<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPMSG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2094"></a>MSPMSG.C</h2>
<pre><code>/* <br> *  M S P M S G . C <br> * <br> *  Code for the MAPI Sample Store Provider implementation of the <br> *  IMessage object.  The implementation is, in fact, a thin <br> *  wrapping layer around the implementation of IMessage on <br> *  IStorage.  We wrap the IMessage object returned by IMsgOnIStg <br> *  so that we can handle those methods (like SubmitMessage) not <br> *  understood by a standalone message (e.g. one embedded in a word <br> *  document) but which makes sense for a message in the context of <br> *  a message store. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br> <br>#define MSG_ValidateParameters(pobj, intf, method, arglist)     \ <br>        OBJ_ValidateParameters(pobj, intf, method, sizeof(IMSG), &amp;vtblIMSG, arglist) <br> <br>/* Manifest constants */ <br> <br>/* Number of properties to initialize a normal message with */ <br>#define cpropIMSGInit       11 <br>/* Number of properties to initialize a message-in-message with */ <br>#define cpropMsgInMsgInit   3 <br>/* Number of in-memory properties associated with a message object */ <br>#define cpropIMSGInternal   4 <br>/* The property attributes to set on the initial set of message properties */ <br>#define grfpropattrIMSGInit (PROPATTR_MANDATORY | PROPATTR_READABLE) <br> <br>#define IMSG_EnterCriticalSection(pimsg)    OBJ_EnterCriticalSection((POBJ)pimsg) <br>#define IMSG_LeaveCriticalSection(pimsg)    OBJ_LeaveCriticalSection((POBJ)pimsg) <br> <br>typedef enum _mrflavor <br>{ <br>    ENUM_ADD = 1, <br>    ENUM_MODIFY, <br>    ENUM_REMOVE <br>} MRFLAVOR; <br> <br>/* internal functions */ <br>static HRESULT HrSaveMsgInMsg(PIMSG pimsg, ULONG ulFlags); <br>static SCODE ScFillOneSBPval(PLMR plmr, LPVOID pvOrigBuf, ULONG ulPropTag, <br>    ULONG cb, LPBYTE lpbData, LPSPropValue pval); <br> <br>/* Global variables */ <br> <br>/* Dispatch table for IMessage objects */ <br>IMSG_Vtbl vtblIMSG = <br>{ <br>    (IMSG_QueryInterface_METHOD *)  OBJ_QueryInterface, <br>    (IMSG_AddRef_METHOD *)          OBJ_AddRef, <br>    (IMSG_Release_METHOD *)         OBJ_Release, <br>    (IMSG_GetLastError_METHOD *)    IMS_GetLastError, <br>    IMSG_SaveChanges, <br>    IMSG_GetProps, <br>    IMSG_GetPropList, <br>    IMSG_OpenProperty, <br>    IMSG_SetProps, <br>    IMSG_DeleteProps, <br>    IMSG_CopyTo, <br>    IMSG_CopyProps, <br>    (IMSG_GetNamesFromIDs_METHOD *) IMS_GetNamesFromIDs, <br>    (IMSG_GetIDsFromNames_METHOD *) IMS_GetIDsFromNames, <br>    IMSG_GetAttachmentTable, <br>    IMSG_OpenAttach, <br>    IMSG_CreateAttach, <br>    IMSG_DeleteAttach, <br>    IMSG_GetRecipientTable, <br>    IMSG_ModifyRecipients, <br>    IMSG_SubmitMessage, <br>    IMSG_SetReadFlag <br>}; <br> <br>/* <br> *  OBJECT METHODS <br> */ <br> <br>/* <br> *  IMSG_SaveChanges <br> * <br> *  Purpose: <br> *      Saves changes made to a message object and all of its <br> *      sub-objects (attachments, et al.). <br> * <br> *  Arguments: <br> *      pimsg       Pointer to the object. <br> *      ulFlags     Flags.  The following are defined: <br> *                  KEEP_OPEN_READONLY  Do not invalidate the <br> *                                      object, make it read-only. <br> *                  KEEP_OPEN_READWRITE Don't invalidate the <br> *                                      object, keep it open <br> *                                      read/write. <br> *                  FORCE_SAVE          Overwrite any changes made by <br> *                                      others since message was openned. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IMSG_SaveChanges(PIMSG pimsg, ULONG ulFlags) <br>{ <br>    HRESULT hr = hrSuccess; <br>    PIFLD pifldParent = NULL;   /* parent as an open folder */ <br>    ULONG ulPropMsgFlags;       /* flags for save on property message */ <br>    ULONG ulChangeType = TABLE_ROW_MODIFIED; <br>    BOOL fUnread = FALSE; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMAPIProp, <br>            SaveChanges, <br>            (pimsg,  <br>            ulFlags)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    /* Handle msg-in-msg separately. */ <br>    if (OBJ_TestFlag(pimsg, MSGF_MSGINMSG)) <br>    { <br>        hr = HrSaveMsgInMsg(pimsg, ulFlags); <br>        goto exit; <br>    } <br> <br>    /* open up lpmsg's parent so we can update tables and contents counts */ <br>    hr = HrOpenParent(pimsg-&gt;pims, pimsg-&gt;peid, MAPI_MODIFY, &amp;pifldParent); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* mark the new message as complete by updating its ENTRYID property */ <br>    if (OBJ_TestFlag(pimsg, MSGF_NEWLYCREATED)) <br>    { <br>        ULONG ulMF; <br>        PEID peidInt = NULL; <br> <br>        ReplaceExt(pimsg-&gt;peid-&gt;szPath, MESSAGE_EXT); <br> <br>        /* Assume that PR_ENTRYID is at position 0 in the in-memory */ <br>        /* array. That's where it went in HrSetInternalProps. */ <br> <br>        AssertSz(pimsg-&gt;pval-&gt;ulPropTag == PR_ENTRYID, <br>            "The location of PR_ENTRYID in the in-memory array has changed"); <br> <br>        peidInt = (PEID) pimsg-&gt;pval-&gt;Value.bin.lpb; <br> <br>        AssertSz(!FIsInvalidEID(pimsg-&gt;pval-&gt;Value.bin.cb, peidInt, NULL), <br>            "Invalid internal Entryid"); <br> <br>        if (peidInt) <br>            ReplaceExt(peidInt-&gt;szPath, MESSAGE_EXT); <br> <br>        /* Now, we need to update PR_INSTANCE_KEY in the same way. Since */ <br>        /* the message is just becoming permanent, it won't be in any */ <br>        /* tables yet, so it can change without affecting any tables. */ <br> <br>        /* NOTE: this code assumes knowledge of the format of */ <br>        /* PR_INSTANCE_KEY. */ <br> <br>        AssertSz(pimsg-&gt;pval[1].ulPropTag == PR_INSTANCE_KEY, "The location " <br>            "of PR_INSTANCE_KEY in the in-memory array has changed"); <br> <br>        peidInt = (PEID) pimsg-&gt;pval[1].Value.bin.lpb; <br> <br>        AssertSz(!FIsInvalidEID(pimsg-&gt;pval[1].Value.bin.cb, peidInt, NULL), <br>            "Invalid internal Entryid"); <br> <br>        if (peidInt) <br>            ReplaceExt(peidInt-&gt;szPath, MESSAGE_EXT); <br> <br>        hr = HrGetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, &amp;pimsg-&gt;pims-&gt;lmr, <br>            PR_MESSAGE_FLAGS, &amp;ulMF); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        /* remember the message's unread status, and to update open tables */ <br> <br>        fUnread = !(ulMF &amp; MSGFLAG_READ); <br>        ulChangeType = TABLE_ROW_ADDED; <br>    } <br> <br>    /* When the spooler saves a message, from the client's perspective, it */ <br>    /* hasn't been modified, because it has just arrived. */ <br> <br>    if (!OBJ_TestFlag(pimsg, MSGF_NEWLYCREATED) <br>        &amp;&amp; !OBJ_TestFlag(pimsg-&gt;pims, MSF_SPOOLER)) <br>    { <br>        /* unset the UNMODIFIED bit */ <br>        hr = HrSetFlags(pimsg, UNSET, PR_MESSAGE_FLAGS, MSGFLAG_UNMODIFIED); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    /* save the changes but keep the property file open */ <br>    ulPropMsgFlags = ulFlags; <br> <br>    if (!(ulFlags &amp; KEEP_OPEN_READWRITE)) <br>        ulPropMsgFlags |= KEEP_OPEN_READONLY; <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;SaveChanges(pimsg-&gt;lpmsg, ulPropMsgFlags); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* update the parent's contents table and parent folder properties */ <br>    if (ulChangeType == TABLE_ROW_ADDED) <br>    { <br>        (void) HrIncrementOneROProp(pifldParent, 1, PR_CONTENT_COUNT); <br> <br>        if (fUnread) <br>            (void) HrIncrementOneROProp(pifldParent, 1, PR_CONTENT_UNREAD); <br>    } <br> <br>    ChangeTable(pimsg-&gt;pims, pifldParent-&gt;peid, pimsg-&gt;peid, MAPI_MESSAGE, <br>        ulChangeType, TRUE); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    UlRelease(pifldParent); <br> <br>    if (hr == hrSuccess) <br>    { <br>        /* Unless the user requests to continue with modify access, switch */ <br>        /* down to read-only access. This means that specifying neither of */ <br>        /* the KEEP_OPEN flags means the same thing as KEEP_OPEN_READONLY. */ <br>        if (!(ulFlags &amp; KEEP_OPEN_READWRITE)) <br>            OBJ_ClearFlag(pimsg, OBJF_MODIFY); <br> <br>        OBJ_ClearFlag(pimsg, MSGF_NEWLYCREATED); <br>    } <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_SaveChanges, hr); <br>    return HrCheckHr(hr, IMAPIProp_SaveChanges); <br>} <br> <br>/* <br> *  IMSG_GetProps <br> * <br> *  Purpose: <br> *      Returns to the caller the value(s) of one or more <br> *      properties existent on an IMSG object.  The order of the <br> *      properties in the returned ppval structure exactly <br> *      matches the order in which the properties were requested in <br> *      ptaga.  The caller must free the returned <br> *      structure by calling MAPIFreeBuffer(*ppval), but <br> *      only if the function returns zero or the error <br> *      MAPI_W_ERRORS_RETURNED.  Uses the IMessage on IStorage <br> *      property interface implementation. <br> * <br> *  Arguments: <br> *      pimsg           Pointer to the object. <br> *      ptaga   Pointer to a counted array of property tags <br> *                      ("names") that identify the values to be <br> *                      returned. <br> *      ulFlags         UNICODE / String8 <br> *      pcval       Location in which to return the count of <br> *                      elements in *ppval. <br> *      ppval   Location in which to return an allocated <br> *                      array of property values (the caller frees <br> *                      by calling MAPIFreeBuffer). <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      If the call succeeded overall but access to one or more <br> *      properties failed, the function returns the warning <br> *      MAPI_W_ERRORS_RETURNED.  The calling application should <br> *      then check the Property Tag of each of the returned <br> *      properties to determine which ones failed.  Those that fail <br> *      have their Property Type set to PT_ERROR and their value (a <br> *      ULONG) indicates which error occurred. <br> * <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_W_ERRORS_RETURNED      See above. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IMSG_GetProps(PIMSG pimsg, LPSPropTagArray ptaga, ULONG ulFlags, <br>    ULONG *pcval, LPSPropValue *ppval) <br>{ <br>    HRESULT hr = hrSuccess; <br>    BOOL fLocked = FALSE; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMAPIProp, <br>            GetProps, <br>            (pimsg,  <br>            ptaga,  <br>            ulFlags,  <br>            pcval,  <br>            ppval)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;GetProps(pimsg-&gt;lpmsg, ptaga, ulFlags, <br>        pcval, ppval); <br> <br>    {if(HR_SUCCEEDED(hr)) <br>    { <br>        LPSPropValue pvalStoreSupMask = PpropFindProp(*ppval, *pcval,  <br>                    PROP_TAG(PT_UNSPECIFIED, PROP_ID(PR_STORE_SUPPORT_MASK))); <br>        if(pvalStoreSupMask) <br>        { <br>            pvalStoreSupMask-&gt;ulPropTag = PR_STORE_SUPPORT_MASK; <br>            pvalStoreSupMask-&gt;Value.l = SMS_SUPPORTMASK; <br> <br>            /* fix up hr */ <br>            if(ptaga-&gt;cValues == 1) <br>                hr = hrSuccess; <br>        } <br>    } <br>    } <br>    /* If not message-in-message then wrap values. */ <br>    /* Note that this wrapping function takes as an */ <br>    /* argument the HRESULT from the previous GetProps call. */ <br>    /* We aren't ignoring the error. */ <br> <br>    if (!OBJ_TestFlag(pimsg, MSGF_MSGINMSG)) <br>        hr = HrWrap_GetProps(hr, pimsg-&gt;pims, pimsg-&gt;cval, pimsg-&gt;pval, <br>            pcval, ppval, FALSE, (ptaga != NULL), (POBJ)pimsg); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    #ifdef DEBUG <br>    if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) <br>        DebugTraceResult(IMSG_GetProps, hr); <br>    #endif <br> <br>    return HrCheckHr(hr, IMAPIProp_GetProps); <br>} <br> <br>/* <br> *  IMSG_GetPropList <br> * <br> *  Purpose: <br> *      Returns a list of all the properties currently accessible. <br> *      Uses the IMessage on IStorage property implementation. <br> * <br> *  Arguments: <br> *      pimsg       Pointer to the object. <br> *      ulFlags     UNICODE / String8 <br> *      pptaga      Location in which to return a pointer <br> *                  to a counted array of property tags. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IMSG_GetPropList(PIMSG pimsg, ULONG ulFlags, LPSPropTagArray *pptaga) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPSPropTagArray ptaga = NULL; <br>    LPSPropTagArray ptagaRet = NULL; <br>    UINT ind; <br>    SizedSPropTagArray(2, sptaToAdd) =  <br>        { 2, <br>            {   PR_MESSAGE_RECIPIENTS,  <br>                PR_MESSAGE_ATTACHMENTS <br>            } <br>        }; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMAPIProp, <br>            GetPropList, <br>            (pimsg,  <br>            ulFlags,  <br>            pptaga)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;GetPropList(pimsg-&gt;lpmsg, ulFlags, &amp;ptaga); <br> <br>    if (hr == hrSuccess &amp;&amp; FIsUnsavedMsg(pimsg)) <br>    { <br>        /* Remove PR_ENTRYID from the array. Since the message is unsaved, */ <br>        /* don't return the entryid. Overwrite the PR_ENTRYID entry with */ <br>        /* the last prop tag in the array. */ <br>        /* //$ Should PR_INSTANCE_KEY be removed from the array too? */ <br> <br>        ULONG *pulPT; <br>        ULONG *pulPTMac; <br> <br>        pulPT = ptaga-&gt;aulPropTag; <br>        pulPTMac = pulPT + ptaga-&gt;cValues; <br> <br>        while (pulPT &lt; pulPTMac) <br>        { <br>            if (*pulPT == PR_ENTRYID) <br>            { <br>                ptaga-&gt;cValues--; <br>                pulPTMac--; <br> <br>                if (pulPT &lt; pulPTMac) <br>                    memcpy(pulPT, pulPTMac, sizeof(ULONG)); <br>                break; <br>            } <br> <br>            ++pulPT; <br>        } <br>    } <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    if(hr == hrSuccess) <br>    { <br>        if(!(hr = ResultFromScode(MAPIAllocateBuffer( <br>                        CbNewSPropTagArray(ptaga-&gt;cValues + sptaToAdd.cValues), <br>                         (LPVOID *)&amp;ptagaRet)))) <br>        { <br>            CopyMemory(ptagaRet, ptaga, CbNewSPropTagArray(ptaga-&gt;cValues)); <br> <br>            for(ind = 0; ind &lt; sptaToAdd.cValues; ++ind) <br>            { <br>                if(!FContainsProp(sptaToAdd.aulPropTag[ind], ptaga)) <br>                { <br>                    ptagaRet-&gt;aulPropTag[ptagaRet-&gt;cValues++] = <br>                        sptaToAdd.aulPropTag[ind]; <br>                } <br>            } <br>             <br>        } <br>    } <br> <br>    MAPIFreeBuffer(ptaga); <br>     <br>    if (hr == hrSuccess) <br>        *pptaga = ptagaRet; <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_GetPropList, hr); <br>    return HrCheckHr(hr, IMAPIProp_GetPropList); <br>} <br> <br>/* <br> *  IMSG_OpenProperty <br> * <br> *  Purpose: <br> *      Open a requested interface on a property for further <br> *      access.  Commonly used for stream access to a large binary <br> *      or text property.  This is the only way to access a <br> *      property of type PT_OBJECT, and may be used on other <br> *      properties depending on the implementation.  Uses the <br> *      IMessage on IStorage property implementation. <br> * <br> *  Arguments: <br> *      pimsg           Pointer to the object. <br> *      ulPropTag   Property tag for the desired property.  Only <br> *                      the ID bits of the tag are used; the type bits <br> *                      are ignored. <br> *      lpiid           Pointer to the GUID identifying which interface <br> *                      is desired. <br> *      ulInterfaceOptions  specifies interface-specific behavior <br> *      ulFlags     MAPI_CREATE, MAPI_MODIFY, MAPI_DEFERRED_ERRORS <br> *      lppUnk      Location in which to return a pointer to the <br> *                      newly created interface pointer. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_INTERFACE_NOT_SUPPORTED      An error occurred opening a <br> *                                          supported interface. <br> */ <br>STDMETHODIMP IMSG_OpenProperty(PIMSG pimsg, ULONG ulPropTag, LPCIID lpiid, <br>    ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN *lppUnk) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMAPIProp, <br>            OpenProperty, <br>            (pimsg,  <br>            ulPropTag,  <br>            lpiid,  <br>            ulInterfaceOptions,  <br>            ulFlags,  <br>            lppUnk)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;OpenProperty(pimsg-&gt;lpmsg, ulPropTag, lpiid, <br>        ulInterfaceOptions, ulFlags, lppUnk); <br> <br>    if (hr == hrSuccess <br>        &amp;&amp; (ulFlags &amp; (MAPI_MODIFY | MAPI_CREATE))) <br>        OBJ_ClearFlag(pimsg, MSGF_FRESH); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_OpenProperty, hr); <br>    return HrCheckHr(hr, IMAPIProp_OpenProperty); <br>} <br> <br>/* <br> *  IMSG_SetProps <br> * <br> *  Purpose: <br> *      Sets the value of one or more properties.  This call passes <br> *      a number of Property Value structures.  The Property Tag in <br> *      each indicates which property is having its values set and <br> *      the value indicates what should be stored.  The caller must <br> *      free the returned property problem structure by calling <br> *      MAPIFreeBuffer(*lppProblems), but only if the call <br> *      succeeded overall.  Uses the IMessage on IStorage property <br> *      implementation. <br> * <br> *  Arguments: <br> *      pimsg           Pointer to the object. <br> *      cValues         Number of values in lpPropArray. <br> *      lpPropArray     Pointer to a Property Value array. <br> *      lppProblems     Location in which to return a pointer to a <br> *                      counted array of property problem <br> *                      structures. <br> * <br> *  Returns: <br> *      HRESULT.  If the call succeeds overall, a zero is returned. <br> *      If there are problems with setting some or all of the <br> *      selected values, and a non-NULL is passed for lppProblems, <br> *      then a SPropProblemArray structure is returned with details <br> *      about each problem.  The value returned in lppProblems is <br> *      only valid if zero is returned in the HRESULT.  If an error <br> *      occurs on the call such that a non-zero value is returned <br> *      for the HRESULT then the contents of *lppProblems are <br> *      undefined.  In particular, do not use or free the structure <br> *      if an error occurs on the call. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_E_CALL_FAILED      A general problem affecting <br> *                                  access to all of the object's <br> *                                  properties occurred. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IMSG_SetProps(PIMSG pimsg, ULONG cValues, LPSPropValue lpPropArray, <br>    LPSPropProblemArray *lppProblems) <br>{ <br>    HRESULT hr; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMAPIProp, <br>            SetProps, <br>            (pimsg,  <br>            cValues,  <br>            lpPropArray,  <br>            lppProblems)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;SetProps(pimsg-&gt;lpmsg, cValues, lpPropArray, <br>        lppProblems); <br> <br>    if (hr == hrSuccess) <br>        OBJ_ClearFlag(pimsg, MSGF_FRESH); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_SetProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_SetProps); <br>} <br> <br>/* <br> *  IMSG_DeleteProps <br> * <br> *  Purpose: <br> *      Deletes the list of properties given in ptaga. <br> *      The caller must free the returned property problem <br> *      structure by calling MAPIFreeBuffer(*ppErr), but only <br> *      if the call succeeded overall.  Uses the IMessage on <br> *      IStorage property implementation. <br> * <br> *  Arguments: <br> *      pimsg           Pointer to the object. <br> *      ptaga   Pointer to an array of Property Tags <br> *                      identifying the properties to delete. <br> *      ppErr       Location in which to return a pointer to a <br> *                      counted array of property problem <br> *                      structures. <br> * <br> *  Returns: <br> *      HRESULT.  If the call succeeds overall, zero is returned. <br> *      If there are problems with deleting some or all of the <br> *      selected values, and a non-NULL is passed for ppErr, <br> *      then a SPropProblemArray structure is returned with details <br> *      about each problem.  The value returned in ppErr is <br> *      only valid if zero is returned in the HRESULT.  If an error <br> *      occurs on the call such that a non-zero value is returned <br> *      for the HRESULT then the contents of *ppErr are <br> *      undefined.  In particular, do not use or free the structure <br> *      if an error occurs on the call. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_E_CALL_FAILED      A general problem affecting <br> *                                  access to all of the object's <br> *                                  properties occurred. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IMSG_DeleteProps(PIMSG pimsg, LPSPropTagArray ptaga, <br>    LPSPropProblemArray *ppErr) <br>{ <br>    HRESULT hr; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMAPIProp, <br>            DeleteProps, <br>            (pimsg,  <br>            ptaga,  <br>            ppErr)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;DeleteProps(pimsg-&gt;lpmsg, ptaga, ppErr); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_DeleteProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_DeleteProps); <br>} <br> <br>/* <br> *  IMSG_CopyTo <br> * <br> *  Purpose: <br> *      Copies the contents of the current object to a destination <br> *      object.  The entire contents, including contained objects, <br> *      are copied, or optionally the caller can provide a list of <br> *      properties that are not to be copied.  Previous information <br> *      in the destination object which is not overwritten by <br> *      copied data is neither deleted nor modified. <br> * <br> *  Arguments: <br> *      pimsg           Pointer to the source object. <br> *      ciidExcl        Count of the excluded interfaces in <br> *                      rgiidExcl. <br> *      rgiidExcl   Array of interface IDs specifying <br> *                      interfaces not to be attempted in trying to <br> *                      copy supplemental information to the <br> *                      destination object. <br> *      ptagaExcl   Counted array of property tags of <br> *                      properties that are not to be copied to the <br> *                      destination object.  NULL indicates all <br> *                      properties are to be copied. <br> *      ulUIParam       Handle of parent window cast to ULONG. <br> *      lpProgress      Callback for doing progress UI. <br> *      piidDst     Interface ID of the interface of lpDestObj, <br> *                      the destination object. <br> *      lpDestObj       Pointer to the open destination object. <br> *      ulFlags         Flags.  Defined as follows: <br> *                      MAPI_MOVE       Indicates a move operation. <br> *                                      The default is to copy. <br> *                      MAPI_NOREPLACE  Indicates that existing <br> *                                      properties should not be <br> *                                      overridden.  The default is <br> *                                      to overwrite existing <br> *                                      properties. <br> *                      MAPI_DIALOG     Display a progress dialog <br> *                                      as the operation proceeds. <br> *                      MAPI_STD_DIALOG Use MAPI standard dialog <br> *                                      instead of <br> *                                      provider-specific dialog. <br> *      ppErr       Pointer to a variable that is filled in <br> *                      with a pointer to a set of property <br> *                      problems.  If NULL, no problem set is <br> *                      returned on an error. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> */ <br>STDMETHODIMP IMSG_CopyTo(PIMSG pimsg, ULONG ciidExcl, LPCIID rgiidExcl, <br>    LPSPropTagArray ptagaExcl, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, <br>    LPCIID piidDst, LPVOID lpDestObj, ULONG ulFlags, <br>    LPSPropProblemArray *ppErr) <br>{ <br>    HRESULT hr; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMAPIProp, <br>            CopyTo, <br>            (pimsg,  <br>            ciidExcl,  <br>            rgiidExcl,  <br>            ptagaExcl,  <br>            ulUIParam,  <br>            lpProgress,  <br>            piidDst,  <br>            lpDestObj,  <br>            ulFlags,  <br>            ppErr)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;CopyTo(pimsg-&gt;lpmsg, ciidExcl, rgiidExcl, <br>        ptagaExcl, ulUIParam, lpProgress, piidDst, lpDestObj, <br>        ulFlags, ppErr); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_CopyTo, hr); <br>    return HrCheckHr(hr, IMAPIProp_CopyTo); <br>} <br> <br>/* <br> *  IMSG_CopyProps <br> * <br> *  Purpose: <br> *      Copies the specified properties of the current object to a destination <br> *      object.  Previous information <br> *      in the destination object which is not overwritten by <br> *      copied data is neither deleted nor modified. <br> * <br> *  Arguments: <br> *      pimsg           Pointer to the source object. <br> *      ptagaIncl       Counted array of property tags of <br> *                      properties that are not to be copied to the <br> *                      destination object.  NULL indicates all <br> *                      properties are to be copied. <br> *      ulUIParam       Handle of parent window cast to ULONG. <br> *      lpProgress      Callback for doing progress UI. <br> *      piidDst         Interface ID of the interface of lpDestObj, <br> *                      the destination object. <br> *      lpDestObj       Pointer to the open destination object. <br> *      ulFlags         Flags.  Defined as follows: <br> *                      MAPI_MOVE       Indicates a move operation. <br> *                                      The default is to copy. <br> *                      MAPI_NOREPLACE  Indicates that existing <br> *                                      properties should not be <br> *                                      overridden.  The default is <br> *                                      to overwrite existing <br> *                                      properties. <br> *                      MAPI_DIALOG     Display a progress dialog <br> *                                      as the operation proceeds. <br> *                      MAPI_DECLINE_OK <br> *      ppErr       Pointer to a variable that is filled in <br> *                      with a pointer to a set of property <br> *                      problems.  If NULL, no problem set is <br> *                      returned on an error. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> */ <br>STDMETHODIMP IMSG_CopyProps(PIMSG pimsg, <br>    LPSPropTagArray ptagaIncl, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, <br>    LPCIID piidDst, LPVOID lpDestObj, ULONG ulFlags, <br>    LPSPropProblemArray *ppErr) <br>{ <br>    HRESULT hr; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMAPIProp, <br>            CopyProps, <br>            (pimsg, <br>            ptagaIncl,  <br>            ulUIParam,  <br>            lpProgress,  <br>            piidDst,  <br>            lpDestObj,  <br>            ulFlags,  <br>            ppErr)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;CopyProps(pimsg-&gt;lpmsg, <br>        ptagaIncl, ulUIParam, lpProgress, piidDst, lpDestObj, <br>        ulFlags, ppErr); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_CopyProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_CopyProps); <br>} <br> <br>/* <br> *  IMSG_GetAttachmentTable <br> * <br> *  Purpose: <br> *      Returns, in table form, the list of attachments contained <br> *      in this message (one row per attachment).  The table has at <br> *      least the PR_ATTACH_NUM and PR_RENDERING_POSITION columns. <br> *      Additional columns may be in the table depending on the <br> *      implementation.  This table may change while it is open if <br> *      the application calls CreateAttach() or DeleteAttach(), or </code></pre>
<p>
</p>
<pre><code>*      if an attachment is modified in a way that some properties <br> *      in the table get changed. <br> * <br> *  Arguments: <br> *      pimsg       Pointer to the object. <br> *      ulFlags     Flags.  Reserved for future use.  Ignored. <br> *      lppTable    Pointer to a variable in which the address of <br> *                  the returned table object is placed. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Unable to allocate memory for <br> *                                  the returned table object or <br> *                                  its underlying data. <br> */ <br>STDMETHODIMP <br>IMSG_GetAttachmentTable(PIMSG pimsg, ULONG ulFlags, LPMAPITABLE *lppTable) <br>{ <br>    HRESULT hr; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMessage, <br>            GetAttachmentTable, <br>            (pimsg,  <br>            ulFlags,  <br>            lppTable)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;GetAttachmentTable(pimsg-&gt;lpmsg, ulFlags, <br>        lppTable); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_GetAttachmentTable, hr); <br>    return HrCheckHr(hr, IMessage_GetAttachmentTable); <br>} <br> <br>/* <br> *  IMSG_OpenAttach <br> * <br> *  Purpose: <br> *      Opens an existing attachment and returns a pointer which <br> *      provides further access to the open attachment.  We get a <br> *      pointer to the attachment object from the IMessage on <br> *      IStorage implementation, and then wrap it with our own <br> *      attachment object. <br> * <br> *  Arguments: <br> *      pimsg           Pointer to the object. <br> *      ulAttachmentNum Number of the attachment to be opened (the <br> *                      value of this parameter comes from the <br> *                      attachment table. <br> *      piidDst     IID of interface requested for the <br> *                      newly-opened object.  NULL or IID_IMAPIProp <br> *                      means to open the object using the standard <br> *                      MAPI 1.0 interface for the object. <br> *                      IID_IUnknown means to open it using <br> *                      the easiest interface you can open. <br> *      ulFlags         Flags.  The following are defined: <br> *                      MAPI_MODIFY     Write access is desired. <br> *                                      The message must also be <br> *                                      open for write access. <br> *      lppAttach       Pointer to a variable which is to receive <br> *                      the pointer to the open attachment object. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      IStorage errors, plus, <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the new attachment instance. <br> */ <br>STDMETHODIMP IMSG_OpenAttach(PIMSG pimsg, ULONG ulAttachmentNum, LPCIID piidDst, <br>    ULONG ulFlags, LPATTACH *lppAttach) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPATTACH lpattach = NULL; <br>    PIATCH piatch = NULL; <br>    BOOL fModify; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMessage, <br>            OpenAttach, <br>            (pimsg,  <br>            ulAttachmentNum,  <br>            piidDst,  <br>            ulFlags,  <br>            lppAttach)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    /* Check for modification rights on the message. Switch to read-only */ <br>    /* if the client asked for best access. */ <br> <br>    if (ulFlags &amp; MAPI_BEST_ACCESS) <br>        fModify = !!OBJ_TestFlag(pimsg, OBJF_MODIFY); <br>    else <br>    { <br>        fModify = !!(ulFlags &amp; MAPI_MODIFY); <br> <br>        if (fModify &amp;&amp; !OBJ_TestFlag(pimsg, OBJF_MODIFY)) <br>        { <br>            hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>            goto exit; <br>        } <br>    } <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;OpenAttach(pimsg-&gt;lpmsg, ulAttachmentNum, <br>        piidDst, ulFlags, &amp;lpattach); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrNewIATCH(lpattach, pimsg, fModify, &amp;piatch); <br> <br>    UlRelease(lpattach); <br>    lpattach = NULL; <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    *lppAttach = (LPATTACH) piatch; <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    if (hr != hrSuccess) <br>        UlRelease(piatch); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_OpenAttach, hr); <br>    return HrCheckHr(hr, IMessage_OpenAttach); <br>} <br> <br>/* <br> *  IMSG_CreateAttach <br> * <br> *  Purpose: <br> *      Creates a new attachment in a message and returns a pointer <br> *      which provides further access to the open attachment.  We <br> *      get a pointer to the attachment object from the IMessage on <br> *      IStorage implementation, and then wrap it with our own <br> *      attachment object. <br> * <br> *  Arguments: <br> *      pimsg               Pointer to the object. <br> *      piidDst         IID of interface requested for the <br> *                          newly-opened object.  NULL or IID_IMAPIProp <br> *                          means to open the object using the standard <br> *                          MAPI 1.0 interface for the object. <br> *                          IID_IUnknown means to open it using <br> *                          the easiest interface you can open. <br> *      ulFlags             Flags.  Reserved for future use. <br> *                          Ignored. <br> *      lpulAttachmentNum   Pointer to a variable which is to <br> *                          receive the number of the newly created <br> *                          attachment.  This number is valid only <br> *                          within this message. <br> *      lppAttach           Pointer to a variable which is to <br> *                          receive the pointer to the open <br> *                          attachment object. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      IStorage errors, plus, <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the new attachment instance. <br> */ <br>STDMETHODIMP IMSG_CreateAttach(PIMSG pimsg, LPCIID piidDst, ULONG ulFlags, <br>    ULONG *lpulAttachmentNum, LPATTACH *lppAttach) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPATTACH lpattach = NULL; <br>    PIATCH piatch = NULL; <br>    ULONG ulAttachNum = 0L; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMessage, <br>            CreateAttach, <br>            (pimsg,  <br>            piidDst,  <br>            ulFlags,  <br>            lpulAttachmentNum,  <br>            lppAttach)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    if (!OBJ_TestFlag(pimsg, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;CreateAttach(pimsg-&gt;lpmsg, piidDst, <br>        ulFlags, &amp;ulAttachNum, &amp;lpattach); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Wrap the attachment object returned by IMessage. */ <br> <br>    hr = HrNewIATCH(lpattach, pimsg, TRUE, &amp;piatch); <br> <br>    UlRelease(lpattach); <br>    lpattach = NULL; <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    *lpulAttachmentNum = ulAttachNum; <br>    *lppAttach = (LPATTACH) piatch; <br> <br>    OBJ_ClearFlag(pimsg, MSGF_FRESH); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    if (hr != hrSuccess) <br>        UlRelease(piatch); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_CreateAttach, hr); <br>    return HrCheckHr(hr, IMessage_CreateAttach); <br>} <br> <br>/* <br> *  IMSG_DeleteAttach <br> * <br> *  Purpose: <br> *      Deletes an attachment in a message.  The current <br> *      application should release all pointers to an attachment <br> *      and its streams prior to deleting the attachment.  Deleted <br> *      attachments are not permanently gone until changes to the <br> *      message are saved. <br> * <br> *  Arguments: <br> *      pimsg               Pointer to the object. <br> *      ulAttachmentNum     Index of the attachment to be deleted. <br> *      ulUIParam           Window handle cast to a ULONG. <br> *      lpProgress          Callback for displaying progress UI. <br> *      ulFlags             Flags.  Reserved for future use. <br> *                          Ignored. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      Invalidates all pointers to the attachment, if it is <br> *      currently open (this is done by the IMessage on IStorage <br> *      implementation).  These invalidated sub-objects then only <br> *      support the Release, AddRef, and QueryInterface methods. <br> * <br> *  Errors: <br> *      IStorage errors (MAPI_E_WRITE_FAULT, etc.). <br> */ <br>STDMETHODIMP IMSG_DeleteAttach(PIMSG pimsg, ULONG ulAttachmentNum, <br>    ULONG ulUIParam, LPMAPIPROGRESS lpProgress, ULONG ulFlags) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMessage, <br>            DeleteAttach, <br>            (pimsg,  <br>            ulAttachmentNum,  <br>            ulUIParam,  <br>            lpProgress,  <br>            ulFlags)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    if (!OBJ_TestFlag(pimsg, OBJF_MODIFY)) <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>    else <br>        hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;DeleteAttach(pimsg-&gt;lpmsg, ulAttachmentNum, <br>            ulUIParam, lpProgress, ulFlags); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_DeleteAttach, hr); <br>    return HrCheckHr(hr, IMessage_DeleteAttach); <br>} <br> <br>/* <br> *  IMSG_GetRecipientTable <br> * <br> *  Purpose: <br> *      Opens the recipient table in a message.  The recipient <br> *      table for a received message or a message under composition <br> *      contains one row for each recipient of the message.  The <br> *      table will have at least the following columns:  PR_ROWID, <br> *      PR_DISPLAY_NAME, PR_ENTRYID, PR_RECIPIENT_TYPE.  The <br> *      additional properties PR_ADDRTYPE, PR_SENDER_NAME, <br> *      PR_SENDER_ENTRYID, and PR_CLIENT_SUBMIT_TIME will appear in sent <br> *      messages (messages not under composition).  Additional <br> *      columns may be in the table, depending on the <br> *      implementation. <br> * <br> *  Arguments: <br> *      pimsg       Pointer to the object. <br> *      ulFlags     Flags.  Reserved for future use.  Ignored. <br> *      lppTable    Pointer to a variable in which the address of <br> *                  the returned table object is placed. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Unable to allocate memory for <br> *                                  the returned table object or <br> *                                  its underlying data. <br> */ <br>STDMETHODIMP IMSG_GetRecipientTable(PIMSG pimsg, ULONG ulFlags, <br>    LPMAPITABLE *lppTable) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMessage, <br>            GetRecipientTable, <br>            (pimsg,  <br>            ulFlags,  <br>            lppTable)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;GetRecipientTable(pimsg-&gt;lpmsg, ulFlags, <br>        lppTable); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_GetRecipientTable, hr); <br>    return HrCheckHr(hr, IMessage_GetRecipientTable); <br>} <br> <br>/* <br> *  IMSG_ModifyRecipients <br> * <br> *  Purpose: <br> *      Adds, deletes, and/or modifies the recipients in a message. <br> *      The property set for each recipient being added or modified <br> *      must include a PR_ROWID, PR_DISPLAY_NAME, PR_ADDRTYPE (it <br> *      may be empty), PR_ENTRYID (it may be empty), and <br> *      PR_RECIPIENT_TYPE.  Additional properties may be specified, <br> *      but depending on the implementation they may be ignored or <br> *      discarded. <br> * <br> *      The recipient table may be used to represent both <br> *      "resolved" and "unresolved" entries.  An unresolved entry <br> *      is one that consists only of a display name.  Applications <br> *      which allow users to type recipient names directly will <br> *      create these entries.  A resolved entry contains more <br> *      information relating the display name to a recipient:  an <br> *      email address type and an EntryID.  Unresolved entries are <br> *      stored as entries with zero as a value for PR_ENTRYID and <br> *      PR_ADDRTYPE.  A message with unresolved entries in the <br> *      recipient table will generate a non-delivery-report if <br> *      submitted. <br> * <br> *  Parameters <br> *      pimsg       pointer to message object <br> *      ulFlags     flags:  MESSAGE_REPLACE <br> *      lpMods      Pointer to list of recipient modifications, additions, or <br> *                  deletions to be performed on pimsg <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      This method converts all short-term EntryIDs to long-term <br> *      EntryIDs. <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IMSG_ModifyRecipients(PIMSG pimsg, ULONG ulFlags, LPADRLIST lpMods) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMessage, <br>            ModifyRecipients, <br>            (pimsg,  <br>            ulFlags,  <br>            lpMods)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;ModifyRecipients(pimsg-&gt;lpmsg, ulFlags, lpMods); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_ModifyRecipients, hr); <br>    return HrCheckHr(hr, IMessage_ModifyRecipients); <br>} <br> <br>/* <br> *  IMSG_SubmitMessage <br> * <br> *  Purpose: <br> *      Mark a message as ready for sending and saves all changes <br> *      to it and all its attachments.  Since this is not <br> *      implemented in IMessage on IStorage, we must do it <br> *      ourselves. <br> * <br> *  Arguments: <br> *      pimsg       Pointer to the object. <br> *      ulFlags     Flags.  Defined as follows: <br> *                  FORCE_SUBMIT    If set, MAPI should submit the <br> *                                  message even if it might not be <br> *                                  sent right away. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      If the submission is successful, the pointer to the message <br> *      and all associated sub-objects (messages, attachments, <br> *      streams, tables) are no longer valid, except for their <br> *      Release() methods.  No other operations on these pointers <br> *      are permitted.  MAPI expects the application to release the <br> *      message object and all associated sub-objects. <br> * <br> *  Errors: <br> *      MAPI_E_NON_STANDARD     Unexpected queueing time is <br> *                              possible.  This error is only <br> *                              returned if the FORCE_SUBMIT flag <br> *                              is not set. <br> */ <br>STDMETHODIMP IMSG_SubmitMessage(PIMSG pimsg, ULONG ulFlags) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMAPITABLE pmtRecip = NULL; <br>    PIMS pims; <br>    ULONG ulcRow = 0L; <br>    ULONG cValues = 0L; <br>    LPSPropValue pval = NULL; <br>    ULONG ulMF; <br>    LPSPropProblemArray pprba = NULL; <br>    SYSTEMTIME st; <br>    FILETIME ft; <br>    ULONG ulPrepareFlags; <br>    ULONG ulPreprocess; <br>    LPSRowSet prws = NULL; <br> <br>#define NUM_FLAGTIME    3 <br>    const static SizedSPropTagArray(NUM_FLAGTIME, proptagFlagTime) = <br>    { <br>        NUM_FLAGTIME, <br>        { <br>            PR_MESSAGE_FLAGS, <br>            PR_CLIENT_SUBMIT_TIME, <br>            PR_SUBMIT_FLAGS <br>        } <br>    }; <br>#define NUM_RECIP_COLS  2 <br>    const static SizedSPropTagArray(NUM_RECIP_COLS, proptagRecips) = <br>    { <br>        NUM_RECIP_COLS, <br>        { <br>            PR_ROWID,           /* make sure this stays first */ <br>            PR_RESPONSIBILITY <br>        } <br>    }; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMessage, <br>            SubmitMessage, <br>            (pimsg,  <br>            ulFlags)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    pims = pimsg-&gt;pims; <br> <br>    if (OBJ_TestFlag(pimsg, MSGF_MSGINMSG)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>        goto exit; <br>    } <br> <br>    if (!OBJ_TestFlag(pimsg, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* Get message flag to check for resubmit. */ <br> <br>    hr = HrGetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, &amp;pims-&gt;lmr, <br>        PR_MESSAGE_FLAGS, &amp;ulMF); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Check to see if the message was already submitted. If so, clear the */ <br>    /* Preprocess bit in PR_SUBMIT_FLAGS, save the message, and update the */ <br>    /* outgoing queue. */ <br> <br>    if (ulMF &amp; MSGFLAG_SUBMIT) <br>    { <br>        ULONG ulSF; <br> <br>        AssertSz(OBJ_TestFlag(pimsg-&gt;pims, MSF_SPOOLER), <br>            "Message being resubmitted by other than the spooler"); <br>         <br>        hr = HrGetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, &amp;pims-&gt;lmr, <br>            PR_SUBMIT_FLAGS, &amp;ulSF); <br>        if (hr != hrSuccess) <br>        { <br>            if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>            { <br>                TraceSz1 ("SAMPLE MS: IMSG_SubmitMessage: Error %s getting " <br>                    "PR_SUBMIT_FLAGS during resubmit.", <br>                    SzDecodeScode(GetScode(hr))); <br> <br>                hr = hrSuccess; <br>                ulSF = 0; <br>            } <br>            else <br>                goto exit; <br>        } <br> <br>        ulSF &amp;= ~SUBMITFLAG_PREPROCESS; <br> <br>        hr = HrSetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, &amp;pims-&gt;lmr, <br>            PR_SUBMIT_FLAGS, &amp;ulSF); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br>    else <br>    { <br>        /* Begin by making sure that all recipients have a PR_RESPONSIBILITY */ <br>        /* property. If they don't, we need to put it in. */ <br>     <br>        hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;GetRecipientTable(pimsg-&gt;lpmsg, 0L, <br>            &amp;pmtRecip); <br>        if (hr != hrSuccess) <br>            goto exit; <br>     <br>        /* Get all columns and ensure that the PR_ROWID and PR_RESPONSIBILITY */ <br>        /* columns are the first two table columns using the MAPI API function */ <br>        /* HrAddColumns. */ <br>     <br>        hr = HrAddColumns(pmtRecip, (LPSPropTagArray) &amp;proptagRecips, <br>            pims-&gt;lmr.lpAllocBuf, pims-&gt;lmr.lpFreeBuf); <br>        if (hr != hrSuccess) <br>            goto exit; <br>     <br>        /* Check for PR_RESPONSIBILITY in each table row and set it if it's */ <br>        /* missing. */ <br>     <br>        while (TRUE) <br>        { <br>            LPSRow prw; <br>            LPSRow prwMac; <br>            LPSPropValue pvalT; <br>     <br>            /* Get 10 rows at a time. In general, GetRowCount may not */ <br>            /* be supported by every provider. This loop does not count */ <br>            /* on it working, even though I know that it would in this */ <br>            /* implementation. */ <br>     <br>            hr = pmtRecip-&gt;lpVtbl-&gt;QueryRows(pmtRecip, 10, 0L, &amp;prws); <br>            if (hr != hrSuccess) <br>                goto exit; <br>     <br>            /* All table implementations will return zero rows from QueryRows */ <br>            /* when you're actually at the end of the table. This routine */ <br>            /* uses that to test when to exit this loop. Note that this loop */ <br>            /* doesn't need to check for no recipients at all, because */ <br>            /* ExpandRecips (below) will do that as part of its processing. */ <br>            if (prws-&gt;cRows == 0) <br>                break; <br>     <br>            prw = prws-&gt;aRow; <br>            prwMac = prw + prws-&gt;cRows; <br>     <br>            /* Loop through the rows. For each row, put in PR_RESPONSIBILITY */ <br>            /* if it's missing. Don't change recipients that already have */ <br>            /* a PR_RESPONSIBILITY property (due to resubmission). */ <br>     <br>            while (prw &lt; prwMac) <br>            { <br>                AssertSz(prw-&gt;cValues &gt;= NUM_RECIP_COLS, <br>                    "Bad # of values returned"); <br>         <br>                pvalT = prw-&gt;lpProps; <br>         <br>                AssertSz(!IsBadReadPtr(pvalT, (UINT) prws-&gt;aRow-&gt;cValues <br>                    * sizeof(SPropValue)), "Bad pval array"); <br>         <br>                /* PR_ROWID is in column zero. Leave it alone, and start */ <br>                /* with the next column. */ <br>                ++pvalT; <br>         <br>                /* We don't ever want responsibility for any recipient. */ <br>                /* If this isn't the spooler calling, then force ALL */ <br>                /* responsibilities to FALSE regardless of what they were. */ <br>                if (PROP_TYPE(pvalT-&gt;ulPropTag) == PT_NULL <br>                    || !OBJ_TestFlag(pimsg-&gt;pims, MSF_SPOOLER)) <br>                { <br>                    pvalT-&gt;ulPropTag = PR_RESPONSIBILITY; <br>                    pvalT-&gt;Value.b = FALSE; <br>                } <br>     <br>                ++prw; <br>            } <br>     <br>            /* modify the rows */ <br>            hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;ModifyRecipients(pimsg-&gt;lpmsg, <br>                MODRECIP_MODIFY, (LPADRLIST) prws); <br>            if (hr != hrSuccess) <br>                goto exit; <br>     <br>            FreeProws(prws); <br>            prws = NULL; <br>        } <br>     <br>        /* We're done with the recip table now, so release it. */ <br>        UlRelease(pmtRecip); <br>        pmtRecip = NULL; <br>     <br>        ulPrepareFlags = 0; <br>     <br>        hr = pims-&gt;psup-&gt;lpVtbl-&gt;PrepareSubmit(pims-&gt;psup, pimsg-&gt;lpmsg, <br>            &amp;ulPrepareFlags); <br>        if (hr != hrSuccess) <br>            goto exit; <br>     <br>        /* ExpandRecips checks for no recip, and will return an error. */ <br>        /* Therefore, this code doesn't need to check here for that case. */ <br>     <br>        hr = pims-&gt;psup-&gt;lpVtbl-&gt;ExpandRecips(pims-&gt;psup, pimsg-&gt;lpmsg, <br>            &amp;ulPreprocess); <br>        if (hr != hrSuccess) <br>            goto exit; <br>     <br>        /* Now, your store provider, if it wishes, may take responsibility */ <br>        /* for any recipients that it wishes to handle. (For example, if */ <br>        /* it is tightly coupled to a transport.) */ <br>     <br>        /* Get the time to add to the message as PR_CLIENT_SUBMIT_TIME */ <br>        GetSystemTime(&amp;st); <br>        SideAssert(SystemTimeToFileTime(&amp;st, &amp;ft)); <br>     <br>        /* get the old values of PR_MESSAGE_FLAGS &amp; PR_CLIENT_SUBMIT_TIME */ <br>     <br>        hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;GetProps(pimsg-&gt;lpmsg, <br>            (LPSPropTagArray) &amp;proptagFlagTime, 0, /* ansi */ <br>            &amp;cValues, &amp;pval); <br>        if (HR_FAILED(hr)) <br>            goto exit; <br>     <br>        /* Warnings are OK from GetProps here. */ <br>     <br>        /* turn on the MSGFLAG_SUBMIT bit of PR_MESSAGE_FLAGS */ <br>        pval[0].ulPropTag = PR_MESSAGE_FLAGS; <br>        pval[0].Value.l = pval[0].Value.l | MSGFLAG_SUBMIT; <br>     <br>        /* set the client submission time */ <br>        pval[1].ulPropTag = PR_CLIENT_SUBMIT_TIME; <br>        pval[1].Value.ft = ft; <br>     <br>        /* set the submit flag. If necessary, turn on the preprocess flag */ <br>        pval[2].ulPropTag = PR_SUBMIT_FLAGS; <br>     <br>        if (ulPreprocess &amp; NEEDS_PREPROCESSING) <br>            pval[2].Value.l = SUBMITFLAG_PREPROCESS; <br>        else <br>            pval[2].Value.l = 0L; <br>     <br>        hr = pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;SetProps(pimsg-&gt;lpmsg, NUM_FLAGTIME, pval, <br>            &amp;pprba); <br>        if (hr != hrSuccess || pprba) <br>            goto exit; <br>    } <br> <br>    hr = pimsg-&gt;lpVtbl-&gt;SaveChanges(pimsg, KEEP_OPEN_READWRITE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* add or update (for resubmit) the message in the outgoing queue */ <br>    hr = HrUpdateOutgoingQueue(pims, pimsg, NULL, TABLE_ROW_ADDED); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    if (pprba) <br>    { <br>        LMFree(&amp;pims-&gt;lmr, pprba); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>    } <br> <br>    UlRelease(pmtRecip); <br>    LMFree(&amp;pims-&gt;lmr, pval); <br>    FreeProws(prws); <br> <br>    if (hr == hrSuccess) <br>        OBJ_ClearFlag(pimsg, MSGF_NEWLYCREATED | OBJF_MODIFY); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_SubmitMessage, hr); <br>    return HrCheckHr(hr, IMessage_SubmitMessage); <br>} <br> <br>/* <br> *  IMSG_SetReadFlag <br> * <br> *  Purpose: <br> *      Sets the MSGFLAG_READ bit in the PR_MESSAGE_FLAGS property. <br> *      In addition, it sends a read report to the originator, if <br> *      appropriate.  A read report is only sent if the originator <br> *      of the message requested it.  Applications generally cannot <br> *      determine if a read report has been requested. <br> * <br> *  Arguments: <br> *      pimsg       Pointer to the object. <br> *      ulFlags     Flags.  SUPPRESS_RECEIPT <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      In order to generate a read report, a new message is <br> *      created which gets filled in by MAPI and then submitted. <br> *      This message will be in the same folder as pimsg, and will <br> *      have the same filename, except that it will have the read <br> *      receipt filename extension (.rrt) instead of the normal <br> *      message filename extension (.msg). <br> * <br> *  Errors: <br> *      All errors associated with property modification, message <br> *      creation, or message submission. <br> */ <br>STDMETHODIMP IMSG_SetReadFlag(PIMSG pimsg, ULONG ulFlags) <br>{ <br>    HRESULT hr; <br>    LPTSTR szFull = NULL; <br>    PEID peidCopy = NULL; <br>    PIMSG pimsgRRT = NULL; <br>    PIFLD pifldParent = NULL; <br>    ULONG ulObjType = 0L; <br>    PEID peidCopyFld = NULL; <br>    ULONG ulSeqNumber; <br>    PLMR plmr; <br>    WORD fRR; <br>    ULONG ulMF; <br>    LONG lUnreadChange; <br> <br>    MSG_ValidateParameters( <br>            pimsg, <br>            IMessage, <br>            SetReadFlag, <br>            (pimsg,  <br>            ulFlags)); <br> <br>    IMSG_EnterCriticalSection(pimsg); <br> <br>    plmr = &amp;pimsg-&gt;pims-&gt;lmr; <br> <br>    hr = HrGetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, plmr, PR_MESSAGE_FLAGS, <br>        &amp;ulMF); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* if the flag is already set correctly, don't do anything. */ <br>    if (ulFlags &amp; CLEAR_READ_FLAG) <br>    { <br>        if (!(ulMF &amp; MSGFLAG_READ)) <br>            goto exit; <br>        ulMF &amp;= ~MSGFLAG_READ; <br> <br>        lUnreadChange = 1; <br>    } <br>    else <br>    { <br>        if (ulMF &amp; MSGFLAG_READ) <br>            goto exit; <br>        else <br>            ulMF |= MSGFLAG_READ; <br> <br>        lUnreadChange = -1; <br>    } <br> <br>    hr = HrSetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, plmr, PR_MESSAGE_FLAGS, &amp;ulMF); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrOpenParent(pimsg-&gt;pims, pimsg-&gt;peid, MAPI_MODIFY, &amp;pifldParent); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* see if read receipts are requested */ <br>    hr = HrGetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, plmr, <br>        PR_READ_RECEIPT_REQUESTED, &amp;fRR); <br> <br>    if (hr == hrSuccess <br>        &amp;&amp; !(ulFlags &amp; SUPPRESS_RECEIPT) <br>        &amp;&amp; fRR <br>        &amp;&amp; lUnreadChange == -1) <br>    { <br>        PIFLD pifldRoot = NULL; <br>        ULONG ulObjType; <br> <br>        NFSideAssertSz(pimsg-&gt;peid, <br>            "PR_READ_RECEIPT_REQUESTED set on a message in a message "); <br> <br>        /* Open the root folder */ <br>        hr = pimsg-&gt;pims-&gt;lpVtbl-&gt;OpenEntry(pimsg-&gt;pims, 0, NULL, <br>            NULL, 0L, &amp;ulObjType, (LPUNKNOWN *) &amp;pifldRoot); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        Assert(ulObjType == MAPI_FOLDER); <br> <br>        /* Create a read receipt message in the root folder and call */ <br>        /* IMAPISupport::ReadReceipt */ <br> <br>        hr = HrNewEID(pifldRoot, pimsg-&gt;pims, READRECEIPT_EXT, <br>            &amp;ulSeqNumber, &amp;peidCopy); <br> <br>        UlRelease(pifldRoot); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = HrNewIMSG(peidCopy, pimsg-&gt;pims, TRUE, TRUE, ulSeqNumber, <br>                &amp;szFull, &amp;pimsgRRT); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = InitIMSGProps(pimsgRRT); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = pimsg-&gt;pims-&gt;psup-&gt;lpVtbl-&gt;ReadReceipt(pimsg-&gt;pims-&gt;psup, 0L, <br>            (LPMESSAGE) pimsg, (LPMESSAGE *) &amp;pimsgRRT); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        /* If ReadReceipt didn't release and NULL the returned message, */ <br>        /* then submit it. */ <br> <br>        if (pimsgRRT) <br>        { <br>            hr = pimsgRRT-&gt;lpVtbl-&gt;SubmitMessage(pimsgRRT, FORCE_SUBMIT); <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br>    } <br> <br>    hr = pimsg-&gt;lpVtbl-&gt;SaveChanges(pimsg, KEEP_OPEN_READWRITE); <br>    if (HR_FAILED(hr)) <br>        goto exit; <br> <br>    /* Update the folder properties file -- WARNING:  if we fail from   */ <br>    /* now until the end of the procedure, the folder unread count will */ <br>    /* be inconsistent with the actual unread messages in this folder,  */ <br>    /* and we have no transactional way of backing out changes.         */ <br>    /* don't change folder properties for a message in a message        */ <br> <br>    if (!OBJ_TestFlag(pimsg, MSGF_MSGINMSG)) <br>    { <br>        hr = HrIncrementOneROProp(pifldParent, lUnreadChange, PR_CONTENT_UNREAD); <br> <br>        #ifdef DEBUG <br>        if (HR_FAILED(hr)) <br>            TraceSz1("Sample MS: IMSG_SetReadFlag: error %s changing the " <br>                "unread count on a folder.", SzDecodeScode(GetScode(hr))); </code></pre>
<p>
</p>
<pre><code>#endif <br> <br>        /* Ignore the error. It isn't fatal. */ <br>        hr = hrSuccess; <br>    } <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    UlRelease(pimsgRRT); <br> <br>    FreeNull(szFull); <br>    LMFree(plmr, peidCopy); <br>    LMFree(plmr, peidCopyFld); <br>    UlRelease(pifldParent); <br> <br>    IMSG_LeaveCriticalSection(pimsg); <br> <br>    DebugTraceResult(IMSG_SetReadFlag, hr); <br>    return HrCheckHr(hr, IMessage_SetReadFlag); <br>} <br> <br>/* <br> *  External functions (called from outside of this file). <br> */ <br> <br>/* <br> *  HrNewIMSG <br> * <br> *  Purpose: <br> *      Allocates and initializes an IMSG object (internal <br> *      implementation of IMessage).  Optionally creates storage <br> *      for the object (else it tries to open existing storage). <br> * <br> *  Arguments: <br> *      peid        Internal form of EntryID for message. <br> *      pims        Message Store in which this message resides. <br> *      fCreate     Boolean. TRUE means to create the storage for this message. <br> *      fModify     Boolean. TRUE means to open the message for writing. <br> *      ulSeqNum    The sequence number of the entryid. <br> *      pszFull     Location in which to return the full pathname to the <br> *                  file created or opened. If NULL, don't return the path. <br> *      ppimsg      Location in which to return a pointer to the <br> *                  newly created IMSG instance. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the IMSG instance. <br> */ <br>HRESULT HrNewIMSG(PEID peid, PIMS pims, BOOL fCreate, BOOL fModify, <br>    ULONG ulSeqNum, LPSTR *pszFull, PIMSG *ppimsg) <br>{ <br>    HRESULT hr; <br>    LPTSTR szFull = NULL; <br> <br>    LPMESSAGE lpmsg = NULL; <br>    PEID peidCopy = NULL; <br>    ULONG cbeid; <br>    PIMSG pimsgNew = NULL; <br>    BOOL fDoneCreate = FALSE; <br>    SCODE sc = S_OK; <br>    PEID peidParent = NULL; <br> <br>    AssertSz(peid, "Bad peid"); <br>    AssertSz(pims, "Bad pims"); <br>    AssertSz(ppimsg, "Bad ppimsg"); <br> <br>    /* Get all the necessary parts of an IMSG */ <br> <br>    hr = HrFullPathName(pims-&gt;szStorePath, peid-&gt;szPath, NULL, &amp;szFull); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    ReplaceExt(szFull, MESSAGE_EXT); <br> <br>    /* always open the internal message for modification so that */ <br>    /* SetReadFlag will work. */ <br> <br>    hr = HrOpenIMsg(pims-&gt;pmsgsess, szFull, &amp;pims-&gt;lmr, pims-&gt;psup, fCreate, <br>        TRUE, FALSE, &amp;lpmsg); <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (fCreate) <br>        fDoneCreate = TRUE; <br> <br>    cbeid = CbEID(peid); <br>    hr = HrAlloc(cbeid, (PPV) &amp;peidCopy); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    memcpy(peidCopy, peid, (UINT) cbeid); <br> <br>    /* Allocate and initialize IMSG instance */ <br> <br>    sc = LMAllocZ(&amp;pims-&gt;lmr, sizeof(IMSG), &amp;pimsgNew); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    OBJ_Initialize(pimsgNew, &amp;vtblIMSG, OT_MESSAGE, pims, pims-&gt;pcs); <br> <br>    pimsgNew-&gt;peid = peidCopy; <br>    pimsgNew-&gt;lpmsg = lpmsg; <br> <br>    if (fCreate) <br>    { <br>        OBJ_SetFlag(pimsgNew, MSGF_NEWLYCREATED); <br>        OBJ_SetFlag(pimsgNew, MSGF_FRESH); <br>    } <br>    else <br>    { <br>        ULONG ulMF; <br> <br>        hr = HrGetSingleProp((LPMAPIPROP) lpmsg, &amp;pims-&gt;lmr, <br>                PR_MESSAGE_FLAGS, &amp;ulMF); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (fModify <br>            &amp;&amp; (ulMF &amp; MSGFLAG_SUBMIT) <br>            &amp;&amp; !OBJ_TestFlag(pims, MSF_SPOOLER)) <br>        { <br>            hr = ResultFromScode(MAPI_E_SUBMITTED); <br>            goto exit; <br>        } <br>    } <br> <br>    if (fModify) <br>        OBJ_SetFlag(pimsgNew, OBJF_MODIFY); <br> <br>    hr = HrGetParentEID(&amp;pims-&gt;lmr, peid, &amp;peidParent); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrSetInternalProps(&amp;pims-&gt;lmr, cpropIMSGInternal, &amp;(pimsgNew-&gt;pval), <br>            &amp;(pimsgNew-&gt;cval), peid, peidParent, ulSeqNum); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    OBJ_Enqueue((POBJ) pimsgNew, (POBJ) pims); <br> <br>exit: <br>    LMFree(&amp;pims-&gt;lmr, peidParent); <br> <br>    if (hr != hrSuccess) <br>    { <br>        UlRelease(lpmsg); <br>        FreeNull(peidCopy); <br>        if (fDoneCreate) <br>            DeleteFile(szFull); <br> <br>        if (pimsgNew) <br>            LMFree(&amp;pims-&gt;lmr, pimsgNew-&gt;pval); <br> <br>        LMFree(&amp;pims-&gt;lmr, pimsgNew); <br>        FreeNull(szFull); <br>    } <br>    else <br>    { <br>        *ppimsg = pimsgNew; <br> <br>        if (pszFull) <br>            *pszFull = szFull; <br>        else <br>            FreeNull(szFull); <br>    } <br> <br>    DebugTraceResult(HrNewIMSG, hr); <br>    return hr; <br>} <br> <br>/* <br> *  IMSG_Neuter <br> * <br> *  Purpose: <br> *      Neuters an IMSG <br> * <br> *  Parameter <br> *      pimsg       pointer to IMSG to be neutered <br> */ <br>void IMSG_Neuter(PIMSG pimsg) <br>{ <br>    /* Free IMSG object's internal memory */ <br> <br>    UlRelease(pimsg-&gt;lpmsg); <br> <br>    LMFree(&amp;pimsg-&gt;pims-&gt;lmr, pimsg-&gt;pval); <br> <br>    /* delete the file if it was never saved */ <br>    if (OBJ_TestFlag(pimsg, MSGF_NEWLYCREATED)) <br>    { <br>        LPTSTR szFull = NULL;   /* full path name of message */ <br> <br>        /* delete the file */ <br>        if (HrFullPathName(pimsg-&gt;pims-&gt;szStorePath, pimsg-&gt;peid-&gt;szPath, <br>                NULL, &amp;szFull) == hrSuccess) <br>        { <br>            ReplaceExt(szFull, MESSAGE_EXT); <br>            DeleteFile(szFull); <br>            FreeNull(szFull); <br>        } <br>    } <br> <br>    FreeNull(pimsg-&gt;peid); <br>} <br> <br>/* <br> *  NewIMSGInIATCH <br> * <br> *  Purpose: <br> *      Wraps an IMSG object around a message that is contained in <br> *      an attachment (message in message).  A message in message <br> *      has no EntryID, does not expose a PR_STORE_ENTRYID or <br> *      PR_STORE_RECORD_KEY, and cannot be submitted. <br> * <br> *  Arguments: <br> *      lpmsg       Message in message we get back from the <br> *                  IMessage on IStorage implementation. <br> *      pobj        Pointer to the parent object of the msg-in-msg. <br> *      ulFlags     ulFlags from OpenProperty call <br> *      ppimsg      Address in which to place a pointer to the <br> *                  newly created IMSG instance. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the IMSG instance. <br> */ <br>HRESULT NewIMSGInIATCH(LPMESSAGE lpmsg, POBJ pobj, ULONG ulFlags, PIMSG *ppimsg) <br>{ <br>    PIMSG pimsgNew = NULL; <br>    SCODE sc = S_OK; <br>    PIMS pims; <br> <br>    AssertSz(lpmsg, "Bad lpmsg"); <br>    AssertSz(pobj, "Bad pobj"); <br>    AssertSz(ppimsg, "Bad ppimsg"); <br> <br>    pims = pobj-&gt;pims; <br> <br>    /* Allocate and initialize IMSG instance */ <br> <br>    sc = LMAllocZ(&amp;pims-&gt;lmr, sizeof(IMSG), (LPVOID *) &amp;pimsgNew); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    OBJ_Initialize(pimsgNew, &amp;vtblIMSG, OT_MESSAGE, pims, pims-&gt;pcs); <br> <br>    OBJ_SetFlag(pimsgNew, MSGF_MSGINMSG); <br> <br>    if(ulFlags &amp; MAPI_MODIFY) <br>        OBJ_SetFlag(pimsgNew, OBJF_MODIFY); <br> <br>    pimsgNew-&gt;peid = NULL; <br>    pimsgNew-&gt;lpmsg = lpmsg; <br> <br>    OBJ_Enqueue((POBJ) pimsgNew, pobj); <br> <br>    *ppimsg = pimsgNew; <br> <br>exit: <br>    if (sc != S_OK) <br>        LMFree(&amp;pims-&gt;lmr, pimsgNew); <br> <br>    DebugTraceSc(NewIMSGInIATCH, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> *  InitIMSGProps <br> * <br> *  Purpose: <br> *      Sets the initial (and for read-only properties, the only) <br> *      values for the base properties of the Message Object: <br> *      takes as input parameters the values of those properties <br> *      that are specific to this message and derives the values of <br> *      those properties that are identical for all messages in the <br> *      Microsoft Sample Store Provider. <br> * <br> *  Arguments: <br> *      pimsg       Internal IMessage object instance. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the property arrays. <br> */ <br>HRESULT InitIMSGProps(PIMSG pimsg) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPSPropValue pval = NULL; <br>    LPSPropProblemArray pprba = NULL; <br>    LPSPropTagArray ptaga = NULL; <br>    LPSPropAttrArray patra = NULL; <br>    ULONG cpropInit = 0L; <br>    BOOL fMsgInMsg; <br>    MAPIUID uid; <br>    PIMS pims; <br>    LPMESSAGE lpmsg; <br> <br>    AssertSz(pimsg, "Bad pimsg"); <br> <br>    if (OBJ_TestFlag(pimsg, MSGF_MSGINMSG)) <br>    { <br>        AssertSz(pimsg-&gt;peid == NULL, "Msg in msg has no entryid"); <br> <br>        fMsgInMsg = TRUE; <br>        cpropInit = cpropMsgInMsgInit; <br>    } <br>    else <br>    { <br>        fMsgInMsg = FALSE; <br>        cpropInit = cpropIMSGInit; <br>    } <br> <br>    pims = pimsg-&gt;pims; <br>    lpmsg = pimsg-&gt;lpmsg; <br> <br>    /* Allocate the property arrays. */ <br>    hr = HrAllocPropArrays(cpropInit, &amp;pval, &amp;ptaga, &amp;patra); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Initialize property value array and all property tags. */ <br> <br>    ptaga-&gt;cValues = patra-&gt;cValues = cpropInit; <br> <br>    pval[0].ulPropTag = ptaga-&gt;aulPropTag[0] = PR_OBJECT_TYPE; <br>    pval[0].Value.l = MAPI_MESSAGE; <br>    pval[1].ulPropTag = ptaga-&gt;aulPropTag[1] = PR_MESSAGE_FLAGS; <br> <br>    /* When the spooler creates a message, it is arriving into the store. */ <br>    /* Therefore, the message should be unread, sent and unmodified. When */ <br>    /* the client creates a message, it is unsent, read, and unmodified. */ <br> <br>    if (OBJ_TestFlag(pims, MSF_SPOOLER)) <br>        pval[1].Value.l = MSGFLAG_UNMODIFIED; <br>    else <br>        pval[1].Value.l = MSGFLAG_READ | MSGFLAG_UNSENT | MSGFLAG_UNMODIFIED; <br> <br>    pval[2].ulPropTag = ptaga-&gt;aulPropTag[2] = PR_MESSAGE_CLASS; <br>    pval[2].Value.LPSZ = TEXT("IPM"); <br> <br>    if (!fMsgInMsg) <br>    { <br>        hr = pims-&gt;psup-&gt;lpVtbl-&gt;NewUID(pims-&gt;psup, &amp;uid); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        pval[3].ulPropTag = ptaga-&gt;aulPropTag[3] = PR_SEARCH_KEY; <br>        pval[3].Value.bin.cb = sizeof(uid); <br>        pval[3].Value.bin.lpb = (LPBYTE) &amp;uid; <br>        pval[4].ulPropTag = ptaga-&gt;aulPropTag[4] = PR_STORE_ENTRYID; <br>        pval[4].Value.bin.cb = pims-&gt;eidStore.cb; <br>        pval[4].Value.bin.lpb = pims-&gt;eidStore.lpb; <br>        pval[5].ulPropTag = ptaga-&gt;aulPropTag[5] = PR_STORE_RECORD_KEY; <br>        pval[5].Value.bin.cb = sizeof(pims-&gt;uidResource); <br>        pval[5].Value.bin.lpb = (LPBYTE) &amp;pims-&gt;uidResource; <br>        pval[6].ulPropTag = ptaga-&gt;aulPropTag[6] = PR_MSG_STATUS; <br>        pval[6].Value.l = 0; <br> <br>        /* Set PR_ENTRYID, PR_PARENT_ENTRYID, PR_RECORD_KEY and  <br>         * PR_INSTANCE_KEY to null strings to keep clients from writing over <br>         * them. We get the actual values internally. <br>         */ <br>        pval[7].ulPropTag = ptaga-&gt;aulPropTag[7] = PR_ENTRYID; <br>        pval[7].Value.bin.cb = 1; <br>        pval[7].Value.bin.lpb = (LPBYTE) ""; <br>        pval[8].ulPropTag = ptaga-&gt;aulPropTag[8] = PR_PARENT_ENTRYID; <br>        pval[8].Value.bin.cb = 1; <br>        pval[8].Value.bin.lpb = (LPBYTE) ""; <br>        pval[9].ulPropTag = ptaga-&gt;aulPropTag[9] = PR_RECORD_KEY; <br>        pval[9].Value.bin.cb = 1; <br>        pval[9].Value.bin.lpb = (LPBYTE) ""; <br>        pval[10].ulPropTag = ptaga-&gt;aulPropTag[10] = PR_INSTANCE_KEY; <br>        pval[10].Value.bin.cb = 1; <br>        pval[10].Value.bin.lpb = (LPBYTE) ""; <br> <br>        /* this message is not complete until changes have been saved */ <br>        /* mark it as such so that others don't see a partial message */ <br>    } <br> <br>    /* Initialize the property attribute array. */ <br> <br>    patra-&gt;aPropAttr[0] = grfpropattrIMSGInit; <br>    patra-&gt;aPropAttr[1] = grfpropattrIMSGInit | PROPATTR_WRITEABLE; <br>    patra-&gt;aPropAttr[2] = grfpropattrIMSGInit | PROPATTR_WRITEABLE; <br> <br>    if (!fMsgInMsg) <br>    { <br>        patra-&gt;aPropAttr[3] = grfpropattrIMSGInit | PROPATTR_WRITEABLE; <br>        patra-&gt;aPropAttr[4] = grfpropattrIMSGInit; <br>        patra-&gt;aPropAttr[5] = grfpropattrIMSGInit; <br>        patra-&gt;aPropAttr[6] = grfpropattrIMSGInit; <br>        patra-&gt;aPropAttr[7] = grfpropattrIMSGInit; <br>        patra-&gt;aPropAttr[8] = grfpropattrIMSGInit; <br>        patra-&gt;aPropAttr[9] = grfpropattrIMSGInit; <br>        patra-&gt;aPropAttr[10] = grfpropattrIMSGInit; <br>    } <br> <br>    /* Set the property values. */ <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SetProps(lpmsg, cpropInit, pval, &amp;pprba); <br>    if (hr != hrSuccess || pprba) <br>        goto exit; <br> <br>    /* Set the property attributes. */ <br> <br>    hr = SetAttribIMsgOnIStg(lpmsg, ptaga, patra, &amp;pprba); <br>    if (hr != hrSuccess || pprba) <br>        goto exit; <br> <br>    /* If we succeeded up to this point, commit the properties. */ <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, KEEP_OPEN_READWRITE); <br>    /* if (hr), fall through to exit */ <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    if (pprba) <br>    { <br>        LMFree(&amp;pims-&gt;lmr, pprba); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>    } <br> <br>    FreePropArrays(&amp;pval, &amp;ptaga, &amp;patra); <br> <br>    DebugTraceResult(InitIMSGProps, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrSetFlags <br> * <br> *  Purpose <br> *      Set the value of flag bits on a message property. The <br> *      properties that this function is used for are PR_MESSAGE_FLAGS <br> *      and PR_SUBMIT_FLAGS. <br> * <br> *  Parameters <br> *      pimsg       A pointer to the message object. <br> *      ulAction    SET or UNSET <br> *      ulPropTag   the property tag to be changed. <br> *      ulFlag      flags to be set or unset. <br> */ <br>HRESULT HrSetFlags(PIMSG pimsg, ULONG ulAction, ULONG ulPropTag, ULONG ulFlag) <br>{ <br>    HRESULT hr; <br>    LPSPropValue pval = NULL; <br> <br>    AssertSz1(ulPropTag == PR_MESSAGE_FLAGS || ulPropTag == PR_SUBMIT_FLAGS, <br>        "HrSetFlags: not designed for property %s", SzDecodeUlPropTag(ulPropTag)); <br> <br>    AssertSz1((ulAction == SET) || (ulAction == UNSET), "Bad ulAction: %08lX", <br>        ulAction); <br> <br>    /* get the current value of the flag */ <br>    hr = HrGetOneProp((LPMAPIPROP) pimsg, ulPropTag, &amp;pval); <br> <br>    /* compute and set the new value */ <br>    if (HR_SUCCEEDED(hr)) <br>    { <br>        LONG lOldFlag = pval-&gt;Value.l; <br> <br>        if (ulAction &amp; SET) <br>            pval-&gt;Value.l |= ulFlag; <br>        else <br>            pval-&gt;Value.l &amp;= ~ulFlag; <br> <br>        /* If the value that's there is correct, then don't set it. */ <br> <br>        if (pval-&gt;Value.l == lOldFlag) <br>            goto exit; <br>    } <br>    else if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>    { <br>        pval-&gt;Value.l = (ulAction &amp; SET) ? ulFlag : 0L; <br>        pval-&gt;ulPropTag = ulPropTag; <br>    } <br>    else <br>        goto exit; <br> <br>    hr = HrSetOneProp((LPMAPIPROP) pimsg, pval); <br> <br>exit: <br>    LMFree(&amp;pimsg-&gt;pims-&gt;lmr, pval); <br> <br>    return hr; <br>} <br> <br>/* <br> *  HrSetInternalProps <br> * <br> *  Purpose <br> *      Sets up the in-memory array to hold properties that may change <br> *      when the message or folder object is moved or copied. See the <br> *      routine ProcessGetProps in mspmisc.c for details of how this <br> *      array is used. <br> * <br> *  Parameters <br> *      plmr: A pointer to the linked memory allocation routines. <br> *      cprop: The number of properties to set into the in-memory array. <br> *          Note that the properties that are saved in-memory are placed <br> *          into the array in a hard-coded order (see below). Therefore, <br> *          changing cprop to a smaller number eliminates specific props <br> *          from the array. <br> *      ppval: A pointer to the location to place the in-memory pval array. <br> *      pcval: A pointer to the location to place the number of properties <br> *          placed into *ppval. <br> *      peid: The object's entryid that we are saving in-memory props for. <br> *          (Used to get the value for PR_ENTRYID and PR_INSTANCE_KEY). <br> *      peidParent: The entryid of the parent object. (Used to get the value <br> *          for PR_PARENT_ENTRYID). <br> *      ulSeqNum: The value with which to fill PR_RECORD_KEY. (Only used <br> *          on message objects). <br> * <br> *  Returns <br> *      HRESULT. Only errors are from memory allocation failures. <br> */ <br>HRESULT HrSetInternalProps(PLMR plmr, ULONG cprop, LPSPropValue *ppval, <br>    ULONG *pcval, PEID peid, PEID peidParent, ULONG ulSeqNum) <br>{ <br>    LPSPropValue pval = NULL; <br>    LPSPropValue pvalT; <br>    LPSPropValue pvalTMac; <br>    SCODE sc; <br> <br>    AssertSz(*ppval == NULL, "pval already allocated"); <br>    AssertSz(*pcval == 0, "cval already non-zero"); <br> <br>    /* Allocate the property array. */ <br>    sc = LMAlloc(plmr, cprop * sizeof(SPropValue), &amp;pval); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    pvalT = pval; <br>    pvalTMac = pvalT + cprop; <br> <br>    if (pvalT &lt; pvalTMac) <br>    { <br>        sc = ScFillOneSBPval(plmr, (LPVOID) pval, PR_ENTRYID, <br>            CbEID(peid), (LPBYTE) peid, pvalT); <br>        if (sc != S_OK) <br>            goto exit; <br>     <br>        pvalT++; <br>    } <br> <br>    if (pvalT &lt; pvalTMac) <br>    { <br>        sc = ScFillOneSBPval(plmr, (LPVOID) pval, PR_INSTANCE_KEY, <br>            CbEID(peid), (LPBYTE) peid, pvalT); <br>        if (sc != S_OK) <br>            goto exit; <br>     <br>        pvalT++; <br>    } <br> <br>    if (pvalT &lt; pvalTMac) <br>    { <br>        sc = ScFillOneSBPval(plmr, (LPVOID) pval, PR_PARENT_ENTRYID, <br>            CbEID(peidParent), (LPBYTE) peidParent, pvalT); <br>        if (sc != S_OK) <br>            goto exit; <br> <br>        pvalT++; <br>    } <br> <br>    if (pvalT &lt; pvalTMac) <br>    { <br>        sc = ScFillOneSBPval(plmr, (LPVOID) pval, PR_RECORD_KEY, <br>            sizeof(ulSeqNum), (LPBYTE) &amp;ulSeqNum, pvalT); <br>        if (sc != S_OK) <br>            goto exit; <br> <br>        pvalT++; <br>    } <br> <br>    AssertSz(pvalT == pvalTMac, "Not enough values to fill internal array"); <br> <br>    *pcval = cprop; <br>    *ppval = pval; <br> <br>exit: <br>    if (sc != S_OK) <br>        LMFree(plmr, pval); <br> <br>    DebugTraceSc(HrSetInternalProps, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> * Internal functions (called only from within this file). <br> * <br> */ <br> <br>/* HrSaveMsgInMsg <br> * <br> * Perform the necessary steps to save changes on a msg-in-msg type message. <br> * <br> */ <br>static HRESULT HrSaveMsgInMsg(PIMSG pimsg, ULONG ulFlags) <br>{ <br>    ULONG ulPropMsgFlags = ulFlags; <br> <br>    if (!(ulFlags &amp; KEEP_OPEN_READWRITE)) <br>        ulPropMsgFlags |= KEEP_OPEN_READONLY; <br> <br>    return pimsg-&gt;lpmsg-&gt;lpVtbl-&gt;SaveChanges(pimsg-&gt;lpmsg, ulPropMsgFlags); <br>} <br> <br>/* Fills in an SBinary PropValue via AllocMore. */ <br> <br>static SCODE ScFillOneSBPval(PLMR plmr, LPVOID pvOrigBuf, ULONG ulPropTag, <br>    ULONG cb, LPBYTE lpbData, LPSPropValue pval) <br>{ <br>    SCODE sc; <br> <br>    sc = LMAllocMore(plmr, cb, pvOrigBuf, &amp;(pval-&gt;Value.bin.lpb)); <br>    if (sc == S_OK) <br>    { <br>        pval-&gt;ulPropTag = ulPropTag; <br>        pval-&gt;Value.bin.cb = cb; <br>        if (cb) <br>            memcpy(pval-&gt;Value.bin.lpb, lpbData, (UINT) cb); <br>    } <br> <br>    return sc; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
