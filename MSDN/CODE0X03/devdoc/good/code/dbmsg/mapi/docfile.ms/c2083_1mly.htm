<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPATCH.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2086"></a>MSPATCH.C</h2>
<pre><code>/* <br> *  M S P A T C H . C <br> * <br> *  Code for the MAPI Sample Store Provider implementation of the <br> *  IAttach object.  The implementation is, in reality, a thin <br> *  wrapping layer around the implementation of IMessage on <br> *  IStorage.  We wrap the IAttach object returned by IMsgOnIStg so <br> *  that we can handle those methods (like GetLastError) not <br> *  understood by a standalone attachment (e.g. one embedded in a <br> *  word document) but which makes sense for a message in the <br> *  context of a message store. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br> <br>#define ATCH_ValidateParameters(pobj, intf, method, arglist)        \ <br>        OBJ_ValidateParameters(pobj, intf, method, sizeof(IATCH), &amp;vtblIATCH, arglist) <br> <br>#define IATCH_EnterCriticalSection(piatch) OBJ_EnterCriticalSection((POBJ)piatch) <br>#define IATCH_LeaveCriticalSection(piatch) OBJ_LeaveCriticalSection((POBJ)piatch) <br> <br>/* Manifest constants */ <br> <br>#define cInitIATCHProps         3 <br>#define grfInitIATCHPropAttr    (PROPATTR_MANDATORY | PROPATTR_READABLE) <br> <br>/* Global variables */ <br> <br>/* Dispatch table for IAttach objects */ <br>IATCH_Vtbl vtblIATCH = <br>{ <br>    (IATCH_QueryInterface_METHOD *)     OBJ_QueryInterface, <br>    (IATCH_AddRef_METHOD *)             OBJ_AddRef, <br>    (IATCH_Release_METHOD *)            OBJ_Release, <br>    (IATCH_GetLastError_METHOD *)       IMS_GetLastError, <br>    IATCH_SaveChanges, <br>    IATCH_GetProps, <br>    IATCH_GetPropList, <br>    IATCH_OpenProperty, <br>    IATCH_SetProps, <br>    IATCH_DeleteProps, <br>    IATCH_CopyTo, <br>    IATCH_CopyProps, <br>    (IATCH_GetNamesFromIDs_METHOD *)    IMS_GetNamesFromIDs, <br>    (IATCH_GetIDsFromNames_METHOD *)    IMS_GetIDsFromNames <br>}; <br> <br>/* <br> *  Object methods <br> */ <br> <br>/* <br> *  IATCH_SaveChanges <br> * <br> *  Purpose: <br> *      Saves changes made to an attachment object and all of its <br> *      sub-objects (messages, et al.).  Since the IMessage on <br> *      IStorage implementation handles the invalidation of objects <br> *      after SaveChanges is called, we do not need to worry about <br> *      it at this level. <br> * <br> *  Arguments: <br> *      piatch      Pointer to the object. <br> *      ulFlags     Flags.  The following are defined: <br> *                  KEEP_OPEN_READONLY  Do not invalidate the <br> *                                      object, make it read-only. <br> *                  KEEP_OPEN_READWRITE Don't invalidate the <br> *                                      object, keep it open <br> *                                      read/write. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IATCH_SaveChanges(PIATCH piatch, ULONG ulFlags) <br>{ <br>    HRESULT hr; <br>    PIMSG pimsg; <br>    PLMR plmr; <br> <br>    ATCH_ValidateParameters( <br>            piatch, <br>            IMAPIProp, <br>            SaveChanges, <br>            (piatch,  <br>            ulFlags)); <br> <br>    IATCH_EnterCriticalSection(piatch); <br> <br>    pimsg = (PIMSG) piatch-&gt;pobjParent; <br>    plmr = &amp;piatch-&gt;pims-&gt;lmr; <br> <br>    if (!OBJ_TestFlag(piatch, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    hr = piatch-&gt;lpattach-&gt;lpVtbl-&gt;SaveChanges(piatch-&gt;lpattach, ulFlags); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (!(ulFlags &amp; KEEP_OPEN_READWRITE)) <br>        OBJ_ClearFlag(piatch, OBJF_MODIFY); <br> <br>exit: <br>    IATCH_LeaveCriticalSection(piatch); <br> <br>    DebugTraceResult(IATCH_SaveChanges, hr); <br>    return HrCheckHr(hr, IMAPIProp_SaveChanges); <br>} <br> <br>/* <br> *  IATCH_GetProps <br> * <br> *  Purpose: <br> *      Returns to the caller the value(s) of one or more <br> *      properties existent on an IATCH object.  The order of the <br> *      properties in the returned lppPropArray structure exactly <br> *      matches the order in which the properties were requested in <br> *      lpPropTagArray.  The caller must free the returned <br> *      structure by calling MAPIFreeBuffer(*lppPropArray), but <br> *      only if the function returns zero or the error <br> *      MAPI_W_ERRORS_RETURNED.  Uses the IMessage on IStorage <br> *      property interface implementation. <br> * <br> *  Arguments: <br> *      piatch          Pointer to the object. <br> *       ptaga          Pointer to a counted array of property tags of <br> *                      properties requested <br> *       ulFlags        UNICODE / String8 <br> *       pcval          Pointer to number of values returned <br> *       ppval          Pointer to a variable in which the address of the <br> *                      returned property values is placed <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      If the call succeeded overall but access to one or more <br> *      properties failed, the function returns the warning <br> *      MAPI_W_ERRORS_RETURNED.  The calling application should <br> *      then check the Property Tag of each of the returned <br> *      properties to determine which ones failed.  Those that fail <br> *      have their Property Type set to PT_ERROR and their value (a <br> *      ULONG) indicates which error occurred. <br> * <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_W_ERRORS_RETURNED      See above. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IATCH_GetProps(PIATCH piatch, LPSPropTagArray ptaga, ULONG ulFlags, <br>    ULONG *pcval, LPSPropValue *ppval) <br>{ <br>    HRESULT hr; <br> <br>    ATCH_ValidateParameters( <br>            piatch, <br>            IMAPIProp, <br>            GetProps, <br>            (piatch,  <br>            ptaga,  <br>            ulFlags, <br>            pcval,  <br>            ppval)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    IATCH_EnterCriticalSection(piatch); <br> <br>    /* Pass the call off to IMessage */ <br>    hr = piatch-&gt;lpattach-&gt;lpVtbl-&gt;GetProps(piatch-&gt;lpattach, ptaga, ulFlags,  <br>            pcval, ppval); <br> <br>    /* Wrap specific store properties. Note that this function takes as an */ <br>    /* argument the HRESULT from the previous GetProps call. */ <br>    /* We aren't ignoring the error. */ <br> <br>    hr = HrWrap_GetProps(hr, piatch-&gt;pims, 0, NULL, pcval, ppval, FALSE, <br>        (ptaga != NULL), (POBJ)piatch); <br> <br>    IATCH_LeaveCriticalSection(piatch); <br> <br>    DebugTraceResult(IATCH_GetProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_GetProps); <br>} <br> <br>/* <br> *  IATCH_GetPropList <br> * <br> *  Purpose: <br> *      Returns a list of all the properties currently accessible. <br> *      Uses the IMessage on IStorage property implementation. <br> * <br> *  Arguments: <br> *      piatch              Pointer to the object. <br> *      ulFlags             UNICODE / String8 <br> *      lppPropTagArray     Location in which to return a pointer <br> *                          to a counted array of property tags. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP <br>IATCH_GetPropList(PIATCH piatch, ULONG ulFlags, LPSPropTagArray *lppPropTagArray) <br>{ <br>    HRESULT hr; <br> <br>    ATCH_ValidateParameters( <br>            piatch, <br>            IMAPIProp, <br>            GetPropList, <br>            (piatch,  <br>            ulFlags,  <br>            lppPropTagArray)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    IATCH_EnterCriticalSection(piatch); <br> <br>    hr = piatch-&gt;lpattach-&gt;lpVtbl-&gt;GetPropList(piatch-&gt;lpattach, ulFlags, <br>        lppPropTagArray); <br> <br>    IATCH_LeaveCriticalSection(piatch); <br> <br>    DebugTraceResult(IATCH_GetPropList, hr); <br>    return HrCheckHr(hr, IMAPIProp_GetPropList); <br>} <br> <br>/* <br> *  IATCH_OpenProperty <br> * <br> *  Purpose: <br> *      Open a requested interface on a property for further <br> *      access.  Commonly used for stream access to a large binary <br> *      or text property.  This is the only way to access a <br> *      property of type PT_OBJECT, and may be used on other <br> *      properties depending on the implementation.  Uses the <br> *      IMessage on IStorage property implementation. <br> * <br> *  Arguments: <br> *      piatch      Pointer to the object. <br> *      ulPropTag   Property tag for the desired property.  Only <br> *                  the ID bits of the tag are used; the type bits <br> *                  are ignored. <br> *      lpiid       Pointer to the GUID identifying which interface <br> *                  is desired. <br> *      lppUnk      Location in which to return a pointer to the <br> *                  newly created interface pointer. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_CALL_FAILED      An error occurred opening a <br> *                              supported interface. <br> *      MAPI_E_NO_SUPPORT   The requested interface is not <br> *                              available on the given property. <br> */ <br>STDMETHODIMP IATCH_OpenProperty(PIATCH piatch, ULONG ulPropTag, LPCIID lpiid, <br>    ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN * lppUnk) <br>{ <br>    HRESULT hr; <br>    LPUNKNOWN lpunk = NULL; <br>    PIMSG pimsg = NULL; <br>    LPSPropTagArray ptaga = NULL; <br> <br>    ATCH_ValidateParameters( <br>            piatch, <br>            IMAPIProp, <br>            OpenProperty, <br>            (piatch,  <br>            ulPropTag,  <br>            lpiid, <br>            ulInterfaceOptions,  <br>            ulFlags,  <br>            lppUnk)); <br> <br>    IATCH_EnterCriticalSection(piatch); <br> <br>    /* If input parameters are okay, make OpenProperty call on lpmsg. */ <br> <br>    hr = piatch-&gt;lpattach-&gt;lpVtbl-&gt;OpenProperty(piatch-&gt;lpattach, <br>        ulPropTag, lpiid, ulInterfaceOptions, ulFlags, &amp;lpunk); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* If it's a message in message, we need to wrap the returned object */ <br> <br>    if (ulPropTag == PR_ATTACH_DATA_OBJ <br>        &amp;&amp; IsEqualIID(lpiid, (LPIID) &amp;IID_IMessage)) <br>    { <br>        hr = NewIMSGInIATCH((LPMESSAGE) lpunk, (POBJ) piatch, ulFlags, &amp;pimsg); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = pimsg-&gt;lpVtbl-&gt;GetPropList(pimsg, 0, /* ansi */ <br>                &amp;ptaga); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (ptaga-&gt;cValues == 0) <br>        { <br>            hr = InitIMSGProps(pimsg); <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br> <br>        *lppUnk = (LPUNKNOWN) pimsg; <br>    } <br>    else <br>        *lppUnk = lpunk; <br> <br>exit: <br>    LMFree(&amp;piatch-&gt;pims-&gt;lmr, ptaga); <br> <br>    if (hr != hrSuccess) <br>    { <br>        UlRelease(pimsg); <br>        UlRelease(lpunk); <br>    } <br> <br>    IATCH_LeaveCriticalSection(piatch); <br> <br>    DebugTraceResult(IATCH_OpenProperty, hr); <br>    return HrCheckHr(hr, IMAPIProp_OpenProperty); <br>} <br> <br>/* <br> *  IATCH_SetProps <br> * <br> *  Purpose: <br> *      Sets the value of one or more properties.  This call passes <br> *      a number of Property Value structures.  The Property Tag in <br> *      each indicates which property is having its values set and <br> *      the value indicates what should be stored.  The caller must <br> *      free the returned property problem structure by calling <br> *      MAPIFreeBuffer(*pprba), but only if the call <br> *      succeeded overall.  Uses the IMessage on IStorage property <br> *      implementation. <br> * <br> *  Arguments: <br> *      piatch          Pointer to the object. <br> *      cValues         Number of values in pval. <br> *      pval            Pointer to a Property Value array. <br> *      pprba           Location in which to return a pointer to a <br> *                      counted array of property problem <br> *                      structures. <br> * <br> *  Returns: <br> *      HRESULT.  If the call succeeds overall, a zero is returned. <br> *      If there are problems with setting some or all of the <br> *      selected values, and a non-NULL is passed for pprba, <br> *      then a SPropProblemArray structure is returned with details <br> *      about each problem.  The value returned in pprba is <br> *      only valid if zero is returned in the HRESULT.  If an error <br> *      occurs on the call such that a non-zero value is returned <br> *      for the HRESULT then the contents of *pprba are <br> *      undefined.  In particular, do not use or free the structure <br> *      if an error occurs on the call. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IATCH_SetProps(PIATCH piatch, ULONG cValues, LPSPropValue pval, <br>    LPSPropProblemArray *pprba) <br>{ <br>    HRESULT hr; <br> <br>    ATCH_ValidateParameters( <br>            piatch, <br>            IMAPIProp, <br>            SetProps, <br>            (piatch,  <br>            cValues,  <br>            pval, <br>            pprba)); <br> <br>    IATCH_EnterCriticalSection(piatch); <br> <br>    hr = piatch-&gt;lpattach-&gt;lpVtbl-&gt;SetProps(piatch-&gt;lpattach, cValues, <br>        pval, pprba); <br> <br>    IATCH_LeaveCriticalSection(piatch); <br> <br>    DebugTraceResult(IATCH_SetProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_SetProps); <br>} <br> <br>/* <br> *  IATCH_DeleteProps <br> * <br> *  Purpose: <br> *      Deletes the list of properties given in ptaga. <br> *      The caller must free the returned property problem <br> *      structure by calling MAPIFreeBuffer(*pprba), but only <br> *      if the call succeeded overall.  Uses the IMessage on <br> *      IStorage property implementation. <br> * <br> *  Arguments: <br> *      piatch          Pointer to the object. <br> *      ptaga   Pointer to an array of Property Tags <br> *                      identifying the properties to delete. <br> *      pprba       Location in which to return a pointer to a <br> *                      counted array of property problem <br> *                      structures. <br> * <br> *  Returns: <br> *      HRESULT.  If the call succeeds overall, a zero is returned. <br> *      If there are problems with deleting some or all of the <br> *      selected values, and a non-NULL is passed for pprba, <br> *      then a SPropProblemArray structure is returned with details <br> *      about each problem.  The value returned in pprba is <br> *      only valid if zero is returned in the HRESULT.  If an error <br> *      occurs on the call such that a non-zero value is returned <br> *      for the HRESULT then the contents of *pprba are <br> *      undefined.  In particular, do not use or free the structure <br> *      if an error occurs on the call. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IATCH_DeleteProps(PIATCH piatch, LPSPropTagArray ptaga, <br>    LPSPropProblemArray * pprba) <br>{ <br>    HRESULT hr; <br> <br>    ATCH_ValidateParameters( <br>            piatch, <br>            IMAPIProp, <br>            DeleteProps, <br>            (piatch,  <br>            ptaga, <br>            pprba)); <br> <br>    IATCH_EnterCriticalSection(piatch); <br> <br>    hr = piatch-&gt;lpattach-&gt;lpVtbl-&gt;DeleteProps(piatch-&gt;lpattach, ptaga, pprba); <br> <br>    IATCH_LeaveCriticalSection(piatch); <br> <br>    DebugTraceResult(IATCH_DeleteProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_DeleteProps); <br>} <br> <br>/* <br> *  IATCH_CopyTo <br> * <br> *  Purpose: <br> *      Copies the contents of the current object to a destination <br> *      object.  The entire contents, including contained objects, <br> *      are copied, or optionally the caller can provide a list of <br> *      properties that are not to be copied.  Previous information <br> *      in the destination object which is not overwritten by <br> *      copied data is neither deleted nor modified. <br> * <br> *  Arguments: <br> *      piatch          Pointer to the source object. <br> *      ciidExcl        Count of the excluded interfaces in <br> *                      rgiidExcl. <br> *      rgiidExcl   Array of interface IDs specifying <br> *                      interfaces not to be attempted in trying to <br> *                      copy supplemental information to the <br> *                      destination object. <br> *      ptagaExcl   Counted array of property tags of <br> *                      properties that are not to be copied to the <br> *                      destination object.  NULL indicates all <br> *                      properties are to be copied. <br> *      ulUIParam       Handle of parent window cast to ULONG. <br> *      lpProgress      Callback for doing progress UI. <br> *      piidDst     Interface ID of the interface of lpDestObj, <br> *                      the destination object. <br> *      lpDestObj       Pointer to the open destination object. <br> *      ulFlags         Flags.  Defined as follows: <br> *                      MAPI_MOVE       Indicates a move operation. <br> *                                      The default is to copy. <br> *                      MAPI_NOREPLACE  Indicates that existing <br> *                                      properties should not be <br> *                                      overridden.  The default is <br> *                                      to overwrite existing <br> *                                      properties. <br> *                      MAPI_DIALOG     Display a progress dialog <br> *                                      as the operation proceeds. <br> *                      MAPI_STD_DIALOG Use MAPI standard dialog <br> *                                      instead of <br> *                                      provider-specific dialog. <br> *      pprba       Pointer to a variable that is filled in <br> *                      with a pointer to a set of property <br> *                      problems.  If NULL, no problem set is <br> *                      returned on an error. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IATCH_CopyTo(PIATCH piatch, ULONG ciidExcl, LPCIID rgiidExcl, <br>    LPSPropTagArray ptagaExcl, ULONG ulUIParam, LPMAPIPROGRESS <br>    lpProgress, LPCIID piidDst, LPVOID lpDestObj, ULONG ulFlags, <br>    LPSPropProblemArray * pprba) <br>{ <br>    HRESULT hr; <br> <br>    ATCH_ValidateParameters( <br>            piatch, <br>            IMAPIProp, <br>            CopyTo, <br>            (piatch,  <br>            ciidExcl,  <br>            rgiidExcl, <br>            ptagaExcl,  <br>            ulUIParam,  <br>            lpProgress,  <br>            piidDst,  <br>            lpDestObj,  <br>            ulFlags, <br>            pprba)); <br> <br>    IATCH_EnterCriticalSection(piatch); <br> <br>    hr = piatch-&gt;lpattach-&gt;lpVtbl-&gt;CopyTo(piatch-&gt;lpattach, ciidExcl, <br>        rgiidExcl, ptagaExcl, ulUIParam, lpProgress, piidDst, <br>        lpDestObj, ulFlags, pprba); <br> <br>    IATCH_LeaveCriticalSection(piatch); <br> <br>    DebugTraceResult(IATCH_CopyTo, hr); <br>    return HrCheckHr(hr, IMAPIProp_CopyTo); <br>} <br> <br>/* <br> *  IATCH_CopyProps <br> * <br> *  Purpose: <br> *      Copies the specified properties of the current object to a destination <br> *      object. <br> * <br> *  Arguments: <br> *      piatch          Pointer to the source object. <br> *      ptagaIncl       Counted array of property tags of <br> *                      properties that are to be copied to the <br> *                      destination object. <br> *      ulUIParam       Handle of parent window cast to ULONG. <br> *      lpProgress      Callback for doing progress UI. <br> *      piidDst     Interface ID of the interface of lpDestObj, <br> *                      the destination object. <br> *      lpDestObj       Pointer to the open destination object. <br> *      ulFlags         Flags.  Defined as follows: <br> *                      MAPI_MOVE       Indicates a move operation. <br> *                                      The default is to copy. <br> *                      MAPI_NOREPLACE  Indicates that existing <br> *                                      properties should not be <br> *                                      overridden.  The default is <br> *                                      to overwrite existing <br> *                                      properties. <br> *                      MAPI_DIALOG     Display a progress dialog <br> *                                      as the operation proceeds. <br> *                      MAPI_DECLINE_OK <br> *      pprba       Pointer to a variable that is filled in <br> *                      with a pointer to a set of property <br> *                      problems.  If NULL, no problem set is <br> *                      returned on an error. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IATCH_CopyProps(PIATCH piatch, <br>    LPSPropTagArray ptagaIncl, ULONG ulUIParam, LPMAPIPROGRESS <br>    lpProgress, LPCIID piidDst, LPVOID lpDestObj, ULONG ulFlags, <br>    LPSPropProblemArray * pprba) <br>{ <br>    HRESULT hr; <br> <br>    ATCH_ValidateParameters( <br>            piatch, <br>            IMAPIProp, <br>            CopyProps, <br>            (piatch, <br>            ptagaIncl,  <br>            ulUIParam,  <br>            lpProgress,  <br>            piidDst,  <br>            lpDestObj,  <br>            ulFlags, <br>            pprba)); <br> <br>    IATCH_EnterCriticalSection(piatch); <br> <br>    hr = piatch-&gt;lpattach-&gt;lpVtbl-&gt;CopyProps(piatch-&gt;lpattach, <br>        ptagaIncl, ulUIParam, lpProgress, piidDst, <br>        lpDestObj, ulFlags, pprba); <br> <br>    IATCH_LeaveCriticalSection(piatch); <br> <br>    DebugTraceResult(IATCH_CopyProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_CopyProps); <br>} <br> <br>/* <br> *  External functions <br> */ <br> <br>/* <br> * IATCH_Neuter <br> * <br> * Purpose <br> *  free storage for an attachment <br> * <br> * Parameter <br> *      piatch      pointer to the open attachment <br> * <br> */ <br>void IATCH_Neuter(PIATCH piatch) <br>{ <br>    UlRelease(piatch-&gt;lpattach); <br>} <br> <br>/* <br> *  HrNewIATCH <br> * <br> *  Purpose: <br> *      Allocates and initializes an IATCH object (internal <br> *      implementation of IAttach).  This is just a thin wrapper <br> *      around the attachment object of the IMessage on IStorage <br> *      implementation -- we wrap it to catch certain methods, <br> *      see below. <br> * <br> *  Arguments: <br> *      lpattach    Pointer to an attachment object returned by <br> *                  IMessage on IStorage. <br> *      pimsg       Pointer to the attachment's parent message object. <br> *      fModify     TRUE if the caller wants the attach opened for writing. <br> *      ppiatch Location in which to return a pointer to the <br> *                  newly created IATCH instance. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the IATCH instance. <br> */ <br>HRESULT HrNewIATCH(LPATTACH lpattach, PIMSG pimsg, BOOL fModify, PIATCH * ppiatch) <br>{ <br>    HRESULT hr = hrSuccess; <br>    PIATCH piatchNew = NULL; <br>    SCODE sc; <br>    PIMS pims; <br> <br>    AssertSz(lpattach, "Bad lpattach"); <br>    AssertSz(pimsg, "Bad pimsg"); <br>    AssertSz(ppiatch, "Bad ppiatch"); <br> <br>    pims = pimsg-&gt;pims; <br> <br>    /* Allocate and initialize IATCH instance */ <br> <br>    sc = LMAllocZ(&amp;pims-&gt;lmr, sizeof(IATCH), &amp;piatchNew); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    /* Initialize member variables */ <br> <br>    OBJ_Initialize(piatchNew, &amp;vtblIATCH, OT_ATTACH, pims, pims-&gt;pcs); <br> <br>    UlAddRef(lpattach); /* we're keeping a reference */ <br> <br>    piatchNew-&gt;lpattach = lpattach; <br> <br>    if (fModify) <br>        OBJ_SetFlag(piatchNew, OBJF_MODIFY); <br> <br>    OBJ_Enqueue((POBJ) piatchNew, (POBJ) pimsg); <br> <br>    *ppiatch = piatchNew; <br> <br>exit: <br>    if (hr != hrSuccess) <br>        LMFree(&amp;pims-&gt;lmr, piatchNew); <br> <br>    DebugTraceResult(HrNewIATCH, hr); <br>    return hr; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
