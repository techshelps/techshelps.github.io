<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSP.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2085"></a>MSP.H</h2>
<pre><code>/* <br> *  M S P . H <br> * <br> *  Definitions for the MAPI Sample Message Store Provider. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#ifdef _WIN32 <br>#define _INC_OLE <br>#define INC_OLE2 /* Get the OLE2 stuff */ <br>#define INC_RPC  /* harmless on NT 3.5; Win95 needs it */ <br>#endif <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br> <br>#include &lt;mapispi.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include &lt;mapiwin.h&gt; <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapival.h&gt; <br>#include &lt;smpms.h&gt; <br> <br>#include &lt;mapidefs.h&gt; <br>#include &lt;mapicode.h&gt; <br>#include &lt;mapitags.h&gt; <br>#include &lt;mapiguid.h&gt; <br> <br>#include &lt;imessage.h&gt; <br> <br>#include &lt;limits.h&gt; <br>#include &lt;memory.h&gt; <br> <br>#if defined(_WIN32) <br>#define OLE_CHAR WCHAR <br>#else <br>#define OLE_CHAR char <br>#endif <br> <br>#define VALIDATE <br> <br>#ifdef VALIDATE <br>#define OBJ_ValidateParameters(pobj, intf, method, cbObj, _lpVtbl, arglist) \ <br>    {                                                                       \ <br>        Validate##_##intf##_##method arglist;                               \ <br>        if (IsBadWritePtr(pobj, cbObj) || (pobj)-&gt;lpVtbl != _lpVtbl)        \ <br>            return(ResultFromScode(MAPI_E_INVALID_PARAMETER)); } <br> <br>#define OBJ_CheckParameters(pobj, intf, method, cbObj, _lpVtbl, arglist)    \ <br>    {                                                                       \ <br>        CheckParameters##_##intf##_##method arglist;                        \ <br>        AssertSz(!IsBadWritePtr(pobj, cbObj) &amp;&amp; (pobj)-&gt;lpVtbl == _lpVtbl,  \ <br>            "Bad object pointer"); } <br>#else <br>#define OBJ_ValidateParameters(pobj, intf, method, cbObj, _lpVtbl, arglist) <br>#define OBJ_CheckParameters(pobj, intf, method, cbObj, _lpVtbl, arglist) <br>#endif /* VALIDATE */ <br> <br>typedef LPVOID *PPV; <br> <br>#define NUM_RETRIES 6           /* number of times to retry opening a file */ <br> <br>/* Per-instance data. */ <br>typedef struct <br>{ <br>    UINT        cRef; <br>    LPMALLOC    lpmalloc; <br>} INST, *PINST; <br> <br>/* Linked Memory Routines */ <br>typedef struct _lmr <br>{ <br>    LPALLOCATEBUFFER    lpAllocBuf; <br>    LPALLOCATEMORE      lpAllocMore; <br>    LPFREEBUFFER        lpFreeBuf; <br>}   LMR, *PLMR; <br> <br>#define         LMAlloc(plmr, lcb, ppv)             ((plmr)-&gt;lpAllocBuf(lcb, ppv)) <br>#define         LMAllocMore(plmr, lcb, pvLink, ppv) ((plmr)-&gt;lpAllocMore(lcb, pvLink, ppv)) <br>#define         LMFree(plmr, pv)                    ((plmr)-&gt;lpFreeBuf(pv)) <br> <br>#define IsBadIfacePtr(param, iface)                 \ <br>            (IsBadReadPtr((param), sizeof(iface))   \ <br>        ||  IsBadReadPtr((param)-&gt;lpVtbl, sizeof(iface##Vtbl))) <br> <br>#define SMPMS_VERSION   (0x03)  /* For MAPI 1.0 */ <br> <br>typedef struct _EID             /* Sample Message Store EntryID */ <br>{ <br>    BYTE abFlags[4]; <br>    MAPIUID uidResource; <br>    BYTE bVersion; <br>    BYTE bVerPad[3]; <br>    TCHAR szPath[1]; <br>} EID, *PEID; <br> <br>#define CbNewEID(_cbPath) \ <br>    (offsetof(EID,szPath) + (_cbPath)*sizeof(CHAR)) <br> <br>/* This includes the NULL terminator */ <br>#define CbEID(_peid) \ <br>    (offsetof(EID,szPath) + \ <br>    (((UINT)(lstrlen((_peid)-&gt;szPath)))*sizeof(CHAR)) + sizeof(CHAR)) <br> <br>/* This includes the NULL */ <br>#define CbEIDPath(peid) (CbEID(peid)-CbNewEID(0)) <br> <br>#define PR_FILENAME_SEQUENCE_NUMBER PROP_TAG(PT_LONG,       0x6600) <br>#define PR_SMS_CONTENTS_SORT_ORDER  PROP_TAG(PT_MV_LONG,    0x6601) <br> <br>#if defined(_WIN32) <br>#define CRITICAL_SECTION_MEMBERS    CRITICAL_SECTION cs; <br>#define CRITICAL_SECTION_MEMBERS_P  CRITICAL_SECTION *pcs; <br>#else <br>#define CRITICAL_SECTION_MEMBERS <br>#define CRITICAL_SECTION_MEMBERS_P <br>#endif <br> <br>/* Object typedefs ------------------------------------------------------- */ <br> <br>typedef struct _OBJ     OBJ,        * POBJ,     ** PPOBJ; <br>typedef struct _MSP     MSP,        * PMSP,     ** PPMSP; <br>typedef struct _MSL     MSL,        * PMSL,     ** PPMSL; <br>typedef struct _IMS     IMS,        * PIMS,     ** PPIMS; <br>typedef struct _IFLD    IFLD,       * PIFLD,    ** PPIFLD; <br>typedef struct _IMSG    IMSG,       * PIMSG,    ** PPIMSG; <br>typedef struct _IATCH   IATCH,      * PIATCH,   ** PPIATCH; <br>typedef struct _STM     STM,        * PSTM,     ** PPSTM; <br>typedef struct _STG     STG,        * PSTG,     ** PPSTG; <br> <br>/* Standard Object --------------------------------------------------------- */ <br> <br>#undef  INTERFACE <br>#define INTERFACE struct _OBJ <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, OBJ_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(OBJ_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>}; <br> <br>#define STANDARD_OBJECT_MEMBERS     \ <br>    LONG                cRef;       \ <br>    WORD                wType;      \ <br>    WORD                wFlags;     \ <br>    POBJ                pobjParent; \ <br>    POBJ                pobjNext;   \ <br>    POBJ                pobjHead;   \ <br>    PIMS                pims;       \ <br>    CRITICAL_SECTION_MEMBERS_P      \ <br> <br>/* NOTE: If you modify this enumeration, you must also update various */ <br>/* structures in mspobj.c which use the type as an index into lookup tables */ <br>enum { <br>    OT_MSPROVIDER, <br>    OT_MSLOGON, <br>    OT_MSGSTORE, <br>    OT_FOLDER, <br>    OT_MESSAGE, <br>    OT_ATTACH, <br>    OT_STREAM, <br>    OT_TABLE, <br>    OT_MAX <br>}; <br> <br>#define OBJF_MODIFY     ((WORD)0x0001) <br> <br>struct _OBJ <br>{ <br>    OBJ_Vtbl *      lpVtbl; <br>    STANDARD_OBJECT_MEMBERS <br>}; <br> <br>typedef void (*LPFNNEUTER)(POBJ); <br>extern LPFNNEUTER rgfnNeuter[]; <br> <br>#define OBJ_SetFlag(pobj, f)    ((pobj)-&gt;wFlags |=  (f)) <br>#define OBJ_ClearFlag(pobj, f)  ((pobj)-&gt;wFlags &amp;= ~(f)) <br>#define OBJ_TestFlag(pobj, f)   ((pobj)-&gt;wFlags &amp;   (f)) <br> <br>#ifdef _WIN32 <br>#define OBJ_Initialize(pobj, _vtbl, _wType, _pims, _pcs)    \ <br>    (pobj)-&gt;lpVtbl      = _vtbl;    \ <br>    (pobj)-&gt;cRef        = 1;        \ <br>    (pobj)-&gt;wType       = _wType;   \ <br>    (pobj)-&gt;pims        = _pims;    \ <br>    (pobj)-&gt;pcs         = _pcs; <br>#else <br>#define OBJ_Initialize(pobj, _vtbl, _wType, _pims, _pcs)    \ <br>    (pobj)-&gt;lpVtbl      = _vtbl;    \ <br>    (pobj)-&gt;cRef        = 1;        \ <br>    (pobj)-&gt;wType       = _wType;   \ <br>    (pobj)-&gt;pims        = _pims; <br>#endif <br> <br>#define OBJ_EnterCriticalSection(pobj)  EnterCriticalSection((pobj)-&gt;pcs) <br>#define OBJ_LeaveCriticalSection(pobj)  LeaveCriticalSection((pobj)-&gt;pcs) <br>#define MSP_EnterCriticalSection(pmsp)  OBJ_EnterCriticalSection((POBJ)pmsp) <br>#define MSP_LeaveCriticalSection(pmsp)  OBJ_LeaveCriticalSection((POBJ)pmsp) <br>#define IMS_EnterCriticalSection(pims)  OBJ_EnterCriticalSection((POBJ)pims) <br>#define IMS_LeaveCriticalSection(pims)  OBJ_LeaveCriticalSection((POBJ)pims) <br> <br>/* <br> *  MSPOBJ.C <br> */ <br> <br>BOOL    FQueryInterface(int wType, REFIID riid); <br> <br>void    OBJ_Enqueue(POBJ pobj, POBJ pobjParent); <br>void    OBJ_Dequeue(POBJ pobj); <br>void    OBJ_Destroy(POBJ pobj); <br> <br>extern CHAR szFolderTemplate[];         /*  "*.fld"         */ <br>extern CHAR szMessageTemplate[];        /*  "*.msg"         */ <br>extern CHAR szPropertyFileName[];       /*  "folder.prp"    */ <br>extern CHAR szHierarchyFileName[];      /*  "hierarch.tbl"  */ <br>extern CHAR szContentsFileName[];       /*  "contents.tbl"  */ <br>extern CHAR szOutgoingFileName[];       /*  "outgoing.tbl"  */ <br> <br>/* <br> *  MSPRFS.C <br> */ <br> <br>/* Manifest constants */ <br> <br>#define RFS_CREATE      ((ULONG) 0x00000001) <br> <br>/* Typedefs */ <br> <br>typedef struct _RFS         /* Receive Folder Storage */ <br>{ <br>    LPTSTR szFile;          /* Name of docfile containing RecFldr settings */ <br>} RFS, * PRFS; <br> <br>typedef struct _RFN         /* A single RFS Node */ <br>{ <br>    LPTSTR szClass;         /* Name of the message class */ <br>    LPTSTR szName;          /* Relative path name of receive folder, i.e. */ <br>                            /* EntryID minus the GUID                     */ <br>} RFN, * PRFN; <br> <br>/* Exported functions */ <br> <br>BOOL FIsValidMessageClass(LPTSTR szMessageClass); <br>HRESULT OpenRFS (LPTSTR szStoreRoot, LPTSTR szFile, ULONG ulFlags, <br>    PRFS * lpprfs); <br>HRESULT GetRFN (PRFS prfs, LPTSTR szClassName, PRFN * pprfn); <br>VOID    FreeRFN (PRFN prfn); <br>HRESULT DeleteRFN (PRFS prfs, LPTSTR szClassName); <br>HRESULT AddRFN (PRFS, PRFN prfn); <br>HRESULT CloseRFS (PRFS prfs); <br> <br>/* <br> *  MSPMS.C <br> */ <br> <br>/* Manifest constants */ <br> <br>#define IMS_CREATE      ((WORD) 0x0002) <br>#define IMS_INVALID     ((WORD) 0x0004) <br> <br>/* Typedefs */ <br> <br>#undef  INTERFACE <br>#define INTERFACE   struct _IMS <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, IMS_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMSGSTORE_METHODS(IMPL)     <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, IMS_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMSGSTORE_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(IMS_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMSGSTORE_METHODS(IMPL)     <br>}; <br> <br>struct _IMS             /* Implementation of IMsgStore */ <br>{ <br>    IMS_Vtbl *      lpVtbl;     /* -&gt; vtblIMS */ <br>    STANDARD_OBJECT_MEMBERS <br>    LPTSTR      szStorePath;    /* Full path to the store root */ <br>    MAPIUID     uidResource;    /* Message Store unique identifier */ <br>    LPTSTR      szProps;        /* Full path to property docfile */ <br>    PMSL        pmsl;           /* Logon object (MAPI session stuff) */ <br>    PMSP        pmsp;           /* Provider object (global stuff) */ <br>    LMR         lmr;            /* Linked memory routines */ <br>    PRFS        prfs;           /* Struct handling access to receive folder */ <br>    LPMAPISUP   psup;           /* MAPI Support object */ <br>    SBinary     eidStore;       /* PR_STORE_ENTRYID */ <br>    LPTABLEDATA lptblOutgoing;  /* outgoing queue for this store */ <br>    HANDLE      hOGQueueMutex;  /* Mutex for reading/writing the OG Queue */ <br>    FILETIME    ftOGQueue;      /* The time of the OQ file when we read it */ <br>    ULONG       cOutgoingViews; /* number of views open on the outgoing queue */ <br>    ULONG       ulOQConn;       /* Connection for OQ unadvise */ <br>    HANDLE      hContTblMutex;  /* Mutex for reading/writing ALL cont tbls */ <br>    ULONG       ulTblConn;      /* Connection for Tbl unadvise */ <br>    LPMSGSESS   pmsgsess;       /* IMSG Session to create all messages within */ <br>    ULONG       ulFlagsSLT;     /* Flags for StoreLogoffTransports */ <br>}; <br> <br>#define MSF_SPOOLER         ((WORD)0x8000) <br>#define MSF_BEINGDESTROYED  ((WORD)0x4000) <br> <br>#define SMS_SUPPORTMASK     (STORE_ENTRYID_UNIQUE |     \ <br>                            STORE_ATTACH_OK |           \ <br>                            STORE_OLE_OK |              \ <br>                            STORE_NOTIFY_OK |           \ <br>                            STORE_MV_PROPS_OK |         \ <br>                            STORE_RESTRICTION_OK |      \ <br>                            STORE_SORT_OK |             \ <br>                            STORE_MODIFY_OK |           \ <br>                            STORE_CREATE_OK |           \ <br>                            STORE_SUBMIT_OK) <br> <br>/* Outgoing Queue Notification Block (ONB) */ <br>/* This is the format of our extended cross-process notification for the */ <br>/* outgoing queue table. We use this to update the table data in other */ <br>/* processes after we change it in the originating process. The changes */ <br>/* that we pass across are either deleting a row (for example, when the */ <br>/* spooler calls FinishedMsg), or adding a row (for example, when the */ <br>/* client submits a message). */ <br> <br>typedef struct _ONB <br>{ <br>    FILETIME ftBeforeUpdate;    /* time of the file before updating */ <br>    FILETIME ftAfterUpdate;     /* time of the file after applying the update */ <br>    LPVOID  pvRef;              /* memory offset from originating process */ <br>    ULONG   cbNtf;              /* # of bytes in abNtf (the flat notif below) */ <br>    BYTE    abNtf[1];           /* the update to apply to the table */ <br>} ONB, * PONB; <br> <br>#define CbNewONB(_cb)       (offsetof(ONB,abNtf) + (_cb)) <br>#define CbONB(_ponb) \ <br>    (offsetof(ONB,abNtf) + (UINT)((_ponb)-&gt;cbNtf)) <br> <br> <br>/* Table Notification Block (TNB) */ <br>/* This is the format of our extended cross-process notification for */ <br>/* Contents and Hierarchy Tables. We use this notification to update a */ <br>/* table in other processes after we change it in the originating process. */ <br>/* The notification consists of an object notification containing the */ <br>/* entryids we need. The fnev tells the event type. We only use two of */ <br>/* the entryids in the object notification. The ParentID fields refer to */ <br>/* the parent folder of the table we need to update. The EntryID fields */ <br>/* refer to the object that changed within the folder. The ulObjType field */ <br>/* will be either MAPI_MESSAGE (for contents table changes) or MAPI_FOLDER */ <br>/* (for hierarchy table changes).  All other fields in the structure are */ <br>/* unused and should be set to 0. */ <br> <br>typedef struct _TNB <br>{ <br>    ULONG   ulTableEvent;   /* TABLE_ROW_ (ADDED, DELETED, MODIFIED) */ <br>    LPVOID  pvRef;          /* memory offset from originating process */ <br>    ULONG   cbNtf;          /* # of bytes in abNtf (the flat notif below) */ <br>    BYTE    abNtf[1];       /* an object notification */ <br>} TNB, * PTNB; <br> <br>#define CbNewTNB(_cb)       (offsetof(TNB,abNtf) + (_cb)) <br>#define CbTNB(_ptnb) \ <br>    (offsetof(TNB,abNtf) + (UINT)((_ptnb)-&gt;cbNtf)) <br> <br> <br>/* Exported functions */ <br>HRESULT HrOpenIMSPropsFileRetry(LPMSGSESS pmsgsess, LPTSTR szFile, PLMR plmr, <br>    LPMAPISUP psup, BOOL fModify, LPMESSAGE * lppmsg); <br>BOOL IMS_IsInvalid(PIMS pims); <br> <br>/* Constructors */ <br> <br>HRESULT HrNewIMS(LPTSTR szStorePath, LPTSTR szStoreProps, PMSP pmsp, <br>    PMSL pmsl, PRFS prfs, LPPROFSECT pps, LPMAPISUP psup, BOOL fCreate, <br>    PIMS *ppims); <br> <br>/* Non-virtual public methods */ <br> <br>void IMS_Neuter(PIMS pims); <br>HRESULT HrInitIMSProps (PIMS pims, LPTSTR szPswd); <br>VOID GetResourceUID (PIMS pims, LPMAPIUID lpuid); <br>HRESULT HrUniqueFileName (PIMS pims, ULONG * lpulSeqNumber, LPTSTR * <br>    lppszNewName); <br>BOOL FIsInvalidEID (ULONG, PEID, PIMS); <br>/* Others */ <br> <br>STDAPI_(void) MsgReleaseStg (ULONG ulCallerData, LPMESSAGE lpMessage); <br>long STDAPICALLTYPE LSMSNotifCallback (LPVOID lpvContext, <br>    ULONG cNotif, LPNOTIFICATION lpNotifs); <br> <br>/* column properties for outgoing queue */ <br>#define OUTGOING_COLUMNS    13      /* number of columns in outgoing queue */ <br>static const SizedSPropTagArray(OUTGOING_COLUMNS, sptaOutgoing) = <br>{ <br>    OUTGOING_COLUMNS, <br>    { <br>        PR_ENTRYID, <br>        PR_SUBMIT_FLAGS, <br>        PR_INSTANCE_KEY,    /* the index column */ <br>        PR_DISPLAY_TO, <br>        PR_DISPLAY_CC, <br>        PR_DISPLAY_BCC, <br>        PR_SENDER_NAME, <br>        PR_SUBJECT, <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_PRIORITY, <br>        PR_MESSAGE_FLAGS, <br>        PR_MESSAGE_SIZE, <br>        PR_SPOOLER_STATUS <br>    } <br>}; <br> <br> <br>/* <br> *  MSPFLD.C <br> */ <br> <br>#define FAILED_SEARCH   (INVALID_HANDLE_VALUE) <br> <br>#define MODIFY_INDEX    1       /* index of LAST_MODIFICATION_TIME in tables */ <br> <br>/* column properties for contents tables */ <br>#define CONTENTS_COLUMNS    22      /* number of columns in a table of messages */ <br>static const SizedSPropTagArray(CONTENTS_COLUMNS, sPropTagsContents) = <br>{ <br>    CONTENTS_COLUMNS, <br>    { <br>        PR_ENTRYID, <br>        PR_LAST_MODIFICATION_TIME,  /* must be in position MODIFY_INDEX */ <br>        PR_INSTANCE_KEY,            /* the index column */ <br>        PR_HASATTACH, <br>        PR_SUBJECT, <br>        PR_SENDER_NAME, <br>        PR_DISPLAY_TO, <br>        PR_DISPLAY_CC, <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_MESSAGE_DELIVERY_TIME, <br>        PR_MESSAGE_FLAGS, <br>        PR_PRIORITY, <br>        PR_CONVERSATION_KEY, <br>        PR_SEARCH_KEY, <br>        PR_ICON, <br>        PR_MINI_ICON, <br>        PR_SENSITIVITY, <br>        PR_MESSAGE_CLASS, <br>        PR_RECORD_KEY, <br>        PR_SPOOLER_STATUS, <br>        PR_SENT_REPRESENTING_NAME, <br>        PR_MSG_STATUS <br>    } <br>}; <br> <br>/* column properties for hierarchy tables */ <br>#define HIERARCHY_COLUMNS   12 <br>static const SizedSPropTagArray(HIERARCHY_COLUMNS, sPropTagsHierarchy) = <br>{ <br>    HIERARCHY_COLUMNS, <br>    { <br>        PR_ENTRYID, <br>        PR_LAST_MODIFICATION_TIME, /* must be in postion MODIFY_INDEX */ <br>        PR_DISPLAY_NAME,    /* the folder name */ <br>        PR_INSTANCE_KEY,    /* the index column */ <br>        PR_OBJECT_TYPE, <br>        PR_COMMENT, <br>        PR_CONTENT_COUNT, <br>        PR_CONTENT_UNREAD, <br>        PR_STATUS, <br>        PR_SUBFOLDERS, <br>        PR_FOLDER_TYPE, <br>        PR_DEPTH            /* depth in hierarchy, must be last */ <br>    } <br>} ; <br> <br>#undef  INTERFACE <br>#define INTERFACE struct _IFLD <br>     <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, IFLD_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPICONTAINER_METHODS(IMPL) <br>        MAPI_IMAPIFOLDER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, IFLD_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPICONTAINER_METHODS(IMPL) <br>        MAPI_IMAPIFOLDER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(IFLD_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMAPICONTAINER_METHODS(IMPL) <br>    MAPI_IMAPIFOLDER_METHODS(IMPL) <br>}; <br> <br>extern IFLD_Vtbl    vtblIFLD; <br> <br>/* we store PR_ENTRYID, PR_PARENT_ENTRYID and PR_INSTANCE_KEY internally */ <br>#define cpropIFLDInternal       3 <br> <br>/* Folder's instance data */ <br>struct _IFLD <br>{ <br>    IFLD_Vtbl *     lpVtbl; /* -&gt; vtblIFLD */ <br>    STANDARD_OBJECT_MEMBERS <br>    PEID peid;                  /* EntryID of this folder */ <br>    ULONG           cval;       /* # of internal props */ <br>    LPSPropValue    pval;       /* internal prop values */ <br>    LPTABLEDATA lptblContents;  /* contents table for this folder */ <br>    ULONG cContentsViews;       /* number of views open on contents table*/ <br>    LPTABLEDATA lptblHierarchy; /* hierarchy table for this folder */ <br>    ULONG cHierarchyViews;      /* number of views open on hierarchy table */ <br>}; <br> <br>HRESULT HrNewIFLD(PEID peid, PIMS pims, BOOL fModify, PIFLD * ppifld); <br>HRESULT HrCreateFolderStorage(PIFLD pifld, ULONG ulFolderType, <br>    LPSTR szFolderName, LPSTR szFolderComment, BOOL fCreateDir, <br>    PIMS pims, PEID *ppeid); <br>HRESULT HrNewEID (PIFLD, PIMS, LPTSTR, ULONG *, PEID *); <br>HRESULT HrIncrementOneROProp(PIFLD pifld, LONG lDelta, ULONG ulPT); <br>HRESULT HrIsParent(PEID peidParent, PEID peidChild, BOOL *pfIsParent); <br>HRESULT HrGetFileModTime(LPTSTR szStorePath, LPTSTR szFileName, <br>    FILETIME *pft); <br>HRESULT HrFullPathName (LPSTR, LPSTR, LPSTR, LPSTR *); <br>HRESULT HrFullToRelative(LPTSTR, PIMS, LPTSTR *); <br>HRESULT HrOpenPropertyMessageRetry(PEID peid, PIMS pims, <br>    BOOL fModifyExclusive, LPMESSAGE *lppmsg); <br>HRESULT HrFindFirstID( PIFLD, LPTSTR, ULONG *, LPTSTR *, HANDLE *, <br>                    WIN32_FIND_DATA *, PEID *); <br>HRESULT HrFindNextID( PIFLD, ULONG, LPTSTR, HANDLE, WIN32_FIND_DATA *, PEID *); <br>void CloseIDSearch( HANDLE *, LPTSTR *); <br>HRESULT HrFullToRelative( LPTSTR, PIMS, LPTSTR *); <br>HRESULT HrUpdateRow(PIMS pims, LPTABLEDATA lptbl, PEID peid, <br>    LPSPropTagArray pPTA, FILETIME *pft, ULONG ulObjType); <br>void    IFLD_Neuter (PIFLD); <br>void ChangeTable(PIMS pims, PEID peidTable, PEID peidObject, <br>    ULONG ulObjType, ULONG ulTableEvent, BOOL fSendNotif); <br>HRESULT HrRemoveRow( LPTABLEDATA lptbl, PEID peid); <br> <br>/* <br> *  MSPMSG.C <br> */ <br> <br>#undef  INTERFACE <br>#define INTERFACE struct _IMSG <br>     <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, IMSG_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMESSAGE_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, IMSG_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMESSAGE_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(IMSG_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMESSAGE_METHODS(IMPL) <br>}; <br> <br>extern IMSG_Vtbl    vtblIMSG; <br> <br>struct _IMSG            /* Implementation of IMessage */ <br>{ <br>    IMSG_Vtbl * lpVtbl; /* -&gt; vtblIMSG */ <br>    STANDARD_OBJECT_MEMBERS <br>    LPMESSAGE       lpmsg; <br>    PEID            peid; <br>    ULONG           cval; <br>    LPSPropValue    pval; <br>}; <br> <br>#define MSGF_NEWLYCREATED           ((WORD)0x4000) <br>#define MSGF_MSGINMSG               ((WORD)0x2000) <br>#define MSGF_FRESH                  ((WORD)0x1000) <br>#define MSGF_CREATEDSTORAGE         ((WORD)0x0800) <br> <br>#define SET         1 <br>#define UNSET       2 <br>#define DONT_SAVE   4 <br> <br>/* Exported functions */ <br> <br>HRESULT HrNewIMSG(PEID peid, PIMS pims, BOOL fCreate, BOOL fModify, <br>    ULONG ulSeqNum, LPSTR *pszFull, PIMSG *ppimsg); <br>HRESULT HrSetFlags(PIMSG, ULONG, ULONG, ULONG);  <br>HRESULT NewIMSGInIATCH (LPMESSAGE lpmsg, POBJ pobj, ULONG ulFlags, PIMSG * ppimsg); <br>HRESULT InitIMSGProps(PIMSG pimsg); <br>void IMSG_Neuter (PIMSG); <br>HRESULT HrSetInternalProps(PLMR plmr, ULONG cprop, LPSPropValue *ppval, <br>    ULONG *pcval, PEID peid, PEID peidParent, ULONG ulSeqNum); <br> <br>/* <br> *  MSPATCH.C <br> */ <br> <br>#undef  INTERFACE <br>#define INTERFACE struct _IATCH <br>     <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, IATCH_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IATTACH_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, IATCH_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IATTACH_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(IATCH_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IATTACH_METHODS(IMPL) <br>}; <br> <br>extern IATCH_Vtbl   vtblIATCH; <br> <br>struct _IATCH           /* Implementation of IAttach */ <br>{ <br>    IATCH_Vtbl *    lpVtbl; /* -&gt; vtblIATCH */ <br>    STANDARD_OBJECT_MEMBERS <br>    LPATTACH lpattach; <br>}; <br> <br>/* Exported functions */ <br> <br>HRESULT HrNewIATCH(LPATTACH lpattach, PIMSG pimsg, BOOL fModify, <br>    PIATCH * ppiatch); <br>void IATCH_Neuter (PIATCH piatch); <br> <br>/* <br> *  MSPGLE.C <br> */ <br> <br>HRESULT MapScodeSz (SCODE scArg, PIMS pims, LPTSTR * lppszError); <br> <br>/* <br> *  MSPMISC.C <br> */ <br> <br>/* length in chars of file extension including . (no NULL) */ <br>#define CCH_EXT         4 <br> <br>/* length in chars of the base portion of a local name (no NULL) */ <br>#define CCH_BASE        8 <br> <br>/* length in chars of a local name of a message or folder, including NULL */ <br>#define CCH_NAME            (CCH_BASE + CCH_EXT + 1) <br> <br>#define FOLDER_EXT      TEXT( ".fld" )  /* extension for folder directory names */ <br>#define MESSAGE_EXT     TEXT( ".msg" )  /* File name extension for messages */ <br>#define TEMP_EXT        TEXT( ".tmp" )  /* File name extension for messages */ <br> <br>/* Filename extension for read-receipt messages   */ <br>#define READRECEIPT_EXT TEXT( ".rrt" ) <br> <br>SCODE ScAlloc(ULONG lcb, LPVOID *ppv); <br>SCODE ScAllocZ(ULONG lcb, LPVOID *ppv); <br>SCODE ScRealloc(ULONG lcb, LPVOID pvOrig, LPVOID * ppv); <br>void FreeNull(LPVOID pv); <br>SCODE LMAllocZ(PLMR plmr, ULONG lcb, LPVOID *ppv); <br>SCODE ScInitMSInstance(LPMALLOC lpmalloc); <br>void DeinitMSInstance(void); <br> <br>#define HrAlloc(a,b)        ResultFromScode(ScAlloc((a), (b))) <br>#define HrAllocZ(a,b)       ResultFromScode(ScAllocZ((a), (b))) <br>#define HrRealloc(a,b,c)    ResultFromScode(ScRealloc((a), (b), (c))) <br> <br>LPTSTR SzBaseName (PEID); <br> <br>BOOL FCheckEIDType(PEID peid, LPSTR szExt); <br>BOOL FIsRoot (PEID peid); <br>BOOL FIsFolder (PEID peid); <br>BOOL FIsUnsavedMsg (PIMSG pimsg); <br>#define FIsMessage(_peid)       FCheckEIDType((_peid), MESSAGE_EXT) <br>#define FIsUnsavedEID(_peid)    FCheckEIDType((_peid), TEMP_EXT) <br> <br>HRESULT HrDeconstructEID (PEID peid, LPMAPIUID * lppuid, <br>    LPTSTR * lppszPath, LPTSTR * lppszFile); <br>HRESULT HrAppendPath (LPTSTR szBase, LPTSTR szAppend, LPTSTR * <br>    lppszFullPath); <br>BOOL FAppendPathNoMem (LPTSTR szBase, LPTSTR szAppend, <br>    ULONG cchFullPath, LPTSTR szFullPath); <br>void ReplaceExt(LPTSTR szFile, LPTSTR szExt); <br>HRESULT HrConstructEID(LPMAPIUID lpuidStore, PLMR plmr, LPSTR szNewName, <br>    PEID *ppeidNew); <br>HRESULT HrGetParentEID (PLMR, PEID, PEID *); <br>HRESULT HrOpenParent(PIMS pims, PEID peid, ULONG ulFlags, PIFLD *ppifld); <br> <br>void FreePropArrays (LPSPropValue *, <br>    LPSPropTagArray *, LPSPropAttrArray *); <br>HRESULT HrAllocPropArrays (ULONG, LPSPropValue *, <br>    LPSPropTagArray *, LPSPropAttrArray *); <br> <br>HRESULT HrWrap_GetProps(HRESULT hr, PIMS pims, ULONG cvalInt, <br>    LPSPropValue pvalInt, ULONG * lpcValues, LPSPropValue * ppval, <br>    BOOL fStore, BOOL fTagsSpecified, POBJ pobj); <br> <br>BOOL FIsSubmittedMessage(PIMS pims, PEID peid); <br> <br>HRESULT HrOpenIMsgSession(LPMSGSESS *ppmsgsess); <br>HRESULT HrOpenIMsg(LPMSGSESS pmsgsess, LPSTR szFile, PLMR plmr, LPMAPISUP psup, <br>    BOOL fCreate, BOOL fModify, BOOL fExclusive, LPMESSAGE *lppmsg); <br> <br>HRESULT HrSetOneROProp(LPMESSAGE lpmsg, PLMR plmr, ULONG ulPT, LPVOID pv); <br>HRESULT HrGetSingleProp(LPMAPIPROP pmprop, PLMR plmr, ULONG ulPT, LPVOID pv); <br>HRESULT HrSetSingleProp(LPMAPIPROP pmprop, PLMR plmr, ULONG ulPT, LPVOID pv); <br> <br>BOOL FContainsProp(ULONG ulPropTag, LPSPropTagArray ptaga); <br> <br> <br>/* <br> *  MSPROVIDER object. <br> *  Returned by MSProviderInit() routine. <br> *  One is created for each Session logged <br> *  into this store provider on this process. <br> */ <br> <br>#undef  INTERFACE <br>#define INTERFACE struct _MSP <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, MSP_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMSPROVIDER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, MSP_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMSPROVIDER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(MSP_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMSPROVIDER_METHODS(IMPL) <br>}; <br> <br>extern MSP_Vtbl vtblMSP; <br> <br>struct _MSP <br>{ <br>    MSP_Vtbl *  lpVtbl;         /* -&gt; vtblMSP */ <br>    STANDARD_OBJECT_MEMBERS <br>    CRITICAL_SECTION_MEMBERS        /* Critical section (_WIN32 only) */ <br>    HINSTANCE       hInst;          /* Instance handle */ <br>    LMR             lmr;            /* Linked memory routines */ <br>    IFDBG(BOOL      fInvalid;)      /* TRUE if invalid (DEBUG only) */ <br>}; <br> <br>/* <br> *  LOGON object. <br> *  Returned from MSP_Logon(). <br> *  Called by MAPI.DLL.  Equivalent to the IMSGSTORE object <br> *  returned on the same call but is used by MAPI instead of the client. <br> */ <br> <br>#undef  INTERFACE <br>#define INTERFACE struct _MSL <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, MSL_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMSLOGON_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, MSL_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMSLOGON_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(MSL_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMSLOGON_METHODS(IMPL) <br>}; <br> <br>extern MSL_Vtbl vtblMSL; <br>extern MAPIUID uidProvider; <br> <br>struct _MSL <br>{ <br>    MSL_Vtbl *      lpVtbl;     /* -&gt; vtblMSL */ <br>    STANDARD_OBJECT_MEMBERS <br>    CRITICAL_SECTION_MEMBERS        /* Critical section (_WIN32) */ <br>    LMR                 lmr;        /* Linked memory routines */ <br>    IFDBG(BOOL          fInvalid;)  /* TRUE if invalid (DEBUG only) */ <br>}; <br> <br> <br>/* <br> *  MSPTBL.C <br> */ <br>  <br>HRESULT HrGetTableName(POBJ, LPSTR, LPSTR, LPSTR *); <br>HRESULT HrSyncOutgoingTable(LPTABLEDATA lptbl, PIMS pims); <br>HRESULT HrSyncContentsTable(PIFLD pifld, BOOL fWriteTable); <br>HRESULT HrReadTableFromDisk(LPTABLEDATA, POBJ, LPSTR, ULONG, LPSTR); <br>HRESULT HrWriteTableOnDisk(LPTABLEDATA, POBJ, LPSTR, LPSTR); <br> <br>/* <br> *  MSPNTFY.C <br> */ <br> <br>HRESULT HrUpdateOutgoingQueue(PIMS pims, PIMSG pimsg, PEID peid, <br>    ULONG ulTableEvent); <br>HRESULT HrSetupPrivateNotifications(PIMS pims); <br>HRESULT HrNewOutgoingTableData(PIMS pims); <br>HRESULT HrCreateOGQueueMutex(HANDLE *phQMutex); <br> <br>HRESULT HrSendNotif(PIMS pims, PEID peidParent, PEID peidObject, <br>    ULONG ulTableEvent, ULONG ulObjType); <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
