<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPFLD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2087"></a>MSPFLD.C</h2>
<pre><code>/* <br> *  M S P F L D . C <br> * <br> *  Code that implements the object methods of IMAPIFolder. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br> <br>#define FLD_ValidateParameters(pobj, intf, method, arglist)     \ <br>        OBJ_ValidateParameters(pobj, intf, method, sizeof(IFLD), &amp;vtblIFLD, arglist) <br> <br>static BOOL IFLD_IsInvalid(PIFLD pifld); <br>static HRESULT HrCreateContTblMutex(HANDLE *phCTMutex); <br>static BOOL FFoldInSameStore(PIFLD pifld, PIFLD lpDestFld); <br>static BOOL FIsAncestor(PIFLD pifldAncestor, PIFLD pifldDescendent); <br>static HRESULT HrGetSortOrder(PIFLD pifld, LPSSortOrderSet *lppsSortOrder); <br>static HRESULT HrFillHierarchyTable(PIFLD pifld, LPTABLEDATA lptbl); <br>static HRESULT HrIsRead(PIFLD pifld, PEID peidMsg, BOOL *pfRead); <br>static HRESULT HrCreateFolder(PIFLD pifldParent, LPSTR szName, LPSTR szComment, <br>    BOOL fOpenIfExists, PIFLD *ppifldNew, BOOL *pfCreated); <br>static HRESULT HrDeleteSubDirectory(PIFLD pifldParent, PEID peidToDelete, <br>    ULONG ulFlags, BOOL fContentsOnly); <br>static HRESULT HrCopyContents(PIFLD pifldSrc, PIFLD pifldDst, ULONG ulFlags, <br>    LPSPropTagArray ptagaExcl); <br>static BOOL FFolderExists(PEID peid, PIMS pims); <br>static HRESULT HrSetSubFolderProp(PIFLD pifld, BOOL fSubFolder); <br>static HRESULT HrSetOneROFolderProp(PIFLD pifld, LONG lValue, ULONG ulPT); <br>static HRESULT HrEIDFromDisplayName(LPMAPITABLE pmt, LPSTR szName, PLMR plmr, <br>    PEID *ppeid); <br>static HRESULT HrCreateMessageList(PIFLD pifld, LPENTRYLIST *lppEntryList); <br>static void DestroyMessageList(PLMR plmr, LPENTRYLIST *lppEntryList); <br> <br>#define NUM_RW_FOLDER_PROPS      2  /* number read write initial folder props */ <br> <br>#define IFLD_EnterCriticalSection(pifld)    OBJ_EnterCriticalSection((POBJ)pifld) <br>#define IFLD_LeaveCriticalSection(pifld)    OBJ_LeaveCriticalSection((POBJ)pifld) <br> <br>CALLERRELEASE ViewRelease; <br> <br>TCHAR szSubfolderPropFile[] = TEXT("subfoldr.prp"); <br>TCHAR szAllFilesTemplate[] = TEXT("*.*"); <br> <br>/* properties excluded on a copy of folders' .prp file */ <br>const static SizedSPropTagArray(13, sptaExclFldProps) = <br>{ <br>    13, <br>    { <br>        PR_CONTENT_COUNT, <br>        PR_CONTENT_UNREAD, <br>        PR_ENTRYID, <br>        PR_INSTANCE_KEY, <br>        PR_PARENT_ENTRYID, <br>        PR_OBJECT_TYPE, <br>        PR_STORE_ENTRYID, <br>        PR_STORE_RECORD_KEY, <br>        PR_RECORD_KEY, <br>        PR_FOLDER_TYPE, <br>        PR_SUBFOLDERS, <br>        PR_MESSAGE_RECIPIENTS, <br>        PR_MESSAGE_ATTACHMENTS <br>    } <br>}; <br> <br>/* read only property proptags */ <br>/* order must match order initialized on CreateFolderStorage */ <br>#define NUM_RO_FOLDER_PROPS     11  /* number read only initial folder props */ <br>const static SizedSPropTagArray(NUM_RO_FOLDER_PROPS, sptaReadOnly) = <br>{ <br>    NUM_RO_FOLDER_PROPS, <br>    { <br>        PR_OBJECT_TYPE, <br>        PR_RECORD_KEY, <br>        PR_FOLDER_TYPE, <br>        PR_CONTENT_COUNT, <br>        PR_CONTENT_UNREAD, <br>        PR_STORE_ENTRYID, <br>        PR_STORE_RECORD_KEY, <br>        PR_SUBFOLDERS, <br>        PR_ENTRYID, <br>        PR_PARENT_ENTRYID, <br>        PR_INSTANCE_KEY <br>    } <br>}; <br> <br>/* read only property attributes */ <br>const static SizedSPropAttrArray(NUM_RO_FOLDER_PROPS, spaReadOnly) = <br>{ <br>    NUM_RO_FOLDER_PROPS, <br>    { <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE, <br>        PROPATTR_READABLE <br>    } <br>}; <br> <br>/* initial sort order set for a contents table */ <br>static SizedSSortOrderSet(1, sSortOrderContentsDefault) = <br>{ <br>    1, <br>    0, <br>    0, <br>    { <br>        PR_INSTANCE_KEY,                /* the index column */ <br>        TABLE_SORT_ASCEND <br>    } <br>}; <br> <br>/* message status property array */ <br>static SPropTagArray sptaMessageStatus = <br>{ <br>    1, <br>    { <br>        PR_MESSAGE_FLAGS <br>    } <br>}; <br> <br>/* DISPATCH TABLE */ <br>IFLD_Vtbl vtblIFLD = <br>{ <br>    (IFLD_QueryInterface_METHOD *)  OBJ_QueryInterface, <br>    (IFLD_AddRef_METHOD *)          OBJ_AddRef, <br>    IFLD_Release, <br>    (IFLD_GetLastError_METHOD *)    IMS_GetLastError, <br>    (IFLD_SaveChanges_METHOD *)     IMS_SaveChanges, <br>    IFLD_GetProps, <br>    IFLD_GetPropList, <br>    IFLD_OpenProperty, <br>    IFLD_SetProps, <br>    IFLD_DeleteProps, <br>    IFLD_CopyTo, <br>    IFLD_CopyProps, <br>    (IFLD_GetNamesFromIDs_METHOD *) IMS_GetNamesFromIDs, <br>    (IFLD_GetIDsFromNames_METHOD *) IMS_GetIDsFromNames, <br>    IFLD_GetContentsTable, <br>    IFLD_GetHierarchyTable, <br>    (IFLD_OpenEntry_METHOD *)       IMS_OpenEntry, <br>    IFLD_SetSearchCriteria, <br>    IFLD_GetSearchCriteria, <br>    IFLD_CreateMessage, <br>    IFLD_CopyMessages, <br>    IFLD_DeleteMessages, <br>    IFLD_CreateFolder, <br>    IFLD_CopyFolder, <br>    IFLD_DeleteFolder, <br>    IFLD_SetReadFlags, <br>    IFLD_GetMessageStatus, <br>    IFLD_SetMessageStatus, <br>    IFLD_SaveContentsSort, <br>    IFLD_EmptyFolder <br>}; <br> <br>/**************************************************** <br>*           Methods on IMAPIFolder                  * <br>*****************************************************/ <br> <br>/**************************************************************** <br>    Folder properties are all implemented by creating a file <br>    (FOLDER.PRP) inside each folder and using message properties <br>    on it. <br>*************************************************************/ <br> <br>/*************************************************************************** <br> -  IFLD_Release <br> - <br> *  Purpose: <br> *      Given a valid folder object, decrements the reference count, and if <br> *      zero, NULLS out the lpVtbl. If no child objects of the folder remain <br> *      open, and no contents or hierarchy tables remain open, the routine <br> *      also destroys the object (see OBJ_Destroy for details of that action). <br> * <br> *      This release method is very similar to the standard one found in <br> *      mspobj.c. The only difference is that this one also checks for any <br> *      open contents or hierarchy tables, and doesn't actually destroy <br> *      the folder until they are gone. See ViewRelease() for the other side <br> *      of this implementation. <br> * <br> *  Parameters <br> *       pifld      The folder object to release <br> * <br> *  Returns: <br> *       ULONG: The value of the reference count on the whole object. When <br> *              fully released, it is zero. This information can be used for <br> *              diagnostic and testing purposes only. It CANNOT be used by <br> *              shipping code. See the OLE 2.0 programmers reference for more <br> *              details. Note that this function will also return zero when <br> *              the identity of the object has been destroyed. Therefore, <br> *              clients may not rely on zero having any special significance <br> *              other than for debugging purposes. <br> */ <br>STDMETHODIMP_(ULONG) IFLD_Release(PIFLD pifld) <br>{ <br>    LONG cRef; <br>    POBJ pobj; <br> <br>    if (IFLD_IsInvalid(pifld)) <br>    { <br>        TraceSz1("SampleMS: IFLD_Release(pifld=%08lX): Folder is invalid and is " <br>            "being ignored", pifld); <br>        return (0); <br>    } <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    pobj = (POBJ) pifld; <br> <br>    AssertSz(pobj-&gt;cRef &gt; 0, "IFLD_Release(): Too many releases"); <br> <br>    cRef = --pobj-&gt;cRef; <br> <br>    if (cRef == 0) <br>    { <br>        pobj-&gt;lpVtbl = 0;   /* should prevent being called again. */ <br> <br>        if (    pobj-&gt;pobjHead == 0 <br>            &amp;&amp;  pifld-&gt;lptblContents == NULL <br>            &amp;&amp;  pifld-&gt;lptblHierarchy == NULL) <br>        { <br>            OBJ_Destroy(pobj);  /* will leave the critical section */ <br>            return (0); <br>        } <br>    } <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    return (cRef); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_GetProps <br> - <br> *  Purpose: <br> *      Returns in pcval and ppval the values of the properties <br> *      in ptaga.  If the latter is NULL, all properties in the folder <br> *      are returned. <br> * <br> *  Parameters <br> *       pifld      The folder object whose properties are requested <br> *       ptaga      Pointer to a counted array of property tags of <br> *                  properties requested <br> *       ulFlags    UNICODE / String8 <br> *       pcval      Pointer to number of values returned <br> *       ppval      Pointer to a variable in which the address of the <br> *                  returned property values is placed <br> * <br> *  Returns: <br> *       HRESULT <br> * <br> */ <br>STDMETHODIMP IFLD_GetProps(PIFLD pifld, LPSPropTagArray ptaga, ULONG ulFlags, <br>    ULONG *pcval, LPSPropValue *ppval) <br>{ <br>    LPMESSAGE lpmsg = NULL;     /* open property message */ <br>    HRESULT hr = hrSuccess; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIProp, <br>            GetProps, <br>            (pifld,  <br>            ptaga,  <br>            ulFlags, <br>            pcval,  <br>            ppval)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    /* open the property message */ <br>    hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, FALSE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Pass the call off to IMessage */ <br>    hr = lpmsg-&gt;lpVtbl-&gt;GetProps(lpmsg, ptaga, ulFlags, pcval, ppval); <br> <br>    UlRelease(lpmsg); <br> <br>    {if(HR_SUCCEEDED(hr)) <br>    { <br>        LPSPropValue pvalStoreSupMask = PpropFindProp(*ppval, *pcval,  <br>                    PROP_TAG(PT_UNSPECIFIED, PROP_ID(PR_STORE_SUPPORT_MASK))); <br>        if(pvalStoreSupMask) <br>        { <br>            pvalStoreSupMask-&gt;ulPropTag = PR_STORE_SUPPORT_MASK; <br>            pvalStoreSupMask-&gt;Value.l = SMS_SUPPORTMASK; <br> <br>            /* fix up hr */ <br>            if(ptaga-&gt;cValues == 1) <br>                hr = hrSuccess; <br>        } <br>    } <br>    } <br> <br>    /* Wrap internal properties. Note that this function takes as an */ <br>    /* argument the HRESULT from the previous IMessage::GetProps call. */ <br>    /* We aren't ignoring the error. */ <br> <br>    hr = HrWrap_GetProps(hr, pifld-&gt;pims, pifld-&gt;cval, pifld-&gt;pval, pcval, <br>        ppval, FALSE, (ptaga != NULL), (POBJ)pifld); <br> <br>exit: <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    #ifdef DEBUG <br>    if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) <br>        DebugTraceResult(IFLD_GetProps, hr); <br>    #endif <br> <br>    return HrCheckHr(hr, IMAPIProp_GetProps); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_GetPropList <br> - <br> *  Purpose: <br> *      Returns in ptaga the list of all currently accessible properties <br> *      of pifld. <br> * <br> *  Parameters <br> *       pifld          The folder object whose properties are requested <br> *       ulFlags        UNICODE / String8 <br> *       pptaga         Pointer to a counted array of property tags of <br> *                      properties requested <br> *  Returns: <br> *       hr <br> * <br> */ <br>STDMETHODIMP IFLD_GetPropList(PIFLD pifld, ULONG ulFlags, LPSPropTagArray *pptaga) <br>{ <br>    HRESULT hr; <br>    LPMESSAGE lpmsg = NULL; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIProp, <br>            GetPropList, <br>            (pifld,  <br>            ulFlags,  <br>            pptaga)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    /* open the property message */ <br>    hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, FALSE, <br>            &amp;lpmsg); <br> <br>    /* If the property message was successfully opened, then pass the */ <br>    /* call off to IMessage */ <br> <br>    if (hr == hrSuccess) <br>        hr = lpmsg-&gt;lpVtbl-&gt;GetPropList(lpmsg, ulFlags, pptaga); <br> <br>    UlRelease(lpmsg); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br>    DebugTraceResult(IFLD_GetPropList, hr); <br>    return HrCheckHr(hr, IMAPIProp_GetPropList); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_OpenProperty <br> - <br> *  Purpose: <br> *      Returns in *lppUnk a pointer to a newly created interface for the <br> *                  propery of pifld in ulPropTag <br> *      Not supported on folders. <br> * <br> *  Parameters <br> *       pifld          the folder object whose property interface is requested <br> *       ulPropTag          Property tag for the desired property--only ID is used. <br> *       lpiid              Pointer to the GUID for the interface <br> *       ulInterfaceOptions Specifies interface-specific behavior <br> *       ulFlags            MAPI_CREATE, MAPI_MODIFY, MAPI_DEFERRED_ERRORS <br> *       lppUnk             Pointer to the newly created interface pointer <br> * <br> *  Returns: <br> *       hr <br> * <br> */ <br>STDMETHODIMP IFLD_OpenProperty(PIFLD pifld, ULONG ulPropTag, LPCIID lpiid, <br>    ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN *lppUnk) <br>{ <br>    SCODE sc; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIProp, <br>            OpenProperty, <br>            (pifld,  <br>            ulPropTag,  <br>            lpiid,  <br>            ulInterfaceOptions,  <br>            ulFlags,  <br>            lppUnk)); <br> <br>    sc = MAPI_E_NO_SUPPORT; <br>     <br>    DebugTraceSc(IFLD_OpenProperty, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_SetProps <br> - <br> *  Purpose: <br> *      Sets the properties in pval for pifld. <br> *      lppProblems is a pointer to a structure of problems, <br> *      NULL If there weren't any. <br> * <br> *  Parameters <br> *       pifld          the folder object whose properties are to be set <br> *       cValues            count of properties to be set <br> *       pval               Pointer to a an array of property value structures. <br> *       ppErr      Pointer to address of a property problem structure <br> *                              to be returned. <br> * <br> *  Returns: <br> *       hr         PROP_E_SECURITY_VIOLATION, PROP_E_CALL_FAILED, <br> *                          PROP_E_CALL_FAILED <br> * <br> */ <br>STDMETHODIMP IFLD_SetProps(PIFLD pifld, ULONG cValues, LPSPropValue pval, <br>    LPSPropProblemArray *ppErr) <br>{ <br>    LPMESSAGE lpmsgNew = NULL;      /* new instance of property message */ <br>    HRESULT hr; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIProp, <br>            SetProps, <br>            (pifld,  <br>            cValues,  <br>            pval,  <br>            ppErr)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (!OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* open the property message */ <br>    hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, <br>        TRUE, &amp;lpmsgNew); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* set props on the property message */ <br>    hr = lpmsgNew-&gt;lpVtbl-&gt;SetProps(lpmsgNew, cValues, pval, ppErr); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsgNew-&gt;lpVtbl-&gt;SaveChanges(lpmsgNew, KEEP_OPEN_READWRITE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Must release the message before trying to update the hierarchy */ <br>    /* table. Multiple opens on the internal message are not allowed by */ <br>    /* IStorage. */ <br> <br>    UlRelease(lpmsgNew); <br>    lpmsgNew = NULL; <br> <br>    /* If this isn't the root folder, get the parent entryid, and call */ <br>    /* ChangeTable so that any new properties are updated in its */ <br>    /* hierarchy table row. */ <br> <br>    if (FIsRoot(pifld-&gt;peid) == FALSE) <br>    { <br>        PEID peidParent = NULL; <br>        PIMS pims = pifld-&gt;pims; <br> <br>        hr = HrGetParentEID(&amp;pims-&gt;lmr, pifld-&gt;peid, &amp;peidParent); <br>        if (hr == hrSuccess) <br>        { <br>            ChangeTable(pims, peidParent, pifld-&gt;peid, MAPI_FOLDER, <br>                TABLE_ROW_MODIFIED, TRUE); <br>            LMFree(&amp;pims-&gt;lmr, peidParent); <br>        } <br>        else <br>        { <br>            TraceSz1("Sample MS: IFLD_SetProps: failed to change hierarchy " <br>                "table. sc == %s\n", SzDecodeScode(GetScode(hr))); <br>            hr = hrSuccess; <br>        } <br>    } <br> <br>exit: <br>    UlRelease(lpmsgNew); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br>    DebugTraceResult(IFLD_SetProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_SetProps); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_DeleteProps <br> - <br> *  Purpose: <br> *      Deletes the properties in ptaga for pifld.  ppErr <br> *      is a pointer to a structure of problems, NULL If there weren't any. <br> * <br> *  Parameters <br> *       pifld          the folder object whose properties are to be deleted <br> *       ptaga      Pointer to a counted array of property tags of the <br> *                          properties to be deleted.  Must not be NULL. <br> *       ppErr      Pointer to address of a property problem structure <br> *                          to be returned. <br> *  Returns: <br> *       hr         PROP_E_SECURITY_VIOLATION, PROP_E_CALL_FAILED, <br> *                          PROP_E_CALL_FAILED <br> */ <br>STDMETHODIMP IFLD_DeleteProps(PIFLD pifld, LPSPropTagArray ptaga, <br>    LPSPropProblemArray *ppErr) <br>{ <br>    LPMESSAGE lpmsgNew = NULL;  /* new instance of property message */ <br>    HRESULT hr = hrSuccess; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIProp, <br>            DeleteProps, <br>            (pifld,  <br>            ptaga,  <br>            ppErr)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (!OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* open the property message */ <br>    hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, <br>        pifld-&gt;pims, TRUE, &amp;lpmsgNew); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Pass the call off to IMessage */ <br>    hr = lpmsgNew-&gt;lpVtbl-&gt;DeleteProps(lpmsgNew, ptaga, ppErr); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsgNew-&gt;lpVtbl-&gt;SaveChanges(lpmsgNew, KEEP_OPEN_READWRITE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Must release the message before trying to update the hierarchy */ <br>    /* table. Multiple opens on the internal message are not allowed by */ <br>    /* IStorage. */ <br> <br>    UlRelease(lpmsgNew); <br>    lpmsgNew = NULL; <br> <br>    /* If this isn't the root folder, get the parent entryid, and call */ <br>    /* ChangeTable so that any new properties are updated in its */ <br>    /* hierarchy table row. */ <br> <br>    if (FIsRoot(pifld-&gt;peid) == FALSE) <br>    { <br>        PEID peidParent = NULL; <br>        PIMS pims = pifld-&gt;pims; <br> <br>        hr = HrGetParentEID(&amp;pims-&gt;lmr, pifld-&gt;peid, &amp;peidParent); <br>        if (hr == hrSuccess) <br>        { <br>            ChangeTable(pims, peidParent, pifld-&gt;peid, MAPI_FOLDER, <br>                TABLE_ROW_MODIFIED, TRUE); <br>            LMFree(&amp;pims-&gt;lmr, peidParent); <br>        } <br>        else <br>        { <br>            TraceSz1("Sample MS: IFLD_DeleteProps: failed to change hierarchy " <br>                "table. sc == %s\n", SzDecodeScode(GetScode(hr))); <br>            hr = hrSuccess; <br>        } <br>    } <br> <br>exit: <br>    UlRelease(lpmsgNew); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_DeleteProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_DeleteProps); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_CopyTo <br> - <br> *  Purpose: <br> *      Copy the properties and/or contents of the current object <br> *          to a destination object <br> * <br> *  Parameters <br> *       pifldSrc       current object <br> *       ciidExcl       Count of excluded interfaces in rgiidExcl <br> *       rgiidExcl      Array of iid's specifying excluded interfaces <br> *       ptagaExcl      Pointer to a counted array of property tags of <br> *                      properties not to be copied, can be NULL <br> *       ulUIParam      Handle of parent window cast to ULONG, NULL if <br> *                      no dialog requested <br> *       piidDst        Interface ID of the interface of lpDestObj <br> *       lpDestObj      destination object <br> *       ulFlags        MAPI_MOVE, MAPI_NOREPLACE, MAPI_DIALOG, MAPI_DECLINE_OK <br> *       pprba          Pointer to address of a property problem <br> *                      structure to be returned. <br> * <br> *  Returns: <br> *       hr <br> * <br> *  Side effects: <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IFLD_CopyTo(PIFLD pifldSrc, ULONG ciidExcl, LPCIID rgiidExcl, <br>    LPSPropTagArray ptagaExcl, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, <br>    LPCIID piidDst, LPVOID lpDestObj, ULONG ulFlagsIn, <br>    LPSPropProblemArray *pprba) <br>{ <br>    HRESULT hr = hrSuccess; <br>    BOOL fIsIMapiProp = TRUE;   /* TRUE if are to copy as imapiprop */ <br>    BOOL fIsIMAPIFolder = TRUE;     /* TRUE if are to copy as IMAPIFolder */ <br>    SCODE sc = S_OK; <br>    LPCIID piid; <br>    LPCIID piidMax; <br>    ULONG ulFlags; <br> <br>    FLD_ValidateParameters( <br>            pifldSrc,  <br>            IMAPIProp, <br>            CopyTo, <br>            (pifldSrc,  <br>            ciidExcl,  <br>            rgiidExcl, <br>            ptagaExcl,  <br>            ulUIParam,  <br>            lpProgress, <br>            piidDst,  <br>            lpDestObj,  <br>            ulFlagsIn, <br>            pprba)); <br> <br>    IFLD_EnterCriticalSection(pifldSrc); <br> <br>    /* Turn off MAPI_DIALOG flag, since we don't support it. */ <br>    ulFlags = (ulFlagsIn &amp; ~MAPI_DIALOG); <br> <br>    piid = rgiidExcl; <br>    piidMax = piid + ciidExcl; <br> <br>    /* find the interface to copy : IMAPIPROP or IMAPIFOLDER */ <br>    while (piid &lt; piidMax) <br>    { <br>        if (IsEqualIID(piid, &amp;IID_IMAPIFolder)) <br>            fIsIMAPIFolder = FALSE; <br>        else if (IsEqualIID(piid, (LPIID) &amp;IID_IMAPIProp)) <br>            fIsIMapiProp = FALSE; <br>        piid++; <br>    } <br> <br>    /* make sure that the destination can support this */ <br>    if (fIsIMAPIFolder &amp;&amp; !IsEqualIID(piidDst, (LPIID) &amp;IID_IMAPIFolder)) <br>    { <br>        LPMAPIFOLDER pfld = NULL; <br> <br>        hr = ((LPUNKNOWN) lpDestObj)-&gt;lpVtbl-&gt;QueryInterface(lpDestObj, <br>            (LPIID) &amp;IID_IMAPIFolder, (LPVOID *) &amp;pfld); <br>        if (hr != hrSuccess) <br>        { <br>            Assert(GetScode(hr) == MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            goto exit; <br>        } <br>        UlRelease(pfld); <br>    } <br>    else if (fIsIMapiProp &amp;&amp; <br>            !(IsEqualIID(piidDst, (LPIID) &amp;IID_IMAPIProp) || <br>            IsEqualIID(piidDst, (LPIID) &amp;IID_IMAPIFolder))) <br>    { <br>        LPMAPIPROP pmp = NULL; <br> <br>        hr = ((LPUNKNOWN) lpDestObj)-&gt;lpVtbl-&gt;QueryInterface(lpDestObj, <br>            (LPIID) &amp;IID_IMAPIProp, (LPVOID *) &amp;pmp); <br>        if (hr != hrSuccess) <br>        { <br>            Assert(GetScode(hr) == MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            goto exit; <br>        } <br>        UlRelease(pmp); <br>    } <br> <br>    if (!FFoldInSameStore(pifldSrc, (PIFLD) lpDestObj)) <br>    { <br>        LPMAPISUP psup = pifldSrc-&gt;pims-&gt;psup; <br> <br>        /* leave critical section before calling back to MAPI */ <br>        IFLD_LeaveCriticalSection(pifldSrc); <br> <br>        /* call MAPI's CopyProps */ <br>        hr = psup-&gt;lpVtbl-&gt;DoCopyTo(psup, (LPIID) &amp;IID_IMAPIFolder, (LPVOID) pifldSrc, <br>            ciidExcl, rgiidExcl, ptagaExcl, ulUIParam, <br>            lpProgress, piidDst, lpDestObj, ulFlagsIn, pprba); <br> <br>        DebugTraceResult(IFLD_CopyTo, hr); <br>        return (HrCheckHr(hr, IMAPIProp_CopyTo)); <br>    } <br> <br>    /* copy them as folders */ <br>    if (fIsIMAPIFolder) <br>    { <br>        PIFLD pifldDst = (PIFLD) lpDestObj; <br> <br>        /* make sure we have write access */ <br> <br>        if (!OBJ_TestFlag(pifldDst, OBJF_MODIFY)) <br>        { <br>            hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>            goto exit; <br>        } <br> <br>        if (!FContainsProp(PR_CONTAINER_HIERARCHY, ptagaExcl)) <br>        { <br>            /* can not move or copy a folder to a decendant or itself */ <br>            if (FIsAncestor(pifldSrc, pifldDst)) <br>                hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        } <br>        else if (ulFlags &amp; MAPI_MOVE) <br>        { <br>            /* Can't set MAPI_MOVE and also exclude subfolders. */ <br>            hr = ResultFromScode(MAPI_E_INVALID_PARAMETER); <br>        } <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (!(ulFlags &amp; MAPI_NOREPLACE)) <br>        { <br>            /* Empty the destination folder before beginning. */ <br>            hr = pifldDst-&gt;lpVtbl-&gt;EmptyFolder(pifldDst, 0, NULL, 0); <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br> <br>        /* copy the contents of the source folder to the destination folder */ <br>        hr = HrCopyContents(pifldSrc, pifldDst, ulFlags, ptagaExcl); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    /* copy the properties */ <br>    if (fIsIMapiProp || fIsIMAPIFolder) <br>    { <br>        LPMESSAGE lpmsg; <br>        BOOL fModify = FALSE; <br> <br>        if (ulFlags &amp; MAPI_MOVE) <br>            fModify = TRUE; <br> <br>        hr = HrOpenPropertyMessageRetry(pifldSrc-&gt;peid, <br>            pifldSrc-&gt;pims, fModify, &amp;lpmsg); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = lpmsg-&gt;lpVtbl-&gt;CopyTo(lpmsg, ciidExcl, <br>            rgiidExcl, ptagaExcl, ulUIParam, lpProgress, <br>            (LPIID) &amp;IID_IMAPIProp, lpDestObj, ulFlags, pprba); <br> <br>        if (hr == hrSuccess &amp;&amp; fModify) <br>            lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, KEEP_OPEN_READWRITE); <br> <br>        UlRelease(lpmsg); <br>    } <br> <br>exit: <br>    IFLD_LeaveCriticalSection(pifldSrc); <br> <br>    DebugTraceResult(IFLD_CopyTo, hr); <br>    return HrCheckHr(hr, IMAPIProp_CopyTo); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_CopyProps <br> - <br> *  Purpose: <br> *      Copy the properties and/or contents of the current object <br> *          to a destination object <br> * <br> *  Parameters <br> *       pifldSrc       current object <br> *       ptagaIncl      Pointer to a counted array of property tags of <br> *                      properties to be copied <br> *       ulUIParam      Handle of parent window cast to ULONG, NULL if <br> *                      no dialog requested <br> *       piidDst        Interface ID of the interface of lpDestObj <br> *       lpDestObj      destination object <br> *       ulFlags        MAPI_MOVE, MAPI_NOREPLACE, MAPI_DIALOG, MAPI_DECLINE_OK <br> *       pprba          Pointer to address of a property problem <br> *                      structure to be returned. <br> * <br> *  Returns: <br> *       hr <br> * <br> *  Side effects: <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IFLD_CopyProps(PIFLD pifldSrc, <br>    LPSPropTagArray ptagaIncl, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, <br>    LPCIID piidDst, LPVOID lpDestObj, ULONG ulFlagsIn, <br>    LPSPropProblemArray *pprba) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>#ifdef WHEN_WORKING <br>    PIFLD pifldDst = NULL;      /* lpDestObj if it's a folder */ <br>    BOOL fIsIMAPIFolder;        /* TRUE if are to copy as IMAPIFolder */ <br>    SCODE sc = S_OK; <br>    LPIID piid; <br>    LPIID piidMax; <br>    ULONG ulFlags; <br>#endif /* WHEN_WORKING */ <br> <br>    FLD_ValidateParameters( <br>            pifldSrc,  <br>            IMAPIProp, <br>            CopyProps, <br>            (pifldSrc, <br>            ptagaIncl,  <br>            ulUIParam,  <br>            lpProgress, <br>            piidDst,  <br>            lpDestObj,  <br>            ulFlagsIn, <br>            pprba)); <br> <br>    IFLD_EnterCriticalSection(pifldSrc); <br> <br>#ifdef WHEN_WORKING <br>    /* Turn off MAPI_DIALOG flag, since we don't support it. */ <br>    ulFlags = (ulFlagsIn &amp; ~MAPI_DIALOG); <br> <br>    fIsIMAPIFolder =   FContainsProp(PR_CONTAINER_HIERARCHY, ptagaIncl) <br>                    || FContainsProp(PR_CONTAINER_CONTENTS, ptagaIncl); <br>    /* make sure that the destination can support this */ <br>    if (fIsIMAPIFolder &amp;&amp; !IsEqualIID(piidDst, (LPIID) &amp;IID_IMAPIFolder)) <br>    { <br>        LPMAPIFOLDER pfld = NULL; <br> <br>        hr = ((LPUNKNOWN) lpDestObj)-&gt;lpVtbl-&gt;QueryInterface(lpDestObj, <br>            (LPIID) &amp;IID_IMAPIFolder, (LPVOID *) &amp;pfld); <br>        if (hr != hrSuccess) <br>        { <br>            Assert(GetScode(hr) == MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            goto exit; <br>        } <br>        UlRelease(pfld); <br>    } <br>    else if (!(IsEqualIID(piidDst, (LPIID) &amp;IID_IMAPIProp) || <br>            IsEqualIID(piidDst, (LPIID) &amp;IID_IMAPIFolder))) <br>    { <br>        LPMAPIPROP pmp = NULL; <br> <br>        hr = ((LPUNKNOWN) lpDestObj)-&gt;lpVtbl-&gt;QueryInterface(lpDestObj, <br>            (LPIID) &amp;IID_IMAPIProp, (LPVOID *) &amp;pmp); <br>        if (hr != hrSuccess) <br>        { <br>            Assert(GetScode(hr) == MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            goto exit; <br>        } <br>        UlRelease(pmp); <br>    } <br> <br>    if (!FFoldInSameStore(pifldSrc, (PIFLD) lpDestObj)) <br>    { <br>        LPMAPISUP psup = pifldSrc-&gt;pims-&gt;psup; <br> <br>        /* leave critical section before calling back to MAPI */ <br>        IFLD_LeaveCriticalSection(pifldSrc); <br> <br>        /* call MAPI's CopyProps */ <br>        hr = psup-&gt;lpVtbl-&gt;DoCopyProps(psup, (LPIID) &amp;IID_IMAPIFolder, <br>            (LPVOID) pifldSrc, ptagaIncl, ulUIParam, <br>            lpProgress, piidDst, lpDestObj, ulFlagsIn, pprba); <br> <br>        DebugTraceResult(IFLD_CopyProps, hr); <br>        return (HrCheckHr(hr, IMAPIProp_CopyProps)); <br>    } <br> <br>    /* copy them as folders */ <br>    if (fIsIMAPIFolder) <br>    { <br>        PIFLD pifldDst = (PIFLD) lpDestObj; <br> <br>        /* make sure we have write access */ <br> <br>        if (!OBJ_TestFlag(pifldDst, OBJF_MODIFY)) <br>        { <br>            hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>            goto exit; <br>        } <br> <br>        if (FContainsProp(PR_CONTAINER_HIERARCHY, ptagaIncl)) <br>        { <br>            /* can not move or copy a folder to a decendant or itself */ </code></pre>
<p>
</p>
<pre><code>if (FIsAncestor(pifldSrc, pifldDst)) <br>                hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        } <br>        else if (ulFlags &amp; MAPI_MOVE) <br>        { <br>            /* Can't set MAPI_MOVE and also exclude subfolders. */ <br>            hr = ResultFromScode(MAPI_E_INVALID_PARAMETER); <br>        } <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (!(ulFlags &amp; MAPI_NOREPLACE)) <br>        { <br>            /* Empty the destination folder before beginning. */ <br>            hr = pifldDst-&gt;lpVtbl-&gt;EmptyFolder(pifldDst, 0, NULL, 0); <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br> <br> <br>        if (FContainsProp(PR_CONTAINER_CONTENTS, ptagaIncl)) <br>        { <br>            /* copy the contents of the source folder to the destination folder */ <br>            hr = HrCopyContents(pifldSrc, pifldDst, ulFlags, NULL); <br>        } <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    /* copy the properties */ <br>    /* //$ Rebuild ptagaIncl without Contents and Hierarchy */ <br>    { <br>        LPMESSAGE lpmsg; <br>        BOOL fModify = FALSE; <br> <br>        if (ulFlags &amp; MAPI_MOVE) <br>            fModify = TRUE; <br> <br>        hr = HrOpenPropertyMessageRetry(pifldSrc-&gt;peid, <br>            pifldSrc-&gt;pims, fModify, &amp;lpmsg); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = lpmsg-&gt;lpVtbl-&gt;CopyProps(lpmsg, <br>            ptagaIncl, ulUIParam, lpProgress, <br>            (LPIID) &amp;IID_IMAPIProp, lpDestObj, ulFlags, pprba); <br> <br>        if (hr == hrSuccess &amp;&amp; fModify) <br>            lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, KEEP_OPEN_READWRITE); <br> <br>        UlRelease(lpmsg); <br>    } <br> <br> <br>exit: <br>    IFLD_LeaveCriticalSection(pifldSrc); <br> <br>#else <br> <br>    IFLD_LeaveCriticalSection(pifldSrc); <br> <br>    /* call MAPI's CopyProps */ <br>    hr = pifldSrc-&gt;pims-&gt;psup-&gt;lpVtbl-&gt;DoCopyProps(pifldSrc-&gt;pims-&gt;psup, <br>        (LPIID) &amp;IID_IMAPIFolder, (LPVOID) pifldSrc, ptagaIncl, ulUIParam, <br>        lpProgress, piidDst, lpDestObj, ulFlagsIn, pprba); <br> <br>#endif  /* WHEN_WORKING */ <br> <br>    DebugTraceResult(IFLD_CopyProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_CopyProps); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_GetContentsTable <br> - <br> *  Purpose: <br> *      Returns a table with the summary information about the messages <br> *      in the folder <br> * <br> *  Parameters <br> *       pifld  the folder object <br> *       ulFlags    MAPI_DEFERRED_ERRORS, MAPI_ASSOCIATED <br> *       lppTable   location to place the table object <br> * <br> *  Returns: <br> * <br> *  Side effects: <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IFLD_GetContentsTable(PIFLD pifld, ULONG ulFlags, <br>    LPMAPITABLE *lppTable) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc; <br>    HANDLE hFindFile = FAILED_SEARCH; <br>    LPTSTR szMessageTemplate = NULL;    /* template for a message name */ <br>    LPSSortOrderSet lpsSortOrder = NULL; <br>    BOOL fTableCreated = FALSE; <br>    BOOL fInMutex = FALSE; <br>    PIMS pims; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIContainer, <br>            GetContentsTable, <br>            (pifld,  <br>            ulFlags, <br>            lppTable)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_ASSOCIATED) <br>        return ResultFromScode(MAPI_E_NO_SUPPORT); <br>     <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    pims = pifld-&gt;pims; <br> <br>    /* If the table mutex doesn't yet exist on this process, create it. */ <br> <br>    if (pims-&gt;hContTblMutex == NULL) <br>    { <br>        hr = HrCreateContTblMutex(&amp;pims-&gt;hContTblMutex); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    if (pifld-&gt;lptblContents == NULL) <br>    { <br>        PINST pinst = (PINST) PvGetInstanceGlobals(); <br>        PLMR plmr = &amp;pifld-&gt;pims-&gt;lmr; <br> <br>        if (pinst == NULL) <br>        { <br>            hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>            goto exit; <br>        } <br> <br>        /* create the data for the table */ <br>        sc = CreateTable((LPIID) &amp;IID_IMAPITableData, <br>            plmr-&gt;lpAllocBuf, plmr-&gt;lpAllocMore, <br>            plmr-&gt;lpFreeBuf, pinst-&gt;lpmalloc, TBLTYPE_DYNAMIC, <br>            PR_INSTANCE_KEY, (LPSPropTagArray) &amp;sPropTagsContents, <br>            &amp;(pifld-&gt;lptblContents)); <br> <br>        if (sc != S_OK) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto exit; <br>        } <br>        fTableCreated = TRUE; <br> <br>        /* Get the table mutex so that we can access the file without */ <br>        /* crossing paths with another process. */ <br> <br>        WaitForSingleObject(pims-&gt;hContTblMutex, INFINITE); <br>        fInMutex = TRUE; <br> <br>        hr = HrReadTableFromDisk(pifld-&gt;lptblContents, (POBJ) pifld, <br>            pifld-&gt;peid-&gt;szPath, CONTENTS_COLUMNS, szContentsFileName); <br>        if (hr != hrSuccess) <br>        { <br>            /* non-fatal. If the data on disk is missing or invalid, we */ <br>            /* should regenerate the data via HrSyncContentsTable. */ <br> <br>            TraceSz1("SMS: Error %s reading table from disk. Regenerating " <br>                "table on disk.", SzDecodeScode(GetScode(hr))); <br> <br>            hr = hrSuccess; <br>        } <br>    } <br> <br>    /* If we don't already have the mutex, get it so that we can access */ <br>    /* the file without crossing paths with another process. */ <br> <br>    if (!fInMutex) <br>    { <br>        WaitForSingleObject(pims-&gt;hContTblMutex, INFINITE); <br>        fInMutex = TRUE; <br>    } <br> <br>    hr = HrSyncContentsTable(pifld, TRUE); <br> <br>    Assert(fInMutex); <br> <br>    ReleaseMutex(pims-&gt;hContTblMutex); <br>    fInMutex = FALSE; <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* open a view to the table */ <br>    /* get the sort order from the PR_SMS_CONTENTS_SORT_ORDER property */ <br>    hr = HrGetSortOrder(pifld, &amp;lpsSortOrder); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* get the view */ <br>    hr = pifld-&gt;lptblContents-&gt;lpVtbl-&gt;HrGetView(pifld-&gt;lptblContents, <br>        lpsSortOrder, ViewRelease, (ULONG) pifld, lppTable); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* record this view in pifld */ <br>    pifld-&gt;cContentsViews++; <br> <br>exit: <br>    if (fInMutex) <br>        ReleaseMutex(pims-&gt;hContTblMutex); <br> <br>    /* free the sort order */ <br>    LMFree(&amp;pifld-&gt;pims-&gt;lmr, lpsSortOrder); <br> <br>    /* remove the table if it is created in error */ <br>    if (hr != hrSuccess &amp;&amp; fTableCreated) <br>    { <br>        UlRelease(pifld-&gt;lptblContents); <br>        pifld-&gt;cContentsViews = 0; <br>        pifld-&gt;lptblContents = NULL; <br>    } <br> <br>    CloseIDSearch(&amp;hFindFile, &amp;szMessageTemplate); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_GetContentsTable, hr); <br>    return HrCheckHr(hr, IMAPIFolder_GetContentsTable); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_GetHierarchyTable <br> - <br> *  Purpose: <br> *      Returns a table with the summary information about the child <br> *      folders of the current folder <br> * <br> *  Parameters <br> *       pifld      the folder object <br> *       ulFlags    CONVENIENT_DEPTH if set indicates pre-order traversal <br> *                  MAPI_DEFERRED_ERRORS <br> *                  MAPI_UNICODE <br> *       lppTable   location to place the table object <br> * <br> *  Returns: <br> * <br> *  Side effects: <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IFLD_GetHierarchyTable(PIFLD pifld, ULONG ulFlags, <br>    LPMAPITABLE *lppTable) <br>{ <br>    HRESULT hr; <br>    LPTABLEDATA lptad = NULL; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIContainer, <br>            GetHierarchyTable, <br>            (pifld,  <br>            ulFlags,  <br>            lppTable)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    /* if table needs refreshing */ <br>    if (pifld-&gt;lptblHierarchy == NULL) <br>    { <br>        PINST pinst = (PINST) PvGetInstanceGlobals(); <br>        SCODE sc; <br>        PLMR plmr = &amp;pifld-&gt;pims-&gt;lmr; <br> <br>        pifld-&gt;cHierarchyViews = 0; <br> <br>        if (pinst == NULL) <br>        { <br>            hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>            goto exit; <br>        } <br> <br>        /* create the table */ <br>        sc = CreateTable((LPIID) &amp;IID_IMAPITableData, <br>            plmr-&gt;lpAllocBuf, plmr-&gt;lpAllocMore, <br>            plmr-&gt;lpFreeBuf, pinst-&gt;lpmalloc, TBLTYPE_DYNAMIC, <br>            PR_INSTANCE_KEY, (LPSPropTagArray) &amp;sPropTagsHierarchy, &amp;lptad); <br> <br>        if (sc != S_OK) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto exit; <br>        } <br> <br>        /* add a row or traversal for each subfolder of pifld */ <br>        /* Note that the sample store only supports a max depth of 1. */ <br> <br>        hr = HrFillHierarchyTable(pifld, lptad); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        pifld-&gt;lptblHierarchy = lptad; <br>        lptad = NULL; <br>    } <br> <br>    /* open a view to the table */ <br>    hr = pifld-&gt;lptblHierarchy-&gt;lpVtbl-&gt;HrGetView(pifld-&gt;lptblHierarchy, <br>        NULL, ViewRelease, (ULONG) pifld, lppTable); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* record this view in pifld */ <br>    pifld-&gt;cHierarchyViews++; <br> <br>exit: <br>    /* remove the table if it is created in error */ <br>    if (hr != hrSuccess &amp;&amp; lptad) <br>        UlRelease(lptad); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_GetHierarchyTable, hr); <br>    return HrCheckHr(hr, IMAPIFolder_GetHierarchyTable); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_CreateMessage <br> - <br> *  Purpose: <br> *      Creates a new message in the store <br> * <br> *  Parameters <br> *      pifld           the folder object <br> *      ulFlags         flags. Valid flags to pass are MAPI_DEFERRED_ERRORS <br> *                      and MAPI_ASSOCIATED. The sample store doesn't support <br> *                      MAPI_ASSOCIATED, so the code returns no support if <br> *                      that flag is passed. <br> *      piid            reserved for future use <br> *      lppMessage      location to place the message object <br> * <br> *  Returns: <br> * <br> *  Side effects: <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IFLD_CreateMessage(PIFLD pifld, LPCIID piid, ULONG ulFlags, <br>    LPMESSAGE *lppMessage) <br>{ <br>    HRESULT hr; <br>    PEID peid = NULL; <br>    ULONG ulSeqNumber; <br>    PIMSG pimsg = NULL; <br>    LPTSTR szFull = NULL; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            CreateMessage, <br>            (pifld,  <br>            piid,  <br>            ulFlags,  <br>            lppMessage)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_ASSOCIATED) <br>        return ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    if (piid &amp;&amp; !FQueryInterface(OT_MESSAGE, piid)) <br>        return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>    #endif <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (!OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* create the message */ <br> <br>    hr = HrNewEID(pifld, pifld-&gt;pims, TEMP_EXT, &amp;ulSeqNumber, &amp;peid); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrNewIMSG(peid, pifld-&gt;pims, TRUE, TRUE, ulSeqNumber, &amp;szFull, &amp;pimsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = InitIMSGProps(pimsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* folder contents counts and tables are not updated until message */ <br>    /* has changes saved */ <br> <br>exit: <br>    LMFree(&amp;pifld-&gt;pims-&gt;lmr, peid); <br> <br>    if (hr == hrSuccess) <br>        *lppMessage = (LPMESSAGE) pimsg; <br>    else if (pimsg) <br>    { <br>        UlRelease(pimsg); <br> <br>        Assert(szFull); <br>        DeleteFile(szFull); <br>    } <br> <br>    FreeNull(szFull); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_CreateMessage, hr); <br>    return HrCheckHr(hr, IMAPIFolder_CreateMessage); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_CopyMessages <br> - <br> *  Purpose: <br> *      Moves/Copies messages from the source folder to the destination folder <br> *      EntryId's are not changed here since they get stamped in when the <br> *      messages are opened. <br> * <br> *  Parameters <br> *      pifld                   the source folder <br> *      lpMsgList               the list of messages to be moved/copied <br> *      piid                    the interface id of destination folder <br> *      lpfolderDst             the destination folder <br> *      ulUIParam               Handle of parent window, <br> *                                  ignored if MESSAGE_DIALOG not set <br> *      lpProgress              points to progress dialog object <br> *      ulFlags                 MAPI_DECLINE_OK, MESSAGE_MOVE, or MESSAGE_DIALOG <br> */ <br>STDMETHODIMP IFLD_CopyMessages(PIFLD pifld, LPENTRYLIST lpMsgList, <br>    LPCIID piid, LPMAPIFOLDER lpfolderDst, ULONG ulUIParam, <br>    LPMAPIPROGRESS lpProgress, ULONG ulFlags) <br>{ <br>    LONG cHandled = 0;          /* number messages copied/moved */ <br>    LPTSTR szSrcName = NULL;    /* name of file to be moved */ <br>    LPTSTR szDestName = NULL;   /* name of the file after it is moved */ <br>    ULONG cbSrcPath = 0;        /* length in bytes of path to src fld */ <br>    ULONG cbDestPath = 0;       /* length in bytes of path to dest fld */ <br>    ULONG cbStorePath = 0;      /* length in bytes of path to root of store */ <br>    TCHAR szBlanks[CCH_NAME] = TEXT("        .   "); <br>    HRESULT hr = hrSuccess; <br>    PIFLD pifldDst; <br>    BOOL fMove; <br>    SBinary *psb; <br>    SBinary *psbMax; <br>    PIMS pims; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            CopyMessages, <br>            (pifld,  <br>            lpMsgList,  <br>            piid,  <br>            lpfolderDst,  <br>            ulUIParam,  <br>            lpProgress,  <br>            ulFlags)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    pifldDst = (PIFLD) lpfolderDst; <br>    pims = pifld-&gt;pims; <br> <br>    /* if the folders aren't in the same store, call back to MAPI */ <br> <br>    if (!FFoldInSameStore(pifld, pifldDst)) <br>    { <br>        /* leave critical section before calling back to MAPI */ <br>        IFLD_LeaveCriticalSection(pifld); <br> <br>        return pims-&gt;psup-&gt;lpVtbl-&gt;CopyMessages(pims-&gt;psup, <br>            (LPIID) &amp;IID_IMAPIFolder, (LPVOID) pifld, lpMsgList, piid, <br>            (LPVOID) lpfolderDst, ulUIParam, lpProgress, ulFlags); <br>    } <br> <br>    fMove   = !!(ulFlags &amp; MESSAGE_MOVE); <br> <br>    if (    !OBJ_TestFlag(pifldDst, OBJF_MODIFY) <br>        ||  (   fMove <br>            &amp;&amp;  !OBJ_TestFlag(pifld, OBJF_MODIFY))) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    if (fMove) <br>    { <br>        /* If moving messages and the source and destination are the same */ <br>        /* folder, we are done even before we begin. */ <br> <br>        ULONG ulTheSame; <br> <br>        hr = pims-&gt;lpVtbl-&gt;CompareEntryIDs(pims, <br>                CbEID(pifldDst-&gt;peid), (LPENTRYID) pifldDst-&gt;peid, <br>                CbEID(pifld-&gt;peid), (LPENTRYID) pifld-&gt;peid, 0L, &amp;ulTheSame); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (ulTheSame) <br>        { <br>            hr = hrSuccess; <br>            goto exit; <br>        } <br>    } <br> <br>    /* get storage for the path names */ <br>    cbStorePath = Cbtszsize(pims-&gt;szStorePath); <br>    cbSrcPath = cbStorePath + CbEIDPath(pifld-&gt;peid); <br>    if (FIsRoot(pifld-&gt;peid)) <br>        cbSrcPath--; <br> <br>    cbDestPath = cbStorePath + CbEIDPath(pifldDst-&gt;peid); <br>    if (FIsRoot(pifldDst-&gt;peid)) <br>        cbDestPath--; <br> <br>    hr = HrFullPathName(pims-&gt;szStorePath, pifld-&gt;peid-&gt;szPath, <br>        szBlanks, &amp;szSrcName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrFullPathName(pims-&gt;szStorePath, pifldDst-&gt;peid-&gt;szPath, <br>        szBlanks, &amp;szDestName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    psb = lpMsgList-&gt;lpbin; <br>    psbMax = psb + lpMsgList-&gt;cValues; <br> <br>    /* move/copy each message */ <br>    while (psb &lt; psbMax) <br>    { <br>        ULONG ulMF; <br>        ULONG ulObjType; <br>        BOOL fLocked; <br>        BOOL fRead; <br>        PIMSG pimsg; <br>        LPSTR szRelativePath; <br>        PEID peidNewID; <br>        PEID peidToCopy; <br>        ULONG cbEntryID; <br> <br>        cbEntryID = psb-&gt;cb; <br>        peidToCopy = (PEID) (psb-&gt;lpb); <br> <br>        if (    FIsInvalidEID(cbEntryID, peidToCopy, pims) <br>            ||  !FIsMessage((PEID) peidToCopy)) <br>        { <br>            hr = ResultFromScode(MAPI_E_INVALID_PARAMETER); <br>            goto exit; <br>        } <br> <br>        /* open the message */ <br>        hr = pifld-&gt;lpVtbl-&gt;OpenEntry(pifld, CbEID(peidToCopy), <br>                (LPENTRYID) peidToCopy, NULL, 0L, &amp;ulObjType, <br>                (LPUNKNOWN *) &amp;pimsg); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        Assert(ulObjType == MAPI_MESSAGE); <br> <br>        /* retrieve the PR_MESSAGE_FLAGS property */ <br>        hr = HrGetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, &amp;pims-&gt;lmr, <br>                PR_MESSAGE_FLAGS, &amp;ulMF); <br> <br>        UlRelease(pimsg); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        fLocked = !!(ulMF &amp; MSGFLAG_SUBMIT); <br>        fRead = !!(ulMF &amp; MSGFLAG_READ); <br> <br>        /* if the message is locked then this is an error */ <br>        if (fLocked) <br>        { <br>            hr = ResultFromScode(MAPI_E_INVALID_PARAMETER); <br>            goto exit; <br>        } <br> <br>        /* store in szSrcName the root relative path of the message to be moved*/ <br>        lstrcpy(szSrcName + cbSrcPath, SzBaseName(peidToCopy)); <br> <br>        /* store in szDestName the store relative path name of */ <br>        /* destination file */ <br>        if (fMove) <br>            lstrcpy(szDestName + cbDestPath, SzBaseName(peidToCopy)); <br>        else <br>        { <br>            /* If we're copying, we need to generate a new filename for the */ <br>            /* message, or else we will have two messages with the same */ <br>            /* filename, and copying again (or moving back) will fail. */ <br> <br>            PEID peidTemp = NULL; <br> <br>            hr = HrNewEID(pifld, pims, MESSAGE_EXT, NULL, &amp;peidTemp); <br>            if (hr != hrSuccess) <br>                goto exit; <br> <br>            lstrcpy(szDestName + cbDestPath, SzBaseName(peidTemp)); <br> <br>            LMFree(&amp;pims-&gt;lmr, peidTemp); <br>        } <br> <br>        /* either move or copy the message */ <br>        if (fMove) <br>        { <br>            if (!MoveFile(szSrcName, szDestName)) <br>            { <br>                TraceSz1("MoveFile failed: OS error %08lX.", GetLastError()); <br>                hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>                goto exit; <br>            } <br> <br>            /* remove this message from contents tables */ <br> <br>            (void) HrIncrementOneROProp(pifld, -1, PR_CONTENT_COUNT); <br> <br>            if (!fRead) <br>                (void) HrIncrementOneROProp(pifld, -1, PR_CONTENT_UNREAD); <br> <br>            ChangeTable(pims, pifld-&gt;peid, peidToCopy, MAPI_MESSAGE, <br>                TABLE_ROW_DELETED, TRUE); <br>        } <br>        else <br>        { <br>            if (!CopyFile(szSrcName, szDestName, TRUE)) <br>            { <br>                TraceSz1("CopyFile failed: OS error %08lX.", GetLastError()); <br>                hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>                goto exit; <br>            } <br>        } <br> <br>        /* get new entryid for this message */ <br>        hr = HrFullToRelative(szDestName, pims, &amp;szRelativePath); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = HrConstructEID(&amp;(peidToCopy-&gt;uidResource), &amp;pims-&gt;lmr, <br>                szRelativePath, &amp;peidNewID); <br> <br>        FreeNull(szRelativePath); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        /* If we're copying, then we just used a new name for the file. */ <br>        /* Note that PR_RECORD_KEY, PR_ENTRYID, PR_INSTANCE_KEY, and */ <br>        /* PR_PARENT_ENTRYID are now different, but since these are stored */ <br>        /* in the opened msg, everything should be fine. */ <br> <br>        /* add a row to the contents table of the destination folder */ <br>        (void) HrIncrementOneROProp(pifldDst, 1, PR_CONTENT_COUNT); <br> <br>        if (!fRead) <br>            (void) HrIncrementOneROProp(pifldDst, 1, PR_CONTENT_UNREAD); <br> <br>        ChangeTable(pims, pifldDst-&gt;peid, peidNewID, MAPI_MESSAGE, <br>            TABLE_ROW_ADDED, TRUE); <br> <br>        LMFree(&amp;pims-&gt;lmr, peidNewID); <br> <br>        cHandled++; <br>        psb++; <br>    } <br> <br>exit: <br>    FreeNull(szDestName); <br>    FreeNull(szSrcName); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_CopyMessages, hr); <br>    return HrCheckHr(hr, IMAPIFolder_CopyMessages); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_DeleteMessages <br> - <br> *  Purpose: <br> *      Deletes from the folder pifld all messages in the list lpMsgList <br> * <br> *  Parameters <br> *      pifld           the folder from which messages are to be deleted <br> *      lpMsgList       the list of messages to be deleted <br> *      ulUIParam       handle to main window, cast to ULONG <br> *      lpProgress      points to progress dialog information <br> *      ulFlags         MESSAGE_DIALOG <br> * <br> *  Returns: <br> * <br> *  Side effects: <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IFLD_DeleteMessages(PIFLD pifld, LPENTRYLIST lpMsgList, <br>    ULONG ulUIParam, LPMAPIPROGRESS lpProgress, ULONG ulFlags) <br>{ <br>    PEID peidToDelete = NULL;   /* pointer to next eid to be deleted */ <br>    LONG cDeleted = 0;          /* number messages deleted */ <br>    LONG cUnreadDeleted = 0;    /* number of unread messages deleted */ <br>    LPTSTR szToDeleteName = NULL;   /* name of the next message to be deleted */ <br>    HRESULT hr = hrSuccess; <br>    LPTSTR szBlankName = TEXT("        .   "); <br>    ULONG cchPath;              /* length of path to message */ <br>    BOOL fIsRead;               /* TRUE if deleting a read message */ <br>    DWORD dwErr; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            DeleteMessages, <br>            (pifld,  <br>            lpMsgList, <br>            ulUIParam,  <br>            lpProgress,  <br>            ulFlags)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (!OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    hr = HrFullPathName(pifld-&gt;pims-&gt;szStorePath, pifld-&gt;peid-&gt;szPath, <br>        szBlankName, &amp;szToDeleteName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    cchPath = lstrlen(szToDeleteName) - lstrlen(szBlankName); <br> <br>    /* delete each message in lpMsgList up until the first error */ <br>    while ((ULONG) cDeleted &lt; lpMsgList-&gt;cValues) <br>    { <br>        peidToDelete = (PEID) (lpMsgList-&gt;lpbin[cDeleted].lpb); <br> <br>        /* make sure that this is a message's eid */ <br>        if (!FIsMessage(peidToDelete)) <br>        { <br>            hr = ResultFromScode(MAPI_E_INVALID_PARAMETER); <br>            goto exit; <br>        } <br> <br>        /* make sure the message is not submitted */ <br>        if (FIsSubmittedMessage(pifld-&gt;pims, peidToDelete)) <br>        { <br>            hr = ResultFromScode(MAPI_E_SUBMITTED); <br>            goto exit; <br>        } <br> <br>        /* See if it has been read */ <br>        hr = HrIsRead(pifld, peidToDelete, &amp;fIsRead); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        /* remove the message from disk */ <br>        lstrcpy(szToDeleteName + cchPath, SzBaseName(peidToDelete)); <br>        if (!DeleteFile(szToDeleteName)) <br>        { <br>            dwErr = GetLastError(); <br> <br>            if ((dwErr != ERROR_FILE_NOT_FOUND &amp;&amp; dwErr != ERROR_PATH_NOT_FOUND) <br>                || lpMsgList-&gt;cValues == 1) <br>            { <br>                hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>                goto exit; <br>            } <br>        } <br> <br>        /* remove this message from any open tables */ <br>        ChangeTable(pifld-&gt;pims, pifld-&gt;peid, peidToDelete, MAPI_MESSAGE, <br>            TABLE_ROW_DELETED, TRUE); <br> <br>        if (!fIsRead) <br>            cUnreadDeleted++; <br> <br>        cDeleted++; <br>    } <br> <br>exit: <br> <br>    FreeNull(szToDeleteName); <br> <br>    if (cDeleted) <br>        (void) HrIncrementOneROProp(pifld, -cDeleted, PR_CONTENT_COUNT); <br>    if (cUnreadDeleted) <br>        (void) HrIncrementOneROProp(pifld, -cUnreadDeleted, PR_CONTENT_UNREAD); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_DeleteMessages, hr); <br>    return HrCheckHr(hr, IMAPIFolder_DeleteMessages); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_CreateFolder <br> - <br> *  Purpose: <br> *      Create a new folder within the message store <br> * <br> *  Parameters <br> *      pifld               the parent folder of the newly created folder <br> *      ulFldType           type of folder to be created <br> *      szFldName           name of the new folder <br> *      szComment           comment string for the new folder <br> *      piid                Reserved; must be NULL. <br> *      ulFlags             MAPI_UNICODE and/or MAPI_DEFERRED_ERRORS <br> *      lppfolder           pointer to variable to receive new folder object <br> * <br> */ <br>STDMETHODIMP IFLD_CreateFolder(PIFLD pifld, ULONG ulFldType, LPSTR szFldName, <br>    LPSTR szComment, LPCIID piid, ULONG ulFlags, LPMAPIFOLDER *lppfolder) <br>{ <br>    HRESULT hr; <br>    PIFLD pifldNew = NULL; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            CreateFolder, <br>            (pifld,  <br>            ulFldType,  <br>            szFldName,  <br>            szComment,  <br>            piid,  <br>            ulFlags,  <br>            lppfolder)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br> <br>    if (piid &amp;&amp; !FQueryInterface(OT_FOLDER, piid)) <br>        return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>    #endif <br> <br>    /* Sample store can only create generic folders. */ <br>    if (ulFldType != FOLDER_GENERIC) <br>        return ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (!OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    hr = HrCreateFolder(pifld, szFldName, szComment, <br>        !!(ulFlags &amp; OPEN_IF_EXISTS), &amp;pifldNew, NULL); <br> <br>    if (hr != hrSuccess) <br>        UlRelease(pifldNew); <br>    else <br>        *lppfolder = (LPMAPIFOLDER) pifldNew; <br> <br>exit: <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_CreateFolder, hr); <br>    return HrCheckHr(hr, IMAPIFolder_CreateFolder); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_CopyFolder <br> - <br> *  Purpose: <br> *      Copy my child folder to the specified parent <br> * <br> *  Parameters <br> *      pifld           the parent folder of the newly created folder <br> *      cbEntryID       length of entry ID of folder to copy <br> *      lpEntryID       entry ID of folder to copy <br> *      lpiid           interface to the destination folder <br> *      lpfolder        pointer to destination object <br> *      szNewName       new name to give the copied folder, may be NULL <br> *      ulUIParam       Handle of parent window, <br> *                      ignored if MESSAGE_DIALOG not set <br> *      lpProgress      points to progress dialog information <br> *      ulFlags         control flags <br> * <br> */ <br>STDMETHODIMP IFLD_CopyFolder(PIFLD pifld, ULONG cbEntryID, LPENTRYID lpEntryID, <br>    LPCIID piid, LPVOID lpfolder, LPSTR szNewName, <br>    ULONG ulUIParam, LPMAPIPROGRESS lpProgress, ULONG ulFlags) <br>{ <br>    HRESULT hr; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            CopyFolder, <br>            (pifld,  <br>            cbEntryID,  <br>            lpEntryID, <br>            piid,  <br>            lpfolder,  <br>            szNewName,  <br>            ulUIParam,  <br>            lpProgress,  <br>            ulFlags)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    /* For now, all we do is call back to mapi. */ <br> <br>    hr = pifld-&gt;pims-&gt;psup-&gt;lpVtbl-&gt;CopyFolder(pifld-&gt;pims-&gt;psup, <br>        (LPIID) &amp;IID_IMAPIFolder, (LPVOID) pifld, cbEntryID, lpEntryID, <br>        piid, lpfolder, szNewName, ulUIParam, lpProgress, ulFlags); <br> <br>    DebugTraceResult(IFLD_CopyFolder, hr); <br>    return HrCheckHr(hr, IMAPIFolder_CopyFolder); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_DeleteFolder <br> - <br> *  Purpose: <br> *      Deletes a subfolder <br> * <br> *  Parameters <br> *      pifld               the current folder <br> *      cbEntryID           byte count of lpEntryID <br> *      lpEntryID           entryID of subfolder to be deleted <br> *      ulUIParam           handle to main window cast to ULONG <br> *      lpProgress          pointer to progess dialog information <br> *      ulFlags             DEL_MESSAGES and/or DEL_FOLDERS <br> *                                  and/or FOLDER_DIALOG <br> * <br> *  Returns: <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IFLD_DeleteFolder(PIFLD pifld, ULONG cbEntryID, <br>    LPENTRYID lpEntryID, ULONG ulUIParam, LPMAPIPROGRESS lpProgress, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            DeleteFolder, <br>            (pifld,  <br>            cbEntryID, <br>            lpEntryID,  <br>            ulUIParam,  <br>            lpProgress,  <br>            ulFlags)); <br> <br>    IFLD_EnterCriticalSection(pifld); </code></pre>
<p>
</p>
<pre><code><br>    if (FIsInvalidEID(cbEntryID, (PEID) lpEntryID, pifld-&gt;pims) <br>        || !FIsFolder((PEID) lpEntryID)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    if (!OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* delete this subdirectory of the current directory */ <br>    hr = HrDeleteSubDirectory(pifld, (PEID) lpEntryID, ulFlags, FALSE); <br> <br>exit: <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_DeleteFolder, hr); <br>    return HrCheckHr(hr, IMAPIFolder_DeleteFolder); <br>} <br> <br>STDMETHODIMP IFLD_SetSearchCriteria(PIFLD pifld, LPSRestriction lpRestriction, <br>    LPENTRYLIST lpentrylist, ULONG ulSearchFlags) <br>{ <br>    DebugTraceSc(IFLD_SetSearchCriteria, MAPI_E_NO_SUPPORT); <br>    return ResultFromScode(MAPI_E_NO_SUPPORT); <br>} <br> <br>STDMETHODIMP IFLD_GetSearchCriteria(PIFLD pifld, ULONG ulFlags, <br>    LPSRestriction *lppRestriction, LPENTRYLIST *lppfolderList,  <br>    ULONG *lpulSearchState) <br>{ <br>    DebugTraceSc(IFLD_GetSearchCriteria, MAPI_E_NO_SUPPORT); <br>    return ResultFromScode(MAPI_E_NO_SUPPORT); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_SetReadFlags <br> - <br> *  Purpose: <br> *      Sets the READ flag for each of the given messages. <br> * <br> *  Parameters <br> *      pifld                   the source folder <br> *      lpMsgList               the list of messages to be moved/copied <br> *      ulUIParam               Handle of parent window, <br> *                                  ignored if MESSAGE_DIALOG not set <br> *      lpProgress              points to progress dialog object <br> *      ulFlags                 SUPPRESS_RECEIPT, CLEAR_READ_FLAG <br> */ <br>STDMETHODIMP IFLD_SetReadFlags(PIFLD pifld, LPENTRYLIST lpMsgList, <br>    ULONG ulUIParam, LPMAPIPROGRESS lpProgress, ULONG ulFlags) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPENTRYLIST pelst = NULL; <br>    BOOL fFreeList = FALSE; <br>    SBinary *psb; <br>    SBinary *psbMax; <br>    BOOL fMultipleNotifs = TRUE; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            SetReadFlags, <br>            (pifld,  <br>            lpMsgList,  <br>            ulUIParam,  <br>            lpProgress,  <br>            ulFlags)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (!OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    pelst = lpMsgList; <br> <br>    if (pelst == NULL) <br>    { <br>        /* Create the message list if the caller didn't give us one. */ <br> <br>        hr = HrCreateMessageList(pifld, &amp;pelst); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        fFreeList = TRUE; <br>    } <br> <br>    if (pelst-&gt;cValues &gt; 5) <br>        fMultipleNotifs = FALSE; <br> <br>    psb = pelst-&gt;lpbin; <br>    psbMax = psb + pelst-&gt;cValues; <br> <br>    /* Call IMessage::SetReadFlag on each message */ <br> <br>    while (psb &lt; psbMax) <br>    { <br>        ULONG ulObjType; <br>        PIMSG pimsg; <br>        PEID peid; <br>        ULONG cbEntryID; <br> <br>        cbEntryID = psb-&gt;cb; <br>        peid = (PEID) (psb-&gt;lpb); <br> <br>        if (    FIsInvalidEID(cbEntryID, peid, pifld-&gt;pims) <br>            ||  !FIsMessage((PEID) peid)) <br>        { <br>            hr = ResultFromScode(MAPI_E_INVALID_PARAMETER); <br>            goto exit; <br>        } <br> <br>        /* open the message */ <br>        hr = pifld-&gt;lpVtbl-&gt;OpenEntry(pifld, CbEID(peid), <br>                (LPENTRYID) peid, NULL, 0L, &amp;ulObjType, <br>                (LPUNKNOWN *) &amp;pimsg); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        Assert(ulObjType == MAPI_MESSAGE); <br> <br>        hr = pimsg-&gt;lpVtbl-&gt;SetReadFlag(pimsg, ulFlags); <br> <br>        if (hr == hrSuccess &amp;&amp; fMultipleNotifs) <br>            ChangeTable(pimsg-&gt;pims, pifld-&gt;peid, pimsg-&gt;peid, MAPI_MESSAGE, <br>                TABLE_ROW_MODIFIED, TRUE); <br> <br>        UlRelease(pimsg); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        psb++; <br>    } <br> <br>    /* If several messages changed, then just send one notification to */ <br>    /* re-sync the entire contents table on other processes. */ <br> <br>    if (!fMultipleNotifs) <br>        ChangeTable(pifld-&gt;pims, pifld-&gt;peid, NULL, MAPI_MESSAGE, <br>            TABLE_CHANGED, TRUE); <br> <br>exit: <br>    if (fFreeList) <br>        DestroyMessageList(&amp;pifld-&gt;pims-&gt;lmr, &amp;pelst); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_SetReadFlags, hr); <br>    return HrCheckHr(hr, IMAPIFolder_SetReadFlags); <br>} <br> <br>/*************************************************************************** <br> -  GetMessageStatus <br> - <br> *  Purpose: <br> *      Retrieves the status associated with a message in a folder <br> * <br> *  Parameters <br> *      pifld               the current folder <br> *      cbEntryID           byte count of lpEntryID <br> *      lpEntryID           entryID of the message <br> *      ulFlags             reserved for future use, must be 0 <br> *      lpulMessageStatus   pointer to variable to receive the status <br> * <br> */ <br>STDMETHODIMP IFLD_GetMessageStatus(PIFLD pifld, ULONG cbEntryID, <br>    LPENTRYID lpEntryID, ULONG ulFlags, ULONG *lpulMessageStatus) <br>{ <br>    LPMESSAGE lpmsgMsg = NULL;  /* lpEntryID as an open message */ <br>    ULONG ulObjType;            /* type of object opened */ <br>    HRESULT hr = hrSuccess; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            GetMessageStatus, <br>            (pifld,  <br>            cbEntryID,  <br>            lpEntryID,  <br>            ulFlags,  <br>            lpulMessageStatus)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (FIsInvalidEID(cbEntryID, (PEID) lpEntryID, pifld-&gt;pims) <br>        || !FIsMessage((PEID) lpEntryID)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    /* open up lpEntryID */ <br>    hr = pifld-&gt;lpVtbl-&gt;OpenEntry(pifld, cbEntryID, <br>        lpEntryID, NULL, 0L, &amp;ulObjType, (LPUNKNOWN *) &amp;lpmsgMsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* get the property */ <br>    hr = HrGetSingleProp((LPMAPIPROP) lpmsgMsg, &amp;pifld-&gt;pims-&gt;lmr, <br>        PR_MSG_STATUS, lpulMessageStatus); <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>exit: <br>    UlRelease(lpmsgMsg); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_GetMessageStatus, hr); <br>    return HrCheckHr(hr, IMAPIFolder_GetMessageStatus); <br>} <br> <br>/*************************************************************************** <br> -  SetMessageStatus <br> - <br> *  Purpose: <br> *      Sets the 32-bit status associated with a message in a folder <br> * <br> *  Parameters <br> *      pifld               the current folder <br> *      cbEntryID           byte count of lpentryID <br> *      lpEntryID           entryID of the message <br> *      ulNewStatus         new status to be assigned <br> *      ulNewStatusMask     mask applied to new status indicating bits to set <br> *      lpulOldStatus       pointer to variable to hold previous status <br> * <br> */ <br>STDMETHODIMP IFLD_SetMessageStatus(PIFLD pifld, ULONG cbEntryID, <br>    LPENTRYID lpEntryID, ULONG ulNewStatus, ULONG ulNewStatusMask, <br>    ULONG *lpulOldStatus) <br>{ <br>    PIMSG pimsg = NULL; <br>    LPMESSAGE lpmsg; <br>    ULONG ulObjType;            /* type of object just opened */ <br>    HRESULT hr = hrSuccess; <br>    ULONG ulStatus; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            SetMessageStatus, <br>            (pifld,  <br>            cbEntryID,  <br>            lpEntryID,  <br>            ulNewStatus,  <br>            ulNewStatusMask,  <br>            lpulOldStatus)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (FIsInvalidEID(cbEntryID, (PEID) lpEntryID, pifld-&gt;pims) || <br>        !FIsMessage((PEID) lpEntryID)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    if (    ulNewStatusMask <br>        &amp;&amp;  !OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* open up lpEntryID */ <br>    hr = pifld-&gt;lpVtbl-&gt;OpenEntry(pifld, CbEID((PEID) lpEntryID), <br>        lpEntryID, NULL, 0L, &amp;ulObjType, (LPUNKNOWN *) &amp;pimsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    lpmsg = pimsg-&gt;lpmsg; <br> <br>    /* get the old status */ <br>    hr = HrGetSingleProp((LPMAPIPROP) lpmsg, &amp;pifld-&gt;pims-&gt;lmr, <br>        PR_MSG_STATUS, &amp;ulStatus); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (lpulOldStatus) <br>        *lpulOldStatus = ulStatus; <br> <br>    if (ulNewStatusMask) <br>    { <br>        ulNewStatus &amp;= ulNewStatusMask; <br>        ulStatus &amp;= ~ulNewStatusMask; <br>        ulStatus |= ulNewStatus; <br> <br>        hr = HrSetOneROProp(lpmsg, &amp;pifld-&gt;pims-&gt;lmr, PR_MSG_STATUS, <br>            &amp;ulStatus); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, KEEP_OPEN_READWRITE); <br> <br>        UlRelease(pimsg); <br>        pimsg = NULL; <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        ChangeTable(pifld-&gt;pims, pifld-&gt;peid, (PEID) lpEntryID, MAPI_MESSAGE, <br>            TABLE_ROW_MODIFIED, TRUE); <br>    } <br> <br>exit: <br>    UlRelease(pimsg); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_SetMessageStatus, hr); <br>    return HrCheckHr(hr, IMAPIFolder_SetMessageStatus); <br>} <br> <br>/*************************************************************************** <br> -  IFLD_SaveContentsSort <br> - <br> *  Purpose: <br> *      set default sort order for contents tables on pifld <br> * <br> *  Parameters <br> *      pifld               the current folder <br> *      lpSortCriteria      points to the sort criteria <br> *      ulFlags             RECURSIVE_SORT <br> * <br> */ <br>STDMETHODIMP IFLD_SaveContentsSort(PIFLD pifld, LPSSortOrderSet lpSortCriteria, <br>    ULONG ulFlags) <br>{ <br>    SPropValue pval;            /* sort order property value */ <br>    LPSPropProblemArray pprba = NULL; <br>    HRESULT hr = hrSuccess; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            SaveContentsSort, <br>            (pifld,  <br>            lpSortCriteria, <br>            ulFlags)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    pval.Value.MVl.lpl = NULL; <br> <br>    /* store the sort order in pval */ <br>    pval.ulPropTag = PR_SMS_CONTENTS_SORT_ORDER; <br>    pval.Value.MVl.cValues = 2 * lpSortCriteria-&gt;cSorts; <br>    pval.Value.MVl.lpl = (LONG *) lpSortCriteria-&gt;aSort; <br> <br>    /*  set the sort order property */ <br>    hr = pifld-&gt;lpVtbl-&gt;SetProps(pifld, 1, &amp;pval, &amp;pprba); <br> <br>    if (pprba) <br>    { <br>        LMFree(&amp;pifld-&gt;pims-&gt;lmr, pprba); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>    } <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_SaveContentsSort, hr); <br>    return HrCheckHr(hr, IMAPIFolder_SaveContentsSort); <br>} <br> <br>/* <br> *  IFLD_EmptyFolder <br> * <br> *  Purpose: <br> *      This function empties a folder based on the flags given. It will never <br> *      actually delete the folder itself, and will only empty the specified <br> *      items. <br> * <br> *  Parameters <br> *      pifld           The address of the folder object to empty. <br> *      ulUIParam       Handle of the parent window. (for progress). NYI <br> *      lpProgress      Address of progress dialog object <br> *      ulFlags         Control flags. Setting DEL_ASSOCIATED causes FAI <br> *                      to also be deleted. The FOLDER_DIALOG flag is NYI. <br> *                      DEL_ASSOCIATED has no meaning to the sample store. <br> * <br> *  Returns: <br> */ <br>STDMETHODIMP IFLD_EmptyFolder(PIFLD pifld, ULONG ulUIParam, <br>    LPMAPIPROGRESS lpProgress, ULONG ulFlags) <br>{ <br>    HRESULT hr; <br>    PIFLD pifldParent = NULL; <br> <br>    FLD_ValidateParameters( <br>            pifld,  <br>            IMAPIFolder, <br>            EmptyFolder, <br>            (pifld,  <br>            ulUIParam,  <br>            lpProgress,  <br>            ulFlags)); <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    if (!OBJ_TestFlag(pifld, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* Empty the folder. */ <br> <br>    hr = HrOpenParent(pifld-&gt;pims, pifld-&gt;peid, MAPI_MODIFY, &amp;pifldParent); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrDeleteSubDirectory(pifldParent, pifld-&gt;peid, <br>        (DEL_MESSAGES | DEL_FOLDERS), TRUE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>exit: <br>    UlRelease(pifldParent); <br> <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    DebugTraceResult(IFLD_EmptyFolder, hr); <br>    return HrCheckHr(hr, IMAPIFolder_EmptyFolder); <br>} <br> <br>/**************************************************** <br> *          Private Functions                       * <br> ****************************************************/ <br> <br>/* <br> *  IFLD_IsInvalid <br> * <br> *  Purpose         check if pifld points to an invalid folder. <br> * <br> *  Parameter <br> *      pifld       pointer to the folder <br> * <br> *  Returns: BOOL - TRUE means the folder is invalid. <br> */ <br> <br>static BOOL IFLD_IsInvalid(PIFLD pifld) <br>{ <br>    return (IsBadWritePtr(pifld, sizeof(IFLD)) || <br>        pifld-&gt;lpVtbl != &amp;vtblIFLD); <br>} <br> <br>/*  <br> * HrCreateContTblMutex <br> * <br> *  Purpose <br> *      Create the contents table mutex, and return it to the caller. <br> * <br> *  Arguments <br> *      phCTMutex: Pointer to the location to return the new mutex. <br> * <br> *  Returns: <br> *      HRESULT: Will return an error only if the CreateMutex call fails. <br> */ <br>static HRESULT HrCreateContTblMutex(HANDLE *phCTMutex) <br>{ <br>    HRESULT hr = hrSuccess; <br>    HANDLE hMutex; <br>    LPTSTR szMutexName = "SMS_CONTTBLFILE_MUTEX"; <br> <br>    hMutex = CreateMutex(NULL, FALSE, szMutexName); <br> <br>    if (hMutex) <br>        *phCTMutex = hMutex; <br> <br>    #ifndef WIN16 <br>    else <br>    { <br>        TraceSz1("SampleMS: HrCreateContTblMutex: call to" <br>            " CreateMutex failed (error %08lX)", GetLastError()); <br>         <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>    } <br>    #endif <br> <br>    DebugTraceResult(HrCreateContTblMutex, hr); <br>    return hr; <br>} <br> <br>/* <br> *  FFoldInSameStore <br> * <br> *  Purpose <br> *      Given that the source folder is a folder object within <br> *      our store (i.e. it's a PIFLD, not LPMAPIFOLDER), check if the <br> *      destination folder object is also within the same store. <br> * <br> *  Parameters <br> *      pifld: The folder that we already know is within this store. <br> *      lpDestFld: The folder that we are checking. It may not be in this store. <br> * <br> *  Returns: BOOL - TRUE means the folders are both in this store. <br> * <br> */ <br> <br>static BOOL FFoldInSameStore(PIFLD pifld, PIFLD lpDestFld) <br>{ <br>    if (IsBadWritePtr(lpDestFld, sizeof(IFLD))) <br>        return FALSE; <br> <br>    if (lpDestFld-&gt;lpVtbl != &amp;vtblIFLD) <br>        return FALSE; <br> <br>    if (pifld-&gt;pims != lpDestFld-&gt;pims) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br>/*************************************************************************** <br> *  IFLD_Neuter <br> * <br> *  Purpose     Free all memory allocated inside a folder object, and release <br> *              any objects held inside a folder object. Leaves the object <br> *              itself alone (the caller will free it). <br> * <br> *  Argument    pifld       the folder to be cleaned out. <br> * <br> */ <br>void IFLD_Neuter(PIFLD pifld) <br>{ <br>    /* free allocated memory */ <br>    FreeNull(pifld-&gt;peid); <br> <br>    LMFree(&amp;pifld-&gt;pims-&gt;lmr, pifld-&gt;pval); <br> <br>    /* remove any tables */ <br>    if (pifld-&gt;lptblContents) <br>    { <br>        TraceSz1("SampleMS (IFLD_Neuter): %d contents table views left", <br>            pifld-&gt;cContentsViews); <br> <br>        UlRelease(pifld-&gt;lptblContents); <br>        pifld-&gt;cContentsViews = 0; <br>        pifld-&gt;lptblContents = NULL; <br>    } <br> <br>    if (pifld-&gt;lptblHierarchy) <br>    { <br>        TraceSz1("SampleMS (IFLD_Neuter): %d hierarchy table views left", <br>            pifld-&gt;cHierarchyViews); <br> <br>        UlRelease(pifld-&gt;lptblHierarchy); <br>        pifld-&gt;cHierarchyViews = 0; <br>        pifld-&gt;lptblHierarchy = NULL; <br>    } <br> <br>    return; <br>} <br> <br>/* <br> -  ViewRelease <br> - <br> *  Purpose: <br> *      Call back function from itable on release of a view <br> *      removes the view from the list of open views <br> *      releases the table if there are no more open views on it <br> * <br> *  Parameters <br> *       ulCallerData   pointer to folder object <br> *       lptbl          pointer to the table on which this is a view <br> *       lpvtView       pointer to the view that was released <br> * <br> * <br> */ <br>STDAPI_(void)ViewRelease(ULONG ulCallerData, LPTABLEDATA lptbl, <br>    LPMAPITABLE lpvtView) <br>{ <br>    PIFLD pifld;                /* folder object for this view */ <br>    ULONG *pulViewsLeft;        /* ptr to number of open views left */ <br>    LPTABLEDATA *pptbl;         /* ptr to folder's internal table data */ <br> <br>    pifld = (PIFLD) ulCallerData; <br> <br>    /* do nothing if the folder is invalid. Don't use IFLD_IsInvalid */ <br>    /* because the folder may have already been released, and we still */ <br>    /* want to release the view in that case. */ <br>    if (IsBadWritePtr(pifld, sizeof(IFLD))) <br>        return; <br> <br>    IFLD_EnterCriticalSection(pifld); <br> <br>    /* find the kind of table this view is on */ <br>    if (pifld-&gt;lptblContents == lptbl) <br>    { <br>        pulViewsLeft = &amp;(pifld-&gt;cContentsViews); <br>        pptbl = &amp;(pifld-&gt;lptblContents); <br>    } <br>    else if (pifld-&gt;lptblHierarchy == lptbl) <br>    { <br>        pulViewsLeft = &amp;(pifld-&gt;cHierarchyViews); <br>        pptbl = &amp;(pifld-&gt;lptblHierarchy); <br>    } <br>    else <br>    { <br>        /* invalid table */ <br>        TrapSz("Invalid call to ViewRelease"); <br>        goto exit; <br>    } <br> <br>    AssertSz(*pptbl == lptbl, "Different table data given to ViewRelease"); <br> <br>    /* decrement count of views and release*/ <br>    /* the table data if the viewlist is empty */ <br>    if (--(*pulViewsLeft) == 0) <br>    { <br>        POBJ pobj = (POBJ) pifld; <br> <br>        UlRelease(lptbl); <br>        *pptbl = NULL; <br> <br>        /* These tests are the same as IFLD_Release in this module. That is */ <br>        /* the release method that folders use. */ <br> <br>        if (    pobj-&gt;cRef == 0 <br>            &amp;&amp;  pobj-&gt;pobjHead == 0 <br>            &amp;&amp;  pifld-&gt;lptblContents == NULL <br>            &amp;&amp;  pifld-&gt;lptblHierarchy == NULL) <br>        { <br>            OBJ_Destroy(pobj);  /* will leave the critical section */ <br>            return; <br>        } <br> <br>    } <br> <br>exit: <br>    IFLD_LeaveCriticalSection(pifld); <br> <br>    return; <br>} <br> <br>/* <br> *  HrIsRead <br> * <br> *  Purpose <br> *      Given a parent folder and the entryid of a message, determine <br> *      whether the message has been read (i.e., whether the MSGFLAG_READ <br> *      bit inside the PR_MESSAGE_FLAGS property is set). <br> * <br> *  Parameters <br> *      pifld       A pointer to the parent folder object of the message. <br> *      peidMsg     The entryid of the message. <br> *      pfRead      A pointer to the location to return a BOOL saying <br> *                  whether or not the message was read. Set to TRUE <br> *                  if the message was read, FALSE otherwise. <br> */ <br>static HRESULT HrIsRead(PIFLD pifld, PEID peidMsg, BOOL *pfRead) <br>{ <br>    HRESULT hr; <br>    PIMSG pimsg = NULL;         /* opened version of lpidMsg */ <br>    ULONG ulObjType;            /* type of object opened */ <br>    ULONG ulMF; <br> <br>    /* open the message */ <br>    hr = pifld-&gt;lpVtbl-&gt;OpenEntry(pifld, CbEID(peidMsg), (LPENTRYID) peidMsg, <br>        NULL, 0L, &amp;ulObjType, (LPUNKNOWN *) &amp;pimsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    Assert(ulObjType == MAPI_MESSAGE); <br> <br>    /* retrieve the PR_MESSAGE_FLAGS property */ <br>    hr = HrGetSingleProp((LPMAPIPROP) pimsg-&gt;lpmsg, &amp;pifld-&gt;pims-&gt;lmr, <br>            PR_MESSAGE_FLAGS, &amp;ulMF); <br> <br>    /* set pfRead: no PR_MESSAGE_FLAGS means unread */ <br>    /* The "!!" operator is used to change a bit that is set anywhere in a */ <br>    /* word to exactly TRUE (only one bit set at the far right of the word). */ <br>    /* The first "!" is NOT, which makes all zeros in the value into TRUE, */ <br>    /* and anything else into FALSE. The second "!" reverses that back, so */ <br>    /* that all zeros become FALSE, and anything else becomes TRUE. */ <br> <br>    if (hr == hrSuccess) <br>        *pfRead = !!(ulMF &amp; MSGFLAG_READ); <br>    else if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>    { <br>        *pfRead = FALSE; <br>        hr = hrSuccess; <br>    } <br> <br>    UlRelease(pimsg); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    DebugTraceResult(HrIsRead, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrRemoveRow <br> * <br> *  Purpose     remove a row from a contents or hierarchy table <br> * <br> *  Argument    lptbl       the table whose row is to be deleted <br> *              peid        the entryid of row to be deleted. Used to <br> *                          generate the instance key. <br> * <br> */ <br>HRESULT HrRemoveRow(LPTABLEDATA lptbl, PEID peid) <br>{ <br>    SPropValue valIK;   /* instance key stored in a property value */ <br>    HRESULT hr; <br> <br>    if (lptbl == NULL) <br>        return hrSuccess; <br> <br>    /* make the instance key into a property value */ <br>    valIK.ulPropTag = PR_INSTANCE_KEY; <br>    valIK.Value.bin.cb = CbEID(peid); <br>    valIK.Value.bin.lpb = (BYTE *) peid; <br> <br>    /* delete the row from the table */ <br>    hr = lptbl-&gt;lpVtbl-&gt;HrDeleteRow(lptbl, &amp;valIK); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    DebugTraceResult(HrRemoveRow, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrUpdateRow <br> * <br> *  Purpose <br> *      alter the row in the table with the given index property <br> *      to the properties in the proptag array.  If the index is <br> *      not present, a new row is added to the table. The index <br> *      property MUST be the first in pPTA. <br> *      For contents table, an entry is made only if the object has <br> *      been saved (and therefore has a PR_ENTRYID property). <br> * <br> *  Parameters <br> *      pims            A pointer to the message store object. <br> *      lptbl           A pointer to the table data object to update. <br> *      peid            EntryID of object whose row is to be added <br> *      pPTA            array of property tags of properties to appear in <br> *                      this row <br> *      pft             pointer to the file time to write <br> *      ulObjType       MAPI_MESSAGE (for contents table) or MAPI_FOLDER <br> *                      (for hierarchy table) <br> * <br> */ <br>HRESULT HrUpdateRow(PIMS pims, LPTABLEDATA lptbl, PEID peid, <br>    LPSPropTagArray pPTA, FILETIME *pft, ULONG ulObjType) <br>{ <br>    SRow srUpdateRow;           /* new table row */ <br>    LPSPropValue pval = NULL; <br>    LPMAPIPROP lpEntry = NULL;  /* szName as an open mapiprop */ <br>    ULONG ulObjectType;         /* type of object szName is */ <br>    HRESULT hr = hrSuccess; <br>    ULONG cbEID;                /* number of bytes in lpEntryID */ <br>    ULONG cValues; <br> <br>    if (lptbl == NULL) <br>        return hrSuccess; <br> <br>    cbEID = CbEID(peid); <br> <br>    /* Don't add a contents table row for unsaved messages */ <br>    if (ulObjType == MAPI_MESSAGE &amp;&amp; FIsUnsavedEID(peid)) <br>        goto exit; <br> <br>    /* open this object. Do not open with MAPI_MODIFY because if the */ <br>    /* store is open read-only, the OpenEntry will fail. */ <br> <br>    hr = ((LPMDB) pims)-&gt;lpVtbl-&gt;OpenEntry((LPMDB) pims, cbEID, <br>        (LPENTRYID) peid, NULL, 0L, &amp;ulObjectType, (LPUNKNOWN *) &amp;lpEntry); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (ulObjType == MAPI_MESSAGE &amp;&amp; FIsUnsavedMsg((PIMSG) lpEntry)) <br>    { <br>        UlRelease(lpEntry); <br>        goto exit; <br>    } <br> <br>    hr = lpEntry-&gt;lpVtbl-&gt;GetProps(lpEntry, pPTA, 0, /* ansi */ <br>            &amp;cValues, &amp;pval); <br> <br>    UlRelease(lpEntry); <br> <br>    if (HR_FAILED(hr)) <br>        goto exit; <br> <br>    hr = hrSuccess;             /* ignore warnings */ <br> <br>    Assert(cValues == pPTA-&gt;cValues); <br> <br>    /* add depth if this is a hierarchy table */ <br>    if (ulObjType == MAPI_FOLDER) <br>    { <br>        AssertSz(PROP_ID(pval[cValues - 1].ulPropTag) == PROP_ID(PR_DEPTH), <br>            "Invalid assumption. PR_DEPTH must be last in hier ptags."); <br> <br>        pval[cValues - 1].ulPropTag = PR_DEPTH; <br>        pval[cValues - 1].Value.l = 1L; <br>    } <br> <br>    /* stamp in the last mod time (based on what's passed in) */ <br>    /* Note assumption of where the proptag is. */ <br> <br>    AssertSz1(pPTA-&gt;aulPropTag[MODIFY_INDEX] == PR_LAST_MODIFICATION_TIME, <br>        "Invalid assumption. PR_LAST_MODIFICATION_TIME must be at " <br>        "index %d in pPTA.", MODIFY_INDEX); <br> <br>    pval[MODIFY_INDEX].ulPropTag = PR_LAST_MODIFICATION_TIME; <br>    pval[MODIFY_INDEX].Value.ft = *pft; <br> <br>    /* add the row */ <br>    srUpdateRow.cValues = cValues; <br>    srUpdateRow.lpProps = pval; <br> <br>    hr = lptbl-&gt;lpVtbl-&gt;HrModifyRow(lptbl, &amp;srUpdateRow); <br> <br>    /* Fall through to exit */ <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    LMFree(&amp;pims-&gt;lmr, pval); <br> <br>    DebugTraceResult(HrUpdateRow, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrCreateFolder <br> * <br> * This routine searches for a child folder of the given parent folder <br> * for a folder with the specified PR_DISPLAY_NAME. If found and the caller <br> * wishes to open if exists, then the found folder is opened and returned. If <br> * found and the caller doesn't want to open if exists, then the error <br> * MAPI_E_COLLISION is returned. If no child folder with the matching display <br> * name is found, then a child folder with the correct display name is created <br> * and the new folder is returned. <br> * <br> * Parameters <br> * <br> * pifldParent: The parent folder in which to search for matching display names, <br> *              and, if necessary, to create the child folder. <br> * szName:      The display name to search for and to create the child folder <br> *              with. <br> * szComment:   If a child folder is created, the value to set its PR_COMMENT <br> *              property to. <br> * fOpenIfExists: If a child folder with a matching PR_DISPLAY_NAME is found, <br> *              open the matching folder when this BOOL is TRUE. If this <br> *              BOOL is FALSE, and a match is found, return MAPI_E_COLLISION. <br> *              If no match is found, this parameter is not referenced. <br> * ppifldNew:   The location to return the newly created or opened folder. <br> * pfCreated:   The location to return whether this function created or opened <br> *              the child folder. Returning TRUE means the folder was created. <br> * <br> * Errors: memory or disk errors, and MAPI_E_COLLISION. <br> * <br> */ <br>static HRESULT HrCreateFolder(PIFLD pifldParent, LPSTR szName, LPSTR szComment, <br>    BOOL fOpenIfExists, PIFLD *ppifldNew, BOOL *pfCreated) <br>{ <br>    HRESULT hr; <br>    BOOL fCreated = FALSE; <br>    PEID peid = NULL; <br>    PIFLD pifldNew = NULL; <br>    LPMAPITABLE pmt = NULL; <br>    PIMS pims = pifldParent-&gt;pims; <br>    ULONG ulRowCount; <br>    BOOL fFirstSubFld; <br> <br>    hr = pifldParent-&gt;lpVtbl-&gt;GetHierarchyTable(pifldParent, 0, &amp;pmt); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pmt-&gt;lpVtbl-&gt;GetRowCount(pmt, 0, &amp;ulRowCount); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    fFirstSubFld = (ulRowCount == 0); <br>         <br>    if (!fFirstSubFld) <br>    { <br>        hr = HrEIDFromDisplayName(pmt, szName, &amp;pims-&gt;lmr, &amp;peid); <br>     <br>        if (hr != hrSuccess) <br>            goto exit; <br>     <br>        /* If we found a duplicate, and we don't want it, we have an error. */ <br>     <br>        if ((peid != NULL) &amp;&amp; (fOpenIfExists == FALSE)) <br>        { <br>            hr = ResultFromScode(MAPI_E_COLLISION); <br>            goto exit; <br>        } <br>    } <br>     <br>    UlRelease(pmt); <br>    pmt = NULL; <br>     <br>    if (peid == NULL) <br>    { <br>        /* //$ Need to handle cleanup of directory and propfile when errors */ <br>        /* //$ occur later in this function... */ <br> <br>        hr = HrCreateFolderStorage(pifldParent, FOLDER_GENERIC, szName, <br>            szComment, TRUE, pims, &amp;peid); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        fCreated = TRUE; <br>    } <br> <br>    /* Create the instance data */ <br>    hr = HrNewIFLD(peid, pims, TRUE, &amp;pifldNew); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrSetInternalProps(&amp;pims-&gt;lmr, cpropIFLDInternal, &amp;(pifldNew-&gt;pval), <br>            &amp;(pifldNew-&gt;cval), peid, pifldParent-&gt;peid, 0); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* update the hierarchy tables, if any */ <br>    if (fCreated) <br>    { <br>        if (fFirstSubFld) <br>        { <br>            hr = HrSetSubFolderProp(pifldParent, TRUE); <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br> <br>        ChangeTable(pims, pifldParent-&gt;peid, peid, MAPI_FOLDER, <br>            TABLE_ROW_ADDED, TRUE); <br>    } <br> <br>    if (pfCreated) <br>        *pfCreated = fCreated; <br> <br>    *ppifldNew = pifldNew; <br> <br>exit: <br>    UlRelease(pmt); <br>    LMFree(&amp;pims-&gt;lmr, peid); <br> <br>    if (hr != hrSuccess) <br>        UlRelease(pifldNew); <br> <br>    DebugTraceResult(HrCreateFolder, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrIsParent <br> * <br> *  Purpose <br> *      Checks if peidParent is the parent of peidChild. Note that peidChild <br> *      may be either a message or a folder entryid. Returns answer <br> *      (TRUE or FALSE) in *pfIsParent. <br> * <br> *  Parameters <br> *      peidParent      A pointer to the entryid of the potential parent. <br> *      peidChild       A pointer to the entryid of the potential child. <br> *      pfIsParent      A pointer to the location to return the answer. <br> */ <br>HRESULT HrIsParent(PEID peidParent, PEID peidChild, BOOL *pfIsParent) <br>{ <br>    SCODE sc = S_OK; <br>    LPSTR szLastSlash;          /* pointer to last slash in Childs' path */ <br>    BOOL fAnswer = FALSE; </code></pre>
<p>
</p>
<pre><code>LPSTR szTemp = NULL; <br>    ULONG cbPathCopy; <br> <br>    if (!IsEqualMAPIUID(&amp;(peidParent-&gt;uidResource), &amp;(peidChild-&gt;uidResource))) <br>        goto exit; <br> <br>    szLastSlash = SzFindLastCh(peidChild-&gt;szPath, '\\'); <br>    if (szLastSlash == NULL) <br>    { <br>        /* if child is the root it can have no parent */ <br>        /* otherwise, check if child lives in the root folder */ <br> <br>        if (*(peidChild-&gt;szPath) != '\0') <br>            fAnswer = (*(peidParent-&gt;szPath) == '\0'); <br> <br>        goto exit; <br>    } <br> <br>    cbPathCopy = ((szLastSlash - peidChild-&gt;szPath) * sizeof(TCHAR)) <br>        + sizeof(TCHAR); <br> <br>    sc = ScAlloc(cbPathCopy, &amp;szTemp); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    memcpy(szTemp, peidChild-&gt;szPath, (UINT) cbPathCopy); <br>    szTemp[cbPathCopy - 1] = '\0'; <br> <br>    /* see if paths are the same */ <br>    fAnswer = !lstrcmpi(peidParent-&gt;szPath, szTemp); <br> <br>exit: <br>    if (sc == S_OK) <br>        *pfIsParent = fAnswer; <br> <br>    FreeNull(szTemp); <br> <br>    DebugTraceSc(HrIsParent, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> *  FIsAncestor <br> * <br> *  Purpose <br> *      returns TRUE if pifldDescendent is a descendent of pifldAncestor <br> * <br> *  Parameters <br> *      pifldAncestor       the ancestor(?) folder <br> *      pifldDescendent     the descendent(?) folder <br> * <br> */ <br>static BOOL FIsAncestor(PIFLD pifldAncestor, PIFLD pifldDescendent) <br>{ <br>    PEID peidAncestor;          /* entryID of pifldAncestor */ <br>    PEID peidDescendent;        /* entryID of pifldDescendent */ <br>    LPTSTR szFirstOccurrence = NULL;    /* pointer to first occurrence in */ <br> <br>    /* pifldDescendent's path of */ <br>    /* pifldAncestor's path */ <br> <br>    if (pifldAncestor == NULL || pifldDescendent == NULL) <br>        return FALSE; <br> <br>    peidAncestor = pifldAncestor-&gt;peid; <br>    peidDescendent = pifldDescendent-&gt;peid; <br> <br>    if (!IsEqualMAPIUID(&amp;(peidAncestor-&gt;uidResource), <br>            &amp;(peidDescendent-&gt;uidResource))) <br>        return FALSE; <br> <br>    /* check for either one being the root */ <br>    if (FIsRoot(peidAncestor)) <br>        return TRUE; <br>    if (FIsRoot(peidDescendent)) <br>        return FALSE; <br> <br>    szFirstOccurrence = SzFindSz(peidDescendent-&gt;szPath, <br>        peidAncestor-&gt;szPath); <br> <br>    return (BOOL) (szFirstOccurrence == peidDescendent-&gt;szPath); <br>} <br> <br>/* <br> *  HrFullToRelative <br> * <br> *  Purpose             given a full path name and store, returns the <br> *                      root relative path.  Free with FreeNull. <br> * <br> *  Parameters <br> *      szFullPath      the full path <br> *      pims            the store object <br> *      pszRelative     [out] pointer to the relative path <br> * <br> *  NB      memory is allocated using ScAlloc and should be freed <br> *          with FreeNull <br> */ <br>HRESULT HrFullToRelative(LPTSTR szFullPath, PIMS pims, LPTSTR *pszRelative) <br>{ <br>    ULONG cchStore;     /* length of the store path in tchars */ <br>    ULONG cchFull;      /* length of the full path in tchars */ <br>    SCODE sc; <br> <br>    cchStore = lstrlen(pims-&gt;szStorePath); <br>    cchFull = lstrlen(szFullPath); <br> <br>    Assert(cchFull &gt;= cchStore); <br> <br>    sc = ScAlloc((cchFull - cchStore + sizeof(TCHAR)), (PPV) pszRelative); <br> <br>    if (sc != S_OK) <br>    { <br>        DebugTraceSc(HrFullToRelative, sc); <br>        return ResultFromScode(sc); <br>    } <br> <br>    lstrcpy(*pszRelative, szFullPath + cchStore + 1); <br> <br>    return hrSuccess; <br>} <br> <br>/* <br> *  HrFullPathName <br> * <br> *  Purpose         Allocate space for and return a pointer to the full path <br> *                  name of the given object. Free with FreeNull. <br> * <br> *  Parameters <br> *      szStorePath     full path to the store root <br> *      szPath1         first portion of path past the store root. <br> *                      May be NULL. <br> *      szPath2         second portion of path to the object <br> *                      whose full path name is needed, may be NULL. <br> *      pszName         Pointer to a location to return the full pathname <br> * <br> *  Returns: <br> *      HRESULT <br> */ <br>HRESULT HrFullPathName(LPTSTR szStorePath, LPTSTR szPath1, LPTSTR szPath2, <br>    LPTSTR *pszName) <br>{ <br>    UINT cbPath1 = 0;           /* length in bytes of first portion of path */ <br> <br>    /* excluding NULL */ <br>    UINT cbPath2 = 0;           /* length in bytes of second portion of path */ <br> <br>    /* excluding NULL */ <br>    UINT cbStorePath = 0; <br>    SCODE sc; <br> <br>    Assert(!IsBadWritePtr(pszName, sizeof(LPSTR))); <br>    Assert(!IsBadStringPtr(szStorePath, (UINT) -1)); <br> <br>    Assert(szPath1 == NULL || !IsBadStringPtr(szPath1, (UINT) -1)); <br>    Assert(szPath2 == NULL || !IsBadStringPtr(szPath2, (UINT) -1)); <br> <br>    cbStorePath = lstrlen(szStorePath) * sizeof(TCHAR); <br> <br>    if (szPath1 != NULL) <br>        cbPath1 = lstrlen(szPath1) * sizeof(TCHAR); <br> <br>    if (szPath2 != NULL) <br>        cbPath2 = lstrlen(szPath2) * sizeof(TCHAR); <br> <br>    /* allocate space for the path name */ <br>    sc = ScAlloc(cbStorePath + cbPath1 + cbPath2 + (3 * sizeof(TCHAR)), <br>        (PPV) pszName); <br> <br>    if (sc != S_OK) <br>    { <br>        DebugTraceSc(HrFullPathName, sc); <br>        return ResultFromScode(sc); <br>    } <br> <br>    /* fill in the name */ <br>    lstrcpy(*pszName, szStorePath); <br> <br>    if (cbPath1 != 0) <br>    { <br>        lstrcat(*pszName, TEXT("\\")); <br>        lstrcat(*pszName, szPath1); <br>    } <br> <br>    if (cbPath2 != 0) <br>    { <br>        lstrcat(*pszName, TEXT("\\")); <br>        lstrcat(*pszName, szPath2); <br>    } <br> <br>    return hrSuccess; <br>} <br> <br>/* <br> -  HrNewEID <br> - <br> *  Purpose     Return the EID of a new object (folder or message) <br> * <br> *  Parameters <br> *      pifld           Parent folder of object to receive new ID, NULL <br> *                      means we need EID of the root folder <br> *      pims            Store containing the new object <br> *      szExtension     File extension of new object, including '.' <br> *      lpulSeqNumber   pointer to sequence number of this entryID (optional) <br> *      ppeid           Pointer to pointer to new entryID <br> * <br> *  Returns: <br> *      HRESULT <br> */ <br>HRESULT HrNewEID(PIFLD pifld, PIMS pims, LPTSTR szExtension, <br>    ULONG *lpulSeqNumber, PEID *ppeid) <br>{ <br>    PEID peidNew = NULL; <br>    LPSTR szNewPath = NULL; <br>    HRESULT hr = hrSuccess; <br>    MAPIUID uid; <br>    ULONG ulSeq; <br>    LPSTR szNewObjName = NULL;  /* name of new object */ <br> <br>    Assert(ppeid); <br>    Assert(pims); <br> <br>    /* get the new name of the object, and a unique sequence number. */ <br>    hr = HrUniqueFileName(pims, &amp;ulSeq, &amp;szNewObjName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* code in the sample store depends on the number of chars in the */ <br>    /* file / folder name being OK. Verify that it is. */ <br> <br>    Assert(lstrlen(szNewObjName) == CCH_BASE); <br> <br>    GetResourceUID(pims, &amp;uid); <br> <br>    if (pifld == NULL) <br>    { <br>        CHAR ch = '\0'; <br> <br>        /* Construct the EID for the root folder */ <br>        hr = HrConstructEID(&amp;uid, &amp;pims-&gt;lmr, (LPSTR) &amp;ch, &amp;peidNew); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br>    else <br>    { <br>        ULONG cbPath; <br>        LPSTR szPath = NULL; <br>        SCODE sc; <br>        BOOL fIsRoot; <br> <br>        /* Add 1 TCHAR for the NULL terminator */ <br>        cbPath = (lstrlen(szNewObjName) + lstrlen(szExtension)) * sizeof(TCHAR) <br>            + sizeof(TCHAR); <br> <br>        fIsRoot = FIsRoot(pifld-&gt;peid); <br> <br>        if (fIsRoot == FALSE) <br>        { <br>            /* Add 1 TCHAR for the slash between the folder and the new name */ <br>            /* Subtract 1 TCHAR because we don't need to count the NULL term */ <br> <br>            cbPath += CbEIDPath(pifld-&gt;peid) + sizeof(TCHAR) - sizeof(TCHAR); <br>        } <br> <br>        /* allocate space for the new path */ <br>        sc = ScAlloc(cbPath, &amp;szPath); <br>        if (sc != S_OK) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto exit; <br>        } <br> <br>        *szPath = 0; <br> <br>        if (fIsRoot == FALSE) <br>        { <br>            lstrcpy(szPath, pifld-&gt;peid-&gt;szPath); <br>            lstrcat(szPath, TEXT("\\")); <br>        } <br> <br>        lstrcat(szPath, szNewObjName); <br>        lstrcat(szPath, szExtension); <br> <br>        hr = HrConstructEID(&amp;uid, &amp;pims-&gt;lmr, szPath, &amp;peidNew); <br> <br>        FreeNull(szPath); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    *ppeid = peidNew; <br> <br>    if (lpulSeqNumber) <br>        *lpulSeqNumber = ulSeq; <br> <br>    Assert(hr == hrSuccess); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    if (hr != hrSuccess) <br>        LMFree(&amp;pims-&gt;lmr, peidNew); <br> <br>    FreeNull(szNewObjName); <br> <br>    DebugTraceResult(HrNewEID, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrOpenPropertyMessage <br> * <br> *  Purpose         open the property message for the folder with entryid <br> *                  pointed to peid <br> * <br> *  Parameters <br> *      peid                pointer to folder's entryid <br> *      pims                pointer to the message store object <br> *      fModifyExclusive    TRUE if we want to open for read/write, <br> *                          exclusive access. <br> *      lppmsg              pointer to location to return the open message <br> *                          object <br> * <br> *  Returns: Storage and IMSG errors. <br> */ <br>static HRESULT HrOpenPropertyMessage(PEID peid, PIMS pims, BOOL fModifyExclusive, <br>    LPMESSAGE *lppmsg) <br>{ <br>    LPTSTR szPropFolderPathName = NULL; <br>    HRESULT hr; <br> <br>    /* get full path to message file */ <br>    hr = HrFullPathName(pims-&gt;szStorePath, peid-&gt;szPath, szPropertyFileName, <br>        &amp;szPropFolderPathName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrOpenIMsg(pims-&gt;pmsgsess, szPropFolderPathName, &amp;pims-&gt;lmr, <br>        pims-&gt;psup, FALSE, fModifyExclusive, fModifyExclusive, lppmsg); <br> <br>    if (hr != hrSuccess) <br>    { <br>        if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>            hr = ResultFromScode(MAPI_E_OBJECT_DELETED); <br>        goto exit; <br>    } <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    FreeNull(szPropFolderPathName); <br> <br>    DebugTraceResult(HrOpenPropertyMessage, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrOpenPropertyMessageRetry <br> * <br> *  Purpose         open the property message for the folder with entryid <br> *                  pointed to peid. The function will retry if message is busy <br> *                  for the specified number of times. <br> * <br> *  Parameters <br> *      peid                pointer to folder's eid <br> *      pims                pointer to the message store object <br> *      fModifyExclusive    TRUE if we want to open for read/write, <br> *                          exclusive access. <br> *      lppmsg              pointer to location to return the open message <br> *                          object <br> * <br> */ <br>HRESULT HrOpenPropertyMessageRetry(PEID peid, PIMS pims, <br>    BOOL fModifyExclusive, LPMESSAGE *lppmsg) <br>{ <br>    UINT iRetry;                /* number of attempts to open */ <br>    HRESULT hr = hrSuccess; <br> <br>    iRetry = 0; <br>    while (TRUE) <br>    { <br>        hr = HrOpenPropertyMessage(peid, pims, fModifyExclusive, lppmsg); <br> <br>        if (GetScode(hr) != MAPI_E_NO_ACCESS || ++iRetry &gt;= NUM_RETRIES) <br>            break; <br> <br>        Sleep(500); <br>    } <br> <br>    #ifdef DEBUG <br>    if (iRetry &gt;= NUM_RETRIES) <br>        TraceSz("HrOpenPropertyMessageRetry: Failing open. Too many tries."); <br>    #endif <br> <br>    DebugTraceResult(HrOpenPropertyMessageRetry, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrGetFileModTime <br> * <br> * Gets the last write time of the file from the OS by calling <br> * FindFirstFile, and retrieving it from the FIND_DATA. <br> * <br> * szStorePath: the path to the message store. <br> * szFileName: the relative path to the file. <br> * pft: a pointer to the location to return the FILETIME <br> * <br> */ <br>HRESULT HrGetFileModTime(LPTSTR szStorePath, LPTSTR szFileName, <br>    FILETIME *pft) <br>{ <br>    HRESULT hr; <br>    LPSTR szFullPath; <br> <br>    hr = HrFullPathName(szStorePath, szFileName, NULL, &amp;szFullPath); <br> <br>    if (hr == hrSuccess) <br>    { <br>        HANDLE hFile; <br>        WIN32_FIND_DATA ffd; <br> <br>        hFile = FindFirstFile(szFullPath, &amp;ffd); <br>     <br>        if (hFile == FAILED_SEARCH) <br>            hr = ResultFromScode(MAPI_E_NOT_FOUND); <br>        else <br>        { <br>            *pft = ffd.ftLastWriteTime; <br>            FindClose(hFile); <br>        } <br>     <br>        FreeNull(szFullPath); <br>    } <br> <br>    DebugTraceResult(HrGetFileModTime, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrFindFirstID <br> * <br> *  Purpose         returns in *ppeid the entryid of the <br> *                  first object in pifldParent whose name is of the <br> *                  form specified in szTemplate. The caller must free <br> *                  storage with CloseIDSearch even in error, <br> *                  except *ppeid is always freed with LMFree. <br> * <br> *  Parameters <br> *      pifldParent     parent folder <br> *      szTemplate      template local name for object to be found <br> *      pichLocal       pointer to variable for position of start of local <br> *                      name of the found object <br> *      pszRRPath       pointer to root relative path of next object <br> *      phFindFile      pointer to location to return search handle <br> *      pffd            pointer to location to return Windows find file data <br> *                      struct for use by HrFindNextID. <br> *      ppeid           pointer to eid of found object <br> * <br> *  Returns: <br> *      HRESULT <br> */ <br>HRESULT HrFindFirstID(PIFLD pifldParent, LPTSTR szTemplate, ULONG *pichLocal, <br>    LPTSTR *pszRRPath, HANDLE *phFindFile, WIN32_FIND_DATA *pffd, PEID *ppeid) <br>{ <br>    HRESULT hr = hrSuccess; <br>    MAPIUID uidStore;           /* uid for message store */ <br>    LPTSTR szSubObject = NULL;  /* template name of subobject */ <br>    PEID peid = NULL; <br>    PLMR plmr; <br>    LPSTR szRRPath = NULL; <br>    ULONG ichLocal = 0; <br>    HANDLE hFindFile = 0; <br>    WIN32_FIND_DATA ffd; <br> <br>    plmr = &amp;pifldParent-&gt;pims-&gt;lmr; <br> <br>    /* find the first subobject */ <br>    hr = HrFullPathName(pifldParent-&gt;pims-&gt;szStorePath, <br>        pifldParent-&gt;peid-&gt;szPath, szTemplate, &amp;szSubObject); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hFindFile = FindFirstFile(szSubObject, &amp;ffd); <br> <br>    if (hFindFile == FAILED_SEARCH) <br>    { <br>        hr = ResultFromScode(MAPI_E_NOT_FOUND); <br>        goto exit; <br>    } <br> <br>    /* get components of entryids for messages in this folder */ <br>    GetResourceUID(pifldParent-&gt;pims, &amp;uidStore); <br> <br>    /* get the root relative path */ <br>    hr = HrAlloc(CbEIDPath(pifldParent-&gt;peid) <br>        + (CCH_NAME * sizeof(TCHAR)), (PPV) &amp;szRRPath); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    lstrcpy(szRRPath, pifldParent-&gt;peid-&gt;szPath); <br>    if (*szRRPath != (TCHAR) 0) <br>        lstrcat(szRRPath, TEXT("\\")); <br> <br>    ichLocal = lstrlen(szRRPath); <br> <br>    lstrcpy(szRRPath + ichLocal, ffd.cFileName); <br> <br>    /* construct the ID */ <br>    hr = HrConstructEID(&amp;uidStore, plmr, szRRPath, &amp;peid); <br>    /* fall through to exit */ <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    if (hr != hrSuccess) <br>    { <br>        LMFree(plmr, peid); <br>        FreeNull(szRRPath); <br> <br>        if (hFindFile &amp;&amp; hFindFile != FAILED_SEARCH) <br>            FindClose(hFindFile); <br>    } <br>    else <br>    { <br>        *ppeid = peid; <br>        *pszRRPath = szRRPath; <br>        *phFindFile = hFindFile; <br>        *pichLocal = ichLocal; <br>        *pffd = ffd; <br>    } <br> <br>    FreeNull(szSubObject); <br> <br>    #ifdef DEBUG <br>    if (GetScode(hr) != MAPI_E_NOT_FOUND) <br>        DebugTraceResult(HrFindFirstID, hr); <br>    #endif <br> <br>    return hr; <br>} <br> <br>/* <br> *  HrFindNextID <br> * <br> *  Purpose         returns in ppeid the eid of the next object in the search <br> *                  free *ppeid with LMFree. <br> * <br> *  Parameters <br> *      pifldParent     parent folder <br> *      ichLocal        position of start of local name of the found object <br> *      szRRPath        name of found object from last search <br> *      hFindFile       search handle <br> *      pffd            [in/out] pointer to location to use and return <br> *                      Windows find file data struct. <br> *      ppeid           pointer to location to return eid of next file. <br> * <br> *  Returns: <br> *      HRESULT <br> */ <br>HRESULT HrFindNextID(PIFLD pifldParent, ULONG ichLocal, LPTSTR szRRPath, <br>    HANDLE hFindFile, WIN32_FIND_DATA *lpFindFileData, PEID *ppeid) <br>{ <br>    HRESULT hr = hrSuccess; <br>    MAPIUID uidStore;           /* resource uid of store */ <br>    PLMR plmr; <br>    PEID peid = NULL; <br> <br>    plmr = &amp;pifldParent-&gt;pims-&gt;lmr; <br> <br>    if (FindNextFile(hFindFile, lpFindFileData)) <br>    { <br>        lstrcpy(szRRPath + ichLocal, lpFindFileData-&gt;cFileName); <br>        GetResourceUID(pifldParent-&gt;pims, &amp;uidStore); <br> <br>        /* construct the ID */ <br>        hr = HrConstructEID(&amp;uidStore, plmr, szRRPath, &amp;peid); <br>    } <br>    else <br>        hr = ResultFromScode(MAPI_E_NOT_FOUND); <br> <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    if (hr != hrSuccess) <br>        LMFree(plmr, peid); <br>    else <br>        *ppeid = peid; <br> <br>    #ifdef DEBUG <br>    if (GetScode(hr) != MAPI_E_NOT_FOUND) <br>        DebugTraceResult(HrFindNextID, hr); <br>    #endif <br> <br>    return hr; <br>} <br> <br>/* <br> *  CloseIDSearch <br> * <br> *  Purpose          <br> *      Calls FindClose on the search handle, and FreeNull on the root-relative <br> *      pathname given as arguments. After cleaning up these values, the <br> *      function also invalidates the pointers. <br> * <br> *  Parameters <br> *      lphFindFile     pointer to search handle, returned with FAILED_SEARCH. <br> *      pszRRPath       pointer to name of found object from last search, <br> *                      returned with NULL. <br> * <br> *  Returns: void. <br> */ <br>void CloseIDSearch(HANDLE *lphFindFile, LPTSTR *pszRRPath) <br>{ <br>    if (lphFindFile &amp;&amp; *lphFindFile &amp;&amp; *lphFindFile != FAILED_SEARCH) <br>    { <br>        FindClose(*lphFindFile); <br>        *lphFindFile = FAILED_SEARCH; <br>    } <br> <br>    FreeNull(*pszRRPath); <br>    *pszRRPath = NULL; <br>} <br> <br>/* <br> *  HrNewIFLD <br> * <br> *  Purpose: <br> *      Allocates and initializes new instance data for a folder <br> * <br> *  Parameters <br> *      peid            EID of folder <br> *      pims            address of the message store for this folder <br> *      fModify         TRUE if caller wants to modify, FALSE otherwise <br> *      ppifld          pointer to newly created instance data <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      Allocates memory for IFLD object.  Freed by calling Release. <br> * <br> */ <br>HRESULT HrNewIFLD(PEID peid, PIMS pims, BOOL fModify, PIFLD *ppifld) <br>{ <br>    SCODE sc; <br>    PIFLD pifld = NULL;         /* pointer to new instance data */ <br> <br>    Assert(peid); <br>    Assert(pims); <br>    Assert(ppifld); <br> <br>    /* Don't open the folder object unless the directory and the property */ <br>    /* file are present on disk. */ <br> <br>    if (!FFolderExists(peid, pims)) <br>    { <br>        sc = MAPI_E_NOT_FOUND; <br>        goto exit; <br>    } <br> <br>    /* Allocate memory for the instance data */ <br>    sc = LMAllocZ(&amp;pims-&gt;lmr, sizeof(IFLD), &amp;pifld); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    /* allocate memory to hold the folder's eid */ <br>    sc = ScAllocZ(CbEID(peid), &amp;pifld-&gt;peid); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    Assert(CbEIDPath(peid) == (UINT) Cbtszsize(peid-&gt;szPath)); <br> <br>    OBJ_Initialize(pifld, &amp;vtblIFLD, OT_FOLDER, pims, pims-&gt;pcs); <br> <br>    memcpy(pifld-&gt;peid, peid, CbEID(peid)); <br> <br>    if (fModify) <br>        OBJ_SetFlag(pifld, OBJF_MODIFY); <br> <br>    OBJ_Enqueue((POBJ) pifld, (POBJ) pims); <br> <br>    *ppifld = pifld; <br> <br>exit: <br>    AssertSz(sc == S_OK || FAILED(sc), "No warning expected"); <br> <br>    if (sc != S_OK &amp;&amp; pifld) <br>    { <br>        FreeNull(pifld-&gt;peid); <br>        LMFree(&amp;pims-&gt;lmr, pifld); <br>    } <br> <br>    DebugTraceSc(HrNewIFLD, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/*  <br> * FFolderExists <br> * <br> * Check for the existence of the folder's property file inside the folder <br> * passed in. If the file isn't there or we can't get to it, return FALSE. <br> * If the file is there, return TRUE. <br> * <br> * Parameters: <br> *      peid -- The entryid of the folder to test. <br> *      pims -- a pointer to the message store object. <br> * <br> * Returns: TRUE if the folder's property file is found. <br> *          FALSE in all other cases. <br> * <br> */ <br>BOOL FFolderExists(PEID peid, PIMS pims) <br>{ <br>    LPTSTR  szPropFolderPathName = NULL; <br>    HRESULT hr; <br>    BOOL    fFolderValid = FALSE; <br> <br>    /* get full path to message file */ <br>    hr = HrFullPathName(pims-&gt;szStorePath, peid-&gt;szPath, szPropertyFileName, <br>        &amp;szPropFolderPathName); <br> <br>    if (hr == hrSuccess) <br>    { <br>        HANDLE hFile; <br>        WIN32_FIND_DATA ffd; <br> <br>        hFile = FindFirstFile(szPropFolderPathName, &amp;ffd); <br>     <br>        if (hFile != FAILED_SEARCH) <br>        { <br>            fFolderValid = TRUE;  /* it's there! */ <br>            FindClose(hFile); <br>        } <br>     <br>        FreeNull(szPropFolderPathName); <br>    } <br> <br>    return fFolderValid; <br>} <br> <br>/* <br> -  HrCreateFolderStorage <br> - <br> *  Purpose: <br> *      Create a new folder directory and its property file <br> * <br> *  Parameters <br> *      pifld               the parent folder of the newly created folder <br> *                          If NULL, the new folder is the root folder. <br> *      ulFolderType        type of folder to be created <br> *      szFolderName        name of the new folder <br> *      szFolderComment     comment string for the new folder <br> *      fCreateDir          TRUE means create directory for folder <br> *      pims                pointer to store in which new folder resides <br> *      ppeid               pointer to entryID of new folder <br> * <br> *  Returns: <br> * <br> *  Side effects:   Sets PR_COMMENT property to szFolderComment. <br> * <br> *  Errors: <br> * <br>*/ <br>HRESULT HrCreateFolderStorage(PIFLD pifld, ULONG ulFolderType, <br>    LPSTR szFolderName, LPSTR szFolderComment, BOOL fCreateDir, <br>    PIMS pims, PEID *ppeid) <br>{ <br>    HRESULT hr; <br>    PEID peid = NULL; <br>    ULONG ulSeqNumber;          /* sequence number of new folder*/ <br>    SPropValue pvalRO[NUM_RO_FOLDER_PROPS]; <br>    SPropValue pvalRW[NUM_RW_FOLDER_PROPS]; <br>    ULONG cSet; <br>    LPSPropProblemArray pprba = NULL; <br>    LPMESSAGE lpmsgProp = NULL; /* property message for this folder */ <br>    BOOL fDirCreated = FALSE; <br>    BOOL fFolderPropFileCreated = FALSE; <br> <br>    LPTSTR szNewDirectoryName = NULL; <br>    LPTSTR szPropertyFolderName = NULL; <br> <br>    Assert(pims); <br>    Assert(ppeid); <br> <br>    hr = HrNewEID(pifld, pims, FOLDER_EXT, &amp;ulSeqNumber, &amp;peid); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* create new directory for the new folder object */ <br>    hr = HrFullPathName(pims-&gt;szStorePath, peid-&gt;szPath, NULL, <br>        &amp;szNewDirectoryName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (fCreateDir) <br>    { <br>        if (!CreateDirectory(szNewDirectoryName, NULL)) <br>        { <br>            hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>            goto exit; <br>        } <br>        fDirCreated = TRUE; <br>    } <br> <br>    hr = HrFullPathName(pims-&gt;szStorePath, peid-&gt;szPath, <br>        szPropertyFileName, &amp;szPropertyFolderName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* create and open the message object for properites */ <br>    hr = HrOpenIMsg(pims-&gt;pmsgsess, szPropertyFolderName, &amp;pims-&gt;lmr, <br>        pims-&gt;psup, TRUE, TRUE, TRUE, &amp;lpmsgProp); <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    fFolderPropFileCreated = TRUE; <br> <br>    /* set the initial read only properties */ <br> <br>    pvalRO[0].ulPropTag = sptaReadOnly.aulPropTag[0]; <br>    pvalRO[1].ulPropTag = sptaReadOnly.aulPropTag[1]; <br>    pvalRO[2].ulPropTag = sptaReadOnly.aulPropTag[2]; <br>    pvalRO[3].ulPropTag = sptaReadOnly.aulPropTag[3]; <br>    pvalRO[4].ulPropTag = sptaReadOnly.aulPropTag[4]; <br>    pvalRO[5].ulPropTag = sptaReadOnly.aulPropTag[5]; <br>    pvalRO[6].ulPropTag = sptaReadOnly.aulPropTag[6]; <br>    pvalRO[7].ulPropTag = sptaReadOnly.aulPropTag[7]; <br>    pvalRO[8].ulPropTag = sptaReadOnly.aulPropTag[8]; <br>    pvalRO[9].ulPropTag = sptaReadOnly.aulPropTag[9]; <br>    pvalRO[10].ulPropTag = sptaReadOnly.aulPropTag[10]; <br> <br>    pvalRO[0].Value.l = MAPI_FOLDER; <br>    pvalRO[1].Value.bin.cb = sizeof(ULONG); <br>    pvalRO[1].Value.bin.lpb = (BYTE *) &amp;ulSeqNumber; <br>    pvalRO[2].Value.l = (pifld == NULL) ? FOLDER_ROOT : FOLDER_GENERIC; <br>    pvalRO[3].Value.l = 0; <br>    pvalRO[4].Value.l = 0; <br> <br>    pvalRO[5].Value.bin.cb = pims-&gt;eidStore.cb; <br>    pvalRO[5].Value.bin.lpb = pims-&gt;eidStore.lpb; <br> <br>    pvalRO[6].Value.bin.cb = sizeof(pims-&gt;uidResource); <br>    pvalRO[6].Value.bin.lpb = (LPBYTE) &amp;pims-&gt;uidResource; <br> <br>    pvalRO[7].Value.b = FALSE; <br> <br>    /* Set PR_ENTRYID, PR_PARENT_ENTRYID and PR_INSTANCE_KEY to null */ <br>    /* strings to keep clients from writing over them. */ <br>    /* We get the actual values internally. */ <br> <br>    pvalRO[8].Value.bin.cb = 1; <br>    pvalRO[8].Value.bin.lpb = (LPBYTE) ""; <br> <br>    pvalRO[9].Value.bin.cb = 1; <br>    pvalRO[9].Value.bin.lpb = (LPBYTE) ""; <br> <br>    pvalRO[10].Value.bin.cb = 1; <br>    pvalRO[10].Value.bin.lpb = (LPBYTE) ""; <br> <br>    /* set these read only props */ <br>    hr = lpmsgProp-&gt;lpVtbl-&gt;SetProps(lpmsgProp, NUM_RO_FOLDER_PROPS, <br>        pvalRO, &amp;pprba); <br>    if (hr != hrSuccess || pprba) <br>        goto exit; <br> <br>    Assert(sptaReadOnly.cValues == NUM_RO_FOLDER_PROPS); <br>    Assert(spaReadOnly.cValues == NUM_RO_FOLDER_PROPS); <br> <br>    hr = SetAttribIMsgOnIStg(lpmsgProp, (LPSPropTagArray) &amp;sptaReadOnly, <br>        (LPSPropAttrArray) &amp;spaReadOnly, &amp;pprba); <br>    if (hr != hrSuccess || pprba) <br>        goto exit; <br> <br>    /* set the read write properties */ <br> <br>    cSet = NUM_RW_FOLDER_PROPS; <br> <br>    pvalRW[0].ulPropTag = PR_DISPLAY_NAME; <br> <br>    /* must be last since it is optional */ <br>    pvalRW[1].ulPropTag = PR_COMMENT; <br> <br>    pvalRW[0].Value.LPSZ = szFolderName; <br>    if (szFolderComment != NULL) <br>        pvalRW[1].Value.LPSZ = szFolderComment; <br>    else <br>        cSet--; <br> <br>    /* set the ReadWrite properties */ <br> <br>    hr = lpmsgProp-&gt;lpVtbl-&gt;SetProps(lpmsgProp, cSet, pvalRW, &amp;pprba); <br>    if (hr != hrSuccess || pprba) <br>        goto exit; <br> <br>    hr = lpmsgProp-&gt;lpVtbl-&gt;SaveChanges(lpmsgProp, 0); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    UlRelease(lpmsgProp); <br> <br>    /* free the property problem structure */ <br>    if (pprba) <br>    { <br>        LMFree(&amp;pims-&gt;lmr, pprba); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>    } <br> <br>    if (hr != hrSuccess) <br>    { <br>        LMFree(&amp;pims-&gt;lmr, peid); <br> <br>        if (fFolderPropFileCreated == TRUE) <br>            DeleteFile(szPropertyFolderName); <br> <br>        if (fDirCreated == TRUE) <br>            RemoveDirectory(szNewDirectoryName); <br>    } <br>    else <br>        *ppeid = peid; <br> <br>    FreeNull(szNewDirectoryName); <br>    FreeNull(szPropertyFolderName); <br> <br>    DebugTraceResult(HrCreateFolderStorage, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrIncrementOneROProp <br> * <br> *  Purpose     increment the read only property by delta. Only works on <br> *              properties of type PT_LONG. <br> * <br> *  Argument    pifld   pointer to the folder object <br> *              lDelta  size of increment <br> *              ulPT    the property tag to be changed <br> */ <br>HRESULT HrIncrementOneROProp(PIFLD pifld, LONG lDelta, ULONG ulPT) <br>{ <br>    LONG lValue; <br>    HRESULT hr; <br>    LPMESSAGE lpmsg = NULL; /* property message for pifld */ <br>    PLMR plmr = &amp;pifld-&gt;pims-&gt;lmr; <br> <br>    AssertSz1(PROP_TYPE(ulPT) == PT_LONG, <br>        "Trying to increment property %s; not PT_LONG", <br>        SzDecodeUlPropTag(ulPT)); <br> <br>    /* open the property message exclusively */ <br>    hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, <br>        TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* get the current value of the properties */ <br> <br>    hr = HrGetSingleProp((LPMAPIPROP) lpmsg, plmr, ulPT, &amp;lValue); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    lValue += lDelta; <br> <br>    /* reset the new value */ <br> <br>    hr = HrSetOneROProp(lpmsg, plmr, ulPT, &amp;lValue); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, FORCE_SAVE); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    UlRelease(lpmsg); <br> <br>    DebugTraceResult(HrIncrementOneROProp, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrSetOneROFolderProp <br> * <br> *  Purpose     set the read only folder property to the value given. The <br> *              property must be of type PT_LONG. <br> * <br> *  Argument    pifld   pointer to the folder object <br> *              lValue  value to set the property to. <br> *              ulPT    the property tag to be changed <br> */ <br>static HRESULT HrSetOneROFolderProp(PIFLD pifld, LONG lValue, ULONG ulPT) <br>{ <br>    HRESULT hr; <br>    LPMESSAGE lpmsg = NULL; /* property message for pifld */ <br>    PLMR plmr = &amp;pifld-&gt;pims-&gt;lmr; <br> <br>    AssertSz1(PROP_TYPE(ulPT) == PT_LONG, <br>        "Trying to increment property %s; not PT_LONG", <br>        SzDecodeUlPropTag(ulPT)); <br> <br>    /* open the property message exclusively */ <br>    hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, <br>        TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* reset the new value */ <br> <br>    hr = HrSetOneROProp(lpmsg, plmr, ulPT, &amp;lValue); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, FORCE_SAVE); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); </code></pre>
<p>
</p>
<pre><code><br>    UlRelease(lpmsg); <br> <br>    DebugTraceResult(HrSetOneROFolderProp, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrSetSubFolderProp <br> * <br> *  Purpose     set the PR_SUBFOLDERS property <br> * <br> *  Argument    pifld       pointer to the folder object <br> *              fSubFolder  the value to write into the PR_SUBFOLDER property <br> */ <br>static HRESULT HrSetSubFolderProp(PIFLD pifld, BOOL fSubFolder) <br>{ <br>    HRESULT hr; <br>    LPMESSAGE lpmsg = NULL; /* property message for pifld */ <br>    PIFLD pifldParent = NULL; <br>    PLMR plmr = &amp;pifld-&gt;pims-&gt;lmr; <br>    PEID peid = pifld-&gt;peid; <br> <br>    /* open the property message exclusively */ <br>    hr = HrOpenPropertyMessageRetry(peid, pifld-&gt;pims, TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* set the new value */ <br> <br>    hr = HrSetOneROProp(lpmsg, plmr, PR_SUBFOLDERS, &amp;fSubFolder); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, FORCE_SAVE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    UlRelease(lpmsg); <br>    lpmsg = NULL; <br> <br>    /* If this isn't the root folder, get the parent entryid, and call */ <br>    /* ChangeTable so that any new properties are updated in its */ <br>    /* hierarchy table row. */ <br> <br>    if (FIsRoot(peid) == FALSE) <br>    { <br>        PEID peidParent = NULL; <br>        PIMS pims = pifld-&gt;pims; <br> <br>        hr = HrGetParentEID(&amp;pims-&gt;lmr, pifld-&gt;peid, &amp;peidParent); <br>        if (hr == hrSuccess) <br>        { <br>            ChangeTable(pims, peidParent, peid, MAPI_FOLDER, <br>                TABLE_ROW_MODIFIED, TRUE); <br>            LMFree(&amp;pims-&gt;lmr, peidParent); <br>        } <br>        else <br>        { <br>            TraceSz1("Sample MS: HrSetSubFolderProp: failed to change " <br>                "hierarchy table. sc == %s\n", SzDecodeScode(GetScode(hr))); <br>            hr = hrSuccess; <br>        } <br>    } <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    UlRelease(lpmsg); <br>    UlRelease(pifldParent); <br> <br>    DebugTraceResult(HrSetSubFolderProp, hr); <br>    return hr; <br>} <br> <br>/* <br> *  ChangeTable <br> * <br> * Purpose <br> *  Changes all contents or hierarchy tables in all open folders to reflect <br> *  the change specified. Also updates the folder's content and unread counts. <br> *  Never updates the table on disk. That will happen when the table is <br> *  read-in and verified. <br> * <br> *  Parameters <br> * <br> *      pims            Pointer to the message store object. <br> *      peidTable       EID of the parent folder of the table to change <br> *      peidObject      the object that has been added or deleted or modified. <br> *                      May be NULL if ulTableEvent is TABLE_CHANGED. This  <br> *                      means multiple items changed. <br> *      ulObjType       MAPI_MESSAGE (for contents tables) or MAPI_FOLDER <br> *                      (for hierarchy tables) <br> *      ulTableEvent    either TABLE_ROW_ADDED, DELETED, MODIFIED, or <br> *                      TABLE_CHANGED (TABLE_CHANGED for contents tables only) <br> *      fSendNotif      TRUE if this routine should send notifications to <br> *                      other processes about this change. <br> * <br> */ <br>void ChangeTable(PIMS pims, PEID peidTable, PEID peidObject, <br>    ULONG ulObjType, ULONG ulTableEvent, BOOL fSendNotif) <br>{ <br>    HRESULT hr = hrSuccess; <br>    ULONG cbEIDTable; <br>    LPSPropTagArray pPTA;       /* proptags of column headings */ <br>    POBJ pobj; <br> <br>    Assert(pims); <br>    Assert(peidTable); <br>    AssertSz1(ulTableEvent == TABLE_ROW_ADDED <br>        || ulTableEvent == TABLE_ROW_MODIFIED <br>        || ulTableEvent == TABLE_ROW_DELETED <br>        || ulTableEvent == TABLE_CHANGED, "Bad ulTableEvent %08lX", <br>        ulTableEvent); <br>    AssertSz1(ulObjType == MAPI_MESSAGE || ulObjType == MAPI_FOLDER, <br>        "Bad ulObjType %08lX", ulObjType); <br> <br>    /* <br>     * Look for all open tables within this process. We find them <br>     * by search the open object chain for folders whose entryids match <br>     * the eid of the folder passed in. We only update open tables. <br>     * Therefore, don't bother checking objects that aren't folders or  <br>     * folder objects without open tables. <br>     */ <br>    cbEIDTable = CbEID(peidTable); <br> <br>    for (pobj = pims-&gt;pobjHead; pobj != NULL; pobj = pobj-&gt;pobjNext) <br>    { <br>        PIFLD pifld; <br>        ULONG ulTheSame; <br>        LPTABLEDATA lptbl; <br>        FILETIME ft; <br> <br>        if (pobj-&gt;wType != OT_FOLDER) <br>            continue; <br> <br>        pifld = (PIFLD) pobj; <br> <br>        if (ulObjType == MAPI_MESSAGE) <br>        { <br>            pPTA = (LPSPropTagArray) &amp;sPropTagsContents; <br>            lptbl = pifld-&gt;lptblContents; <br>        } <br>        else <br>        { <br>            pPTA = (LPSPropTagArray) &amp;sPropTagsHierarchy; <br>            lptbl = pifld-&gt;lptblHierarchy; <br>        } <br> <br>        if (lptbl == NULL) <br>            continue; <br> <br>        hr = pims-&gt;lpVtbl-&gt;CompareEntryIDs(pims, cbEIDTable, <br>                (LPENTRYID) peidTable, CbEID(pifld-&gt;peid), <br>                (LPENTRYID) pifld-&gt;peid, 0L, &amp;ulTheSame); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (!ulTheSame) <br>            continue; <br> <br>        switch (ulTableEvent) <br>        { <br>        case TABLE_CHANGED: <br>            if (ulObjType != MAPI_MESSAGE) <br>            { <br>                TrapSz("ChangeTable doesn't handle TABLE_CHANGED on" <br>                    " hierarchy tables"); <br>                goto exit; <br>            } <br> <br>            /* Don't update the file on disk. */ <br>            hr = HrSyncContentsTable(pifld, FALSE); <br>            if (hr != hrSuccess) <br>                goto exit; <br>            break; <br> <br>        case TABLE_ROW_DELETED: <br>            hr = HrRemoveRow(lptbl, peidObject); <br>            if (hr != hrSuccess) <br>            { <br>                if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>                    hr = hrSuccess; <br>                else <br>                    goto exit; <br>            } <br>            break; <br> <br>        case TABLE_ROW_ADDED: <br>        case TABLE_ROW_MODIFIED: <br>            hr = HrGetFileModTime(pims-&gt;szStorePath, peidObject-&gt;szPath, &amp;ft); <br>            if (hr != hrSuccess) <br>                goto exit; <br> <br>            hr = HrUpdateRow(pims, lptbl, peidObject, pPTA, &amp;ft, ulObjType); <br>            if (hr != hrSuccess) <br>                goto exit; <br>            break; <br> <br>        default: <br>            /* We've already asserted this above. */ <br>            goto exit; <br>        } <br>    } <br> <br>    if (fSendNotif) <br>        hr = HrSendNotif(pims, peidTable, peidObject, ulTableEvent, ulObjType); <br> <br>exit: <br>    if (hr != hrSuccess) <br>        TraceSz1("SampleMS: ChangeTable: failed to update " <br>            "table. Error %s.\n", SzDecodeScode(GetScode(hr))); <br> <br>    return; <br>} <br> <br>/* <br> *  HrDestroyFolderStorage <br> * <br> *  Purpose         Removes storage associated with a folder <br> * <br> *  Parameters <br> * <br> *      szFullPath  full path name of the folder to be removed <br> * <br> */ <br>HRESULT HrDestroyFolderStorage(LPTSTR szFullPath) <br>{ <br>    HRESULT hr; <br>    LPTSTR szAll = NULL;    /* path to all files in the folder */ <br>    HANDLE hFile; <br>    WIN32_FIND_DATA ffd; <br> <br>    /* Find all files in the directory, and attempt to delete them. */ <br>    /* Note that if somehow a subdirectory was created in this directory, */ <br>    /* this function will fail. The loop below (that deletes files) goes */ <br>    /* ahead regardless of error until it has tried to delete all files. */ <br>    /* The only fatal error occurs if we can't remove the directory itself. */ <br> <br>    hr = HrAppendPath(szFullPath, szAllFilesTemplate, &amp;szAll); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hFile = FindFirstFile(szAll, &amp;ffd); <br> <br>    if (hFile != INVALID_HANDLE_VALUE) <br>    { <br>        while (TRUE) <br>        { <br>            LPTSTR szTemp = NULL; <br> <br>            /* Don't even attempt to delete directories. The directories */ <br>            /* named "." and ".." are always included in the contents of */ <br>            /* a directory listing, and this avoids the attempt to delete */ <br>            /* them. */ <br> <br>            if (!(ffd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)) <br>            { <br>                if (HrAppendPath(szFullPath, ffd.cFileName, &amp;szTemp) <br>                    == hrSuccess) <br>                { <br>                    DeleteFile(szTemp); <br>                    FreeNull(szTemp); <br>                } <br>            } <br>     <br>            if (!FindNextFile(hFile, &amp;ffd)) <br>            { <br>                FindClose(hFile); <br>                break; <br>            } <br>        } <br>    } <br> <br>    /* Attempt to delete the folder itself. */ <br>    if (!RemoveDirectory(szFullPath)) <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    FreeNull(szAll); <br> <br>    DebugTraceResult(HrDestroyFolderStorage, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrFillHierarchyTable <br> * <br> *  Purpose     Construct table data for hierarchy below the folder pifld <br> * <br> *  Argument <br> *              pifld       pointer to the folder to be added to <br> *                          the hierarchy table. <br> *              lptbl       underlying table data <br> * <br> */ <br>static HRESULT HrFillHierarchyTable(PIFLD pifld, LPTABLEDATA lptbl) <br>{ <br>    HRESULT hr; <br>    PEID peidSub = NULL; <br>    LPTSTR szSubFolder = NULL;  /* template for subfolder of szFolder */ <br>    HANDLE hFindFile = FAILED_SEARCH; <br>    ULONG ichLocal; <br>    WIN32_FIND_DATA ffd; <br>    PIMS pims = pifld-&gt;pims; <br> <br>    /* build a hierarchy entry for each subfolder */ <br>    hr = HrFindFirstID(pifld, szFolderTemplate, &amp;ichLocal, <br>        &amp;szSubFolder, &amp;hFindFile, &amp;ffd, &amp;peidSub); <br> <br>    while (hr == hrSuccess) <br>    { <br>        /* build hierarchy entry for this subfolder */ <br>        hr = HrUpdateRow(pims, lptbl, peidSub, <br>            (LPSPropTagArray) &amp;sPropTagsHierarchy, <br>            &amp;(ffd.ftLastWriteTime), MAPI_FOLDER); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        LMFree(&amp;pims-&gt;lmr, peidSub); <br>        peidSub = NULL; <br> <br>        hr = HrFindNextID(pifld, ichLocal, szSubFolder, <br>            hFindFile, &amp;ffd, &amp;peidSub); <br>    } <br> <br>    if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>        hr = hrSuccess; <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    /* close the search */ <br>    CloseIDSearch(&amp;hFindFile, &amp;szSubFolder); <br>    LMFree(&amp;pims-&gt;lmr, peidSub); <br> <br>    DebugTraceResult(HrFillHierarchyTable, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrDuplicateIFLD <br> * <br> *  Searches the existing subfolders of pifldParent for a folder with <br> *  PR_DISPLAY_NAME of szName. If it finds a match, opens it and returns <br> *  the matching folder (doing nothing else). If no folder matches, then <br> *  the routine creates a new folder and copies all properties from the <br> *  old folder into the new folder. <br> * <br> *      pifld           the old folder <br> *      pifldParent     parent of the new folder <br> *      szName          name of new folder <br> *      szComment       comment for new folder <br> *      ppifldNew       pointer to the location to return the new folder <br> * <br> */ <br>static HRESULT HrDuplicateIFLD(PIFLD pifld, PIFLD pifldParent, LPTSTR szName, <br>    LPTSTR szComment, PIFLD *ppifldNew) <br>{ <br>    HRESULT hr = hrSuccess; <br>    BOOL fCreated = FALSE; <br>    PIFLD pifldNew = NULL; <br> <br>    /* create new folder */ <br> <br>    hr = HrCreateFolder(pifldParent, szName, szComment, TRUE, &amp;pifldNew, <br>        &amp;fCreated); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* copy pifld's properties over except excluded stuff (see */ <br>    /* sptaExclFldProps definition). */ <br> <br>    if (fCreated) <br>    { <br>        LPSPropProblemArray pprba = NULL; <br>        LPMESSAGE lpmsgPropSrc = NULL;  /* pifld's property message */ <br>        LPMESSAGE lpmsgPropNew = NULL;  /* new ifld's property message */ <br> <br>        hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, FALSE, <br>                &amp;lpmsgPropSrc); <br> <br>        if (hr == hrSuccess) <br>            hr = HrOpenPropertyMessageRetry(pifldNew-&gt;peid, <br>                    pifldNew-&gt;pims, TRUE, &amp;lpmsgPropNew); <br> <br>        if (hr == hrSuccess) <br>            hr = lpmsgPropSrc-&gt;lpVtbl-&gt;CopyTo(lpmsgPropSrc, 0, NULL, <br>                    (LPSPropTagArray) &amp;sptaExclFldProps, 0, NULL, <br>                    (LPIID) &amp;IID_IMessage, lpmsgPropNew, 0L, &amp;pprba); <br> <br>        UlRelease(lpmsgPropSrc); <br>        UlRelease(lpmsgPropNew); <br> <br>        if (pprba) <br>        { <br>            Assert(hr == hrSuccess); <br>            LMFree(&amp;pifld-&gt;pims-&gt;lmr, pprba); <br>            hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        } <br>    } <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    *ppifldNew = pifldNew; <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    DebugTraceResult(HrDuplicateIFLD, hr); <br>    return hr; <br>} <br> <br>/* <br> -  HrGetSortOrder <br> - <br> *  Purpose: <br> *      returns in *lppsSortOrder the order of contents tables. <br> *      Caller must use MAPIFreeBuffer to release *lppsSortOrder. <br> * <br> *  Parameters <br> *       pifld          folder whose contents table is referred to <br> *       lppsSortOrder  pointer to sort order variable <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> */ <br>static HRESULT HrGetSortOrder(PIFLD pifld, LPSSortOrderSet *lppsSortOrder) <br>{ <br>    ULONG cValues;              /* number of property values returned */ <br>    LPSPropValue pval = NULL;   /* returned property array */ <br>    HRESULT hr; <br>    ULONG cbSos;                /* number of bytes in sort order */ <br>    SCODE sc; <br>    static SizedSPropTagArray(1, sptaSortOrder) = <br>    { <br>        1, <br>        { <br>            PR_SMS_CONTENTS_SORT_ORDER <br>        } <br>    }; <br> <br>    Assert(pifld); <br>    Assert(lppsSortOrder); <br> <br>    /* get the sort order property */ <br>    hr = pifld-&gt;lpVtbl-&gt;GetProps(pifld, <br>        (LPSPropTagArray) &amp;sptaSortOrder, 0, /* ansi */ <br>        &amp;cValues, &amp;pval); <br> <br>    if (hr != hrSuccess) <br>    { <br>        Assert(HR_FAILED(hr) || GetScode(hr) == MAPI_W_ERRORS_RETURNED); <br>        cbSos = CbSSortOrderSet((LPSSortOrderSet) &amp;sSortOrderContentsDefault); <br> <br>        /* sort order is the default */ <br>        sc = LMAlloc(&amp;pifld-&gt;pims-&gt;lmr, cbSos, lppsSortOrder); <br>        if (sc != S_OK) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto exit; <br>        } <br> <br>        memcpy(*lppsSortOrder, &amp;sSortOrderContentsDefault, (UINT) cbSos); <br>    } <br>    else <br>    { <br>        /* This property should contain a flattened array of */ <br>        /* SSortOrder structures. */ <br> <br>        Assert(cValues == 1L); <br>        cbSos = sizeof(ULONG) * pval-&gt;Value.MVl.cValues; <br> <br>        sc = LMAlloc(&amp;pifld-&gt;pims-&gt;lmr, offsetof(SSortOrderSet, aSort) + cbSos, <br>            lppsSortOrder); <br>        if (sc != S_OK) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto exit; <br>        } <br> <br>        (*lppsSortOrder)-&gt;cSorts = pval-&gt;Value.MVl.cValues / 2; <br>        (*lppsSortOrder)-&gt;cCategories = 0; <br>        (*lppsSortOrder)-&gt;cExpanded = 0; <br>        memcpy((*lppsSortOrder)-&gt;aSort, pval-&gt;Value.MVl.lpl, (UINT) cbSos); <br>    } <br>    hr = hrSuccess; <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    LMFree(&amp;pifld-&gt;pims-&gt;lmr, pval); <br>    DebugTraceResult(HrGetSortOrder, hr); <br>    return hr; <br>} <br> <br>/* <br> -  DestroyMessageList <br> - <br> *  Purpose: <br> *      frees allocated memory inside lppEntryList. The cValues field <br> *      inside the entrylist must contain the count of the number of <br> *      entryids that are in the entrylist so that the entryids can be <br> *      freed. <br> * <br> *  Parameters <br> *       lppEntryList   pointer to a list of entryids; returned NULL <br> * <br> */ <br>static void DestroyMessageList(PLMR plmr, LPENTRYLIST *lppEntryList) <br>{ <br>    Assert(lppEntryList); <br> <br>    if (*lppEntryList != NULL &amp;&amp; (*lppEntryList)-&gt;lpbin != NULL) <br>    { <br>        ULONG cValues = (*lppEntryList)-&gt;cValues; <br>        LPSBinary lpbin = (*lppEntryList)-&gt;lpbin; <br> <br>        Assert(cValues &lt;= UINT_MAX / sizeof(SBinary)); <br>        Assert(!IsBadReadPtr(lpbin, (UINT) cValues * sizeof(SBinary))); <br> <br>        for (; cValues; cValues--, lpbin++) <br>        { <br>            Assert(lpbin-&gt;cb &lt;= UINT_MAX); <br>            Assert(!IsBadReadPtr(lpbin-&gt;lpb, (UINT) lpbin-&gt;cb)); <br>            LMFree(plmr, lpbin-&gt;lpb); <br>        } <br> <br>        FreeNull(*lppEntryList); <br>    } <br> <br>    *lppEntryList = NULL; <br>    return; <br>} <br> <br>/* <br> -  HrCreateMessageList <br> - <br> *  Purpose: <br> *      Counts up and returns a list of entryids for every message in <br> *      the given folder. If no messages are found in the folder, returns <br> *      NULL instead of the list. To get the count, this routine uses <br> *      FindFirstFile, FindNextFile on all files with a ".msg" extension. <br> *      We use PR_CONTENT_COUNT to get an estimate of how many msgs are in <br> *      the folder, but don't depend on that property being correct. If <br> *      the property is incorrect, this routine updates it (SIDE EFFECT) <br> *      before returning to the caller. <br> * <br> *  Parameters <br> *       pifld          the folder object <br> *       lppEntryList   [out] pointer to the location to return a list of <br> *                      entryids of messages in pifld. <br> * <br> */ <br>static HRESULT HrCreateMessageList(PIFLD pifld, LPENTRYLIST *lppEntryList) <br>{ <br>    HRESULT hr; <br>    LONG cMsgsOrig;             /* value of PR_CONTENT_COUNT property */ <br>    LONG cMsgsAlloced;          /* number of msgs allocated in pent-&gt;lpbin */ <br>    ULONG ichLocal;             /* start of message name in full path name */ <br>    LPSBinary lpbin; <br>    LPSBinary lpbinMac; <br> <br>    PEID peidNext = NULL;       /* next entryID to be added to the list */ <br>    WIN32_FIND_DATA ffd; <br>    LPTSTR szFile = NULL; <br>    HANDLE hFindFile = FAILED_SEARCH; <br>    LPENTRYLIST pent = NULL; <br> <br>    /* get the number of messages in pifld */ <br>    /* This value may be incorrect, so use it to simply get an idea */ <br>    /* of how many messages are in the folder. Allocate extra space */ <br>    /* for extra (uncounted) messages, and, if necessary, realloc */ <br>    /* the array until we really count all of them. After we've counted */ <br>    /* all messages, update PR_CONTENT_COUNT with the correct number. */ <br>    /* Assuming that there are extra messages in the folder avoids having */ <br>    /* to realloc the array as often when there actually are extra ones. */ <br> <br>#define CMSGS_EXTRA     10  /* # of extra spaces to alloc in msg array */ <br> <br>    hr = HrGetSingleProp((LPMAPIPROP) pifld, &amp;pifld-&gt;pims-&gt;lmr, <br>            PR_CONTENT_COUNT, &amp;cMsgsOrig); <br> <br>    /* Don't allow the failure to get PR_CONTENT_COUNT to keep this call */ <br>    /* from succeeding. Go ahead and do the call anyway. */ <br> <br>    if (hr != hrSuccess) <br>    { <br>        hr = hrSuccess; <br> <br>        /* We failed to get the property. Set the "original value" */ <br>        /* to an impossible value so that we will attempt to update it */ <br>        /* at the bottom of this function. */ <br> <br>        cMsgsOrig = -1; <br>        cMsgsAlloced = CMSGS_EXTRA; <br>    } <br>    else <br>        cMsgsAlloced = cMsgsOrig + CMSGS_EXTRA; <br> <br>    /* Allocate space for the entrylist. */ <br> <br>    hr = HrAlloc(sizeof(SBinaryArray) + (cMsgsAlloced * sizeof(SBinary)), <br>        &amp;pent); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* We allocated the space all at once; therefore, we initialize the */ <br>    /* lpbin pointer to point just past the binary array. */ <br> <br>    pent-&gt;lpbin = (LPSBinary) ((LPBYTE) pent + sizeof(SBinaryArray)); <br> <br>    /* The cValues field of the entrylist must be kept up-to-date as we */ <br>    /* add entryids to the entrylist. DestroyMessageList (see above) uses */ <br>    /* that field when it frees up the entryids, and if it is wrong, the */ <br>    /* wrong number of entryids will get freed (resulting in a crash if */ <br>    /* it is too big, or a memory leak if it is too small). */ <br> <br>    pent-&gt;cValues = 0; <br> <br>    lpbin = pent-&gt;lpbin; <br>    lpbinMac = lpbin + cMsgsAlloced; <br> <br>    /* get the first entryID */ <br>    hr = HrFindFirstID(pifld, szMessageTemplate, &amp;ichLocal, <br>        &amp;szFile, &amp;hFindFile, &amp;ffd, &amp;peidNext); <br> <br>    if (hr != hrSuccess) <br>    { <br>        /* MAPI_E_NOT_FOUND means that there are no more messages in */ <br>        /* the folder. This is not an error. Because this was the first */ <br>        /* file, there were no messages in the folder at all. Therefore, */ <br>        /* free any allocated memory, reset hr, and get out. */ <br> <br>        if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>        { <br>            DestroyMessageList(&amp;pifld-&gt;pims-&gt;lmr, &amp;pent); <br> <br>            /* pent should be NULL now. We're going to return it to */ <br>            /* our caller below. */ <br> <br>            AssertSz(pent == NULL, "DestroyMessageList is broken."); <br> <br>            hr = hrSuccess; <br>        } <br> <br>        goto exit; <br>    } <br> <br>    while (TRUE) <br>    { <br>        lpbin-&gt;cb = CbEID(peidNext); <br>        lpbin-&gt;lpb = (LPBYTE) peidNext; <br> <br>        ++(pent-&gt;cValues); <br> <br>        hr = HrFindNextID(pifld, ichLocal, szFile, hFindFile, &amp;ffd, &amp;peidNext); <br> <br>        if (hr != hrSuccess) <br>        { <br>            /* MAPI_E_NOT_FOUND means that there are no more messages in */ <br>            /* the folder. This is not an error. */ <br> <br>            if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>                hr = hrSuccess; <br> <br>            goto exit; <br>        } <br> <br>        lpbin++; <br> <br>        if (lpbin &gt;= lpbinMac) <br>        { <br>            /* We need to realloc the array. */ <br>            cMsgsAlloced += CMSGS_EXTRA; <br> <br>            hr = HrRealloc((cMsgsAlloced * sizeof(SBinary)) <br>                + sizeof(SBinaryArray), pent, &amp;pent); <br>            if (hr != hrSuccess) <br>                goto exit; <br> <br>            /* reset the pointer to the end of the array. */ <br>            lpbinMac = pent-&gt;lpbin + cMsgsAlloced; <br>        } <br>    } <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    /* close the search */ <br>    CloseIDSearch(&amp;hFindFile, &amp;szFile); <br> <br>    if (hr == hrSuccess) <br>    { <br>        LONG cMsgsFound = 0; <br> <br>        /* If PR_CONTENT_COUNT was incorrect, then update it. Note that */ <br>        /* the number of messages we found is kept in pent-&gt;cValues unless */ <br>        /* we didn't find any messages (in which case, pent is NULL, and */ <br>        /* we assume no messages were found). */ <br> <br>        if (pent) <br>            cMsgsFound = pent-&gt;cValues; <br> <br>        if (cMsgsFound != cMsgsOrig) <br>            (void) HrSetOneROFolderProp(pifld, cMsgsFound, PR_CONTENT_COUNT); <br> <br>        *lppEntryList = pent; <br>    } <br>    else if (pent) <br>        DestroyMessageList(&amp;pifld-&gt;pims-&gt;lmr, &amp;pent); <br> <br>    DebugTraceResult(HrCreateMessageList, hr); <br>    return hr; <br>} <br> <br>/* <br> -  HrDeleteSubDirectory <br> - <br> *  Purpose: <br> *      Delete a subdirectory of the current directory <br> * <br> *  Parameters <br> *       pifldParent    parent folder of folder to delete <br> *       peid           entryid of folder to be deleted <br> *       ulFlags        DEL_FOLDERS and/or DEL_MESSAGES <br> *       fContentsOnly  BOOL. If TRUE, don't delete peid itself. <br> * <br> *  Side effects: <br> *      If either flag is set, it deletes all that it can before returning. <br> *      It is possible for the subdirectory to fail at being deleted but to <br> *      have some of its contents removed. <br> * <br> */ <br>static HRESULT HrDeleteSubDirectory(PIFLD pifldParent, PEID peidToDelete, <br>    ULONG ulFlags, BOOL fContentsOnly) <br>{ <br> <br>    HANDLE hFindFile = FAILED_SEARCH; <br>    LPTSTR szToDelete = NULL;   /* full path name of subdir to be deleted */ <br>    PEID peidSubDir = NULL;     /* eid of subdirectory */ <br>    PIFLD pifldToDelete = NULL; /* opened subdirectory to delete */ <br>    ULONG ulOffset;             /* start of local name of subdir in szSubDir */ <br>    ULONG ulObjType; <br>    LPENTRYLIST lpMessages = NULL;  /* list of messages to be deleted */ <br>    LPTSTR szRelativePath = NULL;   /* relative path for id searches */ <br>    WIN32_FIND_DATA ffd; <br>    HRESULT hr = hrSuccess; <br>    PIMS pims = pifldParent-&gt;pims; <br> <br>    hr = HrFullPathName(pims-&gt;szStorePath, peidToDelete-&gt;szPath, <br>        NULL, &amp;szToDelete); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* open up the folder to be deleted */ <br>    hr = pifldParent-&gt;lpVtbl-&gt;OpenEntry(pifldParent, CbEID(peidToDelete), <br>        (LPENTRYID) peidToDelete, NULL, MAPI_MODIFY, <br>        &amp;ulObjType, (LPUNKNOWN *) &amp;pifldToDelete); <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (!(ulFlags &amp; DEL_FOLDERS)) <br>    { <br>        /* The caller didn't specify DEL_FOLDERS. Check to make sure that */ <br>        /* there aren't any subfolders before allowing the deletion to */ <br>        /* continue. If there are subfolders, return MAPI_E_HAS_FOLDERS. */ <br> <br>        /* Look for any subfolders */ <br> <br>        hr = HrFindFirstID(pifldToDelete, szFolderTemplate, &amp;ulOffset, <br>            &amp;szRelativePath, &amp;hFindFile, &amp;ffd, &amp;peidSubDir); <br> <br>        CloseIDSearch(&amp;hFindFile, &amp;szRelativePath); <br> <br>        if (hr == hrSuccess) <br>        { <br>            /* release the eid */ <br>            LMFree(&amp;pims-&gt;lmr, peidSubDir); <br>            peidSubDir = NULL; <br> <br>            hr = ResultFromScode(MAPI_E_HAS_FOLDERS); <br>            goto exit; <br>        } <br>        else if (GetScode(hr) != MAPI_E_NOT_FOUND) <br>            goto exit; <br> <br>        hr = hrSuccess; <br>    } <br>    else <br>    { <br>        /* set up the search for subdirectories */ <br>        hr = HrFindFirstID(pifldToDelete, szFolderTemplate, &amp;ulOffset, <br>            &amp;szRelativePath, &amp;hFindFile, &amp;ffd, &amp;peidSubDir); <br>     <br>        /* Delete each subdirectory*/ <br>        while (hr == hrSuccess) <br>        { <br>            hr = HrDeleteSubDirectory(pifldToDelete, peidSubDir, ulFlags, FALSE); <br>     <br>            /* release the eid */ <br>            LMFree(&amp;pims-&gt;lmr, peidSubDir); <br>            peidSubDir = NULL; <br>     <br>            /* Errors returned from HrDeleteSubDirectory should be fatal. */ <br>            /* Don't ignore them, because if we do, then we will leave a */ <br>            /* corrupt message store behind. MAPI_E_HAS_MESSAGES can come */ <br>            /* back from below, as well as MAPI_E_SUBMITTED, etc. */ <br> <br>            if (hr != hrSuccess) <br>                goto exit; <br> <br>            /* Delete the other subdirectories */ <br>            hr = HrFindNextID(pifldToDelete, ulOffset, szRelativePath, <br>                hFindFile, &amp;ffd, &amp;peidSubDir); <br>        } <br>     <br>        if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>            hr = hrSuccess; <br>        else <br>            goto exit; <br>     <br>        /* end the search */ <br>        CloseIDSearch(&amp;hFindFile, &amp;szRelativePath); <br>    } <br> <br>    /* delete all messages if DEL_MESSAGES */ <br>    hr = HrCreateMessageList(pifldToDelete, &amp;lpMessages); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (lpMessages &amp;&amp; !(ulFlags &amp; DEL_MESSAGES)) <br>    { <br>        hr = ResultFromScode(MAPI_E_HAS_MESSAGES); <br>        goto exit; <br>    } <br> <br>    if (lpMessages) <br>    { <br>        hr = pifldToDelete-&gt;lpVtbl-&gt;DeleteMessages(pifldToDelete, <br>            lpMessages, 0L, NULL, 0L); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    UlRelease(pifldToDelete); <br>    pifldToDelete = NULL; <br> <br>    if (!fContentsOnly) <br>    { <br>        ULONG ulRowCount; <br>        LPMAPITABLE pmt; <br> <br>        /* delete the files on the filesystem */ <br>        hr = HrDestroyFolderStorage(szToDelete); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        ChangeTable(pims, pifldParent-&gt;peid, peidToDelete, MAPI_FOLDER, <br>            TABLE_ROW_DELETED, TRUE); <br> <br>        hr = pifldParent-&gt;lpVtbl-&gt;GetHierarchyTable(pifldParent, 0, &amp;pmt); <br> <br>        if (hr == hrSuccess) <br>        { <br>            hr = pmt-&gt;lpVtbl-&gt;GetRowCount(pmt, 0, &amp;ulRowCount); <br>            UlRelease(pmt); <br>        } <br> <br>        if (hr == hrSuccess &amp;&amp; ulRowCount == 0) <br>            hr = HrSetSubFolderProp(pifldParent, FALSE);         <br> <br>        /* Ignore errors changing and updating the hierarchy table. */ <br>        /* The entire delete shouldn't fail simply because we couldn't */ <br>        /* update the hierarchy table. */ <br> <br>        #ifdef DEBUG <br>        if (hr != hrSuccess) <br>        { <br>            TraceSz1("HrDeleteSubDirectory: Ignoring partial failure (%s)" <br>                " fixing hierarchy table.", SzDecodeScode(GetScode(hr))); <br>        } <br>        #endif <br> <br>        hr = hrSuccess; <br>    } <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    UlRelease(pifldToDelete); <br> <br>    LMFree(&amp;pims-&gt;lmr, peidSubDir); <br>    FreeNull(szToDelete); <br> <br>    CloseIDSearch(&amp;hFindFile, &amp;szRelativePath); <br> <br>    if (lpMessages) <br>        DestroyMessageList(&amp;pims-&gt;lmr, &amp;lpMessages); <br> <br>    DebugTraceResult(HrDeleteSubDirectory, hr); <br>    return hr; <br>} <br> <br>/* <br> -  HrCopyFolder <br> - <br> *  Purpose: <br> *      moves or copies one folder into another <br> * <br> *  Parameters <br> *      peidFldSrc      pointer to the entryid of the folder to copy or move. <br> *      pifldDst        the parent folder into which we copy or move <br> *      ulFlags         MAPI_MOVE, MAPI_NOREPLACE <br> *      ptagaExcl       List of properties to exclude from the copy. <br> * <br> *  Returns: <br> * <br> *  Errors: <br> */ <br>static HRESULT HrCopyFolder(PEID peidFldSrc, PIFLD pifldDstPar, ULONG ulFlags, <br>    LPSPropTagArray ptagaExcl) <br>{ <br>    HRESULT hr; <br>    PIFLD pifldSrc = NULL; <br> <br>    PIFLD pifldCopy = NULL;     /* copy of pifldSrc */ <br>    LPTSTR szComment = NULL;    /* comment for copy of pifldSrc */ <br>    PIMS pims = pifldDstPar-&gt;pims; <br>    ULONG ulObjType; <br>    LPSTR szNewFolderName; <br>    PIFLD pifldParent = NULL; </code></pre>
<p>
</p>
<pre><code>ULONG cValNC; <br>    LPSPropValue pvalNC = NULL; <br>    const static SizedSPropTagArray(2, sptaNC) = <br>    { <br>        2, <br>        { <br>            PR_DISPLAY_NAME, <br>            PR_COMMENT <br>        } <br>    }; <br> <br>    /* Open the source folder for modification only if we are moving */ <br> <br>    hr = pims-&gt;lpVtbl-&gt;OpenEntry(pims, CbEID(peidFldSrc), <br>        (LPENTRYID) peidFldSrc, NULL, (ulFlags &amp; MAPI_MOVE) ? MAPI_MODIFY : 0L, <br>        &amp;ulObjType, (LPUNKNOWN *) &amp;pifldSrc); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* if this is a move, make sure the source folder is not in use */ <br>    if ((ulFlags &amp; MAPI_MOVE) &amp;&amp; pifldSrc-&gt;cRef &gt; 1) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* get the name and comment from pifldSrc */ <br>    hr = pifldSrc-&gt;lpVtbl-&gt;GetProps(pifldSrc, <br>        (LPSPropTagArray) &amp;sptaNC, 0, /* ansi */ <br>        &amp;cValNC, &amp;pvalNC); <br>    if (hr != hrSuccess) <br>    { <br>        if (GetScode(hr) == MAPI_W_ERRORS_RETURNED) <br>        { <br>            if (PROP_TYPE(pvalNC-&gt;ulPropTag) == PT_ERROR) <br>            { <br>                hr = ResultFromScode(pvalNC-&gt;Value.err); <br>                goto exit; <br>            } <br> <br>            hr = hrSuccess; <br>        } <br>        else <br>            goto exit; <br>    } <br> <br>    /* create new folder for the copy */ <br>    szNewFolderName = pvalNC[0].Value.LPSZ; <br> <br>    if (PROP_TYPE(pvalNC[1].ulPropTag) != PT_ERROR) <br>        szComment = pvalNC[1].Value.LPSZ; <br>    else <br>        szComment = NULL; <br> <br>    hr = HrDuplicateIFLD(pifldSrc, pifldDstPar, szNewFolderName, szComment, <br>        &amp;pifldCopy); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* move or copy the interior of this folder (recursive) */ <br>    hr = HrCopyContents(pifldSrc, pifldCopy, ulFlags, ptagaExcl); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    UlRelease(pifldSrc); <br>    pifldSrc = NULL; <br> <br>    /* invalidate the source folder if this is a move */ <br>    if (ulFlags &amp; MAPI_MOVE) <br>    { <br>        LPMAPITABLE pmt; <br>        ULONG ulRowCount; <br>        LPTSTR szFullPathFolder; <br> <br>        hr = HrFullPathName(pims-&gt;szStorePath, <br>            peidFldSrc-&gt;szPath, NULL, &amp;szFullPathFolder); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        /* delete it */ <br>        hr = HrDestroyFolderStorage(szFullPathFolder); <br> <br>        FreeNull(szFullPathFolder); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        /* update the hierarchy table of the source's parent */ <br>        hr = HrOpenParent(pims, peidFldSrc, MAPI_MODIFY, &amp;pifldParent); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        ChangeTable(pims, pifldParent-&gt;peid, peidFldSrc, MAPI_FOLDER, <br>            TABLE_ROW_DELETED, TRUE); <br> <br>        hr = pifldParent-&gt;lpVtbl-&gt;GetHierarchyTable(pifldParent, 0, &amp;pmt); <br> <br>        if (hr == hrSuccess) <br>            hr = pmt-&gt;lpVtbl-&gt;GetRowCount(pmt, 0, &amp;ulRowCount); <br> <br>        UlRelease(pmt); <br> <br>        if (hr == hrSuccess &amp;&amp; ulRowCount == 0) <br>            hr = HrSetSubFolderProp(pifldParent, FALSE);         <br>    } <br> <br>exit: <br>    UlRelease(pifldSrc); <br> <br>    LMFree(&amp;pims-&gt;lmr, pvalNC); <br>    UlRelease(pifldParent); <br> <br>    UlRelease(pifldCopy); <br> <br>    DebugTraceResult(HrCopyFolder, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrCopyContents <br> * <br> *  Purpose         copy or move the contents of the source folder to <br> *                  the destination <br> * <br> *  Parameters <br> *      pifldSrc        source folder <br> *      pifldDst        destination folder <br> *      ulFlags         MAPI_MOVE, MAPI_NOREPLACE, MAPI_DIALOG <br> *      ptagaExcl       List of properties to exclude from the copy. <br> * <br> */ <br>static HRESULT HrCopyContents(PIFLD pifldSrc, PIFLD pifldDst, ULONG ulFlags, <br>    LPSPropTagArray ptagaExcl) <br>{ <br>    PEID peidNext = NULL;       /* eid of next folder to move */ <br>    ULONG ichLocal; <br>    PLMR plmr = &amp;pifldSrc-&gt;pims-&gt;lmr; <br> <br>    /* relative path name of next folder to be moved */ <br>    LPTSTR szFile = NULL; <br>    HANDLE hFindFile = FAILED_SEARCH; <br>    HRESULT hr = hrSuccess; <br>    ULONG ulMessageFlags = 0L;  /* flags for the message copy */ <br>    WIN32_FIND_DATA ffd; <br> <br>    /* move or copy each message inside the folder */ <br>    if (ulFlags &amp; MAPI_MOVE) <br>        ulMessageFlags = MESSAGE_MOVE; <br> <br>    if (!FContainsProp(PR_CONTAINER_CONTENTS, ptagaExcl)) <br>    { <br>        LPENTRYLIST lpMessages = NULL; <br> <br>        /* make a message list */ <br>        hr = HrCreateMessageList(pifldSrc, &amp;lpMessages); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        /* move/copy messages */ <br>        if (lpMessages) <br>        { <br>            hr = pifldSrc-&gt;lpVtbl-&gt;CopyMessages(pifldSrc, <br>                lpMessages, 0, (LPMAPIFOLDER) pifldDst, 0, <br>                NULL, ulMessageFlags); <br> <br>            DestroyMessageList(plmr, &amp;lpMessages); <br> <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br>    } <br> <br>    /* move/copy subfolders if required */ <br>    if ((ulFlags &amp; MAPI_MOVE) <br>        || (!FContainsProp(PR_CONTAINER_HIERARCHY, ptagaExcl))) <br>    { <br>        /* get the first entryID for a subfolder */ <br>        hr = HrFindFirstID(pifldSrc, szFolderTemplate, &amp;ichLocal, <br>            &amp;szFile, &amp;hFindFile, &amp;ffd, &amp;peidNext); <br> <br>        while (hr == hrSuccess) <br>        { <br>            /* copy the eid to the destination */ <br>            hr = HrCopyFolder(peidNext, pifldDst, ulFlags, ptagaExcl); <br>            if (hr != hrSuccess) <br>                goto exit; <br> <br>            LMFree(plmr, peidNext); <br>            peidNext = NULL; <br> <br>            if (ulFlags &amp; MAPI_MOVE) <br>            { <br>                /* The folder should have been destroyed; therefore, */ <br>                /* start the search again. */ <br> <br>                CloseIDSearch(&amp;hFindFile, &amp;szFile); <br> <br>                hr = HrFindFirstID(pifldSrc, szFolderTemplate, &amp;ichLocal, <br>                    &amp;szFile, &amp;hFindFile, &amp;ffd, &amp;peidNext); <br>            } <br>            else <br>                hr = HrFindNextID(pifldSrc, ichLocal, szFile, <br>                    hFindFile, &amp;ffd, &amp;peidNext); <br>        } <br> <br>        if (GetScode(hr) != MAPI_E_NOT_FOUND) <br>            goto exit;          /* uh oh.  got a real error */ <br> <br>        hr = hrSuccess; <br>    } <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No warning expected"); <br> <br>    /* close the search */ <br>    CloseIDSearch(&amp;hFindFile, &amp;szFile); <br>    LMFree(plmr, peidNext); <br> <br>    DebugTraceResult(HrCopyContents, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrEIDFromDisplayName <br> * <br> *  Purpose <br> *      Searches the table given, looking for a matching PR_DISPLAY_NAME. <br> *      If found, the routine returns the value of the corresponding <br> *      PR_ENTRYID column, converted to an internal PEID. If not found, the <br> *      routine returns a NULL. <br> * <br> *  Parameters <br> *      pmt: The IMAPITable object to search for the display name. <br> *      szName: The display name to search for. <br> *      plmr: A pointer to the linked memory routines to allow freeing memory. <br> *      ppeid: A pointer to the location to return the internal entryid of <br> *          the PR_ENTRYID column that corresponds to the matching display <br> *          name. If no matching display name was found, the routine returns <br> *          NULL in this location. <br> *   <br> */ <br>static HRESULT HrEIDFromDisplayName(LPMAPITABLE pmt, LPSTR szName, PLMR plmr, <br>    PEID *ppeid) <br>{ <br>    HRESULT hr; <br>    LPSRowSet prws = NULL; <br>    PEID peid = NULL; <br> <br>    SizedSPropTagArray(2, spta) = <br>    { <br>        2, <br>        { <br>            PR_ENTRYID, <br>            PR_DISPLAY_NAME <br>        } <br>    }; <br> <br>    hr = pmt-&gt;lpVtbl-&gt;SetColumns(pmt, (LPSPropTagArray) &amp;spta, 0); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pmt-&gt;lpVtbl-&gt;SeekRow(pmt, BOOKMARK_BEGINNING, 0, NULL); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    while (TRUE) <br>    { <br>        LPSTR szCurName; <br>        LPSPropValue pval; <br> <br>        hr = pmt-&gt;lpVtbl-&gt;QueryRows(pmt, 1, 0, &amp;prws); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (prws-&gt;cRows == 0) <br>            break; <br> <br>        Assert(prws); <br>        Assert(prws-&gt;cRows == 1); <br>        Assert(prws-&gt;aRow[0].lpProps); <br>        Assert(prws-&gt;aRow[0].lpProps[0].ulPropTag == PR_ENTRYID); <br>        Assert(prws-&gt;aRow[0].lpProps[1].ulPropTag == PR_DISPLAY_NAME); <br> <br>        pval = prws-&gt;aRow[0].lpProps; <br> <br>        szCurName = (LPSTR) pval[1].Value.lpszA; <br> <br>        if (lstrcmpi(szName, szCurName) == 0) <br>        { <br>            SCODE sc; <br>            PEID peidTemp = (PEID) pval-&gt;Value.bin.lpb; <br>            UINT cbEID = (UINT) pval-&gt;Value.bin.cb; <br> <br>            sc = LMAlloc(plmr, cbEID, &amp;peid); <br>            if (sc != S_OK) <br>            { <br>                hr = ResultFromScode(sc); <br>                goto exit; <br>            } <br> <br>            if (cbEID) <br>                memcpy(peid, peidTemp, cbEID); <br> <br>            break; <br>        } <br> <br>        FreeProws(prws); <br>        prws = NULL; <br>    } <br> <br>exit: <br>    if (prws) <br>    { <br>        if (prws-&gt;cRows &amp;&amp; prws-&gt;aRow[0].lpProps) <br>            LMFree(plmr, prws-&gt;aRow[0].lpProps); <br> <br>        LMFree(plmr, prws); <br>    } <br> <br>    if (hr == hrSuccess) <br>    { <br>        AssertSz(!IsBadWritePtr(ppeid, sizeof(PEID)), "Bad parameter (ppeid) " <br>            "passed to HrEIDFromDisplayName"); <br>        *ppeid = peid; <br>    } <br> <br>    DebugTraceResult(HrEIDFromDisplayName, hr); <br>    return hr; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
