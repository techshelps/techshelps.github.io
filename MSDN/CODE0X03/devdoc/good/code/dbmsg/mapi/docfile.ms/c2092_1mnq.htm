<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPOBJ.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2096"></a>MSPOBJ.C</h2>
<pre><code>/* <br> * M S P O B J . C <br> * <br> * Common code for implementation of objects in the sample message store <br> * provider. <br> * <br> * Copyright (C) 1992-1995 Microsoft Corporation. All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br> <br>/* Object Type to Neuter Function Map -------------------------------------- */ <br> <br>LPFNNEUTER rgfnNeuter[] = <br>{ <br>    (LPFNNEUTER) 0,             /* IMSProvider */ <br>    (LPFNNEUTER) 0,             /* IMSLogon */ <br>    (LPFNNEUTER) IMS_Neuter,    /* IMsgStore */ <br>    (LPFNNEUTER) IFLD_Neuter,   /* IMAPIFolder */ <br>    (LPFNNEUTER) IMSG_Neuter,   /* IMessage */ <br>    (LPFNNEUTER) IATCH_Neuter,  /* IAttach */ <br>    (LPFNNEUTER) 0,             /* IStream */ <br>    (LPFNNEUTER) 0,             /* IMAPITable */ <br>}; <br> <br>/* Object Type to Interfaces Supported Map --------------------------------- */ <br> <br>REFIID MSP_IIDs[] = <br>{ <br>    &amp;IID_IMSProvider, <br>    &amp;IID_IUnknown <br>}; <br> <br>REFIID MSL_IIDs[] = <br>{ <br>    &amp;IID_IMSLogon, <br>    &amp;IID_IUnknown <br>}; <br> <br>REFIID MS_IIDs[] = <br>{ <br>    &amp;IID_IMsgStore, <br>    &amp;IID_IMAPIProp, <br>    &amp;IID_IUnknown <br>}; <br> <br>REFIID FLD_IIDs[] = <br>{ <br>    &amp;IID_IMAPIFolder, <br>    &amp;IID_IMAPIContainer, <br>    &amp;IID_IMAPIProp, <br>    &amp;IID_IUnknown <br>}; <br> <br>REFIID MSG_IIDs[] = <br>{ <br>    &amp;IID_IMessage, <br>    &amp;IID_IMAPIProp, <br>    &amp;IID_IUnknown <br>}; <br> <br>REFIID ATCH_IIDs[] = <br>{ <br>    &amp;IID_IAttachment, <br>    &amp;IID_IMAPIProp, <br>    &amp;IID_IUnknown <br>}; <br> <br>REFIID STM_IIDs[] = <br>{ <br>    &amp;IID_IStream, <br>    &amp;IID_IUnknown <br>}; <br> <br>REFIID TBL_IIDs[] = <br>{ <br>    &amp;IID_IMAPITable, <br>    &amp;IID_IUnknown <br>}; <br> <br>REFIID *rgpriid[] = <br>{ <br>    MSP_IIDs, <br>    MSL_IIDs, <br>    MS_IIDs, <br>    FLD_IIDs, <br>    MSG_IIDs, <br>    ATCH_IIDs, <br>    STM_IIDs, <br>    TBL_IIDs <br>}; <br> <br>#define OBJ_IsInvalid(pobj, f)                                  \ <br>    (IsBadWritePtr(pobj, sizeof(OBJ))                           \ <br>    || IsBadReadPtr((pobj)-&gt;lpVtbl, sizeof(OBJ_Vtbl))           \ <br>    || (pobj)-&gt;lpVtbl-&gt;f != OBJ_##f                             \ <br>    || (pobj)-&gt;wType &gt;= OT_MAX) <br> <br>/* OBJ_QueryInterface ------------------------------------------------------ */ <br> <br>BOOL  <br>FQueryInterface(int wType, REFIID riid) <br>{ <br>    REFIID *priid = rgpriid[wType]; <br> <br>    while (1) <br>    { <br>        if (IsEqualGUID(riid, *priid)) <br>            return (TRUE); <br> <br>        if (*priid == &amp;IID_IUnknown) <br>            break; <br> <br>        priid += 1; <br>    } <br> <br>    return (FALSE); <br>} <br> <br>STDMETHODIMP  <br>OBJ_QueryInterface(POBJ pobj, REFIID riid, LPVOID * ppvObj) <br>{ <br>    if (    OBJ_IsInvalid(pobj, QueryInterface) <br>        ||  IsBadReadPtr(riid, sizeof(IID)) <br>        ||  IsBadWritePtr(ppvObj, sizeof(LPVOID))) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    /* Even if an error is returned, must zero *ppvObj */ <br>    *ppvObj = 0; <br> <br>    if (FQueryInterface(pobj-&gt;wType, riid)) <br>    { <br>        UlAddRef(pobj); <br>        *ppvObj = pobj; <br>        return (0); <br>    } <br> <br>    return (ResultFromScode(E_NOINTERFACE)); <br>} <br> <br>/* OBJ_AddRef -------------------------------------------------------------- */ <br> <br>STDMETHODIMP_(ULONG) OBJ_AddRef(POBJ pobj) <br>{ <br>    LONG cRef; <br> <br>    if (OBJ_IsInvalid(pobj, AddRef)) <br>    { <br>        TraceSz1("Sample MS: OBJ_AddRef(pobj=%08lX): Object is invalid and " <br>            "is being ignored", pobj); <br>        return (0); <br>    } <br> <br>    OBJ_EnterCriticalSection(pobj); <br> <br>#ifdef DEBUG <br>    if (pobj-&gt;wType == OT_MSGSTORE) <br>        Assert(!OBJ_TestFlag(pobj, MSF_BEINGDESTROYED)); <br>#endif <br> <br>    AssertSz1(      pobj-&gt;wType == OT_MSGSTORE <br>              ||    pobj-&gt;cRef &gt;= 1, "OBJ_AddRef(): Bogus cRef (%08lX)", pobj-&gt;cRef); <br> <br>    cRef = ++pobj-&gt;cRef; <br> <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    return (cRef); <br>} <br> <br>/* OBJ_Release ------------------------------------------------------------- */ <br> <br>/* Used by Message Store, Message, and Attachment objects. All other objects */ <br>/* have their own implementations of Release. */ <br> <br>STDMETHODIMP_(ULONG) OBJ_Release(POBJ pobj) <br>{ <br>    LONG cRef; <br> <br>    if (!pobj) <br>        return (0); <br> <br>    if (OBJ_IsInvalid(pobj, Release)) <br>    { <br>        TraceSz1("SampleMS: OBJ_Release(pobj=%08lX): Object is invalid and is " <br>            "being ignored", pobj); <br>        return (0); <br>    } <br> <br>    OBJ_EnterCriticalSection(pobj); <br> <br>    AssertSz(pobj-&gt;cRef &gt; 0, "OBJ_Release(): Too many releases"); <br> <br>    cRef = --pobj-&gt;cRef; <br> <br>    if (cRef == 0) <br>    { <br>        if (pobj-&gt;wType != OT_MSGSTORE) <br>            pobj-&gt;lpVtbl = 0; <br> <br>        if (pobj-&gt;pobjHead == 0) <br>        { <br>            OBJ_Destroy(pobj); <br>            return (0); <br>        } <br>    } <br> <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    return (cRef); <br>} <br> <br>/* OBJ_Enqueue / OBJ_Dequeue / OBJ_Destroy --------------------------------- */ <br> <br>void OBJ_Enqueue(POBJ pobj, POBJ pobjParent) <br>{ <br>    pobj-&gt;pobjParent = pobjParent; <br>    pobj-&gt;pobjNext = pobjParent-&gt;pobjHead; <br>    pobjParent-&gt;pobjHead = pobj; <br>} <br> <br>void OBJ_Dequeue(POBJ pobj) <br>{ <br>    if (pobj-&gt;pobjParent != NULL) <br>    { <br>        POBJ *ppobj = &amp;pobj-&gt;pobjParent-&gt;pobjHead; <br> <br>        while (TRUE) <br>        { <br>            POBJ pobjCur = *ppobj; <br> <br>            if (pobjCur == NULL) <br>                break; <br> <br>            if (pobjCur == pobj) <br>            { <br>                *ppobj = pobj-&gt;pobjNext; <br>                break; <br>            } <br> <br>            ppobj = &amp;pobjCur-&gt;pobjNext; <br>        } <br> <br>        pobj-&gt;pobjParent = 0; <br>    } <br>} <br> <br>/*  <br> * OBJ_Destroy <br> *  <br> * Destroy an object. If this object was the last thing causing the parent to <br> * exist, then we should destroy the parent, and so on up the chain. There are <br> * two actual critical sections in the sample store. One is in the msp (message <br> * store provider) object. The other is in the msl (message store logon) object. <br> * All other objects in the sample store contain a pointer to the msl object's  <br> * critical section (they all share it). When we arrive at this routine, we  <br> * should have the object's critical section locked, i.e., the msl critical <br> * section should be locked. That's why there are calls to leave a critical <br> * section that aren't balanced with an enter. <br> */ <br> <br>void OBJ_Destroy(POBJ pobj) <br>{ <br>    PIMS pims; <br>    POBJ pobjParent; <br>    LPFNNEUTER lpfnNeuter; <br>    LPMAPISUP psup; <br> <br>    pims = pobj-&gt;pims; <br> <br>    while (1) <br>    { <br>        /* Call a routine to make the object free any memory */ <br>        /* or other structures it has. (We call this "neutering" the object.) */ <br> <br>        if ((lpfnNeuter = rgfnNeuter[pobj-&gt;wType]) != 0) <br>            lpfnNeuter(pobj); <br> <br>        pobjParent = pobj-&gt;pobjParent; <br> <br>        if (pobj == (POBJ) pims) <br>        { <br>            if (pobjParent != NULL) <br>            { <br>                /* The parent in this case is the msp (message store provider) */ <br>                /* object. We need to get its critical section in order to */ <br>                /* safely dequeue the message store object. */ <br> <br>                OBJ_EnterCriticalSection(pobjParent); <br>                OBJ_Dequeue(pobj); <br>                OBJ_LeaveCriticalSection(pobjParent); <br>            } <br> <br>            pobjParent = (POBJ) pims-&gt;pmsl; <br>            psup = pims-&gt;psup; <br> <br>            pobj-&gt;lpVtbl = 0; <br>            LMFree(&amp;pims-&gt;lmr, pobj); <br> <br>            /* This leave balances the enter in the calling function. */ <br>            /* Since we just freed the message store object, we can't leave */ <br>            /* critical section using that pointer. Therefore, use the msl */ <br>            /* (message store logon) object's critical section instead. They */ <br>            /* are the same (see header comment at top of function). */ <br> <br>            OBJ_LeaveCriticalSection(pobjParent); <br> <br>            UlRelease(psup);    /* do this last */ <br>            break; <br>        } <br> <br>        OBJ_Dequeue(pobj); <br> <br>        pobj-&gt;lpVtbl = 0; <br>        LMFree(&amp;pims-&gt;lmr, pobj); <br> <br>        pobj = pobjParent; <br> <br>        if (pobj == 0 || pobj-&gt;cRef || pobj-&gt;pobjHead) <br>        { <br>            /* This leave balances the enter in the calling function. */ <br> <br>            OBJ_LeaveCriticalSection((POBJ) pims); <br>            break; <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
