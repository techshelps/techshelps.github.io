<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPTBL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2099"></a>MSPTBL.C</h2>
<pre><code>/* <br> *  M S P T B L . C <br> * <br> *  Functions to manage a hierarchy and contents tables cached on disk. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br> <br>static SCODE ScCreateFile(LPTSTR szFile, ULONG ulAccess, ULONG ulShare, <br>    ULONG ulCreate, HANDLE * lphFile); <br>static HRESULT HrOpenTblFileRetry(LPTSTR szFile, ULONG ulAccess, ULONG ulShare, <br>    ULONG ulCreate, HANDLE * lphFile); <br>static HRESULT HrNewCounts(PIFLD pifld, LPTABLEDATA lptbl); <br>static HRESULT HrReadBytes(HANDLE hFile, LPVOID lpBuffer, ULONG cbToRead, <br>    BOOL * pfEOF); <br>static HRESULT HrWriteBytes(HANDLE hFile, LPVOID lpBuffer, ULONG cbToWrite); <br>static HRESULT HrWriteRow(HANDLE hFile, LPSRow prw); <br>static VOID TranslateFileError(BOOL fSuccess, ULONG cbIn, ULONG cbOut, <br>    BOOL * pfEOF, SCODE * pscFile); <br>static HRESULT HrGetTime(LPSRow prw, FILETIME * pfiletime); <br>static HRESULT HrRemoveBadTableRows(LPTABLEDATA lptbl, PIFLD pifldParent, <br>    PIMS pims, BOOL * pfTableChanged); <br>static HRESULT HrAddMissingTableRows(LPTABLEDATA lptbl, PIFLD pifld, <br>    LPSTR szTemplate, LPSPropTagArray ptaga, BOOL * pfTableChanged); <br> <br> <br> <br>/* format of a row of table data on disk (DRW) */ <br>typedef struct _DRW <br>{ <br>    ULONG   cbRow; <br>    SRow    rw; <br>    BYTE    ab[MAPI_DIM]; <br>} DRW, *PDRW; <br> <br>#define CbNewDRW(_cb)       (offsetof(DRW,ab) + (_cb)) <br>#define CbDRW(_pdrw)        (offsetof(DRW,ab) + (UINT)((_pdrw)-&gt;cbRow)) <br> <br> <br>/**************************************************************************** <br> * ScCreateFile <br> * <br> * Purpose      Open or create a file <br> * <br> * Parameters <br> *  szFile          name of the file <br> *  ulAccess        read/write access desired see CreateFile <br> *  ulShare         sharing desired see CreateFile <br> *  ulCreate        creation disposition see CreateFile <br> *  lphFile         returns handle of open file, undefined if call fails <br> * <br> */ <br>static SCODE  <br>ScCreateFile(LPTSTR szFile, ULONG ulAccess, ULONG ulShare, <br>    ULONG ulCreate, HANDLE * lphFile) <br>{ <br>    HANDLE hFile; <br>    SCODE sc = S_OK; <br> <br>    hFile = CreateFile(szFile, ulAccess, ulShare, NULL, <br>        ulCreate, FILE_FLAG_SEQUENTIAL_SCAN, NULL); <br> <br>    if (hFile == INVALID_HANDLE_VALUE) <br>    { <br>        switch (GetLastError()) <br>        { <br>        case ERROR_FILE_NOT_FOUND: <br>            sc = MAPI_E_NOT_FOUND; <br>            break; <br> <br>        case ERROR_SHARING_VIOLATION: <br>        case ERROR_LOCK_VIOLATION: <br>            sc = MAPI_E_BUSY; <br>            break; <br> <br>        default: <br>            sc = MAPI_E_NO_ACCESS; <br>            break; <br>        } <br>    } <br>    else <br>    { <br>        AssertSz(!IsBadWritePtr(lphFile, sizeof(HANDLE)), "Bad parameter" <br>            " (lphFile) given to ScCreateFile"); <br> <br>        *lphFile = hFile; <br>    } <br> <br>    DebugTraceSc(ScCreateFile, sc); <br>    return sc; <br>} <br> <br>/* <br> * HrOpenTblFileRetry <br> * <br> * Purpose      Open or create a file, but retry if it is busy <br> * <br> * Parameters <br> *  szFile          name of the file <br> *  ulAccess        read/write access desired see CreateFile <br> *  ulShare         sharing desired see CreateFile <br> *  ulCreate        creation disposition see CreateFile <br> *  lphFile         returns handle of open file, undefined if call fails <br> * <br> */ <br>static HRESULT HrOpenTblFileRetry(LPTSTR szFile, ULONG ulAccess, ULONG ulShare, <br>    ULONG ulCreate, HANDLE * lphFile) <br>{ <br>    UINT iRetry; <br>    SCODE sc = S_OK; <br>    HANDLE hFile; <br> <br>    iRetry = 0; <br>    while (TRUE) <br>    { <br>        sc = ScCreateFile(szFile, ulAccess, ulShare, ulCreate, &amp;hFile); <br> <br>        if (sc != MAPI_E_BUSY || ++iRetry &gt;= NUM_RETRIES) <br>            break; <br> <br>        Sleep(500); <br>    } <br> <br>    if (sc == S_OK) <br>        *lphFile = hFile; <br> <br>    #ifdef DEBUG <br>    if (iRetry &gt;= NUM_RETRIES) <br>        TraceSz("HrOpenTblFileRetry: Failing open. Too many tries."); <br>    #endif <br> <br>    DebugTraceSc(HrOpenTblFileRetry, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> * HrWriteCounts <br> * <br> *  Purpose <br> *      This function writes the counts of messages and unread messages <br> *      in a folder to the folder's property file. After the code  <br> *      validates what the counts should be, this function writes the <br> *      counts so that they are correct. <br> * <br> *  Parameters <br> *      pifld: A pointer to the folder object to update. <br> *      ulMsgs: The number of messages in the folder. <br> *      ulUnread: The number of unread messages in the folder. <br> * <br> */ <br>static HRESULT HrWriteCounts(PIFLD pifld, ULONG ulMsgs, ULONG ulUnread) <br>{ <br>    HRESULT hr; <br>    LPMESSAGE lpmsg = NULL; <br>    PLMR plmr = &amp;pifld-&gt;pims-&gt;lmr; <br>    ULONG ulMsgsCopy = ulMsgs;      /* workaround - MS C code-gen bug */ <br> <br>    hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrSetOneROProp(lpmsg, plmr, PR_CONTENT_COUNT, &amp;ulMsgsCopy); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrSetOneROProp(lpmsg, plmr, PR_CONTENT_UNREAD, &amp;ulUnread); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, FORCE_SAVE); <br> <br>exit: <br>    UlRelease(lpmsg); <br> <br>    DebugTraceResult(HrWriteCounts, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrNewCounts <br> * <br> * Purpose  Make the contents count and unread count of the folder in pifld <br> *          agree with the data in the contents table lptbl <br> * <br> * Parameters <br> *      pifld       the folder <br> *      lptbl       the table <br> */ <br>static HRESULT HrNewCounts(PIFLD pifld, LPTABLEDATA lptbl) <br>{ <br>    HRESULT hr = hrSuccess; <br>    ULONG cMessages = 0; <br>    ULONG cUnread = 0; <br>    LPSRow lpsRow = NULL; <br>    ULONG ulRow = 0; <br>    PLMR plmr = &amp;pifld-&gt;pims-&gt;lmr; <br>    LPMESSAGE lpmsg = NULL; <br> <br>    /* check each row in the table to see if the message has been read */ <br> <br>    while (TRUE) <br>    { <br>        LPSPropValue pval; <br>        LPSPropValue pvalMax; <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;HrEnumRow(lptbl, ulRow++, &amp;lpsRow); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (lpsRow == NULL) <br>            break; <br> <br>        cMessages++; <br> <br>        pval = lpsRow-&gt;lpProps; <br>        pvalMax = pval + lpsRow-&gt;cValues; <br> <br>        /* check PR_MESSAGE_FLAGS to see if this message is unread */ <br>        while (pval &lt; pvalMax) <br>        { <br>            if (pval-&gt;ulPropTag == PR_MESSAGE_FLAGS) <br>            { <br>                if (!(pval-&gt;Value.l &amp; MSGFLAG_READ)) <br>                    cUnread++; <br>                break; <br>            } <br>            pval++; <br>        } <br> <br>        LMFree(&amp;pifld-&gt;pims-&gt;lmr, lpsRow); <br>        lpsRow = NULL; <br>    } <br> <br>    hr = HrWriteCounts(pifld, cMessages, cUnread); <br> <br>exit: <br>    LMFree(&amp;pifld-&gt;pims-&gt;lmr, lpsRow); <br> <br>    DebugTraceResult(HrNewCounts, hr); <br>    return hr; <br>} <br> <br>/********************************************************************** <br> * HrGetTableName <br> * <br> * Purpose <br> *      Given an open object and the kind of table <br> *      returns the full path name of the file that caches that table's data. <br> *      Must be freed with FreeNull. <br> * <br> * Parameters <br> *  pobj        object whose table is needed <br> *  szEIDPath   EID path (may be NULL) <br> *  szFileName  Name of the file that holds the table. <br> *  lppszTable  pointer to storage for the path name of the table file <br> */ <br>HRESULT HrGetTableName(POBJ pobj, LPSTR szEIDPath, LPSTR szFileName, <br>    LPSTR *pszTable) <br>{ <br>    LPTSTR szDir = NULL;        /* Full Path name of directory containing table */ <br>    HRESULT hr = hrSuccess; <br>    PIMS pims = pobj-&gt;pims; <br> <br>    Assert(!IsBadWritePtr(pszTable, sizeof(LPTSTR))); <br> <br>    hr = HrFullPathName(pims-&gt;szStorePath, szEIDPath, NULL, &amp;szDir); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* get memory to hold the filename that contains the table. */ <br>    /* Add 1 char for the backslash before the filename. */ <br> <br>    hr = HrAlloc(CCH_NAME * sizeof(TCHAR) <br>        + ((lstrlen(szDir) + 1) * sizeof(TCHAR)), (PPV) pszTable); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    lstrcpy(*pszTable, szDir); <br>    lstrcat(*pszTable, "\\"); <br>    lstrcat(*pszTable, szFileName); <br> <br>exit: <br>    FreeNull(szDir); <br>    DebugTraceResult(HrGetTableName, hr); <br>    return hr; <br>} <br> <br>/********************************************************************** <br> * HrReadBytes <br> * <br> * Read a number of bytes from a file into a buffer, checking for errors and <br> * end-of-file. <br> * <br> * Parameters: <br> * <br> * hFile:       File handle to read from. <br> * lpBuffer:    Pointer to a buffer to read into. The buffer should be big <br> *              enough to hold the incoming data. <br> * cbToRead:    The number of bytes to read. Should be &lt;= UINT_MAX. <br> * pfEOF:       A pointer to the location to return a boolean specifying <br> *              whether the read encountered an end-of-file. If it did, the <br> *              buffer will return with no data in it. This pointer may be NULL, <br> *              in which case end-of-file will be treated as an error. <br> * <br> * Returns: <br> *  HRESULT     (either a file read error, or MAPI_E_CALL_FAILED when either <br> *              EOF is encountered and pfEOF is NULL, or when the number of <br> *              bytes read is less than the number requested). <br> */ <br>static HRESULT HrReadBytes(HANDLE hFile, LPVOID lpBuffer, ULONG cbToRead, <br>    BOOL *pfEOF) <br>{ <br>    SCODE sc = S_OK; <br>    ULONG cbRead = 0; <br>    BOOL fSuccess; <br> <br>    AssertSz(cbToRead &lt;= UINT_MAX &amp;&amp; !IsBadWritePtr(lpBuffer, (UINT) cbToRead), <br>        "Bad buffer"); <br> <br>    fSuccess = ReadFile(hFile, lpBuffer, cbToRead, &amp;cbRead, NULL); <br> <br>    TranslateFileError(fSuccess, cbToRead, cbRead, pfEOF, &amp;sc); <br> <br>    DebugTraceSc(HrReadBytes, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/********************************************************************** <br> * HrWriteBytes <br> * <br> * Write a number of bytes from a buffer into a file, checking for errors. <br> * <br> * Parameters: <br> * <br> * hFile:       File handle to write into. <br> * lpBuffer:    Pointer to a buffer containing the data to write. <br> * cbToRead:    The number of bytes to write. Should be &lt;= UINT_MAX. <br> * <br> * Returns: <br> *  HRESULT     (either a file write error, or MAPI_E_CALL_FAILED when the <br> *              number of bytes written is less than the number requested). <br> */ <br>static HRESULT HrWriteBytes(HANDLE hFile, LPVOID lpBuffer, ULONG cbToWrite) <br>{ <br>    SCODE sc = S_OK; <br>    ULONG cbWritten = 0; <br>    BOOL fSuccess; <br> <br>    AssertSz(cbToWrite &lt;= UINT_MAX &amp;&amp; !IsBadReadPtr(lpBuffer, (UINT) cbToWrite), <br>        "Bad buffer"); <br> <br>    fSuccess = WriteFile(hFile, lpBuffer, cbToWrite, &amp;cbWritten, NULL); <br> <br>    TranslateFileError(fSuccess, cbToWrite, cbWritten, NULL, &amp;sc); <br> <br>    DebugTraceSc(HrWriteBytes, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/********************************************************************** <br> * TranslateFileError <br> * <br> * Checks for errors from a windows ReadFile or WriteFile call, translating <br> * windows error codes to MAPI errors, and, if requested, checking for end-of- <br> * file. Also checks to make sure the number of bytes read or written equals <br> * the number given as input. <br> * <br> * Parameters: <br> * <br> * fSuccess:    The return value from ReadFile or WriteFile. <br> * cbIn:        The number of bytes given as input to ReadFile or WriteFile. <br> * cbOut:       The number of bytes returned from ReadFile or WriteFile. <br> * pfEOF:       A pointer to the location to return a BOOL specifying <br> *              whether cbOut was 0 and fSuccess was TRUE. This condition <br> *              indicates end-of-file when reading, and should not be treated <br> *              as an error. The pointer may be NULL, in which case, this <br> *              condition is treated as an error, and *psc is returned with <br> *              MAPI_E_CALL_FAILED. <br> * psc:         A pointer to the location to return an SCODE indicating <br> *              the success or failure of the ReadFile or WriteFile. <br> * <br> * Returns: VOID <br> */ <br>static VOID TranslateFileError(BOOL fSuccess, ULONG cbIn, ULONG cbOut, <br>    BOOL *pfEOF, SCODE *pscFile) <br>{ <br>    SCODE sc = S_OK; <br>    BOOL fEOF = FALSE; <br>    BOOL fCheckEOF = (pfEOF != NULL); <br> <br>    if (!fSuccess) <br>    { <br>        DWORD dwError = GetLastError(); <br> <br>        if (dwError != 0) <br> <br>            switch (dwError) <br>            { <br>            case 0: <br>                TraceSz("SampleMS: ScTranslateFileError found unexpected " <br>                    "success\n"); <br>                break; <br> <br>            case ERROR_SHARING_VIOLATION: <br>            case ERROR_LOCK_VIOLATION: <br>                sc = MAPI_E_BUSY; <br>                break; <br> <br>            case ERROR_FILE_NOT_FOUND: <br>                sc = MAPI_E_NOT_FOUND; <br>                break; <br> <br>            case ERROR_TOO_MANY_OPEN_FILES: <br>                sc = MAPI_E_NOT_ENOUGH_RESOURCES; <br>                break; <br> <br>            case ERROR_ACCESS_DENIED: <br>            case ERROR_INVALID_ACCESS: <br>            case ERROR_INVALID_DRIVE: <br>                sc = MAPI_E_NO_ACCESS; <br>                break; <br> <br>            default: <br>                sc = MAPI_E_CALL_FAILED; <br>                break; <br>            } <br>    } <br>    else if (cbOut != cbIn) <br>    { <br>        sc = MAPI_E_CALL_FAILED; <br> <br>        /* If the caller wants to discriminate end-of-file from other */ <br>        /* errors, and the file call returned zero bytes, return EOF, */ <br>        /* and don't return an error. */ <br> <br>        if (fCheckEOF &amp;&amp; cbOut == 0) <br>        { <br>            sc = S_OK; <br>            fEOF = TRUE; <br>        } <br>    } <br> <br>    AssertSz(!IsBadWritePtr(pscFile, sizeof(SCODE)), "Bad parameter (pscFile) " <br>        "given to TranslateFileError"); <br> <br>    *pscFile = sc; <br> <br>    if (pfEOF) <br>    { <br>        AssertSz(!IsBadWritePtr(pfEOF, sizeof(BOOL)), "Bad parameter (pfEOF) " <br>            "given to TranslateFileError"); <br>        *pfEOF = fEOF; <br>    } <br> <br>    return; <br>} <br> <br>/* <br> * HrWriteRow <br> * <br> *  Purpose <br> *      Writes one row of data to the file handle given. <br> * <br> *  Arguments <br> *      hFile: File handle to update. <br> *      prw: Pointer to the row to write. <br> * <br> *  RETURNS: HRESULT <br> */ <br>static HRESULT HrWriteRow(HANDLE hFile, LPSRow prw) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc; <br>    ULONG cb; <br>    PDRW pdrw = NULL; <br> <br>    sc = ScCountProps((UINT) prw-&gt;cValues, prw-&gt;lpProps, &amp;cb); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    /* Allocate space for the disk row */ <br>    hr = HrAlloc(CbNewDRW(cb), &amp;pdrw); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* fill in the disk row structure */ <br> <br>    pdrw-&gt;cbRow = cb; <br>    pdrw-&gt;rw.cValues = prw-&gt;cValues; <br> <br>    /* The lpProps field of the row we write should be point at the */ <br>    /* row we are writing (i.e., pdrw-&gt;ab). We will use that pointer */ <br>    /* value when we read the data off disk to fixup the pointers via */ <br>    /* ScRelocProps. */ <br>    pdrw-&gt;rw.lpProps = (LPSPropValue) pdrw-&gt;ab; <br> <br>    sc = ScCopyProps((UINT) prw-&gt;cValues, prw-&gt;lpProps, &amp;(pdrw-&gt;ab), NULL); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    /* write the row */ <br>    hr = HrWriteBytes(hFile, pdrw, CbDRW(pdrw)); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>exit: <br>    FreeNull(pdrw); <br>     <br>    DebugTraceResult(HrWriteRow, hr); <br>    return hr; <br>} <br> <br>/************************************************************************* <br> * HrWriteTableOnDisk <br> * <br> * Purpose <br> *      write the table in lptbl to the disk image of lpvObjects table <br> *      of type ulType <br> * <br> *  lptbl       Table to be written <br> *  pobj        object whose table is to be written <br> *  szEIDPath   Pathname of the EID of the folder, or NULL <br> *  szFileName  Name of the file that holds this table type. <br> * <br> */ <br>HRESULT HrWriteTableOnDisk(LPTABLEDATA lptbl, POBJ pobj, LPSTR szEIDPath, <br>    LPSTR szFileName) <br>{ <br>    LPTSTR szFile = NULL; <br>    HANDLE hFile = INVALID_HANDLE_VALUE; /* handle to open file */ <br>    LPSRow lpsRow = NULL;               /* next row to be written */ <br>    ULONG ulRowNumber;          /* number of the row being written */ <br>    HRESULT hr = hrSuccess; <br>    PLMR plmr = &amp;pobj-&gt;pims-&gt;lmr; <br> <br>    /* get the name of the file holding the table */ <br>    hr = HrGetTableName(pobj, szEIDPath, szFileName, &amp;szFile); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* open the file with exclusive access */ <br> <br>    hr = HrOpenTblFileRetry(szFile, GENERIC_WRITE, 0L, CREATE_ALWAYS, &amp;hFile); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* write the table data to the file */ <br>    ulRowNumber = 0; <br>    while (TRUE) <br>    { <br>        hr = lptbl-&gt;lpVtbl-&gt;HrEnumRow(lptbl, ulRowNumber, &amp;lpsRow); <br>        if (hr != hrSuccess) <br>            goto exit; <br>        if (lpsRow == NULL) <br>            break; <br> <br>        hr = HrWriteRow(hFile, lpsRow); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        LMFree(plmr, lpsRow); <br>        lpsRow = NULL; <br>        ulRowNumber++; <br>    } <br> <br>exit: <br>    AssertSz(GetScode(hr) != MAPI_W_ERRORS_RETURNED, <br>        "Unexpected warning return"); <br> <br>    /* Set the end of file marker, in case we shrank the file. */ <br>    if (hr == hrSuccess &amp;&amp; SetEndOfFile(hFile) == FALSE) <br>        hr = ResultFromScode(MAPI_E_DISK_ERROR); <br> <br>    if (hFile != INVALID_HANDLE_VALUE) <br>        CloseHandle(hFile); <br> <br>    /* erase the file if in error */ <br>    if (hr != hrSuccess &amp;&amp; szFile) <br>        DeleteFile(szFile); <br> <br>    FreeNull(szFile); <br>    LMFree(plmr, lpsRow); <br> <br>    DebugTraceResult(HrWriteTableOnDisk, hr); <br>    return hr; <br>} <br> <br>/************************************************************************* <br> * HrReadTableFromDisk <br> * <br> * Purpose <br> *      Read a table from this disk cache into the table lptbl <br> * <br> *  lptbl       the table to be built <br> *  pobj        object whose table is to be read <br> *  szEIDPath   Pathname of the EID of the folder, or NULL <br> *  cCols       Number of columns in this type of table <br> *  szFileName  Name of the file that holds this table type. <br> */ <br>HRESULT HrReadTableFromDisk(LPTABLEDATA lptbl, POBJ pobj, LPSTR szEIDPath, <br>    ULONG cCols, LPSTR szFileName) <br>{ <br>    HRESULT hr; <br>    PLMR    plmr; <br>    BOOL    fBadTableData   = FALSE; <br>    LPTSTR  szFile          = NULL; <br>    HANDLE  hFile           = INVALID_HANDLE_VALUE; <br>    PDRW    pdrw            = NULL; <br> <br>    plmr = &amp;pobj-&gt;pims-&gt;lmr; <br> <br>    /* get the name of the file holding the table */ <br>    hr = HrGetTableName(pobj, szEIDPath, szFileName, &amp;szFile); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* open the file */ <br>    hr = HrOpenTblFileRetry(szFile, GENERIC_READ, FILE_SHARE_READ, <br>        OPEN_ALWAYS, &amp;hFile); <br>    if (hr != hrSuccess) <br>    { <br>        /* If the file wasn't found, then simply leave the table empty, */ <br>        /* and return success. */ <br> <br>        if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>            hr = hrSuccess; <br> <br>        goto exit; <br>    } <br> <br>    while (TRUE) <br>    { <br>        BOOL fEOF; <br>        DRW drwTemp; <br>        ULONG cbOut; <br>        SCODE sc; <br> <br>        /* Read the beginning of the disk row. */ <br>        hr = HrReadBytes(hFile, &amp;drwTemp, CbNewDRW(0), &amp;fEOF); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (fEOF) <br>            break; <br> <br>        /* Sanity check for bad data. */ <br>        /* Note that the number of columns in the disk version of the */ <br>        /* table can be less than the number of columns in the in-memory */ <br>        /* table due to properties that were missing from the message */ <br>        /* when it was written to disk. */ <br> <br>        if (    drwTemp.rw.cValues &gt; cCols <br>            ||  drwTemp.rw.cValues == 0 <br>            ||  drwTemp.cbRow &lt; drwTemp.rw.cValues * sizeof(SPropValue)) <br>        { <br>            hr = ResultFromScode(MAPI_E_CORRUPT_DATA); <br>            fBadTableData = TRUE; <br>            goto exit; <br>        } <br> <br>        hr = HrAlloc(CbNewDRW(drwTemp.cbRow), &amp;pdrw); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        memcpy(pdrw, &amp;drwTemp, CbNewDRW(0)); <br> <br>        /* read the rest of the row */ <br>        hr = HrReadBytes(hFile, &amp;pdrw-&gt;ab, pdrw-&gt;cbRow, NULL); <br>        if (hr != hrSuccess) <br>        { <br>            fBadTableData = TRUE; <br>            goto exit; <br>        } <br> <br>        sc = ScRelocProps((UINT) pdrw-&gt;rw.cValues, (LPSPropValue) pdrw-&gt;ab, <br>            pdrw-&gt;rw.lpProps, &amp;pdrw-&gt;ab, &amp;cbOut); <br>        if (sc != S_OK || cbOut != pdrw-&gt;cbRow) <br>        { <br>            hr = ResultFromScode(MAPI_E_CORRUPT_DATA); <br>            fBadTableData = TRUE; <br>            goto exit; <br>        } <br> <br>        pdrw-&gt;rw.lpProps = (LPSPropValue) pdrw-&gt;ab; <br> <br>        /* add this row to the table */ <br>        hr = lptbl-&gt;lpVtbl-&gt;HrModifyRow(lptbl, &amp;pdrw-&gt;rw); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        FreeNull(pdrw); <br>        pdrw = NULL; <br>    } <br> <br>exit: <br>    if (hFile != INVALID_HANDLE_VALUE) <br>        CloseHandle(hFile); <br> <br>    /* erase the file if it is bogus. We will regenerate it if we can. */ <br>    if (fBadTableData) <br>        DeleteFile(szFile); <br> <br>    FreeNull(szFile); <br>    FreeNull(pdrw); <br> <br>    DebugTraceResult(HrReadTableFromDisk, hr); <br>    return hr; <br>} <br> <br>/************************************************************************ <br> * HrGetTime <br> * <br> * Purpose  return the value of PR_LAST_MODIFICATION_TIME from the properties <br> *          in the given property array <br> * <br> * Parameters <br> *  prw         pointer to the table row to search <br> *  pfiletime   pointer to last modification time <br> */ <br>static HRESULT HrGetTime(LPSRow prw, FILETIME *pfiletime) <br>{ <br>    LPSPropValue pvalT; <br>    LPSPropValue pvalMax; <br>    SCODE sc = MAPI_E_NOT_FOUND; <br> <br>    Assert(!IsBadReadPtr(prw, sizeof(SRow))); <br>    Assert(prw-&gt;cValues &lt;= UINT_MAX / sizeof(SPropValue)); <br>    Assert(!IsBadReadPtr(prw-&gt;lpProps, ((UINT) prw-&gt;cValues) * sizeof(SPropValue))); <br>    Assert(!IsBadWritePtr(pfiletime, sizeof(FILETIME))); <br> <br>    pvalT = prw-&gt;lpProps; <br>    pvalMax = pvalT + prw-&gt;cValues; <br> <br>    while (pvalT &lt; pvalMax) <br>    { <br>        if (pvalT-&gt;ulPropTag == PR_LAST_MODIFICATION_TIME) <br>        { <br>            sc = S_OK; <br>            *pfiletime = pvalT-&gt;Value.ft; <br>            break; <br>        } <br>        pvalT++; <br>    } <br> <br>    DebugTraceSc(HrGetTime, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/************************************************************************* <br> * HrSyncOutgoingTable <br> * <br> * Purpose <br> *      Verifies that every table row in memory actually corresponds to <br> *      a message on disk. If bad rows are found, removes them and <br> *      rewrites the disk version of the table data. Note that this code <br> *      does not verify that the message on disk actually is in the queue, <br> *      nor does it check for messages that are somehow missing from the table. <br> * <br> *  lptbl           pointer to the outgoing table data object. <br> *  pims            a pointer to the message store object. <br> * <br> */ <br>HRESULT HrSyncOutgoingTable(LPTABLEDATA lptbl, PIMS pims) <br>{ <br>    HRESULT hr; <br>    BOOL fRowsRemoved; <br> <br>    hr = HrRemoveBadTableRows(lptbl, NULL, pims, &amp;fRowsRemoved); <br> <br>    if (hr == hrSuccess &amp;&amp; fRowsRemoved) <br>        hr = HrWriteTableOnDisk(lptbl, (POBJ) pims, NULL, szOutgoingFileName); <br> <br>    DebugTraceResult(HrSyncOutgoingTable, hr); <br>    return hr; <br>} <br> <br>/************************************************************************* <br> * HrSyncContentsTable <br> * <br> * Purpose <br> *      Verifies that the table in memory agrees with what's on disk. <br> *      If discrepancies are found, fixes them, and rewrites the disk <br> *      version of the table data. <br> * <br> *  pifld           the parent folder of the contents table. <br> *  fWriteTable     if TRUE, write the disk version of the table if the <br> *                  in-memory table is out of sync. <br> * <br> */ <br>HRESULT HrSyncContentsTable(PIFLD pifld, BOOL fWriteTable) <br>{ <br>    HRESULT hr; <br>    BOOL fRowsRemoved; <br>    BOOL fRowsAdded; <br>    LPTABLEDATA lptbl; <br> <br>    lptbl = pifld-&gt;lptblContents; <br> <br>    hr = HrRemoveBadTableRows(lptbl, pifld, pifld-&gt;pims, &amp;fRowsRemoved); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrAddMissingTableRows(lptbl, pifld, szMessageTemplate, <br>        (LPSPropTagArray) &amp;sPropTagsContents, &amp;fRowsAdded); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* update folder's content count and unread count if */ <br>    /* the table was out of ssync */ <br> <br>    if (fRowsRemoved || fRowsAdded) <br>    { <br>        hr = HrNewCounts(pifld, lptbl); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (fWriteTable) <br>        { <br>            hr = HrWriteTableOnDisk(lptbl, (POBJ) pifld, pifld-&gt;peid-&gt;szPath, <br>                szContentsFileName); <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br>    } <br>    else <br>    { <br>        /* If there aren't any rows in the table, we still need to <br>         * update the folder's count of messages, because the counts  <br>         * may not be zero, even though there aren't any messages on disk. <br>         */ <br>        LPSRow lpSRow = NULL; <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;HrEnumRow(lptbl, 0, &amp;lpSRow); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (lpSRow == NULL) <br>            hr = HrWriteCounts(pifld, 0, 0); <br> <br>        LMFree(&amp;pifld-&gt;pims-&gt;lmr, lpSRow); <br>    } <br> <br>exit: <br>    DebugTraceResult(HrSyncContentsTable, hr); <br>    return hr; <br>} <br> <br>/************************************************************************* <br> * HrRemoveBadTableRows <br> * <br> * Purpose <br> *      Verifies that every row in the table given has a corresponding <br> *      file on disk. If the file on disk does not exist, the routine <br> *      removes the row from the table. <br> * <br> *  lptbl           pointer to table <br> *  pifldParent     the folder that all objects should be in. May be NULL. <br> *  pims            the message store object <br> *  pfTableChanged  Pointer to a location to return a BOOL that, when TRUE, <br> *                  indicates that a bad row was found, and the table was changed <br> * <br> */ <br>static HRESULT HrRemoveBadTableRows(LPTABLEDATA lptbl, PIFLD pifldParent, <br>    PIMS pims, BOOL *pfTableChanged) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPSRow lpSRow = NULL; <br>    BOOL fTableChanged = FALSE; /* TRUE if lptbl was changed */ <br>    ULONG iRow = 0; <br> <br>    while (TRUE) <br>    { <br>        LPSTR szPath; <br>        BOOL fIsParent = TRUE; <br>        PEID peid; <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;HrEnumRow(lptbl, iRow++, &amp;lpSRow); <br> <br>        if (hr != hrSuccess || lpSRow == NULL) <br>            break; <br> <br>        peid = (PEID) lpSRow-&gt;lpProps-&gt;Value.bin.lpb; <br> <br>        /* If the caller gave us a parent folder, verify that the message */ <br>        /* is in that folder. For example, if the caller is checking the */ <br>        /* contents table, we can check that all messages are in the folder */ <br>        /* they should be, but for the outgoing queue table, we can't. */ <br> <br>        if (pifldParent) <br>        { <br>            hr = HrIsParent(pifldParent-&gt;peid, peid, &amp;fIsParent); <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br> <br>        hr = HrFullPathName(pims-&gt;szStorePath, peid-&gt;szPath, NULL, &amp;szPath); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        /* Delete the row if it no longer exists on disk */ <br>        /* or isn't in the correct folder */ <br>        if ((GetFileAttributes(szPath) == -1) || !fIsParent) <br>        { <br>            HRESULT hrT; <br> <br>            hrT = lptbl-&gt;lpVtbl-&gt;HrDeleteRow(lptbl, lpSRow-&gt;lpProps); <br> <br>            if (hrT != hrSuccess) <br>            { <br>                TraceSz1("SampleMS: HrSyncTableWithDisk: error %s " <br>                    "deleting out-of-date table entry\n", <br>                    SzDecodeScode(GetScode(hrT))); <br>            } <br> <br>            fTableChanged = TRUE; <br>        } <br> <br>        LMFree(&amp;pims-&gt;lmr, lpSRow); <br>        lpSRow = NULL; <br>        FreeNull(szPath); <br>    } <br> <br>    AssertSz(!IsBadWritePtr(pfTableChanged, sizeof(BOOL)), "Bad parameter" <br>        " (pfTableChanged) given to HrRemoveBadTableRows"); <br>    *pfTableChanged = fTableChanged; <br> <br>exit: <br>    LMFree(&amp;pims-&gt;lmr, lpSRow); <br>    DebugTraceResult(HrRemoveBadTableRows, hr); <br>    return hr; <br>} <br> <br>/************************************************************************* <br> * HrAddMissingTableRows <br> * <br> * Purpose <br> *      Searches a folder for objects of the specified type, and verifies <br> *      that each object exists in the table given, and is up-to-date. <br> *      If the object does not exist or is out-of-date, the routine <br> *      adds or updates the table row with current information from the object. <br> *      This routine only works for contents tables currently. <br> * <br> *  lptbl           pointer to table <br> *  pifld           the folder that all objects should be in. <br> *  szTemplate      type of files to search for for this table type <br> *  ptaga           list of proptags for this type of table <br> *  pfTableChanged  Pointer to a location to return a BOOL that, when TRUE, <br> *                  indicates that the table was changed to match the disk <br> * <br> */ <br>static HRESULT HrAddMissingTableRows(LPTABLEDATA lptbl, PIFLD pifld, <br>    LPSTR szTemplate, LPSPropTagArray ptaga, BOOL * pfTableChanged) <br>{ <br>    HRESULT hr; <br>    WIN32_FIND_DATA ffd; <br>    HANDLE hFindFile = INVALID_HANDLE_VALUE; <br>    ULONG ulOffset; <br>    LPTSTR szFile = NULL;       /* full path name of next file in the table */ </code></pre>
<p>
</p>
<pre><code>PEID peid = NULL; <br>    BOOL fTableChanged = FALSE; <br>    LPSRow lpSRow = NULL; <br>    SPropValue pvInstKey; <br>    PLMR plmr = &amp;pifld-&gt;pims-&gt;lmr; <br> <br>    /* for each file of the right kind ( message or folder ) on disk */ <br>    /* make sure its entry in the cache is up to date */ <br> <br>    pvInstKey.ulPropTag = PR_INSTANCE_KEY; <br> <br>    /* get the next file */ <br>    hr = HrFindFirstID(pifld, szTemplate, &amp;ulOffset, &amp;szFile, &amp;hFindFile, <br>        &amp;ffd, &amp;peid); <br> <br>    while (hr == hrSuccess) <br>    { <br>        FILETIME ftTableTime;   /* modify time of szFile in lptbl */ <br> <br>        /* get its row in the table */ <br>        pvInstKey.Value.bin.cb = CbEID(peid); <br>        pvInstKey.Value.bin.lpb = (LPBYTE) peid; <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;HrQueryRow(lptbl, &amp;pvInstKey, &amp;lpSRow, NULL); <br> <br>        if (GetScode(hr) == MAPI_E_NOT_ENOUGH_MEMORY) <br>            goto exit; <br> <br>        /* update the row if necessary */ <br>        /* store in ftTableTime, the modify time of this object */ <br>        /* as stored in the lptbl */ <br>        if (hr == hrSuccess &amp;&amp; lpSRow) <br>            hr = HrGetTime(lpSRow, &amp;ftTableTime); <br> <br>        if (hr != hrSuccess <br>            || lpSRow == NULL <br>            || CompareFileTime(&amp;ftTableTime, &amp;(ffd.ftLastWriteTime)) == -1) <br>        { <br>            fTableChanged = TRUE; <br> <br>            HrUpdateRow(pifld-&gt;pims, lptbl, peid, ptaga, &amp;(ffd.ftLastWriteTime), <br>                MAPI_MESSAGE); <br>        } <br> <br>        LMFree(plmr, peid); <br>        peid = NULL; <br>        LMFree(plmr, lpSRow); <br>        lpSRow = NULL; <br> <br>        hr = HrFindNextID(pifld, ulOffset, szFile, hFindFile, &amp;ffd, &amp;peid); <br>    } <br> <br>    if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>        hr = hrSuccess; <br> <br>    if (hr == hrSuccess) <br>    { <br>        AssertSz(!IsBadWritePtr(pfTableChanged, sizeof(BOOL)), "Bad parameter" <br>            " (pfTableChanged) given to HrAddMissingTableRows"); <br>        *pfTableChanged = fTableChanged; <br>    } <br> <br>exit: <br>    CloseIDSearch(&amp;hFindFile, &amp;szFile); <br>    LMFree(plmr, lpSRow); <br>    LMFree(plmr, peid); <br> <br>    DebugTraceResult(HrAddMissingTableRows, hr); <br>    return hr; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
