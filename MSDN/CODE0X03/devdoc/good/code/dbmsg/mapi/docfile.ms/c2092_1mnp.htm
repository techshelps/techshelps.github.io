<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPNTFY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2095"></a>MSPNTFY.C</h2>
<pre><code>/* <br> *  M S P N T F Y . C <br> * <br> *  Code for doing internal cross-process notifications within the  <br> *  Sample Message Store provider. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br>#include &lt;stdarg.h&gt; <br> <br>/* INTERNAL Function prototypes. */ <br> <br>long STDAPICALLTYPE LSMSOQNotifCallback(LPVOID lpvContext, ULONG cNotif, <br>    LPNOTIFICATION lpNotifs); <br>static void EmptyTable(LPTABLEDATA lptbl, PLMR plmr); <br>static HRESULT HrApplyOQNotifChanges(LPTABLEDATA lptbl, PONB ponbIn); <br>static HRESULT HrGetOutgoingNotificationKey(PIMS pims, LPNOTIFKEY * lppKey); <br>static HRESULT HrNotifyOnOutgoingQueue(PIMS pims, PEID peid, LPSRow prw, <br>    ULONG ulTableEvent, FILETIME *pftBeforeUpdate); <br> <br>long STDAPICALLTYPE LSMSTblNotifCallback(LPVOID lpvContext, ULONG cNotif, <br>    LPNOTIFICATION lpNotifs); <br>HRESULT HrApplyTblNotifChanges(PIMS pims, PTNB ptnbIn); <br>static HRESULT HrGetTableNotificationKey(PIMS pims, LPNOTIFKEY * lppKey); <br> <br>/* <br> *  EXTERNAL FUNCTIONS (called from outside this file). <br> */ <br> <br>/*  <br> * HrCreateOGQueueMutex <br> * <br> *  Purpose <br> *      Create the outgoing queue mutex, and return it to the caller. <br> * <br> *  Arguments <br> *      phQMutex: Pointer to the location to return the new mutex. <br> * <br> *  Returns: <br> *      HRESULT: Will return an error only if the CreateMutex call fails. <br> */ <br>HRESULT HrCreateOGQueueMutex(HANDLE *phQMutex) <br>{ <br>    HRESULT hr = hrSuccess; <br>    HANDLE hMutex; <br>    LPTSTR szMutexName = "SMS_OGQUEUEFILE_MUTEX"; <br> <br>    hMutex = CreateMutex(NULL, FALSE, szMutexName); <br> <br>    if (hMutex) <br>        *phQMutex = hMutex; <br> <br>    #ifndef WIN16 <br>    else <br>    { <br>        TraceSz1("SampleMS: HrCreateOGQueueMutex: call to" <br>            " CreateMutex failed (error %08lX)", GetLastError()); <br>         <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>    } <br>    #endif <br> <br>    DebugTraceResult(HrCreateOGQueueMutex, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrSetupPrivateNotifications <br> * <br> *  Purpose <br> *      Setup two private channels via the MAPI notification engine to <br> *      tell other processes running against this store when 1) the  <br> *      outgoing queue changes and 2) when contents and hierarchy tables <br> *      change. We communicate between the multiple client processes and <br> *      the one spooler process. For the outgoing queue, we use a key that <br> *      is the full pathname to the outgoing queue file. For the other <br> *      tables, we use a unique 16-byte ID. Remember the connections so <br> *      that we can Unsubscribe when we shutdown the store. <br> * <br> *  Arguments <br> *      pims: a pointer to the message store object. <br> * <br> *  Side Effects <br> *      Fills in the ulOQConn and ulTblConn members of pims. <br> * <br> *  Returns <br> *      HRESULT <br> */ <br>HRESULT HrSetupPrivateNotifications(PIMS pims) <br>{ <br>    HRESULT hr; <br>    LPMAPIADVISESINK lpAdvise; <br>    ULONG ulOQConn = 0; <br>    ULONG ulTblConn = 0; <br>    LPNOTIFKEY lpKey = NULL; <br> <br>    /* Use the MAPI notification engine to tell myself */ <br>    /* (across processes) when to update outgoing queue. */ <br> <br>    /* The key is the path to the disk cache of the outbound queue */ <br>    hr = HrGetOutgoingNotificationKey(pims, &amp;lpKey); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrAllocAdviseSink(&amp;LSMSOQNotifCallback, (LPVOID) pims, &amp;lpAdvise); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pims-&gt;psup-&gt;lpVtbl-&gt;Subscribe(pims-&gt;psup, lpKey, <br>        fnevExtended, 0L, lpAdvise, &amp;ulOQConn); <br> <br>    /* Always release; mapi will have addref'ed it during Subscribe */ <br>    UlRelease(lpAdvise); <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    FreeNull(lpKey); <br>    lpKey = NULL; <br> <br>    /* Now, setup notifications for the other tables. */ <br> <br>    hr = HrGetTableNotificationKey(pims, &amp;lpKey); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrAllocAdviseSink(&amp;LSMSTblNotifCallback, (LPVOID) pims, &amp;lpAdvise); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pims-&gt;psup-&gt;lpVtbl-&gt;Subscribe(pims-&gt;psup, lpKey, <br>        fnevExtended, 0L, lpAdvise, &amp;ulTblConn); <br> <br>    /* Always release; mapi will have addref'ed it during Subscribe */ <br>    UlRelease(lpAdvise); <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>exit: <br>    FreeNull(lpKey); <br> <br>    if (hr == hrSuccess) <br>    { <br>        /* Remember our use of the notification engine. */ <br>        pims-&gt;ulOQConn = ulOQConn; <br>        pims-&gt;ulTblConn = ulTblConn; <br>    } <br>    else if (ulOQConn != 0) <br>        (void) pims-&gt;psup-&gt;lpVtbl-&gt;Unsubscribe(pims-&gt;psup, ulOQConn); <br> <br>    DebugTraceResult(HrSetupPrivateNotifications, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrUpdateOutgoingQueue <br> * <br> *  Purpose <br> *      Updates the outgoing queue based on the information given. If the <br> *      outgoing queue table is not open, or is out-of-date with respect to <br> *      the outgoing queue file on disk, initializes the table. The function <br> *      then applies the change requested to the table, writes the table on <br> *      disk, and notifies other processes of the change. <br> * <br> *  Arguments <br> *      pims: A pointer to the message store object. <br> *      pimsg: For a TABLE_ROW_ADDED event, a pointer to the message being <br> *          added to the queue; otherwise, this parameter should be NULL. <br> *      peid: For a TABLE_ROW_DELETED event, a pointer to the entryid of the <br> *          message being deleted from the queue; otherwise, this parameter <br> *          should be NULL. <br> *      ulTableEvent: The type of update event: Either TABLE_ROW_ADDED or <br> *          TABLE_ROW_DELETED. <br> * <br> *  Returns <br> *      HRESULT <br> */ <br>HRESULT HrUpdateOutgoingQueue(PIMS pims, PIMSG pimsg, PEID peid, <br>    ULONG ulTableEvent) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPTABLEDATA lptbl; <br>    SRow srNewRow = {0, 0, NULL}; <br>    LPSRow prw; <br>    BOOL fInMutex = FALSE; <br>    FILETIME ftBeforeUpdate; <br> <br>    /* If the file mutex doesn't yet exist on this process, create it. */ <br> <br>    if (pims-&gt;hOGQueueMutex == NULL) <br>    { <br>        hr = HrCreateOGQueueMutex(&amp;pims-&gt;hOGQueueMutex); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    /* Get the file mutex so that we can use the file (and change it) */ <br>    /* without crossing paths with another process. */ <br> <br>    WaitForSingleObject(pims-&gt;hOGQueueMutex, INFINITE); <br>    fInMutex = TRUE; <br> <br>    /* This routine will open the outgoing queue table if it's not already */ <br>    /* open in this process, and will leave the opened copy around in pims. */ <br> <br>    if (pims-&gt;lptblOutgoing == NULL) <br>    { <br>        hr = HrNewOutgoingTableData(pims); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    lptbl = pims-&gt;lptblOutgoing; <br>    ftBeforeUpdate = pims-&gt;ftOGQueue; <br> <br>    if (ulTableEvent == TABLE_ROW_ADDED) <br>    { <br>        ULONG cValues; <br> <br>        AssertSz(pimsg, "A msg should be provided on an add"); <br>        AssertSz(peid == NULL, "No entryid should be provided on an add"); <br> <br>        hr = pimsg-&gt;lpVtbl-&gt;GetProps(pimsg, (LPSPropTagArray) &amp;sptaOutgoing, <br>            0, /* ansi */ <br>            &amp;cValues, &amp;srNewRow.lpProps); <br>     <br>        if (HR_FAILED(hr))          /* Ignore warnings from GetProps. */ <br>            goto exit; <br>     <br>        srNewRow.cValues = cValues; <br>     <br>        hr = lptbl-&gt;lpVtbl-&gt;HrModifyRow(lptbl, &amp;srNewRow); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        prw = &amp;srNewRow; <br>    } <br>    else <br>    { <br>        AssertSz(ulTableEvent == TABLE_ROW_DELETED, <br>            "Bad event type received"); <br>        AssertSz(pimsg == NULL, "No msg should be provided on a delete"); <br>        AssertSz(peid, "An entryid should be provided on a delete"); <br> <br>        /* remove it from the outgoing queue */ <br>        hr = HrRemoveRow(lptbl, peid); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        prw = NULL; <br>    } <br> <br>    hr = HrWriteTableOnDisk(lptbl, (POBJ) pims, NULL, szOutgoingFileName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Update the last mod time of the table inside this process's */ <br>    /* message store object. */ <br> <br>    hr = HrGetFileModTime(pims-&gt;szStorePath, szOutgoingFileName, <br>        &amp;pims-&gt;ftOGQueue); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrNotifyOnOutgoingQueue(pims, peid, prw, ulTableEvent, <br>        &amp;ftBeforeUpdate); <br> <br>exit: <br>    if (fInMutex) <br>        ReleaseMutex(pims-&gt;hOGQueueMutex); <br> <br>    LMFree(&amp;pims-&gt;lmr, srNewRow.lpProps); <br> <br>    DebugTraceResult(HrUpdateOutgoingQueue, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrNewOutgoingTableData <br> * <br> * Purpose  Checks the outgoing table data object in the message store. <br> *          If there isn't one, creates it and initializes it from disk. <br> *          If there is one, empties it, and re-initializes it from disk. <br> *          Should be inside the outgoing queue mutex during this function. <br> * <br> * Parameters <br> *  pims    A pointer to the message store object. <br> * <br> * Side Effects <br> *          Fills in the lptblOutgoing member of the pims. <br> *          Updates pims-&gt;ftOGQueue with the last mod time of the  <br> *          outgoing queue file. <br> */ <br>HRESULT HrNewOutgoingTableData(PIMS pims) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPTABLEDATA lptbl = pims-&gt;lptblOutgoing; <br>    BOOL fTableCreated = FALSE; <br> <br>    if (!lptbl) <br>    { <br>        PINST pinst; <br>        SCODE sc = S_OK; <br>     <br>        /* The table doesn't exist. Create it. */ <br> <br>        pinst = (PINST) PvGetInstanceGlobals(); <br>     <br>        if (pinst == NULL) <br>        { <br>            hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>            goto exit; <br>        } <br>     <br>        sc = CreateTable((LPIID) &amp;IID_IMAPITableData, pims-&gt;lmr.lpAllocBuf, <br>            pims-&gt;lmr.lpAllocMore, pims-&gt;lmr.lpFreeBuf, pinst-&gt;lpmalloc, <br>            TBLTYPE_DYNAMIC, PR_INSTANCE_KEY, (LPSPropTagArray) &amp;sptaOutgoing, <br>            &amp;lptbl); <br>     <br>        if (sc != S_OK) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto exit; <br>        } <br> <br>        fTableCreated = TRUE; <br>    } <br>    else <br>    { <br>        /* The table exists already. Delete all rows from it. */ <br>        EmptyTable(lptbl, &amp;pims-&gt;lmr); <br>    } <br> <br>    /* read the table in from disk */ <br>    /* outgoing queue tables can't be regenerated, so any error reading */ <br>    /* the table is fatal. We lose all messages in the OG queue if this */ <br>    /* function has an error. */ <br> <br>    hr = HrReadTableFromDisk(lptbl, (POBJ) pims, NULL, OUTGOING_COLUMNS, <br>        szOutgoingFileName); <br>    if (hr != hrSuccess) <br>    { <br>        TraceSz("SMS: Bad OG Queue data on disk."); <br>        goto exit; <br>    } <br> <br>    /* Verify that all messages in the table actually exist on disk. If */ <br>    /* not, remove the row(s) and re-write the table to disk. */ <br>    hr = HrSyncOutgoingTable(lptbl, pims); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Save away the last mod time of the table inside this process's */ <br>    /* message store object. */ <br> <br>    hr = HrGetFileModTime(pims-&gt;szStorePath, szOutgoingFileName, <br>        &amp;pims-&gt;ftOGQueue); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    pims-&gt;lptblOutgoing = lptbl; <br> <br>exit: <br>    if (hr != hrSuccess &amp;&amp; fTableCreated) <br>        UlRelease(lptbl); <br> <br>    DebugTraceResult(HrNewOutgoingTableData, hr); <br>    return hr; <br>} <br> <br>/* <br> * INTERNAL Functions (called from within this file ONLY). <br> * <br> */ <br> <br>/*----------------------------------------------------------------------+ <br>|                                                                       | <br>|           CONTENTS AND HIERARCHY TABLE NOTIFICATION HANDLING          | <br>|                                                                       | <br>+----------------------------------------------------------------------*/ <br> <br>/* <br> * LSMSTblNotifCallback <br> * <br> *  Purpose <br> *      Update the contents or hierarchy table associated with the folder eid <br> *      passed across. We should receive a notification when the tabledata <br> *      object needs to have a row added, deleted or modified. Calls <br> *      ChangeTable after decoding the notification. <br> * <br> *  Arguments <br> *      lpvContext: A pointer to the message store object to use. We need <br> *          to verify that the object is still valid before using it. <br> *      cNotif: The number of notifications to process. <br> *      lpNotif: A pointer to an array of NOTIFICATION structures. <br> * <br> *  Returns <br> *      LONG: Always returns 0. <br> */ <br>long STDAPICALLTYPE LSMSTblNotifCallback(LPVOID lpvContext, ULONG cNotif, <br>    LPNOTIFICATION lpNotif) <br>{ <br>    PIMS pims = (PIMS) lpvContext; <br>    SCODE sc = S_OK; <br>    HRESULT hr = hrSuccess; <br>    PTNB ptnb; <br> <br>    /* <br>     * Our code sends one extended notification at a time. <br>     * The notification consists of the table event that occurred along with <br>     * an object notification containing the entryids we need. We only use <br>     * two of the entryids in the object notification. The ParentID fields <br>     * refer to the parent folder of the table we need to update. The EntryID <br>     * fields refer to the object that changed within the folder. The <br>     * ulObjType field will be either MAPI_MESSAGE (for contents table <br>     * changes) or MAPI_FOLDER (for hierarchy table changes).  All other <br>     * fields in the structure are unused and should be set to 0. <br>     */ <br>    if (IMS_IsInvalid(pims) <br>        || cNotif != 1 <br>        || (IsBadReadPtr(lpNotif, ((UINT) cNotif) * sizeof(NOTIFICATION))) <br>        || lpNotif-&gt;ulEventType != fnevExtended <br>        || lpNotif-&gt;info.ext.ulEvent != 0) <br>        return 0; <br> <br>    ptnb = (PTNB) lpNotif-&gt;info.ext.pbEventParameters; <br> <br>    if (IsBadReadPtr(ptnb, CbNewTNB(0)) <br>        || IsBadReadPtr(ptnb, CbTNB(ptnb))) <br>        return 0; <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    hr = HrApplyTblNotifChanges(pims, ptnb); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    if (hr != hrSuccess) <br>        sc = GetScode(hr); <br> <br>    return sc; <br>} <br> <br>/*  <br> * HrApplyTblNotifChanges <br> * <br> * Purpose <br> *  This function relocates and validates the internal object notification <br> *  passed in, and then calls ChangeTable to actually update any open tables <br> *  within this process with the change given. The notification needs to be <br> *  relocated because the pointers from the other process may not be valid <br> *  on this process. <br> * <br> * Parameters <br> *  pims: A pointer to the message store object. <br> *  ptnbIn: A pointer to the table notification block (TNB) containing the <br> *      data we need in order to update any open tables om this process. <br> * <br> * Returns: validation errors or hrSuccess. <br> */ <br>HRESULT HrApplyTblNotifChanges(PIMS pims, PTNB ptnbIn) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc = S_OK; <br>    LPNOTIFICATION lpntf; <br>    PTNB ptnb = NULL; <br>    OBJECT_NOTIFICATION *pon; <br>    ULONG cb; <br> <br>    /* Allocate a new notification block, and copy the data over before */ <br>    /* relocation. */ <br> <br>    hr = HrAlloc(CbNewTNB(ptnbIn-&gt;cbNtf), &amp;ptnb); <br>    if (hr != hrSuccess) <br>        goto ret; <br> <br>    memcpy(ptnb, ptnbIn, (UINT) CbNewTNB(ptnbIn-&gt;cbNtf)); <br> <br>    lpntf = (LPNOTIFICATION) ptnb-&gt;abNtf; <br> <br>    if (lpntf-&gt;ulEventType != fnevObjectModified) <br>    { <br>        TraceSz1("SMS: HrApplyTblNotifChanges: Bad ulEventType %08lX " <br>            "received", lpntf-&gt;ulEventType); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto ret; <br>    } <br> <br>    /* Relocate the notification into the address space of this process. */ <br>    /* We passed along the memory offset of the originating process to allow */ <br>    /* this code to work. Note that ScRelocNotifications currently only */ <br>    /* works from "bad" addresses to "good" addresses. The code assumes that */ <br>    /* pointers are "bad" inside the notification, and that after conversion, */ <br>    /* they are valid. */ <br> <br>    sc = ScRelocNotifications(1, lpntf, ptnb-&gt;pvRef, (LPVOID) lpntf, &amp;cb); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto ret; <br>    } <br> <br>    if (ptnb-&gt;cbNtf != cb) <br>    { <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto ret; <br>    } <br> <br>    pon = (OBJECT_NOTIFICATION *) &amp;(lpntf-&gt;info.obj); <br> <br>    if (pon-&gt;ulObjType != MAPI_MESSAGE &amp;&amp; pon-&gt;ulObjType != MAPI_FOLDER) <br>    { <br>        TraceSz1("SMS: HrApplyTblNotifChanges: unexpected Object Type %08lX", <br>            pon-&gt;ulObjType); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto ret; <br>    } <br> <br>    if (    FIsInvalidEID(pon-&gt;cbParentID, (PEID) pon-&gt;lpParentID, pims) <br>        ||  !FIsFolder((PEID) pon-&gt;lpParentID)) <br>    { <br>        TraceSz("SMS: HrApplyTblNotifChanges: invalid parent entryid"); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto ret; <br>    } <br> <br>    /* TABLE_CHANGED events don't require a lpEntryID, because multiple <br>     * objects have changed. ChangeTable() simply validates all rows in <br>     * the table against the files on disk. <br>     */ <br>    if (    ptnb-&gt;ulTableEvent != TABLE_CHANGED <br>        &amp;&amp;  FIsInvalidEID(pon-&gt;cbEntryID, (PEID) pon-&gt;lpEntryID, pims)) <br>    { <br>        TraceSz("SMS: HrApplyTblNotifChanges: invalid entryid"); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto ret; <br>    } <br> <br>    ChangeTable(pims, (PEID) pon-&gt;lpParentID, (PEID) pon-&gt;lpEntryID, <br>        pon-&gt;ulObjType, ptnb-&gt;ulTableEvent, FALSE); <br> <br>ret: <br>    FreeNull(ptnb); <br> <br>    DebugTraceResult(HrApplyTblNotifChanges, hr); <br>    return hr; <br>} <br> <br>/*  <br> * HrSendNotif <br> * <br> * Purpose <br> *  This function constructs and sends a notification to other active Sample <br> *  Message Store processes open on this message store file. The notification <br> *  describes a change (add, delete, or modify) to either a message (contents <br> *  table) or folder (hierarchy table). The receiver will need to get two <br> *  entryids, one for the parent folder of the changed object, and one for <br> *  the changed object itself. The receiver also needs to know whether the <br> *  changed object is a message or a folder, and what type of change occurred: <br> *  add, delete, modify, or change (contents tables only). <br> * <br> * Parameters <br> *  pims: Pointer to the message store object. <br> *  peidParent: The entryid of the folder containing the table to update and <br> *              the object that changed. <br> *  peidObject: The entryid of the object that changed. May be NULL when <br> *              sending a TABLE_CHANGED notification (contents tables only). <br> *  ulTableEvent: TABLE_ROW_ADDED, TABLE_ROW_DELETED, TABLE_ROW_MODIFIED, or <br> *              TABLE_CHANGED (TABLE_CHANGED only works on contents tables). <br> *  ulObjType: The type of object that changed. This implies the type of table <br> *              to update. May be MAPI_MESSAGE (contents table) or MAPI_FOLDER <br> *              (hierarchy table). <br> * <br> * Returns: Memory and disk errors or success. <br> */ <br>HRESULT HrSendNotif(PIMS pims, PEID peidParent, PEID peidObject, <br>    ULONG ulTableEvent, ULONG ulObjType) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc; <br>    LPNOTIFKEY lpKey = NULL; <br>    NOTIFICATION ntfTemp; <br>    NOTIFICATION ntf; <br>    PTNB ptnb = NULL; <br>    ULONG cbNtf; <br>    ULONG cbOut; <br>    ULONG ulFlags = 0; <br> <br>    /* Get the key */ <br>    hr = HrGetTableNotificationKey(pims, &amp;lpKey); <br>    if (hr != hrSuccess) <br>        goto ret; <br> <br>    /* <br>     * Our code sends one extended notification at a time. The notification <br>     * consists of the table event that occurred along with an object <br>     * notification containing the entryids we need. We send the type of <br>     * table event as part of our extended notification structure, and <br>     * package the object notification always as "fnevObjectModified". We <br>     * only use two of the entryids in the object notification. The ParentID <br>     * fields refer to the parent folder of the table we need to update. The <br>     * EntryID fields refer to the object that changed within the folder. The <br>     * ulObjType field will be either MAPI_MESSAGE (for contents table <br>     * changes) or MAPI_FOLDER (for hierarchy table changes).  All other <br>     * fields in the structure are unused and should be set to 0. <br>     */ <br>    memset(&amp;ntfTemp, 0, sizeof(NOTIFICATION)); <br> <br>    /* We always send the same type of event here. This is enough to get the <br>     * notification code to count and relocate what we send. We send the real <br>     * table event in ptnb-&gt;ulTableEvent (see below). <br>     */ <br>    ntfTemp.ulEventType = fnevObjectModified; <br> <br>    ntfTemp.info.obj.ulObjType  = ulObjType; <br> <br>    ntfTemp.info.obj.lpParentID = (LPENTRYID) peidParent; <br>    ntfTemp.info.obj.cbParentID = CbEID(peidParent); <br> <br>    if (ulTableEvent != TABLE_CHANGED) <br>    { <br>        ntfTemp.info.obj.lpEntryID  = (LPENTRYID) peidObject; <br>        ntfTemp.info.obj.cbEntryID  = CbEID(peidObject); <br>    } <br> <br>    sc = ScCountNotifications(1, &amp;ntfTemp, &amp;cbNtf); <br>    if (sc != S_OK) <br>    {                    <br>        hr = ResultFromScode(sc); <br>        goto ret; <br>    } <br> <br>    hr = HrAlloc(CbNewTNB(cbNtf), &amp;ptnb); <br>    if (hr != hrSuccess) <br>        goto ret; <br> <br>    /* Here's where we send the table event. It's either TABLE_ROW_ADDED, <br>     * TABLE_ROW_DELETED, TABLE_ROW_MODIFIED, or TABLE_CHANGED. <br>     */ <br>    ptnb-&gt;ulTableEvent = ulTableEvent; <br>    ptnb-&gt;cbNtf = cbNtf; <br> <br>    sc = ScCopyNotifications(1, &amp;ntfTemp, (LPVOID) ptnb-&gt;abNtf, &amp;cbOut); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto ret; <br>    } <br> <br>    AssertSz(cbOut == cbNtf, "ScCopyNotifications used a different # of bytes " <br>        "than ScCountNotifications returned."); <br> <br>    /* Pass across the notification's memory offset so that the receiving */ <br>    /* process can relocate the notification to its address space. */ <br>    ptnb-&gt;pvRef = (LPVOID) ptnb-&gt;abNtf; <br>     <br>    ntf.ulEventType = fnevExtended; <br>    ntf.info.ext.ulEvent = 0; <br>    ntf.info.ext.cb = CbTNB(ptnb); <br>    ntf.info.ext.pbEventParameters = (LPBYTE) ptnb; <br> <br>    hr = pims-&gt;psup-&gt;lpVtbl-&gt;Notify(pims-&gt;psup, lpKey, 1, &amp;ntf, &amp;ulFlags); <br> <br>ret: <br>    FreeNull(lpKey); <br>    FreeNull(ptnb); <br> <br>    DebugTraceResult(HrSendNotif, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrGetTableNotificationKey <br> * <br> * Purpose <br> *  Generate and return the notification key that will allow cross-process <br> *  notifications for changes to any contents or hierarchy tables within a <br> *  store. The memory returned should be freed with FreeNull. This <br> *  notification key needs to work for processes attached to this particular <br> *  message store, and should only receive notifications having to do with <br> *  changes to tables. The key contains the store guid (unique for this store) <br> *  preceeded by a ULONG with 0x0000ABCD in it. Note that the choice of <br> *  0x0000ABCD is arbitrary. As long as the sender sends to the same key as <br> *  the receiver listens to, and no unexpected sender sends to that key, <br> *  we're fine. <br> * <br> * Parameters <br> *  pims        pointer to the message store object. <br> *  lppKey      pointer to the location to return the new key. <br> */ <br>static HRESULT HrGetTableNotificationKey(PIMS pims, LPNOTIFKEY * lppKey) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPNOTIFKEY lpKey = NULL; <br>    ULONG cb;                   /* number of bytes in the key */ <br> <br>    /* allocate space for the key */ <br>    cb = sizeof(ULONG) + sizeof(MAPIUID); <br>    hr = HrAlloc(CbNewNOTIFKEY(cb), (PPV) &amp;lpKey); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    *((ULONG *) &amp;(lpKey-&gt;ab[0])) = 0x0000ABCD; <br>    GetResourceUID(pims, (MAPIUID *) &amp;(lpKey-&gt;ab[sizeof(ULONG)])); <br>    lpKey-&gt;cb = cb; <br> <br>exit: <br>    if (HR_FAILED(hr)) <br>    { <br>        FreeNull(lpKey); <br>        lpKey = NULL; <br>    } <br> <br>    *lppKey = lpKey; <br> <br>    DebugTraceResult(HrGetTableNotificationKey, hr); <br>    return hr; <br>} <br> <br>/*----------------------------------------------------------------------+ <br>|                                                                       | <br>|               OUTGOING QUEUE NOTIFICATION HANDLING                    | <br>|                                                                       | <br>+----------------------------------------------------------------------*/ <br> <br>/* <br> * LSMSOQNotifCallback <br> * <br> *  Purpose <br> *      Update the outgoing queue table associated with the process that <br> *      the spooler is using. We should receive a notification when the <br> *      tabledata object needs to have a row added or deleted. If the <br> *      tabledata object exists on the message store object, then call <br> *      HrModifyRow (when a row is added), or HrRemoveRow (when a row is <br> *      deleted) to update the table appropriately. <br> * <br> *  Arguments <br> *      lpvContext: A pointer to the message store object to use. We need <br> *          to verify that the object is still valid before using it. <br> *      cNotif: The number of notifications to process. <br> *      lpNotif: A pointer to an array of NOTIFICATION structures. <br> * <br> *  Returns <br> *      LONG: Always returns 0. <br> */ <br>long STDAPICALLTYPE LSMSOQNotifCallback(LPVOID lpvContext, ULONG cNotif, <br>    LPNOTIFICATION lpNotif) <br>{ <br>    PIMS pims = (PIMS) lpvContext; <br>    SCODE sc = S_OK; <br>    HRESULT hr = hrSuccess; <br>    FILETIME ftCurrent; <br>    BOOL fInMutex = FALSE; <br>    PONB ponb; <br> <br>    /* Our code sends one extended notification at a time. This */ <br>    /* extended notification contains two filetimes (the time */ <br>    /* before the outgoing queue file was modified, and the time after */ <br>    /* the change was made), and a standard notification with the change */ <br>    /* to apply to the table. It should be an fnevTableModified, and */ <br>    /* should be either TABLE_ROW_ADDED or TABLE_ROW_DELETED. If we ever */ <br>    /* receive anything other than this, the code must change. */ <br>    if (IMS_IsInvalid(pims) <br>        || cNotif != 1 <br>        || (IsBadReadPtr(lpNotif, ((UINT) cNotif) * sizeof(NOTIFICATION))) <br>        || lpNotif-&gt;ulEventType != fnevExtended <br>        || lpNotif-&gt;info.ext.ulEvent != 0) <br>        return 0; <br> <br>    ponb = (PONB) lpNotif-&gt;info.ext.pbEventParameters; <br> <br>    if (IsBadReadPtr(ponb, CbNewONB(0)) <br>        || IsBadReadPtr(ponb, CbONB(ponb))) <br>        return 0; <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    /* Check to see if the outgoing queue table data is open. If it isn't, */ <br>    /* there is nothing to do, because the current table will be read and */ <br>    /* initialized from disk when the spooler opens it. We're done. */ <br> <br>    if (!pims-&gt;lptblOutgoing) <br>        goto exit; <br> <br>    /* If the file mutex doesn't yet exist on this process, create it. */ <br> <br>    if (pims-&gt;hOGQueueMutex == NULL) <br>    { <br>        hr = HrCreateOGQueueMutex(&amp;pims-&gt;hOGQueueMutex); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    /* Get the file mutex so that we can use the file (and change it) */ <br>    /* without crossing paths with another process. */ <br> <br>    WaitForSingleObject(pims-&gt;hOGQueueMutex, INFINITE); <br>    fInMutex = TRUE; <br> <br>    /* Get time that the file was last modified */ <br>    hr = HrGetFileModTime(pims-&gt;szStorePath, szOutgoingFileName, &amp;ftCurrent); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* If the time that this process last read the file is the same as */ <br>    /* the time that the file was last modified, then don't do anything */ <br>    /* because we already have all changes, including the one sent to us */ <br>    /* in this notification. This can happen because we picked up two */ <br>    /* changes at once, or because this process is actually the same */ <br>    /* process that sent the notification. */ <br>    if (CompareFileTime(&amp;ftCurrent, &amp;pims-&gt;ftOGQueue) == 0) <br>        goto exit; <br> <br>    /* If the time that this process last read the file is the same as */ <br>    /* the time that the other process read the file, then we can simply */ <br>    /* apply the changes sent in the notification itself, and update our */ <br>    /* time to the time after update sent in the notification. */ <br>    /* If the times are different, or there is a problem applying the */ <br>    /* changes, then reconstruct the table from the on-disk copy. */ <br> <br>    if ((CompareFileTime(&amp;ponb-&gt;ftBeforeUpdate, &amp;pims-&gt;ftOGQueue) == 0) <br>        &amp;&amp; (HrApplyOQNotifChanges(pims-&gt;lptblOutgoing, ponb) == hrSuccess)) <br>    { <br>        pims-&gt;ftOGQueue = ponb-&gt;ftAfterUpdate; <br>    } <br>    else <br>    { <br>        hr = HrNewOutgoingTableData(pims); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>exit: <br>    if (fInMutex) <br>        ReleaseMutex(pims-&gt;hOGQueueMutex); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    if (hr != hrSuccess) <br>        sc = GetScode(hr); <br> <br>    return sc; <br>} <br> <br>/* <br> * EmptyTable <br> * <br> *  Purpose <br> *      Deletes all rows from the table data object given. <br> *      Helper function for the outgoing queue table notification callback <br> *      routine. <br> * <br> *  Arguments <br> *      lptbl: A pointer to the tabledata object to empty. <br> *      plmr: A pointer to the linked memory routines. <br> * <br> *  Returns <br> *      void. <br> */ <br>static void EmptyTable(LPTABLEDATA lptbl, PLMR plmr) <br>{ <br>    HRESULT hr; <br>    LPSRow lpsRow; <br>    LPSPropValue pval; <br>    LPSPropValue pvalMac; <br> <br>    while (TRUE) <br>    { <br>        /* Get the first row. Note that as we delete rows, this will */ <br>        /* keep giving us a new row. */ <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;HrEnumRow(lptbl, 0, &amp;lpsRow); <br>        if (hr != hrSuccess) <br>        { <br>            TraceSz1("Sample MS: EmptyTable: HrEnumRow failed with" <br>                " sc == %s", SzDecodeScode(GetScode(hr))); <br>            break; <br>        } <br> <br>        /* The table is empty when no row is returned */ <br>        if (!lpsRow) <br>            break; <br> <br>        /* find the entryid in the property value array */ </code></pre>
<p>
</p>
<pre><code>pval = lpsRow-&gt;lpProps; <br>        pvalMac = pval + lpsRow-&gt;cValues; <br> <br>        for (; pval &lt; pvalMac; ++pval) <br>            if (pval-&gt;ulPropTag == PR_INSTANCE_KEY) <br>                break; <br> <br>        /* Every row should contain an inst key. It is the index property. */ <br>        if (pval == pvalMac) <br>        { <br>            TrapSz("No PR_INSTANCE_KEY found in the table row"); <br>            break; <br>        } <br> <br>        /* delete this row from the table */ <br>        hr = lptbl-&gt;lpVtbl-&gt;HrDeleteRow(lptbl, pval); <br> <br>        LMFree(plmr, lpsRow); <br>        lpsRow = NULL; <br> <br>        if (hr != hrSuccess) <br>        { <br>            TraceSz1("Sample MS: EmptyTable: HrDeleteRow failed with" <br>                " error %s", SzDecodeScode(GetScode(hr))); <br>            break; <br>        } <br>    } <br> <br>    return; <br>} <br> <br>/* <br> * HrApplyOQNotifChanges <br> * <br> *  Purpose <br> *      Helper function of the notification callback routine. If the  <br> *      table on disk hasn't changed except for the notification given, <br> *      then we can update the outgoing queue table data directly instead <br> *      of re-reading the table from disk. This function modifies the <br> *      table data directly by calling HrModifyRow (when a row is added), <br> *      or HrRemoveRow (when a row is deleted). <br> *      Note that we have to convert the notification inside the ONB so <br> *      that the pointers are valid. Also note that we may NOT modify the <br> *      notification data at all; therefore, we must copy the data before <br> *      changing it. <br> * <br> *  Arguments <br> *      lptbl: a pointer to the table data object to update. <br> *      ponbIn: a pointer to the ONB received in the callback. <br> * <br> *  Returns <br> *      HRESULT <br> */ <br>static HRESULT HrApplyOQNotifChanges(LPTABLEDATA lptbl, PONB ponbIn) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc; <br>    ULONG cb; <br>    LPNOTIFICATION lpntf; <br>    PONB ponb = NULL; <br> <br>    /* Allocate a new notification block, and copy the data over before */ <br>    /* relocation. */ <br> <br>    hr = HrAlloc(CbNewONB(ponbIn-&gt;cbNtf), &amp;ponb); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    memcpy(ponb, ponbIn, (UINT) CbNewONB(ponbIn-&gt;cbNtf)); <br> <br>    lpntf = (LPNOTIFICATION) ponb-&gt;abNtf; <br> <br>    /* Relocate the notification into the address space of this process. */ <br>    /* We passed along the memory offset of the originating process to allow */ <br>    /* this code to work. Note that ScRelocNotifications currently only */ <br>    /* works from "bad" addresses to "good" addresses. The code assumes that */ <br>    /* pointers are "bad" inside the notification, and that after conversion, */ <br>    /* they are valid. */ <br> <br>    sc = ScRelocNotifications(1, lpntf, ponb-&gt;pvRef, (LPVOID) lpntf, &amp;cb); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    if (ponb-&gt;cbNtf != cb) <br>    { <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto exit; <br>    } <br> <br>    /* We don't expect any events other than those for a table. */ <br> <br>    if (lpntf-&gt;ulEventType != fnevTableModified) <br>    { <br>        TraceSz1("SMS: HrApplyOQNotifChanges: unexpected ulEventType %08lX", <br>            lpntf-&gt;ulEventType); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto exit; <br>    } <br> <br>    switch (lpntf-&gt;info.tab.ulTableEvent) <br>    { <br>    case TABLE_ROW_DELETED: <br> <br>        /* delete the row from the table according to the index */ <br>        /* property value in the notification structure */ <br>        hr = lptbl-&gt;lpVtbl-&gt;HrDeleteRow(lptbl, &amp;lpntf-&gt;info.tab.propIndex); <br>        if (hr != hrSuccess) <br>        { <br>            TraceSz1("SMS: HrApplyOQNotifChanges: HrDeleteRow returns sc == %s", <br>                SzDecodeScode(GetScode(hr))); <br>            goto exit; <br>        } <br>        break; <br> <br>    case TABLE_ROW_ADDED: <br> <br>        /* add the row to the table. We don't care where in the table */ <br>        /* it goes, because the row will be sorted by the spooler in */ <br>        /* its view anyway. */ <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;HrModifyRow(lptbl, &amp;lpntf-&gt;info.tab.row); <br>        if (hr != hrSuccess) <br>        { <br>            TraceSz1("SMS: HrApplyOQNotifChanges: HrModifyRow returns sc == %s", <br>                SzDecodeScode(GetScode(hr))); <br>            goto exit; <br>        } <br>        break; <br> <br>    default: <br> <br>        /* We don't expect any other table events than the */ <br>        /* two above. */ <br> <br>        TraceSz1("SMS: HrApplyOQNotifChanges: unexpected ulTableEvent %08lX", <br>            lpntf-&gt;info.tab.ulTableEvent); <br>        break; <br>    } <br> <br>exit: <br>    FreeNull(ponb); <br> <br>    DebugTraceResult(HrApplyOQNotifChanges, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrGetOutgoingNotificationKey <br> * <br> * Purpose  return the nofication key for the outgoing queue <br> *          memory should be freed with FreeNull <br> *          The key we use contains the full pathname to the outgoing <br> *          queue file on disk. This should be unique for the store <br> *          that we're running against. <br> * <br> * Parameters <br> * pims         the store whose outgoing queue is being referred to <br> * lppKey       pointer to the key <br> */ <br>static HRESULT HrGetOutgoingNotificationKey(PIMS pims, LPNOTIFKEY * lppKey) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPNOTIFKEY lpKey = NULL; <br>    ULONG cb;                   /* number of bytes in the key */ <br>    LPSTR szPath = NULL;        /* path to outgoing queue */ <br> <br>    hr = HrGetTableName((POBJ) pims, NULL, szOutgoingFileName, &amp;szPath); <br>    if (HR_FAILED(hr)) <br>        goto exit; <br> <br>    /* allocate space for the key */ <br>    cb = Cbtszsize(szPath); <br>    hr = HrAlloc(CbNewNOTIFKEY(cb), (PPV) &amp;lpKey); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    lstrcpy(lpKey-&gt;ab, szPath); <br>    lpKey-&gt;cb = cb; <br> <br>exit: <br>    FreeNull(szPath); <br>    if (HR_FAILED(hr)) <br>    { <br>        FreeNull(lpKey); <br>        lpKey = NULL; <br>    } <br>    *lppKey = lpKey; <br>    return hr; <br>} <br> <br>/* <br> * HrNotifyOnOutgoingQueue <br> * <br> * Purpose <br> *  Send out a notification that the Outgoing Queue has had a row added <br> *  or deleted. Also send the filetime of the queue file before and after <br> *  the modification. <br> * <br> * Parameters <br> *  pims: A pointer to the message store object. <br> *  peid: (For TABLE_ROW_DELETED) The entryid of the message in the <br> *          queue that was deleted. <br> *  prw: (For TABLE_ROW_ADDED) A pointer to the row of data added <br> *          to the OG Queue. <br> *  ulTableEvent: Either TABLE_ROW_ADDED or TABLE_ROW_DELETED. <br> *  pftBeforeUpdate: A pointer to the filetime of the queue file before the <br> *          update was performed. <br> */ <br>static HRESULT HrNotifyOnOutgoingQueue(PIMS pims, PEID peid, LPSRow prw, <br>    ULONG ulTableEvent, FILETIME *pftBeforeUpdate) <br>{ <br>    HRESULT hr; <br>    LPNOTIFKEY lpKey = NULL; <br>    ULONG ulFlags = 0; <br>    NOTIFICATION ntf; <br>    NOTIFICATION ntfTemp; <br>    PONB ponb = NULL; <br>    ULONG cbNtf; <br>    ULONG cbOut; <br>    SCODE sc; <br> <br>    /* get the key */ <br>    hr = HrGetOutgoingNotificationKey(pims, &amp;lpKey); <br>    if (HR_FAILED(hr)) <br>        goto exit; <br> <br>    /* Assemble the notification. */ <br>    ntfTemp.ulEventType = fnevTableModified; <br>    ntfTemp.info.tab.ulTableEvent = ulTableEvent; <br>    ntfTemp.info.tab.hResult = hrSuccess; <br> <br>    if (ulTableEvent == TABLE_ROW_DELETED) <br>    { <br>        /* Send across the index property for the row: PR_INSTANCE_KEY */ <br>        ntfTemp.info.tab.propIndex.ulPropTag = PR_INSTANCE_KEY; <br>        ntfTemp.info.tab.propIndex.Value.bin.cb = CbEID(peid); <br>        ntfTemp.info.tab.propIndex.Value.bin.lpb = (BYTE *) peid; <br>        memset(&amp;(ntfTemp.info.tab.propPrior), 0, sizeof(SPropValue)); <br>        ntfTemp.info.tab.row.cValues = 0; <br>        ntfTemp.info.tab.row.lpProps = NULL; <br>    } <br>    else <br>    { <br>        AssertSz(ulTableEvent == TABLE_ROW_ADDED, <br>            "Bad event type: about to send bogus internal notification"); <br> <br>        memset(&amp;(ntfTemp.info.tab.propIndex), 0, sizeof(SPropValue)); <br>        memset(&amp;(ntfTemp.info.tab.propPrior), 0, sizeof(SPropValue)); <br>        ntfTemp.info.tab.row = *prw; <br>    } <br> <br>    sc = ScCountNotifications(1, &amp;ntfTemp, &amp;cbNtf); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    hr = HrAlloc(CbNewONB(cbNtf), &amp;ponb); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    ponb-&gt;cbNtf = cbNtf; <br> <br>    sc = ScCopyNotifications(1, &amp;ntfTemp, (LPVOID) ponb-&gt;abNtf, &amp;cbOut); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    AssertSz(cbOut == cbNtf, "ScCopyNotifications used a different # of bytes " <br>        "than ScCountNotifications returned."); <br> <br>    ponb-&gt;ftBeforeUpdate = *pftBeforeUpdate; <br>    ponb-&gt;ftAfterUpdate = pims-&gt;ftOGQueue; <br> <br>    /* Pass across the notification's memory offset so that the receiving */ <br>    /* process can relocate the notification to its address space. */ <br>    ponb-&gt;pvRef = (LPVOID) ponb-&gt;abNtf; <br>     <br>    ntf.ulEventType = fnevExtended; <br>    ntf.info.ext.ulEvent = 0; <br>    ntf.info.ext.cb = CbONB(ponb); <br>    ntf.info.ext.pbEventParameters = (LPBYTE) ponb; <br> <br>    hr = pims-&gt;psup-&gt;lpVtbl-&gt;Notify(pims-&gt;psup, lpKey, 1, &amp;ntf, &amp;ulFlags); <br> <br>exit: <br>    FreeNull(lpKey); <br>    FreeNull(ponb); <br> <br>    DebugTraceResult(HrNotifyOnOutgoingQueue, hr); <br>    return hr; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
