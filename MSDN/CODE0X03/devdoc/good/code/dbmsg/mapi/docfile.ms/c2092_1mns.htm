<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPRFS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2098"></a>MSPRFS.C</h2>
<pre><code>/* <br> *  M S P R F S . C <br> * <br> *  Code for implementing Get/SetReceiveFolder for the Message <br> *  Store object. <br> * <br> *  Hungarian shorthand: <br> *      To avoid excessively long identifier names, throughout this <br> *      file, RFS is used to mean "Receive Folder Settings", and RFN <br> *      is used to mean an RFS Node. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br> <br>/* Manifest constants */ <br> <br>TCHAR szRFSStreamName[] = TEXT("RFS_STREAM"); <br> <br>/* GRoup of Flags (grf): <br> * <br> * grfStorageOpen:      Flags used to open a read/write OLE IStorage object. <br> * grfStorageOpenRO:    Flags used to open a read only OLE IStorage object. <br> * grfStorageCreate:    Flags used to create an OLE IStorage object. <br> * grfStreamOpen:       Flags used to open a read/write OLE IStream object. <br> * grfStreamOpenRO:     Flags used to open a read only OLE IStream object. <br> * grfStreamCreate:     Flags used to create an OLE IStream object. <br> * <br> * See the OLE 2 Programmer's Reference for details on these flags. <br> */ <br> <br>#define grfStorageOpen      STGM_READWRITE | STGM_SHARE_EXCLUSIVE | \ <br>                                STGM_TRANSACTED <br>#define grfStorageOpenRO    STGM_READ | STGM_SHARE_EXCLUSIVE | \ <br>                                STGM_TRANSACTED <br>#define grfStorageCreate    grfStorageOpen | STGM_FAILIFTHERE | STGM_CREATE <br> <br>#define grfStreamOpen       STGM_SHARE_EXCLUSIVE | STGM_READWRITE <br>#define grfStreamOpenRO     STGM_SHARE_EXCLUSIVE | STGM_READ <br>#define grfStreamCreate     grfStreamOpen | STGM_FAILIFTHERE <br> <br>/* Function prototypes */ <br> <br>static HRESULT OpenRFSStream(PRFS prfs, BOOL fModify, IStream **lppstream, <br>    LPSTORAGE *lppstg); <br>static void CloseRFSStream(IStream * lpstream, LPSTORAGE lpstg); <br> <br>/* <br> *  Exported functions <br> */ <br> <br>/* <br> *  FIsValidMessageClass <br> * <br> *  Purpose: <br> *      Checks to see if a message class is valid.  A valid message <br> *      class is defined to be a series of one or more <br> *      period-delimited tokens with each token being a series of <br> *      one or more ASCII characters in the range 32-126 <br> *      (inclusive) excluding period.  Note that this definition <br> *      excludes message classes with a leading or trailing <br> *      period, or two or more consecutive periods, because this <br> *      would imply the existence of a zero-length token. <br> * <br> *      We put this function in the RFS module because dealing with <br> *      receive folders is the primary place in the Sample Store where we <br> *      care about message class. <br> * <br> *  Arguments: <br> *      szMessageClass  String identifying the message class. <br> * <br> *  Returns: <br> *      BOOL.  TRUE if szMessage is valid, FALSE if not. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>BOOL FIsValidMessageClass(LPTSTR szMessageClass) <br>{ <br>    TCHAR *pch = szMessageClass; <br>    BOOL fWasPeriod = TRUE; <br> <br>    if (szMessageClass &amp;&amp; IsBadStringPtr(szMessageClass, (UINT) -1)) <br>        return FALSE; <br> <br>    /* Handle the default message class */ <br> <br>    if (!szMessageClass || *szMessageClass == '\0') <br>        return TRUE; <br> <br>    /* disallow things:bad chars and cases where */ <br>    /* period is not a delim(.1, 1., and 1. .1 bad) */ <br>    while (*pch) <br>    { <br>        if (*pch &lt; 32 || *pch &gt; 126) <br>            return FALSE; <br>        if (*pch == '.') <br>        { <br>            if (fWasPeriod) <br>                return FALSE; <br>            fWasPeriod = TRUE; <br>        } <br>        else <br>            fWasPeriod = FALSE; <br>        pch++; <br>    } <br> <br>    return !fWasPeriod; <br>} <br> <br>/* <br> *  OpenRFS <br> * <br> *  Purpose: <br> *      Given an OLE2 storage object, opens a stream on it and <br> *      prepares it for handling receive folder settings.  OpenRFS <br> *      returns to the caller a pointer to the RFS structure which <br> *      is then used for access to the settings.  The stream format <br> *      of the receive folder settings is extremely simple:  the <br> *      first ULONG is a count of the number of RFNs in the <br> *      stream, and the nodes themselves follow sequentially <br> *      afterward.  A node on disk is not the same as an RFN in <br> *      memory.  On disk, it is a variable-sized structure <br> *      containing a ULONG which is the size (in bytes) of the <br> *      node not including this field, then a ULONG which is the <br> *      length (in bytes) of a <br> *      string containing the message class (NULL inclusive), which <br> *      immediately follows.  After that is a ULONG which is the <br> *      size (in bytes) of a string containing the relative path <br> *      name of the receive folder (NULL inclusive), which also <br> *      immediately follows.  Visually, a node looks like the <br> *      following: <br> * <br> *          +--------------------+ <br> *          | ULONG cbNode       | <br> *          +--------------------+ <br> *          | ULONG cbClass      | <br> *          +--------------------+ <br> *          | TCHAR szClass[]    | <br> *          |   .                | <br> *          |   .                | <br> *          |   .                | <br> *          +--------------------+ <br> *          | ULONG cbPath       | <br> *          +--------------------+ <br> *          | TCHAR szPath[]     | <br> *          |   .                | <br> *          |   .                | <br> *          |   .                | <br> *          +--------------------+ <br> * <br> *      The size of the message class name, cbClass, will always be <br> *      &gt; 0 for "valid" nodes (the default message class will be a <br> *      NULL string of size 1 TCHAR).  Thus, a value of 0 for <br> *      cbClass will signify a "free" node.  Free nodes are created <br> *      in the normal use of the stream by DeleteRFN, which <br> *      SetReceiveFolder calls, and are removed at close time (see <br> *      CloseRFS, below). <br> * <br> *      Note that, because string lengths are byte-sized but the <br> *      strings themselves are made of TCHARs, translation between <br> *      BYTE and TCHAR sizes must be done. <br> * <br> *  Arguments: <br> *      szStoreRoot Full path to the sample store "root" <br> *                      directory. <br> *      szFile      Relative path name of docfile containing <br> *                      receive folder settings. <br> *      ulFlags         Flags.  The following are defined: <br> *                      RFS_CREATE  Create the docfile containing <br> *                                  receive folder settings <br> *                                  (default opens existing). <br> *      pprfs           Location in which to return a pointer to <br> *                      the newly created RFS structure. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      Various. <br> */ <br>HRESULT OpenRFS(LPTSTR szStoreRoot, LPTSTR szFile, ULONG ulFlags, PRFS *pprfs) <br>{ <br>    HRESULT hr = hrSuccess; <br>    HRESULT hrStg = hrSuccess; <br>    SCODE sc; <br>    LPTSTR szFullPath = NULL; <br>    ULONG cRFN = 0L; <br>    LPSTORAGE lpstg = NULL; <br>    IStream *lpstream = NULL; <br>    PRFS prfs = NULL; <br> <br>#ifdef _WIN32 <br>    OLE_CHAR szOle[MAX_PATH]; <br>    int cbOle = 0L; <br> <br>#else <br>    OLE_CHAR *szOle; <br> <br>#endif <br>    LARGE_INTEGER liBeg; <br> <br>    /* initial default receive folder settings */ <br>    ULONG cInitRFNs = 1;        /* number of default nodes */ <br> <br>#pragma pack(1) <br>    struct RFN <br>    { <br>        ULONG cbNode; <br>        ULONG cbClass; <br>        TCHAR szClass; <br>        ULONG cbFolder; <br>        TCHAR szFolderPath; <br>    } DefaultNode = <br>    { <br>        (2 * sizeof(ULONG)) + (2 * sizeof(TCHAR)), <br>        sizeof(TCHAR), <br>        '\0', <br>        sizeof(TCHAR), <br>        '\0' <br>    }; <br>#pragma pack() <br> <br>    LISet32(liBeg, 0);  /* This is an OLE initializer macro */ <br> <br>    AssertSz(szStoreRoot, "Bad szStoreRoot"); <br>    AssertSz(szFile, "Bad szFile"); <br>    AssertSz(pprfs, "Bad pprfs"); <br> <br>    hr = HrAppendPath(szStoreRoot, szFile, &amp;szFullPath); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    sc = ScAllocZ(sizeof(RFS), &amp;prfs); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    prfs-&gt;szFile = szFullPath; <br> <br>#ifdef _WIN32 <br>    cbOle = 1 + lstrlen(szFullPath); <br>    Assert(cbOle &lt; MAX_PATH); <br>    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szFullPath, cbOle, szOle, cbOle); <br>#else <br>    szOle = szFullPath; <br>#endif <br> <br>    if (ulFlags &amp; RFS_CREATE) <br>    { <br>        hrStg = StgCreateDocfile(szOle, grfStorageCreate, 0, &amp;lpstg); <br> <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>#ifdef _WIN32 <br>        cbOle = 1 + lstrlen(szRFSStreamName); <br>        Assert(cbOle &lt; MAX_PATH); <br>        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szRFSStreamName, cbOle, <br>                szOle, cbOle); <br>#else <br>        szOle = szRFSStreamName; <br>#endif <br>        hrStg = lpstg-&gt;lpVtbl-&gt;CreateStream(lpstg, szOle, grfStreamCreate, <br>                0, 0, &amp;lpstream); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        /* Initialize the newly created stream */ <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, liBeg, STREAM_SEEK_SET, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        /* add the default RFS setting of the root (path = '\0') */ <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, (LPVOID) &amp;cInitRFNs, <br>                sizeof cInitRFNs, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, (LPVOID) &amp;DefaultNode, <br>                DefaultNode.cbNode + sizeof(ULONG), NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        /* Commit docfile changes.  If we don't do this now, the file on  */ <br>        /* disk will NOT be a docfile (i.e. OLE2 will not recognize it as */ <br>        /* a docfile) if opened again with no other changes made to it.   */ <br> <br>        hrStg = lpstg-&gt;lpVtbl-&gt;Commit(lpstg, 0); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br>    } <br>    else        /* Open an existing stream */ <br>    { <br>        hr = OpenRFSStream(prfs, FALSE, &amp;lpstream, &amp;lpstg); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, liBeg, STREAM_SEEK_SET, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cRFN, <br>                sizeof cRFN, NULL); <br> <br>        /* fall through to error handler */ <br>    } <br> <br>stg_err: <br>    if (hrStg != hrSuccess) <br>        hr = ResultFromScode(MapStorageSCode(GetScode(hrStg))); <br> <br>exit: <br>    if (lpstream) <br>    { <br>        CloseRFSStream(lpstream, lpstg); <br>        lpstg = NULL; <br>    } <br> <br>    if (hr != hrSuccess) <br>    { <br>        FreeNull(szFullPath); <br>        FreeNull(prfs); <br>        UlRelease(lpstg); <br>    } <br>    else <br>        *pprfs = prfs; <br> <br>    DebugTraceResult(OpenRFS, hr); <br>    return hr; <br>} <br> <br>/* <br> *  GetRFN <br> * <br> *  Purpose: <br> *      Returns an RFN containing the receive folder setting <br> *      for the message class that is passed in as a parameter.  If <br> *      there is not a receive folder setting for this particular <br> *      message class, the "best match" is returned, with best <br> *      match being defined in GetReceiveFolder (see msgstobj.c). <br> *      the way we measure this best match is to have a match index <br> *      which is incremented every time a section of the message <br> *      class is matched.  These values begin at 2 because 1 is <br> *      reserved for the default message class.  For example, the <br> *      message class "IPM.Note.Phone" matches against the <br> *      following receive folder settings in the following way: <br> * <br> *          "" (default)        1 <br> *          "IPM"               2 <br> *          "IPM.Note"          3 <br> *          "IPM.Note.Phone"    4 <br> *          "IPC"               0 <br> * <br> *  Arguments: <br> *      prfs            Pointer to the RFS context. <br> *      szClassName     Name of the message class for which to <br> *                      search for a receive folder setting. <br> *      pprfn           Address of location in which to return a <br> *                      pointer to an RFN structure containing <br> *                      the message class and folder name of the <br> *                      "best match" receive folder setting. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      Various. <br> * <br> *  Notes: <br> *      Use FreeRFN() to release the memory of the returned <br> *      RFN structure in *pprfn. <br> */ <br>HRESULT GetRFN(PRFS prfs, LPTSTR szClassName, PRFN *pprfn) <br>{ <br>    HRESULT hr = hrSuccess; <br>    HRESULT hrStg = hrSuccess; <br>    SCODE sc = S_OK; <br>    LPSTORAGE lpstg = NULL; <br>    LPSTREAM lpstream = NULL; <br>    PRFN prfn = NULL; <br>    ULONG ibNextNode = 0L; <br>    ULONG ibMatchNode = 0L; <br>    ULONG cbNode = 0L; <br>    ULONG cbClass = 0L; <br>    ULONG cRFN = 0L; <br>    UINT uiMatchLvl = 0; <br>    UINT ui = 0; <br>    TCHAR rgch[1024]; <br>    LARGE_INTEGER li; <br>    ULONG cbCls = 0L; <br>    ULONG cbName = 0L; <br> <br>    AssertSz(prfs, "Bad prfs"); <br>    AssertSz(szClassName, "Bad szClassName"); <br>    AssertSz(pprfn, "Bad pprfn"); <br> <br>    hr = OpenRFSStream(prfs, FALSE, &amp;lpstream, &amp;lpstg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Read the count of RFS nodes from the stream. */ <br> <br>    LISet32(li, 0);     /* This is an OLE initializer macro */ <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, li, STREAM_SEEK_SET, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cRFN, <br>            sizeof cRFN, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    /* Loop over nodes, looking for the best message class match */ <br> <br>    for (ui = 0, ibNextNode = sizeof cRFN; ui &lt; cRFN; ui++) <br>    { <br>        /* Set seek pointer to beginning of this node */ <br> <br>        LISet32(li, ibNextNode); <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, li, STREAM_SEEK_SET, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        /* Need to have an absolute index to the NEXT node. */ <br>        /* Remember:  cbNode is not self-inclusive, so the  */ <br>        /* next node is (cbNode + sizeof cbNode) from the   */ <br>        /* current node.                                    */ <br> <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cbNode, <br>                sizeof cbNode, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        ibNextNode += cbNode + sizeof cbNode; <br> <br>        /* Get and compare message class */ <br> <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cbClass, <br>                sizeof cbClass, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        AssertSz(sizeof rgch &gt;= cbClass, "Message class too big!"); <br> <br>        if (cbClass &gt; 0L)       /* If it's not a free node */ <br>        { <br>            UINT uiMatchCur = 0; <br> <br>            hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) rgch,  <br>                    cbClass, NULL); <br>            if (hrStg != hrSuccess) <br>                goto stg_err; <br> <br>            if (rgch[0] == '\0') <br>            { <br>                uiMatchCur = 1; <br>            } <br>            else <br>                /* count the matching message class sections */ <br>            { <br>                TCHAR *pch1 = rgch; <br>                TCHAR *pch1Ahead = NULL; <br>                TCHAR *pch2 = szClassName; <br>                TCHAR *pch2Ahead = NULL; <br> <br>                /* if matching against a class that is less refined than */ <br>                /* what we are searching for return 0 */ <br>                if (lstrlen(szClassName) &gt;= lstrlen(rgch)) <br>                { <br>                    while (*pch1 &amp;&amp; *pch2) <br>                    { <br>                        for (pch1Ahead = pch1 + 1; *pch1Ahead &amp;&amp; <br>                            *pch1Ahead != '.'; pch1Ahead++) <br>                            ; <br>                        for (pch2Ahead = pch2 + 1; *pch2Ahead &amp;&amp; <br>                            *pch2Ahead != '.'; pch2Ahead++) <br>                            ; <br>                        if (pch1Ahead - pch1 == pch2Ahead - pch2 &amp;&amp; <br>                            !memcmp(pch1, pch2, pch1Ahead - pch1)) <br>                        { <br>                            uiMatchCur++; <br>                            pch1 = pch1Ahead; <br>                            pch2 = pch2Ahead; <br>                        } <br>                        else <br>                            break; <br>                    } <br>                } <br>                /* We want to match a "real" setting higher than the */ <br>                /* default, so we increment a real match to be &gt; 1.  */ <br> <br>                if (uiMatchCur &gt; 0) <br>                { <br>                    uiMatchCur++; <br>                } <br>            } <br> <br>            if (uiMatchCur &gt; uiMatchLvl) <br>            { <br>                /* Here we set ibMatchNode to be the absolute index of */ <br>                /* the cbClass member of the node (NOT the cbNode      */ <br>                /* member.  When we seek back to this position, we can */ <br>                /* begin reading the cbClass immediately (see below).  */ <br> <br>                ibMatchNode = ibNextNode - cbNode; <br>                uiMatchLvl = uiMatchCur; <br>            } <br>        } <br>    } <br> <br>    if (uiMatchLvl == 0) <br>    { <br>        hr = ResultFromScode(MAPI_E_NOT_FOUND); <br>        goto exit; <br>    } <br> <br>    /* Set the return variable w/best match */ <br> <br>    sc = ScAllocZ(sizeof(RFN), (PPV) &amp;prfn); <br>    if (sc != S_OK) <br>        goto sc_err; <br> <br>    /* Goto best match node, but seek pointer will be past cbNode */ <br> <br>    LISet32(li, ibMatchNode); <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, li, STREAM_SEEK_SET, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    /* Read in class name */ <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cbCls, <br>            sizeof cbCls, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    sc = ScAlloc(cbCls, (PPV) &amp;prfn-&gt;szClass); <br>    if (sc != S_OK) <br>        goto sc_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, <br>            (LPVOID) prfn-&gt;szClass, cbCls, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    /* Read in folder name */ <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cbName, <br>            sizeof cbName, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    sc = ScAlloc(cbName, (PPV) &amp;prfn-&gt;szName); <br>    if (sc != S_OK) <br>        goto sc_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, <br>            (LPVOID) prfn-&gt;szName, cbName, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>sc_err: <br>    if (sc != S_OK) <br>    { <br>        Assert(hr == hrSuccess); <br>        Assert(hrStg == hrSuccess); <br>        hr = ResultFromScode(sc); <br>    } <br> <br>stg_err: <br>    if (hrStg != hrSuccess) <br>    { <br>        Assert(sc == S_OK); <br>        Assert(hr == hrSuccess); <br>        hr = ResultFromScode(MapStorageSCode(GetScode(hrStg))); <br>    } <br> <br>exit: <br>    if (lpstream) <br>        CloseRFSStream(lpstream, lpstg); <br> <br>    if (hr != hrSuccess) <br>        FreeRFN(prfn); <br>    else <br>        *pprfn = prfn; <br> <br>    DebugTraceResult(GetRFN, hr); <br>    return hr; <br>} <br> <br>/* <br> -  FreeRFN <br> - <br> *  Release the memory of an RFN allocated and returned <br> *  by the GetRFN() procedure. <br> */ <br>void FreeRFN(PRFN prfn) <br>{ <br>    if (prfn) <br>    { <br>        (void)FreeNull((LPVOID) prfn-&gt;szClass); <br>        (void)FreeNull((LPVOID) prfn-&gt;szName); <br>        (void)FreeNull((LPVOID) prfn); <br>    } <br>} <br> <br>/* <br> *  DeleteRFN <br> * <br> *  Purpose: <br> *      Delete the receive folder setting associated with a <br> *      particular message class.  We do this by "zeroing out" the <br> *      node on disk, rather than actually removing it and <br> *      compacting the stream.  We can easily zero out the node <br> *      once we've found the right one by setting the length of the <br> *      message class string contained in it to be zero (an invalid <br> *      value). <br> * <br> *  Arguments: <br> *      prfs            Pointer to the RFS context to use. <br> *      szClassName     Buffer containing the name of the message <br> *                      class for which to remove the receive <br> *                      folder setting.  We do a linear search <br> *                      through the stream to find the node on disk <br> *                      with a matching message class. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      Various. <br> */ <br>HRESULT DeleteRFN(PRFS prfs, LPTSTR szClassName) <br>{ <br>    HRESULT hr = hrSuccess; <br>    HRESULT hrStg = hrSuccess; <br>    LPSTORAGE lpstg = NULL; <br>    IStream *lpstream = NULL; <br>    ULONG ibNextNode = 0L; <br>    ULONG cbNode = 0L; <br>    ULONG cbClass = 0L; <br>    ULONG cRFN = 0L; <br>    UINT ui = 0; <br>    TCHAR rgch[1024]; <br>    LARGE_INTEGER li; <br> <br>    AssertSz(prfs, "Bad prfs"); <br>    AssertSz(szClassName, "Bad szClassName"); <br> <br>    hr = OpenRFSStream(prfs, TRUE, &amp;lpstream, &amp;lpstg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Read the count of RFS nodes from the stream. */ <br> <br>    LISet32(li, 0);     /* This is an OLE initializer macro */ <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, li, STREAM_SEEK_SET, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cRFN, <br>            sizeof cRFN, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    /* Loop over nodes, looking for a message class match */ <br> <br>    for (ui = 0, ibNextNode = sizeof cRFN; ui &lt; cRFN; ui++) <br>    { <br>        /* Set seek pointer to beginning of first node */ <br> <br>        LISet32(li, ibNextNode); <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, li, STREAM_SEEK_SET, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        /* Need to have an absolute index to the NEXT node. */ <br>        /* Remember:  cbNode is not self-inclusive, so the  */ <br>        /* next node is (cbNode + sizeof cbNode) from the   */ <br>        /* current node.                                    */ <br> <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cbNode, <br>                sizeof cbNode, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        ibNextNode += cbNode + sizeof cbNode; <br> <br>        /* Get and compare message class */ <br> <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cbClass, <br>                sizeof cbClass, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        AssertSz(sizeof rgch &gt;= cbClass * sizeof(TCHAR), <br>            "Message class too big!"); <br> <br>        if (cbClass &gt; 0L)       /* If it's not a free node */ <br>        { <br>            hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) rgch, <br>                    cbClass, NULL); <br>            if (hrStg != hrSuccess) <br>                goto stg_err; <br> <br>            if (cbClass == Cbtszsize(szClassName) <br>                &amp;&amp; !memcmp(szClassName, rgch, (UINT) cbClass)) <br>            { <br>                LONG ibClass = 0L; <br> <br>                /* Seek back to cbClass */ <br> <br>                ibClass -= (LONG) (cbClass + sizeof cbClass); <br>                LISet32(li, ibClass); <br>                hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, li, <br>                        STREAM_SEEK_CUR, NULL); <br>                if (hrStg != hrSuccess) <br>                    goto stg_err; <br> <br>                /* Zero out the node */ <br> <br>                cbClass = 0L; <br>                hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, <br>                        (LPVOID) &amp;cbClass, sizeof cbClass, NULL); <br>                if (hrStg != hrSuccess) <br>                    goto stg_err; <br> <br>                /* Commit the change */ <br> <br>                hrStg = lpstg-&gt;lpVtbl-&gt;Commit(lpstg, 0); <br>                if (hrStg != hrSuccess) <br>                    goto stg_err; <br> <br>                break; <br>            } <br>        } <br>    } <br> <br>stg_err: <br>    if (hrStg) <br>        hr = ResultFromScode(MapStorageSCode(GetScode(hrStg))); <br> <br>exit: <br>    if (lpstream) <br>        CloseRFSStream(lpstream, lpstg); <br> <br>    DebugTraceResult(DeleteRFN, hr); <br>    return hr; <br>} <br> <br>/* <br> *  AddRFN <br> * <br> *  Purpose: <br> *      Adds a node (on disk) to the stream that holds receive <br> *      folder settings for a message store.  Does this by creating <br> *      a new node at the current End-Of-Stream (at the end of all <br> *      other nodes). <br> * <br> *  Arguments: <br> *      prfs        Pointer to the receive folder storage context. <br> *      prfn    Pointer to the new node to add. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      Various. <br> */ <br>HRESULT AddRFN(PRFS prfs, PRFN prfn) <br>{ <br>    HRESULT hr = hrSuccess; <br>    HRESULT hrStg = hrSuccess; <br>    LPSTORAGE lpstg = NULL; <br>    IStream *lpstream = NULL; <br>    UINT ui = 0; <br>    ULONG cb = 0L; <br>    ULONG cbNode = 0L; <br>    ULONG cbClass = 0L; <br>    ULONG cbName = 0L; <br>    ULONG cRFN = 0L; <br>    LARGE_INTEGER liEOS; <br> <br>    AssertSz(prfs, "Bad prfs"); <br>    AssertSz(prfn, "Bad prfn"); <br>    AssertSz(prfn-&gt;szClass, "Bad prfn-&gt;szClass"); <br>    AssertSz(prfn-&gt;szName, "Bad prfn-&gt;szName"); <br> <br>    hr = OpenRFSStream(prfs, TRUE, &amp;lpstream, &amp;lpstg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Find the end of the stream.  Strictly speaking, we can't just seek */ <br>    /* the current End-Of-Stream (what the IStream thinks is it's current */ <br>    /* EOS), because we really want to be at the end of the last node,    */ <br>    /* and there may have been stuff written after (from a failed write). */ <br>    /* First, read the count of RFS nodes from the stream. */ <br> <br>    LISet32(liEOS, 0);      /* This is an OLE initializer macro */ <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, liEOS, STREAM_SEEK_SET, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cRFN, <br>            sizeof cRFN, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    for (ui = 0; ui &lt; cRFN; ui++) <br>    { <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Read(lpstream, (LPVOID) &amp;cb, <br>                sizeof cb, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br> <br>        LISet32(liEOS, (LONG) cb); <br> <br>        hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, liEOS, STREAM_SEEK_CUR, NULL); <br>        if (hrStg != hrSuccess) <br>            goto stg_err; <br>    } <br> <br>    /* Write out the node */ <br> <br>    /* Size of node: length of 2 strings + 2 NULL characters + 2 times */ <br>    /* the size of the space needed to hold the string lengths.        */ <br> <br>    cbClass = Cbtszsize(prfn-&gt;szClass); <br>    cbName = Cbtszsize(prfn-&gt;szName); <br>    cbNode = 2 * sizeof(ULONG) + cbClass + cbName; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, (LPVOID) &amp;cbNode, <br>            sizeof cbNode, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, (LPVOID) &amp;cbClass, <br>            sizeof cbClass, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, (LPVOID) prfn-&gt;szClass, <br>            cbClass, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, (LPVOID) &amp;cbName, <br>            sizeof cbName, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, (LPVOID) prfn-&gt;szName, <br>            cbName, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    /* Keep cRFN, the in-memory and on-disk */ <br>    /* copies, in sync with each other.     */ <br> <br>    LISet32(liEOS, 0L); <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Seek(lpstream, liEOS, STREAM_SEEK_SET, NULL); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    cRFN++; <br>    hrStg = lpstream-&gt;lpVtbl-&gt;Write(lpstream, (LPVOID) &amp;cRFN, <br>            sizeof cRFN, NULL); <br>    if (hrStg != hrSuccess) <br>    { <br>        cRFN--; <br>        goto stg_err; <br>    } <br> <br>    /* Commit the change */ <br> <br>    hrStg = lpstg-&gt;lpVtbl-&gt;Commit(lpstg, 0); <br>    /* if ( hrStg ), fall through to stg_err */ <br> <br>stg_err: <br>    if (hrStg) <br>        hr = ResultFromScode(MapStorageSCode(GetScode(hrStg))); <br> <br>exit: <br>    if (lpstream) <br>        CloseRFSStream(lpstream, lpstg); <br> <br>    DebugTraceResult(AddRFN, hr); <br>    return hr; <br>} <br> <br>/* <br> *  CloseRFS <br> * <br> *  Purpose: <br> *      Frees and invalidates an open context for accessing receive <br> *      folder settings. <br> * <br> *  Arguments: <br> *      prfs        Pointer to the object to close. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      Various. <br> */ <br>HRESULT CloseRFS(PRFS prfs) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    AssertSz(prfs, "Bad prfs"); <br> <br>    FreeNull(prfs-&gt;szFile); <br>    FreeNull(prfs); <br> <br>    DebugTraceResult(CloseRFS, hr); <br>    return hr; <br>} <br> <br>/* <br> *  Internal functions <br> */ <br> <br>/* <br> *  OpenRFSStream <br> * <br> *  Purpose: <br> *      Open the stream within a docfile that contains receive <br> *      folder settings. <br> * <br> *  Arguments: <br> *      prfs        Receive folder settings context. <br> *      fModify     TRUE indicates the caller wants write access. <br> *      lppstream   Address in which to return a pointer to the <br> *                  newly opened stream. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      Various storage errors. <br> */ <br>static HRESULT OpenRFSStream(PRFS prfs, BOOL fModify, IStream **lppstream, <br>    LPSTORAGE *lppstg) <br>{ <br>    HRESULT hr = hrSuccess; </code></pre>
<p>
</p>
<pre><code>HRESULT hrStg = hrSuccess; <br>    DWORD grfMode; <br> <br>#ifdef _WIN32 <br>    OLE_CHAR szOle[MAX_PATH]; <br>    int cbOle = 0L; <br>#else <br>    OLE_CHAR *szOle; <br>#endif <br> <br>    LPSTORAGE lpstg = NULL; <br>    IStream *lpstream = NULL; <br> <br>    AssertSz(prfs, "Bad prfs"); <br>    AssertSz(lppstream, "Bad lppstream"); <br> <br>#ifdef _WIN32 <br>    cbOle = 1 + lstrlen(prfs-&gt;szFile); <br>    Assert(cbOle &lt; MAX_PATH); <br>    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, prfs-&gt;szFile, cbOle, szOle, cbOle); <br>#else <br>    szOle = prfs-&gt;szFile; <br>#endif <br> <br>    if (fModify) <br>        grfMode = STGM_SHARE_EXCLUSIVE | STGM_READWRITE; <br>    else <br>        grfMode = STGM_SHARE_EXCLUSIVE | STGM_READ; <br> <br>    hrStg = StgOpenStorage(szOle, NULL, grfMode | STGM_TRANSACTED, NULL, <br>            0, &amp;lpstg); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>#ifdef _WIN32 <br>    cbOle = 1 + lstrlen(szRFSStreamName); <br>    Assert(cbOle &lt; MAX_PATH); <br>    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szRFSStreamName, cbOle, szOle, cbOle); <br>#else <br>    szOle = szRFSStreamName; <br>#endif <br> <br>    hrStg = lpstg-&gt;lpVtbl-&gt;OpenStream(lpstg, szOle, NULL, grfMode, 0, &amp;lpstream); <br>    if (hrStg != hrSuccess) <br>        goto stg_err; <br> <br>    /* WARNING:  If any code is added between here and the error handler */ <br>    /* that can fail, a check in the error handler must be added to free */ <br>    /* the open stream in the event of an error.                         */ <br> <br>    *lppstream = lpstream; <br>    *lppstg = lpstg; <br> <br>stg_err: <br>    if (hrStg != hrSuccess) <br>        hr = ResultFromScode(MapStorageSCode(GetScode(hrStg))); <br> <br>    if (hr != hrSuccess) <br>        UlRelease(lpstg); <br> <br>    DebugTraceResult(OpenRFSStream, hr); <br>    return hr; <br>} <br> <br>/* <br> *  CloseRFSStream <br> * <br> *  Purpose: <br> *      Close the stream within a docfile that holds receive folder <br> *      settings. <br> * <br> *  Arguments: <br> *      lpstream    Pointer to the stream. <br> *      lpstg       Pointer to the storage instance in which this <br> *                  stream resides. <br> * <br> *  Returns: <br> *      void <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>static void CloseRFSStream(IStream *lpstream, LPSTORAGE lpstg) <br>{ <br>    AssertSz(lpstream, "Bad lpstream"); <br>    AssertSz(lpstg, "Bad lpstg"); <br> <br>    NFSideAssertSz(UlRelease(lpstream) == 0L, "lpstream not released"); <br>    NFSideAssertSz(UlRelease(lpstg) == 0L, "lpstg not released"); <br> <br>    return; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
