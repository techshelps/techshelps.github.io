<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPMS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2093"></a>MSPMS.C</h2>
<pre><code>/* <br> *  M S P M S . C <br> * <br> *  Code for the MAPI Sample Store Provider implementation of the <br> *  IMsgStore object. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br>#include &lt;stdarg.h&gt; <br> <br>#define MS_ValidateParameters(pobj, intf, method, arglist)      \ <br>        OBJ_ValidateParameters(pobj, intf, method, sizeof(IMS), &amp;vtblIMS, arglist) <br> <br>static HRESULT HrGetSequenceNum(PEID peid, ULONG *pulSequenceNum); <br>static HRESULT HrGetSMSStandardNotifKey(PIMS pims, PEID peid, <br>    LPNOTIFKEY * lppKey); <br> <br>/* Dispatch table for IMsgStore objects */ <br>IMS_Vtbl vtblIMS = <br>{ <br>    (IMS_QueryInterface_METHOD *)   OBJ_QueryInterface, <br>    (IMS_AddRef_METHOD *)           OBJ_AddRef, <br>    (IMS_Release_METHOD *)          OBJ_Release, <br>    IMS_GetLastError, <br>    IMS_SaveChanges, <br>    IMS_GetProps, <br>    IMS_GetPropList, <br>    IMS_OpenProperty, <br>    IMS_SetProps, <br>    IMS_DeleteProps, <br>    IMS_CopyTo, <br>    IMS_CopyProps, <br>    IMS_GetNamesFromIDs, <br>    IMS_GetIDsFromNames, <br> <br>    IMS_Advise, <br>    IMS_Unadvise, <br>    IMS_CompareEntryIDs, <br>    IMS_OpenEntry, <br>    IMS_SetReceiveFolder, <br>    IMS_GetReceiveFolder, <br>    IMS_GetReceiveFolderTable, <br>    IMS_StoreLogoff, <br>    IMS_AbortSubmit, <br> <br>    IMS_GetOutgoingQueue, <br>    IMS_SetLockState, <br>    IMS_FinishedMsg, <br>    IMS_NotifyNewMail, <br>}; <br> <br>/* definitions for outgoing queues */ <br>CALLERRELEASE OutgoingViewRelease; <br> <br>/* <br> *  Object methods <br> */ <br> <br>/* <br> *  IMS_GetLastError [also called by IMSLogon, IMAPIFolder, IMessage, and IAttach] <br> * <br> *  Purpose: <br> *      Returns a localized text error message associated with the <br> *      last error which occurred on a specific object (in <br> *      actuality, the SCODE used is associated with the HRESULT <br> *      passed in, and it is not checked that this HRESULT matches <br> *      that of the last error on this object -- providing a <br> *      different HRESULT will very likely return an inconsistent <br> *      error message, though). <br> * <br> *  Arguments: <br> *      pobj            Pointer to the object. <br> *      hError          HRESULT containing the error code returned <br> *                      by the last failed call on this object. <br> *      ulFlags         MAPI_UNICODE, string8 is default <br> *      pulLLErr        location to place the low level error code <br> *                      (may be NULL) <br> *      pszMessage      Location in which to return an address to <br> *                      an allocated buffer containing the <br> *                      localized text error message. <br> *      pszComponent    Location in which to return an address to <br> *                      an allocated buffer containing the <br> *                      name of the component producing the error. <br> *      lpulContext     Location in which to return a context number <br> *                      for finding help within the Component's help file. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Unable to allocate memory for <br> *                                  the return parameter. <br> *      MAPI_E_INVALID_PARAMETER    hError contains an unknown <br> *                                  SCODE. <br> */ <br>STDMETHODIMP IMS_GetLastError(PIMS pobj, HRESULT hError, ULONG ulFlags, <br>    LPMAPIERROR * lppMapiError) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE   sc; <br>    PIMS pims; <br>    LPTSTR pszMessage   = NULL; <br>     <br>    #ifdef VALIDATE <br>    if (IsBadWritePtr(pobj, sizeof(OBJ)) <br>        || (pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIMS <br>            &amp;&amp; pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblMSL <br>            &amp;&amp; pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIFLD <br>            &amp;&amp; pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIMSG <br>            &amp;&amp; pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIATCH)) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br>         <br>    Validate_IMAPIProp_GetLastError(pobj, hError, ulFlags, lppMapiError); <br> <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    OBJ_EnterCriticalSection((POBJ) pobj); <br> <br>    pims = pobj-&gt;pims; <br> <br>    /* //$ Add param checking and correctly return Component &amp; Context */ <br>    *lppMapiError = NULL; <br>     <br>    sc = LMAlloc( &amp;pims-&gt;lmr, sizeof( MAPIERROR ), lppMapiError ); <br>    if ( FAILED( sc ) ) <br>    { <br>        hr = ResultFromScode( sc ); <br>        goto ret; <br>    } <br>     <br>    memset( *lppMapiError, 0, sizeof( MAPIERROR ) ); <br>     <br>    (*lppMapiError)-&gt;ulVersion = MAPI_ERROR_VERSION;     <br> <br>    hr = MapScodeSz(GetScode(hError), pims, &amp;pszMessage); <br>    if ( HR_FAILED( hr ) ) <br>        goto ret; <br>     <br>    sc = LMAllocMore( &amp;pims-&gt;lmr, Cbtszsize( pszMessage ), *lppMapiError, <br>            &amp;(*lppMapiError)-&gt;lpszError ); <br>     <br>    if ( FAILED( sc ) ) <br>    { <br>        hr = ResultFromScode( sc ); <br>        goto ret; <br>    } <br>     <br>    lstrcpy( (*lppMapiError)-&gt;lpszError, pszMessage ); <br> <br>ret: <br>     <br>    if ( hr )    <br>    { <br>        LMFree( &amp;pims-&gt;lmr, *lppMapiError ); <br>        *lppMapiError = NULL; <br>    } <br>     <br>    LMFree( &amp;pims-&gt;lmr, pszMessage ); <br>     <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    DebugTraceResult(IMS_GetLastError, hr); <br>    return HrCheckHr(hr, IUnknown_GetLastError); <br>} <br> <br>/* <br> *  IMS_SaveChanges [Also used by IMAPIFolder] <br> * <br> *  Purpose: <br> *      Saves changes made to the message store object properties <br> *      (does not propagate to sub-objects).  Because changes to <br> *      message store object properties show up immediately, <br> *      however, this call does nothing (but returns success). <br> * <br> *  Arguments: <br> *      pims        Pointer to the object. <br> *      ulFlags     Flags.  The following are defined: <br> *                  KEEP_OPEN_READONLY  Do not invalidate the <br> *                                      object, make it read-only. <br> *                  KEEP_OPEN_READWRITE Don't invalidate the <br> *                                      object, keep it open <br> *                                      read/write. <br> *                  FORCE_SAVE          Overwrite any changes made by <br> *                                      others since store was opened <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDMETHODIMP IMS_SaveChanges(PIMS pims, ULONG ulFlags) <br>{ <br>    #ifdef VALIDATE <br>    if (    IsBadWritePtr(pims, sizeof(OBJ)) <br>        ||  (   pims-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIMS <br>            &amp;&amp;  pims-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIFLD)) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    Validate_IMAPIProp_SaveChanges(pims, ulFlags); <br>    #endif <br> <br>    return hrSuccess; <br>} <br> <br>/* <br> *  IMS_GetProps <br> * <br> *  Purpose: <br> *      Returns to the caller the value(s) of one or more <br> *      properties existent on an IMS object.  The order of the <br> *      properties in the returned ppval structure exactly <br> *      matches the order in which the properties were requested in <br> *      ptaga.  The caller must free the returned <br> *      structure by calling MAPIFreeBuffer(*ppval), but <br> *      only if the function returns zero or the error <br> *      MAPI_W_ERRORS_RETURNED.  Uses the IMessage on IStorage <br> *      property interface implementation. <br> * <br> *  Arguments: <br> *      pims            Pointer to the object. <br> *      ptaga           Pointer to a counted array of property tags <br> *                      ("names") that identify the values to be <br> *                      returned. <br> *      ulFlags         UNICODE / String8 <br> *      pcval       Location in which to return the count of <br> *                      elements in *ppval. <br> *      ppval   Location in which to return an allocated <br> *                      array of property values (the caller frees <br> *                      by calling MAPIFreeBuffer). <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      If the call succeeded overall but access to one or more <br> *      properties failed, the function returns the warning <br> *      MAPI_W_ERRORS_RETURNED.  The calling application should <br> *      then check the Property Tag of each of the returned <br> *      properties to determine which ones failed.  Those that fail <br> *      have their Property Type set to PT_ERROR and their value (a <br> *      ULONG) indicates which error occurred. <br> * <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_W_ERRORS_RETURNED      See above. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IMS_GetProps(PIMS pims, LPSPropTagArray ptaga, ULONG ulFlags, <br>    ULONG *pcval, LPSPropValue *ppval) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMESSAGE lpmsg = NULL; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMAPIProp, <br>            GetProps, <br>            (pims,  <br>            ptaga,  <br>            ulFlags,  <br>            pcval,  <br>            ppval)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    IMS_EnterCriticalSection(pims); <br> <br>    /* If input parameters are okay, make GetProps call on lpmsgProps. */ <br> <br>    *pcval = 0L; <br>    *ppval = NULL; <br> <br>    hr = HrOpenIMSPropsFileRetry(pims-&gt;pmsgsess, pims-&gt;szProps, &amp;pims-&gt;lmr, <br>        pims-&gt;psup, FALSE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;GetProps(lpmsg, ptaga, ulFlags, pcval, ppval); <br> <br>    {if(HR_SUCCEEDED(hr)) <br>    { <br>        LPSPropValue pvalStoreSupMask = PpropFindProp(*ppval, *pcval,  <br>                                PROP_TAG(PT_UNSPECIFIED, PROP_ID(PR_STORE_SUPPORT_MASK))); <br>        if(pvalStoreSupMask) <br>        { <br>            pvalStoreSupMask-&gt;ulPropTag = PR_STORE_SUPPORT_MASK; <br>            pvalStoreSupMask-&gt;Value.l = SMS_SUPPORTMASK; <br> <br>            /* fix up hr */ <br>            if(ptaga-&gt;cValues == 1) <br>                hr = hrSuccess; <br>        } <br>    } <br>    } <br>    /* Wrap the store entryids. Note that this function takes as an */ <br>    /* argument the HRESULT from the previous GetProps call. */ <br>    /* We aren't ignoring the error. */ <br> <br>    hr = HrWrap_GetProps(hr, pims, 0, NULL, pcval, ppval, TRUE, <br>        (ptaga != NULL), (POBJ)pims); <br> <br>exit: <br>    UlRelease(lpmsg); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    #ifdef DEBUG <br>    if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) <br>        DebugTraceResult(IMS_GetProps, hr); <br>    #endif <br> <br>    return HrCheckHr(hr, IMAPIProp_GetProps); <br>} <br> <br>/* <br> *  IMS_GetPropList <br> * <br> *  Purpose: <br> *      Returns a list of all the properties currently accessible. <br> *      Uses the IMessage on IStorage property implementation. <br> * <br> *  Arguments: <br> *      pims        Pointer to the object. <br> *      ulFlags     UNICODE / String8 <br> *      pptaga      Location in which to return a pointer <br> *                  to a counted array of property tags. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                          to the requested properties. <br> *      MAPI_E_CALL_FAILED  The mechanism for making the <br> *                          call to the service provider <br> *                          failed. <br> */ <br>STDMETHODIMP IMS_GetPropList(PIMS pims, ULONG ulFlags, LPSPropTagArray * pptaga) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMESSAGE lpmsg = NULL; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMAPIProp, <br>            GetPropList, <br>            (pims,  <br>            ulFlags,  <br>            pptaga)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    IMS_EnterCriticalSection(pims); <br> <br>    /* If input parameters are okay, make GetPropList call on lpmsgProps. */ <br> <br>    hr = HrOpenIMSPropsFileRetry(pims-&gt;pmsgsess, pims-&gt;szProps, &amp;pims-&gt;lmr, <br>        pims-&gt;psup, FALSE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;GetPropList(lpmsg, ulFlags, pptaga); <br>    /* if ( hr ) fall through to exit */ <br> <br>exit: <br>    UlRelease(lpmsg); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_GetPropList, hr); <br>    return HrCheckHr(hr, IMAPIProp_GetPropList); <br>} <br> <br>/* <br> *  IMS_OpenProperty <br> * <br> *  Purpose: <br> *      Open a requested interface on a property for further <br> *      access.  Commonly used for stream access to a large binary <br> *      or text property.  This is the only way to access a <br> *      property of type PT_OBJECT, and may be used on other <br> *      properties depending on the implementation.  Uses the <br> *      IMessage on IStorage property implementation, but since the <br> *      transaction model for IMsgOnIStg does not match that for <br> *      IMsgStore, we fail this call.  (We could do a lot of work <br> *      to wrap the interface that IMsgOnIStg returns to us before <br> *      returning it to the client, but we don't.) <br> * <br> *  Arguments: <br> *      pims        Pointer to the object. <br> *      ulPropTag   Property tag for the desired property.  Only <br> *                  the ID bits of the tag are used; the type bits <br> *                  are ignored. <br> *      lpiid       Pointer to the GUID identifying which interface <br> *                  is desired. <br> *      lppUnk      Location in which to return a pointer to the <br> *                  newly created interface pointer. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Errors: <br> *      MAPI_E_INVALID_PARAMETER <br> *      MAPI_E_NO_SUPPORT   The requested interface is not <br> *                              available on the given property. <br> */ <br>STDMETHODIMP IMS_OpenProperty(PIMS pims, ULONG ulPropTag, LPCIID lpiid, <br>    ULONG ulInterfaceOptions, ULONG ulFlags, LPUNKNOWN * lppUnk) <br>{ <br>    SCODE sc; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMAPIProp, <br>            OpenProperty, <br>            (pims,  <br>            ulPropTag,  <br>            lpiid,  <br>            ulInterfaceOptions,  <br>            ulFlags,  <br>            lppUnk)); <br> <br>    sc = MAPI_E_NO_SUPPORT; <br>     <br>    DebugTraceSc(IFLD_OpenProperty, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> *  IMS_SetProps <br> * <br> *  Purpose: <br> *      Sets the value of one or more properties.  This call passes <br> *      a number of Property Value structures.  The Property Tag in <br> *      each indicates which property is having its values set and <br> *      the value indicates what should be stored.  The caller must <br> *      free the returned property problem structure by calling <br> *      MAPIFreeBuffer(*lppProblems), but only if the call <br> *      succeeded overall.  Uses the IMessage on IStorage property <br> *      implementation. <br> * <br> *  Arguments: <br> *      pims            Pointer to the object. <br> *      cValues         Number of values in lpPropArray. <br> *      lpPropArray     Pointer to a Property Value array. <br> *      lppProblems     Location in which to return a pointer to a <br> *                      counted array of property problem <br> *                      structures. <br> * <br> *  Returns: <br> *      HRESULT.  If the call succeeds overall, a zero is returned. <br> *      If there are problems with setting some or all of the <br> *      selected values, and a non-NULL is passed for lppProblems, <br> *      then a SPropProblemArray structure is returned with details <br> *      about each problem.  The value returned in lppProblems is <br> *      only valid if zero is returned in the HRESULT.  If an error <br> *      occurs on the call such that a non-zero value is returned <br> *      for the HRESULT then the contents of *lppProblems are <br> *      undefined.  In particular, do not use or free the structure <br> *      if an error occurs on the call. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_E_CALL_FAILED      A general problem affecting <br> *                                  access to all of the object's <br> *                                  properties occurred. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IMS_SetProps(PIMS pims, ULONG cValues, LPSPropValue lpPropArray, <br>    LPSPropProblemArray * lppProblems) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMESSAGE lpmsg = NULL; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMAPIProp, <br>            SetProps, <br>            (pims,  <br>            cValues,  <br>            lpPropArray,  <br>            lppProblems)); <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    if (!OBJ_TestFlag(pims, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* If input parameters are okay, make SetProps call on lpmsgProps. */ <br> <br>    hr = HrOpenIMSPropsFileRetry(pims-&gt;pmsgsess, pims-&gt;szProps, &amp;pims-&gt;lmr, <br>        pims-&gt;psup, TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SetProps(lpmsg, cValues, lpPropArray, lppProblems); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, KEEP_OPEN_READWRITE); <br>    /* if ( hr ), fall through to exit */ <br> <br>exit: <br>    UlRelease(lpmsg); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_SetProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_SetProps); <br>} <br> <br>/* <br> *  IMS_DeleteProps <br> * <br> *  Purpose: <br> *      Deletes the list of properties given in ptaga. <br> *      The caller must free the returned property problem <br> *      structure by calling MAPIFreeBuffer(*pprba), but only <br> *      if the call succeeded overall.  Uses the IMessage on <br> *      IStorage property implementation. <br> * <br> *  Arguments: <br> *      pims    Pointer to the object. <br> *      ptaga   Pointer to an array of Property Tags <br> *              identifying the properties to delete. <br> *      pprba   Location in which to return a pointer to a <br> *              counted array of property problem <br> *              structures. <br> * <br> *  Returns: <br> *      HRESULT.  If the call succeeds overall, a zero is returned. <br> *      If there are problems with deleting some or all of the <br> *      selected values, and a non-NULL is passed for pprba, <br> *      then a SPropProblemArray structure is returned with details <br> *      about each problem.  The value returned in pprba is <br> *      only valid if zero is returned in the HRESULT.  If an error <br> *      occurs on the call such that a non-zero value is returned <br> *      for the HRESULT then the contents of *pprba are <br> *      undefined.  In particular, do not use or free the structure <br> *      if an error occurs on the call. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_ACCESS    The caller does not have access <br> *                                  to the requested properties. <br> *      MAPI_E_CALL_FAILED      A general problem affecting <br> *                                  access to all of the object's <br> *                                  properties occurred. <br> *      MAPI_E_CALL_FAILED          The mechanism for making the <br> *                                  call to the service provider <br> *                                  failed. <br> */ <br>STDMETHODIMP IMS_DeleteProps(PIMS pims, LPSPropTagArray ptaga, <br>    LPSPropProblemArray *pprba) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMESSAGE lpmsg = NULL; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMAPIProp, <br>            DeleteProps, <br>            (pims,  <br>            ptaga,  <br>            pprba)); <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    if (!OBJ_TestFlag(pims, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    /* If input parameters are okay, make DeleteProps call on lpmsg. */ <br> <br>    hr = HrOpenIMSPropsFileRetry(pims-&gt;pmsgsess, pims-&gt;szProps, &amp;pims-&gt;lmr, <br>        pims-&gt;psup, TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;DeleteProps(lpmsg, ptaga, pprba); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, KEEP_OPEN_READWRITE); <br>    /* if ( hr ), fall through to exit */ <br> <br>exit: <br>    UlRelease(lpmsg); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_DeleteProps, hr); <br>    return HrCheckHr(hr, IMAPIProp_DeleteProps); <br>} <br> <br>/* <br> *  IMS_CopyTo <br> * <br> *  Purpose: <br> *      Copies the contents of the current object to a destination <br> *      object.  The entire contents, including contained objects, <br> *      are copied, or optionally the caller can provide a list of <br> *      properties that are not to be copied.  Previous information <br> *      in the destination object which is not overwritten by <br> *      copied data is neither deleted nor modified.  It is not a <br> *      requirement in MAPI 1.0, however, that CopyTo semantics <br> *      understood by the message store object or folder objects, <br> *      and so this method always returns MAPI_E_NO_SUPPORT. <br> * <br> *  Arguments: <br> *      pims            Pointer to the source object. <br> *      ciidExclude     Count of the excluded interfaces in <br> *                      rgiidExclude. <br> *      rgiidExclude    Array of interface IDs specifying <br> *                      interfaces not to be attempted in trying to <br> *                      copy supplemental information to the <br> *                      destination object. <br> *      ptagaExcl   Counted array of property tags of <br> *                      properties that are not to be copied to the <br> *                      destination object.  NULL indicates all <br> *                      properties are to be copied. <br> *      ulUIParam       Handle of parent window cast to ULONG. <br> *      lpProgress      Callback for doing progress UI. <br> *      piidDst     Interface ID of the interface of lpDestObj, <br> *                      the destination object. <br> *      lpDestObj       Pointer to the open destination object. <br> *      ulFlags         Flags.  Defined as follows: <br> *                      MAPI_MOVE       Indicates a move operation. <br> *                                      The default is to copy. <br> *                      MAPI_NOREPLACE  Indicates that existing <br> *                                      properties should not be <br> *                                      overridden.  The default is <br> *                                      to overwrite existing <br> *                                      properties. <br> *                      MAPI_DIALOG     Display a progress dialog <br> *                                      as the operation proceeds. <br> *      pprba       Pointer to a variable that is filled in <br> *                      with a pointer to a set of property <br> *                      problems.  If NULL, no problem set is <br> *                      returned on an error. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_SUPPORT   This method is not supported by <br> *                              this type of object. <br> */ <br>STDMETHODIMP IMS_CopyTo(PIMS pims, ULONG ciidExcl, LPCIID rgiidExcl, <br>    LPSPropTagArray ptagaExcl, ULONG ulUIParam, LPMAPIPROGRESS <br>    lpProgress, LPCIID piidDst, LPVOID lpDestObj, ULONG ulFlags, <br>    LPSPropProblemArray *pprba) <br>{ <br>    SCODE sc; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMAPIProp, <br>            CopyTo, <br>            (pims,  <br>            ciidExcl,  <br>            rgiidExcl,  <br>            ptagaExcl,  <br>            ulUIParam,   <br>            lpProgress,  <br>            piidDst,  <br>            lpDestObj,  <br>            ulFlags,  <br>            pprba)); <br> <br>    sc = MAPI_E_NO_SUPPORT; <br> <br>    DebugTraceSc(IMS_CopyTo, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> *  IMS_CopyProps <br> * <br> *  Purpose: <br> *      Copies the specified properties of the current object to a destination <br> *      object. <br> * <br> *  Arguments: <br> *      pims            Pointer to the source object. <br> *      ptagaIncl       Counted array of property tags of <br> *                      properties that are to be copied to the <br> *                      destination object. <br> *      ulUIParam       Handle of parent window cast to ULONG. <br> *      lpProgress      Callback for doing progress UI. <br> *      piidDst         Interface ID of the interface of lpDestObj, <br> *                      the destination object. <br> *      lpDestObj       Pointer to the open destination object. <br> *      ulFlags         Flags.  Defined as follows: <br> *                      MAPI_MOVE       Indicates a move operation. <br> *                                      The default is to copy. <br> *                      MAPI_NOREPLACE  Indicates that existing <br> *                                      properties should not be <br> *                                      overridden.  The default is <br> *                                      to overwrite existing <br> *                                      properties. <br> *                      MAPI_DIALOG     Display a progress dialog <br> *                                      as the operation proceeds. <br> *                      MAPI_DECLINE_OK <br> *      pprba       Pointer to a variable that is filled in <br> *                      with a pointer to a set of property <br> *                      problems.  If NULL, no problem set is <br> *                      returned on an error. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NO_SUPPORT   This method is not supported by <br> *                              this type of object. <br> */ <br>STDMETHODIMP IMS_CopyProps(PIMS pims, <br>    LPSPropTagArray ptagaIncl, ULONG ulUIParam, LPMAPIPROGRESS <br>    lpProgress, LPCIID piidDst, LPVOID lpDestObj, ULONG ulFlags, <br>    LPSPropProblemArray *pprba) <br>{ <br>    SCODE sc; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMAPIProp, <br>            CopyProps, <br>            (pims,  <br>            ptagaIncl,  <br>            ulUIParam,   <br>            lpProgress,  <br>            piidDst,  <br>            lpDestObj,  <br>            ulFlags,  <br>            pprba)); <br> <br>    sc = MAPI_E_NO_SUPPORT; <br> <br>    DebugTraceSc(IMS_CopyProps, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> *  IMS_GetNamesFromIDs [also used by IFLD, IMSG, IATCH] <br> * <br> *  Purpose: <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> * <br> *  Errors: <br> *      MAPI_E_NO_SUPPORT   This method is not yet supported in the sample ms. <br> */ <br>STDMETHODIMP IMS_GetNamesFromIDs(PIMS pobj, LPSPropTagArray * pptaga, <br>    LPGUID lpguid, ULONG ulFlags, ULONG * pcNames, LPMAPINAMEID ** pppNames) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMAPIPROP pmp = NULL; <br>    BOOL fReleasePMP = FALSE; <br> <br>    /* Check input parameters. */ <br> <br>    #ifdef VALIDATE <br>    if (    IsBadWritePtr(pobj, sizeof(OBJ)) <br>        || (    pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIMS <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIFLD <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIMSG <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIATCH)) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    Validate_IMAPIProp_GetNamesFromIDs( <br>                pobj,  <br>                pptaga,  <br>                lpguid,  <br>                ulFlags,  <br>                pcNames,  <br>                pppNames); <br>    #endif <br> <br>    OBJ_EnterCriticalSection(pobj); <br> <br>    switch(pobj-&gt;wType) <br>    { <br>        case OT_MSGSTORE: <br>        { <br>            PIMS pims = pobj-&gt;pims; <br>     <br>            hr = HrOpenIMSPropsFileRetry(pims-&gt;pmsgsess, pims-&gt;szProps, <br>                &amp;pims-&gt;lmr, pims-&gt;psup, FALSE, (LPMESSAGE *) &amp;pmp); <br>            if (hr != hrSuccess) <br>                goto exit; <br>     <br>            fReleasePMP = TRUE; <br>            break; <br>        } <br>     <br>        case OT_FOLDER: <br>        { <br>            PIFLD pifld = (PIFLD) pobj; <br>     <br>            hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, FALSE, <br>                (LPMESSAGE *) &amp;pmp); <br>            if (hr != hrSuccess) <br>                goto exit; <br>     <br>            fReleasePMP = TRUE; <br>            break; <br>        } <br>     <br>        case OT_MESSAGE: <br>            pmp = (LPMAPIPROP) ((PIMSG) pobj)-&gt;lpmsg; <br>            break; <br>     <br>        case OT_ATTACH: <br>            pmp = (LPMAPIPROP) ((PIATCH) pobj)-&gt;lpattach; <br>            break; <br>     <br>        default: <br>            TrapSz1("Invalid Object Type %08lX found", pobj-&gt;wType); <br>            hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>            break; <br>    } <br> <br>    hr = pmp-&gt;lpVtbl-&gt;GetNamesFromIDs(pmp, pptaga, lpguid, ulFlags, pcNames, <br>        pppNames); <br> <br>exit: <br>    if (fReleasePMP) <br>        UlRelease(pmp); <br> <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    DebugTraceResult(IMS_GetNamesFromIDs, hr); <br>    return hr; <br>} <br> <br>/* <br> *  IMS_GetIDsFromNames [also used by IFLD, IMSG, IATCH] <br> * <br> *  Purpose: <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IMS_GetIDsFromNames(PIMS pobj, ULONG cNames, <br>    LPMAPINAMEID * ppNames, ULONG ulFlags, LPSPropTagArray * pptaga) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMAPIPROP pmp = NULL; <br>    BOOL fSaveReleasePMP = FALSE; <br>    BOOL fModifyAccess; <br> <br>    /* Check input parameters. */ <br>    #ifdef VALIDATE <br>    if (    IsBadWritePtr(pobj, sizeof(OBJ)) </code></pre>
<p>
</p>
<pre><code>|| (    pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIMS <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIFLD <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIMSG <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *) &amp;vtblIATCH)) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    Validate_IMAPIProp_GetIDsFromNames(pobj, cNames, ppNames, ulFlags, pptaga); <br>    #endif <br> <br>    OBJ_EnterCriticalSection(pobj); <br> <br>    fModifyAccess = !!(ulFlags &amp; MAPI_CREATE); <br> <br>    // Check for correct access mode <br>    if (    fModifyAccess <br>        &amp;&amp;  !OBJ_TestFlag(pobj, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    switch(pobj-&gt;wType) <br>    { <br>        case OT_MSGSTORE: <br>        { <br>            PIMS pims = pobj-&gt;pims; <br>     <br>            hr = HrOpenIMSPropsFileRetry(pims-&gt;pmsgsess, pims-&gt;szProps, <br>                &amp;pims-&gt;lmr, pims-&gt;psup, fModifyAccess, (LPMESSAGE *) &amp;pmp); <br>            if (hr != hrSuccess) <br>                goto exit; <br>     <br>            fSaveReleasePMP = TRUE; <br>            break; <br>        } <br>     <br>        case OT_FOLDER: <br>        { <br>            PIFLD pifld = (PIFLD) pobj; <br>     <br>            hr = HrOpenPropertyMessageRetry(pifld-&gt;peid, pifld-&gt;pims, <br>                fModifyAccess, (LPMESSAGE *) &amp;pmp); <br>            if (hr != hrSuccess) <br>                goto exit; <br>     <br>            fSaveReleasePMP = TRUE; <br>            break; <br>        } <br>     <br>        case OT_MESSAGE: <br>            pmp = (LPMAPIPROP) ((PIMSG) pobj)-&gt;lpmsg; <br>            break; <br>     <br>        case OT_ATTACH: <br>            pmp = (LPMAPIPROP) ((PIATCH) pobj)-&gt;lpattach; <br>            break; <br>     <br>        default: <br>            TrapSz1("Invalid Object Type %08lX found", pobj-&gt;wType); <br>            hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>            break; <br>    } <br> <br>    // CAN RETURN WARNINGS!!! Should still continue even when a warning <br>    // is returned. <br> <br>    hr = pmp-&gt;lpVtbl-&gt;GetIDsFromNames(pmp, cNames, ppNames, ulFlags, pptaga); <br>    if (HR_FAILED(hr)) <br>        goto exit; <br> <br>    if (fSaveReleasePMP &amp;&amp; fModifyAccess) <br>    { <br>        HRESULT hrT; <br> <br>        hrT = pmp-&gt;lpVtbl-&gt;SaveChanges(pmp, 0); <br>        if (HR_FAILED(hrT)) <br>        { <br>            LMFree(&amp;pobj-&gt;lmr, *pptaga); <br>            *pptaga = NULL; <br>            hr = hrT; <br>        } <br>    } <br> <br>exit: <br>    if (fSaveReleasePMP) <br>        UlRelease(pmp); <br> <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    #ifdef DEBUG <br>    if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) <br>        DebugTraceResult(IMS_GetIDsFromNames, hr); <br>    #endif <br> <br>    return hr; <br>} <br> <br>/* <br> *  IMS_Advise [Also used by IMSLogon] <br> * <br> *  Purpose: <br> *      Register a client's interest in a set of events that could <br> *      occur to an object in this store.  The client's particular <br> *      interest is expressed in a ulEventMask, and he is told of <br> *      changes through an Advise object which he gives us. <br> *      The Sample Store uses the MAPI <br> *      Notification Engine to handle notifications, so the <br> *      Advise call is translated into a notification <br> *      subscription with MAPI.  When events occur in the store <br> *      which would cause interested clients to be notified, the <br> *      store calls back to MAPI to request that the occurrence of <br> *      an event be broadcast. <br> * <br> *  Arguments: <br> *      pims                Pointer to the message store object. <br> *      cbEntryID           Size of lpEntryID. <br> *      lpEntryID           Pointer to the ID for the object for <br> *                          which interest is being registered. <br> *                          if NULL then registration is for all changes. <br> *      ulEventMask         Indicates the events of interest and <br> *                          how to see them. <br> *      lpAdviseSink        Pointer to client's Advise Sink object. <br> *      lpulConnection      Pointer to a variable in which the <br> *                          client gets a cookie for cancelling <br> *                          the notifications. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_INVALID_ENTRYID      The EntryID is not recognized <br> *                                  as belonging to this store. <br> *      MAPI_E_NO_SUPPORT       The implementation does not <br> *                                  support notification on this <br> *                                  object. <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for a <br> *                                  needed buffer. <br> */ <br>STDMETHODIMP IMS_Advise(PIMS pobj, ULONG cbEntryID, LPENTRYID lpEntryID, <br>    ULONG ulEventMask, LPMAPIADVISESINK lpAdviseSink, <br>    ULONG *lpulConnection) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPNOTIFKEY lpnotifkey = NULL; <br>    PIMS pims; <br>    PEID peid; <br> <br>    /* Check input parameters. */ <br> <br>    #ifdef VALIDATE <br>    if (    IsBadWritePtr(pobj, sizeof(OBJ)) <br>        || (    pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblIMS <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblMSL)) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    Validate_IMsgStore_Advise( <br>            pobj,  <br>            cbEntryID,  <br>            lpEntryID,  <br>            ulEventMask,  <br>            lpAdviseSink,  <br>            lpulConnection); <br>    #endif <br> <br>    /* If this is an EntryID for which we support notifications, call the */ <br>    /* MAPI registration function and return the notification object.     */ <br> <br>    OBJ_EnterCriticalSection(pobj); <br> <br>    pims = pobj-&gt;pims; <br>    peid = (PEID) lpEntryID; <br>    *lpulConnection = 0; <br> <br>    if (cbEntryID &amp;&amp; FIsInvalidEID(cbEntryID, peid, pims)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    if (cbEntryID &amp;&amp; !FIsFolder(peid) &amp;&amp; !FIsMessage(peid)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>        goto exit; <br>    } <br> <br>    if (cbEntryID == 0) <br>        peid = NULL; <br> <br>    hr = HrGetSMSStandardNotifKey(pims, peid, &amp;lpnotifkey); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (pims-&gt;psup) <br>    { <br>        hr = pims-&gt;psup-&gt;lpVtbl-&gt;Subscribe(pims-&gt;psup, <br>            lpnotifkey, ulEventMask, 0L, lpAdviseSink, lpulConnection); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br>    else <br>    { <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        /* fall through to exit */ <br>    } <br> <br>exit: <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    FreeNull(lpnotifkey); <br> <br>    DebugTraceResult(IMS_Advise, hr); <br>    return HrCheckHr(hr, IMsgStore_Advise); <br>} <br> <br>/* <br> *  IMS_Unadvise [Also used by IMSLogon] <br> * <br> *  Purpose: <br> *      Deregister a previous notification. <br> * <br> *  Arguments: <br> *      pims                Pointer to the message store object. <br> *      ulConnection        Cookie given out at Advise time. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> */ <br>STDMETHODIMP IMS_Unadvise(PIMS pobj, ULONG ulConnection) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMAPISUP psup; <br> <br>    /* Check input parameters. */ <br> <br>    #ifdef VALIDATE <br>    if (    IsBadWritePtr(pobj, sizeof(OBJ)) <br>        ||  (   pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblIMS <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblMSL)) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    Validate_IMsgStore_Unadvise(pobj, ulConnection); <br>    #endif <br> <br>    OBJ_EnterCriticalSection(pobj); <br> <br>    psup = pobj-&gt;pims-&gt;psup; <br> <br>    if (psup) <br>        hr = psup-&gt;lpVtbl-&gt;Unsubscribe(psup, ulConnection); <br>    else <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br> <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    DebugTraceResult(IMS_Unadvise, hr); <br>    return HrCheckHr(hr, IMsgStore_Unadvise); <br>} <br> <br>/* <br> *  IMS_CompareEntryIDs <br> * <br> *  Purpose: <br> *      Compares two EntryIDs to determine if they refer to the <br> *      same object.  This is useful because, in general, an object <br> *      may have more than one valid EntryID.  For the Sample <br> *      Store, however, an object only has one valid EntryID at any <br> *      time and so this function reduces to a check for binary <br> *      equality of the EntryIDs. <br> * <br> *  Arguments: <br> *      pims        Pointer to the Message Store Object. <br> *      cbEntryID1  Size of first EntryID. <br> *      lpEntryID1  Pointer to the first EntryID. <br> *      cbEntryID2  Size of second EntryID. <br> *      lpEntryID2  Pointer to the second EntryID. <br> *      ulFlags     Flags.  Reserved.  Must be zero. <br> *      lpulResult  Pointer to a variable in which the result of <br> *                  the comparison (TRUE or FALSE) is placed. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_INVALID_ENTRYID  An EntryID is not recognized as <br> *                              belonging to this store. <br> */ <br>STDMETHODIMP IMS_CompareEntryIDs(PIMS pobj, ULONG cbEntryID1, <br>    LPENTRYID lpEntryID1, ULONG cbEntryID2, LPENTRYID lpEntryID2, ULONG ulFlags, <br>    ULONG *lpulResult) <br>{ <br>    HRESULT hr = hrSuccess; <br>    PEID peid1; <br>    PEID peid2; <br>    PIMS pims; <br>    BOOL fEID1IsRoot = FALSE; <br>    BOOL fEID2IsRoot = FALSE; <br> <br>    /* Check input parameters. */ <br> <br>    #ifdef VALIDATE <br>    if (    IsBadWritePtr(pobj, sizeof(OBJ)) <br>        || (    pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblIMS <br>            &amp;&amp;  pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblMSL)) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    Validate_IMsgStore_CompareEntryIDs( <br>                pobj,  <br>                cbEntryID1,  <br>                lpEntryID1,  <br>                cbEntryID2,  <br>                lpEntryID2,  <br>                ulFlags,  <br>                lpulResult); <br>    #endif <br> <br>    OBJ_EnterCriticalSection(pobj); <br> <br>    /* Do a binary comparison of the EIDs, if they're the same size AND */ <br>    /* if we recognize one of them as belonging to this store.          */ <br> <br>    peid1 = (PEID) lpEntryID1; <br>    peid2 = (PEID) lpEntryID2; <br>    pims = pobj-&gt;pims; <br> <br>    if ((cbEntryID1 &amp;&amp; FIsInvalidEID(cbEntryID1, peid1, pims)) <br>        || (cbEntryID2 &amp;&amp; FIsInvalidEID(cbEntryID2, peid2, pims))) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    if (cbEntryID1 == 0 || FIsRoot(peid1)) <br>        fEID1IsRoot = TRUE; <br> <br>    if (cbEntryID2 == 0 || FIsRoot(peid2)) <br>        fEID2IsRoot = TRUE; <br> <br>    *lpulResult = FALSE; <br> <br>    if (fEID1IsRoot == fEID2IsRoot &amp;&amp; fEID1IsRoot == TRUE) <br>        *lpulResult = TRUE; <br>    else if (cbEntryID1 == cbEntryID2 <br>            &amp;&amp; memcmp(peid1, peid2, offsetof(EID, szPath)) == 0 <br>            &amp;&amp; peid1-&gt;bVersion == SMPMS_VERSION <br>        &amp;&amp; lstrcmpi(peid1-&gt;szPath, peid2-&gt;szPath) == 0) <br>        *lpulResult = TRUE; <br> <br>exit: <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    DebugTraceResult(IMS_CompareEntryIDs, hr); <br>    return hr; <br>} <br> <br>/* <br> *  IMS_OpenEntry [Also used by IMSLogon and IMAPIFolder] <br> * <br> *  Purpose: <br> *      Opens an object in this message store. <br> * <br> *  Arguments: <br> *      pobj            Message store on which this function was <br> *                      called. <br> *      cbEntryID       Size of lpEntryID. <br> *      lpEntryID       EntryID of object to open. <br> *      piid            IID of interface requested for the <br> *                      newly-opened object.  NULL or IID_IMAPIProp <br> *                      means to open the object using the standard <br> *                      MAPI 1.0 interface for the object. <br> *                      IID_IUnknown means to open it using <br> *                      the easiest interface you can open. <br> *      ulFlags         Flags.  The following are defined: <br> *                      MAPI_MODIFY             Write access desired. <br> *                      MAPI_DEFERRED_ERRORS    Delayed "open" errors OKAY. <br> *                      MAPI_BEST_ACCESS        Open for writing if possible, <br> *                                              otherwise, open for reading. <br> *      lpulObjType     Address in which to place the type of the <br> *                      opened object. <br> *      lppUnk          Address in which to place a pointer to the <br> *                      opened object. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate memory for <br> *                                  the to-be-opened object. <br> *      MAPI_E_INVALID_ENTRYID      This message store does not <br> *                                  recognize this EntryID. <br> *      MAPI_E_UNKNOWN_FLAGS <br> *      MAPI_E_INVALID_PARAMETER <br> */ <br>STDMETHODIMP IMS_OpenEntry(PIMS pobj, ULONG cbEntryID, LPENTRYID lpEntryID, <br>    LPCIID piid, ULONG ulFlags, ULONG *lpulObjType, LPUNKNOWN *lppUnk) <br>{ <br>    HRESULT hr = hrSuccess; <br>    PIMSG pimsg = NULL; <br>    PIFLD pifld = NULL; <br>    PEID peidParent = NULL; <br>    BOOL fEIDIsRoot = FALSE; <br>    BOOL fModify; <br>    BOOL fBestAcc; <br>    PIMS pims; <br>    PEID peid; <br> <br>    /* Check input parameters. */ <br> <br>    #ifdef VALIDATE <br>    if (    IsBadWritePtr(pobj, sizeof(OBJ)) <br>        ||  (   pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblIFLD <br>             &amp;&amp; pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblIMS <br>             &amp;&amp; pobj-&gt;lpVtbl != (IMS_Vtbl *)&amp;vtblMSL)) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    Validate_IMAPIContainer_OpenEntry( <br>                pobj,  <br>                cbEntryID,  <br>                lpEntryID,  <br>                piid,  <br>                ulFlags,  <br>                lpulObjType,  <br>                lppUnk); <br>    #endif <br> <br>    OBJ_EnterCriticalSection(pobj); <br> <br>    /* Get the real pims object in case pobj is a PIFLD or PMSL */ <br>    pims = pobj-&gt;pims; <br> <br>    peid = (PEID) lpEntryID; <br> <br>    /* If parameters are okay, see if this is an EntryID we understand. */ <br> <br>    if (cbEntryID &amp;&amp; FIsInvalidEID(cbEntryID, peid, pims)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    if (cbEntryID == 0 || FIsRoot(peid)) <br>        fEIDIsRoot = TRUE; <br> <br>    /* determine if the caller wants modification access */ <br>    fModify = (ulFlags &amp; (MAPI_MODIFY | MAPI_BEST_ACCESS)) != 0; <br>    fBestAcc = (ulFlags &amp; MAPI_BEST_ACCESS) != 0; <br> <br>    /* Fail if attempting to open an object for */ <br>    /* modification in a read-only store.       */ <br> <br>    if (fModify <br>        &amp;&amp; !OBJ_TestFlag(pims, OBJF_MODIFY)) <br>    { <br>        if (fBestAcc) <br>            fModify = FALSE; <br>        else <br>        { <br>            hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>            goto exit; <br>        } <br>    } <br> <br>    /* Open the object */ <br> <br>    if (fEIDIsRoot) <br>    { <br>        PEID peidRoot = NULL; <br>        CHAR ch = '\0'; <br>        MAPIUID uid; <br> <br>        if (piid &amp;&amp; !FQueryInterface(OT_FOLDER, piid)) <br>        { <br>            hr = ResultFromScode(E_NOINTERFACE); <br>            goto exit; <br>        } <br> <br>        GetResourceUID(pims, &amp;uid); <br> <br>        hr = HrConstructEID(&amp;uid, &amp;pims-&gt;lmr, (LPSTR) &amp;ch, &amp;peidRoot); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        hr = HrNewIFLD(peidRoot, pims, fModify, &amp;pifld); <br> <br>        if (hr == hrSuccess) <br>            hr = HrSetInternalProps(&amp;pims-&gt;lmr, cpropIFLDInternal, <br>                &amp;(pifld-&gt;pval), &amp;(pifld-&gt;cval), peidRoot, peidRoot, 0); <br> <br>        LMFree(&amp;pims-&gt;lmr, peidRoot); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        *lppUnk = (LPUNKNOWN) pifld; <br>        *lpulObjType = MAPI_FOLDER; <br>    } <br>    else <br>    { <br>        hr = HrGetParentEID(&amp;pims-&gt;lmr, peid, &amp;peidParent); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        if (FIsMessage(peid)) <br>        { <br>            ULONG ulSeqNum; <br> <br>            if (piid &amp;&amp; !FQueryInterface(OT_MESSAGE, piid)) <br>            { <br>                hr = ResultFromScode(E_NOINTERFACE); <br>                goto exit; <br>            } <br> <br>            hr = HrGetSequenceNum(peid, &amp;ulSeqNum); <br> <br>            hr = HrNewIMSG(peid, pims, FALSE, fModify, ulSeqNum, NULL, &amp;pimsg); <br> <br>            if (GetScode(hr) == MAPI_E_SUBMITTED &amp;&amp; fBestAcc &amp;&amp; fModify) <br>            { <br>                fModify = FALSE; <br>                hr = HrNewIMSG(peid, pims, FALSE, fModify, ulSeqNum, NULL, &amp;pimsg); <br>            } <br> <br>            if (hr != hrSuccess) <br>                goto exit; <br> <br>            *lppUnk = (LPUNKNOWN) pimsg; <br>            *lpulObjType = MAPI_MESSAGE; <br>        } <br>        else /* a folder */ <br>        { <br>            if (!FIsFolder(peid)) <br>            { <br>                TrapSz("Logic error"); <br>                hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>                goto exit; <br>            } <br> <br>            if (piid &amp;&amp; !FQueryInterface(OT_FOLDER, piid)) <br>            { <br>                hr = ResultFromScode(E_NOINTERFACE); <br>                goto exit; <br>            } <br> <br>            hr = HrNewIFLD(peid, pims, fModify, &amp;pifld); <br>            if (hr != hrSuccess) <br>                goto exit; <br> <br>            hr = HrSetInternalProps(&amp;pims-&gt;lmr, cpropIFLDInternal, <br>                &amp;(pifld-&gt;pval), &amp;(pifld-&gt;cval), peid, peidParent, 0); <br>            if (hr != hrSuccess) <br>                goto exit; <br> <br>            *lppUnk = (LPUNKNOWN) pifld; <br>            *lpulObjType = MAPI_FOLDER; <br>        } <br>    } <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No Warnings expected"); <br> <br>    LMFree(&amp;pims-&gt;lmr, peidParent); <br> <br>    if (hr != hrSuccess) <br>    { <br>        UlRelease(pimsg); <br>        UlRelease(pifld); <br>    } <br> <br>    OBJ_LeaveCriticalSection(pobj); <br> <br>    DebugTraceResult(IMS_OpenEntry, hr); <br>    return HrCheckHr(hr, IMsgStore_OpenEntry); <br>} <br> <br>/* <br> *  IMS_SetReceiveFolder <br> * <br> *  Purpose: <br> *      Sets the receive folder for a particular message class.  A <br> *      message class is a string with "." delimiters, e.g <br> *      "IPM.Note".  This method also removes a setting if the <br> *      EntryID parameter (see below) is NULL.  Because there must <br> *      be only one set of receive folder settings per store (NOT <br> *      per logon), the settings are stored on disk in an OLE2 <br> *      docfile, and all access to them is done on disk, not in <br> *      memory (see recfldr.c, recfldr.h for details). <br> * <br> *  Arguments: <br> *      pims                Pointer to the object. <br> *      szMessageClass  String identifying a message class.  If <br> *                          NULL, then the default receive folder <br> *                          is set. <br> *      ulFlags             Flags. <br> *      cbEntryID           Size of lpEntryID. <br> *      lpEntryID           Pointer to the identifier of a <br> *                          particular folder in the store.  If <br> *                          this pointer is NULL, the receive <br> *                          folder setting is removed. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      IMS_SetReceiveFolder will not actually check to see if the <br> *      EntryID it is given exists in the store at this time, so <br> *      will go ahead and create an invalid receive folder setting <br> *      for that particular message class. <br> * <br> *  Errors: <br> *      MAPI_E_INVALID_ENTRYID  The store doesn't recognize this <br> *                              EntryID as belonging to it. <br> */ <br>STDMETHODIMP IMS_SetReceiveFolder(PIMS pims, LPTSTR szMessageClass, <br>    ULONG ulFlags, ULONG cbEntryID, LPENTRYID lpEntryID) <br>{ <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    TCHAR rgchDefMsgClass[] = TEXT(""); <br>    LPTSTR szNormalizedClass = NULL; <br>    RFN rfn; <br>    PEID peid; <br> <br>    /* Check input parameters. */ <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            SetReceiveFolder, <br>            (pims,  <br>            szMessageClass,  <br>            ulFlags,  <br>            cbEntryID,  <br>            lpEntryID)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    if (!OBJ_TestFlag(pims, OBJF_MODIFY)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_ACCESS); <br>        goto exit; <br>    } <br> <br>    peid = (PEID) lpEntryID; <br> <br>    /* don't allow removal of the default settings */ <br>    if (peid == NULL &amp;&amp; <br>        (szMessageClass == NULL || *szMessageClass == '\0')) <br>    { <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto exit; <br>    } <br> <br>    /* If parameters are okay, see if this is an EntryID we understand. */ <br> <br>    if (cbEntryID &amp;&amp; FIsInvalidEID(cbEntryID, peid, pims)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    /* The RFS module always expects a valid string */ <br>    if (!szMessageClass) <br>        szMessageClass = rgchDefMsgClass; <br> <br>    /* Make a copy of the szMessageClass that is normalized */ <br> <br>    sc = LMAlloc(&amp;pims-&gt;lmr, Cbtszsize(szMessageClass), &amp;szNormalizedClass); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br>    lstrcpy (szNormalizedClass, szMessageClass); <br>    CharUpper (szNormalizedClass); <br>         <br>    if (cbEntryID) <br>    { <br>        PRFN prfnExisting = NULL; <br> <br>        rfn.szClass = szNormalizedClass; <br>        rfn.szName = peid-&gt;szPath; <br> <br>        hr = GetRFN(pims-&gt;prfs, szNormalizedClass, &amp;prfnExisting); <br>        if (hr != hrSuccess) <br>        { <br>            if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>                hr = hrSuccess; <br>            else <br>                goto exit; <br>        } <br>        else <br>        { <br>            /* Remove the existing receive folder setting, but only if it */ <br>            /* _exactly_ matches the one that we're adding.               */ <br>            /*  //$ Are message classes case-sensitive? */ <br> <br>            if (!lstrcmp(szMessageClass, prfnExisting-&gt;szClass)) <br>                hr = DeleteRFN(pims-&gt;prfs, szNormalizedClass); <br> <br>            FreeRFN(prfnExisting); <br> <br>            if (hr != hrSuccess) <br>                goto exit; <br>        } <br> <br>        /* WARNING:  If the addition fails, we can't easily  */ <br>        /* revert to a previous version of the RFS settings. */ <br> <br>        hr = AddRFN(pims-&gt;prfs, &amp;rfn); <br>        /* if ( hr ), fall through to exit */ <br>    } <br>    else <br>    { <br>        hr = DeleteRFN(pims-&gt;prfs, szNormalizedClass); <br>        /* if ( hr ), fall through to exit */ <br>    } <br> <br>exit: <br>    LMFree(&amp;pims-&gt;lmr, szNormalizedClass); <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_SetReceiveFolder, hr); <br>    return HrCheckHr(hr, IMsgStore_SetReceiveFolder); <br>} <br> <br>/* <br> *  IMS_GetReceiveFolder <br> * <br> *  Purpose: <br> *      Obtains the receive folder setting for a particular message <br> *      class and other information about the receive behavior of <br> *      that message class.  This function obtains the EntryID of <br> *      the folder where messages of a specific class are placed. <br> *      If szMessageClass does not explicitly set a receive <br> *      folder, then the receive folder of the first superclass of <br> *      szMessageClass which does explicitly set a receive folder <br> *      is returned.  Whichever message class that explicitly sets <br> *      the receive folder is returned in pszExplicitClass.  For <br> *      example, if the receive folder of the message class <br> *      "IPM.Note" has been set to the EntryID of the Inbox and an <br> *      application calls GetReceiveFolder() on the message class <br> *      "IPM.Note.Phone," the EntryID of the Inbox is returned as <br> *      the lppEntryID, and "IPM.Note" is retuned in <br> *      pszExplicitClass.  The converse is not true:  if the <br> *      receive folder setting of "IPM.Note.Phone" is the Inbox and <br> *      the client asks for the setting of "IPM.Note", NULL is <br> *      returned. <br> * <br> *  Arguments: <br> *      pims                Pointer to the object. <br> *      szMessageClass  Identifies the particular message <br> *                          class.  If this pointer is NULL, then <br> *                          the default is returned. <br> *      ulFlags             Flags. <br> *      lpcbEntryID         Address of the location in which to <br> *                          return the size of the EntryID in <br> *                          *lppEntryID. <br> *      lppEntryID          Address of the location in which to <br> *                          return a pointer to an EntryID which is <br> *                          the identifier of the receive folder. <br> *      pszExplicitClass    Address of the location in which to <br> *                          return a pointer a buffer containing <br> *                          the message class that explicitly sets <br> *                          its receive folder to *lppEntryID.  If <br> *                          NULL indicates that no class name <br> *                          should be returned.  If it is exactly <br> *                          equal to szMessageClass, nothing is <br> *                          returned (*pszExplicitClass == NULL). <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDMETHODIMP IMS_GetReceiveFolder(PIMS pims, LPTSTR szMessageClass, <br>    ULONG ulFlags, ULONG *lpcbEntryID, LPENTRYID *lppEntryID, <br>    LPTSTR *pszExplicitClass) <br>{ <br>    HRESULT hr = hrSuccess; <br>    ULONG cbeid = 0L; <br>    PEID peid = NULL; <br>    LPTSTR szExCls = NULL; <br>    PRFN prfn = NULL; <br>    TCHAR rgchDefMsgClass[] = TEXT(""); <br>    LPTSTR szNormalizedClass = NULL; <br>    MAPIUID uid; <br>    SCODE sc = S_OK; <br> <br>    /* Check input parameters. */ <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            GetReceiveFolder, <br>            (pims,  <br>            szMessageClass,  <br>            ulFlags,  <br>            lpcbEntryID,  <br>            lppEntryID,  <br>            pszExplicitClass)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    *lpcbEntryID = 0L; <br>    *lppEntryID = NULL; <br> <br>    if (pszExplicitClass) <br>        *pszExplicitClass = NULL; <br> <br>    /* The RFS module always expects a valid string */ <br> <br>    if (!szMessageClass) <br>        szMessageClass = rgchDefMsgClass; <br> <br>    /* Make a copy of the szMessageClass that is normalized */ <br> <br>    sc = LMAlloc(&amp;pims-&gt;lmr, Cbtszsize(szMessageClass), &amp;szNormalizedClass); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br>    lstrcpy (szNormalizedClass, szMessageClass); <br>    CharUpper (szNormalizedClass); <br> <br>    hr = GetRFN(pims-&gt;prfs, szNormalizedClass, &amp;prfn); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Allocate and set return variables. */ <br> <br>    GetResourceUID(pims, &amp;uid); <br> <br>    hr = HrConstructEID(&amp;uid, &amp;pims-&gt;lmr, prfn-&gt;szName, &amp;peid); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    cbeid = CbEID(peid); <br> <br>    if (pszExplicitClass) <br>    { <br>        sc = LMAlloc(&amp;pims-&gt;lmr, Cbtszsize(prfn-&gt;szClass), &amp;szExCls); <br>        if (sc != S_OK) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto exit; <br>        } <br> <br>        lstrcpy(szExCls, prfn-&gt;szClass); <br>        *pszExplicitClass = szExCls; <br>    } <br> <br>    *lpcbEntryID = cbeid; <br>    *lppEntryID = (LPENTRYID) peid; <br> <br>exit: <br>    FreeRFN(prfn); <br>    LMFree(&amp;pims-&gt;lmr, szNormalizedClass); <br>    if (hr != hrSuccess) <br>    { <br>        LMFree(&amp;pims-&gt;lmr, peid); <br>        LMFree(&amp;pims-&gt;lmr, szExCls); <br>    } <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_GetReceiveFolder, hr); <br>    return HrCheckHr(hr, IMsgStore_GetReceiveFolder); <br>} <br> <br>STDMETHODIMP IMS_GetReceiveFolderTable(PIMS pims, ULONG ulFlags, <br>    LPMAPITABLE *lppTable) <br>{ <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            GetReceiveFolderTable, <br>            (pims,  <br>            ulFlags,  <br>            lppTable)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    DebugTraceSc(IMS_GetReceiveFolderTable, MAPI_E_NO_SUPPORT); <br>    return ResultFromScode(MAPI_E_NO_SUPPORT); <br>} <br> <br>/* <br> *  IMS_StoreLogoff <br> * <br> *  Purpose: <br> *      Allows the orderly release of a store under client control. <br> *      Use of this function to release a store allows some client <br> *      control over what MAPI will do about transport activity. <br> *      The client can either put itself in the loop by setting the <br> *      appropriate flags, or it can allow MAPI to either abort the <br> *      sending of mail or to complete it prior to invalidating the <br> *      object.  This behavior will only occur when the client is <br> *      the only application which is using the message store, and  <br> *      will happen during release of the store object.  If <br> *      another client is still using the store, the store object <br> *      will remember the flags and will issue the call during the  <br> *      final release. <br> * <br> *  Arguments: <br> *      pims        Pointer to the object. <br> *      pulFlags    Flags.  The following are defined as input: <br> *                  LOGOFF_NO_WAIT  Don't wait for the transports. <br> *                                  All outboutnd mail that is <br> *                                  ready to be sent will be sent. <br> *                                  Control is returned to the <br> *                                  client immediately. <br> *                  LOGOFF_ORDERLY  Don't wait for the transports. <br> *                                  Any currently in-process <br> *                                  message on the store is <br> *                                  completed; no new ones are </code></pre>
<p>
</p>
<pre><code>*                                  started.  Control is returned <br> *                                  to the client immediately. <br> *                  LOGOFF_PURGE    Same as LOGOFF_NO_WAIT but <br> *                                  PurgeQueues() called for <br> *                                  appropriate transports and <br> *                                  client waits for completion. <br> *                  LOGOFF_ABORT    Any transport activity on this <br> *                                  store should be aborted. <br> *                                  Control is returned to the <br> *                                  client when abort completes. <br> *                  LOGOFF_QUIET    If any transport activity is <br> *                                  taking place, the logoff will <br> *                                  not occur. <br> *                  The following are defined as output flags: <br> *                  LOGOFF_COMPLETE         All resources <br> *                                          associated with the <br> *                                          store have been <br> *                                          released and the object <br> *                                          invalidated. <br> *                  LOGOFF_INBOUND          A message is currently <br> *                                          coming into the store <br> *                                          from one or more <br> *                                          transports. <br> *                  LOGOFF_OUTBOUND         A message is currently <br> *                                          being sent from the <br> *                                          store by one or more <br> *                                          transports. <br> *                  LOGOFF_OUTBOUND_QUEUE   Messages are currently <br> *                                          in the outbound queue <br> *                                          for the store. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      See flag description for possible side effects. <br> * <br> *  Errors: <br> *      Various. <br> */ <br> <br>STDMETHODIMP IMS_StoreLogoff(PIMS pims, ULONG * pulFlags) <br>{ <br>    HRESULT hr = 0; <br>    LPMAPISUP psup = NULL; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            StoreLogoff, <br>            (pims, <br>            pulFlags)); <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    pims-&gt;ulFlagsSLT = *pulFlags; <br>    *pulFlags = LOGOFF_COMPLETE; <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_StoreLogoff, hr); <br>    return HrCheckHr(hr, IMsgStore_StoreLogoff); <br>} <br> <br>/* <br> *  IMS_AbortSubmit <br> * <br> *  Purpose: <br> *      Removes the current message from the submission queue. <br> *      Since this is not implemented in IMessage on IStorage, we <br> *      must do it ourselves. <br> * <br> *  Arguments: <br> *      lpMS        Pointer to the message store. <br> *      cbEntryID   the size of the entry ID <br> *      lpEntryID   the entry ID of the message to abort <br> *      ulFlags     Flags.  Reserved for future use.  Must be zero. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_IN_QUEUE     The message was never successfully <br> *                              submitted (and is thus not in the <br> *                              outgoing queue). <br> *      MAPI_E_UNABLE_TO_ABORT  The underlying messaging system no <br> *                              longer allows the submission to be <br> *                              cancelled. <br> */ <br>STDMETHODIMP IMS_AbortSubmit(PIMS pims, ULONG cbEntryID, LPENTRYID lpEntryID, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hr = hrSuccess; <br>    PIMSG pimsg = NULL; <br>    ULONG ulObjType; <br>    BOOL fClearSpooler = FALSE; <br>    ULONG ulSF; <br>    PEID peid; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            AbortSubmit, <br>            (pims,  <br>            cbEntryID,  <br>            lpEntryID,  <br>            ulFlags)); <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    peid = (PEID) lpEntryID; <br> <br>    /* Note that we don't allow a NULL entryid here, because the root */ <br>    /* folder is not a valid input to AbortSubmit. */ <br> <br>    if (FIsInvalidEID(cbEntryID, peid, pims) <br>        &amp;&amp; !FIsMessage(peid)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    /* unlock the message */ <br>    /* make this store look like the spooler so we can open it if locked */ <br> <br>    if (!OBJ_TestFlag(pims, MSF_SPOOLER)) <br>    { <br>        OBJ_SetFlag(pims, MSF_SPOOLER); <br>        fClearSpooler = TRUE; <br>    } <br> <br>    hr = pims-&gt;lpVtbl-&gt;OpenEntry(pims, cbEntryID, lpEntryID, <br>        NULL, MAPI_MODIFY, &amp;ulObjType, (LPUNKNOWN *) &amp;pimsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* If we can't get PR_SUBMIT_FLAGS from the message, then either */ <br>    /* the message hasn't been submitted, or something else is broken. */ <br>    /* In any case, we can't abort the submit. */ <br>    /* If the message is locked already by the spooler, then we also */ <br>    /* can't abort the submit. */ <br> <br>    hr = HrGetSingleProp((LPMAPIPROP) pimsg, &amp;pims-&gt;lmr, PR_SUBMIT_FLAGS, &amp;ulSF); <br>    if ((hr != hrSuccess) || (ulSF &amp; SUBMITFLAG_LOCKED)) <br>    { <br>        hr = ResultFromScode(MAPI_E_UNABLE_TO_ABORT); <br>        goto exit; <br>    } <br> <br>    hr = HrSetFlags(pimsg, UNSET, PR_MESSAGE_FLAGS, MSGFLAG_SUBMIT); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrSetFlags(pimsg, UNSET, PR_SUBMIT_FLAGS, SUBMITFLAG_LOCKED); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pimsg-&gt;lpVtbl-&gt;SaveChanges(pimsg, KEEP_OPEN_READWRITE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrUpdateOutgoingQueue(pims, NULL, (PEID) lpEntryID, <br>        TABLE_ROW_DELETED); <br> <br>exit: <br>    UlRelease(pimsg); <br> <br>    if (fClearSpooler) <br>        OBJ_ClearFlag(pims, MSF_SPOOLER); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_AbortSubmit, hr); <br>    return HrCheckHr(hr, IMsgStore_AbortSubmit); <br>} <br> <br>/* <br> *  IMS_GetOutgoingQueue <br> * <br> *  Purpose: <br> *      Returns a MAPI Table Object of the queue of messages <br> *      waiting to be sent. <br> * <br> *  Arguments: <br> *      pims        Pointer to a Spooler Message Store Object. <br> *      ulFlags     Reserved for future use.  Must be zero. <br> *      lppTable    Location to return the new table object. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDMETHODIMP IMS_GetOutgoingQueue(PIMS pims, ULONG ulFlags, <br>    LPMAPITABLE *lppTable) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hr = hrSuccess; <br>    LPMAPITABLE ptbl = NULL; <br>    BOOL fInMutex = FALSE; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            GetOutgoingQueue, <br>            (pims,  <br>            ulFlags,  <br>            lppTable)); <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    if (!OBJ_TestFlag(pims, MSF_SPOOLER)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>        goto exit; <br>    } <br> <br>    /* If the file mutex doesn't yet exist on this process, create it. */ <br> <br>    if (pims-&gt;hOGQueueMutex == NULL) <br>    { <br>        hr = HrCreateOGQueueMutex(&amp;pims-&gt;hOGQueueMutex); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    /* Get the file mutex so that we can use the file (and change it) */ <br>    /* without crossing paths with another process. */ <br> <br>    WaitForSingleObject(pims-&gt;hOGQueueMutex, INFINITE); <br>    fInMutex = TRUE; <br> <br>    /* Create a new table if there currently is none */ <br>    if (pims-&gt;lptblOutgoing == NULL) <br>    { <br>        hr = HrNewOutgoingTableData(pims); <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    /* open a view on the table */ <br>    hr = pims-&gt;lptblOutgoing-&gt;lpVtbl-&gt;HrGetView(pims-&gt;lptblOutgoing, <br>        NULL, OutgoingViewRelease, (ULONG) pims, &amp;ptbl); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    pims-&gt;cOutgoingViews++; <br> <br>    *lppTable = ptbl; <br> <br>    Assert(hrSuccess == hr); <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), <br>        "Unexpected warning return"); <br> <br>    if (fInMutex) <br>        ReleaseMutex(pims-&gt;hOGQueueMutex); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_GetOutgoingQueue, hr); <br>    return HrCheckHr(hr, IMsgStore_GetOutgoingQueue); <br>} <br> <br>/* <br> *  IMS_SetLockState <br> * <br> *  Purpose: <br> *      Allows the spooler to lock a message so that no one else <br> *      can modify it while the spooler processes it. <br> * <br> *  Arguments: <br> *      pims        Pointer to the Message Store Object. <br> *      lpMessage   The message object to be locked <br> *      ulFlags     control flags <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDMETHODIMP IMS_SetLockState(PIMS pims, LPMESSAGE lpMessage, ULONG ulFlags) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hr = hrSuccess; <br>    PIMSG pimsg = (PIMSG) lpMessage; <br>    ULONG ulSF; <br>    LPSPropValue pval = NULL; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            SetLockState, <br>            (pims,  <br>            lpMessage,  <br>            ulFlags)); <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    if (!OBJ_TestFlag(pims, MSF_SPOOLER)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>        goto exit; <br>    } <br> <br>    hr = HrGetSingleProp((LPMAPIPROP) pimsg, &amp;pims-&gt;lmr, PR_SUBMIT_FLAGS, &amp;ulSF); <br>    if (hr != hrSuccess) <br>    { <br>        if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>        { <br>            ULONG ulMF; <br> <br>            hr = HrGetSingleProp((LPMAPIPROP) pimsg, &amp;pims-&gt;lmr, PR_MESSAGE_FLAGS, &amp;ulMF); <br>            if (hr != hrSuccess) <br>            { <br>                if (GetScode(hr) == MAPI_E_NOT_FOUND) <br>                    hr = ResultFromScode(MAPI_E_CORRUPT_STORE); <br> <br>                goto exit; <br>            } <br> <br>            if (ulMF &amp; MSGFLAG_SUBMIT) <br>                hr = ResultFromScode(MAPI_E_CORRUPT_STORE); <br>            else <br>                hr = ResultFromScode(MAPI_E_NOT_IN_QUEUE); <br>        } <br>        goto exit; <br>    } <br> <br>    /* set the lock state, if the message is already in the correct state */ <br>    /* just get outta here */ <br> <br>    if (ulFlags &amp; MSG_LOCKED) <br>    { <br>        if (!(ulSF &amp; SUBMITFLAG_LOCKED)) <br>            ulSF |= SUBMITFLAG_LOCKED; <br>        else <br>            goto exit; <br>    } <br>    else <br>        /* unlock */ <br>    { <br>        if (ulSF &amp; SUBMITFLAG_LOCKED) <br>            ulSF &amp;= ~SUBMITFLAG_LOCKED; <br>        else <br>            goto exit; <br>    } <br> <br>    hr = HrSetSingleProp((LPMAPIPROP) pimsg, &amp;pims-&gt;lmr, PR_SUBMIT_FLAGS, &amp;ulSF); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pimsg-&gt;lpVtbl-&gt;SaveChanges(pimsg, KEEP_OPEN_READWRITE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* No need to call ChangeTable to update tables because the SaveChanges <br>     * call above just did that. <br>     */ <br> <br>exit: <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_SetLockState, hr); <br>    return HrCheckHr(hr, IMsgStore_SetLockState); <br>} <br> <br>/* <br> *  IMS_FinishedMsg <br> * <br> *  Purpose: <br> *      Allows the Spooler to inform the message store that it has <br> *      finished processing a message (cancels a previous <br> *      MDBLockMsg). <br> * <br> *  Arguments: <br> *      pims        Pointer to a Message Store Object. <br> *      ulFlags     Reserved for future use.  Ignored. <br> *      lpEntryID   EntryID of message that was locked. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDMETHODIMP IMS_FinishedMsg(PIMS pims, ULONG ulFlags, ULONG cbEntryID, <br>    LPENTRYID lpEntryID) <br>{ <br>    PIMSG pimsg = NULL;         /* opened message */ <br>    PIFLD pifldParent = NULL;   /* parent folder of this message */ <br>    ULONG ulObjectType; <br>    HRESULT hr = hrSuccess; <br>    SCODE sc = S_OK; <br>    PEID peid = (PEID) lpEntryID; <br> <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            FinishedMsg, <br>            (pims,  <br>            ulFlags,  <br>            cbEntryID,  <br>            lpEntryID)); <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    if (!OBJ_TestFlag(pims, MSF_SPOOLER)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>        goto exit; <br>    } <br> <br>    if (FIsInvalidEID(cbEntryID, peid, pims)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    hr = pims-&gt;lpVtbl-&gt;OpenEntry(pims, cbEntryID, lpEntryID, <br>        NULL, MAPI_MODIFY, &amp;ulObjectType, (LPUNKNOWN *) &amp;pimsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    Assert(ulObjectType == MAPI_MESSAGE); <br> <br>    /* update the parent folder */ <br>    hr = HrOpenParent(pims, peid, MAPI_MODIFY, &amp;pifldParent); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* unlock the message */ <br>    hr = HrSetFlags(pimsg, UNSET, PR_MESSAGE_FLAGS, <br>        MSGFLAG_UNSENT | MSGFLAG_SUBMIT); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Mark the message read */ <br>    hr = HrSetFlags(pimsg, SET, PR_MESSAGE_FLAGS, MSGFLAG_READ); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Clear submitflag_locked and save the message */ <br>    hr = HrSetFlags(pimsg, UNSET, PR_SUBMIT_FLAGS, SUBMITFLAG_LOCKED); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pimsg-&gt;lpVtbl-&gt;SaveChanges(pimsg, KEEP_OPEN_READWRITE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pims-&gt;psup-&gt;lpVtbl-&gt;DoSentMail(pims-&gt;psup, 0L, (LPMESSAGE) pimsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br>    pimsg = NULL; <br> <br>    Assert(pims-&gt;lptblOutgoing); <br> <br>    hr = HrUpdateOutgoingQueue(pims, NULL, (PEID) lpEntryID, <br>        TABLE_ROW_DELETED); <br> <br>exit: <br>    UlRelease(pifldParent); <br>    UlRelease(pimsg); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_FinishedMsg, hr); <br>    return HrCheckHr(hr, IMsgStore_FinishedMsg); <br>} <br> <br>/* <br> *  IMS_NotifyNewMail <br> * <br> *  Purpose: <br> *      Spooler tells us when to tell clients about a new message. <br> *      Passed in on the call is the exact notification structure <br> *      we need to give the client. <br> * <br> *      Stubbed for now. <br> * <br> *  Arguments: <br> *      pims        Pointer to the object. <br> *      pntf        Pointer to the newmail notification structure. <br> *                                      read/write. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDMETHODIMP IMS_NotifyNewMail(PIMS pims, LPNOTIFICATION pntf) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPNOTIFKEY lpKey = NULL; <br>    ULONG ulFlags = 0; <br>    PEID peidMsg; <br>    PEID peidFld; <br>    ULONG cbEIDMsg; <br>    ULONG cbEIDFld; <br> <br>    MS_ValidateParameters( <br>            pims,  <br>            IMsgStore, <br>            NotifyNewMail, <br>            (pims,  <br>            pntf)); <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    if (!OBJ_TestFlag(pims, MSF_SPOOLER)) <br>    { <br>        hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>        goto exit; <br>    } <br> <br>    if (!pims-&gt;psup) <br>    { <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto exit; <br>    } <br> <br>    cbEIDMsg = pntf-&gt;info.newmail.cbEntryID; <br>    peidMsg = (PEID) pntf-&gt;info.newmail.lpEntryID; <br> <br>    cbEIDFld = pntf-&gt;info.newmail.cbParentID; <br>    peidFld = (PEID) pntf-&gt;info.newmail.lpParentID; <br> <br>    if (    cbEIDMsg == 0 <br>        ||  FIsInvalidEID(cbEIDMsg, peidMsg, pims) <br>        ||  !FIsMessage(peidMsg) <br>        ||  cbEIDFld == 0 <br>        ||  FIsInvalidEID(cbEIDFld, peidFld, pims) <br>        ||  !FIsFolder(peidFld)) <br>    { <br>        TraceSz("SMS: Bad entryid given to NotifyNewMail"); <br>        hr = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto exit; <br>    } <br> <br>    /* Generate the key we use for notifications. First, get the key */ <br>    /* for the folder that the message arrived into. */ <br> <br>    hr = HrGetSMSStandardNotifKey(pims, peidFld, &amp;lpKey); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pims-&gt;psup-&gt;lpVtbl-&gt;Notify(pims-&gt;psup, lpKey, 1, pntf, &amp;ulFlags); <br>    if (hr != hrSuccess) <br>        goto exit; <br>     <br>    FreeNull(lpKey); <br>    lpKey = NULL; <br>    ulFlags = 0; <br> <br>    /* Now, get the key for the entire store, and send to that key also. */ <br> <br>    hr = HrGetSMSStandardNotifKey(pims, NULL, &amp;lpKey); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pims-&gt;psup-&gt;lpVtbl-&gt;Notify(pims-&gt;psup, lpKey, 1, pntf, &amp;ulFlags); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>exit: <br>    FreeNull(lpKey); <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    DebugTraceResult(IMS_NotifyNewMail, hr); <br>    return HrCheckHr(hr, IMsgStore_NotifyNewMail); <br>} <br> <br>/* Internal Functions */ <br> <br>BOOL IMS_IsInvalid(PIMS pims) <br>{ <br>    return (IsBadWritePtr(pims, sizeof(IMS)) || pims-&gt;lpVtbl != &amp;vtblIMS); <br>} <br> <br>/*************************************************************************** <br> -  OutgoingViewRelease <br> - <br> *  Purpose: <br> *      Call back function from itable on release of a view <br> *      removes the view from the list of open views <br> *      releases the table if there are no more open views on it <br> * <br> *  Arguments: <br> *       ulCallerData   pointer to folder object <br> *       lptbl      pointer to the table on which this is a view <br> *       lpvtView       pointer to the view that was released <br> * <br> * <br> */ <br>STDAPI_(void) OutgoingViewRelease(ULONG ulCallerData, LPTABLEDATA lptbl, <br>    LPMAPITABLE lpvtView) <br>{ <br>    PIMS pims;                  /* store who owns this view */ <br>    ULONG ulViewsLeft;          /* number of open views left */ <br> <br>    pims = (PIMS) ulCallerData; <br> <br>    /* do nothing if the message store is gone */ <br>    if (IMS_IsInvalid(pims)) <br>        return; <br> <br>    IMS_EnterCriticalSection(pims); <br> <br>    AssertSz(pims-&gt;lptblOutgoing == lptbl, <br>        "Different table data given to OutgoingViewRelease"); <br> <br>    ulViewsLeft = --(pims-&gt;cOutgoingViews); <br> <br>    /* release the table data if the viewlist is empty */ <br>    if (ulViewsLeft == 0) <br>    { <br>        UlRelease(lptbl); <br>        pims-&gt;lptblOutgoing = NULL; <br>    } <br> <br>    IMS_LeaveCriticalSection(pims); <br> <br>    return; <br>} <br> <br>/* <br> *  HrNewIMS <br> * <br> *  Purpose: <br> *      Allocates and initializes an IMS object (internal <br> *      implementation of IMsgStore). <br> * <br> *  Arguments: <br> *      szStorePath         Path name of directory which is the <br> *                          "root" of this message store. <br> *      szStoreProps        Filename of IMsgStore properties <br> *                          docfile in the store root. <br> *      pmsp                pointer to the MS provider object. <br> *      pmsl                Pointer to the MS logon object given to <br> *                          MAPI when this store is created. <br> *      prfs                Pointer to a context for accessing <br> *                          receive folder settings. <br> *      pps                 pointer to our profile section. <br> *      psup                Pointer to MAPI Support Object. <br> *      fCreate             TRUE if the function should create the docfile <br> *                          containing IMS properties (FALSE opens existing). <br> *      ppims               Location to return the address of the <br> *                          newly created IMS object. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      Does AddRef() of support object. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate memory for <br> *                                  the object. <br> */ <br>HRESULT HrNewIMS(LPTSTR szStorePath, LPTSTR szStoreProps, PMSP pmsp, PMSL pmsl, <br>    PRFS prfs, LPPROFSECT pps, LPMAPISUP psup, BOOL fCreate, PIMS *ppims) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hr; <br>    HRESULT hrStg = hrSuccess; <br>    LPTSTR szPropFull = NULL; <br>    PIMS pimsNew = NULL; <br>    PEID peid = NULL; <br>    LPMESSAGE lpmsg = NULL; <br>    BOOL fDoneCreate = FALSE; <br>    LPMSGSESS pmsgsess = NULL; <br>    LPSPropValue pvalDLLName = NULL; <br> <br>    AssertSz(szStorePath, "Bad szStorePath"); <br>    AssertSz(szStoreProps, "Bad szStoreProps"); <br>    AssertSz(pmsl, "Bad pmsl"); <br>    AssertSz(prfs, "Bad prfs"); <br>    AssertSz(ppims, "Bad ppims"); <br> <br>    *ppims = NULL; <br> <br>    /* Begin by creating or opening the message store's property file. */ <br>    /* This implementation of the sample message store puts its message */ <br>    /* store properties in a file called MSGSTORE.PRP in the root folder */ <br>    /* of the store. If we're opening an existing store, then we'll read */ <br>    /* PR_RECORD_KEY from this file below. If we're creating the file, we */ <br>    /* don't actually use it in this function; however, we still need to */ <br>    /* create the file. */ <br> <br>    hr = HrOpenIMsgSession(&amp;pmsgsess); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    hr = HrAppendPath(szStorePath, szStoreProps, &amp;szPropFull); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br>     <br>    hr = HrOpenIMsg(pmsgsess, szPropFull, &amp;pmsp-&gt;lmr, psup, fCreate, FALSE, <br>        TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    if (fCreate) <br>        fDoneCreate = TRUE; <br> <br>    /* Allocate and fill in the new object. */ <br> <br>    sc = LMAllocZ(&amp;pmsp-&gt;lmr, sizeof(IMS), &amp;pimsNew); <br>    if (sc != S_OK) <br>        goto sc_err; <br> <br>    OBJ_Initialize(pimsNew, &amp;vtblIMS, OT_MSGSTORE, pimsNew, &amp;pmsl-&gt;cs); <br> <br>    pimsNew-&gt;pmsl = pmsl; <br>    pimsNew-&gt;pmsp = pmsp; <br>    pimsNew-&gt;prfs = prfs; <br>    pimsNew-&gt;psup = psup; <br>    pimsNew-&gt;lmr = pmsl-&gt;lmr; <br>    pimsNew-&gt;eidStore.cb = 0L; <br>    pimsNew-&gt;eidStore.lpb = NULL; <br>    pimsNew-&gt;lptblOutgoing = NULL; <br>    pimsNew-&gt;cOutgoingViews = 0L; <br>    pimsNew-&gt;ulOQConn = 0L; <br>    pimsNew-&gt;ulTblConn = 0L; <br>    pimsNew-&gt;pmsgsess = pmsgsess; <br>    pimsNew-&gt;ulFlagsSLT = LOGOFF_ABORT; <br> <br>    sc = ScAlloc(Cbtszsize(szStorePath), (PPV) &amp;pimsNew-&gt;szStorePath); <br>    if (sc != S_OK) <br>        goto sc_err; <br> <br>    lstrcpy(pimsNew-&gt;szStorePath, szStorePath); <br> <br>    pimsNew-&gt;szProps = szPropFull; <br> <br>    /* Fill in the uidResource. <br>     * This is used as the PR_STORE_RECORD_KEY and <br>     * as the UID contained in EntryIDs. <br>     */ <br>    if (fCreate) <br>    { <br>        hr = psup-&gt;lpVtbl-&gt;NewUID(psup, &amp;pimsNew-&gt;uidResource); <br>        if (hr != hrSuccess) <br>            goto hr_err; <br>    } <br>    else <br>    { <br>        LPSPropValue pval; <br> <br>        /* Read out the PR_RECORD_KEY from the store.   */ <br>        /* DO NOT READ THE PR_STORE_RECORD_KEY as that  */ <br>        /* gets wrapped back to pimsNew-&gt;uidResource and    */ <br>        /* HAS NOT BEEN FILLED IN YET!                      */ <br> <br>        hr = HrGetOneProp((LPMAPIPROP) lpmsg, PR_RECORD_KEY, &amp;pval); <br>        if (hr != hrSuccess) <br>            goto hr_err; <br> <br>        AssertSz(pval[0].Value.bin.cb == sizeof(MAPIUID), <br>            "Corrupted data returned from GetProps"); <br> <br>        pimsNew-&gt;uidResource = *((LPMAPIUID) pval[0].Value.bin.lpb); <br> <br>        LMFree(&amp;pmsp-&gt;lmr, pval); <br>    } <br> <br>    /* Generate the PR_STORE_ENTRYID property in memory. */ <br> <br>    hr = HrConstructEID(&amp;pimsNew-&gt;uidResource, &amp;pmsp-&gt;lmr, <br>            pimsNew-&gt;szStorePath, &amp;peid); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    hr = HrGetOneProp((LPMAPIPROP)pps, PR_PROVIDER_DLL_NAME, &amp;pvalDLLName); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    hr = WrapStoreEntryID(0, pvalDLLName-&gt;Value.lpszA, CbEID(peid), <br>            (LPENTRYID)peid, &amp;pimsNew-&gt;eidStore.cb, <br>            (LPENTRYID *) &amp;pimsNew-&gt;eidStore.lpb); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>sc_err: <br>    if (sc != S_OK) <br>        hr = ResultFromScode(sc); <br> <br>hr_err: <br>    LMFree(&amp;pmsp-&gt;lmr, pvalDLLName); <br>    UlRelease(lpmsg); <br>    LMFree(&amp;pmsp-&gt;lmr, peid); <br> <br>    if (hr != hrSuccess) <br>    { <br>        if (fDoneCreate) <br>            DeleteFile(szPropFull); <br> <br>        FreeNull(szPropFull); <br>        if (pimsNew) <br>        { <br>            FreeNull(pimsNew-&gt;szStorePath); <br>            LMFree(&amp;pmsp-&gt;lmr, pimsNew-&gt;eidStore.lpb); <br>            LMFree(&amp;pmsp-&gt;lmr, pimsNew); <br>        } <br> <br>        if (pmsgsess) <br>            CloseIMsgSession(pmsgsess); <br>    } <br>    else <br>    { <br>        /* SUCCESS! */ <br>        *ppims = pimsNew; <br>    } <br> <br>    DebugTraceResult(HrNewIMS, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrInitIMSProps <br> * <br> *  Purpose: <br> *      Sets the initial (and for read-only properties, the only) <br> *      values for the base properties of the Message Store Object: <br> *      takes as input parameters the values of those properties <br> *      that are specific to this store and calculates (hard-coded) <br> *      the values of those properties that are the same for all <br> *      stores created by the Microsoft Sample Store Provider. <br> *      Also sets attributes. <br> * <br> *  Arguments: <br> *      pims        Internal IMsgStore object instance. <br> *      szPswd      Logon Account Password. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the property arrays. <br> */ <br>HRESULT HrInitIMSProps(PIMS pims, LPTSTR szPswd) <br>{ <br>    HRESULT hr; <br>    LPMESSAGE lpmsg = NULL; <br>    LPSPropValue pval = NULL; <br>    LPSPropProblemArray pprba = NULL; <br>    LPSPropTagArray ptaga = NULL; <br>    LPSPropAttrArray patra = NULL; <br>    SCODE sc = S_OK; <br>    LPSPropProblem pProbl = NULL; <br> <br>#define cInitIMSProps       10 <br>#define grfInitIMSProps     ( PROPATTR_MANDATORY | PROPATTR_READABLE ) <br> <br>    AssertSz(pims, "Bad pims"); <br>    NFAssertSz(pims-&gt;psup, "Bad support object"); <br>    AssertSz(szPswd, "Bad szPswd"); <br> <br>    hr = HrOpenIMSPropsFileRetry(pims-&gt;pmsgsess, pims-&gt;szProps, &amp;pims-&gt;lmr, <br>        pims-&gt;psup, TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Allocate the property arrays. */ <br>    hr = HrAllocPropArrays(cInitIMSProps, &amp;pval, &amp;ptaga, &amp;patra); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Initialize property value array and all property tags. */ <br> <br>    ptaga-&gt;cValues = patra-&gt;cValues = cInitIMSProps; <br> <br>    pval[0].ulPropTag = ptaga-&gt;aulPropTag[0] = PR_STORE_ENTRYID; <br>    pval[0].Value.bin.cb = pims-&gt;eidStore.cb; <br>    pval[0].Value.bin.lpb = pims-&gt;eidStore.lpb; <br>    pval[1].ulPropTag = ptaga-&gt;aulPropTag[1] = PR_STORE_RECORD_KEY; <br>    pval[1].Value.bin.cb = sizeof(pims-&gt;uidResource); <br>    pval[1].Value.bin.lpb = (LPBYTE) &amp;pims-&gt;uidResource; <br>    pval[2].ulPropTag = ptaga-&gt;aulPropTag[2] = PR_ENTRYID; <br>    pval[2].Value.bin.cb = pims-&gt;eidStore.cb; <br>    pval[2].Value.bin.lpb = pims-&gt;eidStore.lpb; <br>    pval[3].ulPropTag = ptaga-&gt;aulPropTag[3] = PR_RECORD_KEY; <br>    pval[3].Value.bin.cb = sizeof(pims-&gt;uidResource); <br>    pval[3].Value.bin.lpb = (LPBYTE) &amp;pims-&gt;uidResource; <br>    pval[4].ulPropTag = ptaga-&gt;aulPropTag[4] = PR_DISPLAY_NAME; <br>    pval[4].Value.LPSZ = pims-&gt;szStorePath; <br>    pval[5].ulPropTag = ptaga-&gt;aulPropTag[5] = PR_SMS_PASSWORD; <br>    pval[5].Value.LPSZ = szPswd; <br> <br>    /* We don't set support properties that are changed by READONLY */ <br>    /* when the store is open. Those are or'ed in during GetProps. */ <br>    /* See HrWrap_GetProps for details. */ <br> <br>    pval[6].ulPropTag = ptaga-&gt;aulPropTag[6] = PR_STORE_SUPPORT_MASK; <br>    pval[6].Value.ul = SMS_SUPPORTMASK; <br>         <br>    pval[7].ulPropTag = ptaga-&gt;aulPropTag[7] = PR_OBJECT_TYPE; <br>    pval[7].Value.l = MAPI_STORE; <br>    pval[8].ulPropTag = ptaga-&gt;aulPropTag[8] = PR_FILENAME_SEQUENCE_NUMBER; <br>    pval[8].Value.ul = 0x10000000; <br>    pval[9].ulPropTag = ptaga-&gt;aulPropTag[9] = PR_MDB_PROVIDER; <br>    pval[9].Value.bin.cb = sizeof(MAPIUID); <br>    pval[9].Value.bin.lpb = (LPBYTE) &amp;uidProvider; <br> <br>    /* Initialize the property attribute array. */ <br> <br>    patra-&gt;aPropAttr[0] = grfInitIMSProps; <br>    patra-&gt;aPropAttr[1] = grfInitIMSProps; <br>    patra-&gt;aPropAttr[2] = grfInitIMSProps; <br>    patra-&gt;aPropAttr[3] = grfInitIMSProps; <br>    patra-&gt;aPropAttr[4] = grfInitIMSProps | PROPATTR_WRITEABLE; <br>    patra-&gt;aPropAttr[5] = grfInitIMSProps; <br>    patra-&gt;aPropAttr[6] = grfInitIMSProps; <br>    patra-&gt;aPropAttr[7] = grfInitIMSProps; <br>    patra-&gt;aPropAttr[8] = grfInitIMSProps; <br>    patra-&gt;aPropAttr[9] = grfInitIMSProps; <br> <br>    /* Set the property values. */ <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SetProps(lpmsg, cInitIMSProps, pval, &amp;pprba); <br>    if (hr != hrSuccess) /* || pprba)*/ <br>        goto exit; <br>    if(pprba) <br>    { <br>        for(pProbl = pprba-&gt;aProblem; pProbl &lt; pprba-&gt;aProblem + pprba-&gt;cProblem; ++pProbl) <br>        { <br>            if(pProbl-&gt;ulPropTag != PR_STORE_SUPPORT_MASK) <br>                goto exit; <br>        } <br>        LMFree(&amp;pims-&gt;lmr, pprba); <br>        pprba = NULL; <br>    } <br> <br> <br>    /* Set the property attributes. */ <br> <br>    hr = SetAttribIMsgOnIStg(lpmsg, ptaga, patra, &amp;pprba); <br>    if (hr != hrSuccess) /* || pprba)*/ <br>        goto exit; <br>    if(pprba) <br>    { <br>        for(pProbl = pprba-&gt;aProblem; pProbl &lt; pprba-&gt;aProblem + pprba-&gt;cProblem; ++pProbl) <br>        { <br>            if(pProbl-&gt;ulPropTag != PR_STORE_SUPPORT_MASK) <br>                goto exit; <br>        } <br>        LMFree(&amp;pims-&gt;lmr, pprba); <br>        pprba = NULL; <br>    } <br> <br> <br> <br>    /* If we succeeded up to this point, commit the properties. */ <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, KEEP_OPEN_READWRITE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>exit: <br>    AssertSz(hr == hrSuccess || HR_FAILED(hr), "No Warnings expected"); <br> <br>    if (pprba) <br>    { <br>        LMFree(&amp;pims-&gt;lmr, pprba); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>    } <br> <br>    FreePropArrays(&amp;pval, &amp;ptaga, &amp;patra); </code></pre>
<p>
</p>
<pre><code><br>    UlRelease(lpmsg); <br> <br>    DebugTraceResult(InitIMSProps, hr); <br>    return hr; <br>} <br> <br>/* <br> *  GetResourceUID <br> * <br> *  Purpose: <br> *      Returns the one UID that identifies this MAPI resource <br> *      (message store). <br> * <br> *  Arguments: <br> *      pims    Internal IMsgStore object instance. <br> *      lpuid   Location in which to return the value of the <br> *              Resource UID. <br> * <br> *  Returns: <br> *      VOID <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>VOID GetResourceUID(PIMS pims, LPMAPIUID lpuid) <br>{ <br>    AssertSz(pims, "Bad pims"); <br>    AssertSz(lpuid, "Bad lpuid"); <br> <br>    *lpuid = pims-&gt;uidResource; <br> <br>    return; <br>} <br> <br>/********************************************************* <br> * FIsInvalidEID <br> * <br> *  Purpose         check if the peid points to an invalid EID <br> *                  Returns TRUE if it is invalid. This routine <br> *                  considers EIDs of length 0 invalid. <br> * <br> *  Parameter <br> *      cb          number of bytes believed to be in peid <br> *      peid        pointer to the entryid <br> *      pims        store in which the object should be. May be NULL, <br> *                  in which case, no check of the uid is performed. <br> */ <br>BOOL FIsInvalidEID(ULONG cb, PEID peid, PIMS pims) <br>{ <br>    BOOL fInvalid; <br> <br>    fInvalid = (cb &lt; CbNewEID(0) <br>        || cb &gt; CbNewEID(MAX_PATH) <br>        || IsBadReadPtr(peid, (UINT) cb) <br>        || IsBadStringPtr(peid-&gt;szPath, (UINT) -1) <br>        || cb != CbEID(peid) <br>        || peid-&gt;bVersion != SMPMS_VERSION); <br> <br>    /* If the eid still looks good, and we were given the message store */ <br>    /* object, then do one final check of the uid in the eid versus the */ <br>    /* uid of the store. */ <br> <br>    if (!fInvalid &amp;&amp; pims) <br>    { <br>        MAPIUID uid; <br> <br>        GetResourceUID(pims, &amp;uid); <br>        fInvalid = !IsEqualMAPIUID(&amp;uid, &amp;peid-&gt;uidResource); <br>    } <br> <br>    return fInvalid; <br>} <br> <br>/* <br> *  HrUniqueFileName <br> * <br> *  Purpose: <br> *      Returns a unique file name base that can be used by other <br> *      parts of the store when a file needs to be created.  Gets <br> *      the PR_FILENAME_SEQUENCE_NUMBER property out of the message <br> *      store object, uses its textized form as the unique name, <br> *      increments it, and stores it back in the object.  Sequence <br> *      numbers begin at 0x10000000 and increment so that every <br> *      file name returned is the same 8-character length.  (See <br> *      HrInitIMSProps.) <br> * <br> *  Arguments: <br> *      pims            Message Store Object. <br> *      lpulSeqNumber   pointer to sequence number of this file name <br> *      lppstrNewName   Location in which to return a pointer to a <br> *                      buffer containing the unique file name. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      Increments the PR_FILENAME_SEQUENCE_NUMBER property of the <br> *      message store object. <br> * <br> *  Errors: <br> *      All SetProps and SaveChanges errors.  Also: <br> * <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the return parameter. <br> */ <br>HRESULT HrUniqueFileName(PIMS pims, ULONG *lpulSeqNumber, <br>    LPTSTR *pszNewName) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPTSTR szFileName = NULL; <br>    ULONG ulSeq = 0L; <br>    LPMESSAGE lpmsg = NULL; <br> <br>    AssertSz(pims, "Bad pims"); <br>    AssertSz(pszNewName, "Bad pszNewName"); <br> <br>    /* Allocate space for the return string */ <br> <br>    hr = HrAlloc((CCH_NAME - CCH_EXT) * sizeof(TCHAR), (PPV) &amp;szFileName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Get sequence number out of object, increment */ <br>    /* sequence number, and turn it into a string.  */ <br> <br>    hr = HrGetSingleProp((LPMAPIPROP) pims, &amp;pims-&gt;lmr, <br>        PR_FILENAME_SEQUENCE_NUMBER, &amp;ulSeq); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    ulSeq++; <br> <br>    hr = HrOpenIMSPropsFileRetry(pims-&gt;pmsgsess, pims-&gt;szProps, &amp;pims-&gt;lmr, <br>        pims-&gt;psup, TRUE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrSetOneROProp(lpmsg, &amp;pims-&gt;lmr, PR_FILENAME_SEQUENCE_NUMBER, &amp;ulSeq); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges(lpmsg, KEEP_OPEN_READWRITE); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* If this wsprintf statement changes, fix HrConvertSzToHex below. */ <br> <br>    wsprintf(szFileName, TEXT("%08lx"), ulSeq); <br> <br>    *pszNewName = szFileName; <br>    *lpulSeqNumber = ulSeq; <br> <br>exit: <br>    UlRelease(lpmsg); <br> <br>    if (hr != hrSuccess) <br>        FreeNull(szFileName); <br> <br>    DebugTraceResult(HrUniqueFileName, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrConvertSzToHex <br> * <br> * Converts the string given into an equivalent number. The string must <br> * contain characters in the range 0-9, A-F, or a-f. If the routine finds <br> * characters outside these ranges in the string, it will terminate with <br> * the error MAPI_E_CALL_FAILED. The string must be at least 8 characters <br> * long (a 32-bit number is fully-specified by a 8 hex characters). The <br> * routine will use only the first 8 characters in the string, even if the <br> * string is longer than 8 characters. Note that only the first 8 characters <br> * must be within the proper range. Characters after the first 8 will be <br> * ignored. <br> * <br> * Parameters: <br> *  szName: The string to convert. <br> *  pulAnswer: A pointer to the location to return the converted answer. <br> * <br> * Errors: <br> *  MAPI_E_CALL_FAILED -- when a character is out of range. <br> */ <br>static HRESULT HrConvertSzToHex(LPSTR szName, ULONG *pulAnswer) <br>{ <br>    HRESULT hr = hrSuccess; <br>    CHAR *pch; <br>    CHAR *pchMax; <br>    ULONG ulAns = 0; <br>    ULONG ichConv = 0; <br> <br>    /* String must be at least 8 hex chars long. It should have come from */ <br>    /* the HrUniqueFileName function above, which uses wsprintf to generate */ <br>    /* the string. */ <br> <br>    if (    IsBadStringPtr(szName, (UINT) -1) <br>        ||  lstrlen(szName) &lt; 8) <br>    { <br>        TrapSz("Bad input to function"); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto exit; <br>    } <br> <br>    pch = szName; <br>    pchMax = szName + lstrlen(szName); <br> <br>    /* Only convert the first 8 characters, no matter how long the string is. */ <br>    while(pch &lt; pchMax &amp;&amp; ichConv &lt; 8) <br>    { <br>        ulAns &lt;&lt;= 4; <br> <br>        if (*pch &gt;= '0' &amp;&amp; *pch &lt;= '9') <br>            ulAns += (*pch - '0'); <br>        else if (*pch &gt;= 'a' &amp;&amp; *pch &lt;= 'f') <br>            ulAns += (*pch - 'a' + 0xA); <br>        else if (*pch &gt;= 'A' &amp;&amp; *pch &lt;= 'F') <br>            ulAns += (*pch - 'A'+ 0xA); <br>        else <br>        { <br>            TraceSz2("SampleMS: HrConvertSztoHex: char %c(%#x) out of range.\n", <br>                *pch, *pch); <br>            hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>            goto exit; <br>        } <br> <br>        ++pch; <br>        ++ichConv; <br>    } <br> <br>    *pulAnswer = ulAns; <br> <br>exit: <br>    DebugTraceResult(HrConvertSzToHex, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrGetSequenceNum <br> * <br> * This routine takes a message eid and gets the <br> * numerical equivalent of the base file name in the entryid. So, if the <br> * base name of the message was "00000005.msg", the function would return <br> * 0x00000005. <br> * <br> * Parameters: <br> *  pimsg: the message object to update. <br> *  pulSequenceNum: a pointer to the location to place the generated number. <br> * <br> */ <br>static HRESULT HrGetSequenceNum(PEID peid, ULONG *pulSequenceNum) <br>{ <br>    HRESULT hr; <br>    LPSTR szBaseName; <br>    ULONG ulSeqNum; <br> <br>    szBaseName = SzBaseName(peid); <br> <br>    hr = HrConvertSzToHex(szBaseName, &amp;ulSeqNum); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    *pulSequenceNum = ulSeqNum; <br> <br>exit: <br>    DebugTraceResult(HrGetSequenceNum, hr); <br>    return hr; <br>} <br> <br>/* <br> *  IMS_NeuterChildren, IMS_Neuter <br> * <br> *  Purpose: <br> *      Free all memory and resources associated with a logon.  We <br> *      cannot, however, remove the critical section:  that must be <br> *      done by the caller of this routine. <br> * <br> *  Arguments: <br> *      pims            Pointer to the MS object. <br> * <br> *  Returns: <br> *      None. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>void IMS_NeuterChildren(POBJ pobj, int iLevel) <br>{ <br>#ifdef DEBUG <br>    int i; <br> <br>    DebugTrace("SMS:   "); <br>    for (i = 0; i &lt; iLevel; ++i) <br>        DebugTrace("  "); <br> <br>    switch (pobj-&gt;wType) <br>    { <br>    case OT_MSGSTORE: <br>        DebugTrace("IMsgStore (%s)", ((PIMS) pobj)-&gt;szStorePath); <br>        break; <br>    case OT_FOLDER: <br>        DebugTrace("IMAPIFolder"); <br>        break; <br>    case OT_MESSAGE: <br>        DebugTrace("IMessage"); <br>        break; <br>    case OT_ATTACH: <br>        DebugTrace("IAttach"); <br>        break; <br>    case OT_STREAM: <br>        DebugTrace("IStream"); <br>        break; <br>    } <br>    DebugTrace(" (@%08lX,cRef=%ld)\n", pobj, pobj-&gt;cRef); <br>#endif <br> <br>    while (TRUE) <br>    { <br>        POBJ pobjChild; <br> <br>        pobjChild = pobj-&gt;pobjHead; <br> <br>        if (pobjChild == NULL) <br>            break; <br> <br>        pobj-&gt;pobjHead = pobjChild-&gt;pobjNext; <br>        IMS_NeuterChildren(pobjChild, iLevel + 1); <br>    } <br> <br>    if (pobj-&gt;wType != OT_MSGSTORE) <br>    { <br>        LPFNNEUTER lpfnNeuter; <br> <br>        lpfnNeuter = rgfnNeuter[pobj-&gt;wType]; <br> <br>        if (lpfnNeuter != 0) <br>            lpfnNeuter(pobj); <br> <br>        pobj-&gt;lpVtbl = 0; <br>        LMFree(&amp;pobj-&gt;pims-&gt;lmr, pobj); <br>    } <br>} <br> <br>void IMS_Neuter(PIMS pims) <br>{ <br>    HRESULT hr; <br>    ULONG ulFlags; <br> <br> <br>    if (pims-&gt;ulOQConn) <br>    { <br>        pims-&gt;psup-&gt;lpVtbl-&gt;Unsubscribe(pims-&gt;psup, pims-&gt;ulOQConn); <br>        pims-&gt;ulOQConn = 0; <br>    } <br> <br>    if (pims-&gt;ulTblConn) <br>    { <br>        pims-&gt;psup-&gt;lpVtbl-&gt;Unsubscribe(pims-&gt;psup, pims-&gt;ulTblConn); <br>        pims-&gt;ulTblConn = 0; <br>    } <br>         <br>    OBJ_SetFlag(pims, MSF_BEINGDESTROYED); <br>     <br>    ulFlags = pims-&gt;ulFlagsSLT; <br> <br>    hr = pims-&gt;psup-&gt;lpVtbl-&gt;StoreLogoffTransports(pims-&gt;psup, &amp;ulFlags); <br> <br>#ifdef DEBUG <br>    /* The support object given us during config doesn't support */ <br>    /* StoreLogoffTransports. It isn't an error to get no support */ <br>    /* in that case. */ <br>    if (hr != hrSuccess &amp;&amp; GetScode(hr) != MAPI_E_NO_SUPPORT) <br>        TraceSz1("SMS: IMS_Neuter: StoreLogoffTransports(LOGOFF_ABORT) " <br>            "returned unexpected error %s", SzDecodeScode(GetScode(hr))); <br>#endif <br> <br>    if (pims-&gt;cRef != 0 || pims-&gt;pobjHead != 0) <br>    { <br>        TraceSz("\n---------------------------------------------------------" <br>            "-------"); <br>        TraceSz("SMS: The following objects were not released before Logoff:"); <br>        IMS_NeuterChildren((POBJ) pims, 0); <br>        TraceSz("-----------------------------------------------------------" <br>            "-----\n"); <br>    } <br> <br>    /* Free MS object's resources */ <br>    FreeNull(pims-&gt;szStorePath); <br>    FreeNull(pims-&gt;szProps); <br>    LMFree(&amp;pims-&gt;lmr, pims-&gt;eidStore.lpb); <br>    CloseRFS(pims-&gt;prfs); <br> <br>    if (pims-&gt;lptblOutgoing) <br>    { <br>        if (pims-&gt;cOutgoingViews) <br>        { <br>            TraceSz1("Sample MS: IMS_Neuter: Leaked outgoing queue table " <br>                "(# views left = %08lX)\n", pims-&gt;cOutgoingViews); <br>            pims-&gt;cOutgoingViews = 0; <br>        } <br> <br>        UlRelease(pims-&gt;lptblOutgoing); <br>    } <br> <br> <br>    CloseIMsgSession(pims-&gt;pmsgsess); <br>    pims-&gt;pmsgsess = NULL; <br> <br>    /* Make the logon object forget about us */ <br>    if (pims-&gt;pmsl) <br>        pims-&gt;pmsl-&gt;pims = NULL; <br>} <br> <br>/* <br> *  HrOpenIMSPropsFileRetry <br> * <br> *  Purpose: <br> *      Open the IMsgStore properties docfile as an IMessage <br> *      instance to get/set properties. <br> *      This retries up to NUM_RETRIES times on MAPI_E_NO_ACCESS <br> * <br> *  Arguments: <br> *      szFile      The file to open. <br> *      plmr        a pointer to the linked memory routines. <br> *      psup        a pointer to the MAPI support object. <br> *      fModify     TRUE means the caller wants read/write access. <br> *                  FALSE means read-only access. <br> *      lppmsg      Address of a location in which to return a <br> *                  pointer to the newly opened IMessage instance. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      IMessage on IStorage opening errors. <br> */ <br>HRESULT HrOpenIMSPropsFileRetry(LPMSGSESS pmsgsess, LPTSTR szFile, PLMR plmr, <br>    LPMAPISUP psup, BOOL fModify, LPMESSAGE * lppmsg) <br>{ <br>    UINT iRetry;                /* number of attempts to open */ <br>    HRESULT hr; <br> <br>    iRetry = 0; <br> <br>    while (TRUE) <br>    { <br>        hr = HrOpenIMsg(pmsgsess, szFile, plmr, psup, FALSE, fModify, TRUE, <br>            lppmsg); <br> <br>        if (GetScode(hr) != MAPI_E_NO_ACCESS || ++iRetry &gt;= NUM_RETRIES) <br>            break; <br> <br>        Sleep(500); <br>    } <br> <br>    #ifdef DEBUG <br>    if (iRetry &gt;= NUM_RETRIES) <br>        TraceSz("HrOpenIMSPropsFileRetry: Failing open. Too many tries."); <br>    #endif <br> <br>    DebugTraceResult(HrOpenIMSPropsFileRetry, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrGetSMSStandardNotifKey <br> * <br> * Purpose <br> * <br> * return the notification key for standard notifications (everything <br> * except outgoing queue notifications). <br> * memory should be freed with FreeNull <br> * <br> * In order to call the MAPI registration function, we need to turn <br> * an EntryID into a "notification key" (something unique to an <br> * object in the store that will remain constant throughout this <br> * logon session).  In the case of the Sample Store, we can just <br> * use the local file name of the object (folder or message). <br> * If the user is interested in notifications about all objects in the <br> * store, we use the store's uid for the key. <br> * <br> * Parameters <br> * pims         pointer to the message store object <br> * peid         the entryid of the object  <br> * lppKey       pointer to the location to return the key <br> */ <br>static HRESULT HrGetSMSStandardNotifKey(PIMS pims, PEID peid, <br>    LPNOTIFKEY * lppKey) <br>{ <br>    HRESULT hr; <br>    LPNOTIFKEY lpKey; <br>    ULONG cb;           /* number of bytes in the key */ <br> <br>    if (peid) <br>    { <br>        LPMAPIUID lpuidEID = NULL; <br>        LPTSTR szPathEID = NULL; <br>        LPTSTR szFileEID = NULL; <br> <br>        hr = HrDeconstructEID(peid, &amp;lpuidEID, &amp;szPathEID, &amp;szFileEID); <br>        if (hr == hrSuccess) <br>        { <br>            cb = CbNewNOTIFKEY(Cbtszsize(szFileEID)); <br>            hr = HrAlloc(cb, (PPV) &amp;lpKey); <br>        } <br> <br>        if (hr == hrSuccess) <br>        { <br>            lstrcpy((LPTSTR) &amp;lpKey-&gt;ab, szFileEID); <br>            lpKey-&gt;cb = Cbtszsize(szFileEID); <br>        } <br> <br>        FreeNull(lpuidEID); <br>        FreeNull(szPathEID); <br>        FreeNull(szFileEID); <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br>    else <br>    { <br>        /* The caller is interested in notifications on all objects in the */ <br>        /* store. Generate a key from our uid. */ <br> <br>        cb = CbNewNOTIFKEY(sizeof(MAPIUID)); <br>        hr = HrAlloc(cb, (PPV) &amp;lpKey); <br>        if (hr != hrSuccess) <br>            goto exit; <br> <br>        GetResourceUID(pims, (MAPIUID *) &amp;(lpKey-&gt;ab[0])); <br>        lpKey-&gt;cb = sizeof(MAPIUID); <br>    } <br> <br>exit: <br>    if (hr != hrSuccess) <br>        FreeNull(lpKey); <br>    else <br>        *lppKey = lpKey; <br> <br>    DebugTraceResult(HrGetSMSStandardNotifKey, hr); <br>    return hr; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
