<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPGLE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2088"></a>MSPGLE.C</h2>
<pre><code>/* <br> *  M S P G L E . C <br> * <br> *  Code for implementing the GetLastError method of all store <br> *  objects. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br>#include "msprc.h" <br> <br>/* Manifest constants */ <br> <br>#define STRING_MAX      128 <br> <br>/* Global variables */ <br> <br>/* The following array maps a string identifier (IDS) to status code */ <br>/* (SCODE).  The order of SCODEs in the array has an external        */ <br>/* dependency:  the order of elements in the array is dictated by    */ <br>/* the IDS definitions in msprc.h.  This implicit association must   */ <br>/* be maintained for the strings associated with string identifiers  */ <br>/* to make sense.  Thus, if either this structure or the one in      */ <br>/* msprc.h changes, the other must change to match it.               */ <br> <br>SCODE mpIdsScode[] = <br>{ <br>    S_OK, <br>    MAPI_E_NO_ACCESS, <br>    E_NOINTERFACE, <br>    E_INVALIDARG, <br>    MAPI_E_CALL_FAILED, <br>    MAPI_E_NOT_FOUND, <br>    MAPI_E_NO_SUPPORT, <br>    MAPI_W_ERRORS_RETURNED, <br>    MAPI_W_PARTIAL_COMPLETION, <br>    MAPI_E_BAD_CHARWIDTH, <br>    MAPI_E_BAD_VALUE, <br>    MAPI_E_BUSY, <br>    MAPI_E_COLLISION, <br>    MAPI_E_COMPUTED, <br>    MAPI_E_CORRUPT_DATA, <br>    MAPI_E_CORRUPT_STORE, <br>    MAPI_E_DISK_ERROR, <br>    MAPI_E_HAS_FOLDERS, <br>    MAPI_E_HAS_MESSAGES, <br>    MAPI_E_INVALID_ENTRYID, <br>    MAPI_E_INVALID_OBJECT, <br>    MAPI_E_LOGON_FAILED, <br>    MAPI_E_NETWORK_ERROR, <br>    MAPI_E_NON_STANDARD, <br>    MAPI_E_NOT_ENOUGH_DISK, <br>    MAPI_E_NOT_ENOUGH_MEMORY, <br>    MAPI_E_NOT_ENOUGH_RESOURCES, <br>    MAPI_E_NOT_IN_QUEUE, <br>    MAPI_E_OBJECT_CHANGED, <br>    MAPI_E_OBJECT_DELETED, <br>    MAPI_E_STRING_TOO_LONG, <br>    MAPI_E_SUBMITTED, <br>    MAPI_E_TOO_BIG, <br>    MAPI_E_UNABLE_TO_ABORT, <br>    MAPI_E_UNCONFIGURED, <br>    MAPI_E_UNEXPECTED_TYPE, <br>    MAPI_E_UNKNOWN_FLAGS, <br>    MAPI_E_USER_CANCEL, <br>    MAPI_E_VERSION <br>}; <br> <br>/* <br> *  Exported functions <br> */ <br> <br>/* <br> *  MapScodeSz <br> * <br> *  Purpose: <br> *      Look up an SCODE in a mapping of IDS &lt;-&gt; SCODE to find its <br> *      associated informational string and return it (with memory <br> *      allocated by this function) to the caller. <br> * <br> *  Arguments: <br> *      scArg       The SCODE to look up. <br> *      pims        Pointer to the message store object (where we <br> *                  obtain the memory allocation functions). <br> *      lppszError  Location in which to place an address to a <br> *                  newly allocated buffer containing the <br> *                  informational string associated with scArg. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the return string. <br> */ <br>HRESULT MapScodeSz(SCODE scArg, PIMS pims, LPTSTR * lppszError) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc = SUCCESS_SUCCESS; <br>    UINT ui = 0; <br>    UINT uiMax = 0; <br>    LPTSTR szErr = NULL; <br>    TCHAR rgch[STRING_MAX]; <br> <br>    AssertSz(lppszError, "Bad lppszError\n"); <br> <br>    /* Linear search in mpIdsScode for scArg.  When found, index is IDS. */ <br> <br>    uiMax = sizeof mpIdsScode / sizeof mpIdsScode[0]; <br>    for (ui = 0; ui &lt; uiMax; ui++) <br>    { <br>        if (mpIdsScode[ui] == scArg) <br>            break; <br>    } <br> <br>    /* If we didn't find the string, return a NULL string. */ <br> <br>    if (ui == uiMax) <br>        rgch[0] = (TCHAR) 0; <br>    else <br>    { <br>        /* Get the string from the resource.  Note:  the assumption that   */ <br>        /* rgch is large enough to hold the largest string that LoadString */ <br>        /* could return can be checked by looking at the resource strings  */ <br>        /* file, msp.rc                                                    */ <br> <br>        int iLS = 0; <br>     <br>        Assert(pims-&gt;pmsp); <br>     <br>        iLS = LoadString(pims-&gt;pmsp-&gt;hInst, ui, rgch, STRING_MAX); <br>        AssertSz(iLS, "Unknown string identifier!"); <br>        AssertSz(iLS &lt; STRING_MAX-1, "String resource truncated!"); <br>    } <br> <br>    /* Allocate memory for return variable and set it */ <br> <br>    sc = LMAlloc(&amp;pims-&gt;lmr, Cbtszsize(rgch), &amp;szErr); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    lstrcpy(szErr, rgch); <br>    *lppszError = szErr; <br> <br>exit: <br>    DebugTraceResult(MapScodeSz, hr); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
