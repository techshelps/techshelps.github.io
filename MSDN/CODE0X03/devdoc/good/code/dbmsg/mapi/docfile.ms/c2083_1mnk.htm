<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPINIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2090"></a>MSPINIT.C</h2>
<pre><code>/* <br> *  M S P I N I T . C <br> * <br> *  Initialize the MAPI Sample Message Store Provider. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br> <br>CHAR szFolderTemplate[]         = "*.fld"; <br>CHAR szMessageTemplate[]        = "*.msg"; <br>CHAR szPropertyFileName[]       = "folder.prp"; <br>CHAR szHierarchyFileName[]      = "hierarch.tbl"; <br>CHAR szContentsFileName[]       = "contents.tbl"; <br>CHAR szOutgoingFileName[]       = "outgoing.tbl"; <br> <br>#define MSP_CheckParameters(pobj, intf, method, arglist)        \ <br>        OBJ_CheckParameters(pobj, intf, method, sizeof(MSP), &amp;vtblMSP, arglist) <br> <br>MSP_Vtbl vtblMSP = <br>{ <br>    (MSP_QueryInterface_METHOD *)   OBJ_QueryInterface, <br>    (MSP_AddRef_METHOD *)           OBJ_AddRef, <br>    MSP_Release, <br>    MSP_Shutdown, <br>    MSP_Logon, <br>    MSP_SpoolerLogon, <br>    MSP_CompareStoreIDs <br>}; <br> <br>/* <br> *  Exported functions <br> */ <br> <br>/* <br> *  MSProviderInit <br> * <br> *  Purpose: <br> *      Message Store Provider initialization and version handshake <br> *      with MAPI.  Called once for each MAPI Session that uses this <br> *      store provider DLL on this process.  Passes back an init <br> *      object (LPMSPROVIDER) used for further access to this provider. <br> * <br> *  Arguments: <br> *      ulFlags         Reserved for future use.  Ignored. <br> *      ulMAPIVersion   Version of Message Store SPI used by MAPI. <br> *      lpulMDBVersion  [out] Version of SPI supported by the provider. <br> *      ppmsp   [out] MS Provider object for further access. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_VERSION              Require a higher version of MAPI <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Insufficient memory <br> *      Any errors from ScInitMSInstance() <br> */ <br>STDINITMETHODIMP <br>MSProviderInit(HINSTANCE hInstance, LPMALLOC pmalloc, <br>    LPALLOCATEBUFFER pfnAllocBuf, LPALLOCATEMORE pfnAllocMore, <br>    LPFREEBUFFER pfnFreeBuf, ULONG ulFlags, ULONG ulMAPIVersion, <br>    ULONG * pulMDBVersion, LPMSPROVIDER * ppmsp) <br>{ <br>    SCODE sc = S_OK; <br>    PMSP pmsp = NULL; <br> <br>    AssertSz(pmalloc, "Bad pmalloc"); <br>    AssertSz(pfnAllocBuf, "Bad pfnAllocBuf"); <br>    AssertSz(pfnAllocMore, "Bad pfnAllocMore"); <br>    AssertSz(pfnFreeBuf, "Bad pfnFreeBuf"); <br>    NFAssertSz(!ulFlags, "Unknown flags, bug in MAPI DLL"); <br>    AssertSz(pulMDBVersion, "Bad pulMDBVersion"); <br>    AssertSz(ppmsp, "Bad ppmsp"); <br> <br>    /* This provider requires MAPI to be at least the version <br>     * of the SPI defined at the time this provider was compiled. <br>     */ <br>    if (ulMAPIVersion &lt; CURRENT_SPI_VERSION) <br>    { <br>        sc = MAPI_E_VERSION; <br>        goto exit; <br>    } <br> <br>    /* Initialize the per-instance global data */ <br>    sc = ScInitMSInstance(pmalloc); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    /* Allocate and initialize the MSPROVIDER object. */ <br>    sc = ScAllocZ(sizeof(MSP), (PPV) &amp;pmsp); <br>    if (sc != S_OK) <br>    { <br>        DeinitMSInstance(); <br>        goto exit; <br>    } <br> <br>    OBJ_Initialize(pmsp, &amp;vtblMSP, OT_MSPROVIDER, 0, &amp;pmsp-&gt;cs); <br> <br>    pmsp-&gt;hInst = hInstance; <br>    pmsp-&gt;lmr.lpAllocBuf = pfnAllocBuf; <br>    pmsp-&gt;lmr.lpAllocMore = pfnAllocMore; <br>    pmsp-&gt;lmr.lpFreeBuf = pfnFreeBuf; <br> <br>    InitializeCriticalSection(&amp;pmsp-&gt;cs); <br> <br>    /* Pass back [out] parameters. */ <br>    *pulMDBVersion = CURRENT_SPI_VERSION; <br>    *ppmsp = (LPMSPROVIDER) pmsp; <br> <br>exit: <br>    DebugTraceSc(MSProviderInit, sc); <br>    return ResultFromScode(ScCheckSc(sc, IMSProvider_Init)); <br>} <br> <br>/* <br> -  MSP_Release <br> - <br> */ <br> <br>STDMETHODIMP_(ULONG) MSP_Release(PMSP pmsp) <br>{ <br>    LONG cRef; <br> <br>    MSP_EnterCriticalSection(pmsp); <br> <br>    cRef = --pmsp-&gt;cRef; <br> <br>    AssertSz2(cRef &gt;= 0, "MSP_Release(pmsp=%08lX): Bogus cRef (%08lX)", <br>        pmsp, cRef); <br> <br>    AssertSz(cRef &gt; 0 || pmsp-&gt;pobjHead == NULL, "There are still valid logons"); <br> <br>    MSP_LeaveCriticalSection(pmsp); <br> <br>    if (cRef == 0) <br>    { <br>        DeleteCriticalSection(&amp;pmsp-&gt;cs); <br>        FreeNull(pmsp); <br>        DeinitMSInstance(); <br>    } <br> <br>    return (cRef); <br>} <br> <br>/* <br> *  MSP_Shutdown <br> * <br> *  Purpose: <br> *      Allow MAPI to specify flags related to the Release(). <br> * <br> *  Arguments: <br> *      pulFlags        Reserved for future use.  Ignored. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDMETHODIMP <br>MSP_Shutdown(PMSP pmsp, ULONG * pulFlags) <br>{ <br>    MSP_CheckParameters( <br>            pmsp,  <br>            IMSProvider,  <br>            Shutdown, <br>            (pmsp, <br>            pulFlags)); <br> <br>    MSP_EnterCriticalSection(pmsp); <br> <br>    /* MAPI says it will never call Release with valid logons, */ <br>    /* let's make sure.                                        */ <br> <br>    AssertSz(pmsp-&gt;pobjHead == NULL, "There are still valid logons"); <br> <br>#ifdef DEBUG <br>    pmsp-&gt;fInvalid = TRUE; <br>#endif <br> <br>    MSP_LeaveCriticalSection(pmsp); <br> <br>    return 0; <br>} <br> <br>/* <br> *  MSP_CompareStoreIDs <br> * <br> *  Purpose: <br> *      Compare the EntryIDs of two message stores. <br> * <br> *  Arguments: <br> *      pmsp                MSPROVIDER object returned by MSProviderInit. <br> *      lcbEntryID1         Size of first EntryID. <br> *      lpEntryID1          First EntryID to compare. <br> *      lcbEntryID2         Size of second EntryID. <br> *      lpEntryID2          Second EntryID to compare. <br> *      ulFlags             Flags.  Reserved for future use. <br> *      pulResult           Address in which to place the result of <br> *                          the comparison (TRUE or FALSE). <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDMETHODIMP <br>MSP_CompareStoreIDs(PMSP pmsp, ULONG lcbEntryID1, LPENTRYID lpEntryID1, <br>    ULONG lcbEntryID2, LPENTRYID lpEntryID2, ULONG ulFlags, <br>    ULONG *pulResult) <br>{ <br>    PEID peid1 = (PEID) lpEntryID1; <br>    PEID peid2 = (PEID) lpEntryID2; <br> <br>    MSP_CheckParameters( <br>            pmsp,  <br>            IMSProvider, <br>            CompareStoreIDs, <br>            (pmsp, <br>            lcbEntryID1,  <br>            lpEntryID1, <br>            lcbEntryID2,  <br>            lpEntryID2,  <br>            ulFlags, <br>            pulResult)); <br> <br>    AssertSz(!pmsp-&gt;fInvalid, <br>        "This MSProvider has already been shutdown"); <br> <br>    /* The Sample Store's method of deriving and comparing   */ <br>    /* store EntryIDs has the quirky behavior that if any    */ <br>    /* OTHER store's EntryIDs are binary-comparable, this    */ <br>    /* function will return a successful match, without ever */ <br>    /* knowing that the EntryIDs were not Sample Store       */ <br>    /* EntryIDs.  A subsequent logon would, of course, fail. */ <br> <br>    /* Case-insensitive string compare on part, binary on rest. */ <br>    if (    lcbEntryID1 &gt;= offsetof(EID, szPath) + sizeof(TCHAR) <br>        &amp;&amp;  lcbEntryID1 == lcbEntryID2 <br>        &amp;&amp;  memcmp(peid1, peid2, offsetof(EID, szPath)) == 0 <br>        &amp;&amp;  peid1-&gt;bVersion == SMPMS_VERSION <br>        &amp;&amp;  lstrcmpi(peid1-&gt;szPath, peid2-&gt;szPath) == 0) <br>    { <br>        *pulResult = TRUE; <br>    } <br>    else <br>    { <br>        *pulResult = FALSE; <br>    } <br> <br>    return hrSuccess; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
