<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ABCTBL2.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2108"></a>ABCTBL2.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ABCTBL2.C <br> * <br> *  Contents Table - Part 2. <br> * <br> * <br> *  The following routines are implemented in this file. <br> * <br> * <br> *      IVTABC_SeekRow <br> *      IVTABC_SeekRowApprox <br> *      IVTABC_GetRowCount <br> *      IVTABC_QueryPosition <br> *      IVTABC_FindRow <br> *      IVTABC_Restrict <br> *      IVTABC_QueryRows <br> * <br> * <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br>#include "abp.h" <br>#include "abctbl.h" <br>#include "sampabp.rh" <br> <br>/************************************************************************* <br> * <br> -  IVTABC_SeekRow <br> - <br> * <br> *  Tries to seek an appropriate number of rows. <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_SeekRow(LPIVTABC lpIVTAbc, <br>    BOOKMARK bkOrigin, <br>    LONG lRowCount, <br>    LONG * lplRowsSought) <br>{ <br>    LONG lNewPos; <br>    LONG lMoved; <br>    LONG lDelta; <br>    LONG lLast; <br>    HRESULT hResult = hrSuccess; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(SeekRow, lpIVTAbc); <br> <br>    Validate_IMAPITable_SeekRow(lpIVTAbc, bkOrigin, lRowCount, lplRowsSought); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    if (bkOrigin == BOOKMARK_BEGINNING) <br>    { <br>        lNewPos = 0; <br> <br>    } <br>    else if (bkOrigin == BOOKMARK_CURRENT) <br>    { <br>        lNewPos = lpIVTAbc-&gt;ulPosition; <br> <br>    } <br>    else if (bkOrigin == BOOKMARK_END) <br>    { <br>        lNewPos = lpIVTAbc-&gt;ulMaxPos; <br> <br>    } <br>    else <br>    { <br>        ULONG ulBK = (ULONG) bkOrigin - 3; <br>        LPABCBK lpABCBK = NULL; <br> <br>        /* <br>         *  See if it's out of range <br>         */ <br>        if (ulBK &lt; 0 || ulBK &gt;= MAX_BOOKMARKS) <br>        { <br>            /* <br>             *  bad book mark, it's an error, so... <br>             */ <br>            hResult = ResultFromScode(E_INVALIDARG); <br> <br>            goto out; <br>        } <br> <br>        if (!(lpABCBK = lpIVTAbc-&gt;rglpABCBK[ulBK])) <br>        { <br>            /* <br>             *  bookmark has not been allocated <br>             */ <br>            hResult = ResultFromScode(MAPI_E_INVALID_BOOKMARK); <br> <br>            goto out; <br>        } <br> <br>        /* Not validating existing bookmark  */ <br>        lNewPos = lpABCBK-&gt;ulPosition; <br>    } <br> <br>    /* <br>     *  Figure out what endpoint to use and what direction to go to <br>     *  get there. <br>     */ <br>    if (lRowCount &lt; 0) <br>    { <br>        lLast = 0; <br>        lDelta = -1; <br>    } <br>    else <br>    { <br>        lLast = lpIVTAbc-&gt;ulMaxPos; <br>        lDelta = 1; <br>    } <br> <br>    /* <br>     *  While there's rows to seek ... <br>     */ <br>    lMoved = 0; <br>    while (lNewPos != lLast &amp;&amp; <br>        lMoved != lRowCount) <br>    { <br>        lNewPos += lDelta; <br> <br>        /* <br>         *  Unrestricted list is easy: just seek.  Also, if the next <br>         *  'row' is the end of the table, just go there; don't want <br>         *  to check it against any restriction. <br>         */ <br>        if (!lpIVTAbc-&gt;lpszPartialName || <br>            lNewPos == (LONG) lpIVTAbc-&gt;ulMaxPos) <br>        { <br>            lMoved += lDelta; <br>        } <br> <br>        /* <br>         *  Otherwise, deal with the restricted list:  only count <br>         *  the row if it's in the restriction. <br>         */ <br>        else <br>        { <br>            if (!FChecked(lpIVTAbc, (ULONG) lNewPos)) <br>            { <br>                hResult = HrValidateEntry(lpIVTAbc, (ULONG) lNewPos); <br> <br>                if (HR_FAILED(hResult)) <br>                { <br>                    goto out; <br>                } <br>            } <br> <br>            if (FMatched(lpIVTAbc, (ULONG) lNewPos)) <br>            { <br>                lMoved += lDelta; <br>            } <br>        } <br>    } <br> <br>    if (lplRowsSought) <br>        *lplRowsSought = lMoved; <br> <br>    lpIVTAbc-&gt;ulPosition = lNewPos; <br> <br>out: <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_SeekRow, hResult); <br>    return hResult; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_SeekRowApprox <br> - <br> *  Tries to set the position of the table according to the approximate <br> *  position passed in. <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_SeekRowApprox(LPIVTABC lpIVTAbc, <br>    ULONG ulNumerator, <br>    ULONG ulDenominator) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    ULONG iByte; <br>    BYTE bCount; <br>    ULONG ulPos = 0; <br>    ULONG ulCount = 0; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(SeekRowApprox, lpIVTAbc); <br> <br>    Validate_IMAPITable_SeekRowApprox(lpIVTAbc, ulNumerator, ulDenominator); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br> <br>    if (ulNumerator &gt;= ulDenominator) <br>    { <br>        /*  We're at the end of the list */ <br>        lpIVTAbc-&gt;ulPosition = lpIVTAbc-&gt;ulMaxPos; <br> <br>        hResult = hrSuccess; <br>        goto out; <br>    } <br> <br>    /* <br>     *  Since I'm using muldiv() which takes ints/longs, I should shift right <br>     *  so that I don't incorrectly call it. <br>     *  I'm really just checking to see if the sign bit is set... <br>     */ <br> <br>    if (((long)ulNumerator &lt; 0) || ((long)ulDenominator &lt; 0)) <br>    { <br>        ulNumerator &gt;&gt;= 1; <br>        ulDenominator &gt;&gt;= 1; <br>    } <br> <br>    if (!lpIVTAbc-&gt;lpszPartialName) <br>    { <br>        /* <br>         *  The NON-Restriction method <br>         */ <br> <br>        lpIVTAbc-&gt;ulPosition = MULDIV(lpIVTAbc-&gt;ulMaxPos, ulNumerator, <br>            ulDenominator); <br> <br>        hResult = hrSuccess; <br>        goto out; <br>    } <br> <br>    /* <br>     *  Restriction method <br>     */ <br> <br>    /*  Figure out % of which corresponds with numerator. */ <br>    ulCount = MULDIV(lpIVTAbc-&gt;ulRstrDenom, ulNumerator, ulDenominator); <br> <br>    /*  Count bits in rgMatched until I match numerator */ <br> <br>    for (iByte = 0; iByte &lt; (lpIVTAbc-&gt;ulMaxPos / 8); iByte++) <br>    { <br>        CBitsB(lpIVTAbc-&gt;rgMatched[iByte], bCount); /* &lt;-- MACRO  */ <br>        ulPos += (ULONG) bCount; <br> <br>        if (ulPos &gt;= ulCount) <br>        { <br>            ulPos -= bCount;    /* Go back a byte */ <br>            break; <br>        } <br>    } <br> <br>    /*  My current position is there. */ <br>    lpIVTAbc-&gt;ulPosition = iByte * 8; <br> <br> <br>out: <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_SeekRowApprox, hResult); <br>    return hResult; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_GetRowCount <br> - <br> * <br> *  If there's a restriction applied, I don't necessarily know how many <br> *  rows there are... <br> */ <br> <br>STDMETHODIMP  <br>IVTABC_GetRowCount(LPIVTABC lpIVTAbc, <br>    ULONG ulFlags, <br>    ULONG * lpulCount) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(GetRowCount, lpIVTAbc); <br> <br>    Validate_IMAPITable_GetRowCount(lpIVTAbc, ulFlags, lpulCount); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    /* <br>     *  If there's no restriction, you can actually calculate this.. <br>     */ <br>    if (!lpIVTAbc-&gt;lpszPartialName) <br>    { <br> <br>        /* <br>         *  Number of actual rows <br>         */ <br>        *lpulCount = lpIVTAbc-&gt;ulMaxPos; <br>        hResult = hrSuccess; <br>        goto out; <br>    } <br> <br>    /* <br>     *  There's no way that I can tell how many actual entries there <br>     *  are without counting them.  That takes way too long, so we give <br>     *  the client our best guess. <br>     */ <br> <br>    *lpulCount = lpIVTAbc-&gt;ulRstrDenom; <br> <br>    /* <br>     *  Then we warn the client that this count may not be accurate <br>     */ <br>     <br>    hResult = ResultFromScode(MAPI_W_APPROX_COUNT); <br> <br>out: <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_GetRowCount, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_QueryPosition <br> - <br> *  Figures out the current fractional position <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_QueryPosition(LPIVTABC lpIVTAbc, <br>    ULONG * lpulRow, <br>    ULONG * lpulNumerator, <br>    ULONG * lpulDenominator) <br>{ <br>    HRESULT hResult = hrSuccess; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(QueryPosition, lpIVTAbc); <br> <br>    Validate_IMAPITable_QueryPosition(lpIVTAbc, lpulRow, lpulNumerator, <br>                                        lpulDenominator); <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br> <br>    /*  ...I don't have a restriction  */ <br>    if (!lpIVTAbc-&gt;lpszPartialName) <br>    { <br>        *lpulRow = lpIVTAbc-&gt;ulPosition; <br> <br>        *lpulNumerator = lpIVTAbc-&gt;ulPosition; <br>        *lpulDenominator = lpIVTAbc-&gt;ulMaxPos; <br>    } <br>    else <br>    { <br>        BYTE bCount = 0; <br>        BYTE bFrag; <br>        ULONG iByte; <br> <br>        /* <br>         *  Zero out fraction <br>         */ <br>        *lpulNumerator = 0; <br> <br>        /* <br>         *  Set denominator that we've been keeping track of. <br>         */ <br>        *lpulDenominator = (lpIVTAbc-&gt;ulRstrDenom ? lpIVTAbc-&gt;ulRstrDenom : 1); <br> <br>        /* <br>         *  Handle corner case - we're at the beginning of the list... <br>         */ <br>        if (lpIVTAbc-&gt;ulPosition == 0) <br>        { <br>            *lpulRow = 0; <br>            goto out; <br>        } <br> <br>        /* <br>         *  Calculate Numerator <br>         *  We use the rgMatched bit array and count the bits up to <br>         *  our current position (lpIVTAbc-&gt;ulPosition). <br>         * <br>         */ <br>        for (iByte = 0; iByte &lt; (lpIVTAbc-&gt;ulPosition / 8); iByte++) <br>        { <br>            CBitsB(lpIVTAbc-&gt;rgMatched[iByte], bCount); /* &lt;-- MACRO  */ <br>            *lpulNumerator += (ULONG) bCount; <br>        } <br>        /*  Count the fragment  */ <br>        bFrag = lpIVTAbc-&gt;rgMatched[iByte]; <br>        bFrag = bFrag &gt;&gt; (8 - (lpIVTAbc-&gt;ulPosition % 8)); <br> <br>        CBitsB(bFrag, bCount); <br>        *lpulNumerator += (ULONG) bCount; <br> <br>        /* <br>         *  Good guess here... <br>         */ <br>        *lpulRow = *lpulNumerator; <br> <br>    } <br> <br>out: <br> <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_QueryPosition, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_FindRow <br> - <br> * <br> *  Prefix searches to find a row <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_FindRow(LPIVTABC lpIVTAbc, <br>    LPSRestriction lpRestriction, <br>    BOOKMARK bkOrigin, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hResult = hrSuccess; <br> <br>    ULONG cbRead; <br>    ABCREC abcrec; <br>    LONG lpos; <br>    ULONG fFound = FALSE; <br>    LPSTR szPrefix; <br>    int nCmpResult; <br> <br>    ULONG ulCurMin; <br>    ULONG ulCurMac; <br>    ULONG ulPosT; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(FindRow, lpIVTAbc); <br> <br>    Validate_IMAPITable_FindRow(lpIVTAbc, lpRestriction, bkOrigin, ulFlags); <br> <br> <br>    /* <br>     *  I don't go backwards, yet. <br>     */ <br>    if (ulFlags &amp; DIR_BACKWARD) <br>    { <br>        hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>        DebugTraceResult(IVTABC_FindRow, hResult); <br>        return hResult; <br>    } <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    /* <br>     *  Open the file <br>     */ <br>    hResult = HrOpenFile(lpIVTAbc); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto out; <br>    } <br> <br>    /* <br>     *  initialize <br>     */ <br>    ulCurMin = lpIVTAbc-&gt;ulPosition; <br>    ulCurMac = lpIVTAbc-&gt;ulMaxPos; <br> <br>    /* <br>     *  I handle two type of restrictions:  <br>     *      prefix searching on Display Names <br>     *      Finding a row based on it's instance key <br>     */ <br> <br>    /* <br>     *  The prefix search on display name restriction looks like: <br>     * <br>     *  +----------------- <br>     *  | RES_PROPERTY <br>     *  +----------------- <br>     *  | RELOP_GE <br>     *  +----------------- <br>     *  | PR_DISPLAY_NAME <br>     *  +----------------- <br>     *  | LPSPropVal   -----+ <br>     *  +-----------------  | <br>     *                      |   +------------------------- <br>     *                      +--&gt;| PR_DISPLAY_NAME <br>     *                          +------------------------- <br>     *                          | 0 &lt;-- for alignment (don't care) <br>     *                          +------------------------- <br>     *                          | lpszA &lt;-- prefix for display name <br>     *                          +------------------------- <br>     * <br>     * <br>     * <br>     *              -OR- <br>     * <br>     *  Find a row based on it's instance key <br>     * <br>     *  +----------------- <br>     *  | RES_PROPERTY <br>     *  +----------------- <br>     *  | RELOP_EQ <br>     *  +----------------- <br>     *  | PR_INSTANCE_KEY <br>     *  +----------------- <br>     *  | LPSPropVal   -----+ <br>     *  +-----------------  | <br>     *                      |   +------------------------- <br>     *                      +--&gt;| PR_INSTANCE_KEY <br>     *                          +------------------------- <br>     *                          |     | cbInstanceKey <br>     *                          + bin +------------------- <br>     *                          |     | lpbInstanceKey <br>     *                          +------------------------- <br>     * <br>     * <br>     *  If it doesn't look like one of these, return MAPI_E_TOO_COMPLEX. <br>     */ <br> <br>    /* <br>     *  Both restrictions require this one <br>     */ <br>    if (lpRestriction-&gt;rt != RES_PROPERTY) <br>    { <br>        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX); <br> <br>        goto out; <br>    } <br> <br> <br>    /* <br>     *  Look for Instance Key first - it's easiest to handle <br>     */ <br>    if (lpRestriction-&gt;res.resProperty.relop == RELOP_EQ) <br>    { <br>        LPABCRecInstance lpABCRecInstance; <br>         <br>        if (lpRestriction-&gt;res.resProperty.ulPropTag != PR_INSTANCE_KEY) <br>        { <br>            /* <br>             *  Clearly something we don't recognize <br>             */ <br>            hResult = ResultFromScode(MAPI_E_TOO_COMPLEX); <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  Crack the bin part of this restriction and <br>         *  see if we can still find our way back to this <br>         *  record - quickly... <br>         */ <br>        lpABCRecInstance = (LPABCRecInstance) lpRestriction-&gt;res.resProperty.lpProp-&gt;Value.bin.lpb; <br> <br>        /* <br>         *  First check to see that we're browsing the same file <br>         */ <br>        if (lstrcmp(lpABCRecInstance-&gt;rgchzFileName, lpIVTAbc-&gt;lpszFileName)) <br>        { <br>            /* <br>             *  Nope, different names, return not found and leave our position alone... <br>             */ <br>            hResult = ResultFromScode(MAPI_E_NOT_FOUND); <br>            goto out; <br>        } <br> <br>        /* <br>         *  Ok, so we think we're browsing the same file.  Has it been modified since the <br>         *  last time we looked? <br>         */ <br>        if (memcmp(&amp;(lpABCRecInstance-&gt;filetime), &amp;(lpIVTAbc-&gt;filetime), sizeof (FILETIME))) <br>        { <br>            /* <br>             *  Nope, they're different, so no guarantees here... <br>             */ <br>            hResult = ResultFromScode(MAPI_E_NOT_FOUND); <br>            goto out; <br>        } <br> <br>        /* <br>         *  Now, I feel pretty confident about this instance key.  Just set my current position <br>         *  and go for it. <br>         */ <br>        lpIVTAbc-&gt;ulPosition = lpABCRecInstance-&gt;ulRecordPosition; <br> <br>        /* Done */ <br>        goto out; <br> <br>    } <br>             <br>    /* <br>     *  Now we're looking for prefix searching on display name <br>     */ <br>    if (lpRestriction-&gt;res.resProperty.relop != RELOP_GE) <br>    { <br>        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX); <br> <br>        goto out; <br>    } <br> <br>    if (lpRestriction-&gt;res.resProperty.ulPropTag != PR_DISPLAY_NAME_A) <br>    { <br>        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX); <br> <br>        goto out; <br>    } <br> <br>    szPrefix = lpRestriction-&gt;res.resProperty.lpProp-&gt;Value.lpszA; <br> <br>    if (bkOrigin == BOOKMARK_BEGINNING) <br>    { <br>        ulCurMin = 0; <br> <br>    } <br>    else if (bkOrigin == BOOKMARK_END) <br>    { <br>        ulCurMin = lpIVTAbc-&gt;ulMaxPos; <br> <br>    } <br>    else if (bkOrigin != BOOKMARK_CURRENT) <br>    { <br>        ULONG ulBK = (ULONG) bkOrigin - 3; <br>        LPABCBK lpABCBK = NULL; <br> <br>        /* <br>         *  See if it's out of range <br>         */ <br>        if (ulBK &lt; 0 || ulBK &gt;= MAX_BOOKMARKS) <br>        { <br>            /* <br>             *  bad book mark, it's an error, so... <br>             */ <br>            hResult = ResultFromScode(E_INVALIDARG); <br> <br>            goto out; <br>        } <br> <br>        if (!(lpABCBK = lpIVTAbc-&gt;rglpABCBK[ulBK])) <br>        { <br>            /* <br>             *  bookmark has not been allocated <br>             */ <br>            hResult = ResultFromScode(MAPI_E_INVALID_BOOKMARK); <br> <br>            goto out; <br>        } <br> <br>        /*  Not validating existing bookmark  */ <br>        ulCurMin = lpABCBK-&gt;ulPosition; <br>    } <br> <br>    while (ulCurMin &lt; ulCurMac) <br>    { <br>        /* <br>         *  Look for a row which matches the table restriction (if any). <br>         */ <br>        ulPosT = (ulCurMin + ulCurMac) / 2; <br> <br>        lpos = (long)((long)ulPosT * (long)sizeof(ABCREC)); <br> <br>        SetFilePointer(lpIVTAbc-&gt;hFile, lpos, NULL, FILE_BEGIN); <br> <br>        /*  Read in the record at that location  */ <br>        if (!ReadFile(lpIVTAbc-&gt;hFile, (LPVOID) &amp;abcrec, <br>                sizeof(ABCREC), &amp;cbRead, NULL)) <br>        { <br>            hResult = ResultFromScode(MAPI_E_DISK_ERROR); <br>            SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_NO_READ); <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  I want case insensitive comparisons here... <br>         */ <br>        nCmpResult = lstrcmpi(szPrefix, abcrec.rgchDisplayName); <br> <br>        if (nCmpResult &gt; 0) <br>        { <br>            ulCurMin = ulPosT + 1; <br>        } <br>        else <br>        { <br>            ulCurMac = ulPosT; <br>            if (!lpIVTAbc-&gt;lpszPartialName || <br>                FNameMatch(lpIVTAbc, abcrec.rgchDisplayName)) <br>            { <br>                fFound = TRUE; <br>            } <br>        } <br>    } <br> <br>    /* <br>     *  If I didn't find a row, return MAPI_E_NOT_FOUND. <br>     */ <br>    if (!fFound) <br>    { <br>        hResult = ResultFromScode(MAPI_E_NOT_FOUND); <br> <br>        goto out; <br>    } <br> <br>    /* <br>     *  Otherwise, set the current position to the row found. <br>     */ <br>    lpIVTAbc-&gt;ulPosition = ulCurMac; <br> <br>out: <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_FindRow, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_Restrict <br> - <br> * <br> *      Should just support ANR type restrictions... <br> */ <br>STDMETHODIMP  <br>IVTABC_Restrict(LPIVTABC lpIVTAbc, <br>    LPSRestriction lpRestriction, <br>    ULONG ulFlags) <br>{ <br>    LPSTR szT = NULL; <br>    LPSTR lpszTNew = NULL; <br>    ULONG cbTB = 0; <br>    BYTE bFilter = 0; <br>    SCODE scode; <br>    HRESULT hResult = hrSuccess; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(Restrict, lpIVTAbc); <br> <br>    Validate_IMAPITable_Restrict(lpIVTAbc, lpRestriction, ulFlags); <br> <br> <br>    /* <br>     *  I only handle ANR type restrictions <br>     */ <br> <br>    /* <br>     *  Check to see if they're resetting the restrictions <br>     */ <br>    if (!lpRestriction) <br>    { <br>        EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br>         <br>        if (lpIVTAbc-&gt;lpszPartialName) <br>            (*(lpIVTAbc-&gt;lpFreeBuff)) (lpIVTAbc-&gt;lpszPartialName); <br>        lpIVTAbc-&gt;lpszPartialName = NULL; <br> <br>        FreeANRBitmaps(lpIVTAbc); <br> <br>        LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br>         <br>        return hrSuccess; <br>    } <br> <br>    /* <br>     *  The restriction must look like: <br>     * <br>     * <br>     *  +-------------- <br>     *  | RES_PROPERTY <br>     *  +-------------- <br>     *  | RELOP_EQ <br>     *  +-------------- <br>     *  | PR_ANR <br>     *  +-------------- <br>     *  | LPSPropVal ---+ <br>     *  +-------------- | <br>     *                  |   +------------------------- <br>     *                  +--&gt;| PR_ANR <br>     *                      +------------------------- <br>     *                      | 0 &lt;-- for alignment (don't care) <br>     *                      +------------------------- <br>     *                      | lpszA &lt;-- string to ANR on <br>     *                      +------------------------- <br>     * <br>     * <br>     * <br>     *  If it doesn't look like this, return MAPI_E_TOO_COMPLEX. <br>     * <br>     */ <br> <br>    if (lpRestriction-&gt;rt != RES_PROPERTY) <br>    { <br>        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX); <br> <br>        goto out; <br>    } <br> <br>    if (lpRestriction-&gt;res.resProperty.relop != RELOP_EQ) <br>    { <br>        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX); <br> <br>        goto out; <br>    } <br> <br>    if (lpRestriction-&gt;res.resProperty.ulPropTag != PR_ANR) <br>    { <br>        hResult = ResultFromScode(MAPI_E_TOO_COMPLEX); <br> <br>        goto out; <br>    } <br> <br>    /* <br>     *  NULL string is not defined - it's a bad restriction <br>     */ <br>    if (!lpRestriction-&gt;res.resProperty.lpProp-&gt;Value.lpszA) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>         <br>        goto out; <br>    } <br> <br> <br>    szT = lpRestriction-&gt;res.resProperty.lpProp-&gt;Value.lpszA; <br> <br>    /* <br>     *  Skip over leading spaces <br>     */ <br> <br>    while (*szT == ' ') <br>        szT++; <br> <br>    /* <br>     *  Empty string is not defined - it's a bad restriction <br>     */ <br>    if (*szT == '\0') <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br> <br>    /* <br>     *  Copy the string for the partial name <br>     */ <br> <br>    scode = lpIVTAbc-&gt;lpAllocBuff(lstrlenA(szT) + 1, (LPVOID *) &amp;lpszTNew); <br>    if (FAILED(scode)) <br>    { <br>        /* <br>         *  Memory error <br>         */ <br> <br>        hResult = ResultFromScode(scode); <br>        goto out; <br>    } <br>    lstrcpyA(lpszTNew, szT); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br> <br>    /* <br>     *  Clear up any old restriction <br>     */ <br> <br>    if (lpIVTAbc-&gt;lpszPartialName) <br>        lpIVTAbc-&gt;lpFreeBuff(lpIVTAbc-&gt;lpszPartialName); <br>     <br>    lpIVTAbc-&gt;lpszPartialName = lpszTNew; <br> <br>    FreeANRBitmaps(lpIVTAbc); <br> <br> <br>    /* <br>     *  Allocate enough bits for the checked&amp;matched arrays <br>     */ <br>    cbTB = (lpIVTAbc-&gt;ulMaxPos) / 8 + 1;    /* Number of bytes in both arrays */ <br> <br>    lpIVTAbc-&gt;rgChecked = lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Alloc( <br>        lpIVTAbc-&gt;lpMalloc, <br>        cbTB); <br> <br>    if (lpIVTAbc-&gt;rgChecked == NULL) <br>    { <br>        lpIVTAbc-&gt;lpFreeBuff(lpIVTAbc-&gt;lpszPartialName); <br>        lpIVTAbc-&gt;lpszPartialName = NULL; <br> <br>        hResult = ResultFromScode(scode); <br> <br>        LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br>        goto out; <br>    } <br> <br>    lpIVTAbc-&gt;rgMatched = lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Alloc( <br>        lpIVTAbc-&gt;lpMalloc, <br>        cbTB); <br> <br>    if (lpIVTAbc-&gt;rgMatched == NULL) <br>    { <br>        (*(lpIVTAbc-&gt;lpFreeBuff)) (lpIVTAbc-&gt;lpszPartialName); <br>        lpIVTAbc-&gt;lpszPartialName = NULL; <br> <br>        lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Free(lpIVTAbc-&gt;lpMalloc, lpIVTAbc-&gt;rgChecked); <br>        lpIVTAbc-&gt;rgChecked = NULL; <br> <br>        hResult = ResultFromScode(scode); <br> <br>        LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Initialize the checked array with 0's <br>     */ <br> <br>    FillMemory(lpIVTAbc-&gt;rgChecked, (UINT) cbTB, 0x00); <br> <br>    /* <br>     *  Initialize the matched array with 1's <br>     *  [we assume that if you haven't checked it, it matches] <br>     */ <br> <br>    FillMemory(lpIVTAbc-&gt;rgMatched, (UINT) cbTB, 0xFF); <br> <br>    /* <br>     *  Fill in the end bits so we don't have to worry about them <br>     *  later <br>     */ <br>    bFilter = (0xFF &gt;&gt; (lpIVTAbc-&gt;ulMaxPos % 8)); <br> <br>    /*  Checked end bits should be 1 */ <br>    lpIVTAbc-&gt;rgChecked[cbTB - 1] = bFilter; <br> <br>    /*  Matched end bits should be 0 */ <br>    lpIVTAbc-&gt;rgMatched[cbTB - 1] = ~bFilter; <br> <br>    /* <br>     *  Set the currenly known total number of rows <br>     *  that match the restriction. <br>     */ <br> <br>    lpIVTAbc-&gt;ulRstrDenom = lpIVTAbc-&gt;ulMaxPos; <br> <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>out: <br> <br>    DebugTraceResult(IVTABC_Restrict, hResult); <br>    return hResult; <br> <br>} <br> <br> <br> <br>/************************************************************************* <br> * <br> -  IVTABC_QueryRows <br> - <br> *  Attempts to retrieve ulRowCount rows from the .SAB file.  Even in the <br> *  restricted case. <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_QueryRows(LPIVTABC lpIVTAbc, <br>    LONG lRowCount, <br>    ULONG ulFlags, <br>    LPSRowSet * lppRows) <br>{ <br>    SCODE scode; <br>    HRESULT hResult = hrSuccess; <br>    LPSRowSet lpRowSet = NULL; <br>    LPSPropValue lpRow = NULL; <br>    int cbSizeOfRow; <br>    int cRows, iRow; <br>    int cCols; <br>    DWORD cbRead; <br>    ABCREC abcrec; <br>    ULONG ulOrigPosition; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(QueryRows, lpIVTAbc); <br> <br>    Validate_IMAPITable_QueryRows(lpIVTAbc, lRowCount, ulFlags, lppRows); <br> <br> <br>    if (lRowCount &lt; 0) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        DebugTraceResult(IVTABC_QueryRows, hResult); <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check the flags <br>     */ <br>    if (ulFlags &amp; ~TBL_NOADVANCE) <br>    { <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br> <br>        DebugTraceResult(IVTABC_QueryRows, hResult); <br>        return hResult; <br>    } <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    /* <br>     *  Open the file <br>     */ <br>    hResult = HrOpenFile(lpIVTAbc); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto out; <br>    } <br> <br>    ulOrigPosition = lpIVTAbc-&gt;ulPosition; <br> <br>    /* <br>     *  Calculate # of rows that will be read. <br>     */ <br>    cRows = (int)lpIVTAbc-&gt;ulMaxPos - (int)lpIVTAbc-&gt;ulPosition; <br>    cRows = (cRows &lt; (int)lRowCount ? cRows : (int)lRowCount); <br> <br>    /* <br>     *  Allocate array for SRowSet <br>     */ <br> <br>    scode = lpIVTAbc-&gt;lpAllocBuff(sizeof(ULONG) + cRows * sizeof(SRow), <br>                                        (LPVOID *) &amp;lpRowSet); <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br> <br>        goto out; <br>    } <br> <br>    /* <br>     *  Initialize - so we can clean up later if we have to... <br>     */ <br>    lpRowSet-&gt;cRows = cRows; <br> <br>    for (iRow = 0; iRow &lt; cRows; iRow++) <br>        lpRowSet-&gt;aRow[iRow].lpProps = NULL; <br> <br> <br> <br>    /* <br>     *  Seek to correct position in file <br>     */ <br>    (void) SetFilePointer(lpIVTAbc-&gt;hFile, lpIVTAbc-&gt;ulPosition * sizeof(ABCREC), <br>                        NULL, FILE_BEGIN); <br> <br>    /* <br>     *  Read each row from the file <br>     */ <br>    for (iRow = 0; iRow &lt; cRows; iRow++) <br>    { <br> <br>        /*  The only properties available are: <br>         * <br>         *  PR_DISPLAY_NAME, PR_ENTRYID, PR_ADDRTYPE, PR_EMAIL_ADDRESS, <br>         *  PR_OBJECT_TYPE, PR_DISPLAY_TYPE <br>         */ <br> <br>        /* <br>         *  Handle restricted lists <br>         */ <br>        if (lpIVTAbc-&gt;lpszPartialName) <br>        { <br>            ULONG ulPos = lpIVTAbc-&gt;ulPosition; <br> <br>next: <br>            if (ulPos == lpIVTAbc-&gt;ulMaxPos) <br>            { <br>                break; <br>            } <br> <br>            if (!FChecked(lpIVTAbc, ulPos)) <br>            { <br>                hResult = HrValidateEntry(lpIVTAbc, ulPos); <br>                if (HR_FAILED(hResult)) <br>                { <br>                    goto err; <br>                } <br>            } <br> <br>            if (!FMatched(lpIVTAbc, ulPos)) <br>            { <br>                ulPos++; <br>                goto next; <br>            } <br> <br>            lpIVTAbc-&gt;ulPosition = ulPos; <br>            (void) SetFilePointer(lpIVTAbc-&gt;hFile, lpIVTAbc-&gt;ulPosition * sizeof(ABCREC), <br>                                    NULL, FILE_BEGIN); <br> <br>        } <br> <br>        lpIVTAbc-&gt;ulPosition++; <br> <br>        /* <br>         *  Read in the record from the file <br>         */ <br>        if (!ReadFile(lpIVTAbc-&gt;hFile, (LPVOID) &amp;abcrec, <br>                sizeof(ABCREC), &amp;cbRead, NULL)) <br>        { <br>            hResult = ResultFromScode(MAPI_E_DISK_ERROR); <br>            SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_NO_READ); <br> <br>            goto err; <br>        } <br>        /*  Second check  */ <br>        if ((UINT) cbRead != sizeof(ABCREC)) <br>        { <br>            /* <br>             *  Should never get here. <br>             */ <br>            hResult = ResultFromScode(MAPI_E_DISK_ERROR); <br>            SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_NO_READ); <br> <br>            goto err; <br>        } <br> <br>        /*  Allocate memory to start a row. <br>         */ <br>        cbSizeOfRow = sizeof(ULONG) + <br>            (int)lpIVTAbc-&gt;lpPTAColSet-&gt;cValues * sizeof(SPropValue); <br> <br>        scode = lpIVTAbc-&gt;lpAllocBuff(cbSizeOfRow, (LPVOID *) &amp;lpRow); <br>        if (FAILED(scode)) <br>        { <br>            hResult = ResultFromScode(scode); <br> <br>            goto err; <br>        } <br> <br>        /* <br>         *  Get all the data <br>         */ <br>        for (cCols = 0; cCols &lt; (int)lpIVTAbc-&gt;lpPTAColSet-&gt;cValues; cCols++) <br>        { <br>            switch (lpIVTAbc-&gt;lpPTAColSet-&gt;aulPropTag[cCols]) <br>            { <br>            case PR_DISPLAY_NAME_A: <br>                { <br> <br>                    lpRow[cCols].ulPropTag = PR_DISPLAY_NAME_A; <br>                    scode = lpIVTAbc-&gt;lpAllocMore (lstrlenA(abcrec.rgchDisplayName) + 1, </code></pre>
<p>
</p>
<pre><code>lpRow, <br>                                                (LPVOID *) &amp;(lpRow[cCols].Value.lpszA)); <br> <br>                    if (FAILED(scode)) <br>                    { <br>                        lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR, <br>                            PROP_ID(PR_DISPLAY_NAME_A)); <br>                        lpRow[cCols].Value.err = scode; <br>                    } <br>                    else <br>                    { <br> <br>                        lstrcpyA(lpRow[cCols].Value.lpszA, <br>                            abcrec.rgchDisplayName); <br>                    } <br> <br>                } <br>                break; <br> <br>            case PR_EMAIL_ADDRESS_A: <br>                { <br> <br>                    lpRow[cCols].ulPropTag = PR_EMAIL_ADDRESS_A; <br>                    scode = lpIVTAbc-&gt;lpAllocMore ( <br>                                lstrlenA(abcrec.rgchEmailAddress) + 1, <br>                                lpRow, (LPVOID *) &amp;(lpRow[cCols].Value.lpszA)); <br> <br>                    if (FAILED(scode)) <br>                    { <br>                        lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR, <br>                            PROP_ID(PR_EMAIL_ADDRESS_A)); <br>                        lpRow[cCols].Value.err = scode; <br>                    } <br>                    else <br>                    { <br> <br>                        lstrcpyA(lpRow[cCols].Value.lpszA, <br>                            abcrec.rgchEmailAddress); <br>                    } <br> <br>                } <br>                break; <br> <br>            case PR_ADDRTYPE: <br>                { <br>                    /* <br>                     *  AddrType is always "MSPEER" for the SAB <br>                     */ <br> <br>                    lpRow[cCols].ulPropTag = PR_ADDRTYPE_A; <br>                    scode = lpIVTAbc-&gt;lpAllocMore (lstrlenA(lpszEMT) + 1, <br>                                lpRow, (LPVOID *) &amp;(lpRow[cCols].Value.lpszA)); <br> <br>                    if (FAILED(scode)) <br>                    { <br>                        lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR, <br>                            PROP_ID(PR_ADDRTYPE_A)); <br>                        lpRow[cCols].Value.err = scode; <br>                    } <br>                    else <br>                    { <br> <br>                        lstrcpyA(lpRow[cCols].Value.lpszA, lpszEMT); <br>                    } <br> <br>                } <br>                break; <br> <br>            case PR_ENTRYID: <br>                { <br>                    /* <br>                     *  Fixed sized entryid.  Basically just the .SAB file record <br>                     */ <br>                    LPUSR_ENTRYID lpUsrEid; <br> <br>                    lpRow[cCols].ulPropTag = PR_ENTRYID; <br>                    scode = lpIVTAbc-&gt;lpAllocMore (sizeof(USR_ENTRYID), lpRow, <br>                                (LPVOID *) &amp;(lpRow[cCols].Value.bin.lpb)); <br> <br>                    if (FAILED(scode)) <br>                    { <br>                        lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR, <br>                            PROP_ID(PR_ENTRYID)); <br>                        lpRow[cCols].Value.err = scode; <br>                    } <br>                    else <br>                    { <br>                        lpUsrEid = (LPUSR_ENTRYID) lpRow[cCols].Value.bin.lpb; <br> <br>                        ZeroMemory(lpUsrEid, sizeof(USR_ENTRYID)); <br> <br>                        /*  Size of entryid */ <br>                        lpRow[cCols].Value.bin.cb = sizeof(USR_ENTRYID); <br> <br>                        lpUsrEid-&gt;abFlags[0] = 0;   /*  long-term, recipient */ <br>                        lpUsrEid-&gt;abFlags[1] = 0; <br>                        lpUsrEid-&gt;abFlags[2] = 0; <br>                        lpUsrEid-&gt;abFlags[3] = 0; <br>                        lpUsrEid-&gt;muid = muidABSample; <br>                        lpUsrEid-&gt;ulVersion = SAMP_VERSION; <br>                        lpUsrEid-&gt;ulType = SAMP_USER; <br>                        lpUsrEid-&gt;abcrec = abcrec; <br>                    } <br> <br>                } <br>                break; <br> <br>            case PR_OBJECT_TYPE: <br>                { <br>                    /* <br>                     *  MailUser <br>                     */ <br> <br>                    lpRow[cCols].ulPropTag = PR_OBJECT_TYPE; <br>                    lpRow[cCols].Value.ul = MAPI_MAILUSER; <br>                } <br>                break; <br> <br>            case PR_DISPLAY_TYPE: <br>                { <br>                    /* <br>                     *  MailUser <br>                     */ <br> <br>                    lpRow[cCols].ulPropTag = PR_DISPLAY_TYPE; <br>                    lpRow[cCols].Value.ul = DT_MAILUSER; <br> <br>                } <br>                break; <br> <br>            case PR_INSTANCE_KEY: <br>                { <br>                    LPABCRecInstance lpABCRecInstance; <br>                    UINT cbRecInstance; <br>                    /* <br>                     *  Instance keys are made up of: <br>                     *      ulRecordPosition - current position in the file <br>                     *      filetime         - current date and time stamp of file <br>                     *      lpszFileName     - current file that we're browsing <br>                     */ <br>                    lpRow[cCols].ulPropTag = PR_INSTANCE_KEY; <br>                     <br>                    cbRecInstance = sizeof(ABCRecInstance)+lstrlen(lpIVTAbc-&gt;lpszFileName)+1; <br>                    scode = lpIVTAbc-&gt;lpAllocMore(cbRecInstance, <br>                                                lpRow, <br>                                                (LPVOID) &amp;(lpRow[cCols].Value.bin.lpb)); <br> <br>                    if (FAILED(scode)) <br>                    { <br>                        lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR, <br>                            PROP_ID(PR_INSTANCE_KEY)); <br>                        lpRow[cCols].Value.err = scode; <br>                    } <br>                    else <br>                    { <br>                        lpABCRecInstance = (LPABCRecInstance) lpRow[cCols].Value.bin.lpb; <br> <br>                        ZeroMemory(lpABCRecInstance, cbRecInstance); <br> <br>                        lpRow[cCols].Value.bin.cb = (ULONG) cbRecInstance; <br> <br>                        lpABCRecInstance-&gt;ulRecordPosition = lpIVTAbc-&gt;ulPosition; <br>                        lpABCRecInstance-&gt;filetime = lpIVTAbc-&gt;filetime; <br>                        lstrcpy(lpABCRecInstance-&gt;rgchzFileName, lpIVTAbc-&gt;lpszFileName); <br> <br>                    } <br>                } <br>                break;                       <br>                         <br> <br>            default: <br>                { <br> <br>                    lpRow[cCols].ulPropTag = PROP_TAG(PT_ERROR, <br>                        PROP_ID(lpIVTAbc-&gt;lpPTAColSet-&gt;aulPropTag[cCols])); <br>                    lpRow[cCols].Value.err = MAPI_E_NOT_FOUND; <br>                } <br>                break; <br>            } <br>        } <br> <br>        /*  # of columns  */ <br>        lpRowSet-&gt;aRow[iRow].cValues = lpIVTAbc-&gt;lpPTAColSet-&gt;cValues; <br> <br>        /*  Actual row of data */ <br>        lpRowSet-&gt;aRow[iRow].lpProps = lpRow; <br> <br>        lpRow = NULL; <br> <br>    } <br> <br>    /* <br>     *  it's always iRow. <br>     */ <br>    lpRowSet-&gt;cRows = iRow; <br> <br>    /* <br>     *  Handle Seeked position stuff <br>     */ <br>    if (ulFlags &amp; TBL_NOADVANCE) <br>    { <br>        /* <br>         *  Set it back to it's original position <br>         */ <br>        lpIVTAbc-&gt;ulPosition = ulOrigPosition; <br>    } <br> <br> <br>    *lppRows = lpRowSet; <br> <br>out: <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_QueryRows, hResult); <br>    return hResult; <br> <br>err: <br>    /* <br>     *  Clean up memory... <br>     */ <br> <br>    /*  Free the row  */ <br>    lpIVTAbc-&gt;lpFreeBuff(lpRow); <br> <br>    /*  Clean up the rest of the rows  */ <br>    FreeProws(lpRowSet); <br> <br>    *lppRows = NULL; <br> <br>    goto out; <br> <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
