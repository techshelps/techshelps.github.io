<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ABP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2112"></a>ABP.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ABP.C <br> * <br> * <br> *  The Sample Address Book Provider. <br> *  This file contains the routines that handle the ABPJump table. <br> * <br> *  The following routines are implemented in this file: <br> * <br> *  ABProviderInit <br> *  ABP_QueryInterface <br> *  ABP_Release <br> *  ABP_Shutdown <br> *  ABP_Logon <br> * <br> *  ServiceEntry <br> *  HrOpenSingleProvider <br> *   <br> *  RemoveLogonObject <br> *  FindLogonObject <br> *  ScLoadString <br> *   <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br> <br>#include "abp.h" <br>#include &lt;smpab.h&gt; <br> <br> <br>/* <br> *  The Local Identifier <br> */ <br>LCID lcidUser; <br> <br>/* <br> *  This provider's MAPIUID.  It's used as part of the entryIDs generated from this provider. <br> */ <br>MAPIUID muidABSample = MUIDABSAMPLE; <br> <br>/* <br> *  This provider's value for PR_AB_PROVIDER_ID.  It's found in the hierarchy table exposed <br> *  by this provider <br> */ <br>MAPIUID muidSABProviderID = SAB_PROVIDER_ID; <br> <br>/* <br> *  This provider's Email Type <br> */ <br> <br>LPSTR lpszEMT = SZEMAILTYPE; <br> <br>/* <br> *  Used to keep track of all logon objects created on the ABPInit object <br> */ <br> <br>typedef struct _object <br>{ <br>    struct _object *lppNext; <br>    LPVOID lpObject; <br> <br>} OBJECTLIST, *LPOBJECTLIST; <br> <br> <br>/* <br> *  structures and filters defined for display tables <br> * <br> */ <br> <br>DTBLLABEL dtbllabel = {sizeof(DTBLLABEL), 0}; <br>DTBLPAGE dtblpage = {sizeof(DTBLPAGE), 0, 0, 0}; <br>DTBLGROUPBOX dtblgroupbox = {sizeof(DTBLGROUPBOX), 0}; <br>CHAR szNoFilter[] = "*"; <br>CHAR szAddrTypeFilter[] = "[~:]"; <br>CHAR szFileNameFilter[] = "[~   \\\\]"; /* ends up [~&lt;space&gt;&lt;tab&gt;\\] */ <br> <br>/* <br> *  Prototypes for the functions in this file, most of which I return <br> *  in the jump table returned from ABProviderInit(). <br> */ <br> <br>//ABPROVIDERINIT ABProviderInit; <br>MSGSERVICEENTRY ServiceEntry; <br>HRESULT HrOpenSingleProvider(LPPROVIDERADMIN lpAdminProviders, <br>                             LPPROFSECT FAR * lppProfSect); <br> <br>/* <br> *  Definition of the init object <br> */ <br>typedef struct _ABP { <br>    ABP_Vtbl FAR *      lpVtbl; <br>    SAB_IUnknown; <br> <br>    /* <br>     * list of logon objects  <br>     */ <br>    LPOBJECTLIST  lpObjectList;    <br> <br>} ABP, FAR *LPABP; <br> <br>/* <br> *  The ABInit object's vtbl is filled in here <br> */ <br>ABP_Vtbl vtblABP = <br>{ <br>    ABP_QueryInterface, <br>    (ABP_AddRef_METHOD *) ROOT_AddRef, <br>    ABP_Release, <br>    ABP_Shutdown, <br>    ABP_Logon <br>}; <br> <br>/* <br> -  ABProviderInit <br> - <br> *  Initializes this provider.  Returns an IABProvider object. <br> * <br> */ <br> <br>STDINITMETHODIMP <br>ABProviderInit( <br>    HINSTANCE hLibrary, <br>    LPMALLOC lpMalloc, <br>    LPALLOCATEBUFFER lpAllocBuff, <br>    LPALLOCATEMORE lpAllocMore, <br>    LPFREEBUFFER lpFreeBuff, <br>    ULONG ulFlags, <br>    ULONG ulMAPIVersion, <br>    ULONG FAR * lpulABVersion, <br>    LPABPROVIDER FAR * lppABProvider) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    LPABP lpABP; <br>    SCODE sc; <br> <br>    /* <br>     *  Check the version <br>     */ <br>    if (ulMAPIVersion &lt; CURRENT_SPI_VERSION) <br>    { <br>        /* <br>         *  MAPI's version is too old. <br>         */ <br> <br>        /* <br>         *  See if they understand my version <br>         */ <br>        *lpulABVersion = CURRENT_SPI_VERSION; <br>         <br>        DebugTraceSc(ABProviderInit, MAPI_E_VERSION); <br>        return ResultFromScode(MAPI_E_VERSION); <br>    } <br> <br>    /* <br>     *  Allocate memory for this Init Object <br>     */ <br>    sc = lpAllocBuff (sizeof(ABP), &amp;lpABP); <br>    if (FAILED(sc)) <br>    { <br>        /* <br>         *  Out of memory <br>         */ <br>        DebugTraceSc(ABProviderInit, sc); <br>        return ResultFromScode(sc); <br>    } <br> <br>    /* <br>     *  Initialize the idle engine that MAPI supplies.  This is most useful <br>     *  when browsing the .SAB file.  See ABCTBLn.C. <br>     */ <br>    if (MAPIInitIdle(NULL) == -1) <br>    { <br>        hResult = ResultFromScode(E_FAIL); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Hold on to the lpMalloc <br>     */ <br>    Assert(lpMalloc); <br>    lpMalloc-&gt;lpVtbl-&gt;AddRef(lpMalloc); <br> <br>    lpABP-&gt;lpVtbl = &amp;vtblABP; <br>    lpABP-&gt;lcInit = 1; <br>    lpABP-&gt;hLibrary = hLibrary; <br> <br>    lpABP-&gt;lpMalloc = lpMalloc; <br>    lpABP-&gt;lpAllocBuff = lpAllocBuff; <br>    lpABP-&gt;lpAllocMore = lpAllocMore; <br>    lpABP-&gt;lpFreeBuff = lpFreeBuff; <br>    lpABP-&gt;lpObjectList = NULL; <br> <br>    InitializeCriticalSection(&amp;lpABP-&gt;cs); <br> <br>    *lppABProvider = (LPABPROVIDER) lpABP; <br>    *lpulABVersion = CURRENT_SPI_VERSION; <br> <br>    /* <br>     *  Get our Locale Identifier <br>     */ <br>    lcidUser = GetUserDefaultLCID(); <br> <br> <br>out: <br>    DebugTraceResult(ABProviderInit, hResult); <br>    return hResult; <br> <br>err: <br>    lpFreeBuff(lpABP); <br> <br>    goto out; <br>} <br> <br> <br>/* <br> -  ABP_QueryInterface <br> - <br> *  Supports QI'ing to IUnknown and IABProvider <br> *   <br> *  Note that for all the methods of IABProvider that parameter validation <br> *  is unnecessary.  This is because MAPI is handling all the parameters <br> *  being passed in. <br> *  At best you can assert your parameters. <br> */ <br>STDMETHODIMP <br>ABP_QueryInterface(LPABP lpABP, REFIID lpiid, LPVOID * ppvObj) <br>{ <br> <br>    /*  See if the requested interface is one of ours */ <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IABProvider, sizeof(IID))) <br>    { <br>        *ppvObj = NULL;         /* OLE requires zeroing [out] parameter on error */ <br>        DebugTraceSc(ABP_QueryInterface, E_NOINTERFACE); <br>        return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    EnterCriticalSection(&amp;lpABP-&gt;cs); <br>    ++lpABP-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABP-&gt;cs); <br>     <br>    *ppvObj = lpABP; <br> <br>    return hrSuccess; <br>} <br> <br>/* <br> -  ABP_Release <br> - <br> *  Releases and cleans up this object <br> */ <br>STDMETHODIMP_(ULONG) <br>ABP_Release(LPABP lpABP) <br>{ <br>    long lcInit; <br> <br>    EnterCriticalSection(&amp;lpABP-&gt;cs); <br>    lcInit = --lpABP-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABP-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br>        DeleteCriticalSection(&amp;lpABP-&gt;cs); <br> <br>        lpABP-&gt;lpVtbl = NULL; <br>        lpABP-&gt;lpFreeBuff(lpABP); <br>        return (0); <br>    } <br>    return lcInit; <br>} <br> <br>/* <br> -  ABP_Shutdown <br> - <br> *  Informs this provider that MAPI is done with it. <br> * <br> * <br> */ <br>STDMETHODIMP <br>ABP_Shutdown(LPABP lpABP, ULONG FAR * lpulFlags) <br>{ <br>    MAPIDeinitIdle(); <br> <br>    if (lpABP-&gt;lpMalloc) <br>    { <br>        lpABP-&gt;lpMalloc-&gt;lpVtbl-&gt;Release(lpABP-&gt;lpMalloc); <br>        lpABP-&gt;lpMalloc = NULL; <br>    } <br> <br>    return hrSuccess; <br>} <br> <br>/* <br> -  ABP_Logon <br> - <br> *  Create a logon object and return it to MAPI. <br> * <br> */ <br> <br>/* <br> *  The PropTagArray used to retrieve logon properties <br> */ <br>enum {  ivallogonPR_SAB_FILE, <br>        ivallogonPR_SAB_UID, <br>        cvallogonMax }; <br> <br>static const SizedSPropTagArray(cvallogonMax, tagaSABLogonProps) = <br>{ <br>    cvallogonMax, <br>    { <br>        PR_SAB_FILE, <br>        PR_SAB_UID <br>    } <br>}; <br> <br>STDMETHODIMP <br>ABP_Logon(  LPABP             lpABP, <br>            LPMAPISUP         lpMAPISup, <br>            ULONG             ulUIParam, <br>            LPTSTR            lpszProfileName, <br>            ULONG             ulFlags, <br>            ULONG FAR *       lpulpcbSecurity, <br>            LPBYTE FAR *      lppbSecurity, <br>            LPMAPIERROR FAR * lppMapiError, <br>            LPABLOGON FAR *   lppABPLogon) <br>{ <br>    LPABLOGON       lpABLogon       = NULL; <br>    HRESULT         hResult         = hrSuccess; <br>    SCODE           scode; <br>    LPPROFSECT      lpProfSect      = NULL; <br>    LPSPropValue    lpsPropVal      = NULL; <br>    ULONG           cValues         = 0; <br>    LPSTR           lpstrT          = NULL; <br>    BOOL            fUINeeded; <br>    BOOL            fNeedMAPIUID    = FALSE; <br>    MAPIUID         muidID; <br>    LPOBJECTLIST    lpObjectList; <br>    CHAR            szFileName[MAX_PATH]; <br> <br>    szFileName[0] = '\0'; <br>     <br>    *lppMapiError = NULL; <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceArg( ABP_Logon, "Bad Character width" ); <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>     <br>    /* <br>     *  Get the name of my browse file from the profile section <br>     */ <br> <br>    /*  Open the section for my provider */ <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;OpenProfileSection(lpMAPISup, <br>                NULL, <br>                MAPI_MODIFY, <br>                &amp;lpProfSect); <br> <br>    if (HR_FAILED(hResult)) <br>        goto out; <br> <br>    /*  Get the property containing the browse file name and the sab uid. */ <br>    hResult = lpProfSect-&gt;lpVtbl-&gt;GetProps( <br>        lpProfSect, <br>        (LPSPropTagArray) &amp;tagaSABLogonProps, <br>        0,      /* ansi */ <br>        &amp;cValues, <br>        &amp;lpsPropVal); <br> <br>    if (HR_FAILED(hResult)) <br>        goto out; <br> <br>#ifdef DEBUG <br>    if (hResult != hrSuccess) <br>    { <br>        if (PROP_TYPE(lpsPropVal[ivallogonPR_SAB_FILE].ulPropTag) == PT_ERROR <br>            &amp;&amp; lpsPropVal[0].Value.err != MAPI_E_NOT_FOUND) <br>        { <br>            TraceSz1("ABP_Logon (PR_SAB_FILE) got unexpected scode: %s\n", <br>                SzDecodeScode(lpsPropVal[ivallogonPR_SAB_FILE].Value.err)); <br>        } <br>        if (PROP_TYPE(lpsPropVal[ivallogonPR_SAB_UID].ulPropTag) == PT_ERROR <br>            &amp;&amp; lpsPropVal[ivallogonPR_SAB_UID].Value.err != MAPI_E_NOT_FOUND) <br>        { <br>            TraceSz1("ABP_Logon (PR_SAB_UID) got unexpected scode: %s\n", <br>                SzDecodeScode(lpsPropVal[1].Value.err)); <br>        } <br>    } <br>#endif <br> <br>    /*  Ignore warnings from reading the property. */ <br>    hResult = hrSuccess; <br> <br>    /* copy the sab file name */ <br>    if (lpsPropVal[0].ulPropTag == PR_SAB_FILE) <br>    { <br>        UINT cch = lstrlenA(lpsPropVal[0].Value.lpszA); <br> <br>        if (cch &gt;= MAX_PATH) <br>            cch = MAX_PATH - 1; <br> <br>        if (cch) <br>            memcpy(szFileName, lpsPropVal[0].Value.lpszA, cch); <br> <br>        szFileName[cch] = '\0'; <br>    } <br>    else <br>    { <br>        DebugTrace("ABP_Logon PR_SAB_FILE not found"); <br>    } <br> <br>    /* copy the sab uid */ <br>    if (lpsPropVal[1].ulPropTag == PR_SAB_UID) <br>    { <br>        memcpy(&amp;muidID, lpsPropVal[1].Value.bin.lpb, sizeof(MAPIUID)); <br>    } <br>    else <br>    { <br>        DebugTrace("ABP_Logon PR_SAB_UID not found"); <br>        fNeedMAPIUID = TRUE; <br>    } <br> <br>    /*  Discard GetProps() return data, if any. */ <br>    lpABP-&gt;lpFreeBuff(lpsPropVal); <br> <br>    /* <br>     *  UI needed unless the file name is good and file exists. <br>     */ <br> <br>    fUINeeded = TRUE; <br> <br>    if (szFileName[0] != 0) <br>    { <br>        /* Verify the file exists. */ <br> <br>        HANDLE hFile = CreateFile( <br>            szFileName, <br>            GENERIC_READ, <br>            FILE_SHARE_READ, <br>            NULL, <br>            OPEN_EXISTING, <br>            FILE_ATTRIBUTE_NORMAL, <br>            NULL); <br> <br>        if (hFile != INVALID_HANDLE_VALUE) <br>        { <br>            CloseHandle(hFile); <br> <br>            fUINeeded = FALSE; <br>        } <br>    } <br> <br>    /* <br>    *  if the sab file name was not found in the profile or the sab file <br>    *  does not exist we have to get the user to pick another one and <br>    *  save back into the profile <br>    */ <br> <br>    if (fUINeeded) <br>    { <br>        OPENFILENAME openfilename; <br>        SPropValue sProp[1]; <br> <br>        /* <br>         *  Can't bring up UI unless the client allows it <br>         */ <br>        if (ulFlags &amp; AB_NO_DIALOG) <br>        { <br>            hResult = ResultFromScode(MAPI_E_LOGON_FAILED); <br>            goto out; <br>        } <br> <br>        /* <br>         *  Get the user to select a file <br>         */ <br>        openfilename.lStructSize = sizeof(OPENFILENAME); <br>        openfilename.hwndOwner = (HWND) ulUIParam; <br>        openfilename.hInstance = 0; /* Ignored */ <br>        openfilename.lpstrFilter = TEXT("Sample AB files\0*.sab\0\0"); <br>        openfilename.lpstrCustomFilter = NULL; <br>        openfilename.nMaxCustFilter = 0; <br>        openfilename.nFilterIndex = 0; <br>        openfilename.lpstrFile = szFileName; <br>        openfilename.nMaxFile = MAX_PATH; <br>        openfilename.lpstrFileTitle = NULL; <br>        openfilename.nMaxFileTitle = 0; <br>        openfilename.lpstrInitialDir = NULL; <br>        openfilename.lpstrTitle = TEXT("Sample Address Book"); <br>        openfilename.Flags = OFN_FILEMUSTEXIST | <br>            OFN_HIDEREADONLY | <br>            OFN_NOCHANGEDIR; <br>        openfilename.nFileOffset = 0; <br>        openfilename.nFileExtension = 0; <br>        openfilename.lpstrDefExt = TEXT("sab"); <br>        openfilename.lCustData = 0; <br>        openfilename.lpfnHook = NULL; <br>        openfilename.lpTemplateName = NULL; <br> <br>        /* <br>         *  Call up the common dialog <br>         */ <br>        if (!GetOpenFileName(&amp;openfilename)) <br>        { <br>#ifdef DEBUG <br>            DWORD dwT; <br> <br>            dwT = CommDlgExtendedError(); <br>#endif /* DEBUG */ <br>             <br>            hResult = ResultFromScode(MAPI_E_LOGON_FAILED); <br>            goto out; <br>        } <br> <br>        /* <br>         *  Set the sab file name property value <br>         */ <br>        sProp[0].ulPropTag = PR_SAB_FILE; <br>        sProp[0].Value.lpszA = szFileName; <br> <br>        /* <br>         *  Save the sab file into the profile <br>         */ <br>        if (hResult = lpProfSect-&gt;lpVtbl-&gt;SetProps(lpProfSect, 1, sProp, NULL)) <br>        { <br>            /* <br>             *  Do nothing...  So I couldn't save it away this time... <br>             */ <br>            DebugTraceResult("ABP_Logon got unexpected result on SetProps\n", hResult); <br>            hResult = hrSuccess; <br>        } <br>    } <br> <br>    /* <br>    *  if the uid was not found we have to generate a new muid for the <br>    *  PR_SAB_ID property and save it back into the profile <br>    */ <br> <br>    if (fNeedMAPIUID) <br>    { <br>        SPropValue sProp[1]; <br> <br>        /* <br>         *  Get a new sab uid <br>         */ <br>        hResult = lpMAPISup-&gt;lpVtbl-&gt;NewUID(lpMAPISup, &amp;muidID); <br>        if (HR_FAILED(hResult)) <br>        { <br>            goto out; <br>        } <br> <br>        /* <br>         *  Set the sab uid property value <br>         */ <br>        sProp[0].ulPropTag = PR_SAB_UID; <br>        sProp[0].Value.bin.cb = sizeof(MAPIUID); <br>        sProp[0].Value.bin.lpb = (LPBYTE) &amp;muidID; <br> <br>        /* <br>         *  Save the sab uid into the profile <br>         */ <br>        if (hResult = lpProfSect-&gt;lpVtbl-&gt;SetProps(lpProfSect, 1, sProp, NULL)) <br>        { <br>            /* <br>             *  Do nothing...  So I couldn't save it away this time... <br>             */ <br>            DebugTraceResult("ABP_Logon got unexpected result on SetProps\n", hResult); <br>            hResult = hrSuccess; <br>        } <br>    } <br> <br>    /* <br>     *  Allocate space for keeping the file name in the ABLogon object <br>     */ <br> <br>    if (scode = lpABP-&gt;lpAllocBuff(lstrlenA(szFileName)+1, &amp;lpstrT)) <br>    { <br>        hResult = ResultFromScode(scode); <br>        goto out; <br>    } <br>    lstrcpyA(lpstrT, szFileName); <br> <br> <br>    hResult = HrNewABLogon(&amp;lpABLogon, <br>                            (LPABPROVIDER) lpABP, <br>                            lpMAPISup, <br>                            lpstrT, <br>                            &amp;muidID, <br>                            lpABP-&gt;hLibrary, <br>                            lpABP-&gt;lpAllocBuff, <br>                            lpABP-&gt;lpAllocMore, <br>                            lpABP-&gt;lpFreeBuff, <br>                            lpABP-&gt;lpMalloc ); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto out; <br>    } <br> <br> <br>    /* <br>     *  Allocate space for another object list item <br>     */ <br>    scode = lpABP-&gt;lpAllocBuff(sizeof(OBJECTLIST), &amp;lpObjectList); <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br>        goto out; <br>    } <br> <br>    /* Get the Critical Section */ <br>    EnterCriticalSection(&amp;lpABP-&gt;cs); <br> <br>    /* add logon object to begining of providers object list */ <br>    lpObjectList-&gt;lpObject = (LPVOID) lpABLogon; <br>    lpObjectList-&gt;lppNext = lpABP-&gt;lpObjectList; <br> <br>    /* insert new logon object into the head of the providers object list */ <br>    lpABP-&gt;lpObjectList = lpObjectList; <br> <br>    /* leave critical section */ <br>    LeaveCriticalSection(&amp;lpABP-&gt;cs); <br> <br>    /* <br>     *  Register my MAPIUID for this provider, <br>     *  but do not allow an error from setting the <br>     *  MAPIUID to cause failure to Logon. <br>     */ <br> <br>    (void)lpMAPISup-&gt;lpVtbl-&gt;SetProviderUID(lpMAPISup, <br>        (LPMAPIUID) &amp;muidABSample, 0); <br> <br>    *lppABPLogon = lpABLogon; <br> <br>out: <br>    if (lpProfSect) <br>        lpProfSect-&gt;lpVtbl-&gt;Release(lpProfSect); <br> <br>    if (hResult) <br>    { <br>        lpABP-&gt;lpFreeBuff(lpstrT); <br> <br>        Assert(lpABLogon == NULL); <br> <br>        /* Verify we don't return warnings at this time. */ <br>        Assert(HR_FAILED(hResult)); <br>    } <br> <br>    DebugTraceResult(ABP_Logon, hResult); <br>    return hResult; <br>} <br> <br>/* <br> *  Removes a particular logon object from the list of logon objects <br> *  that's kept track of in the IABProvider object <br> */ <br>void <br>RemoveLogonObject(LPABPROVIDER lpABProvider, LPVOID lpvABLogon, LPFREEBUFFER lpFreeBuff) <br>{ <br> <br>    LPOBJECTLIST *lppObjectList; <br>    LPOBJECTLIST lpObjectListT; <br>    LPABP lpABP = (LPABP) lpABProvider; <br> <br>#if defined DEBUG <br>    BOOL fFound = FALSE; <br> <br>#endif <br> <br>    /* Get the Critical Section */ <br>    EnterCriticalSection(&amp;lpABP-&gt;cs); <br> <br>    /* <br>     *  remove this logon object from the provider init objects list <br>     *  of logon objects <br>     */ <br>    lppObjectList = &amp;(lpABP-&gt;lpObjectList); <br> <br>    while (*lppObjectList) <br>    { <br>        /* is this the logon object? */ <br>        if ((*lppObjectList)-&gt;lpObject == lpvABLogon) <br>        { <br>            /* save next list item */ <br>            lpObjectListT = (*lppObjectList)-&gt;lppNext; <br> <br>            /* free the object list item */ <br>            lpFreeBuff(*lppObjectList); <br> <br>            /* delete object from the list */ <br>            *lppObjectList = lpObjectListT; <br> <br>#if defined DEBUG <br>            fFound = TRUE; <br>#endif <br>            break; <br>        } <br> <br>        lppObjectList = &amp;(*lppObjectList)-&gt;lppNext; <br>    } <br> <br>    /* leave critical section */ <br>    LeaveCriticalSection(&amp;lpABP-&gt;cs); <br> <br>#if defined DEBUG <br>    AssertSz(fFound, TEXT("Logon object not found on providers object list")); <br>#endif <br> <br>    return; <br>}    <br> <br> <br>/* <br> *  Finds a particular logon object by its muid. <br> */ <br>void <br>FindLogonObject(LPABPROVIDER lpABProvider, LPMAPIUID lpMuidToFind, LPABLOGON * lppABLogon) <br>{ <br>    LPABP lpABP = (LPABP) lpABProvider; <br>    LPABLOGON lpABLogonT = NULL; <br>    LPOBJECTLIST lpObjectList = NULL; <br>    LPMAPIUID lpMuidLogon = NULL; <br> <br>    Assert(!IsBadReadPtr(lpABP, sizeof(ABP))); <br>    Assert(!IsBadReadPtr(lpMuidToFind, sizeof(MAPIUID))); <br>    Assert(!IsBadReadPtr(lppABLogon, sizeof(LPABLOGON))); <br> <br>    /* Get the Critical Section */ <br>    EnterCriticalSection(&amp;lpABP-&gt;cs); <br> <br>    *lppABLogon = NULL; <br> <br>    for (lpObjectList = lpABP-&gt;lpObjectList; <br>        lpObjectList; lpObjectList = lpObjectList-&gt;lppNext) <br>    { <br>        lpABLogonT = (LPABLOGON) lpObjectList-&gt;lpObject; <br>         <br>        lpMuidLogon = LpMuidFromLogon(lpABLogonT); <br> <br>        if (memcmp((LPVOID) lpMuidLogon, (LPVOID) lpMuidToFind, sizeof(MAPIUID)) == 0) <br>        { <br>            *lppABLogon = lpABLogonT; <br>            break; <br>        } <br>    } <br> <br>    /* leave critical section */ <br>    LeaveCriticalSection(&amp;lpABP-&gt;cs); <br>} <br> <br> <br>/* <br> -  ServiceEntry <br> - <br> *  This funtion is used by MAPI to configure the Sample Address Book.   <br> *  It's a lot like ABP_Logon, except that it doesn't return a logon object <br> *  and it can be passed in its configuration information (as defined in <br> *  smpab.h) from MAPI so that no UI is required. <br> * <br> */ <br>STDAPI <br>ServiceEntry(HINSTANCE hInstance, <br>             LPMALLOC lpMalloc, <br>             LPMAPISUP lpMAPISup, <br>             ULONG ulUIParam, <br>             ULONG ulFlags, <br>             ULONG ulContext, <br>             ULONG cValues, <br>             LPSPropValue lpProps, <br>             LPPROVIDERADMIN lpAdminProviders, <br>             LPMAPIERROR FAR *lppMapiError) <br>{ <br>    OPENFILENAME openfilename; <br>    char szFileName[MAX_PATH]; <br>    HRESULT hResult = hrSuccess; <br>    LPSPropValue lpsPropVal = NULL; <br>    ULONG ulCount = 0; <br>    LPALLOCATEBUFFER lpAllocBuff; <br>    LPALLOCATEMORE lpAllocMore; <br>    LPFREEBUFFER lpFreeBuff; <br>    LPPROFSECT lpProf = NULL; <br>    BOOL fUINeeded = FALSE; <br>    BOOL fNeedMAPIUID = FALSE; <br>    SPropValue sProp[2]; <br>    ULONG uliProp; <br>    MAPIUID muid; <br> <br>    /*  Validate parameters */ <br> <br>    /* check the support object */ <br>    if (IsBadReadPtr(lpMAPISup, sizeof(LPMAPISUP))) <br>    { <br>        DebugTraceSc(ServiceEntry, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceArg( ServiceEntry, "Bad character width" ); <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>     <br>    /* <br>     *  check for context <br>     */ <br>    if (ulContext == MSG_SERVICE_DELETE || ulContext == MSG_SERVICE_INSTALL <br>        || ulContext == MSG_SERVICE_UNINSTALL) <br>        return hrSuccess; <br>    if (ulContext != MSG_SERVICE_CONFIGURE &amp;&amp; ulContext != MSG_SERVICE_CREATE) <br>    { <br>        DebugTrace(TEXT("ServiceEntry unsupported context")); <br>        return ResultFromScode(MAPI_E_NO_SUPPORT); <br>    } <br> <br>    /*  Get the memory allocation routines we'll be needing. */ <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;GetMemAllocRoutines(lpMAPISup, <br>        &amp;lpAllocBuff, &amp;lpAllocMore, &amp;lpFreeBuff); <br>    if (hResult) <br>    { <br>        DebugTraceResult(MAPISUP: :GetMemAllocRoutines, hResult); <br>        goto out; <br>    } <br> <br>    /* Open the profile section associated with our provider */ <br>    hResult = HrOpenSingleProvider(lpAdminProviders, &amp;lpProf); <br>    if (hResult) <br>    { <br>        DebugTrace(TEXT("Unable to open the profile.")); <br>        goto out; <br>    } <br> <br>    szFileName[0] = '\0'; <br> <br>    /* get sab filename and uid from profile */ <br>    hResult = lpProf-&gt;lpVtbl-&gt;GetProps( <br>        lpProf, <br>        (LPSPropTagArray) &amp;tagaSABLogonProps, <br>        ulFlags &amp; MAPI_UNICODE, <br>        &amp;ulCount, <br>        &amp;lpsPropVal); <br> <br>    /*  Ignore errors/warnings from reading the property. */ <br>    hResult = hrSuccess; <br> <br>    /* Look for the .SAB in the config props first */ <br>    for (uliProp = 0; uliProp &lt; cValues; uliProp++) <br>    { <br>        if (PROP_ID(lpProps[uliProp].ulPropTag) == PROP_ID(PR_SAB_FILE)) <br>            break; <br>    } <br> <br>    if (uliProp &lt; cValues &amp;&amp; <br>        PROP_TYPE(lpProps[uliProp].ulPropTag) != PT_ERROR) <br>    { <br>        ULONG cch = lstrlenA(lpProps[uliProp].Value.lpszA); <br> <br>        if (cch &gt;= MAX_PATH) <br>            cch = MAX_PATH - 1; <br>        if (cch) <br>            memcpy(szFileName, lpProps[uliProp].Value.lpszA, (size_t) cch); <br>        szFileName[cch] = '\0'; <br> <br>    } <br>    else if (lpsPropVal &amp;&amp; PROP_ID(lpsPropVal[0].ulPropTag) == <br>        PROP_ID(PR_SAB_FILE) &amp;&amp; <br>        PROP_TYPE(lpsPropVal[0].ulPropTag) != PT_ERROR) <br>    { <br>        ULONG cch = lstrlenA(lpsPropVal[0].Value.lpszA); <br> <br>        if (cch &gt;= MAX_PATH) <br>            cch = MAX_PATH - 1; <br>        if (cch) <br>            memcpy(szFileName, lpsPropVal[0].Value.lpszA, (size_t) cch); <br>        szFileName[cch] = '\0'; <br>    } <br>    else <br>    { <br>        /* need to ask the user for the sab file */ <br>        fUINeeded = TRUE; <br>    } <br> <br>    /* Look for the SAB_UID in the config props first */ <br>    for (uliProp = 0; uliProp &lt; cValues; uliProp++) <br>    { <br>        if (PROP_ID(lpProps[uliProp].ulPropTag) == PROP_ID(PR_SAB_UID)) <br>            break; <br> <br>    } <br> <br>    if (uliProp &lt; cValues &amp;&amp; <br>        PROP_TYPE(lpProps[uliProp].ulPropTag) != PT_ERROR) <br>    { <br>        memcpy(&amp;muid, lpProps[uliProp].Value.bin.lpb, sizeof(MAPIUID)); <br>    } <br>    else if (lpsPropVal &amp;&amp; PROP_ID(lpsPropVal[1].ulPropTag) == <br>        PROP_ID(PR_SAB_UID) &amp;&amp; PROP_TYPE(lpsPropVal[1].ulPropTag) != PT_ERROR) <br>    { <br>        memcpy(&amp;muid, lpsPropVal[1].Value.bin.lpb, sizeof(MAPIUID)); <br>    } <br>    else <br>    { <br>        /* need to generate a uid */ <br>        fNeedMAPIUID = TRUE; <br>    } <br> <br>    /*  Discard GetProps() return data, if any. <br>     */ <br>    if (lpsPropVal) <br>        lpFreeBuff(lpsPropVal); <br> <br>    /* <br>     *  if the sab file name was not found in the profile we have to <br>     *  get the user to pick one and save it back into the profile <br>     */ <br>    if (   fUINeeded <br>        &amp;&amp; !(ulFlags &amp; (SERVICE_UI_ALLOWED | SERVICE_UI_ALWAYS | UI_SERVICE))) <br>    { <br>        /*  We need UI to configure but it's not allowed so we can't configure. <br>         */ <br>        hResult = ResultFromScode(MAPI_E_UNCONFIGURED); <br> <br>        DebugTrace("SMPAB::ServiceEntry - Missing properties required to configure service.\n"); <br> <br>        goto out; <br>    } <br> <br>    if ((fUINeeded) || (ulFlags &amp; UI_SERVICE)) <br>    { <br>        /* <br>        *  Get the user to pick a SAB file <br>        */ <br>        openfilename.lStructSize = sizeof(OPENFILENAME); <br>        openfilename.hwndOwner = (HWND) ulUIParam; <br>        openfilename.hInstance = 0; /* Ignored */ <br>        openfilename.lpstrFilter = "Sample AB files\0*.sab\0\0"; <br>        openfilename.lpstrCustomFilter = NULL; <br>        openfilename.nMaxCustFilter = 0; <br>        openfilename.nFilterIndex = 0; <br>        openfilename.lpstrFile = szFileName; <br>        openfilename.nMaxFile = MAX_PATH; <br>        openfilename.lpstrFileTitle = NULL; <br>        openfilename.nMaxFileTitle = 0; <br>        openfilename.lpstrInitialDir = NULL; <br>        openfilename.lpstrTitle = "Pick a Sample Address Book file"; <br>        openfilename.Flags = OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR | OFN_HIDEREADONLY; <br>        openfilename.nFileOffset = 0; <br>        openfilename.nFileExtension = 0; <br>        openfilename.lpstrDefExt = "sab"; <br>        openfilename.lCustData = 0; <br>        openfilename.lpfnHook = NULL; <br>        openfilename.lpTemplateName = NULL; <br> <br>        /* <br>        *  Call up the common dialog <br>        */ <br>        if (!GetOpenFileName(&amp;openfilename)) <br>        { <br>            /* user pressed cancel */ <br>            goto out; <br>        } <br>    } <br> <br>    /* <br>    *  if the uid was not found we have to generate a new muid for the <br>    *  PR_SAB_ID property and save it back into the profile <br>    */ <br> <br>    if (fNeedMAPIUID) <br>    { <br>        hResult = lpMAPISup-&gt;lpVtbl-&gt;NewUID(lpMAPISup, &amp;muid); <br>        if (HR_FAILED(hResult)) <br>        { <br>            /* <br>            *  Can't get a uid so just leave <br>            */ <br>            goto out; <br>        } <br>    } <br> <br>    /* <br>    *  Set the file name property <br>    */ <br> <br>    sProp[ivallogonPR_SAB_FILE].ulPropTag = PR_SAB_FILE; <br>    sProp[ivallogonPR_SAB_FILE].Value.lpszA = szFileName; <br> <br>    /* <br>    *  Set the id property <br>    */ <br> <br>    sProp[ivallogonPR_SAB_UID].ulPropTag = PR_SAB_UID; <br>    sProp[ivallogonPR_SAB_UID].Value.bin.cb = sizeof(MAPIUID); <br>    sProp[ivallogonPR_SAB_UID].Value.bin.lpb = (LPBYTE) &amp;muid; <br> <br>    /* <br>    *  Save the sab file and the uid back into the profile <br>    */ <br>    hResult = lpProf-&gt;lpVtbl-&gt;SetProps( <br>        lpProf, <br>        sizeof(sProp) / sizeof(SPropValue), <br>        sProp, <br>        NULL); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        /* <br>        *  Do nothing...  So I couldn't save it away this time... <br>        */ <br>        DebugTrace(TEXT("ServiceEntry could not SetProp in profile")); <br>        hResult = hrSuccess; <br>    } <br> <br>out: <br>    if (lpProf) <br>        lpProf-&gt;lpVtbl-&gt;Release(lpProf); <br> <br>    DebugTraceResult(ServiceEntry, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  HrOpenSingleProvider <br> - <br> *  Opens the profile section associated with this provider. <br> * <br> *  If the ServiceEntry() function exported from a provider had <br> *  more than 1 section associated with it, this is where you'd get the chance <br> *  to get all of them. <br> */ <br> <br>static SizedSPropTagArray(1, tagaProviderTable) = <br>{ <br>    1, <br>    { <br>        PR_PROVIDER_UID <br>    } <br>}; <br> <br>HRESULT <br>HrOpenSingleProvider(LPPROVIDERADMIN lpAdminProviders, <br>                     LPPROFSECT FAR * lppProfSect) <br>{ <br>    HRESULT hResult; <br>    LPMAPITABLE lpTable = NULL; <br>    LPSRowSet lpRows = NULL; <br>    LPSPropValue lpProp; <br> <br>    hResult = lpAdminProviders-&gt;lpVtbl-&gt;GetProviderTable( <br>        lpAdminProviders, <br>        0, <br>        &amp;lpTable); <br>    if (HR_FAILED(hResult)) <br>        goto out; <br> <br>    hResult = lpTable-&gt;lpVtbl-&gt;SetColumns(lpTable, (LPSPropTagArray) &amp;tagaProviderTable, 0); <br>    if (HR_FAILED(hResult)) <br>        goto out; <br> <br>    hResult = lpTable-&gt;lpVtbl-&gt;QueryRows(lpTable, 1, 0, &amp;lpRows); <br>    if (HR_FAILED(hResult)) <br>        goto out; <br> <br>    if (lpRows-&gt;cRows == 0) <br>    { <br>        hResult = ResultFromScode(MAPI_E_NOT_FOUND); <br>        goto out; <br>    } <br> <br>    lpProp = lpRows-&gt;aRow[0].lpProps; <br> <br>    hResult = lpAdminProviders-&gt;lpVtbl-&gt;OpenProfileSection( <br>                lpAdminProviders, <br>                (LPMAPIUID) lpProp-&gt;Value.bin.lpb, <br>                NULL, <br>                MAPI_MODIFY, <br>                lppProfSect); <br> <br>out: <br>    FreeProws(lpRows); <br> <br>    if (lpTable) <br>        lpTable-&gt;lpVtbl-&gt;Release(lpTable); <br> <br>    DebugTraceResult(HrOpenSingleProvider, hResult); <br>    return hResult; <br>} <br> <br> <br> <br>/* <br> -  ScLoadString <br> - <br> *  Loads a string from a resource.  It will optionally allocate the string if </code></pre>
<p>
</p>
<pre><code>*  a allocation function is passed in.  Otherwise it assumes that the *lppsz <br> *  is already allocated. <br> */ <br> <br>SCODE ScLoadString( UINT                ids, <br>                    ULONG               ulcch, <br>                    LPALLOCATEBUFFER    lpAllocBuff, <br>                    HINSTANCE           hLibrary, <br>                    LPSTR *             lppsz) <br>{ <br>    SCODE sc = S_OK; <br>    int iRet; <br> <br>    /* <br>     *  Assert parameters <br>     */ <br>    Assert((lpAllocBuff ? !IsBadCodePtr((FARPROC) lpAllocBuff):TRUE)); <br>    Assert(ids!=0); <br> <br>    if (lpAllocBuff) <br>    { <br>        sc = lpAllocBuff(ulcch, lppsz); <br>        if (FAILED(sc)) <br>        { <br>            goto out; <br>        } <br>    } <br>#ifdef DEBUG <br>    else <br>    { <br>        Assert(!IsBadWritePtr(*lppsz, (UINT) ulcch)); <br>    } <br>#endif /* DEBUG */ <br>     <br>    iRet = LoadStringA( hLibrary, <br>                        ids, <br>                        *lppsz, <br>                        (UINT) ulcch); <br> <br>    if (!iRet) <br>    { <br>        DebugTrace("LoadString() failed...\n"); <br>        sc = E_FAIL; <br>        goto out; <br>    } <br>out: <br> <br>    DebugTraceSc(ScLoadString, sc); <br>    return sc; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
