<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ROOT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2119"></a>ROOT.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ROOT.C <br> * <br> * <br> *  Sample AB Root object <br> *      - This file contains the code for implementing the Sample AB <br> *      root object and the hierarchy table. <br> * <br> *  The Root container object is returned via an ABPOpenEntry() with a <br> *  0-sized entryid.  It only has a limited set of properties available on <br> *  it.  The most useful method on it is GetHierarchyTable() which returns <br> *  the root hierarchy associated with this provider. <br> * <br> *  The hierarchy table has only a single row in it.  The row represents the <br> *  single .SAB file which this provider browses.  If a provider wanted to <br> *  browse many different lists, it would have multiple rows. <br> * <br> *  The following routines are implemented in this file: <br> * <br> * <br> *    To implement the Root container object: <br> * <br> *      HrNewROOT <br> *      SetErrorSz <br> *      ROOT_QueryInterface <br> *      ROOT_AddRef <br> *      ROOT_Release <br> *      ROOT_GetLastError <br> *      ROOT_SaveChanges <br> *      ROOT_OpenProperty <br> *      ROOT_GetContentsTable <br> *      ROOT_GetHierarchyTable <br> *      ROOT_OpenEntry <br> *      ROOT_CreateEntry <br> *      ROOT_CopyEntries <br> *      ROOT_DeleteEntries <br> *      ROOT_ResolveNames <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br>#include "abp.h" <br>#include "sampabp.rh" <br> <br> <br>/* <br> *  The structure behind the 'this' pointer <br> */ <br>typedef struct _ROOT <br>{ <br>    const ROOT_Vtbl FAR *   lpVtbl; <br> <br>    SAB_Wrapped; <br>     <br>} ROOT, *LPROOT; <br> <br> <br>/* <br> *  Root vtbl is filled in here <br> */ <br>static const ROOT_Vtbl vtblROOT = <br>{ <br>    ROOT_QueryInterface, <br>    ROOT_AddRef, <br>    ROOT_Release, <br>    ROOT_GetLastError, <br>    ROOT_SaveChanges, <br>    (ROOT_GetProps_METHOD *) WRAP_GetProps, <br>    (ROOT_GetPropList_METHOD *) WRAP_GetPropList, <br>    ROOT_OpenProperty, <br>    (ROOT_SetProps_METHOD *) WRAP_SetProps, <br>    (ROOT_DeleteProps_METHOD *) WRAP_DeleteProps, <br>    (ROOT_CopyTo_METHOD *) WRAP_CopyTo, <br>    (ROOT_CopyProps_METHOD *) WRAP_CopyProps, <br>    (ROOT_GetNamesFromIDs_METHOD *) WRAP_GetNamesFromIDs, <br>    (ROOT_GetIDsFromNames_METHOD *) WRAP_GetIDsFromNames, <br>    ROOT_GetContentsTable, <br>    ROOT_GetHierarchyTable, <br>    ROOT_OpenEntry, <br>    ROOT_SetSearchCriteria, <br>    ROOT_GetSearchCriteria, <br>    ROOT_CreateEntry, <br>    ROOT_CopyEntries, <br>    ROOT_DeleteEntries, <br>    ROOT_ResolveNames <br>}; <br> <br> <br>/* <br> *  Default properties in this object <br> */ <br>enum {  ivalPR_DISPLAY_TYPE = 0, <br>        ivalPR_OBJECT_TYPE, <br>        ivalPR_ENTRYID, <br>        ivalPR_RECORD_KEY, <br>        ivalPR_SEARCH_KEY, <br>        ivalPR_DISPLAY_NAME_A, <br>        ivalPR_CONTAINER_FLAGS, <br>        cvalMax }; <br> <br>/* <br> -  HrNewROOT <br> - <br> *  Creates a new Root Container object.  This object is created <br> *  when an lpABLogon::OpenEntry() is called with a 0-sized entryid. <br> * <br> * <br> */ <br>HRESULT <br>HrNewROOT(LPABCONT *        lppROOT, <br>          ULONG *           lpulObjType, <br>          LPABLOGON         lpABPLogon, <br>          LPCIID            lpInterface, <br>          HINSTANCE         hLibrary, <br>          LPALLOCATEBUFFER  lpAllocBuff, <br>          LPALLOCATEMORE    lpAllocMore, <br>          LPFREEBUFFER      lpFreeBuff, <br>          LPMALLOC          lpMalloc ) <br>{ <br>    LPROOT lpROOT = NULL; <br>    SCODE scode; <br>    LPPROPDATA lpPropData = NULL; <br>    SPropValue spv[cvalMax]; <br>    HRESULT hResult; <br>    char szDisplayName[MAX_ROOT_NAME]; <br>    LPSTR pszDisplayName = (LPSTR) szDisplayName; <br>    SCODE sc; <br>    DIR_ENTRYID eidRoot =   {   {0, 0, 0, 0}, <br>                                MUIDABSAMPLE, <br>                                SAMP_VERSION, <br>                                SAMP_DIRECTORY }; <br> <br>    /*  Do I support this interface?? */ <br>    if (lpInterface) <br>    { <br>        if (memcmp(lpInterface, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IMAPIProp, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IMAPIContainer, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IABContainer, sizeof(IID))) <br>        { <br>            DebugTraceSc(HrNewROOT, MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>        } <br>    } <br>    /* <br>     *  Allocate space for the ROOT structure <br>     */ <br>    scode = lpAllocBuff (sizeof(ROOT), (LPVOID *) &amp;lpROOT); <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br>        goto err; <br>    } <br> <br>    lpROOT-&gt;lpVtbl = &amp;vtblROOT; <br>    lpROOT-&gt;lcInit = 1; <br>    lpROOT-&gt;hResult = hrSuccess; <br>    lpROOT-&gt;idsLastError = 0; <br> <br>    lpROOT-&gt;hLibrary = hLibrary; <br>    lpROOT-&gt;lpAllocBuff = lpAllocBuff; <br>    lpROOT-&gt;lpAllocMore = lpAllocMore; <br>    lpROOT-&gt;lpFreeBuff = lpFreeBuff; <br>    lpROOT-&gt;lpMalloc = lpMalloc; <br> <br>    lpROOT-&gt;lpABLogon = lpABPLogon; <br> <br>    /* <br>     *  Create a property storage object <br>     */ <br> <br>    scode = CreateIProp((LPIID) &amp;IID_IMAPIPropData, <br>        lpAllocBuff, <br>        lpAllocMore, <br>        lpFreeBuff, <br>        lpMalloc, <br>        &amp;lpPropData); <br> <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Set up initial set of properties associated with this <br>     *  container. <br>     */ <br> <br>    spv[ivalPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE; <br>    spv[ivalPR_DISPLAY_TYPE].Value.l = 0;           /* undefined for now */ <br> <br>    spv[ivalPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE; <br>    spv[ivalPR_OBJECT_TYPE].Value.l = MAPI_ABCONT; <br> <br>    spv[ivalPR_ENTRYID].ulPropTag = PR_ENTRYID; <br>    spv[ivalPR_ENTRYID].Value.bin.cb = sizeof(DIR_ENTRYID); <br>    spv[ivalPR_ENTRYID].Value.bin.lpb = (LPBYTE) &amp;eidRoot; <br> <br>    spv[ivalPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY; <br>    spv[ivalPR_RECORD_KEY].Value.bin.cb = sizeof(DIR_ENTRYID); <br>    spv[ivalPR_RECORD_KEY].Value.bin.lpb = (LPBYTE) &amp;eidRoot; <br> <br>    spv[ivalPR_SEARCH_KEY].ulPropTag = PR_SEARCH_KEY; <br>    spv[ivalPR_SEARCH_KEY].Value.bin.cb = sizeof(DIR_ENTRYID); <br>    spv[ivalPR_SEARCH_KEY].Value.bin.lpb = (LPBYTE) &amp;eidRoot; <br> <br>    sc = ScLoadString(  IDS_ROOT_NAME, <br>                        MAX_ROOT_NAME, <br>                        NULL, <br>                        hLibrary, <br>                        (LPSTR *) &amp;pszDisplayName); <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    spv[ivalPR_DISPLAY_NAME_A].ulPropTag = PR_DISPLAY_NAME_A; <br>    spv[ivalPR_DISPLAY_NAME_A].Value.lpszA = szDisplayName; <br> <br>    spv[ivalPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS; <br>    spv[ivalPR_CONTAINER_FLAGS].Value.l = AB_SUBCONTAINERS; <br> <br>    /* <br>     *   Set the default properties <br>     */ <br>    hResult = lpPropData-&gt;lpVtbl-&gt;SetProps(lpPropData, <br>        cvalMax, <br>        spv, <br>        NULL); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto err; <br>    } <br> <br>    /* <br>     *  The whole object is set READONLY thus eliminating the need to <br>     *  set access rights for the individual properties. <br>     */ <br>    (void) lpPropData-&gt;lpVtbl-&gt;HrSetObjAccess(lpPropData, IPROP_READONLY); <br> <br>    lpROOT-&gt;lpPropData = (LPMAPIPROP) lpPropData; <br> <br>    InitializeCriticalSection(&amp;lpROOT-&gt;cs); <br> <br> <br>    /*  We must AddRef the lpABPLogon object since we will be using it <br>     */ <br>    lpABPLogon-&gt;lpVtbl-&gt;AddRef(lpABPLogon); <br> <br>    *lpulObjType = MAPI_ABCONT; <br>    *lppROOT = (LPVOID) lpROOT; <br> <br>out: <br>    DebugTraceResult(HrNewROOT, hResult); <br>    return hResult; <br> <br>err: <br>    /* <br>     *  free the root object <br>     */ <br>    lpFreeBuff (lpROOT); <br> <br>    /* <br>     *  free the prop data <br>     */ <br>    if (lpPropData) <br>        lpPropData-&gt;lpVtbl-&gt;Release(lpPropData); <br> <br>    goto out; <br>     <br>} <br> <br>/************************************************************************* <br> * <br> * <br> -  SetErrorIDS <br> - <br> *  Handles remembering the last error string associated with an object. <br> *  This string is retrieved by the method GetLastError() <br> * <br> * <br> */ <br> <br>VOID <br>SetErrorIDS(LPVOID lpObject, HRESULT hResult, UINT ids) <br>{ <br>    ((LPROOT) lpObject)-&gt;hResult = hResult; <br>    ((LPROOT) lpObject)-&gt;idsLastError = ids; <br>} <br> <br>/* <br> -  ROOT_QueryInterface <br> - <br> *  Supports QI'ing to IUnknown, IMAPIProp, IMAPIContainer, and IABContainer. <br> * <br> */ <br>STDMETHODIMP <br>ROOT_QueryInterface(LPROOT lpROOT, <br>                    REFIID lpiid, <br>                    LPVOID FAR * lppNewObj) <br>{ <br> <br>    HRESULT hr = hrSuccess; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>                     offsetof(ROOT_Vtbl, QueryInterface)+sizeof(ROOT_QueryInterface_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_QueryInterface != lpROOT-&gt;lpVtbl-&gt;QueryInterface) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IUnknown_QueryInterface(lpROOT, lpiid, lppNewObj); <br> <br>    /*  See if the requested interface is one of ours */ <br> <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IMAPIProp, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IMAPIContainer, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IABContainer, sizeof(IID))) <br>    { <br>        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */ <br>        hr = ResultFromScode(E_NOINTERFACE); <br>        goto out; <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    EnterCriticalSection(&amp;lpROOT-&gt;cs); <br>    ++lpROOT-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpROOT-&gt;cs); <br>     <br>    *lppNewObj = lpROOT; <br> <br>out: <br> <br>    DebugTraceResult(ROOT_QueryInterface, hr); <br>    return hr; <br>} <br> <br>/************************************************** <br> * <br> -  ROOT_AddRef <br> - <br> *      Increment lcInit <br> * <br> */ <br> <br>STDMETHODIMP_(ULONG) ROOT_AddRef(LPROOT lpROOT) <br>{ <br>    LONG lcInit; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>                     offsetof(ROOT_Vtbl, AddRef)+sizeof(ROOT_AddRef_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_AddRef != lpROOT-&gt;lpVtbl-&gt;AddRef) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        return 1; <br>    } <br> <br>    Validate_IUnknown_AddRef(lpROOT); <br> <br> <br>    EnterCriticalSection(&amp;lpROOT-&gt;cs); <br>    lcInit = ++lpROOT-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpROOT-&gt;cs); <br> <br>    return lcInit; <br>} <br> <br>/************************************************** <br> * <br> -  ROOT_Release <br> - <br> *      Decrement lcInit. <br> *      When lcInit == 0, free up the lpROOT structure <br> * <br> */ <br> <br>STDMETHODIMP_(ULONG) ROOT_Release(LPROOT lpROOT) <br>{ <br> <br>    LONG lcInit; <br>     <br>    /* <br>     *  Check to see if it can be a ROOT object <br>     */ <br>    if (IsBadReadPtr(lpROOT, sizeof(ROOT))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see that it's ROOTs vtbl <br>     */ <br>    if (lpROOT-&gt;lpVtbl != &amp;vtblROOT) <br>    { <br>        /* <br>         *  Not my jump table <br>         */ <br>        return 1; <br>    } <br> <br>    Validate_IUnknown_Release(lpROOT); <br> <br> <br>    EnterCriticalSection(&amp;lpROOT-&gt;cs); <br>    lcInit = --lpROOT-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpROOT-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br> <br>        /* <br>         *  Delete our critical section <br>         */ <br> <br>        DeleteCriticalSection(&amp;lpROOT-&gt;cs); <br> <br>        /* <br>         *  Set the vtbl to NULL.  This way the client will find out <br>         *  real fast if it's calling a method on a released object.  That is, <br>         *  the client will crash.  Hopefully, this will happen during the <br>         *  development stage of the client. <br>         */ <br>        lpROOT-&gt;lpVtbl = NULL; <br> <br>        /* <br>         *  free the property storage object <br>         */ <br>        if (lpROOT-&gt;lpPropData) <br>            lpROOT-&gt;lpPropData-&gt;lpVtbl-&gt;Release(lpROOT-&gt;lpPropData); <br> <br>        /*   <br>         *  Release our reference to the ABLogon object. <br>         */ <br>        if (lpROOT-&gt;lpABLogon) <br>        { <br>            lpROOT-&gt;lpABLogon-&gt;lpVtbl-&gt;Release(lpROOT-&gt;lpABLogon); <br>            lpROOT-&gt;lpABLogon = NULL; <br>        } <br> <br>        /* <br>         *  Free the object <br>         */ <br> <br>        lpROOT-&gt;lpFreeBuff(lpROOT); <br>        return 0; <br>    } <br> <br>    return lcInit; <br>} <br> <br>/* <br> -  ROOT_GetLastError <br> - <br> *      Returns a string associated with the last hResult <br> *  returned by the ROOT object. <br> * <br> */ <br> <br>STDMETHODIMP <br>ROOT_GetLastError(  LPROOT lpROOT, <br>                    HRESULT hError, <br>                    ULONG ulFlags, <br>                    LPMAPIERROR FAR * lppMapiError ) <br>{ <br>    SCODE scode; <br>    HRESULT hResult = hrSuccess; <br>    LPSTR   lpszMessage = NULL; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>        offsetof(ROOT_Vtbl, GetLastError)+sizeof(ROOT_GetLastError_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_GetLastError != lpROOT-&gt;lpVtbl-&gt;GetLastError) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTraceResult(ROOT_GetLastError, hResult); <br>        return hResult; <br>    } <br> <br>    Validate_IMAPIProp_GetLastError(lpROOT, hError, ulFlags, lppMapiError); <br> <br> <br> <br>    /*                               <br>     *  NOTE:  We don't handle UNICODE yet.  Everything is <br>     *  assumed to be working in 8-bit char mode. <br>     */ <br>    if (ulFlags &amp; MAPI_UNICODE) <br>    { <br>        hResult = ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>        DebugTraceResult(ROOT_GetLastError, hResult); <br>        return hResult; <br>    } <br> <br> <br>    EnterCriticalSection(&amp;lpROOT-&gt;cs); <br>     <br>    if ((hError != hrSuccess) &amp;&amp; (hError == lpROOT-&gt;hResult)) <br>    { <br>        scode = lpROOT-&gt;lpAllocBuff( sizeof( MAPIERROR ), lppMapiError ); <br>        if ( FAILED( scode ) )       <br>        { <br>            hResult = ResultFromScode(scode); <br>            goto ret; <br>        } <br>         <br>        ZeroMemory( *lppMapiError, sizeof( MAPIERROR ) ); <br>         <br>        (*lppMapiError)-&gt;ulVersion = MAPI_ERROR_VERSION; <br> <br>        /* <br>         *  Get the MAPI Allocated string associated with the last error <br>         */ <br>        scode = ScLoadString(lpROOT-&gt;idsLastError, <br>                             MAX_ERROR_STRING_LENGTH, <br>                             lpROOT-&gt;lpAllocBuff, <br>                             lpROOT-&gt;hLibrary, <br>                             &amp;lpszMessage); <br>        if ( FAILED( scode) )                             <br>        { <br>            hResult = ResultFromScode(scode); <br>            goto ret; <br>        } <br>         <br>        scode = lpROOT-&gt;lpAllocMore( lstrlenA( lpszMessage ) + 1, *lppMapiError,  <br>            &amp;(*lppMapiError)-&gt;lpszError ); <br>        if ( FAILED( scode ) )       <br>        { <br>            hResult = ResultFromScode(scode); <br>            goto ret; <br>        } <br>         <br>        lstrcpyA( (*lppMapiError)-&gt;lpszError, lpszMessage ); <br>         <br>         <br>    } else <br>    { <br>        *lppMapiError = NULL; <br>    } <br> <br>ret: <br>    if ( hResult ) <br>    { <br>        lpROOT-&gt;lpFreeBuff( *lppMapiError ); <br>        *lppMapiError = NULL; <br>    } <br>     <br>    lpROOT-&gt;lpFreeBuff( lpszMessage ); <br>    LeaveCriticalSection(&amp;lpROOT-&gt;cs); <br> <br>    return hResult; <br>} <br> <br>/* <br> -  ROOT_SaveChanges <br> - <br> *  Can't save changes on this object. <br> * <br> * <br> */ <br>STDMETHODIMP <br>ROOT_SaveChanges(LPROOT lpROOT, ULONG ulFlags) <br>{ <br> <br>    HRESULT hResult; <br> <br>    ROOT_ValidateObject(ROOT_SaveChanges, lpROOT); <br> <br>    Validate_IMAPIProp_SaveChanges(lpROOT, ulFlags); <br> <br> <br>    hResult = ResultFromScode(E_ACCESSDENIED); <br> <br>    DebugTraceResult(ROOT_SaveChanges, hResult); <br>    return hResult; <br> <br>} <br> <br>/* <br> -  ROOT_OpenProperty <br> - <br> * <br> *  For this object I only need to support opening the hierarchy table. <br> * <br> */ <br>STDMETHODIMP <br>ROOT_OpenProperty(  LPROOT lpROOT, <br>                    ULONG ulPropTag, <br>                    LPCIID lpiid, <br>                    ULONG ulInterfaceOptions, <br>                    ULONG ulFlags, <br>                    LPUNKNOWN * lppUnk) <br>{ <br> <br>    HRESULT hResult; <br> <br>    ROOT_ValidateObject(ROOT_OpenProperty, lpROOT); <br>     <br>    Validate_IMAPIProp_OpenProperty(lpROOT, ulPropTag, lpiid, <br>                            ulInterfaceOptions, ulFlags, lppUnk); <br> <br>     <br>    if (ulFlags &amp; MAPI_CREATE) <br>    { <br>        hResult = ResultFromScode(E_ACCESSDENIED); <br>        goto out;        <br>    } <br>         <br>    if (ulInterfaceOptions &amp; ~MAPI_UNICODE) <br>    { <br>        /* <br>         *  Only UNICODE flag should be set for any of the objects that might <br>         *  be returned from this object. <br>         */ <br>         <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br>        goto out; <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        goto out; <br>    } <br> <br> <br>    switch (ulPropTag) <br>    { <br> <br>        case PR_CONTAINER_HIERARCHY: <br>        { <br>            /* <br>             *  Check to see if they're expecting a IMAPITable object <br>             */ <br>            if (memcmp(lpiid, &amp;IID_IMAPITable, sizeof(IID))) <br>            { <br>                hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>                goto out; <br>            } <br> <br>            hResult = ROOT_GetHierarchyTable(lpROOT, 0, (LPMAPITABLE *) lppUnk); <br> <br>            goto out; <br>        } <br> <br>        default: <br>            break; <br> <br>    } <br>     <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>out: <br> <br>    DebugTraceResult(ROOT_OpenProperty, hResult); <br>    return hResult; <br> <br>} <br> <br>/************************************************************************* <br> * <br> * <br> -  ROOT_GetContentsTable <br> - <br> *  There are no contents in the root <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>ROOT_GetContentsTable(  LPROOT lpROOT, <br>                        ULONG ulFlags, <br>                        LPMAPITABLE * lppTable) <br>{ <br> <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>        offsetof(ROOT_Vtbl, GetContentsTable)+sizeof(ROOT_GetContentsTable_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_GetContentsTable != lpROOT-&gt;lpVtbl-&gt;GetContentsTable) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTraceResult(ROOT_GetContentsTable, hResult); <br>        return hResult; <br>    } <br> <br>    Validate_IMAPIContainer_GetContentsTable(lpROOT, ulFlags, lppTable); <br> <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        goto out; <br>    } <br>     <br> <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>out: <br>    DebugTraceResult(ROOT_GetContentsTable, hResult); <br>    return hResult; <br> <br>} <br> <br>/* <br> -  ROOT_GetHierarchyTable <br> - <br> *  Returns the table with just one entry in it. <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>ROOT_GetHierarchyTable( LPROOT lpROOT, <br>                        ULONG ulFlags, <br>                        LPMAPITABLE * lppTable) <br>{ <br> <br>    HRESULT hResult = hrSuccess; <br> <br> <br>    ROOT_ValidateObject(ROOT_GetHierarchyTable, lpROOT); <br>    Validate_IMAPIContainer_GetHierarchyTable(lpROOT, ulFlags, lppTable); <br> <br>     <br>    /* <br>     *  Since we only have one item in our hierarchy table, CONVENIENT_DEPTH <br>     *  is equivalent to any other depth level (&gt;1).  So, just ignore the <br>     *  flag.  MAPI_DEFERRED_ERROR is fine.  We don't ever defer errors. <br>     */ <br> <br>    /* <br>     *  Create a View Table for the hierarchy. <br>     */ <br>    hResult = HrBuildRootHier(lpROOT-&gt;lpABLogon, lppTable); <br> <br>    DebugTraceResult(ROOT_GetHierarchyTable, hResult); <br>    return hResult; <br> <br>} <br> <br>/* <br> -  ROOT_OpenEntry <br> - <br> *  Check parameters and use our logon object's OpenEntry method. <br> */ <br>STDMETHODIMP <br>ROOT_OpenEntry(LPROOT lpROOT, <br>    ULONG cbEntryID, <br>    LPENTRYID lpEntryID, <br>    LPCIID lpInterface, <br>    ULONG ulFlags, <br>    ULONG * lpulObjType, <br>    LPUNKNOWN * lppUnk) <br>{ <br>    HRESULT hResult; <br> <br>     <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  No vtbl found <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>        offsetof(ROOT_Vtbl, OpenEntry)+sizeof(ROOT_OpenEntry_METHOD *))) <br>    { <br>        /* <br>         *  vtbl cannot hold this method <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that it's the correct method <br>     */ <br>    if (ROOT_OpenEntry != lpROOT-&gt;lpVtbl-&gt;OpenEntry) <br>    { <br>        /* <br>         *  Not my vtbl <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IABLogon_OpenEntry(lpROOT, cbEntryID, lpEntryID, lpInterface, <br>                                    ulFlags, lpulObjType, lppUnk); <br> <br> <br>    hResult = lpROOT-&gt;lpABLogon-&gt;lpVtbl-&gt;OpenEntry(lpROOT-&gt;lpABLogon, <br>        cbEntryID, <br>        lpEntryID, <br>        lpInterface, <br>        ulFlags, <br>        lpulObjType, <br>        lppUnk); <br>     <br>out: <br> <br>    DebugTraceResult(ROOT_OpenEntry, hResult); <br>    return hResult; <br> <br>} <br> <br>/* <br> -  ROOT_SetSearchCriteria <br> - <br> * <br> *  Not implemented for this object <br> */ <br>STDMETHODIMP <br>ROOT_SetSearchCriteria(LPROOT lpROOT, <br>    LPSRestriction lpRestriction, <br>    LPENTRYLIST lpContainerList, <br>    ULONG ulSearchFlags) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br> <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>        offsetof(ROOT_Vtbl, SetSearchCriteria)+sizeof(ROOT_SetSearchCriteria_METHOD *))) <br>    { <br>        /* <br>         *  vtbl not large enough to support this method <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br> <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that it's the correct method <br>     */ <br>    if (ROOT_SetSearchCriteria != lpROOT-&gt;lpVtbl-&gt;SetSearchCriteria) <br>    { <br>        /* <br>         *  Not my vtbl <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IMAPIContainer_SetSearchCriteria(lpROOT, lpRestriction, <br>                                        lpContainerList, ulSearchFlags); <br> <br>     <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>out: <br>    DebugTraceResult(ROOT_SetSearchCriteria, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  ROOT_GetSearchCriteria <br> - <br> * <br> *  Not implemented for this object <br> * <br> */ <br>STDMETHODIMP <br>ROOT_GetSearchCriteria(LPROOT lpROOT, <br>    ULONG ulFlags, <br>    LPSRestriction FAR * lppRestriction, <br>    LPENTRYLIST FAR * lppContainerList, <br>    ULONG FAR * lpulSearchState) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>        offsetof(ROOT_Vtbl, GetSearchCriteria)+sizeof(ROOT_GetSearchCriteria_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_GetSearchCriteria != lpROOT-&gt;lpVtbl-&gt;GetSearchCriteria) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTraceResult(ROOT_GetSearchCriteria, hResult); <br>        return hResult; <br>    } <br>     <br>    Validate_IMAPIContainer_GetSearchCriteria(lpROOT, ulFlags, lppRestriction, <br>                                            lppContainerList, lpulSearchState); <br>     <br>     <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    DebugTraceResult(ROOT_GetSearchCriteria, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  ROOT_CreateEntry <br> - <br> *  New entries cannot be created in the root <br> * <br> */ <br>STDMETHODIMP <br>ROOT_CreateEntry(LPROOT lpROOT, <br>    ULONG cbEntryID, <br>    LPENTRYID lpEntryID, <br>    ULONG ulCreateFlags, <br>    LPMAPIPROP FAR * lppMAPIPropEntry) <br>{ <br> <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  No vtbl found <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>                     offsetof(ROOT_Vtbl, CreateEntry)+sizeof(ROOT_CreateEntry_METHOD *))) <br>    { <br>        /* <br>         *  vtbl not large enough to hold this method <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_CreateEntry != lpROOT-&gt;lpVtbl-&gt;CreateEntry) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IABContainer_CreateEntry(lpROOT, cbEntryID, lpEntryID, <br>                                ulCreateFlags, lppMAPIPropEntry ); <br> <br> <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>out: <br>    DebugTraceResult(ROOT_CreateEntry, hResult); <br>    return hResult; <br> <br>} <br> <br>/* <br> -  ROOT_CopyEntries <br> - <br> *  Entries cannot be copied into the root <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>ROOT_CopyEntries(LPROOT lpROOT, <br>    LPENTRYLIST lpEntries, <br>    ULONG ulUIParam, <br>    LPMAPIPROGRESS lpProgress, <br>    ULONG ulFlags) <br>{ <br> <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) </code></pre>
<p>
</p>
<pre><code>{ <br>        /* <br>         *  No vtbl found <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>                     offsetof(ROOT_Vtbl, CopyEntries)+sizeof(ROOT_CopyEntries_METHOD *))) <br>    { <br>        /* <br>         *  vtbl not large enough to hold this method <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_CopyEntries != lpROOT-&gt;lpVtbl-&gt;CopyEntries) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IABContainer_CopyEntries(lpROOT, lpEntries, ulUIParam, <br>                                        lpProgress, ulFlags); <br>     <br>     <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>out: <br>    DebugTraceResult(ROOT_CopyEntries, hResult); <br>    return hResult; <br> <br>} <br> <br>/* <br> -  ROOT_DeleteEntries <br> - <br> *  Entries cannot be deleted from the root <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>ROOT_DeleteEntries(LPROOT lpROOT, <br>    LPENTRYLIST lpEntries, <br>    ULONG ulFlags) <br>{ <br> <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  No vtbl found <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>                     offsetof(ROOT_Vtbl, DeleteEntries)+sizeof(ROOT_DeleteEntries_METHOD *))) <br>    { <br>        /* <br>         *  vtbl not large enough to hold this method <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_DeleteEntries != lpROOT-&gt;lpVtbl-&gt;DeleteEntries) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IABContainer_DeleteEntries(lpROOT, lpEntries, ulFlags); <br> <br> <br> <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>out: <br>    DebugTraceResult(ROOT_DeleteEntries, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  ROOT_ResolveNames <br> - <br> *  No special case handling of resolving names within this container <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>ROOT_ResolveNames(  LPROOT          lpROOT, <br>                    LPSPropTagArray lptagaColSet, <br>                    ULONG           ulFlags, <br>                    LPADRLIST       lpAdrList, <br>                    LPFlagList      lpFlagList ) <br>{ <br> <br>    HRESULT hResult; <br> <br>         <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpROOT, offsetof(ROOT, lpVtbl)+sizeof(ROOT_Vtbl *))) <br>    { <br>        /* <br>         *  No vtbl found <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpROOT-&gt;lpVtbl, <br>                     offsetof(ROOT_Vtbl, ResolveNames)+sizeof(ROOT_ResolveNames_METHOD *))) <br>    { <br>        /* <br>         *  vtbl not large enough to hold this method <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ROOT_ResolveNames != lpROOT-&gt;lpVtbl-&gt;ResolveNames) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    CheckParameters_IABContainer_ResolveNames(lpROOT, lptagaColSet, ulFlags, <br>                                            lpAdrList, lpFlagList); <br> <br>     <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>out: <br>    DebugTraceResult(ROOT_ResolveNames, hResult); <br>    return hResult; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
