<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ABCTBL3.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2109"></a>ABCTBL3.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ABCTBL3.C <br> * <br> *  Contents Table - Part 3. <br> * <br> * <br> *  The following routines are implemented in this file. <br> * <br> * <br> *      IVTABC_QueryInterface <br> *      IVTABC_Release <br> *      IVTABC_SortTable <br> *      IVTABC_QuerySortOrder <br> *      IVTABC_CreateBookmark <br> *      IVTABC_FreeBookmark <br> *      IVTABC_ExpandRow <br> *      IVTABC_ColapseRow <br> *      IVTABC_WaitForCompletion <br> *      IVTABC_Abort <br> *      IVTABC_Advise <br> *      IVTABC_Unadvise <br> *      IVTABC_GetStatus <br> *      IVTABC_SetColumns <br> *      IVTABC_QueryColumns <br> *      IVTABC_GetCollapseState, <br> *      IVTABC_SetCollapseState, <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br> <br> <br> <br> <br>#include "abp.h" <br>#include "abctbl.h" <br>#include "sampabp.rh" <br> <br> <br>/* <br> *  Default sort order set <br> */ <br>static const SizedSSortOrderSet(1, sosIVTABC) = <br>{ <br>    1, <br>    0, <br>    0, <br>    { <br>        { <br>            PR_DISPLAY_NAME_A, TABLE_SORT_ASCEND <br>        } <br>    } <br>}; <br> <br> <br> <br> <br>/************************************************************************* <br> * <br> * <br> -  AVTABC_QueryInterface <br> - <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_QueryInterface(LPIVTABC lpIVTAbc, <br>    REFIID lpiid, <br>    LPVOID FAR * lppNewObj) <br>{ <br> <br>    HRESULT hResult = hrSuccess; <br> <br>    IVTABC_ValidateObject(QueryInterface, lpIVTAbc); <br> <br>    Validate_IUnknown_QueryInterface(lpIVTAbc, lpiid, lppNewObj); <br> <br>     <br>    /*  See if the requested interface is one of ours */ <br> <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IMAPITable, sizeof(IID))) <br>    { <br>        *lppNewObj = NULL;      /* OLE requires zeroing the [out] parameter */ <br>        DebugTraceSc(IVTABC_QueryInterface, E_NOINTERFACE); <br>        return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br>    ++lpIVTAbc-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br>     <br>    *lppNewObj = lpIVTAbc; <br> <br>    DebugTraceResult(IVTABC_QueryInterface,hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_Release <br> - <br> * <br> *      Decrement the reference count on this object and free it if <br> *      the reference count is zero. <br> *      Returns the reference count. <br> */ <br> <br>STDMETHODIMP_(ULONG) <br>IVTABC_Release(LPIVTABC lpIVTAbc) <br>{ <br>    ULONG ulBK; <br>    long lcInit; <br>     <br>    /* <br>     *  Check to see if it's big enough to hold this object <br>     */ <br>    if (IsBadReadPtr(lpIVTAbc, sizeof(IVTABC))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see that it's the correct vtbl <br>     */ <br>    if (lpIVTAbc-&gt;lpVtbl != &amp;vtblIVTABC) <br>    { <br>        /* <br>         *  Not my vtbl <br>         */ <br>        return 1; <br>    } <br> <br>    Validate_IUnknown_Release(lpIVTAbc); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br>    lcInit = --lpIVTAbc-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br>        /* <br>         *  Free up the current column set <br>         */ <br>        if (lpIVTAbc-&gt;lpPTAColSet != ptagaivtabcColSet) <br>        { <br>            lpIVTAbc-&gt;lpFreeBuff (lpIVTAbc-&gt;lpPTAColSet); <br>        } <br> <br>        /* <br>         *  Close up the file <br>         */ <br>        if (lpIVTAbc-&gt;hFile != INVALID_HANDLE_VALUE) <br>        { <br>            CloseHandle(lpIVTAbc-&gt;hFile); <br>            lpIVTAbc-&gt;hFile = INVALID_HANDLE_VALUE; <br>        } <br> <br>        /* <br>         *  Free up the file name <br>         */ <br>        lpIVTAbc-&gt;lpFreeBuff(lpIVTAbc-&gt;lpszFileName); <br> <br>        /* <br>         *  Rip through the bookmarks and free up any that are there <br>         */ <br>        for (ulBK = 0; ulBK &lt; MAX_BOOKMARKS; ulBK++) <br>            if (lpIVTAbc-&gt;rglpABCBK[ulBK]) <br>            { <br>                (*(lpIVTAbc-&gt;lpFreeBuff)) (lpIVTAbc-&gt;rglpABCBK[ulBK]); <br>                lpIVTAbc-&gt;rglpABCBK[ulBK] = NULL; <br>            } <br> <br>        /* <br>         *  Free up the ANR stuff, if used <br>         */ <br>        lpIVTAbc-&gt;lpFreeBuff (lpIVTAbc-&gt;lpszPartialName); <br> <br>        FreeANRBitmaps(lpIVTAbc); <br> <br>        /* <br>         *  Free up the advise list, if used <br>         */ <br>        if (lpIVTAbc-&gt;parglpAdvise) <br>            lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Free(lpIVTAbc-&gt;lpMalloc, lpIVTAbc-&gt;parglpAdvise); <br> <br>        /*   <br>         *  Release our reference to the ABLogon object. <br>         */ <br>        if (lpIVTAbc-&gt;lpABLogon) <br>        { <br>            lpIVTAbc-&gt;lpABLogon-&gt;lpVtbl-&gt;Release(lpIVTAbc-&gt;lpABLogon); <br>            lpIVTAbc-&gt;lpABLogon = NULL; <br>        } <br> <br>        /* Delete critical section for this object */ <br>        DeleteCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>        /* Deregister the idle routine */ <br> <br>        DeregisterIdleRoutine(lpIVTAbc-&gt;ftg); <br> <br>        /* <br>         *  Set the vtbl to NULL.  This way the client will find out <br>         *  real fast if it's calling a method on a released object.  That is, <br>         *  the client will crash.  Hopefully, this will happen during the <br>         *  development stage of the client. <br>         */ <br>        lpIVTAbc-&gt;lpVtbl = NULL; <br> <br>        /* <br>         *  Need to free the object <br>         */ <br> <br>        lpIVTAbc-&gt;lpFreeBuff(lpIVTAbc); <br>        return 0; <br>    } <br> <br>    return lcInit; <br>} <br> <br> <br> <br>/* <br> -  IVTABC_SortTable <br> - <br> *  The Sample Address Book does not resort it's views. <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_SortTable(LPIVTABC lpIVTAbc, <br>    LPSSortOrderSet lpSortCriteria, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br>    IVTABC_ValidateObject(SortTable, lpIVTAbc); <br>     <br>    Validate_IMAPITable_SortTable(lpIVTAbc, lpSortCriteria, ulFlags); <br> <br> <br>    /* <br>     *  We don't support sorting this table <br>     */ <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    DebugTraceResult(IVTABC_SortTable, hResult); <br>    return hResult; <br> <br>} <br> <br>/* <br> -  IVTABC_QuerySortOrder <br> - <br> * <br> *  For this implementation there is only one sort order <br> */ <br> <br>STDMETHODIMP  <br>IVTABC_QuerySortOrder(LPIVTABC lpIVTAbc, <br>    LPSSortOrderSet * lppSortCriteria) <br>{ <br>    SCODE scode; <br>    HRESULT hResult = hrSuccess; <br>    int cbSize; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(QuerySortOrder, lpIVTAbc); <br> <br>    Validate_IMAPITable_QuerySortOrder(lpIVTAbc, lppSortCriteria); <br> <br> <br>    /*  Calculate size of the structure we're gonna copy */ <br>    cbSize = CbNewSSortOrderSet((int)sosIVTABC.cSorts); <br> <br>    scode = lpIVTAbc-&gt;lpAllocBuff(cbSize, (LPVOID *) lppSortCriteria); <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br> <br>        goto out; <br>    } <br> <br>    /* <br>     *  Copy the column set in <br>     */ <br>    if (cbSize) <br>        memcpy(*lppSortCriteria, &amp;sosIVTABC, cbSize); <br> <br>out: <br> <br>    DebugTraceResult(IVTABC_QuerySortOrder, hResult); <br>    return hResult; <br> <br>} <br> <br> <br> <br> <br>/* <br> -  IVTABC_CreateBookmark <br> - <br> *  Creates a bookmark associated with a row in a table <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_CreateBookmark(LPIVTABC lpIVTAbc, <br>    BOOKMARK * lpbkPosition) <br>{ <br>    SCODE scode; <br>    HRESULT hResult = hrSuccess; <br>    ULONG ulBK; <br>    LPABCBK lpABCBK = NULL; <br>    ULONG cbRead = 0; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(CreateBookmark, lpIVTAbc); <br> <br>    Validate_IMAPITable_CreateBookmark(lpIVTAbc, lpbkPosition); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br> <br>    /* <br>     *  Open the file <br>     */ <br>    hResult = HrOpenFile(lpIVTAbc); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto out; <br>    } <br> <br>    /* <br>     *  Shortcuts first <br>     */ <br>    if (lpIVTAbc-&gt;ulPosition == lpIVTAbc-&gt;ulMaxPos) <br>    { <br>        *lpbkPosition = BOOKMARK_END; <br>        return hrSuccess; <br>    } <br> <br>    /* <br>     *  search for a blank bookmark <br>     */ <br>    for (ulBK = 0; lpIVTAbc-&gt;rglpABCBK[ulBK] &amp;&amp; ulBK &lt; MAX_BOOKMARKS; ulBK++); <br> <br>    /*  did we find any??  */ <br>    if (ulBK == MAX_BOOKMARKS) <br>    { <br>        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br> <br>        goto out; <br>    } <br> <br> <br>    scode = lpIVTAbc-&gt;lpAllocBuff (sizeof(ABCBK),(LPVOID *) &amp;lpABCBK); <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Fill in new bookmark <br>     */ <br>    lpABCBK-&gt;filetime = lpIVTAbc-&gt;filetime; <br>    lpABCBK-&gt;ulPosition = lpIVTAbc-&gt;ulPosition; <br> <br>    /*  Seek to position in file  */ <br>    (void) SetFilePointer(lpIVTAbc-&gt;hFile, lpABCBK-&gt;ulPosition, NULL, FILE_BEGIN); <br> <br>    /*  Read in the record at that location  */ <br>    if (!ReadFile(lpIVTAbc-&gt;hFile, <br>            (LPVOID) &amp;(lpABCBK-&gt;abcrec), sizeof(ABCREC), &amp;cbRead, NULL)) <br>    { <br>        goto readerror; <br>    } <br>    /*  Second check  */ <br>    if (cbRead != sizeof(ABCREC)) <br>    { <br>        goto readerror; <br>    } <br> <br>    /* <br>     *  Put this in the bookmark structure <br>     */ <br>    lpIVTAbc-&gt;rglpABCBK[ulBK] = lpABCBK; <br> <br>    /*  Return the bookmark  */ <br>    *lpbkPosition = ulBK + 3; <br> <br>out: <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_CreateBookmark, hResult); <br>    return hResult; <br> <br>readerror: <br>    /* <br>     *  Didn't get the record. <br>     */ <br> <br>    /*  Restore back to original position  */ <br>    (void) SetFilePointer(lpIVTAbc-&gt;hFile, lpIVTAbc-&gt;ulPosition, NULL, FILE_BEGIN); <br> <br>    /*  Free up the new bookmark  */ <br>    lpIVTAbc-&gt;lpFreeBuff(lpABCBK); <br> <br>    hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>    SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_NO_READ); <br> <br>    goto out; <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_FreeBookmark <br> - <br> *  Frees up the given bookmark <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_FreeBookmark(LPIVTABC lpIVTAbc, <br>    BOOKMARK bkPosition) <br>{ <br>    HRESULT hResult = hrSuccess; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(FreeBookmark, lpIVTAbc); <br> <br>    Validate_IMAPITable_FreeBookmark(lpIVTAbc, bkPosition); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br> <br>    /* <br>     *  Don't try and free up any of the standard bookmarks <br>     */ <br>    if ((bkPosition != BOOKMARK_BEGINNING) &amp;&amp; <br>        (bkPosition != BOOKMARK_CURRENT) &amp;&amp; <br>        (bkPosition != BOOKMARK_END)) <br>    { <br>        ULONG ulBK = (ULONG) bkPosition - 3; <br> <br>        /* <br>         *  See if it's in range <br>         */ <br>        if (ulBK &gt;= 0 &amp;&amp; ulBK &lt; MAX_BOOKMARKS) <br>        { <br>            LPABCBK lpABCBK = NULL; <br> <br>            /*  If it's valid...  */ <br>            if (lpABCBK = lpIVTAbc-&gt;rglpABCBK[ulBK])    /* '=' on purpose */ <br>            { <br>                /*  ...free it up.  */ <br> <br>                lpIVTAbc-&gt;lpFreeBuff(lpABCBK); <br>                lpIVTAbc-&gt;rglpABCBK[ulBK] = NULL; <br>            } <br> <br>        } <br>        else <br>        { <br>            /* <br>             * It's an error <br>             */ <br>            hResult = ResultFromScode(E_INVALIDARG); <br> <br>        } <br>    } <br> <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_FreeBookmark, hResult); <br>    return hResult; <br> <br>} <br> <br> <br>/************************************************************************* <br> * <br> -  IVTABC_ExpandRow <br> - <br> *  Stubbed out.  This table doesn't implement catagorization. <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_ExpandRow(LPIVTABC lpIVTAbc, ULONG cbIKey, LPBYTE pbIKey, <br>    ULONG ulRowCount, ULONG ulFlags, LPSRowSet FAR * lppRows, <br>    ULONG FAR * lpulMoreRows) <br> <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(ExpandRow, lpIVTAbc); <br> <br>    Validate_IMAPITable_ExpandRow(lpIVTAbc,  cbIKey,  pbIKey, <br>                            ulRowCount,  ulFlags,  lppRows, lpulMoreRows); <br> <br> <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    DebugTraceResult(IVTABC_ExpandRow, hResult); <br>    return hResult; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_CollapseRow <br> - <br> *  Stubbed out.  This table doesn't implement catagorization. <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_CollapseRow(LPIVTABC lpIVTAbc, ULONG cbIKey, LPBYTE pbIKey, <br>    ULONG ulFlags, ULONG FAR * lpulRowCount) <br> <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(CollapseRow, lpIVTAbc); <br> <br>    Validate_IMAPITable_CollapseRow(lpIVTAbc, cbIKey, pbIKey, ulFlags, lpulRowCount); <br> <br> <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    DebugTraceResult(IVTABC_CollapseRow, hResult); <br>    return hResult; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_WaitForCompletion <br> - <br> *  Stubbed out. <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_WaitForCompletion(LPIVTABC lpIVTAbc, ULONG ulFlags, <br>    ULONG ulTimeout, ULONG FAR * lpulTableStatus) <br>{ <br>    HRESULT hResult; <br> <br>    IVTABC_ValidateObject(WaitForCompletion, lpIVTAbc); <br>     <br>    Validate_IMAPITable_WaitForCompletion(lpIVTAbc, ulFlags, ulTimeout,  <br>                                            lpulTableStatus); <br> <br> <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    DebugTraceResult(IVTABC_WaitForCompletion, hResult); <br>    return hResult; <br> <br>} <br>/************************************************************************* <br> * <br> -  IVTABC_Abort <br> - <br> *  Nothing ever to abort... <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_Abort(LPIVTABC lpIVTAbc) <br> <br>{ <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    IVTABC_ValidateObject(Abort, lpIVTAbc); <br> <br>    Validate_IMAPITable_Abort(lpIVTAbc); <br> <br>    return hrSuccess; <br> <br>} <br> <br>/************************************************************************* <br> * <br> * <br> -  IVTABC_Advise <br> - <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_Advise(LPIVTABC lpIVTAbc, <br>    ULONG ulEventmask, <br>    LPMAPIADVISESINK lpAdviseSink, <br>    ULONG FAR * lpulConnection) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    UINT iAdvise; <br> <br>     <br>    /* <br>     *  Validate the parameters <br>     */ <br>     <br>    IVTABC_ValidateObject(Advise, lpIVTAbc); <br>     <br>    Validate_IMAPITable_Advise(lpIVTAbc, ulEventmask, lpAdviseSink, <br>                                lpulConnection); <br>     <br>    /* Get the Critical Section */ <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    for (iAdvise = 0; <br>        lpIVTAbc-&gt;parglpAdvise &amp;&amp; iAdvise &lt; lpIVTAbc-&gt;cAdvise; <br>        ++iAdvise) <br>    { <br>        if (lpIVTAbc-&gt;parglpAdvise[iAdvise] == NULL) <br>            break; <br>    } <br> <br>    if (iAdvise &gt;= lpIVTAbc-&gt;cAdvise) <br>    { <br>        /* <br>         *   Realloc the array if it exists <br>         */ <br>        if (lpIVTAbc-&gt;parglpAdvise) <br>        { <br>            lpIVTAbc-&gt;parglpAdvise = lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Realloc( <br>                lpIVTAbc-&gt;lpMalloc, <br>                lpIVTAbc-&gt;parglpAdvise, <br>                (lpIVTAbc-&gt;cAdvise + 1) * sizeof(LPMAPIADVISESINK)); <br>        } <br>        else <br>        { <br>            lpIVTAbc-&gt;parglpAdvise = lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Alloc( <br>                lpIVTAbc-&gt;lpMalloc, <br>                (lpIVTAbc-&gt;cAdvise + 1) * sizeof(LPMAPIADVISESINK)); <br>        } <br> <br>        /* <br>         *  Could we get the desired memory? <br>         */ <br>        if (lpIVTAbc-&gt;parglpAdvise == NULL) <br>        { <br>            hResult = MakeResult(E_OUTOFMEMORY); <br>            goto ret; <br>        } <br>    } <br> <br>    lpIVTAbc-&gt;cAdvise++; <br> <br>    *lpulConnection = lpIVTAbc-&gt;ulConnectMic + iAdvise; <br> <br>    lpIVTAbc-&gt;parglpAdvise[iAdvise] = lpAdviseSink; <br> <br>    lpAdviseSink-&gt;lpVtbl-&gt;AddRef(lpAdviseSink); <br> <br>ret: <br>    /* leave critical section */ <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_Advise, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> * <br> -  IVTABC_Unadvise <br> - <br> * <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_Unadvise(LPIVTABC lpIVTAbc, ULONG ulConnection) <br>{ <br>    LPMAPIADVISESINK padvise; <br>    UINT iAdvise; <br>    HRESULT hResult = hrSuccess; <br> <br>    IVTABC_ValidateObject(Unadvise, lpIVTAbc); <br> <br>    Validate_IMAPITable_Unadvise(lpIVTAbc, ulConnection); <br> <br> <br>    if (ulConnection - lpIVTAbc-&gt;ulConnectMic &gt; (ULONG) lpIVTAbc-&gt;cAdvise) <br>    { <br>        DebugTraceSc(IVTABC_Unadvise, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /* Get the Critical Section */ <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    iAdvise = (UINT) (ulConnection - lpIVTAbc-&gt;ulConnectMic); <br>    padvise = lpIVTAbc-&gt;parglpAdvise[iAdvise]; <br>    padvise-&gt;lpVtbl-&gt;Release(padvise); <br>    lpIVTAbc-&gt;parglpAdvise[iAdvise] = NULL; <br>    lpIVTAbc-&gt;cAdvise--; <br> <br>    /* leave critical section */ <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_Unadvise, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_GetStatus <br> - <br> *  Returns the status of this table.  This table really isn't <br> *  dynamic yet, but it could be... <br> * <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_GetStatus(LPIVTABC lpIVTAbc, <br>    ULONG * lpulTableStatus, <br>    ULONG * lpulTableType) <br>{ <br> <br>    /* <br>     *  Parameter checking <br>     */ <br> <br>    IVTABC_ValidateObject(GetStatus, lpIVTAbc); <br> <br>    Validate_IMAPITable_GetStatus(lpIVTAbc, lpulTableStatus, lpulTableType); <br> <br> <br>    *lpulTableStatus = TBLSTAT_COMPLETE; <br>    *lpulTableType = TBLTYPE_DYNAMIC; <br> <br>    return hrSuccess; <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_SetColumns <br> - <br> * <br> *  SetColumns for contents table. <br> * <br> */ <br>STDMETHODIMP  <br>IVTABC_SetColumns(LPIVTABC lpIVTAbc, <br>    LPSPropTagArray lpPTAColSet, <br>    ULONG ulFlags) <br>{ <br>    SCODE scode; <br>    HRESULT hResult = hrSuccess; <br>    int cbSizeOfColSet; <br>    LPSPropTagArray lpPTAColSetT; <br>    ULONG uliCol; <br> <br>    /* <br>     *  Check parameters <br>     */ <br>    IVTABC_ValidateObject(SetColumns, lpIVTAbc); <br>     <br>    Validate_IMAPITable_SetColumns(lpIVTAbc, lpPTAColSet, ulFlags); <br> <br> <br>    /* <br>     *  Verify that there are no PT_ERRORs here... <br>     */ <br>    for (uliCol = 0; uliCol &lt; lpPTAColSet-&gt;cValues; uliCol++) <br>    { <br>        if (PROP_TYPE(lpPTAColSet-&gt;aulPropTag[uliCol]) == PT_ERROR) <br>        { <br>            hResult = ResultFromScode(E_INVALIDARG); <br> <br>            DebugTraceResult(IVTABC_GetStatus, hResult); <br>            return hResult; <br>        } <br>    } <br> <br>    /* <br>     *  Allocate a new column set. <br>     */ <br> <br>    cbSizeOfColSet = CbNewSPropTagArray(lpPTAColSet-&gt;cValues); <br> <br>    scode = lpIVTAbc-&gt;lpAllocBuff(cbSizeOfColSet,(LPVOID *) &amp;lpPTAColSetT); <br> <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br> <br>        DebugTraceResult(IVTABC_GetStatus, hResult); <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Copy the column set in <br>     */ <br>    if (cbSizeOfColSet) <br>        memcpy(lpPTAColSetT, lpPTAColSet, cbSizeOfColSet); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br> <br>    if (lpIVTAbc-&gt;lpPTAColSet != ptagaivtabcColSet) <br>    { <br>        /* <br>         *  Free up the old column set <br>         */ <br>        lpIVTAbc-&gt;lpFreeBuff(lpIVTAbc-&gt;lpPTAColSet); <br>    } <br> <br>    lpIVTAbc-&gt;lpPTAColSet = lpPTAColSetT; <br> <br> <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br>     <br> <br>    return hrSuccess; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_QueryColumns <br> - <br> * <br> * <br> *  I always have all my columns available...  and active. <br> */ <br>STDMETHODIMP  <br>IVTABC_QueryColumns(LPIVTABC lpIVTAbc, <br>    ULONG ulFlags, <br>    LPSPropTagArray FAR * lppColumns) <br>{ <br>    SCODE scode; <br>    HRESULT hResult = hrSuccess; <br>    int cbSizeOfColSet; <br> <br>    /* <br>     *  Check parameters <br>     */ <br> <br>    IVTABC_ValidateObject(QueryColumns, lpIVTAbc); <br> <br>    Validate_IMAPITable_QueryColumns(lpIVTAbc, ulFlags, lppColumns); <br> <br> <br>    EnterCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    /* <br>     *  Allocate enough memory for the column set <br>     */ <br>    if (ulFlags &amp; TBL_ALL_COLUMNS) <br> <br>        cbSizeOfColSet = sizeof(ULONG) + <br>            (int)(ptagaivtabcColSet-&gt;cValues) * sizeof(ULONG); <br>    else <br>        cbSizeOfColSet = sizeof(ULONG) + <br>            (int)lpIVTAbc-&gt;lpPTAColSet-&gt;cValues * sizeof(ULONG); <br> <br> <br>    scode = lpIVTAbc-&gt;lpAllocBuff (cbSizeOfColSet,(LPVOID *) lppColumns); <br> <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Copy the column set in <br>     */ <br>    if (ulFlags &amp; TBL_ALL_COLUMNS) <br>        memcpy(*lppColumns, ptagaivtabcColSet, cbSizeOfColSet); <br>    else <br>        memcpy(*lppColumns, lpIVTAbc-&gt;lpPTAColSet, cbSizeOfColSet); <br> <br> <br>out: <br>    LeaveCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    DebugTraceResult(IVTABC_QueryColumns, hResult); <br>    return hResult; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_GetCollapseState <br> - <br> *  Stubbed out.  Only necessary if this table were to support categorization. <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>IVTABC_GetCollapseState(LPIVTABC lpIVTAbc, <br>                        ULONG ulFlags, <br>                        ULONG cbInstanceKey, <br>                        LPBYTE pbInstanceKey, <br>                        ULONG FAR * lpcbCollapseState, <br>                        LPBYTE FAR * lppbCollapseState) <br>{ <br> <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check parameters <br>     */ <br> <br>    IVTABC_ValidateObject(GetCollapseState, lpIVTAbc); <br> <br>    Validate_IMAPITable_GetCollapseState(lpIVTAbc, ulFlags, cbInstanceKey, <br>                                        pbInstanceKey, lpcbCollapseState, <br>                                        lppbCollapseState); <br> <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br>    DebugTraceResult(IVTABC_GetCollapseState, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  IVTABC_SetCollapseState <br> - <br> *  Stubbed out.  Only necessary if this table were to support categorization. <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>IVTABC_SetCollapseState(LPIVTABC lpIVTAbc, <br>                        ULONG ulFlags, <br>                        ULONG cbCollapseState, <br>                        LPBYTE pbCollapseState, <br>                        BOOKMARK FAR * lpbkLocation) <br>{ <br> <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check parameters <br>     */ <br> <br>    IVTABC_ValidateObject(SetCollapseState, lpIVTAbc); <br> <br>    Validate_IMAPITable_SetCollapseState(lpIVTAbc, ulFlags, cbCollapseState, <br>                                        pbCollapseState, lpbkLocation); <br> <br> <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br>    DebugTraceResult(IVTABC_SetCollapseState, hResult); <br>    return hResult; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
