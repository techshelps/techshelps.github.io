<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OOTID.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2116"></a>OOTID.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  OOTID.C <br> * <br> *  Sample Address Book OneOff Template ID object <br> *  This file contains the code for implementing the Sample AB <br> *  template ID for it's one-off. <br> * <br> *  The template ID for the Sample Address Book one-offs has only one <br> *  purpose.  When the SaveChanges() method gets called it recalculates <br> *  PR_EMAIL_ADDRESS_A and PR_SEARCH_KEY from data that was changed by the <br> *  user.  See how this interacts with the one-off user object implemented <br> *  in OOUSER.C. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br>#include "abp.h" <br> <br>/* <br> *  Declaration of IMailUser object implementation <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _OOTID <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, OOTID_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, OOTID_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br> <br>DECLARE_MAPI_INTERFACE(OOTID_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>}; <br> <br> <br>/* <br> *  The structure behind the 'this' pointer <br> */ <br>typedef struct _OOTID { <br> <br>    const OOTID_Vtbl * lpVtbl; <br> <br>    SAB_Wrapped; <br>     <br>} OOTID, *LPOOTID; <br> <br>/* <br> *  OOTID vtbl is filled in here. <br> */ <br> <br>static const OOTID_Vtbl vtblOOTID = <br>{ <br>    (OOTID_QueryInterface_METHOD *)     ABU_QueryInterface, <br>    (OOTID_AddRef_METHOD *)             WRAP_AddRef, <br>    (OOTID_Release_METHOD *)            WRAP_Release, <br>    (OOTID_GetLastError_METHOD *)       WRAP_GetLastError, <br>    OOTID_SaveChanges, <br>    (OOTID_GetProps_METHOD *)           WRAP_GetProps, <br>    (OOTID_GetPropList_METHOD *)        WRAP_GetPropList, <br>    (OOTID_OpenProperty_METHOD *)       WRAP_OpenProperty, <br>    (OOTID_SetProps_METHOD *)           WRAP_SetProps, <br>    (OOTID_DeleteProps_METHOD *)        WRAP_DeleteProps, <br>    (OOTID_CopyTo_METHOD *)             WRAP_CopyTo, <br>    (OOTID_CopyProps_METHOD *)          WRAP_CopyProps, <br>    (OOTID_GetNamesFromIDs_METHOD *)    WRAP_GetNamesFromIDs, <br>    (OOTID_GetIDsFromNames_METHOD *)    WRAP_GetIDsFromNames, <br>}; <br> <br>/************************************************************************* <br> * <br> -  NewOOTID <br> - <br> *  Creates the OOTID object associated with a mail user. <br> * <br> * <br> */ <br> <br>enum { <br>    isptOOTIDFillPR_ADDRTYPE_A = 0, <br>    isptOOTIDFillPR_TEMPLATEID, <br>    isptOOTIDFillPR_DISPLAY_TYPE, <br>    cmaxOOTIDFill <br>}; <br> <br>HRESULT <br>HrNewOOTID( LPMAPIPROP *        lppMAPIPropNew, <br>            ULONG               cbTemplateId, <br>            LPENTRYID           lpTemplateId, <br>            ULONG               ulTemplateFlags, <br>            LPMAPIPROP          lpPropData, <br>            LPABLOGON           lpABPLogon, <br>            LPCIID              lpInterface, <br>            HINSTANCE           hLibrary, <br>            LPALLOCATEBUFFER    lpAllocBuff, <br>            LPALLOCATEMORE      lpAllocMore, <br>            LPFREEBUFFER        lpFreeBuff, <br>            LPMALLOC            lpMalloc ) <br>{ <br>    LPOOTID lpOOTID = NULL; <br>    SCODE sc; <br>    HRESULT hResult = hrSuccess; <br> <br>    /* <br>     *  Allocate space for the OOTID structure <br>     */ <br>    sc = lpAllocBuff( sizeof(OOTID), (LPVOID *) &amp;lpOOTID ); <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Initialize the OOTID structure <br>     */ <br> <br>    lpOOTID-&gt;lpVtbl = &amp;vtblOOTID; <br>    lpOOTID-&gt;lcInit = 1; <br>    lpOOTID-&gt;hResult = hrSuccess; <br>    lpOOTID-&gt;idsLastError = 0; <br>    lpOOTID-&gt;hLibrary = hLibrary; <br>    lpOOTID-&gt;lpAllocBuff = lpAllocBuff; <br>    lpOOTID-&gt;lpAllocMore = lpAllocMore; <br>    lpOOTID-&gt;lpFreeBuff = lpFreeBuff; <br>    lpOOTID-&gt;lpMalloc = lpMalloc; <br>    lpOOTID-&gt;lpABLogon = lpABPLogon; <br>    lpOOTID-&gt;lpPropData = lpPropData; <br> <br>    /* <br>     *  Fill in the wrapped object if we're asked to. <br>     */ <br>    if (ulTemplateFlags &amp; FILL_ENTRY) <br>    { <br>        SPropValue spv[cmaxOOTIDFill]; <br> <br>        spv[isptOOTIDFillPR_ADDRTYPE_A].ulPropTag = PR_ADDRTYPE_A; <br>        spv[isptOOTIDFillPR_ADDRTYPE_A].Value.lpszA = lpszEMT; <br> <br>        spv[isptOOTIDFillPR_TEMPLATEID].ulPropTag = PR_TEMPLATEID; <br>        spv[isptOOTIDFillPR_TEMPLATEID].Value.bin.lpb = (LPBYTE) lpTemplateId; <br>        spv[isptOOTIDFillPR_TEMPLATEID].Value.bin.cb = cbTemplateId; <br> <br>        spv[isptOOTIDFillPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE; <br>        spv[isptOOTIDFillPR_DISPLAY_TYPE].Value.l = DT_MAILUSER; <br> <br>        hResult = lpPropData-&gt;lpVtbl-&gt;SetProps( <br>            lpPropData, <br>            cmaxOOTIDFill, <br>            spv, <br>            NULL); <br>         <br>        if (HR_FAILED(hResult)) <br>        { <br>            goto err; <br>        } <br> <br>    } <br> <br>    /* <br>     *  AddRef lpPropData so we can use it after we return <br>     */ <br> <br>    (void)lpPropData-&gt;lpVtbl-&gt;AddRef(lpPropData); <br> <br>    InitializeCriticalSection(&amp;lpOOTID-&gt;cs); <br>     <br>    /*  We must AddRef the lpABPLogon object since we will be using it <br>     */ <br>    lpABPLogon-&gt;lpVtbl-&gt;AddRef(lpABPLogon); <br> <br>    *lppMAPIPropNew = (LPVOID) lpOOTID; <br> <br>out: <br> <br>    DebugTraceResult(HrNewOOTID, hResult); <br>    return hResult; <br> <br>err: <br> <br>    lpFreeBuff(lpOOTID); <br>    goto out; <br> <br>} <br> <br> <br>/* <br> *  These properties are used and set by the one off dialog, and are <br> *  combined to make up a valid email address. <br> */ <br> <br>enum { <br>    isptcontpropPR_SERVER_NAME = 0, <br>    isptcontpropPR_SHARE_NAME, <br>    isptcontpropPR_PATH_NAME, <br>    cmaxcontprop <br>};       <br> <br>static const SizedSPropTagArray(cmaxcontprop, pta) = <br>{ <br>    cmaxcontprop, <br>    { <br>        PR_SERVER_NAME, <br>        PR_SHARE_NAME, <br>        PR_PATH_NAME, <br>    } <br>}; <br> <br>/* <br> *  These properties are computed by this function and saved back into the underlying <br> *  property storage. <br> */ <br>enum { <br>    isptcomppropsPR_EMAIL_ADDRESS_A = 0, <br>    isptcomppropsPR_SEARCH_KEY, <br>    cmaxcompprops <br>}; <br> <br> <br>/* <br> -  OOTID_SaveChanges <br> - <br> *  All this method does is build the PR_EMAIL_ADDRESS_A and PR_SEARCH_KEY from PR_SERVER_NAME, <br> *  PR_SHARE_NAME, and PR_PATH_NAME. <br> */ <br> <br>STDMETHODIMP <br>OOTID_SaveChanges(LPOOTID lpOOTID, ULONG ulFlags) <br>{ <br>    HRESULT hResult; <br>    /* <br>     *  szEMA can be of the format: <br>     * <br>     *      \\SERVER_NAME\SHARE_NAME[\PATH]'\0' <br>     */ <br>    CHAR szEMA[ MAX_SERVER_NAME + 2 + MAX_SHARE_NAME + 1 + MAX_PATH + 2 ]; <br>    LPSPropValue lpspv = NULL; <br>    SPropValue rgspv[cmaxcompprops]; <br>    ULONG ulcValues; <br>    ULONG cbT = 0; <br>    LPBYTE lpbT = NULL; <br>    SCODE sc; <br> <br>    /* <br>     *  Check to see if it is big enough to be my object <br>     */ <br>    if (IsBadReadPtr(lpOOTID, sizeof(OOTID))) <br>    { <br>        /* <br>         *  Not big enough <br>         */ <br>        return MakeResult(E_INVALIDARG); <br>    } <br> <br>    /* <br>     *  Check to see that it's OOTIDs vtbl <br>     */ <br>    if (lpOOTID-&gt;lpVtbl != &amp;vtblOOTID) <br>    { <br>        /* <br>         *  vtbl not ours <br>         */ <br>        return MakeResult(E_INVALIDARG); <br>    } <br> <br> <br>    /* <br>     *  Get the properties that make up the email address from the <br>     *  mapiprop object <br>     */ <br>    hResult = lpOOTID-&gt;lpPropData-&gt;lpVtbl-&gt;GetProps( <br>        lpOOTID-&gt;lpPropData, <br>        (LPSPropTagArray) &amp;pta, <br>        0,      /* ansi */ <br>        &amp;ulcValues, <br>        &amp;lpspv); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto out; <br>    } <br> <br>    /* <br>     *  Must have at least PR_SERVER_NAME and PR_SHARE_NAME to make a valid <br>     *  email address <br>     */ <br>    if (lpspv[isptcontpropPR_SERVER_NAME].ulPropTag != PR_SERVER_NAME <br>        || lpspv[isptcontpropPR_SHARE_NAME].ulPropTag != PR_SHARE_NAME) <br>    { <br>        /* <br>         *  Without at least these two properties I cannot recalculate <br>         *  anything.  So, just exit cleanly without changing anything. <br>         */ <br>        hResult = hrSuccess; /* to mask any warnings from above */ <br>        goto out; <br>    } <br> <br>    /* create the email address */ <br>    wsprintfA(szEMA, "\\\\%s\\%s", <br>        lpspv[isptcontpropPR_SERVER_NAME].Value.lpszA, lpspv[isptcontpropPR_SHARE_NAME].Value.lpszA); <br> <br>    /*  Did we also get a path??  If so append it on */ <br>    if (lpspv[isptcontpropPR_PATH_NAME].ulPropTag == PR_PATH_NAME) <br>    { <br>        /*  But only if there's a value that make sense */ <br>        if (*lpspv[isptcontpropPR_PATH_NAME].Value.lpszA)   /* i.e. !'\0' */ <br>            wsprintfA(szEMA, "%s\\%s", szEMA, lpspv[isptcontpropPR_PATH_NAME].Value.lpszA); <br>    } <br> <br>    /* initialize the email address prop value */ <br>    rgspv[isptcomppropsPR_EMAIL_ADDRESS_A].ulPropTag = PR_EMAIL_ADDRESS_A; <br>    rgspv[isptcomppropsPR_EMAIL_ADDRESS_A].Value.lpszA = szEMA; <br> <br>    /* <br>     *  Generate the PR_SEARCH_KEY <br>     */ <br>    /*  Search keys for mailable recipients that have email addresses are <br>     *  defined as "EmailType':'EmailAddress\0".  We do the +2 for the ':' and <br>     *  '\0'. <br>     */ <br>    cbT = lstrlenA(szEMA) + lstrlenA(lpszEMT) + 2; <br> <br>    sc = lpOOTID-&gt;lpAllocBuff( cbT, (LPVOID *) &amp;lpbT ); <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br>    lstrcpyA((LPSTR) lpbT, lpszEMT); <br>    lstrcatA((LPSTR) lpbT, ":"); <br>    lstrcatA((LPSTR) lpbT, szEMA); <br>    CharUpperBuffA((LPSTR) lpbT, (UINT) cbT); <br> <br>    rgspv[isptcomppropsPR_SEARCH_KEY].ulPropTag = PR_SEARCH_KEY; <br>    rgspv[isptcomppropsPR_SEARCH_KEY].Value.bin.cb = cbT; <br>    rgspv[isptcomppropsPR_SEARCH_KEY].Value.bin.lpb = lpbT; <br> <br>     <br>    /* <br>     *  set the email address and search key properties <br>     */ <br>    hResult = lpOOTID-&gt;lpPropData-&gt;lpVtbl-&gt;SetProps( <br>        lpOOTID-&gt;lpPropData, <br>        cmaxcompprops, <br>        rgspv, <br>        NULL); <br> <br>    lpOOTID-&gt;lpFreeBuff(lpbT); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto out; <br>    } <br> <br>out: <br>    // <br>    //  If I'm leaving this routine and everything up to this point has been successful, <br>    //  then pass on the SaveChanges to the underlying property storage. <br>    // <br>    if (!HR_FAILED(hResult)) <br>    { <br>        hResult = lpOOTID-&gt;lpPropData-&gt;lpVtbl-&gt;SaveChanges( <br>            lpOOTID-&gt;lpPropData, <br>            ulFlags); <br>    } <br> <br>    /* free the buffer */ <br>    lpOOTID-&gt;lpFreeBuff(lpspv); <br> <br>    DebugTraceResult(OOTID_SaveChanges, hResult); <br>    return hResult; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
