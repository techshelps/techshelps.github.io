<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ABUSER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2115"></a>ABUSER.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ABUSER.C <br> * <br> *  Sample AB Mail User object <br> *  This file contains the code for implementing the Sample AB <br> *  Mail user. <br> * <br> *  The mail user has a read-only interface.  Hence a few of the methods <br> *  will always return E_ACCESSDENIED. <br> * <br> *  Typically it would be in this module (particularly HrNewABUser) that <br> *  your provider would validate the existance of the entry associated <br> *  with a particular entryid.  The Sample Address Book doesn't do this <br> *  because it doesn't need to. <br> * <br> *  The following routines are implemented in this file: <br> * <br> *  HrNewSampUser <br> *  ABU_QueryInterface <br> *  ABU_Release <br> *  ABU_OpenProperty <br> *  HrBuildListBoxTable <br> *  HrBuildDDListboxTable <br> *  HrBuildComboBoxTable <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br>#include "abp.h" <br>#include "sampabp.rh" <br> <br>/* <br> *  Defined in ABP.C <br> */ <br> <br>#define MAX_ADDRTYPE                        25 <br>#define MAX_EMAIL_ADDRESS                   MAX_PATH <br>#define MAX_COMBO_EDIT                      25 <br>#define MAX_LISTBOX_ROWS                    25 <br> <br>/* property tags used on details property sheet */ <br>#define PR_CHECKBOX_1_VALUE             PROP_TAG(PT_BOOLEAN,0x6601) <br>#define PR_CHECKBOX_2_VALUE             PROP_TAG(PT_BOOLEAN,0x6602) <br>#define PR_CHECKBOX_3_VALUE             PROP_TAG(PT_BOOLEAN,0x6603) <br>#define PR_LISTBOX_VALUE                PROP_TAG(PT_LONG,0x6604) <br>#define PR_COMBOBOX_VALUE               PROP_TAG(PT_STRING8,0x6606) <br>#define PR_DDLISTBOX_VALUE              PROP_TAG(PT_LONG,0x6608) <br> <br>/* Display table control structures for the General and Options property sheets. */ <br> <br>/*  First Pane "General", this is the information specific about the first <br> *  edit control, which is used to display the display name of this user. */ <br>DTBLEDIT editUserDisplayName = <br>{ <br>    sizeof(DTBLEDIT), <br>    0, <br>    MAX_DISPLAY_NAME, <br>    PR_DISPLAY_NAME_A <br>}; <br> <br>/* <br> *  "General" pane.  This is the information about the email address type associated <br> *  with this entry <br> */ <br>DTBLEDIT editUserEmailType = <br>{ <br>    sizeof(DTBLEDIT), <br>    0, <br>    MAX_ADDRTYPE, <br>    PR_ADDRTYPE_A <br>}; <br> <br> <br>/* <br> *  "General" pane.  This is the information about the email address associated with <br> *  this entry. <br> */ <br>DTBLEDIT editUserEmailAddress = <br>{ <br>    sizeof(DTBLEDIT), <br>    0, <br>    MAX_EMAIL_ADDRESS, <br>    PR_EMAIL_ADDRESS_A <br>}; <br> <br> <br>/* <br> *  This is the actual definition for the "General" pane.  It lists all the controls <br> *  found on it. <br> */ <br>DTCTL rgdtctlUserGeneral[] = <br>{ <br>    /* <br>     * general property page <br>     *  MAPI UI will default this first pane to be named "General" in this release. <br>     *  However, subsequent releases will not include this behaviour.  Because of this <br>     *  it is stongly suggested that your provider provide a DTCT_PAGE control for each <br>     *  pane. <br>     */ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, <br>        &amp;dtblpage}, <br> <br>    /* display name control and edit control */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, <br>        &amp;dtbllabel}, <br>    {DTCT_EDIT, 0, NULL, 0, szNoFilter, IDC_USER_DISPLAY_NAME, <br>        &amp;editUserDisplayName}, <br> <br>    /* inbox path control and edit control */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, <br>        &amp;dtbllabel}, <br>    {DTCT_EDIT, 0, NULL, 0, szNoFilter, IDC_USER_INBOX_PATH, <br>        &amp;editUserEmailAddress}, <br> <br>    /* address type control and edit control */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, <br>        &amp;dtbllabel}, <br>    {DTCT_EDIT, 0, NULL, 0, szAddrTypeFilter, IDC_USER_EMAIL_TYPE, <br>        &amp;editUserEmailType}, <br>}; <br> <br>/* controls for the options property page */ <br>/* <br> *  "Options" property page.  This is the information that allows the <br> *  UI to fill in the listbox control on this pane. <br> */ <br> DTBLLBX listbox1 = <br>{ <br>    0, <br>    PR_LISTBOX_VALUE, <br>    PR_LISTBOX_TABLE <br>}; <br> <br> <br>/* <br> *  "Options" property page.  The following three controls define a set of check boxes <br> *  that are found on this pane.  Notice that the three prop tags in these structures <br> *  are different - compare them to the radio buttons found in ABCONT.C. <br> */ <br> DTBLCHECKBOX checkbox1 = <br>{ <br>    sizeof(DTBLCHECKBOX), <br>    0, <br>    PR_CHECKBOX_1_VALUE <br>}; <br> <br> DTBLCHECKBOX checkbox2 = <br>{ <br>    sizeof(DTBLCHECKBOX), <br>    0, <br>    PR_CHECKBOX_2_VALUE <br>}; <br> <br> DTBLCHECKBOX checkbox3 = <br>{ <br>    sizeof(DTBLCHECKBOX), <br>    0, <br>    PR_CHECKBOX_3_VALUE <br>}; <br> <br> <br>/* <br> *   "Options" property page.  This is the information required for <br> *  the UI to generate a drop down list box. <br> */ <br> DTBLDDLBX ddlistbox1 = <br>{ <br>    sizeof(DTBLDDLBX), <br>    PR_DISPLAY_NAME_A, <br>    PR_DDLISTBOX_VALUE, <br>    PR_DDLISTBOX_TABLE <br>}; <br> <br> <br>/* <br> *  "Options" property page.  This is the information required for the <br> *  UI to generate a combo box control. <br> */ <br> DTBLCOMBOBOX combobox1 = <br>{ <br>    sizeof(DTBLCOMBOBOX), <br>    0, <br>    MAX_COMBO_EDIT, <br>    PR_COMBOBOX_VALUE, <br>    PR_COMBOBOX_TABLE <br>}; <br> <br>/* <br> *  This is the actual definition of the "Options" pane.  This lists all the <br> *  controls found on that page. <br> */ <br> DTCTL rgdtctlUserAdvanced[] = <br>{ <br> <br>    /* options property page <br>     *  This tells the UI what the tab for this pane should say. <br>     */ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, &amp;dtblpage}, <br> <br>    /* control and listbox */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtbllabel}, <br>    {DTCT_LBX, 0, NULL, 0, NULL, <br>        IDC_USER_LISTBOX, &amp;listbox1}, <br> <br>    /* group box and radio buttons */ <br>    {DTCT_GROUPBOX, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtblgroupbox}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, <br>        IDC_USER_CHECKBOX_1, &amp;checkbox1}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, <br>        IDC_USER_CHECKBOX_2, &amp;checkbox2}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, <br>        IDC_USER_CHECKBOX_3, &amp;checkbox3}, <br> <br>    /* control and drop down listbox */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtbllabel}, <br>    {DTCT_DDLBX, DT_EDITABLE, NULL, 0, NULL, <br>        IDC_USER_DDLISTBOX, &amp;ddlistbox1}, <br> <br>    /* control and combobox */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtbllabel}, <br>    {DTCT_COMBOBOX, DT_EDITABLE, NULL, 0, szNoFilter, <br>        IDC_USER_COMBOBOX, &amp;combobox1}, <br>}; <br> <br>/* Display table pages */ <br> <br>/* <br> *  This lists the order in which the panes will appear in the UI.  The <br> *  UI is driven by a display table which is generated by a call to <br> *  BuildDisplayTable() which takes the following DTPAGE structure. <br> */ <br>DTPAGE rgdtpage[] = <br>{ <br>    { <br>        sizeof(rgdtctlUserGeneral) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(UserGeneralPage), <br>        "", <br>        rgdtctlUserGeneral <br>    }, <br>    { <br>        sizeof(rgdtctlUserAdvanced) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(UserAdvancedPage), <br>        "", <br>        rgdtctlUserAdvanced <br>    } <br> <br>}; <br> <br> <br>/* <br> *  Definition of the ABUSER object <br> */ <br>typedef struct _ABUSER <br>{ <br>    const ABU_Vtbl FAR * lpVtbl; <br> <br>    SAB_Wrapped; <br> <br>    /* <br>     *   Tables used in options property page <br>     */ <br>    LPTABLEDATA lpTDatListBox; <br>    LPTABLEDATA lpTDatDDListBox; <br>    LPTABLEDATA lpTDatComboBox; <br> <br> <br>} ABUSER, *LPABUSER; <br> <br>/* <br> *  ABUser vtbl filled in here <br> */ <br>const ABU_Vtbl vtblABU = <br>{ <br> <br>    ABU_QueryInterface, <br>    (ABU_AddRef_METHOD *)           ROOT_AddRef, <br>    ABU_Release, <br>    (ABU_GetLastError_METHOD *)     ROOT_GetLastError, <br>    (ABU_SaveChanges_METHOD *)      WRAP_SaveChanges, <br>    (ABU_GetProps_METHOD *)         WRAP_GetProps, <br>    (ABU_GetPropList_METHOD *)      WRAP_GetPropList, <br>    ABU_OpenProperty, <br>    (ABU_SetProps_METHOD *)         WRAP_SetProps, <br>    (ABU_DeleteProps_METHOD *)      WRAP_DeleteProps, <br>    (ABU_CopyTo_METHOD *)           WRAP_CopyTo, <br>    (ABU_CopyProps_METHOD *)        WRAP_CopyProps, <br>    (ABU_GetNamesFromIDs_METHOD *)  WRAP_GetNamesFromIDs, <br>    (ABU_GetIDsFromNames_METHOD *)  WRAP_GetIDsFromNames, <br>}; <br> <br> <br>HRESULT HrBuildListBoxTable(LPABUSER lpABUser); <br>HRESULT HrBuildDDListBoxTable(LPABUSER lpABUser); <br>HRESULT HrBuildComboBoxTable(LPABUSER lpABUser); <br> <br>enum {  ivalusrPR_DISPLAY_TYPE = 0, <br>        ivalusrPR_OBJECT_TYPE, <br>        ivalusrPR_ENTRYID, <br>        ivalusrPR_RECORD_KEY, <br>        ivalusrPR_DISPLAY_NAME_A, <br>        ivalusrPR_TRANSMITABLE_DISPLAY_NAME_A, <br>        ivalusrPR_EMAIL_ADDRESS_A, <br>        ivalusrPR_ADDRTYPE_A, <br>        ivalusrPR_SEARCH_KEY, <br>        ivalusrPR_LISTBOX_VALUE, <br>        ivalusrPR_CHECKBOX_1_VALUE, <br>        ivalusrPR_CHECKBOX_2_VALUE, <br>        ivalusrPR_CHECKBOX_3_VALUE, <br>        ivalusrPR_DDLISTBOX_VALUE, <br>        ivalusrPR_COMBOBOX_VALUE, <br>        ivalusrPR_TEMPLATEID, <br>        cvalusrMax }; <br> <br>static SizedSPropTagArray( cvalusrMax, tagaABUAccess) = <br>{ <br>    cvalusrMax, <br>    {   PR_DISPLAY_TYPE, <br>        PR_OBJECT_TYPE, <br>        PR_ENTRYID, <br>        PR_RECORD_KEY, <br>        PR_DISPLAY_NAME_A, <br>        PR_TRANSMITABLE_DISPLAY_NAME_A, <br>        PR_EMAIL_ADDRESS_A, <br>        PR_ADDRTYPE_A, <br>        PR_SEARCH_KEY, <br>        PR_LISTBOX_VALUE, <br>        PR_CHECKBOX_1_VALUE, <br>        PR_CHECKBOX_2_VALUE, <br>        PR_CHECKBOX_3_VALUE, <br>        PR_DDLISTBOX_VALUE, <br>        PR_COMBOBOX_VALUE, <br>        PR_TEMPLATEID <br>      } <br>}; <br> <br>static ULONG    rgulABUAccess[cvalusrMax] = <br>{ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_DISPLAY_TYPE */ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_OBJECT_TYPE */ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_ENTRYID */ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_RECORD_KEY */ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_DISPLAY_NAME_A */ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_TRANSMITABLE_DISPLAY_NAME_A */ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_EMAIL_ADDRESS_A */ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_ADDRTYPE_A */ <br>    IPROP_READONLY | IPROP_CLEAN,   /* PR_SEARCH_KEY */ <br>    IPROP_READWRITE | IPROP_CLEAN,  /* PR_LISTBOX_VALUE */ <br>    IPROP_READWRITE | IPROP_CLEAN,  /* PR_CHECKBOX_1_VALUE */ <br>    IPROP_READWRITE | IPROP_CLEAN,  /* PR_CHECKBOX_2_VALUE */ <br>    IPROP_READWRITE | IPROP_CLEAN,  /* PR_CHECKBOX_3_VALUE */ <br>    IPROP_READWRITE | IPROP_CLEAN,  /* PR_DDLISTBOX_VALUE */ <br>    IPROP_READWRITE | IPROP_CLEAN,  /* PR_COMBOBOX_VALUE */ <br>    IPROP_READONLY | IPROP_CLEAN    /* PR_TEMPLATEID */ <br>}; <br> <br> <br>/************************************************************************* <br> * <br> -  HrNewSampUser <br> - <br> *  Creates the IMAPIProp associated with a mail user. <br> * <br> * <br> */ <br>HRESULT <br>HrNewSampUser(  LPMAILUSER *        lppMAPIPropEntry, <br>                ULONG *             lpulObjType, <br>                ULONG               cbEntryID, <br>                LPENTRYID           lpEntryID, <br>                LPABLOGON           lpABPLogon, <br>                LPCIID              lpInterface, <br>                HINSTANCE           hLibrary, <br>                LPALLOCATEBUFFER    lpAllocBuff, <br>                LPALLOCATEMORE      lpAllocMore, <br>                LPFREEBUFFER        lpFreeBuff, <br>                LPMALLOC            lpMalloc ) <br>{ <br>    LPABUSER lpABUser = NULL; <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    LPPROPDATA lpPropData = NULL; <br>    SPropValue spv[cvalusrMax]; <br>    ULONG cbT = 0; <br>    LPBYTE lpbT = NULL; <br>    LPSTR lpszEMA = NULL; <br> <br>    /*  Do I support this interface?? */ <br>    if (lpInterface) <br>    { <br>        if (memcmp(lpInterface, &amp;IID_IMailUser, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IMAPIProp, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IUnknown, sizeof(IID))) <br>        { <br>            DebugTraceSc(HrNewSampUser, MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>        } <br>    } <br>    /* <br>     *  Allocate space for the ROOT structure <br>     */ <br>    sc = lpAllocBuff(sizeof(ABUSER), (LPVOID *) &amp;lpABUser); <br>    if (FAILED(sc)) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    lpABUser-&gt;lpVtbl = &amp;vtblABU; <br>    lpABUser-&gt;lcInit = 1; <br>    lpABUser-&gt;hResult = hrSuccess; <br>    lpABUser-&gt;idsLastError = 0; <br> <br>    lpABUser-&gt;hLibrary = hLibrary; <br>    lpABUser-&gt;lpAllocBuff = lpAllocBuff; <br>    lpABUser-&gt;lpAllocMore = lpAllocMore; <br>    lpABUser-&gt;lpFreeBuff = lpFreeBuff; <br>    lpABUser-&gt;lpMalloc = lpMalloc; <br> <br>    lpABUser-&gt;lpABLogon = lpABPLogon; <br>    lpABUser-&gt;lpTDatListBox = NULL; <br>    lpABUser-&gt;lpTDatDDListBox = NULL; <br>    lpABUser-&gt;lpTDatComboBox = NULL; <br> <br>    /* <br>     *  Create property storage object <br>     */ <br> <br>    sc = CreateIProp((LPIID) &amp;IID_IMAPIPropData, <br>        lpAllocBuff, <br>        lpAllocMore, <br>        lpFreeBuff, <br>        lpMalloc, <br>        &amp;lpPropData); <br> <br>    if (FAILED(sc)) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Set up initial set of properties associated with this <br>     *  mailuser. <br>     */ <br> <br>    /* <br>     *  Easy ones first <br>     */ <br> <br>    spv[ivalusrPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE; <br>    spv[ivalusrPR_DISPLAY_TYPE].Value.l = DT_MAILUSER; <br> <br>    spv[ivalusrPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE; <br>    spv[ivalusrPR_OBJECT_TYPE].Value.l = MAPI_MAILUSER; <br> <br>    spv[ivalusrPR_ENTRYID].ulPropTag = PR_ENTRYID; <br>    spv[ivalusrPR_ENTRYID].Value.bin.cb = sizeof(USR_ENTRYID); <br>    spv[ivalusrPR_ENTRYID].Value.bin.lpb = (LPBYTE) lpEntryID; <br> <br>    /* <br>     *  Now the calculated props <br>     */ <br> <br>    spv[ivalusrPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY; <br>    spv[ivalusrPR_RECORD_KEY].Value.bin.cb = sizeof(USR_ENTRYID); <br>    spv[ivalusrPR_RECORD_KEY].Value.bin.lpb = (LPBYTE) lpEntryID; <br> <br>    spv[ivalusrPR_DISPLAY_NAME_A].ulPropTag = PR_DISPLAY_NAME_A; <br>    spv[ivalusrPR_DISPLAY_NAME_A].Value.lpszA = ((LPUSR_ENTRYID) lpEntryID)-&gt;abcrec.rgchDisplayName; <br> <br>    /* Should always be the same as PR_DISPLAY_NAME */ <br>    spv[ivalusrPR_TRANSMITABLE_DISPLAY_NAME_A].ulPropTag = PR_TRANSMITABLE_DISPLAY_NAME_A; <br>    spv[ivalusrPR_TRANSMITABLE_DISPLAY_NAME_A].Value.lpszA = ((LPUSR_ENTRYID) lpEntryID)-&gt;abcrec.rgchDisplayName; <br> <br>    spv[ivalusrPR_EMAIL_ADDRESS_A].ulPropTag = PR_EMAIL_ADDRESS_A; <br>    spv[ivalusrPR_EMAIL_ADDRESS_A].Value.lpszA = ((LPUSR_ENTRYID) lpEntryID)-&gt;abcrec.rgchEmailAddress; <br>    lpszEMA = ((LPUSR_ENTRYID) lpEntryID)-&gt;abcrec.rgchEmailAddress; <br> <br>    spv[ivalusrPR_ADDRTYPE_A].ulPropTag = PR_ADDRTYPE_A; <br>    spv[ivalusrPR_ADDRTYPE_A].Value.lpszA = lpszEMT; <br> <br>    /* <br>     *  Build the search key... <br>     */ <br>    /*  Search keys for mailable recipients that have email addresses are <br>     *  defined as "EmailType':'EmailAddress\0".  We do the +2 for the ':' and <br>     *  '\0'. <br>     */ <br>    cbT = lstrlenA(lpszEMA) + lstrlenA(lpszEMT) + 2; <br> <br>    sc = lpAllocBuff( cbT, (LPVOID *) &amp;lpbT ); <br>    if (FAILED(sc)) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto err; <br>    } <br>    lstrcpyA((LPSTR) lpbT, lpszEMT); <br>    lstrcatA((LPSTR) lpbT, ":"); <br>    lstrcatA((LPSTR) lpbT, lpszEMA); <br>    CharUpperBuff((LPTSTR) lpbT, (UINT) cbT); <br> <br>    spv[ivalusrPR_SEARCH_KEY].ulPropTag = PR_SEARCH_KEY; <br>    spv[ivalusrPR_SEARCH_KEY].Value.bin.cb = cbT; <br>    spv[ivalusrPR_SEARCH_KEY].Value.bin.lpb = lpbT; <br> <br>    /* properties used by the options property page */ <br>    spv[ivalusrPR_LISTBOX_VALUE].ulPropTag = PR_LISTBOX_VALUE; <br>    spv[ivalusrPR_LISTBOX_VALUE].Value.l = 5; <br> <br>    spv[ivalusrPR_CHECKBOX_1_VALUE].ulPropTag = PR_CHECKBOX_1_VALUE; <br>    spv[ivalusrPR_CHECKBOX_1_VALUE].Value.b = TRUE; <br> <br>    spv[ivalusrPR_CHECKBOX_2_VALUE].ulPropTag = PR_CHECKBOX_2_VALUE; <br>    spv[ivalusrPR_CHECKBOX_2_VALUE].Value.b = FALSE; <br> <br>    spv[ivalusrPR_CHECKBOX_3_VALUE].ulPropTag = PR_CHECKBOX_3_VALUE; <br>    spv[ivalusrPR_CHECKBOX_3_VALUE].Value.b = TRUE; <br> <br>    spv[ivalusrPR_DDLISTBOX_VALUE].ulPropTag = PR_DDLISTBOX_VALUE; <br>    spv[ivalusrPR_DDLISTBOX_VALUE].Value.l = 10; <br> <br>    spv[ivalusrPR_COMBOBOX_VALUE].ulPropTag = PR_COMBOBOX_VALUE; <br>    spv[ivalusrPR_COMBOBOX_VALUE].Value.lpszA = "ComboBox item 10"; <br> <br>    /* <br>     *  Note that we're using our entryID for our templateID. <br>     *  This is a really simple way to implement templateIDs. <br>     *  (See TID.C) <br>     */ <br>    spv[ivalusrPR_TEMPLATEID].ulPropTag = PR_TEMPLATEID; <br>    spv[ivalusrPR_TEMPLATEID].Value.bin.cb = sizeof(USR_ENTRYID); <br>    spv[ivalusrPR_TEMPLATEID].Value.bin.lpb = (LPBYTE) lpEntryID; <br> <br>    /* <br>     *   Set the default properties <br>     */ <br>    hr = lpPropData-&gt;lpVtbl-&gt;SetProps( <br>        lpPropData, <br>        cvalusrMax, <br>        spv, <br>        NULL); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        goto err; <br>    } <br> <br>    /* <br>     *  Although this object is basically read only, we wanted to show <br>     *  an example of how the check-boxes and other controls on the <br>     *  "Options" pane work.  If we had set this object to be read only, <br>     *  the values behind those controls would have been static. <br>     */ <br>    (void)lpPropData-&gt;lpVtbl-&gt;HrSetObjAccess(lpPropData, IPROP_READWRITE); <br> <br>    /* <br>     *  Set the client access rights to the various properties.  Notice <br>     *  that everything is READONLY except for the properties related to <br>     *  the controls on the "Options" pane. <br>     * <br>     *  All properties are intially marked as CLEAN. <br>     */ <br>    (void) lpPropData-&gt;lpVtbl-&gt;HrSetPropAccess(lpPropData, <br>                                (LPSPropTagArray) &amp;tagaABUAccess, <br>                                rgulABUAccess); <br> <br>    lpABUser-&gt;lpPropData = (LPMAPIPROP) lpPropData; <br> <br>    InitializeCriticalSection(&amp;lpABUser-&gt;cs); <br> <br>    /*  We must AddRef the lpABPLogon object since we will be using it <br>     */ <br>    lpABPLogon-&gt;lpVtbl-&gt;AddRef(lpABPLogon); <br> <br>    *lppMAPIPropEntry = (LPVOID) lpABUser; <br>    *lpulObjType = MAPI_MAILUSER; <br> <br>out: <br>    lpFreeBuff(lpbT); <br> <br>    DebugTraceResult(HrNewSampUser, hr); <br>    return hr; <br> <br>err: <br>    if (lpPropData) <br>        lpPropData-&gt;lpVtbl-&gt;Release(lpPropData); <br> <br>    lpFreeBuff(lpABUser); <br> <br>    goto out; <br> <br>} <br> <br> <br>/************************************************************************* <br> * <br> * <br> -  ABU_QueryInterface <br> - <br> *  Allows QI'ing to only IUnknown, IMAPIProp, and IMailUser. <br> * <br> *  This method is reused in TID.C, OOTID.C, and ABOOSER.C.  Hence the <br> *  difference in checking of the 'this' pointer from other methods within <br> *  this object. <br> */ <br>STDMETHODIMP <br>ABU_QueryInterface(LPABUSER lpABUser, <br>    REFIID lpiid, <br>    LPVOID FAR * lppNewObj) <br>{ <br> <br>    HRESULT hr = hrSuccess; <br> <br>     <br>    /*  Minimally check the lpABUser object <br>     *  Can't do any more extensive checking that this because this method is reused <br>     *  in OOUSER.C. <br>     */ <br> <br>    if (IsBadReadPtr(lpABUser, offsetof(ABUSER, lpVtbl)+sizeof(ABU_Vtbl *))) <br>    { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br>         <br>    if (IsBadReadPtr(lpABUser-&gt;lpVtbl, <br>                     offsetof(ABU_Vtbl, QueryInterface)+sizeof(ABU_QueryInterface_METHOD *))) <br>    { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br>         <br>    if (ABU_QueryInterface != lpABUser-&gt;lpVtbl-&gt;QueryInterface) <br>    { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IUnknown_QueryInterface(lpABUser, lpiid, lppNewObj); <br> <br>     <br>    /*  See if the requested interface is one of ours */ <br> <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IMAPIProp, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IMailUser, sizeof(IID))) <br>    { <br>        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */ <br>        hr = ResultFromScode(E_NOINTERFACE); <br>        goto out; <br>    } <br> <br>    /*  Bump the usage count and return same object pointer. */ <br> <br>    EnterCriticalSection(&amp;lpABUser-&gt;cs); <br>    ++lpABUser-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABUser-&gt;cs); <br>     <br>    *lppNewObj = lpABUser; <br> <br>out: <br> <br>    DebugTraceResult(ABU_QueryInterface, hr); <br>    return hr; <br>} <br> <br> <br>/************************************************** <br> * <br> -  ABU_Release <br> - <br> *      Decrement lcInit. <br> *      When lcInit == 0, free up the lpABUser structure <br> * <br> */ <br>STDMETHODIMP_(ULONG) <br>ABU_Release(LPABUSER lpABUser) <br>{ <br> <br>    LONG lcInit; <br>    /* <br>     *  Check to see if it's big enough to hold this object <br>     */ <br>    if (IsBadReadPtr(lpABUser, sizeof(ABUSER))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see that it's the correct vtbl <br>     */ <br>    if (lpABUser-&gt;lpVtbl != &amp;vtblABU) <br>    { <br>        /* <br>         *  Not my vtbl <br>         */ <br>        return 1; <br>    } <br> <br>    Validate_IUnknown_Release(lpABUser); <br> <br> <br>    EnterCriticalSection(&amp;lpABUser-&gt;cs); <br>    lcInit = --lpABUser-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABUser-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br> <br>        /* <br>         *  Get rid of the lpPropData <br>         */ <br> <br>        lpABUser-&gt;lpPropData-&gt;lpVtbl-&gt;Release(lpABUser-&gt;lpPropData); <br> <br>        /* <br>         *  Get rid of the tables used by the options property page <br>         */ <br> <br>        if (lpABUser-&gt;lpTDatListBox) <br>            lpABUser-&gt;lpTDatListBox-&gt;lpVtbl-&gt;Release(lpABUser-&gt;lpTDatListBox); <br> <br>        if (lpABUser-&gt;lpTDatDDListBox) <br>            lpABUser-&gt;lpTDatDDListBox-&gt;lpVtbl-&gt;Release(lpABUser-&gt;lpTDatDDListBox); <br> <br>        if (lpABUser-&gt;lpTDatComboBox) <br>            lpABUser-&gt;lpTDatComboBox-&gt;lpVtbl-&gt;Release(lpABUser-&gt;lpTDatComboBox); <br> <br>        /*   <br>         *  Release our reference to the ABLogon object. <br>         */ <br>        if (lpABUser-&gt;lpABLogon) <br>        { <br>            lpABUser-&gt;lpABLogon-&gt;lpVtbl-&gt;Release(lpABUser-&gt;lpABLogon); <br>            lpABUser-&gt;lpABLogon = NULL; <br>        } <br> <br>        /* <br>         *  Destroy the critical section for this object <br>         */ <br> <br>        DeleteCriticalSection(&amp;lpABUser-&gt;cs); <br> <br>        /* <br>         *  Set the vtbl to NULL.  This way the client will find out <br>         *  real fast if it's calling a method on a released object.  That is, <br>         *  the client will crash.  Hopefully, this will happen during the <br>         *  development stage of the client. <br>         */ <br> <br>        lpABUser-&gt;lpVtbl = NULL; <br> <br>        /* <br>         *  Need to free the object <br>         */ <br> <br>        lpABUser-&gt;lpFreeBuff( lpABUser ); <br>        return 0; <br>    } <br> <br>    return lcInit; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  ABU_OpenProperty <br> - <br> * <br> *  This is how we get the display table associated with this users <br> *  details screen.  This is also how we get the tables which are needed <br> *  to fill out the "Options" property pane. <br> */ <br>STDMETHODIMP <br>ABU_OpenProperty(LPABUSER lpABUser, <br>    ULONG ulPropTag, <br>    LPCIID lpiid, <br>    ULONG ulInterfaceOptions, <br>    ULONG ulFlags, <br>    LPUNKNOWN * lppUnk) <br>{ <br> <br>    HRESULT hResult; <br> <br>    ABU_ValidateObject(OpenProperty, lpABUser); <br>     <br>    Validate_IMAPIProp_OpenProperty(lpABUser, ulPropTag, lpiid, <br>                    ulInterfaceOptions, ulFlags, lppUnk); <br> <br> <br>    if (ulInterfaceOptions &amp; ~MAPI_UNICODE ) <br>    { <br>        /* <br>         *  Only the Unicode flag should be set for any of the objects that might <br>         *  be returned from this object. <br>         */ <br>         <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br> <br>        DebugTraceResult(ABU_OpenProperty, hResult); <br>        return hResult; <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>        DebugTraceResult(ABU_OpenProperty, hResult); <br>        return hResult; <br>         <br>    } <br>     <br>    if (ulFlags &amp; MAPI_CREATE) <br>    { <br>        hResult = ResultFromScode(E_ACCESSDENIED); <br>         <br>        DebugTraceResult(ABU_OpenProperty, hResult); <br>        return hResult; <br>    } <br>     <br> <br>    if (ulPropTag == PR_DETAILS_TABLE || <br>        ulPropTag == PR_LISTBOX_TABLE || <br>        ulPropTag == PR_DDLISTBOX_TABLE || <br>        ulPropTag == PR_COMBOBOX_TABLE) <br>    { <br>        /* Check to see if they're expecting a table interface */ <br> <br>        if (memcmp(lpiid, &amp;IID_IMAPITable, sizeof(IID))) <br>        { <br>            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            return hResult; <br>        } <br>    } <br> <br> <br> <br>    EnterCriticalSection(&amp;lpABUser-&gt;cs); <br> <br> <br> <br>    switch (ulPropTag) <br>    { <br>        case PR_DETAILS_TABLE: <br>        { <br> <br>            /* Looking for the display table*/ <br>            /* Create a display table */ <br> <br>            hResult = BuildDisplayTable( <br>                lpABUser-&gt;lpAllocBuff, <br>                lpABUser-&gt;lpAllocMore, <br>                lpABUser-&gt;lpFreeBuff, <br>                lpABUser-&gt;lpMalloc, <br>                lpABUser-&gt;hLibrary, <br>                sizeof(rgdtpage) / sizeof(DTPAGE), <br>                rgdtpage, <br>                0, <br>                (LPMAPITABLE *) lppUnk, <br>                NULL); <br> <br>            break; <br>        } <br> <br>        case PR_LISTBOX_TABLE: <br>        { <br>             <br>            /* <br>             *  Looking for the table that fills the listbox <br>             *  on the Options pane on this user's details <br>             */ <br> <br>            /* <br>             *  If we don't already have a Table Data Object, make one. <br>             */ <br>            if (!lpABUser-&gt;lpTDatListBox) <br>            { <br>                hResult = HrBuildListBoxTable(lpABUser); <br>                if (HR_FAILED(hResult)) <br>                    goto out; <br>            } <br> <br>            Assert(lpABUser-&gt;lpTDatListBox); <br> <br>            /* Get a view from the table data object*/ <br>            hResult = lpABUser-&gt;lpTDatListBox-&gt;lpVtbl-&gt;HrGetView( <br>                        lpABUser-&gt;lpTDatListBox, <br>                        NULL, <br>                        NULL, <br>                        0, <br>                        (LPMAPITABLE *) lppUnk); <br> <br>            break; <br>        } <br> <br>        case PR_DDLISTBOX_TABLE: <br>        { <br>            /* <br>             *  Locking for the table that fills the drop down listbox <br>             *  on the Options pane on this user's details. <br>             */ <br> <br>            if (!lpABUser-&gt;lpTDatDDListBox) <br>            { <br>                hResult = HrBuildDDListBoxTable(lpABUser); <br>                if (HR_FAILED(hResult)) <br>                    goto out; <br>            } <br> <br>            Assert(lpABUser-&gt;lpTDatDDListBox); <br> <br>            /* Get a view from the table data object */ <br>            hResult = lpABUser-&gt;lpTDatDDListBox-&gt;lpVtbl-&gt;HrGetView( <br>                        lpABUser-&gt;lpTDatDDListBox, <br>                        NULL, <br>                        NULL, <br>                        0, <br>                        (LPMAPITABLE *) lppUnk); <br> <br> <br>            break; <br>        } <br> <br>        case PR_COMBOBOX_TABLE: <br>        { <br>            /* <br>             *  Locking for the table that fills the combobox <br>             *  on the Options pane on this user's details. <br>             */ <br> <br>            if (!lpABUser-&gt;lpTDatComboBox) <br>            { <br>                hResult = HrBuildComboBoxTable(lpABUser); <br>                if (HR_FAILED(hResult)) <br>                    goto out; <br>            } <br> <br>            Assert(lpABUser-&gt;lpTDatComboBox); <br> <br>            /* Get a view from the table data object */ <br>            hResult = <br>                lpABUser-&gt;lpTDatComboBox-&gt;lpVtbl-&gt;HrGetView( <br>                lpABUser-&gt;lpTDatComboBox, <br>                NULL, <br>                NULL, <br>                0, <br>                (LPMAPITABLE *) lppUnk); <br> <br>            break; <br>        } <br> <br>        default: <br>        { <br>            hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>            break; <br>        } <br>    } <br> <br>out: <br> <br>    LeaveCriticalSection(&amp;lpABUser-&gt;cs); <br>     <br>    DebugTraceResult(ABU_OpenProperty, hResult); <br>    return hResult; <br> <br>} <br> <br>/********************************************************************** <br> * <br> *  Private functions <br> */ <br> <br>/* <br> *  Default column set for listbox table <br> */ <br> <br>enum {  ivallbxPR_DISPLAY_NAME_A = 0, <br>        ivallbxPR_COMMENT_A, <br>        ivallbxPR_ENTRYID, <br>        ivallbxPR_DISPLAY_TYPE, <br>        ivallbxPR_LISTBOX_VALUE, <br>        ivallbxPR_INSTANCE_KEY, <br>        cvallbxMax }; <br> <br>const SizedSPropTagArray(cvallbxMax, tagaColSetListBox) = <br>{ <br>    cvallbxMax, <br>    { <br>        PR_DISPLAY_NAME_A, <br>        PR_COMMENT_A, <br>        PR_ENTRYID, <br>        PR_DISPLAY_TYPE, <br>        PR_LISTBOX_VALUE, <br>        PR_INSTANCE_KEY <br>    } <br>}; <br> <br>typedef struct _options_entryid <br>{ <br>    BYTE abFlags[4]; <br>    MAPIUID muid; <br>    ULONG ulVersion; <br>    ULONG ulType; <br>    ULONG ulRowNumber; <br>} OPTIONS_ENTRYID, *LPOPTIONS_ENTRYID; <br> <br>#define CBOPTIONS_ENTRYID sizeof(OPTIONS_ENTRYID) <br> <br>OPTIONS_ENTRYID OptionsEntryID = <br>{ <br>    {0, 0, 0, 0}, <br>    MUIDABSAMPLE, <br>    SAMP_VERSION, <br>    SAMP_UNKNOWN, <br>    0 <br>}; <br> <br>HRESULT <br>HrBuildListBoxTable(LPABUSER lpABUser) <br>{ <br>    SCODE sc; <br>    HRESULT hResult; <br>    SPropValue rgsPropValue[cvallbxMax]; <br>    SRow sRow; <br>    char szDisplay[MAX_FMT_DET_DN+2]; /* +2 for digits */ <br>    char szComment[MAX_FMT_DET_COMMENT+2]; /* +2 for digits */ <br>    char szFmtDisplay[MAX_FMT_DET_DN]; </code></pre>
<p>
</p>
<pre><code>char szFmtComment[MAX_FMT_DET_COMMENT]; <br>    LPSTR pszFmtComment = (LPSTR) szFmtComment; <br>    LPSTR pszFmtDisplay = (LPSTR) szFmtDisplay; <br> <br>    ULONG uliRow; <br> <br>    /* <br>     *  Get string resources <br>     */ <br>    sc = ScLoadString(  IDS_FMT_DET_DN, <br>                        MAX_FMT_DET_DN, <br>                        NULL, <br>                        lpABUser-&gt;hLibrary, <br>                        (LPSTR *) &amp;pszFmtDisplay); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    sc = ScLoadString(  IDS_FMT_DET_COMMENT, <br>                        MAX_FMT_DET_COMMENT, <br>                        NULL, <br>                        lpABUser-&gt;hLibrary, <br>                        (LPSTR *) &amp;pszFmtComment); <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    /* Create a Table Data object */ <br>    sc = CreateTable( <br>        (LPIID) &amp;IID_IMAPITableData, <br>        lpABUser-&gt;lpAllocBuff, <br>        lpABUser-&gt;lpAllocMore, <br>        lpABUser-&gt;lpFreeBuff, <br>        lpABUser-&gt;lpMalloc, <br>        0, <br>        PR_DISPLAY_NAME_A, <br>        (LPSPropTagArray) &amp;tagaColSetListBox, <br>        &amp;(lpABUser-&gt;lpTDatListBox)); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    /* constants */ <br>    sRow.cValues = cvallbxMax; <br>    sRow.lpProps = rgsPropValue; <br> <br>    /* <br>     *  Although assignment of szDisplay and szComment happen here, their actual <br>     *  values happen below in the for loop. <br>     */ <br>    rgsPropValue[ivallbxPR_DISPLAY_NAME_A].ulPropTag = PR_DISPLAY_NAME_A; <br>    rgsPropValue[ivallbxPR_DISPLAY_NAME_A].Value.lpszA = szDisplay; <br> <br>    rgsPropValue[ivallbxPR_COMMENT_A].ulPropTag = PR_COMMENT_A; <br>    rgsPropValue[ivallbxPR_COMMENT_A].Value.lpszA = szComment; <br> <br> <br>    /* <br>     *  For this release of MAPI the following two properties are required <br>     *  for all listboxes exposed in any details dialog.  This requirement is <br>     *  scheduled to be removed before ship <br>     */ <br>    rgsPropValue[ivallbxPR_ENTRYID].ulPropTag = PR_ENTRYID; <br>    rgsPropValue[ivallbxPR_ENTRYID].Value.bin.lpb = (LPBYTE) &amp;OptionsEntryID; <br>    rgsPropValue[ivallbxPR_ENTRYID].Value.bin.cb = CBOPTIONS_ENTRYID; <br> <br>    rgsPropValue[ivallbxPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE; <br>    rgsPropValue[ivallbxPR_DISPLAY_TYPE].Value.l = 0;  /*  There are no defines for this yet */ <br> <br> <br>    rgsPropValue[ivallbxPR_LISTBOX_VALUE].ulPropTag = PR_LISTBOX_VALUE; <br> <br>    rgsPropValue[ivallbxPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY; <br>    rgsPropValue[ivallbxPR_INSTANCE_KEY].Value.bin.cb = sizeof(ULONG); <br> <br>    /* fill up the table */ <br>    for (uliRow = 0; uliRow &lt; MAX_LISTBOX_ROWS; uliRow++) <br>    { <br>        wsprintfA(szDisplay, szFmtDisplay, uliRow); <br>        wsprintfA(szComment, szFmtComment, uliRow); <br> <br>        OptionsEntryID.ulRowNumber = uliRow; <br>        rgsPropValue[ivallbxPR_LISTBOX_VALUE].Value.l = uliRow; <br> <br>        rgsPropValue[ivallbxPR_INSTANCE_KEY].Value.bin.lpb = (LPBYTE) &amp;uliRow; <br> <br>        hResult = lpABUser-&gt;lpTDatListBox-&gt;lpVtbl-&gt;HrModifyRow( <br>            lpABUser-&gt;lpTDatListBox, <br>            &amp;sRow); <br>        if (HR_FAILED(hResult)) <br>        { <br>            /* <br>             *  Mask errors here... <br>             *  We want to do this because it's probibly still a valid <br>             *  table data object that I can get views from.  Most likely <br>             *  just some of the rows will be missing... <br>             */ <br>            hResult = hrSuccess; <br>            break; <br>        } <br>        /* <br>         *  get rid of any warnings <br>         */ <br>        hResult = hrSuccess; <br>    } <br> <br> <br>out: <br> <br>    DebugTraceResult(hrBuildListBoxTable, hResult); <br>    return hResult; <br>} <br> <br>/* <br> *  Default column set for the dropdown listbox table <br> */ <br> <br>enum {  ivalddPR_DISPLAY_NAME_A = 0, <br>        ivalddPR_ENTRYID, <br>        ivalddPR_DISPLAY_TYPE, <br>        ivalddPR_DDLISTBOX_VALUE, <br>        ivalddPR_INSTANCE_KEY, <br>        cvalddMax }; <br> <br>const SizedSPropTagArray(cvalddMax, tagaColSetDDListBox) = <br>{ <br>    cvalddMax, <br>    { <br>        PR_DISPLAY_NAME_A, <br>        PR_ENTRYID, <br>        PR_DISPLAY_TYPE, <br>        PR_DDLISTBOX_VALUE, <br>        PR_INSTANCE_KEY <br>    } <br>}; <br> <br>HRESULT <br>HrBuildDDListBoxTable(LPABUSER lpABUser) <br>{ <br>    SCODE sc; <br>    HRESULT hResult; <br>    SPropValue rgsPropValue[cvalddMax]; <br>    SRow sRow; <br>    char szFmtDisplay[MAX_FMT_DD_DN]; <br>    char szDisplay[MAX_FMT_DD_DN+2]; /* +2 for digits */ <br>    ULONG uliRow; <br>    LPSTR pszFmtDisplay = (LPSTR) szFmtDisplay; <br> <br>    /* <br>     *  Get resource strings <br>     */ <br>    sc = ScLoadString(  IDS_FMT_DD_DN, <br>                        MAX_FMT_DD_DN, <br>                        NULL, <br>                        lpABUser-&gt;hLibrary, <br>                        (LPSTR *)&amp;pszFmtDisplay ); <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    /* Create a Table Data object */ <br>    sc = CreateTable( <br>        (LPIID) &amp;IID_IMAPITableData, <br>        lpABUser-&gt;lpAllocBuff, <br>        lpABUser-&gt;lpAllocMore, <br>        lpABUser-&gt;lpFreeBuff, <br>        lpABUser-&gt;lpMalloc, <br>        0, <br>        PR_DISPLAY_NAME_A, <br>        (LPSPropTagArray) &amp;tagaColSetDDListBox, <br>        &amp;(lpABUser-&gt;lpTDatDDListBox)); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    /* constants */ <br>    sRow.cValues = cvalddMax; <br>    sRow.lpProps = rgsPropValue; <br> <br> <br>    /* <br>     *  Although assignment of szDisplay happens here, its actual <br>     *  values happen below in the for loop. <br>     */ <br>    rgsPropValue[ivalddPR_DISPLAY_NAME_A].ulPropTag = PR_DISPLAY_NAME_A; <br>    rgsPropValue[ivalddPR_DISPLAY_NAME_A].Value.lpszA = szDisplay; <br> <br>    /* <br>     *  For this release of MAPI the following two properties are required <br>     *  for all listboxes exposed in any details dialog.  This requirement is <br>     *  scheduled to be removed before ship <br>     */ <br>    rgsPropValue[ivalddPR_ENTRYID].ulPropTag = PR_ENTRYID; <br>    rgsPropValue[ivalddPR_ENTRYID].Value.bin.lpb = (LPBYTE) &amp;OptionsEntryID; <br>    rgsPropValue[ivalddPR_ENTRYID].Value.bin.cb = CBOPTIONS_ENTRYID; <br> <br>    rgsPropValue[ivalddPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE; <br>    rgsPropValue[ivalddPR_DISPLAY_TYPE].Value.l = 0; <br>     <br> <br>    rgsPropValue[ivalddPR_DDLISTBOX_VALUE].ulPropTag = PR_DDLISTBOX_VALUE; <br> <br>    rgsPropValue[ivalddPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY; <br>    rgsPropValue[ivalddPR_INSTANCE_KEY].Value.bin.cb = sizeof(ULONG); <br> <br>    /* fill up the table */ <br>    for (uliRow = 0; uliRow &lt; 25; uliRow++) <br>    { <br>        wsprintfA(szDisplay, szFmtDisplay, uliRow); <br> <br>        OptionsEntryID.ulRowNumber = uliRow; <br>        rgsPropValue[ivalddPR_DDLISTBOX_VALUE].Value.l = uliRow; <br>         <br>        rgsPropValue[ivalddPR_INSTANCE_KEY].Value.bin.lpb = (LPBYTE) &amp;uliRow; <br> <br>        hResult = lpABUser-&gt;lpTDatDDListBox-&gt;lpVtbl-&gt;HrModifyRow( <br>            lpABUser-&gt;lpTDatDDListBox, <br>            &amp;sRow); <br>        if (HR_FAILED(hResult)) <br>        { <br>            /* <br>             *  Mask errors here... <br>             *  We want to do this because it's probibly still a valid <br>             *  table data object that I can get views from.  Most likely <br>             *  just some of the rows will be missing... <br>             */ <br> <br>            hResult = hrSuccess; <br>            break; <br>        } <br>        /* <br>         *  get rid of any warnings <br>         */ <br>        hResult = hrSuccess; <br>    } <br> <br>out: <br> <br>    DebugTraceResult(HrBuildDDListBoxTable, hResult); <br>    return hResult; <br>} <br> <br>/* <br> *  Default column set for the combobox table <br> */ <br>enum { ivalcbPR_DISPLAY_NAME_A = 0, <br>        ivalcbPR_ENTRYID, <br>        ivalcbPR_DISPLAY_TYPE, <br>        ivalcbPR_COMBOBOX_VALUE, <br>        ivalcbPR_INSTANCE_KEY, <br>        cvalcbMax }; <br> <br>const SizedSPropTagArray(cvalcbMax, tagaColSetComboBox) = <br>{ <br>    cvalcbMax, <br>    { <br>        PR_DISPLAY_NAME_A, <br>        PR_ENTRYID, <br>        PR_DISPLAY_TYPE, <br>        PR_COMBOBOX_VALUE, <br>        PR_INSTANCE_KEY <br>    } <br>}; <br> <br>HRESULT <br>HrBuildComboBoxTable(LPABUSER lpABUser) <br>{ <br>    SCODE sc; <br>    HRESULT hResult; <br>    SPropValue rgsPropValue[cvalcbMax]; <br>    SRow sRow; <br>    char szFmtDisplay[MAX_FMT_COMBO_DN]; <br>    char szDisplay[MAX_FMT_COMBO_DN + 2]; /* +2 for digits */ <br>    ULONG uliRow; <br>    LPSTR pszFmtDisplay = (LPSTR) szFmtDisplay; <br> <br>    /* <br>     *  Get resource strings <br>     */ <br>    sc = ScLoadString(  IDS_FMT_COMBO_DN, <br>                        MAX_FMT_COMBO_DN, <br>                        NULL, <br>                        lpABUser-&gt;hLibrary, <br>                        (LPSTR *) &amp;pszFmtDisplay ); <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    /* Create a table data object */ <br>    sc = CreateTable( <br>        (LPIID) &amp;IID_IMAPITableData, <br>        lpABUser-&gt;lpAllocBuff, <br>        lpABUser-&gt;lpAllocMore, <br>        lpABUser-&gt;lpFreeBuff, <br>        lpABUser-&gt;lpMalloc, <br>        0, <br>        PR_DISPLAY_NAME_A, <br>        (LPSPropTagArray) &amp;tagaColSetComboBox, <br>        &amp;(lpABUser-&gt;lpTDatComboBox)); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    /* constants */ <br>    sRow.cValues = cvalcbMax; <br>    sRow.lpProps = rgsPropValue; <br> <br>    /* <br>     *  Although assignment of szDisplay happens here, its actual <br>     *  values happen below in the for loop. <br>     */ <br>    rgsPropValue[ivalcbPR_DISPLAY_NAME_A].ulPropTag = PR_DISPLAY_NAME_A; <br>    rgsPropValue[ivalcbPR_DISPLAY_NAME_A].Value.lpszA = szDisplay; <br> <br> <br>    /* <br>     *  For this release of MAPI the following two properties are required <br>     *  for all listboxes exposed in any details dialog.  This requirement is <br>     *  scheduled to be removed before ship <br>     */ <br>    rgsPropValue[ivalcbPR_ENTRYID].ulPropTag = PR_ENTRYID; <br>    rgsPropValue[ivalcbPR_ENTRYID].Value.bin.lpb = (LPBYTE) &amp;OptionsEntryID; <br>    rgsPropValue[ivalcbPR_ENTRYID].Value.bin.cb = CBOPTIONS_ENTRYID; <br> <br>    rgsPropValue[ivalcbPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE; <br>    rgsPropValue[ivalcbPR_DISPLAY_TYPE].Value.l = 0; <br> <br>    rgsPropValue[ivalcbPR_COMBOBOX_VALUE].ulPropTag = PR_COMBOBOX_VALUE; <br>    rgsPropValue[ivalcbPR_COMBOBOX_VALUE].Value.lpszA = szDisplay; <br> <br>    rgsPropValue[ivalcbPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY; <br>    rgsPropValue[ivalcbPR_INSTANCE_KEY].Value.bin.cb = sizeof(ULONG); <br> <br> <br>    /* fill up the table */ <br>    for (uliRow = 0; uliRow &lt; 25; uliRow++) <br>    { <br>        wsprintfA(szDisplay, szFmtDisplay, uliRow); <br> <br>        OptionsEntryID.ulRowNumber = uliRow; <br> <br>        rgsPropValue[ivalcbPR_INSTANCE_KEY].Value.bin.lpb = (LPBYTE) &amp;uliRow; <br> <br>        hResult = lpABUser-&gt;lpTDatComboBox-&gt;lpVtbl-&gt;HrModifyRow( <br>            lpABUser-&gt;lpTDatComboBox, <br>            &amp;sRow); <br>        if (HR_FAILED(hResult)) <br>        { <br>            /* <br>             *  Mask errors here... <br>             *  We want to do this because it's probibly still a valid <br>             *  table data object that I can get views from.  Most likely <br>             *  just some of the rows will be missing... <br>             */ <br> <br>            hResult = hrSuccess; <br>            break; <br>        } <br> <br>        /* <br>         *  get rid of any warnings <br>         */ <br>        hResult = hrSuccess; <br>    } <br> <br>out: <br>    DebugTraceResult(HrBuildComboBoxTable, hResult); <br>    return hResult; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
