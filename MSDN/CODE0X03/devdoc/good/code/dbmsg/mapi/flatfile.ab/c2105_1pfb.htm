<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OOUSER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2117"></a>OOUSER.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  OOUSER.C <br> * <br> *  Sample AB One Off Mail User object <br> *  This file contains the code for implementing the Sample AB <br> *  One Off Mail user. <br> * <br> *  This is the object that is opened in response to the entryID that is <br> *  supplied by this provider in the one-off table (see GetOneOffTable() in <br> *  ABP.C).  All this object does is supply a display table and any default <br> *  values for properties that might need to be there.  One important property <br> *  that this object exports is it's PR_TEMPLATEID (see how this object and <br> *  the implementation in OOTID.C work together). <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br>#include "abp.h" <br>#include "sampabp.rh" <br> <br>/* <br> *  Display table control structures for the OneOff property sheet. <br> */ <br> <br>/* <br> *  This is the edit control on the one-off pane. <br> */ <br>static DTBLEDIT editOOUserDisplayName = <br>{ <br>    sizeof(DTBLEDIT), <br>    0, <br>    MAX_DISPLAY_NAME, <br>    PR_DISPLAY_NAME_A <br>}; <br> <br>/* <br> *  This edit control is for the server name edit box. <br> */ <br>static DTBLEDIT editOOUserServer = <br>{ <br>    sizeof(DTBLEDIT), <br>    0, <br>    MAX_SERVER_NAME, <br>    PR_SERVER_NAME <br>}; <br> <br>/* <br> *  This is the edit control associated with the Share field. <br> */ <br>static DTBLEDIT editOOUserShare = <br>{ <br>    sizeof(DTBLEDIT), <br>    0, <br>    MAX_SHARE_NAME, <br>    PR_SHARE_NAME <br>}; <br> <br>/* <br> *  This is the edit control associated with the path. <br> */ <br>static DTBLEDIT editOOUserPath = <br>{ <br>    sizeof(DTBLEDIT), <br>    0, <br>    MAX_PATH, <br>    PR_PATH_NAME <br>}; <br> <br>/* <br> *  General Property Page definition <br> */ <br>static DTCTL rgdtctlOOUserGeneral[] = <br>{ <br>    /* general property page */ <br>    /* <br>     *  Although this control is not absolutely required, <br>     *  we suggest filling it in.  This non-requirement <br>     *  will probibly change before we actually ship! <br>     */ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, &amp;dtblpage}, <br> <br>    /* display name static control and edit control */ <br>    /* <br>     *  Note that this edit control is editable and required <br>     */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE|DT_REQUIRED, NULL, 0, szNoFilter, <br>        IDC_OOUSER_DISPLAY_NAME, &amp;editOOUserDisplayName}, <br> <br>    /* group box */ <br>    {DTCT_GROUPBOX, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtblgroupbox}, <br>    /* <br>     *  The following three label/edit pairs make up the <br>     *  calculated email address (see OOTID.C's SaveChanges() method). <br>     */ <br>    /* server static control and edit control */ <br>     <br>    {DTCT_LABEL, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE | DT_REQUIRED, NULL, 0, szFileNameFilter, <br>        IDC_OOUSER_SERVER, &amp;editOOUserServer}, <br> <br>    /* share static control and edit control */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE | DT_REQUIRED, NULL, 0, szFileNameFilter, <br>        IDC_OOUSER_SHARE, &amp;editOOUserShare}, <br> <br>    /* path static control and edit control */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, <br>        IDC_STATIC_CONTROL, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, <br>        IDC_OOUSER_PATH, &amp;editOOUserPath}, <br>}; <br> <br>/* <br> *  The OneOff property sheet definition.  This is an array of <br> *  property sheet pages that gets passed to BuildDisplayTable(). <br> */ <br>static DTPAGE rgdtpage[] = <br>{ <br>    { <br>        sizeof(rgdtctlOOUserGeneral) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(OOUserGeneralPage), <br>        "", <br>        rgdtctlOOUserGeneral <br>    }, <br>}; <br> <br> <br> <br> <br>/* <br> *  Declaration of IMailUser object implementation <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _ABOOUSER <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABOOUSER_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAILUSER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABOOUSER_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAILUSER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(ABOOUSER_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMAILUSER_METHODS(IMPL) <br>}; <br> <br>/* <br> *  Structure behind the 'this' <br> */ <br> <br>typedef struct _ABOOUSER <br>{ <br>    const ABOOUSER_Vtbl FAR * lpVtbl; <br> <br>    SAB_Wrapped; <br> <br>} ABOOUSER, *LPABOOUSER; <br> <br> <br>#define ABOOUSER_ValidateObject(Method, pThis)      \ <br>{                                                   \ <br>    HRESULT hResult;                                \ <br>    if (IsBadReadPtr(pThis, sizeof(ABOOUSER)))      \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABOOUSER##_##Method, hResult); \ <br>        return hResult;                             \ <br>    }                                               \ <br>                                                    \ <br>    if (pThis-&gt;lpVtbl != &amp;vtblABOOUSER)             \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABOOUSER##_##Method, hResult); \ <br>        return hResult;                             \ <br>    }                                               \ <br>} <br> <br>/* <br> *  ABOOUser vtbl is set up here. <br> */ <br>static const ABOOUSER_Vtbl vtblABOOUSER = <br>{ <br>    (ABOOUSER_QueryInterface_METHOD *)  ABU_QueryInterface, <br>    (ABOOUSER_AddRef_METHOD *)          WRAP_AddRef, <br>    (ABOOUSER_Release_METHOD *)         WRAP_Release, <br>    (ABOOUSER_GetLastError_METHOD *)    WRAP_GetLastError, <br>    (ABOOUSER_SaveChanges_METHOD *)     WRAP_SaveChanges, <br>    (ABOOUSER_GetProps_METHOD *)        WRAP_GetProps, <br>    (ABOOUSER_GetPropList_METHOD *)     WRAP_GetPropList, <br>    ABOOUSER_OpenProperty, <br>    (ABOOUSER_SetProps_METHOD *)        WRAP_SetProps, <br>    (ABOOUSER_DeleteProps_METHOD *)     WRAP_DeleteProps, <br>    (ABOOUSER_CopyTo_METHOD *)          WRAP_CopyTo, <br>    (ABOOUSER_CopyProps_METHOD *)       WRAP_CopyProps, <br>    (ABOOUSER_GetNamesFromIDs_METHOD *) WRAP_GetNamesFromIDs, <br>    (ABOOUSER_GetIDsFromNames_METHOD *) WRAP_GetIDsFromNames, <br>}; <br> <br>enum {  ivaloousrPR_DISPLAY_TYPE = 0, <br>        ivaloousrPR_ADDRTYPE_A, <br>        ivaloousrPR_TEMPLATEID, <br>        cvaloousrMax }; <br> <br>SizedSPropTagArray( cvaloousrMax, tagaABOOUSERAccess) = <br>{ <br>      cvaloousrMax <br>    , { PR_DISPLAY_TYPE <br>      , PR_ADDRTYPE_A <br>      , PR_TEMPLATEID <br>      } <br>}; <br> <br>ULONG   rgulABOOUSERAccess[cvaloousrMax] = <br>{ <br>      IPROP_READONLY | IPROP_CLEAN  /* PR_DISPLAY_TYPE */ <br>    , IPROP_READONLY | IPROP_CLEAN  /* PR_ADDRTYPE_A */ <br>    , IPROP_READONLY | IPROP_CLEAN  /* PR_TEMPLATEID */ <br>}; <br> <br>/************************************************************************* <br> * <br> -  NewSampOOUser <br> - <br> *  Creates the IMailUser associated with a one off mail user. <br> * <br> * <br> */ <br>HRESULT <br>HrNewSampOOUser(LPMAILUSER *        lppMAPIPropEntry, <br>                ULONG *             lpulObjType, <br>                ULONG               cbEntryID, <br>                LPENTRYID           lpEntryID, <br>                LPABLOGON           lpABPLogon, <br>                LPCIID              lpInterface, <br>                HINSTANCE           hLibrary, <br>                LPALLOCATEBUFFER    lpAllocBuff, <br>                LPALLOCATEMORE      lpAllocMore, <br>                LPFREEBUFFER        lpFreeBuff, <br>                LPMALLOC            lpMalloc ) <br>{ <br>    LPABOOUSER lpABOOUser = NULL; <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    LPPROPDATA lpPropData = NULL; <br>    SPropValue spv[4]; <br> <br>    /*  Do I support this interface?? */ <br>    if (lpInterface) <br>    { <br>        if (memcmp(lpInterface, &amp;IID_IMailUser, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IMAPIProp, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IUnknown, sizeof(IID))) <br>        { <br>            DebugTraceSc(HrNewSampOOUser, MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>        } <br>    } <br> <br>    /* <br>     *  Allocate space for the ABOOUser structure <br>     */ <br>    sc = lpAllocBuff(sizeof(ABOOUSER), (LPVOID *) &amp;lpABOOUser); <br> <br>    if (FAILED(sc)) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    lpABOOUser-&gt;lpVtbl = &amp;vtblABOOUSER; <br>    lpABOOUser-&gt;lcInit = 1; <br>    lpABOOUser-&gt;hResult = hrSuccess; <br>    lpABOOUser-&gt;idsLastError = 0; <br>    lpABOOUser-&gt;hLibrary = hLibrary; <br>    lpABOOUser-&gt;lpAllocBuff = lpAllocBuff; <br>    lpABOOUser-&gt;lpAllocMore = lpAllocMore; <br>    lpABOOUser-&gt;lpFreeBuff = lpFreeBuff; <br>    lpABOOUser-&gt;lpMalloc = lpMalloc; <br>    lpABOOUser-&gt;lpABLogon = lpABPLogon; <br> <br>    /* <br>     *  Create property storage object. <br>     */ <br> <br>    sc = CreateIProp( <br>        (LPIID) &amp;IID_IMAPIPropData, <br>        lpAllocBuff, <br>        lpAllocMore, <br>        lpFreeBuff, <br>        lpMalloc, <br>        &amp;lpPropData); <br> <br>    if (FAILED(sc)) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Set up the initial set of properties <br>     */ <br> <br>    spv[0].ulPropTag = PR_DISPLAY_TYPE; <br>    spv[0].Value.l = DT_MAILUSER; <br> <br>    spv[1].ulPropTag = PR_OBJECT_TYPE; <br>    spv[1].Value.l = MAPI_MAILUSER; <br> <br>    /* <br>     *  Note that we're using our entryID for our templateID. <br>     *  This is a really simple way to implement templateIDs. <br>     *  (See OOTID.C) <br>     */ <br>    spv[2].ulPropTag = PR_TEMPLATEID; <br>    spv[2].Value.bin.cb = sizeof(OOUSR_ENTRYID); <br>    spv[2].Value.bin.lpb = (LPBYTE) lpEntryID; <br> <br>    spv[3].ulPropTag = PR_ADDRTYPE; <br>    spv[3].Value.lpszA = lpszEMT; <br> <br>    /* <br>     *   Set the default properties <br>     */ <br>    hr = lpPropData-&gt;lpVtbl-&gt;SetProps( <br>        lpPropData, <br>        sizeof(spv) / sizeof(SPropValue), <br>        spv, <br>        NULL); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        goto err; <br>    } <br> <br>    /* <br>    *   We mark these properties READONLY so that they can't be changed by <br>    *   the client. <br>    */ <br>    (void) lpPropData-&gt;lpVtbl-&gt;HrSetPropAccess(lpPropData, <br>                                (LPSPropTagArray) &amp;tagaABOOUSERAccess, <br>                                rgulABOOUSERAccess); <br> <br>    (void) lpPropData-&gt;lpVtbl-&gt;HrSetObjAccess(lpPropData, IPROP_READWRITE); <br> <br>    lpABOOUser-&gt;lpPropData = (LPMAPIPROP) lpPropData; <br> <br>    InitializeCriticalSection(&amp;lpABOOUser-&gt;cs); <br> <br>    /*  We must AddRef the lpABPLogon object since we will be using it <br>     */ <br>    lpABPLogon-&gt;lpVtbl-&gt;AddRef(lpABPLogon); <br> <br>    *lppMAPIPropEntry = (LPVOID) lpABOOUser; <br>    *lpulObjType = MAPI_MAILUSER; <br> <br>out: <br> <br>    DebugTraceResult(HrNewSampOOUser, hr); <br>    return hr; <br> <br>err: <br> <br>    if (lpPropData) <br>        lpPropData-&gt;lpVtbl-&gt;Release(lpPropData); <br> <br>    lpFreeBuff( lpABOOUser ); <br> <br>    goto out; <br>} <br> <br> <br>/************************************************************************* <br> * <br> -  ABOOUSER_OpenProperty <br> - <br> * <br> *  This is how we get the display table associated with this one-off's <br> *  details screen. <br> */ <br>STDMETHODIMP <br>ABOOUSER_OpenProperty( <br>    LPABOOUSER lpABOOUser, <br>    ULONG ulPropTag, <br>    LPCIID lpiid, <br>    ULONG ulInterfaceOptions, <br>    ULONG ulFlags, <br>    LPUNKNOWN * lppUnk) <br>{ <br> <br>    /* <br>     *  Since the default is that we do not support opening this <br>     *  object, we can initialize our hResult here. <br>     */ <br>    HRESULT hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    ABOOUSER_ValidateObject(OpenProperty, lpABOOUser); <br> <br>    Validate_IMAPIProp_OpenProperty(lpABOOUser, ulPropTag, lpiid, <br>                            ulInterfaceOptions, ulFlags, lppUnk); <br> <br> <br>    if (ulInterfaceOptions &amp; ~MAPI_UNICODE ) <br>    { <br>        /* <br>         *  Only UNICODE flag should be set for any of the objects that might <br>         *  be returned from this object. <br>         */ <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br>        goto ret; <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        goto ret; <br>    } <br>     <br> <br>     <br>    if (ulFlags &amp; MAPI_CREATE) <br>    { <br>        /* <br>         *  Don't support creating any sub-objects <br>         */ <br>        hResult = ResultFromScode(E_ACCESSDENIED); <br>        goto ret; <br>    } <br>     <br>     <br>    /*  Check to see if I need a display table*/ <br> <br>    if (ulPropTag == PR_DETAILS_TABLE) <br>    { <br>        /* Looking for the display table */ <br>        /* Check to see if they're expecting a table interface*/ <br> <br>        if (memcmp(lpiid, &amp;IID_IMAPITable, sizeof(IID))) <br>        { <br>            /* <br>             *  This provider will only export a table interface for <br>             *  PR_DETAILS_TABLE <br>             */ <br>            hResult = ResultFromScode(E_NOINTERFACE); <br>            goto ret; <br>        } <br> <br>        /* Create a display table */ <br> <br>        hResult = BuildDisplayTable( <br>            lpABOOUser-&gt;lpAllocBuff, <br>            lpABOOUser-&gt;lpAllocMore, <br>            lpABOOUser-&gt;lpFreeBuff, <br>            lpABOOUser-&gt;lpMalloc, <br>            lpABOOUser-&gt;hLibrary, <br>            sizeof(rgdtpage) / sizeof(DTPAGE), <br>            rgdtpage, <br>            0, <br>            (LPMAPITABLE *) lppUnk, <br>            NULL); <br> <br>        if (HR_FAILED(hResult)) <br>        { <br>            goto ret; <br>        } <br> <br>        /* <br>         * We're succeeding. Ensure our hResult is set properly (i.e. mask warnings) <br>         */ <br> <br>        hResult = hrSuccess; <br>    } <br> <br>ret: <br>    DebugTraceResult(ABOOUSER_OpenProperty, hResult); <br>    return hResult; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
