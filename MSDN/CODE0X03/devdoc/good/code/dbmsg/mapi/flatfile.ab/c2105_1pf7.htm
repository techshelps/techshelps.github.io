<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ABP.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2113"></a>ABP.H</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ABP.H <br> * <br> *  Definitions for Sample Address Book Provider <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br> <br>#ifdef _WIN32 <br>#define INC_OLE2                /* Get the OLE2 stuff */ <br>#define INC_RPC                 /* harmless on Windows NT; Windows 95 needs it */ <br>#endif <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;limits.h&gt; <br>#include &lt;mapiwin.h&gt; <br>#include &lt;mapidbg.h&gt; <br> <br>#include &lt;mapidefs.h&gt; <br>#include &lt;mapicode.h&gt; <br>#include &lt;mapitags.h&gt; <br>#include &lt;mapiguid.h&gt; <br>#include &lt;mapispi.h&gt; <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapival.h&gt; <br> <br>#include &lt;memory.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>/* <br> *  IUnknown base members <br> */ <br>#define SAB_IUnknown                    \ <br>    LONG                lcInit;         \ <br>    HRESULT             hResult;        \ <br>    UINT                idsLastError;   \ <br>    HINSTANCE           hLibrary;       \ <br>    LPALLOCATEBUFFER    lpAllocBuff;    \ <br>    LPALLOCATEMORE      lpAllocMore;    \ <br>    LPFREEBUFFER        lpFreeBuff;     \ <br>    LPMALLOC            lpMalloc;       \ <br>    CRITICAL_SECTION    cs <br> <br>#define SAB_IUnkWithLogon               \ <br>    SAB_IUnknown;                       \ <br>    LPABLOGON           lpABLogon <br> <br>#define SAB_Wrapped                     \ <br>    SAB_IUnkWithLogon;                  \ <br>    LPMAPIPROP          lpPropData <br> <br>/* <br> *  Definition of all the objects referred to in the various source modules <br> *  of this provider. <br> */ <br> <br>/* <br> *  Declaration of IABProvider object implementation <br> *  Code for this is in ABP.C <br> */ <br>#undef  INTERFACE <br>#define INTERFACE struct _ABP <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABP_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IABPROVIDER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABP_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IABPROVIDER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(ABP_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IABPROVIDER_METHODS(IMPL) <br>}; <br> <br> <br>/* <br> *  Declaration of IABLogon object implementation <br> *  Code for this is in ABP.C <br> */ <br>#undef  INTERFACE <br>#define INTERFACE struct _ABPLOGON <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABPLOGON_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IABLOGON_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABPLOGON_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IABLOGON_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(ABPLOGON_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IABLOGON_METHODS(IMPL) <br>}; <br> <br> <br>/* <br> *  Declaration of IABContainer object implementation <br> *  Code for this is in ROOT.C <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _ROOT <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ROOT_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPICONTAINER_METHODS(IMPL) <br>        MAPI_IABCONTAINER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ROOT_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPICONTAINER_METHODS(IMPL) <br>        MAPI_IABCONTAINER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(ROOT_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMAPICONTAINER_METHODS(IMPL) <br>    MAPI_IABCONTAINER_METHODS(IMPL) <br>}; <br> <br>#define ROOT_ValidateObject(Method, pThis)          \ <br>{                                                   \ <br>    HRESULT hResult;                                \ <br>    if (IsBadReadPtr(pThis, sizeof(ROOT)))          \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ROOT##_##Method, hResult); \ <br>        return hResult;                             \ <br>    }                                               \ <br>                                                    \ <br>    if (pThis-&gt;lpVtbl != &amp;vtblROOT)                 \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ROOT##_##Method, hResult); \ <br>        return hResult;                             \ <br>    }                                               \ <br>} <br> <br> <br> <br>/* <br> *  Declaration of IABContainer object implementation <br> *  Code for this is in ABCONT.C <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _ABCNT <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABC_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPICONTAINER_METHODS(IMPL) <br>        MAPI_IABCONTAINER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABC_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPICONTAINER_METHODS(IMPL) <br>        MAPI_IABCONTAINER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(ABC_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMAPICONTAINER_METHODS(IMPL) <br>    MAPI_IABCONTAINER_METHODS(IMPL) <br>}; <br> <br>#define ABC_ValidateObject(Method, pThis)           \ <br>{                                                   \ <br>    HRESULT hResult;                                \ <br>    if (IsBadReadPtr(pThis, sizeof(ABC)))           \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABC##_##Method, hResult);  \ <br>        return hResult;                             \ <br>    }                                               \ <br>                                                    \ <br>    if (pThis-&gt;lpVtbl != &amp;vtblABC)                  \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABC##_##Method, hResult);  \ <br>        return hResult;                             \ <br>    }                                               \ <br>} <br> <br> <br>/* <br> *  Declaration of IMAPIContainer object implementation <br> *  Code for this is in ABSEARCH.C <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _ABSRCH <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABSRCH_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPICONTAINER_METHODS(IMPL) <br>        MAPI_IABCONTAINER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABSRCH_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPICONTAINER_METHODS(IMPL) <br>        MAPI_IABCONTAINER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(ABSRCH_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMAPICONTAINER_METHODS(IMPL) <br>}; <br> <br>#define ABSRCH_ValidateObject(Method, pThis)        \ <br>{                                                   \ <br>    HRESULT hResult;                                \ <br>    if (IsBadReadPtr(pThis, sizeof(ABSRCH)))        \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABSRCH##_##Method, hResult);   \ <br>        return hResult;                             \ <br>    }                                               \ <br>                                                    \ <br>    if (pThis-&gt;lpVtbl != &amp;vtblABSRCH)                   \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABSRCH##_##Method, hResult);   \ <br>        return hResult;                             \ <br>    }                                               \ <br>} <br> <br> <br> <br>/* <br> *  Declaration of IMailUser object implementation <br> *  Code for this is in ABUSER.C <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _ABUSER <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABU_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAILUSER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABU_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAILUSER_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(ABU_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMAILUSER_METHODS(IMPL) <br>}; <br> <br>#define ABU_ValidateObject(Method, pThis)       \ <br>{                                                   \ <br>    HRESULT hResult;                                \ <br>    if (IsBadReadPtr(pThis, sizeof(ABUSER)))        \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABU##_##Method, hResult);  \ <br>        return hResult;                             \ <br>    }                                               \ <br>                                                    \ <br>    if (pThis-&gt;lpVtbl != &amp;vtblABU)                  \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABU##_##Method, hResult);  \ <br>        return hResult;                             \ <br>    }                                               \ <br>} <br> <br>/* <br> *  Declaration of IMAPIProp object implementation <br> *  Code for this is in WRAP.C <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _WRAP <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, WRAP_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, WRAP_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(WRAP_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>}; <br> <br> <br> <br>#undef  INTERFACE <br>#define INTERFACE   struct _IVTABC <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, IVTABC_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPITABLE_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, IVTABC_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPITABLE_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(IVTABC_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPITABLE_METHODS(IMPL) <br>}; <br> <br> <br>/* <br> *  Internal utility functions that allow access to data stored in the Init object <br> */ <br>void <br>RemoveLogonObject(LPABPROVIDER lpABProvider, LPVOID lpvABLogon, LPFREEBUFFER lpFreeBuff); <br> <br>void <br>FindLogonObject(LPABPROVIDER lpABProvider, LPMAPIUID lpMuidToFind, LPABLOGON * lppABLogon); <br> <br>/* <br> *  Internal utility functions that allow access to data stored in the logon object <br> */ <br> <br>LPMAPIUID <br>LpMuidFromLogon(LPABLOGON lpABLogon); <br> <br>HRESULT <br>HrLpszGetCurrentFileName(LPABLOGON lpABLogon, LPSTR * lppszFileName); <br> <br>HRESULT <br>HrReplaceCurrentFileName(LPABLOGON lpABLogon, LPSTR lpstrT); <br> <br>void <br>GenerateContainerDN(LPABLOGON lpABLogon, LPSTR lpszName); <br> <br>BOOL <br>FEqualSABFiles( LPABLOGON lpABLogon, <br>                LPSTR lpszFileName); <br> <br>/* <br> * <br> *  Functions that return new objects <br> * <br> */ <br> <br>/* <br> *  Creates a new ABPLogon object  (see ABLOGON.C) <br> */ <br>HRESULT <br>HrNewABLogon(   LPABLOGON *         lppABLogon, <br>                LPABPROVIDER        lpABP, <br>                LPMAPISUP           lpMAPISup, <br>                LPSTR               lpszSABFile, <br>                LPMAPIUID           lpmuid, <br>                HINSTANCE           hLibrary, <br>                LPALLOCATEBUFFER    lpAllocBuff, <br>                LPALLOCATEMORE      lpAllocMore, <br>                LPFREEBUFFER        lpFreeBuff, <br>                LPMALLOC            lpMalloc ); <br> <br>/* <br> *  Creates a new ROOT container object  (see ROOT.C) <br> */ <br>HRESULT <br>HrNewROOT(LPABCONT *        lppROOT, <br>          ULONG *           lpulObjType, <br>          LPABLOGON         lpABPLogon, <br>          LPCIID            lpInterface, <br>          HINSTANCE         hLibrary, <br>          LPALLOCATEBUFFER  lpAllocBuff, <br>          LPALLOCATEMORE    lpAllocMore, <br>          LPFREEBUFFER      lpFreeBuff, <br>          LPMALLOC          lpMalloc ); <br> <br>/* <br> *  Creates a new directory container object (see ABCONT.C) <br> */ <br>HRESULT  <br>HrNewSampDirectory( LPABCONT *          lppABC, <br>                    ULONG *             lpulObjType, <br>                    LPABLOGON           lpABPLogon, <br>                    LPCIID              lpInterface, <br>                    HINSTANCE           hLibrary, <br>                    LPALLOCATEBUFFER    lpAllocBuff, <br>                    LPALLOCATEMORE      lpAllocMore, <br>                    LPFREEBUFFER        lpFreeBuff, <br>                    LPMALLOC            lpMalloc ); <br> <br>/* <br> *  Creates the search object associated with the SampDirectory (see ABSEARCH.C) <br> */ <br>HRESULT <br>HrNewSearch(LPMAPICONTAINER *   lppABSearch, <br>            LPABLOGON           lpABLogon, <br>            LPCIID              lpInterface, <br>            HINSTANCE           hLibrary, <br>            LPALLOCATEBUFFER    lpAllocBuff, <br>            LPALLOCATEMORE      lpAllocMore, <br>            LPFREEBUFFER        lpFreeBuff, <br>            LPMALLOC            lpMalloc ); <br> <br>/* <br> *  Creates a new Mail User object  (see ABUSER.C) <br> */ <br>HRESULT <br>HrNewSampUser(  LPMAILUSER *        lppMAPIPropEntry, <br>                ULONG *             lpulObjectType, <br>                ULONG               cbEntryID, <br>                LPENTRYID           lpEntryID, <br>                LPABLOGON           lpABPLogon, <br>                LPCIID              lpInterface, <br>                HINSTANCE           hLibrary, <br>                LPALLOCATEBUFFER    lpAllocBuff, <br>                LPALLOCATEMORE      lpAllocMore, <br>                LPFREEBUFFER        lpFreeBuff, <br>                LPMALLOC            lpMalloc ); <br> <br>/* <br> *  Creates a new one-off templateID object (see TID.C) <br> */ <br>HRESULT  <br>HrNewOOTID( LPMAPIPROP *        lppMAPIPropNew, <br>            ULONG               cbTemplateId, <br>            LPENTRYID           lpTemplateId, <br>            ULONG               ulTemplateFlags, <br>            LPMAPIPROP          lpMAPIPropData, <br>            LPABLOGON           lpABPLogon, <br>            LPCIID              lpInterface, <br>            HINSTANCE           hLibrary, <br>            LPALLOCATEBUFFER    lpAllocBuff, <br>            LPALLOCATEMORE      lpAllocMore, <br>            LPFREEBUFFER        lpFreeBuff, <br>            LPMALLOC            lpMalloc ); <br> <br>/* <br> *  Creates a new one-off mail user object (see OOUSER.C) <br> */ <br>HRESULT <br>HrNewSampOOUser(LPMAILUSER *        lppMAPIPropEntry, <br>                ULONG *             lpulObjectType, <br>                ULONG               cbEntryID, <br>                LPENTRYID           lpEntryID, <br>                LPABLOGON           lpABPLogon, <br>                LPCIID              lpInterface, <br>                HINSTANCE           hLibrary, <br>                LPALLOCATEBUFFER    lpAllocBuff, <br>                LPALLOCATEMORE      lpAllocMore, <br>                LPFREEBUFFER        lpFreeBuff, <br>                LPMALLOC            lpMalloc ); <br> <br>/* <br> *  Creates a new status object for this provider (see STATUS.C) <br> */ <br>HRESULT  <br>HrNewStatusObject(LPMAPISTATUS *    lppABS, <br>                ULONG *             lpulObjType, <br>                ULONG               ulFlags, <br>                LPABLOGON           lpABPLogon, <br>                LPCIID              lpInterface, <br>                HINSTANCE           hLibrary, <br>                LPALLOCATEBUFFER    lpAllocBuff, <br>                LPALLOCATEMORE      lpAllocMore, <br>                LPFREEBUFFER        lpFreeBuff, <br>                LPMALLOC            lpMalloc ); <br> <br>/* <br> * Creates a new templateID object that's associated with <br> * a SAB mailuser object. <br> */ <br>HRESULT <br>HrNewTID (  LPMAPIPROP *        lppMAPIPropNew, <br>            ULONG               cbTemplateId, <br>            LPENTRYID           lpTemplateId, <br>            ULONG               ulTemplateFlags, <br>            LPMAPIPROP          lpMAPIPropData, <br>            LPABLOGON           lpABPLogon, <br>            LPCIID              lpInterface, <br>            HINSTANCE           hLibrary, <br>            LPALLOCATEBUFFER    lpAllocBuff, <br>            LPALLOCATEMORE      lpAllocMore, <br>            LPFREEBUFFER        lpFreeBuff, <br>            LPMALLOC            lpMalloc ); <br> <br> <br>/* <br> *  Creates a new contents table object <br> */ <br>HRESULT <br>HrNewIVTAbc (LPMAPITABLE *      lppIVTAbc, <br>             LPABLOGON          lpABLogon, <br>             LPABCONT           lpABC, <br>             HINSTANCE          hLibrary, <br>             LPALLOCATEBUFFER   lpAllocBuff, <br>             LPALLOCATEMORE     lpAllocMore, <br>             LPFREEBUFFER       lpFreeBuff, <br>             LPMALLOC           lpMalloc ); <br> <br>/* <br> *  Creates/Updates the SAB's root hierarchy <br> */ <br>HRESULT <br>HrBuildRootHier(LPABLOGON lpABLogon, LPMAPITABLE * lppMAPITable); <br> <br> <br>/* <br> *  Sets an error string associated with a particular hResult on an object. <br> *  It's used in conjunction with the method GetLastError. <br> */ <br>VOID SetErrorIDS (LPVOID lpObject, HRESULT hResult, UINT ids); <br> <br> <br>/* <br> *  Loads a string from a resource.  Optionally allocates room for the string <br> *  if lpAllocBuff is not NULL.  See ABP.C. <br> */ <br>SCODE ScLoadString( UINT                ids, <br>                    ULONG               ulcch, <br>                    LPALLOCATEBUFFER    lpAllocBuff, <br>                    HINSTANCE           hLibrary, <br>                    LPSTR *             lppsz); <br> <br>/* <br> *  The sample ABPs MAPIUID <br> * <br> *  This MAPIUID must be unique (see the Service Provider Writer's Guide on <br> *  Constructing Entry IDs) <br> */ <br>#define MUIDABSAMPLE {0x81,0x2b,0x1f,0x40,0xbe,0xa3,0x10,0x19,0x9d,0x6e,0x00,0xdd,0x01,0x0f,0x54,0x02} <br> <br>#define SZEMAILTYPE                         "MSPEER" <br>#define MAX_DISPLAY_NAME                    45 <br> <br>/* <br> *  Browse record <br> * <br> *  The .SAB files are made up of the following records. <br> */ <br> <br>#define MAX_NAME_SIZE   30 <br>#define MAX_EMA_SIZE    50 <br> <br>#pragma pack(4) <br>typedef struct _ABCREC <br>{ <br> <br>    char rgchDisplayName[MAX_NAME_SIZE + 1]; <br>    char rgchEmailAddress[MAX_EMA_SIZE + 1]; <br> <br>} ABCREC, *LPABCREC; <br>#pragma pack() <br> <br>/* <br> *  Defines of various entryid types <br> */ <br>#define SAMP_DIRECTORY  0x00000000 <br>#define SAMP_USER       0x00000001 <br>#define SAMP_UNKNOWN    0x00000002 <br>#define SAMP_OOUSER     0x00000003 <br> <br>/* <br> *  The version of this ABPs entryids <br> */ <br>#define SAMP_VERSION    0x000000002 <br> <br>/* <br> *  Directory entry id structure <br> * <br> *  This entryid is permanent. <br> */ <br>typedef struct _dir_entryid <br>{ <br> <br>    BYTE abFlags[4]; <br>    MAPIUID muid; <br>    ULONG ulVersion; <br>    ULONG ulType; <br>    MAPIUID muidID; <br> <br>} DIR_ENTRYID, *LPDIR_ENTRYID; <br> <br>/* <br> *  Mail user entry id structure <br> * <br> *  This entryid is permanent. <br> */ <br>#pragma pack(4) <br>typedef struct _usr_entryid <br>{ <br> <br>    BYTE abFlags[4]; <br>    MAPIUID muid; <br>    ULONG ulVersion; <br>    ULONG ulType; <br>    ABCREC abcrec; <br> <br>} USR_ENTRYID, *LPUSR_ENTRYID; <br>#pragma pack() <br> <br>/* <br> *  One off user entry id structure <br> * <br> *  This entryid is permanent. <br> */ <br>typedef struct _oousr_entryid <br>{ <br>    BYTE abFlags[4]; <br>    MAPIUID muid; <br>    ULONG ulVersion; <br>    ULONG ulType; <br> <br>} OOUSR_ENTRYID, *LPOOUSR_ENTRYID; <br> <br> <br>/* <br> *  Externs used throughout various modules within this provider. <br> *  They actually get defined in abp.c <br> */ <br> <br>extern LCID lcidUser; <br> <br>extern MAPIUID muidABSample; <br> <br>extern MAPIUID muidSABProviderID; <br> <br>extern DTBLLABEL dtbllabel; <br> <br>extern DTBLPAGE dtblpage; <br> <br>extern DTBLGROUPBOX dtblgroupbox; <br> <br>extern CHAR szNoFilter[]; <br> <br>extern LPSTR lpszEMT; <br> <br>extern CHAR szAddrTypeFilter[]; <br> <br>extern CHAR szFileNameFilter[]; <br> <br>#define PR_LISTBOX_TABLE                PROP_TAG(PT_OBJECT,0x6605) <br>#define PR_COMBOBOX_TABLE               PROP_TAG(PT_OBJECT,0x6607) <br>#define PR_DDLISTBOX_TABLE              PROP_TAG(PT_OBJECT,0x6609) <br> <br> <br>/* <br> *  Properties defined for our one-off entry <br> */ <br>#define     PR_SERVER_NAME              PROP_TAG(PT_TSTRING,0x660b) <br>#define     PR_SHARE_NAME               PROP_TAG(PT_TSTRING,0x660c) <br>#define     PR_PATH_NAME                PROP_TAG(PT_TSTRING,0x660d) <br> <br>#define MAX_SERVER_NAME                 15 <br>#define MAX_SHARE_NAME                  12 <br> <br>/* <br> *  MACROs for Win16 <br> */ <br> <br>#ifdef WIN16 <br> <br> <br>#define lstrcatA        lstrcat <br>#define wsprintfA       wsprintf <br>#define CharUpperBuffA  CharUpperBuff <br> <br>#endif /*WIN16*/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
