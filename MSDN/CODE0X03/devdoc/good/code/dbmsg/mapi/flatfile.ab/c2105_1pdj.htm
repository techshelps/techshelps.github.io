<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ABCTBL1.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2107"></a>ABCTBL1.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ABCTBL1.C <br> * <br> *  Contents Table <br> * <br> *  The contents table associated with this provider.  It's file based. <br> *  The format of the .SAB file is in ABP.H. <br> * <br> *  This implementation of IMAPITable is retrieved by calling the <br> *  GetContentsTable() method of the sample ABP's single directory (see <br> *  abcont.c). <br> * <br> *  There are a few interesting features in this implementation.  First <br> *  it's implemented on a flat file (.SAB).  Second, it actually supports <br> *  an implementation of ANR (Ambiguous Name Resolution).  And lastly, it <br> *  supports FindRow (limited to prefix searching on display names). <br> * <br> *  This is the minimum set of restrictions that your provider MUST support. <br> *  It MUST have an ANR implementation and support prefix (downward) searching <br> *  on whatever your table is sorted on (in this case PR_DISPLAY_NAME). <br> * <br> *  The browsing of a flat file is done a record at a time.  It's never <br> *  completely read into memory.  It only reads records from the file when <br> *  it absolutely has to (like in QueryRows).  The advantage to this is <br> *  a low memory footprint and the ability to browse rather large files <br> *  with decent performance. <br> */ <br>/* <br> *  ANR is also supported in this implementation.  In the code will often <br> *  be 'if' statements making two different code paths between the restricted <br> *  and unrestricted version.  The restrictions rely on a couple of <br> *  bit arrays.  Each bit corresponds (in order) to the records in the .SAB <br> *  file.  One bit array, rgChecked, says whether or not a record in the <br> *  .SAB file has actually been compared to the restriction.  It's initially <br> *  set to all 0s - which means that none of the records have been checked. <br> *  The second bit array, rgMatched, says whether or not the particular <br> *  record matches the current restriction.  This array is initialized to all <br> *  1s - which says that all the records in the .SAB file match the current <br> *  restriction.  The reason for this is for the fraction returned in <br> *  QueryPosition--By assuming that all the rows match and only updating <br> *  the array when something doesn't match, the fraction returned in <br> *  QueryPosition will get larger and has the effect of making the thumb-bar <br> *  on a listbox implemented on top of this table to scroll down as you go <br> *  down the list. <br> * <br> *  As a row is about to be read it is checked to see if it's been compared <br> *  to the current restriction.  If it has then to determine whether or not <br> *  to actually read the record and build the row we just look at the matched <br> *  bit array.  If it doesn't match we go on to the next record and check <br> *  again.  If it does match we read the record and build the row. <br> * <br> *  Only if it hasn't been checked do we actually go and read the row and <br> *  compare it to the current restriction, setting the rgChecked and <br> *  rgMatched bits accordingly. <br> * <br> *  In this implementation the ANR comparison rules are as follows: <br> *  (See FNameMatch for the actual code to do this) <br> * <br> *    A 'word' is defined as any substring separated by separators. <br> *    The separators are defined as ',', ' ', and '-'. <br> *    A restriction is said to match a display name iff all the words <br> *    in the restriction are all prefixes of words in the display name. <br> * <br> *    For example, a restriction of "b d" will match: <br> *     "Barney Donovan" <br> *     "Donovan, Barney" <br> *     "Danielle Blumenthal" <br> *    But will not match: <br> *     "Darby Opal" <br> *     "Ben Masters" <br> * <br> *  Other providers can do whatever matching they want with the ANR <br> *  restriction.  For example, soundex or additional field comparisons (like <br> *  email addresses).  A good (and fast) implementation will differentiate <br> *  your provider from others in a positive way. <br> * <br> *  FindRow's implementation effectively handles prefix searching on display <br> *  names (PR_DISPLAY_NAME).  It does this by binary searching the .SAB file. <br> *  The only tricky part is knowing when to stop.  Basically you want to stop <br> *  on the first name in the list that matches the restriction.  It's easy to <br> *  do linearly, but a little more trick with a binary search.  This <br> *  implementation is a reasonable example. <br> * <br> * <br> *  This table has only the following columns: <br> */ <br> <br>#include "abp.h" <br>#include "abctbl.h" <br>#include "sampabp.rh" <br> <br>const SizedSPropTagArray(cvalvtMax, tagaivtabcColSet) = <br>{ <br>    cvalvtMax, <br>    { <br>        PR_DISPLAY_NAME_A, <br>        PR_ENTRYID, <br>        PR_ADDRTYPE_A, <br>        PR_EMAIL_ADDRESS_A, <br>        PR_OBJECT_TYPE, <br>        PR_DISPLAY_TYPE, <br>        PR_INSTANCE_KEY <br>    } <br>}; <br>const LPSPropTagArray ptagaivtabcColSet = (LPSPropTagArray) &amp;tagaivtabcColSet; <br> <br>/* <br> * <br> *  The following routines are implemented in the files abctbl2.c and abctbl3.c: <br> * <br> * <br> *      IVTABC_Release <br> *      IVTABC_GetStatus <br> *      IVTABC_SetColumns <br> *      IVTABC_QueryColumns <br> *      IVTABC_GetRowCount <br> *      IVTABC_SeekRow <br> *      IVTABC_SeekRowApprox <br> *      IVTABC_QueryPosition <br> *      IVTABC_FindRow <br> *      IVTABC_Restrict <br> *      IVTABC_CreateBookmark <br> *      IVTABC_FreeBookmark <br> *      IVTABC_SortTable <br> *      IVTABC_QuerySortOrder <br> *      IVTABC_QueryRows <br> *      IVTABC_Abort <br> *      IVTABC_ExpandRow <br> *      IVTABC_CollapseRow <br> *      IVTABC_WaitForCompletion <br> *      IVTABC_GetCollapseState <br> *      IVTABC_SetCollapseState <br> * <br> * <br> *  This file (abctbl1.c) has all the utility functions used throughout this <br> *  objects methods.  They are the following: <br> * <br> *      HrNewIVTAbc() <br> *      HrValidateEntry() <br> *      FChecked() <br> *      FMatched() <br> *      FNameMatch() <br> *      HrOpenFile() <br> *      fIVTAbcIdleRoutine() <br> *      FreeANRBitmaps() <br> * <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br>/* <br> *  vtbl filled in here. <br> */ <br> <br>const IVTABC_Vtbl vtblIVTABC = <br>{ <br> <br>    IVTABC_QueryInterface, <br>    (IVTABC_AddRef_METHOD *)        ROOT_AddRef, <br>    IVTABC_Release, <br>    (IVTABC_GetLastError_METHOD *)  ROOT_GetLastError, <br>    IVTABC_Advise, <br>    IVTABC_Unadvise, <br>    IVTABC_GetStatus, <br>    IVTABC_SetColumns, <br>    IVTABC_QueryColumns, <br>    IVTABC_GetRowCount, <br>    IVTABC_SeekRow, <br>    IVTABC_SeekRowApprox, <br>    IVTABC_QueryPosition, <br>    IVTABC_FindRow, <br>    IVTABC_Restrict, <br>    IVTABC_CreateBookmark, <br>    IVTABC_FreeBookmark, <br>    IVTABC_SortTable, <br>    IVTABC_QuerySortOrder, <br>    IVTABC_QueryRows, <br>    IVTABC_Abort, <br>    IVTABC_ExpandRow, <br>    IVTABC_CollapseRow, <br>    IVTABC_WaitForCompletion, <br>    IVTABC_GetCollapseState, <br>    IVTABC_SetCollapseState <br>}; <br> <br> <br>/* Idle function */ <br>FNIDLE fIVTAbcIdleRoutine; <br> <br>#define     IVTABC_IDLE_INTERVAL        300L <br>#define     IVTABC_IDLE_PRIORITY        -2 <br>#define     IVTABC_IDLE_FLAGS           FIROINTERVAL <br> <br>/************************************************************************* <br> * <br> -  NewIVTAbc <br> - <br> *  Creates a new IMAPITable on the contents of a .SAB file. <br> * <br> * <br> */ <br>HRESULT  <br>HrNewIVTAbc(LPMAPITABLE *       lppIVTAbc, <br>            LPABLOGON           lpABLogon, <br>            LPABCONT            lpABC, <br>            HINSTANCE           hLibrary, <br>            LPALLOCATEBUFFER    lpAllocBuff, <br>            LPALLOCATEMORE      lpAllocMore, <br>            LPFREEBUFFER        lpFreeBuff, <br>            LPMALLOC            lpMalloc ) <br>{ <br>    LPIVTABC lpIVTAbc = NULL; <br>    SCODE scode; <br>    HRESULT hResult = hrSuccess; <br>    ULONG ulBK, ulSize, ulSizeHigh; <br> <br>    /* <br>     *  Allocate space for the IVTABC structure <br>     */ <br> <br>    scode = lpAllocBuff(sizeof(IVTABC), (LPVOID *) &amp;lpIVTAbc); <br>    if (FAILED(scode)) <br>    { <br>        hResult = ResultFromScode(scode); <br>        goto err; <br>    } <br> <br>    lpIVTAbc-&gt;lpVtbl = &amp;vtblIVTABC; <br>    lpIVTAbc-&gt;lcInit = 1; <br>    lpIVTAbc-&gt;hResult = hrSuccess; <br>    lpIVTAbc-&gt;idsLastError = 0; <br> <br>    lpIVTAbc-&gt;hLibrary = hLibrary; <br>    lpIVTAbc-&gt;lpAllocBuff = lpAllocBuff; <br>    lpIVTAbc-&gt;lpAllocMore = lpAllocMore; <br>    lpIVTAbc-&gt;lpFreeBuff = lpFreeBuff; <br>    lpIVTAbc-&gt;lpMalloc = lpMalloc; <br>    lpIVTAbc-&gt;lpABLogon = lpABLogon; <br> <br>    lpIVTAbc-&gt;lpszFileName = NULL; <br>    hResult = HrLpszGetCurrentFileName(lpABLogon, &amp;(lpIVTAbc-&gt;lpszFileName)); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto err; <br>    } <br> <br>    lpIVTAbc-&gt;lpPTAColSet = (LPSPropTagArray) &amp;tagaivtabcColSet; <br> <br>    /* <br>     *  Open the .SAB file associated with this logged in session. <br>     *  Currently it's opened with FILE_SHARED_READ.  This has an <br>     *  unpleasant side-effect of not being able to modify the .SAB <br>     *  file while this table is active. <br>     * <br>     *  It should be OF_SHARE_DENY_NONE.  I don't have the code to <br>     *  handle this in this version. <br>     */ <br>    if ((lpIVTAbc-&gt;hFile = CreateFile( <br>                lpIVTAbc-&gt;lpszFileName, <br>                GENERIC_READ, <br>                FILE_SHARE_READ|FILE_SHARE_WRITE, <br>                NULL, <br>                OPEN_EXISTING, <br>                FILE_ATTRIBUTE_NORMAL, <br>                NULL)) == INVALID_HANDLE_VALUE) <br>    { <br>        /* <br>         *  The file didn't open... <br>         */ <br> <br>        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>        SetErrorIDS(lpABC, hResult, IDS_CANT_OPEN_SAB); <br> <br>        goto err; <br>    } <br> <br>    /* <br>     *  Get the time and date stamp <br>     * <br>     */ <br>    (void)GetFileTime(lpIVTAbc-&gt;hFile, NULL, NULL, &amp;(lpIVTAbc-&gt;filetime)); <br> <br>    /*  Get the size of the file */ <br>    if ((ulSize = GetFileSize(lpIVTAbc-&gt;hFile, &amp;ulSizeHigh)) == 0xFFFFFFFF) <br>    { <br>        /* <br>         *  MAYBE I have an error <br>         */ <br>        if (GetLastError() != NO_ERROR) <br>        { <br>            hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>            SetErrorIDS(lpABC, hResult, IDS_SAB_FILE_ATTRIB); <br>            goto err; <br>        } <br> <br>        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>        SetErrorIDS(lpABC, hResult, IDS_SAB_TOO_LARGE); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Actual number of valid positions <br>     */ <br>    lpIVTAbc-&gt;ulMaxPos = (ulSize / sizeof(ABCREC)); <br> <br>    /* <br>     *  Check to see if it's an exact multiple of sizeof(ABCREC) <br>     */ <br>    if (lpIVTAbc-&gt;ulMaxPos * sizeof(ABCREC) != ulSize) <br>    { <br>        /* <br>         *  Nope. <br>         */ <br> <br>        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>        SetErrorIDS(lpABC, hResult, IDS_SAB_CORRUPT); <br>        goto err; <br>    } <br> <br>    lpIVTAbc-&gt;ulPosition = 0; <br> <br>    /*  Setup bookmarks  */ <br>    for (ulBK = 0; ulBK &lt; MAX_BOOKMARKS; lpIVTAbc-&gt;rglpABCBK[ulBK++] = NULL); <br> <br>    /* <br>     *  Restriction stuff <br>     */ <br> <br>    lpIVTAbc-&gt;rgChecked = NULL; <br>    lpIVTAbc-&gt;rgMatched = NULL; <br>    lpIVTAbc-&gt;lpszPartialName = NULL; <br> <br>    /* <br>     *  Registered notification stuff <br>     */ <br> <br>    lpIVTAbc-&gt;cAdvise = 0; <br>    lpIVTAbc-&gt;parglpAdvise = NULL; <br>    lpIVTAbc-&gt;ulConnectMic = (ULONG) lpIVTAbc &amp; 0xffffff; <br>    InitializeCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    /* <br>     *  Register the idle function <br>     */ <br> <br>    lpIVTAbc-&gt;ftg = FtgRegisterIdleRoutine( <br>        fIVTAbcIdleRoutine, <br>        lpIVTAbc, <br>        IVTABC_IDLE_PRIORITY, <br>        IVTABC_IDLE_INTERVAL, <br>        IVTABC_IDLE_FLAGS); <br> <br>    InitializeCriticalSection(&amp;lpIVTAbc-&gt;cs); <br> <br>    /*  We must AddRef the lpABLogon object since we will be using it <br>     */ <br>    lpABLogon-&gt;lpVtbl-&gt;AddRef(lpABLogon); <br> <br>    *lppIVTAbc = (LPVOID) lpIVTAbc; <br> <br>out: <br> <br>         <br>    DebugTraceResult(HrNewIVTAbc, hResult); <br>    return hResult; <br> <br>err: <br>    if (lpIVTAbc) <br>    { <br>        if (lpIVTAbc-&gt;hFile != INVALID_HANDLE_VALUE) <br>        { <br>            /* <br>             *  Must've opened the file <br>             */ <br>            CloseHandle(lpIVTAbc-&gt;hFile); <br>        } <br> <br>        /*  Free the current .SAB file name */ <br>        lpFreeBuff(lpIVTAbc-&gt;lpszFileName); <br> <br>        /*  Free the mem */ <br>        lpFreeBuff( lpIVTAbc ); <br>    } <br> <br>    goto out; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  HrValidateEntry <br> - <br> * <br> *  Used in restricted lists <br> *  Checks to see if a given entry at a particular location matches <br> *  the active restriction.  It always modifies rgChecked, and may <br> *  modify rgMatched. <br> */ <br>HRESULT  <br>HrValidateEntry(LPIVTABC lpIVTAbc, ULONG ulNewPos) <br>{ <br>    ABCREC abcrec; <br>    ULONG cbRead; <br>    HRESULT hResult; <br> <br>    /* <br>     *  Open the file <br>     */ <br>    hResult = HrOpenFile(lpIVTAbc); <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTraceResult(HrValidateEntry, hResult); <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Set the file position to lNewPos <br>     */ <br> <br>    (void) SetFilePointer(lpIVTAbc-&gt;hFile, ulNewPos * sizeof(ABCREC), <br>                          NULL, FILE_BEGIN); <br> <br>    /* <br>     *  Read in the record from the file <br>     */ <br>    if (!ReadFile(lpIVTAbc-&gt;hFile, (LPVOID) &amp;abcrec, <br>            sizeof(ABCREC), &amp;cbRead, NULL)) <br>    { <br>        DebugTraceSc(HrValidateEntry, MAPI_E_DISK_ERROR); <br>        return ResultFromScode(MAPI_E_DISK_ERROR); <br>    } <br> <br>    /*  Second check  */ <br>    if (cbRead != sizeof(ABCREC)) <br>    { <br>        DebugTraceSc(HrValidateEntry, MAPI_E_DISK_ERROR); <br>        return ResultFromScode(MAPI_E_DISK_ERROR); <br>    } <br> <br>    /* <br>     *  Always set the Checked flag <br>     */ <br>    lpIVTAbc-&gt;rgChecked[ulNewPos / 8] |= (((unsigned char)0x80) &gt;&gt; (ulNewPos % 8)); <br> <br>    /* <br>     *  See if the rgchDisplayName matches the restriction <br>     */ <br>    if (!FNameMatch(lpIVTAbc, abcrec.rgchDisplayName)) <br>    { <br>        /* <br>         *  Apparently not.  Reset the Matched flag <br>         */ <br> <br>        lpIVTAbc-&gt;ulRstrDenom--; <br> <br>        lpIVTAbc-&gt;rgMatched[ulNewPos / 8] &amp;= ~(((unsigned char)0x80) &gt;&gt; (ulNewPos % 8)); <br>    } <br> <br>    return hrSuccess; <br>} <br> <br>/************************************************************************* <br> * <br> -  FChecked <br> - <br> * <br> *  Returns whether or not an entry has ever been checked <br> *  Just looks at the bit in the rgChecked array that corresponds with <br> *  lNewPos <br> * <br> */ <br>BOOL <br>FChecked(LPIVTABC lpIVTAbc, ULONG ulNewPos) <br>{ <br>    ULONG ulT = (ULONG) (lpIVTAbc-&gt;rgChecked[ulNewPos / 8] &amp; (((unsigned char)0x80) &gt;&gt; (ulNewPos % 8))); <br> <br>    return (BOOL) !!ulT; <br>} <br> <br>/************************************************************************* <br> * <br> -  FMatched <br> - <br> * <br> *  Returns whether or not an entry has been matched <br> *  Just checks the bit in the rgMatched array corresponding with <br> *  lNewPos <br> * <br> */ <br>BOOL <br>FMatched(LPIVTABC lpIVTAbc, ULONG ulNewPos) <br>{ <br>    ULONG ulT = (lpIVTAbc-&gt;rgMatched[ulNewPos / 8] &amp; (((unsigned char)0x80) &gt;&gt; (ulNewPos % 8))); <br> <br>    return (BOOL) !!ulT; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  FNameMatch <br> - <br> *  Tries to match the rgchDisplayName with the partial name of the <br> *  restriction. <br> *  It tries to prefix match each partial name component (i.e. word) with <br> *  each rgchDisplayName name component (i.e. word).  Only if all of them <br> *  match (from the partial name) does this return TRUE. <br> */ <br>BOOL <br>FCharInString(LPSTR lpsz, CHAR ch); <br> <br> <br>BOOL <br>FNameMatch(LPIVTABC lpIVTAbc, LPSTR rgchDisplayName) <br>{ <br>    LPSTR szANRSep = ", -"; <br>    LPSTR szANR = lpIVTAbc-&gt;lpszPartialName; <br>    LPSTR pchEndSzANR = szANR + lstrlenA(szANR); <br>    ULONG cchANRName; <br>    ULONG cchFullNameName; <br>    LPSTR szFullNameT; <br>    LPSTR szT; <br> <br>    /*  If someone tries to match more than an iwMOMax-part name, the function <br>     *  will return fFalse.  But then if someone is trying to match a name <br>     *  with iwMOMax parts, chances are they weren't going to get it right <br>     *  anyway.... <br>     */ <br> <br>#define iwMOMax 50 <br> <br>    WORD rgwMO[iwMOMax]; <br>    int iwMOMac = 0; <br> <br>    while (TRUE) <br>    { <br>        /*  Find the end of the partial name we're pointing at  */ <br> <br>        szT = szANR; <br>        while (!FCharInString(szANRSep, *szT)) <br>            ++szT; <br>        cchANRName = szT - szANR; <br> <br>        /*  Check if it matches any name in the full name  */ <br> <br>        szFullNameT = rgchDisplayName; <br>        while (TRUE) <br>        { <br>            szT = szFullNameT; <br> <br>            /*  Find the length of the name in the full name  */ <br>            /*  we're checking against.                       */ <br> <br>            while (!FCharInString(szANRSep, *szT)) <br>                ++szT; <br>            cchFullNameName = szT - szFullNameT; <br> <br>            if (cchANRName &lt;= cchFullNameName &amp;&amp; <br>                CompareStringA( lcidUser, <br>                                NORM_IGNORECASE, <br>                                szANR, <br>                                (int) cchANRName, <br>                                szFullNameT, <br>                                (int) cchANRName) == 2 ) <br>            { <br>                int iwMO; <br> <br>                for (iwMO = 0; iwMO &lt; iwMOMac; iwMO++) <br>                    if (rgwMO[iwMO] == (WORD) (szFullNameT - rgchDisplayName)) <br>                        break; <br> <br>                /*  We found the partial name so check the next ANR part */ <br>                if (iwMO == iwMOMac) <br>                { <br>                    if (iwMOMac == iwMOMax - 1) <br>                    { <br>                        /*  If some user wants to match an iwMOMax part <br>                         *  name, chances are it wasn't going to match <br>                         *  anyway... <br>                         */ <br>                        return FALSE; <br>                    } <br>                    rgwMO[iwMOMac++] = szFullNameT - rgchDisplayName; <br>                    break; <br>                } <br>            } <br> <br>            /*  We didn't find the partial name this time around, so <br>             *  try to check the next name in the full name. <br>             */ <br> <br>            szFullNameT += cchFullNameName; <br> <br>            while (*szFullNameT &amp;&amp; FCharInString(szANRSep, *szFullNameT)) <br>                ++szFullNameT; <br> <br>            if (*szFullNameT == '\0') <br>                return FALSE;   /*  We never found the partial name. */ <br>        } <br> <br>        /* We found the partial name, so check the next ANR part */ <br> <br>        szANR += cchANRName; <br>        while (*szANR &amp;&amp; FCharInString(szANRSep, *szANR)) <br>            ++szANR; <br> <br>        if (*szANR == '\0') <br>            return TRUE;        /* No more ANR to check, so we found `em all  */ <br>    } <br> <br>    /*  Not reached (we hope...)  */ <br>    return FALSE; <br>} <br> <br>/* <br> -  HrOpenFile <br> - <br> *  Opens the .SAB file associated with the table and <br> *  checks whether the .SAB file has changed. <br> *  If it has changed, the table bookmarks and ANR bitmaps <br> *  are updated and everyone on the advise list is notified. <br> */ <br>HRESULT  <br>HrOpenFile(LPIVTABC lpIVTAbc) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    FILETIME filetime; <br>    ULONG ulSize, ulSizeHigh, ulMaxPos; <br>    LPSTR lpszFileName = NULL; <br> <br>    /* <br>     *  If file is not open, open it <br>     */ <br>    if (lpIVTAbc-&gt;hFile == INVALID_HANDLE_VALUE) <br>    { <br> <br>        if (!FEqualSABFiles(lpIVTAbc-&gt;lpABLogon, lpIVTAbc-&gt;lpszFileName)) <br>        { <br>            /* <br>             *  Get the new file name <br>             */ <br>            hResult = HrLpszGetCurrentFileName(lpIVTAbc-&gt;lpABLogon, &amp;lpszFileName); <br>            if (HR_FAILED(hResult)) <br>            { <br>                goto err; <br>            } <br> <br>            /* <br>             *  Replace the old one with this <br>             */ <br>            lpIVTAbc-&gt;lpFreeBuff(lpIVTAbc-&gt;lpszFileName); <br>            lpIVTAbc-&gt;lpszFileName = lpszFileName; <br> <br>            lpszFileName = NULL; <br>        } <br> <br>         <br>        /* <br>         *  File is not open so lets try to open it <br>         */ <br>        lpIVTAbc-&gt;hFile = CreateFile( <br>            lpIVTAbc-&gt;lpszFileName, <br>            GENERIC_READ, <br>            FILE_SHARE_READ|FILE_SHARE_WRITE, <br>            NULL, <br>            OPEN_EXISTING, <br>            FILE_ATTRIBUTE_NORMAL, <br>            NULL); <br> <br>        if (lpIVTAbc-&gt;hFile == INVALID_HANDLE_VALUE) <br>        { <br>            /* <br>             *  The file didn't open... <br>             */ <br>            hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>            SetErrorIDS(lpIVTAbc, hResult, IDS_CANT_OPEN_SAB_FILE); <br>            goto err; <br>        } <br>    } <br> <br>    /* <br>     *  Get the time and date stamp <br>     */ <br>    if (!GetFileTime(lpIVTAbc-&gt;hFile, NULL, NULL, &amp;filetime)) <br>    { <br>        if (GetLastError() != NO_ERROR) <br>        { <br>            hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>            SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_FILE_ATTRIB); <br>        } <br> <br>        goto err; <br>    } <br> <br>    /*  Get the size of the file */ <br>    if ((ulSize = GetFileSize(lpIVTAbc-&gt;hFile, &amp;ulSizeHigh)) == 0xFFFFFFFF) <br>    { <br>        /* <br>         *  MAYBE I have an error <br>         */ <br>        if (GetLastError() != NO_ERROR) <br>        { <br>            hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>            SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_FILE_ATTRIB); <br>            goto err; <br>        } <br> <br>        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>        SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_TOO_LARGE); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Actual number of valid positions <br>     */ <br>    ulMaxPos = (ulSize / sizeof(ABCREC)); <br> <br>    /* <br>     *  Check to see if it's an exact multiple of sizeof(ABCREC) <br>     */ <br>    if (ulMaxPos * sizeof(ABCREC) != ulSize) <br>    { <br>        hResult = ResultFromScode(MAPI_E_UNABLE_TO_COMPLETE); <br>        SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_CORRUPT); <br>        goto err; <br>    } <br> <br>    /* <br>     *  if the file has changed set new position, reset bookmarks etc and <br>     *  notify everybody one the advise list <br>     */ <br>    if (CompareFileTime(&amp;filetime, &amp;lpIVTAbc-&gt;filetime) || ulMaxPos != lpIVTAbc-&gt;ulMaxPos) <br>    { <br>        ULONG ulBK; <br>        ABCREC abcrec; <br>        ULONG cbT; <br>        LPMAPIADVISESINK *ppadvise; <br>        ULONG cAdvises; <br>        NOTIFICATION notif; <br> <br>        /* save new max position and filetime */ <br>        lpIVTAbc-&gt;filetime = filetime; <br>        lpIVTAbc-&gt;ulMaxPos = ulMaxPos; <br> <br>        /* if current position is past the end of file set it to the end */ <br>        if (lpIVTAbc-&gt;ulPosition &gt; lpIVTAbc-&gt;ulMaxPos) <br>            lpIVTAbc-&gt;ulPosition = lpIVTAbc-&gt;ulMaxPos; <br> <br>        if (ulMaxPos) <br>        { <br>            SetFilePointer(lpIVTAbc-&gt;hFile, (ulMaxPos - 1)*sizeof(ABCREC), NULL, FILE_BEGIN); <br> <br>            /*  Read in the record at that location  */ <br>            if (!ReadFile(lpIVTAbc-&gt;hFile, (LPVOID) &amp;abcrec, <br>                    sizeof(ABCREC), &amp;cbT, NULL)) <br>            { <br>                hResult = ResultFromScode(MAPI_E_DISK_ERROR); <br>                SetErrorIDS(lpIVTAbc, hResult, IDS_SAB_NO_READ); <br> <br>                goto err; <br>            } <br> <br>            /* if any of the bookmarks are past the end of file <br>             * set the file time to current file time, the position to last <br>             * record and record to last record <br>             */ <br>            for (ulBK = 0; ulBK &lt; MAX_BOOKMARKS; ulBK++) <br>                if (lpIVTAbc-&gt;rglpABCBK[ulBK] &amp;&amp; <br>                    lpIVTAbc-&gt;rglpABCBK[ulBK]-&gt;ulPosition &gt; lpIVTAbc-&gt;ulMaxPos) <br>                { <br>                    lpIVTAbc-&gt;rglpABCBK[ulBK]-&gt;ulPosition = ulMaxPos - 1; <br>                    lpIVTAbc-&gt;rglpABCBK[ulBK]-&gt;filetime = filetime; <br>                    lpIVTAbc-&gt;rglpABCBK[ulBK]-&gt;abcrec = abcrec; <br>                } <br> <br>            /* <br>            *  Reallocate the checked&amp;matched arrays <br>            */ <br> <br>            cbT = (lpIVTAbc-&gt;ulMaxPos) / 8 + 1; /* Number of bytes in both arrays */ <br> <br>            /* Reallocate ANR bitmaps */ <br>            if (lpIVTAbc-&gt;rgChecked) <br>            { <br>                lpIVTAbc-&gt;rgChecked = lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Realloc( <br>                    lpIVTAbc-&gt;lpMalloc, <br>                    lpIVTAbc-&gt;rgChecked, <br>                    cbT); <br>            } <br> <br>            if (lpIVTAbc-&gt;rgMatched) <br>            { <br>                lpIVTAbc-&gt;rgMatched = lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Realloc( <br>                    lpIVTAbc-&gt;lpMalloc, <br>                    lpIVTAbc-&gt;rgMatched, <br>                    cbT); <br>            } <br>        } <br>        else <br>        { <br>            /* if any of the bookmarks are past the end of file <br>             * set the file time to current file time, the position to the <br>             * beginning of the file. <br>             */ <br>            for (ulBK = 0; ulBK &lt; MAX_BOOKMARKS; ulBK++) <br>                if (lpIVTAbc-&gt;rglpABCBK[ulBK] &amp;&amp; <br>                    lpIVTAbc-&gt;rglpABCBK[ulBK]-&gt;ulPosition &gt; lpIVTAbc-&gt;ulMaxPos) <br>                { <br>                    lpIVTAbc-&gt;rglpABCBK[ulBK]-&gt;ulPosition = 0; <br>                    lpIVTAbc-&gt;rglpABCBK[ulBK]-&gt;filetime = filetime; <br>                } <br> <br>            /* free the ANR bitmaps */ <br>            FreeANRBitmaps(lpIVTAbc); <br>        } <br> <br>        /* initialize the notification */ <br>        ZeroMemory(&amp;notif, sizeof(NOTIFICATION)); <br>        notif.ulEventType = fnevTableModified; <br>        notif.info.tab.ulTableEvent = TABLE_RELOAD; <br> <br>        /* notify everyone that the table has changed */ <br>        for (ppadvise = lpIVTAbc-&gt;parglpAdvise, cAdvises = 0; <br>            cAdvises &lt; lpIVTAbc-&gt;cAdvise; <br>            ++ppadvise, ++cAdvises) <br>        { <br>            Assert(*ppadvise); <br>            if (ppadvise) <br>                (void)(*ppadvise)-&gt;lpVtbl-&gt;OnNotify(*ppadvise, 1, &amp;notif); <br>        } <br>    } <br> <br>out: <br> <br>    DebugTraceResult(NewIVTAbc, hResult); <br>    return hResult; <br>err: <br>    lpIVTAbc-&gt;lpFreeBuff(lpszFileName); <br> <br>    goto out; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  fIVTAbcIdleRoutine <br> - <br> *  This function called during idle time closes the .SAB file and notifies <br> *  everyone on the advise list if the file name has changed <br> * <br> */ <br> <br>BOOL STDAPICALLTYPE <br>fIVTAbcIdleRoutine(LPVOID lpv) <br>{ <br>    LPIVTABC lpIVTAbc = (LPIVTABC) lpv; <br> <br>    Assert(lpv); <br> <br>    /* if file is open close it  */ <br>    if (lpIVTAbc-&gt;hFile != INVALID_HANDLE_VALUE) <br>    { <br>        CloseHandle(lpIVTAbc-&gt;hFile); <br>        lpIVTAbc-&gt;hFile = INVALID_HANDLE_VALUE; <br>    } <br> <br>    /* has file name has changed? */ <br>    if (!FEqualSABFiles(lpIVTAbc-&gt;lpABLogon, lpIVTAbc-&gt;lpszFileName)) <br>    { <br>        /* file name has changed so call HrOpenFile to reset bookmarks etc */ <br>        if (!HR_FAILED(HrOpenFile(lpIVTAbc))) <br>        { <br>            /* close the file */ <br>            CloseHandle(lpIVTAbc-&gt;hFile); <br>            lpIVTAbc-&gt;hFile = INVALID_HANDLE_VALUE; <br>        } <br>    } <br>    return TRUE; <br>} <br> <br>/************************************************************************* <br> * <br> -  FreeANRBitmaps <br> - <br> *  Frees the two ANR bitmaps associated with this table <br> * <br> * <br> */ <br>void  <br>FreeANRBitmaps(LPIVTABC lpIVTAbc) <br>{ <br>    if (lpIVTAbc-&gt;rgChecked) <br>    { <br>        lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Free(lpIVTAbc-&gt;lpMalloc, lpIVTAbc-&gt;rgChecked); <br>        lpIVTAbc-&gt;rgChecked = NULL; <br>    } <br> <br>    if (lpIVTAbc-&gt;rgMatched) <br>    { <br>        lpIVTAbc-&gt;lpMalloc-&gt;lpVtbl-&gt;Free(lpIVTAbc-&gt;lpMalloc, lpIVTAbc-&gt;rgMatched); <br>        lpIVTAbc-&gt;rgMatched = NULL; <br>    } <br>} <br> <br> <br> <br>/* <br> *  FCharInString <br> * <br> *  Finds a character in a string <br> */ <br>BOOL <br>FCharInString(LPSTR lpsz, CHAR ch) <br>{ <br> <br>    while (*lpsz &amp;&amp; *lpsz != ch) <br>        lpsz++; <br> <br>    return (*lpsz == ch); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
