<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATUS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2120"></a>STATUS.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  STATUS.C <br> * <br> * <br> *  The Sample Address Book Provider. <br> *  This file contains the methods that implement the status object. <br> * <br> *  The following routines are implemented in this file: <br> * <br> *      HrNewStatusObject() <br> *      ABS_QueryInterface() <br> *      ABS_Release() <br> *      ABS_ValidateState() <br> *      ABS_SettingsDialog() <br> *      ABS_ChangePassword() <br> *      ABS_FlushQueues() <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br> <br>#include "abp.h" <br>#include "sampabp.rh" <br> <br> <br>/* <br> *  Declaration of IMAPIStatus object implementation <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _ABSTATUS <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, ABS_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPISTATUS_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, ABS_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>        MAPI_IMAPISTATUS_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(ABS_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>    MAPI_IMAPISTATUS_METHODS(IMPL) <br>}; <br> <br> <br>/* <br> *  The actual definition of the structure behind the 'this' pointer for this object <br> */ <br>typedef struct _ABSTATUS <br>{ <br>    const ABS_Vtbl FAR * lpVtbl; <br> <br>    SAB_Wrapped; <br>     <br>} ABSTATUS, *LPABSTATUS; <br> <br> <br>/* <br> *  AB Status vtbl filled in here <br> */ <br> <br>static const ABS_Vtbl vtblABS = <br>{ <br> <br>    ABS_QueryInterface, <br>    (ABS_AddRef_METHOD *)           ROOT_AddRef, <br>    ABS_Release, <br>    (ABS_GetLastError_METHOD *)     ROOT_GetLastError, <br>    (ABS_SaveChanges_METHOD *)      WRAP_SaveChanges, <br>    (ABS_GetProps_METHOD *)         WRAP_GetProps, <br>    (ABS_GetPropList_METHOD *)      WRAP_GetPropList, <br>    (ABS_OpenProperty_METHOD *)     WRAP_OpenProperty, <br>    (ABS_SetProps_METHOD *)         WRAP_SetProps, <br>    (ABS_DeleteProps_METHOD *)      WRAP_DeleteProps, <br>    (ABS_CopyTo_METHOD *)           WRAP_CopyTo, <br>    (ABS_CopyProps_METHOD *)        WRAP_CopyProps, <br>    (ABS_GetNamesFromIDs_METHOD *)  WRAP_GetNamesFromIDs, <br>    (ABS_GetIDsFromNames_METHOD *)  WRAP_GetIDsFromNames, <br>    ABS_ValidateState, <br>    ABS_SettingsDialog, <br>    ABS_ChangePassword, <br>    ABS_FlushQueues <br>}; <br> <br>/************************************************************************* <br> * <br> -  HrNewStatusObject <br> - <br> *  Creates the Status object associated with a particular SAB logon object <br> * <br> * <br> */ <br>HRESULT <br>HrNewStatusObject(LPMAPISTATUS *    lppABS, <br>                ULONG *             lpulObjType, <br>                ULONG               ulFlags, <br>                LPABLOGON           lpABLogon, <br>                LPCIID              lpIID, <br>                HINSTANCE           hLibrary, <br>                LPALLOCATEBUFFER    lpAllocBuff, <br>                LPALLOCATEMORE      lpAllocMore, <br>                LPFREEBUFFER        lpFreeBuff, <br>                LPMALLOC            lpMalloc ) <br>{ <br>    LPABSTATUS lpABS = NULL; <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    LPPROPDATA lpPropData = NULL; <br>    SPropValue spv[6]; <br>    LPSTR lpszFileName; <br> <br> <br>    /* <br>     * <br>     */ <br>    if (lpIID &amp;&amp; <br>        (memcmp(lpIID, &amp;IID_IMAPIStatus, sizeof(IID)) &amp;&amp; <br>         memcmp(lpIID, &amp;IID_IMAPIProp, sizeof(IID)) &amp;&amp; <br>         memcmp(lpIID, &amp;IID_IUnknown, sizeof(IID)))) <br>    { <br>        DebugTraceSc(HrNewStatusObject, E_NOINTERFACE); <br>        return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>    /* <br>     *  Allocate space for the ABSTATUS structure <br>     */ <br>    sc = lpAllocBuff( sizeof(ABSTATUS), (LPVOID *) &amp;lpABS ); <br> <br>    if (FAILED(sc)) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    lpABS-&gt;lpVtbl = &amp;vtblABS; <br>    lpABS-&gt;lcInit = 1; <br>    lpABS-&gt;hResult = hrSuccess; <br>    lpABS-&gt;idsLastError = 0; <br> <br>    lpABS-&gt;hLibrary = hLibrary; <br>    lpABS-&gt;lpAllocBuff = lpAllocBuff; <br>    lpABS-&gt;lpAllocMore = lpAllocMore; <br>    lpABS-&gt;lpFreeBuff = lpFreeBuff; <br>    lpABS-&gt;lpMalloc = lpMalloc; <br> <br>    lpABS-&gt;lpABLogon = lpABLogon; <br> <br>    /* <br>     *  Create lpPropData <br>     */ <br> <br>    sc = CreateIProp((LPIID) &amp;IID_IMAPIPropData, <br>        lpAllocBuff, <br>        lpAllocMore, <br>        lpFreeBuff, <br>        lpMalloc, <br>        &amp;lpPropData); <br> <br>    if (FAILED(sc)) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Set up initial set of properties associated with this <br>     *  status object. <br>     */ <br> <br>    /* <br>     *  Register my status row... <br>     */ <br>    hr = HrLpszGetCurrentFileName(lpABLogon, &amp;lpszFileName); <br>    if (HR_FAILED(hr)) <br>    { <br>        goto err; <br>    } <br>     <br>    spv[0].ulPropTag = PR_DISPLAY_NAME_A; <br>    spv[0].Value.lpszA = lpszFileName; <br> <br>    spv[1].ulPropTag = PR_RESOURCE_METHODS; <br>    spv[1].Value.l = 0; <br> <br>    spv[2].ulPropTag = PR_RESOURCE_FLAGS; <br>    spv[2].Value.l = 0; <br> <br>    spv[3].ulPropTag = PR_STATUS_CODE; <br>    spv[3].Value.l = STATUS_AVAILABLE; <br> <br>    spv[4].ulPropTag = PR_STATUS_STRING_A; <br>    spv[4].Value.lpszA = "Available"; <br> <br>    spv[5].ulPropTag = PR_PROVIDER_DISPLAY_A; <br>    spv[5].Value.lpszA = "Sample Address Book Provider"; <br> <br>    /* <br>     *   Set the default properties <br>     */ <br>    hr = lpPropData-&gt;lpVtbl-&gt;SetProps(lpPropData, <br>        6, <br>        spv, <br>        NULL); <br> <br>    /* <br>     *  Done with the current file name <br>     */ <br>    lpFreeBuff(lpszFileName); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        goto err; <br>    } <br> <br>    /* <br>     *  The whole object is set READONLY thus eliminating the need to <br>     *  set access rights for the individual properties. <br>     */ <br>    (void) lpPropData-&gt;lpVtbl-&gt;HrSetObjAccess(lpPropData, IPROP_READONLY); <br> <br>    lpABS-&gt;lpPropData = (LPMAPIPROP) lpPropData; <br> <br>    InitializeCriticalSection(&amp;lpABS-&gt;cs); <br> <br>    /*  We must AddRef the lpABLogon object since we will be using it <br>     */ <br>    lpABLogon-&gt;lpVtbl-&gt;AddRef(lpABLogon); <br> <br>    *lpulObjType = MAPI_STATUS; <br>    *lppABS = (LPMAPISTATUS) lpABS; <br> <br>out: <br> <br>    DebugTraceResult(HrNewStatusObject, hr); <br>    return hr; <br> <br>err: <br>    if (lpPropData) <br>        lpPropData-&gt;lpVtbl-&gt;Release(lpPropData); <br> <br>    lpFreeBuff( lpABS ); <br> <br>    goto out; <br> <br>} <br> <br>/************************************************************************* <br> * <br> * <br> -  ABS_QueryInterface <br> - <br> *  This method would allow this object to return a different interface than <br> *  the current one.  This object need only support IMAPIStatus and any interface <br> *  it derives from. <br> * <br> */ <br>STDMETHODIMP <br>ABS_QueryInterface(LPABSTATUS lpABS, <br>    REFIID lpiid, LPVOID FAR * lppNewObj) <br>{ <br> <br>    HRESULT hr = hrSuccess; <br>    /* <br>     *  Check to see if lpABS is what we expect <br>     */ <br>    if (IsBadReadPtr(lpABS, sizeof(ABSTATUS)) <br>        || lpABS-&gt;lpVtbl != &amp;vtblABS ) <br>    { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IUnknown_QueryInterface(lpABS, lpiid, lppNewObj); <br> <br> <br>    /*  See if the requested interface is one of ours */ <br> <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IMAPIProp, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IMAPIStatus, sizeof(IID))) <br>    { <br>        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */ <br>        hr = ResultFromScode(E_NOINTERFACE); <br>        goto out; <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    EnterCriticalSection(&amp;lpABS-&gt;cs); <br>     <br>    ++lpABS-&gt;lcInit; <br>     <br>    LeaveCriticalSection(&amp;lpABS-&gt;cs); <br> <br>    *lppNewObj = lpABS; <br> <br>out: <br> <br>    DebugTraceResult(ABS_QueryInterface, hr); <br>    return hr; <br>} <br> <br>/************************************************** <br> * <br> -  ABS_Release <br> - <br> *      Decrement lpInit. <br> *      When lcInit == 0, free up the lpABS structure <br> * <br> */ <br>STDMETHODIMP_(ULONG) ABS_Release(LPABSTATUS lpABS) <br>{ <br>    LONG lcInit; <br> <br>    /* <br>     *  Check to see if lpABS is what we expect <br>     */ <br>    if (IsBadReadPtr(lpABS, sizeof(ABSTATUS))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see that it's the correct jump table <br>     */ <br>    if (lpABS-&gt;lpVtbl != &amp;vtblABS) <br>    { <br>        /* <br>         *  Not my jump table <br>         */ <br>        return 1; <br>    } <br> <br>    Validate_IUnknown_Release(lpABS); <br> <br> <br>    EnterCriticalSection(&amp;lpABS-&gt;cs); <br> <br>    lcInit = --lpABS-&gt;lcInit; <br> <br>    LeaveCriticalSection(&amp;lpABS-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br> <br>        /* <br>         *  Get rid of the lpPropData <br>         */ <br> <br>        lpABS-&gt;lpPropData-&gt;lpVtbl-&gt;Release(lpABS-&gt;lpPropData); <br> <br>        /* <br>         *  Delete the critical section <br>         */ <br> <br>        DeleteCriticalSection(&amp;lpABS-&gt;cs); <br> <br>        /*   <br>         *  Release our reference to the ABLogon object. <br>         */ <br>        if (lpABS-&gt;lpABLogon) <br>        { <br>            lpABS-&gt;lpABLogon-&gt;lpVtbl-&gt;Release(lpABS-&gt;lpABLogon); <br>            lpABS-&gt;lpABLogon = NULL; <br>        } <br> <br>        /* <br>         *  Set the Jump table to NULL.  This way the client will find out <br>         *  real fast if it's calling a method on a released object.  That is, <br>         *  the client will crash.  Hopefully, this will happen during the <br>         *  development stage of the client. <br>         */ <br> <br>        lpABS-&gt;lpVtbl = NULL; <br> <br>        /* <br>         *  Need to free the object <br>         */ <br> <br>        lpABS-&gt;lpFreeBuff( lpABS ); <br>        return 0; <br>    } <br> <br>    return lcInit; <br> <br>} <br> <br> <br>/********************************************************************** <br> * <br> -  ABS_ValidateState <br> - <br> *  Since I did not set any flags for the property PR_RESOURCE_METHODS <br> *  I don't have to support this method. <br> * <br> */ <br> <br>STDMETHODIMP <br>ABS_ValidateState(LPABSTATUS lpABS, <br>                  ULONG ulUIParam, <br>                  ULONG ulFlags) <br>{ <br>    HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>    /* <br>     *  Check to see if lpABS is what we expect <br>     */ <br>    if (IsBadReadPtr(lpABS, sizeof(ABSTATUS)) <br>        || lpABS-&gt;lpVtbl != &amp;vtblABS ) <br>    { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IMAPIStatus_ValidateState(lpABS, ulUIParam, ulFlags); <br>     <br>out: <br>    DebugTraceResult(ABS_ValidateState, hr); <br>    return hr; <br>} <br> <br> <br>/********************************************************************** <br> * <br> -  ABS_SettingsDialog <br> - <br> *  Since I did not set any flags for the property PR_RESOURCE_METHODS <br> *  I don't have to support this method. <br> * <br> */ <br>STDMETHODIMP <br>ABS_SettingsDialog( LPABSTATUS lpABS, <br>                    ULONG ulUIParam, <br>                    ULONG ulFlags) <br>{ <br>    HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>    /* <br>     *  Check to see if lpABS is what we expect <br>     */ <br>    if (IsBadReadPtr(lpABS, sizeof(ABSTATUS)) <br>        || lpABS-&gt;lpVtbl != &amp;vtblABS ) <br>    { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IMAPIStatus_SettingsDialog(lpABS, ulUIParam, ulFlags); <br>     <br>out: <br>    DebugTraceResult(ABS_SettingsDialog, hr); <br>    return hr; <br>} <br> <br> <br>/********************************************************************** <br> * <br> -  ABS_ChangePassword <br> - <br> *  Since I did not set any flags for the property PR_RESOURCE_METHODS <br> *  I don't have to support this method. <br> * <br> *  Note:   in the parameter validation below I chose only check the first 15 <br> *          characters of the passwords.  This was arbitrary. <br> */ <br>STDMETHODIMP <br>ABS_ChangePassword(LPABSTATUS lpABS, <br>    LPTSTR lpOldPass, <br>    LPTSTR lpNewPass, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>    /* <br>     *  Check to see if lpABS is what we expect <br>     */ <br>    if (IsBadReadPtr(lpABS, sizeof(ABSTATUS)) <br>        || lpABS-&gt;lpVtbl != &amp;vtblABS ) <br>    { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IMAPIStatus_ChangePassword(lpABS, lpOldPass, lpNewPass, ulFlags); <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        // UNICODE is currently not supported by the sample AB <br>         <br>        hr = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        goto out; <br>    } <br>     <br>         <br> <br>out: <br>    DebugTraceResult(ABS_ChangePassword, hr); <br>    return hr; <br>} <br> <br> <br>/********************************************************************** <br> * <br> -  ABS_FlushQueues <br> - <br> *  Since I did not set any flags for the property PR_RESOURCE_METHODS <br> *  I don't have to support this method. <br> * <br> */ <br>STDMETHODIMP <br>ABS_FlushQueues(LPABSTATUS lpABS, <br>    ULONG ulUIParam, <br>    ULONG cbTargetTransport, <br>    LPENTRYID lpTargetTransport, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hr = ResultFromScode(MAPI_E_NO_SUPPORT); <br>    /* <br>     *  Check to see if lpABS is what we expect <br>     */ <br>    if (IsBadReadPtr(lpABS, sizeof(ABSTATUS)) || lpABS-&gt;lpVtbl != &amp;vtblABS ) <br>    { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto out; <br>    } <br> <br>    Validate_IMAPIStatus_FlushQueues(lpABS, ulUIParam, cbTargetTransport, <br>                                    lpTargetTransport, ulFlags); <br> <br> <br>out: <br>    DebugTraceResult(ABS_FlushQueues, hr); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
