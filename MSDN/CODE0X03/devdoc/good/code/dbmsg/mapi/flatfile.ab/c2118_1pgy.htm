<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WRAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2122"></a>WRAP.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  WRAP.C <br> * <br> *  Sample Address Book Wrap object <br> *  This file contains the code for implementing the Sample AB <br> *  WRAP object. <br> * <br> *  This file contains methods with "default" actions for objects which <br> *  expose IUnknown and/or IMAPIProp.  These "default" actions are to call <br> *  the appropriate method of a "wrapped" object that is a member of this <br> *  object.  Various methods in this file are used throughout this sample <br> *  provider and are especially useful with the objects that implement template <br> *  ids (see TID.C and OOTID.C). <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br>#include "abp.h" <br> <br>typedef struct _WRAP { <br> <br>    WRAP_Vtbl * lpVtbl; <br> <br>    SAB_Wrapped; <br>     <br>} WRAP, *LPWRAP; <br> <br>/********************************************************************* <br> * <br> *  The actual Wrapped IMAPIProp methods <br> * <br> */ <br> <br>STDMETHODIMP <br>WRAP_QueryInterface(LPWRAP lpWRAP, <br>                    REFIID lpiid, <br>                    LPVOID * lppNewObj) <br>{ <br>    HRESULT hr; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, QueryInterface)+sizeof(WRAP_QueryInterface_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_QueryInterface != lpWRAP-&gt;lpVtbl-&gt;QueryInterface) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    EnterCriticalSection(&amp;lpWRAP-&gt;cs); <br>    /*  Call the internal prop interface */ <br> <br>    hr = lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;QueryInterface( <br>        lpWRAP-&gt;lpPropData, <br>        lpiid, <br>        lppNewObj); <br> <br>    /*  If this object is successful in QI'ing and it returns exactly the <br>     *  same object, then I need to AddRef my own "wrapper" object so that <br>     *  my release code works correctly AND replace the *lppNewObj with the <br>     *  "wrapper" object. <br>     */ <br>    if (!HR_FAILED(hr) &amp;&amp; (lpWRAP-&gt;lpPropData == *lppNewObj)) <br>    { <br>        ++lpWRAP-&gt;lcInit; <br>        *lppNewObj = lpWRAP; <br>    } <br> <br>    LeaveCriticalSection(&amp;lpWRAP-&gt;cs); <br> <br>    return hr; <br> <br>} <br> <br>STDMETHODIMP_(ULONG) WRAP_AddRef(LPWRAP lpWRAP) <br>{ <br>    ULONG ulRet; <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, AddRef)+sizeof(WRAP_AddRef_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_AddRef != lpWRAP-&gt;lpVtbl-&gt;AddRef) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        return 1; <br>    } <br> <br>    EnterCriticalSection(&amp;lpWRAP-&gt;cs); <br>    ++lpWRAP-&gt;lcInit; <br> <br>    /*  Call the internal prop interface */ <br> <br>    ulRet = lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;AddRef(lpWRAP-&gt;lpPropData); <br>     <br>    LeaveCriticalSection(&amp;lpWRAP-&gt;cs); <br> <br>    return ulRet; <br>} <br> <br>STDMETHODIMP_(ULONG) WRAP_Release(LPWRAP lpWRAP) <br>{ <br>    long lcInit; <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, Release)+sizeof(WRAP_Release_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_Release != lpWRAP-&gt;lpVtbl-&gt;Release) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        return 1; <br>    } <br> <br> <br>    EnterCriticalSection(&amp;lpWRAP-&gt;cs); <br> <br>    /* <br>     *  Release the imapiprop object <br>     */ <br> <br>    lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;Release( <br>        lpWRAP-&gt;lpPropData); <br> <br>    lcInit = --lpWRAP-&gt;lcInit; <br> <br>    LeaveCriticalSection(&amp;lpWRAP-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br>        /*   <br>         *  Release our reference to the ABLogon object. <br>         */ <br>        if (lpWRAP-&gt;lpABLogon) <br>        { <br>            lpWRAP-&gt;lpABLogon-&gt;lpVtbl-&gt;Release(lpWRAP-&gt;lpABLogon); <br>            lpWRAP-&gt;lpABLogon = NULL; <br>        } <br> <br> <br>        /* <br>         *  Get rid of my critical section <br>         */ <br>        DeleteCriticalSection(&amp;lpWRAP-&gt;cs); <br> <br>        /* <br>         *  Set the Jump table to NULL.  This way the client will find out <br>         *  real fast if it's calling a method on a released object.  That is, <br>         *  the client will crash.  Hopefully, this will happen during the <br>         *  development stage of the client. <br>         */ <br> <br>        lpWRAP-&gt;lpVtbl = NULL; <br> <br>        /* <br>         *  Need to free the object <br>         */ <br> <br>        lpWRAP-&gt;lpFreeBuff(lpWRAP); <br>        return 0; <br>    } <br> <br>    return lcInit; <br>} <br> <br>STDMETHODIMP <br>WRAP_GetLastError(  LPWRAP lpWRAP, <br>                    HRESULT hError, <br>                    ULONG ulFlags, <br>                    LPMAPIERROR FAR * lppMapiError ) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>        offsetof(WRAP_Vtbl, GetLastError)+sizeof(WRAP_GetLastError_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_GetLastError != lpWRAP-&gt;lpVtbl-&gt;GetLastError) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    if ( ulFlags &amp; ~MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>        return hResult ; <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        return hResult; <br>    } <br>     <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;GetLastError( <br>        lpWRAP-&gt;lpPropData, <br>        hError, <br>        ulFlags, <br>        lppMapiError ); <br>} <br> <br>/* IProperty */ <br> <br>STDMETHODIMP <br>WRAP_SaveChanges(   LPWRAP lpWRAP, <br>                    ULONG ulFlags) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, SaveChanges)+sizeof(WRAP_SaveChanges_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_SaveChanges != lpWRAP-&gt;lpVtbl-&gt;SaveChanges) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    hResult = lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;SaveChanges( <br>        lpWRAP-&gt;lpPropData, <br>        ulFlags); <br> <br>    return hResult; <br> <br>} <br> <br>STDMETHODIMP <br>WRAP_GetProps(  LPWRAP lpWRAP, <br>                LPSPropTagArray lpPropTagArray, <br>                ULONG ulFlags, <br>                ULONG * lpcValues, <br>                LPSPropValue * lppPropArray) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, GetProps)+sizeof(WRAP_GetProps_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_GetProps != lpWRAP-&gt;lpVtbl-&gt;GetProps) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    if ( ulFlags &amp; ~(MAPI_UNICODE) ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>         <br>        return hResult; <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        return hResult; <br>    } <br> <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;GetProps( <br>        lpWRAP-&gt;lpPropData, <br>        lpPropTagArray, <br>        ulFlags, <br>        lpcValues, <br>        lppPropArray); <br> <br>} <br> <br>STDMETHODIMP <br>WRAP_GetPropList(   LPWRAP lpWRAP, <br>                    ULONG ulFlags, <br>                    LPSPropTagArray * lppPropTagArray) <br>{ <br>    HRESULT hResult = hrSuccess; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, GetPropList)+sizeof(WRAP_GetPropList_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_GetPropList != lpWRAP-&gt;lpVtbl-&gt;GetPropList) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    if ( ulFlags &amp; ~(MAPI_UNICODE) ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>         <br>        return hResult; <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        return hResult; <br>    } <br>     <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;GetPropList( <br>        lpWRAP-&gt;lpPropData, <br>        ulFlags, <br>        lppPropTagArray); <br> <br>} <br> <br>STDMETHODIMP <br>WRAP_OpenProperty(  LPWRAP lpWRAP, <br>                    ULONG ulPropTag, <br>                    LPCIID lpiid, <br>                    ULONG ulInterfaceOptions, <br>                    ULONG ulFlags, <br>                    LPUNKNOWN * lppUnk) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, OpenProperty)+sizeof(WRAP_OpenProperty_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_OpenProperty != lpWRAP-&gt;lpVtbl-&gt;OpenProperty) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; ~MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>        return hResult; <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        return hResult; <br>    } <br>     <br>    hResult = lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;OpenProperty( <br>        lpWRAP-&gt;lpPropData, <br>        ulPropTag, <br>        lpiid, <br>        ulInterfaceOptions, <br>        ulFlags, <br>        lppUnk); <br> <br>    return hResult; <br> <br>} <br> <br>STDMETHODIMP <br>WRAP_SetProps(  LPWRAP lpWRAP, <br>                ULONG cValues, <br>                LPSPropValue lpPropArray, <br>                LPSPropProblemArray * lppProblems) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, SetProps)+sizeof(WRAP_SetProps_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_SetProps != lpWRAP-&gt;lpVtbl-&gt;SetProps) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;SetProps( <br>        lpWRAP-&gt;lpPropData, <br>        cValues, <br>        lpPropArray, <br>        lppProblems); <br> <br>} <br> <br>STDMETHODIMP <br>WRAP_DeleteProps(   LPWRAP lpWRAP, <br>                    LPSPropTagArray lpPropTagArray, <br>                    LPSPropProblemArray * lppProblems) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, DeleteProps)+sizeof(WRAP_DeleteProps_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_DeleteProps != lpWRAP-&gt;lpVtbl-&gt;DeleteProps) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;DeleteProps( <br>        lpWRAP-&gt;lpPropData, <br>        lpPropTagArray, <br>        lppProblems); <br> <br>} <br> <br>STDMETHODIMP <br>WRAP_CopyTo(LPWRAP lpWRAP, <br>            ULONG ciidExclude, <br>            LPCIID rgiidExclude, <br>            LPSPropTagArray lpExcludeProps, <br>            ULONG ulUIParam, <br>            LPMAPIPROGRESS lpProgress, <br>            LPCIID lpInterface, <br>            LPVOID lpDestObj, <br>            ULONG ulFlags, <br>            LPSPropProblemArray FAR * lppProblems) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, CopyTo)+sizeof(WRAP_CopyTo_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_CopyTo != lpWRAP-&gt;lpVtbl-&gt;CopyTo) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;CopyTo( <br>        lpWRAP-&gt;lpPropData, <br>        ciidExclude, <br>        rgiidExclude, <br>        lpExcludeProps, <br>        ulUIParam, <br>        lpProgress, <br>        lpInterface, <br>        lpDestObj, <br>        ulFlags, <br>        lppProblems); <br>} <br> <br>STDMETHODIMP <br>WRAP_CopyProps(LPWRAP lpWRAP, <br>            LPSPropTagArray lpIncludeProps, <br>            ULONG ulUIParam, <br>            LPMAPIPROGRESS lpProgress, <br>            LPCIID lpInterface, <br>            LPVOID lpDestObj, <br>            ULONG ulFlags, <br>            LPSPropProblemArray FAR * lppProblems) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, CopyProps)+sizeof(WRAP_CopyProps_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_CopyProps != lpWRAP-&gt;lpVtbl-&gt;CopyProps) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;CopyProps( <br>        lpWRAP-&gt;lpPropData, <br>        lpIncludeProps, <br>        ulUIParam, <br>        lpProgress, <br>        lpInterface, <br>        lpDestObj, <br>        ulFlags, <br>        lppProblems); <br>} <br> <br>STDMETHODIMP <br>WRAP_GetNamesFromIDs(   LPWRAP lpWRAP, <br>                        LPSPropTagArray * lppPropTags, <br>                        LPGUID lpPropSetGuid, <br>                        ULONG ulFlags, <br>                        ULONG * lpcPropNames, <br>                        LPMAPINAMEID ** lpppPropNames) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, GetNamesFromIDs)+sizeof(WRAP_GetNamesFromIDs_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_GetNamesFromIDs != lpWRAP-&gt;lpVtbl-&gt;GetNamesFromIDs) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;GetNamesFromIDs( <br>        lpWRAP-&gt;lpPropData, <br>        lppPropTags, <br>        lpPropSetGuid, <br>        ulFlags, <br>        lpcPropNames, <br>        lpppPropNames); <br>} <br> <br>STDMETHODIMP <br>WRAP_GetIDsFromNames(   LPWRAP lpWRAP, <br>                        ULONG cPropNames, <br>                        LPMAPINAMEID * lppPropNames, <br>                        ULONG ulFlags, <br>                        LPSPropTagArray * lppPropTags) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpWRAP, offsetof(WRAP, lpVtbl)+sizeof(WRAP_Vtbl *))) <br>    { <br>        /* <br>         *  No jump table found <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpWRAP-&gt;lpVtbl, <br>                     offsetof(WRAP_Vtbl, GetIDsFromNames)+sizeof(WRAP_GetIDsFromNames_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (WRAP_GetIDsFromNames != lpWRAP-&gt;lpVtbl-&gt;GetIDsFromNames) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br> <br>        hResult = ResultFromScode(E_INVALIDARG); <br> <br>        return hResult; <br>    } <br> <br>    return lpWRAP-&gt;lpPropData-&gt;lpVtbl-&gt;GetIDsFromNames( <br>        lpWRAP-&gt;lpPropData, <br>        cPropNames, <br>        lppPropNames, <br>        ulFlags, <br>        lppPropTags); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
