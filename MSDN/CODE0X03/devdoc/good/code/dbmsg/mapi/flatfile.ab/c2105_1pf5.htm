<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ABLOGON.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2111"></a>ABLOGON.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ABLOGON.C <br> * <br> * <br> *  The Sample Address Book Provider. <br> * <br> *  This file has the code to implement the Sample Address Book's logon <br> *  object. <br> * <br> *  The following routines are implemented in this file: <br> *   <br> *  ABPLOGON_QueryInterface <br> *  ABPLOGON_Release <br> *  ABPLOGON_Logoff <br> *  ABPLOGON_OpenEntry <br> *  ABPLOGON_CompareEntryIDs <br> *  ABPLOGON_Advise <br> *  ABPLOGON_Unadvise <br> *  ABPLOGON_OpenStatusEntry <br> *  ABPLOGON_OpenTemplateID <br> *  ABPLOGON_GetOneOffTable <br> *  ABPLOGON_PrepareRecips <br> *   <br> *  LpMuidFromLogon <br> *  HrLpszGetCurrentFileName <br> *  HrReplaceCurrentfileName <br> *  GenerateContainerDN <br> *  HrBuildRootHier <br> *   <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br> <br>#include "abp.h" <br>#include "sampabp.rh" <br>#include &lt;smpab.h&gt; <br> <br> <br>/* <br> *  Definition of the logon object <br> */ <br>typedef struct _ABPLOGON { <br> <br>    ABPLOGON_Vtbl FAR *     lpVtbl; <br> <br>    SAB_IUnknown; <br> <br>    /* <br>     *  Private structure <br>     */ <br>    LPABPROVIDER lpABP; <br> <br>    LPSTR lpszFileName;         /* Name of file that is browsed */ <br>    MAPIUID muidID;             /* UID for this logon object */ <br>    LPMAPISUP lpMapiSup;        /* MAPI Support object - gotten via ABP_Logon */ <br> <br>    /* <br>     *  Table Data for canned tables <br>     */ <br> <br> <br>    LPTABLEDATA lpTDatRoot;     /*  Root hierarchy  */ <br>    LPTABLEDATA lpTDatOO;       /*  One Off Table  */ <br> <br>} ABPLOGON, FAR *LPABPLOGON; <br> <br> <br> <br>ABPLOGON_Vtbl vtblABPLOGON = <br>{ <br>    ABPLOGON_QueryInterface, <br>    (ABPLOGON_AddRef_METHOD *) ROOT_AddRef, <br>    ABPLOGON_Release, <br>    (ABPLOGON_GetLastError_METHOD *) ROOT_GetLastError, <br>    ABPLOGON_Logoff, <br>    ABPLOGON_OpenEntry, <br>    ABPLOGON_CompareEntryIDs, <br>    ABPLOGON_Advise, <br>    ABPLOGON_Unadvise, <br>    ABPLOGON_OpenStatusEntry, <br>    ABPLOGON_OpenTemplateID, <br>    ABPLOGON_GetOneOffTable, <br>    ABPLOGON_PrepareRecips <br>}; <br> <br> <br> <br>/* <br> -  HrNewABLogon <br> - <br> * <br> *  Creates a new Sample AB Logon object. <br> */ <br> <br>HRESULT <br>HrNewABLogon(   LPABLOGON *         lppABLogon, <br>                LPABPROVIDER        lpABP, <br>                LPMAPISUP           lpMAPISup, <br>                LPSTR               lpszSABFile, <br>                LPMAPIUID           lpmuid, <br>                HINSTANCE           hLibrary, <br>                LPALLOCATEBUFFER    lpAllocBuff, <br>                LPALLOCATEMORE      lpAllocMore, <br>                LPFREEBUFFER        lpFreeBuff, <br>                LPMALLOC            lpMalloc ) <br>{ <br>    SCODE sc; <br>    HRESULT hResult = hrSuccess; <br>    SPropValue rgSPVStat[6]; <br>    LPABPLOGON lpABPLogon = NULL; <br> <br>    /* <br>     *  Allocate space for the lpABPLogon object <br>     */ <br> <br>    sc = lpAllocBuff(sizeof(ABPLOGON), &amp;lpABPLogon); <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Initialize the ABPLogon object <br>     */ <br> <br>    lpABPLogon-&gt;lpVtbl = &amp;vtblABPLOGON; <br> <br>    lpABPLogon-&gt;lcInit = 1; <br>    lpABPLogon-&gt;hResult = hrSuccess; <br>    lpABPLogon-&gt;idsLastError = 0; <br> <br>    lpABPLogon-&gt;hLibrary = hLibrary; <br> <br>    lpABPLogon-&gt;lpMalloc = lpMalloc; <br>    lpABPLogon-&gt;lpAllocBuff = lpAllocBuff; <br>    lpABPLogon-&gt;lpAllocMore = lpAllocMore; <br>    lpABPLogon-&gt;lpFreeBuff = lpFreeBuff; <br> <br>    lpABPLogon-&gt;lpMapiSup = lpMAPISup; <br>    lpABPLogon-&gt;lpABP = (LPABPROVIDER) lpABP; <br>    lpABPLogon-&gt;lpszFileName = lpszSABFile; <br>    lpABPLogon-&gt;muidID = *lpmuid; <br> <br>    lpABPLogon-&gt;lpTDatRoot = NULL; <br>    lpABPLogon-&gt;lpTDatOO = NULL; <br> <br>    /* <br>     *  Register my status row... <br>     */ <br>    rgSPVStat[0].ulPropTag = PR_DISPLAY_NAME_A; <br>    rgSPVStat[0].Value.lpszA = lpszSABFile; <br>    rgSPVStat[1].ulPropTag = PR_RESOURCE_METHODS; <br>    rgSPVStat[1].Value.l = 0;    <br>    rgSPVStat[2].ulPropTag = PR_RESOURCE_FLAGS; <br>    rgSPVStat[2].Value.l = 0; <br>    rgSPVStat[3].ulPropTag = PR_STATUS_CODE; <br>    rgSPVStat[3].Value.l = STATUS_AVAILABLE; <br>    rgSPVStat[4].ulPropTag = PR_STATUS_STRING; <br>    rgSPVStat[4].Value.lpszA = "Available"; <br>    rgSPVStat[5].ulPropTag = PR_PROVIDER_DISPLAY; <br>    rgSPVStat[5].Value.lpszA = "Sample Address Book Provider"; <br> <br>    /* <br>     *  Set the Status Row for this provider, <br>     *  but do not allow an error from setting the <br>     *  status row to cause failure to Logon. <br>     */ <br> <br>    (void)lpMAPISup-&gt;lpVtbl-&gt;ModifyStatusRow(lpMAPISup, <br>        sizeof(rgSPVStat) / sizeof(SPropValue), rgSPVStat, 0); <br> <br>    /* <br>     *  AddRef the support object, because we're keeping <br>     *  a pointer to it in our Logon object. <br>     */ <br>    lpMAPISup-&gt;lpVtbl-&gt;AddRef(lpMAPISup); <br> <br>    /* <br>     *  AddRef our parent ABInit object <br>     */ <br>    lpABP-&gt;lpVtbl-&gt;AddRef(lpABP); <br> <br>    InitializeCriticalSection(&amp;lpABPLogon-&gt;cs); <br>     <br>    *lppABLogon = (LPABLOGON) lpABPLogon; <br> <br>out: <br> <br>    DebugTraceResult(HrNewABPLogon, hResult); <br>    return hResult; <br>}    <br> <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_QueryInterface <br> - <br> */ <br>STDMETHODIMP <br>ABPLOGON_QueryInterface(LPABPLOGON lpABPLogon, REFIID lpiid, <br>    LPVOID * ppvObj) <br>{ <br>     <br>    Validate_IUnknown_QueryInterface(lpABPLogon, lpiid, ppvObj); <br> <br> <br>    /*  See if the requested interface is one of ours */ <br> <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IABLogon, sizeof(IID))) <br>    { <br>        *ppvObj = NULL;         /* OLE requires zeroing [out] parameter on error */ <br>        DebugTraceSc(ABPLOGON_QueryInterface, E_NOINTERFACE); <br>        return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    EnterCriticalSection(&amp;lpABPLogon-&gt;cs); <br>    ++lpABPLogon-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABPLogon-&gt;cs); <br>     <br>    *ppvObj = lpABPLogon; <br> <br>    return hrSuccess; <br>} <br> <br>/* <br> *  Use ROOTs AddRef <br> */ <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_Release <br> - <br> */ <br>STDMETHODIMP_(ULONG) <br>ABPLOGON_Release(LPABPLOGON lpABPLogon) <br>{ <br>    LONG lcInit; <br> <br> <br>    EnterCriticalSection(&amp;lpABPLogon-&gt;cs); <br>    lcInit = --lpABPLogon-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br>        /* <br>         *  Free up the file <br>         */ <br>        lpABPLogon-&gt;lpFreeBuff(lpABPLogon-&gt;lpszFileName); <br> <br>        /* <br>         *  Release the Hierarchy Table Data <br>         */ <br>        if (lpABPLogon-&gt;lpTDatRoot) <br>            lpABPLogon-&gt;lpTDatRoot-&gt;lpVtbl-&gt;Release(lpABPLogon-&gt;lpTDatRoot); <br> <br>        /* <br>         *  Release the One-Off Table Data <br>         */ <br>        if (lpABPLogon-&gt;lpTDatOO) <br>            lpABPLogon-&gt;lpTDatOO-&gt;lpVtbl-&gt;Release(lpABPLogon-&gt;lpTDatOO); <br> <br>        /* <br>         *  No longer need to be holding on to our parent <br>         */ <br>        lpABPLogon-&gt;lpABP-&gt;lpVtbl-&gt;Release(lpABPLogon-&gt;lpABP); <br>     <br>        /* <br>         *  Release the support object last. <br>         */ <br>        lpABPLogon-&gt;lpMapiSup-&gt;lpVtbl-&gt;Release(lpABPLogon-&gt;lpMapiSup); <br> <br>        DeleteCriticalSection(&amp;lpABPLogon-&gt;cs); <br>        lpABPLogon-&gt;lpVtbl = NULL; <br>        lpABPLogon-&gt;lpFreeBuff(lpABPLogon); <br>        return (0); <br>    } <br>    return lcInit; <br>} <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_Logoff <br> - <br> *  Logoff from this logon object.  Clean up any resources/objects that <br> *  our logon object has accumulated. <br> * <br> * <br> */ <br>STDMETHODIMP <br>ABPLOGON_Logoff(LPABPLOGON lpABPLogon, ULONG ulFlags) <br>{ <br> <br>    /* <br>     *  Remove this logon object from the list of known <br>     *  logon objects associated with this initialization <br>     *  of this provider. <br>     */ <br>    (void) RemoveLogonObject(lpABPLogon-&gt;lpABP, lpABPLogon, lpABPLogon-&gt;lpFreeBuff); <br> <br>    return hrSuccess; <br>} <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_OpenEntry <br> - <br> *  Creates an object with (at least) the IMAPIProp interface from an <br> *  entryID. <br> * <br> *  There are four valid types of entryIDs handled: <br> * <br> *    NULL          &lt;- return back the root container object <br> *    DIR_ENTRYID   &lt;- return back the directory container object <br> *    USR_ENTRYID   &lt;- return back the MAILUSER object <br> *    OOUSR_ENTRYID &lt;- return back the OneOff MAILUSER object <br> * <br> *  Note:  This call is reused for all other internal objects that support OpenEntry(). <br> *    Those other calls *must* check their parameters before calling this method. <br> *    The only other way this method is called is via MAPI which does parameter checking <br> *    for us.  The most we'll do here is assert our parameters. <br> */ <br>STDMETHODIMP <br>ABPLOGON_OpenEntry(LPABPLOGON lpABPLogon, <br>    ULONG cbEntryID, <br>    LPENTRYID lpEntryID, <br>    LPCIID lpInterface, <br>    ULONG ulFlags, <br>    ULONG * lpulObjType, <br>    LPUNKNOWN * lppUnk) <br>{ <br> <br>    LPDIR_ENTRYID lpSampEID = (LPDIR_ENTRYID) lpEntryID; <br>    HRESULT hResult = hrSuccess; <br> <br>    /* <br>     *  Check the EntryID <br>     */ <br> <br>    if (!cbEntryID) <br>    { <br>        LPABCONT lpABCont = NULL; <br> <br>        /* <br>         *  Special case:  the root level object <br>         */ <br> <br>        NFAssertSz(!lpEntryID, "Non-NULL entry id passed with 0 cb to OpenEntry()\n"); <br>         <br>        /*  Make this new object  */ <br> <br>        hResult = HrNewROOT((LPABCONT *) lppUnk, <br>                            lpulObjType, <br>                            (LPABLOGON) lpABPLogon, <br>                            lpInterface, <br>                            lpABPLogon-&gt;hLibrary, <br>                            lpABPLogon-&gt;lpAllocBuff, <br>                            lpABPLogon-&gt;lpAllocMore, <br>                            lpABPLogon-&gt;lpFreeBuff, <br>                            lpABPLogon-&gt;lpMalloc); <br>        goto out; <br>    } <br> <br>    /* <br>     *  There's an entryID there, is it mine?? <br>     *  I need to check because I'm reusing this routine for <br>     *  my Container-&gt;OpenEntry call, and I can't be sure the <br>     *  client will always be well behaved. <br>     * <br>     *  When this routine is called from MAPI, this call is redundant.  But <br>     *  because I'm reusing this routine, I gotta check. <br>     */ <br> <br>    /*  Compare MAPIUIDs  */ <br>    if (memcmp(&amp;(((LPDIR_ENTRYID) lpEntryID)-&gt;muid), &amp;muidABSample, <br>            sizeof(MAPIUID))) <br>    { <br>        /* <br>         *  Not mine! <br>         */ <br> <br>        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto out; <br>    } <br> <br>    /* <br>     *  What object does this correspond to?? <br>     */ <br> <br>    /*  I've only got two types: containers and users  */ <br> <br>    if (lpSampEID-&gt;ulType == SAMP_DIRECTORY) <br>    { <br>        LPABLOGON lpABPLogonT = NULL; <br> <br>        /* entry id must have the same verson number */ <br>        if (lpSampEID-&gt;ulVersion != SAMP_VERSION) <br>        { <br>            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br>            SetErrorIDS(lpABPLogon, hResult, IDS_OLD_EID); <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  find the correct logon object for this entryid <br>         */ <br> <br>        (void) FindLogonObject(lpABPLogon-&gt;lpABP, &amp;lpSampEID-&gt;muidID, &amp;lpABPLogonT); <br> <br>        /* did we find the corresponding logon object */ <br>        if (!lpABPLogonT) <br>        { <br>            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br>            goto out; <br>        } <br> <br>        hResult = HrNewSampDirectory( (LPABCONT *) lppUnk, <br>                                    lpulObjType, <br>                                    (LPABLOGON) lpABPLogonT, <br>                                    lpInterface, <br>                                    lpABPLogon-&gt;hLibrary, <br>                                    lpABPLogon-&gt;lpAllocBuff, <br>                                    lpABPLogon-&gt;lpAllocMore, <br>                                    lpABPLogon-&gt;lpFreeBuff, <br>                                    lpABPLogon-&gt;lpMalloc); <br>        goto out; <br> <br>    } <br> <br>    if (lpSampEID-&gt;ulType == SAMP_USER) <br>        if (cbEntryID == (ULONG) sizeof(USR_ENTRYID)) <br>        { <br>            hResult = HrNewSampUser( (LPMAILUSER *) lppUnk, <br>                                    lpulObjType, <br>                                    cbEntryID, <br>                                    lpEntryID, <br>                                    (LPABLOGON) lpABPLogon, <br>                                    lpInterface, <br>                                    lpABPLogon-&gt;hLibrary, <br>                                    lpABPLogon-&gt;lpAllocBuff, <br>                                    lpABPLogon-&gt;lpAllocMore, <br>                                    lpABPLogon-&gt;lpFreeBuff, <br>                                    lpABPLogon-&gt;lpMalloc); <br> <br>            goto out; <br>        } <br> <br>    if (lpSampEID-&gt;ulType == SAMP_OOUSER) <br>        if (cbEntryID == (ULONG) sizeof(OOUSR_ENTRYID)) <br>        { <br>            hResult = HrNewSampOOUser( (LPMAILUSER *) lppUnk, <br>                                        lpulObjType, <br>                                        cbEntryID, <br>                                        lpEntryID, <br>                                        (LPABLOGON) lpABPLogon, <br>                                        lpInterface, <br>                                        lpABPLogon-&gt;hLibrary, <br>                                        lpABPLogon-&gt;lpAllocBuff, <br>                                        lpABPLogon-&gt;lpAllocMore, <br>                                        lpABPLogon-&gt;lpFreeBuff, <br>                                        lpABPLogon-&gt;lpMalloc); <br> <br> <br>            goto out; <br>        } <br> <br>    hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br> <br>out: <br>    DebugTraceResult(ABPLOGON_OpenEntry, hResult); <br> <br>    return hResult; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_CompareEntryIDs <br> - <br> *  If the two entryids are mine and they're of the same type, then <br> *  just do a binary comparison to see if they're equal. <br> * <br> */ <br>STDMETHODIMP <br>ABPLOGON_CompareEntryIDs(LPABPLOGON lpABPLogon, <br>    ULONG cbEntryID1, <br>    LPENTRYID lpEntryID1, <br>    ULONG cbEntryID2, <br>    LPENTRYID lpEntryID2, <br>    ULONG ulFlags, <br>    ULONG * lpulResult) <br>{ <br> <br>    LPDIR_ENTRYID lpSampEID1 = (LPDIR_ENTRYID) lpEntryID1; <br>    LPDIR_ENTRYID lpSampEID2 = (LPDIR_ENTRYID) lpEntryID2; <br>    HRESULT hResult = hrSuccess; <br> <br>    /* <br>     *  Check to see if their MUID is mine <br>     */ <br>    if (memcmp(&amp;(lpSampEID1-&gt;muid), &amp;muidABSample, sizeof(MAPIUID)) || <br>        memcmp(&amp;(lpSampEID2-&gt;muid), &amp;muidABSample, sizeof(MAPIUID))) <br>    { <br>        /* <br>         *  No recognition of these entryids. <br>         */ <br> <br>        *lpulResult = (ULONG) FALSE; <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br>        goto out; <br>    } <br> <br>    /* <br>     *  See if the type of entryids are the same <br>     */ <br>    if (lpSampEID1-&gt;ulType != lpSampEID2-&gt;ulType) <br>    { <br>        /* <br>         *  They're not, so they don't match <br>         */ <br> <br>        *lpulResult = (ULONG) FALSE; <br>        goto out; <br> <br>    } <br> <br>    /* <br>     *  See if the entryids are the same size.  They'd better be <br>     *  if they're the same type. <br>     */ <br>    if (cbEntryID1 != cbEntryID2) <br>    { <br>        /* <br>         *  They're not?!?  Then I don't know these... <br>         */ <br> <br>        *lpulResult = (ULONG) FALSE; <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br> <br>        goto out; <br>    } <br> <br>    /* <br>     *  Check for Directory entryids <br>     */ <br>    if (lpSampEID1-&gt;ulType == SAMP_DIRECTORY) <br>    { <br>        /* <br>         *  Ok, I'm dealing with directory entryids <br>         */ <br> <br>        /* <br>         *  Better make sure it's the right size <br>         */ <br>        if (cbEntryID1 != sizeof(DIR_ENTRYID)) <br>        { <br>            /* <br>             *  This doesn't make sense.  I don't recognize this entryid. <br>             */ <br> <br>            *lpulResult = (ULONG) FALSE; <br>            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  At this point it's just a memcmp <br>         */ <br>        if (memcmp(lpSampEID1, lpSampEID2, sizeof(DIR_ENTRYID))) <br>        { <br>            /* <br>             *  They're not equal <br>             */ <br> <br>            *lpulResult = (ULONG) FALSE; <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  They must be the same <br>         */ <br> <br>        *lpulResult = (ULONG) TRUE; <br> <br>        goto out; <br>    } <br> <br>    if (lpSampEID1-&gt;ulType == SAMP_USER) <br>    { <br>        /* <br>         *  Ok, I'm dealing with user entryids <br>         */ <br> <br>        /* <br>         *  Better make sure it's the right size <br>         */ <br>        if (cbEntryID1 != sizeof(USR_ENTRYID)) <br>        { <br>            /* <br>             *  This doesn't make sense.  I don't recognize this entryid. <br>             */ <br> <br>            *lpulResult = (ULONG) FALSE; <br>            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  At this point it's just a memcmp <br>         */ <br>        if (memcmp(lpSampEID1, lpSampEID2, sizeof(USR_ENTRYID))) <br>        { <br>            /* <br>             *  They're not equal <br>             */ <br> <br>            *lpulResult = (ULONG) FALSE; <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  They must be the same <br>         */ <br> <br>        *lpulResult = (ULONG) TRUE; <br> <br>        goto out; <br>    } <br> <br>    if (lpSampEID1-&gt;ulType == SAMP_OOUSER) <br>    { <br>        /* <br>         *  Ok, I'm dealing with oneoff user entryids <br>         */ <br> <br>        /* <br>         *  Better make sure it's the right size <br>         */ <br>        if (cbEntryID1 != sizeof(OOUSR_ENTRYID)) <br>        { <br>            /* <br>             *  This doesn't make sense.  I don't recognize this entryid. <br>             */ <br> <br>            *lpulResult = (ULONG) FALSE; <br>            hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  At this point it's just a memcmp <br>         */ <br>        if (memcmp(lpSampEID1, lpSampEID2, sizeof(OOUSR_ENTRYID))) <br>        { <br>            /* <br>             *  They're not equal <br>             */ <br> <br>            *lpulResult = (ULONG) FALSE; <br> <br>            goto out; <br>        } <br> <br>        /* <br>         *  They must be the same <br>         */ <br> <br>        *lpulResult = (ULONG) TRUE; <br> <br>        goto out; <br>    } <br> <br>    /* <br>     *  It's no entryid I know of <br>     */ <br> <br>    *lpulResult = (ULONG) FALSE; <br>    hResult = ResultFromScode(MAPI_E_UNKNOWN_ENTRYID); <br> <br>out: <br> <br>    DebugTraceResult(ABPLOGON_CompareEntryIDs, hResult); <br>    return hResult; <br> <br>} <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_OpenStatusEntry <br> - <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>ABPLOGON_OpenStatusEntry(LPABPLOGON lpABPLogon, <br>    LPCIID lpIID, <br>    ULONG ulFlags, <br>    ULONG FAR * lpulObjType, <br>    LPMAPISTATUS FAR * lppEntry) <br>{ <br>    HRESULT hr; <br> <br>    /* <br>     *  Validate Parameters <br>     */ <br>    Validate_IABLogon_OpenStatusEntry(lpABPLogon, lpIID, ulFlags, <br>                                        lpulObjType, lppEntry); <br> <br> <br>    hr = HrNewStatusObject( lppEntry, <br>                            lpulObjType, <br>                            ulFlags, <br>                            (LPABLOGON) lpABPLogon, <br>                            lpIID, <br>                            lpABPLogon-&gt;hLibrary, <br>                            lpABPLogon-&gt;lpAllocBuff, <br>                            lpABPLogon-&gt;lpAllocMore, <br>                            lpABPLogon-&gt;lpFreeBuff, <br>                            lpABPLogon-&gt;lpMalloc); <br> <br>    DebugTraceResult(ABPLOGON_OpenStatusEntry, hr); <br>    return hr; <br>} <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_OpenTemplateID <br> - <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>ABPLOGON_OpenTemplateID(LPABPLOGON lpABPLogon, <br>    ULONG cbTemplateId, <br>    LPENTRYID lpTemplateId, <br>    ULONG ulTemplateFlags, <br>    LPMAPIPROP lpMAPIPropData, <br>    LPCIID lpInterface, <br>    LPMAPIPROP * lppMAPIPropNew, <br>    LPMAPIPROP lpMAPIPropSibling) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Validate Parameters <br>     */ <br>    Validate_IABLogon_OpenTemplateID(lpABPLogon, cbTemplateId, lpTemplateId, <br>                            ulTemplateFlags, lpMAPIPropData, lpInterface, <br>                            lppMAPIPropNew, lpMAPIPropSibling); <br> <br>    /* //$ need stronger checking here... */ <br>    /* entryid better be right size */ <br>    if (cbTemplateId != sizeof(OOUSR_ENTRYID) &amp;&amp; cbTemplateId != sizeof(USR_ENTRYID)) <br>    { <br>        hResult = ResultFromScode(MAPI_E_INVALID_ENTRYID); <br>        goto out; <br>    } <br> <br>    /*  is it my entry id compare MAPIUIDs  */ <br>    if (memcmp(&amp;(((LPUSR_ENTRYID) lpTemplateId)-&gt;muid), &amp;muidABSample, <br>            sizeof(MAPIUID))) <br>    { <br>        hResult = ResultFromScode( MAPI_E_INVALID_ENTRYID ); <br>        goto out; <br>    } <br> <br>    /* better be a oneoff user entryid or a user entry id */ <br>    if (((LPUSR_ENTRYID) lpTemplateId)-&gt;ulType == SAMP_OOUSER) <br>    { <br> <br>        hResult = HrNewOOTID(   lppMAPIPropNew, <br>                                cbTemplateId, <br>                                lpTemplateId, <br>                                ulTemplateFlags, <br>                                lpMAPIPropData, <br>                                (LPABLOGON) lpABPLogon, <br>                                lpInterface, <br>                                lpABPLogon-&gt;hLibrary, <br>                                lpABPLogon-&gt;lpAllocBuff, <br>                                lpABPLogon-&gt;lpAllocMore, <br>                                lpABPLogon-&gt;lpFreeBuff, <br>                                lpABPLogon-&gt;lpMalloc); <br>             <br>    } <br>    else if (((LPUSR_ENTRYID) lpTemplateId)-&gt;ulType == SAMP_USER) <br>    { <br>        hResult = HrNewTID( lppMAPIPropNew, <br>                            cbTemplateId, <br>                            lpTemplateId, <br>                            ulTemplateFlags, <br>                            lpMAPIPropData, <br>                            (LPABLOGON) lpABPLogon, <br>                            lpInterface, <br>                            lpABPLogon-&gt;hLibrary, <br>                            lpABPLogon-&gt;lpAllocBuff, <br>                            lpABPLogon-&gt;lpAllocMore, <br>                            lpABPLogon-&gt;lpFreeBuff, <br>                            lpABPLogon-&gt;lpMalloc); <br>    } <br>    else <br>    { <br>        hResult = MakeResult(MAPI_E_INVALID_ENTRYID); <br>    } <br> <br>out: <br> <br>    DebugTraceResult(ABPLOGON_OpenTemplateID, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  ABPLOGON_GetOneOffTable <br> - <br> *  Returns the lists of one-offs that this providers can support creation of. <br> *  This list is added to the entries gathered from all the other AB logon objects <br> *  and exposed to the user as the list of things that can be created on a  <br> *  message.  Also this total list is available to other providers through the <br> *  support method GetOneOffTable(). <br> *   <br> *  Note:  There's a bug here that if there are more than one Sample Address Books <br> *  installed on a particular profile, then there will be multiple entries in the <br> *  one-off table from this provider.  This can be changed to only have one one-off <br> *  entry, no matter how many SABs are configured in a profile, if the one-off table <br> *  was associated with the ABInit object. <br> */ <br> <br>/* <br> *  Column set for the oneoff table <br> */ <br>enum {  ivalootPR_DISPLAY_NAME_A = 0, <br>        ivalootPR_ENTRYID, <br>        ivalootPR_DEPTH, <br>        ivalootPR_SELECTABLE, <br>        ivalootPR_ADDRTYPE_A, <br>        ivalootPR_DISPLAY_TYPE, <br>        ivalootPR_INSTANCE_KEY, <br>        ivalootMax }; <br> <br>static const SizedSPropTagArray(ivalootMax, tagaColSetOOTable) = <br>{ <br>    ivalootMax, <br>    { <br>        PR_DISPLAY_NAME_A, <br>        PR_ENTRYID, <br>        PR_DEPTH, <br>        PR_SELECTABLE, <br>        PR_ADDRTYPE_A, <br>        PR_DISPLAY_TYPE, <br>        PR_INSTANCE_KEY <br>    } <br>}; <br> <br>STDMETHODIMP <br>ABPLOGON_GetOneOffTable( <br>    LPABPLOGON lpABPLogon, <br>    ULONG ulFlags, <br>    LPMAPITABLE * lppTable) <br>{ <br>    SCODE sc; <br>    HRESULT hResult; <br>    SRow sRow; <br>    SPropValue rgsPropValue[ivalootMax]; <br>    ULONG ulInstanceKey = 1; <br>    OOUSR_ENTRYID EntryID; <br> <br>    /* <br>     *  Validate Parameters <br>     */ <br>      <br>     <br>    Validate_IABLogon_GetOneOffTable(lpABPLogon, ulFlags, lppTable); <br> <br> <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceArg( APBLOGON_GetOneOffTable, "UNICODE not supported" ); <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>     <br>     <br>    EnterCriticalSection(&amp;lpABPLogon-&gt;cs); <br>     <br>    /* <br>     * If there's not one already associated with this logon object, <br>     * then create one. <br>     */ <br>    if (!lpABPLogon-&gt;lpTDatOO) <br>    { <br>        /* Create a Table data object */ <br>        sc = CreateTable( <br>            (LPIID) &amp;IID_IMAPITableData, <br>            lpABPLogon-&gt;lpAllocBuff, <br>            lpABPLogon-&gt;lpAllocMore, <br>            lpABPLogon-&gt;lpFreeBuff, <br>            lpABPLogon-&gt;lpMalloc, <br>            0, <br>            PR_DISPLAY_NAME_A, <br>            (LPSPropTagArray) &amp;tagaColSetOOTable, <br>            &amp;(lpABPLogon-&gt;lpTDatOO)); <br> <br>        if (FAILED(sc)) <br>        { <br>            hResult = ResultFromScode(sc); <br>            goto out; <br>        } <br> <br>        /* Constants*/ <br> <br>        sRow.cValues = ivalootMax; <br>        sRow.lpProps = rgsPropValue; <br> <br>        /* The Display Name */ <br>        rgsPropValue[ivalootPR_DISPLAY_NAME_A].ulPropTag = PR_DISPLAY_NAME_A; <br>        rgsPropValue[ivalootPR_DISPLAY_NAME_A].Value.lpszA = "Sample Address Book Recipient"; <br> <br>        /* the Entry ID*/ <br>        ZeroMemory(&amp;EntryID, sizeof(OOUSR_ENTRYID)); <br> <br>        EntryID.muid = muidABSample; <br>        EntryID.ulVersion = SAMP_VERSION; <br>        EntryID.ulType = SAMP_OOUSER; <br> <br>        rgsPropValue[ivalootPR_ENTRYID].ulPropTag = PR_ENTRYID; <br>        rgsPropValue[ivalootPR_ENTRYID].Value.bin.cb = sizeof(OOUSR_ENTRYID); <br>        rgsPropValue[ivalootPR_ENTRYID].Value.bin.lpb = (LPVOID) &amp;EntryID; <br> <br>        /* the depth property */ <br>        rgsPropValue[ivalootPR_DEPTH].ulPropTag = PR_DEPTH; <br>        rgsPropValue[ivalootPR_DEPTH].Value.l = 0; <br> <br>        /* the selectable property */ <br>        rgsPropValue[ivalootPR_SELECTABLE].ulPropTag = PR_SELECTABLE; <br>        rgsPropValue[ivalootPR_SELECTABLE].Value.b = TRUE; <br> <br>        /* <br>         *  The address type that would be generated by an entry <br>         *  created from this template <br>         */ <br>        rgsPropValue[ivalootPR_ADDRTYPE_A].ulPropTag = PR_ADDRTYPE; <br>        rgsPropValue[ivalootPR_ADDRTYPE_A].Value.lpszA = lpszEMT; <br> <br>        /* <br>         *  The display type associated with a recipient built with this template <br>         */ <br>        rgsPropValue[ivalootPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE; <br>        rgsPropValue[ivalootPR_DISPLAY_TYPE].Value.l = DT_MAILUSER; <br> <br> <br>        /* <br>         *  The instance key of this row in this one-off table.  Since there's only one <br>         *  row in this one-off table, just default it to a value of 1. <br>         */ <br>        rgsPropValue[ivalootPR_INSTANCE_KEY].ulPropTag = PR_INSTANCE_KEY; <br>        rgsPropValue[ivalootPR_INSTANCE_KEY].Value.bin.cb = sizeof(ULONG); <br>        rgsPropValue[ivalootPR_INSTANCE_KEY].Value.bin.lpb = (LPBYTE) &amp;ulInstanceKey; <br> <br>        (void) lpABPLogon-&gt;lpTDatOO-&gt;lpVtbl-&gt;HrModifyRow( <br>                            lpABPLogon-&gt;lpTDatOO, <br>                            &amp;sRow); <br> <br>    } <br> <br>    /* <br>     *  Get a view to return to the caller <br>     */ <br>    hResult = lpABPLogon-&gt;lpTDatOO-&gt;lpVtbl-&gt;HrGetView( <br>        lpABPLogon-&gt;lpTDatOO, <br>        NULL, <br>        NULL, <br>        0, <br>        (LPMAPITABLE *) lppTable); <br> <br>out: <br> <br>    LeaveCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    DebugTraceResult(ABPLogon_GetOneOffTable, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_Advise <br> - <br> *  NYI <br> * <br> * <br> */ <br>STDMETHODIMP <br>ABPLOGON_Advise(LPABPLOGON lpABPLogon, <br>    ULONG cbEntryID, <br>    LPENTRYID lpEntryID, <br>    ULONG ulEventMask, <br>    LPMAPIADVISESINK lpAdviseSink, <br>    ULONG FAR * lpulConnection) <br>{ <br>    DebugTraceSc(ABPLOGON_Advise, MAPI_E_NO_SUPPORT); <br>    return ResultFromScode(MAPI_E_NO_SUPPORT); <br>} <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_Unadvise <br> - <br> *  NYI <br> * <br> * <br> */ <br>STDMETHODIMP <br>ABPLOGON_Unadvise(LPABPLOGON lpABPLogon, ULONG ulConnection) <br>{ <br>    DebugTraceSc(ABPLOGON_Unadvise, MAPI_E_NO_SUPPORT); <br>    return ResultFromScode(MAPI_E_NO_SUPPORT); <br>} <br> <br>/************************************************************************* <br> * <br> -  ABPLOGON_PrepareRecips <br> - <br> * <br> * <br> * <br> */ <br>STDMETHODIMP <br>ABPLOGON_PrepareRecips(LPABPLOGON lpABPLogon, <br>    ULONG ulFlags, <br>    LPSPropTagArray lpPropTagArray, <br>    LPADRLIST lpRecipList) <br>{ <br>    HRESULT         hResult         = hrSuccess; <br>    UINT            iRecip; <br>    UINT            iProp; <br>    ULONG           cValues; <br>    LPSPropValue    lpspvUser       = NULL; <br>    LPSPropValue    lpNewRecip      = NULL; <br>    LPMAPIPROP      lpMAPIPropEntry = NULL; <br>    SCODE           sc              = S_OK; </code></pre>
<p>
</p>
<pre><code>ULONG           ulObjType; <br>    BOOL            fUselpspvUser; <br> <br>    /* loop through all the recipients */ <br>     <br>    if (!lpPropTagArray) <br>    { <br>        /* <br>         *  They only want us to update our entryID from ephemeral to <br>         *  permanent.  Since ours are already permanent, we don't need to <br>         *  do anything. <br>         */ <br>        goto out; <br>    } <br> <br>    for (iRecip = 0; iRecip &lt; lpRecipList-&gt;cEntries; iRecip++) <br>    { <br>        LPUSR_ENTRYID   lpEntryID   = NULL; <br>        ULONG           cbEntryID; <br>        LPSPropValue    lpPropVal       = NULL; <br>        LPSPropValue    rgpropvalsRecip = lpRecipList-&gt;aEntries[iRecip].rgPropVals; <br>        ULONG           cPropsRecip     = lpRecipList-&gt;aEntries[iRecip].cValues; <br> <br>        /* For each recipient, find its entryid */ <br>         <br>        lpPropVal = PpropFindProp( rgpropvalsRecip, cPropsRecip, PR_ENTRYID ); <br>         <br>        if ( lpPropVal ) <br>        { <br>            lpEntryID = (LPUSR_ENTRYID)lpPropVal-&gt;Value.bin.lpb; <br>            cbEntryID = lpPropVal-&gt;Value.bin.cb; <br>        } <br>        else <br>            continue; <br>                 <br>        /* Is it one of ours? */ <br>          <br>        if ( cbEntryID &lt; CbNewENTRYID(0) <br>            || IsBadReadPtr( (LPVOID) lpEntryID, (UINT) cbEntryID ) ) <br>        { <br>            continue;   /* no */ <br>        } <br>          <br>        if ( memcmp( &amp;(lpEntryID-&gt;muid), &amp;muidABSample, sizeof(MAPIUID) ) ) <br>            continue;   /* no */ <br> <br>        /* Try and open it. */ <br>          <br>        hResult = HrNewSampUser((LPMAILUSER *)&amp;lpMAPIPropEntry, <br>                                &amp;ulObjType,  <br>                                cbEntryID,  <br>                                (LPENTRYID) lpEntryID,  <br>                                (LPABLOGON) lpABPLogon, <br>                                NULL,  <br>                                lpABPLogon-&gt;hLibrary, <br>                                lpABPLogon-&gt;lpAllocBuff, <br>                                lpABPLogon-&gt;lpAllocMore, <br>                                lpABPLogon-&gt;lpFreeBuff, <br>                                lpABPLogon-&gt;lpMalloc ); <br> <br>        if ( HR_FAILED(hResult) ) <br>        { <br>             /* Couldn't open it...; Ignore it and keep looking */ <br> <br>            hResult = hrSuccess; <br>            DebugTrace( "ABPLOGON_PrepareRecips sees a bad user entry ID\n" ); <br>            continue; <br>        } <br> <br>        /* Get the properties requested */ <br> <br>        hResult = lpMAPIPropEntry-&gt;lpVtbl-&gt;GetProps( lpMAPIPropEntry,  <br>                lpPropTagArray, 0, /* ansi */ <br>                &amp;cValues, &amp;lpspvUser ); <br> <br>        /* No longer need lpMAPIPropEntry  */ <br>         <br>        lpMAPIPropEntry-&gt;lpVtbl-&gt;Release(lpMAPIPropEntry); <br>        lpMAPIPropEntry = NULL; <br> <br>        if (HR_FAILED(hResult)) <br>        { <br>            /* Failed getting properties. Cleanup and ignore this entry */ <br> <br>            hResult = hrSuccess; <br>            continue; <br>        } <br>         <br>        hResult = hrSuccess; <br> <br>        Assert(cValues == lpPropTagArray-&gt;cValues); <br> <br>        /* <br>         *  This is the hard part. <br>         *  Merge the two property sets: lpspvUser and lpsPropVal.  Note that <br>         *  both of these sets may have the same property - chances are they do. <br>         *  for these conflicts, lpspvUser should be the one we get the property <br>         *  from. <br>         * <br>         *  Guess how big the resultant SPropValue array is, and allocate one of that <br>         *  size. <br>         */ <br> <br>        sc = lpABPLogon-&gt;lpAllocBuff( (cValues + cPropsRecip) * sizeof( SPropValue ),  <br>                &amp;lpNewRecip); <br>        if (FAILED(sc)) <br>        { <br>            /* <br>             *  Ok, to fail the call here.  If we're running into out of memory conditions <br>             *  we're all in trouble. <br>             */ <br> <br>            hResult = ResultFromScode( sc ); <br>            goto err; <br>        } <br> <br>        /* <br>         *  Copy lpspvUser properties over to lpNewRecip <br>         *  Check each property in lpsvUser to ensure that it isn't PT_ERROR, if so <br>         *  find the propval in rgpropvalsRecip ( the [in] recip prop val array ),  <br>         *  if it exists and use that property. <br>         */ <br>         <br>        for (iProp = 0; iProp &lt; cValues; iProp++) <br>        { <br>            fUselpspvUser = TRUE; <br>             <br>            if ( PROP_TYPE( lpspvUser[iProp].ulPropTag ) == PT_ERROR ) <br>            { <br>                lpPropVal = PpropFindProp( rgpropvalsRecip, cPropsRecip, <br>                         lpPropTagArray-&gt;aulPropTag[iProp] ); <br>                          <br>                if ( lpPropVal ) <br>                { <br>                    sc = PropCopyMore(  lpNewRecip + iProp, lpPropVal, <br>                            lpABPLogon-&gt;lpAllocMore, lpNewRecip ); <br>                             <br>                    fUselpspvUser = FALSE;       <br>                } <br>            } <br>                 <br>            if ( fUselpspvUser ) <br>            { <br>                sc = PropCopyMore(  lpNewRecip + iProp, lpspvUser + iProp, <br>                        lpABPLogon-&gt;lpAllocMore, lpNewRecip ); <br>            } <br>             <br>            if (FAILED(sc)) <br>            { <br>                if (sc == MAPI_E_NOT_ENOUGH_MEMORY) <br>                { <br>                    hResult = MakeResult(sc); <br>                    goto err; <br>                } <br>                 <br>                /* <br>                 *   Otherwise we've run into something wierd in the prop value array <br>                 *   like PT_UNSPECIFIED, PT_NULL, or PT_OBJECT.  In which case continue <br>                 *   on. <br>                 */ <br>            } <br>        } <br>         <br>        /* Done with lpspvUser */ <br>         <br>        lpABPLogon-&gt;lpFreeBuff( lpspvUser ); <br>        lpspvUser = NULL; <br> <br>        /* <br>         *  Copy those properties that aren't already in lpNewRecip <br>         *  from rgpropvalsRecip.  Don't copy over the PT_ERROR prop vals <br>         */ <br>        for ( iProp = 0; iProp &lt; cPropsRecip; iProp++ ) <br>        { <br>         <br>            if ( PpropFindProp( lpNewRecip, cValues, rgpropvalsRecip[iProp].ulPropTag )  <br>                || PROP_TYPE( rgpropvalsRecip[iProp].ulPropTag ) == PT_ERROR ) <br>                continue; <br> <br>            sc = PropCopyMore(  lpNewRecip + cValues, rgpropvalsRecip + iProp, <br>                    lpABPLogon-&gt;lpAllocMore, lpNewRecip ); <br>            if ( FAILED( sc ) ) <br>            { <br>                if (sc == MAPI_E_NOT_ENOUGH_MEMORY) <br>                { <br>                      <br>                    hResult = ResultFromScode( sc ); <br>                    goto err; <br>                } <br>                 <br>                /* <br>                 *  Otherwise we've run into something wierd in the prop value array <br>                 *  like PT_UNSPECIFIED, PT_NULL, or PT_OBJECT.  In which case continue <br>                 *  on. <br>                 */ <br>            } <br>             <br>            cValues++; <br>        } <br> <br>        /* <br>         *  Replace the AdrEntry in the AdrList with this new lpNewRecip.  And <br>         *  don't forget the cValues! <br>         */ <br> <br>        lpRecipList-&gt;aEntries[iRecip].rgPropVals = lpNewRecip; <br>        lpRecipList-&gt;aEntries[iRecip].cValues    = cValues; <br> <br>        /* Finally, free up the old AdrEntry. */ <br> <br>        lpABPLogon-&gt;lpFreeBuff( rgpropvalsRecip ); <br> <br>    } <br>out: <br> <br>    DebugTraceResult( ABPLOGON_PrepareRecips, hResult ); <br>    return hResult; <br> <br>err: <br> <br>    lpABPLogon-&gt;lpFreeBuff( lpspvUser ); <br>    goto out; <br>} <br> <br> <br>/* <br> *  LpMuidFromLogon - <br> *    Returns the particular ABPLOGON object's unique identifier. <br> * <br> */   <br> <br>LPMAPIUID <br>LpMuidFromLogon(LPABLOGON lpABLogon) <br>{ <br>    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon; <br> <br>    AssertSz(!IsBadReadPtr(lpABPLogon, sizeof(ABPLOGON)), "Bad logon object!\n"); <br> <br>    return (&amp;(lpABPLogon-&gt;muidID)); <br>} <br> <br> <br>/* <br> *  HrLpszGetCurrentFileName - <br> *    Returns a copy of the current .SAB file pointed to by this logon object. <br> * <br> */ <br> <br>HRESULT <br>HrLpszGetCurrentFileName(LPABLOGON lpABLogon, LPSTR * lppszFileName) <br>{ <br>    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon; <br>    SCODE sc; <br>    HRESULT hResult = hrSuccess; <br> <br>    AssertSz(!IsBadReadPtr(lpABPLogon, sizeof(ABPLOGON)), "SAB: Bad logon object!\n"); <br>    AssertSz(!IsBadWritePtr(lppszFileName, sizeof(LPSTR)), "SAB: Bad dest string!\n"); <br> <br>    EnterCriticalSection(&amp;lpABPLogon-&gt;cs); <br>     <br>    sc = lpABPLogon-&gt;lpAllocBuff (lstrlenA(lpABPLogon-&gt;lpszFileName)+1, lppszFileName); <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto ret; <br>    } <br> <br>    lstrcpyA( *lppszFileName, lpABPLogon-&gt;lpszFileName); <br>     <br>ret: <br>    LeaveCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    DebugTraceResult(HrLpszGetCurrentFileName, hResult); <br>    return hResult; <br>} <br> <br>/* <br> *  HrReplaceCurrentFileName - <br> *    Replaces the current file name associated with this logon object and tries <br> *    to save it all away in the profile. <br> */ <br> <br>HRESULT <br>HrReplaceCurrentFileName(LPABLOGON lpABLogon, LPSTR lpszNewFile) <br>{ <br>    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon; <br>    HRESULT hResult = hrSuccess; <br>    LPPROFSECT lpProfSect = NULL; <br>    LPSTR lpstrT; <br>    SCODE sc; <br>    SPropValue rgspv[1]; <br> <br>    AssertSz(!IsBadReadPtr(lpABPLogon, sizeof(ABPLOGON)), "Bad logon object!\n"); <br>     <br>    EnterCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    /* <br>     *  SAB file name has changed have to update profile and objects <br>     */ <br>    if (lstrcmpA(lpszNewFile, lpABPLogon-&gt;lpszFileName)) <br>    { <br> <br>        /* <br>         *  Open the private profile section... <br>         */ <br>        hResult = lpABPLogon-&gt;lpMapiSup-&gt;lpVtbl-&gt;OpenProfileSection( <br>            lpABPLogon-&gt;lpMapiSup, <br>            NULL, <br>            MAPI_MODIFY, <br>            &amp;lpProfSect); <br>        if (HR_FAILED(hResult)) <br>        { <br>            /* <br>             *  Shouldn't get here, but in case I do, just... <br>             */ <br>            goto ret; <br>        } <br> <br>        /* <br>         *  Save the new name back into the profile <br>         */ <br>        rgspv[0].ulPropTag = PR_SAB_FILE; <br>        rgspv[0].Value.lpszA = lpszNewFile; <br> <br>        /* <br>         *  Don't care if I can save it in the profile or not. <br>         *  Saving it's a nice to have, but absolutely required <br>         *  for operation of this particular provider. <br>         */ <br>        (void) lpProfSect-&gt;lpVtbl-&gt;SetProps( <br>            lpProfSect, <br>            1, <br>            rgspv, <br>            NULL); <br> <br>        lpProfSect-&gt;lpVtbl-&gt;Release(lpProfSect); <br> <br>        /* <br>         *  Allocate and copy this new one <br>         */ <br> <br>        sc = lpABPLogon-&gt;lpAllocBuff (lstrlenA(lpszNewFile)+1, &amp;lpstrT); <br>        if (FAILED(sc)) <br>        { <br>            hResult = ResultFromScode(sc); <br>            goto ret; <br>        } <br> <br>        lstrcpyA( lpstrT, lpszNewFile ); <br> <br>        /* <br>         *  Free up the old one... <br>         */ <br>        lpABPLogon-&gt;lpFreeBuff(lpABPLogon-&gt;lpszFileName); <br> <br>        /* <br>         *  Put in the new one. <br>         */ <br>        lpABPLogon-&gt;lpszFileName = lpstrT; <br> <br>        /* <br>         *  Update the hierarchy table <br>         */ <br>        hResult = HrBuildRootHier((LPABLOGON)lpABPLogon, NULL); <br>    } <br> <br>ret: <br>    LeaveCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    DebugTraceResult(HrReplaceCurrentFileName, hResult); <br>    return hResult; <br>} <br> <br>/* <br> *  GenerateContainerDN - <br> *      Common code for generating the display name of the single <br> *      container exposed from this logon object. <br> */ <br>void <br>GenerateContainerDN(LPABLOGON lpABLogon, LPSTR lpszName) <br>{ <br>    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon; <br>    LPSTR lpszFileName; <br>    int ich; <br> <br>    AssertSz(!IsBadReadPtr(lpABPLogon, sizeof(ABPLOGON)), "Bad logon object!\n"); <br>     <br> <br>    EnterCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    lpszFileName = lpABPLogon-&gt;lpszFileName; <br> <br>    /* get the filename without the path */ <br>    for (ich = lstrlenA(lpszFileName) - 1; ich &gt;= 0; ich--) <br>    { <br>        if (lpszFileName[ich] == '\\') <br>            break; <br>    } <br> <br>    /* skip past the backslash */ <br>    ich++; <br> <br>    wsprintfA(lpszName, "SAB using %s", lpszFileName + ich); <br> <br>    LeaveCriticalSection(&amp;lpABPLogon-&gt;cs); <br>} <br> <br>/* <br> -  HrBuildRootHier <br> - <br> * <br> *  Builds up the root hierarchy for the Sample Address Book.   <br> * <br> * <br> */ <br>enum {  ivalPR_DISPLAY_NAME_A = 0, <br>        ivalPR_ENTRYID, <br>        ivalPR_DEPTH, <br>        ivalPR_OBJECT_TYPE, <br>        ivalPR_DISPLAY_TYPE, <br>        ivalPR_CONTAINER_FLAGS, <br>        ivalPR_INSTANCE_KEY, <br>        ivalPR_AB_PROVIDER_ID, <br>        cvalMax }; <br> <br>static const SizedSPropTagArray(cvalMax, tagaRootColSet) = <br>{ <br>    cvalMax, <br>    { <br>        PR_DISPLAY_NAME_A, <br>        PR_ENTRYID, <br>        PR_DEPTH, <br>        PR_OBJECT_TYPE, <br>        PR_DISPLAY_TYPE, <br>        PR_CONTAINER_FLAGS, <br>        PR_INSTANCE_KEY, <br>        PR_AB_PROVIDER_ID <br>    } <br>}; <br> <br>HRESULT <br>HrBuildRootHier(LPABLOGON lpABLogon, LPMAPITABLE * lppMAPITable) <br>{ <br>    HRESULT hResult; <br>    SCODE sc; <br>    SRow sRow; <br>    SPropValue rgsPropValue[cvalMax]; <br>    ULONG ulInstanceKey = 1; <br>    char szBuf[MAX_PATH]; <br>    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon; <br>    DIR_ENTRYID eidRoot =   {   {0, 0, 0, 0}, <br>                                MUIDABSAMPLE, <br>                                SAMP_VERSION, <br>                                SAMP_DIRECTORY }; <br>     <br> <br>    EnterCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    /* <br>     *  See if we have a TaD yet <br>     */ <br>    if (!lpABPLogon-&gt;lpTDatRoot) <br>    { <br>        /* Create a Table Data object */ <br>        if (sc = CreateTable((LPIID) &amp;IID_IMAPITableData, <br>                    lpABPLogon-&gt;lpAllocBuff, <br>                    lpABPLogon-&gt;lpAllocMore, <br>                    lpABPLogon-&gt;lpFreeBuff, <br>                    lpABPLogon-&gt;lpMalloc, <br>                    0, <br>                    PR_ENTRYID, <br>                    (LPSPropTagArray) &amp;tagaRootColSet, <br>                    &amp;(lpABPLogon-&gt;lpTDatRoot))) <br>        { <br>            hResult = ResultFromScode(sc); <br>            goto out; <br>        } <br>    } <br>    /* Constants */ <br> <br>    sRow.cValues = cvalMax; <br>    sRow.lpProps = rgsPropValue; <br> <br> <br>    /* First, the Display Name stuff*/ <br> <br>    rgsPropValue[ivalPR_DISPLAY_NAME_A].ulPropTag   = PR_DISPLAY_NAME_A; <br>    GenerateContainerDN((LPABLOGON) lpABPLogon, szBuf); <br>    rgsPropValue[ivalPR_DISPLAY_NAME_A].Value.lpszA = szBuf; <br> <br>    /* <br>     *  For each SAB logon object associated with it's init object, <br>     *  we have a unique MAPIUID.  It's the only thing that distinguishes <br>     *  one SAB entryid from another in the merged hierarchy table that <br>     *  MAPI generates. <br>     */ <br> <br>    rgsPropValue[ivalPR_ENTRYID].ulPropTag          = PR_ENTRYID; <br>    eidRoot.muidID = lpABPLogon-&gt;muidID; <br>    rgsPropValue[ivalPR_ENTRYID].Value.bin.cb       = sizeof(DIR_ENTRYID); <br>    rgsPropValue[ivalPR_ENTRYID].Value.bin.lpb      = (LPVOID) &amp;eidRoot; <br> <br> <br>    rgsPropValue[ivalPR_DEPTH].ulPropTag            = PR_DEPTH; <br>    rgsPropValue[ivalPR_DEPTH].Value.l              = 0; <br> <br> <br>    rgsPropValue[ivalPR_OBJECT_TYPE].ulPropTag      = PR_OBJECT_TYPE; <br>    rgsPropValue[ivalPR_OBJECT_TYPE].Value.l        = MAPI_ABCONT; <br> <br> <br>    rgsPropValue[ivalPR_DISPLAY_TYPE].ulPropTag     = PR_DISPLAY_TYPE; <br>    rgsPropValue[ivalPR_DISPLAY_TYPE].Value.l       = DT_NOT_SPECIFIC; <br> <br> <br>    rgsPropValue[ivalPR_CONTAINER_FLAGS].ulPropTag  = PR_CONTAINER_FLAGS; <br>    rgsPropValue[ivalPR_CONTAINER_FLAGS].Value.l    = AB_RECIPIENTS | AB_UNMODIFIABLE; <br> <br> <br>    rgsPropValue[ivalPR_INSTANCE_KEY].ulPropTag     = PR_INSTANCE_KEY; <br>    rgsPropValue[ivalPR_INSTANCE_KEY].Value.bin.cb  = sizeof(ULONG); <br>    rgsPropValue[ivalPR_INSTANCE_KEY].Value.bin.lpb = (LPBYTE) &amp;ulInstanceKey; <br> <br> <br>    rgsPropValue[ivalPR_AB_PROVIDER_ID].ulPropTag   = PR_AB_PROVIDER_ID; <br>    rgsPropValue[ivalPR_AB_PROVIDER_ID].Value.bin.cb= sizeof(MAPIUID); <br>    rgsPropValue[ivalPR_AB_PROVIDER_ID].Value.bin.lpb= (LPBYTE) &amp;muidSABProviderID; <br> <br>    hResult = lpABPLogon-&gt;lpTDatRoot-&gt;lpVtbl-&gt;HrModifyRow( <br>        lpABPLogon-&gt;lpTDatRoot, &amp;sRow); <br> <br>    if (HR_FAILED(hResult)) <br>        goto out; <br> <br> <br>    /* <br>     *  Check to see if they want a view returned as well <br>     */ <br>    if (lppMAPITable) <br>    { <br>        /* Get a view from the Table data object */ <br>        hResult = <br>            lpABPLogon-&gt;lpTDatRoot-&gt;lpVtbl-&gt;HrGetView( <br>            lpABPLogon-&gt;lpTDatRoot, <br>            NULL, <br>            NULL, <br>            0, <br>            lppMAPITable); <br>    } <br> <br>out: <br> <br>    LeaveCriticalSection(&amp;lpABPLogon-&gt;cs); <br>     <br>    DebugTraceResult(HrBuildRootHier, hResult); <br>    return hResult; <br>} <br> <br> <br> <br>/* <br> *  Checks to see if the file passed in is still the actual file that <br> *  should be browsed. <br> */ <br>BOOL <br>FEqualSABFiles( LPABLOGON lpABLogon, <br>                LPSTR lpszFileName) <br>{ <br>    LPABPLOGON lpABPLogon = (LPABPLOGON) lpABLogon; <br>    BOOL fEqual; <br> <br>    AssertSz(!IsBadReadPtr(lpABPLogon, sizeof(ABPLOGON)), "Bad logon object!\n"); <br>     <br>    EnterCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    fEqual = !lstrcmpA( lpszFileName, lpABPLogon-&gt;lpszFileName ); <br> <br>    LeaveCriticalSection(&amp;lpABPLogon-&gt;cs); <br> <br>    return fEqual; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
