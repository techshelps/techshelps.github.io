<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TID.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2121"></a>TID.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  TID.C <br> * <br> *  Sample Address Book Template ID  object <br> *  This file contains the code for implementing a template ID object <br> *  that is associated with entries from this provider.  In particular <br> *  the MailUser object generated in ABUSER.C needs this TID object when <br> *  it's been copied into another provider (i.e. the PAB). <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br> <br>#include "abp.h" <br> <br>/* <br> *  Declaration of IMailUser object implementation <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _TID <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_DECLARE(type, method, TID_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   MAPIMETHOD_TYPEDEF(type, method, TID_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPIPROP_METHODS(IMPL) <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type, method)   STDMETHOD_(type, method) <br> <br>DECLARE_MAPI_INTERFACE(TID_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPIPROP_METHODS(IMPL) <br>}; <br> <br> <br>/* <br> *  The definition of the TID object <br> */ <br>typedef struct _TID { <br> <br>    const TID_Vtbl * lpVtbl; <br> <br>    SAB_Wrapped; <br>     <br>    /* <br>     *  Private data <br>     */ <br>    LPMAILUSER  lpABUser; <br> <br>} TID, *LPTID; <br> <br>/* <br> *  TID jump table is defined here... <br> */ <br> <br>static const TID_Vtbl vtblTID = <br>{ <br>    (TID_QueryInterface_METHOD *)   ABU_QueryInterface, <br>    (TID_AddRef_METHOD *)           WRAP_AddRef, <br>    TID_Release, <br>    (TID_GetLastError_METHOD *)     WRAP_GetLastError, <br>    (TID_SaveChanges_METHOD *)      WRAP_SaveChanges, <br>    (TID_GetProps_METHOD *)         WRAP_GetProps, <br>    (TID_GetPropList_METHOD *)      WRAP_GetPropList, <br>    TID_OpenProperty, <br>    (TID_SetProps_METHOD *)         WRAP_SetProps, <br>    (TID_DeleteProps_METHOD *)      WRAP_DeleteProps, <br>    (TID_CopyTo_METHOD *)           WRAP_CopyTo, <br>    (TID_CopyProps_METHOD *)        WRAP_CopyProps, <br>    (TID_GetNamesFromIDs_METHOD *)  WRAP_GetNamesFromIDs, <br>    (TID_GetIDsFromNames_METHOD *)  WRAP_GetIDsFromNames, <br>}; <br> <br>/************************************************************************* <br> * <br> -  NewTID <br> - <br> *  Creates the TID object associated with a mail user. <br> * <br> * <br> */ <br>HRESULT <br>HrNewTID(LPMAPIPROP *       lppMAPIPropNew, <br>        ULONG               cbTemplateId, <br>        LPENTRYID           lpTemplateId, <br>        ULONG               ulTemplateFlags, <br>        LPMAPIPROP          lpPropData, <br>        LPABLOGON           lpABPLogon, <br>        LPCIID              lpInterface, <br>        HINSTANCE           hLibrary, <br>        LPALLOCATEBUFFER    lpAllocBuff, <br>        LPALLOCATEMORE      lpAllocMore, <br>        LPFREEBUFFER        lpFreeBuff, <br>        LPMALLOC            lpMalloc ) <br>{ <br>    LPTID lpTID = NULL; <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    LPMAILUSER lpABUser = NULL; <br>    ULONG ulObjType; <br> <br>    /* <br>     *  Create the user object corresponding to the template id <br>     */ <br>    hr = HrNewSampUser( &amp;lpABUser, <br>                        &amp;ulObjType, <br>                        cbTemplateId, <br>                        lpTemplateId, <br>                        lpABPLogon, <br>                        lpInterface, <br>                        hLibrary, <br>                        lpAllocBuff, <br>                        lpAllocMore, <br>                        lpFreeBuff, <br>                        lpMalloc); <br>    if (HR_FAILED(hr)) <br>    { <br>        goto err; <br>    } <br> <br>    Assert(ulObjType == MAPI_MAILUSER); <br>    /* <br>     *  Allocate space for the TID structure <br>     */ <br>    sc = lpAllocBuff(sizeof(TID), (LPVOID *) &amp;lpTID); <br>    if (FAILED(sc)) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    /* <br>     *  Initialize the TID structure <br>     */ <br> <br>    lpTID-&gt;lpVtbl = &amp;vtblTID; <br>    lpTID-&gt;lcInit = 1; <br>    lpTID-&gt;hResult = hrSuccess; <br>    lpTID-&gt;idsLastError = 0; <br>    lpTID-&gt;hLibrary = hLibrary; <br>    lpTID-&gt;lpAllocBuff = lpAllocBuff; <br>    lpTID-&gt;lpAllocMore = lpAllocMore; <br>    lpTID-&gt;lpFreeBuff = lpFreeBuff; <br>    lpTID-&gt;lpMalloc = lpMalloc; <br>    lpTID-&gt;lpABLogon = lpABPLogon; <br>    lpTID-&gt;lpPropData = lpPropData; <br>    lpTID-&gt;lpABUser = (LPMAILUSER) lpABUser; <br> <br> <br>    if (ulTemplateFlags &amp; FILL_ENTRY) <br>    { <br>        ULONG ulCount; <br>        LPSPropValue lpspv = NULL; <br> <br>        /* <br>         *  Copy all the properties from my object to the propdata <br>         */ <br>        hr = lpABUser-&gt;lpVtbl-&gt;GetProps(lpABUser, <br>            NULL, <br>            0,      /* ansi */ <br>            &amp;ulCount, <br>            &amp;lpspv); <br> <br>        if (HR_FAILED(hr)) <br>            goto err; <br> <br>        hr = lpPropData-&gt;lpVtbl-&gt;SetProps(lpPropData, <br>            ulCount, <br>            lpspv, <br>            NULL); <br> <br>        lpFreeBuff(lpspv); <br> <br>        if (HR_FAILED(hr)) <br>            goto err; <br>    } <br> <br>    /* <br>     *  AddRef lpPropData so we can use it after we return <br>     */ <br> <br>    (void)lpPropData-&gt;lpVtbl-&gt;AddRef(lpPropData); <br> <br>    InitializeCriticalSection(&amp;lpTID-&gt;cs); <br> <br>    /*  We must AddRef the lpABPLogon object since we will be using it <br>     */ <br>    lpABPLogon-&gt;lpVtbl-&gt;AddRef(lpABPLogon); <br> <br>    *lppMAPIPropNew = (LPVOID) lpTID; <br> <br>out: <br> <br>    DebugTraceResult(HrNewTID, hr); <br>    return hr; <br> <br>err: <br> <br>    if (lpABUser) <br>        lpABUser-&gt;lpVtbl-&gt;Release(lpABUser); <br>     <br>    lpFreeBuff(lpTID); <br> <br>    goto out; <br>} <br> <br>/* <br> -  TID_Release <br> - <br> *  Releases the TID object.  The main difference between this <br> *  Release and WRAP_Release() is that it also has to release the <br> *  lpABUser object. <br> * <br> *  Note the Release on the lpPropData.  This required because of <br> *  WRAP's implementation of IUnknown (which this object reuses). <br> */ <br> <br>STDMETHODIMP_(ULONG) TID_Release(LPTID lpTID) <br>{ <br>    LONG lcInit; <br> <br>    /* <br>     * Check to see if it's large enough to hold this object <br>     */ <br>    if (IsBadReadPtr(lpTID, sizeof(TID))) <br>    { <br>        /* <br>         *  I'm not looking at an object that I expect to be. <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Check to see that it's TIDs vtbl <br>     */ <br>    if (lpTID-&gt;lpVtbl != &amp;vtblTID) <br>    { <br>        /* <br>         *  It's big enough but it's got the wrong vtbl. <br>         */ <br>        return 1; <br>    } <br> <br>    /* <br>     *  Release the mapi property object <br>     */ <br>    lpTID-&gt;lpPropData-&gt;lpVtbl-&gt;Release( <br>        lpTID-&gt;lpPropData); <br> <br>    EnterCriticalSection(&amp;lpTID-&gt;cs); <br>    lcInit = --lpTID-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpTID-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br>        /* <br>         *  Release the ABUser object <br>         */ <br>        lpTID-&gt;lpABUser-&gt;lpVtbl-&gt;Release( <br>            lpTID-&gt;lpABUser); <br> <br>        /*   <br>         *  Release our reference to the ABLogon object. <br>         */ <br>        if (lpTID-&gt;lpABLogon) <br>        { <br>            lpTID-&gt;lpABLogon-&gt;lpVtbl-&gt;Release(lpTID-&gt;lpABLogon); <br>            lpTID-&gt;lpABLogon = NULL; <br>        } <br> <br>        /* <br>         *  Clean up the critical section <br>         */ <br>        DeleteCriticalSection(&amp;lpTID-&gt;cs); <br> <br>        /* <br>         * Need to free the object <br>         */ <br>        lpTID-&gt;lpFreeBuff(lpTID); <br>        return 0; <br>    } <br> <br>    return lcInit; <br>} <br> <br>/* <br> -  TID_OpenProperty <br> - <br> *  Satisfies the object that are needed to support the "Options" details pane <br> *  associated with the MailUser object from ABUSER.C. <br> * <br> *  Note:  We are masking error strings that might be possible to get from the <br> *  lpABUser object.  Since (for the most part) the only errors that can be returned <br> *  from this object are resource failure types, it wouldn't be of much use to the <br> *  user. <br> */ <br> <br>STDMETHODIMP <br>TID_OpenProperty(LPTID lpTID, <br>    ULONG ulPropTag, <br>    LPCIID lpiid, <br>    ULONG ulInterfaceOptions, <br>    ULONG ulFlags, <br>    LPUNKNOWN * lppUnk) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it's large enough to hold this object <br>     */ <br>    if (IsBadReadPtr(lpTID, sizeof(TID))) <br>    { <br>        /* <br>         *  No vtbl found <br>         */ <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /* <br>     *  Check to see that it's TIDs vtbl <br>     */ <br>    if (lpTID-&gt;lpVtbl != &amp;vtblTID) <br>    { <br>        /* <br>         *  It's big enough but it's got the wrong vtbl. <br>         */ <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    if ( ulInterfaceOptions &amp; ~MAPI_UNICODE ) <br>    { <br>        DebugTraceArg( TID_OpenProperty, "unknown flags" ); <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceArg( TID_OpenProperty, "bad character width" ); <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>    /* <br>     *  Don't want to check any other parameters here. <br>     *  Calls down to wrapped objects will do this for <br>     *  me. <br>     */ <br> <br>    switch (ulPropTag) <br>    { <br>        case PR_LISTBOX_TABLE: <br>        case PR_DDLISTBOX_TABLE: <br>        case PR_COMBOBOX_TABLE: <br>        { <br>            hResult = lpTID-&gt;lpABUser-&gt;lpVtbl-&gt;OpenProperty( <br>                lpTID-&gt;lpABUser, <br>                ulPropTag, <br>                lpiid, <br>                ulInterfaceOptions, <br>                ulFlags, <br>                lppUnk); <br>            break; <br> <br>        } <br> <br>        default: <br>        { <br>            hResult = lpTID-&gt;lpPropData-&gt;lpVtbl-&gt;OpenProperty( <br>                lpTID-&gt;lpPropData, <br>                ulPropTag, <br>                lpiid, <br>                ulInterfaceOptions, <br>                ulFlags, <br>                lppUnk); <br>            break; <br>        } <br>    } <br> <br>    DebugTraceResult(TID_OpenProperty, hResult); <br>    return hResult; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
