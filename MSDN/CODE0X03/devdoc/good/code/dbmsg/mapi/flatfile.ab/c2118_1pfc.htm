<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ABCONT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2118"></a>ABCONT.C</h2>
<pre><code>/*********************************************************************** <br> * <br> *  ABCONT.C <br> * <br> *  Sample AB directory container object <br> * <br> *  This file contains the code for implementing the Sample AB <br> *  directory container object. <br> * <br> *  This directory container was retrieved by OpenEntry on the entryid <br> *  retrieved from the single row of the hierarchy table (IVTROOT in root.c). <br> * <br> *  The following routines are implemented in this file: <br> * <br> *      HrNewSampDirectory <br> *      ABC_Release <br> *      ABC_SaveChanges <br> *      ABC_OpenProperty <br> *      ABC_GetContentsTable <br> *      ABC_GetHierarchyTable <br> * <br> *      HrGetDetailsDialog <br> * <br> *      HrNewABCButton <br> *      ABCBUTT_QueryInterface <br> *      ABCBUTT_Release <br> *      ABCBUTT_Activate <br> *      ABCBUTT_GetState <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> * <br> ***********************************************************************/ <br> <br>#include "abp.h" <br>#include "sampabp.rh" <br>#include &lt;smpab.h&gt; <br> <br> <br>/* <br> *  Proptags used only in this module <br> */ <br>#define PR_RADIO_BUTTON_VALUE       PROP_TAG(PT_LONG,   0x6601) <br>#define PR_BUTTON_PRESS             PROP_TAG(PT_OBJECT, 0x6603) <br>#define PR_SAB_FILE_TEMP            PROP_TAG(PT_TSTRING,0x6605) <br> <br> <br>/* <br> *  Possible values for PR_RADIO_BUTTON_VALUE <br> */ <br>#define RADIO_BUTTON_1_RETURN_VALUE 1 <br>#define RADIO_BUTTON_2_RETURN_VALUE 2 <br>#define RADIO_BUTTON_3_RETURN_VALUE 3 <br>#define RADIO_BUTTON_4_RETURN_VALUE 4 <br> <br> <br> <br>/* <br> *  Structure for the 'this' <br> */ <br> <br>typedef struct _ABCNT <br>{ <br>    const ABC_Vtbl FAR * lpVtbl; <br> <br>    SAB_Wrapped; <br> <br>    /* details display table */ <br>    LPTABLEDATA lpTDatDetails; <br> <br>} ABCNT, *LPABCNT; <br> <br> <br> <br>/* <br> *  This is the data structure passed to the <br> *  HrNotify method of the Table Data Object <br> *  in ABCBUTT_Activate that uniquely identifies <br> *  the control in the display table that needs <br> *  to be updated. <br> */ <br>typedef struct <br>{ <br>    MAPIUID muid; <br>    ULONG ulIdc; <br>} NOTIFDATA; <br> <br>/* <br> *  The actual data.  Note that the control <br> *  is specified by IDC_DIR_SAB_FILE_NAME. <br> */ <br>NOTIFDATA notifdata = <br>{MUIDABSAMPLE, IDC_DIR_SAB_FILE_NAME}; <br> <br> <br> <br>/* Display table control structures for the Directory property sheet. */ <br> <br>/* <br> *  Edit control that displays the current .SAB file. <br> */ <br>DTBLEDIT editDirFileName = <br>{ <br>    sizeof(DTBLEDIT), <br>    0, <br>    MAX_PATH, <br>    PR_SAB_FILE_TEMP <br>}; <br> <br> <br>/* <br> *  Button control for changing the current .SAB file. <br> */ <br>DTBLBUTTON buttonDirChange = <br>{ <br>    sizeof(DTBLBUTTON), <br>    0, <br>    PR_BUTTON_PRESS <br>}; <br> <br> <br>/* <br> *  The next four controls are radio buttons.  Note how they <br> *  are related by their use of PR_RADIO_BUTTON_VALUE and <br> *  differentiated by RADIO_BUTTON_x_RETURN_VALUE.  Also note <br> *  the '4' which says how many controls are in this group <br> *  of radio buttons. <br> */ <br>DTBLRADIOBUTTON radiobuttonDir1 = <br>{ <br>    sizeof(DTBLRADIOBUTTON), <br>    0, <br>    4, <br>    PR_RADIO_BUTTON_VALUE, <br>    RADIO_BUTTON_1_RETURN_VALUE <br>}; <br> <br>DTBLRADIOBUTTON radiobuttonDir2 = <br>{ <br>    sizeof(DTBLRADIOBUTTON), <br>    0, <br>    4, <br>    PR_RADIO_BUTTON_VALUE, <br>    RADIO_BUTTON_2_RETURN_VALUE <br>}; <br> <br>DTBLRADIOBUTTON radiobuttonDir3 = <br>{ <br>    sizeof(DTBLRADIOBUTTON), <br>    0, <br>    4, <br>    PR_RADIO_BUTTON_VALUE, <br>    RADIO_BUTTON_3_RETURN_VALUE <br>}; <br> <br>DTBLRADIOBUTTON radiobuttonDir4 = <br>{ <br>    sizeof(DTBLRADIOBUTTON), <br>    0, <br>    4, <br>    PR_RADIO_BUTTON_VALUE, <br>    RADIO_BUTTON_4_RETURN_VALUE <br>}; <br> <br> <br> <br>/* <br> *  This is the page for the directory details. <br> */ <br>DTCTL rgdtctlDirGeneral[] = <br>{ <br>    /* <br>     *  directory general propery page <br>     *  This names the pane for this page. <br>     *  Although not currently not required in <br>     *  this version, we expect to require it by <br>     *  the time MAPI 1.0 ships. <br>     */ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, <br>        &amp;dtblpage}, <br> <br>    /* controls and edit control containing sab file name */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, <br>        &amp;dtbllabel}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, <br>        &amp;dtbllabel}, <br>    {DTCT_EDIT, 0, (LPBYTE) &amp;notifdata, sizeof(NOTIFDATA), <br>        szNoFilter, IDC_DIR_SAB_FILE_NAME, &amp;editDirFileName}, <br> <br>    /* control and push button for changing sab file */ <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, <br>        &amp;dtbllabel}, <br>    {DTCT_BUTTON, 0, NULL, 0, NULL, IDC_DIR_CHANGE, <br>        &amp;buttonDirChange}, <br> <br>    /* radio button group box and radio buttons */ <br>    {DTCT_GROUPBOX, 0, NULL, 0, NULL, IDC_STATIC_CONTROL, <br>        &amp;dtblgroupbox}, <br>    {DTCT_RADIOBUTTON, DT_EDITABLE, NULL, 0, NULL, IDC_DIR_RADIO_1, <br>        &amp;radiobuttonDir1}, <br>    {DTCT_RADIOBUTTON, DT_EDITABLE, NULL, 0, NULL, IDC_DIR_RADIO_2, <br>        &amp;radiobuttonDir2}, <br>    {DTCT_RADIOBUTTON, DT_EDITABLE, NULL, 0, NULL, IDC_DIR_RADIO_3, <br>        &amp;radiobuttonDir3}, <br>    {DTCT_RADIOBUTTON, DT_EDITABLE, NULL, 0, NULL, IDC_DIR_RADIO_4, <br>        &amp;radiobuttonDir4}, <br>}; <br> <br>/* <br> * Display table pages for Directory Details <br> */ <br>DTPAGE rgdtpageDir[] = <br>{ <br>    { <br>        sizeof(rgdtctlDirGeneral) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(DirGeneralPage), <br>        "", <br>        rgdtctlDirGeneral <br>    } <br>}; <br> <br>/* <br> *  ABCont vtbl is filled in here. <br> */ <br>ABC_Vtbl vtblABC = <br>{ <br>    (ABC_QueryInterface_METHOD *)       ROOT_QueryInterface, <br>    (ABC_AddRef_METHOD *)               ROOT_AddRef,     <br>    ABC_Release, <br>    (ABC_GetLastError_METHOD *)         ROOT_GetLastError, <br>    ABC_SaveChanges, <br>    (ABC_GetProps_METHOD *)             WRAP_GetProps, <br>    (ABC_GetPropList_METHOD *)          WRAP_GetPropList, <br>    ABC_OpenProperty, <br>    (ABC_SetProps_METHOD *)             WRAP_SetProps, <br>    (ABC_DeleteProps_METHOD *)          WRAP_DeleteProps, <br>    (ABC_CopyTo_METHOD *)               WRAP_CopyTo, <br>    (ABC_CopyProps_METHOD *)            WRAP_CopyProps, <br>    (ABC_GetNamesFromIDs_METHOD *)      WRAP_GetNamesFromIDs, <br>    (ABC_GetIDsFromNames_METHOD *)      WRAP_GetIDsFromNames, <br>    ABC_GetContentsTable, <br>    ABC_GetHierarchyTable, <br>    (ABC_OpenEntry_METHOD *)            ROOT_OpenEntry, <br>    (ABC_SetSearchCriteria_METHOD *)    ROOT_SetSearchCriteria, <br>    (ABC_GetSearchCriteria_METHOD *)    ROOT_GetSearchCriteria, <br>    (ABC_CreateEntry_METHOD *)          ROOT_CreateEntry, <br>    (ABC_CopyEntries_METHOD *)          ROOT_CopyEntries, <br>    (ABC_DeleteEntries_METHOD *)        ROOT_DeleteEntries, <br>    (ABC_ResolveNames_METHOD *)         ROOT_ResolveNames <br>}; <br> <br> <br> <br>/* <br> *  Private functions <br> */ <br>HRESULT HrNewABCButton( LPABCNT lpABC, <br>                        ULONG ulInterfaceOptions, <br>                        ULONG ulFlags, <br>                        LPMAPICONTROL FAR * lppMAPICont); <br> <br>//HRESULT HrGetSearchDialog(LPABCNT lpABC, LPMAPITABLE * lppSearchTable); <br>HRESULT HrGetDetailsDialog(LPABCNT lpABC, LPMAPITABLE * lppDetailsTable); <br> <br>/* <br> -  NewSampDirectory <br> - <br> *  Creates a Directory container object. <br> * <br> * <br> */ <br> <br>/* <br> *  properties of which I want to track whether or not they've <br> *  been changed. <br> */ <br>enum { ivalWatchPR_SAB_FILE_TEMP = 0, <br>        cvalWatchMax }; <br> <br>SizedSPropTagArray(cvalWatchMax, tagaPropsToWatch) = <br>{ <br>    cvalWatchMax, <br>    { <br>        PR_SAB_FILE_TEMP <br>    } <br>}; <br> <br> <br>/* <br> *  Properties that are initially set on this object <br> */ <br>enum {  ivalabcPR_DISPLAY_TYPE = 0, <br>        ivalabcPR_OBJECT_TYPE, <br>        ivalabcPR_ENTRYID, <br>        ivalabcPR_RECORD_KEY, <br>        ivalabcPR_SEARCH_KEY, <br>        ivalabcPR_DISPLAY_NAME_A, <br>        ivalabcPR_CONTAINER_FLAGS, <br>        ivalabcPR_SAB_FILE, <br>        ivalabcPR_SAB_FILE_TEMP, <br>        ivalabcPR_RADIO_BUTTON_VALUE, <br>        cvalabcMax }; <br> <br> <br>static SizedSPropTagArray( cvalabcMax, tagaABCAccess) = <br>{ <br>    cvalabcMax, <br>    {   PR_DISPLAY_TYPE, <br>        PR_OBJECT_TYPE, <br>        PR_ENTRYID, <br>        PR_RECORD_KEY, <br>        PR_SEARCH_KEY, <br>        PR_DISPLAY_NAME_A, <br>        PR_CONTAINER_FLAGS, <br>        PR_SAB_FILE, <br>        PR_SAB_FILE_TEMP, <br>        PR_RADIO_BUTTON_VALUE <br>      } <br>}; <br> <br>static ULONG    rgulABCAccess[cvalabcMax] = <br>{ <br>      IPROP_READONLY | IPROP_CLEAN,     /* PR_DISPLAY_TYPE */ <br>      IPROP_READONLY | IPROP_CLEAN,     /* PR_OBJECT_TYPE */ <br>      IPROP_READONLY | IPROP_CLEAN,     /* PR_ENTRYID */ <br>      IPROP_READONLY | IPROP_CLEAN,     /* PR_RECORD_KEY */ <br>      IPROP_READONLY | IPROP_CLEAN,     /* PR_SEARCH_KEY */ <br>      IPROP_READONLY | IPROP_CLEAN,     /* PR_DISPLAY_NAME_A */ <br>      IPROP_READONLY | IPROP_CLEAN,     /* PR_CONTAINER_FLAGS */ <br>      IPROP_READWRITE | IPROP_CLEAN,    /* PR_SAB_FILE */ <br>      IPROP_READWRITE | IPROP_CLEAN,    /* PR_SAB_FILE_TEMP */ <br>      IPROP_READWRITE | IPROP_CLEAN     /* PR_RADIO_BUTTON_VALUE */ <br>}; <br> <br>HRESULT <br>HrNewSampDirectory( LPABCONT *          lppABC, <br>                    ULONG *             lpulObjType, <br>                    LPABLOGON           lpABLogon, <br>                    LPCIID              lpInterface, <br>                    HINSTANCE           hLibrary, <br>                    LPALLOCATEBUFFER    lpAllocBuff, <br>                    LPALLOCATEMORE      lpAllocMore, <br>                    LPFREEBUFFER        lpFreeBuff, <br>                    LPMALLOC            lpMalloc ) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    LPABCNT lpABC = NULL; <br>    SCODE sc; <br>    LPPROPDATA lpPropData = NULL; <br>    SPropValue spv[cvalabcMax]; <br>    char szBuf[MAX_PATH]; <br>    MAPIUID * lpMuidLogon; <br>    LPSTR lpszFileName; <br>    DIR_ENTRYID eidRoot =   {   {0, 0, 0, 0}, <br>                                MUIDABSAMPLE, <br>                                SAMP_VERSION, <br>                                SAMP_DIRECTORY }; <br>     <br>    /*  Do I support this interface?? */ <br>    if (lpInterface) <br>    { <br>        if (memcmp(lpInterface, &amp;IID_IABContainer, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IMAPIContainer, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IMAPIProp, sizeof(IID)) &amp;&amp; <br>            memcmp(lpInterface, &amp;IID_IUnknown, sizeof(IID))) <br>        { <br>            DebugTraceSc(HrNewSampDirectory, MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            return ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>        } <br>    } <br> <br>    /* <br>     *  Allocate space for the directory container structure <br>     */ <br> <br>    sc = lpAllocBuff( sizeof(ABCNT), (LPVOID *) &amp;lpABC ); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    lpABC-&gt;lpVtbl = &amp;vtblABC; <br>    lpABC-&gt;lcInit = 1; <br>    lpABC-&gt;hResult = hrSuccess; <br>    lpABC-&gt;idsLastError = 0; <br> <br>    lpABC-&gt;hLibrary = hLibrary; <br>    lpABC-&gt;lpAllocBuff = lpAllocBuff; <br>    lpABC-&gt;lpAllocMore = lpAllocMore; <br>    lpABC-&gt;lpFreeBuff = lpFreeBuff; <br>    lpABC-&gt;lpMalloc = lpMalloc; <br> <br>    lpABC-&gt;lpABLogon = lpABLogon; <br>    lpABC-&gt;lpTDatDetails = NULL; <br> <br>    /* <br>     *  Create property storage object <br>     */ <br> <br>    sc = CreateIProp((LPIID) &amp;IID_IMAPIPropData, <br>        lpAllocBuff, <br>        lpAllocMore, <br>        lpFreeBuff, <br>        lpMalloc, <br>        &amp;lpPropData); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto err; <br>    } <br> <br>    /* <br>     *  initialize the muid in the entry id <br>     */ <br>    lpMuidLogon = LpMuidFromLogon(lpABLogon); <br>    eidRoot.muidID = *lpMuidLogon; <br> <br>    /* <br>     *  Set up initial set of properties associated with this <br>     *  container. <br>     */ <br>    spv[ivalabcPR_DISPLAY_TYPE].ulPropTag = PR_DISPLAY_TYPE; <br>    spv[ivalabcPR_DISPLAY_TYPE].Value.l = DT_NOT_SPECIFIC; <br> <br>    spv[ivalabcPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE; <br>    spv[ivalabcPR_OBJECT_TYPE].Value.l = MAPI_ABCONT; <br> <br>    spv[ivalabcPR_ENTRYID].ulPropTag = PR_ENTRYID; <br>    spv[ivalabcPR_ENTRYID].Value.bin.cb = sizeof(DIR_ENTRYID); <br>    spv[ivalabcPR_ENTRYID].Value.bin.lpb = (LPBYTE) &amp;eidRoot; <br> <br>    spv[ivalabcPR_RECORD_KEY].ulPropTag = PR_RECORD_KEY; <br>    spv[ivalabcPR_RECORD_KEY].Value.bin.cb = sizeof(DIR_ENTRYID); <br>    spv[ivalabcPR_RECORD_KEY].Value.bin.lpb = (LPBYTE) &amp;eidRoot; <br> <br>    spv[ivalabcPR_SEARCH_KEY].ulPropTag = PR_SEARCH_KEY; <br>    spv[ivalabcPR_SEARCH_KEY].Value.bin.cb = sizeof(DIR_ENTRYID); <br>    spv[ivalabcPR_SEARCH_KEY].Value.bin.lpb = (LPBYTE) &amp;eidRoot; <br> <br> <br>    spv[ivalabcPR_DISPLAY_NAME_A].ulPropTag = PR_DISPLAY_NAME_A; <br> <br>    GenerateContainerDN(lpABLogon, szBuf); <br>    spv[ivalabcPR_DISPLAY_NAME_A].Value.lpszA = szBuf; <br> <br>    spv[ivalabcPR_CONTAINER_FLAGS].ulPropTag = PR_CONTAINER_FLAGS; <br>    spv[ivalabcPR_CONTAINER_FLAGS].Value.l = AB_RECIPIENTS; <br> <br>    /* <br>     *  Get the current .SAB file name from our logon object <br>     */ <br>    hResult = HrLpszGetCurrentFileName(lpABLogon, &amp;lpszFileName); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto err; <br>    } <br> <br>    spv[ivalabcPR_SAB_FILE].ulPropTag = PR_SAB_FILE; <br>    spv[ivalabcPR_SAB_FILE].Value.lpszA = lpszFileName; <br> <br>    spv[ivalabcPR_SAB_FILE_TEMP].ulPropTag = PR_SAB_FILE_TEMP; <br>    spv[ivalabcPR_SAB_FILE_TEMP].Value.lpszA = lpszFileName; <br> <br>    spv[ivalabcPR_RADIO_BUTTON_VALUE].ulPropTag = PR_RADIO_BUTTON_VALUE; <br>    spv[ivalabcPR_RADIO_BUTTON_VALUE].Value.l = RADIO_BUTTON_1_RETURN_VALUE; <br> <br>    /* <br>     *   Set the default properties <br>     */ <br>    hResult = lpPropData-&gt;lpVtbl-&gt;SetProps(lpPropData, <br>        cvalabcMax, <br>        spv, <br>        NULL); <br> <br>    /* <br>     *  No longer need this buffer <br>     */ <br>    lpFreeBuff(lpszFileName); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto err; <br>    } <br> <br>    /* <br>     *  We mark all properties as being CLEAN initially.  Only PR_SAB_FILE, <br>     *  PR_SAB_FILE_TEMP, and PR_RADIO_BUTTON_VALUE are marked as READWRITE <br>     *  (Readable/Writable by the client) the others are marked as READONLY <br>     *  so that the client may not alter them. <br>     * <br>     *  Notice that the ABC_SaveChanges code checks the IPROP_DIRTY bit <br>     *  on PR_SAB_FILE_TEMP to see if the client altered it! <br>     */ <br>    (void) lpPropData-&gt;lpVtbl-&gt;HrSetPropAccess(lpPropData, <br>                                (LPSPropTagArray) &amp;tagaABCAccess, <br>                                rgulABCAccess); <br> <br> <br>    InitializeCriticalSection(&amp;lpABC-&gt;cs); <br> <br>    /*  We must AddRef the lpABLogon object since we will be using it <br>     */ <br>    lpABLogon-&gt;lpVtbl-&gt;AddRef(lpABLogon); <br> <br>    lpABC-&gt;lpPropData = (LPMAPIPROP) lpPropData; <br>    *lppABC = (LPABCONT) lpABC; <br>    *lpulObjType = MAPI_ABCONT; <br> <br> <br>out: <br> <br>    DebugTraceResult(HrNewSampDirectory, hResult); <br>    return hResult; <br> <br>err: <br>    /* <br>     *  free the ABContainer object <br>     */ <br>    lpFreeBuff( lpABC ); <br> <br>    /* <br>     *  free the property storage object <br>     */ <br>    if (lpPropData) <br>        lpPropData-&gt;lpVtbl-&gt;Release(lpPropData); <br> <br>    goto out; <br>} <br> <br> <br>/* <br> -  ABC_Release <br> - <br> *  Decrement lcInit. <br> *      When lcInit == 0, free up the lpABC structure <br> * <br> */ <br> <br>STDMETHODIMP_(ULONG) <br>ABC_Release(LPABCNT lpABC) <br>{ <br> <br>    long lcInit; <br>     <br>    /* <br>     *  Check to see if it has a jump table <br>     */ <br>     <br>    ABC_ValidateObject(Release, lpABC); <br> <br>    Validate_IUnknown_Release(lpABC); <br> <br> <br>    EnterCriticalSection(&amp;lpABC-&gt;cs); <br>    lcInit = --lpABC-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABC-&gt;cs); <br> <br>    if (lcInit == 0) <br>    { <br> <br>        /* <br>         *  Get rid of the lpPropData <br>         */ <br>        if (lpABC-&gt;lpPropData) <br>            lpABC-&gt;lpPropData-&gt;lpVtbl-&gt;Release(lpABC-&gt;lpPropData); <br> <br>        /* <br>         *  Get rid of the details table <br>         */ <br>        if (lpABC-&gt;lpTDatDetails) <br>            lpABC-&gt;lpTDatDetails-&gt;lpVtbl-&gt;Release(lpABC-&gt;lpTDatDetails); <br> <br>        /*   <br>         *  Release our reference to the ABLogon object. <br>         */ <br>        if (lpABC-&gt;lpABLogon) <br>        { <br>            lpABC-&gt;lpABLogon-&gt;lpVtbl-&gt;Release(lpABC-&gt;lpABLogon); <br>            lpABC-&gt;lpABLogon = NULL; <br>        } <br> <br>        /* <br>         *  Destroy the critical section for this object <br>         */ <br> <br>        DeleteCriticalSection(&amp;lpABC-&gt;cs); <br> <br>        /* <br>         *  Set the Jump table to NULL.  This way the client will find out <br>         *  real fast if it's calling a method on a released object.  That is, <br>         *  the client will crash.  Hopefully, this will happen during the <br>         *  development stage of the client. <br>         */ <br>        lpABC-&gt;lpVtbl = NULL; <br> <br>        /* <br>         *  Need to free the object <br>         */ <br> <br>        lpABC-&gt;lpFreeBuff(lpABC); <br>        return 0; <br>    } <br> <br>    return lpABC-&gt;lcInit; <br> <br>} <br> <br> <br>/* <br> -  ABC_SaveChanges <br> - <br> *  This is used to save changes associated with the search dialog <br> *  in order to get the advanced search restriction and to save changes <br> *  associated with the container details dialog. <br> * <br> */ <br> <br>SPropTagArray tagaSAB_FILE = <br>{ <br>    1, <br>    { <br>        PR_SAB_FILE_TEMP <br>    } <br>}; <br> <br>STDMETHODIMP <br>ABC_SaveChanges(LPABCNT lpABC, ULONG ulFlags) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    ULONG ulCount; <br>    LPSPropValue lpspv = NULL; <br>    ULONG FAR *rgulAccess = NULL; <br>    ULONG ulAccess = IPROP_CLEAN | IPROP_READWRITE;  <br>    LPSPropTagArray ptagaSAB_FILE = (LPSPropTagArray) &amp;tagaSAB_FILE; <br>    LPPROPDATA lpPropData = (LPPROPDATA) lpABC-&gt;lpPropData; <br> <br>     <br>    ABC_ValidateObject(SaveChanges, lpABC); <br> <br>    Validate_IMAPIProp_SaveChanges(lpABC, ulFlags); <br>     <br> <br>    EnterCriticalSection(&amp;lpABC-&gt;cs); <br> <br>    /* <br>     *  Check to see if anyone has dirtied the PR_SAB_FILE_TEMP <br>     */ <br>    (void) lpPropData-&gt;lpVtbl-&gt;HrGetPropAccess(lpPropData, <br>                                        &amp;ptagaSAB_FILE, <br>                                        &amp;rgulAccess); <br> <br>    if (!rgulAccess || !((*rgulAccess) &amp; IPROP_DIRTY)) <br>    { <br>        /* <br>         *  No, nothing to update then head on out <br>         */ <br> <br>        goto ret; <br>    } <br> <br>    /* <br>     *  Set back to being clean <br>     */ <br>    (void )lpPropData-&gt;lpVtbl-&gt;HrSetPropAccess(lpPropData, <br>                                        ptagaSAB_FILE, <br>                                        &amp;ulAccess); <br> <br>    /* <br>     * Get the temporary sab file name <br>     */ <br>    hResult = lpPropData-&gt;lpVtbl-&gt;GetProps( <br>        lpPropData, <br>        &amp;tagaSAB_FILE, <br>        0,      /* ansi */ <br>        &amp;ulCount, <br>        &amp;lpspv); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto ret; <br>    } <br> <br>    if (lpspv-&gt;ulPropTag != PR_SAB_FILE_TEMP) <br>    { <br>        /* <br>         *  There's no reason this property shouldn't be there. <br>         */ <br>        hResult = ResultFromScode(MAPI_E_CORRUPT_DATA); <br>        goto ret; <br>    } <br> <br>    /* <br>     *  Save the new name back into the object as PR_SAB_FILE <br>     */ <br>    lpspv-&gt;ulPropTag = PR_SAB_FILE; <br>     <br>    hResult = lpPropData-&gt;lpVtbl-&gt;SetProps( <br>            lpPropData, <br>            1, <br>            lpspv, NULL); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        /* <br>         *  Do nothing...  So I couldn't save it away this time... <br>         */ <br>        hResult = hrSuccess; <br>        goto ret; <br>    } <br> <br>    /* <br>     *  Update every other object that needs this new information <br>     */ <br>    hResult = HrReplaceCurrentFileName(lpABC-&gt;lpABLogon, lpspv-&gt;Value.lpszA); <br> <br> <br>ret: <br> <br>    LeaveCriticalSection(&amp;lpABC-&gt;cs); <br> <br>    lpABC-&gt;lpFreeBuff(lpspv); <br>    lpABC-&gt;lpFreeBuff(rgulAccess); <br>    DebugTraceResult(ABC_SaveChanges, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  ABC_OpenProperty <br> - <br> * <br> *  This method allows the opening of the following object: <br> * <br> *  PR_BUTTON_PRESS  :-  Gets the MAPIControl object associated <br> *                       with the button on this container's details. <br> *  PR_DETAILS_TABLE :-  Gets the display table associated with <br> *                       the details for this container. <br> *  PR_SEARCH        :-  Gets the advanced search object associated with <br> *                       this container. <br> *  PR_CONTAINER_CONTENTS  :-  Same as GetContentsTable() <br> *  PR_CONTAINER_HIERARCHY :-  Same as GetHierarchyTable() <br> * <br> * <br> */ <br>STDMETHODIMP <br>ABC_OpenProperty(LPABCNT lpABC, <br>    ULONG ulPropTag, <br>    LPCIID lpiid, <br>    ULONG ulInterfaceOptions, <br>    ULONG ulFlags, <br>    LPUNKNOWN * lppUnk) <br>{ <br>    HRESULT hResult; <br> <br>    ABC_ValidateObject(OpenProperty, lpABC); <br> <br>    Validate_IMAPIProp_OpenProperty(lpABC, ulPropTag, lpiid, ulInterfaceOptions, <br>                                    ulFlags, lppUnk); <br>    /* <br>     *  Check for flags we can't support <br>     */ <br> <br>    if (ulFlags &amp; (MAPI_CREATE|MAPI_MODIFY)) <br>    { <br>        hResult = ResultFromScode(E_ACCESSDENIED); <br>        goto out; <br>    } <br>         <br>    if (ulInterfaceOptions &amp; ~MAPI_UNICODE) <br>    { <br>        /* <br>         *  Only UNICODE flag should be set for any of the objects that might <br>         *  be returned from this object. <br>         */ <br>         <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br>        goto out; <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>        DebugTraceArg( ABC_OpenProperty, "bad character width" ); <br>        goto out; <br>         <br>    } <br>     <br> <br>    /* <br>     *  Details for this directory entry <br>     */ <br> <br>    if ((ulPropTag == PR_DETAILS_TABLE) || <br>        (ulPropTag == PR_BUTTON_PRESS) || <br>        (ulPropTag == PR_CONTAINER_CONTENTS) || <br>        (ulPropTag == PR_CONTAINER_HIERARCHY) || <br>        (ulPropTag == PR_SEARCH)) <br>    { <br> <br>        /* <br>         *  Check to see if they're expecting a table interface for all props but <br>         *  PR_BUTTON_PRESS. <br>         */ <br>        if ((ulPropTag != PR_BUTTON_PRESS) &amp;&amp; <br>            (ulPropTag != PR_SEARCH) &amp;&amp; <br>            memcmp(lpiid, &amp;IID_IMAPITable, sizeof(IID))) <br>        { <br>            hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>            goto out; <br>        } <br> <br>        switch (ulPropTag) <br>        { <br> <br>        case PR_BUTTON_PRESS: <br>            { <br>                /* <br>                 *  Check to see if they're expecting a generic control interface <br>                 */ <br>                if (memcmp(lpiid, &amp;IID_IMAPIControl, sizeof(IID))) <br>                { <br>                    hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>                    goto out; <br>                } <br> <br>                hResult = HrNewABCButton(lpABC, <br>                    ulInterfaceOptions, <br>                    ulFlags, <br>                    (LPMAPICONTROL FAR *) lppUnk); <br> <br>                break; <br>            } <br> <br>        case PR_DETAILS_TABLE: <br>            { <br>                hResult = HrGetDetailsDialog(lpABC, (LPMAPITABLE *) lppUnk); <br>                break; <br>            } <br> <br>        case PR_SEARCH: <br>            { <br>                /* <br>                 *  Check to see if they're expecting a generic control interface <br>                 */ <br>                if (memcmp(lpiid, &amp;IID_IMAPIContainer, sizeof(IID))) <br>                { <br>                    hResult = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>                    goto out; <br>                } <br> <br>                hResult = HrNewSearch((LPMAPICONTAINER *) lppUnk, <br>                                        lpABC-&gt;lpABLogon, <br>                                        lpiid, <br>                                        lpABC-&gt;hLibrary, <br>                                        lpABC-&gt;lpAllocBuff, <br>                                        lpABC-&gt;lpAllocMore, <br>                                        lpABC-&gt;lpFreeBuff, <br>                                        lpABC-&gt;lpMalloc); <br>                break; <br>            } <br> <br>        case PR_CONTAINER_CONTENTS: <br>            { <br>                hResult = ABC_GetContentsTable(lpABC, 0, (LPMAPITABLE *) lppUnk); <br>                break; <br>            } <br> <br>        case PR_CONTAINER_HIERARCHY: <br>            { <br>                hResult = ABC_GetHierarchyTable(lpABC, 0, (LPMAPITABLE *) lppUnk); <br>                break; <br>            } <br> <br>        default: <br>            Assert(FALSE); <br>            break; <br>        } <br>    } else <br>    { <br> <br>        hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br>    } <br> <br>out: <br> <br>    DebugTraceResult(ABC_OpenProperty, hResult); <br>    return hResult; <br>} <br> <br>/************************************************************************* <br> * <br> -  ABC_GetContentsTable <br> - <br> * <br> *  Retrieves the IMAPITable that has the contents of this container. <br> */ <br>STDMETHODIMP <br>ABC_GetContentsTable(LPABCNT lpABC, ULONG ulFlags, <br>    LPMAPITABLE * lppTable) <br>{ <br> <br>    HRESULT hResult; <br> <br>    /* <br>     *  Validate parameters <br>     */ <br> <br>    ABC_ValidateObject(GetContentsTable, lpABC); <br> <br>    Validate_IMAPIContainer_GetContentsTable(lpABC, ulFlags, lppTable); <br>     <br> <br>    /* <br>     *  Certain flags are not supported <br>     */ <br>    if (ulFlags &amp; (MAPI_ASSOCIATED)) <br>    { <br>        hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br>        goto out; <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceArg( ABC_GetContentsTable, "Bad character width" ); <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        goto out; <br>    } <br> <br>    /* <br>     *  Create the new Contents table <br>     */ <br>    hResult = HrNewIVTAbc(lppTable, <br>                          lpABC-&gt;lpABLogon, <br>                          (LPABCONT) lpABC, <br>                          lpABC-&gt;hLibrary, <br>                          lpABC-&gt;lpAllocBuff, <br>                          lpABC-&gt;lpAllocMore, <br>                          lpABC-&gt;lpFreeBuff, <br>                          lpABC-&gt;lpMalloc); <br> <br>out: <br> <br>    DebugTraceResult(ABC_GetContentsTable, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  ABC_GetHierarchyTable <br> - <br> * <br> *  There is no hierarchy table associated with this object. <br> * <br> */ <br>STDMETHODIMP <br>ABC_GetHierarchyTable(LPABCNT lpABC, ULONG ulFlags, <br>    LPMAPITABLE * lppTable) <br>{ <br>    HRESULT hResult; <br> <br>    /* <br>     *  Check to see if it has a lpVtbl object member <br>     */ <br>    if (IsBadReadPtr(lpABC, offsetof(ABCNT, lpVtbl)+sizeof(ABC_Vtbl *))) <br>    { <br>        /* <br>         *  Not large enough <br>         */ <br>        hResult = MakeResult(E_INVALIDARG); <br>        DebugTraceResult(ABC_HierarchyTable, hResult); <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see that the Vtbl is large enough to include this method <br>     */ <br>    if (IsBadReadPtr(lpABC-&gt;lpVtbl, <br>        offsetof(ABC_Vtbl, GetHierarchyTable)+sizeof(ABC_GetHierarchyTable_METHOD *))) <br>    { <br>        /* <br>         *  Jump table not derived from IUnknown <br>         */ <br> <br>        hResult = MakeResult(E_INVALIDARG); <br>        DebugTraceResult(ABC_HierarchyTable, hResult); <br>        return hResult; <br>    } <br> <br>    /* <br>     *  Check to see if the method is the same <br>     */ <br>    if (ABC_GetHierarchyTable != lpABC-&gt;lpVtbl-&gt;GetHierarchyTable) <br>    { <br>        /* <br>         *  Wrong object - the object passed doesn't have this <br>         *  method. <br>         */ <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTraceResult(ABC_HierarchyTable, hResult); <br>        return hResult; <br>    } <br> <br>    Validate_IMAPIContainer_GetHierarchyTable(lpABC, ulFlags, lppTable); <br>     <br>    /* <br>     *  We don't support this method on this object <br>     */ <br>    hResult = ResultFromScode(MAPI_E_NO_SUPPORT); <br> <br>    DebugTraceResult(ABC_GetHierarchyTable, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  HrGetDetailsDialog <br> - <br> *  Builds a display table for this directory. <br> */ <br> <br>HRESULT <br>HrGetDetailsDialog(LPABCNT lpABC, LPMAPITABLE * lppDetailsTable) <br>{ <br>    HRESULT hResult; <br> <br>    if (!lpABC-&gt;lpTDatDetails) <br>    { <br> <br>        /* Create a display table */ <br>        hResult = BuildDisplayTable( <br>            lpABC-&gt;lpAllocBuff, <br>            lpABC-&gt;lpAllocMore, <br>            lpABC-&gt;lpFreeBuff, <br>            lpABC-&gt;lpMalloc, <br>            lpABC-&gt;hLibrary, <br>            sizeof(rgdtpageDir) / sizeof(DTPAGE), <br>            rgdtpageDir, <br>            0, <br>            lppDetailsTable, <br>            &amp;lpABC-&gt;lpTDatDetails); <br>    } else <br>    { <br>        hResult = lpABC-&gt;lpTDatDetails-&gt;lpVtbl-&gt;HrGetView( <br>            lpABC-&gt;lpTDatDetails, <br>            NULL, <br>            NULL, <br>            0, <br>            lppDetailsTable); <br>    } <br> <br>    DebugTraceResult(HrGetDetailsDialog, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> *  Button object for this directory's details dialog <br> */ <br> <br> <br>/* <br> *  Declaration of IMAPIControl object implementation <br> */ <br>#undef  INTERFACE <br>#define INTERFACE   struct _ABCBUTT <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type,method)    MAPIMETHOD_DECLARE(type,method,ABCBUTT_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPICONTROL_METHODS(IMPL) <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type,method)    MAPIMETHOD_TYPEDEF(type,method,ABCBUTT_) <br>        MAPI_IUNKNOWN_METHODS(IMPL) <br>        MAPI_IMAPICONTROL_METHODS(IMPL) <br> <br>#undef  MAPIMETHOD_ <br>#define MAPIMETHOD_(type,method)    STDMETHOD_(type,method) <br> <br>DECLARE_MAPI_INTERFACE(ABCBUTT_) <br>{ <br>    MAPI_IUNKNOWN_METHODS(IMPL) <br>    MAPI_IMAPICONTROL_METHODS(IMPL) <br>}; <br> <br>/* <br> * <br> *  Declaration of structure behind button <br> * <br> */ <br>typedef struct _ABCBUTT <br>{ </code></pre>
<p>
</p>
<pre><code>ABCBUTT_Vtbl FAR * lpVtbl; <br> <br>    SAB_IUnknown; <br>    /* <br>     *  My parent container object <br>     */ <br>    LPABCNT     lpABC; <br> <br>} ABCBUTT, *LPABCBUTT; <br> <br> <br>/* <br> *  Fill in the vtbl <br> */ <br>ABCBUTT_Vtbl vtblABCBUTT = <br>{ <br>    ABCBUTT_QueryInterface, <br>    (ABCBUTT_AddRef_METHOD *)       ROOT_AddRef, <br>    ABCBUTT_Release, <br>    (ABCBUTT_GetLastError_METHOD *) ROOT_GetLastError, <br>    ABCBUTT_Activate, <br>    ABCBUTT_GetState <br>}; <br> <br>#define ABCBUTT_ValidateObject(Method, pThis)       \ <br>{                                                   \ <br>    HRESULT hResult;                                \ <br>    if (IsBadReadPtr(pThis, sizeof(ABCBUTT)))       \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABCBUTT##_##Method, hResult);  \ <br>        return hResult;                             \ <br>    }                                               \ <br>                                                    \ <br>    if (pThis-&gt;lpVtbl != &amp;vtblABCBUTT)              \ <br>    {                                               \ <br>        hResult = ResultFromScode(E_INVALIDARG);    \ <br>        DebugTraceResult(ABCBUTT##_##Method, hResult);  \ <br>        return hResult;                             \ <br>    }                                               \ <br>} <br> <br> <br> <br>/* <br> -  HrNewABCButton <br> - <br> *  Creates the MAPIControl object that is the code behind the button <br> *  on the Sample AB's directory details. <br> */ <br>HRESULT <br>HrNewABCButton( LPABCNT lpABC, <br>                ULONG ulInterfaceOptions, <br>                ULONG ulFlags, <br>                LPMAPICONTROL FAR * lppMAPICont) <br>{ <br>    LPABCBUTT lpABCButt = NULL; <br>    SCODE scode; <br> <br>    scode = lpABC-&gt;lpAllocBuff(sizeof(ABCBUTT),(LPVOID *) &amp;lpABCButt); <br> <br>    if (FAILED(scode)) <br>    { <br>        DebugTraceSc(HrNewABCButton, scode); <br>        return ResultFromScode(scode); <br>    } <br> <br>    lpABCButt-&gt;lpVtbl = &amp;vtblABCBUTT; <br>    lpABCButt-&gt;lcInit = 1; <br>    lpABCButt-&gt;hResult = hrSuccess; <br>    lpABCButt-&gt;idsLastError = 0; <br> <br>    lpABCButt-&gt;hLibrary = lpABC-&gt;hLibrary; <br>    lpABCButt-&gt;lpAllocBuff = lpABC-&gt;lpAllocBuff; <br>    lpABCButt-&gt;lpAllocMore = lpABC-&gt;lpAllocMore; <br>    lpABCButt-&gt;lpFreeBuff = lpABC-&gt;lpFreeBuff; <br>    lpABCButt-&gt;lpMalloc = lpABC-&gt;lpMalloc; <br>    lpABCButt-&gt;lpABC = lpABC; <br> <br>    /* <br>     *  I need my parent object to stay around while this object <br>     *  does so that I can get to it in my Activate() method. <br>     *  To do this just AddRef() it. <br>     */ <br>    lpABC-&gt;lpVtbl-&gt;AddRef(lpABC); <br> <br>    InitializeCriticalSection(&amp;lpABCButt-&gt;cs); <br>     <br>    *lppMAPICont = (LPMAPICONTROL) lpABCButt; <br> <br>    return hrSuccess; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * <br> -  ABCBUTT_QueryInterface <br> - <br> * <br> *  Allows QI'ing to IUnknown and IMAPIControl. <br> * <br> */ <br>STDMETHODIMP <br>ABCBUTT_QueryInterface( LPABCBUTT lpABCButt, <br>                        REFIID lpiid, <br>                        LPVOID FAR * lppNewObj) <br>{ <br> <br>    HRESULT hResult = hrSuccess; <br> <br>    /*  Minimally validate the lpABCButt parameter */ <br> <br>    ABCBUTT_ValidateObject(QueryInterface, lpABCButt); <br> <br>    Validate_IUnknown_QueryInterface(lpABCButt, lpiid, lppNewObj); <br> <br>    /*  See if the requested interface is one of ours */ <br> <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IMAPIControl, sizeof(IID))) <br>    { <br>        *lppNewObj = NULL;      /* OLE requires zeroing [out] parameter */ <br>        hResult = ResultFromScode(E_NOINTERFACE); <br>        goto out; <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    EnterCriticalSection(&amp;lpABCButt-&gt;cs); <br>    ++lpABCButt-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABCButt-&gt;cs); <br>     <br>    *lppNewObj = lpABCButt; <br> <br>out: <br> <br>    DebugTraceResult(ABCBUTT_QueryInterface, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  ABCBUTT_Release <br> - <br> *  Releases and cleans up this object <br> */ <br>STDMETHODIMP_(ULONG) <br>ABCBUTT_Release(LPABCBUTT lpABCButt) <br>{ <br>    long lcInit; <br> <br>    /*  Minimally validate the lpABCButt parameter */ <br> <br>    if (IsBadReadPtr(lpABCButt, sizeof(ABCBUTT))) <br>    { <br>        return 1; <br>    } <br> <br>    if (lpABCButt-&gt;lpVtbl != &amp;vtblABCBUTT) <br>    { <br>        return 1; <br>    } <br> <br>    Validate_IUnknown_Release(lpABCButt); <br> <br>    EnterCriticalSection(&amp;lpABCButt-&gt;cs); <br>    lcInit = --lpABCButt-&gt;lcInit; <br>    LeaveCriticalSection(&amp;lpABCButt-&gt;cs); <br>     <br>    if (lcInit == 0) <br>    { <br> <br>        /* <br>         *  Release my parent <br>         */ <br>        lpABCButt-&gt;lpABC-&gt;lpVtbl-&gt;Release(lpABCButt-&gt;lpABC); <br> <br>        /* <br>         *  Destroy the critical section for this object <br>         */ <br> <br>        DeleteCriticalSection(&amp;lpABCButt-&gt;cs); <br> <br>        /* <br>         *  Set the Jump table to NULL.  This way the client will find out <br>         *  real fast if it's calling a method on a released object.  That is, <br>         *  the client will crash.  Hopefully, this will happen during the <br>         *  development stage of the client. <br>         */ <br>        lpABCButt-&gt;lpVtbl = NULL; <br> <br>        /* <br>         *  Free the object <br>         */ <br> <br>        lpABCButt-&gt;lpFreeBuff(lpABCButt); <br>        return 0; <br>    } <br> <br>    return lcInit; <br> <br>} <br> <br> <br>/* <br> -  ABCBUTT_Activate <br> - <br> * <br> *  Activates this control.  In this case, it brings up the common file browsing <br> *  dialog and allows the user to pick a different .SAB file. <br> * <br> *  Note that if all is successful it sends a display table notification.  The UI <br> *  will respond to this by updating the particular control that was said to have <br> *  changed in the notification. <br> */ <br>STDMETHODIMP <br>ABCBUTT_Activate(LPABCBUTT lpABCButt, ULONG ulFlags, <br>    ULONG ulUIParam) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    OPENFILENAME openfilename; <br>    char szFileName[MAX_PATH]; <br>    char szDirName[MAX_PATH]; <br>    SPropValue sProp; <br>    LPSPropValue lpspv = NULL; <br>    ULONG ulCount, ich; <br> <br> <br>    /*  Minimally validate the lpABCButt parameter */ <br> <br>    ABCBUTT_ValidateObject(Activate, lpABCButt); <br> <br>    Validate_IMAPIControl_Activate(lpABCButt, ulFlags, ulUIParam); <br>     <br> <br>    if (ulFlags) <br>    { <br>        /* <br>         *  No flags defined for this method <br>         */ <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br>        goto out; <br>    } <br> <br>     <br>    /* <br>     *  First, get the old SAB file name so that it shows up in the <br>     *  choose file dialog <br>     */ <br> <br>    hResult = lpABCButt-&gt;lpABC-&gt;lpPropData-&gt;lpVtbl-&gt;GetProps( <br>        lpABCButt-&gt;lpABC-&gt;lpPropData, <br>        &amp;tagaSAB_FILE, <br>        0,              /* ansi */ <br>        &amp;ulCount, <br>        &amp;lpspv); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto out; <br>    } <br> <br>    if (lpspv-&gt;ulPropTag != PR_SAB_FILE_TEMP) <br>    { <br>        /* <br>         *  Property wasn't there... <br>         */ <br>        hResult = ResultFromScode(MAPI_E_CORRUPT_DATA); <br> <br>        goto out; <br>    } <br> <br>    lstrcpyA(szFileName, lpspv-&gt;Value.lpszA); <br> <br>    szDirName[0] = '\0'; <br> <br> <br>    /* get the path name */ <br>    for (ich = lstrlenA(lpspv-&gt;Value.lpszA) - 1; ich &gt; 0; ich--) <br>    { <br>        if (lpspv-&gt;Value.lpszA[ich] == '\\') <br>        { <br>            lpspv-&gt;Value.lpszA[ich] = '\0'; <br>            break; <br>        } <br>        else if (lpspv-&gt;Value.lpszA[ich] == ':') <br>        { <br>            lpspv-&gt;Value.lpszA[ich + 1] = '\0'; <br>            break; <br>        } <br>    } <br> <br>    lstrcpyA(szDirName, lpspv-&gt;Value.lpszA); <br> <br>    /* <br>     *  Get the user to select one <br>     */ <br>    openfilename.lStructSize = sizeof(OPENFILENAME); <br>    openfilename.hwndOwner = (HWND) ulUIParam; <br>    openfilename.hInstance = 0; /* Ignored */ <br>    openfilename.lpstrFilter = "Sample AB files\0*.sab\0\0"; <br>    openfilename.lpstrCustomFilter = NULL; <br>    openfilename.nMaxCustFilter = 0; <br>    openfilename.nFilterIndex = 0; <br>    openfilename.lpstrFile = szFileName; <br>    openfilename.nMaxFile = MAX_PATH; <br>    openfilename.lpstrFileTitle = NULL; <br>    openfilename.nMaxFileTitle = 0; <br>    openfilename.lpstrInitialDir = szDirName; <br>    openfilename.lpstrTitle = "Sample Address Book"; <br>    openfilename.Flags = OFN_FILEMUSTEXIST | <br>        OFN_HIDEREADONLY | <br>        OFN_NOCHANGEDIR; <br>    openfilename.nFileOffset = 0; <br>    openfilename.nFileExtension = 0; <br>    openfilename.lpstrDefExt = "sab"; <br>    openfilename.lCustData = 0; <br>    openfilename.lpfnHook = NULL; <br>    openfilename.lpTemplateName = NULL; <br> <br>    /* <br>     *  Call up the common dialog <br>     */ <br>    if (!GetOpenFileName(&amp;openfilename)) <br>    { <br>        hResult = hrSuccess; <br>        goto out; <br>    } <br> <br>    /* <br>     *  Save SAB FileName into the container object <br>     */ <br> <br>    sProp.ulPropTag = PR_SAB_FILE_TEMP; <br>    sProp.Value.lpszA = szFileName; <br> <br>    hResult = lpABCButt-&gt;lpABC-&gt;lpPropData-&gt;lpVtbl-&gt;SetProps( <br>        lpABCButt-&gt;lpABC-&gt;lpPropData, <br>        1, <br>        &amp;sProp, <br>        NULL); <br>    if (HR_FAILED(hResult)) <br>    { <br>        goto out; <br>    } <br> <br>    /* <br>     *  Notify the details table so that everyone with a view open <br>     *  will get notified <br>     */ <br>    if (lpABCButt-&gt;lpABC-&gt;lpTDatDetails) <br>    { <br>        sProp.ulPropTag = PR_CONTROL_ID; <br>        sProp.Value.bin.lpb = (LPBYTE) &amp;notifdata; <br>        sProp.Value.bin.cb = sizeof(NOTIFDATA); <br> <br>        hResult = lpABCButt-&gt;lpABC-&gt;lpTDatDetails-&gt;lpVtbl-&gt;HrNotify( <br>            lpABCButt-&gt;lpABC-&gt;lpTDatDetails, <br>            0, <br>            1, <br>            &amp;sProp); <br>    } <br> <br>out: <br>    lpABCButt-&gt;lpFreeBuff(lpspv); <br>    DebugTraceResult(ABCBUTT_Activate, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  ABCBUTT_GetState <br> - <br> *  Says whether this control should appear enabled or not at this time. <br> * <br> */ <br>STDMETHODIMP <br>ABCBUTT_GetState(LPABCBUTT lpABCButt, ULONG ulFlags, <br>    ULONG * lpulState) <br>{ <br> <br>    HRESULT hResult = hrSuccess; <br> <br>    /*  Minimally validate the lpABCButt parameter */ <br> <br>    ABCBUTT_ValidateObject(GetStatus, lpABCButt); <br> <br>    Validate_IMAPIControl_GetState(lpABCButt, ulFlags, lpulState); <br>     <br>     <br>    /* <br>     *  Means that at this time this button should appear enabled. <br>     */ <br>    *lpulState = MAPI_ENABLED; <br> <br> <br>    DebugTraceResult(ABCBUTT_GetState, hResult); <br>    return hResult; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
