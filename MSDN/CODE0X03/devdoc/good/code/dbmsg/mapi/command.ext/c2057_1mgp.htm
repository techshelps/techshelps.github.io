<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CMDEXT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2059"></a>CMDEXT.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name <br>//      CMDEXT.CPP  <br>// <br>//  Description <br>//      Implementation of interface objects <br>// <br>//      IExchExt interface methods: <br>//          MyExchExt::QueryInterface() <br>//          MyExchExt::AddRef() <br>//          MyExchExt::Release() <br>// <br>//          MyExchExt::Install() <br>// <br>//      IExchExtCommands interface methods: <br>//          MyExchExtCommands::QueryInterface() <br>//          MyExchExtCommands::AddRef() <br>//          MyExchExtCommands::Release() <br>// <br>//          MyExchExtCommands::InstallCommands() <br>//          MyExchExtCommands::DoCommand() <br>//          MyExchExtCommands::InitMenu() <br>//          MyExchExtCommands::Help() <br>//          MyExchExtCommands::QueryHelpText() <br>//          MyExchExtCommands::QueryButtonInfo() <br>//          MyExchExtCommands::ResetToolbar() <br>// <br>//          MyExchExtCommands::SetContext() <br>//          MyExchExtCommands::GetCmdID() <br>// <br>//      IExchExtUserEvents interface methods: <br>//          MyExchExtUserEvents::QueryInterface() <br>//          MyExchExtUserEvents::AddRef() <br>//          MyExchExtUserEvents::Release() <br>// <br>//          MyExchExtUserEvents::OnSelectionChange() <br>//          MyExchExtUserEvents::OnObjectChange() <br>// <br>//          MyExchExtUserEvents::SetContext() <br>//          MyExchExtUserEvents::SetIExchExt() <br>// <br>//  Author <br>//      Gary Peluso <br>// <br>//  Revision: 1.00 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1992-1995 Microsoft Corporation. All rights reserved. <br>// <br>#define INITGUID <br>#define USES_IID_IExchExt <br>#define USES_IID_IExchExtAdvancedCriteria <br>#define USES_IID_IExchExtAttachedFileEvents <br>#define USES_IID_IExchExtCommands <br>#define USES_IID_IExchExtMessageEvents <br>#define USES_IID_IExchExtPropertySheets <br>#define USES_IID_IExchExtSessionEvents <br>#define USES_IID_IExchExtUserEvents <br>#define USES_IID_IMAPIFolder <br> <br>#include "CMDEXT.H" <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// data <br>static HINSTANCE ghInstDLL = NULL;  // instance handle of DLL <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FUNCTION: DLLMain() <br>// <br>//    Purpose <br>//    Do initilization processesing <br>// <br>//    Return Value <br>//    TRUE - DLL successfully loads and LoadLibrary will succeed. <br>//    FALSE - will cause an Exchange error message saying it cannot locate <br>//            the extension DLL. <br>// <br>//    Comments <br>//    We only need to get a copy of the DLL's HINSTANCE <br>// <br>BOOL WINAPI DllMain( <br>    HINSTANCE  hinstDLL, <br>    DWORD  fdwReason,    <br>    LPVOID  lpvReserved)  <br>{ <br> if (DLL_PROCESS_ATTACH == fdwReason) <br> { <br>    ghInstDLL = hinstDLL; <br> } <br> return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FUNCTION: ExchEntryPoint <br>// <br>//    Parameters - none <br>// <br>//    Purpose <br>//    The entry point which Exchange calls.   <br>// <br>//    Return Value <br>//    Pointer to Exchange Extension Object <br>// <br>//    Comments <br>//    This is called for each context entry.  Create a new MyExchExt object <br>//    every time so each context will get its own MyExchExt interface. <br>// <br>LPEXCHEXT CALLBACK ExchEntryPoint(void) <br>{ <br>    return new MyExchExt; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::MyExchExt() <br>// <br>//    Parameters - none <br>// <br>//    Purpose <br>//    Constructor. Initialize members and create supporting interface objects <br>// <br>//    Comments <br>//    Each context of Exchange gets its own set of interface objects. <br>//    Furthermore, interface objects per context are kept track of by Exchange <br>//    and the interface methods are called in the proper context. <br>//     <br>MyExchExt::MyExchExt ()  <br>{  <br>  m_cRef = 1;  <br>  m_context = 0; <br>   <br>  m_pExchExtCommands = new MyExchExtCommands; <br>  m_pExchExtUserEvents = new MyExchExtUserEvents; <br> <br>  // in MyExchExtUserEvents methods I need a reference to MyExchExt <br>  m_pExchExtUserEvents-&gt;SetIExchExt(this); <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  IExchExt virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::QueryInterface() <br>// <br>//    Parameters <br>//    riid   -- Interface ID. <br>//    ppvObj -- address of interface object pointer. <br>// <br>//    Purpose <br>//    Called by Exchage to request for interfaces <br>// <br>//    Return Value <br>//    S_OK  -- interface is supported and returned in ppvObj pointer <br>//    E_NOINTERFACE -- interface is not supported and ppvObj is NULL <br>// <br>//    Comments <br>//    Exchange client calls QueryInterface for each object.  Only <br>//    Need to support objects that apply to the extension.  QueryInterface <br>//    is called onces for each IID for each context.  We support two <br>//    contexts in this example so QueryInterface is called twice for <br>//    each IID. <br>//     <br>STDMETHODIMP MyExchExt::QueryInterface(REFIID riid, LPVOID * ppvObj) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    *ppvObj = NULL; <br> <br>    if ( (IID_IUnknown == riid) || (IID_IExchExt == riid) ) <br>    { <br>        *ppvObj = (LPUNKNOWN)this; <br>    } <br>    else if ( IID_IExchExtCommands == riid) <br>    { <br>        *ppvObj = (LPUNKNOWN)m_pExchExtCommands; <br>        m_pExchExtCommands-&gt;SetContext(m_context); <br>    } <br>    else if ( IID_IExchExtUserEvents == riid) <br>    { <br>        *ppvObj = (LPUNKNOWN)m_pExchExtUserEvents; <br>        m_pExchExtUserEvents-&gt;SetContext(m_context); <br>    } <br>    else <br>        hr = E_NOINTERFACE; <br> <br>    if (NULL != *ppvObj) <br>        ((LPUNKNOWN)*ppvObj)-&gt;AddRef(); <br> <br>    return hr; <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::Install() <br>// <br>//    Parameters <br>//    peecb     -- pointer to Exchange Extension callback function <br>//    eecontext -- context code at time of being called. <br>//    ulFlags   -- flag to say if install is for modal or not <br>// <br>//    Purpose <br>//    Called once for each new contexted that is entered.  Proper version  <br>//    number is checked here.   <br>// <br>//    Return Value <br>//    S_OK -- object supported in the requested context <br>//    S_FALSE -- object is not supported in teh requested context <br>// <br>//    Comments <br>// <br> STDMETHODIMP MyExchExt::Install (LPEXCHEXTCALLBACK pmecb,  <br>                         ULONG mecontext, ULONG ulFlags) <br>{ <br>    ULONG ulBuildVersion; <br>    HRESULT hr; <br> <br>    m_context = mecontext; <br> <br>    // make sure this is the right version  <br>    pmecb-&gt;GetVersion(&amp;ulBuildVersion, EECBGV_GETBUILDVERSION); <br>    if (EECBGV_BUILDVERSION_MAJOR != (ulBuildVersion &amp; EECBGV_BUILDVERSION_MAJOR_MASK)) <br>        return S_FALSE; <br> <br>    switch (mecontext) <br>    { <br>        case EECONTEXT_VIEWER: <br>        case EECONTEXT_SEARCHVIEWER: <br>            hr = S_OK; <br>            break; <br>        default: <br>            hr = S_FALSE; <br>            break; <br>    } <br>    return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  IExchExtCommands virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtCommands::QueryInterface() <br>// <br>//    Parameters <br>//    riid   -- Interface ID. <br>//    ppvObj -- address of interface object pointer. <br>// <br>//    Purpose <br>//    Exchange Client does not call IExchExtCommands::QueryInterface().   <br>//    So return nothing. <br>// <br>//    Return Value - none <br>// <br> <br>STDMETHODIMP MyExchExtCommands::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)           <br>{ <br>    *ppvObj = NULL; <br>    if ( (riid == IID_IExchExtCommands) || (riid == IID_IUnknown) ) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        // Increase usage count of this object <br>        AddRef(); <br>        return S_OK; <br>    } <br>    return E_NOINTERFACE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtCommands::InstallCommands() <br>// <br>//    Parameters <br>//    pmecb  -- Exchange Callback Interface <br>//    hWnd   -- window handle to main window of context <br>//    hMenu  -- menu handle to main menu of context <br>//    lptbeArray -- array of toolbar button entries <br>//    ctbe   -- count of button entries in array <br>//    ulFlags -- reserved <br>// <br>//    Purpose <br>//    This function is called when commands are installed for each context <br>//    the extension services. <br>// <br>//    Return Value <br>//    S_FALSE means the commands have been handled. <br>// <br>//    Comments <br>//    The hWnd and hMenu are in context.  If the context is for the SENDNOTE  <br>//    dialog, then the hWnd is the window handle to the dialog and the hMenu is <br>//    the main menu of the dialog. <br>//     <br>//    Call ResetToolbar so that Exchange will show it's toolbar <br>// <br> <br> <br>STDMETHODIMP MyExchExtCommands::InstallCommands(LPEXCHEXTCALLBACK pmecb,  <br>                            HWND hWnd, HMENU hMenu, <br>                            UINT FAR * pcmdidBase, LPTBENTRY lptbeArray, <br>                            UINT ctbe, ULONG ulFlags) <br>{ <br> HRESULT hr = S_FALSE; <br> HMENU hMenuTools; <br> <br> if ((EECONTEXT_SEARCHVIEWER == m_context) || (EECONTEXT_VIEWER == m_context)) <br> { <br> <br> <br>  // -------  install the new menu command, append to end of Tools menu. ---- <br>  m_hWnd = hWnd; <br> <br>  pmecb-&gt;GetMenuPos(EECMDID_ToolsCustomizeToolbar, &amp;hMenuTools, NULL, NULL, 0); <br>  <br> <br>  // add a menu separator <br>   AppendMenu(hMenuTools, MF_SEPARATOR, 0, NULL); <br> <br>  // add our extension command <br>   AppendMenu(hMenuTools, <br>         MF_BYPOSITION | MF_STRING,  <br>         *pcmdidBase,  <br>         "Folder Stats"); <br> <br>     m_cmdid = *pcmdidBase; <br> <br>     (*pcmdidBase)++; <br> <br> } <br> <br> if (EECONTEXT_VIEWER == m_context) <br> { <br> <br>  // --------------  install the new toolbar button -------------- <br> <br>  // walk through the toolbars and find the standard toolbar <br>   <br>  int tbindx; <br>  HWND hwndToolbar = NULL; <br>  for (tbindx = ctbe-1; (int) tbindx &gt; -1; --tbindx) <br>  { <br>   if (EETBID_STANDARD == lptbeArray[tbindx].tbid) <br>   { <br>    hwndToolbar = lptbeArray[tbindx].hwnd; <br>    m_itbb = lptbeArray[tbindx].itbbBase++; <br>    break; <br>   } <br>  } <br> <br>  // add out button's bitmap to the toolbar's set of buttons <br>  if (hwndToolbar) <br>  { <br>   TBADDBITMAP tbab; <br> <br>   tbab.hInst = ghInstDLL; <br>   tbab.nID = IDB_EXTBTN; <br>   m_itbm = SendMessage(hwndToolbar, TB_ADDBITMAP, 1, (LPARAM)&amp;tbab); <br>  } <br> <br> <br> } <br> <br> return hr; <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtCommands::DoCommand() <br>// <br>//    Parameters <br>//    pmecb -- pointer to Exchange Callback Interface <br>// <br>//    Purpose <br>//    This method is called by Exchange for each WM_COMMAND is sent to the <br>//    window in context.  <br>// <br>//    Return Value <br>//    S_OK if command is handled <br>//    S_FALSE if command is not handled <br>// <br>//    Comments <br>//    Use this function to either respond to the command item (menu or toolbar) <br>//    added or modify an existing command in Exchange.  Return S_OK to let <br>//    Exchange know the command was handled.  Return S_OK on commands you are <br>//    taking over from Exchange.  Return S_FALSE to let Exchange know you want <br>//    it to carry out its command, even if you modify its action. <br>// <br>                                                                                                           <br>STDMETHODIMP MyExchExtCommands::DoCommand(LPEXCHEXTCALLBACK pmecb, UINT cmdid) <br>{ <br> static char szBuffer[200]; <br> ULONG uNumSelected = 0; <br> ULONG ulSubFolders = 0; <br> ULONG ulReadMsgs = 0; <br> ULONG ulUnReadMsgs = 0; <br> LPMDB lpMDB = NULL; <br> LPMAPIFOLDER lpFolder = NULL; <br> LPMAPISESSION lpSession = NULL; <br> LPADRBOOK lpAddrBook = NULL; <br> ULONG cbeid; <br> LPENTRYID lpeid = NULL; <br> ULONG ulType; <br> char szMsgClass[50]; <br> ULONG cbMsgClass; <br>// ULONG ulMsgFlags;  <br>  <br> HRESULT hr = S_FALSE;   // assume it is not our command <br> <br> if (m_cmdid != cmdid) <br>    return hr;           // not our command <br> <br> if (m_context == EECONTEXT_VIEWER) <br> { <br> <br>    cbMsgClass = 49; <br>    szMsgClass[0] = '\0'; <br> <br> <br>    hr = pmecb-&gt;GetSession(&amp;lpSession, &amp;lpAddrBook); <br>    if (FAILED(hr)) <br>    { <br>        hr = S_OK;     // we still handled the command <br>        goto error_return; <br>    } <br> <br>    hr = pmecb-&gt;GetSelectionItem(0, &amp;cbeid, &amp;lpeid, &amp;ulType, NULL,  <br>        0, NULL, 0); <br>    if (FAILED(hr)) <br>    { <br>        hr = S_OK;     // we still handled the command <br>        goto error_return; <br>    } <br> <br>    if (ulType != MAPI_FOLDER)          // should never get this <br>    { <br>        hr = S_OK;     // we still handled the command <br>        goto error_return; <br>    } <br> <br> <br>    hr = lpSession-&gt;OpenEntry(cbeid, lpeid, NULL, 0, &amp;ulType,  <br>                         (LPUNKNOWN FAR *)&amp;lpFolder); <br>    if (FAILED(hr)) <br>    { <br>        hr = S_OK;     // we still handled the command <br>        goto error_return; <br>    } <br>     <br> <br>    if (NULL == lpFolder)  <br>    { <br>        hr = S_OK;     // we still handled the command <br>        goto error_return;              // no folder, not going to continue <br>    } <br> <br>    GetFolderStats(lpFolder, &amp;ulSubFolders, &amp;ulReadMsgs, &amp;ulUnReadMsgs); <br>    wsprintf(szBuffer, "Number of subfolders: %ld\n" <br>                       "Number of read messages: %ld\n" <br>                       "Number of unread messages: %ld",  <br>                       ulSubFolders, ulReadMsgs, ulUnReadMsgs); <br> <br>    MessageBox(m_hWnd, szBuffer, "Sample Extension - Folder Stats", MB_OK); <br> <br>    hr = S_OK; <br>     <br> } <br> <br> // must use a different technique in Find window <br> if (m_context == EECONTEXT_SEARCHVIEWER)   <br> { <br> <br> <br>    pmecb-&gt;GetObject(&amp;lpMDB, (LPMAPIPROP FAR *)&amp;lpFolder); <br> <br>    if (lpFolder == NULL) <br>    { <br>        hr = S_OK;     // we still handled the command <br>        goto error_return;              // no folder, not going to continue <br>    } <br> <br>    GetFolderStats(lpFolder, &amp;ulSubFolders, &amp;ulReadMsgs, &amp;ulUnReadMsgs); <br>    wsprintf(szBuffer, "Number of subfolders: %d\n" <br>                       "Number of read messages: %d\n" <br>                       "Number of unread messages: %d",  <br>                       ulSubFolders, ulReadMsgs, ulUnReadMsgs); <br> <br> <br>    MessageBox(m_hWnd, szBuffer, "Sample Extension - Folder Stats", MB_OK); <br> <br>    hr = S_OK; <br> <br> } <br> <br>error_return: <br> <br>    MAPIFreeBuffer(lpeid); <br>     <br>    if (NULL != lpSession) <br>        lpSession-&gt;Release(); <br> <br>    if (NULL != lpAddrBook) <br>        lpAddrBook-&gt;Release(); <br> <br>    if (NULL != lpMDB) <br>        lpMDB-&gt;Release();                         <br> <br>    if (NULL != lpFolder) <br>        lpFolder-&gt;Release(); <br> <br> return hr;  <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtCommands::InitMenu() <br>// <br>//    Parameters <br>//    pmecb -- pointer to Exchange Callback Interface <br>// <br>//    Purpose <br>//    This method is called by Exchange when the menu of context is about to <br>//    be activated.  See WM_INITMENU in the Windows API Reference for more <br>//    information. <br>// <br>//    Return Value - none <br>// <br> <br>STDMETHODIMP_(VOID) MyExchExtCommands::InitMenu(LPEXCHEXTCALLBACK pmecb) <br>{ <br> // do nothing <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtCommands::Help() <br>// <br>//    Parameters <br>//    pmecb -- pointer to Exchange Callback Interface <br>//    cmdid -- command id <br>// <br>//    Purpose <br>//    Respond when user presses F1 while custom menu item is selected. <br>// <br>//    Return Value <br>//    S_OK -- recognized the command and provided help <br>//    S_FALSE -- not our command and we didn't provide help <br>// <br> <br>STDMETHODIMP MyExchExtCommands::Help(LPEXCHEXTCALLBACK pmecb, UINT cmdid) <br>{ <br> HRESULT hr; <br> <br> <br> if (cmdid == m_cmdid) <br> { <br> <br>   MessageBox(m_hWnd, "Called through IExchExtCommands::Help()\n" <br>                      "Contained in cmdext32.dll\n\n" <br>                      "Copyright (c) 1995 Microsoft Corporation.\n" <br>                      "All rights reserved.", <br>                      "About Folder Stats Sample Extension", MB_OK); <br> <br>   hr = S_OK; <br> }  <br> else <br>   hr = S_FALSE; <br> <br> return hr; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtCommands::QueryHelpText() <br>// <br>//    Parameters <br>//    cmdid -- command id corresponding to menu item activated <br>//    ulFlags -- identifies either EECQHT_STATUS or EECQHT_TOOLTIP <br>//    psz -- pointer to buffer to be populated with text to display <br>//    cch -- count of characters available in psz buffer <br>// <br>//    Purpose <br>//    Exchange calls this function each time it requires to update the status <br>//    bar text or if it is to display a tooltip on the toolbar. <br>// <br>//    Return Value <br>//    S_OK to indicate our command was handled <br>//    S_FALSE to tell Exchange it can continue with its function <br>// <br> <br>STDMETHODIMP MyExchExtCommands::QueryHelpText(UINT cmdid, ULONG ulFlags,  <br>                                              LPTSTR psz, UINT cch) <br>{ <br> <br> HRESULT hr; <br> <br> if (cmdid == m_cmdid) <br> { <br>  if (ulFlags == EECQHT_STATUS) <br>    lstrcpyn(psz, "Display Stats on Current Folder", cch); <br>   <br>  if (ulFlags == EECQHT_TOOLTIP) <br>    lstrcpyn(psz, "Folder Stats", cch); <br> <br>  hr = S_OK; <br> <br> } <br> else <br>  hr = S_FALSE; <br> <br> return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtCommands::QueryButtonInfo() <br>// <br>//    Parameters <br>//    tbid    -- toolbar identifier <br>//    itbb    -- toolbar button index <br>//    ptbb    -- pointer to toolbar button structure -- see TBBUTTON structure <br>//    lpsz    -- point to string describing button <br>//    cch     -- maximum size of lpsz buffer <br>//    ulFlags -- EXCHEXT_UNICODE may be specified <br>// <br>//    Purpose <br>//    For Exchange to find out about toolbar button information. <br>// <br>//    Return Value <br>//    S_FALSE - not our button <br>//    S_OK    - we filled information about our button <br>// <br>//    Comments <br>//    Called for every button installed for toolbars when IExchExtCommands <br>//    is installed for each context. The lpsz text is used when the Customize <br>//    Toolbar dialog is displayed.  The text will be displayed next to the <br>//    button. <br>// <br> <br>STDMETHODIMP MyExchExtCommands::QueryButtonInfo (ULONG tbid, UINT itbb,  <br>                            LPTBBUTTON ptbb, LPTSTR lpsz, UINT cch,  <br>                            ULONG ulFlags) <br>{ <br> HRESULT hr = S_FALSE; <br> <br>  if (m_itbb == itbb) <br>  { <br>   ptbb-&gt;iBitmap = m_itbm;             // see InstallCommands in this source file <br>   ptbb-&gt;idCommand = m_cmdid; <br>   ptbb-&gt;fsState = TBSTATE_ENABLED; <br>   ptbb-&gt;fsStyle = TBSTYLE_BUTTON; <br>   ptbb-&gt;dwData = 0; <br>   ptbb-&gt;iString = -1; <br>   lstrcpyn(lpsz, "Folder Stats Toolbar Button", cch); <br> <br>   hr = S_OK; <br>  } <br> return hr; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtCommands::ResetToolbar() <br>// <br>//    Parameters <br>//    tbid <br>//    ulFlags <br>// <br>//    Purpose <br>// <br>//    Return Value  S_OK always <br>// <br>STDMETHODIMP MyExchExtCommands::ResetToolbar(ULONG tbid, ULONG ulFlags) <br>{ <br> return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  IExchExtUserEvents virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtUserEvents::QueryInterface() <br>// <br>//    Parameters <br>//    riid   -- Interface ID. <br>//    ppvObj -- address of interface object pointer. <br>// <br>//    Purpose <br>//    Exchange Client does not call IExchExtUserEvents::QueryInterface().   <br>//    So return nothing. <br>// <br>//    Return Value - none <br>// <br> <br>STDMETHODIMP MyExchExtUserEvents::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)           <br>{ <br>    *ppvObj = NULL; <br>    if (( riid == IID_IExchExtUserEvents) || (riid == IID_IUnknown) ) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        // Increase usage count of this object <br>        AddRef(); <br>        return S_OK; <br>    } <br>    return E_NOINTERFACE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtUserEvents::OnSelectionChange() <br>// <br>//    Parameters <br>//    pmecb  -- pointer to Exchange Callback Object <br>//     <br>// <br>//    Purpose <br>//    This function is called when the selection in the UI is changed. <br>// <br>//    Return Value - none <br>// <br>//    Comments <br>//    OnSelectionChange is called whenever the selection changes either within <br>//    a pane or is changed between panes. <br>// <br> <br>STDMETHODIMP_(VOID) MyExchExtUserEvents::OnSelectionChange(LPEXCHEXTCALLBACK pmecb) <br>{ <br> static ULONG cbeid; <br> static LPENTRYID lpeid = NULL; <br> static ULONG ulType; <br> static char szMsgClass[50]; <br> ULONG cbMsgClass; <br> ULONG ulMsgFlags; <br> HMENU hMenu; <br> HRESULT hr; <br> UINT cmdid; <br> MyExchExtCommands * pExchExtCommands = NULL; <br> <br> // do not care about enabling or disabling menu item if in the search viewer <br> if (m_context == EECONTEXT_SEARCHVIEWER) <br>    return; <br> <br> cbMsgClass = 49; <br> szMsgClass[0] = '\0'; <br> <br> <br> hr = pmecb-&gt;GetSelectionItem(0, &amp;cbeid, &amp;lpeid, &amp;ulType, szMsgClass,  <br>        cbMsgClass, &amp;ulMsgFlags, 0); <br>  <br> if (FAILED(hr)) <br> { <br>  goto error_return; <br> } <br> <br> <br> pmecb-&gt;GetMenu(&amp;hMenu); <br> <br> hr = m_pExchExt-&gt;QueryInterface(IID_IExchExtCommands, (LPVOID *)&amp;pExchExtCommands); <br> if (FAILED(hr)) <br> { <br>    goto error_return; <br> } <br> <br> cmdid = pExchExtCommands-&gt;GetCmdID(); <br> pExchExtCommands-&gt;Release(); <br> pExchExtCommands = NULL; <br> <br> <br> // enable or disable the command depending if the selected object is <br> // a folder or a "non-folder"  Enable if object is a folder. <br> if (ulType == MAPI_FOLDER) <br> { <br>    EnableMenuItem(hMenu, cmdid, MF_BYCOMMAND | MF_ENABLED); <br> } <br> else <br> { <br>    EnableMenuItem(hMenu, cmdid, MF_BYCOMMAND | MF_GRAYED); <br> } <br> <br> <br>error_return: <br> <br> if (lpeid != NULL) <br>    MAPIFreeBuffer(lpeid); <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtUserEvents::OnObjectChange() <br>// <br>//    Parameters <br>//    pmecb  -- pointer to Exchange Callback Object <br>//     <br>// <br>//    Purpose <br>//    This function is called when the selection in the UI is to a different <br>//    of object on the left pane. <br>// <br>//    Return Value - none <br>// <br>//    Comments <br>//    OnObjectChange is called whenever the selection is changed between  <br>//    objects in the left pane only.  Change in selection between folders,  <br>//    subfolders or container object in the left pane will be reflected with a <br>//    call to OnObjectChange.  Change in selection between objects (messages,  <br>//    subfolders) in the right pane will not call OnObjectChange, only  <br>//    OnSelectionChange. <br>// <br> <br>STDMETHODIMP_(VOID) MyExchExtUserEvents::OnObjectChange(LPEXCHEXTCALLBACK pmecb) <br>{ <br> // no need to handle this one <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  Helper functions to accomplish this extension's task <br>// <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetFolderStats() <br>// <br>//    Parameters <br>//    lpFolder      -- pointer to Folder of which to get statistics <br>//    pulFolder     -- pointer to buffer to be filled with number of subfolders <br>//    pulReadMsgs   -- pointer to buffer to be filled with number of read  <br>//                     messages <br>//    pulUnReadMsgs -- pointer to buffer to be filled with number of unread <br>//                     messages <br>// <br>//    Purpose <br>//    This function gathers information information about the given message <br>//    folder.  It calculates the number of subfolders, read messages, and <br>//    unread messages. <br>// <br>//    Return Value - none <br>// <br>//    Comments <br>//    The Find window results folder only contains messages and not subfolders <br>//    so it sets the number of subfolders to zero <br>// <br> <br>void GetFolderStats(LPMAPIFOLDER lpFolder, ULONG FAR * pulSubFolders,  <br>                    ULONG FAR * pulReadMsgs, ULONG FAR * pulUnReadMsgs) <br>{ <br> HRESULT hr = 0; <br> LPMAPITABLE lpTable = NULL; <br> ULONG ulRows = 0; <br> UINT u; <br> LPSRowSet lpRows = NULL; <br> <br> enum { MESSAGE_FLAGS, STATTAGS }; <br> <br> SizedSPropTagArray(STATTAGS,  MsgTags) = <br>      { STATTAGS,  <br>        {  <br>         PR_MESSAGE_FLAGS        // contains read/unread flags <br>        }  <br>      }; <br> <br> <br> hr = lpFolder-&gt;GetHierarchyTable(0, &amp;lpTable);   // get table of subfolders <br> if (MAPI_E_NO_SUPPORT == hr)                     // Find window folder doesn't  <br>    *pulSubFolders = 0;                           // support GetHierarchyTable <br>     <br> else if (S_OK != hr)              // some other error <br>    goto error_return; <br> <br> if (lpTable != NULL) <br> { <br>    lpTable-&gt;GetRowCount(0, pulSubFolders); <br>    lpTable-&gt;Release(); <br>    lpTable =NULL; <br> } <br> <br> hr = lpFolder-&gt;GetContentsTable(0, &amp;lpTable);    // get table of messages <br> if (S_OK != hr) <br>    goto error_return; <br> <br> hr = lpTable-&gt;SetColumns((LPSPropTagArray)&amp;MsgTags, 0); <br> if (S_OK != hr) <br>    goto error_return; <br> <br> lpTable-&gt;GetRowCount(0, &amp;ulRows); <br> hr = lpTable-&gt;QueryRows(ulRows, 0, &amp;lpRows); <br> if (S_OK != hr) <br>    goto error_return; <br> <br> *pulReadMsgs = 0; <br> *pulUnReadMsgs = 0; <br> <br> for (u=0; u&lt;ulRows; u++) <br> { <br> <br>  if (MSGFLAG_READ &amp; lpRows-&gt;aRow[u].lpProps[MESSAGE_FLAGS].Value.ul) <br>    (*pulReadMsgs)++; <br>  else <br>    (*pulUnReadMsgs)++; <br> <br> } <br> <br> <br>error_return: <br> <br> if (NULL != lpTable) <br>    lpTable-&gt;Release(); <br> <br> if (NULL != lpRows) <br>    FreeProws(lpRows); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
