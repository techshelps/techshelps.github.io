<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMEM.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2067"></a>IMEM.C</h2>
<pre><code>/* <br> *  IMEM.C <br> *   <br> *  Per-instance global data for WIN32 (trivial), WIN16, and Mac. <br> * <br> *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved. <br> */ <br> <br>#pragma warning(disable:4100)   /* unreferenced formal parameter */ <br>#pragma warning(disable:4201)   /* nameless struct/union */ <br>#pragma warning(disable:4209)   /* benign typedef redefinition */ <br>#pragma warning(disable:4214)   /* bit field types other than int */ <br>#pragma warning(disable:4001)   /* single line comments */ <br>#pragma warning(disable:4115)   /* named type definition in parens */ <br> <br>#ifdef _WIN32 <br>#define INC_OLE2 /* Get the OLE2 stuff */ <br>#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */ <br>#endif <br>#include &lt;windows.h&gt; <br> <br>#include &lt;windowsx.h&gt; <br>#include &lt;mapiwin.h&gt; <br>#if defined (_WIN32) &amp;&amp; !defined (_MAC) <br>#pragma warning(disable:4001)   /* single line comments */ <br>#include &lt;objerror.h&gt; <br>#include &lt;objbase.h&gt; <br>#endif <br>#ifdef WIN16 <br>#include &lt;compobj.h&gt; <br>#endif <br>#include &lt;mapicode.h&gt; <br>#include &lt;mapidbg.h&gt; <br> <br>#ifdef _MAC <br>#include &lt;macname1.h&gt; <br>#include &lt;macos\lowmem.h&gt; <br>#include &lt;macname2.h&gt; <br>#include &lt;utilmac.h&gt; <br>#endif <br> <br>#ifdef  DEBUG <br>#define STATIC <br>#else <br>#define STATIC static <br>#endif <br> <br>#pragma warning (disable:4514)      /* unreferenced inline function */ <br> <br>#ifdef  WIN16 <br> <br>#pragma code_seg("IMAlloc") <br> <br>#pragma warning(disable: 4005)      /* redefines MAX_PATH */ <br>#include &lt;toolhelp.h&gt; <br>#pragma warning(default: 4005) <br> <br>#pragma warning(disable: 4704)      /* Inline assembler */ <br> <br>/* <br> *  These arrays are parallel. RgwInstKey holds the stack <br> *  segment of each task that calls the DLL we're in; rgpvInst <br> *  has a pointer to that task's instance globals in the slot with <br> *  the same index. Since all Win16 tasks share the same x86 <br> *  segment descriptor tables, no two tasks can have the same stack <br> *  segment. <br> *   <br> *  Note carefully the last elements of the initializers. The value <br> *  in rgwInstKey is a sentinel, which will always stop the scan <br> *  whether the value being sought is a valid stack segment or <br> *  zero. <br> */ <br> <br>STATIC WORD   rgwInstKey[cInstMax+1]= { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0xFFFF }; <br>STATIC LPVOID rgpvInst[cInstMax+1]=   { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }; <br>STATIC DWORD  rgdwPid[cInstMax+1]=    { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }; <br> <br>STATIC WORD   wCachedKey            = 0; <br>STATIC LPVOID pvCachedInst          = NULL; <br> <br>/* <br> -  IFindInst <br> -   <br> *  Purpose: <br> *      Used to locate a particular task's instance pointer, and <br> *      also to find a free slot in the table. <br> *   <br> *  Arguments: <br> *      The value to look up. This is either a task's stack <br> *      segment, or 0 (if an empty slot is being sought). <br> *   <br> *  Returns: <br> *      Returns the index of the given value in rgwInstKey.  <br> *      If the value is not present, returns cInstMax. <br> *   <br> */ <br> <br>#pragma warning(disable: 4035)      /* function return value done in asm */ <br> <br>STATIC int <br>IFindInst(WORD w) <br>{ <br>    _asm <br>    { <br>        mov cx,cInstMax+1           /* count includes sentinel */ <br>        mov ax,ds                   /* point es:di at rgwInstKey */ <br>        mov es,ax <br>        mov di,OFFSET rgwInstKey <br>        mov ax,w                    /* scan for this value */ <br>        cld                         /* scan forward... */ <br>        repne scasw                 /* go */ <br>        mov ax,cx                   /* Convert the number of items remaining */ <br>        sub ax,cInstMax+1           /* to the index of the item found. */ <br>        inc ax <br>        neg ax <br>    } <br>} <br> <br>#pragma warning(default: 4035) <br> <br>/* <br> -  PvGetInstanceGlobals <br> -   <br> *  Purpose: <br> *      Returns a pointer to the instance global data structre for <br> *      the current task. <br> *   <br> *  Returns: <br> *      Pointer to the instance data structure, or NULL if no <br> *      structure has yet been installed for this task. <br> */ <br> <br>LPVOID FAR PASCAL <br>PvGetInstanceGlobals(void) <br>{ <br>    int iInst; <br>    WORD wMe; <br>     <br>    _asm mov wMe,ss         ; get key for this process <br> <br>    /* First check cached value */ <br>    if (wCachedKey == wMe) <br>        return pvCachedInst; <br> <br>    /* Miss, do the lookup */ <br>    iInst = IFindInst(wMe); <br> <br>    /* Cache and return the found value */ <br>    if (iInst != cInstMax) <br>    { <br>        wCachedKey = wMe; <br>        pvCachedInst = rgpvInst[iInst]; <br>    } <br>    return rgpvInst[iInst];     /* Note: parallel to the lookup sentinel */ <br>} <br> <br>LPVOID FAR PASCAL <br>PvGetVerifyInstanceGlobals(DWORD dwPid) <br>{ <br>    int iInst; <br>    WORD wMe; <br>     <br>    _asm mov wMe,ss         ; get key for this process <br> <br>    /* Always do the lookup */ <br>    iInst = IFindInst(wMe); <br> <br>    /* If SS misses, return null right away */ <br>    if (iInst == cInstMax) <br>        return NULL; <br> <br>    /* SS hit, now check the OLE process ID */ <br>    if (dwPid != rgdwPid[iInst]) <br>    { <br>        wCachedKey = 0;         /* Take no chances */ <br>        rgwInstKey[iInst] = 0; <br>        rgpvInst[iInst] = 0; <br>        rgdwPid[iInst] = 0; <br>        return NULL; <br>    } <br> <br>    /* Cache and return the found value */ <br>    wCachedKey = wMe; <br>    pvCachedInst = rgpvInst[iInst]; <br>    return pvCachedInst; <br>} <br> <br>LPVOID FAR PASCAL <br>PvSlowGetInstanceGlobals(DWORD dwPid) <br>{ <br>    int iInst; <br>     <br>    /* Always do the lookup */ <br>    for (iInst = 0; iInst &lt; cInstMax; ++iInst) <br>    { <br>        if (rgdwPid[iInst] == dwPid) <br>            break; <br>    } <br> <br>    /* If PID misses, return null */ <br>    if (iInst == cInstMax) <br>        return NULL; <br> <br>    /* Return the found value. Do not cache; this function is being <br>     * called because SS is not what it "normally" is. <br>     */ <br>    return rgpvInst[iInst]; <br>} <br> <br>/* <br> -  ScSetVerifyInstanceGlobals <br> -   <br> *  Purpose: <br> *      Installs or deinstalls instance global data for the current task. <br> *   <br> *  Arguments: <br> *      pv          in      Pointer to instance data structure (to <br> *                          install); NULL (to deinstall). <br> *      dwPid       in      Zero or process ID, for better matching. <br> *   <br> *  Returns: <br> *      MAPI_E_NOT_ENOUGH_MEMORY if no slot is available in the <br> *      fixed-size table, else 0. <br> */ <br> <br>LONG FAR PASCAL <br>ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid) <br>{ <br>    int iInst; <br>    WORD wMe; <br> <br>    _asm mov wMe,ss <br>    if (pv) <br>    { <br>        /* I am NOT supposed to be in the array at this time! */ <br>        Assert(IFindInst(wMe) == cInstMax); <br> <br>        /* Installing instance globals. Find a free slot and park there. */ <br>        iInst = IFindInst(0); <br>        if (iInst == cInstMax) <br>        { <br>#ifdef  DEBUG <br>            OutputDebugString("Instance globals maxed out\r\n"); <br>#endif   <br>            return MAPI_E_NOT_ENOUGH_MEMORY; <br>        } <br>        rgpvInst[iInst] = pv; <br>        rgwInstKey[iInst] = wMe; <br>        rgdwPid[iInst] = dwPid; <br> <br>        /* Set the cache. */ <br>        wCachedKey = wMe; <br>        pvCachedInst = pv; <br>    } <br>    else <br>    { <br>        /* Deinstalling instance globals. Search and destroy. */ <br>        iInst = IFindInst(wMe); <br>        if (iInst == cInstMax) <br>        { <br>#ifdef  DEBUG <br>            OutputDebugString("No instance globals to reset\r\n"); <br>#endif   <br>            return MAPI_E_NOT_INITIALIZED; <br>        } <br>        rgpvInst[iInst] = NULL; <br>        rgwInstKey[iInst] = 0; <br>        rgdwPid[iInst] = 0L; <br> <br>        /* Clear the cache. */ <br>        wCachedKey = 0; <br>        pvCachedInst = NULL; <br>    } <br> <br>    return 0; <br>} <br> <br>LONG FAR PASCAL <br>ScSetInstanceGlobals(LPVOID pv) <br>{ <br>    return ScSetVerifyInstanceGlobals(pv, 0L); <br>} <br> <br>BOOL __export FAR PASCAL <br>FCleanupInstanceGlobals(WORD wID, DWORD dwData) <br>{ <br>    int iInst; <br>    WORD wMe; <br> <br>    /* <br>     *  Would be nice if we could release the pmalloc <br>     *  and the inst structure in this function, but docs say <br>     *  don't make Windows calls from this callback. <br>     *  That means also NO DEBUG TRACES <br>     */ <br> <br>    /* <br>     *  First, double-check that the DLL's data segment is available. <br>     *  Code snitched from MSDN article "Loading, Initializing, and <br>     *  Terminating a DLL." <br>     */ <br>    _asm <br>    { <br>        push cx <br>        mov cx, ds          ; get selector of interest <br>        lar ax, cx          ; get selector access rights <br>        pop cx <br>        jnz bail            ; failed, segment is bad <br>        test ax, 8000h      ; if bit 8000 is clear, segment is not loaded <br>        jz bail             ; we're OK <br>    } <br> <br>    if (wID == NFY_EXITTASK) <br>    { <br>        _asm mov wMe,ss <br>        iInst = IFindInst(wMe); <br> <br>        if (iInst &lt; cInstMax) <br>        { <br>            /* Clear this process's entry */ <br>            rgpvInst[iInst] = NULL; <br>            rgwInstKey[iInst] = 0; <br>        } <br> <br>        /* Clear the cache too */ <br>        wCachedKey = 0; <br>        pvCachedInst = NULL; <br>    } <br> <br>bail: <br>    return 0;       /* don't suppress further notifications */ <br>} <br> <br>#elif defined(_MAC) /* !WIN16 */ <br> <br>#pragma code_seg("imalloc", "fixed") <br> <br>/* <br> *  The Mac implementation uses a linked list containing unique keys <br> *  to the calling process and pointers to instance data. This linked <br> *  list is n-dimensional because the Mac version often groups several <br> *  dlls into one exe. <br> * <br> *  The OLE code that TomSax wrote allows us to keep track of the caller's <br> *  %a5 world when we call from another application. This code depends on <br> *  on that. <br> * <br> */ <br> <br>typedef struct tag_INSTDATA { <br>    DWORD                   dwInstKey; <br>    DWORD                   dwPid; <br>    LPVOID                  lpvInst[kMaxSet]; <br>    struct tag_INSTDATA     *next; <br>} INSTDATA, *LPINSTDATA, **HINSTDATA; <br> <br> <br>LPINSTDATA      lpInstHead = NULL; <br> <br>#define PvSlowGetInstanceGlobals(_dw, _dwId)    PvGetVerifyInstanceGlobals(_dw, _dwId) <br> <br>VOID <br>DisposeInstData(LPINSTDATA lpInstPrev, LPINSTDATA lpInst) <br>{ <br>    HINSTDATA   hInstHead = &amp;lpInstHead; <br>     <br>    /* This better only happen when both elements are NULL! */ <br>    if (lpInst-&gt;lpvInst[kInstMAPIX] == lpInst-&gt;lpvInst[kInstMAPIU]) <br>    { <br>        /* No inst data, remove element from linked list */ <br>        if (lpInst == *hInstHead) <br>            *hInstHead = lpInst-&gt;next; <br>        else <br>            lpInstPrev-&gt;next = lpInst-&gt;next; <br>        DisposePtr((Ptr)lpInst); <br>    } <br>} <br> <br>/* <br> -  PvGetInstanceGlobals <br> -   <br> *  Purpose: <br> *      Returns a pointer to the instance global data structre for <br> *      the current task. <br> *   <br> *  Returns: <br> *      Pointer to the instance data structure, or NULL if no <br> *      structure has yet been installed for this task. <br> */ <br> <br>LPVOID FAR PASCAL <br>PvGetInstanceGlobals(WORD wDataSet) <br>{ <br>    HINSTDATA       hInstHead = &amp;lpInstHead; <br>    LPINSTDATA      lpInst = *hInstHead; <br> <br>#ifdef DEBUG <br>    if (wDataSet &gt;= kMaxSet) <br>    { <br>        DebugStr("\pPvGetInstanceGlobals : This data set has not been defined."); <br>        return NULL; <br>    } <br>#endif <br> <br>    while (lpInst) <br>    { <br>        if (lpInst-&gt;dwInstKey == (DWORD)LMGetCurrentA5()) <br>            break; <br>        lpInst = lpInst-&gt;next; <br>    }  <br>    return(lpInst-&gt;lpvInst[wDataSet]); <br>} <br> <br>LPVOID FAR PASCAL <br>PvGetVerifyInstanceGlobals(DWORD dwPid, DWORD wDataSet) <br>{ <br>    HINSTDATA   hInstHead = &amp;lpInstHead; <br>    LPINSTDATA  lpInst, lpInstPrev; <br> <br>    lpInst = lpInstPrev = *hInstHead; <br> <br>    /* Always do the lookup */ <br>    while (lpInst) <br>    { <br>        if (lpInst-&gt;dwInstKey == (DWORD)LMGetCurrentA5()) <br>            break; <br>        lpInstPrev = lpInst; <br>        lpInst = lpInst-&gt;next; <br>    } <br> <br>    /* If PvGetInstanceGlobals() misses, return NULL right away */ <br>    if (lpInst-&gt;lpvInst[wDataSet] == NULL) <br>        return NULL; <br> <br>    /* Found a match, now check the OLE process ID */ <br>    if (dwPid != lpInst-&gt;dwPid) <br>    { <br>        DisposeInstData(lpInstPrev, lpInst); <br>        return NULL; <br>    } <br> <br> <br>    /* Return the found value */ <br>    return lpInst-&gt;lpvInst[wDataSet]; <br>} <br> <br>/* <br> -  ScSetVerifyInstanceGlobals <br> -   <br> *  Purpose: <br> *      Installs or deinstalls instance global data for the current task. <br> *   <br> *  Arguments: <br> *      pv          in      Pointer to instance data structure (to <br> *                          install); NULL (to deinstall). <br> *      dwPid       in      Zero or process ID, for better matching. <br> *      wDataSet    in      Inst data set to init or deinit (MAPIX or MAPIU) <br> *   <br> *  Returns: <br> *      MAPI_E_NOT_ENOUGH_MEMORY if a pointer of INSTDATA size cannot be <br> *      created, else 0. <br> */ <br> <br>LONG FAR PASCAL <br>ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid, WORD wDataSet) <br>{ <br>    HINSTDATA       hInstHead = &amp;lpInstHead; <br>    LPINSTDATA      lpInst, lpInstPrev; <br> <br>    lpInst = lpInstPrev = *hInstHead; <br> <br>    Assert(wDataSet &lt; kMaxSet); <br> <br>    /* Find our linked list element and the one before it */ <br>    while (lpInst) <br>    { <br>        if (lpInst-&gt;dwInstKey == (DWORD)LMGetCurrentA5()) <br>            break; <br>        lpInstPrev = lpInst; <br>        lpInst = lpInst-&gt;next; <br>    } <br> <br>    if (pv) <br>    { <br>        if (lpInst) <br>        { <br>            /* I am NOT supposed to be in the array at this time! */ <br>            Assert(lpInst-&gt;lpvInst[wDataSet] == NULL); <br>            lpInst-&gt;lpvInst[wDataSet] = pv; <br>        } <br>        else <br>        { <br>            /* Add a new linked list element and store &lt;pv&gt; there. */ <br>            lpInst = (LPVOID) NewPtrClear(sizeof(INSTDATA)); <br>            if (!lpInst) <br>            { <br>#ifdef  DEBUG <br>                OutputDebugString("Instance globals maxed out\r"); <br>#endif   <br>                return MAPI_E_NOT_ENOUGH_MEMORY; <br>            } <br>            if (lpInstPrev) <br>                lpInstPrev-&gt;next = lpInst; <br>            else <br>                *hInstHead = lpInst; <br>            lpInst-&gt;dwInstKey = (DWORD)LMGetCurrentA5(); <br> <br>            lpInst-&gt;dwPid = dwPid; <br>            lpInst-&gt;lpvInst[wDataSet] = pv; <br>        } <br>    } <br>    else <br>    { <br>        /* Deinstalling instance globals. Search and destroy. */ <br>        if (lpInst == NULL || lpInst-&gt;lpvInst[wDataSet] == NULL) <br>        { <br>#ifdef  DEBUG <br>            OutputDebugString("No instance globals to reset\r"); <br>#endif   <br>            return MAPI_E_NOT_INITIALIZED; <br>        } <br>        /* The memory for &lt;lpInst-&gt;lpvInst[wDataSet]&gt; is disposed of    */ <br>        /* elsewhere. just as it was allocated elsewhere.               */ <br>        lpInst-&gt;lpvInst[wDataSet] = NULL; <br>        DisposeInstData(lpInstPrev, lpInst); <br>    } <br> <br>    return 0; <br>} <br> <br> <br>LONG FAR PASCAL <br>ScSetInstanceGlobals(LPVOID pv, WORD wDataSet) <br>{ <br>    return ScSetVerifyInstanceGlobals(pv, 0L, wDataSet); <br>} <br> <br>BOOL FAR PASCAL <br>FCleanupInstanceGlobals(WORD wID, DWORD dwData) <br>{ <br>/* <br> * This is no longer used. <br> * <br> */ <br> <br>#ifdef DEBUG <br>    DebugStr("\pCalled FCleanupInstanceGlobals : Empty function"); <br>#endif <br> <br>    return 0; <br>} <br> <br>#else /* !WIN16 &amp;&amp; !_MAC */ <br> <br>/* This is the entire 32-bit implementation for instance globals. */ <br> <br>VOID FAR *pinstX = NULL; <br> <br>#endif  /* WIN16 */ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
