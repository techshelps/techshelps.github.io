<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LASTERR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2068"></a>LASTERR.CPP</h2>
<pre><code>// <br>//  LASTERR.CPP <br>// <br>// implementation file for CLastError which implements the <br>// GetLastError helper <br>// <br>//   <br>// <br>// Copyright (C) 1995 Microsoft Corp. <br>// <br> <br>#define STRICT <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include "lasterr.h" <br> <br>const int       CchMaxErrorMessage = 256; <br> <br>extern const CHAR FAR  SzNull[] = ""; <br>char szErrUnknown[] = "Error description is not available"; <br> <br>// <br>// some stuff to put a "Help" button on the error msgbox <br>// <br>#if defined(_WIN32) <br>char szHelpFile[_MAX_PATH]; <br>VOID CALLBACK ErrorBoxCallBack(LPHELPINFO lpHelpInfo); <br>#endif //_WIN32 <br> <br>static LPSTR aszErrorStrings[] =  <br>{ <br>    "Not enough memory", <br>    "Invalid arguments", <br>    "Invalid object", <br>    "Interface not supported", <br>    "Access denied", <br>    "No support", <br>    "Wrong character set", <br>    "Item not found", <br>    "Call failed", <br>    "User cancel", <br>    "Errors returned", <br>    "Invalid flags", <br>    "Unexpected error", <br>    "Can't perform the required action at this time" <br>}; <br> <br>enum  <br>{ <br>    IDS_E_OUTOFMEMORY, <br>    IDS_INVALID_ARGUMENT, <br>    IDS_INVALID_OBJECT, <br>    IDS_INTERFACE_NOT_SUPPORTED, <br>    IDS_ACCESS_DENIED, <br>    IDS_NOT_SUPPORTED, <br>    IDS_INVALID_CHARWIDTH, <br>    IDS_NOT_FOUND, <br>    IDS_CALL_FAILED, <br>    IDS_USER_CANCEL, <br>    IDS_ERRORS_RETURNED, <br>    IDS_UNKNOWN_FLAGS, <br>    IDS_UNEXPECTED, <br>    IDS_CANTNOW <br>};   <br> <br>static int iFromHR(HRESULT hr) <br>{ <br>    switch(GetScode(hr)) { <br>    case MAPI_E_NOT_ENOUGH_MEMORY:      return IDS_E_OUTOFMEMORY; <br>    case MAPI_E_INVALID_PARAMETER:      return IDS_INVALID_ARGUMENT; <br>    case MAPI_E_INVALID_OBJECT:         return IDS_INVALID_OBJECT; <br>    case MAPI_E_INTERFACE_NOT_SUPPORTED: return IDS_INTERFACE_NOT_SUPPORTED; <br>    case MAPI_E_NO_ACCESS:              return IDS_ACCESS_DENIED; <br>    case MAPI_E_NO_SUPPORT:             return IDS_NOT_SUPPORTED; <br>    case MAPI_E_BAD_CHARWIDTH:          return IDS_INVALID_CHARWIDTH; <br>    case MAPI_E_NOT_FOUND:              return IDS_NOT_FOUND; <br>    case MAPI_E_CALL_FAILED:            return IDS_CALL_FAILED; <br>    case MAPI_E_USER_CANCEL:            return IDS_USER_CANCEL; <br>    case MAPI_W_ERRORS_RETURNED:        return IDS_ERRORS_RETURNED; <br>    case MAPI_E_UNKNOWN_FLAGS:          return IDS_UNKNOWN_FLAGS; <br>    case E_UNEXPECTED:                  return IDS_UNEXPECTED; <br>    case OLEOBJ_S_CANNOT_DOVERB_NOW:    return IDS_CANTNOW; <br>    // if it's not in this list you need to add it. <br>    default: <br>        DebugTrace("lasterr: bad arg to FORMScodeFromHR"); <br>        Assert(FALSE); <br>        return 0; <br>    } <br>} <br> <br>HRESULT CLastError::HrSetLastError(HRESULT hr) <br>{ <br>#if defined(DEBUG) <br>    // <br>    //  Ensure that the error string exists -- when we set it not when <br>    //  they ask for it. <br>    // <br> <br>    (void) iFromHR(hr); <br>#endif <br> <br>    // <br>    //  Release any previous error <br>    // <br> <br>    if (m_pmapierr != NULL) { <br>        MAPIFreeBuffer(m_pmapierr); <br>        m_pmapierr = NULL; <br>    } <br> <br>    if (hr) { <br>        m_eLastErr = eMAPI; <br>    } <br>    else { <br>        m_eLastErr = eNoError; <br>    } <br> <br>    return (m_hrLast = hr); <br>} <br> <br>HRESULT CLastError::HrSetLastError(HRESULT hr, IUnknown* punk) <br>{ <br>    Assert(punk &amp;&amp; hr);     // we have to have an object and an error. <br> <br>    m_eLastErr = eObject; <br>    m_hrLast = hr; <br> <br>    IMAPIProp* pmprp = (IMAPIProp*)punk;  // I hate this cast but c'est la vie. <br> <br>    MAPIFreeBuffer(m_pmapierr);     // clean up previous error. <br>    m_pmapierr = NULL; <br> <br>    m_hrGLE = pmprp-&gt;GetLastError(hr, 0, &amp;m_pmapierr); <br>    if (m_hrGLE == S_OK) { <br>        if (m_pmapierr == NULL) { <br>            if (MAPIAllocateBuffer(sizeof(MAPIERROR), (void **) &amp;m_pmapierr)) { <br>                m_hrGLE = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY); <br>            } <br>            else { <br>                memset(m_pmapierr, 0, sizeof(MAPIERROR)); <br>                m_pmapierr-&gt;ulVersion = MAPI_ERROR_VERSION; <br>                m_pmapierr-&gt;lpszError = szErrUnknown; <br>                m_pmapierr-&gt;lpszComponent = (char *) SzNull; <br>            } <br>        } <br>        else if (m_pmapierr-&gt;lpszError == NULL) { <br>            m_pmapierr-&gt;lpszError = (char *) SzNull; <br>        } <br>        else if (m_pmapierr-&gt;lpszComponent == NULL) { <br>            m_pmapierr-&gt;lpszComponent = (char *) SzNull; <br>        } <br>    } <br>    else { <br>        if (m_pmapierr != NULL) { <br>            MAPIFreeBuffer(m_pmapierr); <br>            m_pmapierr = NULL; <br>        } <br>    } <br>    return m_hrLast; <br>} <br> <br>HRESULT CLastError::HrGetLastError(HRESULT hr, DWORD dwFlags, <br>                                   LPMAPIERROR FAR * lppMAPIError) <br>{ <br>    // <br>    //  Start with parameter validation <br>    // <br> <br>    if (IsBadWritePtr(lppMAPIError, sizeof(LPMAPIERROR))) { <br>        return HrSetLastError(ResultFromScode(MAPI_E_INVALID_PARAMETER)); <br>    } <br> <br>    if (MAPI_UNICODE == (dwFlags &amp; MAPI_UNICODE)) { <br>        return HrSetLastError(ResultFromScode(MAPI_E_BAD_CHARWIDTH)); <br>    } <br> <br>    // <br>    //  Is the error asked for the last error registered with us? <br>    // <br> <br>    if (hr != m_hrLast) { <br>        *lppMAPIError = NULL; <br>        return S_OK; <br>    } <br> <br>    int         cch; <br>    int         cb; <br>    int         idsError; <br>    TCHAR*      szMessage = 0; <br>    TCHAR*      szComponent = 0; <br>    LPMAPIERROR pmapierr = NULL; <br> <br>    // <br>    //  Based on the type of the last error, construct the appropriate <br>    //  return object <br>    // <br> <br>    switch (m_eLastErr) { <br>    case eMAPI: <br>        // <br>        //  The last error registered was a MAPI error code.  For mapi <br>        //      error codes we map the MAPI error code into a resource <br>        //      id and return the appropriate string. <br>        // <br>        // as to spec, we allocate a single buffer for message and <br>        //      component.  no one will notice that we aren't doing <br>        //      MAPIAllocateMore for component. <br>        // <br>        //   We make an assumption as to the maximum possible length <br>        //      of the two strings combined. <br>        // <br> <br>        Assert(m_pmapierr == NULL); <br>        if (MAPIAllocateBuffer(CchMaxErrorMessage*sizeof(TCHAR)+sizeof(MAPIERROR), <br>                               (void**)&amp;pmapierr)) { <br>            return ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY); <br>        } <br> <br>        // <br>        //  Set the version number <br>        // <br> <br>        pmapierr-&gt;ulVersion = MAPI_ERROR_VERSION; <br>        pmapierr-&gt;ulLowLevelError = 0; <br> <br>        // <br>        //   do the maping from the MAPI error code into a FORM string <br>        //      value.  The FORM eror code code will be set as the low <br>        //      level error value. <br>        // <br> <br>        idsError = iFromHR(m_hrLast); <br>        pmapierr-&gt;ulContext = idsError; <br> <br>        // <br>        //  Set the error string pointer to the appropriate location <br>        //      in the error buffer and load the error string. <br>        // <br> <br>        pmapierr-&gt;lpszError = (LPTSTR) (sizeof(MAPIERROR) + <br>                                          (BYTE *) pmapierr); <br> <br>        lstrcpy(pmapierr-&gt;lpszError, aszErrorStrings[idsError]); <br>        cch = lstrlen(aszErrorStrings[idsError]); <br>         <br>         <br>        // <br>        // Set the componment string pointer to the appropriate location <br>        //      in the error buffer and load the component string. <br>        // <br> <br>        pmapierr-&gt;lpszComponent = pmapierr-&gt;lpszError + cch + 1; <br>        cch = CchMaxErrorMessage - cch - 1; <br> <br>        lstrcpy(pmapierr-&gt;lpszComponent, <br>                        m_szComponent ? m_szComponent : SzNull); <br>        cch = lstrlen(pmapierr-&gt;lpszComponent); <br>         <br>        if (cch == 0) { <br>            *(pmapierr-&gt;lpszComponent) = 0; <br>        } <br> <br>        break; <br> <br> <br>    case eObject: <br>        // <br>        //  The last regisered error message came from an object.  If we <br>        //      could not get the last error from the object, just return <br>        //      the error it returned and we are done. <br>        // <br> <br>        if (m_hrGLE != NOERROR) { <br>            Assert( m_pmapierr == NULL ); <br>            *lppMAPIError = NULL; <br>            return m_hrGLE; <br>        } <br> <br>    case eExtended: <br>        // <br>        //  The last error was an extended error.  The error is in the <br>        //      structure, we need to copy this structure and return <br>        //      it back to the user <br>        // <br> <br>        Assert( m_pmapierr != NULL ); <br>        cb = lstrlen(m_pmapierr-&gt;lpszError) + lstrlen(m_pmapierr-&gt;lpszComponent); <br> <br>        if (MAPIAllocateBuffer(cb + 2 + sizeof(MAPIERROR), <br>                               (void **) &amp;pmapierr)) { <br>            return ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY); <br>        } <br> <br>        *pmapierr = *m_pmapierr; <br>        pmapierr-&gt;lpszError = (LPTSTR) (sizeof(MAPIERROR) + (BYTE *) pmapierr); <br>        lstrcpy(pmapierr-&gt;lpszError, m_pmapierr-&gt;lpszError); <br>        pmapierr-&gt;lpszComponent = pmapierr-&gt;lpszError + <br>          lstrlen(pmapierr-&gt;lpszError) + 1; <br>        lstrcpy(pmapierr-&gt;lpszComponent, m_pmapierr-&gt;lpszComponent); <br> <br>        break; <br> <br>    case eNoError: <br>        break; <br> <br>    default: <br>        Assert(0); <br>        return NOERROR; <br>    } <br> <br>    *lppMAPIError = pmapierr; <br>    return ResultFromScode(S_OK); <br>} <br> <br> <br> <br>int CLastError::ShowError(HWND hWnd) <br>{ <br>    char szMessage[512]; <br>    char szbuf[256]; <br> <br>    if(m_eLastErr != eObject || NULL == m_pmapierr) return 0; <br> <br>    wsprintf(szMessage, "%s\n%s\nLowLevelError: 0x%08lx context: %ld ", <br>                        (m_pmapierr-&gt;lpszError ? m_pmapierr-&gt;lpszError:""), <br>                        m_pmapierr-&gt;lpszComponent ? m_pmapierr-&gt;lpszComponent:"", <br>                        m_pmapierr-&gt;ulLowLevelError, m_pmapierr-&gt;ulContext); <br>    <br>    wsprintf (szbuf, "\nReturn Code: 0x%08lx", SCODE(m_hrLast)); <br>    lstrcat (szMessage, szbuf); <br>     <br>#if defined (_WIN32) <br>    *szHelpFile = '\0'; <br> <br>    int iret; <br>    BOOL fCanHelp; <br> <br>    if(m_pmapierr-&gt;lpszError  &amp;&amp;  m_pmapierr-&gt;ulContext) <br>        fCanHelp = TRUE; <br>    else <br>        fCanHelp = FALSE; <br>         <br>    if(fCanHelp) <br>    { <br>        DWORD dw = GetPrivateProfileString("Help File Mappings", m_pmapierr-&gt;lpszComponent, <br>                            "", szHelpFile, _MAX_PATH, "mapisvc.inf"); <br>        if(0 == dw) <br>            fCanHelp = FALSE; <br> <br>        if(fCanHelp) <br>        { <br>            MSGBOXPARAMS mbp = {0}; <br> <br>            mbp.cbSize = sizeof(MSGBOXPARAMS); <br>            mbp.hwndOwner = hWnd; <br>            mbp.hInstance = NULL; <br>            mbp.lpszText = szMessage; <br>            mbp.lpszCaption = m_szComponent ? m_szComponent : "Error!"; <br>            mbp.dwStyle = MB_ICONSTOP | MB_OK | MB_HELP; <br>            mbp.lpszIcon = NULL; <br>            mbp.dwContextHelpId = m_pmapierr-&gt;ulContext; <br>            mbp.lpfnMsgBoxCallback = ErrorBoxCallBack; <br>            mbp.dwLanguageId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US); <br> <br>            iret = MessageBoxIndirect(&amp;mbp); <br>        } <br>         <br>    } <br> <br>     <br>    if(!fCanHelp) <br>        iret = MessageBox (hWnd, szMessage, <br>                    m_szComponent ? m_szComponent : "Error!", <br>                        MB_ICONSTOP | MB_OK ); <br> <br>    *szHelpFile = '\0'; <br> <br>    return iret; <br> <br>#else <br>    return MessageBox (hWnd, szMessage, <br>                     m_szComponent ? m_szComponent : "Error!", <br>                         MB_ICONSTOP | MB_OK ); <br>#endif <br>} <br> <br>#if defined(_WIN32) <br>VOID CALLBACK ErrorBoxCallBack(LPHELPINFO lpHelpInfo) <br>{ <br>    Assert(*szHelpFile != '\0'); <br> <br>    WinHelp(NULL, szHelpFile, HELP_CONTEXT, <br>            lpHelpInfo-&gt;dwContextId); <br>} <br>#endif //_WIN32 <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
