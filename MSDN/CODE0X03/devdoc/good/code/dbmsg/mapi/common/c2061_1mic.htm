<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CINDEX.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2064"></a>CINDEX.C</h2>
<pre><code>/* <br> *  CINDEX.C <br> *   <br> *  Create and extend PR_CONVERSATION_INDEX <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;mapiwin.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include &lt;memory.h&gt; <br> <br>#define cbConvIndexHdr          22 <br>#define cbConvIndexComponent    5 <br>#define bConvIndexRes           (BYTE)1 <br> <br>/* <br> *  ExtractLastFileTime() <br> *   <br> *  Purpose: <br> *   <br> *      Parses an existing covnersation index and extracts the last <br> *      FILETIME value contained in the index. <br> */ <br>VOID <br>ExtractLastFileTime (LPBYTE lpb, ULONG cb, FILETIME FAR * lpft) <br>{ <br>    FILETIME ft; <br>    FILETIME ftCur; <br>    LPBYTE lpbEnd; <br> <br>    //  Lets do some verification on the key <br>    // <br>    Assert (!IsBadReadPtr (lpb, (UINT)cb)); <br>    Assert (!IsBadWritePtr (lpft, sizeof(FILETIME))); <br>    Assert (*lpb == bConvIndexRes); <br>    Assert (cb &gt;= cbConvIndexHdr); <br>    Assert (!((cb - cbConvIndexHdr) % cbConvIndexComponent)); <br> <br>    //  Rebuild the header time\date into FILETIME format <br>    // <br>    ft.dwHighDateTime = (((DWORD)(lpb[1])) &lt;&lt; 16) | <br>                        (((DWORD)(lpb[2])) &lt;&lt; 8) | <br>                        ((DWORD)(lpb[3])); <br> <br>    ft.dwLowDateTime = (((DWORD)(lpb[4])) &lt;&lt; 24) | <br>                       (((DWORD)(lpb[5])) &lt;&lt; 16); <br> <br>    //  See where the last child chunk ends <br>    // <br>    lpbEnd = lpb + cb; <br>    lpb += cbConvIndexHdr; <br> <br>    //  Now go through the child chunks to compute <br>    //  for the last FILETIME using the delta <br>    // <br>    while (lpb &lt; lpbEnd) <br>    { <br>        //  Convert the delta of the current child <br>        //  chunk into the FILETIME format.  Use the <br>        //  delta code in the first bit to get the <br>        //  real delta. <br>        // <br>        //  Delta code : 1 = mask 10000000 = 0x80 <br>        // <br>        if ((*lpb &amp; 0x80) == 0x80) <br>        { <br>            //  Mask out the first bit used for the delta code <br>            //  *lpb | 0x7F; <br>            // <br>            ftCur.dwHighDateTime = (((DWORD)(lpb[0] &amp; 0x7F)) &lt;&lt; 15) | <br>                                   (((DWORD)(lpb[1])) &lt;&lt; 7) | <br>                                   (((DWORD)(lpb[2])) &gt;&gt; 1); <br> <br>            ftCur.dwLowDateTime = (((DWORD)(lpb[2])) &lt;&lt; 31) | <br>                                  (((DWORD)(lpb[3])) &lt;&lt; 23); <br> <br>            ft = FtAddFt (ft, ftCur); <br>        } <br>        else <br>        { <br>            ftCur.dwHighDateTime = (((DWORD)(lpb[0] &amp; 0x7F)) &lt;&lt; 10) | <br>                                   (((DWORD)(lpb[1])) &lt;&lt; 2) | <br>                                   (((DWORD)(lpb[2])) &gt;&gt; 6); <br> <br>            ftCur.dwLowDateTime = (((DWORD)(lpb[2])) &lt;&lt; 26) | <br>                                  (((DWORD)(lpb[3])) &lt;&lt; 18); <br> <br>            ft = FtAddFt (ft, ftCur); <br>        } <br> <br>        // Advance to next child <br>        // <br>        lpb += cbConvIndexComponent; <br>    } <br> <br>    //  If all went well, we sould have ended up at <br>    //  lpbEnd <br>    // <br>    Assert (lpb == lpbEnd); <br>    *lpft = ft; <br>    return; <br>} <br> <br>/* <br> *  ScFillConvHeader() <br> *   <br> *  Purpose: <br> *   <br> *      Fills in the header of a conversation index.  This function is <br> *      called when a new conversation index is created. <br> *   <br> *  Assumptions: <br> *   <br> *      The buffer passed in should be big enough to hold cbConvIndexHdr <br> *      bytes (22 bytes). <br> */ <br>SCODE <br>ScFillConvHeader (LPBYTE rgb, ULONG cb) <br>{ <br>    SCODE sc = S_OK; <br>    SYSTEMTIME st; <br>    FILETIME ft; <br>    GUID guid; <br> <br>    Assert (cb &gt;= cbConvIndexHdr); <br>    Assert (!IsBadWritePtr (rgb, cbConvIndexHdr)); <br> <br>    //  (Ha). Put the reserved byte <br>    // <br>    rgb[0] = bConvIndexRes; <br>         <br>    //  (Hb). Put the current time <br>    // <br>    GetSystemTime (&amp;st); <br>    SystemTimeToFileTime (&amp;st, &amp;ft); <br> <br>    //  Construct the date\time one byte at a time <br>    // <br>    rgb[1] = (BYTE) ((ft.dwHighDateTime &amp; 0x00FF0000) &gt;&gt; 16); <br>    rgb[2] = (BYTE) ((ft.dwHighDateTime &amp; 0x0000FF00) &gt;&gt; 8); <br>    rgb[3] = (BYTE) (ft.dwHighDateTime &amp; 0x000000FF); <br> <br>    //  Drop the rightmost least significant 2 bytes <br>    // <br>    rgb[4] = (BYTE) ((ft.dwLowDateTime &amp; 0xFF000000) &gt;&gt; 24); <br>    rgb[5] = (BYTE) ((ft.dwLowDateTime &amp; 0x00FF0000) &gt;&gt; 16); <br> <br>    //  (Hc). Now put the GUID <br>    //      { <br>    //          DWORD Data1; <br>    //          WORD  Data2; <br>    //          WORD  Data3; <br>    //          BYTE  Data4[8]; <br>    //      } GUID; <br>    // <br>    sc = GetScode (CoCreateGuid (&amp;guid)); <br>    if (!FAILED (sc)) <br>    {        <br>        //  Again, lets do it one byte at a time <br>        // <br>        rgb[6] = (BYTE) ((guid.Data1 &amp; 0xFF000000) &gt;&gt; 24); <br>        rgb[7] = (BYTE) ((guid.Data1 &amp; 0x00FF0000) &gt;&gt; 16); <br>        rgb[8] = (BYTE) ((guid.Data1 &amp; 0x0000FF00) &gt;&gt; 8); <br>        rgb[9] = (BYTE) ((guid.Data1 &amp; 0x000000FF)); <br>        rgb[10] = (BYTE) ((guid.Data2 &amp; 0xFF00) &gt;&gt; 8); <br>        rgb[11] = (BYTE) ((guid.Data2 &amp; 0x00FF)); <br>        rgb[12] = (BYTE) ((guid.Data3 &amp; 0xFF00) &gt;&gt; 8); <br>        rgb[13] = (BYTE) ((guid.Data3 &amp; 0x00FF)); <br>    } <br> <br>    //  Slurp the rest across <br>    // <br>    CopyMemory (&amp;rgb[14], &amp;guid.Data4, 8); <br>    DebugTraceSc (ScFillConvHeader(), sc); <br>    return sc; <br>} <br> <br>/* <br> *  ScAddConversationIndex() <br> *   <br> *  Purpose: <br> *   <br> *      Given the conversation index to a message, this function will <br> *      create the conversation of a child message to the original.  If <br> *      the no original is suplied, then an index is created that would <br> *      signify the start of a new thread. <br> */ <br>SCODE <br>ScAddConversationIndex (ULONG cbParent, <br>    LPBYTE lpbParent, <br>    ULONG FAR * lpcb, <br>    LPBYTE FAR * lppb) <br>{ <br>    SCODE sc; <br>    DWORD dwTemp; <br>    SYSTEMTIME st; <br>    FILETIME ft; <br>    FILETIME ftLast; <br>    FILETIME ftDelta; <br>    HMODULE hMAPIDll = NULL; <br>    typedef SCODE (STDAPICALLTYPE FAR *MAPICONVIDX)(ULONG, LPBYTE, ULONG FAR *, LPBYTE FAR *); <br>    MAPICONVIDX lpfnMAPIConvIdx = NULL; <br> <br>#if defined (WIN16) <br>#define szScCreateConversationIndex "ScCreateConversationIndex" <br>#elif defined (_WIN32) &amp;&amp; defined (_X86_) <br>#ifndef szScCreateConversationIndex <br>#define szScCreateConversationIndex "ScCreateConversationIndex@16" <br>#endif <br>#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_) <br>#define szScCreateConversationIndex "ScCreateConversationIndex" <br>#endif <br> <br>#ifdef _WIN32 <br>    #define szMAPIDll "mapi32.dll" <br>#else <br>    #define szMAPIDll "mapi.dll" <br>#endif <br> <br>    /* <br>     * MAPI is going to export a function that is doing the same thing as this one. <br>     * So if the function is present we'll use it. <br>     */ <br>    hMAPIDll = GetModuleHandle(szMAPIDll); <br>    if(hMAPIDll) <br>    { <br>        lpfnMAPIConvIdx = (MAPICONVIDX)GetProcAddress(hMAPIDll, <br>                                            szScCreateConversationIndex); <br>        if(lpfnMAPIConvIdx) <br>        { <br>            return (*lpfnMAPIConvIdx)(cbParent, lpbParent, lpcb, lppb); <br>        } <br>    } <br>    //  Ensure that the parent is what we think <br>    //  it should be <br>    // <br>    if ((cbParent &lt; cbConvIndexHdr) || <br>        ((cbParent - cbConvIndexHdr) % cbConvIndexComponent) || <br>        (lpbParent[0] != bConvIndexRes)) <br>    { <br>        cbParent = 0; <br>        *lpcb = cbConvIndexHdr; <br>    } <br>    else <br>        *lpcb = cbParent + cbConvIndexComponent; <br> <br>    sc = MAPIAllocateBuffer (*lpcb, (LPVOID FAR *)lppb); <br>    if (!FAILED (sc)) <br>    { <br>        if (cbParent == 0) <br>        { <br>            //  This is a new key, so all it ever contains <br>            //  is a header.  Fill it in and we are done <br>            // <br>            sc = ScFillConvHeader (*lppb, *lpcb); <br>            if (FAILED (sc)) <br>            { <br>                MAPIFreeBuffer (*lppb); <br>                *lppb = NULL; <br>            } <br>        } <br>        else <br>        { <br>            //  First copy the old key across <br>            // <br>            CopyMemory (*lppb, lpbParent, (UINT)cbParent); <br> <br>            //  (Cb).  First get the current time (we'll then get <br>            //  the absolute distance between the current time and <br>            //  the time in the last chunk) <br>            // <br>            GetSystemTime (&amp;st); <br>            SystemTimeToFileTime (&amp;st, &amp;ft); <br> <br>            //  Now get the time of the last chunk <br>            //   <br>            ExtractLastFileTime (lpbParent, cbParent, &amp;ftLast); <br> <br>            //  Now mask out the bits we don't want from the <br>            //  current time <br>            // <br>            ft.dwHighDateTime &amp;= 0x00FFFFFF; <br>            ft.dwLowDateTime &amp;= 0xFFFF0000; <br> <br>            //  This assert is here to catch how often the <br>            //  5-byte time can collide and under what scenario, <br>            //  to see if 5 bytes + the next byte suffices to <br>            //  make this child chunk unique. <br>            //   <br>            Assert (!((ftLast.dwHighDateTime == ft.dwHighDateTime) &amp;&amp; <br>                (ftLast.dwLowDateTime == ft.dwLowDateTime))); <br> <br>            //  Get the change in time <br>            // <br>            if ((ft.dwHighDateTime &gt; ftLast.dwHighDateTime) || <br>                ((ft.dwHighDateTime == ftLast.dwHighDateTime) &amp;&amp; <br>                 (ft.dwLowDateTime &gt; ftLast.dwLowDateTime))) <br>            { <br>                ftDelta = FtSubFt (ft, ftLast); <br>            } <br>            else <br>                ftDelta = FtSubFt (ftLast, ft); <br> <br>            //  If the delta is less than 1.7 yrs, use 0 <br>            // <br>            if (!(ftDelta.dwHighDateTime &amp; 0x00FE0000)) <br>            { <br>                //  Just mask out the 31 bits that we <br>                //  want from the ftDelta <br>                // <br>                dwTemp = ((DWORD)(ftDelta.dwHighDateTime &amp; 0x0001FFFF)) &lt;&lt; 14 | <br>                         ((DWORD)(ftDelta.dwLowDateTime &amp; 0xFFFC0000)) &gt;&gt; 18; <br> <br>                //  Only the first byte is different <br>                // <br>                (*lppb)[cbParent] = (BYTE)((dwTemp &amp; 0xFF000000) &gt;&gt; 24 ); <br>            } <br>            else <br>            { <br>                //  Just mask out the 31 bits that we <br>                //  want from the ftDelta <br>                // <br>                dwTemp = ((DWORD)(ftDelta.dwHighDateTime &amp; 0x003FFFFF)) &lt;&lt; 9 | <br>                         ((DWORD)(ftDelta.dwLowDateTime &amp; 0xFF800000)) &gt;&gt; 23; <br> <br>                // Only the first byte is different <br>                // <br>                (*lppb)[cbParent] = (BYTE)(HIBYTE(HIWORD(dwTemp)) | 0x080); <br>            } <br> <br>            //  The remaining delta bytes are the same <br>            // <br>            (*lppb)[cbParent + 1] = (BYTE) ((dwTemp &amp; 0x00FF0000) &gt;&gt; 16); <br>            (*lppb)[cbParent + 2] = (BYTE) ((dwTemp &amp; 0x0000FF00) &gt;&gt; 8); <br>            (*lppb)[cbParent + 3] = (BYTE) ((dwTemp &amp; 0x000000FF) ); <br> <br>            //  (Cc). Next get the random number <br>            //  (Cd). Next get the sequence count <br>            //  -- we are going to use part of the tick count <br>            // <br>            (*lppb)[cbParent + 4] = (BYTE) (GetTickCount() &amp; 0x000000FF); <br>        } <br>    } <br> <br>    DebugTraceSc (ScAddConversationIndex(), sc); <br>    return sc; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
