<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAPIDBG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2071"></a>MAPIDBG.C</h2>
<pre><code>/* <br> *  MAPIDBG.C <br> * <br> *  MAPI Debugging Utilities <br> * <br> *  Copyright (C) 1986-1996 Microsoft Corporation. All rights reserved. <br> */ <br> <br>#ifdef DEBUG <br> <br>#pragma warning(disable:4100)   /* unreferenced formal parameter */ <br>#pragma warning(disable:4127)   /* conditional expression is constant */ <br>#pragma warning(disable:4201)   /* nameless struct/union */ <br>#pragma warning(disable:4206)   /* translation unit is empty */ <br>#pragma warning(disable:4209)   /* benign typedef redefinition */ <br>#pragma warning(disable:4214)   /* bit field types other than int */ <br>#pragma warning(disable:4001)   /* single line comments */ <br>#pragma warning(disable:4050)   /* different code attributes */ <br> <br>#ifdef _MAC <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;macname1.h&gt; <br>#include &lt;macos\menus.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;mapiprof.h&gt; <br> <br>#define GetPrivateProfileIntA       MAPIGetPrivateProfileInt <br> <br>#elif defined(WIN16) || defined(_WIN32) <br>#pragma warning(disable:4115)   /* named type definition in parentheses */ <br>#include &lt;windows.h&gt; <br>#include &lt;mapiwin.h&gt; <br> <br>#ifdef _WIN32 <br>#pragma warning(disable:4001)   /* single line comments */ <br>#pragma warning(disable:4115)   /* named type definition in parentheses */ <br>#pragma warning (disable:4514)  /* unreferenced inline function */ <br>#include &lt;objerror.h&gt; <br>#endif <br> <br>#else <br> <br>#include &lt;stdio.h&gt; <br>void __far __pascal OutputDebugString(char __far *); <br>#define wvsprintf           vsprintf <br>#define wsprintf            sprintf <br> <br>#endif      /* _MAC */ <br> <br>#ifdef DOS <br>#define lstrcpyA            strcpy <br>#define lstrlenA            strlen <br>#define lstrcatA            strcat <br>#define wvsprintfA          wvsprintf <br>#define wsprintfA           wsprintf <br>#define OutputDebugStringA  OutputDebugString <br>#endif <br> <br>#include &lt;mapidbg.h&gt; <br>#include &lt;mapidefs.h&gt; <br>#include &lt;mapitags.h&gt; <br>#include &lt;mapicode.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;time.h&gt; <br>#ifdef _MAC <br>#include &lt;macname2.h&gt; <br>#endif <br> <br>#if defined(DBCS) &amp;&amp; defined(DOS) <br>#include &lt;gapidos.h&gt; <br>#endif <br> <br>#if defined(DEBUG) &amp;&amp; defined(_WINNT) <br>#include &lt;lmcons.h&gt; <br>#include &lt;lmalert.h&gt; <br>#endif <br> <br>/*  Patch/Hack for 16bit, optimized builds. <br> * <br> *  memcpy with a size of 0 bytes causes a <br> *  crash. <br> */ <br> <br>#ifndef __MEMCPY_H_ <br>#define __MEMCPY_H_ <br> <br>#if defined(WIN16) &amp;&amp; !defined(DEBUG) <br>#define MemCopy(_dst,_src,_cb)      do                                  \ <br>                                    {                                   \ <br>                                        size_t __cb = (size_t)(_cb);    \ <br>                                        if (__cb)                       \ <br>                                            memcpy(_dst,_src,__cb);     \ <br>                                    } while (FALSE) <br>#else <br>#define MemCopy(_dst,_src,_cb)  memcpy(_dst,_src,(size_t)(_cb)) <br>#endif <br> <br>#endif <br> <br>#if (defined(WIN16) || defined(DOS)) &amp;&amp; !defined(NO_BASED_DEBUG) <br>#define BASED_DEBUG __based(__segname("DEBUG_DATA")) <br>#else <br>#define BASED_DEBUG <br>#endif <br> <br>#if defined(WIN16) <br>#define BASED_CODE          __based(__segname("_CODE")) <br>#else <br>#define BASED_CODE <br>#endif <br> <br> <br> <br>#if defined(WIN16) || defined(_WIN32) <br>static BOOL fTraceEnabled               = -1; <br>static BOOL fUseEventLog                = -1; <br>static BOOL fAssertLeaks                = -1; <br>#if defined(_WIN32) &amp;&amp; !defined(_MAC) <br>BOOL fInhibitTrapThread                 = 2; <br>#endif <br> <br>static char szKeyTraceEnabled[]         = "DebugTrace"; <br>static char szKeyInhibitTrapThread[]    = "TrapOnSameThread"; <br>static char szKeyEventLog[]             = "EventLog"; <br>static char szKeyUseVirtual[]           = "VirtualMemory"; <br>static char szKeyAssertLeaks[]          = "AssertLeaks"; <br>static char szKeyCheckOften[]           = "CheckHeapOften"; <br>static char szKeyFillRandom[]           = "MemoryFillRandom"; <br>static char szSectionDebug[]            = "General"; <br>static char szDebugIni[]                = "MAPIDBG.INI"; <br>#endif <br> <br>#ifndef VTABLE_FILL <br>#ifdef _MAC <br>#define VTABLE_FILL     NULL, <br>#else <br>#define VTABLE_FILL <br>#endif <br>#endif <br> <br>#if defined(DEBUG) &amp;&amp; defined(_WINNT) <br>typedef BOOL  (WINAPI   *ReportEventFN)(HANDLE, WORD, WORD, DWORD, PSID, WORD, DWORD, LPCTSTR *, LPVOID); <br>typedef HANDLE (WINAPI  *RegisterEventSourceAFN)(LPCTSTR, LPCTSTR); <br> <br>ReportEventFN pfnReportEvent = NULL; <br>RegisterEventSourceAFN pfnRegisterEventSourceA = NULL; <br>#endif <br> <br> <br>#ifdef  WIN16 <br>#pragma code_seg("Debug") <br>#endif   <br> <br>#if defined( _WINNT) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine returns if the service specified is running interactively <br>    (not invoked \by the service controller). <br> <br>Arguments: <br> <br>    None <br> <br>Return Value: <br> <br>    BOOL - TRUE if the service is an EXE. <br> <br> <br>Note: <br> <br>--*/ <br> <br>BOOL WINAPI IsDBGServiceAnExe( VOID ) <br>{ <br>    HANDLE hProcessToken = NULL; <br>    DWORD groupLength = 50; <br> <br>    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength); <br> <br>    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY; <br>    PSID InteractiveSid = NULL; <br>    PSID ServiceSid = NULL; <br>    DWORD i; <br> <br>    // Start with assumption that process is an EXE, not a Service. <br>    BOOL fExe = TRUE; <br> <br> <br>    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;hProcessToken)) <br>        goto ret; <br> <br>    if (groupInfo == NULL) <br>        goto ret; <br> <br>    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo, <br>        groupLength, &amp;groupLength)) <br>    { <br>        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) <br>            goto ret; <br> <br>        LocalFree(groupInfo); <br>        groupInfo = NULL; <br>     <br>        groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength); <br>     <br>        if (groupInfo == NULL) <br>            goto ret; <br>     <br>        if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo, <br>            groupLength, &amp;groupLength)) <br>        { <br>            goto ret; <br>        } <br>    } <br> <br>    // <br>    //  We now know the groups associated with this token.  We want to look to see if <br>    //  the interactive group is active in the token, and if so, we know that <br>    //  this is an interactive process. <br>    // <br>    //  We also look for the "service" SID, and if it's present, we know we're a service. <br>    // <br>    //  The service SID will be present iff the service is running in a <br>    //  user account (and was invoked by the service controller). <br>    // <br> <br> <br>    if (!AllocateAndInitializeSid(&amp;siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0, <br>        0, 0, 0, 0, 0, &amp;InteractiveSid)) <br>    { <br>        goto ret; <br>    } <br> <br>    if (!AllocateAndInitializeSid(&amp;siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0, <br>        0, 0, 0, 0, &amp;ServiceSid)) <br>    { <br>        goto ret; <br>    } <br> <br>    for (i = 0; i &lt; groupInfo-&gt;GroupCount ; i += 1) <br>    { <br>        SID_AND_ATTRIBUTES sanda = groupInfo-&gt;Groups[i]; <br>        PSID Sid = sanda.Sid; <br>     <br>        // <br>        //  Check to see if the group we're looking at is one of <br>        //  the 2 groups we're interested in. <br>        // <br>     <br>        if (EqualSid(Sid, InteractiveSid)) <br>        { <br>            // <br>            //  This process has the Interactive SID in its <br>            //  token.  This means that the process is running as <br>            //  an EXE. <br>            // <br>            goto ret; <br>        } <br>        else if (EqualSid(Sid, ServiceSid)) <br>        { <br>            // <br>            //  This process has the Service SID in its <br>            //  token.  This means that the process is running as <br>            //  a service running in a user account. <br>            // <br>            fExe = FALSE; <br>            goto ret; <br>        } <br>    } <br> <br>    // <br>    //  Neither Interactive or Service was present in the current users token, <br>    //  This implies that the process is running as a service, most likely <br>    //  running as LocalSystem. <br>    // <br>    fExe = FALSE; <br> <br>ret: <br> <br>    if (InteractiveSid) <br>        FreeSid(InteractiveSid); <br> <br>    if (ServiceSid) <br>        FreeSid(ServiceSid); <br> <br>    if (groupInfo) <br>        LocalFree(groupInfo); <br> <br>    if (hProcessToken) <br>        CloseHandle(hProcessToken); <br> <br>    return(fExe); <br>} <br> <br>#endif <br> <br>/* LogIt */ <br> <br>#ifndef _MAC <br>void    LogIt(LPSTR plpcText, BOOL  fUseAlert) <br>{ <br>#if defined(DEBUG) &amp;&amp; defined(_WINNT) <br>    LPSTR           llpcStr[2]; <br>    static HANDLE   hEventSource = NULL; <br> <br>    if (pfnRegisterEventSourceA == NULL) <br>    { <br>        /* This handle is not important as the lib will be freed on exit (and it's debug only) */ <br>        HINSTANCE       lhLib = LoadLibraryA("advapi32.dll"); <br>         <br>        if (!lhLib) <br>            return; <br>         <br>        pfnRegisterEventSourceA = (RegisterEventSourceAFN) GetProcAddress(lhLib, "RegisterEventSourceA"); <br>        pfnReportEvent = (ReportEventFN) GetProcAddress(lhLib, "ReportEventA"); <br>         <br>        if (!pfnRegisterEventSourceA || !pfnReportEvent) <br>            return; <br>    } <br>         <br>    if (!hEventSource)                                       <br>        hEventSource = pfnRegisterEventSourceA(NULL, "MAPIDebug"); <br> <br>    llpcStr[0] = "MAPI Debug Log"; <br>    llpcStr[1] = plpcText; <br> <br>    pfnReportEvent(hEventSource,    /* handle of event source */ <br>        EVENTLOG_ERROR_TYPE,        /* event type             */ <br>        0,                          /* event category         */ <br>        0,                          /* event ID               */ <br>        NULL,                       /* current user's SID     */ <br>        2,                          /* strings in lpszStrings */ <br>        0,                          /* no bytes of raw data   */ <br>        llpcStr,                    /* array of error strings */ <br>        NULL);                      /* no raw data            */ <br>         <br>    /* Now we generate an Alert! */ <br>    /* This code is adapted from PierreC's stuff, and NEEDS TO BE UNICODE!!!! */ <br>    if (fUseAlert) <br>    { <br>#define MAX_LINE        256 <br> <br>typedef NET_API_STATUS  (WINAPI *NAREFN)(TCHAR *, ADMIN_OTHER_INFO *, ULONG, TCHAR *); <br> <br>        BYTE                rgb[sizeof(ADMIN_OTHER_INFO) + (sizeof(WCHAR) * MAX_LINE)]; <br>        ADMIN_OTHER_INFO *  poi     = (ADMIN_OTHER_INFO *) rgb; <br>        WCHAR *             pch     = (WCHAR *) (rgb + sizeof(ADMIN_OTHER_INFO)); <br>        NET_API_STATUS      nas; <br>        static   NAREFN     fnNetAlertRaiseEx = NULL; <br>         <br>        /* Resolve function here, never free library as it's debug only */ <br>        if (!fnNetAlertRaiseEx) <br>        { <br>            HINSTANCE       lhLib = LoadLibrary("NETAPI32.DLL"); <br>            if (lhLib) <br>                fnNetAlertRaiseEx = (NAREFN) GetProcAddress(lhLib, "NetAlertRaiseEx"); <br>        } <br>         <br>        if (fnNetAlertRaiseEx) <br>        { <br>            poi-&gt;alrtad_errcode = (DWORD) -1; <br>            poi-&gt;alrtad_numstrings = 1; <br>             <br>            if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, plpcText, -1, pch, MAX_LINE)) <br>            { <br>                nas = fnNetAlertRaiseEx( <br>                            (TCHAR *) L"ADMIN", <br>                            poi,  <br>                            sizeof(ADMIN_OTHER_INFO) + ((lstrlenW(pch) + 1) * sizeof(WCHAR)), <br>                            (TCHAR *) L"MAPI Assert"); <br>                     <br>                         <br>            } <br>        } <br>    } <br>     <br>#endif /* DEBUG &amp;&amp; NT */ <br>} <br>#endif /* !_MAC */ <br> <br>/* DebugOutputFn ------------------------------------------------------------ */ <br> <br>char BASED_CODE szCR[] = "\r"; <br> <br>void DebugOutputFn(char *psz) <br>{ <br>#if defined(_MAC) <br> <br>    OutputDebugString(psz); <br> <br>#else <br> <br>#if defined(WIN16) || defined(_WIN32) <br>    if (fTraceEnabled == -1) <br>    { <br>        fTraceEnabled = GetPrivateProfileIntA(szSectionDebug, szKeyTraceEnabled, <br>            0, szDebugIni); <br> <br>        fUseEventLog = GetPrivateProfileIntA(szSectionDebug, szKeyEventLog, <br>            0, szDebugIni);      <br>    } <br> <br>    if (!fTraceEnabled) <br>        return; <br> <br>    if (fUseEventLog) <br>#else <br>    if (FALSE) <br>#endif <br>        LogIt(psz, FALSE); <br> <br>#ifdef WIN16 <br>    OutputDebugString(psz); <br>    OutputDebugString(szCR); <br>#else <br>    OutputDebugStringA(psz); <br>    OutputDebugStringA(szCR); <br>#endif <br>     <br>#endif  /* _MAC */ <br>} <br> <br> <br>/* DebugTrapFn -------------------------------------------------------------- */ <br> <br>#if defined(_WIN32) &amp;&amp; !defined(_MAC) <br> <br>typedef struct { <br>    char *      sz1; <br>    char *      sz2; <br>    UINT        rgf; <br>    int         iResult; <br>} MBContext; <br> <br>DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc) <br>{ <br>    if (fUseEventLog) <br>    { <br>        LogIt(pmbc-&gt;sz1, TRUE); <br>        pmbc-&gt;iResult = IDIGNORE; <br>    } <br>    else <br>        pmbc-&gt;iResult = MessageBoxA(NULL, pmbc-&gt;sz1, pmbc-&gt;sz2, <br>            pmbc-&gt;rgf | MB_SETFOREGROUND); <br> <br>    return(0); <br>} <br> <br>int MessageBoxFn(char *sz1, char *sz2, UINT rgf) <br>{ <br>    HANDLE      hThread; <br>    DWORD       dwThreadId; <br>    MBContext   mbc; <br> <br>    mbc.sz1     = sz1; <br>    mbc.sz2     = sz2; <br>    mbc.rgf     = rgf; <br>    mbc.iResult = IDRETRY; <br> <br>    #if defined(_WIN32) &amp;&amp; !defined(_MAC) <br>    if (fInhibitTrapThread == 2) <br>        fInhibitTrapThread = GetPrivateProfileIntA(szSectionDebug, <br>            szKeyInhibitTrapThread, 0, szDebugIni); <br>    #endif <br> <br>    if (fInhibitTrapThread) <br>    { <br>        MessageBoxFnThreadMain(&amp;mbc); <br>    } <br>    else <br>    { <br>        hThread = CreateThread(NULL, 0, <br>            (PTHREAD_START_ROUTINE)MessageBoxFnThreadMain, &amp;mbc, 0, &amp;dwThreadId); <br> <br>        if (hThread != NULL) { <br>            WaitForSingleObject(hThread, INFINITE); <br>            CloseHandle(hThread); <br>        } <br>    } <br> <br>    return(mbc.iResult); <br>} <br>#else <br>#define MessageBoxFn(sz1, sz2, rgf)     MessageBoxA(NULL, sz1, sz2, rgf) <br>#endif <br> <br>int EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...) <br>{ <br>    char    sz[512]; <br>    va_list vl; <br> <br>    #if defined(WIN16) || defined(_WIN32) <br>    int     id; <br>    #endif <br>    #if defined(_WIN32) &amp;&amp; !defined(_MAC) <br>    static int iServiceFlag = -1; <br>    #endif <br> <br>    lstrcpyA(sz, "++++ MAPI Debug Trap ("); <br>    _strdate(sz + lstrlenA(sz)); <br>    lstrcatA(sz, " "); <br>    _strtime(sz + lstrlenA(sz)); <br>    lstrcatA(sz, ")\n"); <br>    DebugOutputFn(sz); <br> <br>    va_start(vl, pszFormat); <br>    wvsprintfA(sz, pszFormat, vl); <br>    va_end(vl); <br> <br>    wsprintfA(sz + lstrlenA(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine); <br> <br>    DebugOutputFn(sz); <br> <br>    #if defined(DOS) <br>    _asm { int 3 } <br>    #endif <br> <br>#if defined(WIN16) || defined(_WIN32) <br>    /* Hold down control key to prevent MessageBox */ <br>    if ( GetAsyncKeyState(VK_CONTROL) &gt;= 0 ) <br>    { <br>        UINT uiFlags = MB_ABORTRETRYIGNORE; <br> <br>        if (fFatal) <br>            uiFlags |= MB_DEFBUTTON1; <br>        else <br>            uiFlags |= MB_DEFBUTTON3; <br> <br>        #ifdef WIN16 <br>        uiFlags |= MB_ICONEXCLAMATION | MB_SYSTEMMODAL; <br>        #else <br>        uiFlags |= MB_ICONSTOP | MB_TASKMODAL; <br>        #endif <br> <br>        #if defined(_WIN32) &amp;&amp; !defined(_MAC) <br>        if (iServiceFlag == -1) <br>        { <br>            DWORD dwVersion = GetVersion(); <br> <br>            if (dwVersion &amp; 0x80000000) <br>            { <br>                if (LOBYTE(LOWORD(dwVersion)) &lt; 4) <br>                { <br>                    //  NT 3.51 <br>                    iServiceFlag = 0x00040000; <br>                } <br>                else <br>                { <br>                    //  NT 4.0+ <br>                    iServiceFlag = 0x00200000; <br>                } <br>            } <br>            else <br>                //  not NT, skip this <br>                iServiceFlag = 0; <br>        } <br> <br>        if (!IsDBGServiceAnExe()) <br>            uiFlags |= (UINT) iServiceFlag; <br>        #endif <br> <br>        id = MessageBoxFn(sz, "MAPI Debug Trap", uiFlags); <br> <br>        if (id == IDABORT) <br>            *((LPBYTE)NULL) = 0; <br>        else if (id == IDRETRY) <br>            DebugBreak(); <br>    } <br>#endif <br> <br>    return(0); <br>} <br> <br>/* DebugTraceFn ------------------------------------------------------------- */ <br> <br>int EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...) <br>{ <br>    char    sz[768]; <br>    int     fAutoLF = 0; <br>    va_list vl; <br> <br>    if (*pszFormat == '~') { <br>        pszFormat += 1; <br>        fAutoLF = 1; <br>    } <br> <br>    va_start(vl, pszFormat); <br>    wvsprintfA(sz, pszFormat, vl); <br>    va_end(vl); <br> <br>#ifndef _MAC <br>    if (fAutoLF) <br>        lstrcatA(sz, "\n"); <br>#endif <br> <br>    DebugOutputFn(sz); <br> <br>    return(0); <br>} <br> <br>/* DebugTraceProblemsFn */ <br> <br>void EXPORTDBG __cdecl DebugTraceProblemsFn(LPSTR sz, LPVOID pv) <br>{ <br>    LPSPropProblemArray pprobs = (LPSPropProblemArray)pv; <br>    SPropProblem *      pprob = pprobs-&gt;aProblem; <br>    int                 cprob = (int)pprobs-&gt;cProblem; <br> <br>    DebugTraceFn("%s: SetProps problem\n", sz); <br>    while (cprob--) <br>    { <br>        DebugTraceFn("Property %s (index %ld): failed with %s\n", <br>            SzDecodeUlPropTagFn(pprob-&gt;ulPropTag), <br>            pprob-&gt;ulIndex, <br>            SzDecodeScodeFn(pprob-&gt;scode)); <br>    } <br>} <br> <br>/* SCODE &amp; PropTag decoding ------------------------------------------------- */ <br> <br>typedef struct <br>{ <br>    char *          psz; <br>    unsigned long   ulPropTag; <br>} PT; <br> <br>typedef struct <br>{ <br>    char *  psz; <br>    SCODE   sc; <br>} SC; <br> <br>#define Pt(_ptag)   {#_ptag, _ptag} <br>#define Sc(_sc)     {#_sc, _sc} <br> <br>#if !defined(DOS) <br>static PT BASED_DEBUG rgpt[] = { <br>     <br>#include "_tags.h" <br>     <br>/* <br> * Property types <br> */ <br>    Pt(PR_NULL), <br>    Pt(PT_UNSPECIFIED), <br>    Pt(PT_NULL), <br>    Pt(PT_I2), <br>    Pt(PT_LONG), <br>    Pt(PT_R4), <br>    Pt(PT_DOUBLE), <br>    Pt(PT_CURRENCY), <br>    Pt(PT_APPTIME), <br>    Pt(PT_ERROR), <br>    Pt(PT_BOOLEAN), <br>    Pt(PT_OBJECT), <br>    Pt(PT_I8), <br>    Pt(PT_STRING8), <br>    Pt(PT_UNICODE), <br>    Pt(PT_SYSTIME), <br>    Pt(PT_CLSID), <br>    Pt(PT_BINARY), <br>    Pt(PT_TSTRING), <br>    Pt(PT_MV_I2), <br>    Pt(PT_MV_LONG), <br>    Pt(PT_MV_R4), <br>    Pt(PT_MV_DOUBLE), <br>    Pt(PT_MV_CURRENCY), <br>    Pt(PT_MV_APPTIME), <br>    Pt(PT_MV_SYSTIME), <br>    Pt(PT_MV_STRING8), <br>    Pt(PT_MV_BINARY), <br>    Pt(PT_MV_UNICODE), <br>    Pt(PT_MV_CLSID), <br>    Pt(PT_MV_I8) <br>}; <br> <br>#define cpt (sizeof(rgpt) / sizeof(PT)) <br> <br>static SC BASED_DEBUG rgsc[] = { <br> <br>/* FACILITY_NULL error codes from OLE */ <br> <br>    Sc(S_OK), <br>    Sc(S_FALSE), <br> <br>    Sc(E_UNEXPECTED), <br>    Sc(E_NOTIMPL), <br>    Sc(E_OUTOFMEMORY), <br>    Sc(E_INVALIDARG), <br>    Sc(E_NOINTERFACE), <br>    Sc(E_POINTER), <br>    Sc(E_HANDLE), <br>    Sc(E_ABORT), <br>    Sc(E_FAIL), <br>    Sc(E_ACCESSDENIED), <br> <br>/* MAPI error codes from MAPICODE.H */ <br>#include "_scode.h" <br>                     <br>}; <br> <br>#define csc (sizeof(rgsc) / sizeof(SC)) <br>#endif <br> <br>char * EXPORTDBG __cdecl <br>SzDecodeScodeFn(SCODE sc) <br>{ <br>    static char rgch[64]; <br> <br>    #if !defined(DOS) <br>    int isc; <br>    for (isc = 0; isc &lt; csc; ++isc) <br>        if (sc == rgsc[isc].sc) <br>            return rgsc[isc].psz; <br>    #endif <br> <br>    wsprintfA (rgch, "%08lX", sc); <br>    return rgch; <br>} <br> <br>char * EXPORTDBG __cdecl <br>SzDecodeUlPropTypeFn(unsigned long ulPropType) <br>{ <br>    static char rgch[8]; <br> <br>    switch (ulPropType) <br>    { <br>    case PT_UNSPECIFIED:    return("PT_UNSPECIFIED");   break; <br>    case PT_NULL:           return("PT_NULL");          break; <br>    case PT_I2:             return("PT_I2");            break; <br>    case PT_LONG:           return("PT_LONG");          break; <br>    case PT_R4:             return("PT_R4");            break; <br>    case PT_DOUBLE:         return("PT_DOUBLE");        break; <br>    case PT_CURRENCY:       return("PT_CURRENCY");      break; <br>    case PT_APPTIME:        return("PT_APPTIME");       break; <br>    case PT_ERROR:          return("PT_ERROR");         break; <br>    case PT_BOOLEAN:        return("PT_BOOLEAN");       break; <br>    case PT_OBJECT:         return("PT_OBJECT");        break; <br>    case PT_I8:             return("PT_I8");            break; <br>    case PT_STRING8:        return("PT_STRING8");       break; <br>    case PT_UNICODE:        return("PT_UNICODE");       break; <br>    case PT_SYSTIME:        return("PT_SYSTIME");       break; <br>    case PT_CLSID:          return("PT_CLSID");         break; <br>    case PT_BINARY:         return("PT_BINARY");        break; <br>    } <br> <br>    wsprintfA(rgch, "0x%04lX", ulPropType); <br>    return rgch; <br>} <br> <br>char *  EXPORTDBG __cdecl <br>SzDecodeUlPropTagFn(unsigned long ulPropTag) <br>{ <br>    static char rgch[64]; <br> <br>    #if !defined(DOS) <br>    int ipt; <br>    for (ipt = 0; ipt &lt; cpt; ++ipt) <br>        if (ulPropTag == rgpt[ipt].ulPropTag) <br>            return rgpt[ipt].psz; <br>    #endif <br> <br>    wsprintfA(rgch, "PROP_TAG(%s, 0x%04lX)", <br>        SzDecodeUlPropType(PROP_TYPE(ulPropTag)), <br>        PROP_ID(ulPropTag)); <br>    return rgch; <br>} <br> <br>SCODE  EXPORTDBG __cdecl <br>ScodeFromSzFn(char *psz) <br>{ <br>    #if !defined(DOS) <br>    int isc; <br>    for (isc = 0; isc &lt; csc; ++isc) <br>        { <br>        if (lstrcmpA(psz, rgsc[isc].psz) == 0) <br>            { <br>            return rgsc[isc].sc; <br>            } <br>        } <br>    #endif <br>    return 0; <br>} <br> <br>unsigned long EXPORTDBG __cdecl <br>UlPropTagFromSzFn(char *psz) <br>{ <br>    #if !defined(DOS) <br>    int ipt; <br>    for (ipt = 0; ipt &lt; cpt; ++ipt) <br>        { <br>        if (lstrcmpA(psz, rgpt[ipt].psz) == 0) <br>            { <br>            return rgpt[ipt].ulPropTag; <br>            } <br>        } <br>    #endif <br>    return 0; <br>} <br> <br>/* ScCheckScFn -------------------------------------------------------------- */ <br> <br>#if !defined(DOS) <br> <br>SCODE EXPORTDBG __cdecl ScCheckScFn(    SCODE   sc, <br>                    SCODE * lpscLegal, <br>                    char *  lpszMethod, <br>                    char *  lpszFile, <br>                    int     iLine) <br>{ <br>    BOOL fIsQueryInterface = (lpscLegal == IUnknown_QueryInterface_Scodes); <br> <br>    if (sc == S_OK) <br>        return(sc); <br> <br>    while( *lpscLegal != S_OK &amp;&amp; sc != *lpscLegal ) <br>    { <br>        lpscLegal++; <br>    } <br> <br>    if ( *lpscLegal == S_OK ) <br>    { <br>        SCODE *lpscNextCommon = Common_Scodes; <br> <br>        /* see if this is a common scode */ <br>            if ( !fIsQueryInterface ) <br>                while(  *lpscNextCommon != S_OK &amp;&amp; <br>                        sc != *lpscNextCommon ) <br>                { <br>                    lpscNextCommon++; <br>                } <br> <br>        /* this is an illegal error or an RPC error */ <br>           if ( (*lpscNextCommon == S_OK || fIsQueryInterface) &amp;&amp; <br>                ( SCODE_FACILITY(sc) != FACILITY_RPC) ) <br>           { <br>                DebugTrace( "Unrecognized scode %s from %s\n\t in file %s line %d\n", <br>                        SzDecodeScode( sc ), lpszMethod, lpszFile, iLine); <br>            } <br>    } <br> <br>    return(sc); <br>} <br>#endif <br> <br>/* SCODE lists -------------------------------------------------------------- */ <br> <br>#if !defined(DOS) <br> <br>#define STANDARD_OPENENTRY_SCODES \ <br>    E_NOINTERFACE,  \ <br>    MAPI_E_NOT_FOUND <br> <br>SCODE BASED_DEBUG Common_Scodes[] = <br>{ <br>    MAPI_E_BAD_CHARWIDTH, <br>    MAPI_E_CALL_FAILED, <br>    MAPI_E_INVALID_ENTRYID, <br>    MAPI_E_INVALID_OBJECT, <br>    MAPI_E_INVALID_PARAMETER, <br>    MAPI_E_NO_ACCESS, <br>    MAPI_E_NO_SUPPORT, <br>    MAPI_E_NOT_ENOUGH_MEMORY, <br>    MAPI_E_UNKNOWN_FLAGS, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG MAPILogon_Scodes[] = <br>{ <br>    MAPI_E_NOT_INITIALIZED, <br>    MAPI_E_LOGON_FAILED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG MAPIAllocateBuffer_Scodes[] = <br>{ <br>    MAPI_E_NOT_INITIALIZED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG MAPIAllocateMore_Scodes[] = <br>{ <br>    MAPI_E_NOT_INITIALIZED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG MAPIFreeBuffer_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IUnknown_QueryInterface_Scodes[] = <br>{ <br>    E_INVALIDARG, <br>    E_NOINTERFACE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IUnknown_GetLastError_Scodes[] = <br>{ <br>    MAPI_E_EXTENDED_ERROR, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_CopyTo_Scodes[] = <br>{ <br>    MAPI_W_ERRORS_RETURNED, <br>    MAPI_E_INVALID_TYPE, <br>    MAPI_E_FOLDER_CYCLE, <br>    MAPI_E_DECLINE_COPY, <br>    E_NOINTERFACE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_CopyProps_Scodes[] = <br>{ <br>    MAPI_W_ERRORS_RETURNED, <br>    MAPI_W_PARTIAL_COMPLETION, <br>    MAPI_E_INVALID_TYPE, <br>    MAPI_E_FOLDER_CYCLE, <br>    MAPI_E_DECLINE_COPY, <br>    E_NOINTERFACE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_DeleteProps_Scodes[] = <br>{ <br>    MAPI_W_ERRORS_RETURNED, <br>    MAPI_E_INVALID_TYPE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_GetIDsFromNames_Scodes[] = <br>{ <br>    MAPI_W_ERRORS_RETURNED, <br>    MAPI_E_TABLE_TOO_BIG, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_GetLastError_Scodes[] = <br>{ <br>    MAPI_E_EXTENDED_ERROR, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_GetNamesFromIDs_Scodes[] = <br>{ <br>    MAPI_W_ERRORS_RETURNED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_GetPropList_Scodes[] = <br>{ <br>    MAPI_W_ERRORS_RETURNED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_GetProps_Scodes[] = <br>{ <br>    MAPI_E_NOT_FOUND, <br>    MAPI_E_OBJECT_DELETED, <br>    MAPI_W_ERRORS_RETURNED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_OpenProperty_Scodes[] = <br>{ <br>    MAPI_E_INTERFACE_NOT_SUPPORTED, <br>    MAPI_E_NOT_FOUND, <br>    MAPI_E_OBJECT_DELETED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_SetProps_Scodes[] = <br>{ <br>    MAPI_E_COMPUTED, <br>    MAPI_E_UNEXPECTED_TYPE, <br>    MAPI_E_INVALID_TYPE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIProp_SaveChanges_Scodes[] = <br>{ <br>    MAPI_E_NOT_ENOUGH_DISK, <br>    MAPI_E_OBJECT_CHANGED, <br>    MAPI_E_OBJECT_DELETED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IStream_Read_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_Write_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_Seek_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_SetSize_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_Tell_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_LockRegion_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_UnlockRegion_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_Clone_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_CopyTo_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_Revert_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_Stat_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IStream_Commit_Scodes[] = {S_OK}; <br> <br>SCODE BASED_DEBUG IMAPITable_GetLastError_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_Advise_Scodes[] = <br>{ <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_Unadvise_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_GetStatus_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_SetColumns_Scodes[] = <br>{ <br>    MAPI_E_BUSY, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_QueryColumns_Scodes[] = <br>{ <br>    MAPI_E_BUSY, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_GetRowCount_Scodes[] = <br>{ <br>    MAPI_E_BUSY, <br>    MAPI_W_APPROX_COUNT, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_SeekRow_Scodes[] = <br>{ <br>    MAPI_E_INVALID_BOOKMARK, <br>    MAPI_E_UNABLE_TO_COMPLETE, <br>    MAPI_W_POSITION_CHANGED, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_SeekRowApprox_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_QueryPosition_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_FindRow_Scodes[] = <br>{ <br>    MAPI_E_INVALID_BOOKMARK, <br>    MAPI_E_NOT_FOUND, <br>    MAPI_W_POSITION_CHANGED, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_Restrict_Scodes[] = <br>{ <br>    MAPI_E_BUSY, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_CreateBookmark_Scodes[] = <br>{ <br>    MAPI_E_UNABLE_TO_COMPLETE, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_FreeBookmark_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_SortTable_Scodes[] = <br>{ <br>    MAPI_E_TOO_COMPLEX, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_QuerySortOrder_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_QueryRows_Scodes[] = <br>{ <br>    MAPI_E_INVALID_BOOKMARK, <br>    MAPI_W_POSITION_CHANGED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPITable_Abort_Scodes[] = <br>{ <br>    MAPI_E_UNABLE_TO_ABORT, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_ExpandRow_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_CollapseRow_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_WaitForCompletion_Scodes[] = <br>{ <br>    MAPI_E_TIMEOUT, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPITable_GetCollapseState_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPITable_SetCollapseState_Scodes[] = {S_OK}; <br> <br> <br>SCODE BASED_DEBUG IMAPISession_LogOff_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_Release_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_GetLastError_Scodes[] = <br>{ <br>    MAPI_E_EXTENDED_ERROR, <br>    S_OK <br>}; <br>SCODE BASED_DEBUG IMAPISession_GetMsgStoresTable_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_GetStatusTable_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_OpenMsgStore_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_OpenAddressBook_Scodes[] = {S_OK}; <br> <br>SCODE BASED_DEBUG IMAPISession_OpenEntry_Scodes[] = <br>{ <br>    STANDARD_OPENENTRY_SCODES, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPISession_OpenProfileSection_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_Advise_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_Unadvise_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_CompareEntryIDs_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_MessageOptions_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_QueryDefaultMessageOpt_Scodes[] = {S_OK}; </code></pre>
<p>
</p>
<pre><code>SCODE BASED_DEBUG IMAPISession_EnumAdrTypes_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPISession_QueryIdentity_Scodes[] = {S_OK}; <br> <br>SCODE BASED_DEBUG IMsgStore_OpenEntry_Scodes[] = <br>{ <br>    STANDARD_OPENENTRY_SCODES, <br>    MAPI_E_SUBMITTED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMsgStore_SetReceiveFolder_Scodes[] = <br>{ <br>    MAPI_E_BAD_CHARWIDTH, <br>    MAPI_E_NOT_FOUND, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMsgStore_GetReceiveFolder_Scodes[] = <br>{ <br>    MAPI_E_BAD_CHARWIDTH, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMsgStore_GetReceiveFolderTable_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMsgStore_StoreLogoff_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMsgStore_Advise_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMsgStore_Unadvise_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMsgStore_CompareEntryIDs_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMsgStore_GetOutgoingQueue_Scodes[] = { <br>    MAPI_E_NO_SUPPORT, <br>    S_OK}; <br>SCODE BASED_DEBUG IMsgStore_SetLockState_Scodes[] = { <br>    MAPI_E_NO_SUPPORT, <br>    MAPI_E_NOT_FOUND, <br>    S_OK}; <br>SCODE BASED_DEBUG IMsgStore_FinishedMsg_Scodes[] = { <br>    MAPI_E_NO_SUPPORT, <br>    S_OK}; <br>SCODE BASED_DEBUG IMsgStore_AbortSubmit_Scodes[] = { <br>    MAPI_E_UNABLE_TO_ABORT, <br>    MAPI_E_NOT_IN_QUEUE, <br>    S_OK}; <br>SCODE BASED_DEBUG IMsgStore_NotifyNewMail_Scodes[] = {S_OK}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_GetContentsTable_Scodes[] = <br>{ <br>    MAPI_E_OBJECT_DELETED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_GetHierarchyTable_Scodes[] = <br>{ <br>    MAPI_E_OBJECT_DELETED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_SaveContentsSort_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_OpenEntry_Scodes[] = <br>{ <br>    STANDARD_OPENENTRY_SCODES, <br>    MAPI_E_SUBMITTED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_CreateMessage_Scodes[] = <br>{ <br>    E_NOINTERFACE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_CopyMessages_Scodes[] = <br>{ <br>    E_NOINTERFACE, <br>    MAPI_E_SUBMITTED, <br>    MAPI_E_DECLINE_COPY, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_DeleteMessages_Scodes[] = <br>{ <br>    MAPI_E_SUBMITTED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_CreateFolder_Scodes[] = <br>{ <br>    E_NOINTERFACE, <br>    MAPI_E_COLLISION, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_CopyFolder_Scodes[] = <br>{ <br>    E_NOINTERFACE, <br>    MAPI_E_COLLISION, <br>    MAPI_E_FOLDER_CYCLE, <br>    MAPI_E_DECLINE_COPY, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_DeleteFolder_Scodes[] = <br>{ <br>    MAPI_E_HAS_FOLDERS, <br>    MAPI_E_HAS_MESSAGES, <br>    MAPI_E_SUBMITTED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_SetSearchCriteria_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_GetSearchCriteria_Scodes[] = <br>{ <br>    MAPI_E_NOT_INITIALIZED, <br>    MAPI_E_CORRUPT_STORE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_SetReadFlags_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_GetMessageStatus_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_SetMessageStatus_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMAPIFolder_EmptyFolder_Scodes[] = <br>{ <br>    MAPI_E_SUBMITTED, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMessage_GetAttachmentTable_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMessage_OpenAttach_Scodes[] = <br>{ <br>    MAPI_E_NOT_FOUND, <br>    E_NOINTERFACE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMessage_CreateAttach_Scodes[] = <br>{ <br>    E_NOINTERFACE, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMessage_DeleteAttach_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMessage_GetRecipientTable_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMessage_ModifyRecipients_Scodes[] = <br>{ <br>    MAPI_E_NOT_FOUND, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMessage_SubmitMessage_Scodes[] = <br>{ <br>    MAPI_E_NO_RECIPIENTS, <br>    MAPI_E_NON_STANDARD, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMessage_SetReadFlag_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IAttach_SaveChanges_Scodes[] = <br>{ <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IAddrBook_OpenEntry_Scodes[] = <br>{ <br>    STANDARD_OPENENTRY_SCODES, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IAddrBook_CompareEntryIDs_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IAddrBook_CreateOneOff_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IAddrBook_ResolveName_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IAddrBook_Address_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IAddrBook_Details_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IAddrBook_RecipOptions_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IAddrBook_QueryDefaultRecipOpt_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IAddrBook_ButtonPress_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IABContainer_GetContentsTable_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IABContainer_GetHierarchyTable_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG INotifObj_ChangeEvMask_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPIStatus_ChangePassword_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPIStatus_FlushQueues_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPIStatus_SettingsDialog_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG IMAPIStatus_ValidateState_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPILogon_Scodes[] = { <br>    MAPI_E_LOGON_FAILED, <br>    S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPILogoff_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPIFreeBuffer_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPISendMail_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPISendDocuments_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPIFindNext_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPIReadMail_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPISaveMail_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPIDeleteMail_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPIAddress_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPIResolveName_Scodes[] = {S_OK}; <br>SCODE BASED_DEBUG SMAPI_MAPIDetails_Scodes[] = {S_OK}; <br> <br>SCODE BASED_DEBUG IMSProvider_Logon_Scodes[] = { <br>    MAPI_E_UNCONFIGURED, <br>    MAPI_E_FAILONEPROVIDER, <br>    MAPI_E_STRING_TOO_LONG, <br>    MAPI_E_LOGON_FAILED, <br>    MAPI_E_CORRUPT_STORE, <br>    MAPI_E_USER_CANCEL, <br>    S_OK}; <br>SCODE BASED_DEBUG IMSProvider_Deinit_Scodes[] = { <br>    S_OK}; <br>SCODE BASED_DEBUG IMSProvider_Shutdown_Scodes[] = { <br>    S_OK}; <br> <br>SCODE BASED_DEBUG IMSProvider_Init_Scodes[] = { <br>    MAPI_E_VERSION, <br>    S_OK}; <br>SCODE BASED_DEBUG IMSProvider_SpoolerLogon_Scodes[] = { <br>    MAPI_E_LOGON_FAILED, <br>    S_OK}; <br> <br>SCODE BASED_DEBUG IMSLogon_OpenEntry_Scodes[] = <br>{ <br>    STANDARD_OPENENTRY_SCODES, <br>    S_OK <br>}; <br> <br>SCODE BASED_DEBUG IMSLogon_OpenStatusEntry_Scodes[] = { <br>    S_OK}; <br> <br>SCODE BASED_DEBUG IMSLogon_CompareEntryIDs_Scodes[] = { <br>    S_OK}; <br> <br>SCODE BASED_DEBUG IMSLogon_Advise_Scodes[] = { <br>    S_OK}; <br>SCODE BASED_DEBUG IMSLogon_Unadvise_Scodes[] = { <br>    S_OK}; <br>SCODE BASED_DEBUG IMSLogon_Logoff_Scodes[] = { <br>    S_OK}; <br>#endif <br> <br>/* DBGMEM ------------------------------------------------------------------- */ <br> <br>#undef  INTERFACE <br>#define INTERFACE struct _DBGMEM <br>DECLARE_INTERFACE(DBGMEM_) <br>{ <br>    BEGIN_INTERFACE <br>    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE; \ <br>    STDMETHOD_(ULONG,AddRef)        (THIS) PURE; \ <br>    STDMETHOD_(ULONG,Release)       (THIS) PURE; \ <br>    STDMETHOD_(void FAR*, Alloc)    (THIS_ ULONG cb) PURE; \ <br>    STDMETHOD_(void FAR*, Realloc)  (THIS_ void FAR* pv, ULONG cb) PURE; \ <br>    STDMETHOD_(void, Free)          (THIS_ void FAR* pv) PURE; \ <br>    STDMETHOD_(ULONG, GetSize)      (THIS_ void FAR* pv) PURE; \ <br>    STDMETHOD_(int, DidAlloc)       (THIS_ void FAR* pv) PURE; \ <br>    STDMETHOD_(void, HeapMinimize)  (THIS) PURE; \ <br>}; <br> <br>extern DBGMEM_Vtbl vtblDBGMEM; <br> <br>typedef struct _DBGMEM  DBGMEM,  FAR *PDBGMEM; <br>typedef struct _BLK     BLK,     *PBLK; <br>typedef struct _BLK UNALIGNED * PUABLK; <br>typedef struct _BLKTAIL BLKTAIL, *PBLKTAIL; <br> <br>struct _DBGMEM { <br>    DBGMEM_Vtbl *       lpVtbl; <br>    ULONG               cRef; <br>    LPMALLOC            pmalloc; <br>    char                szSubsys[16]; <br>    ULONG               ulAllocNum; <br>    ULONG               ulAllocAt; <br>    ULONG               ulFailureAt; <br>    BOOL                fCheckOften; <br>    BOOL                fUnleakable; <br>    ULONG               cbVirtual; <br>    BOOL                fFillRandom; <br>    int                 cbExtra; <br>    int                 cbTail; <br>    PBLK                pblkHead; <br>#if defined(_WIN32) &amp;&amp; defined(_X86_) <br>    CRITICAL_SECTION    cs; <br>#endif <br>}; <br> <br>#define NCALLERS    12 <br> <br>struct _BLK { <br>    PDBGMEM         pdbgmem;        /* pointer to the allocator */ <br>    PBLK            pblkNext;       /* next link in chain of allocated blocks */ <br>    PBLK            pblkPrev;       /* prev link in chain of allocated blocks */ <br>    ULONG           ulAllocNum;     /* internal allocation number */ <br>    BOOL            fUnleakable;    /* TRUE if leak code should ignore block */ <br>    #if defined(_WIN32) &amp;&amp; defined(_X86_) <br>    FARPROC         pfnCallers[NCALLERS]; <br>    #endif <br>    PBLKTAIL        pblktail;       /* pointer to block tail */ <br>}; <br> <br>struct _BLKTAIL { <br>    PBLK            pblk;           /* pointer back to beginning of the block */ <br>}; <br> <br>#define PblkToPv(pblk)          ((LPVOID)((PBLK)(pblk) + 1)) <br>#define PvToPblk(pblk)          ((PBLK)(pv) - 1) <br>#define PblkClientSize(pblk)    ((ULONG)((char *)(pblk)-&gt;pblktail - (char *)PblkToPv(pblk))) <br>#define PblkAllocSize(pblk)     (PblkClientSize(pblk) + sizeof(BLK) + (pblk)-&gt;pdbgmem-&gt;cbTail) <br> <br>#if defined(_WIN32) &amp;&amp; defined(_X86_) <br>#define DBGMEM_EnterCriticalSection(pdbgmem)    \ <br>        EnterCriticalSection(&amp;(pdbgmem)-&gt;cs) <br>#define DBGMEM_LeaveCriticalSection(pdbgmem)    \ <br>        LeaveCriticalSection(&amp;(pdbgmem)-&gt;cs) <br>#else <br>#define DBGMEM_EnterCriticalSection(pdbgmem) <br>#define DBGMEM_LeaveCriticalSection(pdbgmem) <br>#endif <br> <br>#define INITGUID <br>#include &lt;initguid.h&gt; <br> <br>DEFINE_OLEGUID(DBGMEM_IID_IUnknown,     0x00000000L, 0, 0); <br>DEFINE_OLEGUID(DBGMEM_IID_IMalloc,      0x00000002L, 0, 0); <br>DEFINE_OLEGUID(DBGMEM_IID_IBaseMalloc,  0x000203FFL, 0, 0); <br> <br>/* Forward Declarations ----------------------------------------------------- */ <br> <br>BOOL DBGMEM_ValidatePblk(PDBGMEM pdbgmem, PBLK pblk, char ** pszReason); <br>BOOL DBGMEM_ValidatePv(PDBGMEM pdbgmem, void * pv, char * pszFunc); <br>STDMETHODIMP_(void) DBGMEM_Free(PDBGMEM pdbgmem, void * pv); <br> <br>/* Call Stack (_WIN32) ------------------------------------------------------- */ <br> <br>#if defined(_WIN32) &amp;&amp; defined(_X86_) <br> <br>#ifdef _WIN95 <br>#define dwStackLimit    0x00400000      /*  4MB for Windows 95 */ <br>#else <br>#define dwStackLimit    0x00010000      /*  64KB for NT */ <br>#endif <br> <br>void EXPORTDBG __cdecl GetCallStack(DWORD *pdwCaller, int cSkip, int cFind) <br>{ <br>    DWORD * pdwStack; <br>    DWORD * pdwStackPrev = (DWORD *)0; <br>    DWORD   dwCaller; <br> <br>    __asm mov pdwStack, ebp <br> <br>    memset(pdwCaller, 0, cFind * sizeof(DWORD)); <br> <br>    while (cSkip + cFind &gt; 0) <br>    { <br>        pdwStack = (DWORD *)*pdwStack; <br> <br>        if (    pdwStack &lt;= (DWORD *)dwStackLimit <br>            ||  pdwStackPrev &gt;= pdwStack <br>            ||  IsBadReadPtr(pdwStack, 2 * sizeof(DWORD))) <br>            break; <br> <br>        dwCaller = *(pdwStack + 1); <br> <br>        if (dwCaller &lt;= dwStackLimit) <br>            break; <br>        else if (cSkip &gt; 0) <br>            cSkip -= 1; <br>        else <br>        { <br>            *pdwCaller++ = dwCaller; <br>            cFind -= 1; <br> <br>            pdwStackPrev = pdwStack; <br>        } <br>    } <br>} <br> <br>#endif <br> <br>/* Virtual Memory Support (_WIN32) ------------------------------------------- */ <br> <br>#if defined(_WIN32) &amp;&amp; (defined(_X86_) || defined(_PPC_) || defined(_MIPS_)) <br> <br>#define PAGE_SIZE       4096 <br>#define PvToVMBase(pv)  ((void *)((ULONG)pv &amp; 0xFFFF0000)) <br> <br>BOOL VMValidatePvEx(void *pv, ULONG cbCluster) <br>{ <br>    void *  pvBase; <br>    BYTE *  pb; <br> <br>    pvBase = PvToVMBase(pv); <br> <br>    pb = (BYTE *)pvBase + sizeof(ULONG); <br> <br>    while (pb &lt; (BYTE *)pv) { <br>        if (*pb++ != 0xAD) { <br>            TrapSz1("VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv); <br>            return(FALSE); <br>        } <br>    } <br> <br>    if (cbCluster != 1) <br>    { <br>        ULONG cb = *((ULONG *)pvBase); <br>        ULONG cbPad = 0; <br> <br>        if (cb % cbCluster) <br>            cbPad = (cbCluster - (cb % cbCluster)); <br> <br>        if (cbPad) <br>        { <br>            BYTE *pbMac; <br> <br>            pb = (BYTE *)pv + cb; <br>            pbMac = pb + cbPad; <br> <br>            while (pb &lt; pbMac) <br>            { <br>                if (*pb++ != 0xBC) <br>                { <br>                    TrapSz1("VMValidatePvEx(pv=%08lX): Block trailer has been " <br>                        "overwritten", pv); <br>                    return(FALSE); <br>                } <br>            } <br>        } <br>    } <br> <br>    return(TRUE); <br>} <br> <br>void * EXPORTDBG __cdecl VMAlloc(ULONG cb) <br>{ <br>    return VMAllocEx(cb, 1); <br>} <br> <br>void * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster) <br>{ <br>    ULONG   cbAlloc; <br>    void *  pvR; <br>    void *  pvC; <br>    ULONG   cbPad   = 0; <br> <br>    // a cluster size of 0 means don't use the virtual allocator. <br> <br>    AssertSz(cbCluster != 0, "Cluster size is zero."); <br> <br>    if (cb &gt; 0x100000) <br>        return(0); <br> <br>    if (cb % cbCluster) <br>        cbPad = (cbCluster - (cb % cbCluster)); <br> <br>    cbAlloc = sizeof(ULONG) + cb + cbPad + PAGE_SIZE - 1; <br>    cbAlloc -= cbAlloc % PAGE_SIZE; <br>    cbAlloc += PAGE_SIZE; <br> <br>    pvR = VirtualAlloc(0, cbAlloc, MEM_RESERVE, PAGE_NOACCESS); <br> <br>    if (pvR == 0) <br>        return(0); <br> <br>    pvC = VirtualAlloc(pvR, cbAlloc - PAGE_SIZE, MEM_COMMIT, PAGE_READWRITE); <br> <br>    if (pvC != pvR) <br>    { <br>        VirtualFree(pvR, 0, MEM_RELEASE); <br>        return(0); <br>    } <br> <br>    *(ULONG *)pvC = cb; <br> <br>    memset((BYTE *)pvC + sizeof(ULONG), 0xAD, <br>        (UINT) cbAlloc - cb - cbPad - sizeof(ULONG) - PAGE_SIZE); <br> <br>    if (cbPad) <br>        memset((BYTE *)pvC + cbAlloc - PAGE_SIZE - cbPad, 0xBC, <br>            (UINT) cbPad); <br> <br>    return((BYTE *)pvC + (cbAlloc - cb - cbPad - PAGE_SIZE)); <br>} <br> <br>void EXPORTDBG __cdecl VMFree(void *pv) <br>{ <br>    VMFreeEx(pv, 1); <br>} <br> <br>void EXPORTDBG __cdecl VMFreeEx(void *pv, ULONG cbCluster) <br>{ <br>    VMValidatePvEx(pv, cbCluster); <br> <br>    if (!VirtualFree(PvToVMBase(pv), 0, MEM_RELEASE)) <br>        TrapSz2("VMFreeEx(pv=%08lX): VirtualFree failed (%08lX)", <br>            pv, GetLastError()); <br>} <br> <br>void * EXPORTDBG __cdecl VMRealloc(void *pv, ULONG cb) <br>{ <br>    return VMReallocEx(pv, cb, 1); <br>} <br> <br>void * EXPORTDBG __cdecl VMReallocEx(void *pv, ULONG cb, ULONG cbCluster) <br>{ <br>    void *  pvNew = 0; <br>    ULONG   cbCopy; <br> <br>    VMValidatePvEx(pv, cbCluster); <br> <br>    cbCopy = *(ULONG *)PvToVMBase(pv); <br>    if (cbCopy &gt; cb) <br>        cbCopy = cb; <br> <br>    pvNew = VMAllocEx(cb, cbCluster); <br> <br>    if (pvNew) <br>    { <br>        MemCopy(pvNew, pv, cbCopy); <br>        VMFreeEx(pv, cbCluster); <br>    } <br> <br>    return(pvNew); <br>} <br> <br>ULONG EXPORTDBG __cdecl VMGetSize(void *pv) <br>{ <br>    return VMGetSizeEx(pv, 1); <br>} <br> <br>ULONG EXPORTDBG __cdecl VMGetSizeEx(void *pv, ULONG cbCluster) <br>{ <br>    return(*(ULONG *)PvToVMBase(pv)); <br>} <br> <br>#endif <br> <br>/* Virtual Memory Support (WIN16) ------------------------------------------- */ <br> <br>#ifdef WIN16 <br> <br>#define PvToVMBase(pv)  ((void *)((ULONG)pv &amp; 0xFFFF0000)) <br> <br>BOOL VMValidatePvEx(void *pv, ULONG cbCluster) <br>{ <br>    void *  pvBase; <br>    BYTE *  pb; <br> <br>    pvBase = PvToVMBase(pv); <br> <br>    pb = (BYTE *)pvBase + sizeof(ULONG); <br> <br>    while (pb &lt; (BYTE *)pv) { <br>        if (*pb++ != 0xAD) { <br>            TrapSz1("VMValidatePvEx(pv=%08lX): Block leader has been overwritten", pv); <br>            return(FALSE); <br>        } <br>    } <br> <br>    if (cbCluster != 1) <br>    { <br>        ULONG cb = *((ULONG *)pvBase); <br>        ULONG cbPad = 0; <br> <br>        if (cb % cbCluster) <br>            cbPad = (cbCluster - (cb % cbCluster)); <br> <br>        if (cbPad) <br>        { <br>            BYTE *pbMac; <br> <br>            pb = (BYTE *)pv + cb; <br>            pbMac = pb + cbPad; <br> <br>            while (pb &lt; pbMac) <br>            { <br>                if (*pb++ != 0xBC) <br>                { <br>                    TrapSz1("VMValidatePvEx(pv=%08lX): Block trailer has been " <br>                        "overwritten", pv); <br>                    return(FALSE); <br>                } <br>            } <br>        } <br>    } <br> <br>    return(TRUE); <br>} <br> <br>BOOL VMValidatePv(void *pv) <br>{ <br>    return VMValidatePvEx(pv, 1); <br>} <br> <br>void * EXPORTDBG __cdecl VMAlloc(ULONG cb) <br>{ <br>    return VMAllocEx(cb, 1); <br>} <br> <br>void * EXPORTDBG __cdecl VMAllocEx(ULONG cb, ULONG cbCluster) <br>{ <br>    HGLOBAL hGlobal; <br>    ULONG   cbAlloc; <br>    ULONG   cbAllocFromSys; <br>    void *  pvAlloc; <br>    ULONG   cbPad   = 0; <br> <br>    if (cb &gt; 0x10000 - sizeof(ULONG)) <br>        return(0); <br> <br>    if (cb % cbCluster) <br>        cbPad = (cbCluster - (cb % cbCluster)); <br> <br>    cbAlloc = sizeof(ULONG) + cb + cbPad; <br> <br>    if (cbAlloc &gt; 0x10000) <br>        return(0); <br> <br>#ifdef SIMPLE_MAPI <br>    hGlobal = GlobalAlloc(GPTR | GMEM_SHARE, cbAlloc); <br>#else    <br>    hGlobal = GlobalAlloc(GPTR, cbAlloc); <br>#endif   <br> <br>    if (hGlobal == 0) <br>        return(0); <br> <br>    cbAllocFromSys = GlobalSize(hGlobal); <br> <br>    Assert(cbAllocFromSys &gt;= cbAlloc); <br> <br>    cbAlloc = cbAllocFromSys; <br> <br>    pvAlloc = GlobalLock(hGlobal); <br> <br>    if (pvAlloc == 0) { <br>        GlobalFree(hGlobal); <br>        return(0); <br>    } <br> <br>    Assert(((ULONG)pvAlloc &amp; 0x0000FFFF) == 0); <br> <br>    *(ULONG *)pvAlloc = cb; <br> <br>    memset((BYTE *)pvAlloc + sizeof(ULONG), 0xAD, <br>        (size_t)(cbAlloc - cb - cbPad - sizeof(ULONG))); <br> <br>    if (cbPad) <br>        memset((BYTE *)pvAlloc + cbAlloc - cbPad, 0xBC, (size_t) cbPad); <br> <br>    return((BYTE *)pvAlloc + (cbAlloc - cb - cbPad)); <br>} <br> <br>void EXPORTDBG __cdecl VMFree(void *pv) <br>{ <br>    VMFreeEx(pv, 1); <br>} <br> <br>void EXPORTDBG __cdecl VMFreeEx(void *pv, ULONG cbCluster) <br>{ <br>    if (VMValidatePvEx(pv, cbCluster)) <br>    { <br>        HGLOBAL hGlobal; <br>        ULONG cb = *(ULONG *)PvToVMBase(pv); <br> <br>        memset(pv, 0xFE, (size_t)cb); <br> <br>        hGlobal = (HGLOBAL)((ULONG)pv &gt;&gt; 16); <br>        GlobalFree(hGlobal); <br>    } <br>} <br> <br>void * EXPORTDBG __cdecl VMRealloc(void *pv, ULONG cb) <br>{ <br>    return VMReallocEx(pv, cb, 1); <br>} <br> <br>void * EXPORTDBG __cdecl VMReallocEx(void *pv, ULONG cb, ULONG cbCluster) <br>{ <br>    void *  pvNew = 0; <br>    ULONG   cbCopy; <br> <br>    if (VMValidatePvEx(pv, cbCluster)) { <br>        cbCopy = *(ULONG *)PvToVMBase(pv); <br>        if (cbCopy &gt; cb) <br>            cbCopy = cb; <br> <br>        pvNew = VMAllocEx(cb, cbCluster); <br> <br>        if (pvNew) { <br>            MemCopy(pvNew, pv, (size_t)cbCopy); <br>            VMFreeEx(pv, cbCluster); <br>        } <br>    } <br> <br>    return(pvNew); <br>} <br> <br>ULONG EXPORTDBG __cdecl VMGetSize(void *pv) <br>{ <br>    return VMGetSizeEx(pv, 1); <br>} <br> <br>ULONG EXPORTDBG __cdecl VMGetSizeEx(void *pv, ULONG ulCluster) <br>{ <br>    if (VMValidatePvEx(pv, ulCluster)) <br>        return(*(ULONG *)PvToVMBase(pv)); <br> <br>    return(0); <br>} <br> <br>#endif <br> <br>/* Virtual Memory Support (Others) ------------------------------------------ */ <br>/* <br> *  The VM Allocators do not currently work on: <br> *      ALPHA <br> *      MAC <br> */ <br>#if defined(MAC) || defined(_ALPHA_) <br>#define VMAlloc(cb)             0 <br>#define VMAllocEx(cb, ul)       0 <br>#define VMRealloc(pv, cb)       0 <br>#define VMReallocEx(pv, cb, ul) 0 <br>#define VMFree(pv) <br>#define VMFreeEx(pv, ul) <br>#define VMGetSize(pv)           0 <br>#define VMGetSizeEx(pv, ul)     0 <br>#endif <br> <br>/* PblkEnqueue / PblkDequeue ------------------------------------------------ */ <br> <br>void PblkEnqueue(PBLK pblk) <br>{ <br>    pblk-&gt;pblkNext          = pblk-&gt;pdbgmem-&gt;pblkHead; <br>    pblk-&gt;pblkPrev          = 0; <br>    pblk-&gt;pdbgmem-&gt;pblkHead = pblk; <br> <br>    if (pblk-&gt;pblkNext) <br>        pblk-&gt;pblkNext-&gt;pblkPrev = pblk; <br> <br>} <br> <br>void PblkDequeue(PBLK pblk) <br>{ <br>    if (pblk-&gt;pblkNext) <br>        pblk-&gt;pblkNext-&gt;pblkPrev = pblk-&gt;pblkPrev; <br> <br>    if (pblk-&gt;pblkPrev) <br>        pblk-&gt;pblkPrev-&gt;pblkNext = pblk-&gt;pblkNext; <br>    else <br>        pblk-&gt;pdbgmem-&gt;pblkHead  = pblk-&gt;pblkNext; <br>} <br> <br>/* QueryInterface/AddRef/Release -------------------------------------------- */ <br> <br>STDMETHODIMP DBGMEM_QueryInterface(PDBGMEM pdbgmem, REFIID riid, LPVOID FAR* ppvObj) <br>{ <br>    if (memcmp(riid, &amp;DBGMEM_IID_IBaseMalloc, sizeof(IID)) == 0) { <br>        pdbgmem-&gt;pmalloc-&gt;lpVtbl-&gt;AddRef(pdbgmem-&gt;pmalloc); <br>        *ppvObj = pdbgmem-&gt;pmalloc; <br>        return(0); <br>    } <br> <br>    if (memcmp(riid, &amp;DBGMEM_IID_IMalloc, sizeof(IID)) == 0 || <br>        memcmp(riid, &amp;DBGMEM_IID_IUnknown, sizeof(IID)) == 0) { <br>        ++pdbgmem-&gt;cRef; <br>        *ppvObj = pdbgmem; <br>        return(0); <br>    } <br> <br>    *ppvObj = NULL; /* OLE requires zeroing [out] parameter */ <br>    return(ResultFromScode(E_NOINTERFACE)); <br>} <br> <br>STDMETHODIMP_(ULONG) DBGMEM_AddRef(PDBGMEM pdbgmem) <br>{ <br>    ULONG cRef; <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br>    cRef = ++pdbgmem-&gt;cRef; <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br> <br>    return(cRef); <br>} <br> <br>STDMETHODIMP_(ULONG) DBGMEM_Release(PDBGMEM pdbgmem) <br>{ <br>    ULONG       cRef; <br>    LPMALLOC    pmalloc; <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br>    cRef = --pdbgmem-&gt;cRef; <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br> <br>    if (cRef == 0) { <br>        DBGMEM_CheckMemFn(pdbgmem, TRUE); <br>        pmalloc = pdbgmem-&gt;pmalloc; <br>        pdbgmem-&gt;lpVtbl = 0; <br>        #if defined(_WIN32) &amp;&amp; defined(_X86_) <br>        DeleteCriticalSection(&amp;pdbgmem-&gt;cs); <br>        #endif <br>        pmalloc-&gt;lpVtbl-&gt;Free(pmalloc, pdbgmem); <br>        pmalloc-&gt;lpVtbl-&gt;Release(pmalloc); <br>    } <br> <br>    return(cRef); <br>} <br> <br>/* IMalloc::Alloc ----------------------------------------------------------- */ <br> <br>STDMETHODIMP_(void FAR *) DBGMEM_Alloc(PDBGMEM pdbgmem, ULONG cb) <br>{ <br>    PBLK    pblk; <br>    ULONG   cbAlloc; <br>    LPVOID  pvAlloc = 0; <br>    BYTE    bFill   = 0xFA; <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br> <br>    if (pdbgmem-&gt;fCheckOften) <br>        DBGMEM_CheckMemFn(pdbgmem, FALSE); <br> <br>    cbAlloc = sizeof(BLK) + cb + pdbgmem-&gt;cbTail; <br> <br>    if (pdbgmem-&gt;ulFailureAt != 0) <br>    { <br>        if (pdbgmem-&gt;ulFailureAt != pdbgmem-&gt;ulAllocAt) <br>            ++pdbgmem-&gt;ulAllocAt; <br>        else <br>            cbAlloc = 0; <br>    } <br> <br>    if (cbAlloc &lt; cb) <br>        pblk = 0; <br>    else if (pdbgmem-&gt;cbVirtual) <br>        pblk = VMAllocEx(cbAlloc, pdbgmem-&gt;cbVirtual); <br>    else <br>        pblk = (PBLK)pdbgmem-&gt;pmalloc-&gt;lpVtbl-&gt;Alloc(pdbgmem-&gt;pmalloc, cbAlloc); <br> <br>    if (pblk) { <br>        pblk-&gt;pdbgmem       = pdbgmem; <br>        pblk-&gt;ulAllocNum    = ++pdbgmem-&gt;ulAllocNum; <br>        pblk-&gt;fUnleakable   = FALSE; <br>        pblk-&gt;pblktail      = (PBLKTAIL)((char *)pblk + sizeof(BLK) + cb); <br> <br>        if (!pdbgmem-&gt;cbVirtual) <br>            *((PUABLK UNALIGNED * ) <br>            &amp;((struct _BLKTAIL UNALIGNED *) pblk-&gt;pblktail)-&gt;pblk) = pblk; <br> <br>        PblkEnqueue(pblk); <br> <br>        #if defined(_WIN32) &amp;&amp; defined(_X86_) <br>        GetCallStack((DWORD *)pblk-&gt;pfnCallers, 0, NCALLERS); <br>        #endif <br> <br>        if (pdbgmem-&gt;fCheckOften) <br>            DBGMEM_CheckMemFn(pdbgmem, FALSE); <br> <br>        pvAlloc = PblkToPv(pblk); <br> <br>        if (pdbgmem-&gt;fFillRandom) <br>            bFill = (BYTE)pblk-&gt;ulAllocNum; <br> <br>        memset(pvAlloc, bFill, (size_t)cb); <br> <br>        if (pdbgmem-&gt;cbExtra) <br>            memset(pblk-&gt;pblktail + 1, 0xAE, pdbgmem-&gt;cbExtra * sizeof(ULONG)); <br>    } <br> <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br> <br>    return(pvAlloc); <br>} <br> <br>/* IMalloc::Realloc --------------------------------------------------------- */ <br> <br>STDMETHODIMP_(void FAR *) DBGMEM_Realloc(PDBGMEM pdbgmem, void FAR* pv, ULONG cb) <br>{ <br>    ULONG   cbAlloc; <br>    LPVOID  pvAlloc = 0; <br>    BYTE    bFill = 0xFA; <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br> <br>    if (pdbgmem-&gt;fCheckOften) <br>        DBGMEM_CheckMemFn(pdbgmem, FALSE); <br> <br>    if (pv == 0) { <br>        TrapSz1("DBGMEM_Realloc(pv=NULL,cb=%ld): IMalloc::Realloc is being used allocate a new memory block.  Explicit use of IMalloc::Alloc is preferred.", cb); <br>        pvAlloc = DBGMEM_Alloc(pdbgmem, cb); <br>    } else if (cb == 0) { <br>        TrapSz1("DBGMEM_Realloc(pv=%08lX,cb=0): IMalloc::Realloc is being used to free a memory block.  Explicit use of IMalloc::Free is preferred.", pv); <br>        DBGMEM_Free(pdbgmem, pv); <br>        pvAlloc = 0; <br>    } else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_Realloc")) { <br>        PBLK    pblk    = PvToPblk(pv); <br>        ULONG   cbOld   = PblkClientSize(pblk); <br>        PBLK    pblkNew; <br> <br>        PblkDequeue(pblk); <br> <br>        cbAlloc = sizeof(BLK) + cb + pdbgmem-&gt;cbTail; <br> <br>        if (pdbgmem-&gt;ulFailureAt != 0) <br>        { <br>            if (pdbgmem-&gt;ulFailureAt != pdbgmem-&gt;ulAllocAt) <br>                ++pdbgmem-&gt;ulAllocAt; <br>            else <br>                cbAlloc = 0; <br>        } <br> <br>        if (cbAlloc &lt; cb) <br>            pblkNew = 0; <br>        else if (pdbgmem-&gt;cbVirtual) <br>            pblkNew = (PBLK)VMReallocEx(pblk, cbAlloc, pdbgmem-&gt;cbVirtual); <br>        else <br>            pblkNew = (PBLK)pdbgmem-&gt;pmalloc-&gt;lpVtbl-&gt;Realloc(pdbgmem-&gt;pmalloc, pblk, cbAlloc); <br> <br>        if (pblkNew == 0) { <br>            PblkEnqueue(pblk); <br>            pvAlloc = 0; <br>        } else { <br>            pblkNew-&gt;pblktail = (PBLKTAIL)((char *)pblkNew + sizeof(BLK) + cb); <br> <br>            if (!pdbgmem-&gt;cbVirtual) <br>                *((PUABLK UNALIGNED * ) <br>                &amp;((struct _BLKTAIL UNALIGNED *) pblkNew-&gt;pblktail)-&gt;pblk) = pblkNew; <br> <br>            PblkEnqueue(pblkNew); <br> <br>            pvAlloc = PblkToPv(pblkNew); <br> <br>            if (pdbgmem-&gt;fFillRandom) <br>                bFill = (BYTE)pblkNew-&gt;ulAllocNum; <br> <br>            if (cb &gt; cbOld) <br>                memset((char *)pvAlloc + cbOld, bFill, (size_t)(cb - cbOld)); <br> <br>            if (pdbgmem-&gt;cbExtra) <br>                memset(pblkNew-&gt;pblktail + 1, 0xAE, pdbgmem-&gt;cbExtra * sizeof(ULONG)); <br>        } <br>    } <br> <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br> <br>    return(pvAlloc); <br>} <br> <br>/* IMalloc::Free ------------------------------------------------------------ */ <br> <br>STDMETHODIMP_(void) DBGMEM_Free(PDBGMEM pdbgmem, void FAR * pv) <br>{ <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br> <br>    if (pdbgmem-&gt;fCheckOften) <br>        DBGMEM_CheckMemFn(pdbgmem, FALSE); <br> <br>    if (pv &amp;&amp; DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_Free")) { <br>        PBLK pblk = PvToPblk(pv); <br> <br>        PblkDequeue(pblk); <br> <br>        memset(pblk, 0xDC, (size_t)PblkAllocSize(pblk)); <br> <br>        if (pdbgmem-&gt;cbVirtual) <br>            VMFreeEx(pblk, pdbgmem-&gt;cbVirtual); <br>        else <br>            pdbgmem-&gt;pmalloc-&gt;lpVtbl-&gt;Free(pdbgmem-&gt;pmalloc, pblk); <br>    } <br> <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br>} <br> <br>/* IMalloc::GetSize --------------------------------------------------------- */ <br> <br>STDMETHODIMP_(ULONG) DBGMEM_GetSize(PDBGMEM pdbgmem, void FAR * pv) <br>{ <br>    ULONG ulResult = (ULONG)(-1); <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br> <br>    if (pv == 0) <br>        TrapSz("Although technically not an error, I bet you didn't really want to pass a NULL pointer to IMalloc::GetSize, did you?  I hope you can deal with a size of -1, because that's the offical answer.  Good luck."); <br>    else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_GetSize")) <br>        ulResult = PblkClientSize(PvToPblk(pv)); <br> <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br> <br>    return(ulResult); <br>} <br> <br>/* IMalloc::DidAlloc -------------------------------------------------------- */ <br> <br>STDMETHODIMP_(int) DBGMEM_DidAlloc(PDBGMEM pdbgmem, void FAR * pv) <br>{ <br>    PBLK    pblk; <br>    char *  pszReason; <br>    int     iResult = 0; <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br> <br>    for (pblk = pdbgmem-&gt;pblkHead; pblk; pblk = pblk-&gt;pblkNext) <br>    { <br>        AssertSz2(DBGMEM_ValidatePblk(pdbgmem,pblk,&amp;pszReason)==TRUE, <br>                 "Block header (pblk=%08lX) is invalid\n%s", <br>                 pblk, pszReason); <br>        if (PblkToPv(pblk) == pv) { <br>            iResult = 1; <br>            break; <br>        } <br>    } <br> <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br> <br>    return(iResult); <br>} <br> <br>/* IMalloc::HeapMinimize ---------------------------------------------------- */ <br> <br>STDMETHODIMP_(void) DBGMEM_HeapMinimize(PDBGMEM pdbgmem) <br>{ <br>    pdbgmem-&gt;pmalloc-&gt;lpVtbl-&gt;HeapMinimize(pdbgmem-&gt;pmalloc); <br>} <br> <br>/* DBGMEM_ValidatePblk ------------------------------------------------------ */ <br> <br>BOOL DBGMEM_ValidatePblk(PDBGMEM pdbgmem, PBLK pblk, char ** pszReason) <br>{ <br>    #if defined(WIN16) || (defined(_WIN32) &amp;&amp; defined(_X86_)) <br>    if (IsBadWritePtr(pblk, sizeof(BLK))) { <br>        *pszReason = "Block header cannot be written to"; <br>        goto err; <br>    } <br>    #endif <br> <br>    if (pblk-&gt;pdbgmem != pdbgmem) { <br>        *pszReason = "Block header does not have correct pointer back to allocator"; <br>        goto err; <br>    } <br> <br>    if (pblk-&gt;pblkNext) { <br>        #if defined(WIN16) || (defined(_WIN32) &amp;&amp; defined(_X86_)) <br>        if (IsBadWritePtr(pblk-&gt;pblkNext, sizeof(BLK))) { <br>            *pszReason = "Block header has invalid next link pointer"; <br>            goto err; <br>        } <br>        #endif <br> <br>        if (pblk-&gt;pblkNext-&gt;pblkPrev != pblk) { <br>            *pszReason = "Block header points to a next block which doesn't point back to it"; <br>            goto err; <br>        } <br>    } </code></pre>
<p>
</p>
<pre><code><br>    if (pblk-&gt;pblkPrev) { <br>        #if defined(WIN16) || (defined(_WIN32) &amp;&amp; defined(_X86_)) <br>        if (IsBadWritePtr(pblk-&gt;pblkPrev, sizeof(BLK))) { <br>            *pszReason = "Block header has invalid prev link pointer"; <br>            goto err; <br>        } <br>        #endif <br> <br>        if (pblk-&gt;pblkPrev-&gt;pblkNext != pblk) { <br>            *pszReason = "Block header points to a prev block which doesn't point back to it"; <br>            goto err; <br>        } <br>    } else if (pdbgmem-&gt;pblkHead != pblk) { <br>        *pszReason = "Block header has a zero prev link but the allocator doesn't believe it is the first block"; <br>        goto err; <br>    } <br> <br>    if (pblk-&gt;ulAllocNum &gt; pdbgmem-&gt;ulAllocNum) { <br>        *pszReason = "Block header has an invalid internal allocation number"; <br>        goto err; <br>    } <br> <br>    if (!pdbgmem-&gt;cbVirtual) { <br>        #if defined(WIN16) || (defined(_WIN32) &amp;&amp; defined(_X86_)) <br>        if (IsBadWritePtr(pblk-&gt;pblktail, pdbgmem-&gt;cbTail)) { <br>            *pszReason = "Block header has invalid pblktail pointer"; <br>            goto err; <br>        } <br>        #endif <br> <br>        if (*((PUABLK UNALIGNED * ) <br>            &amp;((struct _BLKTAIL UNALIGNED *) pblk-&gt;pblktail)-&gt;pblk) != pblk) { <br>            *pszReason = "Block trailer does not point back to the block header"; <br>            goto err; <br>        } <br>    } <br> <br>    if (pdbgmem-&gt;cbExtra) { <br>        ULONG UNALIGNED * pul = (ULONG UNALIGNED *)(pblk-&gt;pblktail + 1); <br>        int n = pdbgmem-&gt;cbExtra; <br>        for (; --n &gt;= 0; ++pul) <br>            if (*pul != 0xAEAEAEAE) { <br>                *pszReason = "Block trailer spiddle-zone has been overwritten"; <br>                goto err; <br>            } <br>    } <br> <br>    return(TRUE); <br> <br>err: <br>    return(FALSE); <br>} <br> <br>/* DBGMEM_ValidatePv -------------------------------------------------------- */ <br> <br>BOOL DBGMEM_ValidatePv(PDBGMEM pdbgmem, void * pv, char * pszFunc) <br>{ <br>    char *  pszReason; <br> <br>    if (DBGMEM_DidAlloc(pdbgmem, pv) == 0) { <br>        TrapSz3("DBGMEM_ValidatePv(subsys=%s,pv=%08lX) [via %s]\nDetected a memory block which was not allocated by this allocator", <br>            pdbgmem-&gt;szSubsys, pv, pszFunc); <br>        return(FALSE); <br>    } <br> <br>    if (DBGMEM_ValidatePblk(pdbgmem,PvToPblk(pv),&amp;pszReason)) <br>        return(TRUE); <br> <br>    TrapSz4("DBGMEM_ValidatePv(%s,pv=%08lX) [via %s]\n%s", <br>        pdbgmem-&gt;szSubsys, pv, pszFunc, pszReason); <br> <br>    return(FALSE); <br>} <br> <br>/* DBGMEM_ReportLeak -------------------------------------------------------- */ <br> <br>#if defined(_WIN32) &amp;&amp; defined(_X86_) <br>void EXPORTDBG __cdecl DBGMEM_LeakHook(FARPROC pfn) <br>{ <br>    /* Dummy function so that you can set a breakpoint with command   */ <br>    /* "ln ecx;g", in order to get the debugger to print out the name */ <br>    /* of the function which allocated the leaked memory block        */ <br>} <br>#endif <br> <br>void DBGMEM_ReportLeak(PDBGMEM pdbgmem, PBLK pblk) <br>{ <br>    int i = 0; <br> <br>    DebugTrace("%s Memory Leak: @%08lX, allocation #%ld, size %ld\n", <br>        pdbgmem-&gt;szSubsys, PblkToPv(pblk), pblk-&gt;ulAllocNum, PblkClientSize(pblk)); <br> <br>    #if defined(_WIN32) &amp;&amp; defined(_X86_) <br>    for (i = 0; i &lt; NCALLERS &amp;&amp; pblk-&gt;pfnCallers[i] != 0; i++) { <br>        DebugTrace("[%d] %08lX ", i, pblk-&gt;pfnCallers[i]); <br>        DBGMEM_LeakHook(pblk-&gt;pfnCallers[i]); <br>    } <br>    DebugTrace("\n"); <br>    #endif <br>} <br> <br>/* DBGMEM_NoLeakDetectFn ---------------------------------------------------- */ <br> <br>void EXPORTDBG __cdecl DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv) <br>{ <br>    PDBGMEM pdbgmem = (PDBGMEM)pmalloc; <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br> <br>    if (pv == 0) <br>        pdbgmem-&gt;fUnleakable = TRUE; <br>    else if (DBGMEM_ValidatePv(pdbgmem, pv, "DBGMEM_NoLeakDetectFn")) <br>        PvToPblk(pv)-&gt;fUnleakable = TRUE; <br> <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br>} <br> <br>/* DBGMEM_SetFailureAtFn ---------------------------------------------------- */ <br> <br>void EXPORTDBG __cdecl DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt) <br>{ <br>    PDBGMEM pdbgmem = (PDBGMEM)pmalloc; <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br> <br>    pdbgmem-&gt;ulFailureAt = ulFailureAt; <br> <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br>} <br> <br>/* DBGMEM_CheckMemFn -------------------------------------------------------- */ <br> <br>void EXPORTDBG __cdecl DBGMEM_CheckMemFn(void * pmalloc, BOOL fReportOrphans) <br>{ <br>    PDBGMEM pdbgmem = (PDBGMEM)pmalloc; <br>    PBLK    pblk; <br>    int     cLeaks = 0; <br> <br>    DBGMEM_EnterCriticalSection(pdbgmem); <br> <br>    for (pblk = pdbgmem-&gt;pblkHead; pblk; pblk = pblk-&gt;pblkNext) { <br>        if (!DBGMEM_ValidatePv(pdbgmem, PblkToPv(pblk), "DBGMEM_CheckMemFn")) <br>            break; <br> <br>        if (fReportOrphans &amp;&amp; !pdbgmem-&gt;fUnleakable &amp;&amp; !pblk-&gt;fUnleakable) { <br>            DBGMEM_ReportLeak(pdbgmem, pblk); <br>            cLeaks += 1; <br>        } <br>    } <br> <br>    #if defined(WIN16) || (defined(_WIN32) &amp;&amp; defined(_X86_)) <br>    if (fAssertLeaks == -1) <br>    { <br>        fAssertLeaks = GetPrivateProfileIntA(szSectionDebug, szKeyAssertLeaks, <br>            0, szDebugIni); <br>    } <br>    #endif <br> <br>    if (cLeaks &gt; 0) <br>    { <br>        #if defined(WIN16) || (defined(_WIN32) &amp;&amp; defined(_X86_)) <br>        if (fAssertLeaks) <br>        { <br>            TrapSz3("DBGMEM detected %d memory leak%s in subsystem %s", <br>                cLeaks, cLeaks == 1 ? "" : "s", pdbgmem-&gt;szSubsys); <br>        } <br>        else <br>        { <br>            TraceSz3("DBGMEM detected %d memory leak%s in subsystem %s", <br>                cLeaks, cLeaks == 1 ? "" : "s", pdbgmem-&gt;szSubsys); <br>        } <br>        #else <br>        TraceSz3("DBGMEM detected %d memory leak%s in subsystem %s", <br>            cLeaks, cLeaks == 1 ? "" : "s", pdbgmem-&gt;szSubsys); <br>        #endif <br>    } <br> <br>    DBGMEM_LeaveCriticalSection(pdbgmem); <br>} <br> <br>/* vtblDBGMEM --------------------------------------------------------------- */ <br> <br>DBGMEM_Vtbl BASED_DEBUG vtblDBGMEM = <br>{ <br>    VTABLE_FILL <br>    DBGMEM_QueryInterface, <br>    DBGMEM_AddRef, <br>    DBGMEM_Release, <br>    DBGMEM_Alloc, <br>    DBGMEM_Realloc, <br>    DBGMEM_Free, <br>    DBGMEM_GetSize, <br>    DBGMEM_DidAlloc, <br>    DBGMEM_HeapMinimize <br>}; <br> <br>/* DBGMEM_EncapsulateFn ----------------------------------------------------- */ <br> <br>void * EXPORTDBG __cdecl DBGMEM_EncapsulateFn(void * pvmalloc, char *pszSubsys, BOOL fCheckOften) <br>{ <br>    LPMALLOC    pmalloc = (LPMALLOC)pvmalloc; <br>    PDBGMEM     pdbgmem; <br>    LPMALLOC    pmallocBase; <br>    ULONG       cbVirtual = 0; <br>    BOOL        fFillRandom = FALSE; <br>    HRESULT     hr; <br> <br>    hr = pmalloc-&gt;lpVtbl-&gt;QueryInterface(pmalloc, &amp;DBGMEM_IID_IBaseMalloc, &amp;pmallocBase); <br>    if (hr) { <br>        pmallocBase = pmalloc; <br>        pmallocBase-&gt;lpVtbl-&gt;AddRef(pmallocBase); <br>    } <br> <br>    pdbgmem = (PDBGMEM)pmallocBase-&gt;lpVtbl-&gt;Alloc(pmallocBase, sizeof(DBGMEM)); <br> <br>    if (pdbgmem == 0) { <br>        TrapSz("DBGMEM: Failed trying to allocate memory for the first time!\n"); <br>        return(pmallocBase); <br>    } <br> <br>    #if defined(WIN16) || (defined(_WIN32) &amp;&amp; defined(_X86_)) <br>    cbVirtual = GetPrivateProfileIntA(szSectionDebug, szKeyUseVirtual, 0, <br>        szDebugIni); <br> <br>    if (cbVirtual != 0 &amp;&amp; cbVirtual != 1 &amp;&amp; cbVirtual != 4) <br>        cbVirtual = 1; <br> <br>    if (cbVirtual) <br>        DebugTrace("DBGMEM: Subsystem '%s' using virtual memory allocator -" <br>            " align %d.\n", pszSubsys, cbVirtual); <br> <br>    if (!fCheckOften) <br>        fCheckOften = GetPrivateProfileIntA(szSectionDebug, szKeyCheckOften, 0, <br>            szDebugIni); <br> <br>    fFillRandom = GetPrivateProfileIntA(szSectionDebug, szKeyFillRandom, 0, <br>        szDebugIni); <br> <br>    #endif <br> <br>    memset(pdbgmem, 0, sizeof(DBGMEM)); <br> <br>    pdbgmem-&gt;lpVtbl         = &amp;vtblDBGMEM; <br>    pdbgmem-&gt;cRef           = 1; <br>    pdbgmem-&gt;pmalloc        = pmallocBase; <br>    pdbgmem-&gt;fCheckOften    = fCheckOften; <br>    pdbgmem-&gt;fUnleakable    = FALSE; <br>    pdbgmem-&gt;cbVirtual      = cbVirtual; <br>    pdbgmem-&gt;fFillRandom    = fFillRandom; <br>    pdbgmem-&gt;cbExtra        = 0; <br>    pdbgmem-&gt;ulAllocAt      = 1L; <br>    pdbgmem-&gt;ulFailureAt    = 0L; <br> <br>    if (pdbgmem-&gt;cbVirtual) <br>        pdbgmem-&gt;cbTail     = 0; <br>    else <br>        pdbgmem-&gt;cbTail     = sizeof(BLKTAIL) + pdbgmem-&gt;cbExtra * sizeof(ULONG); <br> <br>    lstrcpyn(pdbgmem-&gt;szSubsys, pszSubsys, sizeof(pdbgmem-&gt;szSubsys)); <br> <br>    #if defined(_WIN32) &amp;&amp; defined(_X86_) <br>    InitializeCriticalSection(&amp;pdbgmem-&gt;cs); <br>    #endif <br> <br>    return(pdbgmem); <br>} <br> <br>/* DBGMEM_ShutdownFn -------------------------------------------------------- */ <br> <br>void EXPORTDBG __cdecl DBGMEM_ShutdownFn(void *pvmalloc) <br>{ <br>    LPMALLOC    pmalloc = (LPMALLOC)pvmalloc; <br>    PDBGMEM     pdbgmem = (PDBGMEM)pvmalloc; <br>    LPMALLOC    pmallocBase; <br>    HRESULT     hr; <br> <br>    hr = pmalloc-&gt;lpVtbl-&gt;QueryInterface(pmalloc, &amp;DBGMEM_IID_IBaseMalloc, &amp;pmallocBase); <br>    if (hr == 0) { <br>        pmallocBase-&gt;lpVtbl-&gt;Release(pmallocBase); <br>        if (pdbgmem-&gt;cRef != 1) { <br>            TrapSz2("DBGMEM_Shutdown: Expected a cRef of 1; instead have %ld for %s", <br>                pdbgmem-&gt;cRef, pdbgmem-&gt;szSubsys); <br>            pdbgmem-&gt;cRef = 1; <br>        } <br>    } <br> <br>    pmalloc-&gt;lpVtbl-&gt;Release(pmalloc); <br>} <br> <br>/* -------------------------------------------------------------------------- */ <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
