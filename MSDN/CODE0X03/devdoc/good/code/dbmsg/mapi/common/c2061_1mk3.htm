<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PVALLOC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2073"></a>PVALLOC.C</h2>
<pre><code>/* <br> -  P V A L L O C . C <br> - <br> *  Copyright (C) 1995 Microsoft Corporation <br> *  Purpose: <br> *      Implementation of a chained memory manager. <br> * <br> */ <br> <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;pvalloc.h&gt; <br> <br>#undef _PVALLOC_LOG <br> <br>#ifdef _PVALLOC_LOG <br>static CB       cbTotalAlloc    = 0; <br>static CB       ulTotalBlockNum = 0; <br>#endif <br> <br> <br> <br> <br>/* <br> -  PvAlloc <br> - <br> *  Purpose: <br> *      Allocates a chunk of memory on the global heap. <br> * <br> *  Parameters: <br> *      cbSize          - Count of bytes requested. <br> * <br> *  Returns: <br> *      lpv             - Pointer to the allocated memory <br> * <br> */ <br> <br>PV PvAlloc(CB cbSize) <br>{ <br>    PV      lpv         = pvNull; <br>    HANDLE  hMem; <br>    PPVINFO ppvinfo; <br>#ifdef _PVALLOC_LOG <br>    char    szFileName[80]; <br>    LPSTR   lpszTemp    = NULL; <br>    FILE    *pFile      = NULL; <br>    char    szBuff[128]; <br>#endif <br> <br>    /* Make sure allocations are in multiples of 4 */ <br> <br>    if(cbSize &lt; 4) <br>        cbSize = 4; <br>    else if(cbSize &amp; 3) <br>        cbSize += 4 - (cbSize &amp; 3); <br> <br>    /* Allocate the block */ <br> <br>    hMem = GlobalAlloc(GMEM_MOVEABLE, cbSize + sizeof(PVINFO)); <br>    if(hMem) <br>    { <br>        ppvinfo = (PPVINFO)GlobalLock(hMem); <br>        ppvinfo-&gt;hMem    = hMem; <br>        ppvinfo-&gt;lpvNext = pvNull; <br>        ppvinfo-&gt;lpvBuf  = ((PB)ppvinfo) + sizeof(PVINFO); <br>#ifdef _PVALLOC_LOG <br>        ppvinfo-&gt;cbSize  = cbSize; <br>        ulTotalBlockNum++; <br>        ppvinfo-&gt;ulBlockNum = ulTotalBlockNum; <br>        cbTotalAlloc += cbSize; <br>         <br>        // log to file <br>        lpszTemp = getenv("TEMP"); <br> <br>        if(lpszTemp) <br>            strcpy(szFileName, lpszTemp); <br>        else <br>            strcpy(szFileName, "c:\\temp"); <br> <br>        strcat(szFileName, "\\pvalloc.log"); <br> <br>         <br>        pFile = fopen(szFileName,"a"); <br>        if (pFile == NULL)      <br>            goto NoFile;       <br>//           return NULL; <br> <br>        fprintf(pFile, "Block: \t%lu\tPvAlloc: %ld Bytes\t\tTotal: %ld Bytes\n", <br>                 ulTotalBlockNum, cbSize, cbTotalAlloc); <br> <br>        if (pFile) <br>            fclose(pFile); <br>         <br>        // log to comm port <br>        wsprintf(szBuff,"Block: \t%lu\tPvAlloc: %ld Bytes\t\tTotal: %ld Bytes\n", <br>                 ulTotalBlockNum, cbSize, cbTotalAlloc); <br>        OutputDebugString(szBuff); <br>                         <br>NoFile:                            <br> <br>#ifdef _WIN32 <br>        memset(ppvinfo-&gt;lpvBuf, 0xaa, (size_t)cbSize); <br>#else <br>        _fmemset(ppvinfo-&gt;lpvBuf, 0xaa, (size_t)cbSize); <br>#endif  /* _WIN32 */ <br> <br>#endif  /* _PVALLOC_LOG */ <br>        lpv = ppvinfo-&gt;lpvBuf; <br>    } <br> <br>    return lpv; <br>} <br> <br>/* <br> -  PvAllocMore <br> - <br> *  Purpose: <br> *      Allocates a chunk of memory and chains it to a parent block. <br> * <br> *  Parameters: <br> *      cbSize          - Count of additional bytes to allocate <br> *      lpvParent       - Pointer to parent in memory chain <br> * <br> *  Returns: <br> *      lpv             - Pointer to the allocated memory <br> * <br> */ <br> <br>PV PvAllocMore(CB cbSize, PV lpvParent) <br>{ <br>    PV          lpvStep = lpvParent; <br>    PV          lpv     = pvNull; <br>    PPVINFO     ppvinfoMore; <br>    HANDLE      hMem; <br>    PPVINFO     ppvinfo; <br> <br>    /* Step to the last link */ <br>    do <br>    { <br>        ppvinfoMore = (PPVINFO)(((PB)lpvStep) - sizeof(PVINFO)); <br>        lpvStep = ppvinfoMore-&gt;lpvNext; <br>    } <br>    while(ppvinfoMore-&gt;lpvNext != pvNull); <br> <br>    // beginning of section that was taken from PvAlloc <br> <br>    if(cbSize &lt; 4) <br>        cbSize = 4; <br>    else if(cbSize &amp; 3) <br>        cbSize += 4 - (cbSize &amp; 3); <br> <br> <br>    hMem = GlobalAlloc(GMEM_MOVEABLE, cbSize + sizeof(PVINFO)); <br>    if(hMem) <br>    { <br>        ppvinfo = (PPVINFO)GlobalLock(hMem); <br>        ppvinfo-&gt;hMem       = hMem; <br>        ppvinfo-&gt;lpvNext    = pvNull; <br>        ppvinfo-&gt;lpvBuf     = ((PB)ppvinfo) + sizeof(PVINFO); <br>#ifdef _PVALLOC_LOG <br>        ppvinfo-&gt;cbSize     = cbSize; <br>        ppvinfo-&gt;ulBlockNum = ppvinfoMore-&gt;ulBlockNum; <br>        cbTotalAlloc += cbSize; <br> <br>#ifdef _WIN32 <br>        memset(ppvinfo-&gt;lpvBuf, 0xaa, (size_t)cbSize); <br>#else <br>        _fmemset(ppvinfo-&gt;lpvBuf, 0xaa, (size_t)cbSize); <br>#endif <br> <br>#endif <br>        lpv = ppvinfo-&gt;lpvBuf; <br>    } <br>    else <br>        return lpv; <br>         <br>    // end of section taken from pvalloc <br> <br>#ifdef _WIN32 <br>        memset(lpv, 0xbb, (size_t)cbSize); <br>#else <br>        _fmemset(lpv, 0xbb, (size_t)cbSize); <br>#endif  /* _WIN32 */ <br> <br>    ppvinfoMore-&gt;lpvNext = lpv; <br> <br>    return lpv; <br>} <br> <br> <br> <br>/* <br> -  PvFree <br> - <br> *  Purpose: <br> *      This function frees memory allocated by PvAlloc or PvAllocMore. <br> *      After the call, the pointer memory will be invalid and should <br> *      not be referenced again. <br> *      When memory is allocated by PvAlloc and PvAllocMore, which can <br> *      contain several levels of pointers, all the application needs to <br> *      do to free the entire structure is call this routine with the <br> *      base pointer returned by the PvAlloc call. <br> * <br> *  Parameters: <br> *      lpv             - Pointer to memory to be freed. <br> * <br> *  Returns: <br> *      Void <br> * <br> */ <br> <br>BOOL PvFree(PV lpv) <br>{ <br>    PPVINFO ppvinfo; <br>#ifdef _PVALLOC_LOG <br>    CB      cbSize; <br>    CB      ulBlockNum; <br>    FILE    *pFile  = NULL; <br>    CB      cbFree  = 0; <br>    CB      cbTotalBeforeFree = cbTotalAlloc; <br>    char    szFileName[80]; <br>    LPSTR   lpszTemp    = NULL; <br>    char    szBuff[128]; <br>#endif <br> <br>    if(!lpv) <br>        return 0; <br> <br>    ppvinfo = (PPVINFO)(((PB)lpv) - sizeof(PVINFO)); <br> <br>    while(ppvinfo) <br>    { <br>        lpv = ppvinfo-&gt;lpvNext; <br> <br>#ifdef _PVALLOC_LOG <br>        cbSize      = ppvinfo-&gt;cbSize; <br>        cbFree      += ppvinfo-&gt;cbSize; <br>        ulBlockNum  = ppvinfo-&gt;ulBlockNum; <br> <br>#ifdef _WIN32 <br>        memset(ppvinfo-&gt;lpvBuf, 0xcc, (size_t)ppvinfo-&gt;cbSize); <br>#else <br>        _fmemset(ppvinfo-&gt;lpvBuf, 0xcc, (size_t)ppvinfo-&gt;cbSize); <br>#endif  /* _WIN32 */ <br> <br>#endif  /* _PVALLOC_LOG */ <br> <br>        if(GlobalUnlock(ppvinfo-&gt;hMem)) <br>            goto err;  // Our lock count is non-zero <br> <br>        if(GlobalFree(ppvinfo-&gt;hMem)) <br>            goto err;  // Failure <br> <br>#ifdef _PVALLOC_LOG <br>        cbTotalAlloc -= cbSize; <br>#endif <br> <br>        if(lpv) <br>            ppvinfo = (PPVINFO)(((PB)lpv) - sizeof(PVINFO)); <br>        else <br>            break; <br>    } <br> <br> <br>#ifdef _PVALLOC_LOG <br>     <br>    if((cbTotalBeforeFree - cbTotalAlloc) != cbFree) <br>       goto err; <br>        <br>    // log to file <br>    lpszTemp = getenv("TEMP"); <br> <br>    if(lpszTemp) <br>        strcpy(szFileName, lpszTemp); <br>    else <br>        strcpy(szFileName, "c:\\temp"); <br> <br>    strcat(szFileName, "\\pvalloc.log"); <br>         <br>    pFile = fopen(szFileName,"a"); <br>        <br>    if (pFile == NULL) <br>       goto err; <br> <br>    fprintf(pFile, "Block: \t%lu\t\t***PvFree***,  Freeing  %lu Bytes(Alloc and AllocMore)\tUnFreed: %ld Bytes\n", <br>                    ulBlockNum, cbFree, cbTotalAlloc); <br>    if (pFile) <br>        fclose(pFile); <br> <br>     // log to comm port <br>    wsprintf(szBuff,"Block: \t%lu\t\t***PvFree***,  Freeing  %lu Bytes(Alloc and AllocMore)\tUnFreed: %ld Bytes\n", <br>                    ulBlockNum, cbFree, cbTotalAlloc); <br>    OutputDebugString(szBuff); <br> <br>#endif  /* _PVALLOC_LOG */ <br> <br>    return 0; // Success! <br> <br>err: <br>#ifdef _PVALLOC_LOG <br> <br>    // find file to open <br>    lpszTemp = getenv("TEMP"); <br> <br>    if(lpszTemp) <br>        strcpy(szFileName, lpszTemp); <br>    else <br>        strcpy(szFileName, "c:\\temp"); <br> <br>    strcat(szFileName, "\\pvalloc.log"); <br> <br>         <br>    pFile = fopen(szFileName,"a"); <br> <br>    if (pFile == NULL) <br>       return 1; <br> <br>    fprintf(pFile, "Block: %lu Failure freeing: %ld Bytes\tUnFreed: %ld Bytes\n", <br>             ulBlockNum, cbSize, cbTotalAlloc); <br>    if (pFile) <br>        fclose(pFile); <br> <br>#endif  /* _PVALLOC_LOG */ <br> <br>    return 1; // Failure! <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
