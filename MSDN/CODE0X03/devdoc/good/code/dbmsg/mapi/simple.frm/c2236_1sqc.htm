<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FORMBASE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2244"></a>FORMBASE.CPP</h2>
<pre><code>////////////////////////////////////////////////////////////////////////////// <br>// <br>//  FILE:           FORMBASE.CPP <br>// <br>//   <br>// <br>//  Copyright (c) 1986-1996, Microsoft Corporation. <br>//  All rights reserved. <br>// <br>//-- <br> <br>#include        "precomp.h" <br>#include        &lt;cindex.h&gt; <br> <br>static BOOL     g_FModalUp = FALSE; <br>static BOOL     g_FMBoxUp = FALSE; <br>static HWND     g_hwndUp = NULL; <br> <br> <br>BOOL CALLBACK FormDlgProcSend(HWND, UINT, WPARAM, LPARAM); <br>BOOL CALLBACK FormDlgProcRead(HWND, UINT, WPARAM, LPARAM); <br> <br>SizedSPropTagArray(cpropMsg, tagaRead) = MESSAGE_TAGS; <br> <br>//szRE_PREFIX and szFW_PREFIX have to have the same length <br>char szRE_PREFIX[] = "RE: "; <br>char szFW_PREFIX[] = "FW: "; <br> <br> <br>#define EXCLUDED_PROPS_ON_REPLY     32 <br>SizedSPropTagArray (EXCLUDED_PROPS_ON_REPLY, sptExcludedProps) = <br>{ <br>    EXCLUDED_PROPS_ON_REPLY,  <br>    { <br>        PR_SENDER_NAME, <br>        PR_SENDER_ENTRYID, <br>        PR_SENDER_SEARCH_KEY, <br>        PR_SENDER_EMAIL_ADDRESS, <br>        PR_SENDER_ADDRTYPE, <br> <br>        PR_RECEIVED_BY_NAME, <br>        PR_RECEIVED_BY_ENTRYID, <br>        PR_RECEIVED_BY_SEARCH_KEY, <br> <br>        PR_SENT_REPRESENTING_NAME, <br>        PR_SENT_REPRESENTING_ENTRYID, <br>        PR_SENT_REPRESENTING_SEARCH_KEY, <br>        PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>        PR_SENT_REPRESENTING_ADDRTYPE, <br> <br>        PR_RCVD_REPRESENTING_NAME, <br>        PR_RCVD_REPRESENTING_ENTRYID, <br>        PR_RCVD_REPRESENTING_SEARCH_KEY, <br> <br>        PR_MESSAGE_FLAGS, <br>        PR_MESSAGE_RECIPIENTS, <br> <br>        PR_READ_RECEIPT_ENTRYID, <br>        PR_REPORT_ENTRYID, <br> <br>        PR_REPLY_RECIPIENT_ENTRIES, <br>        PR_REPLY_RECIPIENT_NAMES, <br> <br>        PR_PARENT_KEY, <br> <br>        PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED, <br> <br>        PR_READ_RECEIPT_REQUESTED, <br> <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_MESSAGE_DELIVERY_TIME, <br>        PR_MESSAGE_DOWNLOAD_TIME, <br> <br>        PR_BODY, <br>        PR_SUBJECT, <br>        PR_SUBJECT_PREFIX, <br>        PR_MESSAGE_ATTACHMENTS   <br> <br>    }  <br>}; <br> <br> <br>////    CBaseForm::CBaseForm <br>// <br> <br>CBaseForm::CBaseForm(CClassFactory * pClassFactory)  <br>                : m_lsterr(g_szFormName) <br>{ <br>    m_pClassFactory = pClassFactory; <br>    m_pClassFactory-&gt;AddRef(); <br> <br>    m_ulViewStatus = 0; <br>    m_ulSiteStatus = 0; <br>    m_cRef = 1; <br> <br>    m_pviewctxOverride = NULL; <br>    m_pviewctx = NULL; <br>    m_pmsgsite = NULL; <br>    m_pmsg = NULL; <br> <br>    m_hwnd = NULL; <br>    m_hwndDialog = NULL; <br>     <br>    m_pses = NULL; <br>    m_pab = NULL; <br>    m_pval = NULL; <br> <br>         <br>    m_padrlist = NULL; <br>    m_fRecipientsDirty = FALSE; <br>     <br>    m_fDirty = FALSE; <br> <br>    m_fSameAsLoaded = FALSE; <br> <br>    // <br>    //  Add self to the head of the linked list of forms <br>    // <br> <br>    m_pfrmNext = g_PfrmFirst; <br>    g_PfrmFirst = this; <br> <br>    m_cbConvIdx = 0; <br>    m_lpbConvIdx = NULL; <br>    m_fConvTopicSet = FALSE; <br> <br>    m_hChsFldDll = NULL; <br>    m_lpfnHrPickFolder = NULL; <br>    m_cbCFDState = 0; <br>    m_pbCFDState = NULL; <br> <br> <br>    m_state = stateUninit; <br>} <br> <br> <br>////    CBaseForm::~CBaseForm <br>// <br>CBaseForm::~CBaseForm() <br>{ <br>    CBaseForm *         pfrm; <br>    // <br>    //  Remove ourselves from the form link list <br>    // <br> <br>    if (g_PfrmFirst == this) <br>    { <br>        g_PfrmFirst = m_pfrmNext; <br>    } <br>    else <br>    { <br>        for (pfrm = g_PfrmFirst; pfrm != NULL; pfrm = pfrm-&gt;GetNext()) <br>        { <br>            if (pfrm-&gt;m_pfrmNext == this) <br>            { <br>                pfrm-&gt;m_pfrmNext = m_pfrmNext; <br>                break; <br>            } <br>        } <br>        Assert(pfrm != NULL); <br>    } <br> <br>    MAPIFreeBuffer(m_pval); <br> <br>    FreePadrlist(m_padrlist); <br> <br>    MAPIFreeBuffer(m_lpbConvIdx); <br> <br>    if(m_hChsFldDll) <br>        FreeLibrary(m_hChsFldDll); <br> <br>    MAPIFreeBuffer(m_pbCFDState); <br>     <br>    // <br>    //  Let the class factory know we are gone <br>    // <br> <br>    UlRelease(m_pClassFactory); <br>     <br>} <br> <br> <br>////    CBaseForm::DeInitObjects <br>// <br> <br>void CBaseForm::DeInitObjects() <br>{ <br>    if (m_hwnd != NULL) <br>    { <br>        DestroyWindow(m_hwnd);            // Destroy the frame window <br>    } <br> <br>    Assert(m_pmsg == NULL); <br>    Assert(m_pmsgsite == NULL); <br>    Assert(m_pviewctx == NULL); <br>    Assert(m_pviewctxOverride == NULL); <br>    Assert(m_pab == NULL); <br>    Assert(m_pses == NULL); <br> <br>    m_state = stateDead; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  IUnknown interface <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>////    CBaseForm::QueryInterface <br>// <br>// <br>//  DESCRIPTION:    The form supports IMAPIform, <br>//                  IPersistMessage and IAMPIFormAdviseSink <br> <br>STDMETHODIMP CBaseForm::QueryInterface(REFIID riid, LPVOID * ppvObj) <br>{ <br>    if (riid == IID_IUnknown || riid == IID_IMAPIForm) <br>    { <br>        *ppvObj = (LPVOID) (IMAPIForm *) this; <br>    } <br>    else if (riid == IID_IPersistMessage) <br>    { <br>        *ppvObj = (LPVOID) (IPersistMessage *) this; <br>    } <br>    else if (riid == IID_IMAPIFormAdviseSink) <br>    { <br>        *ppvObj = (LPVOID) (IMAPIFormAdviseSink *) this; <br>    } <br>    else <br>    { <br>        *ppvObj = NULL; <br>        return  m_lsterr.HrSetLastError(ResultFromScode(E_NOINTERFACE)); <br>    } <br> <br>    AddRef(); <br>    return hrSuccess; <br>} <br> <br>////    CBaseForm::AddRef <br>// <br>//  Description: <br>// <br> <br>STDMETHODIMP_(ULONG) CBaseForm::AddRef () <br>{ <br>    m_cRef += 1; <br>    return m_cRef; <br>} <br> <br>////    CBaseForm::Release <br>// <br> <br>STDMETHODIMP_(ULONG) CBaseForm::Release () <br>{ <br>    ULONG cRef = -- m_cRef; <br> <br>    if (cRef == 0) <br>    { <br>        // Let the class factory now we are gone <br>        m_pClassFactory-&gt;ObjDestroyedCallback(); <br>        delete this; <br>    } <br> <br>    return cRef; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  IMAPIForm interface <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br> <br>////    IMAPIForm::SetViewContext <br>// <br>// <br> <br>STDMETHODIMP CBaseForm::SetViewContext(IN IMAPIViewContext * pvc) <br>{ <br>    <br>    // <br>    //  If we currently have a view context, then release it <br>    // <br> <br>    if (m_pviewctx != NULL) <br>    { <br>        m_pviewctx-&gt;SetAdviseSink(NULL); <br>        m_pviewctx-&gt;Release(); <br>    } <br> <br>    // <br>    // Accept the new view context. <br>    // <br> <br>    m_pviewctx = pvc; <br> <br>    // <br>    //  If the new view context is non-null, then save it away, setup <br>    //  the advise sink back to check for things and get the current set <br>    //  of status flags <br>    // <br> <br>    m_ulViewStatus = 0; <br>    if (pvc != NULL) <br>    { <br>        m_pviewctx-&gt;AddRef (); <br>        m_pviewctx-&gt;SetAdviseSink (this); <br>        m_pviewctx-&gt;GetViewStatus(&amp;m_ulViewStatus); <br>    } <br>     <br>    ConfigWinMenu(); <br>     <br>    return hrSuccess; <br>} <br> <br> <br>////    IMAPIForm::GetViewContext <br>// <br> <br>STDMETHODIMP CBaseForm::GetViewContext(OUT IMAPIViewContext * FAR * ppvc) <br>{ <br>    Assert(ppvc); <br> <br>    *ppvc = m_pviewctx; <br>     <br>    if(m_pviewctx != NULL) <br>    { <br>        m_pviewctx-&gt;AddRef(); <br>        return hrSuccess; <br>    } <br>    else <br>        return ResultFromScode(S_FALSE); <br>} <br> <br> <br>////    IMAPIForm::ShutdownForm <br>// <br>//  Description: <br>//      This routine is called to shut down the form and if necessary <br>//      to cause save changes to the form. <br>// <br> <br>STDMETHODIMP CBaseForm::ShutdownForm(DWORD dwSaveOptions) <br>{ <br>  HRESULT             hr; <br>     <br>    // <br>    //  Check for valid state to make the call <br>    // <br> <br>    switch( m_state ) <br>    { <br>        default: <br>        case stateDead: <br>            m_viewnotify.OnShutdown (); <br>            return m_lsterr.HrSetLastError(ResultFromScode(E_UNEXPECTED)); <br> <br>        case stateUninit: <br>        case stateNormal: <br>        case stateNoScribble: <br>        case stateHandsOffFromSave: <br>        case stateHandsOffFromNormal: <br>            break; <br>    } <br>  <br>  <br>    hr = HrQuerySave(dwSaveOptions); <br>    if(HR_FAILED(hr)) <br>        return hr; <br>    // <br>    //  Save us from ourselfs by add-refing the object <br>    // <br> <br>    AddRef(); <br> <br>    // <br>    //  Release the view context <br>    // <br> <br>    if (m_pviewctx != NULL) <br>    { <br>        m_pviewctx-&gt;SetAdviseSink(NULL); <br>        m_pviewctx-&gt;Release(); <br>        m_pviewctx = NULL; <br>    } <br> <br>    // <br>    //  We need to notify anyone who has an advise on us that we are <br>    //  shutting down.  We want to do this in such a manner as to <br>    //  protect ourselves since we are referencing the data structure <br>    //  internally.  Thus the AddRef/Release pair. <br>    // <br> <br>    m_viewnotify.OnShutdown (); <br> <br>    // <br>    //  Release message objects if we have them <br>    // <br> <br>    if(g_FModalUp)   <br>        m_pviewctxOverride = NULL; <br> <br>    UlRelease(m_pmsg); <br>    m_pmsg = NULL; <br>     <br>    UlRelease(m_pmsgsite); <br>    m_pmsgsite = NULL; <br> <br>    UlRelease(m_pab); <br>    m_pab = NULL; <br> <br>    UlRelease(m_pses); <br>    m_pses = NULL; <br> <br> <br>    // <br>    //  Tell all objects to be closed and de-initialized, only IUnknown <br>    //          calls are legal after this. <br>    // <br> <br>    DeInitObjects(); <br> <br>    // <br>    //  We are now all done -- release our internal reference <br>    // <br> <br>    Release(); <br> <br>    return hrSuccess; <br>} <br>                    <br> <br>////    IMAPIForm::DoVerb <br>// <br> <br>STDMETHODIMP CBaseForm::DoVerb(LONG iVerb, LPMAPIVIEWCONTEXT pviewctx, <br>                               ULONG hwndParent, LPCRECT lprcPosRect) <br>{ <br>    HRESULT             hr; <br> <br>    // <br>    //  If a view context was passed in, then we need to get the <br>    //  status bits from this view context.  Also we are going to save <br>    //  the current view context and use this view context for the <br>    //  duration of the verb execution. <br>    // <br> <br>    if (pviewctx != NULL) <br>    { <br>        m_pviewctxOverride = pviewctx; <br>        pviewctx-&gt;GetViewStatus(&amp;m_ulViewStatus); <br>    } <br> <br>    // <br>    //   Execute the requested verb.  If we do not understand the verb <br>    //  or we do not support the verb then we return NO SUPPORT and let <br>    //  the viewer deal with this. <br>    // <br> <br>    switch (iVerb) <br>    { <br>     <br>    case EXCHIVERB_OPEN: <br>        hr = HrOpenForm((HWND) hwndParent, lprcPosRect, m_ulViewStatus); <br>        break; <br> <br>    case EXCHIVERB_REPLYTOSENDER: <br>        hr = HrReply(eREPLY, (HWND) hwndParent, lprcPosRect); <br>        if(HR_SUCCEEDED(hr)) <br>        { <br>            m_pviewctxOverride = NULL; <br>            ShutdownForm(SAVEOPTS_NOSAVE); <br>        } <br>        break; <br> <br>    case EXCHIVERB_FORWARD: <br>        hr = HrReply(eFORWARD, (HWND) hwndParent, lprcPosRect); <br>        if(HR_SUCCEEDED(hr)) <br>        { <br>            m_pviewctxOverride = NULL; <br>            ShutdownForm(SAVEOPTS_NOSAVE); <br>        } <br>        break; <br>     <br>    case EXCHIVERB_PRINT: <br>    case EXCHIVERB_REPLYTOALL: <br>    case EXCHIVERB_SAVEAS: <br>    case EXCHIVERB_REPLYTOFOLDER: <br>        //the viewer should not call us here  <br>        //(see Value in extensions section of smpfrm.cfg) <br>        Assert(FALSE); <br> <br>    default: <br>        hr = m_lsterr.HrSetLastError(ResultFromScode(MAPI_E_NO_SUPPORT)); <br>        break; <br>    } <br> <br>    // <br>    //  If we moved to a different view context, then switch back to <br>    //  the one we started with. <br>    // <br> <br>    m_pviewctxOverride = NULL; <br>     <br>    if(m_pviewctx != NULL) <br>    { <br>        m_ulViewStatus =0; <br>        m_pviewctx-&gt;GetViewStatus(&amp;m_ulViewStatus); <br>        ConfigWinMenu(); <br>    } <br>     <br>    return hr; <br>} <br> <br> <br>////    IMAPIForm::Advise <br>// <br> <br>STDMETHODIMP CBaseForm::Advise (IN IMAPIViewAdviseSink * pViewAdvise, <br>                                OUT ULONG FAR * pulConnection) <br>{ <br>    HRESULT     hr; <br> <br>    hr = m_viewnotify.Advise (pViewAdvise, pulConnection); <br>    if (FAILED(hr)) <br>    { <br>        hr = m_lsterr.HrSetLastError(hr); <br>    } <br>    return hr; <br>} <br> <br> <br>////    IMAPIForm::Unadvise <br>// <br> <br>STDMETHODIMP CBaseForm::Unadvise(ULONG ulConnection) <br>{ <br>    HRESULT     hr; <br>     <br>    hr = m_viewnotify.Unadvise(ulConnection); <br>    if (FAILED(hr)) <br>    { <br>        hr = m_lsterr.HrSetLastError(hr); <br>    } <br> <br>    return hr; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  IPersistMessage interface <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>////    IPersistMessage::GetClassID <br> <br>STDMETHODIMP CBaseForm::GetClassID(LPCLSID lpClassID) <br>{ <br>    *lpClassID = CLSID_IPM_NOTE_SAMPLE; <br>    return hrSuccess; <br>} <br> <br> <br>////  IPersistMessage::GetLastError <br>// <br>//  Description:  This routine is used to get back a string giving more <br>//              information about the last error in the form.  <br>// <br> <br>STDMETHODIMP CBaseForm::GetLastError(HRESULT hr, ULONG ulFlags, <br>                                     LPMAPIERROR FAR * lppMAPIError) <br>{ <br>    return m_lsterr.HrGetLastError(hr, ulFlags, lppMAPIError); <br>} <br> <br> <br>////    IPersistMessage::IsDirty <br>// <br> <br>STDMETHODIMP CBaseForm::IsDirty () <br>{ <br> <br>    if(m_fDirty) <br>        return ResultFromScode(S_OK); <br> <br>    if(NULL == m_hwndDialog) <br>    { <br>        m_fDirty = FALSE; <br>    } <br>    else if(m_eFormType == eformRead) <br>    { <br>        m_fDirty = (m_fRecipientsDirty || <br>                    Edit_GetModify(GetDlgItem(m_hwndDialog, ID_BODY))); <br>    } <br>    else <br>    { <br>        m_fDirty = (m_fRecipientsDirty || <br>                    Edit_GetModify(GetDlgItem(m_hwndDialog, ID_BODY)) || <br>                    Edit_GetModify(GetDlgItem(m_hwndDialog, ID_SUBJECT)) || <br>                    Edit_GetModify(GetDlgItem(m_hwndDialog, ID_TO)) || <br>                    Edit_GetModify(GetDlgItem(m_hwndDialog, ID_CC))); <br>    } <br> <br>    return ResultFromScode ((m_fDirty ? S_OK : S_FALSE)); <br>} <br> <br> <br>////  IPersistMessage::InitNew <br>// <br>//  Description: This function is called in the case of composing a new <br>//      message.  There is a small set of properties which are set by <br>//      the constructor of the message, however in general it can be <br>//      assumed the message is clean. <br>// <br> <br>STDMETHODIMP CBaseForm::InitNew(LPMAPIMESSAGESITE pmsgsite, LPMESSAGE pmsg) <br>{ <br>    // <br>    //  Ensure we are in a state where we can accept this call <br>    // <br> <br>    switch(m_state) <br>    { <br>    case stateUninit: <br>    case stateHandsOffFromSave: <br>    case stateHandsOffFromNormal: <br>        break; <br> <br>    default: <br>        return m_lsterr.HrSetLastError(ResultFromScode(E_UNEXPECTED)); <br>    } <br> <br>    // <br>    //  If we currently have a message site, then release it as we <br>    //  will no longer be using it. <br>    // <br>         <br>    UlRelease(m_pmsgsite); <br>    m_pmsgsite = NULL; <br>     <br>    // <br>    //  Save away the pointers to the message and message site <br>    // <br> <br>    m_pmsgsite = pmsgsite; <br>    pmsgsite-&gt;AddRef(); <br> <br>    m_ulSiteStatus = 0; <br>    m_pmsgsite-&gt;GetSiteStatus(&amp;m_ulSiteStatus); <br> <br>    m_pmsg = pmsg; <br>    pmsg-&gt;AddRef(); <br> <br>    // <br>    //  Make an assumption on the message flags and status <br>    // <br> <br>    m_ulMsgStatus = 0; <br>    m_ulMsgFlags = MSGFLAG_UNSENT; <br>     <br>    if(m_hwnd) <br>        DisplayMessage(); <br> <br>    // <br>    //  We succeeded in doing the InitNew so move to the normal state <br>    // <br> <br>    m_state = stateNormal; <br> <br>    // <br>    //  Tell everybody who cares that we just loaded a new message <br>    // <br> <br>    m_viewnotify.OnNewMessage(); <br>    return hrSuccess; <br> <br>} <br> <br>//// IPersistMessage::Load <br>// <br>//  Description:  This routine is called as part of loading an existing <br>//      message into the form. <br>// <br> <br>STDMETHODIMP CBaseForm::Load(LPMAPIMESSAGESITE pmsgsite, LPMESSAGE pmsg, <br>                             ULONG ulMsgStatus, ULONG ulMsgFlags) <br>{ <br>    // <br>    //  Ensure we are in a state where we can accept this call <br>    // <br> <br>    switch(m_state) <br>    { <br>    case stateUninit: <br>    case stateHandsOffFromSave: <br>    case stateHandsOffFromNormal: <br>        break; <br> <br>    default: <br>        return m_lsterr.HrSetLastError(ResultFromScode(E_UNEXPECTED)); <br>    } <br> <br>    // <br>    //  If we currently have a message site, then release it as we <br>    //  will no longer be using it. <br>    // <br>         <br>    UlRelease(m_pmsgsite); <br>    m_pmsgsite = NULL; <br> <br>    UlRelease(m_pmsg); <br>    m_pmsg = NULL; <br>     <br> <br>    HRESULT hr = HrGetMsgDataFromMsg(pmsg, ulMsgFlags); <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    // <br>    //  Save away the message and message site which are passed in. <br>    // <br> <br>    m_pmsg = pmsg; <br>    pmsg-&gt;AddRef(); <br> <br>    m_pmsgsite = pmsgsite; <br>    pmsgsite-&gt;AddRef(); <br> <br>    // <br>    //  Get the site status flags for disabling buttons &amp; menus <br>    // <br>    m_ulSiteStatus = 0; <br>    m_pmsgsite-&gt;GetSiteStatus(&amp;m_ulSiteStatus); <br> <br>    // <br>    //  Save away these properties <br>    // <br> <br>    m_ulMsgStatus = ulMsgStatus; <br>    m_ulMsgFlags = ulMsgFlags; <br> <br>    // <br>    //  Put us into the normal state <br>    // <br> <br>    m_state = stateNormal; <br> <br>     <br>    // <br>    //  if our form is up, display the message <br>    // <br>    if(m_hwnd) <br>        DisplayMessage(); <br>     <br>    // <br>    //  Tell everybody who cares that we just loaded a new message <br>    // <br> <br>    m_viewnotify.OnNewMessage(); <br>    return hrSuccess; <br> <br>err: <br>    return hr; <br>} <br> <br>////    IPersistMessage::Save <br>// <br>//  Description:   <br>//      This function will be called whenever a save operation of the <br>//      information into the form should be done.  We should only make  <br>//      modifications to the message in this function. <br>// <br> <br>STDMETHODIMP CBaseForm::Save(IN LPMESSAGE pmsg, IN ULONG fSameAsLoad) <br>{ <br>    HRESULT             hr; <br>     <br>    // <br>    //  Check that we are in a state where we are willing to accept <br>    //  this call.  Must have a message. <br>    // <br> <br>    switch( m_state ) <br>    { <br>    default: <br>        Assert(FALSE); <br>    case stateDead: <br>    case stateUninit: <br>    case stateNoScribble: <br>    case stateHandsOffFromSave: <br>    case stateHandsOffFromNormal: <br>        return m_lsterr.HrSetLastError(ResultFromScode(E_UNEXPECTED)); <br> <br>    case stateNormal: <br>        break; <br>    } <br>     <br>    if (fSameAsLoad) <br>    { <br>        // <br>        //  Its the same message interface as was loaded into us.  We can <br>        //      assume that the pmsg passed in is either NULL or an interface <br>        //      on the same object as the message we already have loaded <br>        // <br> <br>        hr = HrSaveInto(m_pmsg); <br>    } <br>    else <br>    { <br>        // <br>        //  We need to copy everything into the new message as we are going <br>        //      to clone ourselves into it. <br>        // <br> <br>        hr = m_pmsg-&gt;CopyTo(0, NULL, NULL, 0, NULL, &amp;IID_IMessage, pmsg, 0, NULL); <br>        if (FAILED(hr)) <br>        { <br>            m_lsterr.HrSetLastError(hr, m_pmsg); <br>            return hr; <br>        } <br>                             <br>        // <br>        //  Now make all of the incremental changes <br>        // <br> <br>        hr = HrSaveInto(pmsg); <br>    } <br>     <br>    if (FAILED(hr)) <br>    { <br>        return hr; <br>    } <br>     <br>    m_state = stateNoScribble; <br>    m_fSameAsLoaded = fSameAsLoad; <br>     <br>    return S_OK; <br>} <br> <br> <br>////    IPersistMessage::SaveCompleted <br>// <br>// <br> <br> <br>STDMETHODIMP CBaseForm::SaveCompleted(IN LPMESSAGE pmsg) <br>{ <br> <br>    switch( m_state ) <br>    { <br>    case stateHandsOffFromNormal: <br>    case stateHandsOffFromSave: <br>    case stateNoScribble: <br>        break; <br> <br>    default: <br>        return m_lsterr.HrSetLastError(ResultFromScode(E_UNEXPECTED)); <br>    } <br> <br>    if((stateHandsOffFromNormal == m_state ||  <br>        stateHandsOffFromSave == m_state)  &amp;&amp; NULL == pmsg) <br>    { <br>        DebugTrace("smpfrm: SaveCompleted called in handsOff state with pmsg==NULL\r\n"); <br>        return  m_lsterr.HrSetLastError(ResultFromScode(E_INVALIDARG)); <br>    } <br>     <br>    ULONG ulOldState = m_state; <br>    m_state = stateNormal;                         <br>        <br>    //state == NoScribble , pmsg == NULL <br>    if(NULL == pmsg) <br>    { <br>        if(m_fSameAsLoaded) <br>        { <br>            ClearDirty(); <br>            m_viewnotify.OnSaved(); <br>        } <br> <br>        return hrSuccess; <br>    } <br>     <br> <br>    //state == handsOffFromNormal, pmsg != NULL <br>    if(stateHandsOffFromNormal == ulOldState) <br>    { <br>        UlRelease(m_pmsg); <br>     <br>        m_pmsg = pmsg; <br>        pmsg-&gt;AddRef(); <br> <br>        return hrSuccess; <br>    }     <br> <br>    //state == handsOffFromSave || NoScribble, pmsg != NULL <br>    if(stateNoScribble == ulOldState) <br>    { <br>        UlRelease(m_pmsg); <br>        m_pmsg = pmsg; <br>        pmsg-&gt;AddRef(); <br>    } <br>     <br>    m_viewnotify.OnSaved(); <br>    ClearDirty(); <br>    <br>   return hrSuccess; <br>} <br> <br> <br>////  IPersistMessage::HandsOffMessage <br>// <br>//  Description: store, folder and message objects has to be released <br>//              in this method. <br>//  <br>// <br> <br>STDMETHODIMP CBaseForm::HandsOffMessage () <br>{ <br>     <br>    switch( m_state ) <br>    { <br>    case stateNormal: <br>    case stateNoScribble: <br>        break; <br> <br>    default: <br>        return m_lsterr.HrSetLastError(ResultFromScode(E_UNEXPECTED)); <br>    } <br> <br>    if(stateNormal == m_state) <br>        m_state = stateHandsOffFromNormal; <br>    else <br>        m_state = stateHandsOffFromSave; <br> <br>    // <br>    //  We must have a message <br>    // <br> <br>    Assert(m_pmsg != NULL); <br>    m_pmsg-&gt;Release(); <br>    m_pmsg = NULL; <br> <br> <br>    return hrSuccess; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  IMAPIFormAdviseSink interfaces <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br> <br> <br>////    IMAPIFormAdviseSink::OnChange <br>// <br>//  Description: called to notify about changes in viewctx status  <br> <br>STDMETHODIMP CBaseForm::OnChange(ULONG ulflag) <br>{ <br>    if(m_pviewctxOverride == NULL)  <br>    { <br>        m_ulViewStatus = ulflag; <br>        ConfigWinMenu(); <br>    } <br> <br>    return hrSuccess; <br>} <br> <br>////    CBaseForm::OnActivateNext <br>// <br>//  Description:  We only say that we will handle the next message if <br>//              it is the exact same message class as the current message. <br>//              If the next message has the same "unsentness" will reuse the  <br>//              current object, otherwise ask our ClassFactory for a new one. <br>// <br> <br>STDMETHODIMP CBaseForm::OnActivateNext(LPCSTR lpszMessageClass, ULONG ulMessageStatus, <br>                                        ULONG ulMessageFlags, <br>                                       LPPERSISTMESSAGE FAR * ppPersistMessage) <br>{ <br>    HRESULT hr; <br> <br>    *ppPersistMessage = NULL; <br> <br>    Assert(m_pval); <br>     <br>     <br>    if(PR_MESSAGE_CLASS == m_pval[irtClass].ulPropTag) <br>    { <br>        //the message class comparison has to be case insensitive <br>        if((lstrcmpi(m_pval[irtClass].Value.LPSZ, lpszMessageClass) != 0) &amp;&amp; <br>            lstrcmpi(FormClassName, lpszMessageClass) != 0) <br>        { <br>            return ResultFromScode(S_FALSE); <br>        } <br>    } <br>    else <br>    { <br>        if(lstrcmpi(FormClassName, lpszMessageClass) != 0) <br>        { <br>            return ResultFromScode(S_FALSE); <br>        } <br>    } <br> <br> <br>    if((m_ulMsgFlags &amp; MSGFLAG_UNSENT) == (ulMessageFlags &amp; MSGFLAG_UNSENT)) <br>        //tell the viewer to reuse our object <br>        return ResultFromScode(S_OK); <br> <br>     <br>    //Get a new object from our class factory <br>    hr = m_pClassFactory-&gt;CreateInstance(NULL, IID_IPersistMessage, (LPVOID FAR *)ppPersistMessage); <br>    if(hr) <br>        return ResultFromScode (S_FALSE); <br>    else <br>        return ResultFromScode(S_OK); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  Non-IMAPIinterface functions <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br> <br>///     CBaseForm::HrGetMsgDataFromMsg <br>// <br>//      fills in m_pval and m_padrlist (for unsent msgs only) <br>//      with the info from pmsg <br>HRESULT CBaseForm::HrGetMsgDataFromMsg(LPMESSAGE pmsg, ULONG ulMsgFlags) <br>{ <br>    Assert(pmsg); <br> <br>    FreePadrlist(m_padrlist); <br>    m_padrlist = NULL; <br> <br> <br>    ULONG   cValues = 0; <br>    MAPIFreeBuffer(m_pval); <br>    m_pval = NULL; <br> <br>    MAPIFreeBuffer(m_lpbConvIdx); <br>    m_lpbConvIdx = NULL; <br> <br>    HRESULT hr = pmsg-&gt;GetProps((LPSPropTagArray) &amp;tagaRead, 0, <br>                                    &amp;cValues, &amp;m_pval); <br>    if (HR_FAILED(hr)) <br>    { <br>        m_lsterr.HrSetLastError(hr, pmsg); <br>        goto err; <br>    } <br> <br>    if(PROP_TYPE(m_pval[irtBody].ulPropTag) == PT_ERROR  &amp;&amp; <br>       GetScode(m_pval[irtBody].Value.l) == MAPI_E_NOT_ENOUGH_MEMORY) <br>    { <br>        hr = HrStreamInMsgBody(pmsg, m_pval, &amp;m_pval[irtBody].Value.LPSZ, &amp;m_lsterr); <br>        if(hr) <br>        { <br>            goto err;    <br>        } <br>        else <br>        { <br>            m_pval[irtBody].ulPropTag = PR_BODY; <br>        } <br>    } <br>     <br>    Assert(cValues ==  cpropMsg); <br> <br>    if(PR_CONVERSATION_INDEX == m_pval[irtConvIdx].ulPropTag) <br>    { <br>        LPSPropValue pval = &amp;m_pval[irtConvIdx]; <br> <br>        m_cbConvIdx = pval-&gt;Value.bin.cb; <br>        if(MAPIAllocateBuffer(m_cbConvIdx, (LPVOID *)&amp;m_lpbConvIdx)) <br>        { <br>            m_lpbConvIdx = NULL; <br>            m_cbConvIdx = 0; <br>        } <br>        else <br>        { <br>            CopyMemory(m_lpbConvIdx, pval-&gt;Value.bin.lpb, m_cbConvIdx); <br>        } <br>    } <br>    else <br>    { <br>        m_lpbConvIdx = NULL; <br>        m_cbConvIdx = 0; <br>    } <br>     <br>    m_fConvTopicSet = (PR_CONVERSATION_TOPIC == m_pval[irtConvTopic].ulPropTag); <br>         <br>     <br>    if(ulMsgFlags &amp; MSGFLAG_UNSENT) <br>    { <br>        hr = GetMsgAdrlist (pmsg, &amp;m_padrlist, &amp;m_lsterr); <br>        if(HR_FAILED(hr)) <br>        { <br>            goto err; <br>        } <br>    } <br> <br>    return hrSuccess; <br> <br>err: <br>    MAPIFreeBuffer(m_pval); <br>    m_pval = NULL; <br> <br>    FreePadrlist(m_padrlist); <br>    m_padrlist = NULL; <br> <br>    return hr; <br> <br>} <br> <br>///         CBaseForm::ClearDirty <br>// <br>//      Clears dirty state <br>void CBaseForm::ClearDirty(void) <br>{ <br>    m_fDirty = FALSE; <br>    m_fRecipientsDirty = FALSE; <br> <br>    if(m_eFormType == eformSend) <br>    { <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_BODY), FALSE); <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_SUBJECT), FALSE); <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_TO), FALSE); <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_CC), FALSE); <br>    } <br>    else <br>    { <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_BODY), FALSE); <br>    } <br>} <br> <br>////    CBaseForm::Address <br>// <br>//  Description: <br>//      This function is used to address the form. <br>//      The parameter determines which button in the address <br>//      dialog has the focus. <br>// <br> <br>void CBaseForm::Address(int id) <br>{ <br>    Assert( ID_TO_BUTTON == id || ID_CC_BUTTON == id); <br> <br>    HRESULT hr; <br> <br>    if (m_pses == NULL) <br>    { <br>        hr = m_pmsgsite-&gt;GetSession(&amp;m_pses); <br>        if(hr) <br>        { <br>            m_lsterr.HrSetLastError(hr, m_pmsgsite); <br>            ShowError(); <br>            return; <br>        } <br>    } <br>     <br>    Assert(m_pses != NULL); <br> <br>    if (m_pab == NULL) <br>    { <br>        hr = m_pses-&gt;OpenAddressBook((ULONG) m_hwnd, NULL, 0, &amp;m_pab); <br>        if(hr) <br>        { <br>            m_lsterr.HrSetLastError(hr, m_pses); <br>            ShowError(); <br>        } <br>        if(HR_FAILED(hr)) //if it's a real error (not a warning) <br>            return;  <br>    } <br>     <br>    Assert(m_pab != NULL); <br> <br>     <br>    ADRPARM adrparm = { 0, NULL, AB_RESOLVE | DIALOG_MODAL, NULL, 0L, <br>                        NULL, NULL, NULL, NULL, "Address Book", NULL, <br>                        "Send Note To", 2, (id == ID_TO_BUTTON ? 0:1), <br>                        NULL, NULL, NULL, NULL }; <br>    ULONG   ulHwndAddr = (ULONG) m_hwnd; <br>     <br>    hr = m_pab-&gt;Address(&amp;ulHwndAddr, &amp;adrparm, &amp;m_padrlist); <br>    if (!hr) <br>    { <br>        m_fRecipientsDirty = TRUE; <br>        UpdateRecipientsDisplay(); <br>    } <br>    else if(GetScode(hr) != MAPI_E_USER_CANCEL) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pab); <br>        ShowError(); <br>    } <br>         <br>} <br> <br>////    CBaseForm::ClearWindow <br>// <br>//  Description: <br>//      This routine is called when the window for this form object is <br>//      destroyed.  We clear out pointer to the window and the windows <br>//      pointer to us. <br>// <br> <br>void CBaseForm::ClearWindow() <br>{ <br>    Assert(m_hwnd != NULL); <br> <br>    // <br>    //  Clear the back pointer to us and remove the reference count for it. <br>    // <br> <br>    SetWindowLong(m_hwnd, 0, 0); <br>    Release(); <br> <br>    // <br>    //  Clear out pointer to the window since it is now dead <br>    // <br> <br>    m_hwnd = NULL; <br>    m_hwndDialog = NULL; <br>} <br> <br>////  CBaseForm::HrOpenForm <br>// <br>//  Description:  This is the internal routine which is called from the <br>//      open/display verb.  It will cause UI to appear if there is none <br>//      and force the window to the foreground if there is already UI. <br>// <br> <br>HRESULT CBaseForm::HrOpenForm(HWND hwndParent, LPCRECT lprcPosRect, </code></pre>
<p>
</p>
<pre><code>ULONG ulViewFlags) <br>{ <br> <br>    if (lprcPosRect == NULL) <br>        return m_lsterr.HrSetLastError(ResultFromScode(E_INVALIDARG)); <br> <br>    // <br>    //  If any modal forms are visible then do not do anything  <br>    // <br> <br>    Assert( g_FModalUp &amp;&amp; g_hwndUp || !g_FModalUp &amp;&amp; !g_hwndUp); <br>    if (g_FMBoxUp || (g_FModalUp &amp;&amp; hwndParent != g_hwndUp)) <br>        return m_lsterr.HrSetLastError( <br>                               ResultFromScode(OLEOBJ_S_CANNOT_DOVERB_NOW)); <br>     <br>    if (!(ulViewFlags &amp; VCSTATUS_MODAL)) <br>    { <br>        //  If we are not modal then don't do anything relative to the parent <br>        hwndParent = NULL; <br>    } <br> <br>    // <br>    //  Check to see if we have a window up <br>    // <br> <br>    if (m_hwnd != 0) <br>    { <br>        MoveWindow(m_hwnd, lprcPosRect-&gt;left, lprcPosRect-&gt;top, <br>                   lprcPosRect-&gt;right - lprcPosRect-&gt;left, <br>                   lprcPosRect-&gt;bottom - lprcPosRect-&gt;top, <br>                   TRUE); <br>        SetForegroundWindow(m_hwnd); <br>         <br>        return S_OK; <br>    } <br>            <br>    m_hwnd = CreateWindow((m_ulMsgFlags &amp; MSGFLAG_UNSENT) ? <br>                          g_szSendWinClass : g_szReadWinClass, <br>                          g_szWindowCaption, WS_OVERLAPPEDWINDOW, <br>                          0, 0, 10, 10, hwndParent, NULL, g_hinst, NULL); <br> <br>    if (m_hwnd == NULL) <br>    { <br>        return m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>    } <br> <br>    // <br>    //  Put the pointer to this object into the window <br>    // <br> <br>    SetWindowLong(m_hwnd, 0, (long) (void FAR *) this); <br>    //we just created another pointer to ourself, so addref <br>    AddRef(); <br> <br>    // <br>    //  Create the dialog as a child of this window <br>    // <br> <br>    if (m_ulMsgFlags &amp; MSGFLAG_UNSENT) <br>    { <br>        m_eFormType = eformSend; <br>        m_hwndDialog = CreateDialog(g_hinst, MAKEINTRESOURCE(IDR_SEND_FORM), <br>                                    m_hwnd, &amp;FormDlgProcSend); <br>        m_HAccelTable = LoadAccelerators(g_hinst, MAKEINTRESOURCE(IDR_SEND_FORM)); <br>    } <br>    else <br>    { <br>        m_eFormType = eformRead; <br>        m_hwndDialog = CreateDialog(g_hinst, MAKEINTRESOURCE(IDR_READ_FORM), <br>                                    m_hwnd, &amp;FormDlgProcRead); <br>        m_HAccelTable = LoadAccelerators(g_hinst, MAKEINTRESOURCE(IDR_READ_FORM)); <br>    } <br>         <br> <br>    DisplayMessage(); <br> <br>    // <br>    //  Position the window where it is suppose to be <br>    // <br>                                    <br>    MoveWindow(m_hwnd, lprcPosRect-&gt;left, lprcPosRect-&gt;top, <br>        lprcPosRect-&gt;right - lprcPosRect-&gt;left, <br>        lprcPosRect-&gt;bottom - lprcPosRect-&gt;top, <br>        TRUE); <br> <br>    ShowWindow(m_hwnd, SW_SHOW); <br> <br>    SetForegroundWindow(m_hwnd); <br>                  <br>    // <br>    //  If we are modal, then we loop until the form is closed <br>    // <br> <br>    if (ulViewFlags &amp; VCSTATUS_MODAL) <br>    { <br>        MSG         msg; <br> <br>        BOOL fOldModalUp = g_FModalUp; <br>        HWND hwndOldUp = g_hwndUp; <br> <br>        g_FModalUp = TRUE; <br>        g_hwndUp = m_hwnd; <br> <br>        while ((m_hwnd != NULL) &amp;&amp; (GetMessage(&amp;msg, m_hwnd, 0, 0))) <br>        { <br>            //first call our method and see if this message makes sense to us. <br>            //if not, let WIN API care about it. <br>            if (!TranslateMessage(msg)) <br>            { <br>                ::TranslateMessage(&amp;msg); <br>                ::DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>        g_FModalUp = fOldModalUp; <br>        g_hwndUp = hwndOldUp; <br>    } <br> <br>    return hrSuccess; <br>} <br> <br>////    CBaseForm::HrSaveInto <br>// <br>//  Description: <br>//    This routine gives one central location which save all modified <br>//      properties into a message. <br>// <br> <br>HRESULT CBaseForm::HrSaveInto(LPMESSAGE pmsg) <br>{ <br>    ULONG               cval = 0; <br>    HRESULT             hr;                                     <br> <br>    // <br>    //  First, write out the recipient table <br>    // <br>     <br>    if(m_padrlist &amp;&amp; m_fRecipientsDirty) <br>    { <br>        hr = pmsg-&gt;ModifyRecipients(0, m_padrlist); <br>        if (FAILED(hr)) <br>        { <br>            m_lsterr.HrSetLastError(hr, pmsg); <br>            return hr; <br>        } <br>    } <br>    // <br>    //  Next set up and save the rest of the info <br>    // <br>       <br>    HrGetMsgDataFromUI(m_hwndDialog); <br> <br>    //PR_DISPLAY_TO AND PR_DISPLAY_CC can't be set <br>    ULONG ulToTag = m_pval[irtTo].ulPropTag; <br>    m_pval[irtTo].ulPropTag = PR_NULL; <br>     <br>    ULONG ulCcTag = m_pval[irtCc].ulPropTag; <br>    m_pval[irtCc].ulPropTag = PR_NULL; <br>     <br>    ULONG ulNormSubjectTag = m_pval[irtNormSubject].ulPropTag; <br>    m_pval[irtNormSubject].ulPropTag = PR_NULL; <br> <br>    m_pval[irtClass].ulPropTag = PR_MESSAGE_CLASS; <br>    m_pval[irtClass].Value.lpszA = FormClassName; <br> <br>    /* <br>     *If the message didn't have PR_CONVERSATION_TOPIC when we loaded it, we'll <br>     *  set it every time we save the message. Otherwise we don't touch it <br>     */ <br>    if(!m_fConvTopicSet) <br>    {    <br>        m_pval[irtConvTopic].ulPropTag = PR_CONVERSATION_TOPIC; <br>        if(PR_SUBJECT == m_pval[irtSubject].ulPropTag) <br>        { <br>            m_pval[irtConvTopic].Value.LPSZ = m_pval[irtSubject].Value.LPSZ; <br>        } <br>        else <br>        { <br>            m_pval[irtConvTopic].Value.LPSZ = ""; <br>        } <br>    } <br>    else <br>    { <br>        m_pval[irtConvTopic].ulPropTag = PR_NULL; <br>    } <br> <br>    /* <br>     * if the message doesn't have a PR_CONVERSATION_INDEX, create and set it <br>     * <br>     */ <br>    if(m_cbConvIdx == 0) <br>    { <br>        if(!ScAddConversationIndex(0, NULL, &amp;m_cbConvIdx,   &amp;m_lpbConvIdx)) <br>        { <br>            m_pval[irtConvIdx].ulPropTag = PR_CONVERSATION_INDEX; <br>            m_pval[irtConvIdx].Value.bin.lpb = m_lpbConvIdx; <br>            m_pval[irtConvIdx].Value.bin.cb = m_cbConvIdx; <br>        } <br>        else <br>        { <br>            m_pval[irtConvIdx].ulPropTag = PR_NULL; <br>        } <br>    } <br>    else <br>    { <br>        m_pval[irtConvIdx].ulPropTag = PR_NULL; <br>    } <br> <br>    LPSPropProblemArray pProblems = NULL; <br> <br>    hr = pmsg-&gt;SetProps(cpropMsg, m_pval, &amp;pProblems); <br>    if (hr) <br>    { <br>        m_lsterr.HrSetLastError(hr, pmsg); <br>        goto err; <br>    } <br>     <br>    if(pProblems) <br>    { <br>        for(UINT ind = 0; ind &lt; pProblems-&gt;cProblem; ++ind) <br>        {  <br>            if(PR_BODY == pProblems-&gt;aProblem[ind].ulPropTag &amp;&amp; <br>               MAPI_E_NOT_ENOUGH_MEMORY == pProblems-&gt;aProblem[ind].scode) <br>            { <br>                hr = HrStreamOutMsgBody(pmsg, m_pval[irtBody].Value.LPSZ, &amp;m_lsterr); <br>                if(hr) <br>                { <br>                    MAPIFreeBuffer(pProblems); <br>                    pProblems = NULL; <br>                    goto err; <br>                } <br>                break; <br>            } <br>        } <br> <br>        MAPIFreeBuffer(pProblems); <br>        pProblems = NULL; <br>    } <br> <br>err: <br>    m_pval[irtTo].ulPropTag = ulToTag; <br>    m_pval[irtCc].ulPropTag = ulCcTag; <br>    m_pval[irtNormSubject].ulPropTag = ulNormSubjectTag; <br>     <br>    return hr; <br>} <br> <br> <br>BOOL CBaseForm::TranslateMessage(MSG&amp; msg) <br>{ <br>    // <br>    //  We translate accelerators before the dialog message so that we <br>    //  can get our accelerators to override the dialog's. <br>    // <br> <br>    if(msg.hwnd == m_hwnd || IsChild(m_hwnd, msg.hwnd)) <br>    { <br>        if (::TranslateAccelerator(m_hwnd, m_HAccelTable, &amp;msg)) <br>        { <br>            return TRUE; <br>        } <br>    } <br>     <br>    if ((m_hwndDialog != NULL) &amp;&amp; ::IsDialogMessage(m_hwndDialog, &amp;msg)) <br>    { <br>        return TRUE; <br>    } <br>     <br>    return FALSE; <br>} <br> <br>///  CBaseForm::UpdateRecipientsDisplay <br>//  go through m_padrlist and display TO and CC recipients in the  <br>//  edit boxes. <br>// Called only for send form. The Read form can use PR_DISPLAY_* <br>void CBaseForm::UpdateRecipientsDisplay(void) <br>{ <br>    Assert(m_hwndDialog); <br>     <br>    Assert(m_eFormType == eformSend); <br> <br>    HWND hwTo = GetDlgItem(m_hwndDialog, ID_TO); <br>    HWND hwCC = GetDlgItem(m_hwndDialog, ID_CC); <br>     <br>    Edit_SetText(hwTo, ""); <br>    Edit_SetText(hwCC, ""); <br>     <br>    if(m_padrlist == NULL || m_padrlist-&gt;cEntries == 0) return; <br> <br>    #define ADRTEXTLEN  512 <br>    char szTo [ADRTEXTLEN] = ""; <br>    char szCC [ADRTEXTLEN] = ""; <br>     <br>    BOOL fToFull = FALSE; <br>    BOOL fCCFull = FALSE; <br> <br>     <br>    LPADRENTRY pae; <br>    for(pae = m_padrlist-&gt;aEntries; <br>        pae &lt; m_padrlist-&gt;aEntries + m_padrlist-&gt;cEntries; <br>        ++pae) <br>    { <br>        if( NULL == pae-&gt;rgPropVals) continue; <br> <br>        LPSPropValue lpsprop; <br>        LPSTR szDisplay = NULL; <br>        LPSTR szName = NULL; <br>        BOOL * pfFull = NULL; <br>        for(lpsprop = pae-&gt;rgPropVals; <br>            lpsprop &lt; pae-&gt;rgPropVals + pae-&gt;cValues; <br>            ++lpsprop) <br>        { <br>            if(lpsprop-&gt;ulPropTag == PR_RECIPIENT_TYPE) <br>            { <br>                if(lpsprop-&gt;Value.l == MAPI_TO) <br>                { <br>                    szDisplay = szTo; <br>                    pfFull = &amp;fToFull; <br>                } <br>                else if(lpsprop-&gt;Value.l == MAPI_CC) <br>                { <br>                    szDisplay = szCC; <br>                    pfFull = &amp;fCCFull; <br>                } <br>            } <br>            else if(lpsprop-&gt;ulPropTag == PR_DISPLAY_NAME) <br>            { <br>                szName = lpsprop-&gt;Value.LPSZ; <br>            } <br>             <br>            if(NULL != szName &amp;&amp; NULL != szDisplay) <br>            { <br>                Assert(pfFull); <br> <br>                if(*pfFull) break; <br> <br>                if(lstrlen(szDisplay) + lstrlen(szName) + 7 &lt; ADRTEXTLEN) <br>                { <br>                    lstrcat(szDisplay, szName); <br>                    lstrcat(szDisplay, "; "); <br>                } <br>                else <br>                { <br>                    lstrcat(szDisplay, "..."); <br>                    *pfFull = TRUE; <br>                } <br> <br>                break; <br>            } <br>        } <br>    } <br> <br>    //get rid of the "; " after the last recipient <br>    if(lstrlen(szTo) &gt; 0  &amp;&amp;  !fToFull)  <br>        szTo[lstrlen(szTo)-2] = 0; <br>    if(lstrlen(szCC) &gt; 0  &amp;&amp;  !fCCFull)  <br>        szCC[lstrlen(szCC)-2] = 0; <br> <br>    Edit_SetText(hwTo, szTo); <br>    Edit_SetText(hwCC, szCC); <br> <br>} <br> <br> <br>///  CBaseForm::DisplayMessage <br>// <br>//  display the info from m_pval in the dialog <br>void CBaseForm::DisplayMessage(void) <br>{ <br>    char    sz[256]; <br> <br>    Assert(m_hwnd); <br>    Assert(m_hwndDialog); <br> <br>    if(NULL == m_pval) return; <br> <br>    if (m_pval[irtSubject].ulPropTag == PR_SUBJECT) <br>    { <br>        SetDlgItemText(m_hwndDialog, ID_SUBJECT, m_pval[irtSubject].Value.LPSZ); <br>        lstrcpyn(sz, m_pval[irtSubject].Value.LPSZ, 200); <br>        sz[200] = 0; <br>        lstrcat(sz, " - "); <br>        lstrcat(sz, g_szWindowCaption); <br>        SetWindowText(m_hwnd, sz); <br>    } <br>    else <br>    { <br>        SetWindowText(m_hwnd, g_szWindowCaption); <br>    } <br> <br>    if (m_pval[irtBody].ulPropTag == PR_BODY) <br>        SetDlgItemText(m_hwndDialog, ID_BODY, m_pval[irtBody].Value.LPSZ); <br> <br>    if(m_eFormType == eformRead) <br>    { <br>        if (m_pval[irtFrom].ulPropTag == PR_SENDER_NAME) <br>        SetDlgItemText(m_hwndDialog, ID_FROM, m_pval[irtFrom].Value.LPSZ); <br> <br>        if (m_pval[irtTime].ulPropTag == PR_CLIENT_SUBMIT_TIME) { <br>            FormatTime(&amp;m_pval[irtTime].Value.ft, sz); <br>            SetDlgItemText(m_hwndDialog, ID_SENT, sz); <br>        } <br> <br>        if (m_pval[irtTo].ulPropTag == PR_DISPLAY_TO) <br>            SetDlgItemText(m_hwndDialog, ID_TO, m_pval[irtTo].Value.LPSZ); <br> <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_BODY), FALSE); <br>    } <br>    else if (m_eFormType == eformSend) <br>    { <br>        UpdateRecipientsDisplay(); <br> <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_BODY), FALSE); <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_SUBJECT), FALSE); <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_TO), FALSE); <br>        Edit_SetModify(GetDlgItem(m_hwndDialog, ID_CC), FALSE); <br>    } <br>    else <br>    { <br>        Assert(FALSE); <br>    } <br>   <br>} <br> <br> <br>/// CBaseForm::HrGetMsgDataFromUI <br>// <br>// save the  message info from the dialog into the m_pval <br>HRESULT CBaseForm::HrGetMsgDataFromUI(HWND hDlg) <br>{ <br> <br>    LONG cb = 0; <br>    HRESULT hr = hrSuccess; <br> <br> <br>    //have to call IsDirty() to make sure  m_fDirty is current <br>    if(!m_fDirty) <br>        IsDirty(); <br>     <br>    if(m_eFormType == eformRead) <br>    { <br>        Assert(m_pval); <br> <br>        if(!m_fDirty) <br>            return hrSuccess; <br> <br>        //everything is read-only except for the body <br>        cb = GetWindowTextLength(GetDlgItem(hDlg, ID_BODY)); <br>        if(m_pval[irtBody].ulPropTag == PR_BODY &amp;&amp; <br>         cb &lt;= lstrlen(m_pval[irtBody].Value.LPSZ)) <br>        { <br>            GetWindowText(GetDlgItem(hDlg, ID_BODY), m_pval[irtBody].Value.LPSZ, cb+1); <br>        } <br>        else <br>        { <br>            if(hr = MAPIAllocateMore(cb+1, m_pval, (LPVOID FAR *)&amp;m_pval[irtBody].Value.LPSZ)) <br>            { <br>                return m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>            } <br> <br>            GetWindowText(GetDlgItem(hDlg, ID_BODY), m_pval[irtBody].Value.LPSZ, cb+1); <br>        } <br> <br>        m_pval[irtBody].ulPropTag = PR_BODY; <br>    } <br>    else if (m_eFormType == eformSend) <br>    { <br>        if(!m_fDirty &amp;&amp; m_pval != NULL)  <br>            return hrSuccess; <br> <br>        if(NULL != m_pval) <br>        { <br>            MAPIFreeBuffer(m_pval); <br>            m_pval = NULL; <br>        } <br>        if(MAPIAllocateBuffer(sizeof(SPropValue)* cpropMsg, (LPVOID FAR *) &amp;m_pval)) <br>        { <br>            return m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>        } <br>         <br>        ZeroMemory(m_pval, sizeof(SPropValue)* cpropMsg); <br>         <br>         <br>        m_pval[irtTime].ulPropTag = PR_NULL; <br>        m_pval[irtFrom].ulPropTag = PR_NULL;                      <br> <br>        cb = GetWindowTextLength(GetDlgItem(hDlg, ID_SUBJECT)) + 1; <br>        /*if(cb &gt; 0) <br>        {*/ <br>            if(MAPIAllocateMore(cb+1, m_pval, (LPVOID FAR *)&amp;m_pval[irtSubject].Value.LPSZ)) <br>            { <br>                return m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>            } <br> <br>            cb = GetWindowText(GetDlgItem(hDlg, ID_SUBJECT), m_pval[irtSubject].Value.LPSZ, cb+1); <br>            m_pval[irtSubject].ulPropTag = PR_SUBJECT; <br>        /*} <br>        else <br>        { //no subject <br>     <br>            m_pval[irtSubject].ulPropTag = PR_NULL; <br>        } */ <br>     <br>        cb = GetWindowTextLength(GetDlgItem(hDlg, ID_BODY)) +1 ; <br>        /*if(cb &gt; 0) <br>        { */ <br>            if(MAPIAllocateMore(cb+1, m_pval, (LPVOID FAR *)&amp;m_pval[irtBody].Value.LPSZ)) <br>            { <br>                return m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>            } <br> <br>            cb = GetWindowText(GetDlgItem(hDlg, ID_BODY), m_pval[irtBody].Value.LPSZ, cb+1); <br>            m_pval[irtBody].ulPropTag = PR_BODY; <br>        /*} <br>        else <br>        { //no body <br>     <br>            m_pval[irtBody].ulPropTag = PR_NULL; <br>        } */ <br>     <br>        cb = GetWindowTextLength(GetDlgItem(hDlg, ID_TO)); <br>        if(cb &gt; 0) <br>        { <br>            if(hr = MAPIAllocateMore(cb+1, m_pval, (LPVOID FAR *)&amp;m_pval[irtTo].Value.LPSZ)) <br>            { <br>                return m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>            } <br> <br>            GetWindowText(GetDlgItem(hDlg, ID_TO), m_pval[irtTo].Value.LPSZ, cb+1); <br>            m_pval[irtTo].ulPropTag = PR_DISPLAY_TO; <br>        } <br>        else <br>        { //no to <br>     <br>            m_pval[irtTo].ulPropTag = PR_NULL; <br>        } <br>         <br>        cb = GetWindowTextLength(GetDlgItem(hDlg, ID_CC)); <br>        if(cb &gt; 0) <br>        { <br>            if(hr = MAPIAllocateMore(cb+1, m_pval, (LPVOID FAR *)&amp;m_pval[irtCc].Value.LPSZ)) <br>            { <br>                return m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>            } <br> <br>            GetWindowText(GetDlgItem(hDlg, ID_CC), m_pval[irtCc].Value.LPSZ, cb+1); <br>            m_pval[irtTo].ulPropTag = PR_DISPLAY_CC; <br>        } <br>        else <br>        { //no cc <br>     <br>            m_pval[irtCc].ulPropTag = PR_NULL; <br>        } <br>    }    <br>    else <br>    { <br>        Assert(FALSE); <br>    } <br>    return hr; <br>} <br> <br>/// CBaseForm::IsAddressed <br>// <br>//Does m_padrlist contain a recipient? <br>BOOL CBaseForm::IsAddressed(void) <br>{ <br>    Assert(m_eFormType == eformSend) ; <br>         <br>    if(NULL == m_padrlist || m_padrlist-&gt;cEntries == 0) <br>        return FALSE; <br>     <br>    for(LPADRENTRY pae = m_padrlist-&gt;aEntries; <br>        pae &lt; m_padrlist-&gt;aEntries + m_padrlist-&gt;cEntries; ++pae) <br>    { <br>        if(pae-&gt;rgPropVals) <br>            return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br>///     CBaseForm::ConfigMenu <br>//Enable/disable menu commands based on the values of m_ulSiteStatus <br>// and m_ulViewStatus <br>void CBaseForm::ConfigMenu(HMENU hMenu) <br>{ <br>    if(m_eFormType == eformRead) <br>    { <br>        EnableMenuItem(hMenu, IDC_MESSAGE_SAVE, <br>            MF_BYCOMMAND|((m_ulSiteStatus &amp; VCSTATUS_SAVE)? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_MESSAGE_DELETE, <br>            MF_BYCOMMAND| (!(m_ulViewStatus &amp; VCSTATUS_READONLY) &amp;&amp; <br>                            (m_ulSiteStatus &amp; VCSTATUS_DELETE) ? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_MESSAGE_COPY, <br>            MF_BYCOMMAND| (!(m_ulViewStatus &amp; VCSTATUS_READONLY) &amp;&amp; <br>                            (m_ulSiteStatus &amp; VCSTATUS_COPY) ? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_MESSAGE_MOVE, <br>            MF_BYCOMMAND| (!(m_ulViewStatus &amp; VCSTATUS_READONLY) &amp;&amp; <br>                            (m_ulSiteStatus &amp; VCSTATUS_MOVE) ? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_VIEW_ITEMABOVE, <br>            MF_BYCOMMAND|(m_ulViewStatus &amp; VCSTATUS_PREV ? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_VIEW_ITEMBELOW, <br>            MF_BYCOMMAND|(m_ulViewStatus &amp; VCSTATUS_NEXT ? MF_ENABLED:MF_GRAYED)); <br>    } <br> <br>    else <br>    { <br>        EnableMenuItem(hMenu, IDC_MESSAGE_SUBMIT, <br>            MF_BYCOMMAND|((m_ulSiteStatus &amp;VCSTATUS_SUBMIT) ? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_MESSAGE_SAVE, <br>            MF_BYCOMMAND|((m_ulSiteStatus &amp; VCSTATUS_SAVE)? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_MESSAGE_DELETE, <br>            MF_BYCOMMAND| (!(m_ulViewStatus &amp; VCSTATUS_READONLY) &amp;&amp; <br>                            (m_ulSiteStatus &amp; VCSTATUS_DELETE) ? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_MESSAGE_COPY, <br>            MF_BYCOMMAND| (!(m_ulViewStatus &amp; VCSTATUS_READONLY) &amp;&amp; <br>                            (m_ulSiteStatus &amp; VCSTATUS_COPY) ? MF_ENABLED:MF_GRAYED)); <br>        EnableMenuItem(hMenu, IDC_MESSAGE_MOVE, <br>            MF_BYCOMMAND| (!(m_ulViewStatus &amp; VCSTATUS_READONLY) &amp;&amp; <br>                            (m_ulSiteStatus &amp; VCSTATUS_MOVE) ? MF_ENABLED:MF_GRAYED)); <br>                             <br>    } <br>} <br>         <br>///CBaseForm::HrReply <br>// <br>// <br>HRESULT CBaseForm::HrReply(eREPLYTYPE eReplyType, HWND hwndParent, LPCRECT prect) <br>{ <br>     <br>    //reply all is not implemented <br>    Assert(eREPLY == eReplyType || eFORWARD == eReplyType); <br>     <br>    HRESULT hr; <br>    LONG cb; <br>     <br>    char * szBody = NULL; <br>    char * szSubject = NULL; <br>    SPropValue val[3] = {0}; <br>     <br>    enum { eName, eAddrType, eEID, eRecipType, eDim}; <br>    SizedSPropTagArray(eDim, sptSender) =  <br>        {eDim, {PR_SENDER_NAME, PR_SENDER_ADDRTYPE, <br>                PR_SENDER_ENTRYID, PR_NULL}}; <br> <br>    LPSPropProblemArray pProblems = NULL; <br>    LPMAPIFORM          pfrmReply = NULL; <br>    LPPERSISTMESSAGE    ppermsg = NULL; <br>    LPMAPIMESSAGESITE   pmsgsite = NULL; <br>    LPMAPIVIEWCONTEXT   pviewctx = NULL; <br>    LPMESSAGE           pmsg = NULL; <br>    ULONG cbNewConvIdx = 0; <br>    LPBYTE lpbNewConvIdx = NULL; <br>     <br>    Assert(m_pmsg); <br>     <br> <br>    hr = m_pClassFactory-&gt;CreateInstance(NULL, IID_IMAPIForm, (LPVOID FAR *) &amp;pfrmReply); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>        goto err; <br>    } <br>      <br>    hr = pfrmReply-&gt;QueryInterface(IID_IPersistMessage, (LPVOID *) &amp;ppermsg); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(hr, pfrmReply); <br>        goto err; <br>    } <br>                                     <br>    hr = m_pmsgsite-&gt;NewMessage(FALSE, NULL, ppermsg, &amp;pmsg, &amp;pmsgsite, &amp;pviewctx); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pmsgsite); <br>        goto err; <br>    } <br>     <br>    hr = m_pmsg-&gt;CopyTo(0, NULL, (LPSPropTagArray)&amp;sptExcludedProps, <br>                        0, NULL, &amp;IID_IMessage, pmsg, 0, &amp;pProblems); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pmsg); <br>        goto err; <br>    } <br>     <br>    if(pProblems) <br>    { <br>        DebugTraceProblems("SmplForm: CopyTo returned ...", pProblems); <br>        //  if any of the errors is other than MAPI_E_COMPUTED, fail <br>        for(UINT ind = 0; ind &lt; pProblems-&gt;cProblem; ++ind) <br>        {  <br>            if(MAPI_E_COMPUTED != pProblems-&gt;aProblem[ind].scode) <br>            { <br>                hr = m_lsterr.HrSetLastError( <br>                            ResultFromScode(pProblems-&gt;aProblem[ind].scode)); <br>                MAPIFreeBuffer(pProblems); <br>                pProblems = NULL; <br>                goto err; <br>                 <br>            } <br>        } <br>        MAPIFreeBuffer(pProblems); <br>        pProblems = NULL; <br>    } <br> <br>    if(m_pval &amp;&amp; m_pval[irtNormSubject].ulPropTag == PR_NORMALIZED_SUBJECT) <br>        cb = lstrlen(m_pval[irtNormSubject].Value.LPSZ); <br>    else <br>        cb = 0; <br>     <br>    if(hr = MAPIAllocateBuffer(cb+lstrlen(szRE_PREFIX)+1, (LPVOID FAR *) &amp;szSubject)) <br>    { <br>        m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>        goto err; <br>    } <br>     <br> <br>    *szSubject = '\0'; <br>     <br>    if(eREPLY == eReplyType) <br>    { <br>        lstrcat(szSubject, szRE_PREFIX); <br>    } <br>    else <br>    { <br>        lstrcat(szSubject, szFW_PREFIX); <br>    }  <br> <br>    if(cb &gt; 0) <br>    { <br>        lstrcat(szSubject, m_pval[irtNormSubject].Value.LPSZ); <br>    } <br> <br>    val[1].Value.lpszA = szSubject; <br>    val[1].ulPropTag = PR_SUBJECT; <br>     <br>    HrSaveToString(&amp;szBody); <br>    if(szBody) <br>    { <br>        val[0].Value.LPSZ = szBody; <br>        val[0].ulPropTag = PR_BODY; <br>    } <br>    else <br>        val[0].ulPropTag = PR_NULL; <br> <br>     <br>    /* <br>     * Create a conversation index for the reply msg based on that of ours <br>     * <br>     */ <br>    if(!ScAddConversationIndex(m_cbConvIdx, m_lpbConvIdx, <br>                                &amp;cbNewConvIdx, &amp;lpbNewConvIdx)) <br>    { <br>        val[2].ulPropTag = PR_CONVERSATION_INDEX; <br>        val[2].Value.bin.cb = cbNewConvIdx; <br>        val[2].Value.bin.lpb = lpbNewConvIdx; <br>    } <br>    else <br>    { <br>        val[2].ulPropTag = PR_NULL; <br>    } <br> <br>    hr = pmsg-&gt;SetProps(3, val, &amp;pProblems); <br>    MAPIFreeBuffer(lpbNewConvIdx); <br>    lpbNewConvIdx = NULL; <br> <br>    MAPIFreeBuffer(szSubject); <br>    szSubject = NULL; <br>     <br>    if(!hr) <br>    { <br>        if(pProblems) <br>        { <br>            for(UINT ind = 0; ind &lt; pProblems-&gt;cProblem; ++ind) <br>            {  <br>                if(PR_BODY == pProblems-&gt;aProblem[ind].ulPropTag &amp;&amp; <br>                   MAPI_E_NOT_ENOUGH_MEMORY == pProblems-&gt;aProblem[ind].scode) <br>                { <br>                    hr = HrStreamOutMsgBody(pmsg, szBody, &amp;m_lsterr); <br>                    if(hr) <br>                    { <br>                        MAPIFreeBuffer(pProblems); <br>                        pProblems = NULL; <br>                        goto err; <br>                    } <br>                    break; <br>                } <br>            } <br>            MAPIFreeBuffer(pProblems); <br>            pProblems = NULL; <br>        } <br>    } <br>    else <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pmsg); <br>        goto err; <br>    } <br> <br>    // if it's a reply, set the addressee <br>    if(eREPLY == eReplyType) <br>    {                <br>        LPADRLIST pal = NULL; <br>        ULONG cVal = 0; <br>        LPSPropValue pval = NULL; <br> <br>        hr = MAPIAllocateBuffer(CbNewADRLIST(1), (LPVOID FAR *)&amp;pal); <br>        if(hr) <br>        { <br>            m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>            goto err; <br>        } <br>        hr = m_pmsg-&gt;GetProps((LPSPropTagArray) &amp;sptSender, 0, &amp;cVal, &amp;pval); <br>        if(hr) //treat warnings as an error, 'cause the props we ask for are required <br>        { <br>            m_lsterr.HrSetLastError(hr, m_pmsg); <br>            MAPIFreeBuffer(pal); <br>            goto err; <br>        } <br>         <br>        Assert(cVal == eDim); <br> <br>        pval[eRecipType].ulPropTag = PR_RECIPIENT_TYPE; <br>        pval[eRecipType].Value.l = MAPI_TO; <br> <br>        Assert(pval[eName].ulPropTag == PR_SENDER_NAME); <br>        pval[eName].ulPropTag = PR_DISPLAY_NAME; <br> <br>        Assert(pval[eAddrType].ulPropTag == PR_SENDER_ADDRTYPE); <br>        pval[eAddrType].ulPropTag = PR_ADDRTYPE; <br> <br>        Assert(pval[eEID].ulPropTag == PR_SENDER_ENTRYID); <br>        pval[eEID].ulPropTag = PR_ENTRYID; <br>         <br>        pal-&gt;aEntries[0].rgPropVals = pval; <br>         <br>        pal-&gt;cEntries = 1; <br>        pal-&gt;aEntries[0].cValues = eDim; <br>         <br>        hr = pmsg-&gt;ModifyRecipients(0, pal); <br>        FreePadrlist(pal); //this will also free pval <br>        pal = NULL; <br>        pval = NULL; <br>        if(hr) <br>        { <br>            m_lsterr.HrSetLastError(hr, pmsg); <br>            goto err; <br>        } <br>    } <br> <br>    hr = ppermsg-&gt;Load(pmsgsite, pmsg, 0, MSGFLAG_UNSENT ); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(hr, ppermsg); <br>        goto err; <br>    } <br> <br>    hr = pfrmReply-&gt;DoVerb(EXCHIVERB_OPEN, pviewctx, (ULONG)hwndParent, prect); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(hr, pfrmReply); <br>        pfrmReply-&gt;ShutdownForm(SAVEOPTS_NOSAVE); <br>        goto err; <br>    } <br> <br>err: <br>     <br>    UlRelease(pfrmReply); <br>    UlRelease(ppermsg); <br>    UlRelease(pmsgsite); <br>    UlRelease(pviewctx); <br>    UlRelease(pmsg); <br>    delete [] szBody; <br>     <br>    return hr; <br>} <br> <br>///     CBaseForm::HrSaveToString <br>//       <br>//  The returned string has to be freed using delete <br>HRESULT CBaseForm::HrSaveToString(LPSTR * pszMessage) <br>{ <br>    Assert(m_pval); <br>    Assert(pszMessage); <br> <br>    ostrstream  ostrBody; <br>    char *szMsg = NULL; <br> <br>    ostrBody &lt;&lt; "\r\n-----------------------------"; <br>    ostrBody &lt;&lt; "\r\nFrom:\t"; <br>    if(m_pval[irtFrom].ulPropTag == PR_SENDER_NAME) <br>    { <br>        ostrBody &lt;&lt; m_pval[irtFrom].Value.LPSZ; <br>    } <br>    else <br>    { <br>        ostrBody &lt;&lt; "Unknown"; <br>    } <br> <br>    if(m_pval[irtTime].ulPropTag == PR_CLIENT_SUBMIT_TIME) <br>    { <br>        char sz[30]; <br>        FormatTime(&amp;m_pval[irtTime].Value.ft, sz); <br>        ostrBody &lt;&lt; "\r\nSent:\t"; <br>        ostrBody &lt;&lt; sz; <br>    } <br>     <br>    if(m_pval[irtTo].ulPropTag == PR_DISPLAY_TO) <br>    { <br>        ostrBody &lt;&lt; "\r\nTo:\t"; <br>        ostrBody &lt;&lt;  m_pval[irtTo].Value.LPSZ; <br>    } <br> <br>    if(m_pval[irtSubject].ulPropTag == PR_SUBJECT) <br>    { <br>        ostrBody &lt;&lt; "\r\nSubject:\t"; <br>        ostrBody &lt;&lt; m_pval[irtSubject].Value.LPSZ; <br>    } <br> <br>    ostrBody &lt;&lt; "\r\n"; <br>    if(m_pval &amp;&amp; m_pval[irtBody].ulPropTag == PR_BODY) <br>        ostrBody &lt;&lt; m_pval[irtBody].Value.LPSZ; <br>         <br>    ostrBody &lt;&lt; ends; <br>     <br>    szMsg = ostrBody.str(); <br> <br>    if(szMsg != NULL) <br>    { <br>        *pszMessage = szMsg; <br>        return hrSuccess; <br>    } <br>    else <br>    { <br>        *pszMessage = NULL; <br>        return m_lsterr.HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>    } <br>} <br> <br>///     CBaseForm::HrQuerySave  <br>// <br>// <br>HRESULT CBaseForm::HrQuerySave (DWORD ulSaveOptions) <br>{ <br>    HRESULT             hr = hrSuccess; <br>    UINT                ui; <br> <br>    // <br>    // Check to see if we are marked as dirty.  If we are clean then <br>    //  we can just return without doing any work <br>    // <br> <br>    if(GetScode(IsDirty()) != S_OK) <br>        return hrSuccess; <br> <br>    switch( ulSaveOptions ) <br>    { <br>    default: <br>        Assert(FALSE); <br> <br>    case SAVEOPTS_SAVEIFDIRTY: <br>        break; <br> <br>    case SAVEOPTS_NOSAVE: <br>        return hrSuccess; <br> <br>    case SAVEOPTS_PROMPTSAVE: <br>        ui = ShowMessageBox (m_hwnd, "Would you like to save changes?", <br>                           g_szFormName, MB_ICONEXCLAMATION | MB_YESNOCANCEL); <br>        switch (ui) <br>        { <br>        case IDYES: <br>            break; <br> <br>        default: <br>            Assert(FALSE); <br>        case IDNO: <br>            return hrSuccess; <br>         <br>        case IDCANCEL: <br>            return MAPI_E_USER_CANCEL; <br> <br>        } <br>    } <br> <br>    hr = m_pmsgsite-&gt;SaveMessage(); <br>    if(hr) <br>        m_lsterr.HrSetLastError(hr, m_pmsgsite); <br> <br>    return hr; <br>} <br> <br>///  CBaseForm::DoDelete <br>// <br>//  called only from our UI <br>void CBaseForm::DoDelete(void) <br>{ <br>    HRESULT hr; <br>    RECT rect; <br> <br>    GetWindowRect(m_hwnd, &amp;rect); <br>     <br>    hr = m_pmsgsite-&gt;DeleteMessage(m_pviewctx, &amp;rect); <br>    if(HR_FAILED(hr)) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pmsgsite); <br>        ShowError(); <br>    } <br>    if(NULL == m_pmsg) <br>    { <br>        ShutdownForm(SAVEOPTS_NOSAVE); <br>    } <br>} <br> <br>///  CBaseForm::DoSave <br>// <br>//  called only from our UI <br>void CBaseForm::DoSave(void) <br>{ <br>    HRESULT hr; <br> <br>    hr = m_pmsgsite-&gt;SaveMessage(); <br>    if (FAILED(hr)) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pmsgsite); </code></pre>
<p>
</p>
<pre><code>ShowError(); <br>    } <br>} <br>             <br>///  CBaseForm::DoSubmit <br>// <br>//  called only from our UI <br>void CBaseForm::DoSubmit(void) <br>{ <br>    HRESULT hr; <br> <br>    if(!IsAddressed()) <br>    { <br>        ShowMessageBox(m_hwndDialog, "No recipients", g_szFormName, MB_OK); <br>        return; <br>    }  <br>     <br>    hr = m_pmsgsite-&gt;SubmitMessage(0); <br>    if (FAILED(hr)) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pmsgsite); <br>        ShowError(); <br>    } <br>    else <br>    { <br>        m_viewnotify.OnSubmitted(); <br>    }    <br>     <br>    if (m_pmsg == NULL) <br>        ShutdownForm(SAVEOPTS_NOSAVE); <br>} <br> <br>///  CBaseForm::DoNext <br>// <br>//  called only from our UI <br>void CBaseForm::DoNext(ULONG ulDir) <br>{    <br>    Assert(VCDIR_NEXT == ulDir || VCDIR_PREV == ulDir); <br> <br>    HRESULT hr; <br>     <br>    hr = HrQuerySave(SAVEOPTS_PROMPTSAVE); <br>    if(hr) <br>    { <br>        if(hr != MAPI_E_USER_CANCEL) <br>            ShowError(); <br>        return; <br>    } <br> <br>    RECT rect; <br>    GetWindowRect(m_hwnd, &amp;rect); <br>         <br>    hr = ViewCtx()-&gt;ActivateNext(ulDir, &amp;rect); <br>    if(NULL == m_pmsg) <br>    { <br>        ShutdownForm(SAVEOPTS_NOSAVE); <br>    } <br>} <br> <br>///  CBaseForm::DoReply <br>// <br>//  called only from our UI <br>void CBaseForm::DoReply(eREPLYTYPE eType) <br>{ <br>    HRESULT hr; <br> <br>    hr = HrQuerySave(SAVEOPTS_PROMPTSAVE); <br>    if(hr) <br>    { <br>        if(hr != MAPI_E_USER_CANCEL) <br>            ShowError(); <br>        return; <br>    } <br> <br>    RECT rect; <br>    GetWindowRect(m_hwnd, &amp;rect); <br> <br>    int iOffset = GetSystemMetrics(SM_CYCAPTION); <br>    OffsetRect(&amp;rect, iOffset, iOffset); <br>     <br>    hr = HrReply(eType, m_hwnd, &amp;rect); <br>    if(!hr) <br>    { <br>        ShutdownForm(SAVEOPTS_NOSAVE); <br>    } <br>    else <br>    { <br>        ShowError(); <br>    } <br>} <br> <br>///  CBaseForm::DoCopy <br>// <br>//  called only from our UI <br>void CBaseForm::DoCopy(void) <br>{ <br>    HRESULT         hr; <br>    LPMAPIFOLDER    pfld = NULL; <br>    LPMDB           pmdb = NULL; <br>     <br>    if(!FGetFoldChooser()) <br>    { <br>        ShowMessageBox(m_hwnd, "Can't copy", g_szFormName, MB_OK | MB_ICONSTOP); <br>        return; <br>    } <br> <br>    Assert(m_lpfnHrPickFolder &amp;&amp; m_hChsFldDll); <br>     <br>    if (m_pses == NULL) <br>    { <br>        hr = m_pmsgsite-&gt;GetSession(&amp;m_pses); <br>        if(hr) <br>        { <br>            m_lsterr.HrSetLastError(hr, m_pmsgsite); <br>            ShowError(); <br>            return; <br>        } <br>    } <br> <br>    BOOL fOldModalUp = g_FModalUp; <br> <br>    g_FModalUp = TRUE; <br> <br>    hr = (*m_lpfnHrPickFolder)(g_hinst, m_hwnd, m_pses, &amp;pfld, &amp;pmdb, <br>                                &amp;m_cbCFDState, &amp;m_pbCFDState); <br> <br>     <br>    g_FModalUp = fOldModalUp; <br> <br>    if(hr) <br>    { <br>        if(GetScode(hr) != MAPI_E_USER_CANCEL) <br>            ShowMessageBox(m_hwnd, "Can't copy", g_szFormName, MB_OK | MB_ICONSTOP); <br> <br>        return; <br>    } <br> <br>    Assert(m_pmsgsite); <br>    Assert(pfld); <br>    Assert(pmdb); <br> <br>    hr = m_pmsgsite-&gt;CopyMessage(pfld); <br>    pfld-&gt;Release(); <br>    pmdb-&gt;Release(); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pmsgsite); <br>        ShowError(); <br>        return; <br>    } <br> <br>} <br> <br> <br>///  CBaseForm::DoMove <br>// <br>//  called only from our UI <br>void CBaseForm::DoMove(void) <br>{ <br>    HRESULT         hr; <br>    LPMAPIFOLDER    pfld = NULL; <br>    LPMDB           pmdb = NULL; <br>     <br>    if(!FGetFoldChooser()) <br>    { <br>        ShowMessageBox(m_hwnd, "Can't move", g_szFormName, MB_OK | MB_ICONSTOP); <br>        return; <br>    } <br> <br>    Assert(m_lpfnHrPickFolder &amp;&amp; m_hChsFldDll); <br>     <br>    if (m_pses == NULL) <br>    { <br>        hr = m_pmsgsite-&gt;GetSession(&amp;m_pses); <br>        if(hr) <br>        { <br>            m_lsterr.HrSetLastError(hr, m_pmsgsite); <br>            ShowError(); <br>            return; <br>        } <br>    } <br> <br>     <br>    BOOL fOldModalUp = g_FModalUp; <br> <br>    g_FModalUp = TRUE; <br> <br>    hr = (*m_lpfnHrPickFolder)(g_hinst, m_hwnd, m_pses, &amp;pfld, &amp;pmdb, <br>                                //&amp;m_cbCFDState, &amp;m_pbCFDState); <br>                                NULL, NULL); <br> <br>    g_FModalUp = fOldModalUp; <br> <br>    if(hr) <br>    { <br>        if(GetScode(hr) != MAPI_E_USER_CANCEL) <br>            ShowMessageBox(m_hwnd, "Can't move", g_szFormName, MB_OK | MB_ICONSTOP); <br> <br>        return; <br>    } <br> <br>    Assert(m_pmsgsite); <br>    Assert(pfld); <br>    Assert(pmdb); <br> <br>    RECT rect; <br>    GetWindowRect(m_hwnd, &amp;rect); <br> <br>    hr = m_pmsgsite-&gt;MoveMessage(pfld, ViewCtx(), &amp;rect); <br>    pfld-&gt;Release(); <br>    pmdb-&gt;Release(); <br>    if(HR_FAILED(hr)) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pmsgsite); <br>        ShowError(); <br>        return; <br>    } <br> <br>    if(NULL == m_pmsg) <br>    { <br>        ShutdownForm(SAVEOPTS_NOSAVE); <br>    } <br> <br> <br>} <br> <br>//wraper for MessageBox() <br>int CBaseForm::ShowMessageBox(HWND hwnd, LPCTSTR lpszText, LPCTSTR lpszTitle, UINT uiStyle) <br>{ <br>    int iret; <br>    BOOL fOldModalUp = g_FMBoxUp; <br>     <br>    g_FMBoxUp = TRUE; <br> <br>    iret = MessageBox(hwnd, lpszText, lpszTitle, uiStyle); <br> <br>    g_FMBoxUp = fOldModalUp; <br> <br>    return iret; <br>} <br>         <br>//wraper for m_lsterr.ShowError() <br>void CBaseForm::ShowError(void) <br>{ <br>    int iret; <br>    BOOL fOldModalUp = g_FMBoxUp; <br>     <br>    g_FMBoxUp = TRUE; <br> <br>    iret = m_lsterr.ShowError(m_hwnd); <br> <br>    g_FMBoxUp = fOldModalUp; <br> <br>} <br> <br>BOOL CBaseForm::FGetFoldChooser(void) <br>{ <br>    if(m_lpfnHrPickFolder) <br>        return TRUE; <br> <br>    Assert(!m_hChsFldDll); <br> <br>    UINT uiErrMode = SetErrorMode(SEM_NOOPENFILEERRORBOX); <br> <br>    m_hChsFldDll = LoadLibrary(szChsFldDllName); <br> <br>    SetErrorMode(uiErrMode); <br> <br>    if(m_hChsFldDll) <br>    { <br>        if((m_lpfnHrPickFolder = (HRPICKFOLDER)GetProcAddress(m_hChsFldDll, <br>                                        szChsFldFnName))) <br>        { <br>            return TRUE; <br>        } <br> <br>        DebugTrace("smpfrm: GetProcAddress for %s failed", szChsFldFnName); <br>         <br>        FreeLibrary(m_hChsFldDll); <br>        m_hChsFldDll = NULL; <br>    } <br>    else <br>    { <br>        DebugTrace("smpfrm: failed to load choose folder dll\n"); <br>    } <br> <br>    return FALSE; <br>} <br> <br>// <br>//if the body is to large for GetProps, have to use IStream <br>// <br>HRESULT HrStreamInMsgBody(LPMESSAGE pmsg, LPVOID pbase, <br>                            LPSTR *  pszBody, CLastError * plasterror) <br>{ <br>    Assert(pmsg); <br>    Assert(pszBody); <br>    Assert(plasterror); <br> <br>    HRESULT hr; <br>    LPSTREAM lpstreamBody = NULL; <br>    STATSTG statstg; <br>    LPSTR szRet = NULL; <br>    ULONG cb = 0; <br> <br>    Assert(pszBody); <br>    *pszBody = NULL; <br> <br>    hr = pmsg-&gt;OpenProperty(PR_BODY, &amp;IID_IStream, <br>                            STGM_READ, 0, (LPUNKNOWN FAR *) &amp;lpstreamBody); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        plasterror-&gt;HrSetLastError(hr, pmsg); <br>        goto err; <br>    } <br>     <br>    hr = lpstreamBody-&gt;Stat(&amp;statstg, STATFLAG_NONAME); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        plasterror-&gt;HrSetLastError(hr, lpstreamBody); <br>        goto err; <br>    } <br>    Assert(statstg.cbSize.HighPart == 0); <br>     <br>    //if p base is not null, link the new buffer to it <br>    if(pbase) <br>    { <br>        if(MAPIAllocateMore(statstg.cbSize.LowPart + 1, pbase, (LPVOID FAR *) &amp;szRet)) <br>        { <br>            plasterror-&gt;HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>            goto err; <br>        } <br>    } <br>    else <br>    { <br>        if(MAPIAllocateBuffer(statstg.cbSize.LowPart + 1, (LPVOID FAR *) &amp;szRet)) <br>        { <br>            plasterror-&gt;HrSetLastError(ResultFromScode(E_OUTOFMEMORY)); <br>            goto err; <br>        } <br>    } <br>     <br>    hr = lpstreamBody-&gt;Read(szRet, statstg.cbSize.LowPart, &amp;cb); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        plasterror-&gt;HrSetLastError(hr); <br>        goto err; <br>    } <br>    szRet[statstg.cbSize.LowPart] = '\0'; <br>     <br>err: <br>    UlRelease(lpstreamBody); <br>    lpstreamBody = NULL; <br>    if(hr) <br>    { <br>        if(!pbase) <br>            MAPIFreeBuffer(szRet); <br>        szRet = NULL; <br> <br>    } <br> <br>    *pszBody = szRet; <br> <br>    return hr; <br>} <br>// <br>//if the body is to large for SetProps, have to use IStream <br>// <br>HRESULT HrStreamOutMsgBody(LPMESSAGE pmsg, LPSTR szBody, CLastError * plasterror) <br>{ <br>    Assert(pmsg); <br>    Assert(szBody); <br>    Assert(plasterror); <br> <br>    HRESULT hr; <br>    LPSTREAM lpstreamBody = NULL; <br>    ULONG cb = 0; <br> <br>    Assert(szBody); <br>     <br>    hr = pmsg-&gt;OpenProperty(PR_BODY, &amp;IID_IStream, <br>                            STGM_READWRITE, 0, (LPUNKNOWN FAR *) &amp;lpstreamBody); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        plasterror-&gt;HrSetLastError(hr, pmsg); <br>        goto err; <br>    } <br>     <br>    hr = lpstreamBody-&gt;Write(szBody, lstrlen(szBody)+1, NULL); <br>    if(hr) <br>        plasterror-&gt;HrSetLastError(hr); <br>     <br>err: <br>    UlRelease(lpstreamBody); <br>    lpstreamBody = NULL; <br> <br>    return hr; <br>} <br> <br>/* <br> *  Formats a Win32 file time as a MAPI date/time string. <br> *  NOTE: converts from GMT to local time. <br> */ <br>void FormatTime(FILETIME *pft, LPSTR szTime) <br>{ <br>    FILETIME        ft; <br>    SYSTEMTIME      systime; <br> <br>    FileTimeToLocalFileTime(pft, &amp;ft); <br>    FileTimeToSystemTime(&amp;ft, &amp;systime); <br>    wsprintf(szTime, <br>        "%04.4d/%02.2d/%02.2d %02.2d:%02.2d", <br>        systime.wYear, systime.wMonth, systime.wDay, <br>        systime.wHour, systime.wMinute); <br>} <br> <br>///     GetMsgAdrlist  <br>//    retrieves recipients adrlist of a message <br>HRESULT GetMsgAdrlist (LPMESSAGE pmsg, LPADRLIST *  ppAdrList, CLastError * plasterror) <br>{ <br>    *ppAdrList = NULL; <br>  <br>    LPMAPITABLE pTable = NULL; <br>    HRESULT hr; <br>     <br>    hr = pmsg-&gt;GetRecipientTable (0, &amp;pTable); <br>    if(!hr) <br>    { <br>        hr = HrQueryAllRows(pTable, NULL, NULL, NULL, 0, (LPSRowSet *)ppAdrList); <br>        if(hr) <br>        { <br>            plasterror-&gt;HrSetLastError(hr, pTable); <br>        } <br>    } <br>    else <br>    { <br>        plasterror-&gt;HrSetLastError(hr, pmsg); <br>    } <br>     <br>    pTable-&gt;Release(); <br>     <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
