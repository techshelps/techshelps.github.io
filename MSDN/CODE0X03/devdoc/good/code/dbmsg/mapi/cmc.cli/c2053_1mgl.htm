<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CMCCLI.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2055"></a>CMCCLI.C</h2>
<pre><code>// <br>//  C M C C L I . C <br>// <br>//      Sample CMC mail client for the MAPI 1.0 PDK. <br>//      Uses the CMC interface without extensions. <br>// <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;lzexpand.h&gt; <br>#include &lt;xcmc.h&gt; <br>#include &lt;xcmcext.h&gt; <br>#include &lt;xcmcmsxt.h&gt; <br>#include "pvalloc.h" <br>#include "cmccli.h" <br> <br>HINSTANCE hInst; <br>HINSTANCE hlibCMC = (HINSTANCE)NULL; <br> <br>LPFNCMCQUERYCONFIGURATION lpfnCMCQueryConfiguration = NULL; <br>LPFNCMCLOGON lpfnCMCLogon = NULL; <br>LPFNCMCLOGOFF lpfnCMCLogoff = NULL; <br>LPFNCMCFREE lpfnCMCFree = NULL; <br>LPFNCMCLOOKUP lpfnCMCLookUp = NULL; <br>LPFNCMCLIST lpfnCMCList = NULL; <br>LPFNCMCSEND lpfnCMCSend = NULL; <br>LPFNCMCREAD lpfnCMCRead = NULL; <br>LPFNCMCACTON lpfnCMCActOn = NULL; <br> <br>// Static Data <br> <br>static BOOL fPriority = 0; <br>static BOOL fReturn = 0; <br>static CMC_extension extMsgOpt[2] = \ <br>                     {{CMC_X_COM_PRIORITY, CMC_X_COM_NORMAL, NULL, 0}, \ <br>                      {CMC_X_MS_MESSAGE_DATA, 0, NULL, CMC_EXT_LAST_ELEMENT}}; <br> <br>static CMC_session_id lhSession = 0; <br>static HBITMAP hReadBmp; <br>static HBITMAP hReadABmp; <br>static HBITMAP hUnReadBmp; <br>static HBITMAP hUnReadABmp; <br>static HCURSOR hWaitCur; <br>static LPMSGID lpReadMsgNode=NULL; <br>static CMC_message FAR *CmcMsg = NULL; <br> <br>int PASCAL <br>WinMain (HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpszCmd, int nCmdShow) <br>{ <br>    MSG msg; <br> <br>    hlibCMC = (HINSTANCE) NULL; <br> <br>    if (!hPrevInst) <br>        if (!InitApplication (hInstance)) <br>            return (FALSE); <br> <br>    if (!InitInstance (hInstance, nCmdShow)) <br>        return (FALSE); <br> <br>    while (GetMessage (&amp;msg, (HWND) NULL, 0, 0)) <br>    { <br>        TranslateMessage (&amp;msg); <br>        DispatchMessage (&amp;msg); <br>    } <br> <br>    if (hReadBmp) <br>        DeleteObject (hReadBmp); <br>    if (hReadABmp) <br>        DeleteObject (hReadABmp); <br>    if (hReadBmp) <br>        DeleteObject (hUnReadBmp); <br>    if (hReadBmp) <br>        DeleteObject (hUnReadABmp); <br> <br>    DeinitApplication (); <br> <br>    return (msg.wParam); <br>} <br> <br>// <br>//  InitApplication <br>// <br>//  Purpose: <br>//      Initialize the application. <br>// <br>//  Parameters: <br>//      hInstance   - Instance handle <br>// <br>//  Returns: <br>//      True/False <br>// <br>// <br> <br>BOOL <br>InitApplication (HINSTANCE hInstance) <br>{ <br>    WNDCLASS wc; <br> <br>    wc.style = 0; <br>    wc.lpfnWndProc = MainWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon (hInstance, "NoMail"); <br>    wc.hCursor = LoadCursor ((HINSTANCE) hInstance, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject (WHITE_BRUSH); <br>    wc.lpszMenuName = "MailMenu"; <br>    wc.lpszClassName = "Client"; <br> <br>    return (RegisterClass (&amp;wc)); <br>} <br> <br>// <br>//  InitInstance <br>// <br>//  Purpose: <br>//      Initialize this instance. <br>// <br>//  Parameters: <br>//      hInstance   - Instance handle <br>//      nCmdShow    - Do we show the window? <br>// <br>//  Returns: <br>//      True/False <br>// <br>// <br> <br>BOOL <br>InitInstance (HINSTANCE hInstance, int nCmdShow) <br>{ <br>    HWND hWnd; <br>    BOOL fInit; <br>    CMC_return_code ulResult; <br>    CMC_boolean UI_available; <br>    CMC_extension ext; <br>    CMC_X_COM_support sup[2]; <br> <br>    hInst = hInstance; <br> <br>    hWnd = CreateWindow ("Client", "CMC Sample Mail Client", WS_OVERLAPPEDWINDOW, <br>        5, 5, 300, 75, (HWND) NULL, (HMENU) NULL, hInst, NULL); <br> <br>    if (!hWnd) <br>        return (FALSE); <br> <br>    ShowWindow (hWnd, nCmdShow); <br>    UpdateWindow (hWnd); <br> <br>    hReadBmp = LoadBitmap (hInst, MAKEINTRESOURCE (IDREAD)); <br>    hReadABmp = LoadBitmap (hInst, MAKEINTRESOURCE (IDREADA)); <br>    hUnReadBmp = LoadBitmap (hInst, MAKEINTRESOURCE (IDUNREAD)); <br>    hUnReadABmp = LoadBitmap (hInst, MAKEINTRESOURCE (IDUNREADA)); <br> <br>    hWaitCur = LoadCursor( (HINSTANCE) NULL, IDC_WAIT); <br> <br>    if (fInit = InitSimpleCMC ()) <br>    { <br>        if((ulResult = CMCQueryConfiguration( <br>           (CMC_session_id) NULL, // no session handle yet! <br>           CMC_CONFIG_UI_AVAIL,   // Make sure UI is available <br>           &amp;UI_available,         // return value <br>           NULL))==CMC_SUCCESS) <br>        { <br>            sup[0].item_code = CMC_XS_COM; <br>            sup[0].flags = 0; <br>            sup[1].item_code = CMC_XS_MS; <br>            sup[1].flags = 0; <br>            ext.item_code = CMC_X_COM_SUPPORT_EXT; <br>            ext.item_data = 2; <br>            ext.item_reference = sup; <br>            ext.extension_flags = CMC_EXT_LAST_ELEMENT; <br> <br>            /* CMCLogon might yield control to Windows. So to prevent the user <br>            from clicking "logon" while we are in the process of loggin on we <br>            have to disable it*/ <br>            SecureMenu(hWnd, TRUE); <br> <br>            if ((ulResult = CMCLogon (NULL, NULL, NULL, (CMC_enum)0, <br>                                  (CMC_ui_id)hWnd, CMC_VERSION, <br>                                  CMC_LOGON_UI_ALLOWED | CMC_ERROR_UI_ALLOWED, <br>                                  &amp;lhSession, &amp;ext))==CMC_SUCCESS) <br>            { <br>                if(sup[0].flags &amp; CMC_X_COM_SUPPORTED) <br>                    fPriority = TRUE; <br>                else <br>                    fPriority = FALSE; <br>                if(sup[1].flags &amp; CMC_X_COM_SUPPORTED) <br>                    fReturn = TRUE; <br>                else <br>                    fReturn = FALSE; <br> <br>                ToggleMenuState (hWnd, TRUE); <br>            } <br>            else <br>            { <br>                SecureMenu(hWnd, FALSE); <br>                lhSession = 0; <br>                MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR); <br>            } <br>        } <br>        else <br>        { <br>            lhSession = 0; <br>            MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR); <br>        } <br>    } <br>    return (fInit); <br>} <br> <br>// <br>//  InitSimpleCMC <br>// <br>//  Purpose: <br>//      Loads the DLL containing the simple CMC functions and sets <br>//      up a pointer to each. Wrappers for the  function pointers <br>//      are declared in CLIENT.H. <br>// <br>//  Returns: <br>//      TRUE if sucessful, else FALSE <br>// <br>//  Side effects: <br>//      Loads a DLL and sets up function pointers <br>// <br>BOOL <br>InitSimpleCMC (void) <br>{ <br>    char    szMsgBuf[512]=""; <br>    char    szLibName[32] <br>        #ifdef WIN16 <br>            ="MAPI.DLL"; <br>        #else <br>            ="MAPI32.dll"; <br>        #endif <br> <br>    /* <br>     *Check if CMC is installed on the system <br>     */ <br>    if(!fCMCInstalled()) <br>        return FALSE; <br> <br> <br>    // Get INI directives for alternate DLL PATH <br>     <br>#ifdef WIN16 <br>    GetProfileString( "Mail", "CMCDLLNAME", szLibName, szLibName,  <br>            sizeof(szLibName) - 1 ); <br>#else <br>    GetProfileString( "Mail", "CMCDLLNAME32", szLibName, szLibName,  <br>            sizeof(szLibName) - 1 ); <br>#endif   <br> <br>#ifdef WIN16 <br>    if ((hlibCMC = LoadLibrary (szLibName)) &lt;  32) <br>#else <br>    if ((hlibCMC = LoadLibrary (szLibName)) &lt;  (HINSTANCE) 32) <br>#endif <br>    { <br>        wsprintf(szMsgBuf,"Cannot Load %s.  Check to see that you have %s in your path or '~SystemRoot~\\System' " <br>                          "directory.  You may change the CMC dll path by adding a [MAIL] section to your " <br>                          "WIN.INI file wtih the following entry: CMCDLLNAME=\\MAPI.REL\\MAPI.DLL", <br>                          szLibName,szLibName); <br>        MessageBox(NULL, szMsgBuf,"Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCQueryConfiguration = (LPFNCMCQUERYCONFIGURATION)GetProcAddress (hlibCMC, "cmc_query_configuration") )) <br>    { <br>        wsprintf(szMsgBuf,"Cannot Load CMC process functions from %s.  Check that you do not have an " <br>                          "outdated version of %s in your '~SystemRoot~\\System' directory.  If you do then you " <br>                          "may change the CMC dll path by adding a [MAIL] section to your WIN.INI file with the " <br>                          "following entry: CMCDLLNAME=\\MAPI.REL\\%s",szLibName,szLibName,szLibName); <br>        MessageBox(NULL, szMsgBuf,"Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCLogon  =  (LPFNCMCLOGON)GetProcAddress (hlibCMC, "cmc_logon") )) <br>    { <br>        MessageBox(NULL, "Cannot Load cmc_logon process address.","Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCLogoff  =  (LPFNCMCLOGOFF)GetProcAddress (hlibCMC, "cmc_logoff") )) <br>    { <br>        MessageBox(NULL, "Cannot Load cmc_logoff process address.","Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCFree  =  (LPFNCMCFREE)GetProcAddress (hlibCMC, "cmc_free") )) <br>    { <br>        MessageBox(NULL, "Cannot Load cmc_free process address.","Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCLookUp  =  (LPFNCMCLOOKUP)GetProcAddress (hlibCMC, "cmc_look_up") )) <br>    { <br>        MessageBox(NULL, "Cannot Load cmc_look_up process address.","Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCList  =  (LPFNCMCLIST)GetProcAddress (hlibCMC, "cmc_list") )) <br>    { <br>        MessageBox(NULL, "Cannot Load cmc_list process address.","Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCSend  =  (LPFNCMCSEND)GetProcAddress (hlibCMC, "cmc_send") )) <br>    { <br>        MessageBox(NULL, "Cannot Load cmc_send process address.","Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCRead  =  (LPFNCMCREAD)GetProcAddress (hlibCMC, "cmc_read") )) <br>    { <br>        MessageBox(NULL, "Cannot Load cmc_read process address.","Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!(lpfnCMCActOn  =  (LPFNCMCACTON)GetProcAddress (hlibCMC, "cmc_act_on") )) <br>    { <br>        MessageBox(NULL, "Cannot Load cmc_acto_on process address.","Error", MB_ICONSTOP | MB_OK); <br>        return FALSE; <br>    } <br> <br>    return (TRUE); <br> <br>} <br> <br> <br>/* <br> -  fCMCInstalled <br> - <br> *  Purpose: <br> *      Checks the appropriate win.ini/registry value to see if CMC is <br> *      installed in the system.  <br> *   <br> *  Returns: <br> *      TRUE if CMC is installed, else FALSE <br> * <br> */ <br>BOOL <br>fCMCInstalled(void) <br>{ <br>#ifdef _WIN32 <br>    /* on win32 the value to check is  <br>        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Messaging Subsystem\CMC <br>    */ <br>     <br>    LONG lr; <br>    HKEY hkWMS; <br>     <br>    #define CMCVSize 8 <br>    char szCMCValue[CMCVSize]; <br>    DWORD dwType; <br>    DWORD cbCMCValue = CMCVSize; <br> <br>    lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, <br>                    "SOFTWARE\\Microsoft\\Windows Messaging Subsystem", <br>                     0, KEY_READ, &amp;hkWMS); <br>    if(ERROR_SUCCESS == lr) <br>    { <br>        lr = RegQueryValueEx(hkWMS, "CMC", 0, &amp;dwType, szCMCValue, &amp;cbCMCValue); <br>        RegCloseKey(hkWMS); <br>        if(ERROR_SUCCESS == lr) <br>        { <br>            if(lstrcmp(szCMCValue, "1") == 0) <br>                return TRUE; <br>        } <br>    } <br>     <br>    return FALSE; <br> <br>#else /*_WIN32*/ <br>     <br>    /*check the win.ini value*/ <br>    return GetProfileInt("Mail", "CMC", 0); <br> <br>#endif /*_WIN32*/ <br>} <br> <br> <br>void <br>DeinitSimpleCMC () <br>{ <br>    if (hlibCMC) <br>    { <br>        FreeLibrary (hlibCMC); <br>        hlibCMC = (HINSTANCE) NULL; <br>    } <br>} <br> <br> <br>void <br>DeinitApplication () <br>{ <br>    DeinitSimpleCMC (); <br>} <br> <br> <br>// <br>//  MainWndProc <br>// <br>//  Purpose: <br>//      Main Window Procedure for test program. <br>// <br>//  Parameters: <br>//      hWnd <br>//      message <br>//      wParam <br>//      lParam <br>// <br>//  Returns: <br>// <br>// <br>// <br> <br>LONG FAR PASCAL <br>MainWndProc (HWND hWnd, UINT msg, UINT wParam, LPARAM lParam) <br>{ <br>    CMC_return_code ulResult; <br>    CMC_boolean UI_available; <br>    CMC_message far *lpmsg; <br>    ULONG cNewRecips; <br>    CMC_recipient FAR *lpNewRecips; <br>    CMC_extension ext; <br>    char *szFoo[2]; <br> <br>    switch (msg) <br>    { <br>    case WM_COMMAND: <br>        switch (LOWORD (wParam)) { <br>        case IDM_LOGON: <br>            if (!lhSession) { <br>                if ( (ulResult = CMCQueryConfiguration( <br>                     (CMC_session_id) NULL, // no session handle yet! <br>                    CMC_CONFIG_UI_AVAIL, // Make sure UI is available <br>                    &amp;UI_available, // return value <br>                    NULL))==CMC_SUCCESS) { // no extensions <br> <br>                    SecureMenu(hWnd, TRUE); <br> <br>                    if ((ulResult = CMCLogon (NULL,  // Default service <br>                           NULL,  // Prompt for username <br>                           NULL,  // Prompt for password <br>                           (CMC_enum)NULL, // Default Character set <br>                           (CMC_ui_id) NULL, // Default UI ID <br>                           CMC_VERSION,  // Version 1 CMC calls <br>                           CMC_LOGON_UI_ALLOWED | CMC_ERROR_UI_ALLOWED, // full logon and allow errors <br>                           &amp;lhSession, // returned session id <br>                           NULL))==CMC_SUCCESS) { // no extensions <br> <br>                        ToggleMenuState (hWnd, TRUE); <br>                    } else { <br>                        SecureMenu(hWnd, FALSE); <br>                        lhSession = 0; <br>                        MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR); <br>                    } <br>                } <br>            } <br>            break; <br> <br>        case IDM_LOGOFF: <br>            if (lhSession) { <br>               CMCLogoff (lhSession, (CMC_ui_id) NULL, 0, 0); <br>               ToggleMenuState (hWnd, FALSE); <br>                lhSession = 0; <br>            } <br>            break; <br> <br>        case IDM_COMPOSE_CUSTOM: <br>            DialogBox (hInst, "ComposeNote", hWnd, ComposeDlgProc); <br>            break; <br> <br>        case IDM_COMPOSE_CMC: <br>            lpmsg = (CMC_message far *)GlobalAllocPtr(GPTR, sizeof(CMC_message)); <br>            ulResult = CMCSend(lhSession,  <br>                            lpmsg,  <br>                            CMC_SEND_UI_REQUESTED | CMC_ERROR_UI_ALLOWED, <br>                            (CMC_ui_id)hWnd, NULL); <br>            if (ulResult != CMC_SUCCESS) <br>            { <br>                if (ulResult != CMC_E_USER_CANCEL) <br>                MakeMessageBox (hWnd, ulResult, IDS_SENDERROR, MBS_ERROR); <br>            } <br>            else <br>            GlobalFreePtr(lpmsg); <br>            break; <br> <br>        case IDM_READ: <br>            DialogBox (hInst, "InBox", hWnd, InBoxDlgProc); <br>            break; <br> <br>        case IDM_ADDRBOOK: <br>            if (lhSession) <br>            { <br>                szFoo[0] = ""; <br>                szFoo[1] = ""; <br>                cNewRecips = 0; <br>                ext.item_code = CMC_X_MS_ADDRESS_UI; <br>                ext.item_data = 0; <br>                ext.item_reference = szFoo; <br>                ext.extension_flags = CMC_EXT_LAST_ELEMENT; <br>                ulResult = CMCLookUp (lhSession, NULL, CMC_LOOKUP_ADDRESSING_UI, <br>                    (CMC_ui_id)hWnd, &amp;cNewRecips, &amp;lpNewRecips, &amp;ext); <br> <br>                if (ulResult != CMC_SUCCESS) <br>                { <br>                    if (ulResult != CMC_E_USER_CANCEL) <br>                        MakeMessageBox (hWnd, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR); <br>                } <br>            } <br>            break; <br> <br>        case IDM_ABOUT: <br>            DialogBox (hInst, "AboutBox", hWnd, AboutDlgProc); <br>            break; <br> <br>        case IDM_EXIT: <br>            if (lhSession) { <br>               CMCLogoff (lhSession, (CMC_ui_id) NULL, 0, 0); <br>               ToggleMenuState (hWnd, FALSE); <br>                lhSession = 0; <br>            } <br> <br>            PostQuitMessage (0); <br>            break; <br> <br>        default: <br>            return (DefWindowProc (hWnd, msg, wParam, lParam)); <br>        } <br>        break; <br> <br>    case WM_ENDSESSION: <br>        DestroyWindow (hWnd); <br>        break; <br> <br>    case WM_CLOSE: <br>    case WM_DESTROY: <br>        if (lhSession) { <br>           CMCLogoff (lhSession, (CMC_ui_id) NULL, 0, 0); <br>           ToggleMenuState (hWnd, FALSE); <br>            lhSession = 0; <br>        } <br>        PostQuitMessage (0); <br>        break; <br> <br>    default: <br>        return (DefWindowProc (hWnd, msg, wParam, lParam)); <br>    } <br>    return FALSE; <br>} <br> <br>// <br>//  AboutDlgProc <br>// <br>//  Purpose: <br>//      About box dialog procedure <br>// <br>//  Parameters: <br>//      hDlg <br>//      message <br>//      wParam <br>//      lParam <br>// <br>//  Returns: <br>//      True/False <br>// <br>// <br> <br>BOOL FAR PASCAL <br>AboutDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    char    rgchVersion[80]; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        sprintf(rgchVersion, "Version %01.1f", ((float)CMC_VERSION)/100); <br>        SetDlgItemText(hDlg, IDC_VERSION, rgchVersion); <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        if (wParam == IDOK || wParam == IDCANCEL) <br>        { <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        } <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br> <br>// <br>//  ComposeDlgProc <br>// <br>//  Purpose: <br>//      Dialog procedure for the ComposeNote dialog. <br>// <br>//  Parameters: <br>//      hDlg <br>//      message <br>//      wParam <br>//      lParam <br>// <br>//  Returns: <br>//      True/False <br>// <br>// <br> <br>BOOL FAR PASCAL <br>ComposeDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    char szUnResNames[TO_EDIT_MAX]; <br>    char szDisplayNames[TO_EDIT_MAX]; <br>    char szAttach[FILE_ATTACH_MAX]; <br>    BOOL fUnResTo, fUnResCc; <br>    LONG cb, cLines; <br>    ULONG ulResult; <br>    HCURSOR hOldCur; <br>    static CMC_string lpszSubject; <br>    static CMC_string lpszTextNote; <br>    static ULONG cRecips; <br>    static ULONG cNewRecips; <br>    static ULONG cAttach; <br>    static CMC_recipient FAR *lpRecips; <br>    static CMC_recipient FAR *lpNewRecips; <br>    static CMC_attachment FAR *lpAttach; <br>    CMC_extension ext; <br>    char *szFoo[2]={"",""}; <br> <br>    switch (msg) { <br>    case WM_INITDIALOG: <br>        if (CmcMsg) <br>        { <br>            //  ComposeNote is being called to either forward or reply <br>            //  to a message in the Inbox.  So, we'll initialize the <br>            //  ComposeNote form with data from the global CMC_message <br> <br>            lpszSubject = CmcMsg-&gt;subject; <br>            lpszTextNote = CmcMsg-&gt;text_note; <br> <br>            lpRecips = CmcMsg-&gt;recipients; <br>            lpAttach = CmcMsg-&gt;attachments; <br> <br>            if (lpRecips == NULL) <br>            { <br>              cRecips = 0; <br>            } <br>            else <br>            { <br>                cRecips = 0; <br>                while(!(lpRecips[cRecips].recip_flags &amp; CMC_RECIP_LAST_ELEMENT)) <br>                    cRecips++; <br> <br>                cRecips++; <br>            } <br> <br>            if (lpAttach == NULL) <br>            { <br>              cAttach = 0; <br>            } <br>            else <br>            { <br>                cAttach = 0; <br>                while(!(lpAttach[cAttach].attach_flags &amp; CMC_ATT_LAST_ELEMENT)) <br>                    cAttach++; <br> <br>                cAttach++; <br>            } <br> <br>            if (cRecips) <br>            { <br>                MakeDisplayNameStr (szDisplayNames, CMC_ROLE_TO, cRecips, lpRecips); <br>                if (*szDisplayNames) <br>                    SetDlgItemText (hDlg, IDC_TO, szDisplayNames); <br> <br>                MakeDisplayNameStr (szDisplayNames, CMC_ROLE_CC, cRecips, lpRecips); <br>                if (*szDisplayNames) <br>                    SetDlgItemText (hDlg, IDC_CC, szDisplayNames); <br>            } <br>            SetDlgItemText (hDlg, IDC_SUBJECT, CmcMsg-&gt;subject); <br>            SetDlgItemText (hDlg, IDC_NOTE, CmcMsg-&gt;text_note); <br> <br>            SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0); <br>            SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0); <br>            SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_SETMODIFY, FALSE, 0); <br>            SendDlgItemMessage (hDlg, IDC_NOTE, EM_SETMODIFY, FALSE, 0); <br>            if(cRecips) <br>                SetFocus (GetDlgItem (hDlg, IDC_NOTE)); <br>            else <br>                SetFocus (GetDlgItem (hDlg, IDC_TO)); <br>        } <br> <br>        else <br>        { <br>            if(CmcMsg) <br>                PvFree(CmcMsg); <br> <br>            CmcMsg = (CMC_message *)PvAlloc(sizeof(CMC_message)); <br>            if (!CmcMsg) <br>                goto cleanup; <br> <br>            _fmemset (CmcMsg, 0, sizeof (CMC_message)); <br> <br>            lpszSubject = NULL; <br>            lpszTextNote = NULL; <br>            cRecips = 0; <br>            cAttach = 0; <br>            lpRecips = NULL; <br>            lpNewRecips = NULL; <br>            lpAttach = NULL; <br> <br>            SetFocus (GetDlgItem (hDlg, IDC_TO)); <br>        } <br>        return FALSE; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD (wParam)) <br>        { <br>        case IDC_ATTACH: <br>            if (GetNextFile (hDlg, (ULONG) -1, &amp;cAttach, &amp;lpAttach) == CMC_SUCCESS) <br>            { <br>                //   Now, send a little render message to the text_note edit <br> <br>                wsprintf (szAttach, "&lt;&lt;File: %s&gt;&gt;", <br>                    lpAttach[cAttach - 1].attach_title); <br> <br>                SendDlgItemMessage (hDlg, IDC_NOTE, EM_REPLACESEL, 0, <br>                    (LPARAM) ((LPSTR) szAttach)); <br>            } <br>            break; <br> <br>        case IDC_ADDRBOOK: <br>         <br>            // To do: <br>            // Add a parameter to ResolveFriendlyNames to prepare unresolved names <br>            // but only as DN strings in recip list. <br>            // When call returns from Address, rebuild the edit fields. <br> <br>            cNewRecips = 0; <br>            ext.item_code = CMC_X_MS_ADDRESS_UI; <br>            ext.item_data = 2; <br>            ext.item_reference = szFoo; <br>            ext.extension_flags = CMC_EXT_LAST_ELEMENT; <br>             <br>            // include any recipients we've already resolved. <br>             <br>            ulResult = CMCLookUp (lhSession, lpRecips, CMC_LOOKUP_ADDRESSING_UI, <br>                          (CMC_ui_id)hDlg, &amp;cNewRecips, &amp;lpNewRecips, &amp;ext); <br> <br> <br>//            cNewRecips = 0; // set to NULL to allow maximum number of names to be allocated <br>//            ulResult = CMCLookUp (lhSession, lpRecips, CMC_LOOKUP_ADDRESSING_UI, <br>//                                  (CMC_ui_id)hDlg, &amp;cNewRecips, &amp;lpNewRecips, NULL); <br> <br>            if (ulResult) <br>            { <br>                if (ulResult != CMC_E_USER_CANCEL) <br>                    MakeMessageBox (hDlg, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR); <br>            } <br>            else <br>            { <br>                if (cNewRecips) <br>                { <br>                    PvFree(lpRecips); <br>                    cRecips = 0; <br> <br>                    lpRecips = (CMC_recipient far *)PvAlloc(cNewRecips * sizeof(CMC_recipient)); <br> <br>                    while(cRecips &lt; cNewRecips) <br>                    { <br>                        if(CopyRecipient(lpRecips, &amp;lpRecips[cRecips], <br>                                         &amp;lpNewRecips[cRecips])) <br>                        { <br>                            PvFree(lpRecips); <br>                            lpRecips = NULL; <br>                            cRecips = 0; <br>                            break; <br>                        } <br>                        cRecips++; <br>                    } <br> <br>                    CMCFree(lpNewRecips); <br>                    lpNewRecips = NULL; <br>                    cNewRecips = 0; <br> <br>                    MakeDisplayNameStr(szDisplayNames, CMC_ROLE_TO, <br>                                       cRecips, lpRecips); <br>                    if (*szDisplayNames) <br>                        SetDlgItemText (hDlg, IDC_TO, szDisplayNames); <br> <br>                    MakeDisplayNameStr(szDisplayNames, CMC_ROLE_CC, <br>                                       cRecips, lpRecips); <br>                    if (*szDisplayNames) <br>                        SetDlgItemText (hDlg, IDC_CC, szDisplayNames); <br> <br>                    SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0); <br>                    SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0); <br>                } <br>            } <br>            break; <br> <br>        case IDC_OPTIONS: <br>            DialogBox (hInst, "Options", hDlg, OptionsDlgProc); <br>            break; <br> <br>        case IDC_SEND: <br>        case IDC_RESOLVE: <br>            fUnResTo = FALSE; <br>            fUnResCc = FALSE; <br> <br>            hOldCur = SetCursor(hWaitCur); <br> <br>            //   Get the names from the To: field and resolve them first <br> <br>            if (SendDlgItemMessage (hDlg, IDC_TO, EM_GETMODIFY, 0, 0) &amp;&amp; <br>                (cb = SendDlgItemMessage (hDlg, IDC_TO, WM_GETTEXT, <br>                    (WPARAM)sizeof(szUnResNames), <br>                    (LPARAM) (LPSTR) szUnResNames))) <br>            { <br>                if (!ResolveFriendlyNames (hDlg, szUnResNames, CMC_ROLE_TO, <br>                        &amp;cRecips, &amp;lpRecips)) <br>                { <br>                    MakeDisplayNameStr (szDisplayNames, CMC_ROLE_TO, <br>                        cRecips, lpRecips); <br>                    if (*szDisplayNames) <br>                    { <br>                        if (*szUnResNames) <br>                        { <br>                            lstrcat (szDisplayNames, "; "); <br>                            lstrcat (szDisplayNames, szUnResNames); <br>                            fUnResTo = TRUE; <br>                        } <br> <br>                        SetDlgItemText (hDlg, IDC_TO, szDisplayNames); <br>                    } <br>                    else <br>                    { <br>                        if (*szUnResNames) <br>                        { <br>                            SetDlgItemText (hDlg, IDC_TO, szUnResNames); <br>                            fUnResTo = TRUE; <br>                        } <br>                    } <br>                } <br>                SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0); <br>            } <br> <br>            //   Now, get the names from the Cc: field and resolve them <br> <br>            if (SendDlgItemMessage (hDlg, IDC_CC, EM_GETMODIFY, 0, 0) &amp;&amp; <br>                (cb = SendDlgItemMessage (hDlg, IDC_CC, WM_GETTEXT, <br>                    (WPARAM)sizeof(szUnResNames), (LPARAM)(LPSTR)szUnResNames))) <br>            { <br>                if (!ResolveFriendlyNames (hDlg, szUnResNames, CMC_ROLE_CC, <br>                        &amp;cRecips, &amp;lpRecips)) <br>                { <br>                    MakeDisplayNameStr (szDisplayNames, CMC_ROLE_CC, <br>                        cRecips, lpRecips); <br>                    if (*szDisplayNames) <br>                    { <br>                        if (*szUnResNames) <br>                        { <br>                            lstrcat (szDisplayNames, "; "); <br>                            lstrcat (szDisplayNames, szUnResNames); <br>                            fUnResCc = TRUE; <br>                        } <br> <br>                        SetDlgItemText (hDlg, IDC_CC, szDisplayNames); <br>                    } <br>                    else <br>                    { <br>                        if (*szUnResNames) <br>                        { <br>                            SetDlgItemText (hDlg, IDC_CC, szUnResNames); <br>                            fUnResCc = TRUE; <br>                        } <br>                    } <br>                } <br>                SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0); <br>            } <br> <br>            //   If we were just Resolving Names then we can leave now <br> <br>            if (LOWORD (wParam) == IDC_RESOLVE) <br>            { <br>                SetCursor(hOldCur); <br>                break; <br>            } <br> <br>            if (cRecips == 0 || fUnResTo || fUnResCc) <br>            { <br>                if (!cRecips) <br>                    MakeMessageBox (hDlg, 0, IDS_NORECIPS, MBS_OOPS); <br> <br>                if (fUnResTo) <br>                    SetFocus (GetDlgItem (hDlg, IDC_TO)); <br>                else if (fUnResCc) <br>                    SetFocus (GetDlgItem (hDlg, IDC_CC)); <br>                else <br>                    SetFocus (GetDlgItem (hDlg, IDC_TO)); <br> <br>                SetCursor(hOldCur); <br>                break; <br>            } <br> <br>            //   Everything is OK so far, lets get the Subject <br>            //   and the text_note and try to send the message. <br> <br>            //   Get Subject from Edit <br> <br>            if (SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_GETMODIFY, 0, 0)) <br>            { <br>                cb = SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_LINELENGTH, 0, 0L); <br> <br>                CMCFree (lpszSubject); <br>                lpszSubject = (LPSTR)PvAlloc(cb + 1); <br>                if (!lpszSubject) <br>                    goto cleanup; <br> <br>                GetDlgItemText (hDlg, IDC_SUBJECT, lpszSubject, (int)cb+1); <br>            } <br> <br>            //   Get the text_note from Edit <br> <br>            if (SendDlgItemMessage (hDlg, IDC_NOTE, EM_GETMODIFY, 0, 0)) <br>            { <br>                cLines = SendDlgItemMessage (hDlg, IDC_NOTE, <br>                    EM_GETLINECOUNT, 0, 0L); <br> <br>                if (cLines) <br>                { <br>                    //   Get the total number of bytes in the multi-line <br> <br>                    cb = SendDlgItemMessage (hDlg, IDC_NOTE, EM_LINEINDEX, <br>                        (WPARAM) cLines - 1, 0L); <br>                    cb += SendDlgItemMessage (hDlg, IDC_NOTE, EM_LINELENGTH, <br>                        (WPARAM)cb, 0L); <br> <br>                    //   The next line is to account for CR-LF pairs per line. <br> <br>                    cb += cLines * 2; <br> <br>                    CMCFree (lpszTextNote); <br>                    lpszTextNote = (LPSTR)PvAlloc(cb + 1); <br>                    if (!lpszTextNote) <br>                        goto cleanup; <br> <br>                    //   Get the Note Text from the edit <br> <br>                    GetDlgItemText (hDlg, IDC_NOTE, lpszTextNote, (int)cb); </code></pre>
<p>
</p>
<pre><code>} <br>                else <br>                { <br>                    //   Make an empty string for text_note <br> <br>                    lpszTextNote = (LPSTR)PvAlloc(1); <br>                    *lpszTextNote = '\0'; <br>                } <br>            } <br> <br>            CmcMsg-&gt;subject = lpszSubject; <br>            CmcMsg-&gt;text_note = lpszTextNote; <br>            CmcMsg-&gt;recipients = lpRecips; <br>            CmcMsg-&gt;attachments = lpAttach; <br>            CmcMsg-&gt;message_extensions = extMsgOpt; <br> <br>            ulResult = CMCSend(lhSession, CmcMsg, CMC_ERROR_UI_ALLOWED, <br>                               (CMC_ui_id)hDlg, (CMC_extension far *)NULL); <br> <br>            LogSendMail(ulResult); <br> <br>            if (ulResult) <br>            { <br>                MakeMessageBox (hDlg, ulResult, IDS_SENDERROR, MBS_ERROR); <br>                SetCursor(hOldCur); <br>                break; <br>            } <br>cleanup: <br>        case IDCANCEL: <br>            SetCursor(hOldCur); <br>            PvFree(CmcMsg-&gt;message_type); <br>            PvFree(CmcMsg); <br>            PvFree(lpRecips); <br>            PvFree(lpAttach); <br>            PvFree(lpszSubject); <br>            PvFree(lpszTextNote); <br>            CmcMsg = NULL; <br> <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>            break; <br> <br>        default: <br>            break; <br>        } <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> -  OptionsDlgProc <br> - <br> *  Purpose: <br> *      Message Options dialog procedure <br> * <br> *  Parameters: <br> *      hDlg <br> *      message <br> *      wParam <br> *      lParam <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL FAR PASCAL <br>OptionsDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        CheckDlgButton (hDlg, IDC_RETURN, <br>            (UINT)(extMsgOpt[1].item_data &amp; (CMC_uint32)CMC_X_MS_MSG_RECEIPT_REQ)); <br> <br>        switch(extMsgOpt[0].item_data) <br>        { <br>        case CMC_X_COM_URGENT: <br>            CheckRadioButton(hDlg, IDC_URGENT, IDC_LOW, IDC_URGENT); <br>            break; <br> <br>        case CMC_X_COM_NORMAL: <br>            CheckRadioButton(hDlg, IDC_URGENT, IDC_LOW, IDC_NORMAL); <br>            break; <br> <br>        case CMC_X_COM_LOW: <br>            CheckRadioButton(hDlg, IDC_URGENT, IDC_LOW, IDC_LOW); <br>            break; <br>        } <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD (wParam)) <br>        { <br>        case IDC_RETURN: <br>            CheckDlgButton(hDlg, IDC_RETURN, <br>                         !IsDlgButtonChecked(hDlg, IDC_RETURN)); <br>            break; <br> <br>        case IDC_URGENT: <br>            CheckRadioButton(hDlg, IDC_URGENT, IDC_LOW, IDC_URGENT); <br>            extMsgOpt[0].item_data = CMC_X_COM_URGENT; <br>            break; <br> <br>        case IDC_NORMAL: <br>            CheckRadioButton(hDlg, IDC_URGENT, IDC_LOW, IDC_NORMAL); <br>            extMsgOpt[0].item_data = CMC_X_COM_NORMAL; <br>            break; <br> <br>        case IDC_LOW: <br>            CheckRadioButton(hDlg, IDC_URGENT, IDC_LOW, IDC_LOW); <br>            extMsgOpt[0].item_data = CMC_X_COM_LOW; <br>            break; <br> <br>        case IDOK: <br>            if (IsDlgButtonChecked (hDlg, IDC_RETURN)) <br>                extMsgOpt[1].item_data |= CMC_X_MS_MSG_RECEIPT_REQ; <br>            else <br>                extMsgOpt[1].item_data &amp;= ~CMC_X_MS_MSG_RECEIPT_REQ; <br> <br>        case IDCANCEL: <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        } <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br> <br>// <br>//  InBoxDlgProc <br>// <br>//  Purpose: <br>//      Dialog procedure for the InBox dialog. <br>// <br>//  Parameters: <br>//      hDlg <br>//      message <br>//      wParam <br>//      lParam <br>// <br>//  Returns: <br>//      True/False <br>// <br> <br> <br>BOOL FAR PASCAL <br>InBoxDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    MEASUREITEMSTRUCT* pmis; <br>    DRAWITEMSTRUCT *pdis; <br>    CMC_message_summary far * lpMsgSum = NULL; <br>    LPMSGID lpMsgNode; <br>    static LPMSGID lpMsgIdList = NULL; <br>    CMC_return_code ulResult; <br>    WORD nIndex; <br>    RECT Rect; <br>    HCURSOR hOldCur; <br> <br>    CMC_uint32 iCount = 0; <br>    CMC_uint32 i; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        hOldCur = SetCursor(hWaitCur); <br> <br>        //   Populate List Box with all messages in InBox. <br> <br>        ulResult = CMCList(lhSession, NULL, (CMC_flags) 0, NULL, <br>                           &amp;iCount, (CMC_ui_id)hDlg, &amp;lpMsgSum, NULL); <br> <br>        if (ulResult == CMC_SUCCESS) <br>        { <br>            for (i = 0; i &lt; iCount; i++) <br>            { <br>                lpMsgNode = MakeMsgNode (&amp;lpMsgSum[i]); <br> <br>                if (lpMsgNode) <br>                { <br>                    InsertMsgNode (lpMsgNode, &amp;lpMsgIdList); <br> <br>                    SendDlgItemMessage (hDlg, IDC_MSG, LB_ADDSTRING, <br>                        0, (LONG) lpMsgNode); <br>                } <br>            } <br>            CMCFree (lpMsgSum); <br>        } <br>        else <br>        { <br>            MakeMessageBox(hDlg, ulResult, IDS_READFAIL, MBS_ERROR); <br>        } <br> <br>        SetCursor(hOldCur); <br>        SetFocus (GetDlgItem (hDlg, IDC_MSG)); <br>        return TRUE; <br>        break; <br> <br>    case WM_SETFOCUS: <br>        SetFocus (GetDlgItem (hDlg, IDC_MSG)); <br>        break; <br> <br>    case WM_MEASUREITEM: <br>        //   Sets the height of the owner-drawn List-Box <br>        pmis = (MEASUREITEMSTRUCT *) lParam; <br>        pmis-&gt;itemHeight = 15; <br>        break; <br> <br>    case WM_DRAWITEM: <br>        pdis = (DRAWITEMSTRUCT *) lParam; <br>        DrawMsgItem (pdis); <br>        break; <br> <br>    case WM_DELETEITEM: <br>        //   This message is handled by the IDC_DELETE message <br>        return TRUE; <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD (wParam)) <br>        { <br>        case IDC_NEW: <br>            hOldCur = SetCursor(hWaitCur); <br> <br>            ulResult = CMCList(lhSession, NULL, CMC_LIST_UNREAD_ONLY, NULL, <br>                               &amp;iCount, (CMC_ui_id)hDlg, &amp;lpMsgSum, NULL); <br> <br>            if (ulResult == CMC_SUCCESS) { <br>                for (i = 0; i &lt; iCount; i++) { <br>                    if (!FindNode(lpMsgIdList,lpMsgSum[i].message_reference)) <br>                    { <br>                        lpMsgNode = MakeMsgNode (&amp;lpMsgSum[i]); <br> <br>                        if (lpMsgNode) <br>                        { <br>                            InsertMsgNode (lpMsgNode, &amp;lpMsgIdList); <br> <br>                            SendDlgItemMessage (hDlg, IDC_MSG, LB_ADDSTRING, <br>                                0, (LONG) lpMsgNode); <br>                        } <br>                    } <br>                } <br>                CMCFree (lpMsgSum); <br>            } <br> <br>            SetCursor(hOldCur); <br>            break; <br> <br>        case IDC_MSG: <br>#ifdef _WIN32 <br>            if(HIWORD(wParam) != LBN_DBLCLK) <br>#else <br>            if(HIWORD(lParam) != LBN_DBLCLK) <br>#endif <br>                break; <br> <br>        case IDC_READ: <br>            nIndex = (WORD) SendDlgItemMessage (hDlg, IDC_MSG, LB_GETCURSEL, 0, 0); <br> <br>            if (nIndex == LB_ERR) <br>                break; <br> <br>            lpReadMsgNode = (LPMSGID) SendDlgItemMessage(hDlg, IDC_MSG, <br>                                                    LB_GETITEMDATA, nIndex, 0L); <br> <br>            if (lpReadMsgNode == (LPMSGID) LB_ERR || !lpReadMsgNode) // Nothing is selected <br>                break; <br>            else <br>                DialogBox(hInst, "ReadNote", hDlg, ReadMailDlgProc); <br> <br>            //   Update the Messages List-Box with new icon <br> <br>            SendDlgItemMessage (hDlg, IDC_MSG, LB_GETITEMRECT, <br>                                (WPARAM)nIndex, (LPARAM)(RECT far *)&amp;Rect); <br>            InvalidateRect(GetDlgItem(hDlg, IDC_MSG), &amp;Rect, FALSE); <br>            break; <br> <br>        case IDC_DELETE: <br>            nIndex = (WORD) SendDlgItemMessage (hDlg, IDC_MSG, LB_GETCURSEL, <br>                                                (WPARAM) 0, (LPARAM) 0); <br> <br>            if (nIndex == LB_ERR) <br>                break; <br> <br>            lpMsgNode = (LPMSGID) SendDlgItemMessage (hDlg, IDC_MSG, <br>                                                      LB_GETITEMDATA, nIndex, 0); <br> <br>            if (lpMsgNode == (LPMSGID) LB_ERR || !lpMsgNode) // Nothing is selected <br>                break; <br>            else <br>            { <br>                ulResult = CMCActOn(lhSession, lpMsgNode-&gt;message_reference, <br>                                    CMC_ACT_ON_DELETE, CMC_ERROR_UI_ALLOWED, <br>                                    (CMC_ui_id)hDlg, NULL); <br> <br>                DeleteMsgNode (lpMsgNode, &amp;lpMsgIdList); <br>            } <br> <br>            SendDlgItemMessage (hDlg, IDC_MSG, LB_DELETESTRING, nIndex, 0); <br>            break; <br> <br>        case IDC_CLOSE: <br>        case IDCANCEL: <br>            FreeMsgList (lpMsgIdList); <br>            lpMsgIdList = NULL; <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>            break; <br> <br>        default: <br>            break; <br>        } <br>        break; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>// <br>//  ReadMailDlgProc <br>// <br>//  Purpose: <br>//      Dialog procedure for the ReadMail dilaog. <br>// <br>//  Parameters: <br>//      hDlg <br>//      message <br>//      wParam <br>//      lParam <br>// <br>//  Returns: <br>//      True/False <br>// <br> <br>BOOL FAR PASCAL <br>ReadMailDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    ULONG ulResult; <br>    char szTo[TO_EDIT_MAX]; <br>    char szCc[TO_EDIT_MAX]; <br>    char szChangeMsg[512]; <br>    ULONG idx; <br>    static CMC_message far *lpReadMsg; <br>    char lpszDateDisplay[TO_EDIT_MAX]; <br>    static ULONG cRecips; <br>    static ULONG cNewRecips; <br>    static ULONG cAttach; <br>    static CMC_recipient FAR *lpRecips; <br>    static CMC_recipient FAR *lpNewRecips; <br>    static CMC_attachment FAR *lpAttach; <br>    CMC_return_code rc; <br>    OFSTRUCT ofs; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        ulResult = CMCRead(lhSession, lpReadMsgNode-&gt;message_reference, <br>                        CMC_ERROR_UI_ALLOWED, &amp;lpReadMsg, (CMC_ui_id)hDlg, NULL); <br>        if (ulResult) <br>        { <br>            MakeMessageBox(hDlg, ulResult, IDS_READFAIL, MBS_ERROR); <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        } <br> <br>        lpReadMsgNode-&gt;fRead = TRUE; <br> <br>        szTo[0] = '\0'; <br>        szCc[0] = '\0'; <br> <br>        idx = 0; <br>        do <br>        { <br>            if (lpReadMsg-&gt;recipients[idx].role == CMC_ROLE_TO) <br>            { <br>                lstrcat (szTo, lpReadMsg-&gt;recipients[idx].name); <br>                lstrcat (szTo, "; "); <br>            } <br>            else if (lpReadMsg-&gt;recipients[idx].role == CMC_ROLE_CC) <br>            { <br>                lstrcat (szCc, lpReadMsg-&gt;recipients[idx].name); <br>                lstrcat (szCc, "; "); <br>            } <br>            else <br>            { <br>                //   Must be Bcc, lets ignore it! <br>            } <br> <br>        }while(!(lpReadMsg-&gt;recipients[idx++].recip_flags &amp; CMC_RECIP_LAST_ELEMENT)); <br> <br>        if(*szTo) <br>            szTo[lstrlen (szTo) - 2] = '\0'; <br>        if(*szCc) <br>            szCc[lstrlen (szCc) - 2] = '\0'; <br> <br>        SetDlgItemText (hDlg, IDC_RFROM, <br>            (lpReadMsgNode-&gt;from ? lpReadMsgNode-&gt;from : "")); <br>        ConvertDateRec (&amp;lpReadMsgNode-&gt;time_sent, <br>            lpszDateDisplay); <br> <br>        SetDlgItemText (hDlg, IDC_RDATE,  (lpszDateDisplay ? lpszDateDisplay : "")); <br>        SetDlgItemText (hDlg, IDC_RTO, szTo); <br>        SetDlgItemText (hDlg, IDC_RCC, szCc); <br>        SetDlgItemText (hDlg, IDC_RSUBJECT, (lpReadMsg-&gt;subject ? lpReadMsg-&gt;subject : "")); <br>        SetDlgItemText (hDlg, IDC_READNOTE, (lpReadMsg-&gt;text_note ? lpReadMsg-&gt;text_note : "")); <br> <br>        if (!lpReadMsg-&gt;attachments) <br>        { <br>            EnableWindow (GetDlgItem (hDlg, IDC_SAVEATTACH), FALSE); <br>            EnableWindow (GetDlgItem (hDlg, IDC_ATTACHMENT), FALSE); <br>            EnableWindow (GetDlgItem (hDlg, IDT_ATTACHMENT), FALSE); <br>        } <br>        else <br>        { <br>            idx = 0; <br>            do <br>            { <br>                if (lpReadMsg-&gt;attachments[idx].attach_title) <br>                    SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_ADDSTRING, 0, <br>                        (LPARAM)lpReadMsg-&gt;attachments[idx].attach_title); <br>            }while(!(lpReadMsg-&gt;attachments[idx++].attach_flags &amp; CMC_ATT_LAST_ELEMENT)); <br> <br>            SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_SETCURSEL, 0, 0L); <br>        } <br> <br>        SetFocus (GetDlgItem (hDlg, IDC_READNOTE)); <br>        return FALSE; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD (wParam)) <br>        { <br>        case IDC_SAVECHANGES: <br>            if (SendDlgItemMessage (hDlg, IDC_READNOTE, EM_GETMODIFY, 0, 0)) <br>                ulResult = SaveMsgChanges (hDlg, lpReadMsg); <br>            SendDlgItemMessage (hDlg, IDC_READNOTE, EM_SETMODIFY, 0, 0); <br>            break; <br> <br>        case IDC_ATTACHMENT: <br>#ifdef _WIN32 <br>            if(HIWORD(wParam) != LBN_DBLCLK) <br>#else <br>            if(HIWORD(lParam) != LBN_DBLCLK) <br>#endif <br>                break; <br> <br>        case IDC_SAVEATTACH: <br>            idx = SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_GETCURSEL, 0, 0L); <br> <br>            if(idx != LB_ERR) <br>            { <br>                SaveFileAttachments(hDlg, &amp;lpReadMsg-&gt;attachments[idx]); <br>                SetFocus(GetDlgItem (hDlg, IDC_ATTACHMENT)); <br>                return FALSE; <br> <br>            } <br>            break; <br> <br>        case IDC_REPLY: <br>        case IDC_REPLYALL: <br>        case IDC_FORWARD: <br>            if(rc = MakeNewMessage (lpReadMsg, LOWORD (wParam))) <br>                MakeMessageBox(hDlg, rc, IDS_MAKENEWFAIL, MBS_ERROR); <br> <br>            if(rc = CMCSend(lhSession, CmcMsg, CMC_SEND_UI_REQUESTED | CMC_ERROR_UI_ALLOWED, <br>                    (CMC_ui_id)hDlg, NULL)) <br>                MakeMessageBox(hDlg, rc, IDS_SENDERROR, MBS_ERROR); <br> <br>            PvFree(CmcMsg-&gt;message_type); <br>            PvFree(CmcMsg-&gt;subject); <br>            PvFree(CmcMsg-&gt;text_note); <br>            PvFree(CmcMsg-&gt;recipients); <br>            PvFree(CmcMsg-&gt;attachments); <br>            PvFree(CmcMsg); <br>            CmcMsg = NULL; <br>            break; <br> <br>        case IDCANCEL: <br>            if (SendDlgItemMessage (hDlg, IDC_READNOTE, EM_GETMODIFY, 0, 0)) <br>            { <br>                wsprintf (szChangeMsg, "Save changes to: '%s' in Inbox?", <br>                    (lpReadMsg-&gt;subject ? lpReadMsg-&gt;subject : "")); <br> <br>                if(MessageBox (hDlg, szChangeMsg, "Mail", MB_YESNO) == IDYES) <br>                { <br>                    ulResult = SaveMsgChanges (hDlg, lpReadMsg); <br>                } <br>            } <br> <br>            //   If there were file attachments, then delete the temps <br> <br>            if(lpReadMsg-&gt;attachments) <br>            { <br>                idx = 0; <br>                do <br>                { <br>                    if (lpReadMsg-&gt;attachments[idx].attach_filename) <br>                        OpenFile(lpReadMsg-&gt;attachments[idx].attach_filename, &amp;ofs, OF_DELETE); <br> <br>                }while(!(lpReadMsg-&gt;attachments[idx++].attach_flags &amp; CMC_ATT_LAST_ELEMENT)); <br>            } <br> <br>            CMCFree (lpReadMsg); <br>            lpReadMsg = NULL; <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        } <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br>// <br>//  MakeMessageBox <br>// <br>//  Purpose: <br>//      Gets resource string and displays an error message box. <br>// <br>//  Parameters: <br>//      hWnd            - Handle to parent window <br>//      idString        - Resource ID of message in StringTable <br>// <br>//  Returns: <br>//      Void <br>// <br>// <br> <br>void <br>MakeMessageBox (HWND hWnd, CMC_return_code ulResult, UINT idString, UINT fStyle) <br>{ <br>    char szMessage[512]; <br>    char szCmcReturn[256]; <br>    UINT uResult; <br> <br>    LoadString (hInst, idString, szMessage, sizeof(szMessage)-sizeof(szCmcReturn)-1); <br> <br>    if (ulResult) <br>    { <br>        uResult = (UINT) ulResult; <br>        LoadString (hInst, uResult, szCmcReturn, sizeof(szCmcReturn)-1); <br>        lstrcat (szMessage, "\nReturn Code: "); <br>        lstrcat (szMessage, szCmcReturn); <br>    } <br> <br>    MessageBox (hWnd, szMessage, "Problem", fStyle); <br>} <br> <br> <br>// <br>//  ResolveFriendlyNames <br>// <br>//  Purpose: <br>//      Helper function to convert a string of ';' delimited friendly <br>//      names into an array of CMC_recipients. <br>// <br>//  Side Effects: <br>//      The display string passed in is modified to contain the <br>//      friendly names of the mail users as found in the sample <br>//      address book. <br>// <br>//  Note: <br>//      Duplicate names in the address book will result in undefined <br>//      behavior. <br>// <br>//  Parameters: <br>//      hWnd                - Handle to parent window <br>//      lpszDisplayNames    - string of ';' delimited user names <br>//      ulRecipRole         - either CMC_ROLE_TO, CMC_ROLE_CC, or CMC_BCC <br>//      lpcRecips           - Address of recipient count to be returned <br>//      lppRecips           - Address of recipient array to be returned <br>// <br>//  Return: <br>//      ulResult <br> <br> <br>CMC_return_code <br>ResolveFriendlyNames(HWND hWnd, LPSTR lpszDisplayNames, CMC_enum ulRecipRole, <br>                     ULONG * lpcRecips, CMC_recipient FAR * * lppRecips) <br>{ <br>    char szResolve[TO_EDIT_MAX]; <br>    LPSTR lpszNameToken; <br>    ULONG cRecips = 0; <br>    ULONG cFails = 0; <br>    ULONG idx; <br>    CMC_return_code ulResult; <br>    CMC_recipient Recip; <br>    CMC_recipient FAR * lpNewRecip; <br>    CMC_recipient FAR * lpRecipList; <br>    CMC_uint32 cNewRecip; <br> <br>    *szResolve = '\0'; <br>    lpszNameToken = _fstrtok (lpszDisplayNames, ";\n"); <br> <br>    while (lpszNameToken) <br>    { <br>        //   Strip leading blanks from name <br> <br>        while (*lpszNameToken == ' ') <br>            lpszNameToken++; <br> <br>        //   Check if name has already been resolved <br> <br>        if (!FNameInList (lpszNameToken, *lpcRecips, *lppRecips)) <br>        { <br>            lstrcat (szResolve, lpszNameToken); <br>            lstrcat (szResolve, "; "); <br>            cRecips++; <br>        } <br> <br>        //   Get Next Token <br> <br>        lpszNameToken = _fstrtok (NULL, ";\n"); <br>    } <br> <br>    *lpszDisplayNames = '\0'; <br> <br>    if (!szResolve[0]) <br>    { <br>        ulResult = CMC_SUCCESS; <br>        goto err; <br>    } <br> <br>    szResolve[lstrlen (szResolve) - 2] = '\0'; <br> <br>    lpRecipList = (CMC_recipient *)PvAlloc((cRecips + *lpcRecips) * sizeof (CMC_recipient)); <br>    if (!lpRecipList) <br>    { <br>        ulResult = CMC_E_INSUFFICIENT_MEMORY; <br>        goto err; <br>    } <br>    _fmemset (lpRecipList, 0, (UINT)(cRecips + *lpcRecips) * sizeof (CMC_recipient)); <br> <br>    cRecips = 0; <br> <br>    while (cRecips &lt; *lpcRecips) <br>    { <br>        ulResult = CopyRecipient (lpRecipList, &amp;lpRecipList[cRecips], <br>            *lppRecips + cRecips); <br> <br>        if (ulResult) <br>        { <br>            PvFree(lpRecipList); <br>            goto err; <br>        } <br> <br>        cRecips++; <br>    } <br> <br>    PvFree(*lppRecips); <br> <br>    lpszNameToken = _fstrtok (szResolve, ";\n"); <br> <br>    while (lpszNameToken) <br>    { <br>        //   Strip leading blanks <br> <br>        while (*lpszNameToken == ' ') <br>            lpszNameToken++; <br> <br>        cNewRecip = 1; // just looking for one resolved name <br>        Recip.name      = lpszNameToken; <br>        Recip.name_type = CMC_TYPE_INDIVIDUAL; <br>        Recip.role      = ulRecipRole; <br>        Recip.recip_flags = CMC_RECIP_LAST_ELEMENT; <br>        Recip.address     = NULL; <br>        Recip.recip_extensions = NULL; <br> <br>        ulResult = CMCLookUp(lhSession, (CMC_recipient far *)&amp;Recip, <br>                             CMC_LOOKUP_RESOLVE_UI | CMC_ERROR_UI_ALLOWED <br>                             | CMC_LOOKUP_RESOLVE_PREFIX_SEARCH, <br>                             (CMC_ui_id)hWnd, &amp;cNewRecip, &amp;lpNewRecip, NULL); <br> <br>        if (ulResult == CMC_SUCCESS) <br>        { <br>            lpNewRecip-&gt;role = ulRecipRole; <br>            ulResult = CopyRecipient (lpRecipList, &amp;lpRecipList[cRecips], lpNewRecip); <br> <br>            CMCFree(lpNewRecip); <br> <br>            if(ulResult) <br>                goto cleanup; <br> <br>            cRecips++; <br>        } <br>        else <br>        { <br>            MakeMessageBox (NULL, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR); <br>            lstrcat (lpszDisplayNames, lpszNameToken); <br>            lstrcat (lpszDisplayNames, "; "); <br>            cFails++; <br>        } <br>        lpszNameToken = _fstrtok (NULL, ";\n"); <br>    } <br> <br>    //   if cFails &gt; 0 then we have partial success <br> <br>    ulResult = CMC_SUCCESS; <br> <br>    if (cFails) <br>        MakeMessageBox (hWnd, 0, IDS_UNRESOLVEDNAMES, MBS_INFO); <br> <br>cleanup: <br>    /* Re-position our LAST_ELEMENT flag in the list */ <br>    if(*lpcRecips = cRecips) <br>    { <br>        for(idx = 0; idx &lt; cRecips-1; idx++) <br>            lpRecipList[idx].recip_flags &amp;= ~CMC_RECIP_LAST_ELEMENT; <br>        lpRecipList[idx].recip_flags |= CMC_RECIP_LAST_ELEMENT; <br> <br>        *lppRecips = lpRecipList; <br>    } <br>    else <br>    { <br>        *lppRecips = NULL; <br>        PvFree(lpRecipList); <br>    } <br> <br>err: <br>    if (*lpszDisplayNames) <br>        lpszDisplayNames[lstrlen (lpszDisplayNames) - 2] = '\0'; <br> <br>    return ulResult; <br>} <br> <br> <br>// <br>//  CopyRecipient <br>// <br>//  Purpose: <br>//      Called in support of ResolveFriendlyNames() to build an array <br>//      of chained CMC_recipients. <br>// <br>//  Parameters: <br>//      lpParent        - Parent memory that allocations get chained to <br>//      lpDest          - Destination Recipient <br>//      lpSrc           - Source Recipient <br>// <br>//  Return: <br>//      ulResult <br> <br> <br>CMC_return_code <br>CopyRecipient (CMC_recipient FAR * lpParent, <br>    CMC_recipient FAR * lpDest, <br>    CMC_recipient FAR * lpSrc) <br>{ <br>    ULONG cRecipExt,cRE; <br>    lpDest-&gt;role = lpSrc-&gt;role; <br>    lpDest-&gt;name_type = lpSrc-&gt;name_type; <br>    lpDest-&gt;recip_flags = lpSrc-&gt;recip_flags; <br> <br> <br>    if (lpSrc-&gt;name) <br>    { <br>        lpDest-&gt;name = (CMC_string)PvAllocMore(lstrlen(lpSrc-&gt;name) + 1, lpParent); <br>        if (!lpDest-&gt;name) <br>                return CMC_E_INSUFFICIENT_MEMORY; <br> <br>        lstrcpy (lpDest-&gt;name, lpSrc-&gt;name); <br>    } <br>    else <br>        lpDest-&gt;name = NULL; <br> <br>    if (lpSrc-&gt;address) <br>    { <br>        lpDest-&gt;address = (CMC_string)PvAllocMore(lstrlen(lpSrc-&gt;address) + 1, lpParent); <br>        if (!lpDest-&gt;address) <br>            return CMC_E_INSUFFICIENT_MEMORY; <br> <br>        lstrcpy (lpDest-&gt;address, lpSrc-&gt;address); <br>    } <br>    else <br>        lpDest-&gt;address = NULL; <br> <br>    if(lpSrc-&gt;recip_extensions &amp;&amp; (lpSrc-&gt;recip_extensions-&gt;item_code == CMC_X_COM_RECIP_ID)) <br>    { <br> <br>        cRecipExt = 0; <br>        while (!(lpSrc-&gt;recip_extensions[cRecipExt].extension_flags &amp; CMC_EXT_LAST_ELEMENT)) <br>            cRecipExt++; <br> <br>        cRecipExt++; <br> <br>        lpDest-&gt;recip_extensions = (CMC_extension *)PvAllocMore(sizeof(CMC_extension)*cRecipExt, lpParent); <br>        if(!lpDest-&gt;recip_extensions) <br>               return CMC_E_INSUFFICIENT_MEMORY; <br> <br>        for (cRE = 0;cRE &lt; cRecipExt;cRE++) <br>        { <br> <br>            lpDest-&gt;recip_extensions[cRE].item_reference = \ <br>                   (CMC_buffer)PvAllocMore( sizeof(CMC_message_reference)+ <br>                   lpSrc-&gt;recip_extensions[cRE].item_data, lpParent); <br>            if(!lpDest-&gt;recip_extensions[cRE].item_reference) <br>                return CMC_E_INSUFFICIENT_MEMORY; <br> <br>            lpDest-&gt;recip_extensions[cRE].item_code = CMC_X_COM_RECIP_ID; <br>            lpDest-&gt;recip_extensions[cRE].item_data = lpSrc-&gt;recip_extensions[cRE].item_data; <br>            lpDest-&gt;recip_extensions[cRE].extension_flags = lpSrc-&gt;recip_extensions[cRE].extension_flags; <br>            if (lpSrc-&gt;recip_extensions[cRE].item_reference) <br>                _fmemcpy(lpDest-&gt;recip_extensions[cRE].item_reference, <br>                    lpSrc-&gt;recip_extensions[cRE].item_reference, <br>                    sizeof(CMC_message_reference)+(size_t)lpSrc-&gt;recip_extensions[cRE].item_data); <br>            else <br>                // NULL item_reference (BUG?) <br>                lpDest-&gt;recip_extensions[cRE].item_reference = lpSrc-&gt;recip_extensions[cRE].item_reference; <br> <br>        } <br> <br>    } <br>    else <br>        lpDest-&gt;recip_extensions = NULL; <br> <br>    return CMC_SUCCESS; <br>} <br> <br>// <br>//  GetNextFile <br>// <br>//  Purpose: <br>//      Called when user clicks 'Attach' button in Compose Note form. <br>//      We will build a chained memory chunk for more than one file <br>//      attachment so the memory can be freed with a single call to <br>//      CMCFree. <br>// <br>//  Parameters: <br>//      hWnd            - Window handle of Compose Note dialog <br>//      nPos            - Render position of attachment in Notetext. <br>//      lpcAttach       - Pointer to the count of attachments. <br>//      lppAttach       - Pointer to the CMC_attachment array. <br>// <br>//  Return: <br>//      ulResult. <br> <br>CMC_return_code <br>GetNextFile (HWND hWnd, ULONG nPos, ULONG * lpcAttach, <br>    CMC_attachment FAR * * lppAttach) <br>{ <br>    CMC_attachment FAR * lpAttach; <br>    CMC_attachment FAR * lpAttachT; <br>    OPENFILENAME ofn; <br>    char szAttachFilename[256] = ""; <br>    char szFilter[256]; <br>    static char szFileTitle[16]; <br>    static char szDirName[256] = ""; <br>    LPSTR lpszEndPath; <br>    ULONG idx; <br>    CMC_return_code ulResult = CMC_SUCCESS; <br> <br>    if (!szDirName[0]) <br>        GetSystemDirectory ((LPSTR) szDirName, 255); <br>    else <br>        lstrcpy (szAttachFilename, szFileTitle); <br> <br>    LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter)); <br> <br>    for (idx = 0; szFilter[idx] != '\0'; idx++) <br>        if (szFilter[idx] == '|') <br>            szFilter[idx] = '\0'; <br> <br>    ofn.lStructSize = sizeof (OPENFILENAME); <br>    ofn.hwndOwner = (HWND) NULL; <br>    ofn.hInstance = (HINSTANCE) NULL; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1L; <br>    ofn.lpstrFile = szAttachFilename; <br>    ofn.nMaxFile = 256; <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = 16; <br>    ofn.lpstrInitialDir = szDirName; <br>    ofn.lpstrTitle = "Attach"; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = NULL; <br>    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br> <br>    if (!GetOpenFileName (&amp;ofn)) <br>        return CMC_E_USER_CANCEL; <br> <br>    //   Save the directory for the next time we call this <br> <br>    lstrcpy (szDirName, szAttachFilename); <br>    if (lpszEndPath = strstr (szDirName, szFileTitle)) <br>        *(--lpszEndPath) = '\0'; <br> <br>    lpAttach = (CMC_attachment *)PvAlloc((*lpcAttach + 1) * sizeof(CMC_attachment)); <br>    if (!lpAttach) <br>        goto err; <br> <br>    _fmemset (lpAttach, 0, ((UINT) *lpcAttach + 1) *sizeof (CMC_attachment)); <br> <br>    lpAttachT = *lppAttach; <br> <br>    for (idx = 0; idx &lt; *lpcAttach; idx++) <br>        if(ulResult = CopyAttachment (lpAttach, &amp;lpAttach[idx], &amp;lpAttachT[idx])) <br>            goto err; <br> <br>    lpAttach[idx-1].attach_flags &amp;= ~CMC_ATT_LAST_ELEMENT; <br>    lpAttach[idx].attach_flags = CMC_ATT_LAST_ELEMENT; <br>    lpAttach[idx].attach_type = NULL; <br>    lpAttach[idx].attach_extensions = NULL; <br> <br>    lpAttach[idx].attach_filename = (CMC_string)PvAllocMore(lstrlen(szAttachFilename) + 1,  lpAttach); <br>    if(!lpAttach[idx].attach_filename) <br>        goto err; <br> <br>    lpAttach[idx].attach_title = (CMC_string)PvAllocMore(lstrlen(szFileTitle) + 1, lpAttach); <br>    if (!lpAttach[idx].attach_title) <br>        goto err; <br> <br>    lstrcpy (lpAttach[idx].attach_filename, szAttachFilename); <br>    lstrcpy (lpAttach[idx].attach_title, szFileTitle); <br> <br>    PvFree(lpAttachT); <br> <br>    *lppAttach = lpAttach; <br>    (*lpcAttach)++; <br> <br>err: <br>    if(ulResult) <br>        PvFree(lpAttach); <br> <br>    return ulResult; <br>} <br> <br> <br>// <br>//  CopyAttachment <br>// <br>//  Purpose: <br>//      Called in support of GetNextFile() to re-build an array <br>//      of chained CMC_attachments. <br>// <br>//  Parameters: <br>//      lpParent        - Parent memory that allocations get chained to <br>//      lpDest          - Destination Recipient <br>//      lpSrc           - Source Recipient <br>// <br>//  Return: <br>//      Void. <br> <br>ULONG <br>CopyAttachment(CMC_attachment FAR * lpParent, <br>               CMC_attachment FAR * lpDest, <br>               CMC_attachment FAR * lpSrc) <br>{ <br>    lpDest-&gt;attach_flags = lpSrc-&gt;attach_flags; <br> <br>    if (lpSrc-&gt;attach_title) <br>    { <br>        lpDest-&gt;attach_title = (CMC_string)PvAllocMore(lstrlen(lpSrc-&gt;attach_title) + 1, (LPVOID)lpParent); <br>        if (!lpDest-&gt;attach_title) <br>            return CMC_E_INSUFFICIENT_MEMORY; <br> <br>        lstrcpy (lpDest-&gt;attach_title, lpSrc-&gt;attach_title); <br>    } <br>    else <br>        lpDest-&gt;attach_title = NULL; <br> <br>    if (lpSrc-&gt;attach_type) <br>    { <br>        lpDest-&gt;attach_type = (CMC_object_identifier)PvAllocMore(lstrlen(lpSrc-&gt;attach_type) + 1, (LPVOID)lpParent); <br>        if (!lpDest-&gt;attach_type) <br>            return CMC_E_INSUFFICIENT_MEMORY; <br> <br>        lstrcpy (lpDest-&gt;attach_type, lpSrc-&gt;attach_type); <br>    } <br>    else <br>        lpDest-&gt;attach_type = NULL; <br> <br>    if (lpSrc-&gt;attach_filename) <br>    { <br>        lpDest-&gt;attach_filename = (CMC_string)PvAllocMore(lstrlen(lpSrc-&gt;attach_filename) + 1, (LPVOID)lpParent); <br>        if (!lpDest-&gt;attach_filename) <br>            return CMC_E_INSUFFICIENT_MEMORY; <br> <br>        lstrcpy (lpDest-&gt;attach_filename, lpSrc-&gt;attach_filename); <br>    } <br>    else <br>        lpDest-&gt;attach_filename = NULL; <br> <br>    lpDest-&gt;attach_extensions = NULL; <br> <br>    return CMC_SUCCESS; <br>} <br> <br> <br>// <br>//  FNameInList <br>// <br>//  Purpose: <br>//      To find lpszName in an array of recipients.  Used to determine <br>//      if user name has already been resolved. <br>// <br>//  Parameters: <br>//      lpszName        - Friendly name to search for </code></pre>
<p>
</p>
<pre><code>//      cRecips         - Count of recipients in lpRecips <br>//      lpRecips        - Array of CMC_recipients <br>// <br>//  Return: <br>//      TRUE/FALSE <br> <br> <br>BOOL <br>FNameInList (LPSTR lpszName, ULONG cRecips, CMC_recipient FAR * lpRecips) <br>{ <br>    //   Case sensitive compare of each friendly name in list. <br> <br>    if (!cRecips || !lpRecips) <br>        return FALSE; <br> <br>    while (cRecips--) <br>        if (!lstrcmp (lpszName, lpRecips[cRecips].name)) <br>            return TRUE; <br> <br>    return FALSE; <br>} <br> <br> <br>// <br>//  DrawMsgItem <br>// <br>//  Purpose: <br>//      Paint the client area of the owner drawn listbox. <br>// <br>//  Parameters: <br>//      pdis        - Pointer to a DRAWITEMSTRUCT <br>//      cMsgIds     - Count of MsgId structs in List of current messages <br>//      lpMsgIds    - Pointer to linked-list of MsgIds <br>// <br>//  Returns: <br>//      void <br>// <br> <br> <br>void <br>DrawMsgItem (DRAWITEMSTRUCT * pdis) <br>{ <br>    LPMSGID lpMsg; <br>    HBITMAP hBmp; <br>    char szDateRec[32]; <br>    HBRUSH hSolidBrush, hOldBrush; <br> <br>    hSolidBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>    hOldBrush = SelectObject(pdis-&gt;hDC, hSolidBrush); <br> <br>    if (ODA_DRAWENTIRE &amp; pdis-&gt;itemAction) <br>    { <br>        //   Clear the item Rectangle <br> <br>        PatBlt (pdis-&gt;hDC, pdis-&gt;rcItem.left, pdis-&gt;rcItem.top, <br>            pdis-&gt;rcItem.right - pdis-&gt;rcItem.left, <br>            pdis-&gt;rcItem.bottom - pdis-&gt;rcItem.top, PATCOPY); <br> <br>        //   Draw the item <br> <br>        lpMsg = (LPMSGID) pdis-&gt;itemData; <br> <br>        if (lpMsg-&gt;fRead) <br>        { <br>            if (lpMsg-&gt;fHasAttach) <br>                hBmp = hReadABmp; <br>            else <br>                hBmp = hReadBmp; <br>        } <br>        else <br>        { <br>            if (lpMsg-&gt;fHasAttach) <br>                hBmp = hUnReadABmp; <br>            else <br>                hBmp = hUnReadBmp; <br>        } <br> <br>        DrawMsgIcon (pdis-&gt;hDC, hBmp, pdis-&gt;rcItem.left + 2, pdis-&gt;rcItem.top, <br>            pdis-&gt;rcItem.left + 18, pdis-&gt;rcItem.top + 15); <br> <br> <br>        // Show originator <br>        TextOut (pdis-&gt;hDC, pdis-&gt;rcItem.left + 20, pdis-&gt;rcItem.top+2, <br>            (lpMsg-&gt;from ? lpMsg-&gt;from : ""), <br>            lstrlen ((lpMsg-&gt;from ? lpMsg-&gt;from : ""))); <br> <br> <br>        // Show subject <br>        TextOut (pdis-&gt;hDC, pdis-&gt;rcItem.left + 120, pdis-&gt;rcItem.top+2, <br>            (lpMsg-&gt;subject ? lpMsg-&gt;subject : ""), <br>            lstrlen ((lpMsg-&gt;subject ? lpMsg-&gt;subject : ""))); <br> <br>        // Show time sent <br>        ConvertDateRec (&amp;lpMsg-&gt;time_sent, szDateRec); <br>        TextOut (pdis-&gt;hDC, pdis-&gt;rcItem.left + 270, pdis-&gt;rcItem.top+2, <br>            szDateRec, lstrlen (szDateRec)); <br> <br>        //   Invert item rectangle if item is selected <br> <br>        if (ODS_SELECTED &amp; pdis-&gt;itemState) <br>            PatBlt (pdis-&gt;hDC, pdis-&gt;rcItem.left, pdis-&gt;rcItem.top, <br>                pdis-&gt;rcItem.right - pdis-&gt;rcItem.left, <br>                pdis-&gt;rcItem.bottom - pdis-&gt;rcItem.top, DSTINVERT); <br> <br>        //   Draw a focus rectangle if item has focus <br> <br>        if (ODS_FOCUS &amp; pdis-&gt;itemState) <br>            DrawFocusRect (pdis-&gt;hDC, &amp;pdis-&gt;rcItem); <br>    } <br>    else <br>    { <br>        //   Invert the item if the selection state is changing <br> <br>        if (ODA_SELECT &amp; pdis-&gt;itemAction) <br>            PatBlt (pdis-&gt;hDC, pdis-&gt;rcItem.left, pdis-&gt;rcItem.top, <br>                pdis-&gt;rcItem.right - pdis-&gt;rcItem.left, <br>                pdis-&gt;rcItem.bottom - pdis-&gt;rcItem.top, DSTINVERT); <br> <br>        //   Draw a focus if the focus state is changing <br> <br>        if (ODA_FOCUS &amp; pdis-&gt;itemAction) <br>            DrawFocusRect (pdis-&gt;hDC, &amp;pdis-&gt;rcItem); <br>    } <br> <br>    SelectObject(pdis-&gt;hDC, hOldBrush); <br>    DeleteObject(hSolidBrush); <br>} <br> <br>// <br>//  DrawMsgIcon <br>// <br>//  Purpose: <br>//      Paint the client area of an owner drawn List Box. <br>// <br>//  Parameters: <br>//      hDC         - Device context of button to be drawn on <br>//      hBitMap     - Handle to a bitmap <br>//      lx          - Upper left x coordinate <br>//      ly          - Upper left y coordinate <br>//      lcx         - Width of paint area <br>//      lcy         - Height of paint area <br>// <br>//  Returns: <br>//      None. <br>// <br> <br> <br>void <br>DrawMsgIcon (HDC hDC, HBITMAP hBmp, int x, int y, int cx, int cy) <br>{ <br>    HDC hDCMem; <br>    HBITMAP hBmpOld; <br> <br>    hDCMem = CreateCompatibleDC (hDC); <br>    hBmpOld = SelectObject (hDCMem, hBmp); <br> <br>    if (hBmpOld) <br>    { <br>        BitBlt (hDC, x, y, cx, cy, hDCMem, 0, 0, SRCCOPY); <br>        SelectObject (hDCMem, hBmpOld); <br>    } <br> <br>    DeleteDC (hDCMem); <br>} <br> <br>// <br>//  ConvertDateRec <br>// <br>//  Purpose: <br>//      To convert the CMC_time field of a message to a <br>//      more paletable display format; namely: mm/dd/yy hh:mmAM. <br>// <br>//  Parameters: <br>//      stime         - Original format <br>//      lpszDateDisplay     - Display format <br>// <br>//  Return: <br>//      Void. <br> <br> <br>void <br>ConvertDateRec (CMC_time far *lpTime, LPSTR lpszDateDisplay) <br>{ <br>    static char szCentury[2][3] = <br>    {"19", "20"}; <br> <br>    static char szAMPM[2][3] = <br>    {"AM", "PM"}; <br> <br> <br>    wsprintf (lpszDateDisplay, "%i/%i/%s%2.2i %i:%2.2i%s", <br>        lpTime-&gt;month+1, // zero based <br>        lpTime-&gt;day, <br>         szCentury[(lpTime-&gt;year &gt; 99 ? 1 : 0)], <br>        (lpTime-&gt;year &gt; 99) ? lpTime-&gt;year - 100 : lpTime-&gt;year, <br>        (lpTime-&gt;hour == 0) ? 12 : ((lpTime-&gt;hour &gt; 12) ? lpTime-&gt;hour - 12 : lpTime-&gt;hour), <br>        lpTime-&gt;minute, <br>        szAMPM[(lpTime-&gt;hour &gt; 11 ? 1 : 0)]); <br>} <br> <br>// <br>//  MakeMsgNode <br>// <br>//  Purpose: <br>//      Allocate memory for a new MSGID node and initialize its <br>//      data members to the values passed in. <br>// <br>//  Parameters: <br>//      lpMsg           - Pointer to a CMC_message <br>//      msgReference       - Opaque message identifier <br>// <br>//  Return: <br>//      lpMsgNode       - Pointer to new node <br> <br> <br>LPMSGID <br>MakeMsgNode (CMC_message_summary FAR *lpMsgSummary) <br>{ <br>    CMC_return_code ulResult; <br>    LPMSGID lpMsgNode = NULL; <br>    CMC_message far * lpMessage; <br> <br>    if (!lpMsgSummary) <br>        goto err; <br> <br> <br>    lpMsgNode = (LPMSGID)PvAlloc(sizeof(MSGID)); <br>    if (!lpMsgNode) <br>        goto err; <br> <br>    _fmemset (lpMsgNode, 0, sizeof (MSGID)); <br> <br>    // copy message regerence <br>    lpMsgNode-&gt;message_reference = (CMC_message_reference *)PvAllocMore( \ <br>            sizeof(CMC_message_reference)+lpMsgSummary-&gt;message_reference-&gt;length, <br>            lpMsgNode); <br> <br>    _fmemcpy(lpMsgNode-&gt;message_reference-&gt;string, <br>             lpMsgSummary-&gt;message_reference-&gt;string, <br>             (size_t) lpMsgSummary-&gt;message_reference-&gt;length); <br> <br>    lpMsgNode-&gt;message_reference-&gt;length = lpMsgSummary-&gt;message_reference-&gt;length; <br> <br>    // Who is the originator? <br>    if (lpMsgSummary-&gt;originator) <br>    { <br>        if (lpMsgSummary-&gt;originator-&gt;name) <br>        { <br>            lpMsgNode-&gt;from = (CMC_string)PvAllocMore(lstrlen(lpMsgSummary-&gt;originator-&gt;name) + 1, lpMsgNode); <br>            if (!lpMsgNode-&gt;from) <br>                goto err; <br>     <br>            lstrcpy (lpMsgNode-&gt;from, lpMsgSummary-&gt;originator-&gt;name); <br>        } <br>        else <br>        { <br>            lpMsgNode-&gt;from = NULL; <br>        } <br>    } <br>    else <br>    { <br>        lpMsgNode-&gt;from = NULL; <br>    } <br> <br> <br>    // What is the subject? <br>    if (lpMsgSummary-&gt;subject) <br>    { <br>        lpMsgNode-&gt;subject = (CMC_string)PvAllocMore(lstrlen(lpMsgSummary-&gt;subject) + 1, lpMsgNode); <br>        if (!lpMsgNode-&gt;subject) <br>            goto err; <br> <br>        lstrcpy (lpMsgNode-&gt;subject, lpMsgSummary-&gt;subject); <br>    } <br>    else <br>    { <br>        lpMsgNode-&gt;subject = NULL; <br>    } <br> <br>    // Time sent <br>    _fmemcpy(&amp;lpMsgNode-&gt;time_sent, &amp;lpMsgSummary-&gt;time_sent, sizeof(CMC_time)); <br> <br>    // Query Attachments and Read/Unread status <br>    ulResult = CMCRead( lhSession, lpMsgSummary-&gt;message_reference, <br>                CMC_MSG_AND_ATT_HDRS_ONLY | CMC_DO_NOT_MARK_AS_READ,  <br>                &amp;lpMessage, (CMC_ui_id)NULL, NULL ); <br>         <br>    if ( ulResult ) <br>        goto err; <br> <br>    if (!ulResult &amp;&amp; lpMessage-&gt;attachments) <br>        lpMsgNode-&gt;fHasAttach = CMC_TRUE; <br> <br>    // Has the message been read? <br>    if (lpMessage-&gt;message_flags &amp; CMC_MSG_READ) <br>        lpMsgNode-&gt;fRead = CMC_TRUE; <br>    else <br>        lpMsgNode-&gt;fRead = CMC_FALSE; <br> <br>     <br>    CMCFree( lpMessage ); <br> <br>    lpMsgNode-&gt;lpPrev = NULL; <br>    lpMsgNode-&gt;lpNext = NULL; <br> <br>    return lpMsgNode; <br> <br>err: <br>    PvFree(lpMsgNode); <br>    return NULL; <br>} <br> <br>// <br>//  InsertMsgNode <br>// <br>//  Purpose: <br>//      Currently (for simplicity) we will insert the nodes <br>//      at the beginning of the list.  This can later be <br>//      replaced with a routine that can insert sorted on <br>//      different criteria, like DateReceived, From, or <br>//      Subject.  But for now... <br>// <br>//  Parameters: <br>//      lpMsgNode       - Pointer to a MSGID node <br>//      lppMsgHead      - Pointer to the head of the list <br>// <br>//  Return: <br>//      Void. <br> <br> <br>void <br>InsertMsgNode (LPMSGID lpMsgNode, LPMSGID  * lppMsgHead) <br>{ <br>    if (*lppMsgHead) <br>    { <br>        lpMsgNode-&gt;lpNext = *lppMsgHead; <br>        (*lppMsgHead)-&gt;lpPrev = lpMsgNode; <br>    } <br>    else <br>        lpMsgNode-&gt;lpNext = NULL; <br> <br>    //   The next 2 assignments are here in case the node came from somewhere <br>    //   other than a call to MakeMsgNode () in which case we aren't sure <br>    //   they're already NULL. <br> <br>    lpMsgNode-&gt;lpPrev = NULL; <br>    *lppMsgHead = lpMsgNode; <br>} <br> <br>// <br>//  DeleteMsgNode <br>// <br>//  Purpose: <br>//      Removes the node passed in from the list.  This <br>//      may seem like a strange way to do this but it's <br>//      not, because the Owner-Drawn List Box gives us <br>//      direct access to elements in the list that makes <br>//      it easier to do things this way. <br>// <br>//  Parameters: <br>//      lpMsgNode       - Pointer to the MSGID node to delete <br>//      lppMsgHead      - Pointer to the head of the list <br>// <br>//  Return: <br>//      Void. <br> <br> <br>void <br>DeleteMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead) <br>{ <br>    if (!lpMsgNode) <br>        return; <br> <br>    //   Check if we are the first node <br> <br>    if (lpMsgNode-&gt;lpPrev) <br>        lpMsgNode-&gt;lpPrev-&gt;lpNext = lpMsgNode-&gt;lpNext; <br> <br>    //   Check if we are the last node <br> <br>    if (lpMsgNode-&gt;lpNext) <br>        lpMsgNode-&gt;lpNext-&gt;lpPrev = lpMsgNode-&gt;lpPrev; <br> <br>    //   check if we are the only node <br> <br>    if(lpMsgNode == *lppMsgHead) <br>        *lppMsgHead = NULL; <br> <br>    PvFree(lpMsgNode); <br>    return; <br>} <br> <br> <br> <br>// <br>//  FindNode <br>// <br>//  Purpose: <br>//      Returns a pointer to the node containing msgReference. <br>//      Returns NULL if node doesn't exist or msgReference is NULL. <br>// <br>//  Parameters: <br>//      lpMsgHead       - Pointer to the head of the list <br>//      msgReference       - Message ID to search for <br>// <br>//  Return: <br>//      lpMsgNode       - Pointer to the node returned <br> <br> <br>LPMSGID <br>FindNode (LPMSGID lpMsgHead, CMC_message_reference FAR *msgReference) <br>{ <br>    if (!msgReference) <br>        return NULL; <br> <br>    while (lpMsgHead) <br>    { <br>        if ((lpMsgHead-&gt;message_reference-&gt;length == msgReference-&gt;length) &amp;&amp; <br>                !_fmemcmp((void far *)lpMsgHead-&gt;message_reference-&gt;string, <br>                      (void far *)msgReference-&gt;string, (size_t)msgReference-&gt;length)) <br>            break; <br> <br>        lpMsgHead = lpMsgHead-&gt;lpNext; <br>    } <br> <br>    return lpMsgHead; <br>} <br> <br> <br> <br>// <br>//  FreeMsgList <br>// <br>//  Purpose: <br>//      Walks down the MsgList and frees each node. <br>// <br>//  Parameters: <br>//      lpMsgHead       - Pointer to the head of the list <br>// <br>//  Return: <br>//      Void. <br> <br> <br>void <br>FreeMsgList (LPMSGID lpMsgHead) <br>{ <br>    LPMSGID lpT; <br> <br>    while (lpMsgHead) <br>    { <br>        lpT = lpMsgHead; <br>        lpMsgHead = lpMsgHead-&gt;lpNext; <br>        PvFree(lpT); <br>    } <br>} <br> <br>// <br>//  MakeDisplayNameStr <br>// <br>//  Purpose: <br>//      Finds all recipients of type ulRecipRole in lpRecips and adds <br>//      their friendly name to the display string. <br>// <br>//  Parameters: <br>//      lpszDisplay         - Destination string for names <br>//      ulRecipRole        - Recipient types to search for <br>//      cRecips             - Count of recipients in lpRecips <br>//      lpRecips            - Pointer to array of CMC_recipients <br>// <br>//  Return: <br>//      Void. <br> <br> <br>void <br>MakeDisplayNameStr (LPSTR lpszDisplay, CMC_enum ulRecipRole, <br>    ULONG cRecips, CMC_recipient FAR * lpRecips) <br>{ <br>    ULONG idx; <br> <br>    *lpszDisplay = '\0'; <br> <br>    for (idx = 0; idx &lt; cRecips; idx++) <br>    { <br>        if (lpRecips[idx].role == ulRecipRole) <br>        { <br>            lstrcat (lpszDisplay, lpRecips[idx].name); <br>            lstrcat (lpszDisplay, "; "); <br>        } <br>    } <br> <br>    if (*lpszDisplay) <br>        lpszDisplay[lstrlen (lpszDisplay) - 2] = '\0'; <br>} <br> <br> <br>// <br>//  SaveMsgChanges <br>// <br>//  Purpose: <br>//      If while reading a message the user changes the notetext at all <br>//      then this function is called to save those changes in the Inbox. <br>// <br>//  Parameters: <br>//      hWnd            - handle to the window/dialog who called us <br>//      lpMsg           - pointer to the CMC message to be saved <br>//      msgReference       - ID of the message to save <br>// <br>//  Return: <br>//      ulResult        - Indicating success/failure <br> <br> <br>CMC_return_code <br>SaveMsgChanges (HWND hWnd, CMC_message far *lpMsg) <br>{ <br>    LPSTR lpszT; <br>    LPSTR lpszTextNote = NULL; <br>    LONG cLines, cb; <br>    CMC_return_code ulResult = CMC_SUCCESS; <br>    CMC_extension   ext; <br> <br>    lpszT = lpMsg-&gt;text_note; <br> <br>    cLines = SendDlgItemMessage (hWnd, IDC_READNOTE, EM_GETLINECOUNT, 0, 0L); <br>    cb = (LRESULT) SendDlgItemMessage (hWnd, <br>                IDC_READNOTE, <br>                EM_LINEINDEX, <br>                (WPARAM) cLines - 1, <br>                0L); <br>    cb += (LRESULT) SendDlgItemMessage (hWnd, IDC_READNOTE, EM_LINELENGTH, (WPARAM)cb, 0L); <br>    cb += cLines * 2; <br> <br>    lpszTextNote = (LPSTR)PvAlloc(cb + 1 ); <br> <br>    if (!lpszTextNote) <br>        goto err; <br> <br>    SendDlgItemMessage (hWnd, IDC_READNOTE, WM_GETTEXT, <br>        (WPARAM) cb, (LPARAM) lpszTextNote); <br> <br>    lpMsg-&gt;text_note = lpszTextNote; <br> <br>    ext.item_data       = 0; <br>    ext.item_code       = CMC_X_COM_SAVE_MESSAGE; <br>    ext.item_reference  = (CMC_buffer)lpMsg; <br>    ext.extension_flags = CMC_EXT_REQUIRED | CMC_EXT_LAST_ELEMENT; <br> <br>    ulResult = CMCActOn(lhSession, lpMsg-&gt;message_reference, CMC_ACT_ON_EXTENDED, <br>                        CMC_ERROR_UI_ALLOWED, (CMC_ui_id)hWnd, &amp;ext); <br> <br>    PvFree(lpszTextNote); <br> <br>err: <br>    lpMsg-&gt;text_note = lpszT; <br>    return ulResult; <br>} <br> <br>// <br>//  MakeNewMessage <br>// <br>//  Purpose: <br>//      This function is used to construct a new message for the <br>//      ComposeNote UI.  This gets called as a result of a Reply, <br>//      ReplyAll, or a Forward action on a message being read. <br>//      The destination for the new message is CmcMsg, the global <br>//      CMC_message struct pointer used by ComposeNoteDlgProc. <br>//      ComposeNoteDlgProc always frees the memory consumed by <br>//      this object whether it allocated it or not. <br>// <br>//  Parameters: <br>//      lpSrcMsg            - CMC_message to be copied <br>//      flType              - Specifies the action that caused this call <br>//                            either: IDC_REPLY, IDC_REPLYALL, or IDC_FORWARD <br>// <br>//  Return: <br>//      ulResult            - Indicates success/failure <br> <br> <br>CMC_return_code <br>MakeNewMessage (CMC_message far *lpSrcMsg, CMC_flags flType) <br>{ <br> <br>#define REPLY_SEPERATOR "\r\n--------------------------\r\n" <br> <br>    ULONG cOldRecips; <br>    ULONG cNewRecips; <br>    ULONG cAttach; <br>    ULONG idx; <br>    CMC_return_code     ulResult = CMC_SUCCESS; <br>    CMC_uint32          cCurrentUser = 1; <br>    CMC_recipient FAR * CurrentUser = NULL; <br> <br> <br>    if (!lpSrcMsg) <br>        return CMC_E_FAILURE; <br> <br>    if(CmcMsg) <br>        PvFree(CmcMsg); <br> <br>    CmcMsg = (CMC_message far *)PvAlloc(sizeof(CMC_message)); <br> <br>    if (!CmcMsg) <br>        goto err; <br> <br>    _fmemset (CmcMsg, 0, sizeof (CMC_message)); <br> <br>    if (lpSrcMsg-&gt;subject) <br>    { <br>        CmcMsg-&gt;subject = (LPSTR)PvAlloc(lstrlen(lpSrcMsg-&gt;subject) + 5); <br>        if (!CmcMsg-&gt;subject) <br>            goto err; <br> <br>        if (flType == IDC_FORWARD) <br>            lstrcpy (CmcMsg-&gt;subject, "FW: "); <br>        else <br>            lstrcpy (CmcMsg-&gt;subject, "RE: "); <br> <br>        lstrcat (CmcMsg-&gt;subject, lpSrcMsg-&gt;subject); <br>    } <br> <br>    if (lpSrcMsg-&gt;text_note) <br>    { <br>        CmcMsg-&gt;text_note = (CMC_string)PvAlloc(lstrlen(lpSrcMsg-&gt;text_note) + 32); <br>        if (!CmcMsg-&gt;text_note) <br>            goto err; <br> <br>        lstrcpy (CmcMsg-&gt;text_note, REPLY_SEPERATOR); <br>        lstrcat (CmcMsg-&gt;text_note, lpSrcMsg-&gt;text_note); <br>    } <br> <br>    if (lpSrcMsg-&gt;message_type) <br>    { <br>        CmcMsg-&gt;message_type = (CMC_string)PvAlloc(lstrlen(lpSrcMsg-&gt;message_type) + 1); <br>        if (!CmcMsg-&gt;message_type) <br>            goto err; <br> <br>        lstrcpy (CmcMsg-&gt;message_type, lpSrcMsg-&gt;message_type); <br>    } <br> <br>    if (lpSrcMsg-&gt;attachments) <br>    { <br>        cAttach = 0; <br>        while (!(lpSrcMsg-&gt;attachments[cAttach].attach_flags &amp; CMC_ATT_LAST_ELEMENT)) <br>            cAttach++; <br> <br>        cAttach++; <br> <br>        CmcMsg-&gt;attachments = (CMC_attachment far *)PvAlloc(cAttach * sizeof(CMC_attachment)); <br>        if (!CmcMsg-&gt;attachments) <br>            goto err; <br> <br>        _fmemset (CmcMsg-&gt;attachments, 0, (size_t)cAttach*sizeof(CMC_attachment)); <br> <br>        for (idx = 0; idx &lt; cAttach; idx++) <br>            CopyAttachment (CmcMsg-&gt;attachments, &amp;CmcMsg-&gt;attachments[idx], &amp;lpSrcMsg-&gt;attachments[idx]); <br> <br>    } <br> <br>    if (flType == IDC_REPLY || flType == IDC_REPLYALL) <br>    { <br>        cOldRecips = 0; <br> <br>        while (!(lpSrcMsg-&gt;recipients[cOldRecips].recip_flags &amp; CMC_RECIP_LAST_ELEMENT)) <br>            cOldRecips++; <br>        cOldRecips++; <br> <br>        if(flType == IDC_REPLYALL) <br>            cNewRecips = cOldRecips; <br>        else <br>            cNewRecips = 1; <br> <br>        CmcMsg-&gt;recipients = (CMC_recipient far *)PvAlloc(cNewRecips * sizeof(CMC_recipient)); <br> <br>        if (!CmcMsg-&gt;recipients) <br>            goto err; <br> <br>        _fmemset (CmcMsg-&gt;recipients, 0, (size_t)cNewRecips*sizeof(CMC_recipient)); <br> <br>        // Look up current user address <br>        ulResult = CMCLookUp(lhSession, NULL, CMC_LOOKUP_RESOLVE_IDENTITY, <br>                             (CMC_ui_id)NULL, &amp;cCurrentUser, &amp;CurrentUser, NULL); <br> <br>        cNewRecips = 0; <br>        for (idx = 0; idx &lt; cOldRecips; idx++) <br>        { <br>            // Always Reply to the originator and change their role <br>            if (lpSrcMsg-&gt;recipients[idx].role == CMC_ROLE_ORIGINATOR) <br>            { <br>                CopyRecipient(CmcMsg-&gt;recipients, &amp;CmcMsg-&gt;recipients[cNewRecips], <br>                              &amp;lpSrcMsg-&gt;recipients[idx]); <br>                CmcMsg-&gt;recipients[cNewRecips].role = CMC_ROLE_TO; <br>                cNewRecips++; <br>                if(flType == IDC_REPLY) <br>                    break; <br>            } <br>            else if((flType == IDC_REPLYALL) &amp;&amp; <br>                    (ulResult || lstrcmp(lpSrcMsg-&gt;recipients[idx].address, <br>                                         CurrentUser-&gt;address))) <br>            { <br>                // Don't reply to ourselves if replying to all <br>                CopyRecipient(CmcMsg-&gt;recipients, &amp;CmcMsg-&gt;recipients[cNewRecips], <br>                              &amp;lpSrcMsg-&gt;recipients[idx]); <br>                cNewRecips++; <br>            } <br>        } <br> <br>        if(cNewRecips) <br>            CmcMsg-&gt;recipients[cNewRecips-1].recip_flags |= CMC_RECIP_LAST_ELEMENT; <br> <br>        CMCFree(CurrentUser); <br>    } <br> <br>    return ulResult; <br> <br>err: <br>    PvFree(CmcMsg-&gt;subject); <br>    PvFree(CmcMsg-&gt;text_note); <br>    PvFree(CmcMsg-&gt;message_type); <br>    PvFree(CmcMsg-&gt;recipients); <br>    PvFree(CmcMsg-&gt;attachments); <br>    PvFree(CmcMsg); <br>    CmcMsg = NULL; <br> <br>    return ulResult; <br>} <br> <br>// <br>//  LogSendMail <br>// <br>//  Purpose: <br>//      Used to track how many messages were sent with this client. <br>//      This information is used strictly for gathering stats on <br>//      how many messages were pumped through the spooler/transport. <br>// <br>//  Usage: <br>//      Add the following to the win.ini file: <br>//          [CMC Client] <br>//          LogFile=filepath <br>// <br>//      where: filepath can be a full UNC path or some local path &amp; file <br>// <br>//  Parameters: <br>//      ulResult        - Currently unused; should be used to count errors <br>// <br>//  Result: <br>//      Void. <br> <br> <br>void LogSendMail(ULONG ulResult) <br>{ <br>    char szLogFile[128]; <br>    char szCount[32]; <br>    OFSTRUCT ofs; <br>    HFILE hf = HFILE_ERROR; <br>    int cSent = 1; <br> <br>    if(!GetProfileString("CMC Client", "LogFile", "CMCcli.log", <br>            szLogFile, sizeof(szLogFile))) <br>        return; <br> <br>    if((hf = OpenFile(szLogFile, &amp;ofs, OF_READWRITE)) == HFILE_ERROR) <br>    { <br>        if((hf = OpenFile(szLogFile, &amp;ofs, OF_CREATE|OF_READWRITE)) == HFILE_ERROR) <br>            return; <br>    } <br>    else <br>    { <br>        if(!_lread(hf, szCount, sizeof(szCount))) <br>        { <br>            _lclose(hf); <br>            return; <br>        } <br> <br>        cSent = atoi(szCount) + 1; <br>    } <br> <br>    wsprintf(szCount, "%d", cSent); <br> <br>    _llseek(hf, 0, 0); <br> <br>    _lwrite(hf, szCount, lstrlen(szCount)); <br>    _lclose(hf); <br> <br>    return; <br>} <br> <br>// <br>//  SaveFileAttachments <br>// <br>//  Purpose: <br>//      Displays a 'Save As' common dialog to allow the user to save <br>//      file attachments contained in the current message. <br>// <br>//  Parameters: <br>//      hWnd            - Window handle of calling WndProc <br>//      cFiles          - Count of the files in the file array <br>//      lpFiles         - Array of CMC_attachments <br>// <br>//  Return: <br>//      Void. <br> <br> <br>void SaveFileAttachments(HWND hWnd, CMC_attachment FAR * lpFile) <br>{ <br>    OPENFILENAME ofn; <br>    char szFileName[256]; <br>    char szFilter[256]; <br>    static char szFileTitle[16]; <br>    static char szDirName[256] = ""; <br>    LPSTR lpszEndPath; <br>    ULONG idx; <br>#ifdef WIN16 <br>    OFSTRUCT ofStrSrc; <br>    OFSTRUCT ofStrDest; <br>    HFILE hfSrcFile, hfDstFile; <br>#endif <br> <br>    _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br> <br>    if (!lpFile) <br>        return; <br> <br>    if (!szDirName[0]) <br>        GetWindowsDirectory ( szDirName,sizeof(szDirName)); <br> <br>    LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter)); <br> <br>    for (idx = 0; szFilter[idx] != '\0'; idx++) <br>        if (szFilter[idx] == '|') <br>            szFilter[idx] = '\0'; <br> <br>    lstrcpy(szFileName, lpFile-&gt;attach_title); <br> <br>    ofn.lStructSize = sizeof (OPENFILENAME); <br>    ofn.hwndOwner = hWnd; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrFile = szFileName; <br>    ofn.nMaxFile = sizeof(szFileName); <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = sizeof(szFileTitle); <br>    ofn.lpstrInitialDir = szDirName; <br>    ofn.lpstrTitle = "Save Attachment"; <br>    ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY; <br> <br>    if (!GetSaveFileName (&amp;ofn)) <br>        return; <br> <br>    //   Save the directory for the next time we call this <br> <br>    lstrcpy (szDirName, szFileName); <br>    if (lpszEndPath = strstr (szDirName, szFileTitle)) <br>        *(--lpszEndPath) = '\0'; <br> <br>#ifdef WIN16 <br>    // Use CopyLZFile to copy the file. <br>    // Open, copy, and then close the file. <br> <br>    hfSrcFile = LZOpenFile(lpFile-&gt;attach_filename, &amp;ofStrSrc, OF_READ); <br> <br>    hfDstFile = LZOpenFile(szFileName, &amp;ofStrDest, OF_CREATE); <br>    if (LZCopy(hfSrcFile, hfDstFile) &lt; 0) <br>        MakeMessageBox (hWnd, 0, IDS_SAVEATTACHERROR, MBS_ERROR); <br>    LZClose(hfSrcFile); <br>    LZClose(hfDstFile); <br> <br>#else <br>    /* Use CopyFile to carry out the operation. */ <br> <br>    if(!CopyFile(lpFile-&gt;attach_filename, szFileName, FALSE)) <br>        MakeMessageBox (hWnd, 0, IDS_SAVEATTACHERROR, MBS_ERROR); <br>#endif <br> <br>} <br> <br>// <br>//  ToggleMenuState <br>// <br>//  Purpose: <br>//      Enables/Disables menu items depending on the session state. <br>// <br>//  Parameters: <br>//      hWnd            - handle to the window/dialog who called us <br>//      fLoggedOn       - TRUE if logged on, FALSE if logged off <br>// <br>//  Return: <br>//      Void. <br>// <br> <br>void ToggleMenuState(HWND hWnd, BOOL fLoggedOn) <br>{ <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGOFF,         !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_COMPOSE_CMC,    !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_COMPOSE_CUSTOM, !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_READ,           !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_ADDRBOOK,       !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGON,          fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,           FALSE); <br>} <br> <br>// <br>//  SecureMenu <br>// <br>//  Purpose: <br>//      Enables/Disables Logon and Exit menu items. <br>//      CMCLogon might yield control to Windows, so the user might be able to <br>//      access the window menu (for example click Logon) after we call <br>//      CMCLogon, but before it returns. <br>// <br>//  Parameters: <br>//      hWnd            - handle to the window/dialog who called us <br>//      fBeforeLogon    - TRUE when this function is called when we are about <br>//                      to call CMCLogon, FALSE if called after logon (failed) <br>//                      if Logon succeddes ToggleMenuState is called instead of <br>//                      this function. <br>// <br>//  Return: <br>//      Void. <br>// <br> <br> <br>void SecureMenu(HWND hWnd, BOOL fBeforeLogon) <br>{ <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGON, fBeforeLogon); <br>    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,  fBeforeLogon); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
