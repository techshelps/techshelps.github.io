<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FORM.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2035"></a>FORM.CPP</h2>
<pre><code>/* -------------------------------------------------------------------------- <br> <br>Basic Forms example of a custom sendable form.  It is an EXE server <br>rather than a DLL.  It implements the minimum form interface required <br>to launch and send a form. <br> <br>Copyright (C) 1995 Microsoft Corporation <br> <br>-------------------------------------------------------------------------- */ <br> <br>//#define ALLOW_SUBCLASS_IPM // all other forms to subclass the reply behavior <br>                             // of this form (slower, but more correct) <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;ole2.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;mapiform.h&gt; <br>#define INITGUID <br>#include &lt;initguid.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapinls.h&gt; <br>#include "dbugit.h" <br>#include "check.h" <br>#include "form.h" <br>#include "dlg.h" <br> <br>/* <br> *   <br> * Checkers form clsid.  This must match the configuration file. <br> *   <br> */ <br> <br>DEFINE_GUID(CLSID_MyFormsClsId,  0x86174010, 0x5030, 0x0076, 0x99, 0x12, 0x00, 0xaa, 0x00, 0x38, 0x90, 0x1b); <br> <br>/* <br> *  HrStartOleAndRegisterClassFactory <br> * <br> *  Purpose: <br> *      Initialize OLE, MAPI, and the Forms Interface <br> *      Should be called from WinMain() or InitApplication() in an SDI app <br> * <br> *      This function LoadLibraries the neccessary DLLs rather than <br> *      linking with them.  This permits the form to run as a stand- <br> *      alone executable even when MAPI and OLE are not installed. <br> * <br> *  Returns: <br> *      HRESULT <br> */ <br> <br>#ifdef _WIN32 <br>#define szOleDll  "ole32.dll" <br>#define szMapiDll "mapi32.dll" <br>#else <br>#define szOleDll  "compobj.dll" <br>#define szMapiDll "mapi.dll" <br>#endif <br> <br>HINSTANCE hinstOle   = NULL; <br>HINSTANCE hinstMapi  = NULL; <br> <br> <br>typedef HRESULT (FAR PASCAL *LPFNCOREGISTERCLASSOBJECT)(REFCLSID rclsid, <br>    IUnknown FAR * pUnk, DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister); <br>#ifdef WIN16 <br>typedef BOOL (FAR PASCAL *LPFNISEQUALGUID)(REFGUID rguid1, REFGUID rguid2); <br>#undef IsEqualIID <br>#define IsEqualIID(riid1, riid2) (*lpfnIsEqualGUID)(riid1, riid2) <br>#endif <br>typedef HRESULT (FAR PASCAL *LPFNHRQUERYALLROWS)(LPMAPITABLE ptable,  <br>                        LPSPropTagArray ptaga, LPSRestriction pres, <br>                        LPSSortOrderSet psos, LONG crowsMax, <br>                        LPSRowSet FAR *pprows); <br>typedef ULONG   (FAR PASCAL *LPFNMAPIFREEBUFFER)(LPVOID pv); <br>typedef HRESULT (FAR PASCAL *LPFNMAPIINITIALIZE)(LPVOID lpvReserved); <br>typedef void    (FAR PASCAL *LPFNMAPIUNINITIALIZE)(VOID); <br>typedef void    (FAR PASCAL *LPFNMAPIFREEPADRLIST)(LPADRLIST); <br> <br>LPFNCOREGISTERCLASSOBJECT lpfnCoRegisterClassObject; <br>#ifdef WIN16 <br>LPFNISEQUALGUID           lpfnIsEqualGUID; <br>#endif <br>LPFNHRQUERYALLROWS        lpfnHrQueryAllRows       ; <br>LPFNMAPIFREEBUFFER        lpfnMAPIFreeBuffer       ; <br>LPFNMAPIINITIALIZE        lpfnMAPIInitialize       ; <br>LPFNMAPIUNINITIALIZE      lpfnMAPIUninitialize     ; <br>LPFNMAPIFREEPADRLIST      lpfnFreePadrlist          ;    <br> <br>HRESULT <br>HrStartOleAndRegisterClassFactory(void) <br>{ <br>    FRMFMR *    pfrmfmr = NULL; <br>    HRESULT     hr; <br> <br>    TraceTag(tagFormFunc,"HrStartOleAndRegisterClassFactory"); <br> <br>    // ----- LoadLibrary the essentials <br>    hinstOle   = LoadLibrary(szOleDll); <br>    hinstMapi  = LoadLibrary(szMapiDll); <br>    #ifdef WIN16 <br>    if (hinstOle   &lt; HINSTANCE_ERROR) hinstOle   = 0; <br>    if (hinstMapi  &lt; HINSTANCE_ERROR) hinstMapi  = 0; <br>    #endif <br>    if (0 == hinstOle || 0 == hinstMapi) <br>        { <br>        return ResultFromScode(E_FAIL); <br>        } <br>         <br> <br>    // ----- Setup a few function pointers <br>    lpfnCoRegisterClassObject = (LPFNCOREGISTERCLASSOBJECT) GetProcAddress(hinstOle,  "CoRegisterClassObject"); <br>#if defined(_WIN32)  <br>    #if defined(_X86_) <br>    lpfnHrQueryAllRows        = (LPFNHRQUERYALLROWS       ) GetProcAddress(hinstMapi,"HrQueryAllRows@24"); <br>    lpfnFreePadrlist          = (LPFNMAPIFREEPADRLIST     ) GetProcAddress(hinstMapi,"FreePadrlist@4"); <br>    #else <br>    lpfnHrQueryAllRows        = (LPFNHRQUERYALLROWS       ) GetProcAddress(hinstMapi,"HrQueryAllRows"); <br>    lpfnFreePadrlist          = (LPFNMAPIFREEPADRLIST     ) GetProcAddress(hinstMapi,"FreePadrlist"); <br>    #endif //_X86_ <br>#else <br>    lpfnIsEqualGUID           = (LPFNISEQUALGUID          ) GetProcAddress(hinstOle,  "IsEqualGUID"); <br>    lpfnHrQueryAllRows        = (LPFNHRQUERYALLROWS       ) GetProcAddress(hinstMapi,"HrQueryAllRows"); <br>    lpfnFreePadrlist          = (LPFNMAPIFREEPADRLIST     ) GetProcAddress(hinstMapi,"FreePadrlist"); <br>#endif //_WIN32 <br>    lpfnMAPIFreeBuffer        = (LPFNMAPIFREEBUFFER       ) GetProcAddress(hinstMapi,"MAPIFreeBuffer"); <br>    lpfnMAPIInitialize        = (LPFNMAPIINITIALIZE       ) GetProcAddress(hinstMapi,"MAPIInitialize"); <br>    lpfnMAPIUninitialize      = (LPFNMAPIUNINITIALIZE     ) GetProcAddress(hinstMapi,"MAPIUninitialize"); <br>    AssertSz(lpfnCoRegisterClassObject ,"missing lpfnCoRegisterClassObject"); <br>    AssertSz(lpfnHrQueryAllRows        ,"missing lpfnHrQueryAllRows       "); <br>    AssertSz(lpfnMAPIFreeBuffer        ,"missing lpfnMAPIFreeBuffer       "); <br>    AssertSz(lpfnMAPIInitialize        ,"missing lpfnMAPIInitialize       "); <br>    AssertSz(lpfnMAPIUninitialize      ,"missing lpfnMAPIUninitialize     "); <br>    AssertSz(lpfnFreePadrlist          ,"missing lpfnFreePadrlist         "); <br>    if (0 == lpfnCoRegisterClassObject || <br>        0 == lpfnHrQueryAllRows        || <br>        0 == lpfnMAPIFreeBuffer        || <br>        0 == lpfnMAPIInitialize        || <br>        0 == lpfnMAPIUninitialize      || <br>        0 == lpfnFreePadrlist) <br>        { <br>        AssertSz(0,"get procaddress failed"); <br>        return ResultFromScode(E_FAIL); <br>        }     <br> <br>    // ----- Initialize MAPI <br>    hr = (*lpfnMAPIInitialize)(NULL); <br>    if (S_OK != hr) <br>        { <br>        TraceTag(tagForm,"MapiInit failed 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- Allocate Memory for our class factory <br>    pfrmfmr = new FRMFMR; <br>    if (NULL == pfrmfmr) <br>        { <br>        TraceTag(tagForm, "RegisterClassFactory: OOM 0x%08lx",hr); <br>        hr = ResultFromScode(E_OUTOFMEMORY); <br>        return hr; <br>        } <br> <br>    // ----- Register our class object(s) <br>    DWORD dwRegMyForm = 0; <br>    hr = (*lpfnCoRegisterClassObject) (CLSID_MyFormsClsId, (LPUNKNOWN)pfrmfmr, <br>            CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, <br>            &amp;dwRegMyForm); /* switch singleuse to multipleuse if you are an MDI app */ <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"CoRegisterClassObject() failed 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    TraceTag(tagForm,"return 0x%08lx",hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrStopForms <br> * <br> *  Purpose: <br> *      UnInitialize OLE, MAPI, and the Forms Interface <br> * <br> *  Returns: <br> *      HRESULT == 0 <br> */ <br>HRESULT <br>HrStopForms(void) <br>{ <br>    HRESULT hr = ResultFromScode(S_OK); <br> <br>    TraceTag(tagFormFunc,"HrStopForms"); <br> <br>    (*lpfnMAPIUninitialize)(); <br> <br>    FreeLibrary(hinstOle); <br>    FreeLibrary(hinstMapi); <br> <br>    return hr; <br>} <br> <br> <br>/* <br> *  S a m p l e   F o r m <br> */ <br> <br>// Checkers form specific methods follow /////////////////////////// <br> <br>/* <br> *  FRM::ScGetRecipientAdrList <br> * <br> *  Purpose: <br> *      Fill the addrlist with the current recipients in the message <br> * <br> *  Arguments: <br> *      LPMESSAGE - the message (in) <br> *      LPADRLIST - the addr list destination (out) <br> * <br> *  Returns: <br> *      SCODE       Error status. <br> */ <br>SCODE <br>FRM::ScGetRecipientAdrlist(LPMESSAGE pmsg, LPADRLIST * ppal) <br>{ <br>    SCODE           sc      = S_OK; <br>    HRESULT         hr; <br>    LPMAPITABLE     pmt     = NULL; <br>    LPSPropTagArray ptaga   = NULL; <br> <br>    TraceTag(tagFormFunc,"ScGetRecipientAdrlist"); <br>    AssertSz(!*ppal, "pal should be NULL on entry"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    // Get the recipient table from the message <br>    if (hr = pmsg-&gt;GetRecipientTable(MAPI_DEFERRED_ERRORS, &amp;pmt)) <br>    { <br>        TraceTag(tagForm,"2043 0x%08lx",hr); <br>        goto Cleanup; <br>    } <br> <br>    if (hr = pmt-&gt;QueryColumns(TBL_ALL_COLUMNS, &amp;ptaga)) <br>    { <br>        TraceTag(tagForm,"sdlkfj 0x%08lx",hr); <br>        goto Cleanup; <br>    } <br> <br>#ifdef NEVER <br>    ConvertToCorrectCharset(ptaga); <br>#endif <br> <br>    // Read in the recipients <br>    hr = (*lpfnHrQueryAllRows)(pmt, ptaga, NULL, NULL, 0, (LPSRowSet *) ppal); <br>    if (hr) <br>    { <br>        TraceTag(tagForm,"sdfhjsadjfhadkflhxxxx 0x%08lx",hr); <br>        goto Cleanup; <br>    } <br> <br>Cleanup: <br>    TraceTag(tagForm,"ScGetRecipientAdrlist 0x%08lx 0x%08lx", hr, sc); <br> <br>    (*lpfnMAPIFreeBuffer)(ptaga); <br>    ReleaseObj(pmt); <br> <br>    TraceTag(tagForm,"return 0x%08lx",ResultFromScode(sc)); <br>    return sc; <br>} <br> <br>/* <br> *  FRM::SendForm <br> * <br> *  Purpose: <br> *      Have the message site send us <br> *      (also tries to send the message using mapi if message site fails) <br> * <br> *  Arguments: <br> *      None. <br> * <br> *  Returns: <br> *      HRESULT             Error status. <br> */ <br>HRESULT <br>FRM::SendForm(VOID) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    TraceTag(tagFormFunc,"FRM::SendForm (this is not a standard form function)"); <br> <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    Assert(pMessageSite); <br>    Assert(pMessage); <br> <br>    // ----- Submit message <br>    if (hr = pMessageSite-&gt;SubmitMessage(0) ) <br>    { <br>        TraceTag(tagForm,"failure pMessageSite-&gt;SubmitMessage 0x%08lx",hr); <br> <br>        #ifndef GOOD_FORM_BEHAVIOR // the following is not standard behavior <br> <br>        // ----- No harm in trying to send it myself <br>        if (IDYES == MessageBox(hMainWnd, "The message site failed to send this form.\nDo you want this form to attempt sending through the message interface?", "Checkers", MB_YESNO | MB_ICONSTOP)) <br>        { <br>            // this is often times easier to debug than the remoted <br>            // message site interface (which does the same thing .. almost) <br> <br>            if (hr = Save(NULL,TRUE)) <br>                { <br>                TraceTag(tagForm,"NO: ::Save 0x%08lx",hr); <br>                } <br> <br>            HandsOffMessage(); <br> <br>            if (hr = pMessage-&gt;SaveChanges(KEEP_OPEN_READWRITE) ) <br>                { <br>                TraceTag(tagForm,"NO: pMessage-&gt;SaveChanges 0x%08lx",hr); <br>                } <br>            if (hr = pMessage-&gt;SubmitMessage(0) ) <br>                { <br>                TraceTag(tagForm,"NO: pMessage-&gt;SubmitMessage 0x%08lx",hr); <br>                } <br>        } <br> <br>        #endif // good_form_behavior <br>    } <br> <br>    // ----- advise everyone of what we just did <br>    ADVISE(OnSubmitted)(); <br> <br>    TraceTag(tagForm,"return 0x%08lx",hr); <br>    return hr; <br>} <br> <br>/* <br> *  FRM::LaunchReplyMessage <br> * <br> *  Purpose: <br> *      Construct a reply to PR_SENDER* (note: ignoring sent representing) <br> *      Display any form user interface on the existing form <br> * <br> *  Arguments: <br> *      HWND                Parent window <br> * <br> *  Returns: <br> *      HRESULT             Error status. <br> */ <br>HRESULT <br>FRM::LaunchReplyMessage(ULONG ulhwndParent) <br>{ <br>    #ifdef ALLOW_SUBCLASS_IPM <br>    LPMAPIFORM pNewForm; <br>    LPPERSISTMESSAGE pNewFormIPersist; <br>    #endif <br> <br>    ULONG itaga; <br>    ADRLIST al = {1,0}; /* our adrlist will have exactly one entry */ <br>    HRESULT hr = S_OK; <br>    LPMAPIMESSAGESITE pNewMessageSite; <br>    LPMAPIVIEWCONTEXT pNewMapiViewContext; <br>    LPMESSAGE pNewMessage; <br> <br>    SizedSPropTagArray(6,tagaSender) = <br>        { 6, <br>        { PR_RECIPIENT_TYPE, <br>            PR_SENDER_NAME, <br>            PR_SENDER_ADDRTYPE, <br>            PR_SENDER_ENTRYID, <br>            PR_SENDER_EMAIL_ADDRESS, <br>            PR_SENDER_SEARCH_KEY } }; <br>    SizedSPropTagArray(6,tagaRepliee) = <br>        { 6, <br>        { PR_RECIPIENT_TYPE, <br>            PR_DISPLAY_NAME, <br>            PR_ADDRTYPE, <br>            PR_ENTRYID, <br>            PR_EMAIL_ADDRESS, <br>            PR_SEARCH_KEY <br>        } }; <br>    static SizedSPropTagArray(26,tagaRemoveFromNewReply) = <br>        { 26, <br>        {   // Stuff you would typically want to remove on reply <br>            PR_MESSAGE_FLAGS,               // Want unsent compose note <br>            PR_MESSAGE_RECIPIENTS,          // Will generate new recip list <br>            PR_SENDER_ENTRYID,              // Clear sender/recipient info <br>            PR_SENDER_NAME,                 // <br>            PR_RECEIVED_BY_ENTRYID,         // <br>            PR_RECEIVED_BY_NAME,            // <br>            PR_SENT_REPRESENTING_ENTRYID,   // Clear delegate access stuff <br>            PR_SENT_REPRESENTING_NAME,      // <br>            PR_SENT_REPRESENTING_ADDRTYPE,  // 10961 <br>            PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>            PR_RCVD_REPRESENTING_ENTRYID,   //  <br>            PR_RCVD_REPRESENTING_NAME,      // <br>            PR_READ_RECEIPT_ENTRYID,        // Clear destination overrides <br>            PR_REPORT_ENTRYID,              // <br>            PR_REPLY_RECIPIENT_ENTRIES,     // <br>            PR_REPLY_RECIPIENT_NAMES,       // <br>            PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED, // Clear delivery receipt <br>            PR_READ_RECEIPT_REQUESTED,      // Clear read receipt <br>            PR_CLIENT_SUBMIT_TIME,          // Clear submit time <br>            PR_MESSAGE_ATTACHMENTS,         // Drop attachments on reply <br>            PR_ORIGINAL_AUTHOR_ENTRYID,     // Keep original author information <br>            PR_ORIGINAL_AUTHOR_NAME,        //  on forwards <br>            PR_ORIGINAL_SUBMIT_TIME,        // Keep original time on forwards <br>            PR_IMPORTANCE,                  // Lose importance on reply <br>            PR_PRIORITY,                    // Lose priority on reply <br>            PR_SENSITIVITY                  // Lose sensitivity on reply <br>        } }; <br> <br>    TraceTag(tagFormFunc,"FRM::LaunchReplyMessage"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    Assert(pMessageSite); <br>    Assert(pSession); <br>    Assert(pMessage); <br> <br>    #ifdef ALLOW_SUBCLASS_IPM <br> <br>    /* <br>       Since I am a single instance exe, creating a new form results in <br>       a new process.  For performance reasons, this form does not conform <br>       to the forms API precisely. This effectively removes the ability to <br>       subclass the reply note for IPM.Checkers.  This is acceptable. <br> <br>    */ <br> <br>    // ----- open form manager <br>    AssertSz(NULL == pFormMgr,"two form managers?"); <br>    hr = pMessageSite-&gt;GetFormManager(&amp;pFormMgr); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure MAPIOpenFormMgr 0x%08lx",hr); <br>        return hr; <br>        } <br>    Assert(pFormMgr); <br> <br>    // ----- Get form info <br>    hr = pFormMgr-&gt;ResolveMessageClass("IPM.Checkers",0,NULL,&amp;pFormInfo); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure to ResolveMessageClass 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- Create the new form <br>    hr = pFormMgr-&gt;CreateForm(0,0,pFormInfo,IID_IMAPIForm,(LPVOID FAR*) &amp;pNewForm); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure to CreateForm 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    hr = pNewForm-&gt;QueryInterface(IID_IPersistMessage, (LPVOID FAR*) &amp;pNewFormIPersist); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure asking form for IPersistMessage 0x%08lx",hr); <br>        return hr; <br>        } <br>    AssertSz(pNewFormIPersist,"have it?"); <br> <br>    #endif // ALLOW_SUBCLASS_IPM <br> <br>    // ----- Create the reply message <br>    hr = pMessageSite-&gt;NewMessage(0,NULL, <br>        #ifdef ALLOW_SUBCLASS_IPM <br>        pNewFormIPersist <br>        #else <br>        this <br>        #endif // ALLOW_SUBCLASS_IPM <br>        ,&amp;pNewMessage,&amp;pNewMessageSite,&amp;pNewMapiViewContext); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure VDOG_*NewMessage* comform...c 0x%08lx",hr); <br>        return hr; <br>        } <br>    AssertSz(pNewMessage,"nothing new with you"); <br>    AssertSz(pNewMessageSite,"no new site?"); <br>    AssertSz(pNewMapiViewContext,"no new view context ... did NewMessage work at all?"); <br> <br>    // ----- Copy current message to new message <br>    hr = pMessage-&gt;CopyTo(0, NULL, (LPSPropTagArray)&amp;tagaRemoveFromNewReply, 0, NULL, <br>                                    (LPIID) &amp;IID_IMessage, pNewMessage, 0, NULL); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure CopyTo 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- who sent this to us? <br>    hr = pMessage-&gt;GetProps((LPSPropTagArray) &amp;tagaSender, 0, &amp;al.aEntries[0].cValues, &amp;al.aEntries[0].rgPropVals); <br>    AssertSz(ResultFromScode(MAPI_W_ERRORS_RETURNED) == hr,"mapi gave me pr_recipient_type, but should not have"); <br> <br>    // ----- Make the sender the recipient <br>    if (al.aEntries &amp;&amp; al.aEntries[0].rgPropVals) <br>    { <br>        al.aEntries[0].rgPropVals[0].ulPropTag = PR_RECIPIENT_TYPE; <br>        al.aEntries[0].rgPropVals[0].Value.ul = MAPI_TO; <br>    } <br>    else <br>    { <br>        AssertSz(0,"could not form reply message: al.aEntries &amp;&amp; al.aEntries[0].rgPropVals"); <br>        return ResultFromScode(E_FAIL); <br>    } <br> <br>    // ----- Set our new recipients properties to their expected property ids <br>    itaga = 1; <br> <br>    TraceTag(tagForm,"0x%08lx cEntries",al.cEntries); <br>    TraceTag(tagForm,"0x%08lx &lt;0x%08lx&gt; %s",al.aEntries[0].rgPropVals[itaga].ulPropTag,al.aEntries[0].rgPropVals[itaga].Value.ul,al.aEntries[0].rgPropVals[itaga].Value.LPSZ); <br> <br>    for (itaga = 1; itaga &lt; tagaRepliee.cValues; itaga++) <br>        { <br>        al.aEntries[0].rgPropVals[itaga].ulPropTag = <br>            PROP_TAG(PROP_TYPE(al.aEntries[0].rgPropVals[itaga].ulPropTag), <br>                PROP_ID(tagaRepliee.aulPropTag[itaga])); <br> <br>        TraceTag(tagForm,"0x%08lx &lt;0x%08lx&gt; %d",al.aEntries[0].rgPropVals[itaga].ulPropTag,al.aEntries[0].rgPropVals[itaga].Value.ul,itaga); <br> <br>        AssertSz(SUCCEEDED(al.aEntries[0].rgPropVals[itaga].Value.ul),"Failure to get PR_SENDER* 10961 "); <br>        } <br> <br>    // ----- Save out addresses <br>    AssertSz(1 == al.cEntries,"we only reply to one person"); <br>    hr = pNewMessage-&gt;ModifyRecipients(0, &amp;al); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"pMessage-&gt;ModifyRecipients 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- Release everything the read form was remembering (if we reply inplace) <br>    #ifndef ALLOW_SUBCLASS_IPM <br>    Forget(); <br>    #endif <br> <br>    // ----- Call LoadForm (this makes the current form the new form) <br>    hr = <br>    #ifdef ALLOW_SUBCLASS_IPM <br>    pNewFormIPersist-&gt; <br>    #endif <br>    Load(pNewMessageSite,pNewMessage,0,MSGFLAG_UNSENT); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure LoadForm 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- Call SetViewContext <br>    #ifdef ALLOW_SUBCLASS_IPM <br>    hr = pNewForm-&gt;SetViewContext(pNewMapiViewContext); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure SetViewContext 0x%08lx",hr); <br>        return hr; <br>        } <br>    #endif <br> <br>    // ----- Call DoVerb So we can see the reply form <br>    hr =  <br>    #ifdef ALLOW_SUBCLASS_IPM <br>    pNewForm-&gt; <br>    #endif <br>    DoVerb(OLEIVERB_PRIMARY,NULL,ulhwndParent,NULL); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure DoVerb 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- release stuff <br>    pNewMessage-&gt;Release(); <br>    pNewMessageSite-&gt;Release(); <br>    pNewMapiViewContext-&gt;Release(); <br>    (*lpfnMAPIFreeBuffer)(al.aEntries[0].rgPropVals); <br> <br>    // ----- Close down the read form (that's me) <br>    #ifdef ALLOW_SUBCLASS_IPM <br>    hr = ShutdownForm(OLECLOSE_NOSAVE); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failure ShutdownForm'ing read form 0x%08lx",hr); <br>        return hr; <br>        } <br>    #endif // ALLOW_SUBCLASS_IPM <br> <br>    // ----- return to caller <br>    return hr; <br> <br>} <br> <br>/* <br> *  FRM::GetCheckersData <br> * <br> *  Purpose: <br> *      Allows anyone to query the form for it's current data <br> * <br> *  Arguments: <br> *      data members (out) <br> * <br> *  Returns: <br> *      void <br> */ <br>VOID <br>FRM::GetCheckersData(SQUARE* out_b, int* out_turn, long* out_movenum, long* out_score) <br>{ <br>    Assert(out_b); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    if (turn) /* set elements only if we have data to give out */ <br>    { <br>        memcpy(out_b,b,sizeof(b)); <br>        if (out_turn) *out_turn = turn; <br>        if (out_movenum) *out_movenum = movenum; <br>        if (out_score) *out_score = score; <br>    } <br>} <br> <br>/* <br> *  FRM::SetCheckersData <br> * <br> *  Purpose: <br> *      Allows anyone to set the forms current data members <br> * <br> *  Arguments: <br> *      data members (in) <br> * <br> *  Returns: <br> *      void <br> */ <br>VOID <br>FRM::SetCheckersData(SQUARE* in_b, int in_turn, long in_movenumber, long in_score) <br>{ <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    Assert(in_b &amp;&amp; in_turn); <br> <br>    fDirty = TRUE; <br> <br>    memcpy(b,in_b,sizeof(b)); <br>    turn    = in_turn; <br>    movenum = in_movenumber; <br>    score   = in_score; <br>} <br> <br> <br>/* <br> *  FRM::AddressForm <br> * <br> *  Purpose: <br> *      Look at the current message addresses, and show user <br> *      interface to address the message. <br> * <br> *  Arguments: <br> *      HWND - parent <br> *      BOOL - true if no user interface should be presented when <br> *             recipients are already present <br> * <br> *  Returns: <br> *      HRESULT Error Status. <br> */ <br>HRESULT <br>FRM::AddressForm(HWND hwnd, BOOL fDontShowIfRecipsExist) <br>{ <br>    LPADRBOOK   pAdrBook; <br>    ULONG       ulUIParam = (ULONG) (UINT) hwnd; <br>    SCODE       sc; <br>    HRESULT     hr = S_OK; <br>    ADRPARM     ap = { 0 }; <br>    LPADRLIST   pal = NULL; <br>    BOOL        fCloseForm = FALSE; <br> <br>    TraceTag(tagFormFunc,"FRM::AddressForm"); <br> <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    Assert(pMessageSite); <br>    Assert(pSession); <br>    Assert(pMessage); <br> <br>    // ----- Read in addresses from message <br>    sc = ScGetRecipientAdrlist(pMessage, &amp;pal); <br>    hr = ResultFromScode(sc); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failed to read address into pal 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- remember address book from the session <br>    hr = pSession-&gt;OpenAddressBook(ulUIParam, NULL, 0, &amp;pAdrBook); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"failed to get pAdrBook object 0x%08lx",hr); <br>        goto cleanuppal; <br>        } <br> <br>    // ----- Show the address book <br>    ap.ulFlags = AB_RESOLVE | DIALOG_OPTIONS | DIALOG_MODAL | fMapiUnicode; <br>    ap.lpszCaption = TEXT("Select Checkers Opponent"); <br>    ap.cDestFields = 1; <br>    if (0 == fDontShowIfRecipsExist || 0 == pal-&gt;cEntries) <br>        hr = pAdrBook-&gt;Address(&amp;ulUIParam, &amp;ap, &amp;pal); <br>    #ifdef DEBUG <br>    if (hwnd != hMainWnd) <br>    { <br>        TraceTag(tagNull,"ADDRESSFORM: pAdrBook-&gt;Address changed it's out parameter even though DIALOG_MODAL"); <br>    } <br>    #endif <br>    if (FAILED(hr)) <br>    { <br>        // cancel is a failed scode <br>        TraceTag(tagForm,"cant pop up addr book 0x%08lx %d",hr,pal?pal-&gt;cEntries:0); <br>    } <br> <br>    // ----- Save out addresses <br>    AssertSz(pMessage,"pMessage said goodbye during the Address function"); <br>    hr = pMessage-&gt;ModifyRecipients(0, pal); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"pMessage-&gt;ModifyRecipients 0x%08lx",hr); <br>        goto cleanup; <br>        } <br> <br>    // ----- Close the form if there are no recipients for this move <br>    if (pal-&gt;cEntries &lt;= 0) fCloseForm = TRUE; <br> <br>    // ----- Release the address book, adrlist, and clean up <br>cleanup: <br>    Assert(pAdrBook); <br>    pAdrBook-&gt;Release(); <br>cleanuppal: <br>    Assert(pal); <br>    (*lpfnFreePadrlist)(pal); <br>    if (fCloseForm) ShutdownForm(OLECLOSE_PROMPTSAVE); <br> <br>    TraceTag(tagForm,"return 0x%08lx",hr); <br>    return hr; <br>} <br> <br>/* <br> *  FRM::Remember <br> * <br> *  Purpose: <br> *      Store and addref the message site, the message, and the session <br> *      for later use <br> * <br> *  Returns: <br> *      HRESULT Error Status. <br> */ <br>HRESULT <br>FRM::Remember(LPMAPIMESSAGESITE pmsite, LPMESSAGE pmsg) <br>{ <br>    HRESULT hr; <br> <br>    TraceTag(tagFormFunc,"FRM::Remember"); <br> <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    AssertSz(pmsite,"what am I going to do without it?"); <br>    AssertSz(pmsg,"what am I going to do without it? pmsg that is"); <br> <br>    // ----- remember our message site object <br>    AssertSz(!pMessageSite,"who me? a message site?"); <br>    pMessageSite = pmsite; <br>    pMessageSite-&gt;AddRef(); <br> <br>    // ----- remember our message <br>    AssertSz(!pMessage,"a message in my"); <br>    pMessage = pmsg; <br>    pMessage-&gt;AddRef(); <br> <br>    // ----- remember mapi session <br>    AssertSz(!pSession,"another session?"); <br>    hr = pMessageSite-&gt;GetSession(&amp;pSession); <br> <br>    #ifdef DEBUG     <br>    if (FAILED(hr)) <br>    { <br>        TraceTag(tagForm,"failed to get session object %08lx",hr); <br>    }     <br>    #endif <br> <br>    // ----- return result to caller <br>    TraceTag(tagForm,"return 0x%08lx",hr); <br>    return hr; <br> <br>} <br> <br>/* <br> *  FRM::Forget <br> * <br> *  Purpose: <br> *      Release the message site, the message, and the session <br> * <br> *  Returns: <br> *      HRESULT Error Status. <br> */ <br>HRESULT <br>FRM::Forget(VOID) <br>{ <br>    TraceTag(tagFormFunc,"FRM::Forget"); <br> <br>    if (pMessage) pMessage-&gt;Release(); <br>    if (pMessageSite) pMessageSite-&gt;Release(); <br>    if (pSession) pSession-&gt;Release(); <br> <br>    pMessage = NULL; <br>    pMessageSite = NULL; <br>    pSession = NULL; <br> <br>    return NOERROR; <br>} <br> <br>/* <br> *  FRM::ShowCurrentMessage <br> * <br> *  Purpose: <br> *      Display any form user interface on a form <br> * <br> *  Arguments: <br> *      HWND                Parent window <br> * <br> *  Returns: <br> *      HRESULT             Error status. <br> */ <br>HRESULT <br>FRM::ShowCurrentMessage(ULONG ulhwndParent) <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    TraceTag(tagFormFunc,"FRM::ShowCurrentMessage"); <br> <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    Assert(pMessageSite); <br>    Assert(pSession); <br>    Assert(pMessage); <br> <br>    // ----- Give our user access to our form interface <br>    SendMessage(hMainWnd,EM_GIVEFORMTOHWND,0,(LPARAM) this); <br> <br>    // ----- Display address book modal to form if this message has not yet been addressed <br>    FORWARD_WM_COMMAND(hMainWnd, IDM_ADDRESS, 0, 1 /* Don't Show Recips */, PostMessage); <br> <br>    return hr; <br>} <br> <br>// IUnknown methods follow /////////////////////////// <br> <br>/* <br> *  FRM::QueryInterface <br> * <br> *  Purpose: <br> *      Returns a pointer to the specified interface. <br> * <br> *  Arguments: <br> *      REFIID              Interface we want. <br> *      LPUNKNOWN *         Interface we return. <br> * <br> *  Returns: <br> *      HRESULT             Error status. <br> */ <br>STDMETHODIMP <br>FRM::QueryInterface(REFIID riid, LPVOID FAR * ppvObj) <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    TraceTag(tagFuncTriv,"FRM::QueryInterface %s",DumpCLSID(riid)); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    if (IsEqualIID(riid, IID_IUnknown)) <br>        { <br>        AddRef(); <br>        *ppvObj = (IMAPIForm *)this; <br>        } <br>    else if (IsEqualIID(riid, IID_IPersistMessage)) <br>        { <br>        AddRef(); <br>        *ppvObj = (IPersistMessage *)this; <br>        } <br>    else if (IsEqualIID(riid, IID_IMAPIForm)) <br>        { <br>        AddRef(); <br>        *ppvObj = (IMAPIForm *)this; <br>        } <br>    else <br>        { <br>        hr = ResultFromScode(E_NOINTERFACE); <br>        *ppvObj = NULL; <br>        } <br>     <br>    #ifdef DEBUG <br>    if (hr != ResultFromScode(E_NOINTERFACE)) AssertSz(ppvObj,"no object pointer"); <br>    #endif <br> <br>    TraceTag(tagForm,"return 0x%08lx",hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  FRM::AddRef <br> * <br> *  Purpose: <br> *      Increments reference count on the sample extension. <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      ULONG               New value of reference count. <br> */ <br>STDMETHODIMP_(ULONG) <br>FRM::AddRef(void) <br>{ <br>    TraceTag(tagFuncTriv,"FRM::AddRef ret %d",cRef + 1); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    return ++cRef; <br>} <br> <br> <br>/* <br> *  FRM::Release <br> * <br> *  Purpose: <br> *      Decrements reference count on the sample extension.  If count is <br> *      decremented to zero, the object is freed. <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      ULONG               New value of reference count. <br> */ <br>STDMETHODIMP_(ULONG) <br>FRM::Release(void) <br>{ <br>    TraceTag(tagFuncTriv,"FRM::Release cRef %d",cRef); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    if (!(--cRef)) <br>        { <br>        // ----- be sure our ui is gone when we leave <br>        #ifdef DEBUG <br>        if (IsWindow(hMainWnd)) <br>            { <br>            TraceTag(tagForm,"Last Release called, but IsWindow(hMainWnd).  ShutdownForm called?"); <br>            } <br>        TraceTag(tagForm,"return 0"); <br>        #endif //debug <br>        delete this; <br>        return 0; <br>        } <br>    return cRef; <br>} <br> <br> <br>// IPersistMessage methods follow /////////////////////////// <br> <br>/* <br> *  FRM::GetLastError <br> * <br> *  Purpose: <br> *      Get the last error <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      HRESULT             NOERROR always. <br> */ <br>STDMETHODIMP <br>FRM::GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR FAR * lppMAPIError) <br>{ <br>    TraceTag(tagFormFunc,"FRM::GetLastError 0x%08x",hResult); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    if (lppMAPIError) *lppMAPIError = NULL; <br>    return NOERROR; <br>} <br> <br>/* <br> *  FRM::GetClassID <br> * <br> *  Purpose: <br> *      Get the class ID associated with this message. </code></pre>
<p>
</p>
<pre><code>* <br> *  Arguments: <br> *      LPCLSID             Where to put the class ID. <br> * <br> *  Returns: <br> *      HRESULT             NOERROR always. <br> */ <br>STDMETHODIMP <br>FRM::GetClassID(LPCLSID pclsid) <br>{ <br>     <br>    TraceTag(tagFormFunc,"FRM::GetClassID"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    // The form only plays with things of its own class ID, so <br>    // this is easy; it's more complicated if code supports multiple <br>    // classes, or can do "treat as" operations <br>    if (pclsid) *pclsid = clsid; <br> <br>    return NOERROR; <br>} <br> <br> <br>/* <br> *  FRM::IsDirty <br> * <br> *  Purpose: <br> *      Returns whether the object has changed since the last save <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      HRESULT             S_OK if dirty, S_FALSE if not dirty. <br> */ <br>STDMETHODIMP <br>FRM::IsDirty(void) <br>{ <br>    TraceTag(tagFormFunc,"FRM::IsDirty"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>     <br>    return fDirty ? NOERROR : ResultFromScode(S_FALSE); <br>} <br> <br> <br>/* <br> *  FRM::InitNew <br> * <br> *  Purpose: <br> *      Create a new message of our message class in the provided pmsg. <br> * <br> *  Arguments: <br> *      LPMAPISESSION       Session in which the message belongs. <br> *      LPMESSAGE           Message to create the new form in. <br> * <br> *  Returns: <br> *      HRESULT             S_OK, or error value. <br> */ <br>STDMETHODIMP <br>FRM::InitNew(LPMAPIMESSAGESITE pmsite, LPMESSAGE pmsg) <br>{ <br>    HRESULT             hr; <br>    SPropValue          prop; <br> <br>    TraceTag(tagFormFunc,"FRM::InitNew"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    // ----- Remember our pointers and such <br>    hr = Remember(pmsite,pmsg); <br>    if (FAILED(hr)) <br>    { <br>        TraceTag(tagForm,"loss of memory in initnew 0x%08lx",hr); <br>        return hr; <br>    } <br> <br>    // ----- set our message class <br>    prop.ulPropTag  = PR_MESSAGE_CLASS; <br>    prop.Value.LPSZ = TEXT("IPM.Checkers"); <br>    hr = pMessage-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed setprops in initnew 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- remind ourselves that this new message could not have been sent <br>    fSentMessage = 0; <br> <br>    // ----- set our special properties <br>    prop.ulPropTag  = PR_SUBJECT; <br>    prop.Value.LPSZ = TEXT("--- CHECKERS FORM ---"); <br>    hr = pMessage-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed setprops in on pr_subject here 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    ADVISE(OnNewMessage)(); <br>    return hr; <br>} <br> <br> <br>/* <br> *  FRM::Load <br> * <br> *  Purpose: <br> *      Attaches our object to the provided pmsg. <br> * <br> *  Arguments: <br> *      LPMAPISESSION       Our session to remember. <br> *      LPMESSAGE           Our message to remember. <br> * <br> *  Returns: <br> *      HRESULT             S_OK, or error value. <br> */ <br>STDMETHODIMP <br>FRM::Load(LPMAPIMESSAGESITE pmsite, LPMESSAGE pmsg, ULONG ulMessageStatus, ULONG ulMessageFlags) <br>{ <br>    ULONG cProps = 0; <br>    #define ctagMax 10 <br>    char rgchTaga[sizeof(SPropTagArray) + (ctagMax * sizeof(ULONG))]; <br>    LPSPropTagArray ptaga = (LPSPropTagArray) rgchTaga; <br>    LPSPropValue rgval = NULL; <br>    LPSPropValue pval = NULL; <br>    HRESULT         hr=S_OK; <br> <br>    TraceTag(tagFormFunc,"FRM::Load status=0x%08lx flags=0x%08lx",ulMessageStatus,ulMessageFlags); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    // ----- Remember our pointers and such <br>    hr = Remember(pmsite,pmsg); <br>    if (FAILED(hr)) <br>        { <br>        TraceTag(tagForm,"loads call to remember failed 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- If this message has been sent we would like to remember that <br>    fSentMessage = !( ulMessageFlags &amp; MSGFLAG_UNSENT); <br>    TraceTag(tagForm,"fSentMessage = %d",(int) fSentMessage); <br> <br>    // ----- Load our data out of the message like a nice form <br>    ptaga-&gt;cValues = 0; <br>    ptaga-&gt;aulPropTag[ptaga-&gt;cValues++] = PR_SUBJECT; <br>    ptaga-&gt;aulPropTag[ptaga-&gt;cValues++] = PR_BODY; <br>    ptaga-&gt;aulPropTag[ptaga-&gt;cValues++] = PR_BOARD; <br>    ptaga-&gt;aulPropTag[ptaga-&gt;cValues++] = PR_TURN; <br>    ptaga-&gt;aulPropTag[ptaga-&gt;cValues++] = PR_MOVENUMBER; <br> <br>    hr = pmsg-&gt;GetProps(ptaga,0, &amp;cProps, &amp;rgval); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed getprops on pr_board there 0x%08lx",hr); <br>        return hr; <br>        } <br>    AssertSz(ptaga-&gt;cValues &lt;= ctagMax, "Too many properties to read!"); <br>    AssertSz(cProps == ptaga-&gt;cValues,"to mucho values"); <br>    pval = rgval; <br> <br>    // ----- set properties to variables <br>    pval;   // subject <br>    pval++; // body <br>    pval++; // board <br>    if (pval-&gt;Value.bin.cb == sizeof(b)) /* if it's a valid board */ <br>        { <br>        memcpy(b,pval-&gt;Value.bin.lpb,(int) pval-&gt;Value.bin.cb); <br>        pval++; // turn <br>        AssertSz(pval-&gt;Value.l == RED || pval-&gt;Value.l == BLACK,"cool: neither red or blacks turn according to mapi"); <br>        turn = (int) pval-&gt;Value.l; <br>        pval++; // movenumber <br>        } <br>    Assert(rgval); <br>    (*lpfnMAPIFreeBuffer)(rgval); <br>    ADVISE(OnNewMessage)(); <br>    return hr; <br>} <br> <br> <br>/* <br> *  FRM::Save <br> * <br> *  Purpose: <br> *      Writes out our information to the provided pmsg. Does NOT commit <br> *      changes; this is the responsibility of the caller. Puts the form <br> *      into no-scribble mode until SaveCompleted is called. <br> * <br> *  Arguments: <br> *      LPMESSAGE           Message to write our changes to. <br> *      BOOL                TRUE if this is our home message, FALSE if <br> *                          this is a different message. <br> * <br> *  Returns: <br> *      HRESULT             S_OK, or error value. <br> */ <br>STDMETHODIMP <br>FRM::Save(LPMESSAGE pmsg, ULONG fSameAsLoad) <br>{ <br>    SPropValue prop; <br>    HRESULT hr = NOERROR; <br> <br>    TraceTag(tagFormFunc,"FRM::Save"); <br> <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    AssertSz(pMessage,"no pmesssg in ::Save"); <br>    #ifdef DEBUG <br>    if (!pmsg) <br>    { <br>        TraceTag(tagNull,"NULL == pmsg in ::Save fsameasload==0x%08lx",fSameAsLoad); <br>    } <br>    #endif <br> <br>    // ----- If this is the same pmsg as we got back when we loaded ... <br>    if (fSameAsLoad) <br>    { <br>        TraceTag(tagForm,"fSameAsLoad true"); <br>        pmsg = pMessage; <br>    } <br> <br>    // ----- Put ourselves in no-scribble mode <br>    fNoScribble = TRUE; <br> <br>    // ----- set our message class <br>    prop.ulPropTag  = PR_MESSAGE_CLASS; <br>    prop.Value.LPSZ = TEXT("IPM.Checkers"); <br>    hr = pMessage-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed setprops in initnew 0x%08lx",hr); <br>        return hr; <br>        } <br> <br>    // ----- Write out our data <br>    AssertSz(turn,"nobody's turn? this is not a good sign..."); <br>    prop.ulPropTag  = PR_BOARD; <br>    prop.Value.bin.lpb = (unsigned char *) b; <br>    prop.Value.bin.cb  = sizeof(b); <br>    hr = pmsg-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed setprops in on pr_board here 0x%08lx",hr); <br>        return hr; <br>        } <br>    prop.ulPropTag  = PR_TURN; <br>    prop.Value.l = (long) turn; <br>    hr = pmsg-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed setprops in on pr_turn here 0x%08lx",hr); <br>        return hr; <br>        } <br>    prop.ulPropTag  = PR_MOVENUMBER; <br>    prop.Value.l = (long) movenum; <br>    hr = pmsg-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed setprops in on pr_turn here 0x%08lx",hr); <br>        return hr; <br>        } <br>    prop.ulPropTag  = PR_SCORINGFUNC; <br>    prop.Value.l = (long) score; <br>    hr = pmsg-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed setprops in on pr_turn here 0x%08lx",hr); <br>        return hr; <br>        } <br>    prop.ulPropTag  = PR_BODY; <br>    prop.Value.lpszA = TextizeBoard(b); <br>    TraceTag(tagForm,"Here's the board I saved:\n%s",prop.Value.lpszA); <br>    hr = pmsg-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>        { <br>        TraceTag(tagForm,"failed setprops in on pr_body here 0x%08lx",hr); <br>        return hr; <br>        } <br> <br> <br>    ADVISE(OnSaved)(); <br>    return hr; <br>} <br> <br> <br>/* <br> *  FRM::SaveCompleted <br> * <br> *  Purpose: <br> *      Terminates no-scribble and hands-off modes, returning the object <br> *      to its normal storage mode. <br> * <br> *  Arguments: <br> *      LPMESSAGE           Our new home message, if we need to change. <br> * <br> *  Returns: <br> *      HRESULT             S_OK, or error value. <br> */ <br>STDMETHODIMP <br>FRM::SaveCompleted(LPMESSAGE pmsg) <br>{ <br>    TraceTag(tagFormFunc,"FRM::SaveCompleted"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    // Reset modes <br>    fDirty = FALSE; <br>    fNoScribble = FALSE; <br> <br>    return NOERROR; <br>} <br> <br> <br>/* <br> *  FRM::HandsOffMessage <br> * <br> *  Purpose: <br> *      Releases our reference on the message so that a Save As operation <br> *      can occur. <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      HRESULT             S_OK, or error value. <br> */ <br>STDMETHODIMP <br>FRM::HandsOffMessage(void) <br>{ <br>    TraceTag(tagFormFunc,"FRM::HandsOffMessage"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    return NOERROR; <br>} <br> <br> <br>// IMAPIForm methods follow ///////////////////////////// <br> <br>/* <br> *  FRM::DoVerb <br> * <br> *  Purpose: <br> *      Performs the specified verb on the message. <br> * <br> *  Arguments: <br> *      LONG                What to do. <br> *      LPMAPIVIEWCONTEXT   Our view context. <br> *      HWND                Our parent window. <br> *      LPCRECT             Where we should display ourselves given a choice. <br> * <br> *  Returns: <br> *      HRESULT             S_OK, or error value. <br> */ <br>STDMETHODIMP <br>FRM::DoVerb(LONG iVerb, LPMAPIVIEWCONTEXT pmvc, ULONG ulhwndParent, <br>               LPCRECT prcPosRect) <br>{ <br>    TraceTag(tagFormFunc,"FRM::DoVerb iVerb=%d",iVerb); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    switch (iVerb) <br>        { <br>        default: <br>        case OLEIVERB_HIDE: <br>        case OLEIVERB_DISCARDUNDOSTATE: <br>            TraceTag(tagForm,"DoVerb: not implemented iVerb"); <br>            return ResultFromScode(E_NOTIMPL); <br> <br>        case OLEIVERB_UIACTIVATE: <br>        case OLEIVERB_INPLACEACTIVATE: <br>            TraceTag(tagForm,"DoVerb: not implemented iVerb=%d",iVerb); <br>            if (iVerb &lt; 0) <br>                return ResultFromScode(E_NOTIMPL); <br>            return ResultFromScode(OLEOBJ_S_INVALIDVERB); <br> <br>        case OLEIVERB_SHOW: <br>            ShowCurrentMessage(ulhwndParent); <br>            return NOERROR; <br> <br>        case OLEIVERB_OPEN: <br>        case OLEIVERB_PRIMARY: <br>            TraceTag(tagForm,"fSentMessage = %d",(int) fSentMessage); <br>            if (fSentMessage) <br>                LaunchReplyMessage(ulhwndParent); <br>            else <br>                ShowCurrentMessage(ulhwndParent); <br> <br>            return NOERROR; <br>        } <br>} <br> <br> <br>/* <br> *  FRM::ShutdownForm <br> * <br> *  Purpose: <br> *      Closes down any UI associated with the form. <br> * <br> *  Arguments: <br> *      DWORD               One of OLECLOSE_SAVEIFDIRTY, OLECLOSE_NOSAVE, <br> *                          or OLECLOSE_PROMPTSAVE. <br> * <br> *  Returns: <br> *      HRESULT             S_OK, or error value. <br> */ <br>STDMETHODIMP <br>FRM::ShutdownForm(DWORD dwSaveOptions) <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    TraceTag(tagFormFunc,"FRM::ShutdownForm dwSaveOptions=%d",dwSaveOptions); <br>    TraceTag(tagForm,"pMessageSite 0x%08x",(ULONG) pMessageSite); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br> <br>    // ----- no way I'm closeing if I'm in a modal dialog <br>    //       especially if the modal dialog occurs in a remoted interface <br>    if (!IsWindowEnabled(hMainWnd)) <br>        return ResultFromScode(E_ABORT); <br> <br>    // ----- be kind, and save ourself   <br>    switch (dwSaveOptions) <br>    { <br>        case OLECLOSE_NOSAVE: <br>            break; <br> <br>        case OLECLOSE_SAVEIFDIRTY: <br>            if (fDirty) <br>                hr = pMessageSite-&gt;SaveMessage(); <br>            break; <br> <br>        default: <br>        case OLECLOSE_PROMPTSAVE: <br>            if (fDirty) <br>                if (IDYES == MessageBox(hMainWnd, "Save changes?", "Checkers", MB_YESNO)) <br>                    hr = pMessageSite-&gt;SaveMessage(); <br>            break; <br> <br>    } <br> <br>    Assert(hMainWnd &amp;&amp; IsWindow(hMainWnd)); <br>    if (NOERROR == hr) <br>    { <br>        // ----- let everyone know we're shutting down <br>        ADVISE(OnShutdown)(); <br> <br>        // ----- Release everything we have remembered thus far <br>        Forget(); <br> <br>        // ----- make sure everyone has Unadvised <br>        AssertSz(0==afAdvisee[0],"0 didn't Unadvise before ShutdownForm"); <br>        AssertSz(0==afAdvisee[1],"1 didn't Unadvise before ShutdownForm"); <br>        AssertSz(0==afAdvisee[2],"2 didn't Unadvise before ShutdownForm"); <br>        AssertSz(0==afAdvisee[3],"3 didn't Unadvise before ShutdownForm"); <br> <br>        // ----- post a quit message to our UI <br>        SendMessage(hMainWnd,WM_CLOSE,0,0); <br>    } <br> <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>FRM::SetViewContext(LPMAPIVIEWCONTEXT pViewContextNew) <br>{ <br>    TraceTag(tagFormFunc,"FRM::SetViewContext"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    AssertSz(pViewContextNew,"no view context to set"); <br> <br>    /* View context is used for next and previous behavior <br>       The checkers form does not do next and previous because <br>       there is not a standard read note.  It is always in  <br>       reply mode */ <br> <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>FRM::GetViewContext(LPMAPIVIEWCONTEXT FAR * ppViewContext) <br>{ <br>    TraceTag(tagFormFunc,"FRM::GetViewContext"); <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    AssertSz(ppViewContext,"get view context to where?"); <br> <br>    if (ppViewContext) *ppViewContext = NULL; /* not supported */ <br> <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>FRM::Advise(LPMAPIVIEWADVISESINK pAdvise, ULONG FAR * pdwStatus) <br>{ <br>    LONG i; <br> <br>    TraceTag(tagFormFunc,"FRM::Advise"); <br> <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    Assert(pdwStatus); <br>    Assert(pAdvise); <br> <br>    // ----- remember who to advise     <br>    for (i=0; i&lt;MAX_ADVISE; i++) <br>        if (!afAdvisee[i]) <br>        { <br>            aAdvisePtrs[i] = pAdvise; <br>            afAdvisee[i] = 1; <br>            *pdwStatus = i + 1; /* ulConnection of zero is not valid */ <br>            pAdvise-&gt;AddRef(); <br>            return NOERROR; <br>        } <br> <br>    // ----- bad news <br>    AssertSz(0,"out of aAdvisPtrs"); <br>    return ResultFromScode(E_FAIL); <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>FRM::Unadvise(ULONG ulConnection) <br>{ <br>    TraceTag(tagFormFunc,"FRM::Unadvise"); <br> <br>    AssertSz(cRef &gt; 0,"excuse me.  are you refering to me?"); <br>    AssertSz(ulConnection &lt; MAX_ADVISE &amp;&amp; ulConnection &gt;= 0,"testing, 123"); <br>    AssertSz(ulConnection,"a non-zero ulConnection is not valid according to OLE"); <br> <br>    // ----- forget about advising this guy <br>    --ulConnection; // remember, we added one in advise <br>    AssertSz(afAdvisee[(int) ulConnection],"never wanted ::Advise in ::Unadvise?"); <br>    afAdvisee[(int) ulConnection] = 0; <br>    aAdvisePtrs[(int) ulConnection]-&gt;Release(); <br>    return NOERROR; <br>} <br> <br> <br>/* <br> *  FRM::FRM <br> * <br> *  Purpose: <br> *      Initialize or new form object <br> * <br> */ <br>FRM::FRM(REFCLSID clsid) <br>{ <br>    LONG i; <br> <br>    TraceTag(tagFormFunc,"FRM::FRM ................."); <br> <br>    cRef = 1; <br>    this-&gt;clsid = clsid; <br> <br>    pMessage = NULL; <br>    pMessageSite = NULL; <br>    pSession = NULL; <br> <br>    pFormMgr = NULL; <br>    pFormInfo = NULL; <br> <br>    fDirty = FALSE; <br> <br>    for (i=0; i&lt;MAX_ADVISE; i++) <br>        { <br>            aAdvisePtrs[i] = NULL; <br>            afAdvisee[i] = 0; <br>        } <br> <br>    turn = 0; <br>} <br> <br>/* <br> *  FRM::~FRM <br> * <br> *  Purpose: <br> *      Destroy our form object <br> */ <br>FRM::~FRM(void) <br>{ <br>    TraceTag(tagFormFunc,"FRM::~FRM Bye now ..."); <br>    AssertSz(0==cRef,"quit referring to this form please"); <br>    AssertSz(NULL == pMessage,"still refing the message"); <br>    AssertSz(NULL == pMessageSite,"still refing the messagesite"); <br>    AssertSz(NULL == pSession,"still refing the session"); <br>} <br> <br>/* <br> *  S a m p l e   F o r m   C l a s s   F a c t o r y <br> * <br> *  Because we are an exe server, we must implement a class factory <br> *  so that other viewers (like Exchange) can learn of our clsid <br> * <br> */ <br> <br>/* <br> *  FRMFAC::CreateInstance <br> * <br> *  Purpose: <br> *      Creates a new form object of the IPM.Form class. <br> * <br> *  Arguments: <br> *      LPUNKNOWN       Outer object to aggregate with (not supported). <br> *      REFIID          Desired interface on new form object. <br> *      LPVOID FAR *    Where to put new form object. <br> * <br> *  Returns: <br> *      HRESULT         S_OK, or one of the following errors: <br> *                      CLASS_E_NOAGGREGATION, E_OUTOFMEMORY, <br> *                      E_NOINTERFACE, E_INVALIDARG. <br> */ <br>STDMETHODIMP <br>FRMFAC::CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID FAR * ppvObject) <br>{ <br>    FRM *   pfrm = NULL; <br>    HRESULT hr; <br> <br>    TraceTag(tagFormFunc,"FRMFAC::CreateInstance"); <br> <br>    // ----- Initialize out parameter and check validity of parameters <br>    if (!ppvObject) <br>        { <br>        hr = ResultFromScode(E_INVALIDARG); <br>        goto Cleanup; <br>        } <br>    *ppvObject = NULL; <br> <br>    if (punkOuter) <br>        { <br>        hr = ResultFromScode(CLASS_E_NOAGGREGATION); <br>        goto Cleanup; <br>        } <br> <br>    // ----- Instantiate new form <br>    if (!(pfrm = new FRM(clsid))) <br>        { <br>        hr = ResultFromScode(E_OUTOFMEMORY); <br>        TraceTag(tagForm,"E_OUTOFMEMORY 0x%08lx",hr); <br>        goto Cleanup; <br>        } <br> <br>    // ----- Get the desired interface <br>    hr = pfrm-&gt;QueryInterface(riid, ppvObject); <br>    AssertSz(0==hr,"QueryInterface failed"); <br> <br>Cleanup: <br>    ReleaseObj(pfrm); <br>    TraceTag(tagForm,"return 0x%08lx initial reference %d",hr,cRef); <br>    return hr; <br>} <br> <br>/* <br> *  FRMFAC::QueryInterface <br> * <br> *  Purpose: <br> *      Returns a pointer to the specified interface. <br> * <br> *  Arguments: <br> *      REFIID          Interface we want. <br> *      LPUNKNOWN *     Interface we return. <br> * <br> *  Returns: <br> *      HRESULT         Error status. <br> */ <br>STDMETHODIMP <br>FRMFAC::QueryInterface(REFIID riid, LPVOID FAR * ppvObj) <br>{ <br>    TraceTag(tagFuncTriv,"FRMFAC::QueryInterface %s",DumpCLSID(riid)); <br>    if (IsEqualIID(riid, IID_IUnknown) ||  <br>        IsEqualIID(riid, IID_IClassFactory)) <br>        { <br>        *ppvObj = this; <br>        AddRef(); <br>        TraceTag(tagForm,"return ok"); <br>        return NOERROR; <br>        } <br> <br>    *ppvObj = NULL; <br>    TraceTag(tagForm,"return no interface"); <br>    return ResultFromScode(E_NOINTERFACE); <br>} <br> <br>/* <br> *  FRMFAC::LockServer <br> * <br> *  Purpose: <br> *       <br> * <br> *  Arguments: <br> *      BOOL            Whether to increment or decrement DLL reference count. <br> * <br> *  Returns: <br> *      HRESULT         S_OK always. <br> */ <br>STDMETHODIMP <br>FRMFAC::LockServer(BOOL fLock) <br>{ <br>    TraceTag(tagFormFunc,"LockServer (not implemented)"); <br>    return NOERROR; <br>} <br> <br>/* <br> *  FRMFAC::AddRef <br> * <br> *  Purpose: <br> *      Increments reference count on the form class factory. <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      ULONG           New value of reference count. <br> */ <br>STDMETHODIMP_(ULONG) <br>FRMFAC::AddRef(void) <br>{ <br>    TraceTag(tagFuncTriv,"FRMFAC::AddRef ret %d",cRef+1); <br>    return ++cRef; <br>} <br> <br> <br>/* <br> *  FRMFAC::Release <br> * <br> *  Purpose: <br> *      Decrements reference count on the form class factory. <br> *      If count is decremented to zero, the object is freed. <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> *      ULONG           New value of reference count. <br> */ <br>STDMETHODIMP_(ULONG) <br>FRMFAC::Release(void) <br>{ <br>    TraceTag(tagFuncTriv,"FRMFAC::Release cRef %d",cRef); <br>    if (!(--cRef)) <br>        { <br>        TraceTag(tagForm,"return 0"); <br>        delete this; <br>        return 0; <br>        } <br>    return cRef; <br>} <br> <br> <br>FRMFMR::FRMFMR() <br>{ <br>    TraceTag(tagFuncTriv,"FRMFMR::FRMFMR"); <br>    clsid = CLSID_MyFormsClsId; <br>} <br> <br>FRMFAC::FRMFAC() <br>{ <br>    TraceTag(tagFuncTriv,"FRMFAC::FRMFAC"); <br>    cRef = 1; <br>} <br> <br>FRMFAC::~FRMFAC(void) <br>{ <br>    TraceTag(tagFuncTriv,"FRMFAC::~FRMFAC"); <br>    AssertSz(!cRef,"0817236"); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
