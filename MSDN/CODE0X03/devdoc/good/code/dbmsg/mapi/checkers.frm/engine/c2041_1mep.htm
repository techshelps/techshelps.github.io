<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHECK.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2041"></a>CHECK.CPP</h2>
<pre><code>/* function prototyping for internal functions */ <br>long CheckMiniMaxAlphaBeta(BOARD b, int t, int j, int d, long c, long p); <br> <br>#define JUMP_CONT_DEEPER 1 <br> <br>/* -------------------------------------------------------------------------- <br>true if previous level should prune <br>else false <br> <br>note: it would be possible to not prune equal qualities becuase they <br>      may be used to increase the number of available suggestions <br> <br>statistics: 02:42:00  3-13-1994 <br>            if this function is return 0, six levels takes 33 seconds <br>            if this function is implemented, six levels takes 9 seconds <br>-------------------------------------------------------------------------- */ <br>inline int AlphaBeta(int t,long q, long c) <br>{ <br>    pdebug(stddbg,"alpha-beta pruning t=%d q=%ld c=%ld %s(%d)\n",t,q,c,__FILE__,__LINE__); <br> <br>    if (c &gt; 0) <br>        { <br>        if (computer_color &amp; t) <br>            { <br>            if (q &gt; c) <br>                { <br>                pdebug(stddbg,"alpha-beta COMP pruning t=%d q=%ld c=%ld %s(%d)\n",t,q,c,__FILE__,__LINE__); <br>                return 1; <br>                } <br>            } <br>        else <br>            { <br>            if (q &lt; c) <br>                { <br>                pdebug(stddbg,"alpha-beta USER pruning t=%d q=%ld c=%ld %s(%d)\n",t,q,c,__FILE__,__LINE__); <br>                return 1; <br>                } <br>            } <br>        } <br>    return 0; <br>} <br> <br> <br>/* -------------------------------------------------------------------------- <br>The algorithm is basically a min-max tree <br>This function takes care of whether or no we remember the Min or the Max <br>In checkers terms this means the following: <br>    if it is my (the computers) move, pick the move that results in the highest quality <br>    if it is your move, remember the move that does the most damage (min quality) <br> <br>Parameters: <br>    t    - whos turn it is (RED or BLACK) <br>    type - the move type.  this parameter should be a constant from check.h <br>           it says if it the move is a black or red move, and if the move is <br>           a sliding or jumping move.  This also indicates if the move is a <br>           move towards the left or towards the right. <br>    number - this is the index into the move table derived from 'type' <br>    d      - current recursion depth (debugging purposes only) <br>    besttype    - type corresponding with bestquality <br>    bestnumber  - number corresponding with bestquality <br>    bestquality - either a min or a max of qualities depending on current turn <br>-------------------------------------------------------------------------- */ <br>inline void RememberMove(int t,int type, int number, long q,int d, <br>                         int* besttype, int* bestnumber, long* bestquality, <br>                         long c, long p, int* fBreak) <br>{ <br>    *fBreak = AlphaBeta(t,q,c); <br>    if (q == *bestquality) <br>        { <br>        pdebug(stddbg,"evaluation (equal move) t=%d type=%d num=%d q=%ld d=%d %s(%d)\n",t,type,number,q,d,__FILE__,__LINE__); <br>        if (1 &amp; rand()) return; <br>        } <br>    else if (computer_color &amp; t) <br>        { <br>        pdebug(stddbg,"evaluation (computer) t=%d type=%d num=%d q=%ld d=%d %s(%d)\n",t,type,number,q,d,__FILE__,__LINE__); <br>        if (q &lt; *bestquality) return; <br>        } <br>    else <br>        { <br>        pdebug(stddbg,"evaluation (opponent) t=%d type=%d num=%d q=%ld d=%d %s(%d)\n",t,type,number,q,d,__FILE__,__LINE__); <br>        if (*bestquality &gt; 0 &amp;&amp; q &gt; *bestquality) return; <br>        } <br> <br>    pdebug(stddbg,"RememberMove! evaluated t=%d type=%d num=%d q=%ld d=%d %s(%d)\n",t,type,number,q,d,__FILE__,__LINE__); <br>    *besttype = type; <br>    *bestnumber = number; <br>    *bestquality = q; <br>    return; <br>} <br> <br>/* -------------------------------------------------------------------------- <br>This function calls recurse for each possible jumping move for t's turn <br>starting from the start position <br> <br>Note: there is special logic to crown men since landing in a crown position <br>      can not continue the jump, but having a man that is already a king land <br>      in a crown position can continue a jump. <br>If the piece I am moving is a king, I look at both BLACK and RED moves. <br> <br>Parameters: <br>    b     - board (value is not changed) <br>    start - starting position <br>    t     - whos turn it is (RED or BLACK) <br>    besttype    - type corresponding with bestquality <br>    bestnumber  - number corresponding with bestquality <br>    bestquality - either a min or a max of qualities depending on current turn <br>-------------------------------------------------------------------------- */ <br>int IterateJumps(BOARD b, int start, int t, int d, <br>                 int* besttype, int* bestnumber, long* bestquality, <br>                 long c, long p, int *fBreak) <br>{ <br>    int moves_made=0; <br>    long q; <br>    SQUARE play_board[SQRS_MAX]; <br> <br>    if ((RED == t) || (KING &amp; b[start])) <br>        { <br>        AssertSz(b[start] &amp; t, "chicken"); <br>        if (0 == b[red_jump_lut[start][1]] &amp;&amp; red_jump_lut[start][1] &amp;&amp; (next(t) &amp; b[red_jump_lut[start][0]])) <br>            { <br>            pdebug(stddbg,"trying RED_JUMP0 std move %d %s(%d)\n",start,__FILE__,__LINE__); <br>            CopyBoard(b,play_board); <br>            MakeMoveNoKing_RED_JUMP0(play_board,start); <br>            if (0 == red_jump_lut[start][4] || (KING &amp; play_board[red_jump_lut[start][1]])) <br>                { <br>                q = CheckMiniMaxAlphaBeta(play_board,t,red_jump_lut[start][1],JUMP_CONT_DEEPER+d,c,p); <br>                } <br>            else <br>                { <br>                AssertSz(play_board[red_jump_lut[start][1]], "what the?"); <br>                play_board[red_jump_lut[start][1]] |= red_jump_lut[start][4]; <br>                q = CheckMiniMaxAlphaBeta(play_board,next(t),0,1+d,p,*bestquality); <br>                } <br>            RememberMove(t,TYPE_RED_JUMP0,start,q,d,besttype,bestnumber,bestquality,c,p,fBreak); <br>            ++moves_made; <br>            } <br>        if (0 == b[red_jump_lut[start][3]] &amp;&amp; red_jump_lut[start][3] &amp;&amp; (next(t) &amp; b[red_jump_lut[start][2]])) <br>            { <br>            pdebug(stddbg,"trying RED_JUMP2 std move %d %s(%d)\n",start,__FILE__,__LINE__); <br>            CopyBoard(b,play_board); <br>            MakeMoveNoKing_RED_JUMP2(play_board,start); <br>            if (0 == red_jump_lut[start][4] || (KING &amp; play_board[red_jump_lut[start][3]])) <br>                { <br>                q = CheckMiniMaxAlphaBeta(play_board,t,red_jump_lut[start][3],JUMP_CONT_DEEPER+d,c,p); <br>                } <br>            else <br>                { <br>                AssertSz(play_board[red_jump_lut[start][3]], "this stupid piece"); <br>                play_board[red_jump_lut[start][3]] |= red_jump_lut[start][4]; <br>                q = CheckMiniMaxAlphaBeta(play_board,next(t),0,1+d,p,*bestquality); <br>                } <br>            RememberMove(t,TYPE_RED_JUMP2,start,q,d,besttype,bestnumber,bestquality,c,p,fBreak); <br>            ++moves_made; <br>            } <br>        } <br>    if ((BLACK == t) || (KING &amp; b[start])) <br>        { <br>        AssertSz(b[start] &amp; t, "but... I thought it was my turn"); <br>        if (0 == b[black_jump_lut[start][1]] &amp;&amp; black_jump_lut[start][1] &amp;&amp; (next(t) &amp; b[black_jump_lut[start][0]])) <br>            { <br>            pdebug(stddbg,"trying BLACK_JUMP0 std move %d %s(%d)\n",start,__FILE__,__LINE__); <br>            CopyBoard(b,play_board); <br>            MakeMoveNoKing_BLACK_JUMP0(play_board,start); <br>            if (0 == black_jump_lut[start][4] || (KING &amp; play_board[black_jump_lut[start][1]])) <br>                { <br>                q = CheckMiniMaxAlphaBeta(play_board,t,black_jump_lut[start][1],JUMP_CONT_DEEPER+d,c,p); <br>                } <br>            else <br>                { <br>                AssertSz(play_board[black_jump_lut[start][1]], "you thought it was who's turn?"); <br>                play_board[black_jump_lut[start][1]] |= black_jump_lut[start][4]; <br>                q = CheckMiniMaxAlphaBeta(play_board,next(t),0,1+d,p,*bestquality); <br>                } <br>            RememberMove(t,TYPE_BLACK_JUMP0,start,q,d,besttype,bestnumber,bestquality,c,p,fBreak); <br>            ++moves_made; <br>            } <br>        if (0 == b[black_jump_lut[start][3]] &amp;&amp; black_jump_lut[start][3] &amp;&amp; (next(t) &amp; b[black_jump_lut[start][2]])) <br>            { <br>            pdebug(stddbg,"trying BLACK_JUMP2 std move %d %s(%d)\n",start,__FILE__,__LINE__); <br>            CopyBoard(b,play_board); <br>            MakeMoveNoKing_BLACK_JUMP2(play_board,start); <br>            if (0 == black_jump_lut[start][4] || (KING &amp; play_board[black_jump_lut[start][3]])) <br>                { <br>                q = CheckMiniMaxAlphaBeta(play_board,t,black_jump_lut[start][3],JUMP_CONT_DEEPER+d,c,p); <br>                } <br>            else <br>                { <br>                AssertSz(play_board[black_jump_lut[start][3]], "maggots"); <br>                play_board[black_jump_lut[start][3]] |= black_jump_lut[start][4]; <br>                q = CheckMiniMaxAlphaBeta(play_board,next(t),0,1+d,p,*bestquality); <br>                } <br>            RememberMove(t,TYPE_BLACK_JUMP2,start,q,d,besttype,bestnumber,bestquality,c,p,fBreak); <br>            ++moves_made; <br>            } <br>        } <br>    return moves_made; <br>} <br> <br>/* -------------------------------------------------------------------------- <br>This function calls recurse after making each possible sliding move for t's turn <br>starting from the start position <br> <br>If the piece I am moving is a king, I look at both BLACK and RED moves. <br> <br>Parameters: <br>    b     - board (value is not changed) <br>    start - starting position <br>    t     - whos turn it is (RED or BLACK) <br>    besttype    - type corresponding with bestquality <br>    bestnumber  - number corresponding with bestquality <br>    bestquality - either a min or a max of qualities depending on current turn <br>-------------------------------------------------------------------------- */ <br>int IterateMoves(BOARD b, int start, int t, int d, <br>                 int* besttype, int* bestnumber, long* bestquality, <br>                 long c, long p, int *fBreak) <br>{ <br>    int moves_made=0; <br>    long q; <br>    SQUARE play_board[SQRS_MAX]; <br> <br>    if ((RED == t) || (KING &amp; b[start])) <br>        { <br>        AssertSz(b[start] &amp; t, "I wish I could fly"); <br>        if (0 == b[red_lut[start][0]] &amp;&amp; red_lut[start][0]) <br>            { <br>            pdebug(stddbg,"trying RED0 std move %d %s(%d)\n",start,__FILE__,__LINE__); <br>            CopyBoard(b,play_board); <br>            MakeMove_RED0(play_board,start); <br>            q = CheckMiniMaxAlphaBeta(play_board,next(t),0,1+d,p,*bestquality); <br>            RememberMove(t,TYPE_RED0,start,q,d,besttype,bestnumber,bestquality,c,p,fBreak); <br>            ++moves_made; <br>            } <br>        if (0 == b[red_lut[start][2]] &amp;&amp; red_lut[start][2]) <br>            { <br>            pdebug(stddbg,"trying RED2 std move %d %s(%d)\n",start,__FILE__,__LINE__); <br>            CopyBoard(b,play_board); <br>            MakeMove_RED2(play_board,start); <br>            q = CheckMiniMaxAlphaBeta(play_board,next(t),0,1+d,p,*bestquality); <br>            RememberMove(t,TYPE_RED2,start,q,d,besttype,bestnumber,bestquality,c,p,fBreak); <br>            ++moves_made; <br>            } <br>        } <br> <br> <br>    if ((BLACK == t) || (KING &amp; b[start])) <br>        { <br>        AssertSz(b[start] &amp; t, "what are you... "); <br>        if (0 == b[black_lut[start][0]] &amp;&amp; black_lut[start][0]) <br>            { <br>            pdebug(stddbg,"trying BLACK0 std move %d %s(%d)\n",start,__FILE__,__LINE__); <br>            CopyBoard(b,play_board); <br>            MakeMove_BLACK0(play_board,start); <br>            q = CheckMiniMaxAlphaBeta(play_board,next(t),0,1+d,p,*bestquality); <br>            RememberMove(t,TYPE_BLACK0,start,q,d,besttype,bestnumber,bestquality,c,p,fBreak); <br>            ++moves_made; <br>            } <br>        if (0 == b[black_lut[start][2]] &amp;&amp; black_lut[start][2]) <br>            { <br>            pdebug(stddbg,"trying BLACK2 std move %d %s(%d)\n",start,__FILE__,__LINE__); <br>            CopyBoard(b,play_board); <br>            MakeMove_BLACK2(play_board,start); <br>            q = CheckMiniMaxAlphaBeta(play_board,next(t),0,1+d,p,*bestquality); <br>            RememberMove(t,TYPE_BLACK2,start,q,d,besttype,bestnumber,bestquality,c,p,fBreak); <br>            ++moves_made; <br>            } <br>        } <br>    return moves_made; <br>} <br> <br> <br>/* -------------------------------------------------------------------------- <br> <br>RECURSIVE MIN MAX ALGORITHM <br> <br>Parameters: <br>    b - pointer to the board <br>    t - whos turn it is (RED or BLACK) <br>    j - space on board in which jump landed or zero if this <br>        is not a jump continuation <br>    d - depth of recursion <br> <br>    alpha-beta pruning parameters: <br> <br>    c - cutoff value for min max algorithm <br>    p - threshold to be passed on to next level <br> <br>always returns the value of the best outcome of the board <br> <br>note: this function is to be called from within the checkers engine only <br>note: this function evaluates moves based on the piece order structure defined <br>      in lut.cpp.  The reason for this is that we gain two things by looking <br>      at the best moves first: <br>        1) pruning is more effective <br>        2) if we must give up due to time constraint, we have already <br>           evaluated some of the best moves. <br> <br>-------------------------------------------------------------------------- */ <br>long CheckMiniMaxAlphaBeta(BOARD b, int t, int j, int d, long c, long p) <br>{ <br>    /* ----- stack variables ----- */ <br>    int  moves_made        = 0; <br>    int  best_move_type    = -1; <br>    int  best_move_number  = -1; <br>    long best_move_quality = -1; <br>    int  fBreak            = 0; <br> <br>    /* ----- debug ----- */ <br>    #ifdef DEBUG <br>    debug=1; <br>    if (debug &amp;&amp; d &lt; 7) PrintBoard(b,d); <br>    #endif <br> <br>    AssertSz(b[0] == 0, "no b for my b my for my be my"); <br>    AssertSz(d &gt;= 0, "i am so tired of this"); <br> <br>    /* ----- if we have reached maximum depth, return now ----- */ <br>    if (d &gt;= depth_maximum) return QualityOfBoard(b,next(t)); <br> <br>    /* ----- iterate through all possible moves ----- */ <br>    if (0 == j) <br>        { <br>        int i; <br>        pdebug(stddbg,"standard iteration d=%d %s(%d)\n",d,__FILE__,__LINE__); <br>        for (i=0;i&lt;SQRS_MAX; i++) <br>            { <br>            int piece; <br>            piece = (int) piece_order[i].m; <br>            if (0 == (b[piece] &amp; t)) continue; /* not our piece */ <br>            moves_made += IterateJumps(b,piece,t,d,&amp;best_move_type,&amp;best_move_number,&amp;best_move_quality,c,p,&amp;fBreak); <br>            if (fBreak) <br>                { <br>                AssertSz(moves_made,"I'm pruning something I have not looked at..."); <br>                break; <br>                } <br>            } <br>        if (0 == moves_made /* enforce the must jump rule */ <br>            #ifndef HIGH_PERFORMANCE <br>                || 0==rConfig.iMustJump <br>            #endif <br>            ) <br>            { <br>            pdebug(stddbg,"could not find a jumping move to make %s(%d)\n",__FILE__,__LINE__); <br>            for (i=0;i&lt;SQRS_MAX; i++) <br>                { <br>                int piece; <br>                piece = (int) piece_order[i].m; <br>                if (0 == (b[piece] &amp; t)) continue; /* not our piece */ <br>                moves_made += IterateMoves(b,piece,t,d,&amp;best_move_type,&amp;best_move_number,&amp;best_move_quality,c,p,&amp;fBreak); <br>                if (fBreak) <br>                    { <br>                    AssertSz(moves_made,"to Scottland, I have not been"); <br>                    break; <br>                    } <br>                } <br>            } <br>        if (0 == moves_made) <br>            { <br>            pdebug(stddbg,"could not find a move to make (error not handled) %s(%d)\n",__FILE__,__LINE__); <br>            return QualityOfBoard(b,next(t)); <br>            } <br> <br>        return best_move_quality; <br>        } <br> <br>    /* ----- handle jump continuation ----- */ <br>    pdebug(stddbg,"jump continuation d=%d %s(%d)\n",d,__FILE__,__LINE__); <br>    moves_made = IterateJumps(b,j,t,d,&amp;best_move_type,&amp;best_move_number,&amp;best_move_quality,c,p,&amp;fBreak); <br>    // AssertSz(0==fBreak,"is this a valid assert?"); <br>    if (0==moves_made) <br>        { <br>        return CheckMiniMaxAlphaBeta(b,next(t),0,d,p,best_move_quality); <br>        } <br>    return best_move_quality; <br> <br>} /* end CheckMiniMaxAlphaBeta */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
