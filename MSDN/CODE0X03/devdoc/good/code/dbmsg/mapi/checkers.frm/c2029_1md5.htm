<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WCHECK.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2039"></a>WCHECK.CPP</h2>
<pre><code>/* -------------------------------------------------------------------------- <br> <br>Basic Forms example of a custom sendable form.  It is an EXE server <br>rather than a DLL.  It implements the minimum form interface required <br>to launch and send a form. <br> <br>Copyright (C) 1995 Microsoft Corporation <br> <br>-------------------------------------------------------------------------- */ <br> <br>#define WINDOWS <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;search.h&gt; <br> <br>#ifdef _WIN32 <br>#include &lt;winver.h&gt; <br>#else <br>#include &lt;ver.h&gt; <br>#endif <br> <br>//$FORM <br> <br>//---[ Form specific includes ]-------------------------------------------- <br> <br>#include &lt;ole2.h&gt; <br>#include &lt;mapiform.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapiutil.h&gt; <br> <br>//$FORM <br> <br>//---[ Various platform defines ]------------------------------------------ <br> <br>#ifndef APIENTRY                // Windows NT defines APIENTRY, <br>#define APIENTRY far pascal             // but 3.x doesn't. <br>#endif <br> <br>#ifndef _WIN32                   // Windows 3.x uses a FARPROC <br>#define DLGPROC FARPROC                 // for dialogs <br>#endif <br> <br>unsigned int _charmax; <br> <br>#ifdef _WIN32 <br>#define MoveTo(_1, _2, _3) MoveToEx(_1,_2,_3,NULL) <br>#endif <br> <br>//---[ Define Debug Trace Tags ]------------------------------------------- <br> <br>#include "dbugit.h" <br> <br>#ifdef DEBUG <br>ASSERTDATA <br>#endif <br> <br>//---[ Local header dependencies ]----------------------------------------- <br> <br>#include "check.h" <br>#include "dlg.h" <br>#include "wcheck.h" <br>#include "checkdta.h" <br>#include "movelist.h" <br>#include "form.h" //$FORM <br> <br>//---[ Globally Accessible Config Info ]----------------------------------- <br> <br>struct  rCheckConfigRec rConfig;                // Config struct <br>struct  rGameStateRec rGameState;               // Game state <br>class   CMoveList CMoves;                               // Move list <br>SQUARE  b[SQRS_MAX];                                    // Board structure <br> <br>static  POINT       pntStart;                   // For buttonup/down processing. <br> <br>char szAppName[] = APP_NAME;                    // The name of this application <br> <br>#ifdef DEBUG <br>char szTitle[]   = "Checkers (debug)"; <br>#else <br>#ifdef TEST <br>char szTitle[]   = "Checkers (test)"; <br>#else <br>char szTitle[]   = "Checkers"; <br>#endif <br>#endif <br> <br>//---[ Globally Accessible Handles ]--------------------------------------- <br> <br>HINSTANCE       hInst;          // current instance handle <br> <br>HWND    hMainWnd        = NULL;         // Main window handle <br>HWND    hClientWnd      = NULL;         // Client window handle <br>HBRUSH  hbrBlack;                        <br>HBRUSH  hbrWhite;                        <br>HBRUSH  hbrRed;                          <br>HBRUSH  hbrBckgrnd;                      <br>HBRUSH  hbrBlue;                         <br>HBRUSH  hbrHuman;                        <br>HBRUSH  hbrComputer;             <br>HBRUSH  hbrDkgrey;                       <br>HPEN    hpenDkgrey;                      <br>HBITMAP hBtmaps;                        // Piece bitmaps <br> <br>HCURSOR curNormal;                      // Standard cursor <br>HCURSOR curThink;                       // Computer is thinking cursor <br>HCURSOR curPiece;                       // Piece cursor (move in progress) <br>HCURSOR curResize;                      // Resize cursor <br> <br>#define SQR_XSIZE       rConfig.iSquareSize <br>#define SQR_YSIZE       rConfig.iSquareSize <br> <br>#define OFST_INCREMENT      rConfig.iSquareSize         // OFFSET into bitmap <br>#define OFST_BLANK          (0*OFST_INCREMENT)          // OFFSET into bitmap <br>#define OFST_BLANK_RED      (1*OFST_INCREMENT)          // OFFSET into bitmap <br>#define OFST_COMPUTER       (2*OFST_INCREMENT)          // OFFSET into bitmap <br>#define OFST_COMPUTER_KING  (3*OFST_INCREMENT)          // OFFSET into bitmap <br>#define OFST_HUMAN_KING     (4*OFST_INCREMENT)          // OFFSET into bitmap <br>#define OFST_HUMAN          (5*OFST_INCREMENT)          // OFFSET into bitmap <br> <br>FRM *pfrm; //$FORM <br> <br>//---[ Inline code includes ]---------------------------------------------- <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br>CMoveList::CMoveList() <br>{ <br>    m_iNumBoards = 0; <br>    m_fClassInitialized = FALSE; <br>    m_prFirstBoard = NULL; <br>    m_prCurrentBoard = m_prFirstBoard; <br>    m_prCurrentSearchBoard = m_prFirstBoard; <br>} <br> <br>CMoveList::~CMoveList() <br>{ <br>    m_prCurrentBoard = m_prFirstBoard; <br>    PurgeBoards(); <br>} <br> <br>BOARD CMoveList::GetFirstBoard(BOARD b, int *piPlayerTurn) <br>{ <br>    AssertSz(m_fClassInitialized, "MoveList class not initialized in GetFirstBoard()"); <br> <br>    m_prCurrentSearchBoard = m_prFirstBoard; <br>    if (NULL == m_prCurrentSearchBoard) <br>    return NULL; <br>    else <br>    { <br>    AssertSz((BLACK == m_prCurrentSearchBoard-&gt;iPlayerTurn) || <br>             (RED == m_prCurrentSearchBoard-&gt;iPlayerTurn),  <br>             "EBr rocks!"); <br>     <br>        *piPlayerTurn = m_prCurrentSearchBoard-&gt;iPlayerTurn; <br>    CopyBoard(m_prCurrentSearchBoard-&gt;b, b); <br>         <br>    m_prCurrentSearchBoard = m_prCurrentSearchBoard-&gt;prNextBoard; <br>    return b; <br>    } <br>} <br> <br>BOARD CMoveList::GetNextBoard(BOARD b, int *piPlayerTurn) <br>{ <br>    AssertSz(m_fClassInitialized, "MoveList class not initialized in GetNextBoard()"); <br> <br>    if (NULL == m_prCurrentSearchBoard) <br>    { <br>    return NULL; <br>    } <br>    else <br>    { <br>    AssertSz((BLACK == m_prCurrentSearchBoard-&gt;iPlayerTurn) || <br>             (RED == m_prCurrentSearchBoard-&gt;iPlayerTurn),  <br>             "Kt C abayn  04/07/94"); <br>     <br>        *piPlayerTurn = m_prCurrentSearchBoard-&gt;iPlayerTurn;         <br>    CopyBoard(m_prCurrentSearchBoard-&gt;b, b); <br>    m_prCurrentSearchBoard = m_prCurrentSearchBoard-&gt;prNextBoard; <br>    return b; <br>    } <br>} <br> <br>BOOL CMoveList::Init() <br>{ <br>    AssertSz(!m_fClassInitialized, "Class already initialized"); <br> <br>    m_fClassInitialized = TRUE; <br>    return TRUE; <br>} <br> <br>BOOL CMoveList::BackMove(BOARD b, int *piPlayerTurn) <br>{ <br>    AssertSz(m_fClassInitialized, "MoveList class not initialized in BackMove()"); <br> <br>    if (NULL == m_prFirstBoard) <br>    return FALSE; <br> <br>    AssertSz(m_prCurrentBoard, "Current Board hosed"); <br> <br>    if (m_prCurrentBoard == m_prFirstBoard) <br>    { <br>    return FALSE; <br>    } <br>    else <br>    { <br>    m_prCurrentBoard = m_prCurrentBoard-&gt;prPrevBoard; <br>     <br>    AssertSz((BLACK == m_prCurrentBoard-&gt;iPlayerTurn) || <br>             (RED == m_prCurrentBoard-&gt;iPlayerTurn),  <br>             "Meatloaf"); <br> <br>        *piPlayerTurn = m_prCurrentBoard-&gt;iPlayerTurn; <br>    CopyBoard(m_prCurrentBoard-&gt;b, b); <br>    return TRUE; <br>    } <br>} <br> <br>BOOL CMoveList::ForwardMove(BOARD b, int *piPlayerTurn) <br>{ <br>    AssertSz(m_fClassInitialized, "MoveList class not initialized in ForwardMove()"); <br> <br>    if (NULL == m_prCurrentBoard) <br>    return FALSE; <br> <br>    if (NULL == m_prCurrentBoard-&gt;prNextBoard) <br>    return FALSE; <br>    else <br>    { <br>    m_prCurrentBoard = m_prCurrentBoard-&gt;prNextBoard; <br> <br>    AssertSz((BLACK == m_prCurrentBoard-&gt;iPlayerTurn) || <br>             (RED == m_prCurrentBoard-&gt;iPlayerTurn),  <br>             "Just say no to yes."); <br> <br>        *piPlayerTurn = m_prCurrentBoard-&gt;iPlayerTurn; <br>    CopyBoard(m_prCurrentBoard-&gt;b, b); <br>    return TRUE; <br>    } <br>} <br> <br>BOOL CMoveList::NewMove(BOARD b, int iPlayerTurn) <br>{ <br>    struct rBoardNode *prNewBoard = NULL; <br> <br>    AssertSz(m_fClassInitialized, "MoveList class not initialized in NewMove()"); <br> <br>    // Remove any old boards that would get overwritten. <br> <br>    if (NULL != m_prCurrentBoard) <br>    { <br>    PurgeBoards(); <br>    } <br>     <br>    prNewBoard = (struct rBoardNode *)malloc(sizeof(struct rBoardNode)); <br>    if (!prNewBoard) <br>    { <br>    MessageBox(NULL, "Out of memory.", "Checkers", MB_ICONEXCLAMATION | MB_OK); <br>    return FALSE; <br>    } <br>    else <br>    { <br>    m_iNumBoards++; <br> <br>    prNewBoard-&gt;prNextBoard = NULL; <br>    prNewBoard-&gt;prPrevBoard = NULL; <br>    CopyBoard(b, prNewBoard-&gt;b); <br> <br>    if (NULL == m_prFirstBoard) <br>    { <br>        m_prFirstBoard = prNewBoard; <br>    } <br>    else <br>    { <br>        m_prCurrentBoard-&gt;prNextBoard = prNewBoard; <br>    } <br> <br>    prNewBoard-&gt;prPrevBoard = m_prCurrentBoard; <br>    prNewBoard-&gt;iPlayerTurn = iPlayerTurn; <br>    m_prCurrentBoard = prNewBoard; <br>    return TRUE; <br>    } <br>} <br> <br>BOOL CMoveList::ClearBoards() <br>{ <br>    m_prCurrentBoard = m_prFirstBoard; <br>    return (PurgeBoards()); <br>} <br> <br>BOOL CMoveList::PurgeBoards() <br>{ <br>    struct rBoardNode *prDeleteBoard; <br>     <br>    if (NULL == m_prCurrentBoard || 0 == m_fClassInitialized) <br>    return TRUE; <br>    else <br>    { <br>    prDeleteBoard = m_prCurrentBoard-&gt;prNextBoard; <br>    while (prDeleteBoard != NULL) <br>    { <br>        m_prCurrentBoard-&gt;prNextBoard = prDeleteBoard-&gt;prNextBoard; <br>        free (prDeleteBoard); <br>        m_iNumBoards--; <br>        prDeleteBoard = m_prCurrentBoard-&gt;prNextBoard; <br>    } <br>    return TRUE; <br>    } <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>BOOL WritePrivateProfileLong(LPCSTR lpszSection, LPCSTR lpszEntry, long lTheLong, LPCSTR lpszFilename); <br>BOOL WritePrivateProfileInt(LPCSTR lpszSection, LPCSTR lpszEntry, int iTheInt, LPCSTR lpszFilename); <br>long GetDlgItemLong(HWND hDlg, WORD id); <br>int  GetDlgItemInt(HWND hDlg, WORD id); <br>void SetDlgItemInt(HWND hDlg, WORD id, int iValue); <br>void SetDlgItemLong(HWND hDlg, WORD id, long lValue); <br>BOOL ValidateNumeric(char *pszText); <br>LONG GetPrivateProfileLong(LPCSTR lpszSection, LPCSTR lpszEntry, long lDefault, LPCSTR lpszFileName); <br> <br>BOOL WritePrivateProfileInt(LPCSTR lpszSection, LPCSTR lpszEntry, int iTheInt, LPCSTR lpszFilename) <br>{ <br>    char szINIString[32]; <br> <br>    AssertSz(lpszSection, "lpszSection == NULL"); <br>    AssertSz(lpszEntry, "lpszEntry == NULL"); <br>    AssertSz(lpszFilename, "lpszFilename == NULL"); <br> <br>    _itoa(iTheInt, szINIString, 10);   // Convert the int to a string. Base10 <br>     return WritePrivateProfileString(lpszSection, lpszEntry, (LPSTR)szINIString, lpszFilename); <br>} <br> <br>long GetDlgItemLong(HWND hDlg, WORD id) <br>{ <br>    char szTemp[20];    // Can't imagine a number longer than this. <br>    long lTemp; <br> <br>    GetDlgItemText (hDlg, id, (LPSTR) szTemp, sizeof(szTemp)); <br>    lTemp = atol(szTemp); <br> <br>    return lTemp; <br>} <br> <br>int GetDlgItemInt(HWND hDlg, WORD id) <br>{ <br>    char szTemp[20];    // Can't imagine a number longer than this. <br>    int iTemp; <br> <br>    GetDlgItemText (hDlg, id, (LPSTR) szTemp, sizeof(szTemp)); <br>    iTemp = atoi(szTemp); <br> <br>    return iTemp; <br>} <br> <br>void SetDlgItemInt(HWND hDlg, WORD id, int iValue) <br>{ <br>    char szTemp[20];     // Can't imagine a number longer than this. <br>     <br>    _itoa(iValue, szTemp, 10); <br>    SetDlgItemText (hDlg, id, szTemp); <br>} <br> <br>void SetDlgItemLong(HWND hDlg, WORD id, long lValue) <br>{ <br>    char szTemp[20];     // Can't imagine a number longer than this. <br>     <br>    _ltoa(lValue, szTemp, 10); <br>    SetDlgItemText (hDlg, id, szTemp); <br>} <br> <br>LONG GetPrivateProfileLong(LPCSTR lpszSection, LPCSTR lpszEntry, long lDefault, LPCSTR lpszFileName) <br>{ <br>    LONG l; <br>    char szTemp[20]; <br> <br>    GetPrivateProfileString(lpszSection, lpszEntry, "~~", szTemp, 20, lpszFileName); <br>    if (lstrcmp(szTemp, "~~") == 0) <br>    l = lDefault; <br>    else <br>    l = atol(szTemp); <br>    return l; <br>} <br> <br>BOOL WritePrivateProfileLong(LPCSTR lpszSection, LPCSTR lpszEntry, long lTheLong, LPCSTR lpszFilename) <br>{ <br>    char szINIString[32]; <br> <br>    AssertSz(lpszSection, "lpszSection == NULL"); <br>    AssertSz(lpszEntry, "lpszEntry == NULL"); <br>    AssertSz(lpszFilename, "lpszFilename == NULL"); <br> <br>    _ltoa(lTheLong, szINIString, 10);   // Convert the int to a string. Base10 <br>     return WritePrivateProfileString(lpszSection, lpszEntry, (LPSTR)szINIString, lpszFilename); <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br>int OpenCheckers(HINSTANCE hInstance, int nCmdShow) <br>{ <br>    MSG msg; <br>    HACCEL hAccelTable = NULL;          // Accelerator table handle. <br> <br>    // Perform initializations that apply to a specific instance <br> <br>    if (!InitInstance(hInstance, nCmdShow))  <br>    { <br>    AssertSz(0,"InitInst failed"); <br>        return (FALSE); <br>    } <br> <br>    hAccelTable = LoadAccelerators (hInstance, (LPSTR)"WCheck"); <br>    AssertSz(hAccelTable,"no accelerators"); <br> <br>    // Acquire and dispatch messages until a WM_QUIT message is received. <br> <br>    while (GetMessage(&amp;msg,         // message structure <br>        NULL,                                   // handle of window receiving the message <br>        0,                                      // lowest message to examine <br>        0))                                     // highest message to examine <br>    { <br>        if (!TranslateAccelerator (msg.hwnd, hAccelTable, &amp;msg))  <br>        { <br>            TranslateMessage(&amp;msg); // Translates virtual key codes <br>            DispatchMessage(&amp;msg);  // Dispatches message to window <br>        } <br>    } <br> <br>    return 0; <br> <br>} /* end open checkers */ <br> <br>/**************************************************************************** <br> <br>    FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int) <br> <br>    PURPOSE: calls initialization function, processes message loop <br> <br>    COMMENTS: <br> <br>        Windows recognizes this function by name as the initial entry point <br>        for the program.  This function calls the application initialization <br>        routine, if no other instance of the program is running, and always <br>        calls the instance initialization routine.  It then executes a message <br>        retrieval and dispatch loop that is the top-level control structure <br>        for the remainder of execution.  The loop is terminated when a WM_QUIT <br>        message is received, at which time this function exits the application <br>        instance by returning the value passed by PostQuitMessage(). <br> <br>        If this function must abort before entering the message loop, it <br>        returns the conventional value NULL. <br> <br>****************************************************************************/ <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow) <br>{ <br> <br>    AssertSz(((RED == PLAYER1) &amp;&amp; (BLACK == PLAYER2)) ||  <br>         ((BLACK == PLAYER1) &amp;&amp; (RED == PLAYER2)), "Players are schizoid"); <br> <br>    hInst = hInstance;                              // Set global Instance handle <br> <br>    if (!hPrevInstance)                                              <br>    { <br>        if (!InitApplication(hInstance))         <br>        { <br>            return (FALSE);      <br>        } <br>    } <br> <br>    // Check for the -Embedding switch <br> <br>    if (lpCmdLine &amp;&amp; (lpCmdLine[0] == '/' || lpCmdLine[0] == '-')) <br>    { <br> <br>        // Attempt to be a form <br> <br>    if (NOERROR == HrStartOleAndRegisterClassFactory()) <br>        { <br>        rGameState.fPlayAsForm = TRUE; // we are acting as a form <br> <br>        #ifdef DEBUG <br>        nCmdShow = SW_SHOWMINIMIZED; <br>        #else <br>        nCmdShow = SW_HIDE; <br>        #endif <br> <br>        // Open the checkers form window .. but do not show until we're DoVerb'd <br> <br>        OpenCheckers(hInstance, nCmdShow); <br> <br>        // Call this function if ..StartForms succeeded <br> <br>        HrStopForms(); <br> <br>        return 0; <br>        } <br> <br>        if (IDYES == MessageBox(GetFocus(), "Unable to initialize messaging subsystem.\nWould you like to play against the computer?", "Checkers", MB_YESNO )) <br>        { <br>        OpenCheckers(hInstance, nCmdShow); <br>        return 0; <br>        } <br> <br>    } <br> <br>    OpenCheckers(hInstance, nCmdShow); <br>    return 0; <br>} <br> <br>VOID ReadPlayerInfo(int iPlayerNum, char *pszPlayerName) <br>{ <br>    AssertSz((iPlayerNum == BLACK) || (iPlayerNum == RED), "Invalid Player Num"); <br>    AssertSz(pszPlayerName, "Playername can't be NULL"); <br> <br>    if (rGameState.fPlayAsForm) <br>    { <br>    rConfig.rPlayer[iPlayerNum].iPlayerType = HUMAN_PLAYER; <br>    if (22871 == GetPrivateProfileInt ("Computer", "Config", HUMAN_PLAYER, INI_NAME)) <br>        { <br>        rConfig.rPlayer[iPlayerNum].iPlayerType = COMPUTER_PLAYER; <br>        } <br>    } <br>    else <br>    { <br>    if (PLAYER1 == iPlayerNum) <br>        rConfig.rPlayer[iPlayerNum].iPlayerType = HUMAN_PLAYER; <br>    else <br>        rConfig.rPlayer[iPlayerNum].iPlayerType = COMPUTER_PLAYER; <br>    } <br>        <br>    // Get computer config options. <br> <br>    rConfig.rPlayer[iPlayerNum].iMemPositions = GetPrivateProfileInt (pszPlayerName, "MemPositions", 0, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].iUseMoveTheory = GetPrivateProfileInt (pszPlayerName, "UseMoveTheory", 1, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].iUseMoveShuffling = GetPrivateProfileInt (pszPlayerName, "UseMoveShuffling", 1, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].iUseEqualMoveSkipping = GetPrivateProfileInt (pszPlayerName, "UseEqualMoveSkipping", 1, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].iUseOpeningBook = GetPrivateProfileInt (pszPlayerName, "UseOpeningBook", 1, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].lUseGoodMoveSkipping = GetPrivateProfileLong (pszPlayerName, "UseGoodMoveSkipping", 0, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].iMaxRecursionDepth = GetPrivateProfileInt (pszPlayerName, "MaxRecursionDepth", 5, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].iUseAlphaBetaPruning = GetPrivateProfileInt (pszPlayerName, "UseAlphaBetaPruning", 1, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].lAlphaPruningOriginalDepth = GetPrivateProfileLong (pszPlayerName, "AlphaPruningOriginalDepth", 2, INI_NAME); <br>    rConfig.rPlayer[iPlayerNum].lAlphaPruningWidth = GetPrivateProfileLong (pszPlayerName, "AlphaPruningWidth", 35, INI_NAME); <br> <br>} <br> <br>VOID    ReadINI () <br>{ <br>    TraceTag(tagUI,"ReadINI()"); <br> <br>    // Read general config info <br> <br>    rConfig.iGameType = GetPrivateProfileInt ("Config", "GameType", GAME_CHECKERS, INI_NAME); <br>    rConfig.iMustJump = GetPrivateProfileInt ("Config", "MustJump", 1, INI_NAME); <br>    rConfig.iBoardFlipped = 1; <br>    rConfig.iSquareSize = GetPrivateProfileInt ("Config", "SquareSize", 30, INI_NAME); <br>    rConfig.iMaxMoves = GetPrivateProfileInt ("Config", "MaxMoves", 200, INI_NAME); <br> <br>    // Read specific player config for both (potential) computer players. <br> <br>    ReadPlayerInfo(PLAYER1, "Player1"); <br>    ReadPlayerInfo(PLAYER2, "Player2"); <br>} <br> <br>VOID WritePlayerInfo(int iPlayerNum, char *pszPlayerName) <br>{ <br>    AssertSz((iPlayerNum == RED) || (iPlayerNum == BLACK), "Invalid Player Num"); <br>    AssertSz(pszPlayerName, "Playername can't be NULL"); <br> <br>    // Player specific config items <br> <br>    WritePrivateProfileInt (pszPlayerName, "PlayerType", rConfig.rPlayer[iPlayerNum].iPlayerType, INI_NAME); <br>    WritePrivateProfileInt (pszPlayerName, "MemPositions", rConfig.rPlayer[iPlayerNum].iMemPositions, INI_NAME); <br>    WritePrivateProfileInt (pszPlayerName, "UseMoveTheory", rConfig.rPlayer[iPlayerNum].iUseMoveTheory, INI_NAME); <br>    WritePrivateProfileInt (pszPlayerName, "UseMoveShuffling", rConfig.rPlayer[iPlayerNum].iUseMoveShuffling, INI_NAME); <br>    WritePrivateProfileInt (pszPlayerName, "UseEqualMoveSkipping", rConfig.rPlayer[iPlayerNum].iUseEqualMoveSkipping, INI_NAME); <br>    WritePrivateProfileInt (pszPlayerName, "UseOpeningBook", rConfig.rPlayer[iPlayerNum].iUseOpeningBook, INI_NAME); <br>    WritePrivateProfileLong(pszPlayerName, "UseGoodMoveSkipping", rConfig.rPlayer[iPlayerNum].lUseGoodMoveSkipping, INI_NAME); <br>    WritePrivateProfileInt (pszPlayerName, "MaxRecursionDepth", rConfig.rPlayer[iPlayerNum].iMaxRecursionDepth, INI_NAME); <br>    WritePrivateProfileInt (pszPlayerName, "UseAlphaBetaPruning", rConfig.rPlayer[iPlayerNum].iUseAlphaBetaPruning, INI_NAME); <br>    WritePrivateProfileLong(pszPlayerName, "AlphaPruningOriginalDepth", rConfig.rPlayer[iPlayerNum].lAlphaPruningOriginalDepth, INI_NAME); <br>    WritePrivateProfileLong(pszPlayerName, "AlphaPruningWidth", rConfig.rPlayer[iPlayerNum].lAlphaPruningWidth, INI_NAME); <br> <br>} <br> <br>VOID    WriteINI () <br>{ <br>    RECT    rect; <br>    char    szTempStr[10];                       // For rect.value translation <br> <br>    TraceTag(tagUI,"WriteINI()"); <br> <br>    // Store state of config radio buttons <br> <br>    WritePrivateProfileInt ("Config", "GameType", rConfig.iGameType, INI_NAME); <br>    WritePrivateProfileInt ("Config", "MustJump", rConfig.iMustJump, INI_NAME); <br>    WritePrivateProfileInt ("Config", "SquareSize", rConfig.iSquareSize, INI_NAME); <br>    WritePrivateProfileInt ("Config", "MaxMoves", rConfig.iMaxMoves, INI_NAME); <br> <br>    // Write player info <br> <br>    WritePlayerInfo(PLAYER1, "Player1"); <br>    WritePlayerInfo(PLAYER2, "Player2"); <br> <br>    // Store state of Window <br> <br>    GetWindowRect (hMainWnd, &amp;rect); <br>    if (!IsIconic(hMainWnd)) <br>    { <br>    wsprintf (szTempStr, "%d", rect.left); <br>    WritePrivateProfileString ("Window", "Left", szTempStr, INI_NAME); <br>    wsprintf (szTempStr, "%d", rect.top); <br>    WritePrivateProfileString ("Window", "Top", szTempStr, INI_NAME); <br>    wsprintf (szTempStr, "%d", rect.right - rect.left); <br>    WritePrivateProfileString ("Window", "Width", szTempStr, INI_NAME); <br>    wsprintf (szTempStr, "%d", rect.bottom - rect.top); <br>    WritePrivateProfileString ("Window", "Height", szTempStr, INI_NAME); <br>    } <br> <br>} <br> <br>BOOL InitApplication(HINSTANCE hInstance) <br>{ <br>    WNDCLASS        wc; <br> <br>    // Fill in window class structure with parameters that describe the <br>    // main window. <br> <br>    wc.style         = CS_HREDRAW | CS_VREDRAW;             // Class style(s). <br>    wc.lpfnWndProc   = (WNDPROC)CheckersWndProc;    // Window Procedure <br>    wc.cbClsExtra    = 0;                                   // No per-class extra data. <br>    wc.cbWndExtra    = 0;                                   // No per-window extra data. <br>    wc.hInstance     = hInstance;                           // Owner of this class <br>    wc.hIcon         = LoadIcon (hInstance, "WCheckIcon");  // Icon name from .RC <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);                 // Cursor <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);                    // Default color <br>    wc.lpszMenuName  = (LPSTR)"WCheck_NORMAL";              // Menu name from .RC <br>    wc.lpszClassName = szAppName;                                           // Name to register as <br> <br>    // Register the window class and return success/failure code. <br>    return (RegisterClass(&amp;wc)); <br>} <br> <br> <br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>    HWND    hWnd; // Main window handle. <br>    HDC hdc = NULL; <br> <br>    // Save the instance handle in static variable, which will be used in <br>    // many subsequence calls from this application to Windows. <br> <br>    // need to set this here because we may get call from somewhere besides winmain <br>    hInst = hInstance; // Store instance handle in our global variable <br> <br>    hbrWhite = (HBRUSH)GetStockObject(WHITE_BRUSH); <br>    hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH); <br> <br>    hbrRed        = CreateSolidBrush(RGB(0xFF,0,0)); <br>    hbrBckgrnd    = CreateSolidBrush(GetNearestColor(hdc, RGB(0xAA,0xAA,0xAA))); <br>    hbrBlue       = CreateSolidBrush(RGB(0,0,0xFF)); <br>    hpenDkgrey    = CreatePen( PS_SOLID, 1, RGB( 0x55, 0x55, 0x55 ) ); <br> <br>    #ifdef _WIN32 <br>        hbrDkgrey     = CreateSolidBrush(RGB(0x55,0x55,0x55)); <br>    #else <br>        hbrDkgrey     = CreateSolidBrush(GetNearestColor(hdc, RGB(0x55,0x55,0x55))); <br>    #endif <br> <br>    // Fail initialization if we can't create brushs/pens/etc.. <br> <br>    if (!hbrRed ||  <br>        !hbrBckgrnd ||  <br>        !hbrBlue || <br>        !hbrWhite ||  <br>        !hbrBlack ||  <br>        !hpenDkgrey ||  <br>        !hbrDkgrey) <br>    return(FALSE); <br> <br>    curNormal   = LoadCursor(NULL, IDC_ARROW); <br>    curThink    = LoadCursor(NULL, IDC_WAIT); <br>    curResize       = LoadCursor(NULL, IDC_SIZENWSE); <br> <br>    if (!curNormal || !curThink || !curResize) <br>    return(FALSE); <br> <br>    // Create a main window for this application instance. <br>    hWnd = CreateWindow( <br>        szAppName,           // See RegisterClass() call. <br>        szTitle,             // Text for window title bar. <br>        WS_OVERLAPPEDWINDOW, // Window style. <br>    GetPrivateProfileInt ("Window", "Left",  13  /* CW_USEDEFAULT */, INI_NAME), <br>    GetPrivateProfileInt ("Window", "Top",   8   /* CW_USEDEFAULT */, INI_NAME), <br>    GetPrivateProfileInt ("Window", "Width", 356 /* CW_USEDEFAULT */, INI_NAME), <br>    GetPrivateProfileInt ("Window", "Height",306 /* CW_USEDEFAULT */, INI_NAME), <br>        NULL,                // Overlapped windows have no parent. <br>        NULL,                // Use the window class menu. <br>        hInstance,           // This instance owns this window. <br>        NULL                 // We don't use any data in our WM_CREATE <br>    ); <br> <br>    // If window could not be created, return "failure" <br>    if (!hWnd) { <br>        return (FALSE); <br>    } <br> <br>    while (!SetTimer (hWnd, ID_TIMER, TIMER_GRANULARITY, NULL)) <br>    { <br>    if (IDCANCEL == MessageBox (hWnd, "Too many clocks or timers!", szAppName, <br>        MB_ICONEXCLAMATION | MB_RETRYCANCEL)) <br>        { <br>        return FALSE; <br>        } <br>    } <br> <br>    // Make the window visible; update its client area; and return "success" <br> <br>    ShowWindow(hWnd, nCmdShow); // Show the window // SW_SHOWNORMAL // SW_HIDE <br>    UpdateWindow(hWnd);         // Sends WM_PAINT message <br> <br>    SendMessage(hWnd, WM_OTHERINIT, 0, 0L); <br> <br>    return (TRUE);              // We succeeded... <br> <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>// FillBoard() puts the pieces on the board (draws them). <br> <br>void NEAR PASCAL FillBoard(BOARD b, HDC hDC) <br> <br>{ <br>    int         i                       = 0;            // Loop (for pieces) variable <br>    HDC         hTmpDC          = NULL;         // Temp work DC <br>    HBITMAP hOldbm              = NULL;         // Store old Bitmap handle <br>    int         yBm             = 0;            // Bitmap to use (depending on piece) <br>    int         iOffset         = 0;            // Squares alternate starting postion.. <br>    int         iX                      = 0;            // Location (x) to place square <br>    int             iY                      = 0;            // Location (y) to place square <br>    int     iLocation       = 0;            // For figuring real location after swap.. <br> <br>    hTmpDC = CreateCompatibleDC( hDC ); <br>    hOldbm = (HBITMAP)SelectObject( hTmpDC, hBtmaps ); <br> <br>    for (i=1; i &lt;= 32; i++) <br>    { <br>        if (rConfig.iBoardFlipped) <br>            iLocation = 33-i; <br>        else <br>            iLocation = i; <br>             <br>    AssertSz(iLocation &gt; 0, "Bee-Gees r a bit"); <br>    AssertSz(iLocation &lt;= SQRS_MAX, "Jello: The environmentally safe defoliant"); <br> <br>    switch(b[iLocation]) <br>    { <br>        case 0: <br>        yBm = 0; <br>        break; <br>        case (RED | KING): <br>        yBm = OFST_COMPUTER_KING; <br>        break; <br>        case RED: <br>        yBm = OFST_COMPUTER; <br>        break; <br>        case (BLACK | KING): <br>        yBm = OFST_HUMAN_KING; <br>        break; <br>        case BLACK: <br>        yBm = OFST_HUMAN; <br>        break; <br>        default: <br>        { <br>        AssertSz(FALSE, "Piece value invalid"); <br>        TraceTag(tagUI, "Invalid piece value of piece %d is: %d", i, b[i]); <br>        } <br>        break; <br>    } <br> <br>        // Calculate location of square on board. (offset?) <br> <br>        iY = (i-1) / 4; <br>        iX = (i-1) % 4; <br>    if ((iY % 2) == 1) <br>            iOffset = 0; <br>        else <br>            iOffset = 1; <br> <br>        // Place the square on the board <br> <br>        BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize*(2*iX+iOffset)), BOARD_TOP + (rConfig.iSquareSize*iY), <br>        rConfig.iSquareSize, rConfig.iSquareSize, hTmpDC, 0, yBm, SRCCOPY ); <br> <br>        // All squares have an accompanying blank square. Depending on the  <br>        // offset, it can be on either side of the filled square. <br> <br>        if (iOffset == 1) <br>            BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize*(2*iX)), BOARD_TOP + (rConfig.iSquareSize*iY), <br>                rConfig.iSquareSize, rConfig.iSquareSize, hTmpDC, 0, OFST_BLANK_RED, SRCCOPY); <br>        else <br>            BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize*(2*iX+1)), BOARD_TOP + (rConfig.iSquareSize*iY), <br>                rConfig.iSquareSize, rConfig.iSquareSize, hTmpDC, 0, OFST_BLANK_RED, SRCCOPY); <br> <br>    } <br> <br>    // Draw setup rack if the user is in setup mode. <br> <br>    if (rGameState.fSetupMode) <br>    { <br> <br>        BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize * RACK_LEFT),  <br>            BOARD_TOP + (rConfig.iSquareSize * (RACK_TOP)),  <br>            rConfig.iSquareSize, rConfig.iSquareSize,  <br>            hTmpDC, 0, OFST_COMPUTER, SRCCOPY); <br> <br>        BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize * RACK_LEFT),  <br>            BOARD_TOP + (rConfig.iSquareSize * (RACK_TOP + 1)),  <br>            rConfig.iSquareSize, rConfig.iSquareSize,  </code></pre>
<p>
</p>
<pre><code>hTmpDC, 0, OFST_HUMAN, SRCCOPY); <br> <br>        BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize * RACK_LEFT),  <br>            BOARD_TOP + (rConfig.iSquareSize * (RACK_TOP + 2)),  <br>            rConfig.iSquareSize, rConfig.iSquareSize,  <br>            hTmpDC, 0, OFST_COMPUTER_KING, SRCCOPY); <br> <br>        BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize * RACK_LEFT),  <br>            BOARD_TOP + (rConfig.iSquareSize * (RACK_TOP + 3)),  <br>            rConfig.iSquareSize, rConfig.iSquareSize,  <br>            hTmpDC, 0, OFST_HUMAN_KING, SRCCOPY); <br> <br>        BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize * RACK_LEFT),  <br>            BOARD_TOP + (rConfig.iSquareSize * (RACK_TOP + 4)),  <br>            rConfig.iSquareSize, rConfig.iSquareSize,  <br>            hTmpDC, 0, OFST_BLANK, SRCCOPY); <br>    } <br> <br>    SelectObject( hTmpDC, hOldbm ); <br>    DeleteDC( hTmpDC ); <br>} <br> <br>// Removes the piece that's moving, and replaces with a blank square. <br> <br>void vClearMovingPiece(HDC hDC, int iX, int iY) <br>{ <br>    HDC   hTmpDC; <br>    HBITMAP hOldbm; <br>    int   yBm; <br> <br>    hTmpDC = CreateCompatibleDC( hDC ); <br>    hOldbm = (HBITMAP)SelectObject( hTmpDC, hBtmaps ); <br> <br>    yBm = 0; <br> <br>    BitBlt( hDC, BOARD_LEFT + (rConfig.iSquareSize*iX), BOARD_TOP + (rConfig.iSquareSize*iY), <br>    rConfig.iSquareSize, rConfig.iSquareSize, hTmpDC, 0, yBm, SRCCOPY ); <br> <br>    SelectObject( hTmpDC, hOldbm ); <br>    DeleteDC( hTmpDC ); <br>} <br> <br>// Reset the board to starting positions. <br>void ClearBoard(BOARD b) <br>{ <br>    Assert(b); <br> <br>    b[0]  = 0;          b[1]  = BLACK;  b[2]  = BLACK;  b[3] = BLACK; <br>    b[4]  = BLACK;  b[5]  = BLACK;  b[6]  = BLACK;      b[7] = BLACK; <br>    b[8]  = BLACK;  b[9]  = BLACK;  b[10] = BLACK;      b[11] = BLACK; <br>    b[12] = BLACK;  b[13] = EMPTY;      b[14] = EMPTY;  b[15] = EMPTY; <br>    b[16] = EMPTY;  b[17] = EMPTY;      b[18] = EMPTY;  b[19] = EMPTY; <br>    b[20] = EMPTY;  b[21] = RED;        b[22] = RED;    b[23] = RED; <br>    b[24] = RED;        b[25] = RED;    b[26] = RED;    b[27] = RED; <br>    b[28] = RED;        b[29] = RED;    b[30] = RED;    b[31] = RED; <br>    b[32] = RED; <br>} <br> <br>void DrawBoard(BOARD b) <br>{ <br>    HDC hDC = GetDC(hMainWnd); <br>     <br>    Assert(b); <br> <br>    FillBoard(b, hDC); <br>    ReleaseDC(hMainWnd, hDC); <br> <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>void DisplayGameOver(HWND hWnd, int iPlayerTurn) <br>{ <br>    int iWinner = BLACK; <br> <br>    AssertSz(hWnd, "hWnd hosed, homey."); <br>    AssertSz((rGameState.iPlayerTurn == BLACK) ||  <br>             (rGameState.iPlayerTurn == RED), "Very low sodium"); <br> <br>    // NOTE: Caller is passing in the losing player. The turn has already <br>    // switched before this gets called. This makes iPlayerTurn  <br>    // equivalent to the winner in a give-away game. If the game type is  <br>    // standard checkers, I want to invert winner. <br> <br>    iWinner = iPlayerTurn; <br>    if (rConfig.iGameType == GAME_CHECKERS) <br>    iWinner = next(iWinner); <br>     <br>    if (RED == iWinner) <br>        MessageBox(hWnd, "Game over. Red wins!", "Checkers", MB_OK ); <br>    else <br>        MessageBox(hWnd, "Game over. Black wins!", "Checkers", MB_OK ); <br> <br>} <br> <br>void DisplayGameDrawn(HWND hWnd, int iPlayerTurn) <br>{ <br>    AssertSz(hWnd, "hWnd hosed (in DisplayGameDrawn), homey."); <br>    AssertSz((rGameState.iPlayerTurn == BLACK) ||  <br>             (rGameState.iPlayerTurn == RED), "Vl bites"); <br> <br>    MessageBox(hWnd, "Game drawn. (Game over)", "Checkers", MB_OK ); <br>} <br> <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>void NEAR PASCAL CheckGenPieces(HDC hDC) <br>{ <br>    HDC     hTmpDC  = NULL; <br>    HBITMAP hOldbm  = NULL; <br>    HBRUSH  hOldbr  = NULL; <br>    int     i               = 0; <br> <br>    AssertSz(hDC, "Null hDC in CheckGenPieces"); <br> <br>    if( hBtmaps != NULL ) <br>        DeleteObject( hBtmaps ); <br> <br>    // We have 6 different pieces (including the blank). So we just fill <br>    // a region big enough for 6 squares. <br>    hBtmaps = CreateCompatibleBitmap( hDC, SQR_XSIZE, 6*SQR_YSIZE ); <br> <br>    /* allocate an off-screen DC, so we can paint the ellipses now */ <br>    hTmpDC = CreateCompatibleDC( hDC ); <br>    hOldbm = (HBITMAP)SelectObject( hTmpDC, hBtmaps ); <br> <br>    /* blank out the off-screen bitmap, ie: paint the background into it */ <br>    hOldbr = (HBRUSH)SelectObject( hTmpDC, GetStockObject( LTGRAY_BRUSH )); <br>    PatBlt( hTmpDC, 0, 0, SQR_XSIZE, SQR_YSIZE, PATCOPY ); <br>    SetBkMode( hTmpDC, TRANSPARENT ); <br> <br>    /* draw the square's "grooved" borders */ <br>    SelectObject( hTmpDC, hpenDkgrey ); <br>    MoveTo( hTmpDC, 2, SQR_YSIZE-2 ); <br>    LineTo( hTmpDC, SQR_XSIZE-2, SQR_YSIZE-2 ); <br>    LineTo( hTmpDC, SQR_XSIZE-2, 1 ); <br>    SelectObject( hTmpDC, GetStockObject( WHITE_PEN ) ); <br>    LineTo( hTmpDC, 1, 1 ); <br>    LineTo( hTmpDC, 1, SQR_YSIZE ); <br>    SelectObject( hTmpDC, GetStockObject( BLACK_PEN ) ); <br>    MoveTo( hTmpDC, 2, SQR_YSIZE-1 ); <br>    LineTo( hTmpDC, SQR_XSIZE-1, SQR_YSIZE-1 ); <br>    LineTo( hTmpDC, SQR_XSIZE-1, 0 ); <br> <br>    /* copy the borders to the other bitmaps */ <br>    for( i=OFST_INCREMENT; i &lt;= OFST_HUMAN; i+=OFST_INCREMENT ) <br>    BitBlt(hTmpDC, 0, i, SQR_XSIZE, SQR_YSIZE, hTmpDC, 0, 0, SRCCOPY); <br> <br>    /* Attempt at RED SQUARE*/ <br>    SelectObject( hTmpDC, hbrDkgrey ); <br>    hOldbr = (HBRUSH)SelectObject( hTmpDC, GetStockObject( LTGRAY_BRUSH )); <br>    SelectObject( hTmpDC, hbrRed); <br>    PatBlt( hTmpDC, 0+2, OFST_BLANK_RED+2, SQR_XSIZE-4, SQR_YSIZE-4, PATCOPY ); <br> <br>    /* first piece: computer */ <br>    SelectObject(hTmpDC, GetStockObject( WHITE_PEN ) ); <br>    SelectObject(hTmpDC, GetStockObject( WHITE_BRUSH ) ); <br>    Ellipse( hTmpDC, 3, OFST_COMPUTER+3, SQR_XSIZE-6, OFST_COMPUTER+SQR_YSIZE-6 ); <br>    SelectObject(hTmpDC, hpenDkgrey ); <br>    SelectObject(hTmpDC, hbrDkgrey ); <br>    Ellipse( hTmpDC, 6, OFST_COMPUTER+6, SQR_XSIZE-3, OFST_COMPUTER+SQR_YSIZE-3 ); <br>    SelectObject(hTmpDC, GetStockObject( BLACK_PEN ) ); <br>    SelectObject(hTmpDC, hbrRed); <br>    Ellipse( hTmpDC, 4, OFST_COMPUTER+4, SQR_XSIZE-5, OFST_COMPUTER+SQR_YSIZE-5 ); <br> <br>    /* computer king */ <br>    BitBlt( hTmpDC, 0, OFST_COMPUTER_KING, SQR_XSIZE, OFST_COMPUTER_KING+SQR_YSIZE, hTmpDC, <br>        0, OFST_COMPUTER, SRCCOPY ); <br>    SelectObject( hTmpDC, GetStockObject( WHITE_PEN ) ); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 4), OFST_COMPUTER_KING + (SQR_YSIZE / 2)); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 4), OFST_COMPUTER_KING + (SQR_YSIZE / 2)); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 4), OFST_COMPUTER_KING + (SQR_YSIZE / 2) + 1); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 4), OFST_COMPUTER_KING + (SQR_YSIZE / 2) + 1); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 2), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 1); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 2), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 1); <br> <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 4), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 1); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 - 6), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 3); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 + 3), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 1); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 5), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 3); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 2), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 2); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 - 3), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 4); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 + 1), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 2); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 3), OFST_COMPUTER_KING + (SQR_YSIZE / 2) - 4); <br> <br>    /* human king */ <br>    BitBlt( hTmpDC, 0, OFST_HUMAN_KING, SQR_XSIZE, OFST_HUMAN_KING+SQR_YSIZE, hTmpDC, <br>    0, OFST_COMPUTER, SRCCOPY ); <br>    SelectObject(hTmpDC, hbrBlack); <br>    SelectObject(hTmpDC, GetStockObject( BLACK_PEN ) ); <br>    Ellipse( hTmpDC, 4, OFST_HUMAN_KING+4, SQR_XSIZE-5, OFST_HUMAN_KING+SQR_YSIZE-5 ); <br>    SelectObject( hTmpDC, GetStockObject( WHITE_PEN ) ); <br>    SelectObject( hTmpDC, GetStockObject( WHITE_PEN ) ); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 4), OFST_HUMAN_KING + (SQR_YSIZE / 2)); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 4), OFST_HUMAN_KING + (SQR_YSIZE / 2)); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 4), OFST_HUMAN_KING + (SQR_YSIZE / 2) + 1); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 4), OFST_HUMAN_KING + (SQR_YSIZE / 2) + 1); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 2), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 1); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 2), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 1); <br> <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 4), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 1); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 - 6), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 3); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 + 3), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 1); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 5), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 3); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 - 2), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 2); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 - 3), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 4); <br>    MoveTo(hTmpDC, (SQR_XSIZE / 2 + 1), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 2); <br>    LineTo(hTmpDC, (SQR_XSIZE / 2 + 3), OFST_HUMAN_KING + (SQR_YSIZE / 2) - 4); <br>     <br>    /* human */ <br>    BitBlt( hTmpDC, 0, OFST_HUMAN, SQR_XSIZE, SQR_YSIZE, hTmpDC, <br>    0, OFST_COMPUTER, SRCCOPY ); <br>    SelectObject(hTmpDC, GetStockObject( BLACK_PEN ) ); <br>    SelectObject(hTmpDC, hbrBlack); <br>    Ellipse( hTmpDC, 4, OFST_HUMAN+4, SQR_XSIZE-5, OFST_HUMAN+SQR_YSIZE-5 ); <br> <br>    SelectObject( hTmpDC, hOldbr ); <br>    SelectObject( hTmpDC, hOldbm ); <br>    DeleteDC( hTmpDC ); <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>void NEAR PASCAL CheckCreate() <br> <br>{ <br>    HDC  hDC; <br>    TEXTMETRIC    charsize;           /* characteristics of the characters */ <br>    int COLOR = 1; <br> <br>    hDC = GetDC(hMainWnd); <br>    GetTextMetrics(hDC, (LPTEXTMETRIC)&amp;charsize); <br> <br>    ReleaseDC(hMainWnd, hDC); <br> <br>    COLOR = GetDeviceCaps(hDC, NUMCOLORS) &gt; 2; <br> <br>    if (COLOR == TRUE) <br>    { <br>    hbrComputer = hbrBlue; <br>    hbrHuman = hbrRed; <br>    } <br>    else <br>    { <br>    hbrComputer = hbrBlack; <br>    hbrHuman = hbrWhite; <br>    } <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>/* Called on WM_PAINT messages. */ <br> <br>void NEAR PASCAL CheckPaint(BOARD b, HDC hDC) <br> <br>{ <br>    CheckGenPieces(hDC); <br>    SetBkMode(hDC, OPAQUE); <br> <br>    DrawBoard(b); <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>void inline vTranslateCurPosToSquare(POINT pntCur, int *pix, int *piy) <br>{ <br>    Assert(pix); <br>    Assert(piy); <br>    Assert(rConfig.iSquareSize != 0); <br> <br>    *pix = (pntCur.x - BOARD_LEFT) / rConfig.iSquareSize; <br>    *piy = (pntCur.y - BOARD_TOP) / rConfig.iSquareSize; <br> <br>    if ((*pix &lt; 0) || (*pix &gt; 7) || (*piy &lt; 0) || (*piy &gt; 7)) <br>    { <br>        if ((!rGameState.fSetupMode) || (*pix != 10) || (*piy &lt; 2) || (*piy &gt; 6)) <br>        { <br>            *pix = -1;              // Return invalid x/y locations <br>            *piy = -1;              // Return invalid x/y locations <br>        } <br>    } <br>} <br> <br>void inline vTranslateUIToEngineSquare(int *piEngine, int iX, int iY) <br>{ <br>    AssertSz(piEngine, "piEngine == NULL"); <br> <br>    if (((iY + iX) % 2 == 0) || <br>    (iY &lt; 0) || (iY &gt; 7) || (iX &lt; 0) || (iX &gt; 7)) <br>    { <br>    *piEngine = -1;         // Return invalid engine ID <br>        return; <br>    } <br>    else <br>    { <br>    *piEngine = iY * 4 + (iX / 2) + 1; <br>    } <br> <br>    if (rConfig.iBoardFlipped) <br>        *piEngine = (33 - *piEngine); <br>} <br> <br>void inline vTranslateEngineToUISquare(int iEngine, int *piX, int *piY) <br>{ <br>    Assert(iEngine &gt; 0); <br>    Assert(piX); <br>    Assert(piY); <br> <br>    if (rConfig.iBoardFlipped) <br>        iEngine = (33 - iEngine); <br>     <br>    *piY = (iEngine - 1) / 4; <br>    *piX = ((iEngine - 1) % 4) * 2 + ((*piY + 1) % 2); <br>}                            <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>BOOL fValidSetupPiece(BOARD b, int ix, int iy) <br>{ <br>    int iEngine = -1; <br>    int iPiece  = -1; <br>    BOOL fRackPiece = FALSE; <br> <br>    AssertSz(b, "Where's the board"); <br> <br>    if ((ix &lt; 0) || (ix &gt; 7) || (iy &lt; 0) || (iy &gt; 7)) <br>    { <br>        // Check for Setup Rack pieces <br> <br>        if ((ix != 10) || (iy &lt; 2) || (iy &gt; 6)) <br>            return FALSE; <br>        else <br>            fRackPiece = TRUE; <br>    } <br>     <br>    vTranslateUIToEngineSquare(&amp;iEngine, ix, iy); <br> <br>    AssertSz((iEngine == -1) ||  <br>         ((iEngine &gt; 0) &amp;&amp; (iEngine &lt;= SQRS_MAX)),  <br>             "iEngine needs counseling"); <br>     <br>    if (iEngine != -1) <br>    { <br>        iPiece = (int) b[iEngine]; <br> <br>        if ((iPiece &amp; RED) || (iPiece &amp; BLACK) || (iPiece == EMPTY)) <br>            return TRUE; <br>        else <br>            return FALSE; <br>    } <br>    else <br>    { <br>        if (!fRackPiece) <br>            return FALSE; <br>        else <br>            return TRUE; <br>    } <br> <br>} <br> <br>BOOL fValidPlayerPiece(BOARD b, int ix, int iy) <br>{ <br>    int iEngine = 0; <br>    int iPiece = 0; <br> <br>    AssertSz(b, "Where's the board?"); <br>    AssertSz(((rGameState.iPlayerTurn == RED) ||  <br>          (rGameState.iPlayerTurn == BLACK)), "Harrison"); <br>     <br>    if ((ix &lt; 0) || (ix &gt; 7) || (iy &lt; 0) || (iy &gt; 7)) <br>    return FALSE; <br> <br>    vTranslateUIToEngineSquare(&amp;iEngine, ix, iy); <br> <br>    // Assert that the engine return is either a "normal" invalid, or <br>    // a normal engine square. Should NOT be 0. <br> <br>    AssertSz((iEngine == -1) ||  <br>         ((iEngine &gt; 0) &amp;&amp; (iEngine &lt;= SQRS_MAX)),  <br>             "Abort, Retry, Fail?"); <br>     <br>    if (iEngine != -1) <br>    iPiece = (int) b[iEngine]; <br>    else <br>        return FALSE; <br> <br>    if (RED == rGameState.iPlayerTurn) <br>    { <br>    if (iPiece &amp; RED) <br>        return TRUE; <br>    else <br>        return FALSE; <br>    } <br>    else  <br>    { <br>        if (BLACK == rGameState.iPlayerTurn) <br>    { <br>        if (iPiece &amp; BLACK) <br>        return TRUE; <br>        else <br>        return FALSE; <br>        } <br>    else <br>        { <br>        AssertSz(FALSE, "rGameState.iPlayerTurn invalid!"); <br>        return FALSE; <br>    } <br>    } <br>} <br> <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>void OnGamePlayableAfterMove(void) <br>{ <br>    if (pfrm) <br>    { <br>    AssertSz(pfrm-&gt;pMessage,"no message to send"); <br> <br>    // ----- Update our forms information based on user interaction <br>    pfrm-&gt;SetCheckersData(b,rGameState.iPlayerTurn,0,QualityOfBoard(b,rGameState.iPlayerTurn)); <br> <br>    // ----- Send this baby, and shut her down <br>    SetWindowText(hMainWnd,"Sending ..."); <br>    pfrm-&gt;SendForm(); <br>    pfrm-&gt;ShutdownForm(OLECLOSE_NOSAVE); <br>    } <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br>// Handle WM_INITMENU message. <br> <br>VOID vHandle_WM_INITMENU(HWND hWnd, HMENU hMenu) <br>{ <br>    hMenu = GetMenu(hWnd); <br>    if (rGameState.fThinking) <br>    { <br>    EnableMenuItem(hMenu, 0, MF_DISABLED | MF_BYPOSITION); <br>    EnableMenuItem(hMenu, 1, MF_DISABLED | MF_BYPOSITION); <br>    } <br>    else <br>    { <br>    EnableMenuItem(hMenu, 0, MF_ENABLED | MF_BYPOSITION); <br>    EnableMenuItem(hMenu, 1, MF_ENABLED | MF_BYPOSITION); <br>    } <br>} <br> <br>BOOL fHandle_WM_CREATE(HWND hWnd, CREATESTRUCT FAR* lpCreateStruct) <br>{ <br>    HDC         hDC     = NULL; <br>    HMENU       hm              = NULL; <br> <br>    hMainWnd = hWnd; <br>    ReadINI(); <br> <br>    // Set game state variables. <br> <br>    rGameState.fSetupMode = FALSE;          // Game in setup mode? Need for button processing <br>    rGameState.fThinking = FALSE;           // Is the computer thinking? <br>    rGameState.fPaused = FALSE;             // Is the game paused? <br>    rGameState.fGameInProgress = FALSE;     // Did the game start? How to react to "File:New" <br>    rGameState.fLMouseButtonDown = FALSE;   // Is the left mouse-button currently down? <br>    rGameState.fRMouseButtonDown = FALSE;   // Is the left mouse-button currently down? <br>    rGameState.fMoveInProgress = FALSE;     // Is the user in the middle of a move? <br>    rGameState.fComputerBusy = FALSE;               // Is the computer thinking? <br>    rGameState.fGameOver = FALSE;                   // Is the game over? <br>    rGameState.fInitDone = FALSE;                   // Is initialization done? <br>    rGameState.iPlayerTurn = BLACK; <br>    rGameState.iCursorState = NORMAL_CURSOR;        // What state is the cursor in? <br>    rGameState.fMouseResizeInProgress = FALSE;      // Is the user resizing right now? <br>    rConfig.iSetupPurgeBoards = TRUE;               // Purge boards when exit setup? <br>     <br>    CMoves.Init(); <br>    CheckCreate(); <br>    hDC = GetDC(hWnd); <br>    ClearBoard(b); <br>    CMoves.NewMove(b, rGameState.iPlayerTurn); <br>    FillBoard(b, hDC); <br> <br>    hm = GetMenu(hWnd); <br>    if (!rConfig.iBoardFlipped) <br>    { <br>        CheckMenuItem(hm, IDM_FLIP, MF_CHECKED); <br>    } <br> <br>    CheckMenuItem(hm, IDM_BASE_LEVEL + rConfig.rPlayer[RED].iMaxRecursionDepth, MF_CHECKED); <br> <br>    switch(rConfig.iGameType) <br>    { <br>    case GAME_CHECKERS: <br>        CheckMenuItem(hm, IDM_GAME_CHECKERS, MF_CHECKED); <br>        CheckMenuItem(hm, IDM_GAME_GIVEAWAY, MF_UNCHECKED); <br>        break; <br>    case GAME_GIVEAWAY: <br>        CheckMenuItem(hm, IDM_GAME_GIVEAWAY, MF_CHECKED); <br>        CheckMenuItem(hm, IDM_GAME_CHECKERS, MF_UNCHECKED); <br>        break; <br>    default: <br>        // Set to checkers, assert if debug <br>        CheckMenuItem(hm, IDM_GAME_CHECKERS, MF_CHECKED); <br>        CheckMenuItem(hm, IDM_GAME_GIVEAWAY, MF_UNCHECKED); <br>        MessageBox(hWnd, "Game type invalid. Setting to checkers", "Checkers", MB_OK); <br>        rConfig.iGameType = GAME_CHECKERS; <br>        break; <br>    } <br> <br>    // Load "Piece" cursor. <br> <br>    curPiece   = LoadCursor(hInst, "PieceCur"); <br>    if (curPiece) <br>    TraceTag(tagUI, "Cur Piece is valid"); <br>    else <br>    TraceTag(tagUI, "Cur Piece is invalid"); <br> <br>    return TRUE; <br> <br>} <br> <br>VOID vHandle_WM_DESTROY(HWND hWnd) <br>{ <br>    WriteINI(); <br> <br>    if (pfrm) <br>    { <br>        FRM *pfrml; //$FORM <br>        pfrml = pfrm; <br>        pfrm = NULL; <br>        pfrml-&gt;ShutdownForm(OLECLOSE_NOSAVE); <br>        pfrml-&gt;Release(); <br>    } <br> <br>    DeleteObject(hbrBckgrnd); <br>    DeleteObject(hbrRed); <br>    DeleteObject(hbrBlue); <br>    DeleteObject(hbrDkgrey); <br>    DeleteObject(hpenDkgrey); <br>    DeleteObject(hBtmaps); <br> <br>    // WinHelp(hWnd, (LPSTR)szHelpFile, HELP_QUIT, 0L); <br> <br>    PostQuitMessage(0); <br>} <br> <br>VOID vHandle_WM_TIMER(HWND hWnd, UINT id) <br>{ <br>    #ifdef DEBUG <br>    static int x=0; <br>    if (0==x) <br>    { <br>    if (!((BLACK == rGameState.iPlayerTurn) || <br>      (RED == rGameState.iPlayerTurn))) x++; <br>    AssertSz(((BLACK == rGameState.iPlayerTurn) ||  <br>          (RED == rGameState.iPlayerTurn)),  <br>          "Caffeine-Free? What's the point?"); <br>    } <br>    #endif <br>     <br>    if ((rConfig.rPlayer[rGameState.iPlayerTurn].iPlayerType == COMPUTER_PLAYER) &amp;&amp; <br>        (rGameState.fInitDone) &amp;&amp;  <br>        (!rGameState.fPaused) &amp;&amp;  <br>        (!rGameState.fComputerBusy) &amp;&amp; <br>        (!rGameState.fGameOver)) <br>    { <br>    ComputerMove(); <br>    } <br>} <br> <br>VOID vHandle_WM_RBUTTONDOWN(HWND hWnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) <br>{ <br>    AssertSz(!rGameState.fRMouseButtonDown, "David Copperfield with a mouse"); <br>    TraceTag(tagMouse, "in vHandle_WM_RBUTTONDOWN"); <br>    TraceTag(tagMouse, "rGameState.fRMouseButtonDown: %d", rGameState.fRMouseButtonDown); <br> <br>    if (!rGameState.fLMouseButtonDown) <br>    { <br>        SetCapture(hWnd); <br> <br>        if (rGameState.fSetupMode) <br>            SetupRButtonDown(hWnd, keyFlags, x, y); <br>        else <br>        { <br>        // No-op. <br>        }     <br>    } <br>    else <br>    { <br>    // No-op. <br>    } <br>     <br> <br>} <br> <br>VOID vHandle_WM_LBUTTONDOWN(HWND hWnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) <br>{ <br>    AssertSz(!rGameState.fLMouseButtonDown, "How'd you do that?"); <br> <br>    TraceTag(tagMouse, "in vHandle_WM_LBUTTONDOWN"); <br>    TraceTag(tagMouse, "rGameState.fLMouseButtonDown: %d", rGameState.fLMouseButtonDown); <br>    TraceTag(tagMouse, "rGameState.fRMouseButtonDown: %d", rGameState.fRMouseButtonDown); <br> <br>    SetCapture(hWnd); <br> <br>    switch (rGameState.iCursorState) <br>    { <br>        case NORMAL_CURSOR: <br>            TraceTag(tagMouse, "Move LButtonDown"); <br>            if (!rGameState.fRMouseButtonDown) <br>            { <br>                SetCapture(hWnd); <br> <br>                if (rGameState.fSetupMode) <br>                SetupLButtonDown(hWnd, keyFlags, x, y); <br>                else <br>                { <br>                    AssertSz(((BLACK == rGameState.iPlayerTurn) ||  <br>                        (RED == rGameState.iPlayerTurn)),  <br>                        "Just how often am I going to check this?"); <br> <br>                    if ((!rGameState.fGameOver) &amp;&amp; <br>                    (HUMAN_PLAYER == rConfig.rPlayer[rGameState.iPlayerTurn].iPlayerType)) <br>                    NormalLButtonDown(hWnd, keyFlags, x, y); <br>                }     <br>            } <br>            else <br>            { <br>                // NO-OP if other button already down <br>            } <br>            break; <br> <br>        case RESIZE_CURSOR: <br>        { <br>            TraceTag(tagMouse, "Resize LButtonDown"); <br>            rGameState.fMouseResizeInProgress = TRUE; <br>        } <br>    }               // end switch <br>         <br>} <br> <br> <br>VOID vHandle_WM_LBUTTONUP(HWND hWnd, int x, int y, UINT keyFlags) <br>{ <br>    TraceTag(tagMouse, "in vHandle_WM_LBUTTONUP"); <br> <br>    TraceTag(tagMouse, "rGameState.fLMouseButtonDown: %d", rGameState.fLMouseButtonDown); <br>    TraceTag(tagMouse, "rGameState.fRMouseButtonDown: %d", rGameState.fRMouseButtonDown); <br> <br>    ReleaseCapture(); <br>     <br>    if (rGameState.fMouseResizeInProgress) <br>    { <br>        rGameState.fMouseResizeInProgress = FALSE; <br>    } <br>    else <br>    { <br>        if (rGameState.fSetupMode) <br>            SetupLButtonUp(hWnd, keyFlags, x, y); <br>        else <br>            if (!rGameState.fGameOver) <br>            NormalLButtonUp(hWnd, keyFlags, x, y); <br>    } <br>} <br> <br>VOID vHandle_WM_RBUTTONUP(HWND hWnd, int x, int y, UINT keyFlags) <br>{ <br> <br>    TraceTag(tagMouse, "in vHandle_WM_RBUTTONUP"); <br> <br>    TraceTag(tagMouse, "rGameState.fLMouseButtonDown: %d", rGameState.fLMouseButtonDown); <br>    TraceTag(tagMouse, "rGameState.fRMouseButtonDown: %d", rGameState.fRMouseButtonDown); <br> <br>    ReleaseCapture(); <br>    if (rGameState.fSetupMode) <br>    SetupRButtonUp(hWnd, keyFlags, x, y); <br>    else <br>    { <br>    // NO-OP <br>    } <br>} <br> <br>VOID vHandle_WM_MOUSEMOVE(HWND hWnd, int x, int y, UINT keyFlags) <br>{ <br> <br>    TraceTag(tagMouse, "in vHandle_WM_MOUSEMOVE. Mouse position: x:%d  y:%d", x, y); <br> <br>    if (rGameState.fRMouseButtonDown) <br>    { <br>        // NO-OP <br>    } <br>    else <br>    { <br>        if (rGameState.fLMouseButtonDown) <br>        { <br>            // NO-OP: Should be the actual mouse resize code. <br>        } <br>        else <br>        { <br>            if (rGameState.fMouseResizeInProgress) <br>            { <br>                int iNewBoardSize = 0; <br>                int iNewSquareSize = 0; <br>                HDC hDC = 0; <br>                RECT rectInvalidate; <br> <br>                TraceTag(tagMouse, "End of mouse resize"); <br>         <br>                iNewBoardSize = ((x - BOARD_LEFT) + (y - BOARD_TOP)) / 2; <br>                TraceTag(tagMouse, "iNewBoardSize: %d", iNewBoardSize); <br> <br>                iNewSquareSize = iNewBoardSize / 8; <br> <br>                AssertSz(MAX_SQUARE_SIZE &gt;= MIN_SQUARE_SIZE, "Max &lt; Min. Duh."); <br>         <br>                if (iNewSquareSize &lt; MIN_SQUARE_SIZE) <br>                    iNewSquareSize = MIN_SQUARE_SIZE; <br> <br>                if (iNewSquareSize &gt; MAX_SQUARE_SIZE) <br>                    iNewSquareSize = MAX_SQUARE_SIZE; <br> <br>                if (iNewSquareSize != rConfig.iSquareSize) <br>                { <br>                    rectInvalidate.left             = BOARD_LEFT; <br>                    rectInvalidate.right    = BOARD_LEFT + rConfig.iSquareSize*13; <br>                    rectInvalidate.top              = BOARD_TOP; <br>                    rectInvalidate.bottom   = BOARD_TOP + rConfig.iSquareSize*8; <br> <br>                    InvalidateRect(hWnd, &amp;rectInvalidate, TRUE); <br>                    hDC = GetDC(hWnd); <br>                    rConfig.iSquareSize = iNewSquareSize; <br>                CheckGenPieces(hDC); <br>                    UpdateWindow(hWnd); <br>                DrawBoard(b);     <br>                } <br>                 <br>                SetCursor(curResize); <br>                TraceTag(tagMouse, "Resize now: x: %d, y: %d", x, y); <br>            } <br>            else <br>            { <br>                // User is in normal play/setup mode. No mouse down. We want to  <br>                // change the cursor based on whether we're scanning over pieces <br>                // or over the "resize" area. <br> <br>                switch(rGameState.iCursorState) <br>                { <br>                    case NORMAL_CURSOR: <br>                        if ((x &gt; BOARD_LEFT + rConfig.iSquareSize*8 - RESIZE_RANGE) &amp;&amp;  <br>                        (x &lt; BOARD_LEFT + rConfig.iSquareSize*8 + RESIZE_RANGE) &amp;&amp; <br>                            (y &gt; BOARD_TOP + rConfig.iSquareSize*8 - RESIZE_RANGE) &amp;&amp; <br>                            (y &lt; BOARD_TOP + rConfig.iSquareSize*8 + RESIZE_RANGE)) <br>                        { <br>                            TraceTag(tagMouse, "Setting RESIZE_CURSOR"); <br>                            SetCursor(curResize); <br>                            rGameState.iCursorState = RESIZE_CURSOR; <br>                        } <br>                        else <br>                        { <br>                            SetCursor(curNormal); <br>                        } <br>                        break; <br>     <br>                    case RESIZE_CURSOR: <br>                        if ((x &lt; BOARD_LEFT + rConfig.iSquareSize*8 - RESIZE_RANGE) || <br>                        (x &gt; BOARD_LEFT + rConfig.iSquareSize*8 + RESIZE_RANGE) || <br>                            (y &lt; BOARD_TOP + rConfig.iSquareSize*8 - RESIZE_RANGE) || <br>                            (y &gt; BOARD_TOP + rConfig.iSquareSize*8 + RESIZE_RANGE)) <br>                        { <br>                            TraceTag(tagMouse, "Setting NORMAL_CURSOR"); <br>                            SetCursor(curNormal); <br>                            rGameState.iCursorState = NORMAL_CURSOR; <br>                        } <br>                        else <br>                        { <br>                            SetCursor(curResize); <br>                        } <br>                        break; <br>                    default: <br>                        AssertSz(FALSE, "Forest AND the trees"); <br>                        break; <br>                }                                                       // end switch <br>            }                                                               // end else fMouseResizeInProgress <br>        }                                                                       // end else fLMouseButtonDown <br>    }                                                                               // end else fRMouseButtonDown <br>} <br> <br>VOID vHandle_WM_PAINT(HWND hWnd) <br>{ <br>    PAINTSTRUCT ps; <br> <br>    BeginPaint(hWnd, (LPPAINTSTRUCT)&amp;ps); <br>    CheckPaint(b, ps.hdc); <br>    EndPaint(hWnd, (LPPAINTSTRUCT)&amp;ps); <br>} <br> <br>VOID vHandle_WM_VSCROLL(HWND hWnd, HWND hWndCtl, UINT code, int pos) <br>{ <br>    AssertSz(FALSE, "When did I start getting VSCROLL messages?"); <br>} <br> <br>VOID vHandle_WM_HSCROLL(HWND hWnd, HWND hWndCtl, UINT code, int pos) <br>{ <br>    AssertSz(FALSE, "When did I start getting HSCROLL messages?"); <br>} <br> <br>VOID vHandle_WM_GETMINMAXINFO(HWND hWnd, MINMAXINFO FAR * lpMinMaxInfo) <br>{ <br>    // NO-OP <br>} <br> <br>VOID vHandle_WM_COMMAND(HWND hWnd, int wmId, HWND hwndCtl, UINT wmEvent) <br>{ <br>    // Used by various commands <br> <br>    FARPROC lpProcDialog = NULL; <br>    int iDialogBoxResult = -1; <br>    RECT rectInvalidate; <br>    HDC hDC = NULL; <br>    HMENU hm = NULL; <br> <br>    switch (wmId) <br>    { <br>    #ifdef NEVER <br>    case IDM_FILENEW: <br>    { <br>        int iResponse; <br> <br>        iResponse = MessageBox(hWnd, "You have asked to start " \ <br>        "a new game. Note, this will end your current game. " \ </code></pre>
<p>
</p>
<pre><code>"Would you like to save your game first?", "New Game?", <br>        MB_YESNOCANCEL | MB_DEFBUTTON2 | MB_ICONQUESTION); <br> <br>        switch (iResponse) <br>        { <br>        case IDYES: <br>            SaveAsBoard(b); <br>            // We mean to fall through to the IDNO case below <br> <br>        case IDNO: <br>            ClearBoard(b); <br>            CMoves.ClearBoards(); <br>                    rGameState.fGameOver = FALSE; <br>                    rGameState.iPlayerTurn = BLACK; <br>                    CMoves.NewMove(b, rGameState.iPlayerTurn); <br>            DrawBoard(b); <br>            break; <br> <br>        case IDCANCEL: <br>                    DrawBoard(b); <br>            break; <br>        } <br>        break; <br>    } <br>    #endif //never <br> <br>    case IDM_SAVE: <br>        NYI("IDM_SAVE"); <br>        break; <br> <br>    case IDM_GAME_CHECKERS: <br>        if (rConfig.iGameType != GAME_CHECKERS) <br>        { <br>        hm = GetMenu(hWnd); <br>        CheckMenuItem(hm, IDM_GAME_CHECKERS, MF_CHECKED); <br>        CheckMenuItem(hm, IDM_GAME_GIVEAWAY, MF_UNCHECKED); <br>        rConfig.iGameType = GAME_CHECKERS; <br>        } <br>        break; <br> <br>    case IDM_GAME_GIVEAWAY: <br>        if (rConfig.iGameType != GAME_GIVEAWAY) <br>        { <br>        hm = GetMenu(hWnd); <br>        CheckMenuItem(hm,IDM_GAME_CHECKERS,MF_UNCHECKED); <br>        CheckMenuItem(hm,IDM_GAME_GIVEAWAY,MF_CHECKED); <br>        rConfig.iGameType = GAME_GIVEAWAY; <br>        } <br>        break; <br> <br>    case IDM_SETUP_BOARD: <br> <br>        SetMenu(hWnd, LoadMenu(hInst, "WCheck_SETUP")); <br>        rGameState.fSetupMode = TRUE; <br> <br>            rectInvalidate.left= BOARD_LEFT + rConfig.iSquareSize*10; <br>            rectInvalidate.right = rectInvalidate.left + rConfig.iSquareSize; <br>            rectInvalidate.top = BOARD_TOP + rConfig.iSquareSize*2; <br>            rectInvalidate.bottom = BOARD_TOP + rConfig.iSquareSize*7; <br>            InvalidateRect(hMainWnd, &amp;rectInvalidate, TRUE); <br>         <br>            //$$ () game over state <br>            break; <br> <br>    case IDM_SETUP_EXIT: <br> <br>        lpProcDialog = MakeProcInstance ((FARPROC) PlayerTurnDialogProc, hInst); <br>        iDialogBoxResult = DialogBox(hInst, "PLAYER_TURN",  <br>        hWnd, (DLGPROC) lpProcDialog); <br>        if (iDialogBoxResult != -1)         <br>            { <br> <br>            AssertSz((BLACK == iDialogBoxResult) || <br>                     (RED == iDialogBoxResult),  <br>                     "Darn tootin!"); <br>         <br>        SetMenu(hWnd, LoadMenu(hInst, "WCheck_NORMAL")); <br>                rGameState.iPlayerTurn = iDialogBoxResult; <br>        rGameState.fSetupMode = FALSE; <br>                rectInvalidate.left= BOARD_LEFT + rConfig.iSquareSize*10; <br>                rectInvalidate.right = rectInvalidate.left + rConfig.iSquareSize; <br>                rectInvalidate.top = BOARD_TOP + rConfig.iSquareSize*2; <br>                rectInvalidate.bottom = BOARD_TOP + rConfig.iSquareSize*7; <br>                InvalidateRect(hMainWnd, &amp;rectInvalidate, TRUE); <br>                if (rConfig.iSetupPurgeBoards) <br>                    CMoves.ClearBoards(); <br>                else <br>                    CMoves.PurgeBoards(); <br>                CMoves.NewMove(b, rGameState.iPlayerTurn); <br>        } <br>        break; <br> <br>    case IDM_PLAYERS: <br>        lpProcDialog = MakeProcInstance ((FARPROC) PlayersDialogProc, hInst); <br>        DialogBox (hInst, "PLAYERS", hWnd, (DLGPROC) lpProcDialog); <br>        FreeProcInstance (lpProcDialog); <br>        break; <br> <br>    case IDM_BACK: <br>        { <br>        // Change menu to say "Continue" <br>        rGameState.fPaused = TRUE; <br>                rGameState.fGameOver = FALSE; <br> <br>                // $$ () game over state <br> <br>        TraceTag(tagUI, "Calling CMoves.BackMove(b)"); <br>        if (FALSE == CMoves.BackMove(b, &amp;rGameState.iPlayerTurn)) <br>                { <br>                    TraceTag(tagUI, "BEEP: Can't back up."); <br>            MessageBeep(MB_OK); <br>                } <br>        else <br>            DrawBoard(b); <br>        } <br>        break; <br> <br>    case IDM_FORWARD: <br>    { <br>        // Change menu to say "Continue" <br>        rGameState.fPaused = TRUE; <br> <br>            // $$ () game over state <br>        TraceTag(tagUI, "Calling CMoves.ForwardMove(b)"); <br>        if (FALSE == CMoves.ForwardMove(b, &amp;rGameState.iPlayerTurn)) <br>            { <br>                TraceTag(tagUI, "BEEP: Can't go forward."); <br>                MessageBeep(MB_OK); <br>            } <br>        else <br>        DrawBoard(b); <br>    } <br>    break; <br> <br>        case IDM_FLIP: <br>            hm = GetMenu(hWnd); <br>            if (FALSE == rConfig.iBoardFlipped) <br>            { <br>                rConfig.iBoardFlipped = TRUE; <br>                CheckMenuItem(hm, IDM_FLIP, MF_UNCHECKED); <br>            } <br>            else <br>            { <br>                rConfig.iBoardFlipped = FALSE; <br>                CheckMenuItem(hm, IDM_FLIP, MF_CHECKED); <br>            } <br> <br>            DrawBoard(b); <br>            break; <br> <br>        case IDM_CONTINUE: <br> <br>        rGameState.fPaused = FALSE; <br>        CMoves.PurgeBoards(); <br> <br>            // $$ () game over state <br> <br>        AssertSz(((BLACK == rGameState.iPlayerTurn) ||  <br>                (RED == rGameState.iPlayerTurn)),  <br>                "Who flicked that?"); <br> <br>        if (COMPUTER_PLAYER == rConfig.rPlayer[rGameState.iPlayerTurn].iPlayerType) <br>        { <br>        ComputerMove(); <br>        } <br>        break; <br> <br>        case IDM_SETDRAWMOVES: <br>        lpProcDialog = MakeProcInstance ((FARPROC) DebugConfigDialogProc, hInst); <br>        DialogBox (hInst, "DEBUG_CONFIG", hWnd, (DLGPROC) lpProcDialog); <br>        FreeProcInstance (lpProcDialog); <br>            break; <br> <br> <br>    case IDM_BASE_LEVEL: <br>    case IDM_BASE_LEVEL + 1: <br>    case IDM_BASE_LEVEL + 2: <br>    case IDM_BASE_LEVEL + 3: <br>    case IDM_BASE_LEVEL + 4: <br>    case IDM_BASE_LEVEL + 5: <br>    case IDM_BASE_LEVEL + 6: <br>    case IDM_BASE_LEVEL + 7: <br>    case IDM_BASE_LEVEL + 8: <br>    case IDM_BASE_LEVEL + 9: <br>    case IDM_BASE_LEVEL + 10: <br>    case IDM_BASE_LEVEL + 11: <br>    case IDM_BASE_LEVEL + 12: <br>    case IDM_BASE_LEVEL + 13: <br>    case IDM_BASE_LEVEL + 14: <br>    case IDM_BASE_LEVEL + 15: <br>    case IDM_BASE_LEVEL + 16: <br>    case IDM_BASE_LEVEL + 17: <br>    case IDM_BASE_LEVEL + 18: <br>    case IDM_BASE_LEVEL + 19: <br>    case IDM_BASE_LEVEL + 20: <br>        HMENU hm; <br>        int i; <br> <br>        hm = GetMenu(hWnd); <br>        i=20; <br>        for (;i;i--) <br>            CheckMenuItem(hm, IDM_BASE_LEVEL + i, MF_UNCHECKED); <br>        CheckMenuItem(hm, wmId, MF_CHECKED); <br>        rConfig.rPlayer[BLACK].iMaxRecursionDepth = <br>            rConfig.rPlayer[RED].iMaxRecursionDepth = wmId - IDM_BASE_LEVEL; <br>        break; <br> <br>    case IDM_HINT: <br>        { <br>        SQUARE      db[SQRS_MAX]; <br>        int i; <br> <br>        SetCursor(curThink); <br>        CopyBoard(b,db); <br>        PlayBestMove(db, rGameState.iPlayerTurn, 0, 0, <br>            (int)rConfig.rPlayer[rGameState.iPlayerTurn].lAlphaPruningOriginalDepth,    /* prune depth */ <br>            (int)rConfig.rPlayer[rGameState.iPlayerTurn].lAlphaPruningWidth,    /* prune size */ <br>            (int)rConfig.rPlayer[rGameState.iPlayerTurn].iMaxRecursionDepth   /* max depth */ <br>            ); <br>        SetCursor(curNormal); <br>        for (i=0; i&lt;3; ++i) <br>        { <br>        #define WAIT_TICKS 250 <br>        #ifndef _WIN32 <br>        DWORD startTick; <br>        #endif <br>        DrawBoard(db); <br>        #ifdef _WIN32 <br>        Sleep(WAIT_TICKS); <br>        #else <br>        startTick = GetTickCount() + WAIT_TICKS; <br>        while (GetTickCount() &lt; startTick) /* do nothing */; <br>        #endif <br>        DrawBoard(b); <br>        #ifdef _WIN32 <br>        Sleep(WAIT_TICKS); <br>        #else <br>        startTick = GetTickCount() + WAIT_TICKS; <br>        while (GetTickCount() &lt; startTick) /* do nothing */; <br>        #endif <br>        } <br> <br>         <br>        } <br>        break; <br> <br>    case IDM_ADDRESS: <br>        if (pfrm) // $ FORM <br>        pfrm-&gt;AddressForm(hWnd,(BOOL) wmEvent); <br>        else <br>        MessageBeep(MB_OK); <br>        break; <br> <br>        case IDM_ABOUT: <br>             <br>            lpProcDialog = MakeProcInstance((FARPROC)About, hInst); <br> <br>            DialogBox(hInst,           // current instance <br>                "AboutBox",            // dlg resource to use <br>                hWnd,                  // parent handle <br>                (DLGPROC)lpProcDialog); // About() instance address <br> <br>            FreeProcInstance(lpProcDialog); <br>            break; <br> <br>        case IDM_EXIT: <br>            DestroyWindow (hWnd); <br>            break; <br>    } <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>LRESULT CALLBACK CheckersWndProc( <br>        HWND hWnd,         // window handle <br>        UINT message,      // type of message <br>        WPARAM wParam,     // additional information <br>        LPARAM lParam)     // additional information <br> <br>{ <br>    switch (message) <br>    { <br>    HANDLE_MSG(hWnd, WM_CREATE, fHandle_WM_CREATE); <br>        HANDLE_MSG(hWnd, WM_INITMENU, vHandle_WM_INITMENU); <br>        HANDLE_MSG(hWnd, WM_DESTROY, vHandle_WM_DESTROY); <br>        HANDLE_MSG(hWnd, WM_TIMER, vHandle_WM_TIMER); <br>        HANDLE_MSG(hWnd, WM_LBUTTONDOWN, vHandle_WM_LBUTTONDOWN); <br>        HANDLE_MSG(hWnd, WM_LBUTTONUP, vHandle_WM_LBUTTONUP); <br>        HANDLE_MSG(hWnd, WM_RBUTTONDOWN, vHandle_WM_RBUTTONDOWN); <br>        HANDLE_MSG(hWnd, WM_RBUTTONUP, vHandle_WM_RBUTTONUP); <br>        HANDLE_MSG(hWnd, WM_MOUSEMOVE, vHandle_WM_MOUSEMOVE); <br>        HANDLE_MSG(hWnd, WM_PAINT, vHandle_WM_PAINT); <br>        HANDLE_MSG(hWnd, WM_VSCROLL, vHandle_WM_VSCROLL); <br>        HANDLE_MSG(hWnd, WM_HSCROLL, vHandle_WM_HSCROLL); <br>        HANDLE_MSG(hWnd, WM_GETMINMAXINFO, vHandle_WM_GETMINMAXINFO); <br>        HANDLE_MSG(hWnd, WM_COMMAND, vHandle_WM_COMMAND); <br> <br>        case EM_GIVEFORMTOHWND: <br> <br>        ShowWindow(hWnd, SW_SHOWNORMAL); <br> <br>        // ----- params valid <br>        AssertSz(NULL == pfrm,"two forms?"); <br>        AssertSz(lParam,"no forms?"); <br>        pfrm = (FRM*) lParam; <br>        TraceTag(tagForm,"wcheck pfrm-&gt;AddRef"); <br>        pfrm-&gt;AddRef(); <br>        Assert(pfrm-&gt;pMessage); <br> <br>        pfrm-&gt;GetCheckersData(b,&amp;rGameState.iPlayerTurn,NULL,NULL); <br>        AssertSz(rGameState.iPlayerTurn == RED || rGameState.iPlayerTurn == BLACK,"cool: neither red or blacks turn according to mapi"); <br>        rConfig.iBoardFlipped = 1; <br>        if (RED == rGameState.iPlayerTurn) <br>        rConfig.iBoardFlipped = 0; <br>        rGameState.fPaused = FALSE; <br> <br> <br>        DrawBoard(b); <br> <br>        break; <br> <br>        case WM_OTHERINIT: <br> <br>        if (!rGameState.fPlayAsForm) <br>        { <br>        if (COMPUTER_PLAYER == rConfig.rPlayer[PLAYER1].iPlayerType) <br>            { <br>            MessageBox(hWnd, "Computer is configured to move first. The " \ <br>            "game will start out paused. Select 'Continue' from the " \ <br>            "main menu to start.", "Checkers", MB_OK); <br>            rGameState.fPaused = TRUE; <br>            } <br>        } <br>        else <br>        { <br>        rGameState.fPaused = TRUE; <br>        } <br>            rGameState.fInitDone = TRUE; <br>        break; <br> <br>    case WM_CLOSE: <br>        if (pfrm) <br>        { <br>        FRM *pfrml; //$FORM <br>        pfrml = pfrm; <br>        pfrm = NULL; <br>        pfrml-&gt;ShutdownForm(OLECLOSE_NOSAVE); <br>        pfrml-&gt;Release(); <br>        } <br>        return(DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>        default:          // Passes it on if unproccessed <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return (0); <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>long WINAPI ComputerMove() <br>{ <br>    int iGameState = GAME_PLAYABLE; <br>     <br>    rGameState.fComputerBusy = TRUE; <br>    rGameState.fGameInProgress = TRUE; <br> <br>    TraceTag(tagUI, "Calling PlayBestMove()"); <br>    SetCursor(curThink); <br> <br>    AssertSz(((BLACK == rGameState.iPlayerTurn) ||  <br>              (RED == rGameState.iPlayerTurn)),  <br>              "This one says x!"); <br> <br>        PlayBestMove(b, rGameState.iPlayerTurn, 0, 0, <br>        (int)rConfig.rPlayer[rGameState.iPlayerTurn].lAlphaPruningOriginalDepth,    /* prune depth */ <br>        (int)rConfig.rPlayer[rGameState.iPlayerTurn].lAlphaPruningWidth,    /* prune size */ <br>        (int)rConfig.rPlayer[rGameState.iPlayerTurn].iMaxRecursionDepth   /* max depth */ <br>        ); <br>         <br>    SetCursor(curNormal); <br>    TraceTag(tagUI, "Done with PlayBestMove()"); <br>    DrawBoard(b); <br> <br>    if (rGameState.iPlayerTurn == BLACK) <br>    rGameState.iPlayerTurn = RED; <br>    else <br>    rGameState.iPlayerTurn = BLACK; <br> <br>    CMoves.NewMove(b, rGameState.iPlayerTurn); <br> <br>    iGameState = GameOver(b, rGameState.iPlayerTurn); <br>    switch (iGameState) <br>    { <br>    case GAME_WON: <br>            rGameState.fGameOver = TRUE; <br>            DisplayGameOver(hMainWnd, rGameState.iPlayerTurn); <br>        break; <br>        case GAME_DRAWN: <br>        rGameState.fGameOver = TRUE; <br>        DisplayGameDrawn(hMainWnd, rGameState.iPlayerTurn); <br>            break;             <br>        case GAME_PLAYABLE: <br>        OnGamePlayableAfterMove(); <br>            break;          <br>        default: <br>            AssertSz(FALSE, "STILL dead");                      <br>    } <br> <br>    rGameState.fComputerBusy = FALSE; <br>     <br>    return(0); <br>     <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>void inline SetupLButtonDown(HWND hWnd, UINT keyFlags, int x, int y) <br>{ <br>    int iSX = 0; <br>    int iSY = 0; <br> <br>    (pntStart).x = x; <br>    (pntStart).y = y; <br> <br>    vTranslateCurPosToSquare(pntStart, &amp;iSX, &amp;iSY); <br> <br>    if (fValidSetupPiece(b, iSX, iSY)) <br>    { <br>    HDC hDC; <br> <br>    SetCursor(curPiece); <br>    hDC = GetDC(hWnd); <br>    AssertSz((iSX &gt;= 0) &amp;&amp; ((iSX &lt;= 7) || (iSX == 10)), "iSX out of range on ButtonDown"); <br>    AssertSz((iSY &gt;= 0) &amp;&amp; (iSY &lt;= 7), "iSY out of range on ButtonDown"); <br>        if ((iSX != 10) &amp;&amp; (!(GetKeyState(VK_CONTROL) &amp; 0x8000))) <br>            vClearMovingPiece(hDC, iSX, iSY); <br>    rGameState.fMoveInProgress = TRUE; <br>    } <br>    else <br>    { <br>        TraceTag(tagUI, "BEEP: Not a valid setup piece"); <br>    MessageBeep(MB_OK); <br>    rGameState.fMoveInProgress = FALSE; <br>    } <br>    rGameState.fLMouseButtonDown = TRUE; <br>    TraceTag(tagMouse, "rGameState.fLMouseButtonDown: %d", rGameState.fLMouseButtonDown); <br>     <br>} <br> <br>void inline SetupRButtonDown(HWND hWnd, UINT keyFlags, int x, int y) <br>{ <br>    int iSX = 0; <br>    int iSY = 0; <br> <br>    TraceTag(tagMouse, "in SetupRButtonDown()"); <br> <br>    (pntStart).x = x; <br>    (pntStart).y = y; <br> <br>    vTranslateCurPosToSquare(pntStart, &amp;iSX, &amp;iSY); <br> <br>    if (fValidSetupPiece(b, iSX, iSY)) <br>    { <br>    HDC hDC; <br> <br>    SetCursor(curPiece); <br>    hDC = GetDC(hWnd); <br>    AssertSz((iSX &gt;= 0) &amp;&amp; ((iSX &lt;= 7) || (iSX == 10)), "iSX out of range on ButtonDown"); <br>    AssertSz((iSY &gt;= 0) &amp;&amp; (iSY &lt;= 7), "iSY out of range on ButtonDown"); <br>        vClearMovingPiece(hDC, iSX, iSY); <br>    rGameState.fMoveInProgress = TRUE; <br>    } <br>    else <br>    { <br>        TraceTag(tagUI, "BEEP: Not a valid setup piece (in RButtonDown)"); <br>    MessageBeep(MB_OK); <br>    rGameState.fMoveInProgress = FALSE; <br>    } <br>    rGameState.fRMouseButtonDown = TRUE; <br>    TraceTag(tagMouse, "rGameState.fRMouseButtonDown: %d", rGameState.fRMouseButtonDown); <br>     <br>} <br> <br>void inline NormalLButtonDown(HWND hWnd, UINT keyFlags, int x, int y) <br>{ <br>    int iSX = 0; <br>    int iSY = 0; <br> <br>    AssertSz((rGameState.iPlayerTurn == RED) || <br>       (rGameState.iPlayerTurn == BLACK), "Player turn is bogus."); <br> <br>    TraceTag(tagMouse, "in NormalLButtonDown()"); <br> <br>    if ((HUMAN_PLAYER == rConfig.rPlayer[rGameState.iPlayerTurn].iPlayerType) &amp;&amp;  <br>    (!rGameState.fPaused)) <br>    { <br>    TraceTag(tagUI, "Button down at x:%d - y:%d", x, y); <br>    (pntStart).x = x; <br>    (pntStart).y = y; <br> <br>    vTranslateCurPosToSquare(pntStart, &amp;iSX, &amp;iSY); <br>    if (fValidPlayerPiece(b, iSX, iSY)) <br>    { <br>        HDC hDC; <br> <br>        SetCursor(curPiece); <br>        hDC = GetDC(hWnd); <br>        AssertSz((iSX &gt;= 0) &amp;&amp; (iSX &lt;= 7), "iSX out of range on ButtonDown"); <br>        AssertSz((iSY &gt;= 0) &amp;&amp; (iSY &lt;= 7), "iSY out of range on ButtonDown"); <br>        vClearMovingPiece(hDC, iSX, iSY); <br>        rGameState.fMoveInProgress = TRUE; <br>    } <br>    else <br>    { <br>            TraceTag(tagUI, "BEEP: Not a valid piece in LButtonDown"); <br>        MessageBeep(MB_OK); <br>        rGameState.fMoveInProgress = FALSE; <br>    } <br>    } <br>    else <br>    { <br>        TraceTag(tagUI, "BEEP: Wrong player in LButtonDown"); <br>    MessageBeep(MB_OK); <br>    } <br> <br>    rGameState.fLMouseButtonDown = TRUE; <br>    TraceTag(tagMouse, "rGameState.fLMouseButtonDown: %d", rGameState.fLMouseButtonDown); <br>     <br>} <br> <br>void inline SetupLButtonUp(HWND hWnd, WPARAM uParam, int x, int y) <br>{ <br> <br>    TraceTag(tagMouse, "in SetupLButtonUp()"); <br> <br>    if (rGameState.fMoveInProgress) <br>    { <br>    int     iEngineStart=0; <br>    int     iEngineEnd=0; <br>    int     iSX = 0; <br>    int     iSY = 0; <br>    int     iEX = 0; <br>    int     iEY = 0; <br>    BOOL    fRackSelect = FALSE; <br>        POINT   pntEnd; <br> <br>    SetCursor(curNormal); <br> <br>    rGameState.fLMouseButtonDown = FALSE; <br>    pntEnd.x = x; <br>    pntEnd.y = y; <br>     <br>    vTranslateCurPosToSquare(pntStart, &amp;iSX, &amp;iSY); <br>        if ((iSX == 10) &amp;&amp; (iSY &gt;=2) &amp;&amp; (iSY &lt;= 6)) <br>            fRackSelect = TRUE; <br>        else <br>        { <br>            fRackSelect = FALSE; <br>            vTranslateUIToEngineSquare(&amp;iEngineStart, iSX, iSY); <br>        } <br> <br>    vTranslateCurPosToSquare(pntEnd, &amp;iEX, &amp;iEY); <br>    vTranslateUIToEngineSquare(&amp;iEngineEnd, iEX, iEY); <br> <br>    TraceTag(tagUI, "Button up at x:%d - y:%d", pntEnd.x, pntEnd.y); <br> <br>        if (iEngineStart != iEngineEnd) <br>        { <br>        if ((iEngineEnd != -1) &amp;&amp; (iEngineStart != -1) &amp;&amp; (!fRackSelect)) <br>        { <br>            TraceTag(tagUI, "St: %d * End: %d", iEngineStart, iEngineEnd); <br> <br>            AssertSz(!fRackSelect, "Trains, Planes, and Automobiles"); <br>            AssertSz(iEngineEnd &lt; SQRS_MAX,"what could be a train"); <br>            AssertSz(iEngineEnd &gt; 0,"what could be trains"); <br>            AssertSz(iEngineStart &lt; SQRS_MAX,"two what could be a train"); <br>            AssertSz(iEngineStart &gt; 0,"two what could be trains"); <br> <br>                b[iEngineEnd] = b[iEngineStart]; <br> <br>            // If high-order bit is set, the control key is down, and I should <br>            // do a copy (not remove the source piece). <br> <br>            if (!(GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                b[iEngineStart] = EMPTY; <br> <br>             <br>        } <br>            else <br>            { <br>            AssertSz(iEngineEnd &lt; SQRS_MAX,"while (TRUE) fork();"); <br>            AssertSz((iEngineEnd &gt; 0) || (-1 == iEngineEnd),"while (TRUE) spoon();"); <br>             <br>                if ((iEngineEnd != -1) &amp;&amp; (fRackSelect)) <br>                { <br>                    switch(iSY) <br>                    { <br>                        case 2: <br>                            b[iEngineEnd] = RED; <br>                            break; <br>                        case 3: <br>                            b[iEngineEnd] = BLACK; <br>                            break; <br>                        case 4: <br>                            b[iEngineEnd] = RED | KING; <br>                            break; <br>                        case 5: <br>                            b[iEngineEnd] = BLACK | KING; <br>                            break; <br>                        case 6: <br>                            b[iEngineEnd] = EMPTY; <br>                            break; <br>                        default: <br>                            AssertSz(FALSE, "Phenylketonurics: Contains Phenylalanine"); <br>                            break; <br>                    } <br>                } <br>        } <br>    } <br>    else <br>    { <br>        // This is what happens if we picked up a piece and dropped it on <br>        // the same square. Right now this is a no-op. <br>    } <br>                                                           <br>    DrawBoard(b); <br>    } <br> <br>    rGameState.fLMouseButtonDown = FALSE; <br>    TraceTag(tagMouse, "rGameState.fLMouseButtonDown: %d", rGameState.fLMouseButtonDown); <br>     <br>} <br> <br>void inline SetupRButtonUp(HWND hWnd, WPARAM uParam, int x, int y) <br>{ <br> <br>    TraceTag(tagMouse, "in SetupRButtonUp()"); <br> <br>    if (rGameState.fMoveInProgress) <br>    { <br>    int     iEngineStart=0; <br>    int     iEngineEnd=0;   <br>    int     iSX = 0; <br>    int     iSY = 0; <br>    int     iEX = 0; <br>    int     iEY = 0; <br>    BOOL    fRackSelect = FALSE; <br>        POINT   pntEnd; <br> <br>    SetCursor(curNormal); <br> <br>    rGameState.fRMouseButtonDown = FALSE; <br>    pntEnd.x = x; <br>    pntEnd.y = y; <br>     <br>    vTranslateCurPosToSquare(pntStart, &amp;iSX, &amp;iSY); <br>        if ((iSX == 10) &amp;&amp; (iSY &gt;=2) &amp;&amp; (iSY &lt;= 6)) <br>            fRackSelect = TRUE; <br>        else <br>        { <br>            fRackSelect = FALSE; <br>            vTranslateUIToEngineSquare(&amp;iEngineStart, iSX, iSY); <br>        } <br> <br>    vTranslateCurPosToSquare(pntEnd, &amp;iEX, &amp;iEY); <br>    vTranslateUIToEngineSquare(&amp;iEngineEnd, iEX, iEY); <br> <br>    TraceTag(tagUI, "Button up at x:%d - y:%d", pntEnd.x, pntEnd.y); <br> <br>        if (iEngineStart == iEngineEnd) <br>        { <br>        if ((iEngineStart != -1) &amp;&amp; (!fRackSelect)) <br>        { <br>            TraceTag(tagUI, "St: %d * End: %d", iEngineStart, iEngineEnd); <br> <br>            AssertSz(!fRackSelect, "Trains, Planes, and Automobiles"); <br>            AssertSz(iEngineEnd &lt; SQRS_MAX,"what could be a train"); <br>            AssertSz(iEngineEnd &gt; 0,"what could be trains"); <br>            AssertSz(iEngineStart &lt; SQRS_MAX,"two what could be a train"); <br>            AssertSz(iEngineStart &gt; 0,"two what could be trains"); <br> <br>                b[iEngineStart] = EMPTY; <br>        } <br>    } <br>    else <br>    { <br>        // This is what happens if we clicked on a piece but moved off of the <br>        // original square.. Right now this is a no-op. <br>    } <br>                                                           <br>    DrawBoard(b); <br>    } <br>     <br>    rGameState.fRMouseButtonDown = FALSE; <br>    TraceTag(tagMouse, "rGameState.fRMouseButtonDown: %d", rGameState.fRMouseButtonDown); <br> <br>} <br> <br> <br>void inline NormalLButtonUp(HWND hWnd, WPARAM uParam, int x, int y) <br>{ <br>    int iGameState = GAME_PLAYABLE; <br> <br>    TraceTag(tagMouse, "in NormalLButtonUp()"); <br> <br>    if (rGameState.fMoveInProgress) <br>    { <br>    int     iEngineStart;                       <br>    int     iEngineEnd; <br>    int     iValid = 0;    // Valid move <br>    int     iSX = 0; <br>    int     iSY = 0; <br>    int     iEX = 0; <br>    int     iEY = 0; <br>    POINT   pntEnd; <br> <br>    SetCursor(curNormal); <br> <br>    rGameState.fLMouseButtonDown = FALSE; <br>    pntEnd.x = x; <br>    pntEnd.y = y; <br>     <br>    vTranslateCurPosToSquare(pntStart, &amp;iSX, &amp;iSY); <br>    vTranslateUIToEngineSquare(&amp;iEngineStart, iSX, iSY); <br>    vTranslateCurPosToSquare(pntEnd, &amp;iEX, &amp;iEY); <br>    vTranslateUIToEngineSquare(&amp;iEngineEnd, iEX, iEY); <br> <br>    TraceTag(tagUI, "Button up at x:%d - y:%d", pntEnd.x, pntEnd.y); <br> <br>    if ((iEngineEnd != -1) &amp;&amp; (iEngineStart != -1)) <br>    { <br>        TraceTag(tagUI, "St: %d * End: %d", iEngineStart, iEngineEnd); <br> <br>        AssertSz(((BLACK == rGameState.iPlayerTurn) ||  <br>              (RED == rGameState.iPlayerTurn)), "Fronk, lots!"); <br>               <br>        if (HUMAN_PLAYER == rConfig.rPlayer[rGameState.iPlayerTurn].iPlayerType) <br>        { <br>        AssertSz(iEngineEnd &lt; SQRS_MAX,"ugly players what could be a train"); <br>        AssertSz(iEngineEnd &gt;= 0,"ugly players what could be trains"); <br>        AssertSz(iEngineStart &lt; SQRS_MAX,"ugly players two what could be a train"); <br>        AssertSz(iEngineStart &gt;= 0,"ugly players two what could be trains"); <br>        iValid = MoveValid(b, iEngineStart, iEngineEnd, rGameState.iPlayerTurn); <br>        } <br>    } <br>    else <br>        iValid = -1; <br> <br>    DrawBoard(b); <br> <br>        if (iValid == 1) <br>        { <br>        if (rGameState.iPlayerTurn == BLACK) <br>            rGameState.iPlayerTurn = RED; <br>        else <br>            rGameState.iPlayerTurn = BLACK; <br>     <br>        CMoves.NewMove(b, rGameState.iPlayerTurn); <br>            iGameState = GameOver(b, rGameState.iPlayerTurn); <br>            switch (iGameState) <br>            { <br>            case GAME_WON: <br>                    rGameState.fGameOver = TRUE; <br>                    DisplayGameOver(hMainWnd, rGameState.iPlayerTurn); <br>                break; <br>                case GAME_DRAWN: <br>                rGameState.fGameOver = TRUE; <br>                DisplayGameDrawn(hMainWnd, rGameState.iPlayerTurn); <br>                    break;             <br>                case GAME_PLAYABLE: <br>            OnGamePlayableAfterMove(); <br>                    break;          <br>                default: <br>                    AssertSz(FALSE, "very dead");                       <br>            } <br>        } <br>    } <br>    rGameState.fMoveInProgress = FALSE; <br>    rGameState.fLMouseButtonDown = FALSE; <br>    TraceTag(tagMouse, "rGameState.fLMouseButtonDown: %d", rGameState.fLMouseButtonDown); <br>     <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent) <br>{ <br>    RECT    rChild, rParent; <br>    int     wChild, hChild, wParent, hParent; <br>    int     wScreen, hScreen, xNew, yNew; <br>    HDC     hdc; <br> <br>    // Get the Height and Width of the child window <br>    GetWindowRect (hwndChild, &amp;rChild); <br>    wChild = rChild.right - rChild.left; <br>    hChild = rChild.bottom - rChild.top; <br> <br>    // Get the Height and Width of the parent window <br>    GetWindowRect (hwndParent, &amp;rParent); <br>    wParent = rParent.right - rParent.left; <br>    hParent = rParent.bottom - rParent.top; <br> <br>    // Get the display limits <br>    hdc = GetDC (hwndChild); <br>    wScreen = GetDeviceCaps (hdc, HORZRES); <br>    hScreen = GetDeviceCaps (hdc, VERTRES); <br>    ReleaseDC (hwndChild, hdc); <br> <br>    // Calculate new X position, then adjust for screen <br>    xNew = rParent.left + ((wParent - wChild) /2); <br>    if (xNew &lt; 0) { <br>        xNew = 0; <br>    } else if ((xNew+wChild) &gt; wScreen) { <br>        xNew = wScreen - wChild; <br>    } <br> <br>    // Calculate new Y position, then adjust for screen <br>    yNew = rParent.top  + ((hParent - hChild) /2); <br>    if (yNew &lt; 0) { <br>        yNew = 0; <br>    } else if ((yNew+hChild) &gt; hScreen) { <br>        yNew = hScreen - hChild; <br>    } <br> <br>    // Set it, and return <br>    return SetWindowPos (hwndChild, NULL, <br>        xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br>/**************************************************************************** <br>***************************************************************************** <br>***************************************************************************** <br>****************************************************************************/ <br> <br>BOOL FAR PASCAL ComputerSettingsDialogProc (HWND hDlg, <br>                    WORD wMsgID, <br>                    WPARAM wParam, <br>                    LPARAM lParam) <br>{ <br>    static struct rPlayerRec *prPlayer; <br> <br>    switch (wMsgID) <br> <br>    { <br>    case WM_INITDIALOG: <br>        prPlayer = (struct rPlayerRec FAR *) lParam; <br>        Assert(prPlayer); <br>        SendDlgItemMessage(hDlg, IDCB_USE_OPENING_BOOK, BM_SETCHECK, prPlayer-&gt;iUseOpeningBook, 0L); <br>        SendDlgItemMessage(hDlg, IDCB_USE_MEM_POSITIONS, BM_SETCHECK, prPlayer-&gt;iMemPositions, 0L); <br>        SendDlgItemMessage(hDlg, IDCB_USE_MOVE_THEORY, BM_SETCHECK, prPlayer-&gt;iUseMoveTheory, 0L); <br>        SendDlgItemMessage(hDlg, IDCB_MOVE_SHUFFLING, BM_SETCHECK, prPlayer-&gt;iUseMoveShuffling, 0L); <br>        SendDlgItemMessage(hDlg, IDCB_GOOD_MOVE_SKIPPING, BM_SETCHECK, (int)prPlayer-&gt;lUseGoodMoveSkipping, 0L); <br>        SendDlgItemMessage(hDlg, IDCB_EQUAL_MOVE_SKIPPING, BM_SETCHECK, prPlayer-&gt;iUseEqualMoveSkipping, 0L); <br>        SendDlgItemMessage(hDlg, IDCB_ALPHA_BETA_PRUNING, BM_SETCHECK, prPlayer-&gt;iUseAlphaBetaPruning, 0L); <br> <br>        // Set other edit controls <br> <br>        SetDlgItemLong(hDlg, IDEC_RECURSION_DEPTH, prPlayer-&gt;iMaxRecursionDepth); <br>            SetDlgItemLong(hDlg, IDEC_PRUNING_DEPTH, prPlayer-&gt;lAlphaPruningOriginalDepth); <br>            SetDlgItemLong(hDlg, IDEC_PRUNING_WIDTH, prPlayer-&gt;lAlphaPruningWidth); <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        switch (wParam) <br>        { <br>        case IDOK: <br>            EndDialog (hDlg, TRUE); <br>             <br>            // Get Checkbox values <br>            prPlayer-&gt;iUseOpeningBook = (int)SendDlgItemMessage(hDlg, IDCB_USE_OPENING_BOOK, BM_GETCHECK, 0, 0L); <br>            prPlayer-&gt;iMemPositions = (int)SendDlgItemMessage(hDlg, IDCB_USE_MEM_POSITIONS, BM_GETCHECK, 0, 0L); <br>            prPlayer-&gt;iUseMoveTheory = (int)SendDlgItemMessage(hDlg, IDCB_USE_MOVE_THEORY, BM_GETCHECK, 0, 0L); <br>            prPlayer-&gt;iUseMoveShuffling = (int)SendDlgItemMessage(hDlg, IDCB_MOVE_SHUFFLING, BM_GETCHECK, 0, 0L); </code></pre>
<p>
</p>
<pre><code>prPlayer-&gt;lUseGoodMoveSkipping = (int)SendDlgItemMessage(hDlg, IDCB_GOOD_MOVE_SKIPPING, BM_GETCHECK, 0, 0L); <br>            prPlayer-&gt;iUseEqualMoveSkipping = (int)SendDlgItemMessage(hDlg, IDCB_EQUAL_MOVE_SKIPPING, BM_GETCHECK, 0, 0L); <br>            prPlayer-&gt;iUseAlphaBetaPruning = (int)SendDlgItemMessage(hDlg, IDCB_ALPHA_BETA_PRUNING, BM_GETCHECK, 0, 0L); <br>            prPlayer-&gt;iMemPositions = (int)SendDlgItemMessage(hDlg, IDCB_USE_MEM_POSITIONS, BM_GETCHECK, 0, 0L); <br> <br>            // Get Edit Control Values <br> <br>            prPlayer-&gt;iMaxRecursionDepth         = GetDlgItemInt(hDlg, IDEC_RECURSION_DEPTH); <br>                    prPlayer-&gt;lAlphaPruningOriginalDepth = GetDlgItemLong(hDlg, IDEC_PRUNING_DEPTH); <br>                    prPlayer-&gt;lAlphaPruningWidth         = GetDlgItemLong(hDlg, IDEC_PRUNING_WIDTH); <br> <br>            return TRUE; <br> <br>        case IDCANCEL: <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        }                                    // end switch <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br>BOOL FAR PASCAL PlayersDialogProc (HWND hDlg, <br>                    WORD wMsgID, <br>                    WPARAM wParam, <br>                    LPARAM lParam) <br>{ <br>    switch (wMsgID) <br> <br>    { <br>    case WM_INITDIALOG: <br>        switch(rConfig.rPlayer[PLAYER1].iPlayerType) <br>        { <br>        case HUMAN_PLAYER: <br>            SendDlgItemMessage(hDlg, IDRB_P1_HUMAN, BM_SETCHECK, 1, 0L); <br>            break; <br>        case COMPUTER_PLAYER: <br>            SendDlgItemMessage(hDlg, IDRB_P1_COMPUTER, BM_SETCHECK, 1, 0L); <br>            break; <br>        case NETWORK_PLAYER: <br>            SendDlgItemMessage(hDlg, IDRB_P1_NETWORK, BM_SETCHECK, 1, 0L); <br>            break; <br>        default: <br>            AssertSz(FALSE, "rConfig.rPlayer[PLAYER1].iPlayerType not valid"); <br>            break; <br>        } <br>         <br>        switch(rConfig.rPlayer[PLAYER2].iPlayerType) <br>        { <br>        case HUMAN_PLAYER: <br>            SendDlgItemMessage(hDlg, IDRB_P2_HUMAN, BM_SETCHECK, 1, 0L); <br>            break; <br>        case COMPUTER_PLAYER: <br>            SendDlgItemMessage(hDlg, IDRB_P2_COMPUTER, BM_SETCHECK, 1, 0L); <br>            break; <br>        case NETWORK_PLAYER: <br>            SendDlgItemMessage(hDlg, IDRB_P2_NETWORK, BM_SETCHECK, 1, 0L); <br>            break; <br>        default: <br>            AssertSz(FALSE, "rConfig.rPlayer[PLAYER2].iPlayerType not valid"); <br>            break; <br>        } <br> <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        switch (wParam) <br>        { <br>        case IDB_P1_COMPUTER_SETUP: <br> <br>            DialogBoxParam (hInst,       // current instance <br>                    "COMPUTER_SETUP_MASTER", // dlg resource to use <br>                    hDlg,        // parent handle <br>                    (DLGPROC)ComputerSettingsDialogProc, // Config() instance address <br>                    (LPARAM) (struct rPlayerRec *) (&amp;(rConfig.rPlayer[PLAYER1]))); <br>            break; <br> <br>        case IDB_P2_COMPUTER_SETUP: <br> <br>            DialogBoxParam (hInst,       // current instance <br>                    "COMPUTER_SETUP_MASTER", // dlg resource to use <br>                    hDlg,        // parent handle <br>                    (DLGPROC)ComputerSettingsDialogProc, // Config() instance address <br>                    (LPARAM) (struct rPlayerRec *) (&amp;(rConfig.rPlayer[PLAYER2]))); <br>            break; <br>         <br>        case IDB_P1_NETWORK_SETUP: <br>        case IDB_P2_NETWORK_SETUP: <br>            NYI("Player Network Setup"); <br>            break; <br> <br>        case IDOK: <br>            EndDialog (hDlg, TRUE); <br>            if (SendDlgItemMessage(hDlg, IDRB_P1_HUMAN, BM_GETCHECK, 0, 0L)) <br>            rConfig.rPlayer[PLAYER1].iPlayerType = HUMAN_PLAYER; <br>            if (SendDlgItemMessage(hDlg, IDRB_P1_COMPUTER, BM_GETCHECK, 0, 0L)) <br>            rConfig.rPlayer[PLAYER1].iPlayerType = COMPUTER_PLAYER; <br>            if (SendDlgItemMessage(hDlg, IDRB_P1_NETWORK, BM_GETCHECK, 0, 0L)) <br>            rConfig.rPlayer[PLAYER1].iPlayerType = NETWORK_PLAYER; <br>            if (SendDlgItemMessage(hDlg, IDRB_P2_HUMAN, BM_GETCHECK, 0, 0L)) <br>            rConfig.rPlayer[PLAYER2].iPlayerType = HUMAN_PLAYER; <br>            if (SendDlgItemMessage(hDlg, IDRB_P2_COMPUTER, BM_GETCHECK, 0, 0L)) <br>            rConfig.rPlayer[PLAYER2].iPlayerType = COMPUTER_PLAYER; <br>            if (SendDlgItemMessage(hDlg, IDRB_P2_NETWORK, BM_GETCHECK, 0, 0L)) <br>            rConfig.rPlayer[PLAYER2].iPlayerType = NETWORK_PLAYER; <br>            return TRUE; <br> <br>        case IDCANCEL: <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        }                                    // end switch <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br> <br>BOOL FAR PASCAL DebugConfigDialogProc (HWND hDlg, <br>                    WORD wMsgID, <br>                    WPARAM wParam, <br>                    LPARAM lParam) <br>{ <br>    switch (wMsgID) <br> <br>    { <br>    case WM_INITDIALOG: <br>        SetDlgItemInt(hDlg, IDEC_MAX_MOVES, rConfig.iMaxMoves); <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        switch (wParam) <br>        { <br>        case IDOK: <br>            EndDialog (hDlg, TRUE); <br>            rConfig.iMaxMoves = GetDlgItemInt(hDlg, IDEC_MAX_MOVES); <br>            return TRUE; <br> <br>        case IDCANCEL: <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        }                                    // end switch <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br> <br>int FAR PASCAL PlayerTurnDialogProc (HWND hDlg, <br>                    WORD wMsgID, <br>                    WPARAM wParam, <br>                    LPARAM lParam) <br>{ <br>    switch (wMsgID) <br> <br>    { <br>    case WM_INITDIALOG: <br>            CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER)); <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        switch (wParam) <br>        { <br>        case IDB_PLAYER1: <br>            EndDialog (hDlg, PLAYER1); <br>            return TRUE; <br> <br>        case IDB_PLAYER2: <br>            EndDialog (hDlg, PLAYER2); <br>            return TRUE; <br>         <br>        case IDCANCEL: <br>            // Return -1 so the calling function will know that the result <br>            // from the dialog call isn't equal to a player ID. <br>             <br>            EndDialog (hDlg, -1); <br>            break;     <br>        }                                    // end switch <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br> <br>LRESULT CALLBACK About( <br>        HWND hDlg,           // window handle of the dialog box <br>        UINT message,        // type of message <br>        WPARAM wParam,       // message-specific information <br>        LPARAM lParam) <br>{ <br>    static  HFONT hfontDlg; <br>    static  LPSTR   lpVersion; <br>    static  DWORD   dwVerInfoSize; <br>    static  DWORD   dwVerHnd; <br>    static  UINT    uVersionLen; <br>    static  WORD    wRootLen; <br>    BOOL    bRetCode; <br>    static  int     i; <br>    static  char    szFullPath[256]; <br>    static  char    szResult[256]; <br>    static  char    szGetName[256]; <br> <br>    switch (message) { <br>        case WM_INITDIALOG:  // message: initialize dialog box <br>            // Create a font to use <br>            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, <br>                0, 0, 0, 0, <br>                VARIABLE_PITCH | FF_SWISS, ""); <br> <br>            // Center the dialog over the application window <br>            CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER)); <br> <br>            // Get version information from the application <br>            GetModuleFileName (hInst, szFullPath, sizeof(szFullPath)); <br>            dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &amp;dwVerHnd); <br>            if (dwVerInfoSize) { <br>                // If we were able to get the information, process it: <br>                LPSTR   lpstrVffInfo; <br>                HANDLE  hMem; <br>                hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize); <br>                lpstrVffInfo  = (char *)GlobalLock(hMem); <br>                GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo); <br>                lstrcpy(szGetName, "\\StringFileInfo\\040904E4\\"); <br>                wRootLen = lstrlen(szGetName); <br> <br>                // Walk through the dialog items that we want to replace: <br>                for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) { <br>                    GetDlgItemText(hDlg, i, szResult, sizeof(szResult)); <br>                    szGetName[wRootLen] = (char)0; <br>                    lstrcat (szGetName, szResult); <br>                    uVersionLen   = 0; <br>                    lpVersion     = NULL; <br>                      bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo, <br>                          (LPSTR)szGetName, <br>                          (LPVOID *)&amp;lpVersion, <br>#if defined (_WIN32) <br>                          (PUINT)&amp;uVersionLen); // For MIPS strictness <br>#else <br>                          (UINT FAR *)&amp;uVersionLen); <br>#endif <br> <br>                      if ( bRetCode &amp;&amp; uVersionLen &amp;&amp; lpVersion) { <br>                          // Replace dialog item text with version info <br>                          lstrcpy(szResult, lpVersion); <br>                          SetDlgItemText(hDlg, i, szResult); <br>                          SendMessage (GetDlgItem (hDlg, i), WM_SETFONT, (UINT)hfontDlg, TRUE); <br>                      } <br>                } // for (i = DLG_VERFIRST; i &lt;= DLG_VERLAST; i++) <br> <br>                GlobalUnlock(hMem); <br>                GlobalFree(hMem); <br>            } // if (dwVerInfoSize) <br> <br>            return (TRUE); <br> <br>        case WM_COMMAND:                      // message: received a command <br>            if (LOWORD(wParam) == IDOK        // "OK" box selected? <br>            || LOWORD(wParam) == IDCANCEL) {  // System menu close command? <br>                EndDialog(hDlg, TRUE);        // Exit the dialog <br>                DeleteObject (hfontDlg); <br>                return (TRUE); <br>            } <br>            break; <br>    } <br>    return (FALSE); // Didn't process the message <br> <br>    lParam; // This will prevent 'unused formal parameter' warnings <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
