<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VALID.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2046"></a>VALID.CPP</h2>
<pre><code>/* -------------------------------------------------------------------------- <br>b - board on which to make the move (will be changed on return) <br>t - RED, BLACK <br> <br>returns 0 if invalid move <br>        2 if continuable <br>else    1  <br>-------------------------------------------------------------------------- */ <br>int MoveValid(BOARD b, int start, int dest, int t) <br>{ <br>    int j; /* the piece we are jumping over */ <br>    int restore_depth; <br>    int must_jump=0; <br> <br>    AssertSz(start &gt; 0 &amp;&amp; start &lt;= 32, "ducks"); <br>    AssertSz(dest &gt; 0 &amp;&amp; dest &lt;= 32, "geese"); <br>    AssertSz(t==RED || t==BLACK, "The Tetonkaha Wildabeast"); <br>    AssertSz(b[start], "it means buffalo"); <br>     <br>    /* destination empty */ <br>    if (0 != b[dest]) return 0; <br>    pdebug(stddbgmin,"MoveValid destination empty %s(%d)",__FILE__,__LINE__); <br> <br>    /* if must jump rule is on */ <br>    if (rConfig.iMustJump) <br>        { <br>        int besttype, bestnumber; <br>        long bestquality; <br>        long c=-1; long p=-1; int fBreak=0; <br>        int i=0; <br>         <br>        restore_depth = depth_maximum; <br>        depth_maximum = 1; <br>        for (i=0;i&lt;SQRS_MAX;i++) <br>            { <br>            if (b[i] &amp; t) <br>                { <br>                must_jump += IterateJumps(b,i,t,0, <br>                            &amp;besttype, &amp;bestnumber, &amp;bestquality, <br>                            c,p,&amp;fBreak); <br>                } <br>            AssertSz(fBreak==0,"no way samual jones"); <br>            } <br>        depth_maximum = restore_depth; <br>        } <br> <br>    if (t == RED || (b[start] &amp; KING)) <br>        { <br>        pdebug(stddbgmin,"MoveValid considering RED moves %s(%d)",__FILE__,__LINE__); <br>        if (red_lut[start][0] == dest) goto slide; <br>        if (red_lut[start][2] == dest) goto slide; <br>        if (red_jump_lut[start][1] == dest &amp;&amp; (b[red_jump_lut[start][0]]|KING) == (next(t)|KING)) {j=red_jump_lut[start][0]; goto jump;} <br>        if (red_jump_lut[start][3] == dest &amp;&amp; (b[red_jump_lut[start][2]]|KING) == (next(t)|KING)) {j=red_jump_lut[start][2]; goto jump;} <br>        } <br>    if (t == BLACK || (b[start] &amp; KING)) <br>        { <br>        pdebug(stddbgmin,"MoveValid considering BLACK moves %s(%d)",__FILE__,__LINE__); <br>        if (black_lut[start][0] == dest) goto slide; <br>        if (black_lut[start][2] == dest) goto slide; <br>        if (black_jump_lut[start][1] == dest &amp;&amp; (b[black_jump_lut[start][0]]|KING) == (next(t)|KING)) {j=black_jump_lut[start][0]; goto jump;} <br>        if (black_jump_lut[start][3] == dest &amp;&amp; (b[black_jump_lut[start][2]]|KING) == (next(t)|KING)) {j=black_jump_lut[start][2]; goto jump;} <br>        } <br> <br>    /* illegal position */ <br>    pdebug(stddbgmin,"MoveValid illegal position %s(%d)",__FILE__,__LINE__); <br>    return 0; <br> <br>slide: <br>    pdebug(stddbgmin,"MoveValid found legal sliding move %s(%d)",__FILE__,__LINE__); <br>    if (must_jump) <br>        { <br>        pdebug(stddbgmin,"slide attempt when jumping move is possible %s(%d)",__FILE__,__LINE__); <br>        return 0; <br>        } <br>    b[dest] = b[start]; <br>    b[start] = 0; <br> <br>    if (RED &amp; b[1]) b[1] |= KING; <br>    if (RED &amp; b[2]) b[2] |= KING; <br>    if (RED &amp; b[3]) b[3] |= KING; <br>    if (RED &amp; b[4]) b[4] |= KING; <br>    if (BLACK &amp; b[32]) b[32] |= KING; <br>    if (BLACK &amp; b[31]) b[31] |= KING; <br>    if (BLACK &amp; b[30]) b[30] |= KING; <br>    if (BLACK &amp; b[29]) b[29] |= KING; <br> <br>    return 1; <br> <br>jump: <br>    pdebug(stddbgmin,"MoveValid found legal jump %s(%d)",__FILE__,__LINE__); <br>    b[dest] = b[start]; <br>    b[start] = 0; <br>    b[j] = 0; <br> <br>    if (t == BLACK || (b[dest] &amp; KING)) <br>        { <br>        if (b[black_jump_lut[dest][1]] == 0 &amp;&amp; (b[black_jump_lut[dest][0]]|KING) == (next(t)|KING)) {return 2;} <br>        if (b[black_jump_lut[dest][3]] == 0 &amp;&amp; (b[black_jump_lut[dest][2]]|KING) == (next(t)|KING)) {return 2;} <br>        } <br> <br>    if (t == RED || (b[dest] &amp; KING)) <br>        { <br>        if (b[red_jump_lut[dest][1]] == 0 &amp;&amp; (b[red_jump_lut[dest][0]]|KING) == (next(t)|KING)) {return 2;} <br>        if (b[red_jump_lut[dest][3]] == 0 &amp;&amp; (b[red_jump_lut[dest][2]]|KING) == (next(t)|KING)) {return 2;} <br>        } <br> <br>    pdebug(stddbgmin,"MoveValid found jump is NOT continuable %s(%d)",__FILE__,__LINE__); <br>    return 1; <br>} <br> <br>/* -------------------------------------------------------------------------- <br>GameOver returns <br> <br>GAME_{WON}|{PLAYABLE}|{DRAWN} <br>--------------------------------------------------------------------------- */ <br>int GameOver(BOARD b, int t) <br>{ <br>    int restore_depth; <br>    int besttype, bestnumber; <br>    long bestquality; <br>    long c=-1; long p=-1; int fBreak=0; <br>    int i=0;                             // Piece I'm on. <br>    int move_is_possible=0; <br> <br>    restore_depth = depth_maximum; <br>    depth_maximum = 1; <br>    for (i=0;i&lt;SQRS_MAX;i++) <br>        { <br>        if (b[i] &amp; t) <br>            { <br>            move_is_possible += IterateJumps(b,i,t,0, <br>                        &amp;besttype, &amp;bestnumber, &amp;bestquality, <br>                        c,p,&amp;fBreak); <br>            move_is_possible += IterateMoves(b,i,t,0, <br>                        &amp;besttype, &amp;bestnumber, &amp;bestquality, <br>                        c,p,&amp;fBreak); <br>            if (move_is_possible) <br>                break; <br>            } <br>            AssertSz(fBreak==0,"no way sammy jones"); <br>        } <br>    depth_maximum = restore_depth; <br> <br>    /* ----- make sure this isn't a drawn game ----- */ <br>    if (move_is_possible) <br>    { <br>        int i=rConfig.iMaxMoves; <br>        int t=0; <br>        SQUARE b[SQRS_MAX]; <br> <br>        if (CMoves.GetFirstBoard(b,&amp;t)) <br>            while (CMoves.GetNextBoard(b,&amp;t)) <br>                i--; <br>        AssertSz(i &gt; -5, "vania lorelle"); <br>        if (i&lt;0)  <br>            return GAME_DRAWN; <br>    } <br> <br>    if (move_is_possible) <br>        return(GAME_PLAYABLE); <br>    else <br>        return(GAME_WON);     <br> <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
