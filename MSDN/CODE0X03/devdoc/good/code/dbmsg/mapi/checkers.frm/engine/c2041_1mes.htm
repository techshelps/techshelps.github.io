<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRUNE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2044"></a>PRUNE.CPP</h2>
<pre><code>/* -------------------------------------------------------------------------- <br>This function is qsort's callback <br>to sort the moves based on quality <br>-------------------------------------------------------------------------- */ <br>int __cdecl cmpgle(const void* elem1, const void* elem2) <br>{ <br>    if (    (*(struct _piece_order_struct *)elem1).q     &gt; <br>            (*(struct _piece_order_struct *)elem2).q     ) <br>        return -1; <br>    else if (    (*(struct _piece_order_struct *)elem1).q     &lt; <br>                 (*(struct _piece_order_struct *)elem2).q     ) <br>        return 1; <br>    else <br>        return 0; <br>} <br> <br>/* -------------------------------------------------------------------------- <br>THIS IS THE CHECKERS ENGINE:: <br> <br>b           - is the start board - it will be changed on return to <br>              reflect the move or moves (in the case of a double jump) <br>              made <br>t           - is whos turn it is RED or BLACK <br>j           - is jump continuation - must be 0 <br>prune_depth - how many levels to recurse to determine what to prune <br>prune_size  - how many branches of the pruned tree to pursue (note: <br>              each piece is considered as one branch even though it <br>              it results in as many as four actual branches <br>max_depth   - after the tree has been pruned how far should it recurse <br>              must be greater than the prune_depth <br> <br>side effects: <br>            Calls PrintBoard (debugio.cpp) <br> <br>note: we may wish to use iterative deepening here and base things on time <br>-------------------------------------------------------------------------- */ <br>long PlayBestMove(BOARD b, int t, int j, int d, <br>                    int prune_depth, int prune_size, int max_depth) <br>{ <br>    /* ----- stack variables ----- */ <br>    int  moves_made        =  0; <br>    int  best_move_type    = -1; <br>    int  best_move_number  = -1; <br>    long best_move_quality = -1; <br>    long alpha_beta_c      = -1; <br>    int  fBreak            = 0; <br>    int  i; <br> <br>    #ifdef DEBUG <br>    int  jumps_made        =  0; <br>    #endif <br> <br>    AssertSz(prune_size &lt;= SQRS_MAX, "me. prune size is way to big"); <br>    AssertSz(prune_size &gt; 1, "how much? prune size is way to small"); <br>    AssertSz(0 == b[0], "b sub zero should equal zero"); <br>    AssertSz(0 == b[SQRS_MAX-1], "b sub MAX-1 should equal zero"); <br> <br>    /* ----- debug ----- */ <br>    if (debug &amp;&amp; d &lt; 3) PrintBoard(b,d); <br> <br>    /* ----- initialize tables and variables ----- */ <br>    depth_maximum = max_depth; <br>    computer_color = t; <br>    for (i=0; i&lt;SQRS_MAX; i++) <br>        { <br>        piece_order[i].m = (SQUARE) i; <br>        piece_order[i].q = -1; <br>        } <br> <br>    /* ----- seed the random number generator ----- */ <br>    #ifdef DEBUG <br>    srand( 0 ); <br>    #else <br>    #ifdef TEST <br>    srand( 0 ); <br>    #else <br>    srand( (unsigned)time( NULL ) ); <br>    #endif <br>    #endif <br> <br>    /* ----- iterate through all possible moves AT PRUNE_DEPTH ----- */ <br>    if (prune_depth &gt; 0) <br>        { <br>        depth_maximum = prune_depth; <br>        pdebug(stddbgmin,"PlayBestMove d=%d %s(%d)\n",d,__FILE__,__LINE__); <br>        for (i=0;i&lt;SQRS_MAX; i++) <br>            { <br>            int piece; <br>            piece = (int) piece_order[i].m; <br>            if (0 == (b[piece] &amp; t)) continue; /* not our piece */ <br>            moves_made += IterateJumps(b,piece,t,d,&amp;best_move_type,&amp;best_move_number,&amp;piece_order[i].q,alpha_beta_c,best_move_quality,&amp;fBreak); <br>            AssertSz(0 == fBreak,"I must not prune at the root level of the tree"); <br>            #ifdef DEBUG <br>            jumps_made += moves_made; <br>            #endif <br>            } <br>        if (0 == moves_made /* enforce the must jump rule */ <br>            #ifndef HIGH_PERFORMANCE <br>                || 0==rConfig.iMustJump <br>            #endif <br>            ) <br>            { <br>            pdebug(stddbgmin,"could not find a jumping move to make %s(%d)\n",__FILE__,__LINE__); <br>            for (i=0;i&lt;SQRS_MAX; i++) <br>                { <br>                int piece; <br>                piece = (int) piece_order[i].m; <br>                if (0 == (b[piece] &amp; t)) continue; /* not our piece */ <br>                moves_made += IterateMoves(b,piece,t,d,&amp;best_move_type,&amp;best_move_number,&amp;piece_order[i].q,alpha_beta_c,best_move_quality,&amp;fBreak); <br>                AssertSz(0 == fBreak,"I ought not prune at the root level of the tree"); <br>                } <br>            } <br>        if (0 == moves_made) <br>            { <br>            pdebug(stddbgmin,"could not find a move to make (error not handled) %s(%d)\n",__FILE__,__LINE__); <br>            AssertSz(0, "I give up... why don't you go instead"); <br>            } <br>        } <br>    else <br>        { <br>        moves_made = 1000; <br>        prune_size = SQRS_MAX; <br>        } <br> <br>    /* ----- if we only have one move to make, dont recurse again ----- */ <br>    if (moves_made &gt; 1) <br>        { <br>        /* ----- shuffle the moves ----- */ <br>        for (i=SQRS_MAX-1; i &gt; 0; i--) <br>            { <br>            int r; <br>            struct _piece_order_struct temp; <br> <br>            /* ----- pick a random interchange ----- */ <br>            r = ((unsigned int)rand()) % ((unsigned int) i); <br> <br>            /* ----- swap the order ----- */ <br>            temp = piece_order[i]; <br>            piece_order[i] = piece_order[r]; <br>            piece_order[r] = temp; <br>            } <br> <br>        /* ----- sort the move table based on the move qualities <br>                of each move that we tried ----- */ <br>        pdebug(stddbgmin,"sorting... %s(%d)\n",__FILE__,__LINE__); <br>        qsort(piece_order,SQRS_MAX, sizeof(struct _piece_order_struct), cmpgle); <br>        pdebug(stddbgmin,"done sorting. %s(%d)\n",__FILE__,__LINE__); <br> <br> <br>        /* ----- recurse the pruned board to a deeper level ----- */ <br>continue_jump: <br>        moves_made = 0; <br>        depth_maximum = max_depth; <br>        pdebug(stddbgmin,"recursing pruned PlayBestMove d=%d %s(%d)\n",d,__FILE__,__LINE__); <br>        for (i=0;i&lt;prune_size; i++) <br>            { <br>            int piece; <br>            piece = (int) piece_order[i].m; <br>            if (0 == (b[piece] &amp; t)) continue; /* not our piece */ <br>            moves_made += IterateJumps(b,piece,t,d,&amp;best_move_type,&amp;best_move_number,&amp;best_move_quality,alpha_beta_c,best_move_quality,&amp;fBreak); <br>            AssertSz(0 == fBreak,"x2 I must not prune at the root level of the tree"); <br>            #ifdef DEBUG <br>            jumps_made += moves_made; <br>            #endif <br>            } <br>        if ((0 == moves_made <br>            #ifndef HIGH_PERFORMANCE <br>                || 0==rConfig.iMustJump <br>            #endif <br>            )&amp;&amp; 0 == j) /* enforce the must jump rule */ <br>            { <br>            pdebug(stddbgmin,"could not find a jumping move to make %s(%d)\n",__FILE__,__LINE__); <br>            for (i=0;i&lt;prune_size; i++) <br>                { <br>                int piece; <br>                piece = (int) piece_order[i].m; <br>                pdebug(stddbgmin,"Next move piece=%d i=%d %s(%d)\n",piece,i,__FILE__,__LINE__); <br>                if (0 == (b[piece] &amp; t)) continue; /* not our piece */ <br>                moves_made += IterateMoves(b,piece,t,d,&amp;best_move_type,&amp;best_move_number,&amp;best_move_quality,alpha_beta_c,best_move_quality,&amp;fBreak); <br>                AssertSz(0 == fBreak,"x3 I must not prune at the root level of the tree"); <br>                } <br>            } <br>        if (0 == moves_made) <br>            { <br>            pdebug(stddbgmin,"could not find a move to make (error ! handled) %s(%d)\n",__FILE__,__LINE__); <br>            #ifdef DEBUG <br>            AssertSz(jumps_made, "Your turn.  I mean.  Can I move or something? .. nevermind .. why don't you just go"); <br>            #endif <br>            } <br>        } <br> <br>    /* ----- do the first step of any jumps ----- */ <br>    if (best_move_type &gt; TYPE_BLACK2) <br>        { <br>        switch (best_move_type) <br>            { <br>            case TYPE_RED_JUMP0   : <br>                j = red_jump_lut[best_move_number][1]  ; <br>                piece_order[0].m = (SQUARE) j; <br>                MakeMoveNoKing_RED_JUMP0(b,best_move_number); <br>                if (0 != red_jump_lut[best_move_number][4] &amp;&amp; !(KING &amp; b[red_jump_lut[best_move_number][1]])) goto no_jump; <br>                break; <br> <br>            case TYPE_RED_JUMP2   : <br>                j = red_jump_lut[best_move_number][3]  ; <br>                piece_order[0].m = (SQUARE) j; <br>                MakeMoveNoKing_RED_JUMP2(b,best_move_number); <br>                if (0 != red_jump_lut[best_move_number][4] &amp;&amp; !(KING &amp; b[red_jump_lut[best_move_number][3]])) goto no_jump; <br>                break; <br> <br>            case TYPE_BLACK_JUMP0 : <br>                j = black_jump_lut[best_move_number][1]; <br>                piece_order[0].m = (SQUARE) j; <br>                MakeMoveNoKing_BLACK_JUMP0(b,best_move_number); <br>                if (0 != black_jump_lut[best_move_number][4] &amp;&amp; !(KING &amp; b[black_jump_lut[best_move_number][1]])) goto no_jump; <br>                break; <br> <br>            case TYPE_BLACK_JUMP2 : <br>                j = black_jump_lut[best_move_number][3]; <br>                piece_order[0].m = (SQUARE) j; <br>                MakeMoveNoKing_BLACK_JUMP2(b,best_move_number); <br>                if (0 != black_jump_lut[best_move_number][4] &amp;&amp; !(KING &amp; b[black_jump_lut[best_move_number][3]])) goto no_jump; <br>                break; <br> <br>            default: <br>                AssertSz(0, "end case"); <br>                break; <br>            } <br> <br>        /* ----- re-initialize ----- */ <br>        prune_size        =  1; /* ! force it to use only the jump destination as a move */ <br>        moves_made        =  0; <br>        best_move_type    = -1; <br>        best_move_number  = -1; <br>        best_move_quality = -1; <br> <br>        goto continue_jump; <br>        } <br>no_jump: <br> <br>    switch (best_move_type) <br>        { <br>        case TYPE_RED0        : <br>            MakeMove_RED0(b,best_move_number); <br>            break; <br> <br>        case TYPE_RED2        : <br>            MakeMove_RED2(b,best_move_number); <br>            break; <br> <br>        case TYPE_BLACK0      : <br>            MakeMove_BLACK0(b,best_move_number); <br>            break; <br> <br>        case TYPE_BLACK2      : <br>            MakeMove_BLACK2(b,best_move_number); <br>            break; <br> <br>        case TYPE_RED_JUMP0   : <br>        case TYPE_RED_JUMP2   : <br>        case TYPE_BLACK_JUMP0 : <br>        case TYPE_BLACK_JUMP2 : <br>            pdebug(stddbgmin,"skipping a jump move in IO %s(%d)\n",__FILE__,__LINE__); <br>            break; <br> <br>        default: <br>            pdebug(stddbgmin,"printmove did not make the move on the board %s(%d)\n",__FILE__,__LINE__); <br>            pdebug(stddbgmin,"this could be a jump continuation %s(%d)\n",__FILE__,__LINE__); <br>            break; <br>        } <br> <br>    // make sure everything is kinged (in case we jumped to this point) <br>    if (RED &amp; b[1]) b[1] |= KING; <br>    if (RED &amp; b[2]) b[2] |= KING; <br>    if (RED &amp; b[3]) b[3] |= KING; <br>    if (RED &amp; b[4]) b[4] |= KING; <br>    if (BLACK &amp; b[32]) b[32] |= KING; <br>    if (BLACK &amp; b[31]) b[31] |= KING; <br>    if (BLACK &amp; b[30]) b[30] |= KING; <br>    if (BLACK &amp; b[29]) b[29] |= KING; <br> <br>    /* ----- return to caller ----- */ <br>    return best_move_quality; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
