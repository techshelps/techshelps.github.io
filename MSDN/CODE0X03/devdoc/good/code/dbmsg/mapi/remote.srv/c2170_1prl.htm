<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RADMRPC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2181"></a>RADMRPC.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      RADMRPC.CPP <br>// <br>//  Description <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "_WINDS.H" <br>#include &lt;RPC.H&gt; <br>#include "WINDS.H"      // Header file generated by the MIDL compiler <br>#include "WDSADM.H"     // Header file generated by the MIDL compiler <br>#include "COMMON.H"     // For the transmition of the DL members list <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmGetServerMailboxes() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmGetServerMailboxes (long * pPipeNumber) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br> <br>    *pPipeNumber = GetNextPipeID(); <br> <br>    SECURITY_ATTRIBUTES sa; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    // Initialize the new security descriptor. <br>    InitializeSecurityDescriptor (&amp;sd, SECURITY_DESCRIPTOR_REVISION); <br> <br>    // Add a NULL descriptor ACL to the security descriptor. <br>    SetSecurityDescriptorDacl (&amp;sd, TRUE, (PACL)NULL, FALSE); <br> <br>    sa.nLength = sizeof(sa); <br>    sa.lpSecurityDescriptor = &amp;sd; <br>    sa.bInheritHandle = TRUE; <br> <br>    // Create a pipe where we will expect the transport to send the data <br>    TCHAR szPipeName[64]; <br>    wsprintf (szPipeName, SERVER_PIPE_NAME_FORMAT, *pPipeNumber); <br>    HANDLE hPipe; <br>    hPipe = CreateNamedPipe (szPipeName, <br>                             PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, <br>                             PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE, <br>                             1, <br>                             IO_BUFFERSIZE, <br>                             IO_BUFFERSIZE, <br>                             0, <br>                             &amp;sa); <br>    if (INVALID_HANDLE_VALUE == hPipe || ERROR_INVALID_PARAMETER == (DWORD)hPipe) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmGetServerMailboxes: Failed to create pipe", lResult); <br>        return lResult; <br>    } <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_ADMIN_GET_SERVER_MAILBOXES; <br>    g_IOInfo.hActionCompleted = NULL; <br>    g_IOInfo.phLastError      = NULL; <br>    g_IOInfo.hTmpFile         = hPipe; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmGetServerDistLists() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmGetServerDistLists (long * pPipeNumber) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br> <br>    *pPipeNumber = GetNextPipeID(); <br> <br>    SECURITY_ATTRIBUTES sa; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    // Initialize the new security descriptor. <br>    InitializeSecurityDescriptor (&amp;sd, SECURITY_DESCRIPTOR_REVISION); <br> <br>    // Add a NULL descriptor ACL to the security descriptor. <br>    SetSecurityDescriptorDacl (&amp;sd, TRUE, (PACL)NULL, FALSE); <br> <br>    sa.nLength = sizeof(sa); <br>    sa.lpSecurityDescriptor = &amp;sd; <br>    sa.bInheritHandle = TRUE; <br> <br>    TCHAR szPipeName[64]; <br>    wsprintf (szPipeName, SERVER_PIPE_NAME_FORMAT, *pPipeNumber); <br>    HANDLE hPipe; <br>    hPipe = CreateNamedPipe (szPipeName, <br>                             PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, <br>                             PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE, <br>                             1, <br>                             IO_BUFFERSIZE, <br>                             IO_BUFFERSIZE, <br>                             0, <br>                             &amp;sa); <br>    if (INVALID_HANDLE_VALUE == hPipe || ERROR_INVALID_PARAMETER == (DWORD)hPipe) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmGetServerDistLists: Failed to create pipe", lResult); <br>        return lResult; <br>    } <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_ADMIN_GET_SERVER_DISTLISTS; <br>    g_IOInfo.hActionCompleted = NULL; <br>    g_IOInfo.phLastError      = NULL; <br>    g_IOInfo.hTmpFile         = hPipe; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmIsServerRunning() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmIsServerRunning() <br>{ <br>    return GetServiceState(); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmCreateMailboxA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmCreateMailboxA (ADM_MAILBOX_INFO_A * pMailboxInfo) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    if (FALSE == GlobalObjectMap.IsAliasNameAvailable ((LPSTR)pMailboxInfo-&gt;szMailboxName)) <br>    { <br>        return HRESULT_FROM_WIN32(ERROR_USER_EXISTS); <br>    } <br>     <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmCreateMailboxA: Failed to create event for I/O thread", lResult); <br>        return lResult; <br>    } <br> <br>    MAILBOX_INFO_A MBInfo = { 0 }; <br>    CopyMemory (&amp;MBInfo, pMailboxInfo, sizeof(MAILBOX_INFO_A)); <br>     <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_CREATE_NEW_MAILBOX; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pMBInfo          = &amp;MBInfo; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>    if (lResult) <br>    { <br>        TraceResult ("RemoteAdmCreateMailboxA: Failed to create the mailbox", lResult); <br>        return lResult; <br>    } <br> <br>    GlobalObjectMap.Insert (MBInfo.dwObjID, MBInfo.szMailboxName, SERVER_USER_MAILBOX); <br> <br>    // Notify clients (i.e. address books) that a new mail user has been added <br>    PWINDS_NOTIFICATION pNotif = (PWINDS_NOTIFICATION)HeapAlloc (ghHeap, <br>                                                                 HEAP_ZERO_MEMORY, <br>                                                                 sizeof(WINDS_NOTIFICATION)); <br>    if (pNotif) <br>    { <br>        pNotif-&gt;Event = AB_USER_ADDED; <br>        CopyMemory (&amp;(pNotif-&gt;Info.MB), &amp;MBInfo, sizeof(MAILBOX_INFO)); <br>        NotifyClients (pNotif); // This will take care of freeing the notification structure <br>    } <br>    else <br>    { <br>        // This is non-fatal <br>        TraceResult ("RemoteAdmCreateMailboxA: Failed to allocate notification structure", E_OUTOFMEMORY); <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmDeleteObject() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmDeleteObject (unsigned long dwObjID) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br> <br>    TCHAR szObjAlias[MAX_ALIAS_SIZE+1]; <br>    WINDS_AB_OBJTYPE Type = UNDEFINED_OBJECT_TYPE; <br>    if (S_OK != GlobalObjectMap.FindObjFromID (dwObjID, szObjAlias, &amp;Type)) <br>    { <br>        return HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND); <br>    } <br> <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmDeleteObject: Failed to create event for I/O thread", lResult); <br>        return lResult; <br>    } <br>    MAILBOX_INFO MBInfo = { 0 }; <br>    DIST_LIST_INFO DLInfo = { 0 }; <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError = &amp;lResult; <br> <br>    if (SERVER_USER_MAILBOX == Type) <br>    { <br>        lstrcpy (MBInfo.szMailboxName, szObjAlias); <br>        g_IOInfo.Action = IO_REMOVE_MAILBOX; <br>        g_IOInfo.pMBInfo = &amp;MBInfo; // On return this will have all the mailbox properties <br>    } <br>    else <br>    { <br>        if (SERVER_DISTRIBUTION_LIST == Type) <br>        { <br>            lstrcpy (DLInfo.szDLAlias, szObjAlias); <br>            g_IOInfo.Action = IO_DELETE_DISTRIBUTION_LIST; <br>            g_IOInfo.pDLInfo = &amp;DLInfo; <br>        } <br>        else <br>        { <br>            TraceMessage ("RemoteAdmDeleteObject: Remove GATEWAY recipient NYI"); <br>        } <br>    } <br> <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br> <br>    if (lResult) <br>    { <br>        TraceResult ("RemoteAdmDeleteObject: Failed to delete the mailbox", lResult); <br>        return lResult; <br>    } <br> <br>    GlobalObjectMap.Delete (dwObjID); <br>    // Notify client address books that a mail user has been deleted <br>    PWINDS_NOTIFICATION pNotif = (PWINDS_NOTIFICATION)HeapAlloc (ghHeap, <br>                                                                 HEAP_ZERO_MEMORY, <br>                                                                 sizeof(WINDS_NOTIFICATION)); <br>    if (pNotif) <br>    { <br>        if (SERVER_USER_MAILBOX == Type) <br>        { <br>            pNotif-&gt;Event = AB_USER_DELETED; <br>            CopyMemory (&amp;(pNotif-&gt;Info.MB), &amp;MBInfo, sizeof(MAILBOX_INFO)); <br>        } <br>        else <br>        { <br>            if (SERVER_DISTRIBUTION_LIST == Type) <br>            { <br>                pNotif-&gt;Event = AB_DL_DELETED; <br>                CopyMemory (&amp;(pNotif-&gt;Info.DL), &amp;DLInfo, sizeof(DIST_LIST_INFO)); <br>            } <br>            else <br>            { <br>                // TODO: Implement this for gateways <br>            } <br>        } <br>        NotifyClients (pNotif); // This will take care of freeing the notification structure <br>    } <br>    else <br>    { <br>        // Non-fatal error <br>        TraceResult ("RemoteAdmDeleteObject: Failed to allocate notification structure", E_OUTOFMEMORY); <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmGetMailboxPropsA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmGetMailboxPropsA (unsigned long           dwObjID, <br>                                unsigned long *         pdwObjType, <br>                                ADM_MAILBOX_INFO_A *    pMailboxInfo) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    return GetObjectProp (dwObjID, pdwObjType, (MAILBOX_INFO*)pMailboxInfo); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmSetMailboxPropsA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmSetMailboxPropsA (ADM_MAILBOX_INFO_A * pMailboxInfo) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br> <br>    if (pMailboxInfo-&gt;dwObjID == 0) <br>    { <br>        TraceMessage ("RemoteAdmSetMailboxPropsA: Invoked with Object ID = 0, cannot accept"); <br>        return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_USER); <br>    } <br> <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmSetMailboxPropsA: Failed to create event for I/O thread", lResult); <br>        return lResult; <br>    } <br> <br>    MAILBOX_INFO_A MBInfo = { 0 }; <br>    CopyMemory (&amp;MBInfo, pMailboxInfo, sizeof(MAILBOX_INFO_A)); <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_SET_MAILBOX_PROPERTIES; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pMBInfo          = &amp;MBInfo; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>    if (!lResult) <br>    { <br>        // Notify client address books that a mail user has been modified <br>        PWINDS_NOTIFICATION pNotif = (PWINDS_NOTIFICATION)HeapAlloc (ghHeap, <br>                                                                     HEAP_ZERO_MEMORY, <br>                                                                     sizeof(WINDS_NOTIFICATION)); <br>        if (pNotif) <br>        { <br>            pNotif-&gt;Event = AB_USER_MODIFIED; <br>            CopyMemory (&amp;(pNotif-&gt;Info.MB), &amp;MBInfo, sizeof(MAILBOX_INFO)); <br>            NotifyClients (pNotif); // This will take care of freeing the notification structure <br>        } <br>        else <br>        { <br>            // This is non-fatal <br>            TraceResult ("RemoteAdmSetMailboxPropsA: Failed to allocate notification structure", E_OUTOFMEMORY); <br>        } <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmTerminateNotifA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmTerminateNotifA (unsigned char *   szComputerName, <br>                              unsigned long     ulConnectionID) <br>{ <br>    return RemoteTerminateNotifA (szComputerName, ulConnectionID); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmValidateNotifA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmValidateNotifA (unsigned char *    szComputerName, <br>                              unsigned long      ulNotifMask, <br>                              unsigned long *    pulConnectionID) <br>{ <br>    return RemoteValidateNotifA (szComputerName, <br>                                 (unsigned char *)"WINDS ADMIN", <br>                                 ulNotifMask, <br>                                 pulConnectionID); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmGetGALDirectory() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmGetGALDirectory (unsigned long dwFlags, long * pPipeNumber) <br>{ <br>    return RemoteGetContainerRecipients (dwFlags, GAL_CONTAINER_ID, pPipeNumber); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmEmptyMailbox() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmEmptyMailbox (unsigned long dwMailboxID) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br> <br>    TCHAR szObjAlias[MAX_ALIAS_SIZE+1]; <br>    WINDS_AB_OBJTYPE Type = UNDEFINED_OBJECT_TYPE; <br>    if (S_OK != GlobalObjectMap.FindObjFromID (dwMailboxID, szObjAlias, &amp;Type)) <br>    { <br>        return HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND); <br>    } <br>    if (SERVER_USER_MAILBOX != Type) <br>    { <br>        return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_USER); <br>    } <br> <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmEmptyMailbox: Failed to create event for I/O thread", lResult); <br>        return lResult; <br>    } <br>     <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    lstrcpy (g_IOInfo.szObject, szObjAlias); <br>    g_IOInfo.Action           = IO_EMPTY_MAILBOX; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br> <br>    TraceResult ("RemoteAdmEmptyMailbox", lResult); <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmGetDLPropsA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmGetDLPropsA (unsigned long        dwObjID, <br>                           unsigned char *      szDLAlias, <br>                           unsigned char *      szDLFullName, <br>                           unsigned long *      pdwFlags, <br>                           unsigned char *      szOwnerAlias, <br>                           unsigned char *      szOwnerName, <br>                           unsigned long *      pdwOwnerID, <br>                           unsigned char *      szComments, <br>                           DLM_XMIT_LIST_A *    pMembers) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br> <br>    if (0 == dwObjID) <br>    { <br>        TraceMessage ("RemoteAdmGetDLPropsA: Invoked with Object ID = 0, cannot accept"); <br>        return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_GROUP); <br>    } <br> <br>    DIST_LIST_INFO DLInfo = { 0 }; <br>    WINDS_AB_OBJTYPE Type = UNDEFINED_OBJECT_TYPE; <br>    if ((S_OK != GlobalObjectMap.FindObjFromID (dwObjID, DLInfo.szDLAlias, &amp;Type)) || <br>        (SERVER_DISTRIBUTION_LIST != Type)) <br>    { <br>        return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_GROUP); <br>    } <br> <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmGetDLPropsA: Failed to create event for I/O thread", lResult); <br>        return lResult; <br>    } <br>    DLInfo.pMembers = (LPVOID)pMembers; <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_GET_DL_PROPERTIES; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pDLInfo          = &amp;DLInfo; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>    if (!lResult) <br>    { <br>        lstrcpy ((LPSTR)szDLAlias, DLInfo.szDLAlias); <br>        lstrcpy ((LPSTR)szDLFullName, DLInfo.szDLFullName); <br>        *pdwFlags = DLInfo.dwFlags; <br>        lstrcpy ((LPSTR)szOwnerAlias, DLInfo.szOwnerAlias); <br>        lstrcpy ((LPSTR)szOwnerName, DLInfo.szOwnerName); <br>        *pdwOwnerID = DLInfo.dwOwnerID; <br>    } <br> <br>    TraceResult ("RemoteAdmGetDLPropsA", lResult); <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmSetDLPropsA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmSetDLPropsA (unsigned long        dwObjID, <br>                           unsigned char *      szDLAlias, <br>                           unsigned char *      szDLFullName, <br>                           unsigned long        dwFlags, <br>                           unsigned char *      szOwnerAlias, <br>                           unsigned char *      szOwnerName, <br>                           unsigned long        dwOwnerID, <br>                           unsigned char *      szComments, <br>                           DLM_XMIT_LIST_A *    pMembers) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    if (dwObjID == 0) <br>    { <br>        TraceMessage ("RemoteAdmSetDLPropsA: Invoked with Object ID = 0, cannot accept"); <br>        return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_GROUP); <br>    } <br> <br>    DIST_LIST_INFO DLInfo = { 0 }; <br>    lstrcpy (DLInfo.szDLAlias, (LPSTR)szDLAlias); <br>    lstrcpy (DLInfo.szDLFullName, (LPSTR)szDLFullName); <br>    DLInfo.dwObjID= dwObjID; <br>    DLInfo.dwFlags = dwFlags; <br>    lstrcpy (DLInfo.szOwnerAlias, (LPSTR)szOwnerAlias); <br>    lstrcpy (DLInfo.szOwnerName, (LPSTR)szOwnerName); <br>    DLInfo.dwOwnerID = dwOwnerID; <br>    DLInfo.pMembers = (LPVOID)pMembers; <br> <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmSetDLPropsA: Failed to create event for I/O thread", lResult); <br>        return lResult; <br>    } <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_SET_DL_PROPERTIES; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pDLInfo          = &amp;DLInfo; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br> <br>    if (!lResult) <br>    { <br>        PWINDS_NOTIFICATION pNotif = (PWINDS_NOTIFICATION)HeapAlloc (ghHeap, <br>                                                                     HEAP_ZERO_MEMORY, <br>                                                                     sizeof(WINDS_NOTIFICATION)); <br>        if (pNotif) <br>        { <br>            pNotif-&gt;Event = AB_DL_MODIFIED; <br>            CopyMemory (&amp;(pNotif-&gt;Info.DL), &amp;DLInfo, sizeof(DIST_LIST_INFO)); <br>            NotifyClients (pNotif); // This will take care of freeing the notification structure <br>        } <br>        else <br>        { <br>            // This is non-fatal <br>            TraceResult ("RemoteAdmSetDLPropsA: Failed to allocate the notification structure", E_OUTOFMEMORY); <br>        } <br>    } <br>    TraceResult ("RemoteAdmSetDLPropsA", lResult); <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteAdmCreateDistListA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteAdmCreateDistListA (unsigned char *   szDLAlias, <br>                               unsigned char *   szDLFullName, <br>                               unsigned long     dwFlags, <br>                               unsigned char *   szOwnerAlias, <br>                               unsigned char *   szOwnerName, <br>                               unsigned long     dwOwnerID, <br>                               DLM_XMIT_LIST_A * pMembers) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    if (FALSE == GlobalObjectMap.IsAliasNameAvailable ((LPSTR)szDLAlias)) <br>    { <br>        return HRESULT_FROM_WIN32(ERROR_GROUP_EXISTS); <br>    } <br>     <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteAdmCreateDistListA: Failed to create event for I/O thread", lResult); <br>        return lResult; <br>    } <br> <br>    DIST_LIST_INFO DLInfo = { 0 }; <br>    lstrcpy (DLInfo.szDLAlias, (LPSTR)szDLAlias); <br>    lstrcpy (DLInfo.szDLFullName, (LPSTR)szDLFullName); <br>    DLInfo.dwFlags = dwFlags; <br> <br>    lstrcpy (DLInfo.szOwnerAlias, (LPSTR)szOwnerAlias); <br>    lstrcpy (DLInfo.szOwnerName, (LPSTR)szOwnerName); <br>    DLInfo.dwOwnerID = dwOwnerID; <br>    if (pMembers-&gt;Info.szMemberName[0]) <br>    { <br>        DLInfo.pMembers = (LPVOID)pMembers; <br>    } <br>    else <br>    { <br>        DLInfo.pMembers = NULL; <br>    } <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_CREATE_DISTRIBUTION_LIST; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pDLInfo          = &amp;DLInfo; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>     <br>    if (lResult) <br>    { <br>        TraceResult ("RemoteAdmCreateDistListA", lResult); <br>        return lResult; <br>    } <br> <br>    GlobalObjectMap.Insert (DLInfo.dwObjID, DLInfo.szDLAlias, SERVER_DISTRIBUTION_LIST); <br> <br>    // Notify client address books that a distribution list has been added <br>    PWINDS_NOTIFICATION pNotif = (PWINDS_NOTIFICATION)HeapAlloc (ghHeap, <br>                                                                 HEAP_ZERO_MEMORY, <br>                                                                 sizeof(WINDS_NOTIFICATION)); <br>    if (pNotif) <br>    { <br>        pNotif-&gt;Event = AB_DL_ADDED; <br>        CopyMemory (&amp;(pNotif-&gt;Info.DL), &amp;DLInfo, sizeof(DIST_LIST_INFO)); <br>        NotifyClients (pNotif); // This will take care of freeing the notification structure <br>    } <br>    else <br>    { <br>        // This is non-fatal <br>        TraceResult ("RemoteAdmCreateDistListA: Failed to allocate the notification structure", E_OUTOFMEMORY); <br>    } <br>    return lResult; <br>} <br> <br>// The UNICODE version of these function, has not been implemented yet. <br>long RemoteAdmTerminateNotifW (wchar_t *        szComputerName, <br>                               unsigned long    ulConnectionID) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteAdmValidateNotifW (wchar_t *         szComputerName, <br>                              unsigned long     ulNotifMask, <br>                              unsigned long *   pulConnectionID) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteAdmCreateMailboxW (ADM_MAILBOX_INFO_W * pMailboxInfo) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteAdmGetMailboxPropsW (unsigned long        dwObjID, <br>                                unsigned long *      pdwUserType, <br>                                ADM_MAILBOX_INFO_W * pMailboxInfo) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteAdmSetMailboxPropsW (ADM_MAILBOX_INFO_W * pMailboxInfo) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteAdmCreateDistListW (wchar_t *         szDLAlias, <br>                               wchar_t *         szDLFullName, <br>                               unsigned long     dwFlags, <br>                               wchar_t *         szOwnerAlias, <br>                               wchar_t *         szOwnerName, <br>                               unsigned long     dwOwnerID, <br>                               DLM_XMIT_LIST_W * pMembers) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteAdmGetDLPropsW (unsigned long        dwObjID, <br>                           wchar_t *            szDLAlias, <br>                           wchar_t *            szDLFullName, <br>                           unsigned long *      pdwFlags, <br>                           wchar_t *            szOwnerAlias, <br>                           wchar_t *            szOwnerName, <br>                           unsigned long *      pdwOwnerID, <br>                           wchar_t *            szComments, <br>                           DLM_XMIT_LIST_W *    pMembers) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteAdmSetDLPropsW (unsigned long        dwObjID, <br>                           wchar_t *            szDLAlias, <br>                           wchar_t *            szDLFullName, <br>                           unsigned long        dwFlags, <br>                           wchar_t *            szOwnerAlias, <br>                           wchar_t *            szOwnerName, <br>                           unsigned long        dwOwnerID, <br>                           wchar_t *            szComments, <br>                           DLM_XMIT_LIST_W *    pMembers) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>// End of file for RADMRPC.CPP <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
