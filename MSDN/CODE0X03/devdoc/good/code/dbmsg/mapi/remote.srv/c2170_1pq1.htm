<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NOTIFY.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2179"></a>NOTIFY.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      NOTIFY.CPP <br>// <br>//  Description <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "_WINDS.H" <br>#include &lt;RPC.H&gt; <br>#include "WINDS.H"     // Header file generated by the MIDL compiler <br> <br>typedef struct _WINDS_NOTIF_CLIENT <br>{ <br>    struct _WINDS_NOTIF_CLIENT *    pNext; <br>    TCHAR                           szComputerName[MAX_COMPUTERNAME_LENGTH + 1]; <br>    TCHAR                           szObjectName[MAX_ALIAS_SIZE+1]; <br>    DWORD                           dwFlags; <br>    DWORD                           dwNotifMask; <br>} WINDS_NOTIF_CLIENT, *PWINDS_NOTIF_CLIENT; <br> <br>PWINDS_NOTIF_CLIENT gpNotifLinks = NULL; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteLogonMailBoxAndSetNotifA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteLogonMailBoxAndSetNotifA (unsigned char *    szMailbox, <br>                                     unsigned char *    szPassword, <br>                                     unsigned char *    szFullName, <br>                                     unsigned long *    pdwMailboxID, <br>                                     unsigned char *    szComputerName, <br>                                     unsigned long      ulNotifMask, <br>                                     unsigned long *    pulConnectionID) <br>{ <br>    long lResult = RemoteLogonMailBoxA (szMailbox, szPassword, szFullName, pdwMailboxID); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    RemoteValidateNotifA (szComputerName, szMailbox, ulNotifMask, pulConnectionID); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteValidateNotifA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteValidateNotifA (unsigned char *  szComputerName, <br>                           unsigned char *  szMailbox, <br>                           unsigned long    ulNotifMask, <br>                           unsigned long *  pulConnectionID) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    PWINDS_NOTIF_CLIENT pNode, pNewNode = (PWINDS_NOTIF_CLIENT)HeapAlloc (ghHeap, <br>                                                                          HEAP_ZERO_MEMORY, <br>                                                                          sizeof(WINDS_NOTIF_CLIENT)); <br>    if (pNewNode) <br>    { <br>        pNewNode-&gt;dwNotifMask = ulNotifMask; <br>        lstrcpy (pNewNode-&gt;szComputerName, (LPSTR)szComputerName); <br>        lstrcpy (pNewNode-&gt;szObjectName, (LPSTR)szMailbox); <br>         <br>        EnterCriticalSection (&amp;g_csNotifLinks); <br>        if (gpNotifLinks) <br>        { <br>            pNode = gpNotifLinks; <br>            while (pNode) <br>            { <br>                if (NULL == pNode-&gt;pNext) <br>                { <br>                    pNode-&gt;pNext = pNewNode; <br>                    break; // Out of the WHILE() loop <br>                } <br>                pNode = pNode-&gt;pNext; <br>            } <br>        } <br>        else <br>        { <br>            gpNotifLinks = pNewNode; <br>        } <br>        LeaveCriticalSection (&amp;g_csNotifLinks); <br> <br>        *pulConnectionID = (unsigned long)pNewNode; <br>    } <br>    TraceMessageIf ("RemoteValidateNotifA: Failed to allocated new node", 0 == *pulConnectionID); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteTerminateNotifA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteTerminateNotifA (unsigned char * szComputerName, <br>                            unsigned long ulConnectionID) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br> <br>    long cbSize = lstrlen ((LPSTR)szComputerName); <br>    EnterCriticalSection (&amp;g_csNotifLinks); <br>    PWINDS_NOTIF_CLIENT pNext, pPrev = NULL, pNode = gpNotifLinks; <br>    while (pNode) <br>    { <br>        if (ulConnectionID == (unsigned long)pNode &amp;&amp; (0 == memcmp (pNode-&gt;szComputerName, szComputerName, cbSize))) <br>        { <br>            // If the node is the head of the list, make the head point to the next node <br>            if (gpNotifLinks == pNode) <br>            { <br>                gpNotifLinks = gpNotifLinks-&gt;pNext; <br>            } <br>            // Save the next pointer so that we may delete the current node <br>            pNext = pNode-&gt;pNext; <br>            HeapFree (ghHeap, 0, pNode); <br>            // If we have a previous node, we are doing a delete in the middle of a single link list <br>            if (pPrev) <br>            { <br>                pPrev-&gt;pNext = pNext; <br>            } <br>            break; // Out of the WHILE() loop <br>        } <br>        else <br>        { <br>            // Don't delete this node, save is as the "previous" node in the linear list <br>            pPrev = pNode; <br>            pNode = pNode-&gt;pNext; <br>        } <br>    } <br>    LeaveCriticalSection (&amp;g_csNotifLinks); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoveAllNotifLinks() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI RemoveAllNotifLinks() <br>{ <br>    EnterCriticalSection (&amp;g_csNotifLinks); <br>    PWINDS_NOTIF_CLIENT pNode = gpNotifLinks; <br>    while (gpNotifLinks) <br>    { <br>        pNode = gpNotifLinks-&gt;pNext; <br>        HeapFree (ghHeap, 0, gpNotifLinks); <br>        gpNotifLinks = pNode; <br>    } <br>    gpNotifLinks = NULL; <br>    LeaveCriticalSection (&amp;g_csNotifLinks); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    NotifyClients() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI NotifyClients (PWINDS_NOTIFICATION pNotif) <br>{ <br>    DWORD dwThreadID; <br>    HANDLE hThread = CreateThread (NULL, <br>                                   0, <br>                                   (LPTHREAD_START_ROUTINE)ClientNotifThreadProc, <br>                                   (LPVOID)pNotif, <br>                                   CREATE_SUSPENDED, <br>                                   &amp;dwThreadID); <br>    if (hThread) <br>    { <br>        TraceDebugger ("NotifyClients: Notif dispatcher thread spawned. ID: %X", dwThreadID); <br>        ResumeThread (hThread); <br>        CloseHandle (hThread); <br>    } <br>    else <br>    { <br>        TraceResult ("NotifyClients: Failed to create notification dispatching thread", HRESULT_FROM_WIN32(GetLastError())); <br>        HeapFree (ghHeap, 0, pNotif); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ClientNotifThreadProc() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      None. <br>// <br>DWORD WINAPI ClientNotifThreadProc (PWINDS_NOTIFICATION pNotif) <br>{ <br>    TCHAR szTargetMailslot[MAX_PATH] = { 0 }; <br>    DWORD dwWritten, dwNotifEvent = 0; <br>    HANDLE hClientMailSlot; <br>    LPTSTR szMailSlotSink = NULL; <br> <br>    SYSTEMTIME st; <br>    GetSystemTime (&amp;st); <br>    SystemTimeToFileTime (&amp;st, &amp;(pNotif-&gt;ftEventTime)); <br> <br>    if (pNotif-&gt;Event &gt;= AB_NOTIF_MIN  &amp;&amp; pNotif-&gt;Event &lt;= AB_NOTIF_MAX) <br>    { <br>        dwNotifEvent = WINDS_NOTIF_ON_AB | WINDS_NOTIF_ON_USER; <br>        szMailSlotSink = AB_WINDS_NOTIFICATION_MAILSLOT; <br>    } <br>    else <br>    { <br>        if (pNotif-&gt;Event &gt;= XP_NOTIF_MIN  &amp;&amp; pNotif-&gt;Event &lt;= XP_NOTIF_MAX) <br>        { <br>            dwNotifEvent = WINDS_NOTIF_ON_XP; <br>            szMailSlotSink = XP_WINDS_NOTIFICATION_MAILSLOT; <br>        } <br>        else <br>        { <br>            if (pNotif-&gt;Event &gt;= MS_NOTIF_MIN  &amp;&amp; pNotif-&gt;Event &lt;= MS_NOTIF_MAX) <br>            { <br>                dwNotifEvent = WINDS_NOTIF_ON_MS; <br>                szMailSlotSink = MS_WINDS_NOTIFICATION_MAILSLOT; <br>            } <br>            else <br>            { <br>                if (pNotif-&gt;Event &gt;= GENERAL_NOTIF_MIN  &amp;&amp; pNotif-&gt;Event &lt;= GENERAL_NOTIF_MAX) <br>                { <br>                    dwNotifEvent = WINDS_NOTIF_ON_USER; <br>                } <br>            } <br>        } <br>    } <br> <br>    EnterCriticalSection (&amp;g_csNotifLinks); <br>    PWINDS_NOTIF_CLIENT pNode = gpNotifLinks; <br>    while (pNode) <br>    { <br>        if (dwNotifEvent &amp; pNode-&gt;dwNotifMask) <br>        { <br>            if (WINDS_NOTIF_ON_USER &amp; dwNotifEvent) <br>            { <br>                if (WINDS_NOTIF_ON_AB &amp; pNode-&gt;dwNotifMask) <br>                { <br>                    szMailSlotSink = AB_WINDS_NOTIFICATION_MAILSLOT; <br>                } <br>                else <br>                { <br>                    if (WINDS_NOTIF_ON_XP &amp; pNode-&gt;dwNotifMask) <br>                    { <br>                        szMailSlotSink = XP_WINDS_NOTIFICATION_MAILSLOT; <br>                    } <br>                    else <br>                    { <br>                        szMailSlotSink = MS_WINDS_NOTIFICATION_MAILSLOT; <br>                    } <br>                } <br>            } <br>            if (WINDS_NOTIF_ON_XP == dwNotifEvent &amp;&amp; XP_NEW_MAIL_ARRIVED == pNotif-&gt;Event) <br>            { <br>                if (lstrcmpi (pNode-&gt;szObjectName, pNotif-&gt;Info.MB.szMailboxName)) <br>                { <br>                    goto NextNode; <br>                } <br>            } <br>            if (WINDS_ADMINISTRATOR &amp; pNode-&gt;dwNotifMask) <br>            { <br>                szMailSlotSink = ADMIN_WINDS_NOTIFICATION_MAILSLOT; <br>            } <br>            wsprintf (szTargetMailslot, <br>                      SERVER_MAILSLOT_SINK_NAME_FORMAT, <br>                      pNode-&gt;szComputerName, <br>                      szMailSlotSink, <br>                      pNode); // the connection number is the pointer address in the server side (this is unique within a given process) <br> <br>            hClientMailSlot = CreateFile (szTargetMailslot, <br>                                          GENERIC_WRITE, <br>                                          FILE_SHARE_READ, <br>                                          NULL, <br>                                          OPEN_EXISTING, <br>                                          FILE_ATTRIBUTE_NORMAL, <br>                                          NULL);  <br>            if (INVALID_HANDLE_VALUE == hClientMailSlot) <br>            { <br>                TraceResult ("ClientNotifThreadProc: Failed to open client mailslot", HRESULT_FROM_WIN32(GetLastError())); <br>            } <br>            else <br>            { <br>                if (!WriteFile (hClientMailSlot, pNotif, sizeof(WINDS_NOTIFICATION), &amp;dwWritten, NULL)) <br>                { <br>                    TraceResult ("ClientNotifThreadProc: Failed to write to the client mailslot", HRESULT_FROM_WIN32(GetLastError())); <br>                } <br>                CloseHandle (hClientMailSlot);  <br>            } <br>        } <br>NextNode: <br>        pNode = pNode-&gt;pNext; <br>    } <br> <br>#define CLIENTS_NOTIF_CACHE_FILE    TEXT("WINDS Service - Last Session Clients.WINDS") <br>    if (SERVER_IS_SHUTTING_DOWN == pNotif-&gt;Event &amp;&amp; gpNotifLinks) <br>    { <br>        DWORD dwBytesWritten; <br>        WINDS_NOTIF_CLIENT tmpNode; <br>        HANDLE hFile = CreateFile (CLIENTS_NOTIF_CACHE_FILE, <br>                                   GENERIC_WRITE, <br>                                   0, <br>                                   NULL, <br>                                   CREATE_ALWAYS, <br>                                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, <br>                                   NULL); <br>        if (INVALID_HANDLE_VALUE == hFile) <br>        { <br>            TraceResult ("ClientNotifThreadProc: Failed to create clients cache file", HRESULT_FROM_WIN32(GetLastError())); <br>        } <br>        else <br>        { <br>            pNode = gpNotifLinks; <br>            while (pNode) <br>            { <br>                tmpNode = *pNode; <br>                tmpNode.pNext = pNode; <br>                // This is so that the node address gets written to the disk. This is the <br>                // connection number and the name of the mailslot in the client side. <br>                WriteFile (hFile, &amp;tmpNode, sizeof(WINDS_NOTIF_CLIENT), &amp;dwBytesWritten, NULL); <br>                pNode = pNode-&gt;pNext; <br>            } <br>        } <br>    } <br>    if (SERVER_HAS_RESTARTED == pNotif-&gt;Event) <br>    { <br>        DWORD dwBytesRead; <br>        WINDS_NOTIF_CLIENT tmpNode = { 0 }; <br>        HANDLE hFile = CreateFile (CLIENTS_NOTIF_CACHE_FILE, <br>                                   GENERIC_READ, <br>                                   0, <br>                                   NULL, <br>                                   OPEN_EXISTING, <br>                                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_DELETE_ON_CLOSE, <br>                                   NULL); <br>        if (INVALID_HANDLE_VALUE != hFile) <br>        { <br>            do <br>            { <br>                if (TRUE == ReadFile (hFile, &amp;tmpNode, sizeof(WINDS_NOTIF_CLIENT), &amp;dwBytesRead, NULL)) <br>                { <br>                    if (WINDS_NOTIF_ON_AB &amp; tmpNode.dwNotifMask) <br>                    { <br>                        szMailSlotSink = AB_WINDS_NOTIFICATION_MAILSLOT; <br>                    } <br>                    else <br>                    { <br>                        if (WINDS_NOTIF_ON_XP &amp; tmpNode.dwNotifMask) <br>                        { <br>                            szMailSlotSink = XP_WINDS_NOTIFICATION_MAILSLOT; <br>                        } <br>                        else <br>                        { <br>                            szMailSlotSink = MS_WINDS_NOTIFICATION_MAILSLOT; <br>                        } <br>                    } <br>                    if (WINDS_ADMINISTRATOR &amp; tmpNode.dwNotifMask) <br>                    { <br>                        szMailSlotSink = ADMIN_WINDS_NOTIFICATION_MAILSLOT; <br>                    } <br>                    wsprintf (szTargetMailslot, <br>                              SERVER_MAILSLOT_SINK_NAME_FORMAT, <br>                              tmpNode.szComputerName, <br>                              szMailSlotSink, <br>                              tmpNode.pNext); // The connection number is the pointer address in the server side (this is unique within a process address space) <br>                    hClientMailSlot = CreateFile (szTargetMailslot, <br>                                                  GENERIC_WRITE, <br>                                                  FILE_SHARE_READ, <br>                                                  NULL, <br>                                                  OPEN_EXISTING, <br>                                                  FILE_ATTRIBUTE_NORMAL, <br>                                                  NULL);  <br>                    if (INVALID_HANDLE_VALUE != hClientMailSlot) <br>                    { <br>                        pNotif-&gt;Event = SERVER_HAS_RESTARTED; <br>                        pNotif-&gt;ftEventTime.dwLowDateTime++; <br>                        pNotif-&gt;ftEventTime.dwHighDateTime++; <br>                        WriteFile (hClientMailSlot, pNotif, sizeof(WINDS_NOTIFICATION), &amp;dwWritten, NULL); <br>                        pNotif-&gt;Event = RESET_LINKS_WITH_SERVER; <br>                        pNotif-&gt;ftEventTime.dwLowDateTime++; <br>                        pNotif-&gt;ftEventTime.dwHighDateTime++; <br>                        WriteFile (hClientMailSlot, pNotif, sizeof(WINDS_NOTIFICATION), &amp;dwWritten, NULL); <br>                        CloseHandle (hClientMailSlot); <br>                    } <br>                } <br>            } while (dwBytesRead); <br>            CloseHandle (hFile); <br>        } <br>    } <br> <br>    LeaveCriticalSection (&amp;g_csNotifLinks); <br>    HeapFree (ghHeap, 0, pNotif); <br>    return S_OK; <br>} <br> <br>// End of file for NOTIFY.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
