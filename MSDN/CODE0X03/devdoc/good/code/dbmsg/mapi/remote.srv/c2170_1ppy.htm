<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADMNOTIF.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2176"></a>ADMNOTIF.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      ADMNOTIF.CPP <br>// <br>//  Description <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "ADMIN.H" <br> <br>// Remark this line to turn verbose tracing OFF <br>//#define DO_INFO_TRACES <br>#ifdef DO_INFO_TRACES <br>#define InfoTrace(a)        TraceInfoMessage(a) <br>#else <br>#define InfoTrace(a)        0 <br>#endif // DO_INFO_TRACES <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    BindToServer() <br>// <br>//    Parameters <br>//      [IN]    szServer   Name of the remote server to which we will bind <br>//                         for RPC calls. If this pointer is NULL, we <br>//                         unbind from that server. <br>// <br>//    Purpose <br>//      This function makes the necessary calls to the RPC runtime library <br>//      to bind to the remote server so that we can start RPC function calls. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI BindToServer (LPTSTR szServer) <br>{ <br>    static TCHAR szLastServer[64] = { 0 }; <br>    static TCHAR * szStringBinding = NULL; <br>     <br>    // If a server name was given, we compare to the current server that we are <br>    // already bounded to. If we are connected return the call. <br>    if (szServer) <br>    { <br>        if (0 == lstrcmpi (szLastServer, szServer)) <br>        { <br>            if (szStringBinding) <br>            { <br>                return 0; <br>            } <br>        } <br>        else <br>        { <br>            // Save the name of the server in the static buffer <br>            lstrcpy (szLastServer, szServer); <br>        } <br>    } <br> <br>    RPC_STATUS status = 0; <br>    if (szStringBinding) // Unbind only if bound <br>    { <br>        status = RpcStringFree ((WINDS_RPC_STRING*)&amp;szStringBinding); <br>        if (!status) <br>        { <br>            szStringBinding = NULL; <br>            status = RpcBindingFree (&amp;hWINDSADM);  // hWINDSADM is defined in WDSADM.H and WDSADM.ACF <br>        } <br>        if (status) <br>        { <br>            status = MAKE_HRESULT(1, FACILITY_RPC, status); <br>            TraceResult ("BindToServer: Failed to free the binding", status); <br>        } <br>    } <br>    // If this is NULL, then we don't need to bind to anything. <br>    if (!szServer) <br>    { <br>        szLastServer[0] = 0; <br>        return S_OK; <br>    } <br>    if (!status) <br>    { <br>        status = RpcStringBindingCompose (NULL, <br>                                          (WINDS_RPC_STRING)WINDS_RPC_PROTOCOL, <br>                                          (WINDS_RPC_STRING)szServer, <br>                                          (WINDS_RPC_STRING)WINDS_ADMIN_RPC_ENDPOINT, <br>                                          NULL, <br>                                          (WINDS_RPC_STRING*)&amp;szStringBinding); <br>        if (!status) <br>        { <br>            status = RpcBindingFromStringBinding ((WINDS_RPC_STRING)szStringBinding, &amp;hWINDSADM); // hWINDSADM is defined in WDSADM.H and WDSADM.ACF <br>        } <br>    } <br>    if (status) <br>    { <br>        szLastServer[0] = 0; <br>        status = MAKE_HRESULT(1, FACILITY_RPC, status); <br>        TraceResult ("BindToServer: Failed to create remote server binding handle", status); <br>    } <br>    return status; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CNotifLink::CNotifLink() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>CNotifLink::CNotifLink() <br>{ <br>    m_hMailSlot = NULL; <br>    m_ulConnectionID = 0; <br>    ZeroMemory (m_szComputerName, sizeof(m_szComputerName)); <br>    DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH + 1; <br>    GetComputerName (m_szComputerName, &amp;dwNameSize); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CNotifLink::~CNotifLink() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>CNotifLink::~CNotifLink() <br>{ <br>    EndNotifications(); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CNotifLink::EndNotifications() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>STDMETHODIMP CNotifLink::EndNotifications() <br>{ <br>    if (0 == m_ulConnectionID) <br>    { <br>        ASSERT (NULL == m_hMailSlot); <br>        return S_OK; <br>    } <br>    CloseHandle (m_hMailSlot); <br>    m_hMailSlot = NULL; <br>    HRESULT hResult; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteAdmTerminateNotif ((WINDS_RPC_STRING)m_szComputerName, m_ulConnectionID); <br>    } <br>    RpcExcept(1) <br>    { <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    m_ulConnectionID = 0; <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CNotifLink::StartNotification() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>STDMETHODIMP CNotifLink::StartNotification() <br>{ <br>    if (0 != m_ulConnectionID) <br>    { <br>        return S_OK; <br>    } <br>    DWORD dwThreadID, dwFlags = WINDS_ADMINISTRATOR | <br>                                WINDS_NOTIF_ON_USER | <br>                                WINDS_NOTIF_ON_AB | <br>                                WINDS_NOTIF_ON_MS; <br>#ifdef UNICODE <br>    dwFlags |= WINDS_UNICODE; <br>#endif // UNICODE <br> <br>    HANDLE hThread; <br>    TCHAR szMailslotName[64]; <br>    HRESULT hResult = S_OK; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteAdmValidateNotif ((WINDS_RPC_STRING)m_szComputerName, <br>                                          dwFlags, <br>                                          &amp;m_ulConnectionID); <br>    } <br>    RpcExcept(1) <br>    { <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    if (!hResult) <br>    { <br>        wsprintf (szMailslotName, <br>                  CLIENT_MAILSLOT_SINK_NAME_FORMAT, <br>                  ADMIN_WINDS_NOTIFICATION_MAILSLOT, <br>                  m_ulConnectionID); <br>        m_hMailSlot = CreateMailslot (szMailslotName, 0, MAILSLOT_WAIT_FOREVER, NULL); <br>        if (INVALID_HANDLE_VALUE == m_hMailSlot) <br>        { <br>            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        } <br>        else <br>        { <br>            hThread = CreateThread (NULL, <br>                                    0, <br>                                    (LPTHREAD_START_ROUTINE)MailslotListenThreadProc, <br>                                    (LPVOID)this, <br>                                    CREATE_SUSPENDED, <br>                                    &amp;dwThreadID); <br>            if (hThread) <br>            { <br>                SetThreadPriority (hThread, THREAD_PRIORITY_LOWEST); <br>                ResumeThread (hThread); <br>                CloseHandle (hThread); <br>            } <br>            else <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                CloseHandle (m_hMailSlot); <br>            } <br>        } <br>        if (hResult) <br>        { <br>            EndNotifications(); <br>        } <br>    } <br>    TraceResult ("CNotifLink::StartNotification", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MailslotListenThreadProc() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//      This is function runs in a separate low priority thread listening for <br>//      notification that a WINDS server sends.. When a <br>//      notification of interest is received, an appropiate action is taken. <br>//      The notification arrive on a mailslot created by the logon object. <br>// <br>//    Return Value <br>//      S_OK always. <br>// <br>DWORD WINAPI MailslotListenThreadProc (CNotifLink * pLink) <br>{ <br>    TCHAR szBuffer[256] = { 0 }; <br>    LV_FINDINFO lfi = { 0 }; <br>    LV_ITEM lvi = { 0 }; <br>     <br>    HANDLE hMailslot = pLink-&gt;GetListenMailslot(); <br>    DWORD dwRead; <br>    FILETIME ftLastNotifTime = { 0 }; <br>    WINDS_NOTIF_EVENT LastEvent; <br>    WINDS_NOTIFICATION Notif; <br>    HRESULT hReadError; <br>    while (TRUE) <br>    { <br>        if (!ReadFile (hMailslot, &amp;Notif, sizeof(WINDS_NOTIFICATION), &amp;dwRead, NULL))  <br>        {  <br>            hReadError = HRESULT_FROM_WIN32 (GetLastError()); <br>            if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hReadError || <br>                HRESULT_FROM_WIN32(ERROR_HANDLE_EOF) == hReadError) <br>            { <br>                break; // out of the WHILE() loop and terminate the thread <br>            } <br>            TraceResult ("MailslotListenThreadProc: ReadFile", HRESULT_FROM_WIN32(GetLastError())); <br>            continue; <br>        } <br>        // Mailslot are received in each network protocol stack installed on the system. <br>        // Check the time stamp and event of the last notification received. If it <br>        // is the same, drop it and continue listen for new and different incoming <br>        // data on the mailslot. <br>        if (ftLastNotifTime.dwLowDateTime  == Notif.ftEventTime.dwLowDateTime &amp;&amp; <br>            ftLastNotifTime.dwHighDateTime == Notif.ftEventTime.dwHighDateTime &amp;&amp; <br>            LastEvent                      == Notif.Event) <br>        { <br>            continue; <br>        } <br>        // Save the last event information <br>        ftLastNotifTime = Notif.ftEventTime; <br>        LastEvent = Notif.Event; <br> <br>        #ifdef DO_INFO_TRACES <br>        switch (Notif.Event) <br>        { <br>            case AB_USER_ADDED : <br>                InfoTrace ("AB_USER_ADDED notification received from the WINDS server"); <br>                break; <br>            case AB_USER_MODIFIED : <br>                InfoTrace ("AB_USER_MODIFIED notification received from the WINDS server"); <br>                break; <br>            case AB_USER_DELETED : <br>                InfoTrace ("AB_USER_DELETED notification received from the WINDS server"); <br>                break; <br>            case AB_DL_ADDED : <br>                InfoTrace ("AB_DL_ADDED notification received from the WINDS server"); <br>                break; <br>            case AB_DL_MODIFIED : <br>                InfoTrace ("AB_DL_MODIFIED notification received from the WINDS server"); <br>                break; <br>            case AB_DL_DELETED : <br>                InfoTrace ("AB_DL_DELETED notification received from the WINDS server"); <br>                break; <br>            case MS_MESSAGE_ADDED : <br>            case MS_MESSAGE_MODIFIED : <br>            case MS_MESSAGE_DELETED : <br>            case MS_FOLDER_ADDED : <br>            case MS_FOLDER_MODIFIED : <br>            case MS_FOLDER_DELETED : <br>                break; <br>            case SERVER_IS_SHUTTING_DOWN : <br>                InfoTrace ("SERVER_IS_SHUTTING_DOWN notification received from the WINDS server"); <br>                break; <br>            case RESET_LINKS_WITH_SERVER : <br>                InfoTrace ("RESET_LINKS_WITH_SERVER notification received from the WINDS server"); <br>                break; <br>            case SERVER_HAS_RESTARTED : <br>                InfoTrace ("SERVER_HAS_RESTARTED notification received from the WINDS server"); <br>                break; <br>            case AB_GET_LOCAL_ABDATA_NOW : <br>                InfoTrace ("AB_GET_LOCAL_ABDATA_NOW notification received from the WINDS server"); <br>                break; <br>            default : <br>                InfoTrace ("UNKNOWN notification received from the WINDS server"); <br>                break; <br>        } <br>        #endif // DO_INFO_TRACES <br> <br>        switch (Notif.Event) <br>        { <br>            case AB_USER_ADDED : <br>            case AB_DL_ADDED : <br>                { <br>                    if (AB_USER_ADDED == Notif.Event) <br>                    { <br>                        if (ITEM_SERVER_USER_MAILBOXES != g_LVItemsType) <br>                        { <br>                            break; <br>                        } <br>                    } <br>                    else <br>                    { <br>                        if (ITEM_SERVER_DIST_LISTS != g_LVItemsType) <br>                        { <br>                            break; <br>                        } <br>                    } <br> <br>                    int iNewItem = ListView_GetItemCount (ghListView); <br>                    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br>                    lvi.iItem = iNewItem; <br>                    lvi.iSubItem = 0; <br>                    if (AB_USER_ADDED == Notif.Event) <br>                    { <br>                         <br>                        lvi.pszText = Notif.Info.MB.szMailboxName; <br>                        lvi.lParam = Notif.Info.MB.dwObjID; <br>                        lvi.iImage = IMG_USER_MAILBOX; <br>                    } <br>                    else <br>                    { <br>                        lvi.pszText = Notif.Info.DL.szDLAlias; <br>                        lvi.lParam = Notif.Info.DL.dwObjID; <br>                        lvi.iImage = IMG_DIST_LIST; <br>                    } <br>                    lvi.iItem = ListView_InsertItem (ghListView, &amp;lvi); <br>                    if (AB_USER_ADDED == Notif.Event) <br>                    { <br>                        ListView_SetItemText (ghListView, lvi.iItem, 1, Notif.Info.MB.szFullName); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 2, Notif.Info.MB.szJobTitle); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 3, Notif.Info.MB.szOffice); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 4, Notif.Info.MB.szPhone); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 5, Notif.Info.MB.szAltPhone); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 6, Notif.Info.MB.szFax); <br>                    } <br>                    else <br>                    { <br>                        ListView_SetItemText (ghListView, lvi.iItem, 1, Notif.Info.DL.szDLFullName); <br>                    } <br>                } <br>                break; <br> <br>            case AB_USER_DELETED : <br>            case AB_USER_MODIFIED : <br>            case AB_DL_DELETED : <br>            case AB_DL_MODIFIED : <br>                if (AB_USER_DELETED == Notif.Event || AB_USER_MODIFIED == Notif.Event) <br>                { <br>                    if (ITEM_SERVER_USER_MAILBOXES != g_LVItemsType) <br>                    { <br>                        break; <br>                    } <br>                } <br>                else <br>                { <br>                    if (ITEM_SERVER_DIST_LISTS != g_LVItemsType) <br>                    { <br>                        break; <br>                    } <br>                } <br>                lfi.flags = LVFI_STRING; <br>                if (AB_USER_MODIFIED == Notif.Event || AB_USER_DELETED == Notif.Event) <br>                { <br>                    lfi.psz = Notif.Info.MB.szMailboxName; <br>                } <br>                else <br>                { <br>                    lfi.psz = Notif.Info.DL.szDLAlias; <br>                } <br>                lvi.iItem = ListView_FindItem (ghListView, -1, &amp;lfi); <br>                if (-1 == lvi.iItem) <br>                { <br>                    break; <br>                } <br>                if (AB_DL_DELETED == Notif.Event || AB_USER_DELETED == Notif.Event) <br>                { <br>                    ListView_DeleteItem (ghListView, lvi.iItem); <br>                } <br>                else <br>                { <br>                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE; <br>                    lvi.iSubItem = 0; <br>                    if (AB_USER_MODIFIED == Notif.Event) <br>                    { <br>                        lvi.pszText = Notif.Info.MB.szMailboxName; <br>                        lvi.lParam = Notif.Info.MB.dwObjID; <br>                        lvi.iImage = IMG_USER_MAILBOX; <br>                        ListView_SetItem (ghListView, &amp;lvi); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 1, Notif.Info.MB.szFullName); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 2, Notif.Info.MB.szJobTitle); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 3, Notif.Info.MB.szOffice); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 4, Notif.Info.MB.szPhone); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 5, Notif.Info.MB.szAltPhone); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 6, Notif.Info.MB.szFax); <br>                    } <br>                    else <br>                    { <br>                        lvi.pszText = Notif.Info.DL.szDLAlias; <br>                        lvi.lParam = Notif.Info.DL.dwObjID; <br>                        lvi.iImage = IMG_DIST_LIST; <br>                        ListView_SetItem (ghListView, &amp;lvi); <br>                        ListView_SetItemText (ghListView, lvi.iItem, 1, Notif.Info.DL.szDLFullName); <br>                    } <br>                } <br>                break; <br>            case RESET_LINKS_WITH_SERVER : <br>                PostMessage (ghWnd, WM_WINDS_RESET_NOTIF_LINK, 0, 0); <br>                break; <br>        } <br>    }  <br>    return S_OK; <br>} <br> <br>// End of file for ADMNOTIF.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
