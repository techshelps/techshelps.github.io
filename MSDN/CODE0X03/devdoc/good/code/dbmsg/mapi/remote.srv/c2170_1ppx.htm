<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADMMBOX.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2175"></a>ADMMBOX.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      ADMMBOX.CPP <br>// <br>//  Description <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "ADMIN.H" <br>#include "COMMON.H" <br> <br>extern "C" <br>{ <br>    HRESULT WINAPI DisplayMailboxPropSheets <br>                        (HWND                       hOwnerWnd, <br>                         POBJECT_INFO               pObjInfo, <br>                         BOOL                       fCreate); <br>    BOOL CALLBACK MBProps1DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK MBProps2DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK MBProps3DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK MBProps4DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK MBProps5DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK MBProps6DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br> <br>    void WINAPI RemoveSpaces <br>                        (LPTSTR *                   ppStr, <br>                         UINT                       uMaxChars); <br>    HRESULT WINAPI ExportDirectoryToFile <br>                        (HWND                       hOwnerWnd); <br>    HRESULT WINAPI ImportDirectoryFromFile <br>                        (HWND                       hOwnerWnd); <br>}; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ExportDirectoryToFile() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI ExportDirectoryToFile (HWND hOwnerWnd) <br>{ <br>    LPTSTR szExportFile = (LPTSTR)GetWindowLong (hOwnerWnd, GWL_USERDATA); <br>    HWND hLabel = GetDlgItem (hOwnerWnd, IDC_MAILBOX_LABEL); <br>    SetWindowText (hLabel, TEXT("")); <br>    HRESULT hResult = S_OK; <br>    long lPipeNum; <br>    TCHAR achPipeName[128]; <br>    HANDLE hPipe; <br>    DWORD dwBytesRead, dwBytesWritten; <br>    AB_ENTRY_INFO abEntry = { 0 }; <br>    char achCRLF[] = "\r\n", achComma[] = ", ", chQuote = '"'; <br>    HANDLE hFile = CreateFile (szExportFile, <br>                               GENERIC_WRITE, <br>                               FILE_SHARE_READ, <br>                               NULL, <br>                               CREATE_ALWAYS, <br>                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,  <br>                               NULL); <br>    if (INVALID_HANDLE_VALUE == hFile) <br>    { <br>        hResult = HRESULT_FROM_WIN32 (GetLastError()); <br>        goto ExportFinished; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteAdmGetServerMailboxes (&amp;lPipeNum); <br>        if (!hResult) <br>        { <br>            // Construct the download pipe name <br>            wsprintf (achPipeName, PIPE_NAME_FORMAT, g_szCurrentServer, lPipeNum); <br>            // Create our endpoint and connect     <br>            hPipe = CreateFile (achPipeName,  <br>                                GENERIC_READ, <br>                                0, <br>                                NULL, <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL); <br>            if (INVALID_HANDLE_VALUE == hPipe) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>            } <br>        } <br>    } <br>    RpcExcept(1) <br>    {         <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    if (!hResult) <br>    { <br>        do <br>        { <br>            // Read from the pipe <br>            if (!ReadFile (hPipe, &amp;abEntry, sizeof(AB_ENTRY_INFO), &amp;dwBytesRead, NULL)) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                if (HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE)   != hResult &amp;&amp;   // For Windows NT <br>                    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hResult)     // For Windows 95 <br>                { <br>                    // There was an error and we can't continue <br>                    TraceResult ("ExportDirectoryToFile: Failed to read from the source", hResult); <br>                } <br>                else <br>                { <br>                    // If the pipe was broken, it means the server finished writing <br>                    // to the it, so we are finished reading from it. <br>                    hResult = S_OK; <br>                } <br>            } <br>            else <br>            { <br>                SetWindowText (hLabel, abEntry.Info.MB.szMailboxName); <br>                WriteFile (hFile, abEntry.Info.MB.szMailboxName, lstrlen (abEntry.Info.MB.szMailboxName), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szFullName, lstrlen (abEntry.Info.MB.szFullName), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szJobTitle, lstrlen (abEntry.Info.MB.szJobTitle), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szOffice, lstrlen (abEntry.Info.MB.szOffice), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szPhone, lstrlen (abEntry.Info.MB.szPhone), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szCompany, lstrlen (abEntry.Info.MB.szCompany), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szDepartment, lstrlen (abEntry.Info.MB.szDepartment), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szAltPhone, lstrlen (abEntry.Info.MB.szAltPhone), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szFax, lstrlen (abEntry.Info.MB.szFax), &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, achComma, 2, &amp;dwBytesWritten, NULL); <br>                WriteFile (hFile, abEntry.Info.MB.szComments, lstrlen (abEntry.Info.MB.szComments), &amp;dwBytesWritten, NULL); <br> <br>                WriteFile (hFile, achCRLF, 2, &amp;dwBytesWritten, NULL); <br>            } <br>            if (AbortRemoteCall()) <br>            { <br>                break; // Out of the DO-WHILE() loop <br>            } <br>        } while (dwBytesRead &amp;&amp; !hResult); <br>        CloseHandle (hPipe); <br>    } <br>    CloseHandle (hFile); <br>    SetWindowText (hLabel, TEXT("Done!")); <br>ExportFinished: <br>    PostMessage (hOwnerWnd, WM_WINDS_EXPORT_FINISHED, hResult, 0); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ImportDirectoryFromFile() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI ImportDirectoryFromFile (HWND hOwnerWnd) <br>{ <br>    LPTSTR szImportFile = (LPTSTR)GetWindowLong (hOwnerWnd, GWL_USERDATA); <br>    HWND hLabel = GetDlgItem (hOwnerWnd, IDC_MAILBOX_LABEL); <br>    SetWindowText (hLabel, TEXT("")); <br>    HWND hListBox = GetDlgItem (hOwnerWnd, IDC_IMPORT_LIST); <br>    TCHAR szBuffer[256]; <br>     <br>    MAILBOX_INFO MB = { 0 }; <br>    DWORD i, dwBytesRead = 1; <br>    TCHAR achBuffer[4096], *szSubStr, achEmpty[] = TEXT(""); <br>    HRESULT hResult = S_OK; <br>    HANDLE hFile = CreateFile (szImportFile, <br>                               GENERIC_READ, <br>                               FILE_SHARE_READ, <br>                               NULL, <br>                               OPEN_EXISTING, <br>                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,  <br>                               NULL); <br>    if (INVALID_HANDLE_VALUE == hFile) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        goto ImportFinished; <br>    } <br>    do <br>    { <br>        ZeroMemory (achBuffer, sizeof(achBuffer)); <br>        ZeroMemory (&amp;MB, sizeof(MAILBOX_INFO)); <br>        for (i=0; i&lt;4096 &amp;&amp; !hResult &amp;&amp; dwBytesRead; i++) <br>        { <br>            if (!ReadFile (hFile, &amp;(achBuffer[i]), 1, &amp;dwBytesRead, NULL)) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("ImportDirectoryToFile: Failed to read from the source", hResult); <br>            } <br>            else <br>            { <br>                if (achBuffer[i] == '\n') <br>                { <br>                    break;  // Out of the FOR() loop <br>                } <br>            } <br>        } <br>        i = lstrlen(achBuffer); <br>        if (hResult || (!dwBytesRead &amp;&amp; 0 == i)) <br>        { <br>            break; <br>        } <br>        if (i&gt;1 &amp;&amp; '\n' == achBuffer[i - 1]) <br>        { <br>            achBuffer[i - 1] = 0; <br>        } <br>        if (i&gt;2 &amp;&amp; '\r' == achBuffer[i - 2]) <br>        { <br>            achBuffer[i - 2] = 0; <br>        } <br>         <br>        if (AbortRemoteCall()) <br>        { <br>            break; // Out of the DO-WHILE() loop <br>        } <br>         <br>        // Get the ALIAS of the mailbox <br>        szSubStr = strtok (achBuffer, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_ALIAS_SIZE); <br>        SetWindowText (hLabel, szSubStr); <br>        if (!IsObjAliasValid (NULL, szSubStr)) <br>        { <br>            wsprintf (szBuffer, TEXT("%s\tFAILED: Invalid object alias name"), szSubStr); <br>            ListBox_AddString (hListBox, szBuffer); <br>            continue; <br>        } <br>        lstrcpy (MB.szMailboxName, szSubStr); <br>        CharUpper (MB.szMailboxName); <br> <br>        // Get the FULL NAME of the mailbox owner <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_STRING_SIZE); <br>        lstrcpy (MB.szFullName, szSubStr); <br> <br>        // Get the JOB TITLE of the mailbox owner <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_STRING_SIZE); <br>        lstrcpy (MB.szJobTitle, szSubStr); <br> <br>        // Get the OFFICE LOCATION of the mailbox owner <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_STRING_SIZE); <br>        lstrcpy (MB.szOffice, szSubStr); <br> <br>        // Get the PHONE NUMBER of the mailbox owner <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_PHONE_SIZE); <br>        lstrcpy (MB.szPhone, szSubStr); <br>         <br>        // Get the COMPANY of the mailbox owner <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_STRING_SIZE); <br>        lstrcpy (MB.szCompany, szSubStr); <br>         <br>        // Get the DEPARTMENT of the mailbox owner <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_STRING_SIZE); <br>        lstrcpy (MB.szDepartment, szSubStr); <br> <br>        // Get the ALTERNATE PHONE NUMBER of the mailbox owner <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_PHONE_SIZE); <br>        lstrcpy (MB.szAltPhone, szSubStr); <br>         <br>        // Get the FAX NUMBER of the mailbox owner <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_PHONE_SIZE); <br>        lstrcpy (MB.szFax, szSubStr); <br>         <br>        // Get the COMMENTS of the mailbox <br>        szSubStr = strtok (NULL, ","); <br>        if (NULL == szSubStr) { szSubStr = achEmpty; } <br>        RemoveSpaces (&amp;szSubStr, MAX_COMMENT_SIZE); <br>        lstrcpy (MB.szComments, szSubStr); <br> <br>        lstrcpy (MB.szPassword, TEXT("PASSWORD")); <br>         <br>        if (AbortRemoteCall()) <br>        { <br>            break; // Out of the DO-WHILE() loop <br>        } <br>        RpcTryExcept <br>        { <br>            hResult = RemoteAdmCreateMailbox ((ADM_MAILBOX_INFO*)&amp;MB); <br>        } <br>        RpcExcept(1) <br>        {         <br>            // If we got here is because there was an error while call was made <br>            // or when it was about to be made. <br>            hResult = RpcExceptionCode(); <br>            if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>            { <br>                hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>            } <br>            else <br>            { <br>                hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>            } <br>        } <br>        RpcEndExcept <br>        if (hResult) <br>        { <br>            if (HRESULT_FROM_WIN32(ERROR_USER_EXISTS) == hResult) <br>            { <br>                wsprintf (szBuffer, TEXT("%s\tFAILED: The object already exists in the directory"), MB.szMailboxName); <br>            } <br>            else <br>            { <br>                wsprintf (szBuffer, TEXT("%s\tFAILED: Error %X"), MB.szMailboxName, hResult); <br>            } <br>        } <br>        else <br>        { <br>            lstrcpy (szBuffer, MB.szMailboxName); <br>            lstrcat (szBuffer, TEXT("\tSuccessfully Imported")); <br>        } <br>        ListBox_AddString (hListBox, szBuffer); <br> <br>        if (hResult &amp;&amp; <br>            hResult != HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE) &amp;&amp; <br>            HRESULT_FACILITY(hResult) != FACILITY_RPC) <br>        { <br>            hResult = S_OK; <br>        } <br>        if (AbortRemoteCall()) <br>        { <br>            break; // Out of the DO-WHILE() loop <br>        } <br>    } while (!hResult &amp;&amp; dwBytesRead); <br>    CloseHandle (hFile); <br>    SetWindowText (hLabel, TEXT("Done!")); <br>ImportFinished: <br>    PostMessage (hOwnerWnd, WM_WINDS_IMPORT_FINISHED, hResult, 0); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoveSpaces() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI RemoveSpaces (LPTSTR * ppStr, UINT uMaxChars) <br>{ <br>    LPTSTR pStr = *ppStr; <br>    // On an empty string, return. Nothing to do here <br>    if (0 == *pStr)  <br>    { <br>        return; <br>    } <br>    while (' ' == *pStr || '\t' == *pStr) <br>    { <br>        pStr++; <br>    } <br>    *ppStr = pStr; <br>    // On an empty string or a single chracter stringm, return. <br>    int i = lstrlen (pStr); <br>    if (0 == *pStr || i &lt; 2) <br>    { <br>        return; <br>    } <br>    pStr = &amp;(pStr[i]); <br>    while (' ' == *pStr || '\t' == *pStr || NULL == *pStr) <br>    { <br>        *pStr = NULL; <br>        pStr--; <br>    } <br>    if (uMaxChars &lt; (UINT)lstrlen (*ppStr)) <br>    { <br>        (*ppStr)[uMaxChars] = NULL; <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateNewMailbox() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI CreateNewMailbox (HWND hOwnerWnd) <br>{ <br>    OBJECT_INFO ObjInfo = { 0 }; <br>    lstrcpy (ObjInfo.MB.szPassword, TEXT("PASSWORD")); <br>    ObjInfo.Type = SERVER_USER_MAILBOX; <br>    HRESULT hResult = DisplayMailboxPropSheets (hOwnerWnd, &amp;ObjInfo, TRUE); <br>    if (!hResult) <br>    { <br>        RpcTryExcept <br>        { <br>            hResult = RemoteAdmCreateMailbox ((ADM_MAILBOX_INFO*)&amp;ObjInfo.MB); <br>        } <br>        RpcExcept(1) <br>        {         <br>            // If we got here is because there was an error while call was made <br>            // or when it was about to be made. <br>            hResult = RpcExceptionCode(); <br>            if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>            { <br>                hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>            } <br>            else <br>            { <br>                hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>            } <br>        } <br>        RpcEndExcept <br>    } <br>    else <br>    { <br>        if (S_FALSE == hResult) <br>        { <br>            hResult = S_OK; <br>        } <br>    } <br>    if (hResult) <br>    { <br>        ErrorHandler (hOwnerWnd, hResult); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DeleteServerObject() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI DeleteServerObject (HWND hOwnerWnd, DWORD dwObjID) <br>{ <br>    if (IDNO == PrivateMessageBox (IDS_MSG_CONFIRM_OBJECT_DELETE, <br>                                   hOwnerWnd, <br>                                   MB_YESNO | MB_ICONEXCLAMATION)) <br>    { <br>        return; <br>    } <br>    HRESULT hResult = S_OK; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteAdmDeleteObject (dwObjID); <br>    } <br>    RpcExcept(1) <br>    {         <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    if (hResult) <br>    { <br>        ErrorHandler (hOwnerWnd, hResult); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ShowMailboxProps() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI ShowMailboxProps (HWND hOwnerWnd, DWORD dwObjID) <br>{ <br>    OBJECT_INFO ObjInfo = { 0 }; <br>    ObjInfo.MB.dwObjID = dwObjID; <br>    ObjInfo.Type = SERVER_USER_MAILBOX; <br>    HRESULT hResult = S_OK; <br>    DWORD dwObjType; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteAdmGetMailboxProps (dwObjID, &amp;dwObjType, (ADM_MAILBOX_INFO*)&amp;ObjInfo.MB); <br>    } <br>    RpcExcept(1) <br>    {         <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    if (!hResult) <br>    { <br>        hResult = DisplayMailboxPropSheets (hOwnerWnd, &amp;ObjInfo, FALSE); <br>        if (S_OK == hResult) <br>        { <br>            RpcTryExcept <br>            { <br>                hResult = RemoteAdmSetMailboxProps ((ADM_MAILBOX_INFO*)&amp;ObjInfo.MB); <br>            } <br>            RpcExcept(1) <br>            {         <br>                // If we got here is because there was an error while call was made <br>                // or when it was about to be made. <br>                hResult = RpcExceptionCode(); <br>                if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>                { <br>                    hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>                } <br>                else <br>                { <br>                    hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>                } <br>            } <br>            RpcEndExcept <br>        } <br>        if (S_FALSE == hResult) <br>        { <br>            hResult = S_OK; <br>        } <br>    } <br>    if (hResult) <br>    { <br>        ErrorHandler (hOwnerWnd, hResult); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DisplayMailboxPropSheets() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI DisplayMailboxPropSheets (HWND           hOwnerWnd, <br>                                         POBJECT_INFO   pObjInfo, <br>                                         BOOL           fCreate) <br>{ <br>    PROPSHEETHEADER psh = { 0 }; <br>    PROPSHEETPAGE psp[6] = { 0 }; <br>    TCHAR szHeaderTitle[64]; <br> <br>    OBJECT_INFO NewObjInfo = *pObjInfo; <br> <br>    psp[0].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[0].dwFlags     = PSP_USETITLE; <br>    psp[0].hInstance   = ghInstance; <br>    psp[0].pszTemplate = MAKEINTRESOURCE (IDD_MB_PROPS1); <br>    psp[0].pfnDlgProc  = MBProps1DlgProc; <br>    psp[0].pszTitle    = TEXT("General"); <br>    psp[0].lParam      = (LPARAM)&amp;NewObjInfo; <br>     <br>    psp[1].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[1].dwFlags     = PSP_USETITLE; <br>    psp[1].hInstance   = ghInstance; <br>    psp[1].pszTemplate = MAKEINTRESOURCE (IDD_MB_PROPS2); <br>    psp[1].pfnDlgProc  = MBProps2DlgProc; <br>    psp[1].pszTitle    = TEXT("Phones"); <br>    psp[1].lParam      = (LPARAM)&amp;NewObjInfo; <br> <br>    psp[2].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[2].dwFlags     = PSP_USETITLE; <br>    psp[2].hInstance   = ghInstance; <br>    psp[2].pszTemplate = MAKEINTRESOURCE (IDD_MB_PROPS3); <br>    psp[2].pfnDlgProc  = MBProps3DlgProc; <br>    psp[2].pszTitle    = TEXT("Organization"); <br>    psp[2].lParam      = (LPARAM)&amp;NewObjInfo; <br> <br>    psp[3].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[3].dwFlags     = PSP_USETITLE; <br>    psp[3].hInstance   = ghInstance; <br>    psp[3].pszTemplate = MAKEINTRESOURCE (IDD_MB_PROPS4); <br>    psp[3].pfnDlgProc  = MBProps4DlgProc; <br>    psp[3].pszTitle    = TEXT("Account Security"); <br>    psp[3].lParam      = (LPARAM)&amp;NewObjInfo; <br> <br>    psp[4].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[4].dwFlags     = PSP_USETITLE; <br>    psp[4].hInstance   = ghInstance; <br>    psp[4].pszTemplate = MAKEINTRESOURCE (IDD_MB_PROPS5); <br>    psp[4].pfnDlgProc  = MBProps5DlgProc; <br>    psp[4].pszTitle    = TEXT("Delegate Access"); <br>    psp[4].lParam      = (LPARAM)&amp;NewObjInfo; <br> <br>    psp[5].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[5].dwFlags     = PSP_USETITLE; <br>    psp[5].hInstance   = ghInstance; <br>    psp[5].pszTemplate = MAKEINTRESOURCE (IDD_MB_PROPS6); <br>    psp[5].pfnDlgProc  = MBProps6DlgProc; <br>    psp[5].pszTitle    = TEXT("Auto Reply"); <br>    psp[5].lParam      = (LPARAM)&amp;NewObjInfo; <br> <br>    psh.dwSize     = sizeof(PROPSHEETHEADER); <br>    psh.dwFlags    = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW; <br>    psh.hwndParent = hOwnerWnd; <br>    psh.hInstance  = ghInstance; <br>    psh.nPages     = sizeof(psp)/sizeof(PROPSHEETPAGE); <br>    psh.ppsp       = (LPCPROPSHEETPAGE)&amp;psp; <br>    if (fCreate) <br>    { <br>        psh.pszCaption  = TEXT("New Mailbox Properties"); <br>    } <br>    else <br>    { <br>        wsprintf (szHeaderTitle, TEXT("Mailbox Properties for %s"), pObjInfo-&gt;MB.szMailboxName); <br>        psh.pszCaption  = szHeaderTitle; <br>    } <br> <br>    // If the user hit OK and at least one of the properties changed, <br>    // we must change the properties on the server <br>ReEnterProperties: <br>    if (1 == PropertySheet (&amp;psh) &amp;&amp; <br>        (fCreate ||  <br>        (NewObjInfo.MB.dwFlags != pObjInfo-&gt;MB.dwFlags || <br>         NewObjInfo.MB.dwManagerID != pObjInfo-&gt;MB.dwManagerID || <br>         lstrcmpi (NewObjInfo.MB.szFullName,    pObjInfo-&gt;MB.szFullName) || <br>         lstrcmpi (NewObjInfo.MB.szPassword,    pObjInfo-&gt;MB.szPassword) || <br>         lstrcmpi (NewObjInfo.MB.szJobTitle,    pObjInfo-&gt;MB.szJobTitle) || <br>         lstrcmpi (NewObjInfo.MB.szOffice,      pObjInfo-&gt;MB.szOffice) || <br>         lstrcmpi (NewObjInfo.MB.szPhone,       pObjInfo-&gt;MB.szPhone) || <br>         lstrcmpi (NewObjInfo.MB.szAltPhone,    pObjInfo-&gt;MB.szAltPhone) || <br>         lstrcmpi (NewObjInfo.MB.szFax,         pObjInfo-&gt;MB.szFax) || <br>         lstrcmpi (NewObjInfo.MB.szCompany,     pObjInfo-&gt;MB.szCompany) || <br>         lstrcmpi (NewObjInfo.MB.szDepartment,  pObjInfo-&gt;MB.szDepartment) || <br>         lstrcmpi (NewObjInfo.MB.szManagerAlias,pObjInfo-&gt;MB.szManagerAlias) || <br>         lstrcmpi (NewObjInfo.MB.szManagerName,pObjInfo-&gt;MB.szManagerName) || <br>         lstrcmpi (NewObjInfo.MB.szComments,  pObjInfo-&gt;MB.szComments)))) <br>    { <br>        if (fCreate) <br>        { <br>            psh.nStartPage = 0; <br>            if (!IsObjAliasValid (hOwnerWnd, NewObjInfo.MB.szMailboxName)) <br>            { <br>                goto ReEnterProperties; <br>            } <br>        } <br>        if (0 == lstrlen (NewObjInfo.MB.szFullName)) <br>        { <br>            PrivateMessageBox (IDS_MSG_NO_USER_NAME, hOwnerWnd, 0); <br>            psh.nStartPage = 0; <br>            goto ReEnterProperties; <br>        } <br>        if (0 == lstrlen (NewObjInfo.MB.szPassword)) <br>        { <br>            PrivateMessageBox (IDS_MSG_NO_PASSWORD, hOwnerWnd, 0); <br>            psh.nStartPage = 2; <br>            goto ReEnterProperties; <br>        } <br>        *pObjInfo = NewObjInfo; <br>        return S_OK; <br>    } <br>    return S_FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    IsObjAliasValid() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>BOOL WINAPI IsObjAliasValid (HWND hOwnerWnd, LPTSTR szObjAlias) <br>{ <br>    TCHAR achTempAlias[MAX_ALIAS_SIZE+1]; <br>    lstrcpy (achTempAlias, szObjAlias); <br>    szObjAlias[0] = NULL; <br>    int iChars = lstrlen (achTempAlias); <br>    if (0 == iChars) <br>    { <br>        if (hOwnerWnd) <br>        { <br>            PrivateMessageBox (IDS_MSG_NO_OBJECT_ALIAS, hOwnerWnd, 0); <br>        } <br>        return FALSE; <br>    } <br>    if (!isalpha (achTempAlias[0])) <br>    { <br>        if (hOwnerWnd) <br>        { <br>            PrivateMessageBox (IDS_MSG_INVALID_OBJECT_ALIAS, hOwnerWnd, 0); <br>        } <br>        return FALSE; <br>    } <br>     <br>    for (int i=1; i&lt;iChars; i++) <br>    { <br>        if (!isdigit(achTempAlias[i]) &amp;&amp; <br>            !isalpha(achTempAlias[i]) &amp;&amp; <br>            '-' != achTempAlias[i] &amp;&amp; <br>            '_' != achTempAlias[i]) <br>        { <br>            if (hOwnerWnd) <br>            { <br>                PrivateMessageBox (IDS_MSG_INVALIS_CHARS_IN_ALIAS, hOwnerWnd, 0); <br>            } <br>            return FALSE; <br>        } <br>    } <br>    lstrcpy (szObjAlias, achTempAlias); <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MBProps1DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK MBProps1DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    static HWND hAliasLabel; <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_OBJECT_ALIAS); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szMailboxName); <br>                if (0 == pObjInfo-&gt;MB.dwObjID) <br>                { <br>                    EnableWindow (hCtl, TRUE); <br>                    Edit_LimitText (hCtl, MAX_ALIAS_SIZE); <br>                    hCtl = GetDlgItem (hDlg, IDC_OBJECT_ALIAS_LABEL); <br>                    EnableWindow (hCtl, TRUE); <br>                } <br> <br>                hCtl = GetDlgItem (hDlg, IDC_MAILBOX_OWNER); <br>                Edit_LimitText (hCtl, MAX_STRING_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szFullName); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_MAILBOX_JOBTITLE); <br>                Edit_LimitText (hCtl, MAX_STRING_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szJobTitle); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_MAILBOX_OFFICE); <br>                Edit_LimitText (hCtl, MAX_STRING_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szOffice); <br> <br>                hAliasLabel = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hAliasLabel, pObjInfo-&gt;MB.szMailboxName); </code></pre>
<p>
</p>
<pre><code>SetWindowFont (hAliasLabel, ghBoldFont, TRUE); <br> <br>                if (OBJECT_DISABLED &amp; pObjInfo-&gt;MB.dwFlags) <br>                { <br>                    Button_SetCheck (GetDlgItem (hDlg, IDC_DISABLE), BST_CHECKED); <br>                } <br>                if (HIDE_IN_DIR &amp; pObjInfo-&gt;MB.dwFlags) <br>                { <br>                    Button_SetCheck (GetDlgItem (hDlg, IDC_HIDE), BST_CHECKED); <br>                } <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_MAILBOX, ILD_NORMAL)); <br>            } <br>            return TRUE; <br> <br>        case WM_NOTIFY : <br>            if (PSN_APPLY == ((LPNMHDR)lParam)-&gt;code) <br>            { <br>                if (BST_CHECKED == Button_GetCheck (GetDlgItem (hDlg, IDC_DISABLE))) <br>                { <br>                    pObjInfo-&gt;MB.dwFlags |= OBJECT_DISABLED; <br>                } <br>                else <br>                { <br>                    pObjInfo-&gt;MB.dwFlags &amp;= ~OBJECT_DISABLED; <br>                } <br>                if (BST_CHECKED == Button_GetCheck (GetDlgItem (hDlg, IDC_HIDE))) <br>                { <br>                    pObjInfo-&gt;MB.dwFlags |= HIDE_IN_DIR; <br>                } <br>                else <br>                { <br>                    pObjInfo-&gt;MB.dwFlags &amp;= ~HIDE_IN_DIR; <br>                } <br>                GetWindowText (GetDlgItem (hDlg, IDC_OBJECT_ALIAS), <br>                               pObjInfo-&gt;MB.szMailboxName, <br>                               MAX_ALIAS_SIZE+1); <br>                GetWindowText (GetDlgItem (hDlg, IDC_MAILBOX_OWNER), <br>                               pObjInfo-&gt;MB.szFullName, <br>                               MAX_STRING_SIZE+1); <br>                GetWindowText (GetDlgItem (hDlg, IDC_MAILBOX_JOBTITLE), <br>                               pObjInfo-&gt;MB.szJobTitle, <br>                               MAX_STRING_SIZE+1); <br>                GetWindowText (GetDlgItem (hDlg, IDC_MAILBOX_OFFICE), <br>                               pObjInfo-&gt;MB.szOffice, <br>                               MAX_STRING_SIZE+1); <br>                 <br>                return PSNRET_NOERROR; <br>            } <br>            break; <br> <br>        case WM_COMMAND : <br>            if (HIWORD(wParam) == EN_CHANGE &amp;&amp; LOWORD(wParam) == IDC_OBJECT_ALIAS) <br>            { <br>                GetWindowText ((HWND)lParam, pObjInfo-&gt;MB.szMailboxName, MAX_ALIAS_SIZE+1); <br>                SetWindowText (hAliasLabel, pObjInfo-&gt;MB.szMailboxName); <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MBProps2DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK MBProps2DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                 <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_MAILBOX_PHONE); <br>                Edit_LimitText (hCtl, MAX_PHONE_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szPhone); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_MAILBOX_FAX); <br>                Edit_LimitText (hCtl, MAX_PHONE_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szFax); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_MAILBOX_ALTPHONE); <br>                Edit_LimitText (hCtl, MAX_PHONE_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szAltPhone); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szMailboxName); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_PHONE_HAND, ILD_NORMAL)); <br>            } <br>            return TRUE; <br> <br>        case WM_NOTIFY : <br>            if (PSN_APPLY == ((LPNMHDR)lParam)-&gt;code) <br>            { <br>                GetWindowText (GetDlgItem (hDlg, IDC_MAILBOX_PHONE), <br>                               pObjInfo-&gt;MB.szPhone, <br>                               MAX_PHONE_SIZE+1); <br>                GetWindowText (GetDlgItem (hDlg, IDC_MAILBOX_FAX), <br>                               pObjInfo-&gt;MB.szFax, <br>                               MAX_PHONE_SIZE+1); <br>                GetWindowText (GetDlgItem (hDlg, IDC_MAILBOX_ALTPHONE), <br>                               pObjInfo-&gt;MB.szAltPhone, <br>                               MAX_PHONE_SIZE+1); <br>                return PSNRET_NOERROR; <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MBProps3DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK MBProps3DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                 <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_MAILBOX_PHONE); <br>                Edit_LimitText (hCtl, MAX_PHONE_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szPhone); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_COMPANY); <br>                Edit_LimitText (hCtl, MAX_STRING_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szCompany); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_DEPARTMENT); <br>                Edit_LimitText (hCtl, MAX_STRING_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szDepartment); <br>                 <br>                hCtl = GetDlgItem (hDlg, IDC_MANAGER); <br>                Edit_LimitText (hCtl, MAX_STRING_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szManagerName); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_MAILBOX_COMMENTS); <br>                Edit_LimitText (hCtl, MAX_COMMENT_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szComments); <br> <br>                 <br>                hCtl = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szMailboxName); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_WORLD, ILD_NORMAL)); <br>            } <br>            return TRUE; <br> <br>        case WM_NOTIFY : <br>            if (PSN_APPLY == ((LPNMHDR)lParam)-&gt;code) <br>            { <br>                GetWindowText (GetDlgItem (hDlg, IDC_COMPANY), <br>                               pObjInfo-&gt;MB.szCompany, <br>                               MAX_STRING_SIZE+1); <br>                GetWindowText (GetDlgItem (hDlg, IDC_DEPARTMENT), <br>                               pObjInfo-&gt;MB.szDepartment, <br>                               MAX_STRING_SIZE+1); <br>                GetWindowText (GetDlgItem (hDlg, IDC_MAILBOX_COMMENTS), <br>                               pObjInfo-&gt;MB.szComments, <br>                               MAX_COMMENT_SIZE+1); <br>                return PSNRET_NOERROR; <br>            } <br>            break; <br> <br>        case WM_COMMAND : <br>            if (LOWORD(wParam) == IDC_BROWSE) <br>            { <br>                if (TRUE == DialogBoxParam (ghInstance, <br>                                            MAKEINTRESOURCE(IDD_ONE_MAILBOX), <br>                                            hDlg, <br>                                            SelectUserDlgProc, <br>                                            (LPARAM)pObjInfo)) <br>                { <br>                    SetWindowText (GetDlgItem (hDlg, IDC_MANAGER), pObjInfo-&gt;MB.szManagerName); <br>                } <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MBProps4DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK MBProps4DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_MAILBOX_PASSWORD); <br>                Edit_LimitText (hCtl, MAX_PASSWORD_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szPassword); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szMailboxName); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_KEY, ILD_NORMAL)); <br>            } <br>            return TRUE; <br> <br>        case WM_NOTIFY : <br>            if (PSN_APPLY == ((LPNMHDR)lParam)-&gt;code) <br>            { <br>                GetWindowText (GetDlgItem (hDlg, IDC_MAILBOX_PASSWORD), <br>                               pObjInfo-&gt;MB.szPassword, <br>                               MAX_STRING_SIZE+1); <br>                return PSNRET_NOERROR; <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MBProps5DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK MBProps5DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szMailboxName); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_NYI_LABEL); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br> <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_PEOPLE, ILD_NORMAL)); <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_CONSTRUCT_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_CONSTRUCT, ILD_NORMAL)); <br>            } <br>            return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MBProps6DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK MBProps6DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hCtl, pObjInfo-&gt;MB.szMailboxName); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_NYI_LABEL); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br> <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_AUTO_REPLY, ILD_NORMAL)); <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_CONSTRUCT_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_CONSTRUCT, ILD_NORMAL)); <br>            } <br>            return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetServerMailboxes() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetServerMailboxes (HWND hOwnerWnd) <br>{ <br>    return DownloadBulkInfo (hOwnerWnd, ghListView, ITEM_SERVER_USER_MAILBOXES); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PurgeMailboxMessages() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI PurgeMailboxMessages (HWND hOwnerWnd, DWORD dwObjID) <br>{ <br>    if (IDNO == PrivateMessageBox (IDS_MSG_CONFIRM_MB_MSGS_PURGE, <br>                                   hOwnerWnd, <br>                                   MB_YESNO | MB_ICONEXCLAMATION)) <br>    { <br>        return; <br>    } <br>    HRESULT hResult = S_OK; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteAdmEmptyMailbox (dwObjID); <br>    } <br>    RpcExcept(1) <br>    {         <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    if (hResult) <br>    { <br>        ErrorHandler (hOwnerWnd, hResult); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    BrowseFileName() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>BOOL WINAPI BrowseFileName (HWND hOwnerWnd, LPTSTR szFileName, BOOL fImport) <br>{ <br>    szFileName[0] = NULL; <br>    // Filter for files for the browse file dialog box <br>    static LPTSTR szFilter = TEXT("Comma Delimeted (*.CSV)\0*.CSV\0All Files (*.*)\0*.*\0"); <br>    OPENFILENAME ofn = { 0 }; <br>    ofn.lStructSize  = sizeof(OPENFILENAME); <br>    ofn.hwndOwner    = hOwnerWnd; <br>    ofn.hInstance    = ghInstance; <br>    ofn.lpstrFilter  = szFilter; <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile    = szFileName; <br>    ofn.nMaxFile     = _MAX_PATH; <br>    ofn.lpstrTitle   = TEXT("WINDS Administrator - File Browse"); <br>    ofn.lpstrDefExt  = TEXT("*.CSV"); <br>    if (fImport) <br>    { <br>        ofn.Flags = OFN_HIDEREADONLY | <br>                    OFN_PATHMUSTEXIST | <br>                    OFN_FILEMUSTEXIST; <br>    } <br>    else <br>    { <br>        ofn.Flags = OFN_HIDEREADONLY | <br>                    OFN_OVERWRITEPROMPT | <br>                    OFN_CREATEPROMPT    | <br>                    OFN_NOREADONLYRETURN; <br>    } <br>     <br>    BOOL fReturn;  <br>    if (fImport) <br>    { <br>        fReturn = GetOpenFileName (&amp;ofn); <br>    } <br>    else <br>    { <br>        fReturn = GetSaveFileName (&amp;ofn); <br>    } <br>    return fReturn; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ExportDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK ExportDlgProc (HWND    hDlg,  <br>                             UINT    message,  <br>                             WPARAM  wParam,  <br>                             LPARAM  lParam) <br>{ <br>    static BOOL fMailboxes, fGwayDirs; <br>    TCHAR szFile[_MAX_PATH]; <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            CenterDialogBox (hDlg); <br>            SetFocus (GetDlgItem (hDlg, IDC_BROWSE)); <br>            Button_SetCheck (GetDlgItem (hDlg, IDC_MAILBOXES), BST_CHECKED); <br>            Button_SetCheck (GetDlgItem (hDlg, IDC_GW_DIRECTORIES), BST_CHECKED); <br>            fMailboxes = fGwayDirs = TRUE; <br>            Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                            ImageList_GetIcon (g_hIconImgs, ICON_LABELS, ILD_NORMAL)); <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_MAILBOXES : <br>                case IDC_GW_DIRECTORIES : <br>                    if (HIWORD(wParam) == BN_CLICKED) <br>                    { <br>                        if (LOWORD(wParam) == IDC_MAILBOXES) <br>                        { <br>                            fMailboxes = !fMailboxes; <br>                        } <br>                        else <br>                        { <br>                            fGwayDirs = !fGwayDirs; <br>                        } <br>                        if (fGwayDirs || fMailboxes) <br>                        { <br>                            EnableWindow (GetDlgItem (hDlg, IDOK), TRUE); <br>                        } <br>                        else <br>                        { <br>                            EnableWindow (GetDlgItem (hDlg, IDOK), FALSE); <br>                        } <br>                    } <br>                    break; <br> <br>                case IDC_BROWSE : <br>                    if (BrowseFileName (hDlg, szFile, FALSE)) <br>                    { <br>                        SetWindowText (GetDlgItem (hDlg, IDC_FILENAME), szFile); <br>                    } <br>                    break; <br> <br>                case IDOK : <br>                    if (!GetWindowText (GetDlgItem (hDlg, IDC_FILENAME), szFile, _MAX_PATH)) <br>                    { <br>                        break; <br>                    } <br>                    DialogBoxParam (ghInstance, <br>                                    MAKEINTRESOURCE (IDD_EXPORT_STATE), <br>                                    hDlg, <br>                                    ExportProgressDlgProc, <br>                                    (LPARAM)szFile); <br>                    break; <br> <br>                case IDCANCEL : <br>                    EndDialog (hDlg, TRUE); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ImportDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK ImportDlgProc (HWND    hDlg,  <br>                             UINT    message,  <br>                             WPARAM  wParam,  <br>                             LPARAM  lParam) <br>{ <br>    TCHAR szFile[_MAX_PATH]; <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            CenterDialogBox (hDlg); <br>            PostMessage (hDlg, WM_COMMAND, IDC_BROWSE, 0); <br>            Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                            ImageList_GetIcon (g_hIconImgs, ICON_CLIP, ILD_NORMAL)); <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_BROWSE : <br>                    if (BrowseFileName (hDlg, szFile, TRUE)) <br>                    { <br>                        SetWindowText (GetDlgItem (hDlg, IDC_FILENAME), szFile); <br>                    } <br>                    break; <br> <br>                case IDOK : <br>                    if (!GetWindowText (GetDlgItem (hDlg, IDC_FILENAME), szFile, _MAX_PATH)) <br>                    { <br>                        break; <br>                    } <br>                    DialogBoxParam (ghInstance, <br>                                    MAKEINTRESOURCE (IDD_IMPORT_STATE), <br>                                    hDlg, <br>                                    ImportProgressDlgProc, <br>                                    (LPARAM)szFile); <br>                    break; <br> <br>                case IDCANCEL : <br>                    EndDialog (hDlg, TRUE); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ImportProgressDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK ImportProgressDlgProc (HWND    hDlg,  <br>                                     UINT    message,  <br>                                     WPARAM  wParam,  <br>                                     LPARAM  lParam) <br>{ <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            { <br>                SetWindowLong (hDlg, GWL_USERDATA, (long)lParam); <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                 <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_STOPWATCH), GetAnimatedTimerCursor()); <br>                 <br>                SetWindowFont (GetDlgItem (hDlg, IDC_ICON_TITLE), ghBoldFont, FALSE); <br>                SetWindowFont (GetDlgItem (hDlg, IDC_MAILBOX_LABEL), ghBoldFont, FALSE); <br> <br>                int nTabStops[1] = { 80 }; <br>                ListBox_SetTabStops (GetDlgItem (hDlg, IDC_IMPORT_LIST), sizeof(nTabStops)/sizeof(int), nTabStops); <br> <br>                PostMessage (hDlg, WM_WINDS_IMPORT_START, 0, 0); <br>            } <br>            return TRUE; <br> <br>        case WM_WINDS_IMPORT_START : <br>            { <br>                DWORD dwThreadID; <br>                HANDLE hThread = CreateThread (NULL, <br>                                               0, <br>                                               (LPTHREAD_START_ROUTINE)ImportDirectoryFromFile, <br>                                               (LPVOID)hDlg, <br>                                               0, <br>                                               &amp;dwThreadID); <br>                if (hThread) <br>                { <br>                    CloseHandle (hThread); <br>                } <br>                else <br>                { <br>                    PostMessage (hDlg, <br>                                 WM_WINDS_IMPORT_FINISHED, <br>                                 HRESULT_FROM_WIN32(GetLastError()), <br>                                 0); <br>                } <br>            } <br>            break; <br> <br>        case WM_WINDS_IMPORT_FINISHED : <br>            EnableWindow (GetDlgItem (hDlg, IDOK), TRUE); <br>            EnableWindow (GetDlgItem (hDlg, IDCANCEL), FALSE); <br>            Static_SetIcon (GetDlgItem (hDlg, IDC_STOPWATCH), <br>                            ImageList_GetIcon (g_hIconImgs, ICON_TIMEUP, ILD_NORMAL)); <br>            if (wParam) <br>            { <br>                ErrorHandler (hDlg, wParam); <br>            } <br>            break; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDCANCEL : <br>                    SetEvent (ghCancelEvent); <br>                    break; <br> <br>                case IDOK : <br>                    EndDialog (hDlg, TRUE); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ExportProgressDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK ExportProgressDlgProc (HWND    hDlg,  <br>                                     UINT    message,  <br>                                     WPARAM  wParam,  <br>                                     LPARAM  lParam) <br>{ <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            { <br>                SetWindowLong (hDlg, GWL_USERDATA, (long)lParam); <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                 <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_STOPWATCH), GetAnimatedTimerCursor()); <br>                 <br>                SetWindowFont (GetDlgItem (hDlg, IDC_ICON_TITLE), ghBoldFont, FALSE); <br>                SetWindowFont (GetDlgItem (hDlg, IDC_MAILBOX_LABEL), ghBoldFont, FALSE); <br> <br>                PostMessage (hDlg, WM_WINDS_EXPORT_START, 0, 0); <br>            } <br>            return TRUE; <br> <br>        case WM_WINDS_EXPORT_START : <br>            { <br>                DWORD dwThreadID; <br>                HANDLE hThread = CreateThread (NULL, <br>                                               0, <br>                                               (LPTHREAD_START_ROUTINE)ExportDirectoryToFile, <br>                                               (LPVOID)hDlg, <br>                                               0, <br>                                               &amp;dwThreadID); <br>                if (hThread) <br>                { <br>                    CloseHandle (hThread); <br>                } <br>                else <br>                { <br>                    PostMessage (hDlg, <br>                                 WM_WINDS_EXPORT_FINISHED, <br>                                 HRESULT_FROM_WIN32(GetLastError()), <br>                                 0); <br>                } <br>            } <br>            break; <br> <br>        case WM_WINDS_EXPORT_FINISHED : <br>            TraceMessage ("Export Finished"); <br>            EnableWindow (GetDlgItem (hDlg, IDOK), TRUE); <br>            EnableWindow (GetDlgItem (hDlg, IDCANCEL), FALSE); <br>            Static_SetIcon (GetDlgItem (hDlg, IDC_STOPWATCH), <br>                            ImageList_GetIcon (g_hIconImgs, ICON_TIMEUP, ILD_NORMAL)); <br>            if (wParam) <br>            { <br>                ErrorHandler (hDlg, wParam); <br>            } <br>            break; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDCANCEL : <br>                    SetEvent (ghCancelEvent); <br>                    break; <br> <br>                case IDOK : <br>                    EndDialog (hDlg, TRUE); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetAnimatedTimerCursor() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HCURSOR WINAPI GetAnimatedTimerCursor() <br>{ <br>    static HCURSOR hCursor = NULL; <br>    if (hCursor) <br>    { <br>        return hCursor; <br>    } <br>    HMODULE hModule; <br>    HRSRC hResource; <br>    DWORD dwBytes, dwSize; <br>    TCHAR szANIFile[MAX_PATH]; <br>    GetTempPath (MAX_PATH, szANIFile); <br>    lstrcat (szANIFile, TEXT("__WINDS_TIMER__CURSOR.ANI")); <br>    HANDLE hResBits, hFile = CreateFile (szANIFile, <br>                                         GENERIC_WRITE, <br>                                         0, <br>                                         NULL, <br>                                         CREATE_ALWAYS, <br>                                         FILE_ATTRIBUTE_NORMAL, <br>                                         NULL); <br>    if (INVALID_HANDLE_VALUE == hFile) <br>    {    <br>        TraceResult ("GetAnimatedTimerCursor: Failed to create temp file", HRESULT_FROM_WIN32(GetLastError())); <br>    } <br>    else <br>    { <br>        hModule = GetModuleHandle (NULL); <br>        hResource = FindResource (hModule, TEXT("#5000"), RT_RCDATA); <br>        hResBits = LoadResource (hModule, hResource); <br>        dwSize = SizeofResource (hModule, hResource); </code></pre>
<p>
</p>
<pre><code>WriteFile (hFile, (LPVOID)hResBits, dwSize, &amp;dwBytes, NULL); <br>        CloseHandle (hFile); <br>        FreeResource (hResource); <br>        hCursor = LoadCursorFromFile (szANIFile); <br>        DeleteFile (szANIFile); <br>    } <br>    return hCursor; <br>} <br> <br>// End of file for ADMMBOX.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
