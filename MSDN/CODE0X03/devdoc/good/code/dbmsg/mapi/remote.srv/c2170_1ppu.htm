<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADMIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2172"></a>ADMIN.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      ADMIN.CPP <br>// <br>//  Description <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "ADMIN.H" <br>#include "COMMON.H" <br> <br>extern "C" <br>{ <br>    TCHAR g_szAppTitle[] = TEXT("WINDS Administrator"); <br>    ITEM_TYPE g_LVItemsType = ITEM_UNDEFINED_TYPE; <br>    HINSTANCE ghInstance = NULL; <br>    HANDLE ghMemHeap = NULL; <br>    HANDLE ghCancelEvent; <br>    HWND ghTreeView, ghListView, ghWnd, ghStatusBar, ghToolBar; <br>    BOOL gfCancel = FALSE, gfTerminate = FALSE; <br>    HFONT ghBoldFont = NULL; <br>    CRITICAL_SECTION csCancel, csRemoteServer; <br>    TCHAR g_szCurrentServer[64] = { 0 }; <br>    HIMAGELIST g_hImages = NULL, g_hIconImgs = NULL; <br>    LPVOID g_pctl3d = NULL; <br> <br>    HRESULT WINAPI ServerChanged <br>                        (HWND                       hTreeView); <br> <br>    LRESULT CALLBACK MainWndProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL WINAPI ShowConnectDialog <br>                        (HWND                       hOwnerWnd, <br>                         LPTSTR                     szServer, <br>                         BOOL *                     pfServerIsOnLine); <br>    BOOL WINAPI IsValidServerName <br>                        (LPTSTR                     szServerName); <br>    void WINAPI LoadSettingsFromRegistry <br>                        (LPTSTR                     szServer); <br>    void WINAPI SaveSettingsToRegistry <br>                        (LPTSTR                     szServer); <br>    void WINAPI HandleItemAction <br>                        (HWND                       hOwnerWnd, <br>                         int                        nItem, <br>                         WORD                       wAction); <br>    void WINAPI GetServerNameFromTitle <br>                        (LPTSTR                     szItemTitle, <br>                         LPTSTR *                   pszServerName); <br>    HRESULT WINAPI CancelThreadProc <br>                        (); <br>} <br> <br>CNotifLink * gpLink = NULL; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WinMain() <br>// <br>//    Parameters <br>//      { Refer to Win32 SDK documentation } <br>//       <br>//    Purpose <br>//      This is the entry function. The application will start executing here. <br>//       <br>//    Return Value <br>//      Return code of the application to the system. <br>//       <br>int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCmdLine, int nCmdLine) <br>{ <br>    #define WINDOW_CLASSNAME        TEXT("WINDS_ADMIN_CLASS") <br>    // Check for other instances of this application running. If one is found, <br>    // bring it to the foreground <br>    ghWnd = FindWindow (WINDOW_CLASSNAME, NULL); <br>    if (NULL != ghWnd) <br>    { <br>        HWND hChildWnd; <br>        hChildWnd = GetLastActivePopup (ghWnd); <br>        if (hChildWnd != ghWnd) <br>        { <br>            BringWindowToTop (hChildWnd); <br>        } <br>        else <br>        { <br>            SetForegroundWindow (ghWnd); <br>        } <br>        return 0; <br>    } <br> <br>    MSG msg; <br>    HACCEL hAccel; <br>    InitTraces (0); <br>    TraceMessage ("WINDS Admin is initializing"); <br>    ghInstance = hInstance; <br>    ghMemHeap = GetProcessHeap(); <br> <br>    WNDCLASS wc = { 0 }; <br>    // Register the class for this application <br>    wc.lpfnWndProc      = MainWndProc; <br>    wc.hInstance        = ghInstance; <br>    wc.hIcon            = LoadIcon (ghInstance, MAKEINTRESOURCE (IDI_MAINFRAME)); <br>    wc.lpszMenuName     = MAKEINTRESOURCE (IDM_MENU); <br>    wc.lpszClassName    = WINDOW_CLASSNAME; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE); <br>    if (!RegisterClass (&amp;wc)) <br>    { <br>        TraceMessage ("WinMain: Failed to register the application class"); <br>        return -1; <br>    } <br>    gpLink = new CNotifLink; <br>    InitializeCriticalSection (&amp;csRemoteServer); <br>    InitializeCriticalSection (&amp;csCancel); <br>     <br>    ghCancelEvent = CreateEvent (NULL, FALSE, FALSE, NULL);     <br> <br>    if (!g_pctl3d) <br>    { <br>        BOOL f; <br>        g_pctl3d = CTL3D_Initialize(ghInstance); <br>        CTL3D_AutoSubclass(g_pctl3d, ghInstance, &amp;f); <br>    } <br> <br>    InitCommonControls(); <br> <br>    ghWnd = CreateWindowEx (WS_EX_DLGMODALFRAME | WS_EX_APPWINDOW | WS_EX_CONTROLPARENT, <br>                            WINDOW_CLASSNAME, <br>                            TEXT("WINDS Administrator"), <br>                            WS_OVERLAPPED   | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU, <br>                            100, <br>                            100, <br>                            800, <br>                            500, <br>                            NULL, <br>                            NULL, <br>                            ghInstance, <br>                            NULL); <br>    if (NULL == ghWnd) <br>    { <br>        PrivateMessageBox (IDS_MSG_NO_INTERNAL_RESOURCES, NULL, 0); <br>        goto ErrorExit; <br>    } <br>    hAccel = LoadAccelerators (ghInstance, MAKEINTRESOURCE (IDA_ACCELTABLE)); <br>    if (NULL == hAccel) <br>    { <br>        TraceMessage ("WinMain: Failed to load accelerator table"); <br>    } <br>     <br>    ShowWindow (ghWnd, nCmdLine); <br>    UpdateWindow (ghWnd); <br> <br>    while (GetMessage (&amp;msg, NULL, 0, 0)) <br>    { <br>        if (!TranslateAccelerator (msg.hwnd, hAccel, &amp;msg)) <br>        { <br>            TranslateMessage (&amp;msg); <br>            DispatchMessage (&amp;msg); <br>        } <br>    } <br>ErrorExit: <br> <br>    DeleteCriticalSection (&amp;csCancel); <br>    DeleteCriticalSection (&amp;csRemoteServer); <br>    delete gpLink; <br>     <br>    // Free any pending RPC binding resources. <br>    BindToServer (NULL); <br> <br>    CloseHandle (ghCancelEvent); <br> <br>    CTL3D_Uninitialize(g_pctl3d); <br>    g_pctl3d = NULL; <br>    return 0; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MainWndProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>LRESULT CALLBACK MainWndProc (HWND    hWnd,  <br>                              UINT    message,  <br>                              WPARAM  wParam,  <br>                              LPARAM  lParam) <br>{ <br>    static HBRUSH hbrFace = NULL; <br>    static HMENU hMBPopupMenu, hDLPopupMenu; <br>    static HCURSOR hCurrentCursor = NULL; <br>    static BOOL fRPCInProgress = FALSE; <br>    switch (message) <br>    { <br>        case WM_SETCURSOR : <br>            SetCursor (hCurrentCursor); <br>            return TRUE; <br> <br>        case WM_CREATE : <br>            { <br>                hCurrentCursor = LoadCursor (NULL, IDC_ARROW); <br>                g_hIconImgs = ImageList_LoadBitmap (ghInstance, MAKEINTRESOURCE(IDB_ICONS), 32, 2, CLR_NONE); <br>                g_hImages = ImageList_LoadBitmap (ghInstance, MAKEINTRESOURCE(IDB_OBJECTS), 18, 2, CLR_NONE); <br>                ImageList_SetBkColor (g_hImages, GetSysColor(COLOR_WINDOW)); <br>                 <br>                if (!CreateListView (hWnd, g_hImages)) <br>                { <br>                    return -1; <br>                } <br>                if (!CreateTreeView (hWnd, g_hImages)) <br>                { <br>                    return -1; <br>                } <br>                if (!CreateToolBar (hWnd)) <br>                { <br>                    return -1; <br>                } <br>                BOOL fServerIsOnline = FALSE; <br>                LoadSettingsFromRegistry (g_szCurrentServer); <br>                if (ShowConnectDialog (hWnd, g_szCurrentServer, &amp;fServerIsOnline) &amp;&amp; <br>                    fServerIsOnline) <br>                { <br>                    AddServerToList (g_szCurrentServer, TRUE); <br>                    gpLink-&gt;StartNotification(); <br>                } <br>                hbrFace = CreateSolidBrush (GetSysColor (COLOR_BTNFACE)); <br>                ghBoldFont = CreateFont (-24,                    // Height <br>                                         0,                      // Width <br>                                         0,                      // Escapement <br>                                         0,                      // Orientation <br>                                         FW_BOLD,                // Font Weigth <br>                                         FALSE,                  // Italic? <br>                                         FALSE,                  // Underlined? <br>                                         FALSE,                  // Strike out? <br>                                         ANSI_CHARSET,           // Character set <br>                                         OUT_STROKE_PRECIS,      // Font precision <br>                                         CLIP_STROKE_PRECIS,     // Clip precision  <br>                                         DRAFT_QUALITY,          // Font apperance quality <br>                                         FF_SWISS,               // Font pitch and family, <br>                                         TEXT("Arial"));         // Font face name <br>                CreateStatusBar (hWnd); <br> <br>                hMBPopupMenu = LoadMenu (ghInstance, MAKEINTRESOURCE (IDM_MAILBOX_POPUP)); <br>                hMBPopupMenu = GetSubMenu (hMBPopupMenu, 0); <br> <br>                hDLPopupMenu = LoadMenu (ghInstance, MAKEINTRESOURCE (IDM_DISTLIST_POPUP)); <br>                hDLPopupMenu = GetSubMenu (hDLPopupMenu, 0); <br> <br>                DWORD dwThreadID; <br>                HANDLE hThread = CreateThread (NULL, <br>                                               0, <br>                                               (LPTHREAD_START_ROUTINE)CancelThreadProc, <br>                                               NULL, <br>                                               0, <br>                                               &amp;dwThreadID); <br>                ASSERTMSG (hThread, "Failed to spawn cancel thread"); <br>                TraceDebugger ("MainWndProc: RPC cancel thread spawned. ID: %X", dwThreadID); <br>                CloseHandle (hThread); <br>            } <br>            break; <br> <br>        case WM_MEASUREITEM : <br>            { <br>                PMEASUREITEMSTRUCT pMIS = (PMEASUREITEMSTRUCT)lParam; <br>                TEXTMETRIC tm; <br>                HDC hdc; <br>                HFONT hFont; <br>                if (pMIS-&gt;CtlType == ODT_LISTVIEW) <br>                { <br>                    hFont = (HFONT)SendMessage (ghListView, WM_GETFONT, 0, 0L); <br>                    hdc = GetDC (ghListView); <br>                    SelectObject (hdc, hFont); <br>                    GetTextMetrics (hdc, &amp;tm); <br>         <br>                    pMIS-&gt;itemHeight = tm.tmHeight + 1; <br> <br>                    if (pMIS-&gt;itemHeight &lt; (18 + 1)) <br>                    { <br>                        pMIS-&gt;itemHeight = 18 + 1; <br>                    } <br>                    ReleaseDC (ghListView, hdc); <br>                } <br>            } <br>            return TRUE; <br> <br>        case WM_DRAWITEM : <br>            { <br>                PDRAWITEMSTRUCT pDIS = (PDRAWITEMSTRUCT)lParam; <br>                if (pDIS-&gt;CtlType != ODT_LISTVIEW) <br>                { <br>                    return FALSE; <br>                } <br>                switch (pDIS-&gt;itemAction) <br>                { <br>                    case ODA_DRAWENTIRE: <br>                    case ODA_FOCUS: <br>                    case ODA_SELECT: <br>                        DrawListViewItem (pDIS); <br>                        break; <br>                } <br>            } <br>            return TRUE; <br> <br>        case WM_PAINT : <br>            { <br>                PAINTSTRUCT ps; <br>                RECT rc; <br>                GetClientRect (hWnd, &amp;rc); <br>                BeginPaint (hWnd, &amp;ps); <br>                FillRect (ps.hdc, &amp;rc, hbrFace); <br>                EndPaint (hWnd, &amp;ps); <br>            } <br>            break; <br> <br>        case WM_MENUCHAR : <br>            if (LOWORD(wParam) == 13 &amp;&amp; 0 == HIWORD(wParam)) // 13 == RETURN <br>            { <br>                PostMessage (hWnd, WM_COMMAND, IDM_FILE_PROPERTIES, 0); <br>                return (BOOL)1; <br>            } <br>            break; <br> <br>        case WM_VKEYTOITEM : <br>            if ((HWND)lParam == ghListView) <br>            { <br>                if (LOWORD(wParam) == VK_DELETE) <br>                { <br>                    PostMessage (hWnd, WM_COMMAND, IDM_FILE_DELETE, 0); <br>                } <br>                else <br>                { <br>                    if (LOWORD(wParam) == VK_INSERT) <br>                    { <br>                        PostMessage (hWnd, WM_COMMAND, IDM_FILE_NEW_MAILBOX, 0); <br>                    } <br>                } <br>            } <br>            return (BOOL)-1; <br> <br>        case WM_SYSCOLORCHANGE : <br>            SendMessage (ghListView, message, wParam, lParam); <br>            SendMessage (ghTreeView, message, wParam, lParam); <br>            break; <br> <br>        case WM_WINDS_RESET_NOTIF_LINK : <br>            gpLink-&gt;EndNotifications(); <br>            gpLink-&gt;StartNotification(); <br>            break; <br>         <br>        case WM_WINDS_UPDATEHEADERWIDTH : <br>            UpdateHeaderWidth ((HWND)wParam, (int)lParam); <br>            break; <br> <br>        case WM_WINDS_REMOTE_CALL_IN_PROGRESS : <br>            fRPCInProgress = TRUE; <br>            SendMessage (ghToolBar, TB_SETSTATE, IDC_CANCEL_REMOTE_CALL, TBSTATE_ENABLED); <br>            break; <br> <br>        case WM_WINDS_REMOTE_CALL_COMPLETED : <br>            hCurrentCursor = LoadCursor (NULL, IDC_ARROW); <br>            SetCursor (hCurrentCursor); <br>            SendMessage (ghStatusBar, SB_SETTEXT, 0, (LPARAM)TEXT("Ready")); <br>            if (wParam) <br>            { <br>                ErrorHandler (hWnd, (HRESULT)wParam); <br>            } <br>            fRPCInProgress = FALSE; <br>            SendMessage (ghToolBar, TB_SETSTATE, IDC_CANCEL_REMOTE_CALL, TBSTATE_INDETERMINATE); <br>            break; <br> <br>        case WM_NOTIFY : <br>            switch (((LPNMHDR)lParam)-&gt;code) <br>            { <br>                case TTN_NEEDTEXT : <br>                    // Time to display a tool tip text box. Return the ID of <br>                    // the string in our resource table. The control will <br>                    // pick it up from there. <br>                    ((LPTOOLTIPTEXT)lParam)-&gt;hinst = ghInstance; <br>                    ((LPTOOLTIPTEXT)lParam)-&gt;lpszText = (LPTSTR)((LPTOOLTIPTEXT)lParam)-&gt;hdr.idFrom; <br>                    break; <br> <br>                case HDN_ENDTRACK: <br>                    { <br>                        HD_NOTIFY *phdn = (HD_NOTIFY *)lParam; <br>                        PostMessage (hWnd, <br>                                     WM_WINDS_UPDATEHEADERWIDTH, <br>                                     (WPARAM)phdn-&gt;hdr.hwndFrom, <br>                                     (LPARAM)phdn-&gt;iItem); <br>                    } <br>                    break; <br> <br>                case TVN_SELCHANGED : <br>                    { <br>                        DWORD dwThreadID; <br>                        HANDLE hThread = NULL; <br>                        NM_TREEVIEW * pNMTV = (NM_TREEVIEW *)lParam; <br>                        ITEM_TYPE tvItemType = (ITEM_TYPE)pNMTV-&gt;itemNew.lParam; <br>                        // Cancel the remote call in progress, if any <br>                        if (fRPCInProgress) <br>                        { <br>                            SetEvent (ghCancelEvent); <br>                        } <br>                        g_LVItemsType = ITEM_UNDEFINED_TYPE; <br>                         <br>                        // If necessary, reset the RPC binding to the new server <br>                        if (S_OK != ServerChanged (ghTreeView)) <br>                        { <br>                            break; <br>                        } <br> <br>                        switch (tvItemType) <br>                        { <br>                            case ITEM_SERVER_USER_MAILBOXES : <br>                                g_LVItemsType = ITEM_SERVER_USER_MAILBOXES; <br>                                hThread = CreateThread (NULL, <br>                                                        0, <br>                                                        (LPTHREAD_START_ROUTINE)GetServerMailboxes, <br>                                                        (LPVOID)hWnd, <br>                                                        CREATE_SUSPENDED, <br>                                                        &amp;dwThreadID); <br>                                break; <br>                            case ITEM_SERVER_DIST_LISTS : <br>                                g_LVItemsType = ITEM_SERVER_DIST_LISTS; <br>                                hThread = CreateThread (NULL, <br>                                                        0, <br>                                                        (LPTHREAD_START_ROUTINE)GetServerDistLists, <br>                                                        (LPVOID)hWnd, <br>                                                        CREATE_SUSPENDED, <br>                                                        &amp;dwThreadID); <br>                                break; <br>                            default : <br>                                ListView_DeleteAllItems (ghListView); <br>                                break; <br>                        } <br>                        if (hThread) <br>                        { <br>                            hCurrentCursor = LoadCursor (NULL, IDC_APPSTARTING); <br>                            SetCursor (hCurrentCursor); <br>                            ResumeThread (hThread); <br>                            CloseHandle (hThread); <br>                            TraceDebugger ("MainWndProc: RPC worker thread spawned. ID: %X", dwThreadID); <br>                        } <br>                    } <br>                    break; <br> <br>                case NM_RCLICK : <br>                case NM_DBLCLK : <br>                    if (((LPNMHDR)lParam)-&gt;idFrom == IDC_LISTVIEW) <br>                    { <br>                        if (NM_RCLICK == ((LPNMHDR)lParam)-&gt;code) <br>                        { <br>                            HMENU hMenu = NULL; <br>                            switch (g_LVItemsType) <br>                            { <br>                                case ITEM_SERVER_USER_MAILBOXES : <br>                                    hMenu = hMBPopupMenu; <br>                                    break; <br>                                case ITEM_SERVER_DIST_LISTS : <br>                                    hMenu = hDLPopupMenu; <br>                                    break; <br>                            } <br>                            POINT pt; <br>                            GetCursorPos (&amp;pt); <br>                            TrackPopupMenu (hMenu,  <br>                                            TPM_CENTERALIGN | TPM_LEFTBUTTON, <br>                                            pt.x, <br>                                            pt.y, <br>                                            0, <br>                                            hWnd, <br>                                            NULL); <br>                        } <br>                        else <br>                        { <br>                            PostMessage (hWnd, WM_COMMAND, IDM_POPUP_MB_PROPS, 0); <br>                        } <br>                    } <br>                    break; <br>            } <br>            break; <br> <br>        case WM_COMMAND : <br>            // If a background thread is download something, we can't <br>            // allow many things to happen. <br>            if (fRPCInProgress &amp;&amp;  <br>                IDM_ABOUT != LOWORD(wParam) &amp;&amp; <br>                IDC_CANCEL_REMOTE_CALL != LOWORD(wParam) &amp;&amp; <br>                IDM_FILE_EXIT != LOWORD(wParam)) <br>            { <br>                PrivateMessageBox (IDS_MSG_WAIT_FOR_COMPLETION, <br>                                   hWnd, <br>                                   MB_OK | <br>                                   MB_ICONEXCLAMATION| <br>                                   MB_SETFOREGROUND); <br>                break; <br>            } <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDM_ABOUT : <br>                    DialogBox (ghInstance, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, AboutDlgProc); <br>                    break; <br> <br>                case IDM_SERVER_EXPORT : <br>                    DialogBox (ghInstance, MAKEINTRESOURCE(IDD_EXPORT), hWnd, ExportDlgProc); <br>                    break; <br> <br>                case IDM_SERVER_IMPORT : <br>                    DialogBox (ghInstance, MAKEINTRESOURCE(IDD_IMPORT), hWnd, ImportDlgProc); <br>                    break; <br> <br>                case IDC_CANCEL_REMOTE_CALL : <br>                    SetEvent (ghCancelEvent); <br>                    break; <br> <br>                case IDM_FILE_PROPERTIES : <br>                case IDM_FILE_DELETE : <br>                case IDM_POPUP_MB_PROPS : <br>                case IDM_POPUP_MB_EMPTY : <br>                case IDM_POPUP_MB_HEADERS : <br>                case IDM_POPUP_MB_DELETE : <br>                    { <br>                        int nItem = ListView_GetNextItem (ghListView, -1, LVNI_FOCUSED | LVNI_ALL); <br>                        if (-1 == nItem) <br>                        { <br>                            break; <br>                        } <br>                        HandleItemAction (hWnd, nItem, LOWORD(wParam)); <br>                    } <br>                    break; <br> <br>                case IDM_FIND_MAILBOX : <br>                    break; <br> <br>                case IDM_FILE_NEW_MAILBOX : <br>                    CreateNewMailbox (hWnd); <br>                    break; <br> <br>                case IDM_FILE_NEW_DISTRIBUTIONLIST : <br>                    CreateNewDistList (hWnd); <br>                    break; <br> <br>                case IDM_VIEW_DISCONNECT : <br>                    DialogBox (ghInstance, MAKEINTRESOURCE(IDD_REMOVE_SERVER), hWnd, RemoveServersDlgProc); <br>                    break; <br> <br>                case IDM_VIEW_CONNECT : <br>                    { <br>                        TCHAR szNewServer[64] = { 0 }; <br>                        BOOL fServerIsOnline = FALSE; <br>                        if (ShowConnectDialog (hWnd, szNewServer, &amp;fServerIsOnline) &amp;&amp; <br>                            fServerIsOnline) <br>                        { <br>                            AddServerToList (szNewServer, (NULL == g_szCurrentServer[0] ? TRUE : FALSE)); <br>                            if (NULL == g_szCurrentServer[0]) <br>                            { <br>                                lstrcpy (g_szCurrentServer, szNewServer); <br>                            } <br>                        } <br>                    } <br>                    break; <br> <br>                case IDM_FILE_EXIT : <br>                    // Terminate the application <br>                    PostMessage (hWnd, WM_CLOSE, 0, 0); <br>                    break; <br>            } <br>            break; <br> <br>        case WM_QUERYENDSESSION : <br>        case WM_DESTROY : <br>            gfTerminate = TRUE; <br>            SetEvent (ghCancelEvent); <br>             <br>            DeleteObject (hbrFace); <br>            DeleteObject (ghBoldFont); <br>            ImageList_Destroy (g_hImages); <br>            ImageList_Destroy (g_hIconImgs); <br>            DestroyWindow (ghListView); <br>            DestroyWindow (ghTreeView); <br>            DestroyWindow (ghStatusBar); <br>            DestroyWindow (ghToolBar); <br>            DestroyMenu (hMBPopupMenu); <br>            DestroyMenu (hDLPopupMenu); <br>            PostQuitMessage (0); <br>            break; <br> <br>        default : <br>            return DefWindowProc (hWnd, message, wParam, lParam); <br>    } <br>    return 0; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    HandleItemAction() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI HandleItemAction (HWND hOwnerWnd, int nItem, WORD wAction) <br>{ <br>    LV_ITEM lvi = { 0 }; <br>    lvi.mask = LVIF_PARAM; <br>    lvi.iItem = nItem; <br>    lvi.iSubItem = 0; <br>    if (FALSE == ListView_GetItem (ghListView, &amp;lvi)) <br>    { <br>        return; <br>    } <br>    switch (wAction) <br>    { <br>        case IDM_FILE_PROPERTIES : <br>        case IDM_POPUP_MB_PROPS : <br>            switch (g_LVItemsType) <br>            { <br>                case ITEM_SERVER_USER_MAILBOXES : <br>                    ShowMailboxProps (hOwnerWnd, lvi.lParam); <br>                    break; <br>                case ITEM_SERVER_DIST_LISTS : <br>                    ShowDistListProps (hOwnerWnd, lvi.lParam); <br>                    break; <br>                case ITEM_SERVER_FOREIGN_MAILBOXES : <br>                    TraceMessage ("Properties of Foreign Recipient"); <br>                    break; <br>                case ITEM_SERVER_PUBLIC_FOLDERS : <br>                    TraceMessage ("Properties of public folder"); <br>                    break; <br>                case ITEM_SERVER_GATEWAYS : <br>                    TraceMessage ("Properties of Server gateway"); <br>                    break; <br>            } <br>            break; <br> <br>        case IDM_POPUP_MB_EMPTY : <br>            if (ITEM_SERVER_USER_MAILBOXES == g_LVItemsType) <br>            { <br>                PurgeMailboxMessages (hOwnerWnd, lvi.lParam); <br>            } <br>            break; <br> <br>        case IDM_FILE_DELETE : <br>        case IDM_POPUP_MB_DELETE : <br>            switch (g_LVItemsType) <br>            { <br>                case ITEM_SERVER_USER_MAILBOXES : <br>                case ITEM_SERVER_DIST_LISTS : <br>                    DeleteServerObject (hOwnerWnd, lvi.lParam); <br>                    break; <br>                case ITEM_SERVER_FOREIGN_MAILBOXES : <br>                    TraceMessage ("Delete Foreign Recipient"); <br>                    break; <br>                case ITEM_SERVER_PUBLIC_FOLDERS : <br>                    TraceMessage ("Delete Public folder"); <br>                    break; <br>            } <br>            break; <br> <br>        case IDM_POPUP_MB_HEADERS : <br>            TraceMessage ("View mailbox headers"); <br>            break; <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    AboutDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//      Displays a dialog box with the copyright and program information <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK AboutDlgProc (HWND    hDlg,  <br>                            UINT    message,  <br>                            WPARAM  wParam,  <br>                            LPARAM  lParam) <br>{ <br>    if (WM_INITDIALOG == message) <br>    { <br>        CenterDialogBox (hDlg); <br>        return TRUE; <br>    } <br>    else <br>    { <br>        if (WM_COMMAND == message &amp;&amp; (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)) <br>        {    <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    AddServerToList() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>void WINAPI AddServerToList (LPTSTR szServer, BOOL fExpandRoot) <br>{ <br>    HTREEITEM hItem, hRoot; <br>    TV_INSERTSTRUCT tvIns = { 0 }; <br>    TV_ITEM tvItem =  <br>    { <br>        TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM, <br>        NULL, <br>        0, <br>        0, <br>        NULL, <br>        0, <br>        IMG_SERVER, <br>        IMG_SERVER, <br>        0, <br>        NULL <br>    }; <br>    TCHAR szName[128]; <br> <br>    // Add the root item <br>    wsprintf (szName, TEXT("WINDS Server: %s"), szServer); <br>    tvItem.pszText = szName, <br>    tvIns.hParent = NULL; <br>    tvItem.lParam = (LPARAM)ITEM_REMOTE_SERVER; <br>    tvIns.item    = tvItem; <br>    hRoot = TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    // Add the "Object Directory" item <br>    tvItem.pszText = TEXT("Object Directory"); <br>    tvItem.iImage = IMG_MAILABLE_OBJECTS_CLOSE; <br>    tvItem.iSelectedImage = IMG_MAILABLE_OBJECTS_OPEN; <br>    tvItem.lParam = (LPARAM)ITEM_OBJECT_DIRECTORY; <br>    tvIns.hParent = hRoot; <br>    tvIns.item    = tvItem; <br>    hItem = TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    // Add the "User Mailboxes" item <br>    tvItem.pszText = TEXT("User Mailboxes"); <br>    tvItem.iImage = IMG_USER; <br>    tvItem.iSelectedImage = IMG_USER; <br>    tvItem.lParam  = (LPARAM)ITEM_SERVER_USER_MAILBOXES; <br>    tvIns.hParent = hItem; <br>    tvIns.item    = tvItem; <br>    TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    // Add the "Server DLs" item <br>    tvItem.pszText = TEXT("Server Distribution Lists"); <br>    tvItem.iImage = IMG_MAIL_GROUP; <br>    tvItem.iSelectedImage = IMG_MAIL_GROUP; <br>    tvItem.lParam  = (LPARAM)ITEM_SERVER_DIST_LISTS; <br>    tvIns.hParent = hItem; <br>    tvIns.item = tvItem; <br>    TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    // Add the "Foreign Entries" item <br>    tvItem.pszText = TEXT("Foreign Mailboxes"); <br>    tvItem.iImage = IMG_FOREIGN_USER; <br>    tvItem.iSelectedImage = IMG_FOREIGN_USER; <br>    tvItem.lParam = (LPARAM)ITEM_SERVER_FOREIGN_MAILBOXES; <br>    tvItem.lParam = NULL; <br>    tvIns.hParent = hItem; <br>    tvIns.item = tvItem; <br>    TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    TreeView_Expand (ghTreeView, hItem, TVE_EXPAND); <br> <br>    tvItem.pszText = TEXT("Public Folders"); <br>    tvItem.iImage = IMG_SERVER_PUB_FOLDER; <br>    tvItem.iSelectedImage = IMG_SERVER_PUB_FOLDER; <br>    tvItem.lParam = (LPARAM)ITEM_SERVER_PUBLIC_FOLDERS; <br>    tvIns.hParent = hRoot; <br>    tvIns.item = tvItem; <br>    TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    tvItem.pszText = TEXT("Gateways"); <br>    tvItem.iImage = IMG_SERVER_GATEWAY; <br>    tvItem.iSelectedImage = IMG_SERVER_GATEWAY; <br>    tvItem.lParam = (LPARAM)ITEM_SERVER_GATEWAYS; <br>    tvIns.hParent = hRoot; <br>    tvIns.item = tvItem; <br>    hItem = TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    tvItem.pszText = TEXT("Exchange Gateway"); <br>    tvItem.iImage = IMG_GATEWAY; <br>    tvItem.iSelectedImage = IMG_GATEWAY; <br>    tvItem.lParam = (LPARAM)ITEM_SERVER_GATEWAYS; <br>    tvIns.hParent = hItem; <br>    tvIns.item = tvItem; </code></pre>
<p>
</p>
<pre><code>TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    tvItem.pszText = TEXT("SMTP Gateway"); <br>    tvItem.iImage = IMG_GATEWAY; <br>    tvItem.iSelectedImage = IMG_GATEWAY; <br>    tvItem.lParam = (LPARAM)ITEM_SERVER_GATEWAYS; <br>    tvIns.hParent = hItem; <br>    tvIns.item = tvItem; <br>    TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    tvItem.pszText = TEXT("FAX Gateway"); <br>    tvItem.iImage = IMG_GATEWAY; <br>    tvItem.iSelectedImage = IMG_GATEWAY; <br>    tvItem.lParam = (LPARAM)ITEM_SERVER_GATEWAYS; <br>    tvIns.hParent = hItem; <br>    tvIns.item = tvItem; <br>    TreeView_InsertItem (ghTreeView, &amp;tvIns); <br> <br>    TreeView_Expand (ghTreeView, hItem, TVE_EXPAND); <br> <br>    if (fExpandRoot) <br>    { <br>        TreeView_Expand (ghTreeView, hRoot, TVE_EXPAND); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CancelThreadProc() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CancelThreadProc() <br>{ <br>    while (TRUE) <br>    { <br>        WaitForSingleObject (ghCancelEvent, INFINITE); <br>        if (gfTerminate) <br>        { <br>            break; // Out of the WHILE() loop <br>        } <br>        EnterCriticalSection (&amp;csCancel); <br>        gfCancel = TRUE; <br>        LeaveCriticalSection (&amp;csCancel); <br>    } <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    LoadSettingsFromRegistry() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//      None <br>//       <br>void WINAPI LoadSettingsFromRegistry (LPTSTR szServer) <br>{ <br>    HKEY hAppKey; <br>    // Try to open the key in the registry, open it with READ rights, <br>    // and read the data into our strcture <br>    if (ERROR_SUCCESS == RegOpenKeyEx (HKEY_CURRENT_USER, <br>                                       WINDS_ADMIN_REGISTRY_KEY, <br>                                       0, <br>                                       KEY_READ, <br>                                       &amp;hAppKey)) <br>    { <br>        ULONG cbSize = 64; <br>        DWORD dwError = RegQueryValueEx (hAppKey, <br>                                         SERVER_SUB_KEY, <br>                                         NULL, <br>                                         NULL, <br>                                         (LPBYTE)szServer, <br>                                         &amp;cbSize); <br>        RegCloseKey (hAppKey); <br>        // If we failed to get the data from the registry we can't return <br>        // yet, we will proceed to initialize the options with default <br>        // values <br>        if (ERROR_SUCCESS == dwError) <br>        { <br>            return; <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    SaveSettingsToRegistry() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      None <br>//       <br>void WINAPI SaveSettingsToRegistry (LPTSTR szServer) <br>{ <br>    HKEY hAppKey; <br>    DWORD dwDisposition; <br>    // Try to open the key in the registry, open it with READ/WRITE rights <br>    if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_CURRENT_USER, <br>                                         WINDS_ADMIN_REGISTRY_KEY, <br>                                         0, <br>                                         NULL, <br>                                         REG_OPTION_NON_VOLATILE, <br>                                         KEY_WRITE, <br>                                         NULL, <br>                                         &amp;hAppKey, <br>                                         &amp;dwDisposition)) <br>    { <br>        // If we fail to access the registry, we need to get out, we don't <br>        // have a key opened where to write <br>        TraceResult ("SaveSettingsToRegistry: Failed to open app key", HRESULT_FROM_WIN32(GetLastError())); <br>    } <br>    else <br>    { <br>        // With the opened key handle, create a sub entry where we save our <br>        // structure values. For this sample we just write the entire <br>        // structure as a big blob of data, which we read the save way. <br>        if (ERROR_SUCCESS != RegSetValueEx (hAppKey, <br>                                            SERVER_SUB_KEY, <br>                                            0, <br>                                            REG_SZ, <br>                                            (LPBYTE)szServer, <br>                                            (1+lstrlen(szServer))*sizeof(TCHAR))) <br>        { <br>            TraceResult ("SaveSettingsToRegistry: Failed to save registry values", HRESULT_FROM_WIN32(GetLastError())); <br>        } <br>        // Close the handle we have open and return the appropiate flag <br>        RegCloseKey (hAppKey); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ShowConnectDialog() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      None <br>//       <br>BOOL WINAPI ShowConnectDialog (HWND hOwnerWnd, LPTSTR szServer, BOOL * pfServerIsOnLine) <br>{ <br>    *pfServerIsOnLine = FALSE; <br>    BOOL bResult = FALSE; <br>    if (lstrlen(szServer)) <br>    { <br>        goto ConnectToServer; <br>    } <br>ReEnterServerName: <br>    // Free any previous bindings <br>    BindToServer (NULL); <br>    SetCursor (LoadCursor (NULL, IDC_ARROW)); <br>    if (TRUE == DialogBoxParam (ghInstance, <br>                                MAKEINTRESOURCE(IDD_SERVER_CONNECT), <br>                                hOwnerWnd, <br>                                ServerConnectDlgProc, <br>                                (LPARAM)szServer)) <br>    { <br>ConnectToServer: <br>        SetCursor (LoadCursor (NULL, IDC_WAIT)); <br>        HRESULT hResult = BindToServer (szServer); <br>        if (!hResult) <br>        { <br>            RpcTryExcept <br>            { <br>                hResult = RemoteAdmIsServerRunning(); <br>                if (!hResult) <br>                { <br>                    *pfServerIsOnLine = TRUE; <br>                } <br>            } <br>            RpcExcept(1) <br>            {         <br>                // If we got here is because there was an error while call was made <br>                // or when it was about to be made. <br>                hResult = RpcExceptionCode(); <br>                if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>                { <br>                    hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>                } <br>                else <br>                { <br>                    hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>                } <br>            } <br>            RpcEndExcept <br>            switch (hResult) <br>            { <br>                case S_OK : <br>                    break; <br>                case HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE) : <br>                    SetCursor (LoadCursor (NULL, IDC_ARROW)); <br>                    if (IDYES == PrivateMessageBox (IDS_MSG_SERVER_NOT_FOUND, <br>                                                    hOwnerWnd, <br>                                                    MB_YESNO | <br>                                                    MB_ICONSTOP | <br>                                                    MB_SETFOREGROUND)) <br>                    { <br>                        goto ReEnterServerName; <br>                    } <br>                    break; <br>                default : <br>                    TraceResult ("ShowConnectDialog", hResult); <br>                    goto ReEnterServerName; <br>                    break; <br>            } <br>            bResult = TRUE; <br>        } <br>    } <br>    SetCursor (LoadCursor (NULL, IDC_ARROW)); <br>    BindToServer (g_szCurrentServer); <br>    return bResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ServerConnectDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK ServerConnectDlgProc (HWND    hDlg,  <br>                                    UINT    message,  <br>                                    WPARAM  wParam,  <br>                                    LPARAM  lParam) <br>{ <br>    static LPTSTR szServer; <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            szServer = (LPTSTR)lParam; <br>            CenterDialogBox (hDlg); <br>            Edit_LimitText (GetDlgItem (hDlg, IDC_SERVER_NAME), 32); <br>            SetFocus (GetDlgItem (hDlg, IDC_SERVER_NAME)); <br>            if (NULL == g_szCurrentServer[0]) <br>            { <br>                Button_SetCheck (GetDlgItem (hDlg, IDC_SERVER_DEFAULT), BST_CHECKED); <br>            } <br>            Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                            ImageList_GetIcon (g_hIconImgs, ICON_CONNECT, ILD_NORMAL)); <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDOK : <br>                    if (GetWindowText (GetDlgItem (hDlg, IDC_SERVER_NAME), szServer, 64)) <br>                    { <br>                        if (FALSE == IsValidServerName (szServer)) <br>                        { <br>                            PrivateMessageBox (IDS_MSG_INVALID_SERVER_NAME, hDlg, 0); <br>                            return TRUE; <br>                        } <br>                        BOOL fDuplicate = FALSE; <br>                        TCHAR szBuffer[128], *szConnectedServer; <br>                        TV_ITEM tvItem = { 0 }; <br>                        tvItem.mask = TVIF_TEXT; <br>                        tvItem.pszText = szBuffer; <br>                        tvItem.cchTextMax = 128; <br>                        HTREEITEM hItem = TreeView_GetRoot (ghTreeView); <br>                        while (hItem) <br>                        { <br>                            tvItem.hItem = hItem; <br>                            if (TRUE == TreeView_GetItem (ghTreeView, &amp;tvItem)) <br>                            { <br>                                GetServerNameFromTitle (szBuffer, &amp;szConnectedServer); <br>                                if (0 == lstrcmpi(szServer, szConnectedServer)) <br>                                { <br>                                    fDuplicate = TRUE; <br>                                    break; // Out of the WHILE() loop <br>                                } <br>                            } <br>                            hItem = TreeView_GetNextItem (ghTreeView, hItem, TVGN_NEXT); <br>                        } <br>                        if (fDuplicate) <br>                        { <br>                            wParam = IDCANCEL; <br>                        } <br>                        else <br>                        { <br>                            if (BST_CHECKED == Button_GetCheck (GetDlgItem (hDlg, IDC_SERVER_DEFAULT))) <br>                            { <br>                                SaveSettingsToRegistry (szServer); <br>                            } <br>                        } <br>                    } <br>                    else <br>                    { <br>                        return TRUE; <br>                    } <br>                    // fall through <br>                case IDCANCEL : <br>                    EndDialog (hDlg, (LOWORD(wParam) == IDOK ? TRUE : FALSE)); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    IsValidServerName() <br>// <br>//    Parameters <br>//      pszServerName       Pointer to a string with the UNC name of a <br>//                          network or local server <br>//    Purpose <br>//      Check the string for a server name and determines if the name is a <br>//      valid UNC name for a network server <br>// <br>//    Return Value <br>//      TRUE if the server name is valid, FALSE otherwise. <br>//       <br>BOOL WINAPI IsValidServerName (LPTSTR pszServerName) <br>{ <br>    // Server name need to be at least "\\x" <br>    if (lstrlen(pszServerName) &lt; 3) <br>    { <br>        return FALSE; <br>    } <br>    // The first two character in the string must be "\". This is standard <br>    // UNC (Universal Naming Convention) for server names <br>    if (pszServerName[0] != '\\' || pszServerName[1] != '\\') <br>    { <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoveServersDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK RemoveServersDlgProc (HWND    hDlg,  <br>                                    UINT    message,  <br>                                    WPARAM  wParam,  <br>                                    LPARAM  lParam) <br>{ <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            { <br>                CenterDialogBox (hDlg); <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hListView = GetDlgItem (hDlg, IDC_SERVER_LIST); <br>                ListView_SetImageList (hListView, g_hImages, LVSIL_SMALL); <br>                RECT rc; <br>                GetClientRect (hListView, &amp;rc); <br>                LV_COLUMN lvc = { 0 }; <br>                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; <br>                lvc.fmt = LVCFMT_LEFT; <br>                lvc.pszText = TEXT("Server Name"); <br>                lvc.cx = rc.right - rc.left; <br>                ListView_InsertColumn (hListView, 0, &amp;lvc); <br> <br>                TCHAR szBuffer[128]; <br> <br>                LV_ITEM lvi = { 0 }; <br>                lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br>                lvi.iImage = IMG_SERVER; <br>                 <br>                TV_ITEM tvItem = { 0 }; <br>                tvItem.mask = TVIF_TEXT; <br>                tvItem.pszText = szBuffer; <br>                tvItem.cchTextMax = 128; <br>                HTREEITEM hItem = TreeView_GetRoot (ghTreeView); <br>                while (hItem) <br>                { <br>                    tvItem.hItem = hItem; <br>                    if (TRUE == TreeView_GetItem (ghTreeView, &amp;tvItem)) <br>                    { <br>                        GetServerNameFromTitle (szBuffer, &amp;lvi.pszText); <br>                        lvi.lParam = (LPARAM)hItem; <br>                        ListView_InsertItem (hListView, &amp;lvi); <br>                        lvi.iItem++; <br>                    } <br>                    hItem = TreeView_GetNextItem (ghTreeView, hItem, TVGN_NEXT); <br>                } <br>            } <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDOK : <br>                    { <br>                        HWND hListView = GetDlgItem (hDlg, IDC_SERVER_LIST); <br>                        TCHAR szBuffer[128]; <br>                        BOOL fSuccess; <br>                        LV_ITEM lvi = { 0 }; <br>                        lvi.mask = LVIF_TEXT | LVIF_PARAM; <br>                        lvi.pszText = szBuffer; <br>                        lvi.cchTextMax = 128; <br>                        lvi.iItem = ListView_GetNextItem (hListView, -1, LVNI_SELECTED); <br>                        while (-1 != lvi.iItem) <br>                        { <br>                            if (TRUE == ListView_GetItem (hListView, &amp;lvi)) <br>                            { <br>                                fSuccess = TreeView_DeleteItem (ghTreeView, (HTREEITEM)lvi.lParam); <br>                                if (fSuccess &amp;&amp; 0 == lstrcmpi (g_szCurrentServer, szBuffer)) <br>                                { <br>                                    gpLink-&gt;EndNotifications(); <br>                                    BindToServer (NULL); <br>                                    ZeroMemory (g_szCurrentServer, sizeof(g_szCurrentServer)); <br>                                    ListView_DeleteAllItems (ghListView); <br>                                } <br>                            } <br>                            lvi.iItem = ListView_GetNextItem (hListView, lvi.iItem, LVNI_SELECTED); <br>                        } <br>                    } <br>                    // fall through <br>                case IDCANCEL : <br>                    ListView_SetImageList (GetDlgItem (hDlg, IDC_SERVER_LIST), NULL, LVSIL_SMALL); <br>                    EndDialog (hDlg, (LOWORD(wParam) == IDOK ? TRUE : FALSE)); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetServerNameFromTitle() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI GetServerNameFromTitle (LPTSTR szItemTitle, LPTSTR * pszServerName) <br>{ <br>    LPTSTR pStr = &amp;(szItemTitle[lstrlen (szItemTitle)]); <br>    while ('\\' != *pStr) <br>    { <br>        pStr--; <br>    } <br>    pStr--; <br>    *pszServerName = pStr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ServerChanged() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI ServerChanged (HWND hTreeView) <br>{ <br>    HTREEITEM hParent, hItem = TreeView_GetSelection (hTreeView); <br>    do <br>    { <br>        hParent = TreeView_GetParent (hTreeView, hItem); <br>        if (hParent) <br>        { <br>            hItem = hParent; <br>        } <br>    } while (hParent); <br>     <br>    LPTSTR szServerName; <br>    HRESULT hResult = S_OK;; <br>    TCHAR szBuffer[128]; <br>    TV_ITEM tvItem = { 0 }; <br>    tvItem.mask = TVIF_TEXT; <br>    tvItem.pszText = szBuffer; <br>    tvItem.cchTextMax = 128; <br>    tvItem.hItem = hItem; <br>    if (TRUE == TreeView_GetItem (hTreeView, &amp;tvItem)) <br>    { <br>        GetServerNameFromTitle (szBuffer, &amp;szServerName); <br>        if (szServerName &amp;&amp; lstrcmpi (g_szCurrentServer, szServerName) &amp;&amp; szServerName[0]) <br>        { <br>            // Terminate the notifications with the current selected server <br>            gpLink-&gt;EndNotifications(); <br>            // Release the RPC binding resources <br>            BindToServer (NULL); <br>            // Copy the server name to the global buffer <br>            lstrcpy (g_szCurrentServer, szServerName); <br>            // Set the RPC binding resources to point to the new server <br>            BindToServer (g_szCurrentServer); <br>            // Establish notification with the new server we are talking to <br>            gpLink-&gt;StartNotification(); <br>        } <br>    } <br>    else <br>    { <br>        hResult = E_FAIL; <br>    } <br>    return hResult; <br>} <br> <br>// End of file for ADMIN.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
