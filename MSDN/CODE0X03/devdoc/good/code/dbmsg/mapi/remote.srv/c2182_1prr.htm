<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STORAGE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2187"></a>STORAGE.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      STORAGE.CPP <br>// <br>//  Description <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "_WINDS.H" <br>#include "WDSADM.H"    // Header file generated by the MIDL compiler <br>#include "COMMON.H" <br>#include "STDIO.H" <br> <br>// Remark this line to turn verbose tracing OFF <br>#define DO_INFO_TRACES <br>#ifdef DO_INFO_TRACES <br>#define InfoTrace(a)        TraceInfoMessage(a) <br>#define InfoTraceRaw(a)     TraceRaw(a) <br>#define InfoTraceProp(a)    TraceProp(a) <br>#else <br>#define InfoTrace(a)        0 <br>#define InfoTraceRaw(a)     0 <br>#define InfoTraceProp(a)    0 <br>#endif // DO_INFO_TRACES <br> <br>extern "C" <br>{ <br>    HRESULT WINAPI LoadObjectProperties <br>                        (LPSTORAGE                  pStorage, <br>                         WINDS_AB_OBJTYPE           Type, <br>                         LPTSTR                     pszObjectType, <br>                         LPMALLOC                   pMalloc); <br>    HRESULT WINAPI GetDLProperties <br>                        (LPSTORAGE                  pStorage, <br>                         LPOLESTR                   pwcsDLName, <br>                         PDIST_LIST_INFO            pDLInfo, <br>                         BOOL                       fGetMembers = FALSE); <br>    HRESULT WINAPI SetDLProperties <br>                        (LPSTORAGE                  pStorage, <br>                         LPOLESTR                   pwcsDLName, <br>                         PDIST_LIST_INFO            pDLInfo); <br>    HRESULT WINAPI DLPropsAndMembers <br>                        (LPSTORAGE                  pStorage, <br>                         PDIST_LIST_INFO            pDLInfo, <br>                         BOOL                       fGetProps); <br>    HRESULT WINAPI CreateDistributionList <br>                        (LPSTORAGE                  pStorage, <br>                         PDIST_LIST_INFO            pDLInfo); <br>    HRESULT WINAPI DeleteDistributionList <br>                        (LPSTORAGE                  pStorage, <br>                         PDIST_LIST_INFO            pDLInfo); <br>    HRESULT WINAPI GetNextObjID <br>                        (LPSTORAGE                  pStorage, <br>                         DWORD &amp;                    dwNextID); <br>    HRESULT WINAPI ReadABContainerInfo <br>                        (LPSTORAGE                  pStorage, <br>                         LPMALLOC                   pMalloc, <br>                         DWORD                      dwContainerID, <br>                         HANDLE                     hPipe); <br>    HRESULT WINAPI EnumContainerObjs <br>                        (LPSTORAGE                  pDirectoryStg, <br>                         HANDLE                     hPipe, <br>                         WINDS_AB_OBJTYPE           Type, <br>                         LPMALLOC                   pMalloc); <br>    HRESULT WINAPI GetDLRecipientsInfo <br>                        (LPSTORAGE                  pMBDirectory, <br>                         LPSTORAGE                  pDLDirectory, <br>                         HANDLE                     hPipe, <br>                         LPOLESTR                   pwcsDLName); <br>    HRESULT WINAPI CreateMailbox <br>                        (LPSTORAGE                  pMBDirectory, <br>                         PMAILBOX_INFO              pMBInfo); <br>    HRESULT WINAPI MailboxProps <br>                        (LPSTORAGE                  pMBDirectory, <br>                         PMAILBOX_INFO              pMBInfo, <br>                         BOOL                       fRetrieve); <br>    HRESULT WINAPI GetGWContainerCount <br>                        (LPSTORAGE                  pStorage, <br>                         LPMALLOC                   pMalloc, <br>                         DWORD                      dwContainerID, <br>                         DWORD *                    pdwContainerCount); <br>    HRESULT WINAPI CopyMsgFromFile <br>                        (LPSTORAGE                  pStorage, <br>                         HANDLE                     hFile, <br>                         LPTSTR                     pszMailbox, <br>                         LPTSTR                     pszHeader); <br>    HRESULT WINAPI RemoveMessageFromMailbox <br>                        (LPSTORAGE                  pStorage, <br>                         LPTSTR                     pszMailbox, <br>                         DWORD                      dwStreamID); <br>    HRESULT WINAPI UpdateMailboxHeaders <br>                        (LPSTORAGE                  pStorage, <br>                         LPSTORAGE                  pMBStg, <br>                         LPTSTR                     pszMailbox, <br>                         DWORD                      dwStreamID, <br>                         LPTSTR                     pszHeader, <br>                         BOOL                       fAddMsgToHeadersList); <br>    HRESULT WINAPI LoadServerObjects <br>                        (LPSTORAGE                  pStorage, <br>                         LPMALLOC                   pMalloc); <br>    HRESULT WINAPI OpenMsgsDataFile <br>                        (LPSTORAGE *                ppStorage); <br>    HRESULT WINAPI GetMailBoxInfo <br>                        (LPSTORAGE                  pStorage, <br>                         LPOLESTR                   pwcsName, <br>                         PMAILBOX_INFO              pInfo); <br>    HRESULT WINAPI SetMailBoxInfo <br>                        (LPSTORAGE                  pStorage, <br>                         LPOLESTR                   pwcsName, <br>                         PMAILBOX_INFO              pInfo); <br>    HRESULT WINAPI DeleteMailbox <br>                        (LPSTORAGE                  pStorage, <br>                         PMAILBOX_INFO              pInfo); <br>    HRESULT WINAPI EmptyMailBoxMsgs <br>                        (LPSTORAGE                  pStorage, <br>                         LPTSTR                     pszMailbox); <br>    HRESULT WINAPI CopyHeadersToFile <br>                        (LPSTORAGE                  pStorage, <br>                         LPMALLOC                   pMalloc, <br>                         HANDLE                     hFile, <br>                         LPTSTR                     pszMailbox); <br>    HRESULT WINAPI CopyMsgToFile <br>                        (LPSTORAGE                  pStorage, <br>                         LPTSTR                     pszMailbox, <br>                         HANDLE                     hFile, <br>                         ULONG *                    pulMsgLen, <br>                         DWORD                      dwStreamID, <br>                         BOOL                       fDeleteAfterCopy); <br>    HRESULT WINAPI CopyStreamToFile <br>                        (LPSTREAM                   pStream, <br>                         HANDLE                     hFile, <br>                         ULONG *                    pulWritten); <br>    HRESULT WINAPI CheckForPendingMailboxMsgs <br>                        (LPSTORAGE                  pStorage, <br>                         LPMALLOC                   pMalloc, <br>                         LPTSTR                     szMailbox, <br>                         DWORD *                    pdwMsgCount); <br>    HRESULT WINAPI GetNextMailboxMsg <br>                        (LPSTORAGE                  pStorage, <br>                         LPMALLOC                   pMalloc, <br>                         LPTSTR                     szMailbox, <br>                         DWORD *                    pdwMsgID, <br>                         HANDLE                     hFile); <br>}; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WorkingIOProc() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>DWORD WINAPI WorkingIOProc() <br>{ <br>    //InfoTrace ("WorkingIOProc: Just starting up"); <br>    // Standard COM initialization so that we may use IStorage and IStream <br>    LPMALLOC pMalloc; <br>    HRESULT hResult = CoInitialize (NULL); <br>    TraceResult ("WorkingIOProc: Failed to initialize the COM libraries", hResult); <br>    if (!hResult) <br>    { <br>        hResult = CoGetMalloc (MEMCTX_TASK, &amp;pMalloc); <br>        TraceResult ("WorkingIOProc: Failed to get an IMalloc interface", hResult); <br>    } <br>    if (FAILED(hResult)) <br>    { <br>        InfoTrace ("WorkingIOProc: Just bailing out now"); <br>        CoUninitialize(); <br>        g_hServerState = CO_E_NOTINITIALIZED; <br>        return g_hServerState; <br>    } <br>    LPSTORAGE pStorage = NULL; <br>     <br>    DWORD dwException = 0; <br> <br>    while (TRUE) <br>    { <br>        WaitForSingleObject (g_IOInfo.hResumeEvent, INFINITE); <br>        //InfoTrace ("WorkingIOProc: Resumed. About to request the critical section..."); <br>        EnterCriticalSection (&amp;g_csIOInfo); <br>        //InfoTrace ("WorkingIOProc: ...Executing in critical section"); <br>        if (g_IOInfo.fAppIsTerminating) <br>        { <br>            InfoTrace ("WorkingIOProc: We are going down"); <br>            if (pStorage) <br>            { <br>                pStorage-&gt;Release(); <br>                pStorage = NULL; <br>            } <br>            break; // out of the WHILE() loop <br>        } <br>ProcessNextAction: <br>        switch (g_IOInfo.Action) <br>        { <br>            case IO_OPEN_STORAGE_FILE : <br>                InfoTrace ("WorkingIOProc: Servicing IO_OPEN_STORAGE_FILE"); <br>                __try <br>                { <br>                    hResult = OpenMsgsDataFile (&amp;pStorage); <br>                    if (hResult) <br>                    { <br>                        g_hServerState = HRESULT_FROM_WIN32(ERROR_STATIC_INIT); <br>                    } <br>                    else <br>                    { <br>                        g_hServerState = S_OK; // Server is ready to accept requests <br>                    } <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_LOAD_MAILBOX_NAMES : <br>                InfoTrace ("WorkingIOProc: Servicing IO_LOAD_MAILBOX_NAMES"); <br>                __try <br>                { <br>                    hResult = LoadServerObjects (pStorage, pMalloc); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                // Restore notification links with the clients from a previous session <br>                g_IOInfo.Action = IO_RESTORE_CLIENT_NOTIFICATIONS; <br>                goto ProcessNextAction; <br>                break; <br> <br>            case IO_GET_CONTAINER_RECIPIENTS : <br>                InfoTrace ("WorkingIOProc: Servicing IO_GET_CONTAINER_RECIPIENTS"); <br>                __try <br>                { <br>                    hResult = ReadABContainerInfo (pStorage, <br>                                                   pMalloc, <br>                                                   g_IOInfo.dwObjID, <br>                                                   g_IOInfo.hTmpFile); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_CREATE_NEW_MAILBOX : <br>                InfoTrace ("WorkingIOProc: Servicing IO_CREATE_NEW_MAILBOX"); <br>                __try <br>                { <br>                    hResult = CreateMailbox (pStorage, g_IOInfo.pMBInfo); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_EMPTY_MAILBOX : <br>                InfoTrace ("WorkingIOProc: Servicing IO_EMPTY_MAILBOX"); <br>                __try <br>                { <br>                    hResult = EmptyMailBoxMsgs (pStorage, g_IOInfo.szObject); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_REMOVE_MAILBOX : <br>                InfoTrace ("WorkingIOProc: Servicing IO_REMOVE_MAILBOX"); <br>                __try <br>                { <br>                    hResult = DeleteMailbox (pStorage, g_IOInfo.pMBInfo); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_GET_MAILBOX_PROPERTIES : <br>                InfoTrace ("WorkingIOProc: Servicing IO_GET_MAILBOX_PROPERTIES"); <br>                __try <br>                { <br>                    hResult = MailboxProps (pStorage, g_IOInfo.pMBInfo, TRUE); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_SET_MAILBOX_PROPERTIES : <br>                InfoTrace ("WorkingIOProc: Servicing IO_SET_MAILBOX_PROPERTIES"); <br>                __try <br>                { <br>                    hResult = MailboxProps (pStorage, g_IOInfo.pMBInfo, FALSE); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_COPY_MSG_FROM_FILE : <br>                InfoTrace ("WorkingIOProc: Servicing IO_COPY_MSG_FROM_FILE"); <br>                __try <br>                { <br>                    hResult = CopyMsgFromFile (pStorage, <br>                                               g_IOInfo.hTmpFile, <br>                                               g_IOInfo.szObject, <br>                                               g_IOInfo.szHeader); <br>                    if (g_IOInfo.fCloseHandle) <br>                    { <br>                        CloseHandle (g_IOInfo.hTmpFile); <br>                    } <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_COPY_HEADERS_TO_FILE : <br>                InfoTrace ("WorkingIOProc: Servicing IO_COPY_HEADERS_TO_FILE"); <br>                __try <br>                { <br>                    hResult = CopyHeadersToFile (pStorage,   <br>                                                 pMalloc, <br>                                                 g_IOInfo.hTmpFile, <br>                                                 g_IOInfo.szObject); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_CHECK_PENDING_MESSAGES : <br>                InfoTrace ("WorkingIOProc: Servicing IO_CHECK_PENDING_MESSAGES"); <br>                __try <br>                { <br>                    hResult = CheckForPendingMailboxMsgs (pStorage,  <br>                                                          pMalloc, <br>                                                          g_IOInfo.szObject, <br>                                                          g_IOInfo.pdwData); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_COPY_MSG_TO_FILE : <br>                InfoTrace ("WorkingIOProc: Servicing IO_COPY_MSG_TO_FILE"); <br>                __try <br>                { <br>                    hResult = CopyMsgToFile (pStorage, <br>                                             g_IOInfo.szObject, <br>                                             g_IOInfo.hTmpFile, <br>                                             g_IOInfo.pdwData, <br>                                             g_IOInfo.dwObjID, <br>                                             FALSE); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_MOVE_MSG_TO_FILE : <br>                InfoTrace ("WorkingIOProc: Servicing IO_MOVE_MSG_TO_FILE"); <br>                __try <br>                { <br>                    hResult = CopyMsgToFile (pStorage, <br>                                             g_IOInfo.szObject, <br>                                             g_IOInfo.hTmpFile, <br>                                             g_IOInfo.pdwData, <br>                                             g_IOInfo.dwObjID, <br>                                             TRUE); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_MOVE_NEXT_MSG_TO_FILE : <br>                InfoTrace ("WorkingIOProc: Servicing IO_MOVE_NEXT_MSG_TO_FILE"); <br>                __try <br>                { <br>                    hResult = GetNextMailboxMsg (pStorage, <br>                                                 pMalloc, <br>                                                 g_IOInfo.szObject, <br>                                                 g_IOInfo.pdwData, <br>                                                 g_IOInfo.hTmpFile); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br>             <br>            case IO_DELETE_MSG_IN_MAILBOX : <br>                InfoTrace ("WorkingIOProc: Servicing IO_DELETE_MSG_IN_MAILBOX"); <br>                __try <br>                { <br>                    hResult = RemoveMessageFromMailbox (pStorage, <br>                                                        g_IOInfo.szObject, <br>                                                        g_IOInfo.dwObjID); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_CREATE_DISTRIBUTION_LIST : <br>                InfoTrace ("WorkingIOProc: Servicing IO_CREATE_DISTRIBUTION_LIST"); <br>                __try <br>                { <br>                    hResult = CreateDistributionList (pStorage, g_IOInfo.pDLInfo); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_DELETE_DISTRIBUTION_LIST : <br>                InfoTrace ("WorkingIOProc: Servicing IO_DELETE_DISTRIBUTION_LIST"); <br>                __try <br>                { <br>                    hResult = DeleteDistributionList (pStorage, g_IOInfo.pDLInfo); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_GET_DL_PROPERTIES : <br>                InfoTrace ("WorkingIOProc: Servicing IO_GET_DL_PROPERTIES"); <br>                __try <br>                { <br>                    hResult = DLPropsAndMembers (pStorage, g_IOInfo.pDLInfo, TRUE); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_SET_DL_PROPERTIES : <br>                InfoTrace ("WorkingIOProc: Servicing IO_SET_DL_PROPERTIES"); <br>                __try <br>                { <br>                    hResult = DLPropsAndMembers (pStorage, g_IOInfo.pDLInfo, FALSE); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_GET_GW_CONTAINER_COUNT : <br>                InfoTrace ("WorkingIOProc: Servicing IO_GET_GW_CONTAINER_COUNT"); <br>                __try <br>                { <br>                    hResult = GetGWContainerCount (pStorage, <br>                                                   pMalloc, <br>                                                   g_IOInfo.dwObjID, <br>                                                   g_IOInfo.pdwData); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_SENT_SHUTDOWN_NOTIFICATION : <br>                InfoTrace ("WorkingIOProc: Servicing IO_SENT_SHUTDOWN_NOTIFICATION"); <br>                __try <br>                { <br>                    ClientNotifThreadProc (g_IOInfo.pNotif); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_RESTORE_CLIENT_NOTIFICATIONS : <br>                InfoTrace ("WorkingIOProc: Servicing IO_RESTORE_CLIENT_NOTIFICATIONS"); <br>                __try <br>                { <br>                    PWINDS_NOTIFICATION pNotif = (PWINDS_NOTIFICATION)HeapAlloc (ghHeap, <br>                                                                                 HEAP_ZERO_MEMORY, <br>                                                                                 sizeof(WINDS_NOTIFICATION)); <br>                    if (NULL == pNotif) <br>                    { <br>                        TraceMessage ("WorkingIOProc: Failed to allocate notification structure"); <br>                    } <br>                    else <br>                    { <br>                        pNotif-&gt;Event = SERVER_HAS_RESTARTED; <br>                        ClientNotifThreadProc (pNotif); <br>                    } <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            case IO_ADMIN_GET_SERVER_MAILBOXES : <br>                InfoTrace ("WorkingIOProc: Servicing IO_ADMIN_GET_SERVER_MAILBOXES"); <br>                __try <br>                { <br>                    hResult = WaitForClientConnection (g_IOInfo.hTmpFile, 15); <br>                    if (S_OK == hResult) <br>                    { <br>                        hResult = EnumContainerObjs (pStorage, g_IOInfo.hTmpFile, SERVER_USER_MAILBOX, pMalloc); <br>                    } <br>                    CloseHandle (g_IOInfo.hTmpFile); <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br>            case IO_ADMIN_GET_SERVER_DISTLISTS : <br>                InfoTrace ("WorkingIOProc: Servicing IO_ADMIN_GET_SERVER_DISTLISTS"); <br>                __try <br>                { <br>                    LPSTORAGE pDirectoryStg; <br>                    hResult = pStorage-&gt;OpenStorage (DISTRIBUTION_LISTS, <br>                                                     NULL, <br>                                                     OPEN_FLAGS, <br>                                                     NULL, <br>                                                     0, <br>                                                     &amp;pDirectoryStg); <br>                    if (S_OK == hResult) <br>                    { <br>                        hResult = WaitForClientConnection (g_IOInfo.hTmpFile, 15); <br>                        if (S_OK == hResult) <br>                        { <br>                            hResult = EnumContainerObjs (pDirectoryStg, <br>                                                         g_IOInfo.hTmpFile, <br>                                                         SERVER_DISTRIBUTION_LIST, <br>                                                         pMalloc); <br>                        } <br>                        CloseHandle (g_IOInfo.hTmpFile); <br>                        pDirectoryStg-&gt;Release(); <br>                    } <br>                } <br>                __except (EXCEPTION_EXECUTE_HANDLER) <br>                { <br>                    dwException = GetExceptionCode(); <br>                } <br>                break; <br> <br>            default : <br>                TraceString1 ("WorkingIOProc: Unknown action requested: %d", g_IOInfo.Action); <br>                hResult = (DWORD)HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION); <br>                break; <br>        } <br>        if (dwException) <br>        { <br>            TraceString2 ("WorkingIOProc: Exception %d occured processing action id %d", dwException, g_IOInfo.Action); <br>            dwException = 0; <br>            hResult = (DWORD)HRESULT_FROM_WIN32(ERROR_EXCEPTION_IN_SERVICE); <br>        } <br> <br>        __try <br>        { <br>            if (g_IOInfo.phLastError) <br>            { <br>                *g_IOInfo.phLastError = hResult; <br>            } <br>        } <br>        __except (EXCEPTION_EXECUTE_HANDLER) <br>        { <br>            dwException = GetExceptionCode(); <br>            TraceString2 ("WorkingIOProc: Exception %d occured setting return error code for action id %d", dwException, g_IOInfo.Action); <br>            dwException = 0; <br>        } <br> <br>        if (g_IOInfo.hActionCompleted) <br>        { <br>            SetEvent (g_IOInfo.hActionCompleted); <br>        } <br>        g_IOInfo.Action = IO_IDLE; <br>        g_IOInfo.phLastError = NULL; <br>        g_IOInfo.hActionCompleted = NULL; <br>        g_IOInfo.pdwData = NULL; <br> <br>        //InfoTrace ("WorkingIOProc: About to leave critical section..."); <br>        LeaveCriticalSection (&amp;g_csIOInfo); <br>        //InfoTrace ("WorkingIOProc: ...Left critical section"); <br>    } <br>    pMalloc-&gt;Release(); <br> <br>    CoUninitialize(); <br> <br>    //InfoTrace ("WorkingIOProc: Just closing down"); <br>    if (g_IOInfo.hActionCompleted) <br>    { <br>        SetEvent (g_IOInfo.hActionCompleted); <br>    } <br>    //InfoTrace ("WorkingIOProc: About to leave critical section..."); <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    //InfoTrace ("WorkingIOProc: ...Left critical section"); <br>    return 0; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    OpenMsgsDataFile() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI OpenMsgsDataFile (LPSTORAGE * ppStorage) <br>{ <br>    DBINFO_DATA dbInfo = { 0 }; <br>    LPSTREAM pStream; <br>    HRESULT hResult = S_OK; <br> <br>#ifdef UNICODE <br>    LPWSTR szFileName = g_szDataFile; <br>#else <br>    WCHAR wcsFileName[MAX_PATH]; <br>    LPWSTR szFileName = wcsFileName; <br>    hResult = AnsiToUnicode (g_szDataFile, wcsFileName, MAX_PATH); <br>    if (hResult) <br>    { <br>        TraceResult ("OpenMsgDataFile: Failed to convert file name to UNICODE", hResult); <br>        return hResult; <br>    } <br>#endif // UNICODE <br>     <br>    hResult = StgIsStorageFile (szFileName); <br>    if (S_OK != hResult) <br>    { <br>        if (S_FALSE == hResult) <br>        { <br>            hResult = S_OK; <br>            goto CreateFileNow; <br>        } <br>        else <br>        { <br>            if (STG_E_FILENOTFOUND != hResult) <br>            { <br>                // else, if any other error occurred <br>                TraceResult ("OpenMsgsDataFile: StgIsStorageFile failed", hResult); <br>                return hResult; <br>            } <br>            else <br>            { <br>                goto CreateFileNow; <br>            } <br>        } <br>    } <br> <br>    hResult = StgOpenStorage (szFileName, NULL, OPEN_FLAGS, NULL, 0, ppStorage); <br>    if (!hResult) <br>    { <br>        hResult = (*ppStorage)-&gt;OpenStream (DBINFO_STREAM, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>        if (hResult) <br>        { <br>            TraceResult ("OpenMsgsDataFile: Failed to open DBINFO stream", hResult); <br>            if (STG_E_FILENOTFOUND == hResult) <br>            { <br>                hResult = STG_E_FILENOTFOUND; <br>            } <br>        } <br>        else <br>        { <br>            hResult = pStream-&gt;Read (&amp;dbInfo, sizeof(DBINFO_DATA), NULL); <br>            TraceResult ("OpenMsgsDataFile: Failed to read from the DBINFO stream", hResult); <br>            if (!hResult) <br>            { <br>                // If the database version does not match, we will delete <br>                // it and create a new one. <br>                if (WINDS_DATABASE_VERSION != dbInfo.dwVersion) <br>                { <br>                    hResult = STG_E_FILENOTFOUND; <br>                } <br>            } <br>            pStream-&gt;Release(); <br>        } <br>        if (hResult) <br>        { <br>            (*ppStorage)-&gt;Release(); <br>            *ppStorage = NULL; <br>        } <br>    } <br>    if (STG_E_FILENOTFOUND == hResult) <br>    { <br>CreateFileNow: <br>        DeleteFile (g_szDataFile); <br>        hResult = StgCreateDocfile (szFileName, CREATE_FLAGS, 0, ppStorage); <br>        TraceResult ("OpenMsgsDataFile: failed to open or create storage object", hResult); <br>        if (!hResult) <br>        { <br>            hResult = (*ppStorage)-&gt;CreateStream (DBINFO_STREAM, CREATE_FLAGS, 0, 0, &amp;pStream); <br>            TraceResult ("OpenMsgsDataFile: Failed to create DBINFO stream", hResult); <br>            if (!hResult) <br>            { <br>                dbInfo.dwVersion = WINDS_DATABASE_VERSION; <br>                hResult = pStream-&gt;Write (&amp;dbInfo, sizeof(DBINFO_DATA), NULL); <br>                TraceResult ("OpenMsgsDataFile: Failed to write to the DBINFO stream", hResult); <br>                pStream-&gt;Release(); <br>                if (!hResult) <br>                { <br>                    hResult = (*ppStorage)-&gt;CreateStream (OBJ_ID_POOL_STREAM, CREATE_FLAGS, 0, 0, &amp;pStream); <br>                    TraceResult ("OpenMsgsDataFile: Failed to create Object ID Pool stream", hResult); <br>                    if (!hResult) <br>                    { <br>                        DWORD dwZero = 0; <br>                        hResult = pStream-&gt;Write (&amp;dwZero, sizeof(DWORD), NULL); </code></pre>
<p>
</p>
<pre><code>pStream-&gt;Release(); <br>                    } <br>                } <br>            } <br>        } <br>        if (!hResult) <br>        { <br>            CreateDLsDirectory (*ppStorage); <br>            CreateGatewayDirectories (*ppStorage); <br>            CreatePublicFoldersDirectory (*ppStorage); <br>        } <br>        if (hResult) <br>        { <br>            DeleteFile (g_szDataFile); <br>        } <br>    } <br>    TraceResult ("OpenMsgsDataFile", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ReadABContainerInfo() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI ReadABContainerInfo (LPSTORAGE pStorage, <br>                                    LPMALLOC  pMalloc, <br>                                    DWORD     dwContainerID, <br>                                    HANDLE    hPipe) <br>{ <br>    BOOL fGalContainer = FALSE; <br>    DWORD dwLastContainerDone = 0; <br>    LPSTORAGE pDirectoryStg; <br>    HRESULT hResult = WaitForClientConnection (hPipe, 15); // 15 second timeout <br>    if (hResult) <br>    { <br>        goto ErrorExit; <br>    } <br>DoNextContainer: <br>    switch (dwContainerID) <br>    { <br>        case GAL_CONTAINER_ID : <br>            fGalContainer = TRUE; <br>            EnumContainerObjs (pStorage, hPipe, SERVER_USER_MAILBOX, pMalloc); <br>            if (S_OK == pStorage-&gt;OpenStorage (DISTRIBUTION_LISTS, NULL, OPEN_FLAGS, NULL, 0, &amp;pDirectoryStg)) <br>            { <br>                EnumContainerObjs (pDirectoryStg, hPipe, SERVER_DISTRIBUTION_LIST, pMalloc); <br>                pDirectoryStg-&gt;Release(); <br>            } <br>            dwLastContainerDone = GAL_CONTAINER_ID; <br>            break; <br>        case EXCHANGE_CONTAINER_ID : <br>        case SMTP_CONTAINER_ID : <br>        case FAX_CONTAINER_ID : <br>            break; <br>        default : <br>            { <br>                TCHAR szDLAlias[MAX_ALIAS_SIZE+1] = { 0 }; <br>                WINDS_AB_OBJTYPE Type = UNDEFINED_OBJECT_TYPE; <br>                WCHAR wcsDLalias[64] = { 0 }; <br>                if (S_OK == GlobalObjectMap.FindObjFromID (dwContainerID, szDLAlias, &amp;Type) &amp;&amp; <br>                    SERVER_DISTRIBUTION_LIST == Type) <br>                { <br>                    AnsiToUnicode (szDLAlias, wcsDLalias, 64); <br>                    hResult = pStorage-&gt;OpenStorage (DISTRIBUTION_LISTS, NULL, OPEN_FLAGS, NULL, 0, &amp;pDirectoryStg); <br>                    if (!hResult) <br>                    { <br>                        hResult = GetDLRecipientsInfo (pStorage, pDirectoryStg, hPipe, wcsDLalias); <br>                        pDirectoryStg-&gt;Release(); <br>                    } <br>                    TraceResult ("ReadABContainerInfo: Getting DL recipients", hResult); <br>                    hResult = S_OK;                         <br>                } <br>                else <br>                { <br>                    hResult = HRESULT_FROM_WIN32(ERROR_NO_SUCH_GROUP); <br>                    TraceResult ("ReadABContainerInfo: Invalid container ID passed in", hResult); <br>                } <br>            } <br>            break; <br>    } <br>    if (fGalContainer) <br>    { <br>        dwContainerID++; <br>        if (dwContainerID &lt;= FAX_CONTAINER_ID) <br>        { <br>            goto DoNextContainer; <br>        } <br>    } <br>ErrorExit: <br>    TraceResult ("ReadABContainerInfo", hResult); <br>    CloseHandle (hPipe); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    EnumContainerObjs() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI EnumContainerObjs (LPSTORAGE             pDirectoryStg, <br>                                  HANDLE                hPipe, <br>                                  WINDS_AB_OBJTYPE      Type, <br>                                  LPMALLOC              pMalloc) <br>{ <br>    LPENUMSTATSTG pEnum; <br>    STATSTG aStat[ELEMENTS_TO_FETCH]; <br>    AB_ENTRY_INFO abEntry = { 0 }; <br>    abEntry.Type = Type; <br>    LPTSTR pszObjAlias = (SERVER_DISTRIBUTION_LIST == Type ? abEntry.Info.DL.szDLAlias : abEntry.Info.MB.szMailboxName); <br>    ULONG ulMBoxFound = 1; <br>    DWORD dwBytesWritten; <br>    BOOL fFailure; <br>    int nChars; <br>    HRESULT hResult = pDirectoryStg-&gt;EnumElements (0, NULL, 0, &amp;pEnum); <br>    TraceResult ("EnumContainerObjs: Failed to get ENUM interface", hResult); <br>    if (!hResult) <br>    { <br>        while (!hResult &amp;&amp; ulMBoxFound) <br>        { <br>            hResult = pEnum-&gt;Next (ELEMENTS_TO_FETCH, aStat, &amp;ulMBoxFound); <br>            if (FAILED(hResult)) // We might get S_FALSE <br>            { <br>                TraceResult ("EnumContainerObjs: Failed to ENUM streams", hResult); <br>            } <br>            else <br>            { <br>                if (ulMBoxFound) <br>                { <br>                    for (ULONG i=0; i&lt;ulMBoxFound; i++) <br>                    { <br>                        if (STGTY_STORAGE == aStat[i].type &amp;&amp; (L'_' != aStat[i].pwcsName[0])) <br>                        { <br>                            nChars = WideCharToMultiByte (CP_ACP, <br>                                                          0, <br>                                                          aStat[i].pwcsName, <br>                                                          -1, <br>                                                          pszObjAlias, <br>                                                          MAX_ALIAS_SIZE+1, <br>                                                          NULL, <br>                                                          NULL); <br>                            if (!nChars) <br>                            { <br>                                TraceResult ("EnumContainerObjs: Failed to convert storage name", HRESULT_FROM_WIN32(GetLastError())); <br>                            } <br>                            else <br>                            { <br>                                if (SERVER_DISTRIBUTION_LIST == Type) <br>                                { <br>                                    fFailure = GetDLProperties (pDirectoryStg, aStat[i].pwcsName, &amp;abEntry.Info.DL); <br>                                } <br>                                else <br>                                { <br>                                    fFailure = GetMailBoxInfo (pDirectoryStg, aStat[i].pwcsName, &amp;abEntry.Info.MB); <br>                                } <br>                                if (!fFailure) <br>                                { <br>                                    WriteFile (hPipe, &amp;abEntry, sizeof(AB_ENTRY_INFO), &amp;dwBytesWritten, NULL); <br>                                } <br>                            } <br>                        } <br>                        pMalloc-&gt;Free (aStat[i].pwcsName); <br>                    } <br>                } <br>            } <br>        } <br>        pEnum-&gt;Release(); <br>    } <br>    if (S_FALSE == hResult) <br>    { <br>        hResult = S_OK; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    LoadServerObjects() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI LoadServerObjects (LPSTORAGE pStorage, LPMALLOC pMalloc) <br>{ <br>    LoadObjectProperties (pStorage, SERVER_USER_MAILBOX, TEXT("User Mailbox"), pMalloc); <br>    LPSTORAGE pDirectoryStg; <br>    HRESULT hResult = pStorage-&gt;OpenStorage (DISTRIBUTION_LISTS, NULL, OPEN_FLAGS, NULL, 0, &amp;pDirectoryStg); <br>RestartDL: <br>    if (!hResult) <br>    { <br>        LoadObjectProperties (pDirectoryStg, SERVER_DISTRIBUTION_LIST, TEXT("Distribution List"), pMalloc); <br>        pDirectoryStg-&gt;Release(); <br>    } <br>    else <br>    { <br>        if (STG_E_FILENOTFOUND == hResult) <br>        { <br>            hResult = pStorage-&gt;CreateStorage (DISTRIBUTION_LISTS, CREATE_FLAGS, 0, 0, &amp;pDirectoryStg); <br>            goto RestartDL; <br>        } <br>    } <br>    LPSTORAGE pGatewaysStg; <br>    hResult = pStorage-&gt;OpenStorage (FOREIGN_DIRECTORIES, NULL, OPEN_FLAGS, NULL, 0, &amp;pGatewaysStg); <br>RestartGateways: <br>    if (!hResult) <br>    { <br>        if (!pGatewaysStg-&gt;OpenStorage (EXCHANGE_GATEWAY, NULL, OPEN_FLAGS, NULL, 0, &amp;pDirectoryStg)) <br>        { <br>            LoadObjectProperties (pDirectoryStg, GATEWAY_RECIPIENT, TEXT("Gateway Recipient"), pMalloc); <br>            pDirectoryStg-&gt;Release(); <br>        } <br>        if (!pGatewaysStg-&gt;OpenStorage (FAX_GATEWAY, NULL, OPEN_FLAGS, NULL, 0, &amp;pDirectoryStg)) <br>        { <br>            LoadObjectProperties (pDirectoryStg, GATEWAY_RECIPIENT, TEXT("Gateway Recipient"), pMalloc); <br>            pDirectoryStg-&gt;Release(); <br>        } <br>        if (!pGatewaysStg-&gt;OpenStorage (SMTP_GATEWAY, NULL, OPEN_FLAGS, NULL, 0, &amp;pDirectoryStg)) <br>        { <br>            LoadObjectProperties (pDirectoryStg, GATEWAY_RECIPIENT, TEXT("Gateway Recipient"), pMalloc); <br>            pDirectoryStg-&gt;Release(); <br>        } <br>        pGatewaysStg-&gt;Release(); <br>    } <br>    else <br>    { <br>        if (STG_E_FILENOTFOUND == hResult) <br>        { <br>            hResult = pStorage-&gt;CreateStorage (FOREIGN_DIRECTORIES, CREATE_FLAGS, 0, 0, &amp;pGatewaysStg); <br>            goto RestartGateways; <br>        } <br>    } <br>    return S_OK; <br>} <br>/////////////////////////////////////////////////////////////////////////////// <br>//    LoadObjectProperties() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI LoadObjectProperties (LPSTORAGE          pStorage, <br>                                     WINDS_AB_OBJTYPE   Type, <br>                                     LPTSTR             pszObjectType, <br>                                     LPMALLOC           pMalloc) <br>{ <br>    LPENUMSTATSTG pEnum; <br>    STATSTG aStat[ELEMENTS_TO_FETCH]; <br>    MAILBOX_INFO MBInfo = { 0 }; <br>    DIST_LIST_INFO DLInfo = { 0 }; <br>    ULONG i, ulMBoxFound = 1; <br>    HRESULT hResult = pStorage-&gt;EnumElements (0, NULL, 0, &amp;pEnum); <br>    TraceResult ("LoadObjectProperties: Failed to get ENUM interface", hResult); <br>    if (!hResult) <br>    { <br>        while (!hResult &amp;&amp; ulMBoxFound) <br>        { <br>            hResult = pEnum-&gt;Next (ELEMENTS_TO_FETCH, aStat, &amp;ulMBoxFound); <br>            if (FAILED(hResult)) // We might get S_FALSE <br>            { <br>                TraceResult ("LoadObjectProperties: Failed to ENUM streams", hResult); <br>            } <br>            else <br>            { <br>                if (ulMBoxFound) <br>                { <br>                    for (i=0; i&lt;ulMBoxFound; i++) <br>                    { <br>                        if (STGTY_STORAGE == aStat[i].type &amp;&amp; (L'_' != aStat[i].pwcsName[0])) <br>                        { <br>                            int nChars = WideCharToMultiByte (CP_ACP, <br>                                                              0, <br>                                                              aStat[i].pwcsName, <br>                                                              -1, <br>                                                              (SERVER_DISTRIBUTION_LIST == Type ? DLInfo.szDLAlias : MBInfo.szMailboxName), <br>                                                              MAX_ALIAS_SIZE+1, <br>                                                              NULL, <br>                                                              NULL); <br>                            if (!nChars) <br>                            { <br>                                TraceResult ("LoadObjectProperties: Failed to convert storage name", HRESULT_FROM_WIN32(GetLastError())); <br>                            } <br>                            else <br>                            { <br>                                if (SERVER_DISTRIBUTION_LIST == Type) <br>                                {                                 <br>                                    if (S_OK == GetDLProperties (pStorage, aStat[i].pwcsName, &amp;DLInfo)) <br>                                    { <br>                                        GlobalObjectMap.Insert (DLInfo.dwObjID, DLInfo.szDLAlias, SERVER_DISTRIBUTION_LIST); <br>                                    } <br>                                } <br>                                else <br>                                { <br>                                    if (S_OK == GetMailBoxInfo (pStorage, aStat[i].pwcsName, &amp;MBInfo)) <br>                                    { <br>                                        GlobalObjectMap.Insert (MBInfo.dwObjID, MBInfo.szMailboxName, SERVER_USER_MAILBOX); <br>                                    } <br>                                } <br>                            } <br>                        } <br>                        pMalloc-&gt;Free (aStat[i].pwcsName); <br>                    } <br>                } <br>            } <br>        } <br>        pEnum-&gt;Release(); <br>    } <br>    if (S_FALSE == hResult) <br>    { <br>        hResult = S_OK; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MailboxProps() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI MailboxProps (LPSTORAGE pMBDirectory, PMAILBOX_INFO pMBInfo, BOOL fRetrieve) <br>{ <br>    HRESULT hResult; <br>    WCHAR wcsMailbox[64] = { 0 }; <br>    AnsiToUnicode (pMBInfo-&gt;szMailboxName, wcsMailbox, 64); <br>    if (fRetrieve) <br>    { <br>        hResult = GetMailBoxInfo (pMBDirectory, wcsMailbox, pMBInfo); <br>    } <br>    else <br>    { <br>        hResult = SetMailBoxInfo (pMBDirectory, wcsMailbox, pMBInfo); <br>    } <br>    TraceResult ("MailboxProps", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetMailBoxInfo() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetMailBoxInfo (LPSTORAGE pStorage, LPOLESTR pwcsName, PMAILBOX_INFO pInfo) <br>{ <br>    LPSTREAM pStream; <br>    LPSTORAGE pSubStorage; <br>    HRESULT hResult = pStorage-&gt;OpenStorage (pwcsName, NULL, OPEN_FLAGS, NULL, 0, &amp;pSubStorage); <br>    TraceResult ("GetMailBoxInfo: Failed to open mailbox storage", hResult); <br>    if (!hResult) <br>    { <br>        hResult = pSubStorage-&gt;OpenStream (USER_PROPERTIES, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>        TraceResult ("GetMailBoxInfo: Failed to open the properties stream", hResult); <br>        if (!hResult) <br>        { <br>            hResult = pStream-&gt;Read (pInfo, sizeof(MAILBOX_INFO), NULL); <br>            TraceResult ("GetMailBoxInfo: Failed to read the MBOX stream", hResult); <br>            pStream-&gt;Release(); <br>        } <br>        pSubStorage-&gt;Release(); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    SetMailBoxInfo() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI SetMailBoxInfo (LPSTORAGE pStorage, LPOLESTR pwcsName, PMAILBOX_INFO pInfo) <br>{ <br>    LPSTREAM pStream; <br>    LPSTORAGE pSubStorage; <br>    HRESULT hResult = pStorage-&gt;OpenStorage (pwcsName, NULL, OPEN_FLAGS, NULL, 0, &amp;pSubStorage); <br>    TraceResult ("SetMailBoxInfo: Failed to open mailbox storage", hResult); <br>    if (!hResult) <br>    { <br>        hResult = pSubStorage-&gt;OpenStream (USER_PROPERTIES, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>        TraceResult ("SetMailBoxInfo: Failed to open the properties stream", hResult); <br>        if (!hResult) <br>        { <br>            hResult = pStream-&gt;Write (pInfo, sizeof(MAILBOX_INFO), NULL); <br>            TraceResult ("SetMailBoxInfo: Failed to write to the MBOX stream", hResult); <br>            pStream-&gt;Release(); <br>        } <br>        pSubStorage-&gt;Release(); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    EmptyMailBoxMsgs() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI EmptyMailBoxMsgs (LPSTORAGE pStorage, LPTSTR pszMailbox) <br>{ <br>    LPSTORAGE pMBStg, pSubStg; <br>    WCHAR wcsMailbox[64] = { 0 }; <br>    AnsiToUnicode (pszMailbox, wcsMailbox, 64); <br>    HRESULT hResult = pStorage-&gt;OpenStorage (wcsMailbox, NULL, OPEN_FLAGS, NULL, 0, &amp;pMBStg); <br>    if (!hResult) <br>    { <br>        hResult = pMBStg-&gt;DestroyElement (HEADERS_STORAGE); <br>        if (!hResult) <br>        { <br>            hResult = pMBStg-&gt;CreateStorage (HEADERS_STORAGE, CREATE_FLAGS, 0, 0, &amp;pSubStg); <br>            if (!hResult) <br>            { <br>                pSubStg-&gt;Release(); <br>                hResult = pMBStg-&gt;DestroyElement (MSGS_STORAGE); <br>                if (!hResult) <br>                { <br>                    hResult = pMBStg-&gt;CreateStorage (MSGS_STORAGE, CREATE_FLAGS, 0, 0, &amp;pSubStg); <br>                    if (!hResult) <br>                    { <br>                        pSubStg-&gt;Release(); <br>                    } <br>                } <br>            } <br>        } <br>        pMBStg-&gt;Release(); <br>    } <br>    TraceResult ("EmptyMailBoxMsgs", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetNextObjID() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetNextObjID (LPSTORAGE pStorage, DWORD &amp; dwNextID) <br>{ <br>    LPSTREAM pStream; <br>    LARGE_INTEGER liZero = { 0 }; <br>    HRESULT hResult = pStorage-&gt;OpenStream (OBJ_ID_POOL_STREAM, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>    if (!hResult) <br>    { <br>        // From the opened stream, read the next available ID <br>        hResult = pStream-&gt;Read (&amp;dwNextID, sizeof(DWORD), NULL); <br>        if (!hResult) <br>        { <br>            // Set the stream seek pointer back to the beginning and write the ID <br>            hResult = pStream-&gt;Seek (liZero, STREAM_SEEK_SET, NULL); <br>            if (!hResult) <br>            { <br>                dwNextID++; <br>                hResult = pStream-&gt;Write (&amp;dwNextID, sizeof(DWORD), NULL); <br>            } <br>        } <br>        pStream-&gt;Release(); <br>    } <br>    // If any, trace out the error code. <br>    TraceResult ("GetNextObjID", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateMailbox() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CreateMailbox (LPSTORAGE pMBDirectory, PMAILBOX_INFO pMBInfo) <br>{ <br>    LPSTORAGE pMBStg, pSubStg; <br>    LPSTREAM pStream; <br>    DWORD dwZero = 0; <br>    HRESULT hResult = GetNextObjID (pMBDirectory, pMBInfo-&gt;dwObjID); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    WCHAR wcsMailbox[64] = { 0 }; <br>    AnsiToUnicode (pMBInfo-&gt;szMailboxName, wcsMailbox, 64); <br>    hResult = pMBDirectory-&gt;CreateStorage (wcsMailbox, CREATE_FLAGS, 0, 0, &amp;pMBStg); <br>    if (!hResult) <br>    { <br>        hResult = pMBStg-&gt;CreateStream (USER_PROPERTIES, CREATE_FLAGS, 0, 0, &amp;pStream); <br>        if (!hResult) <br>        { <br>            hResult = pStream-&gt;Write (pMBInfo, sizeof(MAILBOX_INFO), NULL); <br>            if (!hResult) <br>            { <br>                hResult = pMBStg-&gt;CreateStorage (HEADERS_STORAGE, CREATE_FLAGS, 0, 0, &amp;pSubStg); <br>                if (!hResult) <br>                { <br>                    pSubStg-&gt;Release(); <br>                    hResult = pMBStg-&gt;CreateStream (OBJ_ID_POOL_STREAM, CREATE_FLAGS, 0, 0, &amp;pStream); <br>                    if (!hResult) <br>                    { <br>                        hResult = pStream-&gt;Write (&amp;dwZero, sizeof(DWORD), NULL); <br>                        pStream-&gt;Release(); <br>                        if (!hResult) <br>                        { <br>                            hResult = pMBStg-&gt;CreateStorage (MSGS_STORAGE, CREATE_FLAGS, 0, 0, &amp;pSubStg); <br>                            if (!hResult) <br>                            { <br>                                pSubStg-&gt;Release(); <br>                            } <br>                        } <br>                    } <br>                } <br>            } <br>        } <br>        pMBStg-&gt;Release(); <br>        if (hResult) <br>        { <br>            hResult = pMBDirectory-&gt;DestroyElement (wcsMailbox); <br>        } <br>    } <br>    TraceResult ("CreateMailbox", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DeleteMailbox() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI DeleteMailbox (LPSTORAGE pStorage, PMAILBOX_INFO pMBInfo) <br>{ <br>    WCHAR wcsMailbox[64] = { 0 }; <br>    AnsiToUnicode (pMBInfo-&gt;szMailboxName, wcsMailbox, 64); <br>    GetMailBoxInfo (pStorage, wcsMailbox, pMBInfo); <br>    HRESULT hResult = pStorage-&gt;DestroyElement (wcsMailbox); <br>    TraceResult ("DeleteMailbox: Failed to delete storage of mailbox", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CopyMsgFromFile() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CopyMsgFromFile (LPSTORAGE      pStorage, <br>                                HANDLE         hFile, <br>                                LPTSTR         szMailbox, <br>                                LPTSTR         szHeader) <br>{ <br>    LPSTORAGE pMBStg, pMsgStg; <br>    LPSTREAM pStream; <br>    WCHAR wcsMailbox[64] = { 0 }, wcsStreamName[NAME_FORMAT_SIZE]; <br>    AnsiToUnicode (szMailbox, wcsMailbox, 64); <br>     <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    DWORD dwBytesRead, dwLastError = 0, dwStreamID; <br>    HRESULT hResult = pStorage-&gt;OpenStorage (wcsMailbox, NULL, OPEN_FLAGS, NULL, 0, &amp;pMBStg); <br>    if (!hResult) <br>    { <br>        hResult = pMBStg-&gt;OpenStorage (MSGS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pMsgStg); <br>        if (!hResult) <br>        { <br>            hResult = GetNextObjID (pMBStg, dwStreamID); <br>            if (!hResult) <br>            { <br>                wsprintfW (wcsStreamName, MSG_STREAM_FORMAT, dwStreamID); <br>                hResult = pMsgStg-&gt;CreateStream (wcsStreamName, CREATE_FLAGS, 0, 0, &amp;pStream); <br>                if (!hResult) <br>                { <br>                    do <br>                    { <br>                        if (!ReadFile (hFile, abBuffer, IO_BUFFERSIZE, &amp;dwBytesRead, NULL)) <br>                        { <br>                            dwLastError = HRESULT_FROM_WIN32(GetLastError()); <br>                            TraceResult ("CopyMsgFromFile: Failed to read from the tmp file", dwLastError); <br>                        } <br>                        if (dwBytesRead) <br>                        { <br>                            hResult = pStream-&gt;Write (abBuffer, dwBytesRead, NULL); <br>                            TraceResult ("CopyMsgFromFile: Failed to write into mb stream", hResult); <br>                        } <br>                    } while (dwBytesRead &amp;&amp; !hResult &amp;&amp; !dwLastError); <br>                    if (!hResult &amp;&amp; !dwLastError) <br>                    { <br>                        hResult = UpdateMailboxHeaders (pStorage, pMBStg, NULL, dwStreamID, szHeader, TRUE); <br>                    } <br>                    pStream-&gt;Release(); <br>                    if (hResult || dwLastError) <br>                    { <br>                        pMsgStg-&gt;DestroyElement (wcsStreamName); <br>                        if (dwLastError) <br>                        { <br>                            hResult = dwLastError; <br>                        } <br>                    } <br>                } <br>            } <br>            pMsgStg-&gt;Release(); <br>        } <br>        pMBStg-&gt;Release(); <br>    } <br>    // If there were no error storing the message in the user mailbox, send a <br>    // notification to client transports indicating that a new message <br>    // is pending download. <br>    if (S_OK == hResult) <br>    { <br>        PWINDS_NOTIFICATION pNotif = (PWINDS_NOTIFICATION)HeapAlloc (ghHeap, <br>                                                                     HEAP_ZERO_MEMORY, <br>                                                                     sizeof(WINDS_NOTIFICATION)); <br>        if (pNotif) <br>        { <br>            pNotif-&gt;Event = XP_NEW_MAIL_ARRIVED; <br>            lstrcpy (pNotif-&gt;Info.MB.szMailboxName, szMailbox); <br>            NotifyClients (pNotif); // This will take care of freeing the notification structure <br>        } <br>        else <br>        { <br>            TraceMessage ("CopyMsgFromFile: Failed to allocate memory for client notification"); <br>        } <br>    } <br>    TraceResult ("CopyMsgFromFile", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoveMessageFromMailbox() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI RemoveMessageFromMailbox (LPSTORAGE      pStorage, <br>                                         LPTSTR         szMailbox, <br>                                         DWORD          dwStreamID) <br>{ <br>    LPSTORAGE pHeaders, pMBStg, pMsgStg; <br>    WCHAR wcsMailbox[64] = { 0 }, wcsStreamName[NAME_FORMAT_SIZE]; <br>    AnsiToUnicode (szMailbox, wcsMailbox, 64); <br> <br>    HRESULT hResult = pStorage-&gt;OpenStorage (wcsMailbox, NULL, OPEN_FLAGS, NULL, 0, &amp;pMBStg); <br>    if (!hResult) <br>    { <br>        hResult = pMBStg-&gt;OpenStorage (MSGS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pMsgStg); <br>        if (!hResult) <br>        { <br>            wsprintfW (wcsStreamName, MSG_STREAM_FORMAT, dwStreamID); <br>            hResult = pMsgStg-&gt;DestroyElement (wcsStreamName); <br>            if (!hResult) <br>            { <br>                hResult = pMBStg-&gt;OpenStorage (HEADERS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pHeaders); <br>                if (!hResult) <br>                { <br>                    wsprintfW (wcsStreamName, HEADER_STREAM_FORMAT, dwStreamID); <br>                    pHeaders-&gt;DestroyElement (wcsStreamName); // Drop the error code here <br>                    pHeaders-&gt;Release(); <br>                } <br>            } <br>            pMsgStg-&gt;Release(); <br>        } <br>        pMBStg-&gt;Release(); <br>    } <br>    TraceResult ("RemoveMessageFromMailbox", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    UpdateMailboxHeaders() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long WINAPI UpdateMailboxHeaders (LPSTORAGE pStorage, <br>                                  LPSTORAGE pMBStg, <br>                                  LPTSTR    szMailbox, <br>                                  DWORD     dwStreamID, <br>                                  LPTSTR    pszHeader, <br>                                  BOOL      fAddMsgToHeadersList) <br>{ <br>    WCHAR wcsMailbox[64] = { 0 }, wcsStreamName[NAME_FORMAT_SIZE]; <br>     <br>    LPSTORAGE pHeadersStg; <br>    LPSTREAM pHeader; <br>    HRESULT hResult = S_OK; <br>    BOOL fReleaseLocalStorage = FALSE; <br>    if (!pMBStg) <br>    { <br>        fReleaseLocalStorage = TRUE; <br>        AnsiToUnicode (szMailbox, wcsMailbox, 64); <br>        hResult = pStorage-&gt;OpenStorage (wcsMailbox, NULL, OPEN_FLAGS, NULL, 0, &amp;pMBStg); <br>        TraceResult ("UpdateMailboxHeaders: Failed to open mailbox", hResult); <br>    } <br>    if (!hResult) <br>    { <br>        hResult = pMBStg-&gt;OpenStorage (HEADERS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pHeadersStg); <br>        TraceResult ("UpdateMailboxHeaders: Failed to open header storage", hResult); <br>        if (!hResult) <br>        { <br>            wsprintfW (wcsStreamName, HEADER_STREAM_FORMAT, dwStreamID); <br>            if (fAddMsgToHeadersList) <br>            { <br>                hResult = pHeadersStg-&gt;CreateStream (wcsStreamName, CREATE_FLAGS, 0, 0, &amp;pHeader); <br>                TraceResult ("UpdateMailboxHeaders: Failed to create header stream", hResult); <br>                if (!hResult) <br>                { <br>                    BYTE abEntryID[16]; <br>                    ZeroMemory (abEntryID, 16); <br>                    wsprintfA ((LPSTR)&amp;abEntryID[4], "%d", dwStreamID); <br> <br>                    ULONG cbSize = 16 + lstrlen(pszHeader) * sizeof(TCHAR); <br>                    hResult = pHeader-&gt;Write (&amp;cbSize, sizeof(ULONG), NULL); <br>                    TraceResult ("UpdateMailboxHeaders: Failed to write header size", hResult); <br>                    if (!hResult) <br>                    { <br>                        hResult = pHeader-&gt;Write (abEntryID, 16, NULL); <br>                        TraceResult ("UpdateMailboxHeaders: Failed to write message EID", hResult); <br>                        if (!hResult) <br>                        { <br>                            hResult = pHeader-&gt;Write (pszHeader, cbSize - 16, NULL); <br>                            TraceResult ("UpdateMailboxHeaders: Failed to write header to stream", hResult); <br>                        } <br>                    } <br>                    pHeader-&gt;Release(); <br>                    if (hResult) <br>                    { <br>                        TraceIO2 ("UpdateMailboxHeaders", pHeadersStg-&gt;DestroyElement(wcsStreamName)); <br>                    } <br>                } <br>            } <br>            else <br>            { <br>                hResult = pMBStg-&gt;DestroyElement (wcsStreamName); <br>                TraceResult ("UpdateMailboxHeaders: Failed to remove header stream", hResult); <br>            } <br>            pHeadersStg-&gt;Release(); <br>        } <br>        if (fReleaseLocalStorage) <br>        { <br>            pMBStg-&gt;Release(); <br>        } <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CopyHeadersToFile() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CopyHeadersToFile (LPSTORAGE     pStorage, <br>                                  LPMALLOC      pMalloc, <br>                                  HANDLE        hFile, <br>                                  LPTSTR        szMailbox) <br>{ <br>    BOOL fAtLeastOneCopied = FALSE, fSubStreamFailed = FALSE; <br>    LPSTORAGE pMBStg, pHeadersStg; <br>    LPSTREAM pStream; <br>    LPENUMSTATSTG pEnum; <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    STATSTG aStat[ELEMENTS_TO_FETCH]; <br>    ULONG ulStreamsFound, ulBytesRead; <br>    DWORD dwBytesWrite; <br>     <br>    WCHAR wcsMailbox[64] = { 0 }; <br>    AnsiToUnicode (szMailbox, wcsMailbox, 64); <br> <br>    HRESULT hResult = pStorage-&gt;OpenStorage (wcsMailbox, NULL, OPEN_FLAGS, NULL, 0, &amp;pMBStg); <br>    TraceResult ("CopyHeadersToFile: Failed to mailbox storage", hResult); </code></pre>
<p>
</p>
<pre><code>if (!hResult) <br>    { <br>        hResult = pMBStg-&gt;OpenStorage (HEADERS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pHeadersStg); <br>        TraceResult ("CopyHeadersToFile: Failed to open headers storage", hResult); <br>        if (!hResult) <br>        { <br>            hResult = pHeadersStg-&gt;EnumElements (0, NULL, 0, &amp;pEnum); <br>            TraceResult ("CopyHeadersToFile: Failed to get ENUM interface", hResult); <br>            if (!hResult) <br>            { <br>                hResult = 0; <br>                ulStreamsFound = 1; <br>                while (!hResult &amp;&amp; ulStreamsFound) <br>                { <br>                    hResult = pEnum-&gt;Next (ELEMENTS_TO_FETCH, aStat, &amp;ulStreamsFound); <br>                    if (ulStreamsFound) <br>                    { <br>                        for (ULONG i=0; i&lt;ulStreamsFound; i++) <br>                        { <br>                            hResult = pHeadersStg-&gt;OpenStream (aStat[i].pwcsName, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>                            TraceResult ("CopyHeadersToFile: Failed to open header stream", hResult); <br>                            if (!hResult) <br>                            { <br>                                ASSERT (IO_BUFFERSIZE &gt;= aStat[i].cbSize.LowPart); <br>                                hResult = pStream-&gt;Read (abBuffer, aStat[i].cbSize.LowPart, &amp;ulBytesRead); <br>                                if (!hResult) <br>                                { <br>                                    if (!WriteFile (hFile, abBuffer, ulBytesRead, &amp;dwBytesWrite, NULL)) <br>                                    { <br>                                        fSubStreamFailed = TRUE; <br>                                        TraceResult ("CopyHeadersToFile: Failed to write header to tmp file", HRESULT_FROM_WIN32(GetLastError())); <br>                                    } <br>                                    else <br>                                    { <br>                                        fAtLeastOneCopied = TRUE; <br>                                    } <br>                                } <br>                                pStream-&gt;Release(); <br>                            } <br>                            pMalloc-&gt;Free (aStat[i].pwcsName); <br>                        } <br>                    } <br>                    else <br>                    { <br>                        if (FAILED(hResult)) // We might get S_FALSE <br>                        { <br>                            TraceResult ("CopyHeadersToFile: Failed to ENUM streams", hResult); <br>                        } <br>                    } <br>                } <br>                if (S_FALSE == hResult) <br>                { <br>                    hResult = S_OK; <br>                } <br>                pEnum-&gt;Release(); <br>            } <br>            pHeadersStg-&gt;Release(); <br>        } <br>        pMBStg-&gt;Release(); <br>    } <br>    if (hResult) <br>    { <br>        if (fSubStreamFailed) <br>        { <br>            if (fAtLeastOneCopied) <br>            { <br>                hResult = MAKE_HRESULT(0, FACILITY_WIN32, ERROR_PARTIAL_COPY); <br>            } <br>        } <br>    } <br>    SetFilePointer (hFile, 0, NULL, FILE_BEGIN); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CopyStreamToFile() <br>// <br>//    Parameters                         <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI CopyStreamToFile (LPSTREAM   pStream, <br>                                 HANDLE     hFile, <br>                                 ULONG *    pulWritten) <br>{ <br>    BYTE aBuffer[IO_BUFFERSIZE];  <br>    ULONG ulRead, ulRemain, ulWritten; <br>    STATSTG StatInfo; <br>    *pulWritten = 0; <br>    HRESULT hResult = pStream-&gt;Stat (&amp;StatInfo, STATFLAG_NONAME); <br>    if (!hResult) <br>    { <br>        ulRemain  = StatInfo.cbSize.LowPart; <br>        for (; ulRemain&gt;0; ulRemain -= ulWritten) <br>        { <br>            hResult = pStream-&gt;Read (aBuffer, min(ulRemain, IO_BUFFERSIZE), &amp;ulRead); <br>            if (hResult) <br>            { <br>                break; // Out of the FOR() loop <br>            } <br>            else <br>            { <br>                if (!WriteFile (hFile, aBuffer, ulRead, &amp;ulWritten, NULL)) <br>                {             <br>                    hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                    break; // Out of the FOR() loop <br>                } <br>            } <br>            *pulWritten += ulWritten; <br>        } <br>    } <br>    TraceResult ("CopyStreamToFile", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CopyMsgToFile() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CopyMsgToFile (LPSTORAGE    pStorage, <br>                              LPTSTR       szMailbox, <br>                              HANDLE       hFile, <br>                              ULONG *      pulMsgLen, <br>                              DWORD        dwStreamID, <br>                              BOOL         fDeleteAfterCopy) <br>{ <br>    LPSTORAGE pMBStg, pMsgStg, pHeaders; <br>    LPSTREAM pStream; <br>    WCHAR wcsMailbox[64] = { 0 }, wcsStreamName[NAME_FORMAT_SIZE]; <br>    wsprintfW (wcsStreamName, MSG_STREAM_FORMAT, dwStreamID); <br> <br>    AnsiToUnicode (szMailbox, wcsMailbox, 64); <br>    HRESULT hResult = pStorage-&gt;OpenStorage (wcsMailbox, NULL, OPEN_FLAGS, NULL, 0, &amp;pMBStg); <br>    if (!hResult) <br>    { <br>        hResult = pMBStg-&gt;OpenStorage (MSGS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pMsgStg); <br>        if(!hResult) <br>        { <br>            hResult = pMsgStg-&gt;OpenStream (wcsStreamName, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>            if (!hResult) <br>            { <br>                hResult = CopyStreamToFile (pStream, hFile, pulMsgLen); <br>                pStream-&gt;Release(); <br>                if (!hResult &amp;&amp; fDeleteAfterCopy) <br>                { <br>                    hResult = pMsgStg-&gt;DestroyElement (wcsStreamName); <br>                    if (!hResult) <br>                    { <br>                        hResult = pMBStg-&gt;OpenStorage (HEADERS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pHeaders); <br>                        if (!hResult) <br>                        { <br>                            wsprintfW (wcsStreamName, HEADER_STREAM_FORMAT, dwStreamID); <br>                            hResult = pHeaders-&gt;DestroyElement (wcsStreamName); <br>                            pHeaders-&gt;Release(); <br>                        } <br>                    } <br>                    hResult = S_OK; // We don't want to propagate errors at this level, since the message is already copied. <br>                } <br>            } <br>            pMsgStg-&gt;Release(); <br>        } <br>        pMBStg-&gt;Release(); <br>    } <br>    TraceResult ("CopyMsgToFile", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateDistributionList() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CreateDistributionList (LPSTORAGE pStorage, PDIST_LIST_INFO pDLInfo) <br>{ <br>    HRESULT hResult = GetNextObjID (pStorage, pDLInfo-&gt;dwObjID); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    LPSTORAGE pDLDirectoryStg, pDLStg; <br>    LPSTREAM pStream; <br>    WCHAR wcsDLalias[64] = { 0 }; <br>    AnsiToUnicode (pDLInfo-&gt;szDLAlias, wcsDLalias, 64); <br> <br>    hResult = pStorage-&gt;OpenStorage (DISTRIBUTION_LISTS, NULL, OPEN_FLAGS, NULL, 0, &amp;pDLDirectoryStg); <br>Restart: <br>    if (!hResult) <br>    { <br>        hResult = pDLDirectoryStg-&gt;CreateStorage (wcsDLalias, CREATE_FLAGS, 0, 0, &amp;pDLStg); <br>        if (!hResult) <br>        { <br>            hResult = pDLStg-&gt;CreateStream (DL_PROPS, CREATE_FLAGS, 0, 0, &amp;pStream); <br>            if (!hResult) <br>            { <br>                pStream-&gt;Release(); <br>                hResult = pDLStg-&gt;CreateStream (DL_MEMBERS, CREATE_FLAGS, 0, 0, &amp;pStream); <br>                if (!hResult) <br>                { <br>                    pStream-&gt;Release(); <br>                } <br>            } <br>            pDLStg-&gt;Release(); <br>            hResult = SetDLProperties (pDLDirectoryStg, wcsDLalias, pDLInfo); <br>        } <br>        if (hResult) <br>        { <br>            pDLDirectoryStg-&gt;DestroyElement (wcsDLalias); <br>        } <br>        pDLDirectoryStg-&gt;Release(); <br>    } <br>    else <br>    { <br>        if (STG_E_FILENOTFOUND == hResult) <br>        { <br>            hResult = pStorage-&gt;CreateStorage (DISTRIBUTION_LISTS, CREATE_FLAGS, 0, 0, &amp;pDLDirectoryStg); <br>            goto Restart; <br>        } <br>    } <br>    TraceResult ("CreateDistributionList", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DLPropsAndMembers() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI DLPropsAndMembers (LPSTORAGE pStorage, PDIST_LIST_INFO pDLInfo, BOOL fGetProps) <br>{ <br>    LPSTORAGE pDLDirectoryStg; <br>    WCHAR wcsDLalias[64] = { 0 }; <br>    AnsiToUnicode (pDLInfo-&gt;szDLAlias, wcsDLalias, 64); <br>    HRESULT hResult = pStorage-&gt;OpenStorage (DISTRIBUTION_LISTS, NULL, OPEN_FLAGS, NULL, 0, &amp;pDLDirectoryStg); <br>    if (!hResult) <br>    { <br>        if (fGetProps) <br>        { <br>            hResult = GetDLProperties (pDLDirectoryStg, wcsDLalias, pDLInfo, TRUE); <br>        } <br>        else <br>        { <br>            hResult = SetDLProperties (pDLDirectoryStg, wcsDLalias, pDLInfo); <br>        } <br>        pDLDirectoryStg-&gt;Release(); <br>    } <br>    TraceResult ("DLPropsAndMembers", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetDLProperties() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetDLProperties (LPSTORAGE           pStorage, <br>                                LPOLESTR            pwcsDLName, <br>                                PDIST_LIST_INFO     pDLInfo, <br>                                BOOL                fGetMembers) <br>{ <br>    LPSTREAM pStream; <br>    LPSTORAGE pDLStg; <br>    DWORD i; <br>    DLM_INFO_A Info = { 0 }; <br>    DLM_LIST_A * pList = (DLM_LIST_A *)pDLInfo-&gt;pMembers; <br> <br>    HRESULT hResult = pStorage-&gt;OpenStorage (pwcsDLName, NULL, OPEN_FLAGS, NULL, 0, &amp;pDLStg); <br>    if (!hResult) <br>    { <br>        hResult = pDLStg-&gt;OpenStream (DL_PROPS, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>        if (!hResult) <br>        { <br>            hResult = pStream-&gt;Read (pDLInfo, <br>                                     sizeof(DIST_LIST_INFO) - 4, // Don't read the pMember pointer value <br>                                     NULL); <br>            pStream-&gt;Release(); <br>        } <br>        if (!hResult &amp;&amp; fGetMembers &amp;&amp; pDLInfo-&gt;dwMemberCount &amp;&amp; pList) <br>        { <br>            hResult = pDLStg-&gt;OpenStream (DL_MEMBERS, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>            if (!hResult) <br>            { <br>                for (i=0; i&lt;pDLInfo-&gt;dwMemberCount &amp;&amp; !hResult; i++) <br>                { <br>                    hResult = pStream-&gt;Read (&amp;Info, sizeof(DLM_INFO_A), NULL); <br>                    if (!hResult) <br>                    { <br>                        if (i == 0) <br>                        { <br>                            pList-&gt;Info = Info; <br>                        } <br>                        else <br>                        { <br>                            InsertNewDLMNodeA (Info, pList); <br>                        } <br>                    } <br>                } <br>                pStream-&gt;Release(); <br>            } <br>        } <br>        pDLStg-&gt;Release(); <br>    } <br>    TraceResult ("GetDLProperties", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    SetDLProperties() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI SetDLProperties (LPSTORAGE           pStorage, <br>                                LPOLESTR            pwcsDLName, <br>                                PDIST_LIST_INFO     pDLInfo) <br>{ <br>    LPSTREAM pStream; <br>    LPSTORAGE pDLStg; <br>    ULARGE_INTEGER uliTotalSize = { 0 }; <br>    ULONG ulBytesWritten; <br>    DLM_LIST_A * pNode; <br>    HRESULT hResult = pStorage-&gt;OpenStorage (pwcsDLName, NULL, OPEN_FLAGS, NULL, 0, &amp;pDLStg); <br>    if (!hResult) <br>    { <br>        pDLInfo-&gt;dwMemberCount = 0; <br>        hResult = pDLStg-&gt;OpenStream (DL_MEMBERS, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>        if (!hResult) <br>        { <br>            pNode = (DLM_LIST_A *)pDLInfo-&gt;pMembers; <br>            while (pNode &amp;&amp; !hResult) <br>            { <br>                hResult = pStream-&gt;Write (&amp;(pNode-&gt;Info), <br>                                          sizeof(DLM_INFO_A), <br>                                          &amp;ulBytesWritten); <br>                uliTotalSize.LowPart += ulBytesWritten; <br>                pDLInfo-&gt;dwMemberCount++; <br>                pNode = pNode-&gt;pNext; <br>            } <br>            pStream-&gt;SetSize (uliTotalSize); <br>            pStream-&gt;Release(); <br>        } <br>        if (!hResult) <br>        { <br>            hResult = pDLStg-&gt;OpenStream (DL_PROPS, NULL, OPEN_FLAGS, 0, &amp;pStream); <br>            if (!hResult) <br>            { <br>                hResult = pStream-&gt;Write (pDLInfo, <br>                                          sizeof(DIST_LIST_INFO) - 4, // Don't write the last 4 byte (pMembers) <br>                                          NULL); <br>                pStream-&gt;Release(); <br>            } <br>        } <br>        pDLStg-&gt;Release(); <br>    } <br>    TraceResult ("SetDLProperties", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DeleteDistributionList() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI DeleteDistributionList (LPSTORAGE pStorage, PDIST_LIST_INFO pDLInfo) <br>{ <br>    LPSTORAGE pDLDirectoryStg; <br>    WCHAR wcsDLalias[64] = { 0 }; <br>    AnsiToUnicode (pDLInfo-&gt;szDLAlias, wcsDLalias, 64); <br>    HRESULT hResult = pStorage-&gt;OpenStorage (DISTRIBUTION_LISTS, NULL, OPEN_FLAGS, NULL, 0, &amp;pDLDirectoryStg); <br>    if (!hResult) <br>    { <br>        GetDLProperties (pDLDirectoryStg, wcsDLalias, pDLInfo, FALSE); <br>        hResult = pDLDirectoryStg-&gt;DestroyElement (wcsDLalias); <br>        pDLDirectoryStg-&gt;Release(); <br>    } <br>    TraceResult ("DeleteDistributionList", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetDLRecipientsInfo() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetDLRecipientsInfo (LPSTORAGE   pMBDirectory, <br>                                    LPSTORAGE   pDLDirectory, <br>                                    HANDLE      hPipe, <br>                                    LPOLESTR    pwcsDLName) <br>{ <br>    DLM_LIST_A Members = { 0 }; <br>    DIST_LIST_INFO DLInfo = { 0 }; <br>    DLInfo.pMembers = (LPVOID)&amp;Members; <br>    AB_ENTRY_INFO abEntry = { 0 }; <br>    OLECHAR wcsMemberAlias[MAX_ALIAS_SIZE+1]; <br>    int nChars; <br>    DWORD dwBytesWritten; <br>    DLM_LIST_A * pNode; <br>     <br>    HRESULT hEntry, hResult = GetDLProperties (pDLDirectory, pwcsDLName, &amp;DLInfo, TRUE); <br>    if (!hResult &amp;&amp; (0 != Members.Info.dwMemberID)) <br>    { <br>        pNode = (DLM_LIST_A *)DLInfo.pMembers; <br>        while (pNode) <br>        { <br>            nChars = MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, (LPSTR)pNode-&gt;Info.szMemberAlias, -1, wcsMemberAlias, MAX_ALIAS_SIZE+1); <br>            if (!nChars) <br>            { <br>                TraceResult ("GetDLRecipientsInfo: Failed to convert alias name", HRESULT_FROM_WIN32(GetLastError())); <br>            } <br>            else <br>            { <br>                abEntry.Type = (WINDS_AB_OBJTYPE)pNode-&gt;Info.dwMemberType; <br>                if (SERVER_DISTRIBUTION_LIST == abEntry.Type) <br>                { <br>                    hEntry = GetDLProperties (pDLDirectory, wcsMemberAlias, &amp;abEntry.Info.DL, FALSE); <br>                } <br>                else <br>                { <br>                    if (SERVER_USER_MAILBOX == abEntry.Type) <br>                    { <br>                        hEntry = GetMailBoxInfo (pMBDirectory, wcsMemberAlias, &amp;abEntry.Info.MB); <br>                    } <br>                    else <br>                    { <br>                        ASSERT (GATEWAY_RECIPIENT == abEntry.Type); <br>                        ASSERT (FALSE); // not implemented yet <br>                        hEntry = E_FAIL; <br>                    } <br>                } <br>                if (!hEntry) <br>                { <br>                    if (!WriteFile (hPipe, &amp;abEntry, sizeof(AB_ENTRY_INFO), &amp;dwBytesWritten, NULL)) <br>                    { <br>                        TraceResult ("GetDLRecipientsInfo: Failed to write to client pipe", HRESULT_FROM_WIN32(GetLastError())); <br>                    } <br>                } <br>            } <br>            pNode = pNode-&gt;pNext; <br>        } <br>        FreeDLMList (&amp;Members); <br>    } <br>    TraceResult ("GetDLRecipientsInfo", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetGWContainerCount() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetGWContainerCount (LPSTORAGE   pStorage, <br>                                    LPMALLOC    pMalloc, <br>                                    DWORD       dwContainerID, <br>                                    DWORD *     pdwContainerCount) <br>{ <br>    LPENUMSTATSTG pEnum; <br>    STATSTG aStat[ELEMENTS_TO_FETCH]; <br>    ULONG ulMBoxFound = 1; <br>    LPSTORAGE pDirectory, pGWContainer; <br>    HRESULT hResult = pStorage-&gt;OpenStorage (FOREIGN_DIRECTORIES, NULL, OPEN_FLAGS, NULL, 0, &amp;pDirectory); <br>    if (!hResult) <br>    { <br>        switch (dwContainerID) <br>        { <br>            case FAX_CONTAINER_ID : <br>                hResult = pStorage-&gt;OpenStorage (FAX_GATEWAY, NULL, OPEN_FLAGS, NULL, 0, &amp;pGWContainer); <br>                break; <br>            case SMTP_CONTAINER_ID : <br>                hResult = pStorage-&gt;OpenStorage (SMTP_GATEWAY, NULL, OPEN_FLAGS, NULL, 0, &amp;pGWContainer); <br>                break; <br>            case EXCHANGE_CONTAINER_ID : <br>                hResult = pStorage-&gt;OpenStorage (EXCHANGE_GATEWAY, NULL, OPEN_FLAGS, NULL, 0, &amp;pGWContainer); <br>                break; <br>        } <br>        if (!hResult) <br>        { <br>            hResult = pGWContainer-&gt;EnumElements (0, NULL, 0, &amp;pEnum); <br>            if (!hResult) <br>            { <br>                while (!hResult &amp;&amp; ulMBoxFound) <br>                { <br>                    hResult = pEnum-&gt;Next (ELEMENTS_TO_FETCH, aStat, &amp;ulMBoxFound); <br>                    if (SUCCEEDED(hResult)) <br>                    { <br>                        if (ulMBoxFound) <br>                        { <br>                            for (ULONG i=0; i&lt;ulMBoxFound; i++) <br>                            { <br>                                if (STGTY_STORAGE == aStat[i].type &amp;&amp; (L'_' != aStat[i].pwcsName[0])) <br>                                { <br>                                    (*pdwContainerCount)++; <br>                                } <br>                                pMalloc-&gt;Free (aStat[i].pwcsName); <br>                            } <br>                        } <br>                    } <br>                } <br>                pEnum-&gt;Release(); <br>            } <br>            hResult = S_OK; <br>            pGWContainer-&gt;Release(); <br>        } <br>        pDirectory-&gt;Release(); <br>    } <br>    TraceResult ("GetGWContainerCount", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CheckForPendingMailboxMsgs() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CheckForPendingMailboxMsgs (LPSTORAGE pStorage, <br>                                           LPMALLOC  pMalloc, <br>                                           LPTSTR    szMailbox, <br>                                           DWORD *   pdwMsgCount) <br>{ <br>    WCHAR wcsMailbox[64] = { 0 }; <br>    AnsiToUnicode (szMailbox, wcsMailbox, 64); <br> <br>    ULONG ulMsgsFound, dwTotal = 0; <br>    LPENUMSTATSTG pEnum; <br>    STATSTG aStat[ELEMENTS_TO_FETCH]; <br>    LPSTORAGE pMailbox, pMessages; <br>    HRESULT hResult = pStorage-&gt;OpenStorage (wcsMailbox, NULL, OPEN_FLAGS, NULL, 0, &amp;pMailbox); <br>    if (!hResult) <br>    { <br>        hResult = pMailbox-&gt;OpenStorage (MSGS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pMessages); <br>        if (!hResult) <br>        { <br>            hResult = pMessages-&gt;EnumElements (0, NULL, 0, &amp;pEnum); <br>            if (!hResult) <br>            { <br>                while (!hResult) <br>                { <br>                    hResult = pEnum-&gt;Next (ELEMENTS_TO_FETCH, aStat, &amp;ulMsgsFound); <br>                    if (FAILED(hResult)) // We might get S_FALSE <br>                    { <br>                        TraceResult ("CheckForPendingMailboxMsgs: Failed to ENUM streams", hResult); <br>                    } <br>                    else <br>                    { <br>                        if (ulMsgsFound) <br>                        { <br>                            dwTotal += ulMsgsFound; <br>                        } <br>                        pMalloc-&gt;Free (aStat[0].pwcsName); <br>                    } <br>                } <br>                pEnum-&gt;Release(); <br>                if (S_FALSE == hResult) <br>                { <br>                    hResult = S_OK; <br>                    *pdwMsgCount = dwTotal; <br>                } <br>            } <br>            pMessages-&gt;Release(); <br>        } <br>        pMailbox-&gt;Release(); <br>    } <br>    TraceResult ("CheckForPendingMailboxMsgs", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetNextMailboxMsg() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetNextMailboxMsg (LPSTORAGE pStorage, <br>                                  LPMALLOC  pMalloc, <br>                                  LPTSTR    szMailbox, <br>                                  DWORD *   pdwMsgID, <br>                                  HANDLE    hFile) <br>{ <br>    WCHAR wcsMailbox[64] = { 0 }; <br>    AnsiToUnicode (szMailbox, wcsMailbox, 64); <br> <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    int nChars; <br>    char szObjName[64]; <br>    LPSTR pSubStr; <br>    DWORD dwBytesWritten; <br>    ULONG ulMsgsFound = 0, ulBytesRead; <br>    LPENUMSTATSTG pEnum; <br>    STATSTG aStat[1]; <br>    LPSTORAGE pMailbox, pMessages; <br>    LPSTREAM pOneMsg; <br>    HRESULT hResult = pStorage-&gt;OpenStorage (wcsMailbox, NULL, OPEN_FLAGS, NULL, 0, &amp;pMailbox); <br>    if (!hResult) <br>    { <br>        hResult = pMailbox-&gt;OpenStorage (MSGS_STORAGE, NULL, OPEN_FLAGS, NULL, 0, &amp;pMessages); <br>        if (!hResult) <br>        { <br>            hResult = pMessages-&gt;EnumElements (0, NULL, 0, &amp;pEnum); <br>            if (!hResult) <br>            { <br>                hResult = pEnum-&gt;Next (1, aStat, &amp;ulMsgsFound); <br>                if (FAILED(hResult)) // We might get S_FALSE <br>                { <br>                    TraceResult ("GetNextMailboxMsg: Failed to ENUM streams", hResult); <br>                } <br>                else <br>                { <br>                    if (ulMsgsFound) <br>                    { <br>                        ASSERT (STGTY_STREAM == aStat[0].type) <br>                        nChars = WideCharToMultiByte (CP_ACP, <br>                                                      0, <br>                                                      aStat[0].pwcsName, <br>                                                      -1, <br>                                                      szObjName, <br>                                                      64, <br>                                                      NULL, <br>                                                      NULL); <br>                        if (!nChars) <br>                        { <br>                            TraceResult ("GetNextMailboxMsg: Failed to convert storage name", HRESULT_FROM_WIN32(GetLastError())); <br>                        } <br>                        hResult = pMessages-&gt;OpenStream (aStat[0].pwcsName, <br>                                                         NULL, <br>                                                         OPEN_FLAGS, <br>                                                         0, <br>                                                         &amp;pOneMsg); <br>                        if (!hResult) <br>                        { <br>                            do <br>                            { <br>                                hResult = pOneMsg-&gt;Read (abBuffer, IO_BUFFERSIZE, &amp;ulBytesRead); <br>                                if (!hResult &amp;&amp; ulBytesRead) <br>                                { <br>                                    if (!WriteFile (hFile, abBuffer, ulBytesRead, &amp;dwBytesWritten, NULL)) <br>                                    { <br>                                        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                                    } <br>                                } <br>                            } while (!hResult &amp;&amp; ulBytesRead); <br>                            pOneMsg-&gt;Release(); <br>                        } <br>                        if (!hResult &amp;&amp; nChars) <br>                        { <br>                            pSubStr = &amp;(szObjName[lstrlenA (szObjName)]); <br>                            while (' ' != *pSubStr) <br>                            { <br>                                pSubStr--; <br>                            } <br>                            pSubStr++; <br>                            sscanf (pSubStr, "%X", pdwMsgID); <br>                        } <br>                        pMalloc-&gt;Free (aStat[0].pwcsName); <br>                    } <br>                } <br>                pEnum-&gt;Release(); <br>            } <br>            pMessages-&gt;Release(); <br>        } <br>        pMailbox-&gt;Release(); <br>    } <br>    #ifdef _DEBUG <br>    if (hResult &amp;&amp; S_FALSE != hResult) <br>    { <br>        TraceResult ("GetNextMailboxMsg", hResult); <br>    } <br>    #endif // _DEBUG <br> <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateGatewayQueues() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CreateGatewayQueues (LPSTORAGE pStorage) <br>{ <br>    LPSTORAGE pQueueStg; <br>    if (!pStorage-&gt;CreateStorage (GW_OUTBOX, CREATE_FLAGS, 0, 0, &amp;pQueueStg)) <br>    { <br>        pQueueStg-&gt;Release(); <br>    } <br>    if (!pStorage-&gt;CreateStorage (GW_INBOX, CREATE_FLAGS, 0, 0, &amp;pQueueStg)) <br>    { <br>        pQueueStg-&gt;Release(); <br>    } <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateGatewayDirectories() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CreateGatewayDirectories (LPSTORAGE pStorage) <br>{ <br>    LPSTORAGE pDirsStg, pGatewaysStg; <br>    HRESULT hResult = pStorage-&gt;CreateStorage (FOREIGN_DIRECTORIES, CREATE_FLAGS, 0, 0, &amp;pDirsStg); <br>    if (!hResult) <br>    { <br>        if (!pDirsStg-&gt;CreateStorage (EXCHANGE_GATEWAY, CREATE_FLAGS, 0, 0, &amp;pGatewaysStg)) <br>        { <br>            CreateGatewayQueues (pGatewaysStg); <br>            pGatewaysStg-&gt;Release(); <br>        } <br>        if (!pDirsStg-&gt;CreateStorage (FAX_GATEWAY, CREATE_FLAGS, 0, 0, &amp;pGatewaysStg)) <br>        { <br>            CreateGatewayQueues (pGatewaysStg); <br>            pGatewaysStg-&gt;Release(); <br>        } <br>        if (!pDirsStg-&gt;CreateStorage (SMTP_GATEWAY, CREATE_FLAGS, 0, 0, &amp;pGatewaysStg)) <br>        { <br>            CreateGatewayQueues (pGatewaysStg); <br>            pGatewaysStg-&gt;Release(); <br>        } <br>        pDirsStg-&gt;Release(); <br>    } <br>    return hResult; <br>} <br> <br>// End of file for STORAGE.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
