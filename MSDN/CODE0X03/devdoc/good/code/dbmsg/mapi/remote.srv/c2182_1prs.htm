<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SUPPORT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2188"></a>SUPPORT.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      SUPPORT.CPP <br>// <br>//  Description <br>//      Support functions for remote admin program. <br>// <br>//  Author <br>//      Irving De la Cruz <br>//       <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "_WINDS.H" <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ReleaseSyncObj() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>void WINAPI ReleaseSyncObj() <br>{ <br>    DeleteCriticalSection (&amp;g_csIOInfo); <br>    DeleteCriticalSection (&amp;g_csPipeID); <br>    DeleteCriticalSection (&amp;g_csNotifLinks); <br>    DeleteCriticalSection (&amp;g_csServiceState); <br>    CloseHandle (g_IOInfo.hResumeEvent); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    LoadSettingsFromRegistry() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      This function is used to load the application setting structure values <br>//      from the registry under a subkey for our application. The entire data <br>//      structure is read from a single sub entry as an array of binary data, <br>//      unreadable to humans. <br>//       <br>//    Return Value <br>//      None <br>//       <br>void WINAPI LoadSettingsFromRegistry() <br>{ <br>    HKEY hAppKey; <br>    // Try to open the key in the registry, open it with READ rights, <br>    // and read the data into our strcture <br>    if (ERROR_SUCCESS == RegOpenKeyEx (HKEY_LOCAL_MACHINE, <br>                                       WINDS_SERVICE_REGISTRY_KEY, <br>                                       0, <br>                                       KEY_READ, <br>                                       &amp;hAppKey)) <br>    { <br>        ULONG cbSize = MAX_PATH*sizeof(TCHAR); <br>        DWORD dwError = RegQueryValueEx (hAppKey, <br>                                         DATA_FILE_SUB_KEY, <br>                                         NULL, <br>                                         NULL, <br>                                         (LPBYTE)g_szDataFile, <br>                                         &amp;cbSize); <br>        RegCloseKey (hAppKey); <br>        // If we failed to get the data from the registry we can't return <br>        // yet, we will proceed to initialize the options with default <br>        // values <br>        if (ERROR_SUCCESS == dwError) <br>        { <br>            return; <br>        } <br>    } <br>    // If we couldn't read the file name, then initialize to default values <br>    lstrcpy (g_szDataFile, TEXT(".\\WINDS.DAT")); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    SaveSettingsToRegistry() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      This function is used to save the settings structure values to the <br>//      registry under a subkey for our application. The key where we write <br>//      the values is created if it doesn't exist. The entire structure data <br>//      is written to a single sub entry as an array of binary data, <br>//      unreadable to humans. <br>//       <br>//    Return Value <br>//      None <br>//       <br>void WINAPI SaveSettingsToRegistry() <br>{ <br>    HKEY hAppKey; <br>    DWORD dwDisposition = MAX_PATH*sizeof(TCHAR); <br>    // Try to open the key in the registry, open it with READ/WRITE rights <br>    if (ERROR_SUCCESS != RegCreateKeyEx (HKEY_LOCAL_MACHINE, <br>                                         WINDS_SERVICE_REGISTRY_KEY, <br>                                         0, <br>                                         NULL, <br>                                         REG_OPTION_NON_VOLATILE, <br>                                         KEY_WRITE, <br>                                         NULL, <br>                                         &amp;hAppKey, <br>                                         &amp;dwDisposition)) <br>    { <br>        // If we fail to access the registry, we need to get out, we don't <br>        // have a key opened where to write <br>        TraceResult ("SaveSettingsToRegistry: Failed to open app key", HRESULT_FROM_WIN32(GetLastError())); <br>    } <br>    else <br>    { <br>        // With the opened key handle, create a sub entry where we save our <br>        // structure values. For this sample we just write the entire <br>        // structure as a big blob of data, which we read the save way. <br>        if (ERROR_SUCCESS != RegSetValueEx (hAppKey, <br>                                            DATA_FILE_SUB_KEY, <br>                                            0, <br>                                            REG_SZ, <br>                                            (LPBYTE)g_szDataFile, <br>                                            (lstrlen (g_szDataFile)+1)*sizeof(TCHAR))) <br>        { <br>            TraceResult ("SaveSettingsToRegistry: Failed to save registry values", HRESULT_FROM_WIN32(GetLastError())); <br>        } <br>        // Close the handle we have open and return the appropiate flag <br>        RegCloseKey (hAppKey); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetLocalTempFileName() <br>// <br>//    Parameters <br>//      pszFileName     Pointer to a buffer allocated by the caller where the <br>//                      function returns a fully qualified patha and file for <br>//                      a uniquely named temporary file name. <br>// <br>//    Purpose <br>//      This function creates a temporary file name. The file name will be <br>//      returned in the pszFileName buffer which must have been allocated by <br>//      the caller. The file will have a fully qualified path to its location. <br>//      The location of the file is on the TEMP directory as set in the system. <br>// <br>//    Return Value <br>//      0 if the function is successful at creating a temporary <br>//      unique file name. A system error code otherwise. <br>// <br>HRESULT WINAPI GetLocalTempFileName(LPTSTR pszFileName) <br>{ <br>    HRESULT hResult = S_OK; <br>    TCHAR szTmpPath[_MAX_PATH]; <br> <br>    // Ask the system for the TEMP directory <br>    if (!GetTempPath (_MAX_PATH, szTmpPath)) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("GetLocalTempFileName: Failed to get temp path", hResult); <br>        return hResult; <br>    } <br> <br>    if (!GetTempFileName (szTmpPath,        // Call the Win32 API <br>                          TEXT("WDS"),      // Our fixed prefix for temp files <br>                          0,                // Use a pseudo-unique number <br>                          pszFileName))     // Destination buffer <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("GetLocalTempFileName: Failed to get temp file name", hResult); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FileCopy() <br>// <br>//    Parameters                         <br>//      hDest           handle to destination file/stream <br>//      hSrc            handle to source file/stream <br>//      dwMsgLen        number of bytes to copy <br>// <br>//    Purpose <br>//      Copies bytes from one open file or stream object to another file <br>//      stream object. <br>//       <br>//    Return Value <br>//      NO_ERROR on success, ERROR_READ/WRITE_FAULT otherwise <br>//       <br>long WINAPI FileCopy(HANDLE hDest, HANDLE hSrc, DWORD dwMsgLen) <br>{ <br>    BYTE  buf[IO_BUFFERSIZE];  <br>    DWORD nRead, nRemaining = dwMsgLen; <br>    BOOL  bRes; <br>    for (DWORD nWritten=0; nRemaining&gt;0; nRemaining -= nWritten) <br>    { <br>        bRes = ReadFile (hSrc, buf, min(nRemaining, (DWORD)IO_BUFFERSIZE), &amp;nRead, NULL); <br>        if (!nRead || !bRes) <br>        { <br>            return HRESULT_FROM_WIN32(ERROR_READ_FAULT); <br>        } <br>        bRes = WriteFile(hDest, buf, nRead, &amp;nWritten, NULL); <br>        if (!nWritten || !bRes) <br>        { <br>            return HRESULT_FROM_WIN32(ERROR_WRITE_FAULT); <br>        } <br>    } <br>    return NO_ERROR; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WaitForClientConnection() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long WINAPI WaitForClientConnection (HANDLE hPipe, DWORD dwTimeOut) <br>{ <br>    dwTimeOut *= 1000; // The timeout value comes is seconds so we must convert them to milliseconds. <br> <br>    long lResult = 0; <br>    BOOL bResult; <br>    OVERLAPPED ovWait = { 0 }; <br>    ovWait.hEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (NULL == ovWait.hEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("WaitForClientConnection: Failed to create wait event", lResult); <br>    } <br>    else <br>    { <br>        bResult = ConnectNamedPipe (hPipe, &amp;ovWait); <br>        if (FALSE == bResult) <br>        { <br>            lResult = HRESULT_FROM_WIN32(GetLastError()); <br>            if (HRESULT_FROM_WIN32(lResult) == HRESULT_FROM_WIN32(ERROR_IO_PENDING) || <br>                HRESULT_FROM_WIN32(lResult) == HRESULT_FROM_WIN32(ERROR_PIPE_CONNECTED)) <br>            { <br>                lResult = S_OK; <br>            } <br>        } <br>        if (!lResult) <br>        { <br>            lResult = WaitForSingleObject (ovWait.hEvent, dwTimeOut); <br>            if (WAIT_OBJECT_0 == lResult) <br>            { <br>                lResult = 0; // No error; <br>            } <br>            else <br>            { <br>                TraceMessage ("WaitForClientConnection: Client did not connect. Timeout"); <br>                lResult = HRESULT_FROM_WIN32(ERROR_PIPE_NOT_CONNECTED); <br>            } <br>        } <br>        else <br>        { <br>            lResult = HRESULT_FROM_WIN32(GetLastError()); <br>            TraceResult ("WaitForClientConnection: Failed to wait for connection", lResult); <br>        } <br>        CloseHandle (ovWait.hEvent); <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    AnsiToUnicode() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>// <br>//    Return Value <br>//      None. <br>// <br>HRESULT WINAPI AnsiToUnicode (LPSTR   szStr, <br>                              LPWSTR  wcStr, <br>                              ULONG   cchUnicode) <br>{ <br>    HRESULT hResult = S_OK; <br>    // Do we have a string to duplicate? <br>    if (!szStr || !wcStr) <br>    { <br>        TraceMessage ("AnsiToUnicode: NULL string pointers"); <br>        return E_INVALIDARG; <br>    } <br>    int iChars = MultiByteToWideChar (CP_ACP, <br>                                      MB_PRECOMPOSED, <br>                                      szStr, <br>                                      -1, <br>                                      wcStr, <br>                                      cchUnicode); <br>    if (0 == iChars) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("AnsiToUnicode: Failed tp convert to UNICODE", hResult); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    UnicodeToAnsi() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>// <br>//    Return Value <br>//      None. <br>// <br>HRESULT WINAPI UnicodeToAnsi (LPWSTR  wcStr, <br>                              LPSTR   szStr, <br>                              ULONG   cchAnsi) <br>{ <br>    HRESULT hResult = S_OK; <br>    // Do we have a string to duplicate? <br>    if (!szStr || !wcStr) <br>    { <br>        TraceMessage ("UnicodeToAnsi: NULL string pointers"); <br>        return E_INVALIDARG; <br>    } <br>    int iChars = WideCharToMultiByte (CP_ACP, <br>                                      0, <br>                                      wcStr, <br>                                      -1, <br>                                      szStr, <br>                                      cchAnsi, <br>                                      NULL, <br>                                      NULL); <br>    if (0 == iChars) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("UnicodeToAnsi: Failed tp convert to UNICODE", hResult); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetNextPipeID() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>DWORD WINAPI GetNextPipeID() <br>{ <br>    DWORD dwPipeID; <br>    EnterCriticalSection (&amp;g_csPipeID); <br>    if (g_dwNextPipeID &gt; MAX_PIPE_NUMBER) <br>    { <br>        g_dwNextPipeID = MIN_PIPE_NUMBER; <br>    } <br>    dwPipeID = g_dwNextPipeID; <br>    g_dwNextPipeID++; <br>    LeaveCriticalSection (&amp;g_csPipeID); <br>    return dwPipeID; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CObjectList::CObjectList() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>// <br>//    Return Value <br>//      None. <br>// <br>CObjectList::CObjectList() <br>{ <br>    TraceMessage ("CObjectList: Constructor called"); <br>    m_hHeap = GetProcessHeap(); <br>    m_pHead = NULL; <br>    InitializeCriticalSection (&amp;m_csObj); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CObjectList::~CObjectList() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>// <br>//    Return Value <br>//      None. <br>// <br>CObjectList::~CObjectList() <br>{ <br>    TraceMessage ("CObjectList: Destructor called"); <br>    // Free the entire list <br>    POBJLIST_NODE pNode = m_pHead; <br>    while (m_pHead) <br>    { <br>        pNode = m_pHead-&gt;pNext; <br>        HeapFree (m_hHeap, 0, m_pHead); <br>        m_pHead = pNode; <br>    } <br>    DeleteCriticalSection (&amp;m_csObj); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CObjectList::Insert() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CObjectList::Insert (DWORD             dwObjID, <br>                                  LPTSTR            pObjName, <br>                                  WINDS_AB_OBJTYPE  ObjType) <br>{ <br>    // Allocate a new node <br>    POBJLIST_NODE pNode, pNewNode = (POBJLIST_NODE)HeapAlloc (m_hHeap, <br>                                                              HEAP_ZERO_MEMORY, <br>                                                              sizeof(OBJLIST_NODE)); <br>    if (NULL == pNewNode) <br>    { <br>        TraceResult ("CObjectList::Insert: Failed to allocate new node", E_OUTOFMEMORY); <br>        return E_OUTOFMEMORY; <br>    } <br>    // Copy the data of the node <br>    // pNewNode-&gt;pNext = NULL; &lt;- implied in the allocation <br>    pNewNode-&gt;dwObjID = dwObjID; <br>    pNewNode-&gt;ObjType = ObjType; <br>    lstrcpy (pNewNode-&gt;szObjAlias, pObjName); <br>     <br>    EnterCriticalSection (&amp;m_csObj); <br>    // Insert the node at the end of the list <br>    if (m_pHead) <br>    { <br>        pNode = m_pHead; <br>        while (m_pHead) <br>        { <br>            if (NULL == pNode-&gt;pNext) <br>            { <br>                pNode-&gt;pNext = pNewNode; <br>                break; // Out of the WHILE() loop <br>            } <br>            pNode = pNode-&gt;pNext; <br>        } <br>    } <br>    else <br>    { <br>        m_pHead = pNewNode; <br>    } <br>    LeaveCriticalSection (&amp;m_csObj); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CObjectList::Delete() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CObjectList::Delete (DWORD dwObjID) <br>{ <br>    HRESULT hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND); <br>    EnterCriticalSection (&amp;m_csObj); <br>    POBJLIST_NODE pNext, pPrev = NULL, pNode = m_pHead; <br>    while (pNode) <br>    { <br>        if (pNode-&gt;dwObjID == dwObjID) <br>        { <br>            // If the node is the head of the list, make the head point to the next node <br>            if (m_pHead == pNode) <br>            { <br>                m_pHead = m_pHead-&gt;pNext; <br>            } <br>            // Save the next pointer so that we may delete the current node <br>            pNext = pNode-&gt;pNext; <br>            HeapFree (m_hHeap, 0, pNode); <br>            if (pPrev) <br>            { <br>                pPrev-&gt;pNext = pNext; <br>            } <br>            hResult = S_OK; <br>            break; // Out of the WHILE() loop <br>        } <br>        else <br>        { <br>            pPrev = pNode; <br>            pNode = pNode-&gt;pNext; <br>        } <br>    } <br>    LeaveCriticalSection (&amp;m_csObj); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CObjectList::FindObjFromID() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CObjectList::FindObjFromID (DWORD              dwObjID, <br>                                         LPTSTR             pObjName, <br>                                         WINDS_AB_OBJTYPE * pObjType) <br>{ <br>    HRESULT hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND); <br>    EnterCriticalSection (&amp;m_csObj); <br>    POBJLIST_NODE pNode = m_pHead; <br>    while (pNode) <br>    { <br>        if (pNode-&gt;dwObjID == dwObjID) <br>        { <br>            *pObjType = pNode-&gt;ObjType; <br>            lstrcpy (pObjName, pNode-&gt;szObjAlias); <br>            hResult = S_OK;  <br>            break; // Out of the WHILE() loop <br>        } <br>        pNode = pNode-&gt;pNext; <br>    } <br>    LeaveCriticalSection (&amp;m_csObj); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CObjectList::FindObjFromName() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CObjectList::FindObjFromName (WINDS_AB_OBJTYPE     ObjType, <br>                                           LPTSTR               pObjName, <br>                                           DWORD *              pdwObjID) <br>{ <br>    HRESULT hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND); <br>    EnterCriticalSection (&amp;m_csObj); <br>    POBJLIST_NODE pNode = m_pHead; <br>    while (pNode) <br>    { <br>        if (pNode-&gt;ObjType == ObjType &amp;&amp; 0 == lstrcmpi (pNode-&gt;szObjAlias, pObjName)) <br>        { <br>            *pdwObjID = pNode-&gt;dwObjID; <br>            hResult = S_OK; <br>            break; // Out of the WHILE() loop <br>        } <br>        pNode = pNode-&gt;pNext; <br>    } <br>    LeaveCriticalSection (&amp;m_csObj); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CObjectList::FindObjAndTypeFromName() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CObjectList::FindObjAndTypeFromName (LPTSTR               pObjName, <br>                                                  WINDS_AB_OBJTYPE *   pObjType, <br>                                                  DWORD *              pdwObjID) <br>{ <br>    HRESULT hResult = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND); <br>    EnterCriticalSection (&amp;m_csObj); <br>    POBJLIST_NODE pNode = m_pHead; <br>    while (pNode) <br>    { <br>        if (0 == lstrcmpi (pNode-&gt;szObjAlias, pObjName)) <br>        { <br>            *pObjType = pNode-&gt;ObjType; <br>            *pdwObjID = pNode-&gt;dwObjID; <br>            hResult = S_OK; <br>            break; // Out of the WHILE() loop <br>        } <br>        pNode = pNode-&gt;pNext; <br>    } <br>    LeaveCriticalSection (&amp;m_csObj); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CObjectList::IsAliasNameAvailable() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>BOOL WINAPI CObjectList::IsAliasNameAvailable (LPTSTR pObjName) <br>{ <br>    BOOL bResult = TRUE; <br>    EnterCriticalSection (&amp;m_csObj); <br>    POBJLIST_NODE pNode = m_pHead; <br>    while (pNode) <br>    { <br>        if (0 == lstrcmpi (pNode-&gt;szObjAlias, pObjName)) <br>        { <br>            bResult = FALSE; <br>            break; // Out of the WHILE() loop <br>        } <br>        pNode = pNode-&gt;pNext; <br>    } <br>    LeaveCriticalSection (&amp;m_csObj); <br>    return bResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateDLsDirectory() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CreateDLsDirectory (LPSTORAGE pStorage) <br>{ <br>    LPSTORAGE pPFStg; <br>    HRESULT hResult = pStorage-&gt;CreateStorage (DISTRIBUTION_LISTS, CREATE_FLAGS, 0, 0, &amp;pPFStg); <br>    if (!hResult) <br>    { <br>        pPFStg-&gt;Release(); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreatePublicFoldersDirectory() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI CreatePublicFoldersDirectory (LPSTORAGE pStorage) <br>{ <br>    LPSTORAGE pPFStg; <br>    HRESULT hResult = pStorage-&gt;CreateStorage (PUBLIC_FOLDERS_ROOT, CREATE_FLAGS, 0, 0, &amp;pPFStg); <br>    if (!hResult) <br>    { <br>        pPFStg-&gt;Release(); <br>    } <br>    return hResult; <br>} <br> <br>// End of file for SUPPORT.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
