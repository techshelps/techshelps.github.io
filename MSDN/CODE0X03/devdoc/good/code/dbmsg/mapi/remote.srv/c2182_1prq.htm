<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVICE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2186"></a>SERVICE.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      SERVICE.CPP <br>// <br>//  Description <br>//      This is the file where the entry point is (WinMain). <br>//      Here we also implement the registration and unregistration of <br>//      the RPC server. <br>//      The server register its services with NAMED PIPES as the exposed <br>//      protocol sequence for RPC calls. This server can only be run on <br>//      Windows NT platforms. Windows 95 does not support the creation of <br>//      named pipes. <br>//      This is where we register the NT service with the Service control <br>//      manager and where the service control handler is implemented <br>// <br>//      The WinMain, function can take certain paramenters from the command <br>//      line to control the action of the executable <br>// <br>//      Argument        Action <br>//      ========        ====== <br>//      &lt;None&gt;          If normally started by the Service control manager, <br>//                      the WINDS NT Service starts and it is ready to accept <br>//                      request from WINDS MAPI service providers and from <br>//                      the WINDS administrator. <br>//                      If started as an application, a message dialog will <br>//                      come up to allow interactive install and removal of <br>//                      the service. <br>// <br>//      APP             Start the service as an APPLICATION EXECUTABLE, as <br>//                      opposed to an NT SERVICE. This is useful for <br>//                      debugging the WINDS server. <br>// <br>//      INSTALL         Adds the WINDS NT Service to the Service Control <br>//                      Manager list, modify the registry entries and starts <br>//                      the NT services normally. <br>// <br>//      REMOVE          Remove the WINDS NT service from the Service <br>//                      control list, and stops the WINDS service, halting <br>//                      services WINDS MAPI providers and WINDS administrators <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "_WINDS.H" <br>#include &lt;WINDOWSX.H&gt; <br>#include "WRAP3D.H" <br>#include &lt;RPC.H&gt; <br>#include "WINDS.H"     // Header file generated by the MIDL compiler <br>#include "WDSADM.H"    // Header file generated by the MIDL compiler <br>#include "COMMON.H" <br> <br>extern "C" <br>{ <br>    BOOL WINAPI InitRPCServer <br>                        (); <br>    BOOL WINAPI TerminateAllRPCServer <br>                        (); <br>    void WINAPI RegisterWindsPrivateClass <br>                        (); <br>    void WindsServiceMain <br>                        (DWORD                      dwArgc, <br>                         LPTSTR *                   pszArgv); <br>    void WindsServiceCtrlHandler <br>                        (DWORD                      dwControlCode); <br>    void WINAPI TerminateService <br>                        (HRESULT                    hErrror); <br>    HRESULT WINAPI SendStatusToSCM <br>                        (DWORD                      dwServiceState, <br>                         HRESULT                    hError, <br>                         DWORD                      dwCheckPoint, <br>                         DWORD                      dwWait); <br>    HRESULT WINAPI InstallWindsService <br>                        (DWORD                      dwStartType, <br>                         LPTSTR                     szFullPathToServiceExe, <br>                         BOOL                       fStartImmediately); <br>    HRESULT WINAPI RemoveWindsService <br>                        (); <br>    HRESULT WINAPI InitWindsService <br>                        (); <br>    void WINAPI PauseWindsService <br>                        (); <br>    void WINAPI ResumeWindsService <br>                        (); <br>    void WINAPI StopWindsService <br>                        (); <br>    BOOL CALLBACK GenericDlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK InstallDlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    LRESULT CALLBACK PrivateDlgClassProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br> <br>    TCHAR g_szAppTitle[] = TEXT("WINDS Messaging Host"); <br>    HINSTANCE ghInstance = NULL; <br>    HANDLE ghHeap = NULL; <br>    IOTHREADINFO     g_IOInfo = { 0 }; <br>    TCHAR            g_szDataFile[MAX_PATH] = { 0 }; <br>    HRESULT          g_hServerState = HRESULT_FROM_WIN32(ERROR_BUSY); <br>    CRITICAL_SECTION g_csIOInfo; <br>    CRITICAL_SECTION g_csNotifLinks; <br>    CRITICAL_SECTION g_csServiceState; <br>    CRITICAL_SECTION g_csPipeID; <br>    DWORD g_dwNextPipeID = MIN_PIPE_NUMBER; <br> <br>    SERVICE_STATUS_HANDLE   g_ssHandle = NULL; <br>    HANDLE                  g_hTerminateEvent = NULL; <br>    LPVOID                  g_pctl3d = NULL; <br>}; <br> <br>CObjectList GlobalObjectMap; <br> <br>#define WINDS_SERVICE_NAME          TEXT("WINDS Messaging Host") <br>#define WINDS_SERVICE_NAME_SHORT    TEXT("WindsMessagingHost") <br>#define WINDS_SERVICE_EXECUTABLE    TEXT("\\WINDSSRV.EXE") <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WindsServiceMain() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on ServiceMain } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      None <br>//       <br>void WindsServiceMain (DWORD dwArgc, LPTSTR * pszArgv) <br>{ <br>    g_ssHandle = RegisterServiceCtrlHandler (WINDS_SERVICE_NAME, <br>                                             (LPHANDLER_FUNCTION)WindsServiceCtrlHandler); <br>    if (NULL == g_ssHandle) <br>    { <br>        TraceResult ("WindsServiceMain: Failed to register the control handle", HRESULT_FROM_WIN32(GetLastError())); <br>        return; <br>    } <br>    HRESULT hResult = SendStatusToSCM (SERVICE_START_PENDING, S_OK, 1, 5); <br>    if (hResult) <br>    { <br>        TerminateService (hResult); <br>        return; <br>    } <br>    g_hTerminateEvent = CreateEvent (0, TRUE, FALSE, 0); <br>    if (NULL == g_hTerminateEvent) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("WindsServiceMain: Failed to create terminate event", hResult); <br>        TerminateService (hResult); <br>        return; <br>    } <br> <br>    hResult = SendStatusToSCM (SERVICE_START_PENDING, S_OK, 2, 1); <br>    if (!hResult) <br>    { <br>        hResult = InitWindsService(); <br>        if (!hResult) <br>        { <br>            hResult = SendStatusToSCM (SERVICE_RUNNING, S_OK, 0, 0); <br>            // If an error occured, terminate the service <br>            if (hResult) <br>            { <br>                StopWindsService(); <br>            } <br>        } <br>    } <br>    if (S_OK == hResult) <br>    { <br>        WaitForSingleObject (g_hTerminateEvent, INFINITE); <br>    } <br>    TerminateService (hResult); <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    TerminateService() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      None <br>//       <br>void WINAPI TerminateService (HRESULT hError) <br>{ <br>    if (g_hTerminateEvent) <br>    { <br>        CloseHandle (g_hTerminateEvent); <br>    } <br>    if (g_ssHandle) <br>    { <br>        SendStatusToSCM (SERVICE_STOPPED, hError, 0, 0); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    SendStatusToSCM() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      None <br>//       <br>HRESULT WINAPI SendStatusToSCM (DWORD   dwServiceState, <br>                                HRESULT hError, <br>                                DWORD   dwCheckPoint, <br>                                DWORD   dwWait) <br>{ <br>    SERVICE_STATUS ssStatus = { 0 }; <br>    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS; <br>    ssStatus.dwCurrentState = dwServiceState; <br>    if (SERVICE_START_PENDING == dwServiceState) <br>    { <br>        ssStatus.dwControlsAccepted = 0; <br>    } <br>    else <br>    { <br>        ssStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | <br>                                      SERVICE_ACCEPT_PAUSE_CONTINUE | <br>                                      SERVICE_ACCEPT_SHUTDOWN; <br>    } <br>    if (hError) <br>    { <br>        ssStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR; <br>        ssStatus.dwServiceSpecificExitCode = (DWORD)hError; <br>    } <br>    ssStatus.dwCheckPoint = dwCheckPoint; <br>    ssStatus.dwWaitHint = (dwWait * 1000); <br>     <br>    HRESULT hResult = S_OK; <br>    if (!SetServiceStatus (g_ssHandle, &amp;ssStatus)) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("SendStatusToSCM: Failed to set service status", hResult); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WindsServiceCtrlHandler() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      None <br>//       <br>void WindsServiceCtrlHandler (DWORD dwControlCode) <br>{ <br>    switch (dwControlCode) <br>    { <br>        case SERVICE_CONTROL_SHUTDOWN : <br>        case SERVICE_CONTROL_STOP : <br>            SendStatusToSCM (SERVICE_STOP_PENDING, S_OK, 1, 10); <br>            StopWindsService(); <br>            SendStatusToSCM (SERVICE_STOPPED, S_OK, 0, 0); <br>            break; <br> <br>        case SERVICE_CONTROL_PAUSE : <br>            SendStatusToSCM (SERVICE_PAUSE_PENDING, S_OK, 1, 1); <br>            PauseWindsService(); <br>            SendStatusToSCM (SERVICE_PAUSED, S_OK, 0, 0); <br>            break; <br> <br>        case SERVICE_CONTROL_CONTINUE : <br>            SendStatusToSCM (SERVICE_CONTINUE_PENDING, S_OK, 1, 1); <br>            ResumeWindsService(); <br>            SendStatusToSCM (SERVICE_RUNNING, S_OK, 0, 0); <br>            break; <br> <br>        case SERVICE_CONTROL_INTERROGATE : <br>            SendStatusToSCM (0, S_OK, 0, 0); <br>            break; <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    InitWindsService() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI InitWindsService() <br>{ <br>    HRESULT hResult = S_OK; <br>    LoadSettingsFromRegistry(); <br>    SaveSettingsToRegistry(); <br> <br>    InitializeCriticalSection (&amp;g_csIOInfo); <br>    InitializeCriticalSection (&amp;g_csPipeID); <br>    InitializeCriticalSection (&amp;g_csNotifLinks); <br>    InitializeCriticalSection (&amp;g_csServiceState); <br> <br>    g_IOInfo.hResumeEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!g_IOInfo.hResumeEvent) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("InitWindsService: Failed to create sync object (EVENT)", hResult); <br>        return FALSE; <br>    } <br> <br>    DWORD dwThreadID; <br>    HANDLE hThread = CreateThread (NULL, <br>                                   0, <br>                                   (LPTHREAD_START_ROUTINE)WorkingIOProc, <br>                                   NULL, <br>                                   0, <br>                                   &amp;dwThreadID); <br>    if (!hThread) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("InitWindsService: Failed to create I/O thread", hResult); <br>        ReleaseSyncObj(); <br>        return hResult; <br>    } <br>    TraceDebugger ("InitWindsService: IO thread spawned. ID: %X", dwThreadID); <br>    SetThreadPriority (hThread, THREAD_PRIORITY_HIGHEST); <br>    CloseHandle (hThread); <br>     <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br> <br>    if (InitRPCServer()) <br>    { <br>        EnterCriticalSection (&amp;g_csIOInfo); <br>        SetEvent (g_IOInfo.hResumeEvent); <br>        g_IOInfo.Action           = IO_OPEN_STORAGE_FILE; <br>        g_IOInfo.hActionCompleted = hWaitEvent; <br>        g_IOInfo.phLastError      = &amp;hResult; <br>        LeaveCriticalSection (&amp;g_csIOInfo); <br>        WaitForSingleObject (hWaitEvent, INFINITE); <br>    } <br>    else <br>    { <br>        TraceMessage ("InitWindsService: Failed to initialize the RPC server"); <br>        hResult = E_FAIL; <br>    } <br>    CloseHandle (hWaitEvent); <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action            = IO_LOAD_MAILBOX_NAMES; <br>    g_IOInfo.hActionCompleted  = NULL; <br>    g_IOInfo.phLastError       = NULL; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PauseWindsService() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI PauseWindsService() <br>{ <br>    EnterCriticalSection (&amp;g_csServiceState); <br>    g_hServerState = HRESULT_FROM_WIN32(ERROR_SERVICE_CANNOT_ACCEPT_CTRL); <br>    LeaveCriticalSection (&amp;g_csServiceState); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ResumeWindsService() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI ResumeWindsService() <br>{ <br>    EnterCriticalSection (&amp;g_csServiceState); <br>    g_hServerState = S_OK; <br>    LeaveCriticalSection (&amp;g_csServiceState); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    StopWindsService() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI StopWindsService() <br>{ <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br> <br>    PWINDS_NOTIFICATION pNotif = (PWINDS_NOTIFICATION)HeapAlloc (ghHeap, <br>                                                                 HEAP_ZERO_MEMORY, <br>                                                                 sizeof(WINDS_NOTIFICATION)); <br>    if (pNotif) <br>    { <br>        pNotif-&gt;Event = SERVER_IS_SHUTTING_DOWN; <br>        EnterCriticalSection (&amp;g_csIOInfo); <br>        SetEvent (g_IOInfo.hResumeEvent); <br>        g_IOInfo.Action           = IO_SENT_SHUTDOWN_NOTIFICATION; <br>        g_IOInfo.hActionCompleted = hWaitEvent; <br>        g_IOInfo.pNotif           = pNotif; <br>        g_IOInfo.phLastError      = NULL; <br>        LeaveCriticalSection (&amp;g_csIOInfo); <br>        WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    } <br>    else <br>    { <br>        TraceMessage ("StopWindsService: Failed to create structure for shutdown notification"); <br>    } <br>    TerminateAllRPCServer(); <br>    RemoveAllNotifLinks(); <br>     <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    // Resume the thread so that it terminate ifself properly <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.fAppIsTerminating = TRUE; <br>    g_IOInfo.hActionCompleted  = hWaitEvent; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>     <br>    CloseHandle (hWaitEvent); <br>     <br>    UnInitTraces (); <br>     <br>    ReleaseSyncObj(); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    InstallWindsService() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI InstallWindsService (DWORD   dwStartType, <br>                                    LPTSTR  szFullPathToServiceExe, <br>                                    BOOL    fStartImmediately) <br>{ <br>    HRESULT hResult = S_OK; <br>    SC_HANDLE schSCM, schWINDS; <br>    schSCM = OpenSCManager (0, 0, SC_MANAGER_CREATE_SERVICE); <br>    if (NULL == schSCM) <br>    { <br>        hResult = HRESULT_FROM_WIN32 (GetLastError()); <br>    } <br>    else <br>    { <br>RestartInstall: <br>        schWINDS = CreateService (schSCM, <br>                                  WINDS_SERVICE_NAME_SHORT, <br>                                  WINDS_SERVICE_NAME, <br>                                  SERVICE_ALL_ACCESS, <br>                                  SERVICE_WIN32_OWN_PROCESS, <br>                                  dwStartType, <br>                                  SERVICE_ERROR_NORMAL, <br>                                  szFullPathToServiceExe, <br>                                  NULL, <br>                                  NULL, <br>                                  NULL, <br>                                  NULL, <br>                                  NULL); <br>        if (NULL == schWINDS) <br>        { <br>            hResult = HRESULT_FROM_WIN32 (GetLastError()); <br>        } <br>        else <br>        { <br>            if (fStartImmediately) <br>            { <br>                StartService (schWINDS, 0, NULL); <br>            } <br>            CloseServiceHandle (schWINDS); <br>        } <br>        if (HRESULT_FROM_WIN32 (ERROR_SERVICE_EXISTS) == hResult) <br>        { <br>            RemoveWindsService(); <br>            goto RestartInstall; <br>        } <br>        CloseServiceHandle (schSCM); <br>    } <br>    TraceResult ("InstallWindsService", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoveWindsService() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI RemoveWindsService() <br>{ <br>    HRESULT hResult = S_OK; <br>    SC_HANDLE schSCM, schWINDS; <br>    schSCM = OpenSCManager (0, 0, SC_MANAGER_CREATE_SERVICE); <br>    if (NULL == schSCM) <br>    { <br>        hResult = HRESULT_FROM_WIN32 (GetLastError()); <br>    } <br>    else <br>    { <br>        schWINDS = OpenService (schSCM, <br>                                WINDS_SERVICE_NAME_SHORT, <br>                                SERVICE_ALL_ACCESS); <br>        if (NULL == schWINDS) <br>        { <br>            hResult = HRESULT_FROM_WIN32 (GetLastError()); <br>        } <br>        else <br>        { <br>            SERVICE_STATUS ssState; <br>            ControlService (schWINDS, SERVICE_CONTROL_STOP, &amp;ssState); <br>            DeleteService (schWINDS); <br>            CloseServiceHandle (schWINDS); <br>        } <br>        CloseServiceHandle (schSCM); <br>    } <br>    TraceResult ("RemoveWindsService", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WinMain() <br>// <br>//    Parameters <br>//      { Refer to Win32 SDK documentation } <br>//       <br>//    Purpose <br>//      This is the entry function. The application will start executing here. <br>//       <br>//    Return Value <br>//      Return code of the application to the system. <br>//       <br>int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCmdLine, int nCmdShow) <br>{ <br>    InitTraces (TRACES_NO_ASSERT_DIALOG | TRACES_NO_COM_OUTPUT); <br>    //InitTraces (TRACES_NO_ASSERT_DIALOG); <br>    ghInstance = hInstance; <br>    ghHeap = GetProcessHeap(); <br> <br>    if (0 == lstrcmpi ("APP", pszCmdLine)) <br>    { <br>        // Check for other instances of this application running. If one is found, <br>        // bring it to the foreground <br>        HWND hOtherInstance = FindWindow (MAINDLGCLASS, NULL); <br>        if (NULL != hOtherInstance) <br>        { <br>            HWND hChildWnd = GetLastActivePopup (hOtherInstance); <br>            if (hChildWnd != hOtherInstance) <br>            { <br>                BringWindowToTop (hOtherInstance); <br>            } <br>            else <br>            { <br>                SetForegroundWindow (hOtherInstance); <br>            } <br>            return 1; <br>        } <br> <br>        RegisterWindsPrivateClass(); <br> <br>        if (S_OK != InitWindsService()) <br>        { <br>            return -1; <br>        } <br>     <br>        DialogBoxParam (ghInstance, MAKEINTRESOURCE(IDD_WINDS_APP), NULL, GenericDlgProc, (LPARAM)TRUE); <br>     <br>        StopWindsService(); <br> <br>        return 0; <br>    } <br> <br>    if (0 == lstrcmpi ("INSTALL", pszCmdLine)) <br>    { <br>        TCHAR szFullPath[_MAX_PATH] = { 0 }; <br>        GetCurrentDirectory (_MAX_PATH, szFullPath); <br>        lstrcat (szFullPath, WINDS_SERVICE_EXECUTABLE); <br>        if (S_OK != InstallWindsService (SERVICE_AUTO_START, szFullPath, TRUE)) <br>        { <br>            return -1; <br>        } <br>        return 0; <br>    } <br> <br>    if (0 == lstrcmpi ("REMOVE", pszCmdLine)) <br>    { <br>        if (S_OK != RemoveWindsService()) <br>        { <br>            return -1; <br>        } <br>        return 0; <br>    } <br> <br>    SERVICE_TABLE_ENTRY ServiceTable[] = <br>    { <br>        { WINDS_SERVICE_NAME, <br>          (LPSERVICE_MAIN_FUNCTION)WindsServiceMain, <br>        }, <br>        { NULL, NULL } <br>    }; <br> <br>    if (FALSE == StartServiceCtrlDispatcher (ServiceTable)) <br>    { <br>        if (ERROR_FAILED_SERVICE_CONTROLLER_CONNECT == GetLastError()) <br>        { <br>            RegisterWindsPrivateClass(); <br>            DialogBoxParam (ghInstance, MAKEINTRESOURCE(IDD_WINDS_DIALOG), NULL, GenericDlgProc, (LPARAM)FALSE); <br>        } <br>    } <br>    return 0; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    InitRPCServer() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>BOOL WINAPI InitRPCServer() <br>{ <br>    #define MAX_NUM_OF_CALLS    65536 <br>    RPC_STATUS status = RpcServerUseProtseqEp ((WINDS_RPC_STRING)WINDS_RPC_PROTOCOL, <br>                                               MAX_NUM_OF_CALLS, <br>                                               (WINDS_RPC_STRING)WINDS_PROVIDERS_RPC_ENDPOINT, <br>                                               NULL);  // Security descriptor <br>    if (status) <br>    { <br>        TraceMessage ("InitRPCServer: RpcServerUseProtseqEp failed (PROVIDER)"); <br>        goto ErrorExit; <br>    } <br> <br>    status = RpcServerRegisterIf (WINDSREM_v1_6_s_ifspec,   // Interface to register <br>                                  NULL,                     // MgrTypeUuid <br>                                  NULL);                    // MgrEpv; null means use default <br>    if (status) <br>    { <br>        TraceMessage ("InitRPCServer: RpcServerRegisterIf failed (PROVIDER)"); <br>        goto ErrorExit; <br>    } <br> <br>    status = RpcServerUseProtseqEp ((WINDS_RPC_STRING)WINDS_RPC_PROTOCOL, <br>                                    MAX_NUM_OF_CALLS, <br>                                    (WINDS_RPC_STRING)WINDS_ADMIN_RPC_ENDPOINT, <br>                                    NULL);  // Security descriptor <br>    if (status) <br>    { <br>        TraceMessage ("InitRPCServer: RpcServerUseProtseqEp failed (ADMIN)"); <br>        goto ErrorExit; <br>    } <br>     <br>    status = RpcServerRegisterIf (WINDSADM_v1_0_s_ifspec,   // Interface to register <br>                                  NULL,                     // MgrTypeUuid <br>                                  NULL);                    // MgrEpv; null means use default <br>    if (status) <br>    { <br>        TraceMessage ("InitRPCServer: RpcServerRegisterIf failed (ADMIN)"); <br>        goto ErrorExit; <br>    } <br> <br>    status = RpcServerListen (1, MAX_NUM_OF_CALLS, TRUE); <br>    if (status) <br>    { <br>        TraceMessage ("InitRPCServer: RpcServerListen failed"); <br>        goto ErrorExit; <br>    } <br>ErrorExit: <br>    if (status) <br>    { <br>        TraceResult ("InitRPCServer", MAKE_HRESULT(1, FACILITY_RPC, status)); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    TerminateAllRPCServer() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>BOOL WINAPI TerminateAllRPCServer() <br>{ <br>    RPC_STATUS status = RpcMgmtStopServerListening (NULL); <br>    if (status) <br>    { <br>        TraceMessage ("TerminateRPCServer: RpcMgmtStopServerListening failed"); <br>    } <br>    else <br>    { <br>        status = RpcServerUnregisterIf (NULL, NULL, FALSE); <br>        if (status) <br>        { <br>            TraceMessage ("TerminateRPCServer: RpcServerUnregisterIf failed"); <br>        } <br>    } <br>    if (status) <br>    { <br>        TraceResult ("TerminateRPCServer", MAKE_HRESULT(1, FACILITY_RPC, status)); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetServiceState() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetServiceState() <br>{ <br>    HRESULT hServiceState; <br>    EnterCriticalSection (&amp;g_csServiceState); <br>    hServiceState = g_hServerState; <br>    LeaveCriticalSection (&amp;g_csServiceState); <br>    return hServiceState; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PrivateDlgClassProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>LRESULT CALLBACK PrivateDlgClassProc (HWND    hDlg,  <br>                                      UINT    message,  <br>                                      WPARAM  wParam,  <br>                                      LPARAM  lParam) <br>{ <br>    return DefDlgProc (hDlg, message, wParam, lParam); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RegisterWindsPrivateClass() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI RegisterWindsPrivateClass() <br>{ <br>    WNDCLASS wc = { 0 }; <br>    // Register the class for this application <br>    wc.hInstance        = ghInstance; <br>    wc.hCursor          = LoadCursor (NULL, IDC_ARROW); <br>    wc.lpfnWndProc      = PrivateDlgClassProc; <br>    wc.cbWndExtra       = DLGWINDOWEXTRA; <br>    wc.hIcon            = LoadIcon (ghInstance, MAKEINTRESOURCE (IDI_WINDSSERVICE)); <br>    wc.lpszClassName    = MAINDLGCLASS; <br>    if (!RegisterClass (&amp;wc)) <br>    { <br>        TraceResult ("RegisterWindsPrivateClass: Failed to register the main class", HRESULT_FROM_WIN32(GetLastError())); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GenericDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK GenericDlgProc (HWND    hDlg,  <br>                              UINT    message,  <br>                              WPARAM  wParam,  <br>                              LPARAM  lParam) <br>{ <br>    HRESULT hResult; <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            if (TRUE == lParam) <br>            { <br>                ShowWindow (hDlg, SW_MINIMIZE); <br>            } <br>            else <br>            { <br>                if (!g_pctl3d) <br>                { <br>                    BOOL f; <br>                    g_pctl3d = CTL3D_Initialize(ghInstance); <br>                    CTL3D_AutoSubclass(g_pctl3d, ghInstance, &amp;f); <br>                } <br>                CenterDialogBox (hDlg); <br>            } <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDOK : <br>                case IDCANCEL : <br>                    PostMessage (hDlg, WM_SYSCOMMAND, SC_CLOSE, 0); <br>                    return TRUE; <br> <br>                case IDC_INSTALL_SERVICE : <br>                    DialogBox (ghInstance, MAKEINTRESOURCE(IDD_INSTALL_OPTIONS), hDlg, InstallDlgProc); <br>                    break; <br> <br>                case IDC_REMOVE_SERVICE : <br>                    hResult = RemoveWindsService(); <br>                    if (S_OK == hResult) <br>                    { <br>                        MessageBox (hDlg, <br>                                    TEXT("Service successfully removed"), <br>                                    TEXT("WINDS Services - Remove"), <br>                                    MB_OK | MB_ICONEXCLAMATION); <br>                    } <br>                    else <br>                    { <br>                        MessageBox (hDlg, <br>                                    TEXT("Failed to remove the service"), <br>                                    TEXT("WINDS Services - Remove"), <br>                                    MB_OK | MB_ICONSTOP); <br>                    } <br>                    break; <br>            } <br>            break; <br> <br>        case WM_SYSCOMMAND: <br>            if (wParam == SC_CLOSE) <br>            { <br>                CTL3D_Uninitialize(g_pctl3d); <br>                g_pctl3d = NULL; <br>                EndDialog (hDlg, TRUE); <br>                return TRUE; <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    InstallDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK InstallDlgProc (HWND    hDlg,  <br>                              UINT    message,  <br>                              WPARAM  wParam,  <br>                              LPARAM  lParam) <br>{ <br>    TCHAR szFullPath[_MAX_PATH]; <br>    DWORD dwStart; <br>    BOOL fStartNow; <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            CenterDialogBox (hDlg); <br>            Edit_LimitText (GetDlgItem (hDlg, IDC_SERVICE_FILEPATH), _MAX_PATH - 1); <br>            GetCurrentDirectory (_MAX_PATH, szFullPath); <br>            lstrcat (szFullPath, WINDS_SERVICE_EXECUTABLE); <br>            SetWindowText (GetDlgItem (hDlg, IDC_SERVICE_FILEPATH), szFullPath); <br>            Button_SetCheck (GetDlgItem (hDlg, IDC_AUTO_START), BST_CHECKED); <br>            Button_SetCheck (GetDlgItem (hDlg, IDC_START_NOW), BST_CHECKED); </code></pre>
<p>
</p>
<pre><code>return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDOK : <br>                    GetWindowText (GetDlgItem (hDlg, IDC_SERVICE_FILEPATH), szFullPath, _MAX_PATH); <br>                    if (BST_CHECKED == Button_GetCheck (GetDlgItem (hDlg, IDC_AUTO_START))) <br>                    { <br>                        dwStart = SERVICE_AUTO_START; <br>                    } <br>                    else <br>                    { <br>                        dwStart = SERVICE_DEMAND_START; <br>                    } <br>                    if (BST_CHECKED == Button_GetCheck (GetDlgItem (hDlg, IDC_START_NOW))) <br>                    { <br>                        fStartNow = TRUE; <br>                    } <br>                    else <br>                    { <br>                        fStartNow = FALSE; <br>                    } <br>                    if (lstrlen (szFullPath) &amp;&amp; S_OK == InstallWindsService (dwStart, szFullPath, fStartNow)) <br>                    { <br>                        MessageBox (hDlg, <br>                                    TEXT("Service successfully installed"), <br>                                    TEXT("WINDS Services - Install"), <br>                                    MB_OK | MB_ICONEXCLAMATION); <br>                    } <br>                    else <br>                    { <br>                        MessageBox (hDlg, <br>                                    TEXT("Failed to install the service"), <br>                                    TEXT("WINDS Services - Install"), <br>                                    MB_OK | MB_ICONSTOP); <br>                    } <br>                    // Fall through <br>                case IDCANCEL : <br>                    EndDialog (hDlg, TRUE); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>// End of file for SERVICE.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
