<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RABRPC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2180"></a>RABRPC.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      RABRPC.CPP <br>// <br>//  Description <br>//      This file implements all the remote functions available to client <br>//      WINDS address book providers.  <br>//       <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "_WINDS.H" <br>#include &lt;RPC.H&gt; <br>#include "WINDS.H"      // Header file generated by the MIDL compiler <br>#include "WDSADM.H"     // Header file generated by the MIDL compiler <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteChangePasswordA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteChangePasswordA (unsigned char *  szMailbox, <br>                            unsigned char *  szOldPassword, <br>                            unsigned char *  szNewPassword) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    MAILBOX_INFO MBInfo = { 0 }; <br>    if (S_OK != GlobalObjectMap.FindObjFromName (SERVER_USER_MAILBOX, (LPSTR)szMailbox, &amp;MBInfo.dwObjID)) <br>    { <br>        TraceMessage ("RemoteChangePasswordA: Invalid mailbox"); <br>        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER); <br>    } <br>    lstrcpy (MBInfo.szMailboxName, (LPSTR)szMailbox); <br>     <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteChangePasswordA: Failed to create I/O event", lResult); <br>        return lResult; <br>    } <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_GET_MAILBOX_PROPERTIES; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pMBInfo          = &amp;MBInfo; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    if (S_OK == lResult) <br>    { <br>        if (0 == lstrcmp (MBInfo.szPassword, (LPSTR)szOldPassword)) <br>        { <br>            lstrcpy (MBInfo.szPassword, (LPSTR)szNewPassword); <br>            EnterCriticalSection (&amp;g_csIOInfo); <br>            SetEvent (g_IOInfo.hResumeEvent); <br>            g_IOInfo.Action           = IO_SET_MAILBOX_PROPERTIES; <br>            g_IOInfo.hActionCompleted = hWaitEvent; <br>            g_IOInfo.phLastError      = &amp;lResult; <br>            g_IOInfo.pMBInfo          = &amp;MBInfo; <br>            LeaveCriticalSection (&amp;g_csIOInfo); <br>            WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>        } <br>        else <br>        { <br>            lResult = HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD); <br>        } <br>    } <br>    CloseHandle (hWaitEvent); <br>    TraceResult ("RemoteChangePasswordA", lResult); <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteGetRecipientPropsA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteGetRecipientPropsA (unsigned long    dwObjID, <br>                               unsigned long *  pdwObjType, <br>                               unsigned char *  szMailboxName, <br>                               unsigned char *  szFullName, <br>                               unsigned char *  szJobTitle, <br>                               unsigned char *  szOffice, <br>                               unsigned char *  szPhone, <br>                               unsigned char *  szAltPhone, <br>                               unsigned char *  szFax, <br>                               unsigned char *  szComments, <br>                               unsigned char *  szCompany, <br>                               unsigned char *  szDepartment, <br>                               unsigned char *  szManagerName, <br>                               unsigned char *  szManagerAlias, <br>                               unsigned long *  pdwManagerID) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    MAILBOX_INFO_A MBInfo = { 0 }; <br>    MBInfo.dwObjID = dwObjID; <br>    lResult = GetObjectProp (dwObjID, pdwObjType, &amp;MBInfo); <br>    if (S_OK == lResult) <br>    { <br>        lstrcpy ((LPSTR)szMailboxName,  MBInfo.szMailboxName); <br>        lstrcpy ((LPSTR)szFullName,     MBInfo.szFullName); <br>        lstrcpy ((LPSTR)szJobTitle,     MBInfo.szJobTitle); <br>        lstrcpy ((LPSTR)szOffice,       MBInfo.szOffice); <br>        lstrcpy ((LPSTR)szPhone,        MBInfo.szPhone); <br>        lstrcpy ((LPSTR)szFax,          MBInfo.szFax); <br>        lstrcpy ((LPSTR)szComments,     MBInfo.szComments); <br>        lstrcpy ((LPSTR)szAltPhone,     MBInfo.szAltPhone); <br>        lstrcpy ((LPSTR)szCompany,      MBInfo.szCompany); <br>        lstrcpy ((LPSTR)szDepartment,   MBInfo.szDepartment); <br>        lstrcpy ((LPSTR)szManagerName,  MBInfo.szManagerName); <br>        lstrcpy ((LPSTR)szManagerAlias, MBInfo.szManagerAlias); <br>        *pdwManagerID = MBInfo.dwManagerID; <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetObjectProp() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetObjectProp (DWORD             dwObjID, <br>                              DWORD *           pdwObjType, <br>                              MAILBOX_INFO *    pMailboxInfo) <br>{ <br>    if (dwObjID == 0) <br>    { <br>        TraceMessage ("GetObjectProp: Invoked with Object ID = 0, cannot accept"); <br>        return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_USER); <br>    } <br> <br>    MAILBOX_INFO MBInfo = { 0 }; <br>    WINDS_AB_OBJTYPE Type = UNDEFINED_OBJECT_TYPE; <br>    // If an object with the given ID is not found or if the <br>    // found object is not the expected, the fail the client request <br>    if ((S_OK != GlobalObjectMap.FindObjFromID (dwObjID, MBInfo.szMailboxName, &amp;Type)) || <br>        (!(SERVER_USER_MAILBOX == Type || GATEWAY_RECIPIENT == Type))) <br>    { <br>        return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_USER); <br>    } <br>    ASSERT (SERVER_USER_MAILBOX == Type || GATEWAY_RECIPIENT == Type); <br>    *pdwObjType = (unsigned long)Type; <br>    HRESULT hResult; <br> <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("GetMailboxProp: Failed to create I/O event", hResult); <br>        return hResult; <br>    } <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    if (SERVER_USER_MAILBOX == Type) <br>    { <br>        g_IOInfo.Action = IO_GET_MAILBOX_PROPERTIES; <br>    } <br>    else <br>    { <br>        ASSERT (FALSE); // We haven't implemented gateway yet <br>        g_IOInfo.Action = IO_GET_MAILBOX_PROPERTIES; <br>    } <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;hResult; <br>    g_IOInfo.pMBInfo          = &amp;MBInfo; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>    if (!hResult) <br>    { <br>        if (SERVER_USER_MAILBOX == Type) <br>        { <br>            *pMailboxInfo = MBInfo; <br>        } <br>        else <br>        { <br>            ASSERT (FALSE); <br>            hResult = E_FAIL; <br>        } <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteGetDistListPropsA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteGetDistListPropsA (unsigned long     dwObjID, <br>                              unsigned char *   szDLAlias, <br>                              unsigned char *   szDLFullName, <br>                              unsigned long *   pdwContentCount, <br>                              unsigned char *   szOwnerAlias, <br>                              unsigned char *   szOwnerName, <br>                              unsigned char *   szComments) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    DIST_LIST_INFO DLInfo = { 0 }; <br>    WINDS_AB_OBJTYPE Type = UNDEFINED_OBJECT_TYPE; <br>    if ((S_OK != GlobalObjectMap.FindObjFromID (dwObjID, DLInfo.szDLAlias, &amp;Type)) || <br>        (SERVER_DISTRIBUTION_LIST != Type)) <br>    { <br>        return HRESULT_FROM_WIN32 (ERROR_NO_SUCH_GROUP); <br>    } <br> <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteGetDistListPropsA: Failed to create I/O event", lResult); <br>        return HRESULT_FROM_WIN32(lResult); <br>    } <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_GET_DL_PROPERTIES; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pDLInfo          = &amp;DLInfo; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>    if (!lResult) <br>    { <br>        lstrcpy ((LPSTR)szDLAlias, DLInfo.szDLAlias); <br>        lstrcpy ((LPSTR)szDLFullName, DLInfo.szDLFullName); <br>        lstrcpy ((LPSTR)szOwnerAlias, DLInfo.szOwnerAlias); <br>        lstrcpy ((LPSTR)szOwnerName, DLInfo.szOwnerName); <br>        lstrcpy ((LPSTR)szComments, DLInfo.szComments); <br>        *pdwContentCount = DLInfo.dwMemberCount; <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteGetContainerProps() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteGetContainerProps (unsigned long     dwContainerID, <br>                              unsigned long *   pdwContentCount) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    switch (dwContainerID) <br>    { <br>        case ROOT_CONTAINER_ID : <br>        case GATEWAY_CONTAINERS_ID : <br>        case GAL_CONTAINER_ID : <br>            *pdwContentCount = 0; <br>            if (GAL_CONTAINER_ID == dwContainerID) <br>            { <br>                *pdwContentCount = 0; <br>            } <br>            return S_OK; <br>        case FAX_CONTAINER_ID : <br>        case SMTP_CONTAINER_ID : <br>        case EXCHANGE_CONTAINER_ID : <br>            break; <br>         <br>        default : <br>            TraceMessage ("RemoteGetContainerProps: Invalid container ID passed in"); <br>            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_GROUP); <br>    } <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteGetContainerProps: Failed to create I/O event", lResult); <br>        return lResult; <br>    } <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_GET_GW_CONTAINER_COUNT; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pdwData          = pdwContentCount; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteGetContainerRecipients() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteGetContainerRecipients (unsigned long    dwFlags, <br>                                   unsigned long    dwContainerID, <br>                                   long *           pPipeNumber) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>     <br>    *pPipeNumber = GetNextPipeID(); <br> <br>    SECURITY_ATTRIBUTES sa; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    // Initialize the new security descriptor. <br>    InitializeSecurityDescriptor (&amp;sd, SECURITY_DESCRIPTOR_REVISION); <br> <br>    // Add a NULL descriptor ACL to the security descriptor. <br>    SetSecurityDescriptorDacl (&amp;sd, TRUE, (PACL)NULL, FALSE); <br> <br>    sa.nLength = sizeof(sa); <br>    sa.lpSecurityDescriptor = &amp;sd; <br>    sa.bInheritHandle = TRUE; <br> <br>    // Create a pipe where we will expect the transport to send the data <br>    TCHAR szPipeName[64]; <br>    wsprintf (szPipeName, SERVER_PIPE_NAME_FORMAT, *pPipeNumber); <br>    HANDLE hPipe; <br>    hPipe = CreateNamedPipe (szPipeName, <br>                             PIPE_ACCESS_OUTBOUND | FILE_FLAG_OVERLAPPED, <br>                             PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE, <br>                             1, <br>                             IO_BUFFERSIZE, <br>                             IO_BUFFERSIZE, <br>                             0, <br>                             &amp;sa); <br>    if (INVALID_HANDLE_VALUE == hPipe || ERROR_INVALID_PARAMETER == (DWORD)hPipe) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteGetContainerRecipients: Failed to create pipe", lResult); <br>        goto ErrorExit; <br>    } <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_GET_CONTAINER_RECIPIENTS; <br>    g_IOInfo.hActionCompleted = NULL; <br>    g_IOInfo.phLastError      = NULL; <br>    g_IOInfo.dwObjID          = dwContainerID; <br>    g_IOInfo.hTmpFile         = hPipe; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>ErrorExit: <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteIsServerRunning() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteIsServerRunning() <br>{ <br>    return GetServiceState(); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteGetAllAccounts() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteGetAllAccounts (long * pPipeNumber) <br>{ <br>    return RemoteAdmGetServerMailboxes (pPipeNumber); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteLogonMailBoxA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteLogonMailBoxA (unsigned char *    szMailbox, <br>                          unsigned char *    szPassword, <br>                          unsigned char *    szFullName, <br>                          unsigned long *    pdwMailboxID) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    if (S_OK != GlobalObjectMap.FindObjFromName (SERVER_USER_MAILBOX, (LPSTR)szMailbox, pdwMailboxID)) <br>    { <br>        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER); <br>    } <br> <br>    DWORD dwObjType; <br>    MAILBOX_INFO_A MBInfo = { 0 }; <br>    lResult = GetObjectProp (*pdwMailboxID, &amp;dwObjType, &amp;MBInfo); <br>    if (lstrcmp (MBInfo.szPassword, (LPSTR)szPassword)) <br>    { <br>        return HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD); <br>    } <br>    lstrcpy ((LPSTR)szMailbox, MBInfo.szMailboxName); <br>    lstrcpy ((LPSTR)szFullName, MBInfo.szFullName); <br>    return S_OK; <br>} <br> <br>// The UNICODE version of these function, has not been implemented yet. <br>long RemoteChangePasswordW (wchar_t *       szMailbox, <br>                            wchar_t *       szOldPassword, <br>                            wchar_t *       szNewPassword) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteLogonMailBoxW (wchar_t *          szMailbox, <br>                          wchar_t *          szPassword, <br>                          wchar_t *          szFullName, <br>                          unsigned long *    pdwMailboxID) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteLogonMailBoxAndSetNotifW (wchar_t *          szMailbox, <br>                                     wchar_t *          szPassword, <br>                                     wchar_t *          szFullName, <br>                                     unsigned long *    pdwMailboxID, <br>                                     wchar_t *          szComputerName, <br>                                     unsigned long      ulNotifMask, <br>                                     unsigned long *    pulConnectionID) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteTerminateNotifW (wchar_t *       szComputerName, <br>                            unsigned long   ulConnectionID) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteValidateNotifW (wchar_t *        szComputerName, <br>                           wchar_t *        szMailboxName, <br>                           unsigned long    ulNotifMask, <br>                           unsigned long *  pulConnectionID) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteOpenMsgUploadPipeW (wchar_t *        szSenderMailbox, <br>                               long *           pPipeNumber, <br>                               unsigned char *  szCookie) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteSendMsgToAccountW (wchar_t * szRecipAccount, <br>                              wchar_t * szHeaderInfo, <br>                              wchar_t * szCookie) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteOpenMsgDownloadPipeW (wchar_t *          szMailbox, <br>                                 unsigned long *    pPipeNumber) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteOpenHeaderDownloadPipeW (wchar_t *   szMailbox, <br>                                    long *      pPipeNumber) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteCheckNewMailW (wchar_t *         szMailbox, <br>                          unsigned long *   pulPending) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteOpenOneMsgDownloadPipeW (wchar_t *   szMailbox, <br>                                    long *      pPipeNumber) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteGetRecipientPropsW (unsigned long    dwObjID, <br>                               unsigned long *  pdwObjType, <br>                               wchar_t *        szMailboxName, <br>                               wchar_t *        szFullName, <br>                               wchar_t *        szJobTitle, <br>                               wchar_t *        szOffice, <br>                               wchar_t *        szPhone, <br>                               wchar_t *        szAltPhone, <br>                               wchar_t *        szFax, <br>                               wchar_t *        szComments, <br>                               wchar_t *        szCompany, <br>                               wchar_t *        szDepartment, <br>                               wchar_t *        szManagerName, <br>                               wchar_t *        szManagerAlias, <br>                               unsigned long *  pdwManagerID) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br>long RemoteGetDistListPropsW (unsigned long     dwObjID, <br>                              wchar_t *         szDLAlias, <br>                              wchar_t *         szDLFullName, <br>                              unsigned long *   pdwContentCount, <br>                              wchar_t *         szOwnerAlias, <br>                              wchar_t *         szOwnerName, <br>                              wchar_t *         szComments) <br>{ return HRESULT_FROM_WIN32(E_NOTIMPL); } <br> <br>// End of file for RABRPC.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
