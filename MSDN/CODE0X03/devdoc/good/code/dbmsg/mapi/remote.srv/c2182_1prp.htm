<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RXPRPC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2185"></a>RXPRPC.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      RXPRPC.CPP <br>// <br>//  Description <br>//      This file implements all the remote functions available to client <br>//      WINDS message transport providers. <br>//       <br>//  Authors <br>//      Irving De la Cruz <br>//      Les Thaler <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "_WINDS.H" <br>#include &lt;RPC.H&gt; <br>#include "WINDS.H"     // Header file generated by the MIDL compiler <br>#include "WDSADM.H"    // Header file generated by the MIDL compiler <br> <br>typedef struct tagTHREAD_PROC_INFO <br>{ <br>    HANDLE          hPipe; <br>    HANDLE          hTmpFile; <br>    TCHAR           szTmpFile[MAX_PATH]; <br>    TCHAR           szMailbox[MAX_ALIAS_SIZE+1]; <br>} THREAD_PROC_INFO, *PTHREAD_PROC_INFO; <br> <br>typedef struct tagDL_DELIVERY_PROC_INFO <br>{ <br>    TCHAR               szTmpFile[MAX_PATH]; <br>    TCHAR               szHeader[1024]; <br>    DIST_LIST_INFO      DLInfo; <br>    DWORD               dwAliasDelivered; <br>    LPTSTR *            ppszAliasList; <br>    HANDLE              hWaitEvent; <br>    HANDLE              hFile; <br>    BOOL                fDeleteInfoStruct; <br>} DL_DELIVERY_PROC_INFO, *PDL_DELIVERY_PROC_INFO; <br> <br>extern "C" <br>{ <br>    HRESULT WINAPI MsgUploadPipeThread <br>                        (PTHREAD_PROC_INFO          pInfo); <br>    HRESULT WINAPI MsgDownloadThread <br>                        (PTHREAD_PROC_INFO          pInfo); <br>    HRESULT WINAPI OneMsgDownloadPipeThread <br>                        (PTHREAD_PROC_INFO          pInfo); <br>    HRESULT WINAPI HeaderDLPipeThread <br>                        (PTHREAD_PROC_INFO          pInfo); <br>    DWORD WINAPI DistListDeliveryThread <br>                        (PDL_DELIVERY_PROC_INFO     pDLInfo); <br>    BOOL WINAPI DeleteMessage <br>                        (HANDLE                     hResumeEvt, <br>                         LPTSTR                     szMBox, <br>                         LPBYTE                     pEID); <br>    HANDLE WINAPI OpenMessage <br>                        (HANDLE                     hResumeEvt, <br>                         LPTSTR                     pszMailBox, <br>                         LPBYTE                     pEID, <br>                         ULONG                      ulCmd, <br>                         ULONG *                    pulMsgLen); <br>    HRESULT WINAPI ObjectDelivered <br>                        (PDL_DELIVERY_PROC_INFO     pInfo, <br>                         LPTSTR                     szObject); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteOpenMsgUploadPipeA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteOpenMsgUploadPipeA (unsigned char *   szSenderMailbox, <br>                               long *            pPipeNumber, <br>                               unsigned char *   szCookie) <br>{ <br>    LPTSTR pStrTok; <br>    TCHAR szBuffer[_MAX_PATH]; <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    DWORD dwMailboxID; <br>    if (S_OK != GlobalObjectMap.FindObjFromName (SERVER_USER_MAILBOX, (LPSTR)szSenderMailbox, &amp;dwMailboxID)) <br>    { <br>        TraceMessage ("RemoteOpenUploadPipeA: The originator no longer has an account in this server"); <br>        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER); <br>    } <br> <br>    PTHREAD_PROC_INFO pInfo = (PTHREAD_PROC_INFO)HeapAlloc (ghHeap, <br>                                                            HEAP_ZERO_MEMORY, <br>                                                            sizeof(THREAD_PROC_INFO)); <br>    if (NULL == pInfo) <br>    { <br>        TraceMessage ("RemoteOpenMsgUploadPipeA: Failed to allocate info structure"); <br>        return E_OUTOFMEMORY; <br>    } <br>     <br>    lResult = GetLocalTempFileName (szBuffer); <br>    if (lResult) <br>    { <br>        goto TerminateAndCleanup; <br>    } <br>    lstrcpy (pInfo-&gt;szTmpFile, szBuffer); <br>    pInfo-&gt;hTmpFile = CreateFile (szBuffer, <br>                                  GENERIC_WRITE, <br>                                  FILE_SHARE_READ, <br>                                  NULL, <br>                                  CREATE_ALWAYS, <br>                                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, <br>                                  NULL); <br>    if (INVALID_HANDLE_VALUE == pInfo-&gt;hTmpFile) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenMsgUploadPipeA: Failed to create the temp file", lResult); <br>        goto TerminateAndCleanup; <br>    } <br> <br>    pStrTok = &amp;szBuffer[lstrlen(szBuffer)]; <br>    while ('\\' != *pStrTok) <br>    { <br>        pStrTok--; <br>    } <br>    pStrTok++; <br>    lstrcpy ((LPSTR)szCookie, pStrTok); <br>     <br>    *pPipeNumber = GetNextPipeID(); <br> <br>    SECURITY_ATTRIBUTES sa; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    // Initialize the new security descriptor. <br>    InitializeSecurityDescriptor (&amp;sd, SECURITY_DESCRIPTOR_REVISION); <br> <br>    // Add a NULL descriptor ACL to the security descriptor. <br>    SetSecurityDescriptorDacl (&amp;sd, TRUE, (PACL)NULL, FALSE); <br> <br>    sa.nLength = sizeof(SECURITY_ATTRIBUTES); <br>    sa.lpSecurityDescriptor = &amp;sd; <br>    sa.bInheritHandle = TRUE; <br> <br>    // Create a pipe where we will expect the transport to send the data <br>    wsprintf (szBuffer, SERVER_PIPE_NAME_FORMAT, *pPipeNumber); <br>    pInfo-&gt;hPipe = CreateNamedPipe (szBuffer, <br>                                    PIPE_ACCESS_INBOUND, <br>                                    PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE, <br>                                    1, <br>                                    IO_BUFFERSIZE, <br>                                    IO_BUFFERSIZE, <br>                                    0, <br>                                    &amp;sa); <br>    if (INVALID_HANDLE_VALUE == pInfo-&gt;hPipe || ERROR_INVALID_PARAMETER == (DWORD)pInfo-&gt;hPipe) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenMsgUploadPipeA: Failed to create pipe", lResult); <br>    } <br>    else <br>    { <br>        DWORD dwThreadID; <br>        HANDLE hThread = CreateThread (NULL, <br>                                       0, <br>                                       (LPTHREAD_START_ROUTINE)MsgUploadPipeThread, <br>                                       (LPVOID)pInfo, <br>                                       0, <br>                                       &amp;dwThreadID); <br>        if (hThread) <br>        { <br>            TraceDebugger ("RemoteOpenMsgUploadPipeA: Message Upload thread spawned. ID: %X", dwThreadID); <br>            CloseHandle (hThread); <br>            pInfo = NULL; // The thread will free this memory <br>        } <br>        else <br>        { <br>            lResult = HRESULT_FROM_WIN32(GetLastError()); <br>            TraceResult ("RemoteOpenMsgUploadPipeA: Failed to create pipe thread", lResult); <br>        } <br>    } <br>TerminateAndCleanup : <br>    if (pInfo) <br>    { <br>        if (pInfo-&gt;hTmpFile &amp;&amp; (ERROR_INVALID_HANDLE != (DWORD)pInfo-&gt;hTmpFile)) <br>        { <br>            CloseHandle (pInfo-&gt;hTmpFile); <br>        } <br>        if (pInfo-&gt;hPipe) <br>        { <br>            CloseHandle (pInfo-&gt;hPipe); <br>        } <br>        HeapFree (ghHeap, 0, pInfo); <br>    } <br>    if (lResult) <br>    { <br>        if (FACILITY_NULL == HRESULT_FACILITY(lResult)) <br>        { <br>            lResult = HRESULT_FROM_WIN32 (lResult); <br>        } <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteSendMsgToAccountA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteSendMsgToAccountA (unsigned char * szRecipAccount, <br>                              unsigned char * szHeaderInfo, <br>                              unsigned char * szCookie) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    DWORD dwMailboxID; <br>    WINDS_AB_OBJTYPE Type; <br>    if (S_OK != GlobalObjectMap.FindObjAndTypeFromName ((LPSTR)szRecipAccount, &amp;Type, &amp;dwMailboxID)) <br>    { <br>        TraceMessage ("RemoteSendMsgToAccountA: Rejecting message for an non-existing recipient"); <br>        return HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME); <br>    } <br>     <br>    TCHAR szTmpPath[_MAX_PATH]; <br>    if (!GetTempPath (_MAX_PATH, szTmpPath)) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteSendMsgToAccountA: Failed to get temp path", lResult); <br>        return HRESULT_FROM_WIN32 (lResult); <br>    } <br> <br>    lstrcat (szTmpPath, (LPSTR)szCookie); <br>    PTHREAD_PROC_INFO pInfo = NULL; <br>    PDL_DELIVERY_PROC_INFO pDLInfo = NULL; <br>    HANDLE hFile = NULL, hWaitEvent; <br>RetryOpenFile: <br>    hFile = CreateFile (szTmpPath, <br>                        GENERIC_READ, <br>                        FILE_SHARE_READ, <br>                        NULL, <br>                        OPEN_ALWAYS, <br>                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, <br>                        NULL); <br>    if (INVALID_HANDLE_VALUE == hFile) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        if (HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == lResult) <br>        { <br>            lResult = S_OK; <br>            TraceMessage ("RemoteSendMsgToAccountA: Sharing Violation, waiting before retry"); <br>            SleepEx (200, FALSE); <br>            goto RetryOpenFile; <br>        } <br>        TraceResult ("RemoteSendMsgToAccountA: Failed to open the temp file", lResult); <br>        return lResult; <br>    } <br>    hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteSendMsgToAccountA: Failed to create event for I/O thread", lResult); <br>        goto ErrorExit; <br>    } <br>    if (SERVER_USER_MAILBOX == Type) <br>    { <br>        EnterCriticalSection (&amp;g_csIOInfo); <br>        SetEvent (g_IOInfo.hResumeEvent); <br>        lstrcpy (g_IOInfo.szObject, (LPSTR)szRecipAccount); <br>        lstrcpy (g_IOInfo.szHeader, (LPSTR)szHeaderInfo); <br>        g_IOInfo.Action           = IO_COPY_MSG_FROM_FILE; <br>        g_IOInfo.hActionCompleted = hWaitEvent; <br>        g_IOInfo.hTmpFile         = hFile; <br>        g_IOInfo.fCloseHandle     = TRUE; <br>        hFile = NULL; <br>        g_IOInfo.phLastError      = &amp;lResult; <br>        LeaveCriticalSection (&amp;g_csIOInfo); <br>        WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    } <br>    else <br>    { <br>        if (SERVER_DISTRIBUTION_LIST == Type) <br>        { <br>            pDLInfo = (PDL_DELIVERY_PROC_INFO)HeapAlloc (ghHeap, <br>                                                         HEAP_ZERO_MEMORY, <br>                                                         sizeof(DL_DELIVERY_PROC_INFO)); <br>            if (NULL == pDLInfo) <br>            { <br>                TraceMessage ("RemoteSendMsgToAccountA: Failed to allocate info structure"); <br>                lResult = E_OUTOFMEMORY; <br>                goto ErrorExit; <br>            } <br>            pDLInfo-&gt;fDeleteInfoStruct = TRUE; <br>            lstrcpy (pDLInfo-&gt;DLInfo.szDLAlias, (LPSTR)szRecipAccount); <br>            lstrcpy (pDLInfo-&gt;szHeader, (LPSTR)szHeaderInfo); <br>            GetLocalTempFileName (pDLInfo-&gt;szTmpFile); <br>            if (FALSE == CopyFile (szTmpPath, pDLInfo-&gt;szTmpFile, FALSE)) <br>            { <br>                lResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("RemoteSendMsgToAccountA: Failed to create duplicate tmp file for DL delivery", lResult); <br>                goto ErrorExit; <br>            } <br> <br>            EnterCriticalSection (&amp;g_csIOInfo); <br>            SetEvent (g_IOInfo.hResumeEvent); <br>            g_IOInfo.Action           = IO_GET_DL_PROPERTIES; <br>            g_IOInfo.hActionCompleted = hWaitEvent; <br>            g_IOInfo.phLastError      = &amp;lResult; <br>            g_IOInfo.pDLInfo          = &amp;(pDLInfo-&gt;DLInfo); <br>            LeaveCriticalSection (&amp;g_csIOInfo); <br>            WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>            if (lResult) <br>            { <br>                goto ErrorExit; <br>            } <br>            DWORD dwThreadID; <br>            HANDLE hThread = CreateThread (NULL, <br>                                           0, <br>                                           (LPTHREAD_START_ROUTINE)DistListDeliveryThread, <br>                                           (LPVOID)pDLInfo, <br>                                           CREATE_SUSPENDED, <br>                                           &amp;dwThreadID); <br>            if (hThread) <br>            { <br>                TraceDebugger ("RemoteSendMsgToAccountA: Server DL delivery thread spawned. ID: %X", dwThreadID); <br>                SetThreadPriority (hThread, THREAD_PRIORITY_BELOW_NORMAL); <br> <br>                ResumeThread (hThread); <br>                CloseHandle (hThread); <br>                pDLInfo = NULL; // The thread will free this memory <br>            } <br>            else <br>            { <br>                lResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("RemoteSendMsgToAccountA: Failed to create Server DL delivery thread", lResult); <br>            } <br>        } <br>        else <br>        { <br>            TraceMessage ("RemoteSendMsgToAccountA: This type has not been implemented yet"); <br>            lResult = HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME); <br>        } <br>    } <br>ErrorExit: <br>    if (lResult) <br>    { <br>        if (pDLInfo) <br>        { <br>            DeleteFile (pDLInfo-&gt;szTmpFile); <br>            HeapFree (ghHeap, 0, pDLInfo); <br>        } <br>        if (pInfo) <br>        { <br>            DeleteFile (pInfo-&gt;szTmpFile); <br>            HeapFree (ghHeap, 0, pInfo); <br>        } <br>    } <br>    if (hFile) <br>    { <br>        CloseHandle (hFile); <br>    } <br>    if (hWaitEvent) <br>    { <br>        CloseHandle (hWaitEvent); <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteFinishUpload() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteFinishUpload (unsigned char * szCookie) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    TCHAR szTmpPath[_MAX_PATH]; <br>    if (!GetTempPath (_MAX_PATH, szTmpPath)) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteFinishUpload: Failed to get temp path", lResult); <br>        lResult = lResult; <br>    } <br>    else <br>    { <br>        lstrcat (szTmpPath, (LPSTR)szCookie); <br>        DeleteFile (szTmpPath); <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteOpenHeaderDownloadPipeA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteOpenHeaderDownloadPipeA (unsigned char * szMailbox, long * pPipeNumber) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    DWORD dwMailboxID; <br>    if (S_OK != GlobalObjectMap.FindObjFromName (SERVER_USER_MAILBOX, (LPSTR)szMailbox, &amp;dwMailboxID)) <br>    { <br>        TraceMessage ("RemoteOpenHeaderDownloadPipeA: Invalid user mailbox"); <br>        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER); <br>    } <br>     <br>    *pPipeNumber = GetNextPipeID(); <br> <br>    TCHAR szBuffer[_MAX_PATH]; <br>    lResult = GetLocalTempFileName (szBuffer); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    HANDLE hFile = CreateFile (szBuffer, <br>                               GENERIC_READ | GENERIC_WRITE, <br>                               FILE_SHARE_READ, <br>                               NULL, <br>                               OPEN_ALWAYS, <br>                               FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, <br>                               NULL); <br>    if (INVALID_HANDLE_VALUE == hFile) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenHeaderDownloadPipeA: Failed to temp file", lResult); <br>        return lResult; <br>    } <br> <br>    SECURITY_ATTRIBUTES sa; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    // Initialize the new security descriptor. <br>    InitializeSecurityDescriptor (&amp;sd, SECURITY_DESCRIPTOR_REVISION); <br> <br>    // Add a NULL descriptor ACL to the security descriptor. <br>    SetSecurityDescriptorDacl (&amp;sd, TRUE, (PACL)NULL, FALSE); <br> <br>    sa.nLength = sizeof(SECURITY_ATTRIBUTES); <br>    sa.lpSecurityDescriptor = &amp;sd; <br>    sa.bInheritHandle = TRUE; <br>     <br>    wsprintf (szBuffer, SERVER_PIPE_NAME_FORMAT, *pPipeNumber); <br>    HANDLE hPipe = CreateNamedPipe (szBuffer, <br>                                    PIPE_ACCESS_OUTBOUND, <br>                                    PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE, <br>                                    1, <br>                                    IO_BUFFERSIZE, <br>                                    IO_BUFFERSIZE, <br>                                    0, <br>                                    &amp;sa); <br>    if (INVALID_HANDLE_VALUE == hPipe || ERROR_INVALID_PARAMETER == (DWORD)hPipe) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenHeaderDownloadPipeA: Failed to create pipe", lResult); <br>    } <br>    else <br>    { <br>        PTHREAD_PROC_INFO pInfo = (PTHREAD_PROC_INFO)HeapAlloc (ghHeap, <br>                                                                HEAP_ZERO_MEMORY, <br>                                                                sizeof(THREAD_PROC_INFO)); <br>        if (pInfo) <br>        { <br>            lstrcpy (pInfo-&gt;szMailbox, (LPSTR)szMailbox); <br>            pInfo-&gt;hPipe = hPipe; <br>            pInfo-&gt;hTmpFile = hFile; <br>            DWORD dwThreadID; <br>            HANDLE hThread = CreateThread (NULL, <br>                                           0, <br>                                           (LPTHREAD_START_ROUTINE)HeaderDLPipeThread, <br>                                           (LPVOID)pInfo, <br>                                           0, <br>                                           &amp;dwThreadID); <br>            if (hThread) <br>            { <br>                TraceDebugger ("RemoteOpenHeaderDownloadPipeA: Header download thread spawned. ID: %X", dwThreadID); <br>                CloseHandle (hThread); <br>            } <br>            else <br>            { <br>                lResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("RemoteOpenHeaderDownloadPipeA: Failed to create pipe thread", lResult); <br>            } <br>        } <br>        else <br>        { <br>            TraceMessage ("RemoteOpenHeaderDownloadPipeA: Failed to allocate info structure"); <br>            lResult = E_OUTOFMEMORY; <br>        } <br>    } <br>    if (lResult) <br>    { <br>        CloseHandle (hPipe); <br>        CloseHandle (hFile); <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteOpenMsgDownloadPipeA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteOpenMsgDownloadPipeA (unsigned char *     szMailbox, <br>                                 unsigned long *     pPipeNumber) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    DWORD dwMailboxID; <br>    if (S_OK != GlobalObjectMap.FindObjFromName (SERVER_USER_MAILBOX, (LPSTR)szMailbox, &amp;dwMailboxID)) <br>    { <br>        TraceMessage ("RemoteOpenMsgDownloadPipeA: Invalid user mailbox"); <br>        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER); <br>    } <br>     <br>    PTHREAD_PROC_INFO pInfo = (PTHREAD_PROC_INFO)HeapAlloc (ghHeap, <br>                                                            HEAP_ZERO_MEMORY, <br>                                                            sizeof(THREAD_PROC_INFO)); <br>    if (!pInfo) <br>    { <br>        TraceMessage ("RemoteOpenMsgDownloadPipeA: Failed to allocate info structure"); <br>        return E_OUTOFMEMORY; <br>    } <br>    lstrcpy (pInfo-&gt;szMailbox, (LPSTR)szMailbox); <br> <br>    *pPipeNumber = GetNextPipeID(); <br>     <br>    SECURITY_ATTRIBUTES sa; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    // Initialize the new security descriptor. <br>    InitializeSecurityDescriptor (&amp;sd, SECURITY_DESCRIPTOR_REVISION); <br> <br>    // Add a NULL descriptor ACL to the security descriptor. <br>    SetSecurityDescriptorDacl (&amp;sd, TRUE, (PACL)NULL, FALSE); <br> <br>    sa.nLength = sizeof(SECURITY_ATTRIBUTES); <br>    sa.lpSecurityDescriptor = &amp;sd; <br>    sa.bInheritHandle = TRUE; <br> <br>    TCHAR szPipeName[64]; <br>    wsprintf (szPipeName, SERVER_PIPE_NAME_FORMAT, *pPipeNumber); <br>    pInfo-&gt;hPipe = CreateNamedPipe (szPipeName, <br>                                    PIPE_ACCESS_DUPLEX, <br>                                    PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE, <br>                                    1, <br>                                    IO_BUFFERSIZE, <br>                                    IO_BUFFERSIZE, <br>                                    0, <br>                                    &amp;sa); <br>    if (INVALID_HANDLE_VALUE == pInfo-&gt;hPipe || ERROR_INVALID_PARAMETER == (DWORD)pInfo-&gt;hPipe) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenMsgDownloadPipeA: Failed to create pipe", lResult); <br>    } <br>    else <br>    { <br>        DWORD dwThreadID; <br>        HANDLE hThread = CreateThread (NULL, <br>                                       0, <br>                                       (LPTHREAD_START_ROUTINE)MsgDownloadThread, <br>                                       (LPVOID)pInfo, <br>                                       0, <br>                                       &amp;dwThreadID); <br>        if (hThread) <br>        { <br>            TraceDebugger ("RemoteOpenMsgDownloadPipeA: Header download thread spawned. ID: %X", dwThreadID); <br>            CloseHandle (hThread); <br>        } <br>        else <br>        { <br>            lResult = HRESULT_FROM_WIN32(GetLastError()); <br>            TraceResult ("RemoteOpenMsgDownloadPipeA: Failed create doanload thread", lResult); <br>        } <br>    } <br> <br>    if (lResult) <br>    { <br>        if (FACILITY_NULL == HRESULT_FACILITY(lResult)) <br>        { <br>            lResult = HRESULT_FROM_WIN32 (lResult); <br>        } <br>        HeapFree (ghHeap, 0, pInfo); <br>    } <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MsgUploadPipeThread() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI MsgUploadPipeThread (PTHREAD_PROC_INFO pInfo) <br>{ <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    DWORD dwBytesWrite, dwBytesRead = 0; <br>     <br>    ConnectNamedPipe (pInfo-&gt;hPipe, NULL); <br>    HRESULT hResult = S_OK; <br>    do <br>    { <br>        // Wait until the client writes to the pipe <br>        if (!ReadFile (pInfo-&gt;hPipe, abBuffer, IO_BUFFERSIZE, &amp;dwBytesRead, NULL)) <br>        { <br>            // There was an error and we can't continue <br>            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>            if (hResult != HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE)) <br>            { <br>                TraceResult ("MsgUploadPipeThread: Failed to read from the msg upload pipe", hResult); <br>            } <br>            else <br>            { <br>                hResult = 0; <br>            } <br>        } <br>        if (dwBytesRead &amp;&amp; !hResult) <br>        { <br>            if (!WriteFile (pInfo-&gt;hTmpFile, abBuffer, dwBytesRead, &amp;dwBytesWrite, NULL)) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("MsgUploadPipeThread: Failed to write to the local tmp file", hResult); <br>            } <br>        } <br>    } while (dwBytesRead &amp;&amp; !hResult); <br> <br>    TraceResult ("MsgUploadPipeThread", hResult); <br>    CloseHandle (pInfo-&gt;hTmpFile); <br>    CloseHandle (pInfo-&gt;hPipe); <br>    if (hResult) <br>    { <br>        DeleteFile (pInfo-&gt;szTmpFile); <br>    } <br>    HeapFree (ghHeap, 0, pInfo); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    HeaderDLPipeThread() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI HeaderDLPipeThread (PTHREAD_PROC_INFO pInfo) <br>{ <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    DWORD dwBytesRead, dwBytesWrite; <br>    HRESULT hResult; <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("HeaderDLPipeThread: Failed to create event for I/O thread", hResult); <br>        goto Error; <br>    } <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    lstrcpy (g_IOInfo.szObject, pInfo-&gt;szMailbox); <br>    g_IOInfo.Action           = IO_COPY_HEADERS_TO_FILE; <br>    g_IOInfo.hTmpFile         = pInfo-&gt;hTmpFile; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;hResult; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>    if (hResult) <br>    { <br>        goto Error; <br>    } <br> <br>    // Wait until the client connects to the pipe <br>    ConnectNamedPipe (pInfo-&gt;hPipe, NULL); <br>     <br>    do <br>    { <br>        if (!ReadFile (pInfo-&gt;hTmpFile, abBuffer, IO_BUFFERSIZE, &amp;dwBytesRead, NULL)) <br>        { <br>            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>            TraceResult ("HeaderDLPipeThread: Failed to read the tmp file", hResult); <br>        } <br>        if (dwBytesRead &amp;&amp; !hResult) <br>        { <br>            if (!WriteFile (pInfo-&gt;hPipe, abBuffer, dwBytesRead, &amp;dwBytesWrite, NULL)) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("HeaderDLPipeThread: Failed to write to the pipe", hResult); <br>            } <br>        } <br>    } while (dwBytesRead &amp;&amp; !hResult); <br> <br>Error: <br>    CloseHandle (pInfo-&gt;hTmpFile); <br>    CloseHandle (pInfo-&gt;hPipe); <br>    HeapFree (ghHeap, 0, pInfo); <br>    return hResult; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////// <br>//    MsgDownloadThread() <br>// <br>//    Parameters <br>//          pInfo       pointer to a THREAD_PROC_INFO containing the handle to <br>//                      the open pipe for data transmission to the remote XP <br>// <br>//    Purpose <br>//          This is the worker thread that is spawned when a request to <br>//          messages arrives from the remote XP via RemoteOpenMsgDownloadPipe. <br>//          Once the pipe has been opened the remote XP sends command messages <br>//          on the pipe to request data from the server. These command messages <br>//          are of 3 types: MSG_MOVE, MSG_DOWNLOAD, and MSG_DELETE. The command <br>//          messages have a msg ID that tells the requested operation. When this <br>//          thread is started, it creates an event object for synchronization <br>//          with the storage thread that accesses the message database then <br>//          immediately blocks waiting for the XP to connect to the pipe. We  <br>//          unblock and start reading command requests. Each mail message we  <br>//          process goes through the following cycle: <br>//           <br>//              1. read the command message, this contains the operation <br>//                 requested by the XP and the mail message's entry ID <br>//               <br>//              2. if the command is to HANG UP, quit, otherwise: <br>// <br>//                 look up the entry ID of the mail message in the storage. <br>//                 if unsuccessful, send a NAK message back to the XP <br>//           <br>//                 if the request is to DELETE, delete the message and if <br>//                 successful send an ACK message back to the XP, otherwise <br>//                 send a NAK message back, then start on the next request <br>// <br>//                 if the request is to MOVE or DOWNLOAD, get the mail message's <br>//                 size, stuff it in an ACK message and write it to the XP.then <br>//                 stream the mail message over the pipe <br>// <br>//              3. read the next command <br>//   <br>//          We treat write errors to the pipe as fatal and disconnect. <br>// <br>//    Return Value <br>//           <br>HRESULT WINAPI MsgDownloadThread(PTHREAD_PROC_INFO pInfo) <br>{ <br>    MSG_HDR     MsgHdr; <br>    HANDLE      hTmpFile; <br>    DWORD       dwBytesRead, dwBytesWritten; <br>    HRESULT hResult = S_OK; <br>    HANDLE      hResumeEvt  = CreateEvent(NULL, FALSE, FALSE, NULL); <br> <br>    if (!hResumeEvt) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("MsgDownloadThread: Failed to create event", hResult); <br>        goto Quit; <br>    } <br> <br>    // block until XP connects to us <br>    ConnectNamedPipe (pInfo-&gt;hPipe, NULL); <br> <br>    while (TRUE) <br>    { <br>        if (!ReadFile(pInfo -&gt; hPipe, &amp;MsgHdr, sizeof(MSG_HDR), &amp;dwBytesRead, NULL)) <br>            break; // Out of the WHILE() loop <br> <br>        ASSERT (dwBytesRead == sizeof(MSG_HDR)); <br> <br>        switch (MsgHdr.ulMID) <br>        { <br>            case MSG_MOVE:  // Fall through <br>            case MSG_DOWNLOAD: <br> <br>                // tell IO thread to open msg's container, write it <br>                // to a temp file and return us its size and handle <br> <br>                hTmpFile = OpenMessage(hResumeEvt,  <br>                                       pInfo-&gt;szMailbox, <br>                                       MsgHdr.Info.EID, <br>                                       MsgHdr.ulMID, <br>                                       &amp;MsgHdr.Info. <br>                                       ulMsgLen); <br>                if (!hTmpFile) <br>                {    <br>                    MsgHdr.ulMID = OP_FAILED;           // send a NAK back to XP <br>                    MsgHdr.Info.ulMsgLen = 0; <br>                    if (!WriteFile(pInfo-&gt;hPipe, &amp;MsgHdr, sizeof(MSG_HDR), &amp;dwBytesWritten, NULL)) <br>                    { <br>                        goto Quit; <br>                    } <br>                } <br>                else </code></pre>
<p>
</p>
<pre><code>{    <br>                    MsgHdr.ulMID = OP_STARTED;         // send an ACK to XP <br>                    // Bail on any write errors, the connection is down                     <br>                    if (!WriteFile(pInfo-&gt;hPipe, &amp;MsgHdr, sizeof(MSG_HDR), &amp;dwBytesWritten, NULL)) <br>                    { <br>                        goto Quit; <br>                    } <br>                     <br>                    // set seek pointer to beginning of temp file <br>                    if ((DWORD)-1 == SetFilePointer(hTmpFile, 0, NULL, FILE_BEGIN)) <br>                        break; <br> <br>                    if (NO_ERROR != FileCopy(pInfo -&gt; hPipe, hTmpFile, MsgHdr.Info.ulMsgLen)) <br>                        goto Quit; <br> <br>                }                     <br>                break;                 <br>                                     <br>            case MSG_DELETE: <br>                // tell storage thread to delete msg's substorage <br>                MsgHdr.ulMID = (DeleteMessage (hResumeEvt, pInfo-&gt;szMailbox, MsgHdr.Info.EID) ? OP_COMPLETE : OP_FAILED); <br>                MsgHdr.Info.ulMsgLen = 0; <br>                 <br>                // send ACK/NAK to XP <br>                if (!WriteFile (pInfo-&gt;hPipe, &amp;MsgHdr, sizeof(MSG_HDR), &amp;dwBytesWritten, NULL)) <br>                { <br>                    goto Quit; <br>                } <br>                break; <br>                         <br>            case GOODBYE:            // HANG UP <br>                goto Quit;         <br>             <br>            default : <br>                // don't attempt to resynchronize <br>                goto Quit;              <br>        }       <br>    } <br> <br>Quit: <br>    CloseHandle (pInfo-&gt;hPipe); <br>    CloseHandle (hResumeEvt); <br>    HeapFree (ghHeap, 0, pInfo); <br>    return hResult; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////// <br>//    DeleteMessage() <br>// <br>//    Parameters <br>//          hResumeEvt          handle to event object for signaling completion <br>//                              of storage operation <br>//          szMailBox           Name of mailbox for the mail msg we're handling <br>//          pEID                entry ID of msg we're handling <br>//    Purpose <br>//          Sends a DELETE request to the storage thread.The request, along  <br>//          with the message's EID, and the mailbox name where the message  <br>//          resides are passed to the storage thread in g_IOInfo. We then block <br>//          on an event from the storage thread signaling completetion of the <br>//          requested operations. The storage finds the mail message and <br>//          deletes it.                     <br>// <br>//    Return Value <br>//          TRUE on success,FALSE otherwise <br>// <br>BOOL WINAPI DeleteMessage(HANDLE hResumeEvt, LPTSTR pszMailBox, LPBYTE pEID) <br>{ <br>    HRESULT hResult = S_OK; <br>    // In Windows NT 3.5 OLE storages can only be accessed by a single thread, so use <br>    // this global data struct to pass data to the storage thread <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent(g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = IO_DELETE_MSG_IN_MAILBOX; <br>    g_IOInfo.hActionCompleted = hResumeEvt;         <br>    g_IOInfo.phLastError      = &amp;hResult; <br>    g_IOInfo.dwObjID          = (DWORD)atol((LPCSTR) &amp;pEID[4]); <br>    lstrcpy (g_IOInfo.szObject, pszMailBox); <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    // Block until the storage thread finishes <br>    WaitForSingleObject(hResumeEvt, GENERAL_TIME_OUT); <br>    return (S_OK == hResult ? TRUE : FALSE); <br>} <br> <br>//////////////////////////////////////////////////////////////////////////// <br>//    OpenMessage() <br>// <br>//    Parameters <br>//          hResumeEvt          handle to event object for signaling completion <br>//                              of storage operation <br>//          pszMailBox          name of mailbox for the mail msg we're handling <br>//          pEID                entry ID of msg we're handling <br>//          ulCmd               operation to perform on the message <br>//          pulMsgLen           to pass back the size of the data stream <br>//    Purpose <br>//          Create a temporary file to hold the mail message, then send <br>//          a request for the operation passed in ulCmd to the storage <br>//          thread.The request, along with the message's EID, the mailbox <br>//          name where the message resides, and the handle to the tempfile <br>//          are passed to the storage thread in g_IOInfo. We then block on <br>//          an event from the storage thread signaling completetion of the <br>//          requested operations. The storage finds the mail message and <br>//          copies it into the tempfile passing back the size in pulMsgLen.                     <br>// <br>//    Return Value <br>//          Handle of temp file on success, NULL otherwise <br>// <br>HANDLE WINAPI OpenMessage(HANDLE   hResumeEvt, <br>                          LPTSTR   pszMailBox, <br>                          LPBYTE   pEID, <br>                          ULONG    ulCmd, <br>                          ULONG *  pulMsgLen) <br>{ <br>    HANDLE      hTempFile = NULL;                     <br>    HRESULT     hResult; <br>    TCHAR       szTempFile[MAX_PATH]; <br>    ACTION      Action; <br>    // creates a unique tempfile name   <br>    if (GetLocalTempFileName (szTempFile)) <br>    { <br>        return NULL; <br>    } <br> <br>    switch (ulCmd) <br>    { <br>        case MSG_DOWNLOAD : <br>            Action = IO_COPY_MSG_TO_FILE; <br>            break; <br> <br>        case MSG_MOVE : <br>            Action = IO_MOVE_MSG_TO_FILE; <br>            break; <br> <br>        default :  <br>            TraceMessage ("OpenMessage: Invalid command received"); <br>            ASSERT (FALSE); <br>            return NULL; <br>    } <br> <br>    // create tempfile to hold message <br>    if (! (hTempFile = CreateFile(szTempFile, <br>                                  GENERIC_READ | GENERIC_WRITE, <br>                                  FILE_SHARE_READ, <br>                                  NULL, <br>                                  CREATE_ALWAYS, <br>                                  FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, <br>                                  NULL))) <br>        return NULL; <br> <br>    // OLE storages can only be accessed by a single thread, so use <br>    // this global data struct to pass data to the storage thread <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    g_IOInfo.Action           = Action;        // requested operation <br>    g_IOInfo.hActionCompleted = hResumeEvt;    // signal us on this event     <br>    g_IOInfo.phLastError      = &amp;hResult; <br>    g_IOInfo.dwObjID          = (DWORD) atol((const char *) &amp;pEID[4]); <br>    g_IOInfo.hTmpFile         = hTempFile;     // storage thread writes msg here <br>    g_IOInfo.pdwData          = pulMsgLen;     // storage thread writes length here <br>    lstrcpy (g_IOInfo.szObject, pszMailBox); <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br> <br>    // block until storage thread finishes <br>    WaitForSingleObject(hResumeEvt, GENERAL_TIME_OUT); <br>    return (hResult ? NULL : hTempFile); <br>} <br> <br>//////////////////////////////////////////////////////////////////////////// <br>//    DistListDeliveryThread() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//      This function is RECURSIVE <br>// <br>//    Return Value <br>//           <br>DWORD WINAPI DistListDeliveryThread (PDL_DELIVERY_PROC_INFO pDLInfo) <br>{ <br>    DLM_LIST_A * pNode, *pSubNode; <br>    DL_DELIVERY_PROC_INFO SubDLInfo = { 0 }; <br>    DWORD j, dwResult = S_OK; <br>    HRESULT hResult; <br>    HANDLE hWaitEvent, hFile; <br>    ObjectDelivered (pDLInfo, pDLInfo-&gt;DLInfo.szDLAlias); <br>    if (NULL == pDLInfo-&gt;hFile) <br>    { <br>        hFile = CreateFile (pDLInfo-&gt;szTmpFile, <br>                            GENERIC_READ, <br>                            0, <br>                            NULL, <br>                            OPEN_ALWAYS, <br>                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, <br>                            NULL); <br>        if (INVALID_HANDLE_VALUE == hFile) <br>        { <br>            dwResult = HRESULT_FROM_WIN32(GetLastError()); <br>            TraceResult ("DistListDeliveryThread: Failed to open the temp file", dwResult); <br>            goto ErrorExit; <br>        } <br>        pDLInfo-&gt;hFile = hFile; <br>    } <br>    else <br>    { <br>        hFile = pDLInfo-&gt;hFile; <br>    } <br>    if (NULL == pDLInfo-&gt;hWaitEvent) <br>    { <br>        hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>        if (!hWaitEvent) <br>        { <br>            TraceResult ("DistListDeliveryThread: Failed to create event for I/O thread", HRESULT_FROM_WIN32(GetLastError())); <br>        } <br>        pDLInfo-&gt;hWaitEvent = hWaitEvent; <br>    } <br>    else <br>    { <br>        hWaitEvent = pDLInfo-&gt;hWaitEvent; <br>    } <br>    // Process the USER mailboxes first <br>    pNode = (DLM_LIST_A *)pDLInfo-&gt;DLInfo.pMembers; <br>    while (pNode) <br>    { <br>        if (SERVER_USER_MAILBOX != (WINDS_AB_OBJTYPE)pNode-&gt;Info.dwMemberType) <br>        { <br>            continue; <br>        } <br>        SetFilePointer (hFile, 0, NULL, FILE_BEGIN); <br>        EnterCriticalSection (&amp;g_csIOInfo); <br>        SetEvent (g_IOInfo.hResumeEvent); <br>        lstrcpy (g_IOInfo.szObject, (LPSTR)pNode-&gt;Info.szMemberAlias); <br>        lstrcpy (g_IOInfo.szHeader, pDLInfo-&gt;szHeader); <br>        g_IOInfo.Action           = IO_COPY_MSG_FROM_FILE; <br>        g_IOInfo.hActionCompleted = hWaitEvent; <br>        g_IOInfo.hTmpFile         = hFile; <br>        g_IOInfo.fCloseHandle     = FALSE; <br>        g_IOInfo.phLastError      = &amp;hResult; <br>        LeaveCriticalSection (&amp;g_csIOInfo); <br>        WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br> <br>        // The message was successfully delivered to the recipient, so add it to the "DELIVERED" list <br>        if (S_OK == hResult) <br>        { <br>            ObjectDelivered (pDLInfo, (LPSTR)pNode-&gt;Info.szMemberAlias); <br>        } <br>        pNode = pNode-&gt;pNext; <br>    } <br>    lstrcpy (SubDLInfo.szHeader, pDLInfo-&gt;szHeader); <br>    SubDLInfo.hFile = hFile; <br>    SubDLInfo.hWaitEvent = hWaitEvent; <br> <br>    // Process the Distribution lists second <br>    pNode = (DLM_LIST_A *)pDLInfo-&gt;DLInfo.pMembers; <br>    while (pNode) <br>    { <br>        if (SERVER_DISTRIBUTION_LIST != (WINDS_AB_OBJTYPE)pNode-&gt;Info.dwMemberType) <br>        { <br>            continue; <br>        } <br>        for (j=0; j&lt;pDLInfo-&gt;dwAliasDelivered; j++) <br>        { <br>            // If the message has already been delivered to this sub DL, skip it <br>            if (0 == lstrcmp ((LPSTR)pNode-&gt;Info.szMemberAlias, pDLInfo-&gt;ppszAliasList[j])) <br>            { <br>                continue; <br>            } <br>        } <br> <br>        lstrcpy (SubDLInfo.DLInfo.szDLAlias, (LPSTR)pNode-&gt;Info.szMemberAlias); <br>        SubDLInfo.fDeleteInfoStruct = FALSE; <br>        SubDLInfo.DLInfo.pMembers = NULL; <br>        SubDLInfo.dwAliasDelivered = pDLInfo-&gt;dwAliasDelivered; <br>        SubDLInfo.ppszAliasList = pDLInfo-&gt;ppszAliasList; <br> <br>        EnterCriticalSection (&amp;g_csIOInfo); <br>        SetEvent (g_IOInfo.hResumeEvent); <br>        g_IOInfo.Action           = IO_GET_DL_PROPERTIES; <br>        g_IOInfo.hActionCompleted = hWaitEvent; <br>        g_IOInfo.phLastError      = &amp;hResult; <br>        g_IOInfo.pDLInfo          = &amp;(SubDLInfo.DLInfo); <br>        LeaveCriticalSection (&amp;g_csIOInfo); <br>        WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>        if (hResult) <br>        { <br>            TraceResult ("DistListDeliveryThread: Could not get DL properties", hResult); <br>            continue; <br>        } <br> <br>        pSubNode = (DLM_LIST_A *)SubDLInfo.DLInfo.pMembers; <br>        while (pSubNode) <br>        { <br>            for (j=0; j&lt;pDLInfo-&gt;dwAliasDelivered; j++) <br>            { <br>                // If the message has already been delivered to a member of the Sub DL <br>                // mark the entry in the sub DL so that it won't deliver to that recipient. <br>                if (0 == lstrcmp ((LPSTR)pSubNode-&gt;Info.szMemberAlias, pDLInfo-&gt;ppszAliasList[j])) <br>                { <br>                    pSubNode-&gt;Info.dwMemberType = (DWORD)UNDEFINED_OBJECT_TYPE; <br>                } <br>            } <br>            pSubNode = pSubNode-&gt;pNext; <br>        } <br>        // Deliver to the members of the sub-distribution list         <br>        hResult = DistListDeliveryThread (&amp;SubDLInfo); <br>        // Remember how many recipients were handled in this sub DL <br>        pDLInfo-&gt;dwAliasDelivered = SubDLInfo.dwAliasDelivered; <br>        pDLInfo-&gt;ppszAliasList = SubDLInfo.ppszAliasList; <br>        if (SubDLInfo.DLInfo.pMembers) <br>        { <br>            HeapFree (ghHeap, 0, SubDLInfo.DLInfo.pMembers); <br>        } <br>        pNode = pNode-&gt;pNext; <br>    } <br> <br>ErrorExit: <br>    if (pDLInfo-&gt;fDeleteInfoStruct) <br>    { <br>        CloseHandle (pDLInfo-&gt;hWaitEvent); <br>        CloseHandle (pDLInfo-&gt;hFile); <br>        DeleteFile (pDLInfo-&gt;szTmpFile); <br>        if (pDLInfo-&gt;DLInfo.pMembers) <br>        { <br>            HeapFree (ghHeap, 0, pDLInfo-&gt;DLInfo.pMembers); <br>        } <br>        if (pDLInfo-&gt;ppszAliasList) <br>        { <br>            for (j=0; j&lt;pDLInfo-&gt;dwAliasDelivered; j++) <br>            { <br>                HeapFree (ghHeap, 0, pDLInfo-&gt;ppszAliasList[j]); <br>            } <br>            HeapFree (ghHeap, 0, pDLInfo-&gt;ppszAliasList); <br>        } <br>        HeapFree (ghHeap, 0, pDLInfo); <br>    } <br>    return dwResult; <br>} <br> <br>//////////////////////////////////////////////////////////////////////////// <br>//    ObjectDelivered() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//           <br>HRESULT WINAPI ObjectDelivered (PDL_DELIVERY_PROC_INFO pDLInfo, LPTSTR szObject) <br>{ <br>    DWORD dwIndex = pDLInfo-&gt;dwAliasDelivered; <br>    if (NULL == pDLInfo-&gt;ppszAliasList) <br>    { <br>        ASSERT (0 == pDLInfo-&gt;dwAliasDelivered); <br>        pDLInfo-&gt;ppszAliasList = (LPTSTR *)HeapAlloc (ghHeap, 0, sizeof(LPTSTR)); <br>        if (NULL == pDLInfo-&gt;ppszAliasList) <br>        { <br>            TraceMessage ("ObjectDelivered: Failed to allocate Delivered Alias List"); <br>            return E_OUTOFMEMORY; <br>        } <br>    } <br>    else <br>    { <br>        pDLInfo-&gt;ppszAliasList = (LPTSTR *)HeapReAlloc (ghHeap, <br>                                                        0, <br>                                                        pDLInfo-&gt;ppszAliasList, <br>                                                        sizeof(LPTSTR) * (pDLInfo-&gt;dwAliasDelivered + 1)); <br>        if (NULL == pDLInfo-&gt;ppszAliasList[dwIndex]) <br>        { <br>            TraceMessage ("ObjectDelivered: Failed to re-allocate Delivered Alias List"); <br>            return E_OUTOFMEMORY; <br>        } <br>    } <br>     <br>    pDLInfo-&gt;ppszAliasList[dwIndex] = (LPTSTR)HeapAlloc (ghHeap, 0, (sizeof (TCHAR)*(lstrlen(szObject)+1))); <br>    if (NULL == pDLInfo-&gt;ppszAliasList[dwIndex]) <br>    { <br>        TraceMessage ("ObjectDelivered: Failed to allocate object alias string"); <br>        return E_OUTOFMEMORY; <br>    } <br>    lstrcpy (pDLInfo-&gt;ppszAliasList[dwIndex], szObject); <br>    pDLInfo-&gt;dwAliasDelivered++; <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteCheckNewMailA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteCheckNewMailA (unsigned char * szMailbox, unsigned long * pulPending) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    HANDLE hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteCheckNewMailA: Failed to create event for I/O thread", lResult); <br>        return lResult; <br>    } <br>    *pulPending = 0; <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    lstrcpy (g_IOInfo.szObject, (LPSTR)szMailbox); <br>    g_IOInfo.Action           = IO_CHECK_PENDING_MESSAGES; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    g_IOInfo.pdwData          = pulPending; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    CloseHandle (hWaitEvent); <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    RemoteOpenOneMsgDownloadPipeA() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>long RemoteOpenOneMsgDownloadPipeA (unsigned char *    szMailbox, <br>                                    long *             pPipeNumber) <br>{ <br>    long lResult = GetServiceState(); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br>    TCHAR szTmpFile[_MAX_PATH], szPipeName[64]; <br>    lResult = GetLocalTempFileName (szTmpFile); <br>    if (lResult) <br>    { <br>        return lResult; <br>    } <br> <br>    PTHREAD_PROC_INFO pInfo = (PTHREAD_PROC_INFO)HeapAlloc (ghHeap, <br>                                                            HEAP_ZERO_MEMORY, <br>                                                            sizeof(THREAD_PROC_INFO)); <br>    if (NULL == pInfo) <br>    { <br>        TraceMessage ("RemoteOpenOneMsgDownloadPipeA: Failed to allocate info structure"); <br>        return E_OUTOFMEMORY; <br>    } <br>    DWORD dwThreadID, dwMsgID; <br>    HANDLE hThread, hWaitEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br>    if (!hWaitEvent) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenOneMsgDownloadPipeA: Failed to create event for I/O thread", lResult); <br>        goto ErrorExit; <br>    } <br>     <br>    pInfo-&gt;hTmpFile = CreateFile (szTmpFile, <br>                                  GENERIC_WRITE | GENERIC_READ, <br>                                  0, <br>                                  NULL, <br>                                  CREATE_ALWAYS, <br>                                  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_DELETE_ON_CLOSE, <br>                                  NULL); <br>    if (INVALID_HANDLE_VALUE == pInfo-&gt;hTmpFile) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenOneMsgDownloadPipeA: Failed to create the temp file", lResult); <br>        goto ErrorExit; <br>    } <br>     <br>    *pPipeNumber = GetNextPipeID(); <br>     <br>    SECURITY_ATTRIBUTES sa; <br>    SECURITY_DESCRIPTOR sd; <br> <br>    // Initialize the new security descriptor. <br>    InitializeSecurityDescriptor (&amp;sd, SECURITY_DESCRIPTOR_REVISION); <br> <br>    // Add a NULL descriptor ACL to the security descriptor. <br>    SetSecurityDescriptorDacl (&amp;sd, TRUE, (PACL)NULL, FALSE); <br> <br>    sa.nLength = sizeof(SECURITY_ATTRIBUTES); <br>    sa.lpSecurityDescriptor = &amp;sd; <br>    sa.bInheritHandle = TRUE; <br> <br>    wsprintf (szPipeName, SERVER_PIPE_NAME_FORMAT, *pPipeNumber); <br>    pInfo-&gt;hPipe = CreateNamedPipe (szPipeName, <br>                                    PIPE_ACCESS_OUTBOUND, <br>                                    PIPE_WAIT | PIPE_READMODE_BYTE | PIPE_TYPE_BYTE, <br>                                    1, <br>                                    IO_BUFFERSIZE, <br>                                    IO_BUFFERSIZE, <br>                                    0, <br>                                    &amp;sa); <br>    if (INVALID_HANDLE_VALUE == pInfo-&gt;hPipe || ERROR_INVALID_PARAMETER == (DWORD)pInfo-&gt;hPipe) <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenMsgDownloadPipeA: Failed to create pipe", lResult); <br>        goto ErrorExit; <br>    } <br> <br>    EnterCriticalSection (&amp;g_csIOInfo); <br>    SetEvent (g_IOInfo.hResumeEvent); <br>    lstrcpy (g_IOInfo.szObject, (LPSTR)szMailbox); <br>    g_IOInfo.Action           = IO_MOVE_NEXT_MSG_TO_FILE; <br>    g_IOInfo.hActionCompleted = hWaitEvent; <br>    g_IOInfo.hTmpFile         = pInfo-&gt;hTmpFile; <br>    g_IOInfo.pdwData          = &amp;dwMsgID; <br>    g_IOInfo.phLastError      = &amp;lResult; <br>    LeaveCriticalSection (&amp;g_csIOInfo); <br>    WaitForSingleObject (hWaitEvent, GENERAL_TIME_OUT); <br>    if (lResult) <br>    { <br>        goto ErrorExit; <br>    } <br> <br>    hThread = CreateThread (NULL, <br>                            0, <br>                            (LPTHREAD_START_ROUTINE)OneMsgDownloadPipeThread, <br>                            (LPVOID)pInfo, <br>                            0, <br>                            &amp;dwThreadID); <br>    if (hThread) <br>    { <br>        TraceDebugger ("RemoteOpenOneMsgDownloadPipeA: Message Download thread spawned. ID: %X", dwThreadID); <br>        CloseHandle (hThread); <br>        pInfo = NULL; // The thread will free this memory <br>        EnterCriticalSection (&amp;g_csIOInfo); <br>        SetEvent (g_IOInfo.hResumeEvent); <br>        lstrcpy (g_IOInfo.szObject, (LPSTR)szMailbox); <br>        g_IOInfo.Action           = IO_DELETE_MSG_IN_MAILBOX; <br>        g_IOInfo.hActionCompleted = NULL; <br>        g_IOInfo.dwObjID          = dwMsgID; <br>        g_IOInfo.phLastError      = NULL; <br>        LeaveCriticalSection (&amp;g_csIOInfo); <br>    } <br>    else <br>    { <br>        lResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("RemoteOpenOneMsgDownloadPipeA: Failed to create pipe thread", lResult); <br>    } <br>     <br>ErrorExit: <br>    if (pInfo) <br>    { <br>        if (pInfo-&gt;hTmpFile) <br>        { <br>            CloseHandle (pInfo-&gt;hTmpFile); <br>        } <br>        if (pInfo-&gt;hPipe) <br>        { <br>            CloseHandle (pInfo-&gt;hPipe); <br>        } <br>        HeapFree (ghHeap, 0, pInfo); <br>    } <br>    if (hWaitEvent) <br>    { <br>        CloseHandle (hWaitEvent); <br>    } <br>    #ifdef _DEBUG <br>    if (lResult &amp;&amp; S_FALSE != lResult) <br>    { <br>        TraceResult ("RemoteOpenOneMsgDownloadPipeA", lResult); <br>    } <br>    #endif // _DEBUG <br>    return lResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    OneMsgDownloadPipeThread() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI OneMsgDownloadPipeThread (PTHREAD_PROC_INFO pInfo) <br>{ <br>    DWORD dwBytesRead, dwBytesWritten; <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    HRESULT hResult = S_OK; <br> <br>    SetFilePointer (pInfo-&gt;hTmpFile, 0, NULL, FILE_BEGIN); <br> <br>    ConnectNamedPipe (pInfo-&gt;hPipe, NULL); <br>     <br>    do <br>    { <br>        if (!ReadFile (pInfo-&gt;hTmpFile, abBuffer, IO_BUFFERSIZE, &amp;dwBytesRead, NULL)) <br>        { <br>            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>            TraceResult ("OneMsgDownloadPipeThread: Failed to read the tmp file", hResult); <br>        } <br>        if (dwBytesRead &amp;&amp; !hResult) <br>        { <br>            if (!WriteFile (pInfo-&gt;hPipe, abBuffer, dwBytesRead, &amp;dwBytesWritten, NULL)) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("OneMsgDownloadPipeThread: Failed to write to the pipe", hResult); <br>            } <br>        } <br>    } while (dwBytesRead &amp;&amp; !hResult); <br> <br>    TraceResult ("OneMsgDownloadPipeThread", hResult); <br>    CloseHandle (pInfo-&gt;hPipe); <br>    CloseHandle (pInfo-&gt;hTmpFile); <br>    HeapFree (ghHeap, 0, pInfo); <br>    return hResult; <br>} <br> <br>// End of file for RXPRPC.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
