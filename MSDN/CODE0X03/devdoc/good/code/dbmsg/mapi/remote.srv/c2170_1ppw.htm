<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADMINUI.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2174"></a>ADMINUI.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      ADMINUI.CPP <br>// <br>//  Description <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "ADMIN.H" <br> <br>#define MAXCOLUMNS        7 <br> <br>extern "C" <br>{ <br>    void WINAPI InitListViewColumns <br>                        (); <br>    BOOL WINAPI CalcStringEllipsis <br>                        (HDC                        hdc, <br>                         LPTSTR                     szString, <br>                         int                        cchMax, <br>                         UINT                       uColWidth); <br>    void WINAPI DrawItemColumn <br>                        (HDC                        hdc, <br>                         LPTSTR                     szText, <br>                         LPRECT                     prcClip); <br>}; <br> <br>UINT g_uColumns[MAXCOLUMNS] = <br>{ <br>    100, <br>    125, <br>    175, <br>    75, <br>    175, <br>    80, <br>    80 <br>}; <br> <br>void WINAPI InitListViewColumns() <br>{ <br>    TCHAR achTemp[256]; <br>    LV_COLUMN lvc; <br>     <br>    // Initialize the LV_COLUMN structure <br>    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; <br>    lvc.fmt = LVCFMT_LEFT; <br>    lvc.pszText = achTemp; <br> <br>    // Add the columns <br>    for (int iCol = 0; iCol &lt; MAXCOLUMNS; iCol++) <br>    { <br>        lvc.iSubItem = iCol; <br>        lvc.cx = g_uColumns[iCol]; <br>        LoadString (ghInstance, IDS_COLUMN1 + iCol, achTemp, sizeof(achTemp)); <br>        ListView_InsertColumn (ghListView, iCol, &amp;lvc); <br>    } <br>} <br> <br>#define TOP_CLEAR               30 <br>#define V_BORDER_SIZE           5 <br>#define H_BORDER_SIZE           3 <br>#define CONTROL_HEIGHT          403 <br>#define TREEVIEW_WIDTH          215 <br>#define TREEVIEW_HEIGHT         CONTROL_HEIGHT <br>#define LISTVIEW_WIDTH          560 <br>#define LISTVIEW_HEIGHT         CONTROL_HEIGHT <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateListView() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>BOOL WINAPI CreateListView (HWND hOwnerWnd, HIMAGELIST hImages) <br>{ <br>    RECT rc; <br>    GetClientRect (hOwnerWnd, &amp;rc); <br>    ghListView = CreateWindowEx (0, <br>                                 WC_LISTVIEW, <br>                                 TEXT(""), <br>                                 WS_VISIBLE | WS_CHILD | WS_BORDER | <br>                                 LVS_REPORT | LVS_OWNERDRAWFIXED | <br>                                 LVS_SHOWSELALWAYS | LVS_SINGLESEL | <br>                                 LVS_SORTASCENDING, <br>                                 V_BORDER_SIZE + TREEVIEW_WIDTH + V_BORDER_SIZE, <br>                                 TOP_CLEAR,  <br>                                 LISTVIEW_WIDTH, <br>                                 LISTVIEW_HEIGHT, <br>                                 hOwnerWnd, <br>                                 (HMENU)IDC_LISTVIEW,  <br>                                 ghInstance,  <br>                                 NULL); <br>    if (ghListView == NULL) <br>    { <br>        return FALSE; <br>    } <br>    ListView_SetImageList (ghListView, hImages, LVSIL_SMALL); <br>    InitListViewColumns(); <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateTreeView() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>BOOL WINAPI CreateTreeView (HWND hOwnerWnd, HIMAGELIST hImages) <br>{ <br>    ghTreeView = CreateWindowEx (0, <br>                                 WC_TREEVIEW, <br>                                 TEXT(""), <br>                                 WS_BORDER | WS_CHILD | WS_VISIBLE | <br>                                 TVS_HASLINES | TVS_HASBUTTONS | <br>                                 TVS_LINESATROOT | TVS_SHOWSELALWAYS | <br>                                 TVS_DISABLEDRAGDROP, <br>                                 V_BORDER_SIZE, <br>                                 TOP_CLEAR, <br>                                 TREEVIEW_WIDTH, <br>                                 TREEVIEW_HEIGHT, <br>                                 hOwnerWnd, <br>                                 (HMENU)IDC_TREEVIEW, <br>                                 ghInstance, <br>                                 NULL); <br>    if (ghTreeView == NULL) <br>    { <br>        return FALSE; <br>    } <br>    TreeView_SetImageList (ghTreeView, hImages, TVSIL_NORMAL); <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateStatusBar() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>BOOL WINAPI CreateStatusBar (HWND hOwnerWnd) <br>{ <br>    ghStatusBar = CreateStatusWindow (WS_BORDER | WS_CHILD | WS_VISIBLE, <br>                                      TEXT("Ready"), <br>                                      hOwnerWnd, <br>                                      IDC_STATUSBAR); <br>    if (ghStatusBar == NULL) <br>    { <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>// Define this enumaration for easier array indexing <br>enum <br>{ <br>    SPACE_1, <br>    ADD_USER, <br>    ADD_DL, <br>    SPACE_2, <br>    SPACE_3, <br>    DELETE_OBJ, <br>    SPACE_4, <br>    SPACE_5, <br>    STOP_HAND, <br>    NUMBER_OF_TB_BUTTONS, <br>    NUMBER_OF_SEPARATORS = 5 <br>}; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateToolBar() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>BOOL WINAPI CreateToolBar (HWND hOwnerWnd) <br>{ <br>    // Initialize each of the buttons with the appropiate values <br>    TBBUTTON tbButton[NUMBER_OF_TB_BUTTONS] = { 0 }; <br> <br>    tbButton[SPACE_1].fsStyle   = TBSTYLE_SEP; <br>    tbButton[SPACE_2].fsStyle   = TBSTYLE_SEP; <br>    tbButton[SPACE_3].fsStyle   = TBSTYLE_SEP; <br>    tbButton[SPACE_4].fsStyle   = TBSTYLE_SEP; <br>    tbButton[SPACE_5].fsStyle   = TBSTYLE_SEP; <br> <br>    tbButton[ADD_USER].iBitmap   = 0; <br>    tbButton[ADD_USER].idCommand = IDM_FILE_NEW_MAILBOX; <br>    tbButton[ADD_USER].fsState   = TBSTATE_ENABLED; <br>    tbButton[ADD_USER].fsStyle   = TBSTYLE_BUTTON; <br> <br>    tbButton[ADD_DL].iBitmap      = 1; <br>    tbButton[ADD_DL].idCommand    = IDM_FILE_NEW_DISTRIBUTIONLIST; <br>    tbButton[ADD_DL].fsState      = TBSTATE_ENABLED; <br>    tbButton[ADD_DL].fsStyle      = TBSTYLE_BUTTON; <br> <br>    tbButton[DELETE_OBJ].iBitmap  = 2; <br>    tbButton[DELETE_OBJ].idCommand= IDM_FILE_DELETE; <br>    tbButton[DELETE_OBJ].fsState  = TBSTATE_ENABLED; <br>    tbButton[DELETE_OBJ].fsStyle  = TBSTYLE_BUTTON; <br> <br>    tbButton[STOP_HAND].iBitmap  = 3; <br>    tbButton[STOP_HAND].idCommand= IDC_CANCEL_REMOTE_CALL; <br>    tbButton[STOP_HAND].fsState  = TBSTATE_INDETERMINATE; <br>    tbButton[STOP_HAND].fsStyle  = TBSTYLE_BUTTON; <br> <br>    // Create the toolbar with the most commonly used functions <br>    ghToolBar = CreateToolbarEx (hOwnerWnd, <br>                                 WS_VISIBLE | WS_CHILD | WS_BORDER | TBSTYLE_TOOLTIPS, <br>                                 IDC_TOOLBAR, <br>                                 // The number of images is the number of <br>                                 // buttons minus the separators <br>                                 NUMBER_OF_TB_BUTTONS - NUMBER_OF_SEPARATORS, <br>                                 ghInstance, <br>                                 IDB_TOOLBAR, <br>                                 tbButton, <br>                                 NUMBER_OF_TB_BUTTONS, <br>                                 16, 16, 16, 32, <br>                                 sizeof(TBBUTTON)); <br>    if (NULL == ghToolBar) <br>    { <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    UpdateHeaderWidth() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI UpdateHeaderWidth (HWND hWndHeader, int iItem) <br>{ <br>    HD_ITEM hdi; <br>    // Get the column width from the control <br>    hdi.mask = HDI_WIDTH; <br>    if (Header_GetItem (hWndHeader, iItem, &amp;hdi)) <br>    { <br>        g_uColumns[iItem] = hdi.cxy; <br>    } <br>    // Force the ListView control to repaint <br>    InvalidateRect (ghListView, NULL, TRUE); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DrawListViewItem() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI DrawListViewItem (LPDRAWITEMSTRUCT pDIS) <br>{ <br>    TCHAR szBuffer[512]; <br>    LV_ITEM lvi; <br>    int cxImage = 0, cyImage = 0; <br>    UINT uFirstColWidth; <br>    RECT rcClip; <br>    int iColumn = 1; <br>    UINT uiFlags = ILD_TRANSPARENT; <br> <br>    // Get the item image to be displayed <br>    lvi.mask = LVIF_IMAGE | LVIF_STATE | LVIF_TEXT; <br>    lvi.iItem = pDIS-&gt;itemID; <br>    lvi.iSubItem = 0; <br>    lvi.pszText = szBuffer; <br>    lvi.cchTextMax = 512; <br>    ListView_GetItem (pDIS-&gt;hwndItem, &amp;lvi); <br> <br>    // Check to see if this item is selected <br>    if (pDIS-&gt;itemState &amp; ODS_SELECTED) <br>    { <br>        // Set the text background and foreground colors <br>        SetTextColor (pDIS-&gt;hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)); <br>        SetBkColor (pDIS-&gt;hDC, GetSysColor(COLOR_HIGHLIGHT)); <br> <br>        // Also add the ILD_BLEND50 so the images come out selected <br>        uiFlags |= ILD_BLEND50; <br>    } <br>    else <br>    { <br>        // Set the text background and foreground colors to the standard window colors <br>        SetTextColor (pDIS-&gt;hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>        SetBkColor (pDIS-&gt;hDC, GetSysColor(COLOR_WINDOW)); <br>    } <br> <br>    // Get the image list and draw the image <br>    ImageList_Draw (g_hImages, <br>                    lvi.iImage, <br>                    pDIS-&gt;hDC, <br>                    pDIS-&gt;rcItem.left, <br>                    pDIS-&gt;rcItem.top, <br>                    uiFlags); <br>    // Find out how big the image we just drew was <br>    ImageList_GetIconSize (g_hImages, &amp;cxImage, &amp;cyImage); <br>     <br>    // Calculate the width of the first column after the image width.  If <br>    // There was no image, then cxImage will be zero. <br>    uFirstColWidth = g_uColumns[0] - cxImage; <br> <br>    // Set up the new clipping rect for the first column text and draw it <br>    rcClip.left = pDIS-&gt;rcItem.left + cxImage; <br>    rcClip.right = pDIS-&gt;rcItem.left + g_uColumns[0]; <br>    rcClip.top = pDIS-&gt;rcItem.top; <br>    rcClip.bottom = pDIS-&gt;rcItem.bottom; <br> <br>    DrawItemColumn (pDIS-&gt;hDC, szBuffer, &amp;rcClip); <br>    szBuffer[0] = 0; <br> <br>    lvi.mask = LVIF_TEXT; <br>    lvi.iSubItem++; <br>    ListView_GetItem (pDIS-&gt;hwndItem, &amp;lvi); <br>    rcClip.left = rcClip.right; <br>    rcClip.right = rcClip.left + g_uColumns[1]; <br>    DrawItemColumn(pDIS-&gt;hDC, szBuffer, &amp;rcClip); <br>    szBuffer[0] = 0; <br> <br>    rcClip.left = rcClip.right; <br>    rcClip.right = rcClip.left + g_uColumns[2]; <br>    lvi.iSubItem++; <br>    ListView_GetItem (pDIS-&gt;hwndItem, &amp;lvi); <br>    DrawItemColumn(pDIS-&gt;hDC, szBuffer, &amp;rcClip); <br>    szBuffer[0] = 0; <br> <br>    rcClip.left = rcClip.right; <br>    rcClip.right = rcClip.left + g_uColumns[3]; <br>    lvi.iSubItem++; <br>    ListView_GetItem (pDIS-&gt;hwndItem, &amp;lvi); <br>    DrawItemColumn(pDIS-&gt;hDC, szBuffer, &amp;rcClip); <br>    szBuffer[0] = 0; <br> <br>    rcClip.left = rcClip.right; <br>    rcClip.right = rcClip.left + g_uColumns[4]; <br>    lvi.iSubItem++; <br>    ListView_GetItem (pDIS-&gt;hwndItem, &amp;lvi); <br>    DrawItemColumn(pDIS-&gt;hDC, szBuffer, &amp;rcClip); <br>    szBuffer[0] = 0; <br> <br>    rcClip.left = rcClip.right; <br>    rcClip.right = rcClip.left + g_uColumns[5]; <br>    lvi.iSubItem++; <br>    ListView_GetItem (pDIS-&gt;hwndItem, &amp;lvi); <br>    DrawItemColumn(pDIS-&gt;hDC, szBuffer, &amp;rcClip); <br>    szBuffer[0] = 0; <br> <br>    rcClip.left = rcClip.right; <br>    rcClip.right = rcClip.left + g_uColumns[6]; <br>    lvi.iSubItem++; <br>    ListView_GetItem (pDIS-&gt;hwndItem, &amp;lvi); <br>    DrawItemColumn(pDIS-&gt;hDC, szBuffer, &amp;rcClip); <br>    szBuffer[0] = 0; <br> <br>    // If we changed the colors for the selected item, undo it <br>    if (pDIS-&gt;itemState &amp; ODS_SELECTED) <br>    { <br>        // Set the text background and foreground colors <br>        SetTextColor (pDIS-&gt;hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>        SetBkColor (pDIS-&gt;hDC, GetSysColor(COLOR_WINDOW)); <br>    } <br> <br>    // If the item is focused, now draw a focus rect around the entire row <br>    if (pDIS-&gt;itemState &amp; ODS_FOCUS) <br>    { <br>        // Adjust the left edge to exclude the image <br>        rcClip = pDIS-&gt;rcItem; <br>        rcClip.left += cxImage; <br> <br>        // Draw the focus rect <br>        DrawFocusRect (pDIS-&gt;hDC, &amp;rcClip); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DrawItemColumn() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI DrawItemColumn (HDC hdc, LPTSTR szText, LPRECT prcClip) <br>{ <br>    TCHAR szString[256]; <br>    // Check to see if the string fits in the clip rect.  If not, truncate <br>    // the string and add "...". <br>    lstrcpy(szString, szText); <br>    CalcStringEllipsis (hdc, szString, 256, prcClip-&gt;right - prcClip-&gt;left); <br>    ExtTextOut (hdc, <br>                prcClip-&gt;left + 2, <br>                prcClip-&gt;top + 1, <br>                ETO_CLIPPED | ETO_OPAQUE, <br>                prcClip, <br>                szString, <br>                lstrlen(szString), <br>                NULL); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CalcStringEllipsis() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>BOOL WINAPI CalcStringEllipsis (HDC     hdc, <br>                                LPTSTR  szString, <br>                                int     cchMax, <br>                                UINT    uColWidth) <br>{ <br>    const TCHAR szEllipsis[] = TEXT("..."); <br>    SIZE   sizeString; <br>    SIZE   sizeEllipsis; <br>    int    cbString; <br>    LPTSTR lpszTemp; <br>    BOOL   fSuccess = FALSE; <br>     <br>    // Adjust the column width to take into account the edges <br>    uColWidth -= 4; <br>    __try <br>    { <br>        // Allocate a string for us to work with.  This way we can mangle the <br>        // string and still preserve the return value <br>        lpszTemp = (LPTSTR)HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, cchMax); <br>        if (!lpszTemp) <br>        { <br>            __leave; <br>        } <br>        lstrcpy (lpszTemp, szString); <br> <br>        // Get the width of the string in pixels <br>        cbString = lstrlen(lpszTemp); <br>        if (!GetTextExtentPoint32 (hdc, lpszTemp, cbString, &amp;sizeString)) <br>        { <br>            __leave; <br>        } <br> <br>        // If the width of the string is greater than the column width shave <br>        // the string and add the ellipsis <br>        if ((ULONG)sizeString.cx &gt; uColWidth) <br>        { <br>            if (!GetTextExtentPoint32 (hdc, <br>                                       szEllipsis, <br>                                       lstrlen(szEllipsis), <br>                                       &amp;sizeEllipsis)) <br>            { <br>                __leave; <br>            } <br> <br>            while (cbString &gt; 0) <br>            { <br>                lpszTemp[--cbString] = 0; <br>                if (!GetTextExtentPoint32 (hdc, lpszTemp, cbString, &amp;sizeString)) <br>                { <br>                    __leave; <br>                } <br> <br>                if ((ULONG)(sizeString.cx + sizeEllipsis.cx) &lt;= uColWidth) <br>                { <br>                    // The string with the ellipsis finally fits, now make sure <br>                    // there is enough room in the string for the ellipsis <br>                    if (cchMax &gt;= (cbString + lstrlen(szEllipsis))) <br>                    { <br>                        // Concatenate the two strings and break out of the loop <br>                        lstrcat (lpszTemp, szEllipsis); <br>                        lstrcpy (szString, lpszTemp); <br>                        fSuccess = TRUE; <br>                        __leave; <br>                    } <br>                } <br>            } <br>        } <br>        else <br>        { <br>            // No need to do anything, everything fits great. <br>            fSuccess = TRUE; <br>        } <br>    } <br>    __finally <br>    { <br>        // Free the memory <br>        HeapFree (GetProcessHeap(), 0, (LPVOID)lpszTemp); <br>        return fSuccess; <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ErrorHandler() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI ErrorHandler (HWND hOwnerWnd, HRESULT hError) <br>{ <br>    LPTSTR szSystemMessage = NULL; <br>    TCHAR achBuffer[1024]; <br>    DWORD dwSystemError; <br>    // If the facility is RPC remove it before calling FormatMessage(). That <br>    // Win32 API does not recognizes the facility. <br>    if (HRESULT_FACILITY(hError) == FACILITY_RPC) <br>    { <br>        dwSystemError = LOWORD(hError); <br>    } <br>    else <br>    { <br>        dwSystemError = hError; <br>    } <br>    // Get an error description from the system <br>    DWORD dwChars = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,  <br>                                   NULL,  <br>                                   dwSystemError,  <br>                                   MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),  <br>                                   (LPTSTR)&amp;szSystemMessage, <br>                                   0,  <br>                                   NULL); <br>    // Check to see if FormatMessage() returned us an error <br>    if (0 == dwChars) <br>    { <br>        szSystemMessage = TEXT("Generic Error"); <br>    } <br>    else <br>    { <br>        LPTSTR pStr = &amp;szSystemMessage[lstrlen (szSystemMessage)]; <br>        while ('\r' != *pStr) <br>        { <br>            pStr--; <br>        } <br>        *pStr = 0; <br>    } <br>    ASSERT (dwChars &lt; 1024); <br>    // Add the error code to the string returned and then show it. <br>    switch (HRESULT_FACILITY(hError)) <br>    { <br>        case FACILITY_WIN32 : <br>            wsprintf (achBuffer, <br>                      TEXT("%s (Win32 Error %d)"), <br>                      szSystemMessage, <br>                      LOWORD(hError)); <br>            break; <br>        case FACILITY_STORAGE : <br>            wsprintf (achBuffer, <br>                      TEXT("%s (IStorage Error %08X)"), <br>                      szSystemMessage, <br>                      hError); <br>            break; <br>        case FACILITY_ITF : <br>            wsprintf (achBuffer, <br>                      TEXT("%s (Interface Error %08X)"), <br>                      szSystemMessage, <br>                      hError); <br>            break; <br>        case FACILITY_RPC : <br>            wsprintf (achBuffer, <br>                      TEXT("%s (RPC Error %d - %08X)"), <br>                      szSystemMessage, <br>                      LOWORD(hError), <br>                      hError); <br>            break; <br>        default : <br>            wsprintf (achBuffer, <br>                      TEXT("%s (Unknown Facility(%d) Error %d - %08X)"), <br>                      szSystemMessage, <br>                      HRESULT_FACILITY(hError), <br>                      hError, <br>                      hError); <br>            break; <br>    } <br>    if (dwChars) <br>    { <br>        LocalFree ((HLOCAL)szSystemMessage); <br>    } <br>    MessageBox (hOwnerWnd, achBuffer, TEXT("WINDS Administrator - Error"), MB_ICONSTOP | MB_OK); <br>} <br> <br>// End of file for ADMINUI.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
