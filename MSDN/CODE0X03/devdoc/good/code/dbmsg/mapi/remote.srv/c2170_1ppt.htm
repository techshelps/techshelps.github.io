<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADMDLIST.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2171"></a>ADMDLIST.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      ADMDLIST.CPP <br>// <br>//  Description <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "ADMIN.H" <br>#include "COMMON.H" <br> <br>extern "C" <br>{ <br>    HRESULT WINAPI DisplayDistListPropSheets <br>                        (HWND                       hOwnerWnd, <br>                         POBJECT_INFO               pObjInfo, <br>                         BOOL                       fCreate); <br>    BOOL CALLBACK DLProps1DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK DLProps2DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK DLProps3DlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK ModifyListDlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    BOOL CALLBACK WaitDlgProc <br>                        (HWND                       hDlg,  <br>                         UINT                       message,  <br>                         WPARAM                     wParam,  <br>                         LPARAM                     lParam); <br>    void WINAPI AddMembersToPageLV <br>                        (HWND                       hOwnerWnd, <br>                         HWND                       hListView, <br>                         DLM_LIST *                 pMembers); <br>}; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetServerDistLists() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI GetServerDistLists (HWND hOwnerWnd) <br>{ <br>    return DownloadBulkInfo (hOwnerWnd, ghListView, ITEM_SERVER_DIST_LISTS); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DownloadBulkInfo() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>// <br>HRESULT WINAPI DownloadBulkInfo (HWND hOwnerWnd, HWND hListView, ITEM_TYPE Type) <br>{ <br>    LV_ITEM lvi = { 0 }; <br>    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br>    int i = 0; <br>    long lPipeNum; <br>    TCHAR achPipeName[128]; <br>    LPTSTR szObjAlias; <br>    HANDLE hPipe; <br>    DWORD dwBytesRead; <br>    DWORD * pdwObjID; <br>    AB_ENTRY_INFO abEntry = { 0 }; <br>    HRESULT hResult = S_OK; <br>    EnterCriticalSection (&amp;csRemoteServer); <br>    SendMessage (hOwnerWnd, WM_WINDS_REMOTE_CALL_IN_PROGRESS, hResult, 0); <br>    ListView_DeleteAllItems (hListView); <br>    SendMessage (ghStatusBar, SB_SETTEXT, 0, (LPARAM)TEXT("Connecting to the server...")); <br>    RpcTryExcept <br>    { <br>        // Make the remote call to request the server to open a pipe for the download <br>        switch (Type) <br>        { <br>            case ITEM_SERVER_USER_MAILBOXES : <br>                hResult = RemoteAdmGetServerMailboxes (&amp;lPipeNum); <br>                lvi.iImage = IMG_USER_MAILBOX; <br>                pdwObjID = &amp;(abEntry.Info.MB.dwObjID); <br>                szObjAlias = abEntry.Info.MB.szMailboxName; <br>                break; <br>            case ITEM_SERVER_DIST_LISTS : <br>                hResult = RemoteAdmGetServerDistLists (&amp;lPipeNum); <br>                lvi.iImage = IMG_DIST_LIST; <br>                pdwObjID = &amp;(abEntry.Info.DL.dwObjID); <br>                szObjAlias = abEntry.Info.DL.szDLAlias; <br>                break; <br>            default : <br>                ASSERTMSG (FALSE, "Unknown item type"); <br>                hResult = E_FAIL; <br>                break; <br>        } <br>        if (!hResult) <br>        { <br>            SendMessage (ghStatusBar, SB_SETTEXT, 0, (LPARAM)TEXT("Connection established... Pending pipe connection...")); <br>            // Construct the download pipe name <br>            wsprintf (achPipeName, PIPE_NAME_FORMAT, g_szCurrentServer, lPipeNum); <br>            // Create our endpoint and connect     <br>            hPipe = CreateFile (achPipeName,  <br>                                GENERIC_READ, <br>                                0, <br>                                NULL, <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL); <br>            if (INVALID_HANDLE_VALUE == hPipe) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>            } <br>        } <br>    } <br>    RpcExcept(1) <br>    {         <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    if (!hResult) <br>    { <br>        SendMessage (ghStatusBar, SB_SETTEXT, 0, (LPARAM)TEXT("Pipe opened. Downloading server information...")); <br>        do <br>        { <br>            // Read from the pipe <br>            if (!ReadFile (hPipe, &amp;abEntry, sizeof(AB_ENTRY_INFO), &amp;dwBytesRead, NULL)) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                if (HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE)   != hResult &amp;&amp;   // For Windows NT <br>                    HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hResult)     // For Windows 95 <br>                { <br>                    // There was an error and we can't continue <br>                    TraceResult ("DownloadBulkInfo: Failed to read from the source", hResult); <br>                } <br>                else <br>                { <br>                    // If the pipe was broken, it means the server finished writing <br>                    // to the it, so we are finished reading from it. <br>                    hResult = S_OK; <br>                } <br>            } <br>            else <br>            {    <br>                lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br>                lvi.iItem = i; <br>                lvi.iSubItem = 0; <br>                lvi.pszText = szObjAlias; <br>                lvi.lParam = *pdwObjID; <br>                lvi.iItem = ListView_InsertItem (hListView, &amp;lvi); <br>                 <br>                switch (Type) <br>                { <br>                    case ITEM_SERVER_USER_MAILBOXES : <br>                        ListView_SetItemText (hListView, lvi.iItem, 1, abEntry.Info.MB.szFullName); <br>                        ListView_SetItemText (hListView, lvi.iItem, 2, abEntry.Info.MB.szJobTitle); <br>                        ListView_SetItemText (hListView, lvi.iItem, 3, abEntry.Info.MB.szOffice); <br>                        ListView_SetItemText (hListView, lvi.iItem, 4, abEntry.Info.MB.szDepartment); <br>                        ListView_SetItemText (hListView, lvi.iItem, 5, abEntry.Info.MB.szPhone); <br>                        ListView_SetItemText (hListView, lvi.iItem, 6, abEntry.Info.MB.szFax); <br>                        break; <br>                    case ITEM_SERVER_DIST_LISTS : <br>                        ListView_SetItemText (hListView, lvi.iItem, 1, abEntry.Info.DL.szDLFullName); <br>                        break; <br>                } <br>                i++; <br>            } <br>            if (AbortRemoteCall()) <br>            { <br>                dwBytesRead = 0; // This will cause the DO-WHILE() loop to terminate <br>                hResult = S_OK; // If the user aborted the call, don't return any error. <br>            } <br>        } while (dwBytesRead &amp;&amp; !hResult); <br>        CloseHandle (hPipe); <br>        SendMessage (ghStatusBar, SB_SETTEXT, 0, (LPARAM)TEXT("Connection Closed...")); <br>    } <br>    LeaveCriticalSection (&amp;csRemoteServer); <br>    TraceResult ("DownloadBulkInfo", hResult); <br>    SendMessage (hOwnerWnd, WM_WINDS_REMOTE_CALL_COMPLETED, hResult, 0); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CreateNewDistList() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>// <br>//    Return Value <br>// <br>void WINAPI CreateNewDistList (HWND hOwnerWnd) <br>{ <br>    DLM_XMIT_LIST Members = { 0 }; <br>    OBJECT_INFO ObjInfo = { 0 }; <br>    ObjInfo.DL.pMembers = &amp;Members; <br>    ObjInfo.Type = SERVER_DISTRIBUTION_LIST; <br>    HRESULT hResult = DisplayDistListPropSheets (hOwnerWnd, &amp;ObjInfo, TRUE); <br>    if (!hResult) <br>    { <br>        RpcTryExcept <br>        { <br>            hResult = RemoteAdmCreateDistList ((WINDS_RPC_STRING)ObjInfo.DL.szDLAlias, <br>                                               (WINDS_RPC_STRING)ObjInfo.DL.szDLFullName, <br>                                               ObjInfo.DL.dwFlags, <br>                                               (WINDS_RPC_STRING)ObjInfo.DL.szOwnerAlias, <br>                                               (WINDS_RPC_STRING)ObjInfo.DL.szOwnerName, <br>                                               ObjInfo.DL.dwOwnerID, <br>                                               &amp;Members); <br>        } <br>        RpcExcept(1) <br>        {         <br>            // If we got here is because there was an error while call was made <br>            // or when it was about to be made. <br>            hResult = RpcExceptionCode(); <br>            if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>            { <br>                hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>            } <br>            else <br>            { <br>                hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>            } <br>        } <br>        RpcEndExcept <br>        FreeDLMList (&amp;Members); <br>    } <br>    else <br>    { <br>        if (S_FALSE == hResult) <br>        { <br>            hResult = S_OK; <br>        } <br>    } <br>    if (hResult) <br>    { <br>        ErrorHandler (hOwnerWnd, hResult); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ShowDistListProps() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI ShowDistListProps (HWND hOwnerWnd, DWORD dwObjID) <br>{ <br>    DLM_XMIT_LIST_A Members = { 0 }; <br>    OBJECT_INFO ObjInfo = { 0 }; <br>    ObjInfo.DL.dwObjID = dwObjID; <br>    ObjInfo.DL.pMembers = &amp;Members; <br>    ObjInfo.Type = SERVER_DISTRIBUTION_LIST; <br> <br>    HRESULT hResult = S_OK; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteAdmGetDLProps (dwObjID, <br>                                       (WINDS_RPC_STRING)ObjInfo.DL.szDLAlias, <br>                                       (WINDS_RPC_STRING)ObjInfo.DL.szDLFullName, <br>                                       &amp;ObjInfo.DL.dwFlags, <br>                                       (WINDS_RPC_STRING)ObjInfo.DL.szOwnerAlias, <br>                                       (WINDS_RPC_STRING)ObjInfo.DL.szOwnerName, <br>                                       &amp;ObjInfo.DL.dwOwnerID, <br>                                       (WINDS_RPC_STRING)ObjInfo.DL.szComments, <br>                                       &amp;Members); <br>    } <br>    RpcExcept(1) <br>    {         <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    if (!hResult) <br>    {    <br>        hResult = DisplayDistListPropSheets (hOwnerWnd, &amp;ObjInfo, FALSE); <br>        if (S_OK == hResult) <br>        { <br>            RpcTryExcept <br>            { <br>                hResult = RemoteAdmSetDLProps (dwObjID, <br>                                               (WINDS_RPC_STRING)ObjInfo.DL.szDLAlias, <br>                                               (WINDS_RPC_STRING)ObjInfo.DL.szDLFullName, <br>                                               ObjInfo.DL.dwFlags, <br>                                               (WINDS_RPC_STRING)ObjInfo.DL.szOwnerAlias, <br>                                               (WINDS_RPC_STRING)ObjInfo.DL.szOwnerName, <br>                                               ObjInfo.DL.dwOwnerID, <br>                                               (WINDS_RPC_STRING)ObjInfo.DL.szComments, <br>                                               &amp;Members); <br>            } <br>            RpcExcept(1) <br>            {         <br>                // If we got here is because there was an error while call was made <br>                // or when it was about to be made. <br>                hResult = RpcExceptionCode(); <br>                if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>                { <br>                    hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>                } <br>                else <br>                { <br>                    hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>                } <br>            } <br>            RpcEndExcept <br>        } <br>        if (S_FALSE == hResult) <br>        { <br>            hResult = S_OK; <br>        } <br>        FreeDLMList (&amp;Members); <br>    } <br>    if (hResult) <br>    { <br>        ErrorHandler (hOwnerWnd, hResult); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DisplayDistListPropSheets() <br>// <br>//    Parameters <br>//       <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>HRESULT WINAPI DisplayDistListPropSheets (HWND           hOwnerWnd, <br>                                          POBJECT_INFO   pObjInfo, <br>                                          BOOL           fCreate) <br>{ <br>    PROPSHEETHEADER psh = { 0 }; <br>    PROPSHEETPAGE psp[3] = { 0 }; <br>    TCHAR szHeaderTitle[64]; <br> <br>    OBJECT_INFO NewObjInfo = *pObjInfo; <br> <br>    psp[0].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[0].dwFlags     = PSP_USETITLE; <br>    psp[0].hInstance   = ghInstance; <br>    psp[0].pszTemplate = MAKEINTRESOURCE (IDD_DL_PROPS1); <br>    psp[0].pfnDlgProc  = DLProps1DlgProc; <br>    psp[0].pszTitle    = TEXT("General"); <br>    psp[0].lParam      = (LPARAM)&amp;NewObjInfo; <br>     <br>    psp[1].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[1].dwFlags     = PSP_USETITLE; <br>    psp[1].hInstance   = ghInstance; <br>    psp[1].pszTemplate = MAKEINTRESOURCE (IDD_DL_PROPS2); <br>    psp[1].pfnDlgProc  = DLProps2DlgProc; <br>    psp[1].pszTitle    = TEXT("Members"); <br>    psp[1].lParam      = (LPARAM)&amp;NewObjInfo; <br> <br>    psp[2].dwSize      = sizeof(PROPSHEETPAGE); <br>    psp[2].dwFlags     = PSP_USETITLE; <br>    psp[2].hInstance   = ghInstance; <br>    psp[2].pszTemplate = MAKEINTRESOURCE (IDD_DL_PROPS3); <br>    psp[2].pfnDlgProc  = DLProps3DlgProc; <br>    psp[2].pszTitle    = TEXT("Ownership"); <br>    psp[2].lParam      = (LPARAM)&amp;NewObjInfo; <br> <br>    psh.dwSize     = sizeof(PROPSHEETHEADER); <br>    psh.dwFlags    = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW; <br>    psh.hwndParent = hOwnerWnd; <br>    psh.hInstance  = ghInstance; <br>    psh.nPages     = sizeof(psp)/sizeof(PROPSHEETPAGE); <br>    psh.ppsp       = (LPCPROPSHEETPAGE)&amp;psp; <br>    if (fCreate) <br>    { <br>        psh.pszCaption = TEXT("New Distribution List Properties"); <br>        psh.nStartPage = 0; <br>    } <br>    else <br>    { <br>        wsprintf (szHeaderTitle, TEXT("Distribution List Properties for %s"), pObjInfo-&gt;DL.szDLAlias); <br>        psh.pszCaption = szHeaderTitle; <br>        psh.nStartPage = 1; <br>    } <br> <br>    // If the user hit OK and at least one of the properties changed, <br>    // we must change the properties on the server <br>ReEnterProperties: <br>    if (1 == PropertySheet (&amp;psh) &amp;&amp; <br>        (fCreate || NewObjInfo.dwData || <br>        NewObjInfo.DL.dwFlags != pObjInfo-&gt;DL.dwFlags || <br>        NewObjInfo.DL.dwOwnerID != pObjInfo-&gt;DL.dwOwnerID || <br>        lstrcmpi (NewObjInfo.DL.szDLFullName, pObjInfo-&gt;DL.szDLFullName) || <br>        lstrcmpi (NewObjInfo.DL.szDLAlias, pObjInfo-&gt;DL.szDLAlias) || <br>        lstrcmpi (NewObjInfo.DL.szComments, pObjInfo-&gt;DL.szComments))) <br>    { <br>        if (fCreate) <br>        { <br>            if (!IsObjAliasValid (hOwnerWnd, NewObjInfo.DL.szDLAlias)) <br>            { <br>                goto ReEnterProperties; <br>            } <br>        } <br>        if (0 == lstrlen (NewObjInfo.DL.szDLFullName)) <br>        { <br>            PrivateMessageBox (IDS_MSG_NO_DL_NAME, hOwnerWnd, 0); <br>            goto ReEnterProperties; <br>        } <br>        *pObjInfo = NewObjInfo; <br>        return S_OK; <br>    } <br>    return S_FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DLProps1DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK DLProps1DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    static HWND hCtlLabel; <br>    switch (message) <br>    { <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_OBJECT_ALIAS); <br>                SetWindowText (hCtl, pObjInfo-&gt;DL.szDLAlias); <br>                if (0 == pObjInfo-&gt;DL.dwObjID) <br>                { <br>                    EnableWindow (hCtl, TRUE); <br>                    Edit_LimitText (hCtl, MAX_ALIAS_SIZE); <br>                    hCtl = GetDlgItem (hDlg, IDC_OBJECT_ALIAS_LABEL); <br>                    EnableWindow (hCtl, TRUE); <br>                } <br> <br>                hCtl = GetDlgItem (hDlg, IDC_DL_FULLNAME); <br>                Edit_LimitText (hCtl, MAX_STRING_SIZE); <br>                SetWindowText (hCtl, pObjInfo-&gt;DL.szDLFullName); <br> <br>                hCtlLabel = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hCtlLabel, pObjInfo-&gt;DL.szDLAlias); <br>                SetWindowFont (hCtlLabel, ghBoldFont, TRUE); <br> <br>                if (OBJECT_DISABLED &amp; pObjInfo-&gt;DL.dwFlags) <br>                { <br>                    Button_SetCheck (GetDlgItem (hDlg, IDC_DISABLE), BST_CHECKED); <br>                } <br>                if (HIDE_IN_DIR &amp; pObjInfo-&gt;DL.dwFlags) <br>                { <br>                    Button_SetCheck (GetDlgItem (hDlg, IDC_HIDE), BST_CHECKED); <br>                } <br> <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_LARGE_ENVEL, ILD_NORMAL)); <br>            } <br>            return TRUE; <br> <br>        case WM_NOTIFY: <br>            if (PSN_APPLY == ((LPNMHDR)lParam)-&gt;code) <br>            { <br>                if (BST_CHECKED == Button_GetCheck (GetDlgItem (hDlg, IDC_DISABLE))) <br>                { <br>                    pObjInfo-&gt;DL.dwFlags |= OBJECT_DISABLED; <br>                } <br>                else <br>                { <br>                    pObjInfo-&gt;DL.dwFlags &amp;= ~OBJECT_DISABLED; <br>                } <br>                if (BST_CHECKED == Button_GetCheck (GetDlgItem (hDlg, IDC_HIDE))) <br>                { <br>                    pObjInfo-&gt;DL.dwFlags |= HIDE_IN_DIR; <br>                } <br>                else <br>                { <br>                    pObjInfo-&gt;DL.dwFlags &amp;= ~HIDE_IN_DIR; <br>                } <br>                GetWindowText (GetDlgItem (hDlg, IDC_OBJECT_ALIAS), <br>                               pObjInfo-&gt;DL.szDLAlias, <br>                               MAX_ALIAS_SIZE+1); <br>                GetWindowText (GetDlgItem (hDlg, IDC_DL_FULLNAME), <br>                               pObjInfo-&gt;DL.szDLFullName, <br>                               MAX_STRING_SIZE+1); <br>                return PSNRET_NOERROR; <br>            } <br>            break; <br> <br>        case WM_COMMAND : <br>            if (HIWORD(wParam) == EN_CHANGE &amp;&amp; LOWORD(wParam) == IDC_OBJECT_ALIAS) <br>            { <br>                GetWindowText ((HWND)lParam, pObjInfo-&gt;DL.szDLAlias, MAX_ALIAS_SIZE+1); <br>                SetWindowText (hCtlLabel, pObjInfo-&gt;DL.szDLAlias); <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DLProps2DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK DLProps2DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                 <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hCtl, pObjInfo-&gt;DL.szDLAlias); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br> <br>                hCtl = GetDlgItem (hDlg, IDC_MEMBERS); <br>                ListView_SetImageList (hCtl, g_hImages, LVSIL_SMALL); <br> <br>                RECT rc; <br>                GetClientRect (hCtl, &amp;rc); <br>                LV_COLUMN lvc; <br>                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; <br>                lvc.fmt = LVCFMT_LEFT; <br>                lvc.pszText = TEXT("Full Name"); <br>                lvc.iSubItem = 0; <br>                lvc.cx = 160; <br>                ListView_InsertColumn (hCtl, 0, &amp;lvc); <br>                lvc.pszText = TEXT("Alias"); <br>                lvc.iSubItem = 1; <br>                lvc.cx = min (110, (rc.right - rc.left - lvc.cx)); <br>                ListView_InsertColumn (hCtl, 1, &amp;lvc); <br> <br>                AddMembersToPageLV (hDlg, hCtl, (DLM_LIST *)pObjInfo-&gt;DL.pMembers); <br> <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_DL_MEMBERS, ILD_NORMAL)); <br>            } <br>            return TRUE; <br> <br>        case WM_DESTROY : <br>            ListView_SetImageList (GetDlgItem (hDlg, IDC_MEMBERS), NULL, LVSIL_SMALL); <br>            break; <br> <br>        case WM_COMMAND : <br>            if (LOWORD(wParam) == IDC_MODIFY) <br>            { <br>                pObjInfo-&gt;pMembers = (DLM_LIST *)pObjInfo-&gt;DL.pMembers; <br>                if (TRUE == DialogBoxParam (ghInstance, <br>                                            MAKEINTRESOURCE(IDD_ADDTOLIST), <br>                                            hDlg, <br>                                            ModifyListDlgProc, <br>                                            (LPARAM)pObjInfo)) <br>                { <br>                    AddMembersToPageLV (hDlg, GetDlgItem (hDlg, IDC_MEMBERS), (DLM_LIST *)pObjInfo-&gt;DL.pMembers); <br>                } <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    AddMembersToPageLV() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//       <br>void WINAPI AddMembersToPageLV (HWND        hOwnerWnd, <br>                                HWND        hListView, <br>                                DLM_LIST *  pMembers) <br>{ <br>    ListView_DeleteAllItems (hListView); <br>    int i = 0; <br>    LV_ITEM lvi = { 0 }; <br>    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br>    WINDS_AB_OBJTYPE Type; <br>    DLM_LIST * pNode = pMembers; <br>    while (pNode &amp;&amp; pNode-&gt;Info.szMemberAlias[0]) <br>    { <br>        Type = (WINDS_AB_OBJTYPE)pNode-&gt;Info.dwMemberType; <br>        switch (Type) <br>        { <br>            case GATEWAY_RECIPIENT : <br>            case SERVER_USER_MAILBOX : <br>                lvi.iImage = IMG_USER_MAILBOX; <br>                break; <br>            case ITEM_SERVER_DIST_LISTS : <br>                lvi.iImage = IMG_DIST_LIST; <br>                break; <br>            case PUBLIC_FOLDER : <br>                TraceMessage ("AddMembersToPageLV: Public Folder added - WARNING NYI"); <br>            default : <br>                goto NextNode; <br>        } <br>        lvi.iItem = i; <br>        lvi.iSubItem = 0; <br>        lvi.pszText = (LPSTR)pNode-&gt;Info.szMemberName; <br>        lvi.lParam = pNode-&gt;Info.dwMemberID; <br>        lvi.iItem = ListView_InsertItem (hListView, &amp;lvi); <br>        ListView_SetItemText (hListView, lvi.iItem, 1, (LPSTR)pNode-&gt;Info.szMemberAlias); <br>        i++; <br>NextNode: <br>        pNode = pNode-&gt;pNext; <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DLProps3DlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK DLProps3DlgProc (HWND    hDlg,  <br>                               UINT    message,  <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo = NULL; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                // The pointer to the folder object came in the PROPSHEETPAGE <br>                // structure. The lParam of this message has a pointer to the <br>                // structure used to create this page. Get the OBJECT_INFO <br>                // pointer and save it. <br>                pObjInfo = (POBJECT_INFO)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hCtl = GetDlgItem (hDlg, IDC_ICON_TITLE); <br>                SetWindowText (hCtl, pObjInfo-&gt;DL.szDLAlias); <br>                SetWindowFont (hCtl, ghBoldFont, TRUE); <br> <br>                if (DL_OWNED &amp; pObjInfo-&gt;DL.dwFlags) <br>                { <br>                    SetWindowText (GetDlgItem (hDlg, IDC_DL_OWNER), pObjInfo-&gt;DL.szOwnerName); <br>                    hCtl = GetDlgItem (hDlg, IDC_COMMENTS); <br>                    SetWindowText (hCtl, pObjInfo-&gt;DL.szComments); <br>                    Edit_LimitText (hCtl, sizeof(pObjInfo-&gt;DL.szComments)/sizeof(TCHAR) - 1); <br>                    hCtl = GetDlgItem (hDlg, IDC_OWNED); <br>                    Button_SetCheck (hCtl, BST_CHECKED); <br>                    PostMessage (hDlg, WM_COMMAND, MAKEWPARAM(IDC_OWNED, BN_CLICKED), (LPARAM)hCtl); <br>                } <br>                else <br>                { <br>                    Button_SetCheck (GetDlgItem (hDlg, IDC_NOT_OWNED), BST_CHECKED); <br>                } <br> <br>                Static_SetIcon (GetDlgItem (hDlg, IDC_PAGE_ICON), <br>                                ImageList_GetIcon (g_hIconImgs, ICON_DL_OWNER, ILD_NORMAL)); <br>            } <br>            return TRUE; <br> <br>        case WM_NOTIFY: <br>            if (PSN_APPLY == ((LPNMHDR)lParam)-&gt;code) <br>            { <br>                if (BST_CHECKED == Button_GetCheck (GetDlgItem (hDlg, IDC_OWNED))) <br>                { <br>                    pObjInfo-&gt;DL.dwFlags |= DL_OWNED; <br>                    TCHAR achBuffer[64] = { 0 }; <br>                    GetWindowText (GetDlgItem (hDlg, IDC_DL_OWNER), achBuffer, 64); <br>                    if (NULL == achBuffer[0]) <br>                    { <br>                        pObjInfo-&gt;DL.dwFlags &amp;= ~DL_OWNED; <br>                    } <br>                    else <br>                    { <br>                        GetWindowText (GetDlgItem (hDlg, IDC_COMMENTS), pObjInfo-&gt;DL.szComments, sizeof(pObjInfo-&gt;DL.szComments)/sizeof(TCHAR)); <br>                    } <br>                } <br>                else <br>                { <br>                    pObjInfo-&gt;DL.dwFlags &amp;= ~DL_OWNED; <br>                } <br>                if (!(DL_OWNED &amp; pObjInfo-&gt;DL.dwFlags)) <br>                { <br>                    pObjInfo-&gt;DL.dwOwnerID = 0; <br>                    ZeroMemory (pObjInfo-&gt;DL.szOwnerAlias, sizeof(pObjInfo-&gt;DL.szOwnerAlias)); <br>                    ZeroMemory (pObjInfo-&gt;DL.szOwnerName, sizeof(pObjInfo-&gt;DL.szOwnerName)); <br>                    ZeroMemory (pObjInfo-&gt;DL.szComments, sizeof(pObjInfo-&gt;DL.szComments)); <br>                } <br>                return PSNRET_NOERROR; <br>            } <br>            break; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_OWNED : <br>                case IDC_NOT_OWNED : <br>                    if (HIWORD(wParam) == BN_CLICKED) <br>                    { <br>                        SetFocus ((HWND)lParam); <br>                        BOOL fEnabled = (LOWORD(wParam) == IDC_OWNED ? TRUE : FALSE); <br>                        HWND hCtl; <br>                        hCtl = GetDlgItem (hDlg, IDC_DL_OWNER); <br>                        EnableWindow (hCtl, fEnabled); </code></pre>
<p>
</p>
<pre><code>hCtl = GetDlgItem (hDlg, IDC_OWNER_LABEL); <br>                        EnableWindow (hCtl, fEnabled); <br>                        hCtl = GetDlgItem (hDlg, IDC_MODIFY); <br>                        EnableWindow (hCtl, fEnabled); <br>                        hCtl = GetDlgItem (hDlg, IDC_COMMENTS_LABEL); <br>                        EnableWindow (hCtl, fEnabled); <br>                        hCtl = GetDlgItem (hDlg, IDC_COMMENTS); <br>                        EnableWindow (hCtl, fEnabled); <br>                    } <br>                    break; <br> <br>                case IDC_MODIFY : <br>                    if (TRUE == DialogBoxParam (ghInstance, <br>                                                MAKEINTRESOURCE(IDD_ONE_MAILBOX), <br>                                                hDlg, <br>                                                SelectUserDlgProc, <br>                                                (LPARAM)pObjInfo)) <br>                    { <br>                        SetWindowText (GetDlgItem (hDlg, IDC_DL_OWNER), pObjInfo-&gt;DL.szOwnerName); <br>                    } <br>                    break; <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    SelectUserDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK SelectUserDlgProc (HWND    hDlg,  <br>                                 UINT    message,  <br>                                 WPARAM  wParam,  <br>                                 LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                pObjInfo = (POBJECT_INFO)lParam; <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hWaitWnd = CreateDialog (ghInstance, MAKEINTRESOURCE(IDD_DIR_DOWNLOAD_WAIT), hDlg, WaitDlgProc); <br> <br>                long lPipeNum; <br>                HANDLE hPipe; <br>                DWORD dwBytesRead, dwUserID, dwListUserIndex = 0; <br>                if (SERVER_DISTRIBUTION_LIST == pObjInfo-&gt;Type) <br>                { <br>                    dwUserID = pObjInfo-&gt;DL.dwOwnerID; <br>                } <br>                else <br>                { <br>                    dwUserID = pObjInfo-&gt;MB.dwManagerID; <br>                } <br>                AB_ENTRY_INFO abEntry = { 0 }; <br>                HRESULT hResult = S_OK; <br>                int nTabStops[1] = { 1000 }; // Off the screen <br>                TCHAR achPipeName[64]; <br>                 <br>                HWND hListView = GetDlgItem (hDlg, IDC_ALL_USERS); <br>                ListView_SetImageList (hListView, g_hImages, LVSIL_SMALL); <br>                 <br>                RECT rc; <br>                GetClientRect (hListView, &amp;rc); <br>                LV_COLUMN lvc; <br>                lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; <br>                lvc.fmt = LVCFMT_LEFT; <br>                lvc.pszText = TEXT("Full Name"); <br>                lvc.iSubItem = 0; <br>                lvc.cx = 160; <br>                ListView_InsertColumn (hListView, 0, &amp;lvc); <br>                lvc.pszText = TEXT("Alias"); <br>                lvc.iSubItem = 1; <br>                lvc.cx = min (110, (rc.right - rc.left - lvc.cx)); <br>                ListView_InsertColumn (hListView, 1, &amp;lvc); <br> <br>                int i = 0; <br>                LV_ITEM lvi = { 0 }; <br>                lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; <br>                lvi.iImage = IMG_USER_MAILBOX; <br> <br>                RpcTryExcept <br>                { <br>                    hResult = RemoteAdmGetServerMailboxes (&amp;lPipeNum); <br>                    if (!hResult) <br>                    { <br>                        // Construct the download pipe name <br>                        wsprintf (achPipeName, PIPE_NAME_FORMAT, g_szCurrentServer, lPipeNum); <br>                        // Create our endpoint and connect     <br>                        hPipe = CreateFile (achPipeName,  <br>                                            GENERIC_READ, <br>                                            0, <br>                                            NULL, <br>                                            OPEN_EXISTING, <br>                                            0, <br>                                            NULL); <br>                        if (INVALID_HANDLE_VALUE == hPipe) <br>                        { <br>                            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                        } <br>                    } <br>                } <br>                RpcExcept(1) <br>                {         <br>                    // If we got here is because there was an error while call was made <br>                    // or when it was about to be made. <br>                    hResult = RpcExceptionCode(); <br>                    if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>                    { <br>                        hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>                    } <br>                    else <br>                    { <br>                        hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>                    } <br>                } <br>                RpcEndExcept <br>                if (!hResult) <br>                { <br>                     <br>                    do <br>                    { <br>                        // Read from the pipe <br>                        if (!ReadFile (hPipe, &amp;abEntry, sizeof(AB_ENTRY_INFO), &amp;dwBytesRead, NULL)) <br>                        { <br>                            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                            if (HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE)   != hResult &amp;&amp;   // For Windows NT <br>                                HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hResult)     // For Windows 95 <br>                            { <br>                                // There was an error and we can't continue <br>                                TraceResult ("ModifyListDlgProc: Failed to read from the source", hResult); <br>                            } <br>                            else <br>                            { <br>                                // If the pipe was broken, it means the server finished writing <br>                                // to the it, so we are finished reading from it. <br>                                hResult = S_OK; <br>                            } <br>                        } <br>                        else <br>                        { <br>                            lvi.iItem = i; <br>                            lvi.iSubItem = 0; <br>                            lvi.pszText = abEntry.Info.MB.szFullName; <br>                            lvi.lParam = abEntry.Info.MB.dwObjID; <br>                            lvi.iItem = ListView_InsertItem (hListView, &amp;lvi); <br>                            ListView_SetItemText (hListView, lvi.iItem, 1, abEntry.Info.MB.szMailboxName); <br>                            i++; <br>                            if (abEntry.Info.MB.dwObjID == dwUserID) <br>                            { <br>                                dwListUserIndex = abEntry.Info.MB.dwObjID; <br>                            } <br>                        } <br>                    } while (dwBytesRead &amp;&amp; !hResult); <br>                    CloseHandle (hPipe); <br>                    if (0 != dwListUserIndex) <br>                    { <br>                        ListView_SetItemState (hListView,    <br>                                               dwListUserIndex, <br>                                               LVIS_FOCUSED | LVIS_SELECTED, <br>                                               LVIS_FOCUSED | LVIS_SELECTED); <br>                    } <br>                } <br>                DestroyWindow (hWaitWnd); <br>                if (hResult) <br>                { <br>                    ErrorHandler (hDlg, hResult); <br>                    EndDialog (hDlg, -1); <br>                } <br>            } <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_ALL_USERS : <br>                    if (LBN_DBLCLK == HIWORD(wParam)) <br>                    { <br>                        PostMessage (hDlg, WM_COMMAND, IDOK, 0); <br>                    } <br>                    break; <br>                case IDOK : <br>                    { <br>                        TCHAR achName[MAX_STRING_SIZE+1], achAlias[MAX_ALIAS_SIZE+1]; <br>                        DWORD dwUserID; <br>                        HWND hListView= GetDlgItem (hDlg, IDC_ALL_USERS); <br>                         <br>                        LV_ITEM lvi = { 0 }; <br>                        lvi.mask = LVIF_PARAM | LVIF_TEXT; <br>                        lvi.iItem = ListView_GetNextItem (hListView, -1, LVNI_FOCUSED | LVNI_ALL); <br>                        lvi.iSubItem = 0; <br>                        lvi.pszText = achName; <br>                        lvi.cchTextMax = MAX_STRING_SIZE+1; <br>                        if (ListView_GetItem (hListView, &amp;lvi)) <br>                        { <br>                            dwUserID = lvi.lParam; <br>                            lvi.mask = LVIF_TEXT; <br>                            lvi.iSubItem = 1; <br>                            lvi.pszText = achAlias; <br>                            lvi.cchTextMax = MAX_ALIAS_SIZE+1; <br>                            if (FALSE == ListView_GetItem (hListView, &amp;lvi)) <br>                            { <br>                                wParam = IDCANCEL; <br>                            } <br>                        } <br>                        else <br>                        { <br>                            wParam = IDCANCEL; <br>                        } <br>                        if (IDOK == wParam) <br>                        { <br>                            if (SERVER_DISTRIBUTION_LIST == pObjInfo-&gt;Type) <br>                            { <br>                                pObjInfo-&gt;DL.dwOwnerID = dwUserID; <br>                            } <br>                            else <br>                            { <br>                                pObjInfo-&gt;MB.dwManagerID = dwUserID; <br>                            } <br>                            if (SERVER_DISTRIBUTION_LIST == pObjInfo-&gt;Type) <br>                            { <br>                                lstrcpy (pObjInfo-&gt;DL.szOwnerName, achName); <br>                            } <br>                            else <br>                            { <br>                                lstrcpy (pObjInfo-&gt;MB.szManagerName, achName); <br>                            } <br>                            if (SERVER_DISTRIBUTION_LIST == pObjInfo-&gt;Type) <br>                            { <br>                                lstrcpy (pObjInfo-&gt;DL.szOwnerAlias, achAlias); <br>                            } <br>                            else <br>                            { <br>                                lstrcpy (pObjInfo-&gt;MB.szManagerAlias, achAlias); <br>                            } <br>                        } <br>                    } <br>                    // Fall through <br>                case IDCANCEL : <br>                    ListView_SetImageList (GetDlgItem (hDlg, IDC_ALL_USERS), NULL, LVSIL_SMALL); <br>                    EndDialog (hDlg, (LOWORD(wParam) == IDOK ? TRUE : FALSE)); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WaitDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK WaitDlgProc (HWND    hDlg,  <br>                           UINT    message,  <br>                           WPARAM  wParam,  <br>                           LPARAM  lParam) <br>{ <br>    if (WM_INITDIALOG == message) <br>    { <br>        CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>        Static_SetIcon(GetDlgItem (hDlg, IDC_STOPWATCH), GetAnimatedTimerCursor()); <br>        return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ModifyListDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK ModifyListDlgProc (HWND    hDlg,  <br>                                 UINT    message,  <br>                                 WPARAM  wParam,  <br>                                 LPARAM  lParam) <br>{ <br>    static POBJECT_INFO pObjInfo; <br>    static HWND hAllUsers, hMembers; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                pObjInfo = (POBJECT_INFO)lParam; <br>                CTL3D_Subclass(g_pctl3d, hDlg, CTL3D_ALL); <br>                HWND hWaitWnd = CreateDialog (ghInstance, MAKEINTRESOURCE(IDD_DIR_DOWNLOAD_WAIT), hDlg, WaitDlgProc); <br> <br>                long lPipeNum; <br>                TCHAR achBuffer[128]; <br>                HANDLE hPipe; <br>                DWORD dwBytesRead; <br>                AB_ENTRY_INFO abEntry = { 0 }; <br>                HRESULT hResult = S_OK; <br>                int nTabStops[1]; <br>                nTabStops[0] = 1000; // Off the screen <br>                 <br>                hAllUsers = GetDlgItem (hDlg, IDC_ALL_USERS); <br>                hMembers = GetDlgItem (hDlg, IDC_MEMBERS); <br>                 <br>                ListBox_SetTabStops (hAllUsers, sizeof(nTabStops)/sizeof(int), nTabStops); <br>                ListBox_SetTabStops (hMembers, sizeof(nTabStops)/sizeof(int), nTabStops); <br>                RpcTryExcept <br>                { <br>                    hResult = RemoteAdmGetGALDirectory (0, &amp;lPipeNum); <br>                    if (!hResult) <br>                    { <br>                        // Construct the download pipe name <br>                        wsprintf (achBuffer, PIPE_NAME_FORMAT, g_szCurrentServer, lPipeNum); <br>                        // Create our endpoint and connect     <br>                        hPipe = CreateFile (achBuffer,  <br>                                            GENERIC_READ, <br>                                            0, <br>                                            NULL, <br>                                            OPEN_EXISTING, <br>                                            0, <br>                                            NULL); <br>                        if (INVALID_HANDLE_VALUE == hPipe) <br>                        { <br>                            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                        } <br>                    } <br>                } <br>                RpcExcept(1) <br>                {         <br>                    // If we got here is because there was an error while call was made <br>                    // or when it was about to be made. <br>                    hResult = RpcExceptionCode(); <br>                    if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>                    { <br>                        hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>                    } <br>                    else <br>                    { <br>                        hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>                    } <br>                } <br>                RpcEndExcept <br>                if (!hResult) <br>                { <br>                    do <br>                    { <br>                         <br>                        // Read from the pipe <br>                        if (!ReadFile (hPipe, &amp;abEntry, sizeof(AB_ENTRY_INFO), &amp;dwBytesRead, NULL)) <br>                        { <br>                            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                            if (HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE)   != hResult &amp;&amp;   // For Windows NT <br>                                HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hResult)     // For Windows 95 <br>                            { <br>                                // There was an error and we can't continue <br>                                TraceResult ("ModifyListDlgProc: Failed to read from the source", hResult); <br>                            } <br>                            else <br>                            { <br>                                // If the pipe was broken, it means the server finished writing <br>                                // to the it, so we are finished reading from it. <br>                                hResult = S_OK; <br>                            } <br>                        } <br>                        else <br>                        { <br>                            switch (abEntry.Type) <br>                            { <br>                                case GATEWAY_RECIPIENT : <br>                                case SERVER_USER_MAILBOX : <br>                                    if (abEntry.Info.MB.dwObjID != pObjInfo-&gt;MB.dwObjID) <br>                                    { <br>                                        wsprintf (achBuffer, <br>                                                  TEXT("%s\t%s\t%d\t%d"), <br>                                                  abEntry.Info.MB.szFullName, <br>                                                  abEntry.Info.MB.szMailboxName, <br>                                                  abEntry.Info.MB.dwObjID, <br>                                                  abEntry.Type); <br>                                        ListBox_AddString (hAllUsers, achBuffer); <br>                                    } <br>                                    break; <br>                                case SERVER_DISTRIBUTION_LIST : <br>                                    if (abEntry.Info.DL.dwObjID != pObjInfo-&gt;DL.dwObjID) <br>                                    { <br>                                        wsprintf (achBuffer, <br>                                                  TEXT("%s\t%s\t%d\t%d"), <br>                                                  abEntry.Info.DL.szDLFullName, <br>                                                  abEntry.Info.DL.szDLAlias, <br>                                                  abEntry.Info.DL.dwObjID, <br>                                                  abEntry.Type); <br>                                        ListBox_AddString (hAllUsers, achBuffer); <br>                                    } <br>                                    break; <br>                            } <br>                        } <br>                    } while (dwBytesRead &amp;&amp; !hResult); <br>                    CloseHandle (hPipe); <br>                } <br>                if (!hResult) <br>                { <br>                    WINDS_AB_OBJTYPE Type; <br>                    DLM_LIST * pNode = pObjInfo-&gt;pMembers; <br>                    while (pNode &amp;&amp; pNode-&gt;Info.szMemberAlias[0]) <br>                    { <br>                        Type = (WINDS_AB_OBJTYPE)pNode-&gt;Info.dwMemberType; <br>                        wsprintf (achBuffer, <br>                                  TEXT("%s\t%s\t%d\t%d"), <br>                                  pNode-&gt;Info.szMemberName, <br>                                  pNode-&gt;Info.szMemberAlias, <br>                                  pNode-&gt;Info.dwMemberID, <br>                                  pNode-&gt;Info.dwMemberType); <br>                        ListBox_AddString (hMembers, achBuffer); <br>                        pNode = pNode-&gt;pNext; <br>                    } <br>                } <br>                DestroyWindow (hWaitWnd); <br>                if (hResult) <br>                { <br>                    ErrorHandler (hDlg, hResult); <br>                    EndDialog (hDlg, -1); <br>                } <br>            } <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_REMOVE_ALL : <br>                    pObjInfo-&gt;dwData = TRUE; <br>                    ListBox_ResetContent (hMembers); <br>                    break; <br>                 <br>                case IDC_MEMBERS : <br>                    if (LBN_DBLCLK != HIWORD(wParam)) <br>                    { <br>                        break; <br>                    } <br>                    // else fall through <br>                case IDC_REMOVE_USER : <br>                    { <br>                        int nIndex = ListBox_GetCurSel (hMembers); <br>                        if (LB_ERR != nIndex) <br>                        { <br>                            ListBox_DeleteString (hMembers, nIndex); <br>                            pObjInfo-&gt;dwData = TRUE; <br>                        } <br>                    } <br>                    break; <br> <br>                case IDC_ALL_USERS : <br>                    if (LBN_DBLCLK != HIWORD(wParam)) <br>                    { <br>                        break; <br>                    } <br>                    // else fall through <br>                case IDC_ADD_USER : <br>                    { <br>                        TCHAR szBuffer[128]; <br>                        int iUsers = ListBox_GetSelCount (hAllUsers); <br>                        if (iUsers == LB_ERR) // Nothins is selected <br>                        { <br>                            break; <br>                        } <br>                        int *piList = (int *)HeapAlloc (ghMemHeap, 0, (DWORD)(iUsers * sizeof(int))); <br>                        if (NULL == piList) // Low system resources <br>                        { <br>                            ErrorHandler (hDlg, E_OUTOFMEMORY); <br>                            break; <br>                        }  <br>                        ListBox_GetSelItems (hAllUsers, iUsers, piList); <br> <br>                        for (int i=0; i&lt;iUsers; i++) <br>                        { <br>                            ListBox_GetText (hAllUsers, piList[i], szBuffer); <br>                            if (LB_ERR == ListBox_FindStringExact (hMembers, -1, szBuffer)) <br>                            { <br>                                ListBox_AddString (hMembers, szBuffer); <br>                            } <br>                            ListBox_SetSel (hMembers, FALSE, i); <br>                        } <br>                        pObjInfo-&gt;dwData = TRUE; <br>                        HeapFree (ghMemHeap, 0, piList); <br>                    } <br>                    break; <br> <br>                case IDOK : <br>                    if (pObjInfo-&gt;dwData) // Means that something was changed <br>                    { <br>                        TCHAR achBuffer[128]; <br>                        DLM_INFO Info = { 0 }; <br>                        TCHAR * szSubStr; <br>                        FreeDLMList ((DLM_LIST*)pObjInfo-&gt;DL.pMembers); <br>                        DLM_LIST * pMemberList = (DLM_LIST*)pObjInfo-&gt;DL.pMembers; <br>                        int nCount = ListBox_GetCount (hMembers); <br>                        for (int i=0; i&lt;nCount; i++) <br>                        { <br>                            if (LB_ERR == ListBox_GetText (hMembers, i, achBuffer)) <br>                            { <br>                                continue; <br>                            } <br>                            strtok (achBuffer, "\t"); <br>                            lstrcpy ((LPSTR)Info.szMemberName, achBuffer); <br> <br>                            szSubStr = strtok (NULL, "\t"); <br>                            lstrcpy ((LPSTR)Info.szMemberAlias, szSubStr); <br>                             <br>                            szSubStr = strtok (NULL, "\t"); <br>                            Info.dwMemberID = (DWORD)atol (szSubStr); <br> <br>                            szSubStr = strtok (NULL, "\t"); <br>                            Info.dwMemberType = (DWORD)atol (szSubStr); <br> <br>                            if (0 == i) <br>                            { <br>                                pMemberList-&gt;Info = Info; <br>                            } <br>                            else <br>                            { <br>                                InsertNewDLMNode (Info, (DLM_XMIT_LIST *)pMemberList); <br>                            } <br>                        } <br>                    } <br>                    // Fall through <br>                case IDCANCEL : <br>                    EndDialog (hDlg, (LOWORD(wParam) == IDOK ? TRUE : FALSE)); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>// End of file for ADMDLIST.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
