<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EVNTEXT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2101"></a>EVNTEXT.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name <br>//      EVNTEXT.CPP  <br>// <br>//  Description <br>//  This is an implementation of a message event extension example.  The <br>//  extension calculates the checksum of a message that is submitted by <br>//  The Exchange client and then signs the message with the checksum result <br>//  to be used upon reading.  The sample includes a Tools Options property <br>//  page to enable or disable signing. <br>// <br>//      IExchExt interface methods: <br>//          MyExchExt::QueryInterface() <br>//          MyExchExt::AddRef() <br>//          MyExchExt::Release() <br>// <br>//          MyExchExt::Install() <br>// <br>//      IExchExtPropertySheets interface methods: <br>//          IExchExtPropertySheets::QueryInterface() <br>//          IExchExtPropertySheets::AddRef() <br>//          IExchExtPropertySheets::Release() <br>// <br>//          IExchExtPropertySheets::GetMaxPageCount() <br>//          IExchExtPropertySheets::GetPages() <br>//          IExchExtPropertySheets::FreePages() <br>// <br>//      IExchExtMessageEvents interface methods: <br>//          IExchExtMessageEvents::QueryInterface() <br>//          IExchExtMessageEvents::AddRef() <br>//          IExchExtMessageEvents::Release() <br>// <br>//          IExchExtMessageEvents::OnCheckNames() <br>//          IExchExtMessageEvents::OnCheckNamesComplete() <br>//          IExchExtMessageEvents::OnRead() <br>//          IExchExtMessageEvents::OnReadComplete() <br>//          IExchExtMessageEvents::OnSubmit() <br>//          IExchExtMessageEvents::OnSubmitComplete() <br>//          IExchExtMessageEvents::OnWrite() <br>//          IExchExtMessageEvents::OnWriteComplete() <br>// <br>//  Author <br>//      Gary Peluso <br>// <br>//  Revision: 1.01 <br>// <br>//  History <br>//  9/21/95 - fixed "signature" property sheet bug (two sheets incorrectly shown) <br>//  9/21/95 - changed QI for MyExchExtMessageEvents and MyExchExtPropertySheets <br>//               to return pointer to MyExchExt when IID_IUNKNOWN is requested <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1992-1995 Microsoft Corporation. All rights reserved. <br>// <br>#define INITGUID <br>#define USES_IID_IExchExt <br>#define USES_IID_IExchExtAdvancedCriteria <br>#define USES_IID_IExchExtAttachedFileEvents <br>#define USES_IID_IExchExtCommands <br>#define USES_IID_IExchExtMessageEvents <br>#define USES_IID_IExchExtPropertySheets <br>#define USES_IID_IExchExtSessionEvents <br>#define USES_IID_IExchExtUserEvents <br>#define USES_IID_IMessage <br>#define USES_PS_MAPI <br>#define USES_PS_PUBLIC_STRINGS <br> <br>#include "EVNTEXT.H" <br> <br>//#include &lt;INITGUID.H&gt; <br>#include &lt;MAPIGUID.H&gt; <br> <br>     <br>/////////////////////////////////////////////////////////////////////////////// <br>//    global data that supports extension functionality <br>BOOL bSignatureOn = TRUE; <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    global data for DLL <br>static HINSTANCE ghInstDLL = NULL;  // instance handle of DLL <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FUNCTION: DLLMain() <br>// <br>//    Purpose <br>//    Do initilization processesing <br>// <br>//    Return Value <br>//    TRUE - DLL successfully loads and LoadLibrary will succeed. <br>//    FALSE - will cause an Exchange error message saying it cannot locate <br>//            the extension DLL. <br>// <br>//    Comments <br>//    We only need to get a copy of the DLL's HINSTANCE. <br>// <br>BOOL WINAPI DllMain( <br>    HINSTANCE  hinstDLL, <br>    DWORD  fdwReason,    <br>    LPVOID  lpvReserved)  <br>{ <br> if (DLL_PROCESS_ATTACH == fdwReason) <br> { <br>    ghInstDLL = hinstDLL; <br> <br> } <br> return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FUNCTION: ExchEntryPoint <br>// <br>//    Parameters - none <br>// <br>//    Purpose <br>//    The entry point called by Exchange. <br>// <br>//    Return Value <br>//    Pointer to Exchange Extension (IExchExt) interface <br>// <br>//    Comments <br>//    Exchange Client calls this for each context entry.   <br>// <br> <br>LPEXCHEXT CALLBACK ExchEntryPoint(void) <br>{ <br>     return new MyExchExt; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::MyExchExt() <br>// <br>//    Parameters - none <br>// <br>//    Purpose <br>//    Comstructor.  Called during instantiation of MyExchExt object. <br>// <br>// <br> <br>MyExchExt::MyExchExt() <br>{ <br>  m_cRef = 1;  <br> <br>  m_pExchExtPropertySheets = new MyExchExtPropertySheets(this); <br>  m_pExchExtMessageEvents = new MyExchExtMessageEvents(this); <br> <br>}; <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  IExchExt virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::Release() <br>// <br>//    Parameters - none <br>// <br>//    Purpose <br>//    Frees memory when interface is not referenced any more <br>// <br>//    Return value <br>//    reference count of interface <br>// <br> <br>STDMETHODIMP_(ULONG) MyExchExt::Release()  <br>{  <br> ULONG ulCount = --m_cRef; <br>                          <br> if (!ulCount)  <br> {  <br>  delete this; <br> } <br> <br>return ulCount; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::QueryInterface() <br>// <br>//    Parameters <br>//    riid   -- Interface ID. <br>//    ppvObj -- address of interface object pointer. <br>// <br>//    Purpose <br>//    Returns a pointer to an interface object that is requested by ID. <br>// <br>//    Comments <br>//    The interfaces are requested everytime a new context is entered.  The  <br>//    IID_IExchExt* interfaces are ignored if not specified in the Exchange <br>//    extensions registry. <br>// <br>//    If an interface pointer is returned for more than one context, that <br>//    interface is used by the client for each of those contexts.  Check the <br>//    current context to verify if it is appropriate to pass back an interface <br>//    pointer. <br>//     <br>//    Return Value - none <br>// <br> <br>STDMETHODIMP MyExchExt::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)           <br>{ <br>    HRESULT hResult = S_OK; <br> <br>    *ppvObj = NULL; <br> <br>    if (( IID_IUnknown == riid) || ( IID_IExchExt == riid) ) <br>    { <br>        *ppvObj = (LPUNKNOWN)this; <br>    } <br>    else if (IID_IExchExtPropertySheets == riid) <br>    { <br>     // if we are in the read or send context, do not return <br>     // propertysheet interface <br>        if ( (m_context == EECONTEXT_SENDNOTEMESSAGE)   || <br>             (m_context == EECONTEXT_SENDPOSTMESSAGE)   || <br>             (m_context == EECONTEXT_SENDRESENDMESSAGE) || <br>             (m_context == EECONTEXT_READNOTEMESSAGE)   || <br>             (m_context == EECONTEXT_READPOSTMESSAGE)   || <br>             (m_context == EECONTEXT_READREPORTMESSAGE) ) <br>                 return E_NOINTERFACE; <br> <br>     // otherwise return the interface <br>        *ppvObj = (LPUNKNOWN) m_pExchExtPropertySheets; <br>    } <br>    else if (IID_IExchExtMessageEvents == riid) <br>    { <br>        *ppvObj = (LPUNKNOWN) m_pExchExtMessageEvents; <br>    } <br>    else <br>        hResult = E_NOINTERFACE; <br> <br>    if (NULL != *ppvObj) <br>        ((LPUNKNOWN)*ppvObj)-&gt;AddRef(); <br> <br>    return hResult; <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::Install() <br>// <br>//    Parameters <br>//    peecb     -- pointer to Exchange Extension callback function <br>//    eecontext -- context code at time of being called. <br>// <br>//    Purpose <br>//    Called once for each new context that is entered. <br>// <br>//    Return Value <br>//    S_OK - the installation succeeded for the context <br>//    S_FALSE - deny the installation fo the extension for the context <br>// <br>STDMETHODIMP MyExchExt::Install(LPEXCHEXTCALLBACK peecb, ULONG eecontext, ULONG ulFlags) <br>{ <br>    ULONG ulBuildVersion; <br>    HRESULT hr; <br> <br>    m_context = eecontext; <br>        <br>    // make sure this is the right version  <br>    peecb-&gt;GetVersion(&amp;ulBuildVersion, EECBGV_GETBUILDVERSION); <br>    if (EECBGV_BUILDVERSION_MAJOR != (ulBuildVersion &amp;  <br>                                      EECBGV_BUILDVERSION_MAJOR_MASK)) <br>        return S_FALSE; <br> <br> <br>    switch (eecontext) <br>    { <br>     case EECONTEXT_PROPERTYSHEETS: <br>     case EECONTEXT_SENDNOTEMESSAGE: <br>     case EECONTEXT_SENDPOSTMESSAGE: <br>     case EECONTEXT_SENDRESENDMESSAGE: <br>     case EECONTEXT_READNOTEMESSAGE: <br>     case EECONTEXT_READPOSTMESSAGE: <br>     case EECONTEXT_READREPORTMESSAGE: <br>        hr = S_OK; <br>        break; <br> <br>     default: <br>        hr = S_FALSE; <br>        break; <br>    } <br> <br> <br>    return hr; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  IExchExtPropertySheets virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::QueryInterface() <br>// <br>//    Parameters <br>//    riid   -- Interface ID. <br>//    ppvObj -- address of interface object pointer. <br>// <br>//    Purpose <br>//    Return interface object upon request <br>//     <br>//    Return Value - none <br>// <br>//    Comments <br>//    Currently the Exchange client does not call QueryInterface from any object <br>//    except for IExchExt.  This is implemented in case features are added to <br>//    Exchange to require QueryInterface from any object.  Also, as a "rule of <br>//    OLE COM" this is the proper implementation of QueryInterface. <br>// <br> <br>STDMETHODIMP MyExchExtPropertySheets::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)           <br>{    <br> <br>    *ppvObj = NULL; <br>    if (riid == IID_IExchExtPropertySheets) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        // Increase usage count of this object <br>        AddRef(); <br>        return S_OK; <br>    } <br>    if (riid == IID_IUnknown) <br>    { <br>        *ppvObj = (LPVOID)m_pExchExt;  // return parent interface <br>        m_pExchExt-&gt;AddRef(); <br>        return S_OK; <br>    } <br> <br>    return E_NOINTERFACE; <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::GetMaxPageCount() <br>// <br>//    Parameters <br>//    ulFlags -- a bitmask indicating what type of property sheet is being  <br>//               displayed <br>// <br>//    Purpose <br>//    Returns the number of property pages which are to be added. <br>// <br>//    Return Value - maximum number of custom pages for the property sheet <br>// <br>//    Exchange calls this to know how many PROPSHEETPAGE buffers it needs <br>//    to allocate. <br>// <br> <br>STDMETHODIMP_ (ULONG) MyExchExtPropertySheets::GetMaxPageCount(ULONG ulFlags)           <br>{ <br> ULONG ulNumExtSheets; <br> <br>    switch (ulFlags) <br>    { <br>     // ignore these objects. <br>     case EEPS_FOLDER: <br>     case EEPS_STORE: <br>     case EEPS_MESSAGE: <br>        ulNumExtSheets = 0; <br>        break; <br>          <br>     case EEPS_TOOLSOPTIONS: <br>        ulNumExtSheets = 1;   // adding one propery page <br>        break; <br> <br>     default: <br>        ulNumExtSheets = 0; <br>        break; <br>    } <br> <br>    return ulNumExtSheets;   <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::GetPages() <br>// <br>//    Parameters <br>//    peecb   -- pointer to Exchange callback interface <br>//    ulFlags -- a bitmask indicating what type of property sheet is being  <br>//               displayed <br>//    ppsp    -- output parm pointing to pointer to list of property sheets <br>//    pcpsp   -- output parm pointing to buffer contaiing number of property <br>//               sheets actually used. <br>// <br>//    Purpose <br>//    Fills the PROPSHEETPAGE members for the custom property page. <br>// <br>//    Return Value <br>//    S_FALSE - do not add a new page <br>//    S_OK - use the ppsp information for new pages. <br>// <br>//    Comments <br>//    Exchange calls this method to gather information for any custom <br>//    property pages to be added to the sheet.  Here we are only adding <br>//    one.  ppsp may be an array of PROPSHEETPAGE structures to allow you <br>//    to all multiple property pages. <br>// <br> <br>STDMETHODIMP MyExchExtPropertySheets::GetPages(LPEXCHEXTCALLBACK peecb, <br>                      ULONG ulFlags, LPPROPSHEETPAGE ppsp, ULONG FAR * pcpsp) <br>{ <br> LPMDB pMDB = NULL; <br> LPMESSAGE pItem = NULL; <br> <br>    *pcpsp = 0; <br> <br> <br>    // fill out members for the property page <br>    ppsp[0].dwSize = sizeof (PROPSHEETPAGE); <br>    ppsp[0].dwFlags = PSP_DEFAULT | PSP_HASHELP; <br>    ppsp[0].hInstance = ghInstDLL; <br>    ppsp[0].pszTemplate = MAKEINTRESOURCE(IDD_SIGNATURE); <br>    ppsp[0].hIcon = NULL;     // not used in this sample <br>    ppsp[0].pszTitle = NULL;  // not used in this sample <br>    ppsp[0].pfnDlgProc = (DLGPROC)SignatureOptionsDlgProc; <br>    ppsp[0].lParam = 0;      <br>    ppsp[0].pfnCallback = NULL; <br>    ppsp[0].pcRefParent = NULL; // not used in this sample <br> <br>    *pcpsp = 1; <br> <br>    return S_OK; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::FreePages() <br>// <br>//    Parameters <br>//    ppsp -- pointer to a pointer to the first of a list of property pages <br>//    cpsp -- number of custom property pages in the list <br>//    ulFlags -- type of property page <br>//     <br>//    Purpose <br>//    Free any memory associated to the property sheet. <br>// <br>//    Return Value - none <br>// <br>//    Comments <br>//    No parameters are used in this example but the function is used as <br>//    a signal that the property sheet is going away and so memory may <br>//    be freed. <br>// <br>                          <br>STDMETHODIMP_ (VOID) MyExchExtPropertySheets::FreePages(LPPROPSHEETPAGE ppsp, ULONG ulFlags,  <br>                                        ULONG cpsp)           <br>{ <br>   // not used in this sample <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  IExchExtMessageEvents virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::QueryInterface() <br>// <br>//    Parameters <br>//    riid   -- Interface ID. <br>//    ppvObj -- address of interface object pointer. <br>// <br>//    Purpose <br>//    Return interface object upon request <br>//     <br>//    Return Value - none <br>// <br>//    Comments <br>//    Currently the Exchange client does not call QueryInterface from any object <br>//    except for IExchExt.  This is implemented in case features are added to <br>//    Exchange to require QueryInterface from any object.  Also, as a "rule of <br>//    OLE COM" this is the proper implementation of QueryInterface. <br>// <br> <br>STDMETHODIMP MyExchExtMessageEvents::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)           <br>{    <br> <br>    *ppvObj = NULL; <br>    if (riid == IID_IExchExtMessageEvents) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        // Increase usage count of this object <br>        AddRef(); <br>        return S_OK; <br>    } <br>    if (riid == IID_IUnknown) <br>    { <br>        *ppvObj = (LPVOID)m_pExchExt;  // return parent interface <br>        m_pExchExt-&gt;AddRef(); <br>        return S_OK; <br>    } <br>    return E_NOINTERFACE; <br> <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::OnRead() <br>// <br>//    Parameters <br>//    lpeecb -- pointer to IExchExtCallback interface <br>// <br>//    Purpose <br>//    To extend or inhibit Exchange when displaying the send or read note form. <br>//     <br>//    Return Value <br>//    S_OK signals Exchange to not continue calling extensions <br>//    S_FALSE signals Exchange to continue calling extensions <br>//    Other MAPI Code errors will abort the send or read note form. <br>// <br>// <br> <br>STDMETHODIMP MyExchExtMessageEvents::OnRead(LPEXCHEXTCALLBACK lpeecb) <br>{ <br>  HRESULT hr; <br>  LPMESSAGE pMessage = NULL; <br>  LPMDB pMDB = NULL; <br>  ULONG ulCheckSum = 0; <br>  LPSPropTagArray pNamedPropTags = NULL; <br>  LPSPropValue pPropValues = NULL; <br>  HWND hWnd; <br>  HCURSOR hOldCursor = NULL; <br>  MAPINAMEID NamedID; <br>  LPMAPINAMEID pnmid = &amp;NamedID; <br> <br> <br>  m_hrOnReadComplete = S_FALSE; // tell OnReadComplete to show its dialog <br>   <br>  if (!bSignatureOn)      // user has turned off signatures <br>  { <br>    goto error_return;    // return and do nothing <br>  } <br> <br> <br>  hr = lpeecb-&gt;GetObject(&amp;pMDB, (LPMAPIPROP *)&amp;pMessage); <br>  if (FAILED(hr)) <br>  { <br>    goto error_return; <br>  } <br> <br> <br>  lpeecb-&gt;GetWindow(&amp;hWnd); <br>  hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>  // check to see if MsgChecksum exists <br>  // use a named property for the message body checksum <br>  NamedID.lpguid = (LPGUID) &amp;PS_PUBLIC_STRINGS; <br>  NamedID.ulKind = MNID_STRING; <br>  NamedID.Kind.lpwstrName = L"MsgChecksum"; <br> <br>  hr = pMessage-&gt;GetIDsFromNames(1, &amp;pnmid, 0, &amp;pNamedPropTags); <br>  //here we can get away with checking for hr!=0, because we retrieve only one <br>  //PropTag. If more then one PropTag requested and GetIDsFromName can't find <br>  // some of them, a warning MAPI_W_ERRORS_RETURNED is returned and each PropTag <br>  //has to be checked separatly. (See Docs for details). <br>  if (hr)     // likely the message is not signed <br>  { <br>    goto error_return; <br>  } <br> <br>  pNamedPropTags-&gt;aulPropTag[0] = PROP_TAG(PT_LONG, PROP_ID(pNamedPropTags-&gt;aulPropTag[0])); <br> <br>  hr = HrGetOneProp(pMessage, pNamedPropTags-&gt;aulPropTag[0], &amp;pPropValues); <br>  if (hr) <br>  { <br>    goto error_return; <br>  } <br> <br>  // we have a signed message, continue with checking validity through checksum <br>  hr = CalcULONGCheckSum(pMessage, &amp;ulCheckSum); <br>  if (FAILED(hr)) <br>  { <br>    ErrorMessageBox(hWnd, hr, "OnRead",  <br>        "An error occured while calculating\n" <br>        "the message body checksum."); <br>    goto error_return; <br>  } <br> <br>  if (pPropValues[0].Value.ul == ulCheckSum) <br>  { <br>      MessageBox(hWnd, "Signed Message Verified.\n" <br>                       "Message has authentic contents.", "Event Extension", MB_OK); <br>  } <br>  else <br>  { <br>   int nRet = MessageBox(hWnd, "Signed Message was altered.\n" <br>                       "Message may not have authentic contents.\n" <br>                       "Do you wish to view the message anyway?", "Event Extension", MB_YESNO); <br>    <br>   if (nRet == IDNO) <br>   // this will tell OnReadComplete to not display the read note UI at all. <br>      m_hrOnReadComplete = MAPI_E_CALL_FAILED; <br>  } <br> <br>  error_return: <br> <br>  hr = S_FALSE; <br>   <br>  UlRelease(pMDB); <br> <br>  UlRelease(pMessage); <br> <br>  MAPIFreeBuffer(pNamedPropTags); <br> <br>  MAPIFreeBuffer(pPropValues); <br> <br>  if(hOldCursor) <br>      SetCursor(hOldCursor); <br> <br>  return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::OnReadComplete() <br>// <br>//    Parameters <br>//    lpeecb -- pointer to IExchExtCallback interface <br>// <br>//    Purpose <br>//    To do processing after message has been read. <br>//     <br>//    Return Value <br>//    S_OK signals Exchange to not continue calling extensions <br>//    S_FALSE signals Exchange to continue calling extensions <br>//    Some MAPI Code error indicates a problem and will not display the send <br>//    or read note form. <br>// <br>//    Comments. <br>//    If an error code, such as MAPI_E_CALL_FAILED, is returned, Exchange will <br>//    call OnReadComplete again with the ulFlags parameter set to  <br>//    EEME_COMPLETE_FAILED.  Returning the error code again will cause Exchange <br>//    to not display the UI. <br>// <br> <br>STDMETHODIMP MyExchExtMessageEvents::OnReadComplete(LPEXCHEXTCALLBACK lpeecb, ULONG ulFlags) <br>{ <br> <br>  return m_hrOnReadComplete; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::OnWrite() <br>// <br>//    Parameters <br>//    lpeecb -- pointer to IExchExtCallback interface <br>// <br>//    Purpose <br>//    This method is called when a message is about to be written.  The message <br>//    only has default properties at this point.  It does not contain  <br>//    properties which the user has added by way of recipients, subject, <br>//    message text, or attachments. <br>//    This method is called when the user Sends or Saves a message <br>//     <br>//    Return Value <br>//    S_OK signals Exchange to not continue calling extensions <br>//    S_FALSE signals Exchange to continue calling extensions <br>// <br>// <br> <br>STDMETHODIMP MyExchExtMessageEvents::OnWrite(LPEXCHEXTCALLBACK lpeecb) <br>{ <br>  HRESULT hr; <br> <br>  hr = S_FALSE;  <br> <br>  return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::OnWriteComplete() <br>// <br>//    Parameters <br>//    lpeecb -- pointer to IExchExtCallback interface <br>// <br>//    Purpose <br>//    This method is called when the data (recipients, attachments, body,  <br>//    subject, etc.) has been written to the message.  This sample will <br>//    calculate the checksum on the PR_BODY property. <br>//     <br>//    Return Value <br>//    S_OK signals Exchange to not continue calling extensions <br>//    S_FALSE signals Exchange to continue calling extensions <br>// <br>// <br> <br>STDMETHODIMP MyExchExtMessageEvents::OnWriteComplete(LPEXCHEXTCALLBACK lpeecb, ULONG ulFlags) <br>{ <br>  HRESULT hr; <br>  LPMESSAGE pMessage = NULL; <br>  LPMDB pMDB = NULL; <br>  ULONG ulCheckSum = 0; <br>  SPropValue valChksumProp; <br>  LPSPropTagArray pNamedPropTags = NULL; <br>  HWND hWnd; <br>  HCURSOR hOldCursor; <br> <br>  MAPINAMEID NamedID; <br>   <br>  LPMAPINAMEID pnmid = &amp;NamedID; <br>                      <br>  if (!bSignatureOn)      // user has turned off signatures <br>  { <br>    return S_FALSE;    // return and do nothing <br>  } <br> <br>  if (!m_bInSubmitState)    // means user is just "saving the message" <br>  { <br>    return S_FALSE; <br>  } <br> <br>  hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br> <br>  hr = lpeecb-&gt;GetObject(&amp;pMDB, (LPMAPIPROP *)&amp;pMessage); <br>  if (FAILED(hr)) <br>  { <br>    goto error_return; <br>  } <br> <br>  hr = CalcULONGCheckSum(pMessage, &amp;ulCheckSum); <br>  if (FAILED(hr)) <br>  { <br>    lpeecb-&gt;GetWindow(&amp;hWnd); <br> <br>    ErrorMessageBox(hWnd, hr, "OnWriteComplete",  <br>        "An error occured while calculating\n" <br>        "the message body checksum."); <br>    goto error_return; <br>  } <br> <br>  // use a named property for the message body checksum <br>  NamedID.lpguid = (LPGUID) &amp;PS_PUBLIC_STRINGS; <br>  NamedID.ulKind = MNID_STRING; <br>  NamedID.Kind.lpwstrName = L"MsgChecksum"; <br> <br>  hr = pMessage-&gt;GetIDsFromNames(1, &amp;pnmid, MAPI_CREATE, &amp;pNamedPropTags); <br>  //here we can get away with checking for hr!=0, because we retrieve only one <br>  //PropTag. If more then one PropTag requested and GetIDsFromName can't find <br>  // some of them, a warning MAPI_W_ERRORS_RETURNED is returned and each PropTag <br>  //has to be checked separatly. (See Docs for details). <br>  if(hr) <br>  { <br>   goto error_return; <br>  } <br> <br>  valChksumProp.ulPropTag = PROP_TAG(PT_LONG, PROP_ID(pNamedPropTags-&gt;aulPropTag[0])); <br>  valChksumProp.dwAlignPad = 0L; <br>  valChksumProp.Value.ul = ulCheckSum; <br> <br>  hr = HrSetOneProp(pMessage, &amp;valChksumProp); <br>  if (hr) <br>  { <br>   goto error_return; <br>  } <br> <br> <br>  // everything succeeded.  return S_FALSE to tell Exchange to continue calling <br>  // extensions. <br>  hr = S_FALSE;  <br> <br>  error_return: <br> <br>   <br>  UlRelease(pMDB); <br> <br>  UlRelease(pMessage); <br> <br>  MAPIFreeBuffer(pNamedPropTags); <br> <br> <br>  SetCursor(hOldCursor); <br> <br>  return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::OnCheckNames() <br>// <br>//    Parameters <br>//    lpeecb -- pointer to IExchExtCallback interface <br>// <br>//    Purpose <br>//    Called when user selects the Check Names button and just before message <br>//    is submitted to MAPI. <br>//     <br>//    Return Value <br>//    S_OK signals Exchange to not continue calling extensions <br>//    S_FALSE signals Exchange to continue calling extensions <br>// <br> <br>STDMETHODIMP MyExchExtMessageEvents::OnCheckNames(LPEXCHEXTCALLBACK lpeecb) <br>{ <br>  // Not used by the sample. <br>  return S_FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::OnCheckNamesComplete() <br>// <br>//    Parameters <br>//    lpeecb -- pointer to IExchExtCallback interface <br>// <br>//    Purpose <br>//    Called after exchange has completed resolving names in the message <br>//    recipients table. <br>//     <br>//    Return Value <br>//    S_OK signals Exchange to not continue calling extensions <br>//    S_FALSE signals Exchange to continue calling extensions <br>// <br> <br>STDMETHODIMP MyExchExtMessageEvents::OnCheckNamesComplete(LPEXCHEXTCALLBACK lpeecb, ULONG ulFlags) <br>{ <br>  // Not used by the sample <br>  return S_FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::OnSubmit() <br>// <br>//    Parameters <br>//    lpeecb -- pointer to IExchExtCallback interface <br>// <br>//    Purpose <br>//    Called before message data has been written and is <br>//    is submitted to MAPI. <br>//     <br>//    Return Value <br>//    S_OK signals Exchange to not continue calling extensions <br>//    S_FALSE signals Exchange to continue calling extensions <br>// <br>//    Set a member function to show that submit has been called <br>//    to indicate to OnWriteComplete that the user has hit the <br>//    Send button and is not just saving the message. <br>// <br> <br>STDMETHODIMP MyExchExtMessageEvents::OnSubmit(LPEXCHEXTCALLBACK lpeecb) <br>{ <br>  HRESULT hr; <br> <br>  hr = S_FALSE;    <br> <br>  m_bInSubmitState = TRUE;  // submit is called <br> <br> <br>  return hr; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtMessageEvents::OnSubmitComplete() <br>// <br>//    Parameters <br>//    lpeecb -- pointer to IExchExtCallback interface <br>// <br>//    Purpose <br>//    Called after message has been submitted to MAPI. <br>//     <br>//    Return Value - none <br>// <br>//    A flag is cleared to indicate to other methods that Exchange is <br>//    finished submitting the message. <br>// <br> <br>STDMETHODIMP_ (VOID) MyExchExtMessageEvents::OnSubmitComplete(LPEXCHEXTCALLBACK lpeecb, ULONG ulFlags) <br>{ <br> <br>  m_bInSubmitState = FALSE;  // out of submit state <br> <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  Helper Functions <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ErrorMessageBox() <br>// <br>//    Parameters <br>//    hWnd       -- parent window <br>//    hr         -- HRESULT value <br>//    szFunction -- function name in which the error occurred <br>//    szMessage  -- error message <br>// <br>//    Purpose <br>//    Displays an error message using MessageBox <br>// <br>//    Return Value - none <br>// <br>//    Comments <br>//    Pass 0 for hr to not display an error number.  Pass NULL for <br>//    szFunction to not display a function name.  Use these options <br>//    to display error messages for public consumption.  Use hr and <br>//    function name for internal errors and for debugging.  szMessage <br>//    is mandatory. <br>// <br>void ErrorMessageBox(HWND hWnd, HRESULT hr, LPSTR szFunction, LPSTR szMessage) <br>{ <br> static char szError[256]; <br> <br> if (szMessage == NULL) <br> { <br>    MessageBox(hWnd,  <br>         "An unknown error occured in\nSample property sheet extension", <br>         "Sample Property Sheet Extension", MB_ICONEXCLAMATION | MB_OK); <br>    return; <br> } <br> <br> if ((hr == 0) &amp;&amp; (szFunction == NULL)) <br> { <br>    MessageBox(hWnd, szMessage, "Sample Extension Error", MB_ICONEXCLAMATION | MB_OK); <br>    return; <br> } <br> <br> <br> if (szFunction != NULL)  <br> { <br>  wsprintf(szError, "Error %08X in %s\n%s", hr, szFunction, szMessage); <br>  MessageBox(hWnd, szError, "Sample Extension Error", MB_ICONEXCLAMATION | MB_OK); <br> } <br> <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CalcULONGCheckSum(pMessage, &amp;ulCheckSum)() <br>// <br>//    Parameters <br>//    pMessage -- pointer to message object <br>//    *pulCheckSum -- pointer to buffer to contain calculated checksum <br>// <br>//    Purpose <br>//    Calculates a checksum on the PR_BODY property of a message <br>// <br>//    Return Value <br>//    HRESULT value: <br>//       S_OK -- succeeded <br>//       anything means some internal call failed <br>// <br>//    Comments <br>//    Checksum is calculated by adding the ascii values for 4 bytes of data <br>//    concatenated together at a time.  If the message does not have an even <br>//    multiple of 4 characters in the PR_BODY, the remain 1 2 or 3 characters <br>//    are concatenated to make a ULONG with leading zeros. <br>// <br> <br>HRESULT CalcULONGCheckSum(LPMESSAGE pMessage, ULONG *pulCheckSum) <br>{ <br> HRESULT hr; <br> LPSTREAM pStreamBody = NULL; <br> ULONG ulValue; <br> ULONG ulRead; <br> LARGE_INTEGER large_int; <br> ULARGE_INTEGER ularge_int; <br> <br> if ( (pMessage == NULL) || <br>      (pulCheckSum == NULL) ) <br> { <br>      hr = MAPI_E_INVALID_PARAMETER; <br>      goto error_return; <br> } <br> <br> hr = pMessage-&gt;OpenProperty(PR_BODY, &amp;IID_IStream, STGM_DIRECT | STGM_READ, 0,  <br>                    (LPUNKNOWN *) &amp;pStreamBody); <br>  <br> if(GetScode(hr) == MAPI_E_NOT_FOUND)  //no body in the message <br> { <br>     *pulCheckSum = 0; <br>     return hrSuccess; <br> } <br> if (FAILED(hr)) <br> { <br>    goto error_return; <br> } <br> <br> large_int.LowPart = 0; <br> large_int.HighPart = 0; <br>  <br> hr = pStreamBody-&gt;Seek(large_int, STREAM_SEEK_SET, &amp;ularge_int);   <br> if (FAILED(hr)) <br> { <br>    goto error_return; <br> } <br> <br>  <br> (*pulCheckSum) = 0; <br> ulValue = 0; <br> while ( (S_OK == (hr = pStreamBody-&gt;Read((LPVOID)&amp;ulValue, 4, &amp;ulRead)))  &amp;&amp; <br>         (ulRead &gt; 0) ) <br> { <br>    (*pulCheckSum) += ulValue; <br>    ulValue = 0; <br> }       <br> <br> <br> error_return: <br> <br> if (pStreamBody != NULL) <br>    pStreamBody-&gt;Release(); <br> </code></pre>
<p>
</p>
<pre><code>return hr; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
