<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXTPRSHT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2166"></a>EXTPRSHT.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name <br>//      EXTPRSHT.CPP  <br>// <br>//  Description <br>//      Implementation of MyExchExt and MyExchExtPropertySheets along <br>//      with helper functions towards the end. <br>// <br>//      IExchExt interface methods: <br>//          MyExchExt::QueryInterface() <br>//          MyExchExt::AddRef() <br>//          MyExchExt::Release() <br>// <br>//          MyExchExt::Install() <br>// <br>//      IExchExtPropertySheets interface methods: <br>//          IExchExtPropertySheets::QueryInterface() <br>//          IExchExtPropertySheets::AddRef() <br>//          IExchExtPropertySheets::Release() <br>// <br>//          IExchExtPropertySheets::GetMaxPageCount() <br>//          IExchExtPropertySheets::GetPages() <br>//          IExchExtPropertySheets::FreePages() <br>// <br>//  Author <br>//      Gary Peluso <br>// <br>//  Revision: 1.01 <br>// <br>//  History <br>//  9/21/95 - changed QI for MyExchExtPropertySheets to return pointer to MyExchExt  <br>//            when IID_IUNKNOWN is requested <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1992-1995 Microsoft Corporation. All rights reserved. <br>// <br>#define INITGUID <br>#define USES_IID_IExchExt <br>#define USES_IID_IExchExtAdvancedCriteria <br>#define USES_IID_IExchExtAttachedFileEvents <br>#define USES_IID_IExchExtCommands <br>#define USES_IID_IExchExtMessageEvents <br>#define USES_IID_IExchExtPropertySheets <br>#define USES_IID_IExchExtSessionEvents <br>#define USES_IID_IExchExtUserEvents <br>#define USES_IID_IMAPIFolder <br>#define USES_IID_IMAPIFormInfo <br>#define USES_PS_PUBLIC_STRINGS <br> <br>#include "EXTPRSHT.H" <br> <br>#include &lt;INITGUID.H&gt; <br>#include &lt;MAPIGUID.H&gt; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  tag enumeration definitions and arrays <br>// <br>//  <br> enum { MESSAGE_CLASS, OBJECT_TYPE, OBJPROPTAGS }; <br> <br>static const SizedSPropTagArray(OBJPROPTAGS,  ObjPropTags) = <br>      { OBJPROPTAGS,  <br>        {  <br>         PR_MESSAGE_CLASS, <br>         PR_OBJECT_TYPE,         <br>        }  <br>      }; <br> <br> enum { LASTEDIT, MORETAGS }; <br> <br>static const SizedSPropTagArray(MORETAGS,  MoreObjTags) = <br>      { MORETAGS,  <br>        {  <br>         PR_LAST_MODIFICATION_TIME, <br>        }  <br>      }; <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    Office Document Named Properties <br>// <br> <br>enum { KEYWORDS = 0, COMMENTS, AUTHOR, COMPANY,  <br>       APPNAME, CATEGORY, TITLE, DOCSUBJECT,  <br>       NAMEIDS // number of properties <br>}; <br> <br>LPWSTR awszDocProperties[] = { L"Keywords", L"Comments", L"Author", L"Company",  <br>                               L"AppName",  L"Category", L"Title", L"Subject"}; <br> <br> <br>// array of property tags for named properties <br>SizedSPropTagArray(NAMEIDS, tagaDoc); <br> <br>// arrays for summary sheet properties   <br>LPSPropValue pSummaryProps = NULL; <br>LPSPropValue pMoreDocProps = NULL; <br> <br>// instance handle of DLL <br>static HINSTANCE ghInstDLL = NULL; <br> <br>// flag to prevent reentrancy <br>BOOL bBusy = FALSE; <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FUNCTION: DLLMain() <br>// <br>//    Purpose <br>//    Do initilization processesing <br>// <br>//    Return Value <br>//    TRUE - DLL successfully loads and LoadLibrary will succeed. <br>//    FALSE - will cause an Exchange error message saying it cannot locate <br>//            the extension DLL. <br>// <br>//    Comments <br>//    We only need to get a copy of the DLL's HINSTANCE. <br>// <br>BOOL WINAPI DllMain( <br>    HINSTANCE  hinstDLL, <br>    DWORD  fdwReason,    <br>    LPVOID  lpvReserved)  <br>{ <br> if (DLL_PROCESS_ATTACH == fdwReason) <br> { <br>    ghInstDLL = hinstDLL; <br> <br> } <br> return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FUNCTION: ExchEntryPoint <br>// <br>//    Parameters - none <br>// <br>//    Purpose <br>//    The entry point called by Exchange. <br>// <br>//    Return Value <br>//    Pointer to Exchange Extension (IExchExt) interface <br>// <br>//    Comments <br>//    Exchange Client calls this for each context entry.   <br>// <br> <br>LPEXCHEXT CALLBACK ExchEntryPoint(void) <br>{ <br>         <br>     return new MyExchExt; <br> <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::MyExchExt() <br>// <br>//    Parameters - none <br>// <br>//    Purpose <br>//    Comstructor.  Called during instantiation of MyExchExt object. <br>// <br>// <br> <br>MyExchExt::MyExchExt() <br>{ <br>  m_cRef = 1;  <br>  m_context = 0; <br>   <br>  m_pExchExtPropertySheets = new MyExchExtPropertySheets(this); <br> <br>}; <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  IExchExt virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::Release() <br>// <br>//    Parameters - none <br>// <br>//    Purpose <br>//    Frees memory when interface is not referenced any more <br>// <br>//    Return value <br>//    reference count of interface <br>// <br> <br>STDMETHODIMP_(ULONG) MyExchExt::Release()  <br>{  <br> ULONG ulCount = --m_cRef; <br>                          <br> if (!ulCount)  <br> {  <br>  tagaDoc.cValues = 0; <br>  delete this; <br> } <br> <br>return ulCount; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::QueryInterface() <br>// <br>//    Parameters <br>//    riid   -- Interface ID. <br>//    ppvObj -- address of interface object pointer. <br>// <br>//    Purpose <br>//    Returns a pointer to an interface object that is requested by ID. <br>// <br>//    Comments <br>//    The interfaces are requested everytime a new context is entered.  The  <br>//    IID_IExchExt* interfaces are ignored if not specified in the Exchange <br>//    extensions registry. <br>// <br>//    If an interface pointer is returned for more than one context, that <br>//    interface is used by the client for each of those contexts.  Check the <br>//    current context to verify if it is appropriate to pass back an interface <br>//    pointer. <br>//     <br>//    Return Value - none <br>// <br> <br>STDMETHODIMP MyExchExt::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)           <br>{ <br>    HRESULT hResult = S_OK; <br> <br>    *ppvObj = NULL; <br> <br>    if (( IID_IUnknown == riid) || ( IID_IExchExt == riid) ) <br>    { <br>        *ppvObj = (LPUNKNOWN)this; <br>    } <br>    else if (IID_IExchExtPropertySheets == riid) <br>    { <br>        *ppvObj = (LPUNKNOWN) m_pExchExtPropertySheets; <br>    } <br>    else <br>        hResult = E_NOINTERFACE; <br> <br>    if (NULL != *ppvObj) <br>        ((LPUNKNOWN)*ppvObj)-&gt;AddRef(); <br> <br>    return hResult; <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExt::Install() <br>// <br>//    Parameters <br>//    peecb     -- pointer to Exchange Extension callback function <br>//    eecontext -- context code at time of being called. <br>// <br>//    Purpose <br>//    Called once for each new context that is entered. <br>// <br>//    Return Value <br>//    S_OK - the installation succeeded for the context <br>//    S_FALSE - deny the installation fo the extension for the context <br>// <br>STDMETHODIMP MyExchExt::Install(LPEXCHEXTCALLBACK peecb, ULONG eecontext, ULONG ulFlags) <br>{ <br>    ULONG ulBuildVersion; <br>    HRESULT hr; <br> <br>    m_context = eecontext; <br>        <br>    // make sure this is the right version  <br>    peecb-&gt;GetVersion(&amp;ulBuildVersion, EECBGV_GETBUILDVERSION); <br>    if (EECBGV_BUILDVERSION_MAJOR != (ulBuildVersion &amp;  <br>                                      EECBGV_BUILDVERSION_MAJOR_MASK)) <br>        return S_FALSE; <br> <br> <br>    switch (eecontext) <br>    { <br>     case EECONTEXT_PROPERTYSHEETS: <br>        hr = S_OK; <br>        break; <br> <br>     default: <br>        hr = S_FALSE; <br>        break; <br>    } <br> <br> <br>    return hr; <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  IExchExtPropertySheets virtual member functions implementation <br>// <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::QueryInterface() <br>// <br>//    Parameters <br>//    riid   -- Interface ID. <br>//    ppvObj -- address of interface object pointer. <br>// <br>//    Purpose <br>//    Return interface object upon request <br>//     <br>//    Return Value - none <br>// <br>//    Comments <br>//    Currently the Exchange client does not call QueryInterface from any object <br>//    except for IExchExt.  This is implemented in case features are added to <br>//    Exchange to require QueryInterface from any object.  Also, as a "rule of <br>//    OLE COM" this is the proper implementation of QueryInterface. <br>// <br> <br>STDMETHODIMP MyExchExtPropertySheets::QueryInterface(REFIID riid, LPVOID FAR * ppvObj)           <br>{    <br> <br>    *ppvObj = NULL; <br>    if (riid == IID_IExchExtPropertySheets) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        // Increase usage count of this object <br>        AddRef(); <br>        return S_OK; <br>    }     <br>    if (riid == IID_IUnknown) <br>    { <br>     // return MyExchExt as a rule of OLE COM since MyExchExtPropertySheets <br>     // was obtained vi MyExchExt::QueryInterface <br>        *ppvObj = (LPVOID)m_pExchExt; <br>        m_pExchExt-&gt;AddRef(); <br>        return S_OK; <br>    } <br>    return E_NOINTERFACE; <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::GetMaxPageCount() <br>// <br>//    Parameters <br>//    ulFlags -- a bitmask indicating what type of property sheet is being  <br>//               displayed <br>// <br>//    Purpose <br>//    Returns the number of property pages which are to be added. <br>// <br>//    Return Value - maximum number of custom pages for the property sheet <br>// <br>//    Exchange Calls this to know how many PROPSHEETPAGE buffers it needs <br>//    to allocate. <br>// <br> <br>ULONG MyExchExtPropertySheets::GetMaxPageCount(ULONG ulFlags)           <br>{ <br> ULONG ulNumExtSheets; <br> <br>    switch (ulFlags) <br>    { <br>     // ignore these objects. <br>     case EEPS_FOLDER: <br>     case EEPS_STORE: <br>     case EEPS_TOOLSOPTIONS: <br>        ulNumExtSheets = 0; <br>        break; <br>          <br>     case EEPS_MESSAGE: <br>        ulNumExtSheets = 1; <br>        break; <br> <br>     default: <br>        ulNumExtSheets = 0; <br>        break; <br>    } <br> <br>    return ulNumExtSheets;   // adding one propery page <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::GetPages() <br>// <br>//    Parameters <br>//    peecb   -- pointer to Exchange callback interface <br>//    ulFlags -- a bitmask indicating what type of property sheet is being  <br>//               displayed <br>//    ppsp    -- output parm pointing to pointer to list of property sheets <br>//    pcpsp   -- output parm pointing to buffer contaiing number of property <br>//               sheets actually used. <br>// <br>//    Purpose <br>//    Fills the PROPSHEETPAGE members for the custom property page. <br>// <br>//    Return Value <br>//    S_FALSE - do not add a new page <br>//    S_OK - use the ppsp information for new pages. <br>// <br>//    Comments <br>//    Exchange calls this method to gather information for any custom <br>//    property pages to be added to the sheet.  Here we are only adding <br>//    one.  ppsp may be an array of PROPSHEETPAGE structures to allow you <br>//    to all multiple property pages. <br>// <br> <br>STDMETHODIMP MyExchExtPropertySheets::GetPages(LPEXCHEXTCALLBACK peecb, <br>                      ULONG ulFlags, LPPROPSHEETPAGE ppsp, ULONG FAR * pcpsp) <br>{ <br>    HRESULT     hr; <br>    LPMDB       pMDB = NULL; <br>    LPMESSAGE   pItem = NULL; <br> <br>    *pcpsp = 0; <br> <br>    // Check for reentrancy <br>    if (bBusy) <br>    { <br>        hr = MAPI_E_BUSY; <br>        ErrorMessageBox(NULL, hr, "GetPages", "The summary sheet is already open"); <br>        return hr; <br>    } <br>     <br>    bBusy = TRUE; <br> <br>    // Get our message from the caller <br>    hr = peecb-&gt;GetObject(&amp;pMDB, (LPMAPIPROP *)&amp;pItem); <br>    if (pItem == NULL) <br>    { <br>        ErrorMessageBox(NULL, hr, "GetPages", "GetObject failed"); <br>        goto error_return; <br>    } <br> <br>    // If the message does not belong to a document class, we don't <br>    // do anything <br>    if (!ValidDocObject(pItem)) <br>    { <br>        // nothing to do, must clear bBusy <br>        bBusy = FALSE; <br>        hr = S_OK; <br>        goto error_return; <br>    } <br> <br>    // Retrieve document summary properties from the message <br>    if (!GetSummarySheetInfo(pItem)) <br>    { <br>        ErrorMessageBox(NULL, 0, "GetPages", "Could not get summary sheet information"); <br>        hr = E_FAIL; <br>        goto error_return; <br>    } <br> <br>    // fill out members for the property page <br>    ppsp[0].dwSize = sizeof (PROPSHEETPAGE); <br>    ppsp[0].dwFlags = PSP_DEFAULT; <br>    ppsp[0].hInstance = ghInstDLL; <br>    ppsp[0].pszTemplate = MAKEINTRESOURCE(IDD_SUMMARY); <br>    ppsp[0].hIcon = NULL;     // not used in this sample <br>    ppsp[0].pszTitle = NULL;  // not used in this sample <br>    ppsp[0].pfnDlgProc = (DLGPROC)SummaryPageDlgProc; <br>    ppsp[0].lParam = 0;      <br>    ppsp[0].pfnCallback = NULL; <br>    ppsp[0].pcRefParent = NULL; // not used in this sample <br> <br>    *pcpsp = 1; <br>    // DO NOT clear bBusy in this case. It will be cleared evenmtually <br>    // when the property sheet is dismissed. <br>    hr = S_OK; <br> <br>error_return: <br> <br>    UlRelease(pItem); <br>    UlRelease(pMDB); <br> <br>    if (hr) <br>        bBusy = FALSE; <br> <br>    return hr; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MyExchExtPropertySheets::FreePages() <br>// <br>//    Parameters <br>//    ppsp -- pointer to a pointer to the first of a list of property pages <br>//    cpsp -- number of custom property pages in the list <br>//    ulFlags -- type of property page <br>//     <br>//    Purpose <br>//    Free any memory associated to the property sheet. <br>// <br>//    Return Value - none <br>// <br>//    Comments <br>//    No parameters are used in this example but the function is used as <br>//    a signal that the property sheet is going away and so memory may <br>//    be freed. <br>// <br>                          <br>VOID MyExchExtPropertySheets::FreePages(LPPROPSHEETPAGE ppsp, ULONG ulFlags,  <br>                                        ULONG cpsp)           <br>{ <br>    MAPIFreeBuffer(pSummaryProps); <br>    pSummaryProps = NULL; <br> <br>    MAPIFreeBuffer(pMoreDocProps); <br>    pMoreDocProps = NULL; <br> <br>    // Clear the reentrancy flag. <br>    // This must be done here rather than in the dialog proc, because <br>    // our property page may be dismissed without ever having been  <br>    // displayed. <br>    bBusy = FALSE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//  Helper Functions <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ErrorMessageBox() <br>// <br>//    Parameters <br>//    hWnd       -- parent window <br>//    hr         -- HRESULT value <br>//    szFunction -- function name in which the error occurred <br>//    szMessage  -- error message <br>// <br>//    Purpose <br>//    Displays an error message using MessageBox <br>// <br>//    Return Value - none <br>// <br>//    Comments <br>//    Pass 0 for hr to not display an error number.  Pass NULL for <br>//    szFunction to not display a function name.  Use these options <br>//    to display error messages for public consumption.  Use hr and <br>//    function name for internal errors and for debugging.  szMessage <br>//    is mandatory. <br>// <br>void ErrorMessageBox(HWND hWnd, HRESULT hr, LPSTR szFunction, LPSTR szMessage) <br>{ <br> static char szError[256]; <br> <br> if (szMessage == NULL) <br> { <br>    MessageBox(hWnd,  <br>         "An unknown error occured in\nSample property sheet extension", <br>         "Sample Property Sheet Extension", MB_ICONEXCLAMATION | MB_OK); <br>    return; <br> } <br> <br> if ((hr == 0) &amp;&amp; (szFunction == NULL)) <br> { <br>    MessageBox(hWnd, szMessage, "Sample Extension Error", MB_ICONEXCLAMATION | MB_OK); <br>    return; <br> } <br> <br> <br> if (szFunction != NULL)  <br> { <br>  wsprintf(szError, "Error %08X in %s\n%s", hr, szFunction, szMessage); <br>  MessageBox(hWnd, szError, "Sample Extension Error", MB_ICONEXCLAMATION | MB_OK); <br> } <br> <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetSummarySheetInfo() <br>// <br>//    Parameters <br>//    pMessage -- pointer to an Office Document object, message object of <br>//                class IPM.Document <br>// <br>//    Purpose <br>//    gathers the summary sheet information from the properties of a message <br>// <br>//    Return Value <br>//    TRUE if everything succeeded <br>//    FALSE something failed, inform the caller <br>// <br>//    Comments <br>//    The pointers to the buffers are defined in the PRSHTDLG.CPP file and are <br>//    externally referenced here. <br>// <br>//    tagaDoc is a static array of property tags from GetNamedIDs <br>//    Only need to call this function once when tags are first needed. <br>//    The buffer for the tags are freed in the Release method of MyExchExt when <br>//    Exchange is closing down. <br>// <br> <br>BOOL GetSummarySheetInfo(LPMESSAGE pMessage) <br>{ <br>    HRESULT     hr; <br>    ULONG       ulcValues; <br>    BOOL        bSuccess; <br>  <br>    bSuccess = FALSE; <br> <br>    if (pMessage == NULL) <br>    { <br>        ErrorMessageBox(NULL, 0, "GetSummarySheetInfo", "Null pMessage"); <br>        goto error_return; <br>    } <br> <br>    // Retrieve property IDs of the summary properties from the message. <br>    tagaDoc.cValues = 0; <br>    if (!GetNamedIDs(pMessage)) <br>    { <br>        ErrorMessageBox(NULL, 0, "GetSummarySheetInfo", "GetNamedIDs failed"); <br>        goto error_return; <br>    }         <br> <br> <br>    hr = pMessage-&gt;GetProps((LPSPropTagArray)&amp;tagaDoc, 0, &amp;ulcValues, <br>        &amp;pSummaryProps); <br>    if (FAILED(hr)) <br>    { <br>        ErrorMessageBox(NULL, hr, "GetSummarySheetInfo", "GetProps failed"); <br>        goto error_return; <br>    } <br> <br> <br>    // These must be validated in the same order as the named id property tag <br>    // array. See GetNamedIDs below. <br> <br>    if (PROP_TYPE(pSummaryProps[KEYWORDS].ulPropTag) == PT_MV_STRING8) <br>        mvszKeywords = pSummaryProps[KEYWORDS].Value.MVszA; <br>    else <br>    { <br>        char szDefault[] = "No Keywords"; <br>        szDocKeywords = (LPSTR)malloc(lstrlen(szDefault) + 1); <br>        lstrcpy (szDocKeywords, szDefault); <br>        mvszKeywords.cValues = 0; <br>    } <br> <br> <br>    if (PROP_TYPE(pSummaryProps[COMMENTS].ulPropTag) == PT_STRING8) <br>        szDocComments = pSummaryProps[COMMENTS].Value.lpszA; <br>    else <br>        szDocComments = "No Comments"; <br> <br> <br>    if (PROP_TYPE(pSummaryProps[AUTHOR].ulPropTag) == PT_STRING8) <br>        szDocAuthor = pSummaryProps[AUTHOR].Value.lpszA; <br>    else <br>        szDocAuthor = "No Author"; <br> <br>    if (PROP_TYPE(pSummaryProps[COMPANY].ulPropTag) == PT_STRING8) <br>        szDocCompany = pSummaryProps[COMPANY].Value.lpszA; <br>    else <br>        szDocCompany = "No Company"; <br> <br>    if (PROP_TYPE(pSummaryProps[APPNAME].ulPropTag) == PT_STRING8) <br>        szDocApplication = pSummaryProps[APPNAME].Value.lpszA; <br>    else <br>        szDocApplication = "No Application"; <br> <br>    if (PROP_TYPE(pSummaryProps[CATEGORY].ulPropTag) == PT_STRING8) <br>        szDocCategory = pSummaryProps[CATEGORY].Value.lpszA; <br>    else <br>        szDocCategory = "No Category"; <br> <br>    if (PROP_TYPE(pSummaryProps[TITLE].ulPropTag) == PT_STRING8) <br>        szDocTitle = pSummaryProps[TITLE].Value.lpszA; <br>    else <br>        szDocTitle = "No Title"; <br> <br>    if (PROP_TYPE(pSummaryProps[DOCSUBJECT].ulPropTag) == PT_STRING8) <br>        szDocSubject = pSummaryProps[DOCSUBJECT].Value.lpszA; <br>    else <br>        szDocSubject = "No Subject"; <br> <br>    // Retrieve additional non-named properties <br>    hr = pMessage-&gt;GetProps((LPSPropTagArray)&amp;MoreObjTags, 0, &amp;ulcValues, &amp;pMoreDocProps); <br>    if (FAILED(hr)) <br>    { <br>        ErrorMessageBox(NULL, hr, "GetSummarySheetInfo", "GetProps failed"); <br>        goto error_return; <br>    } <br> <br>    if (PROP_TYPE(pMoreDocProps[LASTEDIT].ulPropTag) == PT_SYSTIME) <br>        szDocLastSaved = GetFileTimeString(&amp;(pMoreDocProps[LASTEDIT].Value.ft)); <br>    else <br>        szDocLastSaved = "No last saved time"; <br> <br>    bSuccess = TRUE; <br> <br>error_return: <br> <br>return bSuccess; <br> <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetNamedIDs() <br>// <br>//    Parameters <br>//    pMessage -- message object of which to call GetIDsFromNames() <br>// <br>//    Purpose <br>//    This function retrieves the property IDs of names from Office Document <br>//    summary sheet properties. <br>// <br>//    Return Value - none <br>// <br>//    Comments <br>//    The name strings used were found imperically because there were no <br>//    documentation publishing the Office document named properties at the <br>//    time this sample was implemented.  It is possible to get a list <br>//    of all public named properties by calling GetNamesFromIDs(). <br>// <br>//    tagaDoc is a global variable listed at the top of this file. <br>// <br>BOOL GetNamedIDs(LPMESSAGE pMessage) <br>{ <br>    HRESULT         hr; <br>    LPMAPINAMEID    apMAPINameId[NAMEIDS]; <br>    MAPINAMEID      aMAPINameId[NAMEIDS]; <br>    UINT            i; <br>    LPSPropTagArray pTags = NULL; <br>    BOOL            bSucceeded = FALSE; <br> <br>    if (pMessage == NULL) <br>    { <br>        ErrorMessageBox(NULL, 0, "GetNamedIDs", "Null pMessage"); <br>        goto error_return; <br>    } <br> <br>    memset(apMAPINameId, 0, NAMEIDS * sizeof(LPMAPINAMEID)); <br>    memset(aMAPINameId, 0, NAMEIDS * sizeof(MAPINAMEID)); <br> <br>    // create an array of property names <br>    for (i=0; i&lt;NAMEIDS; i++) <br>    { <br>        aMAPINameId[i].lpguid = (LPGUID)&amp;PS_PUBLIC_STRINGS; <br>        aMAPINameId[i].ulKind = MNID_STRING; <br>        aMAPINameId[i].Kind.lpwstrName = awszDocProperties[i]; <br> <br>        apMAPINameId[i] = &amp;aMAPINameId[i]; <br>    } <br> <br> <br>    // Get the property IDs for these names from the message. <br>    // A PT_ERROR tag is returned for any unrecognized names. <br>    hr = pMessage-&gt;GetIDsFromNames(NAMEIDS, apMAPINameId, 0, &amp;pTags); <br>    if (FAILED(hr)) <br>    { <br>        ErrorMessageBox(NULL, hr, "GetNamedIDs", "GetIDsFromNames failed"); <br>        goto error_return; <br>    } <br> <br> <br>    // Copy the returned property tags to the global array tagaDoc. <br>    // For the unrecognized properties, substitute a tag that GetProps <br>    // will ignore. <br>    for (i=0; i&lt;NAMEIDS; ++i) <br>    { <br>        if (PT_ERROR != PROP_TYPE(pTags-&gt;aulPropTag[i])) <br>            tagaDoc.aulPropTag[i] = pTags-&gt;aulPropTag[i]; <br>        else <br>            tagaDoc.aulPropTag[i] = PR_NULL; <br>    } <br> <br>    tagaDoc.cValues = NAMEIDS; <br> <br>    bSucceeded = TRUE; <br> <br>error_return: <br> <br>    MAPIFreeBuffer(pTags); <br>    return bSucceeded; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ValidDocObject() <br>// <br>//    Parameters <br>//    pObject -- pointer to property object validate <br>// <br>//    Purpose <br>//    Inspects the properties of the object to see if the selected object <br>//    is a message type object and has the proper class. <br>// <br>//    Return Value <br>//    TRUE if the object is MAPI_MESSAGE and the class is IPM.Document <br>//    FALSE if either the object is not MAPI_MESSAGE or class is not <br>//    IPM.Document <br>// <br>//    Comments <br>//    This function is intended to be called from GetPages with an <br>//    object pointer from GetObject. <br>// <br>BOOL ValidDocObject(LPMAPIPROP pObject) <br>{ <br>    HRESULT         hr; <br>    ULONG           ulcValues; <br>    LPSPropValue    pObjectProps = NULL; <br>    BOOL            bRet; <br> <br>    bRet = FALSE;   // assume invalid object <br> <br>    if (!pObject) <br>    { <br>        ErrorMessageBox(NULL, 0, "ValidDocObject", "Null pObject"); <br>        return FALSE; <br>    } <br> <br>    hr = pObject-&gt;GetProps((LPSPropTagArray)&amp;ObjPropTags, 0, &amp;ulcValues,  <br>        &amp;pObjectProps); <br>    if (FAILED(hr)) <br>    { <br>        ErrorMessageBox(NULL, hr, "ValidDocObject", "pObject-&gt;GetProps failed"); <br>        goto error_return; <br>    } <br> <br>    if ( (pObjectProps[OBJECT_TYPE].Value.l == MAPI_MESSAGE)  &amp;&amp; <br>         (pObjectProps[MESSAGE_CLASS].ulPropTag == PR_MESSAGE_CLASS) &amp;&amp; <br>         (strstr(pObjectProps[MESSAGE_CLASS].Value.lpszA, "IPM.Document")) ) <br>        bRet = TRUE; <br> <br> <br>    // clean up <br>error_return: <br> <br>    MAPIFreeBuffer(pObjectProps); <br>    return bRet; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetFileTimeString() <br>// <br>//    Parameters <br>//    pft -- filetime structure pointer <br>// <br>//    Purpose <br>//    convert the given filetime date into a string. <br>// <br>//    Return Value <br>//    pointer to a string buffer containing formatted filed time. <br>// <br>//    Comments <br>//    The filetime is formated into dd/mm/yy hh:mm.  The string buffer <br>//    is static (not on the stack) because it is referred to outside this <br>//    function. <br>// <br> <br>LPSTR GetFileTimeString(FILETIME * pft) <br>{ <br> static char szTimeStringBuff[25]; <br> FILETIME ftLocal; <br> SYSTEMTIME systime; <br> WORD wAdjustedHour; <br> LPSTR pszAMPM[2] = { "AM", "PM" }; <br> int nAMPM; <br> <br> FileTimeToLocalFileTime(pft, &amp;ftLocal); <br> FileTimeToSystemTime(&amp;ftLocal, &amp;systime); <br>  <br> szTimeStringBuff[0] = '\0'; <br>  <br>// convert from Military time to Civilian time format  <br> wAdjustedHour = systime.wHour; <br> <br> nAMPM = 1;  // assume PM time <br> if ( wAdjustedHour &lt; 12 ) <br>    nAMPM = 0;   // AM time <br> <br> if (wAdjustedHour &gt; 12) <br> { <br>    wAdjustedHour-=12; <br> } <br>  <br> wsprintf(szTimeStringBuff, "%02d/%02d/%02d %02d:%02d%s",  <br>            systime.wMonth, <br>            systime.wDay, <br>            systime.wYear, <br>            wAdjustedHour, <br>            systime.wMinute, <br>            pszAMPM[nAMPM]); <br> <br> return szTimeStringBuff; <br> <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
