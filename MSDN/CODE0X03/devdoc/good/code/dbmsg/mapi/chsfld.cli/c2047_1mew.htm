<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHSFLD.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2048"></a>CHSFLD.CPP</h2>
<pre><code>//////////////////////////////////////////////////////////////////////////// <br>// <br>//      CHSFLD.CPP <br>// <br>// <br>//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved. <br>/////////////////////////////////////////////////////////////////////// <br> <br> <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include "chsfld.h" <br>#include "lasterr.h" <br>#include "tvdlg.h" <br>#include "resource.h" <br>#include "tvstack.h" <br> <br> <br> <br>#define cImageHeight    16 <br>#define cImageWidth     16 <br>#define cImages         4 <br> <br>//globals <br>LPSTR g_szAllStores = "All Message Stores"; <br>LPSTR g_szModuleName = "Choose Folder Dialog"; <br> <br>//functions used only in this file <br>BOOL CALLBACK <br>ChsFldDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam); <br> <br>HRESULT HrGetNewName(HINSTANCE hInst, HWND hwParent, LPSTR * pszNewName); <br> <br>BOOL CALLBACK <br>NewNameDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam); <br> <br> <br>// <br>//  HrPickFolder <br>// <br>//   <br>STDAPI <br>HrPickFolder(HINSTANCE hInst, HWND hWnd, LPMAPISESSION pses, LPMAPIFOLDER * ppfld, <br>                LPMDB *ppmdb, ULONG * pcb, LPBYTE * ppb) <br>{ <br>    HRESULT hr; <br>     <br>    //Assert(hInst); <br>     <br>    if((hWnd &amp;&amp; !IsWindow(hWnd)) || (!pses) || (!ppfld) || (!ppmdb)) <br>    {  <br>        DebugTraceResult(HrPickFolder, E_INVALIDARG); <br>        return E_INVALIDARG; <br>    } <br> <br>    if(pcb &amp;&amp; IsBadWritePtr(pcb, sizeof(ULONG))) <br>    { <br>        DebugTraceArg(HrPickFolder, "pcb not writable"); <br>        return E_INVALIDARG; <br>    } <br> <br>    if(pcb &amp;&amp; (*pcb &amp; 0x3)) <br>    { <br>        DebugTraceArg(HrPickFolder, "pcb not multiple of 4"); <br>        return E_INVALIDARG; <br>    } <br>     <br>    if(ppb &amp;&amp; IsBadWritePtr(ppb, sizeof(LPBYTE))) <br>    { <br>        DebugTraceArg(HrPickFolder, "ppb not writable"); <br>        return E_INVALIDARG; <br>    } <br> <br>    if(ppb &amp;&amp; pcb &amp;&amp; IsBadWritePtr(*ppb, *pcb)) <br>    { <br>        DebugTraceArg(HrPickFolder, "*pcb or *ppb"); <br>        return E_INVALIDARG; <br>    } <br> <br>    ////////////////////////////////////////////////////////////////////// <br>    // if you incorporate this code into you app, remove this and pass in <br>    // the right hInst <br>    // Start remove <br>    hInst = GetModuleHandle("chsfld32.dll"); <br>    if(!hInst) <br>    { <br>        DebugTrace("GetModuleHandel failed\n"); <br>        DebugTraceResult(HrPickFolder, E_FAIL); <br>        return E_FAIL; <br>    } <br>    // End remove <br>    /////////////////////////////////////////////////////////////////////// <br> <br>    //ULONG cb = 0; <br>    //LPBYTE pb = NULL; <br>     <br>    CChsFldDlg PickDlg(pses, hInst, pcb, ppb); <br> <br>    InitCommonControls(); <br> <br>    hr = PickDlg.HrPick(MAKEINTRESOURCE(IDD_CFDIALOG), hWnd, <br>                        (DLGPROC)ChsFldDlgProc, ppfld, ppmdb); <br> <br>/*  if(SUCCEEDED(hr)) <br>    { <br>        (*ppfld)-&gt;Release(); <br>        (*ppmdb)-&gt;Release(); <br>    } <br>     <br>    CChsFldDlg PickDlg1(pses, hInst, pcb, ppb); <br> <br>    hr = PickDlg1.HrPick(MAKEINTRESOURCE(IDD_CFDIALOG), hWnd, <br>                        (DLGPROC)ChsFldDlgProc, ppfld, ppmdb);*/ <br> <br>//  if(!hr) <br>    //  MAPIFreeBuffer(pb); <br>         <br>    DebugTraceResult(HrPickFolder, hr); <br>    return hr; <br>} <br> <br> <br>// <br>//  CChsFldDlg::CChsFldDlg <br>// <br>inline <br>CChsFldDlg::CChsFldDlg(LPMAPISESSION pses, HINSTANCE hInst, ULONG * pcb, <br>                        LPBYTE * ppb)   : m_lsterr(g_szModuleName) <br>{ <br>    Assert(pses); <br>    Assert(hInst); <br>     <br>    m_pses = pses; <br>    pses-&gt;AddRef(); <br> <br>    m_hr = hrSuccess; <br>    m_pfld = NULL; <br>    m_pmdb = NULL; <br>    m_hiRoot = NULL; <br>    m_hInst = hInst; <br>    m_hIml = NULL; <br>    m_hDlg = NULL; <br>    m_hwTreeCtl = NULL; <br>    m_pcbState = pcb; <br>    m_ppbState = ppb; <br>}        <br> <br>// <br>//  CChsFldDlg::~CChsFldDlg <br>// <br>CChsFldDlg::~CChsFldDlg() <br>{ <br>    UlRelease(m_pses); <br>    UlRelease(m_pfld); <br>    UlRelease(m_pmdb); <br> <br>    if(m_hIml) <br>        ImageList_Destroy(m_hIml); <br>} <br> <br> <br>// <br>//  CChsFldDlg::SetFolder <br>// <br>//  Store the folder chosen by the user <br>// <br>inline void CChsFldDlg::SetFolder(LPMAPIFOLDER pfld, LPMDB pmdb) <br>{ <br>    UlRelease(m_pfld); <br> <br>    m_pfld = pfld; <br>     <br>    if(pfld) <br>        pfld-&gt;AddRef(); <br> <br>    UlRelease(m_pmdb); <br> <br>    m_pmdb = pmdb; <br>    if(pmdb) <br>        pmdb-&gt;AddRef(); <br>} <br> <br> <br>// <br>//  CChsFldDlg::HrPick <br>// <br>// The outmost method. <br>// <br>HRESULT CChsFldDlg::HrPick(LPCTSTR lpTemplateName, HWND hWnd, <br>                DLGPROC pfnDlgProc, LPMAPIFOLDER * ppfld, LPMDB *ppmdb) <br>{ <br>    if(-1 == DialogBoxParam(m_hInst, lpTemplateName, hWnd, pfnDlgProc, (LPARAM) this)) <br>    { <br>        DebugTraceSc(CChsDldDlg::HrPick, MAPI_E_NOT_ENOUGH_MEMORY); <br>        return MAPI_E_NOT_ENOUGH_MEMORY; <br>    } <br> <br>    //m_hr is set inside the dialog <br>    if(HR_SUCCEEDED(m_hr)) <br>    { <br>        Assert(m_pfld); <br>        m_pfld-&gt;AddRef(); <br>        *ppfld = m_pfld; <br> <br>        Assert(m_pmdb); <br>        m_pmdb-&gt;AddRef(); <br>        *ppmdb = m_pmdb; <br>    } <br> <br>    return m_hr; <br>} <br> <br>// <br>//  CChsFldDlg::HrInitTree <br>// <br>// Called from WM_INITDIALOG. Opens all message stores in the profile and <br>// puts the IPM subtrees in the tree control <br>// <br>HRESULT CChsFldDlg::HrInitTree(HWND hDlg, HWND hwTreeCtl) <br>{ <br>    HRESULT     hr; <br>    LPSPropValue pval = NULL; <br>    LPTVNODE    pNode = NULL; <br>    HTREEITEM   hiRoot = NULL; <br>    HICON       hIcon = NULL; <br>     <br>    Assert(hDlg); <br>    Assert(hwTreeCtl); <br> <br>    m_hwTreeCtl = hwTreeCtl; <br>    m_hDlg      = hDlg; <br>     <br> <br>    // <br>    // Set up the image list <br>    // <br>    m_hIml = ImageList_Create(cImageWidth, cImageHeight, ILC_MASK,  <br>                            cImages, 0); <br>    if(!m_hIml) <br>    { <br>        hr = MAPI_E_NOT_ENOUGH_MEMORY; <br>        goto err; <br>    } <br> <br>    hIcon = LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_ALLSTORES)); <br>    m_iIconAllStores = ImageList_AddIcon(m_hIml, hIcon); <br>     <br>    hIcon = LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_ROOTFLD)); <br>    m_iIconRootFld = ImageList_AddIcon(m_hIml, hIcon); <br>     <br>    hIcon = LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_OPENFLD)); <br>    m_iIconOpenFld = ImageList_AddIcon(m_hIml, hIcon); <br>     <br>    hIcon = LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_CLSDFLD)); <br>    m_iIconClsdFld = ImageList_AddIcon(m_hIml, hIcon); <br> <br>    if(ImageList_GetImageCount(m_hIml) &lt; cImages) <br>    { <br>        hr = MAPI_E_NOT_ENOUGH_MEMORY; <br>        goto err; <br>    } <br> <br> <br>    TreeView_SetImageList(hwTreeCtl, m_hIml, TVSIL_NORMAL); <br>     <br>    // <br>    // create the root tree node <br>    // (fake a GetProps) <br>    // <br>    hr = MAPIAllocateBuffer(nhtProps * sizeof(SPropValue), <br>                        (LPVOID *)&amp;pval); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(hr); <br>        m_lsterr.ShowError(hDlg); <br>             <br>        goto err; <br>    } <br>     <br> <br>    ZeroMemory(pval, nhtProps * sizeof(SPropValue)); <br> <br>    //Set  proptags to make CNode constructor happy <br>    pval[iEID].ulPropTag = PR_ENTRYID; <br>    pval[iDispName].ulPropTag = PR_DISPLAY_NAME; <br>    pval[iDispName].Value.lpszA = g_szAllStores; <br>    pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS; <br> <br>    hr = HrCreateNode(pval, nhtProps, NULL, &amp;pNode); <br>    if(hr) <br>        goto err; <br> <br>    Assert(pNode); <br>     <br>    pval = NULL; //will be freed in ~CTVNode <br> <br>    hiRoot = AddOneItem(NULL, TVI_ROOT, m_iIconAllStores, m_iIconAllStores, <br>                            hwTreeCtl, pNode, 1); <br>    if(!hiRoot) <br>    { <br>        hr = MAPI_E_NOT_ENOUGH_MEMORY; <br>        goto err; <br>    } <br>     <br>    pNode-&gt;SetKidsLoaded(TRUE); <br>     <br>    m_hiRoot = hiRoot; <br>     <br>    // <br>    //  Put the IPM subtrees of all the message stores in <br>    // <br>    hr = HrLoadRoots(); <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    (void)HrRestoreTreeState(); <br>         <br>err: <br>    MAPIFreeBuffer(pval); <br> <br>    DebugTraceResult(CChsFldDlg::HrInitTree, hr); <br>    return hr; <br>} <br> <br> <br>// <br>//  CChsFldDlg::HrLoadRoots <br>// <br>HRESULT CChsFldDlg::HrLoadRoots(void) <br>{ <br>    HRESULT hr; <br>    LPMAPITABLE ptblMStrs = NULL; <br>    UINT ind; <br>    LPSRowSet pRows = NULL; <br>    static SSortOrderSet sosName; <br> <br>    sosName.cSorts = 1; <br>    sosName.cCategories = 0; <br>    sosName.cExpanded = 0; <br>    sosName.aSort[0].ulPropTag = PR_DISPLAY_NAME; <br>    sosName.aSort[0].ulOrder = TABLE_SORT_ASCEND; <br> <br>         <br>    //Get Message Store Table <br>    hr = m_pses-&gt;GetMsgStoresTable(0, &amp;ptblMStrs); <br>    if(hr) <br>    { <br>        m_lsterr.HrSetLastError(hr, m_pses); <br>        m_lsterr.ShowError(m_hDlg); <br> <br>        goto err; <br>    } <br> <br>    //For each msg store insert a node corresponding to PR_IPM_SUBTREE <br> <br>    hr = HrQueryAllRows(ptblMStrs, (LPSPropTagArray) &amp;spthtProps, NULL, <br>                        &amp;sosName, 0, &amp;pRows); <br>                         <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    if(0 ==  pRows-&gt;cRows)  //$ No stores <br>    { <br>        MessageBox(m_hDlg, <br>                    "No message stores in the profile", <br>                    g_szModuleName, <br>                    MB_OK); <br>        hr = E_FAIL; <br>    } <br>     <br>    for(ind = 0; ind &lt; pRows-&gt;cRows; ++ind) <br>    { <br>        LPSPropValue pval = pRows-&gt;aRow[ind].lpProps; <br>        Assert(pRows-&gt;aRow[ind].cValues == nhtProps); <br>        Assert(pval[iEID].ulPropTag == PR_ENTRYID); <br> <br>        pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS; <br>        pval[iSubfldrs].Value.b = TRUE; <br> <br>        //pval is consumed by this function <br>        hr = HrInsertRoot(pval); <br>        pRows-&gt;aRow[ind].cValues = 0; <br>        pRows-&gt;aRow[ind].lpProps = NULL; <br>        if(FAILED(hr)) <br>            goto err; <br>         <br>    } <br> <br>     <br>         <br>err: <br>    FreeProws(pRows); <br>    UlRelease(ptblMStrs); <br> <br>    DebugTraceResult(CChsFldDlg::HrLoadRoots, hr); <br>    return hr; <br>} <br> <br>// <br>//  CChsFldDlg::HrInsertRoot <br>// <br>// Put the IPM subtree of the msg store in the tree control <br>//  pval is consumed <br>// <br>HRESULT CChsFldDlg::HrInsertRoot(LPSPropValue pval) <br>{ <br>    HRESULT hr; <br>    HTREEITEM hItem; <br> <br> <br>    Assert(m_hiRoot); <br>     <br>     <br>    LPTVNODE pNode = NULL; <br>    hr = HrCreateNode(pval, nhtProps, NULL, &amp;pNode); <br>    if(hr) <br>    { <br>        MAPIFreeBuffer(pval); <br>        goto err; <br>    } <br> <br>    Assert(pNode); <br>    pval = NULL; <br> <br>         <br>    hItem = AddOneItem(m_hiRoot, TVI_LAST, m_iIconRootFld, m_iIconRootFld, <br>                            m_hwTreeCtl, pNode, 1); <br>    if(!hItem) <br>    { <br>        hr = MAPI_E_NOT_ENOUGH_MEMORY; <br>        goto err; <br>    } <br>             <br>         <br>err: <br> <br>    DebugTraceResult(CChsFldDlg::HrInsertRoots, hr); <br>    return hr; <br>} <br> <br> <br>// <br>//  CChsFldDlg::HrSaveTreeState <br>// <br>// Save expand - collapse state of the tree control <br>// <br>HRESULT CChsFldDlg::HrSaveTreeState(void) <br>{ <br>    HRESULT hr; <br> <br>    if(!m_pcbState || !m_ppbState) <br>        return hrSuccess; <br> <br>    MAPIFreeBuffer(*m_ppbState); <br>    *m_ppbState = NULL; <br>    *m_pcbState = 0; <br>     <br>    hr = HrSaveTreeStateEx(FALSE, m_pcbState, NULL); <br>    if(hr) <br>        goto err; <br> <br>    DebugTrace("ChsFld: size of state data: %ld\n", *m_pcbState); <br>     <br>    hr = HrSaveTreeStateEx(TRUE, m_pcbState, m_ppbState); <br>     <br>err: <br>    DebugTraceResult(CChsFldDlg::HrSaveTreeState, hr); <br>    return hr; <br>} <br> <br>// <br>//  CChsFldDlg::HrSaveTreeStateEx <br>// <br>// Save expand - collapse state of the tree control <br>// <br>HRESULT CChsFldDlg::HrSaveTreeStateEx(BOOL fWrite, ULONG * pcb, LPBYTE * ppb) <br>{ <br>    HRESULT hr = hrSuccess; <br>    CTIStack tiStack; <br>    HTREEITEM hti; <br>    LPBYTE pb = NULL; <br>    LPBYTE pBuffer = NULL; <br>    LONG iLevel; <br> <br>    if(fWrite) <br>    { <br>        if(*pcb == 0) <br>        { <br>            *ppb = NULL; <br>            return hrSuccess; <br>        } <br>        else <br>        { <br>            hr = MAPIAllocateBuffer(*pcb, (LPVOID *) &amp;pBuffer); <br>            if (hr) <br>            { <br>                *pcb = 0; <br>                return hr; <br>            } <br>            pb = pBuffer; <br>        } <br>    } <br> <br>    hti = TreeView_GetRoot(m_hwTreeCtl); <br>    iLevel = 0; <br>    tiStack.Push(NULL); <br> <br>    while(hti) <br>    { <br>        Assert(iLevel &gt;= 0); <br>         <br>        while(hti) <br>        { <br>            TV_ITEM tvi; <br>             <br>            tvi.hItem = hti; <br>            tvi.mask = TVIF_STATE | TVIF_PARAM; <br>            tvi.lParam = 0; <br>            tvi.state = 0; <br>            tvi.stateMask = TVIS_EXPANDED; <br> <br>            if(!TreeView_GetItem(m_hwTreeCtl, &amp;tvi)) <br>            { <br>                hr = E_FAIL; <br>                goto err; <br>            } <br> <br>            if(tvi.state &amp; TVIS_EXPANDED) <br>            { <br>                HTREEITEM htiChild = TreeView_GetChild(m_hwTreeCtl, hti); <br> <br>                if(htiChild) <br>                { <br>                    LPTVNODE pNode = (LPTVNODE) tvi.lParam; <br>                    Assert(pNode); <br> <br>                    pNode-&gt;Write(fWrite, iLevel, &amp;pb); <br> <br>                    HTREEITEM htiNextSibl = TreeView_GetNextSibling(m_hwTreeCtl, hti); <br> <br>                    tiStack.Push(htiNextSibl); <br> <br>                    hti = htiChild; <br>                    ++iLevel; <br> <br>                    continue; <br>                } <br> <br>            } <br> <br>            hti = TreeView_GetNextSibling(m_hwTreeCtl, hti); <br>        } <br> <br>        do <br>        { <br>            hti = tiStack.Pop(); <br>            --iLevel; <br>             <br>        }while(!tiStack.IsEmpty() &amp;&amp; hti == NULL); <br>    } <br> <br>    Assert(iLevel == -1); <br> <br>    *pcb = pb - pBuffer; <br>    if(pBuffer) <br>        *ppb = pBuffer; <br>     <br>err: <br>    DebugTraceResult(CChsFldDlg::HrSaveTreeStateEx, hr); <br>    return hr; <br>} <br> <br>inline LONG GetLevel(LPBYTE * ppb) <br>{ <br>    LONG level = *((LONG *) *ppb); <br> <br>    *ppb += sizeof(LONG); <br> <br>    return level; <br>} <br> <br>inline ULONG GetCb(LPBYTE * ppb) <br>{ <br>    ULONG cb = *((ULONG *) *ppb); <br> <br>    *ppb += sizeof(ULONG); <br> <br>    return cb; <br>} <br> <br>HTREEITEM HtiFindChild(HWND hwTreeCtl, HTREEITEM hti, ULONG cb, <br>                    LPENTRYID pbEID, CChsFldDlg *pCFDlg, LPTVNODE *ppNode) <br>{ <br>    HRESULT hr; <br>    HTREEITEM htiChild; <br> <br>    htiChild = TreeView_GetChild(hwTreeCtl, hti); <br>     <br>    while(htiChild) <br>    { <br>        TV_ITEM tvi; <br>         <br>        tvi.hItem = htiChild; <br>        tvi.mask = TVIF_PARAM; <br>        tvi.lParam = 0; <br> <br>        if(!TreeView_GetItem(hwTreeCtl, &amp;tvi)) <br>            return NULL; <br> <br>        LPTVNODE pNode = (LPTVNODE) tvi.lParam; <br>        Assert(pNode); <br> <br>        ULONG ulMatch = 0; <br>        hr = pCFDlg-&gt;Session()-&gt;CompareEntryIDs(cb, pbEID, <br>                            pNode-&gt;m_pval[iEID].Value.bin.cb, <br>                            (LPENTRYID)pNode-&gt;m_pval[iEID].Value.bin.lpb, <br>                            0, &amp;ulMatch); <br>        if(SUCCEEDED(hr)) <br>        { <br>            if(ulMatch) <br>            { <br>                *ppNode = pNode; <br>                return htiChild; <br>            } <br>        } <br> <br>        htiChild = TreeView_GetNextSibling(hwTreeCtl, htiChild); <br>    } <br> <br>    return htiChild; <br>} <br> <br>// <br>//  CChsFldDlg::HrRestoreTreeState <br>// <br>HRESULT CChsFldDlg::HrRestoreTreeState(void) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPBYTE pb; <br>    LPBYTE pbMax; <br>    CTIStack tiStack; <br>    HTREEITEM hti; <br>    LONG iLevel = 0; <br>    BOOL fNodeMissing = FALSE; <br> <br>    if(!m_pcbState  || *m_pcbState == 0) <br>        return hrSuccess; <br> <br>    try //protect ourself from callers who mess with the state data <br>    { <br>    Assert(m_hwTreeCtl); <br> <br>    Assert(m_ppbState); <br>    pb = *m_ppbState; <br> <br>    pbMax = pb + *m_pcbState; <br>     <br>    hti = TreeView_GetRoot(m_hwTreeCtl); <br> <br>    iLevel = GetLevel(&amp;pb); <br>    Assert(iLevel == 0); <br> <br>    TreeView_Expand(m_hwTreeCtl, hti, TVE_EXPAND); <br>     <br>    while(hti) <br>    { <br>        if(pb &gt;= pbMax) <br>            break; //done <br>             <br>        LONG iNewLevel = GetLevel(&amp;pb); <br> <br>        if(iNewLevel &lt;= iLevel) <br>        { <br>            do <br>            { <br>                hti = tiStack.Pop(); <br>                --iLevel; <br>            }while(iLevel &gt;= iNewLevel); <br> <br>            Assert(hti); <br>        } <br> <br>        if(iNewLevel &gt; iLevel) <br>        { <br>            if(!fNodeMissing) <br>                Assert(iNewLevel == iLevel + 1); <br> <br>            ULONG cbEID = GetCb(&amp;pb); <br>            LPENTRYID pbEID = (LPENTRYID)pb; <br>            pb += Align4(cbEID); <br> <br>            if(iNewLevel != iLevel +1) <br>                continue; <br>                 <br>            LPTVNODE pNodeChild = NULL; <br>            HTREEITEM htiChild = HtiFindChild(m_hwTreeCtl, hti, cbEID, pbEID, <br>                                            this, &amp;pNodeChild); <br>            if(htiChild) <br>            { <br>                fNodeMissing = FALSE; <br>                 <br>                hr = pNodeChild-&gt;HrExpand(this); <br>                if(FAILED(hr)) <br>                    goto err; <br> <br>                TreeView_Expand(m_hwTreeCtl, htiChild, TVE_EXPAND); <br>                 <br>                tiStack.Push(hti); <br> <br>                hti = htiChild; <br>                ++iLevel; <br> <br>                continue; <br>            } <br>            else <br>            { <br>                //Assert(FALSE); //$ handle <br>                fNodeMissing = TRUE; <br>            } <br> <br>        } <br>        /*else <br>        { <br>            do <br>            { <br>                hti = tiStack.Pop(); <br>                --iLevel; <br>            }while(iLevel &gt;= iNewLevel); <br>        }*/ <br>    } <br>    } <br> <br>    catch(...) <br>    { <br>        DebugTrace("chsfld: Exception caught in HrRestoreTreeState\n"); <br>        hr = E_FAIL; <br>    } <br>     <br>err: <br> <br>    /*MAPIFreeBuffer(*m_ppbState); <br>    *m_ppbState = NULL; <br>    *m_pcbState = 0;*/ <br>     <br>     <br>    DebugTraceResult(CChsFldDlg::HrRestoreTreeState, hr); <br>    return hr; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////////////// <br>// CTVNodeFactory <br> <br>// <br>//  CTVNodeFactory::CTVNodeFactory <br>// <br>inline CTVNodeFactory::CTVNodeFactory() <br>{ <br>    m_pHead = NULL; <br>} <br> <br>// <br>//  CTVNodeFactory::~CTVNodeFactory <br>// <br>//  Destroy all created CTVNode s <br>CTVNodeFactory::~CTVNodeFactory() <br>{ <br>    while(m_pHead) <br>    { <br>        LPTVNODE ptemp = m_pHead; <br> <br>        m_pHead = m_pHead-&gt;m_pNext; <br> <br>        delete ptemp; <br>    } <br>} <br> <br> <br>// <br>//  CTVNodeFactory::HrCreateNode <br>// <br>// All instances of CTVNode are created through this method <br>// <br>HRESULT CTVNodeFactory::HrCreateNode(LPSPropValue pval, ULONG cVals, LPMDB pmdb, <br>                                        LPTVNODE * pptvNode) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    LPTVNODE pNode = new CTVNode(pval, cVals, pmdb); <br>     <br>    if(!pNode) <br>    { <br>        hr = MAPI_E_NOT_ENOUGH_MEMORY; <br>        goto err; <br>    } <br> <br>    Insert(pNode); <br> <br>    *pptvNode = pNode; <br>             <br>err: <br> <br>    DebugTraceResult(CTVNodeFactory::HrCreateNode, hr); <br>    return hr; <br>} <br> <br> <br>// <br>//  CTVNodeFactory::Insert <br>// <br>// Store all created CTVNode s so that we can destroy them when we are done <br>// <br>void CTVNodeFactory::Insert(LPTVNODE pNode) <br>{ <br>    pNode-&gt;m_pNext = m_pHead; <br>    m_pHead = pNode; <br>} <br> <br> <br>// <br>//  ChsFldDlgProc <br>// <br>// Dialog proc for the choose folder dialog <br>// <br>//  Controls: <br>//          IDOK        "OK" <br>//          IDCANCEL    "Cancel" <br>//          IDC_NEWFLD  "New Folder" <br>// <br>BOOL CALLBACK <br>ChsFldDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    HRESULT hr; <br>    CChsFldDlg * pCDlg = NULL; <br>    HWND hwTreeCtl = NULL; <br>    int wmId; <br>    int wmEvent; <br>    HTREEITEM hti = NULL; <br>    TV_ITEM tvi; <br>         <br>    switch(msg) <br>    { <br>    case WM_INITDIALOG: <br>        Assert(lParam); <br>        pCDlg = (CChsFldDlg *)lParam; <br> <br>        hwTreeCtl = GetDlgItem(hDlg, IDC_TREEVIEW); <br>        Assert(hwTreeCtl); <br> <br>        hr = pCDlg-&gt;HrInitTree(hDlg, hwTreeCtl); <br>        if(HR_FAILED(hr)) <br>        { <br>            pCDlg-&gt;SetError(hr); <br>            EndDialog(hDlg, 1); <br>            break; <br>        } <br> <br>        SetWindowLong(hDlg, DWL_USER, (LONG)pCDlg); <br> <br>        break; <br> <br>    case WM_COMMAND: <br>        wmId = GET_WM_COMMAND_ID(wParam, lParam);   <br>        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam); <br> <br>        hwTreeCtl = GetDlgItem(hDlg, IDC_TREEVIEW); <br>        Assert(hwTreeCtl); <br> <br>        pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER); <br>        Assert(pCDlg); <br> <br> <br>        switch(wmId) <br>        { <br>        case IDOK: <br>            switch (wmEvent) <br>            { <br>            case BN_CLICKED: <br>                         <br>                hti = TreeView_GetSelection(hwTreeCtl); <br>                AssertSz(hti, "No Selection?"); <br> <br>                tvi.hItem = hti; <br>                tvi.mask = TVIF_PARAM; <br> <br>                if(TreeView_GetItem(hwTreeCtl, &amp;tvi)) <br>                { <br>                    LPTVNODE pNode = (LPTVNODE)tvi.lParam; <br>                    Assert(pNode); <br> <br>                    LPMAPIFOLDER pfld = NULL; <br>                    LPMDB pmdb = NULL; <br> <br>                    hr = pNode-&gt;HrGetFolder(pCDlg, &amp;pfld, &amp;pmdb); <br>                    if(HR_SUCCEEDED(hr)) <br>                    { <br>                        pCDlg-&gt;SetFolder(pfld, pmdb); <br>                        pfld-&gt;Release(); <br>                        pmdb-&gt;Release(); <br> <br>                        hr = pCDlg-&gt;HrSaveTreeState();                   <br>                    } <br>                    else <br>                    { <br>                        pCDlg-&gt;SetError(hr); <br>                    } <br>                } <br>                else <br>                { <br>                    pCDlg-&gt;SetError(E_FAIL); <br>                } <br> <br>                EndDialog(hDlg, TRUE); <br> <br>                break; <br> <br>            default: <br>                return FALSE; <br>            } <br>            break; <br> <br>        case IDC_NEWFLD: <br>            switch(wmEvent) <br>            { <br>            case BN_CLICKED: <br>                 <br>                hti = TreeView_GetSelection(hwTreeCtl); <br>                AssertSz(hti, "No Selection?"); <br> <br>                tvi.hItem = hti; <br>                tvi.mask = TVIF_PARAM; <br> <br>                if(TreeView_GetItem(hwTreeCtl, &amp;tvi)) <br>                { <br>                    LPTVNODE pNode = (LPTVNODE)tvi.lParam; <br>                    Assert(pNode); <br>                    LPSTR szName = NULL; <br>                     <br>                    do <br>                    { <br>                        hr = HrGetNewName(pCDlg-&gt;hInst(), hDlg, &amp;szName); <br>                        if(HR_SUCCEEDED(hr)) <br>                        { <br>                            hr = pNode-&gt;HrNewFolder(pCDlg, szName); <br>                        } <br>                    }while(hr == MAPI_E_COLLISION); <br> <br>                    MAPIFreeBuffer(szName); <br>                    szName = NULL; <br> <br>                } <br> <br>                SetFocus(hwTreeCtl); <br> <br>                break; <br> <br>            default: <br>                return FALSE; <br>            } <br>            break; <br>     <br>        case IDCANCEL: <br>            switch(wmEvent) <br>            { <br>            case BN_CLICKED: <br> <br>                pCDlg-&gt;SetError(MAPI_E_USER_CANCEL); <br> <br>                EndDialog(hDlg, TRUE); <br>                break; <br> <br>            default: <br>                return FALSE; <br>            } <br>            break; <br>        } <br>        break; <br>         <br>    case WM_NOTIFY: <br>        switch( ((LPNMHDR)lParam)-&gt;code) <br>        { <br>        case TVN_ITEMEXPANDING: <br>            { <br>            Assert(((LPNMHDR)lParam)-&gt;idFrom == IDC_TREEVIEW); <br> <br>            NM_TREEVIEW * ptntv = (NM_TREEVIEW *)lParam; <br> <br>            if(ptntv-&gt;action != TVE_EXPAND) <br>                return FALSE; <br> <br>            // <br>            // If the kids of this node are not loaded, load'em  <br>            LPTVNODE pNode = (LPTVNODE)ptntv-&gt;itemNew.lParam; <br>            Assert(pNode); <br> <br>            hwTreeCtl = ((LPNMHDR)lParam)-&gt;hwndFrom; <br>             <br>            pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER); <br>            //Assert(pCDlg); <br> <br>            hr = pNode-&gt;HrExpand(pCDlg);   <br>            if(HR_FAILED(hr)) <br>            { <br>                return TRUE; <br>            } <br>                return FALSE; <br>            }    <br>            break; <br>        case TVN_GETDISPINFO: <br>            { <br>            Assert(((LPNMHDR)lParam)-&gt;idFrom == IDC_TREEVIEW); <br> <br>            // <br>            // we don't give folder names to the tree control (to save space) <br>            // when it wants to display an item, it asks us for the name <br>            // <br>            TV_DISPINFO * pdi = (TV_DISPINFO *)lParam; <br> <br>            if(pdi-&gt;item.mask &amp; TVIF_TEXT) <br>            { <br>                pdi-&gt;item.pszText = ((LPTVNODE)pdi-&gt;item.lParam)-&gt;GetName(); <br>                return TRUE; <br>            } <br>            else <br>            { <br>                return FALSE; <br>            } <br>            } <br> <br>            break; <br>             <br>        case TVN_SELCHANGED: <br>            // <br>            //Enable "OK" and "New Folder" buttons only if it is not the  <br>            //root node <br>            // <br>            {Assert(((LPNMHDR)lParam)-&gt;idFrom == IDC_TREEVIEW); <br> <br>            NM_TREEVIEW *ptntv = (NM_TREEVIEW *)lParam; <br> <br>            pCDlg = (CChsFldDlg *)GetWindowLong(hDlg, DWL_USER); <br>            Assert(pCDlg); <br>     <br>            EnableWindow(GetDlgItem(hDlg, IDOK), <br>                        !pCDlg-&gt;IsTreeRoot(ptntv-&gt;itemNew.hItem)); <br>            EnableWindow(GetDlgItem(hDlg, IDC_NEWFLD), <br>                        !pCDlg-&gt;IsTreeRoot(ptntv-&gt;itemNew.hItem)); <br>            break; <br>            } <br>             <br>            break; <br>        } <br>         <br>        break; <br>         <br>    default: <br>        return FALSE;    <br>    } <br>    return TRUE; <br>} <br> <br>// <br>//  AddOneItem <br>// <br>// Add a node to the tree control <br>// <br>HTREEITEM AddOneItem( HTREEITEM hParent, HTREEITEM hInsAfter,  <br>    int iImage, int iImageSel, HWND hwndTree, LPTVNODE pNode, int cKids) <br>{ <br>    HTREEITEM hItem; <br>    TV_INSERTSTRUCT tvIns; <br> <br>    tvIns.item.mask             = TVIF_CHILDREN | TVIF_PARAM |TVIF_TEXT | <br>                                    TVIF_IMAGE | TVIF_SELECTEDIMAGE; <br>    tvIns.item.pszText          = LPSTR_TEXTCALLBACK; <br>    tvIns.item.cchTextMax       = 0; <br>    tvIns.item.lParam           = (LPARAM)pNode; <br>    tvIns.item.cChildren        = cKids; <br>    tvIns.item.iImage           = iImage; <br>    tvIns.item.iSelectedImage   = iImageSel; <br> <br>    tvIns.hInsertAfter = hInsAfter; <br>    tvIns.hParent = hParent; <br>     <br>    // Insert the item into the tree. <br>    hItem = TreeView_InsertItem(hwndTree, &amp;tvIns); <br> <br>    pNode-&gt;SetHandle(hItem); <br> <br>    return (hItem); <br>} <br> <br> <br>// <br>//  HrGetNewName <br>// <br>//  Display dialog asking the user for a new folder name  <br>// <br>//  If *pszNewName is not NULL, it has to be a string allocated with <br>//  MAPIAllocateBuffer. It will be displayed in the dialog. <br>//  The returned string has to be freed with MAPIFreeBuffer. <br>// <br>HRESULT HrGetNewName(HINSTANCE hInst, HWND hwParent, LPSTR * pszNewName) <br>{ <br>    Assert(pszNewName); <br>     <br>    int nRes = DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_NEWNAME), hwParent, <br>                        NewNameDlgProc, (LPARAM)pszNewName); <br>    if(nRes == 1) <br>    { <br>        return hrSuccess; <br>    } <br>    else <br>    { <br>        DebugTraceSc(HrGetNewName, E_FAIL); <br>        return E_FAIL; <br>    } <br>} <br> <br> <br>// <br>// NewNameDlgProc <br>// <br>// Dlg proc for the "New Name" dialog; <br>// If user chooses OK, return 1 from EndDialog. <br>// <br>BOOL CALLBACK <br>NewNameDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    int wmId; <br>    int wmEvent; <br> <br>    switch(msg) <br>    { <br>    case WM_INITDIALOG: <br>        { <br>        Assert(lParam); <br> <br>        LPSTR * pszName = (LPSTR *)lParam; <br> <br>        if(*pszName) <br>        { <br>            SetWindowText(GetDlgItem(hDlg, IDC_NAME), *pszName); <br>            MAPIFreeBuffer(*pszName); <br>            *pszName = NULL; <br> <br>        } <br>         <br>        SetWindowLong(hDlg, DWL_USER, (LONG)lParam); <br>        SetFocus(GetDlgItem(hDlg, IDC_NAME)); <br>        return FALSE; <br>        } <br>        break; <br> <br>    case WM_COMMAND: <br>        wmId = GET_WM_COMMAND_ID(wParam, lParam);   <br>        wmEvent = GET_WM_COMMAND_CMD(wParam, lParam); <br> <br>        switch(wmId) <br>        { <br>        case IDOK: <br>            switch (wmEvent) <br>            { <br>            case BN_CLICKED: <br>                { <br>                HWND hwName = GetDlgItem(hDlg, IDC_NAME); <br>                 <br>                int cb = Edit_GetTextLength(hwName); <br>                Assert(cb); //OK is disabled when edit control is empty <br> <br>                LPSTR szName = NULL; <br>                if(!MAPIAllocateBuffer(cb + 1, (LPVOID *)&amp;szName)) <br>                { <br>                    GetWindowText(hwName, szName, cb+1); <br> <br>                    LPSTR * pszName = (LPSTR *)GetWindowLong(hDlg, DWL_USER); <br> <br>                    *pszName = szName; <br> <br>                    EndDialog(hDlg, 1); <br>                } <br>                else <br>                { <br>                    EndDialog(hDlg, FALSE); <br>                    break; <br>                } <br>                } <br>                break; <br> <br>            default: </code></pre>
<p>
</p>
<pre><code>return FALSE; <br>            } <br>             <br>            break; <br> <br>        case IDCANCEL: <br>            switch (wmEvent) <br>            { <br>            case BN_CLICKED: <br>                EndDialog(hDlg, FALSE); <br>                break; <br> <br>            default: <br>                return FALSE; <br>            } <br>             <br>            break; <br> <br>        case IDC_NAME: <br>            switch(wmEvent) <br>            { <br>            case EN_CHANGE: <br>                Assert((HWND)lParam == GetDlgItem(hDlg, IDC_NAME)); <br> <br>                EnableWindow(GetDlgItem(hDlg, IDOK), <br>                            Edit_GetTextLength((HWND)lParam)); <br> <br>                break; <br> <br>            default: <br>                return FALSE; <br>            } <br>                 <br>            break; <br>        } <br>    default: <br>        return FALSE; <br>    }    <br>         <br>    return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
