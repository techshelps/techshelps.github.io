<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TVNODE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2051"></a>TVNODE.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////// <br>// <br>//  TVNODE.CPP <br>// <br>// <br>//  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved. <br>/////////////////////////////////////////////////////////////////////// <br> <br> <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include "lasterr.h" <br>#include "tvdlg.h" <br> <br> <br>LPSTR g_szNoFolderName = "&lt;No Name&gt;"; <br> <br>// <br>//  CTVNode::CTVNode <br>// <br>CTVNode::CTVNode(LPSPropValue pval, ULONG cProps, LPMDB pmdb) <br>{ <br>    Assert(cProps == nhtProps); <br>    Assert(pval); <br> <br>    m_pval = pval; <br> <br>    m_htiMe = NULL; <br>         <br>    m_fKidsLoaded = FALSE; <br> <br>    m_pfld = NULL; <br> <br>    m_pNext = NULL; <br> <br>    m_pmdb = pmdb; <br>    if(pmdb) <br>        pmdb-&gt;AddRef(); <br> <br>} <br> <br>// <br>//  CTVNode::~CTVNode <br>// <br>CTVNode::~CTVNode() <br>{ <br>    MAPIFreeBuffer(m_pval); <br>    UlRelease(m_pfld); <br>    UlRelease(m_pmdb); <br>} <br> <br> <br>// <br>//  CTVNode::HrExpand <br>// <br>//  Put all kids of the given folder in the tree control <br>// <br>HRESULT CTVNode::HrExpand(CChsFldDlg * pCFDlg) <br>{ <br>    HRESULT hr; <br>    LPMAPITABLE ptblHier = NULL; <br>    LPSRowSet pRowSet = NULL; <br>    UINT ind; <br>     <br>    static SSortOrderSet sosName; <br> <br>    sosName.cSorts = 1; <br>    sosName.cCategories = 0; <br>    sosName.cExpanded = 0; <br>    sosName.aSort[0].ulPropTag = PR_DISPLAY_NAME; <br>    sosName.aSort[0].ulOrder = TABLE_SORT_ASCEND; <br> <br> <br>    Assert(m_htiMe); <br>     <br>    if(m_fKidsLoaded || !m_pval[iSubfldrs].Value.b) <br>        return hrSuccess; <br> <br>    if(!m_pmdb) <br>    { <br>    // this node corresponds to the top level of a message store which has <br>    // not been opend yet. <br>    // m_pval[iEID] contains entry ID of the message store <br>    //  <br>        hr = HrOpenMDB(pCFDlg); <br>        if(FAILED(hr)) <br>            goto err; <br>    } <br>     <br>    Assert(m_pmdb);      <br>     <br>    if(!m_pfld) <br>    { <br>        hr = HrOpenFolder(pCFDlg); <br>        if(FAILED(hr)) <br>            goto err; <br>    } <br> <br>    Assert(m_pfld);  <br>     <br>    hr = m_pfld-&gt;GetHierarchyTable(MAPI_DEFERRED_ERRORS, &amp;ptblHier); <br>    if(HR_FAILED(hr)) <br>    { <br>        pCFDlg-&gt;m_lsterr.HrSetLastError(hr, m_pfld); <br>        pCFDlg-&gt;m_lsterr.ShowError(pCFDlg-&gt;hwDialog()); <br>         <br>        goto err; <br>    } <br> <br>    hr = HrQueryAllRows(ptblHier, (LPSPropTagArray)&amp;spthtProps, NULL, &amp;sosName, <br>                        0, &amp;pRowSet); <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    if(0 == pRowSet-&gt;cRows) <br>    { <br>        m_pval[iSubfldrs].Value.b = FALSE; <br>        goto err; <br>    } <br> <br>    for(ind = 0; ind &lt; pRowSet-&gt;cRows; ++ind) <br>    { <br>        LPSPropValue pval = pRowSet-&gt;aRow[ind].lpProps; <br>         <br>        Assert(pRowSet-&gt;aRow[ind].cValues == nhtProps); <br>        Assert(pval[iEID].ulPropTag == PR_ENTRYID); <br>        Assert(pval[iDispName].ulPropTag == PR_DISPLAY_NAME); <br>        Assert(pval[iSubfldrs].ulPropTag == PR_SUBFOLDERS); <br> <br>        LPTVNODE pNode = NULL; <br> <br>        hr = pCFDlg-&gt;HrCreateNode(pval, nhtProps, m_pmdb, &amp;pNode); <br>        if(hr) <br>            goto err; <br>     <br>        //this row will be freed in ~CTVNode <br>        pRowSet-&gt;aRow[ind].cValues = 0; <br>        pRowSet-&gt;aRow[ind].lpProps = NULL; <br> <br>        HTREEITEM hItem; <br>         <br>        hItem = AddOneItem(m_htiMe,  TVI_LAST, pCFDlg-&gt;IndClsdFld(), <br>                            pCFDlg-&gt;IndOpenFld(), pCFDlg-&gt;hwTreeCtl(), pNode, <br>                            pval[iSubfldrs].Value.b? 1: 0); <br>        if(!hItem) <br>        { <br>            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY); <br>            goto err; <br>        } <br>             <br>    } <br> <br>    m_fKidsLoaded = TRUE; <br> <br>err: <br>    UlRelease(ptblHier); <br>    FreeProws(pRowSet); <br> <br>    DebugTraceResult(CTVNode::HrExpand, hr); <br>    return hr; <br>} <br> <br>// <br>//  CTVNode::HrOpenMDB <br>// <br>HRESULT CTVNode::HrOpenMDB(CChsFldDlg * pCFDlg) <br>{ <br>    HRESULT hr; <br>    LPMDB pmdb = NULL; <br>    LPSPropValue pvalIPM = NULL; <br>    ULONG ulObjType; <br>     <br>    Assert(m_pval[iEID].ulPropTag == PR_ENTRYID); <br> <br>    DebugTrace("ChsFld: Openning Msg Store: %s\n", GetName()); <br>     <br>    hr = pCFDlg-&gt;Session()-&gt;OpenMsgStore(0L, m_pval[iEID].Value.bin.cb, <br>                                (LPENTRYID)m_pval[iEID].Value.bin.lpb, <br>                                NULL, MAPI_BEST_ACCESS, &amp;pmdb); <br>    if(hr) //Display warning messages too <br>    { <br>        pCFDlg-&gt;m_lsterr.HrSetLastError(hr, pCFDlg-&gt;Session()); <br>        pCFDlg-&gt;m_lsterr.ShowError(pCFDlg-&gt;hwDialog()); <br>    } <br> <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    hr = HrGetOneProp(pmdb, PR_IPM_SUBTREE_ENTRYID, &amp;pvalIPM); <br>    if(hr) <br>    { <br>        pCFDlg-&gt;m_lsterr.HrSetLastError(hr, pmdb); <br>        pCFDlg-&gt;m_lsterr.ShowError(pCFDlg-&gt;hwDialog()); <br> <br>        goto err; <br>    } <br> <br>    hr = pmdb-&gt;OpenEntry(pvalIPM-&gt;Value.bin.cb, <br>                (LPENTRYID)pvalIPM-&gt;Value.bin.lpb, <br>                NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>                 &amp;ulObjType, (LPUNKNOWN *) &amp;m_pfld); <br>    if(HR_FAILED(hr)) <br>    { <br>        pCFDlg-&gt;m_lsterr.HrSetLastError(hr, pmdb); <br>        pCFDlg-&gt;m_lsterr.ShowError(pCFDlg-&gt;hwDialog()); <br>         <br>        goto err; <br>    } <br>     <br>    Assert(MAPI_FOLDER == ulObjType); <br> <br>/*  if(pvalIPM-&gt;Value.bin.cb &gt; m_pval[iEID].Value.bin.cb) <br>    { <br>        if(hr = MAPIAllocateMore(pvalIPM-&gt;Value.bin.cb, <br>                        m_pval, (LPVOID *)&amp;m_pval[iEID].Value.bin.lpb)) <br>            goto err; <br>                 <br>    } <br> <br>    CopyMemory(m_pval[iEID].Value.bin.lpb, pvalIPM-&gt;Value.bin.lpb, <br>                                        pvalIPM-&gt;Value.bin.cb); <br>    m_pval[iEID].Value.bin.cb = pvalIPM-&gt;Value.bin.cb;*/ <br> <br>err: <br>    if(HR_FAILED(hr)) <br>    { <br>        UlRelease(pmdb); <br>        UlRelease(m_pfld); <br>        m_pfld = NULL; <br>    } <br>    else <br>    { <br>        m_pmdb = pmdb; <br>        hr = hrSuccess; //don't return warnings <br>    } <br> <br>    MAPIFreeBuffer(pvalIPM); <br> <br>    DebugTraceResult(CTVNode::HrOpenMDB, hr); <br>    return hr; <br>} <br> <br>// <br>//  CTVNode::HrOpenFolder <br>// <br>HRESULT CTVNode::HrOpenFolder(CChsFldDlg * pCFDlg) <br>{ <br>    HRESULT hr; <br>    ULONG ulObjType; <br> <br>    Assert(m_pval[iEID].ulPropTag == PR_ENTRYID); <br>    Assert(m_pmdb); <br>     <br>    // MAPI_MODIFY flag affects only IMAPIProp interface of the object. <br>    // It does not guarantee permission to create subfolders. <br>    hr = m_pmdb-&gt;OpenEntry(m_pval[iEID].Value.bin.cb, <br>                (LPENTRYID)m_pval[iEID].Value.bin.lpb, <br>                NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>                 &amp;ulObjType, (LPUNKNOWN *) &amp;m_pfld); <br>    if(HR_FAILED(hr)) <br>    { <br>        pCFDlg-&gt;m_lsterr.HrSetLastError(hr, m_pmdb); <br>        pCFDlg-&gt;m_lsterr.ShowError(pCFDlg-&gt;hwDialog()); <br>         <br>        goto err; <br>    } <br>     <br>    Assert(MAPI_FOLDER == ulObjType); <br>err: <br> <br>    DebugTraceResult(CTVNode::HrOpenFolder, hr); <br>    return hr; <br> <br>} <br> <br>// <br>//  CTVNode::HrGetFolder <br>// <br>//  return folder interface for the node <br>HRESULT CTVNode::HrGetFolder(CChsFldDlg * pCFDlg, <br>                            LPMAPIFOLDER * ppfld, LPMDB *ppmdb) <br>{ <br>    HRESULT hr = hrSuccess; <br>     <br>    Assert(pCFDlg); <br>    Assert(ppfld); <br>    Assert(ppmdb); <br> <br> <br>    if(!m_pmdb) <br>    { <br>        hr = HrOpenMDB(pCFDlg); <br>        if(FAILED(hr)) <br>            goto err; <br>    } <br>    Assert(m_pmdb); <br>     <br>    if(!m_pfld) <br>    { <br>        Assert(!m_fKidsLoaded); <br>         <br>        hr = HrOpenFolder(pCFDlg); <br>        if(FAILED(hr)) <br>            goto err; <br> <br>    } <br>    Assert(m_pfld); <br> <br>    *ppfld = m_pfld; <br>    m_pfld-&gt;AddRef(); <br> <br>    m_pmdb-&gt;AddRef(); <br>    *ppmdb = m_pmdb;             <br> <br>err: <br> <br>    DebugTraceResult(CTVNode::HrGetFolder, hr); <br>    return hr; <br>} <br> <br> <br>// <br>//  CTVNode::HrNewFolder <br>// <br>// Create subfolder szFldName <br>// <br>HRESULT CTVNode::HrNewFolder(CChsFldDlg * pCFDlg, <br>                                     LPSTR szFldName) <br>{ <br>    HRESULT hr; <br>    LPMAPIFOLDER pfldNew = NULL; <br>    LPTVNODE pNode = NULL; <br>    LPSPropValue pval = NULL; <br>    HTREEITEM hItem; <br> <br>    Assert(szFldName); <br>    Assert(pCFDlg); <br>     <br> <br>    if(!m_pmdb) <br>    { <br>        hr = HrOpenMDB(pCFDlg); <br>        if(FAILED(hr)) <br>            goto err; <br>    } <br> <br>    Assert(m_pmdb); <br>     <br>    if(!m_pfld) <br>    { <br>        hr = HrOpenFolder(pCFDlg); <br>        if(FAILED(hr)) <br>            goto err; <br>    } <br> <br>    Assert(m_pmdb); <br>     <br>    hr = m_pfld-&gt;CreateFolder(FOLDER_GENERIC, szFldName, NULL, <br>                                NULL, 0, &amp;pfldNew); <br>    if(HR_FAILED(hr)) <br>    { <br>        pCFDlg-&gt;m_lsterr.HrSetLastError(hr, m_pfld); <br>        pCFDlg-&gt;m_lsterr.ShowError(pCFDlg-&gt;hwDialog()); <br> <br>        goto err; <br>    } <br> <br>    if(!m_pval[iSubfldrs].Value.b) <br>    { <br>        m_pval[iSubfldrs].Value.b = TRUE; <br> <br>        TV_ITEM tvI; <br> <br>        tvI.hItem           = m_htiMe; <br>        tvI.mask            = TVIF_CHILDREN; <br>        tvI.cChildren       = 1; <br> <br>        TreeView_SetItem(pCFDlg-&gt;hwTreeCtl(), &amp;tvI); <br>    } <br> <br>    if(m_fKidsLoaded) <br>    { <br>        hr = MAPIAllocateBuffer(sizeof(SPropValue)* nhtProps, (LPVOID *)&amp;pval); <br>        if(hr) <br>            goto err; <br> <br>        ZeroMemory(pval, sizeof(SPropValue) * nhtProps ); <br> <br>        pval[iEID].ulPropTag = PR_ENTRYID; <br>        pval[iDispName].ulPropTag = PR_DISPLAY_NAME; <br>        pval[iSubfldrs].ulPropTag = PR_SUBFOLDERS; <br> <br>        pval[iSubfldrs].Value.b = FALSE; <br> <br>        int cb = lstrlen(szFldName) + 1; <br>        hr = MAPIAllocateMore(cb, pval, (LPVOID *)&amp;pval[iDispName].Value.lpszA); <br>        if(hr)  <br>            goto err; <br> <br>        lstrcpy(pval[iDispName].Value.lpszA, szFldName); <br> <br>        hr = pCFDlg-&gt;HrCreateNode(pval, nhtProps, m_pmdb, &amp;pNode); <br>        if(HR_FAILED(hr)) <br>            goto err; <br> <br>        pval = NULL; <br> <br>        hItem = AddOneItem(m_htiMe,  TVI_SORT, pCFDlg-&gt;IndClsdFld(), <br>                        pCFDlg-&gt;IndOpenFld(), pCFDlg-&gt;hwTreeCtl(), pNode, 0); <br>        if(!hItem) <br>        { <br>            hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY); <br>            goto err; <br>        } <br>             <br>        pNode-&gt;m_pfld = pfldNew; <br>        pfldNew = NULL; <br>         <br>    } <br> <br>err: <br>    MAPIFreeBuffer(pval); <br>    UlRelease(pfldNew); <br> <br>    DebugTraceResult(CTVNode::HrNewFolder, hr); <br>    return hr; <br>} <br> <br>// <br>//  CTVNode::Write <br>// <br>// Used in CChsFldDlg::HrSaveTreeState <br>void CTVNode::Write(BOOL fWrite, LONG iLevel, LPBYTE * ppb) <br>{ <br>    if(fWrite) <br>        *((LONG *)*ppb) = iLevel; <br>    *ppb += sizeof(LONG); <br> <br>    if(iLevel != 0) <br>    { <br>        ULONG cb = m_pval[iEID].Value.bin.cb; <br>         <br>        if(fWrite) <br>            *((ULONG *)*ppb) = cb; <br>        *ppb += sizeof(ULONG); <br> <br>        if(fWrite) <br>            CopyMemory(*ppb, m_pval[iEID].Value.bin.lpb, cb); <br>        *ppb += Align4(cb); <br>    } <br>    else <br>    { <br>        Assert(m_pval[iDispName].Value.lpszA == g_szAllStores); <br>    } <br> <br>} <br> <br>LPVOID CTVNode::operator new( size_t cb ) <br>{ <br>    LPVOID pv; <br> <br>    if ( MAPIAllocateBuffer( (ULONG)cb, &amp;pv ) ) <br>        pv = NULL; <br> <br>    return pv;  <br>} <br> <br>void CTVNode::operator delete( LPVOID pv ) <br>{ <br>    MAPIFreeBuffer( pv ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
