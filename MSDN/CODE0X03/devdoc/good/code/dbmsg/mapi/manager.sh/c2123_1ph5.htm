<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHCFG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2129"></a>SMHCFG.C</h2>
<pre><code>/* <br> *  S M H C F G . C <br> * <br> *  Sample mail handling hook configuration <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br> <br>/* <br> *  Configuration Properties <br> *   <br> *  sptConfigProps <br> *   <br> *      This is the set of properties that we expect to find in the <br> *      provider's profile section. <br> *   <br> *  sptRule <br> *   <br> *      This is the set of properties that are expected to be found in <br> *      each rule's profile section. <br> */ <br>const SizedSPropTagArray (cpMax, sptConfigProps) = <br>{ <br>    cpMax, <br>    { <br>        PR_PROFILE_NAME, <br>        PR_SMH_FLAGS, <br>        PR_SMH_RULES, <br>        PR_SMH_RULE_NAMES, <br>        PR_SMH_OOF_TEXT, <br>        PR_SMH_OOF_ENABLED, <br>        PR_SMH_OOF_RTF, <br>        PR_SMH_SOUND_SCHEMES, <br>        PR_SMH_REPFWD_SCHEMES, <br>        PR_SMH_EXCLUSIONS <br>    } <br>}; <br>const SizedSPropTagArray (cpRLMax, sptRule) = <br>{ <br>    cpRLMax, <br>    { <br>        PR_DISPLAY_NAME, <br>        PR_RULE_TYPE, <br>        PR_RULE_DATA, <br>        PR_RULE_FLAGS, <br>        PR_RULE_TARGET_ENTRYID, <br>        PR_RULE_TARGET_PATH, <br>        PR_RULE_STORE_ENTRYID, <br>        PR_RULE_STORE_DISPLAY_NAME, <br>        PR_RULE_SOUND_LOPRI, <br>        PR_RULE_SOUND_NORMAL, <br>        PR_RULE_SOUND_HIPRI, <br>        PR_RULE_FORWARD_RECIP, <br>        PR_RULE_FORWARD_RECIP_ENTRYID, <br>        PR_RULE_REP_FWD_RTF, <br>        PR_RULE_REP_FWD_TEXT <br>    } <br>}; <br> <br> <br>/* <br> *  Configuration event name <br> */ <br>const TCHAR lpszConfigEvt[] = "SMH_CONFIGURATION_EVENT"; <br> <br> <br>/* <br> *  HrOpenSingleProvider() <br> *   <br> *  Purpose: <br> *   <br> *      Opens the profile section of this service provider.  This is done <br> *      by opening the message service table and querying all rows. <br> *      Since the SMH service contains only one provider, there is only <br> *      one row in the table.  This contains our profile section.  Use <br> *      the PR_PROFILE_UID to open the section. <br> *   <br> *  Arguments: <br> *   <br> *      lpadmin         the IProfileAdmin object <br> *      lppprof [OUT]   on return contains the profile section obj <br> *   <br> *  Returns: <br> *   <br> *      (HRESULT) <br> *      lppprof [OUT]   contains the profile section object iff the call <br> *                      is successful. <br> */ <br>HRESULT <br>HrOpenSingleProvider (LPPROVIDERADMIN lpadmin, LPPROFSECT FAR * lppprof) <br>{ <br>    HRESULT hr; <br>    LPMAPITABLE lptbl = NULL; <br>    LPSRowSet lprws = NULL; <br>    SPropTagArray sptProvider = {1, {PR_PROVIDER_UID}}; <br>    SRestriction res = {0}; <br> <br>    res.rt = RES_EXIST; <br>    res.res.resExist.ulPropTag = PR_PROVIDER_DLL_NAME; <br> <br>    hr = lpadmin-&gt;lpVtbl-&gt;GetProviderTable (lpadmin, 0, &amp;lptbl); <br>    if (!HR_FAILED (hr)) <br>    { <br>        hr = lptbl-&gt;lpVtbl-&gt;SetColumns (lptbl, &amp;sptProvider, 0L); <br>        if (!HR_FAILED (hr)) <br>        { <br>            hr = lptbl-&gt;lpVtbl-&gt;Restrict (lptbl, &amp;res, 0); <br>            if (!HR_FAILED (hr)) <br>            { <br>                hr = lptbl-&gt;lpVtbl-&gt;QueryRows (lptbl, 10, 0, &amp;lprws); <br>                if (!HR_FAILED (hr) &amp;&amp; lprws-&gt;cRows) <br>                { <br>                    Assert (lprws-&gt;cRows == 1); <br>                    Assert (lprws-&gt;aRow[0].cValues == 1); <br>                    Assert (lprws-&gt;aRow[0].lpProps); <br>                    Assert (lprws-&gt;aRow[0].lpProps[0].ulPropTag == PR_PROVIDER_UID); <br>                    hr = lpadmin-&gt;lpVtbl-&gt;OpenProfileSection (lpadmin, <br>                        (LPMAPIUID)lprws-&gt;aRow[0].lpProps[0].Value.bin.lpb, <br>                        NULL, <br>                        MAPI_MODIFY, <br>                        lppprof); <br>                    MAPIFreeBuffer (lprws-&gt;aRow[0].lpProps); <br>                } <br>                MAPIFreeBuffer (lprws); <br>            } <br>        } <br>        UlRelease (lptbl); <br>    } <br>    DebugTraceResult (HrOpenSingleProvider, hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  HrMergeValues() <br> *   <br> *  Purpose: <br> *   <br> *      Merges two property value arrays into one.  By making a copy of <br> *      the first and then adding/replacing props from the second. <br> *   <br> *      IMPORTANT: if there are any property values that are separately <br> *      allocated with either MAPIAllocateBuffer() or MAPIAllocateMore(), <br> *      then these property values must remain valid as long as the <br> *      merged property array is expected to be valid. <br> *   <br> *  Returns: <br> *   <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrMergeValues (ULONG cval1, <br>    LPSPropValue lpval1, <br>    ULONG cval2, <br>    LPSPropValue lpval2, <br>    LPALLOCATEBUFFER lpfnAlloc, <br>    ULONG FAR * lpcvalMerged, <br>    LPSPropValue FAR * lppvalMerged) <br>{ <br>    SCODE sc; <br>    LPSPropValue lpval = NULL; <br>    UINT cb; <br>    UINT ip; <br> <br>    cb = (UINT)(cval1 + cval2) * sizeof(SPropValue); <br>    sc = (*lpfnAlloc)(cb, &amp;lpval); <br>    if (!FAILED (sc)) <br>    { <br>        /*  Slurp the original data across */ <br> <br>        memcpy (lpval, lpval1, (UINT)cval1 * sizeof(SPropValue)); <br> <br>        /*  Move the new stuff over */ <br> <br>        while (cval2--) <br>        { <br>            for (ip = 0; ip &lt; (UINT)cval1; ip++) <br>            { <br>                /*  See if we match properties */ <br> <br>                if (PROP_ID (lpval[ip].ulPropTag) == PROP_ID (lpval2[cval2].ulPropTag)) <br>                { <br>                    /*  We matched, but are we a real property */ <br> <br>                    if (PROP_TYPE (lpval2[cval2].ulPropTag) != PT_ERROR) <br>                        lpval[ip] = lpval2[cval2]; <br>                    break; <br>                } <br>            } <br>            if (ip == cval1) <br>                lpval[cval1++] = lpval2[cval2]; <br>        } <br>        *lpcvalMerged = cval1; <br>        *lppvalMerged = lpval; <br>    } <br>    DebugTraceSc (HrMergeValues(), sc); <br>    return ResultFromScode (sc); <br>} <br> <br> <br>/* <br> *  HrUpdateProfileFormat() <br> *   <br> *  Purpose: <br> *   <br> *      Converts the WMS level of SMH profile properties to post WMS <br> *      levels.  Namely rules are now stored via a pair of properties <br> *      in the profile.  PR_SMH_RULES has been changed to a multi-valued <br> *      binary property and PR_SMH_RULE_NAMES contains the display names <br> *      for the rules.  The prevents the configuration functions from <br> *      opening all profile sections to build the list of rules. <br> *   <br> *  Arguments: <br> *   <br> *      lpvOPSCtxt          Context passed to OpenProfileSection() <br> *                          (a session or an profadmin object) <br> *      lpfnOpenProfSect    Pointer to OpenProfileSection() <br> *      lpfnMore            MAPIAllocateMore() function <br> *      lpfnFree            MAPIFreeBuffer() function <br> *      lpvalNew            propvalue array for the converted values <br> *      lpvalOld            propvalue of the old PR_SMH_RULES <br> *   <br> *  Returns: <br> *   <br> *      (HRESULT) <br> */ <br> <br>HRESULT <br>HrUpdateProfileFormat (LPVOID lpvOPSCtxt, <br>    LPOPENPROFSECT lpfnOpenProfSect, <br>    LPALLOCATEMORE lpfnMore, <br>    LPFREEBUFFER lpfnFree, <br>    LPSPropValue lpvalNew, <br>    LPSPropValue lpvalOld) <br>{ <br>    SCODE sc = S_OK; <br>    LPMAPIUID lpmuid; <br>    LPPROFSECT lpsec = NULL; <br>    LPSBinary lpbin; <br>    LPSPropValue lpval = NULL; <br>    LPTSTR FAR * lppsz; <br>    SizedSPropTagArray (2, spt) = {2, {PR_DISPLAY_NAME, PR_RULE_TYPE}}; <br>    UINT cb; <br>    UINT crl; <br>    UINT i; <br>    ULONG cval; <br>     <br>    DebugTrace ("SMH: updating profile to new format\n"); <br> <br>    /*  Make sure that the size is an even number of UIDs */ <br> <br>    Assert ((lpvalOld-&gt;Value.bin.cb % sizeof(MAPIUID)) == 0); <br>    crl = (UINT)lpvalOld-&gt;Value.bin.cb / sizeof(MAPIUID); <br> <br>    /*  Allocate space for the two new properties */ <br> <br>    cb = crl * sizeof(SBinary); <br>    sc = (*lpfnMore) (cb, lpvalNew, &amp;lpbin); <br>    if (FAILED (sc)) <br>        goto ret; <br>    memset (lpbin, 0, cb); <br>     <br>    cb = crl * sizeof(LPTSTR); <br>    sc = (*lpfnMore) (cb, lpvalNew, (LPVOID FAR *)&amp;lppsz); <br>    if (FAILED (sc)) <br>        goto ret; <br>    memset (lppsz, 0, cb); <br>     <br>    /*  Iterate through the old list building the two new lists as we go */ <br>     <br>    lpmuid = (LPMAPIUID)lpvalOld-&gt;Value.bin.lpb; <br>    for (i = 0; crl--; lpmuid++) <br>    { <br>        /*  Open the old profile section and get PR_DISPLAY_NAME <br>         *  and PR_RULE_TYPE for conversion purposes.  The type <br>         *  will be converted and reset into the profile section. <br>         *  Thus, completing the conversion for that section. <br>         * <br>         *  The display name will be extracted and copied out to <br>         *  the external names property and will be saved out when <br>         *  all section conversions are completed <br>         */ <br>        if (!HR_FAILED ((*lpfnOpenProfSect) (lpvOPSCtxt, lpmuid, NULL, MAPI_MODIFY, &amp;lpsec)) &amp;&amp; <br>            !HR_FAILED (lpsec-&gt;lpVtbl-&gt;GetProps (lpsec, (LPSPropTagArray)&amp;spt, 0, &amp;cval, &amp;lpval)) &amp;&amp; <br>            !FAILED ((*lpfnMore) (sizeof(MAPIUID), lpvalNew, &amp;lpbin[i].lpb)) &amp;&amp; <br>            !FAILED ((*lpfnMore) (lstrlen (lpval[0].Value.LPSZ) + 1, lpvalNew, &amp;lppsz[i]))) <br>        { <br>            switch (lpval[1].Value.l) <br>            { <br>              case 1: <br>                lpval[1].Value.l = RL_SUBJECT; <br>                break; <br>              case 2: <br>                lpval[1].Value.l = RL_SENDER; <br>                break; <br>              case 4: <br>                lpval[1].Value.l = RL_HAS_ATTACH; <br>                break; <br>              case 8: <br>                lpval[1].Value.l = RL_BODY; <br>                break; <br>              case 16: <br>                lpval[1].Value.l = RL_TO_RECIP; <br>                break; <br>              case 32: <br>                lpval[1].Value.l = RL_CC_RECIP; <br>                break; <br>              case 64: <br>                lpval[1].Value.l = RL_BCC_RECIP; <br>                break; <br>              case 128: <br>                lpval[1].Value.l = RL_ANY_RECIP; <br>                break; <br>              case 256: <br>                lpval[1].Value.l = RL_MSG_CLASS; <br>                break; <br>            } <br>            if (!HR_FAILED (HrSetOneProp ((LPMAPIPROP)lpsec, &amp;lpval[1]))) <br>            { <br>                DebugTrace ("SMH: converting '%s' rule\n", lpval[0].Value.LPSZ); <br>                lpbin[i].cb = sizeof(MAPIUID); <br>                memcpy (lpbin[i].lpb, lpmuid, sizeof(MAPIUID)); <br>                lstrcpy (lppsz[i], lpval[0].Value.LPSZ); <br>                i++; <br>            } <br>        } <br>        (*lpfnFree) (lpval); <br>        UlRelease (lpsec); <br>        lpval = NULL; <br>        lpsec = NULL; <br>    } <br>    lpvalNew[ipRules].ulPropTag = PR_SMH_RULES; <br>    lpvalNew[ipRules].Value.MVbin.cValues = i; <br>    lpvalNew[ipRules].Value.MVbin.lpbin = lpbin; <br>    lpvalNew[ipNames].ulPropTag = PR_SMH_RULE_NAMES; <br>    lpvalNew[ipNames].Value.MVSZ.cValues = i; <br>    lpvalNew[ipNames].Value.MVSZ.LPPSZ = lppsz; <br> <br>ret: <br> <br>    DebugTraceSc (HrUpdateProfileFormat(), sc); <br>    return ResultFromScode (sc ? sc : ((i == crl) ? 0 : MAPI_W_ERRORS_RETURNED)); <br>} <br>         <br> <br>/* <br> *  HrGetConfigEvent() <br> *   <br> *  Purpose: <br> *   <br> *      Gets the configuration event handle.  The handle is used to <br> *      signal logged in handlers that their configuration has been <br> *      modified and, at the next reasonable chance, should be reloaded. <br> *   <br> *      Called at SMH init time only. <br> *   <br> *  Arguments: <br> *   <br> *      lphevt  [OUT]   contains the handle iff the call succeeds <br> *   <br> *  Returns: <br> *   <br> *      (HRESULT) <br> */ <br>#ifdef  _WIN32 <br>HRESULT <br>HrGetConfigEvent (HANDLE FAR * lphevt) <br>{ <br>    HANDLE hevt = NULL; <br>         <br>    if (!(hevt = CreateEvent (NULL, TRUE, FALSE, lpszConfigEvt)) &amp;&amp; <br>        !(hevt = OpenEvent (EVENT_MODIFY_STATE, FALSE, lpszConfigEvt))) <br>        ResultFromScode (MAPI_E_NOT_ENOUGH_RESOURCES); <br> <br>    *lphevt = hevt; <br>    return hrSuccess; <br>} <br>#endif  /* _WIN32 */ <br> <br> <br>/* <br> *  SignalConfigChanged() <br> *   <br> *  Purpose: <br> *   <br> *      Sets the configuration event such that logged in hooks can update <br> *      their configuration on the fly. <br> *   <br> *      Called from within the service entry when configuration changes <br> *      are commited. <br> */ <br>#ifdef  _WIN32 <br>VOID <br>SignalConfigChanged (VOID) <br>{ <br>    HANDLE hevt = NULL; <br>     <br>    if (hevt = OpenEvent (EVENT_MODIFY_STATE, FALSE, lpszConfigEvt)) <br>    { <br>        SetEvent (hevt); <br>        CloseHandle (hevt); <br>    } <br>    return; <br>} <br>#endif  /* _WIN32 */ <br> <br> <br>/* <br> *  FConfigChanged() <br> *   <br> *  Purpose: <br> *   <br> *      Tests the configuration event such that logged in hooks can update <br> *      their configuration on the fly if the configuration has changed. <br> *   <br> *      Called from within the SMH object at regualr intervals <br> *   <br> *  Returns: <br> *   <br> *      TRUE iff the config changed <br> *   <br> */ <br>#ifdef  _WIN32 <br>BOOL <br>FConfigChanged (HANDLE hevt) <br>{ <br>    ULONG dw; <br> <br>    dw = WaitForSingleObject (hevt, 0); <br>    Assert (dw != WAIT_ABANDONED); <br>    return (dw == WAIT_OBJECT_0); <br>} <br>#endif  /* _WIN32 */ <br> <br> <br>/* <br> *  SMH_ServiceEntry() <br> *   <br> *  Purpose: <br> *   <br> *      The ServiceEntry() function is the MAPI entry point to configure <br> *      a service for use in a profile.  The call can then bring up UI to <br> *      ensure configuration of the SMH provider. <br> *   <br> *  Parameters: <br> *   <br> *      hinst           DLL instance <br> *      lpmalloc        OLE style allocator (used by PropSheet()) <br> *      lpsup           MAPI profile support object <br> *      ulUIParam       hwnd that is to be used as UI parent <br> *      ulFlags         configuration flags <br> *      ulContext       configuration action <br> *      cval            count of caller supplied properties <br> *      lpval           caller supplied properties to be configured <br> *      lpadmin         IProviderAdmin object <br> *      lppmerr [OUT]   extended error information <br> *   <br> *  Operation: <br> *   <br> *      The ServiceEntry() uses the IProviderAdmin object to open its <br> *      profile section and retrieve the current set of properties.  The <br> *      caller supplied properties are then merged into the set of <br> *      current properties. <br> *   <br> *      If either this set of properties is not sufficient for <br> *      configuration or the caller specifically asked for configuration <br> *      UI, then ServiceEntry() will make calls to bring up its config <br> *      UI. <br> *   <br> *      ServiceEntry() recognizes several configuration flags.  If <br> *      SERVICE_UI_ALWAYS and/or SERVICE_UI_ALLOWED are set, UI is <br> *      allowed and we be brought up if appropriate.  Is <br> *      MSG_SERVICE_UI_READ_ONLY is set, then the UI should not  <br> *      allow the configuration to be modified. <br> *   <br> *      The configuration contexts MSG_SERVICE_DELETE, MSG_SERVICE_INSTALL,  <br> *      and MSG_SERVICE_UNINSTALL are ignored and no action is taken. <br> *      MSG_SERVICE_CONFIGURE and MSG_SERVICE_CREATE allow the caller to <br> *      create or update the configuration properties in this providers <br> *      profile section.  <br> *   <br> *      SMH will not return extended information in the MAPIERROR in case <br> *      of error <br> */ <br>HRESULT STDAPICALLTYPE <br>SMH_ServiceEntry( <br>    HINSTANCE hinst, <br>    LPMALLOC lpmalloc, <br>    LPMAPISUP lpsup, <br>    ULONG ulUIParam, <br>    ULONG ulFlags, <br>    ULONG ulContext, <br>    ULONG cval, <br>    LPSPropValue lpval, <br>    LPPROVIDERADMIN lpadmin, <br>    LPMAPIERROR FAR * lppmerr) <br>{ <br>    HRESULT hr = hrSuccess; <br>    BOOL fUI = FALSE; <br>    LPALLOCATEBUFFER lpfnAlloc = NULL; <br>    LPALLOCATEMORE lpfnAllocMore = NULL; <br>    LPFREEBUFFER lpfnFree = NULL; <br>    LPMAPIUID lpmuid = NULL; <br>    LPPROFSECT lpprof = NULL; <br>    LPPROFSECT lpprofSvc = NULL; <br>    LPSCD lpscd = NULL; <br>    LPSPropValue lpvalCur = NULL; <br>    LPSPropValue lpvalNew = NULL; <br>    LPSPropValue lpvalOld; <br>    SPropValue val; <br>    UINT csec = 0; <br>    UINT i; <br>    ULONG cvalCur; <br>    ULONG cvalNew; <br>    ULONG ulMyFlags; <br> <br>    if ((ulContext == MSG_SERVICE_INSTALL) || <br>        (ulContext == MSG_SERVICE_UNINSTALL)) <br>        goto ret; <br> <br>    if ((ulContext != MSG_SERVICE_CONFIGURE) &amp;&amp; <br>        (ulContext != MSG_SERVICE_CREATE) &amp;&amp; <br>        (ulContext != MSG_SERVICE_DELETE)) <br>    { <br>        hr = ResultFromScode (MAPI_E_NO_SUPPORT); <br>        goto ret; <br>    } <br> <br>    if (ulFlags &amp; MAPI_UNICODE) <br>    { <br>        /*  Unicode is not supported by SMH */ <br> <br>        hr = ResultFromScode (MAPI_E_BAD_CHARWIDTH); <br>        goto ret; <br>    } <br> <br>    /*  Find out our UI options */ <br> <br>    fUI = !!(ulFlags &amp; SERVICE_UI_ALWAYS); <br>    ulMyFlags = (ulFlags &amp; MSG_SERVICE_UI_READ_ONLY) <br>        ? UI_READONLY <br>        : 0; <br> <br>    /*  Get memory routines */ <br> <br>    hr = lpsup-&gt;lpVtbl-&gt;GetMemAllocRoutines (lpsup, <br>                            &amp;lpfnAlloc, <br>                            &amp;lpfnAllocMore, <br>                            &amp;lpfnFree); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Open the profile section */ <br> <br>    hr = HrOpenSingleProvider (lpadmin, &amp;lpprof); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Get the values already in the profile */ <br> <br>    hr = lpprof-&gt;lpVtbl-&gt;GetProps (lpprof, <br>                            (LPSPropTagArray)&amp;sptConfigProps, <br>                            0, <br>                            &amp;cvalCur, <br>                            &amp;lpvalCur); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Check that the rules are stored in the correct format */ <br>     <br>    if (lpvalCur[ipRules].ulPropTag != PR_SMH_RULES) <br>    { <br>        hr = HrGetOneProp ((LPMAPIPROP)lpprof, <br>                    CHANGE_PROP_TYPE(PR_SMH_RULES, PT_BINARY), <br>                    &amp;lpvalOld); <br>        if (!HR_FAILED (hr)) <br>        { <br>            /*  The rules are stored in the wrong format */ <br> <br>            hr = HrUpdateProfileFormat (lpadmin, <br>                            lpadmin-&gt;lpVtbl-&gt;OpenProfileSection, <br>                            lpfnAllocMore, <br>                            lpfnFree, <br>                            lpvalCur, <br>                            lpvalOld); <br>            (*lpfnFree) (lpvalOld); <br>            if (HR_FAILED (hr)) <br>                goto ret; <br> <br>            /*  Save out anything we got back */ <br> <br>            lpprof-&gt;lpVtbl-&gt;SetProps (lpprof, cpMax, lpvalCur, NULL); <br>        } <br>    } <br> <br>    if (ulContext != MSG_SERVICE_DELETE) <br>    { <br>        /*  Merge what was in the profile with what was passed in */ <br> <br>        hr = HrMergeValues (cvalCur, <br>                            lpvalCur, <br>                            cval, <br>                            lpval, <br>                            lpfnAlloc, <br>                            &amp;cvalNew, <br>                            &amp;lpvalNew); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        /*  If we dont have all the props we need, then <br>         *  we will have to ask for them <br>         */ <br>        fUI = fUI || (lpvalNew[ipFlags].ulPropTag != PR_SMH_FLAGS); <br>        if ((lpvalNew[ipFlags].ulPropTag != PR_SMH_FLAGS) &amp;&amp; <br>            (!(ulFlags &amp; (SERVICE_UI_ALLOWED | SERVICE_UI_ALWAYS)) || <br>            (ulFlags &amp; MSG_SERVICE_UI_READ_ONLY))) <br>        { <br>            /*  We need UI but can't have it. */ <br> <br>            hr = ResultFromScode (MAPI_E_UNCONFIGURED); <br>            goto ret; <br>        } <br> <br>        if (fUI) <br>        { <br>            /*  Do the config dialog */ <br> <br>            if (!FAILED ((*lpfnAlloc) (sizeof(SCD), &amp;lpscd))) <br>            { <br>                memset (lpscd, 0, sizeof(SCD)); <br>                lpscd-&gt;hinst = hinst; <br>                lpscd-&gt;hwnd = (HWND)ulUIParam; <br>                lpscd-&gt;lpfnAlloc = lpfnAlloc; <br>                lpscd-&gt;lpfnAllocMore = lpfnAllocMore; <br>                lpscd-&gt;lpfnFree = lpfnFree; <br>                lpscd-&gt;lpmalloc = lpmalloc; <br>                lpscd-&gt;lpval = lpvalNew; <br>                lpscd-&gt;lpsec = lpprof; <br>                lpscd-&gt;lpsup = lpsup; <br>                lpscd-&gt;lpadmin = lpadmin; <br>                lpscd-&gt;ulFlags = ulMyFlags; <br>                hr = HrDisplayPropSheets (hinst, (HWND)ulUIParam, lpscd); <br>            } <br>            else <br>            { <br>                hr = ResultFromScode (MAPI_E_NOT_ENOUGH_MEMORY); <br>                goto ret; <br>            } <br>        } <br> <br>        /*  Open the service profile section and set PR_SERVICE_EXTRA_UIDS */ <br> <br>        if (!HR_FAILED (lpadmin-&gt;lpVtbl-&gt;OpenProfileSection (lpadmin, <br>                                            NULL, <br>                                            NULL, <br>                                            MAPI_MODIFY, <br>                                            &amp;lpprofSvc))) <br>        { <br>            /*  PR_SERVICE_EXTRA_UIDS is composed of all additional <br>             *  sections used by SMH.  By setting this value, we gain <br>             *  the ability to have the service copied and\or moved <br>             *  while having the additional sections move across with <br>             *  it. <br>             */ <br>            if (lpvalNew[ipRules].ulPropTag == PR_SMH_RULES) <br>                csec += (UINT)lpvalNew[ipRules].Value.MVbin.cValues; <br>             <br>            if (csec &amp;&amp; !FAILED ((*lpfnAlloc) (csec * sizeof(MAPIUID), &amp;lpmuid))) <br>            { <br>                for (i = 0; i &lt; csec; i++) <br>                    memcpy (&amp;lpmuid[i], <br>                        lpvalNew[ipRules].Value.MVbin.lpbin[i].lpb, <br>                        sizeof(MAPIUID)); <br> <br>                val.ulPropTag = PR_SERVICE_EXTRA_UIDS; <br>                val.Value.bin.cb = csec * sizeof(MAPIUID); <br>                val.Value.bin.lpb = (LPBYTE)lpmuid; <br>                lpprofSvc-&gt;lpVtbl-&gt;SetProps (lpprofSvc, 1, &amp;val, NULL); <br>                lpprofSvc-&gt;lpVtbl-&gt;SaveChanges (lpprofSvc, 0); <br>                (*lpfnFree) (lpmuid); <br>            } <br>            UlRelease (lpprofSvc); <br>        } <br>    } <br>     <br>ret: <br> <br>#ifdef  _WIN32 <br>    if (!HR_FAILED (hr)) <br>        SignalConfigChanged (); <br>#endif <br> <br>    /*  Cleanup what was left behind */ <br> <br>    if (lpscd) <br>    {    <br>        for (i = 0; i &lt; lpscd-&gt;crl; i++) <br>        { <br>            (*lpfnFree) (lpscd-&gt;lppsz[i]); <br>            (*lpfnFree) (lpscd-&gt;lpbin[i].lpb); <br>        } <br>        (*lpfnFree) (lpscd-&gt;lppsz); <br>        (*lpfnFree) (lpscd-&gt;lpbin); <br>        (*lpfnFree) (lpscd); <br>    } <br>                 <br>    if (lpfnFree) <br>    { <br>        (*lpfnFree) (lpvalCur); <br>        (*lpfnFree) (lpvalNew); <br>    } <br> <br>    UlRelease (lpprof); <br>    DebugTraceResult (SMH_ServiceEntry, hr); <br>    return hr; <br>}; </code></pre>
<p>&nbsp;</p></body>
</HTML>
