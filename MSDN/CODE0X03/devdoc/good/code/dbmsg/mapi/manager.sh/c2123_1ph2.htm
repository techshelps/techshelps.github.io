<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMH.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2126"></a>SMH.C</h2>
<pre><code>/* <br> *  S M H . C <br> *   <br> *  Sample mail handling hook <br> *   <br> *  Purpose: <br> *   <br> *      The sample mail handling (SMH) hook illustrates the use of the <br> *      MAPI Spooler Hook Provider Interface (ISpoolerHook) and those <br> *      parts of the general MAPI API that are available to a spooler <br> *      hook implementation. <br> *   <br> *      Specifically, SMH illusttrates the operation of both an inbound <br> *      message hook as well as outbound.  SMH also has examples of the <br> *      configuration of a spooler hook provider via calls to SMH's <br> *      ServiceEntry() and/or through calls from the Profile Wizard. <br> *   <br> *  Features: <br> *   <br> *    Sent Mail: <br> *   <br> *      SMH allows the archiving of outbound messages (sent mail), into a <br> *      well defined set of subfolders in the default stores sent mail <br> *      folder.  The archive folders are comprised of monthly archive <br> *      folders.  The monthly folders can be, optionally, created under a <br> *      year based folder in the sent mail folder.  Thus in a typical <br> *      message store, a fully archived sent mail folder might have a <br> *      hierarchy that looks similar to the following: <br> *   <br> *          Sent Mail <br> *              | <br> *              |-- 1994 <br> *              |    | <br> *              |    |-- 10 October <br> *              |    |-- 11 November <br> *              |    |-- 12 December <br> *              | <br> *              |-- 1995 <br> *                   | <br> *                   |-- 01 January <br> *   <br> *      This allows for a mail user to organize their outgoing mail in <br> *      a managible fashion. <br> *   <br> *    Deleted Mail: <br> *   <br> *      SMH allows the archiving of deleted mail in the same fashion as <br> *      sent mail can be archived.  This feature helps people who choose <br> *      keep their 'deleted' mail accessible.  It should be noted here <br> *      that this feature does not make use of the ISpoolerHook <br> *      interface, but is an example of what all can be done with spooler <br> *      hook providers. <br> *   <br> *    Incoming Mail: <br> *   <br> *      SMH can also 'filter' incoming messages and route the message <br> *      directly to folders, other than the default stores inbox, based <br> *      on message content.  The user can define any number of filters <br> *      that can help organize and manage the email.  Additionally, the <br> *      user can specify a sound scheme to be used on message delivery. <br> *      This allows the user to specify specific sounds based on message <br> *      content and priority. <br> *   <br> *    Unread Search Folders: <br> *   <br> *      Because SMH can filter unread messages deep into a message store <br> *      folder hierarchy, SMH can also create a search folder in the root <br> *      of the IPM_SUBTREE that searches the entire subtree for unread <br> *      messages. <br> *   <br> *    Out-of-office Processing: <br> *   <br> *      SMH can generate OOF notifications for incomming mail.  It will <br> *      do it's best to not send multiple OOF's to any single recipient <br> *      over the period in which the OOF processing is enabled.  The OOF <br> *      engine supports full rich-text. <br> *   <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br> <br>extern SPropTagArray sptRule; <br>extern SPropTagArray sptConfigProps; <br> <br>/* <br> *  sptMessageProps <br> * <br> *  These are the properties that are required to check filters against <br> *  messages. <br> */ <br>const static SizedSPropTagArray (cpMsgPrps, sptMsgPrps) = <br>{ <br>    cpMsgPrps, <br>    { <br>        PR_MESSAGE_FLAGS, <br>        PR_SUBJECT, <br>        PR_SENT_REPRESENTING_NAME, <br>        PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>        PR_IMPORTANCE <br>    } <br>}; <br> <br>/* <br> *  vtblSMH <br> * <br> *  This is the SMH object's vtable.  The table and its functions are <br> *  defined by MAPI's ISpoolerHook interface. <br> */ <br>static const SMH_Vtbl vtblSMH = <br>{ <br>    SMH_QueryInterface, <br>    SMH_AddRef, <br>    SMH_Release, <br>    SMH_InboundMsgHook, <br>    SMH_OutboundMsgHook <br>}; <br> <br>/* <br> *  lpCtl3D <br> *   <br> *  Holds context for the 3D control DLL. <br> */ <br> <br>LPVOID lpCtl3D = NULL; <br> <br>/* <br> *  HrInitUnreadSearch() <br> * <br> *  Purpose: <br> * <br> *      Inits/creates an 'Unread Messages' search folder in the root of <br> *      the given store's IPM_SUBTREE hierarchy. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           the sample mail handler object <br> *      lpmdb           the store getting the search folder <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrInitUnreadSearch (LPSMH lpsmh) <br>{ <br>    HRESULT hr; <br>    ENTRYLIST el = {0}; <br>    LPMAPIFOLDER lpfldr = NULL; <br>    LPMAPIFOLDER lpfldrUM = NULL; <br>    LPMDB lpmdb = NULL; <br>    LPSPropValue lpval = NULL; <br>    SRestriction res = {0}; <br>    ULONG ulType = 0; <br>    UINT cerr = 0; <br>    UINT i; <br> <br>    for (i = 0; i &lt; lpsmh-&gt;lpstotbl-&gt;cSto; i++) <br>    { <br>        hr = HrOpenStoEntry (lpsmh-&gt;lpsess, &amp;lpsmh-&gt;lpstotbl-&gt;aSto[i], &amp;lpmdb); <br>        if (!HR_FAILED (hr)) <br>        { <br>            hr = HrGetOneProp ((LPMAPIPROP)lpmdb, PR_IPM_SUBTREE_ENTRYID, &amp;lpval); <br>            if (!HR_FAILED (hr)) <br>            { <br>                hr = lpmdb-&gt;lpVtbl-&gt;OpenEntry (lpmdb, <br>                                        lpval-&gt;Value.bin.cb, <br>                                        (LPENTRYID)lpval-&gt;Value.bin.lpb, <br>                                        NULL, <br>                                        MAPI_MODIFY, <br>                                        &amp;ulType, <br>                                        (LPUNKNOWN FAR *)&amp;lpfldr); <br>                if (!HR_FAILED (hr)) <br>                { <br>                    hr = lpfldr-&gt;lpVtbl-&gt;CreateFolder (lpfldr, <br>                                        FOLDER_SEARCH, <br>                                        "Unread Messages", <br>                                        "Simple Mail Handler: unread message search", <br>                                        NULL, <br>                                        MAPI_MODIFY | OPEN_IF_EXISTS, <br>                                        &amp;lpfldrUM); <br>                    if (!HR_FAILED (hr)) <br>                    { <br>                        el.cValues = 1; <br>                        el.lpbin = &amp;lpval-&gt;Value.bin; <br>                        res.rt = RES_BITMASK; <br>                        res.res.resBitMask.relBMR = BMR_EQZ; <br>                        res.res.resBitMask.ulPropTag = PR_MESSAGE_FLAGS; <br>                        res.res.resBitMask.ulMask = MSGFLAG_READ; <br>                        hr = lpfldrUM-&gt;lpVtbl-&gt;SetSearchCriteria (lpfldrUM, <br>                                        &amp;res, <br>                                        &amp;el, <br>                                        RECURSIVE_SEARCH | BACKGROUND_SEARCH | RESTART_SEARCH); <br>                        UlRelease (lpfldrUM); <br>                        lpfldrUM = NULL; <br>                    } <br>                    UlRelease (lpfldr); <br>                    lpfldr = NULL; <br>                } <br>                (*lpsmh-&gt;lpfnFree) (lpval); <br>                lpval = NULL; <br>            } <br>        } <br>        if (HR_FAILED (hr)) <br>        { <br>            DebugTrace ("SMH: WARNING: failed to init unread search (store:%d)\n", i); <br>            cerr++; <br>        } <br>    } <br> <br>    hr = ResultFromScode (cerr ? MAPI_W_ERRORS_RETURNED : S_OK); <br>    DebugTraceResult (HrInitUnreadSearch(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  LpszFindChar() <br> * <br> *  Purpose: <br> * <br> *      Finds the given character in the passed in string.  This is an <br> *      exact matching model so strings should be normalized to either <br> *      upper or lower case if case insensitvity is required. <br> * <br> *  Arguments: <br> * <br> *      lpszSrc         source string <br> *      ch              character to find <br> * <br> *  Returns: <br> * <br> *      NULL iff the char was not found, otherwise, the return is a <br> *      pointer to the character in the source string. <br> */ <br>LPTSTR <br>LpszFindChar (LPTSTR lpszSrc, TCHAR ch) <br>{ <br>    LPTSTR lpsz = lpszSrc; <br> <br>    if (lpszSrc) <br>        while (*lpsz &amp;&amp; (*lpsz != ch)) <br>            lpsz++; <br> <br>    return ((lpsz &amp;&amp; *lpsz) ? lpsz : NULL); <br>} <br> <br> <br>/* <br> *  HrCheckExclusions() <br> * <br> *  Purpose: <br> * <br> *      Checks the message class against the list of message classes <br> *      excluded from filtering. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           the smh parent object <br> *      lpmsg           the message to check for exclusion <br> * <br> *  Returns: <br> * <br> *      (HRESULT)       If the message is to be excluded, then hrSuccess <br> *                      is returned, otherwize MAPI_E_NOT_ME indicates it <br> *                      is OK to filter the message <br> */ <br>HRESULT <br>HrCheckExclusions (LPSMH lpsmh, LPMESSAGE lpmsg) <br>{ <br>    SCODE sc = S_OK; <br>    UINT isz = 0; <br>    LPSPropValue lpval = NULL; <br> <br>    if (lpsmh-&gt;valEx.ulPropTag == PR_SMH_EXCLUSIONS) <br>    { <br>        if (!HR_FAILED (HrGetOneProp ((LPMAPIPROP)lpmsg, PR_MESSAGE_CLASS, &amp;lpval))) <br>        { <br>            /*  See if this is in the list of exclusions */ <br> <br>            for (isz = 0; isz &lt; lpsmh-&gt;valEx.Value.MVSZ.cValues; isz++) <br>                if (FLpszContainsLpsz (lpval-&gt;Value.LPSZ, lpsmh-&gt;valEx.Value.MVSZ.LPPSZ[isz])) <br>                    break; <br> <br>            (*lpsmh-&gt;lpfnFree) (lpval); <br>        } <br>        sc = ((isz == lpsmh-&gt;valEx.Value.MVSZ.cValues) ? S_OK : MAPI_E_NOT_ME); <br>    } <br> <br>    DebugTraceSc (HrCheckExclusions(), sc); <br>    return ResultFromScode (sc); <br>} <br> <br> <br>/* <br> *  HrCheckRule() <br> *   <br> *  Purpose: <br> *   <br> *      Examines a message to see if the current rule applies to the <br> *      message.  <br> *   <br> *      IMPORTANT: If a rule is of type RL_SUBJECT, RL_FROM, or <br> *      RL_ATTACH, then the set of properties required to check for <br> *      matches with the message are retained and passed back to the <br> *      caller such that subsequent calls to HrCheckRule() will not have <br> *      to get those props a second time.  THEREFORE the caller is <br> *      responsible for cleaning up any returned property values. <br> *   <br> *  Arguments: <br> *   <br> *      lprl            pointer to the rule <br> *      lpmsg           pointer to the message to examine <br> *      lppval  [OUT]   buffer containing the target entryid value struct <br> *   <br> *  Returns: <br> *   <br> *      (HRESULT)       If the rule does apply, hrSuccess is returned and <br> *                      the lppval parameter will point to a lpval struct <br> *                      containing the entryid of the target folder. <br> *   <br> *                      If the rule does not apply, the return value is <br> *                      an HRESULT with MAPI_E_NOT_ME as the SCODE. <br> *   <br> *                      Otherwise normal error codes apply. <br> */ <br>HRESULT <br>HrCheckRule (LPSMH lpsmh, LPRULE lprl, LPMESSAGE lpmsg, LPSPropValue FAR * lppval) <br>{ <br>    HRESULT hr; <br>    LPMAPITABLE lptbl = NULL; <br>    LPSPropValue lpval = *lppval; <br>    LPSPropValue lpvalT = NULL; <br>    ULONG cval; <br> <br>    if (!lpval) <br>    { <br>        hr = lpmsg-&gt;lpVtbl-&gt;GetProps (lpmsg, <br>                                (LPSPropTagArray)&amp;sptMsgPrps, <br>                                0, <br>                                &amp;cval, <br>                                &amp;lpval); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br>    } <br> <br>    /*  Init for failure */ <br> <br>    hr = ResultFromScode (MAPI_E_NOT_ME); <br> <br>    if ((lprl-&gt;rlTyp == RL_TO_RECIP) || <br>        (lprl-&gt;rlTyp == RL_CC_RECIP) || <br>        (lprl-&gt;rlTyp == RL_BCC_RECIP) || <br>        (lprl-&gt;rlTyp == RL_ANY_RECIP)) <br>    { <br>        hr = lpmsg-&gt;lpVtbl-&gt;GetRecipientTable (lpmsg, 0, &amp;lptbl); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;FindRow (lptbl, lprl-&gt;lpres, BOOKMARK_BEGINNING, 0); <br>        UlRelease (lptbl); <br>        if (HR_FAILED (hr) &amp;&amp; (GetScode (hr) == MAPI_E_NOT_FOUND)) <br>            hr = ResultFromScode (MAPI_E_NOT_ME); <br>    } <br>    else if (lprl-&gt;rlTyp == RL_SUBJECT) <br>    { <br>        if (lpval[ipMsgSubj].ulPropTag == PR_SUBJECT) <br>            if (FLpszContainsLpsz (lpval[ipMsgSubj].Value.LPSZ, lprl-&gt;lpszData)) <br>                hr = hrSuccess; <br>    } <br>    else if (lprl-&gt;rlTyp == RL_SENDER) <br>    { <br>        if (lpval[ipMsgSentRep].ulPropTag == PR_SENT_REPRESENTING_NAME) <br>            if (FLpszContainsLpsz (lpval[ipMsgSentRep].Value.LPSZ, lprl-&gt;lpszData)) <br>                hr = hrSuccess; <br> <br>        if (HR_FAILED (hr)) <br>            if (lpval[ipMsgSentRepEA].ulPropTag == PR_SENT_REPRESENTING_EMAIL_ADDRESS) <br>                if (FLpszContainsLpsz (lpval[ipMsgSentRepEA].Value.LPSZ, lprl-&gt;lpszData)) <br>                    hr = hrSuccess; <br>    } <br>    else if (lprl-&gt;rlTyp == RL_HAS_ATTACH) <br>    { <br>        if (lpval[ipMsgFlgs].ulPropTag == PR_MESSAGE_FLAGS) <br>            if (lpval[ipMsgFlgs].Value.l &amp; MSGFLAG_HASATTACH) <br>                hr = hrSuccess; <br>    } <br>    else if (lprl-&gt;rlTyp == RL_BODY) <br>    { <br>        if (!HR_FAILED (HrGetOneProp ((LPMAPIPROP)lpmsg, PR_BODY, &amp;lpvalT))) <br>        { <br>            if (FLpszContainsLpsz (lpvalT-&gt;Value.LPSZ, lprl-&gt;lpszData)) <br>                hr = hrSuccess; <br> <br>            (*lpsmh-&gt;lpfnFree) (lpvalT); <br>        } <br>    } <br>    else if (lprl-&gt;rlTyp == RL_MSG_CLASS) <br>    { <br>        if (!HR_FAILED (HrGetOneProp ((LPMAPIPROP)lpmsg, PR_MESSAGE_CLASS, &amp;lpvalT))) <br>        { <br>            if (FLpszContainsLpsz (lpvalT-&gt;Value.LPSZ, lprl-&gt;lpszData)) <br>                hr = hrSuccess; <br> <br>            (*lpsmh-&gt;lpfnFree) (lpvalT); <br>        } <br>    } <br> <br>    if (lprl-&gt;ulFlags &amp; RULE_NOT) <br>    { <br>        if (GetScode (hr) == MAPI_E_NOT_ME) <br>            hr = hrSuccess; <br>        else if (hr == hrSuccess) <br>            hr = ResultFromScode (MAPI_E_NOT_ME); <br>    } <br>     <br>ret: <br> <br>    *lppval = lpval; <br>    DebugTraceResult (HrCheckRule(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  HrFolderFromPath() <br> * <br> *  Purpose: <br> * <br> *      Takes a IPM root-based path string and returns a folder <br> *      corresponding to the path given.  The '\' character is the path <br> *      separator.  And non-existing folders are created as a psrt of the <br> *      process. <br> * <br> *  Arguments: <br> * <br> *      lpsmh               pointer to smh parent object <br> *      lpmdb               store in which the path is to exist <br> *      lpszPath            the root-based path to use <br> *      lppfldr     [OUT]   buffer to place target folder <br> *      lppvalEid   [OUT]   buffer for target entryid value struct pointer <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrFolderFromPath (LPSMH lpsmh, <br>    LPMDB lpmdb, <br>    LPTSTR lpszPath, <br>    LPMAPIFOLDER FAR * lppfldr, <br>    LPSPropValue FAR * lppvalEid) <br>{ <br>    HRESULT hr; <br>    LPMAPIFOLDER lpfldr = NULL; <br>    LPMAPIFOLDER lpfldrT = NULL; <br>    LPSPropValue lpval = NULL; <br>    LPTSTR lpch; <br>    TCHAR rgch[MAX_PATH]; <br>    ULONG ulType; <br> <br>    if (!LoadString (lpsmh-&gt;hinst, SMH_FolderComment, rgch, sizeof(rgch))) <br>        rgch[0] = 0; <br> <br>    hr = HrGetOneProp ((LPMAPIPROP)lpmdb, PR_IPM_SUBTREE_ENTRYID, &amp;lpval); <br>    if (!HR_FAILED (hr)) <br>    { <br>        hr = lpmdb-&gt;lpVtbl-&gt;OpenEntry (lpmdb, <br>                            lpval-&gt;Value.bin.cb, <br>                            (LPENTRYID)lpval-&gt;Value.bin.lpb, <br>                            NULL, <br>                            MAPI_MODIFY, <br>                            &amp;ulType, <br>                            (LPUNKNOWN FAR *)&amp;lpfldr); <br> <br>        (*lpsmh-&gt;lpfnFree) (lpval); <br>        lpval = NULL; <br> <br>        if (!HR_FAILED (hr)) <br>        { <br>            do <br>            { <br>                if (lpch = LpszFindChar (lpszPath, '\\')) <br>                    *lpch = 0; <br> <br>                Assert (lstrlen (lpszPath)); <br>                hr = lpfldr-&gt;lpVtbl-&gt;CreateFolder (lpfldr, <br>                            FOLDER_GENERIC, <br>                            lpszPath, <br>                            rgch, <br>                            NULL, <br>                            MAPI_MODIFY | OPEN_IF_EXISTS, <br>                            &amp;lpfldrT); <br>                if (HR_FAILED (hr)) <br>                { <br>#ifdef  DEBUG <br>                    LPMAPIERROR lperr = NULL; <br>                    lpfldr-&gt;lpVtbl-&gt;GetLastError (lpfldr, hr, 0, &amp;lperr); <br>                    DebugTrace ("SMH: WARNING: unable to open/create folder: '%s' in %s\n", <br>                        lperr-&gt;lpszError, lperr-&gt;lpszComponent); <br>                    (*lpsmh-&gt;lpfnFree) (lperr); <br>#endif <br>                    break; <br>                } <br> <br>                UlRelease (lpfldr); <br>                lpfldr = lpfldrT; <br>                lpfldrT = NULL; <br> <br>                lpszPath = (lpch ? ++lpch : NULL); <br> <br>            } while (lpszPath); <br>        } <br>        if (!HR_FAILED (hr)) <br>        { <br>            hr = HrGetOneProp ((LPMAPIPROP)lpfldr, PR_ENTRYID, &amp;lpval); <br>            if (!HR_FAILED (hr)) <br>            { <br>                *lppfldr = lpfldr; <br>                *lppvalEid = lpval; <br>                lpfldr = NULL; <br>                lpval = NULL; <br>            } <br>        } <br>    } <br> <br>    (*lpsmh-&gt;lpfnFree) (lpval); <br>    UlRelease (lpfldr); <br> <br>    DebugTraceResult (HrFolderFromPath(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  HrBuildRule() <br> * <br> *  Purpose: <br> * <br> *      Takes a profile section and builds a rule structure that <br> *      corresponds to the properties in the profile section. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           pointer to smh parent object <br> *      lpmuid          profile section UID <br> *      lpprl   [OUT]   buffer for the newly created rule pointer <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrBuildRule (LPSMH lpsmh, LPMAPIUID lpmuid, LPRULE FAR * lpprl) <br>{ <br>    SCODE sc; <br>    HRESULT hr; <br>    LPMAPISESSION lpsess = lpsmh-&gt;lpsess; <br>    LPPROFSECT lpprof = NULL; <br>    LPRULE lprl = NULL; <br>    LPSPropValue lpval = NULL; <br>    LPSPropValue lpvalEid = NULL; <br>    LPSPropValue lpvalT; <br>    LPSRestriction lpres = NULL; <br>    ULONG cval; <br>    ULONG ulType; <br>    UINT cb; <br>    UINT i; <br> <br>    sc = (*lpsmh-&gt;lpfnAlloc) (sizeof(RULE), &amp;lprl); <br>    if (FAILED (sc)) <br>    { <br>        hr = ResultFromScode (sc); <br>        goto ret; <br>    } <br>    memset (lprl, 0, sizeof(RULE)); <br>    memcpy (&amp;lprl-&gt;muid, lpmuid, sizeof(MAPIUID)); <br>    hr = lpsess-&gt;lpVtbl-&gt;OpenProfileSection (lpsess, <br>                            lpmuid, <br>                            NULL, <br>                            MAPI_MODIFY, <br>                            &amp;lpprof); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = lpprof-&gt;lpVtbl-&gt;GetProps (lpprof, <br>                            (LPSPropTagArray)&amp;sptRule, <br>                            0, <br>                            &amp;cval, <br>                            &amp;lpval); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    if ((lpval[ipRLType].ulPropTag != PR_RULE_TYPE) || <br>        (lpval[ipRLData].ulPropTag != PR_RULE_DATA) || <br>        (lpval[ipRLFlags].ulPropTag != PR_RULE_FLAGS) || <br>        (!(lpval[ipRLFlags].Value.l &amp; (RULE_DELETE | RULE_NO_MOVE)) &amp;&amp; <br>          (lpval[ipRLType].ulPropTag != PR_RULE_TYPE) || <br>          (lpval[ipRLPath].ulPropTag != PR_RULE_TARGET_PATH) || <br>          (lpval[ipRLStore].ulPropTag != PR_RULE_STORE_DISPLAY_NAME))) <br>    { <br>        /*  Something very important is missing */ <br> <br>        hr = ResultFromScode (MAPI_E_UNCONFIGURED); <br>        goto ret; <br>    } <br>    lprl-&gt;rlTyp = (UINT)lpval[ipRLType].Value.l; <br>    lprl-&gt;ulFlags = lpval[ipRLFlags].Value.l; <br> <br>    /*  Get the filter value */ <br> <br>    sc = (*lpsmh-&gt;lpfnAllocMore) (lpval[ipRLData].Value.bin.cb, lprl, &amp;lprl-&gt;lpszData); <br>    if (FAILED (sc)) <br>    { <br>        hr = ResultFromScode (sc); <br>        goto ret; <br>    } <br>    memcpy (lprl-&gt;lpszData, <br>        lpval[ipRLData].Value.bin.lpb, <br>        (UINT)lpval[ipRLData].Value.bin.cb); <br> <br>    /*  Get the sounds */ <br> <br>    if (lpval[ipRLFlags].Value.l &amp; RULE_PLAY_SOUNDS) <br>    { <br>        for (i = 0; i &lt; csndMax; i++) <br>        { <br>            if ((lpval[ipRLLoPri + i].ulPropTag == sptRule.aulPropTag[ipRLLoPri + i]) &amp;&amp; <br>                (cb = lstrlen (lpval[ipRLLoPri + i].Value.lpszA))) <br>            { <br>                cb += sizeof(TCHAR); <br>                sc = (*lpsmh-&gt;lpfnAllocMore) (cb, lprl, (LPVOID FAR *)&amp;lprl-&gt;rgszSnd[i]); <br>                if (FAILED (sc)) <br>                { <br>                    hr = ResultFromScode (sc); <br>                    goto ret; <br>                } <br>                lstrcpy (lprl-&gt;rgszSnd[i], lpval[ipRLLoPri + i].Value.lpszA); <br>            } <br>        } <br>    } <br> <br>    /*  Fill in the auto response */ <br> <br>    if (lpval[ipRLFlags].Value.l &amp; RULE_AUTO_RESPONSE) <br>    { <br>        if (lpval[ipRLRepFwdRTF].ulPropTag == PR_RULE_REP_FWD_RTF) <br>        { <br>            sc = (*lpsmh-&gt;lpfnAllocMore) (lpval[ipRLRepFwdRTF].Value.bin.cb, <br>                                          lprl, <br>                                          (LPVOID FAR *)&amp;lprl-&gt;lpbRTF); <br>            if (FAILED (sc)) <br>            { <br>                hr = ResultFromScode (sc); <br>                goto ret; <br>            } <br>            lprl-&gt;cbRTF = lpval[ipRLRepFwdRTF].Value.bin.cb; <br>            memcpy (lprl-&gt;lpbRTF, lpval[ipRLRepFwdRTF].Value.bin.lpb, (UINT)lprl-&gt;cbRTF); <br>        } <br>        else if (lpval[ipRLRepFwd].ulPropTag == PR_RULE_REP_FWD_TEXT) <br>        { <br>            cb = lstrlen (lpval[ipRLRepFwd].Value.lpszA) + sizeof(TCHAR); <br>            sc = (*lpsmh-&gt;lpfnAllocMore) (cb, lprl, (LPVOID FAR *)&amp;lprl-&gt;lpszAnno); <br>            if (FAILED (sc)) <br>            { <br>                hr = ResultFromScode (sc); <br>                goto ret; <br>            } <br>            lstrcpy (lprl-&gt;lpszAnno, lpval[ipRLRepFwd].Value.lpszA); <br>        } <br> <br>        if (lpval[ipRLFlags].Value.l &amp; RULE_AUTO_FORWARD) <br>        { <br>            if (lpval[ipRLFwdEid].ulPropTag != PR_RULE_FORWARD_RECIP_ENTRYID) <br>            { <br>                hr = ResultFromScode (MAPI_E_UNCONFIGURED); <br>                goto ret; <br>            } <br>            else <br>            { <br>                sc = (*lpsmh-&gt;lpfnAlloc) (sizeof(SPropValue), &amp;lprl-&gt;lpvalRecip); <br>                if (!FAILED (sc)) <br>                { <br>                    sc = (*lpsmh-&gt;lpfnAllocMore) (lpval[ipRLFwdEid].Value.bin.cb, <br>                        lprl-&gt;lpvalRecip, <br>                        &amp;lprl-&gt;lpvalRecip[0].Value.bin.lpb); <br>                    if (!FAILED (sc)) <br>                    { <br>                        lprl-&gt;lpvalRecip[0].ulPropTag = PR_ENTRYID; <br>                        lprl-&gt;lpvalRecip[0].Value.bin.cb = lpval[ipRLFwdEid].Value.bin.cb; <br>                        memcpy (lprl-&gt;lpvalRecip[0].Value.bin.lpb, <br>                                lpval[ipRLFwdEid].Value.bin.lpb, <br>                                lpval[ipRLFwdEid].Value.bin.cb); <br>                    } <br>                } <br>            } <br>            if (FAILED (sc)) <br>            { <br>                hr = ResultFromScode (sc); <br>                goto ret; <br>            } <br>        } <br>    } <br> <br>    /*  See if we are not going to delete the message */ <br>     <br>    if (!(lpval[ipRLFlags].Value.l &amp; (RULE_DELETE | RULE_NO_MOVE))) <br>    { <br>        /*  Find the target folder */ <br> <br>        hr = HrOpenMdbFromName (lpsmh, lpval[ipRLStore].Value.LPSZ, &amp;lprl-&gt;lpmdb); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        if ((lpval[ipRLEid].ulPropTag != PR_RULE_TARGET_ENTRYID) || <br>            (HR_FAILED (lpsess-&gt;lpVtbl-&gt;OpenEntry (lpsess, <br>                            lpval[ipRLEid].Value.bin.cb, <br>                            (LPENTRYID)lpval[ipRLEid].Value.bin.lpb, <br>                            NULL, <br>                            MAPI_MODIFY, <br>                            &amp;ulType, <br>                            (LPUNKNOWN FAR *)&amp;lprl-&gt;lpfldr)))) <br>        { <br>            hr = HrFolderFromPath (lpsmh, <br>                            lprl-&gt;lpmdb, <br>                            lpval[ipRLPath].Value.LPSZ, <br>                            &amp;lprl-&gt;lpfldr, <br>                            &amp;lpvalEid); <br>            if (HR_FAILED (hr)) <br>                goto ret; <br> <br>            lpvalEid-&gt;ulPropTag = PR_RULE_TARGET_ENTRYID; <br>            HrSetOneProp ((LPMAPIPROP)lpprof, lpvalEid); <br>            lprl-&gt;lpvalEid = lpvalEid; <br>        } <br>        else <br>        { <br>            hr = HrGetOneProp ((LPMAPIPROP)lprl-&gt;lpfldr, PR_ENTRYID, &amp;lprl-&gt;lpvalEid); <br>            if (HR_FAILED (hr)) <br>                goto ret; <br>        } <br>    } <br> <br>    if ((lpval[ipRLType].Value.l == RL_TO_RECIP) || <br>        (lpval[ipRLType].Value.l == RL_CC_RECIP) || <br>        (lpval[ipRLType].Value.l == RL_BCC_RECIP) || <br>        (lpval[ipRLType].Value.l == RL_ANY_RECIP)) <br>    { <br>        cb = (sizeof(SRestriction) * cresMax) + (sizeof(SPropValue) * cvMax); <br>        sc = (*lpsmh-&gt;lpfnAllocMore) (cb, lprl, &amp;lpres); <br>        if (FAILED (sc)) <br>        { <br>            hr = ResultFromScode (sc); <br>            goto ret; <br>        } <br>        lpvalT = (LPSPropValue)&amp;lpres[cresMax]; <br> <br>        lpres[iresAnd].rt = RES_AND; <br>        lpres[iresAnd].res.resAnd.cRes = 2; <br>        lpres[iresAnd].res.resAnd.lpRes = &amp;lpres[iresRecip]; <br> <br>        lpvalT[ivRecip].ulPropTag = PR_RECIPIENT_TYPE; <br>        lpvalT[ivRecip].Value.l = ((lpval[ipRLType].Value.l == RL_TO_RECIP) <br>                                    ? MAPI_TO <br>                                    : ((lpval[ipRLType].Value.l == RL_CC_RECIP) <br>                                        ? MAPI_CC <br>                                        : ((lpval[ipRLType].Value.l == RL_BCC_RECIP) <br>                                            ? MAPI_BCC <br>                                            : 0))); <br>        lpres[iresRecip].rt = RES_PROPERTY; <br>        lpres[iresRecip].res.resProperty.relop = RELOP_EQ; <br>        lpres[iresRecip].res.resContent.ulPropTag = PR_RECIPIENT_TYPE; <br>        lpres[iresRecip].res.resContent.lpProp = &amp;lpvalT[ivRecip]; <br> <br>        lpres[iresOr].rt = RES_OR; <br>        lpres[iresOr].res.resOr.cRes = 2; <br>        lpres[iresOr].res.resOr.lpRes = &amp;lpres[iresEmail]; <br> <br>        lpvalT[ivEmail].ulPropTag = PR_EMAIL_ADDRESS; <br>        lpvalT[ivEmail].Value.LPSZ = (LPTSTR)lprl-&gt;lpszData; <br>        lpres[iresEmail].rt = RES_CONTENT; <br>        lpres[iresEmail].res.resContent.ulFuzzyLevel = FL_SUBSTRING | FL_IGNORECASE; <br>        lpres[iresEmail].res.resContent.ulPropTag = PR_EMAIL_ADDRESS; <br>        lpres[iresEmail].res.resContent.lpProp = &amp;lpvalT[ivEmail]; <br> <br>        lpvalT[ivDispNm].ulPropTag = PR_DISPLAY_NAME; <br>        lpvalT[ivDispNm].Value.LPSZ = (LPTSTR)lprl-&gt;lpszData; <br>        lpres[iresDispNm].rt = RES_CONTENT; <br>        lpres[iresDispNm].res.resContent.ulFuzzyLevel = FL_SUBSTRING | FL_IGNORECASE; <br>        lpres[iresDispNm].res.resContent.ulPropTag = PR_DISPLAY_NAME; <br>        lpres[iresDispNm].res.resContent.lpProp = &amp;lpvalT[ivDispNm]; <br> <br>        if ((lpval[ipRLType].Value.l == RL_TO_RECIP) || <br>            (lpval[ipRLType].Value.l == RL_CC_RECIP) || <br>            (lpval[ipRLType].Value.l == RL_BCC_RECIP)) <br>            lprl-&gt;lpres = &amp;lpres[iresAnd]; <br>        else <br>            lprl-&gt;lpres = &amp;lpres[iresOr]; <br>    } <br> <br>ret: <br> <br>    (*lpsmh-&gt;lpfnFree) (lpval); <br> <br>    UlRelease (lpprof); <br>    if (HR_FAILED (hr)) <br>    { <br>        (*lpsmh-&gt;lpfnFree) (lprl-&gt;lpvalRecip); <br>        (*lpsmh-&gt;lpfnFree) (lprl-&gt;lpvalEid); <br>        (*lpsmh-&gt;lpfnFree) (lprl); <br>        lprl = NULL; <br>    } <br>    *lpprl = lprl; <br> <br>    DebugTraceResult (HrBuildRule(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  ReleaseBkit() <br> * <br> *  Purpose: <br> * <br> *      Cleans up all resources held by a bucket structure and wipes the <br> *      structure clean. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           pointer to the smh object (uses allocation fn's) <br> *      lpbkit          pointer to the bucket needing cleaning <br> * <br> */ <br>VOID <br>ReleaseBkit (LPSMH lpsmh, LPBKIT lpbkit) <br>{ <br>    UlRelease (lpbkit-&gt;lpfldr); <br>    UlRelease (lpbkit-&gt;lpfldrYr); <br>    UlRelease (lpbkit-&gt;lpfldrParent); <br>    (*lpsmh-&gt;lpfnFree) (lpbkit-&gt;lpeid); <br>    (*lpsmh-&gt;lpfnFree) (lpbkit-&gt;lpeidYr); <br>    (*lpsmh-&gt;lpfnFree) (lpbkit-&gt;lpeidParent); <br>    memset (lpbkit, 0, sizeof(BKIT)); <br>    return; <br>} <br> <br> <br>HRESULT <br>HrInitSMH (LPSMH lpsmh) <br>{ <br>    HRESULT hr; <br>    LPPROFSECT lpprof = NULL; <br>    LPRULE lprl; <br>    LPSPropValue lpval = NULL; <br>    LPSPropValue lpvalOld; <br>    UINT crl; <br>    ULONG cval; <br>     <br>    /*  Get options from the profile */ <br> <br>    hr = lpsmh-&gt;lpsess-&gt;lpVtbl-&gt;OpenProfileSection (lpsmh-&gt;lpsess, <br>                            &amp;lpsmh-&gt;muid, <br>                            NULL, <br>                            MAPI_MODIFY, <br>                            &amp;lpprof); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = lpprof-&gt;lpVtbl-&gt;GetProps (lpprof, <br>                            (LPSPropTagArray)&amp;sptConfigProps, <br>                            0, <br>                            &amp;cval, <br>                            &amp;lpval); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Check to see if we are configured */ <br> <br>    if (lpval[ipFlags].ulPropTag != PR_SMH_FLAGS) <br>    { <br>        hr = ResultFromScode (MAPI_E_UNCONFIGURED); <br>        goto ret; <br>    } <br> <br>    /*  Check that the rules are stored in the correct format */ <br>     <br>    if (lpval[ipRules].ulPropTag != PR_SMH_RULES) <br>    { <br>        hr = HrGetOneProp ((LPMAPIPROP)lpprof, <br>                    CHANGE_PROP_TYPE(PR_SMH_RULES, PT_BINARY), <br>                    &amp;lpvalOld); <br>        if (!HR_FAILED (hr)) <br>        { <br>            /*  The rules are stored in the wrong format */ <br> <br>            hr = HrUpdateProfileFormat (lpsmh-&gt;lpsess, <br>                            lpsmh-&gt;lpsess-&gt;lpVtbl-&gt;OpenProfileSection, <br>                            lpsmh-&gt;lpfnAllocMore, <br>                            lpsmh-&gt;lpfnFree, <br>                            lpval, <br>                            lpvalOld); <br>            (*lpsmh-&gt;lpfnFree) (lpvalOld); <br>            if (HR_FAILED (hr)) <br>                goto ret; </code></pre>
<p>
</p>
<pre><code><br>            /*  Save out anything we got back */ <br> <br>            lpprof-&gt;lpVtbl-&gt;SetProps (lpprof, cpMax, lpval, NULL); <br>        } <br>    } <br>    UlRelease (lpprof); <br>    lpprof = NULL; <br> <br>    /*  Grab the exclusions list */ <br> <br>    hr = ResultFromScode (PropCopyMore (&amp;lpsmh-&gt;valEx, <br>                            &amp;lpval[ipExc], <br>                            lpsmh-&gt;lpfnAllocMore, <br>                            lpsmh)); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Init the stores table */ <br> <br>    hr = HrInitStoresTable (lpsmh, lpsmh-&gt;lpsess); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Store the values */ <br> <br>    lpsmh-&gt;fAtp = !!(lpval[ipFlags].Value.l &amp; SMH_ADD_TO_PAB); <br>    lpsmh-&gt;fCatSm = !!(lpval[ipFlags].Value.l &amp; SMH_FILTER_SENTMAIL); <br>    lpsmh-&gt;fCatSmByYr = !!(lpval[ipFlags].Value.l &amp; SMH_FILTER_SENTMAIL_YR); <br> <br>    /*  If we are archiving deleted mail, init the filters */ <br>     <br>    if (lpval[ipFlags].Value.l &amp; SMH_FILTER_DELETED) <br>    { <br>        HrInitDeletedMailFilter (lpsmh); <br>        lpsmh-&gt;fCatWb = !!(lpval[ipFlags].Value.l &amp; SMH_FILTER_DELETED_YR); <br>    } <br>     <br>    /*  If the unread folder is desired, make sure it is there */ <br>     <br>    if (!!(lpval[ipFlags].Value.l &amp; SMH_UNREAD_VIEWER)) <br>        HrInitUnreadSearch (lpsmh); <br> <br>    /*  Setup the oof text */ <br>     <br>    if ((lpval[ipOofEnabled].ulPropTag == PR_SMH_OOF_ENABLED) &amp;&amp; <br>        lpval[ipOofEnabled].Value.b) <br>    { <br>        lpsmh-&gt;fOof = !HR_FAILED (HrInitOof (lpsmh, <br>                                        &amp;lpval[ipOof], <br>                                        &amp;lpval[ipOofRtf])); <br>    } <br> <br>    /*  Build the rules if need be */ <br>     <br>    if ((lpval[ipFlags].Value.l &amp; SMH_FILTER_INBOUND) &amp;&amp; <br>        (lpval[ipRules].ulPropTag == PR_SMH_RULES) &amp;&amp; <br>        (lpval[ipRules].Value.MVbin.cValues != 0)) <br>    { <br>        crl = (UINT)lpval[ipRules].Value.MVbin.cValues; <br>        while (crl--) <br>        { <br>            hr = HrBuildRule (lpsmh, <br>                    (LPMAPIUID)lpval[ipRules].Value.MVbin.lpbin[crl].lpb, <br>                    &amp;lprl); <br>            if (!HR_FAILED (hr)) <br>            { <br>                lprl-&gt;rlNext = lpsmh-&gt;lstRl; <br>                lpsmh-&gt;lstRl = lprl; <br>            } <br>        } <br>        hr = hrSuccess; <br>    } <br> <br>ret: <br> <br>    UlRelease (lpprof); <br>    (*lpsmh-&gt;lpfnFree) (lpval); <br> <br>    DebugTraceResult (HrInitSMH(), hr); <br>    return hr; <br>} <br> <br> <br>VOID <br>DeinitSMH (LPSMH lpsmh) <br>{ <br>    LPRULE lprl; <br>    LPRULE lprlT; <br>    LPWB lpwb; <br>    LPWB lpwbT; <br>     <br>    ReleaseBkit (lpsmh, &amp;lpsmh-&gt;bkitSm); <br>    memset (&amp;lpsmh-&gt;bkitSm, 0, sizeof(BKIT)); <br> <br>    for (lpwb = lpsmh-&gt;lstWb; lpwb; lpwb = lpwbT) <br>    { <br>        lpwbT = lpwb-&gt;wbNext; <br>        lpwb-&gt;lptbl-&gt;lpVtbl-&gt;Unadvise (lpwb-&gt;lptbl, lpwb-&gt;ulAdvz); <br> <br>#ifdef  _WIN32 <br>        if (lpwb-&gt;ht) <br>        { <br>            lpwb-&gt;fBail = TRUE; <br>            WaitForSingleObject (lpwb-&gt;ht, INFINITE); <br>        } <br>#endif <br> <br>        ReleaseBkit (lpsmh, &amp;lpwb-&gt;bkit); <br>        UlRelease (lpwb-&gt;lptbl); <br>        UlRelease (lpwb-&gt;lpfldr); <br> <br>        (*lpsmh-&gt;lpfnFree) (lpwb-&gt;lpvalEid); <br>        (*lpsmh-&gt;lpfnFree) (lpwb); <br> <br>    } <br>    lpsmh-&gt;lstWb = NULL; <br>    for (lprl = lpsmh-&gt;lstRl; lprl; lprl = lprlT) <br>    { <br>        lprlT = lprl-&gt;rlNext; <br>        ReleaseBkit (lpsmh, &amp;lprl-&gt;bkit); <br>        UlRelease (lprl-&gt;lpfldr); <br>        (*lpsmh-&gt;lpfnFree) (lprl-&gt;lpvalEid); <br>        (*lpsmh-&gt;lpfnFree) (lprl-&gt;lpvalRecip); <br>        (*lpsmh-&gt;lpfnFree) (lprl); <br>    } <br>    lpsmh-&gt;lstRl = NULL; <br> <br>    UlRelease (lpsmh-&gt;oof.lptad); <br>    UlRelease (lpsmh-&gt;oof.lptbl); <br>    (*lpsmh-&gt;lpfnFree) (lpsmh-&gt;oof.lpbRTF); <br>    (*lpsmh-&gt;lpfnFree) (lpsmh-&gt;oof.lpszBody); <br>    memset (&amp;lpsmh-&gt;oof, 0, sizeof(OOF)); <br> <br>    ReleaseStoresTable (lpsmh); <br>    return; <br>} <br> <br> <br>/* <br> *  SMH Object Methods <br> * <br> *  SMH_QueryInterface      (See OLE IUnknown object methods) <br> *  SMH_AddRef              (See OLE IUnknown object methods) <br> *  SMH_Release             (See OLE IUnknown object methods) <br> *  SMH_InboundMsgHook      Filters inbound messages <br> *  SMH_OutboundMsgHook     Filters sent mail messages <br> * <br> */ <br>STDMETHODIMP <br>SMH_QueryInterface (LPSMH lpsmh, REFIID lpiid, LPVOID FAR * lppv) <br>{ <br>    if (IsBadWritePtr (lpsmh, sizeof(SMH)) || <br>        IsBadReadPtr (lpiid, sizeof(IID)) || <br>        IsBadWritePtr (lppv, sizeof(LPVOID))) <br>        return ResultFromScode (MAPI_E_INVALID_PARAMETER); <br> <br>    if (!memcmp (lpiid, &amp;IID_ISpoolerHook, sizeof(IID)) || <br>        !memcmp (lpiid, &amp;IID_IUnknown, sizeof(IID))) <br>    { <br>        *lppv = (LPVOID)lpsmh; <br>        lpsmh-&gt;lcInit++; <br>        return hrSuccess; <br>    } <br>    DebugTraceSc (SMH_QueryInterface(), MAPI_E_INTERFACE_NOT_SUPPORTED); <br>    return ResultFromScode (MAPI_E_INTERFACE_NOT_SUPPORTED); <br>} <br> <br>STDMETHODIMP_ (ULONG) <br>SMH_AddRef (LPSMH lpsmh) <br>{ <br>    if (IsBadWritePtr (lpsmh, sizeof(SMH))) <br>        return 0; <br> <br>    return ++lpsmh-&gt;lcInit; <br>} <br> <br>STDMETHODIMP_ (ULONG) <br>SMH_Release (LPSMH lpsmh) <br>{ <br>    if (IsBadWritePtr (lpsmh, sizeof(SMH))) <br>        return 0; <br> <br>    if (--lpsmh-&gt;lcInit) <br>        return lpsmh-&gt;lcInit; <br> <br>    DeinitSMH (lpsmh); <br>     <br>    CloseHandle (lpsmh-&gt;hevtCfg); <br>    UlRelease (lpsmh-&gt;lpsess); <br>    (*lpsmh-&gt;lpfnFree) (lpsmh); <br>    if (lpCtl3D) <br>    { <br>        CTL3D_Uninitialize (lpCtl3D); <br>        lpCtl3D = NULL; <br>    } <br>    return 0; <br>} <br> <br>/* <br> *  SMH_InboundMsgHook() <br> * <br> *  Purpose: <br> * <br> *      The purpose of this filter is to match inbound messages to <br> *      individual rules from the profile and re-route the messages based <br> *      on the results of the comparisons. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           this filter hook obj <br> *      lpmsg           the message to be filtered <br> *      lpfldrDef       owning folder of message <br> *      lpmdbDef        owning store of message <br> *      lpulFlags       flags returned by filter <br> *      lpcbeid         cb for entryid of default target for message <br> *      lppbeid         pb for entryid of default target for message <br> * <br> *  Operation: <br> * <br> *      Opens the suggested folder (if needed) and checks for the <br> *      existence of the appropriate "bucket" folder.  If it does exist, <br> *      then the  folder is created and cached.  The entryid is grabbed <br> *      and passed back in to the spooler. <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> *      lpulFlags   [out]   set HOOK_CANCEL if this is the last hook <br> *      lpcbeid     [out]   the size of the returned EntryID <br> *      lppbeid     [out]   the data of the returned EntryID <br> * <br> */ <br>STDMETHODIMP <br>SMH_InboundMsgHook (LPSMH lpsmh, <br>    LPMESSAGE lpmsg, <br>    LPMAPIFOLDER lpfldrDef, <br>    LPMDB lpmdbDef, <br>    ULONG FAR * lpulFlags, <br>    ULONG FAR * lpcbeid, <br>    LPBYTE FAR * lppeid) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPRULE lprl; <br>    LPBYTE lpeid; <br>    LPSPropValue lpval = NULL; <br> <br>    /*  Quick and dirty parameter check */ <br> <br>    if (IsBadWritePtr (lpsmh, sizeof(SMH)) || <br>        IsBadWritePtr (lpcbeid, sizeof(ULONG)) || <br>        IsBadWritePtr (lppeid, sizeof(LPBYTE)) || <br>        IsBadWritePtr (*lppeid, (UINT)(*lpcbeid))) <br>        return ResultFromScode (MAPI_E_INVALID_PARAMETER); <br> <br>#ifdef  _WIN32 <br>    if (FConfigChanged (lpsmh-&gt;hevtCfg)) <br>    { <br>        /*  reconfiguration required */ <br>         <br>        DeinitSMH (lpsmh); <br>        hr = HrInitSMH (lpsmh); <br>        if (HR_FAILED (hr)) <br>            return hr; <br>         <br>        ResetEvent (lpsmh-&gt;hevtCfg); <br>    } <br>#endif  // _WIN32 <br>     <br>    if (lprl = lpsmh-&gt;lstRl)    /*  Yup '=' */ <br>    { <br>        hr = HrCheckExclusions (lpsmh, lpmsg); <br>        if (!HR_FAILED (hr)) <br>        { <br>            /*  We have not been excluded */ <br> <br>            for (; lprl; lprl = lprl-&gt;rlNext) <br>            { <br>                hr = HrCheckRule (lpsmh, lprl, lpmsg, &amp;lpval); <br>                if (!HR_FAILED (hr)) <br>                { <br>                    /*  We have a match. What do we do, filter or delete? */ <br>                     <br>                    if (!(lprl-&gt;ulFlags &amp; (RULE_DELETE | RULE_NO_MOVE))) <br>                    { <br>                        /*  Filter the critter */ <br> <br>                        hr = ResultFromScode ((*lpsmh-&gt;lpfnAlloc) (lprl-&gt;lpvalEid-&gt;Value.bin.cb, &amp;lpeid)); <br>                        if (!HR_FAILED (hr)) <br>                        { <br>                            memcpy (lpeid, lprl-&gt;lpvalEid-&gt;Value.bin.lpb, <br>                                (UINT)lprl-&gt;lpvalEid-&gt;Value.bin.cb); <br> <br>                            (*lpsmh-&gt;lpfnFree) (*lppeid); <br>                            *lpcbeid = lprl-&gt;lpvalEid-&gt;Value.bin.cb; <br>                            *lppeid = lpeid; <br> <br>                            if (lprl-&gt;ulFlags &amp; RULE_ARCHIVED) <br>                            { <br>                                hr = HrArchiveMessage (lpsmh, <br>                                            lpmsg, <br>                                            lpfldrDef, <br>                                            lpmdbDef, <br>                                            &amp;lprl-&gt;bkit, <br>                                            !!(lprl-&gt;ulFlags &amp; RULE_ARCHIVED_BY_YEAR), <br>                                            lpcbeid, <br>                                            lppeid); <br>                                 <br>                                if (lprl-&gt;ulFlags &amp; RULE_TERMINAL) <br>                                    *lpulFlags = HOOK_CANCEL; <br>                            } <br>                        } <br> <br>                        /*  Play the sound */ <br> <br>                        if ((lpval[ipPriority].Value.l &lt; 3) &amp;&amp; <br>                            lprl-&gt;rgszSnd[lpval[ipPriority].Value.l]) <br>                            sndPlaySound (lprl-&gt;rgszSnd[lpval[ipPriority].Value.l], SND_ASYNC); <br>                    } <br>                    else <br>                    { <br>                        if (lprl-&gt;ulFlags &amp; RULE_DELETE) <br>                            *lpulFlags |= HOOK_DELETE; <br>                                           <br>                        *lpulFlags |= HOOK_CANCEL; <br>                    } <br> <br>                    /*  Check for an auto-forward\reply */ <br> <br>                    if (lprl-&gt;ulFlags &amp; RULE_AUTO_RESPONSE) <br>                    { <br>                        /*  We have a response that needs to <br>                         *  be created, and sent on. <br>                         */ <br>                        hr = HrGenerateResponse (lpsmh, lprl, lpfldrDef, lpmsg); <br>                    } <br>                    break; <br>                } <br>                else if (GetScode (hr) != MAPI_E_NOT_ME) <br>                { <br>                    /*  We have a failure that is not really <br>                     *  expected, we need to bail.  Also, this <br>                     *  should cancel any further hooking <br>                     */ <br>                    *lpulFlags = HOOK_CANCEL; <br>                    break; <br>                } <br>                else <br>                    hr = hrSuccess; <br>            } <br>        } <br>    } <br>     <br>    if (lpsmh-&gt;fOof) <br>    { <br>        /*  OOF'ing is done by calling HrGenerateResponse() <br>         *  and passing in a NULL for the rule. <br>         */ <br>        hr = HrGenerateResponse (lpsmh, NULL, lpfldrDef, lpmsg); <br>    } <br> <br>    (*lpsmh-&gt;lpfnFree) (lpval); <br>    DebugTraceResult (SMH_InboundMsgHook(), hr); <br>    return hrSuccess; <br>} <br> <br> <br>/* <br> *  SMH_OutboundMsgHook() <br> * <br> *  Purpose: <br> * <br> *      The purpose of this filter is to "hash" a users sent mail <br> *      processing based on date.  The most obvious bucket size is <br> *      monthly but there is no reason not to make this an option the <br> *      user could confiigure. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           this filter hook obj <br> *      lpmsg           the message to be filtered <br> *      lpfldrDef       owning folder of message <br> *      lpmdbDef        owning store of message <br> *      lpulFlags       flags returned by filter <br> *      lpcbeid         cb for entryid of default target for message <br> *      lppbeid         pb for entryid of default target for message <br> * <br> *  Operation: <br> * <br> *      Opens the suggested folder (if needed) and checks for the <br> *      existence of the appropriate "bucket" folder.  If it does exist, <br> *      then the  folder is created and cached.  The entryid is grabbed <br> *      and passed back in to the spooler. <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> *      lpulFlags   [out]   set HOOK_CANCEL if this is the last hook <br> *      lpcbeid     [out]   the size of the returned EntryID <br> *      lppbeid     [out]   the data of the returned EntryID <br> * <br> */ <br>STDMETHODIMP <br>SMH_OutboundMsgHook (LPSMH lpsmh, <br>    LPMESSAGE lpmsg, <br>    LPMAPIFOLDER lpfldrDef, <br>    LPMDB lpmdbDef, <br>    ULONG FAR * lpulFlags, <br>    ULONG FAR * lpcbeid, <br>    LPBYTE FAR * lppeid) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    /*  Quick and dirty parameter check */ <br> <br>    if (IsBadWritePtr (lpsmh, sizeof(SMH)) || <br>        IsBadWritePtr (lpcbeid, sizeof(ULONG)) || <br>        IsBadWritePtr (lppeid, sizeof(LPBYTE)) || <br>        IsBadWritePtr (*lppeid, (UINT)(*lpcbeid))) <br>        return ResultFromScode (MAPI_E_INVALID_PARAMETER); <br> <br>#ifdef  _WIN32 <br>    if (FConfigChanged (lpsmh-&gt;hevtCfg)) <br>    { <br>        /*  reconfiguration required */ <br>         <br>        DeinitSMH (lpsmh); <br>        hr = HrInitSMH (lpsmh); <br>        if (HR_FAILED (hr)) <br>            return hr; <br>         <br>        ResetEvent (lpsmh-&gt;hevtCfg); <br>    } <br>#endif  // _WIN32 <br> <br>    if (lpsmh-&gt;fAtp) <br>        (void) HrAddEntriesToPab (lpsmh, lpmsg); <br> <br>    if (lpsmh-&gt;fCatSm) <br>        hr = HrArchiveMessage (lpsmh, <br>                lpmsg, <br>                lpfldrDef, <br>                lpmdbDef, <br>                &amp;lpsmh-&gt;bkitSm, <br>                lpsmh-&gt;fCatSmByYr, <br>                lpcbeid, <br>                lppeid); <br> <br>    DebugTraceResult (SMH_OutboundMsgHook(), hr); <br>    return hrSuccess; <br>} <br> <br> <br>/* <br> *  SMH_Init() <br> * <br> *  Purpose: <br> * <br> *      Spooler's entry into the sample mail handler.  This function is <br> *      equivilent to a provider logon in that it returns an object to <br> *      the spooler that will be used to make any additional calls into <br> *      the handler. <br> * <br> *  Arguments: <br> * <br> *      lpsess          the session this handler relates to <br> *      hinst           hinst of the SMH dll <br> *      lpfnAlloc       pointer to MAPIAllocateBuffer() <br> *      lpfnAllocMore   pointer to MAPIAllocateMore() <br> *      lpfnFree        pointer to MAPIFreeBuffer() <br> *      lpmuid          pointer to profile section muid <br> *      ulFlags         flags <br> *      lppHook         buffer to hold handler object <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> *      lpphook     [OUT]   holds the returned handler object iff successful <br> */ <br>STDINITMETHODIMP <br>SMH_Init (LPMAPISESSION lpsess, <br>    HINSTANCE hinst, <br>    LPALLOCATEBUFFER lpfnAlloc, <br>    LPALLOCATEMORE lpfnAllocMore, <br>    LPFREEBUFFER lpfnFree, <br>    LPMAPIUID lpmuid, <br>    ULONG ulFlags, <br>    LPSPOOLERHOOK FAR * lppHook) <br>{ <br>    SCODE sc; <br>    LPSMH lpsmh = NULL; <br>    HRESULT hr; <br> <br>    sc = (*lpfnAlloc) (sizeof(SMH), &amp;lpsmh); <br>    if (FAILED (sc)) <br>        return ResultFromScode (sc); <br>    memset (lpsmh, 0, sizeof(SMH)); <br> <br>    hr = lpsess-&gt;lpVtbl-&gt;QueryInterface (lpsess, <br>                            &amp;IID_IMAPISession, <br>                            &amp;lpsmh-&gt;lpsess); <br>    if (!HR_FAILED (hr)) <br>    { <br>        /*  Fill in all fields of the object */ <br> <br>        lpsmh-&gt;lpVtbl = (SMH_Vtbl FAR *)&amp;vtblSMH; <br>        lpsmh-&gt;lcInit = 1; <br>        lpsmh-&gt;hinst = hinst; <br>        lpsmh-&gt;lpsess = lpsess; <br>        lpsmh-&gt;lpfnAlloc = lpfnAlloc; <br>        lpsmh-&gt;lpfnAllocMore = lpfnAllocMore; <br>        lpsmh-&gt;lpfnFree = lpfnFree; <br>        memcpy (&amp;lpsmh-&gt;muid, lpmuid, sizeof(MAPIUID)); <br> <br>#ifdef  _WIN32 <br>        /*  Setup listening for configuration changes */ <br> <br>        (void)HrGetConfigEvent (&amp;lpsmh-&gt;hevtCfg); <br>#endif <br> <br>        /*  Fill out the rest of the structure */ <br>         <br>        hr = HrInitSMH (lpsmh); <br>    } <br> <br>    if (HR_FAILED (hr)) <br>    { <br>        UlRelease (lpsmh); <br>        lpsmh = NULL; <br>    } <br>    *lppHook = (LPSPOOLERHOOK)lpsmh; <br>    DebugTraceResult (SMH_Init(), hr); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
