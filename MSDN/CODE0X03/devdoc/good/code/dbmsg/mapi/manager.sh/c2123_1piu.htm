<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHPS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2136"></a>SMHPS.C</h2>
<pre><code>/* <br> *  S M H P S . C <br> * <br> *  Sample mail handling hook configuration property sheets <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br>#ifndef WIN16 <br>#include &lt;commctrl.h&gt; <br>#endif <br> <br>extern LPTSTR lpszConfigEvt; <br>extern SPropTagArray sptRule; <br>extern SPropTagArray sptConfigProps; <br> <br>typedef struct _FILTER <br>{ <br>    LPSCD               lpscd;              /* back-pointer to config struct */ <br>     <br>    TCHAR               rgch[cchNameMax];   /* filter name */ <br>    MAPIUID             muid;               /* muid of filter profile section */ <br>    LPPROFSECT          lpsec;              /* profile section object */ <br>    LPSPropValue        lpval;              /* filter property values */ <br> <br>    SCODE               sc; <br> <br>} FILTER, FAR * LPFILTER; <br> <br> <br> <br>/*  sptDelete <br> * <br> *  This is the set of properties that need to be deleted from a rule <br> *  profile section any time the rule is edited.  Otherwise, changes in <br> *  target folders may not be retained across edits. <br> */ <br>const static SizedSPropTagArray (2, sptDelete) = <br>{ <br>    2, <br>    { <br>        PR_RULE_TARGET_ENTRYID, <br>        PR_RULE_STORE_ENTRYID <br>    } <br>}; <br> <br>enum {ipMsgSto, ipDefSto, cpStoTblMax}; <br>const static SizedSPropTagArray (cpStoTblMax, sptStoTbl) = <br>{ <br>    cpStoTblMax, <br>    { <br>        PR_DISPLAY_NAME, <br>        PR_DEFAULT_STORE <br>    } <br>}; <br>             <br>/* <br> *  Common Dialog Functions --------------------------------------------------- <br> */ <br> <br>/* <br> *  SizeODButtons() <br> * <br> *  Purpose: <br> * <br> *      Set the control size for the two owner-draw buttons in the filter <br> *      page of the configuration property sheets. <br> * <br> *  Arguments: <br> * <br> *      hinst       the DLL instance <br> *      hdlg        the dialog in which the buttons will be drawn <br> *      id          the dialog ID identifying which buttons to size <br> */ <br>VOID <br>SizeODButtons (HINSTANCE hInst, HWND hdlg, UINT id) <br>{ <br>    BITMAP  bitmap; <br>    HBITMAP hbmp; <br> <br>    if (!(hbmp = LoadBitmap (hInst, MAKEINTRESOURCE(ID_UpArrow)))) <br>        return; <br>    GetObject (hbmp, sizeof(BITMAP), &amp;bitmap); <br> <br>    if (id == SMH_FilterPage) <br>    { <br>        SetWindowPos (GetDlgItem (hdlg, ID_FilterUp), NULL, 0, 0, bitmap.bmWidth, <br>            bitmap.bmHeight, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER); <br>        SetWindowPos (GetDlgItem (hdlg, ID_FilterDown), NULL, 0, 0, bitmap.bmWidth, <br>            bitmap.bmHeight, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER); <br>    } <br>    DeleteBitmap (hbmp); <br>} <br> <br> <br>/* <br> *  DrawODButton() <br> * <br> *  Purpose: <br> * <br> *      Draws the button control for either of the two owner-draw buttons <br> *      in the filter page of the configuration property sheets. <br> * <br> *  Arguments: <br> * <br> *      hinst       the DLL instance <br> *      pdi         the DRAWITEMSTRUCT info for drawing the button <br> */ <br>VOID <br>DrawODButton (HINSTANCE hInst, DRAWITEMSTRUCT FAR * lpdi, BOOL fDrawFocus) <br>{ <br>    HDC hDC; <br>    HBITMAP hbmpOld; <br>    HBITMAP hbmpArw; <br>    WORD wBtnRes; <br>    BITMAP bitmap; <br> <br>    Assert (lpdi-&gt;CtlType == ODT_BUTTON); <br>    if (!(hDC = CreateCompatibleDC (lpdi-&gt;hDC))) <br>        return; <br> <br>    /*  Get the bitmap */ <br> <br>    if (lpdi-&gt;itemState &amp; ODS_SELECTED) <br>        wBtnRes = (lpdi-&gt;CtlID == ID_FilterUp) ? ID_UpArrowInv : ID_DownArrowInv; <br>    else if (lpdi-&gt;itemState &amp; ODS_DISABLED) <br>        wBtnRes = (lpdi-&gt;CtlID == ID_FilterUp) ? ID_UpArrowDis : ID_DownArrowDis; <br>    else <br>        wBtnRes = (lpdi-&gt;CtlID == ID_FilterUp) ? ID_UpArrow : ID_DownArrow; <br> <br>    /*  blit the bitmap */ <br> <br>    if (!(hbmpArw = CreateMappedBitmap (hInst, wBtnRes, FALSE, NULL, 0))) <br>        goto ret; <br>    hbmpOld = SelectObject (hDC, hbmpArw); <br>    BitBlt (lpdi-&gt;hDC, 0, 0, lpdi-&gt;rcItem.right - lpdi-&gt;rcItem.left, <br>        lpdi-&gt;rcItem.bottom - lpdi-&gt;rcItem.top, hDC, 0, 0, SRCCOPY); <br> <br>    /*  Draw a focus rectangle if the button has the focus */ <br> <br>    if(fDrawFocus &amp;&amp; (lpdi-&gt;itemState &amp; ODS_FOCUS)) <br>    { <br>        GetObject (hbmpArw, sizeof(BITMAP), &amp;bitmap); <br>        lpdi-&gt;rcItem.right = bitmap.bmWidth; <br>        lpdi-&gt;rcItem.bottom = bitmap.bmHeight; <br>        InflateRect (&amp;lpdi-&gt;rcItem, -3, -3); <br>        if (lpdi-&gt;itemState &amp; ODS_SELECTED) <br>            OffsetRect (&amp;lpdi-&gt;rcItem, 1, 1); <br>        DrawFocusRect (lpdi-&gt;hDC, &amp;lpdi-&gt;rcItem); <br>    } <br> <br>    SelectObject (hDC, hbmpOld); <br>    DeleteBitmap (hbmpArw); <br>ret: <br>    DeleteDC (hDC); <br>} <br> <br> <br>/* <br> *  RTF Stream Callbacks ------------------------------------------------------ <br> */ <br> <br>DWORD CALLBACK <br>WriteRTFToBuffer (DWORD dwCookie, LPBYTE lpb, LONG cb, LONG FAR * lpcb) <br>{ <br>    LPBYTE lpbT = NULL; <br>    LPRTFS lprtfs = (LPRTFS)dwCookie; <br> <br>    if ((lprtfs-&gt;cb + cb) &gt; lprtfs-&gt;cbMax) <br>    { <br>        if (!FAILED ((*lprtfs-&gt;lpfnAlloc) (lprtfs-&gt;cb + (cb * 2), &amp;lpbT))) <br>        { <br>            memcpy (lpbT, lprtfs-&gt;lpb, (UINT)lprtfs-&gt;cb); <br>            (*lprtfs-&gt;lpfnFree) (lprtfs-&gt;lpb); <br>            lprtfs-&gt;lpb = lpbT; <br>            lprtfs-&gt;cbMax = lprtfs-&gt;cb + (cb * 2); <br>        } <br>        else <br>            return (DWORD)E_FAIL; <br>    } <br> <br>    memcpy (lprtfs-&gt;lpb + lprtfs-&gt;cb, lpb, (UINT)cb); <br>    lprtfs-&gt;cb += cb; <br>    *lpcb = cb; <br> <br>    return (DWORD)NOERROR; <br>} <br> <br> <br>DWORD CALLBACK <br>ReadRTFFromBuffer (DWORD dwCookie, LPBYTE lpb, LONG cb, LONG FAR * lpcb) <br>{ <br>    LPRTFS lprtfs = (LPRTFS)dwCookie; <br> <br>    cb = min (lprtfs-&gt;cb + cb, lprtfs-&gt;cbMax) - lprtfs-&gt;cb; <br>    memcpy (lpb, lprtfs-&gt;lpb + lprtfs-&gt;cb, (UINT)cb); <br>    lprtfs-&gt;cb += cb; <br>    *lpcb = cb; <br> <br>    return NOERROR; <br>} <br> <br>/* <br> *  Store listbox support ----------------------------------------------------- <br> */ <br>VOID <br>FillStoresListbox (LPSCD lpscd, HWND hdlg) <br>{ <br>    HRESULT hr = hrSuccess; <br>    CHAR rgch[MAX_PATH] = {0}; <br>    HWND hctrl = GetDlgItem (hdlg, ID_Store); <br>    LPMAPISESSION lpsess; <br>    LPMAPITABLE lptbl = NULL; <br>    LPSRowSet lprws = NULL; <br>    UINT iDef; <br>    UINT irw; <br>     <br>    /*  Logon to the profile for access to the stores table */ <br>     <br>    if (!(lpsess = lpscd-&gt;lpsess)) <br>    { <br>        hr = MAPILogonEx ((ULONG)GetParent (hdlg), <br>                    lpscd-&gt;lpval[ipProfile].Value.lpszA, <br>                    NULL, <br>                    MAPI_NEW_SESSION            | <br>                         MAPI_EXPLICIT_PROFILE  | <br>                         MAPI_EXTENDED          | <br>                         MAPI_NO_MAIL           | <br>                         MAPI_PASSWORD_UI       | <br>                         MAPI_TIMEOUT_SHORT, <br>                    &amp;lpsess); <br>    } <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = lpsess-&gt;lpVtbl-&gt;GetMsgStoresTable (lpsess, 0, &amp;lptbl); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = lptbl-&gt;lpVtbl-&gt;SetColumns (lptbl, (LPSPropTagArray)&amp;sptStoTbl, 0); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    while (TRUE) <br>    { <br>        hr = lptbl-&gt;lpVtbl-&gt;QueryRows (lptbl, 64, 0, &amp;lprws); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        if (lprws-&gt;cRows == 0) <br>            break; <br> <br>        for (irw = 0; irw &lt; lprws-&gt;cRows; irw++) <br>        { <br>            ComboBox_AddString (hctrl, <br>                lprws-&gt;aRow[irw].lpProps[ipMsgSto].Value.lpszA); <br> <br>            if (lprws-&gt;aRow[irw].lpProps[ipDefSto].Value.b) <br>                lstrcpy (rgch, lprws-&gt;aRow[irw].lpProps[ipMsgSto].Value.lpszA); <br>                     <br>            /*  Free the row data */ <br>             <br>            (*lpscd-&gt;lpfnFree) (lprws-&gt;aRow[irw].lpProps); <br>        } <br>         <br>        (*lpscd-&gt;lpfnFree) (lprws); <br>        lprws = NULL; <br>    } <br>    (*lpscd-&gt;lpfnFree) (lprws); <br>    lprws = NULL; <br> <br>    iDef = ComboBox_FindString (hctrl, -1, rgch); <br>    ComboBox_SetCurSel (hctrl, iDef == CB_ERR ? 0 : iDef); <br>     <br>ret: <br>     <br>    lpscd-&gt;lpsess = lpsess; <br>    UlRelease (lptbl); <br>    return; <br>} <br> <br> <br>SCODE <br>ScPickResponseRecip (HWND hdlg, LPFILTER lpfltr) <br>{ <br>    HRESULT hr; <br>    SCODE sc = S_OK; <br>    ADRPARM adrparm = {0}; <br>    CHAR rgch[cchNameMax]; <br>    LPADRBOOK lpab = NULL; <br>    LPADRLIST lpadr = NULL; <br>    LPSCD lpscd = lpfltr-&gt;lpscd; <br>    LPSPropValue lpval = lpfltr-&gt;lpval; <br>    LPSPropValue lpvalT; <br>    LPTSTR rglpszDestTitles[] = { "To" }; <br>    ULONG rgulDestComps[] = { MAPI_TO }; <br>    UINT ip; <br> <br>    hr = lpscd-&gt;lpsess-&gt;lpVtbl-&gt;OpenAddressBook (lpscd-&gt;lpsess, <br>                                        0, <br>                                        NULL, <br>                                        AB_NO_DIALOG, <br>                                        &amp;lpab); <br>    if (!HR_FAILED (hr)) <br>    { <br>        /*  Iniitalize the adrparm structure */ <br> <br>        wsprintf (rgch, "Auto-Forward Recipient for '%s'", lpfltr-&gt;rgch); <br> <br>        adrparm.ulFlags = ADDRESS_ONE | DIALOG_MODAL | AB_RESOLVE; <br>        adrparm.lpszCaption = rgch; <br>        adrparm.lpszNewEntryTitle = rgch; <br>        adrparm.lpszDestWellsTitle = "Auto-Forward Recipient"; <br>        adrparm.lppszDestTitles = rglpszDestTitles; <br>        adrparm.lpulDestComps = rgulDestComps; <br>        adrparm.lpContRestriction = NULL; <br>        hr = lpab-&gt;lpVtbl-&gt;Address (lpab, (ULONG FAR*)&amp;hdlg, &amp;adrparm, &amp;lpadr); <br>        if (!HR_FAILED (hr)) <br>        { <br>            /*  Zip though and copy out the display name and the <br>             *  entryid <br>             */ <br>            lpvalT = lpadr-&gt;aEntries[0].rgPropVals; <br>            for (ip = 0; ip &lt; lpadr-&gt;aEntries[0].cValues; lpvalT++, ip++) <br>            { <br>                if (lpvalT-&gt;ulPropTag == PR_DISPLAY_NAME) <br>                { <br>                    sc = (*lpscd-&gt;lpfnAllocMore) (lstrlen (lpvalT-&gt;Value.LPSZ) + 1, <br>                        lpval, &amp;(lpval[ipRLFwdRecip].Value.lpszA)); <br>                    if (FAILED (sc)) <br>                        goto ret; <br> <br>                    lpval[ipRLFwdRecip].ulPropTag = PR_RULE_FORWARD_RECIP; <br>                    lstrcpy (lpval[ipRLFwdRecip].Value.lpszA, <br>                        lpvalT-&gt;Value.lpszA); <br>                } <br>                else if (lpvalT-&gt;ulPropTag == PR_ENTRYID) <br>                { <br>                    sc = (*lpscd-&gt;lpfnAllocMore) (lpvalT-&gt;Value.bin.cb, lpval, <br>                        &amp;(lpval[ipRLFwdEid].Value.bin.lpb)); <br>                    if (FAILED (sc)) <br>                        goto ret; <br> <br>                    lpval[ipRLFwdEid].ulPropTag = PR_RULE_FORWARD_RECIP_ENTRYID; <br>                    lpval[ipRLFwdEid].Value.bin.cb = lpvalT-&gt;Value.bin.cb; <br>                    memcpy (lpval[ipRLFwdEid].Value.bin.lpb, <br>                        lpvalT-&gt;Value.bin.lpb, <br>                        lpvalT-&gt;Value.bin.cb); <br>                } <br>            } <br>ret: <br>            (*lpscd-&gt;lpfnFree) (lpadr-&gt;aEntries[0].rgPropVals); <br>            (*lpscd-&gt;lpfnFree) (lpadr); <br>            hr = ResultFromScode (sc); <br>        } <br>        UlRelease (lpab); <br>    } <br> <br>    DebugTraceResult (ScPickResponseRecip(), hr); <br>    return GetScode (hr); <br>} <br> <br> <br>SCODE <br>ScResolveResponseRecip (HWND hdlg, LPFILTER lpfltr, LPTSTR lpszRecip) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hr; <br>    CHAR rgch[cchNameMax]; <br>    CHAR rgch2[256]; <br>    BOOL fCtl3d = FALSE; <br>    LPADRBOOK lpab = NULL; <br>    LPADRLIST lpadr = NULL; <br>    LPSCD lpscd = lpfltr-&gt;lpscd; <br>    LPSPropValue lpval = lpfltr-&gt;lpval; <br>    LPSPropValue lpvalT; <br>    UINT ip; <br> <br>    hr = lpscd-&gt;lpsess-&gt;lpVtbl-&gt;OpenAddressBook (lpscd-&gt;lpsess, <br>                                        0, <br>                                        NULL, <br>                                        AB_NO_DIALOG, <br>                                        &amp;lpab); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    if (FAILED (sc = (*lpscd-&gt;lpfnAlloc) (sizeof(SPropValue), &amp;lpvalT)) || <br>        FAILED (sc = (*lpscd-&gt;lpfnAlloc) (CbNewADRLIST(1), &amp;lpadr))) <br>    { <br>        hr = ResultFromScode (sc); <br>        goto ret; <br>    } <br> <br>    lpadr-&gt;cEntries = 1; <br>    lpadr-&gt;aEntries[0].cValues = 1; <br>    lpadr-&gt;aEntries[0].rgPropVals = lpvalT; <br>    lpvalT[0].ulPropTag = PR_DISPLAY_NAME; <br>    lpvalT[0].Value.LPSZ = lpszRecip; <br>    wsprintf (rgch, "Auto-Forward Recipient for '%s'", lpszRecip); <br>    hr = lpab-&gt;lpVtbl-&gt;ResolveName (lpab, 0, 0, rgch, lpadr); <br>    if (HR_FAILED (hr)) <br>    { <br>        wsprintf (rgch2, <br>            "Recipient '%s' for auto-forward filter '%s' is ambiguous.\n" <br>            "Please select a recipient from the Check Names dialog.", <br>            lpszRecip, lpfltr-&gt;rgch); <br>             <br>        if (CTL3D_GetVer(lpCtl3D) &gt;= 0x220 &amp;&amp; !CTL3D_IsAutoSubclass(lpCtl3D)) <br>            CTL3D_AutoSubclass (lpCtl3D, lpscd-&gt;hinst, &amp;fCtl3d); <br>        MessageBox (hdlg, rgch2, rgch, MB_TASKMODAL | MB_OK | MB_ICONINFORMATION); <br>        CTL3D_CeaseAutoSubclass(lpCtl3D, fCtl3d); <br>         <br>        hr = lpab-&gt;lpVtbl-&gt;ResolveName (lpab, (ULONG)hdlg, MAPI_DIALOG, rgch, lpadr); <br>    } <br> <br>    if (!HR_FAILED (hr)) <br>    { <br>        /*  Zip though and copy out the display name and the <br>         *  entryid <br>         */ <br>        lpvalT = lpadr-&gt;aEntries[0].rgPropVals; <br>        for (ip = 0; ip &lt; lpadr-&gt;aEntries[0].cValues; lpvalT++, ip++) <br>        { <br>            if (lpvalT-&gt;ulPropTag == PR_DISPLAY_NAME) <br>            { <br>                sc = (*lpscd-&gt;lpfnAllocMore) (lstrlen (lpvalT-&gt;Value.LPSZ) + 1, <br>                    lpval, &amp;(lpval[ipRLFwdRecip].Value.lpszA)); <br>                if (FAILED (sc)) <br>                { <br>                    hr = ResultFromScode (sc); <br>                    goto ret; <br>                } <br> <br>                lpval[ipRLFwdRecip].ulPropTag = PR_RULE_FORWARD_RECIP; <br>                lstrcpy (lpval[ipRLFwdRecip].Value.lpszA, <br>                         lpvalT-&gt;Value.lpszA); <br>            } <br>            else if (lpvalT-&gt;ulPropTag == PR_ENTRYID) <br>            { <br>                sc = (*lpscd-&gt;lpfnAllocMore) (lpvalT-&gt;Value.bin.cb, lpval, <br>                    &amp;(lpval[ipRLFwdEid].Value.bin.lpb)); <br>                if (FAILED (sc)) <br>                { <br>                    hr = ResultFromScode (sc); <br>                    goto ret; <br>                } <br> <br>                lpval[ipRLFwdEid].ulPropTag = PR_RULE_FORWARD_RECIP_ENTRYID; <br>                lpval[ipRLFwdEid].Value.bin.cb = lpvalT-&gt;Value.bin.cb; <br>                memcpy (lpval[ipRLFwdEid].Value.bin.lpb, <br>                        lpvalT-&gt;Value.bin.lpb, <br>                        lpvalT-&gt;Value.bin.cb); <br>            } <br>        } <br>    } <br> <br>ret: <br>     <br>    if (lpadr) <br>    { <br>        (*lpscd-&gt;lpfnFree) (lpadr-&gt;aEntries[0].rgPropVals); <br>        (*lpscd-&gt;lpfnFree) (lpadr); <br>    } <br> <br>    UlRelease (lpab); <br>    DebugTraceResult (ScResolveResponseRecip(), hr); <br>    return GetScode (hr); <br>} <br> <br> <br>/* <br> *  Filter Description Property Sheet Page ------------------------------------ <br> *   <br> *  The Filter description page of the configuration property sheets <br> *  provides access to the many flags that are available to the SMH <br> *  service. <br> */ <br> <br>/* <br> *  FilterDescriptionPage_INITDAILOG() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_INITDIALOG message for the filter description dialog <br> */ <br>BOOL <br>FilterDescriptionPage_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    LPFILTER lpfltr = (LPFILTER)(((PROPSHEETPAGE *)lParam)-&gt;lParam); <br>    LPSPropValue lpval; <br>    HWND hctrl; <br>    UINT iSto; <br> <br>    /*  Setup the dialog */ <br> <br>    CTL3D_Subclass (lpCtl3D, hdlg, CTL3D_ALL); <br>    SetWindowLong (hdlg, DWL_USER, ((PROPSHEETPAGE *)lParam)-&gt;lParam); <br> <br>    Edit_LimitText (GetDlgItem (hdlg, ID_Name), cchNameMax); <br> <br>    if (lpval = lpfltr-&gt;lpval) <br>    { <br>        /*  Fill in the display name */ <br>         <br>        Assert (!IsBadReadPtr (lpval, sizeof(SPropValue) * cpRLMax)); <br>        if (lpval[ipRLDisp].ulPropTag == PR_DISPLAY_NAME) <br>            Edit_SetText (GetDlgItem (hdlg, ID_Name), <br>                    lpval[ipRLDisp].Value.LPSZ); <br> <br>        /*  Check the corresponding rule type.  Note that the rule type <br>         *  enumeration follows the same order as the corresponding control <br>         *  ID's such that calculating the rule type is a simple addition to <br>         *  the base control ID. <br>         */ <br>        if (lpval[ipRLType].ulPropTag == PR_RULE_TYPE) <br>            CheckRadioButton (hdlg, <br>                    ID_AnyRecip, <br>                    ID_ToRecip, <br>                    (UINT)(ID_AnyRecip + lpval[ipRLType].Value.l - 1)); <br>             <br>        /*  Setup the rule data */ <br>         <br>        if (lpval[ipRLData].ulPropTag == PR_RULE_DATA) <br>            Edit_SetText (GetDlgItem (hdlg, ID_Value), <br>                    lpval[ipRLData].Value.bin.lpb); <br> <br>        /*  Setup the message store display name.  Note that an empty or <br>         *  missing value here implies uses the default store. <br>         */ <br>        FillStoresListbox (lpfltr-&gt;lpscd, hdlg); <br>        if (lpval[ipRLStore].ulPropTag == PR_RULE_STORE_DISPLAY_NAME) <br>        { <br>            hctrl = GetDlgItem (hdlg, ID_Store); <br>            iSto = ComboBox_FindString (hctrl, -1, lpval[ipRLStore].Value.lpszA); <br>            ComboBox_SetCurSel (hctrl, iSto == CB_ERR ? 0 : iSto); <br>        } <br> <br>        /*  Setup the target folder path */ <br>         <br>        if (lpval[ipRLPath].ulPropTag == PR_RULE_TARGET_PATH) <br>            Edit_SetText (GetDlgItem (hdlg, ID_Folder), <br>                    lpval[ipRLPath].Value.LPSZ); <br> <br>        /*  Check the boxes indicated by the rule flags */ <br>         <br>        if (lpval[ipRLFlags].ulPropTag == PR_RULE_FLAGS) <br>        { <br>            CheckDlgButton (hdlg, ID_NotMatch, <br>                    !!(lpval[ipRLFlags].Value.l &amp; RULE_NOT)); <br>            CheckDlgButton (hdlg, ID_ArchTarg, <br>                    !!(lpval[ipRLFlags].Value.l &amp; RULE_ARCHIVED)); <br>            CheckDlgButton (hdlg, ID_ArchTargYr, <br>                    !!(lpval[ipRLFlags].Value.l &amp; RULE_ARCHIVED_BY_YEAR)); <br>            EnableWindow (GetDlgItem (hdlg, ID_ArchTargYr), <br>                    !!(lpval[ipRLFlags].Value.l &amp; RULE_ARCHIVED)); <br> <br>            if (lpval[ipRLFlags].Value.l &amp; RULE_DELETE) <br>            { <br>                CheckRadioButton (hdlg, ID_DeleteMsg, ID_FilterMsg, ID_DeleteMsg); <br>                EnableWindow (GetDlgItem (hdlg, ID_ArchTarg), FALSE); <br>                EnableWindow (GetDlgItem (hdlg, ID_ArchTargYr), FALSE); <br>                EnableWindow (GetDlgItem (hdlg, ID_Folder), FALSE); <br>                EnableWindow (GetDlgItem (hdlg, ID_ReplyFwd), FALSE); <br>                EnableWindow (GetDlgItem (hdlg, ID_Store), FALSE); <br>                EnableWindow (GetDlgItem (hdlg, ID_Txt3), FALSE); <br>                EnableWindow (GetDlgItem (hdlg, ID_Txt4), FALSE); <br>            } <br>            else if (lpval[ipRLFlags].Value.l &amp; RULE_NO_MOVE) <br>                CheckRadioButton (hdlg, ID_DeleteMsg, ID_FilterMsg, ID_LeaveMsg); <br>            else <br>                CheckRadioButton (hdlg, ID_DeleteMsg, ID_FilterMsg, ID_FilterMsg); <br>        } <br>        else <br>        { <br>            Button_Enable (GetDlgItem (hdlg, ID_ArchTargYr), FALSE); <br>            CheckRadioButton (hdlg, ID_FilterMsg, ID_DeleteMsg, ID_FilterMsg); <br>            lpval[ipRLFlags].ulPropTag = PR_RULE_FLAGS; <br>            lpval[ipRLFlags].Value.l = 0; <br>        } <br>    } <br>     <br>    return TRUE; <br>} <br> <br>/* <br> *  FilterDescriptionPage_NOTIFY() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_NOTIFY message for the filter description dialog. <br> *      On PSN_APPLY, SMHFlags is recomputed from the checkbox states. <br> */ <br>BOOL <br>FilterDescriptionPage_NOTIFY (HWND hdlg, UINT id, NMHDR FAR * lpnmhdr) <br>{ <br>    SCODE sc; <br>    HRESULT hr; <br>    HWND hctrl; <br>    LPFILTER lpfltr = (LPFILTER)GetWindowLong (hdlg, DWL_USER); <br>    LPSCD lpscd = lpfltr-&gt;lpscd; <br>    LPSPropValue lpval = lpfltr-&gt;lpval; <br>    UINT cb; <br>    UINT i; <br> <br>    switch (lpnmhdr-&gt;code) <br>    { <br>      case PSN_KILLACTIVE: <br>        if (IsDlgButtonChecked (hdlg, ID_FilterMsg) &amp;&amp; <br>            Edit_GetTextLength (GetDlgItem(hdlg, ID_Folder)) == 0) <br>        { <br>            MessageBox(hdlg, "You have to enter folder name",  <br>                        "Sample Spooler Hook",  <br>                        MB_TASKMODAL | MB_OK | MB_ICONSTOP); <br>            SetWindowLong(hdlg, DWL_MSGRESULT, TRUE); <br>            return TRUE; <br>        }   <br>        break; <br> <br>      case PSN_RESET: <br>      case PSN_SETACTIVE: <br>      default: <br> <br>        break; <br> <br>      case PSN_APPLY: <br>                 <br>        /*  Turn off any flags we may be setting down the road */ <br> <br>        lpval[ipRLFlags].Value.l &amp;= ~(RULE_ARCHIVED | <br>                                      RULE_ARCHIVED_BY_YEAR | <br>                                      RULE_NOT | <br>                                      RULE_DELETE | <br>                                      RULE_NO_MOVE); <br> <br>        /*  Get the rule name */ <br> <br>        hctrl = GetDlgItem (hdlg, ID_Name); <br>        cb = Edit_GetTextLength (hctrl) + 1; <br>        if(cb != 1) <br>        { <br>            Edit_GetText (hctrl, lpfltr-&gt;rgch, cb); <br> <br>            lpval[ipRLDisp].ulPropTag = PR_DISPLAY_NAME; <br>            lpval[ipRLDisp].Value.LPSZ = lpfltr-&gt;rgch; <br>        } <br> <br>        /*  Rule type */ <br> <br>        lpval[ipRLType].ulPropTag = PR_RULE_TYPE; <br>        for (i = RL_ANY_RECIP; i &lt; RL_TYPE_MAX; i++) <br>        { <br>            if (IsDlgButtonChecked (hdlg, ID_AnyRecip + i - 1)) <br>            {    <br>                lpval[ipRLType].Value.l = i; <br>                break; <br>            } <br>        } <br> <br>        /*  Rule data */ <br> <br>        hctrl = GetDlgItem (hdlg, ID_Value); <br>        cb = Edit_GetTextLength (hctrl) + 1; <br>        sc = (*lpscd-&gt;lpfnAllocMore) (cb, lpval, &amp;lpval[ipRLData].Value.bin.lpb); <br>        if (FAILED (sc)) <br>            goto ret; <br> <br>        lpval[ipRLData].ulPropTag = PR_RULE_DATA; <br>        lpval[ipRLData].Value.bin.cb = (ULONG)cb; <br>        Edit_GetText (hctrl, lpval[ipRLData].Value.bin.lpb, cb); <br> <br>        /*  Target store EID */ <br> <br>        lpval[ipRLSEid].ulPropTag = PR_NULL; <br> <br>        /*  Target store */ <br> <br>        hctrl = GetDlgItem (hdlg, ID_Store); <br>        cb = ComboBox_GetTextLength (hctrl) + 1; <br>        sc = (*lpscd-&gt;lpfnAllocMore) (cb, lpval, &amp;(lpval[ipRLStore].Value.lpszA)); <br>        if (FAILED (sc)) <br>            goto ret; <br> <br>        lpval[ipRLStore].ulPropTag = PR_RULE_STORE_DISPLAY_NAME; <br>        ComboBox_GetText (hctrl, lpval[ipRLStore].Value.LPSZ, cb); <br> <br>        /*  Target folder EID */ <br> <br>        lpval[ipRLEid].ulPropTag = PR_NULL; <br> <br>        /*  Target folder */ <br> <br>        hctrl = GetDlgItem (hdlg, ID_Folder); <br>        cb = Edit_GetTextLength (hctrl) + 1; <br>        sc = (*lpscd-&gt;lpfnAllocMore) (cb, lpval, &amp;(lpval[ipRLPath].Value.lpszA)); <br>        if (FAILED (sc)) <br>            goto ret; <br> <br>        lpval[ipRLPath].ulPropTag = PR_RULE_TARGET_PATH; <br>        Edit_GetText (hctrl, lpval[ipRLPath].Value.LPSZ, cb); <br> <br>        /*  Flags */ <br> <br>        if (IsDlgButtonChecked (hdlg, ID_ArchTarg)) <br>        { <br>            lpval[ipRLFlags].Value.l |= RULE_ARCHIVED; <br>            if (IsDlgButtonChecked (hdlg, ID_ArchTargYr)) <br>                lpval[ipRLFlags].Value.l |= RULE_ARCHIVED_BY_YEAR; <br>        } <br>        if (IsDlgButtonChecked (hdlg, ID_NotMatch)) <br>            lpval[ipRLFlags].Value.l |= RULE_NOT; <br>        if (IsDlgButtonChecked (hdlg, ID_DeleteMsg)) <br>            lpval[ipRLFlags].Value.l |= RULE_DELETE; <br>        if (IsDlgButtonChecked (hdlg, ID_LeaveMsg)) <br>            lpval[ipRLFlags].Value.l |= RULE_NO_MOVE; <br> <br>        /*  Delete the folder and store entryid's properties */ <br> <br>        lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;DeleteProps (lpfltr-&gt;lpsec, <br>                                    (LPSPropTagArray)&amp;sptDelete, <br>                                    NULL); <br>             <br>        /*  Set the values and save changes on the profile section */ <br> <br>        hr = lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;SetProps (lpfltr-&gt;lpsec, <br>                                            cpRLMax, <br>                                            lpval, <br>                                            NULL); <br>        if (FAILED (sc = GetScode (hr))) <br>            goto ret; <br> <br>        hr = lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;SaveChanges (lpfltr-&gt;lpsec, KEEP_OPEN_READWRITE); <br>        if (FAILED (sc = GetScode (hr))) <br>            goto ret; <br> <br>ret:         <br>        /*  Set error code into filter */ <br>     <br>        lpfltr-&gt;sc = sc; <br>        return !FAILED (sc); <br> <br>      case PSN_HELP: <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  FilterDescriptionPage_COMMAND() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_COMMAND message for the filter description dialog <br> * <br> *      IMPORTANT: This function relies on the dialog control IDs as <br> *      defined in _SMH.RH.  The yearly archive checkboxes must have an <br> *      ID that is one greater than the companion checkbox. <br> */ <br>BOOL <br>FilterDescriptionPage_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    BOOL fCheck; <br>     <br>    switch (id) <br>    { <br>      case ID_LeaveMsg: <br>      case ID_FilterMsg: <br>      case ID_DeleteMsg: <br> <br>        /*  Enable windows based on the check state of the ID_FilterMsg */ <br>         <br>        fCheck = IsDlgButtonChecked (hdlg, ID_FilterMsg); <br>        EnableWindow (GetDlgItem (hdlg, ID_ArchTarg), fCheck); <br>        EnableWindow (GetDlgItem (hdlg, ID_ArchTargYr), <br>            fCheck &amp;&amp; IsDlgButtonChecked (hdlg, ID_ArchTarg)); <br>        EnableWindow (GetDlgItem (hdlg, ID_Folder), fCheck); <br>        EnableWindow (GetDlgItem (hdlg, ID_Store), fCheck); <br>        EnableWindow (GetDlgItem (hdlg, ID_Txt3), fCheck); <br>        EnableWindow (GetDlgItem (hdlg, ID_Txt4), fCheck); <br>        break; <br> <br>      case ID_ArchTarg: <br> <br>        /*  Enable yearly sub-archive button when the archiving is enabled */ <br>         <br>        EnableWindow (GetDlgItem (hdlg, ID_ArchTargYr), <br>            IsDlgButtonChecked (hdlg, ID_ArchTarg)); <br>         <br>        break; <br> <br>      default: <br> <br>        return TRUE; <br>    } <br>     <br>    PropSheet_Changed (GetParent (hdlg), hdlg); <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  FilterDescriptionPageProc() <br> * <br> *  Purpose: <br> * <br> *      Dispatches window messages to the proper function for processing <br> */ <br>BOOL CALLBACK <br>FilterDescriptionPageProc (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>      case WM_INITDIALOG: <br> <br>        FHandleWm (FilterDescriptionPage, hdlg, INITDIALOG, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_COMMAND: <br> <br>        FHandleWm (FilterDescriptionPage, hdlg, COMMAND, wParam, lParam); <br>        break; <br> <br>      case WM_NOTIFY: <br> <br>        return FHandleWm (FilterDescriptionPage, hdlg, NOTIFY, wParam, lParam); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>BOOL <br>ResponsePage_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    EDITSTREAM es = {0}; <br>    LPFILTER lpfltr = (LPFILTER)(((PROPSHEETPAGE *)lParam)-&gt;lParam); <br>    LPFORMATBAR lpfb; <br>    LPSCD lpscd = lpfltr-&gt;lpscd; <br>    LPSPropValue lpval; <br>    RTFS rtfs = {0}; <br>     <br>    /*  Set the user data component to point to the SCD structure */ <br>     <br>    CTL3D_Subclass (lpCtl3D, hdlg, CTL3D_ALL); <br>    SetWindowLong (hdlg, DWL_USER, ((PROPSHEETPAGE *)lParam)-&gt;lParam); <br> <br>    /*  Setup the toolbar for the annotation */ <br> <br>    if (!FAILED (ScCreateToolbar (lpscd, hdlg, ID_Annotation, FALSE, &amp;lpfb)) &amp;&amp; <br>        !FAILED (ScNewRicheditCallback (lpfb, <br>                                lpscd-&gt;lpfnAlloc, <br>                                lpscd-&gt;lpfnAllocMore, <br>                                lpscd-&gt;lpfnFree, <br>                                &amp;lpfb-&gt;lpreoc))) <br>    { <br>        SendMessage (GetDlgItem (hdlg, ID_Annotation), <br>            EM_SETOLECALLBACK, <br>            0, <br>            (LPARAM)lpfb-&gt;lpreoc); <br>    } <br> <br>    /*  Init the dialog fields */ <br> <br>    if (lpval = lpfltr-&gt;lpval) <br>    { <br>        /*  Fill in the display name */ <br>         <br>        Assert (!IsBadReadPtr (lpval, sizeof(SPropValue) * cpRLMax)); <br> <br>        CheckDlgButton (hdlg, ID_ReplyFwd, <br>            !!(lpval[ipRLFlags].Value.l &amp; RULE_AUTO_RESPONSE)); <br>         <br>        /*  Check the boxes indicated by the rule flags */ <br>         <br>        if (!(lpval[ipRLFlags].Value.l &amp; RULE_AUTO_FORWARD)) <br>        { <br>            CheckRadioButton (hdlg, ID_Reply, ID_Forward, ID_Reply); <br>            EnableWindow (GetDlgItem (hdlg, ID_Recip), FALSE); <br>            EnableWindow (GetDlgItem (hdlg, ID_PickRecip), FALSE); <br>        } <br>        else <br>            CheckRadioButton (hdlg, ID_Reply, ID_Forward, ID_Forward); <br> <br>        /*  Setup the fowarding recipient */ <br>         <br>        if (lpval[ipRLFwdRecip].ulPropTag == PR_RULE_FORWARD_RECIP) <br>            Edit_SetText (GetDlgItem (hdlg, ID_Recip), <br>                    lpval[ipRLFwdRecip].Value.LPSZ); <br> <br>        /*  How 'bout the RTF */ <br>         <br>        if (lpval[ipRLRepFwdRTF].ulPropTag == PR_RULE_REP_FWD_RTF) <br>        { <br>            rtfs.cbMax = lpval[ipRLRepFwdRTF].Value.bin.cb; <br>            rtfs.lpb = lpval[ipRLRepFwdRTF].Value.bin.lpb; <br>            es.pfnCallback = ReadRTFFromBuffer; <br>            es.dwCookie = (DWORD)&amp;rtfs; <br>            SendMessage (GetDlgItem (hdlg, ID_Annotation), <br>                EM_STREAMIN, <br>                SF_RTF | SFF_SELECTION | SFF_PLAINRTF, <br>                (LPARAM)&amp;es); <br>        } <br>        else if (lpval[ipRLRepFwd].ulPropTag == PR_RULE_REP_FWD_TEXT) <br>            Edit_SetText (GetDlgItem (hdlg, ID_Annotation), <br>                lpval[ipRLRepFwd].Value.LPSZ); <br>    } <br>     <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>ResponsePage_NOTIFY (HWND hdlg, UINT id, NMHDR FAR * lpnmhdr) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hr; <br>    CHAR rgch[cchNameMax]; <br>    EDITSTREAM es = {0}; <br>    HWND hctrl; <br>    LPFILTER lpfltr = (LPFILTER)GetWindowLong (hdlg, DWL_USER); <br>    LPSCD lpscd = lpfltr-&gt;lpscd; </code></pre>
<p>
</p>
<pre><code>LPSPropValue lpval = lpfltr-&gt;lpval; <br>    RTFS rtfs = {0}; <br>    SizedSPropTagArray (1, spt) = {1, { PR_RULE_FORWARD_RECIP_ENTRYID }}; <br>    UINT cb; <br>     <br>    switch (lpnmhdr-&gt;code) <br>    { <br>      case PSN_KILLACTIVE: <br>      case PSN_RESET: <br>      case PSN_SETACTIVE: <br>      default: <br> <br>        break; <br> <br>      case PSN_APPLY: <br> <br>        if (lpval = lpfltr-&gt;lpval) <br>        { <br>            /*  Turn off any flags we may be setting down the road */ <br> <br>            lpval[ipRLFlags].Value.l &amp;= ~(RULE_AUTO_RESPONSE | <br>                                          RULE_AUTO_APPEND_ORIG | <br>                                          RULE_AUTO_REPLY | <br>                                          RULE_AUTO_FORWARD); <br>             <br>            /*  See if we are enabled */ <br>             <br>            if (IsDlgButtonChecked (hdlg, ID_ReplyFwd)) <br>                lpval[ipRLFlags].Value.l |= RULE_AUTO_RESPONSE; <br> <br>            /*  Grab the annotation in both plain text and RTF */ <br> <br>            hctrl = GetDlgItem (hdlg, ID_Annotation); <br>            cb = Edit_GetTextLength (hctrl) + 1; <br>            sc = (*lpscd-&gt;lpfnAllocMore) (cb, lpval, &amp;lpval[ipRLRepFwd].Value.LPSZ); <br>            if (FAILED (sc)) <br>                goto ret; <br>         <br>            lpval[ipRLRepFwd].ulPropTag = PR_RULE_REP_FWD_TEXT; <br>            Edit_GetText (hctrl, lpval[ipRLRepFwd].Value.LPSZ, cb); <br> <br>            rtfs.cb = 0; <br>            rtfs.cbMax = 0; <br>            rtfs.lpfnAlloc = lpscd-&gt;lpfnAlloc; <br>            rtfs.lpfnFree = lpscd-&gt;lpfnFree; <br>            es.pfnCallback = WriteRTFToBuffer; <br>            es.dwCookie = (DWORD)&amp;rtfs; <br>            SendMessage (hctrl, EM_STREAMOUT, SF_RTF | SFF_PLAINRTF, (LPARAM)&amp;es); <br>            if (!es.dwError) <br>            { <br>                /* make a copy of the RTF data for long term storage */ <br> <br>                sc = (*lpscd-&gt;lpfnAllocMore) (rtfs.cb, <br>                                lpval, <br>                                &amp;lpval[ipRLRepFwdRTF].Value.bin.lpb); <br>                if (!FAILED (sc)) <br>                { <br>                    lpval[ipRLRepFwdRTF].ulPropTag = PR_RULE_REP_FWD_RTF; <br>                    lpval[ipRLRepFwdRTF].Value.bin.cb = rtfs.cb; <br>                    memcpy (lpval[ipRLRepFwdRTF].Value.bin.lpb, rtfs.lpb, (UINT)rtfs.cb); <br>                } <br>                else <br>                    lpval[ipRLRepFwdRTF].ulPropTag = PR_NULL; <br>            } <br> <br>            (*lpscd-&gt;lpfnFree) (rtfs.lpb); <br> <br>            /*  Delete props that need to be recalc'd */ <br>             <br>            lpval[ipRLFwdEid].ulPropTag = PR_NULL; <br>            lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;DeleteProps (lpfltr-&gt;lpsec, <br>                (LPSPropTagArray)&amp;spt, NULL); <br>             <br>            /*  Grab the recipient information */ <br> <br>            hctrl = GetDlgItem (hdlg, ID_Recip); <br>            hctrl = GetDlgItem (hdlg, ID_Recip); <br>            cb = Edit_GetTextLength (hctrl) + 1; <br>            Edit_GetText (hctrl, rgch, cb); <br> <br>            /*  See if what we have cached will work */ <br> <br>            if (IsDlgButtonChecked (hdlg, ID_ReplyFwd) &amp;&amp; <br>                IsDlgButtonChecked (hdlg, ID_Forward)) <br>            { <br>                if ((lpval[ipRLFwdEid].ulPropTag != PR_RULE_FORWARD_RECIP_ENTRYID) || <br>                    (lpval[ipRLFwdRecip].ulPropTag != PR_RULE_FORWARD_RECIP) || <br>                    lstrcmp (lpval[ipRLFwdRecip].Value.lpszA, rgch)) <br>                { <br>                    /*  We do not have a resolved recipient */ <br> <br>                    (void) ScResolveResponseRecip (GetParent (hdlg), lpfltr, rgch); <br>                } <br>            } <br> <br>            /*  Set the response type */ <br> <br>            lpval[ipRLFlags].Value.l |= RULE_AUTO_APPEND_ORIG | <br>                (IsDlgButtonChecked (hdlg, ID_Reply) <br>                     ? RULE_AUTO_REPLY <br>                     : RULE_AUTO_FORWARD); <br> <br>            /*  Set the values and save changes on the profile section */ <br> <br>            hr = lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;SetProps (lpfltr-&gt;lpsec, <br>                                            cpRLMax, <br>                                            lpval, <br>                                            NULL); <br>            if (FAILED (sc = GetScode (hr))) <br>                goto ret; <br> <br>            hr = lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;SaveChanges (lpfltr-&gt;lpsec, KEEP_OPEN_READWRITE); <br>            if (FAILED (sc = GetScode (hr))) <br>                goto ret; <br>        } <br>ret: <br>        lpfltr-&gt;sc = sc; <br>        return !FAILED(sc); <br> <br>      case PSN_HELP: <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>BOOL <br>ResponsePage_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    BOOL fCheck = FALSE; <br>    LPFILTER lpfltr = (LPFILTER)GetWindowLong (hdlg, DWL_USER); <br> <br>    if (FDoRTFCommand (GetDlgItem (hdlg, ID_Frame), id, codeNotify)) <br>        return TRUE; <br>     <br>    switch (id) <br>    { <br>      case ID_Forward: <br>         <br>        fCheck = TRUE; <br> <br>        /*  Fall through */ <br>         <br>      case ID_Reply: <br> <br>        EnableWindow (GetDlgItem (hdlg, ID_Recip), fCheck); <br>        EnableWindow (GetDlgItem (hdlg, ID_PickRecip), fCheck); <br>        break; <br> <br>      case ID_PickRecip: <br> <br>        if (!FAILED (ScPickResponseRecip (GetParent (hdlg), lpfltr))) <br>        { <br>            Edit_SetText (GetDlgItem (hdlg, ID_Recip), <br>                    lpfltr-&gt;lpval[ipRLFwdRecip].Value.LPSZ); <br>        } <br>    } <br> <br>    PropSheet_Changed (GetParent (hdlg), hdlg); <br>    return TRUE; <br>} <br> <br> <br>BOOL CALLBACK <br>ResponsePageProc (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>      case WM_INITDIALOG: <br> <br>        FHandleWm (ResponsePage, hdlg, INITDIALOG, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_COMMAND: <br> <br>        FHandleWm (ResponsePage, hdlg, COMMAND, wParam, lParam); <br>        break; <br> <br>      case WM_NOTIFY: <br> <br>        return FHandleWm (ResponsePage, hdlg, NOTIFY, wParam, lParam); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>BOOL <br>SoundsPage_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    LPFILTER lpfltr = (LPFILTER)(((PROPSHEETPAGE *)lParam)-&gt;lParam); <br>    LPSPropValue lpval; <br>    UINT i; <br>     <br>    /*  Set the user data component to point to the SCD structure */ <br>     <br>    CTL3D_Subclass (lpCtl3D, hdlg, CTL3D_ALL); <br>    SetWindowLong (hdlg, DWL_USER, ((PROPSHEETPAGE *)lParam)-&gt;lParam); <br> <br>    /*  Init the dialog fields */ <br> <br>    if (lpval = lpfltr-&gt;lpval) <br>    { <br>        /*  See if we are enabled */ <br>         <br>        CheckDlgButton (hdlg, ID_Sound, <br>            !!(lpval[ipRLFlags].Value.l &amp; RULE_PLAY_SOUNDS)); <br>         <br>        /*  Fill in the display name */ <br>         <br>        Assert (!IsBadReadPtr (lpval, sizeof(SPropValue) * cpRLMax)); <br>        Edit_SetText (GetDlgItem (hdlg, ID_Name), ((LPSCD)lParam)-&gt;rgch); <br> <br>        /*  Setup the sound entries */ <br> <br>        for (i = 0; i &lt; csndMax; i++) <br>        { <br>            if (lpval[ipRLLoPri + i].ulPropTag == sptRule.aulPropTag[ipRLLoPri + i]) <br>            { <br>                Edit_SetText (GetDlgItem (hdlg, ID_LoPri + i), <br>                    lpval[ipRLLoPri + i].Value.LPSZ); <br>            } <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>SoundsPage_NOTIFY (HWND hdlg, UINT id, NMHDR FAR * lpnmhdr) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hr; <br>    HWND hctrl; <br>    LPFILTER lpfltr = (LPFILTER)GetWindowLong (hdlg, DWL_USER); <br>    LPSCD lpscd = lpfltr-&gt;lpscd; <br>    LPSPropValue lpval; <br>    UINT cb; <br>    UINT i; <br>     <br>    switch (lpnmhdr-&gt;code) <br>    { <br>      case PSN_KILLACTIVE: <br>      case PSN_RESET: <br>      case PSN_SETACTIVE: <br>      default: <br> <br>        break; <br> <br>      case PSN_APPLY: <br> <br>        if (lpval = lpfltr-&gt;lpval) <br>        { <br>            /*  Turn off any flags we may be setting down the road */ <br> <br>            lpval[ipRLFlags].Value.l &amp;= ~RULE_PLAY_SOUNDS; <br> <br>            /*  See if we are enabled */ <br>             <br>            if (IsDlgButtonChecked (hdlg, ID_Sound)) <br>                lpval[ipRLFlags].Value.l |= RULE_PLAY_SOUNDS; <br>             <br>            /*  Grab the sounds */ <br> <br>            for (i = 0; i &lt; csndMax; i++) <br>            { <br>                hctrl = GetDlgItem (hdlg, ID_LoPri + i); <br>                cb = Edit_GetTextLength (hctrl) + 1; <br>                sc = (*lpscd-&gt;lpfnAllocMore) (cb, lpval, &amp;(lpval[ipRLLoPri + i].Value.lpszA)); <br>                if (FAILED (sc)) <br>                    break; <br> <br>                lpval[ipRLLoPri + i].ulPropTag = sptRule.aulPropTag[ipRLLoPri + i]; <br>                Edit_GetText (hctrl, lpval[ipRLLoPri + i].Value.LPSZ, cb); <br>            } <br>             <br>            /*  Set the values and save changes on the profile section */ <br> <br>            hr = lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;SetProps (lpfltr-&gt;lpsec, <br>                                            cpRLMax, <br>                                            lpval, <br>                                            NULL); <br>            if (!FAILED (sc = GetScode (hr))) <br>            { <br>                hr = lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;SaveChanges (lpfltr-&gt;lpsec, KEEP_OPEN_READWRITE); <br>                sc = GetScode (hr); <br>            } <br>        } <br> <br>        lpfltr-&gt;sc = sc; <br>        return !FAILED(sc); <br> <br>      case PSN_HELP: <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>BOOL <br>SoundsPage_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    PropSheet_Changed (GetParent (hdlg), hdlg); <br>    return TRUE; <br>} <br> <br> <br>BOOL CALLBACK <br>SoundsPageProc (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>      case WM_INITDIALOG: <br> <br>        FHandleWm (SoundsPage, hdlg, INITDIALOG, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_COMMAND: <br> <br>        FHandleWm (SoundsPage, hdlg, COMMAND, wParam, lParam); <br>        break; <br> <br>      case WM_NOTIFY: <br> <br>        return FHandleWm (SoundsPage, hdlg, NOTIFY, wParam, lParam); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  HrEditFilterProperties() <br> * <br> *  Purpose: <br> * <br> *      Brings up the filter description dialog for the rule properties <br> *      found in the profile section muid passed in. <br> * <br> *  Arguments: <br> * <br> *      lpscd       SMH dialog structure <br> *      hdlg        parent dialog for the filter description <br> *      fEdit       indicates lpscd-&gt;muid contains a section to edit <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrEditFilterProperties (LPFILTER lpfltr, HWND hdlg, BOOL fEdit) <br>{ <br>    HRESULT hr = hrSuccess; <br>    ULONG cval; <br>    UINT ipg; <br>    PROPSHEETPAGE psp[] = <br>    { <br>        { <br>            sizeof(PROPSHEETPAGE), <br>            PSP_USETITLE, <br>            lpfltr-&gt;lpscd-&gt;hinst, <br>            MAKEINTRESOURCE(SMH_PropertiesPage), <br>            NULL, <br>            MAKEINTRESOURCE(SMH_GeneralTab), <br>            FilterDescriptionPageProc, <br>            0, <br>            NULL, <br>            NULL <br>        }, <br>        { <br>            sizeof(PROPSHEETPAGE), <br>            PSP_USETITLE, <br>            lpfltr-&gt;lpscd-&gt;hinst, <br>            MAKEINTRESOURCE(SMH_ResponsePage), <br>            NULL, <br>            MAKEINTRESOURCE(SMH_ResponseTab), <br>            ResponsePageProc, <br>            0, <br>            NULL, <br>            NULL <br>        }, <br>        { <br>            sizeof(PROPSHEETPAGE), <br>            PSP_USETITLE, <br>            lpfltr-&gt;lpscd-&gt;hinst, <br>            MAKEINTRESOURCE(SMH_SoundsPage), <br>            NULL, <br>            MAKEINTRESOURCE(SMH_SoundsTab), <br>            SoundsPageProc, <br>            0, <br>            NULL, <br>            NULL <br>        }, <br>    }; <br>    PROPSHEETHEADER psh = <br>    { <br>        sizeof(PROPSHEETHEADER), <br>        PSH_PROPSHEETPAGE | PSH_PROPTITLE, <br>        GetParent (hdlg), <br>        lpfltr-&gt;lpscd-&gt;hinst, <br>        NULL, <br>        NULL, <br>        sizeof(psp) / sizeof(PROPSHEETPAGE), <br>        0, <br>        (LPCPROPSHEETPAGE)&amp;psp <br>    }; <br> <br>    /*  If we are creating a new entry, then we first need to create <br>     *  new profile section UID. <br>     */ <br>    if (!fEdit) <br>    { <br>        lstrcpy (lpfltr-&gt;rgch, "Untitled"); <br>        hr = lpfltr-&gt;lpscd-&gt;lpsup-&gt;lpVtbl-&gt;NewUID (lpfltr-&gt;lpscd-&gt;lpsup, &amp;lpfltr-&gt;muid); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br>    } <br> <br>    /*  Open the rules profile section */ <br>     <br>    hr = lpfltr-&gt;lpscd-&gt;lpadmin-&gt;lpVtbl-&gt;OpenProfileSection (lpfltr-&gt;lpscd-&gt;lpadmin, <br>                                        &amp;lpfltr-&gt;muid, <br>                                        NULL, <br>                                        MAPI_MODIFY, <br>                                        &amp;lpfltr-&gt;lpsec); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Get the set of properties describing the rule */ <br> <br>    hr = lpfltr-&gt;lpsec-&gt;lpVtbl-&gt;GetProps (lpfltr-&gt;lpsec, <br>                                        (LPSPropTagArray)&amp;sptRule, <br>                                        0, <br>                                        &amp;cval, <br>                                        &amp;lpfltr-&gt;lpval); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  set property sheet data */ <br> <br>    psh.pszCaption = lpfltr-&gt;rgch; <br>    for (ipg = 0; ipg &lt; psh.nPages; ipg++) <br>        psp[ipg].lParam = (LPARAM)lpfltr; <br> <br>    switch (PropertySheet (&amp;psh)) <br>    { <br>      case -1: <br> <br>        hr = ResultFromScode (MAPI_E_CALL_FAILED); <br>        break; <br> <br>      case 0: <br> <br>        hr = ResultFromScode (MAPI_E_USER_CANCEL); <br>        break; <br>    } <br> <br>ret: <br> <br>    /*  On success, the profile sub-section has been updated and <br>     *  committed.  We can now release the resources held for access <br>     *  to the section. <br>     */ <br>    (*lpfltr-&gt;lpscd-&gt;lpfnFree) (lpfltr-&gt;lpval); <br>    UlRelease (lpfltr-&gt;lpsec); <br>    lpfltr-&gt;lpval = NULL; <br>    lpfltr-&gt;lpsec = NULL; <br> <br>    DebugTraceResult (HrEditFilterProperties(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  Filters Property Sheet Page ----------------------------------------------- <br> *   <br> *  The filters page of the configuration property sheets provides a list <br> *  of the exisitng filter AND the order in which they are processed.  The  <br> *  page allows the user to delete, edit or create rules as well as customize <br> *  the order in which the rules are processed. <br> *   <br> *  The list is based on the profile section property PR_SMH_RULES.  This <br> *  property is a multi-valued binary property that contains rule section <br> *  muids.  These muids are paired with the values from PR_SMH_RULE_NAMES. <br> *   <br> *  Furthermore, there exists an additional property, PR_SMH_ORPHANED_RULES,    <br> *  that is used to maintain references to rules that have been deleted. <br> *   <br> *  When page processing is complete -- when either OK, APPLY or CANCEL <br> *  is chosen, the properties related to this page are set in the profile <br> *  and the changes are saved.  Note that switching out of the filters <br> *  page to another page includes an implicit APPLY before switching <br> *  pages. <br> */ <br> <br>/* <br> *  EnableFilterPageCtrls() <br> * <br> *  Purpose: <br> * <br> *      Enables the set of buttons on the filter page based on the <br> *      current selection in the filter list dialog <br> */ <br>VOID <br>EnableFilterPageCtrls (HWND hdlg) <br>{ <br>    BOOL fDelete; <br>    BOOL fEdit; <br>    BOOL fDown = FALSE; <br>    BOOL fUp = FALSE; <br>    HWND hctrl = GetDlgItem (hdlg, ID_FilterOrderLB); <br>    UINT isel = ListBox_GetCurSel (hctrl); <br> <br>    if (fDelete = fEdit = (isel != LB_ERR)) <br>    { <br>        /*  If we are at the top, "move up" is not very realistic */ <br> <br>        fUp = (isel != 0); <br> <br>        /*  If we are at the bottom, "move down" is not very realistic */ <br> <br>        fDown = (isel != (UINT)(ListBox_GetCount (hctrl) - 1)); <br>    } <br> <br>    /*  Enable the controls */ <br> <br>    Button_Enable (GetDlgItem (hdlg, ID_FilterUp), fUp); <br>    Button_Enable (GetDlgItem (hdlg, ID_FilterDown), fDown); <br>    Button_Enable (GetDlgItem (hdlg, ID_EditFilter), fEdit); <br>    Button_Enable (GetDlgItem (hdlg, ID_RmvFilter), fDelete); <br>    return; <br>} <br> <br> <br>/* <br> *  FilterPage_INITDIALOG() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_INITDIALOG message for the filter description <br> *      dialog. <br> * <br> *      The current list of filters are processed and the name is <br> *      retrieved for use in the dialog. <br> */ <br>BOOL <br>FilterPage_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    SCODE sc = S_OK; <br>    BOOL fInit; <br>    HWND hctrl; <br>    LPBYTE lpmuid; <br>    LPSCD lpscd = (LPSCD)(((PROPSHEETPAGE *)lParam)-&gt;lParam); <br>    LPSPropValue lpval; <br>    LPTSTR lpsz; <br>    UINT cb; <br>    UINT crl; <br>    UINT irl = 0; <br> <br>    /*  Setup the dialog */ <br> <br>    CTL3D_Subclass(lpCtl3D, hdlg, CTL3D_ALL); <br>    SizeODButtons (lpscd-&gt;hinst, hdlg, SMH_FilterPage); <br>    SetWindowLong (hdlg, DWL_USER, ((PROPSHEETPAGE *)lParam)-&gt;lParam); <br> <br>    /*  Load the filter LBX and create the mapping */ <br> <br>    if ((lpval = lpscd-&gt;lpval) &amp;&amp; (lpval[ipRules].ulPropTag == PR_SMH_RULES)) <br>    { <br>        hctrl = GetDlgItem (hdlg, ID_FilterOrderLB); <br> <br>        crl = (UINT)lpval[ipRules].Value.MVbin.cValues; <br>        Assert (crl == lpval[ipNames].Value.MVbin.cValues); <br>         <br>        if (fInit = !lpscd-&gt;lpbin) <br>        { <br>            /*  As we fill the listbox we are going to make a copy of the <br>             *  of the multi-valued arrays for use while editing <br>             */ <br>             <br>            cb = (crl + GROW_SIZE) * sizeof(LPTSTR); <br>            if (FAILED (sc = (*lpscd-&gt;lpfnAlloc) (cb, (LPVOID FAR *)&amp;lpscd-&gt;lppsz))) <br>                goto ret; <br> <br>            cb = (crl + GROW_SIZE) * sizeof(SBinary); <br>            if (FAILED (sc = (*lpscd-&gt;lpfnAlloc) (cb, &amp;lpscd-&gt;lpbin))) <br>                goto ret; <br> <br>            lpscd-&gt;crlMax = crl + GROW_SIZE; <br>        } <br>         <br>        for (irl = 0; irl &lt; crl; irl++) <br>        { <br>            if (fInit) <br>            { <br>                /*  Allocate space (linked) for the copy */ <br>                 <br>                lpsz = lpval[ipNames].Value.MVSZ.lppszA[irl]; <br>                lpmuid = lpval[ipRules].Value.MVbin.lpbin[irl].lpb; <br>                cb = lstrlen (lpval[ipNames].Value.MVSZ.lppszA[irl]) + 1; <br>                if (FAILED (sc = (*lpscd-&gt;lpfnAlloc) (cb, &amp;lpscd-&gt;lppsz[irl])) || <br>                    FAILED (sc = (*lpscd-&gt;lpfnAlloc) (sizeof(MAPIUID), &amp;lpscd-&gt;lpbin[irl].lpb))) <br>                    break; <br>            } <br>            else <br>                lpsz = lpscd-&gt;lppsz[irl]; <br> <br>            /*  Add the item to the list and copy it local (maybe) */ <br>             <br>            if ((ListBox_AddString (hctrl, lpsz) != LB_ERRSPACE) &amp;&amp; <br>                (ListBox_SetItemData (hctrl, irl, irl) != LB_ERR) &amp;&amp; <br>                fInit) <br>            { <br>                lstrcpy (lpscd-&gt;lppsz[irl], lpsz); <br>                lpscd-&gt;lpbin[irl].cb = sizeof(MAPIUID); <br>                memcpy (lpscd-&gt;lpbin[irl].lpb, lpmuid, sizeof(MAPIUID)); <br>            } <br>        } <br> <br>        /*  Set the selection to the first filter in the list */ <br> <br>        ListBox_SetCurSel (hctrl, 0); <br>    } <br>    else <br>        sc = MAPI_E_UNCONFIGURED; <br> <br>ret: <br>     <br>    EnableFilterPageCtrls (hdlg); <br>    lpscd-&gt;crl = irl; <br>    lpscd-&gt;sc = sc; <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  FilterPage_NOTIFY() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_NOTIFY message for the filter description dialog. <br> *      On PSN_APPLY, the filter order is computed and set in PR_SMH_RULES. <br> */ <br>BOOL <br>FilterPage_NOTIFY (HWND hdlg, UINT id, NMHDR FAR * lpnmhdr) <br>{ <br>    HRESULT hr; <br>    LPSCD lpscd; <br>    SPropValue rgval[2]; <br> <br>    switch (lpnmhdr-&gt;code) <br>    { <br>      case PSN_KILLACTIVE: <br>      case PSN_RESET: <br>      case PSN_SETACTIVE: <br>      default: <br> <br>        break; <br> <br>      case PSN_APPLY: <br> <br>        DebugTrace ("SMH: saving contents of filter page\n"); <br> <br>        /*  Setup and save out the new properties */ <br> <br>        lpscd = (LPSCD)GetWindowLong (hdlg, DWL_USER); <br>         <br>        if(lpscd-&gt;crl) <br>        { <br>            rgval[0].ulPropTag = PR_SMH_RULES; <br>            rgval[0].Value.MVbin.cValues = lpscd-&gt;crl; <br>            rgval[0].Value.MVbin.lpbin = lpscd-&gt;lpbin; <br>            rgval[1].ulPropTag = PR_SMH_RULE_NAMES; <br>            rgval[1].Value.MVSZ.cValues = lpscd-&gt;crl; <br>            rgval[1].Value.MVSZ.lppszA = lpscd-&gt;lppsz; <br>             <br>            hr = lpscd-&gt;lpsec-&gt;lpVtbl-&gt;SetProps (lpscd-&gt;lpsec, 2, rgval, NULL); <br>        } <br>        else <br>        { <br>            SizedSPropTagArray(2, taga) = {2, {PR_SMH_RULES, PR_SMH_RULE_NAMES}}; <br>            LPSPropProblemArray pProbl = NULL; <br> <br>            hr = lpscd-&gt;lpsec-&gt;lpVtbl-&gt;DeleteProps(lpscd-&gt;lpsec,  <br>                                            (LPSPropTagArray)&amp;taga, &amp;pProbl); <br>            if (!hr) <br>            { <br>                if(pProbl) <br>                { <br>                    DebugTraceProblems("SMH: DeleteProps :", pProbl); <br>                    MAPIFreeBuffer(pProbl); <br>                } <br>            } <br>        } <br> <br>        if (!HR_FAILED (hr)) <br>            hr = lpscd-&gt;lpsec-&gt;lpVtbl-&gt;SaveChanges (lpscd-&gt;lpsec, KEEP_OPEN_READWRITE); <br> <br>        lpscd-&gt;sc = GetScode (hr); <br>        return TRUE; <br> <br>      case PSN_HELP: <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  FilterPage_COMMAND() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_COMMAND message for the filter description dialog. <br> */ <br>BOOL <br>FilterPage_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    SCODE sc; <br>    FILTER fltr = {0}; <br>    HWND hctrl = GetDlgItem (hdlg, ID_FilterOrderLB); <br>    LPBYTE lpb; <br>    LPSBinary lpbin; <br>    LPSCD lpscd = (LPSCD)GetWindowLong (hdlg, DWL_USER); <br>    LPTSTR FAR * lppsz; <br>    LPTSTR lpsz; <br>    UINT cb; <br>    UINT irl = 0; <br>    INT nAdj; <br> <br>    irl = ListBox_GetCurSel (hctrl); <br>    switch (id) <br>    { <br>      case ID_NewFilter: <br> <br>        if (lpscd-&gt;crl == lpscd-&gt;crlMax) <br>        { <br>            /*  We need to make room for new entries */ <br> <br>            cb = (lpscd-&gt;crl + GROW_SIZE) * sizeof(LPVOID); <br>            if (FAILED (sc = (*lpscd-&gt;lpfnAlloc) (cb, (LPVOID FAR *)&amp;lppsz))) <br>                break; <br>            memcpy (lppsz, lpscd-&gt;lppsz, lpscd-&gt;crl * sizeof(LPTSTR)); <br>                 <br>            cb = (lpscd-&gt;crl + GROW_SIZE) * sizeof(SBinary); <br>            if (FAILED (sc = (*lpscd-&gt;lpfnAlloc) (cb, &amp;lpbin))) <br>                break; <br>            memcpy (lpbin, lpscd-&gt;lpbin, lpscd-&gt;crl * sizeof(SBinary)); <br> <br>            /*  Swap out the old for the new */ <br> <br>            (*lpscd-&gt;lpfnFree) (lpscd-&gt;lppsz); <br>            (*lpscd-&gt;lpfnFree) (lpscd-&gt;lpbin); <br>            lpscd-&gt;crlMax += GROW_SIZE; <br>            lpscd-&gt;lppsz = lppsz; <br>            lpscd-&gt;lpbin = lpbin; <br> <br>        } <br>        irl = lpscd-&gt;crl; <br> <br>        /*  Get the new filter */ <br> <br>        fltr.lpscd = lpscd; <br>        if (!FAILED (sc = GetScode (HrEditFilterProperties (&amp;fltr, hdlg, FALSE)))) <br>        { <br>            /*  Allocate space for the new rule identifiers */ <br>             <br>            if (!FAILED (sc = (*lpscd-&gt;lpfnAlloc) (lstrlen (fltr.rgch) + 1, &amp;lpscd-&gt;lppsz[irl])) &amp;&amp; <br>                !FAILED (sc = (*lpscd-&gt;lpfnAlloc) (sizeof(MAPIUID), &amp;lpscd-&gt;lpbin[irl].lpb))) <br>            { <br>                if ((ListBox_AddString (hctrl, fltr.rgch) != LB_ERR) &amp;&amp; <br>                    (ListBox_SetItemData (hctrl, irl, irl) != LB_ERR)) <br>                { <br>                    /*  Copy the identifiers across */ <br>                     <br>                    lstrcpy (lpscd-&gt;lppsz[irl], fltr.rgch); <br>                    memcpy (lpscd-&gt;lpbin[irl].lpb, &amp;fltr.muid, sizeof(MAPIUID)); <br>                    lpscd-&gt;lpbin[irl].cb = sizeof(MAPIUID); <br> <br>                    ListBox_SetCurSel (hctrl, irl); <br>                    PropSheet_Changed (GetParent (hdlg), hdlg); <br>                    lpscd-&gt;crl++; <br>                } <br>                else <br>                    sc = MAPI_E_CALL_FAILED; <br>            } <br>        } <br>        lpscd-&gt;sc = sc; <br>        break; <br> <br>      case ID_FilterOrderLB: <br> <br>        if (codeNotify != LBN_DBLCLK) <br>            break; <br> <br>        /*  Fall through to edit */ <br>              <br>      case ID_EditFilter: <br> <br>        /*  Copy the muid out for use in the dialog */ <br> <br>        fltr.lpscd = lpscd; <br>        lstrcpy (fltr.rgch, lpscd-&gt;lppsz[irl]); <br>        memcpy (&amp;fltr.muid, lpscd-&gt;lpbin[irl].lpb, sizeof(MAPIUID)); <br>        if (!FAILED (sc = GetScode (HrEditFilterProperties (&amp;fltr, hdlg, TRUE)))) <br>        { <br>            /*  The name may have changed.  If so, update it */ <br> <br>            if (lstrcmp (fltr.rgch, lpscd-&gt;lppsz[irl])) <br>            { <br>                /*  See if we need a bigger buffer and alloc one */ <br> <br>                if ((cb = lstrlen (fltr.rgch)) &gt; (UINT)lstrlen (lpscd-&gt;lppsz[irl])) <br>                { <br>                    if (!FAILED (sc = (*lpscd-&gt;lpfnAlloc) (cb + 1, &amp;lpsz))) <br>                    { <br>                        (*lpscd-&gt;lpfnFree) (lpscd-&gt;lppsz[irl]); <br>                        lstrcpy (lpsz, fltr.rgch); <br>                        lpscd-&gt;lppsz[irl] = lpsz; <br>                    } <br>                    else <br>                        break; <br>                } <br>                else <br>                    lstrcpy (lpscd-&gt;lppsz[irl], fltr.rgch); <br>                 <br>                if ((ListBox_DeleteString (hctrl, irl) == LB_ERR) || <br>                    (ListBox_InsertString (hctrl, irl, fltr.rgch) == LB_ERRSPACE) || <br>                    (ListBox_SetItemData (hctrl, irl, irl) == LB_ERR)) <br>                    sc = MAPI_E_NOT_ENOUGH_MEMORY; <br> <br>                ListBox_SetCurSel (hctrl, irl); <br>            } <br>            PropSheet_Changed (GetParent (hdlg), hdlg); <br>        } <br>        lpscd-&gt;sc = sc; <br>        break; <br> <br>      case ID_RmvFilter: <br> <br>        /*  Remove the string and collapse the local copies */ <br> <br>        if ((irl != LB_ERR) &amp;&amp; (ListBox_DeleteString (hctrl, irl) != LB_ERR)) <br>        { <br>            (*lpscd-&gt;lpfnFree) (lpscd-&gt;lpbin[irl].lpb); <br>            (*lpscd-&gt;lpfnFree) (lpscd-&gt;lppsz[irl]); <br>            lpscd-&gt;crl -= 1; <br>            if (irl != lpscd-&gt;crl) <br>            { <br>                memcpy (&amp;lpscd-&gt;lppsz[irl], &amp;lpscd-&gt;lppsz[irl + 1], <br>                    (lpscd-&gt;crl - irl) * sizeof(LPTSTR)); <br>                memcpy (&amp;lpscd-&gt;lpbin[irl], &amp;lpscd-&gt;lpbin[irl + 1], <br>                    (lpscd-&gt;crl - irl) * sizeof(SBinary)); <br>            } <br>        } <br>        else <br>            MessageBeep (0); <br> <br>        ListBox_SetCurSel (hctrl, irl); <br>        PropSheet_Changed (GetParent (hdlg), hdlg); <br>        break; <br> <br>      case ID_FilterUp: <br>      case ID_FilterDown: <br> <br>        /*  Ensure we really have something to move */ <br>         <br>        if (id == ID_FilterUp) <br>        { <br>            nAdj = -1; <br>            if ((irl == LB_ERR) || (irl == 0)) <br>                break; <br>        } <br>        else <br>        { <br>            nAdj = 1; <br>            if ((irl == LB_ERR) || (irl == (UINT)(ListBox_GetCount (hctrl) - 1))) <br>                break; <br>        } <br> <br>        /*  Move it */ <br> <br>        if ((ListBox_DeleteString (hctrl, irl + nAdj) == LB_ERR) || <br>            (ListBox_InsertString (hctrl, irl, lpscd-&gt;lppsz[irl + nAdj]) == LB_ERRSPACE)) <br>        { <br>            ListBox_ResetContent (hctrl); <br>            lpscd-&gt;sc = MAPI_E_CALL_FAILED; <br>            break; <br>        } <br>        else <br>            ListBox_SetItemData (hctrl, irl, irl); <br> <br>        /*  Move it in the local copies */ <br> <br>        lpsz = lpscd-&gt;lppsz[irl + nAdj]; <br>        lpscd-&gt;lppsz[irl + nAdj] = lpscd-&gt;lppsz[irl]; <br>        lpscd-&gt;lppsz[irl] = lpsz; <br>         <br>        lpb = lpscd-&gt;lpbin[irl + nAdj].lpb; <br>        lpscd-&gt;lpbin[irl + nAdj].lpb = lpscd-&gt;lpbin[irl].lpb; <br>        lpscd-&gt;lpbin[irl].lpb = lpb; <br> <br>        /*  Set the selection to the new position */ <br>         <br>        ListBox_SetCurSel (hctrl, irl + nAdj); <br>        PropSheet_Changed (GetParent (hdlg), hdlg); <br>        break; <br> <br>      case ID_Export: <br> <br>        ScExportFilters (lpscd, GetParent (hdlg)); <br>        break; <br> <br>      case ID_Import: <br> <br>        ScImportFilters (lpscd, GetParent (hdlg), hctrl); <br>        PropSheet_Changed (GetParent (hdlg), hdlg); <br>        break; <br> <br>      default: <br>        break; <br>    } <br> <br>    EnableFilterPageCtrls (hdlg); <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  FilterPageProc() <br> * <br> *  Purpose: <br> * <br> *      Dispatches window messages to the proper function for processing <br> */ <br>BOOL CALLBACK <br>FilterPageProc (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>      case WM_INITDIALOG: <br> <br>        FHandleWm (FilterPage, hdlg, INITDIALOG, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_COMMAND: <br> <br>        FHandleWm (FilterPage, hdlg, COMMAND, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_DRAWITEM: <br> <br>        DrawODButton (((LPSCD)GetWindowLong (hdlg, DWL_USER))-&gt;hinst, <br>            (DRAWITEMSTRUCT FAR *)lParam, TRUE); <br>        break; <br> <br>      case WM_NOTIFY: <br> <br>        return FHandleWm (FilterPage, hdlg, NOTIFY, wParam, lParam); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  General Property Sheet Page ----------------------------------------------- <br> *   <br> *  The general page of the configuration property sheets provides access <br> *  to the many flags that are available to the SMH service.  The dialog <br> *  is used to set the value for PR_SMH_FLAGS. <br> */ <br> <br>/* <br> *  GeneralPage_INITDAILOG() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_INITDIALOG message for the filter description dialog <br> */ <br>BOOL <br>GeneralPage_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    LPSCD lpscd = (LPSCD)(((PROPSHEETPAGE *)lParam)-&gt;lParam); </code></pre>
<p>
</p>
<pre><code>LPSPropValue lpval = lpscd-&gt;lpval; <br>    ULONG ulFlags; <br> <br>    CTL3D_Subclass(lpCtl3D, hdlg, CTL3D_ALL); <br>    SetWindowLong (hdlg, DWL_USER, ((PROPSHEETPAGE *)lParam)-&gt;lParam); <br> <br>    ulFlags = (lpval[ipFlags].ulPropTag == PR_SMH_FLAGS) <br>                ? lpval[ipFlags].Value.l <br>                : 0; <br> <br>    /*  Enable/check the checkboxes based on SMH flags */ <br> <br>    CheckDlgButton (hdlg, ID_AddToPab, !!(ulFlags &amp; SMH_ADD_TO_PAB)); <br>    CheckDlgButton (hdlg, ID_Deleted, !!(ulFlags &amp; SMH_FILTER_DELETED)); <br>    CheckDlgButton (hdlg, ID_DeletedYr, !!(ulFlags &amp; SMH_FILTER_DELETED_YR)); <br>    CheckDlgButton (hdlg, ID_Inbound, !!(ulFlags &amp; SMH_FILTER_INBOUND)); <br>    CheckDlgButton (hdlg, ID_SentMail, !!(ulFlags &amp; SMH_FILTER_SENTMAIL)); <br>    CheckDlgButton (hdlg, ID_SentMailYr, !!(ulFlags &amp; SMH_FILTER_SENTMAIL_YR)); <br>    CheckDlgButton (hdlg, ID_Unread, !!(ulFlags &amp; SMH_UNREAD_VIEWER)); <br>    EnableWindow (GetDlgItem (hdlg, ID_DeletedYr), !!(ulFlags &amp; SMH_FILTER_DELETED)); <br>    EnableWindow (GetDlgItem (hdlg, ID_SentMailYr), !!(ulFlags &amp; SMH_FILTER_SENTMAIL)); <br>    lpval[ipFlags].ulPropTag = PR_SMH_FLAGS; <br>    lpval[ipFlags].Value.l = ulFlags; <br>    return TRUE; <br>} <br> <br>/* <br> *  GeneralPage_NOTIFY() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_NOTIFY message for the filter description dialog. <br> *      On PSN_APPLY, SMHFlags is recomputed from the checkbox states. <br> */ <br>BOOL <br>GeneralPage_NOTIFY (HWND hdlg, UINT id, NMHDR FAR * lpnmhdr) <br>{ <br>    HRESULT hr; <br>    LPSCD lpscd = (LPSCD)GetWindowLong (hdlg, DWL_USER); <br>    SPropValue val = {0}; <br> <br>    switch (lpnmhdr-&gt;code) <br>    { <br>      case PSN_KILLACTIVE: <br>      case PSN_RESET: <br>      case PSN_SETACTIVE: <br>      default: <br> <br>        break; <br> <br>      case PSN_APPLY: <br> <br>        DebugTrace ("SMH: saving contents of general page\n"); <br>         <br>        /*  Calc the value for PR_SMH_FLAGS */ <br> <br>        if (IsDlgButtonChecked (hdlg, ID_SentMail)) <br>        { <br>            val.Value.l |= SMH_FILTER_SENTMAIL; <br>            if (IsDlgButtonChecked (hdlg, ID_SentMailYr)) <br>                val.Value.l |= SMH_FILTER_SENTMAIL_YR; <br>            else <br>                val.Value.l &amp;= ~SMH_FILTER_SENTMAIL_YR; <br>        } <br>        else <br>            val.Value.l &amp;= ~(SMH_FILTER_SENTMAIL | SMH_FILTER_SENTMAIL_YR); <br> <br>        if (IsDlgButtonChecked (hdlg, ID_Deleted)) <br>        { <br>            val.Value.l |= SMH_FILTER_DELETED; <br>            if (IsDlgButtonChecked (hdlg, ID_DeletedYr)) <br>                val.Value.l |= SMH_FILTER_DELETED_YR; <br>            else <br>                val.Value.l &amp;= ~SMH_FILTER_DELETED_YR; <br>        } <br>        else <br>            val.Value.l &amp;= ~(SMH_FILTER_DELETED | SMH_FILTER_DELETED_YR); <br> <br>        if (IsDlgButtonChecked (hdlg, ID_Inbound)) <br>            val.Value.l |= SMH_FILTER_INBOUND; <br>        else <br>            val.Value.l &amp;= ~SMH_FILTER_INBOUND; <br> <br>        if (IsDlgButtonChecked (hdlg, ID_Unread)) <br>            val.Value.l |= SMH_UNREAD_VIEWER; <br>        else <br>            val.Value.l &amp;= ~SMH_UNREAD_VIEWER; <br> <br>        if (IsDlgButtonChecked (hdlg, ID_AddToPab)) <br>            val.Value.l |= SMH_ADD_TO_PAB; <br>        else <br>            val.Value.l &amp;= ~SMH_ADD_TO_PAB; <br> <br>        val.ulPropTag = PR_SMH_FLAGS; <br>        hr = lpscd-&gt;lpsec-&gt;lpVtbl-&gt;SetProps (lpscd-&gt;lpsec, <br>                                        1, <br>                                        &amp;val, <br>                                        NULL); <br>        if (!HR_FAILED (hr)) <br>            hr = lpscd-&gt;lpsec-&gt;lpVtbl-&gt;SaveChanges (lpscd-&gt;lpsec, KEEP_OPEN_READWRITE); <br>         <br>        lpscd-&gt;sc = GetScode (hr); <br>        return TRUE; <br> <br>      case PSN_HELP: <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  GeneralPage_COMMAND() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_COMMAND message for the filter description dialog <br> * <br> *      IMPORTANT: This function relies on the dialog control IDs as <br> *      defined in _SMH.RH.  The yearly archive checkboxes must have an <br> *      ID that is one greater than the companion checkbox. <br> */ <br>BOOL <br>GeneralPage_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    switch (id) <br>    { <br>      case ID_SentMail: <br>      case ID_Deleted: <br> <br>        EnableWindow (GetDlgItem (hdlg, id + 1), <br>                    !!IsDlgButtonChecked (hdlg, id)); <br>        break; <br> <br>      case ID_SentMailYr: <br>      case ID_DeletedYr: <br>      case ID_Inbound: <br>      case ID_Unread: <br>      case ID_AddToPab: <br> <br>        break; <br> <br>      default: <br> <br>        return TRUE; <br>    } <br>    PropSheet_Changed (GetParent (hdlg), hdlg); <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  GeneralPageProc() <br> * <br> *  Purpose: <br> * <br> *      Dispatches window messages to the proper function for processing <br> */ <br>BOOL CALLBACK <br>GeneralPageProc (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>      case WM_INITDIALOG: <br> <br>        FHandleWm (GeneralPage, hdlg, INITDIALOG, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_COMMAND: <br> <br>        FHandleWm (GeneralPage, hdlg, COMMAND, wParam, lParam); <br>        break; <br> <br>      case WM_NOTIFY: <br> <br>        return FHandleWm (GeneralPage, hdlg, NOTIFY, wParam, lParam); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  Exclussion Edit Dialog ---------------------------------------------------- <br> *   <br> *  The exclusion edit dialog alows the user to input a single entry into <br> *  the list of excluded message classes. <br> *   <br> *  All information is passed via the SCD structure. <br> *   <br> *      lpscd-&gt;rgch     [IN\OUT]    contains the message class to exclude <br> *   <br> *  The caller is responsible for merging the new value into the <br> *  exclusion list. <br> */ <br> <br>/* <br> *  ExclusionEdit_INITDIALOG() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_INITDIALOG message for the filter description dialog <br> */ <br>BOOL <br>ExclusionEdit_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    CTL3D_Subclass(lpCtl3D, hdlg, CTL3D_ALL); <br>    SetWindowLong (hdlg, DWL_USER, lParam); <br> <br>    /*  Enable/limit the exclusion edit */ <br> <br>    Edit_LimitText (GetDlgItem (hdlg, ID_ExclusionClass), cchNameMax - 1); <br>    Button_Enable (GetDlgItem (hdlg, IDOK), FALSE); <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  ExclusionEdit_COMMAND() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_COMMAND message for the filter description dialog <br> */ <br>BOOL ExclusionEdit_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    LPSCD lpscd = (LPSCD)GetWindowLong (hdlg, DWL_USER); <br>    HWND hctrl = GetDlgItem (hdlg, ID_ExclusionClass); <br> <br>    switch (id) <br>    { <br>      case IDOK: <br> <br>        Edit_GetText (hctrl, lpscd-&gt;rgch, cchNameMax); <br>        break; <br> <br>      case IDCANCEL: <br> <br>        break; <br> <br>      default: <br> <br>        return FALSE; <br>    } <br> <br>    EndDialog (hdlg, id); <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  ExclusionEditProc() <br> * <br> *  Purpose: <br> * <br> *      Dispatches window messages to the proper function for processing <br> */ <br>BOOL CALLBACK <br>ExclusionEditProc (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    HWND hctrl = GetDlgItem (hdlg, ID_ExclusionClass); <br> <br>    switch (msg) <br>    { <br>      case WM_INITDIALOG: <br> <br>        FHandleWm (ExclusionEdit, hdlg, INITDIALOG, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_COMMAND: <br> <br>        FHandleWm (ExclusionEdit, hdlg, COMMAND, wParam, lParam); <br>        break; <br>    } <br>    Button_Enable (GetDlgItem (hdlg, IDOK), !!Edit_GetTextLength (hctrl)); <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  Exclussion Page Property Sheet -------------------------------------------- <br> *   <br> *  The exclusions page exposes the list of message classes that are <br> *  excluded from inbound filtering.  The property that correlates to  <br> *  the list is PR_SMH_EXCLUSIONS.  Any actions required against this <br> *  property are processed within the context of this property sheet. <br> */ <br> <br>/* <br> *  ExclusionPage_INITDIALOG() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_INITDIALOG message for the filter description dialog <br> */ <br>BOOL <br>ExclusionPage_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    LPSCD lpscd = (LPSCD)(((PROPSHEETPAGE *)lParam)-&gt;lParam); <br>    HWND hctrl = GetDlgItem (hdlg, ID_ExclusionLB); <br>    UINT isz; <br> <br>    CTL3D_Subclass(lpCtl3D, hdlg, CTL3D_ALL); <br>    SetWindowLong (hdlg, DWL_USER, ((PROPSHEETPAGE *)lParam)-&gt;lParam); <br> <br>    /*  Populate the exclusion listbox */ <br> <br>    if (lpscd-&gt;lpval[ipExc].ulPropTag == PR_SMH_EXCLUSIONS) <br>        for (isz = 0; isz &lt; lpscd-&gt;lpval[ipExc].Value.MVSZ.cValues; isz++) <br>            ListBox_AddString (hctrl, lpscd-&gt;lpval[ipExc].Value.MVSZ.LPPSZ[isz]); <br> <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  ExclusionPage_NOTIFY() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_NOTIFY message for the filter description dialog <br> */ <br>BOOL <br>ExclusionPage_NOTIFY (HWND hdlg, UINT id, NMHDR FAR * lpnmhdr) <br>{ <br>    SCODE sc; <br>    LPSCD lpscd = (LPSCD)GetWindowLong (hdlg, DWL_USER); <br>    HWND hctrl = GetDlgItem (hdlg, ID_ExclusionLB); <br>    LPSPropValue lpval; <br>    LPTSTR FAR * lppsz = NULL; <br>    SizedSPropTagArray (1, spt) = {1, { PR_SMH_EXCLUSIONS }}; <br>    UINT cex; <br>    UINT iex; <br> <br>    switch (lpnmhdr-&gt;code) <br>    { <br>      case PSN_KILLACTIVE: <br>      case PSN_RESET: <br>      case PSN_SETACTIVE: <br>      default: <br> <br>        break; <br> <br>      case PSN_APPLY: <br> <br>        DebugTrace ("SMH: saving contents of exclusions page\n"); <br> <br>        /*  Assemble a new PR_SMH_EXCLUSIONS property value */ <br> <br>        lpval = &amp;lpscd-&gt;lpval[ipExc]; <br>        cex = ListBox_GetCount (hctrl); <br>        if (cex) <br>        { <br>            sc = (*lpscd-&gt;lpfnAllocMore) (cex * sizeof(LPTSTR), <br>                                    lpscd-&gt;lpval, <br>                                    (LPVOID FAR *)&amp;lppsz); <br>            if (!FAILED (sc)) <br>            { <br>                lpval-&gt;ulPropTag = PR_SMH_EXCLUSIONS; <br>                lpval-&gt;Value.MVSZ.LPPSZ = lppsz; <br>                for (iex = 0; iex &lt; cex; iex++, lppsz++) <br>                { <br>                    sc = (*lpscd-&gt;lpfnAllocMore) (ListBox_GetTextLen (hctrl, iex) + 1, <br>                                        lpscd-&gt;lpval, <br>                                        lppsz); <br>                    if (FAILED (sc)) <br>                        break; <br> <br>                    ListBox_GetText (hctrl, iex, *lppsz); <br>                } <br>                lpval-&gt;Value.MVSZ.cValues = iex; <br> <br>                /*  Set the new value */ <br> <br>                sc = GetScode (lpscd-&gt;lpsec-&gt;lpVtbl-&gt;SetProps (lpscd-&gt;lpsec, <br>                                                        1, <br>                                                        lpval, <br>                                                        NULL)); <br>                if (!FAILED (sc)) <br>                    sc = GetScode (lpscd-&gt;lpsec-&gt;lpVtbl-&gt;SaveChanges (lpscd-&gt;lpsec, <br>                                                        KEEP_OPEN_READWRITE)); <br>            } <br>            lpscd-&gt;sc = sc; <br>        } <br>        else <br>        { <br>            lpval-&gt;ulPropTag = PR_NULL; <br>            lpscd-&gt;lpsec-&gt;lpVtbl-&gt;DeleteProps (lpscd-&gt;lpsec, (LPSPropTagArray)&amp;spt, NULL); <br>        } <br>        return TRUE; <br> <br>      case PSN_HELP: <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  ExclusionPage_COMMAND() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_COMMAND message for the filter description dialog <br> */ <br>BOOL <br>ExclusionPage_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    LPSCD lpscd = (LPSCD)GetWindowLong (hdlg, DWL_USER); <br>    HWND hctrl = GetDlgItem (hdlg, ID_ExclusionLB); <br>    UINT iex; <br> <br>    switch (id) <br>    { <br>      case ID_NewExclusion: <br> <br>        id = DialogBoxParam (lpscd-&gt;hinst, <br>                    MAKEINTRESOURCE (SMH_ExclusionEdit), <br>                    GetParent(hdlg), <br>                    ExclusionEditProc, <br>                    (LPARAM)lpscd); <br>        if (id == IDOK) <br>            ListBox_SetCurSel (hctrl, ListBox_AddString (hctrl, lpscd-&gt;rgch)); <br> <br>        PropSheet_Changed (GetParent (hdlg), hdlg); <br>        break; <br> <br>      case ID_RmvExclusion: <br> <br>        iex = ListBox_GetCurSel (hctrl); <br>        ListBox_DeleteString (hctrl, iex); <br>        ListBox_SetCurSel (hctrl, iex); <br>        PropSheet_Changed (GetParent (hdlg), hdlg); <br>        break; <br> <br>      default: <br> <br>        break; <br>    } <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  ExclusionPageProc() <br> * <br> *  Purpose: <br> * <br> *      Dispatches window messages to the proper function for processing <br> */ <br>BOOL CALLBACK <br>ExclusionPageProc (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>      case WM_INITDIALOG: <br> <br>        FHandleWm (ExclusionPage, hdlg, INITDIALOG, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_COMMAND: <br> <br>        FHandleWm (ExclusionPage, hdlg, COMMAND, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_NOTIFY: <br> <br>        return FHandleWm (ExclusionPage, hdlg, NOTIFY, wParam, lParam); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  Out-Of-Office Page Property Sheet ----------------------------------------- <br> *   <br> *  The Out-of-office page exposes access to the OOF utility of SMH.   <br> *  The enabling and message text are both modified via this page. <br> *  The corresponding properties are stored in PR_SMH_OOF_ENABLED, <br> *  PR_SMH_OOF_TEXT and PR_SMH_OOF_RTF. <br> *   <br> *  The RTF component of the OOF message uses the RICHEDIT implementation <br> *  that is available as a part of the WIN95 system. <br> */ <br> <br>/* <br> *  OofPage_INITDIALOG() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_INITDIALOG message for the filter description dialog <br> */ <br>BOOL <br>OofPage_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    EDITSTREAM es = {0}; <br>    LPSCD lpscd = (LPSCD)(((PROPSHEETPAGE *)lParam)-&gt;lParam); <br>    LPFORMATBAR lpfb; <br>    RTFS rtfs = {0}; <br> <br>    CTL3D_Subclass(lpCtl3D, hdlg, CTL3D_ALL); <br>    SetWindowLong (hdlg, DWL_USER, ((PROPSHEETPAGE *)lParam)-&gt;lParam); <br> <br>    if (!FAILED (ScCreateToolbar (lpscd, hdlg, ID_OofText, TRUE, &amp;lpfb)) &amp;&amp; <br>        !FAILED (ScNewRicheditCallback (lpfb, <br>                                lpscd-&gt;lpfnAlloc, <br>                                lpscd-&gt;lpfnAllocMore, <br>                                lpscd-&gt;lpfnFree, <br>                                &amp;lpfb-&gt;lpreoc))) <br>    { <br>        SendMessage (GetDlgItem (hdlg, ID_OofText), <br>            EM_SETOLECALLBACK, <br>            0, <br>            (LPARAM)lpfb-&gt;lpreoc); <br>    } <br> <br>    if (lpscd-&gt;lpval[ipOofRtf].ulPropTag == PR_SMH_OOF_RTF) <br>    { <br>        rtfs.cbMax = lpscd-&gt;lpval[ipOofRtf].Value.bin.cb; <br>        rtfs.lpb = lpscd-&gt;lpval[ipOofRtf].Value.bin.lpb; <br>        es.pfnCallback = ReadRTFFromBuffer; <br>        es.dwCookie = (DWORD)&amp;rtfs; <br>        SendMessage (GetDlgItem (hdlg, ID_OofText), <br>            EM_STREAMIN, <br>            SF_RTF | SFF_SELECTION | SFF_PLAINRTF, <br>            (LPARAM)&amp;es); <br>    } <br>    else if (lpscd-&gt;lpval[ipOof].ulPropTag == PR_SMH_OOF_TEXT) <br>        Edit_SetText (GetDlgItem (hdlg, ID_OofText), lpscd-&gt;lpval[ipOof].Value.LPSZ); <br> <br>    if (lpscd-&gt;lpval[ipOofEnabled].ulPropTag == PR_SMH_OOF_ENABLED) <br>        CheckDlgButton (hdlg, ID_OofEnabled, lpscd-&gt;lpval[ipOofEnabled].Value.b); <br>     <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  OofPage_NOTIFY() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_NOTIFY message for the filter description dialog <br> */ <br>BOOL <br>OofPage_NOTIFY (HWND hdlg, UINT id, NMHDR FAR * lpnmhdr) <br>{ <br>    SCODE sc; <br>    HWND hctrl; <br>    EDITSTREAM es = {0}; <br>    LPSCD lpscd = (LPSCD)GetWindowLong (hdlg, DWL_USER); <br>    RTFS rtfs = {0}; <br>    SPropValue rgval[3]; <br>    UINT cb; <br> <br>    switch (lpnmhdr-&gt;code) <br>    { <br>      case PSN_KILLACTIVE: <br>      case PSN_RESET: <br>      case PSN_SETACTIVE: <br>      default: <br> <br>        break; <br> <br>      case PSN_APPLY: <br> <br>        DebugTrace ("SMH: saving contents of out-of-office page\n"); <br> <br>        hctrl = GetDlgItem (hdlg, ID_OofText); <br>        cb = Edit_GetTextLength (hctrl) + 1; <br>        sc = (*lpscd-&gt;lpfnAllocMore) (cb, <br>                            lpscd-&gt;lpval, <br>                            &amp;lpscd-&gt;lpval[ipOof].Value.LPSZ); <br>        if (!FAILED (sc)) <br>        { <br>            lpscd-&gt;lpval[ipOof].ulPropTag = PR_SMH_OOF_TEXT; <br>            Edit_GetText (hctrl, lpscd-&gt;lpval[ipOof].Value.LPSZ, cb); <br>            DebugTrace ("SMH: OOF: text size: %d\n", lstrlen (lpscd-&gt;lpval[ipOof].Value.LPSZ)); <br> <br>            lpscd-&gt;lpval[ipOofEnabled].ulPropTag = PR_SMH_OOF_ENABLED; <br>            lpscd-&gt;lpval[ipOofEnabled].Value.b = <br>                IsDlgButtonChecked (hdlg, ID_OofEnabled); <br> <br>            /*  Grab the RTF */ <br> <br>            rtfs.cbMax = (FAILED ((*lpscd-&gt;lpfnAlloc) (cb * 2, &amp;rtfs.lpb))) ? 0 : cb * 2; <br>            rtfs.lpfnAlloc = lpscd-&gt;lpfnAlloc; <br>            rtfs.lpfnFree = lpscd-&gt;lpfnFree; <br>            es.pfnCallback = WriteRTFToBuffer; <br>            es.dwCookie = (DWORD)&amp;rtfs; <br>            SendMessage (hctrl, EM_STREAMOUT, SF_RTF | SFF_PLAINRTF, (LPARAM)&amp;es); <br>            if (!es.dwError) <br>            { <br>                lpscd-&gt;lpval[ipOofRtf].ulPropTag = PR_SMH_OOF_RTF; <br>                lpscd-&gt;lpval[ipOofRtf].Value.bin.cb = rtfs.cb; <br>                lpscd-&gt;lpval[ipOofRtf].Value.bin.lpb = rtfs.lpb; <br>                DebugTrace ("SMH: OOF: RTF size: %ld\n", lpscd-&gt;lpval[ipOofRtf].Value.bin.cb); <br>            } <br> <br>            rgval[0] = lpscd-&gt;lpval[ipOof]; <br>            rgval[1] = lpscd-&gt;lpval[ipOofEnabled]; <br>            rgval[2] = lpscd-&gt;lpval[ipOofRtf]; <br>            sc = GetScode (lpscd-&gt;lpsec-&gt;lpVtbl-&gt;SetProps (lpscd-&gt;lpsec, <br>                                                        3, <br>                                                        rgval, <br>                                                        NULL)); <br>            if (!FAILED (sc)) <br>                    sc = GetScode (lpscd-&gt;lpsec-&gt;lpVtbl-&gt;SaveChanges (lpscd-&gt;lpsec, <br>                                                        KEEP_OPEN_READWRITE)); <br>            (*lpscd-&gt;lpfnFree) (rtfs.lpb); <br>        } <br>        return TRUE; <br> <br>      case EN_SELCHANGE: <br> <br>        /*  Update the format bar */ <br> <br>        UpdateFormatBar (GetDlgItem (hdlg, ID_Frame)); <br> <br>        return FALSE; <br> <br>      case PSN_HELP: <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  OofPage_COMMAND() <br> * <br> *  Purpose: <br> * <br> *      Handles the WM_COMMAND message for the filter description dialog <br> */ <br>BOOL <br>OofPage_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    LPSCD lpscd = (LPSCD)GetWindowLong (hdlg, DWL_USER); <br> <br>    if (!FDoRTFCommand (GetDlgItem (hdlg, ID_Frame), id, codeNotify)) <br>    { <br>        switch (id) <br>        { <br>          case ID_OofText: <br>          case ID_OofEnabled: <br> <br>            PropSheet_Changed (GetParent (hdlg), hdlg); <br>            break; <br>        } <br>    } <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  OofPageProc() <br> * <br> *  Purpose: <br> * <br> *      Dispatches window messages to the proper function for processing <br> */ <br>BOOL CALLBACK <br>OofPageProc (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>      case WM_INITDIALOG: <br> <br>        FHandleWm (OofPage, hdlg, INITDIALOG, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_COMMAND: <br> <br>        FHandleWm (OofPage, hdlg, COMMAND, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_NOTIFY: <br> <br>        return FHandleWm (OofPage, hdlg, NOTIFY, wParam, lParam); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> *  HrDisplayPropSheets() <br> * <br> *  Purpose: <br> * <br> *      Brings up the SMH property sheets. <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrDisplayPropSheets (HINSTANCE hinst, <br>    HWND hwnd, <br>    LPSCD lpscd) <br>{ <br>    HRESULT hr = hrSuccess; <br>    CHAR rgch[60] = {0}; <br>    HINSTANCE hlib; <br>    UINT ipg; <br>    PROPSHEETPAGE psp[] = <br>    { <br>        { <br>            sizeof(PROPSHEETPAGE), <br>            PSP_USETITLE, <br>            hinst, <br>            MAKEINTRESOURCE(SMH_GeneralPage), <br>            NULL, <br>            MAKEINTRESOURCE(SMH_GeneralTab), <br>            GeneralPageProc, <br>            0, <br>            NULL, <br>            NULL <br>        }, <br>        { <br>            sizeof(PROPSHEETPAGE), <br>            PSP_USETITLE, <br>            hinst, <br>            MAKEINTRESOURCE(SMH_FilterPage), <br>            NULL, <br>            MAKEINTRESOURCE(SMH_FilterTab), <br>            FilterPageProc, <br>            0, <br>            NULL, <br>            NULL <br>        }, <br>        { <br>            sizeof(PROPSHEETPAGE), <br>            PSP_USETITLE, <br>            hinst, <br>            MAKEINTRESOURCE(SMH_OofPage), <br>            NULL, <br>            MAKEINTRESOURCE(SMH_OofTab), <br>            OofPageProc, <br>            0, <br>            NULL, <br>            NULL <br>        }, <br>        { <br>            sizeof(PROPSHEETPAGE), <br>            PSP_USETITLE, <br>            hinst, <br>            MAKEINTRESOURCE(SMH_ExclusionPage), <br>            NULL, <br>            MAKEINTRESOURCE(SMH_ExclusionTab), <br>            ExclusionPageProc, <br>            0, <br>            NULL, <br>            NULL <br>        } <br>    }; <br>    PROPSHEETHEADER psh = <br>    { <br>        sizeof(PROPSHEETHEADER), <br>        PSH_PROPSHEETPAGE | PSH_PROPTITLE, <br>        hwnd, <br>        hinst, <br>        NULL, <br>        NULL, <br>        sizeof(psp) / sizeof(PROPSHEETPAGE), <br>        0, <br>        (LPCPROPSHEETPAGE)&amp;psp <br>    }; <br> <br>    /*  set property sheet data */ <br> <br>    for (ipg = 0; ipg &lt; psh.nPages; ipg++) <br>        psp[ipg].lParam = (LPARAM)lpscd; <br> <br>    hlib = LoadLibrary (RICHEDIT_LIB); <br> <br>    if (LoadString (hinst, SMH_ProviderName, rgch, sizeof(rgch))) <br>    { <br>        if (!lpCtl3D) <br>            lpCtl3D = CTL3D_Initialize (hinst); <br>         <br>        psh.pszCaption = rgch; <br> <br>        switch (PropertySheet (&amp;psh)) <br>        { <br>          case -1: <br> <br>            hr = ResultFromScode (MAPI_E_CALL_FAILED); <br>            break; <br> <br>          case 0: <br> <br>            hr = ResultFromScode (MAPI_E_USER_CANCEL); <br>            break; <br>        } <br>         <br>        if (lpCtl3D) <br>        { <br>            CTL3D_Uninitialize (lpCtl3D); <br>            lpCtl3D = NULL; <br>        } <br>         <br>        UlRelease (lpscd-&gt;lpsess); <br>        lpscd-&gt;lpsess = NULL; <br>    } <br>    else <br>        hr = ResultFromScode (MAPI_E_CALL_FAILED); <br> <br>    FreeLibrary (hlib); <br>    DebugTraceResult (HrDisplayPropSheets(), hr); <br>    return hr; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
