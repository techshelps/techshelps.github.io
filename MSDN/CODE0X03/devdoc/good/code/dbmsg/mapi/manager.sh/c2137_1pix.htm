<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHTB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2139"></a>SMHTB.C</h2>
<pre><code>/* <br> *  S M H T B . C <br> * <br> *  Sample mail handling hook configuration toolbar <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br>#include &lt;richedit.h&gt; <br> <br>#ifndef WIN16 <br>#include &lt;commctrl.h&gt; <br>#endif <br> <br>/*  Maximum number of font digits */ <br> <br>#define cchSizeMax  16 <br> <br>/*  Enumeration of button bitmaps if toolbar bitmap */ <br> <br>enum { <br>    itbBold, <br>    itbItalic, <br>    itbUnderline, <br>    itbColor, <br>    ctbMax <br>}; <br> <br>/*  Gap sizes for format bar */ <br> <br>#define cxDownButton    16 <br>#define cxName          (125 + cxDownButton) <br>#define cxSize          (40 + cxDownButton) <br>#define cxPlaceHolder   (cxName + 8 + cxSize + 8) <br>#define cxIndent        (1440 / 4) <br> <br>/*  Button descriptions for format bar */ <br> <br>static const TBBUTTON rgtbbChar[] = <br>{ <br>    { cxPlaceHolder, 0L, TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1}, <br>    { itbColor, ID_Color, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 }, <br>    { itbBold, ID_Bold, TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1}, <br>    { itbItalic, ID_Italic, TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1}, <br>    { itbUnderline, ID_Underline, TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1}, <br>}; <br>#define ctbbChar   (sizeof(rgtbbChar) / sizeof(TBBUTTON)) <br> <br>/*  Color descriptions for dropdown color list */ <br> <br>DWORD rgrgb[] = { <br>    RGB(  0,   0,   0), /* Auto         */ <br>    RGB(  0,   0,   0), /* Black        */ <br>    RGB(128,   0,   0), /* Dark red     */ <br>    RGB(  0, 128,   0), /* Dark green   */ <br>    RGB(128, 128,   0), /* Dark yellow  */ <br>    RGB(  0,   0, 128), /* Dark blue    */ <br>    RGB(128,   0, 128), /* Dark purple  */ <br>    RGB(  0, 128, 128), /* Dark aqua    */ <br>    RGB(128, 128, 128), /* Dark grey    */ <br>    RGB(192, 192, 192), /* Light grey   */ <br>    RGB(255,   0,   0), /* Light red    */ <br>    RGB(  0, 255,   0), /* Light green  */ <br>    RGB(255, 255,   0), /* Light yellow */ <br>    RGB(  0,   0, 255), /* Light blue   */ <br>    RGB(255,   0, 255), /* Light purple */ <br>    RGB(  0, 255, 255), /* Light aqua   */ <br>    RGB(255, 255, 255), /* White        */ <br>}; <br>#define crgb    (sizeof(rgrgb) / sizeof(rgrgb[0])) <br>const LPTSTR rgszColor[] = { <br>    "Auto", "Black", "Maroon", <br>    "Green", "Olive", "Navy", <br>    "Purple", "Teal", "Gray", <br>    "Silver", "Red", "Lime", <br>    "Yellow", "Blue", "Fuchia", <br>    "Aqua", "White" <br>}; <br> <br>/*  Font and paragraph effects */ <br>     <br>static const DWORD rgdwEffect[] = { CFE_BOLD, CFE_ITALIC, CFE_UNDERLINE }; <br>static const WORD rgwAlign[] = { PFA_LEFT, PFA_CENTER, PFA_RIGHT }; <br>static const UINT rglFontSize[] = <br>{ <br>     8,  9, 10, 11, <br>    12, 14, 16, 18, <br>    20, 22, 24, 26, <br>    28, 36, 48, 72 <br>}; <br>#define FontSize(_y)    MulDiv((int)(_y), 72, 1440) <br> <br>/*  Toolbar and combobox class names */ <br> <br>static const TCHAR rgchTBClass[] = "SMHToolbar"; <br>static const TCHAR rgchComboBox[] = "ComboBox"; <br> <br>#ifdef  WIN16 <br>#define GWL_USERDATA 0 <br>#endif <br> <br> <br>/* <br> *  Font, font size, and color dropdown and listing functions ----------------- <br> * <br> *  These functions are used to fill in and display the character formats <br> *  for the format bar.  The font listbox gets filled once and only once <br> *  on format bar creation.  The font size listbox will get filled up each <br> *  and everytime the font list gets dropped down.  The font color menu <br> *  will get filled once at startup. <br> */ <br> <br>INT CALLBACK EXPORT <br>EnumFontNames (LPVOID lpvLogFont, <br>    NEWTEXTMETRIC FAR * lpntm, <br>    INT nFontType, <br>    LPARAM lParam) <br>{ <br>    UINT i; <br>    DWORD dw = 0; <br>    LOGFONT FAR * lplf = FWin4Shell() <br>                            ? &amp;((ENUMLOGFONTEX FAR *)lpvLogFont)-&gt;elfLogFont <br>                            : (LOGFONT FAR *)lpvLogFont; <br> <br>    /*  Add the face name into the listbox */ <br> <br>    DebugTrace ("SMH: adding font: %s%s\n", lplf-&gt;lfFaceName, <br>        (lpntm-&gt;tmPitchAndFamily &amp; TMPF_TRUETYPE) <br>            ? " (TrueType)" <br>            : ""); <br> <br>    i = ComboBox_AddString ((HWND)lParam, lplf-&gt;lfFaceName); <br>    if ((i != CB_ERR) || (i != CB_ERRSPACE)) <br>    { <br>        Assert (!(lplf-&gt;lfCharSet &amp; 0xFFFFFF00)); <br>        Assert (!(lplf-&gt;lfPitchAndFamily &amp; 0xFFFFFF00)); <br>        Assert (!(nFontType &amp; 0xFFFF0000)); <br>        dw = lplf-&gt;lfCharSet &amp; 0xFF; <br>        dw &lt;&lt;= 8; <br>        dw |= lplf-&gt;lfPitchAndFamily &amp; 0xFF; <br>        dw &lt;&lt;= 16; <br>        dw |= nFontType &amp; 0xFFFF; <br>        ComboBox_SetItemData ((HWND)lParam, i, dw); <br>    } <br>    return TRUE; <br>} <br> <br>void <br>FillFontNames (HWND hwnd) <br>{ <br>    HDC hdc; <br> <br>    /*  Empty the contents of the listbox and enumerate the fonts */ <br>     <br>    ComboBox_ResetContent (hwnd); <br>    if (hdc = GetDC(NULL)) <br>    { <br>        EnumFontFamilies (hdc, <br>            (LPTSTR)NULL, <br>            (FONTENUMPROC)EnumFontNames, <br>            (LPARAM)(LPVOID)hwnd); <br>        ReleaseDC (NULL, hdc); <br>    } <br>} <br> <br>INT CALLBACK EXPORT <br>EnumFontSizes (LPVOID lpvLogFont, <br>    NEWTEXTMETRIC FAR * lpntm, <br>    INT nFontType, <br>    LPARAM lParam) <br>{ <br>    TCHAR rgch[cchSizeMax]; <br>    UINT i; <br> <br>    if (lpntm-&gt;tmPitchAndFamily &amp; TMPF_TRUETYPE) <br>    { <br>        /*  If the font is TrueType, then just fillin random sizes */ <br>         <br>        for (i = 0; i &lt; (sizeof(rglFontSize) / sizeof(UINT)); i++) <br>        { <br>            wsprintf (rgch, "%d", rglFontSize[i]); <br>            DebugTrace ("SMH: adding font size: %s\n", rgch); <br>            ComboBox_AddString (((LPFORMATBAR)lParam)-&gt;hwndSize, rgch); <br>        } <br>        return FALSE; <br>    } <br>    else <br>    { <br>        /*  Calculate the size of the current instance */ <br> <br>        wsprintf (rgch, "%d", MulDiv ((INT)lpntm-&gt;tmHeight - lpntm-&gt;tmInternalLeading, 72, <br>            GetDeviceCaps (((LPFORMATBAR)lParam)-&gt;hdc, LOGPIXELSY))); <br>        if (ComboBox_FindStringExact (((LPFORMATBAR)lParam)-&gt;hwndSize, -1, rgch) == CB_ERR) <br>        { <br>            DebugTrace ("SMH: font height: %d\n", lpntm-&gt;tmHeight - lpntm-&gt;tmInternalLeading); <br>            DebugTrace ("SMH: adding font size: %s\n", rgch); <br>            ComboBox_AddString (((LPFORMATBAR)lParam)-&gt;hwndSize, rgch); <br>            ((LPFORMATBAR)lParam)-&gt;cSize++; <br>        } <br>        return TRUE; <br>    } <br>} <br> <br>void <br>FillSizes (LPFORMATBAR lpfb) <br>{ <br>    TCHAR rgch[30]; <br> <br>    /*  Empty the contents of the listbox and enumerate the fonts */ <br>     <br>    ComboBox_ResetContent (lpfb-&gt;hwndSize); <br>    ComboBox_GetText (lpfb-&gt;hwndFont, rgch, sizeof(rgch) - 1); <br> <br>    if (lpfb-&gt;hdc = GetDC (lpfb-&gt;hwndSize)) <br>    { <br>        lpfb-&gt;cSize = 0; <br>        EnumFontFamilies (lpfb-&gt;hdc, rgch, (FONTENUMPROC)EnumFontSizes, (LPARAM)lpfb); <br>        ReleaseDC (lpfb-&gt;hwndSize, lpfb-&gt;hdc); <br>    } <br>} <br> <br>void CALLBACK <br>ColorMenu_MeasureItem (HWND hwnd, MEASUREITEMSTRUCT FAR * lpmis) <br>{ <br>    LPFORMATBAR lpfb = (LPFORMATBAR)GetWindowLong (hwnd, GWL_USERDATA); <br>    HFONT hfnt; <br>    TEXTMETRIC tm; <br> <br>    hfnt = SelectObject (lpfb-&gt;hdc, lpfb-&gt;hfnt); <br>    GetTextMetrics (lpfb-&gt;hdc, &amp;tm); <br>    SelectObject (lpfb-&gt;hdc, hfnt); <br>    lpmis-&gt;itemHeight = tm.tmHeight; <br>    lpmis-&gt;itemWidth = 14 * tm.tmAveCharWidth; <br>    return; <br>} <br> <br>void CALLBACK EXPORT <br>ColorMenu_DrawItem (HWND hwnd, DRAWITEMSTRUCT FAR * lpdis) <br>{ <br>    LPFORMATBAR lpfb = (LPFORMATBAR)(GetWindowLong (hwnd, GWL_USERDATA)); <br>    HBRUSH hbr; <br>    WORD dx; <br>    WORD dy; <br>    RECT rc; <br>    DWORD rgbBack; <br>    DWORD rgbText; <br> <br>    if (lpdis-&gt;itemState &amp; ODS_SELECTED) <br>    { <br>        rgbBack = SetBkColor (lpdis-&gt;hDC, GetSysColor (COLOR_HIGHLIGHT)); <br>        rgbText = SetTextColor (lpdis-&gt;hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)); <br>    } <br>    else <br>    { <br>        rgbBack = SetBkColor (lpdis-&gt;hDC, GetSysColor(COLOR_WINDOW)); <br>        rgbText = SetTextColor (lpdis-&gt;hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>    } <br> <br>    ExtTextOut (lpdis-&gt;hDC, <br>            lpdis-&gt;rcItem.left, <br>            lpdis-&gt;rcItem.top, <br>            ETO_OPAQUE, <br>            &amp;lpdis-&gt;rcItem, <br>            NULL, 0, NULL); <br> <br>    dx = GetSystemMetrics(SM_CXBORDER); <br>    dy = GetSystemMetrics(SM_CYBORDER); <br>    rc.top = lpdis-&gt;rcItem.top + dy; <br>    rc.bottom = lpdis-&gt;rcItem.bottom - dy; <br>    rc.left = lpdis-&gt;rcItem.left + dx; <br>    rc.right = rc.left + 2 * (rc.bottom - rc.top); <br> <br>    if (hbr = CreateSolidBrush (lpdis-&gt;itemData)) <br>    { <br>        hbr = SelectObject (lpdis-&gt;hDC, hbr); <br>        Rectangle (lpdis-&gt;hDC, rc.left, rc.top, rc.right, rc.bottom); <br>        DeleteObject (SelectObject (lpdis-&gt;hDC, hbr)); <br>    } <br> <br>    DebugTrace ("SMH: color menu: painting item: %s\n", <br>        (LPCSTR)rgszColor[lpdis-&gt;itemID - ID_Color - 1]); <br>    SelectObject (lpdis-&gt;hDC, lpfb-&gt;hfnt); <br>    TextOut (lpdis-&gt;hDC, <br>        2 * dx + rc.right, <br>        lpdis-&gt;rcItem.top, <br>        rgszColor[lpdis-&gt;itemID - ID_Color - 1], <br>        lstrlen ((LPCSTR)rgszColor[lpdis-&gt;itemID - ID_Color - 1])); <br> <br>    SetTextColor (lpdis-&gt;hDC, rgbText); <br>    SetBkColor (lpdis-&gt;hDC, rgbBack); <br>    return; <br>} <br> <br>void <br>FillColors (LPFORMATBAR lpfb) <br>{ <br>    UINT irgb; <br> <br>    /*  Setup the auto color */ <br> <br>    rgrgb[0] = GetSysColor (COLOR_WINDOWTEXT); <br> <br>    for (irgb = 0; irgb &lt; crgb; irgb++) <br>    { <br>        DebugTrace ("SMH: color menu: adding item: %s (0x%08lX)\n", <br>            (LPCSTR)rgszColor[irgb], rgrgb[irgb]); <br>        AppendMenu (lpfb-&gt;hmnuColor, <br>            MF_ENABLED | MF_OWNERDRAW, <br>            ID_Color + irgb + 1, <br>            (LPCSTR)rgrgb[irgb]); <br>    } <br>} <br> <br>/* <br> *  FormatBar window proc ----------------------------------------------------- <br> * <br> *  The formatbar window proc intercepts several window messages and <br> *  processes them as needed.  The primary messages we operate on are the <br> *  messages that will cause items to be redrawn or shown. <br> * <br> *  Additionally, WM_DESTROY is processed as for cleanup of all the <br> *  formatbar components <br> */ <br> <br>LRESULT CALLBACK EXPORT <br>FormatBarWndProc (HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    LPFORMATBAR lpfb = (LPFORMATBAR)GetWindowLong (hwnd, GWL_USERDATA); <br> <br>    switch (msg) <br>    { <br>      case WM_COMMAND: <br>         <br>        if ((GET_WM_COMMAND_CMD (wParam, lParam) == CBN_DROPDOWN) &amp;&amp; <br>            (GET_WM_COMMAND_ID (wParam, lParam) == ID_FontSize)) <br>            FillSizes (lpfb); <br>        SendMessage (GetParent(hwnd), WM_COMMAND, wParam, lParam); <br>        return TRUE; <br> <br>      case WM_SHOWWINDOW: <br>         <br>        SendMessage (lpfb-&gt;hwndTb, msg, wParam, lParam); <br>        break; <br> <br>      case WM_DRAWITEM: <br>         <br>        ColorMenu_DrawItem (hwnd, (DRAWITEMSTRUCT FAR *)lParam); <br>        return TRUE; <br> <br>      case WM_MEASUREITEM: <br>         <br>        ColorMenu_MeasureItem (hwnd, (MEASUREITEMSTRUCT FAR *)lParam); <br>        return TRUE; <br> <br>      case WM_DESTROY: <br>         <br>        DebugTrace ("SMH: destroying format bar\n"); <br>        DestroyWindow (lpfb-&gt;hwndTb); <br>        DestroyWindow (lpfb-&gt;hwndFont); <br>        DestroyWindow (lpfb-&gt;hwndSize); <br>        DeleteObject (lpfb-&gt;hbrBtnFace); <br>        DestroyMenu (lpfb-&gt;hmnuColor); <br>        UlRelease (lpfb-&gt;lpreoc); <br>        (*lpfb-&gt;lpscd-&gt;lpfnFree) (lpfb); <br>        break; <br>    } <br>    return DefWindowProc (hwnd, msg, wParam, lParam); <br>} <br> <br>/* <br> *  Toolbar subclass proc ----------------------------------------------------- <br> * <br> *  The subclassing of the toolbar is done so that the listboxes added to <br> *  the toolbar will be drawn with the correct control color. <br> */ <br> <br>LRESULT CALLBACK EXPORT <br>ToolbarSubclassProc (HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    LPFORMATBAR lpfb = (LPFORMATBAR)GetWindowLong (GetParent (hwnd), GWL_USERDATA); <br> <br>    switch (msg) <br>    { <br>#ifdef _WIN32 <br>      case WM_CTLCOLORLISTBOX: <br>#else <br>      case WM_CTLCOLOR: <br>   <br>        switch (HIWORD (lParam)) <br>        { <br>          case CTLCOLOR_LISTBOX: <br>#endif <br>            if (!lpfb-&gt;hbrBtnFace) <br>            { <br>                lpfb-&gt;hbrBtnFace = CreateSolidBrush (FWin4Shell() <br>                                                        ? GetSysColor (COLOR_WINDOW) <br>                                                        : GetSysColor (COLOR_BTNFACE)); <br>            } <br>            return (LRESULT)(LPVOID)lpfb-&gt;hbrBtnFace; <br>#ifdef _WIN32 <br>            break; <br>#else <br>            break; <br>        } <br>        break; <br>#endif <br>    } <br> <br>    return CallWindowProc (lpfb-&gt;lpfnToolbar, hwnd, msg, wParam, lParam); <br>} <br> <br>STDMETHODIMP_(SCODE) <br>ScCreateToolbar (LPSCD lpscd, <br>    HWND hwnd, <br>    UINT idPeg, <br>    BOOL fPropsheet, <br>    LPFORMATBAR FAR * lppfb) <br>{ <br>    SCODE sc; <br>    RECT rc; <br>    RECT rcId; <br>    RECT rcTb; <br>    RECT rcCli; <br>    UINT x; <br>    UINT y; <br>    WNDCLASS wc = {0}; <br>    LPFORMATBAR lpfb = NULL; <br> <br>    sc = (*lpscd-&gt;lpfnAlloc) (sizeof(FORMATBAR), &amp;lpfb); <br>    if (!FAILED (sc)) <br>    { <br>        memset (lpfb, 0, sizeof(FORMATBAR)); <br>        lpfb-&gt;hwndEdit = GetDlgItem (hwnd, idPeg); <br> <br>        lpfb-&gt;cf.cbSize = sizeof(CHARFORMAT); <br>        SendMessage (lpfb-&gt;hwndEdit, EM_GETCHARFORMAT, TRUE, (LPARAM)(LPVOID)&amp;lpfb-&gt;cf); <br>        lpfb-&gt;pf.cbSize = sizeof(PARAFORMAT); <br>        SendMessage (lpfb-&gt;hwndEdit, EM_GETPARAFORMAT, 0, (LPARAM)(LPVOID)&amp;lpfb-&gt;pf); <br>        SendMessage (lpfb-&gt;hwndEdit, EM_SETEVENTMASK, 0, ENM_SELCHANGE | ENM_CHANGE); <br> <br>        lpfb-&gt;cf.dwMask = CFM_FACE | CFM_SIZE | CFE_BOLD | CFE_ITALIC | CFE_UNDERLINE | CFM_COLOR; <br>        lpfb-&gt;cf.dwEffects = CFE_AUTOCOLOR; <br>        lstrcpy (lpfb-&gt;cf.szFaceName, "Arial"); <br>        lpfb-&gt;cf.yHeight = 200; <br>        SendMessage (lpfb-&gt;hwndEdit, EM_SETCHARFORMAT, 0, (LPARAM)(LPVOID)&amp;lpfb-&gt;cf); <br> <br>        if (!GetClassInfo (lpscd-&gt;hinst, rgchTBClass, &amp;wc)) <br>        { <br>            wc.style = CS_HREDRAW | CS_VREDRAW; <br>            wc.lpfnWndProc = FormatBarWndProc; <br>            wc.cbWndExtra = sizeof(LPVOID); <br>            wc.hInstance = lpscd-&gt;hinst; <br>            wc.hCursor = LoadCursor (NULL, IDC_ARROW); <br>            wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>            wc.lpszClassName = (LPCTSTR)rgchTBClass; <br>            SideAssert (RegisterClass (&amp;wc)); <br>        } <br>        Assert (IsWindow (hwnd)); <br>        GetWindowRect (lpfb-&gt;hwndEdit, &amp;rcId); <br>        if (lpfb-&gt;hwndFrame = CreateWindow ((LPCTSTR)rgchTBClass, <br>                                        "SMH", <br>                                        WS_CHILD, <br>                                        0, 0, rcId.right, 30, <br>                                        hwnd, <br>                                        (HMENU)ID_Frame, <br>                                        lpscd-&gt;hinst, <br>                                        NULL)) <br>        { <br> <br>            CTL3D_SubclassCtl (lpCtl3D, lpfb-&gt;hwndFrame); <br> <br>            lpfb-&gt;hmnuColor = CreatePopupMenu(); <br>            FillColors (lpfb); <br> <br>            if (lpfb-&gt;hwndTb = CreateToolbarEx (lpfb-&gt;hwndFrame, <br>                                        CCS_TOP | WS_CHILD, <br>                                        0, <br>                                        ctbMax, <br>                                        lpscd-&gt;hinst, <br>                                        ID_Toolbar, <br>                                        rgtbbChar, <br>                                        ctbbChar, <br>                                        16, 16, 16, 16, <br>                                        sizeof(TBBUTTON))) <br>            { <br>                lpfb-&gt;lpscd = lpscd; <br>                SetWindowLong (lpfb-&gt;hwndFrame, GWL_USERDATA, (ULONG)lpfb); <br> <br>                /*  Move the window to where it belongs */ <br> <br>                GetWindowRect (hwnd, &amp;rc); <br>                GetClientRect (lpfb-&gt;hwndTb, &amp;rcTb); <br> <br>                x = rcId.left - rc.left; <br>                y = rcId.top - rc.top - rcTb.bottom - 2; <br> <br>                /*  Adjust y by any title bars and framing */ <br> <br>                if (!fPropsheet) <br>                { <br>                    GetClientRect (hwnd, &amp;rcCli); <br>                    y -= rc.bottom - rc.top - rcCli.bottom; <br>                    x -= (rc.right - rc.left - rcCli.right) / 2; <br>                    y += (rc.right - rc.left - rcCli.right) / 2; <br>                } <br> <br>                MoveWindow (lpfb-&gt;hwndFrame, x, y, rcId.right - rcId.left, rcTb.bottom, FALSE); <br> <br>                lpfb-&gt;hfnt = (HFONT) SendMessage (lpfb-&gt;hwndTb, WM_GETFONT, 0, 0); <br> <br>                lpfb-&gt;lpfnToolbar = (WNDPROC)SetWindowLong (lpfb-&gt;hwndTb, <br>                                        GWL_WNDPROC, <br>                                        (LONG)ToolbarSubclassProc); <br> <br>                lpfb-&gt;hwndFont = CreateWindow ((LPCTSTR)rgchComboBox, <br>                                        NULL, <br>                                        WS_CHILD | WS_VSCROLL | CBS_DROPDOWN | CBS_SORT | WS_VISIBLE, <br>                                        0, 3, cxName, rcTb.bottom * 5, <br>                                        lpfb-&gt;hwndTb, <br>                                        (HMENU) ID_Font, <br>                                        lpscd-&gt;hinst, <br>                                        NULL); <br> <br>                CTL3D_SubclassCtl (lpCtl3D, lpfb-&gt;hwndFont); <br> <br>                SetWindowFont (lpfb-&gt;hwndFont, lpfb-&gt;hfnt, TRUE); <br>                ComboBox_SetExtendedUI (lpfb-&gt;hwndFont, TRUE); <br>                FillFontNames (lpfb-&gt;hwndFont); <br> <br>                lpfb-&gt;hwndSize = CreateWindow ((LPCTSTR)rgchComboBox, <br>                                        NULL, <br>                                        WS_CHILD | WS_VSCROLL | CBS_DROPDOWN | WS_VISIBLE, <br>                                        cxName + 8, 3, cxSize, rcTb.bottom * 5, <br>                                        lpfb-&gt;hwndTb, <br>                                        (HMENU) ID_FontSize, <br>                                        lpscd-&gt;hinst, <br>                                        NULL); <br> <br>                CTL3D_SubclassCtl (lpCtl3D, lpfb-&gt;hwndSize); <br> <br>                SetWindowFont (lpfb-&gt;hwndSize, lpfb-&gt;hfnt, TRUE); <br>                ComboBox_SetExtendedUI (lpfb-&gt;hwndSize, TRUE); <br>                ComboBox_LimitText (lpfb-&gt;hwndSize, cchSizeMax); <br>                FillSizes (lpfb); <br> <br>                UpdateFormatBar (lpfb-&gt;hwndFrame); <br>                ShowWindow (lpfb-&gt;hwndFrame, SW_SHOW); <br>                ShowWindow (lpfb-&gt;hwndTb, SW_SHOW); <br>            } <br>        } <br>    } <br>    *lppfb = lpfb; <br>    DebugTraceSc (ScCreateToolbar(), (lpfb-&gt;hwndFrame ? S_OK : MAPI_E_CALL_FAILED)); <br>    return (lpfb-&gt;hwndFrame ? S_OK : MAPI_E_CALL_FAILED); <br>} <br> <br>STDMETHODIMP_(BOOL) <br>FDoRTFCommand (HWND hwnd, UINT id, UINT code) <br>{ <br>    LPFORMATBAR lpfb = (LPFORMATBAR)(GetWindowLong (hwnd, GWL_USERDATA)); <br>    DWORD dw; <br>    RECT rc; <br>    UINT iSel; <br> <br>    switch (id) <br>    { <br>      case ID_Font: <br> <br>        if (code == CBN_SELENDOK) <br>        { <br>            FillSizes (lpfb); <br>            iSel = ComboBox_GetCurSel (lpfb-&gt;hwndFont); <br>            lpfb-&gt;cf.dwMask = CFM_FACE | CFM_CHARSET; <br>            ComboBox_GetLBText (lpfb-&gt;hwndFont, iSel, lpfb-&gt;cf.szFaceName); <br>            dw = ComboBox_GetItemData (lpfb-&gt;hwndFont, iSel); <br>            lpfb-&gt;cf.bPitchAndFamily = (BYTE)(dw &gt;&gt;= 16) &amp; 0xFF; <br>            lpfb-&gt;cf.bCharSet = (BYTE)(dw &gt;&gt;= 8) &amp; 0xFF; <br>            SendMessage (lpfb-&gt;hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)(LPVOID)&amp;lpfb-&gt;cf); <br>            UpdateFormatBar (lpfb-&gt;hwndFrame); <br>            SetFocus (lpfb-&gt;hwndEdit); <br>        } <br>        break; <br> <br>      case ID_FontSize: <br> <br>        if (code == CBN_SELENDOK) <br>        { <br>            UINT i; <br>            TCHAR rgch[cchSizeMax]; <br> <br>            rgch[0] = 0; <br>            lpfb-&gt;cf.dwMask = CFM_SIZE; <br>            ComboBox_GetLBText (lpfb-&gt;hwndSize, <br>                        ComboBox_GetCurSel (lpfb-&gt;hwndSize), <br>                        rgch); <br>            for (lpfb-&gt;cf.yHeight = 0, i = 0; rgch[i]; i++) <br>                lpfb-&gt;cf.yHeight = (lpfb-&gt;cf.yHeight * 10) + (rgch[i] - '0'); <br>            lpfb-&gt;cf.yHeight *= 20; <br>            SendMessage (lpfb-&gt;hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)(LPVOID)&amp;lpfb-&gt;cf); <br>            UpdateFormatBar (lpfb-&gt;hwndFrame); <br>            SetFocus (lpfb-&gt;hwndEdit); <br>        } <br>        break; <br>        break; <br> <br>      case ID_Color: <br> <br>        if (lpfb-&gt;hdc = GetDC (lpfb-&gt;hwndTb)) <br>        { <br>            SendMessage (lpfb-&gt;hwndTb, TB_GETITEMRECT, 1, (LPARAM) &amp;rc); <br>            MapWindowPoints (lpfb-&gt;hwndTb, NULL, (LPPOINT)&amp;rc, 2); <br>            TrackPopupMenu (lpfb-&gt;hmnuColor, TPM_LEFTALIGN | TPM_LEFTBUTTON, <br>                    rc.left, rc.bottom + 2, 0, hwnd, NULL); <br>            ReleaseDC (lpfb-&gt;hwndTb, lpfb-&gt;hdc); <br>        } <br>        break; <br> <br>      case ID_ColorAuto: <br>      case ID_ColorBlack: <br>      case ID_ColorMaroon: <br>      case ID_ColorGreen: <br>      case ID_ColorOlive: <br>      case ID_ColorBlue: <br>      case ID_ColorPurple: <br>      case ID_ColorTeal: <br>      case ID_ColorGray: <br>      case ID_ColorSilver: <br>      case ID_ColorRed: <br>      case ID_ColorLime: <br>      case ID_ColorYellow: <br>      case ID_ColorNavy: <br>      case ID_ColorFuchia: <br>      case ID_ColorAqua: <br>      case ID_ColorWhite: <br> <br>        lpfb-&gt;cf.dwMask = CFM_COLOR; <br>        lpfb-&gt;cf.dwEffects &amp;= ~CFE_AUTOCOLOR; <br>        lpfb-&gt;cf.dwEffects |= (id == ID_ColorAuto) ? CFE_AUTOCOLOR : 0; <br>        lpfb-&gt;cf.crTextColor = (COLORREF)rgrgb[id - ID_Color - 1]; <br>        SendMessage (lpfb-&gt;hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)(LPVOID)&amp;lpfb-&gt;cf); <br>        break; <br> <br>      case ID_Bold: <br>      case ID_Italic: <br>      case ID_Underline: <br> <br>        DebugTrace ("dwMask before: 0x%08lX\n", lpfb-&gt;cf.dwMask); <br>        DebugTrace ("dwEffects before: 0x%08lX\n", lpfb-&gt;cf.dwEffects); <br>        lpfb-&gt;cf.dwMask = rgdwEffect[id - ID_Bold]; <br>        lpfb-&gt;cf.dwEffects ^= rgdwEffect[id - ID_Bold]; <br>        DebugTrace ("dwMask after: 0x%08lX\n", lpfb-&gt;cf.dwMask); <br>        DebugTrace ("dwEffects after: 0x%08lX\n", lpfb-&gt;cf.dwEffects); <br>        SendMessage (lpfb-&gt;hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)(LPVOID)&amp;lpfb-&gt;cf); <br>        break; <br> <br>      case ID_Indent: <br>      case ID_Collapse: <br> <br>        lpfb-&gt;pf.dwMask = PFM_STARTINDENT; <br>        lpfb-&gt;pf.dxStartIndent += ((id == ID_Indent) ? cxIndent : -cxIndent); <br>        SendMessage (lpfb-&gt;hwndEdit, EM_SETPARAFORMAT, 0, (LPARAM)(LPVOID)&amp;lpfb-&gt;pf); <br>        break; <br> <br>      case ID_Left: <br>      case ID_Center: <br>      case ID_Right: <br> <br>        lpfb-&gt;pf.dwMask = PFM_ALIGNMENT; <br>        lpfb-&gt;pf.wAlignment = rgwAlign[id - ID_Left]; <br>        SendMessage (lpfb-&gt;hwndEdit, EM_SETPARAFORMAT, 0, (LPARAM)(LPVOID)&amp;lpfb-&gt;pf); <br>        break; <br> <br>      case ID_Bullet: <br> <br>        lpfb-&gt;pf.dwMask = PFM_NUMBERING | PFM_OFFSET; <br>        if (lpfb-&gt;pf.wNumbering != PFN_BULLET) <br>        { <br>            lpfb-&gt;pf.wNumbering = PFN_BULLET; <br>            lpfb-&gt;pf.dxOffset = cxIndent; <br>        } <br>        else <br>        { <br>            lpfb-&gt;pf.wNumbering = 0; <br>            lpfb-&gt;pf.dxOffset = 0; <br>        } <br>        SendMessage (lpfb-&gt;hwndEdit, EM_SETPARAFORMAT, 0, (LPARAM)(LPVOID)&amp;lpfb-&gt;pf); <br>        break; <br> <br>      default: <br> <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>void <br>UpdateFormatBar (HWND hwnd) <br>{ <br>    LPFORMATBAR lpfb = (LPFORMATBAR)(GetWindowLong (hwnd, GWL_USERDATA)); <br>    TCHAR rgch[cchSizeMax]; <br>    UINT i; <br> <br>    SendMessage (lpfb-&gt;hwndEdit, EM_GETCHARFORMAT, TRUE, (LPARAM)(LPVOID)&amp;lpfb-&gt;cf); <br>    DebugTrace ("SMH: updating formatbar: format: %s%s%s\n", <br>        (lpfb-&gt;cf.dwEffects &amp; rgdwEffect[0]) ? "BOLD, " : "", <br>        (lpfb-&gt;cf.dwEffects &amp; rgdwEffect[1]) ? "ITALIC, " : "", <br>        (lpfb-&gt;cf.dwEffects &amp; rgdwEffect[2]) ? "UNDERLINED" : ""); <br>    DebugTrace ("SMH: updating formatbar: current font: %s\n", lpfb-&gt;cf.szFaceName); <br>    DebugTrace ("SMH: updating formatbar: current font height: %d\n", lpfb-&gt;cf.yHeight); <br>    DebugTrace ("SMH: updating formatbar: current font size: %d\n", FontSize (lpfb-&gt;cf.yHeight)); <br>    DebugTrace ("SMH: updating formatbar: color: 0x%2X (r), 0x%2X (g), 0x%2x (b)\n", <br>        GetRValue (lpfb-&gt;cf.crTextColor), <br>        GetGValue (lpfb-&gt;cf.crTextColor), <br>        GetBValue (lpfb-&gt;cf.crTextColor)); <br>         <br>    for (i = ID_Bold; i &lt;= ID_Underline; i++) <br>        SendMessage (lpfb-&gt;hwndTb, TB_CHECKBUTTON, i, <br>            MAKELONG (lpfb-&gt;cf.dwEffects &amp; rgdwEffect[i - ID_Bold], 0)); <br> <br>    i = ComboBox_FindString (lpfb-&gt;hwndFont, -1, lpfb-&gt;cf.szFaceName); <br>    if (i != (UINT)ComboBox_GetCurSel (lpfb-&gt;hwndFont)) <br>    { <br>        ComboBox_SetCurSel (lpfb-&gt;hwndFont, i); <br>        ComboBox_SetText (lpfb-&gt;hwndFont, lpfb-&gt;cf.szFaceName); <br>    } <br> <br>    wsprintf (rgch, "%d", FontSize (lpfb-&gt;cf.yHeight)); <br>    i = (UINT)ComboBox_FindStringExact (lpfb-&gt;hwndSize, -1, rgch); <br>    if ((i != CB_ERR) || (i != (UINT)ComboBox_GetCurSel (lpfb-&gt;hwndSize))) <br>        ComboBox_SetCurSel (lpfb-&gt;hwndSize, i); <br>    ComboBox_SetText (lpfb-&gt;hwndSize, rgch); <br>    return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
