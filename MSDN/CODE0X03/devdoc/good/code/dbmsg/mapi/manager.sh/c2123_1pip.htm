<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHINPXP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2131"></a>SMHINPXP.C</h2>
<pre><code>/* <br> *  S M H I N P X P . C <br> * <br> *  Sample mail handling hook filter importing and exporting. <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br>#include &lt;commdlg.h&gt; <br> <br>extern SPropTagArray sptRule; <br> <br>#define Align(_cb,_pad)         (((_cb)+((_pad)-1)) &amp; ~((_pad)-1)) <br>#define Align8(_cb)             Align((_cb),8) <br> <br>#ifdef WIN16 <br>#define SEG(_fp)                HIWORD((DWORD)_fp) <br>#define OFF(_fp)                LOWORD((DWORD)_fp) <br>#define PvRelocPv(_p,_bo,_bn)   ((LPVOID)MAKELONG(OFF(_p)-OFF(_bo)+OFF(_bn),SEG(_bn))) <br>#else <br>#define PvRelocPv(_p,_bo,_bn)   ((LPVOID)((LPBYTE)(_p)-(LPBYTE)(_bo)+(LPBYTE)(_bn))) <br>#endif <br> <br>static const BYTE rgbExportKey[] = { 0x4F, 0x6C, 0x61, 0x66, 0xDE, 0xAD }; <br> <br>/* <br> *  Property Flattening ------------------------------------------------------- <br> */ <br> <br>/* <br> *  ScSizeFlattenedProps() <br> *  ScFlattenProps() <br> *  ScNormalizeFlattenedProps() <br> *   <br> *  These three functions are similar to the MAPI utility functions <br> *  ScCountProps(), ScCopyProps() and ScRelocProps().  SMH uses these <br> *  implementations because they are platform independant.  Additionally, <br> *  the SMH rule property sets are very simple and do not require support <br> *  for complex property types. <br> *   <br> *  To be platform independent, SMH pads all variable length properties <br> *  out to 8 byte aligment.  This ensures that all RISC platforms (MIPS, <br> *  ALPHA and PowerPC) will not suffer aligment problems when using the <br> *  normalized flattened property values. <br> *   <br> *  ScSizeFlattenedProps() calculates the size of a buffer required to <br> *  flatten the properties in the SPropValue array. <br> *   <br> *  ScFlattenProps() copies the properties from the source array to the <br> *  destination buffer. <br> *   <br> *  ScNormalizeFlattenedProps() goes through a flattened a property array <br> *  and bases all the pointers to a specific value. <br> */ <br>SCODE <br>ScSizeFlattenedProps (UINT cv, LPSPropValue rgval, ULONG FAR * lpcb) <br>{ <br>    SCODE sc = S_OK; <br>    ULONG cb = 0; <br> <br>    for (; cv--; rgval++) <br>    { <br>        cb += sizeof(SPropValue); <br>        switch (PROP_TYPE (rgval-&gt;ulPropTag)) <br>        { <br>          default: <br>          case PT_UNSPECIFIED: <br>          case PT_I2: <br>          case PT_R4: <br>          case PT_APPTIME: <br>          case PT_DOUBLE: <br>          case PT_BOOLEAN: <br>          case PT_CURRENCY: <br>          case PT_SYSTIME: <br>          case PT_I8: <br>          case PT_OBJECT: <br>          case PT_CLSID: <br>          case PT_MV_I2: <br>          case PT_MV_LONG: <br>          case PT_MV_R4: <br>          case PT_MV_APPTIME: <br>          case PT_MV_DOUBLE: <br>          case PT_MV_CURRENCY: <br>          case PT_MV_SYSTIME: <br>          case PT_MV_CLSID: <br>          case PT_MV_I8: <br>          case PT_MV_BINARY: <br>          case PT_MV_STRING8: <br>          case PT_MV_UNICODE: <br> <br>            sc = MAPI_E_UNEXPECTED_TYPE; <br>            break; <br>             <br>          case PT_LONG: <br>          case PT_ERROR: <br>          case PT_NULL: <br> <br>            /*  There is no additional data to include in <br>             *  the size of the flattened props. <br>             */ <br>            continue; <br> <br>          case PT_BINARY: <br>                 <br>            cb += Align8 (rgval-&gt;Value.bin.cb); <br>            break; <br> <br>          case PT_STRING8: <br>                 <br>            cb += Align8 ((lstrlenA (rgval-&gt;Value.lpszA ) + 1) * sizeof(CHAR)); <br>            break; <br> <br>          case PT_UNICODE: <br>                 <br>            cb += Align8 ((lstrlenW (rgval-&gt;Value.lpszW ) + 1) * sizeof(WCHAR)); <br>            break; <br> <br>        } <br>         <br>        if (FAILED (sc)) <br>            break; <br>    } <br> <br>    *lpcb = cb; <br>    DebugTraceSc (ScSizeFlattenedProps(), sc); <br>    return sc; <br>} <br> <br> <br>SCODE <br>ScFlattenProps (UINT cv, LPSPropValue rgval, LPBYTE lpb) <br>{ <br>    SCODE sc = S_OK; <br>    LPSPropValue rgvalDst = (LPSPropValue)lpb; <br>    ULONG cb; <br> <br>    /*  Copy over the base properties and setup <br>     *  a pointer to the block of memory following <br>     *  the property value array <br>     */ <br>    memcpy (rgvalDst, rgval, cv * sizeof(SPropValue)); <br>    lpb += cv * sizeof(SPropValue); <br> <br>    for (; cv--; rgval++, rgvalDst++) <br>    { <br>        switch (PROP_TYPE (rgval-&gt;ulPropTag)) <br>        { <br>          default: <br>          case PT_UNSPECIFIED: <br>          case PT_I2: <br>          case PT_R4: <br>          case PT_APPTIME: <br>          case PT_DOUBLE: <br>          case PT_BOOLEAN: <br>          case PT_CURRENCY: <br>          case PT_SYSTIME: <br>          case PT_I8: <br>          case PT_OBJECT: <br>          case PT_CLSID: <br>          case PT_MV_I2: <br>          case PT_MV_LONG: <br>          case PT_MV_R4: <br>          case PT_MV_APPTIME: <br>          case PT_MV_DOUBLE: <br>          case PT_MV_CURRENCY: <br>          case PT_MV_SYSTIME: <br>          case PT_MV_CLSID: <br>          case PT_MV_I8: <br>          case PT_MV_BINARY: <br>          case PT_MV_STRING8: <br>          case PT_MV_UNICODE: <br> <br>            sc = MAPI_E_UNEXPECTED_TYPE; <br>            break; <br> <br>          case PT_LONG: <br>          case PT_ERROR: <br>          case PT_NULL: <br> <br>            /*  There is no additional data to flatten for <br>             *  these types of properties.  All the data is <br>             *  contained in the SPropValue struct. <br>             */ <br>            continue; <br>             <br>          case PT_BINARY: <br> <br>            cb = rgval-&gt;Value.bin.cb; <br>            rgvalDst-&gt;Value.bin.lpb = lpb; <br>            memcpy (lpb, rgval-&gt;Value.bin.lpb, (UINT)cb); <br>            break; <br> <br>          case PT_STRING8: <br> <br>            cb = lstrlenA (rgval-&gt;Value.lpszA) + 1; <br>            rgvalDst-&gt;Value.lpszA = (LPSTR)lpb; <br>            memcpy (lpb, rgval-&gt;Value.lpszA, cb); <br>            break; <br> <br>          case PT_UNICODE: <br>               <br>            cb = (lstrlenW (rgval-&gt;Value.lpszW) + 1) * sizeof(WCHAR); <br>            rgvalDst-&gt;Value.lpszW = (LPWSTR)lpb; <br>            memcpy (lpb, rgval-&gt;Value.lpszW, cb); <br>            break; <br>        } <br> <br>        if (FAILED (sc)) <br>            break; <br> <br>        /*  Align the size and adjust the data pointer */ <br> <br>        lpb += Align8 (cb); <br>    } <br> <br>    DebugTraceSc (ScFlattenProps(), sc); <br>    return sc; <br>} <br> <br> <br>SCODE <br>ScNormalizeFlattenedProps (UINT cv, LPSPropValue rgval, LPVOID lpvOld, LPVOID lpvNew) <br>{ <br>    SCODE sc = S_OK; <br> <br>    for (; cv--; rgval++) <br>    { <br>        switch (PROP_TYPE (rgval-&gt;ulPropTag)) <br>        { <br>          default: <br>          case PT_UNSPECIFIED: <br>          case PT_I2: <br>          case PT_R4: <br>          case PT_APPTIME: <br>          case PT_DOUBLE: <br>          case PT_BOOLEAN: <br>          case PT_CURRENCY: <br>          case PT_SYSTIME: <br>          case PT_I8: <br>          case PT_OBJECT: <br>          case PT_CLSID: <br>          case PT_MV_I2: <br>          case PT_MV_LONG: <br>          case PT_MV_R4: <br>          case PT_MV_APPTIME: <br>          case PT_MV_DOUBLE: <br>          case PT_MV_CURRENCY: <br>          case PT_MV_SYSTIME: <br>          case PT_MV_CLSID: <br>          case PT_MV_I8: <br>          case PT_MV_BINARY: <br>          case PT_MV_STRING8: <br>          case PT_MV_UNICODE: <br> <br>            sc = MAPI_E_UNEXPECTED_TYPE; <br>            break; <br> <br>          case PT_LONG: <br>          case PT_ERROR: <br>          case PT_NULL: <br> <br>            /*  Nothing to relocate */ <br>               <br>            continue; <br> <br>          case PT_BINARY: <br>               <br>            rgval-&gt;Value.bin.lpb = PvRelocPv (rgval-&gt;Value.bin.lpb, lpvOld, lpvNew); <br>            break; <br> <br>          case PT_STRING8: <br> <br>            rgval-&gt;Value.lpszA = PvRelocPv (rgval-&gt;Value.lpszA, lpvOld, lpvNew); <br>            break; <br> <br>          case PT_UNICODE: <br> <br>            rgval-&gt;Value.lpszW = PvRelocPv (rgval-&gt;Value.lpszW, lpvOld, lpvNew); <br>            break; <br>        } <br>         <br>        if (FAILED (sc)) <br>            break; <br>    } <br> <br>    DebugTraceSc (ScNormalizeFlattenedProps(), sc); <br>    return sc; <br>} <br> <br> <br>/* <br> *  Common Dialog Helper Functions -------------------------------------------- <br> */ <br> <br>#ifdef  WIN16 <br>#define COMMDLG             "commdlg.dll" <br>#define GETOPENFILENAME     "GetOpenFileName" <br>#define GETSAVEFILENAME     "GetSaveFileName" <br>#else <br>#define COMMDLG             "comdlg32" <br>#define GETOPENFILENAME     "GetOpenFileNameA" <br>#define GETSAVEFILENAME     "GetSaveFileNameA" <br>#endif <br>typedef BOOL  (WINAPI COMMDLG_GETOPENFILENAME)(LPOPENFILENAME); <br>typedef COMMDLG_GETOPENFILENAME FAR * LPCOMMDLG_GETOPENFILENAME; <br>typedef BOOL  (WINAPI COMMDLG_GETSAVEFILENAME)(LPOPENFILENAME); <br>typedef COMMDLG_GETSAVEFILENAME FAR * LPCOMMDLG_GETSAVEFILENAME; <br>    <br>SCODE <br>ScSetupCommdlg (HINSTANCE FAR * lplib, <br>    LPCOMMDLG_GETOPENFILENAME FAR * lppfnOpen, <br>    LPCOMMDLG_GETSAVEFILENAME FAR * lppfnSave) <br>{ <br>    HINSTANCE hlib = LoadLibrary (COMMDLG); <br>     <br>#ifdef WIN16 <br>    if (hlib &lt; HINSTANCE_ERROR) <br>        hlib = NULL; <br>#endif <br> <br>    if (hlib) <br>    {        <br>        *lppfnOpen = (LPCOMMDLG_GETOPENFILENAME)GetProcAddress (hlib, GETOPENFILENAME); <br>        *lppfnSave = (LPCOMMDLG_GETSAVEFILENAME)GetProcAddress (hlib, GETSAVEFILENAME); <br>    } <br> <br>    *lplib = hlib; <br> <br>    return hlib ? S_OK : MAPI_E_CALL_FAILED; <br>} <br> <br> <br>UINT CALLBACK <br>CommdlgHook (HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    if (msg == WM_INITDIALOG) <br>    { <br>        CTL3D_Subclass (lpCtl3D, hdlg, CTL3D_ALL); <br>        return TRUE; <br>    } <br>     <br>    return FALSE;    <br>} <br> <br> <br>/* <br> *  Filter Exporting ---------------------------------------------------------- <br> *   <br> *  SMH allows the importing and exporting of its filters.  This is <br> *  useful when the user has multiple machines available for use.  Or for <br> *  when the user needs to re-create their profile. <br> * <br> *  ScWriteRule() take the muid of a profile section that contains a <br> *  filter and writes the rule out to the passed in file handle. <br> *   <br> *  ScExportFilters() opens the export file and iterates through the <br> *  rules and calls ScWriteRule() for each filter. <br> */ <br>SCODE <br>ScWriteRule (LPSCD lpscd, HFILE hf, LPMAPIUID lpmuid) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hr; <br>    LPPROFSECT lpsec = NULL; <br>    LPSPropValue lpval = NULL; <br>    LPSPropValue lpvalT = NULL; <br>    ULONG cb; <br>    ULONG cval; <br> <br>    /*  Open the profile section for the rule */ <br> <br>    hr = lpscd-&gt;lpadmin-&gt;lpVtbl-&gt;OpenProfileSection (lpscd-&gt;lpadmin, <br>                                        lpmuid, <br>                                        NULL, <br>                                        0, <br>                                        &amp;lpsec); <br>    if (!HR_FAILED (hr)) <br>    { <br>        /*  Get the set of properties describing the rule */ <br> <br>        hr = lpsec-&gt;lpVtbl-&gt;GetProps (lpsec, <br>                                (LPSPropTagArray)&amp;sptRule, <br>                                0, <br>                                &amp;cval, <br>                                &amp;lpval); <br>        if (!HR_FAILED (hr)) <br>        { <br>            /*  When exporting, we do not want to <br>             *  export the values for store-based <br>             *  entryid's.  These can be profile <br>             *  specific. <br>             */ <br>            lpval[ipRLEid].ulPropTag = PR_NULL; <br>            lpval[ipRLSEid].ulPropTag = PR_NULL; <br> <br>            /*  Flatten the remaining property set and <br>             *  write them out to the export file <br>             */ <br>            sc = ScSizeFlattenedProps (cval, lpval, &amp;cb); <br>            if (!FAILED (sc)) <br>            { <br>                sc = (*lpscd-&gt;lpfnAlloc) (cb, &amp;lpvalT); <br>                if (!FAILED (sc)) <br>                { <br>                    sc = ScFlattenProps (cval, lpval, (LPBYTE)lpvalT); <br>                    if (!FAILED (sc)) <br>                    { <br>                        sc = ScNormalizeFlattenedProps (cval, lpvalT, lpvalT, 0); <br>                        if (!FAILED (sc)) <br>                        { <br>                            /*  We have the flattened props, so <br>                             *  write them out. <br>                             */ <br>                            _lwrite (hf, (LPBYTE)&amp;cb, sizeof(ULONG)); <br>                            _lwrite (hf, (LPBYTE)lpvalT, (UINT)cb); <br>                        } <br>                    } <br>                } <br>            } <br>        } <br>    } <br>    if (HR_FAILED (hr)) <br>        sc = GetScode (sc); <br>     <br>    (*lpscd-&gt;lpfnFree) (lpvalT); <br>    (*lpscd-&gt;lpfnFree) (lpval); <br>    UlRelease (lpsec); <br>     <br>    DebugTraceSc (ScWriteRule(), sc); <br>    return sc; <br>} <br> <br> <br>SCODE <br>ScExportFilters (LPSCD lpscd, HWND hwnd) <br>{ <br>    SCODE sc = S_OK; <br>    CHAR rgch[MAX_PATH]; <br>    HFILE hf; <br>    HINSTANCE hlib = NULL; <br>    LPCOMMDLG_GETOPENFILENAME lpfnOpen; <br>    LPCOMMDLG_GETSAVEFILENAME lpfnSave; <br>    OFSTRUCT ob; <br>    OPENFILENAME ofn = {sizeof(OPENFILENAME)}; <br>    UINT irl; <br>    UINT ofFlags = OF_READWRITE | OF_SHARE_EXCLUSIVE | OF_CREATE; <br> <br>    /*  Setup the commdlg structures */ <br>     <br>    lstrcpy (rgch, "smh.mrl"); <br>    ofn.hwndOwner = hwnd; <br>    ofn.lpstrFilter = "Filter Export Files (*.mrl)\0*.mrl\0"; <br>    ofn.lpstrFile = rgch; <br>    ofn.nMaxFile = MAX_PATH; <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.lpstrTitle = "Create Filter Export File"; <br>    ofn.lpstrDefExt = "MRL"; <br>    ofn.hInstance = lpscd-&gt;hinst; <br>    ofn.lCustData = 0; <br>    ofn.lpfnHook = (LPOFNHOOKPROC)CommdlgHook; <br>    ofn.Flags = OFN_PATHMUSTEXIST       | <br>                OFN_HIDEREADONLY        | <br>                OFN_NOCHANGEDIR         | <br>                OFN_ENABLEHOOK          | <br>                OFN_OVERWRITEPROMPT; <br> <br>    if (FWin4Shell ()) <br>        ofn.Flags |= OFN_EXPLORER; <br> <br>    /*  Get commdlg loaded and ready to serve */ <br> <br>    if (!FAILED (ScSetupCommdlg (&amp;hlib, &amp;lpfnOpen, &amp;lpfnSave))) <br>    { <br>        /*  Prompt the user for the file to use */ <br>         <br>        if ((*lpfnSave) (&amp;ofn)) <br>        { <br>            /*  Open the file and iterate through the rules; <br>             *  Writing each one out as we go. <br>             */ <br>            hf = OpenFile (rgch, &amp;ob, ofFlags); <br>            if (hf != HFILE_ERROR) <br>            { <br>                _lwrite (hf, (LPBYTE)rgbExportKey, sizeof(rgbExportKey)); <br>                _lwrite (hf, (LPBYTE)&amp;lpscd-&gt;crl, sizeof(ULONG)); <br>                for (irl = 0; irl &lt; lpscd-&gt;crl; irl++) <br>                { <br>                    sc = ScWriteRule (lpscd, hf, (LPMAPIUID)lpscd-&gt;lpbin[irl].lpb); <br>                    if (FAILED (sc)) <br>                        break; <br>                } <br> <br>                _lclose (hf); <br>            } <br>        } <br>        FreeLibrary (hlib); <br>    } <br> <br>    DebugTraceSc (ScExportFilters(), sc); <br>    return sc; <br>} <br> <br> <br>/* <br> *  Filter Importing ---------------------------------------------------------- <br> *   <br> *  SMH allows the importing and exporting of its filters.  This is <br> *  useful when the user has multiple machines available for use.  Or for <br> *  when the user needs to re-create their profile. <br> *   <br> *  ScInsertImportedRule() takes a SPropValue array and sets those values <br> *  into a profile section.  It will replace rules by name -- maybe some <br> *  sort of a conflict message would be good here, but... -- otherwise, <br> *  it will create a new profile section for each rule.  The filter is <br> *  then added to the filters page of the SMH config. <br> *   <br> *  ScReadRule() reads in the components of a flattened rule from the <br> *  passed in file handle.  It then tries to insert the rule into the <br> *  profile via ScInsertImportedRule(). <br> *   <br> *  ScImportFilters() opens the imported rule file and iterates through <br> *  the file calling ScReadRule() for each contained filter. <br> */ <br>SCODE <br>ScInsertImportedRule (LPSCD lpscd, HWND hctrl, LPSPropValue lpval) <br>{ <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    LPSBinary lpbin; <br>    LPTSTR FAR * lppsz; <br>    LPPROFSECT lpsec = NULL; <br>    MAPIUID muid; <br>    UINT irl; <br>    UINT cb; <br> <br>    /*  See if the filter alread exists -- if so, we wil replace it */ <br>     <br>    for (irl = 0; irl &lt; lpscd-&gt;crl; irl++) <br>        if (!lstrcmpi (lpscd-&gt;lppsz[irl], lpval[ipRLDisp].Value.lpszA)) <br>            break; <br> <br>    if (irl == lpscd-&gt;crl) <br>        hr = lpscd-&gt;lpsup-&gt;lpVtbl-&gt;NewUID (lpscd-&gt;lpsup, &amp;muid); <br>    else <br>        memcpy (&amp;muid, lpscd-&gt;lpbin[irl].lpb, sizeof(MAPIUID)); <br> <br>    if (!HR_FAILED (hr)) <br>    { <br>        hr = lpscd-&gt;lpadmin-&gt;lpVtbl-&gt;OpenProfileSection (lpscd-&gt;lpadmin, <br>                                        &amp;muid, <br>                                        NULL, <br>                                        MAPI_MODIFY, <br>                                        &amp;lpsec); <br>        if (!HR_FAILED (hr)) <br>        { <br>            hr = lpsec-&gt;lpVtbl-&gt;SetProps (lpsec, cpRLMax, lpval, NULL); <br>            if (!HR_FAILED (hr)) <br>                hr = lpsec-&gt;lpVtbl-&gt;SaveChanges (lpsec, 0); <br>        } <br>    } <br> <br>    /*  Add the filter to the list of active filters */ <br>     <br>    if (!HR_FAILED (hr)) <br>    { <br>        if (irl == lpscd-&gt;crlMax) <br>        { <br>            /*  We need to make room for new entries */ <br> <br>            cb = (irl + GROW_SIZE) * sizeof(LPVOID); <br>            if (FAILED (sc = (*lpscd-&gt;lpfnAlloc) (cb, (LPVOID FAR *)&amp;lppsz))) <br>                goto ret; <br>            memcpy (lppsz, lpscd-&gt;lppsz, lpscd-&gt;crl * sizeof(LPTSTR)); <br>                 <br>            cb = (irl + GROW_SIZE) * sizeof(SBinary); <br>            if (FAILED (sc = (*lpscd-&gt;lpfnAlloc) (cb, &amp;lpbin))) <br>                goto ret; <br>            memcpy (lpbin, lpscd-&gt;lpbin, lpscd-&gt;crl * sizeof(SBinary)); <br> <br>            /*  Swap out the old for the new */ <br> <br>            (*lpscd-&gt;lpfnFree) (lpscd-&gt;lppsz); <br>            (*lpscd-&gt;lpfnFree) (lpscd-&gt;lpbin); <br>            lpscd-&gt;crlMax += GROW_SIZE; <br>            lpscd-&gt;lppsz = lppsz; <br>            lpscd-&gt;lpbin = lpbin; <br>        } <br> <br>        sc = (*lpscd-&gt;lpfnAlloc) (lstrlen (lpval[ipRLDisp].Value.LPSZ) + 1, &amp;lpscd-&gt;lppsz[irl]); <br>        if (!FAILED (sc) &amp;&amp; <br>            !FAILED (sc = (*lpscd-&gt;lpfnAlloc) (sizeof(MAPIUID), &amp;lpscd-&gt;lpbin[irl].lpb))) <br>        { <br>            if ((ListBox_AddString (hctrl, lpval[ipRLDisp].Value.LPSZ) != LB_ERR) &amp;&amp; <br>                (ListBox_SetItemData (hctrl, irl, irl) != LB_ERR)) <br>            { <br>                /*  Copy the identifiers across */ <br>                     <br>                lstrcpy (lpscd-&gt;lppsz[irl], lpval[ipRLDisp].Value.LPSZ); <br>                memcpy (lpscd-&gt;lpbin[irl].lpb, &amp;muid, sizeof(MAPIUID)); <br>                lpscd-&gt;lpbin[irl].cb = sizeof(MAPIUID); <br>                lpscd-&gt;crl++; <br>            } <br>        } <br>        else <br>            hr = ResultFromScode (sc); <br>    } <br> <br>ret: <br>     <br>    UlRelease (lpsec); <br>    DebugTraceResult (ScInsertImportedRule(), hr); <br>    return GetScode (hr); <br>} <br> <br> <br>SCODE <br>ScReadRule (LPSCD lpscd, HWND hctrl, HFILE hf) <br>{ <br>    SCODE sc = S_OK; <br>    LPSPropValue lpval = NULL; <br>    ULONG cb; <br>     <br>    if (_lread (hf, (LPBYTE)&amp;cb, sizeof(ULONG)) == sizeof(ULONG)) <br>    { <br>        sc = (*lpscd-&gt;lpfnAlloc) (cb, &amp;lpval); <br>        if (!FAILED (sc)) <br>        { <br>            if (_lread (hf, (LPBYTE)lpval, (UINT)cb) == cb) <br>            { <br>                sc = ScNormalizeFlattenedProps (cpRLMax, lpval, 0, lpval); <br>                if (!FAILED (sc)) <br>                    sc = ScInsertImportedRule (lpscd, hctrl, lpval); <br>            } <br>        } <br>    } <br>     <br>    (*lpscd-&gt;lpfnFree) (lpval); <br>    DebugTraceSc (ScWriteRule(), sc); <br>    return sc; <br>} <br> <br> <br>SCODE <br>ScImportFilters (LPSCD lpscd, HWND hwnd, HWND hctrl) <br>{ <br>    SCODE sc = S_OK; <br>    BOOL fCtl3d = FALSE; <br>    CHAR rgch[MAX_PATH]; <br>    CHAR rgchT[MAX_PATH + 60]; <br>    CHAR rgb[sizeof(rgbExportKey)]; <br>    HFILE hf; <br>    OFSTRUCT ob; <br>    UINT ofFlags = OF_READ | OF_SHARE_EXCLUSIVE; <br>    UINT irl; <br>    ULONG crlNew; <br>    HINSTANCE hlib = NULL; <br>    LPCOMMDLG_GETOPENFILENAME lpfnOpen; <br>    LPCOMMDLG_GETSAVEFILENAME lpfnSave; <br>    OPENFILENAME ofn = {sizeof(OPENFILENAME)}; <br> <br>    lstrcpy (rgch, "*.mrl"); <br>    ofn.hwndOwner = hwnd; <br>    ofn.lpstrFilter = "Filter Export Files (*.mrl)\0*.mrl\0"; <br>    ofn.lpstrFile = rgch; <br>    ofn.nMaxFile = MAX_PATH; <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.lpstrTitle = "Open Filter Export File"; <br>    ofn.lpstrDefExt = "MRL"; <br>    ofn.hInstance = lpscd-&gt;hinst; <br>    ofn.lCustData = 0; <br>    ofn.lpfnHook = (LPOFNHOOKPROC)CommdlgHook; <br>    ofn.Flags = OFN_PATHMUSTEXIST       | <br>                OFN_HIDEREADONLY        | <br>                OFN_ENABLEHOOK          | <br>                OFN_NOCHANGEDIR; <br> <br>    if (FWin4Shell ()) <br>        ofn.Flags |= OFN_EXPLORER; <br> <br>    if (!FAILED (ScSetupCommdlg (&amp;hlib, &amp;lpfnOpen, &amp;lpfnSave))) <br>    { <br>        if ((*lpfnOpen) (&amp;ofn)) <br>        { <br>            hf = OpenFile (rgch, &amp;ob, ofFlags); <br>            if (hf != HFILE_ERROR) <br>            { <br>                _lread (hf, (LPBYTE)rgb, sizeof(rgbExportKey)); <br>                if (!memcmp (rgb, rgbExportKey, sizeof(rgbExportKey))) <br>                { <br>                    _lread (hf, (LPBYTE)&amp;crlNew, sizeof(ULONG)); <br>                    for (irl = 0; irl &lt; crlNew; irl++) <br>                    { <br>                        sc = ScReadRule (lpscd, hctrl, hf); <br>                        if (FAILED (sc)) <br>                            break; <br>                    } <br>                } <br>                else <br>                { <br>                    wsprintf (rgchT, <br>                        "'%s' is an invalid or corrupt exported filter file.", <br>                        rgch); <br> <br>                    if (CTL3D_GetVer(lpCtl3D) &gt;= 0x220 &amp;&amp; !CTL3D_IsAutoSubclass(lpCtl3D)) <br>                        CTL3D_AutoSubclass (lpCtl3D, lpscd-&gt;hinst, &amp;fCtl3d); <br>                    MessageBox (hwnd, <br>                        rgchT, <br>                        "Import filters", <br>                        MB_TASKMODAL | MB_OK | MB_ICONINFORMATION); <br>                    CTL3D_CeaseAutoSubclass(lpCtl3D, fCtl3d); <br>                } <br> <br>                _lclose (hf); <br>            } <br>        } <br>        else <br>            sc = MAPI_E_USER_CANCEL; <br>         <br>        FreeLibrary (hlib); <br>    } <br>     <br>    DebugTraceSc (ScImportFilters(), sc); <br>    return sc; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
