<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHWB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2140"></a>SMHWB.C</h2>
<pre><code>/* <br> *  S M H W B . C <br> * <br> *  Sample mail handling wastbasket message archiving <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br> <br>/* <br> *  sptFilterWb <br> * <br> *  These are the columns used in wastebasket filtering\archiving <br> */ <br>enum { iwbEid, iwbDlv, iwbSbmt }; <br>const static SizedSPropTagArray (3, sptFilterWb) = <br>{ <br>    3, <br>    { <br>        PR_ENTRYID, <br>        PR_MESSAGE_DELIVERY_TIME, <br>        PR_CLIENT_SUBMIT_TIME <br>    } <br>}; <br> <br> <br>/* <br> *  HrFilterDeleted() <br> * <br> *  Purpose: <br> * <br> *      Filters all the current message from the 'Wastebasket'/'Deleted Items' <br> *      folder based on the archiving model used in sent mail processing. <br> * <br> *  Arguments: <br> * <br> *      lpwb            wastbucket struct for the current store <br> *      lpbin           sbinary holding the entryid of the message <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrFilterDeleted (LPWB lpwb, LPSRowSet lprws) <br>{ <br>    HRESULT hr = ResultFromScode (MAPI_E_NOT_ENOUGH_MEMORY); <br>    FILETIME ft; <br>    LPBYTE lpeid = NULL; <br>    LPMAPIFOLDER lpfldr = lpwb-&gt;lpfldr; <br>    LPMDB lpmdb = lpwb-&gt;lpmdb; <br>    LPSBinary lpbin = NULL; <br>    LPSMH lpsmh = lpwb-&gt;lpsmh; <br>    SBinaryArray sba; <br>    UINT ib; <br>    UINT irw; <br>    ULONG cb = lpwb-&gt;lpvalEid-&gt;Value.bin.cb; <br>    ULONG ulFlags = 0; <br> <br>    if (!FAILED ((*lpsmh-&gt;lpfnAlloc) (lprws-&gt;cRows * sizeof(SBinary), &amp;lpbin))) <br>    { <br>        for (irw = 0; irw &lt; lprws-&gt;cRows; ) <br>        { <br>            ib = 0; <br>            if (!FAILED ((*lpsmh-&gt;lpfnAlloc) (cb, &amp;lpeid))) <br>            { <br>                memcpy (lpeid, lpwb-&gt;lpvalEid-&gt;Value.bin.lpb, (UINT)cb); <br>                if (lprws-&gt;aRow[irw].lpProps[iwbDlv].ulPropTag == PR_MESSAGE_DELIVERY_TIME) <br>                    ft = lprws-&gt;aRow[irw].lpProps[iwbDlv].Value.ft; <br>                else if (lprws-&gt;aRow[irw].lpProps[iwbSbmt].ulPropTag == PR_CLIENT_SUBMIT_TIME) <br>                    ft = lprws-&gt;aRow[irw].lpProps[iwbSbmt].Value.ft; <br>                else <br>                { <br>                    ++irw; <br>                    continue; <br>                } <br>                 <br>                hr = HrArchiveByDate (lpsmh, <br>                                &amp;ft, <br>                                lpfldr, <br>                                lpmdb, <br>                                &amp;lpwb-&gt;bkit, <br>                                lpsmh-&gt;fCatWb, <br>                                cb, <br>                                lpeid); <br>                if (!HR_FAILED (hr)) <br>                { <br>                    lpbin[ib++] = lprws-&gt;aRow[irw].lpProps[iwbEid].Value.bin; <br>                    for (irw += 1; irw &lt; lprws-&gt;cRows; irw++) <br>                    { <br>                        if (lprws-&gt;aRow[irw].lpProps[iwbDlv].ulPropTag == PR_MESSAGE_DELIVERY_TIME) <br>                        { <br>                            ft = lprws-&gt;aRow[irw].lpProps[iwbDlv].Value.ft; <br>                            if ((CompareFileTime (&amp;lpwb-&gt;bkit.dft.ftStart, &amp;ft) == 1) || <br>                                (CompareFileTime (&amp;lpwb-&gt;bkit.dft.ftEnd, &amp;ft) == -1)) <br>                                break; <br> <br>                            lpbin[ib++] = lprws-&gt;aRow[irw].lpProps[iwbEid].Value.bin; <br>                        } <br>                        else if (lprws-&gt;aRow[irw].lpProps[iwbSbmt].ulPropTag == PR_CLIENT_SUBMIT_TIME) <br>                        { <br>                            ft = lprws-&gt;aRow[irw].lpProps[iwbSbmt].Value.ft; <br>                            if ((CompareFileTime (&amp;lpwb-&gt;bkit.dft.ftStart, &amp;ft) == 1) || <br>                                (CompareFileTime (&amp;lpwb-&gt;bkit.dft.ftEnd, &amp;ft) == -1)) <br>                                break; <br> <br>                            lpbin[ib++] = lprws-&gt;aRow[irw].lpProps[iwbEid].Value.bin; <br>                        } <br>                        else <br>                            break; <br>                    } <br> <br>                    sba.cValues = ib; <br>                    sba.lpbin = lpbin; <br>                    hr = lpfldr-&gt;lpVtbl-&gt;CopyMessages (lpfldr, <br>                                &amp;sba, <br>                                NULL, <br>                                lpwb-&gt;bkit.lpfldr, <br>                                0, <br>                                NULL, <br>                                MAPI_MOVE); <br>                } <br>            } <br>            (*lpsmh-&gt;lpfnFree) (lpeid); <br>            lpeid = NULL; <br>        } <br>    } <br>    (*lpsmh-&gt;lpfnFree) (lpbin); <br>    DebugTraceResult (HrFilterDeleted(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  FilterDeletedThread() <br> *   <br> *  Purpose: <br> *   <br> *      This function will spin off and do the archiving of the messages <br> *      in the deleted folder.  It is important to note that on 32 bit <br> *      platforms, this function will belong to its own thread.  Thus <br> *      cleanup and logoff must wait for the thread to terminate before <br> *      releasing returning. <br> *   <br> *  Arguments: <br> *   <br> *      lpwb        pointer to the wastebasket object <br> *   <br> *  Returns: <br> *   <br> *      (DOWRD) : Ignored <br> */ <br>static DWORD WINAPI <br>FilterDeletedThread (LPWB lpwb) <br>{ <br>    HRESULT hr; <br>    LPMAPITABLE lptbl; <br>    LPSRowSet lprws = NULL; <br> <br>    lptbl = lpwb-&gt;lptbl; <br> <br>#ifdef  _WIN32 <br>    SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_IDLE); <br>#endif <br> <br>    while (!lpwb-&gt;fBail) <br>    { <br>        lptbl-&gt;lpVtbl-&gt;SeekRow (lptbl, BOOKMARK_BEGINNING, 0, NULL); <br>        hr = lptbl-&gt;lpVtbl-&gt;QueryRows (lptbl, 64, 0, &amp;lprws); <br>        if (HR_FAILED (hr)) <br>            break; <br> <br>        if (lprws-&gt;cRows) <br>        { <br>            //  Filter the deleted messages <br>            // <br>            HrFilterDeleted (lpwb, lprws); <br> <br>            while (lprws-&gt;cRows) <br>                (*lpwb-&gt;lpsmh-&gt;lpfnFree) (lprws-&gt;aRow[--lprws-&gt;cRows].lpProps); <br>        } <br>        else <br>            break; <br> <br>        (*lpwb-&gt;lpsmh-&gt;lpfnFree) (lprws); <br>        lprws = NULL; <br>    } <br>     <br>    (*lpwb-&gt;lpsmh-&gt;lpfnFree) (lprws); <br>     <br>    /*  Reset the filtering indicator */ <br>#ifdef  _WIN32 <br>    CloseHandle (lpwb-&gt;ht); <br>    lpwb-&gt;ht = NULL; <br>#endif <br>    return 0; <br>} <br> <br> <br>/* <br> *  WBNotify() <br> * <br> *  Purpose: <br> * <br> *      Notification callback on the WB folders of message stores.  When <br> *      rows are added to the WB contents table, we enum the table and <br> *      filter each message added. <br> * <br> *  Arguments: <br> * <br> *      lpv         void pointer to current WB struct <br> *      cntf        count of notifications <br> *      lpntf       notifications <br> * <br> *  Returns: <br> * <br> *      (SCODE) <br> */ <br>STDAPI_(SCODE) <br>WBNotify (LPVOID lpv, ULONG cntf, LPNOTIFICATION lpntf) <br>{ <br>    BOOL fFilter = FALSE; <br>    LPWB lpwb = (LPWB)lpv; <br> <br>    /* Quick and dirty check on the context */ <br> <br>    if (IsBadReadPtr (lpv, sizeof(WB)) || <br>        IsBadReadPtr (((LPWB)lpv)-&gt;lpsmh, sizeof(SMH))) <br>        return S_OK; <br> <br>    /* Just incase we were turned off */ <br> <br>    if (lpwb-&gt;lpsmh-&gt;fCatWb) <br>    { <br>        while (cntf--) <br>        { <br>            Assert (lpntf-&gt;ulEventType == fnevTableModified); <br>            if (lpntf-&gt;info.tab.ulTableEvent == TABLE_ROW_ADDED) <br>            { <br>                fFilter |= TRUE; <br>                break; <br>            } <br>        } <br>         <br>        if (fFilter) <br>        { <br>#ifdef  _WIN32 <br>            if(!lpwb-&gt;ht) <br>            { <br>                DWORD dw; <br>                 <br>                lpwb-&gt;ht = CreateThread (NULL, <br>                            1024, <br>                            (LPTHREAD_START_ROUTINE)FilterDeletedThread, <br>                            lpwb, <br>                            0, <br>                            &amp;dw); <br>            } <br>#else <br>            FilterDeletedThread (lpwb); <br>#endif  // _WIN32 <br>        }        <br>    } <br>    return S_OK; <br>} <br> <br> <br>/* <br> *  HrInitDeletedMailFilter() <br> * <br> *  Purpose: <br> * <br> *      Inits the deleted mail filters by opening the store, finding the <br> *      WB folder, opening the contents table of the WB, and registering <br> *      for table modification notifications. <br> * <br> *  Arguments: <br> * <br> *      lpsmg           the sample mail handler object <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrInitDeletedMailFilter (LPSMH lpsmh) <br>{ <br>    HRESULT hr; <br>    LPMAPIADVISESINK lpadvz = NULL; <br>    LPMAPIFOLDER lpfldr = NULL; <br>    LPMAPITABLE lptbl = NULL; <br>    LPMDB lpmdb = NULL; <br>    LPSPropValue lpval = NULL; <br>    LPWB lpwb = NULL; <br>    ULONG ulType; <br>    UINT cerr = 0; <br>    UINT i; <br> <br>    for (i = 0; i &lt; lpsmh-&gt;lpstotbl-&gt;cSto; i++) <br>    { <br>        hr = ResultFromScode ((*lpsmh-&gt;lpfnAlloc) (sizeof(WB), &amp;lpwb)); <br>        if (HR_FAILED (hr)) <br>            goto nxt; <br>        memset (lpwb, 0, sizeof(WB)); <br> <br>        hr = HrOpenStoEntry (lpsmh-&gt;lpsess, &amp;lpsmh-&gt;lpstotbl-&gt;aSto[i], &amp;lpmdb); <br>        if (HR_FAILED (hr)) <br>            goto nxt; <br> <br>        hr = HrGetOneProp ((LPMAPIPROP)lpmdb, PR_IPM_WASTEBASKET_ENTRYID, &amp;lpval); <br>        if (HR_FAILED (hr)) <br>            goto nxt; <br> <br>        hr = lpmdb-&gt;lpVtbl-&gt;OpenEntry (lpmdb, <br>                                lpval-&gt;Value.bin.cb, <br>                                (LPENTRYID)lpval-&gt;Value.bin.lpb, <br>                                NULL, <br>                                MAPI_MODIFY, <br>                                &amp;ulType, <br>                                (LPUNKNOWN FAR *)&amp;lpfldr); <br>        if (HR_FAILED (hr)) <br>            goto nxt; <br> <br>        hr = lpfldr-&gt;lpVtbl-&gt;GetContentsTable (lpfldr, 0, &amp;lptbl); <br>        if (HR_FAILED (hr)) <br>            goto nxt; <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;SetColumns (lptbl, (LPSPropTagArray)&amp;sptFilterWb, 0); <br>        if (HR_FAILED (hr)) <br>            goto nxt; <br> <br>        hr = HrAllocAdviseSink ((LPNOTIFCALLBACK)&amp;WBNotify, lpwb, &amp;lpadvz); <br>        if (HR_FAILED (hr)) <br>            goto nxt; <br> <br>        hr = lptbl-&gt;lpVtbl-&gt;Advise (lptbl, fnevTableModified, lpadvz, &amp;lpwb-&gt;ulAdvz); <br>        if (HR_FAILED (hr)) <br>            goto nxt; <br> <br>        UlAddRef (lptbl); <br>        UlAddRef (lpfldr); <br>        lpwb-&gt;lpmdb = lpmdb; <br>        lpwb-&gt;lptbl = lptbl; <br>        lpwb-&gt;lpfldr = lpfldr; <br>        lpwb-&gt;lpvalEid = lpval; <br>        lpwb-&gt;lpsmh = lpsmh; <br>        lpval = NULL; <br> <br>        /* Hook it in */ <br> <br>        lpwb-&gt;wbNext = lpsmh-&gt;lstWb; <br>        lpsmh-&gt;lstWb = lpwb; <br>        lpwb = NULL; <br>nxt: <br> <br>        if (HR_FAILED (hr)) <br>            cerr++; <br> <br>        (*lpsmh-&gt;lpfnFree) (lpval); <br>        lpval = NULL; <br> <br>        (*lpsmh-&gt;lpfnFree) (lpwb); <br>        lpwb = NULL; <br> <br>        UlRelease (lpadvz); <br>        lpadvz = NULL; <br> <br>        UlRelease (lpfldr); <br>        lpfldr = NULL; <br> <br>        UlRelease (lptbl); <br>        lptbl = NULL; <br>    } <br> <br>    hr = ResultFromScode (cerr ? MAPI_W_ERRORS_RETURNED : S_OK); <br>    DebugTraceResult (HrInitDeletedMailFilter(), hr); <br>    return hr; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
