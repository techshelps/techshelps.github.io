<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHOOF.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2135"></a>SMHOOF.C</h2>
<pre><code>/* <br> *  S M H O O F . C <br> * <br> *  Sample mail handling hook <br> *  Out of office management <br> * <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br>#include &lt;mapiutil.h&gt; <br>#include &lt;cindex.h&gt; <br>#include &lt;limits.h&gt; <br> <br>#ifdef _WIN32 <br>#define szPlatform "32" <br>#else <br>#define szPlatform <br>#endif <br> <br>enum { ipOofRId, ipOofREid, cpOofMax }; <br>enum { icrgFrom, icrgSubmit, icrgTo, icrgCC, icrgSubj, icrgImp, icrgSen, ccrgMax }; <br> <br>enum <br>{ <br>    ipRespSen, <br>    ipRespConvKey, <br>    ipRespConvIdx, <br>    ipRespConvTopic, <br>    ipRespReportTag, <br>    ipRespOrigAuthEid, <br>    ipRespOrigAuthorName, <br>    ipRespOrigAuthorSKey, <br>    ipRespOrigSubmitTime, <br>    ipRespPriority, <br>    ipRespImportance, <br>    ipRespSubject, <br>    ipRespSubjectPrefix, <br>    ipRespDelAfterSub, <br>    ipRespMessageClass, <br>    ipRespMessageFlags, <br>    cpTargetResponseMax <br>}; <br> <br>enum <br>{ <br>    ipRespRecipName, <br>    ipRespRecipAdrType, <br>    ipRespRecipEmail, <br>    ipRespRecipType, <br>    ipRespRecipEid, <br>    ipRespRecipSKey, <br>    cpTargetRecipMax <br>}; <br> <br>enum <br>{ <br>    ipMsgClass, <br>    ipMsgFlags, <br>    ipRecipMe, <br>    ipNSubj, <br>    ipSndrEid, <br>    ipSndrNm, <br>    ipSndrType, <br>    ipSndrEmail, <br>    ipSndrSKey, <br>    ipConvIndex, <br>    ipConvTopic, <br>    ipConvKey, <br>    ipOrigPriority, <br>    ipReportTag, <br>    ipOrigAuthorEid, <br>    ipOrigAuthorName, <br>    ipOrigAuthorSKey, <br>    ipOrigSubmitTime, <br>    ipSentRepName, <br>    ipSentRepType, <br>    ipSentRepEmail, <br>    ipSentRepSKey, <br>    ipStoreSupport, <br>    ipSubmitTime, <br>    ipDisplayTo, <br>    ipDisplayCc, <br>    ipOofSubj, <br>    ipImportance, <br>    ipSensitivity, <br>    cpResponseMax <br>}; <br> <br>const static SizedSPropTagArray (cpResponseMax, sptResponse) = <br>{ <br>    cpResponseMax, <br>    { <br>        PR_MESSAGE_CLASS, <br>        PR_MESSAGE_FLAGS, <br>        PR_MESSAGE_RECIP_ME, <br>        PR_NORMALIZED_SUBJECT, <br>        PR_SENDER_ENTRYID, <br>        PR_SENDER_NAME, <br>        PR_SENDER_ADDRTYPE, <br>        PR_SENDER_EMAIL_ADDRESS, <br>        PR_SENDER_SEARCH_KEY, <br>        PR_CONVERSATION_INDEX, <br>        PR_CONVERSATION_TOPIC, <br>        PR_CONVERSATION_KEY, <br>        PR_PRIORITY, <br>        PR_REPORT_TAG, <br>        PR_ORIGINAL_AUTHOR_ENTRYID, <br>        PR_ORIGINAL_AUTHOR_NAME, <br>        PR_ORIGINAL_AUTHOR_SEARCH_KEY, <br>        PR_ORIGINAL_SUBMIT_TIME, <br>        PR_SENT_REPRESENTING_NAME, <br>        PR_SENT_REPRESENTING_ADDRTYPE, <br>        PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>        PR_SENT_REPRESENTING_SEARCH_KEY, <br>        PR_STORE_SUPPORT_MASK, <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_DISPLAY_TO,                   <br>        PR_DISPLAY_CC, <br>        PR_SUBJECT, <br>        PR_IMPORTANCE, <br>        PR_SENSITIVITY, <br>    } <br>}; <br> <br>enum { ipDispNm, ipAdrTyp, ipEmail, ipSKey, cpUserMax }; <br>const static SizedSPropTagArray (cpUserMax, sptUser) = <br>{ <br>    cpUserMax, <br>    { <br>        PR_DISPLAY_NAME, <br>        PR_ADDRTYPE, <br>        PR_EMAIL_ADDRESS, <br>        PR_SEARCH_KEY, <br>    } <br>}; <br> <br>enum { ropOof, ropForward, ropReply }; <br>static const LPTSTR rgszSubjPrfx[] = <br>{ <br>    "OOF: ", <br>    "FW: ", <br>    "RE: " <br>}; <br> <br>enum <br>{ <br>    ivHdrSndrName, <br>    ivHdrSndrType, <br>    ivHdrSndrEmail, <br>    ivHdrSentRepName, <br>    ivHdrSentRepType, <br>    ivHdrSentRepEmail, <br>    ivHdrSubmitTime, <br>    ivDisplayTo, <br>    ivDisplayCc, <br>    ivSubject, <br>    ivImportance, <br>    ivSensitivity, <br>    cvHeader <br>}; <br> <br>static const SizedSPropTagArray (cvHeader, sptHeader) =  <br>{ <br>    cvHeader, <br>    { <br>        PR_SENDER_NAME, <br>        PR_SENDER_ADDRTYPE, <br>        PR_SENDER_EMAIL_ADDRESS, <br>        PR_SENT_REPRESENTING_NAME, <br>        PR_SENT_REPRESENTING_ADDRTYPE, <br>        PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_DISPLAY_TO,                   <br>        PR_DISPLAY_CC, <br>        PR_SUBJECT, <br>        PR_IMPORTANCE, <br>        PR_SENSITIVITY <br>    } <br>}; <br> <br>static const SizedSPropTagArray (1, sptForward) = <br>{ <br>    1, <br>    { <br>        PR_MESSAGE_ATTACHMENTS, <br>    } <br>}; <br> <br>enum { ipAttPos, ipAttNum, ipAttMeth, ipAttName, cpTaggingMax }; <br>static const SizedSPropTagArray (cpTaggingMax, sptTagging) = <br>{ <br>    cpTaggingMax, <br>    { <br>        PR_RENDERING_POSITION, <br>        PR_ATTACH_NUM, <br>        PR_ATTACH_METHOD, <br>        PR_ATTACH_FILENAME <br>    } <br>}; <br> <br>static const LPTSTR rgszHeaderField[] = <br>{ <br>    "Sent:", <br>    "To:", <br>    "Cc:", <br>    "Subject:", <br>    "Importance:", <br>    "Sensitivity:" <br>}; <br> <br>static const LPTSTR rgszImportance[] =  <br>{ <br>    "Low", <br>    "Normal", <br>    "High" <br>}; <br> <br>static const LPTSTR rgszSensitivity[] = <br>{ <br>    "Normal", <br>    "Personal", <br>    "Private", <br>    "Confidential" <br>}; <br> <br>static const TCHAR * rgszDay[] = <br>{ <br>    TEXT ("Sunday"), <br>    TEXT ("Monday"), <br>    TEXT ("Tuesday"), <br>    TEXT ("Wednesday"), <br>    TEXT ("Thursday"), <br>    TEXT ("Friday"), <br>    TEXT ("Saturday") <br>}; <br>extern TCHAR FAR * rgtstrMonthFull[]; <br> <br> <br>LONG <br>CchInsertSz (HWND hwnd, LPTSTR lpsz) <br>{ <br>    SendMessage (hwnd, EM_REPLACESEL, 0, (LPARAM) lpsz); <br>    return lstrlen (lpsz); <br>} <br> <br> <br>VOID <br>FileTimeToDateTimeSz (FILETIME FAR * lpft, LPTSTR rgch, UINT cb) <br>{ <br>    SYSTEMTIME st; <br> <br>    if (FileTimeToSystemTime (lpft, &amp;st)) <br>    { <br>        wsprintf (rgch, <br>            "%s, %s %02d, %4d %d:%02d %s", <br>            rgszDay[st.wDayOfWeek], <br>            rgtstrMonthFull[st.wMonth - 1], <br>            st.wDay, <br>            st.wYear, <br>            st.wHour &amp; 12, <br>            st.wMinute, <br>            (st.wHour &gt; 11) ? "PM" : "AM"); <br>    } <br>    else <br>        lstrcpy (rgch, "Unavailable"); <br>} <br> <br>HRESULT <br>HrCopyOriginalBody (LPSMH lpsmh, <br>    HWND hwnd, <br>    LPMESSAGE lpmsg, <br>    LONG FAR * lpcch) <br>{ <br>    HRESULT hr; <br>    CHARRANGE chrg = {0}; <br>    EDITSTREAM es = {0}; <br>    LPSTREAM lpstm = NULL; <br>    LPSTREAM lpstmT = NULL; <br> <br>    *lpcch = 0; <br>    hr = lpmsg-&gt;lpVtbl-&gt;OpenProperty (lpmsg, <br>                                PR_RTF_COMPRESSED, <br>                                &amp;IID_IStream, <br>                                0, 0, <br>                                (LPUNKNOWN FAR *)&amp;lpstmT); <br>    if (!HR_FAILED (hr)) <br>    { <br>        hr = WrapCompressedRTFStream (lpstmT, 0, &amp;lpstm); <br>        if (!HR_FAILED (hr)) <br>        { <br>            es.pfnCallback = (EDITSTREAMCALLBACK)lpstm-&gt;lpVtbl-&gt;Read; <br>            es.dwCookie = (DWORD)lpstm; <br>             <br>            /*  Stuff a newline into the edit <br>             *  control such that whatever preceeds <br>             *  the body will be separated from the <br>             *  the text of the original message <br>             */ <br>            SendMessage (hwnd, EM_EXGETSEL, 0, (LPARAM) &amp;chrg); <br>            CchInsertSz (hwnd, "\r\n"); <br> <br>            /*  Do the body now */ <br>             <br>            SendMessage (hwnd, <br>                EM_STREAMIN, <br>                SF_RTF | SFF_SELECTION | SFF_PLAINRTF, <br>                (LPARAM)&amp;es); <br> <br>            /*  Calculate the size of the body in characters */ <br>             <br>            Edit_SetSel (hwnd, chrg.cpMin, INT_MAX); <br>            SendMessage (hwnd, EM_EXGETSEL, 0, (LPARAM) &amp;chrg); <br>            *lpcch = chrg.cpMax - chrg.cpMin; <br> <br>            /*  Reset the selection to the begining <br>             *  of the edit control such that all <br>             *  additions occur before the original <br>             *  body <br>             */ <br>            Edit_SetSel (hwnd, 0, 0); <br>        } <br>    } <br> <br>    UlRelease (lpstm); <br>    UlRelease (lpstmT); <br>    DebugTraceResult (HrCopyOriginalBody(), hr); <br>    return hr; <br>} <br> <br> <br>HRESULT <br>HrInsertOriginalHeader (LPSMH lpsmh, <br>    HWND hwnd, <br>    LPSPropValue lpval, <br>    CHARFORMAT FAR * lpcf, <br>    LONG FAR * lpcch) <br>{ <br>    CHAR rgch[MAX_PATH]; <br>    CHARRANGE chrg = {0}; <br>    CHARRANGE chrgHdr = {0}; <br>    CHARRANGE rgchrg[ccrgMax] = {0}; <br>    LONG cp; <br>    LPTSTR lpsz; <br>    UINT icrg = 0; <br>    UINT ip; <br>     <br>    /*  Stuff a newline into the edit <br>     *  control such that whatever preceeds <br>     *  the body will be separated from the <br>     *  the text of the original message <br>     */ <br>    SendMessage (hwnd, EM_EXGETSEL, 0, (LPARAM) &amp;chrgHdr); <br>    CchInsertSz (hwnd, "\r\n"); <br> <br>    /*  Mark the begining of the header */ <br>     <br>    SendMessage (hwnd, EM_EXGETSEL, 0, (LPARAM) &amp;chrg); <br>     <br>    cp = chrg.cpMin; <br>    cp += CchInsertSz (hwnd, "\r\n----------\r\n"); <br> <br>    /*  Insert the "From: xxxx" line */ <br>     <br>    if ((lpval[ipSndrNm].ulPropTag == PR_SENDER_NAME) &amp;&amp; <br>        (lpval[ipSndrNm].Value.LPSZ != NULL) &amp;&amp; <br>        (*lpval[ipSndrNm].Value.LPSZ != 0)) <br>    { <br>        rgchrg[icrg].cpMin = cp; <br>        cp += CchInsertSz (hwnd, "From:"); <br>        rgchrg[icrg].cpMax = cp; <br>        icrg++; <br>         <br>        cp += CchInsertSz (hwnd, "\t"); <br>        cp += CchInsertSz (hwnd, lpval[ipSndrNm].Value.LPSZ); <br> <br>        /*  If we were representing someone else... */ <br> <br>        if ((lpval[ipSentRepName].ulPropTag == PR_SENT_REPRESENTING_NAME) &amp;&amp; <br>            (lpval[ipSentRepName].Value.LPSZ != NULL) &amp;&amp; <br>            (*lpval[ipSentRepName].Value.LPSZ != 0)) <br>        { <br>            if ((lpval[ipSndrSKey].ulPropTag != PR_SENDER_SEARCH_KEY) || <br>                (lpval[ipSentRepSKey].ulPropTag != PR_SENT_REPRESENTING_SEARCH_KEY) || <br>                (lpval[ipSndrSKey].Value.bin.cb != lpval[ipSentRepSKey].Value.bin.cb) || <br>                memcmp (lpval[ipSndrSKey].Value.bin.lpb, <br>                    lpval[ipSentRepSKey].Value.bin.lpb, <br>                    lpval[ipSndrSKey].Value.bin.cb)) <br>            { <br>                cp += CchInsertSz (hwnd, " on behalf of "); <br>                cp += CchInsertSz (hwnd, lpval[ipSentRepName].Value.LPSZ); <br>            } <br>            cp += CchInsertSz (hwnd, TEXT("\r\n")); <br>        } <br> <br>        /*  Insert the remaining lines */ <br>         <br>        for (ip = ipSubmitTime; ip &lt; cpResponseMax; ip++) <br>        { <br>            lpsz = NULL; <br>            switch (PROP_TYPE (lpval[ip].ulPropTag)) <br>            { <br>              case PT_TSTRING: <br> <br>                /*  Strings are strings */ <br>                   <br>                lpsz = lpval[ip].Value.LPSZ; <br>                break; <br> <br>              case PT_SYSTIME: <br> <br>                /*  Convertt the date to a string */ <br>                   <br>                FileTimeToDateTimeSz (&amp;lpval[ip].Value.ft, rgch, sizeof(rgch)); <br>                lpsz = rgch; <br>                break; <br> <br>              case PT_LONG: <br> <br>                /*  Importance and Sensitivity use a look-up to <br>                 *  find the proper string to insert.  If the value <br>                 *  equates to the "normal" level of a given message, <br>                 *  then no value is displayed. <br>                 */ <br>                if ((lpval[ip].ulPropTag == PR_IMPORTANCE) &amp;&amp; <br>                    (lpval[ip].Value.l != IMPORTANCE_NORMAL)) <br>                    lpsz = rgszImportance[lpval[ip].Value.l]; <br>                else if ((lpval[ip].ulPropTag == PR_SENSITIVITY) &amp;&amp; <br>                    (lpval[ip].Value.l != SENSITIVITY_NONE)) <br>                    lpsz = rgszSensitivity[lpval[ip].Value.l]; <br>                break; <br>            } <br> <br>            if (lpsz &amp;&amp; *lpsz) <br>            { <br>                rgchrg[icrg].cpMin = cp; <br>                cp += CchInsertSz (hwnd, rgszHeaderField[ip - ipSubmitTime]); <br>                rgchrg[icrg].cpMax = cp; <br>                icrg++; <br>                 <br>                cp += CchInsertSz (hwnd, "\t"); <br>                cp += CchInsertSz (hwnd, lpsz); <br>                cp += CchInsertSz (hwnd, TEXT("\r\n")); <br>            } <br>        } <br>        cp += CchInsertSz (hwnd, TEXT("\r\n")); <br> <br>        /*  Ensure that the text is formated in the <br>         *  charformat passed in.  Such that we can <br>         *  manipulate the rest with no worries <br>         */ <br>        chrg.cpMin += 2; <br>        chrg.cpMax = cp; <br>        SendMessage (hwnd, EM_EXSETSEL, 0, (LPARAM) &amp;chrg); <br>        SendMessage (hwnd, EM_SETCHARFORMAT, SCF_SELECTION|SCF_WORD, (LPARAM)lpcf); <br> <br>        /*  Run through all the field headers and make them bold */ <br>         <br>        lpcf-&gt;cbSize = sizeof(CHARFORMAT); <br>        lpcf-&gt;dwMask = CFM_BOLD; <br>        lpcf-&gt;dwEffects = CFE_BOLD; <br> <br>        while (icrg) <br>        { <br>            chrg = rgchrg[--icrg]; <br>            SendMessage (hwnd, EM_EXSETSEL, 0, (LPARAM)&amp;chrg); <br>            SendMessage (hwnd, EM_SETCHARFORMAT, SCF_SELECTION|SCF_WORD, (LPARAM)lpcf); <br>        } <br> <br>        /*  Calculate the size of the header */ <br>         <br>        *lpcch = cp - chrgHdr.cpMin; <br>        Edit_SetSel (hwnd, 0, 0); <br>    } <br>     <br>    DebugTraceResult (HrInsertOriginalHeader(), hrSuccess); <br>    return hrSuccess; <br>} <br> <br> <br>HRESULT <br>HrInsertAnnotation (LPSMH lpsmh, <br>    HWND hwnd, <br>    UINT rop, <br>    LPRULE lprl, <br>    LONG FAR * lpcch) <br>{ <br>    CHARRANGE chrg = {0}; <br>    EDITSTREAM es = {0}; <br>    LPBYTE lpb; <br>    RTFS rtfs = {0}; <br>    ULONG cb; <br>     <br>    /*  Setup which annotation to use */ <br>     <br>    if (rop != ropOof) <br>    { <br>        cb = lprl-&gt;cbRTF; <br>        lpb = lprl-&gt;lpbRTF; <br>    } <br>    else <br>    { <br>        cb = lpsmh-&gt;oof.cbRTF; <br>        lpb = lpsmh-&gt;oof.lpbRTF; <br>    } <br> <br>    /*  Stream the bad boy in */ <br>     <br>    rtfs.cb = 0; <br>    rtfs.cbMax = cb; <br>    rtfs.lpb = lpb; <br>    es.pfnCallback = ReadRTFFromBuffer; <br>    es.dwCookie = (DWORD)&amp;rtfs; <br>    SendMessage (hwnd, <br>        EM_STREAMIN, <br>        SF_RTF | SFF_SELECTION | SFF_PLAINRTF, <br>        (LPARAM)&amp;es); <br> <br>    /*  Calculate the size of what we just streamed in */ <br>     <br>    SendMessage (hwnd, EM_EXGETSEL, 0, (LPARAM) &amp;chrg); <br>    *lpcch = chrg.cpMax; <br> <br>    DebugTraceResult (HrInsertAnnotation(), hrSuccess); <br>    return hrSuccess; <br>} <br> <br> <br>HRESULT <br>HrTagAttachments (LPSMH lpsmh, <br>    HWND hwnd, <br>    LONG dch, <br>    LPMESSAGE lpmsg) <br>{ <br>    HRESULT hr; <br>    CHAR rgch[MAX_PATH] = {0}; <br>    LONG ichPos; <br>    LPATTACH lpatt = NULL; <br>    LPMAPITABLE lptbl = NULL; <br>    LPMESSAGE lpmsgT = NULL; <br>    LPSPropValue lpval = NULL; <br>    LPSRowSet lprws = NULL; <br>    UINT irw; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;GetAttachmentTable (lpmsg, 0, &amp;lptbl); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = lptbl-&gt;lpVtbl-&gt;SetColumns (lptbl, (LPSPropTagArray)&amp;sptTagging, 0); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    while (TRUE) <br>    { <br>        hr = lptbl-&gt;lpVtbl-&gt;QueryRows (lptbl, 64, 0, &amp;lprws); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        if (lprws-&gt;cRows == 0) <br>            break; <br> <br>        for (irw = 0; irw &lt; lprws-&gt;cRows; irw++) <br>        { <br>            switch (lprws-&gt;aRow[irw].lpProps[ipAttMeth].Value.l) <br>            { <br>              case ATTACH_OLE: <br> <br>                lstrcpy (rgch, "&lt;&lt;OLE Object: unknown&gt;&gt;"); <br>                break; <br> <br>              case ATTACH_EMBEDDED_MSG: <br> <br>                hr = lpmsg-&gt;lpVtbl-&gt;OpenAttach (lpmsg, <br>                                        lprws-&gt;aRow[irw].lpProps[ipAttNum].Value.l, <br>                                        NULL, <br>                                        0, <br>                                        &amp;lpatt); <br>                if (!HR_FAILED (hr)) <br>                { <br>                    hr = lpatt-&gt;lpVtbl-&gt;OpenProperty (lpatt, <br>                                        PR_ATTACH_DATA_OBJ, <br>                                        &amp;IID_IMessage, <br>                                        0, 0, <br>                                        (LPUNKNOWN FAR *)&amp;lpmsgT); <br>                    if (!HR_FAILED (hr)) <br>                    { <br>                        /*  Get the subject of the embedded message <br>                         *  as the tag identifier <br>                         */ <br>                        hr = HrGetOneProp ((LPMAPIPROP)lpmsgT, PR_SUBJECT, &amp;lpval); <br>                    } <br>                } <br> <br>                wsprintf (rgch, "&lt;&lt;Message: %s&gt;&gt;", <br>                    HR_FAILED (hr) ? "" : lpval-&gt;Value.LPSZ); <br>                 <br>                (*lpsmh-&gt;lpfnFree) (lpval); <br>                UlRelease (lpmsgT); <br>                UlRelease (lpatt); <br>                lpmsgT = NULL; <br>                lpval = NULL; <br>                lpatt = NULL; <br>                break; <br> <br>              default: <br>              case ATTACH_BY_VALUE: <br>              case ATTACH_BY_REFERENCE: <br> <br>                /*  Use the filename for the attachment tag */ <br> <br>                wsprintf (rgch, "&lt;&lt;File: %s&gt;&gt;", <br>                    (lprws-&gt;aRow[irw].lpProps[ipAttName].ulPropTag == PR_ATTACH_FILENAME) <br>                          ? lprws-&gt;aRow[irw].lpProps[ipAttName].Value.LPSZ <br>                          : ""); <br>                break; <br>            } <br> <br>            /*  Setup the selection such that we replace the attachment <br>             *  place holder wiht the attachment tag <br>             */ <br>            ichPos = lprws-&gt;aRow[irw].lpProps[ipAttPos].Value.l; <br>            if (ichPos == -1) <br>                Edit_SetSel (hwnd, INT_MAX, INT_MAX); <br>            else <br>                Edit_SetSel (hwnd, ichPos + dch - 1, ichPos + dch); <br> <br>            /*  Insert the tag and adjust the offset <br>             *  of the next attachment tag posiiton. <br>             */ <br>            dch += CchInsertSz (hwnd, rgch) - 1; <br> <br>            /*  Free the row data */ <br>             <br>            (*lpsmh-&gt;lpfnFree) (lprws-&gt;aRow[irw].lpProps); <br>        } <br>         <br>        hr = hrSuccess; <br>        (*lpsmh-&gt;lpfnFree) (lprws); <br>        lprws = NULL; <br>    } <br>    (*lpsmh-&gt;lpfnFree) (lprws); <br>    lprws = NULL; <br> <br>ret: <br>     <br>    UlRelease (lptbl); <br>     <br>    DebugTraceResult (HrTagAttachments(), hr); <br>    return hr; <br>} <br> <br> <br>HRESULT <br>HrOffsetAttachments (LPSMH lpsmh, <br>    LONG dch, <br>    LPMESSAGE lpmsg) <br>{ <br>    HRESULT hr; <br>    LPATTACH lpatt = NULL; <br>    LPMAPITABLE lptbl = NULL; <br>    LPSRowSet lprws = NULL; <br>    UINT irw; <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;GetAttachmentTable (lpmsg, 0, &amp;lptbl); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = lptbl-&gt;lpVtbl-&gt;SetColumns (lptbl, (LPSPropTagArray)&amp;sptTagging, 0); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    while (TRUE) <br>    { <br>        hr = lptbl-&gt;lpVtbl-&gt;QueryRows (lptbl, 64, 0, &amp;lprws); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        if (lprws-&gt;cRows == 0) <br>            break; <br> <br>        for (irw = 0; irw &lt; lprws-&gt;cRows; irw++) <br>        { <br>            /*  If the rendering position is not -1, we <br>             *  want to adjust the positioning by the value <br>             *  passed in dch <br>             */ <br>            if (lprws-&gt;aRow[irw].lpProps[ipAttPos].Value.l != -1) <br>            { <br>                /*  Adjust the positioning, and set in into the attachment */ <br>                 <br>                lprws-&gt;aRow[irw].lpProps[ipAttPos].Value.l += dch; <br> <br>                hr = lpmsg-&gt;lpVtbl-&gt;OpenAttach (lpmsg, <br>                                            lprws-&gt;aRow[irw].lpProps[ipAttNum].Value.l, <br>                                            NULL, <br>                                            MAPI_MODIFY, <br>                                            &amp;lpatt); <br>                if (!HR_FAILED (hr)) <br>                { <br>                    hr = lpatt-&gt;lpVtbl-&gt;SetProps (lpatt, <br>                                            1, <br>                                            &amp;lprws-&gt;aRow[irw].lpProps[ipAttPos], <br>                                            NULL); <br>                    if (!HR_FAILED (hr)) <br>                    { <br>                        /*  Save out the new positioning */ <br>                         <br>                        hr = lpatt-&gt;lpVtbl-&gt;SaveChanges (lpatt, 0); <br>                         <br>                    } <br>                    UlRelease (lpatt); <br>                    lpatt = NULL; <br>                } <br>                hr = hrSuccess; <br>            } <br> <br>            /*  Free the row data */ <br>             <br>            (*lpsmh-&gt;lpfnFree) (lprws-&gt;aRow[irw].lpProps); <br>        } <br>         <br>        (*lpsmh-&gt;lpfnFree) (lprws); <br>        lprws = NULL; <br>    } <br>    (*lpsmh-&gt;lpfnFree) (lprws); <br>    lprws = NULL; <br> <br>ret: <br>     <br>    UlRelease (lptbl); <br>     <br>    DebugTraceResult (HrOffsetAttachments(), hr); <br>    return hr; <br>} <br> <br> <br>HRESULT <br>HrInsertBody (LPSMH lpsmh, <br>    HWND hwnd, <br>    LPSPropValue lpval, <br>    LPMESSAGE lpmsg) <br>{ <br>    HRESULT hr = hrSuccess; <br>    BOOL fUpdated; <br>    EDITSTREAM es = {0}; <br>    LPSTREAM lpstm = NULL; <br>    LPSTREAM lpstmRTF = NULL; <br>    SPropValue val; <br>    ULONG ulFlags = 0; <br> <br>    /*  Do PR_BODY iff the store is not RTF_AWARE */ <br>     <br>    if ((lpval[ipStoreSupport].ulPropTag != PR_STORE_SUPPORT_MASK) || <br>        !(lpval[ipStoreSupport].Value.l &amp; STORE_RTF_OK)) <br>    { <br>        hr = lpmsg-&gt;lpVtbl-&gt;OpenProperty (lpmsg, <br>                                PR_BODY, <br>                                &amp;IID_IStream, <br>                                0, <br>                                MAPI_CREATE | MAPI_MODIFY, <br>                                (LPUNKNOWN FAR *)&amp;lpstm); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        es.dwCookie = (DWORD)lpstm; <br>        es.pfnCallback = (EDITSTREAMCALLBACK)lpstm-&gt;lpVtbl-&gt;Write; <br>        SendMessage (hwnd, EM_STREAMOUT, SF_TEXT, (LPARAM)&amp;es); <br>        UlRelease (lpstm); <br>        lpstm = NULL; <br> <br>        if (!es.dwError) <br>            ulFlags |= RTF_SYNC_BODY_CHANGED; <br>    } <br> <br>    /*  Add in PR_COMPRESSED_RTF */ <br>     <br>    hr = lpmsg-&gt;lpVtbl-&gt;OpenProperty (lpmsg, <br>                                PR_RTF_COMPRESSED, <br>                                &amp;IID_IStream, <br>                                0, <br>                                MAPI_CREATE | MAPI_MODIFY, <br>                                (LPUNKNOWN FAR *)&amp;lpstm); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br>     <br>    hr = WrapCompressedRTFStream (lpstm, <br>                MAPI_MODIFY | (lpval[ipStoreSupport].Value.l &amp; STORE_UNCOMPRESSED_RTF), <br>                &amp;lpstmRTF); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    es.dwCookie = (DWORD)lpstmRTF; <br>    es.pfnCallback = (EDITSTREAMCALLBACK)lpstmRTF-&gt;lpVtbl-&gt;Write; <br>    SendMessage (hwnd, EM_STREAMOUT, SF_RTF | SFF_PLAINRTF, (LPARAM)&amp;es); <br> <br>    hr = lpstmRTF-&gt;lpVtbl-&gt;Commit (lpstmRTF, 0); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br>     <br>    if (!es.dwError) <br>        ulFlags |= RTF_SYNC_RTF_CHANGED; <br> <br>    /*  Sync the RTF and the body iff the store is not RTF aware */ <br> <br>    if ((lpval[ipStoreSupport].ulPropTag != PR_STORE_SUPPORT_MASK) || <br>        !(lpval[ipStoreSupport].Value.l &amp; STORE_RTF_OK)) <br>    { <br>        /*  We are not aware, so we better do a full sync */ <br>         <br>        hr = RTFSync (lpmsg, ulFlags, &amp;fUpdated); <br>    } <br>    else <br>    { <br>        /*  If we are aware, then we want to tell the <br>         *  store that we are completely in sync.  Otherwise, <br>         *  we could loose our attachment positioning on <br>         *  RTF aware stores.  And that would be bad. <br>         */ <br>        val.ulPropTag = PR_RTF_IN_SYNC; <br>        val.Value.b = TRUE; <br>        lpmsg-&gt;lpVtbl-&gt;SetProps (lpmsg, 1, &amp;val, NULL); <br>    } <br> <br>ret: <br> <br>    UlRelease (lpstm); <br>    UlRelease (lpstmRTF); <br> <br>    DebugTraceResult (HrInsertBody(), hr); <br>    return hr; <br>} <br> <br> <br>HRESULT <br>HrBuildRecipient (LPSMH lpsmh, <br>    LPSPropValue lpval, <br>    LPMESSAGE lpmsg) <br>{ <br>    SCODE sc; <br>    HRESULT hr; <br>    LPADRLIST lpadr = NULL; <br>    LPMAPIPROP lpusr = NULL; <br>    LPSPropValue lpvalUsr = NULL; <br>    LPSPropValue rgval = NULL; <br>    UINT cval = 0; <br>    ULONG ulT; <br> <br>    /*  Open the recipient up */ <br>     <br>    hr = lpsmh-&gt;lpsess-&gt;lpVtbl-&gt;OpenEntry (lpsmh-&gt;lpsess, <br>                            lpval-&gt;Value.bin.cb, <br>                            (LPENTRYID)lpval-&gt;Value.bin.lpb, <br>                            NULL, 0, <br>                            &amp;ulT, <br>                            (LPUNKNOWN FAR *)&amp;lpusr); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Get the properties we need */ <br>     <br>    hr = lpusr-&gt;lpVtbl-&gt;GetProps (lpusr, <br>                            (LPSPropTagArray)&amp;sptUser, <br>                            0, <br>                            &amp;ulT, <br>                            &amp;lpvalUsr); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Allocate the adrlist */ <br>     <br>    if (FAILED (sc = (*lpsmh-&gt;lpfnAlloc) (CbNewADRLIST (1), &amp;lpadr)) || <br>        FAILED (sc = (*lpsmh-&gt;lpfnAlloc) (cpTargetRecipMax * sizeof(SPropValue), &amp;rgval))) <br>    { <br>        hr = ResultFromScode (sc); <br>        goto ret; <br>    } <br> <br>    /*  Stuff the properties and add the recipient */ <br>     <br>    rgval[cval].ulPropTag = PR_ENTRYID; <br>    rgval[cval].Value = lpval-&gt;Value; <br>    cval++; <br> <br>    rgval[cval].ulPropTag = PR_DISPLAY_NAME; <br>    rgval[cval].Value.LPSZ = lpvalUsr[ipDispNm].Value.LPSZ; <br>    cval++; <br>     <br>    if (lpvalUsr[ipAdrTyp].ulPropTag == PR_ADDRTYPE) <br>    { <br>        rgval[cval].ulPropTag = PR_ADDRTYPE; <br>        rgval[cval].Value.LPSZ = lpvalUsr[ipAdrTyp].Value.LPSZ; <br>        cval++; <br>    } <br>     <br>    if (lpvalUsr[ipEmail].ulPropTag == PR_EMAIL_ADDRESS) <br>    { <br>        rgval[cval].ulPropTag = PR_EMAIL_ADDRESS; <br>        rgval[cval].Value.LPSZ = lpvalUsr[ipEmail].Value.LPSZ; <br>        cval++; <br>    } <br> <br>    if (lpvalUsr[ipSKey].ulPropTag == PR_SEARCH_KEY) <br>    { <br>        rgval[cval].ulPropTag = PR_SEARCH_KEY; <br>        rgval[cval].Value = lpvalUsr[ipSKey].Value; <br>        cval++; <br>    } <br>     <br>    rgval[cval].ulPropTag = PR_RECIPIENT_TYPE; <br>    rgval[cval].Value.l = MAPI_TO; <br>    cval++; <br>     <br>    lpadr-&gt;cEntries = 1; <br>    lpadr-&gt;aEntries[0].cValues = cval; <br>    lpadr-&gt;aEntries[0].rgPropVals = rgval; <br>    hr = lpmsg-&gt;lpVtbl-&gt;ModifyRecipients (lpmsg, MODRECIP_ADD, lpadr); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>ret: <br>     <br>    if (lpadr) <br>    { <br>        (*lpsmh-&gt;lpfnFree) (lpadr-&gt;aEntries[0].rgPropVals); <br>        (*lpsmh-&gt;lpfnFree) (lpadr); <br>    } <br>    (*lpsmh-&gt;lpfnFree) (lpvalUsr); <br>    UlRelease (lpusr); <br> <br>    DebugTraceResult (HrBuildRecipient(), hr); <br>    return hr; <br>} <br> <br> <br>HRESULT <br>HrCreateResponse (LPSMH lpsmh, <br>    LPRULE lprl, <br>    LPMAPIFOLDER lpfldr, <br>    LPMESSAGE lpmsgOrig, <br>    LPSPropValue lpval, <br>    LPMESSAGE FAR * lppmsg) <br>{ <br>    SCODE sc; <br>    HRESULT hr; <br>    CHARFORMAT cf = {0}; <br>    HINSTANCE hlib = NULL; <br>    HWND hwnd = NULL; <br>    LONG cch = 0; <br>    LONG cchHdr = 0; <br>    LPBYTE lpbConvIndex = NULL; <br>    LPMESSAGE lpmsg = NULL; <br>    LPREOC lpreoc = NULL; <br>    LPSPropValue rgval = NULL; <br>    PARAFORMAT pf = {0}; <br>    TCHAR rgchClass[MAX_PATH]; <br>    TCHAR rgchSubj[MAX_PATH]; <br>    UINT rop; <br>    ULONG cval = 0; <br> <br>    *lppmsg = NULL; <br>     <br>    /*  Calculate the response operation based on <br>     *  the supplied rule.  If no rule is supplied <br>     *  then the response is an out-of-office msg. <br>     */ <br>    if (lprl) <br>    { <br>        Assert (lprl-&gt;ulFlags &amp; RULE_AUTO_RESPONSE); <br>        if (lprl-&gt;ulFlags &amp; RULE_AUTO_FORWARD) <br>        { <br>            Assert (!(lprl-&gt;ulFlags &amp; RULE_AUTO_REPLY)); <br>            rop = ropForward; <br>        } <br>        else <br>        { <br>            Assert (!(lprl-&gt;ulFlags &amp; RULE_AUTO_FORWARD)); <br>            rop = ropReply; <br>        } <br>    } <br>    else <br>        rop = ropOof; <br> <br>    /*  Create the response message */ <br>     <br>    hr = lpfldr-&gt;lpVtbl-&gt;CreateMessage (lpfldr, NULL, 0, &amp;lpmsg); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Create and initialized the RTF edit control */ <br> <br>    hlib = LoadLibrary (RICHEDIT_LIB); <br>    hwnd = CreateWindow (RICHEDIT_CLASS, <br>                        "", <br>                        WS_BORDER|ES_MULTILINE, <br>                        CW_USEDEFAULT, CW_USEDEFAULT, INT_MAX, INT_MAX, <br>                        NULL, <br>                        NULL, <br>                        lpsmh-&gt;hinst, <br>                        NULL); <br>    if (!hwnd) <br>    { <br>        hr = ResultFromScode (MAPI_E_CALL_FAILED); <br>        goto ret; <br>    } <br> <br>    /*  Create the richedit OLE callback.  If this <br>     *  fails, it is non-fatal.  It just means that <br>     *  any OLE objects in the annotation will not <br>     *  be preserved in then response message. <br>     */ <br>    if (!FAILED (ScNewRicheditCallback (NULL, <br>                        lpsmh-&gt;lpfnAlloc, <br>                        lpsmh-&gt;lpfnAllocMore, <br>                        lpsmh-&gt;lpfnFree, <br>                        &amp;lpreoc))) <br>    { <br>        /*  We have an OLE callback that we need <br>         *  to hand off to the richedit control. <br>         *  Although, the richedit control should <br>         *  be AddRef()ing the object, we will hold <br>         *  our reference until we are through with <br>         *  the edit control. <br>         */ <br>        SendMessage (hwnd, EM_SETOLECALLBACK, 0, (LPARAM)lpreoc); <br>    } <br> <br>    /*  Setup the default character format */ <br>     <br>    cf.cbSize = sizeof(CHARFORMAT); <br>    cf.dwMask = CFM_FACE | CFM_SIZE | CFM_COLOR | CFM_BOLD | <br>                CFM_ITALIC | CFM_UNDERLINE | CFM_STRIKEOUT | <br>                CFM_OFFSET | CFM_CHARSET; <br>    cf.dwEffects = CFE_AUTOCOLOR; <br>    cf.yHeight = 160; <br>    lstrcpy (cf.szFaceName, "MS Sans Serif"); <br>    cf.bCharSet = DEFAULT_CHARSET; <br>    SendMessage (hwnd, EM_SETCHARFORMAT, 0, (LPARAM)&amp;cf); <br> <br>    /*  Copy over the original body if it makes sense to do so */ <br> <br>    if ((rop != ropOof) &amp;&amp; (lprl-&gt;ulFlags &amp; RULE_AUTO_APPEND_ORIG)) <br>    { <br>        hr = HrCopyOriginalBody (lpsmh, hwnd, lpmsgOrig, &amp;cch); <br>        if (HR_FAILED (hr) &amp;&amp; (rop == ropForward)) </code></pre>
<p>
</p>
<pre><code>goto ret; <br>         <br>        hr = hrSuccess; <br>    } <br> <br>    /*  Create and insert the original message header */ <br> <br>    hr = HrInsertOriginalHeader (lpsmh, hwnd, lpval, &amp;cf, &amp;cchHdr); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  If this response is not a forward, we will want to <br>     *  indent the header (and maybe the body) such that they <br>     *  are offset from the annotation. <br>     */ <br>    if (rop != ropForward) <br>    { <br>        /*  Skip indenting the blankline */ <br>         <br>        Edit_SetSel (hwnd, 2, INT_MAX); <br>        pf.cbSize = sizeof(PARAFORMAT); <br>        pf.dwMask = PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_ALIGNMENT | <br>                    PFM_OFFSET | PFM_TABSTOPS | PFM_NUMBERING; <br>        pf.dxOffset = 1440; <br>        pf.cTabCount = 1; <br>        pf.rgxTabs[0] = 1440; <br>        pf.wAlignment = PFA_LEFT; <br>        pf.dxStartIndent = 1440 / 4; <br>        SendMessage (hwnd, EM_SETPARAFORMAT, 0, (LPARAM)&amp;pf); <br>        Edit_SetSel (hwnd, 0, 0); <br>    } <br> <br>    /*  Copy over the annotation */ <br> <br>    hr = HrInsertAnnotation (lpsmh, hwnd, rop, lprl, &amp;cch); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Tag the attachments for replies */ <br> <br>    if (rop == ropReply) <br>    { <br>        hr = HrTagAttachments (lpsmh, hwnd, cchHdr + cch + 3, lpmsgOrig); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br>    } <br> <br>    /*  Allocate space for the new message properties */ <br> <br>    sc = (*lpsmh-&gt;lpfnAlloc) (cpTargetResponseMax * sizeof(SPropValue), &amp;rgval); <br>    if (FAILED (sc)) <br>    { <br>        hr = ResultFromScode (sc); <br>        goto ret; <br>    } <br> <br>    /*  Build the response subject */ <br> <br>    lstrcpy (rgchSubj, rgszSubjPrfx[rop]); <br>    lstrcat (rgchSubj, lpval[ipNSubj].Value.LPSZ); <br>    rgval[cval].ulPropTag = PR_SUBJECT; <br>    rgval[cval].Value.LPSZ = rgchSubj; <br>    cval++; <br> <br>    rgval[cval].ulPropTag = PR_SUBJECT_PREFIX; <br>    rgval[cval].Value.LPSZ = rgszSubjPrfx[rop]; <br>    cval++; <br>         <br>    /*  Build the response message class */ <br> <br>    if (rop == ropOof) <br>        wsprintf (rgchClass, "Report.%s.OOF", lpval[ipMsgClass].Value.LPSZ); <br>    else if (rop == ropReply) <br>        lstrcpy (rgchClass, "IPM.Note.AutoReply"); <br>    else <br>        lstrcpy (rgchClass, lpval[ipMsgClass].Value.LPSZ); <br>    rgval[cval].ulPropTag = PR_MESSAGE_CLASS; <br>    rgval[cval].Value.LPSZ = rgchClass; <br>    cval++; <br> <br>    /*  Compose the set of remaining properties */ <br> <br>    rgval[cval].ulPropTag = PR_DELETE_AFTER_SUBMIT; <br>    rgval[cval].Value.b = TRUE; <br>     <br>#ifdef  DEBUG <br>    rgval[cval].Value.b = GetPrivateProfileInt ("SMH", "DeleteResponses", 1, "MAPIDBG.INI"); <br>#endif <br> <br>    cval++; <br> <br>    /*  Tell the store that the message has not <br>     *  been sent.  Otherwise, since the spooler <br>     *  is the creater of the message, the store <br>     *  will treat the message as if it has been <br>     *  delivered into the store by a transport. <br>     */ <br>    rgval[cval].ulPropTag = PR_MESSAGE_FLAGS; <br>    rgval[cval].Value.l = MSGFLAG_UNSENT; <br>    cval++; <br>     <br>    /*  Create appropriate conversation topic and indexes */ <br>     <br>    if (lpval[ipConvKey].ulPropTag == PR_CONVERSATION_KEY) <br>        rgval[cval++] = lpval[ipConvKey]; <br>    else <br>    { <br>        rgval[cval].ulPropTag = PR_CONVERSATION_TOPIC; <br>        rgval[cval].Value.LPSZ = lpval[ipNSubj].Value.LPSZ; <br>        cval++; <br>    } <br> <br>    if (lpval[ipConvTopic].ulPropTag == PR_CONVERSATION_TOPIC) <br>        rgval[cval++] = lpval[ipConvTopic]; <br>    else <br>    { <br>        rgval[cval].ulPropTag = PR_CONVERSATION_TOPIC; <br>        rgval[cval].Value.LPSZ = lpval[ipNSubj].Value.LPSZ; <br>        cval++; <br>    } <br> <br>    if (lpval[ipConvIndex].ulPropTag == PR_CONVERSATION_INDEX) <br>    { <br>        sc = ScAddConversationIndex (lpval[ipConvIndex].Value.bin.cb, <br>                            lpval[ipConvIndex].Value.bin.lpb, <br>                            &amp;rgval[cval].Value.bin.cb, <br>                            &amp;lpbConvIndex); <br>    } <br>    else <br>    { <br>        sc = ScAddConversationIndex (0, <br>                            NULL, <br>                            &amp;rgval[cval].Value.bin.cb, <br>                            &amp;lpbConvIndex); <br>    } <br>    if (!FAILED (sc)) <br>    { <br>        rgval[cval].ulPropTag = PR_CONVERSATION_INDEX; <br>        rgval[cval].Value.bin.lpb = lpbConvIndex; <br>        cval++; <br>    } <br> <br>    /*  Report tag */ <br>     <br>    if (lpval[ipReportTag].ulPropTag == PR_REPORT_TAG) <br>        rgval[cval++] = lpval[ipReportTag]; <br> <br>    /*  Sensitivity */ <br> <br>    if (lpval[ipSensitivity].ulPropTag == PR_SENSITIVITY) <br>        rgval[cval++] = lpval[ipSensitivity]; <br> <br>    /*  Build response specific properties */ <br>     <br>    if (rop == ropForward) <br>    { <br>        /*  Importance */ <br> <br>        if (lpval[ipImportance].ulPropTag == PR_IMPORTANCE) <br>            rgval[cval++] = lpval[ipImportance]; <br>         <br>        /*  Priority */ <br> <br>        if (lpval[ipOrigPriority].ulPropTag == PR_PRIORITY) <br>            rgval[cval++] = lpval[ipOrigPriority]; <br>         <br>        /*  Original author */ <br> <br>        if (lpval[ipOrigAuthorName].ulPropTag == PR_ORIGINAL_AUTHOR_NAME) <br>            rgval[cval++] = lpval[ipOrigAuthorName]; <br>         <br>        if (lpval[ipOrigAuthorEid].ulPropTag == PR_ORIGINAL_AUTHOR_ENTRYID) <br>            rgval[cval++] = lpval[ipOrigAuthorEid]; <br>         <br>        if (lpval[ipOrigAuthorSKey].ulPropTag == PR_ORIGINAL_AUTHOR_SEARCH_KEY) <br>            rgval[cval++] = lpval[ipOrigAuthorSKey]; <br>         <br>        /*  Original submit time */ <br> <br>        if (lpval[ipOrigSubmitTime].ulPropTag == PR_ORIGINAL_SUBMIT_TIME) <br>            rgval[cval++] = lpval[ipOrigSubmitTime]; <br>    } <br>     <br>    /*  Set the properties */ <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;SetProps (lpmsg, cval, rgval, NULL); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br>     <br>    /*  Insert the body into the mesage directly */ <br> <br>    hr = HrInsertBody (lpsmh, hwnd, lpval, lpmsg); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /*  Copy the attachment across in the case of a forward */ <br>     <br>    if (rop == ropForward) <br>    { <br>        hr = lpmsgOrig-&gt;lpVtbl-&gt;CopyProps(lpmsgOrig, <br>                        (LPSPropTagArray)&amp;sptForward, <br>                        0, <br>                        NULL, <br>                        (LPIID) &amp;IID_IMessage, <br>                        lpmsg, <br>                        0, <br>                        NULL); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        hr = HrOffsetAttachments (lpsmh, cchHdr + cch + 2, lpmsg); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br>    } <br> <br>    /*  Do the recipient */ <br> <br>    hr = HrBuildRecipient (lpsmh, <br>                    (rop == ropForward) <br>                        ? lprl-&gt;lpvalRecip <br>                        : &amp;lpval[ipSndrEid], <br>                    lpmsg); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>ret: <br>     <br>    if (hwnd) <br>        DestroyWindow (hwnd); <br>     <br>    if (HR_FAILED (hr)) <br>    { <br>        UlRelease (lpmsg); <br>        lpmsg = NULL; <br>    } <br>     <br>    if (hlib) <br>        FreeLibrary (hlib); <br> <br>    (*lpsmh-&gt;lpfnFree) (lpbConvIndex); <br>    (*lpsmh-&gt;lpfnFree) (rgval); <br>    UlRelease (lpreoc); <br>     <br>    *lppmsg = lpmsg; <br> <br>    DebugTraceResult (HrCreateResponse(), hr); <br>    return hr; <br>} <br> <br> <br>BOOL <br>FOofRecip (LPOOF lpoof, LPSPropValue lpvalEid) <br>{ <br>    BOOL fOof = TRUE; <br>    LPMAPITABLE lptbl = lpoof-&gt;lptbl; <br>    SPropValue val; <br>    SRestriction res; <br> <br>    if (lptbl) <br>    { <br>#ifdef  DEBUG <br>        if (!GetPrivateProfileInt ("SMH", "OofAlways", 0, "MAPIDBG.INI")) <br>#endif <br>        { <br>            val.ulPropTag = PR_ENTRYID; <br>            val.Value = lpvalEid-&gt;Value; <br> <br>            res.rt = RES_PROPERTY; <br>            res.res.resProperty.relop = RELOP_EQ; <br>            res.res.resProperty.ulPropTag = PR_ENTRYID; <br>            res.res.resProperty.lpProp = &amp;val; <br>            fOof = HR_FAILED (lptbl-&gt;lpVtbl-&gt;FindRow (lptbl, &amp;res, BOOKMARK_BEGINNING, 0L)); <br>        } <br>    } <br>    return fOof; <br>} <br> <br> <br>HRESULT <br>HrRegOofRecip (LPSMH lpsmh, LPOOF lpoof, LPSPropValue lpvalEid) <br>{ <br>    HRESULT hr; <br>    LPTABLEDATA lptad = lpoof-&gt;lptad; <br>    SizedSPropTagArray (cpOofMax, sptOofTbl) = {cpOofMax, { PR_ROWID, PR_ENTRYID }}; <br>    SPropValue rgval[cpOofMax]; <br>    SRow rw; <br> <br>    if (!lptad) <br>    { <br>        //  This is the first OOF recip so we need to create the <br>        //  table of recips <br>        // <br>        hr = ResultFromScode (CreateTable ((LPIID)&amp;IID_IMAPITableData, <br>                            lpsmh-&gt;lpfnAlloc, <br>                            lpsmh-&gt;lpfnAllocMore, <br>                            lpsmh-&gt;lpfnFree, <br>                            NULL, <br>                            TBLTYPE_DYNAMIC, <br>                            PR_ROWID, <br>                            (LPSPropTagArray)&amp;sptOofTbl, <br>                            (LPTABLEDATA FAR *)&amp;lptad)); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br>         <br>        hr = lptad-&gt;lpVtbl-&gt;HrGetView (lptad, NULL, NULL, 0, &amp;lpoof-&gt;lptbl); <br>        if (HR_FAILED (hr)) <br>        { <br>            UlRelease (lptad); <br>            goto ret; <br>        } <br>        lpoof-&gt;lptad = lptad; <br>    } <br> <br>    rgval[ipOofRId].ulPropTag = PR_ROWID; <br>    rgval[ipOofRId].Value.l = lpoof-&gt;cRecips++; <br>    rgval[ipOofREid].ulPropTag = PR_ENTRYID; <br>    rgval[ipOofREid].Value = lpvalEid-&gt;Value; <br>     <br>    rw.cValues = cpOofMax; <br>    rw.lpProps = rgval;  <br>    hr = lptad-&gt;lpVtbl-&gt;HrModifyRow (lptad, &amp;rw); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>ret: <br> <br>    DebugTraceResult (HrRegOofRecip(), hr); <br>    return hr; <br>} <br> <br> <br>HRESULT <br>HrGenerateResponse (LPSMH lpsmh, LPRULE lprl, LPMAPIFOLDER lpfldr, LPMESSAGE lpmsg) <br>{ <br>    HRESULT hr; <br>    LPSPropValue lpval = NULL; <br>    LPMESSAGE lpmsgRep = NULL; <br>    ULONG cval; <br>     <br>    hr = lpmsg-&gt;lpVtbl-&gt;SaveChanges (lpmsg, KEEP_OPEN_READONLY); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br>     <br>    hr = lpmsg-&gt;lpVtbl-&gt;GetProps (lpmsg,  <br>                            (LPSPropTagArray)&amp;sptResponse, <br>                            0, <br>                            &amp;cval, <br>                            &amp;lpval); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = ResultFromScode (MAPI_E_NOT_ME); <br>     <br>    if ((lpval[ipMsgClass].ulPropTag == PR_MESSAGE_CLASS) &amp;&amp; <br>        (lpval[ipMsgClass].Value.LPSZ != NULL) &amp;&amp; <br>        FLpszContainsLpsz (lpval[ipMsgClass].Value.LPSZ, "Report.")) <br>        goto ret; <br> <br>    if ((lpval[ipFlags].ulPropTag == PR_MESSAGE_FLAGS) &amp;&amp; <br>        (lpval[ipFlags].Value.l == MSGFLAG_FROMME)) <br>        goto ret; <br> <br>    /*  If there is no rule, then we must be OOF'ing */ <br>    if (!lprl &amp;&amp; !FOofRecip (&amp;lpsmh-&gt;oof, &amp;lpval[ipSndrEid])) <br>        goto ret; <br> <br>    if ((lpval[ipRecipMe].ulPropTag == PR_MESSAGE_RECIP_ME) &amp;&amp; <br>        (lpval[ipRecipMe].Value.b)) <br>    { <br>        DebugTrace ("SMH: generating response message\n"); <br>         <br>        if (!lprl) <br>        { <br>            /*  Register the OOF recipient */ <br>             <br>            hr = HrRegOofRecip (lpsmh, &amp;lpsmh-&gt;oof, &amp;lpval[ipSndrEid]); <br>            if (HR_FAILED (hr)) <br>                goto ret; <br>        } <br> <br>        /*  Create the response and submit it */ <br>         <br>        hr = HrCreateResponse (lpsmh, <br>                        lprl, <br>                        lpfldr, <br>                        lpmsg, <br>                        lpval, <br>                        &amp;lpmsgRep); <br>        if (!HR_FAILED (hr)) <br>            hr = lpmsgRep-&gt;lpVtbl-&gt;SubmitMessage (lpmsgRep, 0); <br>         <br>        UlRelease (lpmsgRep); <br>    } <br> <br>ret: <br> <br>    (*lpsmh-&gt;lpfnFree) (lpval); <br>    DebugTraceResult (HrGenerateResponse(), hr); <br>    return hr; <br>} <br> <br> <br>HRESULT <br>HrInitOof (LPSMH lpsmh, LPSPropValue lpvalAnno, LPSPropValue lpvalRTF) <br>{ <br>    SCODE sc = MAPI_E_UNCONFIGURED; <br> <br>    if (lpvalRTF-&gt;ulPropTag == PR_SMH_OOF_RTF) <br>    { <br>        if (!FAILED (sc = (*lpsmh-&gt;lpfnAlloc) (lpvalRTF-&gt;Value.bin.cb, <br>                                    (LPVOID FAR *)&amp;lpsmh-&gt;oof.lpbRTF))) <br>        { <br>            lpsmh-&gt;oof.cbRTF = lpvalRTF-&gt;Value.bin.cb; <br>            memcpy (lpsmh-&gt;oof.lpbRTF, <br>                lpvalRTF-&gt;Value.bin.lpb, <br>                (UINT)lpvalRTF-&gt;Value.bin.cb); <br>        } <br>    } <br>    if (lpvalAnno-&gt;ulPropTag == PR_SMH_OOF_TEXT) <br>    { <br>        if (!FAILED (sc = (*lpsmh-&gt;lpfnAlloc) (lstrlen (lpvalAnno-&gt;Value.LPSZ) + sizeof(TCHAR), <br>                                    (LPVOID FAR *)&amp;lpsmh-&gt;oof.lpszBody))) <br>            lstrcpy (lpsmh-&gt;oof.lpszBody, lpvalAnno-&gt;Value.LPSZ); <br>    } <br> <br>    DebugTraceSc (HrInitOof(), sc); <br>    return ResultFromScode (sc); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
