<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHMDB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2132"></a>SMHMDB.C</h2>
<pre><code>/* <br> *  S M H M D B . C <br> * <br> *  Sample mail handling hook <br> *  Store Tables <br> * <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br> <br> <br>/* <br> *  sptStoTbl <br> * <br> *  The store table column set and enum <br> */ <br>enum { ipNull, ipEid, ipDispNm, ipRsrcFlags, cpStoTblMax }; <br>static const SizedSPropTagArray (cpStoTblMax, sptStoTbl) = <br>{ <br>    cpStoTblMax, <br>    { <br>        PR_NULL, <br>        PR_ENTRYID, <br>        PR_DISPLAY_NAME_A, <br>        PR_RESOURCE_FLAGS <br>    } <br>}; <br> <br> <br>/* <br> *  HrInitStoresTable() <br> * <br> *  Purpose: <br> * <br> *      Inits the stores table stucture and adds a reference to the SMH <br> *      parent object.  This is done by getting the message stores table <br> *      from the MAPI session and querying all rows (up to cStoMax) and <br> *      mapping the return to an LPSTOTABLE structure. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           the SMH parent object <br> *      lpsess          the MAPI session that this SMH instance belongs to <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrInitStoresTable (LPSMH lpsmh, LPMAPISESSION lpsess) <br>{ <br>    HRESULT hr; <br>    LPMAPITABLE lptbl; <br>    LPSRowSet lprws = NULL; <br>    LPSTOTABLE lpstotbl; <br>    UINT i; <br> <br>    Assert (lpsmh-&gt;lpstotbl == NULL); <br>    hr = lpsess-&gt;lpVtbl-&gt;GetMsgStoresTable (lpsess, 0, &amp;lptbl); <br>    if (!HR_FAILED (hr)) <br>    { <br>        hr = lptbl-&gt;lpVtbl-&gt;SetColumns (lptbl, (LPSPropTagArray)&amp;sptStoTbl, 0); <br>        if (!HR_FAILED (hr)) <br>        { <br>            hr = lptbl-&gt;lpVtbl-&gt;QueryRows (lptbl, cStoMax, 0, &amp;lprws); <br>            if (!HR_FAILED (hr)) <br>            { <br>                /*  Zero fill the initial property in all rows. <br>                 *  This has the nice side effect of NULL'ing the <br>                 *  lpmdb member of the structure <br>                 */ <br>                lpstotbl = (LPSTOTABLE)lprws; <br>                for (i = 0; i &lt; lpstotbl-&gt;cSto; i++) <br>                    memset (&amp;lpstotbl-&gt;aSto[i].lpstoe-&gt;valPad, <br>                        0, sizeof(SPropValue)); <br> <br>                lpsmh-&gt;lpstotbl = lpstotbl; <br>            } <br>        } <br>        UlRelease (lptbl); <br>    } <br> <br>    DebugTraceResult (HrInitStoresTable(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  ReleaseStoresTable() <br> * <br> *  Purpose: <br> * <br> *      Releases all resources owned by the store table and disconnects <br> *      the SMH parent from the table. <br> * <br> *  Arguments: <br> * <br> *      lpsmh       the SMH parent object <br> */ <br>VOID <br>ReleaseStoresTable (LPSMH lpsmh) <br>{ <br>    LPSTOTABLE lpstotbl = lpsmh-&gt;lpstotbl; <br>    UINT i; <br> <br>    if (lpstotbl) <br>    { <br>        for (i = 0; i &lt; lpstotbl-&gt;cSto; i++) <br>        { <br>            UlRelease (lpstotbl-&gt;aSto[i].lpstoe-&gt;lpmdb); <br>            (*lpsmh-&gt;lpfnFree) (lpstotbl-&gt;aSto[i].lpProps); <br>        } <br>        (*lpsmh-&gt;lpfnFree) (lpstotbl); <br>        lpsmh-&gt;lpstotbl = NULL; <br>    } <br>    return; <br>} <br> <br> <br>/* <br> *  HrOpenStoEntry() <br> * <br> *  Purpose: <br> * <br> *      Opens the store associated with a stoenty in the stores table. <br> * <br> *      IMPORTANT: the caller does not end up owning the store reference <br> *      and should NOT call Release() on the store unless they also call <br> *      AddRef().  The referece is owned by the stores table and is <br> *      released upon the tables destruction. <br> * <br> *  Arguments: <br> * <br> *      lpsess          the MAPI session object <br> *      lpsto           the STO structure for the MDB to open <br> *      lppmdb  [OUT]   contains the LPMDB iff the call succeeds <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrOpenStoEntry (LPMAPISESSION lpsess, LPSTO lpsto, LPMDB FAR * lppmdb) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMDB lpmdb = NULL; <br> <br>    if (!lpsto-&gt;lpstoe-&gt;lpmdb) <br>    { <br>        hr = lpsess-&gt;lpVtbl-&gt;OpenMsgStore (lpsess, <br>                                0, <br>                                lpsto-&gt;lpProps[ipEid].Value.bin.cb, <br>                                (LPENTRYID)lpsto-&gt;lpProps[ipEid].Value.bin.lpb, <br>                                NULL, <br>                                MDB_WRITE | MDB_NO_DIALOG | MDB_NO_MAIL, <br>                                &amp;lpmdb); <br>        if (!HR_FAILED (hr)) <br>            lpsto-&gt;lpstoe-&gt;lpmdb = lpmdb; <br>         <br>        *lppmdb = lpmdb; <br>    } <br>    else <br>    { <br>        *lppmdb = lpsto-&gt;lpstoe-&gt;lpmdb; <br>    } <br> <br>    DebugTraceResult (HrOpenStoEntry(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  HrOpenMdbFromEid() <br> * <br> *  Purpose: <br> * <br> *      Opens a message store by entryid.  The entryid is looked up in <br> *      the stores table to find the proper STOENTRY.  If no entry is <br> *      found, then the store is not opened.  If one is found, then the <br> *      MDB is retrieved from the STOENTRY.  If it has not yet been opened, <br> *      the MDB is opened at this time and stored (no pun intended). <br> * <br> *      IMPORTANT: the caller does not end up owning the store reference <br> *      and should NOT call Release() on the store unless they also call <br> *      AddRef().  The referece is owned by the stores table and is <br> *      released upon the tables destruction. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           the SMH parent object <br> *      cbeid           size of the stores entryid <br> *      lpeid           the entryid to be opened <br> *      lppmdb  [OUT]   contains the LPMDB iff the call succeeds <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrOpenMdbFromEid (LPSMH lpsmh, ULONG cbeid, LPENTRYID lpeid, LPMDB FAR * lppmdb) <br>{ <br>    HRESULT hr = ResultFromScode (MAPI_E_NOT_FOUND); <br>    LPSTOTABLE lpstotbl = lpsmh-&gt;lpstotbl; <br>    UINT i; <br> <br>    if (lpstotbl) <br>    { <br>        for (i = 0; i &lt; lpstotbl-&gt;cSto; i++) <br>        { <br>            if ((cbeid == lpstotbl-&gt;aSto[i].lpProps[ipEid].Value.bin.cb) &amp;&amp; <br>                !memcmp (lpeid, lpstotbl-&gt;aSto[i].lpProps[ipEid].Value.bin.lpb, (UINT)cbeid)) <br>            { <br>                if (lpstotbl-&gt;aSto[i].lpstoe-&gt;lpmdb) <br>                { <br>                    *lppmdb = lpstotbl-&gt;aSto[i].lpstoe-&gt;lpmdb; <br>                    hr = hrSuccess; <br>                } <br>                else <br>                    hr = HrOpenStoEntry (lpsmh-&gt;lpsess, &amp;lpstotbl-&gt;aSto[i], lppmdb); <br> <br>                break; <br>            } <br>        } <br>    } <br> <br>    if (HR_FAILED (hr)) <br>        *lppmdb = NULL; <br> <br>    DebugTraceResult (HrOpenMdbFromEid(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  HrOpenMdbFromName() <br> * <br> *  Purpose: <br> * <br> *      Opens a message store by PR_DISPLAY_NAME value.  The name is <br> *      looked up in the stores table to find the proper STOENTRY.  If no <br> *      entry is found, then the store is not opened.  If one is found, <br> *      then the MDB is retrieved from the STOENTRY.  If it has not yet <br> *      been opened, the MDB is opened at this time and stored (no pun <br> *      intended). <br> * <br> *      IMPORTANT: the caller does not end up owning the store reference <br> *      and should NOT call Release() on the store unless they also call <br> *      AddRef().  The referece is owned by the stores table and is <br> *      released upon the tables destruction. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           the SMH parent object <br> *      lpszName        the name of the store to open <br> *      lppmdb  [OUT]   contains the LPMDB iff the call succeeds <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrOpenMdbFromName (LPSMH lpsmh, LPTSTR lpszName, LPMDB FAR * lppmdb) <br>{ <br>    HRESULT hr = ResultFromScode (MAPI_E_NOT_FOUND); <br>    LPSTOTABLE lpstotbl = lpsmh-&gt;lpstotbl; <br>    UINT i; <br> <br>    if (lpstotbl) <br>    { <br>        for (i = 0; i &lt; lpstotbl-&gt;cSto; i++) <br>        { <br>            if (!lstrcmpi (lpszName, lpstotbl-&gt;aSto[i].lpProps[ipDispNm].Value.LPSZ)) <br>            { <br>                if (lpstotbl-&gt;aSto[i].lpstoe-&gt;lpmdb) <br>                { <br>                    *lppmdb = lpstotbl-&gt;aSto[i].lpstoe-&gt;lpmdb; <br>                    hr = hrSuccess; <br>                } <br>                else <br>                    hr = HrOpenStoEntry (lpsmh-&gt;lpsess, &amp;lpstotbl-&gt;aSto[i], lppmdb); <br> <br>                break; <br>            } <br>        } <br>    } <br> <br>    if (HR_FAILED (hr)) <br>        *lppmdb = NULL; <br> <br>    DebugTraceResult (HrOpenMdbFromEid(), hr); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
