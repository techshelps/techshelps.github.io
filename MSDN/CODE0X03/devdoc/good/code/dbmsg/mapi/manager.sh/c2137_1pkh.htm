<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHWIZ.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2141"></a>SMHWIZ.C</h2>
<pre><code>/* <br> *  S M H W I Z . C <br> * <br> *  Sample mail handling hook configuration wizard <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br> <br>extern SPropTagArray sptConfigProps; <br> <br>/* <br> *  Wizard global and external variables <br> */ <br>static LPMAPIPROP lpmpWiz = NULL; <br>static LPSPropValue lpvalWiz = NULL; <br>static UINT ipgCur = (UINT)(-1); <br> <br>/* <br> *  MAPI Initialization structure. <br> * <br> *  By initializing MAPI, the wizard can allocate and/or free memory <br> *  using MAPIAllocateBuffer(), MAPIAllocateMore(), and MAPIFreeBuffer() <br> */ <br>static const MAPIINIT mapiinit = { MAPI_INIT_VERSION, 0 }; <br> <br>/* Wizard page enumeration */ <br> <br>enum {ipgSentMail, ipgDeleted, ipgInbound, ipgUnread, cpgMax}; <br> <br> <br>/* <br> *  TogglePage() <br> * <br> *  Purpose: <br> * <br> *      Toggles the state of the current page to be either enabled and <br> *      visible or disabled and hidden. <br> * <br> *      IMPORTANT: This function relies on the dialog control IDs as <br> *      defined in _SMH.RH.  Each page exists in a certain range and all <br> *      controls in each page must have contiguous IDs starting at the <br> *      page ID value. <br> * <br> *  Arguments: <br> * <br> *      hdlg            the dialog <br> *      ipg             the page index (0 - cpgMax) <br> *      fEnable         boolean used to either enable for disable the page <br> */ <br>VOID <br>TogglePage (HWND hdlg, UINT ipg, BOOL fEnable) <br>{ <br>    UINT ictl = 0; <br>    HANDLE hctl; <br> <br>    if (ipg &gt;= cpgMax) <br>        return; <br> <br>    while (hctl = GetDlgItem (hdlg, (WIZ_BASE + (ipg * PAGE_INC) + ictl++))) <br>    { <br>        EnableWindow (hctl, fEnable); <br>        ShowWindow (hctl, (fEnable ? SW_SHOW : SW_HIDE)); <br>    } <br>} <br> <br> <br>/* <br> *  EnablePage() <br> * <br> *  Purpose: <br> * <br> *      Toggles the state of the current page controls to be either <br> *      enabled or disabled. <br> * <br> *      IMPORTANT: This function relies on the dialog control IDs as <br> *      defined in _SMH.RH.  Each page exists in a certain range and all <br> *      controls in each page must have contiguous IDs starting at the <br> *      page ID value. <br> * <br> *  Arguments: <br> * <br> *      hdlg            the dialog <br> *      ipg             the page index (0 - cpgMax) <br> *      fEnable         boolean used to either enable for disable the page <br> */ <br>VOID <br>EnablePage (HWND hdlg, UINT ipg, BOOL fEnable) <br>{ <br>    UINT ictl = 0; <br>    HANDLE hctl; <br> <br>    if (ipg &gt;= cpgMax) <br>        return; <br> <br>    while (hctl = GetDlgItem (hdlg, (WIZ_BASE + (ipg * PAGE_INC) + ictl++))) <br>        EnableWindow (hctl, fEnable); <br>} <br> <br> <br>/* <br> *  ShowPage() <br> * <br> *  Purpose: <br> * <br> *      Toggles the state of the current page controls to be either <br> *      visible or hidden. <br> * <br> *      IMPORTANT: This function relies on the dialog control IDs as <br> *      defined in _SMH.RH.  Each page exists in a certain range and all <br> *      controls in each page must have contiguous IDs starting at the <br> *      page ID value. <br> * <br> *  Arguments: <br> * <br> *      hdlg            the dialog <br> *      ipg             the page index (0 - cpgMax) <br> *      fEnable         boolean used to either show or hide the page <br> */ <br>VOID <br>ShowPage (HWND hdlg, UINT ipg, BOOL fEnable) <br>{ <br>    UINT ictl = 0; <br>    HANDLE hctl; <br> <br>    if (ipg &gt;= cpgMax) <br>        return; <br> <br>    while (hctl = GetDlgItem (hdlg, (WIZ_BASE + (ipg * PAGE_INC) + ictl++))) <br>        ShowWindow (hctl, (fEnable ? SW_SHOW : SW_HIDE)); <br>} <br> <br> <br>/* <br> *  WizardPage_INITDIALOG() <br> * <br> *  Purpose: <br> * <br> *      Responds to the WM_INITDIALOG message. <br> * <br> *  Returns: <br> * <br> *      TRUE iff the initialization was successful <br> */ <br>BOOL <br>WizardPage_INITDIALOG (HWND hdlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    ULONG cval; <br>    ULONG ulFlags; <br> <br>    if (!FAILED (MAPIInitialize ((LPMAPIINIT)&amp;mapiinit)) &amp;&amp; <br>        !HR_FAILED (lpmpWiz-&gt;lpVtbl-&gt;GetProps (lpmpWiz, <br>                                        (LPSPropTagArray)&amp;sptConfigProps, <br>                                        0, <br>                                        &amp;cval, <br>                                        &amp;lpvalWiz))) <br>    { <br>        ulFlags = (lpvalWiz[ipFlags].ulPropTag == PR_SMH_FLAGS) <br>            ? lpvalWiz[ipFlags].Value.l <br>            : 0; <br> <br>        CheckDlgButton (hdlg, ID_SentMail, !!(ulFlags &amp; SMH_FILTER_SENTMAIL)); <br>        CheckDlgButton (hdlg, ID_SentMailYr, !!(ulFlags &amp; SMH_FILTER_SENTMAIL_YR)); <br>        CheckDlgButton (hdlg, ID_Deleted, !!(ulFlags &amp; SMH_FILTER_DELETED)); <br>        CheckDlgButton (hdlg, ID_DeletedYr, !!(ulFlags &amp; SMH_FILTER_DELETED_YR)); <br>        CheckDlgButton (hdlg, ID_Inbound, !!(ulFlags &amp; SMH_FILTER_INBOUND)); <br>        CheckDlgButton (hdlg, ID_Unread, !!(ulFlags &amp; SMH_UNREAD_VIEWER)); <br>        lpvalWiz[ipFlags].ulPropTag = PR_SMH_FLAGS; <br>        lpvalWiz[ipFlags].Value.l = ulFlags; <br>        DebugTrace ("SMH: wizard initialized\n"); <br>        return TRUE; <br>    } <br>    else <br>    { <br>        DebugTrace ("SMH: wizard initializion failed\n"); <br>        return FALSE; <br>    } <br>} <br> <br> <br>/* <br> *  WizardPage_COMMAND() <br> * <br> *  Purpose: <br> * <br> *      Responds to the WM_COMMAND message. <br> * <br> *      IMPORTANT: This function relies on the dialog control IDs as <br> *      defined in _SMH.RH.  Each page exists in a certain range and all <br> *      controls in each page must have contiguous IDs starting at the <br> *      page ID value. <br> * <br> *  Returns: <br> * <br> *      TRUE iff the command was processed by the wizard page <br> */ <br>BOOL <br>WizardPage_COMMAND (HWND hdlg, UINT id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    UINT cpgJmp = 1; <br> <br>    switch (id) <br>    { <br>      case ID_SentMail: <br>      case ID_Deleted: <br> <br>        /* Check/uncheck the companion checkbox */ <br> <br>        EnableWindow (GetDlgItem (hdlg, id + 1), !!IsDlgButtonChecked (hdlg, id)); <br>        break; <br> <br>      case WIZ_PREV: <br> <br>        cpgJmp = (UINT)(-((INT)cpgJmp)); <br> <br>        /* Fall through! */ <br> <br>      case WIZ_NEXT: <br> <br>        DebugTrace ("SMH: PREV/NEXT'd from pg %d to pg %d\n", ipgCur, ipgCur + cpgJmp); <br> <br>        /* Disable/hide the current page and enable target page */ <br>        TogglePage (hdlg, ipgCur, FALSE); <br>        EnablePage (hdlg, ipgCur += cpgJmp, TRUE); <br> <br>        switch (ipgCur) <br>        { <br>          case ipgSentMail: <br> <br>            EnableWindow (GetDlgItem (hdlg, ID_SentMailYr), <br>                !!IsDlgButtonChecked (hdlg, ID_SentMail)); <br>            break; <br> <br>          case ipgDeleted: <br> <br>            EnableWindow (GetDlgItem (hdlg, ID_DeletedYr), <br>                !!IsDlgButtonChecked (hdlg, ID_Deleted)); <br>            break; <br> <br>          case ipgInbound: <br>          case ipgUnread: <br> <br>            break; <br> <br>          case cpgMax: <br> <br>            if (IsDlgButtonChecked (hdlg, ID_SentMail)) <br>            { <br>                lpvalWiz[ipFlags].Value.l |= SMH_FILTER_SENTMAIL; <br>                if (IsDlgButtonChecked (hdlg, ID_SentMailYr)) <br>                    lpvalWiz[ipFlags].Value.l |= SMH_FILTER_SENTMAIL_YR; <br>                else <br>                    lpvalWiz[ipFlags].Value.l &amp;= ~SMH_FILTER_SENTMAIL_YR; <br>            } <br>            else <br>                lpvalWiz[ipFlags].Value.l &amp;= ~(SMH_FILTER_SENTMAIL | SMH_FILTER_SENTMAIL_YR); <br> <br>            if (IsDlgButtonChecked (hdlg, ID_Deleted)) <br>            { <br>                lpvalWiz[ipFlags].Value.l |= SMH_FILTER_DELETED; <br>                if (IsDlgButtonChecked (hdlg, ID_DeletedYr)) <br>                    lpvalWiz[ipFlags].Value.l |= SMH_FILTER_DELETED_YR; <br>                else <br>                    lpvalWiz[ipFlags].Value.l &amp;= ~SMH_FILTER_DELETED_YR; <br>            } <br>            else <br>                lpvalWiz[ipFlags].Value.l &amp;= ~(SMH_FILTER_DELETED | SMH_FILTER_DELETED_YR); <br> <br>            if (IsDlgButtonChecked (hdlg, ID_Inbound)) <br>                lpvalWiz[ipFlags].Value.l |= SMH_FILTER_INBOUND; <br>            else <br>                lpvalWiz[ipFlags].Value.l &amp;= ~SMH_FILTER_INBOUND; <br> <br>            if (IsDlgButtonChecked (hdlg, ID_Unread)) <br>                lpvalWiz[ipFlags].Value.l |= SMH_UNREAD_VIEWER; <br>            else <br>                lpvalWiz[ipFlags].Value.l &amp;= ~SMH_UNREAD_VIEWER; <br> <br>            lpmpWiz-&gt;lpVtbl-&gt;SetProps (lpmpWiz, cpMax, lpvalWiz, NULL); <br>            lpmpWiz-&gt;lpVtbl-&gt;SaveChanges (lpmpWiz, KEEP_OPEN_READWRITE); <br>            break; <br>        } <br> <br>        /* Unhide the target page */ <br> <br>        ShowPage (hdlg, ipgCur, TRUE); <br>        return (BOOL)cpgJmp; <br> <br>      default: <br> <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/* <br> *  SMH_WizProc() <br> * <br> *  Purpose: <br> * <br> *      The wizard page dialog proceedure. <br> * <br> *  Arguments: <br> * <br> *      hdlg        the dialog <br> *      wMsgID      the message <br> *      wParam <br> *      lParam <br> */ <br>BOOL STDAPICALLTYPE <br>SMH_WizProc (HWND hdlg, <br>    UINT wMsgID, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    //static UINT ipgCur = (UINT)(-1); <br>    static LPSPropValue lpval = NULL; <br> <br>    switch (wMsgID) <br>    { <br>      case WM_INITDIALOG: <br> <br>        return (BOOL)FHandleWm (WizardPage, hdlg, INITDIALOG, wParam, lParam); <br> <br>      case WIZ_QUERYNUMPAGES: <br> <br>        DebugTrace ("SMH: wizard page count %d\n", cpgMax); <br>        return (BOOL)cpgMax; <br> <br>      case WM_CLOSE: <br> <br>        DebugTrace ("SMH: wizard closed\n"); <br> <br>        ipgCur = (UINT)(-1); <br>        MAPIFreeBuffer (lpvalWiz); <br>        MAPIUninitialize (); <br>        lpvalWiz = NULL; <br> <br>        UlRelease (lpmpWiz); <br>        lpmpWiz = NULL; <br>        break; <br> <br>      case WM_COMMAND: <br> <br>        return (BOOL)FHandleWm (WizardPage, hdlg, COMMAND, wParam, lParam); <br> <br>      default: <br> <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/* <br> *  WizardEntry() <br> * <br> *  Purpose: <br> * <br> *      This is the initial entrypoint for the MAPI 1.0 configuration <br> *      wizard.  This function tells the wizard DLL how many pages the <br> *      configuration for this service requires as well as the dialog <br> *      procedure to call for each individual event. <br> * <br> *  Arguments: <br> * <br> *      hInstance       the instance of my dll, this can be used to <br> *                      retrieve resources out of my DLL, etc. <br> * <br> *      lpszRsrcName    [OUT]   on return, this buffer is filled with <br> *                              the full name of the dialog resource ID. <br> *                              Note that this requires the name to be a <br> *                              text value and not something generated <br> *                              with the MAKEINTRESOURCE() macro <br> * <br> *      lpfnDlgProc     [OUT]   on return, holds a function pointer to <br> *                              the dialog proc to call for each event <br> * <br> *      lpMapiProp      the pointer to a IMAPIProp object that is my <br> *                      interface to the profile. <br> * <br> *  Returns: <br> * <br> *      (SCODE)         S_OK <br> */ <br>ULONG STDAPICALLTYPE <br>SMH_WizEntry (HINSTANCE hInstance, <br>    LPTSTR FAR * lppszRsrcName, <br>    DLGPROC FAR * lpfnDlgProc, <br>    LPMAPIPROP lpMapiProp, <br>    LPVOID lpsup) <br>{ <br>    Unreferenced (lpsup); <br>     <br>    /*  Stash the MAPIPROP object in global for use in the <br>     *  configuration wizard <br>     */ <br>    lpmpWiz = lpMapiProp; <br>    UlAddRef (lpmpWiz); <br> <br>    /*  tell the configuration wizard the dialog template name <br>     *  and the window proceedure to use <br>     */ <br>    *lppszRsrcName = (LPTSTR)szWizardDialog; <br>    *lpfnDlgProc = (DLGPROC)SMH_WizProc; <br> <br>    return S_OK; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
