<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMHARC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2127"></a>SMHARC.C</h2>
<pre><code>/* <br> *  S M H A R C . C <br> * <br> *  Sample mail handling message archiving <br> *  Copyright 1992-95 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "_pch.h" <br> <br>/* <br> *  FIsLeapYear() <br> * <br> *  Used to calculate leap years when determining month ranges for <br> *  archive folders. <br> */ <br>#define FIsLeapYear(_yr) ((!((_yr) % 400) || ((_yr) % 100) &amp;&amp; !((_yr) % 4)) ? TRUE : FALSE) <br> <br>/* <br> *  sptMsgDates <br> * <br> *  The list of properties that are used for archiving.  If <br> *  PR_MESSAGE_DELIVERY_TIME is not available, then SMH will use <br> *  PR_CLIENT_SUBMIT_TIME. <br> */ <br>const static SizedSPropTagArray(2, sptMsgDates) = <br>{ <br>    2, <br>    { <br>        PR_MESSAGE_DELIVERY_TIME, <br>        PR_CLIENT_SUBMIT_TIME <br>    } <br>}; <br> <br>/* <br> *  sptFldrDates <br> * <br> *  Theses properties describe the range of dates that an archive folder <br> *  with the returned EntryID will support.  This is used in the call to <br> *  find a supporting sub-folder. <br> */ <br>const static SizedSPropTagArray (3, sptFldrDates) = <br>{ <br>    3, <br>    { <br>        PR_START_DATE, <br>        PR_END_DATE, <br>        PR_ENTRYID <br>    } <br>}; <br> <br>/* <br> *  rgtstrMonth <br> *  rgtstrMonthFull <br> *  rgwDaysPerMonth <br> * <br> *  These arrays are used in the calculation and creation of supporting <br> *  archive folders. <br> */ <br>const static TCHAR FAR * rgtstrMonth[] = <br>{ <br>    TEXT ("Jan"), <br>    TEXT ("Feb"), <br>    TEXT ("Mar"), <br>    TEXT ("Apr"), <br>    TEXT ("May"), <br>    TEXT ("Jun"), <br>    TEXT ("Jul"), <br>    TEXT ("Aug"), <br>    TEXT ("Sep"), <br>    TEXT ("Oct"), <br>    TEXT ("Nov"), <br>    TEXT ("Dec") <br>}; <br>const TCHAR FAR * rgtstrMonthFull[] = <br>{ <br>    TEXT ("January"), <br>    TEXT ("February"), <br>    TEXT ("March"), <br>    TEXT ("April"), <br>    TEXT ("May"), <br>    TEXT ("June"), <br>    TEXT ("July"), <br>    TEXT ("August"), <br>    TEXT ("September"), <br>    TEXT ("October"), <br>    TEXT ("November"), <br>    TEXT ("December") <br>}; <br>const static WORD rgwDaysPerMonth[] = <br>{ <br>    31, //  JAN <br>    28, //  FEB <br>    31, //  MAR <br>    30, //  APR <br>    31, //  MAY <br>    30, //  JUN <br>    31, //  JUL <br>    31, //  AUG <br>    30, //  SEP <br>    31, //  OCT <br>    30, //  NOV <br>    31  //  DEC <br>}; <br> <br> <br>/* <br> *  HrCacheFolder() <br> * <br> *  Purpose: <br> * <br> *      Caches the passed in entryid along with a matching folder <br> * <br> *  Arguments: <br> * <br> *      lpsmh       pointer to the sentmail handler <br> *      cbeid       count of bytes for the entryid to check <br> *      lpeid       data for the entryid to check <br> *      lpcbeid     points to the cached entryid size <br> *      lppeid      points to the cached entryid data <br> *      lppfldr     points to the cached mapi folder object <br> *      lpfUpdated  points to cache update flag <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> *      lpcbeid     [OUT] size of newly cached entryid <br> *      lppeid      [OUT] data of newly cached entryid <br> *      lppfldr     [OUT] folder corresponding to cached entryid <br> *      lpfUpdated  [OUT] TRUE iff the out folder is not the <br> *                          previously cached folder <br> */ <br>HRESULT <br>HrCacheFolder (LPSMH lpsmh, <br>    LPMDB lpmdbPref, <br>    ULONG cbeid, <br>    LPENTRYID lpeid, <br>    ULONG FAR * lpcbeid, <br>    LPENTRYID FAR * lppeid, <br>    LPMAPIFOLDER FAR * lppfldr, <br>    BOOL far * lpfUpdated) <br>{ <br>    HRESULT hr; <br>    ULONG ulType; <br>    ULONG ulMatch; <br>    LPMAPIPROP lpmp = NULL; <br> <br>    /* Init the update flag */ <br> <br>    *lpfUpdated = FALSE; <br> <br>    /*  Is the topmost sent mail folder the same folder <br>     *  as the last filtered message? <br>     */ <br>    hr = lpsmh-&gt;lpsess-&gt;lpVtbl-&gt;CompareEntryIDs (lpsmh-&gt;lpsess, <br>                                        cbeid, <br>                                        lpeid, <br>                                        *lpcbeid, <br>                                        *lppeid, <br>                                        0, <br>                                        &amp;ulMatch); <br>    if (HR_FAILED (hr) || !ulMatch) <br>    { <br>        /* Different folder, guess we better toss the cached one */ <br> <br>        (*lpsmh-&gt;lpfnFree) (*lppeid); <br>        *lppeid = NULL; <br>        *lpcbeid = 0; <br> <br>        /* Cache the SentMail */ <br> <br>        hr = ResultFromScode ((*lpsmh-&gt;lpfnAlloc) (cbeid, lppeid)); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br>        memcpy (*lppeid, lpeid, (UINT)cbeid); <br>        *lpcbeid = cbeid; <br>        *lpfUpdated = TRUE; <br>    } <br>    else if (*lppfldr) <br>        return hrSuccess; <br> <br>    /* Open the new folder, but try the preferred store first */ <br> <br>    hr = lpmdbPref-&gt;lpVtbl-&gt;OpenEntry (lpmdbPref, <br>                                        cbeid, <br>                                        lpeid, <br>                                        NULL, <br>                                        MAPI_BEST_ACCESS, <br>                                        &amp;ulType, <br>                                        (LPUNKNOWN FAR *)&amp;lpmp); <br>    if (HR_FAILED (hr)) <br>    { <br>        /* Try the MAPI session now and see if we can get the folder */ <br>         <br>        hr = lpsmh-&gt;lpsess-&gt;lpVtbl-&gt;OpenEntry (lpsmh-&gt;lpsess, <br>                                        cbeid, <br>                                        lpeid, <br>                                        NULL, <br>                                        MAPI_BEST_ACCESS, <br>                                        &amp;ulType, <br>                                        (LPUNKNOWN FAR *)&amp;lpmp); <br>    } <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    if (ulType != MAPI_FOLDER) <br>    { <br>        hr = ResultFromScode (MAPI_E_UNEXPECTED_TYPE); <br>        goto ret; <br>    } <br> <br>ret: <br> <br>    if (HR_FAILED (hr)) <br>    { <br>        UlRelease (lpmp); <br>        (*lpsmh-&gt;lpfnFree) (*lppeid); <br>        *lppeid = NULL; <br>        *lpcbeid = 0; <br>        lpmp = NULL; <br>    } <br> <br>    UlRelease (*lppfldr); <br>    *lppfldr = (LPMAPIFOLDER)lpmp; <br> <br>    DebugTraceResult (HrCacheFolder(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  HrCreateHashedFolder() <br> * <br> *  Purpose: <br> * <br> *      Create/Caches the a folder that satisfies the hash value <br> * <br> *  Arguments: <br> * <br> *      lpsmh       pointer to the sentmail handler <br> *      lpdft       pointer the the hash interval <br> *      lpfldrPar   parnet folder <br> *      lpszName    name for folder <br> *      lpszComment comment for folder <br> *      lpcbeid     points to the cached entryid size <br> *      lppeid      points to the cached entryid data <br> *      lppfldr     points to the cached mapi folder object <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> *      lpcbeid     [OUT] size of newly cached entryid <br> *      lppeid      [OUT] data of newly cached entryid <br> *      lppfldr     [OUT] folder corresponding to cached entryid <br> */ <br>HRESULT <br>HrCreateHashedFolder (LPSMH lpsmh, <br>    LPDFT lpdft, <br>    LPMAPIFOLDER lpfldrPar, <br>    LPTSTR lpszName, <br>    LPTSTR lpszComment, <br>    ULONG FAR * lpcbeid, <br>    LPENTRYID FAR * lppeid, <br>    LPMAPIFOLDER FAR * lppfldr) <br>{ <br>    HRESULT hr; <br>    LPMAPIFOLDER lpfldr = NULL; <br>    LPSPropValue lpval = NULL; <br>    SPropValue rgval[2] = {0}; <br>    ULONG cval; <br> <br>    /* Toss the current cache info */ <br> <br>    (*lpsmh-&gt;lpfnFree) (*lppeid); <br>    *lppeid = NULL; <br>    *lpcbeid = 0; <br> <br>    /* Create the new folder */ <br> <br>    hr = lpfldrPar-&gt;lpVtbl-&gt;CreateFolder (lpfldrPar, <br>                            FOLDER_GENERIC, <br>                            lpszName, <br>                            lpszComment, <br>                            NULL, <br>                            OPEN_IF_EXISTS, <br>                            &amp;lpfldr); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /* Set the hashing interval properties */ <br> <br>    rgval[0].ulPropTag = PR_START_DATE; <br>    rgval[0].Value.ft = lpdft-&gt;ftStart; <br>    rgval[1].ulPropTag = PR_END_DATE; <br>    rgval[1].Value.ft = lpdft-&gt;ftEnd; <br>    hr = lpfldr-&gt;lpVtbl-&gt;SetProps (lpfldr, 2, rgval, NULL); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /* Cache the folder info */ <br> <br>    hr = lpfldr-&gt;lpVtbl-&gt;GetProps (lpfldr, <br>                            (LPSPropTagArray)&amp;sptFldrDates, <br>                            FALSE, <br>                            &amp;cval, <br>                            &amp;lpval); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /* Make sure we have all the info we need */ <br> <br>    if ((lpval[0].ulPropTag != PR_START_DATE) || <br>        (lpval[1].ulPropTag != PR_END_DATE) || <br>        (lpval[2].ulPropTag != PR_ENTRYID)) <br>    { <br>        hr = ResultFromScode (MAPI_E_BAD_VALUE); <br>        goto ret; <br>    } <br> <br>    /* Cache the entryid */ <br> <br>    hr = ResultFromScode ((*lpsmh-&gt;lpfnAlloc) (lpval[2].Value.bin.cb, lppeid)); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br>    memcpy (*lppeid, lpval[2].Value.bin.lpb, (UINT)lpval[2].Value.bin.cb); <br>    *lpcbeid = lpval[2].Value.bin.cb; <br> <br>ret: <br> <br>    (*lpsmh-&gt;lpfnFree) (lpval); <br>    if (HR_FAILED (hr)) <br>    { <br>        UlRelease (lpfldr); <br>        lpfldr = NULL; <br>    } <br>    UlRelease (*lppfldr); <br>    *lppfldr = lpfldr; <br> <br>    DebugTraceResult (HrCreateHashedFolder(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  HrCacheHashedFolder() <br> * <br> *  Purpose: <br> * <br> *      Caches the folder that matches the hash value (file time) <br> * <br> *  Arguments: <br> * <br> *      lpsmh       pointer to the sentmail handler <br> *      ft          hash filetime <br> *      lpdft       pointer the the hash interval <br> *      lpcbeid     points to the cached entryid size <br> *      lppeid      points to the cached entryid data <br> *      lppfldr     points to the cached mapi folder object <br> *      lpfUpdated  points to cache update flag <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> *      lpcbeid     [OUT] size of newly cached entryid <br> *      lppeid      [OUT] data of newly cached entryid <br> *      lppfldr     [OUT] folder corresponding to cached entryid <br> *      lpfUpdated  [OUT] TRUE iff the out folder is not the <br> *                          previously cached folder <br> */ <br>HRESULT <br>HrCacheHashedFolder (LPSMH lpsmh, <br>    LPMDB lpmdbPref, <br>    FILETIME ft, <br>    LPDFT lpdft, <br>    LPMAPIFOLDER lpfldr, <br>    ULONG FAR * lpcbeid, <br>    LPENTRYID FAR * lppeid, <br>    LPMAPIFOLDER FAR * lppfldr, <br>    BOOL far * lpfUpdated) <br>{ <br>    HRESULT hr; <br>    LPMAPIPROP lpmp = NULL; <br>    LPMAPITABLE lptbl = NULL; <br>    LPSRow lprw = NULL; <br>    LPSRowSet lprws = NULL; <br>    ULONG ulType; <br>    UINT i; <br> <br>    /*  Check to see if the new hash fits the <br>     *  the current hashed folder, if the hash <br>     *  value does not work, find one that does <br>     */ <br>    if (!*lpfUpdated &amp;&amp; <br>        (CompareFileTime (&amp;lpdft-&gt;ftStart, &amp;ft) != 1) &amp;&amp; <br>        (CompareFileTime (&amp;lpdft-&gt;ftEnd, &amp;ft) != -1)) <br>    { <br>        /* The hash works, but do we have a folder? */ <br> <br>        if (*lppfldr) <br>            return hrSuccess; <br> <br>        hr = lpsmh-&gt;lpsess-&gt;lpVtbl-&gt;OpenEntry (lpsmh-&gt;lpsess, <br>                                        *lpcbeid, <br>                                        *lppeid, <br>                                        NULL, <br>                                        MAPI_BEST_ACCESS, <br>                                        &amp;ulType, <br>                                        (LPUNKNOWN FAR *)&amp;lpmp); <br>        if (!HR_FAILED (hr) &amp;&amp; (ulType != MAPI_FOLDER)) <br>        { <br>            hr = ResultFromScode (MAPI_E_UNEXPECTED_TYPE); <br>            UlRelease (lpmp); <br>            lpmp = NULL; <br>        } <br>        goto ret; <br>    } <br> <br>    /* Toss the cached info */ <br> <br>    (*lpsmh-&gt;lpfnFree) (*lppeid); <br>    *lppeid = NULL; <br>    *lpcbeid = 0; <br> <br>    /* Get the hierachy and set it up to find the target folder */ <br> <br>    hr = lpfldr-&gt;lpVtbl-&gt;GetHierarchyTable (lpfldr, 0, &amp;lptbl); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = lptbl-&gt;lpVtbl-&gt;SetColumns (lptbl, (LPSPropTagArray)&amp;sptFldrDates, 0); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    hr = lptbl-&gt;lpVtbl-&gt;QueryRows (lptbl, 12, 0L, &amp;lprws); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    while (lprws-&gt;cRows) <br>    { <br>        for (i = 0; i &lt; lprws-&gt;cRows; i++) <br>        { <br>            lprw = &amp;lprws-&gt;aRow[i]; <br> <br>            if (!lpmp &amp;&amp; <br>                (lprw-&gt;lpProps[0].ulPropTag == PR_START_DATE) &amp;&amp; <br>                (lprw-&gt;lpProps[1].ulPropTag == PR_END_DATE) &amp;&amp; <br>                (CompareFileTime (&amp;lprw-&gt;lpProps[0].Value.ft, &amp;ft) != 1) &amp;&amp; <br>                (CompareFileTime (&amp;lprw-&gt;lpProps[1].Value.ft, &amp;ft) != -1)) <br>            { <br>                /* Hey, this looks like the folder we want */ <br> <br>                hr = HrCacheFolder (lpsmh, <br>                        lpmdbPref, <br>                        lprw-&gt;lpProps[2].Value.bin.cb, <br>                        (LPENTRYID)lprw-&gt;lpProps[2].Value.bin.lpb, <br>                        lpcbeid, <br>                        lppeid, <br>                        (LPMAPIFOLDER FAR *)&amp;lpmp, <br>                        lpfUpdated); <br>                if (!HR_FAILED (hr)) <br>                { <br>                    lpdft-&gt;ftStart = lprw-&gt;lpProps[0].Value.ft; <br>                    lpdft-&gt;ftEnd = lprw-&gt;lpProps[1].Value.ft; <br>                } <br>            } <br>        } <br> <br>        /* Clean up the row properies */ <br> <br>        for (i = 0; i &lt; lprws-&gt;cRows; i++) <br>            (*lpsmh-&gt;lpfnFree) (lprws-&gt;aRow[i].lpProps); <br> <br>        /* We either found the folder or we had an error */ <br> <br>        if (lpmp || HR_FAILED (hr)) <br>            break; <br> <br>        /* Clean up the row set */ <br> <br>        (*lpsmh-&gt;lpfnFree) (lprws); <br>        hr = lptbl-&gt;lpVtbl-&gt;QueryRows (lptbl, 12, 0L, &amp;lprws); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br>    } <br> <br>    /* Clean up the final row set */ <br> <br>    (*lpsmh-&gt;lpfnFree) (lprws); <br> <br>ret: <br> <br>    UlRelease (lptbl); <br>    UlRelease (*lppfldr); <br>    *lppfldr = (LPMAPIFOLDER)lpmp; <br> <br>    DebugTraceResult (HrCacheHashedFolder(), hr); <br>    return hr ? hr : (lpmp ? hrSuccess : ResultFromScode (MAPI_E_NOT_FOUND)); <br>} <br> <br> <br>/* <br> *  HrArchiveByDate() <br> * <br> *  Purpose: <br> * <br> *      The purpose of this function is to "hash" a single message by <br> *      processing based on date.  The most obvious bucket size is <br> *      monthly but there is no reason not to make this an option the <br> *      user could confiigure. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           this filter hook obj <br> *      lpft            the date to be filtered against <br> *      lpfldrDef       the owning folder of the message <br> *      lpmdbDef        the owning store of the message <br> *      lpbkit          the cached bucket structure <br> *      fCatByYear      uses yearly subfolders iff TRUE <br> *      cbeid           cb for entryid of default target for message <br> *      lpbeid          pb for entryid of default target for message <br> * <br> *  Operation: <br> * <br> *      Opens the suggested folder (if needed) and checks for the <br> *      existence of the appropriate "bucket" folder.  If it does exist, <br> *      then the  folder is created and cached.  The entryid is grabbed <br> *      and passed back in to the spooler. <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> */ <br>HRESULT <br>HrArchiveByDate (LPSMH lpsmh, <br>    FILETIME FAR * lpft, <br>    LPMAPIFOLDER lpfldrDef, <br>    LPMDB lpmdbDef, <br>    LPBKIT lpbkit, <br>    BOOL fCatByYear, <br>    ULONG cbeid, <br>    LPBYTE lpeid) <br>{ <br>    HRESULT hr = hrSuccess; <br>    BOOL fUpdated = FALSE; <br>    LPMAPIFOLDER lpfldr; <br>    SYSTEMTIME st; <br>    SYSTEMTIME sty; <br>    TCHAR rgchName[64] = {0}; <br>     <br>    if (!FileTimeToSystemTime (lpft, &amp;st)) <br>    { <br>        hr = ResultFromScode (MAPI_E_BAD_VALUE); <br>        goto ret; <br>    } <br> <br>    /* Cache the parent folder */ <br> <br>    hr = HrCacheFolder (lpsmh, <br>                    lpmdbDef, <br>                    cbeid, <br>                    (LPENTRYID)lpeid, <br>                    &amp;lpbkit-&gt;cbeidParent, <br>                    &amp;lpbkit-&gt;lpeidParent, <br>                    &amp;lpbkit-&gt;lpfldrParent, <br>                    &amp;fUpdated); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    if (fCatByYear) <br>    { <br>        /* Cache the year folder */ <br> <br>        hr = HrCacheHashedFolder (lpsmh, <br>                    lpmdbDef, <br>                    *lpft, <br>                    &amp;lpbkit-&gt;dftYr, <br>                    lpbkit-&gt;lpfldrParent, <br>                    &amp;lpbkit-&gt;cbeidYr, <br>                    &amp;lpbkit-&gt;lpeidYr, <br>                    &amp;lpbkit-&gt;lpfldrYr, <br>                    &amp;fUpdated); <br>        if (HR_FAILED (hr) &amp;&amp; (GetScode (hr) == MAPI_E_NOT_FOUND)) <br>        { <br>            wsprintf (rgchName, "%04hu", st.wYear); <br>            sty.wYear = st.wYear; <br>            sty.wMonth = 1; <br>            sty.wDayOfWeek = 0; <br>            sty.wDay = 1; <br>            sty.wHour = 0; <br>            sty.wMinute = 0; <br>            sty.wSecond = 0; <br>            sty.wMilliseconds = 0; <br>            if (!SystemTimeToFileTime (&amp;sty, &amp;lpbkit-&gt;dftYr.ftStart)) <br>            { <br>                hr = ResultFromScode (MAPI_E_BAD_VALUE); <br>                goto ret; <br>            } <br>            sty.wMonth = 12; <br>            sty.wDay = rgwDaysPerMonth[sty.wMonth - 1]; <br>            sty.wDayOfWeek = 0; <br>            sty.wDay = 31; <br>            sty.wHour = 23; <br>            sty.wMinute = 59; <br>            sty.wSecond = 59; <br>            sty.wMilliseconds = 999; <br>            if (!SystemTimeToFileTime (&amp;sty, &amp;lpbkit-&gt;dftYr.ftEnd)) <br>            { <br>                hr = ResultFromScode (MAPI_E_BAD_VALUE); <br>                goto ret; <br>            } <br>            hr = HrCreateHashedFolder (lpsmh, <br>                            &amp;lpbkit-&gt;dftYr, <br>                            lpbkit-&gt;lpfldrParent, <br>                            rgchName, <br>                            NULL, <br>                            &amp;lpbkit-&gt;cbeidYr, <br>                            &amp;lpbkit-&gt;lpeidYr, <br>                            &amp;lpbkit-&gt;lpfldrYr); <br>            if (HR_FAILED (hr)) <br>                goto ret; <br>        } <br>        else if (HR_FAILED (hr)) <br>            goto ret; <br> <br>        lpfldr = lpbkit-&gt;lpfldrYr; <br>    } <br>    else <br>        lpfldr = lpbkit-&gt;lpfldrParent; <br> <br>    /* Cache the hashed target folder */ <br> <br>    hr = HrCacheHashedFolder (lpsmh, <br>                    lpmdbDef, <br>                    *lpft, <br>                    &amp;lpbkit-&gt;dft, <br>                    lpfldr, <br>                    &amp;lpbkit-&gt;cbeid, <br>                    &amp;lpbkit-&gt;lpeid, <br>                    &amp;lpbkit-&gt;lpfldr, <br>                    &amp;fUpdated); <br>    if (HR_FAILED (hr) &amp;&amp; (GetScode (hr) == MAPI_E_NOT_FOUND)) <br>    { <br>        if (fCatByYear) <br>        { <br>            wsprintf (rgchName, <br>                "%02hu %s", <br>                st.wMonth, <br>                rgtstrMonthFull[st.wMonth - 1]); <br>        } <br>        else <br>        { <br>            wsprintf (rgchName, <br>                TEXT("'%02hu/%02hu %s"), <br>                st.wYear % 100, <br>                st.wMonth, <br>                rgtstrMonthFull[st.wMonth - 1]); <br>        } <br>        st.wDayOfWeek = (st.wDay - st.wDayOfWeek - 1) % 7; <br>        st.wDay = 1; <br>        st.wHour = 0; <br>        st.wMinute = 0; <br>        st.wSecond = 0; <br>        st.wMilliseconds = 0; <br>        if (!SystemTimeToFileTime (&amp;st, &amp;lpbkit-&gt;dft.ftStart)) <br>        { <br>            hr = ResultFromScode (MAPI_E_BAD_VALUE); <br>            goto ret; <br>        } <br>        st.wDay = rgwDaysPerMonth[st.wMonth - 1]; <br>        if ((st.wMonth == 2) &amp;&amp; FIsLeapYear (st.wYear)) <br>            st.wDay += 1; <br>        st.wDayOfWeek = (st.wDayOfWeek + st.wDay - 1) % 7; <br>        st.wHour = 23; <br>        st.wMinute = 59; <br>        st.wSecond = 59; <br>        st.wMilliseconds = 999; <br>        if (!SystemTimeToFileTime (&amp;st, &amp;lpbkit-&gt;dft.ftEnd)) <br>        { <br>            hr = ResultFromScode (MAPI_E_BAD_VALUE); <br>            goto ret; <br>        } <br>        hr = HrCreateHashedFolder (lpsmh, <br>                            &amp;lpbkit-&gt;dft, <br>                            lpfldr, <br>                            rgchName, <br>                            NULL, <br>                            &amp;lpbkit-&gt;cbeid, <br>                            &amp;lpbkit-&gt;lpeid, <br>                            &amp;lpbkit-&gt;lpfldr); <br>    } <br> <br>ret: <br> <br>    DebugTraceResult (HrArchiveMessage(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> *  HrArchiveMessage() <br> * <br> *  Purpose: <br> * <br> *      The purpose of this function is to "hash" a single message by <br> *      processing based on date.  The most obvious bucket size is <br> *      monthly but there is no reason not to make this an option the <br> *      user could confiigure. <br> * <br> *  Arguments: <br> * <br> *      lpsmh           this filter hook obj <br> *      lpmsg           the message to be filtered <br> *      lpfldrDef       the owning folder of the message <br> *      lpmdbDef        the owning store of the message <br> *      lpbkit          the cached bucket structure <br> *      fCatByYear      uses yearly subfolders iff TRUE <br> *      lpcbeid         cb for entryid of default target for message <br> *      lppbeid         pb for entryid of default target for message <br> * <br> *  Operation: <br> * <br> *      Extracts the date of the message that is to be used in the <br> *      archiving, and calls off to HrArchiveByDate(). <br> * <br> *      IMPORTANT: the entryid passed in will be swapped out by this <br> *      call.  Therefore the *lppeid buffer must be allocated with the <br> *      MAPIAllocateBuffer provider to the filter. <br> * <br> *  Returns: <br> * <br> *      (HRESULT) <br> *      lpcbeid [out]   the size of the returned EntryID <br> *      lppbeid [out]   the data of the returned EntryID <br> */ <br>HRESULT <br>HrArchiveMessage (LPSMH lpsmh, <br>    LPMESSAGE lpmsg, <br>    LPMAPIFOLDER lpfldrDef, <br>    LPMDB lpmdbDef, <br>    LPBKIT lpbkit, <br>    BOOL fCatByYear, <br>    ULONG FAR * lpcbeid, <br>    LPBYTE FAR * lppeid) <br>{ <br>    HRESULT hr = hrSuccess; <br>    FILETIME ft; <br>    LPSPropValue lpval = NULL; <br>    ULONG cval; <br> <br>    /* Quick and dirty parameter check */ <br> <br>    if (IsBadWritePtr (lpsmh, sizeof(SMH)) || <br>        IsBadWritePtr (lpcbeid, sizeof(ULONG)) || <br>        IsBadWritePtr (lppeid, sizeof(LPBYTE)) || <br>        IsBadWritePtr (*lppeid, (UINT)(*lpcbeid))) <br>        return ResultFromScode (MAPI_E_INVALID_PARAMETER); <br> <br>    /* Get the date used by the hash */ <br> <br>    hr = lpmsg-&gt;lpVtbl-&gt;GetProps (lpmsg, <br>                            (LPSPropTagArray)&amp;sptMsgDates, <br>                            FALSE, <br>                            &amp;cval, <br>                            &amp;lpval); <br>    if (HR_FAILED (hr)) <br>        goto ret; <br> <br>    /* Make sure what we end up with is usable */ <br> <br>    if (lpval[0].ulPropTag == PR_MESSAGE_DELIVERY_TIME) <br>    { <br>        DebugTrace ("SMH: filtering on PR_MESSAGE_DELIVERY_TIME\n"); <br>        ft = lpval[0].Value.ft; <br>    } <br>    else if (lpval[1].ulPropTag == PR_CLIENT_SUBMIT_TIME) <br>    { <br>        DebugTrace ("SMH: filtering on PR_CLIENT_SUBMIT_TIME\n"); <br>        ft = lpval[1].Value.ft; <br>    } <br>    else <br>    { <br>        DebugTrace ("SMH: cannot filter on provided time props\n"); <br>        hr = ResultFromScode (MAPI_E_BAD_VALUE); <br>        goto ret; <br>    } <br> <br>    hr = HrArchiveByDate (lpsmh, <br>                    &amp;ft, <br>                    lpfldrDef, <br>                    lpmdbDef, <br>                    lpbkit, <br>                    fCatByYear, <br>                    *lpcbeid, <br>                    *lppeid); <br> <br>ret: <br>     <br>    if (!HR_FAILED (hr)) <br>    { <br>        LPBYTE lpeid; <br> <br>        /* OK, If we get this far we are moving the message */ <br> <br>        hr = ResultFromScode ((*lpsmh-&gt;lpfnAlloc) (lpbkit-&gt;cbeid, &amp;lpeid)); <br>        if (HR_FAILED (hr)) <br>            goto ret; <br>        memcpy (lpeid, lpbkit-&gt;lpeid, (UINT)lpbkit-&gt;cbeid); <br>        (*lpsmh-&gt;lpfnFree) (*lppeid); <br>        *lpcbeid = lpbkit-&gt;cbeid; <br>        *lppeid = lpeid; <br>    } <br>    (*lpsmh-&gt;lpfnFree) (lpval); <br>     <br>    DebugTraceResult (HrArchiveMessage(), hr); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
