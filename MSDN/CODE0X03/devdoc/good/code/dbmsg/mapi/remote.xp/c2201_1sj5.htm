<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2201"></a>README.TXT</h2>
<pre><code>WINDS Remote Transport <br> <br> <br>SUMMARY <br>======= <br> <br>The Remote.Xp sample is a remote transport provider (XPWDSR) implemented <br>in C++. This transport demonstrates the following extended MAPI features: <br> <br> - Support for the REMOTE interface for slow-link connection to a remote host. <br>   This includes implementation of the IMAPIFolder methods needed to interact <br>   with a client remote viewer application. <br> - Support for deferred delivery mechanism for scheduled message submission to <br>   a remote host at a user-settable upload time. <br> - Support for forced immediate connection and submission (using the <br>   FlushQueues method implemented in the IMAPIStatus object) in response to <br>   Deliver Mail Now and Transfer Mail in the Microsoft Exchange Client. <br> - How to implement server-based messaging. <br> - Real-world working mail transport which sends messages to a Windows NT <br>   workstation or server running the Windows Developer Support (WINDS) Sample <br>   Server Messaging Host included with this and other MAPI samples. <br> - Use of the Transport Neutral Encapsulation Format (TNEF) interface to <br>   encapsulate ALL the message properties. <br> - How to implement the IMAPIStatus interface for client access to transport <br>   status. <br> - Multithread safe. <br> - Configuration dialogs. <br> - Generation of delivery and non-delivery reports. <br> - Support for the profile Wizard for interactive profile configuration. <br> - Support for the WINDS address type. <br> - Support for background download and FlushQueues spooler interaction for <br>   spooler-marshalled remote connections. <br> - Single binary file for Windows NT and Windows 95. <br> <br>MORE INFORMATION <br>================ <br> <br>This program requires: <br> <br>    Windows NT 3.51 (or later) or Windows 95, <br>    The MAPI 1.0 SDK included in the Win32 SDK, <br>    Microsoft Visual C++ version 2.1 (or later.) <br> <br>Optionally, the Win32 SDK tools with the MIDL compiler. <br> <br>This sample uses RPCs over named pipes to establish connections with the <br>remote server. For convenience to customers without the full Win32 SDK, we <br>have provided the MIDL compiler-generated C and header files (WINDS.H, <br>WINDS_S.C, and WINDS_C.C) along with the IDL and ACF files. If you make changes <br>to the IDL or ACF, you'll NEED to recompile them using the MIDL compiler <br>available only in the Win32 SDK and Visual C++ 4.0 and later. <br> <br>Building the Sample Code <br>------------------------ <br> <br>The sample remote transport provider has only been compiled and tested under <br>Windows NT 3.51 and Windows 95, there are no plans for a Windows 3.1x (16-bit) <br>release of this sample. <br> <br>Users should update the project file dependencies as soon as the files are <br>copied to your machine. Use the PROJECTS.UPDATE DEPENDENCIES options in the <br>Visual C++ Developer Studio. <br> <br>This sample was developed using Microsoft Visual C++ 2.x. Its associated <br>makefile is XPWDSR32.MAK. Traces can be enabled for Release builds by defining <br>ENABLE_DEBUG_OUTPUT in the preprocessor symbols define in the project settings <br>menu. <br> <br>A command-line compiler-independent MAKE file has been provided for users of <br>command-line tools. <br> <br>Configuration <br>------------- <br> <br>Use the MERGEINI.EXE utility from the MAPI PDK to merge this transport's <br>message service INF file, XPWDSR.INF, with the MAPISVC.INF file: <br> <br>    MERGEINI  {full-path}\XPWDSR.INF -m -q <br> <br>for example: <br> <br>    MERGEINI  C:\SAMPLES\MAPI\XPWDSR\XPWDSR.INF -m -q <br> <br>You will then need to configure a profile that includes this transport. When <br>you create a new profile, the Profile Wizard will detect this transport and set <br>the initial properties through the wizard pages. <br> <br>XPWDSR has two property sheets for interactive configuration which are <br>accessible through the service provider logon, through the ServiceEntry call <br>and through the IMAPIStatus::SettingsDialog method. The sample also defines <br>custom properties for the configuration options so they may be set and <br>retrieved programmatically. <br> <br>User Account Configuration Page <br>------------------------------- <br> <br>Server Name: This is the network UNC (Universal Naming Convention) name of <br>the machine where the user account is. The server machine MUST be running the <br>WINDS Sample Server Messaging Host application prior to the provider setup. <br> <br>Mailbox Name: The mailbox name is the name of the account on the remote server. <br>To select a mailbox or change the current one, click on Browse and select a <br>name from the list that will appear. Once selected, you will be asked to enter <br>the password for the mailbox. For new mailboxes, the default password is <br>PASSWORD. If the list of mailboxes is empty or you don't find the one for you, <br>then a new account must be created on the server program. This field cannot be <br>edited manually by the user. <br> <br>Full Name: This is the complete name of the owner of the mailbox selected. This <br>field is updated automatically when a new mailbox is selected. This information <br>cannot be edited manually. <br> <br>Change Mailbox Password: Click on this button to change the password for this <br>mailbox. You will be asked to type the old password, a new password, and then <br>confirm the new password. <br> <br>Using Local Network (LAN): This is the option to use if the machine is directly <br>hooked to on the network there is a connection to the server machine at all <br>times. If this option is selected, when running, the provider will install <br>notification links with the remote system allowing the provider to update <br>internal data dynamically as the data changes on the server, and to react to <br>changes or commands from the server. <br> <br>Remote - With Local Address Book Directory: This setting instructs the provider <br>to adjust itself to use local data and to defer communication with the server <br>until the user changes the connection mode. This mode is useful if the server <br>or the clientmachine are not on a persistent connection link with each other. <br>If this option is selected the provider will not know of changes that occur on <br>the server to cached data. <br> <br>Message Transport Configuration Page <br>------------------------------------ <br> <br>Automatic Remote Uploads At: The daily time when the transport will submit <br>all the messages it has deferred. At this time it will connect to the server <br>and submit all the messages in a batch. The time must be entered in the <br>24-hour format, i.e. 12:00 AM is 0:00. 10:30 PM is 22:30, etc. <br> <br>When Connected: If this option is selected, after the messages have been <br>uploaded at the scheduled time, the transport will request to update the <br>message headers. <br> <br>Note: Prior to installing this transport into a profile, the WINDS Sample <br>Server Messaging Host should be running in the remote (or local) computer. <br>See the readme file in the above sample for instructions on compiling, <br>installing, and using it. <br> <br>Address Format <br>-------------- <br> <br>This transport supports the address type WINDS. When creating new one-off <br>entries in an address book (i.e. the Personal Address Book), this is the <br>value for the Address Type field. Email addresses for this transport look <br>like this: <br> <br>    \\server-name\mailbox-name <br> <br>The backslashes are literals, while the server-name and mailbox-name should <br>be replaced with the server and mailbox name you wish to send to. <br> <br>Note: When typing one-off addresses in the Exchange client, you must double <br>the backslashes, like this: <br> <br>    [WINDS:\\\\myserver\\mymailbox] <br> <br>This is because the client treats the backslash as an escape character. <br> <br>Remote Access <br>------------- <br> <br>The main difference between this transport and a non-remote transport is the <br>ability to schedule mail transmission and to preview the header information <br>of messages residing in a user's remote mailbox. Outgoing messages aren't <br>transmitted at time of submission, but are queued by the spooler until the <br>scheduled delivery time occurs. This is known as deferred submission. As long <br>as the message is deferred, it stays in the user's local message store and the <br>spooler retains responsibility. The spooler maintains an internal queue of <br>deferred messages which it empties at the scheduled upload time, passing each <br>message in sequence to the transport for delivery. <br> <br>Inbound messages stay in the user's mailbox on the remote server until <br>explicitly downloaded. This transport supports the Remote Viewer semantics, <br>where the user can request the transport to connect to the server and <br>retrieve a table of mail headers of messages in the user's remote mailbox. The <br>remote viewer lets the user mark those rows of the header table he wishes to <br>download. Rows are marked for move, delete, or copy operations according to <br>which operation the user wants to perform on the corresponding message. <br>Downloads are started explicitly, not scheduled, since the user has to <br>explicitly mark the rows of the table that are to be downloaded. <br> <br>The download table is a contents table of a MAPI folder that is returned by <br>the IMAPIStatus object. This folder has no objects in it, but only exists to <br>provide the contents table. When the user marks messages for download in the <br>Remote Viewer, the corresponding row in the table has the PR_MSG_STATUS <br>property set to a bitmask indicating the requested operation. To obtain the <br>data for the header table, the transport makes an RPC to the server <br>requesting the name of a named pipe. The server creates the pipe and <br>returns the name. The transport then opens its end of the pipe and streams <br>the actual data over it. This data is used to populate the contents table. <br> <br>Download Semantics <br>------------------ <br> <br>A user request to start downloading marked messages causes the transport's <br>IMAPIStatus::ValidateState method to be called with the <br>PROCESS_XP_HEADER_CACHE flag passed. At this point the download table is <br>walked and each marked entry is added to a list of messages to be <br>downloaded. When the list has been constructed, an RPC is made to the server <br>to obtain the name of a named pipe over which to stream the data. <br> <br>The transport opens the pipe and requests the first message in the to-download <br>list. The transport uses a simple form of handshaking: control messages are <br>passed first to tell the server what the operation is, ACK the request, and get <br>the size of the following stream. Transmission errors can be reported in these <br>messages also. An error causes the message-in-transit to be dropped and the <br>next one started. <br> <br>When a message is downloaded, its storage is backed by a temporary file which <br>is created on the fly to hold the incoming stream. When the message stream <br>arrives successfully on the client side, its to-download list node is moved <br>to a just-downloaded list. If the user logs off the session before the <br>just-dowloaded list is processed, the downloaded file is kept in a to-do <br>directory which will be processed in the next session logon. <br> <br>Processing the just-downloaded list occurs in the same manner as for a <br>non-deferred message; each message is pumped through the spooler's <br>StartMessage loop. The spooler is notified that new mail has arrived by <br>setting the STATUS_INBOUND_FLUSH in the PR_STATUS_CODE bit in the status table <br>row. This causes the spooler to start requesting messages from the XP (by <br>calling StartMessage). We stream the message in from the temp file, decode the <br>TNEF stream into the passed MAPI message object, remove the non-transmittable <br>properties, set the transport computed properties, delete the temporary file, <br>and remove that message's node from the just-downloaded list. When the list is <br>empty, we signal the spooler to stop requesting incoming messages by clearing <br>the STATUS_INBOUND_FLUSH bit and passing back the untouched message object in <br>StartMessage. <br> <br>Upload Semantics <br>---------------- <br> <br>Uploading messages works in a similar fashion except that we initiate the <br>process based on the time of day. The user configuration specifies a daily <br>upload time which is saved in the profile section. The XP can be in several <br>states with respect to the upload operation. When the upload time arrives, the <br>state changes from WAITING to PROCESSING_TIMER_EVENT. <br> <br>When a message is submitted by the user, SubmitMessage is called and the <br>message is passed to us by the spooler. If our state is WAITING, we return <br>without doing anything. In the subsequent call to EndMessage, we check the <br>state and if we're WAITING, pass back END_DONT_RESEND. This signals the <br>spooler to queue this message until later requested. <br> <br>A timer event is initialized on logon with the interval between the current <br>time and the upload time. When the timer expires, the spooler is notified to <br>start submitting the earlier deferred messages from its internal queue. We get <br>called again at SubmitMessage and are passed each message that's dequeued. <br>In SubmitMessage, we check our state, recognize that we're being called this <br>time to send the message, take responsibility (PR_RESPONSIBILITY), and go ahead <br>and deliver it. We also change our status to STATUS_OUTBOUND_FLUSH to signal <br>the spooler to keep calling our SubmitMessage method as long as it's queue is <br>not empty. In the subsequent EndMessage, we check our state, realize that a <br>message has just been dequeued and sent, decrement our counter and pass back <br>0. When the spooler has dequeued the last message, it callls TranportNotify, <br>passing NOTIFY_END_OUTBOUND_FLUSH and we change state back to WAITING. <br> <br>After the transport has finished uploading the messages at the scheduled time, <br>we also request to get a new table of message headers on the server. This table <br>is downloaded to the local file and if the remote viewer is displayed, the <br>table of contents is refreshed. <br> <br>Aborting Message Delivery <br>------------------------- <br> <br>Once deferred, a message can be aborted any time before the actual delivery. <br>This happens if the user opens or deletes the message before it's sent. The <br>XP gets called at TransportNotify with NOTIFY_ABORT_DEFERRED. The spooler <br>will remove this message from its internal queue and we won't be called at <br>SubmitMessage for it. <br> <br>Debug Traces and Asserts <br>------------------------ <br> <br>This sample uses several output debug string functions in the Win32 <br>environment to avoid attaching the DLL to any debugger. By default, the trace <br>messages are output to a debug terminal attached to COM1 with settings at <br>9600, N, 8, 1. The debug messages can also be written to a log file whose <br>default location is C:\MAPILOG.TXT. The file TRACES.CPP defines some macros <br>that can be easily modified for different communications settings, output port, <br>and log file name. It also implements a macro (ASSERT) and function that test <br>the validity of a given statement. If the assertion fails, the user/developer <br>has the opportunity to break into the debugger at the exact point where the <br>assertion occurred. <br> <br>The debug routines are found in the TRACES.CPP and TRACES.H files. <br> <br>To enable the TRACExx functions in the TRACES.CPP files, define the <br>ENABLE_DEBUG_OUTPUT macro during compilation. These functions work in DEBUG or <br>RELEASE builds. You can only enable/disable traces at compile time through <br>ENABLE_DEBUG_OUTPUT. There is no run time switch to enable or disable the <br>traces. <br> <br>TRACES.CPP implements an ASSERT macro which test a evaluates an expression <br>expecting a TRUE result, i.e. ASSERT (expression) will interrupt execution if the expression is NOT TRUE (non-zero). <br> <br>The ASSERT macro informs the line and source code file name where the assertion <br>failed and writes the result to a debug trace. The assert information is also <br>written to the log file. <br> <br>Also the this file implements a variation of assert: ASSERTMSG (expression, <br>user-message) which behaves identical to ASSERT except that is the assertion <br>fails, the message string is printed along with the assertion line and file <br>information. <br> <br>By default, if an assertion fails, a dialog will come up and interrupt <br>execution until a selection is made to break into the debugger or ignore the <br>assertion. </code></pre>
<p>&nbsp;</p></body>
</HTML>
