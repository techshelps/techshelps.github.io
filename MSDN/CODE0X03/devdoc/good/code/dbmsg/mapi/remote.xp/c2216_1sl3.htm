<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPSRVCE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2217"></a>XPSRVCE.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      XPSRVCE.CPP <br>// <br>//  Description <br>//      This file implements the entry points, XPProviderInit and  <br>//      ServiceEntry for this provider's DLL. <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "XPWDSR.H" <br> <br>// Remark this line to turn verbose tracing OFF <br>#define DO_INFO_TRACES <br>#ifdef DO_INFO_TRACES <br>#define InfoTrace(a)   TraceInfoMessage(a) <br>#else <br>#define InfoTrace(a)    <br>#endif // DO_INFO_TRACES <br> <br>DTBLEDIT     DtUploadTime = { sizeof(DTBLEDIT), fMapiUnicode, 5, PR_TMP_UPLOAD_TIME }; <br>DTBLCHECKBOX DtGetHeaders = { sizeof(DTBLCHECKBOX), fMapiUnicode, PR_SMP_GET_HEADERS }; <br> <br>DTCTL XPConfigPage[] = <br>{ <br>    { DTCT_PAGE,     0,           NULL, 0, NULL,     0,                  &amp;DtPage       }, <br>    { DTCT_EDIT,     DT_REQUIRED, NULL, 0, szFilter, IDC_UPLOAD_TIME,    &amp;DtUploadTime }, <br>    { DTCT_CHECKBOX, 0,           NULL, 0, NULL,     IDC_UPDATE_HEADERS, &amp;DtGetHeaders }, <br>    { DTCT_LABEL,    0,           NULL, 0, NULL,     IDC_STATIC1,        &amp;DtLabel      }, <br>    { DTCT_GROUPBOX, 0,           NULL, 0, NULL,     IDC_STATIC2,        &amp;DtGroupBox   }, <br>    { DTCT_GROUPBOX, 0,           NULL, 0, NULL,     IDC_STATIC3,        &amp;DtGroupBox   } <br>}; <br> <br>TCHAR szDefaultTime[] = TEXT("23:59"); <br> <br>// Global pointer to the MAPI memory allocation functions <br>LPALLOCATEBUFFER    gpfnAllocateBuffer;  // MAPIAllocateBuffer function <br>LPALLOCATEMORE      gpfnAllocateMore;    // MAPIAllocateMore function     <br>LPFREEBUFFER        gpfnFreeBuffer;      // MAPIFreeBuffer function       <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ServiceEntry() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Called by the profile setup API to display the provider <br>//      configuration properties for this transport provider <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT STDAPICALLTYPE ServiceEntry (HINSTANCE          hInstance, <br>                                     LPMALLOC           pMallocObj, <br>                                     LPMAPISUP          pSupObj, <br>                                     ULONG              ulUIParam, <br>                                     ULONG              ulFlags, <br>                                     ULONG              ulContext, <br>                                     ULONG              ulCfgPropCount, <br>                                     LPSPropValue       pCfgProps, <br>                                     LPPROVIDERADMIN    pAdminProvObj, <br>                                     LPMAPIERROR *      ppMAPIError) <br>{ <br>    // Look at TRACES.H and TRACES.CPP for more options to the InitTraces() function <br>    //InitTraces (0);                                       // Send output only to the COM1 port <br>    InitTraces (TRACES_CONSOLE | TRACES_NO_COM_OUTPUT);     // Send output to a console window BUT NOT to the COM1 <br>    //InitTraces (TRACES_CONSOLE | TRACES_LOG_FILE);        // Send output to COM1 port AND a console window AND to a log file in C:\MAPILOG.TXT <br> <br>    InfoTrace ("ServiceEntry function called"); <br>    HRESULT hResult = S_OK; <br>    LPPROFSECT pProfileObj = NULL; <br>    ULONG ulPropCount; <br>    LPSPropValue pProps = NULL; <br>    HANDLE hUIMutex = NULL; <br> <br>    // What context where were we called in? <br>    if (MSG_SERVICE_INSTALL         == ulContext || <br>        MSG_SERVICE_UNINSTALL       == ulContext || <br>        MSG_SERVICE_PROVIDER_CREATE == ulContext || <br>        MSG_SERVICE_PROVIDER_DELETE == ulContext) <br>    { <br>        // We don't handle any of these contexts <br>        TraceString1 ("ServiceEntry: Immediate return. Context: %d", ulContext); <br>        goto ErrorExit; <br>    } <br>    TraceString1 ("ServiceEntry: Context for call: %d", ulContext); <br>    ghInstance = hInstance; <br>     <br>    // Get the MAPI memory allocation routines we'll be needing <br>    hResult = pSupObj-&gt;GetMemAllocRoutines (&amp;gpfnAllocateBuffer, &amp;gpfnAllocateMore, &amp;gpfnFreeBuffer); <br>    if (hResult) <br>    { <br>        TraceResult ("ServiceEntry: Failed to get the memory allocation functions", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    // Open the Profile Section for this service <br>    hResult = pAdminProvObj-&gt;OpenProfileSection (NULL, <br>                                                 NULL, <br>                                                 MAPI_MODIFY, <br>                                                 &amp;pProfileObj); <br>    if (hResult) <br>    { <br>        goto ErrorExit; <br>    } <br>    if (MSG_SERVICE_CREATE == ulContext) <br>    { <br>        // If ServiceEntry is called because it the service is being created, we create a temporary <br>        // file where we save the headers text file when the user updates them from <br>        // the remote host. The headers should be persistent from session to <br>        // session (using the same profile, of course) but unique per session. <br>        TCHAR szTmpDir[_MAX_PATH], szFile[_MAX_PATH]; <br>        GetTempPath (_MAX_PATH, szTmpDir); <br>        lstrcat (szTmpDir, WINDS_DATA_DIRECTORY); <br>        CreateDirectory (szTmpDir, NULL); <br>        GetTempFileName (szTmpDir,      // Create the file in the system temp directory <br>                         TEXT("XRH"),   // Our transport fixed prefix for temp files <br>                         0,             // Use the time to create a pseudo-random number <br>                         szFile);       // Destination buffer <br>        SPropValue spvProps[4] = { 0 }; <br>        spvProps[0].ulPropTag = PR_SMP_HEADERS_FILENAME; <br>        spvProps[0].Value.LPSZ = szFile; <br>        SYSTEMTIME st; <br>        GetLocalTime (&amp;st); <br>        st.wHour = 23; st.wMinute = 59; st.wSecond = 0; <br>        spvProps[1].ulPropTag = PR_SMP_UPLOAD_TIME; <br>        SystemTimeToFileTime (&amp;st, &amp;spvProps[1].Value.ft); <br>        spvProps[2].ulPropTag = PR_SMP_CONNECTION_TYPE; <br>        spvProps[2].Value.l = OFFLINE_CONNECT; <br>        spvProps[3].ulPropTag = PR_SMP_GET_HEADERS; <br>        spvProps[3].Value.b = TRUE; <br>        hResult = pProfileObj-&gt;SetProps (sizeof(spvProps)/sizeof(SPropValue), spvProps, NULL); <br>        TraceResult ("ServiceEntry: Failed to save the headers file name back into the profile", hResult); <br>    } <br>    // The profile section is open, get the properties out of it <br>    hResult = pProfileObj-&gt;GetProps ((LPSPropTagArray)&amp;sptLogonProps, <br>                                     fMapiUnicode, <br>                                     &amp;ulPropCount, <br>                                     &amp;pProps); <br>    if (FAILED(hResult)) <br>    { <br>        TraceResult ("ServiceEntry: Failed to get profile section properties", hResult); <br>        goto ErrorExit; <br>    } <br>    ASSERT (NUM_LOGON_PROPERTIES == ulPropCount); <br> <br>    if (MSG_SERVICE_DELETE == ulContext) <br>    { <br>        // If the service is being removed from a profile, we must cleanup <br>        // any temporary file (i.e. the headers text file) <br>        if (PR_SMP_HEADERS_FILENAME == pProps[HEADER_FILE].ulPropTag) <br>        { <br>            DeleteFile (pProps[HEADER_FILE].Value.LPSZ); <br>        } <br>        TCHAR szTmpDir[_MAX_PATH], szDownloadDir[_MAX_PATH]; <br>        GetTempPath (_MAX_PATH, szTmpDir); <br>        lstrcat (szTmpDir, WINDS_DATA_DIRECTORY); <br>        if (PR_SMP_MAILBOX_NAME == pProps[MAILBOX_NAME].ulPropTag) <br>        { <br>            wsprintf (szDownloadDir, WINDS_DOWNLOAD_DIR_NAME_FORMAT, szTmpDir, pProps[MAILBOX_NAME].Value.LPSZ); <br>            RemoveDirectory (szDownloadDir); <br>        } <br>        RemoveDirectory (szTmpDir); <br>        // We are done <br>        hResult = S_OK; <br>        goto ErrorExit; <br>    } <br>    // After the setup wizard has been called the ServiceEntry functions gets called <br>    // with a set of properties obtained from the user for configuring this provider. <br>    // Merge or replace those properties onto the one we obtained from the profile section. <br>    if (pCfgProps &amp;&amp; ulCfgPropCount) <br>    { <br>        hResult = MergeConfigProps (ulCfgPropCount, pCfgProps, pProps); <br>        if (hResult) <br>        { <br>            goto ErrorExit; <br>        } <br>    } <br>    // If we can, display the UI... <br>    if (SERVICE_UI_ALWAYS &amp; ulFlags || SERVICE_UI_ALLOWED &amp; ulFlags) <br>    { <br>        CFGDLG CfgDialog = { 0 }; <br>        hUIMutex = CreateMutex (NULL, FALSE, CONFIG_UI_MUTEX); <br>        if (NULL == hUIMutex) <br>        { <br>            TraceResult ("ServiceEntry: Failed to create UI mutext", GetLastError()); <br>        } <br>        PrivInitialize3DCtl (hInstance); <br>        if (WAIT_TIMEOUT == WaitForSingleObject (hUIMutex, 250)) // Wait for the MUTEX for 1/4 second <br>        { <br>            PrivateMessageBox (IDS_MSG_CONFIG_UI_IN_USE, (HWND)ulUIParam); <br>            hResult = MAPI_E_BUSY; <br>            goto ErrorExit; <br>        } <br> <br>        // Fill in the logon UI structure <br>        CfgDialog.hInst    = hInstance; <br>        CfgDialog.hWnd     = (HWND)ulUIParam; <br>        CfgDialog.ppProps  = &amp;pProps; <br>        CfgDialog.pSupObj  = pSupObj; <br>        CfgDialog.ulFlags  = MSG_SERVICE_UI_READ_ONLY &amp; ulFlags ? UI_READONLY : 0; <br>        CfgDialog.hUIMutex = NULL; // So that the DoLogonDlg() won't have to wait. <br>ShowPropsAgain: <br>        hResult = DoLogonDlg (&amp;CfgDialog); <br>        if (hResult) <br>        { <br>            goto ErrorExit; <br>        } <br>        if (!PingRemoteServer ((HWND)ulUIParam, pProps)) <br>        { <br>            goto ShowPropsAgain; <br>        } <br>    } <br>    if (PR_SMP_MAILBOX_NAME == pProps[MAILBOX_NAME].ulPropTag) <br>    { <br>        TCHAR szTmpDir[_MAX_PATH], szDownloadDir[_MAX_PATH]; <br>        GetTempPath (_MAX_PATH, szTmpDir); <br>        lstrcat (szTmpDir, WINDS_DATA_DIRECTORY); <br>        wsprintf (szDownloadDir, WINDS_DOWNLOAD_DIR_NAME_FORMAT, szTmpDir, pProps[MAILBOX_NAME].Value.LPSZ); <br>        CreateDirectory (szDownloadDir, NULL); <br>    } <br> <br>    hResult = pProfileObj-&gt;SetProps (NUM_LOGON_PROPERTIES, pProps, NULL); <br>    TraceResult ("ServiceEntry: Failed to save the properties back into the profile", hResult); <br> <br>ErrorExit: <br>    // Clean up <br>    if (pProfileObj) <br>    { <br>        pProfileObj-&gt;Release(); <br>    } <br>    if (gpfnFreeBuffer) <br>    { <br>        gpfnFreeBuffer (pProps); <br>    } <br>    if (hUIMutex) <br>    { <br>        ReleaseMutex (hUIMutex); <br>        CloseHandle (hUIMutex); <br>    } <br>    // In case the DLL was loaded, unload it. <br>    // This DLL gets loaded and initialized in the call to DoLogonDlg() <br>    PrivUninitialize3DCtl (hInstance); <br>     <br>    // If we have remote connections going on, close them now <br>    TerminateRemoteConnections(); <br> <br>    // Close down the traces <br>    UnInitTraces(); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DoLogonDlg() <br>// <br>//    Parameters <br>//      pCfgDialog   Pointer to an CFGDLG structure. <br>// <br>//    Purpose <br>//      This functions gets called to display the configuration properties for <br>//      this transport. When invoked, it will parse the transport logon  <br>//      property array and initialize the fields in the property sheet with it. <br>//      The function could also get invoked to display the settings in  <br>//      READ-ONLY mode in which case we disable writing to the editable fields. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI DoLogonDlg (PCFGDLG pCfgDialog) <br>{ <br>    DWORD dwWait = WaitForSingleObject (pCfgDialog-&gt;hUIMutex, 1000); // Wait for the MUTEX for 1 second <br>    PrivInitialize3DCtl (pCfgDialog-&gt;hInst); <br>    if (WAIT_TIMEOUT == dwWait) <br>    { <br>        PrivateMessageBox (IDS_MSG_CONFIG_UI_IN_USE, pCfgDialog-&gt;hWnd); <br>        return MAPI_E_BUSY; <br>    } <br> <br>    LPMAPITABLE pTableObj= NULL; <br>    ULONG ulPropCount; <br>    SizedSPropTagArray(NUM_LOGON_PROPERTIES, sptCfgProps); <br>    CopyMemory (&amp;sptCfgProps, &amp;sptLogonProps, sizeof(sptLogonProps)); <br>    sptCfgProps.aulPropTag[UPLOAD_TIME] = PR_TMP_UPLOAD_TIME; <br>     <br>    // Take ownership of the property value array, so calling code <br>    // will not leak memory <br>    LPSPropValue pProps = *pCfgDialog-&gt;ppProps; <br>    *pCfgDialog-&gt;ppProps = NULL; <br>     <br>    // Retrieve the dialog title string <br>    TCHAR szDialogTitle[64], szTimeString[32]; <br>    LoadString (pCfgDialog-&gt;hInst, IDS_SERVICE_PROPERTY_SHEETS_TITLE, szDialogTitle, 64); <br>    CUIMAPIProp * pPropObj = NULL; <br>    HRESULT hResult = S_OK; <br>    try <br>    { <br>        pPropObj = new CUIMAPIProp (pCfgDialog-&gt;hInst, <br>                                    gpfnAllocateBuffer, <br>                                    gpfnAllocateMore, <br>                                    gpfnFreeBuffer, <br>                                    pCfgDialog-&gt;ulFlags &amp; UI_READONLY); <br>        if (!pPropObj) <br>        { <br>            hResult = E_OUTOFMEMORY; <br>        } <br>    } <br>    catch (CException &amp; Exception) <br>    { <br>        hResult = Exception.GetError(); <br>    } <br>    if (hResult) <br>    { <br>        goto ErrorExit; <br>    } <br> <br>    ASSERT (PR_SMP_UPLOAD_TIME == pProps[UPLOAD_TIME].ulPropTag); <br>    GetTimeString (szTimeString, pProps[UPLOAD_TIME].Value.ft); <br>    pProps[UPLOAD_TIME].ulPropTag = PR_TMP_UPLOAD_TIME; <br>    pProps[UPLOAD_TIME].Value.LPSZ = szTimeString; <br> <br>    hResult = pPropObj-&gt;SetProps (NUM_LOGON_PROPERTIES, pProps, NULL); <br>    if (hResult) <br>    { <br>        TraceResult ("DoLogonDlg: Failed to set the properties", hResult); <br>        goto ErrorExit; <br>    } <br>    DTPAGE DtPropPages[2]; <br>    DtPropPages[0].cctl = NUM_CFG_USERINFO_PAGE_CTLS;   // Count of controls in the ConfigPage array <br>    DtPropPages[0].lpszComponent = szBlank; <br>    DtPropPages[0].lpszResourceName = MAKEINTRESOURCE (IDD_CFG_USERINFO); <br>    DtPropPages[0].lpctl = UserConfigPage; <br> <br>    DtPropPages[1].cctl = sizeof(XPConfigPage)/sizeof(DTCTL);   // Count of controls in the ConfigPage array <br>    DtPropPages[1].lpszComponent = szBlank; <br>    DtPropPages[1].lpszResourceName = MAKEINTRESOURCE (IDD_CFG_XPCONNECT); <br>    DtPropPages[1].lpctl = XPConfigPage; <br> <br>    // If the UI_READONLY flag is set, then we are being called from the  <br>    // SettingDialog method in Read Only mode. Disable all of the controls <br>    // on the property sheets, else Enable them <br>    if (pCfgDialog-&gt;ulFlags &amp; UI_READONLY) <br>    { <br>        // Disable the controls (make them read-only) <br>        DtPropPages[0].lpctl[1].ulCtlFlags &amp;= ~(DT_EDITABLE | DT_SET_IMMEDIATE); <br>        DtPropPages[0].lpctl[7].ulCtlFlags &amp;= ~(DT_EDITABLE | DT_SET_IMMEDIATE); <br>        DtPropPages[1].lpctl[1].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        DtPropPages[1].lpctl[2].ulCtlFlags &amp;= ~DT_EDITABLE; <br>    } <br>    else <br>    { <br>        // Enable the controls (make them read/write) <br>        DtPropPages[0].lpctl[1].ulCtlFlags |= (DT_EDITABLE | DT_SET_IMMEDIATE); <br>        DtPropPages[0].lpctl[7].ulCtlFlags |= (DT_EDITABLE | DT_SET_IMMEDIATE); <br>        DtPropPages[1].lpctl[1].ulCtlFlags |= DT_EDITABLE; <br>        DtPropPages[1].lpctl[2].ulCtlFlags |= DT_EDITABLE; <br>    } <br> <br>    // Create the display table for the logon dialog. It is based on dialog <br>    // resources plus the static information at the head of this module. <br>    LPTABLEDATA pTableData; <br>    hResult = BuildDisplayTable (gpfnAllocateBuffer, <br>                                 gpfnAllocateMore, <br>                                 gpfnFreeBuffer, <br>                                 NULL, <br>                                 pCfgDialog-&gt;hInst, <br>                                 sizeof(DtPropPages)/sizeof(DTPAGE), <br>                                 DtPropPages, <br>                                 fMapiUnicode, <br>                                 &amp;pTableObj, <br>                                 &amp;pTableData); <br>    if (!hResult) <br>    { <br>        pPropObj-&gt;SetTableData (pTableData); <br>        pTableData-&gt;Release(); <br> <br>        // Display the dialog/property sheets <br>DisplayPropsAgain: <br>        hResult = pCfgDialog-&gt;pSupObj-&gt;DoConfigPropsheet ((ULONG)pCfgDialog-&gt;hWnd, <br>                                                          0, <br>                                                          szDialogTitle, <br>                                                          pTableObj, <br>                                                          pPropObj, <br>                                                          0);     // Default index for the top property sheet <br>        if (!hResult) <br>        { <br>            // Retrieve the altered data <br>            gpfnFreeBuffer (pProps); <br>            pProps = NULL; <br>            hResult = pPropObj-&gt;GetProps ((LPSPropTagArray)&amp;sptCfgProps, fMapiUnicode, &amp;ulPropCount, &amp;pProps); <br>            if (hResult) <br>            { <br>                if (MAPI_W_ERRORS_RETURNED == hResult) <br>                { <br>                    if (PR_TMP_UPLOAD_TIME != pProps[UPLOAD_TIME].ulPropTag) <br>                    { <br>                        pProps[UPLOAD_TIME].ulPropTag = PR_TMP_UPLOAD_TIME; <br>                        pProps[UPLOAD_TIME].Value.LPSZ = szDefaultTime; <br>                    } <br>                    hResult = S_OK; <br>                } <br>                else <br>                { <br>                    TraceResult ("DoLogonDlg: GetProps failed", hResult); <br>                    goto ErrorExit; <br>                } <br>            } <br>            // Check the Server name <br>            if (!IsValidServerName (pProps[SERVER_NAME].Value.LPSZ)) <br>            { <br>                gpfnFreeBuffer (pProps); <br>                pProps = NULL; <br>                PrivateMessageBox (IDS_MSG_INVALID_SERVER_NAME, pCfgDialog-&gt;hWnd); <br>                goto DisplayPropsAgain; <br>            } <br> <br>            ASSERT (PR_TMP_UPLOAD_TIME == pProps[UPLOAD_TIME].ulPropTag); <br>            SYSTEMTIME st; <br>            GetLocalTime (&amp;st); <br>            if (ParseTime (pProps[UPLOAD_TIME].Value.LPSZ, &amp;st.wHour, &amp;st.wMinute)) <br>            { <br>                pProps[UPLOAD_TIME].ulPropTag = PR_SMP_UPLOAD_TIME; <br>                SystemTimeToFileTime (&amp;st, &amp;pProps[UPLOAD_TIME].Value.ft); <br>            } <br>            else <br>            { <br>                gpfnFreeBuffer (pProps); <br>                pProps = NULL; <br>                PrivateMessageBox (IDS_MSG_BAD_TIME_FORMAT, pCfgDialog-&gt;hWnd); <br>                goto DisplayPropsAgain; <br>            } <br> <br>            // Return the new property array <br>            *pCfgDialog-&gt;ppProps = pProps; <br>            pProps = NULL;      // do not free this in cleanup code below <br>        } <br>    } <br> <br>ErrorExit: <br>    // Release objects <br>    if (pTableObj) <br>    { <br>        pTableObj-&gt;Release(); <br>    } <br>    if (pPropObj) <br>    { <br>        pPropObj-&gt;Release(); <br>    }     <br>    gpfnFreeBuffer (pProps); <br>    PrivUninitialize3DCtl (pCfgDialog-&gt;hInst); <br>    ReleaseMutex (pCfgDialog-&gt;hUIMutex); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ParseTime() <br>// <br>//    Parameters                         <br>//      [IN]    pszTime     String in the form HH:MM. <br>//      [OUT]   pwHour      Hour of day, 0-23 <br>//      [OUT]   pwMinute    Minute of hour, 0-59 <br>// <br>//    Purpose <br>//      This function parses the string in pszTime and returns the numbers <br>//      for the hour and minute of day in a 24 hour clock format. <br>//       <br>//    Return Value <br>//      TRUE on success, FALSE if we failed or the string passed <br>//      in is invalid. <br>//       <br>BOOL WINAPI ParseTime (LPTSTR pszTime, WORD * pwHour, WORD * pwMinute) <br>{ <br>    TCHAR szTemp[6]; <br>    lstrcpy (szTemp, pszTime); <br>    LPTSTR pszSubStr = strtok(szTemp, TEXT(":")); <br>    if (!pszSubStr) <br>    { <br>        return FALSE; <br>    } <br>    *pwHour = atoi (pszSubStr); <br>    if (*pwHour &lt; 0 || *pwHour &gt; 23) <br>    { <br>        return FALSE; <br>    } <br>    pszSubStr = strtok (NULL, TEXT(" ")); <br>    if (!pszSubStr) <br>    { <br>        return FALSE; <br>    } <br>    *pwMinute = atoi(pszSubStr); <br>    if (*pwMinute &lt; 0 || *pwMinute &gt; 59) <br>    { <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetTimeString() <br>// <br>//    Parameters <br>//      [OUT]   pszTime     Pointer to a buffer where the function copies the <br>//                          formatted time string. The buffer must have been <br>//                          allocated by the caller. <br>//      [IN]    FileTime    FILETIME structure with the time for the string. <br>// <br>//    Purpose <br>//      This function returns a string formatted as "HH:MM" <br>//      The formatted string is returned in a buffer supplied by the caller <br>//      of the function. <br>//       <br>//    Return Value <br>//      None. <br>// <br>void WINAPI GetTimeString (LPTSTR pszTime, FILETIME FileTime) <br>{ <br>    // Convert the FILETIME structure to a more readable form <br>    SYSTEMTIME sysTime; <br>    FileTimeToSystemTime (&amp;FileTime, &amp;sysTime); <br>    wsprintf (pszTime, TEXT("%d:%02d"), sysTime.wHour, sysTime.wMinute); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetMAPIError() <br>// <br>//    Parameters <br>//      ppMAPIError             Pointer to a location where the newly <br>//                              allocated MAPIERROR structure is returened.  <br>//      ulFlags                 Flags for the allocation of the structure <br>//      hError                  Handle to the error for which a string will <br>//                              be returned <br>//      hInstance               Handle to instance of DLL where the resource <br>//                              strings are located <br>// <br>//    Purpose <br>//      This provider implements a shared function for the two different <br>//      GetLastError methods in the IMAPIFolder and IMAPIStatus interfaces. <br>//      These interfaces do not maintain (cached) the last error result, so <br>//      we trust the client that the hError passed in is indeed the last error. <br>//      This simplifies implementation of GetLastError, but it will give up <br>//      giving error strings on the exact context of the actual last error <br>//      in the case a client passes the wrong hResult. <br>//      ISV's should weight the benefits and trade-off of this implementation. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI GetMAPIError (LPMAPIERROR *          ppMAPIError, <br>                             ULONG                  ulFlags, <br>                             HRESULT                hError, <br>                             HINSTANCE              hInstance) <br>{ <br>    // The following array maps a string identifier (IDS) to an hResult <br>    // The order of HRESULTs in the array has an external dependency: <br>    // the order of elements in the array is dictated by the IDS definitions <br>    // in RESOURCE.H. This implicit association must be maintained for the  <br>    // strings associated with string identifiers to make sense. Thus, if  <br>    // either this structure or the RESOURCE.H defines changes, the other  <br>    // must change to match it <br>    static const HRESULT MapOfhResults[] = <br>    { <br>        S_OK, <br> <br>        E_FAIL, <br>        E_OUTOFMEMORY, <br>        E_INVALIDARG, <br>        E_NOINTERFACE, <br>        E_ACCESSDENIED, <br> <br>        MAPI_E_BUSY, <br>        MAPI_E_NO_SUPPORT, <br>        MAPI_E_NOT_FOUND, <br>        MAPI_E_UNKNOWN_FLAGS, <br>        MAPI_E_VERSION, <br>        MAPI_E_INVALID_ENTRYID, <br>        MAPI_E_USER_CANCEL, <br>        MAPI_E_DISK_ERROR, <br>        MAPI_E_CORRUPT_DATA, <br>        MAPI_E_BAD_CHARWIDTH, <br>        MAPI_E_UNCONFIGURED, <br>         <br> <br>        CO_E_NOTINITIALIZED,    // This error could only be comming from the server <br> <br>        MAPI_W_ERRORS_RETURNED <br>    }; <br> <br>    // Default the a return value in case we don't have the specified error <br>    // Allocate the memory for the MAPIERROR structure. The caller is <br>    // responsible for free this <br>    HRESULT hResult = gpfnAllocateBuffer (sizeof(MAPIERROR), (LPVOID *)ppMAPIError); <br>    if (hResult) <br>    { <br>        TraceResult ("GetMAPIError: Failed to allocate memory for the MAPIERROR structure", hResult); <br>        return hResult; <br>    } <br> <br>    // Zero-out all the members in the structure <br>    ZeroMemory (*ppMAPIError, sizeof(MAPIERROR)); <br>    (*ppMAPIError)-&gt;ulVersion = MAPI_ERROR_VERSION; <br>    // See if we have the string for the error. If so, make a copy  <br>    // and pass it back. The memory for the string will be linked to <br>    // the memory of the structure so that the caller can make a <br>    // single release on the structure <br>     <br>    // Search for the hResult in the HRESULT map <br>    UINT i, uMaxNum, uStringID; <br>    uStringID = 0; <br>    uMaxNum = sizeof (MapOfhResults) / sizeof (HRESULT); <br>    for (i=0; i&lt;uMaxNum; i++ ) <br>    { <br>        if (MapOfhResults[i] == hError) <br>        { <br>            break; <br>        } <br>    } <br> <br>    if (i == uMaxNum) <br>    { <br>        (*ppMAPIError)-&gt;ulLowLevelError = LOWORD(hError); <br>        if (HRESULT_FACILITY(hError) == FACILITY_RPC) <br>        { <br>            uStringID = IDS_RPC_ERROR; <br>        } <br>        else <br>        { <br>            if (HRESULT_FACILITY(hError) == FACILITY_WIN32 || <br>                HRESULT_FACILITY(hError) == FACILITY_NULL) <br>            { <br>                uStringID = IDS_SYSTEM_ERROR; <br>            } <br>            else <br>            { <br>                uStringID = IDS_E_UNKNOWN_ERROR; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        uStringID = i + IDS_SUCCESS; <br>    } <br>     <br>    TCHAR szBuffer[512]; <br>    int nCharsRead = LoadString (hInstance, uStringID, szBuffer, sizeof(szBuffer) -1); <br>    if (!nCharsRead) <br>    { <br>        TraceString1 ("GetMAPIError: Could not find error string for ID %d", uStringID); <br>        hResult = MAPI_E_NOT_FOUND; <br>    } <br>    else <br>    { <br>        // Allocate memory for return variable and set it. <br>        // The memory for this string is linked to the memory in the pMemBlock parameter <br>        hResult = gpfnAllocateMore (Cbtszsize (szBuffer), <br>                                    *ppMAPIError, <br>                                    (LPVOID *)&amp;(*ppMAPIError)-&gt;lpszError); <br>        if (!hResult) <br>        { <br>            lstrcpy ((*ppMAPIError)-&gt;lpszError, szBuffer); <br>            hResult = gpfnAllocateMore (Cbtszsize (TRANSPORT_DISPLAY_NAME_STRING), <br>                                        *ppMAPIError, <br>                                        (LPVOID *)&amp;(*ppMAPIError)-&gt;lpszComponent); <br>            if (!hResult) <br>            { <br>                lstrcpy ((*ppMAPIError)-&gt;lpszComponent, TRANSPORT_DISPLAY_NAME_STRING); <br>            } <br>            else <br>            { <br>                TraceResult ("GetMAPIError: Failed to allocate the memory for the component string", hResult); <br>            } <br>        } <br>        else <br>        { <br>            TraceResult ("GetMAPIError: Failed to allocate the memory for the error string", hResult); <br>        } <br>    } <br> <br>    if (hResult) <br>    { <br>        gpfnFreeBuffer (*ppMAPIError); <br>        *ppMAPIError = NULL; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    XPProviderInit() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Entry point called by the MAPI spooler when a profile uses this  <br>//      transport. The spooler calls this method and expects a pointer to an <br>//      implementation of the IXPProvider interface. MAPI uses the returned <br>//      IXPProvider interface pointer to logon on the transport provider <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDINITMETHODIMP XPProviderInit (HINSTANCE          hInstance,  <br>                                 LPMALLOC           pMallocObj, <br>                                 LPALLOCATEBUFFER   pfnAllocateBuffer, <br>                                 LPALLOCATEMORE     pfnAllocateMore, <br>                                 LPFREEBUFFER       pfnFreeBuffer, <br>                                 ULONG              ulFlags, <br>                                 ULONG              ulMAPIVer, <br>                                 ULONG *            pulProviderVer, <br>                                 LPXPPROVIDER *     ppXPProviderObj) <br>{ <br>    // Look at TRACES.H and TRACES.CPP for more options to the InitTraces() function <br>    //InitTraces (0);                                       // Send output only to the COM1 port <br>    InitTraces (TRACES_CONSOLE | TRACES_NO_COM_OUTPUT);     // Send output to a console window BUT NOT to the COM1 <br>    //InitTraces (TRACES_CONSOLE | TRACES_LOG_FILE);        // Send output to COM1 port AND a console window AND to a log file in C:\MAPILOG.TXT <br>    InfoTrace ("XPProviderInit function called"); <br>    *pulProviderVer = CURRENT_SPI_VERSION; <br>    if (ulMAPIVer &lt; CURRENT_SPI_VERSION) <br>    { <br>        TraceMessage ("XPProviderInit: The version of the subsystem cannot handle this version of the provider"); <br>        return MAPI_E_VERSION; <br>    } <br>    // Save the pointer to the allocation routines in global variables <br>    gpfnAllocateBuffer = pfnAllocateBuffer; <br>    gpfnAllocateMore   = pfnAllocateMore; <br>    gpfnFreeBuffer     = pfnFreeBuffer; <br>    ghInstance         = hInstance; <br>    // Allocate a new XPProvider object, the constructor will initialize the data member <br>    CXPProvider * pXPProvider = new CXPProvider (hInstance); <br>    if (!pXPProvider) <br>    { <br>        TraceMessage ("XPProviderInit: Failed to allocate a new CXPProvider object"); <br>        return E_OUTOFMEMORY; <br>    } <br>    // Copy pointer to the allocated object back into the return IXPProvider object pointer <br>    *ppXPProviderObj = (LPXPPROVIDER)pXPProvider;         <br>    return S_OK; <br>} <br> <br>// End of file for XPSRVCE.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
