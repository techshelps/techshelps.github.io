<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMWINDS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2203"></a>COMWINDS.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      COMWINDS.CPP <br>// <br>//  Description <br>//      This file implement the RPC code to talk to the WINDS Sample Server <br>//      Messaging Host. <br>//      Here we also implement common code used by providers in the service <br>//      that talking to WINDS and that share similiar configuration UI. <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "COMWINDS.H" <br> <br>// Remark this line to turn verbose tracing OFF <br>#define DO_INFO_TRACES <br>#ifdef DO_INFO_TRACES <br>#define InfoTrace(a)   TraceInfoMessage(a) <br>#else <br>#define InfoTrace(a)    <br>#endif // DO_INFO_TRACES <br> <br>typedef struct tagSELECTED_MAILBOX_INFO <br>{ <br>    HANDLE  hPipe; <br>    HRESULT hLastError; <br>    LPTSTR  szMailBoxName; <br>    LPTSTR  szDisplayName; <br>    LPTSTR  szPassword; <br>    DWORD * pdwMailboxID; <br>} SELECTED_MAILBOX_INFO; <br> <br>HINSTANCE ghUIControl = NULL; <br>typedef BOOL (WINAPI CTL3DFUNCTION) (HINSTANCE hInstance); <br>typedef CTL3DFUNCTION *LPCTL3DFUNCTION; <br>typedef BOOL (WINAPI CTL3DSUBCLASS) (HWND hDlg, DWORD dwFlags); <br>typedef CTL3DSUBCLASS *LPCTL3DSUBCLASS; <br> <br>LPCTL3DFUNCTION pfn3DRegister = NULL, pfn3DUnregister = NULL, pfn3DAutoSubclass = NULL; <br>LPCTL3DSUBCLASS pfnDlgSubclassEx = NULL; <br> <br>LPFREEBUFFER pfnMAPIFreeBuffer; <br> <br>extern "C" <br>{ <br>    void STDAPICALLTYPE BrowseMailboxes <br>                    (CUIMAPIProp *              pObj, <br>                     HWND                       hOwnerWnd, <br>                     HINSTANCE                  hInstance); <br>    void STDAPICALLTYPE ConfigChangePassword <br>                    (CUIMAPIProp *              pObj, <br>                     HWND                       hOwnerWnd, <br>                     HINSTANCE                  hInstance); <br>    HRESULT WINAPI ShowServerAccounts <br>                    (HWND                       hOwnerWnd, <br>                     HINSTANCE                  hInstance, <br>                     LPTSTR                     szServerName, <br>                     LPTSTR                     szMailboxName, <br>                     LPTSTR                     szFullName, <br>                     LPTSTR                     szPassword, <br>                     DWORD *                    pdwMailboxID); <br>    BOOL CALLBACK PasswordDlgProc <br>                    (HWND                       hDlg, <br>                     UINT                       message, <br>                     WPARAM                     wParam,  <br>                     LPARAM                     lParam); <br>    BOOL CALLBACK EnterMBPasswordDlgProc <br>                    (HWND                       hDlg, <br>                     UINT                       message, <br>                     WPARAM                     wParam,  <br>                     LPARAM                     lParam); <br>    BOOL CALLBACK SelectMailBoxDlgProc <br>                    (HWND                       hDlg, <br>                     UINT                       message, <br>                     WPARAM                     wParam,  <br>                     LPARAM                     lParam); <br>    void WINAPI TogglePage <br>                    (HWND                       hDlg, <br>                     UINT                       iPage, <br>                     BOOL                       fState);                     <br>    HRESULT WINAPI LogonServerMailbox <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szMailboxName, <br>                     LPTSTR                     szDisplayName, <br>                     LPTSTR                     szPassword, <br>                     DWORD *                    pdwMailboxID); <br>}; <br> <br>HRESULT WINAPI LogonServerMailboxAndSetNotif <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szMailboxName, <br>                     LPTSTR                     szDisplayName, <br>                     LPTSTR                     szPassword, <br>                     DWORD *                    pdwMailboxID, <br>                     DWORD                      dwNotifMask, <br>                     DWORD &amp;                    dwConnectID); <br> <br>// Static data for the transport provider configuration property sheets <br>TCHAR szFilter[] = TEXT("*"); // "*" to allow any character <br>TCHAR szTimeFilter[] = TEXT("[0-9:]"); <br>TCHAR szPhoneFilter[] = TEXT("[0-9-]"); <br>TCHAR szBlank[] = TEXT(""); <br> <br>extern TCHAR gszProviderName[]; <br> <br>// Control description structures <br>DTBLLABEL       DtLabel      = { sizeof(DTBLLABEL),       fMapiUnicode}; <br>DTBLGROUPBOX    DtGroupBox   = { sizeof(DTBLGROUPBOX),    fMapiUnicode}; <br>DTBLPAGE        DtPage       = { sizeof(DTBLPAGE),        fMapiUnicode}; <br>DTBLEDIT        DtServer     = { sizeof(DTBLEDIT),        fMapiUnicode, MAX_STRING_SIZE, PR_SMP_REMOTE_SERVER}; <br>DTBLEDIT        DtUserName   = { sizeof(DTBLEDIT),        fMapiUnicode, MAX_STRING_SIZE, PR_SMP_USER_NAME}; <br>DTBLEDIT        DtMBAlias    = { sizeof(DTBLEDIT),        fMapiUnicode, MAX_ALIAS_SIZE,  PR_SMP_MAILBOX_NAME}; <br>DTBLBUTTON      DtBrowseMB   = { sizeof(DTBLBUTTON),      fMapiUnicode, PR_SMP_BROWSE_MB}; <br>DTBLBUTTON      DtChangePW   = { sizeof(DTBLBUTTON),      fMapiUnicode, PR_SMP_CHANGE_PASSWORD}; <br>DTBLRADIOBUTTON DtLANConnect = { sizeof(DTBLRADIOBUTTON), fMapiUnicode, 2, PR_SMP_CONNECTION_TYPE, LAN_CONNECT }; <br>DTBLRADIOBUTTON DtREMConnect = { sizeof(DTBLRADIOBUTTON), fMapiUnicode, 2, PR_SMP_CONNECTION_TYPE, OFFLINE_CONNECT }; <br> <br>// Keys for field the we are going to update dynamically and we <br>// want MAPI's property pages to pick the changes on thes <br>#define ALIAS_KEY_VALUE     "UI_CONTROL_ALIAS" <br>#define ALIAS_KEY           ((LPBYTE)ALIAS_KEY_VALUE) <br>#define CB_ALIAS_KEY        sizeof(ALIAS_KEY_VALUE) <br> <br>#define NAME_KEY_VALUE      "UI_CONTROL_NAME" <br>#define NAME_KEY            ((LPBYTE)NAME_KEY_VALUE) <br>#define CB_NAME_KEY         sizeof(NAME_KEY_VALUE) <br> <br>// Description table for the controls <br>DTCTL UserConfigPage[] = <br>{ <br>    { DTCT_PAGE,        0,           NULL,      0,            NULL,     0,                   &amp;DtPage       }, <br>    { DTCT_EDIT,        DT_REQUIRED, NULL,      0,            szFilter, IDC_SERVERNAME,      &amp;DtServer     }, <br>    { DTCT_EDIT,        DT_REQUIRED, ALIAS_KEY, CB_ALIAS_KEY, szFilter, IDC_MAILBOXNAME,     &amp;DtMBAlias    }, <br>    { DTCT_BUTTON,      0,           NULL,      0,            NULL,     IDC_BROWSE_MB,       &amp;DtBrowseMB   }, <br>    { DTCT_EDIT,        DT_REQUIRED, NAME_KEY,  CB_NAME_KEY,  szFilter, IDC_USER_NAME,       &amp;DtUserName   }, <br>    { DTCT_BUTTON,      0,           NULL,      0,            NULL,     IDC_CHANGE_PASSWORD, &amp;DtChangePW   }, <br>    { DTCT_RADIOBUTTON, DT_SET_IMMEDIATE,NULL,  0,            NULL,     IDC_CONNECT_ONLINE,  &amp;DtLANConnect }, <br>    { DTCT_RADIOBUTTON, DT_SET_IMMEDIATE,NULL,  0,            NULL,     IDC_CONNECT_OFFLINE, &amp;DtREMConnect }, <br>    { DTCT_LABEL,       0,           NULL,      0,            NULL,     IDC_STATIC1,         &amp;DtLabel      }, <br>    { DTCT_LABEL,       0,           NULL,      0,            NULL,     IDC_STATIC2,         &amp;DtLabel      }, <br>    { DTCT_GROUPBOX,    0,           NULL,      0,            NULL,     IDC_STATIC3,         &amp;DtGroupBox   }, <br>    { DTCT_GROUPBOX,    0,           NULL,      0,            NULL,     IDC_STATIC4,         &amp;DtGroupBox   }, <br>    { DTCT_GROUPBOX,    0,           NULL,      0,            NULL,     IDC_STATIC5,         &amp;DtGroupBox   } <br>}; <br> <br>// Global data used in the WizardDlgProc function <br>LPMAPIPROP pPropObj = NULL; <br>BOOL fInitalizeControls, fDownloadMBList; <br> <br>extern "C" <br>{ <br>    HINSTANCE            ghInstance = NULL; <br>    WIZARDENTRY          WizardEntry;     <br>    SERVICEWIZARDDLGPROC WizardDlgProc;    <br>}; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    IsWINDSServerAvailable() <br>// <br>//    Parameters <br>//      szServer        Pointer to a string with the name of the remote <br>//                      server to verify <br>// <br>//    Purpose <br>//      This functions makes remote procedure call to a server to make sure <br>//      the remote machine is available. <br>//      The remote server must be running the WINDS sample server messaging <br>//      host because that is the server procedure that will answer the <br>//      RPC call. <br>// <br>//    Return Value <br>//      TRUE if the server was found, FALSE otherwise. <br>// <br>BOOL WINAPI IsWINDSServerAvailable (LPTSTR szServer) <br>{ <br>    // We the user didn't supply a server, then fail. <br>    if (!szServer) <br>    { <br>        TraceMessage ("IsWINDSServerAvailable: No server name?"); <br>        return FALSE; <br>    } <br>    HCURSOR hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT)); <br>    // Before we make an RPC call, we must initialize the RPC runtime <br>    // binding handle with the server <br>    HRESULT hResult = BindToServer (szServer); <br>    if (!hResult) <br>    { <br>        RpcTryExcept <br>        { <br>            // Call the server. <br>            hResult = RemoteIsServerRunning(); <br>        } <br>        RpcExcept(1) <br>        { <br>            // If we got here is because there was an error while call was made <br>            // or when it was about to be made. <br>            hResult = RpcExceptionCode(); <br>            if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>            { <br>                hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>            } <br>            else <br>            { <br>                hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>            } <br>        } <br>        RpcEndExcept <br>        TraceResult ("IsWINDServerAvailable", hResult); <br>    } <br>    SetCursor (hCursor); <br>    return (S_OK == hResult ? TRUE : FALSE); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ShowServerAccounts() <br>// <br>//    Parameters <br>//      hOwnerWnd       Handle to a parent window. If NULL we don't display a <br>//                      list of available mailboxes in the server. <br>//      hInstance       Handle to the instance of the DLL where the dialog <br>//                      resource is located <br>//      szServerName    Name of the server we are going to make an RPC call to <br>//      szMailboxName   Where we return the name of the mailbox selected. <br>//      szFullName      Where we return the name of the owner of the <br>//                      mailbox seleted. <br>//      szPassword      Where we return the password of the mailbox seleted <br>//      pdwMailboxID    Where we return the ID of the mailbox seleted <br>// <br>//    Purpose <br>//      This function displays a list of available mailboxes in the server. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI ShowServerAccounts (HWND        hOwnerWnd, <br>                                   HINSTANCE   hInstance, <br>                                   LPTSTR      szServerName, <br>                                   LPTSTR      szMailboxName, <br>                                   LPTSTR      szFullName, <br>                                   LPTSTR      szPassword, <br>                                   DWORD *     pdwMailboxID) <br>{ <br>    ASSERT (hOwnerWnd); <br>    ASSERT (hInstance); <br>    ASSERT (szServerName); <br>    ASSERT (szMailboxName); <br>    ASSERT (szFullName); <br>    ASSERT (szPassword); <br>    ASSERT (pdwMailboxID); <br>    HRESULT hResult = BindToServer (szServerName); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    long lPipeNumber; <br>    HANDLE hPipe; <br>    TCHAR szPipeName[64]; <br>    SELECTED_MAILBOX_INFO info = { 0 }; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteGetAllAccounts (&amp;lPipeNumber); <br>        if (S_OK == hResult) <br>        { <br>            wsprintf (szPipeName, PIPE_NAME_FORMAT, szServerName, lPipeNumber); <br>            hPipe = CreateFile (szPipeName, <br>                                GENERIC_READ, <br>                                0, <br>                                NULL, <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL); <br>            if (INVALID_HANDLE_VALUE == hPipe) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("ShowServerAccounts: Failed to open pipe to server", hResult); <br>            } <br>            else <br>            { <br>                info.hPipe = hPipe; <br>                info.hLastError = E_FAIL; <br>                info.szDisplayName = szFullName; <br>                info.szMailBoxName = szMailboxName; <br>                info.szPassword = szPassword; <br>                info.pdwMailboxID = pdwMailboxID; <br>                hResult = DialogBoxParam (hInstance, <br>                                          MAKEINTRESOURCE(IDD_SELECTMB), <br>                                          hOwnerWnd, <br>                                          SelectMailBoxDlgProc, <br>                                          (LPARAM)&amp;info); <br>                if (-1 == hResult) <br>                { <br>                    hResult = info.hLastError; <br>                } <br>                else <br>                { <br>                    if (FALSE == hResult) <br>                    { <br>                        hResult = MAPI_E_USER_CANCEL; <br>                    } <br>                    else <br>                    { <br>                        hResult = S_OK; <br>                    } <br>                } <br>                CloseHandle (hPipe); <br>            } <br>        } <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    TraceResult ("ShowServerAccounts", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    LogonServerMailbox() <br>// <br>//    Parameters <br>//      szServerName        Name of the server where are connecting to. <br>//      szMailboxName       Name of the mailbox we are attempting to access <br>//      szDisplayName       Name of the owner of the mailbox <br>//      szPassword          Password to access the mailbox <br>//      pdwMailboxID        Where we return the ID of the mailbox as stored <br>//                          on the server <br>// <br>//    Purpose <br>//      This function makes a connection to the remote server and makes sure <br>//      we can access it with the given password. Upon success, the remote <br>//      call returns us the full name of the owner of the mailbox and the <br>//      ID of the recipient. <br>//       <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI LogonServerMailbox (LPTSTR   szServerName, <br>                                   LPTSTR   szMailboxName, <br>                                   LPTSTR   szDisplayName, <br>                                   LPTSTR   szPassword, <br>                                   DWORD *  pdwMailboxID) <br>{ <br>    ASSERT (szServerName); <br>    ASSERT (szMailboxName); <br>    ASSERT (szDisplayName); <br>    ASSERT (szPassword); <br>    ASSERT (pdwMailboxID); <br>    HRESULT hResult = BindToServer (szServerName); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteLogonMailBox ((WINDS_RPC_STRING)szMailboxName, <br>                                      (WINDS_RPC_STRING)szPassword, <br>                                      (WINDS_RPC_STRING)szDisplayName, <br>                                      pdwMailboxID); <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    TraceResult ("LogonServerMailbox", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    LogonServerMailboxAndSetNotif() <br>// <br>//    Parameters <br>//      szServerName       Name of the server where are connecting to. <br>//      szMailboxName      Name of the mailbox we are attempting to access <br>//      szDisplayName      Name of the owner of the mailbox <br>//      szPassword         Password to access the mailbox <br>//      pdwMailboxID        Where we return the ID of the mailbox as stored <br>//                          on the server <br>//      dwNotifMask         Mask of events the loggin service is intersted in. <br>//      dwConnectID         Where we return the connection number the server <br>//                          assigned to us. <br>// <br>//    Purpose <br>//      In addition to what LogonServerMailbox() does, this function also <br>//      instructs the remote server to set up a notification link with us <br>//      to advise us of changes in the server's data or the server state. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI LogonServerMailboxAndSetNotif (LPTSTR    szServerName, <br>                                              LPTSTR    szMailboxName, <br>                                              LPTSTR    szDisplayName, <br>                                              LPTSTR    szPassword, <br>                                              DWORD *   pdwMailboxID, <br>                                              DWORD     dwNotifMask, <br>                                              DWORD &amp;   dwConnectID) <br>{ <br>    ASSERT (szServerName); <br>    ASSERT (szMailboxName); <br>    ASSERT (szDisplayName); <br>    ASSERT (szPassword); <br>    ASSERT (pdwMailboxID); <br> <br>    // Get the computer name of us (the client) so that the server can <br>    // create the mailslot name appropiately. <br>    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1]; <br>    HRESULT hResult; <br>    DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH + 1; <br>    if (!GetComputerName (szComputerName, &amp;dwNameSize)) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("LogonServerMailboxAndSetNotif: Failed to get the computer name", hResult); <br>    } <br>    else <br>    { <br>        hResult = BindToServer (szServerName); <br>    } <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteLogonMailBoxAndSetNotif ((WINDS_RPC_STRING)szMailboxName, <br>                                                 (WINDS_RPC_STRING)szPassword, <br>                                                 (WINDS_RPC_STRING)szDisplayName, <br>                                                 pdwMailboxID, <br>                                                 (WINDS_RPC_STRING)szComputerName, <br>                                                 dwNotifMask, <br>                                                 &amp;dwConnectID); <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    TraceResult ("LogonServerMailboxAndSetNotif", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    TerminateServerNotifications() <br>// <br>//    Parameters <br>//      szServerName           Name of the server we want to terminate <br>//                              connections with. <br>//      dwConnectionID          Connection ID assigned to us in that server <br>// <br>//    Purpose <br>//      Tell the server that this provider is shutting down an it show remove <br>//      it from the list of advise clients. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI TerminateServerNotifications (LPTSTR     szServerName, <br>                                             DWORD      dwConnectionID) <br>{ <br>    // If the connection is zero, there is nothing to do here. <br>    if (0 == dwConnectionID) <br>    { <br>        return S_OK; <br>    } <br>    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1]; <br>    HRESULT hResult; <br>    DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH + 1; <br>    if (!GetComputerName (szComputerName, &amp;dwNameSize)) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("TerminateServerNotifications: Failed to get the computer name", hResult); <br>    } <br>    else <br>    { <br>        hResult = BindToServer (szServerName); <br>    } <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteTerminateNotif ((WINDS_RPC_STRING)szComputerName, dwConnectionID); <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    TraceResult ("TerminateServerNotifications", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ResetServerNotifications() <br>// <br>//    Parameters <br>//      szServerName        Name of the remote server <br>//      szMailboxName       Name of the owner mailbox where the notifations <br>//                          are set <br>//      dwNotifMask         Mask of events the service is interested in. <br>//      pdwConnectionID     Where the server returns the new connection number <br>// <br>//    Purpose <br>//      This function is called in response to a notification sent by the <br>//      server to advise clients that they need to reset the notification <br>//      because the old connection is no longer valid. <br>//      The server send this notification periodically to make sure the advise <br>//      client he sending notifications to are still around. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI ResetServerNotifications (LPTSTR     szServerName, <br>                                         LPTSTR     szMailboxName, <br>                                         DWORD      dwNotifMask, <br>                                         DWORD *    pdwConnectionID) <br>{ <br>    // The connections with the server is dead anyways so 0 the connection ID even we fail. <br>    *pdwConnectionID = 0; <br>    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1]; <br>    HRESULT hResult; <br>    DWORD dwNameSize = MAX_COMPUTERNAME_LENGTH + 1; <br>    if (!GetComputerName (szComputerName, &amp;dwNameSize)) <br>    { <br>        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>        TraceResult ("ResetServerNotifications: Failed to get the computer name", hResult); <br>    } <br>    else <br>    { <br>        hResult = BindToServer (szServerName); <br>    } <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteValidateNotif ((WINDS_RPC_STRING)szComputerName, <br>                                       (WINDS_RPC_STRING)szMailboxName, <br>                                       dwNotifMask, <br>                                       pdwConnectionID); <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    TraceResult ("ResetServerNotifications", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetHeadersFromServer() <br>// <br>//    Parameters <br>//      szServerName   Name of the server we are going to make an RPC call to <br>//      szMailbox      Mailbox for which we are going to retrieve the <br>//                      headers for. <br>//      szHeaderFile   The name of the local file where we will copy the <br>//                      message headers found in the remote mailbox <br>// <br>//    Purpose <br>//      This function makes an RPC call to the remote server host to retrieve <br>//      the message header information of a particular mailbox. The headers <br>//      found are save to a local file and then used to fill the contents <br>//      table of the remote folder object we return to a client remote <br>//      viewer application. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI GetHeadersFromServer (LPTSTR szServerName, <br>                                     LPTSTR szMailbox, <br>                                     LPTSTR szHeaderFile) <br>{ <br>    HANDLE hFile, hPipe; <br>    DWORD dwBytesWrite, dwBytesRead; <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    long lPipeNumber; <br>    HRESULT hResult = BindToServer (szServerName); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    HCURSOR hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT)); <br>    RpcTryExcept <br>    { <br>        hResult = RemoteOpenHeaderDownloadPipe ((WINDS_RPC_STRING)szMailbox, &amp;lPipeNumber); <br>        if (S_OK == hResult) <br>        { <br>            wsprintf ((LPTSTR)abBuffer, PIPE_NAME_FORMAT,szServerName, lPipeNumber); <br>            hPipe = CreateFile ((LPTSTR)abBuffer, <br>                                GENERIC_READ, <br>                                0, <br>                                NULL, <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL); <br>            if (INVALID_HANDLE_VALUE == hPipe) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("GetHeadersFromServer: Failed to open pipe to server", hResult); <br>            } <br>            else <br>            { <br>                hFile = CreateFile (szHeaderFile, <br>                                    GENERIC_WRITE, <br>                                    0, <br>                                    NULL, <br>                                    CREATE_ALWAYS, <br>                                    FILE_FLAG_SEQUENTIAL_SCAN, <br>                                    NULL); <br>                if (INVALID_HANDLE_VALUE == hFile) <br>                { <br>                    hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                    TraceResult ("GetHeadersFromServer: Failed to open local headers file", hResult); <br>                } <br>                else <br>                { <br>                    do <br>                    { <br>                        // Read the pipe handle. <br>                        if (!ReadFile (hPipe, abBuffer, IO_BUFFERSIZE, &amp;dwBytesRead, NULL)) <br>                        { <br>                            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                            if (HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE)   != hResult &amp;&amp;   // For Windows NT <br>                                HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hResult)     // For Windows 95 <br>                            { <br>                                // There was an error and we can't continue <br>                                TraceResult ("GetHeadersFromServer: Failed to read from the pipe", hResult); <br>                            } <br>                            else <br>                            { <br>                                // If the pipe was broken, it means the server finished writing <br>                                // to the it, so we are finished reading from it. <br>                                hResult = S_OK; <br>                            } <br>                        } <br>                        if (dwBytesRead) <br>                        { <br>                            if (!WriteFile (hFile, abBuffer, dwBytesRead, &amp;dwBytesWrite, NULL)) <br>                            { <br>                                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                                TraceResult ("GetHeadersFromServer: Failed to write to local header file", hResult); <br>                            } <br>                        } <br>                    } while (dwBytesRead &amp;&amp; !hResult); <br>                    CloseHandle (hFile); <br>                } <br>                CloseHandle (hPipe); <br>            } <br>        } <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    // Terminate connections with the remote server <br>    BindToServer (NULL); <br>    SetCursor (hCursor); <br>    TraceResult ("GetHeadersFromServer", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    OpenServerUploadPipe() <br>// <br>//    Parameters <br>//      hMsgFile            Handle to the local TNEF file with the message to <br>//                          upload <br>//      szServerName       String with the name of the remote server <br>//      szRecipMailbox     String with the name of the mailbox where the <br>//                          message will be uploaded. <br>// </code></pre>
<p>
</p>
<pre><code>//    Purpose <br>//      This function uploads a file to a server. The file must have been <br>//      opened by the caller and a handle to it must have been passed in <br>//      hMsgFile. The function will bind to the server (the name is is <br>//      szServerName). <br>//      This functions makes a remote procedure call to a server to request <br>//      the a pipe to upload the data through. <br>//      The remote server must be running the WINDS sample server messaging <br>//      host because that is the server procedure that will answer the <br>//      RPC call. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI OpenServerUploadPipe (LPTSTR     szServerName, <br>                                     LPTSTR     szSenderMailbox, <br>                                     HANDLE     hMsgFile, <br>                                     LPTSTR     szConnectionInfo, <br>                                     BOOL *     pfErrorInTheServer) <br>{ <br>    *pfErrorInTheServer = FALSE; <br>    HANDLE hPipe; <br>    char szPipeName[64]; <br>    DWORD dwBytesWrite, dwBytesRead; <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    long lPipeNumber, hResult = BindToServer (szServerName); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteOpenMsgUploadPipe ((WINDS_RPC_STRING)szSenderMailbox, <br>                                           &amp;lPipeNumber, <br>                                           (WINDS_RPC_STRING)szConnectionInfo); <br>        if (!hResult) <br>        { <br>            wsprintf (szPipeName, PIPE_NAME_FORMAT, szServerName, lPipeNumber); <br>            hPipe = CreateFile (szPipeName, <br>                                GENERIC_WRITE, <br>                                0, <br>                                NULL, <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL); <br>            if (INVALID_HANDLE_VALUE == hPipe) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("OpenServerUploadPipe: Failed to open pipe to server", hResult); <br>            } <br>            else <br>            { <br>                do <br>                { <br>                    if (!ReadFile (hMsgFile, abBuffer, IO_BUFFERSIZE, &amp;dwBytesRead, NULL)) <br>                    { <br>                        hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                        TraceResult ("OpenServerUploadPipe: Failed to read local msg file", hResult); <br>                    } <br>                    if (dwBytesRead) <br>                    { <br>                        if (!WriteFile (hPipe, abBuffer, dwBytesRead, &amp;dwBytesWrite, NULL)) <br>                        { <br>                            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                            TraceResult ("OpenServerUploadPipe: Failed to write to the pipe", hResult); <br>                        } <br>                    } <br>                } while (dwBytesRead &amp;&amp; !hResult); <br>                CloseHandle (hPipe); <br>            } <br>        } <br>        else <br>        { <br>            if (hResult) <br>            { <br>                *pfErrorInTheServer = TRUE; <br>            } <br>        } <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            *pfErrorInTheServer = TRUE; <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    TraceResult ("OpenServerUploadPipe", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    SendMsgToAccount() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI SendMsgToAccount (LPTSTR    szServerName, <br>                                 LPTSTR    szRecipMailbox, <br>                                 LPTSTR    szHeader, <br>                                 LPTSTR    szConnectionInfo, <br>                                 BOOL *    pfErrorInTheServer) <br>{ <br>    *pfErrorInTheServer = FALSE; <br>    long hResult = BindToServer (szServerName); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteSendMsgToAccount ((WINDS_RPC_STRING)szRecipMailbox, <br>                                          (WINDS_RPC_STRING)szHeader, <br>                                          (WINDS_RPC_STRING)szConnectionInfo); <br>        if (hResult) <br>        { <br>            *pfErrorInTheServer = TRUE; <br>        } <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            *pfErrorInTheServer = TRUE; <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    TraceResult ("SendMsgToAccount", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FinishUploadConnection() <br>// <br>//    Parameters <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI FinishUploadConnection (LPTSTR   szServerName, <br>                                       LPTSTR   szConnectionInfo) <br>{ <br>    long hResult = BindToServer (szServerName); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteFinishUpload ((WINDS_RPC_STRING)szConnectionInfo); <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    TraceResult ("FinishUploadConnection", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    OpenRemoteServerDownLoadPipe() <br>// <br>//    Parameters                         <br>//      szServer   Name of the server we are downloading the message from <br>//      szMBox     Name of the mailbox we are downloading from. <br>//      phPipe      Pointer where I return the handle to the opened named <br>//                  pipe to the server machine. <br>// <br>//    Purpose <br>//      Makes an RPC to the remote server which sets up a pipe <br>//      over which the download occurs. The RPC returns to the <br>//      client (us) the pipe's ID that the server creates. We <br>//      then connect to the pipe. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI OpenRemoteServerDownLoadPipe (LPTSTR     szServer, <br>                                             LPTSTR     szMBox, <br>                                             HANDLE *   phPipe) <br>{ <br>    ASSERT (szServer); <br>    ASSERT (szMBox); <br>    HRESULT hResult = BindToServer (szServer); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        ULONG ulPipeNum; <br>        hResult = RemoteOpenMsgDownloadPipe ((WINDS_RPC_STRING)szMBox, &amp;ulPipeNum); <br>        if (!hResult) <br>        { <br>            TCHAR szPipeName[_MAX_PATH]; <br>            HANDLE hPipe; <br>            // Construct the download pipe name <br>            wsprintf (szPipeName, PIPE_NAME_FORMAT, szServer, ulPipeNum); <br>            // Create our endpoint and connect     <br>            hPipe = CreateFile (szPipeName,  <br>                                GENERIC_READ | GENERIC_WRITE, <br>                                0, <br>                                NULL, <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL); <br>            if (INVALID_HANDLE_VALUE == hPipe) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>            } <br>            else <br>            { <br>                *phPipe = hPipe; <br>            } <br>        } <br>    } <br>    RpcExcept(1) <br>    {         <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    // Terminate connections with the remote server <br>    BindToServer (NULL); <br>    TraceResult ("OpenRemoteServerDownLoadPipe", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    SelectMailBoxDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//      Displays a dialog with all available mailboxes in the remote machine <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK SelectMailBoxDlgProc (HWND    hDlg, <br>                                    UINT    message, <br>                                    WPARAM  wParam,  <br>                                    LPARAM  lParam) <br>{ <br>    static SELECTED_MAILBOX_INFO * pInfo; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                HWND hCtl = GetDlgItem (hDlg, IDC_LIST); <br>                int nTabStops[3]; <br>                nTabStops[0] = 75; <br>                nTabStops[1] = 1000; // Off the screen <br>                nTabStops[2] = 1015; // Off the screen <br>                ListBox_SetTabStops (hCtl, sizeof(nTabStops)/sizeof(int), nTabStops); <br>                pInfo = (SELECTED_MAILBOX_INFO *)lParam; <br>                TCHAR szFormated[256]; <br>                AB_ENTRY_INFO abEntry = { 0 }; <br>                DWORD dwLastError = 0, dwBytesRead = 0; <br>                do <br>                { <br>                    // Read the pipe handle. <br>                    if (!ReadFile (pInfo-&gt;hPipe, &amp;abEntry, sizeof(AB_ENTRY_INFO), &amp;dwBytesRead, NULL)) <br>                    { <br>                        dwLastError = HRESULT_FROM_WIN32(GetLastError()); <br>                        if (HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE)   != dwLastError &amp;&amp;   // For Windows NT <br>                            HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != dwLastError)     // For Windows 95 <br>                        { <br>                            // There was an error and we can't continue <br>                            TraceResult ("SelectMailBoxDlgProc: Failed to read from the pipe", dwLastError); <br>                        } <br>                        else <br>                        { <br>                            // If the pipe was broken, it means the server finished writing <br>                            // to the it, so we are finished reading from it. <br>                            dwLastError = 0; <br>                        } <br>                    } <br>                    else <br>                    { <br>                        wsprintf (szFormated, <br>                                  TEXT("%s\t%s\t%s\t%d"), <br>                                  abEntry.Info.MB.szMailboxName, <br>                                  abEntry.Info.MB.szFullName, <br>                                  abEntry.Info.MB.szPassword, <br>                                  abEntry.Info.MB.dwObjID); <br>                        ListBox_AddString (hCtl, szFormated); <br>                    } <br>                } while (dwBytesRead &amp;&amp; !dwLastError); <br>                if (!dwLastError) <br>                { <br>                    if (pfnDlgSubclassEx) <br>                    { <br>                        pfnDlgSubclassEx (hDlg, CTL3D_ALL); <br>                    } <br>                    return TRUE; <br>                } <br>                pInfo-&gt;hLastError = dwLastError; <br>                EndDialog (hDlg, -1); <br>            } <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_LIST : <br>                    if (LBN_DBLCLK != HIWORD(wParam)) <br>                    { <br>                        break; <br>                    } <br>                case IDOK : <br>                    { <br>                        TCHAR szBuffer[256]; <br>                        LPTSTR pStr; <br>                        HWND hCtl = GetDlgItem (hDlg, IDC_LIST); <br>                        int i = ListBox_GetCurSel (hCtl); <br>                        if (i != LB_ERR) <br>                        { <br>                            ListBox_GetText (hCtl, i, szBuffer); <br>                            pStr = strtok (szBuffer, "\t"); <br>                            lstrcpy (pInfo-&gt;szMailBoxName, pStr); <br>                            pStr = strtok (NULL, "\t"); <br>                            lstrcpy (pInfo-&gt;szDisplayName, pStr); <br>                            pStr = strtok (NULL, "\t"); <br>                            lstrcpy (pInfo-&gt;szPassword, pStr); <br>                            pStr = strtok (NULL, "\t"); <br>                            *(pInfo-&gt;pdwMailboxID) = (DWORD)atol (pStr); <br>                        } <br>                        else <br>                        { <br>                            PrivateMessageBox (IDS_MSG_SELECT_MB_NAME, hDlg); <br>                            return FALSE; <br>                        } <br>                    } <br>                case IDCANCEL : <br>                    EndDialog (hDlg, (LOWORD(wParam) == IDCANCEL ? FALSE : TRUE)); <br>                    return TRUE; <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ChangeMBServerPassword() <br>// <br>//    Parameters <br>//      szServerName        Name of the server machine we are connecting to <br>//      szMailboxName       Name of the mailbox where the password will <br>//                          be changed. <br>//      szOldPassword       Old password of the mailbox <br>//      szNewPassword       New password for the mailbox <br>// <br>//    Purpose <br>//      Changes the access password in the specified mailbox in <br>//      the specified server. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI ChangeMBServerPassword (LPTSTR   szServerName, <br>                                       LPTSTR   szMailboxName, <br>                                       LPTSTR   szOldPassword, <br>                                       LPTSTR   szNewPassword) <br>{ <br>    if (BindToServer (szServerName)) <br>    { <br>        return FALSE; <br>    } <br>    HRESULT hResult; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteChangePassword ((WINDS_RPC_STRING)szMailboxName, <br>                                        (WINDS_RPC_STRING)szOldPassword, <br>                                        (WINDS_RPC_STRING)szNewPassword); <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    BindToServer (NULL); <br>    TraceResult ("ChangeMBServerPassword", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PrivateMessageBox() <br>// <br>//    Parameters <br>//      ids             String ID of a string in the resource string table <br>//      hOwnerWnd       Window who will own the Message Box <br>//      uFlags          Flags (options) for the message box <br>//       <br>//    Purpose <br>//      This function display a message box with a string loaded from the <br>//      string table of this app. The ID of the string is passed in the ids <br>//      parameter. The dialog box is modal with respect to the window <br>//      identified in hOwnerWnd. The options to display the dialog box are <br>//      passed in uFlags <br>//       <br>//    Return Value <br>//      ID of the button pressed in the message box dialog box <br>//       <br>int WINAPI PrivateMessageBox (UINT          ids, <br>                              HWND          hOwnerWnd, <br>                              UINT          uFlags, <br>                              HINSTANCE     hInst) <br>{ <br>    int nResponse = -1; // Default response <br>    // Get the string from the string table. The size of the buffer is the <br>    // maximum number of character allowed in the character buffer, without <br>    // the accounting for the NULL terminator <br>    if (NULL == hInst) <br>    { <br>        hInst = ghInstance; <br>    } <br>    ASSERT (hInst); <br>    TCHAR szBuffer[256]; <br>    if (LoadString (hInst, ids, szBuffer, 255)) <br>    { <br>        if (!(MB_ICONSTOP &amp; uFlags)) <br>        { <br>            uFlags |= MB_ICONINFORMATION; <br>        } <br>        // Show the message box and get the ID of the button pressed <br>        nResponse = MessageBox (hOwnerWnd, <br>                                szBuffer, <br>                                gszProviderName, <br>                                uFlags | <br>                                MB_SETFOREGROUND | <br>                                MB_SYSTEMMODAL); <br>    } <br>    return nResponse; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    IsValidServerName() <br>// <br>//    Parameters <br>//      szServerName       Pointer to a string with the UNC name of a <br>//                          network or local server <br>//    Purpose <br>//      Check the string for a server name and determines if the name is a <br>//      valid UNC name for a network server <br>// <br>//    Return Value <br>//      TRUE if the server name is valid, FALSE otherwise. <br>//       <br>BOOL WINAPI IsValidServerName (LPTSTR szServerName) <br>{ <br>    // Server name need to be at least "\\x" <br>    if (lstrlen(szServerName) &lt; 3) <br>    { <br>        return FALSE; <br>    } <br>    // The first two character in the string must be "\". This is standard <br>    // UNC (Universal Naming Convention) for server names <br>    if (szServerName[0] != '\\' || szServerName[1] != '\\') <br>    { <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    BindToServer() <br>// <br>//    Parameters <br>//      [IN]    szServer   Name of the remote server to which we will bind <br>//                          for RPC calls. If this pointer is NULL, we <br>//                          unbind from that server. <br>// <br>//    Purpose <br>//      This function makes the necessary calls to the RPC runtime library <br>//      to bind to the remote server so that we can start RPC function calls. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI BindToServer (LPTSTR szServer) <br>{ <br>    static unsigned char * szStringBinding = NULL; <br>    static char szLastServer[32] = { 0 }; <br> <br>    // If a server name was given, we compare to the current server that we are <br>    // already bounded to. If we are connected return the call. <br>    if (szServer) <br>    { <br>        if (0 == lstrcmpi (szLastServer, szServer)) <br>        { <br>            if (szStringBinding) <br>            { <br>                return 0; <br>            } <br>        } <br>        else <br>        { <br>            // Save the name of the server in the static buffer <br>            lstrcpy (szLastServer, szServer); <br>        } <br>    } <br> <br>    RPC_STATUS status = 0; <br>    if (szStringBinding) // Unbind only if bound <br>    { <br>        status = RpcStringFree (&amp;szStringBinding); <br>        TraceRPCError  ("BindToServer: RpcStringFree failed", status); <br>        if (!status) <br>        { <br>            szStringBinding = NULL; <br>            status = RpcBindingFree (&amp;hWINDSREM);  // hWINDSREM is defined in WINDS.H and WINDS.ACF <br>            TraceRPCError  ("BindToServer: RpcBindingFree failed", status); <br>        } <br>    } <br>    // If this is NULL, then we don't need to bind to anything. <br>    if (!szServer) <br>    { <br>        szLastServer[0] = 0; <br>        return 0; <br>    } <br>    if (!status) <br>    { <br>        status = RpcStringBindingCompose (NULL, <br>                                          (WINDS_RPC_STRING)WINDS_RPC_PROTOCOL, <br>                                          (WINDS_RPC_STRING)szServer, <br>                                          (WINDS_RPC_STRING)WINDS_PROVIDERS_RPC_ENDPOINT, <br>                                          NULL, <br>                                          &amp;szStringBinding); <br>        TraceRPCError  ("BindToServer: RpcStringBindingCompose failed", status); <br>        if (!status) <br>        { <br>            status = RpcBindingFromStringBinding (szStringBinding, &amp;hWINDSREM); // hWINDSREM is defined in WINDS.H and WINDS.ACF <br>            TraceRPCError ("BindToServer: RpcBindingFromStringBinding failed", status); <br>        } <br>    } <br>    if (status) <br>    { <br>        szLastServer[0] = 0; <br>        status = MAKE_HRESULT(1, FACILITY_RPC, status);; <br>    } <br>    return status; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    TerminateRemoteConnections() <br>// <br>//    Parameters <br>//      None. <br>// <br>//    Purpose <br>//      Termintes the binding links in the RPC runtime library to the remote <br>//      server after a sequence of RPC calls. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI TerminateRemoteConnections() <br>{ <br>    BindToServer (NULL); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    midl_user_allcate() <br>// <br>//    Parameters <br>//      len     Size (in bytes) of the memory block to allocate for the <br>//              RPC object <br>// <br>//    Purpose <br>//      Allocates memory as needed by the RPC runtime library. <br>//      The stubs or runtime libraries may need to allocate memory. <br>//      By convention, they call a user-specified function named <br>//      midl_user_allocate. <br>// <br>//    Return Value <br>//      Pointer to a block of memory of len byte in size <br>// <br>void __RPC_FAR * __RPC_API midl_user_allocate (size_t len) <br>{ <br>    LPVOID pVoid = HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (DWORD)len); <br>    if (NULL == pVoid) <br>    { <br>        TraceMessage ("midl_user_allocate: Failed to allocated RPC memory block"); <br>    } <br>    return pVoid; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    midl_user_free() <br>// <br>//    Parameters <br>//      ptr     Pointer to memory block to release <br>// <br>//    Purpose <br>//      Free memory as needed by the RPC runtime library. <br>//      The stubs or runtime libraries may need to free memory. <br>//      By convention, they call a user-specified function named <br>//      midl_user_free. <br>// <br>//    Return Value <br>//      None <br>// <br>void __RPC_API midl_user_free (void __RPC_FAR * ptr) <br>{ <br>    HeapFree (GetProcessHeap(), 0, ptr); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CUIMAPIProp::CUIMAPIProp() <br>// <br>//    Parameters <br>//      hInstance           Instance of the DLL where this provider is <br>//      pfnAllocateBuffer   MAPI allocation function <br>//      pfnAllocateMore     MAPI allocation function <br>//      pfnFreeBuffer       MAPI allocation function <br>//      fReadOnly           Weather or not the UI is in read-only mode <br>// <br>//    Purpose <br>//      Constructor of the class. <br>// <br>//    Return Value <br>//      None. <br>// <br>CUIMAPIProp::CUIMAPIProp (HINSTANCE             hInstance, <br>                          LPALLOCATEBUFFER      pfnAllocateBuffer, <br>                          LPALLOCATEMORE        pfnAllocateMore, <br>                          LPFREEBUFFER          pfnFreeBuffer, <br>                          BOOL                  fReadOnly) <br>{ <br>    // Save in global pointer <br>    pfnMAPIFreeBuffer = pfnFreeBuffer; <br> <br>    // Use MAPI's IMAPIProp in-memory implementation to do the actual <br>    // work of store the properties. If we fail to create this, we throw <br>    // and exception, to new creator of this object must have the <br>    // construction of this object protected within a try-catch block. <br>    HRESULT hResult = CreateIProp ((LPIID)&amp;IID_IMAPIPropData, <br>                                   pfnAllocateBuffer, <br>                                   pfnAllocateMore, <br>                                   pfnFreeBuffer, <br>                                   NULL, <br>                                   &amp;m_pImpObj); <br>    if (hResult) <br>    {    <br>        TraceResult ("CUIMAPIProp: CreateIProp failed to create IPropData object", hResult); <br>        throw CException (hResult); <br>    } <br>    m_hInstance = hInstance; <br>    m_fReadOnly = fReadOnly; <br>    m_cRef = 1; <br>    m_ulCustomPropTag = 0; <br>    m_pfnCallBack = NULL; <br>    m_pTableData = NULL; <br>    InitializeCriticalSection (&amp;m_csObj); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CUIMAPIProp::OpenProperty() <br>// <br>//    Parameters <br>//      { Refer to the MAPI documentation for parameter description } <br>// <br>//    Purpose <br>//      Open the property for the BUTTON control on the display table. We <br>//      only allow the IID_IMAPIControl interface specified in this method. <br>//      If we have the property specified, create a new IMAPIControl <br>//      interface and return it to the caller. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CUIMAPIProp::OpenProperty (ULONG       ulPropTag, <br>                                        LPCIID      piid, <br>                                        ULONG       ulInterfaceOptions, <br>                                        ULONG       ulFlags, <br>                                        LPUNKNOWN * ppUnk) <br>{ <br>    Validate_IMAPIProp_OpenProperty (this, <br>                                     ulPropTag,  <br>                                     piid, <br>                                     ulInterfaceOptions, <br>                                     ulFlags, <br>                                     ppUnk); <br>    if (IID_IMAPIControl != *piid) <br>    { <br>        return E_NOINTERFACE; <br>    } <br>    LPBUTTONCALLBACK pfnCallBack = NULL; <br>    switch (ulPropTag) <br>    { <br>        case PR_SMP_BROWSE_MB : <br>            pfnCallBack = BrowseMailboxes; <br>            break; <br>        case PR_SMP_CHANGE_PASSWORD : <br>            pfnCallBack = ConfigChangePassword; <br>            break; <br>        default : <br>            // We allow client of CUIMAPIProp to set one custom property <br>            // that is not know internally and a custom callback. <br>            if (m_ulCustomPropTag == ulPropTag) <br>            { <br>                pfnCallBack = m_pfnCallBack; <br>            } <br>    } <br>    if (NULL == pfnCallBack) <br>    { <br>        return MAPI_E_NOT_FOUND; <br>    } <br>    CMAPIControl * pControl = new CMAPIControl (this, pfnCallBack, m_fReadOnly); <br>    if (!pControl) <br>    { <br>        return E_OUTOFMEMORY; <br>    } <br>    *ppUnk = (LPUNKNOWN)pControl; <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    EnterMBPasswordDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//      Display a dialog where the user enters the password for a mailbox <br>//      on the server. <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK EnterMBPasswordDlgProc (HWND    hDlg, <br>                                      UINT    message, <br>                                      WPARAM  wParam,  <br>                                      LPARAM  lParam) <br>{ <br>    static LPTSTR szStoredPassword; <br>    static LPTSTR szReturningBuffer; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            { <br>                // On this message only, the lParam is an argument passed by the <br>                // caller who instantiated this dialog. <br>                LPSPropValue pProps = (LPSPropValue)lParam; <br>                SetWindowText (GetDlgItem (hDlg, IDC_MAILBOXNAME), pProps[0].Value.LPSZ); <br>                SetWindowText (GetDlgItem (hDlg, IDC_USER_NAME), pProps[1].Value.LPSZ); <br>                szStoredPassword = pProps[2].Value.LPSZ; <br>                szReturningBuffer = pProps[3].Value.LPSZ; <br>                Edit_LimitText (GetDlgItem (hDlg, IDC_PASSWORD), MAX_PASSWORD_SIZE); <br>                // If this value is false, we should disable the BROWSE button to prevent <br>                // users from changing the mailbox. <br>                if (FALSE == pProps[4].Value.b) <br>                { <br>                    EnableWindow (GetDlgItem (hDlg, IDC_BROWSE_MB), FALSE); <br>                } <br>                if (pfnDlgSubclassEx) <br>                { <br>                    pfnDlgSubclassEx (hDlg, CTL3D_ALL); <br>                } <br>            } <br>            return TRUE; <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_BROWSE_MB : <br>                    EndDialog (hDlg, IDC_BROWSE_MB); <br>                    break; <br>                case IDOK : <br>                    // Get the password and do a CASE-SENSITIVE comparison of the stored and entered psswords. <br>                    GetWindowText (GetDlgItem (hDlg, IDC_PASSWORD), szReturningBuffer, MAX_PASSWORD_SIZE); </code></pre>
<p>
</p>
<pre><code>if (szStoredPassword &amp;&amp; (0 != lstrcmp (szReturningBuffer, szStoredPassword))) <br>                    { <br>                        MessageBeep (MB_ICONEXCLAMATION); <br>                        PrivateMessageBox (IDS_MSG_INVALID_MB_PASSWORD, hDlg); <br>                        SetFocus (GetDlgItem (hDlg, IDC_PASSWORD)); <br>                        return TRUE; <br>                    } <br>                    // else fall through <br>                case IDCANCEL : <br>                    EndDialog (hDlg, (LOWORD(wParam) == IDCANCEL ? FALSE : TRUE)); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PasswordDlgProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 API documentation on dialog procedures } <br>// <br>//    Purpose <br>//      Display a dialog where the user enters a new password for the mailbox. <br>//       <br>//    Return Value <br>//      TRUE if message was handled, FALSE if we don't handle the message <br>//       <br>BOOL CALLBACK PasswordDlgProc (HWND    hDlg, <br>                               UINT    message, <br>                               WPARAM  wParam,  <br>                               LPARAM  lParam) <br>{ <br>    static LPTSTR * pszPasswords; <br>    switch (message) <br>    {    <br>        case WM_INITDIALOG : <br>            // On this message only, the lParam is an argument passed by the <br>            // caller who instantiated this dialog. <br>            pszPasswords = (LPTSTR *)lParam; <br>            // Limit the fields the user can type in. <br>            Edit_LimitText  (GetDlgItem (hDlg, IDC_PASSWORD), MAX_PASSWORD_SIZE); <br>            Edit_LimitText  (GetDlgItem (hDlg, IDC_PASSWORD_CONFIRM), MAX_PASSWORD_SIZE); <br>            Edit_LimitText  (GetDlgItem (hDlg, IDC_OLD_PASSWORD), MAX_PASSWORD_SIZE); <br>            if (pfnDlgSubclassEx) <br>            { <br>                pfnDlgSubclassEx (hDlg, CTL3D_ALL); <br>            } <br>            return TRUE; <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDOK : <br>                    { <br>                        // Get and verify the OLD password <br>                        TCHAR szConfirm[MAX_PASSWORD_SIZE+1],  szOldPassword[MAX_PASSWORD_SIZE+1]; <br>                        if (!GetWindowText (GetDlgItem (hDlg, IDC_OLD_PASSWORD), szOldPassword, MAX_PASSWORD_SIZE+1)) <br>                        { <br>                            MessageBeep (MB_ICONEXCLAMATION); <br>                            PrivateMessageBox (IDS_MSG_NEED_OLD_PASSWORD, hDlg); <br>                            SetFocus (GetDlgItem (hDlg, IDC_OLD_PASSWORD)); <br>                            return TRUE; <br>                        } <br>                        if (lstrcmp (szOldPassword, pszPasswords[1])) <br>                        { <br>                            MessageBeep (MB_ICONEXCLAMATION); <br>                            PrivateMessageBox (IDS_MSG_OLD_PASSWORD_NO_MATCH, hDlg); <br>                            SetWindowText (GetDlgItem (hDlg, IDC_OLD_PASSWORD), szBlank); <br>                            SetFocus (GetDlgItem (hDlg, IDC_OLD_PASSWORD)); <br>                            return TRUE; <br>                        } <br>                        // Get the NEW password <br>                        if (!GetWindowText (GetDlgItem (hDlg, IDC_PASSWORD), pszPasswords[0], MAX_PASSWORD_SIZE+1)) <br>                        { <br>                            MessageBeep (MB_ICONEXCLAMATION); <br>                            PrivateMessageBox (IDS_MSG_NEED_PASSWORD, hDlg); <br>                            SetFocus (GetDlgItem (hDlg, IDC_PASSWORD)); <br>                            return TRUE; <br>                        } <br>                        // Get the NEW password (CONFIRM) <br>                        if (!GetWindowText (GetDlgItem (hDlg, IDC_PASSWORD_CONFIRM), szConfirm, MAX_PASSWORD_SIZE+1)) <br>                        { <br>                            MessageBeep (MB_ICONEXCLAMATION); <br>                            PrivateMessageBox (IDS_MSG_NEED_PASSWORD_CONFIRM, hDlg); <br>                            SetFocus (GetDlgItem (hDlg, IDC_PASSWORD_CONFIRM)); <br>                            return TRUE; <br>                        } <br>                        // Compare (case-sensitive) the instances of the new password typed in <br>                        if (lstrcmp (szConfirm, pszPasswords[0])) <br>                        { <br>                            MessageBeep (MB_ICONEXCLAMATION); <br>                            PrivateMessageBox (IDS_MSG_NEW_PASSWORD_NO_MATCH, hDlg); <br>                            SetWindowText (GetDlgItem (hDlg, IDC_PASSWORD), szBlank); <br>                            SetWindowText (GetDlgItem (hDlg, IDC_PASSWORD_CONFIRM), szBlank); <br>                            SetFocus (GetDlgItem (hDlg, IDC_PASSWORD)); <br>                            return TRUE; <br>                        } <br>                    } <br>                case IDCANCEL : <br>                    EndDialog (hDlg, (IDOK == LOWORD(wParam) ? TRUE : FALSE)); <br>                    return TRUE; <br>            } <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    BrowseMailboxes() <br>// <br>//    Parameters <br>//      pObj            Pointer to our IMAPIProp implementation (CUIMAPIProp) <br>//                      passed in to the DoConfidPropSheet() function <br>//      hOwnerWnd       The owner of any window we display <br>//      hInstance       The instance of this DLL <br>// <br>//    Purpose <br>//      This function get called by our implementation of <br>//      IMAPIControl::Active() by a user hitting a "Browse" <br>//      on the provider configuration property sheet. <br>//      Display a dialog box with all the mailboxes in the remote system <br>// <br>//    Return Value <br>//      None <br>// <br>void STDAPICALLTYPE BrowseMailboxes (CUIMAPIProp *  pObj, <br>                                     HWND           hOwnerWnd, <br>                                     HINSTANCE      hInstance) <br>{ <br>    TCHAR szDisplayName[MAX_STRING_SIZE+1], szMailboxName[MAX_ALIAS_SIZE+1]; <br>    TCHAR szStoredPassword[MAX_PASSWORD_SIZE+1], szEnterPassword[MAX_PASSWORD_SIZE+1]; <br>    LPSPropValue pProp = NULL; <br>    DWORD dwMailboxID; <br>    SPropTagArray sptServer; <br>    sptServer.cValues = 1; <br>    sptServer.aulPropTag[0] = PR_SMP_REMOTE_SERVER; <br>    ULONG cValues; <br>    // Get the server name the user may have typed in the edit field <br>    HRESULT hResult = pObj-&gt;GetProps (&amp;sptServer, fMapiUnicode, &amp;cValues, &amp;pProp); <br>    if (FAILED(hResult) || MAPI_W_ERRORS_RETURNED == hResult) <br>    { <br>        pfnMAPIFreeBuffer (pProp); <br>        PrivateMessageBox (IDS_MSG_NEED_SERVER_NAME, hOwnerWnd); <br>        return; <br>    } <br>    ASSERT (pProp-&gt;ulPropTag == PR_SMP_REMOTE_SERVER); <br>    TCHAR szServer[MAX_STRING_SIZE+1]; <br>    lstrcpy (szServer, pProp-&gt;Value.LPSZ); <br>    pfnMAPIFreeBuffer (pProp); <br>    // Validate the server <br>    if (!IsValidServerName (szServer)) <br>    { <br>        MessageBeep (MB_ICONEXCLAMATION); <br>        PrivateMessageBox (IDS_MSG_INVALID_SERVER_NAME, hOwnerWnd); <br>        return; <br>    } <br>    if (!IsWINDSServerAvailable (szServer)) <br>    { <br>        PrivateMessageBox (IDS_MSG_SERVER_NOT_FOUND, hOwnerWnd); <br>        return; <br>    } <br>    // Show the list of mailboxes in the server. If the user hit OK, process the selected entry. <br>Restart: <br>    if (S_OK == ShowServerAccounts  (hOwnerWnd, <br>                                     hInstance, <br>                                     szServer, <br>                                     szMailboxName, <br>                                     szDisplayName, <br>                                     szStoredPassword, <br>                                     &amp;dwMailboxID)) <br>    { <br>        // Set the selected mailbox properties in the property object <br>        SPropValue spvProps[5] = { 0 }; <br>        spvProps[0].ulPropTag = PR_SMP_MAILBOX_NAME; <br>        spvProps[0].Value.LPSZ = szMailboxName; <br>        spvProps[1].ulPropTag = PR_SMP_USER_NAME; <br>        spvProps[1].Value.LPSZ = szDisplayName; <br>        spvProps[2].ulPropTag = PR_SMP_MAILBOX_PASSWORD; <br>        spvProps[2].Value.LPSZ = szStoredPassword; <br>        spvProps[3].ulPropTag = PR_SMP_MAILBOX_PASSWORD; <br>        spvProps[3].Value.LPSZ = szEnterPassword; <br>        spvProps[4].Value.b = TRUE; // Activate the "BROWSE" button on the dialog below <br>        // Before continuing, the user must verify it's access to the mailbox by typing the correct password <br>        int nAnswer = DialogBoxParam (hInstance,   <br>                                      MAKEINTRESOURCE(IDD_ENTER_PASSWORD), <br>                                      hOwnerWnd, <br>                                      EnterMBPasswordDlgProc, <br>                                      (LPARAM)spvProps); <br>        if (IDC_BROWSE_MB == nAnswer) <br>        { <br>            goto Restart; <br>        } <br>        if (TRUE == nAnswer) <br>        { <br>            // Access is verified, continue <br>            spvProps[3].ulPropTag = PR_SMP_MAILBOX_ID; <br>            spvProps[3].Value.l = dwMailboxID; <br>            pObj-&gt;SetProps (4, spvProps, NULL); <br>            // Now we must tell the property sheet handler to re-read the data for <br>            // this field from the IMAPIProp object any of the DTCTL members with a key, for a notification on them. <br>            for (ULONG iRow=0; ; iRow++) <br>            { <br>                LPSRow pRow; <br>                LPSPropValue pControlID; <br>                hResult = pObj-&gt;m_pTableData-&gt;HrEnumRow (iRow, &amp;pRow); <br>                if (hResult || !pRow) <br>                { <br>                    TraceResult ("BrowseMailboxes: Traversing the display table", hResult); <br>                    return; <br>                } <br>                pControlID = PpropFindProp (pRow-&gt;lpProps, pRow-&gt;cValues, PR_CONTROL_ID); <br>                if (pControlID-&gt;Value.bin.cb) <br>                { <br>                    pObj-&gt;m_pTableData-&gt;HrNotify (0, 1, pControlID); <br>                } <br>                pfnMAPIFreeBuffer (pRow); <br>            } <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    ConfigChangePassword() <br>// <br>//    Parameters <br>//      pObj            Pointer to our IMAPIProp implementation (CUIMAPIProp) <br>//                      passed in to the DoConfidPropSheet() function <br>//      hOwnerWnd       The owner of any window we display <br>//      hInstance       The instance of this DLL <br>// <br>//    Purpose <br>//      This function get called by our implementation of <br>//      IMAPIControl::Active() by a user hitting a "Change Mailbox Password" <br>//      on the provider configuration property sheet. <br>//      Display a dialog box where the user can change the password of the <br>//      mailbox. <br>// <br>//    Return Value <br>//      None <br>// <br>void STDAPICALLTYPE ConfigChangePassword (CUIMAPIProp * pObj, HWND hOwnerWnd, HINSTANCE hInstance) <br>{ <br>    const static SizedSPropTagArray(3, sptServerAndPass) = <br>    { <br>        3, <br>        { <br>            PR_SMP_REMOTE_SERVER, <br>            PR_SMP_MAILBOX_NAME, <br>            PR_SMP_MAILBOX_PASSWORD <br>        } <br>    }; <br>    TCHAR szOldPassword[MAX_PASSWORD_SIZE+1], szNewPassword[MAX_PASSWORD_SIZE+1]; <br>    TCHAR szServer[MAX_STRING_SIZE+1], szMBName[MAX_STRING_SIZE+1]; <br>    LPTSTR aszPasswords[2] = { 0 }; <br>    ULONG cValues; <br>    LPSPropValue pProp = NULL; <br>    SPropValue spvNewPassword = { 0 }; <br>    // Get the server and mailbox information for the property object <br>    HRESULT hResult = pObj-&gt;GetProps ((LPSPropTagArray)&amp;sptServerAndPass, fMapiUnicode, &amp;cValues, &amp;pProp); <br>    if (FAILED(hResult) || MAPI_W_ERRORS_RETURNED == hResult) <br>    { <br>        pfnMAPIFreeBuffer (pProp); <br>        PrivateMessageBox (IDS_MSG_NEED_SERVER_NAME, hOwnerWnd); <br>        return; <br>    } <br>    ASSERTMSG (pProp[0].ulPropTag == PR_SMP_REMOTE_SERVER, "Where is PR_SMP_REMOTE_SERVER?!?!"); <br>    ASSERTMSG (pProp[1].ulPropTag == PR_SMP_MAILBOX_NAME, "Where is PR_SMP_MAILBOX_NAME?!?!"); <br>    ASSERTMSG (pProp[2].ulPropTag == PR_SMP_MAILBOX_PASSWORD, "Where is PR_SMP_MAILBOX_PASSWORD?!?!"); <br>    lstrcpy (szServer, pProp[0].Value.LPSZ); <br>    lstrcpy (szMBName, pProp[1].Value.LPSZ); <br>    lstrcpy (szOldPassword, pProp[2].Value.LPSZ); <br>    pfnMAPIFreeBuffer (pProp); <br>    // Validate the server name and availability <br>    if (!IsValidServerName (szServer)) <br>    { <br>        MessageBeep (MB_ICONEXCLAMATION); <br>        PrivateMessageBox (IDS_MSG_INVALID_SERVER_NAME, hOwnerWnd); <br>        return; <br>    } <br>    if (!IsWINDSServerAvailable (szServer)) <br>    { <br>        PrivateMessageBox (IDS_MSG_SERVER_NOT_FOUND, hOwnerWnd); <br>        return; <br>    } <br>    aszPasswords[0] = szNewPassword; <br>    aszPasswords[1] = szOldPassword; <br> <br>    // Show the dialog where the user can change the information <br>    if (TRUE == DialogBoxParam (hInstance, <br>                                MAKEINTRESOURCE(IDD_NEW_PASSWORD), <br>                                hOwnerWnd, <br>                                PasswordDlgProc, <br>                                (LPARAM)&amp;aszPasswords)) <br>    { <br>        // If the user is ok call the server <br>        if (S_OK == ChangeMBServerPassword (szServer, szMBName, szOldPassword, szNewPassword)) <br>        { <br>            // If the change was successfull, save the new password in the property object. <br>            spvNewPassword.ulPropTag = PR_SMP_MAILBOX_PASSWORD; <br>            spvNewPassword.Value.LPSZ = szNewPassword; <br>            pObj-&gt;SetProps (1, &amp;spvNewPassword, NULL); <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PingRemoteServer() <br>// <br>//    Parameters <br>//      hOwnerWnd       Handle to a windows that owns any UI done by <br>//                      this provider <br>//      pProps          An array of SPropValue structures with the logon <br>//                      properties of the service. The first 5 properties <br>//                      must be the standard properties for a WINDS service <br>//                      and they must be in the standard order (see COMWINDS.H) <br>// <br>//    Purpose <br>//      Make a quick connection to the server verifying a mailbox access <br>//      with the current password and name. <br>// <br>//    Return Value <br>//      TRUE if the connection was successful, or the user does not care that <br>//      the server is offline. <br>//      FALSE if the user wants to change the configuration properties again. <br>// <br>BOOL WINAPI PingRemoteServer (HWND hOwnerWnd, LPSPropValue pProps) <br>{ <br>    BOOL fPingedOK = TRUE; <br>    DWORD dwMsgIDS = 0, dwMailboxID; <br>    TCHAR szServerUserFullName[MAX_STRING_SIZE+1]; <br>    HRESULT hLogonError; <br>    CharUpper (pProps[SERVER_NAME].Value.LPSZ); <br>    // Try to connect to the server and see if it is around <br>    if (IsWINDSServerAvailable (pProps[SERVER_NAME].Value.LPSZ)) <br>    { <br>        hLogonError = LogonServerMailbox (pProps[SERVER_NAME].Value.LPSZ, <br>                                          pProps[MAILBOX_NAME].Value.LPSZ, <br>                                          szServerUserFullName, <br>                                          pProps[PASSWORD].Value.LPSZ, <br>                                          &amp;dwMailboxID); <br>        if (hLogonError) <br>        { <br>            switch (hLogonError) <br>            { <br>                case HRESULT_FROM_WIN32 (ERROR_NO_SUCH_USER) : <br>                    dwMsgIDS = IDS_MSG_CONFIG_INVALID_USER; <br>                    break; <br>                case HRESULT_FROM_WIN32 (ERROR_BAD_USERNAME) : <br>                    dwMsgIDS = IDS_MSG_CONFIG_INVALID_USER_NAME; <br>                    break; <br>                case HRESULT_FROM_WIN32 (ERROR_INVALID_PASSWORD) : <br>                    dwMsgIDS = IDS_MSG_INVALID_MB_PASSWORD; <br>                    break; <br>                default : <br>                    dwMsgIDS = IDS_MSG_CONFIG_NO_CONNECT; <br>                    break; <br>            } <br>            PrivateMessageBox (dwMsgIDS, hOwnerWnd); <br>            fPingedOK = FALSE; <br>        } <br>    } <br>    else <br>    { <br>        if (IDNO == PrivateMessageBox (IDS_MSG_NO_SERVER_GO_OFFLINE, hOwnerWnd, MB_YESNO | MB_ICONSTOP)) <br>        { <br>            // The user wants to re-enter the name of the remote server <br>            fPingedOK = FALSE; <br>        } <br>    } <br>    return fPingedOK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    DoServerLogon() <br>// <br>//    Parameters <br>//      pMBInfo             Pointer to the mailbox info structure where this <br>//                          function returns the mailbox information of the <br>//                          user logging in. <br>//      pProps              An array of SPropValue structures with the logon <br>//                          properties of the service. The first 5 properties <br>//                          must be the standard properties for a WINDS <br>//                          service and they must be in the standard order <br>//                          (see COMWINDS.H) <br>//      pProfileObj         Profile object to which this function write <br>//                          changes, if any are required based on the latest <br>//                          information comming down from the server or <br>//                          entered by the user in the configuration dialog. <br>//      fUIAllowed          Weather or not the function is allowed to display <br>//                          any UI of information or request input from <br>//                          the user. <br>//      hOwnerWnd           Handle to the window that owns any UI displayed. <br>//      fSetNotification    Weather or not to set notifications with the <br>//                          remote server <br>//      dwNotifMask         Mask of events this provider is intersted in <br>//                          receiving. <br>//      pdwConnectID        Where I return the connection ID returned by <br>//                          the server <br>//      fOffLineOK          Flag that indicates that the caller does not <br>//                          want to be bother with a "server offline" <br>//                          notification/UI and that we should return success <br>//                          even if the server could not be reached. <br>// <br>//    Purpose <br>//      This function does a complete logon to the server with the <br>//      information passed in the pProps arguments. The function makes a <br>//      remote call to the server to request access to a mailbox. If <br>//      access is not granted we display messages and if needed, display the <br>//      appropiate dialog boxes for reconfiguration or change of password. <br>//      If the server was off-line, but the user does not mind, we return <br>//      MAPI_W_NO_SERVICE. <br>//      If the server is off-line, but no UI is allowed we return <br>//      MAPI_E_NETWORK_ERROR. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI DoServerLogon (PMAILBOX_INFO pMBInfo, <br>                              LPSPropValue  pProps, <br>                              LPPROFSECT    pProfileObj, <br>                              BOOL          fUIAllowed, <br>                              HWND          hOwnerWnd, <br>                              BOOL          fSetNotification, <br>                              DWORD         dwNotifMask, <br>                              DWORD *       pdwConnectID, <br>                              BOOL          fOffLineOK) <br>{ <br>    ASSERT (PR_SMP_REMOTE_SERVER == pProps[SERVER_NAME].ulPropTag); <br>    ASSERT (PR_SMP_MAILBOX_NAME == pProps[MAILBOX_NAME].ulPropTag); <br>    ASSERT (PR_SMP_MAILBOX_ID == pProps[MAILBOX_ID].ulPropTag); <br>    ASSERT (PR_SMP_USER_NAME == pProps[USER_NAME].ulPropTag); <br>    ASSERT (PR_SMP_MAILBOX_PASSWORD == pProps[PASSWORD].ulPropTag); <br>     <br>    pMBInfo-&gt;dwObjID = pProps[MAILBOX_ID].Value.l; <br>    lstrcpy (pMBInfo-&gt;szMailboxName, pProps[MAILBOX_NAME].Value.LPSZ); <br>    lstrcpy (pMBInfo-&gt;szFullName, pProps[USER_NAME].Value.LPSZ); <br>    lstrcpy (pMBInfo-&gt;szPassword, pProps[PASSWORD].Value.LPSZ); <br>     <br>    SPropValue spvProps[5] = { 0 }; <br>    DWORD dwMsgIDS = 0, dwStyle = MB_YESNO | MB_ICONSTOP, dwMailboxID; <br>    HRESULT hLogonError; <br>    long nResponse; <br> <br>    // Try to connect to the server and see if it is around <br>    if (IsWINDSServerAvailable (pProps[SERVER_NAME].Value.LPSZ)) <br>    { <br>RestartMailboxLogon: <br>        if (fSetNotification) <br>        { <br>            hLogonError = LogonServerMailboxAndSetNotif (pProps[SERVER_NAME].Value.LPSZ, <br>                                                         pMBInfo-&gt;szMailboxName, <br>                                                         pMBInfo-&gt;szFullName, <br>                                                         pMBInfo-&gt;szPassword, <br>                                                         &amp;dwMailboxID, <br>                                                         dwNotifMask, <br>                                                         *pdwConnectID); <br>        } <br>        else <br>        { <br>            hLogonError = LogonServerMailbox (pProps[SERVER_NAME].Value.LPSZ, <br>                                              pMBInfo-&gt;szMailboxName, <br>                                              pMBInfo-&gt;szFullName, <br>                                              pMBInfo-&gt;szPassword, <br>                                              &amp;dwMailboxID); <br>        } <br>        if (hLogonError) <br>        { <br>            if (fUIAllowed) <br>            { <br>                switch (hLogonError) <br>                { <br>                    case HRESULT_FROM_WIN32 (ERROR_NO_SUCH_USER) : <br>                        dwMsgIDS = IDS_MSG_LOGON_INVALID_USER; <br>                        break; <br>                    case HRESULT_FROM_WIN32 (ERROR_BAD_USERNAME) : <br>                        dwMsgIDS = IDS_MSG_LOGON_INVALID_USER_NAME; <br>                        break; <br>                    case HRESULT_FROM_WIN32 (ERROR_INVALID_PASSWORD) : <br>                        dwMsgIDS = IDS_MSG_INVALID_MB_PASSWORD; <br>                        dwStyle = MB_OK | MB_ICONSTOP; <br>                        break; <br>                    default : <br>                        dwMsgIDS = IDS_MSG_LOGON_NO_CONNECT; <br>                        break; <br>                } <br>                if (dwMsgIDS) <br>                { <br>                    PrivInitialize3DCtl (ghInstance); <br>                    nResponse = PrivateMessageBox (dwMsgIDS, hOwnerWnd, dwStyle); <br>                    if (IDYES == nResponse &amp;&amp; hLogonError != HRESULT_FROM_WIN32 (ERROR_INVALID_PASSWORD)) <br>                    { <br>                        return S_FALSE; <br>                    } <br>                    if (hLogonError == HRESULT_FROM_WIN32 (ERROR_INVALID_PASSWORD)) <br>                    { <br>                        spvProps[0].ulPropTag = PR_SMP_MAILBOX_NAME; <br>                        spvProps[0].Value.LPSZ = pMBInfo-&gt;szMailboxName; <br>                        spvProps[1].ulPropTag = PR_SMP_USER_NAME; <br>                        spvProps[1].Value.LPSZ = pMBInfo-&gt;szFullName; <br>                        spvProps[2].ulPropTag = PR_SMP_MAILBOX_PASSWORD; <br>                        spvProps[2].Value.LPSZ = NULL; <br>                        spvProps[3].ulPropTag = PR_SMP_MAILBOX_PASSWORD; <br>                        spvProps[3].Value.LPSZ = pMBInfo-&gt;szPassword; <br>                        spvProps[4].Value.b = FALSE; // De-activate the "BROWSE" button on the dialog below <br>                        ASSERT (NULL != ghInstance); <br>                        nResponse = DialogBoxParam (ghInstance,   <br>                                                    MAKEINTRESOURCE(IDD_ENTER_PASSWORD), <br>                                                    hOwnerWnd, <br>                                                    EnterMBPasswordDlgProc, <br>                                                    (LPARAM)spvProps); <br>                        if (FALSE == nResponse) <br>                        { <br>                            return MAPI_E_EXTENDED_ERROR; <br>                        } <br>                        else <br>                        { <br>                            goto RestartMailboxLogon; <br>                        } <br>                    } <br>                } <br>            } <br>            else <br>            { <br>                return hLogonError; <br>            } <br>        } <br>        else <br>        { <br>            ULONG ulProps = 0; <br>            // If any of this properties that came from the server is different to <br>            // what we have stored on the profile, then set them back for the next session. <br>            if (lstrcmp (pProps[USER_NAME].Value.LPSZ, pMBInfo-&gt;szFullName)) <br>            { <br>                spvProps[ulProps].ulPropTag = PR_SMP_USER_NAME; <br>                spvProps[ulProps++].Value.LPSZ = pMBInfo-&gt;szFullName; <br>            } <br>            if (lstrcmp (pProps[PASSWORD].Value.LPSZ, pMBInfo-&gt;szPassword)) <br>            { <br>                spvProps[ulProps].ulPropTag = PR_SMP_MAILBOX_PASSWORD; <br>                spvProps[ulProps++].Value.LPSZ = pMBInfo-&gt;szPassword; <br>            } <br>            if (dwMailboxID != pProps[MAILBOX_ID].Value.ul) <br>            { <br>                spvProps[ulProps].ulPropTag = PR_SMP_MAILBOX_ID; <br>                spvProps[ulProps++].Value.l = dwMailboxID; <br>            } <br>            if (ulProps) <br>            { <br>                HRESULT hResult = pProfileObj-&gt;SetProps (ulProps, spvProps, NULL); <br>                TraceResult ("DoServerLogon: Could not set last-minute props", hResult); <br>            } <br>        } <br>    } <br>    else <br>    { <br>        // If the caller says that is OK to be offline, then return. <br>        if (fOffLineOK) <br>        { <br>            return S_OK; <br>        } <br>        if (fUIAllowed) <br>        { <br>            PrivInitialize3DCtl (ghInstance); <br>            if (IDYES == PrivateMessageBox (IDS_MSG_NO_SERVER_ONLINE, hOwnerWnd, MB_YESNO)) <br>            { <br>                // The user wants to re-enter the name of the remote server <br>                return MAPI_W_NO_SERVICE; <br>            } <br>        } <br>        else <br>        { <br>            return MAPI_E_NETWORK_ERROR; <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WizardEntry() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Returns the name of the resource where the controls for the wizard <br>//      pages are defined and outlined. The Wizard gives us a pointer to an <br>//      IMAPIProp object. We will release this object after we are finished <br>//      in the dialog procedure of our configuration pages. <br>// <br>//    Return Value <br>//      S_OK always. <br>// <br>ULONG STDAPICALLTYPE WizardEntry (HINSTANCE     hProviderDLLInstance, <br>                                  LPTSTR *      ppcsResourceName, <br>                                  DLGPROC *     ppDlgProc, <br>                                  LPMAPIPROP    pMapiProp, <br>                                  LPVOID        pSupObj) <br>{    <br>    InfoTrace ("WizardEntry function called"); <br>    // Quick sanity check on the input parameters <br>    ASSERT (ppcsResourceName); <br>    ASSERT (pMapiProp); <br>    ASSERT (ppDlgProc); <br>    ASSERT (hProviderDLLInstance); <br>    // The resource name needs to be an actual text string not <br>    // something generated with the MAKEINTRESOURCE() macro <br>    const static TCHAR szTemplate[] = TEXT("WIZARD_PAGES"); <br>    *ppcsResourceName = (LPTSTR)szTemplate; <br>    *ppDlgProc = (DLGPROC)WizardDlgProc; <br>    pPropObj = pMapiProp; <br>    pPropObj-&gt;AddRef(); <br>    ghInstance = hProviderDLLInstance; <br> <br>    fInitalizeControls = fDownloadMBList = TRUE; <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    WizardDlgProc() <br>// <br>//    Parameters <br>//      { Refer to MAPI and Win32 SDK Documentation on this method } <br>// <br>//    Purpose <br>//      This is the function that the profile wizard will call while <br>//      interacting with our configuration pages. <br>// <br>//    Return Value <br>//      TRUE if we handle a message, FALSE if we don't or there was an error <br>//      in the data <br>// <br>BOOL STDAPICALLTYPE WizardDlgProc (HWND           hDlg, <br>                                   UINT           message, <br>                                   WPARAM         wParam, <br>                                   LPARAM         lParam) <br>{ <br>    static SPropValue spvWizardProps[WIZARD_PROPERTIES] = { 0 }; <br>    static TCHAR szDisplayName[MAX_STRING_SIZE+1]; <br>    static TCHAR szServerName[MAX_STRING_SIZE+1]; <br>    static TCHAR szMailboxName[MAX_ALIAS_SIZE+1]; <br>    static TCHAR szStoredPassword[MAX_PASSWORD_SIZE+1]; <br>    static TCHAR szEnterPassword[MAX_PASSWORD_SIZE+1]; <br>    static DWORD dwMailboxID; <br>    static UINT iPageNum; <br>    switch (message) <br>    { <br>        case WM_INITDIALOG: <br>            // If the control have not been initialized do so <br>            if (fInitalizeControls) <br>            { <br>                // Send output to a console window BUT NOT to the COM1 <br>                InitTraces (TRACES_CONSOLE | TRACES_NO_COM_OUTPUT); <br>                dwMailboxID = 0; <br>                // Set the flag to avoid re-initialization <br>                fInitalizeControls = FALSE; <br>                // Limit the maximum number of character users can enter for the mailbox PASSWORD <br>                Edit_LimitText  (GetDlgItem (hDlg, IDC_PASSWORD), MAX_PASSWORD_SIZE); <br>                PrivInitialize3DCtl (ghInstance); <br>                iPageNum = 0; <br>            } <br>            return TRUE; <br> <br>        case WIZ_QUERYNUMPAGES : <br>            // Return the number of pages the our provider needs to display <br>            return (BOOL)2; <br> <br>        case WM_CLOSE : <br>            pPropObj-&gt;Release(); <br>            pPropObj = NULL; <br>            PrivUninitialize3DCtl (ghInstance); <br>            // Close down the log file/com port/console window/etc. <br>            UnInitTraces(); <br>            return TRUE; <br> <br>        case WM_COMMAND : <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDC_BROWSE_MB : <br>                    if (S_OK == ShowServerAccounts  (hDlg, <br>                                                     ghInstance, <br>                                                     szServerName, <br>                                                     szMailboxName, </code></pre>
<p>
</p>
<pre><code>szDisplayName, <br>                                                     szStoredPassword, <br>                                                     &amp;dwMailboxID)) <br>                    { <br>                        SetWindowText (GetDlgItem (hDlg, IDC_MAILBOXNAME), szMailboxName); <br>                        SetWindowText (GetDlgItem (hDlg, IDC_USER_NAME), szDisplayName); <br>                    } <br>                    return TRUE; <br> <br>                case WIZ_NEXT: <br>                    switch (iPageNum) <br>                    { <br>                        // We are about to leave a page in each of the  <br>                        // following cases. Here we should get the data from <br>                        // the controls in that page, validate it if necessary <br>                        // and copy the validated data into the property array <br>                        case 0: <br>                            break; <br> <br>                        case 1: <br>                            if (!GetWindowText (GetDlgItem (hDlg, IDC_SERVERNAME), <br>                                                szServerName, <br>                                                sizeof(szServerName))) <br>                            { <br>                                MessageBeep (MB_ICONEXCLAMATION); <br>                                PrivateMessageBox (IDS_MSG_NEED_SERVER_NAME, hDlg); <br>                                return FALSE; <br>                            } <br>                            if (!IsValidServerName (szServerName)) <br>                            { <br>                                MessageBeep (MB_ICONEXCLAMATION); <br>                                PrivateMessageBox (IDS_MSG_INVALID_SERVER_NAME, hDlg); <br>                                return FALSE; <br>                            } <br>                            if (!IsWINDSServerAvailable (szServerName)) <br>                            { <br>                                PrivateMessageBox (IDS_MSG_SERVER_NOT_FOUND, hDlg); <br>                                return FALSE; <br>                            } <br>                            if (fDownloadMBList) <br>                            { <br>                                if (S_OK == ShowServerAccounts  (hDlg, <br>                                                                 ghInstance, <br>                                                                 szServerName, <br>                                                                 szMailboxName, <br>                                                                 szDisplayName, <br>                                                                 szStoredPassword, <br>                                                                 &amp;dwMailboxID)) <br>                                { <br>                                    SetWindowText (GetDlgItem (hDlg, IDC_MAILBOXNAME), szMailboxName); <br>                                    SetWindowText (GetDlgItem (hDlg, IDC_USER_NAME), szDisplayName); <br>                                    fDownloadMBList = FALSE; <br>                                } <br>                                else <br>                                { <br>                                    return FALSE; <br>                                } <br>                            } <br>                            break; <br> <br>                        case 2: <br>                            if (!GetWindowTextLength (GetDlgItem (hDlg, IDC_PASSWORD))) <br>                            { <br>                                MessageBeep (MB_ICONEXCLAMATION); <br>                                PrivateMessageBox (IDS_MSG_SELECT_MB_NAME, hDlg); <br>                                SetFocus (GetDlgItem (hDlg, IDC_BROWSE_MB)); <br>                                return FALSE; <br>                            } <br>                            if (!GetWindowText (GetDlgItem (hDlg, IDC_PASSWORD), szEnterPassword, sizeof(szEnterPassword))) <br>                            { <br>                                MessageBeep (MB_ICONEXCLAMATION); <br>                                PrivateMessageBox (IDS_MSG_NEED_PASSWORD, hDlg); <br>                                SetFocus (GetDlgItem (hDlg, IDC_PASSWORD)); <br>                                return FALSE; <br>                            } <br>                            if (lstrcmp (szEnterPassword, szStoredPassword)) <br>                            { <br>                                MessageBeep (MB_ICONEXCLAMATION); <br>                                PrivateMessageBox (IDS_MSG_INVALID_MB_PASSWORD, hDlg); <br>                                SetFocus (GetDlgItem (hDlg, IDC_PASSWORD)); <br>                                return FALSE; <br>                            } <br>                            spvWizardProps[SERVER_NAME].ulPropTag  = PR_SMP_REMOTE_SERVER; <br>                            spvWizardProps[SERVER_NAME].Value.LPSZ = szServerName; <br>                            spvWizardProps[MAILBOX_NAME].ulPropTag  = PR_SMP_MAILBOX_NAME; <br>                            spvWizardProps[MAILBOX_NAME].Value.LPSZ = szMailboxName; <br>                            spvWizardProps[MAILBOX_ID].ulPropTag  = PR_SMP_MAILBOX_ID; <br>                            spvWizardProps[MAILBOX_ID].Value.l = dwMailboxID; <br>                            spvWizardProps[USER_NAME].ulPropTag  = PR_SMP_USER_NAME; <br>                            spvWizardProps[USER_NAME].Value.LPSZ = szDisplayName; <br>                            spvWizardProps[PASSWORD].ulPropTag  = PR_SMP_MAILBOX_PASSWORD; <br>                            spvWizardProps[PASSWORD].Value.LPSZ = szStoredPassword; <br>                            // Since this is the last page in our configuration <br>                            // we must save the obtained data into the <br>                            // IMAPIProp object that the wizard gave us. In <br>                            // turn this data will be saved in the profile <br>                            // section of this provider <br>                            ASSERT (pPropObj); <br>                            if (pPropObj) <br>                            { <br>                                HRESULT hResult = pPropObj-&gt;SetProps (WIZARD_PROPERTIES, spvWizardProps, NULL); <br>                                if (hResult) <br>                                { <br>                                    // Something went wrong <br>                                    TraceResult ("WizardDlgPrc: Failed to set props", hResult); <br>                                    return FALSE; <br>                                } <br>                            } <br>                            break; <br> <br>                        default: <br>                            // We should not get here. No pages after three <br>                            ASSERT (FALSE); <br>                            break; <br>                    } <br>                    // Disable the page we were in and enable the next one <br>                    // before it is display by the wizard <br>                    TogglePage (hDlg, iPageNum, FALSE); <br>                    TogglePage (hDlg, ++iPageNum, TRUE); <br>                    return TRUE; <br> <br>                case WIZ_PREV: <br>                    // Disable the page we were in and enable the next one <br>                    // before it is display by the wizard <br>                    TogglePage (hDlg, iPageNum, FALSE); <br>                    TogglePage (hDlg, --iPageNum, TRUE); <br>                    return TRUE; <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    TogglePage() <br>// <br>//    Parameters <br>//      hDlg        Handle to the dialogs where the controls are located <br>//      iPage       Number of the page we are going to toggle <br>//      fState      State of the controls: TRUE shows them, FALSE hides them <br>// <br>//    Purpose <br>//      This function will hide or show the controls for the page number <br>//      specified in the iPage parameter. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI TogglePage (HWND hDlg, UINT iPage, BOOL fState) <br>{ <br>    // What page is it? <br>    HWND hEditCtl = NULL; <br>    switch (iPage) <br>    { <br>        // Toggle the controls that should be displayed for a particular page <br>        case 1 : <br>            EnableWindow (GetDlgItem (hDlg, IDC_STATIC1), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_STATIC1), fState ? SW_SHOW : SW_HIDE); <br>            EnableWindow (GetDlgItem (hDlg, IDC_INFO1), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_INFO1), fState ? SW_SHOW : SW_HIDE); <br>            hEditCtl = GetDlgItem (hDlg, IDC_SERVERNAME); <br>            break; <br> <br>        case 2 : <br>            EnableWindow (GetDlgItem (hDlg, IDC_STATIC2), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_STATIC2), fState ? SW_SHOW : SW_HIDE); <br>            EnableWindow (GetDlgItem (hDlg, IDC_STATIC3), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_STATIC3), fState ? SW_SHOW : SW_HIDE); <br>            EnableWindow (GetDlgItem (hDlg, IDC_STATIC4), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_STATIC4), fState ? SW_SHOW : SW_HIDE); <br>            EnableWindow (GetDlgItem (hDlg, IDC_INFO2), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_INFO2), fState ? SW_SHOW : SW_HIDE); <br>            EnableWindow (GetDlgItem (hDlg, IDC_MAILBOXNAME), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_MAILBOXNAME), fState ? SW_SHOW : SW_HIDE); <br>            EnableWindow (GetDlgItem (hDlg, IDC_USER_NAME), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_USER_NAME), fState ? SW_SHOW : SW_HIDE); <br>            EnableWindow (GetDlgItem (hDlg, IDC_BROWSE_MB), fState); <br>            ShowWindow   (GetDlgItem (hDlg, IDC_BROWSE_MB), fState ? SW_SHOW : SW_HIDE); <br>            hEditCtl = GetDlgItem (hDlg, IDC_PASSWORD); // We want the button to have the focus by default <br>            break; <br>    } <br>    if (hEditCtl) <br>    { <br>        EnableWindow (hEditCtl, fState); <br>        ShowWindow   (hEditCtl, fState ? SW_SHOW : SW_HIDE); <br>        if (fState) <br>        { <br>            SetFocus (hEditCtl); <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    MergeConfigProps() <br>// <br>//    Parameters <br>//      ulCfgProps      Number of properties for configuration <br>//      pCfgProps       Array of properties to configure the provider <br>//      pLogonProps     Array of properties found in the profile section of <br>//                      this service provider <br>// <br>//    Purpose <br>//      This function merges a property array that the user (or configuration <br>//      application) passed into ServiceEntry with the property array of <br>//      the provider, stored in the profile. This merged array is what <br>//      either gets passed into the configuration dialog (if UI is allowed) <br>//      and gets written out to the profile section for the service provider. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI MergeConfigProps (ULONG                  ulCfgProps, <br>                                 LPSPropValue           pCfgProps, <br>                                 LPSPropValue           pLogonProps) <br>{ <br>    while (ulCfgProps--) <br>    { <br>        // For the particular property found, set the proptag (in case <br>        // the one in the profile was not valid), and the value. The <br>        // value will be the value passed in the configuration prop array. <br>        switch (pCfgProps[ulCfgProps].ulPropTag) <br>        { <br>            case PR_SMP_REMOTE_SERVER : <br>                if (FALSE == IsValidServerName (pCfgProps[ulCfgProps].Value.LPSZ)) <br>                { <br>                    return E_INVALIDARG; <br>                } <br>                pLogonProps[SERVER_NAME] = pCfgProps[ulCfgProps]; <br>                break; <br>            case PR_SMP_USER_NAME : <br>                pLogonProps[USER_NAME] = pCfgProps[ulCfgProps]; <br>                break; <br>            case PR_SMP_MAILBOX_NAME : <br>                pLogonProps[MAILBOX_NAME] = pCfgProps[ulCfgProps]; <br>                break; <br>            case PR_SMP_MAILBOX_ID : <br>                pLogonProps[MAILBOX_ID] = pCfgProps[ulCfgProps]; <br>                break; <br>            case PR_SMP_MAILBOX_PASSWORD : <br>                pLogonProps[PASSWORD] = pCfgProps[ulCfgProps]; <br>                break; <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    OpenServiceProfileSection() <br>// <br>//    Parameters <br>//      pSupObj         Pointer to the provider support object <br>//      ppProfSectObj   Where we return a pointer to the service profile <br>//                      section of the provider <br>//      pfnFreeBuffer   MAPI memory allocation function <br>// <br>//    Purpose <br>//      This function opens the profile section of this service, where the <br>//      properties of a WINDS provider (AB, MS, or XP) are stored. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI OpenServiceProfileSection (LPMAPISUP    pSupObj, <br>                                          LPPROFSECT * ppProfSectObj, <br>                                          LPFREEBUFFER pfnFreeBuffer) <br>{ <br>    SPropTagArray sptService = { 1, { PR_SERVICE_UID } }; <br>    LPPROFSECT pProvProfSectObj; <br>    ULONG cValues; <br>    LPSPropValue pProp; <br>    // Get the PROVIDER profile section <br>    HRESULT hResult = pSupObj-&gt;OpenProfileSection (NULL, <br>                                                   MAPI_MODIFY, <br>                                                   &amp;pProvProfSectObj); <br>    if (!hResult) <br>    { <br>        // Get the UID of the profile section of the service where this provider is installed <br>        hResult = pProvProfSectObj-&gt;GetProps (&amp;sptService, fMapiUnicode, &amp;cValues, &amp;pProp); <br>        if (SUCCEEDED(hResult)) <br>        { <br>            if (S_OK == hResult) <br>            { <br>                // Now, with the obtained UID, open the profile section of the service <br>                ASSERTMSG (PR_SERVICE_UID == pProp-&gt;ulPropTag, "Where is PR_SERVICE_UID"); <br>                hResult = pSupObj-&gt;OpenProfileSection ((LPMAPIUID)pProp-&gt;Value.bin.lpb, <br>                                                       MAPI_MODIFY, <br>                                                       ppProfSectObj); <br>            } <br>            else <br>            { <br>                hResult = E_FAIL; <br>            } <br>            pfnFreeBuffer (pProp); <br>        } <br>        pProvProfSectObj-&gt;Release(); <br>    } <br>    TraceResult ("OpenServiceProfileSection", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PrivInitialize3DCtl() <br>// <br>//    Parameters <br>//      hInstance   Handle to the instance the control 3d library will <br>//                  subclass <br>// <br>//    Purpose <br>//      This function dynamically binds to the CTL3D library for UI apperance <br>//      on Windows NT. On Windows 95 the library may or may not be on the <br>//      system. We do this to have a single binary file that works on <br>//      Windows NT and Windows 95 and ensure that the WINDS service DLL loads <br>//      correctly in both platforms. <br>//      The CTL3D provider a less disparate user interface between the two OS's <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI PrivInitialize3DCtl (HINSTANCE hInstance) <br>{ <br>    if (NULL == ghUIControl) <br>    { <br>        ghUIControl = LoadLibrary (TEXT("CTL3D32.DLL")); <br>        if (ghUIControl) <br>        { <br>            pfn3DRegister = (LPCTL3DFUNCTION)GetProcAddress (ghUIControl, TEXT("Ctl3dRegister")); <br>            pfn3DUnregister = (LPCTL3DFUNCTION)GetProcAddress (ghUIControl, TEXT("Ctl3dUnregister")); <br>            pfn3DAutoSubclass = (LPCTL3DFUNCTION)GetProcAddress (ghUIControl, TEXT("Ctl3dAutoSubclass")); <br>            pfnDlgSubclassEx = (LPCTL3DSUBCLASS)GetProcAddress (ghUIControl, TEXT("Ctl3dSubclassDlgEx")); <br>             <br>            if (pfn3DRegister &amp;&amp; <br>                pfn3DUnregister &amp;&amp; <br>                pfn3DAutoSubclass &amp;&amp; <br>                pfnDlgSubclassEx) <br>            { <br>                pfn3DRegister (hInstance); <br>                pfn3DAutoSubclass (hInstance); <br>            } <br>            else <br>            { <br>                PrivUninitialize3DCtl (hInstance); <br>            } <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PrivUninitialize3DCtl() <br>// <br>//    Parameters <br>//      hInstance   Handle to the instance the control 3d library will <br>//                  de-attach from. <br>// <br>//    Purpose <br>//      Unregister the 3D UI control stuff and unload the library of the <br>//      3D controls. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI PrivUninitialize3DCtl (HINSTANCE hInstance) <br>{ <br>    if (ghUIControl) <br>    { <br>        if (pfn3DUnregister) <br>        { <br>            pfn3DUnregister (hInstance); <br>        } <br>        FreeLibrary (ghUIControl); <br>        ghUIControl = NULL; <br>        pfn3DRegister = NULL; <br>        pfn3DUnregister = NULL; <br>        pfn3DAutoSubclass = NULL; <br>        pfnDlgSubclassEx = NULL; <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CheckForPendingMessages() <br>// <br>//    Parameters <br>//      szServerName        Name of the server we are going to connect <br>//      szMailboxName       Name of the mailbox we are going to check <br>//      pulMsgWaiting       Number of messages waiting for download <br>// <br>//    Purpose <br>//      This function queries the remote server for how many messages are <br>//      waiting in the specified mailbox. <br>//      If there are not messages waiting, the function return S_FALSE. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI CheckForPendingMessages (LPTSTR  szServerName, <br>                                        LPTSTR  szMailboxName, <br>                                        ULONG * pulMsgWaiting) <br>{ <br>    HRESULT hResult = BindToServer (szServerName); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    RpcTryExcept <br>    { <br>        hResult = RemoteCheckNewMail ((WINDS_RPC_STRING)szMailboxName, pulMsgWaiting); <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    #ifdef _DEBUG <br>    if (hResult &amp;&amp; S_FALSE != hResult) <br>    { <br>        TraceResult ("CheckForPendingMessages", hResult); <br>    } <br>    #endif // _DEBUG <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    GetNextMailboxMsg() <br>// <br>//    Parameters <br>//      szServerName        Name of the server we are going to connect <br>//      szMailboxName       Name of the mailbox we are going to get the <br>//                          messages from <br>//      szLocalMsgFile      Name of the local file where the message <br>//                          should be placed. <br>// <br>//    Purpose <br>//      This function connect to the server an request the next message to <br>//      be downloaded for the mailbox specified in call. If there are no <br>//      more messages to download, we return S_FALSE. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI GetNextMailboxMsg (LPTSTR szServerName, <br>                                  LPTSTR szMailboxName, <br>                                  LPTSTR szLocalMsgFile) <br>{ <br>    HRESULT hResult = BindToServer (szServerName); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br>    long lPipeNumber; <br>    HANDLE hPipe, hFile; <br>    TCHAR szPipeName[64]; <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    DWORD dwBytesRead, dwBytesWritten; <br>    RpcTryExcept <br>    { <br>        hResult = RemoteOpenOneMsgDownloadPipe ((WINDS_RPC_STRING)szMailboxName, &amp;lPipeNumber); <br>        if (!hResult) <br>        { <br>            wsprintf (szPipeName, PIPE_NAME_FORMAT, szServerName, lPipeNumber); <br>            hPipe = CreateFile (szPipeName, <br>                                GENERIC_READ, <br>                                0, <br>                                NULL, <br>                                OPEN_EXISTING, <br>                                0, <br>                                NULL); <br>            if (INVALID_HANDLE_VALUE == hPipe) <br>            { <br>                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                TraceResult ("GetHeadersFromServer: Failed to open pipe to server", hResult); <br>            } <br>            else <br>            { <br>                hFile = CreateFile (szLocalMsgFile, <br>                                    GENERIC_WRITE, <br>                                    0, <br>                                    NULL, <br>                                    CREATE_ALWAYS, <br>                                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, <br>                                    NULL); <br>                if (INVALID_HANDLE_VALUE == hFile) <br>                { <br>                    hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                    TraceResult ("GetNextMailboxMsg: Failed to open local headers file", hResult); <br>                } <br>                else <br>                { <br>                    do <br>                    { <br>                        // Read the pipe handle. <br>                        if (!ReadFile (hPipe, abBuffer, IO_BUFFERSIZE, &amp;dwBytesRead, NULL)) <br>                        { <br>                            hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                            if (HRESULT_FROM_WIN32(ERROR_BROKEN_PIPE)   != hResult &amp;&amp;   // For Windows NT <br>                                HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hResult)     // For Windows 95 <br>                            { <br>                                // There was an error and we can't continue <br>                                TraceResult ("GetNextMailboxMsg: Failed to read from the pipe", hResult); <br>                            } <br>                            else <br>                            { <br>                                // If the pipe was broken, it means the server finished writing <br>                                // to the it, so we are finished reading from it. <br>                                hResult = S_OK; <br>                            } <br>                        } <br>                        if (dwBytesRead) <br>                        { <br>                            if (!WriteFile (hFile, abBuffer, dwBytesRead, &amp;dwBytesWritten, NULL)) <br>                            { <br>                                hResult = HRESULT_FROM_WIN32(GetLastError()); <br>                                TraceResult ("GetNextMailboxMsg: Failed to write to local header file", hResult); <br>                            } <br>                        } <br>                    } while (dwBytesRead &amp;&amp; !hResult); <br>                    CloseHandle (hFile); <br>                } <br>                CloseHandle (hPipe); <br>            } <br>        } <br>    } <br>    RpcExcept(1) <br>    { <br>        // If we got here is because there was an error while call was made <br>        // or when it was about to be made. <br>        hResult = RpcExceptionCode(); <br>        if (RPC_S_SERVER_UNAVAILABLE == hResult) <br>        { <br>            hResult = HRESULT_FROM_WIN32(ERROR_HOST_UNREACHABLE); <br>        } <br>        else <br>        { <br>            hResult = MAKE_HRESULT(1, FACILITY_RPC, hResult); <br>        } <br>    } <br>    RpcEndExcept <br>    #ifdef _DEBUG <br>    if (hResult &amp;&amp; S_FALSE != hResult) <br>    { <br>        TraceResult ("GetNextMailboxMsg", hResult); <br>    } <br>    #endif // _DEBUG <br>    return hResult; <br>} <br> <br>// End of file for COMWINDS.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
