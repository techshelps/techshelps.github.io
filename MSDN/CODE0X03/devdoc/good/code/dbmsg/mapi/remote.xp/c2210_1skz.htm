<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPLIST.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2213"></a>XPLIST.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      XPLIST.CPP <br>// <br>//  Description <br>//      This file implements the classe CMsgQueue and CList used in this <br>//      transport to process remote messages. The two classes help us process <br>//      the list of messages selected in the Remote Viewer of a mail client. <br>// <br>//  Authors <br>//      Les Thaler <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>//   <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "XPWDSR.H" <br> <br>enum <br>{ <br>    STAT, <br>    EID, <br>    NUM_PROPS <br>}; <br>static const SizedSPropTagArray (NUM_PROPS, sptProps) = <br>{ <br>    NUM_PROPS, <br>    { <br>        PR_MSG_STATUS, <br>        PR_ENTRYID <br>    } <br>}; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMsgQueue::CMsgQueue() <br>// <br>//    Parameters                         <br>//      None. <br>// <br>//    Purpose <br>//      CMsgQueue class constructor.  <br>// <br>//    Return Value <br>//      None. <br>// <br>CMsgQueue::CMsgQueue() <br>{ <br>    m_ulItems  = 0; <br>    m_pHead = NULL; <br>    m_pTail = NULL; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMsgQueue::~MsgQueue() <br>// <br>//    Parameters                         <br>//      None.  <br>// <br>//    Purpose <br>//      CMsgQueue class destructor, walks the queue freeing each node <br>//      and the node's members. <br>// <br>//    Return Value <br>//      None <br>// <br>CMsgQueue::~CMsgQueue() <br>{ <br>    if (!Empty()) <br>    { <br>        PLIST_NODE pNode; <br>        do      <br>        { <br>            pNode = m_pHead-&gt;pNext; <br>            delete m_pHead; <br>            m_pHead = pNode; <br>        } while (pNode); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMsgQueue::Insert() <br>// <br>//    Parameters                         <br>//      pNode       Pointer to the node to queue <br>// <br>//    Purpose <br>//      Queues a node into the message queue <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI CMsgQueue::Insert (PLIST_NODE pNode) <br>{ <br>    pNode-&gt;pNext = NULL; <br>    if (Empty()) <br>    { <br>        m_pHead = m_pTail = pNode; <br>    } <br>    else <br>    { <br>        m_pTail-&gt;pNext = pNode; <br>        m_pTail = m_pTail-&gt;pNext;            <br>    } <br>    m_ulItems++; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMsgQueue::Delete() <br>// <br>//    Parameters                         <br>//      None. <br>// <br>//    Purpose <br>//      Dequeues a node from the message queue. The caller is responsible for <br>//      freeing the node after use. <br>// <br>//    Return Value <br>//      The pointer to the dequeued node on success, NULL otherwise <br>// <br>PLIST_NODE WINAPI CMsgQueue::Delete() <br>{    <br>    if (!m_ulItems) <br>    { <br>        return NULL; <br>    } <br>    PLIST_NODE pNode = m_pHead; <br>    if (m_pHead-&gt;pNext == NULL) <br>    { <br>        m_pHead = m_pTail = NULL; <br>    } <br>    else <br>    { <br>        m_pHead = m_pHead-&gt;pNext; <br>    } <br>    m_ulItems--; <br>    pNode-&gt;pNext = NULL; <br>    return pNode; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CList::CList() <br>// <br>//    Parameters                         <br>//      None <br>// <br>//    Purpose <br>//      Class constructor for the CList class, the list of downloaded <br>//      messages. Encapsulates the message queue and methods for manipulating <br>//      in the context of the CXPLogon object. <br>// <br>//    Return Value <br>//      None. <br>// <br>CList::CList() <br>{ <br>    m_pToDownload = NULL; <br>    m_pDownloaded = NULL; <br>    m_pLogon      = NULL; <br>} <br>  <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CList::~CList() <br>// <br>//    Parameters                         <br>//      None. <br>// <br>//    Purpose <br>//      CList class destructor. Frees the TO DO and DONE queues <br>// <br>//    Return Value <br>//      None. <br>// <br>CList::~CList() <br>{ <br>    // free the msg queues <br>    delete m_pToDownload; <br>    m_pToDownload = NULL; <br>    delete m_pDownloaded; <br>    m_pDownloaded = NULL; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    PropToMID() <br>// <br>//    Parameters                         <br>//      lProp       the MAPI MSGSTATUS_REMOTExx flag <br>// <br>//    Purpose <br>//      Translate the MAPI MSGSTATUS_REMOTExx flag bimask into an internal <br>//      message ID. This utility function is useful for walking the contents <br>//      table and checking which messages have been marked for downloading, <br>//      moving, etc. <br>// <br>//    Return Value <br>//      The message ID if lProp indicates the message was marked for a remote <br>//      operation, UNMARKED otherwise. <br>// <br>MID WINAPI PropToMID (long lProp) <br>{ <br>    if (lProp &amp; MSGSTATUS_REMOTE_DOWNLOAD) <br>    { <br>        if (lProp &amp; MSGSTATUS_REMOTE_DELETE) <br>        { <br>            return MSG_MOVE; <br>        } <br>        else <br>        { <br>            return MSG_DOWNLOAD; <br>        } <br>    } <br>    else <br>    { <br>        if (lProp &amp; MSGSTATUS_REMOTE_DELETE) <br>        { <br>            return MSG_DELETE; <br>        } <br>    } <br>    return UNMARKED;         <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CList::UpdateTableRow() <br>// <br>//    Parameters                         <br>//      pEID        Pointer to a message entry ID <br>//      midAction   Action taken on a row of the remote folder contents table <br>// <br>//    Purpose <br>//      Update a message's row in the contents table. Call this <br>//      method after a remote DOWNLOAD, MOVE or DELETE to synch the local <br>//      header contents table with what's really on the server. <br>// <br>//    Return Value <br>//      TRUE on success, FALSE otherwise <br>// <br>BOOL WINAPI CList::UpdateTableRow (LPBYTE pEID, MID midAction) <br>{ <br>    SPropValue spvEID = { 0 }; <br>    spvEID.ulPropTag = PR_ENTRYID; <br>    spvEID.Value.bin.cb = TRANSPORT_MESSAGE_EID_SIZE; <br>    spvEID.Value.bin.lpb = pEID; <br>    LPTABLEDATA pTableData = m_pLogon-&gt;GetRemoteFolderTableData(); <br>    HRESULT hResult; <br>    if (midAction == MSG_DOWNLOAD) <br>    { <br>        LPSRow pRow; <br>        ULONG i; <br>        long lOldFlags; <br>        hResult = pTableData-&gt;HrQueryRow (&amp;spvEID, &amp;pRow, NULL); <br>        TraceResult ("CList::UpdateTableRow: Failed to query the table row", hResult); <br>        if (!hResult) <br>        { <br>            for (i=0; i&lt;pRow-&gt;cValues; i++) <br>            { <br>                if (PR_MESSAGE_FLAGS == pRow-&gt;lpProps[i].ulPropTag) <br>                { <br>                    lOldFlags = pRow-&gt;lpProps[i].Value.l; <br>                    pRow-&gt;lpProps[i].Value.l |= MSGFLAG_READ; <br>                    if (pRow-&gt;lpProps[i].Value.l != lOldFlags) <br>                    { <br>                        hResult = pTableData-&gt;HrModifyRow (pRow); <br>                    } <br>                    break; // Out of the FOR() loop <br>                } <br>            } <br>            gpfnFreeBuffer (pRow); <br>        } <br>    } <br>    else <br>    { <br>        hResult = pTableData-&gt;HrDeleteRow (&amp;spvEID); <br>    } <br>    TraceResult ("CList::UpdateTableRow: Failed to update the table row", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CList::Init() <br>// <br>//    Parameters                         <br>//      none. <br>// <br>//    Purpose <br>//      Initializes the CList object. Creates the 'TO DO' and "DONE' <br>//      message queues. <br>// <br>//    Return Value <br>//      TRUE on success, FALSE otherwise <br>// <br>BOOL WINAPI CList::Init() <br>{ <br>    if (m_pToDownload) <br>    { <br>        delete m_pToDownload; <br>    } <br>    m_pToDownload = new CMsgQueue; <br>    if (m_pDownloaded) <br>    { <br>        delete m_pDownloaded; <br>    } <br>    m_pDownloaded = new CMsgQueue; <br> <br>    if (!m_pToDownload || !m_pDownloaded) <br>    { <br>        delete m_pToDownload; <br>        delete m_pDownloaded; <br>        TraceMessage ("CList::Init: Failed to create download queues"); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CList::DownLoadMsgs() <br>// <br>//    Parameters                         <br>//      pTable          Pointer to the header contents table <br>//      ulRowCount      Count of entries in the contents table <br>//      hPipe           Handle to the named pipe opened to the server <br>//                      where the messages in being downloaded through. <br>// <br>//    Purpose <br>//      Walks through the contents table and checks the PR_MSG_STATUS of each <br>//      entry. Messages marked for download, move, or delete are allocated a <br>//      node for queuing the "TO DO' queue. Messages marked for download or <br>//      move additionally have a temporary filename created for them to hold <br>//      the downloaded message.  <br>// <br>//      If the resulting 'TO DO' queue is non-empty, the download worker <br>//      thread is started and the CList object passed to it. This starts the <br>//      background processing of messages in the 'TO DO' queue. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI CList::DownLoadMsgs (LPMAPITABLE pTable, ULONG ulRowCount, HANDLE hPipe) <br>{ <br>    HRESULT hResult = pTable-&gt;SetColumns ((LPSPropTagArray)&amp;sptProps, 0); <br>    if (hResult) <br>    { <br>        TraceResult ("CList::DownLoadMsgs: Failed to set the columns", hResult); <br>        return hResult; <br>    } <br> <br>    LPSRowSet pRows; <br>    hResult = pTable-&gt;QueryRows (ulRowCount, 0, &amp;pRows); <br>    if (hResult) <br>    { <br>        TraceResult ("CList::DownLoadMsgs: Failed to get the rows", hResult); <br>        return hResult; <br>    } <br> <br>    // construct the list of msgs to download/delete/move <br>    ASSERT (pRows-&gt;cRows); <br>    MID midMsgAction; <br>    for (ULONG i=0; i&lt;pRows-&gt;cRows; i++) <br>    { <br>        ASSERT (PR_MSG_STATUS == pRows-&gt;aRow[i].lpProps[STAT].ulPropTag); <br>        ASSERT (PR_ENTRYID == pRows-&gt;aRow[i].lpProps[EID].ulPropTag); <br>        if (pRows-&gt;aRow[i].lpProps[STAT].ulPropTag == PR_MSG_STATUS &amp;&amp; <br>            pRows-&gt;aRow[i].lpProps[EID].ulPropTag  == PR_ENTRYID) <br>        { <br>            midMsgAction= PropToMID (pRows-&gt;aRow[i].lpProps[STAT].Value.l); <br>            // Queue message only if marked for remote processing <br>            if (UNMARKED != midMsgAction) <br>            { <br>                PLIST_NODE pNode= new LIST_NODE; <br>                if (NULL == pNode) <br>                { <br>                    TraceMessage ("CList::DownLoadMsgs: Failed to allocate new node"); <br>                    hResult = E_OUTOFMEMORY; <br>                    break; <br>                } <br>                ZeroMemory (pNode, sizeof(LIST_NODE)); <br>                pNode-&gt;fRetry = FALSE; <br> <br>                // Only downloaded/moved msgs need the tempfile <br>                if (midMsgAction == MSG_DOWNLOAD || midMsgAction == MSG_MOVE)                 <br>                { <br>                    m_pLogon-&gt;GetMsgTempFileName (pNode-&gt;szFileName); <br>                } <br>                ASSERT (TRANSPORT_MESSAGE_EID_SIZE == pRows-&gt;aRow[i].lpProps[EID].Value.bin.cb); <br>                CopyMemory (pNode-&gt;Hdr.Info.EID, pRows-&gt;aRow[i].lpProps[EID].Value.bin.lpb, TRANSPORT_MESSAGE_EID_SIZE); <br>                pNode-&gt;Hdr.ulMID = pNode-&gt;OpStat = midMsgAction; <br>                // insert in 'TO DO' queue <br>                m_pToDownload-&gt;Insert (pNode); <br>            } <br>        } <br>    } <br>    FreeProws(pRows); <br>    if (!hResult) <br>    { <br>        ASSERT (!m_pToDownload-&gt;Empty()); <br>        DownLoadNow (hPipe); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CList::DownLoadNow() <br>// <br>//    Parameters                         <br>//      hPipe           Handle to the named pipe opened to the server <br>//                      where the messages in being downloaded through. <br>// <br>//    Purpose <br>//      For each message in the 'TO DO' queue, check its requested <br>//      operation and format a control command to send over the pipe to <br>//      the server.  <br>// <br>//      The control command will contain the requested operation code and <br>//      the remote entry ID of the message. The server will ACK the control <br>//      command if the operation can be performed on the server side. The  <br>//      ACK message sent back by the server contains the size in bytes of <br>//      the data stream that the server will next write to the pipe. <br>// <br>//      If the server can't perform the requested operation (e.g. the message <br>//      can't be opened), it sends back an OP_FAILED command (NAK) and the  <br>//      dequeued TO DO message is discarded. This is considered a non-fatal error. <br>//      and the rest of the queue is processed. <br>//    <br>//      Downloaded and moved messages have a temporary file created for them before <br>//      the data transfer to the message store is started. A failure creating the <br>//      file is also non-fatal, the current message is discarded but processing <br>//      continues. After the temp file is created, data transfer is started on <br>//      the pipe. The stream is copied from the pipe into the temp file. <br>// <br>//      If the MOVE/DOWNLOAD operation succeeds, the 'TO DO' message is inserted <br>//      into the 'DONE' queue which is then passed to StartMessage for processing <br>//      in the spooler Poll() loop. <br>// <br>//      On exit, we send the server a 'HANG UP' command. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CList::DownLoadNow (HANDLE hPipe) <br>{ <br>    PLIST_NODE pNode; <br>    MSG_HDR CtrlMsg, InMsg; <br>    DWORD dwBytes; <br>    m_ulMsgCount = m_pToDownload-&gt;m_ulItems; <br>    for (ULONG i=0; i&lt;m_ulMsgCount; i++) <br>    { <br>        pNode = m_pToDownload-&gt;Delete(); <br>        if (NULL == pNode) <br>        { <br>            TraceMessage ("CList::DownLoadNow: Failed to get node from internal queue"); <br>            continue; // The FOR() loop <br>        } <br>        CtrlMsg = pNode-&gt;Hdr; <br>        switch (pNode-&gt;Hdr.ulMID) <br>        { <br>            case MSG_MOVE : <br>            case MSG_DOWNLOAD : <br>                // We need a temp file where we download the server message temporeraly <br>                // until it gets picked up in IXPLogon::StartMessage() <br>                pNode-&gt;hFile = CreateFile (pNode-&gt;szFileName, <br>                                           GENERIC_READ | GENERIC_WRITE, <br>                                           FILE_SHARE_READ, <br>                                           NULL, <br>                                           CREATE_ALWAYS, <br>                                           FILE_ATTRIBUTE_TEMPORARY, <br>                                           NULL); <br>                if (INVALID_HANDLE_VALUE == pNode-&gt;hFile) <br>                { <br>                    pNode-&gt;OpStat = OP_FAILED; <br>                    TraceResult ("CList::DownLoadNow: Failed to create local file", GetLastError()); <br>                    goto ProcessNextMessage; <br>                } <br>                // The node has a header structure with the command action to instruct <br>                // the server on what we need to do on this message <br>                if (!WriteFile (hPipe, &amp;CtrlMsg, sizeof(MSG_HDR), &amp;dwBytes, NULL)) <br>                { <br>                    TraceResult ("CList::DownLoadNow: (MOVE/COPY) Failed to send control message to host", GetLastError()); <br>                    goto ProcessNextMessage; <br>                } <br>                // Upon receiving the control header, the remote host sent a response <br>                if (!ReadFile (hPipe, &amp;InMsg, sizeof(MSG_HDR), &amp;dwBytes, NULL)) <br>                { <br>                    TraceResult ("CList::DownLoadNow: (MOVE/COPY) Failed to receive message to data", GetLastError()); <br>                    goto ProcessNextMessage; <br>                } <br>                // Check the result of the host and if successful, copy the message to a local file <br>                if (OP_FAILED == InMsg.ulMID || <br>                    NO_ERROR != FileCopy (pNode-&gt;hFile, hPipe, InMsg.Info.ulMsgLen)) <br>                { <br>                    goto ProcessNextMessage; <br>                } <br>                // If the message was moved from the remote server, we must remote the <br>                // row in the remote folder viewer. <br>                UpdateTableRow (pNode-&gt;Hdr.Info.EID, pNode-&gt;Hdr.ulMID); <br>                m_pDownloaded-&gt;Insert (pNode); <br>                pNode = NULL; <br>                break; <br> <br>            case MSG_DELETE : <br>                if (!WriteFile (hPipe, &amp;CtrlMsg, sizeof(MSG_HDR), &amp;dwBytes, NULL)) <br>                { <br>                    TraceResult ("CList::DownLoadNow: (DELETE) Failed to send control message to host", GetLastError()); <br>                    goto ProcessNextMessage; <br>                } <br>                if (!ReadFile (hPipe, &amp;InMsg, sizeof(MSG_HDR), &amp;dwBytes, NULL)) <br>                { <br>                    TraceResult ("CList::DownLoadNow: (DELETE) Failed to receive message to data", GetLastError()); <br>                    goto ProcessNextMessage; <br>                } <br>                if (InMsg.ulMID != OP_FAILED) <br>                { <br>                    UpdateTableRow (pNode-&gt;Hdr.Info.EID, MSG_DELETE); <br>                } <br>                break; <br>            default : <br>                TraceMessage ("CList::DownLoadNow: Unknown action on this node"); <br>                break; <br>        } <br>ProcessNextMessage: <br>        m_pLogon-&gt;UpdateProgress ((((i + 1) * 100) / m_ulMsgCount), REMOTE_ACTION_DOWNLOADING_MSGS); <br>        if (pNode) <br>        { <br>            if (pNode-&gt;hFile) <br>            { <br>                CloseHandle (pNode-&gt;hFile); <br>                DeleteFile (pNode-&gt;szFileName); <br>            } <br>            delete pNode; <br>        } <br>    } <br>    CtrlMsg.ulMID = GOODBYE; <br>    WriteFile (hPipe, &amp;CtrlMsg, sizeof(MSG_HDR), &amp;dwBytes, NULL); <br>    m_ulMsgLeft = m_ulMsgCount;  <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CList::UpdateProgress() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      Update the progress percentage in the status row after a message is <br>//      processed in IXPLogon::StartMessage() <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CList::UpdateProgress() <br>{ <br>    if (m_ulMsgCount) <br>    { <br>        m_ulMsgLeft--; <br>        m_pLogon-&gt;UpdateProgress ((((m_ulMsgCount - m_ulMsgLeft) * 100) / m_ulMsgCount), <br>                                    REMOTE_ACTION_PROCESSING_MSGS); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    FileCopy() <br>// <br>//    Parameters                         <br>//      hDest       Handle of stream object receiving the data <br>//      hSrc        Handle of stream object whence data <br>//      dwMsgLen    Number of bytes to transfer <br>// <br>//    Purpose <br>//      Transfers dwMsgLen bytes from hSrc to hDest. The objects can be <br>//      open file handles, pipes, or any stream oriented object that uses <br>//      the Read/WriteFile semantics.       <br>// <br>//    Return Value <br>//      NO_ERROR on success, ERROR_READ/WRITE_FAULT otherwise <br>// <br>long WINAPI FileCopy (HANDLE hDest, HANDLE hSrc, DWORD dwMsgLen) <br>{ <br>    BYTE abBuffer[IO_BUFFERSIZE];  <br>    DWORD dwRead, dwRemaining = dwMsgLen; <br>    BOOL bSuccess; <br>    long lResult = NO_ERROR; <br>    for (DWORD dwWritten=0 ; dwRemaining&gt;0; dwRemaining -= dwWritten) <br>    { <br>        bSuccess = ReadFile (hSrc, abBuffer, min(dwRemaining, IO_BUFFERSIZE), &amp;dwRead, NULL); <br>        if (!dwRead || !bSuccess) <br>        { <br>            lResult = ERROR_READ_FAULT; <br>            break; <br>        } <br>        bSuccess = WriteFile (hDest, abBuffer, dwRead, &amp;dwWritten, NULL); <br>        if (!dwWritten || !bSuccess) <br>        { <br>            lResult = ERROR_WRITE_FAULT; <br>            break; <br>        } <br>    } <br>    if (lResult) <br>    { <br>        TraceResult ("CList::FileCopy: IO operation failed", GetLastError()); <br>    } <br>    else <br>    { <br>        FlushFileBuffers (hDest); <br>        SetFilePointer (hDest, 0, NULL, FILE_BEGIN); <br>    } <br>    return lResult; <br>} <br> <br>// End of file for XPLIST.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
