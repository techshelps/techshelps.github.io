<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPSTATUS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2218"></a>XPSTATUS.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name <br>//      XPSTATUS.CPP  <br>// <br>//  Description <br>//      This file implements the methods for the IMAPIStatus interface. <br>// <br>//  Authors <br>//      Irving De la Cruz <br>//      Les Thaler <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "XPWDSR.H" <br> <br>// Remark this line to turn verbose tracing OFF <br>#define DO_INFO_TRACES <br>#ifdef DO_INFO_TRACES <br>#define InfoTrace(a)   TraceInfoMessage(a) <br>#else <br>#define InfoTrace(a)    <br>#endif // DO_INFO_TRACES <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::CMAPIStatus() <br>// <br>//    Parameters <br>//      pLogon          Parent logon session for this IMAPIStatus object <br>//      pProfSectObj    Profile section object for this provider <br>// <br>//    Purpose <br>//      Constructor of the object. Parameters are passed to initialize the <br>//      data members with the appropiate values. <br>// <br>//    Return Value <br>//      None <br>// <br>CMAPIStatus::CMAPIStatus (CXPLogon * pLogon, LPPROFSECT pProfSectObj) <br> <br>{ <br>    InfoTrace ("CMAPIStatus: Constructor called"); <br>    m_cRef          = 1; <br>    m_pLogon        = pLogon; // Don't AddRef() this object (to avoid circular reference) <br>    m_pHeaderFolder = NULL; <br>    m_pProfSectObj  = pProfSectObj; <br>    if (m_pProfSectObj) <br>    { <br>        m_pProfSectObj-&gt;AddRef(); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::~CMAPIStatus() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      Destructor of CMAPIStatus <br>// <br>//    Return Value <br>//      None <br>// <br>CMAPIStatus::~CMAPIStatus () <br>{ <br>    InfoTrace ("CMAPIStatus: Destructor called"); <br>    if (m_pProfSectObj) <br>    { <br>        m_pProfSectObj-&gt;Release(); <br>    } <br>    if (m_pHeaderFolder &amp;&amp; m_pHeaderFolder-&gt;m_cRef) <br>    { <br>        m_pHeaderFolder-&gt;Release();     // Release our instance of the folder <br>    } <br>    m_pHeaderFolder = NULL; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::QueryInterface() <br>// <br>//    Parameters <br>//      { Refer to OLE Documentation on this method } <br>// <br>//    Purpose <br>//      Returns a pointer to a interface requested if the interface is  <br>//      supported and implemented by this object. If it is not supported, it  <br>//      returns NULL <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIStatus::QueryInterface (REFIID riid, LPVOID * ppvObj) <br>{ <br>    HRESULT hResult = S_OK; <br>    // OLE requires NULLing parameter <br>    *ppvObj = NULL; <br>    // If this is one of the supported IIDs return an interface pointer to it <br>    if (riid == IID_IMAPIStatus || riid == IID_IMAPIProp || riid == IID_IUnknown) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        AddRef(); <br>    } <br>    else <br>    { <br>        // The status object of a remote transport can return a folder object, <br>        // if the IID requested is for a MAPI folder object. The object returned in <br>        // this case is the folder that has the headers of messages available in <br>        // the remote host. A remote client viewer application requests operations <br>        // on those message by modifying the PR_MESSAGE_STATUS property in each <br>        // row of the contents table of this folder and later calls the <br>        // ValidateState method of this IMAPIStatus object <br>        if (riid == IID_IMAPIFolder) <br>        { <br>            // If we already have a folder around, return the same object to the caller. <br>            if (!m_pHeaderFolder) <br>            { <br>                m_pHeaderFolder = new CMAPIFolder (this, m_pLogon); <br>                if (!m_pHeaderFolder) <br>                { <br>                    TraceMessage("CMAPIStatus::QueryInterface: Unable to create remote viewer folder"); <br>                    hResult = E_OUTOFMEMORY; <br>                } <br>            } <br>            if (!hResult) <br>            { <br>                m_pHeaderFolder-&gt;AddRef();      // One for the caller requesting it <br>                *ppvObj = (LPVOID)m_pHeaderFolder; <br>            } <br>        } <br>        else <br>        { <br>            // This object does not support the interface requested <br>            hResult = E_NOINTERFACE; <br>        } <br>    } <br>    return hResult; <br>}     <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IMAPIProp virtual member functions <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::GetLastError() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Called by a client to get a string from the transport describing the <br>//      last error that occurred. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIStatus::GetLastError (HRESULT         hError, <br>                                        ULONG           ulFlags, <br>                                        LPMAPIERROR *   ppMAPIError) <br>{ <br>    InfoTrace ("CMAPIStatus::GetLastError method called"); <br>    Validate_IMAPIProp_GetLastError (this, hError, ulFlags, ppMAPIError); <br>    // Allocate and fill a MAPIERROR structure with the error passed in. <br>    // Use the common helper function GetMAPIError <br>    return GetMAPIError (ppMAPIError, ulFlags, hError, m_pLogon-&gt;GetInstance()); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::SaveChanges() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Place holder. Replace this function with actual implementation  <br>//      if needed. <br>// <br>//    Return Value <br>//      S_OK always. <br>// <br>STDMETHODIMP CMAPIStatus::SaveChanges (ULONG ulFlags) <br>{ <br>    InfoTrace ("CMAPIStatus::SaveChanges method called"); <br>    Validate_IMAPIProp_SaveChanges (this, ulFlags); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::GetProps() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      The caller specifies an array of tags, and this method returns a <br>//      property value array for thoses tag, if found. The tags are the ones <br>//      available in the transport ID array <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIStatus::GetProps (LPSPropTagArray     pTags, <br>                                    ULONG               ulFlags, <br>                                    ULONG *             pcValues, <br>                                    LPSPropValue *      ppPropArray) <br>{ <br>    InfoTrace ("CMAPIStatus::GetProps method called"); <br>    Validate_IMAPIProp_GetProps (this, pTags, ulFlags, pcValues, ppPropArray); <br>     <br>    #ifdef DO_INFO_TRACES <br>    if (!pTags) <br>    { <br>        TraceInfoMessage ("CMAPIStatus::GetProps: All properties requested"); <br>    } <br>    else <br>    { <br>        TraceMessage ("CMAPIStatus::GetProps Properties requested..."); for (ULONG j=0; j&lt;pTags-&gt;cValues; j++) { TraceProp (pTags-&gt;aulPropTag[j]); } <br>    } <br>    #endif // DO_INFO_TRACES <br> <br>    BOOL fGetAllProps = pTags ? FALSE : TRUE; <br>    if (!pTags) <br>    { <br>        pTags = (LPSPropTagArray)&amp;sptStatusObj; <br>    } <br>     <br>    *pcValues = pTags-&gt;cValues; <br>    HRESULT hResult = gpfnAllocateBuffer (sizeof(SPropValue)*(*pcValues), (LPVOID *)ppPropArray); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIStatus::GetProps: Memory allocation failed", hResult); <br>        return hResult; <br>    } <br>    if (fGetAllProps) <br>    { <br>        for (ULONG i=0; i&lt;sptStatusObj.cValues; i++) <br>        { <br>            (*ppPropArray)[i].ulPropTag = sptStatusObj.aulPropTag[i]; <br>        } <br>    } <br>    else <br>    { <br>        // A client of the IMAPIProp::GetProps() method can pass PT_UNSPECIFIED in the <br>        // tag of a property. Is the provider's responsiblity to return <br>        // the proper type of the property. <br>        for (ULONG k=0; k&lt;pTags-&gt;cValues; k++) <br>        { <br>            for (ULONG i=0; i&lt;sptStatusObj.cValues; i++) <br>            { <br>                if (PROP_ID(pTags-&gt;aulPropTag[k]) == PROP_ID(sptStatusObj.aulPropTag[i])) <br>                { <br>                    (*ppPropArray)[k].ulPropTag = sptStatusObj.aulPropTag[i]; <br>                } <br>                else <br>                { <br>                    (*ppPropArray)[k].ulPropTag = pTags-&gt;aulPropTag[k]; <br>                } <br>            } <br>        } <br>    } <br> <br>    TCHAR szBuffer[128]; <br>    BOOL fGotErrors = FALSE;     <br>    LPVOID pSrc, pDst; <br>    ULONG cbSize; <br>    for (ULONG i=0; i&lt;*pcValues; i++) <br>    { <br>        hResult = S_OK; <br>        switch ((*ppPropArray)[i].ulPropTag) <br>        { <br>            case PR_NULL : <br>                (*ppPropArray)[i].Value.err = S_OK; <br>                break; <br>            case PR_RESOURCE_METHODS : <br>                (*ppPropArray)[i].Value.l = STATUS_SETTINGS_DIALOG | <br>                                            STATUS_FLUSH_QUEUES | <br>                                            STATUS_VALIDATE_STATE | <br>                                            STATUS_CHANGE_PASSWORD; <br>                break; <br>            case PR_RESOURCE_TYPE : <br>                (*ppPropArray)[i].Value.l = MAPI_TRANSPORT_PROVIDER; <br>                break; <br>            case PR_RESOURCE_FLAGS : <br>                hResult = E_FAIL; <br>                if (m_pProfSectObj) <br>                { <br>                    LPSPropValue pResFlags; <br>                    SPropTagArray sptResFlags = { 1, { PR_RESOURCE_FLAGS } }; <br>                    ULONG cValues; <br>                    hResult = m_pProfSectObj-&gt;GetProps (&amp;sptResFlags, fMapiUnicode, &amp;cValues, &amp;pResFlags); <br>                    if (SUCCEEDED(hResult)) <br>                    { <br>                        if (PR_RESOURCE_FLAGS == pResFlags-&gt;ulPropTag) <br>                        { <br>                            (*ppPropArray)[i].Value.l = pResFlags-&gt;Value.l; <br>                        } <br>                        gpfnFreeBuffer (pResFlags); <br>                    } <br>                } <br>                if (hResult) <br>                { <br>                    (*ppPropArray)[i].Value.l = STATUS_PRIMARY_IDENTITY; <br>                    hResult = S_OK; <br>                } <br>                break; <br>            case PR_DISPLAY_NAME : <br>                wsprintf (szBuffer, <br>                          TEXT("%s (%s)"), <br>                          TRANSPORT_DISPLAY_NAME_STRING, <br>                          m_pLogon-&gt;GetServerName()); <br>                pSrc = (LPVOID)szBuffer; <br>                break; <br>            case PR_PROVIDER_DLL_NAME : <br>                pSrc = (LPVOID)TRANSPORT_DLL_NAME_STRING; <br>                break; <br>            case PR_PROVIDER_DISPLAY : <br>                pSrc = (LPVOID)TRANSPORT_DISPLAY_NAME_STRING; <br>                break; <br>            case PR_IDENTITY_DISPLAY : <br>                pSrc = (LPVOID)m_pLogon-&gt;m_pIdentityProps[XPID_NAME].Value.LPSZ; <br>                break; <br>            case PR_IDENTITY_ENTRYID : <br>                cbSize = m_pLogon-&gt;m_pIdentityProps[XPID_EID].Value.bin.cb; <br>                pSrc = (LPVOID)m_pLogon-&gt;m_pIdentityProps[XPID_EID].Value.bin.lpb; <br>                break; <br>            case PR_IDENTITY_SEARCH_KEY : <br>                cbSize = m_pLogon-&gt;m_pIdentityProps[XPID_SEARCH_KEY].Value.bin.cb; <br>                pSrc = (LPVOID)m_pLogon-&gt;m_pIdentityProps[XPID_SEARCH_KEY].Value.bin.lpb; <br>                break; <br>            case PR_STATUS_CODE : <br>                (*ppPropArray)[i].Value.l = (long)m_pLogon-&gt;GetTransportStatusCode(); <br>                break; <br>            case PR_STATUS_STRING : <br>                szBuffer[0] = 0; <br>                m_pLogon-&gt;LoadStatusString (szBuffer, sizeof(szBuffer) - 1); <br>                pSrc = (LPVOID)szBuffer; <br>                break; <br>            case PR_CURRENT_VERSION : <br>                (*ppPropArray)[i].Value.li.LowPart = TRANSPORT_VERSION_MAJOR; <br>                (*ppPropArray)[i].Value.li.HighPart = TRANSPORT_VERSION_MINOR; <br>                break; <br>            case PR_OBJECT_TYPE : <br>                (*ppPropArray)[i].Value.l = MAPI_STATUS; <br>                break; <br>            default: <br>                hResult = MAPI_E_NOT_FOUND; <br>                #ifdef DO_INFO_TRACES <br>                TraceRaw ("CMAPIStatus::GetProps: Not Found - "); TraceProp ((*ppPropArray)[i].ulPropTag); <br>                #endif // #DO_INFO_TRACES <br>                break; <br>        } <br>        if (!hResult &amp;&amp;  <br>            (PROP_TYPE((*ppPropArray)[i].ulPropTag) == PT_BINARY || <br>             PROP_TYPE((*ppPropArray)[i].ulPropTag) == PT_TSTRING)) <br>        { <br>            if (PROP_TYPE((*ppPropArray)[i].ulPropTag) == PT_TSTRING) <br>            { <br>                cbSize = Cbtszsize ((LPTSTR)pSrc); <br>            } <br>            hResult = gpfnAllocateMore (cbSize, *ppPropArray, &amp;pDst); <br>            if (!hResult) <br>            { <br>                CopyMemory (pDst, pSrc, cbSize); <br>                if (PROP_TYPE((*ppPropArray)[i].ulPropTag) == PT_BINARY) <br>                { <br>                    (*ppPropArray)[i].Value.bin.cb  = cbSize; <br>                    (*ppPropArray)[i].Value.bin.lpb = (LPBYTE)pDst; <br>                } <br>                else <br>                { <br>                    (*ppPropArray)[i].Value.LPSZ = (LPTSTR)pDst; <br>                } <br>            } <br>        } <br>        if (hResult) <br>        { <br>            (*ppPropArray)[i].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID((*ppPropArray)[i].ulPropTag)); <br>            (*ppPropArray)[i].Value.err = hResult; <br>            fGotErrors = TRUE; <br>        } <br>    } <br>    if (fGotErrors) <br>    { <br>        hResult = MAPI_W_ERRORS_RETURNED; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::GetPropList() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Returns a tag array with the properties in the status row of this  <br>//      transport. The caller is responsible for freeing the memory allocated <br>//      for the tag array. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIStatus::GetPropList (ULONG                ulFlags, <br>                                       LPSPropTagArray *    ppPropTagArray) <br>{ <br>    InfoTrace ("CMAPIStatus::GetPropList method called"); <br>    Validate_IMAPIProp_GetPropList (this, ulFlags, ppPropTagArray); <br> <br>    ULONG cbTagsArraySize = CbNewSPropTagArray(NUM_STATUS_OBJECT_PROPS); <br>    // Allocate the required amount of memory <br>    HRESULT hResult = gpfnAllocateBuffer (cbTagsArraySize, (LPVOID *)ppPropTagArray); <br>    TraceResult ("CMAPIStatus::GetPropList: Memory allocation failed", hResult); <br>    if (!hResult) <br>    { <br>        // Copy the contents of our property tag array into the buffer <br>        CopyMemory (*ppPropTagArray, &amp;sptStatusObj, cbTagsArraySize); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::OpenProperty() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Place holder. Replace this function with actual implementation  <br>//      if needed. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIStatus::OpenProperty (ULONG           ulPropTag, <br>                                        LPCIID          piid, <br>                                        ULONG           ulInterfaceOptions, <br>                                        ULONG           ulFlags, <br>                                        LPUNKNOWN *     ppUnk) <br>{ <br>    InfoTrace ("CMAPIStatus::OpenProperty method called"); <br>    Validate_IMAPIProp_OpenProperty (this, ulPropTag,  piid, ulInterfaceOptions, ulFlags, ppUnk); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::SetProps() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Place holder. Replace this function with actual implementation  <br>//      if needed. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIStatus::SetProps (ULONG                   cValues, <br>                                    LPSPropValue            pPropArray, <br>                                    LPSPropProblemArray *   ppProblems) <br>{ <br>    InfoTrace ("CMAPIStatus::SetProps method called"); <br>    Validate_IMAPIProp_SetProps (this, cValues, pPropArray, ppProblems); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::DeleteProps() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Place holder. Replace this function with actual implementation  <br>//      if needed. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIStatus::DeleteProps (LPSPropTagArray          pPropTagArray, <br>                                       LPSPropProblemArray *    ppProblems) <br>{ <br>    InfoTrace ("CMAPIStatus::DeleteProps method called"); <br>    Validate_IMAPIProp_DeleteProps (this, pPropTagArray, ppProblems); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::CopyTo() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Place holder. Replace this function with actual implementation  <br>//      if needed. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIStatus::CopyTo (ULONG                   ciidExclude, <br>                                  LPCIID                  rgiidExclude, <br>                                  LPSPropTagArray         pExcludeProps, <br>                                  ULONG                   ulUIParam, <br>                                  LPMAPIPROGRESS          pProgress, <br>                                  LPCIID                  pInterface, <br>                                  LPVOID                  pDestObj, <br>                                  ULONG                   ulFlags, <br>                                  LPSPropProblemArray *   ppProblems) <br>{ <br>    InfoTrace ("CMAPIStatus::CopyTo method called"); <br>    Validate_IMAPIProp_CopyTo (this, <br>                               ciidExclude, <br>                               rgiidExclude, <br>                               pExcludeProps, <br>                               ulUIParam, <br>                               pProgress, <br>                               pInterface, <br>                               pDestObj, <br>                               ulFlags, <br>                               ppProblems); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::CopyProps() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Place holder. Replace this function with actual implementation  <br>//      if needed. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIStatus::CopyProps (LPSPropTagArray            pIncludeProps, <br>                                     ULONG                      ulUIParam, <br>                                     LPMAPIPROGRESS             pProgress, <br>                                     LPCIID                     pInterface, <br>                                     LPVOID                     pDestObj, <br>                                     ULONG                      ulFlags, <br>                                     LPSPropProblemArray *      ppProblems) <br>{ <br>    InfoTrace ("CMAPIStatus::CopyProps method called"); <br>    Validate_IMAPIProp_CopyProps (this, <br>                                  pIncludeProps, <br>                                  ulUIParam, <br>                                  pProgress, <br>                                  pInterface, <br>                                  pDestObj, <br>                                  ulFlags, <br>                                  ppProblems); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::GetNamesFromIDs() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Place holder. Replace this function with actual implementation  <br>//      if needed. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIStatus::GetNamesFromIDs (LPSPropTagArray *    ppPropTags, <br>                                           LPGUID               pPropSetGuid, <br>                                           ULONG                ulFlags, <br>                                           ULONG *              pcPropNames, <br>                                           LPMAPINAMEID **      pppPropNames) <br>{ <br>    InfoTrace ("CMAPIStatus::GetNamesFromIDs method called"); <br>    Validate_IMAPIProp_GetNamesFromIDs (this, <br>                                        ppPropTags, <br>                                        pPropSetGuid, <br>                                        ulFlags, <br>                                        pcPropNames, <br>                                        pppPropNames); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::GetIDsFromNames() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Place holder. Replace this function with actual implementation  <br>//      if needed. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIStatus::GetIDsFromNames (ULONG                cPropNames, <br>                                           LPMAPINAMEID *       ppPropNames, <br>                                           ULONG                ulFlags, <br>                                           LPSPropTagArray *    ppPropTags) <br>{ <br>    InfoTrace ("CMAPIStatus::GetIDsFromNames method called"); <br>    Validate_IMAPIProp_GetIDsFromNames (this, <br>                                        cPropNames, <br>                                        ppPropNames, <br>                                        ulFlags, <br>                                        ppPropTags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IMAPIStatus virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::ValidateState() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      This method is called by the REMOTE viewer UI to start the remote <br>//      processing. We check the ulFlags bits to see what operation is being <br>//      requested and do it. All the operation of this transport are <br>//      ASYNCHRONOUS meaning, that the call returns to the client before the <br>//      action is truly completed. <br>//      To control this, we dynamically change PR_REMOTE_VALIDATE_OK on the <br>//      status row so that the client calls us at intervals to check if we <br>//      finished or not. <br>//      When an action is requested, we change the internal state of the <br>//      transport and we tell the spooler to FLUSH us, so that it can better <br>//      manage interaction with multiple transport. <br>//      This is the recommended way for remote transports to connect using <br>//      shared resources such as COM port. In this transport, we do it this <br>//      way for purposes of demonstration of how it should be done. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIStatus::ValidateState (ULONG ulUIParam, ULONG ulFlags) <br>{    <br>    InfoTrace ("CMAPIStatus::ValidateState method called"); <br>    Validate_IMAPIStatus_ValidateState (this, ulUIParam, ulFlags); <br>     <br>    // We only support this flags <br>    if (ulFlags &amp; ~(SHOW_XP_SESSION_UI | <br>                    REFRESH_XP_HEADER_CACHE | <br>                    PROCESS_XP_HEADER_CACHE | <br>                    FORCE_XP_CONNECT | <br>                    FORCE_XP_DISCONNECT | <br>                    ABORT_XP_HEADER_OPERATION)) <br>    { <br>        return MAPI_E_UNKNOWN_FLAGS; <br>    } <br> <br>    if (ulFlags &amp; SHOW_XP_SESSION_UI)   <br>    { <br>        // We don't implement UI for processing the headers <br>        return MAPI_E_NO_SUPPORT; <br>    } <br>    if (ulFlags &amp; ABORT_XP_HEADER_OPERATION) <br>    { <br>        // If we are called to cancel an opertaion, if we can't cancel we will set a <br>        // flag so that when the current operation finishes, we won't continue. <br>        if (HEADERS_AND_DOWNLOAD == m_pLogon-&gt;GetTransportState()) <br>        { <br>            m_pLogon-&gt;m_fCancelPending = TRUE; <br>            return MAPI_E_BUSY; <br>        } <br>        // The cancel occured while we where flushing the inbound queue. We can <br>        // cancel this by telling the spooler to stop flushing us. Note that at <br>        // this point ALL the message have been downloaded to temporary files <br>        // and are simply pending to be placed in the default inbox <br>        if (DOWNLOADING_MESSAGES &amp; m_pLogon-&gt;GetTransportStatusCode()) <br>        { <br>            m_pLogon-&gt;RemoveStatusBits (DOWNLOADING_MESSAGES); // Tell the spooler to take us off from inbound flush <br>            m_pLogon-&gt;AddStatusBits (STATUS_OFFLINE); // The transport is now OFF line <br>            m_pLogon-&gt;UpdateStatus (TRUE, TRUE); // Set PR_REMOTE_VALIDATE_OK to TRUE <br>            m_pLogon-&gt;SetTransportState (WAITING); // The transport is now IDLE <br>        } <br>        return S_OK; <br>    } <br>    HRESULT hResult = S_OK; <br>    // The request is to process remote messages and upload any deferred messages <br>    if (ulFlags &amp; PROCESS_XP_HEADER_CACHE) <br>    { <br>        if (PENDING_RETURN_CODE == m_pLogon-&gt;GetTransportState()) <br>        { <br>            // The transport had finished a request and is ready to return the results error (if any) <br>            m_pLogon-&gt;SetTransportState (WAITING); <br>            m_pLogon-&gt;UpdateStatus (TRUE, FALSE); <br>            m_pLogon-&gt;UpdateProgress (-1, REMOTE_ACTION_IDLE); // Reset PR_REMOTE_PROGRESS_TEXT <br>            return m_pLogon-&gt;m_hRemoteActionErr; <br>        } <br>        if (HEADERS_AND_DOWNLOAD == m_pLogon-&gt;GetTransportState()) <br>        { <br>            // We are busy, poll me later <br>            return MAPI_E_BUSY; <br>        } <br> <br>        // The MS Exchange viewer wants a remote transport to update the headers <br>        // during this call with this flag, so we must update the headers. <br>        // The MS Exchange remote viewer does not call this method with <br>        // REFRESH_XP_HEADER_CACHE alone, any longer. <br>        ulFlags |= REFRESH_XP_HEADER_CACHE; <br>        m_pLogon-&gt;m_fCancelPending = FALSE; <br>    } <br>    // The request is to get remote headers <br>    if (!hResult &amp;&amp; (ulFlags &amp; REFRESH_XP_HEADER_CACHE)) <br>    { <br>        if (PENDING_RETURN_CODE == m_pLogon-&gt;GetTransportState()) <br>        { <br>            m_pLogon-&gt;SetTransportState (WAITING); <br>            m_pLogon-&gt;UpdateStatus (TRUE, FALSE); <br>            m_pLogon-&gt;UpdateProgress (-1, REMOTE_ACTION_IDLE); // Reset PR_REMOTE_PROGRESS_TEXT <br>            return m_pLogon-&gt;m_hRemoteActionErr; <br>        } <br>        if (HEADERS_AND_DOWNLOAD == m_pLogon-&gt;GetTransportState()) <br>        { <br>            return MAPI_E_BUSY; <br>        } <br>        m_pLogon-&gt;m_fCancelPending = FALSE; <br> <br>        // Fire up a request to the spooler to flush the INBOUD logic <br>        // which in turn will also get new headers. <br>        m_pLogon-&gt;SetTransportState (HEADERS_AND_DOWNLOAD); <br>        m_pLogon-&gt;AddStatusBits (DOWNLOADING_MESSAGES); <br>        m_pLogon-&gt;RemoveStatusBits (STATUS_OFFLINE); <br>        m_pLogon-&gt;UpdateStatus (TRUE, FALSE); <br>        return MAPI_E_BUSY; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::SettingsDialog() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Called by a client to display the configuration settings, if any, for <br>//      a particular transport. This method could be used to display the  <br>//      current setting in a READ-ONLY mode <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIStatus::SettingsDialog (ULONG ulUIParam, ULONG ulFlags) <br>{ <br>    InfoTrace ("CMAPIStatus::SettingsDialog method called"); <br>    Validate_IMAPIStatus_SettingsDialog (this, ulUIParam, ulFlags); <br>     <br>    ULONG ulPropCount; <br>    LPSPropValue pProps = NULL; <br>    LPPROFSECT pProfileObj = NULL; <br>    HRESULT hResult = S_OK; <br>    BOOL fChangeAccount = FALSE; <br>    TCHAR szOldMailboxName[MAX_ALIAS_SIZE+1], szOldServer[MAX_STRING_SIZE+1]; <br>    CFGDLG CfgDialog = { 0 }; <br> <br>    PrivInitialize3DCtl (m_pLogon-&gt;GetInstance()); <br>    DWORD dwWait = WaitForSingleObject (m_pLogon-&gt;m_hUIMutex, 1000); // Wait for the MUTEX for 1 second <br>    if (WAIT_TIMEOUT == dwWait) <br>    { <br>        PrivateMessageBox (IDS_MSG_CONFIG_UI_IN_USE, (HWND)ulUIParam); <br>        PrivUninitialize3DCtl (m_pLogon-&gt;GetInstance()); <br>        return MAPI_E_BUSY; <br>    } <br> <br>    // Open the profile for our provider and get what ever is set there <br>    hResult = OpenServiceProfileSection (m_pLogon-&gt;m_pSupObj, &amp;pProfileObj, gpfnFreeBuffer); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIStatus::SettingsDialog: Failed to open the profile section", hResult); <br>        goto ErrorExit; <br>    } <br>     <br>    hResult = pProfileObj-&gt;GetProps ((LPSPropTagArray)&amp;sptLogonProps, </code></pre>
<p>
</p>
<pre><code>fMapiUnicode, <br>                                     &amp;ulPropCount, <br>                                     &amp;pProps); <br>    if (FAILED(hResult)) <br>    { <br>        TraceResult ("CMAPIStatus::SettingsDialog: Failed to get profile section properties", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    lstrcpy (szOldMailboxName, pProps[MAILBOX_NAME].Value.LPSZ); <br>    lstrcpy (szOldServer, pProps[SERVER_NAME].Value.LPSZ); <br> <br>    // Fill in the logon UI structure <br>    CfgDialog.hInst   = m_pLogon-&gt;GetInstance(); <br>    CfgDialog.hWnd    = (HWND)ulUIParam; <br>    CfgDialog.ppProps = &amp;pProps; <br>    CfgDialog.pSupObj = m_pLogon-&gt;m_pSupObj; <br>    CfgDialog.ulFlags = ulFlags; <br> <br>ShowPropsAgain: <br>    hResult = DoLogonDlg (&amp;CfgDialog); <br>    // If the dialog was displayed READ-only, we don't need to verify <br>    // anything because the user didn't change anything and we are <br>    // still runnig with the logon settings of the session. <br>    if (hResult || (ulFlags &amp; UI_READONLY)) <br>    { <br>        goto ErrorExit; <br>    } <br>    if (!PingRemoteServer ((HWND)ulUIParam, pProps)) <br>    { <br>        goto ShowPropsAgain; <br>    } <br> <br>    // We don't need to set the header file name back into the profile. <br>    hResult = pProfileObj-&gt;SetProps (NUM_LOGON_PROPERTIES, pProps, NULL); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIStatus::SetttingsDialog: Failed to save the properties back into the profile", hResult); <br>        goto ErrorExit; <br>    } <br>    if (lstrcmpi (szOldMailboxName, pProps[SERVER_NAME].Value.LPSZ)) <br>    { <br>        m_pLogon-&gt;SetServerName (pProps[SERVER_NAME].Value.LPSZ); <br>        fChangeAccount = TRUE; <br>    } <br>    // If the configuration changed, we need to change the download directory <br>    // which is based on the mailbox name. <br>    if (PR_SMP_MAILBOX_NAME == pProps[MAILBOX_NAME].ulPropTag &amp;&amp; <br>        lstrcmpi (szOldMailboxName, pProps[MAILBOX_NAME].Value.LPSZ)) <br>    { <br>        TCHAR szTmpDir[_MAX_PATH], szDownloadDir[_MAX_PATH]; <br>        GetTempPath (_MAX_PATH, szTmpDir); <br>        lstrcat (szTmpDir, WINDS_DATA_DIRECTORY); <br>        // Remove the download directory for the old mailbox <br>        wsprintf (szDownloadDir, WINDS_DOWNLOAD_DIR_NAME_FORMAT, szTmpDir, szOldMailboxName); <br>        RemoveDirectory (szDownloadDir); <br>        // Create the download directory for the new mailbox <br>        wsprintf (szDownloadDir, WINDS_DOWNLOAD_DIR_NAME_FORMAT, szTmpDir, pProps[MAILBOX_NAME].Value.LPSZ); <br>        CreateDirectory (szDownloadDir, NULL); <br>        fChangeAccount = TRUE; <br>    } <br>    if (fChangeAccount) <br>    { <br>        m_pLogon-&gt;SetAccountProps (pProps[MAILBOX_NAME].Value.LPSZ, <br>                                   (DWORD)pProps[MAILBOX_ID].Value.l, <br>                                   pProps[USER_NAME].Value.LPSZ, <br>                                   pProps[PASSWORD].Value.LPSZ); <br>    } <br> <br>    // Reflect the new changes in the status row. <br>    m_pLogon-&gt;InitializeStatusRow (STATUSROW_UPDATE); <br> <br>    // If the user changed the upload time, reset the upload timer. <br>    if (m_pLogon-&gt;SetUploadTime (pProps[UPLOAD_TIME].Value.ft)) <br>    { <br>        m_pLogon-&gt;StopUploadTimer(); <br>        m_pLogon-&gt;InitializeTimer(); <br>        m_pLogon-&gt;StartUploadTimer(); <br>    } <br>     <br> <br>ErrorExit: <br>    if (pProfileObj) <br>    { <br>        pProfileObj-&gt;Release(); <br>    } <br>    gpfnFreeBuffer (pProps); <br>    PrivUninitialize3DCtl (m_pLogon-&gt;GetInstance()); <br>    ReleaseMutex (m_pLogon-&gt;m_hUIMutex); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::ChangePassword() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Changes the password for the mailbox the service is logged in. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIStatus::ChangePassword (LPTSTR    pszOldPass, <br>                                          LPTSTR    pszNewPass, <br>                                          ULONG     ulFlags) <br>{ <br>    InfoTrace ("CMAPIStatus::ChangePassword method called"); <br>    Validate_IMAPIStatus_ChangePassword (this, pszOldPass, pszNewPass, ulFlags); <br>    HRESULT hResult = ChangeMBServerPassword (m_pLogon-&gt;GetServerName(), <br>                                              m_pLogon-&gt;GetAccountName(), <br>                                              pszOldPass, <br>                                              pszNewPass); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIStatus::ChangePassword", hResult); <br>        if (HRESULT_FROM_WIN32 (ERROR_INVALID_PASSWORD) == hResult) <br>        { <br>            hResult = E_ACCESSDENIED; <br>        } <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIStatus::FlushQueues() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub function that calls the IXPLogon object for this status object <br>//      to actually flush any deferred messages. <br>//      This only flushes messages deferred for delivery. It does not <br>//      downloads any messages from the server. <br>// <br>//    Return Value <br>//      S_OK always <br>// <br>STDMETHODIMP CMAPIStatus::FlushQueues (ULONG        ulUIParam, <br>                                       ULONG        cbTargetTransport, <br>                                       LPENTRYID    pTargetTransport, <br>                                       ULONG        ulFlags) <br>{ <br>    InfoTrace ("CMAPIStatus::FlushQueues method called"); <br>    Validate_IMAPIStatus_FlushQueues (this, <br>                                      ulUIParam, <br>                                      cbTargetTransport, <br>                                      pTargetTransport, <br>                                      ulFlags); <br>    DWORD dwFlushBits = 0; <br>    if (ulFlags &amp; FLUSH_UPLOAD) <br>    { <br>        dwFlushBits |= UPLOADING_MESSAGES; <br>    } <br>    if (ulFlags &amp; FLUSH_DOWNLOAD) <br>    { <br>        dwFlushBits |= DOWNLOADING_MESSAGES; <br>    } <br>    if (dwFlushBits) <br>    { <br>        m_pLogon-&gt;AddStatusBits (dwFlushBits); <br>        m_pLogon-&gt;UpdateStatus(); <br>    } <br>    return S_OK; <br>} <br> <br>// End of File for XPSTATUS.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
