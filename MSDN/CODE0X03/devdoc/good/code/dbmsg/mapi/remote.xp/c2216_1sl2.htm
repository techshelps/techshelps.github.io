<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPPROV.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2216"></a>XPPROV.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      XPPROV.CPP <br>// <br>//  Description <br>//      This file implements the IXPProvider interface with the methods  <br>//      specified in the MAPI SPI 1.0 specifications. Also some helper <br>//      functions are implemented in this file. <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#define INITGUID <br>#define USES_IID_IXPProvider <br>#define USES_IID_IXPLogon <br>#define USES_IID_IMAPIStatus <br>#define USES_IID_IMAPIProp <br>#define USES_IID_IMAPIPropData <br>#define USES_IID_IMAPIControl <br>#define USES_IID_IMAPIContainer <br>#define USES_IID_IMAPIFolder <br>#define USES_IID_IMAPITableData <br> <br>#include "XPWDSR.H" <br> <br>// Remark this line to turn verbose tracing OFF <br>#define DO_INFO_TRACES <br>#ifdef DO_INFO_TRACES <br>#define InfoTrace(a)   TraceInfoMessage(a) <br>#else <br>#define InfoTrace(a)    <br>#endif // DO_INFO_TRACES <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPProvider::CXPProvider() <br>// <br>//    Parameters <br>//      hInst                   Handle to instance of this XP DLL <br>// <br>//    Purpose <br>//      Constructor of the object. Parameters are passed to initialize the <br>//      data members with the appropiate values. <br>// <br>//    Return Value <br>//      None <br>// <br>CXPProvider::CXPProvider (HINSTANCE hInst) <br>{ <br>    InfoTrace ("CXPProvider: Constructor called"); <br>    m_hInstance    = hInst; <br>    m_cRef         = 1; <br>    // Initialize critical sections for this transport <br>    InitializeCriticalSection (&amp;m_csTransport); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPProvider::~CXPProvider() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      Close down and release resources and libraries <br>// <br>//    Return Value <br>//      None <br>// <br>CXPProvider::~CXPProvider() <br>{ <br>    InfoTrace ("CXPProvider: Destructor called"); <br>    m_hInstance = NULL; <br> <br>    // This is the last method called on a transport, close down the traces <br>    UnInitTraces(); <br>    DeleteCriticalSection (&amp;m_csTransport); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPProvider::QueryInterface() <br>// <br>//    Parameters <br>//      { Refer to OLE Documentation on this method } <br>// <br>//    Purpose <br>//      Returns a pointer to a interface requested if the interface is  <br>//      supported and implemented by this object. If it is not supported, it  <br>//      returns NULL <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPProvider::QueryInterface (REFIID riid, LPVOID * ppvObj) <br>{ <br>    // OLE requires NULLing parameter <br>    *ppvObj = NULL; <br>    // If this is one of the two IID return an interface pointer to it <br>    if (riid == IID_IXPProvider || riid == IID_IUnknown) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        // Increase usage count of this object <br>        AddRef(); <br>        return S_OK; <br>    } <br>    // This object does not support the interface requested <br>    return E_NOINTERFACE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IXPProvider virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPProvider::Shutdown() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPProvider::Shutdown (ULONG * pulFlags) <br>{ <br>    InfoTrace ("CXPProvider::Shutdown method called"); <br>    CheckParameters_IXPProvider_Shutdown (this, pulFlags); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPProvider::TransportLogon() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Display the logon dialog to show the options saved in the profile for <br>//      this provider and allow changes to it. Save new configuration settings <br>//      back in the profile. <br>//      Create a new CXPLogon object and return it to the spooler. Also,  <br>//      initialize the properties array for each address type handled <br>//      by this transport. Check all the flags and return them to the spooler <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPProvider::TransportLogon (LPMAPISUP     pSupObj, <br>                                          ULONG         ulUIParam, <br>                                          LPTSTR        pszProfileName, <br>                                          ULONG *       pulFlags, <br>                                          LPMAPIERROR * ppMAPIError, <br>                                          LPXPLOGON *   ppXPLogon) <br>{ <br>    InfoTrace ("CXPProvider::TransportLogon method called"); <br>    CheckParameters_IXPProvider_TransportLogon (this, <br>                                                pSupObj, <br>                                                ulUIParam, <br>                                                pszProfileName, <br>                                                pulFlags, <br>                                                ppMAPIError, <br>                                                ppXPLogon); <br>    CXPLogon * pXPLogon = NULL; <br>    ULONG ulPropCount; <br>    LPSPropValue pProps = NULL; <br>    MAILBOX_INFO UserMBInfo = { 0 }; <br>    CFGDLG CfgDialog = { 0 }; <br>    LPPROFSECT pProfileObj; <br>    HRESULT hResult = OpenServiceProfileSection (pSupObj, &amp;pProfileObj, gpfnFreeBuffer); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPProvider::TransportLogon: Failed to open the service profile section", hResult); <br>        return hResult; <br>    } <br> <br>    HANDLE hUIMutex = CreateMutex (NULL, FALSE, CONFIG_UI_MUTEX); <br>    if (NULL == hUIMutex) <br>    { <br>        HRESULT hResult = HRESULT_FROM_WIN32 (GetLastError()); <br>        TraceResult ("CXPProvider::TransportLogon: Failed to create UI mutext", hResult); <br>    } <br>     <br>    hResult = pProfileObj-&gt;GetProps ((LPSPropTagArray)&amp;sptLogonProps, <br>                                     fMapiUnicode, <br>                                     &amp;ulPropCount, <br>                                     &amp;pProps); <br>    if (FAILED(hResult)) <br>    { <br>        TraceResult ("CXPProvider::TransportLogon: Failed to get the logon props", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    // Fill in the logon UI structure <br>    CfgDialog.hInst    = m_hInstance; <br>    CfgDialog.hWnd     = (HWND)ulUIParam; <br>    CfgDialog.ppProps  = &amp;pProps; <br>    CfgDialog.pSupObj  = pSupObj; <br>    CfgDialog.hUIMutex = hUIMutex; <br> <br>    // In case we get MAPI_W_ERRORS_RETURNED, ignore it and reset  <br>    // to S_OK. Now display the logon configuration dialog <br>    if (MAPI_W_ERRORS_RETURNED == hResult) <br>    { <br>        if (PR_SMP_MAILBOX_ID       != pProps[MAILBOX_ID].ulPropTag  || <br>            PR_SMP_CONNECTION_TYPE  != pProps[NET_CON].ulPropTag     || <br>            PR_SMP_UPLOAD_TIME      != pProps[UPLOAD_TIME].ulPropTag || <br>            PR_SMP_HEADERS_FILENAME != pProps[HEADER_FILE].ulPropTag || <br>            PR_SMP_GET_HEADERS      != pProps[GET_HEADERS].ulPropTag) <br>        { <br>            TraceMessage ("CXPProvider::TransportLogon: Where are the provider properties?"); <br>            hResult = MAPI_E_UNCONFIGURED; <br>            if (!(LOGON_NO_DIALOG &amp; *pulFlags)) <br>            { <br>                PrivInitialize3DCtl (m_hInstance); <br>                PrivateMessageBox (IDS_MSG_SERVICE_NOT_PROPERLY_CFG, (HWND)ulUIParam); <br>                PrivUninitialize3DCtl (m_hInstance); <br>            } <br>            goto ErrorExit; <br>        } <br> <br>        if (PR_SMP_REMOTE_SERVER != pProps[SERVER_NAME].ulPropTag || <br>            PR_SMP_MAILBOX_NAME != pProps[MAILBOX_NAME].ulPropTag || <br>            PR_SMP_USER_NAME != pProps[USER_NAME].ulPropTag || <br>            PR_SMP_MAILBOX_PASSWORD != pProps[PASSWORD].ulPropTag) <br>        { <br>            if (LOGON_NO_DIALOG &amp; *pulFlags) <br>            { <br>                TraceMessage ("CXPProvider::TransportLogon: UI not allowed but it is needed"); <br>                hResult = MAPI_E_UNCONFIGURED; <br>                goto ErrorExit; <br>            } <br>            PrivInitialize3DCtl (m_hInstance); <br>ReStartLogonDlg : <br>            if ((hResult = DoLogonDlg (&amp;CfgDialog))) <br>            { <br>                goto ErrorExit; <br>            } <br>            hResult = pProfileObj-&gt;SetProps (4, pProps, NULL); <br>            if (hResult) <br>            { <br>                TraceResult ("CXPProvider::TransportLogon: Failed to set the properties", hResult); <br>                goto ErrorExit; <br>            } <br>        } <br>    } <br>    // Connect to the server with the stored information. If necessary (and allowed) display UI. <br>    hResult = DoServerLogon (&amp;UserMBInfo, <br>                             pProps, <br>                             pProfileObj, <br>                             !(LOGON_NO_DIALOG &amp; *pulFlags), <br>                             (HWND)ulUIParam, <br>                             FALSE, <br>                             0, <br>                             NULL, <br>                             TRUE); <br>    if (S_FALSE == hResult) <br>    { <br>        goto ReStartLogonDlg; <br>    } <br>    if (hResult) <br>    { <br>        goto ErrorExit; <br>    } <br> <br>    // Once we have validated the remote credentials, terminate all connections <br>    TerminateRemoteConnections(); <br> <br>    try <br>    { <br>        // Allocate the IXPLogon-derived object. Initialize its data members with the necessary values <br>        pXPLogon = new CXPLogon (m_hInstance, <br>                                 pSupObj, <br>                                 pProps[HEADER_FILE].Value.LPSZ, <br>                                 pProps[GET_HEADERS].Value.b, <br>                                 &amp;UserMBInfo, <br>                                 pProps[MAILBOX_ID].Value.l, <br>                                 pProps[SERVER_NAME].Value.LPSZ, <br>                                 hUIMutex); <br>        if (!pXPLogon) <br>        { <br>            // New failed, propably due to memory shortage <br>            TraceMessage ("CXPProvider::TransportLogon: Failed to allocate new CXPLogon object"); <br>            hResult = E_OUTOFMEMORY; <br>        } <br>    } <br>    catch (CException &amp; Exception) <br>    { <br>        hResult = Exception.GetError(); <br>    } <br>    if (hResult) <br>    { <br>        goto ErrorExit; <br>    } <br>    hUIMutex = NULL; <br> <br>    pXPLogon-&gt;CheckForUnfinishedDownloads(); <br> <br>    // Lock other threads because we are going to work on data that is  <br>    // global to all threads (sessions) using this transport <br>    EnterCriticalSection (&amp;m_csTransport); <br>    // Check the mode in which MAPI is logging into our transport and set <br>    // the appropiate internal (this CXPLogon object) transport session flags <br>    pXPLogon-&gt;InitializeTransportStatusFlags (*pulFlags); <br>    // Initialize the transport ID prop array for this session <br>    hResult = pXPLogon-&gt;SetIdentityProps(); <br>    if (!hResult) <br>    { <br>        // Build the transport status row for this session <br>        hResult = pXPLogon-&gt;InitializeStatusRow(); <br>        if (!hResult) <br>        { <br>            // Set the session flags returned to MAPI by the transport <br>            pXPLogon-&gt;SetSessionFlags (pulFlags); <br>            // Set the upload delivery time to the current day, mo, yr and the hour and <br>            // minute from the config dialog saved in the profile. The profile info <br>            // is only valid for the hour and minute of day, the date can be old <br>            pXPLogon-&gt;SetUploadTime (pProps[UPLOAD_TIME].Value.ft); <br>            // Copy our allocated object back to the returned MAPI object pointer <br>            *ppXPLogon = (LPXPLOGON)pXPLogon; <br>        } <br>    } <br>    // Release the critical section <br>    LeaveCriticalSection (&amp;m_csTransport); <br> <br> <br>ErrorExit: <br>    // Release pProfileObj. This object was AddRef() by MAPI before it  <br>    // came to us. The transport is in charge of cleaning it up (Release()ing it). <br>    if (pProfileObj) <br>    { <br>        pProfileObj-&gt;Release(); <br>    } <br>    PrivUninitialize3DCtl (m_hInstance); <br> <br>    if (hUIMutex) <br>    { <br>        CloseHandle (hUIMutex); <br>    } <br>    gpfnFreeBuffer (pProps); <br>    if (hResult) <br>    {    <br>        // Something failed, so clean the session if it has been allocated. <br>        // The Release() method of CXPLogon does the memory deallocation  <br>        // of this object. The destructor of CXPLogon does the rest of  <br>        // the clean up <br>        if (pXPLogon) <br>        { <br>            pXPLogon-&gt;Release(); <br>        } <br>    } <br>    return hResult; <br>}                                         <br> <br>// End of File for XPPROV.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
