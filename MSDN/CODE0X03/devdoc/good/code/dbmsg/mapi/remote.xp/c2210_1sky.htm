<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPFOLDER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2212"></a>XPFOLDER.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      XPFOLDER.CPP <br>// <br>//  Description <br>//      This file implements the IMAPIFolder interface with the methods  <br>//      specified in the MAPI SPI 1.0. <br>// <br>//  Authors <br>//      Irving De la Cruz <br>//      Les Thaler <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "XPWDSR.H" <br> <br>// Remark this line to turn verbose tracing OFF <br>#define DO_INFO_TRACES <br>#ifdef DO_INFO_TRACES <br>#define InfoTrace(a)   TraceInfoMessage(a) <br>#else <br>#define InfoTrace(a)    <br>#endif // DO_INFO_TRACES <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::CMAPIFolder() <br>// <br>//    Parameters <br>//      pStatusObj      Pointer to parent status object <br>//      pLogonObj       Pointer to logon session <br>// <br>//    Purpose <br>//      Constructor of the object. Parameters are passed to initialize the <br>//      data members with the appropiate values. <br>// <br>//    Return Value <br>//      None <br>// <br>CMAPIFolder::CMAPIFolder (CMAPIStatus * pStatusObj, <br>                          CXPLogon *    pLogonObj) <br>{ <br>    InfoTrace ("CMAPIFolder: Constructor called"); <br>    m_cRef = 1; <br>    m_pTableData = NULL; <br>    m_pLogon = pLogonObj; <br>    m_pLogon-&gt;AddRef(); <br>    m_pStatusObj = pStatusObj; <br>//    m_pStatusObj-&gt;AddRef(); the status object holds a reference to us, so <br>//  addref will result in circular reference. <br>    m_fNoHeadersFile = FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::~CMAPIFolder() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      Destructor of CMAPIFolder. Releases memory allocated for internal  <br>//      properties during the life of this transport logon object. <br>// <br>//    Return Value <br>//      None <br>// <br>CMAPIFolder::~CMAPIFolder () <br>{ <br>    InfoTrace ("CMAPIFolder: Destructor called"); <br>    if (m_pTableData) <br>    { <br>        m_pTableData-&gt;Release(); <br>        m_pTableData = NULL; <br>    } <br>//    m_pStatusObj-&gt;Release(); we didn't addref it in the constructor. <br>    m_pStatusObj = NULL; <br>    m_pLogon-&gt;Release(); <br>    m_pLogon = NULL; <br>    m_fNoHeadersFile = FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::QueryInterface() <br>// <br>//    Parameters <br>//      { Refer to OLE Documentation on this method } <br>// <br>//    Purpose <br>//      Returns a pointer to a interface requested if the interface is  <br>//      supported and implemented by this object. If it is not supported, it <br>//      returns NULL <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIFolder::QueryInterface (REFIID riid, LPVOID * ppvObj) <br>{ <br>    // OLE requires NULLing parameter <br>    *ppvObj = NULL; <br>    // If this is one of the two IID return an interface pointer to it <br>    if (riid == IID_IMAPIFolder || riid == IID_IMAPIContainer || riid == IID_IMAPIProp) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        // Increase usage count of this object <br>        AddRef(); <br>        return S_OK; <br>    } <br>    // OLE's COM rules for IUnknown establish that if an interface B <br>    // was obtained using QueryInterface() on interface A, querying B for <br>    // its IUnknown IID, should return a pointer to the A interface. <br>    // Since this IMAPIFolder interface was obtained from IMAPIStatus::QueryInterface, <br>    // when requested for IUnknown, return the contained pointer to the parent status <br>    // object <br>    if (riid == IID_IUnknown) <br>    { <br>        *ppvObj = (LPVOID)m_pStatusObj; <br>        // Increase usage count of this object <br>        m_pStatusObj-&gt;AddRef(); <br>        return S_OK; <br>    } <br>    // This object does not support the interface requested <br>    return E_NOINTERFACE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::Release() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      Decrements the usage count of the Folder object. <br>// <br>//    Return Value <br>//      Usage count of this object. <br>// <br>STDMETHODIMP_(ULONG) CMAPIFolder::Release() <br>{ <br>    ULONG ulCount = --m_cRef; <br>    if (!ulCount) <br>    { <br>        delete this; <br>    } <br>    // If the count is 1, is only the internal reference kept in the parent <br>    // status object. This is the time to flush the contents table to <br>    // the headers file. <br>    if (1 == ulCount) <br>    { <br>        CopyTableToFile(); <br>    } <br>    return ulCount; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IMAPIProp virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetLastError() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      This function finds a string for the hError passed. The hError is the <br>//      last error that occurred in one of our methods. Here we call a <br>//      function to allocate a MAPIERROR structure and passed the information <br>//      to the caller. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIFolder::GetLastError (HRESULT        hError, <br>                                        ULONG          ulFlags, <br>                                        LPMAPIERROR *  ppMAPIError) <br>{ <br>    InfoTrace ("CMAPIFolder::GetLastError method called"); <br>    Validate_IMAPIProp_GetLastError (this, hError, ulFlags, ppMAPIError); <br> <br>    // Allocate and fill a MAPIERROR structure with the error passed in. <br>    // Use the common helper function GetMAPIError <br>    return GetMAPIError (ppMAPIError, ulFlags, hError, m_pLogon-&gt;GetInstance()); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::SaveChanges() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      We don't implement this. Besides, folder objects are not transacted. <br>// <br>//    Return Value <br>//      S_OK always. <br>// <br>STDMETHODIMP CMAPIFolder::SaveChanges (ULONG ulFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::SaveChanges method called"); <br>    Validate_IMAPIProp_SaveChanges (this, ulFlags); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetProps() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Gets the properties of the remote message folder container. A client <br>//      requests the properties it needs by passing an array of property tags <br>//      in pTags. If the array pointer is NULL, we return ALL the properties <br>//      we have. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIFolder::GetProps (LPSPropTagArray pTags, <br>                                    ULONG           ulFlags, <br>                                    ULONG *         pcValues, <br>                                    LPSPropValue *  ppPropArray) <br>{ <br>    InfoTrace ("CMAPIFolder::GetProps method called"); <br>    Validate_IMAPIProp_GetProps (this, pTags, ulFlags, pcValues, ppPropArray); <br> <br>    #ifdef DO_INFO_TRACES <br>    if (!pTags) <br>    { <br>        TraceInfoMessage ("CMAPIFolder::GetProps: All properties requested"); <br>    } <br>    else <br>    { <br>        TraceMessage ("CMAPIFolder::GetProps Properties requested..."); for (ULONG j=0; j&lt;pTags-&gt;cValues; j++) { TraceProp (pTags-&gt;aulPropTag[j]); } <br>    } <br>    #endif // DO_INFO_TRACES <br> <br>    BOOL fGetAllProps = pTags ? FALSE : TRUE; <br>    if (!pTags) <br>    { <br>        pTags = (LPSPropTagArray)&amp;sptFolderProps; <br>    } <br>    *pcValues = pTags-&gt;cValues; <br>    HRESULT hResult = gpfnAllocateBuffer (sizeof(SPropValue)*(*pcValues), (LPVOID *)ppPropArray); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIFolder::GetProps: Memory allocation failed", hResult); <br>        return hResult; <br>    } <br>    if (fGetAllProps) <br>    { <br>        for (ULONG i=0; i&lt;sptFolderProps.cValues; i++) <br>        { <br>            (*ppPropArray)[i].ulPropTag = sptFolderProps.aulPropTag[i]; <br>        } <br>    } <br>    else <br>    { <br>        // A client of the IMAPIProp::GetProps() method can pass PT_UNSPECIFIED in the <br>        // tag of a property. Is the provider's responsiblity to return <br>        // the proper type of the property. <br>        for (ULONG k=0; k&lt;pTags-&gt;cValues; k++) <br>        { <br>            for (ULONG i=0; i&lt;sptFolderProps.cValues; i++) <br>            { <br>                if (PROP_ID(pTags-&gt;aulPropTag[k]) == PROP_ID(sptFolderProps.aulPropTag[i])) <br>                { <br>                    (*ppPropArray)[k].ulPropTag = sptFolderProps.aulPropTag[i]; <br>                } <br>                else <br>                { <br>                    (*ppPropArray)[k].ulPropTag = pTags-&gt;aulPropTag[k]; <br>                } <br>            } <br>        } <br>    } <br>    TCHAR szBuffer[64]; <br>    BOOL fGotErrors = FALSE;     <br>    LPVOID pSrc, pDst; <br>    ULONG cbSize; <br>    for (ULONG i=0; i&lt;*pcValues; i++) <br>    { <br>        hResult = S_OK; <br>        switch ((*ppPropArray)[i].ulPropTag) <br>        { <br>            case PR_NULL : <br>                (*ppPropArray)[i].Value.err = S_OK; <br>                break; <br>            case PR_CREATION_TIME : <br>                if (m_fNoHeadersFile) <br>                { <br>                    hResult = MAPI_E_NOT_FOUND; <br>                } <br>                else <br>                { <br>                    (*ppPropArray)[i].Value.ft = m_ftLastUpdate; <br>                } <br>                break; <br>            case PR_CONTENT_COUNT : <br>                hResult = MAPI_E_NOT_FOUND; <br>                if (m_pTableData) <br>                { <br>                    LPMAPITABLE pTable; <br>                    if (!m_pTableData-&gt;HrGetView (NULL, NULL, 0, &amp;pTable)) <br>                    { <br>                        if (!pTable-&gt;GetRowCount (0, &amp;(*ppPropArray)[i].Value.ul)) <br>                        { <br>                            hResult = S_OK; <br>                        } <br>                        pTable-&gt;Release(); <br>                    } <br>                } <br>                break; <br>            case PR_ASSOC_CONTENT_COUNT : <br>                (*ppPropArray)[i].Value.l = 0; <br>                break; <br>            case PR_ACCESS : <br>                (*ppPropArray)[i].Value.l = MAPI_ACCESS_READ; <br>                break; <br>            case PR_ACCESS_LEVEL : <br>                (*ppPropArray)[i].Value.l = 0; <br>                break; <br>            case PR_FOLDER_TYPE : <br>                (*ppPropArray)[i].Value.l = FOLDER_GENERIC; <br>                break; <br>            case PR_OBJECT_TYPE : <br>                (*ppPropArray)[i].Value.l = MAPI_FOLDER; <br>                break; <br>            case PR_DISPLAY_TYPE : <br>                (*ppPropArray)[i].Value.l = DT_FOLDER; <br>                break; <br>            case PR_SUBFOLDERS : <br>                (*ppPropArray)[i].Value.b = FALSE; <br>                break; <br>            case PR_CREATION_VERSION : <br>                (*ppPropArray)[i].Value.li.LowPart = TRANSPORT_VERSION_MAJOR; <br>                (*ppPropArray)[i].Value.li.HighPart = TRANSPORT_VERSION_MINOR; <br>                break; <br>            case PR_CURRENT_VERSION : <br>                (*ppPropArray)[i].Value.li.LowPart = TRANSPORT_VERSION_MAJOR; <br>                (*ppPropArray)[i].Value.li.HighPart = TRANSPORT_VERSION_MINOR; <br>                break; <br>            case PR_DISPLAY_NAME : <br>                szBuffer[0] = 0; <br>                LoadString (m_pLogon-&gt;GetInstance(), IDS_MSG_REMOTE_FOLDER_VIEW_NAME, szBuffer, 64); <br>                pSrc = (LPVOID)szBuffer; <br>                break; <br>            default: <br>                hResult = MAPI_E_NOT_FOUND; <br>                #ifdef DO_INFO_TRACES <br>                TraceRaw ("CMAPIFolder::GetProps: Not Found - "); TraceProp ((*ppPropArray)[i].ulPropTag); <br>                #endif // #DO_INFO_TRACES <br>                break; <br>        } <br>        if (!hResult &amp;&amp;  <br>            (PROP_TYPE((*ppPropArray)[i].ulPropTag) == PT_BINARY || <br>             PROP_TYPE((*ppPropArray)[i].ulPropTag) == PT_TSTRING)) <br>        { <br>            if (PROP_TYPE((*ppPropArray)[i].ulPropTag) == PT_TSTRING) <br>            { <br>                cbSize = Cbtszsize ((LPTSTR)pSrc); <br>            } <br>            hResult = gpfnAllocateMore (cbSize, *ppPropArray, &amp;pDst); <br>            if (!hResult) <br>            { <br>                CopyMemory (pDst, pSrc, cbSize); <br>                if (PROP_TYPE((*ppPropArray)[i].ulPropTag) == PT_BINARY) <br>                { <br>                    (*ppPropArray)[i].Value.bin.cb  = cbSize; <br>                    (*ppPropArray)[i].Value.bin.lpb = (LPBYTE)pDst; <br>                } <br>                else <br>                { <br>                    (*ppPropArray)[i].Value.LPSZ = (LPTSTR)pDst; <br>                } <br>            } <br>        } <br>        if (hResult) <br>        { <br>            (*ppPropArray)[i].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID((*ppPropArray)[i].ulPropTag)); <br>            (*ppPropArray)[i].Value.err = hResult; <br>            fGotErrors = TRUE; <br>        } <br>    } <br>    if (fGotErrors) <br>    { <br>        hResult = MAPI_W_ERRORS_RETURNED; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetPropList() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Returns an array with all the property tags that we support in <br>//      this folder <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIFolder::GetPropList (ULONG ulFlags, LPSPropTagArray * ppTags) <br>{ <br>    InfoTrace ("CMAPIFolder::GetPropList method called"); <br>    Validate_IMAPIProp_GetPropList (this, ulFlags, ppTags); <br> <br>    ULONG cbTagsArraySize = CbNewSPropTagArray(NUM_FOLDER_PROPS); <br>    // Allocate the required amount of memory <br>    HRESULT hResult = gpfnAllocateBuffer (cbTagsArraySize, (LPVOID *)ppTags); <br>    TraceResult ("CMAPIFolder::GetPropList: Memory allocation failed", hResult); <br>    if (!hResult) <br>    { <br>        // Copy the contents of our property tag array into the buffer <br>        CopyMemory (*ppTags, &amp;sptFolderProps, cbTagsArraySize); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::OpenProperty() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::OpenProperty (ULONG       ulPropTag, <br>                                        LPCIID      piid, <br>                                        ULONG       ulInterfaceOptions, <br>                                        ULONG       ulFlags, <br>                                        LPUNKNOWN * ppUnk) <br>{ <br>    InfoTrace ("CMAPIFolder::OpenProperty method called"); <br>    Validate_IMAPIProp_OpenProperty (this, ulPropTag,  piid, ulInterfaceOptions, ulFlags, ppUnk); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::SetProps() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::SetProps (ULONG                   cValues, <br>                                    LPSPropValue            pPropArray, <br>                                    LPSPropProblemArray *   ppProblems) <br>{ <br>    InfoTrace ("CMAPIFolder::SetProps method called"); <br>    Validate_IMAPIProp_SetProps (this, cValues, pPropArray, ppProblems); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::DeleteProps() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::DeleteProps (LPSPropTagArray       pPropTagArray, <br>                                       LPSPropProblemArray * ppProblems) <br>{ <br>    InfoTrace ("CMAPIFolder::DeleteProps method called"); <br>    Validate_IMAPIProp_DeleteProps (this, pPropTagArray, ppProblems); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::CopyTo() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::CopyTo (ULONG                 ciidExclude, <br>                                  LPCIID                rgiidExclude, <br>                                  LPSPropTagArray       pExcludeProps, <br>                                  ULONG                 ulUIParam, <br>                                  LPMAPIPROGRESS        pProgress, <br>                                  LPCIID                pInterface, <br>                                  LPVOID                pDestObj, <br>                                  ULONG                 ulFlags, <br>                                  LPSPropProblemArray * ppProblems) <br>{ <br>    InfoTrace ("CMAPIFolder::CopyTo method called"); <br>    Validate_IMAPIProp_CopyTo (this, <br>                               ciidExclude, <br>                               rgiidExclude, <br>                               pExcludeProps, <br>                               ulUIParam, <br>                               pProgress, <br>                               pInterface, <br>                               pDestObj, <br>                               ulFlags, <br>                               ppProblems); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::CopyProps() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::CopyProps (LPSPropTagArray        pIncludeProps, <br>                                     ULONG                  ulUIParam, <br>                                     LPMAPIPROGRESS         pProgress, <br>                                     LPCIID                 pInterface, <br>                                     LPVOID                 pDestObj, <br>                                     ULONG                  ulFlags, <br>                                     LPSPropProblemArray *  ppProblems) <br>{ <br>    InfoTrace ("CMAPIFolder::CopyProps method called"); <br>    Validate_IMAPIProp_CopyProps (this, <br>                                  pIncludeProps, <br>                                  ulUIParam, <br>                                  pProgress, <br>                                  pInterface, <br>                                  pDestObj, <br>                                  ulFlags, <br>                                  ppProblems); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetNamesFromIDs() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::GetNamesFromIDs (LPSPropTagArray *    ppPropTags, <br>                                           LPGUID               pPropSetGuid, <br>                                           ULONG                ulFlags, <br>                                           ULONG *              pcPropNames, <br>                                           LPMAPINAMEID **      pppPropNames) <br>{ <br>    InfoTrace ("CMAPIFolder::GetNamesFromIDs method called"); <br>    Validate_IMAPIProp_GetNamesFromIDs (this, <br>                                        ppPropTags, <br>                                        pPropSetGuid, <br>                                        ulFlags, <br>                                        pcPropNames, <br>                                        pppPropNames); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetIDsFromNames() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::GetIDsFromNames (ULONG                cPropNames, <br>                                           LPMAPINAMEID *       ppPropNames, <br>                                           ULONG                ulFlags, <br>                                           LPSPropTagArray *    ppPropTags) <br>{ <br>    InfoTrace ("CMAPIFolder::GetIDsFromNames method called"); <br>    Validate_IMAPIProp_GetIDsFromNames (this, <br>                                        cPropNames, <br>                                        ppPropNames, <br>                                        ulFlags, <br>                                        ppPropTags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IMAPIContainer virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetContentsTable() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIFolder::GetContentsTable (ULONG ulFlags, LPMAPITABLE * ppTable) <br>{ <br>    InfoTrace ("CMAPIFolder::GetContentsTable method called"); <br>    Validate_IMAPIContainer_GetContentsTable (this, ulFlags, ppTable); <br> <br>    if (MAPI_ASSOCIATED &amp; ulFlags) <br>    { <br>        TraceMessage ("CMAPIFolder::GetContentsTable: We don't have associated messages"); <br>        return MAPI_E_NO_SUPPORT; <br>    } <br>    HRESULT hResult; <br>    // If we don't have an ITableData interface pointer instantiated, create one. <br>    if (!m_pTableData) <br>    { <br>        hResult = CreateTable (&amp;IID_IMAPITableData, <br>                               gpfnAllocateBuffer, <br>                               gpfnAllocateMore, <br>                               gpfnFreeBuffer, <br>                               NULL, <br>                               TBLTYPE_DYNAMIC, <br>                               PR_ENTRYID, <br>                               (LPSPropTagArray)&amp;sptFldContents, <br>                               &amp;m_pTableData); <br>        if (hResult) <br>        { <br>            TraceResult ("CMAPIFolder::GetContentsTable: Failed to create an ITableData object", hResult); <br>            return hResult; <br>        } <br> <br>        // Populate the data for the table here <br>        hResult = FillContentsTable (m_pLogon-&gt;GetLocalHeadersCache()); <br>        if (hResult) <br>        { <br>            TraceResult ("CMAPIFolder::GetContentsTable: Failed to populate table data", hResult); <br>            return hResult; <br>        } <br>    } <br>    hResult = m_pTableData-&gt;HrGetView (NULL, NULL, 0, ppTable); <br>    // If any, trace out the error code. <br>    TraceResult ("CMAPIFolder::GetContentsTable: Failed to create a view of the table data", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetHierarchyTable() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::GetHierarchyTable (ULONG          ulFlags, <br>                                             LPMAPITABLE *  ppTable) <br>{ <br>    InfoTrace ("CMAPIFolder::GetHierarchyTable method called"); <br>    Validate_IMAPIContainer_GetHierarchyTable (this, ulFlags, ppTable); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::OpenEntry() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::OpenEntry (ULONG          cbEntryID, <br>                                     LPENTRYID      pEntryID, <br>                                     LPCIID         pInterface, <br>                                     ULONG          ulFlags, <br>                                     ULONG *        pulObjType, <br>                                     LPUNKNOWN *    ppUnk) <br>{ <br>    InfoTrace ("CMAPIFolder::OpenEntry method called"); <br>    Validate_IMAPIContainer_OpenEntry (this, <br>                                       cbEntryID, <br>                                       pEntryID, <br>                                       pInterface, <br>                                       ulFlags, <br>                                       pulObjType, <br>                                       ppUnk); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::SetSearchCriteria() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::SetSearchCriteria (LPSRestriction pRestriction, <br>                                             LPENTRYLIST    pContainerList, <br>                                             ULONG          ulSearchFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::SetSearchCriteria method called"); <br>    Validate_IMAPIContainer_SetSearchCriteria (this, pRestriction, pContainerList, ulSearchFlags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetSearchCriteria() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::GetSearchCriteria (ULONG             ulFlags, <br>                                             LPSRestriction *  ppRestriction, <br>                                             LPENTRYLIST *     ppContainerList, <br>                                             ULONG *           pulSearchState) <br>{ <br>    InfoTrace ("CMAPIFolder::GetSearchCriteria method called"); <br>    Validate_IMAPIContainer_GetSearchCriteria (this, ulFlags, ppRestriction, ppContainerList, pulSearchState); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IMAPIFolder virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::CreateMessage() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::CreateMessage (LPCIID         pInterface, <br>                                         ULONG          ulFlags, <br>                                         LPMESSAGE *    ppMessage) <br>{ <br>    InfoTrace ("CMAPIFolder::CreateMessage method called"); <br>    Validate_IMAPIFolder_CreateMessage (this, pInterface, ulFlags, ppMessage); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::CopyMessages() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::CopyMessages (LPENTRYLIST     pMsgList, <br>                                        LPCIID          pInterface, <br>                                        LPVOID          pDestFolder, <br>                                        ULONG           ulUIParam, <br>                                        LPMAPIPROGRESS  pProgress, <br>                                        ULONG           ulFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::CopyMessages method called"); <br>    Validate_IMAPIFolder_CopyMessages (this, <br>                                       pMsgList, <br>                                       pInterface, <br>                                       pDestFolder, <br>                                       ulUIParam, <br>                                       pProgress, <br>                                       ulFlags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::DeleteMessages() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::DeleteMessages (LPENTRYLIST       pMsgList, <br>                                          ULONG             ulUIParam, <br>                                          LPMAPIPROGRESS    pProgress, <br>                                          ULONG             ulFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::DeleteMessages method called"); <br>    Validate_IMAPIFolder_DeleteMessages (this, <br>                                         pMsgList, <br>                                         ulUIParam, <br>                                         pProgress, <br>                                         ulFlags); <br>    return MAPI_E_NO_SUPPORT; </code></pre>
<p>
</p>
<pre><code>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::CreateFolder() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::CreateFolder (ULONG           ulFolderType, <br>                                        LPTSTR          pszFolderName, <br>                                        LPTSTR          pszFolderComment, <br>                                        LPCIID          pInterface, <br>                                        ULONG           ulFlags, <br>                                        LPMAPIFOLDER *  ppFolder) <br>{ <br>    InfoTrace ("CMAPIFolder::CreateFolder method called"); <br>    Validate_IMAPIFolder_CreateFolder (this, <br>                                       ulFolderType, <br>                                       pszFolderName, <br>                                       pszFolderComment, <br>                                       pInterface, <br>                                       ulFlags, <br>                                       ppFolder); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::CopyFolder() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::CopyFolder (ULONG             cbEntryID, <br>                                      LPENTRYID         pEntryID, <br>                                      LPCIID            pInterface, <br>                                      LPVOID            pDestFolder, <br>                                      LPTSTR            pszNewFolderName, <br>                                      ULONG             ulUIParam, <br>                                      LPMAPIPROGRESS    pProgress, <br>                                      ULONG             ulFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::CopyFolder method called"); <br>    Validate_IMAPIFolder_CopyFolder (this, <br>                                     cbEntryID, <br>                                     pEntryID, <br>                                     pInterface, <br>                                     pDestFolder, <br>                                     pszNewFolderName, <br>                                     ulUIParam, <br>                                     pProgress, <br>                                     ulFlags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::DeleteFolder() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::DeleteFolder (ULONG           cbEntryID, <br>                                        LPENTRYID       pEntryID, <br>                                        ULONG           ulUIParam, <br>                                        LPMAPIPROGRESS  pProgress, <br>                                        ULONG           ulFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::DeleteFolder method called"); <br>    Validate_IMAPIFolder_DeleteFolder (this, <br>                                       cbEntryID, <br>                                       pEntryID, <br>                                       ulUIParam, <br>                                       pProgress, <br>                                       ulFlags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::SetReadFlags() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::SetReadFlags (LPENTRYLIST     pMsgList, <br>                                        ULONG           ulUIParam, <br>                                        LPMAPIPROGRESS  pProgress, <br>                                        ULONG           ulFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::SetReadFlags method called"); <br>    Validate_IMAPIFolder_SetReadFlags (this, <br>                                       pMsgList, <br>                                       ulUIParam, <br>                                       pProgress, <br>                                       ulFlags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::GetMessageStatus() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::GetMessageStatus (ULONG       cbEntryID, <br>                                            LPENTRYID   pEntryID, <br>                                            ULONG       ulFlags, <br>                                            ULONG *     pulMessageStatus) <br>{ <br>    InfoTrace ("CMAPIFolder::GetMessageStatus method called"); <br>    Validate_IMAPIFolder_GetMessageStatus (this, <br>                                           cbEntryID, <br>                                           pEntryID, <br>                                           ulFlags, <br>                                           pulMessageStatus); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::SetMessageStatus() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIFolder::SetMessageStatus (ULONG       cbEntryID, <br>                                            LPENTRYID   pEntryID, <br>                                            ULONG       ulNewStatus, <br>                                            ULONG       ulNewStatusMask, <br>                                            ULONG *     pulOldStatus) <br>{ <br>    InfoTrace ("CMAPIFolder::SetMessageStatus method called"); <br>    Validate_IMAPIFolder_SetMessageStatus (this, <br>                                           cbEntryID, <br>                                           pEntryID, <br>                                           ulNewStatus, <br>                                           ulNewStatusMask, <br>                                           pulOldStatus); <br> <br>    ASSERT (TRANSPORT_MESSAGE_EID_SIZE == cbEntryID); <br>    SPropValue spvSearchProp; <br>    spvSearchProp.ulPropTag     = PR_ENTRYID; <br>    spvSearchProp.Value.bin.cb  = cbEntryID; <br>    spvSearchProp.Value.bin.lpb = (LPBYTE)pEntryID; <br> <br>    LPSRow psrTargetRow; <br>    HRESULT hResult = m_pTableData-&gt;HrQueryRow (&amp;spvSearchProp, &amp;psrTargetRow, NULL); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIFolder::SetMessageStatus: Failed to query row from internal table", hResult); <br>        return hResult; <br>    } <br> <br>    BOOL bFound = FALSE; <br>    ULONG ulOldStatus; <br>    for (ULONG i=0; i&lt;psrTargetRow-&gt;cValues; i++) <br>    { <br>        if (PR_MSG_STATUS == psrTargetRow-&gt;lpProps[i].ulPropTag) <br>        { <br>            bFound = TRUE; <br>            ulOldStatus = psrTargetRow-&gt;lpProps[i].Value.l; <br>            if (pulOldStatus) <br>            { <br>                *pulOldStatus = ulOldStatus; <br>            } <br>            ulOldStatus &amp;= ulNewStatusMask; <br>            ulNewStatus &amp;= ulNewStatusMask; <br>            if (ulNewStatus != ulOldStatus) <br>            { <br>                psrTargetRow-&gt;lpProps[i].Value.l &amp;= ~ulNewStatusMask; <br>                psrTargetRow-&gt;lpProps[i].Value.l |= ulNewStatus; <br>                hResult= m_pTableData-&gt;HrModifyRow (psrTargetRow); <br>                // If any, trace out the error code. <br>                TraceResult ("CMAPIFolder::SetMessageStatus: Failed to modify row in the internal table", hResult); <br>            } <br>            break; // Out of the FOR() loop <br>        } <br>    } <br>    if (!hResult &amp;&amp; !bFound) <br>    { <br>        TraceMessage ("CMAPIFolder::SetMessageStatus: Could not find property in table row"); <br>        hResult = MAPI_E_NOT_FOUND; <br>    } <br>    gpfnFreeBuffer (psrTargetRow); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::SaveContentsSort() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::SaveContentsSort (LPSSortOrderSet pSortCriteria, <br>                                            ULONG           ulFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::SaveContentsSort method called"); <br>    Validate_IMAPIFolder_SaveContentsSort (this, pSortCriteria, ulFlags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::EmptyFolder() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. <br>// <br>//    Return Value <br>//      MAPI_E_NO_SUPPORT always. <br>// <br>STDMETHODIMP CMAPIFolder::EmptyFolder (ULONG            ulUIParam, <br>                                       LPMAPIPROGRESS   pProgress, <br>                                       ULONG            ulFlags) <br>{ <br>    InfoTrace ("CMAPIFolder::EmptyFolder method called"); <br>    Validate_IMAPIFolder_EmptyFolder (this, ulUIParam, pProgress, ulFlags); <br>    return MAPI_E_NO_SUPPORT; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Other member functions specific to this class <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::FillContentsTable() <br>// <br>//    Parameters <br>//      pszHeaderFileName       String with a fully qualified path to the <br>//                              headers data file <br>//    Purpose <br>//      This function reads the file with the headers information to <br>///     populate the table of contents of the remote mail bag folder. <br>//      The data is store in a file whose path is given in the <br>//      pszHeaderFileName parameter. <br>// <br>//    Return Value <br>//      S_OK  If the function is successful or an hResult with the <br>//      error that occurr <br>// <br>STDMETHODIMP CMAPIFolder::FillContentsTable (LPTSTR pszHeaderFileName) <br>{ <br>    ASSERT(pszHeaderFileName); <br>    if (NULL == m_pTableData) <br>    { <br>        // Nothing to do <br>        return S_OK; <br>    } <br> <br>    HRESULT hResult = m_pTableData-&gt;HrDeleteRows (TAD_ALL_ROWS, NULL, NULL); <br>    TraceResult ("CMAPIFolder::FillContentsTable: Failed to delete all rows in internal table", hResult); <br> <br>    // Check that the file exists. If it doesn't exist, then there is no headers file. <br>    HANDLE hFile = CreateFile (pszHeaderFileName, <br>                               GENERIC_READ, <br>                               0, <br>                               NULL, <br>                               OPEN_EXISTING, <br>                               FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, <br>                               NULL); <br>    if (INVALID_HANDLE_VALUE == hFile) <br>    { <br>        // Set the internal flag that the user HAS NOT downloaded headers from the server <br>        m_fNoHeadersFile = TRUE; <br>        return S_OK; <br>    } <br>    else <br>    { <br>        // The time the headers file was last updated, is the last time the file was written to <br>        if (GetFileTime (hFile, NULL, NULL, &amp;m_ftLastUpdate)) <br>        { <br>            // Set the internal flag that the user HAS downloaded headers from the server <br>            m_fNoHeadersFile = FALSE; <br>        } <br>        TraceResult ("CMAPIFolder::FillContentsTable: Failed to get info about the headers file", ::GetLastError()); // Call the Win32 API <br>    } <br>    if (!GetFileSize (hFile, NULL)) <br>    { <br>        CloseHandle(hFile); <br>        return S_OK; <br>    } <br> <br>    SRow srTblRow; <br>    // Allocate an array of properties for the colums in the contents <br>    // tables of the folder <br>    hResult = gpfnAllocateBuffer (NUM_HDR_PROPS*sizeof(SPropValue), (LPVOID *)&amp;(srTblRow.lpProps)); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIFolder::FillContentsTable: Failed to allocate memory for properties", hResult); <br>        CloseHandle (hFile); <br>        return hResult; <br>    } <br> <br>    // Initialize the property tags in the row set <br>    srTblRow.cValues = NUM_HDR_PROPS; <br>    for (UINT i=0; i&lt;NUM_HDR_PROPS; i++)     <br>    { <br>        srTblRow.lpProps[i].ulPropTag = sptFldContents.aulPropTag[i]; <br>    } <br>    // The MS Exchange remote viewer wants PR_MESSAGE_DOWNLOAD_TIME in the rows of the contents table. <br>    // However in our transport we compute it. This property gets set when we download the message. <br>    // This property is listed and shown here for information purposes only. <br>    srTblRow.lpProps[HDR_DOWNLOAD_TIME].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_MESSAGE_DOWNLOAD_TIME)); <br>    srTblRow.lpProps[HDR_DOWNLOAD_TIME].Value.err = S_OK; <br>    srTblRow.lpProps[HDR_OBJ_TYPE].Value.l = MAPI_MESSAGE; <br>     <br>    DWORD dwBytesRead, dwInstanceKey = 1; <br>    srTblRow.lpProps[HDR_INST_KEY].Value.bin.cb  = sizeof (DWORD); // This is a fixed size. <br>    srTblRow.lpProps[HDR_INST_KEY].Value.bin.lpb = (LPBYTE)&amp;dwInstanceKey; <br>    ULONG ulHeaderSize, iNextField; <br>    LONG lFieldSize, lValue = 0; <br>    LPTSTR pStr, pszMsgClass; <br>    TCHAR szDisplayTo[256], szSubject[256], szSender[256]; <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    __try <br>    { <br>        do <br>        { <br>            ZeroMemory (szDisplayTo, 256); <br>            ZeroMemory (szSubject, 256); <br>            ZeroMemory (szSender, 256); <br>            if (ReadFile (hFile, &amp;ulHeaderSize, sizeof(ULONG), &amp;dwBytesRead, NULL)) <br>            { <br>                if (ReadFile (hFile, abBuffer, ulHeaderSize, &amp;dwBytesRead, NULL)) <br>                { <br>                    if (dwBytesRead) <br>                    { <br>                        // Put the data into the property value members <br>                        srTblRow.lpProps[HDR_EID].Value.bin.cb  = TRANSPORT_MESSAGE_EID_SIZE; // This is a fixed size. <br>                        srTblRow.lpProps[HDR_EID].Value.bin.lpb = abBuffer;                   // It will only read the first 16 bytes <br>                        iNextField = TRANSPORT_MESSAGE_EID_SIZE;                              // Skip the entry ID <br> <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lFieldSize = atol (pStr); <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        CopyMemory (szSender, &amp;abBuffer[iNextField], lFieldSize); <br>                        iNextField += lstrlen (szSender) + 1;   // +1 to skip the comma <br>                        srTblRow.lpProps[HDR_SNDR].Value.LPSZ = szSender; <br>                        srTblRow.lpProps[HDR_REPR].Value.LPSZ = szSender; <br> <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lFieldSize = atol (pStr); <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        CopyMemory (szDisplayTo, &amp;abBuffer[iNextField], lFieldSize); <br>                        srTblRow.lpProps[HDR_DISP_TO].Value.LPSZ = szDisplayTo; <br>                     <br>                        iNextField += lFieldSize + 1;       // +1 to skip the comma <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lFieldSize = atol (pStr); <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        CopyMemory (szSubject, &amp;abBuffer[iNextField], lFieldSize); <br>                        srTblRow.lpProps[HDR_SUBJ].Value.LPSZ = szSubject; <br>                        srTblRow.lpProps[HDR_NORM_SUBJ].Value.LPSZ = szSubject; <br> <br>                        iNextField += lFieldSize + 1;       // +1 to skip the comma <br>                        pszMsgClass = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        srTblRow.lpProps[HDR_CLASS].Value.LPSZ = pszMsgClass; <br>                     <br>                        iNextField += lstrlen (pszMsgClass) + 1;       // +1 to skip the comma <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lValue = atol (pStr); <br>                        srTblRow.lpProps[HDR_FLAGS].Value.l = lValue; <br> <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lValue = atol (pStr); <br>                        srTblRow.lpProps[HDR_SIZE].Value.l = lValue; <br> <br>                     <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lValue = atol (pStr); <br>                        srTblRow.lpProps[HDR_PRIOR].Value.l = lValue; <br>                     <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lValue = atol (pStr); <br>                        srTblRow.lpProps[HDR_IMPORTANCE].Value.l = lValue; <br> <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lValue = atol (pStr); <br>                        srTblRow.lpProps[HDR_SENS].Value.l = lValue; <br> <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lValue = atol (pStr); <br>                        srTblRow.lpProps[HDR_TIME].Value.ft.dwLowDateTime = lValue; <br>                     <br>                        iNextField += lstrlen (pStr) + 1;   // +1 to skip the comma <br>                        pStr = strtok ((LPTSTR)&amp;abBuffer[iNextField], ","); <br>                        lValue = atol (pStr); <br>                        srTblRow.lpProps[HDR_TIME].Value.ft.dwHighDateTime = lValue; <br> <br>                        srTblRow.lpProps[HDR_STAT].Value.l = 0; <br> <br>                        srTblRow.lpProps[HDR_HASATTACH].Value.l = (BOOL)!!(srTblRow.lpProps[HDR_FLAGS].Value.l &amp; MSGFLAG_HASATTACH); <br>                     <br>                        hResult = m_pTableData-&gt;HrModifyRow (&amp;srTblRow); <br>                        if (hResult) <br>                        { <br>                            TraceResult ("CMAPIFolder::FillContentsTable: Failed to add row to table data", hResult); <br>                        } <br>                        dwInstanceKey++; <br>                    } <br>                } <br>                else <br>                { <br>                    hResult = ::GetLastError(); // Call the Win32 API <br>                    TraceResult ("CMAPIFolder::FillContentsTable: Failed to read header data", hResult); <br>                    hResult = HRESULT_FROM_WIN32 (hResult); <br>                } <br>            } <br>            else <br>            { <br>                hResult = ::GetLastError(); // Call the Win32 API <br>                TraceResult ("CMAPIFolder::FillContentsTable: Failed to read header size", hResult); <br>                hResult = HRESULT_FROM_WIN32 (hResult); <br>            } <br>        } while (dwBytesRead &amp;&amp; !hResult); <br>    } <br>    __except (EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        TraceString1 ("CMAPIFolder::FillContentsTable: An exception occured. Exception code: %d", GetExceptionCode()); <br>        hResult = MAPI_E_CORRUPT_DATA; <br>    } <br> <br>    // Free the array and close the file <br>    gpfnFreeBuffer (srTblRow.lpProps); <br>    CloseHandle (hFile); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CMAPIFolder::CopyTableToFile() <br>// <br>//    Parameters <br>//      None. <br>// <br>//    Purpose <br>//      This function copies the data from the in-memory contents table into <br>//      the headers file. If the user selected any action on the messages in <br>//      the contents table, those changes will be reflected in the headers <br>//      file and restored the next time the remote viewer is brought up. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CMAPIFolder::CopyTableToFile() <br>{ <br>    if (!m_pTableData) <br>    { <br>        return S_OK; <br>    } <br>    HRESULT hResult; <br>    HANDLE hFile = CreateFile (m_pLogon-&gt;GetLocalHeadersCache(), <br>                               GENERIC_WRITE, <br>                               0, <br>                               NULL, <br>                               CREATE_ALWAYS, <br>                               FILE_FLAG_SEQUENTIAL_SCAN, <br>                               NULL); <br>    if (INVALID_HANDLE_VALUE == hFile) <br>    { <br>        hResult = ::GetLastError(); <br>        TraceResult ("CMAPIFolder::CopyTableToFile: Failed to open local headers file", hResult); <br>        return HRESULT_FROM_WIN32(hResult); <br>    } <br>    BOOL fDeleteFile = TRUE; <br>    LPMAPITABLE pTable = NULL; <br>    hResult = m_pTableData-&gt;HrGetView (NULL, NULL, 0, &amp;pTable); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIFolder::CopyTableToFile: Failed to get a view of the table data", hResult); <br>        goto ErrorExit; <br>    } <br>     <br>    hResult = pTable-&gt;SetColumns ((LPSPropTagArray)&amp;sptFldContents, 0); <br>    if (hResult) <br>    { <br>        TraceResult ("CMAPIFolder::CopyTableToFile: Failed to set the columns", hResult); <br>        goto ErrorExit; <br>    } <br>     <br>    LPSPropValue pProps; <br>    BYTE abBuffer[IO_BUFFERSIZE]; <br>    LPSRowSet pRows; <br>    LPVOID pVoid; <br>    DWORD i, cbSize, dwBytesWrittem; <br>    BOOL fSuccess; <br>    while (TRUE) <br>    { <br>        #define QUERY_SIZE  10 <br>        hResult = pTable-&gt;QueryRows (QUERY_SIZE, 0, &amp;pRows); <br>        if (hResult) <br>        { <br>            TraceResult ("CMAPIFolder::CopyTableToFile: Failed to query the rows in the table", hResult); <br>            goto ErrorExit; <br>        } <br>        // Did we finish reading all the rows? <br>        if (!pRows-&gt;cRows) <br>        { <br>            FreeProws (pRows); <br>            break; // Out of the WHILE() loop <br>        } <br>        for (i=0; i&lt;pRows-&gt;cRows; i++) <br>        { <br>            pProps = pRows-&gt;aRow[i].lpProps; <br>            if (pProps[HDR_EID].ulPropTag != PR_ENTRYID || <br>                pProps[HDR_SNDR].ulPropTag != PR_SENDER_NAME || <br>                pProps[HDR_DISP_TO].ulPropTag != PR_DISPLAY_TO || <br>                pProps[HDR_SUBJ].ulPropTag != PR_SUBJECT || <br>                pProps[HDR_CLASS].ulPropTag != PR_MESSAGE_CLASS || <br>                pProps[HDR_FLAGS].ulPropTag != PR_MESSAGE_FLAGS || <br>                pProps[HDR_SIZE].ulPropTag != PR_MESSAGE_SIZE || <br>                pProps[HDR_PRIOR].ulPropTag != PR_PRIORITY || <br>                pProps[HDR_IMPORTANCE].ulPropTag != PR_IMPORTANCE || <br>                pProps[HDR_SENS].ulPropTag != PR_SENSITIVITY || <br>                pProps[HDR_TIME].ulPropTag != PR_MESSAGE_DELIVERY_TIME || <br>                pProps[HDR_STAT].ulPropTag != PR_MSG_STATUS) <br>            { <br>                TraceMessage ("CMAPIFolder::CopyTableToFile: Missing property in a row. Skipping it"); <br>                continue; // The FOR() loop <br>            } <br>             <br>            ZeroMemory (abBuffer, IO_BUFFERSIZE); <br>         <br>            // Put the properties' data into the buffer. <br>            pVoid = (LPVOID)abBuffer; <br>            CopyMemory (pVoid, pProps[HDR_EID].Value.bin.lpb, TRANSPORT_MESSAGE_EID_SIZE); <br>            cbSize = (DWORD)pVoid + TRANSPORT_MESSAGE_EID_SIZE; <br>            pVoid = (LPVOID)cbSize; <br> <br>            wsprintf ((LPTSTR)pVoid, <br>                      TEXT("%d,%s,%d,%s,%d,%s,%s,%d,%d,%d,%d,%d,%d,%d,"), <br>                      lstrlen (pProps[HDR_SNDR].Value.LPSZ), <br>                      pProps[HDR_SNDR].Value.LPSZ, <br>                      lstrlen (pProps[HDR_DISP_TO].Value.LPSZ), <br>                      pProps[HDR_DISP_TO].Value.LPSZ, <br>                      lstrlen (pProps[HDR_SUBJ].Value.LPSZ), <br>                      pProps[HDR_SUBJ].Value.LPSZ, <br>                      pProps[HDR_CLASS].Value.LPSZ, <br>                      pProps[HDR_FLAGS].Value.l, <br>                      pProps[HDR_SIZE].Value.l, <br>                      pProps[HDR_PRIOR].Value.l, <br>                      pProps[HDR_IMPORTANCE].Value.l, <br>                      pProps[HDR_SENS].Value.l, <br>                      pProps[HDR_TIME].Value.ft.dwLowDateTime, <br>                      pProps[HDR_TIME].Value.ft.dwHighDateTime); <br> <br>            cbSize = TRANSPORT_MESSAGE_EID_SIZE + lstrlen ((LPTSTR)pVoid); <br>            fSuccess = WriteFile (hFile, &amp;cbSize, sizeof(DWORD), &amp;dwBytesWrittem, NULL); <br>            if (fSuccess) <br>            { <br>                fSuccess = WriteFile (hFile, abBuffer, cbSize, &amp;dwBytesWrittem, NULL); <br>                if (fSuccess) <br>                { <br>                    fDeleteFile = FALSE; <br>                } <br>            } <br>            if (!fSuccess) <br>            { <br>                hResult = ::GetLastError(); <br>                TraceResult ("CMAPIFolder::CopyTableToFile: Write header data to file", hResult); <br>                hResult = HRESULT_FROM_WIN32(hResult); <br>                break; // Ouf of the FOR() loop <br>            } <br>        } <br>        FreeProws (pRows); <br>        if (hResult) <br>        { <br>            goto ErrorExit; <br>        } <br>    } <br> <br>ErrorExit: <br>    if (pTable) <br>    { <br>        pTable-&gt;Release(); <br>    } <br>    CloseHandle (hFile); <br>    if (hResult &amp;&amp; fDeleteFile) <br>    { <br>        DeleteFile (m_pLogon-&gt;GetLocalHeadersCache()); <br>    } <br>    m_pTableData-&gt;Release(); <br>    m_pTableData = NULL; <br>    return hResult; <br>} <br> <br>// End of file for XPFOLDER.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
