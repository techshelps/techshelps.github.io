<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMWINDS.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2202"></a>COMWINDS.H</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name  <br>//      COMWINDS.H <br>// <br>//  Description <br>//      Common remote call and client-side utility functions for provider <br>//      communicating with the WINDS messaging host. <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#ifndef _COMWINDS_H <br>#define _COMWINDS_H <br> <br>#define STRICT <br>#include &lt;WINDOWS.H&gt; <br>#include &lt;WINDOWSX.H&gt; <br>#include &lt;CTL3D.H&gt; <br>#include &lt;MAPIWIN.H&gt; <br>#include &lt;MAPISPI.H&gt; <br>#include &lt;MAPIUTIL.H&gt; <br>#include &lt;MAPICODE.H&gt; <br>#include &lt;MAPIVAL.H&gt; <br>#include &lt;MAPIWZ.H&gt; <br> <br>// Constants for communicating with the WINDS Server Messaging Host <br>#include "WINDSGBL.H" <br> <br>// Header file for the trace and logging functions. <br>#include "TRACES.H" <br> <br>// This header file is generated by the MIDL compiler <br>#include "WINDS.H" <br> <br>#include "UISRVCS.H" <br> <br>#ifdef UNICODE <br>#define RemoteChangePassword            RemoteChangePasswordW <br>#define RemoteLogonMailBox              RemoteLogonMailBoxW <br>#define RemoteLogonMailBoxAndSetNotif   RemoteLogonMailBoxAndSetNotifW <br>#define RemoteTerminateNotif            RemoteTerminateNotifW <br>#define RemoteValidateNotif             RemoteValidateNotifW <br>#define RemoteOpenMsgUploadPipe         RemoteOpenMsgUploadPipeW <br>#define RemoteSendMsgToAccount          RemoteSendMsgToAccountW <br>#define RemoteOpenMsgDownloadPipe       RemoteOpenMsgDownloadPipeW <br>#define RemoteOpenHeaderDownloadPipe    RemoteOpenHeaderDownloadPipeW <br>#define RemoteCheckNewMail              RemoteCheckNewMailW <br>#define RemoteOpenOneMsgDownloadPipe    RemoteOpenOneMsgDownloadPipeW <br>#define RemoteGetRecipientProps         RemoteGetRecipientPropsW <br>#define RemoteGetDistListProps          RemoteGetDistListPropsW <br>#else <br>#define RemoteChangePassword            RemoteChangePasswordA <br>#define RemoteLogonMailBox              RemoteLogonMailBoxA <br>#define RemoteLogonMailBoxAndSetNotif   RemoteLogonMailBoxAndSetNotifA <br>#define RemoteTerminateNotif            RemoteTerminateNotifA <br>#define RemoteValidateNotif             RemoteValidateNotifA <br>#define RemoteOpenMsgUploadPipe         RemoteOpenMsgUploadPipeA <br>#define RemoteSendMsgToAccount          RemoteSendMsgToAccountA <br>#define RemoteOpenMsgDownloadPipe       RemoteOpenMsgDownloadPipeA <br>#define RemoteOpenHeaderDownloadPipe    RemoteOpenHeaderDownloadPipeA <br>#define RemoteCheckNewMail              RemoteCheckNewMailA <br>#define RemoteOpenOneMsgDownloadPipe    RemoteOpenOneMsgDownloadPipeA <br>#define RemoteGetRecipientProps         RemoteGetRecipientPropsA <br>#define RemoteGetDistListProps          RemoteGetDistListPropsA <br>#endif // UNICODE <br> <br>// Custom properties used by this service provider. These properties are <br>// non-transmittable and only used in the configuration and private <br>// profile section of this provider/service. <br>#define BASE_PROVIDER_ID                    0x6600  // Look at the comments in MAPITAGS.H <br> <br>// Common Custom Properties for all WINDS service providers <br>#define PR_SMP_REMOTE_SERVER            PROP_TAG (PT_TSTRING,    (BASE_PROVIDER_ID + 0x0000)) <br>#define PR_SMP_USER_NAME                PROP_TAG (PT_TSTRING,    (BASE_PROVIDER_ID + 0x0001)) <br>#define PR_SMP_BROWSE_MB                PROP_TAG (PT_OBJECT,     (BASE_PROVIDER_ID + 0x0002)) <br>#define PR_SMP_CHANGE_PASSWORD          PROP_TAG (PT_OBJECT,     (BASE_PROVIDER_ID + 0x0003)) <br>#define PR_SMP_SESSION_UID              PROP_TAG (PT_BINARY,     (BASE_PROVIDER_ID + 0x0004)) <br>#define PR_SMP_CONNECTION_TYPE          PROP_TAG (PT_LONG,       (BASE_PROVIDER_ID + 0x0005)) <br> <br>// Secured properties that users should not see by looking at the registry. <br>// On Windows NT the registry is secured by the system. On Windows 95, this <br>// properties are stored encrypted, along with the system's list of passwords <br>#define PR_SMP_MAILBOX_NAME         PROP_TAG (PT_TSTRING,    (PROP_ID_SECURE_MIN + 0x0001)) <br>#define PR_SMP_MAILBOX_ID           PROP_TAG (PT_LONG,       (PROP_ID_SECURE_MIN + 0x0002)) <br>#define PR_SMP_MAILBOX_PASSWORD     PROP_TAG (PT_TSTRING,    (PROP_ID_SECURE_MIN + 0x0003)) <br>                                                              <br>// Address books                                              <br>#define PR_SMP_LUL_LAST_UPDATE      PROP_TAG (PT_TSTRING,    (BASE_PROVIDER_ID + 0x0020)) <br>#define PR_SMP_LUL_FILENAME         PROP_TAG (PT_TSTRING,    (BASE_PROVIDER_ID + 0x0021)) <br>#define PR_SMP_LUL_DOWNLOAD         PROP_TAG (PT_OBJECT,     (BASE_PROVIDER_ID + 0x0022)) <br>#define PR_SMP_MANAGER_NAME_TBL     PROP_TAG (PT_OBJECT,     (BASE_PROVIDER_ID + 0x0023)) <br>// Custom properties for IMailUser and IDistList objects. This properties are in the named <br>// property range so that PAB address books and other writeable address books may copy them. <br>// Address book service providers should not use the 0x6600-0x67FF property ID range for <br>// custom properties in the recipient objects. Instead user NAMED properties <br>#define PR_WINDS_AB_MANAGER_NAME        PROP_TAG (PT_TSTRING, 0x8000) <br>#define PR_WINDS_AB_MANAGER_ENTRYID     PROP_TAG (PT_BINARY,  0x8001) <br>#define PR_WINDS_AB_DL_OWNER_ACCT       PROP_TAG (PT_TSTRING, 0x8002) <br>#define PR_WINDS_AB_DL_OWNER_NAME       PROP_TAG (PT_TSTRING, 0x8003) <br>// Address entry named property names. They have to be UNICODE strings <br>#define WINDS_AB_MANAGER_NAME       L"WINDS AB - Manager Name" <br>#define WINDS_AB_MANAGER_EID        L"WINDS AB - Manager Entry ID" <br>#define WINDS_AB_DL_OWNER_ACCT      L"WINDS AB - DL Owner Account" <br>#define WINDS_AB_DL_OWNER_NAME      L"WINDS AB - DL Owner Name" <br> <br>// Transports                                                 <br>#define PR_SMP_UPLOAD_TIME          PROP_TAG (PT_SYSTIME,    (BASE_PROVIDER_ID + 0x0040)) <br>#define PR_SMP_HEADERS_FILENAME     PROP_TAG (PT_TSTRING,    (BASE_PROVIDER_ID + 0x0041)) <br>#define PR_TMP_UPLOAD_TIME          PROP_TAG (PT_TSTRING,    (BASE_PROVIDER_ID + 0x0042)) <br>#define PR_SMP_GET_HEADERS          PROP_TAG (PT_BOOLEAN,    (BASE_PROVIDER_ID + 0x0043)) <br> <br>// Values available for PR_SMP_CONNECTION_TYPE <br>typedef enum _CONNECTION_TYPE <br>{ <br>    // Don't change the order of these unless the string resources ID's are modified accordingly <br>    LAN_CONNECT         = 1,     <br>    OFFLINE_CONNECT     = 2, <br>    CONNECTION_BROKEN   = 3, <br>    NOT_AVAIL_NO_ABD    = 4 <br>} CONNECTION_TYPE; <br> <br>// Index properties into the logon property array of ALL providers using the WINDS server <br>enum <br>{ <br>    SERVER_NAME             = 0, <br>    MAILBOX_NAME            = 1, <br>    MAILBOX_ID              = 2, <br>    USER_NAME               = 3,  <br>    PASSWORD                = 4, <br>    NET_CON                 = 5, <br>    // Number of properties the WIZARD setup pages collect for the configuration of the WINDS providers <br>    WIZARD_PROPERTIES       = 5 <br>}; <br> <br>// Number of controls in the configuration page of ALL WINDS Providers <br>#define NUM_CFG_USERINFO_PAGE_CTLS     13 <br> <br>// Structure passed to the configuration dialog. <br>typedef struct _CFGDLG <br>{ <br>    HINSTANCE      hInst;      // Instance of provider's DLL for loading resources for the UI <br>    HWND           hWnd;       // Handle of parent window or NULL is not UI should be used <br>    LPSPropValue * ppProps;    // Property array with the configuration properties <br>    LPMAPISUP      pSupObj;    // IMAPISupport object for creating the UI property sheets <br>    ULONG          ulFlags;    // 0 or UI_READONLY for access control to the configuration values <br>    HANDLE         hUIMutex;   // Handle to the MUTEX to control exclusive access to the configuration UI <br>} CFGDLG, *PCFGDLG; <br> <br>// This code is to protect on reentrancy in the function <br>// that display the configuration UI for the WINDS services <br>#define CONFIG_UI_MUTEX     TEXT("WINDS_SERVICE_CONFIG_UI_MUTEX") <br> <br>// PR_AB_PROVIDER_ID is the GUID that represents this Address Book Provider. <br>// This GUID is available as a property in the hierarchy. The UID is hard coded. <br>// This number is generated only once per provider during the developement <br>// of it using the standard tools (GUIDGEN or UUIDGEN) in VC++ or the Win32 SDK. <br>// With this number you could identify your provider across multiple platforms. <br>// GUIDGEN: 0xe33c67a0, 0xc81f, 0x11ce, 0xb2, 0xe4, 0x0, 0xaa, 0x0, 0x51, 0xe, 0x3b <br>// This is the UID of the entry ID of objects in the WINDS address book provider. <br>#define AB_UID_PROVIDER { 0xe3, 0x3c, 0x67, 0xa0, \ <br>                          0xc8, 0x1f, 0x11, 0xce, \ <br>                          0xb2, 0xe4, 0x0,  0xaa, \ <br>                          0x0,  0x51, 0xe,  0x3b } <br> <br> <br>// This is the UID in the entry ID's the a WINDS transport uses to open entries in <br>// the WINDS address book, through the support object. <br>// This UID is hard coded because we only allow one instance of our provider <br>// to be installed in a single profile at any time. <br>// GUIDGEN: 0x8B43A160, 0xDFAC, 0x11ce, 0xB2, 0xEC, 0x00, 0xAA, 0x00, 0x51, 0x0E, 0x3B <br>#define XP_WINDS_AB_ENTRIES { 0x8b, 0x43, 0xa1, 0x60, \ <br>                              0xdf, 0xac, 0x11, 0xce, \ <br>                              0xb2, 0xec, 0x0,  0xaa, \ <br>                              0x0,  0x51, 0xe,  0x3b } <br> <br> <br>// This is the private entry ID structure for entries that a WINDS transport <br>// would like to open in the WINDS address book <br>typedef struct _PRIVATE_XP_ENTRYID <br>{ <br>    // MAPI-required fields <br>    BYTE        abFlags[4];         // 4 bytes      // MAPI Flags <br>    MAPIUID     uidGlobal;          // 16 bytes     // UID Unique for XP entries <br>    // Provider-defined fields <br>    MAPIUID     uidWINDSEntries;    // 16 bytes     // UID Unique for WINDS entries in the WINDS address book <br>    char        szObjectAlias[34];  // 34 bytes <br>                                    // 70 Bytes Total <br>} PRIVATE_XP_ENTRYID; <br>#define     CB_PRIVATE_XP_EID       70      // Size of the structure above <br> <br> <br>// This is the subdirectory in the TEMP directoy where WINDS service <br>// providers create temporary data files <br>#define WINDS_DATA_DIRECTORY                TEXT("WINDS Messaging Services Data Files") <br>// This is the directory where the temporary files for downloaded messages are stored <br>#define WINDS_DOWNLOAD_DIR_NAME_FORMAT      TEXT("%s\\Pending Downloads - %s") <br>#define XP_MSG_FILE_PREFIX                  TEXT("XRM") <br>#define XP_MSG_FILE_SUFFIX                  TEXT("TMP") <br> <br>// Variables and static data structure used by all WINDS providers  <br>extern "C" <br>{ <br>    extern HINSTANCE    ghInstance; <br>    extern TCHAR        szBlank[]; <br>    extern TCHAR        szFilter[]; <br>    extern TCHAR        szPhoneFilter[]; <br>    extern TCHAR        szTimeFilter[]; <br>    extern DTBLLABEL    DtLabel; <br>    extern DTBLGROUPBOX DtGroupBox; <br>    extern DTBLPAGE     DtPage; <br>    extern DTBLEDIT     DtObjAlias; <br>    extern DTBLEDIT     DtObjFullName; <br>    extern DTBLEDIT     DtUserName; <br>    extern DTBLEDIT     DtServer; <br>    extern DTBLEDIT     DtComment; <br>    extern DTCTL        UserConfigPage[]; <br>}; <br> <br>int WINAPI PrivateMessageBox <br>                    (UINT                       ids,  <br>                     HWND                       hOwnerWnd = NULL, <br>                     UINT                       uFlags = MB_OK | MB_ICONSTOP, <br>                     HINSTANCE                  hInst = NULL); <br>extern "C" <br>{ <br>    HRESULT WINAPI BindToServer <br>                    (LPTSTR                     szServer); <br>    BOOL WINAPI IsWINDSServerAvailable <br>                    (LPTSTR                     szServerName); <br>    BOOL WINAPI PingRemoteServer <br>                    (HWND                       hOwnerWnd, <br>                     LPSPropValue               pProps); <br>    BOOL WINAPI IsValidServerName <br>                    (LPTSTR                     szServerName); <br>    HRESULT WINAPI DoServerLogon <br>                    (PMAILBOX_INFO              pMBInfo, <br>                     LPSPropValue               pProps, <br>                     LPPROFSECT                 pProfileObj, <br>                     BOOL                       fUIAllowed, <br>                     HWND                       hOwnerWnd, <br>                     BOOL                       fSetNotification, <br>                     DWORD                      dwNotifMask, <br>                     DWORD *                    pdwConnectID, <br>                     BOOL                       fOffLineOK); <br>    HRESULT WINAPI ChangeMBServerPassword <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szMailboxName, <br>                     LPTSTR                     szOldPassword, <br>                     LPTSTR                     szNewPassword); <br>    HRESULT WINAPI TerminateServerNotifications <br>                    (LPTSTR                     szServerName, <br>                     DWORD                      dwConnectionID); <br>    HRESULT WINAPI ResetServerNotifications <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szMailboxName, <br>                     DWORD                      dwNotifMask, <br>                     DWORD *                    pdwConnectionID); <br>    void WINAPI TerminateRemoteConnections <br>                    (); <br>    HRESULT WINAPI MergeConfigProps <br>                    (ULONG                      ulCfgProps, <br>                     LPSPropValue               pCfgProps, <br>                     LPSPropValue               pLogonProps); <br>    HRESULT WINAPI OpenServiceProfileSection <br>                    (LPMAPISUP                  pSupObj, <br>                     LPPROFSECT *               ppProfSectObj, <br>                     LPFREEBUFFER               pfnFreeBuffer); <br>    // Transport Providers <br>    HRESULT WINAPI OpenServerUploadPipe <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szSenderMailbox, <br>                     HANDLE                     hMsgFile, <br>                     LPTSTR                     szConnectionInfo, <br>                     BOOL *                     pfErrorInTheServer); <br>    HRESULT WINAPI SendMsgToAccount <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szRecipMailbox, <br>                     LPTSTR                     szHeader, <br>                     LPTSTR                     szConnectionInfo, <br>                     BOOL *                     pfErrorInTheServer); <br>    HRESULT WINAPI FinishUploadConnection <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szConnectionInfo); <br>    HRESULT WINAPI GetHeadersFromServer <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szMailbox, <br>                     LPTSTR                     szHeaderFile); <br>    HRESULT WINAPI OpenRemoteServerDownLoadPipe <br>                    (LPTSTR                     szServer, <br>                     LPTSTR                     szMBox, <br>                     HANDLE *                   phPipe); <br>    HRESULT WINAPI GetNextMailboxMsg <br>                    (LPTSTR                     szServer, <br>                     LPTSTR                     szMailbox, <br>                     LPTSTR                     szLocalMsgFile); <br>    HRESULT WINAPI CheckForPendingMessages <br>                    (LPTSTR                     szServerName, <br>                     LPTSTR                     szMailboxName, <br>                     ULONG *                    pulMsgWaiting); <br>}; <br> <br>// CTL3D Dynamic Loading Support <br>void WINAPI PrivInitialize3DCtl <br>                    (HINSTANCE                  hInstance); <br>void WINAPI PrivUninitialize3DCtl <br>                    (HINSTANCE                  hInstance); <br> <br>// Forward declarations <br>class CUIMAPIProp; <br> <br>// Custom callback function prototype for the implementation <br>// and activation of IMAPIControl on display tables on property sheets. <br>typedef void (STDAPICALLTYPE BUTTONCALLBACK) (CUIMAPIProp * pObj, HWND hOwnerWnd, HINSTANCE hInstance); <br>typedef BUTTONCALLBACK *LPBUTTONCALLBACK; <br> <br>class CUIMAPIProp : public IMAPIProp <br>{ <br>public: <br>    inline STDMETHODIMP QueryInterface <br>                    (REFIID                     riid, <br>                     LPVOID *                   ppvObj) <br>                    { *ppvObj = NULL; <br>                      HRESULT hResult = S_OK; <br>                      EnterCriticalSection (&amp;m_csObj); <br>                      if (riid == IID_IMAPIProp || riid == IID_IUnknown) <br>                      { <br>                          *ppvObj = (LPVOID)this; <br>                          AddRef(); <br>                      } <br>                      else <br>                      { <br>                          hResult = E_NOINTERFACE; <br>                      } <br>                      LeaveCriticalSection (&amp;m_csObj); <br>                      return hResult; } <br>    inline STDMETHODIMP_(ULONG) AddRef <br>                    () { EnterCriticalSection (&amp;m_csObj); <br>                         ++m_cRef; ULONG ulCount = m_cRef; <br>                         LeaveCriticalSection (&amp;m_csObj); <br>                         return ulCount; } <br>    inline STDMETHODIMP_(ULONG) Release <br>                    () { EnterCriticalSection (&amp;m_csObj); <br>                         ULONG ulCount = --m_cRef; <br>                         LeaveCriticalSection (&amp;m_csObj); <br>                         if (!ulCount) { delete this; } <br>                         return ulCount;} <br>    inline STDMETHODIMP GetLastError <br>                    (HRESULT                    hResult, <br>                     ULONG                      ulFlags, <br>                     LPMAPIERROR *              ppMAPIError) <br>                    { return m_pImpObj-&gt;GetLastError (hResult, ulFlags, ppMAPIError); } <br>    inline STDMETHODIMP SaveChanges <br>                    (ULONG                      ulFlags) <br>                    { return S_OK; } <br>    inline STDMETHODIMP GetProps <br>                    (LPSPropTagArray            pPropTagArray, <br>                     ULONG                      ulFlags, <br>                     ULONG *                    pcValues, <br>                     LPSPropValue *             ppPropArray) <br>                    { return m_pImpObj-&gt;GetProps (pPropTagArray, ulFlags, pcValues, ppPropArray); } <br>    inline STDMETHODIMP GetPropList <br>                    (ULONG                      ulFlags, <br>                     LPSPropTagArray *          ppAllTags) <br>                    { return m_pImpObj-&gt;GetPropList (ulFlags, ppAllTags); } <br>    STDMETHODIMP OpenProperty <br>                    (ULONG                      ulPropTag, <br>                     LPCIID                     piid, <br>                     ULONG                      ulInterfaceOptions, <br>                     ULONG                      ulFlags, <br>                     LPUNKNOWN *                ppUnk); <br>    inline STDMETHODIMP SetProps <br>                    (ULONG                      cValues, <br>                     LPSPropValue               pPropArray, <br>                     LPSPropProblemArray *      ppProblems) <br>                    { return m_pImpObj-&gt;SetProps (cValues, pPropArray, ppProblems); } <br>    inline STDMETHODIMP DeleteProps <br>                    (LPSPropTagArray            pPropTagArray, <br>                     LPSPropProblemArray *      ppProblems) <br>                    { return m_pImpObj-&gt;DeleteProps (pPropTagArray, ppProblems); } <br>    inline STDMETHODIMP CopyTo <br>                    (ULONG                      ciidExclude, <br>                     LPCIID                     rgiidExclude, <br>                     LPSPropTagArray            pExcludeProps, <br>                     ULONG                      ulUIParam, <br>                     LPMAPIPROGRESS             pProgress, <br>                     LPCIID                     pInterface, <br>                     LPVOID                     pDestObj, <br>                     ULONG                      ulFlags, <br>                     LPSPropProblemArray *      ppProblems) <br>                    { return m_pImpObj-&gt;CopyTo (ciidExclude, rgiidExclude, pExcludeProps, ulUIParam, pProgress, pInterface, pDestObj, ulFlags, ppProblems); } <br>    inline STDMETHODIMP CopyProps <br>                    (LPSPropTagArray            pIncludeProps, <br>                     ULONG                      ulUIParam, <br>                     LPMAPIPROGRESS             pProgress, <br>                     LPCIID                     pInterface, <br>                     LPVOID                     pDestObj, <br>                     ULONG                      ulFlags, <br>                     LPSPropProblemArray *      ppProblems) <br>                    { return m_pImpObj-&gt;CopyProps (pIncludeProps, ulUIParam, pProgress, pInterface, pDestObj, ulFlags, ppProblems); } <br>    inline STDMETHODIMP GetNamesFromIDs <br>                    (LPSPropTagArray *          ppPropTags, <br>                     LPGUID                     pPropSetGuid, <br>                     ULONG                      ulFlags, <br>                     ULONG *                    pcPropNames, <br>                     LPMAPINAMEID **            pppPropNames) <br>                    { return MAPI_E_NO_SUPPORT; } <br>    inline STDMETHODIMP GetIDsFromNames <br>                    (ULONG                      cPropNames, <br>                     LPMAPINAMEID *             ppPropNames, <br>                     ULONG                      ulFlags, <br>                     LPSPropTagArray *          ppPropTags) <br>                    { return MAPI_E_NO_SUPPORT; } <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Other methods private to this class <br>// <br>    inline void WINAPI SetTableData <br>                    (LPTABLEDATA                pTable) <br>                    { m_pTableData = pTable; m_pTableData-&gt;AddRef(); } <br>    inline void WINAPI SetPropCallBack <br>                    (ULONG                      ulPropTag, <br>                     LPBUTTONCALLBACK           pfnCallBack) <br>                    { m_ulCustomPropTag = ulPropTag; m_pfnCallBack = pfnCallBack; } <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Constructors and destructors <br>// <br>public : <br>    CUIMAPIProp     (HINSTANCE                  hInstance, <br>                     LPALLOCATEBUFFER           pfnAllocateBuffer, <br>                     LPALLOCATEMORE             pfnAllocateMore, <br>                     LPFREEBUFFER               pfnFreeBuffer, <br>                     BOOL                       fReadOnly); <br>    ~CUIMAPIProp    () { m_pImpObj-&gt;Release(); m_pImpObj = NULL; <br>                         if (m_pTableData) { m_pTableData-&gt;Release(); } <br>                         DeleteCriticalSection (&amp;m_csObj);} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Data members <br>// <br>private : <br>    ULONG               m_cRef; <br>    BOOL                m_fReadOnly; <br>    LPPROPDATA          m_pImpObj; <br>    ULONG               m_ulCustomPropTag; <br>    LPBUTTONCALLBACK    m_pfnCallBack; <br>    CRITICAL_SECTION    m_csObj; <br>public : <br>    LPTABLEDATA         m_pTableData; <br>    HINSTANCE           m_hInstance; <br>}; <br> <br>class CMAPIControl : public IMAPIControl <br>{ <br>    inline STDMETHODIMP QueryInterface <br>                    (REFIID                     riid, <br>                     LPVOID *                   ppvObj) <br>                    { *ppvObj = NULL; <br>                      HRESULT hResult = S_OK; <br>                      EnterCriticalSection (&amp;m_csObj); <br>                      if (riid == IID_IMAPIControl || riid == IID_IUnknown) <br>                      { <br>                          *ppvObj = (LPVOID)this; <br>                          // Increase usage count of this object <br>                          AddRef(); <br>                      } <br>                      else <br>                      { <br>                          hResult = E_NOINTERFACE; <br>                      } <br>                      LeaveCriticalSection (&amp;m_csObj); <br>                      return hResult; } <br>    inline STDMETHODIMP_(ULONG) AddRef <br>                    () { EnterCriticalSection (&amp;m_csObj); <br>                         ++m_cRef; ULONG ulCount = m_cRef; <br>                         LeaveCriticalSection (&amp;m_csObj); <br>                         return ulCount; } <br>    inline STDMETHODIMP_(ULONG) Release <br>                    () { EnterCriticalSection (&amp;m_csObj); <br>                         ULONG ulCount = --m_cRef; <br>                         LeaveCriticalSection (&amp;m_csObj); <br>                         if (!ulCount) { delete this; } <br>                         return ulCount;} <br>    inline STDMETHODIMP GetLastError <br>                    (HRESULT                    hResult, <br>                     ULONG                      ulFlags, <br>                     LPMAPIERROR *              ppMAPIError) <br>                    { return MAPI_E_NO_SUPPORT; } <br>    inline STDMETHODIMP GetState <br>                    (ULONG                      ulFlags, <br>                     ULONG *                    pulState) <br>                    { *pulState = (m_fReadOnly ? MAPI_DISABLED : MAPI_ENABLED); return S_OK; } <br>    inline STDMETHODIMP Activate <br>                    (ULONG                      ulFlags, <br>                     ULONG                      ulUIParam) <br>                    { (*m_pfnCallBack)(m_pProp, (HWND)ulUIParam, m_pProp-&gt;m_hInstance); return S_OK; } <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// Constructors and destructors <br>// <br>public : <br>    CMAPIControl    (CUIMAPIProp *              pProp, <br>                     LPBUTTONCALLBACK           pfnCallBack, <br>                     BOOL                       fReadOnly) <br>                    { m_cRef = 1; m_pfnCallBack = pfnCallBack; m_fReadOnly = fReadOnly; <br>                      m_pProp = pProp; m_pProp-&gt;AddRef(); <br>                      InitializeCriticalSection (&amp;m_csObj); } <br>    ~CMAPIControl   () <br>                    { m_pProp-&gt;Release(); <br>                      DeleteCriticalSection (&amp;m_csObj);} <br>/////////////////////////////////////////////////////////////////////////////// <br>// Data members <br>// <br>private : <br>    ULONG               m_cRef; <br>    LPBUTTONCALLBACK    m_pfnCallBack; <br>    BOOL                m_fReadOnly; <br>    CUIMAPIProp *       m_pProp; <br>    CRITICAL_SECTION    m_csObj; <br>}; <br> <br>#endif // _COMWINDS_H <br> <br>// End of file for COMWINDS.H </code></pre>
<p>&nbsp;</p></body>
</HTML>
