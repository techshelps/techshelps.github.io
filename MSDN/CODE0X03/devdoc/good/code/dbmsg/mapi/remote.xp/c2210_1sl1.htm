<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPLOGON.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2215"></a>XPLOGON.CPP</h2>
<pre><code>////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name <br>//      XPLOGON.CPP <br>// <br>//  Description <br>//      This file implements the IXPLogon interface with the methods specified <br>//      in the MAPI SPI 1.0. <br>// <br>//  Authors <br>//      Irving De la Cruz <br>//      Les Thaler <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>// <br>#include "XPWDSR.H" <br> <br>#define DO_INFO_TRACES <br>#ifdef DO_INFO_TRACES <br>#define InfoTrace(a)   TraceInfoMessage(a) <br>#else <br>#define InfoTrace(a) <br>#endif // DO_INFO_TRACES <br> <br>// Remark this line to turn verbose tracing OFF <br>MAPIUID guidABEntries = AB_UID_PROVIDER; <br>MAPIUID guidXPABEntries = XP_WINDS_AB_ENTRIES; <br>MAPIUID * puidWINDSEntries; <br>TCHAR gszProviderName[] = TEXT("WINDS Transport Service"); <br>LPTSTR gszWINDSAddressType = WINDS_ADDRESS_TYPE; <br>LPTSTR * gpszXPAddressTypes; <br> <br>void CALLBACK UploadTimerProc (HWND    hOwnerWnd, <br>                               UINT    Message, <br>                               UINT    idEvent, <br>                               DWORD   dwTime); <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::CXPLogon() <br>// <br>//    Parameters <br>//      hInstance               Instance of the provider DLL <br>//      pSupObj                 Pointer to IMAPISupport object used in <br>//                              CXPLogon methods <br>//      pszHeadersFile          Full file path where the remote headers are <br>//                              store in the local computer. <br>//      fGetHeaders             Weather or not to get the headers of the <br>//                              mailbox during a scheduled connection. <br>//      pUserMailboxInfo        Pointer to a MAILBOX_INFO structure with the <br>//                              information of the logged user as store in <br>//                              the WINDS server. <br>//      dwMailboxID             ID of the user in the WINDS system. <br>//      pszRemoteServer         Name of the remote WINDS server to which <br>//                              this transport communicates <br>//      hUIMutex                Handle to a WINDS mutex to allow single access <br>//                              to the UI configuration of this provider. <br>// <br>//    Purpose <br>//      Constructor of the object. Parameters are passed to initialize the <br>//      data members with the appropiate values. <br>// <br>//    Return Value <br>//      None <br>// <br>CXPLogon::CXPLogon (HINSTANCE       hInstance, <br>                    LPMAPISUP       pSupObj, <br>                    LPTSTR          pszHeadersFile, <br>                    BOOL            fGetHeaders, <br>                    PMAILBOX_INFO   pUserMailboxInfo, <br>                    DWORD           dwMailboxID, <br>                    LPTSTR          pszRemoteServer, <br>                    HANDLE          hUIMutex) <br>{ <br>    InfoTrace ("CXPLogon: Constructor called"); <br>    m_cRef           = 1; <br>    m_pIdentityProps = NULL; <br>    m_hInstance      = hInstance; <br>    m_pSupObj        = pSupObj; <br>    m_pStatusObj     = NULL; <br>    m_pIdentityProps = NULL; <br>    ZeroMemory (&amp;m_stDelivTime, sizeof(SYSTEMTIME)); <br>    m_uTimerID       = 0; <br>    m_hTimerWnd      = NULL; <br>    m_fABWDSInstalled = FALSE; <br>    m_fGetHeaders    = fGetHeaders; <br>    m_hUIMutex       = hUIMutex; <br>    m_raAction       = REMOTE_ACTION_IDLE; <br>    m_UserInfo       = *pUserMailboxInfo; <br>    ZeroMemory (&amp;m_UserEID, CB_PRIVATE_EID); <br>    m_UserEID.uidGlobal = guidABEntries; <br>    m_UserEID.bVersion = ENTRYID_VERSION; <br>    m_UserEID.bObject = MAPI_MAILUSER; <br>    m_UserEID.dwObjID = dwMailboxID; <br> <br>    m_pSupObj-&gt;AddRef(); <br> <br>    lstrcpy (m_szHeaders, pszHeadersFile); <br>    lstrcpy (m_szServer, pszRemoteServer); <br> <br>    wsprintf (m_szAddress, TEXT("%s\\%s"), m_szServer, m_UserInfo.szMailboxName); <br> <br>    // Initialize the messages download list object <br>    m_List.SetLogon(this); <br>    if (!m_List.Init()) <br>    { <br>        throw CException (E_OUTOFMEMORY); <br>    } <br>    SetTransportState (WAITING); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::~CXPLogon() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      Destructor of CXPLogon. Releases memory allocated for internal <br>//      properties during the life of this transport logon object. <br>// <br>//    Return Value <br>//      None <br>// <br>CXPLogon::~CXPLogon() <br>{ <br>    InfoTrace ("CXPLogon: Destructor called"); <br>    gpfnFreeBuffer (m_pIdentityProps); <br>    CloseHandle (m_hUIMutex); <br> <br>    EmptyInboundQueue(); <br> <br>    // Delete CMAPIStatus Object <br>/*    if (m_pStatusObj) <br>    { <br>        m_pStatusObj-&gt;Release(); <br>        m_pStatusObj = NULL; <br>    } <br>*/ <br>    // Release the IMAPISupport object <br>    m_pSupObj-&gt;Release(); <br>    m_pSupObj = NULL; <br> <br>    // Just as a safety precaution, make sure the timer is off. <br>    StopUploadTimer(); <br> <br>    // Just in case the DLL is still hanging around <br>    PrivUninitialize3DCtl (m_hInstance); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::QueryInterface() <br>// <br>//    Parameters <br>//      { Refer to OLE Documentation on this method } <br>// <br>//    Purpose <br>//      Returns a pointer to a interface requested if the interface is <br>//      supported and implemented by this object. If it is not supported, it <br>//      returns NULL <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::QueryInterface (REFIID riid, LPVOID * ppvObj) <br>{ <br>    // OLE requires NULLing parameter <br>    *ppvObj = NULL; <br>    // If this is one of the two IID return an interface pointer to it <br>    if (riid == IID_IXPLogon || riid == IID_IUnknown) <br>    { <br>        *ppvObj = (LPVOID)this; <br>        // Increase usage count of this object <br>        AddRef(); <br>        return S_OK; <br>    } <br>    // This object does not support the interface requested <br>    return E_NOINTERFACE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// IXPLogon virtual member functions implementation <br>// <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::AddressType() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Called by the MAPI Spooler when initializing this XP logon object to <br>//      allow the transport to register the address it will handle <br>// <br>//    Return Value <br>//      S_OK always <br>// <br>STDMETHODIMP CXPLogon::AddressTypes (ULONG *        pulFlags, <br>                                     ULONG *        pcAdrType, <br>                                     LPTSTR **      pppAdrTypeArray, <br>                                     ULONG *        pcMAPIUID, <br>                                     LPMAPIUID **   pppMAPIUIDArray) <br>{ <br>    InfoTrace ("CXPLogon::AddressTypes method called"); <br>    CheckParameters_IXPLogon_AddressTypes (this, <br>                                           pulFlags, <br>                                           pcAdrType, <br>                                           pppAdrTypeArray, <br>                                           pcMAPIUID, <br>                                           pppMAPIUIDArray); <br> <br>    // This is how many address type strings we are returning in pppAdrTypeArray <br>    *pcAdrType = 1; <br> <br>    // Copy address types back to the MAPI pointer <br>    gpszXPAddressTypes = &amp;gszWINDSAddressType; <br>    *pppAdrTypeArray = gpszXPAddressTypes; <br>    *pulFlags = fMapiUnicode; <br> <br>    // The UID for routing message has to be set here. If it is not used, set it NULL. <br>    // In the case of WINDS transport registers support for the UID of <br>    // the WINDS address book's entry ID <br>    puidWINDSEntries = &amp;guidABEntries; <br>    *pcMAPIUID = 1; <br>    *pppMAPIUIDArray = &amp;puidWINDSEntries; <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::RegisterOptions() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      This transport does not registers any per-recipient or per-message <br>//      option processing, so we return 0 options. And NULL in the OPTIONDATA <br>//      structure pointer. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::RegisterOptions (ULONG *         pulFlags, <br>                                        ULONG *         pcOptions, <br>                                        LPOPTIONDATA *  ppOptions) <br>{ <br>    InfoTrace ("CXPLogon::RegisterOptions method called"); <br>    CheckParameters_IXPLogon_RegisterOptions (this, <br>                                              pulFlags, <br>                                              pcOptions, <br>                                              ppOptions); <br>    *pulFlags = 0; <br>    *pcOptions = 0; <br>    *ppOptions = NULL; <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::TransportNotify() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Update the status row registered by this transport with MAPI <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::TransportNotify (ULONG * pulFlags, LPVOID * ppvData) <br>{ <br>    InfoTrace ("CXPLogon::TransportNotify method called"); <br>    CheckParameters_IXPLogon_TransportNotify (this, <br>                                              pulFlags, <br>                                              ppvData); <br> <br>    ULONG ulOldStatus = GetTransportStatusCode(); <br>    // Set appropriate status flags and re-register status row <br>    if (*pulFlags &amp; NOTIFY_BEGIN_INBOUND) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Begin INBOUND logic"); <br>        AddStatusBits (STATUS_INBOUND_ENABLED); <br>    } <br>    if (*pulFlags &amp; NOTIFY_END_INBOUND) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Terminate INBOUND logic"); <br>        RemoveStatusBits (STATUS_INBOUND_ENABLED); <br>    } <br>    if (*pulFlags &amp; NOTIFY_BEGIN_OUTBOUND) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Begin OUTBOUND logic"); <br>        AddStatusBits (STATUS_OUTBOUND_ENABLED); <br>        InitializeTimer(); <br>        StartUploadTimer(); <br>    } <br>    if (*pulFlags &amp; NOTIFY_END_OUTBOUND) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Terminate OUTBOUND logic"); <br>        RemoveStatusBits (STATUS_OUTBOUND_ENABLED); <br>        StopUploadTimer(); <br>    } <br>    if (*pulFlags &amp; NOTIFY_BEGIN_OUTBOUND_FLUSH) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Begin OUTBOUND flush"); <br>        // If the spooler need to flush us for some reason, we put ourselves <br>        // in FLUSH and tell the spooler to give us any deferred messages <br>        // it has queued up for us. <br>        AddStatusBits (UPLOADING_MESSAGES); // Add these bits to the status code <br>        SetTransportState (READY); <br>        m_pSupObj-&gt;SpoolerNotify (NOTIFY_SENTDEFERRED, NULL); <br>    } <br>    if (*pulFlags &amp; NOTIFY_END_INBOUND_FLUSH) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Terminate INBOUND flush"); <br>        if (FALSE == m_List.AreTherePendingDownloads()) <br>        { <br>            RemoveStatusBits (DOWNLOADING_MESSAGES); // Tell the spooler to take us off from inbound flush <br>            AddStatusBits (STATUS_OFFLINE); // The transport is now OFF line <br>            UpdateStatus (TRUE, TRUE); <br>        } <br>    } <br>    if (*pulFlags &amp; NOTIFY_END_OUTBOUND_FLUSH) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Terminate OUTBOUND flush"); <br>        if (GetTransportStatusCode() &amp; UPLOADING_MESSAGES) <br>        { <br>            // When the spooler finished sending messages to our CXPLogon::SubmitMessage <br>            // method, he will call us to let us know there is nothing else we need to <br>            // flush, and we need to reset our status row. <br>            RemoveStatusBits (UPLOADING_MESSAGES); // Tell the spooler to take us off from outbound flush <br>            AddStatusBits (STATUS_OFFLINE); // The transport is now OFF line <br>            if (PENDING_RETURN_CODE != GetTransportState()) <br>            { <br>                SetTransportState (WAITING); <br>            } <br>        } <br>    } <br> <br>    // We get called here if user deletes/modifies queued msg in Outbox. <br>    // If the user modifies and resends it, we get called again at SubmitMessage. <br>    // If the user closes the message viewer or just saves it, it's removed <br>    // from the spooler queue and discarded. <br>    if (*pulFlags &amp; NOTIFY_ABORT_DEFERRED) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Abort deferred message"); <br>    } <br>    if (*pulFlags &amp; NOTIFY_CANCEL_MESSAGE) <br>    { <br>        InfoTrace ("CXPLogon::TransportNotify: Cancel message"); <br>    } <br>    if (ulOldStatus != GetTransportStatusCode()) <br>    { <br>        UpdateStatus(); <br>    } <br>    if (*pulFlags &amp; NOTIFY_BEGIN_INBOUND) <br>    { <br>        // If we have pending message from a previous session, notify the <br>        // spooler that we are ready to give them to the store. <br>        if (m_List.AreTherePendingDownloads()) <br>        { <br>            // Put ourselves into flush mode and have the spooler call us until <br>            // we are finished putting the downloaded messages into the default store. <br>            AddStatusBits (DOWNLOADING_MESSAGES); // Add these bits to the status code <br>            UpdateStatus(); <br>        } <br>    } <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::Idle() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. We should not get called here, because we told <br>//      the spooler not to call us here. <br>// <br>//    Return Value <br>//      S_OK always. <br>// <br>STDMETHODIMP CXPLogon::Idle (ULONG ulFlags) <br>{ <br>    InfoTrace ("CXPLogon::Idle method called"); <br>    CheckParameters_IXPLogon_Idle (this, ulFlags); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::TransportLogoff() <br>// <br>//    Parameters <br>//      ulFlags     Priority with which the transport should log off <br>// <br>//    Purpose <br>//      This method is called by the spooler when the transport should do final <br>//      arragements before it gets released. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::TransportLogoff (ULONG ulFlags) <br>{ <br>    InfoTrace ("CXPLogon::TransportLogoff method called"); <br>    CheckParameters_IXPLogon_TransportLogoff (this, ulFlags); <br>    StopUploadTimer(); <br> <br>    EmptyInboundQueue(); <br> <br>    // We should attempt to remove the transport's status row from <br>    // the system, but if we fail we won't fail the call. <br>    HRESULT hResult = m_pSupObj-&gt;ModifyStatusRow (0, NULL, 0); <br>    TraceResult ("CXPLogon::TransportLogoff: Failed to remove status row", hResult); <br> <br>    if (m_pStatusObj) <br>    { <br>        m_pStatusObj-&gt;Release(); <br>        m_pStatusObj = NULL; <br>    } <br> <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::SubmitMessage() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      This method is called by the spooler when a client submits a <br>//      message to a recipient whose address type this transport handles. <br>//      The spooler calls this method twice for each deferred message. <br>//      The first time (before the delivery time) when the message is <br>//      submitted by the client, we simply return. The message is then queued <br>//      by the spooler for later delivery. We keep track of when it's time <br>//      to send deferred messages. <br>// <br>//      The second time we're called, the state variable will be 'READY' and <br>//      we go ahead and start the actual transmission. While we're in the <br>//      body of this function, the implied state is 'SENDING' <br>// <br>//      If the client logs out of this session, any pending messages get <br>//      queued again the next time it logs in. <br>// <br>//      In this transport we get a recipient table, we restrict the table for <br>//      unmarked recipients. After the table is ready we invoke a helper <br>//      method to do the actual transmission. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::SubmitMessage (ULONG     ulFlags, <br>                                      LPMESSAGE pMsgObj, <br>                                      ULONG *   pulMsgRef, <br>                                      ULONG *   pulReturnParm) <br>{ <br>    InfoTrace ("CXPLogon::SubmitMessage method called"); <br>    CheckParameters_IXPLogon_SubmitMessage (this, <br>                                            ulFlags, <br>                                            pMsgObj, <br>                                            pulMsgRef, <br>                                            pulReturnParm); <br> <br>    #ifdef _DEBUG <br>    // Before we get called in SubmitMessage or StartMessage, the spooler should have called <br>    // us in TransportNotify() to let us know which logic (IN, OUT, BOTH) of the <br>    // transporting mechanism should be activated for this IXPLogon session. <br>    if (!(GetTransportStatusCode() &amp; STATUS_OUTBOUND_ENABLED)) <br>    { <br>        TraceMessage ("CXPLogon::SubmitMessage: We can't send a message if the outbound is not enabled"); <br>        ASSERTMSG (FALSE, "We can't submit a message if we have not started OUTBOUND logic"); <br>        return MAPI_E_NOT_ME; <br>    } <br>    #endif // _DEBUG <br> <br>    // Lock the object against the timer thread re-entrancy. Timer events are handle <br>    // in a separate thread. This section will get unlocked in the CPXLogon::EndMessage() call <br>    if (WAITING == GetTransportState()) <br>    { <br>        // Not scheduled upload time, return and let IXPLogon::EndMessage() defer the message <br>        InfoTrace ("CXPLogon::SubmitMessage: Deferring message for scheduled submission"); <br>        return S_OK; <br>    } <br>    InfoTrace ("CXPLogon::SubmitMessage: Processing deferred message"); <br> <br>    CheckSpoolerYield (TRUE); <br> <br>    // Notify the MAPI spooler the transport is going to flush any queued up messages and submit them. <br>    // Transport to used shared resources, such as COM ports, should put them selves into flush mode <br>    // when submitting a batch of messages. This gives the transport the advantage of locking shared <br>    // resources across submitted messages and ensures that the spooler does not call other <br>    // transports while another is flushing because it could have something locked. <br>    // This transport does not uses any shared resources that we would need to lock, but for the <br>    // purposes of demonstration, we put our selves into flush mode until the MAPI spooler <br>    // tells us to step down. <br>    if (!(GetTransportStatusCode() &amp; UPLOADING_MESSAGES)) <br>    { <br>        AddStatusBits (UPLOADING_MESSAGES); <br>        UpdateStatus(); <br>    } <br> <br>    // Get the recipient table from the message <br>    LPMAPITABLE pTable = NULL; <br>    HRESULT hResult = pMsgObj-&gt;GetRecipientTable (fMapiUnicode, &amp;pTable); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SubmitMessage: Failed to get the recipient table", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    // The spooler marks all the message recipients this transport has to <br>    // handle with PR_RESPONSIBILITY set to FALSE <br>    SPropValue spvRecipUnsent; <br>    spvRecipUnsent.ulPropTag                       = PR_RESPONSIBILITY; <br>    spvRecipUnsent.Value.b                         = FALSE; <br> <br>    SRestriction srRecipientUnhandled; <br>    srRecipientUnhandled.rt                        = RES_PROPERTY; <br>    srRecipientUnhandled.res.resProperty.relop     = RELOP_EQ; <br>    srRecipientUnhandled.res.resProperty.ulPropTag = PR_RESPONSIBILITY; <br>    srRecipientUnhandled.res.resProperty.lpProp    = &amp;spvRecipUnsent; <br> <br>    hResult = pTable-&gt;Restrict (&amp;srRecipientUnhandled, 0L); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SubmitMessage: Failed to restrict the recipient table", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    // Let the MAPI spooler do other things <br>    CheckSpoolerYield(); <br> <br>    hResult = HrAddColumns (pTable, <br>                            (LPSPropTagArray)&amp;sptRecipTable, <br>                            gpfnAllocateBuffer, <br>                            gpfnFreeBuffer); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SubmitMessage: Failed to expand the columns in the recipient table", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    LPSRowSet pRecipRows; <br>    hResult = HrQueryAllRows (pTable, <br>                              NULL, <br>                              NULL, <br>                              NULL, <br>                              0, <br>                              &amp;pRecipRows); <br>    if (!hResult) <br>    { <br>        // Let the MAPI spooler do other things <br>        CheckSpoolerYield(); <br>        // Send to the recipients which we can reach, and generate NDR's for the ones we can't <br>        hResult = SendMailMessage (pMsgObj, pRecipRows); <br>        FreeProws (pRecipRows); <br>        if (!hResult) <br>        { <br>            // Now we need to save changes on the message and close it. <br>            // After this, the message object can't be used. <br>            hResult = pMsgObj-&gt;SaveChanges (0); <br>            TraceResult ("CXPLogon::SubmitMessage: Failed to save the message object", hResult); <br>        } <br>    } <br> <br>ErrorExit: <br>     // Release the table, we're finished with it <br>    if (pTable) <br>    { <br>        pTable-&gt;Release(); <br>    } <br> <br>    // Release the spooler's message if needed to <br>    if (pMsgObj) <br>    { <br>        pMsgObj-&gt;Release (); <br>    } <br> <br>    // In case there is a warning or error floating around, don't let it escape to the spooler. <br>    if (FAILED(hResult)) <br>    { <br>        // We default to MAPI_E_NOT_ME so that the spooler would attempt handle <br>        // the message to other transport (currently running in this profile) <br>        // that handle the same address type as ours. <br>        TraceMessage ("CXPLogon::SubmitMessage: An error occurred in the submission, returning MAPI_E_NOT_ME"); <br>        hResult = MAPI_E_NOT_ME; <br>    } <br>    else <br>    { <br>        hResult = S_OK; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::EndMessage() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      This method is called by the spooler for each message we're to <br>//      deliver. It's the mate to SubmitMessage. We're called here twice <br>//      for each deferred message and once for non-deferred (realtime) <br>//      messages. <br>// <br>//      We first check the transport state, and if we're <br>//      WAITING for the scheduled delivery time to arrive, we return <br>//      END_DONT_RESEND in *pulFlags, which tells the spooler to queue this <br>//      message for deferred delivery. <br>// <br>//      If the state is SENDING, we're getting called here after <br>//      a message has been dequeued and delivered. Return 0 in *pulFlags <br>//      to tell the spooler the message has been delivered. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::EndMessage (ULONG ulMsgRef, ULONG * pulFlags) <br>{ <br>    InfoTrace ("CXPLogon::EndMessage method called"); <br>    CheckParameters_IXPLogon_EndMessage (this, ulMsgRef, pulFlags); <br> <br>    if (WAITING == GetTransportState()) <br>    { <br>        // Tell spooler to queue msg for deferred delivery <br>        *pulFlags = END_DONT_RESEND; <br>    } <br>    else <br>    { <br>        *pulFlags = 0; <br>    } <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::Poll() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Stub method. We should not get called here, because we told <br>//      the spooler not to call us here. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::Poll (ULONG * pulIncoming) <br>{ <br>    InfoTrace ("CXPLogon::Poll method called"); <br>    CheckParameters_IXPLogon_Poll (this, pulIncoming); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::StartMessage() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      This method gets called when an incoming message is pending to be <br>//      processed. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::StartMessage (ULONG      ulFlags, <br>                                     LPMESSAGE  pMsgObj, <br>                                     ULONG *    pulMsgRef) <br>{ <br>    InfoTrace ("CXPLogon::StartMessage method called"); <br>    CheckParameters_IXPLogon_StartMessage (this, ulFlags, pMsgObj, pulMsgRef); <br> <br>    // Initialize the pseudo-timer for the SpoolerYield() call <br>    CheckSpoolerYield (TRUE); <br> <br>    HRESULT hResult = S_OK; <br>    LPSTREAM pFileStream = NULL; <br>    CCachedStream * pStream = NULL; <br>    LPITNEF pTNEFObj = NULL; <br>    SPropTagArray sptExcludedProps = { 0 }; <br> <br>    PLIST_NODE pNode = m_List.GetDownloadNode(); <br>    if (!pNode) <br>    { <br>        RemoveStatusBits (DOWNLOADING_MESSAGES); // Remove these bits from the status code <br>        UpdateStatus(); <br>        if (READY == GetTransportState()) <br>        { <br>            SetTransportState (WAITING); <br>        } <br>        goto ErrorExit; <br>    } <br>    // Close the file so that we may open it in the call below <br>    if (pNode-&gt;hFile) <br>    { <br>        CloseHandle (pNode-&gt;hFile); <br>        // NULL the handle to avoid closing the file again during cleanup. <br>        pNode-&gt;hFile = NULL; <br>    } <br>    // Open the stream where the message properties are. <br>    hResult = OpenStreamOnFile (gpfnAllocateBuffer, <br>                                gpfnFreeBuffer, <br>                                STGM_READ, <br>                                pNode-&gt;szFileName, <br>                                NULL, <br>                                &amp;pFileStream); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::StartMessage: Failed to open stream on the message file", hResult); <br>        goto ErrorExit; <br>    } <br>    try <br>    { <br>        // Create a buffer IStream interface for the TNEF decoding <br>        pStream = new CCachedStream (pFileStream, XPSOF_READ); <br>        if (!pStream) <br>        { <br>            TraceMessage ("CXPLogon::StartMessage: Failed to allocate cached stream object"); <br>            hResult = E_OUTOFMEMORY; <br>        } <br>    } <br>    catch (CException &amp; Exception) <br>    { <br>        hResult = Exception.GetError(); <br>    } <br>    pFileStream-&gt;Release(); <br>    pFileStream = NULL; <br>    if (hResult) <br>    { <br>        goto ErrorExit; <br>    } <br>    hResult = OpenTnefStream (m_pSupObj, <br>                              pStream, <br>                              TNEF_FILE_NAME, <br>                              TNEF_DECODE, <br>                              pMsgObj, <br>                              0,    // Not needed when decoding TNEF <br>                              &amp;pTNEFObj); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::StartMessage: Failed to open TNEF stream object", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    // Let the MAPI spooler do other things <br>    CheckSpoolerYield(); <br> <br>    // Get the properties for the message which are encoded in the TNEF <br>    // message stream. The sptExcludedProps argument, is just a stub, <br>    // we are not excluding any properties <br>    LPSTnefProblemArray pProblems; <br>    pProblems = NULL; <br>    hResult = pTNEFObj-&gt;ExtractProps (TNEF_PROP_EXCLUDE, &amp;sptExcludedProps, &amp;pProblems); <br>    if (pProblems) <br>    { <br>        gpfnFreeBuffer (pProblems); <br>        pProblems = NULL; <br>    } <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::StartMessage: Failed to open TNEF stream", hResult); <br>        goto ErrorExit; <br>    } <br>    if (MAPI_E_CORRUPT_DATA == SetIncomingProps (pMsgObj, pNode)) <br>    { <br>        pNode = NULL; // To avoid deleting it below. <br>    } <br> <br>    // Save all chages and new properties, back on the message <br>    // Don't release the message object. The spooler is still using it. <br>    // After this, the message object can't be used by this transport. <br>    hResult = pMsgObj-&gt;SaveChanges (0); <br>    TraceResult ("CXPLogon::StartMessage: Failed to save the message object", hResult); <br> <br>    // Let the MAPI spooler do other things <br>    CheckSpoolerYield(); <br> <br>ErrorExit: <br>    // Release used objects <br>    if (pTNEFObj) <br>    { <br>        pTNEFObj-&gt;Release(); <br>    } <br>    if (pStream) <br>    { <br>        pStream-&gt;Release(); <br>    } <br>    if (pNode) <br>    { <br>        if (pNode-&gt;hFile) <br>        { <br>            CloseHandle (pNode-&gt;hFile); <br>        } <br>        // Delete the file ONLY if the we were successful putting the <br>        // file data into the message. Otherwise leave the file in <br>        // the directory, and it will be picked up later <br>        if (S_OK == hResult) <br>        { <br>            DeleteFile (pNode-&gt;szFileName); <br>        } <br>        delete pNode; <br>    } <br>    m_List.UpdateProgress(); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::OpenStatusEntry() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      This method is called to get an IMAPIStatus object for this XPLOGON <br>//      session. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::OpenStatusEntry (LPCIID          pInterface, <br>                                        ULONG           ulFlags, <br>                                        ULONG *         pulObjType, </code></pre>
<p>
</p>
<pre><code>LPMAPISTATUS *  ppEntry) <br>{ <br>    InfoTrace ("CXPLogon::OpenStatusEntry method called"); <br>    CheckParameters_IXPLogon_OpenStatusEntry (this, <br>                                              pInterface, <br>                                              ulFlags, <br>                                              pulObjType, <br>                                              ppEntry); <br>    if (MAPI_MODIFY &amp; ulFlags) <br>    { <br>        TraceMessage ("CXPLogon::OpenStatusEntry: We don't support WRITE access to the status object"); <br>        return E_ACCESSDENIED; <br>    } <br> <br>    HRESULT hResult = S_OK; <br>    // Now, if we already have created a status object on this logon context, <br>    // we'll just use QueryInterface to get a new copy (AddRef() it) of the object <br>    if (!m_pStatusObj) <br>    { <br>        // Get the profile section of the PROVIDER so that we may get some properties, <br>        // assigned by MAPI to this provider, directly on the status object. <br>        LPPROFSECT pProfileObj = NULL; <br>        m_pSupObj-&gt;OpenProfileSection (NULL, 0, &amp;pProfileObj); <br>        // If we don't have an object, create it, and save a copy in the logon object <br>        m_pStatusObj = new CMAPIStatus (this, pProfileObj); <br>        if (!m_pStatusObj) <br>        { <br>            TraceMessage ("CXPLogon::OpenStatusEntry: Could not allocate new CMAPIStatus object"); <br>            hResult = E_OUTOFMEMORY; <br>        } <br>        // The constructor of CMAPIStatus AddRef()'ed this object <br>        if (pProfileObj) <br>        { <br>            pProfileObj-&gt;Release(); <br>        } <br>    } <br>    if (!hResult) <br>    { <br>        // The transport will return *ppEntry == NULL or a pointer to the new memory allocated <br>        m_pStatusObj-&gt;AddRef(); <br>        *ppEntry = m_pStatusObj; <br>        *pulObjType = MAPI_STATUS; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::ValidateState() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      This function gets caller by a client in order to validate the <br>//      transport logon properties. This function open the profile with the <br>//      most up-to-date properties and then compares them to what the transport <br>//      has stored internally <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::ValidateState (ULONG ulUIParam, ULONG ulFlags) <br>{ <br>    InfoTrace ("CXPLogon::ValidateState method called"); <br>    CheckParameters_IXPLogon_ValidateState (this, <br>                                            ulUIParam, <br>                                            ulFlags); <br> <br>    // Try to open the transport profile section <br>    LPPROFSECT pProfileObj; <br>    HRESULT hResult = OpenServiceProfileSection (m_pSupObj, &amp;pProfileObj, gpfnFreeBuffer); <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br> <br>    LPSPropValue pProps = NULL; <br>    ULONG ulPropCount; <br>    // Read the properties stored in the profile of this user <br>    hResult = pProfileObj-&gt;GetProps ((LPSPropTagArray)&amp;sptLogonProps, <br>                                     fMapiUnicode, <br>                                     &amp;ulPropCount, <br>                                     &amp;pProps); <br>    TraceResult ("CXPLogon::ValidateState: Failed to get profile properties", hResult); <br>    if (!hResult) <br>    { <br>        // Now, compare what the transport thinks the information in the profile is <br>        // to the real data. If they are different, tell the spooler the transport <br>        // would like to be reloaded <br>        if (lstrcmp (m_UserInfo.szMailboxName, pProps[MAILBOX_NAME].Value.LPSZ)|| <br>            lstrcmp (m_UserInfo.szPassword, pProps[PASSWORD].Value.LPSZ) || <br>            lstrcmp (m_UserInfo.szFullName, pProps[USER_NAME].Value.LPSZ) || <br>            lstrcmpi (m_szServer, pProps[SERVER_NAME].Value.LPSZ)) <br>        { <br>            hResult = m_pSupObj-&gt;SpoolerNotify (NOTIFY_CONFIG_CHANGE, NULL); <br>            TraceResult ("CXPLogon::ValidateState: Failed to notify the spooler", hResult); <br>        } <br>    } <br>    pProfileObj-&gt;Release(); <br>    gpfnFreeBuffer (pProps); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::FlushQueues() <br>// <br>//    Parameters <br>//      { Refer to MAPI Documentation on this method } <br>// <br>//    Purpose <br>//      Called by the MAPI spooler when, upon request of the client or <br>//      ourselves, we need to flush the inbound or outbound queue. <br>//      Here we make connections to the server to download messages, refresh <br>//      the remote message headers, and request the spooler to send us any <br>//      deferred messages. <br>//      Transport connecting only in FlushQueues() allow the MAPI spooler to <br>//      better manage contention of multiple transport accessing common <br>//      communication resources (such as COM ports) and let the spooler give us <br>//      messages to process when is best for the overall subsystem. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::FlushQueues (ULONG       ulUIParam, <br>                                    ULONG       cbTargetTransport, <br>                                    LPENTRYID   pTargetTransport, <br>                                    ULONG       ulFlags) <br>{ <br>    InfoTrace ("CXPLogon::FlushQueues method called"); <br>    CheckParameters_IXPLogon_FlushQueues (this, <br>                                          ulUIParam, <br>                                          cbTargetTransport, <br>                                          pTargetTransport, <br>                                          ulFlags); <br> <br>    HRESULT hResult = S_OK; <br>    // Update status flags and then update update the transport status rows <br>    if (ulFlags &amp; FLUSH_UPLOAD) <br>    { <br>        // If the remote server is offline, the transport is not going to send the deferred messages <br>        if (TRUE == IsWINDSServerAvailable (m_szServer)) <br>        { <br>            // If we are already in delivery mode submitted messages will not get deferred, <br>            // so don't bother the spooler asking for deferred messages. <br>            if (READY != GetTransportState()) <br>            { <br>                // Guard against re-entrancy from the timer call back which happens on a separate thread <br>                if (PROCESSING_TIMER_EVENT != GetTransportState()) <br>                { <br>                    SetTransportState (READY); <br>                } <br>                // We pass NULL for the entry ID so that the spooler would resend ALL the <br>                // deferred messages. Transport may pass individual entry IDs for specific messages. <br>                hResult = m_pSupObj-&gt;SpoolerNotify (NOTIFY_SENTDEFERRED, NULL); <br>            } <br>        } <br>    } <br>    if (ulFlags &amp; FLUSH_DOWNLOAD) <br>    { <br>        if (HEADERS_AND_DOWNLOAD == GetTransportState()) <br>        { <br>            m_hRemoteActionErr = ProcessHeaders(); <br>            if (!m_hRemoteActionErr &amp;&amp; !m_fCancelPending) <br>            { <br>                m_pSupObj-&gt;SpoolerYield (0); <br>                if (m_List.AreTherePendingDownloads()) <br>                { <br>                    // Put ourselves into flush mode and have the spooler call us until <br>                    // we are finished putting the downloaded messages into the default store. <br>                    AddStatusBits (DOWNLOADING_MESSAGES); // Add these bits to the status code <br>                } <br>                if (!m_fCancelPending) <br>                { <br>                    // Upload any deferred messages the spooler has for our transport <br>                    if (IsWINDSServerAvailable (m_szServer)) <br>                    { <br>                        m_pSupObj-&gt;SpoolerNotify (NOTIFY_SENTDEFERRED, NULL); <br>                    } <br>                    if (!m_fCancelPending) <br>                    { <br>                        m_hRemoteActionErr = DownloadMessageHeaders(); <br>                        if (!m_hRemoteActionErr &amp;&amp; !(GetTransportStatusCode() &amp; DOWNLOADING_MESSAGES)) <br>                        { <br>                            RemoveStatusBits (STATUS_INBOUND_FLUSH); <br>                            UpdateStatus (TRUE, TRUE); <br>                            m_pSupObj-&gt;SpoolerYield (0); <br>                        } <br>                    } <br>                } <br>            } <br>            SetTransportState (PENDING_RETURN_CODE); <br>            AddStatusBits (STATUS_OFFLINE); <br>            if (m_hRemoteActionErr) <br>            { <br>                RemoveStatusBits (STATUS_INBOUND_FLUSH); <br>                UpdateStatus (TRUE, TRUE); <br>            } <br>            else <br>            { <br>                if (m_fCancelPending) <br>                { <br>                    UpdateStatus (TRUE, TRUE); <br>                } <br>                else <br>                { <br>                    UpdateStatus(); <br>                } <br>            } <br>        } <br>        else <br>        { <br>            if (PROCESSING_TIMER_EVENT == GetTransportState()) <br>            { <br>                if (m_fGetHeaders) <br>                { <br>                    RemoveStatusBits (STATUS_OFFLINE); <br>                    UpdateStatus(); <br>                    DownloadMessageHeaders(); <br>                    AddStatusBits (STATUS_OFFLINE); <br>                    UpdateStatus(); <br>                } <br>            } <br>            else <br>            { <br>                if (m_List.AreTherePendingDownloads()) <br>                { <br>                    // Put ourselves into flush mode and have the spooler call us until <br>                    // we are finished putting the downloaded messages into the default store. <br>                    AddStatusBits (DOWNLOADING_MESSAGES); // Add these bits to the status code <br>                    UpdateStatus(); <br>                } <br>            } <br>        } <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::ProcessHeaders() <br>// <br>//    Parameters <br>//      None. <br>// <br>//    Purpose <br>//      This method is called from the status object's ValidateState when <br>//      it's passed PROCESS_XP_HEADER_CACHE. It starts the download processing. <br>//      First we get the header folder contents table and restrict it to rows <br>//      where PR_MSG_STATUS is &gt;= MSGSTATUS_REMOTE_DOWNLOAD. These are rows <br>//      for messages that have the MSGSTATUS_REMOTE_DOWNLOAD, or <br>//      MSGSTATUS_REMOTE_DELETE, or both, bits set. <br>// <br>//      We then connect to the server to obtain the download named pipe and <br>//      start the download. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::ProcessHeaders() <br>{ <br>    // If we don't have a folder in the status object or the folder doesn't <br>    // have an initialized contents table, there is nothing to do. <br>    if (!m_pStatusObj-&gt;m_pHeaderFolder || !m_pStatusObj-&gt;m_pHeaderFolder-&gt;m_pTableData) <br>    { <br>        return S_OK; <br>    } <br> <br>    // Get headers folder contents table, some are marked for download <br>    LPMAPITABLE pTable; <br>    HRESULT hResult = m_pStatusObj-&gt;m_pHeaderFolder-&gt;m_pTableData-&gt;HrGetView (NULL, NULL, 0, &amp;pTable); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::ProcessHeaders: Failed to get a view on the contents table", hResult); <br>        return hResult; <br>    } <br> <br>    // we only want rows marked for download, form restriction <br>    SPropValue spvFilter = { 0 }; <br>    spvFilter.ulPropTag = PR_MSG_STATUS; <br>    spvFilter.Value.l = MSGSTATUS_REMOTE_DOWNLOAD; <br> <br>    // This restriction relies in the current values of the flags in PR_MSG_STATUS <br>    SRestriction srStatus = { 0 }; <br>    srStatus.rt = RES_PROPERTY; <br>    srStatus.res.resProperty.relop = RELOP_GE; <br>    srStatus.res.resProperty.ulPropTag = PR_MSG_STATUS; <br>    srStatus.res.resProperty.lpProp = &amp;spvFilter; <br> <br>    hResult = pTable-&gt;Restrict (&amp;srStatus, 0); <br>    if (hResult) <br>    { <br>        // This is a non-fatal error (i.e. the implementation does not support restrictions) <br>        TraceResult ("CXPLogon::ProcessHeaders: Failed to restrict the table", hResult); <br>    } <br>    ULONG ulRowCount; <br>    // Providers and client should not, when ever possible, use IMAPITable::GetRowCount() <br>    // because depending on the implementation of the table, the returned count by not <br>    // be exact. <br>    // We use it here for convenience knowing the fact the MAPI's ITableData implementation <br>    // returns and EXACT count of the rows in the memory table. <br>    hResult = pTable-&gt;GetRowCount (0, &amp;ulRowCount); <br>    if (hResult) <br>    { <br>        goto ErrorExit; <br>    } <br>    // Nothing to do. <br>    if (0 == ulRowCount) <br>    { <br>        goto ErrorExit; <br>    } <br>    else <br>    { <br>        // Make sure our download directory is around. <br>        TCHAR szTmpDir[_MAX_PATH], szDownloadDir[_MAX_PATH]; <br>        GetTempPath (_MAX_PATH, szTmpDir); <br>        lstrcat (szTmpDir, WINDS_DATA_DIRECTORY); <br>        wsprintf (szDownloadDir, WINDS_DOWNLOAD_DIR_NAME_FORMAT, szTmpDir, m_UserInfo.szMailboxName); <br>        CreateDirectory (szDownloadDir, NULL); <br>    } <br> <br>    // Initialize the progress property in the status row of this transport. <br>    UpdateProgress (0, REMOTE_ACTION_DOWNLOADING_MSGS); <br> <br>    // Make a call to the remote server to open the connection <br>    HANDLE hPipe; <br>    hResult = OpenRemoteServerDownLoadPipe (m_szServer, m_UserInfo.szMailboxName, &amp;hPipe); <br>    if (hResult) <br>    { <br>        goto ErrorExit; <br>    } <br>    // Do the actual download transmission now. <br>    hResult = m_List.DownLoadMsgs (pTable, ulRowCount, hPipe); <br>    CloseHandle (hPipe); <br> <br>    TerminateRemoteConnections(); <br> <br>ErrorExit: <br>    TraceResult ("CXPLogon::ProcessHeaders", hResult); <br>    pTable-&gt;Release(); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::UpdateProgress() <br>// <br>//    Parameters <br>//      lPercentComplete    Percent completion of download <br>//      raFlag              Flag that indicate to what remote action the <br>//                          update is tied to, so that we may properly <br>//                          update PR_REMOTE_PROGRESS_TEXT. <br>// <br>//    Purpose <br>//      Sets the status row property PR_REMOTE_PROGRESS with a number from <br>//      0-100. In example, if 10 messages are queued and 5 have been <br>//      downloaded, lPercentComplete will be 50, regardless of individual <br>//      messages' sizes. <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI CXPLogon::UpdateProgress (long          lPercentComplete, <br>                                      REMOTE_ACTION raFlag) <br>{ <br>    SPropValue spProgress[2] = { 0 }; <br>    ULONG cProps = 1; <br>    TCHAR szRemoteProgress[64] = { 0 }; <br>    spProgress[0].ulPropTag = PR_REMOTE_PROGRESS; <br>    spProgress[0].Value.l = lPercentComplete; <br>    if (raFlag != m_raAction) <br>    { <br>        spProgress[1].ulPropTag = PR_REMOTE_PROGRESS_TEXT; <br>        spProgress[1].Value.LPSZ = szRemoteProgress; <br>        DWORD idString; <br>        m_raAction = raFlag; <br>        switch (raFlag) <br>        { <br>            case REMOTE_ACTION_DOWNLOADING_MSGS : <br>                idString = IDS_REMOTE_DOWNLOADING; <br>                break; <br>            case REMOTE_ACTION_PROCESSING_MSGS : <br>                idString = IDS_REMOTE_PROCESSING_MSGS; <br>                break; <br>            case REMOTE_ACTION_HEADER_REFRESH : <br>                idString = IDS_REMOTE_REFRESHING_HEADERS; <br>                break; <br>            case REMOTE_ACTION_IDLE : <br>                idString = 0; <br>                break; <br>        } <br>        if (idString) <br>        { <br>            LoadString (m_hInstance, idString, szRemoteProgress, 64); <br>        } <br>        cProps++; <br>    } <br> <br>    HRESULT hResult = m_pSupObj-&gt;ModifyStatusRow (cProps, spProgress, STATUSROW_UPDATE); <br>    TraceResult ("CXPLogon::UpdateProgress: Failed to modify the status row", hResult); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::LoadStatusString() <br>// <br>//    Parameters <br>//      pString         Pointer to a string which will hold the status string <br>//      uStringSize     Maximum number of characters allowed in the string <br>// <br>//    Purpose <br>//      Loads a string from the transport's stringtable. This method is called <br>//      by the CXPLogon::UpdateStatus method when updating a status row. This <br>//      method loads the string based on the status bits of the transport <br>//      status code <br>// <br>//    Return Value <br>//      TRUE            If the string was found in the string table. <br>//      FALSE           The string was not found. The String indicated by <br>//                      pString is set to hold 0 characters <br>// <br>BOOL WINAPI CXPLogon::LoadStatusString (LPTSTR pString, UINT uStringSize) <br>{ <br>    UINT uStringID; <br>    DWORD dwStatusCode = GetTransportStatusCode(); <br>    if (dwStatusCode &amp; (DOWNLOADING_MESSAGES | UPLOADING_MESSAGES)) <br>    { <br>        uStringID = IDS_XP_STATUS_TIMER_EVENT; <br>    } <br>    else <br>    { <br>        if (dwStatusCode &amp; DOWNLOADING_MESSAGES) <br>        { <br>            if (dwStatusCode &amp; STATUS_OFFLINE) <br>            { <br>                uStringID = IDS_XP_STATUS_FLUSHING_INBOUND; <br>            } <br>            else <br>            { <br>                uStringID = IDS_XP_STATUS_INBOUND_AND_HEADERS; <br>            } <br>        } <br>        else <br>        { <br>            if (dwStatusCode &amp; UPLOADING_MESSAGES) <br>            { <br>                uStringID = IDS_XP_STATUS_FLUSHING_OUTBOUND; <br>            } <br>            else <br>            { <br>                if (dwStatusCode &amp; STATUS_INBOUND_ENABLED &amp;&amp; <br>                    dwStatusCode &amp; STATUS_OUTBOUND_ENABLED) <br>                { <br>                    uStringID = IDS_XP_STATUS_READY; <br>                } <br>                else <br>                { <br>                    uStringID = IDS_XP_STATUS_AVAILABLE; <br>                } <br>            } <br>        } <br>    } <br>    if (LoadString (m_hInstance, uStringID, pString, uStringSize)) <br>    { <br>        return TRUE; <br>    } <br>    pString[0] = '\0'; <br>    return FALSE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::MakeSearchKey() <br>// <br>//    Parameters <br>//      pParentMemBlock     Pointer the a block of memory allocated with the <br>//                          MAPI Mem. alloc. functions. <br>//      pszAddress          String with the actual mail address <br>//      pcbSearchKey        Pointer to a ULONG which returns the size <br>//                          (in bytes) of the newly created search key <br>//      ppSearchKey         Pointer to an array ob BYTES <br>// <br>//    Purpose <br>//      Returns a MAPI search key of the form TYPE:ADDRESS in upper case. <br>//      The string is allocated with the MAPI Mem Alloc functions and linked <br>//      to the block of memory indicated by pParentMemBlock <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::MakeSearchKey (LPVOID        pParentMemBlock, <br>                                      LPTSTR        pszAddress, <br>                                      ULONG *       pcbSearchKey, <br>                                      LPBYTE *      ppSearchKey) <br>{ <br>    LPTSTR pszSearchKey; <br>    // The 2 is for the COLON and the NULL terminator <br>    ULONG cbStrSize = sizeof (TCHAR) * (2 + lstrlen (WINDS_ADDRESS_TYPE) + lstrlen (pszAddress)); <br>    HRESULT hResult = gpfnAllocateMore (cbStrSize, pParentMemBlock, (LPVOID *)&amp;pszSearchKey); <br>    TraceResult ("CXPLogon::MakeSearchKey: Failed to allocate search key string", hResult); <br>    if (!hResult) <br>    { <br>        // We need to convert the address to upper case <br>        wsprintf (pszSearchKey, TEXT("%s:%s"), WINDS_ADDRESS_TYPE, pszAddress); <br>        CharUpper (pszSearchKey); <br>        *pcbSearchKey = cbStrSize; <br>        *ppSearchKey = (LPBYTE)pszSearchKey; <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::UpdateStatus() <br>// <br>//    Parameters <br>//      fAddValidate <br>//      fValidateOkState <br>// <br>//    Purpose <br>//      Updates the transport status row of this transport in the MAPI Mail <br>//      subsystem. Updates the flags according the internal state flags <br>//      maintained in status code of the transport and loads a readable status <br>//      string to reset the status row. The caller of this method should update <br>//      the status code member variable prior to calling UpdateStatus() <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CXPLogon::UpdateStatus (BOOL fAddValidate, BOOL fValidateOkState) <br>{ <br>    ULONG cProps = 1; <br>    SPropValue rgProps[3] = { 0 }; <br>    //  Store the new Transport Provider Status Code <br>    rgProps[0].ulPropTag = PR_STATUS_CODE; <br>    rgProps[0].Value.l = GetTransportStatusCode(); <br> <br>    TCHAR szStatus[64]; <br>    if  (LoadStatusString (szStatus, sizeof(szStatus) - 1 )) <br>    { <br>        rgProps[1].ulPropTag = PR_STATUS_STRING; <br>        rgProps[1].Value.LPSZ = szStatus; <br>        cProps++; <br>    } <br>    if (fAddValidate) <br>    { <br>        ULONG index; <br>        if (2 == cProps) <br>        { <br>            index = 2; <br>        } <br>        else <br>        { <br>            index = 1; <br>        } <br>        rgProps[index].ulPropTag = PR_REMOTE_VALIDATE_OK; <br>        rgProps[index].Value.b = fValidateOkState; <br>        cProps++; <br>    } <br>    //  OK. Notify the messaging subsystem of state changes in this transport. <br>    HRESULT hResult = m_pSupObj-&gt;ModifyStatusRow (cProps, rgProps, STATUSROW_UPDATE); <br>    TraceResult ("CXPLogon::UpdateStatus: ModifyStatusRow failed", hResult); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::InitializeTransportStatusFlags() <br>// <br>//    Parameters <br>//      ulFlags     Flags passed in to initialize the transport status flags. <br>// <br>//    Purpose <br>//      Initialize the transport status flags with the flags passed in by the <br>//      MAPI spooler. This method gets called when initializing a CXPLogon <br>//      object in the CXPProvider::TransportLogon method. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CXPLogon::InitializeTransportStatusFlags (ULONG ulFlags) <br>{ <br>    AddStatusBits (STATUS_AVAILABLE | STATUS_OFFLINE | STATUS_REMOTE_ACCESS); <br>    if (!(ulFlags &amp; LOGON_NO_INBOUND)) <br>    { <br>        AddStatusBits (STATUS_INBOUND_ENABLED); <br>    } <br>    if (!(ulFlags &amp; LOGON_NO_OUTBOUND)) <br>    { <br>        AddStatusBits (STATUS_OUTBOUND_ENABLED); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::SetIdentityProps() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      Initializes the transport ID array with the properties found in the <br>//      profile for the user. <br>//      If the ABWDS address book is installed, we open an entry in it to <br>//      supply the identity properties. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::SetIdentityProps() <br>{ <br>    // Allocate the property array for transport. This memory block is freed <br>    // in the destructor of the CXPLogon object <br>    HRESULT hResult = gpfnAllocateBuffer (sizeof(SPropValue)*NUM_IDENTITY_PROPS, (LPVOID *)&amp;m_pIdentityProps); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SetIdentityProps: Failed to allocate property array", hResult); <br>        return hResult; <br>    } <br>    LPMAILUSER pUser; <br>    ULONG ulObjType; <br>    TCHAR szSearchKey[128]; <br>    LPTSTR pStr; <br>    // Try to open out entry ID in the ABWDS address book (see if it is around) <br>    // If the call fails, we must create a one-off for our identity. <br>    hResult = m_pSupObj-&gt;OpenEntry (CB_PRIVATE_EID, <br>                                    (LPENTRYID)&amp;m_UserEID, <br>                                    NULL, <br>                                    0, <br>                                    &amp;ulObjType, <br>                                    (LPUNKNOWN *)&amp;pUser); <br>    if (S_OK == hResult) <br>    { <br>        ASSERTMSG (MAPI_MAILUSER == ulObjType, "What kind object is this?"); <br> <br>        // Looks like ABWDS is around, mark the internal flag. <br>        // ABWDS is the native WINDS address book service provider. If present, <br>        // instead of creating a one-off entry for the transport identity, we <br>        // will simply open an entry in the WINDS address book and get the <br>        // necessary properties out from it. <br>        m_fABWDSInstalled = TRUE; <br> <br>        m_pIdentityProps[XPID_NAME].ulPropTag = PR_SENDER_NAME; <br>        m_pIdentityProps[XPID_NAME].Value.LPSZ = m_UserInfo.szFullName; <br>        m_pIdentityProps[XPID_EID].ulPropTag = PR_SENDER_ENTRYID; <br>        m_pIdentityProps[XPID_EID].Value.bin.cb = CB_PRIVATE_EID; <br>        m_pIdentityProps[XPID_EID].Value.bin.lpb = (LPBYTE)&amp;m_UserEID; <br>        wsprintf (szSearchKey, <br>                  TEXT("%s:%s\\%s"), <br>                  WINDS_ADDRESS_TYPE, <br>                  m_szServer,       // this is already in the format "\\&lt;servername&gt;" <br>                  m_UserInfo.szMailboxName); <br>        CharUpper (szSearchKey); <br>        hResult = gpfnAllocateMore (Cbtszsize(szSearchKey), m_pIdentityProps, (LPVOID *)&amp;pStr); <br>        if (hResult) <br>        { <br>            TraceResult ("CXPLogon::SetIdentityProps: Failed to allocate string for native search key", hResult); <br>            m_pIdentityProps[XPID_SEARCH_KEY].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_SENDER_SEARCH_KEY)); <br>        } <br>        else <br>        { <br>            lstrcpy (pStr, szSearchKey); <br>            m_pIdentityProps[XPID_SEARCH_KEY].ulPropTag = PR_SENDER_SEARCH_KEY; <br>            m_pIdentityProps[XPID_SEARCH_KEY].Value.bin.cb = Cbtszsize(pStr); <br>            m_pIdentityProps[XPID_SEARCH_KEY].Value.bin.lpb = (LPBYTE)pStr; <br>        } <br>        pUser-&gt;Release(); <br>        return hResult; <br>    } <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_SENDER_ENTRYID property. Create an entry for the user and <br>    // set it in the property array <br>    m_pIdentityProps[XPID_EID].ulPropTag = PR_SENDER_ENTRYID; <br>    LPBYTE lpeid = NULL; <br>    ULONG  cbeid = 0; <br>    hResult = m_pSupObj-&gt;CreateOneOff (m_UserInfo.szFullName, <br>                                       WINDS_ADDRESS_TYPE, <br>                                       m_szAddress, <br>                                       fMapiUnicode, <br>                                       &amp;cbeid, <br>                                       (LPENTRYID *)&amp;lpeid); <br> if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SetIdentityProps: Failed to create a one off identity", hResult); <br>        m_pIdentityProps[XPID_EID].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_SENDER_ENTRYID)); <br>        return hResult; <br>    } <br> <br>    hResult = gpfnAllocateMore(cbeid, m_pIdentityProps, <br>                            (LPVOID *)&amp;m_pIdentityProps[XPID_EID].Value.bin.lpb); <br>    if(hResult) <br>    { <br>        TraceResult ("CXPLogon::SetIdentityProps: Failed to allocate memory", hResult); <br>        m_pIdentityProps[XPID_EID].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_SENDER_ENTRYID)); <br>        gpfnFreeBuffer(lpeid); <br>        lpeid = NULL; <br>        return hResult; <br>    } <br> <br>    m_pIdentityProps[XPID_EID].Value.bin.cb = cbeid; <br>    CopyMemory(m_pIdentityProps[XPID_EID].Value.bin.lpb, lpeid, cbeid); <br> <br>    gpfnFreeBuffer(lpeid); <br>    lpeid = NULL; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_SENDER_NAME property <br>    m_pIdentityProps[XPID_NAME].ulPropTag = PR_SENDER_NAME; <br>    LPTSTR pStr1, pStr2 = m_UserInfo.szFullName; <br>    hResult = gpfnAllocateMore (Cbtszsize(pStr2), m_pIdentityProps, (LPVOID *)&amp;pStr1); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SetIdentityProps: Memory allocation failed for display name string", hResult); <br>        m_pIdentityProps[XPID_NAME].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_SENDER_NAME)); <br>        return hResult; <br>    } <br>    lstrcpy (pStr1, pStr2); <br>    m_pIdentityProps[XPID_NAME].Value.LPSZ = pStr1; <br> <br>    ////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_SENDER_SEARCH_KEY property <br>    m_pIdentityProps[XPID_SEARCH_KEY].ulPropTag = PR_SENDER_SEARCH_KEY; <br>    // First, create the search key <br>    hResult = MakeSearchKey (m_pIdentityProps, <br>                             m_szAddress, <br>                             &amp;m_pIdentityProps[XPID_SEARCH_KEY].Value.bin.cb, <br>                             &amp;m_pIdentityProps[XPID_SEARCH_KEY].Value.bin.lpb); <br>    if (hResult) <br>    { <br>        m_pIdentityProps[XPID_SEARCH_KEY].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_SENDER_SEARCH_KEY)); <br>    } <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::SetSessionFlags() <br>// <br>//    Parameters <br>//      [IN, OUT]   pulFlags    Flags returned to caller <br>// <br>//    Purpose <br>//      To set the flags we will return to the spooler during the CXPLogon <br>//      initialization in the CXPProvider::TransportLogon method. The ulFlags <br>//      parameter is filled as a return value to the caller <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CXPLogon::SetSessionFlags (ULONG * pulFlags) <br>{ <br>    if (*pulFlags &amp; LOGON_NO_CONNECT) <br>    { <br>        // Nothing is set <br>        *pulFlags = 0; <br>    } <br>    else <br>    { <br>        // We DON'T want the MAPI spooler to call our IXPLogon::Idle method (LOGON_SP_IDLE not added) <br>        // We DON'T want the MAPI spooler to call our IXPLogon::Poll method (LOGON_SP_POLL not added) <br>        // Also the names have to be fully resolved (LOGON_SP_RESOLVE) <br>        *pulFlags = LOGON_SP_RESOLVE; <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::SendMailMessage() <br>// <br>//    Parameters <br>//      pMsgObj     Pointer to an IMessage object passed to us by the <br>//                  MAPI spooler. </code></pre>
<p>
</p>
<pre><code>//      pRecipRows  Row set with ALL the rows from the recipient table which <br>//                  have the properties of the recipients we are sending the <br>//                  message to. <br>// <br>//    Purpose <br>//      This method gets called by SubmitMessage() to do the delivery of the <br>//      message to the list of recipients. Each recipient will have the <br>//      PR_RESPONSIBILITY property set indicating weather or not message <br>//      reached the recipient. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::SendMailMessage (LPMESSAGE pMsgObj, LPSRowSet pRecipRows) <br>{ <br>    LPSPropValue pMsgProps = NULL; <br>    LPADRLIST pAdrList = NULL, pAdrListFailed = NULL; <br>    LPSTnefProblemArray pProblems = NULL; <br>    CCachedStream * pStream = NULL; <br>    LPSTREAM pFileStream; <br>    HANDLE hMsgFile = NULL; <br>    HRESULT hOpenConnect, hUploadError; <br>    BOOL fErrorInServer, fSentSuccessfully; <br>    ULONG ulRow, ulCount1 = 0 , ulCount2 = 0; <br>    LPTSTR pszServer, pszMailbox; <br>    LPSPropValue pProps; <br>    TCHAR szHeaderText[1024], szTmpFile[_MAX_PATH], szConnectInfo[MAX_STRING_SIZE+1] = { 0 }; <br>    if (!GetMsgTempFileName (szTmpFile))   // Not the Win32 API, but an internal implementation <br>    { <br>        return E_FAIL; <br>    } <br> <br>    // Create a stream where all message information will be saved. <br>    HRESULT hResult = OpenStreamOnFile (gpfnAllocateBuffer, <br>                                        gpfnFreeBuffer, <br>                                        STGM_CREATE | STGM_READWRITE, <br>                                        szTmpFile, <br>                                        NULL, <br>                                        &amp;pFileStream); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SendMailMessage: Failed to create stream object", hResult); <br>        return hResult; <br>    } <br>    try <br>    { <br>        pStream = new CCachedStream (pFileStream, XPSOF_READWRITE); <br>        if (!pStream) <br>        { <br>            TraceMessage ("CXPLogon::SendMailMessage: Failed to allocate cached stream object"); <br>            hResult = E_OUTOFMEMORY; <br>        } <br>    } <br>    catch (CException &amp; Exception) <br>    { <br>        hResult = Exception.GetError(); <br>    } <br>    pFileStream-&gt;Release(); <br>    pFileStream = NULL; <br>    if (hResult) <br>    { <br>        return hResult; <br>    } <br> <br>    // The wKey is a key used to identify the TNEF property stream. Transports <br>    // should generate a pseudo-random number for this field. Here we get <br>    // a number based upon the system's tic count <br>    // Note that this number cannot be zero of the  OpenTnefStream call will be fail. <br>    WORD wKey = LOWORD (GetTickCount()); <br>    if (!wKey) <br>    { <br>        ASSERTMSG (FALSE, "I'll be darn! It's zero!!!"); <br>        wKey = LOWORD (GetTickCount()) + 1; <br>        ASSERTMSG (0 != wKey, "No way! What is going on!?!?"); <br>    } <br>    LPITNEF pTNEFObj = NULL; <br>    hResult = OpenTnefStream (m_pSupObj, <br>                              pStream, <br>                              TNEF_FILE_NAME, <br>                              TNEF_ENCODE | TNEF_PURE, <br>                              pMsgObj, <br>                              wKey, <br>                              &amp;pTNEFObj); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SendMailMessage: Failed to create TNEF object", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    // Let the MAPI spooler do other things <br>    CheckSpoolerYield(); <br> <br>    // Get the current time. We need to set some properties that require the time <br>    SYSTEMTIME st; <br>    FILETIME ft; <br>    GetSystemTime (&amp;st); <br>    SystemTimeToFileTime (&amp;st, &amp;ft); <br> <br>    SetOutgoingProps (pMsgObj, ft); <br> <br>    // Check what properties there are and exclude the Non-Transmittables ones <br>    LPSPropTagArray pTags; <br>    hResult = pMsgObj-&gt;GetPropList (fMapiUnicode, &amp;pTags); <br>    if (hResult) <br>    { <br>        TraceResult ("CXPLogon::SendMailMessage: Failed to get the message property tags", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    // Let the MAPI spooler do other things <br>    CheckSpoolerYield(); <br> <br>    // In this sample transport we opted to let TNEF encapsulate <br>    // the table of recipients of this message. This has a side effect: The <br>    // addresses of the recipients get munged into the TNEF stream. So, for <br>    // example, if the TNEF file goes through a foreign mail system and it <br>    // needs to translate the address of the recipients, it will not be <br>    // able to. A tranport using TNEF which trasmits messages to a foreign <br>    // mail system, must do custom processing of the recipients and their <br>    // address so the receiving side will understands them. <br>    // This sample code must be modified if you want it as the base code <br>    // for a gateway transport. <br>    // Here we also let TNEF encode all the attachments we want to send. <br>    ULONG cValues, i; <br>    cValues = 0; <br>    for (i=0; i&lt;pTags-&gt;cValues; i++) <br>    { <br>        // Use the FIsTransmittable macro in MAPI to determine if a <br>        // property is transmittable or not. <br>        if (!FIsTransmittable(pTags-&gt;aulPropTag[i]) &amp;&amp; <br>            PR_MESSAGE_RECIPIENTS != pTags-&gt;aulPropTag[i] &amp;&amp; <br>            PR_MESSAGE_ATTACHMENTS != pTags-&gt;aulPropTag[i]) <br>        { <br>            pTags-&gt;aulPropTag[cValues++] = pTags-&gt;aulPropTag[i]; <br>        } <br>    } <br>    pTags-&gt;cValues = cValues; <br> <br>    // Encode the properties now <br>    hResult = pTNEFObj-&gt;AddProps (TNEF_PROP_EXCLUDE, 0, NULL, pTags); <br>    gpfnFreeBuffer (pTags); <br>    if (FAILED(hResult)) // There could be warnings <br>    { <br>        TraceResult ("CXPLogon::SendMailMessage: Failed to Add the TNEF properties to the message stream", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    hResult = pTNEFObj-&gt;Finish (0, &amp;wKey, &amp;pProblems); <br>    if (FAILED(hResult)) // There could be warnings <br>    { <br>        TraceResult ("CXPLogon::SendMailMessage: Failed to save the TNEF props", hResult); <br>        goto ErrorExit; <br>    } <br>    if (pProblems) <br>    { <br>        TraceMessage ("CXPLogon::SendMailMessage: Some problem(s) occurred while finishing the TNEF encoding"); <br>        gpfnFreeBuffer (pProblems); <br>        pProblems = NULL; <br>        // Don't have to fail submission <br>    } <br> <br>    // Release used objects and NULL the object pointers to avoid re-releasing them during cleanup <br>    if (NULL != pTNEFObj) <br>    { <br>        pTNEFObj-&gt;Release(); <br>        pTNEFObj = NULL; <br>    } <br>    if (NULL != pStream) <br>    { <br>        pStream-&gt;Release(); <br>        pStream = NULL; <br>    } <br> <br>    hMsgFile = CreateFile (szTmpFile, <br>                           GENERIC_READ, <br>                           0, <br>                           NULL, <br>                           OPEN_EXISTING, <br>                           FILE_ATTRIBUTE_TEMPORARY | <br>                           FILE_FLAG_DELETE_ON_CLOSE | <br>                           FILE_FLAG_SEQUENTIAL_SCAN, <br>                           NULL); <br>    if (INVALID_HANDLE_VALUE == hMsgFile) <br>    { <br>        TraceResult ("CXPLogon::SendMailMessage: Failed to open local msg file", GetLastError()); <br>        hResult = E_FAIL; <br>        goto ErrorExit; <br>    } <br> <br>    // Get some properties in the message need to send the message <br>    // and delivery report information <br>    hResult = pMsgObj-&gt;GetProps ((LPSPropTagArray)&amp;sptPropsForHeader, <br>                                 fMapiUnicode, <br>                                 &amp;cValues, <br>                                 &amp;pMsgProps); <br>    if (FAILED(hResult)) <br>    { <br>        TraceResult ("CXPLogon::SendMailMessage: Failed to get message props", hResult); <br>        goto ErrorExit; <br>    } <br> <br>    // We need to check if the sender requeste a delivery report or not. <br>    BOOL fNeedDeliveryReport; <br>    if (PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED == pMsgProps[MSG_DR_REPORT].ulPropTag &amp;&amp; <br>        pMsgProps[MSG_DR_REPORT].Value.b) <br>    { <br>        fNeedDeliveryReport = TRUE; <br>    } <br>    else <br>    { <br>        fNeedDeliveryReport = FALSE; <br>    } <br> <br>    // Create the header that we transmit to the server. The remote host will <br>    // store this information and make it available to us when then recipients <br>    // of the message ask for a headers update on their remote mailboxes. <br>    CreateMsgHeaderTextLine (pMsgProps, szHeaderText, ft); <br> <br>    // Let the MAPI spooler do other things <br>    CheckSpoolerYield(); <br> <br>    hOpenConnect = OpenServerUploadPipe (m_szServer, <br>                                         m_UserInfo.szMailboxName, <br>                                         hMsgFile, <br>                                         szConnectInfo, <br>                                         &amp;fErrorInServer); <br>    for (ulRow=0; ulRow&lt;pRecipRows-&gt;cRows; ulRow++) <br>    { <br>        pProps = pRecipRows-&gt;aRow[ulRow].lpProps; <br> <br>        // Assume the worst. If hOpenConnect is not S_OK, the fSentSuccessfully <br>        // must be FALSE to generate NDR for each recipient. <br>        fSentSuccessfully = FALSE; <br>        if (S_OK == hOpenConnect) <br>        { <br>            if (IsValidAddress (pProps[RECIP_EMAIL_ADR].Value.LPSZ, &amp;pszServer, &amp;pszMailbox)) <br>            { <br>                // pszServer should be the same as m_szServer <br>                hUploadError = SendMsgToAccount (pszServer, <br>                                                 pszMailbox, <br>                                                 szHeaderText, <br>                                                 szConnectInfo, <br>                                                 &amp;fErrorInServer); <br>                if (!hUploadError) <br>                { <br>                    // If we got here, we assume the message has been received in the server <br>                    fSentSuccessfully = TRUE; <br>                } <br>            } <br>            else <br>            { <br>                hUploadError = MAKE_HRESULT(1, FACILITY_WIN32, ERROR_INVALID_ADDRESS); <br>            } <br>        } <br>        else <br>        { <br>            hUploadError = hOpenConnect; <br>        } <br> <br>        // Let the MAPI spooler do other things <br>        CheckSpoolerYield(); <br> <br>        // Set the PR_RESPONSIBILITY flag to indicated we have handled this <br>        // recipient (row). If the flag is not modified, MAPI will pass this <br>        // message to the next transport in the profile that knows how to <br>        // handle the address types this transport knows. <br>        // In this case WE want to be the last to handle the message. If <br>        // we fail the submission, we should tell MAPI to generate an NDR. <br>        pProps[RECIP_RESPONSIBILITY].ulPropTag = PR_RESPONSIBILITY; <br>        pProps[RECIP_RESPONSIBILITY].Value.b = TRUE; <br> <br>        // Set the report time for DR's and NDR's <br>        pProps[RECIP_REPORT_TIME].ulPropTag = PR_REPORT_TIME; <br>        pProps[RECIP_REPORT_TIME].Value.ft = ft; <br> <br>        if (!fSentSuccessfully) <br>        { <br>            // Make the spooler generate an NDR instead of DR <br>            pProps[RECIP_DELIVER_TIME].ulPropTag = PR_NULL; <br> <br>            // The Spooler will generate an NDR report and will fill in <br>            // all required properties in the StatusRecips call. The only <br>            // thing we need to do is to fill in a specific per-recipient <br>            // text description of the problem. It's good to have real <br>            // info from the transport indicating the real cause for the <br>            // failure <br>            wsprintf (szHeaderText, <br>                      TEXT("\tThe WINDS transport service failed to deliver the message to this recipient.\r\n" <br>                           "\tRecipient Address: Server: %s  Mailbox: %s. Delivery error: %#08X.  %s"), <br>                           (pszServer ? pszServer : ""), <br>                           (pszMailbox ? pszMailbox : ""), <br>                           hUploadError, <br>                      (fErrorInServer ? TEXT("The error occurred in the server host.") : <br>                                        TEXT("The error occurred in local processing."))); <br>            if (fErrorInServer &amp;&amp; hUploadError) <br>            { <br>                DWORD dwServerErrorIDS = 0; <br>                switch (hUploadError) <br>                { <br>                    case HRESULT_FROM_WIN32(ERROR_INVALID_ACCOUNT_NAME) : <br>                        dwServerErrorIDS = IDS_DELIVERY_ERROR_INVALID_ACCT; <br>                        break; <br>                    case HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER) : <br>                        dwServerErrorIDS = IDS_DELIVERY_ERROR_NO_SUCH_USER; <br>                        break; <br>                    case HRESULT_FROM_WIN32 (ERROR_HOST_UNREACHABLE) : <br>                        dwServerErrorIDS = IDS_DELIVERY_ERROR_OFFLINE_SERVER; <br>                        break; <br>                    case HRESULT_FROM_WIN32 (ERROR_INVALID_ADDRESS) : <br>                        dwServerErrorIDS = IDS_DELIVERY_ERROR_INVALID_ADDRESS; <br>                        break; <br>                    case E_OUTOFMEMORY : <br>                        dwServerErrorIDS = IDS_DELIVERY_ERROR_OUTOFMEMORY; <br>                        break; <br>                    case E_INVALIDARG : <br>                        dwServerErrorIDS = IDS_DELIVERY_ERROR_INVALID_PARAM; <br>                        break; <br>                } <br>                if (!dwServerErrorIDS &amp;&amp; FACILITY_STORAGE == HRESULT_FACILITY(hUploadError)) <br>                { <br>                    dwServerErrorIDS = IDS_DELIVERY_ERROR_ISTORAGE; <br>                } <br>                if (!dwServerErrorIDS &amp;&amp; FACILITY_WIN32 == HRESULT_FACILITY(hUploadError)) <br>                { <br>                    dwServerErrorIDS = IDS_DELIVERY_ERROR_WIN32; <br>                } <br>                if (dwServerErrorIDS) <br>                { <br>                    TCHAR szBuffer[256]; <br>                    if (LoadString (m_hInstance, dwServerErrorIDS, szBuffer, 255)) <br>                    { <br>                        lstrcat (szHeaderText, TEXT("\r\n\t")); <br>                        lstrcat (szHeaderText, szBuffer); <br>                    } <br>                } <br>            } <br>            LPTSTR pStr; <br>            hResult = gpfnAllocateMore (Cbtszsize(szHeaderText), pProps, (LPVOID *)&amp;pStr); <br>            if (SUCCEEDED(hResult)) <br>            { <br>                // Copy the formatted string and hook it into the <br>                // pre-allocated (by MAPI) column <br>                lstrcpy (pStr, szHeaderText); <br>                pProps[RECIP_REPORT_TEXT].ulPropTag = PR_REPORT_TEXT; <br>                pProps[RECIP_REPORT_TEXT].Value.LPSZ = pStr; <br>            } <br>            else <br>            { <br>                pProps[RECIP_REPORT_TEXT].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_REPORT_TEXT)); <br>                pProps[RECIP_REPORT_TEXT].Value.err = hResult; <br>                TraceResult ("CXPLogon::SendMailMessage: memory allocation failed for the NDR report string", hResult); <br>            } <br>        } <br>        else <br>        { <br>            // For delivery report, each recipient must have this property set. <br>            // Otherwise the spooler will default to generate an NDR instead. <br>            pProps[RECIP_DELIVER_TIME].ulPropTag = PR_DELIVER_TIME; <br>            pProps[RECIP_DELIVER_TIME].Value.ft = ft; <br> <br>            pProps[RECIP_REPORT_TEXT].ulPropTag = PROP_TAG (PT_ERROR, PROP_ID (PR_REPORT_TEXT)); <br>            pProps[RECIP_REPORT_TEXT].Value.err = S_OK; <br>        } <br> <br>        // Based on the result of the submission to the remote host we determine into <br>        // which address list to add this recipient <br>        LPADRLIST * ppTmpList = (fSentSuccessfully ? &amp;pAdrList : &amp;pAdrListFailed); <br>        ULONG ulTmpCount = (fSentSuccessfully ? ulCount1 : ulCount2); <br> <br>        // Does the list where this recipient goes have enough room for one more entry? <br>        // If not, resize the address list to hold QUERY_SIZE more entries. <br>        if (!(*ppTmpList) || ((*ppTmpList)-&gt;cEntries + 1 &gt; ulTmpCount)) <br>        { <br>            hResult= GrowAddressList (ppTmpList, 10, &amp;ulTmpCount); <br>            if (hResult) <br>            { <br>                goto ErrorExit; <br>            } <br>            ulCount1 = (fSentSuccessfully ? ulTmpCount : ulCount1); <br>            ulCount2 = (!fSentSuccessfully ? ulTmpCount : ulCount2); <br>        } <br> <br>        // We have room now so store the new ADRENTRY. As part of the <br>        // storage, we're going to copy the SRow pointer from the SRowSet <br>        // into the ADRENTRY. Once we've done this, we won't need the <br>        // SRowSet any more ... and the SRow will be released when <br>        // we unwind the ADRLIST <br>        (*ppTmpList)-&gt;aEntries[(*ppTmpList)-&gt;cEntries].cValues = pRecipRows-&gt;aRow[ulRow].cValues; <br>        (*ppTmpList)-&gt;aEntries[(*ppTmpList)-&gt;cEntries].rgPropVals = pRecipRows-&gt;aRow[ulRow].lpProps; <br> <br>        // Increase the number of entries in the address list <br>        (*ppTmpList)-&gt;cEntries++; <br> <br>        // Now that we are finished with this row (it is in the right <br>        // adrlist) we want to disassociate it from the rowset <br>        // so we don't delete this before we modify the recipients list <br>        pRecipRows-&gt;aRow[ulRow].lpProps = NULL; <br>        pRecipRows-&gt;aRow[ulRow].cValues = 0; <br> <br>    } <br> <br>    // Let the MAPI spooler do other things <br>    CheckSpoolerYield(); <br> <br>    // Do we have some recipients that the message arrived to? <br>    if (pAdrList) <br>    { <br>        hResult = pMsgObj-&gt;ModifyRecipients (MODRECIP_MODIFY, pAdrList); <br>        TraceResult ("CXPLogon::SendMailMessage: ModifyRecipients failed (DELIVERED)", hResult); <br>        hResult = S_OK; // We'll drop the error code from the modify recipients call <br>        if (fNeedDeliveryReport) <br>        { <br>            hResult = m_pSupObj-&gt;StatusRecips (pMsgObj, pAdrList); <br>            TraceResult ("CXPLogon::SendMailMessage: StatusRecips (DR) failed", hResult); <br>            if (!HR_FAILED(hResult)) <br>            { <br>                // If we were successful, we should null out the pointer becase MAPI released <br>                // the memory for this structure. And we should not try to release it <br>                // again in the cleanup code. <br>                pAdrList = NULL; <br>            } <br>        } <br>    } <br>    // Do we have some recipients that the message DID NOT arrived to? <br>    if (pAdrListFailed) <br>    { <br>        hResult = pMsgObj-&gt;ModifyRecipients (MODRECIP_MODIFY, pAdrListFailed); <br>        // We'll drop the error code from the modify recipients call <br>        TraceResult ("CXPLogon::SendMailMessage: ModifyRecipients failed (NON-DELIVERED)", hResult); <br> <br>        // The address list has the entries with the PR_RESPONSIBILITY set, so the <br>        // spooler will know if it has to generate NDR reports. <br>        hResult = m_pSupObj-&gt;StatusRecips (pMsgObj, pAdrListFailed); <br>        TraceResult ("CXPLogon::SendMailMessage: StatusRecips (NDR) failed", hResult); <br>        if (!HR_FAILED(hResult)) <br>        { <br>            // If we were successful, we should null out the pointer becase MAPI released <br>            // the memory for this structure. And we should not try to release it <br>            // again in the cleanup code. <br>            pAdrListFailed = NULL; <br>        } <br>    } <br> <br>ErrorExit: <br>    gpfnFreeBuffer (pProblems); <br>    gpfnFreeBuffer (pMsgProps); <br>    FreePadrlist (pAdrList); <br>    FreePadrlist (pAdrListFailed); <br> <br>    // Release used objects <br>    if (pTNEFObj) <br>    { <br>        pTNEFObj-&gt;Release(); <br>    } <br>    if (pStream) <br>    { <br>        pStream-&gt;Release(); <br>    } <br>    // Close the file if it has been opened <br>    CloseHandle (hMsgFile); <br> <br>    // Delete the message file in case the function fails before the call to CreateFile() above <br>    DeleteFile (szTmpFile); <br> <br>    // Call the sender function will NULL parameters to reset internal data buffers <br>    if (lstrlen(szConnectInfo)) <br>    { <br>        FinishUploadConnection (m_szServer, szConnectInfo); <br>    } <br> <br>    // Once we have sent all messages to the remote server(s), terminate all connections <br>    TerminateRemoteConnections(); <br> <br>    // Let the MAPI spooler do other things <br>    CheckSpoolerYield(); <br> <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::SetOutgoingProps() <br>// <br>//    Parameters <br>//      pMsgObj     Pointer to the IMessage object we are processing. <br>//      ft          FILETIME structure with the time the message is <br>//                  being delivered. <br>// <br>//    Purpose <br>//      This function checks that the sender information is on the message <br>//      so that we may get replies from the intended recipients. <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI CXPLogon::SetOutgoingProps (LPMESSAGE pMsgObj, FILETIME ft) <br>{ <br>    LPSPropValue pSender; <br>    ULONG ulValues; <br>    HRESULT hResult = pMsgObj-&gt;GetProps ((LPSPropTagArray)&amp;sptOutMsgProps, fMapiUnicode, &amp;ulValues, &amp;pSender); <br>    if (FAILED(hResult)) <br>    { <br>        TraceResult ("CXPLogon::SetOutgoingProps: Failed to get properties from the message", hResult); <br>        pSender = NULL; // So that we may recover and continue using default values <br>    } <br>    ASSERT (2 == ulValues); <br>    #define NUM_OUTGOING_PROPS  11 <br>    SPropValue spvProps[NUM_OUTGOING_PROPS] = { 0 }; <br>    ULONG i = 0; <br>    // If no sender has been stamped on the message use the identity of the transport <br>    if (!pSender || PR_SENDER_ENTRYID != pSender[0].ulPropTag) <br>    { <br>        spvProps[i].ulPropTag = PR_SENDER_NAME; <br>        spvProps[i++].Value.LPSZ = m_UserInfo.szFullName; <br> <br>        spvProps[i].ulPropTag = PR_SENDER_EMAIL_ADDRESS; <br>        spvProps[i++].Value.LPSZ = m_szAddress; <br> <br>        spvProps[i].ulPropTag = PR_SENDER_ADDRTYPE; <br>        spvProps[i++].Value.LPSZ = WINDS_ADDRESS_TYPE; <br> <br>        spvProps[i].ulPropTag = PR_SENDER_ENTRYID; <br>        spvProps[i++].Value.bin = m_pIdentityProps[XPID_EID].Value.bin; <br> <br>        spvProps[i].ulPropTag = PR_SENDER_SEARCH_KEY; <br>        spvProps[i++].Value.bin = m_pIdentityProps[XPID_SEARCH_KEY].Value.bin; <br>    } <br>    // The MS Exchange mail viewer requires these properties <br>    if (!pSender || PR_SENT_REPRESENTING_NAME != pSender[1].ulPropTag) <br>    { <br>        spvProps[i].ulPropTag = PR_SENT_REPRESENTING_NAME; <br>        spvProps[i++].Value.LPSZ = m_UserInfo.szFullName; <br>        spvProps[i].ulPropTag = PR_SENT_REPRESENTING_SEARCH_KEY; <br>        spvProps[i++].Value.bin = m_pIdentityProps[XPID_SEARCH_KEY].Value.bin; <br>        spvProps[i].ulPropTag = PR_SENT_REPRESENTING_ENTRYID; <br>        spvProps[i++].Value.bin = m_pIdentityProps[XPID_EID].Value.bin; <br>        spvProps[i].ulPropTag = PR_SENT_REPRESENTING_ADDRTYPE; <br>        spvProps[i++].Value.LPSZ = WINDS_ADDRESS_TYPE; <br>        spvProps[i].ulPropTag = PR_SENT_REPRESENTING_EMAIL_ADDRESS; <br>        spvProps[i++].Value.LPSZ = m_szAddress; <br>    } <br>    gpfnFreeBuffer (pSender); <br> <br>    // Set the time when this transport actually transmitted the message <br>    spvProps[i].ulPropTag = PR_MESSAGE_DELIVERY_TIME; <br>    spvProps[i++].Value.ft = ft; <br>    spvProps[i].ulPropTag = PR_PROVIDER_SUBMIT_TIME; <br>    spvProps[i++].Value.ft = ft; <br> <br>    ASSERT (i &lt;= NUM_OUTGOING_PROPS); <br>    hResult = pMsgObj-&gt;SetProps (i, spvProps, NULL); <br>    TraceResult ("CXPLogon::SetOutgoingProps: Failed to set properties in the message", hResult); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::SetIncomingProps() <br>// <br>//    Parameters <br>//      pMsgObj     Pointer to the IMessage object we are processing. <br>// <br>//    Purpose <br>//      This function sets the PR_SENT_REPRESENTING_xxx properties in an <br>//      incoming message if those properties aren't already in the message. <br>//      For these properties we use the values for the sender of the message. <br>//      We also walk the recipient list restricted to the address type of our <br>//      transport looking for us, the recipient of the message, s that we may <br>//      set the PR_MESSAGE_TO_xxx and PR_MESSAGE_RECIP_ME properties in <br>//      the message. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI CXPLogon::SetIncomingProps (LPMESSAGE pMsgObj, PLIST_NODE pNode) <br>{ <br>    // This is the maximum number of properties that we could set in the message <br>    #define NUM_INCOMING_PROPS      28 <br>    SPropValue spvProps[NUM_INCOMING_PROPS] =  { 0 }; <br>    ULONG ulValues, i = 0; <br>    BOOL fNameIsMissing = FALSE, fAddressIsMissing = FALSE; <br>    TCHAR szUnknown[] = TEXT("Unknown"), szAddress[128]; <br>    TCHAR szUnknownAddress[] = TEXT("\\\\Unknown\\Unknown"), szSender[MAX_STRING_SIZE+1]; <br>    LPTSTR pszAlias, pszServer; <br>    LPSPropValue pProps = NULL, pSenderSKEY = NULL, pSenderEID = NULL, pObjProps = NULL; <br>    LPVOID lpToBeFreed = NULL; <br> <br>    HRESULT hResult = pMsgObj-&gt;GetProps ((LPSPropTagArray)&amp;sptNewMsgProps, fMapiUnicode, &amp;ulValues, &amp;pProps); <br>    if (FAILED(hResult)) <br>    { <br>        TraceResult ("CXPLogon::SetIncomingProps: Failed to get the message changes", hResult); <br>        goto RecoverAndContinue; <br>    } <br>    hResult = S_OK; // Get rid of any warnings <br>    // These properties should ALWAYS be in an incoming message, but just in case, we have a backup plan. <br>    if ((PR_SENDER_NAME != pProps[NEW_SENDER_NAME].ulPropTag || <br>        PR_SENDER_EMAIL_ADDRESS != pProps[NEW_SENDER_EMAIL].ulPropTag) &amp;&amp; !pNode-&gt;fRetry) <br>    { <br>        pNode-&gt;fRetry = TRUE; <br>        m_List.ReQueueNode (pNode); <br>        gpfnFreeBuffer (pProps); <br>        return MAPI_E_CORRUPT_DATA; <br>    } <br> <br>    if (PR_SENDER_NAME != pProps[NEW_SENDER_NAME].ulPropTag) <br>    { <br>        fNameIsMissing = TRUE; <br>        pProps[NEW_SENDER_NAME].ulPropTag = PR_SENDER_NAME; <br>        if (PR_SENDER_EMAIL_ADDRESS == pProps[NEW_SENDER_EMAIL].ulPropTag) <br>        { <br>            // Decompose the address and get the alias. At least this is better that UNKNOWN! <br>            lstrcpy (szAddress, pProps[NEW_SENDER_EMAIL].Value.LPSZ); <br>            DecomposeAddress (szAddress, &amp;pszServer, &amp;pszAlias); <br>            lstrcpy (szSender, pszAlias); <br>            pProps[NEW_SENDER_NAME].Value.LPSZ = szSender; <br>        } <br>        else <br>        { <br>            // This is the best we can do. <br>            pProps[NEW_SENDER_NAME].Value.LPSZ = szUnknown; <br>        } <br>    } <br>    if (PR_SENDER_EMAIL_ADDRESS != pProps[NEW_SENDER_EMAIL].ulPropTag) <br>    { <br>        pProps[NEW_SENDER_EMAIL].ulPropTag = PR_SENDER_EMAIL_ADDRESS; <br>        pProps[NEW_SENDER_EMAIL].Value.LPSZ = szUnknownAddress; <br>        fAddressIsMissing = TRUE; <br>    } <br>    spvProps[i].ulPropTag = PR_SENDER_ADDRTYPE; <br>    spvProps[i++].Value.LPSZ = WINDS_ADDRESS_TYPE; <br>    spvProps[i].ulPropTag = PR_SENT_REPRESENTING_ADDRTYPE; <br>    spvProps[i++].Value.LPSZ = WINDS_ADDRESS_TYPE; <br> <br>    // Looks like ABWDS is around, mark the internal flag. <br>    // ABWDS is the native WINDS address book service provider. If present, <br>    // instead of creating a one-off entry for the sender, we <br>    // will simply open the entry in the WINDS address book and get the <br>    // necessary properties out from it. <br>    // Note that in other to open an entry in the ABWDS address book provider <br>    // we need to have at least the email address of the sender, otherwise we <br>    // will default to create one-off entries in the sender (and delagate sender) <br>    if (m_fABWDSInstalled &amp;&amp; !fAddressIsMissing) <br>    { <br>        PRIVATE_XP_ENTRYID eidEntry = { 0 }; <br>        eidEntry.uidGlobal = guidXPABEntries; <br>        eidEntry.uidWINDSEntries = guidABEntries; <br>        // Decompose the address and get the alias. <br>        DecomposeAddress (pProps[NEW_SENDER_EMAIL].Value.LPSZ, &amp;pszServer, &amp;pszAlias); <br>        lstrcpy (eidEntry.szObjectAlias, pszAlias); <br>        // Put the Email address back to what it was <br>        RecomposeAddress (pszServer, pszAlias, pProps[NEW_SENDER_EMAIL].Value.LPSZ); <br>        LPMAILUSER pUser = NULL; <br>        ULONG ulObjType; <br>        const static SizedSPropTagArray (3, sptWINDSObjProps) = <br>        { <br>            3, <br>            { <br>                PR_DISPLAY_NAME, <br>                PR_SEARCH_KEY, <br>                PR_ENTRYID <br>            } <br>        }; <br> <br>        HRESULT hTmpResult = m_pSupObj-&gt;OpenEntry (CB_PRIVATE_XP_EID, <br>                                                   (LPENTRYID)&amp;eidEntry, <br>                                                   NULL, <br>                                                   0, <br>                                                   &amp;ulObjType, <br>                                                   (LPUNKNOWN *)&amp;pUser); <br>        if (!hTmpResult) <br>        { <br>            hTmpResult = pUser-&gt;GetProps ((LPSPropTagArray)&amp;sptWINDSObjProps, <br>                                          fMapiUnicode, <br>                                          &amp;ulValues, <br>                                          &amp;pObjProps); <br>            if (SUCCEEDED(hTmpResult)) // We might get warnings <br>            { <br>                if (PR_DISPLAY_NAME == pObjProps[0].ulPropTag &amp;&amp; <br>                    PR_SEARCH_KEY == pObjProps[1].ulPropTag &amp;&amp; <br>                    PR_ENTRYID == pObjProps[2].ulPropTag) <br>                { <br>                    if (fNameIsMissing) <br>                    { <br>                        spvProps[i].ulPropTag = PR_SENDER_NAME; <br>                        spvProps[i++].Value.LPSZ = pObjProps[0].Value.LPSZ; <br>                    } <br>                    spvProps[i].ulPropTag = PR_SENDER_SEARCH_KEY; <br>                    spvProps[i++].Value.bin = pObjProps[1].Value.bin; <br>                    spvProps[i].ulPropTag = PR_ENTRYID; <br>                    spvProps[i++].Value.bin = pObjProps[2].Value.bin; <br>                    if (PR_SENT_REPRESENTING_NAME != pProps[NEW_SENT_NAME].ulPropTag &amp;&amp; <br>                        PR_SENT_REPRESENTING_EMAIL_ADDRESS != pProps[NEW_SENT_EMAIL].ulPropTag) <br>                    { <br>                        // If the message doesn't have PR_SENT_REPRESENTING_xxx use the sender <br>                        // properties for the delagate sender properties <br>                        spvProps[i].ulPropTag    = PR_SENT_REPRESENTING_NAME; <br>                        spvProps[i++].Value.LPSZ = pObjProps[0].Value.LPSZ; <br>                        spvProps[i].ulPropTag    = PR_SENT_REPRESENTING_SEARCH_KEY; <br>                        spvProps[i++].Value.bin  = pObjProps[1].Value.bin; </code></pre>
<p>
</p>
<pre><code>spvProps[i].ulPropTag    = PR_SENT_REPRESENTING_ENTRYID; <br>                        spvProps[i++].Value.bin  = pObjProps[2].Value.bin; <br>                        spvProps[i].ulPropTag    = PR_SENT_REPRESENTING_ADDRTYPE; <br>                        spvProps[i++].Value.LPSZ = WINDS_ADDRESS_TYPE; <br>                        spvProps[i].ulPropTag    = PR_SENT_REPRESENTING_EMAIL_ADDRESS; <br>                        spvProps[i++].Value.LPSZ = pProps[NEW_SENDER_EMAIL].Value.LPSZ; <br>                    } <br>                } <br>                else <br>                { <br>                    // We couldn't find the properties needed from the WINDS <br>                    // address book entry. Continue with one-off entries <br>                    hTmpResult = MAPI_W_ERRORS_RETURNED; <br>                } <br>            } <br>            pUser-&gt;Release(); <br>        } <br>        if (S_OK == hTmpResult) <br>        { <br>            goto ContinueAddingProps; <br>        } <br>    } <br> <br>    // We need to make a search key for this recipient. <br>    spvProps[i].ulPropTag = PR_SENDER_SEARCH_KEY; <br>    hResult = MakeSearchKey (pProps, <br>                             pProps[NEW_SENDER_EMAIL].Value.LPSZ, <br>                             &amp;spvProps[i].Value.bin.cb, <br>                             &amp;spvProps[i].Value.bin.lpb); <br>    if (!hResult) <br>    { <br>        pSenderSKEY = &amp;spvProps[i]; <br>        i++; <br>        // We need to create a one-off entry in the address book so that we may <br>        // reply to this recipient. If the recipient already exist, its <br>        // entry Id will be returned instead. <br>        spvProps[i].ulPropTag = PR_SENDER_ENTRYID; <br> <br>        //else <br>        { <br>            hResult = m_pSupObj-&gt;CreateOneOff (pProps[NEW_SENDER_NAME].Value.LPSZ, <br>                                               WINDS_ADDRESS_TYPE, <br>                                               pProps[NEW_SENDER_EMAIL].Value.LPSZ, <br>                                               fMapiUnicode, <br>                                               &amp;spvProps[i].Value.bin.cb, <br>                                               (LPENTRYID *)&amp;spvProps[i].Value.bin.lpb); <br>        } <br>        if (hResult) <br>        { <br>            i--; // Ignore this property and the previous <br>        } <br>        else <br>        { <br>            pSenderEID = &amp;spvProps[i]; <br>            i++; <br>        } <br>    } <br>    TraceResult ("CXPLogon::SetIncomingProps: Failed to create a one-off for the sender", hResult); <br> <br>    if (PR_SENT_REPRESENTING_NAME == pProps[NEW_SENT_NAME].ulPropTag &amp;&amp; <br>        PR_SENT_REPRESENTING_EMAIL_ADDRESS == pProps[NEW_SENT_EMAIL].ulPropTag) <br>    { <br>        spvProps[i].ulPropTag = PR_SENT_REPRESENTING_SEARCH_KEY; <br>        hResult = MakeSearchKey (pProps, <br>                                 pProps[NEW_SENT_EMAIL].Value.LPSZ, <br>                                 &amp;spvProps[i].Value.bin.cb, <br>                                 &amp;spvProps[i].Value.bin.lpb); <br>        if (!hResult) <br>        { <br>            i++; <br>            spvProps[i].ulPropTag = PR_SENT_REPRESENTING_ENTRYID; <br>            hResult = m_pSupObj-&gt;CreateOneOff (pProps[NEW_SENT_NAME].Value.LPSZ, <br>                                               WINDS_ADDRESS_TYPE, <br>                                               pProps[NEW_SENT_EMAIL].Value.LPSZ, <br>                                               fMapiUnicode, <br>                                               &amp;spvProps[i].Value.bin.cb, <br>                                               (LPENTRYID *)&amp;spvProps[i].Value.bin.lpb); <br>            if (hResult) <br>            { <br>                i--; // Ignore this property and the previous <br>            } <br>            else <br>            { <br>                lpToBeFreed = spvProps[i].Value.bin.lpb; <br>                i++; <br>            } <br>        } <br>        // We trace the error but is not fatal <br>        TraceResult ("CXPLogon::SetIncomingProps: Failed to create a oneoff for the delegated sender", hResult); <br>    } <br>    else <br>    { <br>        // If the message doesn't have PR_SENT_REPRESENTING_xxx properties AND we were <br>        // successful at creating the one-off for the sender, we set PR_SENT_REPRESENTING_xxx <br>        // to the same values as PR_SENDER_xxx <br>        if (!hResult) <br>        { <br>            spvProps[i].ulPropTag       = PR_SENT_REPRESENTING_NAME; <br>            spvProps[i++].Value.LPSZ    = pProps[NEW_SENDER_NAME].Value.LPSZ; <br>            spvProps[i].ulPropTag       = PR_SENT_REPRESENTING_ADDRTYPE; <br>            spvProps[i++].Value.LPSZ    = WINDS_ADDRESS_TYPE; <br>            spvProps[i].ulPropTag       = PR_SENT_REPRESENTING_EMAIL_ADDRESS; <br>            spvProps[i++].Value.LPSZ    = pProps[NEW_SENDER_EMAIL].Value.LPSZ; <br> <br>            ASSERT (PR_SENDER_ENTRYID == pSenderEID-&gt;ulPropTag); <br>            spvProps[i].ulPropTag       = PR_SENT_REPRESENTING_ENTRYID; <br>            spvProps[i++].Value         = pSenderEID-&gt;Value; <br> <br>            ASSERT (PR_SENDER_SEARCH_KEY == pSenderSKEY-&gt;ulPropTag); <br>            spvProps[i].ulPropTag       = PR_SENT_REPRESENTING_SEARCH_KEY; <br>            spvProps[i++].Value         = pSenderSKEY-&gt;Value; <br>        } <br>    } <br> <br>ContinueAddingProps: <br>    // If the sender's address is the same as our address (the recipient), then the message <br>    // was sent from us, to ourselves, therefore we must set the flag bit in the message. <br>    if (0 == lstrcmpi (pProps[NEW_SENDER_EMAIL].Value.LPSZ, m_szAddress)) <br>    { <br>        ASSERT (PR_MESSAGE_FLAGS == pProps[NEW_MSG_FLAGS].ulPropTag); <br>        spvProps[i].ulPropTag = PR_MESSAGE_FLAGS; <br>        spvProps[i++].Value.l = pProps[NEW_MSG_FLAGS].Value.l | MSGFLAG_FROMME; <br>    } <br> <br>RecoverAndContinue: <br>    // We must stamp the message with this properties since we (this transport) <br>    // were the ones who processed the incoming message. <br>    spvProps[i].ulPropTag       = PR_RECEIVED_BY_ENTRYID; <br>    spvProps[i++].Value.bin     = m_pIdentityProps[XPID_EID].Value.bin; <br>    spvProps[i].ulPropTag       = PR_RECEIVED_BY_NAME; <br>    spvProps[i++].Value.LPSZ    = m_pIdentityProps[XPID_NAME].Value.LPSZ; <br>    spvProps[i].ulPropTag       = PR_RECEIVED_BY_SEARCH_KEY; <br>    spvProps[i++].Value.bin     = m_pIdentityProps[XPID_SEARCH_KEY].Value.bin; <br>    spvProps[i].ulPropTag       = PR_RECEIVED_BY_ADDRTYPE; <br>    spvProps[i++].Value.LPSZ    = WINDS_ADDRESS_TYPE; <br>    spvProps[i].ulPropTag       = PR_RECEIVED_BY_EMAIL_ADDRESS; <br>    spvProps[i++].Value.LPSZ    = m_szAddress; <br> <br>    // In this transport we set PR_RCVD_xxx with the values of PR_RECEIVED_xxx <br>    spvProps[i].ulPropTag       = PR_RCVD_REPRESENTING_ENTRYID; <br>    spvProps[i++].Value.bin     = m_pIdentityProps[XPID_EID].Value.bin; <br>    spvProps[i].ulPropTag       = PR_RCVD_REPRESENTING_NAME; <br>    spvProps[i++].Value.LPSZ    = m_pIdentityProps[XPID_NAME].Value.LPSZ; <br>    spvProps[i].ulPropTag       = PR_RCVD_REPRESENTING_SEARCH_KEY; <br>    spvProps[i++].Value.bin     = m_pIdentityProps[XPID_SEARCH_KEY].Value.bin; <br>    spvProps[i].ulPropTag       = PR_RCVD_REPRESENTING_ADDRTYPE; <br>    spvProps[i++].Value.LPSZ    = WINDS_ADDRESS_TYPE; <br>    spvProps[i].ulPropTag       = PR_RCVD_REPRESENTING_EMAIL_ADDRESS; <br>    spvProps[i++].Value.LPSZ    = m_szAddress; <br> <br>    SYSTEMTIME st; <br>    FILETIME ftTime; <br>    GetSystemTime (&amp;st); <br>    SystemTimeToFileTime (&amp;st, &amp;ftTime); <br>    spvProps[i].ulPropTag = PR_MESSAGE_DOWNLOAD_TIME; <br>    spvProps[i++].Value.ft = ftTime; <br> <br>    LPMAPITABLE pTable; <br>    LPSRowSet pRows; <br>    BOOL fFoundCC, fFoundTO; <br>    fFoundCC = fFoundTO = FALSE; <br>    LPSPropValue pRecip; <br>    SPropValue spvFilter = { 0 }; <br>    spvFilter.ulPropTag = PR_ADDRTYPE; <br>    spvFilter.Value.LPSZ = WINDS_ADDRESS_TYPE; <br> <br>    SRestriction srRecips = { 0 }; <br>    srRecips.rt = RES_PROPERTY; <br>    srRecips.res.resProperty.relop = RELOP_EQ; <br>    srRecips.res.resProperty.ulPropTag = PR_ADDRTYPE; <br>    srRecips.res.resProperty.lpProp = &amp;spvFilter; <br> <br>    hResult = pMsgObj-&gt;GetRecipientTable (fMapiUnicode, &amp;pTable); <br>    if (!hResult) <br>    { <br>        hResult = HrQueryAllRows (pTable, <br>                                  (LPSPropTagArray)&amp;sptMsgRecipProps, <br>                                  &amp;srRecips, <br>                                  NULL, <br>                                  0, <br>                                  &amp;pRows); <br>        if (!hResult) <br>        { <br>            ASSERTMSG (pRows-&gt;cRows &gt; 0, "Huh?, Zero rows?"); <br>            for (ULONG ulIndex=0; ulIndex&lt;pRows-&gt;cRows; ulIndex++) <br>            { <br>                pRecip = pRows-&gt;aRow[ulIndex].lpProps; <br>                ASSERTMSG (PR_EMAIL_ADDRESS == pRecip[0].ulPropTag, "Where is the PR_EMAIL_ADDRESS?"); <br>                ASSERTMSG (PR_RECIPIENT_TYPE == pRecip[1].ulPropTag, , "Where is the PR_RECIPIENT_TYPE?"); <br>                if (PR_EMAIL_ADDRESS == pRecip[0].ulPropTag) <br>                { <br>                    // We use the address for the comparison because the sender might <br>                    // have create a one-off to send us this message and the only thing that this <br>                    // transport can count on being the same across all computers <br>                    // is the email address. The display name is modifyable by the user. <br>                    if (0 == lstrcmpi (pRecip[0].Value.LPSZ, m_szAddress)) <br>                    { <br>                        if (PR_RECIPIENT_TYPE == pRecip[1].ulPropTag) <br>                        { <br>                            if (MAPI_TO == pRecip[1].Value.l) <br>                            { <br>                                fFoundTO = TRUE; <br>                            } <br>                            else <br>                            { <br>                                if (MAPI_CC == pRecip[1].Value.l) <br>                                { <br>                                    fFoundCC = TRUE; <br>                                } <br>                            } <br>                        } <br>                    } <br>                } <br>            } <br>            FreeProws (pRows); <br>        } <br>        pTable-&gt;Release(); <br>    } <br>    TraceResult ("CXPLogon::SetIncomingProps: Something went wrong setting PR_MESSAGE_xxx", hResult); <br> <br>    if (!hResult) <br>    { <br>        spvProps[i].ulPropTag = PR_MESSAGE_TO_ME; <br>        spvProps[i++].Value.b = fFoundTO; <br> <br>        spvProps[i].ulPropTag = PR_MESSAGE_CC_ME; <br>        spvProps[i++].Value.b = fFoundCC; <br> <br>        spvProps[i].ulPropTag = PR_MESSAGE_RECIP_ME; <br>        spvProps[i++].Value.b = fFoundTO || fFoundCC; <br>    } <br>    ASSERT (i &lt;= NUM_INCOMING_PROPS); <br>    hResult = pMsgObj-&gt;SetProps (i, spvProps, NULL); <br>    TraceResult ("CXPLogon::SetIncomingProps: Failed to set properties in the message", hResult); <br>    gpfnFreeBuffer(lpToBeFreed); <br>    if(pSenderEID) <br>        gpfnFreeBuffer(pSenderEID-&gt;Value.bin.lpb); <br>    gpfnFreeBuffer (pProps); <br>    gpfnFreeBuffer (pObjProps); <br>    return S_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::GetMsgTempFileName() <br>// <br>//    Parameters <br>//      pszFileName     Pointer to a buffer allocated by the caller where the <br>//                      function returns a fully qualified path and file for <br>//                      a uniquely named temporary file. <br>// <br>//    Purpose <br>//      This function creates a temporary file name. The file name will be <br>//      returned in the pszFileName buffer which must have been allocated by <br>//      the caller. The file will have a fully qualified path to its location. <br>//      The location of the file is on the TEMP directory, as set in the system, <br>//      and within it, in the directory for the downloads of the WINDS <br>//      message transport <br>// <br>//    Return Value <br>//      TRUE if the function is successful at creating a temporary <br>//      unique file name. FALSE otherwise. <br>// <br>BOOL WINAPI CXPLogon::GetMsgTempFileName (LPTSTR pszFileName) <br>{ <br>    TCHAR szTmpDir[_MAX_PATH], szDownloadDir[_MAX_PATH]; <br>    // Ask the system for the TEMP directory <br>    DWORD dwChars = GetTempPath (_MAX_PATH, szTmpDir); <br>    if (dwChars) <br>    { <br>        lstrcat (szTmpDir, WINDS_DATA_DIRECTORY); <br>        wsprintf (szDownloadDir, WINDS_DOWNLOAD_DIR_NAME_FORMAT, szTmpDir, m_UserInfo.szMailboxName); <br>        dwChars = ::GetTempFileName (szDownloadDir,         // Call the Win32 API <br>                                     XP_MSG_FILE_PREFIX,    // Our transport's fixed prefix for temp files <br>                                     0,                     // Use the time to create a pseudo-random number <br>                                     pszFileName);          // Destination buffer <br>    } <br>    if (!dwChars) <br>    { <br>        TraceResult ("CXPLogon::GetMsgTempFileName: Failed to get temp path or file name", GetLastError()); <br>    } <br>    return (0 != dwChars ? TRUE : FALSE); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::CreateMsgHeaderTextLine() <br>// <br>//    Parameters <br>//      pProps              Array of properties of the message being <br>//                          submitted where we get the information to create a <br>//                          message header string to send to the server <br>//      pszBuffer           Buffer where the function copies the formated data <br>//                          for the server message header string <br>//      time                Reference to a FILETIME structure with the time <br>//                          the transport is delivering the message. <br>// <br>//    Purpose <br>//      This function creates a string with the data needed in the server <br>//      side to update the remote server mailboxes message header file of <br>//      the recipients. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CXPLogon::CreateMsgHeaderTextLine (LPSPropValue     pProps, <br>                                               LPTSTR           pszBuffer, <br>                                               FILETIME &amp;       time) <br>{ <br>    // In case we don't find the properties in the array, we need <br>    // to supply default values for the strings. This method <br>    // should never fail. <br>    LPTSTR pszSubject = TEXT("&lt;Subject Not Found&gt;"); <br>    LPTSTR pszMsgClass = TEXT("IPM.Note"); <br>    TCHAR szDisplayTo[256] = { 0 }; <br> <br>    // In case we don't have the expected properties, assign default values. <br>    long lMsgFlags = 0; <br>    if (PR_MESSAGE_FLAGS == pProps[MSG_FLAGS].ulPropTag) <br>    { <br>        // Filter out the flags to only allow the ones listed <br>        lMsgFlags = pProps[MSG_FLAGS].Value.l &amp; (MSGFLAG_UNMODIFIED | <br>                                                 MSGFLAG_HASATTACH | <br>                                                 MSGFLAG_FROMME | <br>                                                 MSGFLAG_RESEND); <br>    } <br>    if (pProps[MSG_SIZE].ulPropTag != PR_MESSAGE_SIZE) <br>    { <br>        pProps[MSG_SIZE].Value.l = 1024; // Default to 1Kb <br>    } <br>    if (pProps[MSG_PRIORITY].ulPropTag != PR_PRIORITY) <br>    { <br>        pProps[MSG_PRIORITY].Value.l = PRIO_NORMAL; <br>    } <br>    if (pProps[MSG_IMPORTANCE].ulPropTag != PR_IMPORTANCE) <br>    { <br>        pProps[MSG_IMPORTANCE].Value.l = IMPORTANCE_NORMAL; <br>    } <br>    if (pProps[MSG_SENSITIVITY].ulPropTag != PR_SENSITIVITY) <br>    { <br>        pProps[MSG_SENSITIVITY].Value.l = SENSITIVITY_NONE; <br>    } <br> <br>    // Get the string of TO recipients. If the string is too long, set the elipsis at the end of the buffer <br>    if (pProps[MSG_DISP_TO].ulPropTag == PR_DISPLAY_TO) <br>    { <br>        LPTSTR pszDisplayTo = pProps[MSG_DISP_TO].Value.LPSZ; <br>        if (lstrlen (pszDisplayTo) &gt; 256) <br>        { <br>            pszDisplayTo[252] = '.'; // Copy the elipsis for a long string <br>            pszDisplayTo[253] = '.'; <br>            pszDisplayTo[254] = '.'; <br>            pszDisplayTo[255] = 0; <br>        } <br>        LPTSTR pszOneName = strtok (pszDisplayTo, ";"); <br>        if (pszOneName) <br>        { <br>            pszOneName[lstrlen(pszOneName) - 1] = 0; <br>            lstrcpy (szDisplayTo, &amp;pszOneName[1]); <br>        } <br>        while (pszOneName) <br>        { <br>            pszOneName = strtok (NULL, ";"); <br>            if (pszOneName) <br>            { <br>                pszOneName[0] = TEXT(';'); <br>                pszOneName[1] = TEXT(' '); <br>                pszOneName[lstrlen(pszOneName) - 1] = 0; <br>                lstrcat (szDisplayTo, pszOneName); <br>            } <br>        } <br>    } <br>    if (0 == szDisplayTo[0]) <br>    { <br>        lstrcpy (szDisplayTo, TEXT("&lt;Display To Names Not Found&gt;")); <br>    } <br>    // Get the message class string. <br>    if (pProps[MSG_CLASS].ulPropTag == PR_MESSAGE_CLASS) <br>    { <br>        pszMsgClass = pProps[MSG_CLASS].Value.LPSZ; <br>    } <br>    // Get the subject. If the string is too long, set the elipsis at the end of the buffer <br>    if (pProps[MSG_SUBJECT].ulPropTag == PR_SUBJECT) <br>    { <br>        pszSubject = pProps[MSG_SUBJECT].Value.LPSZ; <br>        if (lstrlen (pszSubject) &gt; 256) <br>        { <br>            pszSubject[252] = '.'; // Copy the elipsis for a long string <br>            pszSubject[253] = '.'; <br>            pszSubject[254] = '.'; <br>            pszSubject[255] = 0; <br>        } <br>    } <br>    // Write the properties into the buffer. This buffer is the header <br>    // information we send to the server The buffer passed in must hold <br>    // at least 1024 characters <br>    wsprintf (pszBuffer, <br>              // The string must end with a ',' (for the parsing logic <br>              // in the downloading of the headers) <br>              TEXT("%d,%s,%d,%s,%d,%s,%s,%d,%d,%d,%d,%d,%d,%d,"), <br>              lstrlen(m_UserInfo.szFullName), <br>              m_UserInfo.szFullName, <br>              lstrlen(szDisplayTo), <br>              szDisplayTo, <br>              lstrlen(pszSubject), <br>              pszSubject, <br>              pszMsgClass, <br>              lMsgFlags, <br>              pProps[MSG_SIZE].Value.l, <br>              pProps[MSG_PRIORITY].Value.l, <br>              pProps[MSG_IMPORTANCE].Value.l, <br>              pProps[MSG_SENSITIVITY].Value.l, <br>              time.dwLowDateTime, <br>              time.dwHighDateTime); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::IsValidAddress() <br>// <br>//    Parameters <br>//      pszAddress      The address of the recipient. This string gets <br>//                      decomposed locally, so it can't be re-used by <br>//                      the caller. <br>//      ppszServer      Pointer to a location where the function returns <br>//                      the remote server name <br>//      ppszMailbox     Pointer to a location where the function returns <br>//                      the remote user mailbox name <br>// <br>//    Purpose <br>//      This functions takes the address of a recipient and makes sure it is <br>//      valid (as far as syntax) and decomposes the address into two <br>//      components: Remote server name and Remote user mailbox name. The <br>//      two component strings are returned to the caller. <br>// <br>//    Return Value <br>//      TRUE if the address of the recipient is valid. FALSE otherwise. <br>// <br>BOOL WINAPI CXPLogon::IsValidAddress (LPTSTR        pszAddress, <br>                                      LPTSTR *      ppszServer, <br>                                      LPTSTR *      ppszMailbox) <br>{ <br>    // Make sure that we can read the string <br>    if (!pszAddress || IsBadStringPtr (pszAddress, 32)) <br>    { <br>        TraceMessage ("CXPLogon::IsValidAddress: Invalid string pointer"); <br>        return FALSE; <br>    } <br>    DecomposeAddress (pszAddress, ppszServer, ppszMailbox); <br>    // Validate the names of the server and the mailbox <br>    if (!IsValidServerName (*ppszServer) || !*ppszMailbox) <br>    { <br>        TraceMessage ("CXPLogon::IsValidAddress: Invalid address for remote server host"); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::GrowAddressList() <br>// <br>//    Parameters <br>//      ppAdrList           Pointer to an address where the old address list <br>//                          is and where the new resized address list will <br>//                          be returned <br>//      ulResizeBy          Number of new address entries to add to the list <br>//      pulOldAndNewCount   Number of entries in the old address list. In <br>//                          this parameter, upon sucessful return, will have <br>//                          the number of in the new address list <br>// <br>//    Purpose <br>//      In this function, given an address list with pulOldAndNewCount of <br>//      entries, we resize the address list to hold the old number of <br>//      entries plus the ulResizeBy entries. The old address list contents <br>//      are copied to the new list and the count reset. The memory for the <br>//      old address list is released here. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::GrowAddressList (LPADRLIST *   ppAdrList, <br>                                        ULONG         ulResizeBy, <br>                                        ULONG *       pulOldAndNewCount) <br>{ <br>    LPADRLIST pNewAdrList; <br>    // Calculate how big the new buffer for the expanded address list should be <br>    ULONG cbSize = CbNewADRLIST ((*pulOldAndNewCount) + ulResizeBy); <br>    // Allocate the memory for it <br>    HRESULT hResult = gpfnAllocateBuffer (cbSize, (LPVOID *)&amp;pNewAdrList); <br>    if (hResult) <br>    { <br>        // We can't continue <br>        TraceResult ("CXPLogon::GrowAddressList: Failed to allocate memory for resized address list", hResult); <br>        return hResult; <br>    } <br> <br>    // Zero-out all memory for neatness <br>    ZeroMemory (pNewAdrList, cbSize); <br> <br>    // If we had entries in the old address list, copy the memory from <br>    // the old addres list into the new expanded list <br>    if ((*pulOldAndNewCount)) <br>    { <br>        CopyMemory (pNewAdrList, *ppAdrList, CbNewADRLIST ((*pulOldAndNewCount))); <br>    } <br> <br>    // Set the number of entries in the new address list to the OLD size <br>    pNewAdrList-&gt;cEntries = (*pulOldAndNewCount); <br> <br>    // We must return the number of available entries in the new expanded address list <br>    (*pulOldAndNewCount) += ulResizeBy; <br> <br>    // Free the old memory and put the new pointer in place <br>    gpfnFreeBuffer (*ppAdrList); <br>    *ppAdrList = pNewAdrList; <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::CheckSpoolerYield() <br>// <br>//    Parameters <br>//      fReset      Resets the pseudo-timer <br>// <br>//    Purpose <br>//      Enforce the 0.2 second rule for transport that need to yield to the <br>//      MAPI spooler.  Called periodically while processing a message to <br>//      determine if we have used more than 0.2 seconds.  If so, then call <br>//      SpoolerYield(), else just continue. <br>//      This is called with fReset set to TRUE when we first enter one <br>//      of the Transport Logon methods (usually one that is known to <br>//      take a long time like StartMessage() or SubmitMessage(). ) <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI CXPLogon::CheckSpoolerYield (BOOL fReset) <br>{ <br>    DWORD dwStop; <br>    static DWORD dwStart; <br>    if (fReset) <br>    { <br>        dwStart = GetTickCount(); <br>    } <br>    else <br>    { <br>        dwStop = GetTickCount(); <br>        if ((dwStop - dwStart) &gt; 200) // 200 milliseconds <br>        { <br>            m_pSupObj-&gt;SpoolerYield (0); <br>            dwStart = GetTickCount(); <br>        } <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::InitializeStatusRow() <br>// <br>//    Parameters <br>//      ulFlags     0 if the properties are being created the first time. <br>//                  MODIFY_FLAGS if a change is being made to the properties <br>// <br>//    Purpose <br>//      To initialize or modify the status properties of a CXPLogon <br>//      object. This function allocates an array with NUM_STATUS_ROW_PROPS <br>//      properties and initializes them. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::InitializeStatusRow (ULONG ulFlags) <br>{ <br>    #define NUM_STATUS_ROW_PROPS    10 <br>    SPropValue spvStatusRow[NUM_STATUS_ROW_PROPS] = { 0 }; <br>    ULONG i = 0; <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_PROVIDER_DISPLAY property: The transport readable name <br>    spvStatusRow[i].ulPropTag = PR_PROVIDER_DISPLAY; <br>    spvStatusRow[i++].Value.LPSZ = TRANSPORT_DISPLAY_NAME_STRING; <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_RESOURCE_METHODS property. These are the methods implemented <br>    // in the our IMAPIStatus implementation (CMAPIStatus class.) <br>    spvStatusRow[i].ulPropTag = PR_RESOURCE_METHODS; <br>    // we support ALL the methods in our implementation of IMAPIStatus interface (except the WRITABLE ones) <br>    spvStatusRow[i++].Value.l = STATUS_SETTINGS_DIALOG | <br>                                STATUS_FLUSH_QUEUES | <br>                                STATUS_VALIDATE_STATE | <br>                                STATUS_CHANGE_PASSWORD; <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_STATUS_CODE property. <br>    spvStatusRow[i].ulPropTag = PR_STATUS_CODE; <br>    spvStatusRow[i++].Value.l = GetTransportStatusCode(); <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_STATUS_STRING property <br>    TCHAR szStatus[64]; <br>    LoadStatusString (szStatus, sizeof(szStatus)); <br>    spvStatusRow[i].ulPropTag = PR_STATUS_STRING; <br>    spvStatusRow[i++].Value.LPSZ = szStatus; <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_DISPLAY_NAME property <br>    TCHAR szDisplayName[64]; <br>    wsprintf (szDisplayName, TEXT("%s (%s)"), TRANSPORT_DISPLAY_NAME_STRING, m_szServer); <br>    spvStatusRow[i].ulPropTag = PR_DISPLAY_NAME; <br>    spvStatusRow[i++].Value.LPSZ = szDisplayName; <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_IDENTITY_ENTRYID property <br>    spvStatusRow[i].ulPropTag = PR_IDENTITY_ENTRYID; <br>    spvStatusRow[i++].Value = m_pIdentityProps[XPID_EID].Value; <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_IDENTITY_DISPLAY property <br>    spvStatusRow[i].ulPropTag = PR_IDENTITY_DISPLAY; <br>    spvStatusRow[i++].Value.LPSZ = m_pIdentityProps[XPID_NAME].Value.LPSZ; <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_IDENTITY_SEARCH_KEY property <br>    spvStatusRow[i].ulPropTag = PR_IDENTITY_SEARCH_KEY; <br>    spvStatusRow[i++].Value = m_pIdentityProps[XPID_SEARCH_KEY].Value; <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_REMOTE_PROGRESS property <br>    spvStatusRow[i].ulPropTag = PR_REMOTE_PROGRESS; <br>    spvStatusRow[i++].Value.l = -1; // Not initialized <br> <br>    /////////////////////////////////////////////////////////////////////////// <br>    // Set the PR_REMOTE_VALIDATE_OK property <br>    spvStatusRow[i].ulPropTag = PR_REMOTE_VALIDATE_OK; <br>    spvStatusRow[i++].Value.b = TRUE; <br>    ASSERT (NUM_STATUS_ROW_PROPS == i); <br> <br>    // Write the entries on the provider's session status row <br>    HRESULT hResult = m_pSupObj-&gt;ModifyStatusRow (i, spvStatusRow, ulFlags); <br>    TraceResult ("CXPLogon::InitializeStatusRow: Failed to modify the status row", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::CheckForUnfinishedDownloads() <br>// <br>//    Parameters <br>//      None. <br>// <br>//    Purpose <br>//      This function checks to see if we have files where downloaded messages <br>//      were lefted from a previous session or from a previous failed download <br>//      sequence. The message files, if any, should be in the data directory of <br>//      this service. If any files are found, the message queue is loaded and <br>//      the during out inbound logic initialization in <br>//      IXPLogon::TransportNotify(), we check the queue. If the queue is not <br>//      empty, we tell the transport to flush our inbound flush. <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI CXPLogon::CheckForUnfinishedDownloads() <br>{ <br>    WIN32_FIND_DATA wfdFile = { 0 }; <br>    TCHAR szTmpDir[_MAX_PATH], szDownloadDir[_MAX_PATH], szSearchMask[512]; <br>    GetTempPath (_MAX_PATH, szTmpDir); <br>    lstrcat (szTmpDir, WINDS_DATA_DIRECTORY); <br>    wsprintf (szDownloadDir, WINDS_DOWNLOAD_DIR_NAME_FORMAT, szTmpDir, m_UserInfo.szMailboxName); <br>    wsprintf (szSearchMask, TEXT("%s\\%s*.%s"), szDownloadDir, XP_MSG_FILE_PREFIX, XP_MSG_FILE_SUFFIX); <br>    HANDLE hSearch = FindFirstFile (szSearchMask, &amp;wfdFile); <br>    if (hSearch == INVALID_HANDLE_VALUE) <br>    { <br>        return; <br>    } <br>    BOOL fFound = TRUE; <br>    while (fFound) <br>    { <br>        wsprintf (szTmpDir, TEXT("%s\\%s"), szDownloadDir, wfdFile.cFileName); <br>        // If the file size of 0, then is probably some garbage file. Get rid of it. <br>        // A zero-sized file does not contains a message. <br>        if (0 == wfdFile.nFileSizeHigh &amp;&amp; 0 == wfdFile.nFileSizeLow) <br>        { <br>            DeleteFile (szTmpDir); <br>        } <br>        else <br>        { <br>            m_List.QueuePendingMsgFile (szTmpDir); <br>        } <br>        fFound = FindNextFile (hSearch, &amp;wfdFile); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::DownloadMessageHeaders() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      This function downloads the message headers for the user's mailbox and <br>//      is a remote folder is available, re-load the contents table of the <br>//      folder with the new message headers information. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>STDMETHODIMP CXPLogon::DownloadMessageHeaders() <br>{ <br>    // Guard against re-entrancy from the timer call back which happens on a separate thread <br>    UpdateProgress (0, REMOTE_ACTION_HEADER_REFRESH);     // Start the progress bar <br>    HRESULT hResult = GetHeadersFromServer (m_szServer, </code></pre>
<p>
</p>
<pre><code>m_UserInfo.szMailboxName, <br>                                            m_szHeaders); <br>    UpdateProgress (50, REMOTE_ACTION_HEADER_REFRESH);    // Half way through <br>    if (!hResult &amp;&amp; m_pStatusObj &amp;&amp; m_pStatusObj-&gt;m_pHeaderFolder) <br>    { <br>        hResult = m_pStatusObj-&gt;m_pHeaderFolder-&gt;FillContentsTable (m_szHeaders); <br>    } <br>    UpdateProgress (100, REMOTE_ACTION_HEADER_REFRESH);   // Finish <br>    TraceResult ("CXPLogon::DownloadMessageHeaders", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::EmptyInboundQueue() <br>// <br>//    Parameters <br>//      None <br>// <br>//    Purpose <br>//      Deletes all the node in the queue of downloaded messages, deleting <br>//      the used memory and closing the handle to the local temporary <br>//      message file. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CXPLogon::EmptyInboundQueue() <br>{ <br>    // If we have nodes at this point, is because the transport could not <br>    // process them at this time. They will be retrieved in the next time this <br>    // transport comes on line on the same profile or on a profile that has <br>    // the same user identity. <br>    PLIST_NODE pNode = m_List.GetDownloadNode(); <br>    while (pNode) <br>    { <br>        CloseHandle (pNode-&gt;hFile); <br>        delete pNode; <br>        // If the list is empty, pNode will be NULL. <br>        // CList::GetDownloadNode() returns NULL for an empty list. <br>        pNode = m_List.GetDownloadNode(); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    TimerWndProc() <br>// <br>//    Parameters <br>//      { Refer to Win32 documentation } <br>// <br>//    Purpose <br>//      Stub window procedure for the hidden timer window class. <br>// <br>//    Return Value <br>//      Default value return by the default window procedure <br>// <br>LRESULT CALLBACK TimerWndProc (HWND      hWnd, <br>                               UINT      message, <br>                               WPARAM    wParam, <br>                               LPARAM    lParam) <br>{ <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::InitializeTimer() <br>// <br>//    Parameters <br>//      None. <br>// <br>//    Purpose <br>//      Initialize the hidden window for the upload timer. <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI CXPLogon::InitializeTimer() <br>{ <br>    WNDCLASS wc = { 0 }; <br>    // Register the class for this application <br>    wc.lpfnWndProc      = TimerWndProc; <br>    wc.hInstance        = m_hInstance; <br>    wc.lpszClassName    = TIMER_WND_CLASS; <br>    if (!RegisterClass (&amp;wc)) <br>    { <br>        TraceResult ("InitializeTimer: Failed to register the timer window class", GetLastError()); <br>        return; <br>    } <br>    m_hTimerWnd = CreateWindow (TIMER_WND_CLASS, <br>                                NULL, <br>                                WS_OVERLAPPEDWINDOW, <br>                                0, 0, 0, 0, <br>                                NULL, <br>                                NULL, <br>                                m_hInstance, <br>                                NULL); <br>    if (NULL == m_hTimerWnd) <br>    { <br>        TraceResult ("InitializeTimer: Failed to create timer window", GetLastError()); <br>        return; <br>    } <br>    SetWindowLong (m_hTimerWnd, GWL_USERDATA, (LONG)this); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::StartUploadTimer() <br>// <br>//    Parameters <br>//      None. <br>// <br>//    Purpose <br>//      This function sets a timer with the operating system. When <br>//      the specified period elapses, we will get called in the procedure <br>//      specified and we will then flush the incoming and outgoing queues. <br>//      Note that we round the delivery time to the HOUR <br>// <br>//    Return Value <br>//      None. <br>// <br>void WINAPI CXPLogon::StartUploadTimer() <br>{ <br>    SYSTEMTIME stNow = { 0 }; <br>    GetLocalTime (&amp;stNow); <br>    WORD wUploadHour = m_stDelivTime.wHour; <br>    // If the time is 0:00, this is 12:00 AM midnight <br>    if (!wUploadHour) <br>    { <br>        wUploadHour = 24; <br>    } <br>    UINT uDelay = 0; <br>    // How many hours before the next upload? <br>    int nHours = wUploadHour - stNow.wHour; <br>    if (nHours &lt;= 0) <br>    { <br>        // If the hours is 0 and the time hasn't arrived with in this hour, <br>        // set the upload timer for THIS hour. <br>        if (0 == nHours &amp;&amp; stNow.wMinute &lt; m_stDelivTime.wMinute) <br>        { <br>            nHours = -24; <br>            uDelay += (UINT)(m_stDelivTime.wMinute - stNow.wMinute) * 60 * 1000; <br>        } <br>        nHours += 24; <br>    } <br>    uDelay += (UINT)nHours * 60 * 60 * 1000; // Number of milliseconds in the hours <br>    m_uTimerID = SetTimer (m_hTimerWnd, 0, uDelay, UploadTimerProc); <br>    if (0 == m_uTimerID) <br>    { <br>        TraceResult ("CXPLogon::StartUploadTimer: Failed to set the timer", GetLastError()); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CXPLogon::StopUploadTimer() <br>// <br>//    Parameters <br>//      None. <br>// <br>//    Purpose <br>//      Terminates the timer used for the upload time. <br>// <br>//    Return Value <br>//      None <br>// <br>void WINAPI CXPLogon::StopUploadTimer() <br>{ <br>    // If we have a timer around, terminate it and all its associated resources <br>    if (m_uTimerID) <br>    { <br>        KillTimer (m_hTimerWnd, m_uTimerID); <br>        DestroyWindow (m_hTimerWnd); <br>        UnregisterClass (TIMER_WND_CLASS, m_hInstance); <br>        m_hTimerWnd = NULL; <br>        m_uTimerID = 0; <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    UploadTimerProc() <br>// <br>//    Parameters <br>//      { Refer to the Win32 TIMERPROC callback parameters } <br>// <br>//    Purpose <br>//      This function executes when the timer delay has expired. <br>//      Now we ask the spooler to send us the deferred messages, and we set <br>//      the transport state ready to receive updated headers. <br>// <br>//    Return Value <br>//      None <br>// <br>void CALLBACK UploadTimerProc (HWND    hTimerWnd, <br>                               UINT    Message, <br>                               UINT    idEvent, <br>                               DWORD   dwTime) <br>{ <br>    KillTimer (hTimerWnd, idEvent); <br>    // We asked to get the CXPLogon object who set the timer. We now <br>    // check and see if the object is valid before we attempt to use it. <br>    CXPLogon * pLogon = (CXPLogon *)GetWindowLong (hTimerWnd, GWL_USERDATA); <br>    if (!pLogon || <br>        IsBadWritePtr (pLogon, sizeof(CXPLogon)) || <br>        IsBadReadPtr (pLogon, sizeof(CXPLogon))) <br>    { <br>        TraceMessage ("UploadTimerProc: We got a bogus logon object"); <br>        return; <br>    } <br>    pLogon-&gt;m_uTimerID = 0; <br> <br>    // If the transport's outgoing logic has been activated in this session, <br>    // send all the deferred messages, by flushing the transport. <br>    if (pLogon-&gt;GetTransportStatusCode() &amp; STATUS_OUTBOUND_ENABLED) <br>    { <br>        pLogon-&gt;AddStatusBits (UPLOADING_MESSAGES); <br>    } <br>    // If the transport's incoming logic has been activated in this session, <br>    // get any pending messages that need to be placed in the default inbox, <br>    // and set the transport state, ready to get the headers from the server.. <br>    if (pLogon-&gt;GetTransportStatusCode() &amp; STATUS_INBOUND_ENABLED) <br>    { <br>        pLogon-&gt;AddStatusBits (DOWNLOADING_MESSAGES); <br>        pLogon-&gt;SetTransportState (PROCESSING_TIMER_EVENT); <br>    } <br>    // Modify the status row now <br>    pLogon-&gt;UpdateStatus(); <br>    // Reset the time for the next upload. Uploading time is a recurring event. <br>    pLogon-&gt;StartUploadTimer(); <br>} <br> <br>// End of file for XPLOGON.CPP <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
