<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPSTREAM.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2219"></a>XPSTREAM.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  File Name <br>//      XPSTREAM.CPP  <br>// <br>//  Description <br>//      Wraps the StreamOnFile object to add buffering of the stream. <br>//      The wrappered version uses an in-memory buffer, or cache, to <br>//      reduce the number of actual Reads and Writes to the underlying <br>//      stream.  The goal is, obviously, to improve performance. <br>//      This code is not thread safe.  Also, the implementation <br>//      is not optimized for streams that both read and write continuously <br>//      because there will be too much flushing going on. <br>// <br>//  Author <br>//      Irving De la Cruz <br>// <br>//  Note: This file is the C++ version of the buffered IStream wrapper <br>//        developed originally for the C-based MSPEER transport in <br>//        the MAPI SDK samples. <br>// <br>//  Revision: 1.7 <br>// <br>// Written for Microsoft Windows Developer Support <br>// Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved. <br>// <br>#include "XPSTREAM.H" <br>#include "TRACES.H" <br>#include "COMWINDS.H" <br> <br> <br>CCachedStream::CCachedStream (LPSTREAM pImpStream, ULONG ulFlags) <br>{ <br>    m_cRef = 1; <br>    m_fDirty = FALSE; <br>    m_ulFlags = ulFlags; <br>    m_libBuff = 0; <br>    m_cbBuffMac = 0; <br>    m_pvCache = HeapAlloc (GetProcessHeap(), 0, XPSOF_BUFF_MAX); <br>    if (NULL == m_pvCache) <br>    { <br>        throw CException (E_OUTOFMEMORY); <br>    } <br>    m_pImpStream = pImpStream; <br>    m_pImpStream-&gt;AddRef(); <br>} <br> <br>CCachedStream::~CCachedStream() <br>{ <br>    m_pImpStream-&gt;Release(); <br>    if (m_pvCache) <br>    { <br>        HeapFree (GetProcessHeap(), 0, m_pvCache); <br>    } <br>} <br> <br>STDMETHODIMP CCachedStream::Read (LPVOID lpvData, ULONG cbSize, ULONG * lpcbRead) <br>{ <br>    HRESULT hResult = S_OK; <br>    ULONG cbRead = 0; <br>    ULONG cbT; <br>    LPVOID lpvRead = NULL; <br> <br>    if (IsBadWritePtr (lpvData, cbSize) || (lpcbRead &amp;&amp; IsBadWritePtr (lpcbRead, sizeof(ULONG)))) <br>    { <br>        hResult = STG_E_INVALIDPARAMETER; <br>        goto ret; <br>    } <br>    if (!(XPSOF_READ &amp; m_ulFlags)) <br>    { <br>        hResult = STG_E_ACCESSDENIED; <br>        goto ret; <br>    } <br>    ASSERT (m_cbBuffMac &gt;= m_libBuff); <br> <br>    // First, flush the buffer if it has been written into.  This <br>    // operation empties our buffer and zeros the offset and size. <br>    // We do this because we also buffer writes and we need to force <br>    // the underlying stream to point to where the caller expects. <br>    if ((XPSOF_WRITE &amp; m_ulFlags) &amp;&amp; m_fDirty) <br>    { <br>        hResult = Commit (0); <br>        if (hResult) <br>        { <br>            goto ret; <br>        } <br>    } <br> <br>    // Determine if the buffer is empty (cbT == 0) or not (cbT != 0). <br>    // We consider the buffer empty if we've read past the end of it <br>    // or if m_cbBuffMac and m_libBuff are equal to zero. <br>    cbT = m_cbBuffMac - m_libBuff; <br> <br>    // If the buffer is empty and the caller wants to read less than <br>    // the size of our buffer, then we'll fill the buffer from the <br>    // underlying stream object.  Adjust our buffer offset and size. <br>    if (!cbT &amp;&amp; (cbSize &lt; XPSOF_BUFF_MAX)) <br>    { <br>        hResult = m_pImpStream-&gt;Read (m_pvCache, XPSOF_BUFF_MAX, &amp;cbRead); <br>        if (hResult) <br>        { <br>            goto ret; <br>        } <br>        m_libBuff = 0; <br>        m_cbBuffMac = cbT = cbRead; <br>    } <br> <br>    // Now, if the buffer is *not* empty and the caller wants to read <br>    // fewer bytes than what is in the buffer, then we read it from <br>    // our buffer, fix-up our offset, set the count read and leave. <br>    if (cbT &amp;&amp; (cbSize &lt;= cbT)) <br>    { <br>        lpvRead = (LPVOID)((LPBYTE)m_pvCache + m_libBuff); <br>        CopyMemory (lpvData, lpvRead, cbSize); <br>        m_libBuff += cbSize; <br>        cbRead = cbSize; <br>        goto ret; <br>    } <br> <br>    // If we are here, then the caller has requested more bytes to be <br>    // read than what can fit in our buffer.  In this case, we copy <br>    // the remaining data from the buffer (if any) into lpvData and <br>    // then go straight to the underlying stream for the remainder. <br>    // Either way, our buffer is empty after this operation. <br>    lpvRead = lpvData; <br>    if (cbT) <br>    { <br>        CopyMemory (lpvRead, (LPVOID)((LPBYTE)m_pvCache + m_libBuff), cbT); <br>        lpvRead = (LPBYTE)lpvRead + cbT; <br>        m_libBuff = 0; <br>        m_cbBuffMac = 0; <br>    } <br> <br>    hResult = m_pImpStream-&gt;Read (lpvRead, cbSize - cbT, &amp;cbRead); <br>    if (hResult) <br>    { <br>        goto ret; <br>    } <br>    cbRead += cbT; <br> <br>ret: <br>    if (lpcbRead) <br>    { <br>        *lpcbRead = cbRead; <br>    } <br>    TraceResult ("CCachedStream::Read", hResult); <br>    return hResult; <br>} <br> <br>STDMETHODIMP CCachedStream::Write (const void * lpvData, ULONG cbSize, ULONG * lpcbWritten) <br>{ <br>    HRESULT hResult = S_OK; <br>    ULONG cbWritten = 0; <br>    ULONG cbT; <br>    LPVOID lpvWrite = NULL; <br> <br>    if (IsBadReadPtr (lpvData, cbSize) || (lpcbWritten &amp;&amp; IsBadWritePtr (lpcbWritten, sizeof(ULONG)))) <br>    { <br>        hResult = STG_E_INVALIDPARAMETER; <br>        goto ret; <br>    } <br>    if (!(XPSOF_WRITE &amp; m_ulFlags)) <br>    { <br>        hResult = STG_E_ACCESSDENIED; <br>        goto ret; <br>    } <br>    ASSERT (m_cbBuffMac &gt;= m_libBuff); <br> <br>    // First, if we've been Reading, then we need to re-wind the file <br>    // pointer in the underlying stream to compensate for the last <br>    // buffered Read.  Our new vacancy = the Max Size of our buffer. <br>    if (!m_fDirty) <br>    { <br>        if (m_libBuff != m_cbBuffMac) <br>        { <br>            hResult = RewindStream (m_cbBuffMac - m_libBuff); <br>            if (hResult) <br>            { <br>                goto ret; <br>            } <br>        } <br>        m_libBuff = 0; <br>        m_cbBuffMac = XPSOF_BUFF_MAX; <br>    } <br> <br>    // Determine the total vacancy of the buffer. <br>    cbT = m_cbBuffMac - m_libBuff; <br> <br>    // If the caller wants to Write more bytes than the current <br>    // vacancy of the buffer, then commit the current buffer and <br>    // Write the callers data directly to the stream.  If the <br>    // buffer is not dirty, then the Commit call is a no-op. <br>    if (cbSize &gt; cbT) <br>    { <br>        hResult = Commit (0); <br>        if (hResult) <br>        { <br>            goto ret; <br>        } <br>        hResult = m_pImpStream-&gt;Write (lpvData, cbSize, &amp;cbWritten); <br>        goto ret; <br>    } <br> <br>    // The callers data will fit in our current buffer.  Copy the <br>    // data into the buffer, mark the buffer as dirty, and adjust <br>    // the buffer offset.  Set cbWritten to cbSize and return. <br>    lpvWrite = (LPVOID)((LPBYTE)m_pvCache + m_libBuff); <br>    CopyMemory (lpvWrite, lpvData, cbSize); <br>    m_fDirty = TRUE; <br>    m_libBuff += cbSize; <br>    cbWritten = cbSize; <br> <br>ret: <br>    if (lpcbWritten) <br>    { <br>        *lpcbWritten = cbWritten; <br>    } <br>    TraceResult ("CCachedStream::Write", hResult); <br>    return hResult; <br>} <br> <br>STDMETHODIMP CCachedStream::Seek (LARGE_INTEGER liMove, DWORD dwMode, ULARGE_INTEGER * lpliPos) <br>{ <br>    HRESULT hResult = S_OK; <br>    if (lpliPos &amp;&amp; IsBadWritePtr (lpliPos, sizeof(ULARGE_INTEGER))) <br>    { <br>        hResult = STG_E_INVALIDPARAMETER; <br>        goto ret; <br>    } <br>    ASSERT (m_cbBuffMac &gt;= m_libBuff); <br> <br>    // If our buffer is dirty, then we've been writing into it and <br>    // we need to flush it.  Else, if it isn't dirty and our offset <br>    // and buffer size are not equal, then we've been reading and we <br>    // need to rewind the underlying stream to match our position. <br>    if (m_fDirty) <br>    { <br>        hResult = Commit (0); <br>        if (hResult) <br>        { <br>            goto ret; <br>        } <br>    } <br>    else <br>    { <br>        if ((dwMode == STREAM_SEEK_CUR) &amp;&amp; (m_libBuff != m_cbBuffMac)) <br>        { <br>            hResult = RewindStream (m_cbBuffMac - m_libBuff); <br>            if (hResult) <br>            { <br>                goto ret; <br>            } <br>        } <br>        m_libBuff = 0; <br>        m_cbBuffMac = 0; <br>    } <br>    // Now, call the real stream's Seek method. <br>    hResult = m_pImpStream-&gt;Seek (liMove, dwMode, lpliPos); <br>ret: <br>    TraceResult ("CCachedStream::Seek", hResult); <br>    return hResult; <br>} <br> <br>STDMETHODIMP CCachedStream::CopyTo (LPSTREAM lpStrmDst, <br>                                    ULARGE_INTEGER cbCopy, <br>                                    ULARGE_INTEGER * lpcbRead, <br>                                    ULARGE_INTEGER * lpcbWritten) <br>{ <br>    HRESULT hResult; <br>    if (IsBadReadPtr (lpStrmDst, sizeof(LPVOID)) || <br>        IsBadWritePtr (lpcbRead, sizeof(ULARGE_INTEGER)) || <br>        IsBadWritePtr (lpcbWritten, sizeof(ULARGE_INTEGER))) <br>    { <br>        hResult = STG_E_INVALIDPARAMETER; <br>        goto ret; <br>    } <br>    ASSERT (m_cbBuffMac &gt;= m_libBuff); <br> <br>    // If our buffer is dirty, then we've been writing into it and <br>    // we need to flush it.  Else, if it isn't dirty and our offset <br>    // and buffer size are not equal, then we've been reading and we <br>    // need to rewind the underlying stream to match our position. <br>    if (m_fDirty) <br>    { <br>        hResult = Commit (0); <br>        if (hResult) <br>        { <br>            goto ret; <br>        } <br>    } <br>    else <br>    { <br>        if (m_libBuff != m_cbBuffMac) <br>        { <br>            hResult = RewindStream (m_cbBuffMac - m_libBuff); <br>            if (hResult) <br>            { <br>                goto ret; <br>            } <br>        } <br>        m_libBuff = 0; <br>        m_cbBuffMac = 0; <br>    } <br> <br>    // Now, call the real streams CopyTo method. <br>    hResult = m_pImpStream-&gt;CopyTo (lpStrmDst, cbCopy, lpcbRead, lpcbWritten); <br>ret: <br>    TraceResult ("CCachedStream::CopyTo", hResult); <br>    return hResult; <br>} <br> <br>STDMETHODIMP CCachedStream::Commit (ULONG ulFlags) <br>{ <br>    HRESULT hResult = S_OK; <br>    // Flush my internal buffer if it is dirty. <br>    if ((XPSOF_WRITE &amp; m_ulFlags) &amp;&amp; m_fDirty) <br>    { <br>        hResult = m_pImpStream-&gt;Write (m_pvCache, m_libBuff, NULL); <br>        if (hResult) <br>        { <br>            goto ret; <br>        } <br>    } <br>    // Mark my buffer as empty cal clean. <br>    m_fDirty = FALSE; <br>    m_libBuff = 0; <br>    m_cbBuffMac = 0; <br>ret: <br>    TraceResult ("CCachedStream::Commit", hResult); <br>    return hResult; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>//    CCachedStream::RewindStream() <br>// <br>//    Parameters <br>//      ib      Number of bytes to rewind <br>// <br>//    Purpose <br>//      This gets called to back-up the file pointer when a Write operation <br>//      follows a Read operation.  This is necessary because the file pointer <br>//      is actually further ahead in the file than the buffered file pointer. <br>// <br>//    Return Value <br>//      An HRESULT <br>// <br>HRESULT WINAPI CCachedStream::RewindStream (ULONG ib) <br>{ <br>    if (ib) <br>    { <br>        LARGE_INTEGER liRewind; <br>        liRewind.HighPart = 0xFFFFFFFF; <br>        liRewind.LowPart = -((LONG)ib); <br>        return m_pImpStream-&gt;Seek (liRewind, STREAM_SEEK_CUR, NULL); <br>    } <br>    return S_OK; <br>} <br> <br>// End of File for XPSTREAM.CPP </code></pre>
<p>&nbsp;</p></body>
</HTML>
