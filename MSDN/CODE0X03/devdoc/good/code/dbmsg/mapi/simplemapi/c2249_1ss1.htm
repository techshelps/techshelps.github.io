<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAPIAPP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2251"></a>MAPIAPP.C</h2>
<pre><code>/* QuickCase:W KNB Version 1.00 */ <br>#include "MAPIAPP.h" <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "mapi.h" <br>#define MAIN 1 <br>#include "mapinit.h" <br> <br> <br>HANDLE hLibrary; <br>LHANDLE hMAPISession; <br> <br>MapiMessage mmMapiMessage; <br> <br>ULONG nMessageSize = 0x000004000; <br>lpMapiMessage FAR *lppMessage; <br>lpMapiMessage lpMessage; <br>char szSeedMessageID[512]; <br>char szMessageID[512]; <br>char szSubject[512]; <br>char szNoteText[4096]; <br> <br>LPSTR lpszSeedMessageID = &amp;szSeedMessageID[0]; <br>LPSTR lpszMessageID = &amp;szMessageID[0]; <br> <br>LPSTR pszSubject = &amp;szSubject[0]; <br>LPSTR pszNoteText = &amp;szNoteText[0]; <br>LPSTR pszDateReceived = "1991/03/23 12:00"; <br>MapiRecipDesc rdOriginator = { 0L,MAPI_ORIG,(LPSTR)"ONE",NULL}; <br> <br>int iFindFirst= TRUE; <br> <br>void InitMessage(lpMapiMessage pmmMessage) <br>{ <br>  pmmMessage-&gt;ulReserved = 0L; <br>  pmmMessage-&gt;lpszSubject =pszSubject; <br>  pmmMessage-&gt;lpszNoteText =pszNoteText; <br>  pmmMessage-&gt;lpszMessageType = NULL; <br>  pmmMessage-&gt;lpszDateReceived = pszDateReceived; <br>  pmmMessage-&gt;flFlags = MAPI_UNREAD; <br>  pmmMessage-&gt;lpOriginator = &amp;rdOriginator; <br>  pmmMessage-&gt;nRecipCount = 0L; <br>  pmmMessage-&gt;lpRecips = NULL; <br>  pmmMessage-&gt;nFileCount = 0L; <br>  pmmMessage-&gt;lpFiles = NULL; <br>} <br> <br>/**************************************************************************** <br> <br>    FUNCTION: OutOfMemory(void) <br> <br>    PURPOSE:  Displays warning message <br> <br>****************************************************************************/ <br>void OutOfMemory(void) <br>{ <br>    MessageBox( <br>        GetFocus(), <br>        GetStringRes (IDS_ERR_NO_MEMORY), <br>        NULL, <br>        MB_ICONHAND | MB_SYSTEMMODAL); <br>    return; <br>} <br> <br>void mycpystr(char * npszStrg, LPSTR lpszStrg) <br>{ <br>  if (lpszStrg != NULL) <br>    strcpy(npszStrg, lpszStrg); <br>  else <br>     *npszStrg = '\0'; <br>} <br> <br> <br>/************************************************************************/ <br>/*                                                                      */ <br>/* Windows 3.0 Main Program Body                                        */ <br>/*                                                                      */ <br>/* The following routine is the Windows Main Program.  The Main Program */ <br>/* is executed when a program is selected from the Windows Control      */ <br>/* Panel or File Manager.  The WinMain routine registers and creates    */ <br>/* the program's main window and initializes global objects.  The       */ <br>/* WinMain routine also includes the applications message dispatch      */ <br>/* loop.  Every window message destined for the main window or any      */ <br>/* subordinate windows is obtained, possibly translated, and            */ <br>/* dispatched to a window or dialog processing function. The dispatch   */ <br>/* loop is exited when a WM_QUIT message is obtained.  Before exiting   */ <br>/* the WinMain routine should destroy any objects created and free      */ <br>/* memory and other resources.                                          */ <br>/*                                                                      */ <br>/************************************************************************/ <br> <br>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) <br>{ <br> /***********************************************************************/ <br> /* HANDLE hInstance;       handle for this instance                    */ <br> /* HANDLE hPrevInstance;   handle for possible previous instances      */ <br> /* LPSTR  lpszCmdLine;     long pointer to exec command line           */ <br> /* int    nCmdShow;        Show code for main window display           */ <br> /***********************************************************************/ <br> <br> MSG        msg;           /* MSG structure to store your messages        */ <br> int        nRc;           /* return value from Register Classes          */ <br> long       nWndunits;     /* window units for size and location          */ <br> int        nWndx;         /* the x axis multiplier                       */ <br> int        nWndy;         /* the y axis multiplier                       */ <br> int        nX;            /* the resulting starting point (x, y)         */ <br> int        nY; <br> int        nWidth;        /* the resulting width and height for this     */ <br> int        nHeight;       /* window                                      */ <br> <br> strcpy(szAppName, "MAPIAPP"); <br> hInst = hInstance; <br> if(!hPrevInstance) <br>   { <br>    /* register window classes if first instance of application         */ <br>    if ((nRc = nCwRegisterClasses()) == -1) <br>      { <br>       /* registering one of the windows failed                         */ <br>       LoadString(hInst, IDS_ERR_REGISTER_CLASS, szString, sizeof(szString)); <br>       MessageBox(NULL, szString, NULL, MB_ICONEXCLAMATION); <br>       return nRc; <br>      } <br>   } <br> <br> /* Create a device independant size and location                       */ <br> nWndunits = GetDialogBaseUnits(); <br> nWndx = LOWORD(nWndunits); <br> nWndy = HIWORD(nWndunits); <br> nX = ((60 * nWndx) / 4); <br> nY = ((60 * nWndy) / 8); <br> nWidth = ((197 * nWndx) / 4); <br> nHeight = ((138 * nWndy) / 8); <br> <br> /* create application's Main window                                    */ <br> hWndMain = CreateWindow( <br>                szAppName,               /* Window class name           */ <br>GetStringRes (IDS_APP_TITLE),  /* Window's title        */ <br>                WS_CAPTION      |        /* Title and Min/Max           */ <br>                WS_SYSMENU      |        /* Add system menu box         */ <br>                WS_MINIMIZEBOX  |        /* Add minimize box            */ <br>                WS_MAXIMIZEBOX  |        /* Add maximize box            */ <br>                WS_BORDER       |        /* thin frame                  */ <br>                WS_CLIPCHILDREN |        /* don't draw in child windows areas */ <br>                WS_OVERLAPPED, <br>                nX, nY,                  /* X, Y                        */ <br>                nWidth, nHeight,         /* Width, Height of window     */ <br>                NULL,                    /* Parent window's handle      */ <br>                NULL,                    /* Default to Class Menu       */ <br>                hInst,                   /* Instance of window          */ <br>                NULL);                   /* Create struct for WM_CREATE */ <br> <br> <br> if (InitMAPI() != 0) <br>   return ERR_LOAD_LIB; <br> <br>  InitMessage(&amp;mmMapiMessage); <br> <br> if(hWndMain == NULL) <br>   { <br>    LoadString(hInst, IDS_ERR_CREATE_WINDOW, szString, sizeof(szString)); <br>    MessageBox(NULL, szString, NULL, MB_ICONEXCLAMATION); <br>    return IDS_ERR_CREATE_WINDOW; <br>   } <br> <br> EnableMenuItem(GetMenu(hWndMain), IDM_A_LOGOFF, MF_DISABLED | MF_GRAYED); <br> EnableMenuItem(GetMenu(hWndMain), IDM_S_MAIL, MF_DISABLED | MF_GRAYED); <br> EnableMenuItem(GetMenu(hWndMain), IDM_S_DOCUMENT, MF_DISABLED | MF_GRAYED); <br> EnableMenuItem(GetMenu(hWndMain), IDM_M_FINDFIRST, MF_DISABLED | MF_GRAYED); <br> EnableMenuItem(GetMenu(hWndMain), IDM_M_FINDNEXT, MF_DISABLED | MF_GRAYED); <br> EnableMenuItem(GetMenu(hWndMain), IDM_M_READ, MF_DISABLED | MF_GRAYED); <br> EnableMenuItem(GetMenu(hWndMain), IDM_M_DELETE, MF_DISABLED | MF_GRAYED); <br> <br> ShowWindow(hWndMain, nCmdShow);            /* display main window      */ <br> <br> while(GetMessage(&amp;msg, NULL, 0, 0))        /* Until WM_QUIT message    */ <br>   { <br>    TranslateMessage(&amp;msg); <br>    DispatchMessage(&amp;msg); <br>   } <br> <br> DeInitMAPI(); <br> /* Do clean up before exiting from the application                     */ <br> CwUnRegisterClasses(); <br> return msg.wParam; <br>} /*  End of WinMain                                                    */ <br>/************************************************************************/ <br>/*                                                                      */ <br>/* Main Window Procedure                                                */ <br>/*                                                                      */ <br>/* This procedure provides service routines for the Windows events      */ <br>/* (messages) that Windows sends to the window, as well as the user     */ <br>/* initiated events (messages) that are generated when the user selects */ <br>/* the action bar and pulldown menu controls or the corresponding       */ <br>/* keyboard accelerators.                                               */ <br>/*                                                                      */ <br>/* The SWITCH statement shown below distributes the window messages to  */ <br>/* the respective message service routines, which are set apart by the  */ <br>/* CASE statements. The window procedures must provide an appropriate   */ <br>/* service routine for its end user initiated messages, as well as the  */ <br>/* general Windows messages (ie. WM_CLOSE message). If a message is     */ <br>/* sent to this procedure for which there is no programmed CASE clause  */ <br>/* (i.e., no service routine), the message is defaulted to the          */ <br>/* DefWindowProc function, where it is handled by Windows               */ <br>/*                                                                      */ <br>/* For the end-user initiated messages, this procedure is concerned     */ <br>/* principally with the WM_COMMAND message. The menu control ID (or the */ <br>/* corresponding accelerator ID) is communicated to this procedure in   */ <br>/* the first message parameter (wParam). The window procedure provides  */ <br>/* a major CASE statement for the WM_COMMAND message and a subordinate  */ <br>/* SWITCH statement to provide CASE clauses for the message service     */ <br>/* routines for the various menu item's, identified by their ID values. */ <br>/*                                                                      */ <br>/* The message service routines for the individual menu items are the   */ <br>/* main work points in the program. These service routines contain the  */ <br>/* units of work performed when the end user select one of the menu     */ <br>/* controls. The required application response to a menu control is     */ <br>/* programmed in its associated CASE clause. The service routines may   */ <br>/* contain subroutine calls to separately compiled and libraried        */ <br>/* routines, in-line calls to subroutines to be embodied in this source */ <br>/* code module, or program statements entered directly in the CASE      */ <br>/* clauses. Program control is switched to the appropriate service      */ <br>/* routine when Windows recognizes the end user event and sends a WM_COMMAND */ <br>/* message to the window procedure. The service routine provides the    */ <br>/* appropriate application-specific response to the end user initiated  */ <br>/* event, then breaks to return control to the WinMain() routine which  */ <br>/* continues to service the message queue of the window(s).             */ <br>/*                                                                      */ <br>/************************************************************************/ <br> <br>LONG FAR PASCAL WndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br> HMENU      hMenu=0;            /* handle for the menu                 */ <br> HBITMAP    hBitmap=0;          /* handle for bitmaps                  */ <br> HDC        hDC;                /* handle for the display device       */ <br> PAINTSTRUCT ps;                /* holds PAINT information             */ <br> int        nRc=0;              /* return code                         */ <br> FLAGS flFlag = 0L; <br> ULONG ulResult; <br>  char szBuf[32*1024]; // Waste of stack space, but this is only a demo. <br>  char szTmp[32*1024]; // Waste of stack space, but this is only a demo. <br> <br> switch (Message) { <br>   case WM_COMMAND: <br>     /* The Windows messages for action bar and pulldown menu items */ <br>     /* are processed here.                                         */ <br>     /* The WM_COMMAND message contains the message ID in its first */ <br>     /* parameter (wParam). This routine is programmed to SWITCH on */ <br>     /* the #define values generated by CASE:W for the menu items   */ <br>     /* in the application's header (*.H) file. The ID values have  */ <br>     /* the format, IDM_itemname. The service routines for the      */ <br>     /* various menu items follow the CASE statements up to the     */ <br>     /* generated BREAK statements.                                 */ <br>     switch (LOWORD(wParam)) { <br>       case IDM_A_LOGON: <br>            /* Place User Code to respond to the                   */ <br>            /* Menu Item Named "Log&amp;In" here.                      */ <br>         flFlag =MAPI_NEW_SESSION | MAPI_LOGON_UI; <br>         ulResult = (*lpfnMAPILogon)(hWnd, NULL, NULL, flFlag, 0L, (LPLHANDLE)&amp;hMAPISession); <br>         if (ulResult == 0L) { <br>           EnableMenuItem(GetMenu(hWndMain), IDM_A_LOGOFF, MF_ENABLED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_S_MAIL, MF_ENABLED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_S_DOCUMENT, MF_ENABLED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_FINDFIRST, MF_ENABLED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_FINDNEXT, MF_ENABLED); <br>         } <br>       break; <br> <br>       case IDM_A_LOGOFF: <br>            /* Place User Code to respond to the                   */ <br>            /* Menu Item Named "Log&amp;Off" here.                     */ <br>         ulResult = (*lpfnMAPILogoff)(hMAPISession, hWnd, 0L, 0L); <br>         if (ulResult == 0L) { <br>            EnableMenuItem(GetMenu(hWndMain), IDM_A_LOGOFF, MF_DISABLED | MF_GRAYED); <br>             EnableMenuItem(GetMenu(hWndMain), IDM_S_MAIL, MF_DISABLED | MF_GRAYED); <br>             EnableMenuItem(GetMenu(hWndMain), IDM_S_DOCUMENT, MF_DISABLED | MF_GRAYED); <br>             EnableMenuItem(GetMenu(hWndMain), IDM_M_FINDFIRST, MF_DISABLED | MF_GRAYED); <br>             EnableMenuItem(GetMenu(hWndMain), IDM_M_FINDNEXT, MF_DISABLED | MF_GRAYED); <br>             EnableMenuItem(GetMenu(hWndMain), IDM_M_READ, MF_DISABLED | MF_GRAYED); <br>             EnableMenuItem(GetMenu(hWndMain), IDM_M_DELETE, MF_DISABLED | MF_GRAYED); <br>         } <br>       break; <br> <br>       case IDM_S_MAIL: <br>            /* Place User Code to respond to the                   */ <br>            /* Menu Item Named "&amp;Mail" here.                       */ <br>          flFlag =MAPI_DIALOG; <br>         ulResult = (*lpfnMAPISendMail)(hMAPISession, hWnd, &amp;mmMapiMessage, flFlag, 0L); <br>       break; <br> <br>       case IDM_S_DOCUMENT: <br>            /* Place User Code to respond to the                   */ <br>            /* Menu Item Named "&amp;Document" here.                   */ <br>         ulResult = (*lpfnMAPISendDocuments)(hWnd, ";", "C:\\CONFIG.SYS", "CONFIG.SYS", 0L); <br>       break; <br> <br>       case IDM_M_FINDFIRST: <br>           iFindFirst=TRUE; <br>       case IDM_M_FINDNEXT: <br>            /* Place User Code to respond to the                   */ <br>            /* Menu Item Named "&amp;Find Next" here.                  */ <br>         if (iFindFirst) { <br>           *lpszSeedMessageID = '\0'; <br>           iFindFirst = FALSE; <br>         } <br>         else { <br>           strcpy(lpszSeedMessageID,lpszMessageID); <br>         } <br>         ulResult = (*lpfnMAPIFindNext)(hMAPISession, hWnd, NULL, lpszSeedMessageID, flFlag, 0L, lpszMessageID); <br>         if (ulResult == 0L) { <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_FINDNEXT, MF_ENABLED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_READ, MF_ENABLED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_DELETE, MF_ENABLED); <br>         } <br>         else { <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_FINDNEXT, MF_DISABLED | MF_GRAYED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_READ, MF_DISABLED | MF_GRAYED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_DELETE, MF_DISABLED | MF_GRAYED); <br>         } <br>       break; <br> <br>       case IDM_M_READ: <br>            /* Place User Code to respond to the                   */ <br>            /* Menu Item Named "&amp;Read" here.                       */ <br> <br>           lppMessage= (lpMapiMessage FAR *) &amp;lpMessage; <br>           ulResult = (*lpfnMAPIReadMail)(hMAPISession, hWnd, lpszMessageID, flFlag, 0L, lppMessage); <br>           if (ulResult == 0L) { <br>             mycpystr(szTmp,lpMessage-&gt;lpOriginator-&gt;lpszName); <br> sprintf(szBuf, GetStringRes(IDS_FROM), szTmp); <br>             mycpystr(szTmp,lpMessage-&gt;lpRecips[0].lpszName); <br>             sprintf(szBuf, GetStringRes(IDS_TO), szBuf,szTmp); <br>             mycpystr(szTmp,lpMessage-&gt;lpszDateReceived); <br>             sprintf(szBuf, GetStringRes(IDS_DATE), szBuf,szTmp); <br>             mycpystr(szTmp,lpMessage-&gt;lpszSubject); <br> sprintf(szBuf, GetStringRes(IDS_SUBJECT), szBuf,szTmp); <br> mycpystr(szTmp,lpMessage-&gt;lpszNoteText); <br> sprintf(szBuf,"%s%s",szBuf,szTmp); <br>              <br> MessageBox(hWnd,szBuf, GetStringRes(IDS_MESSAGE), MB_OK); <br>             ulResult = lpfnMAPIFreeBuffer((LPVOID)lpMessage); <br>           } <br>       break; <br> <br>       case IDM_M_DELETE: <br>            /* Place User Code to respond to the                   */ <br>            /* Menu Item Named "&amp;Delete" here.                  */ <br> <br>         ulResult = (*lpfnMAPIDeleteMail)(hMAPISession, hWnd, lpszMessageID, flFlag, 0l); <br>         if (ulResult == 0L) { <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_READ, MF_DISABLED | MF_GRAYED); <br>           EnableMenuItem(GetMenu(hWndMain), IDM_M_DELETE, MF_DISABLED | MF_GRAYED); <br>         } <br>       break; <br> <br>       default: <br>         return DefWindowProc(hWnd, Message, wParam, lParam); <br>     } <br>     if (ulResult != 0L) {       /** oops **/ <br> <br>       sprintf(szBuf, GetStringRes(IDS_RETURNED_ERROR), ulResult); <br>       MessageBox(hWnd,szBuf, GetStringRes(IDS_FAILED),MB_OK); <br>     } <br>     else { <br>       sprintf(szBuf, GetStringRes(IDS_GOOD_JOB)); <br>       MessageBox(hWnd,szBuf, GetStringRes(IDS_SUCCESS), MB_OK); <br>     } <br>   break;        /* End of WM_COMMAND                             */ <br> <br>   case WM_CREATE: <br>     /* The WM_CREATE message is sent once to a window when the     */ <br>     /* window is created.  The window procedure for the new window */ <br>     /* receives this message after the window is created, but      */ <br>     /* before the window becomes visible.                          */ <br>     /*                                                             */ <br>     /* Parameters:                                                 */ <br>     /*                                                             */ <br>     /*    lParam  -  Points to a CREATESTRUCT structure with       */ <br>     /*               the following form:                           */ <br>     /*                                                             */ <br>     /*    typedef struct                                           */ <br>     /*              {                                              */ <br>     /*               LPSTR     lpCreateParams;                     */ <br>     /*               HANDLE    hInst;                              */ <br>     /*               HANDLE    hMenu;                              */ <br>     /*               HWND      hwndParent;                         */ <br>     /*               int       cy;                                 */ <br>     /*               int       cx;                                 */ <br>     /*               int       y;                                  */ <br>     /*               int       x;                                  */ <br>     /*               LONG      style;                              */ <br>     /*               LPSTR     lpszName;                           */ <br>     /*               LPSTR     lpszClass;                          */ <br>     /*               DWORD     dwExStyle;                          */ <br>     /*              }  CREATESTRUCT;                               */ <br> <br> <br> <br>   break;       /*  End of WM_CREATE                              */ <br> <br>   case WM_MOVE:     /*  code for moving the window                    */ <br>   break; <br> <br>   case WM_SIZE:     /*  code for sizing client area                   */ <br>        /* wParam contains a code indicating the requested sizing      */ <br>        /* lParam contains the new height and width of the client area */ <br>   break;       /* End of WM_SIZE                                 */ <br> <br>   case WM_PAINT:    /* code for the window's client area              */ <br>     /* Obtain a handle to the device context                       */ <br>     /* BeginPaint will sends WM_ERASEBKGND if appropriate          */ <br>     memset(&amp;ps, 0x00, sizeof(PAINTSTRUCT)); <br>     hDC = BeginPaint(hWnd, &amp;ps); <br> <br>     /* Included in case the background is not a pure color         */ <br>     SetBkMode(hDC, TRANSPARENT); <br> <br>     /* Application should draw on the client window using          */ <br>     /* the GDI graphics and text functions.  'ps' the PAINTSTRUCT  */ <br>     /* returned by BeginPaint contains a rectangle to the          */ <br>     /* area that must be repainted.                                */ <br> <br>     /* Inform Windows painting is complete                         */ <br>     EndPaint(hWnd, &amp;ps); <br>   break;       /*  End of WM_PAINT                               */ <br> <br>   case WM_CLOSE:  /* close the window                                 */ <br>     /* Destroy child windows, modeless dialogs, then, this window  */ <br>     DestroyWindow(hWnd); <br>     if (hWnd == hWndMain) <br>       PostQuitMessage(0);  /* Quit the application                 */ <br>   break; <br> <br>   default: <br>        /* For any message for which you don't specifically provide a  */ <br>        /* service routine, you should return the message to Windows   */ <br>        /* for default message processing.                             */ <br>     return DefWindowProc(hWnd, Message, wParam, lParam); <br> } <br> return 0L; <br>}     /* End of WndProc                                         */ <br> <br>/************************************************************************/ <br>/*                                                                      */ <br>/* nCwRegisterClasses Function                                          */ <br>/*                                                                      */ <br>/* The following function registers all the classes of all the windows  */ <br>/* associated with this application. The function returns an error code */ <br>/* if unsuccessful, otherwise it returns 0.                             */ <br>/*                                                                      */ <br>/************************************************************************/ <br> <br>int nCwRegisterClasses(void) <br>{ <br> WNDCLASS   wndclass;    /* struct to define a window class             */ <br> memset(&amp;wndclass, 0x00, sizeof(WNDCLASS)); <br> <br> <br> /* load WNDCLASS with window's characteristics                         */ <br> wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNWINDOW; <br> wndclass.lpfnWndProc = WndProc; <br> /* Extra storage for Class and Window objects                          */ <br> wndclass.cbClsExtra = 0; <br> wndclass.cbWndExtra = 0; <br> wndclass.hInstance = hInst; <br> wndclass.hIcon = LoadIcon(hInst, "MAPIAPP"); <br> wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); <br> /* Create brush for erasing background                                 */ <br> wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br> wndclass.lpszMenuName = szAppName;   /* Menu Name is App Name */ <br> wndclass.lpszClassName = szAppName; /* Class Name is App Name */ <br> if(!RegisterClass(&amp;wndclass)) <br>   return -1; <br> <br> <br> return(0); <br>} /* End of nCwRegisterClasses                                          */ <br> <br>/************************************************************************/ <br>/*  CwUnRegisterClasses Function                                        */ <br>/*                                                                      */ <br>/*  Deletes any refrences to windows resources created for this         */ <br>/*  application, frees memory, deletes instance, handles and does       */ <br>/*  clean up prior to exiting the window                                */ <br>/*                                                                      */ <br>/************************************************************************/ <br> <br>void CwUnRegisterClasses(void) <br>{ <br> WNDCLASS   wndclass;    /* struct to define a window class             */ <br> memset(&amp;wndclass, 0x00, sizeof(WNDCLASS)); <br> <br> UnregisterClass(szAppName, hInst); <br>}    /* End of CwUnRegisterClasses                                      */ <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
