<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ROUTE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2227"></a>ROUTE.C</h2>
<pre><code>/* <br> -  ROUTE.C <br> * <br> * <br> *      Functions used to implement routing. <br> * <br> *      To create a new routing message call: <br> *         DialogBoxParam(hInst, "RouteNote", hWnd, RouteNoteDlgProc, (LPARAM) NULL ); <br> *      To route a routed message to the next recipient call: <br> *          DialogBoxParam(hInst, "RouteNote", hWnd, RouteNoteDlgProc, (LPARAM) pmsg ); <br> *              where pmsg is a pointer to the message you want to route. <br> *      To find out if a message was routed by this program call: <br> *          HasRougingSlip(); <br> * <br> * <br> *      To use this functions in your own program change the line (in route.h): <br> *          #define lpszSmplRTMsgClass "IPM.Note.SampleRoutingForm" <br> *      to reflect the name of your own class for routing messages. <br> * <br> * <br> *  Copyright 1986-1996, Microsoft Corporation. All Rights Reserved. <br> */ <br> <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef _WIN32 <br>#include &lt;objerror.h&gt; <br>#include &lt;objbase.h&gt; <br>#endif <br>#ifdef WIN16 <br>#include &lt;compobj.h&gt; <br>#include &lt;commdlg.h&gt; <br>#endif <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapiwin.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include &lt;cindex.h&gt; <br> <br>#ifdef WIN16 <br>#define GWL_USERDATA    DWL_USER <br>#endif <br> <br> <br>/* <br> To use a GUID XXX in a program you have to initialize it in exactly one <br>obj file of your project. <br>Line "#define USES_XXX" tells the compiler that you are going to use GUID XXX <br>in this file. <br>Lines "#define INITGUID"  and "#include&lt;initguid.h&gt;" <br>tell the compiler to init GUIDs in this file.*/ <br> <br>/* the GUID we'll be using */ <br>#define USES_PS_ROUTING_EMAIL_ADDRESSES 1 <br>#define USES_PS_ROUTING_ADDRTYPE 1 <br>#define USES_PS_ROUTING_DISPLAY_NAME 1 <br>#define USES_PS_ROUTING_ENTRYID 1 <br>#define USES_PS_ROUTING_SEARCH_KEY 1 <br>#define USES_PS_PUBLIC_STRINGS  1 <br>#define USES_IID_IMessage 1 <br>#define USES_IID_IMAPIStatus 1 <br>#define USES_IID_IMAPIForm 1 <br>/*initialize the GUIDs in this file*/ <br>#define INITGUID 1 <br>#include &lt;initguid.h&gt; <br>#include &lt;mapiguid.h&gt; <br>#include &lt;pdkver.h&gt; <br> <br>#include "client.h" <br>#include "bitmap.h" <br>#include "route.h" <br> <br>/* Routing Data. Used in RouteNoteDlgProc that handles composing/sending/reading of <br>routing messages */ <br>typedef struct _ROUTEDATA <br>{ <br>    LPADRLIST palAddrListOld; <br>    LPADRLIST palAddrListActive; <br>    ULONG nCurrentRouteRecip; <br>    ULONG nTotalRouteRecip; <br>    LPMAPITABLE ptblAttach; <br>    BOOL bNewMessage; <br>    LPMESSAGE pmsgRouteMsg; <br>    ULONG tagCurrent; <br>    ULONG tagTotal; <br>    ULONG cbConvIdx; <br>    LPBYTE lpbConvIdx; <br>} ROUTEDATA, FAR * LPROUTEDATA; <br> <br>BOOL MakeNewRouteMessage(LPMESSAGE pmsgRead, LPROUTEDATA FAR * ppRouteData); <br>BOOL SetRouteProps(LPROUTEDATA pRouteData); <br>BOOL DelRouteProps(LPROUTEDATA pRouteData); <br>BOOL GetRoutePropTagArray(ULONG cb, LPMESSAGE lpM, LPSPropTagArray FAR * lppspta); <br>BOOL GetRoutePropTagArrayFast(ULONG nTotalRecip, LPMESSAGE lpM, BOOL fCreate, <br>                                LPSPropTagArray FAR * lppspta); <br>BOOL GetRouteIndices(LPROUTEDATA pRouteData); <br>BOOL SetRouteIndices(LPROUTEDATA pRouteData); <br>BOOL CreateOutMessage(LPMESSAGE FAR * lpmSrcMsgI); <br>BOOL GetRouteAddrLists(LPROUTEDATA pRouteData); <br>UINT FirstRecipient(LPADRLIST lpAL); <br>BOOL SetMessageClass(LPMESSAGE lpM, LPSTR lpszClass); <br>BOOL HasAttachment(LPMESSAGE lpM); <br>BOOL PopulateAttachList(HWND hDlg, LPROUTEDATA pRouteData); <br>BOOL CreateNewAttachment(HWND hDlg); <br>void SaveAttachment( HWND hDlg, UINT indx); <br>void RT_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify); <br>BOOL RT_OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lParam); <br>BOOL RBox_OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lParam); <br>void RBox_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify); <br>void DeInitRouteData(LPROUTEDATA pRouteData); <br>BOOL CALLBACK RouteBoxDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam); <br>void InitRouteNameIDArray(ULONG cb, LPMAPINAMEID lpPropNames); <br>void PopulateRouteListBox(HWND hDlg); <br>void ConfigMoveButtons(HWND hDlg, HWND hLB); <br> <br> <br>typedef enum _ROUTEPROPSETS <br>{ <br>    ROUTEPROPSET_EMAIL_ADDRESS = 0, <br>    ROUTEPROPSET_ADDRTYPE, <br>    ROUTEPROPSET_DISPLAY_NAME, <br>    ROUTEPROPSET_ENTRYID, <br>    ROUTEPROPSET_SEARCH_KEY, <br>    ROUTEPROPSETDIM     /* used for dimension*/ <br>} ROUTEPROPSETS; <br> <br> <br>LPGUID  lpguidA[ROUTEPROPSETDIM]  = <br>{ <br>    (LPGUID)&amp;PS_ROUTING_EMAIL_ADDRESSES, <br>    (LPGUID)&amp;PS_ROUTING_ADDRTYPE, <br>    (LPGUID)&amp;PS_ROUTING_DISPLAY_NAME, <br>    (LPGUID)&amp;PS_ROUTING_ENTRYID, <br>    (LPGUID)&amp;PS_ROUTING_SEARCH_KEY <br>}; <br> <br>ULONG  ulRoutePropTypes [ROUTEPROPSETDIM] = <br>{ <br>    PT_STRING8, <br>    PT_STRING8, <br>    PT_STRING8, <br>    PT_BINARY, <br>    PT_BINARY <br>}; <br> <br> <br> <br>/*  used for PrepareRecips call*/ <br>SizedSPropTagArray(ROUTEPROPSETDIM, sptRouteProps) = <br>{ <br>    ROUTEPROPSETDIM, <br>    { <br>        PR_EMAIL_ADDRESS, <br>        PR_ADDRTYPE, <br>        PR_DISPLAY_NAME, <br>        PR_ENTRYID, <br>        PR_SEARCH_KEY <br>    } <br>}; <br> <br>enum {EMSG_SUBJ = 0, EMSG_BODY, EMSG_MSGFLAGS, EMSG_CONVIDX, EMSGPROPDIM}; <br>SizedSPropTagArray( EMSGPROPDIM, tagaMsgProps) = <br>{ <br>    EMSGPROPDIM, <br>    {PR_SUBJECT, PR_BODY, PR_MESSAGE_FLAGS, PR_CONVERSATION_INDEX} <br>}; <br>/* <br>// <br>// the number of entries could vary from <br>// EXCLUDED_PROPS_ON_REPLY to EXCLUDED_PROPS_ON_REPLY - 1 and vice versa, <br>// depending if the message is being reply or fowarded. If forwarded, the <br>// PR_MESSAGE_ATTACHMENTS property is included in the forwarded message <br>// otherwise it is excluded <br>*/ <br>#define EXCLUDED_PROPS_ON_REPLY     29 <br>SizedSPropTagArray (EXCLUDED_PROPS_ON_REPLY, sptExcludedProps) = <br>{ <br>    EXCLUDED_PROPS_ON_REPLY, <br>    { <br>        PR_SENDER_NAME, <br>        PR_SENDER_ENTRYID, <br>        PR_SENDER_SEARCH_KEY, <br>        PR_SENDER_EMAIL_ADDRESS, <br>        PR_SENDER_ADDRTYPE, <br> <br>        PR_RECEIVED_BY_NAME, <br>        PR_RECEIVED_BY_ENTRYID, <br>        PR_RECEIVED_BY_SEARCH_KEY, <br> <br>        PR_SENT_REPRESENTING_NAME, <br>        PR_SENT_REPRESENTING_ENTRYID, <br>        PR_SENT_REPRESENTING_SEARCH_KEY, <br>        PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>        PR_SENT_REPRESENTING_ADDRTYPE, <br> <br>        PR_RCVD_REPRESENTING_NAME, <br>        PR_RCVD_REPRESENTING_ENTRYID, <br>        PR_RCVD_REPRESENTING_SEARCH_KEY, <br> <br>        PR_MESSAGE_FLAGS, <br>        PR_MESSAGE_RECIPIENTS, <br> <br>        PR_READ_RECEIPT_ENTRYID, <br>        PR_REPORT_ENTRYID, <br> <br>        PR_REPLY_RECIPIENT_ENTRIES, <br>        PR_REPLY_RECIPIENT_NAMES, <br> <br>        PR_PARENT_KEY, <br> <br>        PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED, <br> <br>        PR_READ_RECEIPT_REQUESTED, <br> <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_MESSAGE_DELIVERY_TIME, <br>        PR_MESSAGE_DOWNLOAD_TIME, <br> <br>//        PR_SUBJECT_PREFIX, <br>        PR_MESSAGE_ATTACHMENTS <br>    } <br>}; <br> <br>LPADRBOOK <br>OpenAddressBook(HWND hwnd) <br>{ <br>    HRESULT hr; <br>    LPADRBOOK pabAddrBook = NULL; <br> <br>    Assert(pses); <br>    hr = pses-&gt;lpVtbl-&gt;OpenAddressBook(pses, (ULONG) hwnd, NULL, 0, &amp;pabAddrBook); <br>    if(HR_FAILED(hr)) <br>    { <br>        MakeMessageBox(hwnd, GetScode(hr),IDS_OPENAB, NULL, MBS_ERROR); <br>        return NULL; <br>    } <br>    if(hr) /*if we have a warning*/ <br>    { <br>        LPMAPIERROR perr = NULL; <br> <br>        pses-&gt;lpVtbl-&gt;GetLastError(pses, hr, 0, &amp;perr); <br>        MakeMessageBox(hwnd, GetScode(hr), IDS_OPENABWARN, perr, MBS_ERROR); <br>        MAPIFreeBuffer(perr); <br>    } <br> <br>    return pabAddrBook; <br>} <br> <br>/* <br> *  Handles the RouteSlipbox <br> * <br> *  Extracts all necessary data from GWL_USERDATA window long of <br> *  its parent which is RouteNote dialog. <br> */ <br>BOOL CALLBACK <br>RouteBoxDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        PopulateRouteListBox(hDlg); <br>        return TRUE; <br> <br>    HANDLE_MSG(hDlg, WM_COMMAND, RBox_OnCommand); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>void RBox_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    ADRPARM AdrParm = { 0 }; <br>    ULONG ulrectps = MAPI_TO; <br>    LPSTR  lpszTitles = "Route To "; <br>    UINT nIndex, nIndex1; <br>    LPSPropValue lpspv = NULL; <br>    LPROUTEDATA pRouteData = NULL; <br>    HRESULT hr; <br> <br>    switch (id) <br>    { <br>    case IDC_ADDRLISTACTIVE: <br>    case IDC_ADDRLISTOLD: <br>            /*This is to disallow hitting "Remove" button when <br>            there is something selected in the old address list*/ <br>        if(codeNotify == LBN_SETFOCUS) <br>        { <br>            if(id == IDC_ADDRLISTOLD) <br>            { <br>                EnableWindow(GetDlgItem(hDlg, IDC_REMOVEADDR), FALSE); <br>                EnableWindow(GetDlgItem(hDlg, IDC_MOVEUP), FALSE); <br>                EnableWindow(GetDlgItem(hDlg, IDC_MOVEDOWN), FALSE); <br>                ListBox_SetCurSel(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), -1); <br> <br>            } <br> <br>            else /*must be IDC_ADDRLISTACTIVE*/ <br>            { <br>                EnableWindow(GetDlgItem(hDlg, IDC_REMOVEADDR), TRUE); <br>                ListBox_SetCurSel(GetDlgItem(hDlg, IDC_ADDRLISTOLD), -1); <br>            } <br>        } <br> <br> <br>        if(IDC_ADDRLISTACTIVE == id &amp;&amp; LBN_SELCHANGE == codeNotify) <br>        { <br>            ConfigMoveButtons(hDlg, hwndCtl); <br>        } <br> <br>        /* Details */ <br>        if(codeNotify == LBN_DBLCLK) <br>        { <br>            LPSPropValue pvalDtls = NULL; <br>            ULONG cVals = 0; <br> <br>            nIndex = (UINT)ListBox_GetCurSel(hwndCtl); <br>            if (nIndex == LB_ERR) <br>                break; <br>            nIndex1 = (UINT)ListBox_GetItemData(hwndCtl, nIndex); <br>            if(nIndex1 == LB_ERR) <br>            { <br>                DebugTrace("Client: error retrieving listbox item data"); <br>                break; <br>            } <br> <br>            pRouteData = (LPROUTEDATA) GetWindowLong(GetParent(hDlg), GWL_USERDATA); <br>            Assert(pRouteData); <br> <br>            if(IDC_ADDRLISTACTIVE == id) <br>            { <br>                Assert(nIndex1 &lt; pRouteData-&gt;palAddrListActive-&gt;cEntries); <br>                pvalDtls = pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndex1].rgPropVals; <br>                cVals = pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndex1].cValues; <br>            } <br>            else if(IDC_ADDRLISTOLD == id) <br>            { <br>                Assert(nIndex1 &lt; pRouteData-&gt;palAddrListOld-&gt;cEntries); <br>                pvalDtls = pRouteData-&gt;palAddrListOld-&gt;aEntries[nIndex1].rgPropVals; <br>                cVals = pRouteData-&gt;palAddrListOld-&gt;aEntries[nIndex1].cValues; <br>            } <br>            else <br>                Assert(FALSE); <br> <br>            Assert(pvalDtls); <br>            pvalDtls = PpropFindProp(pvalDtls, cVals, PR_ENTRYID); <br> <br>            Assert(pvalDtls); <br>            if(pvalDtls) <br>            { <br>                hr = pabAddrB-&gt;lpVtbl-&gt;Details(pabAddrB, (LPULONG) &amp;hDlg, NULL, <br>                                        NULL, pvalDtls-&gt;Value.bin.cb, <br>                                        (LPENTRYID)pvalDtls-&gt;Value.bin.lpb, NULL, <br>                                        NULL, NULL, DIALOG_MODAL); <br>            } <br>        } <br>        return; <br> <br>    case IDC_MOVEDOWN: <br>    case IDC_MOVEUP: <br>        { <br>            int nInd, nIndNew; <br>            int nIndData, nIndDataNew; <br>#ifdef DEBUG <br>            int nTotal; <br>#endif <br>            char szStr[256]; <br>            ADRENTRY ae = {0}; <br>            HWND hLB = GetDlgItem(hDlg, IDC_ADDRLISTACTIVE); <br> <br>            Assert(hLB); <br> <br>            nInd = ListBox_GetCurSel(hLB); <br>            if (nInd == LB_ERR) <br>                break; <br>#ifdef DEBUG <br>            Assert(nInd != 0 || id != IDC_MOVEUP); <br> <br>            nTotal = ListBox_GetCount(hLB); <br>            if(nTotal != LB_ERR) <br>                Assert(nInd != nTotal-1 || id != IDC_MOVEDOWN); <br>#endif <br> <br>            if(IDC_MOVEDOWN == id) <br>                nIndNew = nInd + 1; <br>            else <br>                nIndNew = nInd - 1; <br> <br>            nIndData = ListBox_GetItemData(hLB, nInd); <br>            if(nIndData == LB_ERR) <br>            { <br>                DebugTrace("Client: error retrieving listbox item data"); <br>                break; <br>            } <br> <br>            nIndDataNew = ListBox_GetItemData(hLB, nIndNew); <br>            if(nIndDataNew == LB_ERR) <br>            { <br>                DebugTrace("Client: error retrieving listbox item data"); <br>                break; <br>            } <br> <br>            pRouteData = (LPROUTEDATA) GetWindowLong(GetParent(hDlg), GWL_USERDATA); <br>            Assert(pRouteData); <br> <br>            ae = pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndData]; <br>            pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndData] = <br>            pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndDataNew]; <br>            pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndDataNew] = ae; <br> <br>            /*PopulateRouteListBox(hDlg);*/ <br> <br>            /*this works only because the two strings we swap are adjacent*/ <br>            ListBox_GetText(hLB, nInd, szStr); <br>            ListBox_DeleteString(hLB, nInd); <br>            ListBox_InsertString(hLB, nIndNew, szStr); <br> <br>            ListBox_SetItemData(hLB, nIndNew, nIndDataNew); <br>            ListBox_SetItemData(hLB, nInd, nIndData); <br> <br>            ListBox_SetCurSel(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), nIndNew); <br>            ConfigMoveButtons(hDlg, GetDlgItem(hDlg, IDC_ADDRLISTACTIVE)); <br>            break; <br>        } <br> <br> <br>    case IDC_ADDADDR: <br>        Assert(pabAddrB != NULL); <br>        memset(&amp;AdrParm, 0, sizeof(AdrParm)); <br>        AdrParm.ulFlags = AB_SELECTONLY | DIALOG_MODAL; <br>        AdrParm.lpszCaption = "Routing Slip"; <br>        AdrParm.lpszNewEntryTitle = "NEW ENTRY"; <br>        AdrParm.cDestFields = 1; <br>        AdrParm.nDestFieldFocus = 0; <br>        AdrParm.lppszDestTitles = &amp;lpszTitles; <br>        AdrParm.lpulDestComps =  &amp;ulrectps ; <br> <br>        pRouteData = (LPROUTEDATA) GetWindowLong(GetParent(hDlg), GWL_USERDATA); <br>        Assert(pRouteData); <br> <br>        hr = pabAddrB-&gt;lpVtbl-&gt;Address(pabAddrB, (LPULONG) &amp;hDlg, &amp;AdrParm, &amp;pRouteData-&gt;palAddrListActive); <br> <br>        if(GetScode(hr)!= MAPI_E_USER_CANCEL) <br>        { <br>            PopulateRouteListBox(hDlg); <br>            SetWindowText(GetDlgItem(hDlg, IDCANCEL), "Close"); <br>            SetFocus(GetDlgItem(hDlg, IDCANCEL)); <br> <br>            ListBox_SetCurSel(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), 0); <br>            ConfigMoveButtons(hDlg, GetDlgItem(hDlg, IDC_ADDRLISTACTIVE)); <br> <br>        } <br>        return; <br> <br>    case IDC_REMOVEADDR: <br>        nIndex = (UINT)ListBox_GetCurSel(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE)); <br>        if (nIndex == LB_ERR) <br>            break; <br> <br>        /*items position in ADRLIST is stored with the item in the listbox*/ <br>        nIndex1 = (UINT)ListBox_GetItemData(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), nIndex); <br>        if(nIndex1 == LB_ERR) <br>        { <br>            DebugTrace("Client: error retrieving listbox item data"); <br>            break; <br>        } <br> <br>        pRouteData = (LPROUTEDATA) GetWindowLong(GetParent(hDlg), GWL_USERDATA); <br>        Assert(pRouteData); <br> <br>        /* Null out the removed item */ <br>        MAPIFreeBuffer(pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndex1].rgPropVals); <br>        pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndex1].rgPropVals = NULL; <br>        pRouteData-&gt;palAddrListActive-&gt;aEntries[nIndex1].cValues = 0; <br> <br>        ListBox_DeleteString(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), nIndex); <br> <br>        if(nIndex &gt; 0) <br>            --nIndex; <br> <br>        ListBox_SetCurSel(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), nIndex); <br>        ConfigMoveButtons(hDlg, GetDlgItem(hDlg, IDC_ADDRLISTACTIVE)); <br> <br> <br>        SetWindowText(GetDlgItem(hDlg, IDCANCEL), "Close"); <br>        return; <br> <br>    case IDCANCEL: <br> <br>        EndDialog (hDlg, TRUE); <br>        return; <br> <br>    default: <br>        break; <br>    } <br>} <br> <br>void ConfigMoveButtons(HWND hDlg, HWND hLB) <br>{ <br>    int nIndex; <br>    int nTotal; <br> <br>    EnableWindow(GetDlgItem(hDlg, IDC_MOVEUP), FALSE); <br>    EnableWindow(GetDlgItem(hDlg, IDC_MOVEDOWN), FALSE); <br> <br>    nIndex = (UINT)ListBox_GetCurSel(hLB); <br>    if (nIndex == LB_ERR) <br>        return; <br> <br>    nTotal = ListBox_GetCount(hLB); <br>    if(nTotal == LB_ERR) <br>        return; <br> <br>    if(nIndex) <br>        EnableWindow(GetDlgItem(hDlg, IDC_MOVEUP), TRUE); <br> <br>    if(nIndex &lt; nTotal-1) <br>        EnableWindow(GetDlgItem(hDlg, IDC_MOVEDOWN), TRUE); <br>} <br> <br>/* <br> *  Handles the Route Note dialog which is used for both composing <br> *  and reading routing messages. <br> * <br> *  If RotueNoteDlg is called to route an existing msg, a pointer to <br> *  the message is passed as a lParam to WM_INITDIALOG. <br> * <br> */ <br> <br>BOOL CALLBACK <br>RouteNoteDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>    HANDLE_MSG(hDlg, WM_INITDIALOG, RT_OnInitDialog); <br> <br>    HANDLE_MSG(hDlg, WM_COMMAND, RT_OnCommand); <br> <br>    default: <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br>BOOL RT_OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    HRESULT hr; <br>    ULONG cVals = 0; <br>    LPSPropValue pvalProp = NULL; <br>    LPSTREAM lpstreamBody = NULL; <br>    STATSTG statstg = {0}; <br>    LPSTR lpszNoteText = NULL; <br>    ULONG cb = 0; <br>    LPMESSAGE pmsgRead = (LPMESSAGE)lParam; <br>    LPROUTEDATA pRouteData = NULL; <br>    LPMESSAGE pmsgRoute = NULL; <br> <br>    if(!MakeNewRouteMessage(pmsgRead, &amp;pRouteData)) <br>    { <br>        DebugTrace("Client: MakeNewRouteMessage failed (RT_OnInitDialog)"); <br>        goto err; <br>    } <br> <br>    if (pmsgRead) <br>    { <br>        hr = pmsgRead-&gt;lpVtbl-&gt;SetReadFlag(pmsgRead, MAPI_DEFERRED_ERRORS); <br>        /* RouteNote is being called to route  */ <br>        /*  a message in the Inbox.  So, we'll initialize the   */ <br>        /*  form with data from  pmsgRouteMsg */ <br>        pmsgRoute = pRouteData-&gt;pmsgRouteMsg; <br>        Assert(pmsgRoute); <br> <br>        hr = pmsgRoute-&gt;lpVtbl-&gt;GetProps(pmsgRoute, (LPSPropTagArray)&amp;tagaMsgProps, 0, <br>                                                     &amp;cVals, &amp;pvalProp); <br>        Assert(cVals == EMSGPROPDIM); <br>        if(HR_SUCCEEDED(hr)) <br>        { <br>            if(PROP_TYPE(pvalProp[EMSG_SUBJ].ulPropTag) == PT_ERROR) <br>            { <br>                DebugTrace("Client: Unable to retrieve subject"); <br>                /*goto err;*/ <br>            } <br>            else <br>            { <br>                SetDlgItemText(hDlg, IDC_RTSUBJECT, pvalProp[EMSG_SUBJ].Value.LPSZ); <br>                /* //$ */ <br>            } <br> <br>            if(PR_CONVERSATION_INDEX == pvalProp[EMSG_CONVIDX].ulPropTag) <br>            { <br>                LPSPropValue pval = &amp;pvalProp[EMSG_CONVIDX]; <br> <br>                pRouteData-&gt;cbConvIdx = pval-&gt;Value.bin.cb; <br>                if(MAPIAllocateBuffer(pRouteData-&gt;cbConvIdx, &amp;pRouteData-&gt;lpbConvIdx)) <br>                { <br>                    DebugTrace("Client: MAPIAllocateBuffer failed\r\n"); <br>                    pRouteData-&gt;lpbConvIdx = NULL; <br>                    pRouteData-&gt;cbConvIdx = 0; <br>                } <br>                else <br>                { <br>                    CopyMemory(pRouteData-&gt;lpbConvIdx, pval-&gt;Value.bin.lpb, pRouteData-&gt;cbConvIdx); <br>                } <br>            } <br>            else <br>            { <br>                pRouteData-&gt;lpbConvIdx = NULL; <br>                pRouteData-&gt;cbConvIdx = 0; <br>            } <br> <br>            if(PROP_TYPE(pvalProp[EMSG_BODY].ulPropTag) == PT_ERROR) <br>            { <br>                if(GetScode(pvalProp[EMSG_BODY].Value.l) == MAPI_E_NOT_ENOUGH_MEMORY) <br>                { <br>                    hr = pmsgRoute-&gt;lpVtbl-&gt;OpenProperty(pmsgRoute, PR_BODY, &amp;IID_IStream, <br>                                                STGM_READ, MAPI_DEFERRED_ERRORS, <br>                                                (LPUNKNOWN FAR *) &amp;lpstreamBody); <br>                    if(S_OK != GetScode(hr)) <br>                    { <br>                        DebugTraceResult(OpenProperty, hr); <br>                        goto err; <br>                    } <br>                    hr = lpstreamBody-&gt;lpVtbl-&gt;Stat(lpstreamBody, &amp;statstg, STATFLAG_NONAME); <br>                    if(S_OK != GetScode(hr)) <br>                    { <br>                        DebugTrace("IStream::Stat failed"); <br>                        goto err; <br>                    } <br>                    Assert(statstg.cbSize.HighPart == 0); <br>                    if(MAPIAllocateBuffer(statstg.cbSize.LowPart + 1, (LPVOID FAR *) &amp;lpszNoteText)) <br>                    { <br>                        goto err; <br>                    } <br>                    hr = lpstreamBody-&gt;lpVtbl-&gt;Read(lpstreamBody, lpszNoteText, <br>                                                statstg.cbSize.LowPart, &amp;cb); <br>                    if(S_OK != GetScode(hr)) <br>                    { <br>                        DebugTrace("IStream::Read failed"); <br>                        goto err; <br>                    } <br>                    lpszNoteText[statstg.cbSize.LowPart] = '\0'; <br>                    SetDlgItemText(hDlg, IDC_RTNOTE, lpszNoteText); <br>                    MAPIFreeBuffer(lpszNoteText); <br>                    lpszNoteText = NULL; <br>                    lpstreamBody-&gt;lpVtbl-&gt;Release(lpstreamBody); <br>                    lpstreamBody = NULL; <br>                } <br>                else /* some other error (too bad) */ <br>                { <br>                    DebugTrace("Client: error reading body"); <br>                     /*//$goto err;*/ <br>                } <br>            } <br>            else /* everything's fine */ <br>            { <br>                SetDlgItemText(hDlg, IDC_RTNOTE, pvalProp[EMSG_BODY].Value.LPSZ); <br>            } <br>        } <br>        else  /* a real error*/ <br>        { <br>            DebugTrace("Client: error reading body and subject"); <br>            goto err; <br>        } <br>     <br>        if(pvalProp[EMSG_MSGFLAGS].ulPropTag == PR_MESSAGE_FLAGS) <br>        { <br>            if(pvalProp[EMSG_MSGFLAGS].Value.l &amp; MSGFLAG_HASATTACH) <br>            { <br>                PopulateAttachList(hDlg, pRouteData); <br>            } <br>        } <br> <br>        MAPIFreeBuffer(pvalProp); <br>        pvalProp = NULL; <br> <br> <br>        Assert(pRouteData-&gt;palAddrListOld || pRouteData-&gt;palAddrListActive); <br>    } <br>    else <br>    { <br>    /* if we are here it means we are creating a new message */ <br>        pRouteData-&gt;lpbConvIdx = NULL; <br>        pRouteData-&gt;cbConvIdx = 0; <br>    } <br> <br> <br>    SetWindowLong(hDlg, GWL_USERDATA, (LONG) pRouteData); <br>    UlRelease(pmsgRead); <br>    return TRUE; <br> <br>err: <br>    UlRelease(lpstreamBody); <br>    MAPIFreeBuffer(pvalProp); <br>    MAPIFreeBuffer(lpszNoteText); <br>    DeInitRouteData(pRouteData); <br>    UlRelease(pmsgRead); <br>    MakeMessageBox(hDlg, 0, IDS_INIDIAG, NULL, MBS_ERROR); <br>    EndDialog(hDlg, FALSE); <br>    return TRUE; <br>} <br> <br>void RT_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    LONG cb, cLines; <br>    ULONG nAttNum; <br>    HRESULT hr; <br>    LPSTR lpszSubject = NULL; <br>    LPSTR lpszNoteText = NULL; <br>    /* +1 for SentMailEID; +2 for conversation topic*/   <br>    SPropValue spvProp[EMSGPROPDIM+2] = {0};  <br>    LPSTREAM lpstreamBody = NULL; <br>    HCURSOR hcOld; <br>    UINT nFstRecip; <br>    LPROUTEDATA pRouteData = NULL; <br>    LPMESSAGE pmsgRoute = NULL; <br>    LPSPropProblemArray pProblems = NULL; <br>    ULONG cbNewConvIdx = 0; <br>    LPBYTE lpbNewConvIdx = NULL; <br> <br> <br>    switch (id) <br>        { <br>        case IDC_RTATTACH: <br>            if(!CreateNewAttachment(hDlg)) <br>            { <br>                DebugTrace("CreateNewAttachment failed"); <br>            } <br>            return; <br> <br>        case IDC_RTDELATTACH: <br>            pRouteData = (LPROUTEDATA)GetWindowLong(hDlg, GWL_USERDATA); <br>            Assert(pRouteData); <br> <br>            cb = ListBox_GetCurSel(GetDlgItem(hDlg, IDC_RTATTACHLIST)); <br>            if(LB_ERR != cb) <br>            { <br>                nAttNum = ListBox_GetItemData(GetDlgItem(hDlg, IDC_RTATTACHLIST), cb); <br>                if(LB_ERR == nAttNum) <br>                { <br>                    DebugTrace("Client:GetItemData failed (routenote)"); <br>                    break; <br>                } <br> <br>                hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt;DeleteAttach(pRouteData-&gt;pmsgRouteMsg, nAttNum, 0, <br>                                            NULL, 0); <br>                if(S_OK != GetScode(hr)) <br>                { <br>                    DebugTrace("Client: DeleteAttach failed"); <br>                    break; <br>                } <br>                ListBox_DeleteString(GetDlgItem(hDlg, IDC_RTATTACHLIST), cb); <br>            } <br> <br>            break; <br> <br>        case IDC_RTATTACHLIST: <br>            cb = ListBox_GetCurSel(hwndCtl); <br>                if(cb!=LB_ERR) <br>                { <br>                    EnableWindow(GetDlgItem(hDlg, IDC_RTSAVEATTACH), TRUE); <br>                    EnableWindow(GetDlgItem(hDlg, IDC_RTDELATTACH), TRUE); <br>                } <br>                else <br>                { <br>                    EnableWindow(GetDlgItem(hDlg, IDC_RTSAVEATTACH), FALSE); <br>                    EnableWindow(GetDlgItem(hDlg, IDC_RTDELATTACH), FALSE); <br>                } <br>            if(codeNotify != LBN_DBLCLK) <br>                break; <br>            /*fall through*/ <br> <br>        case IDC_RTSAVEATTACH: <br>            cb = ListBox_GetCurSel(GetDlgItem(hDlg, IDC_RTATTACHLIST)); <br>            if(LB_ERR != cb) <br>            { <br>                SaveAttachment(hDlg, (UINT) cb); <br>            } <br>            break; <br> <br>        case IDC_RTEDITROUTESLIP: <br>            DialogBox (hInst, "RouteSlipBox", hDlg, RouteBoxDlgProc); <br>            break; <br> <br>        case IDC_RTROUTE: <br>            pRouteData = (LPROUTEDATA)GetWindowLong(hDlg, GWL_USERDATA); <br>            Assert(pRouteData); <br> <br>            pmsgRoute = pRouteData-&gt;pmsgRouteMsg; <br>            Assert(pmsgRoute); <br>            if(!pRouteData-&gt;palAddrListActive &amp;&amp; pRouteData-&gt;palAddrListOld) <br>            { <br>                MakeMessageBox(hDlg,0, IDS_LASTRECIP, NULL, MB_OK); <br>                break; <br>            } <br>            nFstRecip = FirstRecipient(pRouteData-&gt;palAddrListActive); <br>            if((!pRouteData-&gt;palAddrListActive &amp;&amp; !pRouteData-&gt;palAddrListOld) || !nFstRecip) <br>            { <br>                MakeMessageBox(hDlg, 0, IDS_NORECIPS, NULL, MB_OK); <br>                break; <br>            } <br>            hcOld = SetCursor(hWaitCur); <br>            if (Edit_GetModify(GetDlgItem(hDlg, IDC_RTSUBJECT))) <br>            { <br>                cb = Edit_LineLength(GetDlgItem(hDlg, IDC_RTSUBJECT), 0); <br>                if (MAPIAllocateBuffer (cb + 1, (LPVOID far *) &amp; lpszSubject)) <br>                    goto err; <br> <br>                GetDlgItemText (hDlg, IDC_RTSUBJECT, lpszSubject, (int)cb+1); <br>                spvProp[EMSG_SUBJ].ulPropTag = PR_SUBJECT; <br>                spvProp[EMSG_SUBJ].Value.LPSZ = lpszSubject; <br> <br>            } <br>            else <br>            { <br>                spvProp[EMSG_SUBJ].ulPropTag = PR_NULL; <br>            } <br>            if (pRouteData-&gt;bNewMessage || Edit_GetModify(GetDlgItem(hDlg, IDC_RTNOTE))) <br>            { <br>                cLines = Edit_GetLineCount(GetDlgItem(hDlg, IDC_RTNOTE)); <br> <br>                if (cLines) <br>                { <br>                    /* Get the total number of bytes in the multi-line */ <br> <br>                    cb = Edit_LineIndex(GetDlgItem(hDlg, IDC_RTNOTE),(cLines - 1)); <br>                    cb += Edit_LineLength(GetDlgItem(hDlg, IDC_RTNOTE), cb); <br> <br>                    /* The next line is to account for CR-LF pairs per line. */ <br> <br>                    cb += cLines * 2; <br> <br>                    if (MAPIAllocateBuffer (cb + 1, (LPVOID FAR *) &amp; lpszNoteText)) <br>                        goto err; <br> <br>                    /* Get the Note Text from the edit */ <br> <br>                    GetDlgItemText (hDlg, IDC_RTNOTE, lpszNoteText, (int)cb); <br>                    spvProp[EMSG_BODY].ulPropTag = PR_BODY; <br>                    spvProp[EMSG_BODY].Value.LPSZ = lpszNoteText; <br>                } <br>            } <br>            else <br>            { <br>                spvProp[EMSG_BODY].ulPropTag = PR_NULL; <br>            } <br> <br>            /*We want a copy of the message in the "Sent Mail" folder*/ <br>            CopyMemory(&amp;spvProp[EMSGPROPDIM], pvalSentMailEID, sizeof(SPropValue)); <br> <br>#ifdef DEBUG <br>            if(pRouteData-&gt;bNewMessage) <br>            { <br>                Assert(pRouteData-&gt;cbConvIdx == 0); <br>                Assert(pRouteData-&gt;lpbConvIdx == NULL); <br>            } <br>#endif <br>            if(!ScAddConversationIndex(pRouteData-&gt;cbConvIdx, pRouteData-&gt;lpbConvIdx, <br>                                        &amp;cbNewConvIdx, &amp;lpbNewConvIdx)) <br>            { <br>                spvProp[EMSG_CONVIDX].ulPropTag = PR_CONVERSATION_INDEX; <br>                spvProp[EMSG_CONVIDX].Value.bin.cb = cbNewConvIdx; <br>                spvProp[EMSG_CONVIDX].Value.bin.lpb = lpbNewConvIdx; <br>            } <br>            else <br>            { <br>                spvProp[EMSG_CONVIDX].ulPropTag = PR_NULL; <br>            } <br> <br>            if(pRouteData-&gt;bNewMessage) <br>            { <br>                spvProp[EMSGPROPDIM+1].ulPropTag = PR_CONVERSATION_TOPIC; <br>                if(PR_SUBJECT == spvProp[EMSG_SUBJ].ulPropTag) <br>                { <br>                    spvProp[EMSGPROPDIM+1].Value.LPSZ = spvProp[EMSG_SUBJ].Value.LPSZ; <br>                } <br>                else <br>                { <br>                    spvProp[EMSGPROPDIM+1].Value.LPSZ = ""; <br>                } <br>            } <br>            else <br>            { <br>                spvProp[EMSGPROPDIM+1].ulPropTag = PR_NULL; <br>            } <br> <br>            spvProp[EMSG_MSGFLAGS].ulPropTag = PR_NULL; <br>             <br>            hr = pmsgRoute-&gt;lpVtbl-&gt;SetProps(pmsgRoute, EMSGPROPDIM+2, spvProp, &amp;pProblems); <br>            MAPIFreeBuffer(lpbNewConvIdx); <br>            lpbNewConvIdx = NULL; <br>            if(S_OK != GetScode(hr)) <br>            { <br>                DebugTrace("Client: SetProps failed (RouteNote)"); <br>                goto err; <br>            } </code></pre>
<p>
</p>
<pre><code>else <br>            { <br>                if(pProblems) <br>                {   /* use nAttNum as an index for a sec */ <br>                    for(nAttNum = 0; nAttNum &lt; pProblems-&gt;cProblem; ++nAttNum) <br>                    { <br>                        switch(pProblems-&gt;aProblem[nAttNum].ulPropTag) <br>                        { <br>                        case PR_SENTMAIL_ENTRYID: <br>                            DebugTrace("Client: Error setting PR_SENTMAIL_ENTRYID"); <br>                            goto err; <br> <br>                        case PR_SUBJECT: <br>                            DebugTrace("Client: Error settting PR_SUBJECT"); <br>                            goto err; <br>                        case PR_BODY: <br>                            if(MAPI_E_NOT_ENOUGH_MEMORY != pProblems-&gt;aProblem[nAttNum].scode) <br>                            { <br>                                DebugTrace("Client: Error settting PR_BODY"); <br>                                goto err; <br>                            } <br>                            else /* have to use IStream */ <br>                            { <br>                                hr = pmsgRoute-&gt;lpVtbl-&gt;OpenProperty(pmsgRoute, PR_BODY, &amp;IID_IStream, <br>                                                STGM_READWRITE, MAPI_DEFERRED_ERRORS, <br>                                                (LPUNKNOWN FAR *) &amp;lpstreamBody); <br>                                if(S_OK != GetScode(hr)) <br>                                { <br>                                    DebugTraceResult(OpenProperty, hr); <br>                                    goto err; <br>                                } <br>                                hr = lpstreamBody-&gt;lpVtbl-&gt;Write(lpstreamBody, lpszNoteText, lstrlen(lpszNoteText), NULL); <br>                                if(S_OK != GetScode(hr)) <br>                                { <br>                                    DebugTrace("IStream::Write failed"); <br>                                    goto err; <br>                                } <br>                            } <br>                            break; <br>                        } <br>                    } <br>                } <br>            } <br> <br> <br>            DelRouteProps(pRouteData); <br>            if(!SetRouteProps(pRouteData)) <br>            { <br>                DebugTrace("Client: SetRouteProps failed (RouteNote)"); <br>                goto err; <br>            } <br> <br>            if(!SetMessageClass(pRouteData-&gt;pmsgRouteMsg,  lpszSmplRTMsgClass)) <br>            { <br>                DebugTrace("Client: SetMessageClass failed"); <br>                goto err; <br>            } <br> <br>            cb = pRouteData-&gt;palAddrListActive-&gt;cEntries; <br>            /* nFstRecip is the index of the first non NULL entry in the <br>            palAddrListActive. So we pretend for a sec that palAddrListActive had <br>            only one recipient to set a "TO" recipient in the pmsgRouteMsg */ <br>            pRouteData-&gt;palAddrListActive-&gt;cEntries = nFstRecip; <br>            hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt;ModifyRecipients(pRouteData-&gt;pmsgRouteMsg, <br>                                        0, pRouteData-&gt;palAddrListActive); <br>            pRouteData-&gt;palAddrListActive-&gt;cEntries = cb; <br>            if(S_OK != GetScode(hr)) <br>            { <br>                DebugTrace("Client: ModifyRecipients faild (routenote)"); <br>                goto err; <br>            } <br> <br>            hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt;SubmitMessage(pRouteData-&gt;pmsgRouteMsg, 0); <br>            if(S_OK != GetScode(hr)) <br>            { <br>                MakeMessageBox(hDlg, GetScode(hr), IDS_SENDERROR, NULL, MBS_ERROR); <br>                goto err; <br>            } <br>            /*fall through*/ <br> <br>err: <br>        case IDCANCEL: <br> <br>            if(IDCANCEL == id) <br>            { <br>                pRouteData = (LPROUTEDATA)GetWindowLong(hDlg, GWL_USERDATA); <br>                Assert(pRouteData); <br>                if(pRouteData-&gt;palAddrListActive|| <br>                    Edit_GetModify(GetDlgItem(hDlg, IDC_RTNOTE)) || <br>                    Edit_GetModify(GetDlgItem(hDlg, IDC_RTSUBJECT))) <br>                    { <br>                        if(MessageBox(hDlg, "Are you sure you want to close this form?", <br>                        "?", MB_YESNO) == IDNO)  break; <br>                    } <br>            } <br>            else <br>            { <br>                SetCursor(hcOld); <br>            } <br> <br> <br>            MAPIFreeBuffer (lpszSubject); <br>            MAPIFreeBuffer (lpszNoteText); <br>            UlRelease(lpstreamBody); <br>            lpstreamBody = NULL; <br>            DeInitRouteData(pRouteData); <br>            pRouteData = NULL; <br> <br>            EndDialog (hDlg, TRUE); <br>            break; <br> <br>        default: <br>            break; <br>        } <br>} <br> <br>/*  <br>*   DeInitRouteData <br>* <br>*  releases pRouteData and everything that was in it <br>*/ <br>void DeInitRouteData(LPROUTEDATA pRouteData) <br>{ <br>    if(!pRouteData) return; <br> <br>    FreePadrlist(pRouteData-&gt;palAddrListOld); <br>    FreePadrlist(pRouteData-&gt;palAddrListActive); <br>    UlRelease(pRouteData-&gt;pmsgRouteMsg); <br>    UlRelease(pRouteData-&gt;ptblAttach); <br>    MAPIFreeBuffer(pRouteData-&gt;lpbConvIdx); <br>    MAPIFreeBuffer(pRouteData); <br>} <br> <br>/* Returns a 1-based index of the first recipent. <br> returns 0 if all entries in the input address list are NULLs*/ <br>UINT FirstRecipient(LPADRLIST lpAL) <br>{ <br>    UINT idx; <br> <br>    if(!lpAL || !lpAL-&gt;cEntries) return 0; <br> <br>    for(idx = 0; idx &lt; lpAL-&gt;cEntries; ++idx) <br>        if(lpAL-&gt;aEntries[idx].rgPropVals) return (idx+1); <br> <br>    return 0; <br>} <br> <br>void PopulateRouteListBox(HWND hDlg) <br>{ <br>    LPADRENTRY lpadrent; <br>    LPSPropValue lpsprop; <br>    LPSTR pStr = NULL; <br>    LPROUTEDATA pRouteData = NULL; <br>    UINT iadrentry = 0, ilbitem = 0; <br> <br> <br> <br>    UINT yOld = MINY, yActive = MINY; <br>    UINT cOld; <br>    UINT cActive; <br>    RECT rect; <br> <br>    pRouteData = (LPROUTEDATA) GetWindowLong(GetParent(hDlg), GWL_USERDATA); <br> <br>    Assert(pRouteData); <br> <br>    if(!pRouteData-&gt;palAddrListOld &amp;&amp; !pRouteData-&gt;palAddrListActive) <br>        return; <br> <br>    /* some arithmetic to resize the listboxes. <br>       Make the listbox that has more entries taller*/ <br>    if(pRouteData-&gt;palAddrListOld &amp;&amp; pRouteData-&gt;palAddrListActive) <br>    { <br>        cOld = pRouteData-&gt;palAddrListOld-&gt;cEntries; <br>        cActive = pRouteData-&gt;palAddrListActive-&gt;cEntries; <br> <br>        yOld = (UINT)LBLENGTH * cOld / (cOld + cActive); <br>        yActive = (UINT)LBLENGTH - yOld; <br>    } <br>    else if(pRouteData-&gt;palAddrListOld) <br>    { <br>        yActive = 0; <br>    } <br>    else <br>    { <br>        yOld = 0; <br>    } <br>    if(yOld &lt; MINY) <br>    { <br>        yOld = MINY; <br>        yActive = LBLENGTH - MINY; <br>    } <br>    else if(yActive &lt; MINY) <br>    { <br>        yActive = MINY; <br>        yOld = LBLENGTH - MINY; <br>    } <br> <br>    rect.left = LBX; <br>    rect.top = OLDY; <br>    rect.right = DELTAX; <br>    rect.bottom = yOld; <br> <br>    MapDialogRect(hDlg, &amp;rect); <br> <br>    SetWindowPos(GetDlgItem(hDlg, IDC_ADDRLISTOLD), 0, <br>                rect.left, rect.top, rect.right, rect.bottom, SWP_SHOWWINDOW); <br> <br>    rect.left = LBX; <br>    rect.top = OLDY + yOld + DELTA; <br>    rect.right = DELTAX; <br>    rect.bottom = yActive; <br> <br>    MapDialogRect(hDlg, &amp;rect); <br> <br>    SetWindowPos(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), 0, <br>                rect.left, rect.top, rect.right, rect.bottom, SWP_SHOWWINDOW); <br> <br>    ListBox_ResetContent(GetDlgItem(hDlg, IDC_ADDRLISTOLD)); <br>    ListBox_ResetContent(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE)); <br> <br>    if(pRouteData-&gt;palAddrListOld) <br>    { <br> <br>    for(iadrentry = 0, lpadrent = pRouteData-&gt;palAddrListOld-&gt;aEntries; <br>         lpadrent &lt; pRouteData-&gt;palAddrListOld-&gt;aEntries+pRouteData-&gt;palAddrListOld-&gt;cEntries; <br>         ++lpadrent, ++iadrentry) <br>    { <br>        if(!lpadrent-&gt;rgPropVals) continue; <br> <br>        /* IAddrBook::Addres doesn't guarantee the order of the props. <br>            So we have to loop through all of them */ <br>        for(lpsprop = lpadrent-&gt;rgPropVals; <br>            lpsprop &lt; lpadrent-&gt;rgPropVals + lpadrent-&gt;cValues; ++lpsprop) <br>        { <br>            if(lpsprop-&gt;ulPropTag ==  PR_DISPLAY_NAME) <br>            { <br>                pStr =  lpsprop-&gt;Value.LPSZ; <br>                ilbitem = ListBox_AddString(GetDlgItem(hDlg, IDC_ADDRLISTOLD), pStr); <br>                if(LB_ERR != ilbitem) <br>                    ListBox_SetItemData(GetDlgItem(hDlg, IDC_ADDRLISTOLD), ilbitem, iadrentry); <br>                break; <br>            } <br>        } <br>    } <br>    } <br>    if(pRouteData-&gt;palAddrListActive) <br>    { <br>        for(iadrentry = 0, lpadrent = pRouteData-&gt;palAddrListActive-&gt;aEntries; <br>             lpadrent &lt; pRouteData-&gt;palAddrListActive-&gt;aEntries+pRouteData-&gt;palAddrListActive-&gt;cEntries; <br>             ++lpadrent, ++iadrentry) <br>        { <br>            if(!lpadrent-&gt;rgPropVals) continue; <br> <br>            /* IAddrBook::Addres doesn't guarantee the order of the props. <br>            So we have to loop through all of them */ <br>            for(lpsprop = lpadrent-&gt;rgPropVals; <br>                lpsprop &lt; lpadrent-&gt;rgPropVals + lpadrent-&gt;cValues; ++lpsprop) <br>            { <br>                if(lpsprop-&gt;ulPropTag ==  PR_DISPLAY_NAME) <br>                { <br>                    pStr =  lpsprop-&gt;Value.LPSZ; <br>                    ilbitem = ListBox_AddString(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), pStr); <br>                    if(LB_ERR != ilbitem)    /* save the position of the entry in the addrlist for future refs*/ <br>                        ListBox_SetItemData(GetDlgItem(hDlg, IDC_ADDRLISTACTIVE), ilbitem, iadrentry); <br>                    break; <br>                } <br>            } <br>        } <br>    } <br>} <br> <br> <br>/* Get the index of the current recip and total number of recipients <br> * from the routing slip of the message <br> */ <br>BOOL GetRouteIndices(LPROUTEDATA pRouteData) <br>{ <br>    HRESULT hr; <br>    LPSPropTagArray lpsptProp = NULL; <br>    LPSPropValue lpspv = NULL ; <br>    ULONG cProps = 0; <br>    LPMESSAGE pmsg = NULL; <br>    MAPINAMEID nmidRTPR[2]; <br>    MAPINAMEID *pnmidRTPR[2] = {&amp;nmidRTPR[0], &amp;nmidRTPR[1]}; <br> <br>    nmidRTPR[0].lpguid = (LPGUID)&amp;PS_PUBLIC_STRINGS; <br>    nmidRTPR[0].ulKind = MNID_STRING; <br>    nmidRTPR[0].Kind.lpwstrName =   L"CURRENT_RT_RECIP"; <br>    nmidRTPR[1].lpguid = (LPGUID)&amp;PS_PUBLIC_STRINGS; <br>    nmidRTPR[1].ulKind = MNID_STRING; <br>    nmidRTPR[1].Kind.lpwstrName =   L"TOTAL_RT_RECIP"; <br> <br>    Assert(pRouteData); <br> <br>    pmsg = pRouteData-&gt;pmsgRouteMsg; <br>    Assert(pmsg); <br>    hr = pmsg-&gt;lpVtbl-&gt;GetIDsFromNames(pmsg, 2, pnmidRTPR, 0, &amp;lpsptProp); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTraceResult(GetIDsFromNames, hr); <br>        goto err; <br>    } <br> <br>    lpsptProp-&gt;aulPropTag[0] = PROP_TAG(PT_LONG, PROP_ID(lpsptProp-&gt;aulPropTag[0])); <br>    lpsptProp-&gt;aulPropTag[1] = PROP_TAG(PT_LONG, PROP_ID(lpsptProp-&gt;aulPropTag[1])); <br> <br>    /* save for later use in setrouteindices() */ <br>    pRouteData-&gt;tagCurrent = lpsptProp-&gt;aulPropTag[0]; <br>    pRouteData-&gt;tagTotal = lpsptProp-&gt;aulPropTag[1]; <br> <br>    hr = pmsg-&gt;lpVtbl-&gt;GetProps(pmsg, lpsptProp, 0, &amp;cProps, &amp;lpspv); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTraceResult(GetProps, hr); <br>        goto err; <br>    } <br> <br>    Assert(lpspv); <br>    pRouteData-&gt;nCurrentRouteRecip = lpspv[0].Value.l; <br>    pRouteData-&gt;nTotalRouteRecip = lpspv[1].Value.l; <br> <br> <br>err: <br>    MAPIFreeBuffer(lpsptProp); <br>    MAPIFreeBuffer(lpspv); <br>    return !hr; <br>} <br> <br>BOOL SetRouteIndices(LPROUTEDATA pRouteData) <br>{ <br> <br>    HRESULT hr; <br>    LPSPropTagArray lpsptProp = NULL; <br>    SPropValue spvRTProp[2]; <br>    LPSPropProblemArray pProblems = NULL; <br> <br>    MAPINAMEID nmidRTPR[2]; <br>    MAPINAMEID *pnmidRTPR[2] = {&amp;nmidRTPR[0], &amp;nmidRTPR[1]}; <br> <br>    Assert(pRouteData); <br> <br>    ZeroMemory(&amp;spvRTProp, 2*sizeof(SPropValue)); <br> <br>    /* if this is a new message, get PropIDs */ <br>    if(pRouteData-&gt;bNewMessage) <br>    { <br>        nmidRTPR[0].lpguid = (LPGUID)&amp;PS_PUBLIC_STRINGS; <br>        nmidRTPR[0].ulKind = MNID_STRING; <br>        nmidRTPR[0].Kind.lpwstrName =   L"CURRENT_RT_RECIP"; <br>        nmidRTPR[1].lpguid = (LPGUID)&amp;PS_PUBLIC_STRINGS; <br>        nmidRTPR[1].ulKind = MNID_STRING; <br>        nmidRTPR[1].Kind.lpwstrName =   L"TOTAL_RT_RECIP"; <br> <br>        hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt;GetIDsFromNames(pRouteData-&gt;pmsgRouteMsg, 2, pnmidRTPR, MAPI_CREATE, &amp;lpsptProp); <br>        if(S_OK != GetScode(hr)) <br>        { <br>            DebugTraceResult(GetIDsFromNames, hr); <br>            goto err; <br>        } <br> <br>        lpsptProp-&gt;aulPropTag[0] = PROP_TAG(PT_LONG, PROP_ID(lpsptProp-&gt;aulPropTag[0])); <br>        lpsptProp-&gt;aulPropTag[1] = PROP_TAG(PT_LONG, PROP_ID(lpsptProp-&gt;aulPropTag[1])); <br> <br>        spvRTProp[0].ulPropTag = lpsptProp-&gt;aulPropTag[0]; <br>        spvRTProp[1].ulPropTag = lpsptProp-&gt;aulPropTag[1]; <br>    } <br>    else /* if we created this msg from one in the inbox, we already have the PropIDs*/ <br>    { <br>        spvRTProp[0].ulPropTag = pRouteData-&gt;tagCurrent; <br>        spvRTProp[1].ulPropTag = pRouteData-&gt;tagTotal; <br> <br>    } <br> <br>    spvRTProp[0].Value.l = pRouteData-&gt;nCurrentRouteRecip; <br>    spvRTProp[1].Value.l = pRouteData-&gt;nTotalRouteRecip; <br> <br>    hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt;SetProps(pRouteData-&gt;pmsgRouteMsg, 2, spvRTProp, &amp;pProblems); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        if(pProblems) <br>        { <br>            DebugTraceProblems("Client: ", pProblems); <br>            MAPIFreeBuffer(pProblems); <br>            pProblems = NULL; <br>        } <br>        DebugTraceResult(SetProps, hr); <br>        goto err; <br>    } <br> <br> <br>err: <br>    MAPIFreeBuffer(lpsptProp); <br> <br>    return !hr; <br>} <br> <br> <br>void InitRouteNameIDArray(ULONG iRecip, LPMAPINAMEID  lpPropNames) <br>{ <br>    ULONG idx; <br> <br>    Assert (lpPropNames); <br>    for(idx = 0; idx &lt; ROUTEPROPSETDIM; ++idx) <br>    { <br>        lpPropNames[idx].lpguid = (LPGUID)lpguidA[idx]; <br>        lpPropNames[idx].ulKind = MNID_ID; <br>        lpPropNames[idx].Kind.lID = iRecip; <br>    } <br>} <br> <br>BOOL GetRoutePropTagArray(ULONG iRecip, LPMESSAGE   lpM, LPSPropTagArray FAR * lppspta) <br>{ <br>    MAPINAMEID nmidA[ROUTEPROPSETDIM]; <br>    LPMAPINAMEID  lppnmidA[5]; <br>    HRESULT hr; <br>    ULONG *pulptPropTag = NULL; <br>    UINT ulidx = 0; <br> <br>    Assert(lpM); <br> <br>    /*First create the 5 prop names and get IDs for them*/ <br>    for(ulidx = 0; ulidx &lt; ROUTEPROPSETDIM; ++ulidx) <br>        lppnmidA[ulidx] = &amp;nmidA[ulidx]; <br>    InitRouteNameIDArray(iRecip, nmidA); <br>    hr = lpM-&gt;lpVtbl-&gt;GetIDsFromNames(lpM, ROUTEPROPSETDIM, lppnmidA, <br>                                        MAPI_CREATE, lppspta); <br> <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTraceResult(GetIDsFromNames, hr); <br>        return FALSE; <br>    } <br>    Assert((*lppspta)-&gt;cValues == ROUTEPROPSETDIM); <br> <br>    /*Now add right prop types */ <br>    ulidx = 0; <br>    for(pulptPropTag = (*lppspta)-&gt;aulPropTag; <br>        pulptPropTag &lt; (*lppspta)-&gt;aulPropTag + ROUTEPROPSETDIM; ++pulptPropTag, ++ulidx) <br>    { <br>     *pulptPropTag =  PROP_TAG(ulRoutePropTypes[ulidx], PROP_ID(*pulptPropTag)); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/* the output PropTag array contains nTotalRecip * ROUTEPROPSETDIM + 1 <br> * prop tags. The last one is PR_NULL. <br> */ <br>BOOL GetRoutePropTagArrayFast(ULONG nTotalRecip, LPMESSAGE lpM, BOOL fCreate, <br>                                LPSPropTagArray FAR * lppspta) <br>{ <br>    LPMAPINAMEID pnmid = NULL; <br>    LPMAPINAMEID * ppnmid = NULL; <br>    HRESULT hr; <br>    ULONG *pulptPropTag = NULL; <br>    UINT ulidx = 0; <br>    /*//$ hack!!!  +1 is to save a spot for PR_RECIPIENT_TYPE */ <br>    UINT nTotalProps = nTotalRecip * ROUTEPROPSETDIM + 1; <br>     <br> <br>    Assert(lpM); <br> <br>    if(hr = ResultFromScode(MAPIAllocateBuffer(nTotalProps * sizeof(MAPINAMEID), <br>                            (LPVOID FAR *)&amp;pnmid))) <br>        return FALSE; <br> <br>    ZeroMemory(pnmid, nTotalProps * sizeof(MAPINAMEID)); <br> <br>    if(hr = ResultFromScode(MAPIAllocateBuffer(nTotalProps * sizeof(LPMAPINAMEID), <br>                            (LPVOID FAR *)&amp;ppnmid))) <br>        goto err; <br> <br>    for(ulidx = 0; ulidx &lt; nTotalProps; ++ulidx) <br>        ppnmid[ulidx] = &amp;pnmid[ulidx]; <br> <br>    for(ulidx = 0; ulidx &lt; nTotalRecip; ++ulidx ) <br>        InitRouteNameIDArray(ulidx, &amp;pnmid[ulidx * ROUTEPROPSETDIM]); <br> <br>    //put someting reasonable in <br>    pnmid[nTotalProps-1].lpguid = (LPGUID)lpguidA[0]; <br>    pnmid[nTotalProps-1].ulKind = MNID_ID; <br>    pnmid[nTotalProps-1].Kind.lID = 0; <br> <br>    hr = lpM-&gt;lpVtbl-&gt;GetIDsFromNames(lpM, nTotalProps, ppnmid, <br>                        fCreate? MAPI_CREATE : 0, lppspta); <br>    if(hr) /* treat warnings as errors */ <br>        goto err; <br> <br>    Assert((*lppspta)-&gt;cValues == nTotalProps); <br>     <br>    ulidx = 0; <br>    for(pulptPropTag = (*lppspta)-&gt;aulPropTag; <br>        pulptPropTag &lt; (*lppspta)-&gt;aulPropTag + nTotalProps - 1; <br>        ++pulptPropTag , ++ulidx) <br>    { <br>        *pulptPropTag = PROP_TAG(ulRoutePropTypes[ulidx % ROUTEPROPSETDIM], <br>                                PROP_ID(*pulptPropTag)); <br>    } <br> <br>    *pulptPropTag = PR_NULL; <br>     <br>err: <br>    MAPIFreeBuffer(pnmid); <br>    MAPIFreeBuffer(ppnmid); <br>         <br>    DebugTraceResult(ROUTECLI_GetRoutePropTagArray, hr); <br>    return (hr? FALSE : TRUE); <br>} <br> <br>BOOL OpenOutFolder(HWND hWnd, LPMAPIFOLDER FAR * lppF) <br>{ <br>    LPMAPIFOLDER lpfOutF = NULL; <br>    HRESULT hr; <br>    LPSPropValue lpspvFEID = NULL; <br>    ULONG  ulObjType = 0; <br> <br>    Assert(pmdb); <br> <br>    *lppF = NULL; <br>    hr = HrGetOneProp((LPMAPIPROP) pmdb, PR_IPM_OUTBOX_ENTRYID, &amp;lpspvFEID); <br>    if(hr) <br>    { <br>        DebugTrace("Client: HrGetOneProp failed (OpneOutFolder)"); <br>        goto err; <br>    } <br> <br>    Assert(lpspvFEID-&gt;ulPropTag == PR_IPM_OUTBOX_ENTRYID); <br> <br>    hr = pmdb-&gt;lpVtbl-&gt;OpenEntry(pmdb, lpspvFEID-&gt;Value.bin.cb, <br>                        (LPENTRYID)lpspvFEID-&gt;Value.bin.lpb, NULL, <br>                        MAPI_MODIFY | MAPI_DEFERRED_ERRORS, <br>                        &amp;ulObjType, (LPUNKNOWN FAR *) &amp;lpfOutF); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTrace("Client: OpenEntry (OpenOutFolder)"); <br>        goto err; <br>    } <br> <br>    *lppF = lpfOutF; <br> <br> <br>err: <br>    MAPIFreeBuffer(lpspvFEID); <br>    if(hr) <br>        MakeMessageBox(hWnd, GetScode(hr), IDS_OPENOUTB, NULL, MBS_ERROR); <br> <br>    return !hr; <br> <br>} <br> <br>BOOL CreateOutMessage(LPMESSAGE FAR * lpmM) <br>{ <br> <br>    LPMESSAGE lpmResM = NULL; <br>    HRESULT hr; <br> <br>    Assert(pfldOutBox); <br> <br>    hr = pfldOutBox-&gt;lpVtbl-&gt;CreateMessage(pfldOutBox, NULL, MAPI_DEFERRED_ERRORS, <br>                                            &amp;lpmResM); <br> <br>    if(S_OK != GetScode(hr)) return FALSE; <br> <br>    *lpmM = lpmResM; <br> <br>    return TRUE; <br>} <br> <br>BOOL MakeNewRouteMessage(LPMESSAGE pmsgRead, LPROUTEDATA FAR * ppRouteData) <br>{ <br>    HRESULT hr; <br>    LPROUTEDATA pRouteData = NULL; <br>    LPSPropProblemArray pProblems = NULL; <br> <br>    if(MAPIAllocateBuffer(sizeof(ROUTEDATA), (LPVOID FAR *) &amp;pRouteData)) <br>    { <br>        return FALSE; <br>    } <br>    ZeroMemory(pRouteData, sizeof(ROUTEDATA)); <br> <br>    if(!CreateOutMessage(&amp;pRouteData-&gt;pmsgRouteMsg)) <br>    { <br>        goto err; <br>    } <br> <br>    if(!pmsgRead)   /*if called  to create a new message*/ <br>    { <br>        pRouteData-&gt;bNewMessage = TRUE; <br>        *ppRouteData = pRouteData; <br>        return TRUE; <br>    } <br> <br>     pRouteData-&gt;bNewMessage = FALSE; <br> <br>    /* include attachments*/ <br>    sptExcludedProps.cValues = EXCLUDED_PROPS_ON_REPLY - 1; <br> <br>    hr = pmsgRead-&gt;lpVtbl-&gt;CopyTo(pmsgRead, 0, NULL, <br>                                  (LPSPropTagArray)&amp;sptExcludedProps, <br>                                  0, NULL, &amp;IID_IMessage, <br>                                  pRouteData-&gt;pmsgRouteMsg, 0, &amp;pProblems); <br> <br>    if(HR_FAILED(hr)) <br>    { <br>        if(pProblems) <br> <br>        { <br>            DebugTraceProblems("Client: ", pProblems); <br>            MAPIFreeBuffer(pProblems); <br>            pProblems = NULL; <br>        } <br> <br>        goto err; <br>    } <br> <br>    if(!GetRouteIndices(pRouteData)) <br>    { <br>        goto err; <br>    } <br> <br>    if(!GetRouteAddrLists(pRouteData)) <br>    { <br>        goto err; <br>    } <br> <br>    *ppRouteData = pRouteData; <br> <br>    return TRUE; <br> <br>err: <br>    UlRelease(pRouteData-&gt;pmsgRouteMsg); <br>    MAPIFreeBuffer(pRouteData); <br>    *ppRouteData = NULL; <br>    return FALSE; <br>} <br> <br>/*Assumes that members nCurrentRouteRecip and nTotalRouteRecip were succesfully <br> *set. Initializes palAddrListActive and palAddrListOld. <br> */ <br> <br>BOOL GetRouteAddrLists(LPROUTEDATA pRouteData) <br>{ <br>    LPSPropTagArray lpspta = NULL; <br>//  SizedSPropTagArray((ROUTEPROPSETDIM + 1), sspta); <br>    LPADRLIST lpalOld = NULL; <br>    LPADRLIST lpalActive = NULL; <br>    ULONG cbal = 0; <br>    HRESULT hr; <br>    UINT ulidx, ulidx1; <br>    ULONG cActiveRecip ; <br>    LPMESSAGE pmsg; <br>    ULONG cvalAllProps = 0; <br>    LPSPropValue pvalAllProps = NULL; <br>     <br>    Assert(pRouteData); <br>    Assert(!pRouteData-&gt;palAddrListActive); <br>    Assert(!pRouteData-&gt;palAddrListOld); <br> <br>    pmsg = pRouteData-&gt;pmsgRouteMsg; <br>    Assert(pmsg); <br>     <br>    if(!GetRoutePropTagArrayFast(pRouteData-&gt;nTotalRouteRecip, <br>                            pmsg, <br>                            FALSE, <br>                            &amp;lpspta)) <br>        goto err; <br>         <br>    /* hack!! the output PropTag array contains nTotalRecip * ROUTEPROPSETDIM + 1 <br>     * prop tags. The last one is PR_NULL. We do this to reserve a spot for <br>     * PR_RECIPIENT_TYPE <br>     */ <br> <br>    hr = pmsg-&gt;lpVtbl-&gt;GetProps(pmsg, lpspta, 0, &amp;cvalAllProps, &amp;pvalAllProps); <br>    MAPIFreeBuffer(lpspta); <br>    lpspta=NULL; <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    Assert(cvalAllProps == pRouteData-&gt;nTotalRouteRecip * ROUTEPROPSETDIM + 1); <br> <br>    // <br>    // In case somebody does not handle PR_NULL in GetProps <br>    // <br>    pvalAllProps[cvalAllProps - 1].ulPropTag = PR_NULL; <br>     <br>    cActiveRecip = pRouteData-&gt;nTotalRouteRecip - pRouteData-&gt;nCurrentRouteRecip; <br> <br>    /*First do the recipients already routed to */ <br>    cbal =  CbNewADRLIST(pRouteData-&gt;nCurrentRouteRecip); <br>    if (MAPIAllocateBuffer(cbal, &amp;lpalOld)) <br>        goto err; <br>    ZeroMemory(lpalOld, cbal); <br> <br>    lpalOld-&gt;cEntries = pRouteData-&gt;nCurrentRouteRecip; <br> <br>    for(ulidx = 0; ulidx &lt; pRouteData-&gt;nCurrentRouteRecip; ++ulidx) <br>    { <br>        LPSPropValue pval = NULL; <br> <br>        hr = ResultFromScode(ScDupPropset(ROUTEPROPSETDIM +1, <br>                                &amp;pvalAllProps[ulidx * ROUTEPROPSETDIM], <br>                                MAPIAllocateBuffer, <br>                                &amp;pval)); <br>         <br>        if(hr) <br>            goto err; <br>             <br>        lpalOld-&gt;aEntries[ulidx].rgPropVals = pval; <br>        lpalOld-&gt;aEntries[ulidx].cValues = ROUTEPROPSETDIM + 1; <br>             <br>        for(ulidx1 = 0; ulidx1 &lt; ROUTEPROPSETDIM; ++ulidx1) <br>        { <br>            pval[ulidx1].ulPropTag = sptRouteProps.aulPropTag[ulidx1]; <br>            pval[ulidx1].dwAlignPad = 0; <br>        } <br>        /*Have to set RECIPIENT_TYPE in order for IAddressBook::Address to show the <br>          recipient in one of its listboxes*/ <br>        pval[ROUTEPROPSETDIM].ulPropTag = PR_RECIPIENT_TYPE; <br>        pval[ROUTEPROPSETDIM].dwAlignPad = 0; <br>        pval[ROUTEPROPSETDIM].Value.l = MAPI_TO; <br> <br>    } <br>     <br>    if(cActiveRecip == 0) <br>    { <br>        pRouteData-&gt;palAddrListOld = lpalOld; <br>        pRouteData-&gt;palAddrListActive = NULL; <br>        goto ret; <br>    } <br> <br>    /*Now the same for palAddrListActive*/ <br>    cbal =  CbNewADRLIST(cActiveRecip); <br>    if (MAPIAllocateBuffer(cbal, &amp;lpalActive)) <br>        goto err; <br>    memset(lpalActive, 0, cbal); <br>    lpalActive-&gt;cEntries = cActiveRecip; <br>    for(ulidx = 0; ulidx &lt; cActiveRecip; ++ulidx) <br>    { <br>        LPSPropValue pval = NULL; <br> <br>        hr = ResultFromScode(ScDupPropset(ROUTEPROPSETDIM +1, <br>                            &amp;pvalAllProps[(ulidx + pRouteData-&gt;nCurrentRouteRecip) * <br>                                                ROUTEPROPSETDIM], <br>                                MAPIAllocateBuffer, <br>                                &amp;pval)); <br>         <br>        if(hr) <br>            goto err; <br>             <br>        lpalActive-&gt;aEntries[ulidx].rgPropVals = pval; <br>        lpalActive-&gt;aEntries[ulidx].cValues = ROUTEPROPSETDIM + 1; <br>             <br>        for(ulidx1 = 0; ulidx1 &lt; ROUTEPROPSETDIM; ++ulidx1) <br>        { <br>            pval[ulidx1].ulPropTag = sptRouteProps.aulPropTag[ulidx1]; <br>            pval[ulidx1].dwAlignPad = 0; <br>        } <br>        /*Have to set RECIPIENT_TYPE in order for IAddressBook::Address to show the <br>          recipient in one of its listboxes*/ <br>        pval[ROUTEPROPSETDIM].ulPropTag = PR_RECIPIENT_TYPE; <br>        pval[ROUTEPROPSETDIM].dwAlignPad = 0; <br>        pval[ROUTEPROPSETDIM].Value.l = MAPI_TO; <br> <br>    } <br> <br>    pRouteData-&gt;palAddrListOld = lpalOld; <br>    pRouteData-&gt;palAddrListActive = lpalActive; <br> <br>ret: <br>    MAPIFreeBuffer(pvalAllProps); <br>    return TRUE; <br>err: <br>    FreePadrlist(lpalOld); <br>    FreePadrlist(lpalActive); <br>    MAPIFreeBuffer(pvalAllProps); <br>     <br>    return FALSE; <br>} <br> <br> <br>/*deletes all the props corresponding to the entries in palAddrListActive*/ <br>BOOL  DelRouteProps(LPROUTEDATA pRouteData) <br>{ <br>    UINT ulidx; <br>    LPSPropTagArray lpsptaRouteTags = NULL; <br>    LPSPropProblemArray lpsppaProblems = NULL; <br>    HRESULT hr = hrSuccess; <br> <br>    if(!pRouteData-&gt;palAddrListActive) return TRUE; <br> <br> <br>    Assert(pRouteData); <br>    Assert(pRouteData-&gt;pmsgRouteMsg); <br> <br>    for(ulidx = pRouteData-&gt;nCurrentRouteRecip; ulidx &lt; pRouteData-&gt;nTotalRouteRecip; ++ulidx) <br>    { <br>        if(!GetRoutePropTagArray(ulidx, pRouteData-&gt;pmsgRouteMsg, &amp;lpsptaRouteTags)) <br>        { <br>            /* <br>            //$ even if it gives an error still have to go through all of them*/ <br>            continue; <br>        } <br>        hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt;DeleteProps(pRouteData-&gt;pmsgRouteMsg, lpsptaRouteTags, &amp;lpsppaProblems); <br>        /* even if it gives an error still have to go through all of them*/ <br>        if(lpsppaProblems) <br>        { <br>            DebugTraceProblems("Client:", lpsppaProblems); <br>            MAPIFreeBuffer(lpsppaProblems); <br>            lpsppaProblems = NULL; <br>        } <br> <br>        MAPIFreeBuffer(lpsptaRouteTags); <br> <br>        lpsptaRouteTags = NULL; <br> <br>    } <br> <br>    return (S_OK == GetScode(hr)); <br>} <br> <br>BOOL SetRouteProps(LPROUTEDATA pRouteData) <br>{ <br>    //SPropValue pspvRouteProps[ROUTEPROPSETDIM]; <br>    LPSPropTagArray lpsptaRouteTags = NULL; <br>    ULONG cRouteRecip; <br>    LPADRENTRY lpae = NULL; <br>    LPSPropValue lpspv = NULL; <br>    UINT ulidx; <br>    LPSPropProblemArray lpsppaProblems = NULL; <br>    HRESULT hr; <br>    UINT cNewRecips = 0; <br>    LPSPropValue pvalAll = NULL; <br>    LPSPropValue pval = NULL; <br> <br>    Assert(pRouteData); <br>    if(!pRouteData-&gt;palAddrListActive) return TRUE; <br> <br>    cRouteRecip = pRouteData-&gt;nCurrentRouteRecip; <br> <br>    if(!GetRoutePropTagArrayFast( <br>                cRouteRecip + pRouteData-&gt;palAddrListActive-&gt;cEntries, <br>                pRouteData-&gt;pmsgRouteMsg, <br>                TRUE, <br>                &amp;lpsptaRouteTags)) <br>    { <br>        hr = ResultFromScode(E_FAIL); <br>        goto err; <br>    } <br> <br>    if(hr = MAPIAllocateBuffer( <br>                    pRouteData-&gt;palAddrListActive-&gt;cEntries * ROUTEPROPSETDIM * <br>                        sizeof(SPropValue), (LPVOID *) &amp;pvalAll)) <br>        goto err; <br> <br>    ZeroMemory(pvalAll, pRouteData-&gt;palAddrListActive-&gt;cEntries * <br>                        ROUTEPROPSETDIM * sizeof(SPropValue)); <br> <br>    /* get required properties missing in AddrlistActive*/ <br>    hr = pabAddrB-&gt;lpVtbl-&gt;PrepareRecips(pabAddrB, 0, (LPSPropTagArray)&amp;sptRouteProps, <br>                                                        pRouteData-&gt;palAddrListActive); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTrace("Client: PrepareRecips failed"); <br>        goto err; <br>    } <br>     <br>    for(lpae = pRouteData-&gt;palAddrListActive-&gt;aEntries, <br>            pval = pvalAll, cNewRecips = 0; <br>        lpae &lt; pRouteData-&gt;palAddrListActive-&gt;aEntries + <br>                pRouteData-&gt;palAddrListActive-&gt;cEntries; <br>            ++lpae ) <br>    { <br>        if(!lpae-&gt;rgPropVals) <br>        { <br>            continue; <br>        } <br> <br>        ++cNewRecips; <br>                 <br>        Assert(lpae-&gt;rgPropVals[ROUTEPROPSET_EMAIL_ADDRESS].ulPropTag == PR_EMAIL_ADDRESS); <br>        pval[ROUTEPROPSET_EMAIL_ADDRESS].Value.LPSZ = <br>            lpae-&gt;rgPropVals[ROUTEPROPSET_EMAIL_ADDRESS].Value.LPSZ; <br> <br>        Assert(lpae-&gt;rgPropVals[ROUTEPROPSET_ADDRTYPE].ulPropTag == PR_ADDRTYPE); <br>        pval[ROUTEPROPSET_ADDRTYPE].Value.LPSZ = <br>            lpae-&gt;rgPropVals[ROUTEPROPSET_ADDRTYPE].Value.LPSZ; <br> <br>        Assert(lpae-&gt;rgPropVals[ROUTEPROPSET_DISPLAY_NAME].ulPropTag == PR_DISPLAY_NAME); <br>        pval[ROUTEPROPSET_DISPLAY_NAME].Value.LPSZ = <br>            lpae-&gt;rgPropVals[ROUTEPROPSET_DISPLAY_NAME].Value.LPSZ; <br>         <br>        Assert(lpae-&gt;rgPropVals[ROUTEPROPSET_ENTRYID].ulPropTag == PR_ENTRYID); <br>        pval[ROUTEPROPSET_ENTRYID].Value = <br>            lpae-&gt;rgPropVals[ROUTEPROPSET_ENTRYID].Value; <br> <br>        Assert(lpae-&gt;rgPropVals[ROUTEPROPSET_SEARCH_KEY].ulPropTag == PR_SEARCH_KEY); <br>        pval[ROUTEPROPSET_SEARCH_KEY].Value = <br>            lpae-&gt;rgPropVals[ROUTEPROPSET_SEARCH_KEY].Value; <br> <br>        pval += ROUTEPROPSETDIM; <br>    } <br> <br>     <br>    for(ulidx = cRouteRecip * ROUTEPROPSETDIM, pval = pvalAll; <br>         ulidx &lt; (cRouteRecip + cNewRecips)*ROUTEPROPSETDIM; <br>         ++pval, ++ulidx) <br>    { <br>        pval-&gt;ulPropTag = lpsptaRouteTags-&gt;aulPropTag[ulidx]; <br>    } <br> <br>    hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt;SetProps( <br>                                            pRouteData-&gt;pmsgRouteMsg, <br>                                            cNewRecips * ROUTEPROPSETDIM, <br>                                            pvalAll, <br>                                            &amp;lpsppaProblems); </code></pre>
<p>
</p>
<pre><code><br> <br>    if(S_OK != GetScode(hr)) <br>    { <br>         <br>        DebugTraceResult(SetProps, hr); <br>        goto err; <br>    } <br> <br>    if(lpsppaProblems) <br>    { <br>        DebugTraceProblems("Client: SetProps", lpsppaProblems); <br>        MAPIFreeBuffer(lpsppaProblems); <br>        lpsppaProblems = NULL; <br>    } <br> <br> <br>    MAPIFreeBuffer(lpsptaRouteTags); <br>    lpsptaRouteTags = NULL; <br> <br> <br>    pRouteData-&gt;nTotalRouteRecip = pRouteData-&gt;nCurrentRouteRecip + cNewRecips; <br> <br>    ++(pRouteData-&gt;nCurrentRouteRecip); <br>    if(!SetRouteIndices(pRouteData)) <br>    { <br>        hr = ResultFromScode(E_FAIL); <br>        goto err; <br>    } <br> <br>     <br>err: <br>    MAPIFreeBuffer(lpsptaRouteTags); <br>    MAPIFreeBuffer(lpsppaProblems); <br>    MAPIFreeBuffer(pvalAll); <br>    return ( hr ? FALSE : TRUE); <br>} <br> <br>BOOL SetMessageClass(LPMESSAGE lpM, LPSTR lpszClass) <br>{ <br>    HRESULT hr; <br>    SPropValue spvProp; <br> <br>    spvProp.ulPropTag = PR_MESSAGE_CLASS; <br>    spvProp.dwAlignPad = 0; <br>    spvProp.Value.LPSZ = lpszClass; <br> <br>    Assert(lpM); <br> <br>    hr = HrSetOneProp((LPMAPIPROP)lpM, &amp;spvProp); <br>    if(hr) <br>    { <br>        DebugTrace("Client: HrSetOneProp failed (SetMessageClass)"); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/* this functions works correctly only for received (saved) msgs*/ <br>/*BOOL HasAttachment(LPMESSAGE lpM) <br>{ <br>    HRESULT hr; <br>    LPSPropValue lpspvProp = NULL; <br>    LONG lflags = 0; <br> <br>    Assert(lpM); <br> <br>    hr = HrGetOneProp((LPMAPIPROP) lpM, PR_MESSAGE_FLAGS, &amp;lpspvProp); <br>    if(hr) <br>    { <br>        DebugTrace("Client: HrGetOneProp failed (hasattachment)"); <br>        goto err; <br>    } <br> <br>    lflags = lpspvProp-&gt;Value.l; <br> <br>err: <br>    MAPIFreeBuffer(lpspvProp); <br> <br>    return lflags &amp; MSGFLAG_HASATTACH; <br>}*/ <br> <br>BOOL PopulateAttachList(HWND hDlg, LPROUTEDATA pRouteData) <br>{ <br>    SizedSPropTagArray (1, sptAttachNum) =  {   1,  {PR_ATTACH_NUM}  }; <br>    LPSRowSet lprsRows = NULL; <br>    LPATTACH lpAttach = NULL; <br>    HRESULT hr; <br>    UINT idx, lbidx; <br>    LPSPropValue lpProp = NULL; <br>    SPropValue spvPosProp = {0}; <br>    spvPosProp.ulPropTag = PR_RENDERING_POSITION; <br>    spvPosProp.Value.l = -1; <br> <br>    Assert(pRouteData); <br>    Assert(pRouteData-&gt;pmsgRouteMsg); <br> <br>    hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt; <br>            GetAttachmentTable(pRouteData-&gt;pmsgRouteMsg, 0, <br>                                &amp;pRouteData-&gt;ptblAttach); <br>    if(S_OK != hr) <br>    { <br>        DebugTrace("Client: GetAttachmentTable failed (PopulateAttachList)"); <br>        goto err; <br>    } <br> <br>    hr = HrQueryAllRows(pRouteData-&gt;ptblAttach, (LPSPropTagArray)&amp;sptAttachNum, NULL, <br>                                        NULL, 0, &amp;lprsRows); <br>    if(S_OK != hr) <br>    { <br>        DebugTrace("Client: QueryAllRows failed (PopulateAttachList)"); <br>        goto err; <br>    } <br> <br>    if(!lprsRows || !(lprsRows-&gt;cRows)) goto err; <br> <br>    for(idx = 0; idx &lt; lprsRows-&gt;cRows; ++idx) <br>    { <br>        Assert(lprsRows-&gt;aRow[idx].cValues == 1); <br>        Assert(lprsRows-&gt;aRow[idx].lpProps-&gt;ulPropTag == PR_ATTACH_NUM); <br> <br>        hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt; <br>            OpenAttach(pRouteData-&gt;pmsgRouteMsg, <br>                            lprsRows-&gt;aRow[idx].lpProps-&gt;Value.l, <br>                        NULL, MAPI_MODIFY | MAPI_DEFERRED_ERRORS, &amp;lpAttach); <br>        if(S_OK != hr) <br>        { <br>            DebugTrace("Client: openattach failed (PopulateAttachList)"); <br>            goto err; <br>        } <br> <br>        hr = HrGetOneProp((LPMAPIPROP)lpAttach, PR_DISPLAY_NAME, &amp;lpProp); <br>        if(hr) <br>        { <br>            DebugTrace("Client: HrGetOneProp failed (PopulateAttachList)"); <br>            goto err; <br>        } <br>        lbidx = ListBox_AddString(GetDlgItem(hDlg, IDC_RTATTACHLIST), lpProp-&gt;Value.LPSZ); <br>        if(LB_ERR != lbidx) <br>        { <br>            ListBox_SetItemData(GetDlgItem(hDlg, IDC_RTATTACHLIST), lbidx, <br>                                    lprsRows-&gt;aRow[idx].lpProps-&gt;Value.l); <br>        } <br> <br>        MAPIFreeBuffer(lpProp); <br>        lpProp = NULL; <br> <br>        /* in received msgs attachment positions are not -1 any more. <br>            Set them to -1 again*/ <br>        hr = HrSetOneProp((LPMAPIPROP)lpAttach, &amp;spvPosProp); <br>        if(!hr) <br>        { <br>            hr = lpAttach-&gt;lpVtbl-&gt;SaveChanges(lpAttach, 0); <br>        } <br>        lpAttach-&gt;lpVtbl-&gt;Release(lpAttach); <br>        lpAttach = NULL; <br>    } <br> <br>err: <br> <br>    FreeProws(lprsRows); <br>    lprsRows = NULL; <br> <br>    UlRelease(lpAttach); <br> <br>    MAPIFreeBuffer(lpProp); <br> <br>    return (S_OK == GetScode(hr)); <br>} <br> <br>BOOL CreateNewAttachment(HWND hDlg) <br>{ <br>    OPENFILENAME ofn; <br>    char szFileName[MAX_PATH] = ""; <br>    char szFilter[256]; <br>    static char szFileTitle[16] = ""; <br>    static char szDirName[256] = ""; <br>    LPSTR lpszEndPath; <br>    UINT idx, lbidx; <br>    HRESULT hr; <br>    LPROUTEDATA pRouteData = NULL; <br> <br>    enum { REND_POS, PATH_NAME, ATT_METHOD, DISP_NAME, ATT_FILENAME, ATT_DIM}; <br> <br>    SizedSPropTagArray(ATT_DIM , sptAttachTags) = <br>    { ATT_DIM, <br>        {   PR_RENDERING_POSITION, PR_ATTACH_PATHNAME, <br>            PR_ATTACH_METHOD, PR_DISPLAY_NAME, PR_ATTACH_FILENAME } <br>    }; <br>    SPropValue spvAttachProps[ATT_DIM]; <br> <br>    LPATTACH lpAttach = NULL; <br>    ULONG ulAttachNum = 0; <br> <br>    pRouteData = (LPROUTEDATA)GetWindowLong(hDlg, GWL_USERDATA); <br>    Assert(pRouteData); <br>     <br>#ifndef WIN16 <br>    if (!szDirName[0]) <br>        GetCurrentDirectory (255, (LPSTR) szDirName); <br>    else <br>#endif <br>        lstrcpy (szFileName, szFileTitle); <br> <br>    if(!LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter))) <br>    { <br>        DebugTrace("Client: failed to load a string"); <br>        return FALSE; <br>    } <br> <br>    for (idx = 0; szFilter[idx] != '\0'; idx++) <br>        if (szFilter[idx] == '|') <br>            szFilter[idx] = '\0'; <br> <br>    ofn.lStructSize = sizeof (OPENFILENAME); <br>    ofn.hwndOwner = 0; <br>    ofn.hInstance = 0; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1L; <br>    ofn.lpstrFile = szFileName; <br>    ofn.nMaxFile = 256; <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = 16; <br>    ofn.lpstrInitialDir = szDirName; <br>    ofn.lpstrTitle = "Attach"; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = NULL; <br>    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST; <br> <br>    if (!GetOpenFileName (&amp;ofn)) <br>        return FALSE; <br> <br>    /* Save the directory for the next time we call this */ <br> <br>    lstrcpy (szDirName, szFileName); <br>    if (lpszEndPath = SzFindLastCh(szDirName, '\\')) <br>        *(lpszEndPath) = '\0'; <br> <br>    hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt;CreateAttach(pRouteData-&gt;pmsgRouteMsg, <br>                                 NULL, MAPI_DEFERRED_ERRORS, &amp;ulAttachNum, &amp;lpAttach); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTrace("Client: CreateAttach failed (CreateNewAttach)"); <br>        return FALSE; <br>    } <br> <br>    for(idx = 0; idx &lt; ATT_DIM; ++idx) <br>    { <br>        spvAttachProps[idx].ulPropTag = sptAttachTags.aulPropTag[idx]; <br>        spvAttachProps[idx].dwAlignPad = 0; <br>    } <br> <br>    spvAttachProps[REND_POS].Value.l = -1; <br>    spvAttachProps[PATH_NAME].Value.LPSZ = szFileName; <br>    spvAttachProps[ATT_METHOD].Value.l = ATTACH_BY_REF_RESOLVE; <br>    /* ATTACH_BY_REF_RESOLVE means the spooler wiil reslove the attachment into ATTACH_BY_VALUE <br>        and place the attachment data in PR_ATTACH_DATA_BIN */ <br>    spvAttachProps[DISP_NAME].Value.LPSZ = szFileTitle; <br>    spvAttachProps[ATT_FILENAME].Value.LPSZ = szFileTitle; <br> <br>    hr = lpAttach-&gt;lpVtbl-&gt;SetProps(lpAttach, ATT_DIM, spvAttachProps, NULL); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTrace("Client: SetProp failed (createnewattachment)"); <br>        goto err; <br>    } <br> <br>    hr = lpAttach-&gt;lpVtbl-&gt;SaveChanges(lpAttach, MAPI_DEFERRED_ERRORS); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTrace("Client: SaveChanges failed (createnewattachment)"); <br>        goto err; <br>    } <br> <br>    lbidx = ListBox_AddString(GetDlgItem(hDlg, IDC_RTATTACHLIST), szFileTitle); <br>    if(LB_ERR != lbidx) <br>    { <br>        /*Store the attachment # with its name in the listbox*/ <br>        ListBox_SetItemData(GetDlgItem(hDlg, IDC_RTATTACHLIST), lbidx, <br>                                    ulAttachNum); <br>    } <br> <br>err: <br>    UlRelease(lpAttach); <br> <br>    return (S_OK == GetScode(hr)); <br>} <br> <br>void SaveAttachment( HWND hDlg, UINT itemindx) <br>{ <br>    OPENFILENAME ofn; <br>    char szFileName[256] = ""; <br>    char szFilter[256]; <br>    static char szFileTitle[16]; <br>    static char szDirName[256] = ""; <br>    LPSTR lpszEndPath; <br>    ULONG idx; <br>    HRESULT hr; <br>    LPSPropValue lpProp = NULL; <br>    LPATTACH lpAttach = NULL; <br>    LPSTREAM lpstrAtt=NULL, lpstrFile=NULL; <br>    STATSTG statstg = {0}; <br>    ULONG ulAttachNum; <br>    LPROUTEDATA pRouteData = NULL; <br> <br>    pRouteData = (LPROUTEDATA)GetWindowLong(hDlg, GWL_USERDATA); <br>    if(!pRouteData) <br>    { <br>        DebugTrace("Client: pRouteData == 0 (saveattachment)"); <br>        goto err; <br>    } <br> <br>    if (!szDirName[0]) <br>        GetTempPath (sizeof(szDirName), szDirName); <br> <br>    if(!LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter))) <br>    { <br>        DebugTrace("Client: failed to load a string"); <br>        goto err; <br>    } <br> <br>    for (idx = 0; szFilter[idx] != '\0'; idx++) <br>        if (szFilter[idx] == '|') <br>            szFilter[idx] = '\0'; <br> <br>    ulAttachNum = ListBox_GetItemData(GetDlgItem(hDlg, IDC_RTATTACHLIST), itemindx); <br>    if(LB_ERR == ulAttachNum) <br>    { <br>        DebugTrace("Client: can't get attach num (saveattachment)"); <br>        return; <br>    } <br> <br>    hr = pRouteData-&gt;pmsgRouteMsg-&gt;lpVtbl-&gt; <br>            OpenAttach(pRouteData-&gt;pmsgRouteMsg, ulAttachNum, NULL, <br>                        MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, &amp;lpAttach); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTrace("Client: OpenAttach failed (saveattachment)"); <br>        goto err; <br>    } <br> <br>    hr = HrGetOneProp((LPMAPIPROP)lpAttach, PR_ATTACH_FILENAME, &amp;lpProp); <br>    if(hr) <br>    { <br>        DebugTrace("Client: OpenAttach failed (saveattachment)"); <br>        goto err; <br>    } <br> <br>    lstrcpy (szFileName, lpProp-&gt;Value.LPSZ); <br>    MAPIFreeBuffer(lpProp); <br>    lpProp = NULL; <br> <br>    ofn.lStructSize = sizeof (OPENFILENAME); <br>    ofn.hwndOwner = hDlg; <br>    ofn.hInstance = 0; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1L; <br>    ofn.lpstrFile = szFileName; <br>    ofn.nMaxFile = sizeof(szFileName); <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = sizeof(szFileTitle); <br>    ofn.lpstrInitialDir = szDirName; <br>    ofn.lpstrTitle = "Save Attachment"; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = NULL; <br>    ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY; <br> <br>    if (!GetSaveFileName (&amp;ofn)) <br>        goto err; <br> <br>    /* Save the directory for the next time we call this */ <br> <br>    lstrcpy (szDirName, szFileName); <br>    if (lpszEndPath = SzFindLastCh(szDirName, '\\')) <br>        *(lpszEndPath) = '\0'; <br> <br> <br>    hr = lpAttach-&gt;lpVtbl-&gt;OpenProperty (lpAttach, PR_ATTACH_DATA_BIN, <br>                                        (LPIID)&amp;IID_IStream, <br>                                        0, MAPI_DEFERRED_ERRORS, <br>                                        (LPUNKNOWN *)&amp;lpstrAtt); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        /*must be a new attachment*/ <br>        hr = HrGetOneProp((LPMAPIPROP)lpAttach, PR_ATTACH_PATHNAME, &amp;lpProp); <br>        if(hr) <br>        { <br>            DebugTrace("Client: PR_ATTACH_PATHNAME (saveattach)"); <br>            goto err; <br>        } <br>        CopyFile(lpProp-&gt;Value.LPSZ, szFileName, TRUE); <br>        goto err; <br>    } <br> <br>    hr = OpenStreamOnFile (MAPIAllocateBuffer, MAPIFreeBuffer, <br>                            STGM_CREATE | STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, <br>                            szFileName, NULL, &amp;lpstrFile); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTrace("Client: OpenStreamOnFile failed (saveattachment)"); <br>        goto err; <br>    } <br> <br> <br>    lpstrAtt-&gt;lpVtbl-&gt;Stat(lpstrAtt, &amp;statstg, STATFLAG_NONAME); <br> <br>    hr = lpstrAtt-&gt;lpVtbl-&gt;CopyTo(lpstrAtt, lpstrFile, statstg.cbSize, NULL, NULL); <br>    if(S_OK != GetScode(hr)) <br>    { <br>        DebugTrace("Client: CopyTo failed (saveattachment)"); <br>        goto err; <br>    } <br> <br>err: <br>    UlRelease(lpstrAtt); <br>    UlRelease(lpstrFile); <br>    UlRelease(lpAttach); <br>    MAPIFreeBuffer(lpProp); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
