<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BITMAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2226"></a>BITMAP.C</h2>
<pre><code>/* <br> -  B I T M A P . C <br> - <br> *  Purpose: <br> *      Bitmap and Listbox support functions for InBox in sample mail client. <br> * <br> *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved. <br> */ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef _WIN32 <br>#include &lt;objerror.h&gt; <br>#include &lt;objbase.h&gt; <br>#endif <br>#ifdef WIN16 <br>#include &lt;compobj.h&gt; <br>#endif <br>#include &lt;mapiwin.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include &lt;mapi.h&gt; <br>#include &lt;mapix.h&gt; <br>#include "bitmap.h" <br>#include "client.h" <br> <br>// Fonts to use in dialogs <br> <br>#ifdef _WIN32 <br>#define SHELL_FONT "MS Shell Dlg" <br>#define SHELL_FONT_SIZE 8 <br>#else <br>#define SHELL_FONT "MS Sans Serif" <br>#define SHELL_FONT_SIZE 8 <br>#endif <br> <br>/* <br> *  globals <br> */ <br>  <br>DWORD   rgbWindowColor = 0xFF000000;    // variables for the current <br>DWORD   rgbHiliteColor = 0xFF000000;    // system color settings. <br>DWORD   rgbWindowText  = 0xFF000000;    // on a WM_SYSCOLORCHANGE <br>DWORD   rgbHiliteText  = 0xFF000000;    // we check to see if we need <br>DWORD   rgbGrayText    = 0xFF000000;    // to reload our bitmap. <br>DWORD   rgbDDWindow    = 0xFF000000;    // <br>DWORD   rgbDDHilite    = 0xFF000000;    // 0xFF000000 is an invalid RGB <br> <br>// an array of integers containing the tab stops, in pixels. The tab  <br>// stops must be sorted in ascending order; back tabs are not allowed.  <br> <br>int     rgTabs[] = { 2, 28, 135, 292 }; <br>int     dxbmpLB, dybmpLB;   // dx and dy of listbox bmps <br> <br>HDC     hdcMemory = 0;      // hdc to hold listbox bitmaps (for speed) <br>HBITMAP hbmpOrigMemBmp = 0; // original null bitmap in hdcMemory <br>HBITMAP hbmpLB = 0;         // cached listbox bitmaps <br>HFONT   hfontLB = 0;        // hfont of LB <br>HWND    hwndLB = 0;         // hwnd of LB <br> <br>FONTSTYLE fontStyle = { SHELL_FONT_SIZE, FW_NORMAL, 0, TEXT(SHELL_FONT) }; <br> <br>extern HANDLE hInst; <br> <br> <br>/* <br> -  DeInitBmps <br> -   <br> *  Purpose: <br> *      cleans up LB hfonts, hdc, and hbmps <br> */ <br>  <br>VOID DeInitBmps(VOID) <br>{ <br>    DeleteBitmapLB(); <br>    if(hdcMemory) <br>    { <br>        DeleteDC(hdcMemory); <br>        hdcMemory = 0; <br>    } <br> <br>    if(hfontLB) <br>    { <br>        SetWindowFont(hwndLB, GetStockObject(SYSTEM_FONT), FALSE); <br>        DeleteObject(hfontLB); <br>        hfontLB = 0; <br>    } <br>} <br> <br> <br>/* <br> -  SetLBFont <br> -   <br> *  Purpose: <br> *      creates a font from the global fontStyle <br> *      sets global hfontLB to new font and WM_SETFONTs <br> *      the hwndLB to the new font <br> */ <br>  <br>VOID SetLBFont(VOID) <br>{ <br>    LOGFONT lf; <br> <br>    lf.lfHeight = fontStyle.lfHeight; <br>    lf.lfWidth = 0; <br>    lf.lfEscapement = 0; <br>    lf.lfOrientation = 0; <br>    lf.lfWeight = fontStyle.lfWeight; <br>    lf.lfItalic = fontStyle.lfItalic; <br>    lf.lfUnderline = 0; <br>    lf.lfStrikeOut = 0; <br>    lf.lfCharSet = ANSI_CHARSET; <br>    lf.lfOutPrecision = OUT_DEFAULT_PRECIS; <br>    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS; <br>    lf.lfQuality = DEFAULT_QUALITY; <br>    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS; <br>    lstrcpy(lf.lfFaceName, fontStyle.lfFaceName); <br> <br>    hfontLB = CreateFontIndirect(&amp;lf); <br>    if(hfontLB) <br>        SetWindowFont(hwndLB, hfontLB, FALSE);         <br>} <br> <br> <br>/* <br> -  InitBmps <br> -   <br> *  Purpose: <br> *      inits listbox globals, creates listbox <br> *   <br> *  Arguments: <br> *      HWND    main hwnd of app (parent of LB) <br> *   <br> *  Returns: <br> *      TRUE - success; FALSE - failed <br> */ <br>  <br>BOOL InitBmps(HWND hwnd, int idLB) <br>{ <br>    HDC     hdcScreen; <br>    HBITMAP hbmpTemp; <br> <br>    hdcScreen = GetDC(0); <br>    if(!hdcScreen) <br>        goto CantInit; <br>    hdcMemory = CreateCompatibleDC(hdcScreen); <br>    if(!hdcMemory) <br>        goto ReleaseScreenDC; <br> <br>    hbmpTemp = CreateCompatibleBitmap(hdcMemory, 1, 1); <br>    if(!hbmpTemp) <br>        goto ReleaseMemDC; <br>    hbmpOrigMemBmp = SelectObject(hdcMemory, hbmpTemp); // get hbmp of NULL <br>    if(!hbmpOrigMemBmp)                                 // bmp for hdcMemory <br>        goto ReleaseMemDC;                              // for when we delete <br>    SelectObject(hdcMemory, hbmpOrigMemBmp);            // it later in life <br>    DeleteObject(hbmpTemp); <br>    ReleaseDC(0, hdcScreen); <br> <br>    SetRGBValues();     // set the global RGB values <br>    LoadBitmapLB();     // load the bmps into hdcMemory <br> <br>    hwndLB = GetDlgItem(hwnd, idLB); <br>     <br>    SetLBFont();    // set the font of our listbox <br>    return TRUE; <br> <br>/* Error recovery exits */ <br>ReleaseMemDC: <br>    DeleteDC(hdcMemory); <br>    hdcMemory = 0; <br> <br>ReleaseScreenDC: <br>    ReleaseDC(0, hdcScreen); <br> <br>CantInit: <br>    return FALSE; <br>} <br> <br> <br>/* <br> -  SetRGBValues <br> -   <br> *  Purpose: <br> *      To set various system colors in static variables.  Called at <br> *      init time and when system colors change. <br> */ <br>  <br>VOID SetRGBValues(VOID) <br>{ <br>    rgbWindowColor = GetSysColor(COLOR_WINDOW); <br>    rgbHiliteColor = GetSysColor(COLOR_HIGHLIGHT); <br>    rgbWindowText  = GetSysColor(COLOR_WINDOWTEXT); <br>    rgbHiliteText  = GetSysColor(COLOR_HIGHLIGHTTEXT); <br>    rgbGrayText    = GetSysColor(COLOR_GRAYTEXT); <br>} <br> <br> <br>/* <br> -  MeasureItem <br> -   <br> *  Purpose: <br> *      called from msg WM_MEASUREITEM: returns max dy of listbox items <br> *   <br> *  Arguments: <br> *      HWND        hwnd of main window <br> *      pmis        measureitemstruct from WM_MEASUREITEM call <br> */ <br>  <br>VOID MeasureItem(HANDLE hwnd, LPMEASUREITEMSTRUCT pmis) <br>{ <br>    HDC        hDC = GetDC(hwnd); <br>    HANDLE     hFont = hfontLB; <br>    TEXTMETRIC TM; <br> <br>    if(!hFont) <br>        hFont = GetStockObject(SYSTEM_FONT); <br>    hFont = SelectObject(hDC, hFont); <br>    GetTextMetrics(hDC, &amp;TM); <br>    SelectObject(hDC, hFont); <br>    ReleaseDC(hwnd, hDC); <br> <br>    // set the height to be max of (dyfont or dybitmap) <br>    pmis-&gt;itemHeight = max(dybmpLB, TM.tmHeight); <br>} <br> <br> <br>/* <br> -  OutTextFormat <br> -   <br> *  Purpose: <br> *      to parse the string in the listbox and draw it accordingly: <br> *      first char == chBOLD: line is bold <br> *      first char == chUNDERLINE: line is underlined (can follow chBOLD) <br> *      char == chTAB: go to next column in rgTabs <br> *      '/001#': bitblt that numbered bitmap. <br> *      otherwise, outtext the line <br> *   <br> *  Arguments: <br> *      pDI     from DrawItem from WM_DRAWITEM msg <br> */ <br>  <br>VOID OutTextFormat(LPDRAWITEMSTRUCT pDI) <br>{ <br>    TCHAR   szDateRec[32]; <br>    TCHAR   szItem[256]; <br>    TCHAR   szTemp[4]; <br>    TCHAR   szDots[4] = {"..."}; <br>    TCHAR   *pch; <br>    INT     nT; <br>    INT     nTab = 0;           // current tab we is on <br>    INT     nBmp;               // index of envelope bitmap <br>    HFONT   hfDef = 0; <br>    HFONT   hfOld = 0;          // bold or underlined font <br>    TCHAR   *pchBuff = NULL; <br>    LPMSGID lpMsgId = (LPMSGID)pDI-&gt;itemData; <br> <br>    pch = szItem; <br> <br>    // Format a string from the info in lpMsgNode <br>    // First, calculate the index to the desired bitmap <br>     <br>    nBmp = ((!lpMsgId-&gt;fUnRead) * 2) + ((!!lpMsgId-&gt;fHasAttach) * 1 ); <br> <br>    // Convert our received date and build string <br>     <br>    ConvertDateRec (lpMsgId-&gt;lpszDateRec, szDateRec); <br> <br>    // Limit our subject size <br>     <br>    szTemp[0] = '\0'; <br>     <br>    if(lpMsgId-&gt;lpszSubject &amp;&amp; (lstrlen(lpMsgId-&gt;lpszSubject) &gt; 32)) <br>    { <br>        memcpy(szTemp, &amp;lpMsgId-&gt;lpszSubject[28], 4); <br>        memcpy(&amp;lpMsgId-&gt;lpszSubject[28], szDots, 4); <br>    } <br>     <br>    wsprintf(szItem, "\001%d\t%s\t%s\t%s", nBmp,  <br>            (lpMsgId-&gt;lpszFrom ? lpMsgId-&gt;lpszFrom : ""), <br>            (lpMsgId-&gt;lpszSubject ? lpMsgId-&gt;lpszSubject : ""), <br>            szDateRec); <br> <br>    // erase background <br>    ExtTextOut(pDI-&gt;hDC, 0, 0, ETO_OPAQUE, &amp;pDI-&gt;rcItem, NULL, 0, NULL); <br> <br>    // underline or bold this line?  Only check first &amp; second char <br>    if(*pch == chBOLD || *pch == chUNDERLINE) <br>    { <br>        LOGFONT     lf; <br> <br>        hfOld = GetWindowFont(pDI-&gt;hwndItem); <br>        if(!hfOld) <br>            hfOld = GetStockObject(SYSTEM_FONT); <br>        GetObject(hfOld, sizeof(lf), &amp;lf); <br> <br>        if(*pch == chBOLD) <br>        { <br>            lf.lfWeight = FW_BOLD; <br>            pch++; <br>        } <br>        if(*pch == chUNDERLINE) <br>        { <br>            lf.lfUnderline = TRUE; <br>            pch++; <br>        } <br> <br>        hfDef = CreateFontIndirect(&amp;lf); <br>        if(hfDef) <br>            SelectObject(pDI-&gt;hDC, hfDef); <br>    } <br> <br>    // selected or nonselected bmps? <br>    nT = (ODS_SELECTED &amp; pDI-&gt;itemState) ? (BMWIDTH * NUMBMPS) : 0; <br> <br>    // parse the string <br>    for(; *pch; pch++) <br>    { <br>        TCHAR   *pchT; <br>        RECT    rc; <br> <br>        if(*pch == chBITMAP)     // do we have a bitmap? <br>        { <br>            ++pch; <br>            // draw the bitmap <br>            BitBlt(pDI-&gt;hDC, pDI-&gt;rcItem.left + rgTabs[nTab], <br>                pDI-&gt;rcItem.top, BMWIDTH, BMHEIGHT, hdcMemory, <br>                nT + (int)(*pch - TEXT('0')) * BMWIDTH, 0, SRCCOPY); <br>            continue; <br>        } <br> <br>        if(*pch == chTAB)    // move to next tabstop? <br>        { <br>            nTab++; <br>            continue; <br>        } <br> <br>        pchT = pch;     // find end of the column of text <br>        while(*pchT &amp;&amp; (*pchT != chTAB)) <br>            pchT++; <br> <br>        // set rect to drawtext in <br>        SetRect(&amp;rc, pDI-&gt;rcItem.left + rgTabs[nTab], pDI-&gt;rcItem.top,  <br>            pDI-&gt;rcItem.right, pDI-&gt;rcItem.bottom); <br> <br>        // draw the text <br>        ExtTextOut(pDI-&gt;hDC, rc.left, rc.top + 1, ETO_OPAQUE | ETO_CLIPPED, <br>            &amp;rc, pch, pchT - pch, NULL); <br>        pch = pchT - 1; // move to end of this column <br>    } <br> <br>    if(hfDef)   // delete underline or bold font if we created it <br>    { <br>        SelectObject(pDI-&gt;hDC, hfOld); <br>        DeleteObject(hfDef); <br>    } <br> <br>    if(szTemp[0] != '\0') <br>    { <br>        memcpy(&amp;lpMsgId-&gt;lpszSubject[28], szTemp, 4); <br>    } <br>} <br> <br> <br>/* <br> -  DrawItem <br> - <br> *  Purpose: <br> *      Handles WM_DRAWITEM for both drive and directory listboxes. <br> * <br> *  Parameters: <br> *      pDI     LPDRAWITEMSTRUCT passed from the WM_DRAWITEM message. <br> */ <br>  <br>VOID DrawItem(LPDRAWITEMSTRUCT pDI) <br>{ <br>    COLORREF    crText, crBack; <br> <br>    if((int)pDI-&gt;itemID &lt; 0) <br>        return; <br> <br>    if((ODA_DRAWENTIRE | ODA_SELECT) &amp; pDI-&gt;itemAction) <br>    { <br>        if(pDI-&gt;itemState &amp; ODS_SELECTED) <br>        { <br>            // Select the appropriate text colors <br>            crText = SetTextColor(pDI-&gt;hDC, rgbHiliteText); <br>            crBack = SetBkColor(pDI-&gt;hDC, rgbHiliteColor); <br>        } <br> <br>        // parse and spit out bmps and text <br>        OutTextFormat(pDI); <br> <br>        // Restore original colors if we changed them above. <br>        if(pDI-&gt;itemState &amp; ODS_SELECTED) <br>        { <br>            SetTextColor(pDI-&gt;hDC, crText); <br>            SetBkColor(pDI-&gt;hDC,   crBack); <br>        } <br>    } <br> <br>    if((ODA_FOCUS &amp; pDI-&gt;itemAction) || (ODS_FOCUS &amp; pDI-&gt;itemState)) <br>        DrawFocusRect(pDI-&gt;hDC, &amp;pDI-&gt;rcItem); <br>} <br> <br> <br>/* <br> -  ConvertDateRec <br> - <br> *  Purpose: <br> *      To convert the lpszDateReceived field of a message to a <br> *      more paletable display format; namely: mm/dd/yy hh:mmAM. <br> * <br> *  Parameters: <br> *      lpszDateRec         - Original format <br> *      lpszDateDisplay     - Display format <br> */ <br> <br>VOID ConvertDateRec (LPSTR lpszDateRec, LPSTR lpszDateDisplay) <br>{ <br>    char  szDateTmp[32]; <br>    LPSTR lpszYear; <br>    LPSTR lpszMonth; <br>    LPSTR lpszDay; <br>    LPSTR lpszHour; <br>    LPSTR lpszMinute; <br>    int nHour; <br>    static char szFoo[2][3] = <br>    {"AM", "PM"}; <br> <br>    *lpszDateDisplay = 0; <br>    if (!lpszDateRec || !*lpszDateRec) <br>        return; <br> <br>    lstrcpy(szDateTmp, lpszDateRec); <br> <br>    lpszYear = strtok (szDateTmp, "/ :"); <br>    lpszMonth = strtok (NULL, "/ :"); <br>    lpszDay = strtok (NULL, "/ :"); <br>    lpszHour = strtok (NULL, "/ :"); <br>    lpszMinute = strtok (NULL, "/ :"); <br> <br>    if(lpszHour) <br>        nHour = atoi (lpszHour); <br>    else <br>        nHour = 0; <br> <br>    if (nHour &gt; 12) <br>        wsprintf (lpszHour, "%d", nHour - 12); <br> <br>    wsprintf (lpszDateDisplay, "%s/%s/%s %s:%s%s", lpszMonth, <br>        (lpszDay ? lpszDay : ""), <br>        (lpszYear ? lpszYear : ""), <br>        (lpszHour ? lpszHour : ""), <br>        (lpszMinute ? lpszMinute : ""), <br>        szFoo[(nHour &gt; 11 ? 1 : 0)]); <br>} <br> <br> <br>/* <br> *  RgbInvertRgb <br> *   <br> *  Purpose: <br> *      To reverse the byte order of the RGB value (for file format <br> *   <br> *  Arguments: <br> *   <br> *  Returns: <br> *      New color value (RGB to BGR) <br> */ <br>  <br>#define RgbInvertRgb(_rgbOld) \ <br>    (DWORD)RGB(GetBValue(_rgbOld), GetGValue(_rgbOld), GetRValue(_rgbOld)) <br> <br> <br>/* <br> *  LoadAlterBitmap (mostly stolen from commdlg) <br> *   <br> *  Purpose: <br> *      Loads the IDB_ENVELOPE bitmap and gives all the pixels that are <br> *      RGBREPLACE a new color. <br> * <br> *  Assumption: <br> *      This function will work on one bitmap during it's lifetime. <br> *      (Due to the fact that it finds RGBREPLACE once and then <br> *      operates on that offset whenever called again because under NT, <br> *      it appears that the bitmap is cached, so the second time you go <br> *      looking for RGBREPLACE, it won't be found.) You could load the <br> *      resource, copy it, then modify the copy as a workaround. But I <br> *      chose the cheap way out as I will only ever modify one bmp. <br> *   <br> *  Arguments: <br> *      rgbInstead  rgb value to replace defined RGBREPLACE with <br> *   <br> *  Returns: <br> *      NULL - failed or hbmp of new modified bitmap <br> */ <br> <br>HBITMAP LoadAlterBitmap(DWORD rgbInstead) <br>{ <br>    HANDLE              hbmp = 0; <br>    LPBITMAPINFOHEADER  qbihInfo; <br>    HDC                 hdcScreen; <br>    HRSRC               hresLoad; <br>    HGLOBAL             hres; <br>    LPBYTE              qbBits; <br>    DWORD               rgbReplace = 0; <br>    DWORD               *rgdw = NULL; <br>    DWORD               *lpdw = NULL; <br>    ULONG               cb = 0; <br>     <br>    if (rgbInstead) <br>        rgbReplace = RGBREPLACE; <br> <br>    // load our listbox bmps resource <br>    hresLoad = FindResource(hInst, MAKEINTRESOURCE(IDB_ENVELOPE), RT_BITMAP); <br>    if(hresLoad == 0) <br>        return 0; <br>    hres = LoadResource(hInst, hresLoad); <br>    if(hres == 0) <br>        return 0; <br> <br>    rgbReplace = RgbInvertRgb(rgbReplace); <br>    rgbInstead = RgbInvertRgb(rgbInstead); <br>    qbihInfo = (LPBITMAPINFOHEADER)LockResource(hres); <br> <br>    // Skip over the header structure <br>    qbBits = (LPBYTE)(qbihInfo + 1); <br> <br>    // Skip the color table entries, if any <br>    qbBits += (1 &lt;&lt; (qbihInfo-&gt;biBitCount)) * sizeof(RGBQUAD); <br> <br>    // Copy the resource into writable memory so we can <br>    // munge the color table to set our background color <br>    cb = (ULONG)(qbBits - (LPBYTE)qbihInfo) + qbihInfo-&gt;biSizeImage; <br>    rgdw = (DWORD *)GlobalAllocPtr(GMEM_MOVEABLE, cb); <br>     <br>    CopyMemory((LPVOID)rgdw, (LPVOID)qbihInfo, cb); <br>     <br>    // find the color to replace in the color table <br>    for(lpdw = (DWORD *)((LPBYTE)rgdw + qbihInfo-&gt;biSize); ; lpdw++) <br>    { <br>        if(*lpdw == rgbReplace) <br>            break; <br>    } <br> <br>    // replace that color value with our new one <br>    *lpdw = (DWORD)rgbInstead; <br> <br>    // Create a color bitmap compatible with the display device <br>    hdcScreen = GetDC(0); <br>    if(hdcScreen != 0) <br>    { <br>        hbmp = CreateDIBitmap(hdcScreen, (LPBITMAPINFOHEADER)rgdw,  <br>                (LONG)CBM_INIT, qbBits, (LPBITMAPINFO) rgdw, DIB_RGB_COLORS); <br>        ReleaseDC(0, hdcScreen); <br>    } <br> <br>    UnlockResource(hres); <br>    FreeResource(hres); <br> <br>    GlobalFreePtr(rgdw); <br>     <br>    return hbmp; <br>} <br> <br> <br>/* <br> *  DeleteBitmapLB <br> *   <br> *  Purpose: <br> *      Get rid of hbmpLB, if it exists <br> */ <br>  <br>VOID DeleteBitmapLB(VOID) <br>{ <br>    if(hbmpOrigMemBmp) <br>    { <br>        SelectObject(hdcMemory, hbmpOrigMemBmp); <br>        if(hbmpLB != 0) <br>        { <br>            DeleteObject(hbmpLB); <br>            hbmpLB = 0; <br>        } <br>    } <br>} <br> <br> <br>/* <br> *  LoadBitmapLB (mostly stolen from commdlg) <br> *   <br> *  Purpose: <br> *      Creates the listbox bitmap. If an appropriate bitmap <br> *      already exists, it just returns immediately.  Otherwise, it <br> *      loads the bitmap and creates a larger bitmap with both regular <br> *      and highlight colors. <br> * <br> *  Returns: <br> *      TRUE - success; FALSE - failure <br> */ <br>  <br>BOOL LoadBitmapLB(VOID) <br>{ <br>    BITMAP  bmp; <br>    HANDLE  hbmp, hbmpOrig; <br>    HDC     hdcTemp; <br>    BOOL    bWorked = FALSE; <br> <br>    // check for existing bitmap and validity <br>    if( (hbmpLB != 0) &amp;&amp; <br>        (rgbWindowColor == rgbDDWindow) &amp;&amp; <br>        (rgbHiliteColor == rgbDDHilite)) <br>    { <br>        if(SelectObject(hdcMemory, hbmpLB)) <br>            return TRUE; <br>    } <br> <br>    DeleteBitmapLB(); <br> <br>    rgbDDWindow = rgbWindowColor; <br>    rgbDDHilite = rgbHiliteColor; <br> <br>    if(!(hdcTemp = CreateCompatibleDC(hdcMemory))) <br>        goto LoadExit; <br> <br>    if(!(hbmp = LoadAlterBitmap(rgbWindowColor))) <br>        goto DeleteTempDC; <br> <br>    GetObject(hbmp, sizeof(BITMAP), (LPBYTE) &amp;bmp); <br>    dybmpLB = bmp.bmHeight; <br>    dxbmpLB = bmp.bmWidth; <br> <br>    hbmpOrig = SelectObject(hdcTemp, hbmp); <br> <br>    hbmpLB = CreateDiscardableBitmap(hdcTemp, dxbmpLB*2, dybmpLB); <br>    if(!hbmpLB) <br>        goto DeleteTempBmp; <br> <br>    if(!SelectObject(hdcMemory, hbmpLB)) <br>    { <br>        DeleteBitmapLB(); <br>        goto DeleteTempBmp; <br>    } <br> <br>    BitBlt(hdcMemory, 0, 0, dxbmpLB, dybmpLB,   // copy unhighlited bmps <br>           hdcTemp, 0, 0, SRCCOPY);             // into hdcMemory <br>    SelectObject(hdcTemp, hbmpOrig); <br> <br>    DeleteObject(hbmp); <br> <br>    if(!(hbmp = LoadAlterBitmap(rgbHiliteColor))) <br>        goto DeleteTempDC; <br> <br>    hbmpOrig = SelectObject(hdcTemp, hbmp); <br>    BitBlt(hdcMemory, dxbmpLB, 0, dxbmpLB, dybmpLB, // copy highlited bmps <br>        hdcTemp, 0, 0, SRCCOPY);                    // into hdcMemory <br>    SelectObject(hdcTemp, hbmpOrig); <br> <br>    bWorked = TRUE; <br> <br>DeleteTempBmp: <br>    DeleteObject(hbmp); <br>DeleteTempDC: <br>    DeleteDC(hdcTemp); <br>LoadExit: <br>    return bWorked; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
