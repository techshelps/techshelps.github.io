<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2224"></a>CLIENT.C</h2>
<pre><code>/* <br> -  C L I E N T . C <br> - <br> *    Purpose: <br> *      Sample routing mail client for the MAPI SDK. <br> *      Exclusively uses the Extended MAPI interface. <br> * <br> *  Copyright 1986-1996, Microsoft Corporation. All Rights Reserved. <br> * <br> */ <br> <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef _WIN32 <br>#include &lt;objerror.h&gt; <br>#include &lt;objbase.h&gt; <br>#endif <br>#ifdef WIN16 <br>#include &lt;compobj.h&gt; <br>#endif <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapiwin.h&gt; <br>#include &lt;pdkver.h&gt; <br>#include &lt;mapiform.h&gt; <br>#include &lt;ole2.h&gt; <br>#include &lt;wrap3d.h&gt; <br> <br>#define USES_IID_IMAPIStatus 1 <br>#define USES_IID_IMessage  1 <br>#include &lt;mapiguid.h&gt; <br> <br>#include "client.h" <br>#include "bitmap.h" <br>#include "route.h" <br>#ifdef _WIN32 <br>#include "chsfld.h" <br>#endif <br> <br>#ifdef WIN16 <br>#define GWL_USERDATA    DWL_USER <br>#endif <br> <br> <br>/* Application instance */ <br>HANDLE hInst; <br>                             <br>/* Static Data */ <br> <br>static ULONG cbeidFolderToView; <br>static LPENTRYID lpeidFolderToView = NULL; <br> <br>LPADRBOOK pabAddrB = NULL; <br>LPMAPISESSION pses = NULL; <br>LPMDB pmdb = NULL; <br>LPMAPIFOLDER pfldOutBox = NULL; <br>LPSPropValue pvalSentMailEID = NULL; <br>HCURSOR hWaitCur; <br> <br>LPVOID lpCtl3d = NULL;      /* 3D control context */ <br> <br>#ifdef _WIN32 <br>/* Choose folder stuff */ <br>HMODULE             g_hChsFldDll; <br>HRPICKFOLDER        g_lpfnHrPickFolder; <br>ULONG               cbCFDState = 0; <br>LPBYTE              pbCFDState = NULL; <br>#endif /*_WIN32 */ <br> <br>int PASCAL <br>WinMain (HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpszCmd, int nCmdShow) <br>{ <br>    MSG msg; <br> <br>    if (!hPrevInst) <br>        if (!InitApplication (hInstance)) <br>            return (FALSE); <br> <br>    if (!InitInstance (hInstance, nCmdShow)) <br>        return (FALSE); <br> <br>    while (GetMessage (&amp;msg, 0, 0, 0)) <br>    { <br>        TranslateMessage (&amp;msg); <br>        DispatchMessage (&amp;msg); <br>    } <br> <br>    DeinitApplication (); <br> <br>    return (msg.wParam); <br>} <br> <br>/* <br> -  InitApplication <br> - <br> *  Purpose: <br> *      Initialize the application. <br> * <br> *  Parameters: <br> *      hInstance   - Instance handle <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL <br>InitApplication (HANDLE hInstance) <br>{ <br>    WNDCLASS wc; <br> <br>    wc.style = 0; <br>    wc.lpfnWndProc = MainWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon (hInstance, "NoMail"); <br>    wc.hCursor = LoadCursor (0, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject (WHITE_BRUSH); <br>    wc.lpszMenuName = "MailMenu"; <br>    wc.lpszClassName = "RoutingSample"; <br> <br>    return (RegisterClass (&amp;wc)); <br>} <br> <br>/* <br> -  InitInstance <br> - <br> *  Purpose: <br> *      Initialize this instance. <br> * <br> *  Parameters: <br> *      hInstance   - Instance handle <br> *      nCmdShow    - Do we show the window? <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL <br>InitInstance (HANDLE hInstance, int nCmdShow) <br>{ <br>    HWND hWnd; <br>    BOOL fInit; <br>    BOOL f; <br> <br>    hInst = hInstance; <br> <br>    fInit = InitMAPI(0); <br> <br>    if (!lpCtl3d) <br>    { <br>        lpCtl3d = CTL3D_Initialize(hInstance); <br>        CTL3D_AutoSubclass(lpCtl3d, hInstance, &amp;f); <br>    } <br> <br>    hWnd = CreateWindow ("RoutingSample", "Routing Sample", WS_OVERLAPPEDWINDOW, <br>        5, 5, 550, 75, 0, 0, hInst, NULL); <br> <br>    if (!hWnd) <br>        return (FALSE); <br> <br>    ShowWindow (hWnd, nCmdShow); <br>    UpdateWindow (hWnd); <br> <br>    hWaitCur = LoadCursor(0, IDC_WAIT); <br> <br>    if (fInit) <br>    { <br>        if (ClientLogon (hWnd)) <br>            ToggleMenuState (hWnd, TRUE); <br>    } <br> <br>    return (fInit); <br>} <br> <br>BOOL <br>InitMAPI (HWND hWnd) <br>{ <br>    HRESULT hr; <br> <br>    hr = MAPIInitialize(NULL); <br>    if(hr) <br>    { <br>        MakeMessageBox(hWnd, GetScode(hr), IDS_MAPIINIF, NULL, MBS_ERROR); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>void <br>DeinitApplication () <br>{ <br>    DeinitMAPI (); <br> <br>    CTL3D_Uninitialize(lpCtl3d); <br>    lpCtl3d = NULL; <br> <br>#ifdef _WIN32 <br>    if(g_hChsFldDll) <br>        FreeLibrary(g_hChsFldDll); <br>         <br>#endif /* _WIN32 */ <br>} <br> <br>void <br>DeinitMAPI () <br>{ <br>    MAPIUninitialize(); <br> <br>} <br> <br>/* <br> *  Log on to MAPI <br> *   <br> *  Error messages are in subroutings. <br> * <br> *  Globals: <br> *      pses        MAPI session handle <br> *      pmdb        MAPI message store object <br> *      pabAddrB    MAPI address book object <br> *      pfldOutBox  Out folder <br> *      pvalSentMailEID     EntryID of the "Sent mail" folder <br> */ <br> <br>BOOL ClientLogon (HWND hWnd) <br>{ <br>    HRESULT hr; <br>    /* We should not yet be logged on*/ <br>    Assert(pses == NULL); <br>    Assert(pmdb == NULL); <br> <br>     <br>        /* MAPILogon might yield control to Windows. So to prevent the user <br>    from clicking "logon" while we are in the process of loggin on we <br>    have to disable it*/ <br> <br>    SecureMenu(hWnd, TRUE); <br> <br>    /* Create a MAPI session*/ <br>    hr = MAPILogonEx((ULONG) hWnd, NULL, NULL, <br>            MAPI_EXTENDED | MAPI_EXPLICIT_PROFILE | MAPI_LOGON_UI | <br>            MAPI_NEW_SESSION, &amp;pses); <br>    if(hr) <br>    { <br>        SecureMenu(hWnd, FALSE); <br>        pses = NULL; <br>        if (GetScode(hr) != MAPI_E_USER_CANCEL) <br>            MakeMessageBox (hWnd, GetScode(hr), IDS_LOGONFAIL, NULL, MBS_ERROR); <br>        return FALSE; <br>    } <br> <br> <br>    pmdb = OpenDefaultStore(hWnd); <br>    if (!pmdb) goto err; <br> <br>    pabAddrB = OpenAddressBook(hWnd); <br>    if (!pabAddrB) goto err; <br> <br>    if(!OpenOutFolder(hWnd, &amp;pfldOutBox)) goto err; <br>     <br>    /* retrieve the EntryID of the sentmail folder and change the property tag <br>        so that it is ready to use on a message*/ <br>    hr = HrGetOneProp((LPMAPIPROP)pmdb, PR_IPM_SENTMAIL_ENTRYID, &amp;pvalSentMailEID); <br>    if(hr) <br>    { <br>        goto err; <br>    } <br>    pvalSentMailEID-&gt;ulPropTag = PR_SENTMAIL_ENTRYID; <br> <br>    return TRUE; <br> <br>err: <br>     <br>    ClientLogoff(hWnd); <br>    SecureMenu(hWnd, FALSE); <br>     <br>    return FALSE; <br>} <br> <br>/* <br> *  Releases  the global objects and logs off MAPI. <br> * <br> *  Globals: <br> *      pses        Extended-MAPI session object <br> *      pmdb        Extended-MAPI message store object <br> *      pabAddrB        Address Book <br> *      pfldOutBox  out folder <br> *      pvalSetmailEID contains EID of the "Sent" folder <br> */ <br>VOID <br>ClientLogoff (HWND hWnd) <br>{ <br> <br>#ifdef _WIN32 <br>    MAPIFreeBuffer(pbCFDState); <br>    pbCFDState = NULL; <br>    cbCFDState = 0; <br>#endif <br> <br>    UlRelease(pfldOutBox); <br>    pfldOutBox = NULL; <br> <br>    UlRelease(pmdb); <br>    pmdb = NULL; <br> <br>    UlRelease(pabAddrB); <br>    pabAddrB = NULL; <br> <br>    MAPIFreeBuffer(pvalSentMailEID); <br>    pvalSentMailEID = NULL; <br> <br>    pses-&gt;lpVtbl-&gt;Logoff(pses, (ULONG)hWnd, MAPI_LOGOFF_UI, 0); <br>    UlRelease(pses); <br>    pses = NULL; <br> <br>    SetWindowText(hWnd, "Routing Sample"); <br>} <br> <br>LPMDB <br>OpenDefaultStore(HWND hWnd) <br>{ <br>    HRESULT hr; <br>    LPMDB lpmdb = NULL; <br>    LPMAPITABLE ptable = NULL; <br>    LPSRowSet prows = NULL; <br>    LPSPropValue pvalProp = NULL; <br>    static SizedSPropTagArray(2, columns) = <br>                { 2, { PR_DEFAULT_STORE, PR_ENTRYID} }; <br>    SPropValue valDefStore; <br>    SPropertyRestriction restpropDefStore; <br>    SRestriction restDefStore; <br> <br>     <br>    valDefStore.ulPropTag = PR_DEFAULT_STORE; <br>    valDefStore.dwAlignPad = 0; <br>    valDefStore.Value.b = TRUE; <br> <br>    restpropDefStore.relop = RELOP_EQ; <br>    restpropDefStore.ulPropTag = PR_DEFAULT_STORE; <br>    restpropDefStore.lpProp = &amp;valDefStore; <br> <br>    restDefStore.rt = RES_PROPERTY; <br>    restDefStore.res.resProperty = restpropDefStore; <br> <br>    hr = pses-&gt;lpVtbl-&gt;GetMsgStoresTable(pses, 0, &amp;ptable); <br>    if (HR_FAILED(hr)) <br>    { <br>        MakeMessageBox (hWnd, GetScode(hr), IDS_STORETBLFAIL, NULL, MBS_ERROR); <br>        goto ret; <br>    } <br> <br>     <br>    hr = HrQueryAllRows(ptable, (LPSPropTagArray) &amp;columns, &amp;restDefStore, NULL, 0, &amp;prows); <br>    if (HR_FAILED(hr)) <br>    { <br>        MakeMessageBox (hWnd, GetScode(hr), IDS_QUERYROWFAIL, NULL, MBS_ERROR); <br>        goto ret; <br>    } <br> <br>    if (prows == NULL || prows-&gt;cRows == 0 <br>        || prows-&gt;aRow[0].lpProps[1].ulPropTag != PR_ENTRYID) <br>    { <br>        MakeMessageBox (hWnd, 0L, IDS_NODEFAULTSTORE, NULL, MBS_ERROR); <br>        goto ret; <br>    } <br>     <br>    Assert(prows-&gt;cRows == 1); <br> <br>    hr = pses-&gt;lpVtbl-&gt;OpenMsgStore(pses, (ULONG)hWnd, <br>                        prows-&gt;aRow[0].lpProps[1].Value.bin.cb, <br>                        (LPENTRYID)prows-&gt;aRow[0].lpProps[1].Value.bin.lpb, <br>                        NULL, MDB_WRITE | MAPI_DEFERRED_ERRORS, &amp;lpmdb); <br>    if (HR_FAILED(hr)) <br>    { <br>        if (GetScode(hr) != MAPI_E_USER_CANCEL) <br>            MakeMessageBox (hWnd, GetScode(hr), IDS_OPENSTOREFAIL, NULL, MBS_ERROR); <br>        Assert(lpmdb == NULL); <br>        goto ret; <br>    } <br>    if(hr) /*if we have a warning, display it and succeed */ <br>    { <br>        LPMAPIERROR perr = NULL; <br> <br>        pses-&gt;lpVtbl-&gt;GetLastError(pses, hr, 0, &amp;perr); <br>        MakeMessageBox(hWnd, GetScode(hr), IDS_OPENSTOREWARN, perr, MBS_ERROR); <br>        MAPIFreeBuffer(perr); <br>    } <br> <br> <br>    Assert(lpmdb != NULL); <br> <br>    hr = HrGetOneProp((LPMAPIPROP)lpmdb, PR_DISPLAY_NAME, &amp;pvalProp); <br>    if(!hr) <br>    {    <br>        char buf[128]; <br> <br>        wsprintf(buf, "Routing Sample: %s", pvalProp-&gt;Value.lpszA); <br> <br>        SetWindowText(hWnd, buf); <br>        MAPIFreeBuffer(pvalProp); <br>    } <br>                     <br>ret: <br>    FreeProws(prows); <br>    UlRelease(ptable); <br> <br>    return lpmdb; <br>} <br> <br> <br>#ifdef _WIN32 <br>BOOL FGetFoldChooser(void) <br>{ <br>    UINT uiErrMode; <br>     <br>    if(g_lpfnHrPickFolder) <br>        return TRUE; <br> <br>    Assert(!g_hChsFldDll); <br> <br>    uiErrMode = SetErrorMode(SEM_NOOPENFILEERRORBOX); <br> <br>    g_hChsFldDll = LoadLibrary(szChsFldDllName); <br> <br>    SetErrorMode(uiErrMode); <br> <br>    if(g_hChsFldDll) <br>    { <br>        if((g_lpfnHrPickFolder = (HRPICKFOLDER)GetProcAddress(g_hChsFldDll, <br>                                        szChsFldFnName))) <br>        { <br>            return TRUE; <br>        } <br> <br>        DebugTrace("route.cli: GetProcAddress for %s failed", szChsFldFnName); <br>         <br>        FreeLibrary(g_hChsFldDll); <br>        g_hChsFldDll = NULL; <br>    } <br>    else <br>    { <br>        DebugTrace("smpfrm: failed to load choose folder dll\n"); <br>    } <br> <br>    return FALSE; <br>} <br>#endif /* _WIN32 */ <br> <br>/* <br> -  MainWndProc <br> - <br> *   Purpose: <br> *      Main Window Procedure. <br> *      Handles the menu bar and standard window messages. <br> * <br> *   Parameters: <br> *       hWnd <br> *       message <br> *       wParam <br> *       lParam <br> * <br> *   Returns: <br> * <br> * <br> */ <br> <br>LONG FAR PASCAL <br>MainWndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>    HANDLE_MSG(hWnd, WM_COMMAND, MAIN_OnCommand); <br>     <br>    case WM_ENDSESSION: <br>        DestroyWindow (hWnd); <br>        break; <br> <br>    case WM_CLOSE: <br>    case WM_DESTROY: <br>        if (pses) <br>            ClientLogoff (hWnd); <br> <br>        PostQuitMessage (0); <br>        break; <br> <br>    default: <br>        return (DefWindowProc (hWnd, msg, wParam, lParam)); <br>    } <br>    return FALSE; <br>} <br> <br> <br>LONG MAIN_OnCommand(HWND hWnd, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    HRESULT hr; <br>#ifndef _WIN32 <br>    LPDIALOGDATA pDialogData; <br>#endif <br>    LPMESSAGE pmsgOutgoing = NULL; <br>    ULONG ulMsgToken = 0; <br>     <br>    switch (id) <br>    { <br>    case IDM_NEWFORM: <br>        { <br>            LPMAPIFORMMGR pfmmgr = NULL; <br>            LPMAPIFORMINFO pfminfo = NULL;           <br>            LPSPropValue pvalMsgClass = NULL; <br>            LPMESSAGE pmsgForm = NULL; <br> <br>            hr = MAPIOpenFormMgr(pses, &amp;pfmmgr); <br>            if(!hr) <br>            { <br>                hr = pfmmgr-&gt;lpVtbl-&gt;SelectForm(pfmmgr, (ULONG) hWnd, 0, NULL, NULL, &amp;pfminfo); <br> <br>                if(!hr) <br>                { <br>                     <br>                    /*Get the form's msg class */ <br>                    hr = HrGetOneProp((LPMAPIPROP)pfminfo, PR_MESSAGE_CLASS, &amp;pvalMsgClass); <br>                    DebugTraceResult(HrGetOneProp, hr); <br>                     <br>                    if(!hr) <br>                    { <br>                        /*create new message*/ <br>                        if(CreateOutMessage(&amp;pmsgForm)) <br>                        { <br>                            hr = pses-&gt;lpVtbl-&gt;PrepareForm(pses, NULL, pmsgForm, (LPULONG) &amp;ulMsgToken); <br>                            if(S_OK != GetScode(hr)) <br>                            { <br>                                DebugTrace("Client: PrepareForm failed"); <br>                                break; <br>                            } <br>                            UlRelease(pmsgForm); <br>                            pmsgForm = NULL; <br>                 <br>                            hr = pses-&gt;lpVtbl-&gt;ShowForm(pses, (ULONG) hWnd, pmdb, pfldOutBox, <br>                                                        NULL, ulMsgToken, NULL, MAPI_NEW_MESSAGE, <br>                                                        0, MSGFLAG_UNSENT | MSGFLAG_READ, 0, <br>                                                        pvalMsgClass-&gt;Value.lpszA ); <br>                            if(S_OK != GetScode(hr)) <br>                            MakeMessageBox(hWnd, GetScode(hr), IDS_SHOWFORM, NULL, MBS_ERROR); <br>                        } <br>                        else <br>                            MakeMessageBox(hWnd, 1, IDS_CRTOUTMSG, NULL, MBS_ERROR); <br>                    } <br> <br>                    MAPIFreeBuffer(pvalMsgClass); <br>                    UlRelease(pfminfo); <br>                } <br> <br>                UlRelease(pfmmgr); <br>            } <br>        } <br>                 <br>        break;               <br>                 <br> <br>    case IDM_LOGON: <br>        if (!pses) <br>        { <br>            if (ClientLogon (hWnd)) <br>                ToggleMenuState (hWnd, TRUE); <br>        } <br>        break; <br>     <br>    case IDM_LOGOFF: <br>        if (pses) <br>        { <br>            ClientLogoff (hWnd); <br>            ToggleMenuState (hWnd, FALSE); <br>        } <br>        break;                   <br>         <br>    case IDM_HIER: <br>        Assert(pses); <br>        //on win32 use the sample Choose Folder Dialog <br>#ifdef _WIN32  <br>        { <br>            HRESULT hr; <br>            LPMAPIFOLDER pfld = NULL; <br>            LPMDB pmdbNew = NULL; <br> <br>            if(!FGetFoldChooser()) <br>                return TRUE; <br>                 <br>            hr = (*g_lpfnHrPickFolder)(NULL, hWnd, pses, &amp;pfld, &amp;pmdbNew, <br>                                    &amp;cbCFDState, &amp;pbCFDState); <br>            if(HR_SUCCEEDED(hr)) <br>            { <br>                LPSPropValue pval = NULL; <br> <br>                UlRelease(pmdb); <br>                pmdb = pmdbNew; <br>                pmdbNew = NULL; <br> <br>                hr = HrGetOneProp((LPMAPIPROP)pmdb, PR_DISPLAY_NAME, &amp;pval); <br>                if(!hr) <br>                {    <br>                    char buf[128]; <br> <br>                    wsprintf(buf, "Routing Sample: %s", pval-&gt;Value.lpszA); <br> <br>                    SetWindowText(hWnd, buf); <br>                    MAPIFreeBuffer(pval); <br>                    pval = NULL; <br>                } <br> <br>     <br>                hr = HrGetOneProp((LPMAPIPROP)pfld, PR_ENTRYID, &amp;pval); <br>                if(!hr) <br>                { <br>                    cbeidFolderToView = pval-&gt;Value.bin.cb; <br>                    lpeidFolderToView = (LPENTRYID)pval-&gt;Value.bin.lpb; <br> <br>                    DialogBox (hInst, "InBox", hWnd, InBoxDlgProc); <br> <br>                    cbeidFolderToView = 0; <br>                    lpeidFolderToView = NULL; <br> <br>                    MAPIFreeBuffer(pval); <br>                } <br>                 <br>                UlRelease(pfld); <br>            } <br>        } <br> <br>#else <br> <br>         <br>        Assert(pmdb); <br>        if (pDialogData = CreateDialogData (iHierarchy)) <br>            DialogBoxParam (hInst, "HierarchyTable", hWnd, CommonDlgProc, (LPARAM)pDialogData); <br>#endif /* _WIN32 */ <br>        break; <br> <br>#ifndef _WIN32         <br>    case IDM_OPEN: <br>        Assert(pses); <br>        if (pDialogData = CreateDialogData (iStores)) <br>            DialogBoxParam (hInst, "OpenStore", hWnd, CommonDlgProc, (LPARAM)pDialogData); <br>        break; <br>#endif /* _WIN32 */ <br>                                                                       <br>    case IDM_ROUTE: <br>        Assert(pses); <br>        DialogBoxParam(hInst, "RouteNote", hWnd, RouteNoteDlgProc, (LPARAM) NULL ); <br>        break; <br> <br>    case IDM_READ: <br>        Assert(pses); <br>        Assert(pmdb); <br>        Assert(lpeidFolderToView == NULL); <br> <br>        { <br>            /* Get the entry ID of the Inbox from the message store. */ <br>            if ((hr = pmdb-&gt;lpVtbl-&gt;GetReceiveFolder(pmdb, <br>                    "IPM", 0, <br>                    &amp;cbeidFolderToView, &amp;lpeidFolderToView, NULL)) <br>                        == hrSuccess) <br>            { <br>                DialogBox (hInst, "InBox", hWnd, InBoxDlgProc); <br>                MAPIFreeBuffer(lpeidFolderToView); <br>                lpeidFolderToView = NULL; <br>            } <br>            else <br>                MakeMessageBox (hWnd, GetScode(hr), IDS_GETRCVFAIL, NULL, MBS_ERROR); <br>        } <br>        break; <br> <br>    case IDM_SEND: <br>        Assert(pses); <br>        { <br>            if(CreateOutMessage(&amp;pmsgOutgoing)) <br>            { <br>                hr = pses-&gt;lpVtbl-&gt;PrepareForm(pses, NULL, pmsgOutgoing, (LPULONG) &amp;ulMsgToken); <br>                if(S_OK != GetScode(hr)) <br>                { <br>                    DebugTrace("Client: PrepareForm failed"); <br>                    break; <br>                } <br>                UlRelease(pmsgOutgoing); <br>                pmsgOutgoing = NULL; <br>                 <br>                hr = pses-&gt;lpVtbl-&gt;ShowForm(pses, (ULONG) hWnd, pmdb, pfldOutBox, NULL, ulMsgToken, <br>                                            NULL, MAPI_NEW_MESSAGE, 0, MSGFLAG_UNSENT | MSGFLAG_READ, 0, "IPM.Note"); <br>                if(S_OK != GetScode(hr)) <br>                    MakeMessageBox(hWnd, GetScode(hr), IDS_SHOWFORM, NULL, MBS_ERROR); <br>            } <br>            else <br>                MakeMessageBox(hWnd, 1, IDS_CRTOUTMSG, NULL, MBS_ERROR);                 <br> <br>        } <br>        break; <br>           <br>    case IDM_ABOUT: <br>        DialogBox (hInst, "AboutBox", hWnd, AboutDlgProc); <br>        break; <br>     <br> <br>    case IDM_EXIT: <br>        if (pses) <br>            ClientLogoff (hWnd); <br>     <br>        PostQuitMessage (0); <br>        break; <br> <br>        default: <br>            return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br>     <br> <br>/* <br> *  Displays an About dialog for the sample client. <br> */ <br> <br>BOOL CALLBACK <br>AboutDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    char    rgchVersion[80]; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        wsprintf(rgchVersion, "Version %d.%d.%d (%s)", rmj, rmm, rup, <br>            szVerName &amp;&amp; *szVerName ? szVerName : "BUDDY"); <br>        SetDlgItemText(hDlg, IDC_VERSION, rgchVersion); <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        if (wParam == IDOK || wParam == IDCANCEL) <br>        { <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        } <br>        break; <br>    } <br>    return FALSE; <br>} <br>             <br> <br> <br>/* <br> *  Handles the Inbox list view, its command buttons. <br> *  The main window is a listbox presenting a summary line for <br> *  each message in the Inbox. There are command buttons for <br> *  refreshing the list, displaying a message, and deleting a <br> *  message. <br> * <br> *  All operations are on single messages; multiple selection is <br> *  not supported. <br> * <br> *  The EntryID of the folder to examine is passed in using <br> *  the global lpeidFolderToView. <br> */ <br> <br>BOOL CALLBACK <br>InBoxDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    LPMSGID lpMsgIdList = NULL; <br>    HCURSOR hOldCur; <br>    LPMESSAGE pmsgRead = NULL; <br>    ULONG ulObjType = 0; <br>    ULONG ulMsgToken = 0; <br>    LPINBOXDATA pIBData = NULL; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        if(MAPIAllocateBuffer(sizeof(INBOXDATA), &amp;pIBData)) <br>        { <br>            EndDialog(hDlg, FALSE); <br>            return TRUE; <br>        } <br>         <br>        hOldCur = SetCursor(hWaitCur); <br> <br>        ZeroMemory(pIBData, sizeof(INBOXDATA)); <br>         <br>        InitBmps(hDlg, IDC_MSG); <br> <br>        /* Populate List Box with all messages in InBox. */ <br>        PopulateMessages(hDlg, pIBData); <br> <br>        SetCursor(hOldCur); <br>        SetFocus (GetDlgItem (hDlg, IDC_MSG)); <br>        SetWindowLong(hDlg, GWL_USERDATA, (LONG)pIBData); <br>        return TRUE; <br>        break; <br> <br>    case WM_SETFOCUS: <br>        SetFocus (GetDlgItem (hDlg, IDC_MSG)); <br>        break; <br> <br>    case WM_MEASUREITEM: <br>        /* Sets the height of the owner-drawn List-Box */ <br>        MeasureItem(hDlg, (MEASUREITEMSTRUCT *)lParam); <br>        break; <br> <br>    case WM_DRAWITEM: <br>        DrawItem((DRAWITEMSTRUCT *)lParam); <br>        break; <br> <br>    case WM_CHARTOITEM:     /* don't select item by character*/ <br>        return  -2; <br> <br>    /* Handled by IDC_DELETE */ <br>    case WM_DELETEITEM: <br>        return TRUE; <br>    HANDLE_MSG(hDlg, WM_COMMAND, INBOX_OnCommand); <br>        break; <br>    } <br> <br>    return FALSE; <br>} <br> <br>void INBOX_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    LPMSGID lpMsgNode = NULL; <br>    LPINBOXDATA pibData = NULL; <br>    HCURSOR hOldCur; <br>    UINT nIndex; <br>    RECT Rect; <br>    LPMESSAGE pmsgRead = NULL; <br>    ULONG ulObjType = 0; <br>    HRESULT hr; <br>    ULONG ulMsgToken = 0; <br>    ULONG cProps = 0; <br>    LPSPropValue pvalProps = NULL; <br>    LONG lStat = 0, lFlags = 0, lAccess = 0; <br>    LPSTR lpszMsgClass = "IPM.Note"; <br> <br>    enum { PRSTAT, PRFLAGS, PRACCESS, PRCLASS, PRDIM};      /* used to retrieve props*/ <br>    SizedSPropTagArray(PRDIM, sptaSFProps) =                /*required for ShowForm call*/ <br>    { PRDIM, {PR_MSG_STATUS, PR_MESSAGE_FLAGS, PR_ACCESS_LEVEL, PR_MESSAGE_CLASS} }; <br> <br>     <br>    switch (id) <br>    { <br>     <br>    case IDC_FLUSH: <br>        hr = DeliverNow(hDlg); <br>        if(hr) <br>            break; <br>         /*fall through if the flush was succesfull*/ <br>    case IDC_NEW: <br>         <br>        pibData = (LPINBOXDATA)GetWindowLong(hDlg, GWL_USERDATA); <br>        if(!pibData) <br>        { <br>            DebugTrace("Client: userdata == 0 (inboxdlgproc)"); <br>        } <br>        hOldCur = SetCursor(hWaitCur); <br>     <br>        /* Destroy the old message list. */ <br>        FreeMsgList (pibData-&gt;lpMsgIdList); <br>        pibData-&gt;lpMsgIdList = NULL; <br> <br>        /* Populate List Box with all messages in InBox. */ <br>        PopulateMessages(hDlg, pibData); <br>         <br>        SetCursor(hOldCur); <br>        break; <br> <br>    case IDC_MSG: <br>        if(codeNotify != LBN_DBLCLK) <br>        break; <br>        /* FALL THROUGH to read the double-clicked message */ <br>     <br>    case IDC_READ: <br>        nIndex = (UINT)ListBox_GetCurSel(GetDlgItem(hDlg, IDC_MSG)); <br>        if (nIndex == LB_ERR) <br>        break; <br>     <br>        lpMsgNode = (LPMSGID)ListBox_GetItemData(GetDlgItem(hDlg, IDC_MSG), nIndex); <br>        if (lpMsgNode) <br>        {    <br>            hr = pmdb-&gt;lpVtbl-&gt;OpenEntry(pmdb, lpMsgNode-&gt;cbEID, lpMsgNode-&gt;lpEID, <br>                                NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>                                &amp;ulObjType, (LPUNKNOWN FAR *) &amp;pmsgRead); <br>     <br>            if(S_OK != GetScode(hr)) <br>            { <br>                LPMAPIERROR perr = NULL; <br>                 <br>                pmdb-&gt;lpVtbl-&gt;GetLastError(pmdb, hr, 0, &amp;perr); <br>                MakeMessageBox(hDlg, GetScode(hr), IDS_READFAIL, perr, MBS_ERROR); <br>                MAPIFreeBuffer(perr); <br>                DebugTrace("Client: OpenEntry failed"); <br>                break; <br>            } <br>            else <br>            {  <br>                Assert(ulObjType == MAPI_MESSAGE); <br>     <br>                lpMsgNode-&gt;fUnRead = FALSE; <br>         <br>                /* get all the props in one call */ <br>                hr = pmsgRead-&gt;lpVtbl-&gt; <br>                GetProps(pmsgRead, (LPSPropTagArray)&amp;sptaSFProps, 0, <br>                                                    &amp;cProps, &amp;pvalProps); <br>                if(HR_SUCCEEDED(hr)) <br>                { <br>                    if(pvalProps[PRSTAT].ulPropTag == PR_MSG_STATUS)  <br>                        lStat = pvalProps[PRSTAT].Value.l; <br>                    if(pvalProps[PRFLAGS].ulPropTag == PR_MESSAGE_FLAGS) <br>                        lFlags = pvalProps[PRFLAGS].Value.l; <br>                    if(pvalProps[PRACCESS].ulPropTag == PR_ACCESS_LEVEL) <br>                        lAccess = pvalProps[PRACCESS].Value.l; <br>                    if(pvalProps[PRCLASS].ulPropTag == PR_MESSAGE_CLASS) <br>                        lpszMsgClass = pvalProps[PRCLASS].Value.lpszA; <br>                } <br>                 <br>                else <br>                { <br>                    DebugTrace("Client: GetProps (for ShowForm) failed"); <br>                    break; <br>                } <br>                 <br>                if (!lstrcmpi(lpszMsgClass, lpszSmplRTMsgClass)) <br>                { <br>                    DialogBoxParam(hInst, "RouteNote", hDlg, RouteNoteDlgProc, (LPARAM) pmsgRead); <br>                    /* RouteNoteDlgPropc will release pmsgRead*/ <br>                } <br>                else <br>                {                                    <br>                    hr = pses-&gt;lpVtbl-&gt;PrepareForm(pses, NULL, pmsgRead, (LPULONG) &amp;ulMsgToken); <br>                    if(S_OK != GetScode(hr)) <br>                    { <br>                        DebugTrace("Client: PrepareForm failed"); <br>                        MAPIFreeBuffer(pvalProps); <br>                        break; <br>                    } <br>                    UlRelease(pmsgRead); <br>                    pmsgRead = NULL; <br>                    hr = pses-&gt;lpVtbl-&gt;ShowForm(pses, (ULONG) hDlg, pmdb, pfldOutBox, NULL, ulMsgToken, <br>                                            NULL, 0, lStat, lFlags, lAccess, lpszMsgClass); <br>                     <br>                } <br>            } <br>             <br>        } <br>         <br>        MAPIFreeBuffer(pvalProps); <br>        pvalProps = NULL; <br>        /* Update the Messages List-Box with new icon */ <br>        lpMsgNode = NULL; <br> <br>        ListBox_GetItemRect(GetDlgItem(hDlg, IDC_MSG),nIndex, (LPARAM) &amp;Rect); <br>        InvalidateRect(GetDlgItem(hDlg, IDC_MSG), &amp;Rect, FALSE); <br>         <br>        break; <br>         <br>    case IDC_DELETE: <br>        { <br>        ENTRYLIST el; <br>        SBinary sb; <br>         <br>        nIndex = (UINT)ListBox_GetCurSel(GetDlgItem(hDlg, IDC_MSG)); <br>        if (nIndex == LB_ERR) <br>            break; <br>     <br>        pibData = (LPINBOXDATA)GetWindowLong(hDlg, GWL_USERDATA); <br>        if(!pibData) <br>        { <br>            DebugTrace("Client: userdata == 0 (inboxdlgproc)"); <br>        } <br>         <br>        lpMsgNode = (LPMSGID) ListBox_GetItemData(GetDlgItem(hDlg, IDC_MSG), <br>                                                nIndex); <br>        if (lpMsgNode) <br>        {    <br>            sb.cb = lpMsgNode-&gt;cbEID; <br>            sb.lpb = (LPBYTE)lpMsgNode-&gt;lpEID; <br>            el.cValues = 1; <br>            el.lpbin = &amp;sb; <br> <br>            hr = pibData-&gt;pfld-&gt;lpVtbl-&gt; <br>                    DeleteMessages(pibData-&gt;pfld, &amp;el, 0, NULL, 0); <br>            DeleteMsgNode (lpMsgNode, &amp;pibData-&gt;lpMsgIdList); <br>        } <br> <br>        ListBox_DeleteString(GetDlgItem(hDlg, IDC_MSG), nIndex); <br>        } <br>        break; <br>     <br>    case IDC_CLOSE: <br>    case IDCANCEL: <br>        pibData = (LPINBOXDATA)GetWindowLong(hDlg, GWL_USERDATA); <br>        if(!pibData) <br>        { <br>            DebugTrace("Client: userdata == 0 (inboxdlgproc)"); <br>             <br>        } <br>         <br>        FreeMsgList (pibData-&gt;lpMsgIdList); <br>        pibData-&gt;lpMsgIdList = NULL; <br>        UlRelease(pibData-&gt;pfld); <br>        pibData-&gt;pfld = NULL; <br>        MAPIFreeBuffer(pibData); <br>        pibData = NULL; <br>        DeInitBmps(); <br>        EndDialog (hDlg, TRUE); <br>        break; <br>     <br>    default: <br>        break; <br>    } <br>} <br> <br>/* <br> *  DeliverNow flushes outbound and inboud queues. <br> * <br> */ <br>HRESULT DeliverNow(HWND hWnd) <br>{ <br>    HRESULT hr; <br>    LPMAPISTATUS pstatSpooler = NULL; <br>    ULONG ulObjType = 0; <br>    LPMAPITABLE ptblStatus = NULL; <br>    SizedSPropTagArray(1, columns) = <br>                { 1, { PR_ENTRYID} }; <br>    SPropValue valSpooler; <br>    SPropertyRestriction restpropSpooler; <br>    SRestriction restSpooler; <br>    LPSRowSet prows = NULL; <br>     <br>    /*Build property restriction (PR_RESOURCE_TYPE == MAPI_SPOOLER)*/ <br>    valSpooler.ulPropTag = PR_RESOURCE_TYPE; <br>    valSpooler.dwAlignPad = 0; <br>    valSpooler.Value.l = MAPI_SPOOLER; <br> <br>    restpropSpooler.relop = RELOP_EQ; <br>    restpropSpooler.ulPropTag = PR_RESOURCE_TYPE; <br>    restpropSpooler.lpProp = &amp;valSpooler; <br> <br>    restSpooler.rt = RES_PROPERTY; <br>    restSpooler.res.resProperty = restpropSpooler; <br> <br>    /*open session status table*/ <br>    hr = pses-&gt;lpVtbl-&gt;GetStatusTable(pses, 0, &amp;ptblStatus); <br>    if(hr) <br>    { <br>        DebugTraceResult(GetStatusTable, hr); <br>        goto err; <br>    } <br> <br>    /*find a row corresponding to the spooler*/ <br>    hr = HrQueryAllRows(ptblStatus, (LPSPropTagArray) &amp;columns, &amp;restSpooler, NULL, 0, &amp;prows); <br>    if (HR_FAILED(hr)) <br>    { <br>        DebugTraceResult(HrQueryAllRows, hr); <br>        goto err; <br>    } <br> <br>    Assert(prows &amp;&amp; prows-&gt;cRows == 1); /*hope the spooler is always there */ <br>    Assert(prows-&gt;aRow[0].lpProps[0].ulPropTag == PR_ENTRYID); </code></pre>
<p>
</p>
<pre><code><br>    /*open spooler as a status object*/ <br>    hr = pses-&gt;lpVtbl-&gt; <br>            OpenEntry(pses, prows-&gt;aRow-&gt;lpProps-&gt;Value.bin.cb, <br>                        (LPENTRYID)prows-&gt;aRow-&gt;lpProps-&gt;Value.bin.lpb, <br>                        &amp;IID_IMAPIStatus, MAPI_BEST_ACCESS, &amp;ulObjType, <br>                        (LPUNKNOWN FAR *) &amp;pstatSpooler); <br>    if(hr) <br>    { <br>        DebugTraceResult(OpenEntry, hr); <br>        goto err; <br>    } <br> <br>    Assert(ulObjType == MAPI_STATUS); <br> <br>    /*call FlushQueues()*/ <br>    hr = pstatSpooler-&gt;lpVtbl-&gt;FlushQueues(pstatSpooler, (ULONG) hWnd, 0, NULL,  <br>                                            FLUSH_DOWNLOAD | FLUSH_UPLOAD); <br>    if(hr) <br>    { <br>        DebugTraceResult(FlushQueues, hr); <br>        goto err; <br>    } <br>     <br>    /*release all used objects*/ <br> <br>err: <br>    UlRelease(ptblStatus); <br>    FreeProws(prows); <br>    UlRelease(pstatSpooler); <br> <br>    return hr; <br>} <br> <br>    /* <br> -  MakeMessageBox <br> - <br> *  Purpose: <br> *      Gets resource string and displays an error message box. <br> * <br> *  Parameters: <br> *      hWnd            - Handle to parent window <br> *      sc              - SCODE <br> *      idString        - Resource ID of message in StringTable <br> *      perr            - pointer to MAPIERROR from last GetLastError <br> *      fStyle          - style for MessageBox <br> * <br> *  Returns: <br> *      Void <br> * <br> */ <br> <br>void <br>MakeMessageBox (HWND hWnd, SCODE sc, UINT idString, LPMAPIERROR perr, UINT fStyle) <br>{ <br>    char szMessage[512]; <br>    char szbuf[256]; <br> <br>    if(!LoadString (hInst, idString, szMessage, 255)) <br>        return; <br> <br>    if(perr) <br>    { <br>        wsprintf(szbuf, "\n%s\n%s\nLowLevelError: 0x%08lx context: %ld ", (perr-&gt;lpszError ? perr-&gt;lpszError:""), <br>                        perr-&gt;lpszComponent ? perr-&gt;lpszComponent:"", perr-&gt;ulLowLevelError, perr-&gt;ulContext); <br>        lstrcat(szMessage, szbuf); <br>    } <br>    if (sc) <br>    { <br>        wsprintf (szbuf, "\nReturn Code: 0x%08lx", sc); <br>        lstrcat (szMessage, szbuf); <br>    } <br> <br>    MessageBox (hWnd, szMessage, "Sample Routing Form", fStyle); <br>} <br> <br> <br>/* <br> * Common Dialog Proc for store and folder listboxes <br> * <br> */ <br>BOOL CALLBACK <br>CommonDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    MEASUREITEMSTRUCT *pmis; <br>    DRAWITEMSTRUCT *pdis; <br>    HCURSOR hOldCur; <br>    LPDIALOGDATA pdd = (LPDIALOGDATA) GetWindowLong(hDlg, DWL_USER); <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        /* Remember the address of our dialog data*/ <br>        SetWindowLong(hDlg, DWL_USER, lParam); <br>        pdd = (LPDIALOGDATA)lParam; <br>        Assert(pdd-&gt;poarHead == NULL); <br> <br>        /*/ Load up the rows of the dialog*/ <br>        hOldCur = SetCursor(hWaitCur); <br>        PopulateStores (hDlg, &amp;pdd-&gt;poarHead, pdd-&gt;iDlgType, <br>            pdd-&gt;cbEntryID, pdd-&gt;lpEntryID); <br>        SetCursor(hOldCur); <br> <br>        SetFocus (GetDlgItem (hDlg, IDC_MSG)); <br>        return TRUE; <br> <br>    case WM_DESTROY: <br>        /* Discard our dialog data*/ <br>        FreeOarList(&amp;pdd-&gt;poarHead); <br>        MAPIFreeBuffer(pdd); <br>        return TRUE; <br> <br>    case WM_SETFOCUS: <br>        SetFocus (GetDlgItem (hDlg, IDC_MSG)); <br>        break; <br> <br>    case WM_MEASUREITEM: <br>        /* Sets the height of the owner-drawn List-Box */ <br>        pmis = (MEASUREITEMSTRUCT *) lParam; <br>        pmis-&gt;itemHeight = 15; <br>        break; <br> <br>    case WM_DRAWITEM: <br>        pdis = (DRAWITEMSTRUCT *) lParam; <br>        DrawOarItem (pdis, pdd-&gt;iDlgType); <br>        break; <br> <br>    case WM_CHARTOITEM:     /* don't select item by character*/ <br>        return -2; <br> <br>    /* Handled by IDC_DELETE */ <br>    case WM_DELETEITEM: <br>        return TRUE; <br> <br>//  HANDLE_MSG(hDlg, WM_COMMAND, Common_OnCommand); <br>    case WM_COMMAND: <br>        return ((Common_OnCommand)((hDlg), (int)(wParam), (HWND)(LOWORD(lParam)), 0L)); <br> <br>    }   /* switch (msg) */ <br> <br>    return FALSE; <br>} <br> <br> <br>BOOL Common_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    LPDIALOGDATA pdd = (LPDIALOGDATA) GetWindowLong(hDlg, DWL_USER); <br> <br>    switch (id) <br>    { <br>    case IDC_MSG: <br>        if(codeNotify != LBN_DBLCLK) <br>            break; <br>            /* FALL THROUGH to read the double-clicked store */ <br> <br>    case IDC_DOWN: <br>    case IDC_READ: <br>        /*/ open a Hierarchy or Store*/ <br>    { <br>            /*/ Open one of the items in the list*/ <br>        LPMDB pmdbTemp; <br>        UINT nIndex; <br>        LPOAR poar; <br>        LPSPropValue pProp; <br>        LPSPropValue pvalProp = NULL; <br>        HRESULT hr; <br> <br>        nIndex = (UINT)ListBox_GetCurSel(GetDlgItem(hDlg, IDC_MSG)); <br> <br>        if (nIndex == LB_ERR) <br>            return TRUE; <br> <br>        poar = (LPOAR) ListBox_GetItemData(GetDlgItem(hDlg, IDC_MSG), nIndex); <br> <br>        if (!poar) <br>            return TRUE; <br> <br>                /* PropFindProp from mapiutil.h */ <br>        pProp = PpropFindProp(poar-&gt;lpProps,  poar-&gt;cValues, PR_ENTRYID); <br>         <br>        Assert(pProp); <br>        /*/ Every row should have an EntryID */ <br>         <br>        if (pdd-&gt;iDlgType == iStores) <br>        { <br>            hr = pses-&gt;lpVtbl-&gt;OpenMsgStore(pses, <br>                (ULONG)hDlg, <br>                pProp-&gt;Value.bin.cb, <br>                (LPENTRYID)pProp-&gt;Value.bin.lpb, <br>                NULL, MDB_WRITE, &amp;pmdbTemp); <br> <br>            if (HR_FAILED(hr)) <br>            { <br>                if (GetScode(hr) != MAPI_E_USER_CANCEL) <br>                    MakeMessageBox (hDlg, GetScode(hr), IDS_OPENSTOREFAIL, NULL, MBS_ERROR); <br>                return TRUE; <br>                } <br>            if(hr) /*if we have a warning*/ <br>            { <br>                LPMAPIERROR perr = NULL; <br> <br>                pses-&gt;lpVtbl-&gt;GetLastError(pses, hr, 0, &amp;perr); <br>                MakeMessageBox(hDlg, GetScode(hr), IDS_OPENSTOREWARN, perr, MBS_ERROR); <br>                MAPIFreeBuffer(perr); <br>            } <br> <br> <br>            Assert(hr == hrSuccess);    /* no warnings (for now?)*/ <br> <br>            UlRelease(pmdb); <br>            pmdb = pmdbTemp; <br> <br>            /*Change the caption of the main window */ <br>            hr = HrGetOneProp((LPMAPIPROP)pmdb, PR_DISPLAY_NAME, &amp;pvalProp); <br>            if(!hr) <br>            { <br>                char buf[128]; <br>             <br>                wsprintf(buf, "Routing Sample: %s", pvalProp-&gt;Value.lpszA); <br>                SetWindowText(GetParent(hDlg), buf); <br> <br>                MAPIFreeBuffer(pvalProp); <br>                pvalProp = NULL; <br>            } <br>                     <br>            EndDialog (hDlg, TRUE); <br>            return TRUE; <br>        } <br> <br>        Assert (pdd-&gt;iDlgType == iHierarchy); <br> <br>        if (id == IDC_DOWN) <br>        { <br>            LPDIALOGDATA pDialogData; <br>            if (pDialogData = CreateDialogData (iHierarchy)) <br>            { <br>                pDialogData-&gt;cbEntryID = pProp-&gt;Value.bin.cb; <br>                pDialogData-&gt;lpEntryID = (LPENTRYID)pProp-&gt;Value.bin.lpb; <br>                DialogBoxParam (hInst, "HierarchyTable", hDlg, CommonDlgProc, (LPARAM)pDialogData); <br>            } <br> <br>        } <br>        else    /* IDC_READ */ <br>        { <br>            /* OPEN a contents table*/ <br>            Assert(lpeidFolderToView == NULL); <br>            cbeidFolderToView = pProp-&gt;Value.bin.cb; <br>            lpeidFolderToView = (LPENTRYID)pProp-&gt;Value.bin.lpb; <br>            DialogBox (hInst, "InBox", hDlg, InBoxDlgProc); <br>            lpeidFolderToView = NULL; <br>        } <br>    } <br>    return TRUE; <br> <br>    case IDC_CLOSE: <br>    case IDCANCEL: <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br> <br>    } <br> <br>    return TRUE; <br>} <br> <br>/* <br> -  PopulateStores <br> - <br> *  Accumulate all the rows of a table onto the OAR list. <br> *  idlgType indicates iStores, iHierarchy. <br> * <br> *  If iHierarchy, the EntryID of the folder is in cb/lpeid. <br> */ <br> <br>VOID <br>PopulateStores ( HWND hDlg, LPOAR FAR * ppoarHead, int idlgType, <br>        ULONG cb, LPENTRYID lpeid) <br>{ <br>    HRESULT hr; <br>    SCODE sc; <br>    LPMAPIFOLDER pfld = NULL; <br>    LPMAPITABLE ptable = NULL; <br>    LPSRowSet prows = NULL; <br>    LPSPropValue pvalProp = NULL; <br>    UINT idx; <br> <br>    /* Get the list of available message stores or folderes from MAPI*/ <br>    Assert(pses); <br> <br>    switch (idlgType) <br>    { <br>    case iStores: <br>        if (hr = pses-&gt;lpVtbl-&gt;GetMsgStoresTable(pses, 0, &amp;ptable)) <br>        { <br>            MakeMessageBox (hDlg, GetScode(hr), IDS_STORETBLFAIL, NULL, MBS_ERROR); <br>            goto ret; <br>        } <br>        break; <br>    case iHierarchy: <br>        { <br>            ULONG ulObjType; <br>            if (hr = pmdb-&gt;lpVtbl-&gt;OpenEntry(pmdb, cb, lpeid, NULL, <br>                                MAPI_DEFERRED_ERRORS, <br>                            &amp;ulObjType, (LPUNKNOWN FAR *) &amp;pfld)) <br>            { <br>                MakeMessageBox (hDlg, GetScode(hr), IDS_OPENFOLDERFAIL, NULL, MBS_ERROR); <br>                goto ret; <br>            } <br>            Assert(ulObjType == MAPI_FOLDER); <br>            if (hr = pfld-&gt;lpVtbl-&gt;GetHierarchyTable(pfld, MAPI_DEFERRED_ERRORS, <br>                                                        &amp;ptable)) <br>            { <br>                MakeMessageBox (hDlg, GetScode(hr), IDS_STORETBLFAIL, NULL, MBS_ERROR); <br>                goto ret; <br>            } <br>            hr = HrGetOneProp((LPMAPIPROP)pfld, PR_DISPLAY_NAME, &amp;pvalProp); <br>            if(!hr) <br>            { <br>                if(*pvalProp-&gt;Value.lpszA) <br>                    SetWindowText(hDlg, pvalProp-&gt;Value.lpszA); <br>                MAPIFreeBuffer(pvalProp); <br>                pvalProp = NULL; <br>            } <br>                     <br>        } <br>        break; <br>    default: <br>        Assert(0); <br>    } <br> <br>    if(hr = HrQueryAllRows(ptable, NULL, NULL, NULL, 1000l, &amp;prows)) <br>    { <br>        MakeMessageBox (hDlg, GetScode(hr), IDS_QUERYROWFAIL, NULL, MBS_ERROR); <br>        goto ret; <br>    } <br>    for(idx = 0; idx &lt; prows-&gt;cRows; ++idx) <br>    { <br>        LPOAR poar = NULL; <br>        sc = MAPIAllocateBuffer(sizeof(OAR), &amp;poar); <br>        if (sc) <br>        { <br>            hr = ResultFromScode(sc); <br>            FreeProws(prows);   /* free ENTIRE row*/ <br>            break; <br>        } <br>        /*/ Transfer the data of the row to our OAR structure.*/ <br>        poar-&gt;cValues = prows-&gt;aRow[idx].cValues; <br>        poar-&gt;lpProps = prows-&gt;aRow[idx].lpProps; <br> <br>        /* Put OAR at head of the list*/ <br>        if (*ppoarHead) <br>            (*ppoarHead)-&gt;lpPrev = poar; <br>        poar-&gt;lpPrev = NULL; <br>        poar-&gt;lpNext = (*ppoarHead); <br>        *ppoarHead  = poar; <br> <br>        ListBox_AddString(GetDlgItem(hDlg, IDC_MSG), (LONG) poar); <br>    } <br>     <br>    MAPIFreeBuffer(prows);  /* free OUTER buffer only*/ <br> <br>ret: <br>    UlRelease(ptable); <br>    UlRelease(pfld); <br>} <br> <br>/* <br> -  FreeOarList <br> - <br> *  Free the memory of the rows on the screen. <br> *  Zero the pointer passed in. <br> */ <br>VOID <br>FreeOarList (LPOAR FAR *ppoarHead) <br>{ <br>    LPOAR poar = *ppoarHead; <br> <br>    while (poar) <br>    { <br>        LPOAR poarTemp = poar; <br> <br>        poar = poarTemp-&gt;lpNext; <br>        MAPIFreeBuffer(poarTemp-&gt;lpProps); <br>        MAPIFreeBuffer(poarTemp); <br>    } <br> <br>    *ppoarHead = NULL; <br>} <br> <br>/* <br> -  DrawOarItem <br> - <br> *  Purpose: <br> *      Paint the client area of the owner-drawn listbox. <br> * <br> *  Parameters: <br> *      pdis        - Pointer to a DRAWITEMSTRUCT <br> * <br> *  Returns: <br> *      void <br> * <br> */ <br> <br>VOID <br>DrawOarItem (DRAWITEMSTRUCT FAR * pdis, int idlgType) <br>{ <br>    HBRUSH hSolidBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>    HBRUSH hOldBrush = SelectObject(pdis-&gt;hDC, hSolidBrush); <br> <br>    if (ODA_DRAWENTIRE &amp; pdis-&gt;itemAction) <br>    { <br>        LPOAR poar; <br>        LPSPropValue pProp; <br>        UINT c; <br> <br>        /* Clear the item Rectangle */ <br> <br>        PatBlt (pdis-&gt;hDC, pdis-&gt;rcItem.left, pdis-&gt;rcItem.top, <br>            pdis-&gt;rcItem.right - pdis-&gt;rcItem.left, <br>            pdis-&gt;rcItem.bottom - pdis-&gt;rcItem.top, PATCOPY); <br> <br>        /* Draw the item */ <br> <br>        poar = (LPOAR) pdis-&gt;itemData; <br> <br>        for (pProp = poar-&gt;lpProps, c = (UINT)poar-&gt;cValues; <br>            c &gt; 0; <br>            c-- , pProp++) <br>        { <br>            /* Identify the Default Store*/ <br>            if (idlgType == iStores <br>                    &amp;&amp; pProp-&gt;ulPropTag == PR_DEFAULT_STORE &amp;&amp; pProp-&gt;Value.b) <br>                TextOut (pdis-&gt;hDC, pdis-&gt;rcItem.left + 10, pdis-&gt;rcItem.top+2, <br>                    TEXT("&gt;"), 1); <br> <br>            if (pProp-&gt;ulPropTag == PR_DISPLAY_NAME) <br>                TextOut (pdis-&gt;hDC, pdis-&gt;rcItem.left + 20, pdis-&gt;rcItem.top+2, <br>                    pProp-&gt;Value.LPSZ, <br>                    lstrlen (pProp-&gt;Value.LPSZ)); <br> <br>        } <br> <br>        /* Invert item rectangle if item is selected */ <br> <br>        if (ODS_SELECTED &amp; pdis-&gt;itemState) <br>            PatBlt (pdis-&gt;hDC, pdis-&gt;rcItem.left, pdis-&gt;rcItem.top, <br>                pdis-&gt;rcItem.right - pdis-&gt;rcItem.left, <br>                pdis-&gt;rcItem.bottom - pdis-&gt;rcItem.top, DSTINVERT); <br> <br>        /* Draw a focus rectangle if item has focus */ <br> <br>        if (ODS_FOCUS &amp; pdis-&gt;itemState) <br>            DrawFocusRect (pdis-&gt;hDC, &amp;pdis-&gt;rcItem); <br>    } <br>    else <br>    { <br>        /* Invert the item if the selection state is changing */ <br> <br>        if (ODA_SELECT &amp; pdis-&gt;itemAction) <br>            PatBlt (pdis-&gt;hDC, pdis-&gt;rcItem.left, pdis-&gt;rcItem.top, <br>                pdis-&gt;rcItem.right - pdis-&gt;rcItem.left, <br>                pdis-&gt;rcItem.bottom - pdis-&gt;rcItem.top, DSTINVERT); <br> <br>        /* Draw a focus if the focus state is changing */ <br> <br>        if (ODA_FOCUS &amp; pdis-&gt;itemAction) <br>            DrawFocusRect (pdis-&gt;hDC, &amp;pdis-&gt;rcItem); <br>    } <br> <br>    SelectObject(pdis-&gt;hDC, hOldBrush); <br>    DeleteObject(hSolidBrush); <br>} <br> <br> <br>/* Fill the lppMsgIdList with info about the messages in the specified folder. */ <br>enum { E_EID=0, E_SUBJECT, E_SENDER_NAME, E_MSG_DEL_TIME, E_FLAGS, E_PRIORITY, E_CONVERS_KEY, <br>        E_SEARCH_KEY, E_CLASS, E_RECORD_KEY, E_PTINBOXDIM}; <br>SizedSPropTagArray(E_PTINBOXDIM, ptInbox) = <br>{ <br>    E_PTINBOXDIM, <br>    { <br>        PR_ENTRYID, <br>        PR_SUBJECT, <br>        PR_SENDER_NAME, <br>        PR_MESSAGE_DELIVERY_TIME, <br>        PR_MESSAGE_FLAGS, <br>        PR_PRIORITY, <br>        PR_CONVERSATION_KEY, <br>        PR_SEARCH_KEY, <br>        PR_MESSAGE_CLASS, <br>        PR_RECORD_KEY <br>    } <br>}; <br> <br>VOID <br>PopulateMessages( HWND hDlg, LPINBOXDATA pibData ) <br>{ <br>    LPMAPIFOLDER pfld = pibData-&gt;pfld; <br>    LPMAPITABLE ptable = NULL; <br>    LPSRowSet prows = NULL; <br>    HRESULT hr; <br>    ULONG ulType; <br>    SizedSSortOrderSet(1, sos) = <br>        { 1, 0, 0, { PR_MESSAGE_DELIVERY_TIME, TABLE_SORT_ASCEND } }; <br>    UINT nIndex; <br>    LPMSGID lpMsgNode; <br>    LPSPropValue pvalProp = NULL; <br> <br>    ListBox_ResetContent(GetDlgItem(hDlg, IDC_MSG)); <br> <br>    if(!pfld) <br>    { <br>        /* Open the right folder, and get the list of messages. */ <br>        hr = pmdb-&gt;lpVtbl-&gt;OpenEntry(pmdb,cbeidFolderToView, lpeidFolderToView, <br>                                 NULL, MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>                                    &amp;ulType, (LPUNKNOWN FAR *)&amp;pfld); <br>        if(GetScode(hr) != S_OK)    goto ret; <br> <br>        Assert(ulType == MAPI_FOLDER); <br>        pibData-&gt;pfld = pfld; <br>        hr = HrGetOneProp((LPMAPIPROP)pfld, PR_DISPLAY_NAME, &amp;pvalProp); <br>        if(!hr) <br>        { <br>            if(*pvalProp-&gt;Value.lpszA) <br>                SetWindowText(hDlg, pvalProp-&gt;Value.lpszA); <br>            MAPIFreeBuffer(pvalProp); <br>            pvalProp = NULL; <br>        } <br>    } <br>    hr = pfld-&gt;lpVtbl-&gt;GetContentsTable(pfld, MAPI_DEFERRED_ERRORS, &amp;ptable); <br>    if (hr) <br>        goto ret; <br> <br>    if (hr = HrQueryAllRows(ptable, (LPSPropTagArray) &amp;ptInbox, NULL, <br>        (LPSSortOrderSet) &amp;sos, 0, &amp;prows)) <br>    { <br>        MakeMessageBox (hDlg, GetScode(hr), IDS_QUERYROWFAIL, NULL, MBS_ERROR); <br>        goto ret; <br>    } <br> <br>    for (nIndex = 0; nIndex &lt; prows-&gt;cRows; ++nIndex) <br>    { <br>        lpMsgNode = MakeMsgNode(prows-&gt;aRow + nIndex); <br> <br>        if (lpMsgNode) <br>        { <br>            InsertMsgNode(lpMsgNode, &amp;pibData-&gt;lpMsgIdList); <br> <br>            ListBox_AddString(GetDlgItem(hDlg, IDC_MSG),(LONG) lpMsgNode); <br>        } <br>    } <br>    FreeProws(prows); <br> <br>     <br> <br>ret: <br>    UlRelease(ptable); <br>} <br> <br>/* <br> -  MakeMsgNode <br> - <br> *  Purpose: <br> *      Allocate memory for a new MSGID node and initialize its <br> *      data members to the values passed in. <br> *      A separate allocation is used for each property which is pretty <br> *      wastefull. This can be changed to a smarter allocation scheme. <br> * <br> *  Parameters: <br> *       <br> *  Return: <br> *      lpMsgNode       - Pointer to new node <br> */ <br> <br>LPMSGID <br>MakeMsgNode (LPSRow prow) <br>{ <br>    LPMSGID lpMsgNode = NULL; <br> <br>    if (!prow) <br>        goto err; <br> <br>    if (MAPIAllocateBuffer (sizeof (MSGID), (LPVOID far *) &amp; lpMsgNode)) <br>        goto err; <br> <br>    ZeroMemory(lpMsgNode, sizeof (MSGID)); <br> <br>    if(prow-&gt;lpProps[E_FLAGS].ulPropTag == PR_MESSAGE_FLAGS) <br>    { <br>        lpMsgNode-&gt;fHasAttach = !!(prow-&gt;lpProps[E_FLAGS].Value.l &amp; MSGFLAG_HASATTACH); <br>        lpMsgNode-&gt;fUnRead = !(prow-&gt;lpProps[E_FLAGS].Value.l &amp; MSGFLAG_READ); <br>    } <br> <br>    if(prow-&gt;lpProps[E_EID].ulPropTag == PR_ENTRYID) <br>    {    <br>        if (MAPIAllocateMore(prow-&gt;lpProps[E_EID].Value.bin.cb, lpMsgNode, <br>                    (LPVOID FAR *)&amp;lpMsgNode-&gt;lpEID)) <br>            goto err; <br>        CopyMemory(lpMsgNode-&gt;lpEID, prow-&gt;lpProps[E_EID].Value.bin.lpb, prow-&gt;lpProps[E_EID].Value.bin.cb); <br>        lpMsgNode-&gt;cbEID = prow-&gt;lpProps[E_EID].Value.bin.cb; <br>    } <br> <br>    if(prow-&gt;lpProps[E_SENDER_NAME].ulPropTag == PR_SENDER_NAME) <br>    { <br>        if (MAPIAllocateMore (lstrlen (prow-&gt;lpProps[E_SENDER_NAME].Value.LPSZ) + 1, <br>                    lpMsgNode, (LPVOID far *) &amp; lpMsgNode-&gt;lpszFrom)) <br>        goto err; <br>        lstrcpy (lpMsgNode-&gt;lpszFrom, prow-&gt;lpProps[E_SENDER_NAME].Value.LPSZ); <br>    } <br>         <br>    if(prow-&gt;lpProps[E_SUBJECT].ulPropTag == PR_SUBJECT) <br>    { <br>        if (MAPIAllocateMore (lstrlen (prow-&gt;lpProps[E_SUBJECT].Value.LPSZ) + 1, lpMsgNode, <br>                    (LPVOID far *) &amp; lpMsgNode-&gt;lpszSubject)) <br>            goto err; <br>        lstrcpy (lpMsgNode-&gt;lpszSubject, prow-&gt;lpProps[E_SUBJECT].Value.LPSZ); <br>    } <br>     <br>    if(prow-&gt;lpProps[E_MSG_DEL_TIME].ulPropTag == PR_MESSAGE_DELIVERY_TIME) <br>    { <br>        if (MAPIAllocateMore (32, lpMsgNode,(LPVOID far *) &amp; lpMsgNode-&gt;lpszDateRec)) <br>            goto err; <br>        FormatFILETIME (&amp;prow-&gt;lpProps[E_MSG_DEL_TIME].Value.ft, lpMsgNode-&gt;lpszDateRec); <br>    } <br>     <br>    return lpMsgNode; <br> <br>err: <br>    MAPIFreeBuffer (lpMsgNode); <br>    return NULL; <br>} <br> <br>/* <br> -  InsertMsgNode <br> - <br> *  Purpose: <br> *      We insert the nodes <br> *      at the beginning of the list.  This can be <br> *      replaced with a routine that inserts sorted on <br> *      different criteria, like DateReceived, From, or <br> *      Subject. <br> * <br> *  Parameters: <br> *      lpMsgNode       - Pointer to a MSGID node <br> *      lppMsgHead      - Pointer to the head of the list <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void <br>InsertMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead) <br>{ <br>    if (*lppMsgHead) <br>    { <br>        lpMsgNode-&gt;lpNext = *lppMsgHead; <br>        (*lppMsgHead)-&gt;lpPrev = lpMsgNode; <br>    } <br>    else <br>        lpMsgNode-&gt;lpNext = NULL; <br> <br>    /* The next 2 assignments are here in case the node came from somewhere */ <br>    /* other than a call to MakeMsgNode () in which case we aren't sure */ <br>    /* they're already NULL. */ <br> <br>    lpMsgNode-&gt;lpPrev = NULL; <br>    *lppMsgHead = lpMsgNode; <br>} <br> <br>/* <br> -  DeleteMsgNode <br> - <br> *  Purpose: <br> *      Removes the node passed in from the list.  This <br> *      may seem like a strange way to do this but it's <br> *      not, because the Owner-Drawn List Box gives us <br> *      direct access to elements in the list that makes <br> *      it easier to do things this way. <br> * <br> *  Parameters: <br> *      lpMsgNode       - Pointer to the MSGID node to delete <br> *      lppMsgHead      - Pointer to the head of the list <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void <br>DeleteMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead) <br>{ <br>    if (!lpMsgNode) <br>        return; <br> <br>    if (lpMsgNode-&gt;lpPrev) <br>    { <br>        /* Adjust Previous node to point to Next*/ <br>        Assert(*lppMsgHead != lpMsgNode); <br>        lpMsgNode-&gt;lpPrev-&gt;lpNext = lpMsgNode-&gt;lpNext; <br>    } <br>    else <br>    { <br>        /*/ Adjust Head to point to Next*/ <br>        Assert(*lppMsgHead == lpMsgNode); <br>        *lppMsgHead = lpMsgNode-&gt;lpNext; <br>    } <br> <br>    /* Adjust next node to point to Previous*/ <br> <br>    if (lpMsgNode-&gt;lpNext) <br>        lpMsgNode-&gt;lpNext-&gt;lpPrev = lpMsgNode-&gt;lpPrev; <br> <br>    MAPIFreeBuffer (lpMsgNode); <br>    return; <br>} <br> <br> <br> <br>/* <br> -  FindNode <br> - <br> *  Purpose: <br> *      Returns a pointer to the node with EntryID equal to *pEntryID. <br> *      Returns NULL if node doesn't exist. <br> * <br> *  Parameters: <br> *      lpMsgHead       - Pointer to the head of the list <br> *      pEntryID + cbEntryID    - Message ID to search for <br> * <br> *  Return: <br> *      lpMsgNode       - Pointer to the node returned <br> */ <br> <br>LPMSGID <br>FindNode (LPMSGID lpMsgHead, LPENTRYID pEntryID, ULONG cbEntryID) <br>{ <br>    ULONG fl; <br>    HRESULT hr; <br> <br>    Assert(pmdb); <br> <br>    while (lpMsgHead) <br>    { <br>        hr = pmdb-&gt;lpVtbl-&gt;CompareEntryIDs(pmdb, cbEntryID, pEntryID, lpMsgHead-&gt;cbEID, lpMsgHead-&gt;lpEID, <br>                                            0, &amp;fl); <br>        if(S_OK != GetScode(hr)) <br>            return NULL; <br>        if(fl) <br>            break; <br> <br>        lpMsgHead = lpMsgHead-&gt;lpNext; <br>    } <br> <br>    return lpMsgHead; <br>} <br> <br>/* <br> -  FreeMsgList <br> - <br> *  Purpose: <br> *      Walks down the MsgList and frees each node. <br> * <br> *  Parameters: <br> *      lpMsgHead       - Pointer to the head of the list <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void <br>FreeMsgList (LPMSGID lpMsgHead) <br>{ <br>    LPMSGID lpT; <br> <br>    while (lpMsgHead) <br>    { <br>        lpT = lpMsgHead; <br>        lpMsgHead = lpMsgHead-&gt;lpNext; <br>        MAPIFreeBuffer (lpT); <br>    } <br>} <br> <br>/* <br> -  ToggleMenuState <br> - <br> *  Purpose: <br> *      Enables/Disables menu items depending on the session state. <br> * <br> *  Parameters: <br> *      hWnd            - handle to the window/dialog who called us <br> *      fLoggedOn       - TRUE if logged on, FALSE if logged off <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void ToggleMenuState(HWND hWnd, BOOL fLoggedOn) <br>{ <br>    EnableMenuItem (GetMenu (hWnd), IDM_HIER,     !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_OPEN,     !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGOFF,   !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_ROUTE,    !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_READ,     !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_SEND,     !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_NEWFORM,  !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGON,    fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,       FALSE); <br>} <br> <br>// <br>//  SecureMenu <br>// <br>//  Purpose: <br>//      Enables/Disables Logon and Exit menu items. <br>//      CMCLogon might yield control to Windows, so the user might be able to <br>//      access the window menu (for example click Logon) after we call <br>//      MAPILogon, but before it returns. <br>// <br>//  Parameters: <br>//      hWnd            - handle to the window/dialog who called us <br>//      fBeforeLogon    - TRUE when this function is called when we are about <br>//                      to call MAPILogon, FALSE if called after logon (failed) <br>//                      if Logon succeddes ToggleMenuState is called instead of <br>//                      this function. <br>// <br>//  Return: <br>//      Void. <br>// <br> <br> <br>void SecureMenu(HWND hWnd, BOOL fBeforeLogon) <br>{ <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGON, fBeforeLogon); <br>    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,  fBeforeLogon); <br>} <br> <br> <br>/* <br> *  Formats a Win32 file time as a MAPI date/time string. <br> *  NOTE: converts from GMT to local time. <br> */ <br>void FormatFILETIME(FILETIME *pft, LPSTR szTime) <br>{ <br>    FILETIME        ft; <br>    SYSTEMTIME      systime; <br> <br>    FileTimeToLocalFileTime(pft, &amp;ft); <br>    FileTimeToSystemTime(&amp;ft, &amp;systime); <br>    wsprintf(szTime, <br>        "%04.4d/%02.2d/%02.2d %02.2d:%02.2d", <br>        systime.wYear, systime.wMonth, systime.wDay, <br>        systime.wHour, systime.wMinute); <br>} <br> <br>/* <br> *  Create a data block used in CommonDlgProc to remember <br> *  the entire chain of rows in the scrolling list box. <br> */ <br>LPDIALOGDATA <br>CreateDialogData (int iDlgType) <br>{ <br>    LPDIALOGDATA pDialogData; <br> <br>    SCODE sc; <br> <br>    sc = MAPIAllocateBuffer(sizeof(DIALOGDATA), &amp;pDialogData); <br>    if (sc) <br>    { <br>        MakeMessageBox (0, MAPI_E_NOT_ENOUGH_MEMORY, IDS_OPERATION, NULL, MBS_ERROR); <br>        return NULL; <br>    } <br> <br>    pDialogData-&gt;iDlgType = iDlgType; <br>    pDialogData-&gt;poarHead = NULL; <br>    pDialogData-&gt;cbEntryID = 0; <br>    pDialogData-&gt;lpEntryID = NULL; <br>    return pDialogData; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
