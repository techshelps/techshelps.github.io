<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPSNDMSG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2158"></a>XPSNDMSG.C</h2>
<pre><code>/* <br> -  X P S N D M S G . C <br> - <br> *  Purpose: <br> *      Code to support the MAPI Transport SPI entry points for <br> *      message transmission. <br> *      This module contains the following SPI entry points: <br> * <br> *          SubmitMessage() <br> *          EndMessage() <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "xppch.h" <br> <br> <br>HRESULT HrAddDeferred(LPXPL lpxpl, LPMESSAGE lpMsg, ULONG *lpulMsgRef); <br> <br> <br>/* <br> -  XPL_SubmitMessage <br> - <br> *  Purpose: <br> *      Called by the Spooler when it wishes to attempt transmission <br> *      of a message. <br> * <br> *  Parameters: <br> *      ulFlags             Flags from the Spooler. The only <br> *                          flag defined in the MAPI 1.0 TSPI <br> *                          is BEGIN_DEFERRED, and this transport <br> *                          doesn't do deferred transmission. <br> *      lpMessage           Pointer to message object that the <br> *                          Spooler wants sent. <br> *      lpulMsgRef          Pointer to where the transport should <br> *                          store a unsigned long for use in <br> *                          identifying TransportNotify() message <br> *                          events. Initialized to 1 by the <br> *                          Spooler. We use this to ID deferred <br> *                          messages using DEFERRED_MSG_REF. <br> *      lpulReturnParm      Used for several MAPI_E_XXX returns, <br> *                          but this transport doesn't do any <br> *                          of them. <br> * <br> *  Returns: <br> *      (HRESULT)           MAPI_E_BUSY if the Spooler calls <br> *                          here again while we're busy, else <br> *                          errors encountered if any. <br> * <br> *  Operation: <br> *      For non peer-to-peer, "send" the message to our outbound directory. <br> * <br> *      For peer-to-peer, use the ADRLIST builder HrBuildAdrList to attempt <br> *      transmission to each recipient and build both a sent ADRLIST and a <br> *      NDR ADRLIST. ModifyRecipients() on the Spooler message if there's <br> *      anyone in the sent ADRLIST. This tells the spooler which ones got <br> *      the mail.  If there were any recipients in the NDR ADRLIST, we need <br> *      to StatusRecips() with that list, and we will need to <br> *      ModifyRecipients() again with them. <br> * <br> *      For non peer-to-peer or p2p with NDR recipients, use the ADRLIST <br> *      builder HrBuildAdrList to make a ADRLIST with all of our unsent <br> *      recipients (for non p2p, delivery to all recipients consists of <br> *      putting a file into the outbound and for NDR cases, we just take <br> *      responsibility because we've already NDR'ed them) and <br> *      ModifyRecipients(). <br> */ <br> <br>STDMETHODIMP <br>XPL_SubmitMessage(LPXPL lpxpl, <br>    ULONG ulFlags, <br>    LPMESSAGE lpMessage, <br>    ULONG * lpulMsgRef, <br>    ULONG * lpulReturnParm) <br>{ <br>    LPTSTR lpszMyDir; <br>    HRESULT hResult = 0; <br>    SCODE sc = 0; <br>    BOOL fUpdatedStatus = FALSE; <br>    BOOL fPeer2Peer; <br> <br>    LPSPropValue lpPropArray = NULL; <br>    LPMAPISUP lpMAPISup; <br> <br>    ULONG cValues; <br>    LPSPropValue lpMsgProps = NULL; <br> <br>    static const SizedSPropTagArray(2, sptMsgDefer) = <br>    { <br>        2, <br>        { <br>            PR_SAMPLE_PER_MSG_DEFER, <br>            PR_SAMPLE_PER_RECIP_DEFER <br>        } <br>    }; <br> <br>    SPropValue spvRecipUnsent = <br>    {PR_RESPONSIBILITY, 0L, FALSE}; <br>    SPropValue spvRecipDefer = <br>    {PR_SAMPLE_PER_RECIP_DEFER, 0L, TRUE}; <br>    SRestriction rgsrOr[2]; <br>    SRestriction rgsrAnd[2]; <br>    SRestriction srExist; <br>    SRestriction srRecipUnsent; <br> <br>    LPMAPITABLE lpTable = NULL; <br>    LPMYADRLIST lpMyAdrListDone = NULL; <br>    LPMYADRLIST lpMyAdrListNotDone = NULL; <br> <br>    /* Simple re-entrancy test. Should never happen anyway. */ <br> <br>    if (lpxpl-&gt;ulTransportStatus &amp; STATUS_OUTBOUND_ACTIVE) <br>    { <br>        hResult = ResultFromScode(MAPI_E_BUSY); <br>        DebugTrace("XPL_SubmitMessage reentrancy test failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Signal that we're uploading. */ <br> <br>    lpxpl-&gt;ulTransportStatus |= STATUS_OUTBOUND_ACTIVE; <br>    hResult = HrUpdateTransportStatus(lpxpl, 0L); <br>    if (hResult) <br>        goto ret; <br>    fUpdatedStatus = TRUE; <br> <br>    /*  Session's OK, hook up some local references */ <br> <br>    sc = ScCopySessionProps(lpxpl, &amp;lpPropArray, NULL); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("ScCopySessionProps failed in SubmitMessage.\n"); <br>        goto ret; <br>    } <br> <br>    lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    fPeer2Peer = ((ArrayIndex(PR_SAMPLE_FLAGS, lpPropArray).Value.ul) &amp; PR_SAMPLE_FLAG_PEER_TO_PEER) != 0; <br>    lpszMyDir = ArrayIndex(PR_SAMPLE_OUTBOUND_DIR, lpPropArray).Value.LPSZ; <br> <br>    PrintfTransportLog(TEXT("Start Outbound: %s"), <br>        ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpPropArray).Value.LPSZ); <br> <br>    /* Reset the timer for SpoolerYield() */ <br> <br>    HrCheckSpoolerYield(lpMAPISup, TRUE); <br> <br>    /* Check if we are to defer this message */ <br> <br>    hResult = lpMessage-&gt;lpVtbl-&gt;GetProps(lpMessage, <br>        (LPSPropTagArray) &amp;sptMsgDefer, 0, /* ansi */ <br>        &amp;cValues, &amp;lpMsgProps); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("Failed getting props on the message.\n"); <br>        goto ret; <br>    } <br> <br>    /* We'll default fResendDeferred to TRUE unless we defer this msg */ <br> <br>    lpxpl-&gt;fResendDeferred = TRUE; <br> <br>    /* If PR_SAMPLE_PER_MSG_DEFER exists and is TRUE, then we delete <br>       this property from the message, and add this message to our <br>       deferred list.  The lpulMsgRef is set to the value assigned to <br>       the node in our list.  When EndMessage is called we search for <br>       this Ref in to list.  If found, we return END_DONT_RESEND, <br>       causing the spooler to defer the msg. */ <br> <br>    if (lpMsgProps-&gt;ulPropTag == PR_SAMPLE_PER_MSG_DEFER) <br>    { <br>        lpMessage-&gt;lpVtbl-&gt;DeleteProps(lpMessage, <br>            (LPSPropTagArray) &amp;sptMsgDefer, NULL); <br> <br>        lpMessage-&gt;lpVtbl-&gt;SaveChanges(lpMessage, KEEP_OPEN_READWRITE); <br> <br>        if (lpMsgProps-&gt;Value.b == TRUE) <br>        { <br>            hResult = HrAddDeferred(lpxpl, lpMessage, lpulMsgRef); <br>            goto ret; <br>        } <br>    } <br> <br>    /* Now, see if any Recipients have PR_SAMPLE_PER_RECIP_DEFER set to <br>       TRUE in the RecipientTable.  If so, then slam a non-transmittable <br>       property into the message to indicate we've deferred this message <br>       for some recipients this time around.  If this property already <br>       exists, then we know it has already been deferred and we should <br>       just go ahead and send to all un-handled recipients.              */ <br> <br>    if (lpMsgProps[1].ulPropTag == PR_SAMPLE_PER_RECIP_DEFER) <br>    { <br>        lpMessage-&gt;lpVtbl-&gt;DeleteProps(lpMessage, <br>            (LPSPropTagArray) &amp;sptMsgDefer, NULL); <br> <br>        lpMessage-&gt;lpVtbl-&gt;SaveChanges(lpMessage, KEEP_OPEN_READWRITE); <br> <br>        /*  Initialize a restriction -- we'll need it soon. */ <br> <br>        srRecipUnsent.rt = RES_PROPERTY; <br>        srRecipUnsent.res.resProperty.relop = RELOP_EQ; <br>        srRecipUnsent.res.resProperty.ulPropTag = PR_RESPONSIBILITY; <br>        srRecipUnsent.res.resProperty.lpProp = &amp;spvRecipUnsent; <br>    } <br>    else <br>    { <br>        SRestriction srRecipDefer; <br> <br>        srRecipDefer.rt = RES_PROPERTY; <br>        srRecipDefer.res.resProperty.relop = RELOP_EQ; <br>        srRecipDefer.res.resProperty.ulPropTag = PR_SAMPLE_PER_RECIP_DEFER; <br>        srRecipDefer.res.resProperty.lpProp = &amp;spvRecipDefer; <br> <br>        hResult = lpMessage-&gt;lpVtbl-&gt;GetRecipientTable( <br>            lpMessage, 0L, &amp;lpTable); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("GetRecipientTable failed in SubmitMessage.\n"); <br>            goto ret; <br>        } <br> <br>        hResult = lpTable-&gt;lpVtbl-&gt;FindRow(lpTable, &amp;srRecipDefer, <br>            BOOKMARK_BEGINNING, 0); <br> <br>        /* Check our .2 second timer! */ <br> <br>        sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br> <br>        if (sc == MAPI_W_CANCEL_MESSAGE) <br>        { <br>            DebugTrace("Cancelling message delivery.\n"); <br>            goto ret; <br>        } <br> <br>        if (GetScode(hResult) != MAPI_E_NOT_FOUND) <br>        { <br>            hResult = HrAddDeferred(lpxpl, lpMessage, lpulMsgRef); <br> <br>            if (HR_FAILED(hResult)) <br>            { <br>                DebugTrace("HrAddDeferred failed doing a per-recip deferral.\n"); <br>                goto ret; <br>            } <br>        } <br>        else <br>        { <br>            hResult = lpTable-&gt;lpVtbl-&gt;SeekRow(lpTable, <br>                BOOKMARK_BEGINNING, 0L, NULL); <br>        } <br> <br>        /*  Initialize a restriction -- we'll need it soon. */ <br> <br>        spvRecipDefer.Value.b = FALSE; <br> <br>        srExist.rt = RES_EXIST; <br>        srExist.res.resExist.ulPropTag = PR_SAMPLE_PER_RECIP_DEFER; <br> <br>        rgsrOr[0].rt = RES_NOT; <br>        rgsrOr[0].res.resNot.lpRes = &amp;srExist; <br> <br>        rgsrOr[1].rt = RES_PROPERTY; <br>        rgsrOr[1].res.resProperty.relop = RELOP_EQ; <br>        rgsrOr[1].res.resProperty.ulPropTag = PR_SAMPLE_PER_RECIP_DEFER; <br>        rgsrOr[1].res.resProperty.lpProp = &amp;spvRecipDefer; <br> <br>        rgsrAnd[0].rt = RES_PROPERTY; <br>        rgsrAnd[0].res.resProperty.relop = RELOP_EQ; <br>        rgsrAnd[0].res.resProperty.ulPropTag = PR_RESPONSIBILITY; <br>        rgsrAnd[0].res.resProperty.lpProp = &amp;spvRecipUnsent; <br> <br>        rgsrAnd[1].rt = RES_OR; <br>        rgsrAnd[1].res.resOr.cRes = 2; <br>        rgsrAnd[1].res.resOr.lpRes = rgsrOr; <br> <br>        srRecipUnsent.rt = RES_AND; <br>        srRecipUnsent.res.resAnd.cRes = 2; <br>        srRecipUnsent.res.resAnd.lpRes = rgsrAnd; <br>    } <br> <br>    /* Check our .2 second timer before attempting to send */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br> <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message delivery.\n"); <br>        goto ret; <br>    } <br> <br>    /*  If not peer-to-peer, "send message" to our outbound directory. */ <br> <br>    if (!fPeer2Peer) <br>    { <br>        BOOL fSent; <br> <br>        hResult = HrSendOneMessage(lpxpl, lpPropArray, <br>                lpMessage, 0, lpszMyDir, &amp;fSent); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("Copying message to outbound failed.\n"); <br>            goto ret; <br>        } <br>    } <br> <br>    /*  If we are peer-to-peer, send to all our recipients. */ <br> <br>    else <br>    { <br>        /*  Get the recipient table from the message if we haven't already */ <br> <br>        if (!lpTable) <br>        { <br>            hResult = lpMessage-&gt;lpVtbl-&gt;GetRecipientTable( <br>                lpMessage, 0L, &amp;lpTable); <br> <br>            if (hResult) <br>            { <br>                DebugTrace("GetRecipientTable failed in SubmitMessage.\n"); <br>                goto ret; <br>            } <br>        } <br> <br>        /*  Restrict to all unsent recipients */ <br> <br>        hResult = lpTable-&gt;lpVtbl-&gt;Restrict(lpTable, &amp;srRecipUnsent, 0L); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("Restriction on recipient table  failed in SubmitMessage.\n"); <br>            goto ret; <br>        } <br> <br>        /* Check our .2 second timer! */ <br> <br>        sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br> <br>        if (sc == MAPI_W_CANCEL_MESSAGE) <br>        { <br>            DebugTrace("Cancelling message delivery.\n"); <br>            goto ret; <br>        } <br> <br>        /*  Send to the recipients which we can reach, and build ADRLISTs of <br>            the sent and unsent recipients */ <br> <br>        hResult = HrBuildAdrList(lpxpl, lpPropArray, lpMessage, lpTable, <br>                TRUE, HrSendOneMessage, &amp;lpMyAdrListDone, &amp;lpMyAdrListNotDone); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("HrBuildAdrList failed in SubmitMessage.\n"); <br>            goto ret; <br>        } <br> <br>        /*  No error, do we have some recipients? If so, do the ModifyRecipients(). */ <br> <br>        if (lpMyAdrListDone) <br>        { <br>            hResult = lpMessage-&gt;lpVtbl-&gt;ModifyRecipients(lpMessage, <br>                    MODRECIP_MODIFY, lpMyAdrListDone-&gt;lpAdrList); <br> <br>            if (hResult) <br>            { <br>                DebugTrace("ModifyRecipients failed in SubmitMessage.\n"); <br>                goto ret; <br>            } <br> <br>            /* Now we need to save changes on the message. */ <br> <br>            hResult = lpMessage-&gt;lpVtbl-&gt;SaveChanges(lpMessage, <br>                    lpMyAdrListNotDone ? KEEP_OPEN_READWRITE : 0L); <br> <br>            if (hResult) <br>            { <br>                DebugTrace("SaveChanges failed in SubmitMessage.\n"); <br>                goto ret; <br>            } <br>        } <br> <br>        /*  Check for unsent recipients. If there were any, we need to NDR <br>            them and (finally) mark them as taken. If there were not any, <br>            we're really finished and can just go and release the message. */ <br> <br>        if (!lpMyAdrListNotDone) <br>            goto ret; <br> <br>        hResult = lpMAPISup-&gt;lpVtbl-&gt;StatusRecips(lpMAPISup, <br>                lpMessage, lpMyAdrListNotDone-&gt;lpAdrList); <br> <br>        if (HR_FAILED(hResult)) <br>        { <br>            DebugTrace("StatusRecips failed in SubmitMessage.\n"); <br>            goto ret; <br>        } <br> <br>        /*  StatusRecips killed the ADRLIST so zero out our pointer. */ <br> <br>        lpMyAdrListNotDone-&gt;lpAdrList = NULL; <br> <br>        /* Get rid of the MYADRLISTs. */ <br> <br>        FreeMyAdrList(lpxpl, lpMyAdrListDone); <br>        FreeMyAdrList(lpxpl, lpMyAdrListNotDone); <br> <br>        lpMyAdrListDone = lpMyAdrListNotDone = NULL; <br> <br>        /*  Free the recipient table. */ <br> <br>        lpTable-&gt;lpVtbl-&gt;Release(lpTable); <br>        lpTable = NULL; <br>    } <br> <br>    /* Check our .2 second timer after attempting to send */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br> <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message delivery.\n"); <br>        goto ret; <br>    } <br> <br>    /*  At this point we have either: <br> <br>        a)  If not peer-to-peer, made a single container file in <br>            the outbound directory <br>        b)  If peer-to-peer, created a container file in every <br>            inbound directory we were able to reach (but not all <br>            of them) -- and have NDR'ed the ones we could not reach <br> <br>        All that remains to do is to mark all unsent recipients as <br>        handled, since in the non-peer case the creation of the <br>        container suffices as "handling" and in the peer case the <br>        NDR message also does this. <br>    */ <br> <br>    hResult = lpMessage-&gt;lpVtbl-&gt;GetRecipientTable(lpMessage, 0L, &amp;lpTable); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("Second GetRecipientTable failed in SubmitMessage.\n"); <br>        goto ret; <br>    } <br> <br>    /*  Restrict the recipient table to the remaining unsent */ <br> <br>    hResult = lpTable-&gt;lpVtbl-&gt;Restrict(lpTable, &amp;srRecipUnsent, 0L); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("Restriction on recipient table failed.\n"); <br>        goto ret; <br>    } <br> <br>    /*  Build the ADRLIST of the unsent recipients */ <br> <br>    hResult = HrBuildAdrList(lpxpl, lpPropArray, lpMessage, lpTable, <br>            TRUE, NULL,  &amp;lpMyAdrListDone, &amp;lpMyAdrListNotDone); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("HrBuildAdrList failed in SubmitMessage.\n"); <br>        goto ret; <br>    } <br> <br>    Assert(!lpMyAdrListNotDone); <br> <br>    /*  No error, do we have some recipients? If so, do the ModifyRecipients(). */ <br> <br>    if (lpMyAdrListDone) <br>    { <br>        hResult = lpMessage-&gt;lpVtbl-&gt;ModifyRecipients(lpMessage, <br>                MODRECIP_MODIFY, lpMyAdrListDone-&gt;lpAdrList); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("ModifyRecipients failed in SubmitMessage.\n"); <br>            goto ret; <br>        } <br>    } <br> <br>    /*  Release the table, we're finished with it */ <br> <br>    UlRelease(lpTable); <br>    lpTable = NULL; <br> <br>    /* With the recipient table work done, save changes again. */ <br> <br>    hResult = lpMessage-&gt;lpVtbl-&gt;SaveChanges(lpMessage, 0L); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("SaveChanges failed in SubmitMessage.\n"); <br>        goto ret; <br>    } <br> <br>    PrintfTransportLog(TEXT("End Outbound: %s"), <br>        ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpPropArray).Value.LPSZ); <br> <br>ret: <br>    /* Free-Up Memory */ <br> <br>    lpxpl-&gt;FreeBuffer(lpPropArray); <br>    lpxpl-&gt;FreeBuffer(lpMsgProps); <br> <br>    /* Get rid of any MYADRLISTs. */ <br> <br>    FreeMyAdrList(lpxpl, lpMyAdrListDone); <br>    FreeMyAdrList(lpxpl, lpMyAdrListNotDone); <br> <br>    /* Release any open table */ <br> <br>    UlRelease(lpTable); <br> <br>    /* Release the spooler's message if need be */ <br> <br>    UlRelease(lpMessage); <br> <br>    /* Reset upload status if set. If this errors, use the error only <br>       if no other error had occurred here. */ <br> <br>    if (fUpdatedStatus) <br>    { <br>        lpxpl-&gt;ulTransportStatus &amp;= ~STATUS_OUTBOUND_ACTIVE; <br>        (void)HrUpdateTransportStatus(lpxpl, 0L); <br>    } <br> <br>    DebugTraceResult(XPL_SubmitMessage, hResult); <br>    return hResult; <br> <br>} <br> <br>/* <br> -  XPL_EndMessage <br> - <br> *  Purpose: <br> *      Called by the Spooler to complete transmission of a message. <br> * <br> *  Parameters: <br> *      ulMsgRef            Opaque identifier from SubmitMessage <br> *      lpulFlags           Pointer to where the transport should <br> *                          store special flags on return. This <br> *                          Transport doesn't use any. <br> * <br> *  Returns: <br> *      (HRESULT)           Success. <br> * <br> *  Operation: <br> *      Clears unsigned long status, and returns success. <br> */ <br> <br>STDMETHODIMP <br>XPL_EndMessage(LPXPL lpxpl, ULONG ulMsgRef, ULONG * lpulFlags) <br>{ <br>    LPDEFMSG lpDefMsg; <br> <br>    Assert(!IsBadWritePtr(lpulFlags, sizeof(ULONG))); <br> <br>    *lpulFlags = 0L; <br> <br>    /* If the ulMsgRef is non zero, look for it in the deferred <br>       list.  If found, return END_DONT_RESEND to the Spooler.  */ <br> <br>    if (ulMsgRef) <br>    { <br>        lpDefMsg = lpxpl-&gt;lpDeferredList; <br> <br>        while (lpDefMsg) <br>        { <br>            if (lpDefMsg-&gt;ulMsgRef == ulMsgRef) <br>            { <br>                *lpulFlags = END_DONT_RESEND; <br>                break; <br>            } <br>        } <br>    } <br> <br>    return hrSuccess; <br>} <br> <br> <br>/* <br> -  HrAddDeferred <br> - <br> *  Purpose: <br> *      Adds the EntryID and ulMsgRef of a message we are deferring <br> *      to our list of deferred message. <br> * <br> *  Parameters: <br> *      lpxpl           Transport session <br> *      lpMsg           The message we wish to defer <br> *      lpulMsgRef      Receives the reference we assign to this message <br> * <br> *  Returns: <br> *      hResult         Indicating Success/Failure <br> */ <br> <br>HRESULT <br>HrAddDeferred(LPXPL lpxpl, LPMESSAGE lpMsg, ULONG *lpulMsgRef) <br>{ <br>    HRESULT hResult; <br>    SCODE sc; <br>    LPDEFMSG lpDefMsg = NULL; <br>    ULONG cVals; <br>    LPSPropValue lpEIDProp = NULL; <br>    static SPropTagArray spta = {1, {PR_ENTRYID}}; <br> <br>    /* Allocate a new DefMsg node */ <br> <br>    sc = lpxpl-&gt;AllocateBuffer(sizeof(DEFMSG), (LPVOID *)&amp;lpDefMsg); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("Allocation failed in HrAddDeferred.\n"); <br>        goto ret; <br>    } <br> <br>    /* Get the EntryID of the message we are deferring */ <br> <br>    hResult = lpMsg-&gt;lpVtbl-&gt;GetProps(lpMsg, &amp;spta, 0, &amp;cVals, &amp;lpEIDProp); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("GetProps failed in HrAddDeferred.\n"); <br>        goto ret; <br>    } <br> <br>    Assert(cVals == 1); <br>    Assert(lpEIDProp); <br>    Assert(lpEIDProp-&gt;ulPropTag == PR_ENTRYID); <br> <br>    /* We'll make our own copy of the EntryID */ <br> <br>    sc = lpxpl-&gt;AllocateMore(lpEIDProp-&gt;Value.bin.cb, (LPVOID)lpDefMsg, <br>            (LPVOID *)&amp;(lpDefMsg-&gt;sbinEIDDef.lpb)); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("Allocation failed in HrAddDeferred.\n"); <br>        goto ret; <br>    } <br> <br>    /* Fill in this new node and add it to the list */ <br> <br>    lpDefMsg-&gt;sbinEIDDef.cb = lpEIDProp-&gt;Value.bin.cb; <br>    memcpy(lpDefMsg-&gt;sbinEIDDef.lpb, lpEIDProp-&gt;Value.bin.lpb, <br>            (UINT)lpDefMsg-&gt;sbinEIDDef.cb); <br> <br>    lpDefMsg-&gt;ulMsgRef = ++lpxpl-&gt;ulDeferredMsgRef; <br>    lpDefMsg-&gt;lpNext = lpxpl-&gt;lpDeferredList; <br>    lpxpl-&gt;lpDeferredList = lpDefMsg; <br> <br>    lpxpl-&gt;fResendDeferred = FALSE; <br> <br>    *lpulMsgRef = lpDefMsg-&gt;ulMsgRef; <br> <br>ret: <br>    if (HR_FAILED(hResult)) <br>        lpxpl-&gt;FreeBuffer(lpDefMsg); <br> <br>    lpxpl-&gt;FreeBuffer(lpEIDProp); <br> <br>    DebugTraceResult(HrAddDeferred, hResult); <br>    return hResult; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
