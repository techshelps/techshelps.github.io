<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPOPTION.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2150"></a>XPOPTION.C</h2>
<pre><code>/* <br> -  X P O P T I O N . C <br> - <br> *  Purpose: <br> *      Defines a wrapped implementation of an IMAPIProp interface <br> *      to be used by ScMsgOptionCallBack() and ScRecipOptionCallBack() <br> *      to wrap the IMAPIProp passed in.  This object is wrapped so we <br> *      can effect the behavior of the OpenProperty() call.  Specifically, <br> *      we wish to put up a Property Sheet when the user tries to open <br> *      the PR_DETAILS_TABLE property. <br> * <br> *      This file overloads the OpenProperty() method on the Wrapped <br> *      IMAPIProp in order to slam properties from a Display Table <br> *      into the underlying message object.  It also creates the <br> *      Display Table used by IMAPISession::MessageOptions(). <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "xppch.h" <br>#include "xpresrc.h" <br>#include "xpoption.h" <br>#include &lt;mapiutil.h&gt; <br> <br>/* Generic control structures */ <br> <br>DTBLPAGE dtblMsgOptPage = <br>{sizeof(DTBLPAGE), 0, 0, 0}; <br>DTBLPAGE dtblRecipOptPage = <br>{sizeof(DTBLPAGE), 0, 0, 0}; <br> <br>/* Display table control structures for the General property sheet. */ <br> <br>DTBLCHECKBOX chkPerMsgDefer = <br>{sizeof(DTBLCHECKBOX), fMapiUnicode, <br>    PR_SAMPLE_PER_MSG_DEFER}; <br>DTBLCHECKBOX chkPerRecipDefer = <br>{sizeof(DTBLCHECKBOX), fMapiUnicode, <br>    PR_SAMPLE_PER_RECIP_DEFER}; <br> <br>DTCTL rgdtctlMsgOpt[] = <br>{ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, &amp;dtblMsgOptPage}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, IDC_PER_MSG_DEFER, &amp;chkPerMsgDefer} <br>}; <br> <br>DTCTL rgdtctlRecipOpt[] = <br>{ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, &amp;dtblRecipOptPage}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, IDC_PER_RECIP_DEFER, &amp;chkPerRecipDefer} <br>}; <br> <br> <br>/* Display table pages */ <br> <br>DTPAGE rgdtpageMsgOpt[] = <br>{ <br>    { <br>        sizeof(rgdtctlMsgOpt) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(PerMsgOpt), <br>        "", <br>        rgdtctlMsgOpt <br>    } <br>}; <br> <br> <br>DTPAGE rgdtpageRecipOpt[] = <br>{ <br>    { <br>        sizeof(rgdtctlRecipOpt) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(PerRecipOpt), <br>        "", <br>        rgdtctlRecipOpt <br>    } <br>}; <br> <br> <br>/* <br> *  WMProp jump table is defined here... <br> */ <br> <br>WMPROP_Vtbl vtblOPT = <br>{ <br>    WMPROP_QueryInterface, <br>    WMPROP_AddRef, <br>    WMPROP_Release, <br>    WMPROP_GetLastError, <br>    WMPROP_SaveChanges, <br>    WMPROP_GetProps, <br>    WMPROP_GetPropList, <br>    WMPROP_OpenProperty, <br>    WMPROP_SetProps, <br>    WMPROP_DeleteProps, <br>    WMPROP_CopyTo, <br>    WMPROP_CopyProps, <br>    WMPROP_GetNamesFromIDs, <br>    WMPROP_GetIDsFromNames, <br>}; <br> <br> <br>/* <br> *  Private functions prototypes <br> */ <br> <br>SCODE ScNewWrappedMAPIProp( <br>    LPMAPIPROP lpMAPIProp, <br>    HINSTANCE hInst, <br>    LPMALLOC lpMalloc, <br>    ULONG ulType, <br>    ULONG cbOptionData, <br>    LPBYTE lpbOptionData, <br>    LPMAPISUP lpMAPISup, <br>    LPWMPROP * lppWMProp); <br> <br>OPTIONCALLBACK ScOptionDataCallBack; <br> <br> <br>/* <br> -  ScOptionDataCallBack <br> - <br> *  Purpose: <br> *      Gets called by MAPI to wrap the source IMessage in <br> *      preparation to Display Table calls. <br> * <br> *  Parameters: <br> *      hInst               - Instance of myself from LoadLibrary call <br> *      lpMalloc            - OLE 2.0 style allocator <br> *      ulFlags             - OPTION_TYPE_MESSAGE | OPTION_TYPE_RECIPIENT <br> *      cbOptionData        - Size of OptionData I sent at Register time <br> *      lpbOptionData       - OptionData I sent at Register time <br> *      lpMAPISup           - A support object for mem routines <br> *      lpDataSource        - Underlying IMessage object <br> *      lppWrappedSource    - Returned wrapped version of lpDataSource <br> *      lppszErrorMsg       - Context sensitive error msg for MAPI <br> *      lppszErrorComponent - Help filename if one exists <br> *      lpulErrorContext    - Context in Help File <br> * <br> *  Returns: <br> *      sc                  - Scode of failure if any <br> */ <br> <br>STDINITMETHODIMP_(SCODE) <br>ScOptionDataCallBack( <br>    HINSTANCE hInst, <br>    LPMALLOC lpMalloc, <br>    ULONG ulFlags, <br>    ULONG cbOptionData, <br>    LPBYTE lpbOptionData, <br>    LPMAPISUP lpMAPISup, <br>    LPMAPIPROP lpDataSource, <br>    LPMAPIPROP FAR * lppWrappedSource, <br>    LPMAPIERROR FAR * lppMapiError ) <br>{ <br>    SCODE sc; <br>    LPWMPROP lpWMProp = NULL; <br> <br>    /* Do Parameter Validation Now */ <br> <br>#ifdef _WIN32 <br>    if (!hInst) <br>#else <br>    if (hInst &lt; HINSTANCE_ERROR) <br>#endif <br>    { <br>        DebugTrace("ScOptionDataCallBack() - Invalid hInst"); <br>        return E_INVALIDARG; <br>    } <br> <br>    if (ulFlags &amp; (~(OPTION_TYPE_MESSAGE | OPTION_TYPE_RECIPIENT))) <br>    { <br>        DebugTrace("ScOptionDataCallBack() - Unknown ulFlags!"); <br>        return E_INVALIDARG; <br>    } <br> <br>    if (cbOptionData &amp;&amp; !lpbOptionData) <br>    { <br>        DebugTrace("ScOptionDataCallBack() - Invalid lpbOptionData"); <br>        return E_INVALIDARG; <br>    } <br> <br>    if (cbOptionData) <br>    { <br>        if (IsBadReadPtr(lpbOptionData, (UINT) cbOptionData)) <br>        { <br>            DebugTrace("ScOptionDataCallBack() - Invalid lpbOptionData"); <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    if (!lpMAPISup || IsBadReadPtr(lpMAPISup, sizeof(LPVOID))) <br>    { <br>        DebugTrace("ScOptionDataCallBack() - Invalid lpMAPISup"); <br>        return E_INVALIDARG; <br>    } <br> <br>    if (!lpDataSource || IsBadReadPtr(lpDataSource, sizeof(LPVOID))) <br>    { <br>        DebugTrace("ScOptionDataCallBack() - Invalid lpDataSource"); <br>        return E_INVALIDARG; <br>    } <br> <br>    if (!lppWrappedSource || IsBadWritePtr(lppWrappedSource, sizeof(LPVOID))) <br>    { <br>        DebugTrace("ScOptionDataCallBack() - Invalid lppWrappedSource"); <br>        return E_INVALIDARG; <br>    } <br> <br>    if (!lppMapiError || IsBadWritePtr(lppMapiError, sizeof(LPMAPIERROR))) <br>    { <br>        DebugTrace("ScOptionDataCallBack() - Invalid lppMapiError"); <br>        return E_INVALIDARG; <br>    } <br> <br>    *lppWrappedSource = NULL; <br>    *lppMapiError = NULL; <br> <br>    /* Everything is OK, Lets build the Wrapped Source now. */ <br> <br>    sc = ScNewWrappedMAPIProp(lpDataSource, hInst, lpMalloc, ulFlags,  <br>            cbOptionData, lpbOptionData, lpMAPISup, &amp;lpWMProp); <br> <br>    if (sc) <br>        goto ret; <br> <br>    *lppWrappedSource = (LPMAPIPROP) lpWMProp; <br> <br>ret: <br>    return sc; <br>} <br> <br> <br>/* <br> -  ScNewWrappedMAPIProp <br> - <br> *  Purpose: <br> *      Creates a wrapped Per-Message or Per-Recipient Options <br> *      property interface to pass back to caller.  All methods <br> *      call through to the base class except OpenProperty(), <br> *      which intercepts PR_DETAILS_TABLE and creates a Display <br> *      Table to pass back to the caller. <br> * <br> *  Parameters: <br> *      lpMAPIProp          - The Property Interface to wrapper (an IMsg) <br> *      lpXPLogon           - The opaque XP Logon object <br> *      hInst               - My hInst of this DLL <br> *      ulType              - Either OPTION_TYPE_MESSAGE or _RECIPIENT <br> *      cbOptionData        - Size of my OptionData blob <br> *      lpbOptionData       - My OptionData blob <br> *      lpMAPISup           - Needed for memory alloc routines <br> *      lppWMProp           - Returned wrapped IMAPIProp object <br> * <br> *  Returns: <br> *      sc                  - Indicating Success/Failure <br> */ <br> <br>SCODE <br>ScNewWrappedMAPIProp( <br>    LPMAPIPROP lpMAPIProp, <br>    HINSTANCE hInst, <br>    LPMALLOC lpMalloc, <br>    ULONG ulType, <br>    ULONG cbOptionData, <br>    LPBYTE lpbOptionData, <br>    LPMAPISUP lpMAPISup, <br>    LPWMPROP FAR * lppWMProp) <br>{ <br>    HRESULT hr; <br>    SCODE sc; <br>    LPWMPROP lpWMProp = NULL; <br>    LPBYTE lpb = NULL; <br>    LPALLOCATEBUFFER lpAllocBuff = NULL; <br>    LPALLOCATEMORE lpAllocMore = NULL; <br>    LPFREEBUFFER lpFreeBuff = NULL; <br> <br>    hr = lpMAPISup-&gt;lpVtbl-&gt;GetMemAllocRoutines(lpMAPISup, <br>        &amp;lpAllocBuff, &amp;lpAllocMore, &amp;lpFreeBuff); <br> <br>    if (hr) <br>    { <br>        sc = GetScode(hr); <br>        goto ret; <br>    } <br> <br>    sc = (*lpAllocBuff) (sizeof(WMPROP), &amp;lpWMProp); <br> <br>    if (sc) <br>    { <br>        goto ret; <br>    } <br> <br>    lpWMProp-&gt;lpVtbl = &amp;vtblOPT; <br>    lpWMProp-&gt;lcInit = 1; <br>    lpWMProp-&gt;lpAllocBuff = lpAllocBuff; <br>    lpWMProp-&gt;lpAllocMore = lpAllocMore; <br>    lpWMProp-&gt;lpFreeBuff = lpFreeBuff; <br>    lpWMProp-&gt;hInst = hInst; <br>    lpWMProp-&gt;lpMalloc = lpMalloc; <br>    lpWMProp-&gt;ulType = ulType; <br>    lpWMProp-&gt;lpMAPIProp = lpMAPIProp; <br> <br>    if (cbOptionData) <br>    { <br>        sc = (*lpAllocMore) (cbOptionData, lpWMProp, &amp;lpb); <br> <br>        if (sc) <br>        { <br>            goto ret; <br>        } <br> <br>        memcpy(lpb, lpbOptionData, (UINT) cbOptionData); <br> <br>        lpWMProp-&gt;cbOptionData = cbOptionData; <br>        lpWMProp-&gt;lpbOptionData = lpb; <br>    } <br> <br>    lpMalloc-&gt;lpVtbl-&gt;AddRef(lpMalloc); <br>    lpMAPIProp-&gt;lpVtbl-&gt;AddRef(lpMAPIProp); <br> <br>    *lppWMProp = lpWMProp; <br> <br>ret: <br>    if (sc &amp;&amp; lpFreeBuff) <br>        (*lpFreeBuff) (lpWMProp); <br> <br>    return sc; <br>} <br> <br> <br>/* <br> -  WMPROP_OpenProperty <br> - <br> *  Purpose: <br> *      Traps a request to OpenProperty() on PR_DETAILS_TABLE so I <br> *      can supply a DisplayTable for the user.  Else, passes the <br> *      request to the underlying object. <br> * <br> */ <br> <br>STDMETHODIMP <br>WMPROP_OpenProperty( <br>    LPWMPROP lpWMProp, <br>    ULONG ulPropTag, <br>    LPCIID lpiid, <br>    ULONG ulInterfaceOptions, <br>    ULONG ulFlags, <br>    LPUNKNOWN * lppUnk) <br>{ <br>    HRESULT hResult; <br> <br>    /* Check to see if it has a jump table */ <br> <br>    if (FBadUnknown(lpWMProp)) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTraceResult(WMPROP_OpenProperty, hResult); <br>        return hResult; <br>    } <br> <br>    /* Check to see that it's the correct jump table */ <br> <br>    if (lpWMProp-&gt;lpVtbl != &amp;vtblOPT) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTraceResult(WMPROP_OpenProperty, hResult); <br>        return hResult; <br>    } <br> <br>    if (IsBadWritePtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, OpenProperty))) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTraceResult(WMPROP_OpenProperty, hResult); <br>        return hResult; <br>    } <br> <br>    if ( ulInterfaceOptions &amp; ~MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br>        DebugTraceResult(WMPROP_OpenProperty, hResult); <br>        return hResult; <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>        DebugTraceResult(WMPROP_OpenProperty, hResult); <br>        return hResult; <br>    } <br>     <br>    /* PR_DETAILS_TABLE is the secret code for "DisplayTable" */ <br> <br>    if (ulPropTag == PR_DETAILS_TABLE) <br>    { <br>        /* Check to see if they're expecting a table interface */ <br> <br>        if (memcmp(lpiid, &amp;IID_IMAPITable, sizeof(IID))) <br>        { <br>            hResult = ResultFromScode(E_NOINTERFACE); <br>            goto ret; <br>        } <br> <br>        if (lpWMProp-&gt;ulType == OPTION_TYPE_MESSAGE) <br>        { <br>            hResult = BuildDisplayTable( <br>                lpWMProp-&gt;lpAllocBuff, <br>                lpWMProp-&gt;lpAllocMore, <br>                lpWMProp-&gt;lpFreeBuff, <br>                lpWMProp-&gt;lpMalloc, <br>                lpWMProp-&gt;hInst, <br>                sizeof(rgdtpageMsgOpt) / sizeof(DTPAGE), <br>                rgdtpageMsgOpt, <br>                0, <br>                (LPMAPITABLE FAR *) lppUnk, <br>                NULL); <br>        } <br>        else <br>        { <br>            Assert(lpWMProp-&gt;ulType == OPTION_TYPE_RECIPIENT); <br> <br>            hResult = BuildDisplayTable( <br>                lpWMProp-&gt;lpAllocBuff, <br>                lpWMProp-&gt;lpAllocMore, <br>                lpWMProp-&gt;lpFreeBuff, <br>                lpWMProp-&gt;lpMalloc, <br>                lpWMProp-&gt;hInst, <br>                sizeof(rgdtpageRecipOpt) / sizeof(DTPAGE), <br>                rgdtpageRecipOpt, <br>                0, <br>                (LPMAPITABLE FAR *) lppUnk, <br>                NULL); <br>        } <br>    } <br>    else <br>    { <br>        hResult = lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;OpenProperty( <br>            lpWMProp-&gt;lpMAPIProp, ulPropTag, lpiid, <br>            ulInterfaceOptions, ulFlags, lppUnk); <br>    } <br> <br>ret: <br>    DebugTraceResult(WMPROP_OpenProperty, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  WMPROP_QueryInterface <br> -  WMPROP_AddRef <br> -  WMPROP_Release <br> * <br> *  Purpose: <br> *      Wrapped version of the IUnknown methods. <br> */ <br> <br>STDMETHODIMP <br>WMPROP_QueryInterface( <br>    LPWMPROP lpWMProp, <br>    REFIID lpiid, <br>    LPVOID * lppNewObj) <br>{ <br>    /* Check to see if it has a jump table */ <br> <br>    if (FBadUnknown(lpWMProp)) <br>    { <br>        DebugTraceSc(WMPROP_QueryInterface, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /* Check to see if the method is the same */ <br> <br>    if (WMPROP_QueryInterface != lpWMProp-&gt;lpVtbl-&gt;QueryInterface) <br>    { <br>        DebugTraceSc(WMPROP_QueryInterface, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /*  Call the internal prop interface */ <br> <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;QueryInterface( <br>        lpWMProp-&gt;lpMAPIProp, lpiid, lppNewObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>WMPROP_AddRef(LPWMPROP lpWMProp) <br>{ <br>    /* Check to see if it has a jump table */ <br> <br>    if (FBadUnknown(lpWMProp)) <br>    { <br>        DebugTrace("Bad lpWMProp in WMPROP_AddRef\n"); <br>        return 1; <br>    } <br> <br>    /* Check to see if the method is the same */ <br> <br>    if (WMPROP_AddRef != lpWMProp-&gt;lpVtbl-&gt;AddRef) <br>    { <br>        DebugTrace("Bad lpWMProp in WMPROP_AddRef\n"); <br>        return 1; <br>    } <br> <br>    return ++lpWMProp-&gt;lcInit; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>WMPROP_Release(LPWMPROP lpWMProp) <br>{ <br>    ULONG cRef; <br> <br>    /* Check to see if it has a jump table */ <br> <br>    if (FBadUnknown(lpWMProp)) <br>    { <br>        DebugTrace("Bad lpWMProp in WMPROP_Release\n"); <br>        return 1; <br>    } <br> <br>    /* Check to see if the method is the same */ <br> <br>    if (WMPROP_Release != lpWMProp-&gt;lpVtbl-&gt;Release) <br>    { <br>        DebugTrace("Bad lpWMProp in WMPROP_Release\n"); <br>        return 1; <br>    } <br> <br>    cRef = --lpWMProp-&gt;lcInit; <br> <br>    if (lpWMProp-&gt;lcInit == 0) <br>    { <br>        /* Release the allocator that was handed to us */ <br>         <br>        lpWMProp-&gt;lpMalloc-&gt;lpVtbl-&gt;Release(lpWMProp-&gt;lpMalloc); <br>         <br>        /* Release the underlying IMAPIProp object */ <br>         <br>        lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;Release(lpWMProp-&gt;lpMAPIProp); <br> <br>        /* Need to free the object */ <br> <br>        (*lpWMProp-&gt;lpFreeBuff) (lpWMProp); <br>    } <br> <br>    return cRef; <br>} <br> <br> <br>/* <br> -  WMPROP_GetLastError <br> -  WMPROP_SaveChanges <br> -  WMPROP_GetProps <br> -  WMPROP_GetPropList <br> -  WMPROP_OpenProperty <br> -  WMPROP_SetProps <br> -  WMPROP_DeleteProps <br> -  WMPROP_CopyTo <br> -  WMPROP_CopyProps <br> -  WMPROP_GetNamesFromID <br> -  WMPROP_GetIDsFromName <br> * <br> *  Purpose: <br> *      Wrapped version of the IMAPIProp methods. <br> */ <br> <br>STDMETHODIMP <br>WMPROP_GetLastError( <br>    LPWMPROP lpWMProp, <br>    HRESULT hError, <br>    ULONG ulFlags, <br>    LPMAPIERROR FAR * lppMapiError ) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, GetLastError)) || <br>        WMPROP_GetLastError != lpWMProp-&gt;lpVtbl-&gt;GetLastError) <br>    { <br>        DebugTraceSc(WMPROP_GetLastError, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    if ( ulFlags &amp; ~MAPI_UNICODE ) <br>    { <br>        DebugTraceSc(WMPROP_GetLastError, MAPI_E_UNKNOWN_FLAGS); <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceSc(WMPROP_GetLastError, MAPI_E_BAD_CHARWIDTH); <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>     <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;GetLastError( <br>            lpWMProp-&gt;lpMAPIProp, hError, ulFlags, lppMapiError ); <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_SaveChanges( <br>    LPWMPROP lpWMProp, <br>    ULONG ulFlags) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, SaveChanges)) || <br>        WMPROP_SaveChanges != lpWMProp-&gt;lpVtbl-&gt;SaveChanges) <br>    { <br>        DebugTraceSc(WMPROP_SaveChanges,  E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /*  We don't want to really call SaveChanges() on the underlying object, <br>        as this would make an incomplete message still under composition <br>        actually appear in the folder where it was created. <br> <br>        If we had some computed properties here, we should do so (since some <br>        of them might have changed) and return any error encountered in <br>        doing so. But we don't. So all we need to do is return success. */ <br> <br>    return hrSuccess; <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_GetProps( <br>    LPWMPROP lpWMProp, <br>    LPSPropTagArray lpPropTagArray, <br>    ULONG ulFlags, <br>    ULONG * lpcValues, <br>    LPSPropValue * lppPropArray) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, GetProps)) || <br>        WMPROP_GetProps != lpWMProp-&gt;lpVtbl-&gt;GetProps) <br>    { <br>        DebugTraceSc(WMPROP_GetProps, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br>     <br>    if ( ulFlags &amp; ~(MAPI_UNICODE) ) <br>    { <br>        DebugTraceSc(WMPROP_GetProps, MAPI_E_UNKNOWN_FLAGS); <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>    } <br> <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceSc(WMPROP_GetProps, MAPI_E_BAD_CHARWIDTH); <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>     <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;GetProps( <br>        lpWMProp-&gt;lpMAPIProp, lpPropTagArray, ulFlags, <br>        lpcValues, lppPropArray); <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_GetPropList( <br>    LPWMPROP lpWMProp, <br>    ULONG ulFlags, <br>    LPSPropTagArray * lppPropTagArray) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, GetPropList)) || <br>        WMPROP_GetPropList != lpWMProp-&gt;lpVtbl-&gt;GetPropList) <br>    { <br>        DebugTraceSc(WMPROP_GetPropList, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    if ( ulFlags &amp; ~(MAPI_UNICODE) ) <br>    { <br>        DebugTraceSc(WMPROP_GetProps, MAPI_E_UNKNOWN_FLAGS); <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>    } <br> <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceSc(WMPROP_GetProps, MAPI_E_BAD_CHARWIDTH); <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>     <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;GetPropList( <br>        lpWMProp-&gt;lpMAPIProp, ulFlags, lppPropTagArray); <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_SetProps( <br>    LPWMPROP lpWMProp, <br>    ULONG cValues, <br>    LPSPropValue lpPropArray, <br>    LPSPropProblemArray * lppProblems) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, SetProps)) || <br>        WMPROP_SetProps != lpWMProp-&gt;lpVtbl-&gt;SetProps) <br>    { <br>        DebugTraceSc(WMPROP_SetProps, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;SetProps(lpWMProp-&gt;lpMAPIProp, <br>        cValues, lpPropArray, lppProblems); <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_DeleteProps( <br>    LPWMPROP lpWMProp, <br>    LPSPropTagArray lpPropTagArray, <br>    LPSPropProblemArray * lppProblems) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, DeleteProps)) || <br>        WMPROP_DeleteProps != lpWMProp-&gt;lpVtbl-&gt;DeleteProps) <br>    { <br>        DebugTraceSc(WMPROP_DeleteProps, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;DeleteProps(lpWMProp-&gt;lpMAPIProp, <br>        lpPropTagArray, lppProblems); <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_CopyTo( <br>    LPWMPROP lpWMProp, <br>    ULONG ciidExclude, <br>    LPCIID rgiidExclude, <br>    LPSPropTagArray lpExcludeProps, <br>    ULONG ulUIParam, <br>    LPMAPIPROGRESS lpProgress, <br>    LPCIID lpInterface, <br>    LPVOID lpDestObj, <br>    ULONG ulFlags, <br>    LPSPropProblemArray FAR * lppProblems) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, CopyTo)) || <br>        WMPROP_CopyTo != lpWMProp-&gt;lpVtbl-&gt;CopyTo) <br>    { <br>        DebugTraceSc(WMPROP_CopyTo, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;CopyTo(lpWMProp-&gt;lpMAPIProp, <br>        ciidExclude, rgiidExclude, lpExcludeProps, ulUIParam,  <br>        lpProgress, lpInterface, lpDestObj, ulFlags, lppProblems); <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_CopyProps( <br>    LPWMPROP lpWMProp, <br>    LPSPropTagArray lpIncludeProps, <br>    ULONG ulUIParam, <br>    LPMAPIPROGRESS lpProgress, <br>    LPCIID lpInterface, <br>    LPVOID lpDestObj, <br>    ULONG ulFlags, <br>    LPSPropProblemArray FAR * lppProblems) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, CopyProps)) || <br>        WMPROP_CopyProps != lpWMProp-&gt;lpVtbl-&gt;CopyProps) <br>    { <br>        DebugTraceSc(WMPROP_CopyProps, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;CopyProps(lpWMProp-&gt;lpMAPIProp, <br>        lpIncludeProps, ulUIParam, lpProgress, lpInterface, lpDestObj, <br>        ulFlags, lppProblems); <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_GetNamesFromIDs( <br>    LPWMPROP lpWMProp, <br>    LPSPropTagArray * lppPropTags, <br>    LPGUID lpPropSetGuid, <br>    ULONG ulFlags, <br>    ULONG * lpcPropNames, <br>    LPMAPINAMEID * *lpppPropNames) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, GetNamesFromIDs)) || <br>        WMPROP_GetNamesFromIDs != lpWMProp-&gt;lpVtbl-&gt;GetNamesFromIDs) <br>    { <br>        DebugTraceSc(WMPROP_GetNamesFromIDs, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;GetNamesFromIDs(lpWMProp-&gt;lpMAPIProp, <br>        lppPropTags, lpPropSetGuid, ulFlags, lpcPropNames, lpppPropNames); <br>} <br> <br> <br>STDMETHODIMP <br>WMPROP_GetIDsFromNames( <br>    LPWMPROP lpWMProp, <br>    ULONG cPropNames, <br>    LPMAPINAMEID * lppPropNames, <br>    ULONG ulFlags, <br>    LPSPropTagArray * lppPropTags) <br>{ <br>    /* Validate the object */ <br> <br>    if (FBadUnknown(lpWMProp) || <br>        IsBadWritePtr(lpWMProp, sizeof(WMPROP)) || <br>        IsBadReadPtr(lpWMProp-&gt;lpVtbl, offsetof(WMPROP_Vtbl, GetIDsFromNames)) || <br>        WMPROP_GetIDsFromNames != lpWMProp-&gt;lpVtbl-&gt;GetIDsFromNames) <br>    { <br>        DebugTraceSc(WMPROP_GetIDsFromNames, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    return lpWMProp-&gt;lpMAPIProp-&gt;lpVtbl-&gt;GetIDsFromNames(lpWMProp-&gt;lpMAPIProp, <br>        cPropNames, lppPropNames, ulFlags, lppPropTags); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
