<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPDIALOG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2145"></a>XPDIALOG.C</h2>
<pre><code>/* <br> -  X P D I A L O G . C <br> - <br> *  Purpose: <br> *      Logon UI code for use by the MAPI Sample Transport Provider. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "xppch.h" <br>#include "xpresrc.h" <br>#include &lt;stdlib.h&gt; <br>#include &lt;mapiutil.h&gt; <br> <br>#ifdef DEBUG_DLGITEMS <br>#ifndef DEBUG <br>#define DEBUG <br>#endif <br>#endif <br> <br>#define PropIndex(PROP)         (PROP_ID(PROP) - BASE_PROVIDER_ID - 1) <br> <br>/* Generic control structures */ <br> <br>DTBLLABEL dtbllabel = <br>{sizeof(DTBLLABEL), 0}; <br>DTBLPAGE dtblpage = <br>{sizeof(DTBLPAGE), 0, 0, 0}; <br>TCHAR szNoFilter[] = TEXT("*"); <br>TCHAR szDigitFilter[] = TEXT("[0-9]"); <br> <br>/* Display table control structures for the General property sheet. */ <br> <br>DTBLEDIT editWgapFname = <br>{sizeof(DTBLEDIT), fMapiUnicode, MAX_PATH, <br>    PR_SAMPLE_FILENAME}; <br>DTBLEDIT editWgapDir = <br>{sizeof(DTBLEDIT), fMapiUnicode, MAX_PATH, <br>    PR_SAMPLE_DIRECTORY}; <br>DTBLCHECKBOX chkLogEvents = <br>{sizeof(DTBLCHECKBOX), fMapiUnicode, <br>    PR_TEMP_LOG_EVENTS}; <br>DTBLCHECKBOX chkPeer = <br>{sizeof(DTBLCHECKBOX), fMapiUnicode, <br>    PR_TEMP_PEER_TO_PEER}; <br>DTBLCHECKBOX chkLogonUI = <br>{sizeof(DTBLCHECKBOX), fMapiUnicode, <br>    PR_TEMP_UI_ALWAYS}; <br>DTBLCHECKBOX chkSaveDialog = <br>{sizeof(DTBLCHECKBOX), fMapiUnicode, <br>    PR_TEMP_SAVE_DATA}; <br> <br>DTCTL rgdtctlGeneral[] = <br>{ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, &amp;dtblpage}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, IDC_LOG_EVENTS, &amp;chkLogEvents}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, IDC_PEER, &amp;chkPeer}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, IDC_LOGON_UI, &amp;chkLogonUI}, <br>    {DTCT_CHECKBOX, DT_EDITABLE, NULL, 0, NULL, IDC_SAVE_DIALOG, &amp;chkSaveDialog}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_WGAP_FNAME, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, IDE_WGAP_FNAME, &amp;editWgapFname}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_WGAP_DIR, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, IDE_WGAP_DIR, &amp;editWgapDir} <br>}; <br> <br>/* Display table control structures for the Peer to Peer property sheet. */ <br> <br>DTBLEDIT editDisplay = <br>{sizeof(DTBLEDIT), fMapiUnicode, MAX_TEXTFIELD, <br>    PR_SAMPLE_DISPLAY_NAME}; <br>DTBLEDIT editEmailType = <br>{sizeof(DTBLEDIT), fMapiUnicode, 32, <br>    PR_SAMPLE_EMAIL_ADDR_TYPE}; <br>DTBLEDIT editEmailAddress = <br>{sizeof(DTBLEDIT), fMapiUnicode, MAX_TEXTFIELD, <br>    PR_SAMPLE_EMAIL_ADDRESS}; <br>DTBLEDIT editInboundDir = <br>{sizeof(DTBLEDIT), fMapiUnicode, MAX_PATH, <br>    PR_SAMPLE_INBOUND_DIR}; <br>DTBLEDIT editOutboundDir = <br>{sizeof(DTBLEDIT), fMapiUnicode, MAX_PATH, <br>    PR_SAMPLE_OUTBOUND_DIR}; <br> <br>DTCTL rgdtctlPeer[] = <br>{ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, &amp;dtblpage}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_DISPLAY, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, IDE_DISPLAY, &amp;editDisplay}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_EMAIL_TYPE, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, IDE_EMAIL_TYPE, &amp;editEmailType}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_EMAIL_ADDR, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, IDE_EMAIL_ADDR, &amp;editEmailAddress}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_IN_DIR, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, IDE_IN_DIR, &amp;editInboundDir}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_OUT_DIR, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, IDE_OUT_DIR, &amp;editOutboundDir} <br>}; <br> <br>/* Display table control structures for the Logging property sheet. */ <br> <br>DTBLEDIT editLogFile = <br>{sizeof(DTBLEDIT), fMapiUnicode, MAX_PATH, <br>    PR_SAMPLE_LOGFILE}; <br>DTBLEDIT editLogHigh = <br>{sizeof(DTBLEDIT), fMapiUnicode, 11, <br>    PR_TEMP_LOGHIGHWATER}; <br>DTBLEDIT editLogLow = <br>{sizeof(DTBLEDIT), fMapiUnicode, 11, <br>    PR_TEMP_LOGLOWWATER}; <br>DTCTL rgdtctlLogging[] = <br>{ <br>    {DTCT_PAGE, 0, NULL, 0, NULL, 0, &amp;dtblpage}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_LOG_NAME, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szNoFilter, IDE_LOG_NAME, &amp;editLogFile}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_LOG_HIGH, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szDigitFilter, IDE_LOG_HIGH, &amp;editLogHigh}, <br>    {DTCT_LABEL, 0, NULL, 0, NULL, IDT_LOG_LOW, &amp;dtbllabel}, <br>    {DTCT_EDIT, DT_EDITABLE, NULL, 0, szDigitFilter, IDE_LOG_LOW, &amp;editLogLow} <br>}; <br> <br>/* Display table pages */ <br> <br>DTPAGE rgdtpage[] = <br>{ <br>    { <br>        sizeof(rgdtctlGeneral) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(GeneralPage), <br>        "", <br>        rgdtctlGeneral <br>    }, <br>    { <br>        sizeof(rgdtctlPeer) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(PeerPage), <br>        "", <br>        rgdtctlPeer <br>    }, <br>    { <br>        sizeof(rgdtctlLogging) / sizeof(DTCTL), <br>        (LPTSTR) MAKEINTRESOURCE(LoggingPage), <br>        "", <br>        rgdtctlLogging <br>    } <br>}; <br> <br>#ifdef DEBUG_DLGITEMS <br>static void <br> DLGDump(LPXPDLG lpXPDialog); <br>#endif <br> <br> <br>/* <br> -  ScDoLogonDlg <br> - <br> *  Purpose: <br> *      Called by the TransportLogon code to present logon UI to the user. <br> * <br> *  Parameters: <br> *      lpXPDialog          Structure through which we communicate <br> * <br> *  Returns: <br> *      0                   Dialog came up, pLogonStruct-&gt;lppPropArray <br> *                          contains a PropValueArray if OK, NULL if CANCEL <br> * <br> *      (Failure)           Some error occurred. lppPropArray will have <br> *                          either the original array or NULL. <br> * <br> *  Operation: <br> *      Gets the necessary information from Windows and activates the logon <br> *      dialog box. <br> */ <br> <br>SCODE <br>ScDoLogonDlg(LPXPDLG lpXPDialog) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hr; <br>    LPMAPITABLE ptable = NULL; <br>    LPPROPDATA pTempProps = NULL; <br>    ULONG flT = 0L; <br>    LPSPropValue rgprop; <br>    LPSPropValue pprop; <br>    LPSPropTagArray ptags; <br>    ULONG cprop; <br>    TCHAR szDialogTitle[128]; <br>    TCHAR szLogHigh[12]; <br>    TCHAR szLogLow[12]; <br>    UINT i; <br> <br>    /* Take ownership of the property value array, so calling code <br>       will not leak memory. */ <br> <br>    rgprop = *(lpXPDialog-&gt;lppPropArray); <br>    *(lpXPDialog-&gt;lppPropArray) = NULL; <br>    ptags = lpXPDialog-&gt;lpPTArray; <br> <br>    /* Retrieve the dialog title string */ <br> <br>    if (!LoadString(lpXPDialog-&gt;hInst, IDS_CONFIG_TITLE,  <br>        szDialogTitle, sizeof(szDialogTitle))) <br>    { <br>        sc = MAPI_E_NOT_ENOUGH_MEMORY; <br>        DebugTrace("LoadString failed in ScDoLogonDlg.\n"); <br>        goto ret; <br>    } <br> <br>    /* Create the configuration data interface. <br>       First, split the PR_SAMPLE_FLAGS property into four individual <br>       Boolean properties. */ <br> <br>    pprop = rgprop + (MAX_LOGON_PROPERTIES - TEMP_LOGON_PROPERTIES); <br> <br>    if (rgprop[PropIndex(PR_SAMPLE_FLAGS)].ulPropTag == PR_SAMPLE_FLAGS) <br>        flT = rgprop[PropIndex(PR_SAMPLE_FLAGS)].Value.ul; <br>    else <br>    { <br>        /*  The Peer to Peer and Save Data flags default to TRUE */ <br>        rgprop[PropIndex(PR_SAMPLE_FLAGS)].ulPropTag = PR_SAMPLE_FLAGS; <br>        flT = PR_SAMPLE_FLAG_PEER_TO_PEER | PR_SAMPLE_FLAG_SAVE_DATA; <br>        rgprop[PropIndex(PR_SAMPLE_FLAGS)].Value.ul = flT; <br>    } <br> <br>    pprop[0].ulPropTag = PR_TEMP_PEER_TO_PEER; <br>    pprop[0].Value.b = !!(flT &amp; PR_SAMPLE_FLAG_PEER_TO_PEER); <br>    pprop[1].ulPropTag = PR_TEMP_UI_ALWAYS; <br>    pprop[1].Value.b = !!(flT &amp; PR_SAMPLE_FLAG_UI_ALWAYS); <br>    pprop[2].ulPropTag = PR_TEMP_LOG_EVENTS; <br>    pprop[2].Value.b = !!(flT &amp; PR_SAMPLE_FLAG_LOG_EVENTS); <br>    pprop[3].ulPropTag = PR_TEMP_SAVE_DATA; <br>    pprop[3].Value.b = !!(flT &amp; PR_SAMPLE_FLAG_SAVE_DATA); <br> <br>    /* Next, make strings out of the two numeric logging parameters */ <br> <br>    if (rgprop[PropIndex(PR_SAMPLE_LOGHIGHWATER)].ulPropTag == PR_SAMPLE_LOGHIGHWATER) <br>        wsprintf(szLogHigh, "%ld", <br>            rgprop[PropIndex(PR_SAMPLE_LOGHIGHWATER)].Value.l); <br>    else <br>        szLogHigh[0] = '\0'; <br> <br>    pprop[4].ulPropTag = PR_TEMP_LOGHIGHWATER; <br>    pprop[4].Value.LPSZ = szLogHigh; <br> <br>    if (rgprop[PropIndex(PR_SAMPLE_LOGLOWWATER)].ulPropTag == PR_SAMPLE_LOGLOWWATER) <br>        wsprintf(szLogLow, "%ld", <br>            rgprop[PropIndex(PR_SAMPLE_LOGLOWWATER)].Value.l); <br>    else <br>        szLogLow[0] = '\0'; <br> <br>    pprop[5].ulPropTag = PR_TEMP_LOGLOWWATER; <br>    pprop[5].Value.LPSZ = szLogLow; <br> <br>    /* Now make a temporary property interface and feed it the data. */ <br> <br>    sc = CreateIProp((LPIID) &amp;IID_IMAPIPropData, <br>            lpXPDialog-&gt;AllocateBuffer, <br>            lpXPDialog-&gt;AllocateMore, <br>            lpXPDialog-&gt;FreeBuffer, <br>            lpXPDialog-&gt;lpMalloc, <br>            &amp;pTempProps); <br> <br>    if (FAILED(sc)) <br>    { <br>        DebugTrace("CreateIProp failed in ScDoLogonDlg.\n"); <br>        goto ret; <br>    } <br> <br>    hr = pTempProps-&gt;lpVtbl-&gt;SetProps(pTempProps, MAX_LOGON_PROPERTIES, rgprop, NULL); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        sc = GetScode(hr); <br>        DebugTrace("SetProps failed in ScDoLogonDlg.\n"); <br>        goto ret; <br>    } <br>     <br>    /* If the UI_READONLY flag is set, then we are being called from <br>       the SettingDialog() method in Read Only mode.  Disable all of <br>       the controls on the three property sheets, else Enable them.  */ <br> <br>    if (lpXPDialog-&gt;ulFlags &amp; UI_READONLY) <br>    { <br>        /* Disable controls on the General PropSheet */ <br>        rgdtpage[0].lpctl[1].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[0].lpctl[2].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[0].lpctl[3].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[0].lpctl[4].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[0].lpctl[6].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[0].lpctl[8].ulCtlFlags &amp;= ~DT_EDITABLE; <br> <br>        /* Disable controls on the Peer-To-Peer PropSheet */ <br>        rgdtpage[1].lpctl[2].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[1].lpctl[4].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[1].lpctl[6].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[1].lpctl[8].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[1].lpctl[10].ulCtlFlags &amp;= ~DT_EDITABLE; <br> <br>        /* Disable controls on the Logging PropSheet */ <br>        rgdtpage[2].lpctl[2].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[2].lpctl[4].ulCtlFlags &amp;= ~DT_EDITABLE; <br>        rgdtpage[2].lpctl[6].ulCtlFlags &amp;= ~DT_EDITABLE; <br>    } <br>    else <br>    { <br>        /* Enable controls on the General PropSheet */ <br>        rgdtpage[0].lpctl[1].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[0].lpctl[2].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[0].lpctl[3].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[0].lpctl[4].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[0].lpctl[6].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[0].lpctl[8].ulCtlFlags |= DT_EDITABLE; <br> <br>        /* Enable controls on the Peer-To-Peer PropSheet */ <br>        rgdtpage[1].lpctl[2].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[1].lpctl[4].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[1].lpctl[6].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[1].lpctl[8].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[1].lpctl[10].ulCtlFlags |= DT_EDITABLE; <br> <br>        /* Enable controls on the Logging PropSheet */ <br>        rgdtpage[2].lpctl[2].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[2].lpctl[4].ulCtlFlags |= DT_EDITABLE; <br>        rgdtpage[2].lpctl[6].ulCtlFlags |= DT_EDITABLE; <br>    } <br> <br>    /* Check if we are being called at Logon time or from a call to <br>       SettingsDialog().  If from SettingsDialog() then disable the <br>       IDE_EMAIL_TYPE edit control reguardless of ulFlags setting. */ <br> <br>    if (!lpXPDialog-&gt;fLogon) <br>        rgdtpage[1].lpctl[4].ulCtlFlags &amp;= ~DT_EDITABLE; <br> <br>    /* Create the display table for the logon dialog. It is based on dialog <br>       resources plus the static information at the head of this module. */ <br> <br>    hr = BuildDisplayTable( <br>        lpXPDialog-&gt;AllocateBuffer, <br>        lpXPDialog-&gt;AllocateMore, <br>        lpXPDialog-&gt;FreeBuffer, <br>        lpXPDialog-&gt;lpMalloc, <br>        lpXPDialog-&gt;hInst, <br>        sizeof(rgdtpage) / sizeof(DTPAGE), <br>        rgdtpage, <br>        0, <br>        &amp;ptable, <br>        NULL); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        sc = GetScode(hr); <br>        DebugTrace("BuildDisplayTable failed in ScDoLogonDlg.\n"); <br>        goto ret; <br>    } <br> <br>    /* Run the dialog */ <br> <br>    hr = lpXPDialog-&gt;lpMAPISup-&gt;lpVtbl-&gt;DoConfigPropsheet(lpXPDialog-&gt;lpMAPISup, <br>        (ULONG) lpXPDialog-&gt;hwnd, <br>        0, <br>        szDialogTitle, <br>        ptable, <br>        (LPMAPIPROP) pTempProps, <br>        1); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        sc = GetScode(hr); <br>        DebugTrace("DoConfigPropsheet failed in ScDoLogonDlg.\n"); <br>        goto ret; <br>    } <br> <br>    /* Retrieve the altered data */ <br> <br>    (*(lpXPDialog-&gt;FreeBuffer)) (rgprop); <br>    rgprop = NULL; <br> <br>    hr = pTempProps-&gt;lpVtbl-&gt;GetProps(pTempProps, ptags, 0, /* ansi */ <br>            &amp;cprop, &amp;rgprop); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        sc = GetScode(hr); <br>        DebugTrace("GetProps failed in ScDoLogonDlg.\n"); <br>        goto ret; <br>    } <br> <br>    Assert(cprop == MAX_LOGON_PROPERTIES); <br> <br>    /* Supply default values for any unfilled fields. <br>       Also ensure that the directory name fields end in a slash. */ <br> <br>    for (i = 0; i &lt; MAX_LOGON_PROPERTIES - TEMP_LOGON_PROPERTIES; ++i) <br>    { <br>        ULONG tagT = rgprop[i].ulPropTag; <br>        UINT cch; <br>        LPTSTR lpszT; <br> <br>        if (tagT != ptags-&gt;aulPropTag[i]) <br>        { <br>            /* This property did not make it. Integer properties default <br>               to 0, and string properties default to empty. */ <br> <br>            tagT = ptags-&gt;aulPropTag[i]; <br> <br>            if (PROP_TYPE(tagT) == PT_LONG) <br>            { <br>                rgprop[i].Value.l = 0; <br>                rgprop[i].ulPropTag = tagT; <br>            } <br>            else if (PROP_TYPE(tagT) == PT_TSTRING) <br>            { <br>                if (FAILED((*(lpXPDialog-&gt;AllocateMore)) (sizeof(TCHAR), <br>                            rgprop, (LPVOID FAR *) &amp;rgprop[i].Value.LPSZ))) <br>                { <br>                    rgprop[i].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(tagT)); <br>                    rgprop[i].Value.err = MAPI_E_NOT_ENOUGH_MEMORY; <br>                } <br>                else <br>                { <br>                    rgprop[i].Value.LPSZ[0] = '\0'; <br>                    rgprop[i].ulPropTag = tagT; <br>                } <br>            } <br>        } <br>        else if (tagT == PR_SAMPLE_INBOUND_DIR || <br>                tagT == PR_SAMPLE_OUTBOUND_DIR || <br>            tagT == PR_SAMPLE_DIRECTORY) <br>        { <br>            cch = lstrlen(rgprop[i].Value.LPSZ); <br> <br>            if (cch &amp;&amp; rgprop[i].Value.LPSZ[cch - 1] != '\\') <br>            { <br>                if (FAILED((*(lpXPDialog-&gt;AllocateMore)) ( <br>                            (cch + 2) * sizeof(TCHAR), rgprop, (LPVOID FAR *) &amp;lpszT))) <br>                { <br>                    rgprop[i].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(tagT)); <br>                    rgprop[i].Value.err = MAPI_E_NOT_ENOUGH_MEMORY; <br>                } <br>                else <br>                { <br>                    lstrcpy(lpszT, rgprop[i].Value.LPSZ); <br>                    lpszT[cch] = '\\'; <br>                    lpszT[cch + 1] = '\0'; <br>                    rgprop[i].Value.LPSZ = lpszT; <br>                } <br>            } <br>        } <br>    } <br> <br>    /* Reassemble the PR_SAMPLE_FLAGS property */ <br> <br>    pprop = rgprop + (MAX_LOGON_PROPERTIES - TEMP_LOGON_PROPERTIES); <br>    flT = 0L; <br> <br>    if (pprop[0].ulPropTag == PR_TEMP_PEER_TO_PEER &amp;&amp; pprop[0].Value.b) <br>        flT |= PR_SAMPLE_FLAG_PEER_TO_PEER; <br>    if (pprop[1].ulPropTag == PR_TEMP_UI_ALWAYS &amp;&amp; pprop[1].Value.b) <br>        flT |= PR_SAMPLE_FLAG_UI_ALWAYS; <br>    if (pprop[2].ulPropTag == PR_TEMP_LOG_EVENTS &amp;&amp; pprop[2].Value.b) <br>        flT |= PR_SAMPLE_FLAG_LOG_EVENTS; <br>    if (pprop[3].ulPropTag == PR_TEMP_SAVE_DATA &amp;&amp; pprop[3].Value.b) <br>        flT |= PR_SAMPLE_FLAG_SAVE_DATA; <br> <br>    rgprop[PropIndex(PR_SAMPLE_FLAGS)].ulPropTag = PR_SAMPLE_FLAGS; <br>    rgprop[PropIndex(PR_SAMPLE_FLAGS)].Value.ul = flT; <br> <br>    /* Reassemble the high and low water marks for logging */ <br> <br>    if (rgprop[PropIndex(PR_TEMP_LOGHIGHWATER)].ulPropTag == PR_TEMP_LOGHIGHWATER) <br>        rgprop[PropIndex(PR_SAMPLE_LOGHIGHWATER)].Value.l = <br>            atoi(rgprop[PropIndex(PR_TEMP_LOGHIGHWATER)].Value.LPSZ); <br> <br>    if (rgprop[PropIndex(PR_TEMP_LOGLOWWATER)].ulPropTag == PR_TEMP_LOGLOWWATER) <br>        rgprop[PropIndex(PR_SAMPLE_LOGLOWWATER)].Value.l = <br>            atoi(rgprop[PropIndex(PR_TEMP_LOGLOWWATER)].Value.LPSZ); <br> <br>    /* Return the new property array */ <br> <br>    *(lpXPDialog-&gt;lppPropArray) = rgprop; <br>    rgprop = NULL;              /* do not free this in cleanup code */ <br>    sc = S_OK;                  /* no warnings */ <br> <br>#ifdef DEBUG_DLGITEMS <br>    DLGDump(lpXPDialog);        /* dump debug data. */ <br>#endif <br> <br>ret: <br>    DebugTraceSc(ScDoLogonDialog(), sc); <br> <br>    UlRelease(ptable); <br>    UlRelease(pTempProps); <br> <br>    lpXPDialog-&gt;FreeBuffer(rgprop); <br> <br>    return sc; <br>} <br> <br> <br>#ifdef DEBUG_DLGITEMS <br> <br>/* <br> -  DLGDump <br> - <br> *  Purpose: <br> *      Called by ScDoLogonDlg to dump the contents <br> *      of the logon property array to the debugger. <br> * <br> *  Parameters: <br> *      lpXPDialog      Pointer to logon parameter structure <br> * <br> *  Returns: <br> *      none. <br> * <br> *  Operation: <br> *      Walks through the property array inside the logon structure, and <br> *      dumps its contents through DebugTrace(). <br> * <br> *      This function only exists in the debug version. <br> */ <br> <br>static void <br>DLGDump(LPXPDLG lpXPDialog) <br>{ <br> <br>    ULONG ulT, flT, ptT, ptT2; <br>    LPSPropValue lpPropArray; <br>    LPSPropTagArray lpPTArray; <br>    SPropValue propT; <br>    ULONG ulCount; <br> <br>    if (!lpXPDialog) <br>    { <br>        DebugTrace("lpXPDialog is NULL"); <br>        goto ret; <br>    } <br> <br>    DebugTrace("LogonStruct:"); <br> <br>    lpPropArray = *(lpXPDialog-&gt;lppPropArray); <br>    lpPTArray = lpXPDialog-&gt;lpPTArray; <br> <br>    if (!lpPropArray) <br>    { <br>        DebugTrace("NULL\n"); <br>        goto ret; <br>    } <br> <br>    ulCount = lpPTArray-&gt;cValues; <br> <br>    for (ulT = 0; ulT &lt; ulCount; ulT++) <br>    { <br>        propT = lpPropArray[ulT]; <br>        ptT = lpPTArray-&gt;aulPropTag[ulT]; <br>        ptT2 = propT.ulPropTag; <br> <br>        switch (ptT) <br>        { <br>        case PR_SAMPLE_DISPLAY_NAME: <br>            DebugTrace("  DisplayName: %s", (ptT == ptT2) ? propT.Value.LPSZ : "NULL"); <br>            break; <br> <br>        case PR_SAMPLE_EMAIL_ADDR_TYPE: <br>            DebugTrace("  EmailAddressType: %s", (ptT == ptT2) ? propT.Value.LPSZ : "NULL"); <br>            break; <br> <br>        case PR_SAMPLE_EMAIL_ADDRESS: <br>            DebugTrace("  EmailAddress: %s", (ptT == ptT2) ? propT.Value.LPSZ : "NULL"); <br>            break; <br> <br>        case PR_SAMPLE_INBOUND_DIR: <br>            DebugTrace("  Inbound Directory: %s", (ptT == ptT2) ? propT.Value.LPSZ : "NULL"); <br>            break; <br> <br>        case PR_SAMPLE_OUTBOUND_DIR: <br>            DebugTrace("  Outbound Directory: %s", (ptT == ptT2) ? propT.Value.LPSZ : "NULL"); <br>            break; <br> <br>        case PR_SAMPLE_FILENAME: <br>            DebugTrace("  WGApp Filename: %s", (ptT == ptT2) ? propT.Value.LPSZ : "NULL"); <br>            break; <br> <br>        case PR_SAMPLE_DIRECTORY: <br>            DebugTrace("  WGApp Directory: %s", (ptT == ptT2) ? propT.Value.LPSZ : "NULL"); <br>            break; <br> <br>        case PR_SAMPLE_FLAGS: <br> <br>            flT = (ptT == ptT2) ? propT.Value.ul : 0; <br> <br>            DebugTrace("  Peer-To-Peer: %s", (flT &amp; PR_SAMPLE_FLAG_PEER_TO_PEER) ? "TRUE" : "FALSE"); <br>            DebugTrace("  Always show UI: %s", (flT &amp; PR_SAMPLE_FLAG_UI_ALWAYS) ? "TRUE" : "FALSE"); <br>            DebugTrace("  Log Events: %s", (flT &amp; PR_SAMPLE_FLAG_LOG_EVENTS) ? "TRUE" : "FALSE"); <br>            DebugTrace("  Save Logon Input: %s", (flT &amp; PR_SAMPLE_FLAG_SAVE_DATA) ? "TRUE" : "FALSE"); <br>            break; <br> <br>        case PR_SAMPLE_LOGFILE: <br>            DebugTrace("  Log File Name: %s", (ptT == ptT2) ? propT.Value.LPSZ : "NULL"); <br>            break; <br> <br>        case PR_SAMPLE_LOGHIGHWATER: <br>            DebugTrace("  Log File HighWater: %ld", (ptT == ptT2) ? propT.Value.ul : 0); <br>            break; <br> <br>        case PR_SAMPLE_LOGLOWWATER: <br>            DebugTrace("  Log File LowWater: %ld", (ptT == ptT2) ? propT.Value.ul : 0); <br>            break; <br>             <br>        default: <br>            DebugTrace("  Unknown Logon Property: %08X", ptT); <br>            break; <br>        } <br>    } <br>ret: <br>    return; <br>} <br> <br>#endif                          /* DEBUG_DLGITEMS */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
