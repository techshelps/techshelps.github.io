<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPSTATUS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2161"></a>XPSTATUS.C</h2>
<pre><code>/* <br> -  X P S T A T U S . C <br> - <br> *  Purpose: <br> *      Sample transport provider status interface code.  This module <br> *      contains the following Transport SPI entry points: <br> * <br> *          OpenStatusEntry() <br> * <br> *      The Status Object methods implemented in this module are: <br> * <br> *          QueryInterface, <br> *          AddRef, <br> *          Release, <br> *          GetLastError, <br> *          GetProps, <br> *          GetPropList, <br> *          SettingsDialog, <br> *          FlushQueues, <br> * <br> *      Additional support functions found here: <br> * <br> *          HrBuildTransportStatus <br> *          HrUpdateTransportStatus <br> *          NewSOB <br> *          HrLoadStatusString <br> *          MapScodeSz <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>//$BUG  Invalid flags should return MAPI_E_UNKNOWN_FLAGS! <br> <br>#include "xppch.h" <br>#include "xpresrc.h" <br> <br> <br>#define MAX_STRING          8192 <br>#define MAX_RESRC_STRING    256 <br> <br>/* Declared in xpbase.c */ <br> <br>extern sptLogonArray; <br> <br>/*  SOB IMAPIProp jump table */ <br> <br>SOB_Vtbl vtblSOB = <br>{ <br>    SOB_QueryInterface, <br>    SOB_AddRef, <br>    SOB_Release, <br>    SOB_GetLastError, <br>    SOB_SaveChanges, <br>    SOB_GetProps, <br>    SOB_GetPropList, <br>    SOB_OpenProperty, <br>    SOB_SetProps, <br>    SOB_DeleteProps, <br>    SOB_CopyTo, <br>    SOB_CopyProps, <br>    SOB_GetNamesFromIDs, <br>    SOB_GetIDsFromNames, <br>    SOB_ValidateState, <br>    SOB_SettingsDialog, <br>    SOB_ChangePassword, <br>    SOB_FlushQueues, <br>}; <br> <br>/*  Static properties. In this case the array of Property Tags available <br>    from the Status object if opened.  The PR_RESOURCE_PATH must be last <br>    because we will not tell the client about this property if it isn't <br>    set in the Logon dialog.  Being last makes GetPropList() easier to do. */ <br> <br>/* Number of columns in Status row. */ <br> <br>#define NUM_STATUS_ROW_PROPS 10 <br> <br>const static SizedSPropTagArray(NUM_STATUS_ROW_PROPS, sptaStatusRow) = <br>{ <br>    NUM_STATUS_ROW_PROPS, <br>    { <br>        PR_RESOURCE_METHODS, <br>        PR_PROVIDER_DISPLAY, <br>        PR_DISPLAY_NAME, <br>        PR_IDENTITY_DISPLAY, <br>        PR_IDENTITY_ENTRYID, <br>        PR_IDENTITY_SEARCH_KEY, <br>        PR_STATUS_CODE, <br>        PR_STATUS_STRING, <br>        PR_OBJECT_TYPE, <br>        PR_RESOURCE_PATH <br>    } <br>}; <br> <br>/* List of IID's we support on open/query */ <br> <br>#define N_IID 3 <br>static const LPIID lpStatusFamilyIID[N_IID] = <br>{ <br>    (LPIID) &amp;IID_IUnknown,      /* IUnknown is everyone's parent */ <br>    (LPIID) &amp;IID_IMAPIProp,     /* IMAPIProp follows from this   */ <br>    (LPIID) &amp;IID_IMAPIStatus    /* My actual interface ID        */ <br>}; <br> <br>/* Local code */ <br> <br>static HRESULT NewSOB(LPCIID lpInterface, <br>    ULONG ulOpenFlags, <br>    LPXPL lpxpl, <br>    ULONG * lpulObjType, <br>    LPSOB * lppSOB); <br> <br>static HRESULT HrLoadStatusString(LPXPL lpxpl, <br>    LPVOID lpvParent, <br>    LPTSTR * lppsz); <br> <br> <br>/* <br> -  HrBuildTransportStatus <br> - <br> *  Purpose: <br> *      Called by TransportLogon to build the Status Table entry for the <br> *      Sample Transport Provider. <br> * <br> *  Parameters: <br> *      lpxpl               The current session structure. <br> *      ulFlags             0 or STATUSROW_UPDATE <br> * <br> *  Returns: <br> *      (HRESULT)           Errors encountered if any. <br> *      (Status Row)        Contains properties from session <br> * <br> *  Operation: <br> *      This one's relatively simple: build a property value array based on <br> *      data in the session structure, and call (*lpMAPISup)-&gt;ModifyStatusRow <br> *      to register the row in the table. <br> */ <br> <br>HRESULT <br>HrBuildTransportStatus(LPXPL lpxpl, ULONG ulFlags) <br>{ <br>    SCODE sc = 0; <br>    LPSPropValue lpPropArray = NULL; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    LPSPropValue pPropValT; <br>    LPVOID lpvT; <br>    LPVOID lpvT1; <br>    LPVOID lpvT2; <br>    LPTSTR lpszStatus = NULL; <br>    ULONG ulT; <br> <br>    /*  Allocate initial property array now. */ <br> <br>    sc = lpxpl-&gt;AllocateBuffer(sizeof(SPropValue) * (NUM_STATUS_ROW_PROPS - 1), (LPVOID *) &amp;lpPropArray); <br> <br>    if (sc) <br>    { <br>        DebugTraceSc(Status Row Allocation, sc); <br>        goto ret; <br>    } <br> <br>    /*  Store the properties into the status row */ <br> <br>    pPropValT = lpPropArray; <br> <br>    /*  1. Transport's Display Name. */ <br> <br>    pPropValT-&gt;ulPropTag = PR_PROVIDER_DISPLAY; <br>    pPropValT-&gt;Value.LPSZ = (LPTSTR) MYDISPLAYNAME; <br>    pPropValT++; <br> <br>    /*  2. Extra methods on status object */ <br> <br>    pPropValT-&gt;ulPropTag = PR_RESOURCE_METHODS; <br>    pPropValT-&gt;Value.ul = lpxpl-&gt;ulResourceMethods; <br>    pPropValT++; <br> <br>    /*  3. Display Name associated with session. Use email address. */ <br> <br>    lpvT1 = ArrayIndex (PR_SAMPLE_DISPLAY_NAME, lpxpl-&gt;lpPropArray).Value.LPSZ; <br>    lpvT2 = ArrayIndex (PR_SAMPLE_EMAIL_ADDRESS, lpxpl-&gt;lpPropArray).Value.LPSZ; <br>    ulT = (lstrlen((LPCTSTR) lpvT1)+lstrlen((LPCTSTR) lpvT2)+4)*sizeof (TCHAR); <br> <br>    sc = lpxpl-&gt;AllocateMore(ulT, (LPVOID) lpPropArray, &amp;lpvT); <br> <br>    if (sc) <br>    { <br>        DebugTraceSc(Session Display Name allocation, sc); <br>        goto ret; <br>    } <br>    wsprintf((LPTSTR) lpvT, TEXT("%s [%s]"), (LPTSTR) lpvT1, (LPTSTR) lpvT2); <br>    pPropValT-&gt;ulPropTag = PR_DISPLAY_NAME; <br>    pPropValT-&gt;Value.LPSZ = (LPTSTR) lpvT; <br>    pPropValT++; <br> <br>    /*  4. User's Display Name. */ <br> <br>    Assert(lpxpl-&gt;lpMyIDArray); <br>    *pPropValT = lpxpl-&gt;lpMyIDArray[1]; <br> <br>    Assert(pPropValT-&gt;ulPropTag == PR_SENDER_NAME); <br>    Assert(!IsBadStringPtr(pPropValT-&gt;Value.LPSZ, MAX_STRING)); <br> <br>    pPropValT-&gt;ulPropTag = PR_IDENTITY_DISPLAY; <br>    pPropValT++; <br> <br>    /*  5. User Entry-ID. */ <br> <br>    Assert(lpxpl-&gt;lpMyIDArray); <br>    *pPropValT = lpxpl-&gt;lpMyIDArray[0]; <br> <br>    Assert(pPropValT-&gt;ulPropTag == PR_SENDER_ENTRYID); <br>    Assert(pPropValT-&gt;Value.bin.cb); <br>    Assert(!IsBadReadPtr(pPropValT-&gt;Value.bin.lpb, (UINT) pPropValT-&gt;Value.bin.cb)); <br> <br>    pPropValT-&gt;ulPropTag = PR_IDENTITY_ENTRYID; <br>    pPropValT++; <br> <br>    /*  6. User Search Key. */ <br> <br>    Assert(lpxpl-&gt;lpMyIDArray); <br>    *pPropValT = lpxpl-&gt;lpMyIDArray[2]; <br> <br>    Assert(pPropValT-&gt;ulPropTag == PR_SENDER_SEARCH_KEY); <br>    Assert(pPropValT-&gt;Value.bin.cb); <br>    Assert(!IsBadReadPtr(pPropValT-&gt;Value.bin.lpb, (UINT) pPropValT-&gt;Value.bin.cb)); <br> <br>    pPropValT-&gt;ulPropTag = PR_IDENTITY_SEARCH_KEY; <br>    pPropValT++; <br> <br>    /*  7. Code. Online/Offline, Send/Receive, Uploading/Downloading. */ <br> <br>    pPropValT-&gt;ulPropTag = PR_STATUS_CODE; <br>    pPropValT-&gt;Value.ul = lpxpl-&gt;ulTransportStatus; <br>    pPropValT++; <br> <br>    /*  8. Status String based on Status Code. */ <br> <br>    if (HrLoadStatusString(lpxpl, lpPropArray, &amp;lpszStatus)) <br>    { <br>        pPropValT-&gt;ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_STATUS_STRING)); <br>        pPropValT-&gt;Value.err = MAPI_E_NOT_FOUND; <br>    } <br>    else <br>    { <br>        pPropValT-&gt;ulPropTag = PR_STATUS_STRING; <br>        pPropValT-&gt;Value.LPSZ = lpszStatus; <br>    } <br>    pPropValT++; <br> <br>    /*  9. Resource Path == WGAP Directory. */ <br> <br>    lpvT = (LPVOID) ArrayIndex(PR_SAMPLE_DIRECTORY, lpxpl-&gt;lpPropArray).Value.LPSZ; <br> <br>    if (lstrlen((LPCTSTR) lpvT)) <br>    { <br>        pPropValT-&gt;ulPropTag = PR_RESOURCE_PATH; <br>        pPropValT-&gt;Value.LPSZ = (LPTSTR) lpvT; <br>        pPropValT++; <br>    } <br> <br>    /*  Status Row is built. Register it. */ <br> <br>    sc = GetScode(lpMAPISup-&gt;lpVtbl-&gt;ModifyStatusRow(lpMAPISup, <br>            (pPropValT - lpPropArray), lpPropArray, ulFlags)); <br> <br>    if (FAILED(sc)) <br>        DebugTrace("ModifyStatusRow failed.\n"); <br> <br>ret: <br>    /*  Free the allocated memory */ <br> <br>    lpxpl-&gt;FreeBuffer(lpPropArray); <br> <br>    DebugTraceSc(HrBuildTransportStatus, sc); <br>    return ResultFromScode(sc); <br>} <br> <br> <br>/* <br> -  HrUpdateTransportStatus <br> - <br> *  Purpose: <br> *      Called by Transport code to update the PR_STATUS_CODE property in the <br> *      Status Table row for the Sample Transport Provider. <br> * <br> *  Parameters: <br> *      lpxpl               The current session structure. <br> *      ulFlags             Flags. Not currently used. <br> * <br> *  Returns: <br> *      (HRESULT)           Errors encountered if any. <br> *      (Status Row)        PR_STATUS_CODE and PR_STATUS_STRING updated <br> * <br> *  Operation: <br> *      Transport should already have updated lpxpl-&gt;ulTransportStatus <br> *      before calling here.  So all this routine does is construct a <br> *      notification structure for a status object modification and call <br> *      (*lpMAPISup)-&gt;ModifyStatusRow() to update the table.  If there is a <br> *      string available in the StringTable, then our cProps goes to 2 and <br> *      we assign the string to the 2nd element of rgProps. <br> */ <br> <br>HRESULT <br>HrUpdateTransportStatus(LPXPL lpxpl, ULONG ulFlags) <br>{ <br>    HRESULT hResult; <br>    ULONG cProps = 2; <br>    SPropValue rgProps[2]; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    LPTSTR lpszStatus = NULL; <br> <br>    /*  Store the new Transport Provider Status Code. */ <br> <br>    rgProps[0].ulPropTag = PR_STATUS_CODE; <br>    rgProps[0].Value.ul = lpxpl-&gt;ulTransportStatus; <br> <br>    /* Set the Status String according to ulStatus */ <br> <br>    if (HrLoadStatusString(lpxpl, NULL, &amp;lpszStatus)) <br>    { <br>        rgProps[1].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_STATUS_STRING)); <br>        rgProps[1].Value.err = MAPI_E_NOT_FOUND; <br>    } <br>    else <br>    { <br>        rgProps[1].ulPropTag = PR_STATUS_STRING; <br>        rgProps[1].Value.LPSZ = lpszStatus; <br>    } <br> <br>    /*  OK. Notify the Spooler. It will tell MAPI. */ <br> <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;ModifyStatusRow(lpMAPISup, <br>            cProps, rgProps, STATUSROW_UPDATE); <br> <br>    lpxpl-&gt;FreeBuffer(lpszStatus); <br>     <br>    DebugTraceResult(ModifyStatusRow, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  OpenStatusEntry <br> - <br> *  Purpose: <br> *      Called by Spooler to service client OpenEntry request. <br> * <br> *  Parameters: <br> *      lpiid               Interface identifier. <br> *      ulFlags             Open flags. The only doc'ed flag <br> *                          is MAPI_MODIFY, which we don't support. <br> *      lpulObjType         Pointer to a unsigned long into which <br> *                          we are to store the type of the <br> *                          object we've just opened. <br> *      lppEntry            Points to a variable into which we <br> *                          may store the object pointer. <br> * <br> *  Returns: <br> *      (HRESULT)           E_INVALIDARG if the session <br> *                          pointer isn't valid, or any other <br> *                          parameter not to our liking, <br> *                          or any other errors we encounter. <br> *      *lpulObjType        MAPI_STATUS if we open the entry, <br> *                          unchanged if not <br> *      *lppEntry           Pointer to object if we open the <br> *                          entry, unchanged if not <br> * <br> *  Operation: <br> *      Validate parameters. Call NewSOB() to create the object, returning <br> *      object type and object pointer into user-supplied locations. <br> */ <br> <br>STDMETHODIMP <br>XPL_OpenStatusEntry(LPXPL lpxpl, <br>    LPCIID lpiid, <br>    ULONG ulFlags, <br>    ULONG * lpulObjType, <br>    LPMAPISTATUS * lppEntry) <br>{ <br>    HRESULT hResult; <br>#ifndef MAC <br>    LPXPP lpxpp; <br>#endif <br> <br>    /* Need to do weak session validation to do this */ <br> <br>    if (IsBadWritePtr(lpxpl, sizeof(XPL)) || <br>        IsBadWritePtr((lpxpp = lpxpl-&gt;lpxppParent), sizeof(XPP)) || <br>        (lpiid != NULL &amp;&amp; IsBadReadPtr(lpiid, sizeof(IID))) || <br>        (IsBadWritePtr(lpulObjType, sizeof(ULONG))) || <br>        (IsBadWritePtr(lppEntry, sizeof(LPMAPISTATUS)))) <br>    { <br>        DebugTraceSc(OpenStatusEntry, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /* Get the Critical Section */ <br> <br>    EnterCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /*  Validate the user's parameters always */ <br> <br>    /*  Invalid parameter checking: 1) make sure the passed session <br>        is still valid; 2) lpiid should either be null or point <br>        to a piece of memory at least the size of a iid; 3) lpulObjType <br>        must point to a writable piece of memory the size of a ulong; <br>        4) lppEntry must point to enough writable memory to store a <br>        LPMAPISTATUS. */ <br> <br>    if (!FIsValidSession(lpxpl)) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTrace("Invalid Logon object.\n"); <br>        goto ret; <br>    } <br> <br>    /*  We don't support MAPI_MODIFY and no other flags are spec'ed. */ <br> <br>    if (ulFlags &amp; ~MAPI_MODIFY) <br>    { <br>        hResult = ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br>        DebugTrace("Unknown Flags.\n"); <br>        goto ret; <br>    } <br> <br>    if (ulFlags &amp; MAPI_MODIFY) <br>    { <br>        hResult = ResultFromScode(MAPI_E_NO_ACCESS); <br>        DebugTrace("XP Support Object doesn't support Modify access.\n"); <br>        goto ret; <br>    } <br> <br>    /*  The argument list looks good to us. Now, if we already have opened <br>        a status object on this logon context, we'll just use QueryInterface <br>        to get a new copy of the object... */ <br> <br>    if (lpxpl-&gt;lpXPStatus) <br>    { <br>        hResult = lpxpl-&gt;lpXPStatus-&gt;lpVtbl-&gt;QueryInterface(lpxpl-&gt;lpXPStatus, <br>                (lpiid ? lpiid : &amp;IID_IMAPIStatus), lppEntry); <br>                 <br>        if (HR_FAILED(hResult)) <br>            DebugTrace("QueryInterface failed.\n"); <br>        else <br>            *lpulObjType = MAPI_STATUS; <br>    } <br>    else <br>    { <br>        /*  Or if we don't already have an object, create it, saving a <br>            copy in the logon context. */ <br> <br>        hResult = NewSOB(lpiid, ulFlags, lpxpl,  <br>                lpulObjType, (LPSOB *) lppEntry); <br>                 <br>        if (HR_FAILED(hResult)) <br>            DebugTrace("NewSOB failed.\n"); <br>        else <br>            lpxpl-&gt;lpXPStatus = *lppEntry; <br>    } <br> <br>ret: <br>    /*  Release the critical section. */ <br> <br>    LeaveCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /*  Errors returned from this routine are always in sc. So if <br>        sc is zero we return 0. If it's nonzero we return a hResult <br>        built here from sc. */ <br> <br>    DebugTraceResult(OpenStatusEntry, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  NewSOB <br> - <br> *  Purpose: <br> *      Called from OpenStatusEntry to create a Status Object. <br> * <br> *  Parameters: <br> *      lpInterface         If non-null must be IID_IMAPIStatus <br> *      ulOpenFlags         Open flags. The only doc'ed flag <br> *                          is MAPI_MODIFY, which we don't support. <br> *      lpxpl               The handle of the session for which <br> *                          we want to open a Status object. In <br> *                          Spooler context, a pointer to the <br> *                          session data structure. <br> *      lpulObjType         Pointer to a unsigned long into which <br> *                          we are to store the type of the <br> *                          object we've just opened. <br> *      lppSOB              Points to a variable into which we <br> *                          may store the object pointer. <br> * <br> * Returns: <br> *      (HRESULT)           MAPI_E_NO_SUPPORT if an <br> *                          interface is specified, or any <br> *                          other errors we encounter. <br> *      *lpulObjType        MAPI_STATUS if we open the entry, <br> *                          unchanged if not <br> *      *lppEntry           Pointer to object if we open the <br> *                          entry, unchanged if not <br> * <br> *  Operation: <br> *      Allocates the memory for the object, initializes its data <br> *      members, plugs in the jump table and returns the appropriate <br> *      stuff to the caller. <br> */ <br> <br>static HRESULT <br>NewSOB(LPCIID lpInterface, <br>    ULONG ulOpenFlags, <br>    LPXPL lpxpl, <br>    ULONG * lpulObjType, <br>    LPSOB * lppSOB) <br>{ <br>    SCODE sc; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    LPSOB lpSOB = NULL; <br>    ULONG i; <br> <br>    *lpulObjType = 0; <br>    *lppSOB = NULL; <br> <br>    /*  Make sure no interface (or ours) was specified. */ <br> <br>    if (lpInterface) <br>    { <br>        for (i = 0; i &lt; N_IID; i++) <br>        { <br>            if (!memcmp(lpInterface, lpStatusFamilyIID[i], sizeof(IID))) <br>                break; <br>        } <br> <br>        if (i == N_IID) <br>        { <br>            DebugTraceSc(NewSOB, E_INVALIDARG); <br>            return ResultFromScode(E_INVALIDARG); <br>        } <br>    } <br> <br> <br>    /*  Allocate space for the SOB structure */ <br> <br>    sc = lpxpl-&gt;AllocateBuffer(sizeof(SOB), (LPVOID *) &amp;lpSOB); <br> <br>    if (sc) <br>    { <br>        DebugTrace("Allocation of Status Object failed.\n"); <br>        return ResultFromScode(sc); <br>    } <br> <br>    /*  Fill in the data members and the jump table. */ <br> <br>    lpSOB-&gt;lpVtbl = &amp;vtblSOB; <br>    lpSOB-&gt;lcInit = 1; <br>    lpSOB-&gt;lpsobMyAddress = lpSOB; <br> <br>    lpSOB-&gt;hrLastError = 0; <br>    lpSOB-&gt;ulOpenFlags = ulOpenFlags; <br>    lpSOB-&gt;AllocateBuffer = lpxpl-&gt;AllocateBuffer; <br>    lpSOB-&gt;AllocateMore = lpxpl-&gt;AllocateMore; <br>    lpSOB-&gt;FreeBuffer = lpxpl-&gt;FreeBuffer; <br>    lpSOB-&gt;lpMAPISup = lpMAPISup; <br>    lpSOB-&gt;lpxpl = lpxpl; <br> <br>    /*  Return the newly constructed object to the caller. */ <br> <br>    *lpulObjType = MAPI_STATUS; <br>    *lppSOB = lpSOB; <br> <br>    return 0; <br>} <br> <br> <br>/* <br> -  HrLoadStatusString <br> - <br> *  Purpose: <br> *      Retrieves a Status String from the resource StringTable <br> *      based on ulStatus code passed in. <br> * <br> *  Parameters: <br> *      lpxpl               The Transport Logon session <br> *      lpvParent           If non-null we chain the memory to this block <br> *      lppsz               Place to copy Status String to. <br> * <br> * Returns: <br> *      hr                  Indicating Success/Failure <br> * <br> */ <br> <br>static HRESULT <br>HrLoadStatusString(LPXPL lpxpl, LPVOID lpvParent, LPTSTR *lppsz) <br>{ <br>    SCODE sc = S_OK; <br>    UINT ids; <br>    ULONG cb; <br>    ULONG ulStatus = lpxpl-&gt;ulTransportStatus; <br>    TCHAR szStatus[MAX_RESRC_STRING]; <br> <br>    /* Determine the IDS of the status.  Since the status' are bit fields <br>       of ulStatus, we apply this hierarcy to determine the correct string. */ <br>     <br>    if (ulStatus &amp; STATUS_INBOUND_ACTIVE) <br>        ids = IDS_STATUS_UPLOADING; <br>    else if (ulStatus &amp; STATUS_OUTBOUND_ACTIVE) <br>        ids = IDS_STATUS_DOWNLOADING; <br>    else if (ulStatus &amp; STATUS_INBOUND_FLUSH) <br>        ids = IDS_STATUS_INFLUSHING; <br>    else if (ulStatus &amp; STATUS_OUTBOUND_FLUSH) <br>        ids = IDS_STATUS_OUTFLUSHING; <br>    else if ((ulStatus &amp; STATUS_AVAILABLE) &amp;&amp; <br>            ((ulStatus &amp; STATUS_INBOUND_ENABLED) || <br>            (ulStatus &amp; STATUS_OUTBOUND_ENABLED))) <br>        ids = IDS_STATUS_ONLINE; <br>    else if (ulStatus &amp; STATUS_AVAILABLE) <br>        ids = IDS_STATUS_AVAILABLE; <br>    else <br>        ids = IDS_STATUS_OFFLINE; <br> <br>    /* Attempt to load the resource into our automatic variable. */ <br>     <br>    cb = LoadString(lpxpl-&gt;lpxppParent-&gt;hInst, ids, szStatus, MAX_RESRC_STRING); <br>     <br>    if (!cb) <br>    { <br>        sc = MAPI_E_CALL_FAILED; <br>        DebugTrace("LoadString failed in HrLoadStatusString.\n"); <br>        goto ret; <br>    } <br> <br>    /* We'll get the exact size of the string and put it on the heap. <br>       The caller had the luxury of specifying a parent block to chain <br>       this allocation to. */ <br>     <br>    cb = (cb + 1) * sizeof(TCHAR); <br> <br>    if (lpvParent)   <br>        sc = lpxpl-&gt;AllocateMore(cb, lpvParent, (LPVOID *)lppsz); <br>    else     <br>        sc = lpxpl-&gt;AllocateBuffer(cb, (LPVOID *)lppsz); <br>     <br>    if (FAILED(sc)) <br>    { <br>        DebugTrace("Allocation failed in HrLoadStatusString.\n"); <br>        goto ret; <br>    } <br>     <br>    lstrcpy(*lppsz, szStatus); <br> <br>ret: <br>    DebugTraceSc(HrLoadStatusString, sc); <br>    return ResultFromScode(sc); <br>} <br> <br> <br>/* <br> -  IMAPISTATUS::QueryInterface <br> - <br> *  Purpose: <br> *      Standard IUnknown method. <br> * <br> *  Parameters: <br> *      lpObject            Pointer to object <br> *      lpiid               New interface to Query to <br> *      lppNewObj           Where to store pointer to new object <br> * <br> *  Returns: <br> *      (SCODE)             E_INVALIDARG if the input object <br> *                          doesn't look like a SOB, if the <br> *                          IID isn't readable or lppNewObj <br> *                          isn't writable; E_NOINTERFACE <br> *                          if we don't know the IID. <br> * <br> *  Operation: <br> *      Validate parameters. See if the caller wants IUnknown, IMAPIProp or <br> *      IStatus. If so, increment the usage count and return a new object. <br> */ <br> <br>STDMETHODIMP <br>SOB_QueryInterface(LPSOB lpSOB, <br>    REFIID lpiid, <br>    LPVOID * lppNewObj) <br>{ <br>    ULONG i; <br> <br>    /*  Validate the parameters: 1) Does it seem to be an object? <br>        2) is the refcount nonzero? 3) Is there enough there for <br>        an interface ID? 4) Is there enough there for a new object? */ <br> <br>    if ((IsBadWritePtr(lpSOB, sizeof(SOB))) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (IsBadReadPtr(lpiid, sizeof(IID))) || <br>        (IsBadWritePtr(lppNewObj, sizeof(LPSOB)))) <br>    { <br>        DebugTraceSc(SOB_QueryInterface, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /*  See if the requested interface is one of ours */ <br> <br>    for (i = 0; i &lt; N_IID; i++) <br>    { <br>        if (!memcmp(lpiid, lpStatusFamilyIID[i], sizeof(IID))) <br>            break; <br>    } <br> <br>    /*  If we didn't find the interface, get out now. */ <br> <br>    if (i == N_IID) <br>    { <br>        /* OLE requires zeroing [out] parameters */ <br>        *lppNewObj = NULL; <br>        DebugTraceSc(SOB_QueryInterface, E_NOINTERFACE); <br>        return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    ++lpSOB-&gt;lcInit; <br>    *lppNewObj = lpSOB; <br> <br>    return hrSuccess; <br> <br>} <br> <br> <br>/* <br> -  IMAPISTATUS::AddRef <br> - <br> *  Purpose: <br> *      Increment reference count if nonzero. <br> * <br> *  Parameters: <br> *      lpObject            Pointer to object (should be SOB) <br> * <br> *  Returns: <br> *      (ULONG)             Current reference count or zero if <br> *                          it doesn't seem to be SOB. <br> * <br> *  Operation: <br> *      Make sure it looks like a SOB, and if so, bump the reference count <br> *      and return the result to the caller. <br> */ <br> <br>STDMETHODIMP_(ULONG) <br>SOB_AddRef(LPSOB lpSOB) <br>{ <br>    /*  If it doesn't seem to be an object or refcount is zero, return zero */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        lpSOB-&gt;lcInit == 0 || <br>        lpSOB-&gt;lpsobMyAddress != lpSOB) <br>        return 0; <br> <br>    return ++lpSOB-&gt;lcInit; <br> <br>} <br> <br> <br>/* <br> -  IMAPISTATUS::Release <br> - <br> *  Purpose: <br> *      Decrement lcInit. If it's zero, release the object. <br> * <br> *  Parameters: <br> *      lpObject            Pointer to object (should be SOB) <br> * <br> *  Returns: <br> *      (ULONG)             Current reference count or zero if <br> *                          it doesn't seem to be SOB. <br> * <br> *  Operation: <br> *      Make sure it looks like a SOB, and if so, decrement the reference <br> *      count. If the count is now zero, deallocate the object. <br> *      Return the reference count to the caller. <br> */ <br> <br>STDMETHODIMP_(ULONG) <br>SOB_Release(LPSOB lpSOB) <br>{ <br>    /*  If it doesn't seem to be an object or refcount is zero, return zero */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        lpSOB-&gt;lcInit == 0 || <br>        lpSOB-&gt;lpsobMyAddress != lpSOB) <br>        return 0; <br> <br>    --lpSOB-&gt;lcInit; <br> <br>    if (lpSOB-&gt;lcInit == 0) <br>    { <br>        DebugTrace("SOB::Release() freeing SOB.\n"); <br> <br>        /* Unlink the status object from the logon object */ <br> <br>        if (FIsValidSession(lpSOB-&gt;lpxpl)) <br>            lpSOB-&gt;lpxpl-&gt;lpXPStatus = NULL; <br> <br>        lpSOB-&gt;lpVtbl = NULL; <br>        (*lpSOB-&gt;FreeBuffer) (lpSOB); <br>        return 0; <br>    } <br> <br>    return lpSOB-&gt;lcInit; <br>} <br> <br> <br>/* <br> -  IMAPISTATUS::GetLastError <br> - <br> *  Purpose: <br> *      Returns a string associated with the last HRESULT returned <br> *      by the SOB object. <br> * <br> *  Parameters: <br> *      lpObject            Pointer to object (should be SOB) <br> *      hError              HRESULT that caller is interested in <br> *      ulFlags             Ignored. <br> *      lppszMessage        Pointer to where message pointer should <br> *                          be copied. <br> * <br> *  Returns: <br> *      (HRESULT)           E_INVALIDARG if object doesn't look <br> *                          like a SOB or if any parameters look <br> *                          bad; other errors if any; 0 if successful. <br> *      *lppszMessage       Pointer to error message if any, else NULL <br> * <br> *  Operation: <br> *      Confirm the parameters. Compare the HRESULT to our last saved one. If <br> *      they match, copy the string into a new buffer and store the pointer <br> *      into the location provided by the caller. <br> */ <br> <br>STDMETHODIMP <br>SOB_GetLastError(LPSOB lpSOB, <br>    HRESULT hError, <br>    ULONG ulFlags, <br>    LPMAPIERROR * lppMapiError ) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    SCODE   sc; <br>    LPTSTR  pszMessage  = NULL; <br> <br>    /*  Validate the object and return pointer */ <br> <br>    *lppMapiError = NULL; <br>     <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (IsBadWritePtr(lppMapiError, sizeof(LPMAPIERROR)))) <br>    { <br>        DebugTraceSc(SOB_GetLastError, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    if ( ulFlags &amp; ~MAPI_UNICODE ) <br>    { <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>     <br>    /*  See if we have the message the caller wants. If so, <br>        make a copy and pass it back. */ <br> <br>    if ((hError != 0) &amp;&amp; (hError == lpSOB-&gt;hrLastError)) <br>    { <br>        sc = lpSOB-&gt;AllocateBuffer( sizeof( MAPIERROR ), lppMapiError ); <br>        if ( FAILED( sc ) ) <br>        { <br>            hResult = ResultFromScode( sc ); <br>            goto ret; <br>        } <br>         <br>        memset( *lppMapiError, 0, sizeof( MAPIERROR ) ); <br>         <br>        (*lppMapiError)-&gt;ulVersion = MAPI_ERROR_VERSION;     <br>     <br>        hResult = MapScodeSz(GetScode(hError), lpSOB-&gt;lpxpl, &amp;pszMessage); <br>        if ( HR_FAILED( hResult ) ) <br>            goto ret; <br>         <br>        sc = lpSOB-&gt;AllocateMore( Cbtszsize( pszMessage ), *lppMapiError,  <br>                &amp;(*lppMapiError)-&gt;lpszError ); <br>        if ( FAILED( sc ) )      <br>        { <br>            hResult = ResultFromScode( sc ); <br>            goto ret; <br>        } <br>         <br>        lstrcpy( (*lppMapiError)-&gt;lpszError, pszMessage ); <br>    } <br> <br>ret: <br>    if ( hResult ) <br>    { <br>        lpSOB-&gt;FreeBuffer( *lppMapiError ); <br>        *lppMapiError = NULL; <br>    } <br>         <br>    lpSOB-&gt;FreeBuffer( pszMessage ); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  IMAPISTATUS::GetProps <br> - <br> *  Purpose: <br> *      Returns the properties listed in the lpPropTagArray. <br> * <br> *  Parameters: <br> *      lpObject            Pointer to object (should be SOB) <br> *      lpPropTagArray      List of tags for which values are desired <br> *      ulFlags             UNICODE / String8 <br> *      lpcValues           Pointer: where to store count of values <br> *      lppPropArray        Pointer: where to store pointer to values <br> * <br> *  Returns: <br> *      (HRESULT)           E_INVALIDARG if object doesn't look like <br> *                          a SOB or if any of the parameters look <br> *                          bad; other errors if any; 0 if successful. <br> *      *lpcValues          Contains a property count if successful <br> *      *lppPropArray       Undefined if not successful; NULL if <br> *                          no properties; points to array of <br> *                          properties if any. <br> * <br> *  Operation: <br> *      Confirm the parameters. If lpPropTagArray is NULL, use our canned <br> *      property list. <br> *      Walk through the list, and give the caller any properties in the <br> *      list which we can provide. Return count in *lpcValues and pointer to <br> *      the array in *lppPropArray. <br> */ <br> <br>STDMETHODIMP <br>SOB_GetProps(LPSOB lpSOB, <br>    LPSPropTagArray lpPropTagArray, <br>    ULONG ulFlags, <br>    ULONG * lpcValues, <br>    LPSPropValue * lppPropArray) <br>{ <br>    SCODE sc = 0; <br>    HRESULT hResult = 0; <br>    ULONG ulT = 0; <br>    LPXPL lpxpl = NULL; <br>    HINSTANCE hInst; <br>    LPSPropValue lpPropArray = NULL; <br>    LPSPropValue lpMyIDArray = NULL; <br>    LPSPropTagArray lpspta = NULL; <br>    ULONG cb; <br>    LPTSTR lpsz; <br>    LPSPropValue lpPropT; <br>    BOOL fGotMemErrors = FALSE; <br>    BOOL fMyPTA = TRUE; <br>    BOOL fNoResourcePath = FALSE; <br> <br>    /*  Validate the object and the return pointers */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        lpSOB-&gt;lcInit == 0 || <br>        lpSOB-&gt;lpsobMyAddress != lpSOB) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        goto ret; <br>    } <br> <br>    /* Validate the Flags */ <br>     <br>    if ( ulFlags &amp; ~(MAPI_UNICODE) ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>        goto ret; <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        goto ret; <br>    } <br>     <br>    /*  Validate the return pointers */ <br> <br>    if ((IsBadWritePtr(lpcValues, sizeof(ULONG))) || <br>        (IsBadWritePtr(lppPropArray, sizeof(LPSPropValue)))) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        goto ret; <br>    } <br> <br>    /*  Validate the passed property tag array if any */ </code></pre>
<p>
</p>
<pre><code><br>    if (lpPropTagArray) <br>    { <br>        if ((IsBadReadPtr(lpPropTagArray, CbNewSPropTagArray(0))) || <br>            (lpPropTagArray-&gt;cValues == 0) || <br>            (IsBadReadPtr(&amp;lpPropTagArray-&gt;aulPropTag[0], <br>                    (UINT) (lpPropTagArray-&gt;cValues * sizeof(ULONG))))) <br>        { <br>            hResult = ResultFromScode(E_INVALIDARG); <br>            goto ret; <br>        } <br>        fMyPTA = FALSE; <br>        lpspta = lpPropTagArray; <br>    } <br>    else <br>    { <br>        /*  An array wasn't passed. Use ours. */ <br> <br>        lpspta = (LPSPropTagArray) &amp;sptaStatusRow; <br>    } <br> <br>    /*  Parameters have passed muster. Create the property array. */ <br> <br>    lpxpl = lpSOB-&gt;lpxpl; <br>    hInst = lpxpl-&gt;lpxppParent-&gt;hInst; <br> <br>    sc = ScCopySessionProps(lpxpl, &amp;lpPropArray, &amp;lpMyIDArray); <br> <br>    if (FAILED(sc)) <br>        goto ret; <br> <br>    sc = (*lpSOB-&gt;AllocateBuffer) (sizeof(SPropValue) * (lpspta-&gt;cValues), (LPVOID *) lppPropArray); <br>    if (sc) <br>    { <br>        hResult = ResultFromScode(sc); <br>        lpSOB-&gt;hrLastError = hResult; <br>        goto ret; <br>    } <br> <br>    /*  Count will always equal input number since we'll either get a <br>        property value or a PT_ERROR. */ <br> <br>    for (ulT = 0; ulT &lt; lpspta-&gt;cValues; ulT++) <br>    { <br>        switch (lpspta-&gt;aulPropTag[ulT]) <br>        { <br>        case PR_RESOURCE_METHODS: <br>            (*lppPropArray)[ulT].ulPropTag = PR_RESOURCE_METHODS; <br>            (*lppPropArray)[ulT].Value.ul = lpxpl-&gt;ulResourceMethods; <br>            break; <br> <br>        case PR_PROVIDER_DISPLAY: <br>            (*lppPropArray)[ulT].ulPropTag = PR_PROVIDER_DISPLAY; <br>            (*lppPropArray)[ulT].Value.LPSZ = (LPTSTR)MYDISPLAYNAME; <br>            break; <br> <br>        case PR_DISPLAY_NAME: <br>            lpsz = ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ; <br>            cb = sizeof(TCHAR) * (lstrlen(lpsz) + 1); <br> <br>            sc = lpSOB-&gt;AllocateMore(cb, (LPVOID) *lppPropArray, <br>                    (LPVOID *) &amp;((*lppPropArray)[ulT].Value.LPSZ)); <br>                 <br>            if (sc) <br>            { <br>                fGotMemErrors = TRUE; <br>                (*lppPropArray)[ulT].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(lpspta-&gt;aulPropTag[ulT])); <br>                (*lppPropArray)[ulT].Value.err = sc; <br>            } <br>            else <br>            { <br>                (*lppPropArray)[ulT].ulPropTag = PR_DISPLAY_NAME; <br>                lstrcpy((*lppPropArray)[ulT].Value.LPSZ, lpsz); <br>            } <br>            break; <br> <br>        case PR_IDENTITY_DISPLAY: <br>            lpPropT = &amp;(lpMyIDArray[1]); <br>            Assert(lpPropT); <br>            Assert(lpPropT-&gt;ulPropTag == PR_SENDER_NAME); <br> <br>            cb = sizeof(TCHAR) * (lstrlen(lpPropT-&gt;Value.LPSZ) + 1); <br> <br>            sc = lpSOB-&gt;AllocateMore(cb, (LPVOID) * lppPropArray, <br>                    (LPVOID *) &amp;((*lppPropArray)[ulT].Value.LPSZ)); <br> <br>            if (sc) <br>            { <br>                fGotMemErrors = TRUE; <br>                (*lppPropArray)[ulT].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(lpspta-&gt;aulPropTag[ulT])); <br>                (*lppPropArray)[ulT].Value.err = sc; <br>            } <br>            else <br>            { <br>                (*lppPropArray)[ulT].ulPropTag = PR_IDENTITY_DISPLAY; <br>                lstrcpy((*lppPropArray)[ulT].Value.LPSZ, lpPropT-&gt;Value.LPSZ); <br>            } <br>            break; <br> <br>        case PR_IDENTITY_ENTRYID: <br>            lpPropT = &amp;(lpMyIDArray[0]); <br>            Assert(lpPropT); <br>            Assert(lpPropT-&gt;ulPropTag == PR_SENDER_ENTRYID); <br> <br>            cb = lpPropT-&gt;Value.bin.cb; <br>            Assert(cb); <br>            Assert(!IsBadReadPtr(lpPropT-&gt;Value.bin.lpb, (UINT)cb)); <br> <br>            sc = lpSOB-&gt;AllocateMore(cb, (LPVOID) *lppPropArray, <br>                    (LPVOID *) &amp;((*lppPropArray)[ulT].Value.bin.lpb)); <br>                     <br>            if (sc) <br>            { <br>                fGotMemErrors = TRUE; <br>                (*lppPropArray)[ulT].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(lpspta-&gt;aulPropTag[ulT])); <br>                (*lppPropArray)[ulT].Value.err = sc; <br>            } <br>            else <br>            { <br>                (*lppPropArray)[ulT].ulPropTag = PR_IDENTITY_ENTRYID; <br>                (*lppPropArray)[ulT].Value.bin.cb = cb; <br>                if (cb) <br>                    memcpy((*lppPropArray)[ulT].Value.bin.lpb, <br>                            lpPropT-&gt;Value.bin.lpb, (UINT)cb); <br>            } <br>            break; <br> <br>        case PR_IDENTITY_SEARCH_KEY: <br>            lpPropT = &amp;(lpMyIDArray[2]); <br>            Assert(lpPropT); <br>            Assert(lpPropT-&gt;ulPropTag == PR_SENDER_SEARCH_KEY); <br> <br>            cb = lpPropT-&gt;Value.bin.cb; <br>            Assert(cb); <br>            Assert(!IsBadReadPtr(lpPropT-&gt;Value.bin.lpb, (UINT)cb)); <br> <br>            sc = lpSOB-&gt;AllocateMore(cb, (LPVOID) *lppPropArray, <br>                    (LPVOID *) &amp;((*lppPropArray)[ulT].Value.bin.lpb)); <br>                     <br>            if (sc) <br>            { <br>                fGotMemErrors = TRUE; <br>                (*lppPropArray)[ulT].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(lpspta-&gt;aulPropTag[ulT])); <br>                (*lppPropArray)[ulT].Value.err = sc; <br>            } <br>            else <br>            { <br>                (*lppPropArray)[ulT].ulPropTag = PR_IDENTITY_SEARCH_KEY; <br>                (*lppPropArray)[ulT].Value.bin.cb = cb; <br>                if (cb) <br>                    memcpy((*lppPropArray)[ulT].Value.bin.lpb, <br>                            lpPropT-&gt;Value.bin.lpb, (UINT)cb); <br>            } <br>            break; <br> <br>        case PR_STATUS_CODE: <br>            (*lppPropArray)[ulT].ulPropTag = PR_STATUS_CODE; <br>            (*lppPropArray)[ulT].Value.ul = lpxpl-&gt;ulTransportStatus; <br>            break; <br> <br>        case PR_STATUS_STRING: <br>            lpsz = NULL; <br> <br>            if (sc = GetScode(HrLoadStatusString(lpxpl, *lppPropArray, &amp;lpsz))) <br>            { <br>                fGotMemErrors = TRUE; <br>                (*lppPropArray)[ulT].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(lpspta-&gt;aulPropTag[ulT])); <br>                (*lppPropArray)[ulT].Value.err = sc; <br>            } <br>            else <br>            { <br>                (*lppPropArray)[ulT].ulPropTag = PR_STATUS_STRING; <br>                (*lppPropArray)[ulT].Value.LPSZ = lpsz; <br>            } <br>            break; <br> <br>        case PR_RESOURCE_PATH: <br>            lpsz = (LPVOID) ArrayIndex(PR_SAMPLE_DIRECTORY, lpPropArray).Value.LPSZ; <br>            Assert(lpsz); <br> <br>            cb = (lstrlen(lpsz) + 1) * sizeof(TCHAR); <br> <br>            if (cb == sizeof(TCHAR)) <br>            { <br>                if (fMyPTA) <br>                { <br>                    fNoResourcePath = TRUE; <br>                } <br>                else <br>                { <br>                    (*lppPropArray)[ulT].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_RESOURCE_PATH)); <br>                    (*lppPropArray)[ulT].Value.err = MAPI_E_NOT_FOUND; <br>                } <br>                break; <br>            } <br> <br>            sc = (*lpSOB-&gt;AllocateMore) (cb, (LPVOID) * lppPropArray, (LPVOID *) &amp;((*lppPropArray)[ulT].Value.LPSZ)); <br> <br>            if (sc) <br>            { <br>                fGotMemErrors = TRUE; <br>                (*lppPropArray)[ulT].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_RESOURCE_PATH)); <br>                (*lppPropArray)[ulT].Value.err = sc; <br>            } <br>            else <br>            { <br>                (*lppPropArray)[ulT].ulPropTag = PR_RESOURCE_PATH; <br>                lstrcpy((*lppPropArray)[ulT].Value.LPSZ, lpsz); <br>            } <br>            break; <br> <br>        case PR_OBJECT_TYPE: <br>            (*lppPropArray)[ulT].ulPropTag = PR_OBJECT_TYPE; <br>            (*lppPropArray)[ulT].Value.ul = MAPI_STATUS; <br>            break; <br> <br>        default: <br>            (*lppPropArray)[ulT].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(lpspta-&gt;aulPropTag[ulT])); <br>            (*lppPropArray)[ulT].Value.err = MAPI_E_NOT_FOUND; <br> <br>            hResult = ResultFromScode(MAPI_W_ERRORS_RETURNED); <br>            lpSOB-&gt;hrLastError = hResult; <br>            break; <br>        } <br>    } <br> <br>    /*  Store number of properties we're returning, i.e., the number <br>        asked for (with possible errors). */ <br> <br>    if (fMyPTA &amp;&amp; fNoResourcePath) <br>        *lpcValues = lpspta-&gt;cValues - 1; <br>    else     <br>        *lpcValues = lpspta-&gt;cValues; <br> <br>    if (fGotMemErrors) <br>    { <br>        hResult = ResultFromScode(MAPI_W_ERRORS_RETURNED); <br>        lpSOB-&gt;hrLastError = hResult; <br>    } <br> <br>ret: <br>    if(lpxpl) <br>    { <br>        lpxpl-&gt;FreeBuffer(lpPropArray); <br>        lpxpl-&gt;FreeBuffer(lpMyIDArray); <br>    } <br> <br>    DebugTraceResult(SOB_GetProps, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  IMAPISTATUS::GetPropList <br> - <br> *  Purpose: <br> * <br> *  Parameters: <br> *      lpObject            Pointer to object (should be SOB) <br> *      ulFlags             UNICODE / String8 <br> *      lppPropTagArray     Pointer: where to store pointer to tags <br> * <br> *  Returns: <br> *      (HRESULT)           E_INVALIDARG if object doesn't look like a <br> *                          SOB or if any of the parameters look bad; <br> *                          other errors if any; 0 if successful. <br> *      *lppPropArray       Undefined if not successful; points to <br> *                          array of property tags otherwise. <br> * <br> *  Operation: <br> *      Validate parameters; Create enough memory for out property tag list, <br> *      copy the list into it and do so. Return the new list into the caller's <br> *      pointer. <br> */ <br> <br>STDMETHODIMP <br>SOB_GetPropList(LPSOB lpSOB, <br>    ULONG ulFlags, <br>    LPSPropTagArray * lppPropTagArray) <br>{ <br>    SCODE sc; <br>    HRESULT hResult = 0; <br>    LPXPL lpxpl; <br>    ULONG ulArraySize; <br>    ULONG cActualProps; <br> <br>    /* Validate the Flags */ <br>     <br>    if ( ulFlags &amp; ~(MAPI_UNICODE) ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>        goto ret; <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        hResult = ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>        goto ret; <br>    } <br>     <br>    /*  Validate the object and the return pointers */ <br> <br>    if ((IsBadWritePtr(lpSOB, sizeof(SOB))) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (IsBadWritePtr(lppPropTagArray, sizeof(LPSPropTagArray)))) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        goto ret; <br>    } <br> <br>    lpxpl = lpSOB-&gt;lpxpl; <br> <br>    /* If WGAP Directory is empty, don't tell them about this property. */ <br>    cActualProps = sptaStatusRow.cValues; <br> <br>    if (lstrlen((LPTSTR) ArrayIndex(PR_SAMPLE_DIRECTORY, lpxpl-&gt;lpPropArray).Value.LPSZ)) <br>        ulArraySize = CbNewSPropTagArray(sptaStatusRow.cValues); <br>    else <br>    { <br>        /* Adjust for removing a prop tag */ <br>        cActualProps--; <br>        ulArraySize = CbNewSPropTagArray(sptaStatusRow.cValues - 1); <br>    } <br> <br>    /*  Allocate the required amount of memory */ <br> <br>    sc = (*lpSOB-&gt;AllocateBuffer) (ulArraySize, (LPVOID *) lppPropTagArray); <br> <br>    if (sc) <br>    { <br>        hResult = ResultFromScode(sc); <br>        lpSOB-&gt;hrLastError = hResult; <br>        goto ret; <br>    } <br> <br>    /*  Copy the contents of our canned property tag array into the buffer */ <br> <br>    if (ulArraySize) <br>    { <br>        memcpy(*lppPropTagArray, &amp;sptaStatusRow, (size_t) ulArraySize); <br>        (*lppPropTagArray)-&gt;cValues = cActualProps; <br>    } <br> <br>ret: <br>    DebugTraceResult(SOB_GetPropList, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  SOB_SettingsDialog <br> - <br> *  Purpose: <br> *      This routine will invoke the Transports Logon dialog to allow <br> *      the user to change the Logon properties.  The lpPropArray on the <br> *      current session will be updated. <br> * <br> *  Parameters: <br> *      lpSOB               The status object for this transport session <br> *      ulUIParam           The HWnd of the caller (may be null) <br> *      ulFlags             If UI_READONLY will not update the lpPropArray <br> * <br> *  Returns: <br> *      hResult             Indicating success/failure. <br> * <br> *  Operation: <br> * <br> */ <br> <br>STDMETHODIMP <br>SOB_SettingsDialog(LPSOB lpSOB, <br>    ULONG ulUIParam, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    SCODE sc = S_OK; <br>    LPSPropValue lpMyIDArray = NULL; <br>    LPVOID lpvT, lpvT2; <br>    ULONG ulCount = MAX_LOGON_PROPERTIES - TEMP_LOGON_PROPERTIES; <br>    ULONG ulT; <br>    LPXPL lpxpl = lpSOB-&gt;lpxpl; <br>    LPSPropValue lpPropArray = NULL; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    LPPROFSECT lpProfileObj = NULL; <br>    XPDLG XPDialog; <br>    BOOL fNeedUI = TRUE; <br>    BOOL fInCS = FALSE; <br> <br>    if ((IsBadReadPtr(lpSOB, sizeof(SOB))) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB)) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        goto ret; <br>    } <br> <br>    if (ulFlags &amp; ~UI_READONLY) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        goto ret; <br>    } <br> <br>    /* Get the Critical Section */ <br> <br>    EnterCriticalSection(&amp;(lpxpl-&gt;lpxppParent-&gt;csTransport)); <br> <br>    fInCS = TRUE; <br> <br>    sc = ScCopySessionProps(lpxpl, &amp;lpPropArray, NULL); <br> <br>    if (FAILED(sc)) <br>        goto ret; <br> <br>    /* Fill in the logon UI structure */ <br> <br>    XPDialog.hInst = lpxpl-&gt;lpxppParent-&gt;hInst; <br>    XPDialog.hwnd = (HWND) ulUIParam; <br>    XPDialog.lppPropArray = &amp;lpPropArray; <br>    XPDialog.lpPTArray = (LPSPropTagArray) &amp;sptLogonArray; <br>    XPDialog.AllocateBuffer = lpxpl-&gt;AllocateBuffer; <br>    XPDialog.AllocateMore = lpxpl-&gt;AllocateMore; <br>    XPDialog.FreeBuffer = lpxpl-&gt;FreeBuffer; <br>    XPDialog.lpMalloc = lpxpl-&gt;lpxppParent-&gt;lpMalloc; <br>    XPDialog.lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    XPDialog.fLogon = FALSE; <br>    XPDialog.ulFlags = ulFlags; <br> <br>    while (fNeedUI) <br>    { <br>        sc = ScDoLogonDlg(&amp;XPDialog); <br> <br>        if (FAILED(sc)) <br>        { <br>            DebugTraceSc(Logon UI activation, sc); <br>            goto ret; <br>        } <br> <br>        if (lpPropArray) <br>        { <br>            /* Got a prop array, make sure everything in it is good */ <br> <br>            for (ulT = 0; ulT &lt; ulCount; ulT++) <br>            { <br>                if (PROP_TYPE((lpPropArray)[ulT].ulPropTag) == PT_ERROR) <br>                { <br>                    DebugTrace("Property %x not available.\n", PROP_ID((lpPropArray)[ulT].ulPropTag)); <br>                    sc = MAPI_E_NO_ACCESS; <br>                } <br>            } <br>        } <br>        else <br>            sc = MAPI_E_NO_ACCESS; <br> <br>        if (sc) <br>        { <br>            DebugTraceSc(Logon UI returning, sc); <br>            goto ret; <br>        } <br> <br>        /* Do some simple validation of the Logon Props */ <br> <br>        sc = ScCheckLogonProps(&amp;XPDialog, TRUE); <br> <br>        if (sc == MAPI_E_USER_CANCEL) <br>            goto ret; <br>        else if (sc == MAPI_E_INVALID_PARAMETER) <br>            continue; <br>        else <br>            fNeedUI = FALSE; <br> <br>        /* If we get here, everything is fine and we can proceed. But first <br>           we should write the properties out if the user is willing. */ <br> <br>        ulT = ArrayIndex(PR_SAMPLE_FLAGS, lpPropArray).Value.ul; <br> <br>        if ((ulT &amp; PR_SAMPLE_FLAG_SAVE_DATA)) <br>        { <br>            /* Try to open our profile. */ <br> <br>            hResult = lpMAPISup-&gt;lpVtbl-&gt;OpenProfileSection(lpMAPISup, <br>                (LPMAPIUID) NULL, MAPI_MODIFY, &amp;lpProfileObj); <br> <br>            if (HR_FAILED(hResult)) <br>            { <br>              DebugTraceResult(MAPISUP: :OpenProfileSection, hResult); <br>                goto ret; <br>            } <br> <br>            hResult = lpProfileObj-&gt;lpVtbl-&gt;SetProps(lpProfileObj, <br>                ulCount, lpPropArray, NULL); <br> <br>            if (HR_FAILED(hResult)) <br>            { <br>              DebugTraceResult(PROFSECT: :SetProps, hResult); <br>                goto ret; <br>            } <br>        } <br>    } <br> <br>    /* Allocate initial property array for transport ID. */ <br> <br>    sc = (*lpxpl-&gt;AllocateBuffer) (sizeof(SPropValue) * NUM_SENDER_PROPS, <br>        (LPVOID *) &amp;lpMyIDArray); <br> <br>    if (sc) <br>    { <br>        DebugTraceSc(Sender ID property array allocation, sc); <br>        goto ret; <br>    } <br> <br>    memset(lpMyIDArray, 0, sizeof(SPropValue) * NUM_SENDER_PROPS); <br> <br>    /* Create the One-Off directly into the property value structure. */ <br> <br>    lpMyIDArray[0].ulPropTag = PR_SENDER_ENTRYID; <br> <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;CreateOneOff(lpMAPISup, <br>        ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpPropArray).Value.LPSZ, <br>        ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ, <br>        ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ, <br>        fMapiUnicode, <br>        &amp;lpMyIDArray[0].Value.bin.cb, <br>        (LPENTRYID *) &amp;lpMyIDArray[0].Value.bin.lpb); <br> <br>    if (hResult) <br>    { <br>      DebugTraceResult(MAPISUP: :CreateOneOff, hResult); <br>        lpMyIDArray[0].Value.bin.lpb = NULL; <br>        goto ret; <br>    } <br> <br>    /* Create the PR_SENDER_NAME property value. */ <br> <br>    lpvT2 = ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpPropArray).Value.LPSZ; <br>    ulT = lstrlen((LPCTSTR) lpvT2) + 1; <br> <br>    sc = (*lpxpl-&gt;AllocateMore) (ulT, (LPVOID) lpMyIDArray, <br>        (LPVOID *) &amp;lpvT); <br> <br>    if (sc) <br>    { <br>        DebugTraceSc(User Display Name allocation, sc); <br>        goto ret; <br>    } <br> <br>    lstrcpy((LPTSTR) lpvT, (LPCTSTR) lpvT2); <br> <br>    lpMyIDArray[1].ulPropTag = PR_SENDER_NAME; <br>    lpMyIDArray[1].Value.LPSZ = (LPTSTR) lpvT; <br> <br>    /* Create the PR_SENDER_SEARCH_KEY value. */ <br> <br>    lpMyIDArray[2].ulPropTag = PR_SENDER_SEARCH_KEY; <br> <br>    /* Size of property = type plus colon plus address plus null. */ <br> <br>    ulT = 2 + lstrlen(ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ) + <br>        lstrlen(ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ); <br> <br>    sc = (*lpxpl-&gt;AllocateMore) (ulT, (LPVOID) lpMyIDArray, <br>        (LPVOID *) &amp;lpvT); <br> <br>    if (sc) <br>    { <br>        DebugTraceSc(User Search Key allocation, sc); <br>        goto ret; <br>    } <br> <br>    /* PR_SENDER_SEARCH_KEY is "TYPE:ADDRESS" folded to uppercase. */ <br> <br>    wsprintf((LPTSTR) lpvT, TEXT("%s:%s"), <br>        (ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ), <br>        (ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ)); <br> <br>    CharUpperBuff((LPTSTR) lpvT, (UINT)-- ulT); <br> <br>    lpMyIDArray[2].Value.bin.cb = sizeof(TCHAR) * (1 + lstrlen((LPTSTR) lpvT)); <br>    lpMyIDArray[2].Value.bin.lpb = lpvT; <br> <br>    /* Replace the original PropArray with the new one. */ <br> <br>    lpxpl-&gt;FreeBuffer(lpxpl-&gt;lpPropArray); <br>    lpxpl-&gt;lpPropArray = lpPropArray; <br> <br>    /* Now, free the original User Display Name and Entry-ID */ <br> <br>    if (lpxpl-&gt;lpMyIDArray) <br>    { <br>        (*lpxpl-&gt;FreeBuffer) (lpxpl-&gt;lpMyIDArray[0].Value.bin.lpb); <br>        (*lpxpl-&gt;FreeBuffer) (lpxpl-&gt;lpMyIDArray); <br>    } <br> <br>    lpxpl-&gt;lpMyIDArray = lpMyIDArray; <br> <br>    hResult = HrBuildTransportStatus(lpxpl, STATUSROW_UPDATE); <br> <br>ret: <br>    /* Release the Critical Section. */ <br> <br>    if (fInCS) <br>        LeaveCriticalSection(&amp;(lpxpl-&gt;lpxppParent-&gt;csTransport)); <br> <br>    UlRelease(lpProfileObj); <br> <br>    if (lpPropArray &amp;&amp; (lpxpl-&gt;lpPropArray != lpPropArray)) <br>        lpxpl-&gt;FreeBuffer(lpPropArray); <br> <br>    if (lpMyIDArray &amp;&amp; (lpxpl-&gt;lpMyIDArray != lpMyIDArray)) <br>    { <br>        (*lpxpl-&gt;FreeBuffer) (lpMyIDArray[0].Value.bin.lpb); <br>        (*lpxpl-&gt;FreeBuffer) (lpMyIDArray); <br>    } <br> <br>    if (!hResult &amp;&amp; sc) <br>        hResult = ResultFromScode(sc); <br> <br>    DebugTraceResult(SOB_SettingsDialog, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  SOB_FlushQueues <br> - <br> *  Purpose: <br> *      Logon object method used by Spooler if FlushQueues is called on <br> *      the spooler status object. <br> * <br> *  Parameters: <br> *      lpSOB               This pointer for Status Object <br> *      ulUIParam           Window handle <br> *      cbTargetTransport   Count of bytes in Entryid. Zero. <br> *      lpTargetTransport   Entryid of transport. NULL. <br> *      ulFlags <br> * <br> *  Returns: <br> *      (HRESULT)           E_INVALIDARG if object doesn't <br> *                          look like a XPL; MAPI_E_NO_SUPPORT <br> *                          otherwise. <br> * <br> *  Operation: <br> *      Validate the object pointer. <br> */ <br> <br>STDMETHODIMP <br>SOB_FlushQueues(LPSOB lpSOB, <br>    ULONG ulUIParam, <br>    ULONG cbTargetTransport, <br>    LPENTRYID lpTargetTransport, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hResult; <br> <br>    if ((IsBadReadPtr(lpSOB, sizeof(SOB))) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB)) <br>    { <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    if (ulFlags &amp; FLUSH_UPLOAD) <br>        lpSOB-&gt;lpxpl-&gt;ulTransportStatus |= STATUS_OUTBOUND_FLUSH; <br>    if (ulFlags &amp; FLUSH_DOWNLOAD) <br>        lpSOB-&gt;lpxpl-&gt;ulTransportStatus |= STATUS_INBOUND_FLUSH; <br> <br>    hResult = HrUpdateTransportStatus(lpSOB-&gt;lpxpl, 0L); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  Unimplemented functions. Stubbed to give access or NYI. <br> - <br> */ <br> <br>STDMETHODIMP <br>SOB_SaveChanges(LPSOB lpSOB, <br>    ULONG ulFlags) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadReadPtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (ulFlags &amp; ~(KEEP_OPEN_READWRITE | KEEP_OPEN_READONLY | FORCE_SAVE))) <br>    { <br>        DebugTraceSc(SOB_SaveChanges, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br>     <br>    DebugTraceSc(SOB_SaveChanges, MAPI_E_NO_ACCESS); <br>    return (ResultFromScode(MAPI_E_NO_ACCESS)); <br>} <br> <br>STDMETHODIMP <br>SOB_OpenProperty(LPSOB lpSOB, <br>    ULONG ulPropTag, <br>    LPCIID lpiid, <br>    ULONG ulInterfaceOptions, <br>    ULONG ulFlags, <br>    LPUNKNOWN * lppUnk) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadReadPtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (!lpiid || IsBadReadPtr(lpiid, sizeof(IID))) || <br>        (ulFlags &amp; ~(MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS)) || <br>        (!lppUnk || IsBadWritePtr(lppUnk, sizeof(LPVOID)))) <br>    { <br>        DebugTraceSc(SOB_OpenProperty, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; ~(MAPI_UNICODE) ) <br>    { <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>    } <br>     <br>    if ( ulInterfaceOptions &amp; MAPI_UNICODE ) <br>    { <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br>    } <br>     <br>    DebugTraceSc(SOB_OpenProperty, MAPI_E_NO_SUPPORT); <br>    return (ResultFromScode(MAPI_E_NO_SUPPORT)); <br>} <br> <br>STDMETHODIMP <br>SOB_SetProps(LPSOB lpSOB, <br>    ULONG cValues, <br>    LPSPropValue lpPropArray, <br>    LPSPropProblemArray * lppProblems) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (cValues &amp;&amp; IsBadReadPtr(lpPropArray, (UINT)cValues*sizeof(SPropValue))) || <br>        (IsBadWritePtr(lppProblems, sizeof(LPSPropProblemArray)))) <br>    { <br>        DebugTraceSc(SOB_SetProps, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    DebugTraceSc(SOB_SetProps, MAPI_E_NO_ACCESS); <br>    return (ResultFromScode(MAPI_E_NO_ACCESS)); <br>} <br> <br>STDMETHODIMP <br>SOB_DeleteProps(LPSOB lpSOB, <br>    LPSPropTagArray lpPropTagArray, <br>    LPSPropProblemArray * lppProblems) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (!lpPropTagArray) || <br>        (IsBadReadPtr(lpPropTagArray, (UINT)lpPropTagArray-&gt;cValues*sizeof(ULONG))) || <br>        (IsBadWritePtr(lppProblems, sizeof(LPSPropProblemArray)))) <br>    { <br>        DebugTraceSc(SOB_DeleteProps, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    DebugTraceSc(SOB_DeleteProps, MAPI_E_NO_ACCESS); <br>    return (ResultFromScode(MAPI_E_NO_ACCESS)); <br>} <br> <br>STDMETHODIMP <br>SOB_CopyTo(LPSOB lpSOB, <br>    ULONG ciidExclude, <br>    LPCIID rgiidExclude, <br>    LPSPropTagArray lpExcludeProps, <br>    ULONG ulUIParam, <br>    LPMAPIPROGRESS lpProgress, <br>    LPCIID lpInterface, <br>    LPVOID lpDestObj, <br>    ULONG ulFlags, <br>    LPSPropProblemArray * lppProblems) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (ciidExclude &amp;&amp; (!rgiidExclude || IsBadReadPtr(rgiidExclude, (UINT)ciidExclude*sizeof(IID)))) || <br>        (lpExcludeProps &amp;&amp; IsBadReadPtr(lpExcludeProps, (UINT)lpExcludeProps-&gt;cValues*sizeof(ULONG))) || <br>        (lpProgress &amp;&amp; IsBadReadPtr(lpProgress, sizeof(LPMAPIPROGRESS))) || <br>        (!lpInterface || IsBadReadPtr(lpInterface, sizeof(IID))) || <br>        (IsBadReadPtr(lpDestObj, sizeof(LPVOID))) || <br>        (ulFlags &amp; ~(MAPI_MOVE | MAPI_NOREPLACE | MAPI_DIALOG | MAPI_DECLINE_OK)) || <br>        (IsBadWritePtr(lppProblems, sizeof(LPSPropProblemArray)))) <br>    { <br>        DebugTraceSc(SOB_CopyTo, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    DebugTraceSc(SOB_CopyTo, MAPI_E_NO_SUPPORT); <br>    return (ResultFromScode(MAPI_E_NO_SUPPORT)); <br>} <br> <br>STDMETHODIMP <br>SOB_CopyProps(LPSOB lpSOB, <br>    LPSPropTagArray lpIncludeProps, <br>    ULONG ulUIParam, <br>    LPMAPIPROGRESS lpProgress, <br>    LPCIID lpInterface, <br>    LPVOID lpDestObj, <br>    ULONG ulFlags, <br>    LPSPropProblemArray * lppProblems) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (lpIncludeProps &amp;&amp; IsBadReadPtr(lpIncludeProps, (UINT)lpIncludeProps-&gt;cValues*sizeof(ULONG))) || <br>        (lpProgress &amp;&amp; IsBadReadPtr(lpProgress, sizeof(LPMAPIPROGRESS))) || <br>        (!lpInterface || IsBadReadPtr(lpInterface, sizeof(IID))) || <br>        (IsBadReadPtr(lpDestObj, sizeof(LPVOID))) || <br>        (ulFlags &amp; ~(MAPI_MOVE | MAPI_NOREPLACE | MAPI_DIALOG | MAPI_DECLINE_OK)) || <br>        (IsBadWritePtr(lppProblems, sizeof(LPSPropProblemArray)))) <br>    { <br>        DebugTraceSc(SOB_CopyProps, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    DebugTraceSc(SOB_CopyProps, MAPI_E_NO_SUPPORT); <br>    return (ResultFromScode(MAPI_E_NO_SUPPORT)); <br>} <br> <br>STDMETHODIMP <br>SOB_GetNamesFromIDs(LPSOB lpSOB, <br>    LPSPropTagArray * lppPropTags, <br>    LPGUID lpPropSet, <br>    ULONG ulFlags, <br>    ULONG * lpcPropNames, <br>    LPMAPINAMEID * * lpppPropNames) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (IsBadReadPtr(lppPropTags, sizeof(LPSPropTagArray))) || <br>        (IsBadReadPtr(lpPropSet, sizeof(GUID))) || <br>        (IsBadWritePtr(lpcPropNames, sizeof(ULONG))) || <br>        (IsBadWritePtr(lpppPropNames, sizeof(LPVOID)))) <br>    { <br>        DebugTraceSc(SOB_GetNamesFromIDs, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    DebugTraceSc(SOB_GetNamesFromIDs, MAPI_E_NO_SUPPORT); <br>    return (ResultFromScode(MAPI_E_NO_SUPPORT)); <br>} <br> <br>STDMETHODIMP <br>SOB_GetIDsFromNames(LPSOB lpSOB, <br>    ULONG cPropNames, <br>    LPMAPINAMEID * lppPropNames, <br>    ULONG ulFlags, <br>    LPSPropTagArray * lppPropTags) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (!lppPropNames || IsBadReadPtr(lppPropNames, (UINT)cPropNames*sizeof(LPMAPINAMEID))) || <br>        (IsBadReadPtr(lppPropTags, sizeof(LPSPropTagArray)))) <br>    { <br>        DebugTraceSc(SOB_GetIDsFromNames, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    DebugTraceSc(SOB_GetIDsFromNames, MAPI_E_NO_SUPPORT); <br>    return (ResultFromScode(MAPI_E_NO_SUPPORT)); <br>} <br> <br>STDMETHODIMP <br>SOB_ChangePassword(LPSOB lpSOB, <br>    LPTSTR lpOldPass, <br>    LPTSTR lpNewPass, <br>    ULONG ulFlags) <br>{ <br>    /*  Do parameter validation */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (IsBadStringPtr(lpOldPass, MAX_STRING)) || <br>        (IsBadStringPtr(lpNewPass, MAX_STRING)) || <br>        (ulFlags &amp; ~MAPI_UNICODE)) <br>    { <br>        DebugTraceSc(SOB_ChangePassword, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br>     <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceSc(SOB_ChangePassword, MAPI_E_BAD_CHARWIDTH); <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ); <br>    } <br>               <br>    DebugTraceSc(SOB_ChangePassword, MAPI_E_NO_SUPPORT); <br>    return (ResultFromScode(MAPI_E_NO_SUPPORT)); <br>} <br> <br>STDMETHODIMP <br>SOB_ValidateState(LPSOB lpSOB, <br>    ULONG ulUIParam, <br>    ULONG ulFlags) <br>{ <br>    ULONG ulFlagMask =  REFRESH_XP_HEADER_CACHE | \ <br>                        PROCESS_XP_HEADER_CACHE | \ <br>                        FORCE_XP_CONNECT | \ <br>                        FORCE_XP_DISCONNECT | \ <br>                        SUPPRESS_UI; <br>                         <br>    /*  Do parameter validation */ <br> <br>    if (IsBadWritePtr(lpSOB, sizeof(SOB)) || <br>        (lpSOB-&gt;lcInit == 0) || <br>        (lpSOB-&gt;lpsobMyAddress != lpSOB) || <br>        (ulFlags &amp; (~(ulFlagMask)))) <br>    { <br>        DebugTraceSc(SOB_ValidateState, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    DebugTraceSc(SOB_ValidateState, MAPI_E_NO_SUPPORT); <br>    return (ResultFromScode(MAPI_E_NO_SUPPORT)); <br>} <br> <br> <br>/* The following array maps a string identifier (IDS) to status code  */ <br>/* (SCODE).  The order of SCODEs in the array has an external         */ <br>/* dependency:  the order of elements in the array is dictated by     */ </code></pre>
<p>
</p>
<pre><code>/* the IDS definitions in xpresrc.h.  This implicit association must  */ <br>/* be maintained for the strings associated with string identifiers   */ <br>/* to make sense.  Thus, if either this structure or the rc.h defines */ <br>/* changes, the other must change to match it.                        */ <br> <br>SCODE mpIdsScode[] = <br>{ <br>    SUCCESS_SUCCESS, <br>    MAPI_E_BUSY, <br>    MAPI_E_CALL_FAILED, <br>    MAPI_E_INVALID_PARAMETER, <br>    MAPI_E_NO_ACCESS, <br>    MAPI_E_NO_SUPPORT, <br>    MAPI_E_NOT_FOUND, <br>    MAPI_E_UNKNOWN_FLAGS, <br>    MAPI_E_VERSION, <br>    MAPI_E_NOT_ENOUGH_MEMORY, <br>    MAPI_W_ERRORS_RETURNED <br>}; <br> <br> <br>/* <br> *  MapScodeSz <br> * <br> *  Purpose: <br> *      Look up an SCODE in a mapping of IDS &lt;-&gt; SCODE to find its <br> *      associated informational string and return it (with memory <br> *      allocated by this function) to the caller. <br> * <br> *  Arguments: <br> *      sc          The SCODE to look up. <br> *      lpxpl       Pointer to the Transport Logon object <br> *      lppszError  Location in which to place an address to a <br> *                  newly allocated buffer containing the <br> *                  informational string associated with scArg. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Errors: <br> *      MAPI_E_NO_MEMORY    Could not allocate space for <br> *                          the return string. <br> */ <br> <br>HRESULT <br>MapScodeSz(SCODE scArg, LPXPL lpxpl, LPTSTR * lppszError) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc = SUCCESS_SUCCESS; <br>    ULONG cb; <br>    UINT ui; <br>    UINT ids; <br>    UINT uiMax = sizeof mpIdsScode / sizeof mpIdsScode[0]; <br>    TCHAR rgch[512]; <br> <br>    if (!lppszError || IsBadWritePtr(lppszError, sizeof(LPVOID))) <br>    { <br>        DebugTrace("Bad lppszError in MapScodeSz\n"); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br>     <br>    *lppszError = NULL; <br> <br>    /* Linear search in mpIdsScode for sc. */ <br> <br>    for (ui = 0; ui &lt; uiMax; ui++) <br>        if (mpIdsScode[ui] == scArg) <br>            break; <br> <br>    if (ui == uiMax) <br>        ids = IDS_UNKNOWN_ERROR; <br>    else <br>        ids = ui + LIB_ERRORS; <br> <br>    if (!LoadString(lpxpl-&gt;lpxppParent-&gt;hInst, ids, rgch, sizeof(rgch))) <br>    { <br>        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY); <br>        DebugTraceResult(LoadString failed in MapScodeSz, hr); <br>        goto ret; <br>    } <br> <br>    /* Allocate memory for return variable and set it */ <br> <br>    cb = (lstrlen(rgch) + 1) * sizeof(TCHAR); <br>    sc = lpxpl-&gt;AllocateBuffer(cb, (LPVOID *) lppszError); <br> <br>    if (sc != SUCCESS_SUCCESS) <br>    { <br>        hr = ResultFromScode(sc); <br>        DebugTraceResult(AllocateBuffer failed in MapScodeSz, hr); <br>        goto ret; <br>    } <br> <br>    lstrcpy(*lppszError, rgch); <br> <br>ret: <br>    DebugTraceResult(MapScodeSz, hr); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
