<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPQUEUE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2154"></a>XPQUEUE.C</h2>
<pre><code>/* <br> -  X P Q U E U E . C <br> - <br> *  Purpose: <br> *      Code to support the background queueing mechanism for the Sample <br> *      Transport Provider. <br> *      This module contains the following SPI entry points: <br> * <br> *          Idle() <br> * <br> *      Additional support functions found here: <br> * <br> *          HrBuildAdrList() <br> *          HrSendOneMessage() <br> *          HrIMsgToTextMsg() <br> *          HrPrepareRecipientTable() <br> *          HrCrackSenderEID() <br> *          FPropIndex() <br> *          FormatFileTime() <br> *          FreeMyAdrList() <br> *          ScLoadTnef() <br> * <br> *      Also present in this module is the transmit list management code and <br> *      all the recipient list manipulation logic. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "xppch.h" <br>#include &lt;tnef.h&gt; <br>#include "xpsof.h" <br>#include "xptxtmsg.h" <br>#include "xpresrc.h" <br> <br>BOOL FIsTextizedProp(ULONG ulPropTag); <br> <br>/* Generic BAD_VALUE for use in comparisons below */ <br> <br>#define BAD_VALUE (0xFFFFFFFF) <br> <br> <br>/* <br> -  lpxpl-&gt;lpVtbl-&gt;Idle <br> - <br> *  Purpose: <br> *      Called by the Spooler periodically in its idle loop. <br> * <br> *      The Transport will determine if there's any incoming mail for the <br> *      Spooler and will TransportNotify (NOTIFY_NEWMAIL) if so. <br> * <br> *  Parameters: <br> *      ulFlags             Flags. None are currently defined. <br> * <br> *  Returns: <br> *      (HRESULT)           Errors encountered if any. <br> * <br> *  Operation: <br> *      If inbound operation is currently enabled, call the Poll() entry point <br> *      to see if there's anything there. If we find something with Poll(), then <br> *      SpoolerNotify(NOTIFY_NEWMAIL). <br> */ <br> <br>STDMETHODIMP <br>XPL_Idle(LPXPL lpxpl, ULONG ulFlags) <br>{ <br>    HRESULT hResult = 0; <br>    LPDEFMSG lpDefMsg; <br> <br>    /* Incoming messages? */ <br> <br>    if (lpxpl-&gt;ulTransportStatus &amp; STATUS_INBOUND_ENABLED) <br>    { <br>        ULONG ulT = 0; <br> <br>        if ((hResult = XPL_Poll(lpxpl, &amp;ulT)) != 0) <br>            goto ret; <br>        if (ulT != 0) <br>        { <br>            /* SpoolerNotify() could theoretically return a nonzero <br>            HRESULT, but it's much easier and unambiguous to ignore <br>            that possibility and field Spooler errors elsewhere. */ <br> <br>            (void)lpxpl-&gt;lpMAPISup-&gt;lpVtbl-&gt;SpoolerNotify(lpxpl-&gt;lpMAPISup, NOTIFY_NEWMAIL, NULL); <br>        } <br>    } <br> <br>    if (lpxpl-&gt;fResendDeferred) <br>    { <br>        while (lpxpl-&gt;lpDeferredList) <br>        { <br>            lpDefMsg = lpxpl-&gt;lpDeferredList; <br>            lpxpl-&gt;lpDeferredList = lpDefMsg-&gt;lpNext; <br> <br>            lpxpl-&gt;lpMAPISup-&gt;lpVtbl-&gt;SpoolerNotify(lpxpl-&gt;lpMAPISup, <br>                NOTIFY_SENTDEFERRED, &amp;(lpDefMsg-&gt;sbinEIDDef)); <br> <br>            lpxpl-&gt;FreeBuffer(lpDefMsg); <br>        } <br> <br>        lpxpl-&gt;fResendDeferred = FALSE; <br>    } <br> <br>ret: <br> <br>    DebugTraceResult(XPL_Idle, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  HrBuildAdrList <br> - <br> *  Called by outbound and inbound logic. <br> * <br> *  Traverses a restricted recipient table and collates the rows into <br> *  a "done" adrlist structure and a "not done" adrlist structure. The <br> *  only distinction between done and not done is the result of a call <br> *  to an optional function to attempt to send the open message to <br> *  a particular recipient. <br> * <br> *  Obviously, if the callback isn't specified, the "done" adrlist will <br> *  contain all recipients that matched the restriction. <br> * <br> *  Parameters: <br> *      lpxpl               Session in which we're executing <br> *      lpMessage           Message containing the recipient table <br> *      lpTable             Recipient table <br> *      fSetResponsibility  TRUE/FALSE = Set/Clear PR_RESPONSIBILITY <br> *                          in good list (clear bad list always) <br> *      lpfnCallBack        Routine to call when trying to send <br> *      lppMyAdrListGood    Where to store the list of done recips <br> *      lppMyAdrListBad     Where to store the list of not done <br> * <br> *  Returns: <br> *      (HRESULT)           Errors encountered if any. <br> * <br> * <br> *  Operation: <br> *      This routine builds a pair of MYADRLISTS from the (restricted) <br> *      table which is passed to it. <br> * <br> *      Do a SetColumns so we know where to find PR_EMAIL_ADDRESS, PR_ROWID <br> *      and other necessary columns. Included in the SetColumns is <br> *      PR_REPORT_TEXT as a placeholder for NDR information. <br> * <br> *      Then, until we run out of data, <br> * <br> *      1) QueryRows on the input table <br> *      2) For each row: <br> *          a) If lpfnCallBack and PR_EMAIL_ADDRESS, invoke callback. <br> *          b) If callback wasn't defined or if successful, add row to <br> *             "good" list, else add to "bad" list with NDR reason <br> *      3) Free RowSet <br> * <br> *      The caller can tell if any recipients remain by whether the <br> *      "not done" set contains any elements. <br> * <br> *      The "not done" set will set PR_RESPONSIBILITY to FALSE if the caller <br> *      wants "done" recipients set, <br> */ <br> <br>HRESULT <br>HrBuildAdrList(LPXPL lpxpl, <br>    LPSPropValue lpPropArray, <br>    LPMESSAGE lpMessage, <br>    LPMAPITABLE lpTable, <br>    BOOL fSetResponsibility, <br>    LPMYCALLBACK lpfnCallBack, <br>    LPMYADRLIST FAR * lppMyAdrListGood, <br>    LPMYADRLIST FAR * lppMyAdrListBad) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    SCODE sc = S_OK; <br>    LPVOID lpvT; <br>    TCHAR rgchBuffer[512]; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br> <br>    LPSRowSet lpRow = NULL; <br>    LPMYADRLIST lpDone = NULL; <br>    LPMYADRLIST lpNotDone = NULL; <br>    LPSPropTagArray lpsptT = NULL; <br> <br>    LPMYADRLIST FAR *lppMyAdrList; <br>    LPSPropTagArray lpsptNew; <br>    LPSPropValue lpspvT; <br> <br>    ULONG ulT; <br>    ULONG ulNew; <br>    ULONG ulRow; <br> <br>    /*  These are the columns I need to have in the recipient table, <br>        even if all I get is a placeholder. If you need to add any, <br>        bump the definition of NUM_REQUIRED_COLS, add new defines <br>        for the new columns, and add the new column proptags to the <br>        switch below. If the property isn't necessarily going to be <br>        in the table, use the PR_NULL trick you see below for the <br>        PR_REPORT_TEXT property. */ <br> <br>    enum enumColumns <br>    { <br>        COLUMN_PR_ROWID, <br>        COLUMN_PR_EMAIL_ADDRESS, <br>        COLUMN_PR_RESPONSIBILITY, <br>        COLUMN_PR_REPORT_TEXT, <br>        COLUMN_PR_RECIPIENT_TYPE, <br>        NUM_REQUIRED_COLS <br>    }; <br> <br>    Assert(lppMyAdrListGood); <br>    Assert(lppMyAdrListBad); <br> <br>    /* <br>        Arrange the columns so that we'll have the recipient properties <br>        we really want. <br> <br>        So as not to lose any recipient properties, we need to do it in <br>        this fashion: <br> <br>        1)  QueryColumns() on the input table <br>        2)  Build a new column set based on the properties we care <br>            about plus all other properties of the input table <br>        3)  SetColumns() on the input table <br> <br>        The properties we care about are the following: <br> <br>        1)  PR_ROWID <br>        2)  PR_EMAIL_ADDRESS <br>        3)  PR_RESPONSIBILITY */ <br> <br>    /*  Get the complete column set */ <br> <br>    hResult = lpTable-&gt;lpVtbl-&gt;QueryColumns(lpTable, TBL_ALL_COLUMNS, &amp;lpsptT); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("QueryColumns failed.\n"); <br>        goto ret; <br>    } <br> <br>    /*  Gotta have a PR_ROWID. That guarantees at least one column! */ <br> <br>    Assert(lpsptT-&gt;cValues &gt;= 1); <br> <br>    /*  Allocate a new column set, linked to the old one for cleanup */ <br> <br>    ulT = CbNewSPropTagArray(NUM_REQUIRED_COLS + lpsptT-&gt;cValues); <br>    sc = (*lpxpl-&gt;AllocateMore) (ulT, (LPVOID) lpsptT, (LPVOID) &amp;lpsptNew); <br> <br>    if (sc) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("New column set allocation failed.\n"); <br>        goto ret; <br>    } <br> <br>    /*  Fill in the new column set, required fields first in our order. */ <br> <br>    lpsptNew-&gt;aulPropTag[COLUMN_PR_ROWID] = PR_ROWID; <br>    lpsptNew-&gt;aulPropTag[COLUMN_PR_EMAIL_ADDRESS] = PR_EMAIL_ADDRESS; <br>    lpsptNew-&gt;aulPropTag[COLUMN_PR_RESPONSIBILITY] = PR_RESPONSIBILITY; <br>    lpsptNew-&gt;aulPropTag[COLUMN_PR_REPORT_TEXT] = PR_NULL; <br>    lpsptNew-&gt;aulPropTag[COLUMN_PR_RECIPIENT_TYPE] = PR_RECIPIENT_TYPE; <br>    ulNew = NUM_REQUIRED_COLS; <br> <br>    for (ulT = 0; ulT &lt; lpsptT-&gt;cValues; ulT++) <br>    { <br>        switch (lpsptT-&gt;aulPropTag[ulT]) <br>        { <br>        case PR_REPORT_TEXT: <br>            lpsptNew-&gt;aulPropTag[COLUMN_PR_REPORT_TEXT] = PR_REPORT_TEXT; <br>            break; <br> <br>        case PR_ROWID: <br>        case PR_EMAIL_ADDRESS: <br>        case PR_RESPONSIBILITY: <br>        case PR_RECIPIENT_TYPE: <br>            break; <br> <br>        default: <br>            lpsptNew-&gt;aulPropTag[ulNew++] = lpsptT-&gt;aulPropTag[ulT]; <br>            break; <br>        } <br>    } <br> <br>    lpsptNew-&gt;cValues = ulNew; <br> <br>    /*  Set the new columns */ <br> <br>    hResult = lpTable-&gt;lpVtbl-&gt;SetColumns(lpTable, lpsptNew, 0L); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("SetColumns failed.\n"); <br>        goto ret; <br>    } <br> <br>    /*  Free both old and new PropTagArrays. */ <br> <br>    (*lpxpl-&gt;FreeBuffer) ((LPVOID) lpsptT); <br>    lpsptT = NULL; <br> <br>    /*  Build two big ADRLISTs from this table. Do minimal allocations so <br>        that all the reallocation code will be properly exercised. We can <br>        optimize later when we've tested. <br> <br>        The obvious underlying assumption of this code is that it's <br>        possible to get the entire recipient list into memory at once. */ <br> <br>#ifdef DEBUG <br>#define GROW_SIZE   1       /* How much we'll add on every reallocation. */ <br>#define QUERY_SIZE  1       /* How much we'll try for on query rows */ <br>#else <br>#define GROW_SIZE   20 <br>#define QUERY_SIZE  20 <br>#endif <br> <br>    for (;;) <br>    { <br>        /*  Get some rows from the recipient table. */ <br> <br>        hResult = lpTable-&gt;lpVtbl-&gt;QueryRows(lpTable, QUERY_SIZE, 0L, &amp;lpRow); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("QueryRows failed.\n"); <br>            goto ret; <br>        } <br> <br>        /*  Are we finished getting rows? */ <br> <br>        if (!lpRow || !(lpRow-&gt;cRows)) <br>        { <br>            /*  Free the row if any */ <br> <br>            (*lpxpl-&gt;FreeBuffer) ((LPVOID) lpRow); <br>            lpRow = NULL; <br> <br>            /*  We're finished now, break out of the (for (;;)) loop. */ <br> <br>            break; <br>        } <br> <br>        /*  Work our way through the RowSet */ <br> <br>        for (ulRow = 0; ulRow &lt; lpRow-&gt;cRows; ulRow++) <br>        { <br>            BOOL fDone = TRUE; <br> <br>            Assert(lpRow-&gt;aRow[ulRow].cValues); <br>            Assert(lpRow-&gt;aRow[ulRow].lpProps); <br> <br>            lpspvT = lpRow-&gt;aRow[ulRow].lpProps; <br> <br>            /* Check our .2 second timer before processing each row. */ <br> <br>            sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br> <br>            if (sc == MAPI_W_CANCEL_MESSAGE) <br>            { <br>                DebugTrace("Cancelling message delivery.\n"); <br>                goto ret; <br>            } <br> <br>            /*  See if we need to do the callback. If so, make the call now */ <br> <br>            if (lpfnCallBack) <br>            { <br>                Assert(lpspvT[COLUMN_PR_EMAIL_ADDRESS].ulPropTag == PR_EMAIL_ADDRESS); <br>                Assert(lpspvT[COLUMN_PR_RECIPIENT_TYPE].ulPropTag == PR_RECIPIENT_TYPE); <br> <br>                hResult = lpfnCallBack(lpxpl, <br>                    lpPropArray, <br>                    lpMessage, <br>                    lpspvT[COLUMN_PR_RECIPIENT_TYPE].Value.ul, <br>                    lpspvT[COLUMN_PR_EMAIL_ADDRESS].Value.LPSZ, <br>                    &amp;fDone); <br> <br>                if (hResult) <br>                { <br>                    DebugTrace("IGNORE: Callback function  failed.\n"); <br>                    hResult = hrSuccess; <br>                } <br>            } <br> <br>            /*  Set the PR_RESPONSIBILITY flag to its indicated new state. */ <br> <br>            Assert(lpRow-&gt;aRow[ulRow].cValues &gt; COLUMN_PR_RESPONSIBILITY); <br> <br>            /*  Make the appropriate change to PR_RESPONSIBILITY. If we're <br>                setting it, just do it into whatever column we've set; <br>                is pointing at, Prop Tag and Value. If we're clearing it, <br>                we only need to do anything if there was a discrete column, <br>                and all that's needed is to set the Prop Tag to PR_NULL. */ <br> <br>            if (fSetResponsibility) <br>            { <br>                lpspvT[COLUMN_PR_RESPONSIBILITY].ulPropTag = PR_RESPONSIBILITY; <br>                lpspvT[COLUMN_PR_RESPONSIBILITY].Value.b = fDone; <br>            } <br>            else <br>            { <br>                /*  We want to clear the flag */ <br>                lpspvT[COLUMN_PR_RESPONSIBILITY].ulPropTag = PR_NULL; <br>            } <br> <br>            /*  PR_NULL the PR_ROWID column if this will be a "bad" recipient, also <br>                adding NDR information to the row (in a column we set earlier) */ <br> <br>            if (!fDone) <br>            { <br>                TCHAR szReportText[512]; <br> <br>                lpspvT[COLUMN_PR_ROWID].ulPropTag = PR_NULL; <br> <br>                /*  The Spooler will default to a NDR report and will fill in all <br>                    required properties in the StatusRecips call. The only thing <br>                    we need to do is to fill in a specific per-recipient text <br>                    description of the problem (it defaults too but it's good <br>                    to have real info from the horse's mouth) */ <br> <br>                LoadString(lpxpl-&gt;lpxppParent-&gt;hInst, IDS_REPORT_TEXT_MSG, <br>                    szReportText, sizeof(szReportText)); <br> <br>                wsprintf(rgchBuffer, "%s%s", szReportText, <br>                    lpspvT[COLUMN_PR_EMAIL_ADDRESS].Value.LPSZ); <br> <br>                ulT = Cbtszsize(rgchBuffer); <br>                sc = lpxpl-&gt;AllocateMore(ulT, lpspvT, &amp;lpvT); <br> <br>                if (sc) <br>                { <br>                    hResult = ResultFromScode(sc); <br>                    DebugTrace("NDR text allocation failed.\n"); <br>                    goto ret; <br>                } <br> <br>                /*  Memory allocated, copy the formatted string and hook it into <br>                    the pre-allocated column. */ <br> <br>                lstrcpy((LPTSTR) lpvT, rgchBuffer); <br>                lpspvT[COLUMN_PR_REPORT_TEXT].ulPropTag = PR_REPORT_TEXT; <br>                lpspvT[COLUMN_PR_REPORT_TEXT].Value.LPSZ = (LPTSTR) lpvT; <br>            } <br> <br>            /*  Now point ourselves at one of the two LPMYADRLIST pointers */ <br> <br>            lppMyAdrList = (fDone ? &amp;lpDone : &amp;lpNotDone); <br> <br>            /*  If we didn't already have a LPMYADRLIST, allocate one now. */ <br> <br>            if (*lppMyAdrList == NULL) <br>            { <br>                /*  Allocate an initial MYADRLIST structure. Then allocate <br>                    enough memory for (GROW_SIZE) ADRENTRYs and store <br>                    it into the structure. Initialize the members. */ <br> <br>                sc = (*lpxpl-&gt;AllocateBuffer) (sizeof(MYADRLIST), &amp;lpvT); <br> <br>                if (sc) <br>                { <br>                    hResult = ResultFromScode(sc); <br>                    DebugTrace("Initial MYADRLIST allocation failed.\n"); <br>                    goto ret; <br>                } <br> <br>                /*  Hook up the MYADRLIST with no entries. */ <br> <br>                *lppMyAdrList = (LPMYADRLIST) lpvT; <br>                (*lppMyAdrList)-&gt;cMaxEntries = 0; <br>                (*lppMyAdrList)-&gt;lpAdrList = NULL; <br> <br>                /* Now allocate a ADRLIST with GROW_SIZE entries in it. */ <br> <br>                sc = (*lpxpl-&gt;AllocateBuffer) (CbNewADRLIST(GROW_SIZE), &amp;lpvT); <br> <br>                if (sc) <br>                { <br>                    hResult = ResultFromScode(sc); <br>                    DebugTrace("Initial ADRLIST allocation failed.\n"); <br>                    goto ret; <br>                } <br> <br>                /*  Now hook up this ADRLIST into the MYADRLIST. */ <br> <br>                (*lppMyAdrList)-&gt;lpAdrList = (LPADRLIST) lpvT; <br>                (*lppMyAdrList)-&gt;cMaxEntries = GROW_SIZE; <br>                (*lppMyAdrList)-&gt;lpAdrList-&gt;cEntries = 0; <br>            } <br> <br>            /*  Make sure that the selected MYADRLIST has room for another row */ <br> <br>            ulT = (*lppMyAdrList)-&gt;lpAdrList-&gt;cEntries + 1; <br>            Assert(ulT &lt;= (*lppMyAdrList)-&gt;cMaxEntries + 1); <br> <br>            if (ulT &gt; (*lppMyAdrList)-&gt;cMaxEntries) <br>            { <br>                LPADRLIST lpAdrListT; <br> <br>                /*  Not enough space, we need to create a new ADRLIST. */ <br> <br>                ulT = CbNewADRLIST((*lppMyAdrList)-&gt;cMaxEntries + GROW_SIZE); <br>                sc = (*lpxpl-&gt;AllocateBuffer) (ulT, &amp;lpvT); <br> <br>                if (sc) <br>                { <br>                    hResult = ResultFromScode(sc); <br>                    DebugTrace("Reallocation of ADRLIST failed.\n"); <br>                    goto ret; <br>                } <br> <br>                /*  Got it, now copy the data from the old one */ <br> <br>                lpAdrListT = (LPADRLIST) lpvT; <br>                ulT = CbNewADRLIST((*lppMyAdrList)-&gt;cMaxEntries); <br> <br>                if (ulT) <br>                    memcpy(lpAdrListT, (*lppMyAdrList)-&gt;lpAdrList, (UINT) ulT); <br> <br>                (*lppMyAdrList)-&gt;cMaxEntries += GROW_SIZE; <br> <br>                /*  Exchange the pointers */ <br> <br>                lpvT = (LPVOID) (*lppMyAdrList)-&gt;lpAdrList; <br>                (*lppMyAdrList)-&gt;lpAdrList = lpAdrListT; <br> <br>                /*  Free the old memory */ <br> <br>                lpxpl-&gt;FreeBuffer(lpvT); <br>            } <br> <br>            /*  We have room now so store the new ADRENTRY. As part of the <br>                storage, we're going to copy the SRow pointer from the SRowSet <br>                into the ADRENTRY. Once we've done this, we won't need the <br>                SRowSet any more ... and the SRow will be deallocated when <br>                we unwind the ADRLIST. */ <br> <br>            /*  Calculate location in ADRLIST for the new entry. */ <br> <br>            ulT = (*lppMyAdrList)-&gt;lpAdrList-&gt;cEntries++; <br> <br>            /*  Copy the data from the SRowSet. */ <br> <br>            (*lppMyAdrList)-&gt;lpAdrList-&gt;aEntries[ulT].cValues = lpRow-&gt;aRow[ulRow].cValues; <br>            (*lppMyAdrList)-&gt;lpAdrList-&gt;aEntries[ulT].rgPropVals = lpRow-&gt;aRow[ulRow].lpProps; <br> <br>            /*  Now that we are finished with this row (eg it is in the <br>                adrlist) we want to disassociate it from the rowset. */ <br> <br>            lpRow-&gt;aRow[ulRow].lpProps = NULL; <br>        } <br> <br>        /*  We're finished with the SRowSet (since it is allocated <br>            separately from the SRow). Deallocate it. */ <br> <br>        lpxpl-&gt;FreeBuffer((LPVOID) lpRow); <br>        lpRow = NULL; <br> <br>    }                           /* End of big ADRLIST builder loop */ <br> <br>    /*  Fall into exit with hResult set if something failed. */ <br> <br>ret: <br> <br>    /*  Clean up RowSet if any is left */ <br> <br>    FreeProws(lpRow); <br> <br>    /*  Clean up column stuff if any's left */ <br> <br>    lpxpl-&gt;FreeBuffer((LPVOID) lpsptT); <br> <br>    /*  If sc is set, feed it into hResult. Afterwards, hResult is the <br>        determinant of whether there was an error or not. */ <br> <br>    if (hResult) <br>    { <br>        /*  This memory should only be hanging around in the error case. */ <br> <br>        FreeMyAdrList(lpxpl, lpDone); <br>        FreeMyAdrList(lpxpl, lpNotDone); <br> <br>        *lppMyAdrListGood = NULL; <br>        *lppMyAdrListBad = NULL; <br>    } <br>    else <br>    { <br>        /*  Success, pass the adrlists we built back to the caller */ <br> <br>        *lppMyAdrListGood = lpDone; <br>        *lppMyAdrListBad = lpNotDone; <br>    } <br> <br>    DebugTraceResult(HrBuildAdrList, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  HrSendOneMessage <br> - <br> *  Purpose: <br> *      Called by HrBuildAdrList() to send a message to a recipient <br> *      that matched all of the caller's restrictions. Also called by <br> *      XPL_SubmitMessage() if transport is not peer-to-peer, in which <br> *      case the "Email address" is just our outbound directory. <br> * <br> *  Parameters: <br> *      lpxpl               The Transports logon object for this session <br> *      lpPropArray         Logon properties that have been copied from lpxpl <br> *      lpMessage           Message to send <br> *      ulRecipType         MAPI_TO, MAPI_CC, etc. If 0, not a recip. <br> *      lpszEmailAddress    Email address of this recipient. <br> *      lpfSent             Pointer to the boolean result <br> *                          of the operation. <br> * <br> *  Returns: <br> *      (HRESULT)           Set if an error encountered. <br> *      *lpfSent            FALSE if sending failed, <br> *                          TRUE if sending succeeded. <br> * <br> *  Operation: <br> *      Initializes result in *lpfSent to FALSE.  Open a stream interface <br> *      on the destination message file.  Write all the textized envelope <br> *      properties into the stream, then use TNEF to encapsulate the remaining <br> *      message properties into the stream. <br> */ <br> <br>HRESULT <br>HrSendOneMessage(LPXPL lpxpl, <br>    LPSPropValue lpPropArray, <br>    LPMESSAGE lpMessage, <br>    ULONG ulRecipType, <br>    LPTSTR lpszEmailAddress, <br>    BOOL FAR * lpfSent) <br>{ <br>    TCHAR rgchOutFileName[MAX_PATH]; <br>    HRESULT hResult = 0; <br>    SCODE sc = 0; <br>    ULONG ulT; <br>    ULONG cValues; <br>    BOOL fFromMe; <br> <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    LPIID lpidMessage = (LPIID) &amp;IID_IMessage; <br>    SPropValue spvDestMsgProps[3]; <br> <br>    LPSPropProblemArray lpProblems = NULL; <br>    LPSPropTagArray lpPropTagArray = NULL; <br> <br>    LPSTnefProblemArray lptpa = NULL; <br> <br>    WORD wKey = 0; <br>    LPITNEF lpTnef = (LPITNEF) NULL; <br>    LPSTREAM lpSof = (LPSTREAM) NULL; <br>    LPSTREAM lpXPSof = (LPSTREAM) NULL; <br> <br>    /* Assume the worst, we'll fix it later if need be */ <br> <br>    *lpfSent = FALSE; <br> <br>    /* Build file name of outgoing message. Because loopback doesn't <br>       always work on all platforms, we check the email address against <br>       our own and just substitute the inbox path if it matches. */ <br> <br>    if (!lstrcmpi(lpszEmailAddress, <br>            ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ)) <br>    { <br>        DebugTrace("Email Address is mine, doing my own internal loopback\n"); <br>        lstrcpy(rgchOutFileName, ArrayIndex(PR_SAMPLE_INBOUND_DIR, lpPropArray).Value.LPSZ); <br>        fFromMe = TRUE; <br>    } <br>    else <br>    { <br>        lstrcpy(rgchOutFileName, lpszEmailAddress); <br> <br>        /*  If this is a real email address, it won't have a <br>            trailing backslash. But if it's our outbound dir (when <br>            we're not p2p) it wiil have one. Only add one if <br>            it's needed. */ <br> <br>        ulT = lstrlen(rgchOutFileName); <br>        Assert(ulT &gt; 1); <br> <br>        if (lstrcmp(&amp;rgchOutFileName[ulT], TEXT("\\"))) <br>            lstrcat(rgchOutFileName, TEXT("\\")); <br>        fFromMe = FALSE; <br>    } <br> <br>    hResult = OpenStreamOnFile(lpxpl-&gt;AllocateBuffer, lpxpl-&gt;FreeBuffer, <br>        STGM_CREATE | STGM_READWRITE | SOF_UNIQUEFILENAME, <br>        rgchOutFileName, TEXT("TNF"), &amp;lpSof); <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("OpenStreamOnFile(%s) failed.\n",rgchOutFileName); <br>        PrintfTransportLog(TEXT("Delivery failed in OpenStreamOnFile.")); <br>        goto ret; <br>    } <br> <br>    /* Wrap the Stream-On-File object in our buffered wrapper. */ <br> <br>    hResult = HrWrapStreamOnFile(lpxpl-&gt;AllocateBuffer, lpxpl-&gt;FreeBuffer, <br>            XPSOF_READWRITE, lpSof, &amp;lpXPSof); <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("HrWrapStreamOnFile() failed\n"); <br>        goto ret; <br>    } <br> <br>    /* Write all non-TNEF properties to the text file */ <br> <br>    hResult = HrIMsgToTextMsg(lpxpl, lpPropArray, lpMessage, lpXPSof); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("HrIMsgToTextMsg() failed.\n"); <br>        PrintfTransportLog(TEXT("Delivery failed in HrIMsgToTextMsg.")); <br>        goto ret; <br>    } <br> <br>    hResult = hrSuccess; <br> <br>    /* Check our .2 second timer after writting textized properties. */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br> <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message delivery.\n"); <br>        goto ret; <br>    } <br> <br>    /* Open a TNEF encapsulation on the StreamOnFile interface */ <br> <br>    hResult = OpenTnefStream(lpMAPISup, lpXPSof, TEXT("MAPIMAIL.DAT"), <br>            TNEF_ENCODE, lpMessage, 0x01AF, &amp;lpTnef); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("OpenTNEFStream() failed.\n"); <br>        PrintfTransportLog(TEXT("Delivery failed in OpenTNEFStream.")); <br>        goto ret; <br>    } <br> <br>    /* Find out what properties there are, so we can exclude the <br>       "nontransmittables" and the properties we've textized. */ <br> <br>    hResult = lpMessage-&gt;lpVtbl-&gt;GetPropList(lpMessage, 0, /* ansi */ <br>            &amp;lpPropTagArray); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("GetPropList failed.\n"); <br>        goto ret; <br>    } <br> <br>    Assert(lpPropTagArray); <br> <br>    /* Build a new prop tag array on the memory we just got back. This <br>       prop tag array will only contain nontransmittable properties. */ <br> <br>    cValues = 0; <br> <br>    for (ulT = 0; ulT &lt; lpPropTagArray-&gt;cValues; ulT++) <br>    { <br>        ULONG ulPropTagT = lpPropTagArray-&gt;aulPropTag[ulT]; <br> <br>        /*  FIsTransmittable is a macro in the MAPI headers. Makes it <br>            really easy to determine transmittable/not when we need to */ <br> <br>        if ((!FIsTransmittable(ulPropTagT) || FIsTextizedProp(ulPropTagT)) &amp;&amp; <br>            (ulPropTagT != PR_MESSAGE_ATTACHMENTS)) <br>        { <br>            lpPropTagArray-&gt;aulPropTag[cValues++] = ulPropTagT; <br>        } <br>    } <br>    lpPropTagArray-&gt;cValues = cValues; <br> <br>    /* Exclude selected properties from our TNEF encapsulation. */ <br> <br>    hResult = lpTnef-&gt;lpVtbl-&gt;AddProps(lpTnef, <br>        TNEF_PROP_EXCLUDE, 0L, NULL, lpPropTagArray); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("AddProps failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Check our .2 second timer! */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br> <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message delivery.\n"); <br>        goto ret; <br>    } <br> <br>    /* If we had a recipient type, we should help the receiver side out <br>       with some properties, as follows: <br> <br>       PR_MESSAGE_TO_ME should be set TRUE if ulRecipType == MAPI_TO <br>       PR_MESSAGE_CC_ME should be set TRUE if ulRecipType == MAPI_CC <br>       PR_MESSAGE_RECIP_ME should be set TRUE for either of the above */ <br> <br>    if (ulRecipType) <br>    { <br>        spvDestMsgProps[0].ulPropTag = PR_MESSAGE_TO_ME; <br>        spvDestMsgProps[0].Value.b = (ulRecipType == MAPI_TO); <br> <br>        spvDestMsgProps[1].ulPropTag = PR_MESSAGE_CC_ME; <br>        spvDestMsgProps[1].Value.b = (ulRecipType == MAPI_CC); <br> <br>        spvDestMsgProps[2].ulPropTag = PR_MESSAGE_RECIP_ME; <br>        spvDestMsgProps[2].Value.b = ((ulRecipType == MAPI_TO) || (ulRecipType == MAPI_CC)); <br> <br>        lpxpl-&gt;FreeBuffer(lpProblems); <br>        lpProblems = NULL; <br> <br>        hResult = lpTnef-&gt;lpVtbl-&gt;SetProps(lpTnef, 0L, 0L, 3, <br>            spvDestMsgProps); <br> <br>        if (HR_FAILED(hResult)) <br>        { <br>            DebugTrace("SetProps failed"); <br>            goto ret; <br>        } <br>    } <br> <br>    /* OK. All the properties are copied over. Save Changes on the <br>       message we created. */ <br> <br>    hResult = lpTnef-&gt;lpVtbl-&gt;Finish(lpTnef, 0L, &amp;wKey, &amp;lptpa); <br>    lpxpl-&gt;FreeBuffer(lptpa); <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("Finish failed.\n"); <br>        goto ret; <br>    } <br> <br>    hResult = lpXPSof-&gt;lpVtbl-&gt;Commit(lpXPSof, STGC_DEFAULT); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("Commit stream failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Check our .2 second timer! */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br> <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message delivery.\n"); <br>        goto ret; <br>    } <br> <br>    *lpfSent = TRUE; <br> <br>    /* Log successful transmission. */ <br> <br>    PrintfTransportLog(TEXT("Delivery Complete: %s"), rgchOutFileName); <br> <br>ret: <br>    /* Release any open object */ <br> <br>    UlRelease(lpTnef); <br>    UlRelease(lpXPSof); <br>    UlRelease(lpSof); <br> <br>    if (HR_FAILED(hResult) &amp;&amp; lpSof) <br>        DeleteFile(rgchOutFileName); <br> <br>    /* Release the prop tag array and/or problem array if any */ <br> <br>    lpxpl-&gt;FreeBuffer(lpPropTagArray); <br> <br>    DebugTraceResult(HrSendOneMessage, hResult); <br>    return hResult; <br>} <br> <br> <br>/* Stuff to support the textized message formatting */ <br> <br>const static SizedSPropTagArray(4, sptMsgProps) = <br>{ <br>    4, <br>    { <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_SUBJECT, <br>        PR_PRIORITY, <br>        PR_BODY <br>    } <br>}; <br> <br>const static SizedSPropTagArray(5, sptRecipProps) = <br>{ <br>    5, <br>    { <br>        PR_RECIPIENT_TYPE, <br>        PR_EMAIL_ADDRESS, <br>        PR_ADDRTYPE, <br>        PR_DISPLAY_NAME, <br>        PR_RESPONSIBILITY <br>    } <br>}; <br> <br>const static SizedSPropTagArray(3, sptSenderDelegate) = <br>{ <br>    3, <br>    { <br>        PR_SENT_REPRESENTING_ENTRYID, <br>        PR_SENDER_ENTRYID, <br>        PR_REPLY_RECIPIENT_ENTRIES, <br>    } <br>}; <br> <br>TCHAR rgszTags[NUM_TAGS][MAX_TAG_LEN] = <br>{ <br>    TEXT("Message: "), <br>    TEXT("From: "), <br>    TEXT("Representing: "), <br>    TEXT("Reply To: "), <br>    TEXT("Date: "), <br>    TEXT("To: "), <br>    TEXT("Cc: "), <br>    TEXT("Bcc: "), <br>    TEXT("Subject: "), <br>    TEXT("Priority Urgent: "), <br>    TEXT("Priority Normal: "), <br>    TEXT("Priority Low: "), <br>    TEXT("Contents: "), <br>    TEXT("Text Item: "), <br>    TEXT("File Item: ") <br>}; <br> <br>TCHAR szCRLF[3] = {TEXT("\r\n")}; </code></pre>
<p>
</p>
<pre><code>TCHAR szCRLFCRLF[5] = {TEXT("\r\n\r\n")}; <br> <br> <br>/* <br> -  HrIMsgToTextMsg <br> - <br> *  Purpose: <br> *      Called by HrSendOneMessage() to write the envelope properties <br> *      to the destination message text file.  Uses the StreamOnFile <br> *      interface for all the file access.  This stream interface <br> *      is then passed to the TNEF encoder, with its current file <br> *      pointer un-modified, so the non-envelope properties can be <br> *      encapsulated in a TNEF encapsulation in a "File Item" section. <br> * <br> *  Parameters: <br> *      lpxpl               Pointer to Transport Logon object <br> *      lpPropArray         Copy of the sessions logon properties <br> *      lpMessage           Message to send <br> *      lpSof               Pointer to the stream interface <br> * <br> *  Returns: <br> *      (HRESULT)           Set if an error encountered. <br> * <br> *  Operation: <br> *      Call GetProps() on the message to extract PR_SUBMIT_DATE, PR_SUBJECT, <br> *      PR_PRIORITY, and PR_BODY.  Then call GetRecipientTable() to extract <br> *      the PR_DISPLAY_NAME and PR_EMAIL_ADDRESS for each type of <br> *      PR_RECIPIENT_TYPE.  Write all this info to the stream (after <br> *      formatting appropriately). <br> */ <br> <br>HRESULT <br>HrIMsgToTextMsg(LPXPL lpxpl, LPSPropValue lpPropArray, LPMESSAGE lpMessage, LPSTREAM lpSof) <br>{ <br>    HRESULT hr = hrSuccess; <br>    ULONG cMsgVals = 0; <br>    ULONG cSndrVals = 0; <br>    LPSPropValue lpMsgProps = NULL; <br>    LPSPropValue lpSndrProps = NULL; <br>    LPSPropValue lpPropT = NULL; <br>    LPMAPITABLE lpTbl = NULL; <br>    LPSRowSet lpRows = NULL; <br>    ULONG uli; <br>    ULONG cbOut; <br>    ULONG cbRead; <br>    ULONG cbCRLF = lstrlen(szCRLF); <br>    ULONG cbCRLFCRLF = lstrlen(szCRLFCRLF); <br>    TCHAR szRep[128]; <br>    TCHAR szFrom[128]; <br>    TCHAR szOutBuf[128]; <br>    TCHAR rgchStrmBuf[MAX_STRM_BUF]; <br>    LPTSTR lpszT1; <br>    LPTSTR lpszT2; <br>    LPSTREAM lpStrm = NULL; <br> <br>    /* Get the 4 Message properties to be textized */ <br> <br>    hr = lpMessage-&gt;lpVtbl-&gt;GetProps(lpMessage, <br>            (LPSPropTagArray) &amp;sptMsgProps, 0, /* ansi */ <br>            &amp;cMsgVals, &amp;lpMsgProps); <br> <br>    if (HR_FAILED(hr) || !cMsgVals) <br>    { <br>        DebugTrace("GetProps() MsgProps failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Get the 3 Sender/Delegate properties to be textized */ <br> <br>    hr = lpMessage-&gt;lpVtbl-&gt;GetProps(lpMessage, <br>            (LPSPropTagArray) &amp;sptSenderDelegate, 0, /* ansi */ <br>            &amp;cSndrVals, &amp;lpSndrProps); <br> <br>    if (HR_FAILED(hr) || !cSndrVals) <br>    { <br>        DebugTrace("GetProps()  SndrProps failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Returns the Recipient Table in a well defined state <br>       (i.e. minimal column set and restricted on our AddrType). */ <br> <br>    hr = HrPrepareRecipientTable(lpPropArray, lpMessage, &amp;lpTbl); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        DebugTrace("HrPrepareRecipientTable()  failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Write Message: field */ <br> <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, rgszTags[tagMessage], <br>            lstrlen(rgszTags[tagMessage]), &amp;cbOut), ret); <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>            cbCRLFCRLF, &amp;cbOut), ret); <br> <br>    /* Write From: and Representing: fields */ <br> <br>    /* The following code sets the Sender/Delegate */ <br>    /* properties as follows: <br> <br>        1) If no PR_SENT_REPRESENTING_??? in message, <br>            a)  If no PR_SENDER_??? in message, <br>                    PR_SENDER_??? = transport identities <br>            b)  PR_SENT_REPRESENTING_??? = PR_SENDER_??? <br>        2) (else) If there was a PR_SENT_REPRESENTING_??? in message, <br>            a)  If no PR_SENDER_??? in message, <br>                    PR_SENDER_??? = PR_SENT_REPRESENTING_??? <br>        3)  If no PR_REPLY_RECIPIENT_???, <br>                PR_REPLY_RECIPIENT_ENTRIES = PR_SENT_REPRESENTING_ENTRYID <br>                PR_REPLY_RECIPIENT_NAMES = PR_SENT_REPRESENTING_NAME <br> <br>       This just works because HrCrackSenderEID() doesn't change the <br>       szFrom or szRep memory unless it is successful.  It is for this <br>       reason that we don't check the return from HrCrackSenderEID() */ <br> <br>    hr = hrSuccess; <br>    *szFrom = '\0'; <br>    *szRep = '\0'; <br> <br>    if (lpSndrProps[0].ulPropTag == PR_SENT_REPRESENTING_ENTRYID) <br>        HrCrackSenderEID(lpxpl, lpSndrProps[0].Value.bin.cb, <br>            lpSndrProps[0].Value.bin.lpb, szRep); <br> <br>    if (lpSndrProps[1].ulPropTag == PR_SENDER_ENTRYID) <br>        HrCrackSenderEID(lpxpl, lpSndrProps[1].Value.bin.cb, <br>            lpSndrProps[1].Value.bin.lpb, szFrom); <br> <br>    if (!*szFrom &amp;&amp; !*szRep) <br>    { <br>        lpszT1 = ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpPropArray).Value.LPSZ; <br>        lpszT2 = ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ; <br>        wsprintf(szFrom, TEXT("%s[%s]"), lpszT1, lpszT2); <br>        lstrcpy(szRep, szFrom); <br>    } <br>    else if (*szFrom &amp;&amp; !*szRep) <br>    { <br>        lstrcpy(szRep, szFrom); <br>    } <br>    else <br>    { <br>        lstrcpy(szFrom, szRep); <br>    } <br> <br>    wsprintf(szOutBuf, TEXT("%s%s"), rgszTags[tagFrom], szFrom); <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szOutBuf, <br>            lstrlen(szOutBuf), &amp;cbOut), ret); <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>            cbCRLFCRLF, &amp;cbOut), ret); <br> <br>    wsprintf(szOutBuf, TEXT("%s%s"), rgszTags[tagRepresenting], szRep); <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szOutBuf, <br>            lstrlen(szOutBuf), &amp;cbOut), ret); <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>            cbCRLFCRLF, &amp;cbOut), ret); <br> <br>    /* Write Reply To: fields */ <br> <br>    if (lpSndrProps[2].ulPropTag == PR_REPLY_RECIPIENT_ENTRIES) <br>    { <br>        LPFLATENTRYLIST lpList = (LPFLATENTRYLIST) lpSndrProps[2].Value.bin.lpb; <br>        LPBYTE lpb; <br>        ULONG cEntries; <br> <br>        /* Attempt some level of validation for this property */ <br> <br>        if (!lpList <br>            || IsBadReadPtr(lpList, CbNewFLATENTRYLIST(0)) <br>            || !lpList-&gt;abEntries <br>            || IsBadReadPtr(lpList, (UINT) CbFLATENTRYLIST(lpList)) <br>            || !lpList-&gt;cEntries <br>            || (lpList-&gt;cEntries * sizeof(GUID) &gt; lpList-&gt;cbEntries)) <br>        { <br>            DebugTrace("Bad PR_REPLY_RECIPIENT_ENTRIES!\n"); <br>            DebugTrace("Skipping the Reply To: field.\n"); <br>        } <br>        else <br>        { <br>            lpb = lpList-&gt;abEntries; <br>            cEntries = lpList-&gt;cEntries; <br> <br>            while (cEntries--) <br>            { <br>                LPFLATENTRY lpEntry = (LPFLATENTRY) lpb; <br>                ULONG ulSize; <br> <br>                if (IsBadReadPtr(lpEntry, CbNewFLATENTRY(0)) <br>                    || IsBadReadPtr(lpEntry, (UINT) CbFLATENTRY(lpEntry))) <br>                { <br>                    DebugTrace("Bad entry inside PR_REPLY_RECIPIENT_ENTRIES!\n"); <br>                    break; <br>                } <br> <br>                ulSize = lpEntry-&gt;cb; <br> <br>                hr = HrCrackSenderEID(lpxpl, ulSize, lpEntry-&gt;abEntry, szFrom); <br> <br>                if (!hr) <br>                { <br>                    wsprintf(szOutBuf, TEXT("%s%s"), <br>                        rgszTags[tagReplyTo], szFrom); <br>                    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szOutBuf, <br>                            lstrlen(szOutBuf), &amp;cbOut), ret); <br>                    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLF, <br>                            cbCRLF, &amp;cbOut), ret); <br>                } <br> <br>                lpb += offsetof (FLATENTRY, abEntry) + ((ulSize + 3) &amp; -4L); <br>            } <br> <br>            /* Add one more CR/LF pair after Reply Recipients */ <br> <br>            TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, <br>                    szCRLF, cbCRLF, &amp;cbOut), ret); <br>        } <br>    } <br>    else <br>    { <br>        wsprintf(szOutBuf, TEXT("%s%s"), rgszTags[tagReplyTo], szFrom); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szOutBuf, <br>                lstrlen(szOutBuf), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>                cbCRLFCRLF, &amp;cbOut), ret); <br>    } <br> <br>    /* Write Date: field */ <br> <br>    if (FPropIndex(lpMsgProps, cMsgVals, PR_CLIENT_SUBMIT_TIME, &amp;uli)) <br>    { <br>        /* Property exists in message; write it to the stream */ <br>        FormatFileTime(&amp;lpMsgProps[uli].Value.ft, szOutBuf); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, rgszTags[tagDate], <br>                lstrlen(rgszTags[tagDate]), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szOutBuf, <br>                lstrlen(szOutBuf), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>                cbCRLFCRLF, &amp;cbOut), ret); <br>    } <br> <br>    /* Write To: &amp; Cc: fields */ <br> <br>    while (TRUE) <br>    { <br>        /* Get a row from the Recipient Table */ <br> <br>        hr = lpTbl-&gt;lpVtbl-&gt;QueryRows(lpTbl, 1, 0, &amp;lpRows); <br> <br>        if (hr || !lpRows || (lpRows-&gt;cRows != 1)) <br>            break; <br> <br>        lpPropT = lpRows-&gt;aRow[0].lpProps; <br> <br>        /* Throw away MAPI_ORIG and P1 Recipient Types */ <br> <br>        if ((lpPropT[0].Value.l != MAPI_TO) &amp;&amp; <br>            (lpPropT[0].Value.l != MAPI_CC)) <br>        { <br>            FreeProws(lpRows); <br>            lpRows = NULL; <br>            lpPropT = NULL; <br>            continue; <br>        } <br> <br>        /* Write Recipients as: <br>            '{To: | Cc: } Display Name [email-address]' */ <br> <br>        Assert((lpPropT[0].Value.l == MAPI_TO) || <br>            (lpPropT[0].Value.l == MAPI_CC)); <br> <br>        wsprintf(szOutBuf, TEXT("%s%s[%s]"), <br>            rgszTags[tagDate + lpPropT[0].Value.l], <br>            lpPropT[3].Value.LPSZ, lpPropT[1].Value.LPSZ); <br> <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szOutBuf, <br>                lstrlen(szOutBuf), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLF, <br>                cbCRLF, &amp;cbOut), ret); <br> <br>        /* Clean-Up */ <br> <br>        FreeProws(lpRows); <br>        lpRows = NULL; <br>        lpPropT = NULL; <br>    } <br> <br>    /* Add one more CR/LF pair after recipients */ <br> <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLF, cbCRLF, &amp;cbOut), ret); <br> <br>    /* Write Subject: field */ <br> <br>    if (FPropIndex(lpMsgProps, cMsgVals, PR_SUBJECT, &amp;uli)) <br>    { <br>        /* Property exists and is small enough to not require a <br>           stream interface to be opened on it; just write it. */ <br> <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, rgszTags[tagSubject], <br>                lstrlen(rgszTags[tagSubject]), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLF, <br>                cbCRLF, &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, lpMsgProps[uli].Value.LPSZ, <br>                lstrlen(lpMsgProps[uli].Value.LPSZ), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>                cbCRLFCRLF, &amp;cbOut), ret); <br>    } <br>    else if (!(hr = lpMessage-&gt;lpVtbl-&gt;OpenProperty(lpMessage, PR_SUBJECT, <br>                (LPIID) &amp;IID_IStream, 0, 0, (LPUNKNOWN *) &amp;lpStrm))) <br>    { <br>        /* Property exists and requires a stream interface to <br>           access all the data.  Copy between streams! */ <br> <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, rgszTags[tagSubject], <br>                lstrlen(rgszTags[tagSubject]), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLF, <br>                cbCRLF, &amp;cbOut), ret); <br> <br>        while (TRUE) <br>        { <br>            hr = lpStrm-&gt;lpVtbl-&gt;Read(lpStrm, (LPVOID) rgchStrmBuf, <br>                MAX_STRM_BUF, &amp;cbRead); <br> <br>            if (hr || (cbRead == 0)) <br>                break;          /* There's nothing to write; we're done! */ <br> <br>            TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, (LPVOID) rgchStrmBuf, <br>                    cbRead, &amp;cbOut), ret); <br> <br>            if (cbRead &lt; MAX_STRM_BUF) <br>                break;          /* We've exhausted the stream; we're done! */ <br>        } <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>                cbCRLFCRLF, &amp;cbOut), ret); <br> <br>        lpStrm-&gt;lpVtbl-&gt;Release(lpStrm); <br>        lpStrm = NULL; <br>    } <br> <br>    /* Write Priority: field */ <br> <br>    if (FPropIndex(lpMsgProps, cMsgVals, PR_PRIORITY, &amp;uli)) <br>    { <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, <br>                rgszTags[tagPrioNormal - lpMsgProps[uli].Value.l], <br>                lstrlen(rgszTags[tagPrioNormal - lpMsgProps[uli].Value.l]), <br>                &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>                cbCRLFCRLF, &amp;cbOut), ret); <br>    } <br> <br>    /* Write Contents: field */ <br> <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, rgszTags[tagContents], <br>            lstrlen(rgszTags[tagContents]), &amp;cbOut), ret); <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>            cbCRLFCRLF, &amp;cbOut), ret); <br> <br>    /* Text Item: */ <br> <br>    if (FPropIndex(lpMsgProps, cMsgVals, PR_BODY, &amp;uli)) <br>    { <br>        /* Property exists and is small enough to not require <br>           a stream interface to be opened on it; just copy it */ <br> <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, rgszTags[tagTextItem], <br>                lstrlen(rgszTags[tagTextItem]), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLF, <br>                cbCRLF, &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, lpMsgProps[uli].Value.LPSZ, <br>                lstrlen(lpMsgProps[uli].Value.LPSZ), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>                cbCRLFCRLF, &amp;cbOut), ret); <br>    } <br>    else if (!(hr = lpMessage-&gt;lpVtbl-&gt;OpenProperty(lpMessage, PR_BODY, <br>                (LPIID) &amp;IID_IStream, 0, 0, (LPUNKNOWN *) &amp;lpStrm))) <br>    { <br>        /* Property exists and requires a stream interface to <br>           access all the data.  Copy between streams! */ <br> <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, rgszTags[tagTextItem], <br>                lstrlen(rgszTags[tagTextItem]), &amp;cbOut), ret); <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLF, <br>                cbCRLF, &amp;cbOut), ret); <br> <br>        while (TRUE) <br>        { <br>            hr = lpStrm-&gt;lpVtbl-&gt;Read(lpStrm, (LPVOID) rgchStrmBuf, <br>                MAX_STRM_BUF, &amp;cbRead); <br> <br>            if (hr || (cbRead == 0)) <br>                break;          /* There's nothing to write; we're done! */ <br> <br>            TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, (LPVOID) rgchStrmBuf, <br>                    cbRead, &amp;cbOut), ret); <br> <br>            if (cbRead &lt; MAX_STRM_BUF) <br>                break;          /* We've exhausted the stream; we're done! */ <br>        } <br>        TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLFCRLF, <br>                cbCRLFCRLF, &amp;cbOut), ret); <br> <br>        lpStrm-&gt;lpVtbl-&gt;Release(lpStrm); <br>        lpStrm = NULL; <br>    } <br> <br>    /* File Item: */ <br> <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, rgszTags[tagFileItem], <br>            lstrlen(rgszTags[tagFileItem]), &amp;cbOut), ret); <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, TEXT("MESSAGE.TNF"), <br>            lstrlen(TEXT("MESSAGE.TNF")), &amp;cbOut), ret); <br>    TraceFailedWrite(lpSof-&gt;lpVtbl-&gt;Write(lpSof, szCRLF, <br>            cbCRLF, &amp;cbOut), ret); <br> <br>ret: <br>    lpxpl-&gt;FreeBuffer(lpMsgProps); <br>    lpxpl-&gt;FreeBuffer(lpSndrProps); <br>    FreeProws(lpRows); <br> <br>    UlRelease(lpTbl); <br> <br>    DebugTraceResult(HrIMsgToTextMsg(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> -  HrPrepareRecipientTable <br> - <br> *  Purpose: <br> *      Gets the Recipient Table from an IMAPIMessage and sets its <br> *      columns, restricts the view, and sorts it (if sorts are <br> *      supported).  All this in preparation of writing recipients <br> *      to the destination message file. <br> * <br> *  Parameters: <br> *      lpPropArray         Pointer to Transport Logon object <br> *      lpMsg               Message to GetRecipientTable on <br> *      lppTbl              Receives the RecipientTable <br> * <br> *  Returns: <br> *      hr                  Indicating Success/Failure <br> */ <br> <br>HRESULT <br>HrPrepareRecipientTable(LPSPropValue lpPropArray, LPMESSAGE lpMsg, LPMAPITABLE * lppTbl) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPMAPITABLE lpTbl = NULL; <br> <br>    SizedSSortOrderSet(2, rgSort) = <br>    { <br>        2, 0, 0, <br>        { <br>            PR_RECIPIENT_TYPE, TABLE_SORT_ASCEND, <br>                PR_ROWID, TABLE_SORT_ASCEND <br>        } <br>    }; <br> <br>    *lppTbl = NULL; <br> <br>    hr = lpMsg-&gt;lpVtbl-&gt;GetRecipientTable(lpMsg, 0, &amp;lpTbl); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        DebugTrace("GetRecipientTable() failed in HrPrepareRecipientTable()"); <br>        goto ret; <br>    } <br> <br>    /* SetColumns to: PR_RECIPIENT_TYPE, PR_EMAIL_ADDRESS, PR_ADDRTYPE, <br>       PR_DISPLAY_NAME, and PR_RESPONSIBILITY in that order */ <br> <br>    hr = lpTbl-&gt;lpVtbl-&gt;SetColumns(lpTbl, (LPSPropTagArray) &amp;sptRecipProps, <br>        TBL_BATCH); <br> <br>    if (HR_FAILED(hr)) <br>    { <br>        DebugTrace("SetColumns() failed in HrPrepareRecipientTable()"); <br>        goto ret; <br>    } <br> <br>    /* Sort by: PR_RECIPIENT_TYPE (i.e. MAPI_TO, MAPI_CC, MAPI_BCC) <br>            and PR_ROWID, both in acsending order */ <br> <br>    hr = lpTbl-&gt;lpVtbl-&gt;SortTable(lpTbl, (LPSSortOrderSet) &amp;rgSort, TBL_BATCH); <br> <br>    if (hr) <br>    { <br>        /* Don't fail the call for no support!  Just return <br>           the table in whatever order it may be in by default. */ <br> <br>        if (GetScode(hr) == MAPI_E_NO_SUPPORT) <br>            hr = 0; <br>        else <br>            DebugTrace("SortTable() failed in HrPrepareRecipientTable()"); <br>    } <br> <br>    /* Seek to the beginning since sorting may have moved out position */ <br> <br>    hr = lpTbl-&gt;lpVtbl-&gt;SeekRow(lpTbl, BOOKMARK_BEGINNING, 0, NULL); <br> <br>    if (hr) <br>    { <br>        DebugTrace("SeekRow() failed in HrPrepareRecipientTable()"); <br>    } <br> <br>ret: <br>    if (HR_FAILED(hr)) <br>    { <br>        UlRelease(lpTbl); <br>    } <br>    else <br>        *lppTbl = lpTbl; <br> <br>    DebugTraceResult(HrPrepareRecipientTable(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> -  HrCrackSenderEID <br> - <br> *  Purpose: <br> *      Does an OpenEntry() on the EntryID and GetProps() PR_DISPLAY_NAME <br> *      and PR_EMAIL_ADDRESS.  Then formats the return string like: <br> *          "Display Name[email-address]" <br> * <br> *  Parameters: <br> *      lpxpl           Pointer to Transport Logon object <br> *      cb              Count of bytes in EntryID <br> *      lpb             Pointer to EntryID <br> *      lpsz            Receives the formatted Name/Address pair <br> * <br> *  Returns: <br> *      hr              Indicating Success/Failure <br> * <br> *  Note: <br> *      No parameter validation!  I assume the caller knew what was <br> *      being passed in and ensured all was well. <br> */ <br> <br>HRESULT <br>HrCrackSenderEID(LPXPL lpxpl, ULONG cb, LPBYTE lpb, LPTSTR lpsz) <br>{ <br>    HRESULT hr = hrSuccess; <br>    ULONG ulObjType; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    LPMAPIPROP lpMAPIProp = NULL; <br>    ULONG cVals = 0; <br>    LPSPropValue lpProps = NULL; <br> <br>    const static SizedSPropTagArray(2, sptCracked) = <br>    { <br>        2, <br>        { <br>            PR_DISPLAY_NAME, <br>            PR_EMAIL_ADDRESS <br>        } <br>    }; <br> <br>    /* Open a Property Interface on this EntryID */ <br> <br>    hr = lpMAPISup-&gt;lpVtbl-&gt;OpenEntry(lpMAPISup, cb, (LPENTRYID) lpb, <br>        NULL, 0, &amp;ulObjType, (LPUNKNOWN *) &amp;lpMAPIProp); <br> <br>    if (hr) <br>    { <br>        DebugTrace("OpenEntry() Failed in HrCrackSenderEID().\n"); <br>        goto ret; <br>    } <br> <br>    /* Get the 2 properties we need from this object */ <br> <br>    hr = lpMAPIProp-&gt;lpVtbl-&gt;GetProps(lpMAPIProp, <br>        (LPSPropTagArray) &amp;sptCracked, 0, /* ansi */ <br>        &amp;cVals, &amp;lpProps); <br> <br>    if (hr || !cVals) <br>    { <br>        DebugTrace("GetProps() Failed in HrCrackSenderEID().\n"); <br>        goto ret; <br>    } <br> <br>    /* Assert that all went well so far!!! */ <br> <br>    Assert(lpProps); <br>    Assert(cVals == 2); <br>    Assert(lpProps[0].ulPropTag == PR_DISPLAY_NAME); <br>    Assert(lpProps[1].ulPropTag == PR_EMAIL_ADDRESS); <br> <br>    /* Format our Name/Address pair as desired */ <br> <br>    wsprintf(lpsz, "%s[%s]", lpProps[0].Value.LPSZ, lpProps[1].Value.LPSZ); <br> <br>ret: <br>    lpxpl-&gt;FreeBuffer(lpProps); <br> <br>    UlRelease(lpMAPIProp); <br> <br>    DebugTraceResult(HrCrackSenderEID(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> -  FPropIndex <br> - <br> *  Purpose: <br> *      Finds and returns (if it exists) the index of ulPropTag <br> *      in the lpProps SPropValue array. <br> * <br> *  Parameters: <br> *      lpProps         PropValue array to search through <br> *      cVals           Count of properties in lpProps <br> *      ulPropTag       PropTag to search for <br> *      puli            Receives the index of ulPropTag in lpProps <br> * <br> *  Returns: <br> *      TRUE/FALSE      TRUE if found, FALSE otherwise <br> */ <br> <br>BOOL <br>FPropIndex(LPSPropValue lpProps, ULONG cVals, ULONG ulPropTag, ULONG * puli) <br>{ <br>    Assert(lpProps); <br>    Assert(cVals); <br>    Assert(puli); <br> <br>    while (cVals--) <br>    { <br>        if (lpProps[cVals].ulPropTag == ulPropTag) <br>        { <br>            *puli = cVals; <br>            return TRUE; <br>        } <br>    } <br>    return FALSE; <br>} <br> <br> <br>/* <br> -  FormatFileTime <br> - <br> *  Purpose: <br> *      Formats a Windows NT file time as a MAPI date/time string <br> *      of the format:  yyyy/mm/dd hh:mm <br> * <br> *  Parameters: <br> *      pft             Pointer to FILETIME to convert <br> *      szTime          Destination string <br> * <br> *  Returns: <br> *      void. <br> */ <br> <br>void <br>FormatFileTime(FILETIME * pft, LPTSTR szTime) <br>{ <br>    SYSTEMTIME systime; <br> <br>    FileTimeToSystemTime(pft, &amp;systime); <br>    wsprintf(szTime, "%04.4d/%02.2d/%02.2d %02.2d:%02.2d", <br>        systime.wYear, systime.wMonth, systime.wDay, <br>        systime.wHour, systime.wMinute); <br>} <br> <br> <br>/* <br> -  FIsTextizedProp <br> - <br> *  Purpose: <br> *      Used to determine if the property is one we wish to <br> *      exclude from the TNEF encapsulation (i.e. one we've <br> *      textized in the envelope of the message file). <br> * <br> *  Parameters: <br> *      ulPropTag       PropTag to test <br> * <br> *  Return: <br> *      BOOL            Indicating if the property is textized <br> */ <br> <br>BOOL <br>FIsTextizedProp(ULONG ulPropTag) <br>{ <br>    ULONG i; <br> <br>    static SizedSPropTagArray(16, spta) = <br>    { <br>        16, <br>        { <br>            PR_SENDER_NAME, <br>            PR_SENDER_ENTRYID, <br>            PR_SENDER_SEARCH_KEY, <br>            PR_SENDER_EMAIL_ADDRESS, <br>            PR_SENDER_ADDRTYPE, <br>            PR_SENT_REPRESENTING_NAME, <br>            PR_SENT_REPRESENTING_ENTRYID, <br>            PR_SENT_REPRESENTING_SEARCH_KEY, <br>            PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>            PR_SENT_REPRESENTING_ADDRTYPE, <br>            PR_REPLY_RECIPIENT_ENTRIES, <br>            PR_REPLY_RECIPIENT_NAMES, <br>            PR_SUBJECT, <br>            PR_CLIENT_SUBMIT_TIME, <br>            PR_BODY, <br>            PR_PRIORITY <br>        } <br>    }; <br> <br>    for (i = 0; i &lt; spta.cValues; i++) <br>        if (spta.aulPropTag[i] == ulPropTag) <br>            return TRUE; <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> -  FreeMyAdrList <br> - <br> *  Purpose: <br> *      Called by anyone who winds up with a MYADRLIST structure <br> *      and wants to free it. <br> * <br> *  Parameters: <br> *      lpxpl               Session context. <br> *      lpMyAdrList         Structure to free. <br> * <br> *  Returns: <br> *      void                Data in lpMyAdrList freed. <br> * <br> *  Operation: <br> *      Walks through adrlist and frees all the memory. <br> */ <br> <br>void <br>FreeMyAdrList(LPXPL lpxpl, LPMYADRLIST lpMyAdrList) <br>{ <br>    ULONG ulT; <br>    LPSPropValue lpspvT; <br>    LPADRLIST lpAdrListT; <br> <br>    /*  Clean up any adrlist stuff that's lying around. */ <br> <br>    if (lpMyAdrList) <br>    { <br>        lpAdrListT = lpMyAdrList-&gt;lpAdrList; <br> <br>        if (lpAdrListT &amp;&amp; lpAdrListT-&gt;cEntries) <br>        { <br>            for (ulT = 0; ulT &lt; lpAdrListT-&gt;cEntries; ulT++) <br>            { <br>                lpspvT = (lpAdrListT-&gt;aEntries[ulT]).rgPropVals; <br> <br>                lpxpl-&gt;FreeBuffer((LPVOID) lpspvT); <br>            } <br>        } <br>        lpxpl-&gt;FreeBuffer((LPVOID) lpAdrListT); <br>        lpxpl-&gt;FreeBuffer((LPVOID) lpMyAdrList); <br>    } <br>} <br> <br> <br>CHAR lpszEOM[] = "\n*** End of Message ***\n"; <br>#define cchEOM (sizeof(lpszEOM) - 1) <br> <br>STDMETHODIMP <br>PreprocessMessage (LPMAPISESSION lpSession, <br>    LPMESSAGE lpMessage, <br>    LPADRBOOK lpAdrBook, <br>    LPMAPIFOLDER lpFolder, <br>    LPALLOCATEBUFFER AllocateBuffer, <br>    LPALLOCATEMORE AllocateMore, <br>    LPFREEBUFFER FreeBuffer, <br>    ULONG FAR *lpcOutbound, <br>    LPMESSAGE FAR * FAR * lpppMessage, <br>    LPADRLIST FAR *lppRecipList) <br>{ <br>    HRESULT hr; <br>    LPSTREAM lpstrm = NULL; <br>    ULONG cb; <br>    LARGE_INTEGER liTo = {0}; <br> <br>    hr = lpMessage-&gt;lpVtbl-&gt;OpenProperty (lpMessage, <br>                                    PR_BODY_A, <br>                                    (LPIID)&amp;IID_IStream, <br>                                    0, <br>                                    MAPI_MODIFY, <br>                                    (LPUNKNOWN FAR *)&amp;lpstrm); <br>    if (!HR_FAILED (hr)) <br>    { <br>        hr = lpstrm-&gt;lpVtbl-&gt;Seek (lpstrm, liTo, STREAM_SEEK_END, NULL); <br>        if (!HR_FAILED (hr)) <br>        { <br>            hr = lpstrm-&gt;lpVtbl-&gt;Write (lpstrm, lpszEOM, cchEOM, &amp;cb); <br>            if (!HR_FAILED (hr) &amp;&amp; (cb == cchEOM)) <br>            { <br>                if (!HR_FAILED (hr = lpstrm-&gt;lpVtbl-&gt;Commit (lpstrm, 0L))) <br>                    hr = lpMessage-&gt;lpVtbl-&gt;SaveChanges (lpMessage, KEEP_OPEN_READWRITE); <br>            } <br>        } <br>        UlRelease (lpstrm); <br>    } <br>     <br>    *lpcOutbound = 0; <br>    *lpppMessage = NULL; <br>     <br>    DebugTraceResult (PreprocessMessage(), hr); <br>    return hr; <br>} <br> <br> <br>STDMETHODIMP <br>RemovePreprocessInfo (LPMESSAGE lpMessage) <br>{ <br>    CHAR lpszBuf[sizeof(lpszEOM)] = {0}; <br>    HRESULT hr; <br>    LARGE_INTEGER liTo; <br>    LPSTREAM lpstrm = NULL; <br>    ULARGE_INTEGER liSize; <br>    ULONG cb; <br>    BOOL fUpd = FALSE; <br> <br>    hr = lpMessage-&gt;lpVtbl-&gt;OpenProperty (lpMessage, <br>                                    PR_BODY_A, <br>                                    (LPIID)&amp;IID_IStream, <br>                                    0, <br>                                    MAPI_MODIFY, <br>                                    (LPUNKNOWN FAR *)&amp;lpstrm); <br>    if (!HR_FAILED (hr)) <br>    { <br>        liTo.HighPart =  -1; <br>        liTo.LowPart = (ULONG)(-(LONG)(cchEOM)); <br>        hr = lpstrm-&gt;lpVtbl-&gt;Seek (lpstrm, liTo, STREAM_SEEK_END, &amp;liSize); <br>        if (!HR_FAILED (hr)) <br>        { <br>            hr = lpstrm-&gt;lpVtbl-&gt;Read (lpstrm, lpszBuf, cchEOM, &amp;cb); <br>            if (!HR_FAILED (hr) &amp;&amp; (cb == cchEOM)) <br>            { <br>                if (!lstrcmpiA (lpszEOM, lpszBuf)) <br>                { <br>                    if (!HR_FAILED (hr = lpstrm-&gt;lpVtbl-&gt;SetSize (lpstrm, liSize)) &amp;&amp; <br>                        !HR_FAILED (hr = lpstrm-&gt;lpVtbl-&gt;Commit (lpstrm, 0L))) <br>                        hr = lpMessage-&gt;lpVtbl-&gt;SaveChanges (lpMessage, KEEP_OPEN_READWRITE); <br>                } <br>            } <br>        } <br>    } <br>    UlRelease (lpstrm); <br>    DebugTraceResult (RemovePreprocessInfo(), hr); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
