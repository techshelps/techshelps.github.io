<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPRCVMSG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2156"></a>XPRCVMSG.C</h2>
<pre><code>/* <br> -  X P R C V M S G . C <br> - <br> *  Purpose: <br> *      Code to support the MAPI Transport SPI entry points for <br> *      message reception.  This module contains the following <br> *      SPI entry points: <br> * <br> *          Poll() <br> *          StartMessage() <br> * <br> *      Additional support functions found here: <br> * <br> *          HrIMsgFromTextMsg() <br> *          HrBuildSenderProps() <br> *          HrAddRecipToAdrList() <br> *          HrAddRecipToReplyList() <br> *          HrMakeSearchKey() <br> *          HrGetLine() <br> *          FGetTagAndToken() <br> *          FileTimeFromSzTime() <br> *          SetFromMeFlag() <br> * <br> *      Also, the Idle() code in XPQUEUE.C will call into this module to <br> *      find out if there's any mail to tell SpoolerNotify() about. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "xppch.h" <br>#include &lt;tnef.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "xpsof.h" <br>#include "xptxtmsg.h" <br> <br>/* Local function prototype(s) */ <br> <br>VOID SetFromMeFlag(LPXPL lpxpl, LPMESSAGE lpMsg); <br> <br> <br>/* <br> -  Poll <br> - <br> *  Purpose: <br> *      Called by the Spooler periodically in its idle loop. Also called from <br> *      the Idle() entry point code. <br> * <br> *  Parameters: <br> *      lpulIncoming        Pointer to a ULONG. <br> * <br> *  Returns: <br> *      *lpulIncoming       Nonzero if any messages are found; <br> *                          Zero if no messages were found. <br> * <br> *  Operation: <br> *      This routine uses FindFirst/FindNext to look for message container <br> *      files in the inbound directory. Because its FIND_DATA structure and <br> *      the associated Handle is contained in the session structure, it's <br> *      easy to keep context and pass it along to StartMessage(). <br> * <br> *      Because it can be called from multiple places, and there's no <br> *      guarantee that StartMessage() will be called between the time we <br> *      signal the presence of inbound mail and the next time we're called, <br> *      we maintain a boolean in the session structure which we set to TRUE <br> *      when we find a message, and which StartMessage() sets to FALSE after <br> *      processing that message. If we see it as TRUE when called, we return <br> *      immediately with *lpulIncoming set. <br> * <br> *      Otherwise, we do a FindNext if a find handle is open. If it fails, we <br> *      close the handle. <br> * <br> *      If we have no open handle (either because one wasn't open or because <br> *      we just closed one), we do a FindFirst. <br> * <br> *      If we find a message container file, we set the boolean and <br> *      *lpulIncoming and return. Else we close the find handle. <br> * <br> *      This function always returns SUCCESS_SUCCESS. <br> */ <br> <br>STDMETHODIMP <br>XPL_Poll(LPXPL lpxpl, ULONG * lpulIncoming) <br>{ <br>    HANDLE *lpPollHandle; <br>    LPWIN32_FIND_DATA lpFindData; <br>    LPMAPISUP lpMAPISup; <br>    LPSPropValue lpPropArray = lpxpl-&gt;lpPropArray; <br>    BOOL fFound = FALSE; <br>    DWORD dwIgnoreAttrs = <br>    FILE_ATTRIBUTE_READONLY | <br>    FILE_ATTRIBUTE_SYSTEM | <br>    FILE_ATTRIBUTE_DIRECTORY | <br>    FILE_ATTRIBUTE_TEMPORARY; <br> <br>    lpPollHandle = &amp;lpxpl-&gt;hInFindHandle; <br>    lpFindData = &amp;lpxpl-&gt;wfdInFindData; <br> <br>    lpMAPISup = lpxpl-&gt;lpMAPISup; <br> <br>    /* Start out with default of no incoming message */ <br> <br>    *lpulIncoming = 0; <br> <br>    /* Is inbound enabled for this session? */ <br> <br>    if (!(lpxpl-&gt;ulTransportStatus &amp; STATUS_INBOUND_ENABLED)) <br>        goto ret; <br> <br>    /* See if we found one on a previous pass through here and haven't <br>       done a StartMessage() yet... */ <br> <br>    if (lpxpl-&gt;fFoundInMessage) <br>    { <br>        *lpulIncoming = 1; <br>        goto ret; <br>    } <br> <br>    /*  One of the following is now true: <br> <br>        A)  We have a search already active, use FindNextFile. <br>            If it fails, we will want to restart the search <br>            (in case something appeared in the search behind <br>            us. <br> <br>        B)  We don't have a search active, use FindFirstFile. <br>    */ <br> <br>    /* Try the active search */ <br> <br>    if (*lpPollHandle != INVALID_HANDLE_VALUE) <br>    { <br>        fFound = FindNextFile(*lpPollHandle, lpFindData); <br> <br>        /* If we fail, close the old search so we can start <br>           a new one below. */ <br> <br>        if (!fFound) <br>        { <br>            FindClose(*lpPollHandle); <br>            *lpPollHandle = INVALID_HANDLE_VALUE; <br>        } <br>    } <br> <br>    /* If there was no search or if the old one was just closed above */ <br> <br>    if (*lpPollHandle == INVALID_HANDLE_VALUE) <br>    { <br>        HANDLE hFindT; <br>        TCHAR chFileName[MAX_PATH]; <br> <br>        /* Copy the directory name. Note that we trust the value in the <br>           profile to be correct, since the UI should have enforced a <br>           syntax that included a trailing : or \ in the spec. */ <br> <br>        lstrcpy(chFileName, <br>            (ArrayIndex(PR_SAMPLE_INBOUND_DIR, lpPropArray)).Value.LPSZ); <br> <br>        lstrcat(chFileName, TEXT("TNF*.TMP")); <br> <br>        hFindT = FindFirstFile(chFileName, lpFindData); <br> <br>        /* If nothing's found, we're done here. */ <br> <br>        if (hFindT == INVALID_HANDLE_VALUE) <br>            goto ret; <br> <br>        /* Found something, continue along. */ <br> <br>        fFound = TRUE; <br>        *lpPollHandle = hFindT; <br>    } <br> <br>    /* <br>        Here on a match. Exclude unwanted files. <br> <br>        Any match with DIRECTORY, READONLY, SYSTEM or TEMPORARY attribute <br>        is ignored. Keep trying until we exhaust the current supply or we <br>        find a file without these attributes. Also, ignore files smaller <br>        than some arbitrary size, they're probably trash. <br>    */ <br> <br>    while (fFound) <br>    { <br>        /*  We found a file. Does it have any of the attributes we <br>            want to ignore? If not, get out. If so, try another. */ <br> <br>#define MIN_USEFUL_FILESIZE ((DWORD) 64) <br> <br>        if ((!((lpFindData)-&gt;dwFileAttributes &amp; dwIgnoreAttrs)) &amp;&amp; <br>            ((lpFindData-&gt;nFileSizeHigh != 0) || <br>                (lpFindData-&gt;nFileSizeLow &gt;= MIN_USEFUL_FILESIZE))) <br>            break; <br> <br>        fFound = FindNextFile(*lpPollHandle, lpFindData); <br>    } <br> <br>    if (fFound) <br>        lpxpl-&gt;fFoundInMessage = TRUE; <br>    else <br>    { <br>        FindClose(*lpPollHandle); <br>        *lpPollHandle = INVALID_HANDLE_VALUE; <br>    } <br> <br>ret: <br>    if (lpxpl-&gt;fFoundInMessage) <br>    { <br>        /*  Got a hit. If fFound is set, we found it this time. If fFound <br>            is not set, we got it before and we were called again before <br>            StartMessage(). */ <br> <br>        *lpulIncoming = 1; <br>        DebugTrace("XPL_Poll returns *lpulIncoming=%lx\n", *lpulIncoming); <br>    } <br>    else if (lpxpl-&gt;ulTransportStatus &amp; STATUS_INBOUND_FLUSH) <br>    { <br>        lpxpl-&gt;ulTransportStatus &amp;= ~STATUS_INBOUND_FLUSH; <br>        (void)HrUpdateTransportStatus(lpxpl, 0L); <br>    } <br>    return hrSuccess; <br>} <br> <br> <br>/* <br> -  StartMessage <br> - <br> *  Purpose: <br> *      Called by the Spooler for receipt of an inbound message. This sequence <br> *      of events is set off by a SpoolerNotify (NOTIFY_NEWMAIL) or a Poll() <br> *      returning *lpulIncoming != 0. <br> * <br> *  Parameters: <br> *      ulFlags             Flags from the Spooler. Currently <br> *                          there are no StartMessage() flags <br> *                          defined in the MAPI 1.0 TSPI. <br> *      lpMessage           Pointer to message object into which <br> *                          the Spooler wants the transport to <br> *                          store the incoming message. <br> *      lpulMsgRef          Pointer to where the transport should <br> *                          store a unsigned long for use in <br> *                          identifying TransportNotify() message <br> *                          events. Initialized to 0 by the <br> *                          Spooler. We don't do anything with <br> *                          message events in this transport, so <br> *                          we don't store anything there. <br> * <br> *  Returns: <br> *      (HRESULT)           MAPI_E_BUSY if the Spooler calls <br> *                          here again while we're busy, else <br> *                          errors encountered if any. <br> *      (*lpMessage)        Contains the new input message if any. <br> * <br> *  Operation: <br> *      Checks for the result of a FindFirst/FindNext operation in the <br> *      session's FIND_DATA buffer. If none, exit without changing the input <br> *      message (this should result in the new message being destroyed when <br> *      the Spooler releases its object). <br> * <br> *      If a file was found, attempt to open it. If the open fails and the <br> *      reason is not attributable to network locking, return the error; if <br> *      attributable to network locking (like if a peer's transmit code is <br> *      writing a container file), return no error. In either case, exit <br> *      without changing the input message. <br> * <br> *      Open a stream interface on the input message file.  Pass this off <br> *      to HrIMsgFromTxtMsg() to convert all the textized envelope properties <br> *      to SPropValues which are then set on the spoolers IMessage.  When <br> *      we return, the input stream will be pointing to the beginning of <br> *      the embedded TNEF encapsulation in the input message file.  Make <br> *      the appropriate calls to TNEF to extract the properties from the <br> *      encapsulation and set them on the message. <br> * <br> *      Finally, SaveChanges() on the Spooler's message to retain the result, <br> *      delete the container file, and reset the "found message" flag for the <br> *      benefit of Poll(). <br> */ <br> <br>STDMETHODIMP <br>XPL_StartMessage(LPXPL lpxpl, <br>    ULONG ulFlags, <br>    LPMESSAGE lpMessage, <br>    ULONG * lpulMsgRef) <br>{ <br>    LPWIN32_FIND_DATA lpFindData; <br>    LPSPropValue lpMyIDArray = NULL; <br>    LPSPropValue lpPropArray = NULL; <br>    SPropValue rgDelegateProps[3]; <br>    SPropValue spvTime; <br>    LPSPropProblemArray lpProblems = NULL; <br>    TCHAR rgchFileName[MAX_PATH]; <br>    LPTSTR lptMyDir; <br>    HRESULT hResult = 0; <br>    SCODE sc = 0; <br>    BOOL fUpdatedStatus = FALSE; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    WORD wKey = 0; <br>    SPropTagArray sptExcludeNone = {0}; <br>    LPITNEF lpTnef = (LPITNEF) NULL; <br>    LPSTREAM lpSof = (LPSTREAM) NULL; <br>    LPSTREAM lpXPSof = (LPSTREAM) NULL; <br>    LPSTnefProblemArray lptpa = NULL; <br> <br>    /* Reset our .2 second timer before starting. */ <br> <br>    HrCheckSpoolerYield(lpMAPISup, TRUE); <br> <br>    /* Do this first so we know at exit time if we tried to open a file */ <br> <br>    rgchFileName[0] = '\0'; <br> <br>    /* Simple re-entrancy test. Should never happen anyway. */ <br> <br>    if (lpxpl-&gt;ulTransportStatus &amp; STATUS_INBOUND_ACTIVE) <br>    { <br>        hResult = ResultFromScode(MAPI_E_BUSY); <br>        DebugTrace("XPL_StartMessage reentrancy test failed\n"); <br>        goto ret; <br>    } <br> <br>    /* Signal that we're downloading. */ <br> <br>    *lpulMsgRef = 1L;           /* This is good enough. */ <br>    lpxpl-&gt;ulTransportStatus |= STATUS_INBOUND_ACTIVE; <br>    hResult = HrUpdateTransportStatus(lpxpl, 0L); <br>    if (hResult) <br>    { <br>        DebugTrace("Update of status row failed\n"); <br>        goto ret; <br>    } <br>    fUpdatedStatus = TRUE; <br> <br>    /* Get the current findfirst/findnext buffer */ <br> <br>    lpFindData = &amp;lpxpl-&gt;wfdInFindData; <br> <br>    /* Is there actually a message available? If not, go away. */ <br> <br>    if (!lpxpl-&gt;fFoundInMessage) <br>        goto ret; <br> <br>    sc = ScCopySessionProps(lpxpl, &amp;lpPropArray, &amp;lpMyIDArray); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        goto ret; <br>    } <br> <br>    /* Build file name of incoming message */ <br> <br>    lptMyDir = ArrayIndex(PR_SAMPLE_INBOUND_DIR, lpPropArray).Value.LPSZ; <br> <br>    lstrcpy(rgchFileName, lptMyDir); <br>    lstrcat(rgchFileName, lpFindData-&gt;cFileName); <br> <br>    PrintfTransportLog(TEXT("Start Incoming: %s"), rgchFileName); <br> <br>    hResult = OpenStreamOnFile(lpxpl-&gt;AllocateBuffer, lpxpl-&gt;FreeBuffer, <br>        STGM_READ, rgchFileName, NULL, &amp;lpSof); <br> <br>    if (hResult) <br>    { <br>        sc = GetScode(hResult); <br>        DebugTrace("OpenStreamOnFile() failed in StartMessage()\n"); <br>        PrintfTransportLog(TEXT("OpenStreamOnFile(%s) returns %lx"), rgchFileName, sc); <br> <br>        /*  If "Access Denied" just don't do anything. <br>            It's usually a situation that will clear up (when another <br>            instance of this transport closes the msg file or when the <br>            other system comes online) */ <br> <br>        if (sc == MAPI_E_NO_ACCESS) <br>            hResult = hrSuccess; <br> <br>        /*  If "Not Found", clear fFoundInMessage so that we'll do a <br>            FindNext. */ <br> <br>        if (sc == MAPI_E_NOT_FOUND) <br>            lpxpl-&gt;fFoundInMessage = FALSE; <br> <br>        goto ret; <br>    } <br> <br>    /* Wrap the Stream-On-File object in our buffered wrapper. */ <br> <br>    hResult = HrWrapStreamOnFile(lpxpl-&gt;AllocateBuffer, lpxpl-&gt;FreeBuffer, <br>            XPSOF_READ, lpSof, &amp;lpXPSof); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("HrWrapStreamOnFile() failed\n"); <br>        goto ret; <br>    } <br> <br>    /* Check our .2 second timer before attempting to receive */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br>         <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message download.\n"); <br>        goto ret; <br>    } <br> <br>    hResult = HrIMsgFromTextMsg(lpxpl, lpPropArray, lpMessage, lpXPSof); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("HrIMsgFromTextMsg() failed\n"); <br>        goto ret; <br>    } <br> <br>    /* Check our .2 second timer again. */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br>         <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message download.\n"); <br>        goto ret; <br>    } <br> <br>    /* The 0x01AF if a key used to identify the TNEF.  A real transport <br>       should generate a pseudo-random sequence for this field. */ <br> <br>    hResult = OpenTnefStream(lpxpl-&gt;lpMAPISup, lpXPSof,  <br>            TEXT("MAPIMAIL.DAT"), TNEF_DECODE, lpMessage, 0x01AF, &amp;lpTnef); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("OpenTNEF() failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Extract properties from the incomming message and add them to <br>       the target message. */ <br> <br>    hResult = lpTnef-&gt;lpVtbl-&gt;ExtractProps(lpTnef, <br>        TNEF_PROP_EXCLUDE, &amp;sptExcludeNone, &amp;lptpa); <br>    lpxpl-&gt;FreeBuffer(lptpa); <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("GetTNEFProps() failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Check our .2 second timer again. */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br>         <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message download.\n"); <br>        goto ret; <br>    } <br> <br>    /* All the properties have been copied over. Set the PR_RECEIVED_BY <br>       delegate properties (all the others were set by the transmitter) */ <br> <br>    if (lpMyIDArray) <br>    { <br>        Assert(!IsBadReadPtr(lpMyIDArray, 3 * sizeof(SPropValue))); <br>        Assert(lpMyIDArray[0].ulPropTag == PR_SENDER_ENTRYID); <br>        Assert(lpMyIDArray[1].ulPropTag == PR_SENDER_NAME); <br>        Assert(lpMyIDArray[2].ulPropTag == PR_SENDER_SEARCH_KEY); <br> <br>        memcpy(rgDelegateProps, lpMyIDArray, 3 * sizeof(SPropValue)); <br>        rgDelegateProps[0].ulPropTag = PR_RECEIVED_BY_ENTRYID; <br>        rgDelegateProps[1].ulPropTag = PR_RECEIVED_BY_NAME; <br>        rgDelegateProps[2].ulPropTag = PR_RECEIVED_BY_SEARCH_KEY; <br> <br>        /* At this point we have all the delegate properties set. Put them into <br>           the old message and then we'll just get them on the CopyTo(). */ <br> <br>        hResult = lpMessage-&gt;lpVtbl-&gt;SetProps(lpMessage, 3, <br>            rgDelegateProps, &amp;lpProblems); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("SetProps of Receiver ID to message failed.\n"); <br>            goto ret; <br>        } <br> <br>        if (lpProblems) <br>        { <br>            /* If there were problems, let's dump them to the debugger. */ <br> <br>            DebugTraceProblems("XPL_StartMessage", lpProblems); <br> <br>            lpxpl-&gt;FreeBuffer(lpProblems); <br>            lpProblems = NULL; <br>        } <br>    } <br> <br>    /* Set the Received Time to be the last-modified time on the file. */ <br> <br>    spvTime.ulPropTag = PR_MESSAGE_DELIVERY_TIME; <br>    spvTime.Value.ft = lpFindData-&gt;ftLastWriteTime; <br> <br>    hResult = lpMessage-&gt;lpVtbl-&gt;SetProps(lpMessage, 1, &amp;spvTime, NULL); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("SetProps of PR_MESSAGE_DELIVERY_TIME failed.\n"); <br>        goto ret; <br>    } <br> <br>    /*  Finished with all properties and recipients now, SaveChanges <br>        on the message. */ <br> <br>    /* Check our .2 second timer again. */ <br> <br>    sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br>         <br>    if (sc == MAPI_W_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("Cancelling message download.\n"); <br>        goto ret; <br>    } <br> <br>    hResult = lpMessage-&gt;lpVtbl-&gt;SaveChanges(lpMessage, 0L); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("SaveChanges on incoming message failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Finally, set the found message flag so we'll get another file. */ <br> <br>    lpxpl-&gt;fFoundInMessage = FALSE; <br> <br>ret: <br>    /* Log end of incoming if we logged start. */ <br> <br>    if (*rgchFileName) <br>        PrintfTransportLog(TEXT("End Incoming: %s"), rgchFileName); <br> <br>    UlRelease(lpTnef); <br>    UlRelease(lpXPSof); <br>    UlRelease(lpSof); <br> <br>    /* If we got the message into the store, delete the inbound file. */ <br> <br>    if (!(HR_FAILED (hResult)) &amp;&amp; *rgchFileName) <br>        (void)DeleteFile(rgchFileName); <br> <br>    /* Release the prop tag array and/or problem array if any */ <br> <br>    lpxpl-&gt;FreeBuffer(lpPropArray); <br>    lpxpl-&gt;FreeBuffer(lpMyIDArray); <br> <br>    /* Reset download status if set. */ <br> <br>    if (fUpdatedStatus) <br>    { <br>        lpxpl-&gt;ulTransportStatus &amp;= ~STATUS_INBOUND_ACTIVE; <br>        (void)HrUpdateTransportStatus(lpxpl, 0L); <br>    } <br> <br>    DebugTraceResult(XPL_StartMessage, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  HrIMsgFromTextMsg <br> - <br> *  Purpose: <br> *      Called by StartMessage() to read a text formatted message file, <br> *      containing a TNEF encapsulation, and converting it into a <br> *      MAPI Message.  The TNEF DLL is used to decode the binary portion <br> *      of this message into all the correct IMessage components. <br> * <br> *  Parameters: <br> *      lpxpl               Pointer to Transport Logon object <br> *      lpPropArray         Array of the transports logon properties <br> *      lpMessage           Message to receive into <br> *      lpSof               Pointer to the stream interface <br> * <br> *  Returns: <br> *      hr                  Indicating Success/Failure <br> * <br> *  Operation: <br> *      Read each Tag out of the text file and process its Token according <br> *      to my rules for the Tag ID.  PR_SUBJECT and PR_BODY are automatically <br> *      streamed into the message, PR_CLIENT_SUBMIT_TIME, PR_PRIORITY, <br> *      PR_SENDER_NAME, and PR_SENDER_ENTRYID are added with SetProps(). <br> *      All To: and Cc: recipients are added by building an AdrList <br> *      and doing a ModifyRecipients() on the message.  When we're finished <br> *      here, the file pointer in the input stream will (hopefully) be <br> *      left pointing to the start of the TNEF encapsulation. <br> */ <br> <br>HRESULT <br>HrIMsgFromTextMsg(LPXPL lpxpl, LPSPropValue lpPropArray, LPMESSAGE lpMessage, LPSTREAM lpSof) <br>{ <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    BOOL fHaveTagAndToken = FALSE; <br>    TCHAR szLine[MAX_LINE]; <br>    ULONG cbRead; <br>    ULONG ulTag; <br>    LPTSTR lpszToken; <br>    ULONG cValues = 0; <br>    LPSPropValue lpMsgProps = NULL; <br>    LPMYADRLIST lpMyRecipList = NULL; <br>    LPTSTR lpszAddrType; <br>    LPTSTR lpszReplyNames = NULL; <br>    ULONG cbReplyEntryList = 0; <br>    LPFLATENTRYLIST lpReplyEntryList = NULL; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br> <br>    lpszAddrType = ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ; <br> <br>    sc = lpxpl-&gt;AllocateBuffer(MAX_TXTMSG_PROPS * sizeof(SPropValue), <br>            &amp;lpMsgProps); <br> <br>    if (sc) <br>    { <br>        hr = ResultFromScode(sc); <br>        DebugTrace("Allocation failed.\n"); <br>        goto ret; <br>    } <br> <br>    memset(lpMsgProps, 0, MAX_TXTMSG_PROPS * sizeof(SPropValue)); <br> <br>    sc = lpxpl-&gt;AllocateBuffer(sizeof(MYADRLIST), &amp;lpMyRecipList); <br> <br>    if (sc) <br>    { <br>        hr = ResultFromScode(sc); <br>        DebugTrace("Allocation failed.\n"); <br>        goto ret; <br>    } <br> <br>    memset(lpMyRecipList, 0, sizeof(MYADRLIST)); <br> <br>    while (TRUE) <br>    { <br>        /* fHaveTagAndToken gets set only when we return from <br>           HrGetStreamedProp and the call actually gets <br>           the next tagged line and tokenizes it for us. */ <br> <br>        if (!fHaveTagAndToken) <br>        { <br>            hr = HrGetLine(lpSof, MAX_LINE, szLine, &amp;cbRead); <br> <br>            if (hr) <br>                break; <br> <br>            if (szLine[0] == '\0') <br>                continue; <br>        } <br> <br>        if (fHaveTagAndToken || FGetTagAndToken(szLine, &amp;ulTag, &amp;lpszToken)) <br>        { <br>            fHaveTagAndToken = FALSE; <br> <br>            /* Check our .2 second timer again. */ <br> <br>            sc = GetScode(HrCheckSpoolerYield(lpMAPISup, FALSE)); <br>         <br>            if (sc == MAPI_W_CANCEL_MESSAGE) <br>            { <br>                DebugTrace("Cancelling message download.\n"); <br>                goto ret; <br>            } <br> <br>            switch (ulTag) <br>            { <br>            case tagFrom: <br>            case tagRepresenting: <br>                /* Create an addressing triplet (DisplayName, EntryID, <br>                   SearchKey) from this line and add these properties <br>                   to the array of props. */ <br> <br>                hr = HrBuildSenderProps(lpxpl, lpPropArray, ulTag, lpszToken, <br>                        lpszAddrType, lpMessage, &amp;cValues, lpMsgProps); <br> <br>                if (hr) <br>                { <br>                    DebugTrace("HrBuildSenderProps() failed.\n"); <br>                    goto ret; <br>                } <br>                break; <br> <br>            case tagReplyTo: <br>                hr = HrAddRecipToReplyList(lpxpl, lpszToken, lpszAddrType, <br>                    &amp;lpszReplyNames, &amp;cbReplyEntryList, &amp;lpReplyEntryList); <br> <br>                if (hr) <br>                    goto ret; <br>                break; <br> <br>            case tagDate: <br>                lpMsgProps[cValues].ulPropTag = PR_CLIENT_SUBMIT_TIME; <br>                FileTimeFromSzTime(lpszToken, &amp;lpMsgProps[cValues++].Value.ft); <br>                break; <br> <br>            case tagTo: <br>            case tagCc: <br>                hr = HrAddRecipToAdrList(lpxpl, (LONG) ulTag - tagDate, lpszToken, <br>                    lpszAddrType, lpMyRecipList); <br>                if (hr) <br>                    goto ret; <br>                break; <br> <br>            case tagSubject: <br>            case tagTextItem: <br>                hr = HrGetStreamedProp(lpxpl, lpSof, lpMessage, <br>                        ((ulTag == tagSubject) ? PR_SUBJECT : PR_BODY), <br>                        &amp;cValues, lpMsgProps, szLine, &amp;ulTag, &amp;lpszToken); <br> <br>                if (HR_FAILED(hr)) <br>                    goto ret; <br> <br>                if(S_OK ==GetScode(hr)) <br>                    fHaveTagAndToken = TRUE; <br>                break; <br> <br>            case tagPrioLow: <br>            case tagPrioNormal: <br>            case tagPrioUrgent: <br>                lpMsgProps[cValues].ulPropTag = PR_PRIORITY; <br>                lpMsgProps[cValues++].Value.l = tagPrioNormal - ulTag; <br>                break; <br> <br>            case tagFileItem: <br>                goto ret; <br> <br>            case tagMessage: <br>            case tagBcc: <br>            case tagContents: <br>            default: <br>                break; <br>            }   /* end switch() */ <br>        }       /* end if()     */ <br>    }           /* end while()  */ <br> <br>ret: <br>    if (lpszReplyNames &amp;&amp; lpReplyEntryList) <br>    { <br>        lpMsgProps[cValues].ulPropTag = PR_REPLY_RECIPIENT_NAMES; <br>        lpMsgProps[cValues++].Value.LPSZ = lpszReplyNames; <br> <br>        lpMsgProps[cValues].ulPropTag = PR_REPLY_RECIPIENT_ENTRIES; <br>        lpMsgProps[cValues].Value.bin.cb = cbReplyEntryList; <br>        lpMsgProps[cValues++].Value.bin.lpb = (LPBYTE) lpReplyEntryList; <br>    } <br> <br>    if (cValues) <br>        lpMessage-&gt;lpVtbl-&gt;SetProps(lpMessage, cValues, lpMsgProps, NULL); <br> <br>    if (lpMyRecipList &amp;&amp; lpMyRecipList-&gt;lpAdrList) <br>    { <br>        hr = lpMessage-&gt;lpVtbl-&gt;ModifyRecipients(lpMessage, <br>            MODRECIP_ADD, lpMyRecipList-&gt;lpAdrList); <br> <br>        FreeMyAdrList(lpxpl, lpMyRecipList); <br> <br>        if (hr) <br>            DebugTrace("ModifyRecipients failed.\n"); <br>    } <br>    else <br>        lpxpl-&gt;FreeBuffer(lpMyRecipList); <br> <br>    lpxpl-&gt;FreeBuffer(lpMsgProps); <br>    lpxpl-&gt;FreeBuffer(lpszReplyNames); <br>    lpxpl-&gt;FreeBuffer(lpReplyEntryList); <br> <br>    DebugTraceResult(HrIMsgFromTextMsg(), hr); <br> <br>    return hr; <br>} <br> <br> <br>/* <br> -  HrBuildSenderProps <br> - <br> *  Purpose: <br> *      Creates the 5 identity properties: PR_***_SEARCH_KEY, <br> *      PR_***_NAME, PR_***_ENTRYID, PR_***_EMAIL_ADDRESS,  <br> *      PR_***_ADDRTYPE, where *** is either SENDER or <br> *      SENT_REPRESENTING. <br> * <br> *  Parameters: <br> *      lpxpl               The transports logon object <br> *      lpPropArray         The session logon properties <br> *      ulTag               Either tagFrom or tagRepresenting <br> *      lpszToken           Display name and address for triplet <br> *      lpszAddrType        This transports address type <br> *      lpMessage           The spoolers IMessage object <br> *      lpcValues           Count of and index into lpMsgProps <br> *      lpMsgProps          Array of message properties we are building <br> * <br> *  Returns: <br> *      hr                  Indicating Success/Failure <br> */ <br> <br>HRESULT <br>HrBuildSenderProps(LPXPL lpxpl, <br>    LPSPropValue lpPropArray, <br>    ULONG ulTag, <br>    LPTSTR lpszToken, <br>    LPTSTR lpszAddrType, <br>    LPMESSAGE lpMessage, <br>    ULONG * lpcValues, <br>    LPSPropValue lpMsgProps) <br>{ <br>    SCODE sc; <br>    HRESULT hr; <br>    LPTSTR lpszDisplayName = NULL; <br>    LPTSTR lpszAddress = NULL; <br>    LPTSTR lpsz; <br>    ULONG cbEntryID = 0; <br>    LPBYTE lpEntryID = NULL; <br>    LPBYTE lpb = NULL; <br>    ULONG cbSK; <br>    LPBYTE lpSearchKey; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    ULONG cValues = *lpcValues; <br> <br>    lpsz = strtok(lpszToken, "["); <br> <br>    sc = lpxpl-&gt;AllocateMore(lstrlen(lpsz) + 1, <br>        lpMsgProps, &amp;lpszDisplayName); <br> <br>    if (sc) <br>    { <br>        hr = ResultFromScode(sc); <br>        DebugTrace("AllocateMore failed.\n"); <br>        goto ret; <br>    } <br> <br>    lstrcpy(lpszDisplayName, lpsz); <br> <br>    lpsz = strtok(NULL, "]"); <br> <br>    sc = lpxpl-&gt;AllocateMore(lstrlen(lpsz) + 1, <br>        lpMsgProps, &amp;lpszAddress); <br> <br>    if (sc) <br>    { <br>        hr = ResultFromScode(sc); <br>        DebugTrace("AllocateMore failed.\n"); <br>        goto ret; <br>    } <br> <br>    lstrcpy(lpszAddress, lpsz); <br> <br>    /* Create OneOff Entry ID for Sender/Delegate */ <br> <br>    hr = lpMAPISup-&gt;lpVtbl-&gt;CreateOneOff(lpMAPISup, <br>        lpszDisplayName, lpszAddrType, lpszAddress, 0, <br>        &amp;cbEntryID, (LPENTRYID FAR *) &amp;lpEntryID); <br> <br>    if (hr) <br>    { <br>        DebugTrace("CreateOneOff() failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Chain the EntryID to the lpMsgProp block */ <br> <br>    sc = lpxpl-&gt;AllocateMore(cbEntryID, lpMsgProps, &amp;lpb); <br> <br>    if (sc) <br>    { <br>        hr = ResultFromScode(sc); <br>        DebugTrace("AllocateMore failed.\n"); <br>        goto ret; <br>    } <br> <br>    if (cbEntryID) <br>        memcpy(lpb, lpEntryID, (size_t) cbEntryID); <br> <br>    lpxpl-&gt;FreeBuffer(lpEntryID); <br>    lpEntryID = NULL; <br> <br>    /* Make the PR_***_SEARCH_KEY */ <br> <br>    hr = HrMakeSearchKey(lpxpl, lpMsgProps, lpszAddrType, <br>        lpszAddress, &amp;cbSK, &amp;lpSearchKey); <br> <br>    if (hr) <br>    { <br>        DebugTrace("HrMakeSearchKey() failed.\n"); <br>        goto ret; <br>    } <br> <br>    if (ulTag == tagFrom) <br>    { <br>        lpMsgProps[cValues].ulPropTag = PR_SENDER_NAME; <br>        lpMsgProps[cValues + 1].ulPropTag = PR_SENDER_ENTRYID; <br>        lpMsgProps[cValues + 2].ulPropTag = PR_SENDER_SEARCH_KEY; <br>        lpMsgProps[cValues + 3].ulPropTag = PR_SENDER_ADDRTYPE; <br>        lpMsgProps[cValues + 4].ulPropTag = PR_SENDER_EMAIL_ADDRESS; <br> <br>        if (!lstrcmpi(lpszAddress, <br>                ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, <br>                    lpPropArray).Value.LPSZ)) <br>            SetFromMeFlag(lpxpl, lpMessage); <br>    } <br>    else <br>    { <br>        Assert(ulTag == tagRepresenting); <br>        lpMsgProps[cValues].ulPropTag = PR_SENT_REPRESENTING_NAME; <br>        lpMsgProps[cValues + 1].ulPropTag = PR_SENT_REPRESENTING_ENTRYID; <br>        lpMsgProps[cValues + 2].ulPropTag = PR_SENT_REPRESENTING_SEARCH_KEY; <br>        lpMsgProps[cValues + 3].ulPropTag = PR_SENT_REPRESENTING_ADDRTYPE; <br>        lpMsgProps[cValues + 4].ulPropTag = PR_SENT_REPRESENTING_EMAIL_ADDRESS; <br>    } <br> <br>    lpMsgProps[cValues++].Value.LPSZ = lpszDisplayName; <br>    lpMsgProps[cValues].Value.bin.cb = cbEntryID; <br>    lpMsgProps[cValues++].Value.bin.lpb = lpb; <br>    lpMsgProps[cValues].Value.bin.cb = cbSK; <br>    lpMsgProps[cValues++].Value.bin.lpb = lpSearchKey; <br>    lpMsgProps[cValues++].Value.LPSZ = lpszAddrType; <br>    lpMsgProps[cValues++].Value.LPSZ = lpszAddress; <br> <br>    *lpcValues = cValues; <br> <br>ret: <br>    lpxpl-&gt;FreeBuffer(lpEntryID); <br> <br>    DebugTraceResult(HrBuildSenderProps(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> -  HrGetStreamedProp <br> - <br> *  Purpose: <br> *      Reads either the PR_BODY or PR_SUBJECT from the message file and </code></pre>
<p>
</p>
<pre><code>*      adds it to the spoolers IMessage. <br> * <br> *  Parameters: <br> *      lpSof               The stream we are reading the message from <br> *      lpMsg               The spoolers IMessage we are building up <br> *      ulPropTag           Either PR_SUBJECT or PR_BODY <br> *      lpcValues           Current size of the lpMsgProps array <br> *      lpMsgProps          The message property array we are building <br> *      lpszLine            Char array we use to read lines into <br> *      lpulTag             The text file tag we return as a side effect <br> *      lppszToken          The token we return as a side effect <br> * <br> *  Returns: <br> *      hr                  Indicating Success/Failure <br> * <br> *  10/5/95 the functon can return S_FALSE when the call to OpenProperty fails. <br> *          in this case the property still gets set using SetProps, but we don't <br> *          get the next token for the caller. So S_FALSE is to inform the <br> *          caller that we didn't get token for him and he has to do it himself. <br> */ <br> <br>HRESULT <br>HrGetStreamedProp(LPXPL lpxpl, <br>    LPSTREAM lpSof, <br>    LPMESSAGE lpMsg, <br>    ULONG ulPropTag, <br>    ULONG * lpcValues, <br>    LPSPropValue lpMsgProps, <br>    LPTSTR lpszLine, <br>    ULONG * lpulTag, <br>    LPTSTR * lppszToken) <br>{ <br>    SCODE sc; <br>    HRESULT hr; <br>    LPSTREAM lpStrm = NULL; <br>    LPTSTR lpsz = NULL; <br>    ULONG cbCRLF = lstrlen(szCRLF); <br>    ULONG cbRead; <br>    ULONG cbWritten; <br> <br>    #define cbSubjMax 4096 <br>    LPSTR szSubj = NULL; <br> <br>    sc = lpxpl-&gt;AllocateBuffer(cbSubjMax, &amp;szSubj); <br>    if (sc) <br>    { <br>        hr = ResultFromScode(sc); <br>        DebugTrace("Allocation failed.\n"); <br>        goto ret; <br>    } <br> <br>    *szSubj = '\0'; <br> <br>    hr = HrGetLine(lpSof, MAX_LINE, lpszLine, &amp;cbRead); <br> <br>    if (hr) <br>    { <br>        DebugTrace("HrGetLine failed.\n"); <br>        goto ret; <br>    } <br> <br>    if (ulPropTag == PR_SUBJECT) <br>    { <br>        /* Once in the context of the subject, go until we reach the <br>           next tag.  Then return and process the next tag and token */ <br> <br>        UINT cbCurrentSubj = 0; <br>        while (!FGetTagAndToken(lpszLine, lpulTag, lppszToken)) <br>        { <br>            if(cbCurrentSubj &lt; cbSubjMax) <br>            { <br>                cbCurrentSubj += lstrlen(lpszLine); <br>                 <br>                if(cbCurrentSubj &lt; cbSubjMax) <br>                    lstrcat(szSubj, lpszLine); <br>            } <br>             <br>            hr = HrGetLine(lpSof, MAX_LINE, lpszLine, &amp;cbRead); <br>                 <br>            if (hr) <br>                goto ret; <br>        } <br> <br>        /* this is in order to get inside the 'if' clause after OpenProperty*/ <br>        hr = 1; <br>    } <br>    else <br>    { <br>    /* If we fail to open a stream on the property, then slam <br>       this line into the property array and break outta here */ <br> <br>    hr = lpMsg-&gt;lpVtbl-&gt;OpenProperty(lpMsg, ulPropTag, <br>        (LPIID) &amp;IID_IStream, 0, MAPI_CREATE | MAPI_MODIFY, <br>        (LPUNKNOWN *) &amp;lpStrm); <br>    } <br> <br>    if (hr) <br>    { <br>        LPSTR szBuf = (ulPropTag == PR_SUBJECT) ? szSubj : lpszLine; <br>        sc = lpxpl-&gt;AllocateMore(lstrlen(szBuf) + 1, lpMsgProps, &amp;lpsz); <br> <br>        if (sc) <br>        { <br>            hr = ResultFromScode(sc); <br>            DebugTrace("Allocation failed.\n"); <br>            goto ret; <br>        } <br> <br>        lstrcpy(lpsz, szBuf); <br>        lpMsgProps[*lpcValues].ulPropTag = ulPropTag; <br>        lpMsgProps[(*lpcValues)++].Value.LPSZ = lpsz; <br> <br>        hr = (ulPropTag == PR_SUBJECT) ? hrSuccess : ResultFromScode(S_FALSE); <br>        goto ret; <br>    } <br> <br>    /* Once we're in the context of the body, the only <br>       valid Tag is the TNEF File Item Tag.  So, we <br>       ignore all other message text lines that may <br>       contain a Tag (by chance). */ <br> <br>    while (TRUE) <br>    { <br>        FGetTagAndToken(lpszLine, lpulTag, lppszToken); <br> <br>        if ((*lpulTag == tagFileItem) &amp;&amp; <br>            !lstrcmp(*lppszToken, "MESSAGE.TNF")) <br>            break; <br> <br>        TraceFailedWrite(hr = lpStrm-&gt;lpVtbl-&gt;Write(lpStrm, lpszLine, <br>                lstrlen(lpszLine), &amp;cbWritten), ret); <br> <br>        if (cbRead &lt; MAX_LINE - 1) <br>        { <br>            TraceFailedWrite(lpStrm-&gt;lpVtbl-&gt;Write(lpStrm, <br>                    szCRLF, cbCRLF, &amp;cbWritten), ret); <br>        } <br> <br>        hr = HrGetLine(lpSof, MAX_LINE, lpszLine, &amp;cbRead); <br> <br>        if (hr) <br>            break; <br>    } <br> <br> <br>ret: <br>    UlRelease(lpStrm); <br> <br>    lpxpl-&gt;FreeBuffer(szSubj); <br> <br>    DebugTraceResult(HrGetStreamedProp(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> -  HrAddRecipToAdrList <br> - <br> *  Purpose: <br> *      Called by HrIMsgFromTextMsg() to add a single recipient to the <br> *      AdrList.  Pre-allocates space (cMaxEntries) for 10 AdrEntrys the <br> *      first time called.  If all cMaxEntries slots are filled, then we <br> *      ReAlloc for (cMaxEntries + cMaxEntries/2) more slots and continue <br> *      adding the recipient.  New memory is allocated for the attributes <br> *      passed in and chained-up to the rgProps array. <br> * <br> *  Parameters: <br> *      lpxpl           Needed for access to support obj and mem allocators <br> *      ulRecipType     MAPI_TO or MAPI_CC <br> *      lpszNameAddr    recipient token (Format: Display Name[email-address] ) <br> *      lpszAddrType    This transports Address Type <br> *      lpMyAdrList     Pointer to the Recipient List <br> * <br> *  Returns: <br> *      hr              Indicating Suucess/Failure <br> */ <br> <br>HRESULT <br>HrAddRecipToAdrList(LPXPL lpxpl, LONG lRecipType, <br>    LPTSTR lpszNameAddr, LPTSTR lpszAddrType, LPMYADRLIST lpMyAdrList) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc; <br>    BOOL fAlloc = FALSE; <br>    BOOL fReAlloc = FALSE; <br>    ULONG cb; <br>    ULONG cMaxEntries; <br>    LPADRLIST lpAdrList = NULL; <br>    LPSPropValue rgProps = NULL; <br>    LPTSTR lpsz; <br>    LPTSTR lpszDisplayName = NULL; <br>    LPTSTR lpszAddress = NULL; <br>    LPTSTR lpszAddrTypeT = NULL; <br>    ULONG cbEntryID = 0; <br>    LPBYTE lpEntryID = NULL; <br>    LPBYTE lpb = NULL; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    enum enumRecipProps <br>    { <br>        iRecipType, <br>        iDisplayName, <br>        iAddrType, <br>        iAddress, <br>        iEntryID, <br>        cRecipProps <br>    }; <br> <br>    /* Determine if we need to Allocate or ReAllocate memory */ <br> <br>    if (!lpMyAdrList-&gt;cMaxEntries) <br>    { <br>        /* First time in; list should be NULL */ <br>        Assert(lpMyAdrList-&gt;lpAdrList == NULL); <br>        fAlloc = TRUE; <br>        cMaxEntries = 10; <br>    } <br>    else if (lpMyAdrList-&gt;lpAdrList &amp;&amp; <br>        (lpMyAdrList-&gt;lpAdrList-&gt;cEntries == lpMyAdrList-&gt;cMaxEntries)) <br>    { <br>        /* List is full; we need to ReAlloc */ <br>        fReAlloc = TRUE; <br>        cMaxEntries = lpMyAdrList-&gt;cMaxEntries + lpMyAdrList-&gt;cMaxEntries / 2; <br>    } <br>    else <br>    { <br>        /* List exists and is not full; just point to it */ <br>        Assert(lpMyAdrList-&gt;lpAdrList); <br>        Assert(lpMyAdrList-&gt;lpAdrList-&gt;cEntries &lt; lpMyAdrList-&gt;cMaxEntries); <br>        lpAdrList = lpMyAdrList-&gt;lpAdrList; <br>    } <br> <br>    /* If the list was NULL or full we'll Alloc/ReAlloc */ <br> <br>    if (fAlloc || fReAlloc) <br>    { <br>        cb = CbNewADRLIST(cMaxEntries); <br>        sc = lpxpl-&gt;AllocateBuffer(cb, &amp;lpAdrList); <br>        if (sc) <br>        { <br>            DebugTrace("AllocateBuffer() failed in HrAddRecipToAdrList()"); <br>            goto ret; <br>        } <br> <br>        /* Zero-out new list */ <br> <br>        memset(lpAdrList, 0, (size_t) cb); <br> <br>        if (fReAlloc) <br>        { <br>            /* We're ReAllocing; copy old list into new memory */ <br> <br>            cb = CbNewADRLIST(lpMyAdrList-&gt;lpAdrList-&gt;cEntries); <br>            if (cb) <br>                memcpy(lpAdrList, lpMyAdrList-&gt;lpAdrList, (size_t) cb); <br> <br>            /* Free old list */ <br> <br>            lpxpl-&gt;FreeBuffer(lpMyAdrList-&gt;lpAdrList); <br>        } <br> <br>        /* Fix-up size and pointer elements */ <br> <br>        lpMyAdrList-&gt;cMaxEntries = cMaxEntries; <br>        lpMyAdrList-&gt;lpAdrList = lpAdrList; <br>    } <br> <br>    /* Allocate room for cRecipProps PropValues and chain memory needed <br>       for AdrEntry data to the rgProps block to make freeing easier. */ <br> <br>    sc = lpxpl-&gt;AllocateBuffer(cRecipProps * sizeof(SPropValue), &amp;rgProps); <br> <br>    if (sc) <br>    { <br>        DebugTrace("AllocateBuffer() failed in HrAddRecipToAdrList()"); <br>        goto ret; <br>    } <br> <br>    /* Allocate memory for AddrType */ <br> <br>    sc = lpxpl-&gt;AllocateMore(lstrlen(lpszAddrType) + 1, rgProps, &amp;lpszAddrTypeT); <br> <br>    if (sc) <br>    { <br>        DebugTrace("AllocateMore() failed in HrAddRecipToAdrList()"); <br>        goto ret; <br>    } <br> <br>    /* Copy AddrType into chained memory buffer */ <br> <br>    lstrcpy(lpszAddrTypeT, lpszAddrType); <br> <br>    /* Break lpszNameAddr into lpszDisplayName and lpszAddress */ <br> <br>    lpsz = strtok(lpszNameAddr, "["); <br> <br>    sc = lpxpl-&gt;AllocateMore(lstrlen(lpsz) + 1, rgProps, &amp;lpszDisplayName); <br> <br>    if (sc) <br>    { <br>        DebugTrace("AllocateMore() failed in HrAddRecipToAdrList()"); <br>        goto ret; <br>    } <br> <br>    /* Copy Display Name into chained memory buffer */ <br> <br>    lstrcpy(lpszDisplayName, lpsz); <br> <br>    lpsz = strtok(NULL, "]"); <br> <br>    sc = lpxpl-&gt;AllocateMore(lstrlen(lpsz) + 1, rgProps, &amp;lpszAddress); <br> <br>    if (sc) <br>    { <br>        DebugTrace("AllocateMore() failed in HrAddRecipToAdrList()"); <br>        goto ret; <br>    } <br> <br>    /* Copy Address into chained memory buffer */ <br> <br>    lstrcpy(lpszAddress, lpsz); <br> <br>    /* Create OneOff Entry ID */ <br> <br>    hr = lpMAPISup-&gt;lpVtbl-&gt;CreateOneOff(lpMAPISup, <br>        lpszDisplayName, lpszAddrType, lpszAddress, 0, <br>        &amp;cbEntryID, (LPENTRYID FAR *) &amp;lpEntryID); <br> <br>    if (hr) <br>    { <br>        DebugTrace("CreateOneOff() failed in HrAddRecipToAdrList()"); <br>        goto ret; <br>    } <br> <br>    /* We need to copy the EntryID into chained memory */ <br> <br>    sc = lpxpl-&gt;AllocateMore(cbEntryID, rgProps, &amp;lpb); <br> <br>    if (sc) <br>    { <br>        DebugTrace("AllocateMore() failed in HrAddRecipToAdrList()"); <br>        goto ret; <br>    } <br> <br>    /* Copy EntryID into chained memory buffer */ <br> <br>    if (cbEntryID) <br>        memcpy(lpb, lpEntryID, (size_t) cbEntryID); <br> <br>    lpxpl-&gt;FreeBuffer(lpEntryID); <br>    lpEntryID = NULL; <br> <br>    /* Now, build the PropValue array */ <br> <br>    rgProps[iRecipType].ulPropTag = PR_RECIPIENT_TYPE; <br>    rgProps[iRecipType].Value.l = lRecipType; <br> <br>    rgProps[iDisplayName].ulPropTag = PR_DISPLAY_NAME; <br>    rgProps[iDisplayName].Value.LPSZ = lpszDisplayName; <br> <br>    rgProps[iAddrType].ulPropTag = PR_ADDRTYPE; <br>    rgProps[iAddrType].Value.LPSZ = lpszAddrTypeT; <br> <br>    rgProps[iAddress].ulPropTag = PR_EMAIL_ADDRESS; <br>    rgProps[iAddress].Value.LPSZ = lpszAddress; <br> <br>    rgProps[iEntryID].ulPropTag = PR_ENTRYID; <br>    rgProps[iEntryID].Value.bin.cb = cbEntryID; <br>    rgProps[iEntryID].Value.bin.lpb = lpb; <br> <br>    /* It's now safe to hook in the new AdrEntry */ <br> <br>    lpAdrList-&gt;aEntries[lpAdrList-&gt;cEntries].cValues = cRecipProps; <br>    lpAdrList-&gt;aEntries[lpAdrList-&gt;cEntries++].rgPropVals = rgProps; <br> <br>    return hrSuccess; <br> <br>ret: <br>    lpxpl-&gt;FreeBuffer(rgProps); <br>    lpxpl-&gt;FreeBuffer(lpEntryID); <br> <br>    if (lpAdrList != lpMyAdrList-&gt;lpAdrList) <br>        lpxpl-&gt;FreeBuffer(lpAdrList); <br> <br>    if (!hr &amp;&amp; sc) <br>        hr = ResultFromScode(sc); <br> <br>    DebugTraceResult(HrAddRecipToAdrList()Failed !, hr); <br> <br>    return hr; <br>} <br> <br> <br>/* <br> -  HrAddRecipToReplyList <br> - <br> *  Purpose: <br> *      Builds the PR_REPLY_RECIPIENT_NAMES and PR_REPLY_RECIPIENT_ENTRIES <br> *      properties by re-allocing as new ones are added to the list. <br> * <br> *  Parameters: <br> *      lpxpl           Points to Transport Logon object <br> *      lpszToken       Contains Display Name and E-Mail Address <br> *      lpszAddrType    Address Type for this transport <br> *      lppszNames      Semi-colon delimited list of Display Names <br> *      lpcbEIDList     Current size of EntryList <br> *      lppEIDList      Pointer to current EntryList <br> * <br> *  Returns: <br> *      hr              Indicating Suucess/Failure <br> */ <br> <br>HRESULT <br>HrAddRecipToReplyList(LPXPL lpxpl, LPTSTR lpszToken, LPTSTR lpszAddrType, <br>    LPTSTR * lppszNames, ULONG * lpcbEIDList, LPFLATENTRYLIST * lppEIDList) <br>{ <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    LPTSTR lpszAddress; <br>    LPTSTR lpszName; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    ULONG cbEID; <br>    LPBYTE lpEID = NULL; <br>    LPFLATENTRYLIST lpOld = *lppEIDList; <br>    ULONG cbOld; <br>    LPFLATENTRYLIST lpNew = NULL; <br>    LPFLATENTRY lpEntry; <br>    ULONG cbNew; <br>    LPTSTR lpszNewNames = NULL; <br> <br>    lpszName = strtok(lpszToken, "["); <br> <br>    lpszAddress = strtok(NULL, "]"); <br> <br>    /* Create OneOff Entry ID for this Recipient */ <br> <br>    hr = lpMAPISup-&gt;lpVtbl-&gt;CreateOneOff(lpMAPISup, <br>        lpszName, lpszAddrType, lpszAddress, 0, <br>        &amp;cbEID, (LPENTRYID FAR *) &amp;lpEID); <br> <br>    if (hr) <br>        goto ret; <br> <br>    /* Determine size of new list and allocate memory for it. <br>       The "+ 3) &amp; -4L" will round up the allocation to be a <br>       multiple of 4 bytes. */ <br> <br>    if (lpOld) <br>    { <br>        Assert(!IsBadReadPtr(lpOld, CbNewFLATENTRYLIST(0))); <br>        Assert(!IsBadReadPtr(lpOld-&gt;abEntries, (UINT) lpOld-&gt;cbEntries)); <br> <br>        cbOld = lpOld-&gt;cbEntries; <br>        cbNew = (cbOld + offsetof(FLATENTRY, abEntry) + cbEID + 3) &amp; -4L; <br>    } <br>    else <br>    { <br>        cbNew = cbOld = (cbEID + offsetof(FLATENTRY, abEntry) + 3) &amp; -4L; <br>    } <br> <br>    sc = lpxpl-&gt;AllocateBuffer(cbNew + offsetof(FLATENTRYLIST, abEntries), &amp;lpNew); <br> <br>    if (sc) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto ret; <br>    } <br> <br>    /* If Re-Allocing then copy old list and new EID, else build new list */ <br> <br>    if (lpOld) <br>    { <br>        ULONG cbNewOff = (cbOld + 3) &amp; -4L; <br> <br>        /* Copy the old data to the new structure */ <br> <br>        lpNew-&gt;cEntries = lpOld-&gt;cEntries + 1; <br>        lpNew-&gt;cbEntries = cbNew; <br> <br>        if (cbOld) <br>            memcpy(lpNew-&gt;abEntries, lpOld-&gt;abEntries, (size_t) cbOld); <br> <br>        /* Resolve the pointer to the new FLATENTRY */ <br> <br>        lpEntry = (LPFLATENTRY) &amp; lpNew-&gt;abEntries[cbNewOff]; <br> <br>    } <br>    else <br>    { <br>        lpNew-&gt;cEntries = 1; <br>        lpNew-&gt;cbEntries = cbNew; <br> <br>        /* Resolve the pointer to the new FLATENTRY */ <br> <br>        lpEntry = (LPFLATENTRY) lpNew-&gt;abEntries; <br>    } <br> <br>    /* Add in the new FLATENTRY */ <br> <br>    lpEntry-&gt;cb = cbEID; <br>    if (cbEID) <br>        memcpy(lpEntry-&gt;abEntry, lpEID, (size_t) cbEID); <br> <br>    /* Now, build the Display Name(s) String */ <br> <br>    if (*lppszNames) <br>    { <br>        /* We're Re-Allocing: copy old string and cat new one */ <br> <br>        sc = lpxpl-&gt;AllocateBuffer(lstrlen(*lppszNames) + lstrlen(lpszName) + 3, <br>            &amp;lpszNewNames); <br> <br>        if (sc) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto ret; <br>        } <br> <br>        lstrcpy(lpszNewNames, *lppszNames); <br>        lstrcat(lpszNewNames, "; "); <br>        lstrcat(lpszNewNames, lpszName); <br> <br>        lpxpl-&gt;FreeBuffer(*lppszNames); <br>    } <br>    else <br>    { <br>        /* First name; just alloc and copy... */ <br> <br>        sc = lpxpl-&gt;AllocateBuffer(lstrlen(lpszName) + 1, &amp;lpszNewNames); <br> <br>        if (sc) <br>        { <br>            hr = ResultFromScode(sc); <br>            goto ret; <br>        } <br> <br>        lstrcpy(lpszNewNames, lpszName); <br>    } <br> <br>    /* It's now safe to hook in the new list. */ <br>    /* Free old list and pass back new one.   */ <br> <br>    lpxpl-&gt;FreeBuffer(lpOld); <br> <br>    *lppEIDList = lpNew; <br>    *lpcbEIDList = cbNew + offsetof(FLATENTRYLIST, abEntries); <br>    *lppszNames = lpszNewNames; <br> <br>ret: <br>    lpxpl-&gt;FreeBuffer(lpEID); <br> <br>    if (hr) <br>    { <br>        lpxpl-&gt;FreeBuffer(lpNew); <br>        lpxpl-&gt;FreeBuffer(lpszNewNames); <br>    } <br>    return hr; <br>} <br> <br>/* <br> -  HrMakeSearchKey <br> - <br> *  Purpose: <br> *      Makes a Search Key (for the PR_???_SEARCH_KEY property) from <br> *      the values passed in.  Memory is chained to some parent block. <br> *      SearchKeys look like: ADDRTYPE:EMAILADDRESS. <br> * <br> *  Parameters: <br> *      lpxpl           Points to Transport Logon object <br> *      lpParent        Memory block to chain Search Key to <br> *      lpszAddrType    Address Type <br> *      lpszAddress     E-mail Address <br> *      lpcbSK          Returned size of Search Key <br> *      lppSK           The returned Search Key <br> * <br> *  Returns: <br> *      hr              Indicating Suucess/Failure <br> */ <br> <br>HRESULT <br>HrMakeSearchKey(LPXPL lpxpl, LPVOID lpParent, LPTSTR lpszAddrType, <br>    LPTSTR lpszAddress, ULONG * lpcbSK, LPBYTE * lppSK) <br>{ <br>    SCODE sc; <br>    HRESULT hr = hrSuccess; <br>    LPBYTE lpb = NULL; <br>    ULONG ulSize; <br> <br>    /* The 2 is for the colon and the NULL terminator */ <br> <br>    ulSize = sizeof(TCHAR) * (2 + lstrlen(lpszAddrType) + lstrlen(lpszAddress)); <br> <br>    sc = lpxpl-&gt;AllocateMore(ulSize, lpParent, &amp;lpb); <br> <br>    if (sc) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto ret; <br>    } <br> <br>    /* We need to convert to upper case, that's the law! */ <br> <br>    wsprintf((LPTSTR) lpb, "%s:%s", lpszAddrType, lpszAddress); <br>    CharUpperBuff((LPTSTR) lpb, (UINT) (ulSize - sizeof(TCHAR))); <br> <br>    *lpcbSK = ulSize; <br>    *lppSK = lpb; <br> <br>ret: <br>    return hr; <br>} <br> <br>/* <br> -  HrGetLine <br> - <br> *  Purpose: <br> *      Kind of like fgets() except it strips CR\LF pairs for us. <br> *      Reads cbDest bytes from the lpSof stream or until a CR/LF <br> *      pair is reached, whichever comes first.  Returns count of <br> *      bytes read into lpsz. <br> * <br> *  Parameters: <br> *      lpSof           Points to an OLE 2.0 Stream (to be read from) <br> *      cbDest          Size of memory pointed to by lpsz <br> *      lpsz            Points to a chunck of memory that receives the <br> *                      line being read in.  Must be of size cbDest. <br> *      pcbRead         Receives the count of bytes actually read in. <br> * <br> *  Returns: <br> *      hr              Indicating Suucess/Failure <br> */ <br> <br>HRESULT <br>HrGetLine(LPSTREAM lpSof, ULONG cbDest, LPTSTR lpsz, ULONG * pcbRead) <br>{ <br>    HRESULT hr = S_OK; <br>    BOOL fCRLF = FALSE; <br>    TCHAR rgch1[1]; <br>    TCHAR rgch2[1]; <br>    ULONG cbRead; <br> <br>    if (!lpSof || (cbDest == 0) || !lpsz || !pcbRead) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    for (*pcbRead = 0; *pcbRead &lt; cbDest - sizeof(TCHAR);) <br>    { <br>        /* read one TCHAR from stream */ <br> <br>        hr = lpSof-&gt;lpVtbl-&gt;Read(lpSof, (LPVOID) rgch1, sizeof(TCHAR), &amp;cbRead); <br> <br>        if (hr || (cbRead != sizeof(TCHAR))) <br>            break; <br> <br>        /* Test for CR/LF pair; if not then add to line */ <br> <br>        if (*rgch1 == '\r') <br>        { <br>            hr = lpSof-&gt;lpVtbl-&gt;Read(lpSof, (LPVOID) rgch2, sizeof(TCHAR), &amp;cbRead); <br> <br>            if (hr) <br>                break; <br> <br>            if (cbRead == sizeof(TCHAR)) <br>            { <br>                if (*rgch2 == '\n') <br>                { <br>                    fCRLF = TRUE; <br>                    break; <br>                } <br>            } <br>            else <br>            { <br>                *lpsz++ = *rgch1; <br>                *lpsz++ = *rgch2; <br>                *pcbRead += 2 * sizeof(TCHAR); <br>            } <br>        } <br>        else <br>        { <br>            *lpsz++ = *rgch1; <br>            *pcbRead += sizeof(TCHAR); <br>        } <br>    } <br> <br>    /* NULL terminate and leave */ <br> <br>    *lpsz = '\0'; <br> <br>    /* Test for the EOF case.  Since the stream <br>       won't return errors, we will!!!! */ <br> <br>    if (!fCRLF &amp;&amp; !*pcbRead) <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br> <br>    return hr; <br>} <br> <br> <br>/* <br> -  FGetTagAndToken <br> - <br> *  Purpose: <br> *      Breaks a line read from the input stream into Tag and Token. <br> *      If no Tag is found, then returns FALSE indicating this is not <br> *      a Tag'd line. <br> * <br> *  Parameters: <br> *      lpsz            A line from the messsage file that may have <br> *                      the format: 'Tag: Token'.  Must be of size MAX_LINE. <br> *      pulTag          Will receive the index of lpsz's Tag in rgszTag <br> *      lppszToken      Will point to the token in lpsz <br> * <br> *  Returns: <br> *      TRUE            If lpsz starts with a valid Tag <br> *      FALSE           otherwise <br> */ <br> <br>BOOL <br>FGetTagAndToken(LPTSTR lpsz, ULONG * pulTag, LPTSTR * lppszToken) <br>{ <br>    ULONG uli; <br>    TCHAR chT; <br>    LPTSTR lpszT; <br> <br>    if (!lpsz || !pulTag || !lppszToken) <br>        return FALSE; <br> <br>    /* Tags end with ':'  If lpsz has a ':' then it MIGHT be <br>       a Tag'd line, else it's definitely NOT a Tag'd line. */ <br> <br>    lpszT = strchr(lpsz, ':'); <br> <br>    if (!lpszT) <br>        return FALSE; <br> <br>    /* Check that we're not at the MAX_LINE extent of lpsz.  If we are <br>       then just return, cause this can't possibly be a Tag'd line! <br>       The '3' accounts for the space, colon, and null terminator. */ <br> <br>    if ((lpszT - lpsz) &gt; (MAX_LINE - 3)) <br>        return FALSE; <br> <br>    /* Swap *(lpszT+2) with a NULL to seperate Tag from Token */ <br> <br>    lpszT += 2; <br>    chT = *lpszT; <br>    *lpszT = '\0'; <br> <br>    /* Look-Up 'Potential' Tag in Tag Table */ <br> <br>    for (uli = 0; uli &lt; NUM_TAGS; uli++) <br>    { <br>        if (!lstrcmp(lpsz, rgszTags[uli])) <br>        { <br>            /* Found!  Remember index */ <br> <br>            *pulTag = uli; <br>            break; <br>        } <br>    } <br> <br>    /* Swap that NULL out.  lpszT now points to the token (maybe) */ <br> <br>    *lpszT = chT; <br> <br>    if (uli == NUM_TAGS) <br>        return FALSE;           /* Tag wasn't found; it's just a line */ <br> <br>    *lppszToken = lpszT; <br> <br>    return TRUE; <br>} <br> <br> <br>/* <br> -  FileTimeFromSzTime <br> - <br> *  Purpose: <br> *      Converts the textized data field in the text file format <br> *      to a FILETIME struct format.  If we encounter errors in <br> *      parsing the lpszDateTime string, we jump to the conversion <br> *      call and will translate as much as we've filled in so far. <br> * <br> *  Parameters: <br> *      lpszDateTime        Date/Time in the format: yyyy/mm/dd hh:mm <br> *      pft                 Pointer to a FILETIME struct <br> */ <br> <br>void <br>FileTimeFromSzTime(LPTSTR lpszDateTime, FILETIME * pft) <br>{ <br>    SYSTEMTIME systime = <br>    {0, 0, 0, 0, 0, 0, 0, 0}; <br>    LPTSTR lpsz; <br> <br>    /* Feeble attempt at parameter validation! */ <br> <br>    if (!lpszDateTime || !pft) <br>        return; <br> <br>    /* Grab the Year */ <br> <br>    lpsz = strtok(lpszDateTime, "/"); <br>    if (!lpsz) <br>        goto ret; <br> <br>    systime.wYear = atoi(lpsz); <br> <br>    /* Grab the Month */ <br> <br>    lpsz = strtok(NULL, "/"); <br>    if (!lpsz) <br>        goto ret; <br> <br>    systime.wMonth = atoi(lpsz); <br> <br>    /* Grab the Day */ <br> <br>    lpsz = strtok(NULL, " "); <br>    if (!lpsz) <br>        goto ret; <br> <br>    systime.wDay = atoi(lpsz); <br> <br>    /* Grab the Hour */ <br> <br>    lpsz = strtok(NULL, ":"); <br>    if (!lpsz) <br>        goto ret; <br> <br>    systime.wHour = atoi(lpsz); <br> <br>    /* Grab the Minutes */ <br> <br>    lpsz = strtok(NULL, "\r\n:"); <br>    if (!lpsz) <br>        goto ret; <br> <br>    systime.wMinute = atoi(lpsz); <br> <br>ret: <br>    SystemTimeToFileTime(&amp;systime, pft); <br>} <br> <br> <br>/* <br> -  SetFromMeFlag <br> - <br> *  Purpose: <br> *      Sets the PR_MESSAGE_FLAGS MSGFLAG_FROMME bit to on. <br> * <br> */ <br> <br>VOID <br>SetFromMeFlag(LPXPL lpxpl, LPMESSAGE lpMsg) <br>{ <br>    HRESULT hResult; <br>    LPSPropValue lpProp = NULL; <br> <br>    /* Get the current state of the Message Flags */ <br> <br>    hResult = HrGetOneProp((LPMAPIPROP)lpMsg, PR_MESSAGE_FLAGS, &amp;lpProp); <br> <br>    if (HR_FAILED(hResult)) <br>        goto ret; <br> <br>    /* Add the FromMe bit */ <br> <br>    lpProp-&gt;Value.l |= MSGFLAG_FROMME; <br> <br>    hResult = HrSetOneProp((LPMAPIPROP)lpMsg, lpProp); <br> <br>ret: <br>    lpxpl-&gt;FreeBuffer(lpProp); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
