<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPSOF.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2159"></a>XPSOF.C</h2>
<pre><code>/* <br> -  X P S O F . C <br> - <br> *  Purpose: <br> *      Wraps the StreamOnFile object to add buffering of the stream. <br> *      The wrappered version uses an in-memory buffer, or cache, to <br> *      reduce the number of actual Reads and Writes to the underlying <br> *      stream.  The goal is, obviously, to improve performance. <br> *      Note: This code is not thread safe.  Also, the implementation <br> *      is not optimized for streams that both read and write continuously <br> *      because there will be too much flushing going on. <br> * <br> *  Copyright 1992-1995, Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br> <br>#include "xppch.h" <br>#include "xpsof.h" <br> <br>/* Private support function */ <br> <br>HRESULT HrRewindStream(LPXPSOF, ULONG); <br>VOID    HMemCopy(VOID HUGEP * lpvDst, VOID HUGEP * lpvSrc, ULONG cb); <br> <br> <br>XPSOF_Vtbl VtblXPSOF = <br>{ <br>    XPSOF_QueryInterface, <br>    XPSOF_AddRef, <br>    XPSOF_Release, <br>    XPSOF_Read, <br>    XPSOF_Write, <br>    XPSOF_Seek, <br>    XPSOF_SetSize, <br>    XPSOF_CopyTo, <br>    XPSOF_Commit, <br>    XPSOF_Revert, <br>    XPSOF_LockRegion, <br>    XPSOF_UnlockRegion, <br>    XPSOF_Stat, <br>    XPSOF_Clone <br>}; <br> <br> <br>/* <br> -  HrWrapStreamOnFile <br> - <br> *  Purpose: <br> *      This function takes a Stream-On-File object and wraps it.  The <br> *      process of wrappering involves creating a similar object, <br> *      allocating memory for the buffer, AddRefing the original object, <br> *      and returning this new object to the caller. <br> * <br> *  Parameters: <br> *      lpAllocBuffer           A MAPI memory allocator function <br> *      lpFreeBuffer            The corresponding FreeBuffer function <br> *      ulFlags                 XPSOF_READ, XPSOF_WRITE, or XPSOF_READWRITE <br> *      lpStream                The original Stream-On-File to be wrapped <br> *      lppWrappedStream        The new XPSOF object. <br> * <br> *  Returns: <br> *      HRESULT                 Indicating Success/Failure <br> */ <br> <br>STDMETHODIMP <br>HrWrapStreamOnFile( <br>    LPALLOCATEBUFFER    lpAllocBuffer, <br>    LPFREEBUFFER        lpFreeBuffer, <br>    ULONG               ulFlags, <br>    LPSTREAM            lpStream, <br>    LPSTREAM *          lppWrappedStream) <br>{ <br>    SCODE sc; <br>    LPXPSOF lpxpsof = NULL; <br> <br>    /* Allocate the new Stream object */ <br> <br>    sc = lpAllocBuffer(sizeof(XPSOF), (LPVOID *)&amp;lpxpsof); <br> <br>    if (FAILED(sc)) <br>    { <br>        DebugTrace("Allocation of XPSOF object failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Init the object */ <br> <br>    lpxpsof-&gt;lpVtbl = &amp;VtblXPSOF; <br>    lpxpsof-&gt;lcInit = 1; <br>    lpxpsof-&gt;ulFlags = ulFlags; <br>    lpxpsof-&gt;lpstrm = lpStream; <br>    lpxpsof-&gt;lpvBuff = NULL; <br>    lpxpsof-&gt;libBuff = 0; <br>    lpxpsof-&gt;cbBuffMac = 0; <br>    lpxpsof-&gt;fDirty = FALSE; <br>    lpxpsof-&gt;FreeBuffer = lpFreeBuffer; <br> <br>    /* Allocate the buffer or cache */ <br> <br>    sc = lpAllocBuffer(XPSOF_BUFF_MAX, (LPVOID *)&amp;lpxpsof-&gt;lpvBuff); <br> <br>    if (FAILED(sc)) <br>    { <br>        DebugTrace("Allocation of stream buffer failed.\n"); <br>        goto ret; <br>    } <br> <br>    /* Now that we've succeeded, AddRef the original object */ <br> <br>    lpStream-&gt;lpVtbl-&gt;AddRef(lpStream); <br> <br>    *lppWrappedStream = (LPSTREAM)lpxpsof; <br> <br>ret: <br>    if (FAILED(sc)) <br>    { <br>        if (lpxpsof) <br>        { <br>            lpFreeBuffer(lpxpsof-&gt;lpvBuff); <br>            lpFreeBuffer(lpxpsof); <br>        } <br>    } <br> <br>    DebugTraceSc(HrWrapStreamOnFile, sc); <br>    return ResultFromScode(sc); <br>} <br> <br> <br>/* <br> -  IUnknown::QueryInterface <br> -  IUnknown::AddRef <br> -  IUnknown::Release <br> - <br> *  Purpose: <br> *      These are the XPSOF's OLE IUnknown methods. <br> */ <br> <br>STDMETHODIMP <br>XPSOF_QueryInterface(LPXPSOF lpXPSOF, REFIID riid, LPVOID * lppvObj) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF)) || <br>        IsBadReadPtr (riid, sizeof(IID)) || <br>        IsBadWritePtr (lppvObj, sizeof(LPVOID))) <br>    { <br>        DebugTraceSc(XPSOF_QueryInterface, E_INVALIDARG); <br>        return ResultFromScode (E_INVALIDARG); <br>    } <br> <br>    if (memcmp(riid, &amp;IID_IUnknown, sizeof(IID)) <br>        &amp;&amp; memcmp(riid, &amp;IID_IStream, sizeof(IID))) <br>    { <br>        *lppvObj = NULL;    // OLE requires zeroing [out] parameters <br>        DebugTraceSc(XPSOF_QueryInterface, E_NOINTERFACE); <br>        return ResultFromScode (E_NOINTERFACE); <br>    } <br> <br>    lpXPSOF-&gt;lcInit++; <br>    *lppvObj = lpXPSOF; <br> <br>    return hrSuccess; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>XPSOF_AddRef(LPXPSOF lpXPSOF) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF))) <br>    { <br>        DebugTraceSc (XPSOF_AddRef(), E_INVALIDARG); <br>        return 1; <br>    } <br> <br>    return ++lpXPSOF-&gt;lcInit; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>XPSOF_Release (LPXPSOF lpXPSOF) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF))) <br>    { <br>        DebugTraceSc (XPSOF_Release(), E_INVALIDARG); <br>        return 1; <br>    } <br> <br>    if (--lpXPSOF-&gt;lcInit == 0) <br>    { <br>        if (lpXPSOF-&gt;lpstrm) <br>            lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Release(lpXPSOF-&gt;lpstrm); <br> <br>        if (lpXPSOF-&gt;lpvBuff) <br>            lpXPSOF-&gt;FreeBuffer(lpXPSOF-&gt;lpvBuff); <br> <br>        lpXPSOF-&gt;FreeBuffer(lpXPSOF); <br> <br>        return 0; <br>    } <br> <br>    return lpXPSOF-&gt;lcInit; <br>} <br> <br> <br>/* <br> -  IStream::Read <br> - <br> *  Purpose: <br> *      To read data from the stream. <br> */ <br> <br>STDMETHODIMP <br>XPSOF_Read (LPXPSOF lpXPSOF, <br>    VOID HUGEP * lpvData, <br>    ULONG cbSize, <br>    ULONG * lpcbRead) <br>{ <br>    HRESULT hr = hrSuccess; <br>    ULONG cbRead = 0; <br>    ULONG cbT; <br>    VOID HUGEP * lpvRead = NULL; <br> <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF)) || <br>        IsBadHugeWritePtr (lpvData, cbSize) || <br>        (lpcbRead &amp;&amp; IsBadWritePtr (lpcbRead, sizeof(ULONG)))) <br>    { <br>        hr = ResultFromScode(STG_E_INVALIDPARAMETER); <br>        goto ret; <br>    } <br> <br>    if (!(lpXPSOF-&gt;ulFlags &amp; XPSOF_READ)) <br>    { <br>        hr = ResultFromScode(STG_E_ACCESSDENIED); <br>        goto ret; <br>    } <br> <br>    Assert(lpXPSOF-&gt;cbBuffMac &gt;= lpXPSOF-&gt;libBuff); <br> <br>    /* First, flush the buffer if it has been written into.  This     */ <br>    /* operation empties our buffer and zeros the offset and size.    */ <br>    /* We do this because we also buffer writes and we need to force  */ <br>    /* the underlying stream to point to where the caller expects.    */ <br> <br>    if ((lpXPSOF-&gt;ulFlags &amp; XPSOF_WRITE) &amp;&amp; lpXPSOF-&gt;fDirty) <br>    { <br>        hr = XPSOF_Commit(lpXPSOF, 0); <br> <br>        if (HR_FAILED(hr)) <br>            goto ret; <br>    } <br> <br>    /* Determine if the buffer is empty (cbT == 0) or not (cbT != 0). */ <br>    /* We consider the buffer empty if we've read past the end of it  */ <br>    /* or if cbBuffMac and libBuff are equal to zero.                 */ <br> <br>    cbT = lpXPSOF-&gt;cbBuffMac - lpXPSOF-&gt;libBuff; <br> <br>    /* If the buffer is empty and the caller wants to read less than  */ <br>    /* the size of our buffer, then we'll fill the buffer from the    */ <br>    /* underlying stream object.  Adjust our buffer offset and size.  */ <br> <br>    if (!cbT &amp;&amp; (cbSize &lt; XPSOF_BUFF_MAX)) <br>    { <br>        hr = lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Read(lpXPSOF-&gt;lpstrm, <br>                lpXPSOF-&gt;lpvBuff, XPSOF_BUFF_MAX, &amp;cbRead); <br> <br>        if (HR_FAILED(hr)) <br>            goto ret; <br> <br>        lpXPSOF-&gt;libBuff = 0; <br>        lpXPSOF-&gt;cbBuffMac = cbT = cbRead; <br>    } <br> <br>    /* Now, if the buffer is *not* empty and the caller wants to read */ <br>    /* fewer bytes than what is in the buffer, then we read it from   */ <br>    /* our buffer, fix-up our offset, set the count read and leave.   */ <br> <br>    if (cbT &amp;&amp; (cbSize &lt;= cbT)) <br>    { <br>        lpvRead = (VOID HUGEP *)((LPBYTE)lpXPSOF-&gt;lpvBuff + lpXPSOF-&gt;libBuff); <br>        HMemCopy(lpvData, lpvRead, cbSize); <br>        lpXPSOF-&gt;libBuff += cbSize; <br>        cbRead = cbSize; <br>        goto ret; <br>    } <br> <br>    /* If we are here, then the caller has requested more bytes to be */ <br>    /* read than what can fit in our buffer.  In this case, we copy   */ <br>    /* the remaining data from the buffer (if any) into lpvData and   */ <br>    /* then go straight to the underlying stream for the remainder.   */ <br>    /* Either way, our buffer is empty after this operation.          */ <br> <br>    lpvRead = lpvData; <br> <br>    if (cbT) <br>    { <br>        HMemCopy(lpvRead, (VOID HUGEP *)((LPBYTE)lpXPSOF-&gt;lpvBuff + lpXPSOF-&gt;libBuff), cbT); <br>        lpvRead = (BYTE HUGEP *)lpvRead + cbT; <br>        lpXPSOF-&gt;libBuff = 0; <br>        lpXPSOF-&gt;cbBuffMac = 0; <br>    } <br> <br>    hr = lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Read(lpXPSOF-&gt;lpstrm, <br>            lpvRead, cbSize-cbT, &amp;cbRead); <br> <br>    if (HR_FAILED(hr)) <br>        goto ret; <br> <br>    cbRead += cbT; <br> <br>ret: <br>    if (lpcbRead) <br>        *lpcbRead = cbRead; <br> <br>    DebugTraceResult (XPSOF_Read(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> -  IStream::Write <br> - <br> *  Purpose: <br> *      To write data to the stream. <br> */ <br> <br>STDMETHODIMP <br>XPSOF_Write (LPXPSOF lpXPSOF, <br>    VOID HUGEP * lpvData, <br>    ULONG cbSize, <br>    ULONG * lpcbWritten) <br>{ <br>    HRESULT hr = hrSuccess; <br>    ULONG cbWritten = 0; <br>    ULONG cbT; <br>    VOID HUGEP * lpvWrite = NULL; <br> <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF)) || <br>        IsBadHugeReadPtr (lpvData, cbSize) || <br>        (lpcbWritten &amp;&amp; IsBadWritePtr (lpcbWritten, sizeof(ULONG)))) <br>    { <br>        hr = ResultFromScode(STG_E_INVALIDPARAMETER); <br>        goto ret; <br>    } <br> <br>    if (!(lpXPSOF-&gt;ulFlags &amp; XPSOF_WRITE)) <br>    { <br>        hr = ResultFromScode(STG_E_ACCESSDENIED); <br>        goto ret; <br>    } <br> <br>    Assert(lpXPSOF-&gt;cbBuffMac &gt;= lpXPSOF-&gt;libBuff); <br> <br>    /* First, if we've been Reading, then we need to re-wind the file  */ <br>    /* pointer in the underlying stream to compensate for the last     */ <br>    /* buffered Read.  Our new vacancy = the Max Size of our buffer.   */ <br> <br>    if (!lpXPSOF-&gt;fDirty) <br>    { <br>        if (lpXPSOF-&gt;libBuff != lpXPSOF-&gt;cbBuffMac) <br>        { <br>            hr = HrRewindStream(lpXPSOF, lpXPSOF-&gt;cbBuffMac-lpXPSOF-&gt;libBuff); <br> <br>            if (HR_FAILED(hr)) <br>                goto ret; <br>        } <br> <br>        lpXPSOF-&gt;libBuff = 0; <br>        lpXPSOF-&gt;cbBuffMac = XPSOF_BUFF_MAX; <br>    } <br> <br>    /* Determine the total vacancy of the buffer. */ <br> <br>    cbT = lpXPSOF-&gt;cbBuffMac - lpXPSOF-&gt;libBuff; <br> <br>    /* If the caller wants to Write more bytes than the current  */ <br>    /* vacancy of the buffer, then commit the current buffer and */ <br>    /* Write the callers data directly to the stream.  If the    */ <br>    /* buffer is not dirty, then the Commit call is a no-op.     */ <br> <br>    if (cbSize &gt; cbT) <br>    { <br>        hr = XPSOF_Commit(lpXPSOF, 0); <br> <br>        if (HR_FAILED(hr)) <br>            goto ret; <br> <br>        hr = lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Write(lpXPSOF-&gt;lpstrm, <br>                lpvData, cbSize, &amp;cbWritten); <br> <br>        goto ret; <br>    } <br> <br>    /* The callers data will fit in our current buffer.  Copy the */ <br>    /* data into the buffer, mark the buffer as dirty, and adjust */ <br>    /* the buffer offset.  Set cbWritten to cbSize and return.    */ <br> <br>    lpvWrite = (VOID HUGEP *)((LPBYTE)lpXPSOF-&gt;lpvBuff + lpXPSOF-&gt;libBuff); <br>    HMemCopy(lpvWrite, lpvData, cbSize); <br>    lpXPSOF-&gt;fDirty = TRUE; <br>    lpXPSOF-&gt;libBuff += cbSize; <br>    cbWritten = cbSize; <br> <br>ret: <br>    if (lpcbWritten) <br>        *lpcbWritten = cbWritten; <br> <br>    DebugTraceResult (XPSOF_Write(), hr); <br>    return hr; <br>} <br> <br> <br>/* <br> -  IStream::Seek <br> - <br> *  Purpose: <br> *      To move the file pointer in the stream. <br> */ <br> <br>STDMETHODIMP <br>XPSOF_Seek (LPXPSOF lpXPSOF, <br>    LARGE_INTEGER liMove, <br>    DWORD dwMode, <br>    ULARGE_INTEGER * lpliPos) <br>{ <br>    HRESULT hr = hrSuccess; <br> <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF)) || <br>        (lpliPos &amp;&amp; IsBadWritePtr (lpliPos, sizeof(ULARGE_INTEGER)))) <br>    { <br>        DebugTraceSc (XPSOF_Seek(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode (STG_E_INVALIDPARAMETER); <br>    } <br> <br>    Assert(lpXPSOF-&gt;cbBuffMac &gt;= lpXPSOF-&gt;libBuff); <br> <br>    /* If our buffer is dirty, then we've been writing into it and   */ <br>    /* we need to flush it.  Else, if it isn't dirty and our offset  */ <br>    /* and buffer size are not equal, then we've been reading and we */ <br>    /* need to rewind the underlying stream to match our position.   */ <br> <br>    if (lpXPSOF-&gt;fDirty) <br>    { <br>        hr = XPSOF_Commit(lpXPSOF, 0); <br> <br>        if (HR_FAILED(hr)) <br>            goto ret; <br>    } <br>    else <br>    { <br>        if ((dwMode == STREAM_SEEK_CUR) &amp;&amp; <br>            (lpXPSOF-&gt;libBuff != lpXPSOF-&gt;cbBuffMac)) <br>        { <br>            hr = HrRewindStream(lpXPSOF, lpXPSOF-&gt;cbBuffMac-lpXPSOF-&gt;libBuff); <br> <br>            if (HR_FAILED(hr)) <br>                goto ret; <br>        } <br> <br>        lpXPSOF-&gt;libBuff = 0; <br>        lpXPSOF-&gt;cbBuffMac = 0; <br>    } <br> <br>    /* Now, call the real streams Seek method. */ <br> <br>    hr = lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Seek(lpXPSOF-&gt;lpstrm, <br>            liMove, dwMode, lpliPos); <br> <br>ret: <br>    return hr; <br>} <br> <br> <br>/* <br> -  IStream::SetSize <br> - <br> *  Purpose: <br> *      To set a max size on the file. <br> */ <br> <br>STDMETHODIMP <br>XPSOF_SetSize (LPXPSOF lpXPSOF, ULARGE_INTEGER liSize) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF))) <br>    { <br>        DebugTraceSc (XPSOF_SetSize(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode (STG_E_INVALIDPARAMETER); <br>    } <br> <br>    return lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;SetSize(lpXPSOF-&gt;lpstrm, liSize); <br>} <br> <br> <br>/* <br> -  IStream::CopyTo <br> - <br> *  Purpose: <br> *      To copy data from one stream to another. <br> */ <br> <br>STDMETHODIMP <br>XPSOF_CopyTo (LPXPSOF lpXPSOF, <br>    LPSTREAM lpStrmDst, <br>    ULARGE_INTEGER cbCopy, <br>    ULARGE_INTEGER * lpcbRead, <br>    ULARGE_INTEGER * lpcbWritten) <br>{ <br>    HRESULT hr; <br> <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF)) || <br>        IsBadReadPtr (lpStrmDst, sizeof(LPVOID)) || <br>        IsBadWritePtr (lpcbRead, sizeof(ULARGE_INTEGER)) || <br>        IsBadWritePtr (lpcbWritten, sizeof(ULARGE_INTEGER))) <br>    { <br>        DebugTraceSc (XPSOF_CopyTo(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode(STG_E_INVALIDPARAMETER); <br>    } <br> <br>    Assert(lpXPSOF-&gt;cbBuffMac &gt;= lpXPSOF-&gt;libBuff); <br> <br>    /* If our buffer is dirty, then we've been writing into it and   */ <br>    /* we need to flush it.  Else, if it isn't dirty and our offset  */ <br>    /* and buffer size are not equal, then we've been reading and we */ <br>    /* need to rewind the underlying stream to match our position.   */ <br> <br>    if (lpXPSOF-&gt;fDirty) <br>    { <br>        hr = XPSOF_Commit(lpXPSOF, 0); <br> <br>        if (HR_FAILED(hr)) <br>            goto ret; <br>    } <br>    else <br>    { <br>        if (lpXPSOF-&gt;libBuff != lpXPSOF-&gt;cbBuffMac) <br>        { <br>            hr = HrRewindStream(lpXPSOF, lpXPSOF-&gt;cbBuffMac-lpXPSOF-&gt;libBuff); <br> <br>            if (HR_FAILED(hr)) <br>                goto ret; <br>        } <br> <br>        lpXPSOF-&gt;libBuff = 0; <br>        lpXPSOF-&gt;cbBuffMac = 0; <br>    } <br> <br>    /* Now, call the real streams CopyTo method. */ <br> <br>    hr = lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;CopyTo(lpXPSOF-&gt;lpstrm, lpStrmDst, <br>            cbCopy, lpcbRead, lpcbWritten); <br> <br>ret: <br>    return hr; <br>} <br> <br> <br>/* <br> -  IStream::Commit <br> - <br> *  Purpose: <br> *      To force a write to disk of any data that is buffered <br> *      by either this object or the operating system. <br> */ <br> <br>STDMETHODIMP <br>XPSOF_Commit (LPXPSOF lpXPSOF, ULONG ulFlags) <br>{ <br>    HRESULT hr; <br> <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF))) <br>    { <br>        DebugTraceSc (XPSOF_Commit(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode (STG_E_INVALIDPARAMETER); <br>    } <br> <br>    /* Flush my internal buffer if it is dirty. */ <br> <br>    if ((lpXPSOF-&gt;ulFlags &amp; XPSOF_WRITE) &amp;&amp; (lpXPSOF-&gt;fDirty)) <br>    { <br>        hr = lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Write(lpXPSOF-&gt;lpstrm, <br>                lpXPSOF-&gt;lpvBuff, lpXPSOF-&gt;libBuff, NULL); <br> <br>        if (HR_FAILED(hr)) <br>            goto ret; <br>    } <br> <br>    /* Call Commit on the underlying stream. */ <br> <br>    hr = lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Commit(lpXPSOF-&gt;lpstrm, ulFlags); <br> <br>    /* Mark my buffer as empty cal clean. */ <br> <br>    lpXPSOF-&gt;fDirty = FALSE; <br>    lpXPSOF-&gt;libBuff = 0; <br>    lpXPSOF-&gt;cbBuffMac = 0; <br> <br>ret: <br>    return hr; <br>} <br> <br> <br>/* <br> -  IStream::Stat <br> - <br> *  Purpose: <br> *      To retrieve information about the stream. <br> */ <br> <br>STDMETHODIMP <br>XPSOF_Stat (LPXPSOF lpXPSOF, STATSTG * lpStg, DWORD dwFlags) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF)) || <br>        IsBadWritePtr (lpStg, sizeof(STATSTG))) <br>    { <br>        DebugTraceSc (XPSOF_Stat(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode (STG_E_INVALIDPARAMETER); <br>    } <br> <br>    return lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Stat(lpXPSOF-&gt;lpstrm, lpStg, dwFlags); <br>} <br> <br> <br>/* <br> -  HrRewindStream <br> - <br> *  Purpose: <br> *      This gets called to back-up the file pointer when a Write operation <br> *      follows a Read operation.  This is necessary because the file pointer <br> *      is actually further ahead in the file than the buffered file pointer. <br> * <br> *  Parameters: <br> *      lpXPSOF             - Our wrapped stream-on-file object <br> *      ib                  - Number of bytes to rewind <br> * <br> *  Returns: <br> *      hr                  - Result of the underlying Seek() call <br> */ <br> <br>HRESULT HrRewindStream(LPXPSOF lpXPSOF, ULONG ib) <br>{ <br>    LARGE_INTEGER liRewind; <br> <br>    if (!ib) <br>        return hrSuccess; <br> <br>    liRewind.HighPart = 0xFFFFFFFF; <br>    liRewind.LowPart = -((LONG)ib); <br> <br>    return lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Seek(lpXPSOF-&gt;lpstrm, <br>            liRewind, STREAM_SEEK_CUR, NULL); <br>} <br> <br> <br>/* Unimplemented methods; call straight through to the underlying stream. */ <br> <br>STDMETHODIMP <br>XPSOF_Revert (LPXPSOF lpXPSOF) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF))) <br>    { <br>        DebugTraceSc (XPSOF_Revert(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode (STG_E_INVALIDPARAMETER); <br>    } <br> <br>    return lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Revert(lpXPSOF-&gt;lpstrm); <br>} <br> <br>STDMETHODIMP <br>XPSOF_LockRegion (LPXPSOF lpXPSOF, <br>    ULARGE_INTEGER uliOffset, <br>    ULARGE_INTEGER uliSize, <br>    DWORD dwLockType) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF))) <br>    { <br>        DebugTraceSc (XPSOF_LockRegion(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode (STG_E_INVALIDPARAMETER); <br>    } <br> <br>    return lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;LockRegion(lpXPSOF-&gt;lpstrm, <br>            uliOffset, uliSize, dwLockType); <br>} <br> <br>STDMETHODIMP <br>XPSOF_UnlockRegion (LPXPSOF lpXPSOF, <br>    ULARGE_INTEGER uliOffset, <br>    ULARGE_INTEGER uliSize, <br>    DWORD dwLockType) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF))) <br>    { <br>        DebugTraceSc (XPSOF_UnlockRegion(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode (STG_E_INVALIDPARAMETER); <br>    } <br> <br>    return lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;UnlockRegion(lpXPSOF-&gt;lpstrm, <br>            uliOffset, uliSize, dwLockType); <br>} <br> <br>STDMETHODIMP <br>XPSOF_Clone (LPXPSOF lpXPSOF, LPSTREAM * lppStm) <br>{ <br>    if (IsBadWritePtr (lpXPSOF, sizeof(XPSOF))) <br>    { <br>        DebugTraceSc (XPSOF_Clone(), STG_E_INVALIDPARAMETER); <br>        return ResultFromScode (STG_E_INVALIDPARAMETER); <br>    } <br> <br>    return lpXPSOF-&gt;lpstrm-&gt;lpVtbl-&gt;Clone(lpXPSOF-&gt;lpstrm, lppStm); <br>} <br> <br> <br>/* <br> -  HMemCopy <br> - <br> *  Purpose: <br> *      Same as memcpy but works with huge pointers. <br> */ <br> <br>VOID <br>HMemCopy(VOID HUGEP * lpvDst, VOID HUGEP * lpvSrc, ULONG cb) <br>{ <br>    while (cb--) <br>        *((BYTE HUGEP *)lpvDst)++ = *((BYTE HUGEP *)lpvSrc)++; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
