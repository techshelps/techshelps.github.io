<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPBASE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2143"></a>XPBASE.C</h2>
<pre><code>/* <br> -  X P B A S E . C <br> - <br> *  Purpose: <br> *      The sample transport provider illustrates the use of the MAPI <br> *      Transport Service Provider Interface and those parts of the <br> *      general SPI involved with the Provider Status, Notification, <br> *      and some other stuff. <br> * <br> *      This module contains the following SPI entry points: <br> * <br> *          XPProviderInit() <br> *          Shutdown() <br> *          TransportLogon() <br> *          AddressTypes() <br> *          RegisterOptions() <br> *          TransportLogoff() <br> *          TransportNotify() <br> *          ValidateState() <br> *          FlushQueues() <br> *          IUnknown methods for IXPProvider (XPP) &amp; IXPLogon (XPL) objects <br> * <br> *      Additional support functions found here: <br> * <br> *          FIsValidSession() <br> *          CleanupSession() <br> *          ScCheckLogonProps() <br> *          HrCheckSpoolerYield() <br> *          ScCopySessionProps() <br> *          ServiceEntry() <br> *          HrOpenSingleProvider() <br> *          ScMergeLogonProps() <br> * <br> *  NOTE: <br> *  We have a luxury which most providers don't share: our SPI operations <br> *  all occur on a single process context.  This means we don't have to <br> *  worry a lot about DLL context, etc. like other providers. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "xppch.h" <br>#include "xpresrc.h" <br> <br>/* On 32-bit, we want MB_SETFOREGROUND on MessageBoxes. */ <br> <br>#ifndef MB_SETFOREGROUND <br>#define MB_SETFOREGROUND 0 <br>#endif <br> <br>/* <br> *  No bitness in the name of this DLL.  MAPI will handle that. <br> */ <br> <br>#define szDLLName   "smpxp.dll" <br> <br>/* Property Tags of Profile/UI information for a transport session. */ <br> <br>/* NOTE!!! THE ORDERING OF THIS ARRAY MUST BE EXACTLY THE SAME AS THE <br>   ORDERING OF PROP ID'S IN SMPLXPT.H!!!! */ <br> <br>SizedSPropTagArray(MAX_LOGON_PROPERTIES, sptLogonArray) = <br>{ <br>    MAX_LOGON_PROPERTIES, <br>    { <br>        /* Properties stored in Profile */ <br>        PR_SAMPLE_DISPLAY_NAME, <br>        PR_SAMPLE_EMAIL_ADDR_TYPE, <br>        PR_SAMPLE_EMAIL_ADDRESS, <br>        PR_SAMPLE_INBOUND_DIR, <br>        PR_SAMPLE_OUTBOUND_DIR, <br>        PR_SAMPLE_FILENAME, <br>        PR_SAMPLE_DIRECTORY, <br>        PR_SAMPLE_FLAGS, <br>        PR_SAMPLE_LOGFILE, <br>        PR_SAMPLE_LOGHIGHWATER, <br>        PR_SAMPLE_LOGLOWWATER, <br> <br>        /* UI Temporary properties */ <br>        PR_TEMP_PEER_TO_PEER, <br>        PR_TEMP_UI_ALWAYS, <br>        PR_TEMP_LOG_EVENTS, <br>        PR_TEMP_SAVE_DATA, <br>        PR_TEMP_LOGHIGHWATER, <br>        PR_TEMP_LOGLOWWATER <br>    } <br>}; <br> <br> <br>/* MessageOption &amp; RecipientOption Default Property Value */ <br> <br>static SPropValue spvMsgOpt = {PR_SAMPLE_PER_MSG_DEFER, 0L, FALSE}; <br>static SPropValue spvRecipOpt = {PR_SAMPLE_PER_RECIP_DEFER, 0L, FALSE}; <br> <br>/* Wizard configuration items */ <br>static LPMAPIPROP lpmpWizard = NULL; <br>enum <br>{ <br>    ipDispName, <br>    ipEmailType, <br>    ipEmailAddress, <br>    ipInbox, <br>    ipOutbox, <br>    ipFilename, <br>    ipDirectory, <br>    ipFlags, <br>    ipLogFile, <br>    ipLogHigh, <br>    ipLogLow, <br>    cWizProps <br>}; <br>#define cchNameMax  40 <br>#define cchTypeMax  8 <br> <br>/* Virtual Table for the IXPProvider object */ <br> <br>XPP_Vtbl vtblXPP = <br>{ <br>    XPP_QueryInterface, <br>    XPP_AddRef, <br>    XPP_Release, <br>    XPP_Shutdown, <br>    XPP_TransportLogon, <br>}; <br> <br>/* Virtual Table for the IXPLogon object */ <br> <br>XPL_Vtbl vtblXPL = <br>{ <br>    XPL_QueryInterface, <br>    XPL_AddRef, <br>    XPL_Release, <br>    XPL_AddressTypes, <br>    XPL_RegisterOptions, <br>    XPL_TransportNotify, <br>    XPL_Idle, <br>    XPL_TransportLogoff, <br>    XPL_SubmitMessage, <br>    XPL_EndMessage, <br>    XPL_Poll, <br>    XPL_StartMessage, <br>    XPL_OpenStatusEntry, <br>    XPL_ValidateState, <br>    XPL_FlushQueues <br>}; <br> <br>/* Miscellaneous function prototypes. */ <br> <br>HRESULT HrDeleteDeferred(LPXPL lpxpl, LPSBinary lpsbinEID); <br>static void CleanupSession(LPXPL lpxpl); <br> <br>MSGSERVICEENTRY ServiceEntry; <br>WIZARDENTRY WizardEntry; <br>SERVICEWIZARDDLGPROC WizardWndProc; <br> <br>HRESULT HrOpenSingleProvider(LPPROVIDERADMIN, LPPROFSECT FAR *); <br>SCODE ScMergeLogonProps(ULONG, LPSPropValue, ULONG, LPSPropValue, <br>    LPALLOCATEBUFFER, LPALLOCATEMORE, LPSPropValue FAR *); <br> <br>/* <br> -  XPProviderInit <br> - <br> *  Purpose: <br> *      Called by the Spooler prior to initiating actual Transport operations. <br> *      Only needs to be called once, regardless of the number of sessions <br> *      which the Spooler might establish with this Transport provider. <br> * <br> *  Parameters: <br> *      hInstance           Instance of this library <br> *      lpMalloc            OLE2 PMALLOC memory allocator <br> *      lpAllocateBuffer    MAPIAllocateBuffer <br> *      lpAllocateMore      MAPIAllocateMore <br> *      lpFreeBuffer        MAPIFreeBuffer <br> *      ulFlags             Reserved for now. Should be zero. <br> *      ulSpoolerVer        MAPI version the Spooler is implemented to <br> *      lpulTransportVer    Transport puts its MAPI version here <br> *      lppXPProvider       Transport returns Transport Init Object here <br> * <br> *  Returns: <br> *      SUCCESS_SUCCESS     Transport thinks all is well. Transport's <br> *                          version of MAPI has been stored in <br> *                          *lpulTransportVer. Transport's Init Object <br> *                          address has been stored in *lppEntryPoints. <br> * <br> *      MAPI_E_VERSION      Transport doesn't like version of Spooler. <br> *                          Contents of lpulTransportVer and <br> *                          lppXPProvider are untouched by the Transport. <br> * <br> *      MAPI_E_CALL_FAILED  Transport already inited or session table <br> *                          non-empty. Contents of lpulTransportVer and <br> *                          lppXPProvider are untouched by the Transport. <br> * <br> *  Operation: <br> *      In the call, the Spooler will tell the Transport what version of MAPI <br> *      it normally expects to support. If the Transport knows that it cannot <br> *      handle this version, it should return an error on this call. If it <br> *      doesn't know, it should trust the Spooler to handle the problem. <br> * <br> *      The Transport puts the version of MAPI it expects to support back into <br> *      lpulTransportVer and the Spooler should Shutdown if it cannot or <br> *      doesn't want to handle this version. <br> * <br> *      Besides the information which the Spooler will use for its half of the <br> *      MAPI version handshake, the Transport will return a valid Init Object <br> *      address into the location pointed to by lppXPProvider. <br> */ <br> <br>STDINITMETHODIMP <br>XPProviderInit(HINSTANCE hInstance, <br>    LPMALLOC lpMalloc, <br>    LPALLOCATEBUFFER lpAllocateBuffer, <br>    LPALLOCATEMORE lpAllocateMore, <br>    LPFREEBUFFER lpFreeBuffer, <br>    ULONG ulFlags, <br>    ULONG ulSpoolerVer, <br>    ULONG * lpulTransportVer, <br>    LPXPPROVIDER * lppXPProvider) <br>{ <br>    SCODE sc = S_OK; <br>    LPXPP lpxpp; <br> <br>    /*  Test Spooler Version. As we are a MAPI 1.0 transport, we'll <br>        accept any MAPI version over 1.0 (and trust the Spooler to <br>        refuse to handle 1.0 if he's too far advanced!) <br>    */ <br> <br>    if (ulSpoolerVer &lt; CURRENT_SPI_VERSION) <br>    { <br>        sc = MAPI_E_VERSION; <br>        DebugTrace("Spooler version check failed.\n"); <br>        goto ret; <br>    } <br> <br>    /*  Allocate space for the XPP structure */ <br> <br>    sc = (*lpAllocateBuffer) (sizeof(XPP), (LPVOID *) &amp;lpxpp); <br> <br>    if (sc) <br>    { <br>        DebugTrace("XPProvider allocation failed.\n"); <br>        goto ret; <br>    } <br> <br>    /*  Fill in the data members and the jump table. */ <br> <br>    lpxpp-&gt;lpVtbl = &amp;vtblXPP; <br>    lpxpp-&gt;lcInit = 1; <br>    lpxpp-&gt;lpxppMyAddress = lpxpp; <br>    lpxpp-&gt;hInst = hInstance; <br>    lpxpp-&gt;XPSessionList = (LPXPL) NULL; <br>    lpxpp-&gt;fInited = TRUE; <br>    lpxpp-&gt;lpMalloc = lpMalloc; <br>    lpxpp-&gt;lpFreeBuffer = lpFreeBuffer; <br> <br>    /* We're keeping it, we need to AddRef it! */ <br> <br>    UlAddRef(lpMalloc); <br> <br>    /*  Initialize a critical section to be used while: <br>            1. Accessing the Status Object <br>            2. Doing session list management <br>            3. Initializing the logging sub-system <br>            4. Processing a TransportNotify call <br> <br>        These are areas where the potential for re-entrancy <br>        is high and we need to protect ourselves. <br>    */ <br> <br>    InitializeCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /*  Return version number and IXPProvider object to the Spooler. */ <br> <br>    *lpulTransportVer = CURRENT_SPI_VERSION; <br>    *lppXPProvider = (LPXPPROVIDER) lpxpp; <br> <br>ret: <br>    DebugTraceSc(XPProviderInit, sc); <br>    return ResultFromScode(sc); <br>} <br> <br> <br>/* <br> -  lpxpp-&gt;lpVtbl-&gt;Shutdown <br> - <br> *  Purpose: <br> *      Called by the Spooler when all operations on a Transport are complete. <br> *      Only needs to be called once, regardless of the number of sessions <br> *      which the Spooler might have established with this Transport provider. <br> * <br> *  Parameters: <br> *      lpulFlags           Contains flags passed from Spooler: <br> * <br> *                          DEINIT_NORMAL indicates a normal <br> *                          operation. All cleanup should proceed <br> *                          at whatever pace is required for <br> *                          completeness. <br> * <br> *                          DEINIT_HURRY indicates rapid shutdown. <br> *                          Anything that can be done very quickly <br> *                          should be done; time-consuming operations <br> *                          are to be avoided. <br> * <br> *                          In the absence of these flag bits, the <br> *                          Transport should assume DEINIT_NORMAL. <br> * <br> *  Returns: <br> *      SUCCESS_SUCCESS     Transport has done all cleanup. Go ahead <br> *                          and release it. <br> * <br> *      MAPI_E_CALL_FAILED  Transport hasn't been inited or has <br> *                          already been deinited. <br> * <br> *  Operation: <br> *      This call normally will happen if the Spooler doesn't like the <br> *      Transport version passed in from XPProviderInit; if the Spooler <br> *      attempts to log into the Transport and fails; and after a <br> *      TransportLogoff. <br> * <br> *      If there are any sessions active in this process, the Transport <br> *      should clean them up (propagating the DEINIT_HURRY down to <br> *      LOGOFF_HURRY in the TransportLogoff flags) before returning. <br> * <br> *      The Spooler guarantees non-reentrancy on this call. <br> */ <br> <br>STDMETHODIMP <br>XPP_Shutdown(LPXPP lpxpp, ULONG FAR * lpulFlags) <br>{ <br>    LPXPL lpxpl = NULL; <br>    ULONG ulFlags; <br>    HRESULT hResult = hrSuccess; <br> <br>    /*  Walk down the session list. Log off any active sessions. <br> <br>        NOTE: IT IS *REALLY* IMPORTANT THAT ANY WORK DONE TO CHANGE <br>        THE WAY THIS LIST IS WALKED OR RELINKED BY LOGOFF BE DONE IN <br>        SUCH A WAY THAT BOTH THIS CODE AND THE TRANSPORTLOGOFF CODE <br>        CONTINUE TO WORK CORRECTLY!! <br>    */ <br> <br>    /* Get the Critical Section */ <br> <br>    EnterCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    lpxpl = lpxpp-&gt;XPSessionList; <br>    ulFlags = (*lpulFlags &amp; DEINIT_HURRY) ? LOGOFF_HURRY : LOGOFF_NORMAL; <br> <br>    while (lpxpl) <br>    { <br>        LPXPL lpNext = lpxpl-&gt;lpNextSession; <br> <br>        hResult = XPL_TransportLogoff(lpxpl, ulFlags); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("Logging off session failed.\n"); <br> <br>            /* <br>             * A logoff failed. If we are in HURRY mode, we'll let it <br>             * go. Otherwise, we pass the error along and get out! <br>             */ <br> <br>            if (!(*lpulFlags &amp; DEINIT_HURRY)) <br>            { <br>                DebugTrace("Returning Logoff result to caller.\n"); <br> <br>                /* <br>                 * Relink the listhead so that everything has some <br>                 * degree of internal consistency. <br>                 */ <br> <br>                lpxpp-&gt;XPSessionList = lpxpl; <br>                goto ret; <br>            } <br> <br>            DebugTrace("DEINIT_HURRY set, deallocating session and proceeding.\n"); <br>            CleanupSession(lpxpl); <br>        } <br>        lpxpl-&gt;lpVtbl-&gt;Release(lpxpl); <br>        lpxpl = lpNext; <br>    } <br> <br>    /* Release the Critical Section */ <br> <br>    LeaveCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /* Delete critical section which XPProviderInit() initialized. */ <br> <br>    DeleteCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    lpxpp-&gt;XPSessionList = NULL; <br>    lpxpp-&gt;fInited = FALSE; <br> <br>    *lpulFlags = 0; <br> <br>ret: <br>    /* Turn off logging if active */ <br> <br>    DeInitTransportLog((*lpulFlags &amp; DEINIT_HURRY) ? LOG_DEINIT_HURRY : 0L); <br> <br>    DebugTraceResult(XPP_Shutdown, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  lpxpp-&gt;lpVtbl-&gt;TransportLogon <br> - <br> *  Purpose: <br> *      Called by the Spooler to establish a session with a Transport. <br> *      This call might be made many times, once for each session the Spooler <br> *      wants to establish with an external messaging system through this <br> *      Transport. These multiple sessions will usually be established on a <br> *      one-for-one basis with the number of identities which the current <br> *      profile has established for the given messaging system. <br> * <br> *  Parameters: <br> *      lpxpp               The parent XPProvider object who will <br> *                          own this new session. <br> * <br> *      lpMAPISup           A pointer to a MAPI Support Object which <br> *                          is uniquely associated with this session <br> *                          by the Spooler. Any MAPI Support calls <br> *                          associated with this session should be <br> *                          done using this Support Object. <br> * <br> *      ulUIParam           The hWnd who will become the parent of any <br> *                          UI we decide to put up (like a logon dialog). <br> * <br> *      lpszProfileName     Contains a display name associated with the <br> *                          current user's profile.  Expected to be <br> *                          used by the Transport primarily to make <br> *                          any UI easier for the user to decipher. <br> * <br> *      lpulFlags           (In) <br> * <br> *                          Flags passed from Spooler to Transport: <br> * <br> *                          LOGON_NO_DIALOG instructs the Transport <br> *                          not to put any UI up during this operation. <br> *                          If the operation cannot be completed <br> *                          without UI, an error should be returned. <br> * <br> *                          LOGON_NO_CONNECT is set by the Spooler <br> *                          when the transport connection is being <br> *                          made in order to do things like get <br> *                          per-message/per-recipient options; using <br> *                          preprocessor stuff, etc -- but to do so <br> *                          "offline". The Transport is not to connect <br> *                          to the outside world, and if there are <br> *                          insufficient credentials to allow the <br> *                          Transport to operate as if the user should <br> *                          be permitted access, the Transport may <br> *                          wish to fail without presenting UI. <br> * <br> *                          LOGON_NO_INBOUND is set by the Spooler <br> *                          to signal the Transport not to accept <br> *                          incoming mail on this session. The Spooler <br> *                          will ignore the NOTIFY_NEWMAIL flag on <br> *                          SpoolerNotify() and it will not Poll() <br> *                          the Transport on this session. It's OK <br> *                          to make external connections for reasons <br> *                          other than mail reception. The Spooler <br> *                          may TransportNotify() to enable inbound. <br> * <br> *                          LOGON_NO_OUTBOUND is set by the Spooler <br> *                          to signal the Transport that outgoing <br> *                          mail won't be sent right now on this <br> *                          session. The Spooler will ignore the <br> *                          NOTIFY_READYTOSEND flag on SpoolerNotify() <br> *                          and will not be calling SubmitMessage(). <br> *                          It's OK to make external connections for <br> *                          reasons other than mail transmission. The <br> *                          Spooler may TransportNotify() to signal <br> *                          the start of outbound operations. <br> *  Returns: <br> *      lpulFlags           (Out) <br> * <br> *                          Flags passed from Transport to Spooler: <br> * <br> *                          LOGON_SP_IDLE tells the Spooler to call <br> *                          the Idle() entry point with this logon <br> *                          handle as part of its idle processing. <br> *                          The transport may use this to check its <br> *                          underlying messaging system for incoming <br> *                          mail, to do special processing outside <br> *                          of the SPI, or maybe some kind of network <br> *                          link maintenance, for example. <br> * <br> *                          LOGON_SP_POLL instructs the Spooler to <br> *                          call the Transport at its Poll() entry <br> *                          point on a regular basis to see if any <br> *                          new mail is ready for import into the <br> *                          MAPI subsystem. <br> * <br> *                          LOGON_SP_RESOLVE instructs the Spooler <br> *                          and MAPI to ensure that all addresses in <br> *                          an outgoing message's recipient table are <br> *                          fully resolved before this transport is <br> *                          given the message. This could be used by <br> *                          a transport to make a best-guess routing <br> *                          from a recipient's system to allow a given <br> *                          recipient to include all other recipients <br> *                          of a message in a reply ("Reply-All"). <br> * <br> *      lppXPLogon          Contains a pointer to the Transport <br> *                          Logon object (an instance of IXPLogon) <br> *                          that is used to access the session we <br> *                          just created. <br> * <br> *      MAPI_E_UNCONFIGURED Something's wrong with credentials or <br> *                          other things needed for logon. We're <br> *                          not really saying what. <br> * <br> *  Operation: <br> *      The Spooler makes this call when it wants to establish a session with <br> *      the Transport provider. When called here, the Transport will need to <br> *      perform several actions: <br> * <br> *  1) Get credentials out of the profile. <br> * <br> *  2)  Determine if credentials are sufficient. Some providers may choose <br> *      to just send along what they have to the host and let validation <br> *      happen there; others will want to determine that credentials have <br> *      some validity before setting off breakin alarms on a mail host system. <br> * <br> *  3) If credentials are insufficient, return MAPI_E_UNCONFIGURED. <br> * <br> *  4) Validate credentials. This may involve establishing a connection to the <br> *     underlying messaging system and allowing it to determine that the <br> *     credentials are OK. <br> * <br> *  5) If credentials not OK, the Transport provider should return <br> *     MAPI_E_UNCONFIGURED.  This will reuqest that MAPI calls the ServiceEntry <br> *     point to obtain the missing configuration information. <br> * <br> *  6) Save credentials. The profile section made available to the Transport <br> *     Provider can be used to store this information if so indicated. <br> * <br> *      Transports that are less concerned about security may leave out any or <br> *      all of the above. <br> * <br> *  7) Build the logon object. <br> * <br> *  8) Construct a Status Table row and call ModifyStatusRow(). <br> * <br> *  9) Link the logon object into the list for the transport. <br> * <br> * 10) Start up logger if need be <br> * <br> * 11) Log completion of logon operation. <br> * <br> * <br> *  Note: <br> *      There are some parameters stored at the session level (in the <br> *      profile) that are more global in nature, such as the logging stuff <br> *      and peer-to-peer. The way we will resolve this is to interpret new <br> *      information in the light of old stuff, favoring the "on" state. So <br> *      a session that says "no logging" will in fact not be logged only if <br> *      not preceded by a session with logging on, and the session will be <br> *      logged as soon as a session that specifies logging comes online. The <br> *      inbound and outbound paths will be respected; the first logfile name <br> *      will rule.  A session that didn't want to be peer-to-peer could have <br> *      its way among lots of peer-to-peer transports by specifying a <br> *      different outbound path. <br> * <br> */ <br> <br>STDMETHODIMP <br>XPP_TransportLogon(LPXPP lpxpp, <br>    LPMAPISUP lpMAPISup, <br>    ULONG ulUIParam, <br>    LPTSTR lpszProfileName, <br>    ULONG * lpulFlags, <br>    LPMAPIERROR * lppMapiError, <br>    LPXPLOGON FAR * lppXPLogon) <br>{ <br>    LPSPropValue lpPropArray = NULL; <br>    LPSPropValue lpMyIDArray = NULL; <br>    LPVOID lpvT, lpvT2; <br>    ULONG ulCount = 0; <br>    ULONG ulT; <br>    SCODE sc = 0; <br>    HRESULT hResult = 0; <br>    LPXPL lpxpl = NULL; <br>    LPPROFSECT lpProfileObj = NULL; <br>    LPOPTIONDATA lpOptData = NULL; <br> <br>    LPALLOCATEBUFFER lpAllocBuffer; <br>    LPALLOCATEMORE lpAllocMore; <br>    LPFREEBUFFER lpFreeBuffer; <br> <br>    BOOL fNeedUI = FALSE; <br>    BOOL fInitialParamsOk = TRUE; <br> <br>    *lppMapiError = NULL; <br> <br>    if ( *lpulFlags &amp; MAPI_UNICODE ) <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ) ; <br> <br>    /*  Get the memory allocation routines we'll be needing. */ <br> <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;GetMemAllocRoutines(lpMAPISup, <br>        &amp;lpAllocBuffer, &amp;lpAllocMore, &amp;lpFreeBuffer); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("GetMemAllocRoutines failed in XP Logon.\n"); <br>        goto ret; <br>    } <br> <br>    /* Try to open our profile. */ <br> <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;OpenProfileSection(lpMAPISup, <br>        (LPMAPIUID) NULL, MAPI_MODIFY, &amp;lpProfileObj); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("OpenProfileSection failed in XP Logon.\n"); <br>        goto ret; <br>    } <br> <br>    /* Profile is open, get the properties out of it. */ <br> <br>    hResult = lpProfileObj-&gt;lpVtbl-&gt;GetProps(lpProfileObj, <br>        (LPSPropTagArray) &amp;sptLogonArray, 0, /* ansi */ <br>        &amp;ulCount, &amp;lpPropArray); <br> <br>    if (hResult) <br>    { <br>#ifdef DEBUG <br>        LPMAPIERROR lpMapiError = NULL; <br> <br>        DebugTrace("GetProps failed in XP Logon.\n"); <br> <br>        lpProfileObj-&gt;lpVtbl-&gt;GetLastError(lpProfileObj, hResult, <br>            0L, &amp;lpMapiError); <br> <br>        if ( lpMapiError &amp;&amp; lpMapiError-&gt;lpszError ) <br>        { <br>            DebugTrace(lpMapiError-&gt;lpszError); <br>            DebugTrace("\n"); <br> <br>            lpFreeBuffer((LPVOID) lpMapiError); <br>        } <br>#endif <br>        /* Couldn't read all of the properties. We'll recover <br>           from the error by just bringing up UI if allowed. */ <br> <br>        hResult = hrSuccess; <br>    } <br> <br>    /* Profile is open. Get all of our expected properties. */ <br> <br>    Assert(ulCount == MAX_LOGON_PROPERTIES); <br>    ulCount -= TEMP_LOGON_PROPERTIES; <br> <br>    Assert(ulCount &lt; MAX_LOGON_PROPERTIES); <br> <br>    /* Make sure that we have the properties we want. If not, signal the <br>       need for UI. <br> <br>       We could also check that network paths etc. exist at this point. */ <br> <br>    if (lpPropArray) <br>    { <br>        XPDLG       XPDialog; <br> <br>        fNeedUI = FALSE;        /* Default to saying we have what we need */ <br> <br>        for (ulT = 0; ulT &lt; ulCount; ulT++) <br>        { <br>            /* If any of the properties is PT_ERROR, we need to <br>               bring up UI. */ <br> <br>            if (PROP_TYPE(lpPropArray[ulT].ulPropTag) == PT_ERROR) <br>            { <br>                fNeedUI = TRUE; <br>                break; <br>            } <br>        } <br> <br>        /* The configuration checking assumes that the information came from <br>           a dialog box, so we have to look like a dialog box to use it. */ <br>        XPDialog.hInst = NULL; <br>        XPDialog.hwnd = (HWND) ulUIParam; <br>        XPDialog.lppPropArray = &amp;lpPropArray; <br>        XPDialog.lpPTArray = (LPSPropTagArray) &amp;sptLogonArray; <br>        XPDialog.AllocateBuffer = lpAllocBuffer; <br>        XPDialog.AllocateMore = lpAllocMore; <br>        XPDialog.FreeBuffer = lpFreeBuffer; <br>        XPDialog.lpMalloc = NULL; <br>        XPDialog.lpMAPISup = lpMAPISup; <br>        XPDialog.fLogon = TRUE; <br>        XPDialog.ulFlags = 0; <br> <br>        /* Do some simple validation of the Logon Props */ <br>        sc = ScCheckLogonProps(&amp;XPDialog, FALSE); <br>        if ((sc == MAPI_E_USER_CANCEL) || (sc == MAPI_E_UNCONFIGURED)) <br>            fNeedUI = TRUE; <br>    } <br>    else <br>        fNeedUI = TRUE;         /* No prop array means we need UI */ <br> <br>    /* Now we have a local flag that will tell us whether UI must be <br>       presented. We should consider it a "I require data to complete <br>       logon" state as well. At this point, act on the LOGON_NO_DIALOG <br>       flag and error out if we are not allowed to present UI but we <br>       have some reason for wanting it. */ <br> <br>    if (fNeedUI) <br>    { <br>        /* Fill in the logon UI structure */ <br>        hResult = ResultFromScode(MAPI_E_UNCONFIGURED); <br>        DebugTrace("Need UI, returning MAPI_E_UNCONFIGURED to get some.\n"); <br>        goto ret; <br>    } <br> <br>    /* Create the session structure and copy important data into it */ <br>    sc = lpAllocBuffer(sizeof(XPL), (LPVOID *) &amp;lpxpl); <br> <br>    if (sc) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("Allocating XPLogon object failed in XP Logon.\n"); <br>        goto ret; <br>    } <br> <br>    memset(lpxpl, 0, sizeof(XPL)); <br> <br>    lpxpl-&gt;lpVtbl = &amp;vtblXPL; <br>    lpxpl-&gt;lcInit = 1; <br> <br>    lpxpl-&gt;lpMySession = lpxpl; /* Used to validate structure */ <br>    lpxpl-&gt;lpxppParent = lpxpp; <br>    lpxpl-&gt;lpMAPISup = lpMAPISup;   /* Copy of our support object */ <br>    lpxpl-&gt;AllocateBuffer = lpAllocBuffer; <br>    lpxpl-&gt;AllocateMore = lpAllocMore; <br>    lpxpl-&gt;FreeBuffer = lpFreeBuffer; <br>    lpxpl-&gt;ulSessionFlags = *lpulFlags; /* Important session flags*/ <br> <br>    lpxpl-&gt;cLogonPropValues = ulCount;  /* Count of logon properties */ <br>    lpxpl-&gt;lpPropArray = lpPropArray;   /* Array of properties */ <br> <br>    lpxpl-&gt;lpMyIDArray = NULL;  /* Transport ID */ <br>    lpxpl-&gt;fRefSupport = FALSE; <br> <br>    /* Figure out what the initial status of the transport will be */ <br> <br>    if ((*lpulFlags &amp; LOGON_NO_CONNECT)) <br>    { <br>        lpxpl-&gt;ulTransportStatus = STATUS_OFFLINE; <br>    } <br>    else <br>    { <br>        lpxpl-&gt;ulTransportStatus = STATUS_AVAILABLE; <br> <br>        if (!(*lpulFlags &amp; LOGON_NO_INBOUND)) <br>            lpxpl-&gt;ulTransportStatus |= STATUS_INBOUND_ENABLED; <br> <br>        if (!(*lpulFlags &amp; LOGON_NO_OUTBOUND)) <br>            lpxpl-&gt;ulTransportStatus |= STATUS_OUTBOUND_ENABLED; <br>    } <br> <br>    /* Initialize Status object ResourceMethods.  FlushQueues <br>       and SettingsDialog are currently implemented */ <br> <br>    lpxpl-&gt;ulResourceMethods = STATUS_SETTINGS_DIALOG | STATUS_FLUSH_QUEUES; <br> <br>    /* Initialize message send/receive state */ <br> <br>    lpxpl-&gt;fFoundInMessage = FALSE; <br>    lpxpl-&gt;hInFindHandle = INVALID_HANDLE_VALUE; <br>    lpxpl-&gt;hOutFindHandle = INVALID_HANDLE_VALUE; <br> <br>    /* Allocate and initialize the Message &amp; Recipient OptionData struct */ <br> <br>    sc = lpAllocBuffer(2 * sizeof(OPTIONDATA), (LPVOID *) &amp;lpOptData); <br> <br>    if (sc) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("Allocating OPTIONDATA failed in XP Logon.\n"); <br>        goto ret; <br>    } <br> <br>    /* Option Data is registered by Address Type.  In the SettingsDialog() <br>       call on the Status object we force the email address type field to <br>       be read-only.  This ensures that this OptionData remains valid for <br>       the duration of this session. <br> <br>       NOTE:    The ulOrdinal must match the value assigned in the .DEF file. <br>                If this value changes, it must be changed here and in the <br>                .DEF file to the same value! */ <br> <br>    lpOptData[0].ulFlags = OPTION_TYPE_MESSAGE; <br>    lpOptData[0].lpRecipGUID = NULL; <br>    lpOptData[0].lpszAdrType = ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ; <br>    lpOptData[0].lpszDLLName = szDLLName; <br>    lpOptData[0].ulOrdinal = 3; <br>    lpOptData[0].cbOptionsData = 0; <br>    lpOptData[0].lpbOptionsData = NULL; <br>    lpOptData[0].cOptionsProps = 1; <br>    lpOptData[0].lpOptionsProps = &amp;spvMsgOpt; <br> <br>    lpOptData[1].ulFlags = OPTION_TYPE_RECIPIENT; <br>    lpOptData[1].lpRecipGUID = NULL; <br>    lpOptData[1].lpszAdrType = ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ; <br>    lpOptData[1].lpszDLLName = szDLLName; <br>    lpOptData[1].ulOrdinal = 3; <br>    lpOptData[1].cbOptionsData = 0; <br>    lpOptData[1].lpbOptionsData = NULL; <br>    lpOptData[1].cOptionsProps = 1; <br>    lpOptData[1].lpOptionsProps = &amp;spvRecipOpt; <br> <br>    lpxpl-&gt;cOptData = 2; <br>    lpxpl-&gt;lpOptData = lpOptData; <br>    lpOptData = NULL; <br> <br>    /* Allocate initial property array for transport ID. */ <br> <br>    sc = lpAllocBuffer(sizeof(SPropValue) * NUM_SENDER_PROPS, <br>            (LPVOID *) &amp;lpMyIDArray); <br> <br>    if (sc) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("Allocating Sender ID array failed in XP Logon.\n"); <br>        goto ret; <br>    } <br> <br>    /* Zero the memory and hook it into the logon object now.  That <br>       way, if we get a failure between here and ret: then this <br>       memory will be freed in CleanupSession(). */ <br> <br>    memset(lpMyIDArray, 0, sizeof(SPropValue) * NUM_SENDER_PROPS); <br>    lpxpl-&gt;lpMyIDArray = lpMyIDArray; </code></pre>
<p>
</p>
<pre><code><br>    /* Create the One-Off directly into the property value structure. */ <br> <br>    lpMyIDArray[0].ulPropTag = PR_SENDER_ENTRYID; <br> <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;CreateOneOff(lpMAPISup, <br>        ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpPropArray).Value.LPSZ, <br>        ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ, <br>        ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ, <br>        fMapiUnicode, <br>        &amp;lpMyIDArray[0].Value.bin.cb, <br>        (LPENTRYID *) &amp;lpMyIDArray[0].Value.bin.lpb); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("CreateOneOff failed in XP Logon.\n"); <br>        lpMyIDArray[0].Value.bin.lpb = NULL; <br>        goto ret; <br>    } <br> <br>    /* Create the PR_SENDER_NAME property value. */ <br> <br>    lpMyIDArray[1].ulPropTag = PR_SENDER_NAME; <br>    lpvT2 = ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpPropArray).Value.LPSZ; <br>    ulT = (lstrlen((LPCTSTR) lpvT2) + 1) * sizeof(TCHAR); <br> <br>    sc = lpAllocMore(ulT, (LPVOID) lpMyIDArray, &amp;lpvT); <br> <br>    if (sc) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("Allocating user DisplayName failed in XP Logon.\n"); <br>        goto ret; <br>    } <br> <br>    lstrcpy((LPTSTR) lpvT, (LPCTSTR) lpvT2); <br>    lpMyIDArray[1].Value.LPSZ = (LPTSTR) lpvT; <br> <br>    /* Create the PR_SENDER_SEARCH_KEY value. */ <br> <br>    lpMyIDArray[2].ulPropTag = PR_SENDER_SEARCH_KEY; <br> <br>    /* Size of property = type plus colon plus address plus null. */ <br> <br>    ulT = 2 + lstrlen(ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ) + <br>          lstrlen(ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ); <br>    ulT *= sizeof(TCHAR); <br> <br>    sc = lpAllocMore(ulT, (LPVOID) lpMyIDArray, &amp;lpvT); <br> <br>    if (sc) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("Allocating SearchKey failed in XP Logon.\n"); <br>        goto ret; <br>    } <br> <br>    /* PR_SENDER_SEARCH_KEY is "TYPE:ADDRESS" folded to uppercase. */ <br> <br>    wsprintf((LPTSTR) lpvT, TEXT("%s:%s"), <br>            ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ, <br>            ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpPropArray).Value.LPSZ); <br> <br>    CharUpperBuff((LPTSTR) lpvT, (UINT) ulT-sizeof(TCHAR)); <br>    lpMyIDArray[2].Value.bin.cb = ulT; <br>    lpMyIDArray[2].Value.bin.lpb = lpvT; <br> <br>    /* Register the preprocessor */ <br> <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;RegisterPreprocessor (lpMAPISup, NULL, <br>        ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ, <br>#ifdef  WIN16 <br>        "SMPXP.DLL", <br>#else <br>        "SMPXP32.DLL", <br>#endif <br>        "PreprocessMessage", "RemovePreprocessInfo", 0L); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("RegisterPreprocessor failed in XP Logon.\n"); <br>        goto ret; <br>    } <br> <br>    /* Get the Critical Section */ <br> <br>    EnterCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /* Build the status row and register it */ <br> <br>    hResult = HrBuildTransportStatus(lpxpl, 0L); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("HrBuildTransportStatus failed in XP Logon.\n"); <br>        LeaveCriticalSection(&amp;lpxpp-&gt;csTransport); <br>        goto ret; <br>    } <br> <br>    /* Link the session structure into the list. */ <br> <br>    lpxpl-&gt;lpNextSession = lpxpp-&gt;XPSessionList; <br>    lpxpp-&gt;XPSessionList = lpxpl; <br> <br>    /* AddRef() the support object. */ <br> <br>    lpMAPISup-&gt;lpVtbl-&gt;AddRef(lpMAPISup); <br>    lpxpl-&gt;fRefSupport = TRUE; <br> <br>    /* Release the Critical Section. */ <br> <br>    LeaveCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /* Start up logfile stuff if this session indicates it. */ <br> <br>    InitTransportLog(lpxpl, 0L); <br> <br>    /* OK, we were successful. Set the return values. */ <br> <br>    *lppXPLogon = (LPXPLOGON) lpxpl; <br> <br>    /* No flags necessary if no connect ... */ <br> <br>    if (lpxpl-&gt;ulSessionFlags &amp; LOGON_NO_CONNECT) <br>    { <br>        *lpulFlags = 0; <br>    } <br>    else <br>    { <br>        /* Idle and resolve for transmit; Poll for receive */ <br> <br>        *lpulFlags = LOGON_SP_IDLE | LOGON_SP_RESOLVE | LOGON_SP_POLL; <br>    } <br> <br>ret: <br>    UlRelease(lpProfileObj); <br> <br>    /*  Make sure we have an hResult. <br> <br>        Assumptions: <br>            if hResult is set, it reflects the last error. <br>            if sc is set and hResult is not, we want hResult to be set. <br>    */ <br> <br>    if (hResult) <br>    { <br>        /* Error. Get rid of anything already on the session object. */ <br>        /* If no session object, free data that could have been      */ <br>        /* allocated before session object creation.                 */ <br> <br>        if (lpxpl) <br>        { <br>            CleanupSession(lpxpl); <br>            lpxpl-&gt;lpVtbl-&gt;Release(lpxpl); <br>        } <br>        else lpFreeBuffer (lpPropArray); <br>    } <br> <br>    DebugTraceResult(XPP_TransportLogon, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  lpxpl-&gt;lpVtbl-&gt;AddressTypes <br> - <br> *  Purpose: <br> *      Called by the Spooler to find out what recipients it should expect <br> *      this transport to handle. <br> * <br> *  Parameters: <br> *      ulFlags             Ignored for now. <br> *      lpcAdrType          Pointer: where to store number of address types <br> *      lpppAdrTypeArray    Pointer: where to store list of address types <br> *      lpcMAPIUID          Pointer: where to store number of UID's <br> *      lpppMAPIUIDArray    Pointer: where to store list of MAPI UID's <br> * <br> *  Returns: <br> *      (HRESULT)           Errors encountered if any. <br> * <br> *  Operation: <br> *      Returns the Address Type entered at Logon time in the address type <br> *      array. Makes no use of the UID array. <br> */ <br> <br>STDMETHODIMP <br>XPL_AddressTypes(LPXPL lpxpl, <br>    ULONG * lpulFlags, <br>    ULONG * lpcAdrType, LPTSTR * *lpppAdrTypeArray, <br>    ULONG * lpcMAPIUID, LPMAPIUID * *lpppMAPIUIDArray) <br>{ <br>    ULONG cb; <br>    SCODE sc; <br>    LPTSTR lpsz; <br> <br>    /* We are returning an array with exactly one value.  We first need <br>       to AllocateMore a buffer (that is linked to the lpxpl object) and <br>       copy our Email Address Type into there.  We then return the address <br>       of this copy of our AddressType.  */ <br> <br>    if ( *lpulFlags &amp; ~(MAPI_UNICODE) ) <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br> <br>    if ( *lpulFlags &amp; MAPI_UNICODE ) <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ) ; <br> <br>    *lpcAdrType = 1; <br> <br>    lpsz = ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpxpl-&gt;lpPropArray).Value.LPSZ; <br> <br>    cb = (lstrlen(lpsz) + 1) * sizeof(TCHAR); <br> <br>    sc = lpxpl-&gt;AllocateMore(cb, (LPVOID) lpxpl, (LPVOID *) &amp;lpxpl-&gt;lpszAdrType); <br> <br>    if (FAILED(sc)) <br>    { <br>        DebugTrace("AllocateMore in XPL_AddressType failed!\n"); <br>        return ResultFromScode(sc); <br>    } <br> <br>    lstrcpy(lpxpl-&gt;lpszAdrType, lpsz); <br> <br>    *lpppAdrTypeArray = &amp;(lpxpl-&gt;lpszAdrType); <br> <br>    /* Routing by UID has no particular meaning for this transport. */ <br> <br>    *lpcMAPIUID = 0; <br>    *lpppMAPIUIDArray = NULL; <br> <br>    return hrSuccess; <br>} <br> <br> <br>/* <br> -  lpxpl-&gt;lpVtbl-&gt;RegisterOptions <br> - <br> *  Purpose: <br> *      Called by the Spooler to find out what per-message or per-recipient <br> *      options this transport might wish supported. <br> * <br> *  Parameters: <br> *      lpulFlags           Indicates whether strings are UNICODE or not. <br> *      lpcOptions          Pointer: where to store number of address <br> *                          types for which options are being requested <br> *      lppOptions          Pointer: where to store a list of display <br> *                          names associated with each address type <br> * <br> *  Returns: <br> *      (HRESULT)           Errors encountered if any. <br> */ <br> <br>STDMETHODIMP <br>XPL_RegisterOptions(LPXPL lpxpl, <br>    ULONG * lpulFlags, <br>    ULONG * lpcOptions, <br>    LPOPTIONDATA * lppOptions) <br>{ <br>    /* Just give them what we have in our XPLogon object.       */ <br>    /* These options were initialized at TransportLogon() time. */ <br> <br>    if ( *lpulFlags &amp; ~(MAPI_UNICODE) ) <br>        return ResultFromScode( MAPI_E_UNKNOWN_FLAGS ); <br> <br>    if ( *lpulFlags &amp; MAPI_UNICODE ) <br>        return ResultFromScode( MAPI_E_BAD_CHARWIDTH ) ; <br> <br>    *lpcOptions = lpxpl-&gt;cOptData; <br>    *lppOptions = lpxpl-&gt;lpOptData; <br> <br>    return 0; <br>} <br> <br> <br>/* <br> -  lpxpl-&gt;lpVtbl-&gt;TransportLogoff <br> - <br> *  Purpose: <br> *      Called by the Spooler to log off a particular Transport session. <br> * <br> *  Parameters: <br> *      ulFlags             May contain LOGOFF_HURRY, which tells <br> *                          the transport to close this session <br> *                          as quickly as possible. <br> * <br> *  Returns: <br> *      (HRESULT)           Errors encountered if any. <br> * <br> *  Operation: <br> *      Find the session. Tell MAPI the session's going away, unlink it from <br> *      the list, close open handles and deallocate session memory. <br> */ <br> <br>STDMETHODIMP <br>XPL_TransportLogoff(LPXPL lpxpl, ULONG ulFlags) <br>{ <br>    SCODE sc = S_OK; <br>    LPXPL lpxplCurr; <br>    LPXPL lpxplPrev = NULL; <br>    LPXPP lpxpp = lpxpl-&gt;lpxppParent; <br> <br>    /* Get the critical section */ <br> <br>    EnterCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /* Find the session in the list. */ <br> <br>    lpxplCurr = lpxpp-&gt;XPSessionList; <br> <br>    while (lpxplCurr) <br>    { <br>        if (lpxpl == lpxplCurr) <br>        { <br>            /* Unlink the session from the list. */ <br> <br>            if (lpxplPrev == NULL) <br>                lpxpp-&gt;XPSessionList = lpxpl-&gt;lpNextSession; <br>            else <br>                lpxplPrev-&gt;lpNextSession = lpxpl-&gt;lpNextSession; <br> <br>            break; <br>        } <br> <br>        lpxplPrev = lpxplCurr; <br>        lpxplCurr = lpxplCurr-&gt;lpNextSession; <br>    } <br> <br>    /* Release the critical section */ <br> <br>    LeaveCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /* lpxplCurr must be non-NULL if we found the session. */ <br> <br>    if (!lpxplCurr) <br>    { <br>        sc = MAPI_E_INVALID_PARAMETER; <br>        goto ret; <br>    } <br> <br>    /* Clean up the stuff inside the session structure. This may <br>       cause the XPP object to be released. */ <br> <br>    CleanupSession(lpxpl); <br> <br>ret: <br>    DebugTraceSc(TransportLogoff, sc); <br>    return ResultFromScode(sc); <br>} <br> <br> <br>/* <br> -  lpxpl-&gt;lpVtbl-&gt;TransportNotify <br> - <br> *  Purpose: <br> *      Called by the Spooler to call some event to the Transport's attention. <br> * <br> *  Parameters: <br> *      lpulFlags           Flags passed bidirectionally. <br> *                          This transport pays attention to the <br> *                          (BEGIN/END/FLUSH)(INBOUND/OUTBOUND) <br> *                          flags and ignores the others. <br> *      lppvData            Data passed bidirectionally. Not <br> *                          used by this transport. <br> * <br> *  Returns: <br> *      (HRESULT)           Errors encountered if any. <br> * <br> *  Operation: <br> *      If the flag has any bearing on inbound/outbound startup/shutdown, <br> *      then the appropriate change is made to the transport status in the <br> *      XPLogon object and the HrUpdateTransportStatus routine is called to <br> *      ModifyStatusRow() the change. <br> */ <br> <br>STDMETHODIMP <br>XPL_TransportNotify(LPXPL lpxpl, <br>    ULONG * lpulFlags, <br>    LPVOID * lppvData) <br>{ <br>    HRESULT hResult = hrSuccess; <br>    LPXPP lpxpp = lpxpl-&gt;lpxppParent; <br> <br>#define TRANSPORT_NOTIFY_FLAGS  (NOTIFY_BEGIN_INBOUND       | \ <br>                                NOTIFY_END_INBOUND          | \ <br>                                NOTIFY_BEGIN_INBOUND_FLUSH  | \ <br>                                NOTIFY_END_INBOUND_FLUSH    | \ <br>                                NOTIFY_BEGIN_OUTBOUND       | \ <br>                                NOTIFY_END_OUTBOUND         | \ <br>                                NOTIFY_BEGIN_OUTBOUND_FLUSH | \ <br>                                NOTIFY_END_OUTBOUND_FLUSH   | \ <br>                                NOTIFY_CANCEL_MESSAGE       | \ <br>                                NOTIFY_ABORT_DEFERRED) <br> <br>    /* Validate we were passed a legal flag. */ <br> <br>    Assert(*lpulFlags &amp; TRANSPORT_NOTIFY_FLAGS); <br> <br>    /* Make sure we have a good session. */ <br> <br>    if (!FIsValidSession(lpxpl)) <br>    { <br>        hResult = ResultFromScode(E_INVALIDARG); <br>        DebugTrace("FIsValidSession  failed in TransportNotify.\n"); <br>        goto ret; <br>    } <br> <br>    /* Get the Critical Section */ <br> <br>    EnterCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /* Set appropriate status flags and re-register status row */ <br> <br>    if (*lpulFlags &amp; NOTIFY_BEGIN_INBOUND) <br>    { <br>        DebugTrace("NOTIFY_BEGIN_INBOUND received and handled\n"); <br>        lpxpl-&gt;ulTransportStatus |= STATUS_INBOUND_ENABLED; <br>    } <br> <br>    if (*lpulFlags &amp; NOTIFY_END_INBOUND) <br>    { <br>        DebugTrace("NOTIFY_END_INBOUND received and handled\n"); <br>        lpxpl-&gt;ulTransportStatus &amp;= ~STATUS_INBOUND_ENABLED; <br>    } <br> <br>    if (*lpulFlags &amp; NOTIFY_END_INBOUND_FLUSH) <br>    { <br>        DebugTrace("NOTIFY_END_INBOUND_FLUSH received and handled\n"); <br>        lpxpl-&gt;ulTransportStatus &amp;= ~STATUS_INBOUND_FLUSH; <br>    } <br> <br>    if (*lpulFlags &amp; NOTIFY_BEGIN_OUTBOUND) <br>    { <br>        DebugTrace("NOTIFY_BEGIN_OUTBOUND received and handled\n"); <br>        lpxpl-&gt;ulTransportStatus |= STATUS_OUTBOUND_ENABLED; <br>    } <br> <br>    if (*lpulFlags &amp; NOTIFY_END_OUTBOUND) <br>    { <br>        DebugTrace("NOTIFY_END_OUTBOUND received and handled\n"); <br>        lpxpl-&gt;ulTransportStatus &amp;= ~STATUS_OUTBOUND_ENABLED; <br>    } <br> <br>    if (*lpulFlags &amp; NOTIFY_END_OUTBOUND_FLUSH) <br>    { <br>        DebugTrace("NOTIFY_END_OUTBOUND_FLUSH received and handled\n"); <br>        lpxpl-&gt;ulTransportStatus &amp;= ~STATUS_OUTBOUND_FLUSH; <br>    } <br> <br>    if (*lpulFlags &amp; NOTIFY_ABORT_DEFERRED) <br>    { <br>        DebugTrace("NOTIFY_ABORT_DEFERRED received and handled\n"); <br> <br>        hResult = HrDeleteDeferred(lpxpl, (LPSBinary)*lppvData); <br>    } <br> <br>    /* We're just going to ignore NOTIFY_CANCEL_MESSAGE for now. */ <br> <br>    if (*lpulFlags &amp; NOTIFY_CANCEL_MESSAGE) <br>    { <br>        DebugTrace("NOTIFY_CANCEL_MESSAGE received and ignored\n"); <br>    } <br> <br>    HrUpdateTransportStatus(lpxpl, 0L); <br> <br>    /* Release the critical section. */ <br> <br>    LeaveCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>ret: <br> <br>    DebugTraceResult(XPL_TransportNotify, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  XPL_ValidateState <br> - <br> *  Purpose: <br> *      Logon object method used by Spooler if ValidateState is called on <br> *      the spooler status object. <br> * <br> *  Parameters: <br> *      lpxpl               This pointer for logon object <br> *      ulUIParam           Window handle <br> *      ulFlags <br> * <br> *  Returns: <br> *      (HRESULT)           E_INVALIDARG if object doesn't <br> *                          look like a XPL; MAPI_E_NO_SUPPORT <br> *                          otherwise. <br> * <br> *  Operation: <br> *      Compare the PR_ADDRTYPE found in the profile to the one I am <br> *      currently using.  If it has changed, then SpoolerNotify() to <br> *      ask to be reloaded so MAPI will call AddressTypes() and <br> *      RegisterOptions() on us again! <br> * <br> *  Note: We could check all the properties in our profile and be a <br> *        better implementation of this call.  But for now, AddrType <br> *        is the most important property to check. <br> */ <br> <br>STDMETHODIMP <br>XPL_ValidateState(LPXPL lpxpl, <br>    ULONG ulUIParam, <br>    ULONG ulFlags) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hResult; <br>    LPPROFSECT lpProf = NULL; <br>    LPSPropValue lpspvAddrType = NULL; <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    LPSPropValue lpPropArray = NULL; <br>    LPTSTR lpszAddrType = NULL; <br> <br>    /*  If it doesn't seem to be an object or refcount is zero, return zero */ <br> <br>    if (IsBadReadPtr(lpxpl, sizeof(XPL)) || <br>        lpxpl-&gt;lcInit == 0 || <br>        lpxpl-&gt;lpMySession != lpxpl) <br>    { <br>        DebugTraceSc(XPL_ValidateState, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    if (ulFlags &amp; ~SUPPRESS_UI) <br>    { <br>        DebugTraceSc(XPL_ValidateState, MAPI_E_UNKNOWN_FLAGS); <br>        return ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br>    } <br> <br>    sc = ScCopySessionProps(lpxpl, &amp;lpPropArray, NULL); <br> <br>    if (FAILED(sc)) <br>    { <br>        hResult = ResultFromScode(sc); <br>        DebugTrace("ScCopySessionProps failed in ValidateState.\n"); <br>        goto ret; <br>    } <br> <br>    lpszAddrType = ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpPropArray).Value.LPSZ; <br> <br>    /* Try to open our profile. */ <br> <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;OpenProfileSection(lpMAPISup, <br>        (LPMAPIUID) NULL, MAPI_MODIFY, &amp;lpProf); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("OpenProfileSection  failed in ValidateState.\n"); <br>        goto ret; <br>    } <br> <br>    hResult = HrGetOneProp((LPMAPIPROP)lpProf, <br>            PR_SAMPLE_EMAIL_ADDR_TYPE, &amp;lpspvAddrType); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("HrGetOneProp failed in ValidateState.\n"); <br>        goto ret; <br>    } <br> <br>    /* Now, compare what I think my AddrType is to that in the profile. <br>       If they are different, tell the spooler I'd like to be reloaded. */ <br> <br>    if (lpspvAddrType-&gt;ulPropTag == PR_SAMPLE_EMAIL_ADDR_TYPE) <br>    { <br>        if (lstrcmp(lpszAddrType, lpspvAddrType-&gt;Value.LPSZ)) <br>        { <br>            hResult = lpMAPISup-&gt;lpVtbl-&gt;SpoolerNotify(lpMAPISup, <br>                NOTIFY_CONFIG_CHANGE, NULL); <br> <br>            if (HR_FAILED(hResult)) <br>            { <br>                DebugTrace("SpoolerNotify failed  in ValidateState.\n"); <br>                goto ret; <br>            } <br>        } <br>    } <br> <br>    hResult = hrSuccess; <br> <br>ret: <br>    UlRelease(lpProf); <br> <br>    lpxpl-&gt;FreeBuffer(lpPropArray); <br>    lpxpl-&gt;FreeBuffer(lpspvAddrType); <br> <br>    DebugTraceResult(XPL_ValidateState, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  XPL_FlushQueues <br> - <br> *  Purpose: <br> *      Logon object method used by Spooler if FlushQueues is called on <br> *      the spooler status object. <br> * <br> *  Parameters: <br> *      lpxpl               This pointer for logon object <br> *      ulUIParam           Window handle <br> *      cbTargetTransport   Count of bytes in Entryid. Zero. <br> *      lpTargetTransport   Entryid of transport. NULL. <br> *      ulFlags <br> * <br> *  Returns: <br> *      (HRESULT)           E_INVALIDARG if object doesn't <br> *                          look like a XPL; MAPI_E_NO_SUPPORT <br> *                          otherwise. <br> * <br> *  Operation: <br> *      Validate the object pointer. Return MAPI_E_NO_SUPPORT. <br> */ <br> <br>STDMETHODIMP <br>XPL_FlushQueues(LPXPL lpxpl, <br>    ULONG ulUIParam, <br>    ULONG cbTargetTransport, <br>    LPENTRYID lpTargetTransport, <br>    ULONG ulFlags) <br>{ <br>    HRESULT hResult; <br> <br>    /*  Validate the object */ <br> <br>    /*  If it doesn't seem to be an object or refcount is zero, return zero */ <br> <br>    if (IsBadReadPtr(lpxpl, sizeof(XPL)) || <br>        lpxpl-&gt;lcInit == 0 || <br>        lpxpl-&gt;lpMySession != lpxpl) <br>    { <br>        DebugTraceSc(XPL_FlushQueues, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /*  There is nothing special the sample transport <br>        needs to do before signaling its readiness for <br>        flushing */ <br> <br>    /*  Update our status row to inform the spooler <br>        that we are ready for flushing */ <br> <br>    if (ulFlags &amp; FLUSH_UPLOAD) <br>        lpxpl-&gt;ulTransportStatus |= STATUS_OUTBOUND_FLUSH; <br>    if (ulFlags &amp; FLUSH_DOWNLOAD) <br>        lpxpl-&gt;ulTransportStatus |= STATUS_INBOUND_FLUSH; <br> <br>    hResult = HrUpdateTransportStatus(lpxpl, 0L); <br> <br>    DebugTraceResult(XPL_FlushQueues, hResult); <br>    return hResult; <br>} <br> <br> <br>/* <br> -  FIsValidSession <br> - <br> *  Purpose: <br> *      Called from several places in the Transport to verify a session. <br> * <br> *  Parameters: <br> *      lpxpl               handle which is to be confirmed <br> * <br> *  Returns: <br> *      (BOOL)              TRUE if a valid session, FALSE if not. <br> * <br> *  Operation: <br> *      Get the critical section, look for lpxpl in the session list, <br> *      release the critical section, return boolean result. <br> */ <br> <br>BOOL <br>FIsValidSession(LPXPL lpxpl) <br>{ <br>    LPXPL lpxplT; <br>    LPXPP lpxpp; <br>    BOOL fIsValid = FALSE; <br> <br>    /*  First make sure that it can possibly be a session; then <br>        Take advantage of the internal consistency check ... does <br>        it point to itself? then validate the parent XPP. */ <br> <br>    if ((IsBadWritePtr(lpxpl, sizeof(XPL))) || <br>        (lpxpl-&gt;lpMySession != lpxpl) || <br>        (IsBadWritePtr(lpxpl-&gt;lpxppParent, sizeof(XPP)))) <br>        return FALSE; <br> <br>    /*  Maybe it's a session ... see if it's in the list. <br>        Lock out session data structure during the check. */ <br> <br>    lpxpp = lpxpl-&gt;lpxppParent; <br>    EnterCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    /*  Look in the session list for the session */ <br> <br>    lpxplT = lpxpp-&gt;XPSessionList; <br> <br>    while (lpxplT) <br>    { <br>        if (lpxplT == lpxpl) <br>        { <br>            fIsValid = TRUE; <br>            break; <br>        } <br>        lpxplT = lpxplT-&gt;lpNextSession; <br>    } <br> <br>    /*  Release the critical section and return the result. */ <br> <br>    LeaveCriticalSection(&amp;lpxpp-&gt;csTransport); <br> <br>    return fIsValid; <br>} <br> <br> <br>/* <br> -  CleanupSession <br> - <br> *  Purpose: <br> *      Called from TransportLogoff() and error cases of TransportLogon() <br> *      to cleanup session data. <br> * <br> *  Parameters: <br> *      lpxpl           handle which is to be confirmed <br> * <br> *  Returns: <br> *      none. <br> * <br> *  Operation: <br> *      Close any open search handles, deallocate associated structures. <br> *      We assume that if we need the critical section, we already have it. <br> */ <br> <br>static void <br>CleanupSession(LPXPL lpxpl) <br>{ <br>    LPMAPISUP lpMAPISup = lpxpl-&gt;lpMAPISup; <br>    BOOL fRefSupport = lpxpl-&gt;fRefSupport; <br> <br>    /* Get rid of any open handle hanging around from Poll() or <br>    StartMessage() */ <br> <br>    if (lpxpl-&gt;hInFindHandle != INVALID_HANDLE_VALUE) <br>        CloseHandle(lpxpl-&gt;hInFindHandle); <br> <br>    if (lpxpl-&gt;hOutFindHandle != INVALID_HANDLE_VALUE) <br>        CloseHandle(lpxpl-&gt;hOutFindHandle); <br> <br>    /* OK, Deallocate the memory. */ <br> <br>    /* Session User Display Name and Entry-ID */ <br> <br>    if (lpxpl-&gt;lpMyIDArray) <br>    { <br>        lpxpl-&gt;FreeBuffer(lpxpl-&gt;lpMyIDArray[0].Value.bin.lpb); <br>        lpxpl-&gt;FreeBuffer(lpxpl-&gt;lpMyIDArray); <br>    } <br> <br>    /* Free the session property array */ <br> <br>    lpxpl-&gt;FreeBuffer(lpxpl-&gt;lpPropArray); <br> <br>    /* Free the Message OptionData struct */ <br> <br>    lpxpl-&gt;FreeBuffer(lpxpl-&gt;lpOptData); <br> <br>    /* Release() the support object if need be. Do this last, <br>       since it could cause spooler to call XPP_Release. */ <br> <br>    if (fRefSupport) <br>        lpMAPISup-&gt;lpVtbl-&gt;Release(lpMAPISup); <br>} <br> <br> <br>/* <br> -  lpxpp-&gt;lpVtbl-&gt;QueryInterface <br> - <br> *  Purpose: <br> * <br> *  Parameters: <br> *      lpxpp               Pointer to object <br> *      lpiid               New interface to Query to <br> *      lppUnk              Where to store pointer to new object <br> * <br> *  Returns: <br> *      (SCODE)             E_INVALIDARG if the input <br> *                          object doesn't look like a XPP; <br> *                          E_INVALIDARG if the IID <br> *                          isn't readable or lppNewObj isn't <br> *                          writable; E_NOINTERFACE <br> *                          if we don't know the IID. <br> * <br> *  Operation: <br> *      Validate parameters. See if the caller wants IUnknown or IXPProvider. <br> *      If so, increment the usage count and return a new object. <br> */ <br> <br>STDMETHODIMP <br>XPP_QueryInterface(LPXPP lpxpp, <br>    REFIID lpiid, <br>    LPVOID FAR * lppUnk) <br>{ <br>    /*  Validate the parameters: 1) Does it seem to be an object? <br>        2) is the refcount nonzero? 3) Is there enough there for <br>        an interface ID? 4) Is there enough there for a new object? */ <br> <br>    if ((IsBadWritePtr(lpxpp, sizeof(XPP))) || <br>        (lpxpp-&gt;lcInit == 0) || <br>        (lpxpp-&gt;lpxppMyAddress != lpxpp) || <br>        (IsBadReadPtr(lpiid, sizeof(IID))) || <br>        (IsBadWritePtr(lppUnk, sizeof(LPXPP)))) <br>    { <br>        DebugTraceSc(XPP_QueryInterface, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /*  See if the requested interface is one of ours */ <br> <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IXPProvider, sizeof(IID))) <br>    { <br>        *lppUnk = NULL;         /* OLE requires zeroing [out] parameters */ <br>        DebugTraceSc(XPP_QueryInterface, E_NOINTERFACE); <br>        return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    ++lpxpp-&gt;lcInit; <br>    *lppUnk = lpxpp; <br> <br>    return hrSuccess; <br>} <br> <br> <br>/* <br> -  lpxpp-&gt;lpVtbl-&gt;AddRef <br> - <br> *  Purpose: <br> *      Increment reference count if nonzero. <br> * <br> *  Parameters: <br> *      lpxpp               Pointer to object (should be XPP) <br> * <br> * <br> *  Returns: <br> *      (ULONG)             Current reference count or zero if <br> *                          it doesn't seem to be XPP. <br> * <br> *  Operation: <br> *      Make sure it looks like a XPP, and if so, bump the reference count <br> *      and return the result to the caller. <br> */ <br> <br>STDMETHODIMP_(ULONG) <br>XPP_AddRef(LPXPP lpxpp) <br>{ <br>    /*  If it doesn't seem to be an object or refcount is zero, return zero */ <br> <br>    if (IsBadWritePtr(lpxpp, sizeof(XPP)) || <br>        lpxpp-&gt;lcInit == 0 || <br>        lpxpp-&gt;lpxppMyAddress != lpxpp) <br>        return 0; <br> <br>    return ++lpxpp-&gt;lcInit; <br>} <br> <br> <br>/* <br> -  lpxpp-&gt;lpVtbl-&gt;Release <br> - <br> *  Purpose: <br> *      Decrement lcInit. If it's zero, release the object. <br> * <br> *  Parameters: <br> *      lpxpp               Pointer to object (should be XPP) <br> * <br> *  Returns: <br> *      (ULONG)             Current reference count or zero if <br> *                                  it doesn't seem to be XPP. <br> * <br> *  Operation: <br> *      Make sure it looks like a XPP, and if so, decrement the reference <br> *      count. If the count is now zero, deallocate the object. <br> * <br> *      Return the reference count to the caller. <br> */ <br> <br>STDMETHODIMP_(ULONG) <br>XPP_Release(LPXPP lpxpp) <br>{ <br>    /*  If it doesn't seem to be an object or refcount is zero, return zero */ <br> <br>    if (IsBadWritePtr(lpxpp, sizeof(XPP)) || <br>        lpxpp-&gt;lcInit == 0 || <br>        lpxpp-&gt;lpxppMyAddress != lpxpp) <br>        return 0; <br> <br>    --lpxpp-&gt;lcInit; <br> <br>    if (lpxpp-&gt;lcInit == 0) <br>    { <br>        ULONG ulT; <br> <br>        DebugTrace("XPP_Release() freeing XPP.\n"); <br> <br>        /* If we've inited and not deinited, do it now */ <br> <br>        if (lpxpp-&gt;fInited) <br>        { <br>            ulT = DEINIT_HURRY; <br>            lpxpp-&gt;lpVtbl-&gt;Shutdown(lpxpp, &amp;ulT); <br>        } <br> <br>        lpxpp-&gt;lpVtbl = NULL; <br>        (*lpxpp-&gt;lpFreeBuffer) (lpxpp); <br>        return 0; <br>    } <br> <br>    return lpxpp-&gt;lcInit; <br>} <br> <br> <br>/* <br> -  lpxpl-&gt;lpVtbl-&gt;QueryInterface <br> - <br> *  Purpose: <br> * <br> *  Parameters: <br> *      lpxpl               Pointer to object <br> *      lpiid               New interface to Query to <br> *      lppUnk              Where to store pointer to new object <br> * <br> *  Returns: <br> *      (SCODE)             E_INVALIDARG if the input <br> *                          object doesn't look like a XPL; <br> *                          E_INVALIDARG if the IID <br> *                          isn't readable or lppNewObj isn't <br> *                          writable; E_NOINTERFACE <br> *                          if we don't know the IID. <br> * <br> *  Operation: <br> *      Validate parameters. See if the caller wants IUnknown or IXPLogon. <br> *      If so, increment the usage count and return a new object. <br> */ <br> <br>STDMETHODIMP <br>XPL_QueryInterface(LPXPL lpxpl, <br>    REFIID lpiid, <br>    LPVOID FAR * lppUnk) <br>{ <br>    /*  Validate the parameters: 1) Does it seem to be an object? <br>        2) is the refcount nonzero? 3) Is there enough there for <br>        an interface ID? 4) Is there enough there for a new object? */ <br> <br>    if ((IsBadWritePtr(lpxpl, sizeof(XPL))) || <br>        (lpxpl-&gt;lcInit == 0) || <br>        (lpxpl-&gt;lpMySession != lpxpl) || <br>        (IsBadReadPtr(lpiid, sizeof(IID))) || <br>        (IsBadWritePtr(lppUnk, sizeof(LPXPL)))) <br>    { <br>        DebugTraceSc(XPL_QueryInterface, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /*  See if the requested interface is one of ours */ <br> <br>    if (memcmp(lpiid, &amp;IID_IUnknown, sizeof(IID)) &amp;&amp; <br>        memcmp(lpiid, &amp;IID_IXPLogon, sizeof(IID))) <br>    { <br>        *lppUnk = NULL;         /* OLE requires zeroing [out] parameters */ <br>        DebugTraceSc(XPL_QueryInterface, E_NOINTERFACE); <br>        return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>    /*  We'll do this one. Bump the usage count and return a new pointer. */ <br> <br>    ++lpxpl-&gt;lcInit; <br>    *lppUnk = lpxpl; <br> <br>    return hrSuccess; <br>} <br> <br> <br>/* <br> -  lpxpl-&gt;lpVtbl-&gt;AddRef <br> - <br> *  Purpose: <br> *      Increment reference count if nonzero. <br> * <br> *  Parameters: <br> *      lpxpl               Pointer to object (should be XPL) <br> * <br> *  Returns: <br> *      (ULONG)             Current reference count or zero if <br> *                          it doesn't seem to be XPL. <br> * <br> *  Operation: <br> *      Make sure it looks like a XPL, and if so, bump the reference count <br> *      and return the result to the caller. <br> */ <br> <br>STDMETHODIMP_(ULONG) <br>XPL_AddRef(LPXPL lpxpl) <br>{ <br>    /*  If it doesn't seem to be an object or refcount is zero, return zero */ <br> <br>    if (IsBadWritePtr(lpxpl, sizeof(XPL)) || <br>        lpxpl-&gt;lcInit == 0 || <br>        lpxpl-&gt;lpMySession != lpxpl) <br>        return 0; <br> <br>    return ++lpxpl-&gt;lcInit; <br>} <br> <br> <br>/* <br> -  lpxpl-&gt;lpVtbl-&gt;Release <br> - <br> *  Purpose: <br> *      Decrement lcInit. If it's zero, release the object. </code></pre>
<p>
</p>
<pre><code>* <br> *  Parameters: <br> *      lpxpl               Pointer to object (should be XPL) <br> * <br> *  Returns: <br> *      (ULONG)             Current reference count or zero if <br> *                          it doesn't seem to be XPL. <br> * <br> *  Operation: <br> *      Make sure it looks like a XPL, and if so, decrement the reference <br> *      count. If the count is now zero, deallocate the object. <br> * <br> *      Return the reference count to the caller. <br> */ <br> <br>STDMETHODIMP_(ULONG) <br>XPL_Release(LPXPL lpxpl) <br>{ <br>    /*  If it doesn't seem to be an object or refcount is zero, return zero */ <br> <br>    if (IsBadWritePtr(lpxpl, sizeof(XPL)) || <br>        lpxpl-&gt;lcInit == 0 || <br>        lpxpl-&gt;lpMySession != lpxpl) <br>        return 0; <br> <br>    --lpxpl-&gt;lcInit; <br> <br>    if (lpxpl-&gt;lcInit == 0) <br>    { <br>        DebugTrace("XPL_Release() freeing XPL.\n"); <br> <br>        /* Ignore return code; we're going away reguardless! */ <br> <br>        XPL_TransportLogoff(lpxpl, LOGOFF_HURRY); <br>        lpxpl-&gt;lpVtbl = NULL; <br>        (*lpxpl-&gt;FreeBuffer) (lpxpl); <br> <br>        return 0; <br>    } <br> <br>    return lpxpl-&gt;lcInit; <br>} <br> <br> <br>/* <br> -  ScCheckLogonProps <br> - <br> *  Purpose: <br> *      Looks at the properties returned from the XP Logon property <br> *      sheet and does some 'lite' validation of the values.  Users <br> *      of this function must accept the symantics associated with <br> *      the three possible return values.  That is, if the caller <br> *      is displaying UI and MAPI_E_INVALID_PARAMETER is returned <br> *      then the UI must be re-displayed.  If the caller is NOT <br> *      displaying UI and MAPI_E_UNCONFIGURED is returned then <br> *      they should pass this error back up the call stack, as MAPI <br> *      will call the Service Entry point to get this info. <br> *      MAPI_E_USER_CANCEL will only be returned if UI is allowed, <br> *      in which case this should be treated the same a when the <br> *      user presses &lt;Cancel&gt; in the Logon dialog. <br> * <br> *  Parameters: <br> *      lpXPDialog          - Contains everything I need <br> *      fUIAllowed          - Indicates if MessageBox's are allowed <br> * <br> *  Returns: <br> *      S_OK                        - All data appears valid <br> *      MAPI_E_USER_CANCEL          - Bad data and the user wants to abort <br> *      MAPI_E_UNCONFIGURED         - Bad data and the user wants to try again <br> */ <br> <br>SCODE <br>ScCheckLogonProps(LPXPDLG lpXPDialog, BOOL fUIAllowed) <br>{ <br>    SCODE sc = MAPI_E_UNCONFIGURED; <br>    LPTSTR lpszT = NULL; <br>    HINSTANCE hInst = lpXPDialog-&gt;hInst; <br>    HWND hWnd = lpXPDialog-&gt;hwnd; <br>    LPSPropValue lpProps = *(lpXPDialog-&gt;lppPropArray); <br>    HANDLE hf = INVALID_HANDLE_VALUE; <br>    ULONG ulT; <br>    BOOL fDeleteFile = FALSE; <br>    LPTSTR szFuBar = TEXT("fubar"); <br>    TCHAR szFooUNC[MAX_PATH]; <br>    TCHAR szFooPath[MAX_PATH]; <br>    UINT ids = 0; <br>    LONG lFlags; <br> <br>#ifdef _WINNT <br>    ULONG cb; <br>    TCHAR szBuff[16]; <br>#endif  /* _WINNT */ <br> <br>    /* Check Display Name */ <br> <br>    lpszT = ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpProps).Value.LPSZ; <br> <br>    if (PROP_TYPE(ArrayIndex(PR_SAMPLE_DISPLAY_NAME, lpProps).ulPropTag) == PT_ERROR || <br>        !lpszT || (*lpszT == '\0')) <br>    { <br>        ids = IDS_NO_DISPLAY_NAME; <br>        goto ret; <br>    } <br> <br>    /* Check Address Type */ <br> <br>    lpszT = ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpProps).Value.LPSZ; <br> <br>    if (PROP_TYPE(ArrayIndex(PR_SAMPLE_EMAIL_ADDR_TYPE, lpProps).ulPropTag) == PT_ERROR || <br>        !lpszT || (*lpszT == '\0')) <br>    { <br>        ids = IDS_NO_ADDR_TYPE; <br>        goto ret; <br>    } <br> <br>    /* Check Email Address */ <br> <br>    lpszT = ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpProps).Value.LPSZ; <br> <br>    if (PROP_TYPE(ArrayIndex(PR_SAMPLE_EMAIL_ADDRESS, lpProps).ulPropTag) == PT_ERROR || <br>        !lpszT || (*lpszT == '\0')) <br>    { <br>        ids = IDS_NO_EMAIL_ADDRESS; <br>        goto ret; <br>    } <br> <br>    /* Save this, we'll need it later */ <br> <br>    lstrcpy(szFooUNC, lpszT); <br> <br>    if (szFooUNC[lstrlen(szFooUNC)-1] != '\\') <br>        lstrcat(szFooUNC, TEXT("\\")); <br> <br>    lstrcat(szFooUNC, TEXT("foo.txt")); <br> <br>    /* Check Inbound Directory */ <br> <br>    lpszT = ArrayIndex(PR_SAMPLE_INBOUND_DIR, lpProps).Value.LPSZ; <br> <br>    if (PROP_TYPE(ArrayIndex(PR_SAMPLE_INBOUND_DIR, lpProps).ulPropTag) == PT_ERROR || <br>        !lpszT || (*lpszT == '\0')) <br>    { <br>        ids = IDS_NO_INBOUND_DIR; <br>        goto ret; <br>    } <br> <br>    lstrcpy(szFooPath, lpszT); <br> <br>    if (szFooPath[lstrlen(szFooPath)-1] != '\\') <br>        lstrcat(szFooPath, TEXT("\\")); <br> <br>    lstrcat(szFooPath, TEXT("foo.txt")); <br> <br>    /* Check Outbound Directory */ <br> <br>    lFlags = ArrayIndex(PR_SAMPLE_FLAGS, lpProps).Value.l; <br> <br>    if (PROP_TYPE(ArrayIndex(PR_SAMPLE_FLAGS, lpProps).ulPropTag) == PT_ERROR || <br>        !(lFlags &amp; PR_SAMPLE_FLAG_PEER_TO_PEER)) <br>    { <br>        lpszT = ArrayIndex(PR_SAMPLE_OUTBOUND_DIR, lpProps).Value.LPSZ; <br> <br>        if (!lpszT || (*lpszT == '\0')) <br>        { <br>            ids = IDS_NO_OUTBOUND_DIR; <br>            goto ret; <br>        } <br>    } <br> <br> <br>#ifdef _WINNT <br> <br>    /* Do a little loop-back test to validate PR_SAMPLE_EMAIL_ADDRESS <br>       and PR_SAMPLE_INBOUND_DIR point to the same place and are valid. <br>       The WFW and Windows 95 Redirector can't talk to itself, so we only <br>       do this on NT.  Shouldn't be done on platforms whose redirector <br>       cannot do the loop-back thang. */ <br> <br>    if ((hf = CreateFile(szFooUNC, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, <br>                FILE_FLAG_WRITE_THROUGH, NULL)) == INVALID_HANDLE_VALUE) <br>    { <br>        ids = IDS_BAD_EMAIL_ADDRESS; <br>        goto ret; <br>    } <br> <br>    if (!WriteFile(hf, szFuBar, lstrlen(szFuBar), &amp;cb, NULL)) <br>    { <br>        ids = IDS_BAD_EMAIL_ADDRESS; <br>        goto ret; <br>    } <br> <br>    CloseHandle(hf); <br> <br>    fDeleteFile = TRUE; <br> <br>    /* Now, read the file */ <br> <br>    if ((hf = CreateFile(szFooPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, <br>                FILE_ATTRIBUTE_READONLY, NULL)) == INVALID_HANDLE_VALUE) <br>    { <br>        ids = IDS_BAD_INBOUND_DIR; <br>        goto ret; <br>    } <br> <br>    if (!ReadFile(hf, szBuff, lstrlen(szFuBar), &amp;cb, NULL)) <br>    { <br>        ids = IDS_BAD_INBOUND_DIR; <br>        goto ret; <br>    } <br> <br>    szBuff[lstrlen(szFuBar)] = '\0'; <br> <br>    CloseHandle(hf); <br>    hf = INVALID_HANDLE_VALUE; <br> <br>    if (lstrcmp(szFuBar, szBuff)) <br>    { <br>        ids = IDS_UNC_DIR_MISMATCH; <br>        goto ret; <br>    } <br> <br>#endif  /* _WINNT */ <br> <br>    /*  If there's a high water mark, make sure there's a low water <br>        mark at least 1K less than high water and no more than 32K. */ <br> <br>    ulT = ArrayIndex(PR_SAMPLE_LOGHIGHWATER, lpProps).Value.ul; <br>    if (PROP_TYPE(ArrayIndex(PR_SAMPLE_LOGHIGHWATER, lpProps).ulPropTag) == PT_ERROR || <br>        ulT) <br>    { <br>        /* It looks like we'll be doing size adjustment. See what <br>        the current "low water" mark is. */ <br> <br>        ULONG ulLow; <br> <br>        ulLow = ArrayIndex(PR_SAMPLE_LOGLOWWATER, lpProps).Value.ul; <br> <br>        /* Make sure it's not more than 32K. If so, trim it down. */ <br> <br>        if (ulLow &gt; 32) <br>            ulLow = 32; <br> <br>        /* Make sure there's at least 1K between high and low water. If <br>        not, increase high water mark to satisfy this. */ <br> <br>        if (ulLow &gt; (ulT - 1)) <br>            ulT = ulLow + 1; <br> <br>        /* Save this stuff into the logon property array. */ <br> <br>        ArrayIndex(PR_SAMPLE_LOGLOWWATER, lpProps).Value.ul = ulLow; <br>        ArrayIndex(PR_SAMPLE_LOGHIGHWATER, lpProps).Value.ul = ulT; <br>    } <br> <br>    sc = S_OK; <br> <br>ret: <br>    if (fDeleteFile) <br>        DeleteFile(szFooUNC); <br> <br>    if (hf != INVALID_HANDLE_VALUE) <br>        CloseHandle(hf); <br> <br>    /*  OK, the following block goes something like this: <br>        We initialized sc to MAPI_E_UNCONFIGURED at the top <br>        and only set it to S_OK if we make it all the way through <br>        the validation stuff.  If, along the way, we find bad data <br>        we set ids to the appropriate error string (this is Assert'd <br>        below).  Then, if UI is allowed, we get a bunch of string <br>        resources via LoadString and format an error message that <br>        will be displayed in a MessageBox.  If we are running the <br>        debug version of the transport, then the MessageBox will <br>        have an Abort/Retry/Ignore button selection, else, it will <br>        only have a Yes/No button selection.  These buttons carry <br>        with them the following meaning: <br> <br>        DEBUG <br>            Abort   Return MAPI_E_USER_CANCEL; causes Logon to fail; <br>                    indicates that data is not to be saved in the profile. <br> <br>            Retry   Return MAPI_E_UNCONFIGURED; re-display <br>                    Logon UI so user can fix problem. <br> <br>            Ignore  Return S_OK; we accept the data as is and will <br>                    write it into the profile (if asked to save). <br> <br>        !DEBUG <br>            Yes     Same as Retry above. <br> <br>            No      Same as Abort above. <br> <br>        Since we are using MessageBox for our error dialog, we are <br>        limited to this confusing choice of buttons. <br>    */ <br> <br>    if (FAILED(sc) &amp;&amp; fUIAllowed) <br>    { <br>        TCHAR szErrTitle[64]; <br>        TCHAR szErrFormat[128]; <br>        TCHAR szErrStr[128]; <br>        TCHAR szErrMsg[256]; <br>        UINT fuButtons = MB_ICONEXCLAMATION | MB_SETFOREGROUND; <br>        int rc; <br> <br>        Assert(ids); <br> <br>        if (!LoadString(hInst, ids, szErrStr, sizeof(szErrStr) - 1) || <br>            !LoadString(hInst, IDS_BAD_LOGON_PROPS_TITLE, <br>                        szErrTitle, sizeof(szErrTitle) - 1) || <br>            !LoadString(hInst, IDS_BAD_LOGON_PROPS_FORMAT, <br>                        szErrFormat, sizeof(szErrFormat) - 1)) <br>        { <br>            DebugTrace("Unable to do a LoadString in ScCheckLogonProps.\n"); <br>            return sc; <br>        } <br> <br>        wsprintf(szErrMsg, szErrFormat, szErrStr); <br> <br>#ifdef DEBUG <br>        fuButtons |= MB_ABORTRETRYIGNORE; <br>#else <br>        fuButtons |= MB_YESNO; <br>#endif <br> <br>        rc = MessageBox(hWnd, szErrMsg, szErrTitle, fuButtons); <br> <br>        if (rc == IDRETRY || rc == IDYES) <br>            sc = MAPI_E_UNCONFIGURED; <br>        else if (rc == IDABORT || rc == IDNO) <br>            sc = MAPI_E_USER_CANCEL; <br>        else <br>            sc = S_OK; <br>    } <br> <br>    return sc; <br>} <br> <br> <br>/* <br> -  HrCheckSpoolerYield <br> - <br> *  Purpose: <br> *      Used to enforce the .2 second rule.  Called periodically while <br> *      processing a message to determine if we have used more than .2 <br> *      seconds.  If so, then call SpoolerYield(), else just continue. <br> *      This is called with fReset set to TRUE when we first enter one <br> *      of the Transport Logon methods (usually one that is known to <br> *      take a long time like StartMessage() or SubmitMessage(). ) <br> * <br> *  Parameters: <br> *      lpMAPISup           - The Transports support object <br> *      fReset              - Sets dwStart to current TickCount and returns <br> * <br> */ <br> <br>HRESULT <br>HrCheckSpoolerYield(LPMAPISUP lpMAPISup, BOOL fReset) <br>{ <br>    HRESULT hr = hrSuccess; <br>    DWORD dwStop; <br>    static DWORD dwStart; <br> <br>    if (fReset) <br>    { <br>        dwStart = GetTickCount(); <br>        return hr; <br>    } <br> <br>    dwStop = GetTickCount(); <br> <br>    if ((dwStop - dwStart) &gt; 200) <br>    { <br>        hr = lpMAPISup-&gt;lpVtbl-&gt;SpoolerYield(lpMAPISup, 0); <br>        dwStart = GetTickCount(); <br>    } <br> <br>    return hr; <br>} <br> <br>/* <br> -  ScCopySessionProps <br> - <br> *  Purpose: <br> *      Used to make a working copy of the session properties associated <br> *      with a particular logon object.  This is done to protect us from <br> *      having our data change out from under us due to a call to some <br> *      transport UI.  This is done instead of mutexing to avoid the chance <br> *      of deadlock conditions and to avoid having to create an elaborate <br> *      mutex object that suits our special needs. <br> * <br> *  Parameters: <br> *      lpxpl               - The Transports logon object <br> *      lppPropArray        - Receives the new PropArray set <br> *      lppMyIdArray        - Receives the new IdArray <br> */ <br> <br>SCODE <br>ScCopySessionProps( <br>    LPXPL lpxpl, <br>    LPSPropValue FAR * lppPropArray, <br>    LPSPropValue FAR * lppMyIDArray) <br>{ <br>    SCODE sc = S_OK; <br>    ULONG cProps; <br>    LPSPropValue lpPropArray = lpxpl-&gt;lpPropArray; <br>    LPSPropValue lpMyIDArray = lpxpl-&gt;lpMyIDArray; <br>    LPALLOCATEBUFFER lpAllocBuff = lpxpl-&gt;AllocateBuffer; <br> <br>    if (lppPropArray) <br>    { <br>        cProps = MAX_LOGON_PROPERTIES - TEMP_LOGON_PROPERTIES; <br> <br>        sc = ScDupPropset((int)cProps, lpPropArray, lpAllocBuff, lppPropArray); <br> <br>        if (FAILED(sc)) <br>            goto ret; <br>    } <br> <br>    if (lppMyIDArray) <br>    { <br>        cProps = NUM_SENDER_PROPS; <br> <br>        sc = ScDupPropset((int)cProps, lpMyIDArray, lpAllocBuff, lppMyIDArray); <br> <br>        if (FAILED(sc) &amp;&amp; lppPropArray) <br>        { <br>            lpxpl-&gt;FreeBuffer(*lppPropArray); <br>            *lppPropArray = NULL; <br>        } <br>    } <br> <br>ret: <br>    return sc; <br>} <br> <br>/* <br> -  ServiceEntry <br> - <br> *  Purpose: <br> *      This is the service entry point for the MAPI Configuration <br> *      application.  This function uses the XP Logon dialog to allow <br> *      the user to configure the provider.  If asked to, through the <br> *      UI, the new settings will be saved in the profile. <br> * <br> *  Parameters: <br> *      hInstance           [IN] Instance handle of the calling process <br> *      lpMalloc            [IN] OLE style allocator to be used by PropSheet. <br> *      lpMAPISup           [IN] MAPI Support object - used to get memory <br> *                          allocators, BuildDisplayTable, etc. <br> *      ulUIParam           [IN] hWnd of the caller who is parent of my UI. <br> *      ulFlags             [IN] UI_SERVICE indicates that the caller wants <br> *                          UI to help in configuring this provider. <br> *                          MSG_SERVICE_UI_READ_ONLY indicates the caller <br> *                          does not want write access to the configuration <br> *                          property sheet.  No other flags are supported. <br> *      ulContext           [IN] MSG_SERVICE_DELETE, MSG_SERVICE_INSTALL, and <br> *                          MSG_SERVICE_UNINSTALL are noops and simply return <br> *                          hrSuccess.  MSG_SERVICE_CONFIGURE and <br> *                          MSG_SERVICE_CREATE allow the caller to create <br> *                          or update the Logon properties in this providers <br> *                          profile section. <br> *      cValues             [IN] The caller may supply an array of property <br> *                          values to configure this provider with.  This is <br> *                          the number of values found in the array. <br> *      lpProps             [IN] Caller supplied configuration properties. <br> *      lpAdminProviders    [IN] An IProviderAdmin object used to retrieve a <br> *                          ProfileSection object for this provider. <br> *      lppMapiError        [OUT] Extended error information optionally <br> *                          returned when the call fails. <br> */ <br> <br>HRESULT STDAPICALLTYPE <br>ServiceEntry( <br>    HINSTANCE hInstance, <br>    LPMALLOC lpMalloc, <br>    LPMAPISUP lpMAPISup, <br>    ULONG ulUIParam, <br>    ULONG ulFlags, <br>    ULONG ulContext, <br>    ULONG cValues, <br>    LPSPropValue lpProps, <br>    LPPROVIDERADMIN lpAdminProviders, <br>    LPMAPIERROR FAR *lppMapiError) <br>{ <br>    SCODE sc = S_OK; <br>    HRESULT hResult = hrSuccess; <br>    ULONG ulT; <br>    ULONG ulCount = 0; <br>    LPSPropValue lpPropArray = NULL; <br>    LPSPropValue lpLogonProps = NULL; <br>    LPALLOCATEBUFFER lpAllocBuff; <br>    LPALLOCATEMORE lpAllocMore; <br>    LPFREEBUFFER lpFreeBuff; <br>    LPPROFSECT lpProfileObj = NULL; <br>    XPDLG XPDialog; <br>    BOOL fNeedUI = FALSE; <br>    BOOL fAllowUI = FALSE; <br>    BOOL fInitialParamsOk = TRUE; <br> <br>    /* Validate parameters */ <br>    //$BUG: No parameter checking.... <br> <br>    /* Check the Support Object */ <br> <br>    if (FBadUnknown(lpMAPISup)) <br>    { <br>        DebugTraceSc(Bad lpMAPISup in XP ServiceEntry, E_INVALIDARG); <br>        return ResultFromScode(E_INVALIDARG); <br>    } <br> <br>    /* Check for context */ <br> <br>    if ((ulContext == MSG_SERVICE_DELETE) || <br>        (ulContext == MSG_SERVICE_INSTALL) || <br>        (ulContext == MSG_SERVICE_UNINSTALL)) <br>        return hrSuccess; <br> <br>    if (ulContext != MSG_SERVICE_CONFIGURE &amp;&amp; ulContext != MSG_SERVICE_CREATE) <br>    { <br>        DebugTraceSc(ServiceEntry unsupported context, MAPI_E_NO_SUPPORT); <br>        return ResultFromScode(MAPI_E_NO_SUPPORT); <br>    } <br> <br>    if ( ulFlags &amp; MAPI_UNICODE ) <br>    { <br>        DebugTraceSc(ServiceEntry Bad character width, MAPI_E_BAD_CHARWIDTH); <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    } <br> <br>    /* Check for UI */ <br> <br>    if (ulFlags &amp; SERVICE_UI_ALWAYS) <br>        fAllowUI = fNeedUI = TRUE; <br>    else <br>        if (ulFlags &amp; SERVICE_UI_ALLOWED) <br>            fAllowUI = TRUE; <br> <br>    if (ulFlags &amp; MSG_SERVICE_UI_READ_ONLY) <br>        ulFlags = UI_READONLY; <br> <br>    /* Get the memory allocation routines we'll be needing. */ <br> <br>    hResult = lpMAPISup-&gt;lpVtbl-&gt;GetMemAllocRoutines(lpMAPISup, <br>        &amp;lpAllocBuff, &amp;lpAllocMore, &amp;lpFreeBuff); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("GetMemAllocRoutines failed in ServiceEntry.\n"); <br>        goto ret; <br>    } <br> <br>    /* Open the Profile Section for this Transport Provider. */ <br> <br>    hResult = HrOpenSingleProvider(lpAdminProviders, &amp;lpProfileObj); <br> <br>    if (hResult) <br>    { <br>        DebugTrace("Unable to open the profile.\n"); <br>        goto ret; <br>    } <br> <br>    /* Profile is open, get the properties out of it. */ <br> <br>    hResult = lpProfileObj-&gt;lpVtbl-&gt;GetProps(lpProfileObj, <br>        (LPSPropTagArray) &amp;sptLogonArray, ulFlags &amp; MAPI_UNICODE, &amp;ulCount, &amp;lpPropArray); <br> <br>    if (HR_FAILED(hResult)) <br>    { <br>        DebugTrace("GetProps failed in XP ServiceEntry.\n"); <br>        goto ret; <br>    } <br> <br>    hResult = hrSuccess; <br> <br>    /*  If the user passed in a property array to configure our profile <br>        with, then we'll merge this array with that from the profile <br>        section.  This merged array will, conditionally, be used in our <br>        Logon UI and, conditionally,  written out to the profile section. <br>        Also, lpLogonProps becomes our alias for the array no matter where <br>        the properties come from. */ <br> <br>    if (lpProps) <br>    { <br>        sc = ScMergeLogonProps(cValues, lpProps, ulCount, <br>            lpPropArray, lpAllocBuff, lpAllocMore, &amp;lpLogonProps); <br> <br>        if (FAILED(sc)) <br>        { <br>            hResult = ResultFromScode(sc); <br>            DebugTrace("ScMergeLogonProps failed in XP ServiceEntry.\n"); <br>            goto ret; <br>        } <br>    } <br>    else <br>    { <br>        lpLogonProps = lpPropArray; <br>        lpPropArray = NULL; <br>    } <br> <br>    Assert(ulCount == MAX_LOGON_PROPERTIES); <br>    ulCount -= TEMP_LOGON_PROPERTIES; <br> <br>    /* Find out if the stored SAMPLE_FLAGS say we should have UI. <br>       But, only if we aren't already forcing UI to be presented. */ <br> <br>    if (fAllowUI &amp;&amp; !fNeedUI &amp;&amp; lpLogonProps) <br>    { <br>        if ((ArrayIndex(PR_SAMPLE_FLAGS, lpLogonProps).ulPropTag == PR_SAMPLE_FLAGS) &amp;&amp; <br>            (ArrayIndex(PR_SAMPLE_FLAGS, lpLogonProps).Value.l &amp; PR_SAMPLE_FLAG_UI_ALWAYS)) <br>                fNeedUI = TRUE; <br>    } <br> <br>    /* Fill in the logon UI structure */ <br> <br>    XPDialog.hInst = hInstance; <br>    XPDialog.hwnd = (HWND) ulUIParam; <br>    XPDialog.lppPropArray = &amp;lpLogonProps; <br>    XPDialog.lpPTArray = (LPSPropTagArray) &amp;sptLogonArray; <br>    XPDialog.AllocateBuffer = lpAllocBuff; <br>    XPDialog.AllocateMore = lpAllocMore; <br>    XPDialog.FreeBuffer = lpFreeBuff; <br>    XPDialog.lpMalloc = lpMalloc; <br>    XPDialog.lpMAPISup = lpMAPISup; <br>    XPDialog.fLogon = TRUE; <br>    XPDialog.ulFlags = ulFlags; <br> <br>    /* Check the logon props BEFORE the dialog call, as the props will <br>       be freed if Cancel is selected, and we will want to know if the <br>       provider configuration information was valid */ <br> <br>    sc = ScCheckLogonProps(&amp;XPDialog, FALSE); <br>    if ((sc == MAPI_E_USER_CANCEL) || (sc == MAPI_E_UNCONFIGURED)) <br>    { <br>        if (fAllowUI) <br>        { <br>            fNeedUI = TRUE; <br>            fInitialParamsOk = FALSE; <br>        } <br>        else <br>            goto ret; <br>    } <br> <br>    while (fAllowUI &amp;&amp; fNeedUI) <br>    { <br>        sc = ScDoLogonDlg(&amp;XPDialog); <br> <br>        if (FAILED(sc)) <br>        { <br>            hResult = ResultFromScode(sc); <br> <br>            if (sc != MAPI_E_USER_CANCEL) <br>            { <br>                DebugTrace("ScDoLogonDlg failed in XP ServiceEntry.\n"); <br>            } <br>            else <br>                if (!fInitialParamsOk) <br>                    hResult = ResultFromScode(MAPI_E_UNCONFIGURED); <br> <br>            goto ret; <br>        } <br> <br>        if (!lpLogonProps) <br>        { <br>            hResult = ResultFromScode(MAPI_E_CALL_FAILED); <br>            DebugTrace("No Logon Props returned in XP ServiceEntry.\n"); <br>            goto ret; <br>        } <br> <br>        /* Got a prop array, make sure everything in it is good */ <br> <br>        for (ulT = 0; ulT &lt; ulCount; ulT++) <br>        { <br>            if (PROP_TYPE((lpLogonProps)[ulT].ulPropTag) == PT_ERROR) <br>            { <br>                hResult = ResultFromScode(MAPI_E_UNCONFIGURED); <br>                DebugTrace("Property %x not available, returning MAPI_E_UNCONFIGURED\n", PROP_ID((lpLogonProps)[ulT].ulPropTag)); <br>                goto ret; <br>            } <br>        } <br> <br>        /* Do some simple validation of the Logon Props */ <br> <br>        sc = ScCheckLogonProps(&amp;XPDialog, TRUE); <br> <br>        if (sc == MAPI_E_USER_CANCEL) <br>            goto ret; <br>        else if (sc == MAPI_E_UNCONFIGURED) <br>            continue; <br>        else <br>            fNeedUI = FALSE; <br>    } <br> <br>    /*  If the user passed in properties and didn't request UI, then <br>        we need to check the array of Logon Props now.  If they are <br>        bad, then we'll simply return an error. */ <br> <br>    if (lpProps &amp;&amp; !(ulFlags &amp; SERVICE_UI_ALWAYS)) <br>    { <br>        if (sc = ScCheckLogonProps(&amp;XPDialog, FALSE)) <br>        { <br>            hResult = ResultFromScode(sc); <br>            DebugTrace("User supplied properties did not pass validation.\n"); <br>            goto ret; <br>        } <br>    } <br> <br>    /*  If we get here, everything is fine and we can proceed. But first <br>        we should write the properties out if the user is willing. */ <br> <br>    ulT = ArrayIndex(PR_SAMPLE_FLAGS, lpLogonProps).ulPropTag; <br>    Assert(PROP_TYPE(ulT) != PT_ERROR); <br> <br>    ulT = ArrayIndex(PR_SAMPLE_FLAGS, lpLogonProps).Value.ul; <br> <br>    if (ulT &amp; PR_SAMPLE_FLAG_SAVE_DATA) <br>    { <br>        hResult = lpProfileObj-&gt;lpVtbl-&gt;SetProps(lpProfileObj, <br>            ulCount, lpLogonProps, NULL); <br> <br>        if (hResult) <br>        { <br>            DebugTrace("SetProps failed in XP ServiceEntry.\n"); <br>            goto ret; <br>        } <br> <br>        lpProfileObj-&gt;lpVtbl-&gt;SaveChanges(lpProfileObj, 0); <br>    } <br> <br>ret: <br>    UlRelease(lpProfileObj); <br>    lpFreeBuff(lpPropArray); <br>    lpFreeBuff(lpLogonProps); <br> <br>    DebugTraceResult(ServiceEntry, hResult); <br>    return hResult; <br>}; <br> <br> <br>/* <br> -  HrOpenSingleProvider <br> - <br> *  Purpose: <br> *      Gets the IProfileSect object for a single provider from the <br> *      ProviderTable in the IProviderAdmin object.  My entry in the <br> *      table is supposed to be in the first row - this better be true. <br> * <br> */ <br> <br>HRESULT <br>HrOpenSingleProvider(LPPROVIDERADMIN lpAdminProviders, <br>    LPPROFSECT FAR * lppProfSect) <br>{ <br>    HRESULT hResult; <br>    LPMAPITABLE lpTable = NULL; <br>    LPSRowSet lpRows = NULL; <br>    LPSPropValue lpProp; <br>    SPropTagArray sptaProvider = {1, {PR_PROVIDER_UID}}; <br> <br>    hResult = lpAdminProviders-&gt;lpVtbl-&gt;GetProviderTable( <br>        lpAdminProviders, 0, &amp;lpTable); <br> <br>    if (hResult) <br>        goto ret; <br> <br>    hResult = lpTable-&gt;lpVtbl-&gt;SetColumns(lpTable, &amp;sptaProvider, 0L); <br> <br>    if (hResult) <br>        goto ret; <br> <br>    hResult = lpTable-&gt;lpVtbl-&gt;QueryRows(lpTable, 1, 0, &amp;lpRows); <br> <br>    if (hResult || !lpRows || !lpRows-&gt;cRows) <br>    { <br>        hResult = ResultFromScode(MAPI_E_NOT_FOUND); <br>        goto ret; <br>    } <br> <br>    Assert(lpRows-&gt;aRow[0].cValues == 1); <br>    lpProp = lpRows-&gt;aRow[0].lpProps; <br>    Assert(lpProp); <br>    Assert(lpProp-&gt;ulPropTag == PR_PROVIDER_UID); <br> <br>    /* Found the right property; use it to open our section */ <br> <br>    hResult = lpAdminProviders-&gt;lpVtbl-&gt;OpenProfileSection( <br>        lpAdminProviders, (LPMAPIUID) lpProp-&gt;Value.bin.lpb, <br>        NULL, MAPI_MODIFY, lppProfSect); <br> <br>ret: <br>    FreeProws(lpRows); <br>    UlRelease(lpTable); <br> <br>    DebugTraceResult(HrOpenSingleProvider, hResult); <br>    return hResult; <br>} <br> <br>/* <br> -  ScMergeLogonProps <br> - <br> *  Purpose: <br> *      This function merges a property array that the user passed into <br> *      ServiceEntry with the property array of Transport Logon props <br> *      found in the Profile.  This merged array is what either gets <br> *      passed into the XP Logon dialog (in the case when UI is requested) <br> *      or simply gets written out to the profile section for the <br> *      Transport Provider. <br> * <br> *  Parameters: <br> *      cProps1             - count of properties in the users array <br> *      lpProps1            - the users property array <br> *      cProps2             - count of properties from the XP profile <br> *      lpProps2            - property array from the XP profile <br> *      lpAllocBuff         - MAPI allocator used by ScDupPropset <br> *      lppPropsDest        - receives the newly built prop array <br> */ <br> <br>SCODE <br>ScMergeLogonProps( <br>    ULONG cProps1, <br>    LPSPropValue lpProps1, <br>    ULONG cProps2, <br>    LPSPropValue lpProps2, <br>    LPALLOCATEBUFFER lpAllocBuff, <br>    LPALLOCATEMORE lpAllocMore, <br>    LPSPropValue FAR * lppPropsDest) <br>{ <br>    SCODE sc; <br>    ULONG ulTag; <br>    TCHAR szEmpty[1] = ""; <br>    ULONG cT = cProps2; <br>    UINT cch; <br>    UINT id; <br>    LPTSTR lpszT; <br> <br>    /*  If any of the properties that we tried to read from the <br>        profile didn't exist, then the profile provider would return <br>        them to us as type PT_ERROR.  We will convert these to either <br>        empty strings or zeros before we try to merge in the user <br>        supplied values.  This will allow us to do parameter validation <br>        on the properties even if the user didn't ask for UI. */ <br> <br>    while (cT--) <br>    { <br>        ulTag = lpProps2[cT].ulPropTag; <br> <br>        if (PROP_TYPE(ulTag) == PT_ERROR) <br>        { <br>            id = (UINT)PROP_ID(ulTag); <br> <br>            switch (id) <br>            { <br>            case (UINT)PROP_ID(PR_SAMPLE_DISPLAY_NAME): <br>            case (UINT)PROP_ID(PR_SAMPLE_EMAIL_ADDR_TYPE): <br>            case (UINT)PROP_ID(PR_SAMPLE_EMAIL_ADDRESS): <br>            case (UINT)PROP_ID(PR_SAMPLE_INBOUND_DIR): <br>            case (UINT)PROP_ID(PR_SAMPLE_OUTBOUND_DIR): <br>            case (UINT)PROP_ID(PR_SAMPLE_FILENAME): <br>            case (UINT)PROP_ID(PR_SAMPLE_DIRECTORY): <br>            case (UINT)PROP_ID(PR_SAMPLE_LOGFILE): <br>            case (UINT)PROP_ID(PR_TEMP_LOGHIGHWATER): <br>            case (UINT)PROP_ID(PR_TEMP_LOGLOWWATER): <br>                lpProps2[cT].ulPropTag = PROP_TAG(PT_TSTRING, id); <br>                lpProps2[cT].Value.LPSZ = szEmpty; <br>                break; <br> <br>            case (UINT)PROP_ID(PR_SAMPLE_LOGHIGHWATER): <br>            case (UINT)PROP_ID(PR_SAMPLE_LOGLOWWATER): <br>            case (UINT)PROP_ID(PR_SAMPLE_FLAGS): <br>                lpProps2[cT].ulPropTag = PROP_TAG(PT_LONG, id); <br>                lpProps2[cT].Value.l = 0; <br>                break; <br> <br>            case (UINT)PROP_ID(PR_TEMP_PEER_TO_PEER): <br>            case (UINT)PROP_ID(PR_TEMP_UI_ALWAYS): <br>            case (UINT)PROP_ID(PR_TEMP_LOG_EVENTS): <br>            case (UINT)PROP_ID(PR_TEMP_SAVE_DATA): <br>                lpProps2[cT].ulPropTag = PROP_TAG(PT_BOOLEAN, id); <br>                lpProps2[cT].Value.b = FALSE; <br>                break; <br> <br>            default: <br>                DebugTrace("Got a bad PropTag in ScMergeLogonProps.\n"); <br>            } <br>        } <br>    } <br> <br>    /*  Now, replace the profile properties with those passed in by the <br>        user.  Check the ones of the type "File Path" to see that they <br>        have a slash as their last character.  If not, then add one. */ <br> <br>    while (cProps1--) <br>    { <br>        ulTag = lpProps1[cProps1].ulPropTag; <br> <br>        switch (ulTag) <br>        { <br>            /* Do the String properties first */ <br> <br>        case PR_SAMPLE_INBOUND_DIR: <br>        case PR_SAMPLE_OUTBOUND_DIR: <br>        case PR_SAMPLE_DIRECTORY: <br>            if (lpProps1[cProps1].Value.LPSZ) <br>            { <br>                cch = lstrlen(lpProps1[cProps1].Value.LPSZ); <br> <br>                if (cch &amp;&amp; lpProps1[cProps1].Value.LPSZ[cch - 1] != '\\') <br>                { <br>                    sc = lpAllocMore((cch + 2) * sizeof(TCHAR), <br>                        lpProps2, (LPVOID FAR *) &amp;lpszT); <br> <br>                    if (!FAILED(sc)) <br>                    { <br>                        lstrcpy(lpszT, lpProps1[cProps1].Value.LPSZ); <br>                        lpszT[cch] = '\\'; <br>                        lpszT[cch + 1] = '\0'; <br>                        ArrayIndex(ulTag, lpProps2).Value.LPSZ = lpszT; <br>                    } <br>                } <br>                else <br>                    ArrayIndex(ulTag, lpProps2).Value.LPSZ = lpProps1[cProps1].Value.LPSZ; <br>            } <br>            else <br>                ArrayIndex(ulTag, lpProps2).Value.LPSZ = szEmpty; <br> <br>            break; <br> <br>        case PR_SAMPLE_DISPLAY_NAME: <br>        case PR_SAMPLE_EMAIL_ADDR_TYPE: </code></pre>
<p>
</p>
<pre><code>case PR_SAMPLE_EMAIL_ADDRESS: <br>        case PR_SAMPLE_FILENAME: <br>        case PR_SAMPLE_LOGFILE: <br>            if (lpProps1[cProps1].Value.LPSZ) <br>                ArrayIndex(ulTag, lpProps2).Value.LPSZ = lpProps1[cProps1].Value.LPSZ; <br>            else <br>                ArrayIndex(ulTag, lpProps2).Value.LPSZ = szEmpty; <br> <br>            break; <br> <br>            /* Then the long values */ <br> <br>        case PR_SAMPLE_LOGHIGHWATER: <br>        case PR_SAMPLE_LOGLOWWATER: <br>        case PR_SAMPLE_FLAGS: <br>            ArrayIndex(ulTag, lpProps2).Value.l = lpProps1[cProps1].Value.l; <br>            break; <br> <br>            /* We have a bad value, lets return an error! */ <br> <br>        default: <br>            DebugTrace("Got a bad PropTag in ScMergeLogonProps()"); <br>            return E_INVALIDARG; <br>        } <br>    } <br> <br>    return ScDupPropset((int)cProps2, lpProps2, lpAllocBuff, lppPropsDest); <br>} <br> <br> <br>/* <br> -  HrDeleteDeferred <br> - <br> *  Purpose: <br> *      Removes a deferred message node from the list when the Spooler <br> *      does a NOTIFY_ABORT_DEFERRED. <br> * <br> *  Parameters: <br> *      lpxpl           The session owning the deferred message <br> *      lpsbinEID       EntryID of the deferred message to delete <br> * <br> *  Returns: <br> *      hResult         Indicating Success/Faailure <br> */ <br> <br>HRESULT <br>HrDeleteDeferred(LPXPL lpxpl, LPSBinary lpsbinEID) <br>{ <br>    LPDEFMSG lpDefMsg; <br>    LPDEFMSG *lppDefMsg = &amp;(lpxpl-&gt;lpDeferredList); <br> <br>    while (lpDefMsg = *lppDefMsg) <br>    { <br>        if ((lpDefMsg-&gt;sbinEIDDef.cb == lpsbinEID-&gt;cb) &amp;&amp; <br>            !memcmp(lpDefMsg-&gt;sbinEIDDef.lpb, <br>                    lpsbinEID-&gt;lpb, <br>                    (UINT)lpsbinEID-&gt;cb)) <br>        { <br>            *lppDefMsg = lpDefMsg-&gt;lpNext; <br>            break; <br>        } <br>        else <br>            lppDefMsg = &amp;(lpDefMsg-&gt;lpNext); <br>    } <br> <br>    lpxpl-&gt;FreeBuffer(lpDefMsg); <br> <br>    return hrSuccess; <br>} <br> <br> <br>/* <br> *  WizardEntry() <br> * <br> *  Purpose: <br> * <br> *      This is the initial entrypoint for the MAPI 1.0 configuration <br> *      wizard.  This function tells the wizard DLL how many pages the <br> *      configuration for this service requires as well as the dialog <br> *      procedure to call for each individual event. <br> * <br> *  Arguments: <br> * <br> *      hInstance       the instance of my dll, this can be used to <br> *                      retrieve resources out of my DLL, etc. <br> * <br> *      lppszRsrcName   [OUT]   on return, this buffer is filled with <br> *                              the full name of the dialog resource ID. <br> *                              Note that this requires the name to be a <br> *                              text value and not something generated <br> *                              with the MAKEINTRESOURCE() macro <br> * <br> *      lpfnDlgProc     [OUT]   on return, holds a function pointer to <br> *                              the dialog proc to call for each event <br> * <br> *      lpMapiProp      the pointer to a IMAPIProp object that is my <br> *                      interface to the profile. <br> * <br> *      lpsup           A profile suport object that can be used to <br> *                      get MAPI allocators <br> * <br> *  Returns: <br> * <br> *      (SCODE)         S_OK <br> */ <br> <br>ULONG STDAPICALLTYPE <br>WizardEntry (HINSTANCE hInstance, <br>    LPTSTR FAR * lppszRsrcName, <br>    DLGPROC FAR * lpfnDlgProc, <br>    LPMAPIPROP lpMapiProp, <br>    LPVOID lpsup) <br>{ <br>    const static TCHAR szWizTemplate[] = "SampleTransportWizard"; <br> <br>    Unreferenced (lpsup); <br>     <br>    /*  Should probably mutex access here */ <br> <br>    *lppszRsrcName = (LPTSTR)szWizTemplate; <br>    *lpfnDlgProc = (DLGPROC) WizardWndProc; <br>    lpmpWizard = lpMapiProp; <br>    UlAddRef (lpMapiProp); <br> <br>    return S_OK; <br>} <br> <br>/* <br> *  TogglePage() <br> * <br> *  Purpose: <br> * <br> *      Loops through the controls on a wizard page and eiter <br> *      enables/shows the control or hides/disables it. <br> */ <br> <br>VOID <br>TogglePage (HWND hdlg, UINT ipage, BOOL fEnable) <br>{ <br>    UINT ictl = 0; <br>    HANDLE hctl; <br> <br>    while (hctl = GetDlgItem (hdlg, (WIZ_BASE + (ipage * 10) + ictl++))) <br>    { <br>        EnableWindow(hctl, fEnable); <br>        ShowWindow (hctl, (fEnable ? SW_SHOW : SW_HIDE)); <br>    } <br>} <br> <br>BOOL STDAPICALLTYPE <br>WizardWndProc (HWND hDlg, <br>    UINT wMsgID, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    UINT cb; <br>    UINT cpageJump = 1; <br>    UINT idFocus = 0; <br> <br>    static fInited = FALSE; <br>    static UINT ipWiz = 0; <br>    static SPropValue rgvalWiz[cWizProps] = {0}; <br>    static CHAR rgchName[cchNameMax + 1] = {0}; <br>    static CHAR rgchType[cchTypeMax + 1] = {0}; <br>    static CHAR rgchUNC[MAX_PATH] = {0}; <br>    static CHAR rgchPath[MAX_PATH] = {0}; <br> <br>    switch (wMsgID) <br>    { <br>      case WM_INITDIALOG: <br> <br>        if (!fInited) <br>        { <br>            fInited = TRUE; <br>            SetWindowText (GetDlgItem (hDlg, IDC_TypeEdit), "MSPEER"); <br>            SendMessage (GetDlgItem (hDlg, IDC_TypeEdit), EM_LIMITTEXT, (WPARAM)cchTypeMax, 0); <br>            SendMessage (GetDlgItem (hDlg, IDC_NameEdit), EM_LIMITTEXT, (WPARAM)cchNameMax, 0); <br>            SendMessage (GetDlgItem (hDlg, IDC_UNCEdit), EM_LIMITTEXT, (WPARAM)MAX_PATH - 1, 0); <br>            SendMessage (GetDlgItem (hDlg, IDC_PathEdit), EM_LIMITTEXT, (WPARAM)MAX_PATH - 1, 0); <br>            rgvalWiz[ipDispName].ulPropTag = PR_NULL; <br>            rgvalWiz[ipEmailType].ulPropTag = PR_NULL; <br>            rgvalWiz[ipEmailAddress].ulPropTag = PR_NULL; <br>            rgvalWiz[ipInbox].ulPropTag = PR_NULL; <br>            rgvalWiz[ipOutbox].ulPropTag = PR_SAMPLE_OUTBOUND_DIR; <br>            rgvalWiz[ipOutbox].Value.lpszA = "\\TEMP"; <br>            rgvalWiz[ipFilename].ulPropTag = PR_NULL; <br>            rgvalWiz[ipDirectory].ulPropTag = PR_NULL; <br>            rgvalWiz[ipFlags].ulPropTag = PR_SAMPLE_FLAGS; <br>            rgvalWiz[ipFlags].Value.l = PR_SAMPLE_FLAG_PEER_TO_PEER | PR_SAMPLE_FLAG_SAVE_DATA; <br>            rgvalWiz[ipLogFile].ulPropTag = PR_SAMPLE_LOGFILE; <br>            rgvalWiz[ipLogFile].Value.lpszA = "SMPXP.LOG"; <br>            rgvalWiz[ipLogHigh].ulPropTag = PR_SAMPLE_LOGHIGHWATER; <br>            rgvalWiz[ipLogHigh].Value.l = 0; <br>            rgvalWiz[ipLogLow].ulPropTag = PR_SAMPLE_LOGLOWWATER; <br>            rgvalWiz[ipLogLow].Value.l = 0; <br>            DebugTrace ("MSPEER: Wizard page initialized\n"); <br>        } <br>        break; <br> <br>      case WIZ_QUERYNUMPAGES: <br> <br>        DebugTrace ("MSPEER: Wizard page count %d\n", cpageMax); <br>        return (BOOL)cpageMax; <br> <br>      case WM_CLOSE: <br> <br>        UlRelease (lpmpWizard); <br>        lpmpWizard = NULL; <br>        break; <br> <br>      case WM_COMMAND: <br> <br>        switch (LOWORD(wParam)) <br>        { <br>          case WIZ_NEXT: <br> <br>            switch (ipWiz) <br>            { <br>              case 0: <br>                idFocus = IDC_NameEdit; <br>                break; <br> <br>              case 1: <br> <br>                /*  Going from name page to address type */ <br> <br>                if (!(cb = (UINT)GetWindowText (GetDlgItem (hDlg, IDC_NameEdit), <br>                                        rgchName, cchNameMax + 1))) <br>                { <br>                    /*  We require a display name */ <br> <br>                    MessageBeep (0); <br>                    return 0; <br>                } <br>                rgvalWiz[ipDispName].ulPropTag = PR_SAMPLE_DISPLAY_NAME; <br>                rgvalWiz[ipDispName].Value.lpszA = rgchName; <br>                idFocus = IDC_TypeEdit; <br>                break; <br> <br>              case 2: <br> <br>                /* Going from type page to inbox */ <br> <br>                if (!(cb = (UINT)GetWindowText (GetDlgItem (hDlg, IDC_TypeEdit), <br>                                        rgchType, cchTypeMax + 1))) <br>                { <br>                    /*  We require an address type */ <br> <br>                    MessageBeep (0); <br>                    return 0; <br>                } <br>                rgvalWiz[ipEmailType].ulPropTag = PR_SAMPLE_EMAIL_ADDR_TYPE; <br>                rgvalWiz[ipEmailType].Value.lpszA = rgchType; <br>                idFocus = IDC_UNCEdit; <br>                break; <br> <br>              case 3: <br> <br>                /* Going from inbox page to path page */ <br> <br>                if (!(cb = (UINT)GetWindowText (GetDlgItem (hDlg, IDC_UNCEdit), <br>                                        rgchUNC, MAX_PATH))) <br>                { <br>                    /*  We require an address type */ <br> <br>                    MessageBeep (0); <br>                    return 0; <br>                } <br>                rgvalWiz[ipEmailAddress].ulPropTag = PR_SAMPLE_EMAIL_ADDRESS; <br>                rgvalWiz[ipEmailAddress].Value.lpszA = rgchUNC; <br>                idFocus = IDC_PathEdit; <br>                break; <br> <br>              case 4: <br> <br>                /* Going from the path page to completion*/ <br> <br>                rgvalWiz[ipInbox].ulPropTag = PR_SAMPLE_INBOUND_DIR; <br>                if ((cb = (UINT)GetWindowText (GetDlgItem (hDlg, IDC_PathEdit), rgchPath, MAX_PATH))) <br>                    rgvalWiz[ipInbox].Value.lpszA = rgchPath; <br>                else <br>                    rgvalWiz[ipInbox].Value.lpszA = rgvalWiz[ipEmailAddress].Value.lpszA; <br> <br>                Assert (lpmpWizard); <br>                lpmpWizard-&gt;lpVtbl-&gt;SetProps (lpmpWizard, cWizProps, rgvalWiz, NULL); <br>                break; <br> <br>              default: <br>                Assert (FALSE); <br>                break; <br>            } <br> <br>            /*  Disable Current Page */ <br>            TogglePage (hDlg, ipWiz, FALSE); <br> <br>            /*  Enable Next Page */ <br>            TogglePage (hDlg, ++ipWiz, TRUE); <br>            SetFocus (GetDlgItem (hDlg, idFocus)); <br>#ifdef  _WIN32 <br>            SendDlgItemMessage (hDlg, idFocus, EM_SETSEL, 0, -1); <br>#else <br>            SendDlgItemMessage (hDlg, idFocus, EM_SETSEL, 0, MAKELONG(0,-1)); <br>#endif <br>            return (BOOL)cpageJump; <br> <br>          case WIZ_PREV: <br> <br>            /*  Disable Current Page */ <br>            TogglePage (hDlg, ipWiz, FALSE); <br>             <br>            /*  Enable Previous Page */ <br>            TogglePage (hDlg, --ipWiz, TRUE); <br> <br>            switch (ipWiz) <br>            { <br>              case 1: <br>                idFocus = IDC_NameEdit; <br>                break; <br> <br>              case 2: <br>                idFocus = IDC_TypeEdit; <br>                break; <br> <br>              case 3: <br>                idFocus = IDC_UNCEdit; <br>                break; <br> <br>              case 4: <br>                idFocus = IDC_PathEdit; <br>                break; <br> <br>              default: <br>                break; <br>            } <br>            SetFocus (GetDlgItem (hDlg, idFocus)); <br>#ifdef  _WIN32 <br>            SendDlgItemMessage (hDlg, idFocus, EM_SETSEL, 0, -1); <br>#else <br>            SendDlgItemMessage (hDlg, idFocus, EM_SETSEL, 0, MAKELONG(0,-1)); <br>#endif <br>            return (BOOL)cpageJump; <br> <br>          default: <br> <br>            return FALSE; <br>        } <br>        break; <br> <br>      default: <br> <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
