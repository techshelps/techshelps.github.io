<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XPLOGGER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2148"></a>XPLOGGER.C</h2>
<pre><code>/* <br> -  X P L O G G E R . C <br> - <br> *  Purpose: <br> *      Code to support the Log File for the Sample Transport Provider. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "xppch.h" <br> <br>static HANDLE hLogHandle = INVALID_HANDLE_VALUE; <br>static DWORD dwLogLowWater = 0; <br>static DWORD dwLogHiWater = (DWORD) -1; <br>static TCHAR chLogFileName[MAX_PATH]; <br> <br>#define BUFSIZE 255             /* Size of buffer to use for LogPrintf */ <br>static TCHAR _xpbuf[BUFSIZE]; <br> <br> <br>/* <br> -  InitTransportLog <br> - <br> *  Purpose: <br> *      Called by TransportLogon() logic to start logging. <br> * <br> *  Parameters: <br> *      lpxpl               Session object. We'll need it <br> *                          to get the logfile name and <br> *                          size constraints. <br> *      ulFlags             Flags. Not used at present. <br> * <br> *  Returns: <br> *      hLogHandle          Handle of open Log File. <br> *      dwLogLowWater       "Low Water Mark" of Log File. <br> *      dwLogHiWater        "High Water Mark" of Log File. <br> *      chLogFileName       Filename of open Log File. <br> * <br> *  Operation: <br> *      If a file is already open, this transport session doesn't want to log <br> *      events, or the filename given is null, return to caller.  Open the  <br> *      file and save the filename into chLogFileName. Store water marks into  <br> *      the appropriate variables. Save the handle.  We grab the Critical <br> *      Section here because it is possible to Init the logging at times <br> *      other than TransportLogon.  This makes it necessary to protect this <br> *      section of code. <br> */ <br> <br>void <br>InitTransportLog(LPXPL lpxpl, ULONG ulFlags) <br>{ <br>    LPSPropValue lpPropArray = lpxpl-&gt;lpPropArray; <br>    ULONG ulSessFlags; <br>    LPTSTR lpszFileName; <br>    HANDLE hTempHandle; <br>    DWORD dwOffset; <br>    ULONG ulLow, ulHigh; <br> <br>    /*  Use the critical section here */ <br> <br>    EnterCriticalSection(&amp;(lpxpl-&gt;lpxppParent-&gt;csTransport)); <br> <br>    /*  Are we already logging? If so there's nothing to do here. */ <br> <br>    if (hLogHandle != INVALID_HANDLE_VALUE) <br>    { <br>        DebugTrace("Already logging to %s\n", chLogFileName); <br>        goto ret; <br>    } <br> <br>    /*  Logging isn't on. Would this session like it turned on? */ <br> <br>    ulSessFlags = (ArrayIndex(PR_SAMPLE_FLAGS, lpPropArray)).Value.ul; <br>    if (!(ulSessFlags &amp; PR_SAMPLE_FLAG_LOG_EVENTS)) <br>    { <br>        DebugTrace("Log flag isn't on, logfile won't be opened\n"); <br>        goto ret; <br>    } <br> <br>    /*  We're going to log if we can. Get the filename and see if it <br>        makes any sense. If so, try to open it. */ <br> <br>    lpszFileName = (ArrayIndex(PR_SAMPLE_LOGFILE, lpPropArray)).Value.LPSZ; <br>    if (!lpszFileName || !*lpszFileName) <br>    { <br>        DebugTrace("LogFile name wasn't given, logfile won't be opened\n"); <br>        goto ret; <br>    } <br> <br>    hTempHandle = CreateFile(lpszFileName, <br>        GENERIC_READ | GENERIC_WRITE, <br>        FILE_SHARE_READ, <br>        NULL, <br>        OPEN_ALWAYS, <br>        FILE_FLAG_WRITE_THROUGH | FILE_FLAG_RANDOM_ACCESS, <br>        NULL); <br> <br>    if (hTempHandle == INVALID_HANDLE_VALUE) <br>    { <br>        DebugTrace("Error %x opening logfile\n", GetLastError()); <br>        goto ret; <br>    } <br> <br>    /*  The log file is open. Seek to the end so we can resume logging. */ <br> <br>    dwOffset = SetFilePointer(hTempHandle, 0L, NULL, FILE_END); <br>    if (dwOffset == -1) <br>    { <br>        DebugTrace("Error %x seeking to end of logfile\n", GetLastError()); <br>        CloseHandle(hTempHandle); <br>        goto ret; <br>    } <br> <br>    /*  Get the relevant data into the local structures. */ <br> <br>    lstrcpy(chLogFileName, lpszFileName); <br>    hLogHandle = hTempHandle; <br> <br>    ulLow = (ArrayIndex(PR_SAMPLE_LOGLOWWATER, lpPropArray)).Value.ul; <br>    ulHigh = (ArrayIndex(PR_SAMPLE_LOGHIGHWATER, lpPropArray)).Value.ul; <br>    if (ulHigh) <br>    { <br>        dwLogHiWater = ulHigh * 1024; <br>        dwLogLowWater = ulLow * 1024; <br>    } <br> <br>ret: <br> <br>    /*  Release the critical section */ <br> <br>    LeaveCriticalSection(&amp;(lpxpl-&gt;lpxppParent-&gt;csTransport)); <br> <br>    return; <br>} <br> <br> <br>/* <br> -  DeInitTransportLog <br> - <br> *  Purpose: <br> *      Called by DeinitTransport() to turn off all session logging. <br> * <br> *  Parameters: <br> *      ulFlags             Flags. Not used at present. <br> * <br> *  Returns: <br> *      none. <br> * <br> *  Operation: <br> *      If we have a file open, try to close it. Reinitialize structures <br> *      whether we succeeded or not. <br> */ <br> <br>void <br>DeInitTransportLog(ULONG ulFlags) <br>{ <br>    if (hLogHandle != INVALID_HANDLE_VALUE) <br>    { <br>        if (!CloseHandle(hLogHandle)) <br>            DebugTrace("Unable to close logfile %s\n", chLogFileName); <br> <br>        hLogHandle = INVALID_HANDLE_VALUE; <br>        dwLogHiWater = (DWORD) -1L; <br>        dwLogLowWater = 0; <br>        *chLogFileName = '\0'; <br>    } <br>} <br> <br> <br>/* <br> -  PrintfTransportLog <br> - <br> *  Purpose: <br> *      Called by various parts of the Transport to log information (if <br> *      logging is currently active). <br> * <br> *  Parameters: <br> *      fmt                 Start of variable argument list. <br> * <br> *  Returns: <br> *      none. <br> * <br> *  Operation: <br> *      Format the input data and call PutsTransportLog to write to logfile. <br> *      Current maximum length permitted is 255 characters (and is NOT <br> *      protected!). <br> */ <br> <br>void __cdecl <br>PrintfTransportLog(LPTSTR fmt,...) <br>{ <br>    va_list marker; <br> <br>    va_start(marker, fmt); <br> <br>    if (hLogHandle != INVALID_HANDLE_VALUE) <br>    { <br>        if (wvsprintf((LPTSTR) _xpbuf, fmt, marker)) <br>            PutsTransportLog((LPTSTR) _xpbuf); <br>    } <br> <br>    va_end(marker); <br>} <br> <br> <br>/* <br> -  PutsTransportLog <br> - <br> *  Purpose: <br> *      Called mostly by PrintfTransportLog. Writes a single line to the <br> *      logfile if it's open. <br> * <br> *  Parameters: <br> *      str                 String that wants to be written. <br> * <br> *  Returns: <br> *      none. <br> * <br> *  Operation: <br> *      If we have set a high water mark, get the current logfile size. If it <br> *      exceeds the high water mark, move back by the amount of the low water <br> *      mark, find a line ending, read everything to the end, write to the <br> *      front of the file, and truncate to that location. <br> * <br> *      Create a line consisting of the date and time, the input string, and <br> *      line ending characters. Write this line to the logfile. <br> */ <br> <br>void <br>PutsTransportLog(LPTSTR str) <br>{ <br>    DWORD cWritten; <br>    SYSTEMTIME stOurTime; <br>    TCHAR tchData[512]; <br>    HGLOBAL hGlobal = (HGLOBAL) 0L; <br>    LPVOID lpvBuf = NULL; <br> <br>    if (hLogHandle == INVALID_HANDLE_VALUE) <br>        return; <br> <br>    /*  See if we want to be adjusting the file size. */ <br> <br>    if (dwLogHiWater != -1) <br>    { <br>        DWORD finfo; <br> <br>        /*  Get the current file size */ <br> <br>        finfo = GetFileSize(hLogHandle, NULL); <br> <br>        if (finfo == 0xFFFFFFFF) <br>        { <br>            DebugTrace("Error %x getting logfile info\n", GetLastError()); <br>            DeInitTransportLog(LOG_DEINIT_HURRY); <br>            return; <br>        } <br> <br>        /*  Is it time to trim back? If so, let's do it. */ <br> <br>        if (finfo &gt; dwLogHiWater) <br>        { <br>            DWORD dwOffset; <br>            ULONG ulT, ulLowWater; <br>            char *lpbT; <br> <br>            /*  Allocate a buffer to read dwLogLowWater bytes. If <br>                dwLogLowWater &gt; 32K, use 32K. */ <br> <br>            ulLowWater = (dwLogLowWater &gt; 32000L ? 32000L : dwLogLowWater); <br>            if (ulLowWater == 0L) <br>                goto Truncate; <br> <br>            hGlobal = GlobalAlloc(GPTR, (UINT) ulLowWater); <br>            if (hGlobal == NULL) <br>            { <br>                DebugTrace("Attempt to GlobalAlloc %l bytes for lowwater buffer failed\n", ulLowWater); <br>                goto Truncate; <br>            } <br> <br>            lpvBuf = (LPVOID) GlobalLock(hGlobal); <br>            if (lpvBuf == NULL) <br>            { <br>                DebugTrace("Attempt to Lock allocated memory buffer failed\n"); <br>                goto Truncate; <br>            } <br> <br>            /*  Reposition the pointer back by the size of ulLowWater. */ <br> <br>            dwOffset = SetFilePointer(hLogHandle, 0L - ulLowWater, NULL, FILE_CURRENT); <br>            if (dwOffset == -1) <br>            { <br>                DebugTrace("Error %x seeking to low water mark\n", GetLastError()); <br>                DeInitTransportLog(LOG_DEINIT_HURRY); <br>                return; <br>            } <br> <br>            /*  Read (ulLowWater) bytes from that position. */ <br> <br>            if (!ReadFile(hLogHandle, lpvBuf, ulLowWater, &amp;cWritten, NULL)) <br>            { <br>                DebugTrace("Attempt to read %l bytes for low water copy failed, error = %lx\n", ulLowWater, GetLastError()); <br>                goto Truncate; <br>            } <br> <br>            Assert(cWritten == ulLowWater); <br> <br>            /*  Find the first newline from that point */ <br> <br>            for (ulT = 0, lpbT = (char *)lpvBuf; ulT &lt; ulLowWater; lpbT++, ulT++) <br>            { <br>                if (*lpbT == '\n') <br>                    break; <br>            } <br> <br>            /* Did the search fail? If so, truncate the file to zero. */ <br> <br>            if (ulT == ulLowWater) <br>            { <br>                ulLowWater = 0L; <br>Truncate: <br>                /*  We failed for some reason. Deallocate the buffer if <br>                    any and truncate the file to ulLowWater. */ <br> <br>                if (lpvBuf) <br>                    GlobalUnlock(hGlobal); <br>                if (hGlobal) <br>                    (void)GlobalFree(hGlobal); <br> <br>                dwOffset = SetFilePointer(hLogHandle, ulLowWater, NULL, FILE_BEGIN); <br>                if (dwOffset == -1) <br>                { <br>                    DebugTrace("Error %x seeking to low water mark\n", GetLastError()); <br>                    DeInitTransportLog(LOG_DEINIT_HURRY); <br>                    return; <br>                } <br>                goto Adjusted; <br>            } <br> <br>            /*  We found a newline. Skip over it and write the remaining <br>                data from the file start, if any. */ <br> <br>            ulT++; <br>            lpbT++; <br> <br>            dwOffset = SetFilePointer(hLogHandle, 0L, NULL, FILE_BEGIN); <br>            if (dwOffset == -1) <br>            { <br>                if (lpvBuf) <br>                    GlobalUnlock(hGlobal); <br>                if (hGlobal) <br>                    (void)GlobalFree(hGlobal); <br> <br>                DebugTrace("Error %x seeking to file start\n", GetLastError()); <br>                DeInitTransportLog(LOG_DEINIT_HURRY); <br>                return; <br>            } <br> <br>            if (ulT &lt; ulLowWater) <br>            { <br>                cWritten = 0; <br>                WriteFile(hLogHandle, (LPVOID) lpbT, (DWORD) (ulLowWater - ulT), &amp;cWritten, NULL); <br>                Assert((cWritten + ulT) == ulLowWater); <br>            } <br> <br>            GlobalUnlock(hGlobal); <br>            GlobalFree(hGlobal); <br> <br>Adjusted: <br>            if (!SetEndOfFile(hLogHandle)) <br>            { <br>                DebugTrace("Error %x setting EOF\n", GetLastError()); <br>                DeInitTransportLog(LOG_DEINIT_HURRY); <br>                return; <br>            } <br>        } <br>    } <br> <br>    /* We can't handle more than 490 characters on a input line. */ <br> <br>    Assert(lstrlen(str) &lt; 490L); <br> <br>    GetLocalTime(&amp;stOurTime); <br>    wsprintf(tchData, TEXT("%04d/%02d/%02d %02d:%02d:%02d %s\r\n"), <br>        stOurTime.wYear, stOurTime.wMonth, stOurTime.wDay, <br>        stOurTime.wHour, stOurTime.wMinute, stOurTime.wSecond, <br>        str); <br> <br>    WriteFile(hLogHandle, tchData, (DWORD) (lstrlen(tchData) * sizeof(TCHAR)), &amp;cWritten, NULL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
