<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2232"></a>CLIENT.C</h2>
<pre><code>/* <br> -  C L I E N T . C <br> - <br> *  Purpose: <br> *      Sample mail client for the MAPI 1.0 PDK. <br> *              Exclusively uses the Simple MAPI interface. <br> * <br> *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved. <br> */ <br> <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;mapiwin.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include "client.h" <br>#include "bitmap.h" <br>#include "pvalloc.h" <br> <br>HANDLE hInst; <br>HINSTANCE hlibMAPI = 0; <br> <br>LPMAPILOGON lpfnMAPILogon = NULL; <br>LPMAPILOGOFF lpfnMAPILogoff = NULL; <br>LPMAPISENDMAIL lpfnMAPISendMail = NULL; <br>LPMAPISENDDOCUMENTS lpfnMAPISendDocuments = NULL; <br>LPMAPIFINDNEXT lpfnMAPIFindNext = NULL; <br>LPMAPIREADMAIL lpfnMAPIReadMail = NULL; <br>LPMAPISAVEMAIL lpfnMAPISaveMail = NULL; <br>LPMAPIDELETEMAIL lpfnMAPIDeleteMail = NULL; <br>LPMAPIFREEBUFFER lpfnMAPIFreeBuffer = NULL; <br>LPMAPIADDRESS lpfnMAPIAddress = NULL; <br>LPMAPIDETAILS lpfnMAPIDetails = NULL; <br>LPMAPIRESOLVENAME lpfnMAPIResolveName = NULL; <br> <br>/* Static Data */ <br> <br>static BOOL fDialogIsActive = FALSE; <br>static DWORD cUsers = 0; <br>static ULONG flSendMsgFlags = 0; <br>static LHANDLE lhSession = 0L; <br>static HBITMAP hReadBmp = 0; <br>static HBITMAP hReadABmp = 0; <br>static HBITMAP hUnReadBmp = 0; <br>static HBITMAP hUnReadABmp = 0; <br>static HCURSOR hWaitCur; <br>static LPMSGID lpReadMsgNode; <br>static lpMapiMessage lpmsg = NULL; <br> <br>#ifdef _WIN32 <br>#define szMAPIDLL       "MAPI32.DLL" <br>#else <br>#define szMAPIDLL       "MAPI.DLL" <br>#endif <br> <br>int WINAPI <br>WinMain (HINSTANCE hInstance, HINSTANCE hPrevInst, LPSTR lpszCmd, int nCmdShow) <br>{ <br>    MSG msg; <br> <br>    if (!hPrevInst) <br>    if (!InitApplication (hInstance)) <br>        return (FALSE); <br> <br>    if (!InitInstance (hInstance, nCmdShow)) <br>    return (FALSE); <br> <br>    while (GetMessage (&amp;msg, 0, 0, 0)) <br>    { <br>    TranslateMessage (&amp;msg); <br>    DispatchMessage (&amp;msg); <br>    } <br> <br>    DeinitApplication (); <br> <br>    return (msg.wParam); <br>} <br> <br>/* <br> -  InitApplication <br> - <br> *  Purpose: <br> *      Initialize the application. <br> * <br> *  Parameters: <br> *      hInstance   - Instance handle <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL <br>InitApplication (HANDLE hInstance) <br>{ <br>    WNDCLASS wc; <br> <br>    wc.style = 0; <br>    wc.lpfnWndProc = MainWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon (hInstance, "NoMail"); <br>    wc.hCursor = LoadCursor (0, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject (WHITE_BRUSH); <br>    wc.lpszMenuName = "MailMenu"; <br>    wc.lpszClassName = "Client"; <br> <br>    return (RegisterClass (&amp;wc)); <br>} <br> <br>/* <br> -  InitInstance <br> - <br> *  Purpose: <br> *      Initialize this instance. <br> * <br> *  Parameters: <br> *      hInstance   - Instance handle <br> *      nCmdShow    - Do we show the window? <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL <br>InitInstance (HANDLE hInstance, int nCmdShow) <br>{ <br>    HWND hWnd; <br>    BOOL fInit; <br>    ULONG ulResult; <br> <br>    hInst = hInstance; <br> <br>    hWnd = CreateWindow ("Client", "MAPI Sample Mail Client", <br>        WS_OVERLAPPEDWINDOW, 5, 5, 300, 75, 0, 0, hInst, NULL); <br> <br>    if (!hWnd) <br>    return (FALSE); <br> <br>    ShowWindow (hWnd, nCmdShow); <br>    UpdateWindow (hWnd); <br> <br>    hWaitCur = LoadCursor(0, IDC_WAIT); <br> <br>    if (fInit = InitSimpleMAPI ()) <br>    { <br>     <br>        /* MAPILogon might yield control to Windows. So to prevent the user <br>        from clicking "logon" while we are in the process of loggin on we <br>        have to disable it*/ <br>        SecureMenu(hWnd, TRUE); <br>         <br>        if ((ulResult = MAPILogon ((ULONG) hWnd, NULL, NULL, <br>            MAPI_LOGON_UI | MAPI_NEW_SESSION, <br>            0, &amp;lhSession)) == SUCCESS_SUCCESS) <br>        { <br>            ToggleMenuState (hWnd, TRUE); <br>        } <br>        else <br>        { <br>            SecureMenu(hWnd, FALSE); <br>            lhSession = 0; <br>            MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR); <br>        } <br>    } <br> <br>    return (fInit); <br>} <br> <br>/* <br> -  InitSimpleMAPI <br> - <br> *  Purpose: <br> *      Loads the DLL containing the simple MAPI functions and sets <br> *      up a pointer to each. Wrappers for the  function pointers <br> *      are declared in SMAPI.H. <br> * <br> *  Returns: <br> *      TRUE if sucessful, else FALSE <br> * <br> *  Side effects: <br> *      Loads a DLL and sets up function pointers <br> */ <br>BOOL <br>InitSimpleMAPI (void) <br>{ <br>    UINT fuError; <br> <br>    /* <br>     *Check if MAPI is installed on the system <br>     */ <br>    if(!fSMAPIInstalled()) <br>        return FALSE; <br> <br>    fuError = SetErrorMode(SEM_NOOPENFILEERRORBOX); <br>    hlibMAPI = LoadLibrary(szMAPIDLL); <br>    SetErrorMode(fuError); <br> <br>#ifdef _WIN32 <br>    if (!hlibMAPI) <br>#else <br>    if (hlibMAPI &lt; 32) <br>#endif <br>    return (FALSE); <br> <br>    if (!(lpfnMAPILogon = (LPMAPILOGON) GetProcAddress (hlibMAPI, "MAPILogon"))) <br>    return (FALSE); <br>    if (!(lpfnMAPILogoff = (LPMAPILOGOFF) GetProcAddress (hlibMAPI, "MAPILogoff"))) <br>    return (FALSE); <br>    if (!(lpfnMAPISendMail = (LPMAPISENDMAIL) GetProcAddress (hlibMAPI, "MAPISendMail"))) <br>    return (FALSE); <br>    if (!(lpfnMAPISendDocuments = (LPMAPISENDDOCUMENTS) GetProcAddress (hlibMAPI, "MAPISendDocuments"))) <br>    return (FALSE); <br>    if (!(lpfnMAPIFindNext = (LPMAPIFINDNEXT) GetProcAddress (hlibMAPI, "MAPIFindNext"))) <br>    return (FALSE); <br>    if (!(lpfnMAPIReadMail = (LPMAPIREADMAIL) GetProcAddress (hlibMAPI, "MAPIReadMail"))) <br>    return (FALSE); <br>    if (!(lpfnMAPISaveMail = (LPMAPISAVEMAIL) GetProcAddress (hlibMAPI, "MAPISaveMail"))) <br>    return (FALSE); <br>    if (!(lpfnMAPIDeleteMail = (LPMAPIDELETEMAIL) GetProcAddress (hlibMAPI, "MAPIDeleteMail"))) <br>    return (FALSE); <br>    if (!(lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER) GetProcAddress (hlibMAPI, "MAPIFreeBuffer"))) <br>    return (FALSE); <br>    if (!(lpfnMAPIAddress = (LPMAPIADDRESS) GetProcAddress (hlibMAPI, "MAPIAddress"))) <br>    return (FALSE); <br>    if (!(lpfnMAPIDetails = (LPMAPIDETAILS) GetProcAddress (hlibMAPI, "MAPIDetails"))) <br>    return (FALSE); <br>    if (!(lpfnMAPIResolveName = (LPMAPIRESOLVENAME) GetProcAddress (hlibMAPI, "MAPIResolveName"))) <br>    return (FALSE); <br> <br>    return (TRUE); <br>} <br> <br>/* <br> -  fSMAPIInstalled <br> - <br> *  Purpose: <br> *      Checks the appropriate win.ini/registry value to see if Simple MAPI is <br> *      installed in the system.  <br> *   <br> *  Returns: <br> *      TRUE if Simple MAPI is installed, else FALSE <br> * <br> */ <br>BOOL <br>fSMAPIInstalled(void) <br>{ <br>#ifdef _WIN32 <br>    /* on win32, if it's NT 3.51 or lower the value to check is  <br>        win.ini \ [Mail] \ MAPI, otherwise it's a registry value <br>        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows Messaging Subsystem\MAPI <br>    */ <br>     <br>    OSVERSIONINFO osvinfo; <br>    LONG lr; <br>    HKEY hkWMS; <br>     <br>    #define MAPIVSize 8 <br>    char szMAPIValue[MAPIVSize]; <br>    DWORD dwType; <br>    DWORD cbMAPIValue = MAPIVSize; <br> <br>    osvinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); <br> <br>    if(!GetVersionEx(&amp;osvinfo)) <br>        return FALSE; <br> <br>    if( osvinfo.dwMajorVersion &gt; 3 || <br>        (osvinfo.dwMajorVersion == 3 &amp;&amp; osvinfo.dwMinorVersion &gt; 51)) <br>    { //check the registry value <br>        lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, <br>                        "SOFTWARE\\Microsoft\\Windows Messaging Subsystem", <br>                         0, KEY_READ, &amp;hkWMS); <br>        if(ERROR_SUCCESS == lr) <br>        { <br>            lr = RegQueryValueEx(hkWMS, "MAPI", 0, &amp;dwType, szMAPIValue, &amp;cbMAPIValue); <br>            RegCloseKey(hkWMS); <br>            if(ERROR_SUCCESS == lr) <br>            { <br>                Assert(dwType == REG_SZ); <br>                if(lstrcmp(szMAPIValue, "1") == 0) <br>                    return TRUE; <br>            } <br>        } <br>         <br>        return FALSE; <br>    } <br> <br>    /* fall through*/ <br>#endif /*_WIN32*/ <br>     <br>    /*check the win.ini value*/ <br>    return GetProfileInt("Mail", "MAPI", 0); <br>     <br>} <br> <br> <br>void <br>DeinitApplication () <br>{ <br>    DeinitSimpleMAPI (); <br>} <br> <br>void <br>DeinitSimpleMAPI () <br>{ <br>    if (hlibMAPI) <br>    { <br>    FreeLibrary (hlibMAPI); <br>    hlibMAPI = 0; <br>    } <br>} <br> <br>/* <br> -  MainWndProc <br> - <br> *  Purpose: <br> *      Main Window Procedure for test program. <br> * <br> *  Parameters: <br> *      hWnd <br> *      message <br> *      wParam <br> *      lParam <br> * <br> *  Returns: <br> * <br> * <br> */ <br> <br>LONG FAR PASCAL <br>MainWndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    ULONG ulResult; <br> <br>    switch (msg) <br>    { <br>    case WM_COMMAND: <br>    switch (LOWORD (wParam)) <br>    { <br>    case IDM_LOGON: <br>        if (!lhSession) <br>        { <br>        /* MAPILogon might yield control to Windows. So to prevent the user <br>        from clicking "logon" while we are in the process of loggin on we <br>        have to disable it*/ <br>        SecureMenu(hWnd, TRUE); <br> <br>        if ((ulResult = MAPILogon ((ULONG) hWnd, NULL, NULL, <br>                MAPI_LOGON_UI | MAPI_NEW_SESSION, <br>                0, &amp;lhSession)) == SUCCESS_SUCCESS) <br>        { <br>            ToggleMenuState (hWnd, TRUE); <br>        } <br>        else <br>        { <br>            SecureMenu(hWnd, FALSE); <br>            lhSession = 0; <br>            MakeMessageBox (hWnd, ulResult, IDS_LOGONFAIL, MBS_ERROR); <br>        } <br>        } <br>        break; <br> <br>    case IDM_LOGOFF: <br>        if (lhSession) <br>        { <br>        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0); <br>        ToggleMenuState (hWnd, FALSE); <br>        lhSession = 0; <br>        } <br>        break; <br> <br>    case IDM_COMPOSE: <br>            fDialogIsActive = TRUE;  <br>        DialogBox (hInst, "ComposeNote", hWnd, ComposeDlgProc); <br>            fDialogIsActive = FALSE;         <br>        break; <br> <br>    case IDM_READ: <br>            fDialogIsActive = TRUE;  <br>        DialogBox (hInst, "InBox", hWnd, InBoxDlgProc); <br>            fDialogIsActive = FALSE;         <br>        break; <br> <br>    case IDM_SEND: <br>        if(lhSession) <br>            { <br>                MapiMessage msgSend; <br> <br>                memset(&amp;msgSend, 0, sizeof(MapiMessage)); <br>                fDialogIsActive = TRUE;  <br>                MAPISendMail(lhSession, (ULONG)hWnd, &amp;msgSend, MAPI_DIALOG, 0L); <br>                fDialogIsActive = FALSE;         <br>            } <br>        break; <br> <br>    case IDM_ADDRBOOK: <br>        if (lhSession) <br>        { <br>                fDialogIsActive = TRUE;  <br>        if ((ulResult = MAPIAddress (lhSession, (ULONG) hWnd, <br>                NULL, 0, NULL, 0, NULL, 0, 0, NULL, NULL))) <br>        { <br>            if (ulResult != MAPI_E_USER_ABORT) <br>            MakeMessageBox (hWnd, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR); <br>        } <br>                fDialogIsActive = FALSE;         <br>        } <br>        break; <br> <br>    case IDM_DETAILS: <br>        if (lhSession) <br>            { <br>                fDialogIsActive = TRUE;  <br>        DialogBox(hInst, "Details", hWnd, DetailsDlgProc); <br>                fDialogIsActive = FALSE;         <br>            } <br>        break; <br> <br>    case IDM_ABOUT: <br>            fDialogIsActive = TRUE;  <br>        DialogBox (hInst, "AboutBox", hWnd, AboutDlgProc); <br>            fDialogIsActive = FALSE;         <br>        break; <br> <br>    case IDM_EXIT: <br>        if (lhSession) <br>        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0); <br> <br>        PostQuitMessage (0); <br>        break; <br> <br>    default: <br>        return (DefWindowProc (hWnd, msg, wParam, lParam)); <br>    } <br>    break; <br> <br>    case WM_QUERYENDSESSION: <br>    {        <br> <br>        /* <br>         *      If we have a modal dialog open (all our dialogs are modal, so <br>         *      just see if we have a dialog open), veto the shutdown. <br>         */ <br> <br>        if (fDialogIsActive) <br>        { <br>            LPCSTR szTitle = "MAPI Sample Mail Client";  <br>            char szText[256];  <br> <br>        LoadString (hInst, IDS_DIALOGACTIVE, szText, 255); <br> <br>        #ifdef WIN16 <br>            MessageBox((HWND)NULL, szText, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL); <br>        #else <br>            MessageBoxA(NULL, szText, szTitle, MB_OK | MB_ICONSTOP | MB_TASKMODAL | MB_SETFOREGROUND); <br>        #endif <br>        return FALSE; <br>        } <br> <br>        else <br>        { <br>        return TRUE; <br>        } <br>    } <br> <br>    case WM_ENDSESSION: <br> <br>        if (wParam) <br>        { <br>        DestroyWindow (hWnd); <br>        } <br> <br>    break; <br> <br>    case WM_CLOSE: <br>    case WM_DESTROY: <br>    if (lhSession) <br>        MAPILogoff (lhSession, (ULONG) hWnd, 0, 0); <br> <br>    PostQuitMessage (0); <br>    break; <br> <br>    default: <br>    return (DefWindowProc (hWnd, msg, wParam, lParam)); <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> -  AboutDlgProc <br> - <br> *  Purpose: <br> *      About box dialog procedure <br> * <br> *  Parameters: <br> *      hDlg <br> *      message <br> *      wParam <br> *      lParam <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL FAR PASCAL <br>AboutDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br> <br>#include &lt;pdkver.h&gt; <br> <br>    char    rgchVersion[80]; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>        wsprintf(rgchVersion, "Version %d.%d.%d (%s)", rmj, rmm, rup, <br>            szVerName &amp;&amp; *szVerName ? szVerName : "BUDDY"); <br>        SetDlgItemText(hDlg, IDC_VERSION, rgchVersion); <br>    return TRUE; <br> <br>    case WM_COMMAND: <br>    if (wParam == IDOK || wParam == IDCANCEL) <br>    { <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>    } <br>    break; <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> -  OptionsDlgProc <br> - <br> *  Purpose: <br> *      Message Options dialog procedure <br> * <br> *  Parameters: <br> *      hDlg <br> *      message <br> *      wParam <br> *      lParam <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL FAR PASCAL <br>OptionsDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>    CheckDlgButton (hDlg, IDC_RETURN, <br>        !!(flSendMsgFlags &amp; MAPI_RECEIPT_REQUESTED)); <br>    return TRUE; <br> <br>    case WM_COMMAND: <br>    switch (LOWORD (wParam)) <br>    { <br>    case IDOK: <br>        if (IsDlgButtonChecked (hDlg, IDC_RETURN)) <br>        flSendMsgFlags |= MAPI_RECEIPT_REQUESTED; <br>        else <br>        flSendMsgFlags &amp;= ~MAPI_RECEIPT_REQUESTED; <br> <br>    case IDCANCEL: <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>    } <br>    break; <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> -  DetailsDlgProc <br> - <br> *  Purpose: <br> *      User Details dialog procedure <br> * <br> *  Parameters: <br> *      hDlg <br> *      message <br> *      wParam <br> *      lParam <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL FAR PASCAL <br>DetailsDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    LPSTR lpszType = NULL; <br>    LPSTR lpszAddr = NULL; <br>    LPSTR lpszName; <br>    ULONG cRecips; <br>    ULONG ulResult; <br>    lpMapiRecipDesc lpRecip = NULL; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>    while(!lpRecip) <br>    { <br>        if ((ulResult = MAPIAddress (lhSession, (ULONG) hDlg, <br>            "Select One User", 1, "User:", 0, NULL, 0, 0, <br>            &amp;cRecips, &amp;lpRecip))) <br>        { <br>        if (ulResult != MAPI_E_USER_ABORT) <br>            MakeMessageBox (hDlg, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR); <br> <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>        } <br> <br>        if (cRecips == 0) <br>        { <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>        } <br> <br>        if (cRecips &gt; 1) <br>        { <br>        cRecips = 0; <br>        MAPIFreeBuffer (lpRecip); <br>        lpRecip = NULL; <br>        MakeMessageBox (hDlg, 0, IDS_DETAILS_TOO_MANY, MBS_OOPS); <br>        } <br>    } <br>    lpszName = lpRecip-&gt;lpszName; <br>    if(lpRecip-&gt;lpszAddress) <br>    { <br>        lpszType = strtok(lpRecip-&gt;lpszAddress, ":"); <br>        lpszAddr = strtok(NULL, "\n"); <br>    } <br> <br>    SetDlgItemText(hDlg, IDC_NAME, lpszName); <br>    SetDlgItemText(hDlg, IDC_TYPE, (lpszType ? lpszType : "MSPEER")); <br>    SetDlgItemText(hDlg, IDC_ADDR, (lpszAddr ? lpszAddr : "")); <br> <br>    MAPIFreeBuffer (lpRecip); <br>    return TRUE; <br> <br>    case WM_COMMAND: <br>    if(LOWORD(wParam) == IDC_CLOSE || LOWORD(wParam) ==IDCANCEL) <br>    { <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>    } <br>    break; <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> -  ComposeDlgProc <br> - <br> *  Purpose: <br> *      Dialog procedure for the ComposeNote dialog. <br> * <br> *  Parameters: <br> *      hDlg <br> *      message <br> *      wParam <br> *      lParam <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL FAR PASCAL <br>ComposeDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    char szUnResNames[TO_EDIT_MAX]; <br>    char szDisplayNames[TO_EDIT_MAX]; <br>   /* char szAttach[FILE_ATTACH_MAX];*/ <br>    BOOL fUnResTo, fUnResCc; <br>    LONG cb, cLines; <br>    ULONG ulResult; <br>    HCURSOR hOldCur; <br>    static LPSTR lpszSubject; <br>    static LPSTR lpszNoteText; <br>    static ULONG cRecips; <br>    static ULONG cNewRecips; <br>    static ULONG cAttach; <br>    static lpMapiRecipDesc lpRecips; <br>    static lpMapiRecipDesc lpNewRecips; <br>    static lpMapiFileDesc lpAttach; <br>    ULONG idx; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>    if (lpmsg) <br>    { <br>        /* ComposeNote is being called to either forward or reply */ <br>        /* to a message in the Inbox.  So, we'll initialize the   */ <br>        /* ComposeNote form with data from the global MapiMessage */ <br> <br>        lpszSubject = lpmsg-&gt;lpszSubject; <br>        lpszNoteText = lpmsg-&gt;lpszNoteText; <br>        cRecips = lpmsg-&gt;nRecipCount; <br>        cAttach = lpmsg-&gt;nFileCount; <br>        lpRecips = lpmsg-&gt;lpRecips; <br>        lpAttach = lpmsg-&gt;lpFiles; <br> <br>        if (cRecips) <br>        { <br>        MakeDisplayNameStr (szDisplayNames, MAPI_TO, <br>            cRecips, lpRecips); <br>        if (*szDisplayNames) <br>            SetDlgItemText (hDlg, IDC_TO, szDisplayNames); <br> <br>        MakeDisplayNameStr (szDisplayNames, MAPI_CC, <br>            cRecips, lpRecips); <br>        if (*szDisplayNames) <br>            SetDlgItemText (hDlg, IDC_CC, szDisplayNames); <br>        } <br>        SetDlgItemText (hDlg, IDC_SUBJECT, lpmsg-&gt;lpszSubject); <br>        SetDlgItemText (hDlg, IDC_NOTE, lpmsg-&gt;lpszNoteText); <br>        if (!cAttach) <br>        { <br>            EnableWindow (GetDlgItem (hDlg, IDC_CATTACHMENT), FALSE); <br>        EnableWindow (GetDlgItem (hDlg, IDT_CATTACHMENT), FALSE); <br>        } <br>        else <br>        { <br>            for(idx = 0; idx &lt; cAttach; idx++) <br>            if (lpAttach[idx].lpszFileName) <br>                SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_ADDSTRING, 0, <br>                (LPARAM)lpAttach[idx].lpszFileName); <br> <br>           /*SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_SETCURSEL, 0, 0L);*/ <br>        } <br> <br>        SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0); <br>        SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0); <br>        SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_SETMODIFY, FALSE, 0); <br>        SendDlgItemMessage (hDlg, IDC_NOTE, EM_SETMODIFY, FALSE, 0); <br>        if(cRecips) <br>        SetFocus (GetDlgItem (hDlg, IDC_NOTE)); <br>        else <br>        SetFocus (GetDlgItem (hDlg, IDC_TO)); <br>    } <br>    else <br>    { <br>        lpmsg = (lpMapiMessage)PvAlloc(sizeof(MapiMessage)); <br> <br>        if (!lpmsg) <br>        goto cleanup; <br> <br>            memset (lpmsg, 0, sizeof (MapiMessage)); <br> <br>        lpszSubject = NULL; <br>        lpszNoteText = NULL; <br>        cRecips = 0; <br>        cAttach = 0; <br>        lpRecips = NULL; <br>        lpNewRecips = NULL; <br>        lpAttach = NULL; <br> <br>        lpmsg-&gt;flFlags = flSendMsgFlags; <br>        SetFocus (GetDlgItem (hDlg, IDC_TO)); <br>    } <br>    return FALSE; <br> <br>    case WM_COMMAND: <br>    switch (LOWORD (wParam)) <br>    { <br>    case IDC_ATTACH: <br>        if (GetNextFile (hDlg, (ULONG) -1, &amp;cAttach, &amp;lpAttach) == SUCCESS_SUCCESS) <br>        { <br>                /* if the first attachment */ <br>                if (cAttach == 1) <br>                { <br>                    EnableWindow (GetDlgItem (hDlg, IDC_CATTACHMENT), TRUE); <br>            EnableWindow (GetDlgItem (hDlg, IDT_CATTACHMENT), TRUE); <br>                } <br> <br>                if (lpAttach[cAttach - 1].lpszFileName) <br>            SendDlgItemMessage(hDlg, IDC_CATTACHMENT, LB_ADDSTRING, 0, <br>            (LPARAM)lpAttach[cAttach -1].lpszFileName); <br> <br>             /* Now, send a little render message to the NoteText edit */ <br> <br>        /*wsprintf (szAttach, "&lt;&lt;File: %s&gt;&gt;", <br>            lpAttach[cAttach - 1].lpszFileName); <br> <br>        SendDlgItemMessage (hDlg, IDC_NOTE, EM_REPLACESEL, 0, <br>            (LPARAM) ((LPSTR) szAttach));*/ <br>        } <br>        break; <br> <br>    case IDC_ADDRBOOK: <br>            SendMessage(hDlg, WM_COMMAND, MAKELONG(IDC_RESOLVE,0), 0); <br>        ulResult = MAPIAddress (lhSession, (ULONG) hDlg, NULL, <br>        2, NULL, cRecips, lpRecips, 0, 0, <br>        &amp;cNewRecips, &amp;lpNewRecips); <br>        if (ulResult) <br>        { <br>        if (ulResult != MAPI_E_USER_ABORT) <br>            MakeMessageBox (hDlg, ulResult, IDS_ADDRBOOKFAIL, MBS_ERROR); <br>        } <br>        else <br>        { <br>        if (cNewRecips) <br>        { <br>            PvFree(lpRecips); <br>            lpRecips = (lpMapiRecipDesc)PvAlloc(cNewRecips*sizeof(MapiRecipDesc)); <br>            cRecips = cNewRecips; <br> <br>                    while(cNewRecips--) <br>                        CopyRecipient(lpRecips, &amp;lpRecips[cNewRecips], <br>                                &amp;lpNewRecips[cNewRecips]); <br> <br>            MAPIFreeBuffer(lpNewRecips); <br>            lpNewRecips = NULL; <br>            cNewRecips = 0; <br> <br>            MakeDisplayNameStr (szDisplayNames, MAPI_TO, <br>            cRecips, lpRecips); <br>            if (*szDisplayNames) <br>            SetDlgItemText (hDlg, IDC_TO, szDisplayNames); <br> <br>            MakeDisplayNameStr (szDisplayNames, MAPI_CC, <br>            cRecips, lpRecips); <br>            if (*szDisplayNames) <br>            SetDlgItemText (hDlg, IDC_CC, szDisplayNames); <br> <br>            SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0); <br>            SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0); <br>        } <br>        } <br>        break; <br> <br>    case IDC_OPTIONS: <br>        DialogBox (hInst, "Options", hDlg, OptionsDlgProc); <br>        break; <br> <br>    case IDC_SEND: <br>    case IDC_RESOLVE: <br>        fUnResTo = FALSE; <br>        fUnResCc = FALSE; <br> <br>        hOldCur = SetCursor(hWaitCur); <br> <br>         <br>        /* Get the names from the To: field and resolve them first */ <br> <br>        /*if (SendDlgItemMessage (hDlg, IDC_TO, EM_GETMODIFY, 0, 0) &amp;&amp; */ <br>         if (cb = SendDlgItemMessage (hDlg, IDC_TO, WM_GETTEXT, <br>            (WPARAM)sizeof(szUnResNames), (LPARAM)szUnResNames)) <br>        { <br>        if (!ResolveFriendlyNames (hDlg, szUnResNames, MAPI_TO, <br>            &amp;cRecips, &amp;lpRecips)) <br>        { <br>            MakeDisplayNameStr (szDisplayNames, MAPI_TO, <br>            cRecips, lpRecips); <br>            if (*szDisplayNames) <br>            { <br>            if (*szUnResNames) <br>            { <br>                lstrcat (szDisplayNames, "; "); <br>                lstrcat (szDisplayNames, szUnResNames); <br>                fUnResTo = TRUE; <br>            } <br> <br>            SetDlgItemText (hDlg, IDC_TO, szDisplayNames); <br>            } <br>            else <br>            { <br>            if (*szUnResNames) <br>            { <br>                SetDlgItemText (hDlg, IDC_TO, szUnResNames); <br>                fUnResTo = TRUE; <br>            } <br>            } <br>        } <br>        /*SendDlgItemMessage (hDlg, IDC_TO, EM_SETMODIFY, FALSE, 0);*/ <br>        } <br> <br>        /* Now, get the names from the Cc: field and resolve them */ <br> <br>        /*if (SendDlgItemMessage (hDlg, IDC_CC, EM_GETMODIFY, 0, 0) &amp;&amp;*/ <br>        if (cb = SendDlgItemMessage (hDlg, IDC_CC, WM_GETTEXT, <br>            (WPARAM)sizeof(szUnResNames), (LPARAM)szUnResNames)) <br>        { <br>        if (!ResolveFriendlyNames (hDlg, szUnResNames, MAPI_CC, <br>            &amp;cRecips, &amp;lpRecips)) <br>        { <br>            MakeDisplayNameStr (szDisplayNames, MAPI_CC, <br>            cRecips, lpRecips); <br>            if (*szDisplayNames) <br>            { <br>            if (*szUnResNames) <br>            { <br>                lstrcat (szDisplayNames, "; "); <br>                lstrcat (szDisplayNames, szUnResNames); <br>                fUnResCc = TRUE; <br>            } <br> <br>            SetDlgItemText (hDlg, IDC_CC, szDisplayNames); <br>            } <br>            else <br>            { <br>            if (*szUnResNames) <br>            { <br>                SetDlgItemText (hDlg, IDC_CC, szUnResNames); <br>                fUnResCc = TRUE; <br>            } <br>            } <br>        } <br>        /*SendDlgItemMessage (hDlg, IDC_CC, EM_SETMODIFY, FALSE, 0);*/ <br>        } <br> <br>        /* If we were just Resolving Names then we can leave now */ <br> <br>        if (LOWORD (wParam) == IDC_RESOLVE) <br>        { <br>        SetCursor(hOldCur); <br>        break; <br>        } <br> <br>        if (cRecips == 0 || fUnResTo || fUnResCc) <br>        { <br>        if (!cRecips) <br>            MakeMessageBox (hDlg, 0, IDS_NORECIPS, MBS_OOPS); <br> <br>        if (fUnResTo) <br>            SetFocus (GetDlgItem (hDlg, IDC_TO)); <br>        else if (fUnResCc) <br>            SetFocus (GetDlgItem (hDlg, IDC_CC)); <br>        else <br>            SetFocus (GetDlgItem (hDlg, IDC_TO)); <br> <br>        SetCursor(hOldCur); <br>        break; <br>        } <br> <br>        /* Everything is OK so far, lets get the Subject */ <br>        /* and the NoteText and try to send the message. */ <br> <br>        /* Get Subject from Edit */ <br> <br>        if (SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_GETMODIFY, 0, 0)) <br>        { <br>        cb = SendDlgItemMessage (hDlg, IDC_SUBJECT, EM_LINELENGTH, 0, 0L); <br> <br>        PvFree(lpszSubject); <br>        lpszSubject = (LPTSTR)PvAlloc(cb + 1); <br> <br>        if (!lpszSubject) <br>            goto cleanup; <br> <br>        GetDlgItemText (hDlg, IDC_SUBJECT, lpszSubject, (int)cb+1); <br>        } <br> <br>        /* Get the NoteText from Edit */ <br> <br>        if (SendDlgItemMessage (hDlg, IDC_NOTE, EM_GETMODIFY, 0, 0)) <br>        { <br>        cLines = SendDlgItemMessage (hDlg, IDC_NOTE, <br>            EM_GETLINECOUNT, 0, 0L); <br> <br>        if (cLines) <br>        { <br>            /* Get the total number of bytes in the multi-line */ <br> <br>            cb = SendDlgItemMessage (hDlg, IDC_NOTE, EM_LINEINDEX, <br>            (UINT)cLines - 1, 0L); <br>            cb += SendDlgItemMessage (hDlg, IDC_NOTE, EM_LINELENGTH, <br>            (UINT)cb, 0L); <br> <br>            /* The next line is to account for CR-LF pairs per line. */ <br> <br>            cb += cLines * 2; <br> <br>                    PvFree(lpszNoteText); <br>            lpszNoteText = (LPTSTR)PvAlloc(cb + 1); <br> <br>            if (!lpszNoteText) <br>            goto cleanup; <br> <br>            /* Get the Note Text from the edit */ <br> <br>            GetDlgItemText (hDlg, IDC_NOTE, lpszNoteText, (int)cb); <br>        } <br>        else <br>        { <br>            /* Make an empty string for NoteText */ <br> <br>            lpszNoteText = (LPTSTR)PvAlloc(1); <br>            if (!lpszNoteText) <br>            goto cleanup; <br>            *lpszNoteText = '\0'; <br>        } <br>        } <br> <br>        lpmsg-&gt;lpszSubject = lpszSubject; <br>        lpmsg-&gt;lpszNoteText = lpszNoteText; <br>        lpmsg-&gt;nRecipCount = cRecips; <br>        lpmsg-&gt;lpRecips = lpRecips; <br>        lpmsg-&gt;nFileCount = cAttach; <br>        lpmsg-&gt;lpFiles = lpAttach; <br>        lpmsg-&gt;flFlags = flSendMsgFlags; <br> <br>        ulResult = MAPISendMail (lhSession, (ULONG) hDlg, lpmsg, 0, 0); <br> <br>        LogSendMail(ulResult); <br> <br>        if (ulResult) <br>        { <br>        MakeMessageBox (hDlg, ulResult, IDS_SENDERROR, MBS_ERROR); <br>        SetCursor(hOldCur); <br>        break; <br>        } <br>cleanup: <br>        SetCursor(hOldCur); <br> <br>    case IDCANCEL: <br>        PvFree(lpmsg-&gt;lpszMessageType); <br>        PvFree(lpmsg-&gt;lpszConversationID); <br>        PvFree(lpmsg); <br>        PvFree(lpRecips); <br>        PvFree(lpAttach); <br>        PvFree(lpszSubject); <br>        PvFree(lpszNoteText); <br>        lpmsg = NULL; <br> <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>        break; <br> <br>    default: <br>        break; <br>    } <br>    break; <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> -  InBoxDlgProc <br> - <br> *  Purpose: <br> *      Dialog procedure for the InBox dialog. <br> * <br> *  Parameters: <br> *      hDlg <br> *      message <br> *      wParam <br> *      lParam <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL FAR PASCAL <br>InBoxDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    char szMsgID[512]; <br>    char szSeedMsgID[512]; <br>    LPMSGID lpMsgNode; <br>    static LPMSGID lpMsgIdList = NULL; <br>    lpMapiMessage lpMessage; <br>    ULONG ulResult; <br>    DWORD nIndex; <br>    RECT Rect; <br>    HCURSOR hOldCur; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>    hOldCur = SetCursor(hWaitCur); <br> <br>        InitBmps(hDlg, IDC_MSG); <br> <br>    /* Populate List Box with all messages in InBox. */ <br>    /* This is a painfully slow process for now.     */ <br> <br>    ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, NULL, <br>        MAPI_GUARANTEE_FIFO | MAPI_LONG_MSGID, 0, szMsgID); <br> <br>    while (ulResult == SUCCESS_SUCCESS) <br>    { <br>        ulResult = MAPIReadMail (lhSession, (ULONG) hDlg, szMsgID, <br>        MAPI_PEEK | MAPI_ENVELOPE_ONLY, <br>        0, &amp;lpMessage); <br> <br>        if (!ulResult) <br>        { <br>        lpMsgNode = MakeMsgNode (lpMessage, szMsgID); <br> <br>        if (lpMsgNode) <br>        { <br>            InsertMsgNode (lpMsgNode, &amp;lpMsgIdList); <br> <br>            SendDlgItemMessage (hDlg, IDC_MSG, LB_ADDSTRING, <br>            0, (LONG) lpMsgNode); </code></pre>
<p>
</p>
<pre><code>} <br>        MAPIFreeBuffer (lpMessage); <br>        } <br> <br>        lstrcpy (szSeedMsgID, szMsgID); <br>        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, szSeedMsgID, <br>        MAPI_GUARANTEE_FIFO | MAPI_LONG_MSGID, 0, szMsgID); <br>    } <br> <br>    SetCursor(hOldCur); <br>    SetFocus (GetDlgItem (hDlg, IDC_MSG)); <br>    return TRUE; <br>    break; <br> <br>    case WM_SETFOCUS: <br>    SetFocus (GetDlgItem (hDlg, IDC_MSG)); <br>    break; <br> <br>    case WM_MEASUREITEM: <br>    /* Sets the height of the owner-drawn List-Box */ <br>        MeasureItem(hDlg, (MEASUREITEMSTRUCT *)lParam); <br>    break; <br> <br>    case WM_DRAWITEM: <br>    DrawItem((DRAWITEMSTRUCT *)lParam); <br>    break; <br> <br>    case WM_DELETEITEM: <br>    /* This message is handled by the IDC_DELETE message */ <br>    return TRUE; <br>    break; <br> <br>    case WM_COMMAND: <br>    switch (LOWORD (wParam)) <br>    { <br>    case IDC_NEW: <br>        hOldCur = SetCursor(hWaitCur); <br> <br>        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, NULL, <br>        MAPI_UNREAD_ONLY | MAPI_LONG_MSGID, 0, szMsgID); <br> <br>        while (ulResult == SUCCESS_SUCCESS) <br>        { <br>        if (!FindNode (lpMsgIdList, szMsgID)) <br>        { <br>            ulResult = MAPIReadMail (lhSession, (ULONG) hDlg, szMsgID, <br>            MAPI_PEEK | MAPI_ENVELOPE_ONLY, 0, &amp;lpMessage); <br> <br>            if (!ulResult) <br>            { <br>            lpMsgNode = MakeMsgNode (lpMessage, szMsgID); <br>            InsertMsgNode (lpMsgNode, &amp;lpMsgIdList); <br> <br>            SendDlgItemMessage (hDlg, IDC_MSG, LB_ADDSTRING, <br>                0, (LONG) lpMsgNode); <br> <br>            MAPIFreeBuffer (lpMessage); <br>            } <br>        } <br> <br>        lstrcpy (szSeedMsgID, szMsgID); <br>        ulResult = MAPIFindNext (lhSession, (ULONG) hDlg, NULL, szSeedMsgID, <br>            MAPI_UNREAD_ONLY | MAPI_LONG_MSGID, 0, szMsgID); <br>        } <br>        SetCursor(hOldCur); <br>        break; <br> <br>    case IDC_MSG: <br>        if(HIWORD(wParam) != LBN_DBLCLK) <br>        break; <br> <br>    case IDC_READ: <br>        nIndex = SendDlgItemMessage (hDlg, IDC_MSG, LB_GETCURSEL, 0, 0); <br> <br>        if (nIndex == LB_ERR) <br>        break; <br> <br>        lpReadMsgNode = (LPMSGID) SendDlgItemMessage (hDlg, IDC_MSG, <br>        LB_GETITEMDATA, (UINT)nIndex, 0L); <br> <br>        if (lpReadMsgNode) <br>        DialogBox (hInst, "ReadNote", hDlg, ReadMailDlgProc); <br> <br>        /* Update the Messages List-Box with new icon */ <br> <br>        SendDlgItemMessage (hDlg, IDC_MSG, LB_GETITEMRECT, (UINT)nIndex, (LPARAM) &amp;Rect); <br>        InvalidateRect(GetDlgItem(hDlg, IDC_MSG), &amp;Rect, FALSE); <br>        break; <br> <br>    case IDC_DELETE: <br>        nIndex = SendDlgItemMessage (hDlg, IDC_MSG, LB_GETCURSEL, 0, 0); <br> <br>        if (nIndex == LB_ERR) <br>        break; <br> <br>        lpMsgNode = (LPMSGID) SendDlgItemMessage (hDlg, IDC_MSG, <br>        LB_GETITEMDATA, (UINT)nIndex, 0); <br> <br>        if (lpMsgNode) <br>        { <br>        MAPIDeleteMail (lhSession, (ULONG) hDlg, lpMsgNode-&gt;lpszMsgID, 0, 0); <br>        DeleteMsgNode (lpMsgNode, &amp;lpMsgIdList); <br>        } <br> <br>        SendDlgItemMessage (hDlg, IDC_MSG, LB_DELETESTRING, (UINT)nIndex, 0); <br>        break; <br> <br>    case IDC_CLOSE: <br>    case IDCANCEL: <br>        FreeMsgList (lpMsgIdList); <br>        lpMsgIdList = NULL; <br> <br>            DeInitBmps(); <br> <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>        break; <br> <br>    default: <br>        break; <br>    } <br>    break; <br>    } <br> <br>    return FALSE; <br>} <br> <br>/* <br> -  ReadMailDlgProc <br> - <br> *  Purpose: <br> *      Dialog procedure for the ReadMail dilaog. <br> * <br> *  Parameters: <br> *      hDlg <br> *      message <br> *      wParam <br> *      lParam <br> * <br> *  Returns: <br> *      True/False <br> * <br> */ <br> <br>BOOL FAR PASCAL <br>ReadMailDlgProc (HWND hDlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    ULONG ulResult; <br>    char szTo[TO_EDIT_MAX]; <br>    char szCc[TO_EDIT_MAX]; <br>    char szChangeMsg[512]; <br>    ULONG idx; <br>    static lpMapiMessage lpReadMsg; <br> <br>    switch (msg) <br>    { <br>    case WM_INITDIALOG: <br>    if (ulResult = MAPIReadMail (lhSession, (LONG) hDlg, lpReadMsgNode-&gt;lpszMsgID, <br>        0, 0, &amp;lpReadMsg)) <br>    { <br>        MakeMessageBox(hDlg, ulResult, IDS_READFAIL, MBS_ERROR); <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>    } <br> <br>    lpReadMsgNode-&gt;fUnRead = FALSE; <br> <br>    szTo[0] = '\0'; <br>    szCc[0] = '\0'; <br> <br>    for (idx = 0; idx &lt; lpReadMsg-&gt;nRecipCount; idx++) <br>    { <br>        if (lpReadMsg-&gt;lpRecips[idx].ulRecipClass == MAPI_TO) <br>        { <br>        lstrcat (szTo, lpReadMsg-&gt;lpRecips[idx].lpszName); <br>        lstrcat (szTo, "; "); <br>        } <br>        else if (lpReadMsg-&gt;lpRecips[idx].ulRecipClass == MAPI_CC) <br>        { <br>        lstrcat (szCc, lpReadMsg-&gt;lpRecips[idx].lpszName); <br>        lstrcat (szCc, "; "); <br>        } <br>        else <br>        { <br>        /* Must be Bcc, lets ignore it! */ <br>        } <br>    } <br> <br>    if(*szTo) <br>        szTo[lstrlen (szTo) - 2] = '\0'; <br>    if(*szCc) <br>        szCc[lstrlen (szCc) - 2] = '\0'; <br> <br>    SetDlgItemText (hDlg, IDC_RFROM, <br>        (lpReadMsg-&gt;lpOriginator &amp;&amp; lpReadMsg-&gt;lpOriginator-&gt;lpszName ? <br>                lpReadMsg-&gt;lpOriginator-&gt;lpszName : "")); <br>    SetDlgItemText (hDlg, IDC_RDATE, <br>        (lpReadMsg-&gt;lpszDateReceived ? lpReadMsg-&gt;lpszDateReceived : "")); <br>    SetDlgItemText (hDlg, IDC_RTO, szTo); <br>    SetDlgItemText (hDlg, IDC_RCC, szCc); <br>    SetDlgItemText (hDlg, IDC_RSUBJECT, <br>        (lpReadMsg-&gt;lpszSubject ? lpReadMsg-&gt;lpszSubject : "")); <br>    SetDlgItemText (hDlg, IDC_READNOTE, <br>        (lpReadMsg-&gt;lpszNoteText ? lpReadMsg-&gt;lpszNoteText : "")); <br> <br>    if (!lpReadMsg-&gt;nFileCount) <br>    { <br>        EnableWindow (GetDlgItem (hDlg, IDC_SAVEATTACH), FALSE); <br>        EnableWindow (GetDlgItem (hDlg, IDC_ATTACHMENT), FALSE); <br>        EnableWindow (GetDlgItem (hDlg, IDT_ATTACHMENT), FALSE); <br>    } <br>    else <br>    { <br>        for(idx = 0; idx &lt; lpReadMsg-&gt;nFileCount; idx++) <br>        if (lpReadMsg-&gt;lpFiles[idx].lpszFileName) <br>            SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_ADDSTRING, 0, <br>            (LPARAM)lpReadMsg-&gt;lpFiles[idx].lpszFileName); <br> <br>        SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_SETCURSEL, 0, 0L); <br>    } <br> <br>    SetFocus (GetDlgItem (hDlg, IDC_READNOTE)); <br>    return FALSE; <br> <br>    case WM_COMMAND: <br>    switch (LOWORD (wParam)) <br>    { <br>    case IDC_SAVECHANGES: <br>        if (SendDlgItemMessage (hDlg, IDC_READNOTE, EM_GETMODIFY, 0, 0)) <br>        ulResult = SaveMsgChanges (hDlg, lpReadMsg, lpReadMsgNode-&gt;lpszMsgID); <br>        SendDlgItemMessage (hDlg, IDC_READNOTE, EM_SETMODIFY, 0, 0); <br>        break; <br> <br>    case IDC_ATTACHMENT: <br>        if(HIWORD(wParam) != LBN_DBLCLK) <br>        break; <br> <br>    case IDC_SAVEATTACH: <br>        idx = SendDlgItemMessage(hDlg, IDC_ATTACHMENT, LB_GETCURSEL, 0, 0L); <br> <br>        if(idx != LB_ERR) <br>        { <br>        SaveFileAttachments(hDlg, &amp;lpReadMsg-&gt;lpFiles[idx]); <br>        SetFocus(GetDlgItem (hDlg, IDC_ATTACHMENT)); <br>        return FALSE; <br> <br>        } <br>        break; <br> <br>    case IDC_REPLY: <br>    case IDC_REPLYALL: <br>    case IDC_FORWARD: <br>        MakeNewMessage (lpReadMsg, LOWORD (wParam)); <br>        DialogBox (hInst, "ComposeNote", hDlg, ComposeDlgProc); <br>        break; <br> <br>    case IDCANCEL: <br>        if (SendDlgItemMessage (hDlg, IDC_READNOTE, EM_GETMODIFY, 0, 0)) <br>        { <br>        wsprintf (szChangeMsg, "Save changes to: '%s' in Inbox?", <br>            (lpReadMsg-&gt;lpszSubject ? lpReadMsg-&gt;lpszSubject : "")); <br> <br>        if (MessageBox (hDlg, szChangeMsg, "Mail", MB_YESNO) == IDYES) <br>        { <br>            ulResult = SaveMsgChanges (hDlg, lpReadMsg, lpReadMsgNode-&gt;lpszMsgID); <br>        } <br>        } <br> <br>        /* If there were file attachments, then delete the temps */ <br> <br>        for(idx = 0; idx &lt; lpReadMsg-&gt;nFileCount; idx++) <br>        if (lpReadMsg-&gt;lpFiles[idx].lpszPathName) <br>            DeleteFile(lpReadMsg-&gt;lpFiles[idx].lpszPathName); <br> <br>        MAPIFreeBuffer (lpReadMsg); <br>        lpReadMsg = NULL; <br>        EndDialog (hDlg, TRUE); <br>        return TRUE; <br>    } <br>    break; <br>    } <br>    return FALSE; <br>} <br> <br>/* <br> -  MakeMessageBox <br> - <br> *  Purpose: <br> *      Gets resource string and displays an error message box. <br> * <br> *  Parameters: <br> *      hWnd            - Handle to parent window <br> *      idString        - Resource ID of message in StringTable <br> * <br> *  Returns: <br> *      Void <br> * <br> */ <br> <br>void <br>MakeMessageBox (HWND hWnd, ULONG ulResult, UINT idString, UINT fStyle) <br>{ <br>    char szMessage[256]; <br>    char szMapiReturn[64]; <br> <br>    LoadString (hInst, idString, szMessage, 255); <br> <br>    if (ulResult) <br>    { <br>    LoadString (hInst, (UINT)ulResult, szMapiReturn, 64); <br>    lstrcat (szMessage, "\nReturn Code: "); <br>    lstrcat (szMessage, szMapiReturn); <br>    } <br> <br>    MessageBox (hWnd, szMessage, "Problem", fStyle); <br>} <br> <br>/* <br> -  ResolveFriendlyNames <br> - <br> *  Purpose: <br> *      Helper function to convert a string of ';' delimited friendly <br> *      names into an array of MapiRecipDescs. <br> * <br> *  Side Effects:                                              <br> *      The display string passed in is modified to contain the <br> *      friendly names of the mail users as found in the sample <br> *      address book. <br> * <br> *  Note: <br> *      Duplicate names in the address book will result in undefined <br> *      behavior. <br> * <br> *  Parameters: <br> *      hWnd                - Handle to parent window <br> *      lpszDisplayNames    - string of ';' delimited user names <br> *      ulRecipClass        - either MAPI_TO, MAPI_CC, or MAPI_BCC <br> *      lpcRecips           - Address of recipient count to be returned <br> *      lppRecips           - Address of recipient array to be returned <br> * <br> *  Return: <br> *      ulResult <br> */ <br> <br>ULONG <br>ResolveFriendlyNames (HWND hWnd, LPSTR lpszDisplayNames, ULONG ulRecipClass, <br>    ULONG * lpcRecips, lpMapiRecipDesc * lppRecips) <br>{ <br>    char szResolve[TO_EDIT_MAX]; <br>    LPSTR lpszNameToken; <br>    ULONG cRecips = 0; <br>    ULONG cFails = 0; <br>    ULONG ulResult; <br>    lpMapiRecipDesc lpRecip; <br>    lpMapiRecipDesc lpRecipList; <br> <br>    *szResolve = '\0'; <br>    lpszNameToken = strtok (lpszDisplayNames, ";\n"); <br> <br>    while (lpszNameToken) <br>    { <br>    /* Strip leading blanks from name */ <br> <br>    while (*lpszNameToken == ' ') <br>        lpszNameToken++; <br> <br>    /* Check if name has already been resolved */ <br> <br>    if (!FNameInList (lpszNameToken, *lpcRecips, *lppRecips)) <br>    { <br>        lstrcat (szResolve, lpszNameToken); <br>        lstrcat (szResolve, "; "); <br>        cRecips++; <br>    } <br> <br>    /* Get Next Token */ <br> <br>    lpszNameToken = strtok (NULL, ";\n"); <br>    } <br> <br>    *lpszDisplayNames = '\0'; <br> <br>    if (!szResolve[0]) <br>    { <br>    ulResult = SUCCESS_SUCCESS; <br>    goto err; <br>    } <br> <br>    szResolve[lstrlen (szResolve) - 2] = '\0'; <br> <br>    lpRecipList = (lpMapiRecipDesc)PvAlloc((cRecips + *lpcRecips) * sizeof (MapiRecipDesc)); <br> <br>    if (!lpRecipList) <br>    { <br>    ulResult = MAPI_E_INSUFFICIENT_MEMORY; <br>    goto err; <br>    } <br>    memset (lpRecipList, 0, (size_t)(cRecips+*lpcRecips)*sizeof(MapiRecipDesc)); <br> <br>    cRecips = 0; <br> <br>    while (cRecips &lt; *lpcRecips) <br>    { <br>    ulResult = CopyRecipient (lpRecipList, &amp;lpRecipList[cRecips], <br>        *lppRecips + cRecips); <br> <br>    if (ulResult) <br>    { <br>        PvFree(lpRecipList); <br>        goto err; <br>    } <br> <br>    cRecips++; <br>    } <br> <br>    PvFree(*lppRecips); <br> <br>    lpszNameToken = strtok (szResolve, ";\n"); <br> <br>    while (lpszNameToken) <br>    { <br>    /* Strip leading blanks (again) */ <br> <br>    while (*lpszNameToken == ' ') <br>        lpszNameToken++; <br> <br>    ulResult = MAPIResolveName (lhSession, (ULONG) hWnd, lpszNameToken, <br>        MAPI_DIALOG, 0, &amp;lpRecip); <br> <br>    if (ulResult == SUCCESS_SUCCESS) <br>    { <br>        lpRecip-&gt;ulRecipClass = ulRecipClass; <br>        ulResult = CopyRecipient (lpRecipList, &amp;lpRecipList[cRecips], lpRecip); <br> <br>        MAPIFreeBuffer (lpRecip); <br> <br>        if (ulResult) <br>        goto cleanup; <br> <br>        cRecips++; <br>    } <br>    else <br>    { <br>        lstrcat (lpszDisplayNames, lpszNameToken); <br>        lstrcat (lpszDisplayNames, "; "); <br>        cFails++; <br>    } <br>    lpszNameToken = strtok (NULL, ";\n"); <br>    } <br> <br>    /* if cFails &gt; 0 then we have partial success */ <br> <br>    ulResult = SUCCESS_SUCCESS; <br> <br>    if (cFails) <br>    MakeMessageBox (hWnd, 0, IDS_UNRESOLVEDNAMES, MBS_INFO); <br> <br>cleanup: <br>    *lpcRecips = cRecips; <br>    *lppRecips = lpRecipList; <br>err: <br>    if (*lpszDisplayNames) <br>    lpszDisplayNames[lstrlen (lpszDisplayNames) - 2] = '\0'; <br> <br>    return ulResult; <br>} <br> <br>/* <br> -  CopyRecipient <br> - <br> *  Purpose: <br> *      Called in support of ResolveFriendlyNames() to build an array <br> *      of chained MapiRecipDescs. <br> * <br> *  Parameters: <br> *      lpParent        - Parent memory that allocations get chained to <br> *      lpDest          - Destination Recipient <br> *      lpSrc           - Source Recipient <br> * <br> *  Return: <br> *      ulResult <br> */ <br> <br>ULONG <br>CopyRecipient (lpMapiRecipDesc lpParent, <br>    lpMapiRecipDesc lpDest, <br>    lpMapiRecipDesc lpSrc) <br>{ <br>    lpDest-&gt;ulReserved = lpSrc-&gt;ulReserved; <br>    lpDest-&gt;ulRecipClass = lpSrc-&gt;ulRecipClass; <br>    lpDest-&gt;ulEIDSize = lpSrc-&gt;ulEIDSize; <br> <br>    if (lpSrc-&gt;lpszName) <br>    { <br>    lpDest-&gt;lpszName = (LPTSTR)PvAllocMore(lstrlen(lpSrc-&gt;lpszName) + 1, <br>            (LPVOID)lpParent); <br> <br>    if (!lpDest-&gt;lpszName) <br>        return MAPI_E_INSUFFICIENT_MEMORY; <br> <br>    lstrcpy (lpDest-&gt;lpszName, lpSrc-&gt;lpszName); <br>    } <br>    else <br>    lpDest-&gt;lpszName = NULL; <br> <br>    if (lpSrc-&gt;lpszAddress) <br>    { <br>    lpDest-&gt;lpszAddress = (LPTSTR)PvAllocMore(lstrlen (lpSrc-&gt;lpszAddress) + 1, <br>            (LPVOID)lpParent); <br> <br>    if (!lpDest-&gt;lpszAddress) <br>        return MAPI_E_INSUFFICIENT_MEMORY; <br> <br>    lstrcpy (lpDest-&gt;lpszAddress, lpSrc-&gt;lpszAddress); <br>    } <br>    else <br>    lpDest-&gt;lpszAddress = NULL; <br> <br>    if (lpSrc-&gt;lpEntryID) <br>    { <br>    lpDest-&gt;lpEntryID = (LPBYTE)PvAllocMore(lpSrc-&gt;ulEIDSize, <br>            (LPVOID)lpParent); <br> <br>    if (!lpDest-&gt;lpEntryID) <br>        return MAPI_E_INSUFFICIENT_MEMORY; <br> <br>        if (lpSrc-&gt;ulEIDSize) <br>            memcpy (lpDest-&gt;lpEntryID, lpSrc-&gt;lpEntryID, (size_t)lpSrc-&gt;ulEIDSize); <br>    } <br>    else <br>    lpDest-&gt;lpEntryID = NULL; <br> <br>    return SUCCESS_SUCCESS; <br> <br>} <br> <br>/* <br> -  GetNextFile <br> - <br> *  Purpose: <br> *      Called when user clicks 'Attach' button in Compose Note form. <br> *      We will build a chained memory chunk for mmore than one file <br> *      attachment so the memory can be freed with a single call to <br> *      PvFree. <br> * <br> *  Parameters: <br> *      hWnd            - Window handle of Compose Note dialog <br> *      nPos            - Render position of attachment in Notetext. <br> *      lpcAttach       - Pointer to the count of attachments. <br> *      lppAttach       - Pointer to the MapiFileDesc array. <br> * <br> *  Return: <br> *      ulResult. <br> */ <br> <br>ULONG <br>GetNextFile (HWND hWnd, ULONG nPos, ULONG * lpcAttach, <br>    lpMapiFileDesc * lppAttach) <br>{ <br>    lpMapiFileDesc lpAttach; <br>    lpMapiFileDesc lpAttachT; <br>    OPENFILENAME ofn; <br>    char szFileName[256] = ""; <br>    char szFilter[256]; <br>    static char szFileTitle[16]; <br>    static char szDirName[256] = ""; <br>    LPSTR lpszEndPath; <br>    ULONG idx; <br>    ULONG ulResult = SUCCESS_SUCCESS; <br> <br>    if (!szDirName[0]) <br>    GetSystemDirectory ((LPSTR) szDirName, 255); <br>    else <br>    lstrcpy (szFileName, szFileTitle); <br> <br>    LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter)); <br> <br>    for (idx = 0; szFilter[idx] != '\0'; idx++) <br>    if (szFilter[idx] == '|') <br>        szFilter[idx] = '\0'; <br> <br>    ofn.lStructSize = sizeof (OPENFILENAME); <br>    ofn.hwndOwner = 0; <br>    ofn.hInstance = 0; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1L; <br>    ofn.lpstrFile = szFileName; <br>    ofn.nMaxFile = 256; <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = 16; <br>    ofn.lpstrInitialDir = szDirName; <br>    ofn.lpstrTitle = "Attach"; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = NULL; <br>    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br> <br>    if (!GetOpenFileName (&amp;ofn)) <br>    return MAPI_USER_ABORT; <br> <br>    /* Save the directory for the next time we call this */ <br> <br>    lstrcpy (szDirName, szFileName); <br>    if (lpszEndPath = strstr (szDirName, szFileTitle)) <br>    *(--lpszEndPath) = '\0'; <br> <br>    lpAttach = (lpMapiFileDesc)PvAlloc(((*lpcAttach) + 1) * sizeof (MapiFileDesc)); <br> <br>    if(!lpAttach) <br>    goto err; <br> <br>    memset (lpAttach, 0, (size_t)(*lpcAttach + 1) * sizeof (MapiFileDesc)); <br> <br>    lpAttachT = *lppAttach; <br> <br>    for (idx = 0; idx &lt; *lpcAttach; idx++) <br>    if(ulResult = CopyAttachment (lpAttach, &amp;lpAttach[idx], &amp;lpAttachT[idx])) <br>        goto err; <br> <br>    lpAttach[idx].ulReserved = 0; <br>    lpAttach[idx].flFlags = 0; <br>    lpAttach[idx].nPosition = (ULONG)(-1); <br>    lpAttach[idx].lpFileType = NULL; <br> <br>    lpAttach[idx].lpszPathName = (LPTSTR)PvAllocMore(lstrlen (szFileName) + 1, <br>        (LPVOID)lpAttach); <br> <br>    if(!lpAttach[idx].lpszPathName) <br>    goto err; <br> <br>    lpAttach[idx].lpszFileName = (LPTSTR)PvAllocMore(lstrlen (szFileTitle) + 1, <br>        (LPVOID)lpAttach); <br> <br>    if(!lpAttach[idx].lpszFileName) <br>    goto err; <br> <br>    lstrcpy (lpAttach[idx].lpszPathName, szFileName); <br>    lstrcpy (lpAttach[idx].lpszFileName, szFileTitle); <br> <br>    PvFree(lpAttachT); <br> <br>    *lppAttach = lpAttach; <br>    (*lpcAttach)++; <br> <br>err: <br>    if(ulResult) <br>    PvFree(lpAttach); <br> <br>    return ulResult; <br>} <br> <br>/* <br> -  CopyAttachment <br> - <br> *  Purpose: <br> *      Called in support of GetNextFile() to re-build an array <br> *      of chained MapiFileDescs. <br> * <br> *  Parameters: <br> *      lpParent        - Parent memory that allocations get chained to <br> *      lpDest          - Destination Recipient <br> *      lpSrc           - Source Recipient <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>ULONG <br>CopyAttachment (lpMapiFileDesc lpParent, <br>    lpMapiFileDesc lpDest, <br>    lpMapiFileDesc lpSrc) <br>{ <br>    lpDest-&gt;ulReserved = lpSrc-&gt;ulReserved; <br>    lpDest-&gt;flFlags = lpSrc-&gt;flFlags; <br>    lpDest-&gt;nPosition = lpSrc-&gt;nPosition; <br>    lpDest-&gt;lpFileType = lpSrc-&gt;lpFileType; <br> <br>    if (lpSrc-&gt;lpszPathName) <br>    { <br>    lpDest-&gt;lpszPathName = (LPTSTR)PvAllocMore(lstrlen (lpSrc-&gt;lpszPathName) + 1, <br>            (LPVOID)lpParent); <br> <br>    if (!lpDest-&gt;lpszPathName) <br>        return MAPI_E_INSUFFICIENT_MEMORY; <br> <br>    lstrcpy (lpDest-&gt;lpszPathName, lpSrc-&gt;lpszPathName); <br>    } <br>    else <br>    lpDest-&gt;lpszPathName = NULL; <br> <br>    if (lpSrc-&gt;lpszFileName) <br>    { <br>    lpDest-&gt;lpszFileName = (LPTSTR)PvAllocMore(lstrlen (lpSrc-&gt;lpszFileName) + 1, <br>            (LPVOID)lpParent); <br> <br>    if (!lpDest-&gt;lpszFileName) <br>        return MAPI_E_INSUFFICIENT_MEMORY; <br> <br>    lstrcpy (lpDest-&gt;lpszFileName, lpSrc-&gt;lpszFileName); <br>    } <br>    else <br>    lpDest-&gt;lpszFileName = NULL; <br> <br>    return SUCCESS_SUCCESS; <br> <br>} <br> <br>/* <br> -  FNameInList <br> - <br> *  Purpose: <br> *      To find lpszName in an array of recipients.  Used to determine <br> *      if user name has already been resolved. <br> * <br> *  Parameters: <br> *      lpszName        - Friendly name to search for <br> *      cRecips         - Count of recipients in lpRecips <br> *      lpRecips        - Array of MapiRecipDescs <br> * <br> *  Return: <br> *      TRUE/FALSE <br> */ <br> <br>BOOL <br>FNameInList (LPSTR lpszName, ULONG cRecips, lpMapiRecipDesc lpRecips) <br>{ <br>    /* Case sensitive compare of each friendly name in list.  */ <br> <br>    if (!cRecips || !lpRecips) <br>    return FALSE; <br> <br>    while (cRecips--) <br>    if (!lstrcmp (lpszName, lpRecips[cRecips].lpszName)) <br>        return TRUE; <br> <br>    return FALSE; <br>} <br> <br> <br>/* <br> -  MakeMsgNode <br> - <br> *  Purpose: <br> *      Allocate memory for a new MSGID node and initialize its <br> *      data members to the values passed in. <br> * <br> *  Parameters: <br> *      lpMsg           - Pointer to a MapiMessage <br> *      lpszMsgID       - Opaque message identifier <br> * <br> *  Return: <br> *      lpMsgNode       - Pointer to new node <br> */ <br> <br>LPMSGID <br>MakeMsgNode (lpMapiMessage lpMsg, LPSTR lpszMsgID) <br>{ <br>    LPMSGID lpMsgNode = NULL; <br> <br>    if (!lpMsg || !lpszMsgID) <br>    goto err; <br> <br>    lpMsgNode = (LPMSGID)PvAlloc(sizeof (MSGID)); <br> <br>    if (!lpMsgNode) <br>    goto err; <br> <br>    memset (lpMsgNode, 0, sizeof (MSGID)); <br> <br>    if (lpMsg-&gt;nFileCount) <br>    lpMsgNode-&gt;fHasAttach = TRUE; <br> <br>    if (lpMsg-&gt;flFlags &amp; MAPI_UNREAD) <br>    lpMsgNode-&gt;fUnRead = TRUE; <br> <br>    lpMsgNode-&gt;lpszMsgID = (LPTSTR)PvAllocMore(lstrlen (lpszMsgID) + 1, <br>        (LPVOID)lpMsgNode); <br> <br>    if (!lpMsgNode-&gt;lpszMsgID) <br>    goto err; <br> <br>    lstrcpy (lpMsgNode-&gt;lpszMsgID, lpszMsgID); <br> <br>    if (lpMsg-&gt;lpOriginator &amp;&amp; lpMsg-&gt;lpOriginator-&gt;lpszName) <br>    { <br>    lpMsgNode-&gt;lpszFrom = (LPTSTR)PvAllocMore(lstrlen(lpMsg-&gt;lpOriginator-&gt;lpszName) + 1, <br>            (LPVOID)lpMsgNode); <br> <br>    if (!lpMsgNode-&gt;lpszFrom) <br>        goto err; <br> <br>    lstrcpy (lpMsgNode-&gt;lpszFrom, lpMsg-&gt;lpOriginator-&gt;lpszName); <br>    } <br> <br>    if (lpMsg-&gt;lpszSubject) <br>    { <br>    lpMsgNode-&gt;lpszSubject = (LPTSTR)PvAllocMore(lstrlen (lpMsg-&gt;lpszSubject) + 1, <br>            (LPVOID)lpMsgNode); <br> <br>    if (!lpMsgNode-&gt;lpszSubject) <br>        goto err; <br> <br>    lstrcpy (lpMsgNode-&gt;lpszSubject, lpMsg-&gt;lpszSubject); <br>    } <br> <br>    if (lpMsg-&gt;lpszDateReceived) <br>    { <br>    lpMsgNode-&gt;lpszDateRec = (LPTSTR)PvAllocMore(lstrlen (lpMsg-&gt;lpszDateReceived) + 1, <br>            (LPVOID)lpMsgNode); <br> <br>    if (!lpMsgNode-&gt;lpszDateRec) <br>        goto err; <br> <br>    lstrcpy (lpMsgNode-&gt;lpszDateRec, lpMsg-&gt;lpszDateReceived); <br>    } <br> <br>    return lpMsgNode; <br> <br>err: <br>    PvFree(lpMsgNode); <br>    return NULL; <br>} <br> <br>/* <br> -  InsertMsgNode <br> - <br> *  Purpose: <br> *      Currently (for simplicity) we will insert the nodes <br> *      at the beginning of the list.  This can later be <br> *      replaced with a routine that can insert sorted on <br> *      different criteria, like DateReceived, From, or <br> *      Subject.  But for now... <br> * <br> *  Parameters: <br> *      lpMsgNode       - Pointer to a MSGID node <br> *      lppMsgHead      - Pointer to the head of the list <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void <br>InsertMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead) <br>{ <br>    if (*lppMsgHead) <br>    { <br>    lpMsgNode-&gt;lpNext = *lppMsgHead; <br>    (*lppMsgHead)-&gt;lpPrev = lpMsgNode; <br>    } <br>    else <br>    lpMsgNode-&gt;lpNext = NULL; <br> <br>    /* The next 2 assignments are here in case the node came from somewhere */ <br>    /* other than a call to MakeMsgNode () in which case we aren't sure */ <br>    /* they're already NULL. */ <br> <br>    lpMsgNode-&gt;lpPrev = NULL; <br>    *lppMsgHead = lpMsgNode; <br>} <br> <br>/* <br> -  DeleteMsgNode <br> - <br> *  Purpose: <br> *      Removes the node passed in from the list.  This <br> *      may seem like a strange way to do this but it's <br> *      not, because the Owner-Drawn List Box gives us <br> *      direct access to elements in the list that makes <br> *      it easier to do things this way. <br> * <br> *  Parameters: <br> *      lpMsgNode       - Pointer to the MSGID node to delete <br> *      lppMsgHead      - Pointer to the head of the list <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void <br>DeleteMsgNode (LPMSGID lpMsgNode, LPMSGID * lppMsgHead) <br>{ <br>    if (!lpMsgNode) <br>    return; <br> <br>    /* Check if we are the first node */ <br> <br>    if (lpMsgNode-&gt;lpPrev) <br>    lpMsgNode-&gt;lpPrev-&gt;lpNext = lpMsgNode-&gt;lpNext; <br> <br>    /* Check if we are the last node */ <br> <br>    if (lpMsgNode-&gt;lpNext) <br>    lpMsgNode-&gt;lpNext-&gt;lpPrev = lpMsgNode-&gt;lpPrev; <br> <br>    /* check if we are the only node */ <br> <br>    if(lpMsgNode == *lppMsgHead) <br>    *lppMsgHead = NULL; <br> <br>    PvFree(lpMsgNode); <br>    return; <br>} <br> <br> <br> <br>/* <br> -  FindNode <br> - <br> *  Purpose: <br> *      Returns a pointer to the node containing lpszMsgID. <br> *      Returns NULL if node doesn't exist or lpszMsgID is NULL. <br> * <br> *  Parameters: <br> *      lpMsgHead       - Pointer to the head of the list <br> *      lpszMsgID       - Message ID to search for <br> * <br> *  Return: <br> *      lpMsgNode       - Pointer to the node returned <br> */ <br> <br>LPMSGID <br>FindNode (LPMSGID lpMsgHead, LPSTR lpszMsgID) <br>{ <br>    if (!lpszMsgID) <br>    return NULL; <br> <br>    while (lpMsgHead) <br>    { <br>    if (!lstrcmp (lpMsgHead-&gt;lpszMsgID, lpszMsgID)) <br>        break; <br> <br>    lpMsgHead = lpMsgHead-&gt;lpNext; <br>    } <br> <br>    return lpMsgHead; <br>} <br> <br> <br> <br>/* <br> -  FreeMsgList <br> - <br> *  Purpose: <br> *      Walks down the MsgList and frees each node. <br> * <br> *  Parameters: <br> *      lpMsgHead       - Pointer to the head of the list <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void <br>FreeMsgList (LPMSGID lpMsgHead) <br>{ <br>    LPMSGID lpT; <br> <br>    while (lpMsgHead) <br>    { <br>    lpT = lpMsgHead; <br>    lpMsgHead = lpMsgHead-&gt;lpNext; <br>    PvFree(lpT); <br>    } <br>} <br> <br>/* <br> -  MakeDisplayNameStr <br> - <br> *  Purpose: <br> *      Finds all recipients of type ulRecipClass in lpRecips and adds <br> *      their friendly name to the display string. <br> * <br> *  Parameters: <br> *      lpszDisplay         - Destination string for names <br> *      ulRecipClass        - Recipient types to search for <br> *      cRecips             - Count of recipients in lpRecips <br> *      lpRecips            - Pointer to array of MapiRecipDescs <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void <br>MakeDisplayNameStr (LPSTR lpszDisplay, ULONG ulRecipClass, <br>    ULONG cRecips, lpMapiRecipDesc lpRecips) <br>{ <br>    ULONG idx; <br> <br>    *lpszDisplay = '\0'; <br> <br>    for (idx = 0; idx &lt; cRecips; idx++) <br>    { <br>    if (lpRecips[idx].ulRecipClass == ulRecipClass) <br>    { <br>        lstrcat (lpszDisplay, lpRecips[idx].lpszName); <br>        lstrcat (lpszDisplay, "; "); <br>    } <br>    } <br> <br>    if (*lpszDisplay) <br>    lpszDisplay[lstrlen (lpszDisplay) - 2] = '\0'; <br>} <br> <br> <br> <br>/* <br> -  SaveMsgChanges <br> - <br> *  Purpose: <br> *      If while reading a message the user changes the notetext at all <br> *      then this function is called to save those changes in the Inbox. <br> * <br> *  Parameters: <br> *      hWnd            - handle to the window/dialog who called us <br> *      lpMsg           - pointer to the MAPI message to be saved <br> *      lpszMsgID       - ID of the message to save <br> * <br> *  Return: <br> *      ulResult        - Indicating success/failure <br> */ <br> <br>ULONG <br>SaveMsgChanges (HWND hWnd, lpMapiMessage lpMsg, LPSTR lpszMsgID) <br>{ <br>    LPSTR lpszT; <br>    LPSTR lpszNoteText = NULL; <br>    LONG cLines, cb; <br>    ULONG ulResult = MAPI_E_INSUFFICIENT_MEMORY; <br> <br>    lpszT = lpMsg-&gt;lpszNoteText; <br> <br>    cLines = SendDlgItemMessage (hWnd, IDC_READNOTE, EM_GETLINECOUNT, 0, 0L); <br>    cb = SendDlgItemMessage (hWnd, IDC_READNOTE, EM_LINEINDEX, (UINT)cLines - 1, 0L); <br>    cb += SendDlgItemMessage (hWnd, IDC_READNOTE, EM_LINELENGTH, (UINT)cb, 0L); <br>    cb += cLines * 2; <br> <br>    lpszNoteText = (LPTSTR)PvAlloc(cb + 1); <br> <br>    if (!lpszNoteText) <br>    goto err; <br> <br>    SendDlgItemMessage (hWnd, IDC_READNOTE, WM_GETTEXT, <br>    (WPARAM) cb, (LPARAM) lpszNoteText); <br> <br>    lpMsg-&gt;lpszNoteText = lpszNoteText; <br>    ulResult = MAPISaveMail (lhSession, (ULONG) hWnd, lpMsg, MAPI_LONG_MSGID, <br>        0, lpReadMsgNode-&gt;lpszMsgID); <br> <br>    PvFree(lpszNoteText); <br> <br>err: <br>    lpMsg-&gt;lpszNoteText = lpszT; <br>    return ulResult; <br>} <br> <br> <br> <br>/* <br> -  MakeNewMessage <br> - <br> *  Purpose: <br> *      This function is used to construct a new message for the <br> *      ComposeNote UI.  This gets called as a result of a Reply, <br> *      ReplyAll, or a Forward action on a message being read. <br> *      The destination for the new message is lpmsg, the global <br> *      MapiMessage struct pointer used by ComposeNoteDlgProc. <br> *      ComposeNoteDlgProc always frees the memory consumed by <br> *      this object whether it allocated it or not. <br> * <br> *  Parameters: <br> *      lpSrcMsg            - MapiMessage to be copied <br> *      flType              - Specifies the action that caused this call <br> *                            either: IDC_REPLY, IDC_REPLYALL, or IDC_FORWARD <br> * <br> *  Return: <br> *      ulResult            - Indicates success/failure <br> */ <br> <br>ULONG <br>MakeNewMessage (lpMapiMessage lpSrcMsg, UINT flType) <br>{ <br>    ULONG idx; <br>    ULONG ulResult = SUCCESS_SUCCESS; <br> <br>    if (!lpSrcMsg) <br>    return MAPI_E_FAILURE; <br> <br>    lpmsg = (lpMapiMessage)PvAlloc(sizeof (MapiMessage)); <br> <br>    if (!lpmsg) <br>    goto err; <br> <br>    memset (lpmsg, 0, sizeof (MapiMessage)); <br> <br>    lpmsg-&gt;flFlags = flSendMsgFlags; <br> <br>    if (lpSrcMsg-&gt;lpszSubject) <br>    { <br>    lpmsg-&gt;lpszSubject = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg-&gt;lpszSubject) + 5); <br> <br>    if (!lpmsg-&gt;lpszSubject) <br>        goto err; <br> <br>    if (flType == IDC_FORWARD) <br>        lstrcpy (lpmsg-&gt;lpszSubject, "FW: "); <br>    else <br>        lstrcpy (lpmsg-&gt;lpszSubject, "RE: "); <br> <br>    lstrcat (lpmsg-&gt;lpszSubject, lpSrcMsg-&gt;lpszSubject); <br>    } <br> <br>    if (lpSrcMsg-&gt;lpszNoteText) <br>    { <br>    lpmsg-&gt;lpszNoteText = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg-&gt;lpszNoteText) + 32); <br> <br>    if (!lpmsg-&gt;lpszNoteText) <br>        goto err; <br> <br>    lstrcpy (lpmsg-&gt;lpszNoteText, "\r\n--------------------------\r\n"); <br>    lstrcat (lpmsg-&gt;lpszNoteText, lpSrcMsg-&gt;lpszNoteText); <br>    } <br> <br>    if (lpSrcMsg-&gt;lpszMessageType) <br>    { <br>    lpmsg-&gt;lpszMessageType = (LPTSTR)PvAlloc(lstrlen (lpSrcMsg-&gt;lpszMessageType) + 1); </code></pre>
<p>
</p>
<pre><code><br>    if (!lpmsg-&gt;lpszMessageType) <br>        goto err; <br> <br>    lstrcpy (lpmsg-&gt;lpszMessageType, lpSrcMsg-&gt;lpszMessageType); <br>    } <br> <br>    if (lpSrcMsg-&gt;lpszConversationID) <br>    { <br>    lpmsg-&gt;lpszConversationID = (LPTSTR)PvAlloc(lstrlen(lpSrcMsg-&gt;lpszConversationID) + 1); <br> <br>    if (!lpmsg-&gt;lpszConversationID) <br>        goto err; <br> <br>    lstrcpy (lpmsg-&gt;lpszConversationID, lpSrcMsg-&gt;lpszConversationID); <br>    } <br> <br>    if (lpSrcMsg-&gt;nFileCount &amp;&amp; flType == IDC_FORWARD ) <br>    { <br>    lpmsg-&gt;nFileCount = lpSrcMsg-&gt;nFileCount; <br> <br>    lpmsg-&gt;lpFiles = (lpMapiFileDesc)PvAlloc(lpmsg-&gt;nFileCount * sizeof (MapiFileDesc)); <br> <br>    if (!lpmsg-&gt;lpFiles) <br>        goto err; <br>        memset (lpmsg-&gt;lpFiles, 0, (size_t)lpmsg-&gt;nFileCount * sizeof (MapiFileDesc)); <br> <br>        for (idx = 0; idx &lt; lpmsg-&gt;nFileCount; idx++) <br>    {        <br>        CopyAttachment (lpmsg-&gt;lpFiles, &amp;lpmsg-&gt;lpFiles[idx], <br>        &amp;lpSrcMsg-&gt;lpFiles[idx]); <br>         <br>            if ((&amp;lpmsg-&gt;lpFiles[idx])-&gt;nPosition != (ULONG) -1) <br>            {        <br>                /*lpmsg-&gt;lpszNoteText[(&amp;lpmsg-&gt;lpFiles[idx])-&gt;nPosition  <br>                            + lstrlen("\r\n--------------------------\r\n")] = '+';*/ <br>                (&amp;lpmsg-&gt;lpFiles[idx])-&gt;nPosition = (ULONG) -1; <br>                 <br>            } <br>                                 <br>             <br>        } <br>    } <br> <br>    if (flType == IDC_REPLY || flType == IDC_REPLYALL) <br>    { <br>        ULONG idxSrc; <br> <br>    if(lpSrcMsg-&gt;lpOriginator) <br>        lpmsg-&gt;nRecipCount = 1; <br> <br>    if (flType == IDC_REPLYALL) <br>        lpmsg-&gt;nRecipCount += lpSrcMsg-&gt;nRecipCount; <br> <br>        if(!lpmsg-&gt;nRecipCount) <br>            return ulResult; <br> <br>    lpmsg-&gt;lpRecips = (lpMapiRecipDesc)PvAlloc(lpmsg-&gt;nRecipCount * sizeof (MapiRecipDesc)); <br> <br>    if (!lpmsg-&gt;lpRecips) <br>        goto err; <br> <br>        memset (lpmsg-&gt;lpRecips, 0, (size_t)lpmsg-&gt;nRecipCount * sizeof (MapiRecipDesc)); <br>        idx = 0; <br> <br>        if(lpSrcMsg-&gt;lpOriginator) <br>        { <br>        lpSrcMsg-&gt;lpOriginator-&gt;ulRecipClass = MAPI_TO; <br>        CopyRecipient (lpmsg-&gt;lpRecips, lpmsg-&gt;lpRecips, <br>                lpSrcMsg-&gt;lpOriginator); <br>        lpSrcMsg-&gt;lpOriginator-&gt;ulRecipClass = MAPI_ORIG; <br>            idx = 1; <br>        } <br> <br>    for (idxSrc = 0; idx &lt; lpmsg-&gt;nRecipCount; idxSrc++, idx++) <br>        CopyRecipient (lpmsg-&gt;lpRecips, &amp;lpmsg-&gt;lpRecips[idx], <br>        &amp;lpSrcMsg-&gt;lpRecips[idxSrc]); <br>    } <br> <br>    return ulResult; <br> <br>err: <br>    if(lpmsg) <br>    { <br>        PvFree(lpmsg-&gt;lpszSubject); <br>    PvFree(lpmsg-&gt;lpszNoteText); <br>        PvFree(lpmsg-&gt;lpszMessageType); <br>        PvFree(lpmsg-&gt;lpszConversationID); <br>        PvFree(lpmsg-&gt;lpRecips); <br>        PvFree(lpmsg-&gt;lpFiles); <br>        PvFree(lpmsg); <br>        lpmsg = NULL; <br>    } <br>    return ulResult; <br>} <br> <br> <br> <br>/* <br> -  LogSendMail <br> - <br> *  Purpose: <br> *      Used to track how many messages were sent with this client. <br> *      This information is used strictly for gathering stats on <br> *      how many messages were pumped through the spooler/transport. <br> * <br> *  Usage: <br> *      Add the following to the win.ini file: <br> *          [MAPI Client] <br> *          LogFile=filepath <br> * <br> *      where: filepath can be a full UNC path or some local path &amp; file <br> * <br> *  Parameters: <br> *      ulResult        - Currently unused; should be used to count errors <br> * <br> *  Result: <br> *      Void. <br> */ <br> <br>void LogSendMail(ULONG ulResult) <br>{ <br>    char szLogFile[128]; <br>    char szCount[32]; <br>    OFSTRUCT ofs; <br>    HFILE hf = HFILE_ERROR; <br>    int cSent = 1; <br> <br>    if(!GetProfileString("MAPI Client", "LogFile", "mapicli.log", <br>        szLogFile, sizeof(szLogFile))) <br>    return; <br> <br>    if((hf = OpenFile(szLogFile, &amp;ofs, OF_READWRITE)) == HFILE_ERROR) <br>    { <br>    if((hf = OpenFile(szLogFile, &amp;ofs, OF_CREATE|OF_READWRITE)) == HFILE_ERROR) <br>        return; <br>    } <br>    else <br>    { <br>    if(!_lread(hf, szCount, sizeof(szCount))) <br>    { <br>        _lclose(hf); <br>        return; <br>    } <br> <br>    cSent = atoi(szCount) + 1; <br>    } <br> <br>    wsprintf(szCount, "%d", cSent); <br> <br>    _llseek(hf, 0, 0); <br> <br>    _lwrite(hf, szCount, lstrlen(szCount)); <br>    _lclose(hf); <br> <br>    return; <br>} <br> <br> <br> <br>/* <br> -  SaveFileAttachments <br> - <br> *  Purpose: <br> *      Displays a 'Save As' common dialog to allow the user to save <br> *      file attachments contained in the current message. <br> * <br> *  Parameters: <br> *      hWnd            - Window handle of calling WndProc <br> *      cFiles          - Count of the files in the file array <br> *      lpFiles         - Array of MapiFileDescs <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void SaveFileAttachments(HWND hWnd, lpMapiFileDesc lpFile) <br>{ <br>    OPENFILENAME ofn; <br>    char szFileName[256] = ""; <br>    char szFilter[256]; <br>    static char szFileTitle[16]; <br>    static char szDirName[256] = ""; <br>    LPSTR lpszEndPath; <br>    ULONG idx; <br> <br>    if (!lpFile) <br>    return; <br> <br>    if (!szDirName[0]) <br>    GetTempPath (sizeof(szDirName), szDirName); <br> <br>    LoadString(hInst, IDS_FILTER, szFilter, sizeof(szFilter)); <br> <br>    for (idx = 0; szFilter[idx] != '\0'; idx++) <br>    if (szFilter[idx] == '|') <br>        szFilter[idx] = '\0'; <br> <br>    lstrcpy (szFileName, lpFile-&gt;lpszFileName); <br> <br>    ofn.lStructSize = sizeof (OPENFILENAME); <br>    ofn.hwndOwner = hWnd; <br>    ofn.hInstance = 0; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1L; <br>    ofn.lpstrFile = szFileName; <br>    ofn.nMaxFile = sizeof(szFileName); <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = sizeof(szFileTitle); <br>    ofn.lpstrInitialDir = szDirName; <br>    ofn.lpstrTitle = "Save Attachment"; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = NULL; <br>    ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY; <br> <br>    if (!GetSaveFileName (&amp;ofn)) <br>    return; <br> <br>    /* Save the directory for the next time we call this */ <br> <br>    lstrcpy (szDirName, szFileName); <br>    if (lpszEndPath = strstr (szDirName, szFileTitle)) <br>    *(--lpszEndPath) = '\0'; <br> <br>    /* Use CopyFile to carry out the operation. */ <br> <br>    if(!CopyFile(lpFile-&gt;lpszPathName, szFileName, FALSE)) <br>    MakeMessageBox (hWnd, 0, IDS_SAVEATTACHERROR, MBS_ERROR); <br>} <br> <br> <br> <br>/* <br> -  ToggleMenuState <br> - <br> *  Purpose: <br> *      Enables/Disables menu items depending on the session state. <br> * <br> *  Parameters: <br> *      hWnd            - handle to the window/dialog who called us <br> *      fLoggedOn       - TRUE if logged on, FALSE if logged off <br> * <br> *  Return: <br> *      Void. <br> */ <br> <br>void ToggleMenuState(HWND hWnd, BOOL fLoggedOn) <br>{ <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGOFF,   !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_COMPOSE,  !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_READ,     !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_SEND,     !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_ADDRBOOK, !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_DETAILS,  !fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGON,    fLoggedOn); <br>    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,           FALSE); <br>} <br> <br>// <br>//  SecureMenu <br>// <br>//  Purpose: <br>//      Enables/Disables Logon and Exit menu items. <br>//      CMCLogon might yield control to Windows, so the user might be able to <br>//      access the window menu (for example click Logon) after we call <br>//      MAPILogon, but before it returns. <br>// <br>//  Parameters: <br>//      hWnd            - handle to the window/dialog who called us <br>//      fBeforeLogon    - TRUE when this function is called when we are about <br>//                      to call MAPILogon, FALSE if called after logon (failed) <br>//                      if Logon succeddes ToggleMenuState is called instead of <br>//                      this function. <br>// <br>//  Return: <br>//      Void. <br>// <br> <br> <br>void SecureMenu(HWND hWnd, BOOL fBeforeLogon) <br>{ <br>    EnableMenuItem (GetMenu (hWnd), IDM_LOGON, fBeforeLogon); <br>    EnableMenuItem (GetMenu (hWnd), IDM_EXIT,  fBeforeLogon); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
