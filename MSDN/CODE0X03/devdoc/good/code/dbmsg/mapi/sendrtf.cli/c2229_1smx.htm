<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SENDRTF.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2229"></a>SENDRTF.CPP</h2>
<pre><code>//////////////////////////////////////////////////////////////////////////// <br>//  SENDRTF.CPP <br>// <br>//  Command line mail program to send rtf files in a message body. <br>// <br>//  Copyright 1986-1996, Microsoft Corporation. All Rights Reserved. <br>//////////////////////////////////////////////////////////////////////////// <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;mapiutil.h&gt; <br>#include &lt;mapix.h&gt; <br>#include &lt;mapidbg.h&gt; <br>#include &lt;cindex.h&gt; <br> <br>#ifdef DEBUG <br>#define TraceFnResult(f, hr)    \ <br>{ (hr) ?   \ <br>printf(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0;\ <br>} <br>#else <br>#define TraceFnResult(f, hr) <br>#endif  //DEBUG <br> <br>// Globals <br>LPSTR szProfile = NULL;     //profile name <br>LPSTR szPassword = NULL;    //profile password <br>LPSTR szSubject = NULL;     //message subject <br>LPSTR szRTFFile = NULL;     //rtf file name <br>LPSTR szToRecips = NULL;    //recipients <br> <br>BOOL fMAPIInited = FALSE; <br> <br>LPMAPISESSION pses = NULL;              //MAPI session <br>LPADRBOOK pabAddrB = NULL;              //Address Book <br>LPMDB pmdb = NULL;                      //default message store            <br>LPMAPIFOLDER pfldOutBox = NULL;         // Out folder <br>LPSPropValue pvalSentMailEID = NULL;    //Entry ID of the "Sent Mail" folder <br> <br> <br>//Function Prototypes <br>BOOL fParseCommandLine(int argc, char * argv[]); <br>HRESULT InitMAPI(void); <br>void DeInitMAPI(void); <br>HRESULT HrOpenDefaultStore(LPMDB * ppmdb); <br>HRESULT HrOpenAddressBook(LPADRBOOK * ppAdrBook); <br>HRESULT HrOpenOutFolder(LPMAPIFOLDER FAR * lppF); <br>HRESULT HrCreateOutMessage(LPMESSAGE FAR * ppmM); <br>HRESULT HrInitMsg(LPMESSAGE pmsg); <br>HRESULT HrCreateAndSend(void); <br>HRESULT HrCreateAddrList(LPADRLIST * ppal); <br>HRESULT HrSetRTF(LPMESSAGE pmsg); <br> <br> <br> <br>int main(int argc, char * argv[]) <br>{ <br>    HRESULT hr; <br> <br>    if(!fParseCommandLine(argc, argv)) <br>        return 1; <br>     <br>    hr = InitMAPI(); <br>    if(HR_FAILED(hr)) <br>        return 1; <br>     <br>    hr = HrCreateAndSend(); <br>         <br>    DeInitMAPI(); <br> <br>    return 0; <br>} <br> <br> <br>// <br>//  Init MAPI. Open address book, default message store,  outbox  <br>// <br>HRESULT InitMAPI(void) <br>{ <br> <br>    HRESULT hr; <br>    ULONG ulLogonFlag = 0; <br> <br>    hr = MAPIInitialize(NULL); <br>    if(hr) <br>    { <br>        return hr; <br>    } <br>     <br>    fMAPIInited = TRUE; <br> <br>    ulLogonFlag = szProfile ? 0 : MAPI_USE_DEFAULT; <br> <br>    hr = MAPILogonEx(NULL, szProfile, szPassword, <br>                    MAPI_EXTENDED | MAPI_NEW_SESSION | ulLogonFlag, <br>                    &amp;pses); <br>    if(hr) <br>    { <br>        goto err; <br>    } <br> <br>    hr = HrOpenDefaultStore(&amp;pmdb); <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    hr = HrOpenAddressBook(&amp;pabAddrB); <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    hr = HrOpenOutFolder(&amp;pfldOutBox); <br>    if(HR_FAILED(hr)) <br>        goto err; <br>     <br>    /* retrieve the EntryID of the sentmail folder and change the property tag <br>        so that it is ready to use on a message*/ <br>    hr = HrGetOneProp((LPMAPIPROP)pmdb, PR_IPM_SENTMAIL_ENTRYID, &amp;pvalSentMailEID); <br>    if(hr) <br>    { <br>        goto err; <br>    } <br>    pvalSentMailEID-&gt;ulPropTag = PR_SENTMAIL_ENTRYID; <br>     <br>    return hrSuccess; <br> <br>err: <br>    DeInitMAPI(); <br>     <br>    DebugTraceResult(InitMAPI, hr); <br> <br>    return hr; <br>} <br> <br>// <br>//  Release MAPI interfaces and logoff <br>// <br>void DeInitMAPI(void) <br>{ <br> <br>    UlRelease(pfldOutBox); <br>    pfldOutBox = NULL; <br> <br>    if(pmdb) <br>    {    <br>        //get our message out of the outbox <br>        ULONG ulFlags = LOGOFF_PURGE; <br>        HRESULT hr; <br>         <br>        hr = pmdb-&gt;StoreLogoff(&amp;ulFlags); <br> <br>        TraceFnResult(StoreLogoff, hr); <br>#ifdef DEBUG <br>        printf("StoreLogoff output falgs: %lx\n", ulFlags); <br>#endif <br>        UlRelease(pmdb); <br>        pmdb = NULL; <br>    } <br> <br>    UlRelease(pabAddrB); <br>    pabAddrB = NULL; <br> <br>    MAPIFreeBuffer(pvalSentMailEID); <br>    pvalSentMailEID = NULL; <br> <br>    if(pses) <br>    { <br>        pses-&gt;Logoff(0, 0, 0); <br>        UlRelease(pses); <br>        pses = NULL; <br>    } <br> <br>    if(fMAPIInited) <br>    { <br>        MAPIUninitialize(); <br>        fMAPIInited = FALSE; <br>    } <br> <br>} <br> <br>// <br>//  Open the default message store. (The one that has PR_DEFAULT_STORE set to <br>//  TRUE in the message store table. <br>// <br>HRESULT HrOpenDefaultStore(LPMDB * ppmdb) <br>{ <br>    HRESULT hr; <br>    LPMDB lpmdb = NULL; <br>    LPMAPITABLE ptable = NULL; <br>    LPSRowSet prows = NULL; <br>    LPSPropValue pvalProp = NULL; <br>    static SizedSPropTagArray(2, columns) = <br>                { 2, { PR_DEFAULT_STORE, PR_ENTRYID} }; <br>    SPropValue valDefStore; <br>    SRestriction restDefStore; <br> <br>     <br>    valDefStore.ulPropTag = PR_DEFAULT_STORE; <br>    valDefStore.dwAlignPad = 0; <br>    valDefStore.Value.b = TRUE; <br> <br>    restDefStore.rt = RES_PROPERTY; <br>    restDefStore.res.resProperty.relop = RELOP_EQ; <br>    restDefStore.res.resProperty.ulPropTag = PR_DEFAULT_STORE; <br>    restDefStore.res.resProperty.lpProp = &amp;valDefStore; <br>     <br>    Assert(pses); <br> <br>    hr = pses-&gt;GetMsgStoresTable(0, &amp;ptable); <br>    if (HR_FAILED(hr)) <br>    { <br>        TraceFnResult(GetMsgStoresTable, hr); <br>        goto ret; <br>    } <br> <br>     <br>    hr = HrQueryAllRows(ptable, (LPSPropTagArray) &amp;columns, &amp;restDefStore, NULL, 0, &amp;prows); <br>    if (HR_FAILED(hr)) <br>    { <br>        TraceFnResult(HrQyeryAllRows, hr); <br>        goto ret; <br>    } <br> <br>    if (prows == NULL || prows-&gt;cRows == 0 <br>        || prows-&gt;aRow[0].lpProps[1].ulPropTag != PR_ENTRYID) <br>    { <br>        printf("No default store\n"); <br>        goto ret; <br>    } <br>     <br>    Assert(prows-&gt;cRows == 1); <br> <br>    hr = pses-&gt;OpenMsgStore(0, <br>                        prows-&gt;aRow[0].lpProps[1].Value.bin.cb, <br>                        (LPENTRYID)prows-&gt;aRow[0].lpProps[1].Value.bin.lpb, <br>                        NULL, MDB_WRITE | MAPI_DEFERRED_ERRORS, &amp;lpmdb); <br>    if (HR_FAILED(hr)) <br>    { <br>        if (GetScode(hr) != MAPI_E_USER_CANCEL) <br>            TraceFnResult(OpenMsgStore, hr); <br>        goto ret; <br>    } <br> <br>#if 0 <br>    if(hr) /*if we have a warning, display it and succeed */ <br>    { <br>        LPMAPIERROR perr = NULL; <br> <br>        pses-&gt;lpVtbl-&gt;GetLastError(pses, hr, 0, &amp;perr); <br>        MakeMessageBox(hWnd, GetScode(hr), IDS_OPENSTOREWARN, perr, MBS_ERROR); <br>        MAPIFreeBuffer(perr); <br>    } <br> <br>#endif <br> <br>    Assert(lpmdb != NULL); <br> <br>    *ppmdb = lpmdb; <br> <br> <br>                     <br>ret: <br>    FreeProws(prows); <br>    UlRelease(ptable); <br> <br>    DebugTraceResult(OpenDefaultStore, hr); <br>    return hr; <br>} <br> <br>// <br>//  Open MAPI address book <br>// <br>HRESULT HrOpenAddressBook(LPADRBOOK * ppAddrBook) <br>{ <br>    HRESULT hr; <br>    LPADRBOOK pabAddrBook = NULL; <br> <br>    Assert(pses); <br>     <br>    hr = pses-&gt;OpenAddressBook(0, NULL, 0, &amp;pabAddrBook); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(OpenAddressBook, hr); <br>        return hr; <br>    } <br>#if 0 <br>    if(hr) /*if we have a warning*/ <br>    { <br>        LPMAPIERROR perr = NULL; <br> <br>        pses-&gt;lpVtbl-&gt;GetLastError(pses, hr, 0, &amp;perr); <br>        MakeMessageBox(hwnd, GetScode(hr), IDS_OPENABWARN, perr, MBS_ERROR); <br>        MAPIFreeBuffer(perr); <br>    } <br>#endif <br> <br>    *ppAddrBook = pabAddrBook; <br>     <br>    DebugTraceResult(HrOpenAddressBook, hr); <br>    return hrSuccess; <br>} <br> <br>// <br>//  Open the outbox of the default store. <br>//  Assumes the default message store has been opened. <br>// <br>HRESULT HrOpenOutFolder(LPMAPIFOLDER FAR * lppF) <br>{ <br>    LPMAPIFOLDER lpfOutF = NULL; <br>    HRESULT hr; <br>    LPSPropValue lpspvFEID = NULL; <br>    ULONG  ulObjType = 0; <br> <br>    Assert(pmdb); <br> <br>    *lppF = NULL; <br>    hr = HrGetOneProp((LPMAPIPROP) pmdb, PR_IPM_OUTBOX_ENTRYID, &amp;lpspvFEID); <br>    if(hr) <br>    { <br>        TraceFnResult(HrGetOneProp, hr); <br>        goto err; <br>    } <br> <br>    Assert(lpspvFEID-&gt;ulPropTag == PR_IPM_OUTBOX_ENTRYID); <br> <br>    hr = pmdb-&gt;OpenEntry(lpspvFEID-&gt;Value.bin.cb, <br>                        (LPENTRYID)lpspvFEID-&gt;Value.bin.lpb, NULL, <br>                        MAPI_MODIFY | MAPI_DEFERRED_ERRORS, <br>                        &amp;ulObjType, (LPUNKNOWN FAR *) &amp;lpfOutF); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(OpenEntry, hr); <br>        goto err; <br>    } <br> <br>    *lppF = lpfOutF; <br> <br> <br>err: <br>    MAPIFreeBuffer(lpspvFEID); <br> <br>    DebugTraceResult(HrOpenOutFolder, hr); <br>    return hr; <br> <br>} <br> <br> <br>// <br>//  Create an outbound message, put data in it and submit. <br>// <br>HRESULT HrCreateAndSend() <br>{ <br>    HRESULT hr; <br>    LPMESSAGE pmsg = NULL; <br> <br>    hr = HrCreateOutMessage(&amp;pmsg); <br>    if(hr) <br>        return hr; <br> <br>    hr = HrInitMsg(pmsg); <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>    hr = pmsg-&gt;SubmitMessage(0); <br>    TraceFnResult(SubmitMessage, hr); <br> <br>err: <br> <br>    UlRelease(pmsg); <br> <br>    DebugTraceResult(HrCreateAndSend, hr); <br>    return hr; <br> <br>} <br> <br>// <br>//  Create a message in the outbox <br>// <br>HRESULT HrCreateOutMessage(LPMESSAGE FAR * ppmM) <br>{ <br> <br>    LPMESSAGE lpmResM = NULL; <br>    HRESULT hr; <br> <br>    Assert(pfldOutBox); <br> <br>    hr = pfldOutBox-&gt;CreateMessage(NULL, MAPI_DEFERRED_ERRORS, &amp;lpmResM); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(CreateMessage, hr); <br>        return hr; <br>    } <br> <br>    *ppmM = lpmResM; <br> <br>    DebugTraceResult(HrCreateOutMessage, hr); <br>    return hrSuccess; <br>} <br> <br>// <br>//  Put the data from globals in the message <br>// <br>HRESULT HrInitMsg(LPMESSAGE pmsg) <br>{ <br>    HRESULT hr; <br>    LPADRLIST pal = NULL; <br>    enum {iSubj, iSentMail, iConvTopic, iConvIdx, iMsgClass, cProps}; <br>    // PR_SUBJECT, PR_SENTMAIL_ENTRYID, <br>    // PR_CONVERSATION_TOPIC, PR_COVERSATION_INDEX <br>     <br>    SPropValue props[cProps]; <br>    ULONG cbConvIdx = 0; <br>    LPBYTE lpbConvIdx = NULL; <br>     <br>    //recipients <br>    hr = HrCreateAddrList(&amp;pal); <br>    if(HR_FAILED(hr)) <br>        goto err; <br>     <br>    Assert(pal); <br> <br>    hr = pmsg-&gt;ModifyRecipients(0, pal); <br>    if(HR_FAILED(hr)) <br>    { <br>        goto err; <br>    } <br> <br>    //subject  and conversation topic <br>    if(szSubject) <br>    { <br>        props[iSubj].ulPropTag = PR_SUBJECT; <br>        props[iSubj].Value.LPSZ = szSubject; <br> <br>        props[iConvTopic].ulPropTag = PR_CONVERSATION_TOPIC; <br>        props[iConvTopic].Value.LPSZ = szSubject; <br>    } <br>    else <br>    { <br>        props[iSubj].ulPropTag = PR_NULL; <br>        props[iConvTopic].ulPropTag = PR_NULL; <br>    } <br> <br>    // conversaton index <br>    if(!ScAddConversationIndex(0, NULL, &amp;cbConvIdx, &amp;lpbConvIdx)) <br>    { <br>        props[iConvIdx].ulPropTag = PR_CONVERSATION_INDEX; <br>        props[iConvIdx].Value.bin.lpb = lpbConvIdx; <br>        props[iConvIdx].Value.bin.cb = cbConvIdx; <br>    } <br>    else <br>    { <br>        props[iConvIdx].ulPropTag = PR_NULL; <br>    } <br> <br>    // sent mail entry id (we want to leave a copy in the "Sent Items" folder) <br>    props[iSentMail] = *pvalSentMailEID; <br>     <br>    props[iMsgClass].ulPropTag = PR_MESSAGE_CLASS; <br>    props[iMsgClass].Value.lpszA = "IPM.Note"; <br> <br>    hr = pmsg-&gt;SetProps(cProps, (LPSPropValue)&amp;props, NULL); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(SetProps, hr); <br>        goto err; <br>    } <br> <br>    //body (PR_RTF_COMPRESSED) <br> <br>    hr = HrSetRTF(pmsg); <br>    if(HR_FAILED(hr)) <br>        goto err; <br> <br>err: <br>    FreePadrlist(pal); <br>    MAPIFreeBuffer(lpbConvIdx); <br> <br>    DebugTraceResult(HrInitMsg, hr); <br>    return hr; <br> <br>} <br> <br>// <br>//  Put the context of the input file in PR_RTF_COMPRESSED <br>// <br>HRESULT HrSetRTF(LPMESSAGE pmsg) <br>{ <br>    if(!szRTFFile) <br>        return hrSuccess; <br> <br>    Assert(pmsg); <br> <br>    HRESULT hr; <br>    LPSTREAM lpstrRTFComp = NULL; <br>    LPSTREAM lpstrRTF = NULL; <br>    LPSTREAM lpstrRTFFile = NULL; <br>    STATSTG statstg; <br>    BOOL fUpdated; <br>    LPSPropValue pvalSupMask = NULL; <br> <br>    hr = OpenStreamOnFile(MAPIAllocateBuffer, MAPIFreeBuffer, <br>                            STGM_READ | STGM_SHARE_DENY_WRITE, <br>                            szRTFFile,  NULL, &amp;lpstrRTFFile); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(OpenStreamOnFile, hr); <br>        printf("Can't open file %s \n", szRTFFile); <br>        goto err; <br>    } <br> <br>    hr = pmsg-&gt;OpenProperty (PR_RTF_COMPRESSED, &amp;IID_IStream, <br>                        0, MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS, <br>                            (LPUNKNOWN FAR *)&amp;lpstrRTFComp); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(OpenProperty, hr); <br>        goto err; <br>    } <br> <br>    hr = HrGetOneProp(pmsg, PR_STORE_SUPPORT_MASK, &amp;pvalSupMask); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(HrGetOneProp, hr); <br>        goto err; <br>    } <br> <br>    hr = WrapCompressedRTFStream(lpstrRTFComp, <br>                MAPI_MODIFY | (pvalSupMask-&gt;Value.l &amp; STORE_UNCOMPRESSED_RTF), <br>                &amp;lpstrRTF); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(WrapCompressedRTFStream, hr); <br>        goto err; <br>    } <br> <br>    hr = lpstrRTFFile-&gt;Stat(&amp;statstg, STATFLAG_NONAME); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(Stat, hr); <br>        goto err; <br>    } <br> <br>    hr = lpstrRTFFile-&gt;CopyTo(lpstrRTF, statstg.cbSize, NULL, NULL); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(CopyTo, hr); <br>        goto err; <br>    } <br> <br>    hr = lpstrRTF-&gt;Commit(STGC_OVERWRITE); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(Commit, hr); <br>        goto err; <br>    } <br> <br>    if( !(pvalSupMask-&gt;Value.l &amp; STORE_RTF_OK)) <br>    { <br>#ifdef DEBUG <br>        printf("RTFSync will be called\n"); <br>#endif //DEBUG <br>         <br>        hr = RTFSync(pmsg, RTF_SYNC_RTF_CHANGED, &amp;fUpdated); <br>        if(HR_FAILED(hr)) <br>        { <br>            TraceFnResult(RTFSync, hr); <br>            goto err; <br>        } <br>    } <br> <br>err: <br> <br>    UlRelease(lpstrRTF); <br>    UlRelease(lpstrRTFComp); <br>    UlRelease(lpstrRTFFile); <br> <br>    MAPIFreeBuffer(pvalSupMask); <br> <br>    DebugTraceResult(HrSetRTF, hr); <br> <br>    return hr; <br>} <br> <br>// <br>//  Create an adrlist with resolved recipients <br>// <br>HRESULT HrCreateAddrList(LPADRLIST * ppal) <br>{ <br>     <br>    HRESULT hr; <br>    LPADRLIST pal = NULL; <br>    int ind; <br>    #define chDELIMITER ';' <br> <br> <br>    int nToRecips = 1; <br>    LPSTR strToken = szToRecips; <br>    while (strToken = strchr(strToken, chDELIMITER)) <br>    {       <br>        ++strToken; <br>        ++nToRecips; <br>    }  <br> <br>    int cb = CbNewADRLIST(nToRecips); <br> <br>    hr = MAPIAllocateBuffer(cb, (LPVOID FAR *) &amp;pal); <br>    if(hr)  <br>    { <br>        TraceFnResult(MAPIAllocateBuffer, hr); <br>        goto err; <br>    } <br>    ZeroMemory(pal, cb); <br> <br>    hr = MAPIAllocateBuffer(2 * sizeof(SPropValue), <br>                            (LPVOID FAR *)&amp;pal-&gt;aEntries[0].rgPropVals); <br>    if(hr)  <br>    { <br>        TraceFnResult(MAPIAllocateBuffer, hr); <br>        goto err; <br>    } <br>     <br>    pal-&gt;aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME; <br>    pal-&gt;aEntries[0].rgPropVals[0].Value.LPSZ = szToRecips; <br>    pal-&gt;aEntries[0].rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE; <br>    pal-&gt;aEntries[0].rgPropVals[1].Value.l= MAPI_TO; <br>    pal-&gt;aEntries[0].cValues = 2; <br>     <br>    strToken = szToRecips; <br> <br>    for(ind = 1; ind &lt; nToRecips; ++ind) <br>    { <br>        LPADRENTRY pae = &amp;pal-&gt;aEntries[ind]; <br>         <br>        hr = MAPIAllocateBuffer(2 * sizeof(SPropValue), <br>                            (LPVOID FAR *)&amp;pae-&gt;rgPropVals); <br>        if(hr)  <br>        { <br>            TraceFnResult(MAPIAllocateBuffer, hr); <br>            goto err; <br>        } <br> <br>        strToken = strchr(strToken, chDELIMITER); <br>        Assert(strToken); <br> <br>        *strToken++ = '\0'; <br> <br>        pae-&gt;rgPropVals[0].ulPropTag = PR_DISPLAY_NAME; <br>        pae-&gt;rgPropVals[0].Value.LPSZ = strToken; <br>        pae-&gt;rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE; <br>        pae-&gt;rgPropVals[1].Value.l = MAPI_TO; <br>        pae-&gt;cValues = 2; <br>    } <br>     <br>    pal-&gt;cEntries = nToRecips; <br>    hr = pabAddrB-&gt;ResolveName(0, 0, NULL, pal); <br>    if(HR_FAILED(hr)) <br>    { <br>        TraceFnResult(ResolveName, hr); <br>        goto err; <br>    } <br> <br>    *ppal = pal; <br> <br>    return hrSuccess; <br> <br>err: <br> <br>    FreePadrlist(pal); <br> <br>    DebugTraceResult(HrCreateAddrList, hr); <br>    return hr; <br>} <br>     <br> <br>//====================================================================== <br>//  ProcessCommandLineArguments - show usage to the user <br>//====================================================================== <br> <br>BOOL fParseCommandLine(int argc,char * argv[]) <br>{ <br>    BOOL fResult; <br>    int iCount; <br> <br>    fResult = FALSE; <br>    _try <br>    { <br>      if (argc &lt; 2)                                // Must be at least 1 argument <br>      { <br>         return fResult;                           // Show Usage to user. <br>      } <br>         <br>      for (iCount = 1; iCount &lt; argc; iCount++) <br>      { <br>        if ((*argv[iCount] == '-') || (*argv[iCount] == '/')) <br>        { <br>            switch (tolower(*(argv[iCount]+1)))            // Process switches <br>            { <br>            case 'u': <br>                szProfile = argv[++iCount]; <br>                break; <br>                 <br>            case 'p': <br>                szPassword = argv[++iCount]; <br>                break; <br> <br>            case 't': <br>                szToRecips = argv[++iCount]; <br>                break; <br> <br>            case 's': <br>                szSubject = argv[++iCount]; <br>                break; <br> <br>            case 'f': <br>                szRTFFile = argv[++iCount]; <br>                break; <br> <br>            case 'h': <br>            case '?':                   // User asked for help '-?' <br>            default: <br>                return fResult; <br>            } // Switch <br>        }   // If  <br>      } // For Argument Count <br> <br>       <br>      // Check for required command line arguments   <br> <br>      if (szToRecips) <br>      { <br>         fResult = TRUE; <br>      }  <br>      else <br>      { <br>         printf("ERROR: Recipient(s) required.\n"); <br> <br>      } <br>      return fResult; <br> <br>    } <br>    _finally  <br>    { <br>        if (!fResult) <br>        { <br>            printf( "\nSend MAPI messages from Win32 command line.\n" ); <br>            printf( "Usage: sendrtf [-u] [-p] -t [-s] [-f][-v][-?]\n" ); <br>            printf( "Where...\n\n" ); <br>            printf( "-u  profile name \n" ); <br>            printf( "-p  profile password \n" ); <br>            printf( "-t  recipient(s) (multiples must be separated by ';' and " <br>                    "enclosed in double\n"); <br>            printf( "    quotes. recipients must not be ambiguous in default " <br>                    "address book.)\n" ); <br>            //printf( "-c  specifies mail copy list (cc: list) \n" ); <br>            printf( "-s  subject line \n" ); <br>            printf( "-f  file (in rtf format) to be used as a message body\n" ); <br>            //printf( "-v  generates verbose output\n" ); <br>            printf( "-?  prints this message\n" ); <br>         } <br>    } // Finally <br>} // End of Function <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
