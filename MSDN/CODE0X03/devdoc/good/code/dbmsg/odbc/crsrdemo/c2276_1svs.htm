<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CRSRDEMO.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2278"></a>CRSRDEMO.H</h2>
<pre><code>/*-------------------------------------------------------------------------- <br>  Cursors.h -- General constants, types, prototypes and variables <br> <br>  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>  intended for example purposes only. <br> <br>--------------------------------------------------------------------------*/ <br> <br>#ifndef __CURSORS_H <br>#define __CURSORS_H <br> <br> <br>#ifdef_M_ALPHA <br>#define  Print(x,y,z) wsprintf(x,y,z) <br>#else <br>#define Print(x,y,z)  wvsprintf(x,y,z) <br>#endif <br> <br> <br>#ifdef INCL_GLOBAL <br>#define GLOBAL <br>#define INITHAND(name, type)    type name = NULL <br>#ifdef WIN32 <br>#define CONSTSTR(name, str) const char name[]=str <br>#else <br>#define CONSTSTR(name, str) const char FAR * name=str <br>#endif <br>#else <br>#define GLOBAL  extern <br>#define INITHAND(name, type)    extern type name <br>#ifdef WIN32 <br>#define CONSTSTR(name, str) extern const char name[] <br>#else <br>#define CONSTSTR(name, str) extern const char FAR * name <br>#endif <br>#endif <br> <br> <br>// Constants --------------------------------------------------------------- <br>#ifdef WIN32 <br>#define EXPFUNC __stdcall <br>#define INTFUNC __stdcall <br>#else <br>#define EXPFUNC __export __far __pascal <br>#define INTFUNC __pascal <br>#endif <br> <br> <br>#define INLINE __inline <br> <br>// Miscellaneous <br>#define cbMAXSQL    512                    // Maximum SQL string length <br>#define cbSTRLEN    256                    // Maximum string length <br>#define cbINTLEN    16                     // maximum length of an decimal <br>                                           // integer in text format <br>#define cbBUFSIZE   4096                   // Working buffer size <br>#define cPOINTS 10                         // Font point size <br>#define cxBORDER    6                      // Painting border <br>#define cyBORDER    2                      // Painting border <br>#define MAX_MAXBIND 200                    // maximum length of any column <br>#define DEF_MAXBIND 50                     // default maximum length <br> <br>// Miscellaneous strings <br>CONSTSTR(szMDICLIENT,   "MDICLIENT"); <br>CONSTSTR(szCHILDCLASS,  "CursorsChild"); <br>CONSTSTR(szFRAMECLASS,  "CursorsFrame"); <br>CONSTSTR(szSTATICCLASS, "STATIC"); <br>CONSTSTR(szEDITCLASS,   "EDIT"); <br>CONSTSTR(szSCROLLCLASS, "SCROLLBAR"); <br>CONSTSTR(szDSNKEY,      "DSN="); <br>CONSTSTR(szDATATRUNC,   "01004"); <br>CONSTSTR(szTITLEFMT,    "%s (CURSOR%04d)"); <br>CONSTSTR(szCURSORNAME,  "CURSOR%04d"); <br>CONSTSTR(szFONT,        "MS Sans Serif"); <br>CONSTSTR(szRECORD,      "Record:"); <br>CONSTSTR(szRECNUM,      "%6d"); <br>CONSTSTR(szHELPFILE,    "..\\doc\\odbcsmpl.hlp");  // Samples help file <br>CONSTSTR(szKeyword,"cursor demo features"); <br> <br>#define HLP_CRSRDEMO 40     // magic from help file <br> <br>// Macros <br>#define AllocPtr(x) GlobalAllocPtr(GHND, (x)) <br>#define FreePtr(x)      if ((x)) GlobalFreePtr((x)) <br>#define DBCError(hwnd,x)    ODBCError(hwnd,SQL_HANDLE_DBC, g_hdbc, (x)) <br>#define ENVError(hwnd,x)    ODBCError(hwnd,SQL_HANDLE_ENV, g_henv,  (x)) <br> <br>#define SUCCESS(x)  (((x)==SQL_SUCCESS) || ((x)==SQL_SUCCESS_WITH_INFO)) <br> <br>#define ISBLANK(x)      ((x) == ' ') <br>#define ISCOMMA(x)      ((x) == ',') <br>#define ISNUM(x)        (((x) &gt;= '0') &amp;&amp; ((x) &lt;= '9')) <br>#define ISLPAREN(x)     ((x) == '(') <br>#define ISRPAREN(x)     ((x) == ')') <br>#define ISPERIOD(x)     ((x) == '.') <br>#define ISRETURN(x)     (((x) == '\n') || ((x) == '\r')) <br>#define ISTAB(x)        ((x) == '\t') <br>#define ISWHITE(x)      (ISBLANK(x) || ISTAB(x) || ISRETURN(x)) <br> <br>#define ROW_BINDING(x)  (x-&gt;fBindByRow ==   IDC_RADIO_BINDROW) <br>#define IS_ALLWFETCH(x) (x-&gt;dwGuiFlags &amp; GUIF_ALWAYSFETCH) <br>#define UNREF_PARAM(x)  (x) <br> <br>#define MAXNAME     100 <br> <br> <br>// Types ------------------------------------------------------------------- <br>typedef UWORD  FAR  *LPUWORD; <br>typedef SDWORD FAR  *LPSDWORD; <br> <br>typedef struct tagBIGCOL {                 // Big column structure <br>    char        szName[cbSTRLEN];          //   Column name <br>    LPSTR       lpsz;                      //   Pointer to column data <br>    SDWORD      cb;                        //   Length of data <br>} BIGCOL, FAR *LPBIGCOL; <br> <br>typedef struct tagCOL {                    // Column structure <br>    char        szName[cbSTRLEN];          //   Column name <br>    SDWORD      cb;                        //   Column width (transfer width) <br>    SDWORD      cbc;                       //   Column width (display  width) <br>    SWORD       fCType;                    //   C type <br>    SWORD       fSqlType;                  //   ODBC Sql type <br>    LPSDWORD    lpcb;                      //   Pointer to returned width <br>    LPBYTE      lpb;                       //   Pointer to returned data <br>} COL, FAR *LPCOL; <br> <br>typedef struct tagCHILD {                  // Child window variables <br>    HWND        hwnd;                      //   Current window handle <br>    BOOL        fInSetScroll;              //   In SetScroll function flag <br>    BOOL        fIsMinimized;              //   Window minimized flag <br>    BOOL        fHaveMouse;                //   Mouse captured flag <br>    int         iMouseRow;                 //   Mouse down row <br> <br>    int         ccols;                     //   Number of characters per line <br>    int         crowwin;                   //   Rows per window <br>    int         ccolwin;                   //   Character columns per window <br>    HWND        hwndVScroll;               //   Vertical scroll bar <br>    HWND        hwndHScroll;               //   Horizontal scroll bar <br>    BOOL        fVScroll;                  //   Vertical scroll active flag <br>    BOOL        fHScroll;                  //   Horizontal scroll active flag <br> <br>    LPINT       lpnTabs;                   //   Array of tab values <br>    char        szFmt[cbSTRLEN];           //   Format string <br>    char *     rglpv;                     //   wvsprintf data array <br> <br>    HRGN        hrgn;                      //   Clip region <br>    LPSTR       lpsz;                      //   Working buffer <br> <br>    SQLHSTMT    hstmt;                     //   ODBC statement handle <br>    SQLHSTMT    hstmtTmp;                  //   Temp ODBC statement handle <br>    LPSTR       sql;                       //   SQL statement <br> <br>    SWORD       ccol;                      //   Number of result columns <br>    LPCOL       lpcol;                     //   Column information array <br>    BOOL        fResultSetExists;          //   Result set exists flag <br>    BOOL        fDataFetched;              //   Data has been fetched flag <br>    LPUWORD     lpfStatus;                 //   Row status array <br> <br>    BOOL        fBindByRow;                //   Row-wise binding flag <br>    LPBYTE      lpb;                       //   Row-wise binding buffer <br>    SDWORD      cbrow;                     //   Row-wise binding step quantity <br> <br>    UWORD       fConcurrency;              //   Scroll concurrency <br>    SDWORD      crowKeyset;                //   Keyset option <br>    UWORD       crowRowset;                //   Rowset option <br>    BOOL        fRowset;                   //   crowRowset has been modified <br>    char        szRowset[cbINTLEN];        //   text format buffer of inputed <br>                                           //   crowRowset <br> <br>    BOOL        fAsync;                    //   Async enabled flag <br>    BOOL        fCanceled;                 //   Request canceled flag <br>    UWORD       irowPos;                   //   Positioned row (via SQLSetPos) <br>    SDWORD      irow;                      //   First row in row set (absolute) <br>    UWORD       cBind;                     //   Number of bound columns <br>    BOOL        fBind;                     //   cBind's been modified  <br>    char        szBind[cbINTLEN];          //   a buffer to store the <br>                                           // text format of inputed cBind <br>    BOOL        fBindAll;                  //   Bind all columns flag <br>    UWORD       ccolRetrieved;             //   Number of retrieved columns <br> <br>    SDWORD      arow;                      //   Fetch absolute value <br>    SDWORD      rrow;                      //   Fetch relative value <br>    UCHAR       szQualifier[MAXNAME];      //   qualifier name <br>    UCHAR       szTable[MAXNAME];          //   table name <br>    UCHAR       szUser[MAXNAME];           //   user name <br>    UCHAR       szType[MAXNAME];           //   table type (for SQLtables) <br>    UCHAR       szColName[MAXNAME];        //   column name (for SQLColumns) <br>    UWORD       dwOperation;               //   operation to perform  (mistype) <br>    DWORD       dwGuiFlags;                //   flags and state to the gui <br>    SDWORD      crowMaxBind;               //   max length to bind col to <br>    BOOL        fMaxBind;                  //   crowMaxBind has been modified <br>    char        szMaxBind[cbINTLEN];       //   the text format buffer of the  <br>                                           //   inputed crowMaxBind <br>    DWORD       crowCurrent;               //   current actual size of rowset <br>    BOOL        fNoConcurrency;            //   driver doesn't support concur <br>    BOOL        fNoCursorType;             //   no cursor type <br>    UWORD       dwRadioButton;             //   What radio button in info dlg? <br>    UWORD       FetchOP; <br>#ifdef THREAD <br>    CRITICAL_SECTION ThreadCreation; <br>    HANDLE hThread; <br>#endif <br>} CHILD, FAR *LPCHILD; <br> <br>#define     OPER_SELECT     1 <br>#define     OPER_TABLES     2 <br>#define     OPER_PRIVS      3 <br>#define     OPER_STATS      4 <br>#define     OPER_PROCS      5 <br>#define     OPER_COLUMN     6 <br>#define     OPER_TYPES      7 <br> <br> <br>#define     GUIF_TABLES_RADIO   0x00001     // 'tables' radio button set <br>#define     GUIF_ALWAYSFETCH    0x00002     // always fetch first <br> <br>#define SetDlgText(hdlg,id,text)  Edit_SetText(GetDlgItem(hdlg,id), text) <br> <br>// dialog pair -- dialog and id <br> <br>typedef struct tagDialogPair{ <br>    LPSTR   szDlgPairTitle; <br>    int     iDlgPairDlgId; <br>} DIALOG_PAIR; <br> <br> <br> <br> <br>// Prototypes -------------------------------------------------------------- <br>// General routines <br>void INTFUNC AdjustMenus(void); <br>int  INTFUNC DoDialog(HWND, int, DLGPROC); <br>void INTFUNC DoMessage(HWND, UINT); <br>void INTFUNC GetCurrentValue(LPSTR, LPCOL, LPCHILD); <br>BOOL INTFUNC IsUpdateable(SDWORD); <br>void INTFUNC MakeTable(void); <br>BOOL INTFUNC ODBCError(HWND, SWORD, SQLHANDLE, SQLRETURN); <br>BOOL INTFUNC SetCurrentValue(LPSTR, LPCOL, LPCHILD); <br>SQLRETURN INTFUNC PrepareStmt(LPCHILD lpchild); <br>BOOL INTFUNC ProcessResults(LPCHILD lpchild); <br> <br>// Window/Dialog procedures <br>BOOL CALLBACK InitControlCallback( HWND , LPARAM); <br> <br>INLINE  BOOL    SetOrGetCheck( HWND,  int   , BOOL); <br>INLINE  VOID    SetOrGetEditArray( HWND, UCHAR FAR *, int); <br> <br>VOID    INTFUNC  InitializeDialogControls( HWND hDlg, LPCHILD   lpChild); <br>VOID    INTFUNC  ControlValue ( LPCHILD, HWND, HWND , int   , int ); <br>BOOL    INTFUNC  InitializeListBox( HWND, int, const DIALOG_PAIR FAR * , int, int); <br>BOOL    INTFUNC  SetHiddenFields( HWND  hDlg, int       iAct); <br>BOOL    INTFUNC  AlignToControl( HWND   hWnd, HWND  hDlg, int       iCtlId); <br>BOOL    CALLBACK OptionsDlgProc(HWND hdlg,UINT msg,WPARAM wparam,LPARAM lparam); <br>VOID    INTFUNC  ClassOnCommand(HWND hWnd, int iId, HWND hWndCtl, UINT uNotify); <br>BOOL    CALLBACK ChildOptDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam); <br>BOOL    CALLBACK AboutDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK AbsDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK DataDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK FindDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK MakeTableDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK OptDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK RelDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK StmtDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK TableDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK UpdateDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK SQLTablesDlgProc(HWND,UINT,WPARAM,LPARAM); <br> <br>LRESULT CALLBACK ChildProc(HWND, UINT, WPARAM, LPARAM); <br>LRESULT CALLBACK FrameProc(HWND, UINT, WPARAM, LPARAM); <br> <br> <br>// Variables --------------------------------------------------------------- <br>GLOBAL  HWND        g_hwnd;                // Main window handle <br>GLOBAL  HWND        g_hwndClient;          // MDI client window handle <br>GLOBAL  HWND        g_hwndChildDialog;     // child dialog if active <br>GLOBAL  HINSTANCE   g_hinst;               // Instance handle <br>GLOBAL  HACCEL      g_haccel;              // Accelerators <br> <br>GLOBAL  HMENU       g_hmenuInit;           // Pre-connection menu <br>GLOBAL  HMENU       g_hmenuInitWindow;     //   Windows menu (for MDI) <br>GLOBAL  HMENU       g_hmenuFrame;          // Connection made menu <br>GLOBAL  HMENU       g_hmenuFrameWindow;    //   Windows menu (for MDI) <br>GLOBAL  HMENU       g_hmenuChild;          // Child window menu <br>GLOBAL  HMENU       g_hmenuChildWindow;    //   Windows menu (for MDI) <br> <br>GLOBAL  int         g_cxVScroll;           // Width  of vertical scroll bar <br>GLOBAL  int         g_cyHScroll;           // Height of horizontal scroll bar <br> <br>GLOBAL  int         g_cx;                  // Width  of a character <br>GLOBAL  int         g_cy;                  // Height of a character <br> <br>GLOBAL  int         g_cxRecord;            // Width of record count area <br>GLOBAL  int         g_cxRecnum;            // Width of record number <br> <br>GLOBAL  HFONT       g_hfontName;           // Column name font <br>GLOBAL  HFONT       g_hfontData;           // Data font <br> <br>GLOBAL  HBRUSH      g_hbrWin;              // Window background brush <br>GLOBAL  HBRUSH      g_hbrBtn;              // Button face brush <br>GLOBAL  HBRUSH      g_hbrScroll;           // Scroll bar brush <br> <br>GLOBAL  SQLHENV     g_henv;                // ODBC environment handle <br>GLOBAL  SQLHDBC     g_hdbc;                // ODBC connection handle <br> <br>GLOBAL  SWORD       g_cbName;              // Maximum column name width <br>GLOBAL  char        g_szQuoteChar[2];      // Identifier quote char <br>GLOBAL  BOOL        g_fConnected;          // Connected flag <br>GLOBAL  BOOL        g_fAsyncSupported;     // Driver supports async flag <br>GLOBAL  char        g_szDSN[SQL_MAX_DSN_LENGTH+1];  // Data source name <br>GLOBAL  int         g_cChild;              // Number of child windows <br>GLOBAL  int         g_cCursor;             // Current cursor number <br> <br>GLOBAL  char        g_szTable[cbSTRLEN];   // Make table name <br>GLOBAL  SDWORD      g_mrows;               // Make table row count <br> <br>GLOBAL  char        g_szTITLE[cbSTRLEN];   // App title <br>GLOBAL  char        g_szNoRow[cbSTRLEN];   // No row string <br>GLOBAL  char        g_szRowError[cbSTRLEN];// No row string <br>GLOBAL  char        g_szNull[cbSTRLEN];    // Null column string <br>GLOBAL  char        g_szRowDeleted[cbSTRLEN]; // Row deleted string <br>GLOBAL  char        g_szUnknown[cbSTRLEN]; // Unknown string <br> <br> <br> <br>// Constants --------------------------------------------------------------- <br>#define WMU_INIT            (WM_USER+1) <br>#define WMU_DROPTABLE       (WM_USER+2) <br>#define WMU_INSERTREC       (WM_USER+4) <br>#define WMU_CLEANUP         (WM_USER+5) <br>#define WMU_CANCEL          (WM_USER+6) <br>#define WMU_NEWOPTION       (WM_USER+7)         // new options child menu <br>#define WMU_SETSUBTEXT      (WM_USER+8)         // set subtext (options group) <br> <br>#define ACT_INIT            1                   // initialize control <br>#define ACT_TRIGGER         2                   // control has been set <br> <br>#endif // __CURSORS_H </code></pre>
<p>&nbsp;</p></body>
</HTML>
