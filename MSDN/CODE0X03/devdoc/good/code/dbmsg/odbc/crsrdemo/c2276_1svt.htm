<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2279"></a>DIALOGS.C</h2>
<pre><code>/*-------------------------------------------------------------------------- <br>  Dialogs.c -- Cursors dialogs <br> <br>  Description: <br>      This sample is spread across four files, each named for the role <br>      the contained functions play.  Each file header contains a brief <br>      description of its purpose and the routines it contains. <br> <br>      DIALOGS.C contains those routines used to display and manage <br>      dialogs.  Those functions are: <br> <br>         AddEditControls - Dynamically create edit controls for UPDATE <br>                        dialog <br>         AddDlgProc      - Manage add row dialog <br>         CenterDialog    - Center a dialog over its parent window <br>         DoDialog        - Display a dialog <br>         MyCreateDialog - Create a modeless dialog <br>         GetEditControls - Retrieve values from dynamically created <br>                        edit controls <br>         IsMsgWaiting    - Check for waiting messages <br> <br>         AboutDlgProc    - Manage about box <br>         AbsDlgProc      - Manage absolute row number dialog <br>         DataDlgProc     - Manage large data display dialog <br>         FindDlgProc    - Manager dialog to get text string to find in result set <br>         RelDlgProc      - Manage relative row number dialog <br>         StmtDlgProc     - Manage SQL statement dialog <br>         UpdateDlgProc   - Manage update row dialog <br>         SqlTablesDlgProc- handle SQLTables-type request <br>         ClassOnCommand - handle a command message <br> <br> <br>  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>  intended for example purposes only. <br> <br>--------------------------------------------------------------------------*/ <br> <br>// Includes ---------------------------------------------------------------- <br>#include "headers.h" <br> <br>#include    "resource.h" <br>#include "crsrdemo.h" <br> <br> <br> <br>const char szCREATE[] = "CREATE TABLE %s (id int NOT NULL, name char(31) NOT NULL, C3 int)"; <br>const char szDROP[]   = "DROP TABLE %s"; <br>const char szINSERT[] = "INSERT INTO %s VALUES (?, '-FakeTable-FakeTable-FakeTable-', NULL)"; <br> <br>const int   xFIRST = 10; <br>const int   cxSEP  = 6; <br>const int   cySEP  = 3; <br>const int   cxNAME = 35; <br>const int   cyNAME = 8; <br>const int   cxEDIT = 180; <br>const int   cyEDIT = 10; <br> <br>const DWORD dwDLGSTYLE    = DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU; <br>const DWORD dwSTATICSTYLE = WS_CHILD | WS_VISIBLE | SS_RIGHT; <br>const DWORD dwEDITSTYLE   = WS_BORDER | WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_AUTOHSCROLL | ES_LEFT; <br> <br>#define STMTError(x) ODBCError(SQL_NULL_HENV, SQL_NULL_HDBC, lpmtbl-&gt;hstmt, (x)) <br> <br>#define  USERDATA GWL_USERDATA <br> <br> <br>// Types ------------------------------------------------------------------- <br>typedef struct tagMTBL {                  // Make table structure <br>   SQLHSTMT hstmt;                        //   HSTMT in use <br>   SDWORD   i;                            //   Rows inserted <br>} MTBL, FAR *LPMTBL; <br> <br> <br>// Prototypes -------------------------------------------------------------- <br>void INTFUNC AddEditControls(HWND, LPCHILD); <br>void INTFUNC CenterDialog(HWND); <br>BOOL INTFUNC GetEditControls(HWND, LPCHILD); <br>BOOL INTFUNC IsMsgWaiting(HWND); <br>BOOL INTFUNC DlgProcFilter(HWND, UINT, WPARAM, LPARAM); <br> <br> <br>/* AddEditControls --------------------------------------------------------- <br>   Description: Add one edit control for each updateable bound column to <br>                the dialog box <br>                --------------------------------------------------------------------------*/ <br>void INTFUNC AddEditControls(HWND hDlg, LPCHILD lpChild) <br>{ <br>#define DLGX(x)   (((x) * LOWORD(dwBaseUnits)) / 4) <br>#define DLGY(y)   (((y) * HIWORD(dwBaseUnits)) / 8) <br> <br>   HWND  hWnd; <br>   HFONT hfont; <br>   RECT  rc; <br>   LPCOL lpcol; <br>   char  sz[cbMAXSQL]; <br>   char  szFmt[cbSTRLEN]; <br>   DWORD dwBaseUnits; <br>   UINT  idName, idEdit; <br>   int      xName, yName; <br>   int      cxName, cyName; <br>   int      xEdit, yEdit; <br>   int      cxEdit, cyEdit; <br>   int      i; <br>   HDC   hdc; <br>   SIZE  size; <br> <br>   // Determine basic characteristics and start position in dialog <br>   hfont = (HFONT)SendDlgItemMessage(hDlg, IDC_STATIC1, <br>                                     WM_GETFONT, 0, 0L); <br> <br>   dwBaseUnits = GetDialogBaseUnits(); <br> <br>   cxName = DLGX(cxNAME); <br>   cyName = DLGY(cyNAME); <br>   cxEdit = DLGX(cxEDIT); <br>   cyEdit = DLGY(cyEDIT); <br> <br>   LoadString(g_hinst, IDS_COLNAME, szFmt, sizeof(szFmt)); <br> <br>   // Calculate the size of the largest name label <br> <br>   hdc = GetDC(NULL); <br> <br>   if( hdc ) { <br>      for( i = 0, lpcol = lpChild-&gt;lpcol; i &lt; lpChild-&gt;ccol; i++, lpcol++ ) <br>         if( IsUpdateable(lpcol-&gt;fSqlType) ) { <br>            wsprintf(sz, szFmt, lpcol-&gt;szName); <br>            GetTextExtentPoint(hdc, sz, lstrlen(sz), &amp;size); <br>            if( size.cx &gt; cxName ) <br>               cxName = size.cx; <br>         } <br>      ReleaseDC(NULL, hdc); <br>   } <br> <br>   GetWindowRect(GetDlgItem(hDlg, IDOK), &amp;rc); <br> <br>   xName = DLGX(xFIRST); <br>   yName = (4 * DLGY(cySEP)) + (DLGY(cySEP) / 2) + (2 * (rc.bottom - rc.top)); <br> <br>   xEdit = xName + cxName + DLGX(cxSEP); <br> <br>   idName = stc1; <br>   idEdit = edt1; <br> <br>   // For each bound, updateable column, create and add an edit control <br>   for (i=0, lpcol=lpChild-&gt;lpcol; i &lt; lpChild-&gt;ccol; i++, lpcol++) { <br>      if (IsUpdateable(lpcol-&gt;fSqlType)) { <br> <br>         // Create control label <br>         wsprintf(sz, szFmt, lpcol-&gt;szName); <br> <br>         hWnd = CreateWindow(szSTATICCLASS, sz, dwSTATICSTYLE, <br>                             xName, yName, cxName, cyName, hDlg, <br>                             (HMENU)idName, g_hinst, NULL); <br> <br>         FORWARD_WM_SETFONT(hWnd, hfont, 0, SendMessage); <br> <br>         // Create (and intialize) edit control <br>         yEdit = yName - ((cyEDIT - cyNAME) / 2); <br> <br>         GetCurrentValue(sz, lpcol, lpChild); <br> <br>         hWnd = CreateWindow(szEDITCLASS, sz, dwEDITSTYLE, <br>                             xEdit, yEdit, cxEdit, cyEdit, hDlg, <br>                             (HMENU)idEdit, g_hinst, NULL); <br> <br>         FORWARD_WM_SETFONT(hWnd, hfont, 0, SendMessage); <br> <br>         // Limit number of characters user can type to column display size <br>         Edit_LimitText(hWnd, lpcol-&gt;cbc-1); <br> <br>         yName += cyEdit + DLGY(cySEP); <br> <br>         idName++; <br>         idEdit++; <br>      } <br>   } <br> <br>   // Grow dialog so that all controls are visible <br>   GetClientRect(hDlg, &amp;rc); <br> <br>   rc.top    = 0; <br>   rc.bottom = yName + DLGY(cySEP); <br> <br>   rc.left   = 0; <br>   rc.right  = (2 * DLGX(xFIRST)) + DLGX(cxNAME) + DLGX(cxEDIT) + DLGX(cxSEP); <br> <br>   AdjustWindowRect(&amp;rc, dwDLGSTYLE, FALSE); <br>   MoveWindow(hDlg, 0, 0, rc.right - rc.left, rc.bottom - rc.top, TRUE); <br> <br>   // Place OK and Cancel buttons appropriately <br>   GetClientRect(hDlg, &amp;rc); <br>   {  RECT  rcButton; <br>      int      x, y; <br> <br>      GetWindowRect(GetDlgItem(hDlg, IDOK), &amp;rcButton); <br> <br>      x = rc.right - DLGX(cxSEP) - (rcButton.right - rcButton.left); <br>      y = DLGY(cySEP); <br> <br>      MoveWindow(GetDlgItem(hDlg, IDOK), <br>                 x, y, <br>                 rcButton.right - rcButton.left, <br>                 rcButton.bottom - rcButton.top, <br>                 TRUE); <br> <br>      y += rcButton.bottom - rcButton.top + (DLGY(cySEP) / 2); <br> <br>      GetWindowRect(GetDlgItem(hDlg, IDCANCEL), &amp;rcButton); <br>      MoveWindow(GetDlgItem(hDlg, IDCANCEL), <br>                 x, y, <br>                 rcButton.right - rcButton.left, <br>                 rcButton.bottom - rcButton.top, <br>                 TRUE); <br>   } <br> <br>   return; <br>} <br> <br> <br>/* CenterDialog ------------------------------------------------------------ <br>   Description: Center dialog over its owning parent window <br>                If the entire dialog does not fit on the desktop, <br>                ensure upper left corner is always visible <br>                --------------------------------------------------------------------------*/ <br>void INTFUNC CenterDialog(HWND hDlg) <br>{ <br>   RECT  rcDlg, rcScr, rcParent; <br>   int      cx, cy; <br> <br>   GetWindowRect(hDlg, &amp;rcDlg); <br>   cx = rcDlg.right  - rcDlg.left; <br>   cy = rcDlg.bottom - rcDlg.top; <br> <br>   GetWindowRect(GetParent(hDlg), &amp;rcParent); <br>   rcDlg.top    = rcParent.top + <br>      (((rcParent.bottom - rcParent.top) - cy) &gt;&gt; 1); <br>   rcDlg.left   = rcParent.left + <br>      (((rcParent.right - rcParent.left) - cx) &gt;&gt; 1); <br>   rcDlg.bottom = rcDlg.top  + cy; <br>   rcDlg.right  = rcDlg.left + cx; <br> <br>   GetWindowRect(GetDesktopWindow(), &amp;rcScr); <br>   if (rcDlg.bottom &gt; rcScr.bottom) { <br>      rcDlg.bottom = rcScr.bottom; <br>      rcDlg.top    = rcDlg.bottom - cy; <br>   } <br>   if (rcDlg.right  &gt; rcScr.right) { <br>      rcDlg.right = rcScr.right; <br>      rcDlg.left  = rcDlg.right - cx; <br>   } <br> <br>   if (rcDlg.left &lt; 0) rcDlg.left = 0; <br>   if (rcDlg.top  &lt; 0) rcDlg.top  = 0; <br> <br>   MoveWindow(hDlg, rcDlg.left, rcDlg.top, cx, cy, FALSE); <br>   return; <br>} <br> <br> <br>/* DoDialog ---------------------------------------------------------------- <br>   Description: Launch a dialog passing child window variables <br>   --------------------------------------------------------------------------*/ <br>int INTFUNC DoDialog(HWND    hWndParent, <br>                     int     nDlgResNum, <br>                     DLGPROC lpDlgProc) <br>{ <br>   HWND  hWnd; <br>   LPCHILD  lpChild; <br>   int      nRC; <br> <br>   hWnd    = FORWARD_WM_MDIGETACTIVE(g_hwndClient, SendMessage); <br>   lpChild = (hWnd <br>              ? (LPCHILD)GetWindowLong(hWnd, 0) <br>              : NULL); <br> <br>   nRC = DialogBoxParam(g_hinst, <br>                        MAKEINTRESOURCE(nDlgResNum), <br>                        hWndParent, <br>                        lpDlgProc, <br>                        (LONG)lpChild); <br>   return nRC; <br>} <br> <br>/* MyCreateDialog ------------------------------------------------------------ <br>   Description: Launch a  modeless dialog passing child window variables <br>--------------------------------------------------------------------------*/ <br> <br>HWND INTFUNC MyCreateDialog(HWND    hWndParent, <br>                            int     nDlgResNum, <br>                            DLGPROC lpDlgProc) <br>{ <br>   HWND  hWnd, hWndRet; <br>   LPCHILD  lpChild; <br> <br>   hWnd    = FORWARD_WM_MDIGETACTIVE(g_hwndClient, SendMessage); <br>   lpChild = (hWnd <br>              ? (LPCHILD)GetWindowLong(hWnd, 0) <br>              : NULL); <br> <br>   hWndRet = CreateDialogParam(g_hinst, <br>                               MAKEINTRESOURCE(nDlgResNum), <br>                               hWndParent, <br>                               lpDlgProc, <br>                               (LPARAM)lpChild); <br>   return hWndRet; <br>} <br> <br>/* GetEditControls --------------------------------------------------------- <br>   Description: Get values from edit controls and move to row-set buffers <br>   --------------------------------------------------------------------------*/ <br>BOOL INTFUNC GetEditControls(HWND hDlg, LPCHILD lpChild) <br>{ <br>   LPCOL lpcol; <br>   char  sz[cbMAXSQL]; <br>   UINT  idEdit; <br>   BOOL  fChangeMade; <br>   int      i; <br> <br>   fChangeMade = FALSE; <br>   idEdit      = edt1; <br> <br>   // For each bound, updateable column, retrieve the value <br>   for (i=0, lpcol=lpChild-&gt;lpcol; i &lt; lpChild-&gt;ccol; i++, lpcol++) { <br>      if (IsUpdateable(lpcol-&gt;fSqlType)) { <br> <br>         // Get the control value <br>         SendDlgItemMessage(hDlg, idEdit, WM_GETTEXT, <br>                            (WPARAM)sizeof(sz), (LPARAM)((LPSTR)sz)); <br> <br>         // Move into row-set buffer <br>         if (SetCurrentValue(sz, lpcol, lpChild) &amp;&amp; !fChangeMade) <br>            fChangeMade = TRUE; <br> <br>         idEdit++; <br>      } <br>   } <br> <br>   return fChangeMade; <br>} <br> <br> <br>/* IsMsgWaiting ------------------------------------------------------------ <br>   Description: Return TRUE if the Cancel button has been pressed <br>   --------------------------------------------------------------------------*/ <br>BOOL INTFUNC IsMsgWaiting(HWND hWnd) <br>{ <br>   MSG   msg; <br> <br>   UNREF_PARAM (hWnd); <br> <br>   // Check all waiting messages <br>   while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br> <br>      // Process message <br>      TranslateMessage(&amp;msg); <br>      DispatchMessage(&amp;msg); <br> <br>      // Return TRUE if the Cancel button was pressed <br>      if ((msg.message == WM_COMMAND <br>           &amp;&amp; GET_WM_COMMAND_ID(msg.wParam, msg.lParam) == IDCANCEL) <br>          || msg.message == WMU_CANCEL) <br>         return TRUE; <br>   } <br>   return FALSE; <br>} <br> <br>/* OptionsDlgProc ---------------------------------------------------------- <br>   Description: handle options dialog <br>----------------------------------------------------------------------------*/ <br> <br>BOOL EXPFUNC OptionsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br> <br>   switch (msg) { <br> <br>     case WM_INITDIALOG: <br>      CenterDialog(hDlg); <br> <br>      SetWindowLong(hDlg, USERDATA, (LONG)lParam); <br>      InitializeDialogControls(hDlg, (LPCHILD) lParam); <br> <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      (void) HANDLE_WM_COMMAND(hDlg,wParam,lParam,ClassOnCommand); <br>      break; <br> <br>      // New option dialog selected <br> <br>     case WMU_NEWOPTION: <br>      { <br>         LPCHILD  lpChild = (LPCHILD) GetWindowLong(hDlg, USERDATA); <br> <br>         if (g_hwndChildDialog) <br>            DestroyWindow(g_hwndChildDialog); <br> <br>         g_hwndChildDialog = MyCreateDialog(hDlg, <br>                                            (int) lParam, <br>                                            ChildOptDlgProc); <br> <br>         SetFocus(GetDlgItem(hDlg, IDC_OPTIONLIST)); <br> <br>         break; <br>      } <br> <br> <br>      // Set title of option area <br> <br> <br>     case WMU_SETSUBTEXT: <br>      { <br>         char  szBuffer[1000]; <br> <br>         ListBox_GetText(GetDlgItem(hDlg, wParam), <br>                         ListBox_GetCurSel(GetDlgItem(hDlg,wParam)), <br>                         szBuffer); <br> <br>         Static_SetText( GetDlgItem(hDlg, IDC_OPTIONAREA_TITLE), <br>                        szBuffer); <br>         break; <br> <br>      } <br> <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br>/* ChildOptDlgProc -------------------------------------------------------- <br>   Description: handle generic dialog <br>----------------------------------------------------------------------------*/ <br> <br>BOOL EXPFUNC ChildOptDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>   switch (msg) { <br> <br> <br>     case WM_INITDIALOG: <br>      SetWindowLong(hDlg, USERDATA, (LONG)lParam); <br>      InitializeDialogControls(hDlg, (LPCHILD) lParam); <br> <br>      // Align the window to a hidden static in the parent <br> <br>      (void) AlignToControl(hDlg, GetParent(hDlg), IDC_OPTION_WINPOS); <br> <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      return (BOOL)HANDLE_WM_COMMAND(hDlg,wParam,lParam,ClassOnCommand); <br> <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br> <br>/* AboutDlgProc ------------------------------------------------------------ <br>   Description: Display about box <br>   --------------------------------------------------------------------------*/ <br>BOOL EXPFUNC AboutDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   UNREF_PARAM (lParam); <br> <br>   switch (msg) { <br>     case WM_INITDIALOG: <br>      CenterDialog(hDlg); <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      if (GET_WM_COMMAND_ID(wParam, lParam) == IDOK <br>          || GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL) { <br>         EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam)); <br>         return TRUE; <br>      } <br>      break; <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br> <br>/* AbsDlgProc -------------------------------------------------------------- <br>   Description: Get absolute row number to fetch <br>   --------------------------------------------------------------------------*/ <br>BOOL EXPFUNC AbsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   LPCHILD  lpChild; <br>   char  sz[11]; <br>   char  *EndPtr; <br>   SDWORD   arow; <br> <br>   lpChild = (LPCHILD)GetWindowLong(hDlg, USERDATA); <br> <br>   switch (msg) { <br>     case WM_INITDIALOG: <br>      CenterDialog(hDlg); <br> <br>      lpChild = (LPCHILD)lParam; <br> <br>      SetWindowLong(hDlg, USERDATA, (LONG)lpChild); <br>      wsprintf(sz, "%ld", lpChild-&gt;arow); <br>      SetWindowText(GetDlgItem(hDlg, IDC_EDIT1), sz); <br>      SendDlgItemMessage(hDlg, IDC_EDIT1, <br>                         EM_LIMITTEXT, sizeof(sz)-1, 0L); <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>         GetWindowText(GetDlgItem(hDlg, IDC_EDIT1), sz, sizeof(sz)); <br>         arow = strtol((char*) sz, &amp;EndPtr, 10); <br>         for (; *EndPtr &amp;&amp; <br>              ISWHITE(*EndPtr); EndPtr = AnsiNext(EndPtr)); <br>         // the number inputed is within '0' to '9' or + or - <br>         if (*EndPtr != '\0') { <br>            MessageBox(hDlg, <br>                       "Invalid absolute row number", <br>                       NULL, <br>                       MB_ICONSTOP); <br>            return TRUE; <br>         } <br>         lpChild-&gt;arow = arow; <br> <br>        case IDCANCEL: <br>         EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam)); <br>         return TRUE; <br>      } <br>      break; <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br> <br>/* DataDlgProc ------------------------------------------------------------- <br>   Description: Display large data value (retrieved via SQLGetData) <br>   --------------------------------------------------------------------------*/ <br>BOOL EXPFUNC DataDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch (msg) { <br>     case WM_INITDIALOG: { <br>        LPBIGCOL  lpbc; <br>        char      sz[cbSTRLEN]; <br>        char      szNum[cbSTRLEN]; <br>        char      szFmt[cbSTRLEN]; <br> <br>        CenterDialog(hDlg); <br> <br>        lpbc = (LPBIGCOL)lParam; <br> <br>        if (lpbc-&gt;cb == SQL_NULL_DATA) { <br>           lstrcpy(lpbc-&gt;lpsz, g_szNull); <br>           lpbc-&gt;cb = 0; <br>           _ltoa(0, szNum, 10); <br>        } <br>        else if (lpbc-&gt;cb == SQL_NO_TOTAL) <br>           lstrcpy(szNum, g_szUnknown); <br>        else <br>           _ltoa(lpbc-&gt;cb, szNum, 10); <br> <br>        LoadString(g_hinst, IDS_DATADLG, szFmt, sizeof(szFmt)); <br>        wsprintf(sz, szFmt, lpbc-&gt;szName, szNum); <br>        SetWindowText(GetDlgItem(hDlg, IDC_TEXT1), sz); <br> <br>        SetWindowText(GetDlgItem(hDlg, IDC_EDIT1), lpbc-&gt;lpsz); <br>        return TRUE; <br>     } <br> <br>     case WM_COMMAND: <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>        case IDCANCEL: <br>         EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam)); <br>         return TRUE; <br>      } <br>      break; <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br> <br>/* RelDlgProc -------------------------------------------------------------- <br>   Description: Get relative row offset to fetch <br>   --------------------------------------------------------------------------*/ <br>BOOL EXPFUNC RelDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   LPCHILD  lpChild; <br>   char  sz[7]; <br> <br>   lpChild = (LPCHILD)GetWindowLong(hDlg, USERDATA); <br> <br>   switch (msg) { <br>     case WM_INITDIALOG: <br>      CenterDialog(hDlg); <br> <br>      lpChild = (LPCHILD)lParam; <br>      SetWindowLong(hDlg, USERDATA, (LONG)lpChild); <br> <br>      wsprintf(sz, "%ld", lpChild-&gt;rrow); <br>      SetWindowText(GetDlgItem(hDlg, IDC_EDIT1), sz); <br>      SendDlgItemMessage(hDlg, IDC_EDIT1, <br>                         EM_LIMITTEXT, sizeof(sz)-1, 0L); <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: { <br>           SDWORD rrow; <br>           char   *EndPtr; <br> <br>           GetWindowText(GetDlgItem(hDlg, IDC_EDIT1), sz, sizeof(sz)); <br>           rrow = strtol((char*) sz, &amp;EndPtr, 10); <br>           for (; *EndPtr &amp;&amp; <br>                ISWHITE(*EndPtr); EndPtr = AnsiNext(EndPtr)); <br>           // the number inputed is within '0' to '9' or + or - <br>           if (*EndPtr != '\0' || rrow &lt; -100000 || rrow &gt; 100000) { <br>              MessageBox(hDlg, <br>                         "Step amount must be between -100,000 and 100,000", <br>                         NULL, <br>                         MB_ICONSTOP); <br>              return TRUE; <br>           } <br>           lpChild-&gt;rrow = rrow; <br>        } <br> <br>        case IDCANCEL: <br>         EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam)); <br>         return TRUE; <br>      } <br>      break; <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br> <br>/* StmtDlgProc ------------------------------------------------------------- <br>   Description: Get SQL statement to execute <br>   --------------------------------------------------------------------------*/ <br>BOOL EXPFUNC StmtDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   LPCHILD  lpChild; <br> <br>   lpChild = (LPCHILD)GetWindowLong(hDlg, USERDATA); <br> <br>   switch (msg) { <br>     case WM_INITDIALOG: <br>      CenterDialog(hDlg); <br> <br>      lpChild = (LPCHILD)lParam; <br>      SetWindowLong(hDlg, USERDATA, (LONG)lpChild); <br> <br>      SetWindowText(GetDlgItem(hDlg, IDC_EDIT1), lpChild-&gt;sql); <br>      SendDlgItemMessage(hDlg, IDC_EDIT1, EM_LIMITTEXT, cbMAXSQL-1, 0L); <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>         GetWindowText(GetDlgItem(hDlg, IDC_EDIT1), <br>                       lpChild-&gt;sql, cbMAXSQL); <br> <br>         lpChild-&gt;dwOperation = OPER_SELECT; <br> <br> <br>        case IDCANCEL: <br>         EndDialog(hDlg, wParam); <br>         return TRUE; <br>      } <br>      break; <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br> <br>/* UpdateDlgProc ----------------------------------------------------------- <br>   Description: Get new values with which to update the current row <br>   --------------------------------------------------------------------------*/ <br>BOOL EXPFUNC UpdateDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   LPCHILD  lpChild; <br> <br>   lpChild = (LPCHILD)GetWindowLong(hDlg, USERDATA); <br> <br>   switch (msg) { <br> <br>      // Build dialog dynamically, adding appropriate edit controls <br>     case WM_INITDIALOG: <br>      lpChild = (LPCHILD)lParam; <br> <br>      SetWindowLong(hDlg, USERDATA, (LONG)lpChild); <br>      AddEditControls(hDlg, lpChild); <br>      SendDlgItemMessage(hDlg,edt1,EM_SETSEL,GET_EM_SETSEL_MPS(0, -1)); <br> <br>      CenterDialog(hDlg); <br>      SetFocus(GetDlgItem(hDlg, edt1)); <br>      return FALSE; <br> <br>      // Close dialog updating row-set buffer (if OK) with new values <br>     case WM_COMMAND: <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>         if (!GetEditControls(hDlg, lpChild)) <br>            GET_WM_COMMAND_ID(wParam, lParam) = IDCANCEL; <br> <br>        case IDCANCEL: <br>         EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam)); <br>         return TRUE; <br>      } <br>      break; <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br> <br>/* FindDlgProc ------------------------------------------------------------- <br>   Description: Get text string to find in result set <br>   --------------------------------------------------------------------------*/ <br>BOOL EXPFUNC FindDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   LPCHILD  lpChild; <br> <br>   lpChild = (LPCHILD)GetWindowLong(hDlg, USERDATA); <br> <br>   switch (msg) { <br>     case WM_INITDIALOG: <br>      CenterDialog(hDlg); <br> <br>      lpChild = (LPCHILD)lParam; <br>      SetWindowLong(hDlg, USERDATA, (LONG)lpChild); <br> <br>      SetWindowText(GetDlgItem(hDlg, IDC_EDIT1), lpChild-&gt;sql); <br>      SendDlgItemMessage(hDlg, IDC_EDIT1, EM_LIMITTEXT, cbMAXSQL-1, 0L); <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>         GetWindowText(GetDlgItem(hDlg, IDC_EDIT1), <br>                       lpChild-&gt;sql, cbMAXSQL); <br> <br>        case IDCANCEL: <br>         EndDialog(hDlg, wParam); <br>         return TRUE; <br>      } <br>      break; <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br>} <br> <br>/*--------------------------------------------------------------------------- <br>** SQLTablesDlgProc -- get information for SQLTables and similar functions <br>----------------------------------------------------------------------------*/ <br>BOOL EXPFUNC SQLTablesDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   LPCHILD  lpChild; <br> <br>   lpChild = (LPCHILD)GetWindowLong(hDlg, USERDATA); <br> <br>   switch (msg) { <br>     case WM_INITDIALOG: <br>      CenterDialog(hDlg); <br> <br>      lpChild = (LPCHILD)lParam; <br>      SetWindowLong(hDlg, USERDATA, (LONG)lpChild); <br> <br>      // Set the default button <br>      if (!(lpChild-&gt;dwGuiFlags &amp; GUIF_TABLES_RADIO)) { <br>         lpChild-&gt;dwOperation = IDC_TABLE_RAD_TABLE; <br>         lpChild-&gt;dwRadioButton = IDC_TABLE_RAD_TABLE; <br>      } <br> <br>      // Set the dialog up <br> <br>      ControlValue(  lpChild, <br>                   hDlg, <br>                   GetDlgItem(hDlg,lpChild-&gt;dwRadioButton), <br>                   lpChild-&gt;dwRadioButton, <br>                   ACT_INIT); <br> <br>      ControlValue(  lpChild, <br>                   hDlg, <br>                   GetDlgItem(hDlg,lpChild-&gt;dwRadioButton), <br>                   lpChild-&gt;dwRadioButton, <br>                   ACT_TRIGGER); <br> <br>      ControlValue(  lpChild, <br>                   hDlg, <br>                   GetDlgItem(hDlg,IDC_TABLEINFO_QUALIFIER), <br>                   IDC_TABLEINFO_QUALIFIER, <br>                   ACT_INIT); <br> <br>      ControlValue(  lpChild, <br>                   hDlg, <br>                   GetDlgItem(hDlg,IDC_TABLEINFO_NAME), <br>                   IDC_TABLEINFO_NAME, <br>                   ACT_INIT); <br> <br>      ControlValue(  lpChild, <br>                   hDlg, <br>                   GetDlgItem(hDlg,IDC_TABLEINFO_OWNER), <br>                   IDC_TABLEINFO_OWNER, <br>                   ACT_INIT); <br> <br>      ControlValue(  lpChild, <br>                   hDlg, <br>                   GetDlgItem(hDlg,IDC_TABLEINFO_TYPE), <br>                   IDC_TABLEINFO_TYPE, <br>                   ACT_INIT); <br> <br>      ControlValue(  lpChild, <br>                   hDlg, <br>                   GetDlgItem(hDlg,IDC_TABLEINFO_COLNAME), <br>                   IDC_TABLEINFO_COLNAME, <br>                   ACT_INIT); <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      return (BOOL)HANDLE_WM_COMMAND(hDlg, wParam, lParam, ClassOnCommand); <br>      break; <br> <br>   } <br> <br>   return DlgProcFilter(hDlg, msg, wParam, lParam); <br> <br>} <br> <br>/*---ClassCommand--------------------------------------------------------- <br>   Filters commands for dialogs.   Forwards those messages that we think <br>   are interesting to a handler that processes the events. <br>---------------------------------------------------------------------------*/ <br> <br>VOID INTFUNC ClassOnCommand(HWND hWnd, int iId, HWND hWndCtl, UINT uNotify) <br>{ <br>   LPCHILD  lpChild; <br> <br>   lpChild = (LPCHILD)GetWindowLong(hWnd,USERDATA); <br> <br>   if (!(lpChild)) <br>      return; <br> <br>   switch (uNotify) { <br> <br>     case   BN_CLICKED:       // button control selected <br>     case   EN_UPDATE:        // edit box has been updated <br>     case   LBN_SELCHANGE:       // listbox has gotten a message <br>      ControlValue(lpChild, hWnd, hWndCtl, iId, ACT_TRIGGER); <br>      break; <br> <br>   } <br>} <br> <br> <br>/* <br> ** ControlValue -- Initialize a control's value from the child's state, or <br> **               set the child's state from the control.   All control- <br> **               specific logic should go here. <br> ** <br> ** Parameters: <br> **      lpChild  -- child state <br> **      hDlg  --  id of the active dialog <br> **      hCtl  --  control's window <br> **      iId      --  control's id <br> **      iAction  -- Action to take -- ACT_INIT or ACT_TRIGGER <br> ** <br> ** No return value <br> */ <br> <br>VOID INTFUNC ControlValue (LPCHILD     lpChild, <br>                           HWND     hDlg, <br>                           HWND     hCtl, <br>                           int         iId, <br>                           int         iAction) <br>{ <br>   int      iLbSelection; <br>   DWORD dwListData; <br>   BOOL  fTemp; <br>   UCHAR szBuffer[MAXNAME]; <br> <br>   const DIALOG_PAIR dpOptList[] = { <br>      {"Binding",          IDD_BIND_OPTIONS}, <br>      {"General options",     IDD_GENERAL_OPTIONS}, <br>      {"Scrolling Options",   IDD_SCROLLING_OPTIONS}, <br>      {"Concurrency Options", IDD_CONCURRENCY_OPTIONS}}; <br> <br>   switch (iId) { <br> <br>     case   IDOK:                   // generic OK <br>     case   IDCANCEL:                  // generic CANCEL <br>      if (iAction == ACT_TRIGGER) { <br>         if (g_hwndChildDialog) { <br>            g_hwndChildDialog = NULL; <br>         } <br>         EndDialog(hDlg, iId); <br>      } <br>      break; <br> <br>     case IDC_RADIO_BINDROW: <br>     case IDC_RADIO_BINDCOL: <br>      if (SetOrGetCheck(hCtl, iAction, (iId == lpChild-&gt;fBindByRow))) { <br>         lpChild-&gt;fBindByRow = iId; <br>      } <br>      break; <br> <br>     case IDC_RADIO_READONLY: <br>      if (SetOrGetCheck(hCtl, iAction, <br>                        (lpChild-&gt;fConcurrency == SQL_CONCUR_READ_ONLY))) { <br>         lpChild-&gt;fConcurrency = SQL_CONCUR_READ_ONLY; <br>      } <br>      break; <br>     case IDC_RADIO_LOCKING: <br>      if (SetOrGetCheck(hCtl, iAction, <br>                        (lpChild-&gt;fConcurrency == SQL_CONCUR_LOCK))) { <br>         lpChild-&gt;fConcurrency = SQL_CONCUR_LOCK; <br>      } <br>      break; <br>     case IDC_RADIO_OPTIMISTIC: <br>      if (SetOrGetCheck(hCtl, iAction, <br>                        (lpChild-&gt;fConcurrency == SQL_CONCUR_ROWVER))) { <br>         lpChild-&gt;fConcurrency = SQL_CONCUR_ROWVER; <br>      } <br>      break; <br>     case IDC_RADIO_OPTIMVALUE: <br>      if (SetOrGetCheck(hCtl, iAction, <br>                        (lpChild-&gt;fConcurrency == SQL_CONCUR_VALUES))) { <br>         lpChild-&gt;fConcurrency = SQL_CONCUR_VALUES; <br>      } <br>      break; <br> <br>     case IDC_RADIO_FORWARD: <br>      if (SetOrGetCheck(hCtl, iAction, </code></pre>
<p>
</p>
<pre><code>(lpChild-&gt;crowKeyset == SQL_CURSOR_FORWARD_ONLY))) { <br>         lpChild-&gt;crowKeyset = SQL_CURSOR_FORWARD_ONLY; <br>      } <br>      break; <br>     case IDC_RADIO_SNAPSHOT: <br>      if (SetOrGetCheck(hCtl, iAction, <br>                        (lpChild-&gt;crowKeyset == SQL_CURSOR_STATIC))) { <br>         lpChild-&gt;crowKeyset = SQL_CURSOR_STATIC; <br>      } <br>      break; <br>     case IDC_RADIO_KEYSET: <br>      if (SetOrGetCheck(hCtl, iAction, <br>                        (lpChild-&gt;crowKeyset == SQL_CURSOR_KEYSET_DRIVEN))) { <br>         lpChild-&gt;crowKeyset = SQL_CURSOR_KEYSET_DRIVEN; <br>      } <br>      break; <br>     case IDC_RADIO_DYNAMIC: <br>      if (SetOrGetCheck(hCtl, iAction, <br>                        (lpChild-&gt;crowKeyset == SQL_CURSOR_DYNAMIC))) { <br>         lpChild-&gt;crowKeyset = SQL_CURSOR_DYNAMIC; <br>      } <br>      break; <br> <br>     case IDC_CHECK_BINDALL: <br>      fTemp = SetOrGetCheck(hCtl,iAction, (lpChild-&gt;fBindAll)); <br>      lpChild-&gt;fBindAll = fTemp; <br>      Edit_Enable(GetDlgItem(hDlg,IDC_EDIT_BIND), !(fTemp)); <br>      Static_Enable(GetDlgItem(hDlg, IDC_STATIC_NBIND), !(fTemp)); <br>      break; <br> <br>     case IDC_EDIT_BIND: <br>      if (lpChild-&gt;fBind) <br>         wsprintf((LPSTR)szBuffer,"%s", lpChild-&gt;szBind); <br>      else  wsprintf((LPSTR)szBuffer,"%u", lpChild-&gt;cBind); <br>      SetOrGetEditArray(hCtl, szBuffer, iAction); <br>      if (iAction == ACT_TRIGGER) { <br>         lpChild-&gt;fBind = TRUE; <br>         strncpy(lpChild-&gt;szBind, szBuffer, cbINTLEN); <br>         lpChild-&gt;szBind[cbINTLEN-1] = '\0'; <br>      } <br>      break; <br> <br>     case IDC_EDIT_ROWSETSIZE: <br>      if (lpChild-&gt;fRowset) <br>         wsprintf((LPSTR)szBuffer,"%s", lpChild-&gt;szRowset); <br>      else wsprintf((LPSTR)szBuffer,"%u", lpChild-&gt;crowRowset); <br>      SetOrGetEditArray(hCtl, szBuffer, iAction); <br>      if (iAction == ACT_TRIGGER) { <br>         lpChild-&gt;fRowset = TRUE; <br>         strncpy(lpChild-&gt;szRowset, szBuffer, cbINTLEN); <br>         lpChild-&gt;szRowset[cbINTLEN-1] = '\0'; <br>      } <br>      break; <br> <br>     case IDC_MAXCOL: <br>      if (lpChild-&gt;fMaxBind) <br>         wsprintf((LPSTR)szBuffer, "%s", lpChild-&gt;szMaxBind); <br>      else wsprintf((LPSTR)szBuffer, "%ld", lpChild-&gt;crowMaxBind); <br>      SetOrGetEditArray(hCtl, szBuffer, iAction); <br>      if (iAction == ACT_TRIGGER) { <br>         lpChild-&gt;fMaxBind = TRUE; <br>         strncpy(lpChild-&gt;szMaxBind, szBuffer, cbINTLEN); <br>         lpChild-&gt;szMaxBind[cbINTLEN-1] = '\0'; <br>      } <br>      break; <br> <br>     case IDC_TABLE_RAD_STATISTICS:       // TABLEINFO-&gt;STATSTICS <br>     case IDC_TABLE_RAD_COLUMN:           // TABLEINFO-&gt;COLUMNS <br>     case IDC_TABLE_RAD_PRIV:          // TABLEINFO-&gt;PRIVILEGES <br>     case IDC_TABLE_RAD_PROC:          // TABLEINFO-&gt;PROCEDURES <br>     case IDC_TABLE_RAD_TABLE:            // TABLEINFO-&gt;TABLES <br> <br>      // Initialize the button, or set iAction to its value <br>      // Hide any fields not related to the button, show fields related <br> <br>      if( SetOrGetCheck(hCtl, iAction, <br>                        (iId == (int)lpChild-&gt;dwRadioButton)) ) <br>         lpChild-&gt;dwOperation = (UWORD) iId; <br> <br>      if (iAction == ACT_TRIGGER) { <br>         lpChild-&gt;dwGuiFlags |= GUIF_TABLES_RADIO; <br>         lpChild-&gt;dwRadioButton = iId; <br>         (void) SetHiddenFields(hDlg, iId); <br>      } <br>      break; <br> <br>     case IDC_CHECK_FETCH: <br>      if (SetOrGetCheck(hCtl, iAction, (int)IS_ALLWFETCH(lpChild))) <br>         lpChild-&gt;dwGuiFlags |= GUIF_ALWAYSFETCH; <br>      else <br>         lpChild-&gt;dwGuiFlags &amp;= ~GUIF_ALWAYSFETCH; <br> <br>      break; <br> <br>     case IDC_CHECK_ASYNC: <br>      lpChild-&gt;fAsync = SetOrGetCheck(hCtl,iAction,lpChild-&gt;fAsync); <br>      break; <br> <br>     case IDC_TABLEINFO_QUALIFIER:        // TABLEINFO-&gt;QUALIFIER <br>      SetOrGetEditArray(hCtl, lpChild-&gt;szQualifier, iAction); <br>      break; <br> <br>     case IDC_TABLEINFO_NAME:          // TABLEINFO-&gt;NAME <br>      SetOrGetEditArray(hCtl, lpChild-&gt;szTable, iAction); <br>      break; <br> <br>     case IDC_TABLEINFO_OWNER:            // TABLEINFO-&gt;OWNER <br>      SetOrGetEditArray(hCtl, lpChild-&gt;szUser, iAction); <br>      break; <br> <br>     case IDC_TABLEINFO_TYPE:          // TABLEINFO-&gt;TYPE <br>      SetOrGetEditArray(hCtl, lpChild-&gt;szType, iAction); <br>      break; <br> <br>     case IDC_TABLEINFO_COLNAME:          // TABLEINFO-&gt;COLUMN NAME <br>      SetOrGetEditArray(hCtl, lpChild-&gt;szColName, iAction); <br>      break; <br> <br>     case IDC_OPTIONLIST:              // OPTIONS-&gt;options <br>      { <br> <br>         if (iAction == ACT_INIT) { <br>            InitializeListBox(hDlg, <br>                              IDC_OPTIONLIST, <br>                              &amp;dpOptList[0], <br>                              sizeof(dpOptList) / sizeof(DIALOG_PAIR), <br>                              IDD_GENERAL_OPTIONS); <br>         } <br> <br>         // Get the title and data for the currently-selected list box <br> <br>         iLbSelection = ListBox_GetCurSel(hCtl); <br>         dwListData   = ListBox_GetItemData(hCtl, iLbSelection); <br> <br>         SendMessage(hDlg,WMU_NEWOPTION, iLbSelection,(LPARAM)dwListData); <br>         SendMessage(hDlg,WMU_SETSUBTEXT,iId, 0); <br> <br>         break; <br>      } <br> <br>   } <br>} <br> <br>/* <br>** SetOrGetCheck      -- set a value based upon a button action, or set a <br>**                 check button if the action is equal to a value <br>**                 Also used for radios <br>** <br>** Parameters: <br>**    hCtl     -- control handle <br>**    iAction     -- ACT_INIT or ACT_TRIGGER <br>**    bEqual      -- Initialization -- should value be set? <br>** <br>** Returns: <br>**    TRUE if checkbox is now set <br>*/ <br>INLINE BOOL SetOrGetCheck( <br>                          HWND   hCtl, <br>                          int    iAction, <br>                          BOOL   bEqual) <br>{ <br>   if (iAction == ACT_INIT) { <br>      Button_SetCheck(hCtl, bEqual); <br>      return bEqual; <br>   } <br> <br>   if (iAction == ACT_TRIGGER) { <br>      Button_SetCheck(hCtl, Button_GetCheck(hCtl)); <br>      return Button_GetCheck(hCtl); <br>   } <br> <br>   return FALSE; <br>} <br> <br> <br>/* <br>** SetOrGetEditArray -- set the value of an array from an edit control, or <br>**                set the edit control from the array  (inline) <br>** <br>** Parameters: <br>**    hCtl  -- control <br>**    lpStr -- string <br>**    iAction  -- ACT_INIT or ACT_TRIGGER <br>** <br>** Notes:   Assumes lpStr is MAXNAME bytes long <br>*/ <br>INLINE VOID SetOrGetEditArray( <br>                              HWND  hCtl, <br>                              UCHAR FAR *lpStr, <br>                              int      iAction) <br>{ <br>   if (iAction == ACT_INIT) <br>      Edit_SetText(hCtl, (LPSTR)lpStr); <br>   else <br>      if (iAction == ACT_TRIGGER) <br>         Edit_GetText(hCtl, (LPSTR)lpStr, MAXNAME - 1); <br>} <br> <br>/* <br>** SetHiddenFields -- show or hide hidden fields in a dialog box, depending <br>**               upon the action taken. <br>** <br>** Parameters: <br>**    hDlg  -- dialog we are dealing with <br>**    iAct  -- action <br>** <br>*/ <br>BOOL    INTFUNC SetHiddenFields( <br>                                HWND   hWnd, <br>                                int    iAct) <br>{ <br>   HWND  hTTag, hCol; <br>   HWND  hType, hCTag; <br> <br>   // Get handles for all of the windows we want to deal with <br> <br>   hTTag = GetDlgItem(hWnd, IDC_TYPETAG); <br>   hCol  = GetDlgItem(hWnd, IDC_COLTAG); <br> <br>   hType = GetDlgItem(hWnd, IDC_TABLEINFO_TYPE); <br>   hCTag = GetDlgItem(hWnd, IDC_TABLEINFO_COLNAME); <br> <br>   if (hType) { <br>      Edit_Enable(hType, (iAct == IDC_TABLE_RAD_TABLE)  ? 1 : 0); <br>      ShowWindow(hType,  (iAct == IDC_TABLE_RAD_TABLE)  ? SW_SHOW : SW_HIDE); <br>      ShowWindow(hTTag,  (iAct == IDC_TABLE_RAD_TABLE)  ? SW_SHOW : SW_HIDE); <br> <br>      Edit_Enable(hCTag, (iAct == IDC_TABLE_RAD_COLUMN) ? 1 : 0); <br>      ShowWindow(hCol,   (iAct == IDC_TABLE_RAD_COLUMN) ? SW_SHOW : SW_HIDE); <br>      ShowWindow(hCTag,  (iAct == IDC_TABLE_RAD_COLUMN) ? SW_SHOW : SW_HIDE); <br> <br>      return TRUE; <br>   } <br> <br>   return FALSE; <br>} <br> <br>/* <br> **   InitializeListBox -- initialize a listbox from a DIALOG_PAIR <br> **                     structure. <br> ** <br> **  Parameters: <br> **      hWnd     --  window the list box lives in <br> **      lbId     --  resource id of the list box <br> **      dpOptList   --  pointer to option list structure <br> **      iEntries --  number of entries in the list box <br> **      iDefId      --  default to select <br> ** <br> ** <br> **  Returns:  FALSE <br> ** <br> */ <br> <br>BOOL INTFUNC InitializeListBox( <br>   HWND                    hWnd, <br>   int                     lbId, <br>   const DIALOG_PAIR FAR   *dpOptList  , <br>   int                     iEntries, <br>   int                     iDefId) <br>{ <br> <br>   int            iDlg, iIndex; <br>   HWND        hOptionBox; <br>   LPSTR       szDefaultTitle; <br>   hOptionBox  =  GetDlgItem(hWnd, lbId); <br> <br> <br>   for (iDlg = 0; iDlg &lt; iEntries; iDlg++) { <br>      iIndex = ListBox_AddString(hOptionBox, <br>                                 dpOptList[iDlg].szDlgPairTitle); <br> <br>      ListBox_SetItemData(hOptionBox, <br>                          iIndex, <br>                          dpOptList[iDlg].iDlgPairDlgId); <br> <br> <br>      if (iDefId == dpOptList[iDlg].iDlgPairDlgId) { <br>         szDefaultTitle = dpOptList[iDlg].szDlgPairTitle; <br>      } <br> <br>   } <br> <br>   ListBox_SetCurSel(hOptionBox, <br>                     ListBox_FindStringExact(hOptionBox, 0, szDefaultTitle)); <br> <br>   return FALSE; <br>} <br> <br>/* <br>** InitializeDialogControls   -- Initialize all of the controls in a dialog <br>**                      from the lpchild structure.   Callback function. <br>** <br>** Parameters: <br>**    hDlg     -- dialog handle <br>**    lpChild     -- state structure <br>** <br>*/ <br> <br>VOID INTFUNC InitializeDialogControls( <br>                                      HWND   hDlg, <br>                                      LPCHILD   lpChild) <br>{ <br>   FARPROC     ControlInstance = MakeProcInstance((FARPROC)InitControlCallback, <br>                                                  g_hinst); <br> <br>   EnumChildWindows(hDlg, (WNDENUMPROC)ControlInstance, (LPARAM)lpChild); <br>   FreeProcInstance(ControlInstance); <br> <br>} <br> <br> <br> <br>/* <br>** InitControlCallback  -- callback function for initializing controls <br>** <br>** Parameters: <br>**    hwndChild   -- child window handle <br>**    lParam      -- lparam (lpChild from EnumChildProc <br>*/ <br> <br>BOOL CALLBACK InitControlCallback( <br>                                  HWND hwndChild, <br>                                  LPARAM  lParam) <br>{ <br>   int      iControl= GetDlgCtrlID(hwndChild); <br> <br>   if (iControl) { <br>      ControlValue((LPCHILD) lParam, <br>                   GetParent(hwndChild), <br>                   hwndChild, <br>                   iControl, <br>                   ACT_INIT); <br> <br>   } <br>   return TRUE; <br>} <br> <br> <br> <br>BOOL INTFUNC DlgProcFilter(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>   switch (msg) { <br>     case WM_SETTEXT: <br>     case WM_NCPAINT: <br>     case WM_NCACTIVATE: <br>      SetWindowLong(hDlg, DWL_MSGRESULT,0L); <br>      return TRUE; <br>   } <br>   return FALSE; <br>} <br> <br>/* <br>** AlignToControl -- align a window to a control in a dialog <br>** <br>** Parameters: <br>**    hWnd  -- window to align <br>**    hParent -- parent dialog <br>**    iCtlId   -- control Id <br>** <br>** Returns: BOOL that moveWindow returns <br>*/ <br> <br>BOOL INTFUNC AlignToControl( <br>                            HWND hWnd, <br>                            HWND hParent, <br>                            int     iCtlId) <br>{ <br>   HWND  hwndDrawArea; <br>   RECT  rcDrawArea, rcChildWnd; <br>   POINT ptPoint; <br> <br> <br>   hwndDrawArea = GetDlgItem(hParent, iCtlId); <br>   GetWindowRect(hwndDrawArea, &amp;rcDrawArea); <br>   GetWindowRect(hWnd, &amp;rcChildWnd); <br> <br>   ptPoint.x = rcDrawArea.left; <br>   ptPoint.y = rcDrawArea.top; <br> <br>   ScreenToClient(hWnd, &amp;ptPoint); <br> <br>   return (MoveWindow(  hWnd, <br>                      ptPoint.x, <br>                      ptPoint.y, <br>                      rcChildWnd.right- rcChildWnd.left, <br>                      rcChildWnd.bottom - rcChildWnd.top, <br>                      FALSE)); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
