<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHILD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2276"></a>CHILD.C</h2>
<pre><code>/*-------------------------------------------------------------------------- <br>  Child.C --- Cursors child window procedure <br> <br>  Description: <br>   This sample is spread across four files, each named for the role <br>   the contained functions play.  Each file header contains a brief <br>   description of its purpose and the routines it contains. <br> <br>   CHILD.C contains those routines which maintain a child window. <br>   These include most interfaces with ODBC including all data <br>   retrieval and display.  These functions are: <br> <br>     AllocChild      - Allocate and prepare child window memory <br>     AllocClipRgn    - Allocate clip region for painting <br>     Cancel          - Cancel SQL request <br>     CancelSQL       - Cancel asynchronous SQL request <br>     ChildProc       - Process child window messages <br>     CvtSqlToCType   - Return the default ODBC C type for a SQL type <br>     DeleteRow       - Build and issue a positioned delete <br>     DoChildMenu     - Process a menu request <br>     DoSQL           - Issue SQL statement and prepare all required <br>                       variables necessary for displaying the data <br>     Fetch           - Retrieve one row set <br>     FreeStmt        - Issue ODBC SQLFreeStmt (and adjust child memory) <br>     GetCurrentValue - Retrieve (in character format) column value <br>                       from current row (used by DIALOGS.C) <br>     GetData         - Issue a SQLGetData request <br>     GetTableName    - Extract table name from SQL <br>     IsUpdateable    - Check whether a column can be updated <br>     OnDataRow       - Determine if point is over displayed row of data <br>     PaintChild      - Paint child window <br>     ParamValid      - Validate the max column width of lpChild <br>     SetCurrentValue - Set a column value in the current row <br>                       (used by DIALOGS.C) <br>     SetPos          - Set current position in row set <br>     SetScroll       - Set scroll bar states and ranges <br>     SizeScroll      - Size and position scroll bars <br>     UpdateRow       - Build and issue a positioned update request <br> <br>   This code is furnished on an as-is basis as part of the ODBC SDK and is <br>   intended for example purposes only. <br> <br>--------------------------------------------------------------------------*/ <br> <br>/* Includes --------------------------------------------------------------*/ <br>#include "headers.h" <br> <br>#pragma warning(disable:4001) <br>#include   "resource.h" <br>#include   "crsrdemo.h" <br> <br> <br>// Constants --------------------------------------------------------------- <br>#define fDISABLED (MF_BYCOMMAND | MF_DISABLED | MF_GRAYED) <br>#define fENABLED  (MF_BYCOMMAND | MF_ENABLED) <br>#define NULLIFEMPTY(x) (*x?x:NULL) <br> <br>const char szDELETE[]       = "DELETE FROM "; <br>const char szFROM[]         = "FROM"; <br>const char szUPDATE[]       = "UPDATE "; <br>const char szWHERE[]        = " WHERE CURRENT OF "; <br>const char szNoDataTitle[]  = "No data to display"; <br>const char szNoData[]       = "The query didn't return any data"; <br>const char szSET[]          = " SET "; <br>const char szDataAffected[] = "%ld rows were affected"; <br>const char szRowAffected[]  = "%ld row was affected"; <br> <br>const int   cMAXCOLS   = 15; <br> <br>#define Async(x)     lpChild-&gt;fCanceled = FALSE;               \ <br>                     while ((rc = (x)) == SQL_STILL_EXECUTING) \ <br>                     CancelSQL(lpChild); <br> <br>#define STMTError(x) ODBCError(lpChild-&gt;hwnd, SQL_HANDLE_STMT, lpChild-&gt;hstmt, (x)) <br> <br> <br>// Prototypes -------------------------------------------------------------- <br>LPCHILD INTFUNC AllocChild(HWND); <br>void    INTFUNC AllocClipRgn(LPCHILD); <br>void    INTFUNC Cancel(LPCHILD); <br>void    INTFUNC CancelSQL(LPCHILD); <br>SWORD   INTFUNC CvtSqlToCType(SWORD); <br>void    INTFUNC DeleteRow(LPCHILD); <br>BOOL    INTFUNC DoChildMenu(LPCHILD, WPARAM, LPARAM); <br>void    INTFUNC DoSQL(LPCHILD); <br>void    INTFUNC Fetch(LPCHILD); <br>void    INTFUNC FreeStmt(UWORD, LPCHILD); <br>void    INTFUNC GetData(LPCHILD); <br>void    INTFUNC GetTableName(LPSTR, LPCSTR); <br>int     INTFUNC OnDataRow(LPCHILD, LPARAM); <br>void    INTFUNC PaintChild(LPCHILD, HDC, BOOL, BOOL, BOOL); <br>BOOL    INTFUNC  ParamValid(LPCHILD); <br>void    INTFUNC SetPos(LPCHILD, UWORD); <br>void    INTFUNC SetScroll(LPCHILD); <br>void    INTFUNC SizeScroll(LPCHILD); <br>void    INTFUNC UpdateRow(LPCHILD); <br>#ifdef THREAD <br>void    INTFUNC DeleteRowThread(LPCHILD); <br>void    INTFUNC DoSQLThread(LPCHILD); <br>void    INTFUNC FetchThread(LPCHILD); <br>void    INTFUNC GetDataThread(LPCHILD); <br>void    INTFUNC UpdateRowThread(LPCHILD); <br>#endif <br> <br>/* AllocChild -------------------------------------------------------------- <br>   Description: Allocate and initialize child variables <br>   --------------------------------------------------------------------------*/ <br>LPCHILD INTFUNC AllocChild(HWND hwnd) <br>{ <br>   SQLHSTMT hstmt; <br>   LPCHILD  lpChild; <br>   char  sz[cbSTRLEN]; <br> <br>   // Allocate ODBC SQLHSTMT and set cursor name <br>   if (DBCError(hwnd, SQLAllocHandle(SQL_HANDLE_STMT,g_hdbc, &amp;hstmt))) <br>      return NULL; <br> <br>#ifdef THREAD <br>   wsprintf(sz, szTITLEFMT, (LPSTR)g_szDSN, g_cCursor, GetCurrentThreadId()); <br>#else <br>   wsprintf(sz, szTITLEFMT, (LPSTR)g_szDSN, g_cCursor); <br>#endif <br> <br>   SetWindowText(hwnd, sz); <br> <br>   wsprintf(sz, szCURSORNAME, g_cCursor); <br>   if (ODBCError(hwnd, SQL_HANDLE_STMT, hstmt, <br>                 SQLSetCursorName(hstmt, (UCHAR FAR *)sz, SQL_NTS))) <br>      return NULL; <br> <br>   // Allocate child window structure and initialize <br>   lpChild = (LPCHILD)AllocPtr(sizeof(CHILD)); <br> <br>   lpChild-&gt;hwnd             = hwnd; <br>   lpChild-&gt;fInSetScroll     = FALSE; <br>   lpChild-&gt;fIsMinimized     = FALSE; <br>   lpChild-&gt;fHaveMouse       = FALSE; <br>   lpChild-&gt;iMouseRow        = -1; <br>   lpChild-&gt;fNoConcurrency   = FALSE; <br>   lpChild-&gt;fNoCursorType    = FALSE; <br> <br>   lpChild-&gt;ccols            = 0; <br>   lpChild-&gt;crowwin          = 0; <br>   lpChild-&gt;ccolwin          = 0; <br>   lpChild-&gt;fVScroll         = <br>      lpChild-&gt;fHScroll         = FALSE; <br>   lpChild-&gt;lpsz             = AllocPtr(cbBUFSIZE); <br> <br>   lpChild-&gt;hrgn             = NULL; <br> <br>   lpChild-&gt;hstmt            = hstmt; <br>   lpChild-&gt;hstmtTmp         = SQL_NULL_HSTMT; <br> <br>   lpChild-&gt;fBindByRow       = IDC_RADIO_BINDROW; <br>   lpChild-&gt;fConcurrency     = SQL_CONCUR_VALUES; <br>   lpChild-&gt;crowKeyset       = SQL_CURSOR_STATIC; <br>   lpChild-&gt;crowRowset       = 10; <br>   lpChild-&gt;fAsync           = FALSE; <br>   lpChild-&gt;irowPos          = 0; <br>   lpChild-&gt;irow             = 0; <br>   lpChild-&gt;cBind            = 0; <br>   lpChild-&gt;fBindAll         = TRUE; <br>   lpChild-&gt;ccolRetrieved    = 0; <br> <br>   lpChild-&gt;arow             = 1; <br>   lpChild-&gt;rrow             = 10; <br>   lpChild-&gt;ccol             = 0; <br>   lpChild-&gt;lpnTabs          = NULL; <br>   lpChild-&gt;lpcol            = NULL; <br>   lpChild-&gt;lpfStatus        = NULL; <br>   lpChild-&gt;fResultSetExists = FALSE; <br>   lpChild-&gt;fDataFetched     = FALSE; <br>   lpChild-&gt;rglpv            = NULL; <br>   lpChild-&gt;crowMaxBind      = DEF_MAXBIND; <br> <br>   lpChild-&gt;lpb              = NULL; <br>   lpChild-&gt;sql              = AllocPtr(cbMAXSQL); <br>   lpChild-&gt;cbrow            = 0; <br>   lpChild-&gt;dwGuiFlags       = GUIF_ALWAYSFETCH; <br>#ifdef THREAD <br>   InitializeCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>#endif <br> <br>   // Create scroll bars <br>   lpChild-&gt;hwndVScroll = CreateWindow(szSCROLLCLASS, NULL, <br>                                       WS_CHILD | SBS_VERT, <br>                                       0, 0, 0, 0, <br>                                       hwnd, (HMENU)1, g_hinst, NULL); <br> <br>   lpChild-&gt;hwndHScroll = CreateWindow(szSCROLLCLASS, NULL, <br>                                       WS_CHILD | SBS_HORZ, <br>                                       0, 0, 0, 0, <br>                                       hwnd, (HMENU)2, g_hinst, NULL); <br> <br>   // Load default SQL string <br>   LoadString(g_hinst, IDS_SQL, sz, cbSTRLEN); <br>   wsprintf(lpChild-&gt;sql, sz, g_szTable); <br> <br>   return lpChild; <br>} <br> <br> <br>/* AllocClipRgn ------------------------------------------------------------ <br>   Description: Allocate child window clip region <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC AllocClipRgn(LPCHILD lpChild) <br>{ <br>   RECT  rc; <br> <br>   // Determine client window size less space for scroll bars <br>   GetClientRect(lpChild-&gt;hwnd, &amp;rc); <br> <br>   if (lpChild-&gt;hrgn) DeleteObject(lpChild-&gt;hrgn); <br> <br>   if (lpChild-&gt;fVScroll) <br>      rc.right -= g_cxVScroll - 1; <br>   rc.bottom -= g_cyHScroll - 1; <br> <br>   // Allocate clip region <br>   lpChild-&gt;hrgn = CreateRectRgn(rc.left, <br>                                 rc.top, <br>                                 rc.right, <br>                                 rc.bottom); <br>   return; <br>} <br> <br> <br>/* CancelSQL --------------------------------------------------------------- <br>   Description: Display message while an async request is executing and <br>                give the user a chance to cancel the request (if it has <br>                not already been canceled) <br>                --------------------------------------------------------------------------*/ <br>void INTFUNC CancelSQL(LPCHILD lpChild) <br>{ <br>   char  sz[cbSTRLEN]; <br>   int   rc; <br> <br>   // Display message <br>   LoadString(g_hinst, IDS_STILLEXEC, sz, sizeof(sz)); <br>   rc = MessageBox(lpChild-&gt;hwnd, <br>                   sz, g_szTITLE, <br>                   MB_ICONINFORMATION | <br>                   (lpChild-&gt;fCanceled <br>                    ? MB_OK <br>                    : MB_OKCANCEL | MB_DEFBUTTON1)); <br> <br>   // If the user requested, cancel the current request <br>   if (rc == IDCANCEL) <br>      lpChild-&gt;fCanceled = SUCCESS(SQLCancel(lpChild-&gt;hstmt)); <br> <br>   return; <br>} <br> <br> <br>/* ChildProc --------------------------------------------------------------- <br>   Description: Child window procedure <br>   --------------------------------------------------------------------------*/ <br>LRESULT EXPFUNC ChildProc(HWND    hwnd, <br>                          UINT   msg, <br>                          WPARAM wparam, <br>                          LPARAM lparam) <br>{ <br>   LPCHILD  lpChild; <br> <br>   // Get access to child variables and set current window handle <br>   lpChild = (LPCHILD)GetWindowLong(hwnd, 0); <br> <br>   switch (msg) { <br> <br>      // Allocate child variables and save pointer <br>     case WM_CREATE: <br>      lpChild = AllocChild(hwnd); <br> <br>      SetWindowLong(hwnd, 0, (LONG)lpChild); <br> <br>      if (!lpChild) <br>         return -1; <br>      break; <br> <br>      // Paint child window (active or inactive) <br>     case WM_PAINT: { <br>        PAINTSTRUCT ps; <br>        BOOL     fActive; <br> <br>        fActive = (hwnd == <br>                   FORWARD_WM_MDIGETACTIVE(g_hwndClient, SendMessage)); <br> <br>        BeginPaint(hwnd, &amp;ps); <br>        PaintChild(lpChild, ps.hdc, TRUE, FALSE, fActive); <br>        EndPaint(hwnd, &amp;ps); <br>        break; <br>     } <br> <br>      // Trap mouse if over a rowset row <br>     case WM_LBUTTONDOWN: <br>      lpChild-&gt;iMouseRow = OnDataRow(lpChild, lparam); <br>      if (lpChild-&gt;iMouseRow &gt;= 0) { <br>         lpChild-&gt;fHaveMouse = TRUE; <br>         SetCapture(hwnd); <br>      } <br>      break; <br> <br>      // Make row current row (if mouse is still on the row) <br>     case WM_LBUTTONUP: <br>      if (!lpChild-&gt;fHaveMouse) <br>         break; <br> <br>      ReleaseCapture(); <br>      lpChild-&gt;fHaveMouse = FALSE; <br> <br>      if (lpChild-&gt;fDataFetched                         &amp;&amp; <br>          lpChild-&gt;fConcurrency != SQL_CONCUR_READ_ONLY &amp;&amp; <br>          lpChild-&gt;crowKeyset != SQL_CURSOR_FORWARD_ONLY &amp;&amp; <br>          lpChild-&gt;iMouseRow    == OnDataRow(lpChild, lparam)) { <br>         RECT  rc; <br>         int   y; <br> <br>         GetClientRect(hwnd, &amp;rc); <br> <br>         y = (int)HIWORD(lparam) - rc.top - g_cy; <br> <br>         SetPos(lpChild, <br>                (UWORD)(GetScrollPos(lpChild-&gt;hwndVScroll, SB_CTL) + (y / g_cy) + 1)); <br>      } <br>      break; <br> <br>      // Convert keyboard requests to scroll and change window requests <br>     case WM_KEYDOWN: <br>      if (wparam == VK_TAB) { <br>         FORWARD_WM_MDINEXT(g_hwndClient, hwnd, <br>                            (GetKeyState(VK_BACK) &amp; 0x1000 ? TRUE :FALSE), <br>                            SendMessage); <br>         break; <br>      } <br> <br>      else if (wparam == VK_DOWN || wparam == VK_UP) { <br> <br>         msg    = WM_VSCROLL; <br>         GET_WM_VSCROLL_CODE(wparam, lparam) = <br>            (wparam == VK_DOWN <br>             ? SB_LINEDOWN <br>             : SB_LINEUP); <br>      } <br>      else if (wparam == VK_LEFT || wparam == VK_RIGHT) { <br>         if (!lpChild-&gt;fHScroll) <br>            break; <br> <br>         msg    = WM_HSCROLL; <br>         GET_WM_HSCROLL_CODE(wparam, lparam) = <br>            (wparam == VK_RIGHT <br>             ? SB_LINEDOWN <br>             : SB_LINEUP); <br>      } <br>      else <br>         break; <br> <br>      // Scroll window <br>     case WM_HSCROLL: <br>     case WM_VSCROLL: { <br>        HWND  hwndCtl; <br>        int   cInc; <br>        int   iPos; <br>        int   cPage; <br>        int   nPos; <br>        int   iOrig; <br>        int   nMin, nMax; <br> <br>        if (!lpChild-&gt;fDataFetched) <br>           break; <br> <br>        // Determine scroll direction and distance <br>        hwndCtl = (msg == WM_HSCROLL <br>                   ? lpChild-&gt;hwndHScroll <br>                   : lpChild-&gt;hwndVScroll); <br>        cInc    = (msg == WM_HSCROLL ? 1 : 1); <br>        cPage   = (msg == WM_HSCROLL <br>                   ? lpChild-&gt;ccolwin <br>                   : lpChild-&gt;crowwin - 1); <br>        nPos    = GET_WM_HSCROLL_POS(wparam, lparam); <br>        iPos    = <br>           iOrig   = GetScrollPos(hwndCtl, SB_CTL); <br> <br>        GetScrollRange(hwndCtl, SB_CTL, &amp;nMin, &amp;nMax); <br>        switch (GET_WM_HSCROLL_CODE(wparam, lparam)) { <br>          case SB_BOTTOM:        iPos = nMax;  break; <br>          case SB_LINEDOWN:      iPos+= cInc;  break; <br>          case SB_LINEUP:        iPos-= cInc;  break; <br>          case SB_PAGEDOWN:      iPos+= cPage; break; <br>          case SB_PAGEUP:        iPos-= cPage; break; <br>          case SB_TOP:           iPos = nMin;  break; <br>          case SB_THUMBPOSITION: iPos = nPos;  break; <br>        } <br> <br>        // For updateable cursors, vertical scroll requests move the <br>        // current row scroll the window only as needed to keep the <br>        // current row visible <br>        if (msg == WM_VSCROLL &amp;&amp; <br>            lpChild-&gt;crowKeyset != SQL_CURSOR_FORWARD_ONLY &amp;&amp; <br>            lpChild-&gt;fConcurrency != SQL_CONCUR_READ_ONLY) { <br>           int   delta; <br> <br>           if (GET_WM_HSCROLL_CODE(wparam, lparam) == SB_LINEDOWN) <br>              delta = cInc; <br>           else if (GET_WM_HSCROLL_CODE(wparam, lparam) == SB_LINEUP) <br>              delta = -cInc; <br>           else if (GET_WM_HSCROLL_CODE(wparam, lparam) == SB_PAGEDOWN) { <br>              if (iPos &lt;= nMax) <br>                 delta = cPage; <br>              else <br>                 delta = lpChild-&gt;crowRowset - lpChild-&gt;irowPos; <br>           } <br>           else if (GET_WM_HSCROLL_CODE(wparam, lparam) == SB_PAGEUP) { <br>              if (iPos &gt;= nMin) <br>                 delta = -cPage; <br>              else <br>                 delta = 1 - lpChild-&gt;irowPos; <br>           } <br>           else if (GET_WM_HSCROLL_CODE(wparam, lparam) == SB_BOTTOM) <br>              delta = lpChild-&gt;crowRowset - lpChild-&gt;irowPos; <br>           else if (GET_WM_HSCROLL_CODE(wparam, lparam) == SB_TOP) <br>              delta = 1 - lpChild-&gt;irowPos; <br>           else if (GET_WM_HSCROLL_CODE(wparam, lparam) == SB_THUMBPOSITION) { <br>              if (lpChild-&gt;irowPos &gt; (UWORD)iPos &amp;&amp; <br>                  lpChild-&gt;irowPos &lt; (UWORD)(iPos+lpChild-&gt;crowwin)) <br>                 delta = 0; <br>              else if (iPos == nMin) <br>                 delta = 1 - lpChild-&gt;irowPos; <br>              else if (iPos == nMax) <br>                 delta = lpChild-&gt;crowRowset - lpChild-&gt;irowPos; <br>              else if (iPos &lt;= iOrig) <br>                 delta = iPos + lpChild-&gt;crowwin - 1 - lpChild-&gt;irowPos; <br>              else <br>                 delta = iPos - lpChild-&gt;irowPos + 1; <br>           } <br>           else <br>              break; <br> <br>           SetPos(lpChild, (UWORD)(lpChild-&gt;irowPos + delta)); <br> <br>           if ((GET_WM_HSCROLL_CODE(wparam, lparam) == SB_LINEDOWN || <br>                GET_WM_HSCROLL_CODE(wparam, lparam) == SB_LINEUP) &amp;&amp; <br>               lpChild-&gt;irowPos &gt; (UWORD)iOrig                &amp;&amp; <br>               lpChild-&gt;irowPos &lt; (UWORD)(iOrig+lpChild-&gt;crowwin)) <br>              break; <br>        } <br> <br>        // Pin scroll requests within scroll boundaries <br>        if (iPos &lt; nMin) <br>           iPos = nMin; <br>        else if (iPos &gt; nMax) <br>           iPos = nMax; <br> <br>        // Scroll the window if movement has occurred <br>        if (iPos != iOrig) { <br>           HDC      hdc; <br>           BOOL  fTitle; <br> <br>           hdc = GetDC(hwnd); <br> <br>           SetScrollPos(hwndCtl, SB_CTL, iPos, TRUE); <br> <br>           fTitle = (msg == WM_HSCROLL); <br> <br>           PaintChild(lpChild, hdc, fTitle, FALSE, TRUE); <br> <br>           ReleaseDC(hwnd, hdc); <br>        } <br>        break; <br>     } <br> <br>      // Activate the child window <br>     case WM_MDIACTIVATE: { <br>        HDC   hdc; <br> <br>        AdjustMenus(); <br> <br>        hdc = GetDC(hwnd); <br> <br>        PaintChild(lpChild, hdc, TRUE, TRUE, <br>                   GET_WM_MDIACTIVATE_FACTIVATE(lpChild-&gt;hwnd, wparam, lparam)); <br> <br>        ReleaseDC(lpChild-&gt;hwnd, hdc); <br>        break; <br>     } <br> <br>      // Free all child memory <br>     case WM_DESTROY: <br>      if (lpChild) { <br>         FreeStmt(SQL_DROP, lpChild); <br> <br>         FreePtr(lpChild-&gt;lpsz); <br>         FreePtr(lpChild-&gt;sql); <br>#ifdef THREAD <br>         DeleteCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>#endif <br>         FreePtr(lpChild); <br> <br>         SetWindowLong(hwnd, 0, 0L); <br>      } <br>      break; <br> <br>      // Close the window <br>     case WM_CLOSE: <br>      g_cChild--; <br> <br>      if( !g_cChild ) <br>#ifdef WIN32 <br>         SendMessage(g_hwndClient, WM_MDISETMENU, <br>                     (WPARAM)g_hmenuFrame, <br>                     (LPARAM)g_hmenuFrameWindow); <br>#else <br>      FORWARD_WM_MDISETMENU(g_hwndClient, 0, g_hmenuFrame, <br>                            g_hmenuFrameWindow, SendMessage); <br>#endif <br> <br>      // Destroy child window <br>      FORWARD_WM_MDIDESTROY(g_hwndClient, hwnd, SendMessage); <br>      AdjustMenus(); <br>      break; <br> <br>      // Pass all other messages (eventually) to the MDI window procedure <br>     default: <br> <br>      // Reset scroll bars (if needed) when the window is resized <br>      if (msg == WM_SIZE) { <br> <br>         if (wparam == SIZE_MINIMIZED) <br>            lpChild-&gt;fIsMinimized = TRUE; <br> <br>         else { <br>            if (lpChild-&gt;fIsMinimized) <br>               lpChild-&gt;fIsMinimized = FALSE; <br> <br>            SizeScroll(lpChild); <br> <br>            if (lpChild-&gt;fDataFetched) { <br>               int   row; <br> <br>               SetScroll(lpChild); <br> <br>               row = GetScrollPos(lpChild-&gt;hwndVScroll, SB_CTL); <br> <br>               if (lpChild-&gt;fConcurrency != SQL_CONCUR_READ_ONLY &amp;&amp; <br>                   lpChild-&gt;irowPos &gt;= (UWORD)(row+lpChild-&gt;crowwin)) <br>                  if (lpChild-&gt;crowwin &gt; 1) <br>                     SetScrollPos(lpChild-&gt;hwndVScroll, <br>                                  SB_CTL, <br>                                  lpChild-&gt;irowPos-lpChild-&gt;crowwin+1, <br>                                  TRUE); <br>                  else <br>                     SetScrollPos(lpChild-&gt;hwndVScroll, <br>                                  SB_CTL, <br>                                  lpChild-&gt;irowPos-lpChild-&gt;crowwin, <br>                                  TRUE); <br>            } <br> <br>            AllocClipRgn(lpChild); <br>         } <br> <br>         InvalidateRect(hwnd, NULL, TRUE); <br>      } <br> <br>      // Handle child window menu requests <br>      else if (msg == WM_COMMAND) <br>         DoChildMenu(lpChild, wparam, lparam); <br> <br>      // Pass message on to the MDI window procedure <br>      return DefMDIChildProc(hwnd, msg, wparam, lparam); <br>   } <br> <br>   return (LRESULT)NULL; <br>} <br> <br> <br>/* CvtSqlToCType ----------------------------------------------------------- <br>   Description: Determine the default ODBC C type for a given SQL type <br>   --------------------------------------------------------------------------*/ <br>SWORD INTFUNC CvtSqlToCType(SWORD fSqlType) <br>{ <br>   switch (fSqlType) { <br>     case SQL_CHAR: <br>     case SQL_VARCHAR: <br>     case SQL_LONGVARCHAR: <br>     case SQL_DECIMAL: <br>     case SQL_NUMERIC: <br>     case SQL_BIGINT:           return SQL_C_CHAR; <br> <br>     case SQL_BIT:              return SQL_C_BIT; <br>     case SQL_TINYINT: <br>     case SQL_SMALLINT:         return SQL_C_SHORT; <br>     case SQL_INTEGER:          return SQL_C_LONG; <br>     case SQL_REAL:             return SQL_C_FLOAT; <br> <br>     case SQL_FLOAT: <br>     case SQL_DOUBLE:           return SQL_C_DOUBLE; <br> <br>     case SQL_BINARY: <br>     case SQL_VARBINARY: <br>     case SQL_LONGVARBINARY:    return SQL_C_BINARY; <br> <br>     case SQL_TYPE_DATE:        return SQL_C_TYPE_DATE; <br>     case SQL_TYPE_TIME:        return SQL_C_TYPE_TIME; <br>     case SQL_TYPE_TIMESTAMP:   return SQL_C_TYPE_TIMESTAMP; <br> <br>     case SQL_DATE:             return SQL_C_DATE; <br>     case SQL_TIME:             return SQL_C_TIME; <br>     case SQL_TIMESTAMP:        return SQL_C_TIMESTAMP; <br>   } <br> <br>   return SQL_C_CHAR; <br>} <br> <br> <br>/* DeleteRow --------------------------------------------------------------- <br>   Description: Delete the current (positioned) row <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC DeleteRow(LPCHILD lpChild) <br>{ <br>   HCURSOR  hcur; <br>   LPSTR    lpsz; <br>   LPSTR    lpszT; <br>   SWORD    cb; <br> <br>   // Ensure the delete request is valid <br>   if (!lpChild-&gt;fDataFetched) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_NODATAFETCHED); <br>      return; <br>   } <br> <br>   if (*(lpChild-&gt;lpfStatus + lpChild-&gt;irowPos - 1) == SQL_ROW_NOROW) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_NOROWDELETE); <br>      return; <br>   } <br> <br>   if (*(lpChild-&gt;lpfStatus + lpChild-&gt;irowPos - 1) == SQL_ROW_ERROR) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_ERRORROWDELETE); <br>      return; <br>   } <br> <br>   if (*(lpChild-&gt;lpfStatus + lpChild-&gt;irowPos - 1) == SQL_ROW_DELETED) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_DELROWDELETE); <br>      return; <br>   } <br> <br>   if (lpChild-&gt;fConcurrency == SQL_CONCUR_READ_ONLY) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_NOUPDATE); <br>      return; <br>   } <br> <br>   lpsz  = AllocPtr(2 * cbMAXSQL); <br>   lpszT = lpsz + cbMAXSQL; <br> <br>   // Verify the request and allocate a new (temporary) SQLHSTMT for the delete <br>   LoadString(g_hinst, IDS_DELETEROW, lpsz, cbMAXSQL); <br>   if (IDYES == MessageBox(lpChild-&gt;hwnd, lpsz, <br>                           g_szTITLE, MB_ICONQUESTION | MB_YESNO) &amp;&amp; <br>       !DBCError(lpChild-&gt;hwnd, SQLAllocHandle(SQL_HANDLE_STMT,g_hdbc, &amp;lpChild-&gt;hstmtTmp))) { <br> <br>      // Build DELETE &lt;table&gt; WHERE CURRENT OF &lt;cursor&gt; statement <br>      lstrcpy(lpsz, szDELETE); <br> <br>      GetTableName(lpszT, lpChild-&gt;sql); <br>      lstrcat(lpsz, lpszT); <br> <br>      lstrcat(lpsz, szWHERE); <br> <br>      lpszT = lpsz + lstrlen(lpsz); <br> <br>      hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>      if (!STMTError(SQLGetCursorName(lpChild-&gt;hstmt, (UCHAR FAR *)lpszT, <br>                                      cbMAXSQL, &amp;cb))) { <br> <br>         // Issue the request via SQLPrepare/SQLExecute <br>         if (!ODBCError(lpChild-&gt;hwnd, SQL_HANDLE_STMT, lpChild-&gt;hstmtTmp, <br>                        SQLPrepare(lpChild-&gt;hstmtTmp, (UCHAR FAR *)lpsz, SQL_NTS)) &amp;&amp; <br>             !ODBCError(lpChild-&gt;hwnd, SQL_HANDLE_STMT, lpChild-&gt;hstmtTmp, <br>                        SQLExecute(lpChild-&gt;hstmtTmp)) ) { <br>            UWORD irowPos; <br> <br>            irowPos = lpChild-&gt;irowPos; <br> <br>            // Completely refresh local rowset buffer <br>            lpChild-&gt;rrow = 0; <br>            lpChild-&gt;FetchOP = SQL_FETCH_RELATIVE; <br>            Fetch(lpChild); <br> <br>            // Reset current position (fetching sets it to the first row) <br>            SetPos(lpChild, irowPos); <br> <br>            // Repaint window <br>            InvalidateRect(lpChild-&gt;hwnd, NULL, FALSE); <br>         } <br>      } <br> <br>      DBCError(lpChild-&gt;hwnd, SQLFreeHandle(SQL_HANDLE_STMT,lpChild-&gt;hstmtTmp)); <br>      lpChild-&gt;hstmtTmp = SQL_NULL_HSTMT; <br> <br>      SetCursor(hcur); <br> <br>   } <br> <br>   FreePtr(lpsz); <br> <br>   return; <br>} <br> <br> <br>/* DoChildMenu ------------------------------------------------------------- <br>   Description: Respond to a request from the child window menu <br>   --------------------------------------------------------------------------*/ <br>BOOL INTFUNC DoChildMenu(LPCHILD lpChild, WPARAM  wParam, LPARAM  lParam) <br>{ <br>   UNREF_PARAM (lParam); <br>   switch (GET_WM_COMMAND_ID(wParam, lparam)) { <br> <br>     case IDM_STMT_SEND: <br>      if (IDOK == DoDialog(lpChild-&gt;hwnd, IDD_STATEMENT, StmtDlgProc)) <br>#ifdef THREAD <br>         DoSQLThread(lpChild); <br>#else <br>      DoSQL(lpChild); <br>#endif <br>      break; <br> <br>     case IDM_STMT_TABLE: <br>      if (IDOK == DoDialog(lpChild-&gt;hwnd, IDD_TABLE_INFO, SQLTablesDlgProc)) <br>#ifdef THREAD <br>         DoSQLThread(lpChild); <br>#else <br>      DoSQL(lpChild); <br>#endif <br>      break; <br> <br>     case IDM_STMT_TYPE: <br>      lpChild-&gt;dwOperation = OPER_TYPES; <br>#ifdef THREAD <br>      DoSQLThread(lpChild); <br>#else <br>      DoSQL(lpChild); <br>#endif <br>      break; <br> <br> <br> <br>     case IDM_STMT_OPTIONS:     // general <br>      { <br>         CHILD    ChildOld; <br> <br>         // save old values (only works because no pointers <br>         // get modified in options) <br> <br>         memcpy(&amp;ChildOld, lpChild, sizeof(ChildOld)); <br>         // no modification on those option values yet <br>         lpChild-&gt;fBind = <br>            lpChild-&gt;fMaxBind = <br>               lpChild-&gt;fRowset = FALSE; <br> <br>         if (IDOK == DoDialog(lpChild-&gt;hwnd, IDD_OPTION_DIALOG, <br>                              OptionsDlgProc) &amp;&amp; ParamValid(lpChild)) { <br>            if (lpChild-&gt;fDataFetched) { <br>               FreeStmt(SQL_CLOSE,  lpChild); <br>               FreeStmt(SQL_UNBIND, lpChild); <br>            } <br>         } <br>         else { <br>            // restore previous state <br>            memcpy(lpChild, &amp;ChildOld, sizeof(ChildOld)); <br>         } <br>         break; <br>      } <br> <br>     case IDM_STMT_CANCEL:      // general <br>      Cancel(lpChild); <br>      break; <br> <br>     case IDM_FETCH_FIRST: <br>      lpChild-&gt;FetchOP = SQL_FETCH_FIRST; <br>#ifdef THREAD <br>      FetchThread(lpChild); <br>#else <br>      Fetch(lpChild); <br>#endif <br>      break; <br> <br>     case IDM_FETCH_PRIOR: <br>      lpChild-&gt;FetchOP = SQL_FETCH_PRIOR; <br>#ifdef THREAD <br>      FetchThread(lpChild); <br>#else <br>      Fetch(lpChild); <br>#endif <br>      break; <br> <br>     case IDM_FETCH_NEXT: <br>      lpChild-&gt;FetchOP = SQL_FETCH_NEXT; <br>#ifdef THREAD <br>      FetchThread(lpChild); <br>#else <br>      Fetch(lpChild); <br>#endif <br>      break; <br> <br>     case IDM_FETCH_LAST: <br>      lpChild-&gt;FetchOP = SQL_FETCH_LAST; <br>#ifdef THREAD <br>      FetchThread(lpChild); <br>#else <br>      Fetch(lpChild); <br>#endif <br>      break; <br> <br>     case IDM_FETCH_ABSOLUTE: <br>      if (IDOK == DoDialog(lpChild-&gt;hwnd, IDD_ABSOLUTE, AbsDlgProc)) { <br>         lpChild-&gt;FetchOP = SQL_FETCH_ABSOLUTE; <br>#ifdef THREAD <br>         FetchThread(lpChild); <br>#else <br>         Fetch(lpChild); <br>#endif <br>      } <br>      break; <br> <br>     case IDM_FETCH_RELATIVE: <br>      if (IDOK == DoDialog(lpChild-&gt;hwnd, IDD_RELATIVE, RelDlgProc)) { <br>         lpChild-&gt;FetchOP = SQL_FETCH_RELATIVE; <br>#ifdef THREAD <br>         FetchThread(lpChild); <br>#else <br>         Fetch(lpChild); <br>#endif <br>      } <br>      break; <br> <br>     case IDM_FETCH_GET: <br>#ifdef THREAD <br>      GetDataThread(lpChild); <br>#else <br>      GetData(lpChild); <br>#endif <br>      break; <br> <br>     case IDM_FETCH_DELETEROW: <br>#ifdef THREAD <br>      DeleteRowThread(lpChild); <br>#else <br>      DeleteRow(lpChild); <br>#endif <br>      break; <br> <br>     case IDM_FETCH_UPDATEROW: <br>#ifdef THREAD <br>      UpdateRowThread(lpChild); <br>#else <br>      UpdateRow(lpChild); <br>#endif <br>      break; <br>     default: <br>      return FALSE; <br>   } <br> <br>   AdjustMenus(); <br>   return TRUE; <br>} <br> <br>#ifdef THREAD <br>void INTFUNC DoSQLThread(LPCHILD lpChild) <br>{ <br>   DWORD dwThreadId; <br> <br>   EnterCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>   lpChild-&gt;hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)DoSQL, <br>                                    (LPVOID)lpChild, 0, &amp;dwThreadId); <br>   LeaveCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>} <br> <br>void INTFUNC FetchThread(LPCHILD lpChild) <br>{ <br>   DWORD dwThreadId; <br> <br>   EnterCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>   lpChild-&gt;hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)Fetch, <br>                                    (LPVOID)lpChild, 0, &amp;dwThreadId); <br>   LeaveCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>} <br> <br>void INTFUNC GetDataThread(LPCHILD lpChild) <br>{ <br>   DWORD dwThreadId; <br> <br>   EnterCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>   lpChild-&gt;hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)GetData, <br>                                    (LPVOID)lpChild, 0, &amp;dwThreadId); <br>   LeaveCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>} <br> <br>void INTFUNC UpdateRowThread(LPCHILD lpChild) <br>{ <br>   DWORD dwThreadId; <br> <br>   EnterCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>   lpChild-&gt;hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)UpdateRow, <br>                                    (LPVOID)lpChild, 0, &amp;dwThreadId); <br>   LeaveCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>} <br> <br>void INTFUNC DeleteRowThread(LPCHILD lpChild) <br>{ <br>   DWORD dwThreadId; <br> <br>   EnterCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>   lpChild-&gt;hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)DeleteRow, <br>                                    (LPVOID)lpChild, 0, &amp;dwThreadId); <br>   LeaveCriticalSection (&amp;lpChild-&gt;ThreadCreation); <br>} <br>#endif <br> <br> <br>/* DoSQL ------------------------------------------------------------------- <br>   Description: Issue a SQL statement and prepare for fetching data <br>   --------------------------------------------------------------------------*/ </code></pre>
<p>
</p>
<pre><code>void INTFUNC DoSQL(LPCHILD lpChild) <br>{ <br>   SQLRETURN rc; <br> <br>   // Prepare the statement <br> <br>   if (PrepareStmt(lpChild) == SQL_ERROR) <br>      return; <br> <br>   switch(lpChild-&gt;dwOperation) { <br>     case  OPER_SELECT: <br>      // Issue the request via SQLExecDirect <br>      Async(SQLExecDirect(lpChild-&gt;hstmt, <br>                          (UCHAR FAR *)lpChild-&gt;sql, <br>                          lstrlen(lpChild-&gt;sql))); <br>      break; <br> <br>     case  OPER_TYPES: <br>      // Issue a GetTypeInfo request <br>      Async(SQLGetTypeInfo(lpChild-&gt;hstmt, SQL_ALL_TYPES)); <br>      break; <br> <br> <br>     case  IDC_TABLE_RAD_TABLE: <br>      if (!*lpChild-&gt;szTable &amp;&amp; <br>          ((!*lpChild-&gt;szUser &amp;&amp; strcmp(lpChild-&gt;szQualifier, "%") == 0)|| <br>           (!*lpChild-&gt;szQualifier &amp;&amp; strcmp(lpChild-&gt;szUser, "%") == 0))) {  // Special qualifier enumeration <br>         Async(SQLTables(lpChild-&gt;hstmt, <br>                         lpChild-&gt;szQualifier, SQL_NTS, <br>                         lpChild-&gt;szUser, SQL_NTS, <br>                         lpChild-&gt;szTable, SQL_NTS, <br>                         lpChild-&gt;szType,  SQL_NTS)); <br>      } <br>      else <br>         {  // Normal SQLTables call <br>            Async(SQLTables(lpChild-&gt;hstmt, <br>                            NULLIFEMPTY(lpChild-&gt;szQualifier), SQL_NTS, <br>                            NULLIFEMPTY(lpChild-&gt;szUser), SQL_NTS, <br>                            NULLIFEMPTY(lpChild-&gt;szTable),  SQL_NTS, <br>                            NULLIFEMPTY(lpChild-&gt;szType),  SQL_NTS)); <br>         } <br>      break; <br> <br>     case  IDC_TABLE_RAD_PRIV: <br>      Async(SQLTablePrivileges(lpChild-&gt;hstmt, <br>                               NULLIFEMPTY(lpChild-&gt;szQualifier), SQL_NTS, <br>                               NULLIFEMPTY(lpChild-&gt;szUser), SQL_NTS, <br>                               NULLIFEMPTY(lpChild-&gt;szTable),  SQL_NTS)); <br> <br>      break; <br> <br>     case  IDC_TABLE_RAD_STATISTICS: <br>      Async(SQLStatistics(lpChild-&gt;hstmt, <br>                          NULLIFEMPTY(lpChild-&gt;szQualifier), SQL_NTS, <br>                          NULLIFEMPTY(lpChild-&gt;szUser), SQL_NTS, <br>                          NULLIFEMPTY(lpChild-&gt;szTable),  SQL_NTS, <br>                          SQL_INDEX_ALL,      // XXX <br>                          SQL_QUICK));     // XXX <br>      break; <br> <br> <br> <br>     case  IDC_TABLE_RAD_PROC: <br>      Async(SQLProcedures(lpChild-&gt;hstmt, <br>                          NULLIFEMPTY(lpChild-&gt;szQualifier), SQL_NTS, <br>                          NULLIFEMPTY(lpChild-&gt;szUser), SQL_NTS, <br>                          NULLIFEMPTY(lpChild-&gt;szTable),  SQL_NTS)); <br> <br>      break; <br> <br>     case  IDC_TABLE_RAD_COLUMN: <br>      Async(SQLColumns(lpChild-&gt;hstmt, <br>                       NULLIFEMPTY(lpChild-&gt;szQualifier), SQL_NTS, <br>                       NULLIFEMPTY(lpChild-&gt;szUser), SQL_NTS, <br>                       NULLIFEMPTY(lpChild-&gt;szTable),  SQL_NTS, <br>                       NULLIFEMPTY(lpChild-&gt;szColName), SQL_NTS)); <br> <br>   } <br> <br>   if (STMTError(rc)) <br>      return; <br> <br>   if (ProcessResults(lpChild)) { <br> <br>      if (lpChild-&gt;dwGuiFlags &amp; GUIF_ALWAYSFETCH) { <br>         lpChild-&gt;FetchOP = SQL_FETCH_NEXT; <br>         Fetch(lpChild); <br>      } <br>   } <br> <br>   AdjustMenus(); <br>   return; <br> <br>} <br> <br>/* ProcessResults--------------------------------------------------------------- <br>   Description: Process the results from a query or statement <br>   --------------------------------------------------------------------------*/ <br>BOOL INTFUNC ProcessResults(LPCHILD lpChild) <br>{ <br>   LPINT     lptab; <br>   LPCOL     lpcol; <br>   LPBYTE    lpb; <br>   SDWORD    cbMsg; <br>   SDWORD    cbNull; <br>   int       nLastTab; <br>   SWORD     i; <br>   SQLRETURN rc; <br> <br> <br>   // Retrieve number of columns in the result set <br>   Async(SQLNumResultCols(lpChild-&gt;hstmt, &amp;i)); <br>   if (STMTError(rc)) <br>      return FALSE; <br>   lpChild-&gt;ccol = ((UWORD)i &lt; lpChild-&gt;cBind || lpChild-&gt;fBindAll <br>                    ? i <br>                    : lpChild-&gt;cBind); <br> <br>   // If a result set exists, continue; otherwise, return immediately <br>   if (lpChild-&gt;ccol) <br>      lpChild-&gt;fResultSetExists = TRUE; <br>   else <br>      return FALSE; <br> <br>   // Allocate painting related storage and row status array <br> <br>   lpChild-&gt;rglpv     = (char *)AllocPtr(sizeof(char *) * lpChild-&gt;ccol); <br>   lpChild-&gt;lpnTabs   = (LPINT)AllocPtr(sizeof(int) * (lpChild-&gt;ccol+1)); <br>   lpChild-&gt;lpcol     = (LPCOL)AllocPtr(sizeof(COL) * lpChild-&gt;ccol); <br>   lpChild-&gt;lpfStatus = (LPUWORD)AllocPtr((DWORD) sizeof(UWORD) <br>                                          * lpChild-&gt;crowRowset); <br> <br>   for (i=1, lpcol=lpChild-&gt;lpcol; i &lt;= lpChild-&gt;ccol; i++, lpcol++) { <br>      lpcol-&gt;lpb  = NULL; <br>      lpcol-&gt;lpcb = NULL; <br>   } <br> <br>   cbMsg  = lstrlen(g_szRowDeleted); <br>   cbNull = lstrlen(g_szNull); <br>   cbMsg  = max(cbMsg, lstrlen(g_szNoRow)); <br>   cbMsg  = max(cbMsg, cbNull); <br> <br>   // Initialize row width (in bytes) and total number of characters per line <br>   lpChild-&gt;cbrow = 0; <br>   lpChild-&gt;ccols = 0; <br> <br>   lpcol = lpChild-&gt;lpcol; <br>   lptab = lpChild-&gt;lpnTabs; <br> <br>   nLastTab = <br>      *lptab++ = cxBORDER; <br> <br>   // For each bound column <br>   //   a) Get column attributes (e.g., name, size, data type) <br>   //   b) Add column to physical and display row widths <br>   //   c) Determine tab location <br>   for (i=1; i &lt;= lpChild-&gt;ccol; i++, lpcol++, lptab++) { <br> <br>      // Get column name <br>      Async(SQLColAttribute(lpChild-&gt;hstmt, i, <br>                            SQL_DESC_NAME, <br>                            lpcol-&gt;szName, sizeof(lpcol-&gt;szName), NULL, <br>                            NULL)); <br>      if (STMTError(rc)) { <br>         FreeStmt(SQL_DROP, lpChild); <br>         return FALSE; <br>      } <br> <br>      // Get actual column length (number of physical data bytes) <br>// if the sample were to be used with a 3.0 driver only SQLColAttribute <br>// with fattribute of SQL_DESC_OCTECT_LENGTH could be called instead. <br> Async(SQLColAttributes(lpChild-&gt;hstmt, i, <br>                            SQL_COLUMN_LENGTH, <br>                            NULL, 0, NULL, <br>                            &amp;lpcol-&gt;cb)); <br> <br> <br>      if (STMTError(rc)) { <br>         FreeStmt(SQL_DROP, lpChild); <br>         return FALSE; <br>      } <br> <br>      // Get display width <br>      Async(SQLColAttribute(lpChild-&gt;hstmt, i, <br>                            SQL_DESC_DISPLAY_SIZE, <br>                            NULL, 0, NULL, <br>                            &amp;lpcol-&gt;cbc)); <br>      if (STMTError(rc)) { <br>         FreeStmt(SQL_DROP, lpChild); <br>         return FALSE; <br>      } <br> <br> <br>      // if the display size is too big, force to the the maximum <br>      if (lpcol-&gt;cbc &gt; lpChild-&gt;crowMaxBind) <br>         lpcol-&gt;cbc = lpChild-&gt;crowMaxBind; <br> <br>      // Ensure display width is wide enough for: <br>      //   a) Column name <br>      //   b) Null string <br>      //   c) Row status (for the first column only) <br>      if (lpcol-&gt;cbc &lt; cbMsg) <br>         lpcol-&gt;cbc = cbMsg; <br> <br>      if (lstrlen(lpcol-&gt;szName) &gt; lpcol-&gt;cbc) <br>         lpcol-&gt;cbc = lstrlen(lpcol-&gt;szName); <br> <br>      lpcol-&gt;cbc++; <br> <br>      // Get column SQL type <br>      Async(SQLColAttribute(lpChild-&gt;hstmt, i, <br>                            SQL_DESC_CONCISE_TYPE, <br>                            NULL, 0, NULL, <br>                            (SDWORD FAR*) &amp;lpcol-&gt;fSqlType)); <br>      if (STMTError(rc)) { <br>         FreeStmt(SQL_DROP, lpChild); <br>         return FALSE; <br>      } <br> <br>      // Determine target C type <br>      lpcol-&gt;fCType = CvtSqlToCType(lpcol-&gt;fSqlType); <br> <br>      // For hard to handle C types, let the driver convert to character <br>      if (lpcol-&gt;fCType == SQL_C_BIT    || <br>          lpcol-&gt;fCType == SQL_C_BINARY || <br>          lpcol-&gt;fCType == SQL_C_DATE   || <br>          lpcol-&gt;fCType == SQL_C_TIME   || <br>          lpcol-&gt;fCType == SQL_C_TIMESTAMP || <br>          lpcol-&gt;fCType == SQL_C_TYPE_DATE   || <br>          lpcol-&gt;fCType == SQL_C_TYPE_TIME   || <br>          lpcol-&gt;fCType == SQL_C_TYPE_TIMESTAMP) { <br>         lpcol-&gt;fCType = SQL_C_CHAR; <br>         lpcol-&gt;cb = lpcol-&gt;cbc; <br>      } <br> <br>      // Determine next column tab (based on column width plus border) <br>      nLastTab = <br>         *lptab    = nLastTab + ((int)lpcol-&gt;cbc * g_cx) + (2 * cxBORDER); <br> <br>      // Set maximum column length for character data <br>      if( lpcol-&gt;cb &gt; lpChild-&gt;crowMaxBind &amp;&amp; <br>         lpcol-&gt;fCType == SQL_C_CHAR ) <br>         lpcol-&gt;cb = lpChild-&gt;crowMaxBind; <br> <br>      if( lpcol-&gt;fCType == SQL_C_CHAR ) <br>         lpcol-&gt;cb++; <br> <br>      // Increment total phsyical row width and display width <br>      lpChild-&gt;cbrow += lpcol-&gt;cb; <br>      lpChild-&gt;ccols += (int)lpcol-&gt;cbc; <br> <br>      cbMsg = cbNull; <br>   } <br> <br>   // Include a count field for each bound column in physical row width <br>   lpChild-&gt;cbrow += lpChild-&gt;ccol * sizeof(SDWORD); <br> <br>   // Add intra-column border amounts to total character width <br>   lpChild-&gt;ccols += (lpChild-&gt;ccol * (2 * cxBORDER)) / g_cx; <br> <br>   // For each column, include an element in the format string <br>   lpb  = (LPBYTE)lpChild-&gt;szFmt; <br>   for (i=0, lpcol=lpChild-&gt;lpcol; i &lt; lpChild-&gt;ccol; i++, lpcol++) { <br>      *(lpb++) = '\t'; <br>      *(lpb++) = '%'; <br>      *(lpb++) = 's'; <br>   } <br>   *lpb = 0; <br> <br>   // If row-wise binding, allocate a buffer; switch to column-wise <br>   // if the entire row-set cannot fit into 64K minus cursor library <br>   // headers <br>   lpb = NULL; <br>   if (ROW_BINDING(lpChild)) { <br>      if ((lpChild-&gt;cbrow * lpChild-&gt;crowRowset) &gt; 65500L) { <br>         DoMessage(lpChild-&gt;hwnd, IDS_BIGROWSET); <br>         lpChild-&gt;fBindByRow = IDC_RADIO_BINDCOL ; <br>      } <br>      else { <br>         lpb          = <br>            lpChild-&gt;lpb = (LPBYTE)AllocPtr(lpChild-&gt;cbrow * <br>                                            lpChild-&gt;crowRowset); <br>      } <br>   } <br> <br>   // Set binding type <br>   if (STMTError(SQLSetStmtAttr(lpChild-&gt;hstmt, <br>                                SQL_ATTR_ROW_BIND_TYPE, <br>                                (SQLPOINTER) (ROW_BINDING(lpChild) <br>                                              ? lpChild-&gt;cbrow <br>                                              : SQL_BIND_BY_COLUMN), <br>                                SQL_IS_INTEGER))) <br>      return FALSE; <br> <br>   // Finally, for each bound column, bind the data value <br>   for (i=1, lpcol=lpChild-&gt;lpcol; i &lt;= lpChild-&gt;ccol; i++, lpcol++) { <br>      if (!ROW_BINDING(lpChild)) { <br>         lpcol-&gt;lpb  = (LPBYTE)AllocPtr(lpcol-&gt;cb * lpChild-&gt;crowRowset); <br>         lpcol-&gt;lpcb = (LPSDWORD)AllocPtr((DWORD) sizeof(SDWORD) * <br>                                          lpChild-&gt;crowRowset); <br>      } <br>      else { <br>         lpcol-&gt;lpb  = (LPBYTE)lpb; <br>         lpcol-&gt;lpcb = (LPSDWORD)(lpb + lpcol-&gt;cb); <br>         lpb += lpcol-&gt;cb + sizeof(SDWORD); <br>      } <br> <br>      if (STMTError(SQLBindCol(lpChild-&gt;hstmt, i, (SWORD)lpcol-&gt;fCType, <br>                               (PTR)(lpcol-&gt;lpb), <br>                               lpcol-&gt;cb, <br>                               lpcol-&gt;lpcb))) <br>         return FALSE; <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* PrepareStmt ------------------------------------------------------------- <br>   Description: Prepare a statement for future processing <br> <br>   Returns: SQL_ERROR if an error occurs <br>   --------------------------------------------------------------------------*/ <br>SQLRETURN INTFUNC PrepareStmt(LPCHILD lpChild) <br>{ <br> <br>   // Close the statement and drop bindings <br>   FreeStmt(SQL_CLOSE,  lpChild); <br>   FreeStmt(SQL_UNBIND, lpChild); <br> <br>   // Set scroll options <br>   if (!(SUCCESS(SQLSetStmtAttr(lpChild-&gt;hstmt, <br>                                SQL_ATTR_CURSOR_TYPE, <br>                                (SQLPOINTER) lpChild-&gt;crowKeyset, <br>                                SQL_IS_INTEGER)))) <br>      lpChild-&gt;fNoCursorType = TRUE; <br> <br>   if (!(SUCCESS(SQLSetStmtAttr(lpChild-&gt;hstmt, <br>                                SQL_ATTR_CONCURRENCY, <br>                                (SQLPOINTER) lpChild-&gt;fConcurrency, <br>                                SQL_IS_INTEGER)))) <br>      lpChild-&gt;fNoConcurrency = TRUE; <br> <br> <br>   if (STMTError(SQLSetStmtAttr(lpChild-&gt;hstmt, <br>                                SQL_ATTR_ROW_ARRAY_SIZE, <br>                                (SQLPOINTER) lpChild-&gt;crowRowset, <br>                                SQL_IS_INTEGER))) <br>      return SQL_ERROR; <br> <br>   // Set async mode (if supported by the driver) <br>   if (g_fAsyncSupported &amp;&amp; <br>       STMTError(SQLSetStmtAttr(lpChild-&gt;hstmt, <br>                                SQL_ATTR_ASYNC_ENABLE, <br>                                (SQLPOINTER) (lpChild-&gt;fAsync ? 1 : 0), <br>                                SQL_IS_INTEGER))) <br>      return SQL_ERROR; <br> <br> <br> <br>   return FALSE; <br> <br>} <br> <br>/* Cancel ------------------------------------------------------------------- <br>   Description: Issue cancel request <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC Cancel(LPCHILD lpChild) <br>{ <br>   SQLRETURN rc; <br> <br>   // Call SQLCancel <br>   if (lpChild-&gt;hstmtTmp != SQL_NULL_HSTMT) { <br>      rc = SQLCancel(lpChild-&gt;hstmtTmp);  // Cancel temp hstmt <br>      STMTError(rc); <br>   } <br>   else { <br>      rc = SQLCancel(lpChild-&gt;hstmt); <br>      STMTError(rc); <br>      FreeStmt(SQL_CLOSE,  lpChild);   // Cleanup statement <br>   } <br> <br>   return; <br>} <br> <br> <br>/* Fetch ------------------------------------------------------------------- <br>   Description: Issue fetch request <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC Fetch(LPCHILD lpChild) <br>{ <br>   SQLRETURN rc; <br>   UDWORD    crow; <br>   HCURSOR   hcur; <br>   SDWORD    sdwIrowLast = lpChild-&gt;irow; <br>   SDWORD    sdwRowsAffected; <br>   SDWORD    irow; <br>   UWORD     fFetchType; <br> <br>   static UWORD   fFetchTypeLast = SQL_FETCH_NEXT; <br> <br>   fFetchType = lpChild-&gt;FetchOP; <br>   if (fFetchType == SQL_FETCH_ABSOLUTE) <br>      irow = lpChild-&gt;arow; <br>   else if (fFetchType == SQL_FETCH_RELATIVE) <br>      irow = lpChild-&gt;rrow; <br>   else <br>      irow = 0; <br>   if (!(lpChild-&gt;fResultSetExists)) { <br>      STMTError(SQLRowCount(lpChild-&gt;hstmt, &amp;sdwRowsAffected)); <br> <br>      if (sdwRowsAffected &gt; -1) { <br>         UCHAR szBuffer[200]; <br>         wsprintf(szBuffer, <br>                  (sdwRowsAffected == 1) ? szRowAffected:szDataAffected, <br>                  sdwRowsAffected); <br> <br>         MessageBox(lpChild-&gt;hwnd, <br>                    szBuffer, <br>                    szNoDataTitle, <br>                    MB_ICONINFORMATION); <br>      } <br>      else <br>         { <br>            MessageBox( lpChild-&gt;hwnd, <br>                       szNoDataTitle, <br>                       szNoData, <br>                       MB_ICONINFORMATION); <br>         } <br>      return; <br>   } <br> <br>   hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   SQLSetStmtAttr(lpChild-&gt;hstmt, SQL_ATTR_ROWS_FETCHED_PTR, <br>                  &amp;crow, SQL_IS_POINTER); <br>   SQLSetStmtAttr(lpChild-&gt;hstmt, SQL_ATTR_ROW_STATUS_PTR, <br>                  lpChild-&gt;lpfStatus, SQL_IS_POINTER); <br> <br>   // Call SQLFetchScroll <br>   Async(SQLFetchScroll(lpChild-&gt;hstmt, fFetchType, irow)); <br> <br>   if ((rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) &amp;&amp; <br>       lpChild-&gt;irowPos &gt; crow) { <br>      SetPos(lpChild, (UWORD) crow); <br>   } <br> <br>   if (!STMTError(rc) &amp;&amp; rc != SQL_NO_DATA) { <br> <br>      // Reset columns retrieved count <br>      lpChild-&gt;ccolRetrieved = (UWORD)lpChild-&gt;ccol; <br> <br>      // If this is the first fetch, initialize child variables <br>      if (!lpChild-&gt;fDataFetched) { <br> <br>         lpChild-&gt;fDataFetched = TRUE; <br> <br>         lpChild-&gt;irow    = -((SDWORD)lpChild-&gt;crowRowset); <br>         lpChild-&gt;irowPos = 1; <br> <br>         SetScrollPos(lpChild-&gt;hwndVScroll, SB_CTL, 0, FALSE); <br>         SetScrollPos(lpChild-&gt;hwndHScroll, SB_CTL, 0, FALSE); <br> <br>         SetScroll(lpChild); <br>         AllocClipRgn(lpChild); <br>      } <br> <br>      // Otherwise, maintain current row position in the row-set <br>      else if (lpChild-&gt;fConcurrency != SQL_CONCUR_READ_ONLY &amp;&amp; <br>               lpChild-&gt;crowKeyset != SQL_CURSOR_FORWARD_ONLY) <br>         SetPos(lpChild, lpChild-&gt;irowPos); <br> <br>      // if (fFetchType == SQL_FETCH_RESUME) <br>      //    fFetchType = fFetchTypeLast; <br> <br>      // Adjust absolute row number by fetch amount <br>      switch (fFetchType) { <br>        case SQL_FETCH_FIRST: <br>         lpChild-&gt;irow = 1; <br>         break; <br> <br>        case SQL_FETCH_PRIOR: <br>         lpChild-&gt;irow -= crow; <br>         if (lpChild-&gt;irow &lt; 1) <br>            lpChild-&gt;irow = 1; <br>         break; <br> <br>        case SQL_FETCH_NEXT: <br>         lpChild-&gt;irow += lpChild-&gt;crowCurrent;  // Previous RS <br>         break; <br> <br>        case SQL_FETCH_LAST: { <br>           SDWORD iRowT;   // scratch variable <br> <br>           if (STMTError(SQLGetStmtAttr(lpChild-&gt;hstmt, <br>                                        SQL_ATTR_ROW_NUMBER, <br>                                        &amp;iRowT, <br>                                        SQL_IS_INTEGER, <br>                                        NULL))) { <br>              // the cursor library does not support SQL_ROW_NUMBER, <br>              // so use the following calculation. The  result might <br>              // be incorrect <br>              STMTError(SQLRowCount(lpChild-&gt;hstmt, &amp;iRowT)); <br>              lpChild-&gt;irow += (iRowT - crow); <br>              if (lpChild-&gt;irow &lt; 1) lpChild-&gt;irow = 1; <br> <br>           } <br>           else {    // the cursor library supports SQL_ROW_NUMBER <br>              lpChild-&gt;irow = iRowT; <br>           } <br>        } <br>         break; <br> <br>        case SQL_FETCH_RELATIVE: <br>         lpChild-&gt;irow += irow; <br>         if (lpChild-&gt;irow &lt; 1) <br>            lpChild-&gt;irow = 1; <br>         break; <br> <br>        case SQL_FETCH_ABSOLUTE: <br>         if (irow &gt; 0) <br>            lpChild-&gt;irow = irow; <br>         else { <br>            STMTError(SQLRowCount(lpChild-&gt;hstmt, &amp;lpChild-&gt;irow)); <br>            lpChild-&gt;irow = lpChild-&gt;irow + irow + 1; <br>            if (lpChild-&gt;irow &lt; 1) lpChild-&gt;irow = 1; <br>         } <br>         break; <br>      } <br> <br>      // Repaint window <br>      InvalidateRect(lpChild-&gt;hwnd, NULL, FALSE); <br> <br>      lpChild-&gt;crowCurrent = crow; <br>   } <br> <br>   fFetchTypeLast = fFetchType; <br> <br>   AdjustMenus(); <br>   SetCursor(hcur); <br>   return; <br>} <br> <br> <br>/* FreeStmt ---------------------------------------------------------------- <br>   Description: Free SQLHSTMT and reset associated variables of a child window <br>                NOTE: Only SQL_CLOSE, SQL_DROP, and SQL_UNBIND are valid <br>                --------------------------------------------------------------------------*/ <br>void INTFUNC FreeStmt(UWORD fOption, LPCHILD lpChild) <br>{ <br>   SWORD i; <br>   LPCOL lpcol; <br> <br>   if (!lpChild-&gt;hstmt) <br>      return; <br> <br>   // Issue the real SQLFreeStmt call <br>   if (fOption == SQL_DROP) { <br>      if (STMTError(SQLFreeHandle(SQL_HANDLE_STMT, lpChild-&gt;hstmt))) <br>         return; <br>   } <br>   else { <br>      if (STMTError(SQLFreeStmt(lpChild-&gt;hstmt, fOption))) <br>         return; <br>   } <br> <br>   // Drop data buffers for SQL_DROP and SQL_UNBIND requests <br>   if (fOption == SQL_DROP || fOption == SQL_UNBIND) { <br>      if (!ROW_BINDING(lpChild)) { <br>         for (i=0, lpcol=lpChild-&gt;lpcol; i &lt; lpChild-&gt;ccol; i++, lpcol++) { <br>            FreePtr(lpcol-&gt;lpb);  lpcol-&gt;lpb  = NULL; <br>            FreePtr(lpcol-&gt;lpcb); lpcol-&gt;lpcb = NULL; <br>         } <br>      } <br>      else if (lpChild-&gt;lpb) { <br>         FreePtr(lpChild-&gt;lpb); <br>         lpChild-&gt;lpb = NULL; <br>      } <br>   } <br> <br>   // Only drop memory for SQL_UNBIND requests <br>   if (fOption == SQL_UNBIND) <br>      return; <br> <br>   // Clear SQLHSTMT handle for SQL_DROP <br>   if (fOption == SQL_DROP) <br>      lpChild-&gt;hstmt = SQL_NULL_HSTMT; <br> <br>   // Always reset and free result set related variables <br>   lpChild-&gt;fResultSetExists = FALSE; <br>   lpChild-&gt;ccol         = 0; <br>   lpChild-&gt;fDataFetched = FALSE; <br>   lpChild-&gt;cbrow        = 0; <br>   lpChild-&gt;ccols        = 0; <br> <br> <br>   FreePtr(lpChild-&gt;rglpv);     lpChild-&gt;rglpv     = NULL; <br>   FreePtr(lpChild-&gt;lpnTabs);   lpChild-&gt;lpnTabs   = NULL; <br>   FreePtr(lpChild-&gt;lpcol);     lpChild-&gt;lpcol     = NULL; <br>   FreePtr(lpChild-&gt;lpfStatus); lpChild-&gt;lpfStatus = NULL; <br> <br>   if (lpChild-&gt;hrgn) { <br>      DeleteObject(lpChild-&gt;hrgn); <br>      lpChild-&gt;hrgn = NULL; <br>   } <br> <br>   if (lpChild-&gt;hwnd) { <br>      lpChild-&gt;fVScroll = FALSE; <br>      lpChild-&gt;fHScroll = FALSE; <br> <br>      ShowWindow(lpChild-&gt;hwndVScroll, SW_HIDE); <br>      ShowWindow(lpChild-&gt;hwndHScroll, SW_HIDE); <br>      InvalidateRect(lpChild-&gt;hwnd, NULL, FALSE); <br>   } <br>   return; <br>} <br> <br> <br>/* GetCurrentValue --------------------------------------------------------- <br>   Description: Convert to character and return column data from current <br>                row <br>--------------------------------------------------------------------------*/ <br>#pragma optimize("ceglntw", off) <br>void INTFUNC GetCurrentValue(LPSTR lpsz, LPCOL lpcol, LPCHILD lpChild) <br>{ <br>   LPBYTE      lpb; <br>   SDWORD FAR  *lpcb; <br>   UWORD       irowPos; <br> <br>   irowPos = lpChild-&gt;irowPos - 1; <br> <br>   // Get data and count field pointers based on binding type <br>   if (ROW_BINDING(lpChild)) { <br>      lpb  = lpcol-&gt;lpb + (irowPos * lpChild-&gt;cbrow); <br>      lpcb = (LPSDWORD)(lpb + lpcol-&gt;cb); <br>   } <br>   else { <br>      lpb  = lpcol-&gt;lpb + (irowPos * lpcol-&gt;cb); <br>      lpcb = lpcol-&gt;lpcb + irowPos; <br>   } <br> <br>   // Convert column data to character using the supplied buffer <br>   if (*lpcb == SQL_NULL_DATA) { <br>      lstrcpy(lpsz, g_szNull); <br>      return; <br>   } <br> <br>   switch (lpcol-&gt;fSqlType) { <br> <br>     case SQL_CHAR: <br>     case SQL_VARCHAR: <br>      lstrcpy(lpsz, (LPSTR)lpb); <br>      break; <br> <br>     case SQL_INTEGER: <br>     case SQL_SMALLINT: <br>     case SQL_TINYINT: { <br>        long  l; <br> <br>        l = (lpcol-&gt;fSqlType == SQL_INTEGER <br>             ? *((DWORD FAR *)lpb) <br>             : lpcol-&gt;fSqlType == SQL_SMALLINT <br>             ? *((WORD FAR *)lpb) <br>             : *((UCHAR FAR *)lpb)); <br> <br>        _ltoa(l, lpsz, 10); <br>        break; <br>     } <br> <br>     case SQL_REAL: <br>     case SQL_FLOAT: <br>     case SQL_DOUBLE: { <br>        double   d; <br> <br>        d = (lpcol-&gt;fSqlType == SQL_REAL <br>             ? *((float FAR *)lpb) <br>             : *((double FAR *)lpb)); <br> <br>        _gcvt(d, 15, lpsz); <br>        break; <br>     } <br> <br>     default: <br>      *lpsz = '\0'; <br>      break; <br>   } <br> <br>   return; <br>} <br>#pragma optimize("ceglntw", on) <br> <br> <br>/* GetData ----------------------------------------------------------------- <br>   Description: Retrieve the next unbound column and display the data <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC GetData(LPCHILD lpChild) <br>{ <br>   HCURSOR   hcur; <br>   BIGCOL    bcol; <br>   UWORD     icol; <br>   SQLRETURN rc; <br> <br>   // Prevent Cancel from closing statement <br>   lpChild-&gt;hstmtTmp = lpChild-&gt;hstmt; <br> <br>   // Determine next unbound column index <br>   icol = lpChild-&gt;ccolRetrieved + 1; <br> <br>   hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   // Get column name <br>   Async(SQLColAttribute(lpChild-&gt;hstmt, icol, <br>                         SQL_DESC_NAME, <br>                         bcol.szName, sizeof(bcol.szName), NULL, <br>                         NULL)); <br> <br>   SetCursor(hcur); <br> <br>   if (STMTError(rc)) { <br>      lpChild-&gt;hstmtTmp = SQL_NULL_HSTMT; <br>      return; <br>   } <br> <br>   bcol.lpsz = lpChild-&gt;lpsz; <br> <br>   hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   // Get the data converting it to character <br>   Async(SQLGetData(lpChild-&gt;hstmt, icol, SQL_C_CHAR, <br>                    bcol.lpsz, cbBUFSIZE-1, &amp;bcol.cb)); <br> <br>   SetCursor(hcur); <br> <br>   lpChild-&gt;hstmtTmp = SQL_NULL_HSTMT; <br> <br>   if (STMTError(rc) || rc == SQL_NO_DATA) <br>      return; <br> <br>   // Display the retrieved data <br>   DialogBoxParam(g_hinst, <br>                  MAKEINTRESOURCE(IDD_DATADLG), <br>                  lpChild-&gt;hwnd, <br>                  DataDlgProc, <br>                  (LPARAM)((LPSTR)&amp;bcol)); <br> <br>   lpChild-&gt;ccolRetrieved = icol; <br>   return; <br>} <br> <br> <br>/* GetTableName ------------------------------------------------------------ <br>   Description: Extract table name from a SELECT statement <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC GetTableName(LPSTR lpszTable, LPCSTR szSql) <br>{ <br>   LPCSTR   lpsz; <br>   int      cp; <br>   int      cb; <br> <br>   cb = lstrlen(szFROM); <br> <br>   for (lpsz=szSql, cp=0; *lpsz; ) { <br> <br>      while (*lpsz &amp;&amp; ISWHITE(*lpsz)) lpsz++; <br> <br>      if (!cp &amp;&amp; !_fstrnicmp(lpsz, szFROM, cb) &amp;&amp; ISWHITE(*(lpsz+cb))) <br>         break; <br> <br>      if (ISLPAREN(*lpsz)) <br>         cp++; <br>      else if (ISRPAREN(*lpsz)) <br>         cp--; <br> <br>      while (*lpsz &amp;&amp; !ISWHITE(*lpsz)) lpsz++; <br>   } <br> <br>   while (*lpsz &amp;&amp; !ISWHITE(*lpsz)) lpsz++; <br>   while (*lpsz &amp;&amp; ISWHITE(*lpsz))  lpsz++; <br> <br>   if (*lpsz == *g_szQuoteChar) { <br>      *lpszTable++ = *lpsz++; // Copy beginning quote <br>      while (*lpsz &amp;&amp; *lpsz != *g_szQuoteChar) *lpszTable++ = *lpsz++; <br>      *lpszTable++ = *lpsz++; // Copy ending quote <br>   } <br>   else  // Not a quoted identifier <br>      while (*lpsz &amp;&amp; !ISCOMMA(*lpsz) &amp;&amp; !ISWHITE(*lpsz)) *lpszTable++ = *lpsz++; <br> <br>   *lpszTable = '\0'; <br> <br>   return; <br>} <br> <br> <br>/* IsUpdateable ------------------------------------------------------------ <br>   Description: Return TRUE if this app supports updating the particular <br>                SQL data type (due to limited conversion support) <br>                --------------------------------------------------------------------------*/ <br>BOOL INTFUNC IsUpdateable(SDWORD fSqlType) <br>{ <br>   switch (fSqlType) { <br>     case SQL_CHAR: <br>     case SQL_VARCHAR: <br>     case SQL_SMALLINT: <br>     case SQL_INTEGER: <br>     case SQL_REAL: <br>     case SQL_FLOAT: <br>     case SQL_DOUBLE: <br>     case SQL_TINYINT: <br>      return TRUE; <br> <br>     default: <br>      return FALSE; <br>   } <br>} <br> <br> <br>/* OnDataRow --------------------------------------------------------------- <br>   Description: Return 0 or greater if the mouse coordinates in lparam are <br>                over a valid data row, Otherwise return -1 <br>                --------------------------------------------------------------------------*/ <br>int INTFUNC OnDataRow(LPCHILD lpChild, LPARAM lparam) <br>{ <br>   RECT  rc; <br>   int   row; <br> <br>   if (!(lpChild-&gt;hrgn)) <br>      return -1; <br> <br>   GetRgnBox(lpChild-&gt;hrgn, &amp;rc); <br> <br>   row = (int)HIWORD(lparam) - g_cy; <br> <br>   if (row &lt; 0) <br>      return FALSE; <br> <br>   row /= g_cy; <br> <br>   if (row &gt;= 0                        &amp;&amp; <br>       (UWORD)row &lt; lpChild-&gt;crowRowset ) <br>      return row; <br>   else <br>      return -1; <br>} <br> <br> <br>/* PaintChild -------------------------------------------------------------- <br>   Description: Paint child window <br>--------------------------------------------------------------------------*/ <br>void INTFUNC PaintChild(LPCHILD  lpChild, <br>                        HDC      hdc, <br>                        BOOL  fTitle, <br>                        BOOL  fRefresh, <br>                        BOOL  fActive) <br>{ <br>   RECT  rc; <br> <br>   GetClientRect(lpChild-&gt;hwnd, &amp;rc); <br> <br>   // If no data exists, just erase the window <br>   if (!lpChild-&gt;fDataFetched) <br>      FillRect(hdc, &amp;rc, g_hbrWin); <br> <br>   // Otherwise paint the data in a simple scrollable grid <br>   else { <br>      HRGN     hrgn; <br>      HFONT    hfontOld; <br>      HBRUSH   hbrOld; <br>      UWORD    ir; <br>      int      ic; <br>      int      icFirst, icLast; <br>      LPCOL    lpcol; <br>      UWORD    row; <br>      int      col; <br>      int      cx, cy; <br>      LPINT    lpnTab; <br>      LPSTR    lpszValues; <br>      LPSTR    lpsz; <br>      LPUWORD  lpfStatus; <br>      UWORD    irowLast; <br>      UWORD    irowPos; <br>      COLORREF clrfTxt; <br>      COLORREF clrfBkg; <br>      char     szFmt[cbSTRLEN]; <br> <br>      // Prepare the device context <br>      SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br> <br>      clrfTxt = GetTextColor(hdc); <br>      clrfBkg = GetBkColor(hdc); <br> <br>      // Determine first (row,col) and corresponding (x,y) offset <br>      row = (UWORD)GetScrollPos(lpChild-&gt;hwndVScroll, SB_CTL); <br>      col = GetScrollPos(lpChild-&gt;hwndHScroll, SB_CTL); <br> <br>      cx = col * g_cx; <br>      cy = row * g_cy; <br> <br>      // Determine last row to be painted <br>      irowLast = (UWORD)row + ((UWORD)lpChild-&gt;crowwin &lt; lpChild-&gt;crowRowset <br>                               ? lpChild-&gt;crowwin <br>                               : lpChild-&gt;crowRowset); <br>      if (irowLast &gt; lpChild-&gt;crowRowset) <br>         irowLast--; <br> <br>      // Get current row number as a zero based index <br>      irowPos  = lpChild-&gt;irowPos - 1; <br> <br>      // Determine which columns will be painted <br>      lpnTab = lpChild-&gt;lpnTabs; <br>      for (icFirst=0; <br>           icFirst &lt; (lpChild-&gt;ccol-1) &amp;&amp; (cx + cxBORDER) &gt; *(lpnTab+1); <br>           icFirst++, lpnTab++); <br>      for (icLast=icFirst+1; <br>           icLast &lt; lpChild-&gt;ccol &amp;&amp; <br>           (cx + cxBORDER + (lpChild-&gt;ccolwin * g_cx)) &gt; *lpnTab; <br>           icLast++, lpnTab++); <br> <br>      // Offset the device context to appropriate position in the rowset <br>      SetWindowOrgEx(hdc, cx, cy, NULL); <br> <br>      // Set the clip region (to keep from erasing scroll bars, etc.) <br> <br>      if (!(lpChild-&gt;hrgn)) <br>         return; <br> <br>      SelectClipRgn(hdc, lpChild-&gt;hrgn); <br> <br>      // Allocate working buffer to converted data values <br>      lpszValues = AllocPtr((DWORD) lpChild-&gt;ccol * cbSTRLEN); <br> <br>      // If requested, paint column titles <br>      if (fTitle) { <br> <br>         // Prepare device context <br>         SetBkColor(hdc, GetSysColor(COLOR_BTNFACE)); <br>         hfontOld = SelectObject(hdc, g_hfontName); <br> <br>         // Determine bounding rectangle in logical coordinates <br>         rc.top    = cy; <br>         rc.bottom = rc.top + g_cy; <br>         rc.left   = *(lpChild-&gt;lpnTabs + icFirst) - cxBORDER; <br>         rc.right  = *(lpChild-&gt;lpnTabs + icLast)  - cxBORDER; <br> <br>         // Fill rectangle with appropriate color <br>         FillRect(hdc, &amp;rc, g_hbrBtn); </code></pre>
<p>
</p>
<pre><code><br>         // Paint white bar across the top <br>         PatBlt(hdc, 0, rc.top, rc.right, 1, WHITENESS); <br> <br>         // For each visible (or partially visible) column, paint <br>         // separating lines and column name <br>         lpcol  = lpChild-&gt;lpcol   + icFirst; <br>         lpnTab = lpChild-&gt;lpnTabs + icFirst + 1; <br> <br>         for (ic=icFirst; ic &lt; icLast; ic++, lpcol++, lpnTab++) { <br> <br>            PatBlt(hdc, rc.left, rc.top, 1, g_cy, WHITENESS); <br> <br>            rc.right = *lpnTab - cxBORDER + 1; <br> <br>            DrawText(hdc, lpcol-&gt;szName, lstrlen(lpcol-&gt;szName), <br>                     &amp;rc, DT_CENTER | DT_SINGLELINE | DT_VCENTER); <br> <br>            rc.left = rc.right; <br> <br>            PatBlt(hdc, rc.left-1, rc.top, 1, g_cy, BLACKNESS); <br>         } <br> <br>         // Paint black line across the bottom <br>         PatBlt(hdc, 1, rc.bottom-1, rc.right-1, 1, BLACKNESS); <br> <br>         // Reset device context <br>         SelectObject(hdc, hfontOld); <br>         SetBkColor(hdc, clrfBkg); <br>      } <br> <br>      // Determine bounding rectangle for first row to be painted <br>      rc.top    = cy + g_cy; <br>      rc.bottom = rc.top + g_cy - 1; <br>      rc.left   = *(lpChild-&gt;lpnTabs + icFirst) - cxBORDER; <br>      rc.right  = *(lpChild-&gt;lpnTabs + icLast)  - cxBORDER; <br> <br>      // Make format string from the whole format string created earlier <br>#ifdef WIN32 <br>      _fstrncpy(szFmt, lpChild-&gt;szFmt+(icFirst*3), ((icLast-icFirst)*3)+1); <br>#else <br>      lstrcpyn(szFmt, lpChild-&gt;szFmt+(icFirst*3), ((icLast-icFirst)*3)+1); <br>#endif <br>      szFmt[((icLast-icFirst)*3)+1] = '\0'; <br> <br>      // Offset into the row status array <br>      lpfStatus = lpChild-&gt;lpfStatus + row; <br> <br>      // Prepare device context <br>      hfontOld = SelectObject(hdc, g_hfontData); <br>      hbrOld   = SelectObject(hdc, g_hbrBtn); <br> <br>      // Paint each row <br>      for (ir=row; ir &lt; irowLast; ir++) { <br> <br>         // Erase row if requested (i.e., !fRefresh) or if just <br>         // painting the row is insufficient to remove old data <br>         if (!fRefresh                   || <br>             (ir == irowPos &amp;&amp; !fActive) || <br>             *lpfStatus == SQL_ROW_NOROW || <br>             *lpfStatus == SQL_ROW_ERROR || <br>             *lpfStatus == SQL_ROW_DELETED) <br>            FillRect(hdc, &amp;rc, g_hbrWin); <br> <br>         // For an empty row, write the empty row string <br>         if (*lpfStatus == SQL_ROW_NOROW) { <br>            if (icFirst) <br>               *lpChild-&gt;lpsz = '\0'; <br>            else <br>               lstrcpy(lpChild-&gt;lpsz, g_szNoRow); <br>         } <br> <br>         // For a deleted row, write the deleted row string <br>         else if (*lpfStatus == SQL_ROW_DELETED) { <br>            if (icFirst) <br>               *lpChild-&gt;lpsz = '\0'; <br>            else <br>               lstrcpy(lpChild-&gt;lpsz, g_szRowDeleted); <br>         } <br> <br>         // For an error row, write the error row string <br>         else if (*lpfStatus == SQL_ROW_ERROR) { <br>            if (icFirst) <br>               *lpChild-&gt;lpsz = '\0'; <br>            else <br>               lstrcpy(lpChild-&gt;lpsz, g_szRowError); <br>         } <br> <br>         // For all other rows, build a string of data values <br>         else { <br>            LPSTR FAR   *lplpsz; <br>            LPBYTE      lpb; <br>            LPSDWORD lpcb; <br>        <br> <br>            // Paint updated rows in RED <br>            if (*lpfStatus == SQL_ROW_UPDATED) <br>               SetTextColor(hdc, RGB(255,0,0)); <br> <br>                                <br>            lplpsz = (LPSTR FAR *)lpChild-&gt;rglpv; <br>                                <br>            lpsz   = lpszValues; <br> <br>            lpcol  = lpChild-&gt;lpcol   + icFirst; <br>            lpnTab = lpChild-&gt;lpnTabs + icFirst; <br> <br>            // Convert each column to character data <br>            for (ic=icFirst; ic &lt; icLast; ic++, lpcol++) { <br> <br>               lpb  = lpcol-&gt;lpb  + (ir * (ROW_BINDING(lpChild) <br>                                           ? lpChild-&gt;cbrow <br>                                           : lpcol-&gt;cb)); <br>               lpcb = (ROW_BINDING(lpChild) <br>                       ? (LPSDWORD)(lpb + lpcol-&gt;cb) <br>                       : lpcol-&gt;lpcb + ir); <br> <br>               if (*lpcb == SQL_NULL_DATA) <br>                  *lplpsz++ = g_szNull; <br> <br>               else if (lpcol-&gt;fCType == SQL_C_CHAR) <br>                  *lplpsz++ = (LPSTR)lpb; <br> <br>               else { <br> <br>                  if (lpcol-&gt;fCType == SQL_C_FLOAT || <br>                      lpcol-&gt;fCType == SQL_C_DOUBLE ) { <br>                     double   d; <br> <br>                     d = (lpcol-&gt;fCType == SQL_C_FLOAT <br>                          ? *((float FAR *)lpb) <br>                          : *((double FAR *)lpb)); <br> <br>                     _gcvt(d, 15, lpsz); <br>                  } <br> <br>                  else { <br>                     long  l; <br> <br>                     l = ( lpcol-&gt;fCType == SQL_C_SHORT <br>                          ? *((short FAR *)lpb) <br>                          : lpcol-&gt;fCType == SQL_C_LONG <br>                          ? *((long FAR *)lpb) <br>                          : *((signed char FAR *)lpb)); <br> <br>                     _ltoa(l, lpsz, 10); <br>                  } <br> <br>                  *lplpsz++ = lpsz; <br>                  lpsz += cbSTRLEN; <br>               } <br>            } <br> <br>            // Combine all columns into one string (with tab markers) <br>Print(lpChild-&gt;lpsz, szFmt, lpChild-&gt;rglpv ); <br> <br> <br> <br>         } <br> <br>         // Paint the row <br>         TabbedTextOut(hdc, <br>                       rc.left, rc.top, <br>                       lpChild-&gt;lpsz, lstrlen(lpChild-&gt;lpsz), <br>                       icLast - icFirst, lpnTab, 0); <br> <br>         // Paint bottom separator <br>         PatBlt(hdc, 0, rc.bottom, rc.right, 1, PATCOPY); <br> <br>         // Paint inter-column separators <br>         lpnTab = lpChild-&gt;lpnTabs + icFirst + 1; <br>         for (ic=icFirst+1; ic &lt; (icLast+1); ic++, lpnTab++) <br>            PatBlt(hdc, *lpnTab-cxBORDER, rc.top, 1, g_cy, PATCOPY); <br> <br>         // Reset text color (if it was changed) <br>         if (*lpfStatus == SQL_ROW_UPDATED) <br>            SetTextColor(hdc, clrfTxt); <br> <br>         // Hilite the current row <br>         if (ir == irowPos                                 &amp;&amp; <br>             lpChild-&gt;fConcurrency != SQL_CONCUR_READ_ONLY &amp;&amp; <br>             fActive                                        ) { <br>            RECT  rcTemp, rcInvert; <br> <br>            GetClipBox(hdc, &amp;rcTemp); <br> <br>            IntersectRect(&amp;rcInvert, &amp;rc, &amp;rcTemp); <br> <br>            GetClientRect(lpChild-&gt;hwnd, &amp;rcTemp); <br> <br>            if( rcInvert.top == rc.top ) <br>               rcInvert.top++; <br> <br>            if( rcInvert.bottom == rc.bottom ) <br>               rcInvert.bottom--; <br> <br>            if( rcInvert.left == rcTemp.left ) <br>               rcInvert.left++; <br> <br>            if( rcInvert.right == rcTemp.right || <br>               rcInvert.right == rc.right ) <br>               rcInvert.right--; <br> <br>            InvertRect(hdc, &amp;rcInvert); <br>         } <br> <br>         // Advance row rectangle and status array offset <br>         rc.top    += g_cy; <br>         rc.bottom += g_cy; <br>         lpfStatus++; <br>      } <br> <br>      // Erase any partial row which may be displayed after the last <br>      // row of the row-set has been painted <br>      if (ir == lpChild-&gt;crowRowset) <br>         FillRect(hdc, &amp;rc, g_hbrWin); <br> <br>      // Erase any partial column which may be displayed after the last <br>      // column has been painted <br>      if (icLast == lpChild-&gt;ccol) { <br>         GetClipBox(hdc, &amp;rc); <br>         rc.left = *(lpChild-&gt;lpnTabs + icLast) - cxBORDER + 1; <br>         FillRect(hdc, &amp;rc, g_hbrWin); <br>      } <br> <br>      FreePtr(lpszValues); <br> <br>      // Reset clip region to paint areas outside data grid <br>      GetClientRect(lpChild-&gt;hwnd, &amp;rc); <br> <br>      hrgn = CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom); <br> <br>      SelectClipRgn(hdc, hrgn); <br> <br>      OffsetRect(&amp;rc, cx, cy); <br> <br>      // Paint bottom record display bar and/or the corner box <br>      // between the scroll bars <br>      rc.top = rc.bottom - g_cyHScroll + 1; <br> <br>      PatBlt(hdc, rc.left, rc.top, rc.right, 1, BLACKNESS); <br> <br>      SelectObject(hdc, g_hbrScroll); <br> <br>      rc.top++; <br> <br>      cx = (2 * cxBORDER) + g_cxRecord + g_cxRecnum + 2; <br> <br>      if (lpChild-&gt;fHScroll) { <br>         if (lpChild-&gt;fVScroll) <br>            PatBlt(hdc, <br>                   rc.right - g_cxVScroll + 2, rc.top, <br>                   g_cxVScroll, g_cyHScroll, <br>                   PATCOPY); <br>      } <br>      else <br>         PatBlt(hdc, <br>                rc.left + cx, rc.top, <br>                rc.right - rc.left, g_cyHScroll, <br>                PATCOPY); <br> <br>      rc.right = rc.left + cx; <br> <br>      PatBlt(hdc, rc.right, rc.top, 1, rc.bottom, BLACKNESS); <br> <br>      rc.right--; <br> <br>      // Paint current row number <br>      if (fRefresh) <br>         FillRect(hdc, &amp;rc, g_hbrWin); <br> <br>      rc.left += cxBORDER; <br> <br>      TextOut(hdc, rc.left, rc.top, szRECORD, lstrlen(szRECORD)); <br> <br>      rc.left += g_cxRecord + 2; <br> <br>      FillRect(hdc, &amp;rc, g_hbrWin); <br> <br>      wsprintf(lpChild-&gt;lpsz, szRECNUM, lpChild-&gt;irow-1 + lpChild-&gt;irowPos); <br> <br>      TextOut(hdc, rc.left, rc.top, lpChild-&gt;lpsz, lstrlen(lpChild-&gt;lpsz)); <br> <br>      DeleteObject(hrgn); <br> <br>      // Reset device context <br>      SelectObject(hdc, hbrOld); <br> <br>      SelectObject(hdc, hfontOld); <br>   } <br> <br>   return; <br>} <br> <br> <br> <br>/* SetCurrentValue --------------------------------------------------------- <br>   Description: Set a column value from the user buffer <br>--------------------------------------------------------------------------*/ <br>#pragma optimize("ceglntw", off) <br>BOOL INTFUNC SetCurrentValue(LPSTR lpsz, LPCOL lpcol, LPCHILD lpChild) <br>{ <br>   LPBYTE   lpb; <br>   LPSDWORD lpcb; <br>   BOOL     fNew; <br>   UWORD    irowPos; <br> <br>   irowPos = lpChild-&gt;irowPos - 1; <br> <br>   // Get data and count field pointers based on binding type <br>   if (ROW_BINDING(lpChild)) { <br>      lpb  = lpcol-&gt;lpb + (irowPos * lpChild-&gt;cbrow); <br>      lpcb = (LPSDWORD)(lpb + lpcol-&gt;cb); <br>   } <br>   else { <br>      lpb  = lpcol-&gt;lpb + (irowPos * lpcol-&gt;cb); <br>      lpcb = lpcol-&gt;lpcb + irowPos; <br>   } <br> <br>   // If the data is NULL, just set the count field to SQL_NULL_DATA <br>   if (!lstrcmpi(lpsz, g_szNull)) { <br>      if (*lpcb != SQL_NULL_DATA) { <br>         *lpcb = SQL_NULL_DATA; <br>         fNew  = TRUE; <br>      } <br>   } <br> <br>   // Otherwise, convert the character data back to the appropriate type <br>   else switch (lpcol-&gt;fSqlType) { <br> <br>     case SQL_CHAR: <br>     case SQL_VARCHAR: <br>      if (lstrcmp(lpsz, (LPSTR)lpb)) { <br>         lstrcpy((LPSTR)lpb, lpsz); <br>         *lpcb = lstrlen(lpsz); <br>         fNew  = TRUE; <br>      } <br>      break; <br> <br>     case SQL_INTEGER: <br>     case SQL_SMALLINT: <br>     case SQL_TINYINT: { <br>        long  lNew, lCur; <br>        char  *EndPtr; <br> <br>        lNew = strtol(lpsz, &amp;EndPtr, 10); <br>        for (; *EndPtr &amp;&amp; ISWHITE(*EndPtr); EndPtr = AnsiNext(EndPtr)); <br>        if (*EndPtr)  { // check to see if there exists non-numeric chars <br>           UCHAR szBuffer[128]; <br> <br>           LoadString(g_hinst, IDS_BADNUMERIC, szBuffer, sizeof(szBuffer)); <br>           MessageBox(lpChild-&gt;hwnd, <br>                      szBuffer, NULL, MB_ICONSTOP); <br>           fNew = FALSE; <br>           break; <br>        } <br> <br>        lCur = (lpcol-&gt;fSqlType == SQL_INTEGER <br>                ? *((DWORD FAR *)lpb) <br>                : lpcol-&gt;fSqlType == SQL_SMALLINT <br>                ? *((WORD FAR *)lpb) <br>                : *((UCHAR FAR *)lpb)); <br> <br>        if (lNew != lCur) { <br> <br>           switch (lpcol-&gt;fSqlType) { <br>             case SQL_INTEGER: <br>              *((DWORD FAR *)lpb) = lNew; <br>              *lpcb = sizeof(DWORD); <br>              break; <br> <br>             case SQL_SMALLINT: <br>              *((WORD FAR *)lpb) = (WORD)lNew; <br>              *lpcb = sizeof(WORD); <br>              break; <br> <br>             case SQL_TINYINT: <br>              *((UCHAR FAR *)lpb) = (UCHAR)lNew; <br>              *lpcb = sizeof(UCHAR); <br>              break; <br>           } <br> <br>           fNew = TRUE; <br>        } <br>        break; <br>     } <br> <br>     case SQL_REAL: <br>     case SQL_FLOAT: <br>     case SQL_DOUBLE: { <br>        double   dNew, dCur; <br>        char  *EndPtr; <br> <br>        dNew = strtod(lpsz, &amp;EndPtr); <br>        for (; *EndPtr &amp;&amp; ISWHITE(*EndPtr); EndPtr = AnsiNext(EndPtr)); <br>        if (*EndPtr)  { // check to see if there exists non-numeric chars <br>           UCHAR szBuffer[128]; <br> <br>           LoadString(g_hinst, IDS_BADNUMERIC, szBuffer, sizeof(szBuffer)); <br>           MessageBox(lpChild-&gt;hwnd, <br>                      szBuffer, NULL, MB_ICONSTOP); <br>           fNew = FALSE; <br>           break; <br>        } <br> <br>        dCur = (lpcol-&gt;fSqlType == SQL_REAL <br>                ? *((float FAR *)lpb) <br>                : *((double FAR *)lpb)); <br> <br>        if (dNew != dCur) { <br> <br>           switch (lpcol-&gt;fSqlType) { <br>             case SQL_REAL: <br>              *((float FAR *)lpb) = (float)dNew; <br>              *lpcb = sizeof(float); <br>              break; <br> <br>             case SQL_FLOAT: <br>             case SQL_DOUBLE: <br>              *((double FAR *)lpb) = dNew; <br>              *lpcb = sizeof(double); <br>              break; <br>           } <br> <br>           fNew = TRUE; <br>        } <br>        break; <br>     } <br>   } <br> <br>   return fNew; <br>} <br>#pragma optimize("ceglntw", on) <br> <br> <br>/* SetPos ------------------------------------------------------------------ <br>   Description: Set current row, de-hilite last current row and hilite <br>                new current row <br>                --------------------------------------------------------------------------*/ <br>void INTFUNC SetPos(LPCHILD lpChild, UWORD irowPos) <br>{ <br>   HDC      hdc; <br>   HFONT    hfont; <br>   RECT     rc, rcClip, rcInvert; <br>   int      row, col; <br>   int      cx, cy; <br> <br>   if (!(lpChild-&gt;hrgn)) <br>      return ; <br> <br>   if (irowPos &lt; 1) <br>      irowPos = 1; <br> <br>   else if (irowPos &gt; lpChild-&gt;crowRowset) <br>      irowPos = lpChild-&gt;crowRowset; <br> <br>   // Call SQLSetPos to set current row in the row-set <br>   if (STMTError(SQLSetPos(lpChild-&gt;hstmt, irowPos, SQL_POSITION, <br>                           SQL_LOCK_NO_CHANGE))) <br>      return; <br> <br>   // Reset number of columns retrieved <br>   lpChild-&gt;ccolRetrieved = (UWORD)lpChild-&gt;ccol; <br> <br>   // Obtain a device context for painting <br>   hdc = GetDC(lpChild-&gt;hwnd); <br> <br>   row = GetScrollPos(lpChild-&gt;hwndVScroll, SB_CTL); <br>   col = GetScrollPos(lpChild-&gt;hwndHScroll, SB_CTL); <br> <br>   cx  = col * g_cx; <br>   cy  = row * g_cy; <br> <br>   SetWindowOrgEx(hdc, cx, cy, NULL); <br> <br>   GetClientRect(lpChild-&gt;hwnd, &amp;rc); <br>   GetRgnBox(lpChild-&gt;hrgn, &amp;rcClip); <br>   OffsetRect(&amp;rcClip, cx, cy); <br> <br>   rcClip.top += g_cy; <br> <br>   // Offset to last current row <br>   rc.top    = ((lpChild-&gt;irowPos - 1) * g_cy) + g_cy; <br>   rc.bottom = rc.top + g_cy - 1; <br>   rc.left   = 0; <br>   rc.right  = *(lpChild-&gt;lpnTabs + lpChild-&gt;ccol) - cxBORDER; <br> <br>   // De-hilite last current row <br>   IntersectRect(&amp;rcInvert, &amp;rc, &amp;rcClip); <br>   InflateRect(&amp;rcInvert, -1, -1); <br>   InvertRect(hdc, &amp;rcInvert); <br> <br>   // Save new current row <br>   lpChild-&gt;irowPos = irowPos; <br> <br>   // Offset to new current row <br>   rc.top    = ((lpChild-&gt;irowPos - 1) * g_cy) + g_cy; <br>   rc.bottom = rc.top + g_cy - 1; <br> <br>   // Hilite current row (if visible) <br>   if (lpChild-&gt;irowPos &gt; (UWORD)row) { <br> <br>      IntersectRect(&amp;rcInvert, &amp;rc, &amp;rcClip); <br>      InflateRect(&amp;rcInvert, -1, -1); <br>      InvertRect(hdc, &amp;rcInvert); <br>   } <br> <br>   // Update record number <br>   GetClientRect(lpChild-&gt;hwnd, &amp;rc); <br>   OffsetRect(&amp;rc, cx, cy); <br> <br>   rc.left += cxBORDER + g_cxRecord + 2; <br>   rc.top   = rc.bottom - g_cyHScroll + 2; <br>   rc.right = rc.left + g_cxRecnum; <br> <br>   FillRect(hdc, &amp;rc, g_hbrWin); <br> <br>   wsprintf(lpChild-&gt;lpsz, szRECNUM, lpChild-&gt;irow-1 + lpChild-&gt;irowPos); <br> <br>   hfont = SelectObject(hdc, g_hfontData); <br> <br>   TextOut(hdc, rc.left, rc.top, lpChild-&gt;lpsz, lstrlen(lpChild-&gt;lpsz)); <br> <br>   SelectObject(hdc, hfont); <br> <br>   // Release device context <br>   ReleaseDC(lpChild-&gt;hwnd, hdc); <br> <br>   return; <br>} <br> <br> <br>/* SetScroll --------------------------------------------------------------- <br>   Description: Determine if scroll bars are required and their ranges <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC SetScroll(LPCHILD lpChild) <br>{ <br>   RECT  rc; <br>   int   cx, cy; <br>   int   row, col; <br> <br>   // Use the fInSetScroll flag to prevent recursion due WM_SIZE messages <br>   if (lpChild-&gt;fInSetScroll) <br>      return; <br> <br>   lpChild-&gt;fInSetScroll = TRUE; <br> <br>   // Save current scroll positions <br>   row = GetScrollPos(lpChild-&gt;hwndVScroll, SB_CTL); <br>   col = GetScrollPos(lpChild-&gt;hwndHScroll, SB_CTL); <br> <br>   // Get window dimensions <br>   GetClientRect(lpChild-&gt;hwnd, &amp;rc); <br>   cx = rc.right - rc.left; <br>   cy = rc.bottom - rc.top - g_cy - g_cyHScroll; <br> <br>   // Assume no scrolling is required <br>   lpChild-&gt;fHScroll = <br>      lpChild-&gt;fVScroll = FALSE; <br> <br>   // Include a vertical scroll bar if all rows do not fit <br>   lpChild-&gt;crowwin = cy / g_cy; <br>   if ((UWORD)lpChild-&gt;crowwin &lt; lpChild-&gt;crowRowset) { <br>      lpChild-&gt;fVScroll = TRUE; <br>      cx -= g_cxVScroll; <br>   } <br> <br>   // Include a horizontal scroll bar if all columns do not fit <br>   lpChild-&gt;ccolwin = cx / g_cx; <br>   if (lpChild-&gt;ccolwin &lt; lpChild-&gt;ccols) <br>      lpChild-&gt;fHScroll = TRUE; <br> <br>   // Reset scroll positions if no scrolling is necessary <br>   if (!lpChild-&gt;fVScroll) row = 0; <br>   if (!lpChild-&gt;fHScroll) col = 0; <br> <br>   // Set scroll ranges, positions, and scroll bar visibility <br>   SetScrollRange(lpChild-&gt;hwndVScroll, SB_CTL, 0, lpChild-&gt;crowRowset - lpChild-&gt;crowwin, TRUE); <br>   SetScrollRange(lpChild-&gt;hwndHScroll, SB_CTL, 0, lpChild-&gt;ccols - lpChild-&gt;ccolwin,      TRUE); <br> <br>   SetScrollPos(lpChild-&gt;hwndVScroll, SB_CTL, row, TRUE); <br>   SetScrollPos(lpChild-&gt;hwndHScroll, SB_CTL, col, TRUE); <br> <br>   ShowWindow(lpChild-&gt;hwndVScroll, (lpChild-&gt;fVScroll ? SW_SHOW : SW_HIDE)); <br>   ShowWindow(lpChild-&gt;hwndHScroll, (lpChild-&gt;fHScroll ? SW_SHOW : SW_HIDE)); <br> <br>   // Add one extra to window depth so no white space is left between <br>   // the last full row and bottom record display bar <br>   lpChild-&gt;crowwin++; <br> <br>   // Size and position scroll bars <br>   SizeScroll(lpChild); <br> <br>   lpChild-&gt;fInSetScroll = FALSE; <br> <br>   return; <br>} <br> <br> <br>/* SizeScroll -------------------------------------------------------------- <br>   Description: Size and position scroll bars <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC SizeScroll(LPCHILD lpChild) <br>{ <br>   RECT  rc; <br>   int   cxRecord; <br> <br>   GetClientRect(lpChild-&gt;hwnd, &amp;rc); <br> <br>   // Place vertical scroll bar <br>   MoveWindow(lpChild-&gt;hwndVScroll, <br>              rc.right - g_cxVScroll + 1, <br>              rc.top, <br>              g_cxVScroll, <br>              rc.bottom - g_cyHScroll + 2, <br>              TRUE); <br> <br>   // Place horizontal scroll bar <br>   cxRecord = (2 * cxBORDER) + g_cxRecord + g_cxRecnum + 2; <br> <br>   MoveWindow(lpChild-&gt;hwndHScroll, <br>              rc.left + cxRecord, <br>              rc.bottom - g_cyHScroll + 1, <br>              (lpChild-&gt;fVScroll <br>               ? rc.right - g_cxVScroll + 2 - cxRecord <br>               : rc.right + 2 - cxRecord), <br>              g_cyHScroll, <br>              TRUE); <br> <br>   return; <br>} <br> <br> <br>/* UpdateRow --------------------------------------------------------------- <br>   Description: Update current (positioned) row <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC UpdateRow(LPCHILD lpChild) <br>{ <br>   HCURSOR  hcur; <br>   LPSTR    lpsz; <br>   LPSTR    lpszT; <br>   SWORD    cb; <br>   LPCOL    lpcol; <br>   int      cCtls; <br>   UWORD    irowPos; <br>   int      i; <br> <br>   // Ensure the update request is valid <br>   if (!lpChild-&gt;fDataFetched) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_NODATAFETCHED); <br>      return; <br>   } <br> <br>   if (*(lpChild-&gt;lpfStatus + lpChild-&gt;irowPos - 1) == SQL_ROW_NOROW) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_NOROWUPDATE); <br>      return; <br>   } <br> <br>   if (*(lpChild-&gt;lpfStatus + lpChild-&gt;irowPos - 1) == SQL_ROW_ERROR) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_ERRORROWUPDATE); <br>      return; <br>   } <br> <br>   if (*(lpChild-&gt;lpfStatus + lpChild-&gt;irowPos - 1) == SQL_ROW_DELETED) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_DELROWUPDATE); <br>      return; <br>   } <br> <br>   if (lpChild-&gt;fConcurrency == SQL_CONCUR_READ_ONLY) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_NOUPDATE); <br>      return; <br>   } <br> <br>   // Count number of updateable columns <br>   for (cCtls=0, i=0, lpcol=lpChild-&gt;lpcol; i &lt; lpChild-&gt;ccol; i++, lpcol++) <br>      if (IsUpdateable(lpcol-&gt;fSqlType)) <br>         cCtls++; <br> <br>   // Ensure a valid number of updateable columns exist <br>   if (cCtls &gt; cMAXCOLS) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_TOOMANYCOLS); <br>      return; <br>   } <br> <br>   if (!cCtls) { <br>      DoMessage(lpChild-&gt;hwnd, IDS_CANNOTUPDATE); <br>      return; <br>   } <br> <br>   hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   lpsz  = AllocPtr(2 * cbMAXSQL); <br>   lpszT = lpsz + cbMAXSQL; <br> <br>   // Build and display update dialog to get new values, then issue update <br>   // (use a temporary SQLHSTMT for the update request) <br>   if (IDOK == DoDialog(lpChild-&gt;hwnd, IDD_UPDATEROW, UpdateDlgProc) &amp;&amp; <br>       !DBCError(lpChild-&gt;hwnd, SQLAllocHandle(SQL_HANDLE_STMT,g_hdbc, &amp;lpChild-&gt;hstmtTmp))) { <br> <br>      // Build UPDATE &lt;table&gt; WHERE CURRENT OF &lt;cursor name&gt; statement <br>      lstrcpy(lpsz, szUPDATE); <br> <br>      GetTableName(lpszT, lpChild-&gt;sql); <br>      lstrcat(lpsz, lpszT); <br> <br>      // Build the Set Clause <br>      lstrcat(lpsz, szSET); <br>      for (lpcol = lpChild-&gt;lpcol, i = 0; i &lt; lpChild-&gt;ccol; i++, lpcol++) { <br>         if (IsUpdateable(lpcol-&gt;fSqlType)) { <br>            LPSDWORD lpcb; <br>            LPBYTE   lpb; <br> <br>            if (i == 0) wsprintf(lpszT, "%s=?", lpcol-&gt;szName); <br>            else wsprintf(lpszT, ",%s=?", lpcol-&gt;szName); <br>            lstrcat(lpsz, lpszT); <br> <br>            irowPos = lpChild-&gt;irowPos - 1; <br> <br>            // Get data and count field pointers based on binding type <br>            if (ROW_BINDING(lpChild)) { <br>               lpb  = lpcol-&gt;lpb + (irowPos * lpChild-&gt;cbrow); <br>               lpcb = (LPSDWORD)(lpb + lpcol-&gt;cb); <br>            } <br>            else { <br>               lpb  = lpcol-&gt;lpb + (irowPos * lpcol-&gt;cb); <br>               lpcb = lpcol-&gt;lpcb + irowPos; <br>            } <br> <br>            // set parameter <br>            ODBCError(lpChild-&gt;hwnd, SQL_HANDLE_STMT, lpChild-&gt;hstmtTmp, <br>                      SQLSetParam(lpChild-&gt;hstmtTmp, (UWORD) (i+1), lpcol-&gt;fCType, <br>                                  lpcol-&gt;fSqlType, (UDWORD) lpcol-&gt;cb, (SWORD) 0, <br>                                  lpb, lpcb)); <br>         } <br>      } <br> <br>      lstrcat(lpsz, szWHERE); <br> <br>      lpszT = lpsz + lstrlen(lpsz); <br> <br>      if (!STMTError(SQLGetCursorName(lpChild-&gt;hstmt, (UCHAR FAR *)lpszT, <br>                                      cbMAXSQL, &amp;cb))) { <br> <br>         // Issue update request via SQLExecDirect <br>         ODBCError(lpChild-&gt;hwnd, SQL_HANDLE_STMT, lpChild-&gt;hstmtTmp, <br>                   SQLExecDirect(lpChild-&gt;hstmtTmp, (UCHAR FAR *)lpsz, SQL_NTS)); <br>      } <br> <br>      DBCError(lpChild-&gt;hwnd, SQLFreeHandle(SQL_HANDLE_STMT,lpChild-&gt;hstmtTmp)); <br>      lpChild-&gt;hstmtTmp = SQL_NULL_HSTMT; <br> <br>   } <br> <br>   // Refresh entire row-set buffer (saving current row position) <br>   irowPos = lpChild-&gt;irowPos; <br> <br>   lpChild-&gt;FetchOP = SQL_FETCH_RELATIVE; <br>   lpChild-&gt;rrow = 0; <br>   Fetch(lpChild); <br> <br>   SetPos(lpChild, irowPos); <br> <br>   // Repaint the row-set <br>   InvalidateRect(lpChild-&gt;hwnd, NULL, FALSE); <br> <br>   FreePtr(lpsz); <br> <br>   SetCursor(hcur); <br> <br>   return; <br>} <br> <br>/*-------------------------------------------------------------------- <br>Input:  lpChild <br>Output: TRUE if the option parameters are valid, FALSE otherwise <br>--------------------------------------------------------------------*/ <br>BOOL INTFUNC ParamValid(LPCHILD lpChild) <br>{ <br>   char szBuffer[128]; // error message <br>   char *EndMaxBind, *EndRowset, *EndBind; <br> <br>   // the maximum column width <br>   wsprintf((LPSTR) szBuffer, <br>            "Maximum column width must be at least 1 and at most %d", <br>            MAX_MAXBIND); <br> <br>   if (lpChild-&gt;fMaxBind) { // it's been changed <br>      lpChild-&gt;crowMaxBind = <br>         (SDWORD) strtol((char*) lpChild-&gt;szMaxBind, &amp;EndMaxBind, 10); <br>      for (; *EndMaxBind &amp;&amp; ISWHITE(*EndMaxBind); <br>           EndMaxBind = AnsiNext(EndMaxBind)); <br>   } <br> <br>   if (lpChild-&gt;fBind) {  // cBind has been changed <br>      lpChild-&gt;cBind =  (UWORD) strtol((char*) lpChild-&gt;szBind, &amp;EndBind, 10); <br>      for (; *EndBind &amp;&amp; ISWHITE(*EndBind); EndBind = AnsiNext(EndBind)); <br>   } <br> <br>   if (lpChild-&gt;fRowset) { // rowset has been changed <br>      lpChild-&gt;crowRowset = <br>         (UWORD) strtol((char*) lpChild-&gt;szRowset, &amp;EndRowset, 10); <br>      for (; *EndRowset &amp;&amp; ISWHITE(*EndRowset); <br>           EndRowset = AnsiNext(EndRowset)); <br>   } <br> <br>   while (lpChild-&gt;fMaxBind &amp;&amp; *EndMaxBind  || <br>          lpChild-&gt;crowMaxBind &lt; 1 || <br>          lpChild-&gt;crowMaxBind &gt; MAX_MAXBIND || <br>          lpChild-&gt;fRowset &amp;&amp; *EndRowset || <br>          lpChild-&gt;crowRowset &lt; 1 || <br>          lpChild-&gt;crowRowset &gt; 4096 || <br>          lpChild-&gt;fBind &amp;&amp; *EndBind) { <br> <br>      // the maximum column width <br>      if (lpChild-&gt;crowMaxBind &lt; 1 || lpChild-&gt;crowMaxBind &gt; MAX_MAXBIND <br>          || lpChild-&gt;fMaxBind &amp;&amp; *EndMaxBind) <br>         MessageBox(lpChild-&gt;hwnd,  szBuffer, NULL, MB_ICONSTOP); <br> <br>      // the rowset size <br>      if (lpChild-&gt;crowRowset &lt; 1 || lpChild-&gt;crowRowset &gt; 4096 <br>          || lpChild-&gt;fRowset &amp;&amp; *EndRowset) { <br>         char szBuffer[128]; <br> <br>         LoadString(g_hinst, IDS_BADROWSET, szBuffer, sizeof(szBuffer)); <br>         MessageBox(lpChild-&gt;hwnd, szBuffer, NULL, MB_ICONSTOP); <br>      } <br> <br>      // number of bound columns <br>      if (lpChild-&gt;fBind &amp;&amp; *EndBind) <br>         MessageBox(lpChild-&gt;hwnd, <br>                    "Invalid number of bound columns", NULL, MB_ICONSTOP); <br> <br>      if (IDOK != DoDialog(lpChild-&gt;hwnd, IDD_OPTION_DIALOG, OptionsDlgProc)) <br>         return FALSE; <br> <br>      if (lpChild-&gt;fMaxBind) { // it's been changed <br>         lpChild-&gt;crowMaxBind = <br>            (SDWORD) strtol((char*) lpChild-&gt;szMaxBind, &amp;EndMaxBind, 10); <br>         for (; *EndMaxBind &amp;&amp; ISWHITE(*EndMaxBind); <br>              EndMaxBind = AnsiNext(EndMaxBind)); <br>      } <br> <br>      if (lpChild-&gt;fBind) {  // cBind has been changed <br>         lpChild-&gt;cBind = <br>            (UWORD) strtol((char*) lpChild-&gt;szBind, &amp;EndBind, 10); <br> <br>         for (; *EndBind &amp;&amp; ISWHITE(*EndBind); EndBind = AnsiNext(EndBind)); <br>      } <br> <br>      if (lpChild-&gt;fRowset) { // rowset has been changed <br>         lpChild-&gt;crowRowset = <br>            (UWORD) strtol((char*) lpChild-&gt;szRowset, &amp;EndRowset, 10); <br>         for (; *EndRowset &amp;&amp; ISWHITE(*EndRowset); <br>              EndRowset = AnsiNext(EndRowset)); <br>      } <br>   } <br> <br>   return TRUE; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
