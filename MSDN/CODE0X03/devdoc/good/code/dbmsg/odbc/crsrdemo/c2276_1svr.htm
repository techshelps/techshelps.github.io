<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CRSRDEMO.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2277"></a>CRSRDEMO.C</h2>
<pre><code>/*-------------------------------------------------------------------------- <br>  Crsrdemo.C --- Cursors main file <br> <br>  Description: <br>    This sample is spread across four files, each named for the role <br>    the contained functions play.  Each file header contains a brief <br>    description of its purpose and the routines it contains. <br> <br>    CRSRDEMO.C contains the standard functions used in a Windows program <br>    (such as, WinMain) plus two functions shared between all the files. <br>    These functions are: <br> <br>      DoMessage       - Issue a message <br>      EndInstance     - Clean up an instance of this program <br>      InitApplication - Prepare the first instance of this program <br>      InitInstance    - Prepare an instance of this program <br>      ODBCError       - Retrieve and display an ODBC error <br>      WinMain         - Main Windows entry point <br> <br>    This code is furnished on an as-is basis as part of the ODBC SDK and is <br>    intended for example purposes only. <br> <br>--------------------------------------------------------------------------*/ <br> <br>/* Includes --------------------------------------------------------------*/ <br>#include "headers.h" <br> <br>#pragma warning(disable:4001) <br>#define  INCL_GLOBAL <br>#include    "resource.h" <br>#include "crsrdemo.h" <br> <br> <br>// Prototypes -------------------------------------------------------------- <br>void INTFUNC EndInstance(void); <br>BOOL INTFUNC InitApplication(void); <br>BOOL INTFUNC InitInstance(int); <br>int  INTFUNC WinMain(HINSTANCE, HINSTANCE, LPSTR, int); <br> <br> <br>/* DoMessage --------------------------------------------------------------- <br>   Description: Issue a message <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC DoMessage(HWND hwnd, UINT id) <br>{ <br>   char  sz[cbSTRLEN]; <br> <br>   LoadString(g_hinst, id, sz, sizeof(sz)); <br>   MessageBox(hwnd, sz, g_szTITLE, MB_ICONINFORMATION | MB_OK); <br>   return; <br>} <br> <br> <br>/* EndInstance ------------------------------------------------------------- <br>   Description: Free instance related data <br>   --------------------------------------------------------------------------*/ <br>void INTFUNC EndInstance(void) <br>{ <br>   if (g_hfontName)  DeleteObject(g_hfontName); <br>   if (g_hfontData)  DeleteObject(g_hfontData); <br> <br>   if (g_hbrWin)     DeleteObject(g_hbrWin); <br>   if (g_hbrBtn)     DeleteObject(g_hbrBtn); <br>   if (g_hbrScroll)  DeleteObject(g_hbrScroll); <br> <br>   return; <br>} <br> <br> <br>/* InitApplication --------------------------------------------------------- <br>   Description: Prepare application by registering window classes <br>   --------------------------------------------------------------------------*/ <br>BOOL INTFUNC InitApplication(void) <br>{ <br>   WNDCLASS  wc; <br> <br>   wc.style         = CS_HREDRAW | CS_VREDRAW; <br>   wc.lpfnWndProc   = FrameProc; <br>   wc.cbClsExtra    = 0; <br>   wc.cbWndExtra    = 0; <br>   wc.hInstance     = g_hinst; <br>   wc.hIcon         = LoadIcon(g_hinst, MAKEINTRESOURCE(IDR_MAIN)); <br>   wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>   wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>   wc.lpszMenuName  = NULL; <br>   wc.lpszClassName = szFRAMECLASS; <br> <br>   if (!RegisterClass(&amp;wc)) <br>      return FALSE; <br> <br>   wc.style         = CS_HREDRAW | CS_VREDRAW; <br>   wc.lpfnWndProc   = ChildProc; <br>   wc.cbClsExtra    = 0; <br>   wc.cbWndExtra    = sizeof(LPCHILD); <br>   wc.hInstance     = g_hinst; <br>   wc.hIcon         = LoadIcon(g_hinst, MAKEINTRESOURCE(IDR_CHILD)); <br>   wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>   wc.lpszMenuName  = NULL; <br>   wc.lpszClassName = szCHILDCLASS; <br> <br>   if (!RegisterClass(&amp;wc)) <br>      return FALSE; <br> <br>   return TRUE; <br>} <br> <br> <br>/* InitInstance ------------------------------------------------------------ <br>   Description: Prepare instance by initializing global variables and <br>                creating main frame window <br>                --------------------------------------------------------------------------*/ <br>BOOL INTFUNC InitInstance(int nCmdShow) <br>{ <br>   RECT     rc; <br>   HDC         hdc; <br>   HFONT    hfont; <br>   TEXTMETRIC  tm; <br>   char     sz[cbSTRLEN]; <br>   SIZE        size; <br> <br>   // Initialize global variables <br>   g_hwnd       = <br>      g_hwndClient = NULL; <br> <br>   g_haccel     = NULL; <br> <br>   g_hmenuInit        = <br>      g_hmenuInitWindow  = <br>         g_hmenuFrame       = <br>            g_hmenuFrameWindow = <br>               g_hmenuChild       = <br>                  g_hmenuChildWindow = NULL; <br> <br>   g_hfontName = <br>      g_hfontData = NULL; <br> <br>   g_hbrWin    = <br>      g_hbrBtn    = <br>         g_hbrScroll = NULL; <br> <br>   g_henv = SQL_NULL_HENV; <br>   g_hdbc = SQL_NULL_HDBC; <br> <br>   g_haccel = LoadAccelerators(g_hinst, MAKEINTRESOURCE(IDR_MAIN)); <br> <br>   g_hmenuInit  = LoadMenu(g_hinst, MAKEINTRESOURCE(IDR_INIT)); <br>   g_hmenuFrame = LoadMenu(g_hinst, MAKEINTRESOURCE(IDR_MAIN)); <br>   g_hmenuChild = LoadMenu(g_hinst, MAKEINTRESOURCE(IDR_CHILD)); <br> <br>   g_hmenuInitWindow  = GetSubMenu(g_hmenuInit,  IDM_WINDOWINIT); <br>   g_hmenuFrameWindow = GetSubMenu(g_hmenuFrame, IDM_WINDOWFRAME); <br>   g_hmenuChildWindow = GetSubMenu(g_hmenuChild, IDM_WINDOWCHILD); <br> <br>   g_cxVScroll = GetSystemMetrics(SM_CXVSCROLL); <br>   g_cyHScroll = GetSystemMetrics(SM_CYHSCROLL); <br> <br>   LoadString(g_hinst, IDS_TABLE,      g_szTable,      sizeof(g_szTable)); <br>   LoadString(g_hinst, IDR_MAIN,       g_szTITLE,      sizeof(g_szTITLE)); <br>   LoadString(g_hinst, IDS_NOROW,      g_szNoRow,      sizeof(g_szNoRow)); <br>   LoadString(g_hinst, IDS_ROWERROR,   g_szRowError,  sizeof(g_szRowError)); <br>   LoadString(g_hinst, IDS_NULL,       g_szNull,       sizeof(g_szNull)); <br>   LoadString(g_hinst, IDS_ROWDELETED, g_szRowDeleted, sizeof(g_szRowDeleted)); <br>   LoadString(g_hinst, IDS_UNKNOWN,    g_szUnknown,    sizeof(g_szUnknown)); <br> <br>   // Create main window in upper 3/4 of desktop <br>   GetWindowRect(GetDesktopWindow(), &amp;rc); <br> <br>   g_hwnd = CreateWindow(szFRAMECLASS, <br>                         g_szTITLE, <br>                         WS_OVERLAPPEDWINDOW, <br>                         rc.left, <br>                         rc.top, <br>                         rc.right - rc.left, <br>                         ((rc.bottom - rc.top) / 4) * 3, <br>                         HWND_DESKTOP, <br>                         g_hmenuInit, <br>                         g_hinst, <br>                         NULL); <br>   if (!g_hwnd) <br>      return FALSE; <br> <br>   // Create fonts used in painting child windows <br>   hdc = GetDC(g_hwnd); <br> <br>   g_hfontName = CreateFont((GetDeviceCaps(hdc, LOGPIXELSY) * cPOINTS) / 72, <br>                            0, 0, 0, FW_BOLD, 0, 0, 0, 0, 0, 0, 0, 0, <br>                            szFONT); <br> <br>   hfont = SelectObject(hdc, g_hfontName); <br> <br>   GetTextMetrics(hdc, &amp;tm); <br>   g_cx = tm.tmMaxCharWidth; <br>   g_cy = tm.tmHeight + tm.tmInternalLeading; <br> <br>   g_hfontData = CreateFont((GetDeviceCaps(hdc, LOGPIXELSY) * cPOINTS) / 72, <br>                            0, 0, 0, FW_NORMAL, 0, 0, 0, 0, 0, 0, 0, 0, <br>                            szFONT); <br> <br>   SelectObject(hdc, g_hfontData); <br> <br>   // Determine font size characteristics <br>   GetTextMetrics(hdc, &amp;tm); <br>   g_cx = max(g_cx, tm.tmMaxCharWidth); <br>   g_cy = max(g_cy, tm.tmHeight + tm.tmInternalLeading); <br> <br>   GetTextExtentPoint(hdc, szRECORD, lstrlen(szRECORD), &amp;size); <br>   g_cxRecord = size.cx; <br> <br>   wsprintf(sz, szRECNUM, 999999); <br> <br>   GetTextExtentPoint(hdc, sz, lstrlen(sz), &amp;size); <br>   g_cxRecnum = size.cx; <br> <br>   SelectObject(hdc, hfont); <br> <br>   ReleaseDC(g_hwnd, hdc); <br> <br>   // Allocate brushes <br>   g_hbrWin    = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>   g_hbrBtn    = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>   g_hbrScroll = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR)); <br> <br>   // Allocate ODBC environment and connection handles; register as a 3.0 app <br>   if (ENVError(g_hwnd, SQLAllocHandle(SQL_HANDLE_ENV,SQL_NULL_HENV,&amp;g_henv))) <br>      return FALSE; <br>   if (ENVError(g_hwnd, SQLSetEnvAttr(g_henv, SQL_ATTR_ODBC_VERSION, <br>                                      (SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER))) <br>      return FALSE; <br>   if (ENVError(g_hwnd, SQLAllocHandle(SQL_HANDLE_DBC,g_henv, &amp;g_hdbc))) <br>      return FALSE; <br> <br>   // Always use the cursor library <br>   if (DBCError(g_hwnd, SQLSetConnectAttr(   g_hdbc, <br>                                          SQL_ATTR_ODBC_CURSORS, <br>                                          (void *)SQL_CUR_USE_ODBC,0))) { <br>      return FALSE; <br>   } <br> <br> <br> <br> <br>   // Complete variable initialization <br>   g_cbName          = 0; <br>   g_fConnected      = FALSE; <br>   g_fAsyncSupported = FALSE; <br>   g_szDSN[0]        = '\0'; <br>   g_cChild          = 0; <br>   g_cCursor         = 0; <br> <br>   g_mrows      = 1000; <br> <br>   g_hwndClient = GetWindow(g_hwnd, GW_CHILD); <br> <br>   // Set initial menu state <br>   AdjustMenus(); <br> <br>   // Show frame window <br>   ShowWindow(g_hwnd, nCmdShow); <br>   UpdateWindow(g_hwnd); <br>   return TRUE; <br>} <br> <br> <br>/* ODBCError --------------------------------------------------------------- <br>   Description: Fetch and display an ODBC error message <br>                NOTE: SQL_NO_DATA and SQL_STILL_EXECUTING are <br>                      not considered errors <br>                      --------------------------------------------------------------------------*/ <br>BOOL INTFUNC ODBCError(HWND hwnd, SWORD fHandleType, SQLHANDLE handle, SQLRETURN rc) <br>{ <br>   if (rc == SQL_SUCCESS) <br>      return FALSE; <br> <br>   if (rc == SQL_NO_DATA) { <br>      DoMessage(hwnd, IDS_NODATAFOUND); <br>      return FALSE; <br>   } <br> <br>   if (rc == SQL_STILL_EXECUTING) { <br>      DoMessage(hwnd, IDS_STILLEXEC); <br>      return FALSE; <br>   } <br> <br>   { <br>      SDWORD   fNative; <br>      SWORD cbError; <br>      LPSTR lpszFmt; <br>      LPSTR lpszSQLState; <br>      LPSTR lpszError; <br>      LPSTR lpsz; <br>      SWORD sMsgNum = 1; <br> <br>      // Allocate storage <br>      lpsz = AllocPtr(1024 + cbSTRLEN + 6 + SQL_MAX_MESSAGE_LENGTH); <br> <br>      lpszFmt      = lpsz + 1024; <br>      lpszSQLState = lpszFmt + cbSTRLEN; <br>      lpszError    = lpszSQLState + 6; <br>      LoadString(g_hinst, IDS_MSGFMT, lpszFmt, cbSTRLEN); <br> <br>      // sometimes handle comes in as NULL <br>      if (handle) { <br>         // Retrieve and display errors until there are no more <br>         while (SQLGetDiagRec(fHandleType, handle, sMsgNum++, <br>                              (UCHAR FAR *)lpszSQLState, <br>                              &amp;fNative, <br>                              (UCHAR FAR *)lpszError, <br>                              SQL_MAX_MESSAGE_LENGTH-1, <br>                              &amp;cbError) != SQL_NO_DATA) { <br>            if (lstrcmpi(lpszSQLState, szDATATRUNC)) { <br>               wsprintf(lpsz, lpszFmt, lpszSQLState, fNative, lpszError); <br> <br>               MessageBox(hwnd, lpsz, g_szTITLE, <br>                          strncmp(lpszSQLState, "01", 2) <br>                          ? MB_ICONSTOP | MB_OK <br>                          : MB_ICONINFORMATION | MB_OK); <br>            } <br>         } <br>      } <br>      else { <br>         MessageBox(hwnd, "Invalid handle", g_szTITLE, <br>                    MB_ICONSTOP | MB_OK); <br>      } <br> <br>      // Free storage <br>      FreePtr(lpsz); <br>   } <br> <br>   return (!SUCCESS(rc)); <br>} <br> <br> <br>/* WinMain ----------------------------------------------------------------- <br>   Description: Standard WinMain function <br>   --------------------------------------------------------------------------*/ <br>int INTFUNC WinMain(HINSTANCE   hinstCur, <br>                    HINSTANCE   hinstPrev, <br>                    LPSTR       lpszCmdLine, <br>                    int         nCmdShow) <br>{ <br>   MSG msg; <br> <br>   UNREF_PARAM(lpszCmdLine); <br>   g_hinst = hinstCur; <br> <br>   if (!hinstPrev) <br>      if (!InitApplication()) <br>         return (FALSE); <br> <br>   if (!InitInstance(nCmdShow)) { <br>      EndInstance(); <br>      return (FALSE); <br>   } <br> <br>   while (GetMessage(&amp;msg, (HWND)NULL, (UINT)NULL, (UINT)NULL)) <br>      if (!TranslateMDISysAccel(g_hwndClient, &amp;msg) &amp;&amp; <br>          !TranslateAccelerator(g_hwnd, g_haccel, &amp;msg) &amp;&amp; <br>          (!(g_hwndChildDialog) || (!IsDialogMessage(g_hwndChildDialog, &amp;msg)))) { <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br>      } <br> <br>   EndInstance(); <br> <br>   return msg.wParam; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
