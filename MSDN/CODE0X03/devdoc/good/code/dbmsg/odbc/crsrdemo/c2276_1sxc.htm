<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FRAME.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2280"></a>FRAME.C</h2>
<pre><code>/*-------------------------------------------------------------------------- <br>  Frame.C --- Cursors main window procedure <br> <br>  Description: <br>        This sample is spread across four files, each named for the role <br>        the contained functions play.  Each file header contains a brief <br>        description of its purpose and the routines it contains. <br> <br>        FRAME.C contains those functions used to manage the main frame <br>        window.  The frame window, created by code in MAIN.C, owns the <br>        MDI client window, the menu bar, and other major parts of the <br>        interface.  The functions is contains are: <br> <br>            AdjustMenus    - Enable/disable menu items given current state <br>            CloseAll       - Close all child windows <br>            CloseAllEnum   - Window enumeration callback used by CloseAll <br>            CloseChild     - Close the currently active child window <br>            CreateChild    - Create a new child window <br>            DoConnect      - Connect to a host <br>            DoDisconnect   - Disconnect from a host <br>            DoFrameMenu    - Process a menu request <br>            FrameProc      - Process frame window messages <br> <br>  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>  intended for example purposes only. <br> <br>--------------------------------------------------------------------------*/ <br> <br>/* Includes --------------------------------------------------------------*/ <br>#include    "headers.h" <br> <br>#include   "resource.h" <br>#include    "crsrdemo.h" <br> <br> <br>// Constants --------------------------------------------------------------- <br>#define fDISABLED   (MF_BYCOMMAND | MF_DISABLED | MF_GRAYED) <br>#define fENABLED    (MF_BYCOMMAND | MF_ENABLED) <br> <br> <br>// Prototypes -------------------------------------------------------------- <br>void INTFUNC CloseAll(HWND); <br>void INTFUNC CloseChild(HWND); <br>HWND INTFUNC CreateChild(HWND); <br>BOOL INTFUNC DoConnect(HWND); <br>void INTFUNC DoDisconnect(void); <br>BOOL INTFUNC DoFrameMenu(HWND, WPARAM, LPARAM); <br> <br>BOOL CALLBACK CloseAllEnum(HWND, LPARAM); <br> <br> <br>/* AdjustMenus ------------------------------------------------------------- <br>    Description: Enable/disable appropriate menu items <br>    --------------------------------------------------------------------------*/ <br>void INTFUNC AdjustMenus(void) <br>{ <br>   LRESULT lresult; <br>   BOOL    fMaximized; <br>   HWND    hwnd; <br>   HMENU   hmenu; <br>   UINT    idMenu; <br>   UINT    fOption; <br> <br>   lresult = SendMessage(g_hwndClient, WM_MDIGETACTIVE, 0, 0L); <br> <br>#ifdef WIN32 <br>   hwnd       = (HWND)lresult; <br>   fMaximized = GetWindowLong(hwnd, GWL_STYLE) &amp; WS_MAXIMIZE; <br>#else <br>   hwnd       = (HWND)(LOWORD(lresult)); <br>   fMaximized = HIWORD(lresult); <br>#endif <br> <br>   if( hwnd ) { <br>      LPCHILD lpchild; <br> <br>      lpchild = (LPCHILD)GetWindowLong(hwnd, 0); <br> <br>      idMenu = IDM_FETCH + (fMaximized ? 1 : 0); <br> <br>      if( lpchild-&gt;fResultSetExists ) { <br>         EnableMenuItem(GetMenu(g_hwnd), idMenu, MF_BYPOSITION | <br>                        MF_ENABLED); <br>         fOption = fENABLED; <br>      } <br>      else { <br>         EnableMenuItem(GetMenu(g_hwnd), idMenu, MF_BYPOSITION | <br>                        MF_DISABLED   | <br>                        MF_GRAYED); <br>         fOption = fDISABLED; <br>      } <br> <br>      hmenu = GetSubMenu(GetMenu(g_hwnd), idMenu); <br>      EnableMenuItem(hmenu, IDM_FETCH_FIRST, fOption); <br>      EnableMenuItem(hmenu, IDM_FETCH_PRIOR,  fOption); <br>      EnableMenuItem(hmenu, IDM_FETCH_NEXT,   fOption); <br>      EnableMenuItem(hmenu, IDM_FETCH_LAST,   fOption); <br>      EnableMenuItem(hmenu, IDM_FETCH_ABSOLUTE, fOption); <br>      EnableMenuItem(hmenu, IDM_FETCH_RELATIVE, fOption); <br>#if 0 <br>      EnableMenuItem(hmenu, IDM_FETCH_RESUME, fOption); <br>#endif  //  0 <br>      if( lpchild-&gt;dwOperation != OPER_SELECT ) { <br>         EnableMenuItem(hmenu, (UINT)IDM_FETCH_DELETEROW, fDISABLED); <br>         EnableMenuItem(hmenu, (UINT)IDM_FETCH_UPDATEROW, fDISABLED); <br>      } <br>      else { <br>         EnableMenuItem(hmenu, (UINT)IDM_FETCH_DELETEROW, fOption); <br>         EnableMenuItem(hmenu, (UINT)IDM_FETCH_UPDATEROW, fOption); <br>      } <br> <br>      idMenu = IDM_FETCHCHILD + (fMaximized ? 1 : 0); <br>      if( g_fConnected ) { <br>         EnableMenuItem(GetMenu(g_hwnd), idMenu, MF_BYPOSITION | <br>                        MF_ENABLED); <br>         fOption = fENABLED; <br>      } <br>      else { <br>         EnableMenuItem(GetMenu(g_hwnd), idMenu, MF_BYPOSITION  | <br>                        MF_DISABLED    | <br>                        MF_GRAYED); <br>         fOption = fDISABLED; <br>      } <br>   } <br>   else { <br>      UINT    wCount; <br>       <br>      hmenu = GetMenu(g_hwnd); <br>      wCount = GetMenuItemCount(hmenu); <br>      for( idMenu = 0; idMenu &lt; wCount; idMenu++ ) <br>         EnableMenuItem(hmenu, idMenu, MF_BYPOSITION | MF_ENABLED); <br>   } <br> <br>   DrawMenuBar(g_hwnd); <br>   return; <br>} <br> <br> <br>/* CloseAll ---------------------------------------------------------------- <br>    Description: Close all child windows <br>    --------------------------------------------------------------------------*/ <br>void INTFUNC CloseAll(HWND hwnd) <br>{ <br>   UNREF_PARAM(hwnd); <br>   if (!g_fConnected) <br>      return; <br> <br>   EnumChildWindows(g_hwndClient, CloseAllEnum, 0L); <br>   return; <br>} <br> <br> <br>/* CloseAllEnum ------------------------------------------------------------ <br>    Description: EnumChildWindows procedure, it calls CloseChild for each <br>                 child window passed <br>                 --------------------------------------------------------------------------*/ <br>BOOL CALLBACK CloseAllEnum(HWND hwnd, LPARAM lparam) <br>{ <br>   UNREF_PARAM(lparam); <br>   if (!GetWindow(hwnd, GW_OWNER)) <br>      CloseChild(hwnd); <br>   return TRUE; <br>} <br> <br> <br>/* CloseChild -------------------------------------------------------------- <br>    Description: Close a child window <br>    --------------------------------------------------------------------------*/ <br>void INTFUNC CloseChild(HWND hwnd) <br>{ <br>   // Destroy child window <br>   FORWARD_WM_MDIDESTROY(g_hwndClient, hwnd, SendMessage); <br> <br>   // Decrement child count <br>   g_cChild--; <br> <br>   // Set appropriate menu bar <br>   if (!g_cChild) <br>#ifdef WIN32 <br>      SendMessage(g_hwndClient,WM_MDISETMENU,(WPARAM)g_hmenuFrame,(LPARAM)g_hmenuFrameWindow); <br>#else <br>   FORWARD_WM_MDISETMENU(g_hwndClient, <br>                         0, g_hmenuFrame, g_hmenuFrameWindow, SendMessage); <br>#endif <br>   return; <br>} <br> <br> <br>/* CreateChild ------------------------------------------------------------- <br>    Description: Create a child window <br>    --------------------------------------------------------------------------*/ <br>HWND INTFUNC CreateChild(HWND hwnd) <br>{ <br>   HWND            hwndChild; <br>   MDICREATESTRUCT mdi; <br>   int             x, y, cx, cy; <br> <br>   // Have child fill client area if it is the only child window <br>   if (!g_cChild) { <br>      RECT    rc; <br> <br>      GetClientRect(hwnd, &amp;rc); <br> <br>      x  = rc.left; <br>      y  = rc.top; <br>      cx = rc.right - rc.left; <br>      cy = rc.bottom - rc.top; <br>   } <br> <br>   // Otherwise, accept default placement <br>   else { <br>      x  = <br>         y  = <br>            cx = <br>               cy = CW_USEDEFAULT; <br>   } <br> <br>   // Increment child count and cursor number <br>   g_cChild++; <br>   g_cCursor++; <br> <br>   // Create child via MDI interface <br>   mdi.szClass = szCHILDCLASS; <br>   mdi.szTitle = g_szDSN; <br>   mdi.hOwner  = g_hinst; <br>   mdi.x       = x; <br>   mdi.y       = y; <br>   mdi.cx      = cx; <br>   mdi.cy      = cy; <br>   mdi.style   = 0; <br>   mdi.lParam  = (LPARAM)NULL; <br> <br>   hwndChild = FORWARD_WM_MDICREATE(g_hwndClient, ((LPSTR)&amp;mdi), SendMessage); <br> <br>   if (hwndChild) { <br>      if (g_cChild == 1) <br>#ifdef WIN32 <br>         SendMessage(g_hwndClient,WM_MDISETMENU,(WPARAM)g_hmenuChild,(LPARAM)g_hmenuChildWindow); <br>#else <br>      FORWARD_WM_MDISETMENU(g_hwndClient, <br>                            0, g_hmenuChild, g_hmenuChildWindow, SendMessage); <br>#endif <br>   } <br>   else <br>      g_cChild--; <br> <br>   return hwndChild; <br>} <br> <br> <br>/* DoConnect --------------------------------------------------------------- <br>    Description: Connect to a data source <br>    --------------------------------------------------------------------------*/ <br>BOOL INTFUNC DoConnect(HWND hwnd) <br>{ <br>   HCURSOR   hcur; <br>   char      sz[cbMAXSQL]; <br>   SWORD     cb; <br>   SQLRETURN rc; <br> <br>   // If already connected, close all children and disconnect <br>   if (g_fConnected) { <br>      LoadString(g_hinst, IDS_CONWARN, sz, sizeof(sz)); <br>      rc = MessageBox(hwnd, <br>                      sz, g_szTITLE, <br>                      MB_ICONQUESTION | MB_OKCANCEL | MB_DEFBUTTON2); <br>      if (rc == IDCANCEL) <br>         return FALSE; <br>      CloseAll(hwnd); <br>      DoDisconnect(); <br>   } <br> <br>   hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   // Call SQLDriverConnect <br>   rc = SQLDriverConnect(g_hdbc, g_hwnd, NULL, 0, <br>                         (UCHAR FAR *)sz, sizeof(sz), &amp;cb, SQL_DRIVER_COMPLETE); <br> <br>   // If successfully connected, get data source attributes <br>   if (SUCCESS(rc)) { <br>      LPSTR    lpszS, lpszD; <br>      SQLHSTMT hstmt; <br> <br>      // Mark as connected <br>      g_fConnected = TRUE; <br> <br>      // Extract and save data source name <br>      lpszS = _fstrstr(sz, szDSNKEY); <br> <br>      if (lpszS) { <br>         lpszS = _fstrstr(sz, szDSNKEY) + lstrlen(szDSNKEY); <br>         lpszD = g_szDSN; <br>         while (*lpszS &amp;&amp; *lpszS != ';') *lpszD++ = *lpszS++; <br>         *lpszD = '\0'; <br>      } <br>      else <br>         LoadString(g_hinst, IDS_NODSN, g_szDSN, sizeof(g_szDSN)); <br> <br>      // Change to the appropriate menu bar <br>#ifdef WIN32 <br>      SendMessage(g_hwndClient,WM_MDISETMENU,(WPARAM)g_hmenuFrame,(LPARAM)g_hmenuFrameWindow); <br>#else <br>      FORWARD_WM_MDISETMENU(g_hwndClient, <br>                            0, g_hmenuFrame, g_hmenuFrameWindow, SendMessage); <br>#endif <br> <br>      // Get maximum column name length <br>      if (DBCError(hwnd, SQLGetInfo(g_hdbc, SQL_MAX_COLUMN_NAME_LEN, <br>                                    &amp;g_cbName, sizeof(g_cbName), NULL))) <br>         g_cbName = 32; <br> <br>      // Get identifier quote character <br>      if (DBCError(hwnd, SQLGetInfo(g_hdbc, SQL_IDENTIFIER_QUOTE_CHAR, <br>                                    g_szQuoteChar, sizeof(g_szQuoteChar), NULL))) <br>         *g_szQuoteChar = ' '; <br> <br>      // Determine if async support is available <br>      rc = SQLAllocHandle(SQL_HANDLE_STMT,g_hdbc, &amp;hstmt); <br>      if (!SUCCESS(rc)) <br>         g_fAsyncSupported = FALSE; <br> <br>      else { <br>         g_fAsyncSupported = SUCCESS(SQLSetStmtAttr(hstmt, <br>                                                    SQL_ATTR_ASYNC_ENABLE, <br>                                                    (SQLPOINTER) 1, <br>                                                    SQL_IS_INTEGER)); <br>         SQLFreeHandle(SQL_HANDLE_STMT,hstmt); <br>      } <br>   } <br>   else if (rc != SQL_NO_DATA) <br>      DBCError(hwnd, rc); <br> <br>   SetCursor(hcur); <br>   return SUCCESS(rc); <br>} <br> <br> <br>/* DoDisconnect ------------------------------------------------------------ <br>    Description: Drop ODBC connection <br>    --------------------------------------------------------------------------*/ <br>void INTFUNC DoDisconnect(void) <br>{ <br>   // Change to the appropriate menu bar <br>#ifdef WIN32 <br>   SendMessage(g_hwndClient,WM_MDISETMENU,(WPARAM)g_hmenuInit,(LPARAM)g_hmenuInitWindow); <br>#else <br>   FORWARD_WM_MDISETMENU(g_hwndClient, <br>                         0, g_hmenuInit, g_hmenuInitWindow, SendMessage); <br>#endif <br> <br>   // If not fully connected, return immediately <br>   if (!g_fConnected) <br>      return; <br> <br>   // Disconnect with ODBC <br>   SQLDisconnect(g_hdbc); <br> <br>   // Reset connection related variables <br>   g_cbName     = 0; <br>   g_fConnected = FALSE; <br>   g_szDSN[0]   = '\0'; <br>   g_cChild     = 0; <br>   g_cCursor    = 0; <br>   return; <br>} <br> <br> <br>/* DoFrameMenu ------------------------------------------------------------- <br>    Description: Respond to a request from the frame window menu <br>    --------------------------------------------------------------------------*/ <br>BOOL INTFUNC DoFrameMenu(HWND  hwnd, WPARAM  wparam, LPARAM  lparam) <br>{ <br>   HWND    hwndChild; <br> <br>   hwndChild = FORWARD_WM_MDIGETACTIVE(g_hwndClient, SendMessage); <br> <br>   switch (GET_WM_COMMAND_ID(wparam, lparam)) { <br> <br>     case IDM_STMT_ADDDSN: <br>      SQLCreateDataSource(hwnd, NULL); <br>      break; <br> <br>     case IDM_STMT_DISCONNECT: <br>      if (g_cChild) <br>         CloseAll(hwnd); <br>      DoDisconnect(); <br>      break; <br> <br>     case IDM_STMT_CONNECT: <br>      if (!DoConnect(hwnd)) <br>         break; <br> <br>     case IDM_STMT_NEW: <br>      hwndChild = CreateChild(hwnd); <br>      break; <br> <br>     case IDM_STMT_CLOSE: <br>      CloseChild(hwndChild); <br>      break; <br> <br>     case IDM_STMT_CLOSEALL: <br>      CloseAll(hwnd); <br>      break; <br> <br>     case IDM_STMT_EXIT: <br>      PostMessage(hwnd, WM_CLOSE, 0, 0L); <br>      break; <br> <br>     case IDM_WINDOW_ARRANGE: <br>      FORWARD_WM_MDIICONARRANGE(g_hwndClient, SendMessage); <br>      break; <br> <br>     case IDM_WINDOW_CASCADE: <br>      FORWARD_WM_MDICASCADE(g_hwndClient, 0, SendMessage); <br>      break; <br> <br>     case IDM_WINDOW_TILEH: <br>     case IDM_WINDOW_TILEV: { <br>        WPARAM  fTile; <br> <br>        fTile = (GET_WM_COMMAND_ID(wparam, lparam) == IDM_WINDOW_TILEH <br>                 ? MDITILE_HORIZONTAL <br>                 : MDITILE_VERTICAL); <br>        FORWARD_WM_MDITILE(g_hwndClient, fTile, SendMessage); <br>        break; <br>     } <br> <br>     case IDM_HELP_ABOUT: <br>      DoDialog(g_hwnd, IDD_ABOUTBOX, AboutDlgProc); <br>      break; <br>   <br>     case IDM_HELP_HELP: <br>      WinHelp(g_hwnd, szHELPFILE, HELP_KEY ,(DWORD)(LPTSTR)szKeyword ); <br>break; <br> <br> <br> <br>     default: <br>      // Pass unrecognized request to the current child <br>      SendMessage(hwndChild, WM_COMMAND, wparam, lparam); <br>      return FALSE; <br>   } <br> <br>   // Adjust menu state <br>   AdjustMenus(); <br>   return TRUE; <br>} <br> <br> <br>/* FrameProc --------------------------------------------------------------- <br>    Description: Frame window procedure <br>    --------------------------------------------------------------------------*/ <br>LRESULT EXPFUNC FrameProc(HWND    hwnd, <br>                          UINT   msg, <br>                          WPARAM wparam, <br>                          LPARAM lparam) <br>{ <br>   switch (msg) { <br> <br>      // Create MDI client window <br>     case WM_CREATE: { <br>        CLIENTCREATESTRUCT  client; <br> <br>        client.hWindowMenu  = g_hmenuInitWindow; <br>        client.idFirstChild = IDM_FIRSTCHILD; <br> <br>        g_hwndClient = CreateWindow(szMDICLIENT, NULL, <br>                                    WS_CHILD        | <br>                                    WS_CLIPCHILDREN | <br>                                    WS_VISIBLE, <br>                                    0, 0, 0, 0, hwnd, (HMENU)1, g_hinst, <br>                                    &amp;client); <br>        break; <br>     } <br> <br>      // Refresh brushes when colors change <br>     case WM_SYSCOLORCHANGE: <br>      if (g_hbrWin)    DeleteObject(g_hbrWin); <br>      if (g_hbrBtn)    DeleteObject(g_hbrBtn); <br>      if (g_hbrScroll) DeleteObject(g_hbrScroll); <br> <br>      g_hbrWin    = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>      g_hbrBtn    = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>      g_hbrScroll = CreateSolidBrush(GetSysColor(COLOR_SCROLLBAR)); <br>      break; <br> <br>      // Close all children, drop connection, and close frame window <br>     case WM_CLOSE: <br>      CloseAll(hwnd); <br>      DoDisconnect(); <br>      DestroyWindow(hwnd); <br>      break; <br> <br>      // Destroy menus not attached to the window and drop ODBC handles <br>     case WM_DESTROY: { <br>        HMENU   hmenu; <br> <br>        hmenu = GetMenu(hwnd); <br> <br>        if (g_hmenuInit  != hmenu) DestroyMenu(g_hmenuInit); <br>        if (g_hmenuFrame != hmenu) DestroyMenu(g_hmenuFrame); <br>        if (g_hmenuChild != hmenu) DestroyMenu(g_hmenuChild); <br> <br>        if (g_hdbc) <br>           SQLFreeHandle(SQL_HANDLE_DBC,g_hdbc); <br> <br>        if (g_henv) <br>           SQLFreeHandle(SQL_HANDLE_ENV,g_henv); <br> <br>        g_hwnd = NULL; <br> <br>        WinHelp(hwnd, szHELPFILE, HELP_QUIT, 0L); <br>        PostQuitMessage(0); <br>        break; <br>     } <br> <br>      // Pass menu commands to handler routine <br>     case WM_COMMAND: <br>      if (DoFrameMenu(hwnd, wparam, lparam)) <br>         break; <br> <br>      // All other requests go to default MDI frame procedure <br>     default: <br>      return DefFrameProc(hwnd, g_hwndClient, msg, wparam, lparam); <br>   } <br> <br>   return (LRESULT)NULL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
