<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STANDARD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2272"></a>STANDARD.C</h2>
<pre><code>//*--------------------------------------------------------------------------------- <br>//|  ODBC System Administrator <br>//| <br>//|  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>//|  intended for example purposes only. <br>//| <br>//|   Title:   STANDARD.C <br>//|      This module contains standard functions which can be used by many <br>//|      different tools. <br>//| <br>//|      The DumpDebugInfo function when enabled will cause all memory requests <br>//|      and frees to be written to a comma separated file.  This file can then <br>//|      be queries via the sample Text ODBC Driver to find memory problems. <br>//*--------------------------------------------------------------------------------- <br>#include "standard.h" <br>#include &lt;windowsx.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include "errcheck.h" <br>#include "strings.h" <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Global variables <br>//*--------------------------------------------------------------------------------- <br>char OutStr[MAXBUFF]; <br>dCSEG(char) szui[]                        =  "%u"; <br>dCSEG(char) szEmpty[]                     =  "\0"; <br>dCSEG(char) szcrlf[]                      =  "\r\n"; <br> <br>#ifdef _DEBUG <br>#include "time.h" <br>#define szASSERTERROR (LPSTR)"Assert: %s, %s, %d" <br>#define szDEBUGFILE (LPSTR)"C:\\TMP\\MEM" <br>char szDbgOut[200]; <br>BOOL fNew=TRUE; <br> <br>void WinAssertReal(int exp, LPSTR msg, LPSTR file, int line) <br>{ <br>   if(!exp) { <br>      wsprintf(szDbgOut, szASSERTERROR, msg, file, line); <br>      MessageBox(GetActiveWindow(), szDbgOut, szErrTitle, MB_OK); <br>   } <br>} <br> <br>void DumpDebugInfo(LPVOID tmp, LPSTR szFile, int cbLine, int stat, <br>         DWORD rqSize, DWORD aSize) <br>{ <br>   static   OFSTRUCT    ofs; <br>   static   HFILE       hf; <br>   static   time_t      thetime; <br>   static   struct tm * tmVal; <br> <br>   if(fNew) { <br>      fNew = FALSE; <br>      ofs.cBytes = sizeof(OFSTRUCT); <br>      hf = OpenFile(szDEBUGFILE, &amp;ofs, OF_DELETE); <br>      _lclose(hf); <br>   } <br> <br>   // Creates file MEM which is a comma separated text file. <br>   // Issue the select statement to find memory ptrs <br>   // which were allocated but never freed (status=1), and <br>   // pointers which were freed but never allocated (status=-1). <br>   // Of course "No data found" is the desired response. <br>   //    create table mem <br>   //        (address char(9), <br>   //         logtime char(8), <br>   //         status integer, <br>   //         desired integer, <br>   //         actual integer, <br>   //         line integer, <br>   //         file char(45)) <br>   //    select address, sum(status) from mem <br>   //      group by address having sum(status) &lt;&gt; 0 <br>   time(&amp;thetime); <br>   tmVal = localtime(&amp;thetime); <br>   wsprintf(szDbgOut, (LPSTR)"%04X:%04X,%02u:%02u:%02u,%d,%lu,%lu,%u,%s\r\n", <br>            HIWORD(tmp), LOWORD(tmp), tmVal-&gt;tm_hour, tmVal-&gt;tm_min, tmVal-&gt;tm_sec, <br>            stat, rqSize, aSize, cbLine, (LPSTR)szFile); <br>   if((hf = _lopen(szDEBUGFILE, WRITE)) == -1)  // File not found <br>      hf = OpenFile(szDEBUGFILE, &amp;ofs, OF_CREATE); <br>   _llseek(hf, 0L, 2);                    // Try to go to end of file <br>   _lwrite(hf, szDbgOut, lstrlen(szDbgOut));  // Write wherever we are <br>   _lclose(hf); <br>} <br> <br>void FAR * DebugGetMemory(DWORD size, LPSTR szFile, int cbLine) <br>{ <br>   LPVOID   ptr; <br>   DWORD    aSize; <br> <br>   ptr = DoGetMemory(size); <br>   if(!ptr) <br>      return ptr; <br>   aSize = GlobalSize(GlobalPtrHandle(ptr)); <br>   DumpDebugInfo(ptr, szFile, cbLine, 1, size, aSize); <br> <br>   return ptr; <br>} <br> <br>void DebugReleaseMemory(LPVOID ptr, LPSTR szFile, int cbLine) <br>{ <br>   GlobalFreePtr(ptr); <br>   DumpDebugInfo(ptr, szFile, cbLine, -1, 0, 0); <br>} <br>#endif      // Debug memory routines <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoGetMemory: <br>//|   This function allocates the specified amount of memory. <br>//| Parms: <br>//|   in       size                 How much memory <br>//| Returns: <br>//|   Long pointer to void <br>//*--------------------------------------------------------------------------------- <br>void FAR * DoGetMemory(DWORD size) <br>{ <br>   LPVOID   tmp; <br> <br>   tmp = GlobalAllocPtr(GMEM_FIXED | GMEM_ZEROINIT, size); <br>   if(!tmp) <br>      szMessageBox(GetActiveWindow(), <br>                   MB_ICONEXCLAMATION, <br>                   (LPSTR)szErrTitle, <br>                   GetidsString(idsOutOfMemory, OutStr, MAXBUFF)); <br>   return tmp; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoReleaseMemory: <br>//|   Free up the memory we have requested <br>//| Parms: <br>//|   ptr         The pointer to free <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void DoReleaseMemory(LPVOID ptr) <br>{ <br>   GlobalFreePtr(ptr); <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| RemoveCrLf: <br>//|   This will remove all carriage return/line feeds from the input buffer. <br>//| Parms: <br>//|   in       instr                Null terminated string <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>void RemoveCrLf(LPSTR instr) <br>{ <br>   LPSTR str=instr; <br> <br>   if(!str || <br>      !*str) <br>      return; <br>   while((str = _fstrstr(str, (LPSTR)szcrlf))) { <br>      *str++ = ' '; <br>      *str++ = ' '; <br>   } <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| GetNewDirectory: <br>//|   This function will take a complete file name (must have path included) <br>//|   and return only the path portion with no trailing '\' <br>//| Parms: <br>//|   outstr            Output path name with no file <br>//|   instr             Input complete file name <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>void GetNewDirectory(LPSTR outstr, LPSTR instr) <br>{ <br>   LPSTR    str=outstr; <br>   LPSTR    lstr=outstr; <br> <br>   lstrcpy(str, instr); <br>   while((str = _fstrchr(lstr+1, '\\'))) <br>      lstr = str++; <br>   *++lstr = '\0'; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| ValidName: <br>//|   This function parses a string to look for invalid characters which would <br>//|   preclude it from being written as a section or entry in an .ini file. <br>//| Parms: <br>//|   instr             Input complete file name <br>//| Returns: <br>//|   TRUE if it is valid, FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL ValidName(LPSTR instr) <br>{ <br>   LPSTR str=instr; <br>   if(!str) <br>      return TRUE; <br>   while(*str) <br>      switch(*str) { <br>        case '[': <br>        case ']': <br>        case '=': <br>         return FALSE; <br> <br>        default: <br>         ++str; <br>      } <br>   return TRUE; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| lpatoi: <br>//|   atoi only works for NEAR host vars, which makes it useless in a large <br>//|   application.  This function tricks atoi by copy the long string to a <br>//|   local variable and then doing the conversion.  This is a major cluge, <br>//|   but a necessary one. <br>//| Parms: <br>//|   instr             Input number <br>//| Returns: <br>//|   The integer value of instr <br>//*--------------------------------------------------------------------------------- <br>int lpatoi(LPSTR instr) <br>{ <br>   char szStr[35]; <br>   lstrcpy((LPSTR)szStr, instr); <br>   return atoi(szStr); <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//|  GetidsString: <br>//|      Will retrieve a string from our resource fork given the id. <br>//|  Parms: <br>//|      ids            The id of the string <br>//|      szOut          Output buffer for string <br>//|      cbSize         How big is the buffer <br>//|  Returns: <br>//|      Pointer to szOut <br>//*------------------------------------------------------------------------ <br>LPSTR EXTFUN GetidsString(UINT ids, LPSTR szOut, UINT cbSize) <br>{ <br>   extern HINSTANCE hInst; <br> <br>   if(!szOut) <br>      return NULL; <br>   if(!LoadString(hInst, ids, szOut, cbSize)) <br>      lstrcpy(szOut, "Not found"); <br>   return szOut; <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//|  szWrite: <br>//|      Allows you to format an output string which is then added <br>//|      to the specified edit window. <br>//|  Parms: <br>//|      hwnd           Edit window for output <br>//|      szFmt          Format string <br>//|      (varying)      Arguements for format string <br>//|  Returns: <br>//|      Nothing <br>//*------------------------------------------------------------------------ <br>VOID FAR CDECL szWrite(HWND hwnd, LPSTR szFmt, ...) <br>{ <br>#define MAXEDITBUFF 30000 <br>   static      char  szBuffer[MAXBUFF]; <br>   UCHAR *     pszBuffer; <br>   UCHAR       bufFmt[MAXBUFF]; <br>   va_list           marker; <br>   UINT              rtn=0; <br>   UINT              len=0; <br> <br> <br>   pszBuffer = &amp;szBuffer[0]; <br>   lstrcpy(bufFmt, szFmt); <br> <br>   // Use format and arguements as input <br>   va_start(marker, szFmt); <br>   if (_vsnprintf(pszBuffer, MAXBUFF, bufFmt, marker) &lt; 0) { <br>      wsprintf(pszBuffer,"Buffer overflow reporting '%*.*s'", 50,50,(LPSTR)szBuffer); <br>      return; <br>   } <br>   va_end(marker); <br> <br> <br>   // Now we have the string to add to the end of our output.  Verify that the <br>   // new string will not be too large and set selection accordingly. <br>   len = (UINT)SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0L); <br>   if(len + lstrlen(pszBuffer) &gt; MAXEDITBUFF) {    //  Need to truncate <br>      SendMessage(hwnd, EM_SETSEL, 0, MAKELPARAM(0,len + 10)); <br>      SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)((LPSTR)"...\r\n")); <br>      SendMessage(hwnd, EM_SETSEL, 0, MAKELPARAM(len,len)); <br>   } <br>   SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)((LPSTR)pszBuffer)); <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//|  szMessageBox: <br>//|      Works like sprintf only the output goes to a message box. <br>//|  Parms: <br>//|      hwnd           Owner window, NULL uses GetActiveWindow <br>//|      style          Flags for MessageBox <br>//|      szTitle        Title for message box <br>//|      szFmt          Format string <br>//|      (varying)      Arguements for format string <br>//|  Returns: <br>//|      Id from MessageBox <br>//*------------------------------------------------------------------------ <br>int FAR CDECL szMessageBox(HWND hwnd, UINT style, LPSTR szTitle, LPSTR szFmt, ...) <br>{ <br>   char        szBuffer[MAXBUFF]; <br>   char *      pszBuffer; <br>   UCHAR       bufFmt[MAXBUFF]; <br>   va_list     marker; <br> <br>   pszBuffer = &amp;szBuffer[0]; <br>   lstrcpy(bufFmt, szFmt); <br> <br>   // Use format and arguements as input <br>   va_start(marker, szFmt); <br>   if (_vsnprintf(pszBuffer, MAXBUFF, bufFmt, marker) &lt; 0) <br>      wsprintf(pszBuffer,"Buffer overflow reporting '%*.*s'", 50,50,szBuffer); <br>   va_end(marker); <br> <br>   return(MessageBox((hwnd) ? hwnd : GetActiveWindow(), <br>                     pszBuffer, <br>                     szTitle, <br>                     style) == IDOK); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
