<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INFO.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2264"></a>INFO.C</h2>
<pre><code>//*--------------------------------------------------------------------------------- <br>//|  ODBC System Administrator <br>//| <br>//|  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>//|  intended for example purposes only. <br>//| <br>//|   Title:   INFO.C <br>//|      This module contains the functions which handle the Info menu items. <br>//|         This module relies on RESULTS and EXECUTE to  <br>//|      This file contains the actual code to execute SQL Statements and <br>//|         display them.  This file is dependent on the SA Tool data structures <br>//|         and the independent module RESULTS. <br>//| <br>//|      NOTE:  Due to the timing of this sample, only the 1.0 GetInfo constants <br>//|         are shown.  To see all GetInfo constants for a 2.0 driver, use the <br>//|         ODBC Test Tool which comes with this SDK. <br>//*--------------------------------------------------------------------------------- <br>#include "info.h" <br>#include "ini.h" <br>#include "sql.h" <br>#include "sqlext.h" <br>#include "stdlib.h" <br>#include "strings.h" <br>VSZFile; <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Defines and macros <br>//*--------------------------------------------------------------------------------- <br>#define MAXNAME            35 <br>#define MAXPARMS           18 <br>#define MAXSQL             300 <br> <br>#define szCOMMA            "," <br>#define szBLANK            " " <br> <br>typedef struct tagNEWPIPE { <br>   HWND        hwnd; <br>   HINSTANCE   hInst; <br>   char        szName[MAXNAME]; <br>   BOOL        fSuccess; <br>} NEWPIPE; <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Local Function Prototypes <br>//*--------------------------------------------------------------------------------- <br>BOOL EXTFUN EditPipeWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam); <br>void NewPipe(NEWPIPE FAR * np); <br>BOOL EXTFUN NewPipeWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam); <br>BOOL EXTFUN DoPipeWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam); <br>void DoPipe(RESULTSSET FAR * rs, CHILDINFO FAR * ci, LPSTR szPipeName, <br>         int FAR xPipes[], int cbCnt); <br>void DoPipeByValue(RESULTSSET FAR * rs, CHILDINFO FAR * ci, LPSTR sqlpsql, <br>      LPSTR szparms, int FAR xPipes[], int cbCnt, LPSTR szPipeName); <br>void PrepareParmList(LPSTR str); <br>SDWORD RefreshList(HWND hDlg, RESULTSSET FAR * rs, CHILDINFO FAR * ci, int state,  <br>         LPSTR szQual, LPSTR szOwner, LPSTR szName, int cbCols); <br>SDWORD RefreshPipeList(HWND hDlg); <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Global variables <br>//*--------------------------------------------------------------------------------- <br>extern dCSEG(char) szMSSansSerif[]; <br>extern dCSEG(char) szPIPES[]; <br>extern dCSEG(char) szFONT[]; <br>extern char        OutStr[MAXBUFF]; <br>extern dCSEG(char) szVALUE[]; <br> <br>dCSEG(char) szISO92[]            =  "ISO 92"; <br>dCSEG(char) szXOpen[]            =  "X/Open"; <br>dCSEG(char) szODBC[]             =  "ODBC"; <br>dCSEG(char) szDepr[]             =  "Deprecated"; <br> <br>dCSEG(char) szCore[]             =  "Core"; <br>dCSEG(char) szLvl1[]             =  "Level 1"; <br>dCSEG(char) szLvl2[]             =  "Level 2"; <br> <br>dCSEG(char) szYes[]              =  "Yes"; <br>dCSEG(char) szNo[]               =  "No"; <br> <br>dCSEG(char) szODBCFunctions[]    =  "Functions"; <br>dCSEG(char) szODBCDataSources[]  =  "Data Sources"; <br>dCSEG(char) szODBCDataTypes[]    =  "Data Types"; <br>dCSEG(char) szGetInfoTitle[]     =  "Get Info"; <br>dCSEG(char) szQualifier[]        =  "Qualifier"; <br>dCSEG(char) szOwner[]            =  "Owner"; <br>dCSEG(char) szName[]             =  "Name"; <br>dCSEG(char) szType[]             =  "Type"; <br>dCSEG(char) szSQL[]              =  "Sql"; <br>dCSEG(char) szPARMS[]            =  "Parms"; <br>dCSEG(char) szPARMOPT[]          =  "ParmOpt"; <br>dCSEG(char) szDELETEOPT[]        =  "Delete"; <br>dCSEG(char) szBothTypes[]        =  "'%s','%s'"; <br>dCSEG(char) szOneType[]          =  "'%s'"; <br>dCSEG(char) szBlank[]            =  " "; <br>dCSEG(char) szTABLETYPE[]        =  "TABLE"; <br>dCSEG(char) szVIEWTYPE[]         =  "VIEW"; <br>dCSEG(char) szVALUE[]            =  "value"; <br>dCSEG(char) szADDRESS[]          =  "address"; <br>dCSEG(char) szDeletePipe[]       =  "Delete pipe %s?"; <br>dCSEG(char) szEditPipe[]         =  "Edit Pipe"; <br>dCSEG(char) szDuplicatePipe[]    =  "Pipe already exists"; <br>dCSEG(char) szInstalled[]        =  "Installed"; <br>dCSEG(char) szDROPPROCSEMI[]     =  "Drop Procedure (with semi-colon)"; <br> <br>static char szErrorMsgTitle[]    =  "Error"; <br> <br> <br> <br>struct { <br>   UWORD          fFunction;                 // Identifier for SQLGetFunctions <br>   LPSTR          szLevel;                   // Conformance Level <br>   int            idFunction;                // String table identifier for function name <br>   } ODBCFunctions[] = { <br> <br>// fFunction                        szLevel           idFunction <br>// -------------------------------  ---------------   -------------------------------- <br> <br>// ---- ISO 92 Conformance ----------------------------------- <br>   {SQL_API_SQLALLOCHANDLE,          (LPSTR)szISO92,    idsSQLAllocHandle}, <br>   {SQL_API_SQLBINDCOL,              (LPSTR)szISO92,    idsSQLBindCol}, <br>   {SQL_API_SQLCANCEL,               (LPSTR)szISO92,    idsSQLCancel}, <br>   {SQL_API_SQLCLOSECURSOR,          (LPSTR)szISO92,    idsSQLCloseCursor}, <br>   {SQL_API_SQLCOLATTRIBUTE,         (LPSTR)szISO92,    idsSQLColAttribute}, <br>   {SQL_API_SQLCONNECT,              (LPSTR)szISO92,    idsSQLConnect}, <br>   {SQL_API_SQLCOPYDESC,             (LPSTR)szISO92,    idsSQLCopyDesc}, <br>   {SQL_API_SQLDATASOURCES,          (LPSTR)szISO92,    idsSQLDataSources}, <br>   {SQL_API_SQLDESCRIBECOL,          (LPSTR)szISO92,    idsSQLDescribeCol}, <br>   {SQL_API_SQLDISCONNECT,           (LPSTR)szISO92,    idsSQLDisconnect}, <br>   {SQL_API_SQLENDTRAN,              (LPSTR)szISO92,    idsSQLEndTran}, <br>   {SQL_API_SQLEXECDIRECT,           (LPSTR)szISO92,    idsSQLExecDirect}, <br>   {SQL_API_SQLEXECUTE,              (LPSTR)szISO92,    idsSQLExecute}, <br>   {SQL_API_SQLFETCH,                (LPSTR)szISO92,    idsSQLFetch}, <br>   {SQL_API_SQLFETCHSCROLL,          (LPSTR)szISO92,    idsSQLFetchScroll}, <br>   {SQL_API_SQLFREEHANDLE,           (LPSTR)szISO92,    idsSQLFreeHandle}, <br>   {SQL_API_SQLFREESTMT,             (LPSTR)szISO92,    idsSQLFreeStmt}, <br>   {SQL_API_SQLGETCONNECTATTR,       (LPSTR)szISO92,    idsSQLGetConnectAttr}, <br>   {SQL_API_SQLGETCURSORNAME,        (LPSTR)szISO92,    idsSQLGetCursorName}, <br>   {SQL_API_SQLGETDATA,              (LPSTR)szISO92,    idsSQLGetData}, <br>   {SQL_API_SQLGETDESCFIELD,         (LPSTR)szISO92,    idsSQLGetDescField}, <br>   {SQL_API_SQLGETDESCREC,           (LPSTR)szISO92,    idsSQLGetDescRec}, <br>   {SQL_API_SQLGETDIAGFIELD,         (LPSTR)szISO92,    idsSQLGetDiagField}, <br>   {SQL_API_SQLGETDIAGREC,           (LPSTR)szISO92,    idsSQLGetDiagRec}, <br>   {SQL_API_SQLGETFUNCTIONS,         (LPSTR)szISO92,    idsSQLGetFunctions}, <br>   {SQL_API_SQLGETINFO,              (LPSTR)szISO92,    idsSQLGetInfo}, <br>   {SQL_API_SQLGETSTMTATTR,          (LPSTR)szISO92,    idsSQLGetStmtAttr}, <br>   {SQL_API_SQLGETTYPEINFO,          (LPSTR)szISO92,    idsSQLGetTypeInfo}, <br>   {SQL_API_SQLGETSTMTATTR,          (LPSTR)szISO92,    idsSQLGetStmtAttr}, <br>   {SQL_API_SQLNUMRESULTCOLS,        (LPSTR)szISO92,    idsSQLNumResultCols}, <br>   {SQL_API_SQLPREPARE,              (LPSTR)szISO92,    idsSQLPrepare}, <br>   {SQL_API_SQLPUTDATA,              (LPSTR)szISO92,    idsSQLPutData}, <br>   {SQL_API_SQLROWCOUNT,             (LPSTR)szISO92,    idsSQLRowCount}, <br>   {SQL_API_SQLSETCONNECTATTR,       (LPSTR)szISO92,    idsSQLGetConnectAttr}, <br>   {SQL_API_SQLSETCURSORNAME,        (LPSTR)szISO92,    idsSQLSetCursorName}, <br>   {SQL_API_SQLSETDESCFIELD,         (LPSTR)szISO92,    idsSQLSetDescField}, <br>   {SQL_API_SQLSETDESCREC,           (LPSTR)szISO92,    idsSQLSetDescRec}, <br>   {SQL_API_SQLSETENVATTR,           (LPSTR)szISO92,    idsSQLSetEnvAttr}, <br>   {SQL_API_SQLSETSTMTATTR,          (LPSTR)szISO92,    idsSQLSetStmtAttr}, <br> <br>   //---- X/Open Conformance -----------------------------------   <br>   {SQL_API_SQLCOLUMNS,              (LPSTR)szXOpen,   idsSQLColumns}, <br>   {SQL_API_SQLGETENVATTR,           (LPSTR)szXOpen,   idsSQLGetEnvAttr}, <br>   {SQL_API_SQLSPECIALCOLUMNS,       (LPSTR)szXOpen,   idsSQLSpecialColumns}, <br>   {SQL_API_SQLSTATISTICS,           (LPSTR)szXOpen,   idsSQLStatistics}, <br>   {SQL_API_SQLTABLES,               (LPSTR)szXOpen,   idsSQLTables}, <br> <br>   //---- ODBC Conformance ------------------------------------- <br>   {SQL_API_SQLBINDPARAMETER,        (LPSTR)szODBC,    idsSQLBindParameter}, <br>   {SQL_API_SQLBROWSECONNECT,        (LPSTR)szODBC,    idsSQLBrowseConnect}, <br>   {SQL_API_SQLBULKOPERATIONS,       (LPSTR)szODBC,    idsSQLBulkOperations}, <br>   {SQL_API_SQLCOLUMNPRIVILEGES,     (LPSTR)szODBC,    idsSQLColumnPrivileges}, <br>   {SQL_API_SQLDESCRIBEPARAM,        (LPSTR)szODBC,    idsSQLDescribeParam}, <br>   {SQL_API_SQLDRIVERCONNECT,        (LPSTR)szODBC,    idsSQLDriverConnect}, <br>   {SQL_API_SQLFOREIGNKEYS,          (LPSTR)szODBC,    idsSQLForeignKeys}, <br>   {SQL_API_SQLMORERESULTS,          (LPSTR)szODBC,    idsSQLMoreResults}, <br>   {SQL_API_SQLNATIVESQL,            (LPSTR)szODBC,    idsSQLNativeSQL}, <br>   {SQL_API_SQLNUMPARAMS,            (LPSTR)szODBC,    idsSQLNumParams}, <br>   {SQL_API_SQLPRIMARYKEYS,          (LPSTR)szODBC,    idsSQLPrimaryKeys}, <br>   {SQL_API_SQLPROCEDURECOLUMNS,     (LPSTR)szODBC,    idsSQLProcedureColumns}, <br>   {SQL_API_SQLPROCEDURES,           (LPSTR)szODBC,    idsSQLProcedures}, <br>   {SQL_API_SQLSETPOS,               (LPSTR)szODBC,    idsSQLSetPos}, <br>   {SQL_API_SQLTABLEPRIVILEGES,      (LPSTR)szODBC,    idsSQLTablePrivileges}, <br> <br>   //---- Deprecated ---------------------------------------- <br>   {SQL_API_SQLALLOCCONNECT,         (LPSTR)szDepr,    idsSQLAllocConnect}, <br>   {SQL_API_SQLALLOCENV,             (LPSTR)szDepr,    idsSQLAllocEnv}, <br>   {SQL_API_SQLALLOCSTMT,            (LPSTR)szDepr,    idsSQLAllocStmt}, <br>   {SQL_API_SQLBINDPARAM,            (LPSTR)szDepr,    idsSQLBindParam}, <br>   {SQL_API_SQLCOLATTRIBUTES,        (LPSTR)szDepr,    idsSQLColAttributes}, <br>   {SQL_API_SQLERROR,                (LPSTR)szDepr,    idsSQLError}, <br>   {SQL_API_SQLEXTENDEDFETCH,        (LPSTR)szDepr,    idsSQLExtendedFetch}, <br>   {SQL_API_SQLFREECONNECT,          (LPSTR)szDepr,    idsSQLFreeConnect}, <br>   {SQL_API_SQLFREEENV,              (LPSTR)szDepr,    idsSQLFreeEnv}, <br>   {SQL_API_SQLGETCONNECTOPTION,     (LPSTR)szDepr,    idsSQLGetConnectOption}, <br>   {SQL_API_SQLGETSTMTOPTION,        (LPSTR)szDepr,    idsSQLGetStmtOption}, <br>   {SQL_API_SQLPARAMOPTIONS,         (LPSTR)szDepr,    idsSQLParamOptions}, <br>   {SQL_API_SQLSETCONNECTOPTION,     (LPSTR)szDepr,    idsSQLSetConnectOption}, <br>   {SQL_API_SQLSETPARAM,             (LPSTR)szDepr,    idsSQLSetParam}, <br>   {SQL_API_SQLSETSCROLLOPTIONS,     (LPSTR)szDepr,    idsSQLSetScrollOptions}, <br>   {SQL_API_SQLSETSTMTOPTION,        (LPSTR)szDepr,    idsSQLSetStmtOption}, <br>   {SQL_API_SQLTRANSACT,             (LPSTR)szDepr,    idsSQLTransact}, <br>   }; <br> <br> <br>// <br>// Generic prototype for bitmap and value lists <br>//  <br>// This structure is used for to locate both bitmap and enumeration values. <br>// Values may appear in the list in any order.  If a value is aliased, the <br>// second value in an enumeration list will not be found; however, a bitmap <br>// entry would show both aliases as being set. <br>// <br>typedef struct tagINFOSTRUCT { <br>   UDWORD         fVal;                      // Which constant <br>   LPSTR          szStr;                     // Print String <br>   } INFOSTRUCT; <br>typedef INFOSTRUCT FAR * lpINFOSTRUCT; <br> <br>// <br>// This macro is used to build rows of the INFOSTRUCT arrays <br>// guaranteeing that the "print" string is the same as the <br>// INFO manifest constant. <br>// <br>#define INFO_VALUE_ROW(tag) {tag, #tag} <br> <br> <br> <br>// <br>// Structure for SQL_ALTER_DOMAIN <br>// <br>static INFOSTRUCT GetInfoAlterDomain[] = { <br>INFO_VALUE_ROW( SQL_AD_ADD_DOMAIN_CONSTRAINT               ), <br>INFO_VALUE_ROW( SQL_AD_DROP_DOMAIN_CONSTRAINT              ), <br>INFO_VALUE_ROW( SQL_AD_ADD_DOMAIN_DEFAULT                  ), <br>INFO_VALUE_ROW( SQL_AD_DROP_DOMAIN_DEFAULT                 ), <br>INFO_VALUE_ROW( SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED   ), <br>INFO_VALUE_ROW( SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE  ), <br>INFO_VALUE_ROW( SQL_AD_ADD_CONSTRAINT_DEFERRABLE           ), <br>INFO_VALUE_ROW( SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE       ), <br>}; <br> <br>// <br>// Structure for SQL_ALTER_TABLE <br>// <br>static INFOSTRUCT GetInfoAlterTable[] = { <br>INFO_VALUE_ROW( SQL_AT_ADD_COLUMN_SINGLE                   ), <br>INFO_VALUE_ROW( SQL_AT_ADD_CONSTRAINT                      ), <br>INFO_VALUE_ROW( SQL_AT_ADD_COLUMN_DEFAULT                  ), <br>INFO_VALUE_ROW( SQL_AT_ADD_COLUMN_COLLATION                ), <br>INFO_VALUE_ROW( SQL_AT_SET_COLUMN_DEFAULT                  ), <br>INFO_VALUE_ROW( SQL_AT_DROP_COLUMN_DEFAULT                 ), <br>INFO_VALUE_ROW( SQL_AT_DROP_COLUMN_CASCADE                 ), <br>INFO_VALUE_ROW( SQL_AT_DROP_COLUMN_RESTRICT                ), <br>INFO_VALUE_ROW( SQL_AT_ADD_TABLE_CONSTRAINT                ), <br>INFO_VALUE_ROW( SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE       ), <br>INFO_VALUE_ROW( SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT      ), <br>INFO_VALUE_ROW( SQL_AT_CONSTRAINT_NAME_DEFINITION          ), <br>INFO_VALUE_ROW( SQL_AT_CONSTRAINT_INITIALLY_DEFERRED       ), <br>INFO_VALUE_ROW( SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE      ), <br>INFO_VALUE_ROW( SQL_AT_CONSTRAINT_DEFERRABLE               ), <br>INFO_VALUE_ROW( SQL_AT_CONSTRAINT_NON_DEFERRABLE           ), <br>}; <br> <br>// <br>// Structure for SQL_ANSI_ASYNC_MODE <br>// <br>static INFOSTRUCT GetInfoAsyncMode[] = { <br>INFO_VALUE_ROW( SQL_AM_NONE                                ), <br>INFO_VALUE_ROW( SQL_AM_CONNECTION                          ), <br>INFO_VALUE_ROW( SQL_AM_STATEMENT                           ), <br>}; <br> <br> <br> <br>// <br>// Structure for SQL_BATCH_ROW_COUNT <br>// <br>static INFOSTRUCT GetInfoBatchRowCount[] = { <br>INFO_VALUE_ROW( SQL_BRC_ROLLED_UP                          ), <br>INFO_VALUE_ROW( SQL_BRC_PROCEDURES                         ), <br>INFO_VALUE_ROW( SQL_BRC_EXPLICIT                           ), <br>}; <br> <br>// <br>// Structure for SQL_BATCH_SUPPORT <br>// <br>static INFOSTRUCT GetInfoBatchSupport[] = { <br>INFO_VALUE_ROW( SQL_BS_SELECT_EXPLICIT                     ), <br>INFO_VALUE_ROW( SQL_BS_ROW_COUNT_EXPLICIT                  ), <br>INFO_VALUE_ROW( SQL_BS_SELECT_PROC                         ), <br>INFO_VALUE_ROW( SQL_BS_ROW_COUNT_PROC                      ), <br>}; <br> <br>// <br>// Structure for SQL_BOOKMARK_PERSISTENCE <br>// <br>static INFOSTRUCT GetInfoBookmarkPersist[] = { <br>INFO_VALUE_ROW( SQL_BP_CLOSE                               ), <br>INFO_VALUE_ROW( SQL_BP_DELETE                              ), <br>INFO_VALUE_ROW( SQL_BP_DROP                                ), <br>INFO_VALUE_ROW( SQL_BP_TRANSACTION                         ), <br>INFO_VALUE_ROW( SQL_BP_UPDATE                              ), <br>INFO_VALUE_ROW( SQL_BP_OTHER_HSTMT                         ), <br>}; <br> <br>// <br>// Structure for SQL_CATALOG_LOCATION <br>// <br>static INFOSTRUCT GetInfoCatLocation[] = { <br>INFO_VALUE_ROW( SQL_CL_START                               ), <br>INFO_VALUE_ROW( SQL_CL_END                                 ), <br>}; <br> <br> <br> <br>// <br>// Structure for SQL_CATALOG_USAGE <br>// <br>static INFOSTRUCT GetInfoCatUsage[] = { <br>INFO_VALUE_ROW( SQL_CU_DML_STATEMENTS                      ), <br>INFO_VALUE_ROW( SQL_CU_PROCEDURE_INVOCATION                ), <br>INFO_VALUE_ROW( SQL_CU_TABLE_DEFINITION                    ), <br>INFO_VALUE_ROW( SQL_CU_INDEX_DEFINITION                    ), <br>INFO_VALUE_ROW( SQL_CU_PRIVILEGE_DEFINITION                ), <br>}; <br> <br>// <br>// Structure for SQL_CONCAT_NULL_BEHAVIOR <br>// <br>static INFOSTRUCT GetInfoConcat[] = { <br>INFO_VALUE_ROW( SQL_CB_NULL                                ), <br>INFO_VALUE_ROW( SQL_CB_NON_NULL                            ), <br>}; <br> <br>// <br>// Structure for SQL_CONVERT_xxxx <br>// <br>static INFOSTRUCT GetInfoConvertTypes[] = { <br>INFO_VALUE_ROW( SQL_CVT_BIGINT                             ), <br>INFO_VALUE_ROW( SQL_CVT_BINARY                             ), <br>INFO_VALUE_ROW( SQL_CVT_BIT                                ), <br>INFO_VALUE_ROW( SQL_CVT_CHAR                               ), <br>INFO_VALUE_ROW( SQL_CVT_DATE                               ), <br>INFO_VALUE_ROW( SQL_CVT_DECIMAL                            ), <br>INFO_VALUE_ROW( SQL_CVT_DOUBLE                             ), <br>INFO_VALUE_ROW( SQL_CVT_FLOAT                              ), <br>INFO_VALUE_ROW( SQL_CVT_INTEGER                            ), <br>INFO_VALUE_ROW( SQL_CVT_INTERVAL_YEAR_MONTH                ), <br>INFO_VALUE_ROW( SQL_CVT_INTERVAL_DAY_TIME                  ), <br>INFO_VALUE_ROW( SQL_CVT_LONGVARBINARY                      ), <br>INFO_VALUE_ROW( SQL_CVT_LONGVARCHAR                        ), <br>INFO_VALUE_ROW( SQL_CVT_NUMERIC                            ), <br>INFO_VALUE_ROW( SQL_CVT_REAL                               ), <br>INFO_VALUE_ROW( SQL_CVT_SMALLINT                           ), <br>INFO_VALUE_ROW( SQL_CVT_TIME                               ), <br>INFO_VALUE_ROW( SQL_CVT_TIMESTAMP                          ), <br>INFO_VALUE_ROW( SQL_CVT_TINYINT                            ), <br>INFO_VALUE_ROW( SQL_CVT_VARBINARY                          ), <br>INFO_VALUE_ROW( SQL_CVT_VARCHAR                            ), <br>INFO_VALUE_ROW( SQL_CVT_WCHAR                              ), <br>INFO_VALUE_ROW( SQL_CVT_WLONGVARCHAR                       ), <br>INFO_VALUE_ROW( SQL_CVT_WVARCHAR                           ), <br>}; <br> <br>// <br>// Structure for SQL_CONVERT_FUNCTIONS <br>// <br>static INFOSTRUCT GetInfoConvertFunctions[] = { <br>INFO_VALUE_ROW( SQL_FN_CVT_CAST                            ), <br>INFO_VALUE_ROW( SQL_FN_CVT_CONVERT                         ), <br>}; <br> <br>// <br>// Structure for SQL_CORRELATION_NAME <br>// <br>static INFOSTRUCT GetInfoCorrelationName[] = { <br>INFO_VALUE_ROW( SQL_CN_NONE                                ), <br>INFO_VALUE_ROW( SQL_CN_DIFFERENT                           ), <br>INFO_VALUE_ROW( SQL_CN_ANY                                 ), <br>}; <br> <br>// <br>// Structure for SQL_CREATE_ASSERTION <br>// <br>static INFOSTRUCT GetInfoCreateAssertion[] = { <br>INFO_VALUE_ROW( SQL_CA_CREATE_ASSERTION                    ), <br>INFO_VALUE_ROW( SQL_CA_CONSTRAINT_INITIALLY_DEFERRED       ), <br>INFO_VALUE_ROW( SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE      ), <br>INFO_VALUE_ROW( SQL_CA_CONSTRAINT_DEFERRABLE               ), <br>INFO_VALUE_ROW( SQL_CA_CONSTRAINT_NON_DEFERRABLE           ), <br>}; <br> <br>// <br>// Structure for SQL_CREATE_CHARACTER_SET <br>// <br>static INFOSTRUCT GetInfoCreateCharset[] = { <br>INFO_VALUE_ROW( SQL_CCS_CREATE_CHARACTER_SET               ), <br>INFO_VALUE_ROW( SQL_CCS_COLLATE_CLAUSE                     ), <br>INFO_VALUE_ROW( SQL_CCS_LIMITED_COLLATION                  ), <br>}; <br> <br>// <br>// Structure for SQL_CREATE_COLLATION <br>// <br>static INFOSTRUCT GetInfoCreateCollation[] = { <br>INFO_VALUE_ROW( SQL_CCOL_CREATE_COLLATION                  ), <br>}; <br> <br>// <br>// Structure for SQL_CREATE_DOMAIN <br>// <br>static INFOSTRUCT GetInfoCreateDomain[] = { <br>INFO_VALUE_ROW( SQL_CDO_CREATE_DOMAIN                      ), <br>INFO_VALUE_ROW( SQL_CDO_CONSTRAINT                         ), <br>INFO_VALUE_ROW( SQL_CDO_DEFAULT                            ), <br>INFO_VALUE_ROW( SQL_CDO_COLLATION                          ), <br>INFO_VALUE_ROW( SQL_CDO_CONSTRAINT_NAME_DEFINITION         ), <br>INFO_VALUE_ROW( SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED      ), <br>INFO_VALUE_ROW( SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE     ), <br>INFO_VALUE_ROW( SQL_CDO_CONSTRAINT_DEFERRABLE              ), <br>INFO_VALUE_ROW( SQL_CDO_CONSTRAINT_NON_DEFERRABLE          ), <br>}; <br> <br>// <br>// Structure for SQL_CREATE_SCHEMA <br>// <br>static INFOSTRUCT GetInfoCreateSchema[] = { <br>INFO_VALUE_ROW( SQL_CS_CREATE_SCHEMA                       ), <br>INFO_VALUE_ROW( SQL_CS_AUTHORIZATION                       ), <br>INFO_VALUE_ROW( SQL_CS_DEFAULT_CHARACTER_SET               ), <br>}; <br> <br>// <br>// Structure for SQL_CREATE_TABLE <br>// <br>static INFOSTRUCT GetInfoCreateTable[] = { <br>INFO_VALUE_ROW( SQL_CT_COMMIT_PRESERVE                     ), <br>INFO_VALUE_ROW( SQL_CT_COMMIT_DELETE                       ), <br>INFO_VALUE_ROW( SQL_CT_GLOBAL_TEMPORARY                    ), <br>INFO_VALUE_ROW( SQL_CT_LOCAL_TEMPORARY                     ), <br>INFO_VALUE_ROW( SQL_CT_CONSTRAINT_INITIALLY_DEFERRED       ), <br>INFO_VALUE_ROW( SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE      ), <br>INFO_VALUE_ROW( SQL_CT_CONSTRAINT_DEFERRABLE               ), <br>INFO_VALUE_ROW( SQL_CT_CONSTRAINT_NON_DEFERRABLE           ), <br>}; <br> <br>// <br>// Structure for SQL_CREATE_TRANSLATION <br>// <br>static INFOSTRUCT GetInfoCreateXlation[] = { <br>INFO_VALUE_ROW( SQL_CTR_CREATE_TRANSLATION                 ), <br>}; <br> <br>// <br>// Structure for SQL_CREATE_VIEW <br>// <br>static INFOSTRUCT GetInfoCreateView[] = { <br>INFO_VALUE_ROW( SQL_CV_CREATE_VIEW                         ), <br>INFO_VALUE_ROW( SQL_CV_CHECK_OPTION                        ), <br>INFO_VALUE_ROW( SQL_CV_CASCADED                            ), <br>INFO_VALUE_ROW( SQL_CV_LOCAL                               ), <br>}; <br> <br>// <br>// Structure for SQL_CURSOR_COMMIT_BEHAVIOR, <br>//               SQL_CURSOR_ROLLBACK_BEHAVIOR <br>// <br>static INFOSTRUCT GetInfoCommit[] = { <br>INFO_VALUE_ROW( SQL_CB_DELETE                              ), <br>INFO_VALUE_ROW( SQL_CB_CLOSE                               ), <br>INFO_VALUE_ROW( SQL_CB_PRESERVE                            ), <br>}; <br> <br>// <br>// Structure for SQL_CURSOR_SENSITIVITY <br>// <br>static INFOSTRUCT GetInfoCursorSensitiv[] = { <br>INFO_VALUE_ROW( SQL_INSENSITIVE                            ), <br>INFO_VALUE_ROW( SQL_UNSPECIFIED                            ), <br>INFO_VALUE_ROW( SQL_SENSITIVE                              ), <br>}; <br> <br>// <br>// Structure for SQL_DEFAULT_TXN_ISOLATION <br>// <br>static INFOSTRUCT GetInfoTXNIsolation[] = { <br>INFO_VALUE_ROW( SQL_TXN_READ_UNCOMMITTED                   ), <br>INFO_VALUE_ROW( SQL_TXN_READ_COMMITTED                     ), <br>INFO_VALUE_ROW( SQL_TXN_REPEATABLE_READ                    ), <br>INFO_VALUE_ROW( SQL_TXN_SERIALIZABLE                       ), <br>}; <br> <br>// <br>// Structure for SQL_*_CURSOR_ATTRIBUTES1 <br>// <br>static INFOSTRUCT GetInfoCurAttrs1[] = { <br>INFO_VALUE_ROW( SQL_CA1_NEXT                               ), <br>INFO_VALUE_ROW( SQL_CA1_ABSOLUTE                           ), <br>INFO_VALUE_ROW( SQL_CA1_RELATIVE                           ), <br>INFO_VALUE_ROW( SQL_CA1_BOOKMARK                           ), <br>INFO_VALUE_ROW( SQL_CA1_LOCK_NO_CHANGE                     ), <br>INFO_VALUE_ROW( SQL_CA1_LOCK_UNLOCK                        ), <br>INFO_VALUE_ROW( SQL_CA1_POS_POSITION                       ), <br>INFO_VALUE_ROW( SQL_CA1_POS_UPDATE                         ), <br>INFO_VALUE_ROW( SQL_CA1_POS_DELETE                         ), <br>INFO_VALUE_ROW( SQL_CA1_POS_REFRESH                        ), <br>INFO_VALUE_ROW( SQL_CA1_POSITIONED_UPDATE                  ), <br>INFO_VALUE_ROW( SQL_CA1_POSITIONED_DELETE                  ), <br>INFO_VALUE_ROW( SQL_CA1_SELECT_FOR_UPDATE                  ), <br>INFO_VALUE_ROW( SQL_CA1_BULK_ADD                           ), <br>INFO_VALUE_ROW( SQL_CA1_BULK_UPDATE_BY_BOOKMARK            ), <br>INFO_VALUE_ROW( SQL_CA1_BULK_DELETE_BY_BOOKMARK            ), <br>INFO_VALUE_ROW( SQL_CA1_BULK_FETCH_BY_BOOKMARK             ), <br>}; <br> <br>// <br>// Structure for SQL_*_CURSOR_ATTRIBUTES2 <br>// <br>static INFOSTRUCT GetInfoCurAttrs2[] = { <br>INFO_VALUE_ROW( SQL_CA2_READ_ONLY_CONCURRENCY              ), <br>INFO_VALUE_ROW( SQL_CA2_LOCK_CONCURRENCY                   ), <br>INFO_VALUE_ROW( SQL_CA2_OPT_ROWVER_CONCURRENCY             ), <br>INFO_VALUE_ROW( SQL_CA2_OPT_VALUES_CONCURRENCY             ), <br>INFO_VALUE_ROW( SQL_CA2_SENSITIVITY_ADDITIONS              ), <br>INFO_VALUE_ROW( SQL_CA2_SENSITIVITY_DELETIONS              ), <br>INFO_VALUE_ROW( SQL_CA2_SENSITIVITY_UPDATES                ), <br>INFO_VALUE_ROW( SQL_CA2_MAX_ROWS_SELECT                    ), <br>INFO_VALUE_ROW( SQL_CA2_MAX_ROWS_INSERT                    ), <br>INFO_VALUE_ROW( SQL_CA2_MAX_ROWS_UPDATE                    ), <br>INFO_VALUE_ROW( SQL_CA2_MAX_ROWS_DELETE                    ), <br>INFO_VALUE_ROW( SQL_CA2_MAX_ROWS_CATALOG                   ), <br>INFO_VALUE_ROW( SQL_CA2_MAX_ROWS_AFFECTS_ALL               ), <br>INFO_VALUE_ROW( SQL_CA2_CRC_EXACT                          ), <br>INFO_VALUE_ROW( SQL_CA2_CRC_APPROXIMATE                    ), <br>INFO_VALUE_ROW( SQL_CA2_SIMULATE_NON_UNIQUE                ), <br>INFO_VALUE_ROW( SQL_CA2_SIMULATE_TRY_UNIQUE                ), <br>INFO_VALUE_ROW( SQL_CA2_SIMULATE_UNIQUE                    ), <br>}; <br> <br>// <br>// Structure for SQL_DATETIME_LITERALS <br>// <br>static INFOSTRUCT GetInfoSQLDateLit[] = { <br>INFO_VALUE_ROW( SQL_DL_SQL92_DATE                          ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_TIME                          ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_TIMESTAMP                     ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_YEAR                 ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_MONTH                ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_DAY                  ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_HOUR                 ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_MINUTE               ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_SECOND               ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH        ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR          ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE        ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND        ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE       ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND       ), <br>INFO_VALUE_ROW( SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND     ), <br>}; <br> <br>// <br>// Structure for SQL_DROP_ASSERTION <br>// <br>static INFOSTRUCT GetInfoDropAssertion[] = { <br>INFO_VALUE_ROW( SQL_DA_DROP_ASSERTION                      ), <br>}; <br> <br>// <br>// Structure for SQL_DROP_CHARACTER_SET <br>// <br>static INFOSTRUCT GetInfoDropCharset[] = { <br>INFO_VALUE_ROW( SQL_DCS_DROP_CHARACTER_SET                 ), <br>}; <br> <br>// <br>// Structure for SQL_DROP_COLLATION <br>// <br>static INFOSTRUCT GetInfoDropCollation[] = { <br>INFO_VALUE_ROW( SQL_DC_DROP_COLLATION                      ), <br>}; <br> <br>// <br>// Structure for SQL_DROP_DOMAIN <br>// <br>static INFOSTRUCT GetInfoDropDomain[] = { <br>INFO_VALUE_ROW( SQL_DD_DROP_DOMAIN                         ), <br>INFO_VALUE_ROW( SQL_DD_CASCADE                             ), <br>INFO_VALUE_ROW( SQL_DD_RESTRICT                            ), <br>}; <br> <br>// <br>// Structure for SQL_DROP_SCHEMA <br>// <br>static INFOSTRUCT GetInfoDropSchema[] = { <br>INFO_VALUE_ROW( SQL_DS_DROP_SCHEMA                         ), <br>INFO_VALUE_ROW( SQL_DS_CASCADE                             ), <br>INFO_VALUE_ROW( SQL_DS_RESTRICT                            ), <br>}; <br> <br>// <br>// Structure for SQL_DROP_TABLE <br>// <br>static INFOSTRUCT GetInfoDropTable[] = { <br>INFO_VALUE_ROW( SQL_DT_DROP_TABLE                          ), <br>INFO_VALUE_ROW( SQL_DT_CASCADE                             ), <br>INFO_VALUE_ROW( SQL_DT_RESTRICT                            ), <br>}; <br> <br>// <br>// Structure for SQL_DROP_TRANSLATION <br>// <br>static INFOSTRUCT GetInfoDropXlation[] = { <br>INFO_VALUE_ROW( SQL_DTR_DROP_TRANSLATION                   ), <br>}; <br> <br>// <br>// Structure for SQL_DROP_VIEW <br>// <br>static INFOSTRUCT GetInfoDropView[] = { <br>INFO_VALUE_ROW( SQL_DV_DROP_VIEW                           ), <br>INFO_VALUE_ROW( SQL_DV_CASCADE                             ), <br>INFO_VALUE_ROW( SQL_DV_RESTRICT                            ), <br>}; <br> <br>// <br>// Structure for SQL_FILE_USAGE <br>// <br>static INFOSTRUCT GetInfoFileUsage[] = { <br>INFO_VALUE_ROW( SQL_FILE_NOT_SUPPORTED                     ), <br>INFO_VALUE_ROW( SQL_FILE_TABLE                             ), <br>INFO_VALUE_ROW( SQL_FILE_CATALOG                           ), <br>}; <br> <br>// <br>// Structure for SQL_GETDATA_EXTENSIONS <br>// <br>static INFOSTRUCT GetInfoGetdataExt[] = { <br>INFO_VALUE_ROW( SQL_GD_ANY_COLUMN                          ), <br>INFO_VALUE_ROW( SQL_GD_ANY_ORDER                           ), <br>INFO_VALUE_ROW( SQL_GD_BLOCK                               ), <br>INFO_VALUE_ROW( SQL_GD_BOUND                               ), <br>}; <br> <br>// <br>// Structure for SQL_GROUP_BY <br>// <br>static INFOSTRUCT GetInfoGroupBy[] = { <br>INFO_VALUE_ROW( SQL_GB_NOT_SUPPORTED                       ), <br>INFO_VALUE_ROW( SQL_GB_GROUP_BY_EQUALS_SELECT              ), <br>INFO_VALUE_ROW( SQL_GB_GROUP_BY_CONTAINS_SELECT            ), <br>INFO_VALUE_ROW( SQL_GB_NO_RELATION                         ), <br>INFO_VALUE_ROW( SQL_GB_COLLATE                             ), <br>}; <br> <br>// <br>// Structure for SQL_INDEX_KEYWORDS <br>// <br>static INFOSTRUCT GetInfoIndexKeywords[] = { <br>INFO_VALUE_ROW( SQL_IK_NONE                                ), <br>INFO_VALUE_ROW( SQL_IK_ASC                                 ), <br>INFO_VALUE_ROW( SQL_IK_DESC                                ), <br>INFO_VALUE_ROW( SQL_IK_ALL                                 ), <br>}; <br> <br>// <br>// Structure for SQL_INFO_SCHEMA_VIEWS <br>// <br>static INFOSTRUCT GetInfoInfoSchemaViews[] = { <br>INFO_VALUE_ROW( SQL_ISV_ASSERTIONS                         ), <br>INFO_VALUE_ROW( SQL_ISV_CHARACTER_SETS                     ), <br>INFO_VALUE_ROW( SQL_ISV_CHECK_CONSTRAINTS                  ), <br>INFO_VALUE_ROW( SQL_ISV_COLLATIONS                         ), <br>INFO_VALUE_ROW( SQL_ISV_COLUMN_DOMAIN_USAGE                ), <br>INFO_VALUE_ROW( SQL_ISV_COLUMN_PRIVILEGES                  ), <br>INFO_VALUE_ROW( SQL_ISV_COLUMNS                            ), <br>INFO_VALUE_ROW( SQL_ISV_CONSTRAINT_COLUMN_USAGE            ), <br>INFO_VALUE_ROW( SQL_ISV_CONSTRAINT_TABLE_USAGE             ), <br>INFO_VALUE_ROW( SQL_ISV_ASSERTIONS                         ), <br>INFO_VALUE_ROW( SQL_ISV_DOMAIN_CONSTRAINTS                 ), <br>INFO_VALUE_ROW( SQL_ISV_DOMAINS                            ), <br>INFO_VALUE_ROW( SQL_ISV_KEY_COLUMN_USAGE                   ), <br>INFO_VALUE_ROW( SQL_ISV_REFERENTIAL_CONSTRAINTS            ), <br>INFO_VALUE_ROW( SQL_ISV_SQL_LANGUAGES                      ), <br>INFO_VALUE_ROW( SQL_ISV_TABLE_CONSTRAINTS                  ), <br>INFO_VALUE_ROW( SQL_ISV_TABLE_PRIVILEGES                   ), <br>INFO_VALUE_ROW( SQL_ISV_TABLES                             ), <br>INFO_VALUE_ROW( SQL_ISV_TRANSLATIONS                       ), </code></pre>
<p>
</p>
<pre><code>INFO_VALUE_ROW( SQL_ISV_USAGE_PRIVILEGES                   ), <br>INFO_VALUE_ROW( SQL_ISV_VIEW_COLUMN_USAGE                  ), <br>INFO_VALUE_ROW( SQL_ISV_VIEW_TABLE_USAGE                   ), <br>INFO_VALUE_ROW( SQL_ISV_VIEWS                              ), <br>}; <br> <br>// <br>// Structure for SQL_NON_NULLABLE_COLUMNS <br>// <br>static INFOSTRUCT GetInfoNonNullCols[] = { <br>INFO_VALUE_ROW( SQL_NNC_NULL                               ), <br>INFO_VALUE_ROW( SQL_NNC_NON_NULL                           ), <br>}; <br> <br>// <br>// Structure for SQL_NULL_COLLATION <br>// <br>static INFOSTRUCT GetInfoNullCollation[] = { <br>INFO_VALUE_ROW( SQL_NC_END                                 ), <br>INFO_VALUE_ROW( SQL_NC_HIGH                                ), <br>INFO_VALUE_ROW( SQL_NC_LOW                                 ), <br>INFO_VALUE_ROW( SQL_NC_START                               ), <br>}; <br> <br>// <br>// Structure for SQL_PARAM_ARRAY_ROW_COUNTS <br>// <br>static INFOSTRUCT GetInfoParamRowCounts[] = { <br>INFO_VALUE_ROW( SQL_PARC_BATCH                             ), <br>INFO_VALUE_ROW( SQL_PARC_NO_BATCH                          ), <br>}; <br> <br>// <br>// Structure for SQL_PARAM_ARRAY_SELECTS <br>// <br>static INFOSTRUCT GetInfoParamSelects[] = { <br>INFO_VALUE_ROW( SQL_PAS_BATCH                              ), <br>INFO_VALUE_ROW( SQL_PAS_NO_BATCH                           ), <br>INFO_VALUE_ROW( SQL_PAS_NO_SELECT                          ), <br>}; <br> <br>// <br>// Structure for SQL_SCHEMA_USAGE <br>// <br>static INFOSTRUCT GetInfoSchemaUsage[] = { <br>INFO_VALUE_ROW( SQL_SU_DML_STATEMENTS                      ), <br>INFO_VALUE_ROW( SQL_SU_PROCEDURE_INVOCATION                ), <br>INFO_VALUE_ROW( SQL_SU_TABLE_DEFINITION                    ), <br>INFO_VALUE_ROW( SQL_SU_INDEX_DEFINITION                    ), <br>INFO_VALUE_ROW( SQL_SU_PRIVILEGE_DEFINITION                ), <br>}; <br> <br>// <br>// Structure for SQL_SCROLL_OPTIONS <br>// <br>static INFOSTRUCT GetInfoScrollOptions[] = { <br>INFO_VALUE_ROW( SQL_SO_FORWARD_ONLY                        ), <br>INFO_VALUE_ROW( SQL_SO_KEYSET_DRIVEN                       ), <br>INFO_VALUE_ROW( SQL_SO_DYNAMIC                             ), <br>INFO_VALUE_ROW( SQL_SO_MIXED                               ), <br>}; <br> <br>// <br>// Structure for SQL_SQL_CONFORMANCE <br>// <br>static INFOSTRUCT GetInfoSQLConform[] = { <br>INFO_VALUE_ROW( SQL_SC_SQL92_ENTRY                         ), <br>INFO_VALUE_ROW( SQL_SC_FIPS127_2_TRANSITIONAL              ), <br>INFO_VALUE_ROW( SQL_SC_SQL92_FULL                          ), <br>INFO_VALUE_ROW( SQL_SC_SQL92_INTERMEDIATE                  ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_DATETIME_FUNCTIONS <br>// <br>static INFOSTRUCT GetInfoS92DatetimeFns[] = { <br>INFO_VALUE_ROW( SQL_SDF_CURRENT_DATE                       ), <br>INFO_VALUE_ROW( SQL_SDF_CURRENT_TIME                       ), <br>INFO_VALUE_ROW( SQL_SDF_CURRENT_TIMESTAMP                  ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_FOREIGN_KEY_DELETE_RULE <br>// <br>static INFOSTRUCT GetInfoS92FKeyDelRule[] = { <br>INFO_VALUE_ROW( SQL_SFKD_CASCADE                           ), <br>INFO_VALUE_ROW( SQL_SFKD_NO_ACTION                         ), <br>INFO_VALUE_ROW( SQL_SFKD_SET_DEFAULT                       ), <br>INFO_VALUE_ROW( SQL_SFKD_SET_NULL                          ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_FOREIGN_KEY_UPDATE_RULE <br>// <br>static INFOSTRUCT GetInfoS92FKeyUpdRule[] = { <br>INFO_VALUE_ROW( SQL_SFKU_CASCADE                           ), <br>INFO_VALUE_ROW( SQL_SFKU_NO_ACTION                         ), <br>INFO_VALUE_ROW( SQL_SFKU_SET_DEFAULT                       ), <br>INFO_VALUE_ROW( SQL_SFKU_SET_NULL                          ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_GRANT <br>// <br>static INFOSTRUCT GetInfoS92Grant[] = { <br>INFO_VALUE_ROW( SQL_SG_USAGE_ON_DOMAIN                     ), <br>INFO_VALUE_ROW( SQL_SG_USAGE_ON_CHARACTER_SET              ), <br>INFO_VALUE_ROW( SQL_SG_USAGE_ON_COLLATION                  ), <br>INFO_VALUE_ROW( SQL_SG_USAGE_ON_TRANSLATION                ), <br>INFO_VALUE_ROW( SQL_SG_WITH_GRANT_OPTION                   ), <br>}; <br> <br>// <br>// Structure for SQL_NUMERIC_FUNCTIONS <br>// <br>static INFOSTRUCT GetInfoNumeric[] = { <br>INFO_VALUE_ROW( SQL_FN_NUM_ABS                             ), <br>INFO_VALUE_ROW( SQL_FN_NUM_ACOS                            ), <br>INFO_VALUE_ROW( SQL_FN_NUM_ASIN                            ), <br>INFO_VALUE_ROW( SQL_FN_NUM_ATAN                            ), <br>INFO_VALUE_ROW( SQL_FN_NUM_ATAN2                           ), <br>INFO_VALUE_ROW( SQL_FN_NUM_CEILING                         ), <br>INFO_VALUE_ROW( SQL_FN_NUM_COS                             ), <br>INFO_VALUE_ROW( SQL_FN_NUM_COT                             ), <br>INFO_VALUE_ROW( SQL_FN_NUM_EXP                             ), <br>INFO_VALUE_ROW( SQL_FN_NUM_FLOOR                           ), <br>INFO_VALUE_ROW( SQL_FN_NUM_LOG                             ), <br>INFO_VALUE_ROW( SQL_FN_NUM_MOD                             ), <br>INFO_VALUE_ROW( SQL_FN_NUM_RAND                            ), <br>INFO_VALUE_ROW( SQL_FN_NUM_PI                              ), <br>INFO_VALUE_ROW( SQL_FN_NUM_SIGN                            ), <br>INFO_VALUE_ROW( SQL_FN_NUM_SIN                             ), <br>INFO_VALUE_ROW( SQL_FN_NUM_SQRT                            ), <br>INFO_VALUE_ROW( SQL_FN_NUM_TAN                             ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_NUMERIC_VALUE_FUNCTIONS <br>// <br>static INFOSTRUCT GetInfoS92NumValFns[] = { <br>INFO_VALUE_ROW( SQL_SNVF_BIT_LENGTH                        ), <br>INFO_VALUE_ROW( SQL_SNVF_CHAR_LENGTH                       ), <br>INFO_VALUE_ROW( SQL_SNVF_CHARACTER_LENGTH                  ), <br>INFO_VALUE_ROW( SQL_SNVF_EXTRACT                           ), <br>INFO_VALUE_ROW( SQL_SNVF_OCTET_LENGTH                      ), <br>INFO_VALUE_ROW( SQL_SNVF_POSITION                          ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_PREDICATES <br>// <br>static INFOSTRUCT GetInfoS92Predicates[] = { <br>INFO_VALUE_ROW( SQL_SP_EXISTS                              ), <br>INFO_VALUE_ROW( SQL_SP_ISNOTNULL                           ), <br>INFO_VALUE_ROW( SQL_SP_ISNULL                              ), <br>INFO_VALUE_ROW( SQL_SP_MATCH_FULL                          ), <br>INFO_VALUE_ROW( SQL_SP_MATCH_PARTIAL                       ), <br>INFO_VALUE_ROW( SQL_SP_MATCH_UNIQUE_FULL                   ), <br>INFO_VALUE_ROW( SQL_SP_MATCH_UNIQUE_PARTIAL                ), <br>INFO_VALUE_ROW( SQL_SP_OVERLAPS                            ), <br>INFO_VALUE_ROW( SQL_SP_UNIQUE                              ), <br>INFO_VALUE_ROW( SQL_SP_LIKE                                ), <br>INFO_VALUE_ROW( SQL_SP_IN                                  ), <br>INFO_VALUE_ROW( SQL_SP_BETWEEN                             ), <br>INFO_VALUE_ROW( SQL_SP_COMPARISON                          ), <br>INFO_VALUE_ROW( SQL_SP_QUANTIFIED_COMPARISON               ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_RELATIONAL_JOIN_OPERATORS <br>// <br>static INFOSTRUCT GetInfoS92RelJoinOps[] = { <br>INFO_VALUE_ROW( SQL_SRJO_CORRESPONDING_CLAUSE              ), <br>INFO_VALUE_ROW( SQL_SRJO_CROSS_JOIN                        ), <br>INFO_VALUE_ROW( SQL_SRJO_EXCEPT_JOIN                       ), <br>INFO_VALUE_ROW( SQL_SRJO_FULL_OUTER_JOIN                   ), <br>INFO_VALUE_ROW( SQL_SRJO_INNER_JOIN                        ), <br>INFO_VALUE_ROW( SQL_SRJO_INTERSECT_JOIN                    ), <br>INFO_VALUE_ROW( SQL_SRJO_LEFT_OUTER_JOIN                   ), <br>INFO_VALUE_ROW( SQL_SRJO_NATURAL_JOIN                      ), <br>INFO_VALUE_ROW( SQL_SRJO_RIGHT_OUTER_JOIN                  ), <br>INFO_VALUE_ROW( SQL_SRJO_UNION_JOIN                        ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_REVOKE <br>// <br>static INFOSTRUCT GetInfoS92Revoke[] = { <br>INFO_VALUE_ROW( SQL_SR_USAGE_ON_DOMAIN                     ), <br>INFO_VALUE_ROW( SQL_SR_USAGE_ON_CHARACTER_SET              ), <br>INFO_VALUE_ROW( SQL_SR_USAGE_ON_COLLATION                  ), <br>INFO_VALUE_ROW( SQL_SR_USAGE_ON_TRANSLATION                ), <br>INFO_VALUE_ROW( SQL_SR_GRANT_OPTION_FOR                    ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_ROW_VALUE_CONSTRUCTOR <br>// <br>static INFOSTRUCT GetInfoS92RowValConstr[] = { <br>INFO_VALUE_ROW( SQL_SRVC_VALUE_EXPRESSION                  ), <br>INFO_VALUE_ROW( SQL_SRVC_NULL                              ), <br>INFO_VALUE_ROW( SQL_SRVC_DEFAULT                           ), <br>INFO_VALUE_ROW( SQL_SRVC_ROW_SUBQUERY                      ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_STRING_FUNCTIONS <br>// <br>static INFOSTRUCT GetInfoS92StringFns[] = { <br>INFO_VALUE_ROW( SQL_SSF_CONVERT                            ), <br>INFO_VALUE_ROW( SQL_SSF_LOWER                              ), <br>INFO_VALUE_ROW( SQL_SSF_UPPER                              ), <br>INFO_VALUE_ROW( SQL_SSF_SUBSTRING                          ), <br>INFO_VALUE_ROW( SQL_SSF_TRANSLATE                          ), <br>INFO_VALUE_ROW( SQL_SSF_TRIM_BOTH                          ), <br>INFO_VALUE_ROW( SQL_SSF_TRIM_LEADING                       ), <br>INFO_VALUE_ROW( SQL_SSF_TRIM_TRAILING                      ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_VALUE_EXPRESSIONS <br>// <br>static INFOSTRUCT GetInfoS92ValueExprs[] = { <br>INFO_VALUE_ROW( SQL_SVE_CASE                               ), <br>INFO_VALUE_ROW( SQL_SVE_CAST                               ), <br>INFO_VALUE_ROW( SQL_SVE_COALESCE                           ), <br>INFO_VALUE_ROW( SQL_SVE_NULLIF                             ), <br>}; <br> <br>// <br>// Structure for SQL_SQL92_STANDARD_CLI_CONFORMANCE <br>// <br>static INFOSTRUCT GetInfoS92StdCLIConf[] = { <br>INFO_VALUE_ROW( SQL_SCC_XOPEN_CLI_VERSION1                 ), <br>INFO_VALUE_ROW( SQL_SCC_ISO92_CLI                          ), <br>}; <br> <br>// <br>// Structure for SQL_SUBQUERUIES <br>// <br>static INFOSTRUCT GetInfoSubqueries[] = { <br>INFO_VALUE_ROW( SQL_SQ_CORRELATED_SUBQUERIES               ), <br>INFO_VALUE_ROW( SQL_SQ_COMPARISON                          ), <br>INFO_VALUE_ROW( SQL_SQ_EXISTS                              ), <br>INFO_VALUE_ROW( SQL_SQ_IN                                  ), <br>INFO_VALUE_ROW( SQL_SQ_QUANTIFIED                          ), <br>}; <br> <br>// <br>// Structure for SQL_STRING_FUNCTIONS <br>// <br>static INFOSTRUCT GetInfoStrings[] = { <br>INFO_VALUE_ROW( SQL_FN_STR_ASCII                                         ), <br>INFO_VALUE_ROW( SQL_FN_STR_CHAR                            ), <br>INFO_VALUE_ROW( SQL_FN_STR_CONCAT                          ), <br>INFO_VALUE_ROW( SQL_FN_STR_INSERT                          ), <br>INFO_VALUE_ROW( SQL_FN_STR_LCASE                           ), <br>INFO_VALUE_ROW( SQL_FN_STR_LEFT                            ), <br>INFO_VALUE_ROW( SQL_FN_STR_LENGTH                          ), <br>INFO_VALUE_ROW( SQL_FN_STR_LOCATE                          ), <br>INFO_VALUE_ROW( SQL_FN_STR_LTRIM                           ), <br>INFO_VALUE_ROW( SQL_FN_STR_REPEAT                          ), <br>INFO_VALUE_ROW( SQL_FN_STR_REPLACE                         ), <br>INFO_VALUE_ROW( SQL_FN_STR_RIGHT                           ), <br>INFO_VALUE_ROW( SQL_FN_STR_RTRIM                           ), <br>INFO_VALUE_ROW( SQL_FN_STR_SUBSTRING                       ), <br>INFO_VALUE_ROW( SQL_FN_STR_UCASE                           ), <br>}; <br> <br>// <br>// Structure for SQL_SYSTEM_FUNCTIONS <br>// <br>static INFOSTRUCT GetInfoSystem[] = { <br>INFO_VALUE_ROW( SQL_FN_SYS_DBNAME                          ), <br>INFO_VALUE_ROW( SQL_FN_SYS_IFNULL                          ), <br>INFO_VALUE_ROW( SQL_FN_SYS_USERNAME                        ), <br>}; <br> <br>// <br>// Structure for SQL_TIMEDATE_FUNCTIONS <br>// <br>static INFOSTRUCT GetInfoTimeDate[] = { <br>INFO_VALUE_ROW( SQL_FN_TD_CURDATE                          ), <br>INFO_VALUE_ROW( SQL_FN_TD_CURRENT_DATE                     ), <br>INFO_VALUE_ROW( SQL_FN_TD_CURRENT_TIME                     ), <br>INFO_VALUE_ROW( SQL_FN_TD_CURRENT_TIMESTAMP                ), <br>INFO_VALUE_ROW( SQL_FN_TD_CURTIME                          ), <br>INFO_VALUE_ROW( SQL_FN_TD_DAYOFMONTH                       ), <br>INFO_VALUE_ROW( SQL_FN_TD_DAYOFWEEK                        ), <br>INFO_VALUE_ROW( SQL_FN_TD_DAYOFYEAR                        ), <br>INFO_VALUE_ROW( SQL_FN_TD_EXTRACT                          ), <br>INFO_VALUE_ROW( SQL_FN_TD_HOUR                             ), <br>INFO_VALUE_ROW( SQL_FN_TD_MINUTE                           ), <br>INFO_VALUE_ROW( SQL_FN_TD_MONTH                            ), <br>INFO_VALUE_ROW( SQL_FN_TD_NOW                              ), <br>INFO_VALUE_ROW( SQL_FN_TD_QUARTER                          ), <br>INFO_VALUE_ROW( SQL_FN_TD_SECOND                           ), <br>INFO_VALUE_ROW( SQL_FN_TD_WEEK                             ), <br>INFO_VALUE_ROW( SQL_FN_TD_YEAR                             ), <br>}; <br> <br>// <br>// Structure for SQL_TIMEDATE_ADD_INTERVALS, <br>//               SQL_TIMEDATE_DIFF_INTERVALS, <br>// <br>static INFOSTRUCT GetInfoTimeDateIvls[] = { <br>INFO_VALUE_ROW( SQL_FN_TSI_FRAC_SECOND                     ), <br>INFO_VALUE_ROW( SQL_FN_TSI_SECOND                          ), <br>INFO_VALUE_ROW( SQL_FN_TSI_MINUTE                          ), <br>INFO_VALUE_ROW( SQL_FN_TSI_HOUR                            ), <br>INFO_VALUE_ROW( SQL_FN_TSI_DAY                             ), <br>INFO_VALUE_ROW( SQL_FN_TSI_WEEK                            ), <br>INFO_VALUE_ROW( SQL_FN_TSI_MONTH                           ), <br>INFO_VALUE_ROW( SQL_FN_TSI_QUARTER                         ), <br>INFO_VALUE_ROW( SQL_FN_TSI_YEAR                            ), <br>}; <br> <br>// <br>// Structure for SQL_ODBC_API_CONFORMANCE <br>// <br>static INFOSTRUCT GetInfoAPIConform[] = { <br>INFO_VALUE_ROW( SQL_OIC_CORE                               ), <br>INFO_VALUE_ROW( SQL_OIC_LEVEL1                             ), <br>INFO_VALUE_ROW( SQL_OIC_LEVEL2                             ), <br>}; <br> <br>// <br>// Structure for SQL_ODBC_SQL_CONFORMANCE <br>// <br>static INFOSTRUCT GetInfoODBCSQL[] = { <br>INFO_VALUE_ROW( SQL_OSC_MINIMUM                            ), <br>INFO_VALUE_ROW( SQL_OSC_CORE                               ), <br>INFO_VALUE_ROW( SQL_OSC_EXTENDED                           ), <br>}; <br> <br>// <br>// Structure for SQL_IDENTIFIER_CASE <br>// <br>static INFOSTRUCT GetInfoIDCase[] = { <br>INFO_VALUE_ROW( SQL_IC_UPPER                               ), <br>INFO_VALUE_ROW( SQL_IC_LOWER                               ), <br>INFO_VALUE_ROW( SQL_IC_SENSITIVE                           ), <br>INFO_VALUE_ROW( SQL_IC_MIXED                               ), <br>}; <br> <br>// <br>// Structure for SQL_TXN_CAPABLE <br>// <br>static INFOSTRUCT GetInfoTxnCapable[] = { <br>INFO_VALUE_ROW( SQL_TC_NONE                                ), <br>INFO_VALUE_ROW( SQL_TC_DML                                 ), <br>INFO_VALUE_ROW( SQL_TC_DDL_COMMIT                          ), <br>INFO_VALUE_ROW( SQL_TC_DDL_IGNORE                          ), <br>INFO_VALUE_ROW( SQL_TC_ALL                                 ), <br>}; <br> <br>// <br>// Structure for SQL_TXN_ISOLATION_OPTIONS <br>// <br>static INFOSTRUCT GetInfoTxnIsoOptions[] = { <br>INFO_VALUE_ROW( SQL_TXN_READ_UNCOMMITTED                   ), <br>INFO_VALUE_ROW( SQL_TXN_READ_COMMITTED                     ), <br>INFO_VALUE_ROW( SQL_TXN_REPEATABLE_READ                    ), <br>INFO_VALUE_ROW( SQL_TXN_SERIALIZABLE                       ), <br>}; <br> <br>// <br>// Structure for SQL_UNION <br>// <br>static INFOSTRUCT GetInfoUnion[] = { <br>INFO_VALUE_ROW( SQL_U_UNION                                ), <br>INFO_VALUE_ROW( SQL_U_UNION_ALL                            ), <br>}; <br> <br> <br>// <br>// The following structure is used to retrieve information about the driver.  There <br>//    are 5 types of GetInfo structures: <br>//          INT16       16-bit value <br>//          INT32       32-bit value <br>//          STRVAL      String value <br>//          DEXVAL      Indexed item (eg: 0-x) <br>//          BITVAL      Bit-mask value <br>// <br>char           szGetInfo[MAXBUFF]; <br>UWORD          cb16; <br>UDWORD         cb32; <br>#define        INT16             1 <br>#define        INT32             2 <br>#define        STRVAL            3 <br>#define        DEXVAL            4 <br>#define        BITVAL            5 <br> <br>#define INFOROW(name, string, type, addr, varsize, ptr, size) {name, string, type, addr, varsize, ptr, size} <br> <br>#define INT16_ITEM(name)        INFOROW(name, #name, INT16,  &amp;cb16,      sizeof(cb16), NULL, 0) <br>#define INT32_ITEM(name)        INFOROW(name, #name, INT32,  &amp;cb32,      sizeof(cb32), NULL, 0) <br>#define STRNG_ITEM(name)        INFOROW(name, #name, STRVAL, szGetInfo,  sizeof(szGetInfo), NULL, 0) <br>#define BIT32_ITEM(name, list)  INFOROW(name, #name, BITVAL, &amp;cb32,      sizeof(cb32), list, NumItems(list)) <br>#define DEX32_ITEM(name, list)  INFOROW(name, #name, DEXVAL, &amp;cb32,      sizeof(cb32), list, NumItems(list)) <br> <br> <br>struct { <br> <br>   UWORD          fInfoType;                 // What we're looking for <br>   LPSTR          szInfoName;                // Print name of the GetInfo item <br>   int            fOutType;                  // string, 16-bit or 32-bit <br>   PTR            rgbInfoValue;              // Output buffer <br>   SWORD          cbInfoMax;                 // Size of output buffer <br>   void FAR *     ptr;                       // Generic constant structure <br>   int            cbNum;                     // Count of items in ptr <br> <br>} GetInfo[] = { <br> <br> <br>   // Out Type  fInfoType                          List of Values <br>   // --------  -------------------------          --------------------------- <br>   STRNG_ITEM(  SQL_ACCESSIBLE_PROCEDURES                                      ), <br>   STRNG_ITEM(  SQL_ACCESSIBLE_TABLES                                          ), <br>   INT16_ITEM(  SQL_ACTIVE_ENVIRONMENTS                                        ), <br>   BIT32_ITEM(  SQL_ALTER_DOMAIN,                  GetInfoAlterDomain          ), <br>   BIT32_ITEM(  SQL_ALTER_TABLE,                   GetInfoAlterTable           ), <br>   DEX32_ITEM(  SQL_ASYNC_MODE,                    GetInfoAsyncMode            ), <br> <br>   BIT32_ITEM(  SQL_BATCH_ROW_COUNT,               GetInfoBatchRowCount        ), <br>   BIT32_ITEM(  SQL_BATCH_SUPPORT,                 GetInfoBatchSupport         ), <br>   BIT32_ITEM(  SQL_BOOKMARK_PERSISTENCE,          GetInfoBookmarkPersist      ), <br> <br>   DEX32_ITEM(  SQL_CATALOG_LOCATION,              GetInfoCatLocation          ), <br>   STRNG_ITEM(  SQL_CATALOG_NAME                                               ), <br>   STRNG_ITEM(  SQL_CATALOG_NAME_SEPARATOR                                     ), <br>   STRNG_ITEM(  SQL_CATALOG_TERM                                               ), <br>   BIT32_ITEM(  SQL_CATALOG_USAGE,                 GetInfoCatUsage             ), <br>   STRNG_ITEM(  SQL_COLLATION_SEQ                                              ), <br>   STRNG_ITEM(  SQL_COLUMN_ALIAS                                               ), <br>   DEX32_ITEM(  SQL_CONCAT_NULL_BEHAVIOR,          GetInfoConcat               ), <br>   BIT32_ITEM(  SQL_CONVERT_BIGINT,                GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_BINARY,                GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_BIT,                   GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_CHAR,                  GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_DATE,                  GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_DECIMAL,               GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_DOUBLE,                GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_FLOAT,                 GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_FUNCTIONS,             GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_INTEGER,               GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_LONGVARBINARY,         GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_LONGVARCHAR,           GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_NUMERIC,               GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_REAL,                  GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_SMALLINT,              GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_TIME,                  GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_TIMESTAMP,             GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_TINYINT,               GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_VARBINARY,             GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_VARCHAR,               GetInfoConvertTypes         ), <br>   BIT32_ITEM(  SQL_CONVERT_FUNCTIONS,             GetInfoConvertFunctions     ), <br>   BIT32_ITEM(  SQL_CORRELATION_NAME,              GetInfoCorrelationName      ), <br>   BIT32_ITEM(  SQL_CREATE_ASSERTION,              GetInfoCreateAssertion      ), <br>   BIT32_ITEM(  SQL_CREATE_CHARACTER_SET,          GetInfoCreateCharset        ), <br>   BIT32_ITEM(  SQL_CREATE_COLLATION,              GetInfoCreateCollation      ), <br>   BIT32_ITEM(  SQL_CREATE_DOMAIN,                 GetInfoCreateDomain         ), <br>   BIT32_ITEM(  SQL_CREATE_SCHEMA,                 GetInfoCreateSchema         ), <br>   BIT32_ITEM(  SQL_CREATE_TABLE,                  GetInfoCreateTable          ), <br>   BIT32_ITEM(  SQL_CREATE_TRANSLATION,            GetInfoCreateXlation        ), <br>   BIT32_ITEM(  SQL_CREATE_VIEW,                   GetInfoCreateView           ), <br>   DEX32_ITEM(  SQL_CURSOR_COMMIT_BEHAVIOR,        GetInfoCommit               ), <br>   DEX32_ITEM(  SQL_CURSOR_ROLLBACK_BEHAVIOR,      GetInfoCommit               ), <br>   DEX32_ITEM(  SQL_CURSOR_SENSITIVITY,            GetInfoCursorSensitiv       ), <br> <br>   STRNG_ITEM(  SQL_DATA_SOURCE_NAME                                           ), <br>   STRNG_ITEM(  SQL_DATA_SOURCE_READ_ONLY                                      ), <br>   STRNG_ITEM(  SQL_DATABASE_NAME                                              ), <br>   BIT32_ITEM(  SQL_DATETIME_LITERALS,             GetInfoSQLDateLit           ), <br>   STRNG_ITEM(  SQL_DBMS_NAME                                                  ), <br>   STRNG_ITEM(  SQL_DBMS_VER                                                   ), <br>   BIT32_ITEM(  SQL_DEFAULT_TXN_ISOLATION,         GetInfoTXNIsolation         ), <br>   STRNG_ITEM(  SQL_DESCRIBE_PARAMETER                                         ), <br>   INT32_ITEM(  SQL_DRIVER_HDBC                                                ), <br>   INT32_ITEM(  SQL_DRIVER_HENV                                                ), <br>   INT32_ITEM(  SQL_DRIVER_HLIB                                                ), <br>   INT32_ITEM(  SQL_DRIVER_HSTMT                                               ), <br>   STRNG_ITEM(  SQL_DRIVER_NAME                                                ), <br>   STRNG_ITEM(  SQL_DRIVER_ODBC_VER                                            ), <br>   STRNG_ITEM(  SQL_DRIVER_VER                                                 ), <br>   BIT32_ITEM(  SQL_DROP_ASSERTION,                GetInfoDropAssertion        ), <br>   BIT32_ITEM(  SQL_DROP_CHARACTER_SET,            GetInfoDropCharset          ), <br>   BIT32_ITEM(  SQL_DROP_COLLATION,                GetInfoDropCollation        ), <br>   BIT32_ITEM(  SQL_DROP_DOMAIN,                   GetInfoDropDomain           ), <br>   BIT32_ITEM(  SQL_DROP_SCHEMA,                   GetInfoDropSchema           ), <br>   BIT32_ITEM(  SQL_DROP_TABLE,                    GetInfoDropTable            ), <br>   BIT32_ITEM(  SQL_DROP_TRANSLATION,              GetInfoDropXlation          ), <br>   BIT32_ITEM(  SQL_DROP_VIEW,                     GetInfoDropView             ), <br>   BIT32_ITEM(  SQL_DYNAMIC_CURSOR_ATTRIBUTES1,    GetInfoCurAttrs1            ), <br>   BIT32_ITEM(  SQL_DYNAMIC_CURSOR_ATTRIBUTES2,    GetInfoCurAttrs2            ), <br> <br>   STRNG_ITEM(  SQL_EXPRESSIONS_IN_ORDERBY                                     ), <br> <br>   DEX32_ITEM(  SQL_FILE_USAGE,                    GetInfoFileUsage            ), <br>   BIT32_ITEM(  SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1, GetInfoCurAttrs1          ), <br>   BIT32_ITEM(  SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2, GetInfoCurAttrs2          ), <br> <br>   BIT32_ITEM(  SQL_GETDATA_EXTENSIONS,            GetInfoGetdataExt           ), <br>   BIT32_ITEM(  SQL_GROUP_BY,                      GetInfoGroupBy              ), <br> <br>   DEX32_ITEM(  SQL_IDENTIFIER_CASE,               GetInfoIDCase               ), <br>   INT16_ITEM(  SQL_IDENTIFIER_QUOTE_CHAR                                      ), <br>   BIT32_ITEM(  SQL_INDEX_KEYWORDS,                GetInfoIndexKeywords        ), <br>   BIT32_ITEM(  SQL_INFO_SCHEMA_VIEWS,             GetInfoInfoSchemaViews      ), <br>   STRNG_ITEM(  SQL_INTEGRITY                                                  ), <br> <br>   BIT32_ITEM(  SQL_KEYSET_CURSOR_ATTRIBUTES1,     GetInfoCurAttrs1            ), <br>   BIT32_ITEM(  SQL_KEYSET_CURSOR_ATTRIBUTES2,     GetInfoCurAttrs2            ), <br>   STRNG_ITEM(  SQL_KEYWORDS                                                   ), <br> <br>   STRNG_ITEM(  SQL_LIKE_ESCAPE_CLAUSE                                         ), <br> <br>   INT32_ITEM(  SQL_MAX_ASYNC_CONCURRENT_STATEMENTS                            ), <br>   INT32_ITEM(  SQL_MAX_BINARY_LITERAL_LEN                                     ), <br>   INT16_ITEM(  SQL_MAX_CATALOG_NAME_LEN                                       ), <br>   INT32_ITEM(  SQL_MAX_CHAR_LITERAL_LEN                                       ), <br>   INT16_ITEM(  SQL_MAX_COLUMN_NAME_LEN                                        ), <br>   INT16_ITEM(  SQL_MAX_COLUMNS_IN_GROUP_BY                                    ), <br>   INT16_ITEM(  SQL_MAX_COLUMNS_IN_INDEX                                       ), <br>   INT16_ITEM(  SQL_MAX_COLUMNS_IN_ORDER_BY                                    ), <br>   INT16_ITEM(  SQL_MAX_COLUMNS_IN_SELECT                                      ), <br>   INT16_ITEM(  SQL_MAX_COLUMNS_IN_TABLE                                       ), <br>   INT16_ITEM(  SQL_MAX_CONCURRENT_ACTIVITIES                                  ), <br>   INT16_ITEM(  SQL_MAX_CURSOR_NAME_LEN                                        ), <br>   INT16_ITEM(  SQL_MAX_DRIVER_CONNECTIONS                                     ), <br>   INT16_ITEM(  SQL_MAX_IDENTIFIER_LEN                                         ), <br>   INT32_ITEM(  SQL_MAX_INDEX_SIZE                                             ), <br>   INT16_ITEM(  SQL_MAX_PROCEDURE_NAME_LEN                                     ), <br>   INT32_ITEM(  SQL_MAX_ROW_SIZE                                               ), <br>   STRNG_ITEM(  SQL_MAX_ROW_SIZE_INCLUDES_LONG                                 ), <br>   INT16_ITEM(  SQL_MAX_SCHEMA_NAME_LEN                                        ), <br>   INT16_ITEM(  SQL_MAX_STATEMENT_LEN                                          ), <br>   INT16_ITEM(  SQL_MAX_TABLE_NAME_LEN                                         ), <br>   INT16_ITEM(  SQL_MAX_TABLES_IN_SELECT                                       ), <br>   INT16_ITEM(  SQL_MAX_USER_NAME_LEN                                          ), <br>   STRNG_ITEM(  SQL_MULTIPLE_ACTIVE_TXN                                        ), <br>   STRNG_ITEM(  SQL_MULT_RESULT_SETS                                           ), <br> <br>   STRNG_ITEM(  SQL_NEED_LONG_DATA_LEN                                         ), <br>   DEX32_ITEM(  SQL_NON_NULLABLE_COLUMNS,          GetInfoNonNullCols          ), <br>   DEX32_ITEM(  SQL_NULL_COLLATION,                GetInfoNullCollation        ), <br>   BIT32_ITEM(  SQL_NUMERIC_FUNCTIONS,             GetInfoNumeric              ), <br> <br>   DEX32_ITEM(  SQL_ODBC_INTERFACE_CONFORMANCE,    GetInfoAPIConform           ), <br>   DEX32_ITEM(  SQL_ODBC_SQL_CONFORMANCE,          GetInfoODBCSQL              ), <br>   STRNG_ITEM(  SQL_ODBC_VER                                                   ), <br>   STRNG_ITEM(  SQL_ORDER_BY_COLUMNS_IN_SELECT                                 ), <br>   STRNG_ITEM(  SQL_OUTER_JOINS                                                ), <br> <br>   DEX32_ITEM(  SQL_PARAM_ARRAY_ROW_COUNTS,        GetInfoParamRowCounts       ), <br>   DEX32_ITEM(  SQL_PARAM_ARRAY_SELECTS,           GetInfoParamSelects         ), <br>   STRNG_ITEM(  SQL_PROCEDURES                                                 ), <br>   STRNG_ITEM(  SQL_PROCEDURE_TERM                                             ), <br> <br>   DEX32_ITEM(  SQL_QUOTED_IDENTIFIER_CASE,        GetInfoIDCase               ), <br> <br>   STRNG_ITEM(  SQL_ROW_UPDATES                                                ), <br> <br>   STRNG_ITEM(  SQL_SCHEMA_TERM                                                ), <br>   BIT32_ITEM(  SQL_SCHEMA_USAGE,                  GetInfoSchemaUsage          ), <br>   BIT32_ITEM(  SQL_SCROLL_OPTIONS,                GetInfoScrollOptions        ), <br>   STRNG_ITEM(  SQL_SEARCH_PATTERN_ESCAPE                                      ), <br>   STRNG_ITEM(  SQL_SERVER_NAME                                                ), <br>   STRNG_ITEM(  SQL_SPECIAL_CHARACTERS                                         ), <br>   BIT32_ITEM(  SQL_SQL_CONFORMANCE,               GetInfoSQLConform           ), <br>   BIT32_ITEM(  SQL_SQL92_DATETIME_FUNCTIONS,      GetInfoS92DatetimeFns       ), <br>   BIT32_ITEM(  SQL_SQL92_FOREIGN_KEY_DELETE_RULE, GetInfoS92FKeyDelRule       ), <br>   BIT32_ITEM(  SQL_SQL92_FOREIGN_KEY_UPDATE_RULE, GetInfoS92FKeyUpdRule       ), <br>   BIT32_ITEM(  SQL_SQL92_GRANT,                   GetInfoS92Grant             ), <br>   BIT32_ITEM(  SQL_SQL92_NUMERIC_VALUE_FUNCTIONS, GetInfoS92NumValFns         ), <br>   BIT32_ITEM(  SQL_SQL92_PREDICATES,              GetInfoS92Predicates        ), <br>   BIT32_ITEM(  SQL_SQL92_RELATIONAL_JOIN_OPERATORS, GetInfoS92RelJoinOps      ), <br>   BIT32_ITEM(  SQL_SQL92_REVOKE,                  GetInfoS92Revoke            ), <br>   BIT32_ITEM(  SQL_SQL92_ROW_VALUE_CONSTRUCTOR,   GetInfoS92RowValConstr      ), <br>   BIT32_ITEM(  SQL_SQL92_STRING_FUNCTIONS,        GetInfoS92StringFns         ), <br>   BIT32_ITEM(  SQL_SQL92_VALUE_EXPRESSIONS,       GetInfoS92ValueExprs        ), <br>   BIT32_ITEM(  SQL_STANDARD_CLI_CONFORMANCE,      GetInfoS92StdCLIConf        ), <br>   BIT32_ITEM(  SQL_STATIC_CURSOR_ATTRIBUTES1,     GetInfoCurAttrs1            ), <br>   BIT32_ITEM(  SQL_STATIC_CURSOR_ATTRIBUTES2,     GetInfoCurAttrs2            ), <br>   BIT32_ITEM(  SQL_STRING_FUNCTIONS,              GetInfoStrings              ), <br>   BIT32_ITEM(  SQL_SUBQUERIES,                    GetInfoSubqueries           ), <br>   BIT32_ITEM(  SQL_SYSTEM_FUNCTIONS,              GetInfoSystem               ), <br> <br>   STRNG_ITEM(  SQL_TABLE_TERM                                                 ), <br>   BIT32_ITEM(  SQL_TIMEDATE_ADD_INTERVALS,        GetInfoTimeDateIvls         ), <br>   BIT32_ITEM(  SQL_TIMEDATE_DIFF_INTERVALS,       GetInfoTimeDateIvls         ), <br>   BIT32_ITEM(  SQL_TIMEDATE_FUNCTIONS,            GetInfoTimeDate             ), <br>   DEX32_ITEM(  SQL_TXN_CAPABLE,                   GetInfoTxnCapable           ), <br>   BIT32_ITEM(  SQL_TXN_ISOLATION_OPTION,          GetInfoTxnIsoOptions        ), <br> <br>   BIT32_ITEM(  SQL_UNION,                         GetInfoUnion                ), <br>   STRNG_ITEM(  SQL_USER_NAME                                                  ), </code></pre>
<p>
</p>
<pre><code><br>   STRNG_ITEM(  SQL_XOPEN_CLI_YEAR                                             ), <br>}; <br>    <br>    <br>//*--------------------------------------------------------------------------------- <br>//| GetBitVal: <br>//|   Call this function to retrieve the string values for all items which meet <br>//|   the bitwise and condition. <br>//| Parms: <br>//|   in       rs                   Pointer to the results set <br>//|   in       szInfoName           The info value being retrieved <br>//|   in       is                   Structure with resource ids and values <br>//|   in       maxdex               Number of items in struct <br>//|   in       mask                 The value to compare against <br>//|   in       szOut                Output buffer for retrieval <br>//|   in       cbOut                Size of output buffer <br>//| Returns:               <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>BOOL GetBitVal <br>   (RESULTSSET FAR * rs, <br>    LPSTR szInfoName, <br>    lpINFOSTRUCT is, <br>    int maxdex, <br>    UDWORD mask, <br>    LPSTR szVal, <br>    int cbVal) <br>{ <br>   int            tdex; <br>   ROWDATA FAR *  rd; <br>   COLORREF       rgbDft=GetDefaultRGB(); <br> <br>   if (mask != 0) { <br>      for(tdex=0;  tdex&lt;maxdex;  tdex++)  <br>         if(is[tdex].fVal &amp; mask) { <br>            rd = AllocateRowData(rs, rgbDft, RDATA_DEFAULT_BKGRND); <br>            SetColumnData(0, rd, szInfoName); <br>            SetColumnData(1, rd, is[tdex].szStr); <br>            if(AddRowData(rs, rd) == LB_ERRSPACE) <br>               return FALSE; <br>         } <br>   } <br>   else { <br>      rd = AllocateRowData(rs, rgbDft, RDATA_DEFAULT_BKGRND); <br>      SetColumnData(0, rd, szInfoName); <br>      SetColumnData(1, rd, "0"); <br>      if(AddRowData(rs, rd) == LB_ERRSPACE) <br>         return FALSE; <br>   } <br> <br>   return TRUE; <br>} <br> <br>    <br>//*--------------------------------------------------------------------------------- <br>//| GetIndexVal: <br>//|   Call this function to retrieve the string value for a constant. <br>//| Parms: <br>//|   in       rs                   Pointer to the results set <br>//|   in       szInfoName           The info value being retrieved <br>//|   in       is                   Structure with resource ids and values <br>//|   in       maxdex               Number of items in struct <br>//|   in       dex                  String index value  <br>//|   in       szOut                Output buffer for retrieval <br>//|   in       cbOut                Size of output buffer <br>//| Returns:               <br>//|   FALSE if there is an error <br>//| No error is posted if matching value is not found. <br>//*--------------------------------------------------------------------------------- <br>BOOL GetIndexVal <br>   (RESULTSSET FAR * rs, <br>    LPSTR szInfoName,  <br>    lpINFOSTRUCT is, <br>    int maxdex, <br>    int dex, <br>    LPSTR szOut, <br>    int cbOut) <br>{ <br>   int tdex; <br>   ROWDATA FAR *  rd; <br>   COLORREF       rgbDft=GetDefaultRGB(); <br> <br>   for (tdex = 0; tdex&lt;maxdex; tdex++) <br>      if (is[tdex].fVal == (UDWORD) dex) { <br>         rd = AllocateRowData(rs, rgbDft, RDATA_DEFAULT_BKGRND); <br>         SetColumnData(0, rd, szInfoName); <br>         SetColumnData(1, rd, is[tdex].szStr); <br>         if(AddRowData(rs, rd) == LB_ERRSPACE) <br>            return FALSE; <br>      } <br> <br>   return TRUE; <br>} <br> <br>    <br>//*--------------------------------------------------------------------------------- <br>//| DisplayGetInfo: <br>//|   This function goes through all of the SQLGetInfo constants defined in the <br>//|   ODBC reference guide and displays them in a results set. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//| Returns:               <br>//|   TRUE if successful, <br>//|   FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL DisplayGetInfo(CHILDINFO FAR * ci) <br>{ <br>   char                 szTitle[MAXBUFF]; <br>   char                 szVal[MAXBUFF]; <br>   int                  dex; <br>   lpINFOSTRUCT         lpINFS; <br>   RESULTSSET FAR *     rs; <br>   ROWDATA FAR *        rd; <br>   RETCODE              retcode; <br>   COLORREF             rgbDft=GetDefaultRGB(); <br> <br>   // <br>   // Create a hard coded results set with 2 columns <br>   // <br>   lstrcpy((LPSTR)szTitle, (LPSTR)ci-&gt;szClientTitle); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szDash); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szGetInfoTitle); <br>   rs = GetConnectWindowResultsNode(ci); <br>   if(!CreateResultsSet(rs, ci-&gt;hwndClient, ci-&gt;hInst, 2, (LPSTR)szTitle)) <br>      return FALSE;   <br> <br>   // <br>   // Set the meta data <br>   // <br>   SetMetaDataColumn(rs, 0, (LPSTR)"fInfoType",  <br>                     GetTypeName(SQL_TYPE, SQL_CHAR), SQL_CHAR, 40, 0, <br>                     45, TA_LEFT); <br>   SetMetaDataColumn(rs, 1, (LPSTR)"Value",  <br>                     GetTypeName(SQL_TYPE, SQL_CHAR), SQL_CHAR, 70, 0, <br>                     70, TA_LEFT); <br> <br>   // <br>   // Now create the MDI child window which will hold the results. <br>   // <br>   if(!CreateResultsWindow(ci, rs))  <br>      goto exit00; <br> <br>    <br>   // <br>   // Loop through the control structure and check each fInfoType.  Certain <br>   //    types require extra processing. <br>   // <br>   Busy(TRUE); <br>   for(dex=0;  dex&lt;NumItems(GetInfo);  dex++) { <br>      if(GetInfo[dex].fInfoType == SQL_DRIVER_HSTMT)           // Input arg also <br>         *(HSTMT FAR *)GetInfo[dex].rgbInfoValue = ci-&gt;hstmt; <br> <br>      memset(GetInfo[dex].rgbInfoValue, 0, GetInfo[dex].cbInfoMax); <br> <br>      retcode = SQLGetInfo(ci-&gt;hdbc,  <br>                           GetInfo[dex].fInfoType,  <br>                           GetInfo[dex].rgbInfoValue,  <br>                           GetInfo[dex].cbInfoMax,  <br>                           NULL); <br>      if(retcode != SQL_SUCCESS) <br>         PrintErrors(ci, SQL_HANDLE_DBC); <br> <br>      switch(GetInfo[dex].fInfoType) { <br>        case SQL_DRIVER_HENV: <br>        case SQL_DRIVER_HDBC: <br>        case SQL_DRIVER_HSTMT: <br>         rd = AllocateRowData(rs, rgbDft, RDATA_DEFAULT_BKGRND); <br>         SetColumnData(0, rd, GetInfo[dex].szInfoName); <br>         wsprintf(szVal, "%04X:%04X", HIWORD(cb32), LOWORD(cb32)); <br>         SetColumnData(1, rd, (LPSTR)szVal); <br>         if(AddRowData(rs, rd) == LB_ERRSPACE) <br>            goto exit00; <br>         break; <br>          <br>         // <br>         // The default action is taken when we only need to display the <br>         //    value as is.  We can use the structure to figure out what <br>         //    format it is in. <br>         // <br>        default: <br>         rd = AllocateRowData(rs, rgbDft, RDATA_DEFAULT_BKGRND); <br>         SetColumnData(0, rd, GetInfo[dex].szInfoName); <br>         switch(GetInfo[dex].fOutType) { <br>           case INT16: <br>            wsprintf(szVal, "%d", cb16); <br>            SetColumnData(1, rd, (LPSTR)szVal); <br>            if(AddRowData(rs, rd) == LB_ERRSPACE) <br>               goto exit00; <br>            break; <br>             <br>           case INT32: <br>            wsprintf(szVal, "%ld", cb32); <br>            SetColumnData(1, rd, (LPSTR)szVal); <br>            if(AddRowData(rs, rd) == LB_ERRSPACE) <br>               goto exit00; <br>            break; <br> <br>           case DEXVAL: <br>            lpINFS = (lpINFOSTRUCT)GetInfo[dex].ptr; <br>            if(!GetIndexVal(rs, GetInfo[dex].szInfoName, <br>                            lpINFS, GetInfo[dex].cbNum, <br>                            cb32, <br>                            (LPSTR)szVal, sizeof(szVal))) <br>               goto exit00; <br>            break; <br>             <br>           case BITVAL: <br>            lpINFS = (lpINFOSTRUCT)GetInfo[dex].ptr; <br>            if(!GetBitVal(rs, GetInfo[dex].szInfoName, <br>                          lpINFS, GetInfo[dex].cbNum, <br>                          cb32, <br>                          (LPSTR)szVal, sizeof(szVal))) <br>               goto exit00; <br>            break; <br>             <br>           default:  <br>            szGetInfo[69] = '\0'; // truncate long string... <br>            SetColumnData(1, rd, (LPSTR)GetInfo[dex].rgbInfoValue); <br>            if(AddRowData(rs, rd) == LB_ERRSPACE) <br>               goto exit00; <br>            break; <br>         } <br>      } <br>       <br>   } <br>    <br>   Busy(FALSE); <br>   return TRUE; <br>    <br>  exit00: <br>   Busy(FALSE); <br>   return FALSE; <br>} <br> <br>    <br>//*--------------------------------------------------------------------------------- <br>//| DisplayODBCFunctions: <br>//|   This function will enumerate all of the ODBC functions in a results set <br>//|      and indicate which ones are supported.  The results set is attatched <br>//|      as a valid results window on the current child. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//| Returns:               <br>//|   TRUE if successful, <br>//|   FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL DisplayODBCFunctions(CHILDINFO FAR * ci) <br>{ <br>   UWORD                fSupport; <br>   char                 szFuncName[35]; <br>   char                 szTitle[MAXBUFF]; <br>   int                  dex; <br>   RESULTSSET FAR *     rs; <br>   ROWDATA FAR *        rd; <br>   RETCODE              retcode; <br>   COLORREF             rgbDft=GetDefaultRGB(); <br>   // <br>   // Create a hard coded results set with 3 columns <br>   // <br>   lstrcpy((LPSTR)szTitle, (LPSTR)ci-&gt;szClientTitle); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szDash); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szODBCFunctions); <br>   rs = GetConnectWindowResultsNode(ci); <br>   if(!CreateResultsSet(rs, ci-&gt;hwndClient, ci-&gt;hInst, 3, (LPSTR)szTitle)) <br>      return FALSE;   <br> <br>   // <br>   // Set the meta data <br>   // <br>   SetMetaDataColumn(rs, 0, (LPSTR)"Function",  <br>                     GetTypeName(SQL_TYPE, SQL_CHAR), SQL_CHAR, 20, 0, <br>                     25, TA_LEFT); <br>   SetMetaDataColumn(rs, 1, (LPSTR)"Conformance",  <br>                     GetTypeName(SQL_TYPE, SQL_CHAR), SQL_CHAR, 10, 0, <br>                     10, TA_LEFT); <br>   SetMetaDataColumn(rs, 2, (LPSTR)"Supported",  <br>                     GetTypeName(SQL_TYPE, SQL_CHAR), SQL_CHAR, 10, 0, <br>                     10, TA_LEFT); <br> <br>   // <br>   // Now create the MDI child window which will hold the results. <br>   // <br>   if(!CreateResultsWindow(ci, rs))  <br>      goto exit00; <br> <br>    <br>   // <br>   // Loop through the control structure and check each function.  For each row <br>   //    add a record with the function name, conformance level, and Yes if <br>   //    supported, No if not. <br>   // <br>   for(dex=0;  dex&lt;NumItems(ODBCFunctions);  dex++) { <br>      retcode = SQLGetFunctions(ci-&gt;hdbc,  <br>                                ODBCFunctions[dex].fFunction, &amp;fSupport); <br>      if(retcode != SQL_SUCCESS) <br>         PrintErrors(ci, SQL_HANDLE_DBC); <br>      iLoadString(ODBCFunctions[dex].idFunction, (LPSTR)szFuncName, sizeof(szFuncName)); <br>      rd = AllocateRowData(rs, rgbDft, RDATA_DEFAULT_BKGRND); <br>      SetColumnData(0, rd, szFuncName); <br>      SetColumnData(1, rd, ODBCFunctions[dex].szLevel); <br>      SetColumnData(2, rd, (fSupport) ? (LPSTR)szYes : (LPSTR)szNo); <br>      AddRowData(rs, rd); <br>   } <br>    <br>   return TRUE; <br>    <br>  exit00: <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br>   return FALSE; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DisplayODBCDataSources: <br>//|   This function will enumerate all of the ODBC Data sources. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//| Returns:               <br>//|   TRUE if successful, <br>//|   FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL DisplayODBCDataSources(CHILDINFO FAR * ci) <br>{   <br>   HENV                 henv; <br>   RESULTSSET FAR *     rs; <br>   ROWDATA FAR *        rd; <br>   RETCODE              retcode; <br>   char                 szDSN[SQL_MAX_DSN_LENGTH + 1]; <br>   char                 szDesc[MAXBUFF]; <br>   char                 szTitle[MAXBUFF]; <br>   COLORREF             rgbDft=GetDefaultRGB(); <br> <br>   // <br>   // Create a hard coded results set with 2 columns <br>   // <br>   lstrcpy((LPSTR)szTitle, (LPSTR)ci-&gt;szClientTitle); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szDash); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szODBCDataSources); <br>   rs = GetConnectWindowResultsNode(ci); <br>   if(!CreateResultsSet(rs, ci-&gt;hwndClient, ci-&gt;hInst, 2, (LPSTR)szTitle)) <br>      return FALSE;   <br> <br>   // <br>   // Set the meta data <br>   // <br>   SetMetaDataColumn(rs, 0, (LPSTR)"Driver",  <br>                     GetTypeName(SQL_TYPE, SQL_CHAR), SQL_CHAR, 15, 0, <br>                     15, TA_LEFT); <br>   SetMetaDataColumn(rs, 1, (LPSTR)"Description",  <br>                     GetTypeName(SQL_TYPE, SQL_CHAR), SQL_CHAR, 35, 0, <br>                     35, TA_LEFT); <br> <br>   // <br>   // Now create the MDI child window which will hold the results. <br>   // <br>   if(!CreateResultsWindow(ci, rs))  <br>      goto exit00; <br> <br>    <br>   // <br>   // Loop through each data source and add it to the results set. <br>   // <br>   if (SQL_SUCCESS != SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HENV, &amp;henv) ) <br>{ <br> PrintErrors(ci, SQL_HANDLE_ENV); <br> goto exit00; <br>} <br>if (SQL_SUCCESS != SQLSetEnvAttr(henv,SQL_ATTR_ODBC_VERSION, <br>(SQLPOINTER)SQL_OV_ODBC3,SQL_IS_INTEGER)) <br>{ <br> PrintErrors(ci, SQL_HANDLE_ENV); <br> goto exit00; <br>} <br> <br>   retcode = SQLDataSources(henv, SQL_FETCH_FIRST, szDSN, sizeof(szDSN), <br>                            NULL, szDesc, sizeof(szDesc), NULL); <br>   while(retcode != SQL_NO_DATA) { <br>      if(retcode != SQL_SUCCESS ) <br>{ <br>         PrintErrors(ci, SQL_HANDLE_ENV); <br>if (retcode != SQL_SUCCESS_WITH_INFO) <br>goto exit00; <br>} <br>      rd = AllocateRowData(rs, rgbDft, RDATA_DEFAULT_BKGRND); <br>      SetColumnData(0, rd, szDSN); <br>      SetColumnData(1, rd, szDesc); <br>      AddRowData(rs, rd); <br>      retcode = SQLDataSources(henv, SQL_FETCH_NEXT, szDSN, sizeof(szDSN), <br>                               NULL, szDesc, sizeof(szDesc), NULL); <br>   } <br>   SQLFreeHandle(SQL_HANDLE_ENV, henv);  <br> <br>   return TRUE; <br>    <br>  exit00: <br> <br>   return FALSE; <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DisplayODBCDataTypes: <br>//|   This function will enumerate data type information. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//| Returns:               <br>//|   TRUE if successful, <br>//|   FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL DisplayODBCDataTypes(CHILDINFO FAR * ci) <br>{   <br>   RESULTSSET FAR *     rs; <br>   RETCODE              retcode; <br>   SWORD                cbCols; <br>   char                 szTitle[MAXBUFF]; <br> <br>   // <br>   // We'll use SQLGetTypeInfo for this query.  Since this function can return more <br>   //    than the standard types, we must first execute the query and then create <br>   //    the results set. <br>   // <br>   lstrcpy((LPSTR)szTitle, (LPSTR)ci-&gt;szClientTitle); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szDash); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szODBCDataTypes); <br>   retcode = SQLGetTypeInfo(ci-&gt;hstmt, SQL_ALL_TYPES); <br>   if(retcode != SQL_SUCCESS) { <br>      PrintErrors(ci, SQL_HANDLE_STMT); <br>      return FALSE; <br>   } <br> <br>   if(!(cbCols = GetNumResultsCols(ci-&gt;hstmt))) <br>      return FALSE; <br> <br>   rs = GetConnectWindowResultsNode(ci); <br>   if(!CreateResultsSet(rs, ci-&gt;hwndClient, ci-&gt;hInst, cbCols, (LPSTR)szTitle)) <br>      return FALSE;   <br> <br>   // <br>   // Set the meta data <br>   // <br>   SetMetaDataFromSql(ci-&gt;hwndOut, ci-&gt;hstmt, rs, cbCols); <br> <br>   // <br>   // Now create the MDI child window which will hold the results. <br>   // <br>   if(!CreateResultsWindow(ci, rs))  <br>      goto exit00; <br> <br>    <br>   // <br>   // Loop through each data source and add it to the results set. <br>   // <br>   FetchAllRecordsToResults(ci-&gt;hwndOut, ci-&gt;hstmt, rs, cbCols, TRUE); <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br> <br>   return TRUE; <br>    <br>  exit00: <br>   return FALSE; <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| EditPipe: <br>//|   This function allows the user to create a new pipe. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//| Returns:               <br>//|   TRUE if successful, <br>//|   FALSE on error <br>//*--------------------------------------------------------------------------------- <br>void EditPipe(CHILDINFO FAR * ci) <br>{ <br>   HWND     fHwnd=GetFocus(); <br> <br>   if(-1 == DialogBoxParam(ci-&gt;hInst,  <br>                           MAKEINTRESOURCE(IDD_EDIT_PIPE), <br>                           ci-&gt;hwnd,  <br>                           (DLGPROC) EditPipeWndProc, (LPARAM)ci)) <br>      MessageBox(NULL, "Could not open dialog box.", <br>                 "Pipe", MB_ICONEXCLAMATION); <br>    <br>   if(fHwnd) <br>      SetFocus(fHwnd); <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| IsValidParms: <br>//|   Verify that the parameters specified are the correct comma <br>//|   separated format. <br>//| Parms: <br>//|   hwnd              Window handle for errors <br>//|   szParms           The null terminated list of parms <br>//| Returns:               <br>//|   TRUE if they are valid, FALSE on error <br>//*------------------------------------------------------------------------ <br>BOOL WINAPI IsValidParms(HWND hwnd, LPSTR szParms) <br>{ <br>   LPSTR       str=szParms, nstr; <br>   char        sztmp[MAXSQL]; <br>   int         iNum, iCnt=0; <br> <br>   lstrcpy(sztmp, szParms); <br>   nstr = str = strtok(sztmp, szCOMMA); <br>   while(str) { <br>      ++iCnt; <br>      if(!(strlen(str) == 1 &amp;&amp; *str == '0')) { <br>         iNum = atoi(str); <br>         while(*str) { <br>            if(*str &lt; '0' || <br>               *str &gt; '9') <br>               goto invalidint; <br>            ++str; <br>         } <br>          <br>         // It was not 0, so if atoi returned 0 it was invalid <br>         if(!iNum) <br>            goto invalidint; <br>      } <br>       <br>      nstr = str = strtok(NULL, szCOMMA); <br>   } <br>    <br>   if(iCnt &lt;= MAXPARMS) <br>      return TRUE; <br>   else { <br>      szMessageBox(hwnd, <br>                   MB_ICONEXCLAMATION | MB_OK, <br>                   (LPSTR)szErrorMsgTitle, <br>                   iLoadString(idsTooManyParms, OutStr, MAXBUFF), <br>                   iCnt, <br>                   MAXPARMS); <br>      return FALSE; <br>   } <br> <br>  invalidint: <br>   szMessageBox(hwnd,  <br>                MB_ICONEXCLAMATION | MB_OK, <br>                (LPSTR)szErrorMsgTitle, <br>                iLoadString(idsInvalidInt, OutStr, MAXBUFF), <br>                nstr); <br>    <br>   return FALSE; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| EditPipeWndProc: <br>//|   Message handler for creating a new pipe. <br>//| Parms: <br>//|   in       Standard window parms <br>//| Returns:               <br>//|   Depends on message <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN EditPipeWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   static CHILDINFO FAR *     ci; <br>   static                     cbNames; <br>   static char                szName[MAXNAME]; <br> <br>   switch(msg) { <br>     case WM_INITDIALOG: <br>      { <br>         ci = (CHILDINFO FAR *)lParam; <br>         CenterDialog(hDlg); <br> <br>         SendMessage(GetDlgItem(hDlg, IDC_NAME), CB_LIMITTEXT, MAXPARMS, 0L); <br>         SendMessage(GetDlgItem(hDlg, IDE_SQL), EM_LIMITTEXT, MAXSQL, 0L); <br>         SendMessage(GetDlgItem(hDlg, IDE_PARMS), EM_LIMITTEXT, (MAXNAME*2), 0L); <br>         CheckRadioButton(hDlg, IDR_VALUE, IDR_ADDRESS, IDR_VALUE); <br>         SendMessage(hDlg, USER_RESETLIST, 0, 0L); <br>         SendMessage(hDlg, USER_SETSTATES, 0, 0L); <br>      } <br>      return TRUE;       <br> <br> <br>      // This user message is sent when the list needs to be refreshed <br>     case USER_RESETLIST: <br>      { <br>         LPSTR       str, addstr; <br> <br>         addstr = str = (LPSTR)GetMemory(1000); <br>         if(!addstr) <br>            return TRUE; <br>         cbNames = 0; <br>         if(str) { <br>            SendMessage(GetDlgItem(hDlg, IDC_NAME), CB_RESETCONTENT, 0, 0L); <br>            if(GetPrivateProfileString((LPSTR)szPIPES, NULL, NULL, <br>                                       str, 1000, szLABINI))  <br>               while(*addstr) { <br>                  ++cbNames; <br>                  SendMessage(GetDlgItem(hDlg, IDC_NAME), <br>                              CB_ADDSTRING, 0, <br>                              (LPARAM)(LPSTR)addstr); <br>                  addstr = addstr + lstrlen(addstr) + 1; <br>               } <br>         } <br>         ReleaseMemory(str); <br>         if(cbNames)  <br>            SendMessage(GetDlgItem(hDlg, IDC_NAME), CB_SETCURSEL, 0, 0L); <br>         SendMessage(hDlg, USER_SETDEFAULTS, 0, 0L); <br>         SendMessage(hDlg, USER_SETSTATES, 0, 0L); <br>      } <br>      return TRUE; <br>       <br>      // This user defined message will set the state of controls <br>     case USER_SETSTATES: <br>      EnableWindow(GetDlgItem(hDlg, IDB_DELETE), cbNames); <br>      EnableWindow(GetDlgItem(hDlg, IDE_SQL), cbNames); <br>      EnableWindow(GetDlgItem(hDlg, IDR_VALUE), cbNames); <br>      EnableWindow(GetDlgItem(hDlg, IDR_ADDRESS), cbNames); <br>      EnableWindow(GetDlgItem(hDlg, IDE_PARMS), cbNames); <br>      EnableWindow(GetDlgItem(hDlg, IDOK), cbNames); <br>      return TRUE; <br> <br>      // This user defined message is for setting default values <br>     case USER_SETDEFAULTS:  <br>      { <br>         char  szParmType[10]; <br>         char  szSql[MAXSQL]; <br>         char  szParms[MAXBUFF]; <br>          <br>         HWND  hName = GetDlgItem(hDlg, IDC_NAME); <br>          <br>         if(cbNames == 0) {               // No current driver <br>            SetDlgItemText(hDlg, IDE_SQL, ""); <br>            SetDlgItemText(hDlg, IDE_PARMS, ""); <br>            return TRUE; <br>         } <br>         SendMessage(hName, CB_GETLBTEXT, <br>                     (WPARAM)SendMessage(hName, CB_GETCURSEL, 0, 0L), <br>                     (LPARAM)(LPSTR)szName); <br>         if(GetPrivateProfileString(szName, szSQL, NULL, szSql, sizeof(szSql), szLABINI)) <br>            SetDlgItemText(hDlg, IDE_SQL, szSql); <br>         else <br>            SetDlgItemText(hDlg, IDE_SQL, ""); <br>         if(GetPrivateProfileString(szName, szPARMS, NULL, szParms, sizeof(szParms), szLABINI)) <br>            SetDlgItemText(hDlg, IDE_PARMS, szParms); <br>         else <br>            SetDlgItemText(hDlg, IDE_PARMS, ""); <br>         if(GetPrivateProfileString(szName, szPARMOPT, NULL, szParmType, sizeof(szParmType), szLABINI)) <br>            if(lstrcmpi(szVALUE, szParmType) == 0) <br>               CheckRadioButton(hDlg, IDR_VALUE, IDR_ADDRESS, IDR_VALUE); <br>            else <br>               CheckRadioButton(hDlg, IDR_VALUE, IDR_ADDRESS, IDR_ADDRESS); <br>         CheckDlgButton(hDlg, IDX_DELETE, GetPrivateProfileInt(szName, szDELETEOPT, 0, szLABINI)); <br>      } <br>      return TRUE; <br>       <br>     case WM_COMMAND: <br>      switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDB_NEW: <br>         { <br>            NEWPIPE  np; <br>             <br>            np.hwnd = hDlg; <br>            np.hInst = ci-&gt;hInst; <br>            NewPipe(&amp;np); <br>            if(np.fSuccess) { <br>               lstrcpy(szName, np.szName); <br>               SendMessage(GetDlgItem(hDlg, IDC_NAME), CB_SETCURSEL, <br>                           (WPARAM)SendMessage(GetDlgItem(hDlg, IDC_NAME), CB_ADDSTRING,  <br>                                               0, (LPARAM)(LPSTR)szName), 0L); <br>               if(cbNames) <br>                  SendMessage(hDlg, USER_SETDEFAULTS, 0, 0L); <br>               else <br>                  SendMessage(hDlg, USER_RESETLIST, 0, 0L); <br>            } <br>         }               <br>         return TRUE; <br>          <br>        case IDB_DELETE: <br>         GetText(GetDlgItem(hDlg, IDC_NAME), szName); <br>         wsprintf(OutStr, szDeletePipe, (LPSTR)szName); <br>         if(IDOK == MessageBox(hDlg, OutStr, szEditPipe, MB_OKCANCEL)) { <br>            WritePrivateProfileString(szName, NULL, NULL, szLABINI); <br>            WritePrivateProfileString(szPIPES, szName, NULL, szLABINI); <br>            SendMessage(hDlg, USER_RESETLIST, 0, 0L); <br>         } <br>         return TRUE; <br>          <br>         // <br>         // Read in the info from the dialog, validate the parms, write to file <br>         // <br>        case IDOK: <br>         { <br>            char  szSql[MAXSQL]; <br>            char  szParms[MAXBUFF]; <br> <br>            GetDlgItemText(hDlg, IDC_NAME, (LPSTR)szName, sizeof(szName)); <br> <br>            GetDlgItemText(hDlg, IDE_PARMS, szParms, sizeof(szParms)); <br>            if(IsValidParms(hDlg, szParms)) { <br>               WritePrivateProfileString(szName, szPARMS, szParms, szLABINI); <br>                <br>               GetDlgItemText(hDlg, IDE_SQL, szSql, sizeof(szSql)); <br>               WritePrivateProfileString(szName, szSQL, szSql, szLABINI); <br> <br>               if(IsDlgButtonChecked(hDlg, IDR_VALUE))                    <br>                  WritePrivateProfileString(szName, szPARMOPT, szVALUE, szLABINI); <br>               else <br>                  WritePrivateProfileString(szName, szPARMOPT, szADDRESS, szLABINI); <br> <br>               WritePrivateProfileString(szName, szDELETEOPT,  <br>                                         (IsDlgButtonChecked(hDlg, IDX_DELETE)) ? (LPSTR)"1" : (LPSTR)"0", <br>                                         szLABINI); <br>            } <br>         } <br>         return TRUE; <br>          <br>        case IDCANCEL: <br>         EndDialog(hDlg, IDCANCEL);; <br>         return TRUE; <br>      } <br>      // Now check for control notification messages <br>      switch(HIWORD(lParam)) { <br>        case CBN_SELENDOK: <br>        case CBN_KILLFOCUS: <br>         SendMessage(hDlg, USER_SETDEFAULTS, TRUE, 0L); <br>         return TRUE; <br>          <br>        default: <br>         break; <br>      } <br>      break; <br> <br> <br>     default: <br>      return FALSE; <br>   } <br>   return FALSE; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| NewPipe: <br>//|   This function allows the user to create a new pipe. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//| Returns:               <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>void NewPipe(NEWPIPE FAR * np) <br>{ <br>   HWND     fHwnd=GetFocus(); <br> <br>   if(-1 == DialogBoxParam(np-&gt;hInst,  <br>                           MAKEINTRESOURCE(IDD_NEW_PIPE), <br>                           np-&gt;hwnd,  <br>                           (DLGPROC) NewPipeWndProc, (LPARAM)np)) <br>      MessageBox(NULL, "Could not open dialog box.", <br>                 "Pipe", MB_ICONEXCLAMATION); <br>    <br>   if(fHwnd) <br>      SetFocus(fHwnd); <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| NewPipeWndProc: <br>//|   Message handler for creating a new pipe. <br>//| Parms: <br>//|   in       Standard window parms <br>//| Returns:               <br>//|   Depends on message <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN NewPipeWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   char                       szName[MAXNAME]; <br>   static NEWPIPE FAR *       np; <br> <br>   switch(msg) { <br>     case WM_INITDIALOG: <br>      { <br>         np = (NEWPIPE FAR *)lParam; <br>         CenterDialog(hDlg); <br>         SendMessage(GetDlgItem(hDlg, IDE_NAME), EM_LIMITTEXT, MAXNAME, 0L); <br>      } <br>      return TRUE;       <br> <br> <br>     case WM_COMMAND: <br>      switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>         { <br>            char szTmp[MAXNAME]; <br> <br>            // <br>            // Don't allow names with [,], or = in them, nor any <br>            // reserved section names <br>            // <br>            GetText(GetDlgItem(hDlg, IDE_NAME), (LPSTR)szName); <br>            if(!ValidName((LPSTR)szName) || <br>               !*szName || <br>               !lstrcmpi((LPSTR)szName, szSCREEN) || <br>               !lstrcmpi((LPSTR)szName, szFONT) || <br>               !lstrcmpi((LPSTR)szName, szCONNECTOPTIONS) || <br>               !lstrcmpi((LPSTR)szName, szPIPES)) { <br> <br>               szMessageBox(hDlg, <br>                            MB_ICONEXCLAMATION | MB_OK, <br>                            (LPSTR)szErrorMsgTitle, <br>                            iLoadString(idsInvalidName, OutStr, MAXBUFF), <br>                            (LPSTR)szName); <br>               return TRUE; <br>            } <br>            if(GetPrivateProfileString(szPIPES, szName, NULL, <br>                                       szTmp, sizeof(szTmp), szLABINI))  <br>               MessageBox(hDlg, szDuplicatePipe, szEditPipe, MB_OK); <br>            else { <br>               lstrcpy(np-&gt;szName, szName); <br>               np-&gt;fSuccess = TRUE; <br>               WritePrivateProfileString(szPIPES, szName, szInstalled, szLABINI); <br>               EndDialog(hDlg, IDOK); <br>            } <br>         } <br>         return TRUE; <br>          <br>        case IDCANCEL: <br>         np-&gt;fSuccess = FALSE; <br>         EndDialog(hDlg, IDCANCEL); <br>         return TRUE; <br>      } <br>      break; <br> <br>     default: <br>      return FALSE; <br>   } <br>   return FALSE; <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| HandlePipe: <br>//|   This function will use the active results set and run use pipes against it. <br>//| Parms: <br>//|   lpci              Connection window information <br>//|   lpri              Ative results set <br>//| Returns:               <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void INTFUN HandlePipe(lpCHILDINFO lpci, lpRESULTSINFO lpri) <br>{ <br>   HWND                 fHwnd=GetFocus(); <br> <br>   if(-1 == DialogBoxParam(lpci-&gt;hInst,  <br>                           MAKEINTRESOURCE(IDD_DO_PIPE), <br>                           lpci-&gt;hwnd,  <br>                           (DLGPROC) DoPipeWndProc, (LPARAM)(lpRESULTSINFO)lpri)) <br>      MessageBox(NULL, "Could not open dialog box.", <br>                 "HandlePipe", MB_ICONEXCLAMATION); <br>    <br>   if(fHwnd) <br>      SetFocus(fHwnd); <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| DoPipeWndProc: </code></pre>
<p>
</p>
<pre><code>//|   Handle dialog messages for IDD_DO_PIPE. <br>//| Parms: <br>//|   in       Standard window parms <br>//| Returns:               <br>//|   Depends on message <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN DoPipeWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   static CHILDINFO FAR *     ci; <br>   static RESULTSSET FAR *    rs; <br>   static SDWORD              cbPipes; <br> <br>   switch(msg) { <br>     case WM_INITDIALOG: <br>      { <br>         lpRESULTSINFO rwi; <br>         rwi = (lpRESULTSINFO)lParam; <br>         ci = rwi-&gt;ci; <br>         rs = rwi-&gt;rs; <br>         CenterDialog(hDlg); <br>         cbPipes = RefreshPipeList(GetDlgItem(hDlg, IDL_PIPES)); <br>         EnableWindow(GetDlgItem(hDlg, IDL_PIPES), (int)(cbPipes)); <br>         EnableWindow(GetDlgItem(hDlg, IDOK), (int)(cbPipes)); <br>      } <br>      return TRUE;       <br> <br> <br>     case WM_COMMAND: <br>      switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>         // User has clicked OK.  Retrieve an array of the selected indexes <br>         // and run the current pipe against each.  Finally see if this <br>         // pipe wants to delete items. <br>        case IDOK: <br>         { <br>            int         cbCnt; <br>            int FAR *   xSel; <br>            int         dex; <br>            char        szPipeName[MAXBUFF]; <br> <br>            Busy(TRUE); <br>            cbCnt = (int)SendMessage(rs-&gt;hwndList, LB_GETSELCOUNT, 0, 0L); <br>            xSel = (int FAR *)GetMemory(sizeof(int) * cbCnt); <br>            if(!xSel) { <br>               Busy(FALSE); <br>               return TRUE; <br>            } <br>            SendMessage(rs-&gt;hwndList, LB_GETSELITEMS, cbCnt, (LPARAM)(int FAR *)xSel); <br>            SendMessage(GetDlgItem(hDlg, IDL_PIPES), LB_GETTEXT, <br>                        (WPARAM)SendMessage(GetDlgItem(hDlg, IDL_PIPES), LB_GETCURSEL, 0, 0L), <br>                        (LPARAM)(LPSTR)szPipeName); <br>            DoPipe(rs, ci, (LPSTR)szPipeName, xSel, cbCnt); <br>            if(GetPrivateProfileInt(szPipeName, szDELETEOPT, 0, szLABINI)) <br>               for(dex=cbCnt-1;  dex&gt;=0;  dex--) <br>                  SendMessage(rs-&gt;hwndList, LB_DELETESTRING, xSel[dex], 0L); <br>            Busy(FALSE); <br>            ReleaseMemory(xSel); <br>         } <br>         return TRUE; <br>          <br>        case IDCANCEL: <br>         EndDialog(hDlg, IDCANCEL); <br>         return TRUE; <br>      } <br>      return TRUE; <br> <br>     default: <br>      return FALSE; <br>   } <br>   return FALSE; <br>} <br> <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| RefreshPipeList: <br>//|   This function will reset the list of pipes based on the values returned <br>//|      from GetPipeName.  Having this extra level of abstraction allows us <br>//|      to change the location of the pipes without affecting this code. <br>//| Parms: <br>//|   in       hwnd                 Window handle to list box to fill <br>//| Returns:               <br>//|   Number of items selected <br>//*--------------------------------------------------------------------------------- <br>SDWORD RefreshPipeList(HWND hDlg) <br>{ <br>#define MAX_PIPE_SIZE 4000 <br>   LPSTR    szPipes, str; <br>   SDWORD count=0; <br>    <br>   szPipes = (LPSTR)GetMemory(MAX_PIPE_SIZE); <br>   if(!szPipes)  <br>      return 0; <br>    <br>   SendMessage(hDlg, LB_RESETCONTENT, 0, 0L); <br>   GetPipeNames((LPSTR)szPipes, MAX_PIPE_SIZE); <br>   str = szPipes; <br>   while(*str) { <br>      SendMessage(hDlg, LB_ADDSTRING, 0, (LPARAM)(LPSTR)str); <br>      str += lstrlen(str) + 1; <br>      ++count; <br>   } <br>   if(count) <br>      SendMessage(hDlg, LB_SETCURSEL, 0, 0L); <br> <br>   ReleaseMemory(szPipes); <br>   return count; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoPipe: <br>//|   This function will implement a pipe against the object which is passed in. <br>//| Parms: <br>//|   in       rs                   Pointer to results set describing data <br>//|   in       ci                   Connection window information <br>//|   in       szPipeName           Name of pipe to use <br>//|   in       xPipes               Array of items to pipe <br>//|   in       cbCnt                Number of items <br>//| Returns:               <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void DoPipe(RESULTSSET FAR * rs, CHILDINFO FAR * ci, LPSTR szPipeName, <br>            int FAR xPipes[], int cbCnt) <br>{ <br>   SDWORD            cbDataAtExec=SQL_DATA_AT_EXEC; <br>   int               dex; <br>   int               cParm; <br>   char              szpsql[200]; <br>   char              szparms[35]; <br>   char              parmopt[10]; <br>   UWORD             cParmCnt=0; <br>   LPSTR             str=szparms; <br>   LPSTR             numstr=szparms; <br>   ROWDATA FAR *     rd; <br>   RETCODE           retcode; <br> <br>   // <br>   // Make sure we can retrieve the pipe from the .ini file.  Also get the parameter <br>   //    values if they are available. <br>   // <br>   if(!GetPrivateProfileString(szPipeName, szSQL, NULL, szpsql, sizeof(szpsql), szLABINI)) { <br>      szWrite(ci-&gt;hwndOut,  <br>              GetidsString(idsPipeNotFound, OutStr, MAXBUFF),  <br>              (LPSTR)szPipeName); <br>      return; <br>   } <br>   GetPrivateProfileString(szPipeName, szPARMS, NULL, szparms, sizeof(szparms), szLABINI); <br>   GetPrivateProfileString(szPipeName, szPARMOPT, NULL, parmopt, sizeof(parmopt), szLABINI); <br> <br>   // <br>   // If there are parameters to set, set each one based on user desription <br>   // <br>   if(str &amp;&amp; *str) <br>      PrepareParmList(str); <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br>    <br>   // <br>   // What type of parameter passing to do?  value means substitue text and execute, <br>   //    address means use parameter data.  The following will handle the former, the <br>   //    next more complicated routine will pass parameters. <br>   // <br>   if(lstrcmpi(parmopt, szVALUE) == 0) { <br>      DoPipeByValue(rs, ci, szpsql, str, xPipes, cbCnt, (LPSTR)szPipeName); <br>      return; <br>   } <br>    <br>   // <br>   // Now prepare the user's statement, return on error <br>   // <br>   retcode = SQLPrepare(ci-&gt;hstmt, szpsql, SQL_NTS); <br>   if(retcode != SQL_SUCCESS) { <br>      PrintErrors(ci, SQL_HANDLE_STMT); <br>      return; <br>   } <br>    <br>   // <br>   // For each parameter, make sure it's in our range, then see which mode we want, <br>   //    address (param data) or value (textual substitution). <br>   // <br>   while(*str) { <br>      ++cParmCnt; <br>      cParm = lpatoi(str); <br>      if(cParm &gt; rs-&gt;cbColumns)  <br>         szWrite(ci-&gt;hwndOut,  <br>                 GetidsString(idsInvalidParamValue, OutStr, MAXBUFF),  <br>                 cParm, (LPSTR)szPipeName); <br>      else { <br>         retcode = SQLBindParameter(ci-&gt;hstmt,  <br>                                    cParmCnt, SQL_PARAM_INPUT, <br>                                    SQL_C_CHAR, SQL_CHAR,  <br>                                    rs-&gt;md[cParm-1].precision, <br>                                    rs-&gt;md[cParm-1].scale,  <br>                                    (PTR FAR *)(cParm - 1),  <br>                                    rs-&gt;md[cParm-1].precision, <br>                                    &amp;cbDataAtExec); <br>         if(retcode != SQL_SUCCESS)  <br>            PrintErrors(ci, SQL_HANDLE_STMT); <br>      } <br>      str += lstrlen(str) + 1; <br>   }   <br> <br> <br>   // <br>   // For each row selected, retrieve the row data structure associated with it, <br>   //    then do an execute.  When prompted for SQL_NEED_DATA, substitute the <br>   //    correct parameter address. <br>   // <br>   for(dex=0;  dex&lt;cbCnt;  dex++) {  <br>      int      cNeedParm; <br>      rd = (ROWDATA FAR *)SendMessage(rs-&gt;hwndList, LB_GETITEMDATA, (WPARAM)xPipes[dex], 0L); <br>      retcode = SQLExecute(ci-&gt;hstmt); <br>      switch(retcode) { <br>         // <br>         // User had parameter data which we are being prompted for.  Since we <br>         //    did the SQLSetParam using the index number, we simply use that <br>         //    value to index into our column data and give the driver what <br>         //    it requires. <br>         // <br>        case SQL_NEED_DATA: <br>         retcode = SQLParamData(ci-&gt;hstmt, (PTR FAR *)&amp;cNeedParm); <br>         while(retcode == SQL_NEED_DATA) { <br>            retcode = SQLPutData(ci-&gt;hstmt, rd-&gt;cd[cNeedParm].szCols, SQL_NTS); <br>            retcode = SQLParamData(ci-&gt;hstmt, (PTR FAR *)&amp;cNeedParm); <br>         } <br>         break; <br>          <br>        case SQL_SUCCESS: <br>         CheckForResults(ci); <br>         break; <br>          <br>        default: <br>         PrintErrors(ci, SQL_HANDLE_STMT); <br>         break; <br>      } <br>   } <br>    <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br>   return; <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| PrepareParmList: <br>//|   The user will enter a list of numbers separated by columns which will <br>//|   designate which parms go for what marker.  We will turn this list into <br>//|   a double-null terminated list which can be used later for retrieval. <br>//| Parms: <br>//|   in       str                  Pointer to string to work on <br>//| Returns:               <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void PrepareParmList(LPSTR str) <br>{ <br>   LPSTR tmpstr=str; <br>   LPSTR lststr=tmpstr; <br> <br>   // <br>   // Convert parm list into a double-null terminated list <br>   // <br>   while(tmpstr) { <br>      if((tmpstr = _fstrchr(str, ','))) { <br>         lststr = tmpstr + 1; <br>         *tmpstr++ = '\0'; <br>      } <br>      else { <br>         lststr += lstrlen(lststr) + 1; <br>         *lststr = '\0'; <br>      } <br>   } <br>}         <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoPipeByValue: <br>//|   This function will process all of the selcted values by creating a <br>//|   statement which has all parameters embedded in it. <br>//| <br>//|   Note:    There are some servers which use a semi-colon for the name of <br>//|            a stored procedure, but which cannot handle doing a drop of the <br>//|            object with this name.  If the pipe name is the reserved name <br>//|            of "Drop Procedure (with semi-colon)" then we will strip off the <br>//|            name since this can't really be done any other way. <br>//| Parms: <br>//|   in       rs                   Results set pointer <br>//|   in       ci                   Child information <br>//|   in       szUserSQL               Statement with parameter markers <br>//|   in       szParms              Parameter list, double null terminated <br>//|   in       xPipes               Array of indexes to use for param data <br>//|   in       cbCnt                Number of records to process <br>//|   in       szPipeName           Pipe names <br>//| Returns:               <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void DoPipeByValue(RESULTSSET FAR * rs, CHILDINFO FAR * ci, LPSTR szUserSQL, <br>                   LPSTR szParms, int FAR xPipes[], int cbCnt, LPSTR szPipeName) <br>{ <br>   char              szUserSQLCopy[300]; <br>   char              sqlstmt[300]; <br>   LPSTR             szParmStrOut; <br>   LPSTR             szParmStrIn; <br>   LPSTR             szParmStrLast; <br>   LPSTR             str=szParms; <br>   int               dex; <br>   int               cParm; <br>   ROWDATA FAR *     rd; <br>   BOOL              fSemiProc=FALSE; <br>    <br>   // Handle special case of a procedure name with a semi-colon <br>   if(lstrcmp(szPipeName, szDROPPROCSEMI) == 0) <br>      fSemiProc = TRUE; <br>    <br>   // <br>   // For each record selected, create a statement which can be executed by finding <br>   //    parameter markers and replacing them at run time. <br>   // <br>   for(dex=0;  dex&lt;cbCnt;  dex++) { <br>      _fmemset(sqlstmt, 0, sizeof(sqlstmt)); <br>      _fmemset(szUserSQLCopy, 0, sizeof(szUserSQLCopy)); <br>      lstrcpy(szUserSQLCopy, szUserSQL); <br>      szParmStrOut = sqlstmt; <br>      szParmStrIn = szUserSQLCopy; <br>      szParmStrLast = szParmStrIn; <br>      str = szParms; <br>      rd = (ROWDATA FAR *)SendMessage(rs-&gt;hwndList, LB_GETITEMDATA, (WPARAM)xPipes[dex], 0L); <br>      while(*str) { <br>         cParm = lpatoi(str); <br>         if(cParm &gt; rs-&gt;cbColumns)  <br>            szWrite(ci-&gt;hwndOut,  <br>                    GetidsString(idsInvalidParamValue, OutStr, MAXBUFF),  <br>                    cParm, (LPSTR)szPipeName); <br>         else if(szParmStrIn &amp;&amp; *szParmStrIn) { <br>            if((szParmStrIn = _fstrchr(szParmStrIn, '?'))) { <br>               *szParmStrIn++ = '\0'; <br>               lstrcpy(szParmStrOut, szParmStrLast); <br>               _fstrcat(szParmStrOut, rd-&gt;cd[cParm-1].szCols); <br>               // Remove semi-colon for special case of drop procedure <br>               if(fSemiProc) { <br>                  LPSTR    str = _fstrchr(szParmStrOut, ';'); <br>                  if(str) <br>                     *str = '\0'; <br>               } <br>               szParmStrLast = szParmStrIn;  <br>            } <br>            else <br>               lstrcpy(szParmStrOut, szParmStrLast);              // end of list <br>         } <br>         str += lstrlen(str) + 1; <br>      } <br>      if(*szParmStrLast) <br>         _fstrcat(szParmStrOut, szParmStrLast); <br>      ExecuteCmds(ci, sqlstmt); <br>   } <br>    <br>   return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
