<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RESULTS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2270"></a>RESULTS.C</h2>
<pre><code>//*--------------------------------------------------------------------------------- <br>//|  ODBC System Administrator <br>//| <br>//|  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>//|  intended for example purposes only. <br>//| <br>//|   Title:   RESULTS.C <br>//|      This module contains functions which allow you to view results via an <br>//|      owner-drawn list box.  Having the list box functionality made it easy <br>//|      to implement Pipes, but has some serious draw-backs as far as record <br>//|      limits, storage methods, etc...  If you are looking for a great way to <br>//|      paint data in a grid, check out the C++ or Cursor Demo samples that came <br>//|      with this SDK. <br>//*--------------------------------------------------------------------------------- <br>#include &lt;stdio.h&gt; <br>#include "errcheck.h" <br>#include "standard.h" <br>#include "results.h" <br>#include "math.h" <br>#include "ini.h" <br> <br> <br>//------------------------------------------------------------------------ <br>//  Defines <br>//------------------------------------------------------------------------ <br>VSZFile; <br> <br> <br>//------------------------------------------------------------------------ <br>//  Globals <br>//------------------------------------------------------------------------ <br>char szErrMsg[100]; <br>dCSEG(char) szONE[]                       =  "1"; <br>dCSEG(char) szZERO[]                      =  "0"; <br>dCSEG(char) szdate[]                      =  "%02u/%02u/%02u"; <br>dCSEG(char) sztime[]                      =  "%02u:%02u:%02u"; <br>dCSEG(char) sztimestmp[]                  =  "%02u/%02u/%02u %02u:%02u:%02u.%lu"; <br>dCSEG(char) szTypeNotFound[]              =  "Not found"; <br>dCSEG(char) szMaxRowsFetched[]            =  "Maximum rows fetched.  Total rows: %lu"; <br> <br> <br>struct { <br>   SWORD type;                      // Data type value <br>   LPSTR sztype;                    // String equivalent <br>   } SqlTypes[] = { <br>// type                 sztype <br>// -------------------  ----------------------------- <br>   SQL_BIGINT,          "SQL_BIGINT=-5", <br>   SQL_BINARY,          "SQL_BINARY=-2", <br>   SQL_BIT,             "SQL_BIT=-7", <br>   SQL_CHAR,            "SQL_CHAR=1", <br>   SQL_DATE,            "SQL_DATE=9", <br>   SQL_DECIMAL,         "SQL_DECIMAL=3", <br>   SQL_DOUBLE,          "SQL_DOUBLE=8", <br>   SQL_FLOAT,           "SQL_FLOAT=6", <br>   SQL_INTEGER,         "SQL_INTEGER=4", <br>   SQL_LONGVARBINARY,   "SQL_LONGVARBINARY=-4", <br>   SQL_LONGVARCHAR,     "SQL_LONGVARCHAR=-1", <br>   SQL_NUMERIC,         "SQL_NUMERIC=2", <br>   SQL_REAL,            "SQL_REAL=7", <br>   SQL_SMALLINT,        "SQL_SMALLINT=5", <br>   SQL_TIME,            "SQL_TIME=10", <br>   SQL_TIMESTAMP,       "SQL_TIMESTAMP=11", <br>   SQL_TINYINT,         "SQL_TINYINT=-6", <br>   SQL_VARBINARY,       "SQL_VARBINARY=-3", <br>   SQL_VARCHAR,         "SQL_VARCHAR=12", <br>   }; <br> <br> <br>struct { <br>   SWORD type;                      // Data type value <br>   LPSTR sztype;                    // String equivalent <br>   } CTypes[] = { <br>// type                 sztype <br>// -------------------  ----------------------------- <br>   SQL_C_BINARY,        "SQL_C_BINARY=-2", <br>   SQL_C_BIT,           "SQL_C_BIT=-7", <br>   SQL_C_CHAR,          "SQL_C_CHAR=1", <br>   SQL_C_DATE,          "SQL_C_DATE=9", <br>   SQL_C_DOUBLE,        "SQL_C_DOUBLE=8", <br>   SQL_C_FLOAT,         "SQL_C_FLOAT=7", <br>   SQL_C_LONG,          "SQL_C_LONG=4", <br>   SQL_C_SHORT,         "SQL_C_SHORT=5", <br>   SQL_C_TIME,          "SQL_C_TIME=10", <br>   SQL_C_TIMESTAMP,     "SQL_C_TIMESTAMP=11", <br>   SQL_C_TINYINT,       "SQL_C_TINYINT=-6", <br>   }; <br> <br>typedef struct tagDATATYPE{ <br>   SWORD type;                      // Data type value <br>   LPSTR sztype;                    // String equivalent <br>   } DATATYPE; <br> <br> <br>//------------------------------------------------------------------------ <br>//  Local function prototypes <br>//------------------------------------------------------------------------ <br>void CheckDisplayMode(LPSTR strin, SDWORD cbin, LPSTR strout); <br>BOOL INTFUN             DrawRow(DRAWITEMSTRUCT FAR * dw, <br>                           RESULTSSET FAR * rs, int xLeftCol, int xRightCol, BOOL fSelect); <br> <br> <br>//*------------------------------------------------------------------------ <br>//| CreateResultsSet: <br>//|   This is the first function that should be called to create a <br>//|      results set.  When there is no more use for the results set, <br>//|      call DeleteResultsSet to delete it. <br>//| <br>//|   Parameters: <br>//|      in    rs                Pointer to a new results set <br>//|      in    hwndClient        Client window <br>//|      in    hInst             Instance handle of caller <br>//|      in    count             How many columns in the results set <br>//|      in    szTitle           Title for the window <br>//| <br>//|   Returns: <br>//|      TRUE if there were no errors, <br>//|      FALSE otherwise <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN CreateResultsSet(RESULTSSET FAR * rs, HWND hwndClient, HINSTANCE hInst, <br>            int count, LPSTR szTitle) <br>{ <br>   if(!rs || <br>      count &lt;=0) <br>      return FALSE; <br> <br>   memset(rs, 0, sizeof(RESULTSSET)); <br>   rs-&gt;cbColumns = count; <br>   rs-&gt;hInst = hInst; <br>   rs-&gt;hwndClient = hwndClient; <br>   if(*szTitle) <br>      lstrcpy(rs-&gt;szTitle, szTitle); <br> <br>   rs-&gt;md = (METADATA FAR *)GetMemory(sizeof(METADATA) * count); <br>   if(!rs-&gt;md) <br>      return FALSE; <br> <br>   return TRUE; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| SetMetaDataColumn: <br>//|   This function must be called for each column in the results set.  The <br>//|      information placed for each row can be obtained using ODBC functions <br>//|      such as SQLDescribeCol and SQLColAttribute. <br>//|   Parameters: <br>//|      in    rs                Pointer to a results set <br>//|      in    iCol              Column number <br>//|      in    szCol             Pointer to column name <br>//|      in    szTypeName        Data type name <br>//|      in    fSqlType          ODBC data type number <br>//|      in    precision         Precision <br>//|      in    scale             Scale <br>//|      in    cbDisplay         Display size <br>//|      in    fAlign            Alignment <br>//|   Returns: <br>//|      Nothing <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN SetMetaDataColumn(RESULTSSET FAR * rs, int iCol, LPSTR szCol, <br>      LPSTR szTypeName, SDWORD fSqlType, UDWORD precision, SWORD scale, <br>      int cbDisplay, UINT fAlign) <br>{ <br>   if(!rs || <br>      iCol &lt; 0 || <br>      !szCol || <br>      !*szCol || <br>      !szTypeName || <br>      !*szTypeName) { <br>      PostError((LPSTR)szInvalidParms); <br>      return FALSE; <br>   } <br> <br>   rs-&gt;md[iCol].szColumnName = (LPSTR)GetMemory(lstrlen(szCol)+1); <br>   if(!rs-&gt;md[iCol].szColumnName) <br>      return FALSE; <br>   precision = min(precision, MAXBYTES); <br>   lstrcpy(rs-&gt;md[iCol].szColumnName, szCol); <br>   lstrcpy(rs-&gt;md[iCol].szTypeName, szTypeName); <br>   rs-&gt;md[iCol].fSqlType = fSqlType; <br>   rs-&gt;md[iCol].precision = precision; <br>   rs-&gt;md[iCol].scale = scale; <br>   rs-&gt;md[iCol].cbDisplaySize = cbDisplay; <br>   rs-&gt;md[iCol].fAlign = fAlign; <br>   rs-&gt;md[iCol].cbOffset = (iCol &gt; 0) ? (UINT)(precision + rs-&gt;md[iCol-1].cbOffset) : (UINT)(precision); <br>   ++rs-&gt;md[iCol].cbOffset;               // Room for terminators <br> <br>   return TRUE; <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| AllocateRowData: <br>//|   Call this function for each row in the results set to allocate <br>//|      memory and insert a row into the results set. <br>//|   Parameters: <br>//|      in    rs                Pointer to results set <br>//|      in    rd                Pointer to a row data structure <br>//|      in    cColor            Text color <br>//|      in    cBkg              Background color <br>//|   Returns: <br>//|      Pointer to a ROWDATA structure <br>//*------------------------------------------------------------------------ <br>ROWDATA FAR * AllocateRowData(RESULTSSET FAR * rs, COLORREF cColor, COLORREF cBkg) <br>{ <br>   ROWDATA FAR *  rd; <br>   int            dex; <br> <br>   if(!rs) { <br>      PostError((LPSTR)szInvalidParms); <br>      return FALSE; <br>   } <br>   rd = (ROWDATA FAR *)GetMemory(sizeof(ROWDATA)); <br>   if(!rd) <br>      return NULL; <br>   rd-&gt;textColor = cColor; <br>   rd-&gt;bkgrnd = cBkg; <br>   rd-&gt;cd = (COLUMNDATA FAR *)GetMemory((sizeof(COLUMNDATA) * rs-&gt;cbColumns)); <br>   if(!rd-&gt;cd) <br>      return NULL; <br>   rd-&gt;data = (LPSTR)GetMemory(rs-&gt;md[rs-&gt;cbColumns-1].cbOffset + 1); <br>   if(!rd-&gt;data) <br>      return NULL; <br>   rd-&gt;cd[0].szCols = rd-&gt;data; <br>   for(dex=1;  dex&lt;rs-&gt;cbColumns;  dex++) <br>      rd-&gt;cd[dex].szCols = rd-&gt;data + rs-&gt;md[dex-1].cbOffset; <br> <br>   return rd; <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| SetColumnData: <br>//|   Call this function for a particular column in a ROWDATA structure. <br>//|      If memory has been allocated for the column, it will be freed <br>//|      and reallocated for the new string. <br>//|   Parameters: <br>//|      in    icol              Which column? <br>//|      in    rd                Pointer to a row data structure <br>//|      in    str               Pointer to the new buffer <br>//|   Returns: <br>//|      TRUE if successful <br>//|      FALSE on error <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN SetColumnData(int icol, ROWDATA FAR * rd, LPSTR str) <br>{ <br>   if(!str || <br>      !*str) <br>      return FALSE; <br> <br>   lstrcpy(rd-&gt;cd[icol].szCols, str); <br>   return TRUE; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| FreeRowData: <br>//|   Pass a pointer to the ROWDATA structure to free.  Obviously since <br>//|      you are asked for a RESULTSSET pointer, you should call this <br>//|      function before freeing the results set data. <br>//| Parms: <br>//|   in       rs                   Pointer to results set <br>//|   in       rd                   Pointer to row data <br>//| Returns: <br>//|   Nothing. <br>//*------------------------------------------------------------------------ <br>void EXTFUN FreeRowData(RESULTSSET FAR * rs, ROWDATA FAR * rd) <br>{ <br>   ReleaseMemory(rd-&gt;data); <br>   ReleaseMemory((LPVOID)rd-&gt;cd); <br>   ReleaseMemory((LPVOID)rd); <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| FreeResultsSet: <br>//|   Call this function to free all of the memory for a results set. <br>//| Parms: <br>//|   in       rs                   Pointer to results set data to free <br>//| Returns: <br>//|   TRUE     If successful <br>//|   FALSE    if there was an error <br>//*------------------------------------------------------------------------ <br>void EXTFUN FreeResultsSet(RESULTSSET FAR * rs) <br>{ <br>   int   dex; <br> <br>   DeleteObject(rs-&gt;hFont); <br> <br>   for(dex=0;  dex&lt;rs-&gt;cbColumns;  dex++) <br>      ReleaseMemory(rs-&gt;md[dex].szColumnName); <br>   ReleaseMemory(rs-&gt;md); <br>   ReleaseMemory(rs); <br>   return; <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| CreateResultsFont: <br>//|   This function is called to create a font for the results set.  The <br>//|   default font is used if the lf parameter is NULL.  Alternatively <br>//|   the user can pass in a complete LOGFONT structure to use for the <br>//|   font. <br>//| Parms: <br>//|   in       rs                   Pointer to results set to store info <br>//|   in       hwnd                 Window handle to verify font <br>//|   in       lf                   LOGFONT structure to use, NULL for dft <br>//| Returns: <br>//|   Nothing. <br>//*------------------------------------------------------------------------ <br>void CreateResultsFont(RESULTSSET FAR * rs, HWND hwnd, LOGFONT FAR * lf) <br>{ <br>   HDC                     hdc; <br>   LOGFONT                 logfont; <br>   HFONT                   hf; <br>   TEXTMETRIC              tm; <br>   SIZE                    sz; <br>   int                     tmp, dex, cbExtra; <br> <br>   if(!lf) { <br>      memset(&amp;logfont, 0, sizeof(LOGFONT)); <br>      GetDefaultFont(&amp;logfont); <br>   } <br>   else <br>      memmove(&amp;logfont, lf, sizeof(LOGFONT)); <br> <br>   rs-&gt;hFont = CreateFontIndirect(&amp;logfont); <br>   hdc = GetDC(hwnd); <br>   hf = SelectObject(hdc, rs-&gt;hFont); <br>   GetTextMetrics(hdc, &amp;tm); <br>   rs-&gt;cx = tm.tmAveCharWidth; <br> <br>   rs-&gt;cy = tm.tmHeight + tm.tmExternalLeading; <br>   cbExtra = GetSystemMetrics(SM_CYBORDER); <br>   rs-&gt;cTitleHeight = rs-&gt;cy + (7 * cbExtra); <br>   rs-&gt;yTitleLoc = (rs-&gt;cTitleHeight / 2) + rs-&gt;cy; <br>   for(dex=0, tmp=0;  dex&lt;rs-&gt;cbColumns;  dex++) { <br>      GetTextExtentPoint(hdc, rs-&gt;md[dex].szColumnName, <br>                         lstrlen(rs-&gt;md[dex].szColumnName), &amp;sz); <br>      rs-&gt;md[dex].cColWidth = (rs-&gt;md[dex].cbDisplaySize * rs-&gt;cx) + (7 * cbExtra); <br>      rs-&gt;md[dex].cColWidth = max((UINT)(sz.cx * 1.5), <br>                                  rs-&gt;md[dex].cColWidth); <br>      rs-&gt;md[dex].xCol = tmp; <br>      tmp += rs-&gt;md[dex].cColWidth; <br>   } <br>   rs-&gt;cRowWidth = tmp; <br> <br>   SelectObject(hdc,hf); <br>   ReleaseDC(hwnd, hdc); <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| FindRightCol: <br>//|   This function will take the left column and a results set descriptor <br>//|      and return the right column index based on what will fit in the <br>//|      window. <br>//| Parms: <br>//|   in       rs                   Pointer to results set to store info <br>//|   in       xLeftCol             Current left column index <br>//|   in       cWidth               Available width <br>//| Returns: <br>//|   Index to be used for right column <br>//*------------------------------------------------------------------------ <br>int FindRightCol(RESULTSSET FAR * rs, int xLeftCol, int cWidth) <br>{ <br>   int xRightCol; <br>   int cSpace; <br> <br>   xRightCol = xLeftCol; <br>   cSpace = cWidth - rs-&gt;md[xLeftCol].cColWidth; <br>   while(cSpace&gt;0 &amp;&amp; <br>         xRightCol &lt; rs-&gt;cbColumns-1) { <br>      ++xRightCol; <br>      cSpace -= rs-&gt;md[xRightCol].cColWidth; <br>   } <br>   return xRightCol; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| DrawRowData: <br>//|   This function will do the actual drawing on the screen based on the <br>//|      control structures passed in. <br>//| Parms: <br>//|   in       rs                   Pointer to results set to store info <br>//|   in       dwitem               Draw structure <br>//|   in       xLeftCol             Current left column index <br>//|   in       xRightCol            Right column index <br>//| Returns: <br>//|   Nothing. <br>//*------------------------------------------------------------------------ <br>void DrawRowData(RESULTSSET FAR * rs, DRAWITEMSTRUCT FAR * dwitem, <br>               int xLeftCol, int xRightCol) <br>{ <br>   switch(dwitem-&gt;itemAction) { <br>     case ODA_DRAWENTIRE: <br>     case ODA_SELECT: <br>      DrawRow(dwitem, rs, xLeftCol, xRightCol, <br>              (dwitem-&gt;itemState == ODS_SELECTED)); <br>      return; <br>   } <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| DrawColumnTitles: <br>//|   This function is called when we need to paint the column titles for a <br>//|      results set.  We will simply write them out. <br>//| Parms: <br>//|   in       hdc                  Handle to our device contex <br>//|   in       rs                   Our results set to draw <br>//|   in       crect                Client rectangle to paint in <br>//|   in       xLeftCol             Left column <br>//|   in       xRightCol            Right column <br>//| Returns: <br>//|   Nothing. <br>//*------------------------------------------------------------------------ <br>void INTFUN DrawColumnTitles(HDC hdc, RESULTSSET FAR * rs, <br>            RECT FAR * crect, int xLeftCol, int xRightCol) <br>{ <br>   int               dex, offset, cright=0; <br>   RECT              rect; <br>   HFONT             hf; <br> <br>   hf = SelectObject(hdc, rs-&gt;hFont); <br>   SetTextColor(hdc, RDATA_BLACK); <br>   offset = 0 - rs-&gt;md[xLeftCol].xCol; <br>   for (dex=xLeftCol; dex&lt;=xRightCol; dex++) <br>      cright += rs-&gt;md[dex].cColWidth; <br>   Rectangle(hdc, crect-&gt;left, crect-&gt;top, min(cright, crect-&gt;right), crect-&gt;bottom+1); <br>   SetBkColor(hdc, RDATA_GRAY); <br> <br>   rect.top = crect-&gt;top +1; <br>   rect.bottom = crect-&gt;bottom; <br>   for(dex=xLeftCol;  dex&lt;=xRightCol;  dex++) { <br>      rect.left = rs-&gt;md[dex].xCol + offset; <br>      rect.right = rect.left + rs-&gt;md[dex].cColWidth; <br>      MoveTo(hdc, rect.right, rect.top); <br>      LineTo(hdc, rect.right, rect.bottom); <br>      ++rect.left; <br>#ifdef TITLE_DEBUG <br>      { <br>         char tmpbuff[50]; <br>         wsprintf(tmpbuff, "Column: %d, left=%d, top=%d, right=%d, bottom=%d", <br>                  dex, <br>                  rect.left, rect.top, <br>                  rect.right, rect.bottom); <br>         DrawFocusRect(hdc, &amp;rect); <br>         MessageBox(NULL, (LPSTR)tmpbuff, "Debug", MB_OK); <br>         DrawFocusRect(hdc, &amp;rect); <br>      } <br>#endif <br>      ExtTextOut(hdc, rs-&gt;md[dex].xCol + 3 + offset, rect.top + 4, <br>                 ETO_CLIPPED | ETO_OPAQUE, <br>                 &amp;rect, <br>                 rs-&gt;md[dex].szColumnName, <br>                 lstrlen(rs-&gt;md[dex].szColumnName), <br>                 NULL); <br>   } <br>   SelectObject(hdc,hf);               // change font back <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| DrawRow: <br>//|   Call this function for each row which must be painted. <br>//| Parms: <br>//|   in       dw                   Draw structure <br>//|   in       rs                   Our results set to draw <br>//|   in       xLeftCol             Index to left-most column displayed <br>//|   in       xRightCol            Index to right-most column displayed <br>//|   in       fSelect              Is the item supposed to be selected? <br>//| Returns: <br>//|   TRUE if successful, <br>//|   FALSE otherwise <br>//*------------------------------------------------------------------------ <br>//#define RECT_DEBUG <br>BOOL INTFUN DrawRow(DRAWITEMSTRUCT FAR * dw, <br>                     RESULTSSET FAR * rs, <br>                     int xLeftCol, int xRightCol, <br>                     BOOL fSelect) <br>{ <br>   ROWDATA FAR *     rd=(ROWDATA FAR *)dw-&gt;itemData; <br>   int               dex; <br>   int               offset; <br>   int               cright=0; <br>   RECT              rect; <br>   HFONT             hf; <br> <br>   // <br>   // First set the font and text colors according to the user's request, then draw <br>   //    a line at the bottom of the row for a separator.  Note that the rcItem <br>   //    rectangle passed to us in the DRAWITEMSTRUCT is for the <br>   // <br>   hf = SelectObject(dw-&gt;hDC, rs-&gt;hFont); <br>   dw-&gt;rcItem.right = min(rs-&gt;cRowWidth, dw-&gt;rcItem.right); <br>   for (dex=xLeftCol; dex&lt;=xRightCol; dex++) <br>      cright += rs-&gt;md[dex].cColWidth; <br>   // Draw top of box <br>   MoveTo(dw-&gt;hDC, dw-&gt;rcItem.left, dw-&gt;rcItem.top); <br>   LineTo(dw-&gt;hDC, min(cright, dw-&gt;rcItem.right), dw-&gt;rcItem.top); <br> <br>   // Draw bottom also, to take care of last line <br>   MoveTo(dw-&gt;hDC, dw-&gt;rcItem.left, dw-&gt;rcItem.bottom); <br>   LineTo(dw-&gt;hDC, min(cright, dw-&gt;rcItem.right), dw-&gt;rcItem.bottom); <br> <br>#ifdef RECT_DEBUG <br>   { <br>      char tmpbuff[50]; <br>      wsprintf(tmpbuff, "dw-&gt;rcItem, left=%d, top=%d, right=%d, bottom=%d", <br>               dw-&gt;rcItem.left, dw-&gt;rcItem.top, <br>               dw-&gt;rcItem.right, dw-&gt;rcItem.bottom); <br>      DrawFocusRect(dw-&gt;hDC, &amp;dw-&gt;rcItem); <br>      MessageBox(NULL, (LPSTR)tmpbuff, "Debug", MB_OK); <br>      DrawFocusRect(dw-&gt;hDC, &amp;dw-&gt;rcItem); <br>   } <br>#endif <br> <br>   // <br>   // Now loop through each column in the row and draw it's contents by creating <br>   //    a logical rectangle for each column, then filling in that rectangle with <br>   //    the value to be displayed. <br>   // <br>   rect.top = dw-&gt;rcItem.top+1; <br>   rect.bottom = dw-&gt;rcItem.bottom; <br>   SetBkMode(dw-&gt;hDC, TRANSPARENT); <br>   if(fSelect) { <br>      SetBkColor(dw-&gt;hDC, GetSysColor(COLOR_HIGHLIGHT)); <br>      SetTextColor(dw-&gt;hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)); <br>   } <br>   else { <br>      SetBkColor(dw-&gt;hDC, rd-&gt;bkgrnd); <br>      SetTextColor(dw-&gt;hDC, rd-&gt;textColor); <br>   } <br>   offset = 0 - rs-&gt;md[xLeftCol].xCol; <br>   for (dex=xLeftCol; dex&lt;=xRightCol; dex++) { <br>      rect.left = offset + rs-&gt;md[dex].xCol; <br>      rect.right = rect.left + rs-&gt;md[dex].cColWidth; <br>      MoveTo(dw-&gt;hDC, rect.right, rect.top); <br>      LineTo(dw-&gt;hDC, rect.right, rect.bottom); <br> <br>#ifdef RECT_DEBUG <br>      { <br>         char tmpbuff[50]; <br>         wsprintf(tmpbuff, "Column: %d, left=%d, top=%d, right=%d, bottom=%d", <br>                  dex, <br>                  rect.left, rect.top, <br>                  rect.right, rect.bottom); <br>         DrawFocusRect(dw-&gt;hDC, &amp;rect); <br>         MessageBox(NULL, (LPSTR)tmpbuff, "Debug", MB_OK); <br>         DrawFocusRect(dw-&gt;hDC, &amp;rect); <br>      } <br>#endif <br>      SetTextAlign(dw-&gt;hDC, rs-&gt;md[dex].fAlign); <br>      if(dex != xLeftCol) <br>         ++rect.left; <br>      ExtTextOut(dw-&gt;hDC, rs-&gt;md[dex].xCol + 3 + offset, rect.top + 4, <br>                 ETO_CLIPPED | ETO_OPAQUE, <br>                 &amp;rect, <br>                 rd-&gt;cd[dex].szCols, <br>                 lstrlen(rd-&gt;cd[dex].szCols), <br>                 NULL); <br>   } <br>   SelectObject(dw-&gt;hDC,hf);              // change font back <br> <br>   return TRUE; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| HandleHScroll: <br>//|   This function adds a new item to our results set. <br>//| Parms: <br>//|   in       wParam               Scroll option <br>//|   in       rs                   Results set pointer <br>//|   in       hwnd                 Window handle for column title <br>//|   in       hwndHScroll          Scroll bar window handle <br>//|   in       xLeftCol             Left column index <br>//|   in       xRightCol            Right column index <br>//|   in       hwndList             Listbox window handle <br>//|   in       cbColumns            Number of columns <br>//|   in       cbClient             Width of screen available to draw in <br>//|   in       tRect                Bounding rectangle for client window <br>//| Returns: <br>//|   Index to string if successful, LB_ERRSPACE otherwise <br>//*------------------------------------------------------------------------ <br>void HandleHScroll(WPARAM wParam, RESULTSSET FAR * rs, <br>         HWND hwnd, HWND hwndHScroll, int FAR * xLeftCol, int FAR * xRightCol, <br>         HWND hwndList, int cbColumns, int cbClient, RECT FAR * tRect) <br>{ <br>   int      cHScrollPos; <br>   int      fhScroll=FALSE; <br> <br>   cHScrollPos = GetScrollPos(hwndHScroll, SB_CTL); <br>   switch(wParam) { <br>     case SB_LINEUP:          // Shift right one column <br>      if(!*xLeftCol) <br>         fhScroll = FALSE; <br>      else { <br>         --cHScrollPos; <br>         fhScroll = TRUE; <br>         --*xLeftCol; <br>      } <br>      break; <br> <br>     case SB_LINEDOWN:           // Shift left one column <br>      if(*xLeftCol+1 == cbColumns) <br>         fhScroll = FALSE;             // No change required <br>      else { <br>         ++cHScrollPos; <br>         fhScroll = TRUE; <br>         ++*xLeftCol; <br>      } <br>      break; <br> <br>     case SB_PAGEUP:          // Shift right one screen <br>      if(!*xLeftCol) <br>         fhScroll = FALSE; <br>      else { <br>         --cHScrollPos; <br>         fhScroll = TRUE; <br>         --*xLeftCol; <br>      } <br>      break; <br> <br>     case SB_PAGEDOWN:           // Shift left one screen <br>      if(*xLeftCol+1 == cbColumns) <br>         fhScroll = FALSE;             // No change required <br>      else { <br>         if(*xLeftCol &lt; *xRightCol) { <br>            cHScrollPos += *xRightCol - *xLeftCol; <br>            *xLeftCol = *xRightCol; <br>            fhScroll = TRUE; <br>         } <br>         else { <br>            ++cHScrollPos; <br>            ++*xLeftCol; <br>            fhScroll = TRUE; <br>         } <br>      } <br>      break; <br> <br>     case SB_THUMBPOSITION:      // Specific location <br>      break; <br>   } <br> <br>   // <br>   // If movement is required, we will have adjusted the scroll position <br>   //    and columns already.  Calculate what columns will fit on our current <br>   //    display to find the rightmost column.  Next invalidate the areas <br>   //    requiring painting and set the new scroll position.  This will cause <br>   //    each row to be redrawn starting with the new rwi-&gt;xLeftCol. <br>   // <br>   if(fhScroll) {                      // Movement is required <br>      RECT     rect; <br>      *xRightCol = FindRightCol(rs, *xLeftCol, cbClient); <br>      GetClientRect(hwndList, &amp;rect); <br>      InvalidateRect(hwndList, &amp;rect, TRUE); <br>      SetScrollPos(hwndHScroll, SB_CTL, cHScrollPos, TRUE); <br>      InvalidateRect(hwnd, tRect, TRUE); <br>   } <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| HandleVirtualHScroll: <br>//|   This function should be called in response to the WM_KEYDOWN <br>//|   message. It will look for a virtual key to see if the user <br>//|   is trying to do scrolling.  If so, we will force the scroll <br>//|   to happen. <br>//| Parms: <br>//|   in       wParam               Value of wParam for WM_KEYDOWN <br>//|   in       hwndList             Handle of list box <br>//|   in       hwndOwner            Owner window of the horizontal scrollbar <br>//| Returns: <br>//|   Nothing. <br>//*------------------------------------------------------------------------ <br>void HandleVirtualHScroll(WPARAM wParam, HWND hwndList, HWND hwndOwner) <br>{ <br>   switch(wParam) { <br>     case VK_HOME: <br>      SendMessage(hwndList, WM_VSCROLL, SB_TOP, 0L); <br>      return; <br> <br>     case VK_END: <br>      SendMessage(hwndList, WM_VSCROLL, SB_BOTTOM, 0L); <br>      return; <br> <br>     case VK_PRIOR: <br>      SendMessage(hwndList, WM_VSCROLL, SB_PAGEUP, 0L); <br>      return; <br> <br>     case VK_NEXT: <br>      SendMessage(hwndList, WM_VSCROLL, SB_PAGEDOWN, 0L); <br>      return; <br> <br>     case VK_UP: <br>      SendMessage(hwndList, WM_VSCROLL, SB_LINEUP, 0L); <br>      return; <br> <br>     case VK_DOWN: <br>      SendMessage(hwndList, WM_VSCROLL, SB_LINEDOWN, 0L); <br>      return; <br> <br>     case VK_LEFT: <br>      SendMessage(hwndOwner, WM_HSCROLL, SB_LINEUP, 0L); <br>      return; <br> <br>     case VK_RIGHT: <br>      SendMessage(hwndOwner, WM_HSCROLL, SB_LINEDOWN, 0L); <br>      return; <br>   } <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| AddRowData: <br>//|   This function adds a new item to our results set. <br>//| Parms: <br>//|   in       rs                   Pointer to results set <br>//|   in       rd                   Pointer to row data to add <br>//| Returns: <br>//|   Index to string if successful, LB_ERRSPACE otherwise <br>//*------------------------------------------------------------------------ <br>int AddRowData(RESULTSSET FAR * rs, ROWDATA FAR * rd) <br>{ <br>   int         rtn; <br>   DWORD       cbCnt; <br>   rtn = (int)SendMessage(rs-&gt;hwndList, LB_ADDSTRING, 0, (LPARAM)(ROWDATA FAR *)rd); <br>   if(rtn == LB_ERRSPACE) { <br>      cbCnt = SendMessage(rs-&gt;hwndList, LB_GETCOUNT, 0, 0L); <br>      wsprintf(szErrMsg, szMaxRowsFetched, cbCnt); <br>      MessageBox(rs-&gt;hwndClient, szErrMsg, szErrTitle, MB_OK); <br>   } <br>   return rtn; <br>} <br> <br> <br> <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| GetNumResultsCols: <br>//|   Given an hstmt which has an executed statement on it, find the number <br>//|      of results columns in it. <br>//| Parms: <br>//|   in       hstmt                Statement handle with results set <br>//| Returns: <br>//|   Number of columns <br>//*------------------------------------------------------------------------ <br>SWORD GetNumResultsCols(HSTMT hstmt) <br>{ <br>   SWORD cbCols; <br>   RETCODE retcode; <br> <br>   retcode = SQLNumResultCols(hstmt, &amp;cbCols); <br>   if(RC_NOTSUCCESSFUL(retcode)) <br>      return -1; <br>   else <br>      return cbCols; <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| GetTypeName: <br>//|   This function will return the null-terminated character name of <br>//|   the type passed in. <br>//| Parms: <br>//|   in       type                 SQL_TYPE or C_TYPE <br>//|   in       fType                The fCType or fSqlType <br>//| Returns: <br>//|   Nothing. <br>//*------------------------------------------------------------------------ <br>LPSTR GetTypeName(int type, int fType) <br>{ <br>   int               dex, stopdex; <br>   DATATYPE FAR *    dt; <br> <br>   if(type == SQL_TYPE) { <br>      stopdex = NumItems(SqlTypes); <br>      dt = (DATATYPE FAR *)&amp;SqlTypes; <br>   } <br>   else { <br>      stopdex = NumItems(CTypes); <br>      dt = (DATATYPE FAR *)&amp;CTypes; <br>   } <br>   for(dex=0;  dex&lt;stopdex;  dex++) <br>      if(dt[dex].type == fType) <br>         return dt[dex].sztype; <br>   return (LPSTR)szTypeNotFound; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| ConvertSqlTypeToChar: <br>//|   This function will convert the value passed in to it's character equivalent. <br>//| Parms: <br>//|   in       rs                   Pointer to results set <br>//|   in       col                  Which column is it? <br>//|   in       inbuff               Input buffer <br>//|   in       outbuff              Output buffer <br>//|   in       rtnd                 Returned bytes from SQLGetData <br>//| Returns: <br>//|   Nothing. <br>//*------------------------------------------------------------------------ <br>void ConvertSqlTypeToChar(RESULTSSET FAR * rs, int col, LPSTR inbuff, <br>         LPSTR outbuff, SDWORD rtnd) <br>{ <br>   LPSTR                   tmpstr; <br>   SWORD FAR *             tmpsword; <br>   SDWORD FAR *            tmpsdword; <br>   SFLOAT FAR *            tmpsfloat; <br>   SDOUBLE FAR *           tmpsdouble; <br>   DATE_STRUCT FAR *       tmpdate; <br>   TIME_STRUCT FAR *       tmptime; <br>   TIMESTAMP_STRUCT FAR *  tmptimestmp; <br> <br>   *outbuff = '\0'; <br>   switch(rs-&gt;md[col].fSqlType) { <br>      // <br>      // Look for any non-displayable characters and change them to periods <br>      // <br>     case SQL_CHAR: <br>     case SQL_VARCHAR: <br>     case SQL_LONGVARCHAR: <br>      CheckDisplayMode((LPSTR)inbuff, rtnd, outbuff); <br>      tmpstr = outbuff + rtnd; <br>      *tmpstr = '\0'; <br>      break; <br> <br>     case SQL_BINARY: <br>     case SQL_VARBINARY: <br>     case SQL_LONGVARBINARY: <br>      lstrcpy(outbuff, "0x"); </code></pre>
<p>
</p>
<pre><code>BinToChar(outbuff+2, (LPSTR)inbuff, rtnd); <br>      break; <br> <br>     case SQL_TINYINT: <br>     case SQL_SMALLINT: <br>      tmpsword = (SWORD FAR *)inbuff; <br>      wsprintf(outbuff, "%d", *tmpsword); <br>      break; <br> <br>     case SQL_INTEGER: <br>     case SQL_BIGINT: <br>      tmpsdword = (SDWORD FAR *)inbuff; <br>      wsprintf(outbuff, "%ld", *tmpsdword); <br>      break; <br> <br>     case SQL_FLOAT: <br>     case SQL_DOUBLE: <br>      tmpsdouble = (SDOUBLE FAR *)inbuff; <br>      sprintf(outbuff, "%Fg", *tmpsdouble); <br>      break; <br> <br>     case SQL_REAL: <br>      tmpsfloat = (SFLOAT FAR *)inbuff; <br>      sprintf(outbuff, "%Fg", *tmpsfloat); <br>      break; <br> <br>     case SQL_BIT: <br>      tmpsword = (SWORD FAR *)inbuff; <br>      lstrcpy(outbuff, (*tmpsword) ? (LPSTR)szONE : (LPSTR)szZERO); <br>      break; <br> <br>     case SQL_DECIMAL: <br>     case SQL_NUMERIC: <br>      lstrcpy(outbuff, inbuff); <br>      break; <br> <br>     case SQL_DATE: <br>      tmpdate = (DATE_STRUCT FAR *)inbuff; <br>      wsprintf(outbuff, szdate, tmpdate-&gt;month, tmpdate-&gt;day, tmpdate-&gt;year); <br>      break; <br> <br>     case SQL_TIME: <br>      tmptime= (TIME_STRUCT FAR *)inbuff; <br>      wsprintf(outbuff, sztime, tmptime-&gt;hour, tmptime-&gt;minute, tmptime-&gt;second); <br>      break; <br> <br>     case SQL_TIMESTAMP: <br>      tmptimestmp = (TIMESTAMP_STRUCT FAR *)inbuff; <br>      wsprintf(outbuff, sztimestmp, tmptimestmp-&gt;year, tmptimestmp-&gt;month, <br>               tmptimestmp-&gt;day, tmptimestmp-&gt;hour, tmptimestmp-&gt;minute, <br>               tmptimestmp-&gt;second, tmptimestmp-&gt;fraction); <br>      break; <br>   } <br> <br>   return; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| CheckDisplayMode: <br>//|   This function looks through a string for the count specified, then <br>//|      changes any x"00" to a period so it can be displayed. <br>//| Parms: <br>//|   strin       - String coming in <br>//|   cbin        - Byte count of incoming string <br>//|   strout      - Output string <br>//*------------------------------------------------------------------------ <br>void CheckDisplayMode(LPSTR strin, SDWORD cbin, LPSTR strout) <br>{ <br>   SDWORD      dex,max=cbin; <br>   LPSTR    str=strout; <br> <br>   if(cbin &lt; 0) <br>      max = lstrlen(strin); <br>   memcpy(strout, strin, (size_t)max); <br>   for(dex=0; dex&lt;cbin; dex++, str++) <br>      if(!*str) <br>         *str = '.'; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| BinToChar: <br>//|   Takes a string and converts to its hexidecimal equivalent <br>//*------------------------------------------------------------------------ <br>void BinToChar(LPSTR outstr, LPSTR instr, SDWORD count) <br>{ <br>   UCHAR uletter; <br>   LPSTR istr=instr; <br>   LPSTR ostr=outstr; <br> <br>   while(count--) { <br>      uletter = (*instr &amp; 0xF0) &gt;&gt; 4;              // High nibble <br>      if(uletter &lt;= 9) <br>         *ostr++ = uletter + '0'; <br>      else <br>         *ostr++ = 'A' + (uletter - 10); <br>      uletter = *instr++ &amp; 0x0F; <br>      if(uletter &lt;= 9) <br>         *ostr++ = uletter + '0'; <br>      else <br>         *ostr++ = 'A' + (uletter - 10); <br>   } <br>   *ostr = '\0'; <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
