<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2258"></a>DIALOGS.C</h2>
<pre><code>//*--------------------------------------------------------------------------------- <br>//|  ODBC System Administrator <br>//| <br>//|  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>//|  intended for example purposes only. <br>//| <br>//|   Title:   DIALOGS.C <br>//|      This module contains the dialog procs which are used to display <br>//|         catalog function arguements and display the results.  Note that <br>//|         the best way to determine the size of the arguements would be <br>//|         to use SQLGetInfo, however, due to ease of coding, the values <br>//|         have been hard-coded to constants. <br>//*--------------------------------------------------------------------------------- <br>#include &lt;windows.h&gt; <br>#include "admndemo.h" <br>#include "dialogs.h" <br>#include "sql.h" <br>#include "sqlext.h" <br>#include "execute.h" <br>#include "info.h" <br>#include "results.h" <br>#include "strings.h" <br> <br>VSZFile; <br>#define CHKNULL(str)  (*str ? str : NULL) <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Local function prototypes <br>//*--------------------------------------------------------------------------------- <br>BOOL ShowCatalogResults(CHILDINFO FAR * ci, LPSTR szTitle); <br>BOOL EXTFUN CatalogWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam); <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Global variables <br>//*--------------------------------------------------------------------------------- <br>extern char OutStr[MAXBUFF]; <br> <br> <br>// <br>// The following set of defines and host vars are used to create a common <br>// dialog handler for each of the catalog function dialogs.  This makes <br>// the code size smaller while still handling each catalog functions <br>// parameters.  It also allows for sharing of values from one function <br>// to another. <br>// <br>#define CAT_LAST         256 <br>#define CAT_QUALIFIER      1 <br>#define CAT_TABLE          2 <br>#define CAT_OWNER          4 <br>#define CAT_TYPE           8 <br>#define CAT_COLUMN        16 <br>#define CAT_QUALIFIER2    32 <br>#define CAT_OWNER2        64 <br>#define CAT_TABLE2       128 <br>#define CAT_PROCS        256 <br>char szQualifierVal[MAX_QUALIFIER]; <br>char szTableVal[MAX_NAME]; <br>char szOwnerVal[MAX_OWNER]; <br>char szTypeVal[MAX_NAME]; <br>char szColumnVal[MAX_NAME]; <br>char szQualifierVal2[MAX_QUALIFIER]; <br>char szOwnerVal2[MAX_OWNER]; <br>char szTableVal2[MAX_NAME]; <br>char szProcsVal[MAX_NAME]; <br> <br>struct { <br>   int         mMask;                        // Bit mask value <br>   int         id;                           // Edit control id <br>   LPSTR       szStr;                        // Buffer location <br>   int         cbMax;                        // Maximum size <br>   } CatalogVals[] = { <br>// mMask                id                      szStr                   cbMax <br>// -------------------  ---------------------   ----------------------- ------------------------ <br>   CAT_QUALIFIER,       IDE_QUALIFIER,          (LPSTR)szQualifierVal,  MAX_QUALIFIER, <br>   CAT_TABLE,           IDE_TABLE,              (LPSTR)szTableVal,      MAX_NAME, <br>   CAT_OWNER,           IDE_OWNER,              (LPSTR)szOwnerVal,      MAX_OWNER, <br>   CAT_TYPE,            IDE_TYPE,               (LPSTR)szTypeVal,       MAX_NAME, <br>   CAT_COLUMN,          IDE_COLUMN,             (LPSTR)szColumnVal,     MAX_NAME, <br>   CAT_QUALIFIER2,      IDE_QUALIFIER2,         (LPSTR)szQualifierVal2, MAX_QUALIFIER, <br>   CAT_OWNER2,          IDE_OWNER2,             (LPSTR)szOwnerVal2,     MAX_OWNER, <br>   CAT_TABLE2,          IDE_TABLE2,             (LPSTR)szTableVal2,     MAX_NAME, <br>   CAT_PROCS,           IDE_PROCEDURE,          (LPSTR)szProcsVal,      MAX_NAME, <br>   }; <br> <br>dCSEG(char) szTablesTitle[]               =  "Tables"; <br>dCSEG(char) szColumnsTitle[]              =  "Columns"; <br>dCSEG(char) szStatistics[]                =  "Statistics"; <br>dCSEG(char) szPrimaryKeys[]               =  "Primary Keys"; <br>dCSEG(char) szForeignKeys[]               =  "Foreign Keys"; <br>dCSEG(char) szTablePrivs[]                =  "Table Privileges"; <br>dCSEG(char) szColumnPrivs[]               =  "Column Privileges"; <br>dCSEG(char) szSpecialCols[]               =  "Special Columns"; <br>dCSEG(char) szProcsTitle[]                =  "Procedures"; <br>dCSEG(char) szProcCols[]                  =  "Procedure Columns"; <br>dCSEG(char) szCOLON[]                     =  ":"; <br> <br> <br>struct { <br>   int               idMenu;                    // Menu identifier <br>   int               iDialogName;               // ID of dialog <br>// DLGWNDPROC        dlgProc;                   // Dialog procedure <br>   LPSTR             szDlgTitle;                // Title of the dialog <br>   UINT              mask;                      // Mask for this dialog <br>   } Dialogs[] = { <br>// idMenu                  iDialogName                szDlgTitle              mask <br>// ---------------------   ------------------         ----------------------- ------------------------------------------------- <br>   IDM_TABLES,             IDD_SQLTABLES,             (LPSTR)szTablesTitle,   CAT_QUALIFIER | CAT_OWNER | CAT_TABLE | CAT_TYPE, <br>   IDM_COLUMNS,            IDD_SQLCOLUMNS,            (LPSTR)szColumnsTitle,  CAT_QUALIFIER | CAT_OWNER | CAT_TABLE | CAT_COLUMN, <br>   IDM_STATISTICS,         IDD_SQLSTATISTICS,         (LPSTR)szStatistics,    CAT_QUALIFIER | CAT_OWNER | CAT_TABLE, <br>   IDM_PRIMARY_KEYS,       IDD_SQLPRIMARYKEYS,        (LPSTR)szPrimaryKeys,   CAT_QUALIFIER | CAT_OWNER | CAT_TABLE, <br>   IDM_FOREIGN_KEYS,       IDD_SQLFOREIGNKEYS,        (LPSTR)szForeignKeys,   CAT_QUALIFIER | CAT_OWNER | CAT_TABLE | CAT_QUALIFIER2 | CAT_OWNER2 | CAT_TABLE2, <br>   IDM_TABLE_PRIVS,        IDD_SQLTABLEPRIVILEGES,    (LPSTR)szTablePrivs,    CAT_QUALIFIER | CAT_OWNER | CAT_TABLE, <br>   IDM_COLUMN_PRIVS,       IDD_SQLCOLUMNPRIVILEGES,   (LPSTR)szColumnPrivs,   CAT_QUALIFIER | CAT_OWNER | CAT_TABLE | CAT_COLUMN, <br>   IDM_SPECIAL_COLUMNS,    IDD_SQLSPECIALCOLUMNS,     (LPSTR)szSpecialCols,   CAT_QUALIFIER | CAT_OWNER | CAT_TABLE, <br>   IDM_PROCEDURES,         IDD_SQLPROCEDURES,         (LPSTR)szProcsTitle,    CAT_QUALIFIER | CAT_OWNER | CAT_PROCS, <br>   IDM_PROC_COLUMNS,       IDD_SQLPROCEDURECOLUMNS,   (LPSTR)szProcCols,      CAT_QUALIFIER | CAT_OWNER | CAT_PROCS | CAT_COLUMN, <br>   }; <br> <br>// <br>// This structure is used to control the catalog fucntions <br>// <br>typedef struct tagCATALOGINFO { <br>   HINSTANCE         hInst;               // Instance handle for this app <br>   CHILDINFO FAR *   ci;                  // Child info <br>   int               id;                  // Dialog id to indicate function <br>   LPSTR             szDlgTitle;          // Title for the dialog <br>   UINT              mask;                // Dialog control mask <br>// For SQLStatistics <br>   UWORD             fUnique; <br>   UWORD             fAccuracy; <br>// For SQLSpecialColumns <br>   UWORD             fColType; <br>   UWORD             fScope; <br>   UWORD             fNullable; <br>   } CATALOGINFO; <br> <br>// <br>// A prototype for radio button controls <br>// <br>typedef struct tagIDXINFO { <br>   int               idxVal; <br>   int               fType; <br>   } IDXINFO; <br> <br>// <br>// For SQLStatistics, fUnqiue parameter <br>// <br>struct { <br>   int               idxVal;                    // Dialog item number <br>   int               fType;                     // SQL constant equivalent <br>   } StatsfUnique[] = { <br>// idxVal                        fType <br>// --------------------------    --------------------------------- <br>   IDX_INDEX_UNIQUE,             SQL_INDEX_UNIQUE, <br>   IDX_INDEX_ALL,                SQL_INDEX_ALL, <br>   }; <br> <br>// <br>// For SQLStatistics, fAccuracy parameter <br>// <br>struct { <br>   int               idxVal;                    // Dialog item number <br>   int               fType;                     // SQL constant equivalent <br>   } StatsfAccuracy[] = { <br>// idxVal                        fType <br>// --------------------------    --------------------------------- <br>   IDX_ENSURE,                   SQL_ENSURE, <br>   IDX_QUICK,                    SQL_QUICK, <br>   }; <br> <br>// <br>// For SQLSpecialColumns, fColType parameter <br>// <br>struct { <br>   int               idxVal;                    // Dialog item number <br>   int               fType;                     // SQL constant equivalent <br>   } SpecColsfColType[] = { <br>// idxVal                        fType <br>// --------------------------    --------------------------------- <br>   IDX_BEST_ROWID,               SQL_BEST_ROWID, <br>   IDX_ROWVER,                   SQL_ROWVER, <br>   }; <br> <br>// <br>// For SQLSpecialColumns, fNullable parameter <br>// <br>struct { <br>   int               idxVal;                    // Dialog item number <br>   int               fType;                     // SQL constant equivalent <br>   } SpecColsfNullable[] = { <br>// idxVal                        fType <br>// --------------------------    --------------------------------- <br>   IDX_NO_NULLS,                 SQL_NO_NULLS, <br>   IDX_NULLABLE,                 SQL_NULLABLE, <br>   }; <br> <br>// <br>// For SQLSpecialColumns, fScope parameter <br>// <br>struct { <br>   int               idxVal;                    // Dialog item number <br>   int               fType;                     // SQL constant equivalent <br>   } SpecColsfScope[] = { <br>// idxVal                        fType <br>// --------------------------    --------------------------------- <br>   IDX_SCOPE_CURROW,             SQL_SCOPE_CURROW, <br>   IDX_SCOPE_TRANSACTION,        SQL_SCOPE_TRANSACTION, <br>   IDX_SCOPE_SESSION,            SQL_SCOPE_SESSION, <br>   }; <br> <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| GetRadioValue: <br>//|   This function will examine a group of radio buttons based on the control <br>//|   structure and see which is checked.  When found, that value is returned. <br>//| Parms: <br>//|   hDlg           Window handle of dialog with control <br>//|   stct           Radio control structure <br>//|   cbNum          How many items in control structure <br>//| Returns: <br>//|   The value for the item checked <br>//*--------------------------------------------------------------------------------- <br>int GetRadioValue(HWND hDlg, IDXINFO FAR * stct, int cbNum) <br>{ <br>   int   dex; <br>   for(dex=0;  dex&lt;cbNum;  dex++) <br>      if(IsDlgButtonChecked(hDlg, stct[dex].idxVal)) <br>         return(stct[dex].fType); <br>   return 0; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| ShowCatalogResults: <br>//|   This function will display the results set returned by a catalog <br>//|   function. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//|   in       szTitle              Title for the results set <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>BOOL ShowCatalogResults(CHILDINFO FAR * ci, LPSTR szTitle) <br>{ <br>   RESULTSSET FAR *  rs; <br>   int               cbCols; <br> <br>   if(!(cbCols = GetNumResultsCols(ci-&gt;hstmt))) <br>      return TRUE; <br>   if(cbCols == 0) { <br>      szWrite(ci-&gt;hwndOut, GetidsString(idsNoDataFound, OutStr, sizeof(OutStr))); <br>      return TRUE; <br>   } <br>   rs = GetConnectWindowResultsNode(ci); <br>   if(!CreateResultsSet(rs, ci-&gt;hwndClient, ci-&gt;hInst, <br>                        cbCols, szTitle)) <br>      return TRUE; <br>   SetMetaDataFromSql(ci-&gt;hwndOut, ci-&gt;hstmt, rs, cbCols); <br>   if(!CreateResultsWindow(ci, rs)) <br>      return TRUE; <br>   FetchAllRecordsToResults(ci-&gt;hwndOut, ci-&gt;hstmt, rs, cbCols, TRUE); <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br> <br>   return FALSE; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoList: <br>//|   This function will display a selection dialog for the catalog functions <br>//|   then process the request. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//|   in       idMenuSelection      Menu value <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void DoList(CHILDINFO FAR * ci, int idMenuSelection) <br>{ <br>   static BOOL             fInit;            // Have we called before <br>   CATALOGINFO             cati; <br>   CATALOGINFO FAR *       lpcati=&amp;cati; <br>   int                     dex; <br>   HWND                    fHwnd=GetFocus(); <br> <br>   // Clean up all buffers on first catalog function <br>   if(!fInit) { <br>      for(dex=0;  dex&lt;NumItems(CatalogVals);  dex++) <br>         memset(CatalogVals[dex].szStr, 0, CatalogVals[dex].cbMax); <br>      fInit = TRUE; <br>   } <br> <br>   // Find the dialog <br>   for(dex=0;  dex&lt;NumItems(Dialogs) &amp;&amp; <br>       Dialogs[dex].idMenu != idMenuSelection;  dex++); <br> <br>   // Collect information for the dialog proc <br>   cati.hInst = ci-&gt;hInst; <br>   cati.id = idMenuSelection; <br>   cati.ci = ci; <br>   cati.szDlgTitle = Dialogs[dex].szDlgTitle; <br>   cati.mask = Dialogs[dex].mask; <br> <br>   // Display the dialog <br>   if(-1 == DialogBoxParam(cati.hInst, <br>                           MAKEINTRESOURCE(Dialogs[dex].iDialogName), <br>                           ci-&gt;hwnd, <br>                           (DLGPROC) CatalogWndProc, (LPARAM)(CATALOGINFO FAR *)lpcati)) <br>      MessageBox(NULL, "Could not open dialog box.", <br>                 "DoList", MB_ICONEXCLAMATION); <br> <br>   if(fHwnd) <br>      SetFocus(fHwnd); <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoCatalogFunction: <br>//|   The caller should have prepared all the information we need, so we will <br>//|   simply invoke the function they want to run. <br>//| <br>//| Parms: <br>//|   cati     CATALOGINFO <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>void DoCatalogFunction(CATALOGINFO FAR * cati) <br>{ <br>   char                 szTitle[MAXBUFF]; <br>   RETCODE              retcode; <br>   CHILDINFO FAR *      ci=cati-&gt;ci; <br> <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br> <br>   switch(cati-&gt;id) { <br>     case IDM_TABLES: <br>      if (!*szTableVal &amp;&amp; <br>          ((!*szOwnerVal &amp;&amp; strcmp(szQualifierVal, "%") == 0)|| <br>           (!*szQualifierVal &amp;&amp; strcmp(szOwnerVal, "%") == 0))) <br>         retcode = SQLTables(ci-&gt;hstmt, <br>                             szQualifierVal, SQL_NTS, <br>                             szOwnerVal, SQL_NTS, <br>                             szTableVal, SQL_NTS, <br>                             szTypeVal, SQL_NTS); <br>      else <br>         retcode = SQLTables(ci-&gt;hstmt, <br>                             CHKNULL(szQualifierVal), SQL_NTS, <br>                             CHKNULL(szOwnerVal), SQL_NTS, <br>                             CHKNULL(szTableVal), SQL_NTS, <br>                             CHKNULL(szTypeVal), SQL_NTS); <br>      break; <br> <br>     case IDM_COLUMNS: <br>      retcode = SQLColumns(ci-&gt;hstmt, <br>                           CHKNULL(szQualifierVal), SQL_NTS, <br>                           CHKNULL(szOwnerVal), SQL_NTS, <br>                           CHKNULL(szTableVal), SQL_NTS, <br>                           CHKNULL(szColumnVal), SQL_NTS); <br>      break; <br> <br>     case IDM_STATISTICS: <br>      retcode = SQLStatistics(ci-&gt;hstmt, <br>                              CHKNULL(szQualifierVal), SQL_NTS, <br>                              CHKNULL(szOwnerVal), SQL_NTS, <br>                              CHKNULL(szTableVal), SQL_NTS, <br>                              cati-&gt;fUnique, <br>                              cati-&gt;fAccuracy); <br>      break; <br> <br>     case IDM_PRIMARY_KEYS: <br>      retcode = SQLPrimaryKeys(ci-&gt;hstmt, <br>                               CHKNULL(szQualifierVal), SQL_NTS, <br>                               CHKNULL(szOwnerVal), SQL_NTS, <br>                               CHKNULL(szTableVal), SQL_NTS); <br>      break; <br> <br>     case IDM_FOREIGN_KEYS: <br>      retcode = SQLForeignKeys(ci-&gt;hstmt, <br>                               CHKNULL(szQualifierVal), SQL_NTS, <br>                               CHKNULL(szOwnerVal), SQL_NTS, <br>                               CHKNULL(szTableVal), SQL_NTS, <br>                               CHKNULL(szQualifierVal2), SQL_NTS, <br>                               CHKNULL(szOwnerVal2), SQL_NTS, <br>                               CHKNULL(szTableVal2), SQL_NTS); <br>      break; <br> <br>     case IDM_TABLE_PRIVS: <br>      retcode = SQLTablePrivileges(ci-&gt;hstmt, <br>                                   CHKNULL(szQualifierVal), SQL_NTS, <br>                                   CHKNULL(szOwnerVal), SQL_NTS, <br>                                   CHKNULL(szTableVal), SQL_NTS); <br>      break; <br> <br>     case IDM_COLUMN_PRIVS: <br>      retcode = SQLColumnPrivileges(ci-&gt;hstmt, <br>                                    CHKNULL(szQualifierVal), SQL_NTS, <br>                                    CHKNULL(szOwnerVal), SQL_NTS, <br>                                    CHKNULL(szTableVal), SQL_NTS, <br>                                    CHKNULL(szColumnVal), SQL_NTS); <br>      break; <br> <br>     case IDM_SPECIAL_COLUMNS: <br>      retcode = SQLSpecialColumns(ci-&gt;hstmt, <br>                                  cati-&gt;fColType, <br>                                  CHKNULL(szQualifierVal), SQL_NTS, <br>                                  CHKNULL(szOwnerVal), SQL_NTS, <br>                                  CHKNULL(szTableVal), SQL_NTS, <br>                                  cati-&gt;fScope, <br>                                  cati-&gt;fNullable); <br>      break; <br> <br>     case IDM_PROCEDURES: <br>      retcode = SQLProcedures(ci-&gt;hstmt, <br>                              CHKNULL(szQualifierVal), SQL_NTS, <br>                              CHKNULL(szOwnerVal), SQL_NTS, <br>                              CHKNULL(szProcsVal), SQL_NTS); <br>      break; <br> <br>     case IDM_PROC_COLUMNS: <br>      retcode = SQLProcedureColumns(ci-&gt;hstmt, <br>                                    CHKNULL(szQualifierVal), SQL_NTS, <br>                                    CHKNULL(szOwnerVal), SQL_NTS, <br>                                    CHKNULL(szProcsVal), SQL_NTS, <br>                                    CHKNULL(szColumnVal), SQL_NTS); <br>      break; <br> <br>     default: <br>      break; <br>   } <br> <br>   if(retcode != SQL_SUCCESS) { <br>      PrintErrors(ci, SQL_HANDLE_STMT); <br>      return; <br>   } <br> <br>   lstrcpy((LPSTR)szTitle, (LPSTR)ci-&gt;szClientTitle); <br>   lstrcat((LPSTR)szTitle, (LPSTR)szCOLON); <br>   lstrcat((LPSTR)szTitle, (LPSTR)cati-&gt;szDlgTitle); <br>   if(ShowCatalogResults(ci, (LPSTR)szTitle)) <br>      return; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| CatalogWndProc: <br>//|   This windows procedure handles all of the catalog function messages. <br>//|   Many things such as setting/getting text values are table driven. <br>//|   This reduces overall code size significantly. <br>//| Parms: <br>//|   in       Standard window parms <br>//| Returns: <br>//|   Depends on message <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN CatalogWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   static CATALOGINFO FAR *   cati; <br>   int                        dex; <br> <br>   switch(msg) { <br>     case WM_INITDIALOG: <br>      cati = (CATALOGINFO FAR *)lParam; <br>      CenterDialog(hDlg); <br> <br>      // Set all default values for edit controls <br>      for(dex=0;  dex&lt;NumItems(CatalogVals);  dex++) <br>         if(cati-&gt;mask &amp; CatalogVals[dex].mMask) { <br>            SetWindowText(GetDlgItem(hDlg, CatalogVals[dex].id), <br>                          CatalogVals[dex].szStr); <br>            SendMessage(GetDlgItem(hDlg, CatalogVals[dex].id), EM_LIMITTEXT, <br>                        CatalogVals[dex].cbMax, 0L); <br>         } <br>      // Special case for dialogs with options <br>      if(cati-&gt;id == IDM_STATISTICS) { <br>         CheckRadioButton(hDlg, IDX_INDEX_UNIQUE, IDX_INDEX_ALL, IDX_INDEX_UNIQUE); <br>         CheckRadioButton(hDlg, IDX_ENSURE, IDX_QUICK, IDX_ENSURE); <br>      } <br>      else if(cati-&gt;id == IDM_SPECIAL_COLUMNS) { <br>         CheckRadioButton(hDlg, IDX_BEST_ROWID, IDX_ROWVER, IDX_BEST_ROWID); <br>         CheckRadioButton(hDlg, IDX_NO_NULLS, IDX_NULLABLE, IDX_NO_NULLS); <br>         CheckRadioButton(hDlg, IDX_SCOPE_CURROW, IDX_SCOPE_SESSION, IDX_SCOPE_CURROW); <br>      } <br> <br>      return TRUE; <br> <br> <br>     case WM_COMMAND: <br>      switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>         { <br>            Busy(TRUE); <br>            for(dex=0;  dex&lt;NumItems(CatalogVals);  dex++) <br>               if(cati-&gt;mask &amp; CatalogVals[dex].mMask) <br>                  GetText(GetDlgItem(hDlg, CatalogVals[dex].id), <br>                          CatalogVals[dex].szStr); <br>            // Special case for dialogs with options <br>            if(cati-&gt;id == IDM_STATISTICS) { <br>               cati-&gt;fUnique = GetRadioValue(hDlg, (IDXINFO FAR *)StatsfUnique, NumItems(StatsfUnique)); <br>               cati-&gt;fAccuracy = GetRadioValue(hDlg, (IDXINFO FAR *)StatsfAccuracy, NumItems(StatsfAccuracy)); <br>            } <br>            else if(cati-&gt;id == IDM_SPECIAL_COLUMNS) { <br>               cati-&gt;fColType = GetRadioValue(hDlg, (IDXINFO FAR *)SpecColsfColType, <br>                                              NumItems(SpecColsfColType)); <br>               cati-&gt;fScope = GetRadioValue(hDlg, (IDXINFO FAR *)SpecColsfScope, <br>                                            NumItems(SpecColsfScope)); <br>               cati-&gt;fNullable = GetRadioValue(hDlg, (IDXINFO FAR *)SpecColsfNullable, <br>                                               NumItems(SpecColsfNullable)); <br>            } <br>            DoCatalogFunction(cati); <br> <br>            Busy(FALSE); <br>            EndDialog(hDlg, IDOK); <br>         } <br>         return TRUE; <br> <br>        case IDCANCEL: <br>         SendMessage(hDlg, WM_CLOSE, 0, 0L); <br>         EndDialog(hDlg, IDCANCEL); <br>         return TRUE; <br>      } <br>      return TRUE; <br> <br>     default: <br>      return FALSE; <br>   } <br>   return FALSE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
