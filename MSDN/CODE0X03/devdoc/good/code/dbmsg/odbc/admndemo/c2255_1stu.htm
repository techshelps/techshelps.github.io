<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXECUTE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2262"></a>EXECUTE.C</h2>
<pre><code>//*--------------------------------------------------------------------------------- <br>//|  ODBC System Administrator <br>//| <br>//|  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>//|  intended for example purposes only. <br>//| <br>//|   Title:   EXECUTE.C <br>//|      This file contains the actual code to execute SQL Statements and <br>//|         display them.  This file is dependent on the SA Tool data structures <br>//|         and the independent module RESULTS. <br>//*--------------------------------------------------------------------------------- <br>#include "admndemo.h" <br>#include "execute.h" <br>#include "strings.h" <br> <br>VSZFile; <br> <br>#define MAXRECORDS 1000 <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Global variables <br>//*--------------------------------------------------------------------------------- <br>lpRESULTSINFO           lpActiveResults=NULL;         // Tracks the active results window <br>extern lpCHILDINFO      lpActiveConn; <br>extern HWND             hwndCurMDIChild; <br>extern HINSTANCE        hInst; <br>extern HWND             hwndFrame; <br> <br>extern char OutStr[MAXBUFF]; <br>extern char szDirName[_MAX_PATH]; <br>extern char szDftFileFilter[MAXBUFF]; <br> <br>dCSEG(char) szNullString[]                =  "&lt;null&gt;"; <br>dCSEG(char) szDash[]                      =  " - "; <br>dCSEG(char) szResults[]                   =  "Results "; <br>dCSEG(char) szErrorVal[]                  =  "#Error"; <br>dCSEG(char) sz1000[]                      =  "1000"; <br>dCSEG(char) szDlgTitle[]                  =  "Execute File"; <br> <br> <br>typedef struct tagEXECUTEFILE { <br>   BOOL        fExecute;                  // TRUE if ok to proceede <br>   HINSTANCE   hInst;                     // Instance handle <br>   LPSTR       szFile;                    // File name to execute <br>   char        szCharacter[4];            // Character to stop on <br>   int         cbMaxLength;               // Maximum buffer size <br>   } EXECUTEFILE; <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Local function prototypes <br>//*--------------------------------------------------------------------------------- <br>BOOL INTFUN FindTerminator(LPSTR str, LPSTR term, LPSTR * nxtstr); <br>BOOL INTFUN NotInQuote(LPSTR str, LPSTR tar); <br>BOOL INTFUN ValidSQLStmt(LPSTR str); <br>BOOL EXTFUN ExecuteFileWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam); <br>void INTFUN InternalDestroyResultsWindow(CHILDINFO FAR * ci, RESULTSSET FAR * rs); <br>void INTFUN DestroyResultsWindow(CHILDINFO FAR * ci, lpRESULTSINFO lpri); <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| ExecuteFile: <br>//|   This function will open a file and execute each SQL statement in it. <br>//| Parms: <br>//|   ci                   CHILDINFO information <br>//|   hwnd                 Owner window for prompting <br>//|   szExeFile            If not NULL, then the name of a file to execute, in <br>//|                           which case the following *are* used <br>//|   szTerm               Terminator for statement <br>//|   cbStmt               Max statement size <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void ExecuteFile(CHILDINFO FAR * ci, HWND hwnd, LPSTR szExeFile, <br>      LPSTR szTerm, int cbStmt) <br>{ <br>   char              szFile[MAXBUFF]; <br>   int               cbRead, cbNextRead; <br>   HFILE             hf; <br>   LPSTR             szBuff; <br>   EXECUTEFILE       ef; <br>   HWND              fHwnd=GetFocus(); <br> <br> <br>   // <br>   // Display dialog to get execute parameters <br>   // <br>   memset(szFile, 0, MAXBUFF); <br>   ef.hInst = ci-&gt;hInst; <br>   ef.szFile = szFile; <br> <br>   // If the caller doesn't supply a file, then ask them for it <br>   if(!szExeFile) { <br>      if(-1 == DialogBoxParam(ci-&gt;hInst, <br>                              MAKEINTRESOURCE(IDD_EXECUTE_FILE), <br>                              hwnd, <br>                              (DLGPROC) ExecuteFileWndProc, (LPARAM)(EXECUTEFILE FAR *)&amp;ef)) <br>         MessageBox(NULL, "Could not open dialog box.", <br>                    "Execute File", MB_ICONEXCLAMATION); <br> <br>      if(fHwnd) <br>         SetFocus(fHwnd); <br> <br>      if(!ef.fExecute) <br>         return; <br>   } <br>   // If they do, then grab the options <br>   else { <br>      lstrcpy(ef.szFile, szExeFile); <br>      lstrcpy(ef.szCharacter, szTerm); <br>      ef.cbMaxLength = cbStmt; <br>   } <br> <br>   // Now execute the file <br>   szBuff = (LPSTR)GetMemory(ef.cbMaxLength); <br>   if(!szBuff) <br>      return; <br> <br>   if((hf = _lopen(ef.szFile, OF_READ)) != HFILE_ERROR) { <br>      LPSTR nxtstr, nxtread; <br>      szWrite(ci-&gt;hwndOut, <br>              GetidsString(idsExecutingFile, OutStr, MAXBUFF), <br>              (LPSTR)ef.szFile); <br>      nxtread = szBuff; <br>      cbNextRead = ef.cbMaxLength; <br>      while((cbRead = _lread(hf, nxtread, cbNextRead)) || <br>            *szBuff) { <br>         if(FindTerminator(szBuff, ef.szCharacter, &amp;nxtstr)) { <br>            if(ValidSQLStmt(szBuff)) <br>               ExecuteCmds(ci, szBuff); <br>         } <br>         else { <br>            szWrite(ci-&gt;hwndOut, GetidsString(idsTerminatorNotFound, OutStr, MAXBUFF)); <br>            goto exit01; <br>         } <br>         cbNextRead = ef.cbMaxLength; <br>         if(nxtstr) { <br>            lstrcpy(szBuff, nxtstr); <br>            cbNextRead -= lstrlen(szBuff); <br>            nxtread = szBuff + lstrlen(szBuff) + 1; <br>         } <br>      } <br>   } <br>   else {      // Couldn't open file <br>      szMessageBox(GetActiveWindow(), <br>                   MB_ICONEXCLAMATION, <br>                   (LPSTR) szOPENFILE, <br>                   GetidsString(idsOpenFileFailed, szBuff, ef.cbMaxLength), <br>                   (LPSTR)ef.szFile); <br>   } <br> <br>  exit01: <br>   _lclose(hf); <br> <br>   ReleaseMemory(szBuff); <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| FindTerminator: <br>//|   Looks for a statement terminator, clears out carriage returns, <br>//|   and finds the next statement. <br>//| Parms: <br>//|   str      Starting location to look <br>//|   term     The terminator string <br>//|   nxtstr   The next string if there is one, NULL otherwise <br>//| Returns: <br>//|   TRUE if a valid statement was found, FALSE on error <br>//*------------------------------------------------------------------------ <br>BOOL INTFUN FindTerminator(LPSTR str, LPSTR term, LPSTR * nxtstr) <br>{ <br>   LPSTR    cstr=str; <br>   int      len; <br>   LPSTR    next=*nxtstr; <br> <br>   next = str; <br>   while(next) { <br>      if(!(next = strstr(cstr, term))) { <br>         *nxtstr = NULL; <br>         return FALSE; <br>      } <br>      if(NotInQuote(cstr, next)) { <br>         len = lstrlen(term); <br>         while(len--) <br>            *next++ = '\0'; <br>         *nxtstr = next; <br>         return TRUE; <br>      } <br>   } <br> <br>   return FALSE; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| NotInQuote: <br>//|   Given a starting position and a target, this function determines <br>//|   if the target is within a quoted string.  If so, then both <br>//|   pointers are advaned one character after the closing quote. <br>//| Parms: <br>//|   str      Starting location to look <br>//|   tar      Target location <br>//| Returns: <br>//|   TRUE if the value is not in a quote, FALSE if it is <br>//*------------------------------------------------------------------------ <br>BOOL INTFUN NotInQuote(LPSTR str, LPSTR tar) <br>{ <br>   static char    apost = '\''; <br>   LPSTR          instr; <br>   LPSTR          tstr=str; <br> <br> <br>   while((instr = strchr(tstr, apost))) { <br>      if(instr &lt; tar) { <br>         instr = strchr(instr+1, apost); <br>         if(instr &gt; tar) { <br>            str = tar = instr + 1; <br>            return FALSE;        // Target in quoted string <br>         } <br>         else <br>            tstr = instr + 1; <br>      } <br>      else <br>         return TRUE;         // Target not between quotes <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| ValidSQLStmt: <br>//|   Takes a buffer and makes sure it is valid.  Essentially it removes <br>//|   all non-embedded carriage returns and looks for a statement which <br>//|   has nothing but blanks. <br>//| Parms: <br>//|   str      The string to parse <br>//| Returns: <br>//|   TRUE if the statement is valid, FALSE otherwise <br>//*------------------------------------------------------------------------ <br>BOOL INTFUN ValidSQLStmt(LPSTR str) <br>{ <br>   LPSTR tmpstr=str; <br> <br>   RemoveCrLf(str); <br>   while(*tmpstr) <br>      if(*tmpstr++ != ' ') <br>         return TRUE; <br>   return FALSE; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| ExecuteFileWndProc: <br>//|   This window procedure is for executing a file. <br>//| Parms: <br>//|   in       Standard window parms <br>//| Returns: <br>//|   Depends on message <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN ExecuteFileWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   static EXECUTEFILE FAR *      ef; <br> <br>   switch(msg) { <br>     case WM_INITDIALOG: <br>      { <br>         ef = (EXECUTEFILE FAR *)lParam; <br>         ef-&gt;fExecute = FALSE;                           // Assume we close <br>         CenterDialog(hDlg); <br>         if(!*szDirName) <br>            GetWindowsDirectory(szDirName, MAXBUFF); <br>         SendMessage(GetDlgItem(hDlg, IDE_CHARACTER), EM_LIMITTEXT, 3, 0L); <br>         SendMessage(GetDlgItem(hDlg, IDE_MAXLENGTH), EM_LIMITTEXT, 4, 0L); <br>         CheckRadioButton(hDlg, IDR_CARRIAGE, <br>                          IDR_CHARACTER, IDR_CARRIAGE); <br>         EnableWindow(GetDlgItem(hDlg, IDE_CHARACTER), FALSE); <br>         SetWindowText(GetDlgItem(hDlg, IDT_FILE), szDirName); <br>         SetWindowText(GetDlgItem(hDlg, IDE_MAXLENGTH), (LPSTR)sz1000); <br>      } <br>      return TRUE; <br> <br> <br>     case WM_COMMAND: <br>      switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>         // Handle radio buttons <br>        case IDR_CARRIAGE: <br>         EnableWindow(GetDlgItem(hDlg, IDE_CHARACTER), FALSE); <br>         return TRUE; <br> <br>        case IDR_CHARACTER: <br>         EnableWindow(GetDlgItem(hDlg, IDE_CHARACTER), TRUE); <br>         SetFocus(GetDlgItem(hDlg, IDE_CHARACTER)); <br>         return TRUE; <br> <br>         // Get file to execute, use last directory name <br>        case IDB_FILE: <br>         { <br>            OPENFILENAME   lpofn; <br>            char           szFileTitle[MAXBUFF]; <br> <br>            _fmemset(&amp;lpofn, 0, sizeof(OPENFILENAME)); <br>            lpofn.hInstance = ef-&gt;hInst; <br>            lpofn.lStructSize = sizeof(OPENFILENAME); <br>            lpofn.hwndOwner = hDlg; <br>            lpofn.lpstrFilter = (LPSTR)szDftFileFilter; <br>            lpofn.nFilterIndex = 1; <br>            lpofn.lpstrFile = ef-&gt;szFile; <br>            lpofn.nMaxFile = MAXBUFF; <br>            lpofn.lpstrFileTitle = szFileTitle; <br>            lpofn.nMaxFileTitle = sizeof(szFileTitle); <br>            lpofn.lpstrInitialDir = szDirName; <br>            lpofn.Flags = OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST; <br>            if(GetOpenFileName(&amp;lpofn)) { <br>               lstrcpy(ef-&gt;szFile, lpofn.lpstrFile); <br>               SetWindowText(GetDlgItem(hDlg, IDT_FILE), ef-&gt;szFile); <br>               GetNewDirectory(szDirName, lpofn.lpstrFile); <br>            } <br>         } <br>         return TRUE; <br> <br>         // User has clicked OK <br>        case IDOK: <br>         { <br>            char  szNum[5]; <br>            GetText(GetDlgItem(hDlg, IDE_MAXLENGTH), szNum); <br>            ef-&gt;cbMaxLength = atoi(szNum); <br>            if(ef-&gt;cbMaxLength &lt; MINSTMTSIZE) { <br>               MessageBox(hDlg, GetidsString(idsNumTooSmall, OutStr, MAXBUFF), <br>                          szDlgTitle, MB_OK); <br>               SetFocus(GetDlgItem(hDlg, IDE_MAXLENGTH)); <br>               return TRUE; <br>            } <br>            GetText(GetDlgItem(hDlg, IDT_FILE), ef-&gt;szFile); <br>            if(IsRadioButtonOn(GetDlgItem(hDlg, IDR_CARRIAGE))) <br>               lstrcpy((LPSTR)ef-&gt;szCharacter, (LPSTR)"\r\n"); <br>            else <br>               GetText(GetDlgItem(hDlg, IDE_CHARACTER), (LPSTR)ef-&gt;szCharacter); <br>            if(*ef-&gt;szCharacter == ' ' || <br>               !*ef-&gt;szCharacter) { <br>               MessageBox(GetActiveWindow(), <br>                          GetidsString(idsInvalidTerminator, OutStr, MAXBUFF), <br>                          szErrTitle, MB_OK); <br>               SetFocus(GetDlgItem(hDlg, IDE_CHARACTER)); <br>               return TRUE; <br>            } <br>            ef-&gt;fExecute = TRUE; <br>            EndDialog(hDlg, IDOK); <br>         } <br>         return TRUE; <br> <br>        case IDCANCEL: <br>         ef-&gt;fExecute = FALSE; <br>         EndDialog(hDlg, IDCANCEL); <br>         return TRUE; <br>      } <br>      return TRUE; <br> <br>     default: <br>      return FALSE; <br>   } <br>   return FALSE; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoCommitRollback: <br>//|   This function will use SQLTransact to do either a commit or a rollback <br>//|   on the current HDBC. <br>//| Parms: <br>//|   in       ci                   CHILDINFO information <br>//|   in       type                 Which action identified by menu item <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void DoCommitRollback(CHILDINFO FAR * ci, int type) <br>{ <br>   RETCODE retcode; <br> <br>   //------------------------------------------------------------------------------- <br>   // This tool has only one HSTMT per HDBC, and therefore we need only specify <br>   // the HDBC we want to COMMIT.  Note that some drivers may allow the user to <br>   // Execute a COMMIT or ROLLBACK and thereby would not even require a call to <br>   // this function. <br>   //------------------------------------------------------------------------------- <br>   switch(type) { <br>     case IDM_COMMIT: <br>      retcode = SQLEndTran(SQL_HANDLE_DBC, ci-&gt;hdbc, SQL_COMMIT); <br>      break; <br> <br>     case IDM_ROLLBACK: <br>      retcode = SQLEndTran(SQL_HANDLE_DBC, ci-&gt;hdbc, SQL_ROLLBACK); <br>      break; <br>   } <br> <br>   if(retcode != SQL_SUCCESS) <br>      PrintErrors(ci, SQL_HANDLE_DBC); <br>   else <br>      szWrite(ci-&gt;hwndOut, GetidsString(idsStmtProcessed, OutStr, MAXBUFF)); <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| ExecuteCmds: <br>//|   This function will take a command from the given input window and execute <br>//|      it.  The order of execution is to use the selcted text, and if none <br>//|      is selected, to use the entire text from the input window. <br>//| Parms: <br>//|   ci             CHILDINFO information <br>//|   stmt           A null-terminated statement to execute, NULL <br>//|                                    if the value should be taken from input window. <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void ExecuteCmds(CHILDINFO FAR * ci, LPSTR stmt) <br>{ <br>   RETCODE              retcode; <br>   LPSTR                sqlstmt, tmpstr; <br>   DWORD                size; <br>   DWORD                len; <br> <br> <br>   // The user may pass in their own SQL statement to be executed.  In <br>   // this case simply do so. <br>   Busy(TRUE); <br>   if(stmt) <br>      sqlstmt = stmt; <br>   // If stmt is NULL, however, we must get the statement from the input <br>   // window of the current connection window. <br>   else { <br>      len = SendMessage(ci-&gt;hwndIn, WM_GETTEXTLENGTH, 0, 0L); <br>      sqlstmt = (LPSTR)GetMemory(len+1); <br>      if(!sqlstmt) { <br>         Busy(FALSE); <br>         return; <br>      } <br>      SendMessage(ci-&gt;hwndIn, WM_GETTEXT, (WPARAM)len + 1, (LPARAM)sqlstmt); <br>      size = SendMessage(ci-&gt;hwndIn, EM_GETSEL, 0, 0L); <br>      if(HIWORD(size) - LOWORD(size) &gt; 0) {        // A selection has been made <br>         len = HIWORD(size) - LOWORD(size); <br>         memmove(sqlstmt, &amp;sqlstmt[LOWORD(size)], <br>                 HIWORD(size) - LOWORD(size)); <br>         tmpstr = sqlstmt + len; <br>         *tmpstr = '\0'; <br>      } <br>      RemoveCrLf(sqlstmt); <br>   } <br> <br>   // Execute the statement <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br>   retcode = SQLExecDirect(ci-&gt;hstmt, sqlstmt, SQL_NTS); <br>   if(retcode != SQL_SUCCESS) { <br>      PrintErrors(ci, SQL_HANDLE_STMT); <br>      Busy(FALSE); <br>      goto exit00; <br>   } <br> <br>   // Check for results <br>   CheckForResults(ci); <br> <br>  exit00: <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br>   if(!stmt) <br>      ReleaseMemory(sqlstmt); <br>   Busy(FALSE); <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| CheckForResults: <br>//|   Call this function after successful execution of an SQL statement.  This <br>//|   function will attempt to fetch the results from the statement, if they <br>//|   exist.  It is not an error if they do not. <br>//| Parms: <br>//|   ci             CHILDINFO information <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void CheckForResults(CHILDINFO FAR * ci) <br>{ <br>   RESULTSSET FAR *     rs; <br>   SWORD                cbCols; <br>   SDWORD               cbRowCount; <br>   char                 szStr[MAXBUFF]; <br>   char                 tmpbuff[30]; <br>   RETCODE              retcode; <br> <br>   // <br>   // At this point we have executed the statement successfully.  If there is <br>   // a results set, fetch it to a results window.  Otherwise simply tell the <br>   // user how many rows were affected, if possible. <br>   // <br>   retcode = SQLFetch(ci-&gt;hstmt); <br>   if(retcode == SQL_ERROR) { <br>      cbRowCount = PrintAffectedRows(ci-&gt;hstmt, ci-&gt;hwndOut); <br>      SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br>      return; <br>   } <br>   else if (retcode == SQL_NO_DATA) { <br>      szWrite(ci-&gt;hwndOut, GetidsString(idsNoDataFound, szStr, sizeof(szStr))); <br>      return; <br>   } <br> <br>   // <br>   // If we made it this far, then we have a results set to work with.  The <br>   //    following loop will go through each results set (if there are more <br>   //    than one) and place their contents in a results window. <br>   // <br>   while(RC_SUCCESSFUL(retcode)) { <br>      lstrcpy((LPSTR)szStr, (LPSTR)ci-&gt;szClientTitle); <br>      lstrcat((LPSTR)szStr, (LPSTR)szDash); <br>      lstrcat((LPSTR)szStr, (LPSTR)szResults); <br>      wsprintf(tmpbuff, "%u", ++ci-&gt;cbResultCount); <br>      lstrcat((LPSTR)szStr, (LPSTR)tmpbuff); <br> <br>      if(!(cbCols = GetNumResultsCols(ci-&gt;hstmt))) <br>         return; <br> <br>      rs = GetConnectWindowResultsNode(ci); <br>      if(!CreateResultsSet(rs, ci-&gt;hwndClient, ci-&gt;hInst, cbCols, (LPSTR)szStr)) <br>         return; <br> <br>      // <br>      // Set the meta data <br>      // <br>      SetMetaDataFromSql(ci-&gt;hwndOut, ci-&gt;hstmt, rs, cbCols); <br> <br>      // <br>      // Now create the MDI child window which will hold the results. <br>      // <br>      if(!CreateResultsWindow(ci, rs)) <br>         return; <br> <br> <br>      // <br>      // Loop through each data source and add it to the results set. <br>      // <br>      cbRowCount = FetchAllRecordsToResults(ci-&gt;hwndOut, ci-&gt;hstmt, rs, cbCols, FALSE); <br>      szWrite(ci-&gt;hwndOut, <br>              GetidsString(idsAffectedRows, szStr, sizeof(szStr)), <br>              cbRowCount); <br> <br>      // <br>      // Now see if there are any more results to fetch. <br>      // <br>      retcode = SQLMoreResults(ci-&gt;hstmt); <br>      if(RC_SUCCESSFUL(retcode)) <br>         retcode = SQLFetch(ci-&gt;hstmt); <br>   }     // End of loop through results sets <br> <br>   SQLFreeStmt(ci-&gt;hstmt, SQL_CLOSE); <br> <br>   return; <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| FreeConnectWindowResults: <br>//|   This function will free all present results sets (if there are any) and then <br>//|      free up the memory they occupied. <br>//| Parms: <br>//|   in       ci                   Pointer to connection window <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void FreeConnectWindowResults(lpCHILDINFO lpci) <br>{ <br>   while(lpci-&gt;lprihead) <br>      DestroyResultsWindow(lpci, <br>                           (lpRESULTSINFO)lpci-&gt;lprihead); <br> <br>   return; <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| GetConnectWindowResultsNode: <br>//|   This function will return a results set pointer which describes only <br>//|   the graphical portion of a results set. <br>//| Parms: <br>//|   lpci                    Pointer to connection window <br>//| Returns: <br>//|   Pointer to Results set <br>//*--------------------------------------------------------------------------------- <br>lpRESULTSSET GetConnectWindowResultsNode(lpCHILDINFO lpci) <br>{ <br>   lpRESULTSSET lprs; <br> <br>   lprs = (lpRESULTSSET)GetMemory(sizeof(RESULTSSET)); <br>   return lprs; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| AddResultsInfoNode: <br>//|   Associate a child MDI window structure with a results set. <br>//| Parms: <br>//|   lpci                    Pointer to connection window <br>//|   lprs                    The results set to put into a window <br>//| Returns: <br>//|   Pointer to Results set <br>//*--------------------------------------------------------------------------------- <br>lpRESULTSINFO AddResultsInfoNode(lpCHILDINFO lpci, lpRESULTSSET lprs) <br>{ <br>   lpRESULTSINFO     lpri; <br>   lpRESULTSINFO     head=(lpRESULTSINFO)lpci-&gt;lprihead; <br>   lpRESULTSINFO     tail=(lpRESULTSINFO)lpci-&gt;lpritail; <br> <br>   lpri = (lpRESULTSINFO)GetMemory(sizeof(RESULTSINFO)); <br>   if(!lpri) <br>      return NULL; <br> <br>   if(!head) { <br>      lpci-&gt;lprihead = lpri; <br>      lpri-&gt;next = <br>         lpri-&gt;prev = NULL; <br>   } <br>   else { <br>      tail-&gt;next = lpri; <br>      lpri-&gt;prev = tail; <br>      lpri-&gt;next = NULL; <br>   } <br>   lpci-&gt;lpritail = lpri; <br>   ++lpci-&gt;cbResults; <br> <br>   return lpri; <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| CreateResultsWindow: <br>//|   This function will create an MDI client window of type Results which can <br>//|      be used to display a results set.  Call this function with a CHILDINFO <br>//|      structure which is the owner.  A spot will be found in the array of <br>//|      results a child can hold.  FIFO is used if there are no empty array <br>//|      locations. <br>//| Parms: <br>//|   cs                   Pointer to connection window <br>//|   rs                   Pointer to the results set to use for creation <br>//| Returns: <br>//|   TRUE on success, FALSE on failure <br>//*--------------------------------------------------------------------------------- <br>BOOL INTFUN CreateResultsWindow(CHILDINFO FAR * ci, lpRESULTSSET rs) <br>{ <br>   MDICREATESTRUCT            mdicreate; <br>   lpRESULTSINFO              lpri; <br> <br> <br>   // <br>   // Allocate memory for the RESULTSINFO which holds all the control <br>   //    structures needed for creating a window. <br>   // <br>   lpri = AddResultsInfoNode(ci, rs); <br>   if(!lpri) <br>      return FALSE; <br>   lpri-&gt;ci = ci; <br>   lpri-&gt;rs = rs; <br> <br> <br>   // <br>   //  User must have a valid pointer to a results set which was create via <br>   //    CreateResultsSet.  This function will simply create a results set window <br>   //    for the user based on this value. <br>   // <br>   mdicreate.szClass = szResultsClass; <br>   mdicreate.szTitle = (LPSTR)rs-&gt;szTitle; <br>   mdicreate.hOwner  = rs-&gt;hInst; <br>   mdicreate.x       = CW_USEDEFAULT; <br>   mdicreate.y       = CW_USEDEFAULT; <br>   mdicreate.cx      = CW_USEDEFAULT; <br>   mdicreate.cy      = CW_USEDEFAULT; <br>   mdicreate.style   = (hwndCurMDIChild) ? ((IsZoomed(hwndCurMDIChild)) ? WS_MAXIMIZE : 0) : 0; <br>   mdicreate.lParam  = (LPARAM)lpri; <br>   if(SendMessage(rs-&gt;hwndClient, WM_MDICREATE, 0, <br>                  (LONG)(LPMDICREATESTRUCT)&amp;mdicreate)) <br>      return TRUE; <br>   else <br>      return FALSE; <br>} <br> <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DestroyResultsWindow: <br>//|   This function will free all memory for a specified results set.  It must <br>//|      remove the results set from the array of results sets and collapse the <br>//|      array to maintain FIFO order. <br>//| Parms: <br>//|   lpci                 Pointer to Child info <br>//|   lpri                 The results to drop <br>//| Returns: <br>//|   Nothing. <br>//*--------------------------------------------------------------------------------- <br>void INTFUN DestroyResultsWindow(lpCHILDINFO lpci, lpRESULTSINFO lpri) <br>{ <br>   // <br>   // First destroy the contents of the results set, then the memory for <br>   //    the results set itself. <br>   // <br>   SendMessage(lpri-&gt;rs-&gt;hwndList, LB_RESETCONTENT, 0, 0L); <br>   SendMessage(lpci-&gt;hwndClient, WM_MDIDESTROY, <br>               (WPARAM)(HWND)lpri-&gt;rs-&gt;hwndResults, 0L); <br>   FreeResultsSet(lpri-&gt;rs); <br> <br>   if(lpci-&gt;lprihead == lpri) <br>      lpci-&gt;lprihead = lpri-&gt;next; <br>   if(lpci-&gt;lpritail == lpri) <br>      lpci-&gt;lpritail = lpri-&gt;prev; <br>   if(lpri-&gt;next) <br>      lpri-&gt;next-&gt;prev = lpri-&gt;prev; <br>   if(lpri-&gt;prev) <br>      lpri-&gt;prev-&gt;next = lpri-&gt;next; <br> <br>   --lpci-&gt;cbResults; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| ResultsWndProc: <br>//|   This function will handle all messages which are received by a results <br>//|      window. <br>//| Parms: <br>//|   in       hwnd                 Window to work with <br>//|   in       msg                  Message we need to handle <br>//|   in       wParam               First param <br>//|   in       lParam               Second param <br>//| Returns: <br>//|   Depends on message. <br>//*--------------------------------------------------------------------------------- <br>long EXTFUN ResultsWndProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch(msg) { <br>      // <br>      // WM_CREATE is received when the new window is created.  We need to create <br>      //    the listbox for the results set when this message is received. <br>      // <br>     case WM_CREATE: <br>      // <br>      // First get information on the font being used for the display.  Declare <br>      //    all variables which are only needed once on stack for this message only. <br>      // <br>      { <br>         CREATESTRUCT FAR *      cs; <br>         MDICREATESTRUCT FAR *   mdi; <br>         lpRESULTSINFO           rwi; <br>         lpRESULTSSET            rs; <br> <br> <br>         cs = (CREATESTRUCT FAR *)lParam; <br>         mdi = (MDICREATESTRUCT FAR *)cs-&gt;lpCreateParams; <br>         lpActiveResults = rwi = (lpRESULTSINFO)mdi-&gt;lParam; <br>         rs = rwi-&gt;rs; <br> <br>         SETRWPOINTER(hwnd, lpActiveResults); <br>         CreateResultsFont(rs, hwnd, NULL); <br> <br>         // <br>         // Now get the window handle values and then create the components of the <br>         //    results window.  These include the title which has the column names, <br>         //    and the actual owner drawn list box which has the results set in it. <br>         // <br>         rs-&gt;hwndResults = hwnd; <br>         rs-&gt;hwndClient = GetParent(hwnd); <br>         if(!(rs-&gt;hwndList = CreateWindow("listbox", NULL, <br>                                          WS_CHILD | WS_VISIBLE | WS_VSCROLL | <br>                                          LBS_MULTIPLESEL | LBS_OWNERDRAWFIXED | <br>                                          LBS_NOTIFY | LBS_EXTENDEDSEL | LBS_NOINTEGRALHEIGHT, <br>                                          0, 0, 0, 0, <br>                                          hwnd, (HMENU)(2), hInst, NULL))) <br>            return -1; <br>         if(!(rs-&gt;hwndHScroll = CreateWindow("scrollbar", NULL, <br>                                             WS_CHILD | WS_VISIBLE, <br>                                             0, 0, 0, 0, <br>                                             hwnd, (HMENU)(3), hInst, NULL))) <br>            return -1; <br> <br>         // <br>         // Get scroll bar stats and set scroll range <br>         // <br>         SetScrollRange(rs-&gt;hwndHScroll, SB_CTL, 0, rs-&gt;cbColumns - 1, TRUE); <br>      } <br>      return 0; <br> <br> <br>      // <br>      // When WM_SIZE is received, we need to move the child windows including the <br>      //    title information and the listbox to fit the new area.  If all of the <br>      //    columns will fit in one display, hide our horizontal scroll bar. <br>      // NOTE:  We must break to return DefMDIWndProc in order for the menu to <br>      //    be redrawn when we maximize the child window. <br>      // <br>     case WM_SIZE: <br>      { <br>         lpRESULTSINFO        rwi = GETRWPOINTER(hwnd); <br>         lpRESULTSSET         rs=rwi-&gt;rs; <br>         int                  cScroll, dex; <br> <br>         rwi-&gt;dx = LOWORD(lParam); <br>         rwi-&gt;dy = HIWORD(lParam); <br>         rwi-&gt;xRightCol = FindRightCol(rs, rwi-&gt;xLeftCol, rwi-&gt;dx); <br>         for(cScroll=0, dex=rwi-&gt;xLeftCol;  dex&lt;=rwi-&gt;xRightCol;  dex++) <br>            cScroll += rs-&gt;md[dex].cColWidth; <br>         rwi-&gt;fScrollPresent = FALSE; <br>         if(cScroll &gt; rwi-&gt;dx) { <br>            rwi-&gt;fScrollPresent = TRUE; <br>            MoveWindow(rs-&gt;hwndHScroll, 0, rwi-&gt;dy - GetSystemMetrics(SM_CYHSCROLL), <br>                       rwi-&gt;dx - GetSystemMetrics(SM_CXVSCROLL), GetSystemMetrics(SM_CYHSCROLL), TRUE); <br>         } <br>         MoveWindow(rs-&gt;hwndList, 0, rs-&gt;cTitleHeight, rwi-&gt;dx, <br>                    (rwi-&gt;fScrollPresent) ? rwi-&gt;dy - rs-&gt;cTitleHeight - GetSystemMetrics(SM_CYHSCROLL) : rwi-&gt;dy - rs-&gt;cTitleHeight, TRUE); <br>         ShowWindow(rs-&gt;hwndHScroll, (rwi-&gt;fScrollPresent) ? SW_SHOW : SW_HIDE); <br>         rwi-&gt;tRect.left = rwi-&gt;tRect.top = 0; <br>         rwi-&gt;tRect.bottom = rs-&gt;cTitleHeight; <br>         rwi-&gt;tRect.right = min(rwi-&gt;dx, cScroll); <br>      } <br>      break; <br> <br> <br>      // <br>      // Hande the WM_INITMENUPOPUP message so that when the user selects <br>      //    a menu, we enable/disable each item based on our current state. <br>      // <br>     case WM_INITMENUPOPUP: <br>      if(!(BOOL)HIWORD(lParam))        // Not the system menu <br>         ResetMenu((HMENU)wParam, (int)LOWORD(lParam)); <br>      break; <br> <br> <br>      // <br>      // A WM_HSCROLL message is received when the user does something with our </code></pre>
<p>
</p>
<pre><code>//    scroll bar.  We must handle horizontal scroll since a listbox does <br>      //    does inherintly support it. <br>      // <br>     case WM_HSCROLL: <br>      { <br>         lpRESULTSINFO  rwi = GETRWPOINTER(hwnd); <br>         lpRESULTSSET         rs=rwi-&gt;rs; <br> <br>         HandleHScroll(wParam, rs, hwnd, rs-&gt;hwndHScroll, &amp;rwi-&gt;xLeftCol, &amp;rwi-&gt;xRightCol, <br>                       rs-&gt;hwndList, rs-&gt;cbColumns, rwi-&gt;dx, &amp;rwi-&gt;tRect); <br>      } <br>      return 0; <br> <br> <br>      // In order to enable the keyboard to run the scroll bars (for those users <br>      //    without a mouse), we must look for the cursor keys etc... and cause <br>      //    them to do scrolling. <br>     case WM_KEYDOWN: <br>      { <br>         lpRESULTSINFO  rwi = GETRWPOINTER(hwnd); <br>         lpRESULTSSET         rs=rwi-&gt;rs; <br> <br>         HandleVirtualHScroll(wParam, rs-&gt;hwndList, rs-&gt;hwndResults); <br>      } <br>      break;                              // Let it pass through to the app <br> <br> <br>      // <br>      // WM_MEASUREITEM is received when the listbox is first being drawn.  We tell <br>      //    Windows what each row is going to look like. <br>      // <br>     case WM_MEASUREITEM: <br>      { <br>         MEASUREITEMSTRUCT FAR * ms; <br>         lpRESULTSINFO  rwi = GETRWPOINTER(hwnd); <br>         lpRESULTSSET         rs=rwi-&gt;rs; <br> <br>         if((int)wParam != 2)                   // Not our list box <br>            return FALSE; <br>         ms = (MEASUREITEMSTRUCT FAR *)lParam; <br>         ms-&gt;itemHeight = rs-&gt;cTitleHeight; <br>      } <br>      return TRUE; <br> <br> <br>      // <br>      // WM_DRAWITEM is received whenever we must draw a record in the results set <br>      //    list box.  We will recieve a pointer to the ROWDATA structure. <br>      // <br>     case WM_DRAWITEM: <br>      { <br>         DRAWITEMSTRUCT FAR * dwitem; <br>         lpRESULTSINFO  rwi = GETRWPOINTER(hwnd); <br>         lpRESULTSSET         rs=rwi-&gt;rs; <br> <br>         dwitem = (DRAWITEMSTRUCT FAR *)lParam; <br>         DrawRowData(rs, dwitem, rwi-&gt;xLeftCol, rwi-&gt;xRightCol); <br>      } <br>      return TRUE; <br> <br> <br>      // <br>      // The WM_DELETEITEM message is received whenever a row is to be <br>      //    deleted from the listbox.  We will take the opportunity to <br>      //    free the storage for the row. <br>      // <br>     case WM_DELETEITEM: <br>      { <br>         DELETEITEMSTRUCT FAR *  dlt; <br>         lpRESULTSINFO  rwi = GETRWPOINTER(hwnd); <br>         lpRESULTSSET         rs=rwi-&gt;rs; <br>         ROWDATA FAR *        rd; <br> <br>         dlt = (DELETEITEMSTRUCT FAR *)lParam; <br>         rd = (ROWDATA FAR *)dlt-&gt;itemData; <br>         FreeRowData(rs, rd); <br>      } <br>      return 0; <br> <br> <br>      // <br>      // WM_PAINT means it's time for us to paint our columns titles which are <br>      //    simply drawn in the client area for speed. <br>      // <br>     case WM_PAINT: <br>      { <br>         HDC            hdc; <br>         PAINTSTRUCT    ps; <br>         lpRESULTSINFO  rwi = GETRWPOINTER(hwnd); <br>         lpRESULTSSET   rs=rwi-&gt;rs; <br> <br>         hdc = BeginPaint(hwnd, &amp;ps); <br>         if(hdc) { <br>            DrawColumnTitles(hdc, rs, &amp;rwi-&gt;tRect, rwi-&gt;xLeftCol, rwi-&gt;xRightCol); <br>            if(rwi-&gt;fScrollPresent) { <br>               RECT           rct; <br>               rct.left = rwi-&gt;dx - GetSystemMetrics(SM_CXVSCROLL); <br>               rct.top = rwi-&gt;dy - GetSystemMetrics(SM_CYHSCROLL); <br>               rct.right = rwi-&gt;dx; <br>               rct.bottom = rwi-&gt;dy; <br>               MoveTo(hdc, rct.left, rct.top); <br>               LineTo(hdc, rct.right, rct.top); <br>               ++rct.top; <br>               FillRect(hdc, &amp;rct, GetStockObject(LTGRAY_BRUSH)); <br>            } <br>            EndPaint(hwnd, &amp;ps); <br>         } <br>      } <br>      break; <br> <br>      // <br>      // All messages are handled in the main wnd proc, so pass them back <br>      // <br>     case WM_COMMAND: <br>      { <br>         UINT        id=GET_WM_COMMAND_ID(wParam, lParam); <br> <br>         if(id &gt;= IDM_CONNECT &amp;&amp; <br>            id &lt;= IDM_MOVE_WINDOW) <br>            SendMessage(hwndFrame, WM_COMMAND, wParam, lParam); <br>      } <br>      break; <br> <br> <br>      // <br>      // The WM_MDIACTIVATE message is received first by the child window <br>      //    which is losing focus, then by the window which is receiving <br>      //    focus. If we're changing windows, get the RESULTSSET. <br>      // <br>     case WM_MDIACTIVATE: <br>      { <br>#ifndef WIN32 <br>         if(wParam) { <br>            lpActiveResults = GETRWPOINTER((HWND)LOWORD(lParam)); <br>         } <br>#else <br>         if((HWND)lParam == hwnd) { <br>            lpActiveResults = GETRWPOINTER((HWND)lParam); <br>         } <br>#endif <br>         else <br>            lpActiveResults = NULL; <br> <br>         if(lpActiveResults) { <br>            RECT     rect; <br> <br>            hwndCurMDIChild = lpActiveResults-&gt;rs-&gt;hwndResults; <br>            lpActiveConn = lpActiveResults-&gt;ci; <br>            GetClientRect(hwndCurMDIChild, &amp;rect); <br>            InvalidateRect(hwndCurMDIChild, &amp;rect, TRUE); <br>         } <br>      } <br>      return 0; <br> <br> <br>      // <br>      // If the user selects close from the system menu for the window, we need <br>      //    to be able to backtrack and delete our results set.  Since our <br>      //    list of results set is not kept by us, we will pass in our rs <br>      //    pointer and let InternalDestroyResultsWindow find the correct <br>      //    node to destroy. <br>      // <br>     case WM_SYSCOMMAND: <br>      { <br>         lpRESULTSINFO  rwi = lpActiveResults; <br> <br>         if(wParam == SC_CLOSE) <br>            DestroyResultsWindow(lpActiveConn, rwi); <br>      } <br>      break; <br> <br>     default: <br>      break; <br>   } <br> <br>   // <br>   // If we haven't already processed the message, do default behavior. <br>   // <br>   return DefMDIChildProc(hwnd, msg, wParam, lParam); <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| SetMetaDataFromSql: <br>//|   This function will walk through the columns of a results set and <br>//|      set the meta data accordingly.  If the caller so chooses, they <br>//|      may update the default values after calling this function. <br>//| Parms: <br>//|   in       hwndOut              Where to write output <br>//|   in       hstmt                Statement handle with results set <br>//|   in       rs                   Pointer to results set <br>//|   in       cbCols               Number of results cols <br>//| Returns: <br>//|   TRUE if successful, FALSE otherwise <br>//*------------------------------------------------------------------------ <br>BOOL SetMetaDataFromSql(HWND hwndOut, HSTMT hstmt, RESULTSSET FAR * rs, int cbCols) <br>{ <br>   int         dex; <br>   char        szColumnName[MAXBUFF]; <br>   SWORD       fSqlType; <br>   UDWORD      precision; <br>   SWORD       scale; <br>   SWORD       fNullable; <br>   RETCODE     retcode; <br> <br>   for(dex=0;  dex&lt;cbCols;  dex++) { <br>      retcode = SQLDescribeCol(hstmt, <br>                               (UWORD)(dex+1), (LPSTR)szColumnName, <br>                               sizeof(szColumnName), <br>                               NULL, <br>                               &amp;fSqlType, &amp;precision, &amp;scale, &amp;fNullable); <br>      if(!*szColumnName)         // Some drivers don't return names for computed columns <br>         wsprintf(szColumnName, GetidsString(idsExpression, OutStr, MAXBUFF), dex); <br>      if(retcode != SQL_SUCCESS) <br>         PrintErrorsHwnd(hwndOut, SQL_HANDLE_STMT, hstmt); <br>      else <br>         SetMetaDataColumn(rs, dex, (LPSTR)szColumnName, <br>                           GetTypeName(SQL_TYPE, fSqlType), fSqlType, <br>                           (UDWORD)precision, (SWORD)scale, <br>                           (int)(min(MAXBYTES, precision)), TA_LEFT); <br>   } <br>   return TRUE; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| FetchAllRecordsToResults: <br>//|   This function will fetch each row, convert it to char, then add it <br>//|      to the results set we're querying. <br>//| Parms: <br>//|   in       hwnd                 Where to write output <br>//|   in       hstmt                Statement handle with results set <br>//|   in       rs                   Pointer to results set <br>//|   in       cbCols               Number of columns <br>//|   in       fFetch               TRUE if need to fetch first record <br>//| Returns: <br>//|   Number of records which were fetched. <br>//*------------------------------------------------------------------------ <br>SDWORD FetchAllRecordsToResults(HWND hwndOut, HSTMT hstmt, <br>            RESULTSSET FAR * rs, int cbCols, BOOL fFetch) <br>{ <br>#define MAXRSLTSIZE 65535 <br>   int                  dex; <br>   ROWDATA FAR *        rd; <br>   LPSTR                inbuff, outbuff; <br>   SDWORD               cNull; <br>   RETCODE              retcode; <br>   SDWORD               cnt=0; <br>   COLORREF             rgbDft=GetDefaultRGB(); <br> <br>   // <br>   // First get some memory to work with <br>   // <br>   inbuff = (LPSTR)GetMemory(MAXRSLTSIZE); <br>   outbuff = (LPSTR)GetMemory(MAXRSLTSIZE); <br>   if(!inbuff || <br>      !outbuff) <br>      return FALSE; <br> <br>   // <br>   // Now fetch each row, do a getdata on each column, convert it to char, then <br>   //    add it to the results set.  The caller has the option of fetching the <br>   //    first row.  This is required, as the caller may have needed to find <br>   //    out if there was a results set. <br>   // <br>   if(fFetch) <br>      retcode = SQLFetch(hstmt); <br>   else <br>      retcode = SQL_SUCCESS; <br>   while(retcode != SQL_NO_DATA) { <br>      // Increment count and enforce max records <br>      if(cnt &gt; MAXRECORDS) { <br>         szMessageBox(hwndOut, <br>                      MB_ICONEXCLAMATION + MB_OK, <br>                      "Limit", <br>                      GetidsString(idsMaxRecords, OutStr, MAXBUFF), <br>                      MAXRECORDS); <br>         SQLFreeStmt(hstmt, SQL_CLOSE); <br>         goto exit00; <br>      } <br>      ++cnt; <br> <br>      if(retcode != SQL_SUCCESS) <br>         PrintErrorsHwnd(hwndOut, SQL_HANDLE_STMT, hstmt); <br>      else { <br>         // <br>         // Loop through each column and retrieve it's value <br>         // <br>         rd = AllocateRowData(rs, rgbDft, RDATA_DEFAULT_BKGRND); <br>         for(dex=0;  dex&lt;cbCols;  dex++) { <br>            retcode = SQLGetData(hstmt, (UWORD)(dex+1), <br>                                 SQL_C_DEFAULT, <br>                                 (PTR)inbuff, <br>                                 rs-&gt;md[dex].precision + 1, <br>                                 &amp;cNull); <br>            if(retcode != SQL_SUCCESS) { <br>               PrintErrorsHwnd(hwndOut, SQL_HANDLE_STMT, hstmt); <br>               SetColumnData(dex, rd, (LPSTR)szErrorVal); <br>            } <br>            else { <br>               if(cNull != SQL_NULL_DATA) <br>                  ConvertSqlTypeToChar(rs, dex, inbuff, outbuff, cNull); <br>               SetColumnData(dex, rd, <br>                             (cNull == SQL_NULL_DATA) ? (LPSTR)szNullString : outbuff); <br>            } <br>         }     // End of loop through columns <br>         if(AddRowData(rs, rd) == LB_ERRSPACE) <br>            goto exit00; <br>      } <br> <br>      retcode = SQLFetch(hstmt); <br>   }           // End of fetch loop <br> <br>  exit00: <br>   ReleaseMemory(inbuff); <br>   ReleaseMemory(outbuff); <br> <br>   return cnt; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| PrintAffectedRows: <br>//|   This function will print out the "Affected rows" message based on <br>//|   row count. <br>//| Parms: <br>//|   in       hstmt                Statement handle to use <br>//|   in       hwnd                 Where to write output <br>//| Returns: <br>//|   Number of records which were affected <br>//*------------------------------------------------------------------------ <br>SDWORD PrintAffectedRows(HSTMT hstmt, HWND hwnd) <br>{ <br>   SDWORD   cbRowCount; <br>   RETCODE  retcode; <br> <br>   // <br>   // Use SQLRowCount to see how many rows were affected.  It is possible <br>   //    that the driver does not know, in which case -1 will be returned. <br>   //    in this case, we assume success. <br>   // <br>   retcode = SQLRowCount(hstmt, &amp;cbRowCount); <br>   if(cbRowCount &gt; 0) <br>      szWrite(hwnd, <br>              GetidsString(idsAffectedRows, OutStr, MAXBUFF), <br>              cbRowCount); <br>   else <br>      szWrite(hwnd, GetidsString(idsStmtProcessed, OutStr, MAXBUFF)); <br> <br>   return cbRowCount; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
