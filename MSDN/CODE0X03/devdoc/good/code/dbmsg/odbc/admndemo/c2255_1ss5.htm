<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADMNDEMO.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2255"></a>ADMNDEMO.C</h2>
<pre><code>//*--------------------------------------------------------------------------------- <br>//|  ODBC System Administrator <br>//| <br>//|  This code is furnished on an as-is basis as part of the ODBC SDK and is <br>//|  intended for example purposes only. <br>//| <br>//|   Title:   ADMNDEMO.C <br>//|      This module contains the main interface modules for SATOOL, including <br>//|         the MDI client support <br>//*--------------------------------------------------------------------------------- <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "admndemo.h" <br>#include "sql.h" <br>#include "sqlext.h" <br>#include "ini.h" <br>#include "dialogs.h" <br>#include "odbcinst.h" <br>#include "errcheck.h" <br>#include "strings.h" <br>VSZFile; <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Defines <br>//*--------------------------------------------------------------------------------- <br>#define HLP_ADMNDEMO 50 <br> <br>typedef struct tagCMDLINE { <br>   BOOL        fOptions;                     // TRUE if there are options <br>   BOOL        fExit;                        // TRUE if we should exit when done <br>   char        szDriverConnect[100];         // String for SQLDriverConnect <br>   char        szExecuteFile[255];           // File to execute <br>   BOOL        fTrace;                       // TRUE to trace <br>   char        szTraceFile[255];             // File to log ODBC calls <br>   char        szTerm[10];                   // Stmt terminator for file <br>   int         cbStmt;                       // Maximum statement length <br>   } CMDLINE; <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Global variables <br>//*--------------------------------------------------------------------------------- <br>HWND              hwndFrame, hwndClient, hwndOutput; <br>HINSTANCE         hInst; <br>HENV              henv=NULL; <br>HMENU             hMenu=NULL, hSubMenu=NULL; <br>HICON             hIcon=NULL, hResultsIcon=NULL, hConnectIcon=NULL; <br>HFONT             hSmallEditFont; <br>RETCODE           retcode; <br>int               iHelpCnt=0;                // Tracks the <br>CHILDINFO FAR *   CreateCI=NULL; <br>char              OutStr[MAXBUFF]; <br>char              szDirName[_MAX_PATH]; <br>char              szDftFileFilter[MAXBUFF]; <br>CMDLINE           cl; <br> <br> <br>// Following is an array of connections and a global to track the current <br>lpCHILDINFO       ConnectStructs[MAXCONNECTS]; <br>lpCHILDINFO       lpActiveConn=NULL; <br>HWND              hwndCurMDIChild=NULL; <br> <br>extern UWORD            uMenuIDs[NUM_MENU_FLAGS]; <br>extern lpRESULTSINFO    lpActiveResults; <br> <br> <br>dCSEG(char) szFrameClass[]                   = "SAMDI:Frame"; <br>dCSEG(char) szChildClass[]                   = "SACLASS:1"; <br>dCSEG(char) szResultsClass[]                 = "SACLASS:2"; <br>dCSEG(char) szWindowTitle[]                  = "ODBC Admin Demo"; <br>dCSEG(char) szHELPFILE[]                     = "..\\doc\\ODBCSMPL.HLP"; <br> <br>dCSEG(char) szOPENFILE[]                     = "Open File"; <br>dCSEG(char) szSAVEFILE[]                     = "Save File"; <br>dCSEG(char) szUID[]                          =  "UID="; <br>dCSEG(char) szDSN[]                          =  "DSN="; <br>dCSEG(char) szNewLine[]                      =  "\r\n"; <br>dCSEG(char) szComma[]                        =  ", "; <br> <br>dCSEG(char) szUserAt[]                       =  "%s@%s"; <br>dCSEG(char) szUserAtFile[]                   =  "%s@%s   File: %s"; <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//|   Local functions <br>//*--------------------------------------------------------------------------------- <br>BOOL WINAPI Init(HANDLE hInstance,   HANDLE hPrevInstance, <br>          LPSTR  lpszCmdLine, int    CmdShow); <br>BOOL WINAPI SetUp(LPSTR szCmdLine, CMDLINE FAR * cl); <br>void WINAPI CleanUp(void); <br>long EXTFUN WndProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam); <br>long EXTFUN PASCAL ChildWndProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam); <br>BOOL EXTFUN PASCAL AboutWndProc(HWND hDlg, unsigned msg, WPARAM wParam, LPARAM lParam); <br> <br>BOOL WINAPI ParseCommandLine(LPSTR szCmdLine, CMDLINE FAR * cl); <br>BOOL WINAPI ParseOptionsValues(LPSTR instr, LPSTR szTerm, int cbTerm, int FAR * lpMax); <br>VOID WINAPI DoConnect(HWND hwnd, DWORD dwData); <br>BOOL WINAPI Connect(CHILDINFO FAR * ci, HWND hwnd, LPSTR szAutoConnect); <br>VOID WINAPI DoDisconnect(lpCHILDINFO lpci); <br>BOOL WINAPI Disconnect(CHILDINFO FAR * ci); <br>void WINAPI DisplayAbout(HWND hwnd, HINSTANCE hInst); <br>int  WINAPI DoMain(HANDLE hInstance); <br>HWND INTFUN GetEditWindow(CHILDINFO FAR * ci); <br> <br> <br>// File functions <br>VOID WINAPI DoFileOpen(lpCHILDINFO lpci); <br>VOID WINAPI DoFileSave(lpCHILDINFO lpci); <br>VOID WINAPI DoFileSaveAs(lpCHILDINFO lpci); <br> <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| WinMain: <br>//|     Parameters: <br>//|         hInstance     - Handle to current Data Segment <br>//|         hPrevInstance - Handle to previous Data Segment (NULL if none) <br>//|         lpszCmdLine   - Long pointer to command line info <br>//|         nCmdShow      - Integer value specifying how to start app., <br>//|                            (Iconic [7] or Normal [1,5]) <br>//*------------------------------------------------------------------------ <br>int PASCAL WinMain (HINSTANCE hInstance, <br>                    HINSTANCE hPrevInstance, <br>                    LPSTR  lpszCmdLine, <br>                    int    nCmdShow) <br>{ <br>   int         nReturn; <br> <br>   if (Init(hInstance, hPrevInstance,lpszCmdLine,nCmdShow)) { <br>      if(!SetUp(lpszCmdLine, &amp;cl))        // Quit on errors <br>         return 0; <br>      nReturn = DoMain(hInstance); <br>      CleanUp(); <br>   } <br>   return nReturn; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| Init: <br>//|   This function will take care of initilization for the application. <br>//| Parms: <br>//|   in       hInstance            Data segment for this instance <br>//|   in       hPrevInstance        Data segment for previous instance <br>//|   in       lpszCmdLine          Command line parameters <br>//|   in       nCmdShow             Desired display method <br>//| Returns: <br>//|   TRUE     if function was successful <br>//|   FALSE    if there was an error <br>//*--------------------------------------------------------------------------------- <br>BOOL WINAPI Init(HANDLE hInstance,   HANDLE hPrevInstance, <br>          LPSTR  lpszCmdLine, int    nCmdShow) <br>{ <br>   WNDCLASS wc; <br> <br> <br>   // Make sure the .ini file is there before creating anything <br>   ResolveIniFile(); <br> <br>   hInst = hInstance; <br> <br>   if(!hPrevInstance) { <br>      // Register the Frame Window first <br>      wc.style = CS_HREDRAW | CS_VREDRAW; <br>      wc.lpfnWndProc = (WNDPROC)WndProc; <br>      wc.cbClsExtra = 0; <br>      wc.cbWndExtra = 0; <br>      wc.hInstance = hInstance; <br>      hIcon = wc.hIcon = LoadIcon(hInstance, "BASEICON"); <br>      wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>      wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>      wc.lpszMenuName = NULL; <br>      wc.lpszClassName = szFrameClass; <br>      if(!RegisterClass(&amp;wc)) { <br>         PostError((LPSTR)szRegisterClassFailed); <br>         return FALSE; <br>      } <br> <br>      // Register the child window class <br>      wc.style = CS_HREDRAW | CS_VREDRAW; <br>      wc.lpfnWndProc = (WNDPROC)ChildWndProc; <br>      wc.cbClsExtra = 0; <br>      wc.cbWndExtra = sizeof(lpCHILDINFO FAR *); <br>      wc.hInstance = hInstance; <br>      hConnectIcon = wc.hIcon = LoadIcon(hInstance, "CONNECTICON"); <br>      wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>      wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>      wc.lpszMenuName = NULL; <br>      wc.lpszClassName = szChildClass; <br>      if(!RegisterClass(&amp;wc)) { <br>         PostError((LPSTR)szRegisterClassFailed); <br>         return FALSE; <br>      } <br> <br>      // Register the results output window class <br>      wc.style = CS_HREDRAW | CS_VREDRAW; <br>      wc.lpfnWndProc = (WNDPROC)ResultsWndProc; <br>      wc.cbClsExtra = 0; <br>      wc.cbWndExtra = sizeof(lpRESULTSINFO); <br>      wc.hInstance = hInstance; <br>      hResultsIcon = wc.hIcon = LoadIcon(hInstance, "RSLTICON"); <br>      wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>      wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>      wc.lpszMenuName = NULL; <br>      wc.lpszClassName = szResultsClass; <br>      if(!RegisterClass(&amp;wc)) { <br>         PostError((LPSTR)szRegisterClassFailed); <br>         return FALSE; <br>      } <br>   } <br> <br>   hMenu = LoadMenu(hInstance, "BASEMENU"); <br>   hSubMenu = GetSubMenu(hMenu, IDM_WINDOW_POS); <br> <br>   hwndFrame = CreateWindow(szFrameClass, <br>                            szWindowTitle, <br>                            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, <br>                            CW_USEDEFAULT, <br>                            CW_USEDEFAULT, <br>                            CW_USEDEFAULT, <br>                            CW_USEDEFAULT, <br>                            NULL, <br>                            hMenu, <br>                            hInstance, <br>                            NULL); <br> <br>   hwndClient = GetWindow(hwndFrame, GW_CHILD); <br>   ShowWindow(hwndFrame, <br>              (GetPrivateProfileInt(szSCREEN, szMAX, 0, szLABINI) == 1) <br>              ? SW_SHOWMAXIMIZED : nCmdShow); <br>   UpdateWindow(hwndFrame); <br> <br>   return (BOOL)(hwndFrame!=NULL); <br>} <br> <br>//*------------------------------------------------------------------------ <br>//| DoMain: <br>//|     This is the main loop for the application: <br>//*------------------------------------------------------------------------ <br>int  WINAPI DoMain(HANDLE hInstance) <br>{ <br>   MSG msg; <br>   HANDLE hAccel; <br> <br> <br>   SendMessage(hwndFrame, USER_INITAPP, 0, 0L); <br>   hAccel = LoadAccelerators(hInstance,"BASEACCELS"); <br>   while(GetMessage(&amp;msg, NULL, 0, 0)) { <br>      if(!TranslateAccelerator(hwndFrame,hAccel,&amp;msg) &amp;&amp; <br>         !TranslateMDISysAccel(hwndClient, &amp;msg)) { <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br>      } <br>   } <br> <br> <br>   return msg.wParam; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoCloseDown: <br>//|   Clean up all of the global windows, handles, etc...   After this function <br>//|   is called, the application may be killed off. <br>//| Parms: <br>//|   hwnd              The window handle being destoryed, send only on main <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>VOID WINAPI DoCloseDown(HWND hwnd) <br>{ <br>   char     szTempBuf[10]; <br> <br>   // Close all connection windows <br>   SendMessage(hwnd, WM_COMMAND, IDM_CLOSEALL, 0L); <br> <br>   // Kill off the help file if we opened it. <br>   if(iHelpCnt) <br>      WinHelp(hwnd, szHELPFILE, HELP_QUIT, 0L); <br> <br>   // Save our max/min state <br>   wsprintf(szTempBuf, "%d", IsZoomed(hwnd)); <br>   WritePrivateProfileString(szSCREEN, szMAX, szTempBuf, szLABINI); <br> <br>   // Destroy GDI objects <br>   DeleteObject(hSmallEditFont); <br> <br>   DestroyWindow(hwnd); <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| WndProc: <br>//|     Handle requests for action: <br>//*------------------------------------------------------------------------ <br>long EXTFUN WndProc(HWND      hwnd, <br>                        unsigned msg, <br>                        WPARAM     wParam, <br>                        LPARAM     lParam) <br>{ <br>   switch(msg) { <br>     case WM_CREATE: <br>      { <br>         LOGFONT                 lf; <br>         CLIENTCREATESTRUCT         clientcreate; <br> <br>         memset(&amp;lf, 0, sizeof(LOGFONT)); <br>         lf.lfHeight = -10; <br>         lf.lfWeight = FW_THIN; <br>         lf.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS; <br>         lstrcpy(lf.lfFaceName, szMSSansSerif); <br>         hSmallEditFont = CreateFontIndirect(&amp;lf); <br> <br>         clientcreate.hWindowMenu = hSubMenu; <br>         clientcreate.idFirstChild = IDM_FIRSTCHILD; <br>         hwndClient = CreateWindow("MDICLIENT", NULL, <br>                                   WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE | WS_CLIPSIBLINGS, <br>                                   0, 0, 0, 0, hwnd, <br>                                   (HMENU)(1), hInst, <br>                                   (LPSTR)&amp;clientcreate); <br>         if(!hwndClient) <br>            return -1; <br>      } <br>      return 0; <br> <br> <br>      // This user message is sent to handle any first steps once the <br>      // application is up and ready for input.  We'll cause a connection <br>      // to be done. <br>     case USER_INITAPP: <br>      SendMessage(hwnd, WM_COMMAND, IDM_CONNECT, <br>                  (cl.fOptions) ? (LPARAM)(LPSTR)cl.szDriverConnect : 0L); <br>      if(lpActiveConn &amp;&amp; <br>         *cl.szExecuteFile) <br>         ExecuteFile(lpActiveConn, hwnd, cl.szExecuteFile, cl.szTerm, cl.cbStmt); <br>      if(cl.fExit) <br>         SendMessage(hwnd, WM_COMMAND, IDM_EXIT, 0L); <br>      return 0; <br> <br> <br>      // <br>      // Hande the WM_INITMENUPOPUP message so that when the user selects <br>      //    a menu, we enable/disable each item based on our current state. <br>      // <br>     case WM_INITMENUPOPUP: <br>      if(!(BOOL)HIWORD(lParam))        // Not the system menu <br>         ResetMenu(hMenu, (int)LOWORD(lParam)); <br>      break; <br> <br>     case WM_COMMAND: <br>      switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>         //------------------------------------------------------------------- <br>         // The F6 key is a virtual key which toggles the cursor <br>         // location from the input/output window. <br>         //------------------------------------------------------------------- <br>        case IDM_MOVE_WINDOW: <br>         { <br>            if(lpActiveConn) { <br>               DWORD    dwActive=SendMessage(hwndClient, WM_MDIGETACTIVE, 0, 0L); <br>#ifndef WIN32 <br>               HWND     Active = LOWORD(dwActive); <br>#else <br>               HWND     Active = (HWND)(dwActive); <br>#endif <br> <br>               if(Active != lpActiveConn-&gt;hwnd) { <br>                  SendMessage(hwndClient, WM_MDIACTIVATE, <br>                              (WPARAM)(HWND)lpActiveConn-&gt;hwnd, 0L); <br>                  return 0; <br>               } <br>               if(GetFocus() == lpActiveConn-&gt;hwndIn) <br>                  SetFocus(lpActiveConn-&gt;hwndOut); <br>               else <br>                  SetFocus(lpActiveConn-&gt;hwndIn); <br>            } <br>         } <br>         return 0; <br> <br> <br>         //------------------------------------------------------------------- <br>         // Connect Menu <br>         //------------------------------------------------------------------- <br>        case IDM_CONNECT: <br>         DoConnect(hwnd, lParam); <br>         return 0; <br> <br>        case IDM_DISCONNECT: <br>         DoDisconnect(lpActiveConn); <br>         return 0; <br> <br>        case IDM_EXECUTE_FILE: <br>         ExecuteFile(lpActiveConn, hwnd, NULL, NULL, 0); <br>         return 0; <br> <br>        case IDM_OPEN: <br>         DoFileOpen(lpActiveConn); <br>         return 0; <br> <br>        case IDM_CLOSE: <br>         { <br>            // zzz:  Check for save if modified <br>            szWrite(lpActiveConn-&gt;hwndOut, <br>                    GetidsString(idsFileClosed, OutStr, sizeof(OutStr)), <br>                    (LPSTR)lpActiveConn-&gt;szFile); <br> <br>            wsprintf((LPSTR)lpActiveConn-&gt;szClientTitle, szUserAt, <br>                     (LPSTR)lpActiveConn-&gt;CurrentUser, (LPSTR)lpActiveConn-&gt;CurrentServer); <br>            lpActiveConn-&gt;hFile = 0; <br>            ReleaseMemory(lpActiveConn-&gt;szFileBuff); <br>            SetWindowText(lpActiveConn-&gt;hwnd, lpActiveConn-&gt;szClientTitle); <br>         } <br>         return 0; <br> <br>        case IDM_SAVE: <br>         DoFileSave(lpActiveConn); <br>         return 0; <br> <br>        case IDM_SAVEAS: <br>         DoFileSaveAs(lpActiveConn); <br>         return 0; <br> <br>        case IDM_EXIT: <br>         SendMessage(hwnd, WM_CLOSE, 0, 0L); <br>         return 0; <br> <br> <br>         //------------------------------------------------------------------- <br>         // Edit Menu <br>         //------------------------------------------------------------------- <br>        case IDM_UNDO: <br>        case IDM_CUT: <br>        case IDM_COPY: <br>        case IDM_PASTE: <br>         { <br>            HWND        fhwnd=GetEditWindow(lpActiveConn); <br> <br>            if(fhwnd) <br>               SendMessage(fhwnd, <br>                           (wParam == IDM_CUT) ? WM_CUT : <br>                           (wParam == IDM_COPY) ? WM_COPY : <br>                           (wParam == IDM_PASTE) ? WM_PASTE : WM_UNDO, <br>                           0, 0L); <br>         } <br>         return 0; <br> <br>        case IDM_SELECT_ALL: <br>         { <br>            HWND              fhwnd; <br> <br>            if(!(fhwnd = GetEditWindow(lpActiveConn))) <br>               break; <br>            SetFocus(fhwnd); <br>            SendMessage(fhwnd, EM_SETSEL, 0, MAKELPARAM(0, -1)); <br>         } <br>         return 0; <br> <br> <br> <br>         //------------------------------------------------------------------- <br>         // Command Menu <br>         //------------------------------------------------------------------- <br>        case IDM_EXECUTE_NOW: <br>         ExecuteCmds(lpActiveConn, NULL); <br>         return 0; <br> <br>        case IDM_COMMIT: <br>        case IDM_ROLLBACK: <br>         DoCommitRollback(lpActiveConn, wParam); <br>         return 0; <br> <br> <br> <br>         //------------------------------------------------------------------- <br>         // Pipe Menu <br>         //------------------------------------------------------------------- <br>        case IDM_PIPE_EDIT: <br>         EditPipe(lpActiveConn); <br>         return 0; <br> <br>        case IDM_PIPE_DO: <br>         HandlePipe(lpActiveConn, lpActiveResults); <br>         return 0; <br> <br> <br> <br>         //------------------------------------------------------------------- <br>         // Info Menu <br>         //------------------------------------------------------------------- <br>        case IDM_MANAGE_DSNS: <br>         { <br>            HWND     fHwnd=GetFocus(); <br> <br>            SQLManageDataSources(hwnd); <br>            if(fHwnd) <br>               SetFocus(fHwnd); <br>         } <br>         return 0; <br> <br>        case IDM_DATA_TYPES: <br>         DisplayODBCDataTypes(lpActiveConn); <br>         return 0; <br> <br>        case IDM_FUNCTIONS: <br>         DisplayODBCFunctions(lpActiveConn); <br>         return 0; <br> <br>        case IDM_DATA_SOURCES: <br>         DisplayODBCDataSources(lpActiveConn); <br>         return 0; <br> <br>        case IDM_ODBC_INFO: <br>         DisplayGetInfo(lpActiveConn); <br>         return 0; <br> <br> <br> <br>         //------------------------------------------------------------------- <br>         // Lists Menu <br>         //------------------------------------------------------------------- <br>        case IDM_TABLES: <br>        case IDM_COLUMNS: <br>        case IDM_STATISTICS: <br>        case IDM_PRIMARY_KEYS: <br>        case IDM_FOREIGN_KEYS: <br>        case IDM_TABLE_PRIVS: <br>        case IDM_COLUMN_PRIVS: <br>        case IDM_SPECIAL_COLUMNS: <br>        case IDM_PROCEDURES: <br>        case IDM_PROC_COLUMNS: <br>         DoList(lpActiveConn, wParam); <br>         return 0; <br> <br> <br> <br>         //------------------------------------------------------------------- <br>         // Window Menu <br>         //------------------------------------------------------------------- <br>        case IDM_FONT: <br>         PromptForFontName(hwnd); <br>         return 0; <br> <br>        case IDM_CASCADE: <br>         SendMessage(hwndClient, WM_MDICASCADE, 0, 0L); <br>         return 0; <br> <br>        case IDM_TILE: <br>         SendMessage(hwndClient, WM_MDITILE, 0, 0L); <br>         return 0; <br> <br>        case IDM_ARRANGE: <br>         SendMessage(hwndClient, WM_MDIICONARRANGE, 0, 0L); <br>         return 0; <br> <br>        case IDM_CLOSEALL: <br>         { <br>            int         idex; <br>            int         iNum=NumItems(ConnectStructs); <br> <br>            for(idex=0;  idex&lt;iNum;  idex++) <br>               if(ConnectStructs[idex] != NULL) <br>                  DoDisconnect(ConnectStructs[idex]); <br>         } <br>         return 0; <br> <br> <br> <br>         //------------------------------------------------------------------- <br>         // Help Menu <br>         //------------------------------------------------------------------- <br>        case IDM_HELP: <br>         iHelpCnt += WinHelp(hwnd, szHELPFILE, HELP_INDEX, 0L); <br>         return 0; <br> <br>        case IDM_ABOUT: <br>         DisplayAbout(hwnd, hInst); <br>         return 0; <br>      } <br>      break; <br> <br> <br> <br> <br>case WM_CLOSE: <br>      DoCloseDown(hwnd); <br>      return 0; <br> <br>     case WM_DESTROY: <br>      PostQuitMessage(0); <br>      return 0; <br> <br> <br>     default: <br>      break; <br>   } <br> <br>   return DefFrameProc(hwnd, hwndClient, msg, wParam, lParam); <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| ChildWndProc: <br>//|     Handle all messages which are received for the MDI child <br>//|         windows. <br>//*------------------------------------------------------------------------ <br>long EXTFUN ChildWndProc(HWND    hwnd, <br>                        unsigned msg, <br>                        WPARAM     wParam, <br>                        LPARAM     lParam) <br>{ <br>   switch(msg) { <br>      // <br>      // When a successful connection is made, then we are called to <br>      //    create a window to handle it.  The CHILDINFO structure has <br>      //    already been allocated. <br>      // <br>     case WM_CREATE: <br>      { <br>         CREATESTRUCT FAR *      cs; <br>         MDICREATESTRUCT FAR *   mdi; <br>         lpCHILDINFO             lpci; <br> <br>         cs = (CREATESTRUCT FAR *)lParam; <br>         mdi = (MDICREATESTRUCT FAR *)cs-&gt;lpCreateParams; <br>         lpci = (lpCHILDINFO)mdi-&gt;lParam; <br> <br>         SETCIPOINTER(hwnd, lpci); <br> <br>         lpci-&gt;hwnd = hwnd; <br>         lpci-&gt;hInst = hInst; <br>         hwndClient = GetParent(hwnd); <br>         hwndFrame = GetParent(hwndClient); <br>         if(!(lpci-&gt;hwndIn = CreateWindow("edit", NULL, <br>                                          WS_CHILD | WS_VISIBLE | WS_VSCROLL | <br>                                          WS_BORDER | WS_HSCROLL | ES_MULTILINE | ES_AUTOVSCROLL, <br>                                          0, 0, 0, 0, <br>                                          hwnd, (HMENU)(3), hInst, NULL))) <br>            return -1; <br>         if(!(lpci-&gt;hwndOut = CreateWindow("edit", NULL, <br>                                           WS_CHILD | WS_VISIBLE | WS_VSCROLL | <br>                                           WS_BORDER | WS_HSCROLL | ES_MULTILINE | ES_AUTOVSCROLL, <br>                                           0, 0, 0, 0, <br>                                           hwnd, (HMENU)(4), hInst, NULL))) <br>            return -1; <br> <br> <br>         SendMessage(lpci-&gt;hwndIn, WM_SETFONT, <br>                     (WPARAM)hSmallEditFont, (LPARAM)MAKELONG((WORD)TRUE, 0)); <br>         SendMessage(lpci-&gt;hwndOut, WM_SETFONT, <br>                     (WPARAM)hSmallEditFont, (LPARAM)MAKELONG((WORD)TRUE, 0)); <br> <br>         szWrite(lpci-&gt;hwndOut, <br>                 GetidsString(idsSuccessConnect, OutStr, sizeof(OutStr)), <br>                 (LPSTR)lpci-&gt;CurrentUser, (LPSTR)lpci-&gt;CurrentServer); <br>      } <br>      return 0; <br> <br>      // <br>      // NOTE:  We must break to return DefMDIWndProc in order for the menu to <br>      //    be redrawn when we maximize the child window. <br>      // <br>     case WM_SIZE: <br>      { <br>         lpCHILDINFO       lpci; <br>         int               di, dot; <br> <br>         lpci = GETCIPOINTER(hwnd); <br> <br>         lpci-&gt;dx = LOWORD(lParam); <br>         lpci-&gt;dy = HIWORD(lParam); <br>         di = lpci-&gt;dy * 1 / 2; <br>         dot = lpci-&gt;dy - di; <br>         MoveWindow(lpci-&gt;hwndIn, 0, 0, lpci-&gt;dx, di, TRUE); <br>         MoveWindow(lpci-&gt;hwndOut, 0, di, lpci-&gt;dx, dot, TRUE); <br>      } <br>      break; <br> <br> <br> <br> <br> <br>      // <br>      // Handle the WM_INITMENUPOPUP message so that when the user selects <br>      //    a menu, we enable/disable each item based on our current state. <br>      // <br>     case WM_INITMENUPOPUP: <br>      if(!(BOOL)HIWORD(lParam))        // Not the system menu <br>         ResetMenu((HMENU)wParam, (int)LOWORD(lParam)); <br>      break; <br> <br> <br>      // <br>      // All messages are handled in the main wnd proc, so pass them back <br>      // <br>     case WM_COMMAND: <br>      { <br>         UINT        id=GET_WM_COMMAND_ID(wParam, lParam); <br> <br>         if(id &gt;= IDM_CONNECT &amp;&amp; <br>            id &lt;= IDM_MOVE_WINDOW) <br>            SendMessage(hwndFrame, WM_COMMAND, wParam, lParam); <br>      } <br>      break; <br> <br> <br>      // <br>      // The WM_MDIACTIVATE message is received first by the child window <br>      //    which is losing focus, then by the window which is receiving <br>      //    focus. <br>      // <br>     case WM_MDIACTIVATE: <br>      { <br>#ifndef WIN32 <br>         if(wParam) { <br>            lpActiveConn = GETCIPOINTER((HWND)LOWORD(lParam)); <br>         } <br>#else <br>         if((HWND)lParam == hwnd) { <br>            lpActiveConn = GETCIPOINTER((HWND)lParam); <br>         } <br>#endif <br>         else <br>            lpActiveConn = NULL; <br> <br>         if(lpActiveConn) { <br>            hwndCurMDIChild = lpActiveConn-&gt;hwnd; <br>            SetFocus(lpActiveConn-&gt;hwndIn); <br>         } <br>      } <br>      return 0; <br> <br> <br>      // <br>      // Check for a system close command.  This is the equivalent of a <br>      //    Disconnect, so process it as such. <br>      // <br>     case WM_SYSCOMMAND: <br>      { <br>         if(wParam == SC_CLOSE) { <br>            SendMessage(hwnd, WM_COMMAND, IDM_DISCONNECT, 0L); <br>            return 0; <br>         } <br>      } <br>      break; <br> <br>     default: <br>      break; <br>   } <br> <br>   return DefMDIChildProc(hwnd, msg, wParam, lParam); <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| SetUp: <br>//|   This function handles one-time setup operations for the app.  This includes <br>//|   allocating an environment handle for ODBC, and processing the command <br>//|   line. <br>//| Parms: <br>//|   szCmdLine         Command line arguments <br>//|   cl                Command line strucutre for return <br>//| Returns: <br>//|   FALSE if there was an error <br>//*--------------------------------------------------------------------------------- <br>BOOL WINAPI SetUp(LPSTR szCmdLine, CMDLINE FAR * cl) <br>{ <br>   LPSTR str; <br> <br>   // Load default resource strings <br>   GetidsString(idsDftFileFilter, szDftFileFilter, sizeof(szDftFileFilter)); <br>   str = (LPSTR)szDftFileFilter; <br>   while((str = strchr(str, '|'))) <br>      *str++ = '\0'; <br> <br>   if(SQL_SUCCESS != SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HENV, &amp;henv)) { <br>      szMessageBox(GetActiveWindow(), <br>                   MB_ICONEXCLAMATION, <br>                   (LPSTR)szErrTitle, <br>                   GetidsString(idsSQLAllocHandleFailed, OutStr, sizeof(OutStr))); <br>      return FALSE; <br>   } <br> <br>   if(SQL_SUCCESS != SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, <br>                                   (SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER)) { <br>      DisplayErrors(NULL, GetidsString(idsSQLSetEnvAttr, OutStr, sizeof(OutStr)), <br>                    SQL_HANDLE_ENV, henv); <br>      return FALSE; <br>   } <br> <br>   if(!ParseCommandLine(szCmdLine, cl)) <br>      return FALSE; <br> <br>   if(cl-&gt;fTrace) { <br>      if(SQL_SUCCESS != <br>         (retcode = SQLSetConnectAttr(NULL, SQL_ATTR_TRACEFILE, <br>                                      (LPSTR)cl-&gt;szTraceFile, SQL_NTS))) <br>         DisplayErrors(NULL, GetidsString(idsSQLSetConnectAttr, OutStr, sizeof(OutStr)), <br>                       SQL_HANDLE_ENV, henv); <br> <br>      if(SQL_SUCCESS != <br>         (retcode = SQLSetConnectAttr(NULL, SQL_ATTR_TRACE, <br>                                      (SQLPOINTER) SQL_TRUE, <br>                                      SQL_IS_INTEGER))) <br>         DisplayErrors(NULL, GetidsString(idsSQLSetConnectAttr, OutStr, sizeof(OutStr)), <br>                       SQL_HANDLE_ENV, henv); <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| CleanUp: <br>//|     Any last-minute application cleanup activities are done here: <br>//*------------------------------------------------------------------------ <br>void WINAPI CleanUp(void) <br>{ <br>   retcode = SQLFreeHandle(SQL_HANDLE_ENV, henv); <br> <br>#ifdef DEBUGGING <br>   { <br>      retcode = SQLSetConnectAttr(NULL, SQL_ATTR_TRACE, SQL_FALSE, SQL_IS_INTEGER); <br>      WinAssert(retcode == SQL_SUCCESS, (LPSTR)"SetConnectAttr: SQL_ATTR_TRACE"); <br>   } <br>#endif <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| ParseCommandLine: <br>//|   This function will break down the command line and look for common elements. <br>//| Parms: <br>//|   instr             The input string to look at <br>//|   cl                Command line strucutre to store info <br>//| Returns: <br>//|   FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL WINAPI ParseCommandLine(LPSTR instr, CMDLINE FAR * cl) <br>{ <br>   LPSTR    str=instr; <br>   LPSTR    endstr=str; <br> <br>   if(!str) <br>      return TRUE; <br> <br>   // Assume some defaults <br>   memset(cl, 0, sizeof(CMDLINE)); <br>   cl-&gt;cbStmt = 1000; <br>   lstrcpy(cl-&gt;szTerm, (LPSTR)"\r\n"); <br>   cl-&gt;fExit = FALSE; <br> <br>   // Look for each / value.  Spaces are allowed.  Any other character <br>   // at this level is a syntax error <br>   while(endstr &amp;&amp; *str) <br>      switch(*str) { <br>         // We have encountered a command line switch.  See which it is <br>        case '/': <br>        case '-': <br>         ++str; <br>         switch(*str) { <br>            // /D[] for driver connection string <br>           case 'D': <br>           case 'd': <br>            ++str; <br>            if(*str != '[' || <br>               !(endstr = strchr(str, ']'))) <br>               goto tokenerr; <br>            *endstr = '\0'; <br>            if(lstrlen(cl-&gt;szDriverConnect) &gt; sizeof(cl-&gt;szDriverConnect)) <br>               goto toobig; <br>            lstrcpy(cl-&gt;szDriverConnect, str + 1); <br>            str = endstr + 1; <br>            cl-&gt;fOptions = TRUE; <br>            break; </code></pre>
<p>
</p>
<pre><code><br>            // /F for file name to execute <br>           case 'F': <br>           case 'f': <br>            if((endstr = strchr(++str, ' '))) <br>               *endstr = '\0'; <br>            if(lstrlen(cl-&gt;szExecuteFile) &gt; sizeof(cl-&gt;szExecuteFile)) <br>               goto toobig; <br>            lstrcpy(cl-&gt;szExecuteFile, str); <br>            str = endstr + 1; <br>            break; <br> <br>            // /O for options <br>           case 'O': <br>           case 'o': <br>            if((endstr = strchr(++str, ' '))) <br>               *endstr = '\0'; <br>            if(!ParseOptionsValues(str, cl-&gt;szTerm, sizeof(cl-&gt;szTerm), &amp;cl-&gt;cbStmt)) <br>               goto tokenerr; <br>            str = endstr + 1; <br>            break; <br> <br>            // /T for a trace file name <br>           case 'T': <br>           case 't': <br>            if((endstr = strchr(++str, ' '))) <br>               *endstr = '\0'; <br>            if(lstrlen(cl-&gt;szTraceFile) &gt; sizeof(cl-&gt;szTraceFile)) <br>               goto toobig; <br>            lstrcpy(cl-&gt;szTraceFile, str); <br>            str = endstr + 1; <br>            cl-&gt;fTrace = TRUE; <br>            break; <br> <br>            // /X for exit option <br>           case 'X': <br>           case 'x': <br>            ++str; <br>            if(str &amp;&amp; <br>               (*str == 'Y' || *str == 'y')) <br>               cl-&gt;fExit = TRUE; <br>            else if(*str == 'N' || *str == 'n') <br>               cl-&gt;fExit = FALSE; <br>            else <br>               goto tokenerr; <br>            ++str; <br>            break; <br> <br>            // Not a valid argument, error <br>           default: <br>            goto tokenerr; <br>         } <br>         break;   // End of '/' or '-' <br> <br>        case ' ': <br>         ++str; <br>         break; <br> <br>        default: <br>         goto tokenerr; <br>      } <br>   return TRUE; <br> <br>  tokenerr: <br>   szMessageBox(GetActiveWindow(), <br>                MB_ICONEXCLAMATION, <br>                (LPSTR)szErrTitle, <br>                GetidsString(idsInvalidCmdLine, OutStr, sizeof(OutStr))); <br>   return FALSE; <br> <br>  toobig: <br>   szMessageBox(GetActiveWindow(), <br>                MB_ICONEXCLAMATION, <br>                (LPSTR)szErrTitle, <br>                GetidsString(idsCmdLineTooBig, OutStr, sizeof(OutStr))); <br>   return FALSE; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| ParseOptionsValues: <br>//|   This function breaks down the /O switch by returning the invidual elements. <br>//| Parms: <br>//|   instr             The string to parse <br>//|   szTerm            Terminator value <br>//|   cbTerm            Max for terminator value <br>//|   lpMax             Maximum size for statement execution <br>//| Returns: <br>//|   FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL WINAPI ParseOptionsValues(LPSTR instr, LPSTR szTerm, int cbTerm, int FAR * lpMax) <br>{ <br>   LPSTR str=instr; <br>   LPSTR endstr=instr; <br>   char  cApost = '\''; <br> <br>   // Now look for user specific values <br>   while(endstr &amp;&amp; *str) <br>      switch(*str) { <br>         // Found the terminator <br>        case 'T': <br>        case 't': <br>         // Could be a Carriage return or a string <br>         ++str; <br>         if(*str == cApost) { <br>            if(!(endstr = strchr(++str, cApost))) <br>               return FALSE; <br>            *endstr = '\0'; <br>            if(lstrlen(str) &gt; cbTerm) <br>               return FALSE; <br>            lstrcpy(szTerm, str); <br>            str = endstr + 1; <br>         } <br>         else if(strncmp(str, "CR", 2) != 0) <br>            return FALSE; <br>         else { <br>            lstrcpy(szTerm, (LPSTR)"\r\n"); <br>            str += 2; <br>         } <br>         break; <br> <br>         // Found the Maximum length value <br>        case 'M': <br>        case 'm': <br>         ++str; <br>         if((endstr = strchr(str, ':'))) <br>            *endstr = '\0'; <br>         *lpMax = lpatoi(str); <br>         if(*lpMax &lt; MINSTMTSIZE || <br>            *lpMax &gt; MAXSTMTSIZE) <br>            return FALSE; <br>         str = endstr + 1; <br>         break; <br> <br>         // Ignore delimiter <br>        case ':': <br>         ++str; <br>         break; <br> <br>         // This is an error <br>        default: <br>         return FALSE; <br>         break; <br>      } <br>   return TRUE; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoConnect: <br>//|   Handle the structures involved in creating a connection window.  Invoke the <br>//|   Connect function to do the actual ODBC work. <br>//| Parms: <br>//|   hwnd              The parent window handle for the new child <br>//|   dwData            Indicates a start code or string. <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>VOID WINAPI DoConnect(HWND hwnd, DWORD dwData) <br>{ <br>   lpCHILDINFO       citmp; <br>   MDICREATESTRUCT   mdicreate; <br>   int               idex; <br> <br>   for(idex=0;  idex&lt;MAXCONNECTS;  idex++) <br>      if(!ConnectStructs[idex]) <br>         break; <br> <br>   // See if we have exceeded the max connects <br>   if(idex &gt;= MAXCONNECTS) { <br>      szMessageBox(hwnd, <br>                   MB_ICONINFORMATION | MB_OK, <br>                   (LPSTR)szErrTitle, <br>                   GetidsString(idsTooManyConnects, OutStr, sizeof(OutStr)), <br>                   MAXCONNECTS); <br>      return; <br>   } <br> <br>   citmp = (lpCHILDINFO)GetMemory(sizeof(CHILDINFO)); <br>   if(!citmp) <br>      return; <br> <br>   memset(citmp, 0, sizeof(CHILDINFO)); <br> <br>   if(Connect(citmp, hwnd, <br>              (HIWORD(dwData) == 1) ? NULL : (LPSTR)dwData)) {  // Pass NULL if accelerator used <br>      // We are connected, save the handle <br>      ConnectStructs[idex] = citmp; <br> <br>      // Now fill out the rest <br>      citmp-&gt;hwndClient = hwndClient; <br>      citmp-&gt;henv = henv;                    // Keep local copy of global <br> <br>      wsprintf((LPSTR)citmp-&gt;szClientTitle, szUserAt, (LPSTR)citmp-&gt;CurrentUser, <br>               (LPSTR)citmp-&gt;CurrentServer); <br>      mdicreate.szClass = szChildClass; <br>      mdicreate.szTitle = citmp-&gt;szClientTitle; <br>      mdicreate.hOwner  = hInst; <br>      mdicreate.x       = CW_USEDEFAULT; <br>      mdicreate.y       = CW_USEDEFAULT; <br>      mdicreate.cx      = CW_USEDEFAULT; <br>      mdicreate.cy      = CW_USEDEFAULT; <br>      mdicreate.style   = (hwndCurMDIChild) ? ((IsZoomed(hwndCurMDIChild)) ? WS_MAXIMIZE : 0) : 0; <br>      mdicreate.lParam  = (LPARAM)citmp; <br>      SendMessage(hwndClient, WM_MDICREATE, 0, <br>                  (LPARAM)(LPMDICREATESTRUCT)&amp;mdicreate); <br>   } <br>   else { <br>      // No connect made, so release all memory <br>      retcode = SQLFreeHandle(SQL_HANDLE_DBC, citmp-&gt;hdbc); <br>      ReleaseMemory(citmp); <br>   } <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| Connect: <br>//|   This function attempts to make a connection.  If the user has specified the <br>//|   /D command line option, then we will simply use the connection string. <br>//| Parms: <br>//|   ci                Connection window information <br>//|   hwnd              Window handle for any prompting <br>//|   szAutoConnect     NULL if prompt, else pointer to szConnStrIn <br>//| Returns: <br>//|   FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL WINAPI Connect(CHILDINFO FAR * ci, HWND hwnd, LPSTR szAutoConnect) <br>{ <br>   SWORD       cb; <br>   RETCODE     rc; <br>   UWORD       fExists; <br>   int         idex; <br> <br>   if(SQL_SUCCESS != (retcode = SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;ci-&gt;hdbc))) { <br>      szMessageBox(GetActiveWindow(), <br>                   MB_ICONEXCLAMATION | MB_OK, <br>                   (LPSTR)szErrTitle, <br>                   GetidsString(idsSQLAllocHandleFailed, OutStr, sizeof(OutStr))); <br>      return FALSE; <br>   } <br> <br> <br>   // Do the connection <br>   if(!szAutoConnect) <br>      retcode = SQLDriverConnect(ci-&gt;hdbc, hwnd, NULL, 0, ci-&gt;szConnStrOut, <br>                                 MAXBUFF, &amp;cb, SQL_DRIVER_COMPLETE); <br>   else <br>      retcode = SQLDriverConnect(ci-&gt;hdbc, hwnd, szAutoConnect, SQL_NTS, <br>                                 ci-&gt;szConnStrOut, MAXBUFF, &amp;cb, SQL_DRIVER_NOPROMPT); <br>   if(retcode == SQL_NO_DATA) <br>      return FALSE; <br>   else if(retcode == SQL_ERROR) { <br>      PrintErrors(ci, SQL_HANDLE_DBC); <br>      return FALSE; <br>   } <br> <br>   if(RC_SUCCESSFUL(retcode)) { <br>      SWORD len; <br> <br>      retcode = SQLGetInfo(ci-&gt;hdbc, SQL_USER_NAME, ci-&gt;CurrentUser, <br>                           sizeof(ci-&gt;CurrentUser), &amp;len); <br>      if(retcode == SQL_ERROR || len == 0)   // Assume driver not capable <br>         *ci-&gt;CurrentUser = '\0'; <br> <br>      retcode = SQLGetInfo(ci-&gt;hdbc, SQL_DATA_SOURCE_NAME, ci-&gt;CurrentServer, <br>                           sizeof(ci-&gt;CurrentServer), NULL); <br>   } <br> <br>   if(SQL_SUCCESS != (retcode = SQLAllocHandle(SQL_HANDLE_STMT, ci-&gt;hdbc, &amp;ci-&gt;hstmt))) { <br>      szMessageBox(GetActiveWindow(), <br>                   MB_ICONEXCLAMATION, <br>                   (LPSTR)szErrTitle, <br>                   GetidsString(idsSQLAllocHandleFailed, OutStr, sizeof(OutStr))); <br>      return FALSE; <br>   } <br> <br>   // <br>   // Find out what functions are supported and store them in a bitmask <br>   // <br>   memset(&amp;ci-&gt;fFunctions, 0, sizeof(ci-&gt;fFunctions)); <br>   for(idex=0;  idex&lt;NUM_MENU_FLAGS;  idex++) { <br>      rc = SQLGetFunctions(ci-&gt;hdbc, <br>                           uMenuIDs[idex], <br>                           &amp;fExists); <br>      if(RC_NOTSUCCESSFUL(rc)) { <br>         fExists = FALSE; <br>         PrintErrors(ci, SQL_HANDLE_DBC); <br>      } <br> <br>      if(fExists) <br>         BitSet(ci-&gt;fFunctions, idex); <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>int WINAPI GetConnDex(lpCHILDINFO lpci) <br>{ <br>   int idex; <br> <br>   for(idex=0;  idex&lt;MAXCONNECTS;  idex++) <br>      if(lpci == ConnectStructs[idex]) <br>         return idex; <br> <br>   return -1; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoDisconnect: <br>//|   Look for the handle passed in and then disconnect it.  The Disconnect function <br>//|   is used to do the ODBC portion. <br>//| Parms: <br>//|   lpci              Connect window to free <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>VOID WINAPI DoDisconnect(lpCHILDINFO lpci) <br>{ <br>   int         idex; <br> <br>   idex = GetConnDex(lpci); <br>   if(idex == -1) <br>      return; <br> <br>   if(Disconnect(lpci)) { <br>      FreeConnectWindowResults(lpci); <br>      SendMessage(hwndClient, WM_MDIDESTROY, (WPARAM)(HWND)lpci-&gt;hwnd, 0L); <br>      ConnectStructs[idex] = NULL; <br>   } <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| Disconnect: <br>//|     Make a connection to a server. <br>//*------------------------------------------------------------------------ <br>BOOL WINAPI Disconnect(CHILDINFO FAR * ci) <br>{ <br>   if(SQL_SUCCESS != (retcode = SQLFreeHandle(SQL_HANDLE_STMT, ci-&gt;hstmt))) <br>      DisplayErrors(ci-&gt;hwnd, GetidsString(idsSQLFreeHandle, OutStr, sizeof(OutStr)), <br>                    SQL_HANDLE_STMT, ci-&gt;hstmt); <br>   if(SQL_SUCCESS != (retcode = SQLDisconnect(ci-&gt;hdbc))) <br>      DisplayErrors(ci-&gt;hwnd, GetidsString(idsSQLDisconnect, OutStr, sizeof(OutStr)), <br>                    SQL_HANDLE_DBC, ci-&gt;hdbc); <br>   if(SQL_SUCCESS != (retcode = SQLFreeHandle(SQL_HANDLE_DBC, ci-&gt;hdbc))) <br>      DisplayErrors(ci-&gt;hwnd, GetidsString(idsSQLFreeHandle, OutStr, sizeof(OutStr)), <br>                    SQL_HANDLE_DBC, ci-&gt;hstmt); <br> <br>   ci-&gt;hstmt = ci-&gt;hdbc = NULL; <br>   szWrite(ci-&gt;hwndOut, <br>           GetidsString(idsDisconnectSuccess, OutStr, sizeof(OutStr))); <br> <br>   return TRUE; <br>} <br> <br> <br> <br> <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| DisplayAbout: <br>//|     Display the about box for this app. <br>//*------------------------------------------------------------------------ <br>void WINAPI DisplayAbout(HWND hwnd, HINSTANCE hInst) <br>{ <br>   HWND     fHwnd=GetFocus(); <br> <br>   if(-1 == DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hwnd, (DLGPROC)AboutWndProc, <br>                           (LPARAM)(HINSTANCE FAR * )&amp;hInst)) <br>      MessageBox(hwnd, "Could not open dialog box.", <br>                 "About", MB_ICONEXCLAMATION); <br> <br>   if(fHwnd) <br>      SetFocus(fHwnd); <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| AboutWndProc: <br>//|     Handle the About messages <br>//*------------------------------------------------------------------------ <br>BOOL EXTFUN AboutWndProc(HWND    hDlg, <br>                              unsigned msg, <br>                              WPARAM     wParam, <br>                              LPARAM     lParam) <br>{ <br>   int x=10,y=30; <br>   static HINSTANCE FAR *  lpHINST; <br> <br>   switch(msg) { <br>     case WM_INITDIALOG: <br>      lpHINST = (HINSTANCE FAR *)lParam; <br>      CenterDialog(hDlg); <br>      return TRUE; <br> <br>     case WM_COMMAND: <br>      SendMessage(hDlg, WM_CLOSE, 0, 0L); <br>      return TRUE; <br> <br> <br>     case WM_CLOSE: <br>      EndDialog(hDlg, FALSE); <br>      return TRUE; <br> <br> <br>     default: <br>      return FALSE; <br>   } <br>} <br> <br> <br> <br>//*------------------------------------------------------------------------ <br>//| Busy: <br>//|     Display the hour glass cursor when we are working <br>//|         flag = TRUE means we are busy to so display it <br>//|         flag = FALSE means go back to old cursor <br>//*------------------------------------------------------------------------ <br>void Busy(int flag) <br>{ <br>   static HCURSOR hCursor;                // Save old cursor handle <br> <br>   ShowCursor(FALSE); <br>   if(flag) <br>      hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>   else <br>      SetCursor(hCursor); <br>   ShowCursor(TRUE); <br>} <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| iLoadString: <br>//|   This function will retrieve a string from our resource fork and place it <br>//|      in the buffer provided.  If the string is not found, an empty string <br>//|      is returned. <br>//| Parms: <br>//|   in       id                   String number to retrieve <br>//|   in       str                  Output string <br>//|   in       len                  Lenth of possible output <br>//| Returns: <br>//|   Pointer to buffer str <br>//*--------------------------------------------------------------------------------- <br>LPSTR iLoadString(int id, LPSTR str, int len) <br>{ <br>   if(!str || <br>      len &lt;= 0) <br>      return str; <br> <br>   if(!LoadString(hInst, id, str, len)) <br>      *str = '\0'; <br>   return str; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| GetEditWindow: <br>//|   This function will get the current focus window and verify that it is <br>//|   an edit window which is valid for one of the Edit menu items. <br>//| Parms: <br>//|   lpci                 Connection window information <br>//| Returns: <br>//|   Edit window handle if valid, NULL if not valid <br>//*--------------------------------------------------------------------------------- <br>HWND INTFUN GetEditWindow(lpCHILDINFO lpci) <br>{ <br>   HWND hwnd; <br>   hwnd = GetFocus(); <br> <br>   if(hwnd &amp;&amp; lpci) { <br>      if(hwnd == lpci-&gt;hwndIn || <br>         hwnd == lpci-&gt;hwndOut) <br>         return hwnd; <br>   } <br> <br>   return NULL; <br>} <br> <br> <br>//*------------------------------------------------------------------------ <br>//| CenterDialog: <br>//|      Center the dialog over the parent window.  It is possible that <br>//|         their is not a parent window, since the Translate DLL was <br>//|         never meant to display data.  For this reason, we may just <br>//|         center over the entire screen. <br>//*------------------------------------------------------------------------ <br>void WINAPI  CenterDialog(HWND hdlg) <br>{ <br>   RECT  rcParent;                         // Parent window client rect <br>   RECT  rcDlg;                            // Dialog window rect <br>   int   nLeft, nTop;                      // Top-left coordinates <br>   int   cWidth, cHeight;                  // Width and height <br>   HWND  hwnd; <br> <br>   // Get frame window client rect in screen coordinates <br>   if((hwnd = GetParent(hdlg)) == NULL) { <br>      rcParent.top = rcParent.left = 0; <br>      rcParent.right = GetSystemMetrics(SM_CXFULLSCREEN); <br>      rcParent.bottom = GetSystemMetrics(SM_CYFULLSCREEN); <br>   } <br>   else <br>      GetWindowRect(hwnd, &amp;rcParent); <br> <br>   // Determine the top-left point for the dialog to be centered <br>   GetWindowRect(hdlg, &amp;rcDlg); <br>   cWidth  = rcDlg.right  - rcDlg.left; <br>   cHeight = rcDlg.bottom - rcDlg.top; <br>   nLeft   = rcParent.left + <br>      (((rcParent.right  - rcParent.left) - cWidth ) / 2); <br>   nTop    = rcParent.top  + <br>      (((rcParent.bottom - rcParent.top ) - cHeight) / 2); <br>   if (nLeft &lt; 0) nLeft = 0; <br>   if (nTop  &lt; 0) nTop  = 0; <br> <br>   // Place the dialog <br>   MoveWindow(hdlg, nLeft, nTop, cWidth, cHeight, TRUE); <br>   return; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoFileOpen: <br>//|   Use the commond dialog functions to open a file. <br>//| Parms: <br>//|   lpci                    Connection window information <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>VOID WINAPI DoFileOpen(lpCHILDINFO lpci) <br>{ <br>   OPENFILENAME      ofn; <br>   HWND              fHwnd=GetFocus(); <br> <br> <br>   // If user has a file open already, verify that we should continue <br>   if(lpci-&gt;hFile) { <br>      if(IDYES == szMessageBox(lpci-&gt;hwnd, <br>                               MB_YESNO, <br>                               (LPSTR)szOPENFILE, <br>                               GetidsString(idsCloseFile, OutStr, sizeof(OutStr)), <br>                               (LPSTR)lpci-&gt;szFile)) <br>         SendMessage(lpci-&gt;hwnd, WM_COMMAND, IDM_CLOSE, 0L); <br>      else <br>         return; <br>   } <br> <br>   // Now ask to open a file <br>   lpci-&gt;szFileBuff = (LPSTR)GetMemory(MAXFILEBUFF); <br>   if(!lpci-&gt;szFileBuff) <br>      return; <br> <br>   if(!*szDirName) <br>      GetWindowsDirectory(szDirName, sizeof(szDirName)); <br> <br>   // Fill out the struct <br>   memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>   lpci-&gt;szFile[0] = '\0'; <br>   ofn.lStructSize =          sizeof(OPENFILENAME); <br>   ofn.hwndOwner =            lpci-&gt;hwnd; <br>   ofn.lpstrFilter =          szDftFileFilter; <br>   ofn.nFilterIndex =         1; <br>   ofn.lpstrFile =            lpci-&gt;szFile; <br>   ofn.nMaxFile =             sizeof(lpci-&gt;szFile); <br>   ofn.lpstrInitialDir =      szDirName; <br>   ofn.Flags =                OFN_HIDEREADONLY | <br>      OFN_PATHMUSTEXIST | <br>         OFN_FILEMUSTEXIST; <br> <br>   // Try to open the file <br>   if(GetOpenFileName(&amp;ofn)) { <br>      if(fHwnd) <br>         SetFocus(fHwnd); <br> <br>      if(HFILE_ERROR == (lpci-&gt;hFile = _lopen(ofn.lpstrFile, OF_READ))) { <br>         szMessageBox(lpci-&gt;hwnd, <br>                      MB_ICONEXCLAMATION, <br>                      (LPSTR)szOPENFILE, <br>                      GetidsString(idsOpenFileFailed, OutStr, sizeof(OutStr)), <br>                      (LPSTR)ofn.lpstrFile); <br>         return; <br>      } <br> <br>      lpci-&gt;cbFileSize = _lread(lpci-&gt;hFile, <br>                                (void FAR *)lpci-&gt;szFileBuff, MAXFILEBUFF); <br>      _lclose(lpci-&gt;hFile); <br>      szWrite(lpci-&gt;hwndIn, (LPSTR)lpci-&gt;szFileBuff); <br>      SendMessage(lpci-&gt;hwndIn, EM_SETMODIFY, FALSE, 0L); <br>      wsprintf((LPSTR)lpci-&gt;szClientTitle, szUserAtFile, <br>               (LPSTR)lpci-&gt;CurrentUser, (LPSTR)lpci-&gt;CurrentServer, <br>               (LPSTR)ofn.lpstrFile); <br>      SetWindowText(lpci-&gt;hwnd, lpci-&gt;szClientTitle); <br>      GetNewDirectory(szDirName, ofn.lpstrFile); <br>   } <br> <br>   if(fHwnd) <br>      SetFocus(fHwnd); <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoSave: <br>//|   Save the current file. <br>//| Parms: <br>//|   lpci                    Connection window information <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>VOID WINAPI DoFileSave(lpCHILDINFO lpci) <br>{ <br>   OFSTRUCT       ofs; <br> <br>   ofs.cBytes = sizeof(OFSTRUCT); <br> <br>   lpci-&gt;cbFileSize = GetWindowText(lpci-&gt;hwndIn, <br>                                    (LPSTR)lpci-&gt;szFileBuff, MAXFILEBUFF); <br>   if(HFILE_ERROR == (lpci-&gt;hFile = <br>                      OpenFile(lpci-&gt;szFile, &amp;ofs, OF_CREATE))) { <br>      szMessageBox(lpci-&gt;hwnd, <br>                   MB_ICONEXCLAMATION, <br>                   (LPSTR)szSAVEFILE, <br>                   GetidsString(idsSaveFileFailed, OutStr, sizeof(OutStr)), <br>                   (LPSTR)lpci-&gt;szFile); <br>      return; <br>   } <br> <br>   _lwrite(lpci-&gt;hFile, (void FAR *)lpci-&gt;szFileBuff, lstrlen(lpci-&gt;szFileBuff)); <br>   _lclose(lpci-&gt;hFile); <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoFileSaveAs: <br>//|   Use the commond dialog functions to save a file. <br>//| Parms: <br>//|   lpci                    Connection window information <br>//| Returns: <br>//|   Nothing <br>//*--------------------------------------------------------------------------------- <br>VOID INTFUN DoFileSaveAs(lpCHILDINFO lpci) <br>{ <br>   OPENFILENAME         ofn; <br>   HWND                 fHwnd=GetFocus(); <br>   char                 szSaveFile[_MAX_PATH]; <br> <br>   // Fill out struct <br>   szSaveFile[0] = '\0'; <br>   memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>   ofn.lStructSize =          sizeof(OPENFILENAME); <br>   ofn.hwndOwner =            lpci-&gt;hwnd; <br>   ofn.lpstrFilter =          szDftFileFilter; <br>   ofn.nFilterIndex =         1; <br>   ofn.lpstrFile =            szSaveFile; <br>   ofn.nMaxFile =             sizeof(lpci-&gt;szFile); <br>   ofn.lpstrInitialDir =      szDirName; <br>   ofn.Flags =                OFN_HIDEREADONLY | <br>      OFN_PATHMUSTEXIST | <br>         OFN_OVERWRITEPROMPT; <br> <br> <br>   // See if user selects a file <br>   if(GetSaveFileName(&amp;ofn)) { <br>      lstrcpy(lpci-&gt;szFile, szSaveFile); <br>      wsprintf((LPSTR)lpci-&gt;szClientTitle, szUserAtFile, <br>               (LPSTR)lpci-&gt;CurrentUser, (LPSTR)lpci-&gt;CurrentServer, <br>               (LPSTR)szSaveFile); <br>      SetWindowText(lpci-&gt;hwnd, lpci-&gt;szClientTitle); <br>      DoFileSave(lpci); <br>   } <br> <br>   if(fHwnd) <br>      SetFocus(fHwnd); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
