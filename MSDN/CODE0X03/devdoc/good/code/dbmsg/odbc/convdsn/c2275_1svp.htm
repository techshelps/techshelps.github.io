<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVDSN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2275"></a>CONVDSN.C</h2>
<pre><code>/* <br>** CONVDSN.C - This is the ODBC sample code for <br>** creating File DSN pointers to machine DSNs. <br>** <br>**This code is furnished on an as-is basis as part of the ODBC SDK and is <br>**intended for example purposes only. <br>** <br>*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "sql.h" <br>#include "sqlext.h" <br>#include "odbcinst.h" <br> <br>// prototypes <br> <br>void ExpandFileName(LPSTR szFileDSNName, LPCSTR szDSNName); <br>void MakeLegalName(LPSTR szLegalDSNName, LPCSTR szDSNName); <br> <br>// main routine:  Iterate through the user and system DSNs, creating a pointer <br>//                to each. <br> <br>int _stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>   LPSTR lpszCmdLine, int nCmdShow) <br>{ <br>HENV    henv; <br>RETCODE retcode; <br>CHAR    szDSNName[SQL_MAX_DSN_LENGTH + 1]; <br>CHAR    szLegalDSNName[SQL_MAX_DSN_LENGTH + 1]; <br>CHAR    szFileDSNName[MAX_PATH + 1]; <br> <br>if(SQL_SUCCEEDED(SQLAllocHandle(SQL_HANDLE_ENV, NULL, &amp;henv))) <br>{ <br>// set the ODBC behavior version. <br>(void) SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, <br>(SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER); <br> <br>// Enumerate the user data sources. <br>retcode = SQLDataSources(henv, SQL_FETCH_FIRST_SYSTEM, szDSNName, <br>sizeof(szDSNName), NULL, NULL, 0, NULL); <br> <br>while(SQL_SUCCEEDED(retcode)) <br>{ <br>// Make a version of the name acceptable for use as a filename. <br>MakeLegalName(szLegalDSNName, szDSNName); <br> <br>// Build the full filename. <br>ExpandFileName(szFileDSNName, szLegalDSNName); <br> <br>// Write the DSN= keyword into the File DSN. <br>SQLWriteFileDSN(szFileDSNName, "ODBC", "DSN", szDSNName); <br> <br>// Do the next one, if it exists. <br>retcode = SQLDataSources(henv, SQL_FETCH_NEXT, szDSNName, <br>sizeof(szDSNName), NULL, NULL, 0, NULL); <br>} <br> <br>// Enumerate the system data sources. <br>retcode = SQLDataSources(henv, SQL_FETCH_FIRST_USER, szDSNName, <br>sizeof(szDSNName), NULL, NULL, 0, NULL); <br> <br>while(SQL_SUCCEEDED(retcode)) <br>{ <br>// Make a version of the name acceptable for use as a filename. <br>MakeLegalName(szLegalDSNName, szDSNName); <br> <br>// Build the full filename. <br>ExpandFileName(szFileDSNName, szLegalDSNName); <br> <br>// Write the DSN= keyword into the File DSN. <br>SQLWriteFileDSN(szFileDSNName, "ODBC", "DSN", szDSNName); <br> <br>// Do the next one, if it exists. <br>retcode = SQLDataSources(henv, SQL_FETCH_NEXT, szDSNName, <br>sizeof(szDSNName), NULL, NULL, 0, NULL); <br>} <br> <br>SQLFreeHandle(SQL_HANDLE_ENV, henv); <br>} <br> <br>return 0; <br>} <br> <br>// ExpandFileName:  Take the pieces of the filename, and form a complete <br>//                  filename. <br> <br>void ExpandFileName(LPSTR szFileDSNName, LPCSTR szDSNName) <br>{ <br>strcpy(szFileDSNName, szDSNName); <br> <br>// Hint that we're not sharable <br>strcat(szFileDSNName, " (not sharable)"); <br>} <br> <br>// MakeLegalName:  Make a version of the DSN name suitable for use as a  <br>//                 filename. <br> <br>void MakeLegalName(LPSTR szLegalDSNName, LPCSTR szDSNName) <br>{ <br>CHAR   szIllegalChars[] = "\\/:*?\"&lt;&gt;|"; <br>LPSTR  pchIllegalChar; <br>LPCSTR pchDSNSource     = szDSNName; <br>LPSTR  pchDSNTarget     = szLegalDSNName; <br>BOOL   fIllegal; <br> <br>while(*pchDSNSource) <br>{ <br>pchIllegalChar = szIllegalChars; <br> <br>fIllegal = FALSE; <br> <br>// if the character is double byte, copy it and move ahead <br>if(IsDBCSLeadByte(*pchDSNSource)) <br>{ <br>*(pchDSNTarget++) = *(pchDSNSource++); <br>*(pchDSNTarget++) = *(pchDSNSource++); <br>} <br>else <br>{ <br>// single byte <br>if(!isalpha(*pchDSNSource) &amp;&amp; !isdigit(*pchDSNSource)) <br>{ <br>while(*pchIllegalChar) <br>{ <br>if(*pchDSNSource == *(pchIllegalChar++)) <br>{ <br>fIllegal = TRUE; <br>break; <br>} <br>} <br>} <br> <br>if(fIllegal) <br>{ <br>pchDSNSource++; <br>} <br>else <br>{ <br>*(pchDSNTarget++) = *(pchDSNSource++); <br>} <br>} <br>} <br>*pchDSNTarget = '\0'; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
