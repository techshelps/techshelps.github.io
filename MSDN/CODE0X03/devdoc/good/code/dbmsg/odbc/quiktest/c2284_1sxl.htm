<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QUIKTEST.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2289"></a>QUIKTEST.H</h2>
<pre><code>//**************************************************************************** <br>//|   Title:   quiktest.h <br>//|  <br>//|   (c) Copyright 1991, 1992, 1993, 1994, 1995 <br>//|       by Microsoft Corp. <br>//|  <br>//****************************************************************************** <br>#ifndef quiktest_defs <br>#define quiktest_defs <br> <br> <br>/*-----------------------------------------------------------------------------------*/ <br>/*constants defines */ <br>/*-----------------------------------------------------------------------------------*/ <br>#define MAX_QUERY_SIZE2048 <br>#define MAX_BIND_ELEMENTS100 <br>#define MAX_BIND_ARRAY_ELEMENTMAX_QUERY_SIZE / MAX_BIND_ELEMENTS <br>#define MAX_STRING_SIZE350  // Increased from 255 due to overwrite <br>#define MAX_PARAM_SIZE129 <br>#define MAX_DATA_SIZE45 <br>#define MAX_COLUMN_LIST_SIZE200 <br>#define MAX_COLUMN_NAME_SIZE100 <br>#define MAX_INSERT_VALUES_SIZE200 <br>#define MAX_TYPES_SUPPORTED25 <br>#define MAX_TYPE_NAME129 <br>#define MAX_FIELD40 <br>#define MAX_PREFIX129 <br>#define MAX_SUFFIX129 <br>#define MAX_TABLE_NAME60 <br>#define MAX_NUM_BUFFER60 <br>#define MAX_ERROR_SIZE200 <br>#define MAX_ROW_ITEM_LIMIT4 <br> <br>#define PREFIX_SIZE3 <br>#define IGNORED999 <br>#define TEST_CONNECT_OPTION15 <br>#define TEST_STMT_OPTION300 <br>#define SCALEDIFF4 <br>#define ABORT-1 <br>#define TYPE_PORTION4 <br>#define MAXUDWORD((UDWORD)(-1)) <br>#define MINSDWORD(-(SDWORD)((MAXUDWORD / 2) + 1)) <br>#define MAXSDWORD((SDWORD)(MAXUDWORD / 2)) <br> <br>#define SMALLBUFF100 <br>#define MEDBUFF200 <br>#define LARGEBUFF300 <br>#define XLARGEBUFF1024 <br>#define STATE_SIZE6 <br>#define COMBINED_SIZEMAX_ERROR_SIZE + 30 <br> <br>// Descriptor type defines <br>#define DESC_NONE0// No descriptor type <br>#define DESC_APD1// APD only <br>#define DESC_IPD2// IPD only <br>#define DESC_ARD4// ARD only <br>#define DESC_IRD8// IRD only <br>#define DESC_PDDESC_APD|DESC_IPD//Parameter descriptors <br>#define DESC_RDDESC_ARD|DESC_IRD// Row descriptors <br>#define DESC_IDDESC_IPD|DESC_IRD// Implementation descriptors <br>#define DESC_ADDESC_APD|DESC_ARD// Application descriptors <br>#define DESC_MOSTDESC_AD|DESC_IPD// This is the most common settable combination <br>#define DESC_ALLDESC_APD|DESC_IPD|DESC_ARD|DESC_IRD// All descriptor types <br> <br>#define STATUS_ARRAY_SIZE5// Array size to use for row and param arrays <br>#define BIND_SIZE12// Bind type size value <br> <br>/* NUM_THREAD is the number of threads that will be created for multi-thread test */ <br>#define NUM_THREAD5 <br>#define NUM_QUIKREBIND_ROWSETS6 <br> <br>/* BIND_PARM_OFFSET specifies the parameter base for DAE bindings. Either 0 */ <br>/* or 1 based.  */ <br>#define BIND_PARM_OFFSET0 <br> <br>// COLNAME_START specifies the beginning number used in colnames, i.e. c00bit  <br>// vs. c01bit. <br>#define COLNAME_START1 <br> <br>/*constants for Descriptor tests */ <br>#define MAX_DESC_BUF200 <br>#define DESC_UPDATE_MODE_READ0 <br>#define DESC_UPDATE_MODE_WRITE1 <br>#define REC_COUNT_UNK-1// Unkown record count <br>// #define DESC_LOCATE_FAIL-1 <br> <br>/* constants for TestBindParam */ <br>#define INSERT_FAIL  -1 <br> <br>#define UNTOUCHED 0xCA <br> <br>/*------------------------------------------------------------------------------------*/ <br>/*macros                                                                             */ <br>/*------------------------------------------------------------------------------------*/ <br> <br>#define RC_SUCCESSFUL(rc)((rc) == SQL_SUCCESS || \ <br>    (rc) == SQL_SUCCESS_WITH_INFO) <br> <br>#define RC_NOTSUCCESSFUL(rc) (!(RC_SUCCESSFUL(rc))) <br> <br>#define RETCHECK(exp, rec, buf) ReturnCheck(exp, rec, buf, TEXT(__FILE__), __LINE__,FALSE) <br> <br>#define ERRSHANDLE(type, handle, exp, rec, buf) ErrsHandle(type, handle, exp, rec, buf, TEXT(__FILE__), __LINE__,FALSE) <br> <br>#define DIAGRETCHECK(exp, rec, buf) ReturnCheck(exp, rec, buf, TEXT(__FILE__), __LINE__,TRUE) <br> <br>#define DISPLAYERROR(func, string) qtDisplayError(func, string, TEXT(__FILE__), __LINE__) <br> <br>/*--------------------------------------------------------------------------------------*/ <br>/*Structure definitions    */ <br>/*--------------------------------------------------------------------------------------*/ <br> <br>/* Number of Cols in result set of a query: */ <br>UWORD cNumResSetCols; <br> <br>/* used to store information from GetTypeInfo for table creation */ <br>typedef struct FieldInfo { <br>int iField; <br>TCHAR szType[MAX_TYPE_NAME]; <br>TCHAR szFieldName[MAX_FIELD]; <br>SWORD  wSQLType; <br>TCHAR szParams[MAX_PARAM_SIZE]; <br>TCHAR szLength[MAX_FIELD]; <br>TCHAR szPrefix[MAX_PREFIX]; <br>TCHAR szSuffix[MAX_SUFFIX]; <br>SDWORD precision; <br>SWORD scale; <br>SWORD nullable; <br>UDWORD length; <br>int   fAutoUpdate; <br>SWORD fSearchable; <br>SDWORD fUnsigned; <br>SWORD autoinc; <br>} FIELDINFO; <br> <br> <br> <br>/* large buffers allocated as a global used for queries and other*/ <br>/* returned information                                          */ <br>typedef struct  tagQtStruct { <br>TCHARbuf[MAX_STRING_SIZE]; <br>TCHARsz[MAX_QUERY_SIZE]; <br>TCHARszParamQuery[MAX_QUERY_SIZE]; <br>TCHARszParam[MAX_PARAM_SIZE]; <br>TCHARszDataItem[MAX_DATA_SIZE]; <br>TCHARszTableName[MAX_TABLE_NAME]; <br>TCHARszColNames[MAX_COLUMN_LIST_SIZE]; <br>TCHARszColName[MAX_COLUMN_NAME_SIZE]; <br>TCHARszValues[MAX_INSERT_VALUES_SIZE]; <br>}       QTSTRUCT; <br> <br>/* the storage used for data retreived using bind/fetch sequence  */ <br>/* and data for BindParameter                                     */ <br>/* only cb and one of the types will be used for each entry       */ <br>typedef struct tagDataStruct { <br>SDWORD cb; <br>TCHAR data[MAX_STRING_SIZE]; <br>SDWORD sdword; <br>UDWORD udword; <br>SWORD sword; <br>UWORD uword; <br>TCHARsChar; <br>SQLTCHAR uChar; <br>SDOUBLE sdouble; <br>SFLOAT sfloat; <br>TIME_STRUCT time; <br>DATE_STRUCT date; <br>TIMESTAMP_STRUCT timestamp; <br>} DSTRUCT; <br> <br>/* These declarations used to reside locally, but the structures didn't get initialized correctly */ <br>typedef struct SupportOptList { <br>UDWORD Support; <br>SDWORD Option; <br>} SUPPORTOPTINFO; <br> <br>typedef struct SupportConcurList { <br>UDWORD Support; <br>UWORD Option; <br>} SUPPORTCONCURINFO; <br> <br> <br> <br>/* Each thread will contain the following information */ <br>typedef struct { <br>HENVhenv; <br>HDBChdbc; <br>TCHARszTableName[MAX_TABLE_NAME]; <br>FIELDINFO rgFieldInfo; <br> <br>} THREAD_STRUCT; <br> <br> <br>static union <br>{ <br>BYTE rgb[max(max(max(sizeof (HENV),sizeof (HDBC)), <br>max(sizeof (HSTMT), sizeof (SQLHDESC))),sizeof (UDWORD))]; <br>SWORD sw; <br>UWORD uw; <br>SDWORD sdw; <br>UDWORD udw; <br>HENV henv; <br>HDBC hdbc; <br>HSTMT hstmt; <br>SQLHDESC hdesc; <br>} Untouched = {UNTOUCHED, UNTOUCHED, UNTOUCHED, UNTOUCHED}; <br>  <br> <br> <br>int  PASCAL ReturnCheck(RETCODE retExpected, RETCODE retReceived, LPTSTR szFunction,  <br>LPTSTR szFile, int iLine,BOOL fDiag); <br>void PASCAL qtDisplayError(LPTSTR szFunction, LPTSTR buf, LPTSTR szFile, int iLine); <br>LPTSTR PASCAL qtMakeData(int row, int col,FIELDINFO * rgField, LPTSTR buf); <br> <br>BOOL PASCAL CmpODBCtoCHAR(DSTRUCT * rgTestValue, TCHAR * szTrueValue, <br>SWORD fSqlType, SWORD iResSetCol); <br> <br>void* PASCAL CvtCHARtoODBC(void * odbcValue, TCHAR * buf, SWORD fSqlType) <br>{ <br>if(!buf) <br>return NULL; <br> <br>switch (fSqlType) { <br>case SQL_DATE:  <br>case SQL_TYPE_DATE:  <br>{ <br>TCHAR szDATEDELIM[] = TEXT("d{}'- "); <br>TCHAR szTempBuff[30]; <br>LPTSTR   tmpstr=szTempBuff; <br>_tcscpy((LPTSTR) szTempBuff, buf); <br> <br>((DATE_STRUCT *)odbcValue)-&gt;year = _ttoi(_tcstok(tmpstr, szDATEDELIM)); <br>((DATE_STRUCT *)odbcValue)-&gt;month = _ttoi(_tcstok(NULL, szDATEDELIM)); <br>((DATE_STRUCT *)odbcValue)-&gt;day = _ttoi(_tcstok(NULL, szDATEDELIM)); <br>break; <br>} <br> <br> <br>case SQL_TIME:  <br>case SQL_TYPE_TIME:  <br>{ <br>TCHAR szTIMEDELIM[] = TEXT("t{}': "); <br>TCHAR szTempBuff[30]; <br>LPTSTR   tmpstr=szTempBuff; <br>_tcscpy((LPTSTR) szTempBuff, buf); <br> <br>((TIME_STRUCT *)odbcValue)-&gt;hour = _ttoi(_tcstok(tmpstr, szTIMEDELIM)); <br>((TIME_STRUCT *)odbcValue)-&gt;minute = _ttoi(_tcstok(NULL, szTIMEDELIM)); <br>((TIME_STRUCT *)odbcValue)-&gt;second = _ttoi(_tcstok(NULL, szTIMEDELIM)); <br> <br>break; <br>} <br> <br>case SQL_TIMESTAMP: <br>case SQL_TYPE_TIMESTAMP: <br>{ <br>TCHAR szDATETIMEDELIM[] = TEXT("ts'{}-:. "); <br>TCHAR szTempBuff[30]; <br>LPTSTR   tmpstr=szTempBuff; <br>LPTSTRendstr, frstr; <br>_tcscpy((LPTSTR) szTempBuff, buf); <br> <br>/* First the date */ <br>((TIMESTAMP_STRUCT *)odbcValue)-&gt;year = _ttoi(_tcstok(tmpstr, szDATETIMEDELIM)); <br>((TIMESTAMP_STRUCT *)odbcValue)-&gt;month = _ttoi(_tcstok(NULL, szDATETIMEDELIM)); <br>((TIMESTAMP_STRUCT *)odbcValue)-&gt;day = _ttoi(_tcstok(NULL, szDATETIMEDELIM)); <br>/* Then the complete time */ <br>((TIMESTAMP_STRUCT *)odbcValue)-&gt;hour = _ttoi(_tcstok(NULL, szDATETIMEDELIM)); <br>((TIMESTAMP_STRUCT *)odbcValue)-&gt;minute = _ttoi(_tcstok(NULL, szDATETIMEDELIM)); <br>((TIMESTAMP_STRUCT *)odbcValue)-&gt;second = _ttoi(_tcstok(NULL, szDATETIMEDELIM)); <br>if(frstr = _tcstok(NULL, szDATETIMEDELIM)) <br>((TIMESTAMP_STRUCT *)odbcValue)-&gt;fraction = (_tcstoul(frstr, &amp;endstr, 10) * 1000000); <br>else <br>((TIMESTAMP_STRUCT *)odbcValue)-&gt;fraction = 0; <br> <br>break; <br>} <br> <br>} <br>return odbcValue; <br>} <br> <br> <br>/* Compares the value stored at location (row,col) in the array of  <br> * DSTRUCT's with the value created by qtMakeData*/ <br>BOOL PASCAL CmpODBCtoCHAR(DSTRUCT * rgTestValue, TCHAR * szTrueValue, <br>SWORD fSqlType, SWORD iCol) <br>{ <br>BOOL fTestPass=TRUE; <br>SWORD test1,test2; <br>TCHAR*pStop=NULL; <br> <br>switch (fSqlType) { <br>case SQL_BIGINT: <br>case SQL_INTEGER: <br>if(_ttoi(szTrueValue) == (int)rgTestValue[iCol].sdword)  <br>return TRUE; <br>return FALSE; <br> <br>case SQL_DECIMAL: <br>case SQL_NUMERIC: <br>return  (_tcstod(szTrueValue,&amp;pStop) ==  <br>(float)_tcstod(rgTestValue[iCol].data,&amp;pStop)); <br>case SQL_TINYINT: <br>case SQL_SMALLINT: <br>if(_ttoi(szTrueValue) == (int)rgTestValue[iCol].sword) <br>return TRUE; <br>return FALSE; <br> <br>case SQL_FLOAT: <br>case SQL_DOUBLE:  <br>return  (_tcstod(szTrueValue,&amp;pStop) == (float)rgTestValue[iCol].sdouble); <br> <br>case SQL_REAL: <br>/* Need to account for round-off errors in _tcstod conversions: */ <br>test1 = (SWORD)(1000*_tcstod(szTrueValue,&amp;pStop)); <br>test1 = (SWORD)((test1&gt;0) ? (test1+5)/10 : (test1-5)/10); <br>test2 = (SWORD)(1000*rgTestValue[iCol].sfloat); <br>test2 = (SWORD)((test2&gt;0) ? (test2+5)/10 : (test2-5)/10); <br>return  (test1 == test2); <br> <br>case SQL_TIMESTAMP:  <br>case SQL_TYPE_TIMESTAMP:  <br>{ <br>TIMESTAMP_STRUCT tss; <br>CvtCHARtoODBC(&amp;tss, szTrueValue, SQL_TYPE_TIMESTAMP); <br> <br>fTestPass= ((rgTestValue[iCol].timestamp.month == tss.month) <br>&amp;&amp; (rgTestValue[iCol].timestamp.day == tss.day) <br>&amp;&amp; (rgTestValue[iCol].timestamp.year == tss.year) <br>&amp;&amp; (rgTestValue[iCol].timestamp.hour == tss.hour) <br>&amp;&amp; (rgTestValue[iCol].timestamp.minute == tss.minute) <br>&amp;&amp; (rgTestValue[iCol].timestamp.fraction == <br>tss.fraction)); <br>/* Seconds value is zero for small timestamp, so to keep it from always failing... */ <br>if(0 != rgTestValue[iCol].timestamp.second) <br>fTestPass= (fTestPass &amp;&amp; rgTestValue[iCol].timestamp.second == tss.second); <br>return fTestPass; <br>} <br> <br>case SQL_TIME:  <br>case SQL_TYPE_TIME:  <br>{ <br>TIME_STRUCT tss; <br> <br>CvtCHARtoODBC(&amp;tss, szTrueValue, SQL_TYPE_TIME); <br>fTestPass=  ((rgTestValue[iCol].time.hour == tss.hour) <br>&amp;&amp; (rgTestValue[iCol].time.minute == tss.minute)); <br>/* Seconds value is zero for small timestamp, so to keep it from always failing... */ <br>if(0 != rgTestValue[iCol].time.second) <br>fTestPass= (fTestPass &amp;&amp; rgTestValue[iCol].time.second == tss.second); <br>return fTestPass; <br>} <br> <br>case SQL_DATE:  <br>case SQL_TYPE_DATE:  <br>{ <br>DATE_STRUCT tss; <br>CvtCHARtoODBC(&amp;tss, szTrueValue, SQL_TYPE_DATE); <br> <br>return ((rgTestValue[iCol].date.month == tss.month) <br>&amp;&amp; (rgTestValue[iCol].date.day == tss.day) <br>&amp;&amp; (rgTestValue[iCol].date.year == tss.year)); <br>} <br> <br> case SQL_BIT:  <br> case SQL_CHAR:  <br>case SQL_VARCHAR: <br>case SQL_LONGVARCHAR: <br>case SQL_BINARY:   <br>case SQL_VARBINARY:   <br>case SQL_LONGVARBINARY:  <br>default: <br>return !(_tcsncmp(szTrueValue, rgTestValue[iCol].data,  <br>_tcslen(szTrueValue))); <br> <br>} <br>} <br> <br> <br>#endif  <br> <br> <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
