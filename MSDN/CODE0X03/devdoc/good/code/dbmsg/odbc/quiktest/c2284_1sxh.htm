<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CUSTOM.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2285"></a>CUSTOM.C</h2>
<pre><code>//*--------------------------------------------------------------------------------- <br>//| Custom Auto Test DLL <br>//| <br>//| Title:CUSTOM.C <br>//| <br>//| Purpose: <br>//|This sample Auto Test DLL shows how an ODBC auto test may be written and <br>//|subsequently run via the ODBC Test application.  To use this DLL: <br>//|1) Compile the source code via the BUILD.EXE program <br>//|CUSTOM.CThis shource file with test code <br>//|CUSTOM.HInclude files with defines, macros, and prototypes <br>//|CUSTOM.RCResource file for string tables <br>//|(Note that .H and .RC files are optional in for an Auto Test) <br>//|2) Start the ODBC Test application <br>//|3) If you have not done so, choose Tools, Manage Test Sources and define <br>//|a test source to run against <br>//|4) Choose Tools, Manage Tests and add the CUSTOM.DLL created in step 1 <br>//|to the list of installed test DLLs <br>//|5) Choose Tools, Run Tests and select "Custom Auto Test" and your Test Source <br>//|from step #3 <br>//|For more details, please see the SDK documentation. <br>//*--------------------------------------------------------------------------------- <br>#include "autotest.h" <br>#include "custom.h" <br> <br> <br>//---------------------------------------------------------------------------------- <br>//Defines and macros <br>//---------------------------------------------------------------------------------- <br>typedef SWORD (FAR PASCAL *TESTCASEFUNC)(HENV FAR *, HDBC FAR *, HSTMT FAR *, lpSERVERINFO); <br> <br>#define CHECKTEST(lps, exprc, actrc, func) \ <br>{                                                  \ <br>if(!CheckTest(lps, exprc, actrc, (LPSTR)func))  \ <br>return TEST_ABORTED;                         \ <br>} <br>#define CHECKERRS(sErr)\ <br>if(!sErr) szLogPrintf(lpSrvr, FALSE, "\t\tPassed\r\n\r\n"); \ <br>else szLogPrintf(lpSrvr, FALSE, "\t\t%d errors\r\n\r\n", sErr); <br> <br> <br> <br>//---------------------------------------------------------------------------------- <br>//Local function prototypes <br>//---------------------------------------------------------------------------------- <br>SWORD FAR PASCAL DoHelloWorld(HENV FAR * phenv, HDBC FAR * phdbc, <br>HSTMT FAR * phstmt, lpSERVERINFO lpSrvr); <br>SWORD FAR PASCAL DoDisplayInfoDesc(HENV FAR * phenv, HDBC FAR * phdbc, <br>HSTMT FAR * phstmt, lpSERVERINFO lpSrvr); <br>SWORD FAR PASCAL DoSimpleConnect(HENV FAR * phenv, HDBC FAR * phdbc, <br>HSTMT FAR * phstmt, lpSERVERINFO lpSrvr); <br>BOOL FAR PASCAL CheckTest(lpSERVERINFO lps, RETCODE exprc, RETCODE actrc, <br>LPSTRszFuncName); <br> <br> <br>// <br>// This structure is declared to describe the test cases and descriptions <br>//that this auto test supports.  Note that the strings are stored in <br>//the resource fork, but could have been hard coded. <br>// <br>struct { <br>UINTuiName;// Test case name <br>UINTuiDesc;// Test case description <br>TESTCASEFUNClpTestFunc;// Pointer to function to implement test <br>} TestCases[] = { <br>// szNameszDesclpTestFunc <br>// ------------------------------------------------------------------- <br>idsHelloWorld,idsHelloWorldDesc,DoHelloWorld, <br>idsDisplayInfo,idsDisplayInfoDesc,DoDisplayInfoDesc, <br>idsSimpleConnect,idsSimpleConnectDesc,DoSimpleConnect, <br>}; <br> <br> <br> <br>//************************************************************************** <br>//***************************  External Interfaces  ************************ <br>//*  These functions are called by ODBC Test to gather run-time information <br>//************************************************************************** <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| AutoTestName: <br>//|This function is called to give the name of the auto test (which cannot <br>//|exceed AUTO_MAX_TEST_NAME) as well as the number of test cases which <br>//|are implemented in this test DLL. <br>//| Parms: <br>//|szNameThe name to be displayed <br>//|pcbTestCasesPointer to count of test cases <br>//| Returns: <br>//|TRUE if successful (pcbTestCases set), FALSE for error <br>//*--------------------------------------------------------------------------------- <br>BOOL EXTFUN AutoTestName(LPSTR szName, UINT FAR * pcbTestCases) <br>{ <br>GetRCString(hLoadedInst, szName, AUTO_MAX_TEST_NAME, idsTestName); <br>*pcbTestCases = NumItems(TestCases); <br> <br>   return TRUE; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| AutoTestDesc: <br>//|This function is called by ODBC Test when a description of a specific <br>//|test case is required.  The returned name must be no larger than <br>//|AUTO_MAX_TESTCASE_NAME including the NULL terminator.  The returned <br>//|description must be no larger than AUTO_MAX_TESTDESC_NAME including the <br>//|NULL.  iTest will be 1-based index of the test required. <br>//| <br>//|Note that iTest will start at 1 and will go to the number of <br>//|test cases as specified by the AutoTestName function. <br>//| <br>//| Parms: <br>//|iTest1-based index of test case required <br>//|szNameThe name of the test case <br>//|szDescA description of the test case <br>//| Returns: <br>//|TRUE if successful, FALSE for error <br>//*--------------------------------------------------------------------------------- <br>BOOL EXTFUN AutoTestDesc(UWORD iTest, LPSTR szName, LPSTR szDesc) <br>{ <br>// Extra protection should AutoTestName return invalid pcbTestCases <br>if(iTest &gt; NumItems(TestCases)) <br>return FALSE; <br> <br>// Use GetRCString to retrieve resource string directly into return <br>//values <br>GetRCString(hLoadedInst, szName,  <br>AUTO_MAX_TESTCASE_NAME, TestCases[(iTest-1)].uiName); <br>GetRCString(hLoadedInst, szDesc,  <br>AUTO_MAX_TESTDESC_NAME, TestCases[(iTest-1)].uiDesc); <br> <br>   return TRUE; <br>} <br>  <br>  <br>//*--------------------------------------------------------------------------------- <br>//| AutoTestFunc: <br>//|This function is called to execute a test case selected by the user for <br>//|execution.  The lpSrvr structure contains the information required for <br>//|connected (as defined in the chosen Test Source), as well as other <br>//|usefull information.  See the AUTOTEST.H file for the structure <br>//|declaration. <br>//| <br>//|Use the GETBIT macro to determine which test should be executed. <br>//| <br>//| Parms: <br>//|lpSrvrInformation required for running the test <br>//| Returns: <br>//|Nothing <br>//*--------------------------------------------------------------------------------- <br>void EXTFUN AutoTestFunc(lpSERVERINFO lpSrvr) <br>{ <br>HENV henv=NULL; <br>HDBC hdbc=NULL; <br>HSTMT hstmt0=NULL; <br>intiDex; <br>SWORDcErrCnt;// Count errors <br>charszName[AUTO_MAX_TESTCASE_NAME+6];// Room for NULL and \r\n <br> <br> <br>// Sets the error count to 0 <br>InitTest(lpSrvr); <br> <br>// Loop through the count of test cases looking for set bits via GETBIT. <br>//When a bit is set, that test is to be run.  We've stored the <br>//function address which will implement the test, so simply call it. <br>for(iDex=1;  iDex&lt;=NumItems(TestCases);  iDex++) <br>if(GETBIT(lpSrvr-&gt;rglMask, iDex)) { <br>// Print out title of test <br>GetRCString(hLoadedInst, szName,  <br>AUTO_MAX_TESTCASE_NAME, TestCases[(iDex-1)].uiName); <br>szLogPrintf(lpSrvr, FALSE, "%s:\r\n", (LPSTR)szName); <br> <br>// Call the test case and add errors <br>cErrCnt =  <br>(*TestCases[(iDex-1)].lpTestFunc)(&amp;henv, &amp;hdbc, &amp;hstmt0, lpSrvr); <br>if(cErrCnt != TEST_ABORTED) <br>lpSrvr-&gt;cErrors += cErrCnt; <br>else <br>goto abort; <br>} <br>return; <br> <br> <br>// When a test must abort, the test case should call the AbortTest <br>//macro which sets lpSrvr-&gt;cErrors to TEST_ABORTED. <br>abort: <br>return; <br>} <br>  <br> <br> <br> <br> <br> <br>//************************************************************************** <br>//*****************************  Test Cases  ******************************* <br>//*  The following functions implement the tests <br>//************************************************************************** <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoHelloWord: <br>//|This is a simple test which uses the szLogPrintf and szMessageBox <br>//|functions defined in GATORTST.DLL. <br>//| <br>//|Note that this test also simulates an error by returning a count <br>//|of 1.  This value is then totaled by ODBC Test and displayed as <br>//|part of the grand total. <br>//| <br>//| Returns: <br>//|Number of Errors or TEST_ABORTED <br>//*--------------------------------------------------------------------------------- <br>SWORD FAR PASCAL DoHelloWorld(HENV FAR * phenv, HDBC FAR * phdbc, <br>HSTMT FAR * phstmt, lpSERVERINFO lpSrvr) <br>{ <br>SWORDsErr=1;// Pretend there was 1 error <br> <br>// The szMessageBox function will display a formatted message via the <br>//Windows MessageBox function.  This function should not be used <br>//for standard testing since a good test will run unattended. <br>szMessageBox(lpSrvr-&gt;hwnd,  <br>MB_ICONINFORMATION | MB_OK, <br>"Hello World", <br>"This is a sample message."); <br> <br>// The szLogPrintf function is preferred for output operations.  It will <br>//format your string using wvsprintf (which has a limit of 2000 characters) <br>//and log the result both to the output window and to a file per <br>//user instructions. <br>szLogPrintf(lpSrvr, FALSE, "\tHello World!!\r\n"); <br> <br> <br>// check for errors <br>CHECKERRS(sErr); <br> <br> <br>return sErr; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoDisplayInfoDesc: <br>//|This test case will use the szLogPrintf function to dump the contents <br>//|of the lpSrvr structure. <br>//| <br>//| Returns: <br>//|Number of Errors or TEST_ABORTED <br>//*--------------------------------------------------------------------------------- <br>SWORD FAR PASCAL DoDisplayInfoDesc(HENV FAR * phenv, HDBC FAR * phdbc, <br>HSTMT FAR * phstmt, lpSERVERINFO lpSrvr) <br>{ <br>SWORDsErr=0; <br> <br>#ifndef WIN32 <br>#define szAddress "%04X:%04X\r\n" <br>#else <br>#define szAddress "%08X\r\n" <br>#endif <br> <br>// The hwnd parameter is the window of style "edit" which is used for output. <br>//The szLogFile parameter is used for file logging of output. <br>szLogPrintf(lpSrvr, FALSE, <br>"\thwnd:\t\t\t\t\t\t\t%04X\r\n", lpSrvr-&gt;hwnd); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tszLogFile:\t\t\t\t%s\r\n", (LPSTR)lpSrvr-&gt;szLogFile); <br> <br>// Print out address information.  Note that szAddress is conditionaly compiled <br>//to handle 16 and 32-bit.  It will be concatenated to the format string <br>//by the compiler to create a file platform correct string. <br>szLogPrintf(lpSrvr, FALSE, <br>"\thenv:\t\t\t\t\t\t\t" szAddress,  <br>#ifndef WIN32 <br>HIWORD(lpSrvr-&gt;henv), LOWORD(lpSrvr-&gt;henv)); <br>#else <br>lpSrvr-&gt;henv); <br>#endif <br>szLogPrintf(lpSrvr, FALSE, <br>"\thdbc:\t\t\t\t\t\t\t" szAddress,  <br>#ifndef WIN32 <br>HIWORD(lpSrvr-&gt;hdbc), LOWORD(lpSrvr-&gt;hdbc)); <br>#else <br>lpSrvr-&gt;hdbc); <br>#endif <br>szLogPrintf(lpSrvr, FALSE, <br>"\thstmt:\t\t\t\t\t\t\t" szAddress,  <br>#ifndef WIN32 <br>HIWORD(lpSrvr-&gt;hstmt), LOWORD(lpSrvr-&gt;hstmt)); <br>#else <br>lpSrvr-&gt;hstmt); <br>#endif <br> <br> <br>// The following are defined via the Tools, Manage Test Sources dialog in <br>//the ODBC Test application. <br>szLogPrintf(lpSrvr, FALSE, <br>"\tszSource:\t\t\t\t\t%s\r\n", (LPSTR)lpSrvr-&gt;szSource); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tszValidServer0:\t\t\t\t\t\t%s\r\n", (LPSTR)lpSrvr-&gt;szValidServer0); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tszValidLogin0:\t\t\t\t\t\t%s\r\n", (LPSTR)lpSrvr-&gt;szValidLogin0); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tszValidPassword0:\t\t\t%s\r\n", (LPSTR)lpSrvr-&gt;szValidPassword0); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tszKeywords:\t\t\t%s\r\n", (LPSTR)lpSrvr-&gt;szKeywords); <br> <br>// The following elements describe the run-time environment <br>szLogPrintf(lpSrvr, FALSE, <br>"\tcErrors:\t\t\t\t\t\t%d\r\n", (LPSTR)lpSrvr-&gt;cErrors); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tfDebug:\t\t\t\t\t\t%d\r\n", (LPSTR)lpSrvr-&gt;fDebug); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tfScreen:\t\t\t\t\t\t%d\r\n", (LPSTR)lpSrvr-&gt;fScreen); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tfLog:\t\t\t\t\t\t\t\t%d\r\n", (LPSTR)lpSrvr-&gt;fLog); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tfIsolate:\t\t\t\t\t\t%d\r\n", (LPSTR)lpSrvr-&gt;fIsolate); <br>szLogPrintf(lpSrvr, FALSE, <br>"\tvCursorLib:\t\t\t\t%lu\r\n", (LPSTR)lpSrvr-&gt;vCursorLib); <br>szLogPrintf(lpSrvr, FALSE, <br>"\thLoadedInst:\t\t\t%04X\r\n", (LPSTR)lpSrvr-&gt;hLoadedInst); <br> <br>// check for errors <br>CHECKERRS(sErr); <br> <br>return sErr; <br>} <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| DoSimpleConnect: <br>//|This test case will use the information in SERVERINFO to make a connection <br>//|to the chosen test source. <br>//| <br>//| Returns: <br>//|Number of Errors or TEST_ABORTED <br>//*--------------------------------------------------------------------------------- <br>SWORD FAR PASCAL DoSimpleConnect(HENV FAR * phenv, HDBC FAR * phdbc, <br>HSTMT FAR * phstmt, lpSERVERINFO lpSrvr) <br>{ <br>RETCODErc; <br>SWORDsErr=0; <br> <br>// This test will assume that the ODBC handles passed in <br>//are NULL.  One could have this function do a connection <br>//and pass the handles to other test functions. <br>rc = SQLAllocEnv(phenv); <br>CHECKTEST(lpSrvr, SQL_SUCCESS, rc, "SQLAllocEnv"); <br> <br>rc = SQLAllocConnect(*phenv, phdbc); <br>CHECKTEST(lpSrvr, SQL_SUCCESS, rc, "SQLAllocConnect"); <br> <br>rc = SQLConnect(*phdbc, lpSrvr-&gt;szValidServer0, SQL_NTS, <br>lpSrvr-&gt;szValidLogin0, SQL_NTS, <br>lpSrvr-&gt;szValidPassword0, SQL_NTS); <br>CHECKTEST(lpSrvr, <br>(RETCODE)((rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) <br>? rc : SQL_SUCCESS), <br>rc, "SQLConnect"); <br> <br>rc = SQLAllocStmt(*phdbc, phstmt); <br>CHECKTEST(lpSrvr, SQL_SUCCESS, rc, "SQLAllocStmt"); <br> <br>rc = SQLFreeStmt(*phstmt, SQL_DROP); <br>CHECKTEST(lpSrvr, SQL_SUCCESS, rc, "SQLFreeStmt"); <br> <br>rc = SQLDisconnect(*phdbc); <br>CHECKTEST(lpSrvr, SQL_SUCCESS, rc, "SQLDisconnect"); <br> <br>rc = SQLFreeConnect(*phdbc); <br>CHECKTEST(lpSrvr, SQL_SUCCESS, rc, "SQLFreeConnect"); <br> <br>rc = SQLFreeEnv(*phenv); <br>CHECKTEST(lpSrvr, SQL_SUCCESS, rc, "SQLFreeEnv"); <br> <br> <br>// check for errors <br>CHECKERRS(sErr); <br> <br> <br>return sErr; <br>} <br> <br>  <br>  <br>  <br> <br> <br> <br> <br> <br>//************************************************************************** <br>//*************************  Utility Functions  **************************** <br>//*  This section contains internal utility functions <br>//************************************************************************** <br> <br> <br> <br> <br>//*--------------------------------------------------------------------------------- <br>//| CheckTest: <br>//|This function will do a simple comparison of return codes and issue <br>//|erros on failure.  Use the CHECKTEST macro to invoke. <br>//| <br>//| Returns: <br>//|TRUE if the codes match, FALSE on error <br>//*--------------------------------------------------------------------------------- <br>BOOL FAR PASCAL CheckTest(lpSERVERINFO lps, RETCODE exprc, RETCODE actrc, <br>LPSTRszFuncName) <br>{ <br>if(exprc != actrc) { <br>szLogPrintf(lps, FALSE, "\t%s failed:\r\n", (LPSTR)szFuncName); <br>szLogPrintf(lps, FALSE, "\t\tExpected: %d\r\n", exprc); <br>szLogPrintf(lps, FALSE, "\t\tActual:   %d\r\n", actrc); <br>return FALSE; <br>} <br>else <br>return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
