<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QUIKTEST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2288"></a>QUIKTEST.C</h2>
<pre><code>//--------------------------------------------------------------------------------------- <br>// <br>// PROGRAM: quiktest.c <br>//        This code is furnished on an as-is basis as part of the ODBC SDK and is <br>//        intended for example purposes only. <br>// <br>//  PURPOSE: This is a Quick Test of the basic functionality of an ODBC driver. <br>// <br>//  FUNCTIONS: <br>//     QuickTest() - performs the quick test focusing on basic functionalities. <br>// <br>//-------------------------------------------------------------------------------------------- <br>#pragma warning (disable : 4703) <br> <br>#define QUIKTEST <br> <br>#include "autotest.h" <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;wchar.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;time.h&gt; <br>// #include &lt;crtdbg.h&gt; <br>#include "sql.h" <br>#include "sqlext.h" <br>#include "quiktest.h" <br> <br>//-------------------------------------------------------------------------------------- <br>//  static <br>//-------------------------------------------------------------------------------------- <br>static TCHAR  vszFile[]= TEXT(__FILE__); <br> <br>static LPTSTR sz07009= TEXT("07009"); <br>static LPTSTR szIM001= TEXT("IM001"); <br>static LPTSTR szHYC00= TEXT("HYC00"); <br>static LPTSTR szHY009= TEXT("HY009"); <br>static LPTSTR szHY091= TEXT("HY091"); <br>static LPTSTR szHY092= TEXT("HY092"); <br>static LPTSTR szISO= TEXT("ISO 9075"); <br>static LPTSTR szODBC30= TEXT("ODBC 3.0"); <br>static LPTSTR szNotSupported= TEXT("did not return Not supported message"); <br>static LPTSTR szSQLSETCONNECTATTR= TEXT("SQLSetConnectAttr"); <br>static LPTSTR szSQLGETCONNECTATTR= TEXT("SQLGetConnecTAttr"); <br>static LPTSTR szSQLGETINFO= TEXT("SQLGetInfo"); <br>static LPTSTR szSQLGETTYPEINFO= TEXT("SQLGetTypeInfo"); <br>static LPTSTR szSQLALLOCHANDLE= TEXT("SQLAllocHandle"); <br>static LPTSTR szSQLALLOCSTMT= TEXT("SQLAllocStmt"); <br>static LPTSTR szSQLALLOCCONNECT= TEXT("SQLAllocConnect"); <br>static LPTSTR szSQLALLOCENV= TEXT("SQLAllocEnv"); <br>static LPTSTR szSQLSETSTMTATTR= TEXT("SQLSetStmtAttr"); <br>static LPTSTR szSQLGETSTMTATTR= TEXT("SQLGetStmtAttr"); <br>static LPTSTR szSQLSETSTMTOPTION= TEXT("SQLSetStmtOption"); <br>static LPTSTR szSQLGETSTMTOPTION= TEXT("SQLGetStmtOption"); <br>static LPTSTR szSQLSETCONNECTOPTION= TEXT("SQLSetConnectOption"); <br>static LPTSTR szSQLGETCONNECTOPTION= TEXT("SQLGetConnectOption"); <br>static LPTSTR szSQLFETCH= TEXT("SQLFetch"); <br>static LPTSTR szSQLBINDCOL= TEXT("SQLBindCol"); <br>static LPTSTR szSQLFOREIGNKEYS= TEXT("SQLForeignkeys"); <br>static LPTSTR szSQLFREEHANDLE= TEXT("SQLFreeHandle"); <br>static LPTSTR szSQLFREECONNECT= TEXT("SQLFreeConnect"); <br>static LPTSTR szSQLFREEENV= TEXT("SQLFreeEnv"); <br>static LPTSTR szSQLGETDESCREC= TEXT("SQLGetDescRec"); <br>static LPTSTR szSQLSETDESCREC= TEXT("SQLSetDescRec"); <br>static LPTSTR szSQLGETDESCFIELD= TEXT("SQLGetDescField"); <br>static LPTSTR szSQLSETDESCFIELD= TEXT("SQLSetDescField"); <br>static LPTSTR szSQLCOPYDESC= TEXT("SQLCopyDesc"); <br>static LPTSTR szSQLSETENVATTR= TEXT("SQLSetEnvAttr"); <br>static LPTSTR szSQLGETENVATTR= TEXT("SQLGetEnvAttr"); <br>static LPTSTR szSQLFREESTMT= TEXT("SQLFreeStmt"); <br>static LPTSTR szSQLENDTRAN= TEXT("SQLEndTran"); <br>static LPTSTR szSQLGETCURSORNAME= TEXT("SQLGetCursorName"); <br>static LPTSTR szSQLEXECDIRECT= TEXT("SQLExecDirect"); <br>static LPTSTR szSQLPUTDATA= TEXT("SQLPutData"); <br>static LPTSTR szSQLPARAMDATA= TEXT("SQLParamData"); <br>static LPTSTR szSQLROWCOUNT= TEXT("SQLRowCount"); <br>static LPTSTR szSQLSETPARAM= TEXT("SQLSetParam"); <br>static LPTSTR szSQLBINDPARAMETER= TEXT("SQLBindParameter"); <br>static LPTSTR szSQLBINDPARAM= TEXT("SQLBindParam"); <br>static LPTSTR szSQLPREPARE= TEXT("SQLPrepare"); <br>static LPTSTR szSQLEXECUTE= TEXT("SQLExecute"); <br>static LPTSTR szSQLCOLATTRIBUTES= TEXT("SQLColAttributes"); <br>static LPTSTR szSQLGETDATA= TEXT("SQLGetData"); <br>static LPTSTR szSQLCOLUMNS= TEXT("SQLColumns"); <br>static LPTSTR szSQLGETFUNCTIONS= TEXT("SQLGetFunctions");   <br>static LPTSTR szSQLDRIVERCONNECT= TEXT("SQLDriverConnect"); <br>static LPTSTR szSQLDISCONNECT= TEXT("SQLDisconnect"); <br>static LPTSTR szSQLCONNECT= TEXT("SQLConnect"); <br>static LPTSTR szSQLCANCEL= TEXT("SQLCancel"); <br>static LPTSTR szSQLDESCRIBECOL= TEXT("SQLDescribeCol"); <br>static LPTSTR szSQLTABLES= TEXT("SQLTables"); <br>static LPTSTR szSQLSPECIALCOLUMNS= TEXT("SQLSpecialColumns"); <br>static LPTSTR szSQLDESCRIBEPARAM= TEXT("SQLDescribeParam"); <br>static LPTSTR szSQLNUMPARAMS= TEXT("SQLNumParams"); <br>static LPTSTR szSQLPARAMOPTIONS= TEXT("SQLParamOptions"); <br>static LPTSTR szSQLPRIMARYKEYS= TEXT("SQLPrimaryKeys"); <br>static LPTSTR szSQLEXTENDEDFETCH= TEXT("SQLExtendedFetch"); <br>static LPTSTR szSELECTSTAR= TEXT("select * from %s"); <br>static LPTSTR szQUICKREBIND= TEXT("Quick Rebind"); <br>static LPTSTR szSQLBROWSECONNECT= TEXT("SQLBrowseConnect"); <br>static LPTSTR szBLANKLINE= TEXT(" "); <br>static LPTSTR szTAB= TEXT("\t"); <br>static LPTSTR szSQLNUMRESULTCOLS= TEXT("SQLNumResultCols"); <br>static LPTSTR szSQLSETSCROLLOPTIONS= TEXT("SQLSetScrollOptions"); <br>static LPTSTR szSQLFETCHSCROLL= TEXT("SQLFetchScroll"); <br>static LPTSTR szSQLSTATISTICS= TEXT("SQLStatistics"); <br>static LPTSTR szSQLCLOSECURSOR= TEXT("SQLCloseCursor"); <br>static LPTSTR szSQLGETDIAGREC= TEXT("SQLGetDiagRec"); <br>static LPTSTR szSQLGETDIAGFIELD= TEXT("SQLGetDiagField"); <br>static LPTSTR szRETDATA= TEXT("returned data"); <br>static LPTSTR szINCORRECTOUTLEN= TEXT("incorrect outlen"); <br>static LPTSTR szSQLNATIVESQL= TEXT("SQLNativeSql"); <br>static LPTSTR szSQLNATIVESQLW= TEXT("SQLNativeSqlW"); <br>static LPTSTR szSQLCONNECTW= TEXT("SQLConnectW"); <br>static LPTSTR szSQLTABLESA= TEXT("SQLTablesA"); <br>static LPTSTR szSQLTABLESW= TEXT("SQLTablesW"); <br>static LPTSTR szSQLCOLUMNSA= TEXT("SQLColumnsA"); <br>static LPTSTR szSQLCOLUMNSW= TEXT("SQLColumnsW"); <br>static LPTSTR szSQLEXECDIRECTA= TEXT("SQLExecDirectA"); <br>static LPTSTR szSQLEXECDIRECTW= TEXT("SQLExecDirectW"); <br> <br>LPTSTR iTestNames[]={ <br>TEXT("Test Connection Options"), <br>TEXT("Test Statement Options"), <br>TEXT("Test SQLGetCursorName"), <br>TEXT("Test Data"), <br>TEXT("Test SQLNumResultCols"), <br>TEXT("Test Meta-Data"), <br>TEXT("Test Searched Query"), <br>TEXT("Test Large Query"), <br>TEXT("Test SQLTables"), <br>TEXT("Test SQLStatistics"), <br>TEXT("Test SQLSpecialColumns"), <br>TEXT("Test 'Like' Query"), <br>TEXT("Test SQLForeignKeys"), <br>TEXT("Test SQLBrowseConnect"), <br>TEXT("Test SQLDataSources"), <br>TEXT("Test SQLDrivers"), <br>TEXT("Test SQLMoreResults"), <br>TEXT("Test SQLNativeSQL"), <br>TEXT("Test SQLDescribeParam"), <br>TEXT("Test SQLNumParams"), <br>TEXT("Test SQLParamOptions"), <br>TEXT("Test SQLPrimaryKeys"), <br>TEXT("Test SQLProcedures"), <br>TEXT("Test SQLTablePrivileges"), <br>TEXT("Test SQLColumnPrivileges"), <br>TEXT("Test SQLSetScrollOptions"), <br>TEXT("Test SQLExtendedFetch"), <br>TEXT("Test SQL_OJ_CAPABILITIES"), <br>TEXT("Test SQLSetConnectAttr"), <br>TEXT("Test SQLSetStmtAttr"), <br>TEXT("Test Threading"), <br>TEXT("Test GetDescField"), <br>TEXT("Test SetDescField"), <br>TEXT("Test GetDescRec"), <br>TEXT("Test SetDescRec"), <br>TEXT("Test CopyDesc"), <br>TEXT("Test Descriptor Defaults"), <br>TEXT("Test Usage of Descriptor"), <br>TEXT("Test Environment Attributes"), <br>TEXT("Test SQLEndTran"), <br>TEXT("Test SQLBindParam"), <br>TEXT("Test Quick Rebind"), <br>TEXT("Test SQLFetchScroll"), <br>TEXT("Test GetDiagRec"), <br>TEXT("Test GetDiagField"), <br>TEXT("Test MixedAnsiUnicode") <br>}; <br> <br> <br>typedef struct tagHANDLES <br>{ <br>SWORDfHandleType; <br>SQLHANDLEhHandle; <br> <br>} HANDLES, *lpHANDLES; <br> <br>SUPPORTOPTINFO OptionList[] = {SQL_SO_FORWARD_ONLY, SQL_SCROLL_FORWARD_ONLY, <br>SQL_SO_KEYSET_DRIVEN, SQL_SCROLL_KEYSET_DRIVEN, <br>SQL_SO_DYNAMIC, SQL_SCROLL_DYNAMIC}; <br> <br>SUPPORTCONCURINFO ConcurList[] = {SQL_SCCO_READ_ONLY, SQL_CONCUR_READ_ONLY, <br>SQL_SCCO_LOCK, SQL_CONCUR_LOCK, <br>SQL_SCCO_OPT_TIMESTAMP, SQL_CONCUR_TIMESTAMP, <br>SQL_SCCO_OPT_VALUES, SQL_CONCUR_VALUES}; <br> <br> <br>/*--------------------------------------------------------------------------------------*/ <br>/* globals */ <br>/*--------------------------------------------------------------------------------------*/ <br>lpSERVERINFOlpSI = NULL; <br>UWORDfBindParameter=FALSE, <br>fDiagRecSupported=FALSE, <br>fDiagFieldSupported=FALSE, <br>uDriverODBCVer=0; <br>UWORDguwRowCount=0;// Count of rows in the automaketable <br>   <br>/* these are globals so that the error functions can access them without <br>needing to have them passed to every error check */ <br>static HENV            henv=SQL_NULL_HENV; <br>static HDBC            hdbc=SQL_NULL_HDBC; <br>static HSTMT           hstmt=SQL_NULL_HSTMT; <br>static SQLHDESC        hdesc=SQL_NULL_HDESC; <br> <br> <br> <br>//globals for test descriptors <br>TIMESTAMP_STRUCT tsval= {1955, 12, 31, 23, 59, 59, 999}; <br>SQLINTEGER cbtsval=sizeof(TIMESTAMP_STRUCT); <br>SQLINTEGER cbValueMax, cbValue, swBindOffset=128; <br>SQLUINTEGER RowsProcessed; <br>SQLSMALLINT DescBuf[MAX_DESC_BUF];  <br>SQLUSMALLINT StatusArray[STATUS_ARRAY_SIZE]; <br>SQLTCHAR buf[MAX_STRING_SIZE]; <br>SQLTCHAR szParamName[MAX_STRING_SIZE]=TEXT("Parameter Name"); <br> <br>struct tagDescType { <br>SQLUSMALLINTuwDescType; <br>SQLUSMALLINTuwTypeMask; <br>TCHAR szDescName[4]; <br>} DescTypes[] = { <br>SQL_ATTR_APP_ROW_DESC,DESC_ARD,TEXT("ARD"), <br>SQL_ATTR_APP_PARAM_DESC,DESC_APD,TEXT("APD"), <br>SQL_ATTR_IMP_ROW_DESC,DESC_IRD,TEXT("IRD"), <br>SQL_ATTR_IMP_PARAM_DESC,DESC_IPD,TEXT("IPD") <br>}; <br> <br>struct tagDescInfo { <br>SQLSMALLINT uwDescField; <br>LPTSTR szDescFieldName; <br>BOOL fHeader; <br>SQLSMALLINT fGettable;// Can be retrieved for given descriptor types <br>SQLSMALLINT fSettable;// Can be set for given descriptor types <br>SQLSMALLINT fDefault;// Has a default value for the descriptor types <br>SQLINTEGER NewValue; <br>SQLINTEGER DefaultVal; <br>SQLSMALLINT cbValue; <br>SQLINTEGER size; <br>} rgDescInfo[] ={ <br>// Test expects all header fields to be listed first.  The TYPE field must be the first record field listed. <br>// size should be set to 0 for string fields, since we don't know up front what to set it to <br>// Field IDField NameHeaderGettableSettablefDefaultNew ValueDefault ValueData SizeData Type <br> <br>//Header fields <br>SQL_DESC_COUNT,TEXT("SQL_DESC_COUNT"),TRUE,DESC_ALL,DESC_MOST,DESC_MOST,1,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_ALLOC_TYPE,TEXT("SQL_DESC_ALLOC_TYPE"),TRUE,DESC_ALL,DESC_NONE,DESC_ALL,0,SQL_DESC_ALLOC_AUTO,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_ARRAY_SIZE,TEXT("SQL_DESC_ARRAY_SIZE"),TRUE,DESC_AD,DESC_AD,DESC_AD,STATUS_ARRAY_SIZE,1,sizeof(SQLUINTEGER),SQL_IS_UINTEGER, <br>SQL_DESC_ARRAY_STATUS_PTR,TEXT("SQL_DESC_ARRAY_STATUS_PTR"),TRUE,DESC_ALL,DESC_ALL,DESC_ALL,(SQLINTEGER)(StatusArray),(SQLINTEGER)NULL,sizeof(SQLPOINTER),SQL_IS_POINTER, <br>SQL_DESC_BIND_OFFSET_PTR,TEXT("SQL_DESC_BIND_OFFSET_PTR"),TRUE,DESC_AD,DESC_AD,DESC_AD,(SQLINTEGER)(&amp;swBindOffset),(SQLINTEGER)NULL,sizeof(SQLPOINTER),SQL_IS_POINTER, <br>SQL_DESC_BIND_TYPE,TEXT("SQL_DESC_BIND_TYPE"),TRUE,DESC_AD,DESC_AD,DESC_AD,BIND_SIZE,0,sizeof(SQLINTEGER),SQL_IS_INTEGER, <br>//SQL_DESC_OUT_OF_LINE_HEAP,TEXT("SQL_DESC_OUT_OF_LINE_HEAP"),TRUE,DESC_AD,DESC_AD,(SQLINTEGER)(StatusArray),sizeof(SQLINTEGER),SQL_IS_POINTER, <br>//SQL_DESC_OUT_OF_LINE_HEAP_OCTET_LENGTH,TEXT("SQL_DESC_OUT_OF_LINE_HEAP_OCTET_LENGTH"),TRUE, DESC_AD,DESC_AD,sizeof(StatusArray),sizeof(SQLINTEGER),SQL_IS_NOT_POINTER, <br>SQL_DESC_ROWS_PROCESSED_PTR,TEXT("SQL_DESC_ROWS_PROCESSED_PTR"),TRUE,DESC_ID,DESC_ID,DESC_ID,(SQLINTEGER)(&amp;RowsProcessed),(SQLINTEGER)NULL,sizeof(SQLPOINTER),SQL_IS_POINTER, <br> <br>// Record fields <br>SQL_DESC_TYPE,TEXT("SQL_DESC_TYPE"), FALSE,DESC_ALL,DESC_MOST,DESC_AD,SQL_DATETIME,SQL_C_DEFAULT,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_DATETIME_INTERVAL_CODE,TEXT("SQL_DESC_DATETIME_INTERVAL_CODE"),FALSE,DESC_ALL, DESC_MOST,DESC_NONE,SQL_CODE_TIMESTAMP,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_CONCISE_TYPE,TEXT("SQL_DESC_CONCISE_TYPE"),FALSE,DESC_ALL,DESC_MOST,DESC_AD,SQL_TYPE_TIMESTAMP,SQL_C_DEFAULT,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_AUTO_UNIQUE_VALUE,TEXT("SQL_DESC_AUTO_UNIQUE_VALUE"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,0,0,sizeof(SQLINTEGER),SQL_IS_INTEGER, <br>//SQL_DESC_BIND_OUT_OF_LINE,TEXT("SQL_DESC_BIND_OUT_OF_LINE"),FALSE,DESC_AD,DESC_AD,SQL_TRUE,sizeof(SQLSMALLINT),SQL_IS_NOT_POINTER, <br>SQL_DESC_BASE_COLUMN_NAME,TEXT("SQL_DESC_BASE_COLUMN_NAME"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_CASE_SENSITIVE,TEXT("SQL_DESC_CASE_SENSITIVE"),FALSE,DESC_ID,DESC_NONE,DESC_NONE,0,0,sizeof(SQLINTEGER),SQL_IS_INTEGER, <br>SQL_DESC_CATALOG_NAME,TEXT("SQL_DESC_CATALOG_NAME"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_DATETIME_INTERVAL_PRECISION, TEXT("SQL_DESC_DATETIME_INTERVAL_PRECISION"),FALSE, DESC_ALL,DESC_MOST,DESC_NONE,3,0,sizeof(SQLINTEGER),SQL_IS_INTEGER, <br>SQL_DESC_DISPLAY_SIZE,TEXT("SQL_DESC_DISPLAY_SIZE"),FALSE,DESC_IRD,DESC_NONE, DESC_NONE,0,0,sizeof(SQLINTEGER),SQL_IS_INTEGER, <br>SQL_DESC_FIXED_PREC_SCALE,TEXT("SQL_DESC_FIXED_PREC_SCALE"),FALSE,DESC_ID,DESC_NONE,DESC_NONE,0,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_LABEL,TEXT("SQL_DESC_LABEL"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_LENGTH,TEXT("SQL_DESC_LENGTH"),FALSE,DESC_ALL,DESC_MOST,DESC_NONE,23,0,sizeof(SQLUINTEGER),SQL_IS_UINTEGER, <br>SQL_DESC_LITERAL_PREFIX,TEXT("SQL_DESC_LITERAL_PREFIX"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_LITERAL_SUFFIX,TEXT("SQL_DESC_LITERAL_SUFFIX"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_LOCAL_TYPE_NAME,TEXT("SQL_DESC_LOCAL_TYPE_NAME"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_NAME,TEXT("SQL_DESC_NAME"),FALSE,DESC_ID,DESC_IPD,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_NULLABLE,TEXT("SQL_DESC_NULLABLE"),FALSE,DESC_ID,DESC_NONE,DESC_NONE,0,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_OCTET_LENGTH,TEXT("SQL_DESC_OCTET_LENGTH"),FALSE,DESC_ALL,DESC_MOST,DESC_NONE,sizeof(tsval),0,sizeof(SQLINTEGER),SQL_IS_INTEGER, <br>SQL_DESC_OCTET_LENGTH_PTR,TEXT("SQL_DESC_OCTET_LENGTH_PTR"),FALSE,DESC_AD,DESC_AD,DESC_AD,(SQLINTEGER)(&amp;cbtsval),(SQLINTEGER)NULL,sizeof(SQLINTEGER),SQL_IS_POINTER, <br>SQL_DESC_PARAMETER_TYPE,TEXT("SQL_DESC_PARAMETER_TYPE"),FALSE,DESC_IPD,DESC_IPD,DESC_IPD,SQL_PARAM_OUTPUT,SQL_PARAM_INPUT,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_PRECISION,TEXT("SQL_DESC_PRECISION"),FALSE,DESC_ALL,DESC_MOST,DESC_NONE,23,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_SCALE,TEXT("SQL_DESC_SCALE"),FALSE,DESC_ALL,DESC_MOST,DESC_NONE,3,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_SCHEMA_NAME,TEXT("SQL_DESC_SCHEMA_NAME"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_SEARCHABLE,TEXT("SQL_DESC_SEARCHABLE"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,0,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_TABLE_NAME,TEXT("SQL_DESC_TABLE_NAME"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_TYPE_NAME,TEXT("SQL_DESC_TYPE_NAME"),FALSE,DESC_ID,DESC_NONE,DESC_NONE,(SQLINTEGER)szParamName,0,sizeof(SQLCHAR),0, <br>SQL_DESC_UNSIGNED,TEXT("SQL_DESC_UNSIGNED"),FALSE,DESC_ID,DESC_NONE,DESC_NONE,0,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_UPDATABLE,TEXT("SQL_DESC_UPDATABLE"),FALSE,DESC_IRD,DESC_NONE,DESC_NONE,0,0,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_INDICATOR_PTR,TEXT("SQL_DESC_INDICATOR_PTR"),FALSE,DESC_AD,DESC_AD,DESC_AD,SQL_NULL_DATA,(SQLINTEGER)NULL,sizeof(SQLPOINTER),SQL_IS_POINTER, <br>SQL_DESC_UNNAMED,TEXT("SQL_DESC_UNNAMED"),FALSE,DESC_ID,DESC_IPD,DESC_NONE,SQL_UNNAMED,SQL_NAMED,sizeof(SQLSMALLINT),SQL_IS_SMALLINT, <br>SQL_DESC_DATA_PTR,TEXT("SQL_DESC_DATA_PTR"),FALSE,DESC_AD,DESC_MOST,DESC_AD,(SQLINTEGER)&amp;tsval,(SQLINTEGER)NULL,sizeof(SQLPOINTER),SQL_IS_POINTER <br> }; <br> <br>struct tagDIAGINFO { <br>SQLSMALLINT uwDescField; <br>LPTSTR szDescFieldName; <br>SWORD irecRecNumber; <br>} rgDiagInfo[] ={ <br>//SQL_DIAG_CURSOR_ROW_COUNT,TEXT("SQL_DIAG_CURSOR_ROW_COUNT"),0, <br>//SQL_DIAG_DYNAMIC_FUNCTION,TEXT("SQL_DIAG_DYNAMIC_FUNCTION"),0, <br>//SQL_DIAG_DYNAMIC_FUNCTION_CODE,TEXT("SQL_DIAG_DYNAMIC_FUNCTION_CODE"),0, <br>SQL_DIAG_NUMBER,TEXT("SQL_DIAG_NUMBER"),0, <br>SQL_DIAG_RETURNCODE,TEXT("SQL_DIAG_RETURNCODE"),0, <br>//SQL_DIAG_ROW_NUMBER,TEXT("SQL_DIAG_ROW_NUMBER"),0, <br>//SQL_DIAG_COLUMN_NUMBER,TEXT("SQL_DIAG_COLUMN_NUMBER"),1, <br>//SQL_DIAG_ROW_COUNT,TEXT("SQL_DIAG_ROW_COUNT"),0, <br>SQL_DIAG_SQLSTATE,TEXT("SQL_DIAG_SQLSTATE"),1, <br>SQL_DIAG_NATIVE,TEXT("SQL_DIAG_NATIVE"),1, <br>SQL_DIAG_MESSAGE_TEXT,TEXT("SQL_DIAG_MESSAGE_TEXT"),1, <br>SQL_DIAG_CLASS_ORIGIN,TEXT("SQL_DIAG_CLASS_ORIGIN"),1, <br>SQL_DIAG_SUBCLASS_ORIGIN,TEXT("SQL_DIAG_SUBCLASS_ORIGIN"),1, <br>//SQL_DIAG_CONNECTION_NAME,TEXT("SQL_DIAG_CONNECTION_NAME"),1, <br>SQL_DIAG_SERVER_NAME,TEXT("SQL_DIAG_SERVER_NAME"),1, <br>}; <br> <br>BOOLg_f3XDriver=FALSE; <br> <br>//the insert statement bufferto hold the insert statement <br>TCHAR szInsertStmt[MAX_STRING_SIZE]; <br> <br>//----------------------------------------------------------------------- <br>//      Function:               Supported <br>//----------------------------------------------------------------------- <br> <br>_inline UWORD  PASCAL Supported(UWORD uwSQLFunc) <br>{ <br>UWORDfLevel2=FALSE; <br>RETCODErc=SQL_SUCCESS; <br> <br>rc = SQLGetFunctions(hdbc, uwSQLFunc,&amp;fLevel2); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETFUNCTIONS); <br> <br>return(fLevel2); <br> <br>} //Supported() <br> <br> <br>/*------------------------------------------------------------------------------ <br> *Function:CheckDataResults - To check data returned by Fetch calls  <br> *Checks data at (row, col) in result set against (row, col) in table <br> * ----------------------------------------------------------------------------*/ <br>BOOL CheckDataResults(SWORD row, SWORD iTableCol, FIELDINFO*  pField, DSTRUCT* pDataStr, <br> SDWORD cbValue, TCHAR* rgbValue) <br>{ <br>if((pField -&gt;nullable)&amp;&amp; (cbValue&lt;1)) <br>{ <br>if(cbValue == SQL_NULL_DATA &amp;&amp; pDataStr[iTableCol].cb == SQL_NULL_DATA) <br>return TRUE; <br>return FALSE; <br>} <br> <br>return CmpODBCtoCHAR(pDataStr, rgbValue, pField-&gt;wSQLType, iTableCol); <br>} <br> <br> <br>/*------------------------------------------------------------------------------ <br>/Function:BinToHex <br>/Purpose:Render a buffer contents as a hexidecimal string. <br>/*----------------------------------------------------------------------------*/ <br> <br>void PASCAL BinToHex(PTR rgbValue, SWORD cbValue, LPTSTR szHexString) <br>{ <br>UWORD ib; <br>LPTSTR pch; <br>TCHAR rgchDigits[] = TEXT("0123456789ABCDEF"); <br> <br>lstrcpy(szHexString, TEXT("0x")); <br>if(cbValue &gt; (MAX_STRING_SIZE - 3)/2 || cbValue &lt; 0) <br>cbValue = (MAX_STRING_SIZE - 3)/2; <br> <br>pch = &amp;szHexString[lstrlen(szHexString)]; <br>for(ib=0; ib &lt; cbValue; ib++) <br>{ <br>*pch++ = rgchDigits[((LPBYTE)rgbValue)[ib] &gt;&gt; 4]; <br>*pch++ = rgchDigits[((LPBYTE)rgbValue)[ib] &amp; 0xF]; <br>} <br>*pch = TEXT('\0'); <br> <br>} /* BinToHex() */ <br> <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               SearchForError                           */ <br>/*-----------------------------------------------------------------------*/ <br> <br>_inline int PASCAL SearchForError(HENV henv, HDBC hdbc,HSTMT hstmt,LPTSTR szFindState) <br>{ <br>TCHAR buf[MAX_STRING_SIZE]; <br>RETCODE rc; <br>TCHAR szState[6]; <br>int found = FALSE; <br> <br>for(rc = SQLError(henv, hdbc, hstmt, szState, NULL, buf, MAX_STRING_SIZE, NULL) <br>; !found &amp;&amp; (rc == SQL_SUCCESS || rc == SQL_SUCCESS_WITH_INFO) <br>; rc = SQLError(henv, NULL, NULL, szState, NULL, buf, MAX_STRING_SIZE, NULL))  <br>{ <br>found = lstrcmp(szState, szFindState) == 0; <br>} <br> <br>return(found); <br> <br>} /* SearchForError() */ <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               szWrite                                  */ <br>/*-----------------------------------------------------------------------*/ <br> <br>_inline VOID WINAPI szWrite(LPTSTR szStr, BOOL fNewLine) <br>{ <br>szLogPrintf(lpSI, FALSE, szStr); <br>if(fNewLine) <br>szLogPrintf(lpSI, FALSE, TEXT("\r\n")); <br>} <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               GetErrors                         */ <br>/*-----------------------------------------------------------------------*/ <br> <br>VOID PASCAL GetErrors(HENV henv,HDBC hdbc,HSTMT hstmt) <br>{ <br>TCHAR buf[MAX_ERROR_SIZE]; <br>TCHAR largebuf[COMBINED_SIZE]; <br>TCHAR szState[100]; <br>RETCODE rc=SQL_SUCCESS; <br> <br>for(rc = SQLError(henv, hdbc, hstmt, szState, NULL, buf, MAX_ERROR_SIZE, NULL) <br>; RC_SUCCESSFUL(rc) <br>; rc = SQLError(henv, NULL, NULL, szState, NULL, buf, MAX_ERROR_SIZE, NULL)) <br>{ <br>wsprintf(largebuf,TEXT("\t\t\tState: %s"), szState); <br>szWrite(largebuf, TRUE); <br>wsprintf(largebuf,TEXT("\t\t\tError: %s"), buf); <br>szWrite(largebuf, TRUE); <br>} <br> <br>} /* GetErrors() */ <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               GetDiagRecs                         */ <br>/*-----------------------------------------------------------------------*/ <br> <br>VOID PASCAL GetDiagRecs(SWORD fHandleType,SQLHANDLE hHandle) <br>{ <br>TCHARszMessageText[XLARGEBUFF]=TEXT(""), <br>szBuff[XLARGEBUFF]=TEXT(""); <br>TCHARszSQLState[100]=TEXT(""); <br>RETCODErc=SQL_SUCCESS; <br>SWORDirecRecNumber=0; <br>SDWORDfNativeError=0; <br>SWORDcbBufferLength=sizeof(szMessageText), <br>cbTextLength=0; <br>SDWORDsdNumRecs=0; <br> <br>if (fDiagFieldSupported) <br>{ <br>/* Get number of diag, records */ <br>rc = SQLGetDiagField(fHandleType, hHandle,0,SQL_DIAG_NUMBER, <br>&amp;sdNumRecs,sizeof(sdNumRecs),NULL); <br>} <br> <br> <br>for(irecRecNumber=1;(irecRecNumber &lt;= sdNumRecs) &amp;&amp; RC_SUCCESSFUL(rc);irecRecNumber++) <br>{ <br>rc = SQLGetDiagRec(fHandleType, hHandle, irecRecNumber,szSQLState,&amp;fNativeError, <br>szMessageText,cbBufferLength,&amp;cbTextLength); <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>wsprintf(szBuff,TEXT("\t\t\tState: %s"), szSQLState); <br>szWrite(szBuff, TRUE); <br>wsprintf(szBuff,TEXT("\t\t\tError: %s"), szMessageText); <br>szWrite(szBuff, TRUE); <br>} <br> <br>} <br> <br> <br>} /* GetErrors() */ <br> <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               DisplayAllErrors                         */ <br>/*-----------------------------------------------------------------------*/ <br> <br>void  PASCAL DisplayAllErrors() <br>{ <br>if (!fDiagRecSupported) <br>{ <br>GetErrors(henv,NULL,NULL); <br>GetErrors(NULL,hdbc,NULL); <br>GetErrors(NULL,NULL,hstmt); <br>} <br>else <br>{ <br>GetDiagRecs(SQL_HANDLE_ENV,henv); <br>GetDiagRecs(SQL_HANDLE_DBC,hdbc); <br>GetDiagRecs(SQL_HANDLE_STMT,hstmt); <br>GetDiagRecs(SQL_HANDLE_DESC,hdesc); <br>} <br> <br>} /* DisplayAllErrors() */ <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               RetcodeToTCHAR                            */ <br>/*-----------------------------------------------------------------------*/ <br> <br>LPTSTR  PASCAL RetcodeToTCHAR(RETCODE retcode, LPTSTR buf) <br>{ <br>switch (retcode)  <br>{ <br>case SQL_SUCCESS: <br>lstrcpy (buf,TEXT("SQL_SUCCESS")); <br>break; <br>case SQL_ERROR: <br>lstrcpy (buf,TEXT("SQL_ERROR")); <br>break; <br>case SQL_SUCCESS_WITH_INFO: <br>lstrcpy (buf,TEXT("SQL_SUCCESS_WITH_INFO")); <br>break; <br>case SQL_NO_DATA_FOUND: <br>lstrcpy (buf,TEXT("SQL_NO_DATA_FOUND")); <br>break; <br>case SQL_NEED_DATA: <br>lstrcpy (buf,TEXT("SQL_NEED_DATA")); <br>break; <br>case SQL_INVALID_HANDLE: <br>lstrcpy (buf,TEXT("SQL_INVALID_HANDLE")); <br>break; <br>case SQL_STILL_EXECUTING: <br>lstrcpy (buf,TEXT("SQL_STILL_EXECUTING")); <br>break; <br>default: <br>lstrcpy(buf,TEXT("UNKNOWN rc")); <br>} <br> <br>return buf; <br>} <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               ReturnCheck <br>//----------------------------------------------------------------------- <br> <br>int  PASCAL ReturnCheck(RETCODE retExpected, RETCODE retReceived, LPTSTR szFunction,  <br>LPTSTR szFile, int iLine,BOOL fDiag) <br>{ <br>TCHAR buf[MAX_STRING_SIZE]; <br> <br>if(retExpected == retReceived) <br>return TRUE; <br> <br>szWrite(TEXT(""), TRUE); <br> <br>szWrite(TEXT("\t\t\t"), FALSE); <br>szWrite(szFunction, TRUE); <br> <br>szWrite(TEXT("\t\t\tExpected: "), FALSE); <br>szWrite(RetcodeToTCHAR(retExpected, buf), TRUE); <br> <br>szWrite(TEXT("\t\t\tReceived: "), FALSE); <br>szWrite(RetcodeToTCHAR(retReceived, buf), TRUE); <br> <br>if (!fDiag) <br>DisplayAllErrors(); <br> <br>wsprintf(buf,TEXT("\t\t\t%s: %d"), szFile, iLine); <br>szWrite(buf, TRUE); <br> <br>szWrite(TEXT("\t\t\t --------  "), TRUE); <br> <br>lpSI-&gt;failed++; <br> <br>return FALSE; <br>} <br> <br>//----------------------------------------------------------------------- <br>//      Function:               ErrsHandle <br>//----------------------------------------------------------------------- <br> <br>int  PASCAL ErrsHandle(SWORD fHandleType,SQLHANDLE hHandle, RETCODE retExpected, <br>RETCODE retReceived, LPTSTR szFunction, LPTSTR szFile, int iLine,BOOL fDiag) <br>{ <br>TCHAR buf[MAX_STRING_SIZE]; <br> <br>if(retExpected == retReceived) <br>return TRUE; <br> <br>szWrite(TEXT(""), TRUE); <br> <br>szWrite(TEXT("\t\t\t"), FALSE); <br>szWrite(szFunction, TRUE); <br> <br>szWrite(TEXT("\t\t\tExpected: "), FALSE); <br>szWrite(RetcodeToTCHAR(retExpected, buf), TRUE); <br> <br>szWrite(TEXT("\t\t\tReceived: "), FALSE); <br>szWrite(RetcodeToTCHAR(retReceived, buf), TRUE); <br> <br>if (!fDiag) <br>GetDiagRecs(fHandleType,hHandle); <br> <br>wsprintf(buf,TEXT("\t\t\t%s: %d"), szFile, iLine); <br>szWrite(buf, TRUE); <br> <br>szWrite(TEXT("\t\t\t --------  "), TRUE); <br> <br>lpSI-&gt;failed++; <br> <br>return FALSE; <br>} <br> <br>/*------------------------------------------------------------------------------ <br>/Function:FindError <br>/Purpose:Find the expected error message. Display a failure if not found. <br>/*----------------------------------------------------------------------------*/ <br> <br>BOOL PASCAL FindError(SWORD fHandleType, LPTSTR szFindState) <br>{ <br>SQLHANDLE handle = SQL_NULL_HANDLE; <br>SWORD irec; <br>TCHAR szErrorMsg[SQL_MAX_MESSAGE_LENGTH]; <br>RETCODE rc; <br>TCHAR szState[6]; <br> <br>switch(fHandleType) <br>{ <br>case SQL_HANDLE_ENV: <br>handle = henv; <br>break; <br> <br>case SQL_HANDLE_DBC: <br>handle = hdbc; <br>break; <br> <br>case SQL_HANDLE_STMT: <br>handle = hstmt; <br>break; <br> <br>case SQL_HANDLE_DESC: <br>if(!Supported(SQL_API_SQLGETDIAGREC)) <br>return TRUE; <br> <br>handle = hdesc; <br>break; <br> <br>default: <br>DISPLAYERROR(TEXT("FindError"), TEXT("invalid fHandleType")); <br>return FALSE; <br>} <br> <br>for(irec = 1 <br>; rc = SQLGetDiagRec(fHandleType, handle, irec, szState, NULL, szErrorMsg, SQL_MAX_MESSAGE_LENGTH, NULL) <br>, RC_SUCCESSFUL(rc) <br>; irec++) <br>{ <br>if(lstrcmp(szState, szFindState) == 0) <br>return TRUE; <br>} <br>return FALSE; <br> <br>} /* FindError() */ <br> <br>/*------------------------------------------------------------------------------ <br> *Function:CompareWithExpected <br> *Checks data in rgbValue against expected value given row, col, and rgFields. <br> *Posts an error if mismatch <br> * ----------------------------------------------------------------------------*/ <br>void CompareWithExpected(PTR rgbValue, SDWORD * pcbValue, UWORD row, UWORD icol, FIELDINFO  *rgFields) <br>{ <br>LPTSTR   pch=NULL; <br>TCHAR szExpBuf[MAX_STRING_SIZE]=TEXT(""); <br>TCHAR * stopstr; <br> <br>pch = qtMakeData(row-1, icol-1, &amp;rgFields[icol-1], szExpBuf); <br> <br>// Field is not READ ONLY, compare the value we inserted <br>if(pch)  <br>{ <br> // Where row and column match and field is nullable, a NULL exists <br>if (icol-1 == row-1 &amp;&amp; rgFields[icol-1].nullable) <br>{ <br>// Post an error if not SQL_NULL_DATA <br>if (*pcbValue != SQL_NULL_DATA) <br>DISPLAYERROR(TEXT("Simulate BindCol"),TEXT("Didn't return SQL_NULL_DATA")); <br>} <br>else <br>{ <br>BOOL bCompare; <br>TCHAR * pstr=szExpBuf;// Pointer to start of expected string <br> <br>switch(rgFields[icol-1].wSQLType) <br>{ <br>case SQL_BIT: <br>case SQL_TINYINT: <br>case SQL_SMALLINT: <br>case SQL_INTEGER: <br>// Compare the data values as long // tcsncmp <br>bCompare=(_ttol(rgbValue) == _ttol(pstr)); <br>break; <br>case SQL_NUMERIC: <br>case SQL_DECIMAL: <br>case SQL_FLOAT: <br>case SQL_REAL: <br>case SQL_DOUBLE: <br>// Compare the data values as doubles strtod <br>bCompare=(_tcstod(rgbValue, &amp;stopstr) == _tcstod(pstr, &amp;stopstr)); <br>break; <br>case SQL_DATE: <br>case SQL_TIME: <br>case SQL_TIMESTAMP: <br>case SQL_TYPE_DATE: <br>case SQL_TYPE_TIME: <br>case SQL_TYPE_TIMESTAMP: <br>pstr=szExpBuf+lstrlen(TEXT("{ts '")); <br>// Replace second ' with '\0'' <br>_tcstok(pstr, TEXT("'")); <br>if (lstrlen(rgbValue) &gt; lstrlen(TEXT("1994-10-10 10:00:00"))) <br>lstrcat(pstr, TEXT(".000")); <br>bCompare=(!_tcsncmp(rgbValue, pstr, rgFields[icol-1].precision)); </code></pre>
<p>
</p>
<pre><code>break; <br>default: <br>bCompare=(!_tcsncmp(rgbValue, pstr, lstrlen(pstr))); <br>} <br> <br>// Compare the data values as char  <br>if (!bCompare) <br>{ <br>DISPLAYERROR(TEXT("Simulate BindCol"),TEXT("Returned data didn't match")); <br>szWrite(TEXT("\t\t\tExpected: "), FALSE); <br>szWrite(pstr, TRUE); <br>szWrite(TEXT("\t\t\tReceived: "), FALSE); <br>szWrite(rgbValue, TRUE); <br>} <br>} <br>} <br>} //CompareWithExpected <br> <br>//----------------------------------------------------------------------- <br>//      Function:               ResetHstmt <br>//----------------------------------------------------------------------- <br>void ResetHstmt(SQLHSTMT * phstmt) <br>{ <br>SQLRETURN rc; <br> <br>// Free and reallocate stmt handle to clean up <br>rc=SQLFreeHandle(SQL_HANDLE_STMT, *phstmt); <br>ERRSHANDLE(SQL_HANDLE_STMT, *phstmt, SQL_SUCCESS, rc, szSQLFREESTMT); <br>rc=SQLAllocHandle(SQL_HANDLE_STMT, hdbc, phstmt); <br>RETCHECK(SQL_SUCCESS, rc,szSQLALLOCHANDLE); <br>} <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               GetSomeData                              */ <br>/*-----------------------------------------------------------------------*/ <br> <br>VOID PASCAL GetSomeData(HSTMT lhstmt, LPTSTR szTableName,BOOL fBindCol, <br>FIELDINFO  rgField) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>SDWORDcbValue=0; <br>TCHARszQuery[XLARGEBUFF]=TEXT(""), <br>szBuff[XLARGEBUFF]=TEXT(""); <br>TCHARszErrMsg[MAX_STRING_SIZE]=TEXT(""), <br>szDataItem[XLARGEBUFF]=TEXT(""); <br>LPTSTR   pch=NULL; <br> <br>pch = qtMakeData(0, 0,&amp;rgField, szDataItem); <br> <br>wsprintf(szQuery,szSELECTSTAR,szTableName); <br>rc=SQLExecDirect(lhstmt,szQuery,SQL_NTS); <br>//RETCHECK(SQL_SUCCESS,rc,szSQLEXECDIRECT); <br> <br>if (fBindCol) <br>{ <br>rc = SQLBindCol(lhstmt, 1, SQL_C_TCHAR, szBuff, sizeof(szBuff),&amp;cbValue); <br>//RETCHECK(SQL_SUCCESS, rc, szSQLBINDCOL); <br>} <br> <br>rc = SQLFetch(lhstmt); <br>//RETCHECK(SQL_SUCCESS, rc,szSQLFETCH); <br> <br>if (!fBindCol) <br>{ <br>rc = SQLGetData(lhstmt,1, SQL_C_TCHAR,szBuff, sizeof(szBuff), NULL); <br>//RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br>} <br> <br>lstrcmp(szDataItem,szBuff); <br> <br>} /* GetSomeData() */ <br> <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               SelectFromTable                          */ <br>/*-----------------------------------------------------------------------*/ <br> <br>_inline RETCODE PASCAL SelectFromTable(QTSTRUCT *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszQuery[LARGEBUFF]; <br> <br>wsprintf(szQuery,TEXT("select %s from %s"),  <br>//wsprintf(szQuery,TEXT("select %s from %s order by %s"),  <br>lpqt-&gt;szColNames, lpqt-&gt;szTableName/*, lpqt-&gt;szColNames*/); <br> <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>return(rc); <br> <br>} /* SelectFromTable() */ <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               SelectFromTableFetch                     */ <br>/*-----------------------------------------------------------------------*/ <br> <br>_inline RETCODE PASCAL SelectFromTableFetch(QTSTRUCT *lpqt, TCHAR* szColName) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszQuery[LARGEBUFF]; <br> <br>wsprintf(szQuery,TEXT("select %s from %s order by %s"),  <br>lpqt-&gt;szColNames, lpqt-&gt;szTableName, szColName); <br> <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>if((SQL_SUCCESS!=rc) &amp;&amp; (SQL_SUCCESS_WITH_INFO!=rc)){ <br>RETCHECK(SQL_SUCCESS_WITH_INFO, rc,szSQLEXECDIRECT); <br>return SQL_NO_DATA; <br>} <br> <br>return SQL_SUCCESS; <br>} /* SelectFromTableFetch() */ <br> <br>//----------------------------------------------------------------------- <br>//      Function:               AllocHstmt <br>//----------------------------------------------------------------------- <br> <br>_inline BOOL PASCAL AllocHstmt() <br>{ <br>BOOLfFailed=FALSE; <br>RETCODErc=SQL_SUCCESS; <br> <br>if (Supported(SQL_API_SQLALLOCHANDLE)) <br>{ <br>rc = SQLAllocHandle(SQL_HANDLE_STMT,hdbc, &amp;hstmt); <br>if(!RETCHECK(SQL_SUCCESS, rc, szSQLALLOCHANDLE)) <br>fFailed=TRUE; <br>} <br>else <br>{ <br>rc = SQLAllocStmt(hdbc, &amp;hstmt); <br>if(!RETCHECK(SQL_SUCCESS, rc, szSQLALLOCSTMT)) <br>fFailed=TRUE; <br>} <br> <br> <br>return(fFailed); <br> <br>} //AllocHstmt() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               AllocHdbc <br>//----------------------------------------------------------------------- <br> <br>_inline BOOL PASCAL AllocHdbc(HDBC *phdbc) <br>{ <br>BOOLfFailed=FALSE; <br>RETCODErc=SQL_SUCCESS; <br> <br>if (Supported(SQL_API_SQLALLOCHANDLE)) <br>{ <br>rc = SQLAllocHandle(SQL_HANDLE_DBC,henv, phdbc); <br>if(!RETCHECK(SQL_SUCCESS, rc, szSQLALLOCHANDLE)) <br>fFailed=TRUE; <br>} <br>else <br>{ <br>rc = SQLAllocConnect(henv, phdbc); <br>if(!RETCHECK(SQL_SUCCESS, rc, szSQLALLOCCONNECT)) <br>fFailed=TRUE; <br>} <br> <br> <br>return(fFailed); <br> <br>} //AllocHdbc() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:AllocHenv <br>//----------------------------------------------------------------------- <br> <br>_inline BOOL PASCAL PASCAL AllocHenv() <br>{ <br>BOOLfFailed=FALSE; <br>RETCODErc=SQL_SUCCESS; <br> <br>rc = SQLAllocEnv(&amp;henv); <br>if (!RETCHECK(SQL_SUCCESS, rc,szSQLALLOCENV)) <br>fFailed=TRUE; <br> <br>return(fFailed); <br> <br>} //AllocHenv() <br> <br>//----------------------------------------------------------------------- <br>//      Function:               SetStatementAttributes <br>//----------------------------------------------------------------------- <br> <br>_inline BOOL PASCAL SetStatementAttributes(UWORD fAttr, PTR rgbValue) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszAPI[MEDBUFF]; <br>BOOLfFailed=FALSE; <br> <br>if (Supported(SQL_API_SQLSETSTMTATTR)) <br>{ <br>rc = SQLSetStmtAttr(hstmt,(SDWORD)fAttr,rgbValue,sizeof(UDWORD)); <br>lstrcpy(szAPI,szSQLSETSTMTATTR); <br>} <br>else <br>{ <br>rc = SQLSetStmtOption(hstmt,fAttr,(UDWORD)rgbValue); <br>lstrcpy(szAPI,szSQLSETSTMTOPTION); <br>} <br> <br>if (rc != SQL_SUCCESS) <br>{ <br>if(!FindError(SQL_HANDLE_STMT,szHYC00)) <br>RETCHECK(SQL_SUCCESS, rc,szAPI); <br> <br>fFailed=TRUE; <br>} <br> <br>return(fFailed); <br> <br>} //SetStatementAttributes() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               SetConnectionAttributes <br>//----------------------------------------------------------------------- <br> <br>_inline BOOL PASCAL SetConnectionAttributes(HDBC lhdbc,UWORD fAttr, UDWORD rgbValue) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszAPI[MEDBUFF]; <br>BOOLfFailed=FALSE; <br> <br>if (Supported(SQL_API_SQLSETCONNECTATTR)) <br>{ <br>rc = SQLSetConnectAttr(lhdbc,(SDWORD)fAttr,(PTR)rgbValue,sizeof(UDWORD)); <br>lstrcpy(szAPI,szSQLSETCONNECTATTR); <br>} <br>else <br>{ <br>rc = SQLSetConnectOption(lhdbc,fAttr,rgbValue); <br>lstrcpy(szAPI,szSQLSETCONNECTOPTION); <br>} <br> <br>if (rc != SQL_SUCCESS) <br>{ <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS, rc,szAPI); <br> <br>fFailed=TRUE; <br>} <br> <br>return(fFailed); <br> <br>} //SetConnectionAttributes() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               FreeStmt <br>//----------------------------------------------------------------------- <br> <br>_inline BOOL PASCAL FreeStmt(UWORD fOption) <br>{ <br>RETCODErc=SQL_SUCCESS; <br> <br>if (Supported(SQL_API_SQLFREEHANDLE) &amp;&amp; (fOption == SQL_DROP)) <br>{ <br>rc = SQLFreeHandle(SQL_HANDLE_STMT,hstmt); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREEHANDLE); <br>} <br>else <br>{ <br>rc = SQLFreeStmt(hstmt, fOption); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREESTMT); <br>} <br> <br>return(RC_NOTSUCCESSFUL(rc)); <br> <br>} //FreeStmt() <br> <br>//----------------------------------------------------------------------- <br>//      Function:               DropHdbc <br>//----------------------------------------------------------------------- <br> <br>VOID PASCAL DropHdbc(HDBC hdbc) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if (Supported(SQL_API_SQLFREEHANDLE)) <br>{ <br>rc = SQLFreeHandle(SQL_HANDLE_DBC,hdbc); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREEHANDLE); <br>} <br>else <br>{ <br>rc = SQLFreeConnect(hdbc); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREECONNECT); <br>} <br> <br>} //DropHdbc() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               DropHenv <br>//----------------------------------------------------------------------- <br> <br>_inline VOID PASCAL DropHenv() <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if (Supported(SQL_API_SQLFREEHANDLE)) <br>{ <br>rc = SQLFreeHandle(SQL_HANDLE_ENV,henv); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREEHANDLE); <br>} <br>else <br>{ <br>rc = SQLFreeEnv(henv); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREEENV); <br>} <br> <br>} //DropHenv() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               ClearErrorQueue <br>//----------------------------------------------------------------------- <br> <br>VOID PASCAL ClearErrorQueue() <br>{ <br>TCHAR szErrMsg[MAX_STRING_SIZE]; <br>TCHAR szState[6]; <br> <br>/* Eat up the SQL_SUCCESS_WITH_INFO error record */ <br>while (RC_SUCCESSFUL(SQLError(NULL, hdbc,NULL, szState, NULL,  <br>szErrMsg, sizeof(szErrMsg), NULL))) <br>; <br>} <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               Is3XDriver <br>//----------------------------------------------------------------------- <br> <br>BOOL PASCAL Is3XDriver(HDBC hdbc,QTSTRUCT *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>LPTSTRpch=NULL; <br>BOOLf3XDriver=FALSE; <br> <br>rc = SQLGetInfo(hdbc, SQL_DRIVER_ODBC_VER, lpqt-&gt;buf, MAX_STRING_SIZE, NULL); <br>if(RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO)) <br>{ <br>pch = _tcstok(lpqt-&gt;buf,TEXT(".")); <br> <br>if (!_tcsnccmp(pch,TEXT("02"), 2)) <br>{ <br>pch = _tcstok(NULL,TEXT(".")); <br> <br>if(!_tcsnccmp(pch,TEXT("00"), 2)) <br>DISPLAYERROR(szSQLGETINFO,TEXT("Driver returned ODBC version 2.00 which is no longer supported.  Please upgrade to 2.01")); <br> <br>} <br>else if (!_tcsnccmp(pch,TEXT("03"), 2)) <br>f3XDriver=TRUE; <br>} <br> <br>uDriverODBCVer=_ttoi(lpqt-&gt;buf); <br> <br>return(f3XDriver); <br> <br>} //Is3XDriver() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               Connect <br>//----------------------------------------------------------------------- <br> <br>BOOL  PASCAL Connect(lpSERVERINFO lpSI,QTSTRUCT  *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>SDWORD sdwAppVer; <br> <br>/* The signal for test to use it's <br>own allocated handles, is if the a server name is passed in.  If it <br>is not, the test should use the hdbc passed in */ <br> <br>/* ****************** Allocate Env ************************* */ <br>if (AllocHenv()) <br>goto ConnectErrorRet; <br> <br>/* ****************** Set Application Version ************************* */ <br>rc = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, <br>SQL_IS_UINTEGER); <br>if(!RETCHECK(SQL_SUCCESS, rc, szSQLSETENVATTR)) <br>goto ConnectErrorRet; <br> <br>/* ****************** Allocate Connection ************************* */ <br> <br>rc = SQLAllocConnect(henv, &amp;hdbc); <br>if(!RETCHECK(SQL_SUCCESS, rc, szSQLALLOCCONNECT)) <br>goto ConnectErrorRet; <br> <br>/* ****************** Set Connection Attributes ************************* */ <br>rc = SQLSetConnectOption(hdbc,SQL_ODBC_CURSORS,lpSI-&gt;vCursorLib); <br> <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>if (!RETCHECK(SQL_SUCCESS, rc,szSQLSETCONNECTOPTION)) <br>goto ConnectErrorRet; <br> <br>/* create a DriverConnect string */ <br>wsprintf(lpqt-&gt;sz, TEXT("dsn=%s;uid=%s;pwd=%s;"), <br>lpSI-&gt;szValidServer0, <br>lpSI-&gt;szValidLogin0, <br>lpSI-&gt;szValidPassword0); <br> <br>/* since SQL_DRIVER_COMPLETE is used, it is possible that the <br>driver will bring up a dialog asking for more information. */ <br>rc = SQLDriverConnect(hdbc, lpSI-&gt;hwnd, lpqt-&gt;sz, <br>SQL_NTS, lpqt-&gt;buf, MAX_STRING_SIZE, NULL, SQL_DRIVER_COMPLETE); <br> <br>if (RC_NOTSUCCESSFUL(rc)) <br>{ <br>if (!RETCHECK(SQL_SUCCESS, rc,szSQLDRIVERCONNECT)) <br>goto ConnectErrorRet; <br>} <br>else <br>ClearErrorQueue(); <br> <br> <br>rc = SQLDisconnect(hdbc); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDISCONNECT); <br> <br>rc = SQLConnect(hdbc, lpSI-&gt;szValidServer0, SQL_NTS, <br>lpSI-&gt;szValidLogin0, SQL_NTS, <br>lpSI-&gt;szValidPassword0, SQL_NTS); <br> <br>if (RC_SUCCESSFUL(rc)) <br>ClearErrorQueue(); <br>else if (!RETCHECK(SQL_SUCCESS, rc,szSQLCONNECT)) <br>goto ConnectErrorRet; <br> <br>// Set the global 3.0 driver flag <br>g_f3XDriver=Is3XDriver(hdbc,lpqt); <br> <br>// We're now connected, check application version and adjust expected error <br>// states appropriately. <br>rc = SQLGetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, &amp;sdwAppVer, SQL_IS_UINTEGER, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETENVATTR); <br> <br>if (RC_SUCCESSFUL(rc) &amp;&amp; (SQL_OV_ODBC2 == sdwAppVer)) <br>{ <br>lstrcpy(szHY009, TEXT("S1009")); <br>lstrcpy(szHYC00, TEXT("S1C00")); <br>} <br> <br>return(FALSE); <br> <br>ConnectErrorRet: <br> <br>return(TRUE); <br> <br>} //Connect() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               IgnoreType <br>//----------------------------------------------------------------------- <br> <br>BOOL  PASCAL IgnoreType(LPTSTR szType,SWORD wSQLType) <br>{ <br>BOOL fIgnore=FALSE; <br> <br>/* If a line below is compiled in, that type will not be used in creating <br> the table.  (useful for when one specific type is causing problems in <br> a particular test, this way the test can be run for all other types) <br>*/ <br> <br>if (!lstrcmp(szType,TEXT("LONG RAW")) || <br> !lstrcmp(szType,TEXT("LONG VARTCHAR")) || <br>  !lstrcmp(szType,TEXT("LONG VARTCHAR FOR BIT DATA"))) <br>{ <br> fIgnore=TRUE; <br>} <br> <br>//if (wSQLType != SQL_CHAR) <br>//fIgnore=TRUE; <br> <br>return(fIgnore); <br> <br>} //IgnoreType() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               CheckConformanceLevel <br>//----------------------------------------------------------------------- <br> <br>UWORD  PASCAL CheckConformanceLevel() <br>{ <br>RETCODE rc=SQL_SUCCESS; <br>UWORDfIndex=0; <br>SWORDcb=0; <br> <br>rc = SQLGetInfo(hdbc, SQL_ODBC_SQL_CONFORMANCE, &amp;fIndex, <br>sizeof (fIndex), &amp;cb); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>if(fIndex != 0 &amp;&amp; fIndex != 1 &amp;&amp; fIndex != 2) { <br>/* one of these two values should always be returned */ <br>DISPLAYERROR(szSQLGETINFO,TEXT("SQL_ODBC_API_CONFORMANCE - invalid value")); <br>} <br> <br>return(fIndex); <br> <br>} //CheckConformanceLevel() <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               TestConnectionOptions */ <br>/*-----------------------------------------------------------------------*/ <br> <br>void  PASCAL TestConnectionOptions() <br>{ <br>RETCODErc=SQL_SUCCESS; <br>SDWORDsdw, <br>cbValue=0; <br>BOOLfConnectOption=TRUE; <br>TCHARszAPI[MEDBUFF]; <br>HDBClhdbc=NULL; <br> <br> <br>rc=SQLAllocConnect(henv,&amp;lhdbc); <br>RETCHECK(SQL_SUCCESS, rc,szSQLALLOCCONNECT); <br> <br>SetConnectionAttributes(lhdbc,SQL_ACCESS_MODE,SQL_MODE_READ_WRITE); <br> <br>SetConnectionAttributes(lhdbc,SQL_AUTOCOMMIT,TRUE); <br> <br>if (SetConnectionAttributes(lhdbc,SQL_LOGIN_TIMEOUT,TEST_CONNECT_OPTION)) <br>fConnectOption = FALSE; <br> <br>if (Supported(SQL_API_SQLGETCONNECTATTR)) <br>{ <br>rc = SQLGetConnectAttr(lhdbc, SQL_LOGIN_TIMEOUT, (PTR)&amp;sdw,0,&amp;cbValue); <br>lstrcpy(szAPI,szSQLGETCONNECTATTR); <br>} <br>else <br>{ <br>rc = SQLGetConnectOption(lhdbc, SQL_LOGIN_TIMEOUT, &amp;sdw); <br>lstrcpy(szAPI,szSQLSETCONNECTOPTION); <br>} <br> <br> <br>if(rc != SQL_SUCCESS) <br>{ <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS, rc,szAPI); <br>} <br>else <br>{ <br>if(sdw != TEST_CONNECT_OPTION &amp;&amp; fConnectOption) <br>DISPLAYERROR(szAPI,TEXT("SQL_LOGIN_TIMEOUT returned incorrect value")); <br>} <br> <br>rc=SQLFreeConnect(lhdbc); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREECONNECT); <br> <br>} //TestConnectionOptions() <br> <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:            CanAllocHdesc        */ <br>/*-----------------------------------------------------------------------*/ <br> <br>BOOL PASCAL CanAllocHdesc() <br>{ <br>BOOL fSupported=FALSE; <br> <br>/* Allocate an hdesc: */ <br>if(Supported(SQL_API_SQLALLOCHANDLE)) <br>fSupported = RC_SUCCESSFUL(SQLAllocHandle(SQL_HANDLE_DESC, hdbc, &amp;hdesc)); <br> <br>return(fSupported); <br> <br>} <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:            SetErrorCondition    */ <br>/*-----------------------------------------------------------------------*/ <br> <br>VOID PASCAL SetErrorCondition(SWORD fHandleType) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>/* The following are used to produce "(S1)HY009" SQL State */ <br>switch (fHandleType) <br>{ <br>case SQL_HANDLE_ENV: <br>rc = SQLAllocConnect(henv, NULL); <br>break; <br>case SQL_HANDLE_DBC: <br>rc = SQLAllocStmt(hdbc, NULL); <br>break; <br>case SQL_HANDLE_STMT: <br>rc = SQLExecDirect(hstmt, NULL, SQL_NTS);// Produces a DM error <br>break; <br>case SQL_HANDLE_DESC: <br>rc = SQLGetDescField(hdesc, 0, SQL_DESC_AUTO_UNIQUE_VALUE, NULL, 0, NULL); <br>break; <br>} <br> <br>} //SetErrorCondition() <br> <br> <br> <br>VOID PASCAL CheckData(SWORD fHandleType,UWORD uwDescField, PTR rgbValue,LPTSTR szDataSourceName) <br>{ <br>TCHARszBuff[MEDBUFF]=TEXT(""); <br>LPTSTRpszExpState=szHY009; <br> <br>if (fHandleType == SQL_HANDLE_DESC) <br>pszExpState=szHY091; <br> <br>switch(uwDescField) <br>{ <br>case SQL_DIAG_RETURNCODE: <br>{ <br>RETCODE rcRec=*(RETCODE *)rgbValue; <br> <br>if (rcRec!= SQL_ERROR) <br>{ <br>wsprintf(szBuff,TEXT("\t\t\tSQL_DIAG_RETURN_CODE\tReceived: %d\tExpected: %d"),rcRec,-1); <br>} <br>} <br>break; <br> <br>case SQL_DIAG_SQLSTATE: <br>{ <br>if (lstrcmp((LPTSTR)rgbValue,pszExpState)) <br>{ <br>wsprintf(szBuff,TEXT("\t\t\tSQL_DIAG_SQLSTATE\tReceived: %s\tExpected: %s"),(LPTSTR)rgbValue,pszExpState); <br>} <br>} <br>break; <br>case SQL_DIAG_CLASS_ORIGIN: <br>{ <br>if (lstrcmp((LPTSTR)rgbValue,szISO)) <br>wsprintf(szBuff,TEXT("\t\t\tSQL_DIAG_CLASS_ORIGIN\tReceived: %s\tExpected: %s"),(LPTSTR)rgbValue,szISO); <br>} <br>break; <br>case SQL_DIAG_SUBCLASS_ORIGIN: <br>{ <br>if (lstrcmp((LPTSTR)rgbValue,szISO)) <br>wsprintf(szBuff,TEXT("\t\t\tSQL_DIAG_CLASS_ORIGIN\tReceived: %s\tExpected: %s"),(LPTSTR)rgbValue,szISO); <br>} <br>break; <br>case SQL_DIAG_NUMBER: <br>{ <br>SDWORD cRecs=*(SDWORD *)rgbValue; <br>if (cRecs != 1) <br>wsprintf(szBuff,TEXT("\t\t\tSQL_DIAG_NUMBER\tReceived: %d\tExpected: %d"),cRecs,1); <br>} <br>break; <br>case SQL_DIAG_SERVER_NAME: <br>{ <br>switch(fHandleType) <br>{ <br>case SQL_HANDLE_DBC: <br>case SQL_HANDLE_STMT: <br>if (lstrcmp((LPTSTR)rgbValue,szDataSourceName)) <br>wsprintf(szBuff,TEXT("\t\t\tSQL_DIAG_SERVER_NAME\tReceived: %s\tExpected: %s"),(LPTSTR)rgbValue,szDataSourceName); <br>break; <br>} <br>} <br>break; <br>default: <br>break; <br> <br>} <br> <br>if (*szBuff) <br>DISPLAYERROR(szSQLGETDIAGREC,szBuff); <br> <br>} /* CheckData() */ <br> <br> <br>/*------------------------------------------------------------------------------ <br>/Function:TestDiagRec                                               <br>/Purpose:For each type of handle, generate an error. If SQLGetDiagField       <br>/is not supported, verify the appropriate DM error is returned.       <br>/Otherwise, verify SQLGetDiagField returns the expected error         <br>/information. If SQLGetDiagRec is not supported, verify the           <br>/appropriate DM error is returned. Otherwise, verify                  <br>/SQLGetDiagField returns the expected error information. If           <br>/SQLGetDiagRec is supported, compare its output with that of          <br>/SQLGetDiagField.                                                     <br>/*----------------------------------------------------------------------------*/ <br> <br>void PASCAL TestDiagRec() <br>{ <br>SQLRETURNrcFunction,  <br>rc=SQL_SUCCESS; <br>SWORDcbErrorMsg; <br>SDWORDfNativeError; <br>UWORDiHandle=0, <br>iField=0, <br>cHandles; <br> <br>SDWORD*pfNativeError = NULL; <br>LPTSTRpchMessageText = NULL; <br> <br>TCHARszDataSourceName[MAX_STRING_SIZE] = TEXT(""); <br>TCHARszState[SQL_SQLSTATE_SIZE+1]; <br>TCHARszErrorMsg[SQL_MAX_MESSAGE_LENGTH]; <br>TCHARszAPI[MEDBUFF]=TEXT(""); <br>TCHARszBuff[MEDBUFF]=TEXT(""); <br> <br>LPTSTRpszExpState=szHY009; <br>RETCODErcExp=SQL_SUCCESS; <br> <br>HANDLES rgHandles[] =  <br>{ <br>SQL_HANDLE_ENV, henv, <br>SQL_HANDLE_DBC, hdbc, <br>SQL_HANDLE_STMT, hstmt, <br>SQL_HANDLE_DESC, hdesc, <br>}; <br> <br>cHandles=sizeof(rgHandles)/sizeof(HANDLES); <br> <br>/* Call SQLGetInfo to get values to compare: */ <br>rcFunction = SQLGetInfo(hdbc, SQL_DATA_SOURCE_NAME, szDataSourceName, MAX_STRING_SIZE, NULL); <br>RETCHECK(SQL_SUCCESS, rcFunction, szSQLGETINFO); <br> <br>/* Allocate an hdesc: */ <br>if(Supported(SQL_API_SQLALLOCHANDLE) &amp;&amp; g_f3XDriver) <br>{  <br>rcFunction = SQLAllocHandle(SQL_HANDLE_DESC, hdbc, &amp;hdesc); <br>RETCHECK(SQL_SUCCESS, rcFunction, szSQLALLOCHANDLE); <br> <br>// Update the array entry for the hdesc <br>rgHandles[3].hHandle=hdesc; <br> <br>} <br>else <br>cHandles--; <br> <br>for (iHandle=0; iHandle &lt; cHandles; iHandle++) <br>{ <br> <br>SetErrorCondition(rgHandles[iHandle].fHandleType); <br> <br>rc = SQLGetDiagRec(rgHandles[iHandle].fHandleType, rgHandles[iHandle].hHandle,  <br>1,szState,&amp;fNativeError, szErrorMsg, <br>SQL_MAX_MESSAGE_LENGTH, &amp;cbErrorMsg); <br> <br>if (rgHandles[iHandle].fHandleType == SQL_HANDLE_DESC) <br>pszExpState=szHY091; <br> <br>rcExp=SQL_SUCCESS; <br> <br>if(fDiagRecSupported) <br>{ <br> <br>DIAGRETCHECK(rcExp, rc, szSQLGETDIAGREC); <br>if (RC_SUCCESSFUL(rc) &amp;&amp; lstrcmp(szState,pszExpState)) <br>{ <br>wsprintf(szBuff,TEXT("\t\t\tReceived: %s\tExpected: %s"),szState,pszExpState); <br>DISPLAYERROR(szSQLGETDIAGREC,szBuff); <br>} <br>} <br>else <br>{ <br>if(!FindError(rgHandles[iHandle].fHandleType, szIM001)) <br>DISPLAYERROR(szSQLGETDIAGREC, szNotSupported); <br>} <br> <br>} <br> <br> <br>/* Free the hdesc: */ <br>if (hdesc) <br>{ <br>rcFunction = SQLFreeHandle(SQL_HANDLE_DESC, hdesc); <br>RETCHECK(rcExp, rcFunction, szSQLFREEHANDLE); <br>hdesc = SQL_NULL_HDESC; <br>} <br> <br>//ExitTestDiagRec <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} /* TestDiagRec() */ <br> <br> <br>/*------------------------------------------------------------------------------ <br>/Function:TestDiagField                                                <br>/Purpose:For each type of handle, generate an error. If SQLGetDiagField       <br>/is not supported, verify the appropriate DM error is returned.       <br>/Otherwise, verify SQLGetDiagField returns the expected error         <br>/information. If SQLGetDiagRec is not supported, verify the           <br>/appropriate DM error is returned. Otherwise, verify                  <br>/SQLGetDiagField returns the expected error information. If           <br>/SQLGetDiagRec is supported, compare its output with that of          <br>/SQLGetDiagField.                                                     <br>/*----------------------------------------------------------------------------*/ <br> <br>void PASCAL TestDiagField() <br>{ <br>SQLRETURNrcFunction,  <br>rc=SQL_SUCCESS; <br>SWORDcbValue=0; <br>UWORDiHandle=0, <br>iField=0, <br>cHandles; <br> <br>TCHARszDataSourceName[MAX_STRING_SIZE] = TEXT(""); <br>TCHARrgbValue[SQL_MAX_MESSAGE_LENGTH]; <br>TCHARszAPI[MEDBUFF]=TEXT(""); <br>TCHARszBuff[MEDBUFF]=TEXT(""); <br>RETCODErcExp=SQL_SUCCESS; <br> <br>HANDLES rgHandles[] =  <br>{ <br>SQL_HANDLE_ENV, henv, <br>SQL_HANDLE_DBC, hdbc, <br>SQL_HANDLE_STMT, hstmt, <br>SQL_HANDLE_DESC, hdesc, <br>}; <br> <br>cHandles=sizeof(rgHandles)/sizeof(HANDLES); <br> <br>/* Call SQLGetInfo to get values to compare: */ <br>rcFunction = SQLGetInfo(hdbc, SQL_DATA_SOURCE_NAME, szDataSourceName, MAX_STRING_SIZE, NULL); <br>RETCHECK(SQL_SUCCESS, rcFunction, szSQLGETINFO); <br> <br>hdesc = SQL_NULL_HDESC; <br> <br>/* Allocate an hdesc: */ <br>if(Supported(SQL_API_SQLALLOCHANDLE) &amp;&amp; g_f3XDriver) <br>{  <br>rcFunction = SQLAllocHandle(SQL_HANDLE_DESC, hdbc, &amp;hdesc); <br>RETCHECK(SQL_SUCCESS, rcFunction, szSQLALLOCHANDLE); <br> <br>// Update the array entry for the hdesc <br>rgHandles[3].hHandle=hdesc; <br> <br>} <br>else <br>cHandles--; <br> <br>for (iHandle=0; iHandle &lt; cHandles; iHandle++) <br>{ <br> <br>SetErrorCondition(rgHandles[iHandle].fHandleType); <br> <br>if(fDiagFieldSupported) <br>{ <br>for (iField=0;iField &lt; sizeof(rgDiagInfo)/sizeof(struct tagDIAGINFO);iField++) <br>{ <br>rc = SQLGetDiagField(rgHandles[iHandle].fHandleType, rgHandles[iHandle].hHandle,  <br>rgDiagInfo[iField].irecRecNumber, rgDiagInfo[iField].uwDescField, <br>rgbValue, SQL_MAX_MESSAGE_LENGTH, &amp;cbValue); <br> <br>DIAGRETCHECK(rcExp, rc, szSQLGETDIAGFIELD); <br> <br>if (RC_SUCCESSFUL(rc)) <br>CheckData(rgHandles[iHandle].fHandleType,rgDiagInfo[iField].uwDescField,  <br>rgbValue,szDataSourceName); <br>} <br> <br>} <br>else <br>{ <br>rc = SQLGetDiagField(SQL_HANDLE_ENV, henv, 0, SQL_DIAG_RETURNCODE, rgbValue,SQL_MAX_MESSAGE_LENGTH, &amp;cbValue); <br> <br>if(!FindError(rgHandles[iHandle].fHandleType, szIM001)) <br>DISPLAYERROR(szAPI, szNotSupported); <br> <br>} <br> <br>} <br> <br> <br>/* Free the hdesc: */ <br>if (hdesc) <br>{ <br>rcFunction = SQLFreeHandle(SQL_HANDLE_DESC, hdesc); <br>RETCHECK(rcExp, rcFunction, szSQLFREEHANDLE); <br>hdesc = SQL_NULL_HDESC; <br>} <br> <br>//ExitTestDiagField <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} /* TestDiagField() */ <br> <br>//------------------------------------------------------------------------------ <br>//Function:CompareAnsiToUnicode <br>//Compares an ANSI string to a Unicode string <br>//------------------------------------------------------------------------------ <br>BOOL CompareAnsiToUnicode(SQLCHAR * aszBuf, SQLINTEGER cbA, SQLWCHAR * wszBuf, <br>SQLINTEGER cbW, SQLTCHAR * szAPI) <br>{ <br>SQLCHAR aszConvBuf[MAX_STRING_SIZE]; <br>SQLINTEGER cbT; <br>BOOL bCompare=TRUE; <br> <br>// Check ANSI count of bytes returned <br>if ((cbA != SQL_NULL_DATA) &amp;&amp; (SQLINTEGER)strlen(aszBuf) != cbA) <br>{ <br>wsprintf(buf, TEXT("ANSI count of bytes returned incorrect.")\ <br>TEXT(" Expected: %d, received: %d"), <br>strlen(aszBuf), cbA); <br>DISPLAYERROR(szAPI, buf); <br>bCompare=FALSE; <br>} <br> <br>// Compare ANSI count of bytes with Unicode count <br>cbT = (cbA &gt; 0) ? (SQLINTEGER)(cbA * sizeof(SQLWCHAR)) : cbA; <br>if (cbW != cbT) <br>{ <br>wsprintf(buf, TEXT("Unicode count of bytes returned incorrect.")\ <br>TEXT(" Expected: %d, received: %d"), cbT, cbW); <br>DISPLAYERROR(szAPI, buf); <br>bCompare=FALSE; <br>} <br> <br>// Compare strings if not NULL DATA <br>if (cbA != SQL_NULL_DATA) <br>{ <br>// Compare ANSI and Unicode strings returned <br>(void)(WideCharToMultiByte(CP_ACP, 0, wszBuf, wcslen(wszBuf), aszConvBuf, <br>sizeof(aszConvBuf), NULL, NULL)); <br>aszConvBuf[wcslen(wszBuf)]=TEXT('\0'); <br> <br>if (strcmp(aszBuf, aszConvBuf)) <br>{ <br>wsprintf(buf, TEXT("Unicode string did not match ANSI string.\r\n")\ <br>TEXT("\t\t\tExpected: '%hs', Received: '%hs'"), aszBuf, aszConvBuf); <br>DISPLAYERROR(szAPI, buf); <br>bCompare=FALSE; <br>} <br>} <br> <br>return bCompare; <br>} <br> <br>//------------------------------------------------------------------------------ <br>//Function:CompareAnsiUnicodeResults <br>//Compares an ANSI result set to a Unicode result set <br>//------------------------------------------------------------------------------ <br>void CompareAnsiUnicodeResults(SQLHSTMT hstmtA, SQLHSTMT hstmtW, SQLTCHAR * szAPI) <br>{ <br>SQLCHAR aszBuf[MAX_STRING_SIZE]; <br>SQLWCHAR wszBuf[MAX_STRING_SIZE]; <br>SQLINTEGER cbANSI, cbUnicode; <br>SQLUSMALLINTuwCol; <br>SQLSMALLINTswColCountA, swColCountW; <br>SQLRETURN rc, rcA, rcW; <br> <br>// Check width of result sets <br>rc=SQLNumResultCols(hstmtA, &amp;swColCountA); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtA, SQL_SUCCESS, rc, szSQLNUMRESULTCOLS); <br>rc=SQLNumResultCols(hstmtW, &amp;swColCountW); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtW, SQL_SUCCESS, rc, szSQLNUMRESULTCOLS); <br>if (swColCountA != swColCountW) <br>DISPLAYERROR(szAPI,TEXT("ANSI and Unicode result sets different widths.")); <br> <br>uwCol=1; <br>do { <br>rc=SQLBindCol(hstmtA, uwCol, SQL_C_CHAR, aszBuf, sizeof(aszBuf), &amp;cbANSI); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtA, SQL_SUCCESS, rc, szSQLBINDCOL); <br>rc=SQLBindCol(hstmtW, uwCol, SQL_C_WCHAR, wszBuf, sizeof(wszBuf), &amp;cbUnicode); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtW, SQL_SUCCESS, rc, szSQLBINDCOL); <br> <br>// Copy something into the buffers so we can tell if they were modified <br>strcpy(aszBuf, "Untouched"); <br>wcscpy(wszBuf, L"Untouched"); <br> <br>// Fetch into the buffers <br>rcA=SQLFetch(hstmtA); <br>rcW=SQLFetch(hstmtW); <br> <br> <br>if (RC_SUCCESSFUL(rcA) &amp;&amp; RC_SUCCESSFUL(rcW)) <br>{ <br>if (!CompareAnsiToUnicode(aszBuf, cbANSI, wszBuf, cbUnicode, szSQLFETCH)) <br>{ <br>rcW=SQL_NO_DATA;// Abort the loop w/o generating failure <br>rcA=SQL_NO_DATA; <br>} <br>} <br> <br>// Unbind the column bound above on each statement <br>rc=SQLFreeStmt(hstmtA, SQL_UNBIND); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtA, SQL_SUCCESS, rc, szSQLFREESTMT); <br>rc=SQLFreeStmt(hstmtW, SQL_UNBIND); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtW, SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>// Don't exceed the total number of columns in result set <br>uwCol++; <br>if (uwCol &gt; (SQLUSMALLINT)swColCountA) <br>uwCol=1; <br>} <br>while (RC_SUCCESSFUL(rcA) &amp;&amp; RC_SUCCESSFUL(rcW)); <br> <br>// Make sure the result sets were the same size <br>if (rcW != SQL_NO_DATA) <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtW, SQL_NO_DATA, rc, szSQLFETCH); <br> <br>// Make sure the result sets were the same size <br>if (rcA != rcW) <br>DISPLAYERROR(szAPI,TEXT("ANSI and Unicode result sets not the same length.")); <br> <br>rc=SQLFreeStmt(hstmtA, SQL_CLOSE); </code></pre>
<p>
</p>
<pre><code>ERRSHANDLE(SQL_HANDLE_STMT, hstmtA, SQL_SUCCESS, rc, szSQLFREESTMT); <br>rc=SQLFreeStmt(hstmtW, SQL_CLOSE); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtW, SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>} <br> <br> <br>/*------------------------------------------------------------------------------ <br>/Function:TestMixedAnsiUnicode <br>/Purpose:Call several of the Unicode functions mixed with ANSI functions <br>/to verify functions succeed in the mixed case. <br>/*----------------------------------------------------------------------------*/ <br>void PASCAL TestMixedAnsiUnicode(QTSTRUCT * lpqt) <br>{ <br>HDBChdbcANSI, hdbcUnicode; <br>HSTMT hstmtANSIA, hstmtANSIW, hstmtUA, hstmtUW, hstmtW; <br>SQLINTEGER cbANSI, cbUnicode; <br>SQLWCHAR wszServer[MAX_STRING_SIZE], wszLogin[MAX_STRING_SIZE], <br>wszPassword[MAX_STRING_SIZE], wszQuery[MAX_STRING_SIZE], <br>wszBuf[MAX_STRING_SIZE], wszTable[MAX_STRING_SIZE]; <br>SQLCHARaszServer[MAX_STRING_SIZE], aszLogin[MAX_STRING_SIZE], <br>aszPassword[MAX_STRING_SIZE], aszQuery[MAX_STRING_SIZE], <br>aszBuf[MAX_STRING_SIZE], aszTable[MAX_STRING_SIZE]; <br>SQLUSMALLINT fStmts; <br>SQLRETURN rc, rcA=SQL_SUCCESS, rcW=SQL_SUCCESS; <br> <br>// We've already set the environment attribute to 3.0 by this point <br> <br>#ifdef UNICODE <br>// Copy the unicode strings <br>lstrcpy(wszServer, lpSI-&gt;szValidServer0); <br>lstrcpy(wszLogin, lpSI-&gt;szValidLogin0); <br>lstrcpy(wszPassword, lpSI-&gt;szValidPassword0); <br>lstrcpy(wszTable, lpqt-&gt;szTableName); <br>wsprintf(wszQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br> <br>// Convert and copy to ANSI strings <br>/* <br>int WideCharToMultiByte( <br> UINT  CodePage,// code page  <br> DWORD  dwFlags,// performance and mapping flags  <br> LPCWSTR  lpWideCharStr,// address of wide-character string  <br> int  cchWideChar,// number of characters in string  <br> LPSTR  lpMultiByteStr,// address of buffer for new string  <br> int  cchMultiByte,// size of buffer  <br> LPCSTR  lpDefaultChar,// address of default for unmappable characters   <br> LPBOOL  lpUsedDefaultChar // address of flag set when default char. used  <br>); <br>*/ <br>// Server <br>(void)(WideCharToMultiByte(CP_ACP, <br>  0, <br>  lpSI-&gt;szValidServer0, <br>  lstrlen(lpSI-&gt;szValidServer0), <br>  aszServer, <br>  sizeof(aszServer), <br>  NULL, <br>  NULL)); <br>aszServer[lstrlen(lpSI-&gt;szValidServer0)]=TEXT('\0'); <br> <br>// UID <br>(void)(WideCharToMultiByte(CP_ACP, <br>  0, <br>  lpSI-&gt;szValidLogin0, <br>  lstrlen(lpSI-&gt;szValidLogin0), <br>  aszLogin, <br>  sizeof(aszLogin), <br>  NULL, <br>  NULL)); <br>aszLogin[lstrlen(lpSI-&gt;szValidLogin0)]=TEXT('\0'); <br> <br>// PWD <br>(void)(WideCharToMultiByte(CP_ACP, <br>  0, <br>  lpSI-&gt;szValidPassword0, <br>  lstrlen(lpSI-&gt;szValidPassword0), <br>  aszPassword, <br>  sizeof(aszPassword), <br>  NULL, <br>  NULL)); <br>aszPassword[lstrlen(lpSI-&gt;szValidPassword0)]=TEXT('\0'); <br> <br>// Select stmt <br>(void)(WideCharToMultiByte(CP_ACP, <br>  0, <br>  wszQuery, <br>  lstrlen(wszQuery), <br>  aszQuery, <br>  sizeof(aszQuery), <br>  NULL, <br>  NULL)); <br>aszQuery[lstrlen(wszQuery)]=TEXT('\0'); <br> <br>// Table name <br>(void)(WideCharToMultiByte(CP_ACP, <br>  0, <br>  wszTable, <br>  lstrlen(wszTable), <br>  aszQuery, <br>  sizeof(aszTable), <br>  NULL, <br>  NULL)); <br>aszTable[lstrlen(wszTable)]=TEXT('\0'); <br> <br>#else <br>// Copy the ANSI strings <br>lstrcpy(aszServer, lpSI-&gt;szValidServer0); <br>lstrcpy(aszLogin, lpSI-&gt;szValidLogin0); <br>lstrcpy(aszPassword, lpSI-&gt;szValidPassword0); <br>lstrcpy(aszTable, lpqt-&gt;szTableName); <br>wsprintf(aszQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br> <br>// Convert and copy to Unicode strings <br>/* <br>int MultiByteToWideChar( <br> UINT  CodePage,// code page  <br> DWORD  dwFlags,// character-type options  <br> LPCSTR  lpMultiByteStr,// address of string to map  <br> int  cchMultiByte,// number of characters in string  <br> LPWSTR  lpWideCharStr,// address of wide-character buffer  <br> int  cchWideChar // size of buffer  <br>); <br>*/ <br> <br>// Server <br>(void) MultiByteToWideChar(CP_ACP, <br>0, <br>lpSI-&gt;szValidServer0, <br>lstrlen(lpSI-&gt;szValidServer0), <br>wszServer, <br>sizeof(wszServer)/sizeof(WCHAR) <br>); <br>wszServer[lstrlen(lpSI-&gt;szValidServer0)]=TEXT('\0'); <br> <br>// UID <br>(void) MultiByteToWideChar(CP_ACP, <br>0, <br>lpSI-&gt;szValidLogin0, <br>lstrlen(lpSI-&gt;szValidLogin0), <br>wszLogin, <br>sizeof(wszLogin)/sizeof(WCHAR) <br>); <br>wszLogin[lstrlen(lpSI-&gt;szValidLogin0)]=TEXT('\0'); <br> <br>// PWD <br>(void) MultiByteToWideChar(CP_ACP, <br>0, <br>lpSI-&gt;szValidPassword0, <br>lstrlen(lpSI-&gt;szValidPassword0), <br>wszPassword, <br>sizeof(wszPassword)/sizeof(WCHAR) <br>); <br>wszPassword[lstrlen(lpSI-&gt;szValidPassword0)]=TEXT('\0'); <br> <br>// Select stmt <br>(void) MultiByteToWideChar(CP_ACP, <br>0, <br>aszQuery, <br>lstrlen(aszQuery), <br>wszQuery, <br>sizeof(wszQuery)/sizeof(WCHAR) <br>); <br>wszQuery[lstrlen(aszQuery)]=TEXT('\0'); <br> <br>// Table name <br>(void) MultiByteToWideChar(CP_ACP, <br>0, <br>aszTable, <br>lstrlen(aszTable), <br>wszTable, <br>sizeof(wszTable)/sizeof(WCHAR) <br>); <br>wszTable[lstrlen(aszTable)]=TEXT('\0'); <br> <br>#endif <br> <br>// Allocate connection for ANSI <br>rc = SQLAllocConnect(henv, &amp;hdbcANSI); <br>RETCHECK(SQL_SUCCESS, rc, szSQLALLOCCONNECT); <br> <br>// Allocate connection for Unicode <br>rc = SQLAllocConnect(henv, &amp;hdbcUnicode); <br>RETCHECK(SQL_SUCCESS, rc, szSQLALLOCCONNECT); <br> <br>// If Unicode is defined, then strings need to be converted to ANSI <br>// before calling SQLConnectA <br>rc = SQLConnectA(hdbcANSI, (LPSTR)aszServer, SQL_NTS, <br>(LPSTR)aszLogin, SQL_NTS, <br>(LPSTR)aszPassword, SQL_NTS); <br>if (!RC_SUCCESSFUL(rc)) <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcANSI, SQL_SUCCESS, rc,szSQLCONNECT); <br> <br>rc = SQLConnectW(hdbcUnicode, (LPWSTR)wszServer, SQL_NTS, <br>(LPWSTR)wszLogin, SQL_NTS, <br>(LPWSTR)wszPassword, SQL_NTS); <br>if (!RC_SUCCESSFUL(rc)) <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcUnicode, SQL_SUCCESS, rc,szSQLCONNECTW); <br> <br>// Test mixed SQLNativeSQL callson the ANSI connection <br>rc=SQLNativeSqlA(hdbcANSI, aszQuery, strlen(aszQuery), aszBuf, sizeof(aszBuf), &amp;cbANSI); <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcANSI, SQL_SUCCESS, rc,szSQLNATIVESQL); <br>rc=SQLNativeSqlW(hdbcANSI,wszQuery, wcslen(wszQuery)*sizeof(WCHAR), wszBuf, sizeof(wszBuf), <br>&amp;cbUnicode); <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcANSI, SQL_SUCCESS, rc,szSQLNATIVESQL); <br> <br>CompareAnsiToUnicode(aszBuf, cbANSI, wszBuf, cbUnicode, szSQLNATIVESQLW); <br> <br>// Allocate stmt handles for ANSI connection <br>rc = SQLAllocStmt(hdbcANSI, &amp;hstmtANSIA);// Handle for ANSI calls <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcANSI, SQL_SUCCESS, rc,szSQLALLOCSTMT); <br>rc = SQLAllocStmt(hdbcANSI, &amp;hstmtANSIW);// Handle for Unicode calls <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcANSI, SQL_SUCCESS, rc,szSQLALLOCSTMT); <br> <br>// Allocate stmt handles for Unicode connection <br>rc = SQLAllocStmt(hdbcUnicode, &amp;hstmtUA); // Handle for ANSI calls <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcUnicode, SQL_SUCCESS, rc,szSQLALLOCSTMT); <br>rc = SQLAllocStmt(hdbcUnicode, &amp;hstmtUW); // Handle for Unicode calls <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcUnicode, SQL_SUCCESS, rc,szSQLALLOCSTMT); <br> <br>// Call SQLTablesA&amp;W on two different hdbcs <br>strcpy(aszBuf,"%"); <br>wcscpy(wszBuf,L"%"); <br>rc = SQLTablesA(hstmtANSIA, NULL, 0, NULL, 0, aszBuf, SQL_NTS, NULL, 0); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtANSIA, SQL_SUCCESS, rc, szSQLTABLESA); <br>rc = SQLTablesW(hstmtUW, NULL, 0, NULL, 0, wszBuf, SQL_NTS, NULL, 0); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtUW, SQL_SUCCESS, rc, szSQLTABLESW); <br> <br>// Compare the two result sets <br>CompareAnsiUnicodeResults(hstmtANSIA, hstmtUW, szSQLTABLESW); <br> <br>// See if the driver supports multiple active stmts <br>rc = SQLGetInfo(hdbcANSI, SQL_ACTIVE_STATEMENTS, &amp;fStmts, 0, NULL); <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcANSI, SQL_SUCCESS, rc, szSQLGETINFO); <br> <br>// Create a search string for ANSI <br>aszBuf[0]=aszTable[0]; <br>aszBuf[1]=TEXT('\0'); <br>strcat(aszBuf,"%"); <br> <br>// Create a search string for Unicode <br>wszBuf[0]=wszTable[0]; <br>wszBuf[1]=TEXT('\0'); <br>wcscat(wszBuf,L"%"); <br> <br>// If the allowed active statements is &gt; 1, then use the same connection <br>// otherwise use the other connection <br>if (fStmts &gt; 1) <br>hstmtW=hstmtUW; <br>else <br>hstmtW=hstmtANSIW; <br> <br>// Call SQLColumnsA&amp;W on two different hstmts (same connection if allowed) <br>// Call for only the given table to limit compare errors at this time <br>rc = SQLColumnsA(hstmtUA, NULL, 0, NULL, 0, aszTable, SQL_NTS, NULL, 0); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtANSIA, SQL_SUCCESS, rc, szSQLCOLUMNSA); <br> <br>// Call for only the given table to limit compare errors at this time <br>rc = SQLColumnsW(hstmtW, NULL, 0, NULL, 0, wszTable, SQL_NTS, NULL, 0); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtW, SQL_SUCCESS, rc, szSQLCOLUMNSW); <br> <br>CompareAnsiUnicodeResults(hstmtUA, hstmtW, szSQLCOLUMNSW); <br> <br>rc = SQLExecDirectA(hstmtUA, aszQuery, SQL_NTS); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtUA, SQL_SUCCESS, rc, szSQLEXECDIRECTA); <br> <br>// Call for only the given table to limit compare errors at this time <br>rc = SQLExecDirectW(hstmtW, wszQuery, SQL_NTS); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtW, SQL_SUCCESS, rc, szSQLEXECDIRECTW); <br> <br>CompareAnsiUnicodeResults(hstmtUA, hstmtW, szSQLEXECDIRECTW); <br> <br>// Disconnect and free ANSI handles <br>rc=SQLFreeStmt(hstmtANSIA, SQL_DROP); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtANSIA, SQL_SUCCESS, rc,szSQLFREESTMT); <br>rc=SQLFreeStmt(hstmtANSIW, SQL_DROP); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtANSIW, SQL_SUCCESS, rc,szSQLFREESTMT); <br>rc=SQLDisconnect(hdbcANSI); <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcANSI, SQL_SUCCESS, rc,szSQLCONNECT); <br>rc=SQLFreeConnect(hdbcANSI); <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcANSI, SQL_SUCCESS, rc,szSQLCONNECT); <br>// Disconnect and free Unicode handles <br>rc=SQLFreeStmt(hstmtUA, SQL_DROP); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtUA, SQL_SUCCESS, rc,szSQLFREESTMT); <br>rc=SQLFreeStmt(hstmtUW, SQL_DROP); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmtUW, SQL_SUCCESS, rc,szSQLFREESTMT); <br>rc=SQLDisconnect(hdbcUnicode); <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcUnicode, SQL_SUCCESS, rc,szSQLCONNECT); <br>rc=SQLFreeConnect(hdbcUnicode); <br>ERRSHANDLE(SQL_HANDLE_DBC, hdbcUnicode, SQL_SUCCESS, rc,szSQLCONNECT); <br> <br>} /* TestMixedAnsiUnicode() */ <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestStmtOptions <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestStmtOptions() <br>{ <br>UDWORDdwLen, <br>udw; <br>BOOLfConnectOption; <br>RETCODErc=SQL_SUCCESS; <br>TCHARszAPI[MEDBUFF]; <br>SDWORDcbValue=0; <br> <br>SetStatementAttributes(SQL_MAX_LENGTH,(PTR)&amp;udw); <br> <br>if (SetStatementAttributes(SQL_MAX_LENGTH, (PTR)TEST_STMT_OPTION)) <br>fConnectOption = TRUE; <br> <br>if (Supported(SQL_API_SQLGETSTMTATTR)) <br>{ <br>rc = SQLGetStmtAttr(hstmt, SQL_MAX_LENGTH, (PTR)&amp;dwLen,sizeof(dwLen),&amp;cbValue); <br>lstrcpy(szAPI,szSQLGETSTMTATTR); <br>} <br>else <br>{ <br>rc = SQLGetStmtOption(hstmt, SQL_MAX_LENGTH, &amp;dwLen); <br>lstrcpy(szAPI,szSQLGETSTMTOPTION); <br>} <br> <br>if(rc != SQL_SUCCESS) <br>{ <br>if(!FindError(SQL_HANDLE_STMT,szHYC00)) <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTOPTION); <br>} <br>else <br>{ <br>if(dwLen != TEST_STMT_OPTION &amp;&amp; rc == SQL_SUCCESS &amp;&amp; fConnectOption) <br>DISPLAYERROR(szSQLGETSTMTOPTION,TEXT("incorrect SQL_MAX_LENGTH value returned")); <br>} <br> <br> <br>} //TestStmtOptions() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               SetTableName <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL SetTableName(QTSTRUCT  *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDcTableName; <br>TCHARszTime[MEDBUFF]=TEXT(""), <br>szTmpBuff[MEDBUFF], <br>*pTime=NULL; <br> <br>_tstrtime(szTmpBuff); <br> <br>/* Remove colons */ <br>pTime=_tcstok(szTmpBuff, TEXT(":")); <br>while (pTime) <br>{ <br>lstrcat(szTime,pTime); <br>pTime=_tcstok(NULL, TEXT(":")); <br>} <br>  <br>rc = SQLGetInfo(hdbc, SQL_MAX_TABLE_NAME_LEN, &amp;cTableName, <br>sizeof (int), NULL); <br>if(rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>rc = SQLGetInfo(hdbc, SQL_QUALIFIER_NAME_SEPARATOR, lpqt-&gt;buf, <br>MAX_STRING_SIZE, NULL); <br>if(rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>if(!lstrcmp(TEXT("\\"), lpqt-&gt;buf)) <br>cTableName -= 4; <br> <br>_sntprintf(lpqt-&gt;szTableName, min(cTableName, MAX_TABLE_NAME-1), <br>TEXT("q%s"), szTime); <br> <br>} //SetTableName() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               AllowedType <br>// <br>//If swNumTypes &gt; 0, limits SQL types to those in array <br>//----------------------------------------------------------------------- <br>BOOL AllowedType(SWORD fType) <br>{ <br>SWORD i, swNumTypes=0; <br>BOOL bAllowed=TRUE; <br>SWORD rgAllowedTypes[MAX_TYPES_SUPPORTED]={ <br>SQL_CHAR, <br>SQL_BINARY <br>//SQL_BIT <br>/* <br>SQL_TINYINT <br>SQL_NUMERIC, <br>SQL_INTEGER, <br>SQL_SMALLINT, <br>SQL_FLOAT, <br>SQL_REAL, <br>SQL_TYPE_TIMESTAMP, <br>SQL_LONGVARBINARY, <br>SQL_LONGVARCHAR <br>*/ <br>}; <br> <br>if (swNumTypes &gt; 0) <br>{ <br>bAllowed=FALSE; <br> <br>for (i=0; i &lt; swNumTypes; i++) <br>{ <br>if (fType == rgAllowedTypes[i]) <br>bAllowed=TRUE; <br>} <br>} <br> <br>return bAllowed; <br>} <br> <br>//----------------------------------------------------------------------- <br>//      Function:               GetTypeInfo <br>//----------------------------------------------------------------------- <br> <br>UWORD  PASCAL GetTypeInfo(FIELDINFO  *rgFields,QTSTRUCT  *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORD       cFieldName; <br>SDWORD      cMaxTypeSize, cMaxRowSize; <br>UWORD       i, <br>cTypes=0; <br>SDWORD      sdw; <br>LPTSTR       pch=NULL; <br>BOOLfAutoInc=0; <br> <br>/* Get the type information to use in a create statement for a table */ <br> <br>rc = SQLGetInfo(hdbc, SQL_MAX_COLUMN_NAME_LEN, &amp;cFieldName, <br>sizeof cFieldName, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>rc = SQLGetInfo(hdbc, SQL_MAX_ROW_SIZE, &amp;cMaxRowSize, <br>sizeof cMaxRowSize, NULL); <br>/* don't check for SQL_SUCCES here, it's a 2.0 function.  If it's successful <br>That's great, if not then no maximum is assumed. */ <br> <br>cMaxTypeSize = cMaxRowSize / MAX_TYPES_SUPPORTED; <br> <br>/* TO DO: add checks in here for dos file types GetInfo SQL_QUALIFIER_NAME_SEPARATER */ <br> <br>if(cFieldName &gt; MAX_FIELD - 1) <br>cFieldName = MAX_FIELD - 1; <br> <br>if(cFieldName &lt; PREFIX_SIZE) <br>{ <br>DISPLAYERROR(szSQLGETINFO,TEXT("MAX_COLUMN_NAME_LEN is too small for autotest to run")); <br>goto TypeErrorRet; <br>} <br> <br>rc = SQLGetTypeInfo(hstmt, SQL_ALL_TYPES); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETTYPEINFO); <br> <br>for(i = 0; i &lt; MAX_TYPES_SUPPORTED; i++) <br>{ <br> <br>rc = SQLFetch(hstmt); <br>if(rc != SQL_SUCCESS &amp;&amp; rc !=SQL_SUCCESS_WITH_INFO) <br>break; <br> <br>*rgFields[i].szType = *rgFields[i].szLength = *rgFields[i].szParams = TEXT('\0'); <br> <br>/* get type name */ <br>rc = SQLGetData(hstmt, 1, SQL_C_TCHAR, <br>rgFields[i].szType, MAX_TYPE_NAME, &amp;sdw); <br> <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>wsprintf(rgFields[i].szFieldName,TEXT("c%02u"), i+COLNAME_START); <br>/* copy first portion of type name for easy reference */ <br>_tcsnccat(rgFields[i].szFieldName, rgFields[i].szType, TYPE_PORTION); <br> <br> <br>/* change spaces in field name to '_' */ <br>while((pch = (LPTSTR)_tcschr(rgFields[i].szFieldName, TEXT(' '))) != NULL) <br>*pch = TEXT('_'); <br> <br>/* get the SQLType */ <br>rc = SQLGetData(hstmt, 2, SQL_C_DEFAULT, <br>(SWORD  *)&amp;rgFields[i].wSQLType, IGNORED, <br>&amp;sdw); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>/* Max length */ <br>rc = SQLGetData(hstmt, 3, SQL_C_TCHAR, <br>rgFields[i].szLength, MAX_FIELD, &amp;sdw); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>/* limit the row size for those drivers that don't support a long <br>enough row length for all the fields to be at the max length */ <br>switch(rgFields[i].wSQLType) <br>{ <br>case SQL_CHAR: <br>case SQL_VARCHAR: <br>case SQL_VARBINARY: <br>case SQL_BINARY: <br>case SQL_LONGVARCHAR: <br>case SQL_LONGVARBINARY: <br> <br>if(cMaxTypeSize) <br>{ <br>if(_ttol (rgFields[i].szLength) &gt; cMaxTypeSize) <br>_ltot(cMaxTypeSize, rgFields[i].szLength, 10); <br>} <br>} <br> <br>/* prefix */ <br>rc = SQLGetData(hstmt, 4, SQL_C_TCHAR, <br>rgFields[i].szPrefix, MAX_PREFIX, &amp;sdw); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>/* suffix */ <br>rc = SQLGetData(hstmt, 5, SQL_C_TCHAR, <br>rgFields[i].szSuffix, MAX_SUFFIX, &amp;sdw); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>/* create params */ <br>rc = SQLGetData(hstmt, 6, SQL_C_TCHAR, <br>rgFields[i].szParams, MAX_PARAM_SIZE, &amp;sdw); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>/* nullable */ <br>rc = SQLGetData(hstmt, 7, SQL_C_SHORT, &amp;rgFields[i].nullable, IGNORED, <br>&amp;sdw); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>/* searchable */ <br>rc = SQLGetData(hstmt, 9, SQL_C_SHORT, &amp;rgFields[i].fSearchable, IGNORED, <br>&amp;sdw); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>/* autoincrement */ <br>rc = SQLGetData(hstmt, 12, SQL_C_SHORT, &amp;rgFields[i].autoinc, IGNORED, <br>&amp;sdw); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA)) <br>goto TypeErrorRet; <br> <br>// Since some data types will have NULL for autoincrement, we need to set to FALSE <br>if (SQL_NULL_DATA == sdw) <br>rgFields[i].autoinc=FALSE; <br> <br>if (IgnoreType(rgFields[i].szType,rgFields[i].wSQLType)) <br>{ <br>i--; <br>continue; <br>} <br> <br>/* The following code only allows the first autoincrement column to <br>be placed in the table.  Many DBMS's do not allow more than one per table. */ <br>if(rgFields[i].autoinc == TRUE) <br>{ <br>if(fAutoInc) <br>{ <br>i--; <br>continue; <br>} <br>else <br>fAutoInc = TRUE; <br>} <br> <br>// Limit data types to those desired (use for debugging) <br>if (!AllowedType(rgFields[i].wSQLType)) <br>{ <br>i--; <br>continue; <br>} <br>} <br> <br>cTypes = i; <br> <br>/* if the type name contains spaces, replace them with _ because <br>most servers don't allow spaces in field names */ <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>rc = SQLFreeStmt(hstmt, SQL_CLOSE); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREESTMT); <br> <br>SetTableName(lpqt); <br> <br>return(cTypes); <br> <br>TypeErrorRet: <br> <br>return(0); <br> <br>} //GetTypeInfo() <br> <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               BuildCreateStmt <br>//----------------------------------------------------------------------- <br> <br>BOOL  PASCAL BuildCreateStmt(QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHAR        szNum[MAX_NUM_BUFFER];   /* used with _ttoi and itoa conversions */ <br>SWORD       wNum; <br>UWORD       i; <br>SDWORD      sdw; <br>LPTSTR       pch=NULL; <br> <br> <br>/* the column names will be ctypname (where typename is the <br>type name returned by the source in SQLGetTypeInfo) */ <br> <br>*lpqt-&gt;sz = TEXT('\0'); <br>lstrcpy(lpqt-&gt;sz,TEXT("Create Table ")); <br>lstrcat(lpqt-&gt;sz, lpqt-&gt;szTableName); <br>lstrcat(lpqt-&gt;sz,TEXT(" (")); <br>for(i = 0; i &lt; cTypes; i++) { <br>TCHAR szParamType[50]; <br>TCHAR szNotNull[10]; <br>*lpqt-&gt;szParam = TEXT('\0'); <br> <br>/* if SQLGetTypeInfo returned params they need to be used in <br>the create statement */ <br> <br>if(rgFields[i].szParams == NULL || lstrlen(rgFields[i].szParams) == 0) <br>*lpqt-&gt;szParam = TEXT('\0'); <br>else if(_tcschr(rgFields[i].szParams, TEXT(',')) == NULL) <br>wsprintf(lpqt-&gt;szParam,TEXT("(%s)"), rgFields[i].szLength); <br>else <br>{ <br>lstrcpy(szNum, rgFields[i].szLength); <br>wsprintf(lpqt-&gt;szParam,TEXT("(%s, %d)"), rgFields[i].szLength, <br>_ttoi(szNum) - SCALEDIFF); <br>} <br> <br>lstrcpy(szParamType, rgFields[i].szType); <br>if(pch = _tcschr((LPTSTR)szParamType, TEXT('(')))  <br>{ <br>*pch = TEXT('\0'); <br>lstrcat(szParamType, lpqt-&gt;szParam); <br>lstrcat(szParamType, (LPTSTR)_tcschr(rgFields[i].szType, TEXT(')')) + 1); <br>} <br>else <br>{ <br>lstrcat(szParamType, lpqt-&gt;szParam); <br>} <br> <br>/* If the field is not nullable, we need to create the table that way */ <br>rc = SQLGetInfo(hdbc, SQL_NON_NULLABLE_COLUMNS, &amp;wNum, <br>sizeof (SWORD), NULL); <br>if(rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>if((rgFields[i].nullable == SQL_NO_NULLS) &amp;&amp; (wNum != SQL_NNC_NULL)) <br>lstrcpy(szNotNull,TEXT("NOT NULL")); <br>else <br>szNotNull[0] = TEXT('\0'); <br> <br>wsprintf(&amp;lpqt-&gt;sz[lstrlen(lpqt-&gt;sz)],TEXT(" %s %s %s ,"), <br>rgFields[i].szFieldName, (LPTSTR)szParamType, (LPTSTR)szNotNull); <br>} <br> <br>/* remove the last comma and space */ <br>lpqt-&gt;sz[lstrlen(lpqt-&gt;sz) - 2] = TEXT('\0'); <br>lstrcat(lpqt-&gt;sz,TEXT(")")); <br> <br>rc = SQLExecDirect(hstmt, lpqt-&gt;sz, SQL_NTS); <br>if(rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT)) <br>goto BuildErrorRet; <br> <br>/* now that table was created, call SQLColumns.  Both as <br>a test and to get necessary information to insert data */ <br> <br>rc = SQLColumns(hstmt, NULL, SQL_NTS, NULL, SQL_NTS, <br>lpqt-&gt;szTableName, SQL_NTS, NULL, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLCOLUMNS); <br> <br>for(i = 0; i &lt; cTypes; i++) { <br>rc = SQLFetch(hstmt); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFETCH); <br> <br>/* precision */ <br>rc = SQLGetData(hstmt, 7, SQL_C_LONG, &amp;rgFields[i].precision, IGNORED, <br>&amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br> <br>/* length */ <br>if((rgFields[i].precision == 0) || (sdw == SQL_NO_TOTAL)){ <br>rc = SQLGetData(hstmt, 8, SQL_C_LONG, &amp;rgFields[i].precision, IGNORED, <br>&amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br>if(sdw == SQL_NO_TOTAL)/* precision &amp; length were undetermined */ <br>rgFields[i].precision = 1000;/* so set it to an arbitary value */ <br>} <br> <br>/* numeric scale */ <br>rc = SQLGetData(hstmt, 9, SQL_C_SHORT, &amp;rgFields[i].scale, IGNORED, <br>&amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br>if(sdw == SQL_NO_TOTAL) <br>rgFields[i].scale = 0; <br>} <br> <br>rc = SQLFreeStmt(hstmt, SQL_CLOSE); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREESTMT); <br> <br>/* look for columns the test should not try to update by running <br>a select * query and calling ColAttributes on the result fields */ <br>/* select * does not return the fields in a defined order, so field order <br>must be specified */ <br> <br>lstrcpy(lpqt-&gt;sz,TEXT("select ")); <br>for(i = 0; i &lt; cTypes; i ++) { <br>if(i) <br>lstrcat(lpqt-&gt;sz,TEXT(",")); <br>lstrcat(lpqt-&gt;sz, rgFields[i].szFieldName); <br>} <br> <br>lstrcat(lpqt-&gt;sz,TEXT(" from ")); <br>lstrcat(lpqt-&gt;sz, lpqt-&gt;szTableName); <br> <br>rc = SQLExecDirect(hstmt, lpqt-&gt;sz, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>for(i = 1; i &lt;= cTypes; i++) { <br> <br>rc = SQLColAttributes(hstmt, i, SQL_COLUMN_UPDATABLE, NULL, <br>0, NULL, &amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLCOLATTRIBUTES); <br> <br>rgFields[i - 1].fAutoUpdate = sdw == SQL_ATTR_READONLY; <br> <br>rc = SQLColAttributes(hstmt, i, SQL_COLUMN_UNSIGNED, NULL, <br>0, NULL, &amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLCOLATTRIBUTES); <br> <br>rgFields[i - 1].fUnsigned = sdw; <br>} <br> <br>rc = SQLFreeStmt(hstmt, SQL_CLOSE); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREESTMT); <br> <br>return(FALSE); <br> <br>BuildErrorRet: <br> <br>return(TRUE); <br> <br>} //BuildCreateStmt() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               BuildInsertStmt <br>//----------------------------------------------------------------------- <br>   <br>BOOL  PASCAL BuildInsertStmt(QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes, <br>DSTRUCT  *lpd,SDWORD  *cColsSelected,BOOL fBindParameter) <br>{ <br>RETCODE  rc; <br>UWORD    w; <br>UWORD    i; <br>PTRptr; <br>UWORD    ind; <br>SDWORD   sdw; <br>LPTSTR    pch=NULL; <br>BOOLfColNames=TRUE, <br>fLongData=FALSE; <br>SDWORD  *sdwArray = (SDWORD  *)AllocateMemory(sizeof(SDWORD) * MAX_TYPES_SUPPORTED); <br> <br>lstrcpy(lpqt-&gt;szColNames,TEXT("\0")); <br>lstrcpy(lpqt-&gt;szValues,TEXT("\0")); <br> <br>for(i = 0; i &lt; cTypes; i++) { <br> <br>for(ind = 0, w = 0; ind &lt; cTypes; ind++) { <br> <br>pch = qtMakeData(i, ind,&amp;rgFields[ind], lpqt-&gt;szDataItem); <br> <br>if(!pch) /* current type is READ_ONLY) */ <br>continue; <br> <br>/* for every nullable type, that field will be set to */ <br>/* null when the row number corresponds with the field */ <br>/* number */ <br> <br>if(*pch)  <br>{ <br>lstrcpy(lpd[w].data, pch); <br>lpd[w].cb = SQL_NTS; <br>} <br>else  <br>{ <br>lstrcpy(lpd[w].data,TEXT("")); <br>lpd[w].cb = SQL_NULL_DATA; <br>} <br> <br>if(fColNames)  <br>{ <br>/* the first time throught, the insert */ <br>/* statement itself is created         */ <br>lstrcat(lpqt-&gt;szColNames, rgFields[ind].szFieldName); <br>lstrcat(lpqt-&gt;szColNames,TEXT(", ")); <br>lstrcat(lpqt-&gt;szValues,TEXT(" ?, ")); <br> <br>/* and parameters are set */ <br>/* set all the parameters using pointers to buffers in*/ <br>/* the param struct. */ <br>if(!fBindParameter) <br>{ <br>rc = SQLSetParam(hstmt, (UWORD)(w+1), <br>SQL_C_TCHAR, rgFields[ind].wSQLType, <br>rgFields[ind].precision, rgFields[ind].scale, <br>&amp;lpd[w].data, <br>&amp;lpd[w].cb); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETPARAM); <br>} <br>else <br>{ <br>rc = SQLBindParameter(hstmt, (UWORD)(w+1), <br>SQL_PARAM_INPUT, <br>SQL_C_TCHAR, rgFields[ind].wSQLType, <br>rgFields[ind].precision, rgFields[ind].scale, <br>&amp;lpd[w].data, MAX_STRING_SIZE, <br>&amp;lpd[w].cb); <br>RETCHECK(SQL_SUCCESS, rc,szSQLBINDPARAMETER); <br>} <br>} <br>w++; <br>cNumResSetCols=w; <br>} <br> <br>if(fColNames)  <br>{  <br>/* the first time through, the insert*/ <br>/* statement needs to be SQLPrepare'd*/ <br>/* remove the "," at the end of the string*/ <br>lpqt-&gt;szColNames[lstrlen(lpqt-&gt;szColNames) - 2] = TEXT('\0'); <br>lpqt-&gt;szValues[lstrlen(lpqt-&gt;szValues) - 2] = TEXT('\0'); <br> <br>wsprintf(lpqt-&gt;sz,TEXT("insert into %s (%s) VALUES(%s)"), <br>lpqt-&gt;szTableName, lpqt-&gt;szColNames, lpqt-&gt;szValues); <br> <br>//copy the insert statement, with the column names.  <br>//_ASSERTE(lstrlen(lpqt-&gt;sz) &lt; MAX_STRING_SIZE); <br>lstrcpy(szInsertStmt,lpqt-&gt;sz); <br> <br>//prepare the statement <br>rc = SQLPrepare(hstmt, lpqt-&gt;sz, SQL_NTS); <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLPREPARE)) <br>goto InsertErrorRet; <br> <br>fColNames = FALSE; /* no more first times through */ <br>} <br> <br>rc = SQLExecute(hstmt); /* insert a row */ <br> <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLEXECUTE)) <br>{ <br>if (SQL_SUCCESS_WITH_INFO != rc)// BANDAID, normally would fail on S.W.I <br>goto InsertErrorRet; <br>} <br> <br>rc = SQLRowCount(hstmt, &amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLROWCOUNT); <br> <br>if(sdw != 1) /* the execute inserted 1 row */ <br>DISPLAYERROR(szSQLROWCOUNT,TEXT("Insert single row")); <br> <br>/* FreeStmt SQL_CLOSE */ <br>rc = SQLFreeStmt(hstmt, SQL_CLOSE); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREESTMT); <br>} <br> <br>/* for the last row use SQLParamData and SQLPutData */ <br> <br>/* First check to see if the SQL_LEN_DATA_AT_EXEC macro is supported */ <br>rc = SQLGetInfo(hdbc, SQL_NEED_LONG_DATA_LEN, lpqt-&gt;buf, (SWORD)sizeof(lpqt-&gt;buf), NULL); <br>if(rc == SQL_SUCCESS) <br>if(lpqt-&gt;buf[0] == TEXT('Y')) <br>fLongData = TRUE; <br> <br>for(ind = 0, w = 0; ind &lt; cTypes; ind++)  <br>{  <br> <br>/* set all the params */ <br> <br>if(rgFields[ind].fAutoUpdate) <br>continue; <br> <br>if(fLongData &amp;&amp; ((rgFields[ind].wSQLType == SQL_LONGVARBINARY) ||  <br>(rgFields[ind].wSQLType == SQL_LONGVARCHAR))){ <br>/* Make sure we don't exceed the max negative SDWORD value */ <br>if(rgFields[ind].precision &gt; (MAXSDWORD + SQL_LEN_DATA_AT_EXEC_OFFSET)) <br>sdwArray[ind] = MINSDWORD - SQL_LEN_DATA_AT_EXEC_OFFSET; <br>else <br>sdwArray[ind] = SQL_LEN_DATA_AT_EXEC(rgFields[ind].precision); <br>} <br>else <br>sdwArray[ind] = SQL_DATA_AT_EXEC; <br> <br>w++; <br>if(!fBindParameter){ <br>rc = SQLSetParam(hstmt, w, <br>SQL_C_TCHAR, rgFields[ind].wSQLType, <br>rgFields[ind].precision, rgFields[ind].scale, <br>(LPTSTR)(UDWORD)ind, &amp;sdwArray[ind]); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETPARAM); <br>} <br>else{ <br>rc = SQLBindParameter(hstmt, w, SQL_PARAM_INPUT, <br>SQL_C_TCHAR, rgFields[ind].wSQLType, <br>rgFields[ind].precision, rgFields[ind].scale, <br>(LPTSTR)(((UDWORD)ind)+BIND_PARM_OFFSET), 0, &amp;sdwArray[ind]); <br>RETCHECK(SQL_SUCCESS, rc,szSQLBINDPARAMETER); <br>} <br>} <br> <br>*cColsSelected = w; <br> <br>rc = SQLExecDirect(hstmt, lpqt-&gt;sz, SQL_NTS); <br>if (!RETCHECK(SQL_NEED_DATA, rc,szSQLEXECDIRECT)) <br>goto InsertErrorRet; <br> <br> <br>for(ind = 0; ind &lt;= cTypes; ind++)  <br>{ <br>rc = SQLParamData(hstmt, &amp;ptr); <br>if(rc != SQL_NEED_DATA) <br>break; <br> <br>pch = qtMakeData(cTypes, ind, &amp;rgFields[(unsigned long)ptr-BIND_PARM_OFFSET], <br>lpqt-&gt;szDataItem); <br> <br>if(*pch) { <br>rc = SQLPutData(hstmt, pch, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPUTDATA); <br>} else { <br>rc = SQLPutData(hstmt, (LPTSTR)IGNORED, SQL_NULL_DATA); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPUTDATA); <br>} <br>} <br>   <br>RETCHECK(SQL_SUCCESS, rc,szSQLPARAMDATA); <br> <br>rc = SQLRowCount(hstmt, &amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLROWCOUNT); <br> <br>if(sdw != 1) <br>DISPLAYERROR(szSQLROWCOUNT,TEXT("Insert single row")); <br> <br>rc = SQLFreeStmt(hstmt, SQL_RESET_PARAMS); </code></pre>
<p>
</p>
<pre><code>RETCHECK(SQL_SUCCESS, rc,szSQLFREESTMT); <br> <br> <br> <br>ReleaseMemory(sdwArray); <br> <br>return(FALSE); <br> <br>InsertErrorRet: <br> <br>ReleaseMemory(sdwArray); <br>  <br>return(TRUE); <br> <br>} //BuildInsertStmt() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               FullDisconnect <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL FullDisconnect() <br>{  <br>RETCODE rc=SQL_SUCCESS; <br> <br>/* SQLCancel has the same functionality as SQLFreeStmt w/ SQL_CLOSE*/ <br>/*in a non-asynchronous environment */ <br> <br>rc = SQLCancel(hstmt); <br>RETCHECK(SQL_SUCCESS, rc,szSQLCANCEL); <br> <br>FreeStmt(SQL_DROP); <br> <br>/* if the connection was made in the*/ <br>/*test, it should be disconnected*/ <br>/* in the test, otherwise it should be left connected */ <br> <br>rc = SQLDisconnect(hdbc); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDISCONNECT); <br> <br>rc = SQLFreeConnect(hdbc); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREECONNECT); <br> <br>rc = SQLFreeEnv(henv); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREEENV); <br> <br> <br>} //FullDisconnect() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               DropTable <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL DropTable(LPTSTR szTableName, BOOL fSilent) <br>{ <br>TCHARszBuff[100]; <br>RETCODErc=SQL_ERROR; <br> <br>lstrcpy(szBuff,TEXT("drop table ")); <br>lstrcat(szBuff, szTableName); <br> <br>rc = SQLExecDirect(hstmt, szBuff, SQL_NTS); <br> <br>if (!fSilent) <br>{ <br>if(!RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT)) <br>szWrite(TEXT("Unable to drop table"), TRUE); <br>} <br> <br>} //DropTable() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//    Function:CleanUp <br>//Purpose:To drop the table,disconnect from data source and <br>//release memory. <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL CleanUp(DSTRUCT  *lpd,QTSTRUCT  *lpqt,FIELDINFO  *rgFields, <br>LPTSTR szTableName,BOOL fSilent,LPTSTR szValidServer) <br>{ <br> <br>DropTable(szTableName, fSilent); <br> <br>if(szValidServer) <br>FullDisconnect(); <br> <br>ReleaseMemory(lpd); <br>ReleaseMemory(lpqt); <br>ReleaseMemory(rgFields); <br> <br>} //CleanUp() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               BindAllColumns <br>//----------------------------------------------------------------------- <br> <br>BOOL  PASCAL BindAllColumns(QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes, <br>DSTRUCT  *lpd) <br>{ <br>//----------------------------------------------------------------------- <br>//      Function:               BindAllColumns <br>UWORDi, <br>w; <br>RETCODErc=SQL_SUCCESS; <br> <br>for(i = 0, w = 0; i &lt; cTypes; i++)  <br>{ <br> <br>if(!qtMakeData(1, i,&amp;rgFields[i],lpqt-&gt;szDataItem)) <br>continue; <br> <br>w++; <br> <br>switch(rgFields[i].wSQLType)  <br>{ <br>case SQL_INTEGER: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpd[i].sdword, IGNORED, &amp;lpd[i].cb); <br>break; <br>case SQL_SMALLINT: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpd[i].sword, IGNORED, &amp;lpd[i].cb); <br>break; <br>case SQL_FLOAT: <br>case SQL_DOUBLE: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpd[i].sdouble, IGNORED, &amp;lpd[i].cb); <br>break; <br>case SQL_REAL: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpd[i].sfloat, IGNORED, &amp;lpd[i].cb); <br>break; <br>case SQL_DATE: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpd[i].date, IGNORED, &amp;lpd[i].cb); <br>break; <br>case SQL_TIME: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpd[i].time, IGNORED, &amp;lpd[i].cb); <br>break; <br>case SQL_TIMESTAMP: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpd[i].timestamp, IGNORED, &amp;lpd[i].cb); <br>break; <br>case SQL_CHAR: <br>case SQL_VARCHAR: <br>case SQL_NUMERIC: <br>case SQL_DECIMAL: <br>default: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>lpd[i].data, MAX_STRING_SIZE, &amp;lpd[i].cb); <br>break; <br>} <br> <br>if(!RETCHECK(SQL_SUCCESS, rc, szSQLBINDCOL)) <br>return(FALSE); <br>} <br> <br>return(TRUE); <br> <br>} //BindAllColumns() <br> <br>/*----------------------------------------------------------------------- <br> *      Function:               BindFetchColumns <br> *  Used for Checking data in Result sets from fetch calls. <br> *  Binds Binary data types as SQL_C_CHAR <br> *----------------------------------------------------------------------- */ <br> <br>BOOL  PASCAL BindFetchColumns(QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes, <br>DSTRUCT  *lpdFetch) <br>{ <br>UWORDi, <br>w; <br>RETCODErc=SQL_SUCCESS; <br> <br>for(i = 0, w = 0; i &lt; cTypes; i++)  <br>{ <br> <br>if(!qtMakeData(0, i,&amp;rgFields[i],lpqt-&gt;szDataItem)) <br>continue; <br> <br>w++; <br> <br>switch(rgFields[i].wSQLType)  <br>{ <br>case SQL_BIGINT: <br>case SQL_INTEGER: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpdFetch[i].sdword, IGNORED, &amp;lpdFetch[i].cb); <br>break; <br>case SQL_TINYINT: <br>case SQL_SMALLINT: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpdFetch[i].sword, IGNORED, &amp;lpdFetch[i].cb); <br>break; <br>case SQL_FLOAT: <br>case SQL_DOUBLE: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpdFetch[i].sdouble, IGNORED, &amp;lpdFetch[i].cb); <br>break; <br>case SQL_REAL: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpdFetch[i].sfloat, IGNORED, &amp;lpdFetch[i].cb); <br>break; <br>case SQL_DATE: <br>case SQL_TYPE_DATE: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpdFetch[i].date, IGNORED, &amp;lpdFetch[i].cb); <br>break; <br>case SQL_TIME: <br>case SQL_TYPE_TIME: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpdFetch[i].time, IGNORED, &amp;lpdFetch[i].cb); <br>break; <br>case SQL_TIMESTAMP: <br>case SQL_TYPE_TIMESTAMP: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>&amp;lpdFetch[i].timestamp, IGNORED, &amp;lpdFetch[i].cb); <br>break; <br>case SQL_BIT: <br>case SQL_BINARY: <br>case SQL_VARBINARY: <br>case SQL_LONGVARBINARY: <br>rc = SQLBindCol(hstmt, w, SQL_C_TCHAR, <br>lpdFetch[i].data, MAX_STRING_SIZE, &amp;lpdFetch[i].cb); <br>break; <br>case SQL_CHAR: <br>case SQL_VARCHAR: <br>case SQL_NUMERIC: <br>case SQL_DECIMAL: <br>default: <br>rc = SQLBindCol(hstmt, w, SQL_C_DEFAULT, <br>lpdFetch[i].data, MAX_STRING_SIZE, &amp;lpdFetch[i].cb); <br>break; <br>} <br> <br>if(!RETCHECK(SQL_SUCCESS, rc, szSQLBINDCOL)) <br>return(FALSE); <br>} <br> <br>return(TRUE); <br> <br>} /*BindFetchColumns() */ <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestMetaData <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestMetaData(lpSERVERINFO lpSI, QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes) <br>{ <br>SWORD    wNum; <br>UWORD    w; <br>UWORD    i; <br>UDWORD   dwLen; <br>RETCODErc=SQL_SUCCESS; <br>SWORDwType; <br>SWORDwNull; <br> <br>SelectFromTable(lpqt); <br> <br>for(i = 0, w = 0; i &lt; cTypes; i++)  <br>{ <br>dwLen = 0; <br>wNum = 0; <br>wNull = 0; <br> <br>/* information returned by SQLDescribeCol should match info */ <br>/*used to create table */ <br> <br>if(!qtMakeData(1, i,&amp;rgFields[i],lpqt-&gt;szDataItem)) <br>continue; <br> <br>w++; <br>rc = SQLDescribeCol(hstmt, w, lpqt-&gt;buf, <br>MAX_STRING_SIZE, NULL, &amp;wType, &amp;dwLen, &amp;wNum, &amp;wNull); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDESCRIBECOL); <br> <br>/* verify that column name returned is column name created */ <br> <br>if(0 != lstrcmpi(rgFields[i].szFieldName, lpqt-&gt;buf)) <br>DISPLAYERROR(szSQLDESCRIBECOL,TEXT("incorrect column name")); <br> <br>if(wType != rgFields[i].wSQLType) <br>{ <br>// For a 2.x driver, SQLGetTypeInfo result will be SQL_DATE, etc, <br>// but 3.0 DM will convert SQLDescribeCol values to TYPE_DATE, ETC. <br>if ((uDriverODBCVer &lt; 3) &amp;&amp;  <br>((SQL_TYPE_DATE == wType &amp;&amp; SQL_DATE == rgFields[i].wSQLType) || <br>(SQL_TYPE_TIME == wType &amp;&amp; SQL_TIME == rgFields[i].wSQLType) || <br>(SQL_TYPE_TIMESTAMP == wType &amp;&amp; SQL_TIMESTAMP == rgFields[i].wSQLType))) <br>NULL; <br>else <br>DISPLAYERROR(szSQLDESCRIBECOL,TEXT("incorrect SQLType")); <br>} <br> <br>if(dwLen != (UDWORD)rgFields[i].precision) <br>DISPLAYERROR(szSQLDESCRIBECOL,TEXT("incorrect precision")); <br> <br>if(wNum != rgFields[i].scale) <br>DISPLAYERROR(szSQLDESCRIBECOL,TEXT("incorrect scale")); <br> <br>if(wNull != rgFields[i].nullable &amp;&amp; wNull != SQL_NULLABLE_UNKNOWN &amp;&amp; <br>rgFields[i].nullable != SQL_NULLABLE_UNKNOWN) <br>{ <br>DISPLAYERROR(szSQLDESCRIBECOL,TEXT("incorrect nullable")); <br>} <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestMetaData() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               RetrieveData <br>//----------------------------------------------------------------------- <br> <br>void PASCAL RetrieveData(QTSTRUCT *lpqt,FIELDINFO *rgFields, <br>UWORD cTypes,DSTRUCT *lpd) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDind, <br>i; <br>intnSame; <br>LPTSTRpch=NULL; <br>TCHARszNum[MAX_NUM_BUFFER];   /* used with _ttoi and itoa conversions */ <br>TCHAR*stopstring=NULL; <br>doubleNum=0, <br>Num2=0; <br> <br>for(ind = 0; ;ind++)  <br>{ <br> <br>/* Get the data back */ <br>rc = SQLFetch(hstmt); <br>if(rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) <br>break; <br> <br>for(i = 0; i &lt; cTypes; i++)  <br>{  <br>/* make sure it's original data placed */ <br>/* in that field/row location */ <br>pch = qtMakeData(ind, i,&amp;rgFields[i], lpqt-&gt;szDataItem); <br> <br>if(!pch) <br>continue; <br> <br>if(!*pch) { <br>if(lpd[i].cb != SQL_NULL_DATA) <br>DISPLAYERROR(szRETDATA, TEXT("should have been NULL")); <br>continue; <br>} <br>switch(rgFields[i].wSQLType)  <br>{ <br>/* check the outlen and data*/ <br>/* returned for each type. */ <br>case SQL_INTEGER: <br>if(lpd[i].cb != sizeof(SDWORD)) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>lstrcpy(szNum, pch); <br>nSame = _ttol(szNum) == lpd[i].sdword; <br>break; <br>case SQL_SMALLINT: <br>if(lpd[i].cb != sizeof(SWORD)) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>lstrcpy(szNum, pch); <br>nSame = _ttoi(szNum) == lpd[i].sword; <br>break; <br> <br>case SQL_FLOAT: <br>case SQL_DOUBLE: <br>if(lpd[i].cb != sizeof(SDOUBLE)) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>lstrcpy(szNum, pch); <br>Num=_tcstod(szNum, &amp;stopstring); <br>nSame = Num - lpd[i].sdouble &lt; 0.001 &amp;&amp; Num - lpd[i].sdouble &gt; -0.001; <br> <br>break; <br> <br>case SQL_REAL: <br>if(lpd[i].cb != sizeof(SFLOAT)) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>lstrcpy(szNum, pch); <br>Num=_tcstod(szNum, &amp;stopstring); <br> <br>nSame = Num - lpd[i].sfloat &lt; 0.001 &amp;&amp; Num - lpd[i].sfloat &gt; -0.001; <br>break; <br> <br>case SQL_TINYINT: <br>if(lpd[i].cb != sizeof(TCHAR)) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>lstrcpy(szNum, pch); <br>nSame = (TCHAR)_ttoi(szNum) == (TCHAR)lpd[i].data[0]; <br>break; <br> <br>case SQL_DECIMAL: <br>case SQL_NUMERIC: <br>if(lpd[i].cb &gt; MAX_STRING_SIZE) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>if(lpd[i].cb &gt; lstrlen(lpd[i].data)) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>{ <br>TCHAR szNum2[MAX_NUM_BUFFER]; <br> <br>lstrcpy(szNum, pch); <br>lstrcpy(szNum2, pch); <br>Num=_tcstod(szNum, &amp;stopstring); <br>Num2=_tcstod(szNum2, &amp;stopstring); <br> <br>nSame = Num - Num2 &lt; 0.001 &amp;&amp;Num - Num2 &gt; -0.001; <br>} <br> <br>break; <br> <br> <br>case SQL_VARCHAR: <br>case SQL_LONGVARCHAR: <br>if(lpd[i].cb &gt; MAX_STRING_SIZE) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>if(lpd[i].cb &gt; lstrlen(lpd[i].data)) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>nSame = !!_tcsstr(lpd[i].data, pch); <br> <br>break; <br> <br>case SQL_VARBINARY: <br>case SQL_LONGVARBINARY: <br>if(lpd[i].cb &gt; MAX_STRING_SIZE) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>if(lpd[i].cb  * 2 != lstrlen(pch)) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>nSame = TRUE; /* not checking returned data for binary */ <br> <br>break; <br> <br>case SQL_CHAR: <br>if(lpd[i].cb &gt; MAX_STRING_SIZE &amp;&amp; rc == SQL_SUCCESS) <br>DISPLAYERROR(szRETDATA,TEXT("incorrect return code for outlen")); <br> <br>if(lpd[i].cb != rgFields[i].precision &amp;&amp; rc == SQL_SUCCESS) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br> <br>nSame = !_tcsnccmp(lpd[i].data, pch, lstrlen(pch)); <br> <br>break; <br>case SQL_BINARY: <br>default: <br>if(lpd[i].cb &gt; MAX_STRING_SIZE &amp;&amp; rc == SQL_SUCCESS) <br>DISPLAYERROR(szRETDATA,szINCORRECTOUTLEN); <br>nSame = TRUE; /* not checking returned data for binary */ <br>} <br> <br>if(!nSame) <br>DISPLAYERROR(szRETDATA, TEXT("invalid data")); <br>} <br>} <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc, szSQLFETCH); <br> <br>if(ind != cTypes + 1) <br>DISPLAYERROR(szSQLFETCH, TEXT("Incorrect number of result rows")); <br> <br>rc = SQLFreeStmt(hstmt, SQL_CLOSE); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>rc = SQLFreeStmt(hstmt, SQL_UNBIND); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>rc = SQLFreeStmt(hstmt, SQL_RESET_PARAMS); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>} // RetrieveData() <br> <br> <br>   <br>//----------------------------------------------------------------------- <br>//      Function:               TestData <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestData(QTSTRUCT  *lpqt,FIELDINFO  *rgFields, <br>UWORD cTypes,DSTRUCT  *lpd) <br>{ <br> <br>/* bind all fields to a variable of the correct type for retreiving data */ <br>if (!BindAllColumns(lpqt,rgFields,cTypes,lpd)) <br>return; <br> <br>SelectFromTable(lpqt); <br> <br>RetrieveData(lpqt,rgFields,cTypes,lpd); <br> <br>} // TestData() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               CreateParamQuery <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL CreateParamQuery(QTSTRUCT *lpqt, FIELDINFO *rgFields,UWORD cTypes) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDi; <br>LPTSTRpch=NULL; <br>TCHARszQuery[MAX_QUERY_SIZE]; <br>SDWORDsdw = SQL_DATA_AT_EXEC; <br>UWORDw, <br>ind; <br> <br> <br>wsprintf(szQuery,TEXT("select %s from %s where "), lpqt-&gt;szColNames,lpqt-&gt;szTableName); <br> <br> <br>for(i = 0, w = 0,ind=0; i &lt; cTypes; i++)  <br>{ <br>pch = qtMakeData(ind, i,&amp;rgFields[i], lpqt-&gt;szDataItem); <br> <br>if ((rgFields[i].fSearchable == SQL_SEARCHABLE || <br>rgFields[i].fSearchable == SQL_ALL_EXCEPT_LIKE) &amp;&amp; <br>pch &amp;&amp; *pch)  <br>{ <br>w++; <br> <br>switch(rgFields[i].wSQLType) <br>{ <br>case SQL_REAL: <br>case SQL_FLOAT: <br>case SQL_DOUBLE: <br>wsprintf(&amp;szQuery[lstrlen(szQuery)],TEXT("%s &lt; ? + 1 and "), <br>rgFields[i].szFieldName); <br>break; <br>default: <br>wsprintf(&amp;szQuery[lstrlen(szQuery)],TEXT("%s = ? and "), <br>rgFields[i].szFieldName); <br>} <br> <br>if(!fBindParameter) <br>{ <br>rc = SQLSetParam(hstmt, w, <br>SQL_C_TCHAR, rgFields[i].wSQLType, <br>rgFields[i].precision, rgFields[i].scale, <br>(LPTSTR)(UDWORD)i, &amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETPARAM); <br>} <br>else <br>{ <br>rc = SQLBindParameter(hstmt, w, SQL_PARAM_INPUT, <br>SQL_C_TCHAR, rgFields[i].wSQLType, <br>rgFields[i].precision, rgFields[i].scale, <br>(LPTSTR)((UDWORD)i+BIND_PARM_OFFSET), 0, &amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLBINDPARAMETER); <br>} <br> <br>ind++; <br>} <br>} <br> <br>if (_tcsstr(szQuery,TEXT("and"))) <br>{ <br>/* remove the final "and " */ <br>szQuery[lstrlen(szQuery) - 5] = TEXT('\0'); <br>} <br> <br>lstrcpy(lpqt-&gt;szParamQuery, szQuery); <br> <br>} <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSearchedQuery <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSearchedQuery(QTSTRUCT  *lpqt,FIELDINFO  *rgFields, <br>UWORD cTypes,DSTRUCT  *lpd,BOOL fBindParameter) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDi; <br>LPTSTRpch=NULL; <br>SDWORDsdw; <br>UWORDw; <br>UDWORDudw; <br>UWORDind; <br> <br> <br>wsprintf(lpqt-&gt;sz, TEXT("select %s from %s where "), lpqt-&gt;szColNames, <br>lpqt-&gt;szTableName); <br> <br>    sdw = SQL_DATA_AT_EXEC; <br> <br>for(i = 0, w = 0,ind=0; i &lt; cTypes; i++)  <br>{ <br>pch = qtMakeData(ind, i,&amp;rgFields[i], lpqt-&gt;szDataItem); <br> <br>if ((rgFields[i].fSearchable == SQL_SEARCHABLE || <br>rgFields[i].fSearchable == SQL_ALL_EXCEPT_LIKE) &amp;&amp; <br>pch &amp;&amp; *pch) { <br>w++; <br>switch(rgFields[i].wSQLType) { <br>case SQL_REAL: <br>case SQL_FLOAT: <br>case SQL_DOUBLE: <br>wsprintf(&amp;lpqt-&gt;sz[lstrlen(lpqt-&gt;sz)], TEXT("%s &lt; ? + 1 and "), <br>rgFields[i].szFieldName); <br>break; <br>default: <br>wsprintf(&amp;lpqt-&gt;sz[lstrlen(lpqt-&gt;sz)], TEXT("%s = ? and "), <br>rgFields[i].szFieldName); <br>} <br> <br>if(!fBindParameter){ <br>rc = SQLSetParam(hstmt, w, <br>SQL_C_TCHAR, rgFields[i].wSQLType, <br>rgFields[i].precision, rgFields[i].scale, <br>(LPTSTR)(UDWORD)i, &amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc, szSQLSETPARAM); <br>} <br>else{ <br>rc = SQLBindParameter(hstmt, w, SQL_PARAM_INPUT, <br>SQL_C_TCHAR, rgFields[i].wSQLType, <br>rgFields[i].precision, rgFields[i].scale, <br>(LPTSTR)((UDWORD)i+BIND_PARM_OFFSET), 0, &amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc, szSQLBINDPARAMETER); <br>} <br> <br>ind++; <br>} <br>} <br>/* remove the final "and " */ <br>lpqt-&gt;sz[lstrlen(lpqt-&gt;sz) - 5] = TEXT('\0'); <br>lstrcpy(lpqt-&gt;szParamQuery, lpqt-&gt;sz); <br> <br>rc = SQLPrepare(hstmt, lpqt-&gt;sz, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc, szSQLPREPARE); <br> <br>rc = SQLExecute(hstmt); <br>RETCHECK(SQL_NEED_DATA, rc, szSQLEXECUTE); <br> <br>udw = cTypes; <br> <br>for(i = 0; ; i++)  <br>{ <br>rc = SQLParamData(hstmt, (PTR *)&amp;udw); <br>if(rc != SQL_NEED_DATA) <br>break; <br> <br>if(udw-BIND_PARM_OFFSET &lt; cTypes) <br>pch = qtMakeData(cTypes, i,&amp;rgFields[udw-BIND_PARM_OFFSET], lpqt-&gt;szDataItem); <br>else <br>DISPLAYERROR(szSQLPARAMDATA, TEXT("invalid rgbValue")); <br> <br>if(*pch)  <br>{ <br>udw = lstrlen(pch); <br>rc = SQLPutData(hstmt, pch, (SDWORD)lstrlen(pch)); <br>RETCHECK(SQL_SUCCESS, rc, szSQLPUTDATA); <br>}  <br>else <br>{ <br>rc = SQLPutData(hstmt, (LPTSTR)IGNORED, SQL_NULL_DATA); <br>RETCHECK(SQL_SUCCESS, rc, szSQLPUTDATA); <br>} <br>} <br> <br>RETCHECK(SQL_SUCCESS, rc, szSQLPARAMDATA); <br> <br>for(i = 0;; i++)  <br>{ <br>rc = SQLFetch(hstmt); <br> <br>if(rc != SQL_SUCCESS) <br>break; <br>} <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc, szSQLFETCH); <br> <br>/* should have gotten 1 row back */ <br> <br>if(i != 1) <br>DISPLAYERROR(TEXT("Param/PutData"), TEXT("incorrect number of rows returned")); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSearchedQuery() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestLargeQuery <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestLargeQuery(QTSTRUCT  *lpqt,FIELDINFO  *rgFields, <br>UWORD cTypes,DSTRUCT  *lpd) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDind=0, <br>i; <br>LPTSTRpch=NULL; <br>TCHARszQuery[2048]; <br> <br> <br>/* &gt; 1K query */ <br>wsprintf(szQuery,TEXT("select %s from %s where "), lpqt-&gt;szColNames, <br>lpqt-&gt;szTableName); <br> <br>for(i = 0; i &lt; cTypes; i++)  <br>{ <br>if (rgFields[i].fSearchable == SQL_SEARCHABLE || <br>rgFields[i].fSearchable == SQL_ALL_EXCEPT_LIKE) <br>break; <br>} <br> <br>pch = qtMakeData(cTypes, 1, &amp;rgFields[i], lpqt-&gt;szDataItem); <br>while(lstrlen(szQuery) &lt; 1024L)  <br>{ <br>int li=lstrlen(szQuery); <br>switch(rgFields[i].wSQLType)  <br>{ <br>case SQL_REAL: <br>case SQL_FLOAT: <br>case SQL_DOUBLE: <br>wsprintf(&amp;szQuery[lstrlen(szQuery)],TEXT("%s &lt; %s + 1 and "), <br>rgFields[i].szFieldName, pch); <br>break; <br>default: <br>wsprintf(&amp;szQuery[lstrlen(szQuery)],TEXT("%s = %s%s%s and "), <br>rgFields[i].szFieldName, rgFields[i].szPrefix, pch, rgFields[i].szSuffix); <br>break; <br>} <br>} <br> <br>/* remove the final "and " */ <br>szQuery[lstrlen(szQuery) - 5] = TEXT('\0'); <br> <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>for(i = 0;; i++)  <br>{ <br>rc = SQLFetch(hstmt); <br> <br>if(rc != SQL_SUCCESS) <br>break; <br>} <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>/* should have gotten at least 1 row back */ <br> <br>if(i &lt; 1) <br>DISPLAYERROR(TEXT("&gt; 1K query"),TEXT("incorrect number of rows returned")); <br> <br>} <br> <br>/* SQLFreeStmt with SQL_CLOSE to re-use the hstmt */ <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestLargeQuery() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLTables <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLTables(QTSTRUCT  *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>BOOLfFoundTable=FALSE; <br>UWORDi; <br> <br>/* this call may return many tables, as  */ <br>/* long as the one created earlier shows */ <br>/* up it will pass. */ <br> <br>rc = SQLTables(hstmt, NULL, 0, NULL, 0,TEXT("q%"),SQL_NTS,TEXT("'TABLE'"), SQL_NTS);  <br> <br>RETCHECK(SQL_SUCCESS, rc,szSQLTABLES); <br> <br>for(i = 0;; i++)  <br>{ <br>rc = SQLFetch(hstmt); <br>if(rc != SQL_SUCCESS) <br>break; <br> <br>/* column 3 is tablename */ <br>rc = SQLGetData(hstmt, 3, SQL_C_TCHAR, lpqt-&gt;sz, MAX_STRING_SIZE, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); /* should not overflow <br>and return SQL_SUCCESS_WITH_INFO because the buffer is larger than the <br>table name */ <br>fFoundTable += 0 == lstrcmpi(lpqt-&gt;sz, lpqt-&gt;szTableName); <br>} <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>if(1 != fFoundTable) { <br>DISPLAYERROR(szSQLTABLES,TEXT("table not found")); <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSQLTables() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLSpecialCols <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLSpecialCols(QTSTRUCT  *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDi; <br> <br>rc = SQLSpecialColumns(hstmt, SQL_BEST_ROWID, NULL, 0, NULL, 0, <br>lpqt-&gt;szTableName, (SWORD)(lstrlen(lpqt-&gt;szTableName)), SQL_SCOPE_TRANSACTION, <br>SQL_NULLABLE); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSPECIALCOLUMNS); <br> <br>for(i = 0;; i++) <br>{ <br>rc = SQLFetch(hstmt); <br>if(rc != SQL_SUCCESS) <br>break; <br>} <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSQLSpecialCols() <br> <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               VerifyIndex <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL VerifyIndex(QTSTRUCT  *lpqt,UWORD fIndex) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>BOOLfFoundTable=FALSE; <br>UWORDi; <br>SDWORDsdw; <br> <br>rc = SQLStatistics(hstmt, NULL, 0, NULL, 0, lpqt-&gt;szTableName, <br>SQL_NTS, SQL_INDEX_ALL, SQL_ENSURE); <br>RETCHECK(SQL_SUCCESS, rc,TEXT("SQLStatistics")); <br> <br>fFoundTable = 0; <br>for(i = 0;; i++)  <br>{ <br>rc = SQLFetch(hstmt); <br>if(rc != SQL_SUCCESS) <br>break; <br> <br>rc = SQLGetData(hstmt, 3, SQL_C_TCHAR, lpqt-&gt;sz, MAX_STRING_SIZE, <br>&amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br>if (lstrcmpi(lpqt-&gt;sz, lpqt-&gt;szTableName) == 0) <br>{ <br>rc = SQLGetData(hstmt, 6, SQL_C_TCHAR, lpqt-&gt;sz, MAX_STRING_SIZE, <br>&amp;sdw); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br>fFoundTable += 0 == lstrcmpi(lpqt-&gt;sz, lpqt-&gt;szDataItem); <br>} <br>} <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>if(1 != fFoundTable &amp;&amp; fIndex) <br>DISPLAYERROR(TEXT("SQLStatistics"),TEXT("index not returned")); <br> <br>/* one row represents original table, the */ <br>/* other represents the index */ <br>if(i &gt; 2 || i &lt; 1)  <br>DISPLAYERROR(TEXT("SQLStatistics"),TEXT("too many rows")); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //VerifyIndex() <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLStatistics <br>//----------------------------------------------------------------------- <br> <br>BOOL  PASCAL TestSQLStatistics(QTSTRUCT  *lpqt,FIELDINFO  *rgFields, <br>UWORD cTypes,DSTRUCT  *lpd,UWORD fIndex) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDi; <br> <br>lstrcpy(lpqt-&gt;szDataItem, lpqt-&gt;szTableName); <br>lpqt-&gt;szDataItem[0] = TEXT('i'); <br>for(i = 1; i &lt; cTypes; i++) <br>if(rgFields[i].wSQLType == SQL_INTEGER || <br>rgFields[i].wSQLType == SQL_SMALLINT) <br>break; <br>if(i == cTypes) <br>i = 0; <br> <br>lstrcpy(lpqt-&gt;buf, rgFields[i].szFieldName); <br>wsprintf(lpqt-&gt;sz,TEXT("create unique index %s on %s (%s)"), <br>lpqt-&gt;szDataItem, lpqt-&gt;szTableName, lpqt-&gt;buf); <br> <br>rc = SQLExecDirect(hstmt, lpqt-&gt;sz, SQL_NTS); <br>if(fIndex &lt; 1) <br>/* if this is minimal grammar, don't count on indexes being available */ <br>fIndex = rc == SQL_SUCCESS; <br>else <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>VerifyIndex(lpqt,fIndex); <br> <br>return(fIndex); <br> <br>} //TestSQLStatistics() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestLikeQuery <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestLikeQuery(QTSTRUCT  *lpqt,FIELDINFO  *rgFields, <br>UWORD cTypes,DSTRUCT  *lpd) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDi; <br>SDWORDcbValue=0; <br> <br>for(i = 0; i &lt; cTypes; i++)  <br>{ <br>if(rgFields[i].fSearchable == SQL_LIKE_ONLY || <br>rgFields[i].fSearchable == SQL_SEARCHABLE)  <br>{ <br>lstrcpy(lpqt-&gt;buf, rgFields[i].szFieldName); <br>break; <br>} <br>} <br> <br>if(i &lt; cTypes)  <br>{ <br> <br>/* execute a query using like.  This query should return all records */ <br>/* this query should return all rows in the table */ <br> <br>wsprintf(lpqt-&gt;sz,TEXT("select * from %s where %s not like 'a'"), lpqt-&gt;szTableName, <br>lpqt-&gt;buf, lpqt-&gt;buf); <br>rc = SQLExecDirect(hstmt, lpqt-&gt;sz, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>for(i = 0;; i++)  <br>{ <br>rc = SQLFetch(hstmt); <br>if(rc != SQL_SUCCESS) <br>break; <br> <br>rc = SQLGetData(hstmt, 1, SQL_C_TCHAR, lpqt-&gt;sz, MAX_STRING_SIZE, <br>&amp;cbValue); <br>if(rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br>} <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>if(i != cTypes) <br>DISPLAYERROR(TEXT("'LIKE' query"),TEXT("incorrect number of result rows")); <br> <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestLikeQuery() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestLikeQuery <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestOJCap(QTSTRUCT  *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UDWORDudw; <br> <br>rc = SQLGetInfo(hdbc, (UWORD)SQL_OJ_CAPABILITIES, &amp;udw, (SWORD)(sizeof(udw)), NULL); <br>if(RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO)) <br>{ <br>udw &amp;= ~(SQL_OJ_LEFT | SQL_OJ_RIGHT | SQL_OJ_FULL | SQL_OJ_NESTED| <br>SQL_OJ_NOT_ORDERED | SQL_OJ_INNER | SQL_OJ_ALL_COMPARISON_OPS); <br>if(udw) <br>{ <br>wsprintf(lpqt-&gt;buf,TEXT("Undefined flags return from SQLGetInfo(...SQL_OJ_CAPABILITIES...) = %lX"), udw); <br>DISPLAYERROR(szSQLGETINFO, lpqt-&gt;buf); <br>} <br>} <br> <br>rc = SQLGetInfo(hdbc, SQL_OUTER_JOINS, lpqt-&gt;buf, MAX_STRING_SIZE, NULL); <br>if(RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO)){ <br>*lpqt-&gt;buf = toupper(*lpqt-&gt;buf); <br>if((!_tcsnccmp(lpqt-&gt;buf,TEXT("Y"), 1)) &amp;&amp; (!_tcsnccmp(lpqt-&gt;buf,TEXT("N"), 1))) <br>DISPLAYERROR(szSQLGETINFO,TEXT("Driver returned an invalid value for SQLGetInfo(...SQL_OUTER_JOINS...).  The only valid values are \"Y\" and \"N\".")); <br>} <br> <br>} //TestOJCap() <br> <br> <br>/*----------------------------------------------------------------------- <br> *      Function:               TestExtendedFetch <br> *-----------------------------------------------------------------------*/ <br> <br>void  PASCAL TestExtendedFetch(QTSTRUCT  *lpqt, FIELDINFO  *rgFields, UWORD cTypes) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>WORDfLevel2 = FALSE; <br>DWORDdwLen=0; <br>SWORDfSqlType; <br>SDWORDcbValue=0; <br>UWORDiTableCol,row,iCol,uwRowSetSize; <br>TCHARszQuery[MAX_STRING_SIZE], szColName[SMALLBUFF]; <br>TCHAR*rgbValue; <br>DSTRUCT*rgData; <br>DSTRUCT*pDataBuf; <br>BOOLfCol0Bound=TRUE; <br> <br>uwRowSetSize=5; /* Cinco seems like a good rowset size */ <br> <br>/* Only col which might not be bound but might not be AutoUpdateable is col 0 */ <br>if(!qtMakeData(0, 0, &amp;rgFields[0], szQuery)) <br>fCol0Bound = FALSE; <br> <br>SelectFromTable(lpqt); <br> <br>rc = SQLBindCol(hstmt, 1, SQL_C_BINARY, lpqt-&gt;sz, MAX_BIND_ARRAY_ELEMENT, <br>&amp;cbValue); <br>RETCHECK(SQL_SUCCESS, rc,szSQLBINDCOL); <br> <br>if (!Supported(SQL_API_SQLEXTENDEDFETCH))  <br>{ <br>rc = SQLExtendedFetch(hstmt, SQL_FETCH_FIRST, IGNORED, NULL, NULL); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLEXTENDEDFETCH, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLEXTENDEDFETCH); <br> <br>FreeStmt(SQL_CLOSE); <br>return; <br>}  <br> <br>rc = SQLGetStmtOption(hstmt,SQL_CURSOR_TYPE,&amp;dwLen); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTOPTION); <br> <br>if(dwLen != SQL_CURSOR_FORWARD_ONLY) <br>{ <br>rc = SQLExtendedFetch(hstmt, SQL_FETCH_FIRST, IGNORED, NULL, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXTENDEDFETCH); <br>} <br>else <br>{ <br>rc = SQLExtendedFetch(hstmt, SQL_FETCH_FIRST, IGNORED, NULL, NULL); <br>RETCHECK(SQL_ERROR, rc,szSQLEXTENDEDFETCH); <br>} <br> <br>rc = SQLFreeStmt(hstmt, SQL_CLOSE); </code></pre>
<p>
</p>
<pre><code>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>rc = SQLFreeStmt(hstmt, SQL_UNBIND); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>rc = SQLFreeStmt(hstmt, SQL_RESET_PARAMS); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>/* Allocate an area for ExtendedFetch to take place */ <br>if (!(rgData = AllocateMemory(sizeof(DSTRUCT)*cTypes*uwRowSetSize))){ <br>DISPLAYERROR(szSQLEXTENDEDFETCH,TEXT("Insufficient Memory Available")); <br>return; <br>} <br> <br>/* Allocate an area for test data */ <br>if (!(rgbValue = AllocateMemory(MAX_STRING_SIZE))){ <br>DISPLAYERROR(szSQLEXTENDEDFETCH,TEXT("Insufficient Memory Available")); <br>ReleaseMemory(rgData); <br>return; <br>} <br> <br>/* Get column for "order by" clause: */ <br>wsprintf(szQuery,TEXT("select %s from %s"),lpqt-&gt;szColNames, lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>if((SQL_SUCCESS!=rc) &amp;&amp; (SQL_SUCCESS_WITH_INFO!=rc)){ <br>RETCHECK(SQL_SUCCESS_WITH_INFO, rc, szSQLEXECDIRECT); <br>goto abortxfetch; <br>} <br>iCol=0; <br>do{ <br>iCol++; <br>rc=SQLDescribeCol(hstmt, iCol, szColName, (SMALLBUFF*sizeof(TCHAR)),  <br>NULL, &amp;fSqlType, NULL, NULL, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDESCRIBECOL); <br>} while(fSqlType!=SQL_CHAR &amp;&amp; iCol&lt;=cTypes); <br> <br>FreeStmt(SQL_CLOSE); <br>if(iCol&gt;cTypes){ <br>DISPLAYERROR(szSQLEXTENDEDFETCH, TEXT("\t\t\tSelect-order by  Failed")); <br>goto abortxfetch; <br>} <br> <br>/* Set rowset size and set to row-wise binding:  */ <br>rc = SQLSetStmtOption(hstmt, SQL_ROWSET_SIZE, (UDWORD)uwRowSetSize); <br>if (SQL_SUCCESS != rc){ <br>DISPLAYERROR(TEXT("ExtendedFetch...SQLSetStmtOption(Rowset_Size)"), <br>TEXT("SQLSetStmtOption Failed")); <br>GetErrors(henv, hdbc,hstmt); <br>} <br>rc = SQLSetStmtOption(hstmt, SQL_BIND_TYPE, (sizeof(DSTRUCT)*cTypes)); <br>if (SQL_SUCCESS != rc){ <br>DISPLAYERROR(TEXT("ExtendedFetch...SQLSetStmtOption(Bind_Type)"), <br>TEXT("SQLSetStmtOption Failed")); <br>GetErrors(henv, hdbc,hstmt); <br>} <br> <br>if(SQL_SUCCESS != SelectFromTableFetch(lpqt, szColName)){ <br>DISPLAYERROR(szSQLEXTENDEDFETCH, TEXT("\t\t\tSelect-order by  Failed")); <br>goto abortxfetch; <br>} <br>if (!BindFetchColumns(lpqt, rgFields, cTypes, rgData)){ <br>DISPLAYERROR(szSQLEXTENDEDFETCH, szSQLBINDCOL); <br>goto abortxfetch; <br>} <br>/* Fetch into allocated area rowset to be tested */ <br>rc = SQLExtendedFetch(hstmt, SQL_FETCH_NEXT, 1, NULL, NULL); <br>if (SQL_SUCCESS != rc){ <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXTENDEDFETCH); <br>DISPLAYERROR(szSQLEXTENDEDFETCH, TEXT("Fetch Failed")); <br>goto abortxfetch; <br>} <br> <br>rc = SQLFreeStmt(hstmt, SQL_CLOSE); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>rc = SQLFreeStmt(hstmt, SQL_UNBIND); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>/* Set rowset size to "1" to test each row of rowset independently:  */ <br>rc = SQLSetStmtOption(hstmt, SQL_ROWSET_SIZE, (UDWORD)(1)); <br>if (SQL_SUCCESS != rc){ <br>DISPLAYERROR(TEXT("ExtendedFetch...SQLSetStmtOption(Rowset_Size)"), <br>TEXT("SQLSetStmtOption Failed")); <br>GetErrors(henv, hdbc,hstmt); <br>} <br> <br> /* Check data in all rows of rowset */  <br>if(SQL_SUCCESS != SelectFromTableFetch(lpqt, szColName)){ <br>DISPLAYERROR(szSQLEXTENDEDFETCH, TEXT("\t\t\tSelect-order by  Failed")); <br>goto abortxfetch; <br>} <br>  <br>// Need to change this loop if number of rows in table &lt; uwRowSetSize <br>for (row=0; row&lt;uwRowSetSize; row++) <br>{ <br>SWORD iResultSetCol=0; <br>if (SQL_SUCCESS != (rc = SQLFetch(hstmt))){ <br>RETCHECK(SQL_SUCCESS, rc, szSQLFETCH); <br>DISPLAYERROR(szSQLEXTENDEDFETCH, TEXT("Fetch Failed")); <br>goto abortxfetch; <br>} <br> <br>pDataBuf=rgData+row*cTypes; <br>for (iTableCol=0; iTableCol&lt;cTypes; iTableCol++) <br>{ <br>/* Ignore columns which aren't bound as they aren't in the result set */ <br>if((!iTableCol &amp;&amp; !fCol0Bound) || rgFields[iTableCol].fAutoUpdate) <br>continue; <br> <br>iResultSetCol++; <br>rc = SQLGetData(hstmt, iResultSetCol, SQL_C_TCHAR, rgbValue, MAX_STRING_SIZE, <br> &amp;cbValue); <br>if(rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br> <br>if(!CheckDataResults(row, iTableCol, &amp;rgFields[iTableCol], pDataBuf,cbValue,rgbValue)) <br>{ <br>wsprintf(lpqt-&gt;buf, TEXT("Data Check Failed, Row %d, Table Col %d, DataType %d (%s)"), <br>row, iTableCol, rgFields[iTableCol].wSQLType, rgFields[iTableCol].szFieldName) ; <br>szWrite(lpqt-&gt;buf,FALSE); <br>rgbValue[MAX_STRING_SIZE-1]=TEXT('\0'); <br>wsprintf(lpqt-&gt;buf, TEXT("Returned Data: (%s)"), rgbValue); <br>DISPLAYERROR(TEXT("ExtendedFetch"),lpqt-&gt;buf); <br>// goto abortxfetch; <br>} <br>} <br>} <br> <br>abortxfetch: <br>FreeStmt(SQL_CLOSE); <br>FreeStmt(SQL_UNBIND); <br>ReleaseMemory(rgData); <br>ReleaseMemory(rgbValue); <br>} /* TestExtendedFetch() */ <br> <br> <br> <br> <br>/*------------------------------------------------------------------------------ <br> *      Function:       TestQuickRebind Feature  <br> *      Purpose:        To test this specific feature, not the function(s) using it. <br> *      Synopsis: <br> *      An area large enough for 12 rows of QRDSTRUCTs will be created. There will  <br> * be two rows of the result set per Rowset. Rowset 1 should be duplicated <br> * in rows 0,1 and 3,4, while Rowset 2 should be duplicated in rows 6,7 and 9,10.  <br> * Thus, rows 0 and 3 will contain the first row of the result set, rows 1 and  <br> * 4 will contain the second row of the result set, etc.  Rows 2, 5, 8, and <br> * 11 should have their preset condition of all zeroes remain unchanged. <br> * ----------------------------------------------------------------------------*/ <br> <br>void  PASCAL TestQuickRebind(QTSTRUCT * lpqt, FIELDINFO  *rgFields, UWORD cTypes, <br>  DSTRUCT  *lpd) <br>{ <br>RETCODErc; <br>UWORDrow,iCol,iRowset,uwRowsetSize,iRowsetRow,iTableCol; <br>UDWORDudwRowSize; <br>SWORDfSqlType; <br>SDWORDsdwOffset; <br>DSTRUCT*rgData, *pZeroRow; <br>DSTRUCT*pCurrentRowData; <br>TCHARszQuery[MAX_STRING_SIZE], szColName[SMALLBUFF]; <br>SDWORDcbValue; <br>TCHAR*rgbValue=NULL; <br>BOOLfCol0Bound=TRUE; <br> <br>udwRowSize = sizeof(DSTRUCT)*cTypes; <br>/* cNumResSetCols is set in BuildInsertStmt() */ <br>uwRowsetSize = 5;/* uwRowsetSize rows per Rowset */ <br> <br>/* Only col which might not be bound but might not be AutoUpdateable is col 0 */ <br>if(!qtMakeData(0, 0, &amp;rgFields[0], szQuery)) <br>fCol0Bound = FALSE; <br> <br>/* Allocate an area for QuickRebind to take place */ <br>if (!(rgData = AllocateMemory(NUM_QUIKREBIND_ROWSETS*(uwRowsetSize+1)*udwRowSize) )){ <br>DISPLAYERROR(szQUICKREBIND,TEXT("\t\t\tInsufficient Memory Available")); <br>return; <br>} <br> <br>/* Allocate an area for a row of zeroes to place between each Rowset. */ <br>if (!(pZeroRow = AllocateMemory(udwRowSize) )){ <br>DISPLAYERROR(szQUICKREBIND,TEXT("\t\t\tInsufficient Memory Available")); <br>goto abortQuikRebind; <br>} <br> <br>/* Allocate an area for test data */ <br>if (!(rgbValue = AllocateMemory(MAX_STRING_SIZE))){ <br>DISPLAYERROR(szSQLEXTENDEDFETCH,TEXT("Insufficient Memory Available")); <br>goto abortQuikRebind; <br>} <br> <br>ResetHstmt(&amp;hstmt); <br> <br>/* Get column for "order by" clause: */ <br>wsprintf(szQuery,TEXT("select %s from %s"),lpqt-&gt;szColNames, lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>if((SQL_SUCCESS!=rc) &amp;&amp; (SQL_SUCCESS_WITH_INFO!=rc)){ <br>RETCHECK(SQL_SUCCESS_WITH_INFO, rc, szSQLEXECDIRECT); <br>goto abortQuikRebind; <br>} <br>iCol=0; <br>do{ <br>iCol++; <br>rc=SQLDescribeCol(hstmt, iCol, szColName, (SMALLBUFF*sizeof(TCHAR)),  <br>NULL, &amp;fSqlType, NULL, NULL, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDESCRIBECOL); <br>} while(fSqlType!=SQL_CHAR &amp;&amp; iCol&lt;=cTypes); <br> <br>FreeStmt(SQL_CLOSE); <br>if(iCol&gt;=cTypes){ <br>DISPLAYERROR(szQUICKREBIND, TEXT("\t\t\tSelect-order by  Failed")); <br>goto abortQuikRebind; <br>} <br> <br>/* Set to row-wise binding and set Rowset size to uwRowsetSize:  */ <br>rc = SQLSetStmtAttr(hstmt,SQL_ATTR_ROW_BIND_TYPE,(PTR)udwRowSize,SQL_IS_INTEGER); <br>if (SQL_SUCCESS != rc){ <br>_tcscpy(lpqt-&gt;buf,TEXT("\t\t\tQuick Rebind FAILED...SQLSetDescField(Bind_Type)")); <br>szWrite(lpqt-&gt;buf, TRUE); <br>goto abortQuikRebind; <br>} <br>rc = SQLSetStmtAttr(hstmt,SQL_ATTR_ROW_ARRAY_SIZE,(PTR)uwRowsetSize,SQL_IS_INTEGER); <br>if (SQL_SUCCESS != rc){ <br>DISPLAYERROR(szQUICKREBIND,TEXT("\t\t\tSetStmtAttr(Rowset Size)")); <br>goto abortQuikRebind; <br>} <br> <br>/* Define area storing Quikrebind offset value: */ <br>rc = SQLSetStmtAttr(hstmt, SQL_ATTR_ROW_BIND_OFFSET_PTR, &amp;sdwOffset, SQL_IS_POINTER); <br>if (SQL_SUCCESS != rc){ <br>if(FindError(SQL_HANDLE_STMT,szHYC00)){ <br>_tcscpy(lpqt-&gt;buf,TEXT("\t\t\tQuickRebind Not Supported")); <br>szWrite(lpqt-&gt;buf, TRUE); <br>goto abortQuikRebind; <br>} <br>_tcscpy(lpqt-&gt;buf,TEXT("\t\t\tQuick Rebind FAILED...QuickRebind Not Functional")); <br>szWrite(lpqt-&gt;buf, TRUE); <br>goto abortQuikRebind; <br>} <br> <br>if(SQL_SUCCESS != SelectFromTableFetch(lpqt, szColName)){ <br>DISPLAYERROR(szQUICKREBIND, TEXT("\t\t\tSelect-order by  Failed")); <br>goto abortQuikRebind; <br>} <br>  <br>if (!BindFetchColumns(lpqt, rgFields, cTypes, rgData)){ <br>DISPLAYERROR(szQUICKREBIND,szSQLBINDCOL); <br>goto abortQuikRebind; <br>} <br> <br>/* Test quick rebind feature with two pairs of Rowsets, all * <br> * rowsets separated by a row of zeroes:                    */ <br>for (iRowset=0; iRowset&lt;=1; iRowset++) <br>{ <br>if(iRowset) <br>if(SQL_SUCCESS != SelectFromTableFetch(lpqt, szColName)){ <br>DISPLAYERROR(szQUICKREBIND, TEXT("\t\t\tSelect-order by  Failed")); <br>goto abortQuikRebind; <br>} <br>  <br>/* Set offset value (to 0 or 1  * uwRowsetSize * udwRowSize) for 1st rowset */ <br>sdwOffset = iRowset*((1+uwRowsetSize)*udwRowSize); <br> <br>/* Fetch rowset into desired area */ <br>rc = SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 1); <br>if (SQL_SUCCESS != rc){ <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmt, SQL_SUCCESS, rc, szSQLFETCHSCROLL); <br>DISPLAYERROR(szQUICKREBIND,TEXT("Fetch Failed")); <br>goto abortQuikRebind; <br>}                                                                                                                                                                 <br> <br>/* Set offset value (to 2 or 3 * uwRowsetSize * udwRowSize) for 2nd rowset */ <br>sdwOffset = (iRowset+2)*(1+uwRowsetSize)*udwRowSize; <br> <br>rc = SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 1); <br>if (SQL_SUCCESS != rc){ <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmt, SQL_SUCCESS, rc, szSQLFETCHSCROLL); <br>DISPLAYERROR(szQUICKREBIND,TEXT("Fetch Failed")); <br>goto abortQuikRebind; <br>} <br>FreeStmt(SQL_CLOSE); <br>} <br> <br>rc = SQLFreeStmt(hstmt, SQL_UNBIND); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>rc = SQLSetStmtAttr(hstmt,SQL_ATTR_ROW_ARRAY_SIZE,(PTR)1,SQL_IS_INTEGER); <br>if (SQL_SUCCESS != rc){ <br>DISPLAYERROR(szQUICKREBIND,TEXT("\t\t\tSetStmtAttr(Rowset Size)")); <br>goto abortQuikRebind; <br>} <br> <br>/* Check stored values: */ <br>for (iRowset=0; iRowset&lt;=1; iRowset++) <br>{ <br>if(SQL_SUCCESS != SelectFromTableFetch(lpqt, szColName)){ <br>DISPLAYERROR(szQUICKREBIND, TEXT("\t\t\tSelect-order by  Failed")); <br>goto abortQuikRebind; <br>} <br>  <br>/* First Rowset starts either in Allocated Row 0 or 3 */ <br>iRowsetRow= iRowset*(1+uwRowsetSize);   <br>//for (row=0; row&lt;NUM_QUIKREBIND_ROWSETS  ;row++,iRowsetRow++) <br>for (row=0; row&lt;(uwRowsetSize*2)  ;row++,iRowsetRow++) <br>{ <br>UWORD iResultSetCol=0; <br>if(row==uwRowsetSize)      <br>iRowsetRow+= 2+uwRowsetSize; /* Jump to 2nd Rowset */ <br> <br>/* Don't check data in "zero" row, * <br> * the spacer row between rowsets:*/ <br>if(iRowsetRow%(1+uwRowsetSize) == uwRowsetSize) <br>continue; <br> <br>/* Fetch next rowset */ <br>rc = SQLFetch(hstmt); <br>if (SQL_SUCCESS != rc){ <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmt, SQL_SUCCESS, rc, szSQLFETCH); <br>DISPLAYERROR(szQUICKREBIND,TEXT("Fetch Failed")); <br>goto abortQuikRebind; <br>}                       <br> <br>pCurrentRowData = rgData+iRowsetRow*cTypes; <br>for(iTableCol=0; iTableCol&lt;cTypes; iTableCol++) <br>{ <br>/* Ignore columns which aren't bound as they aren't in the result set */ <br>if((!iTableCol &amp;&amp; !fCol0Bound) || rgFields[iTableCol].fAutoUpdate) <br>continue; <br> <br>iResultSetCol++; <br>rc = SQLGetData(hstmt, iResultSetCol, SQL_C_TCHAR, rgbValue, MAX_STRING_SIZE, <br>&amp;cbValue); <br>if(rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO) <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br> <br>if(!CheckDataResults(row, iTableCol, &amp;rgFields[iTableCol], pCurrentRowData,cbValue,rgbValue)) <br>{ <br>wsprintf(lpqt-&gt;buf, TEXT("Data Check Failed, Row %d, Table Col %d, DataType %d (%s)"), <br>row, iTableCol, rgFields[iTableCol].wSQLType, rgFields[iTableCol].szFieldName) ; <br>szWrite(lpqt-&gt;buf,FALSE); <br>rgbValue[MAX_STRING_SIZE-1]=TEXT('\0'); <br>wsprintf(lpqt-&gt;buf, TEXT("Returned Data: (%s)"), rgbValue); <br>DISPLAYERROR(szQUICKREBIND,lpqt-&gt;buf); <br>goto abortQuikRebind;  <br>} <br>}/* end for(iTableCol) */ <br>} /* end for(row)  */ <br>FreeStmt(SQL_CLOSE); <br>} /* end for (iRowset)  */ <br> <br>/* Check Unused memory areas:    */ <br>for (iRowsetRow=uwRowsetSize; iRowsetRow&lt;NUM_QUIKREBIND_ROWSETS*(uwRowsetSize+1);  ) <br>{ <br>pCurrentRowData = rgData+iRowsetRow*cTypes; <br>if(memcmp(pCurrentRowData, pZeroRow, udwRowSize)) <br>DISPLAYERROR(szQUICKREBIND, <br>TEXT("Unused memory areas altered after Quick Rebind.")); <br>iRowsetRow+=(uwRowsetSize+1); <br>}                                                         <br>   <br> <br>abortQuikRebind: <br>ResetHstmt(&amp;hstmt); <br>if (rgbValue)                              <br>ReleaseMemory(rgbValue); <br>if (pZeroRow)                              <br>ReleaseMemory(pZeroRow); <br>ReleaseMemory(rgData); <br> <br>} /* TestQuickRebind() */ <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLForeignKeys <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLForeignKeys(QTSTRUCT  *lpqt) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if (!Supported(SQL_API_SQLFOREIGNKEYS)) <br>{ <br>rc = SQLForeignKeys(hstmt, NULL, 0, NULL, 0, lpqt-&gt;szTableName,  <br>SQL_NTS, NULL, 0, NULL, 0, NULL, 0); <br> <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLFOREIGNKEYS, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLFOREIGNKEYS); <br>} <br>else <br>{ <br>rc = SQLForeignKeys(hstmt, NULL, 0, NULL, 0, lpqt-&gt;szTableName, <br>SQL_NTS, NULL, 0, NULL, 0, NULL, 0); <br> <br>RETCHECK(SQL_SUCCESS, rc,szSQLFOREIGNKEYS); <br> <br>while(rc == SQL_SUCCESS)  <br>rc = SQLFetch(hstmt); <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} <br> <br>} //TestSQLForeignKeys() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLBrowseConnect <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLBrowseConnect(lpSERVERINFO lpSI) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDcMaxConnections=0; <br>TCHARszBCString[40]; <br>TCHARszDSN[40]; <br>HDBChdbcb=NULL; <br> <br>AllocHdbc(&amp;hdbcb); <br> <br>rc = SQLGetInfo(hdbc, SQL_ACTIVE_CONNECTIONS, &amp;cMaxConnections, sizeof(int), NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>if(cMaxConnections != 1)  <br>{ <br>lstrcpy(szBCString,TEXT("DSN=")); <br>lstrcat(szBCString, lpSI-&gt;szValidServer0); <br> <br>if(lpSI-&gt;szValidServer0[0] == 0) <br>{ <br>rc = SQLGetInfo(hdbc, SQL_DATA_SOURCE_NAME, &amp;szDSN, 40, NULL); <br>lstrcat(szBCString, szDSN); <br>} <br> <br>if(!Supported(SQL_API_SQLBROWSECONNECT)) <br>{ <br>HDBC thdbc=NULL; <br> <br>rc = SQLBrowseConnect(hdbcb, szBCString, SQL_NTS, NULL, 0, NULL); <br>thdbc = hdbc; <br>hdbc = hdbcb; <br>if(!FindError(SQL_HANDLE_DBC,szIM001)) <br>DISPLAYERROR(szSQLBROWSECONNECT, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLBROWSECONNECT); <br>hdbc = thdbc; <br> <br>rc = SQLFreeConnect(hdbcb); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREECONNECT); <br> <br>} <br>else <br>{ <br>rc = SQLBrowseConnect(hdbcb, szBCString, SQL_NTS, NULL, 0, NULL); <br>RETCHECK(SQL_NEED_DATA, rc,szSQLBROWSECONNECT); <br> <br>rc = SQLDisconnect(hdbcb); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDISCONNECT); <br>rc = SQLFreeConnect(hdbcb); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREECONNECT); <br>} <br>} <br> <br>} //TestSQLBrowseConnect() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLDataSources <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLDataSources() <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if (!Supported( SQL_API_SQLDATASOURCES)) <br>{ <br>rc = SQLDataSources(henv, SQL_FETCH_FIRST, NULL, 0, NULL, NULL, 0, NULL); <br> <br>if(!FindError(SQL_HANDLE_ENV,szIM001)) <br>DISPLAYERROR(TEXT("SQLDataSources"), szNotSupported); <br> <br>RETCHECK(SQL_ERROR, rc,TEXT("SQLDataSources")); <br>}  <br>else  <br>{ <br>rc = SQLDataSources(henv, SQL_FETCH_FIRST, NULL, 0, NULL, NULL, 0, NULL); <br>RETCHECK(SQL_SUCCESS, rc,TEXT("SQLDataSources")); <br>} <br> <br>} //TestSQLDataSources() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLDataSources <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLDrivers() <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if(!Supported( SQL_API_SQLDRIVERS))  <br>{ <br>rc = SQLDrivers(henv, SQL_FETCH_FIRST, NULL, 0, NULL, NULL, 0, NULL); <br>if(!FindError(SQL_HANDLE_ENV,szIM001)) <br>DISPLAYERROR(TEXT("SQLDrivers"), szNotSupported); <br>RETCHECK(SQL_ERROR, rc,TEXT("SQLDataSources")); <br>} <br>else <br>{ <br>rc = SQLDrivers(henv, SQL_FETCH_FIRST, NULL, 0, NULL, NULL, 0, NULL); <br>if(rc != SQL_SUCCESS) <br>RETCHECK(SQL_SUCCESS_WITH_INFO, rc,TEXT("SQLDrivers")); <br>} <br> <br>} //TestSQLDrivers() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLMoreResults <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLMoreResults(QTSTRUCT  *lpqt) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if(!Supported( SQL_API_SQLMORERESULTS))  <br>{ <br>SelectFromTable(lpqt); <br> <br>rc = SQLMoreResults(hstmt); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(TEXT("SQLMoreResults"), szNotSupported); <br>RETCHECK(SQL_ERROR, rc,TEXT("SQLMoreResults")); <br>} <br>else <br>{ <br>SelectFromTable(lpqt); <br> <br>rc = SQLMoreResults(hstmt); <br>RETCHECK(SQL_NO_DATA_FOUND, rc,TEXT("SQLMoreResults")); <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSQLMoreResults() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLMoreResults <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLNativeSQL(QTSTRUCT  *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszQuery[XLARGEBUFF]; <br> <br>wsprintf(szQuery,TEXT("select * from %s were 0 &gt; 1"),lpqt-&gt;szTableName); <br> <br>if(!Supported( SQL_API_SQLNATIVESQL)) <br>{ <br>rc = SQLNativeSql(hdbc, szQuery, SQL_NTS, NULL, 0, NULL); <br>if(!FindError(SQL_HANDLE_DBC,szIM001)) <br>DISPLAYERROR(TEXT("SQLNativeSql"), szNotSupported); <br>RETCHECK(SQL_ERROR, rc,TEXT("SQLNativeSql")); <br>} <br>else  <br>{ <br>rc = SQLNativeSql(hdbc, szQuery, SQL_NTS, NULL, 0, NULL); <br>RETCHECK(SQL_SUCCESS, rc,TEXT("SQLNativeSql")); <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSQLNativeSQL() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLDescribeParam <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLDescribeParam(QTSTRUCT  *lpqt) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>rc = SQLPrepare(hstmt, lpqt-&gt;szParamQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPREPARE); <br> <br>if(!Supported( SQL_API_SQLDESCRIBEPARAM))  <br>{ <br>rc = SQLPrepare(hstmt, lpqt-&gt;szParamQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPREPARE); <br>rc = SQLDescribeParam(hstmt, 1, NULL, NULL, NULL, NULL); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLDESCRIBEPARAM, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLDESCRIBEPARAM); <br>} <br>else <br>{ <br>rc = SQLPrepare(hstmt, lpqt-&gt;szParamQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPREPARE); <br>rc = SQLDescribeParam(hstmt, 1, NULL, NULL, NULL, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDESCRIBEPARAM); <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSQLDescribeParam() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLNumParams <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLNumParams(QTSTRUCT  *lpqt) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>rc = SQLPrepare(hstmt, lpqt-&gt;szParamQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPREPARE); <br> <br>if(!Supported( SQL_API_SQLNUMPARAMS))  <br>{ <br>rc = SQLNumParams(hstmt, NULL); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLNUMPARAMS, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLNUMPARAMS); <br>} <br>else <br>{ <br>rc = SQLNumParams(hstmt, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLNUMPARAMS); <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSQLNumParams() <br> <br> <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLParamOptions <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLParamOptions(QTSTRUCT *lpqt) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>rc = SQLPrepare(hstmt, lpqt-&gt;szParamQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPREPARE); <br> <br>if(!Supported( SQL_API_SQLPARAMOPTIONS))  <br>{ <br>rc = SQLParamOptions(hstmt, 1, NULL); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLPARAMOPTIONS, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLPARAMOPTIONS); <br>} <br>else <br>{ <br>rc = SQLParamOptions(hstmt, 1, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPARAMOPTIONS); <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSQLParamOptions() <br> <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLPrimaryKeys <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLPrimaryKeys(QTSTRUCT *lpqt) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if (!Supported( SQL_API_SQLPRIMARYKEYS)) <br>{ <br>rc = SQLPrimaryKeys(hstmt, NULL, 0, NULL, 0, lpqt-&gt;szTableName, SQL_NTS); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLPRIMARYKEYS, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLPRIMARYKEYS); <br>} <br>else <br>{ <br>rc = SQLPrimaryKeys(hstmt, NULL, 0, NULL, 0, lpqt-&gt;szTableName, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPRIMARYKEYS); <br>while(rc == SQL_SUCCESS)  <br>rc = SQLFetch(hstmt); <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} <br> <br>} //TestSQLPrimaryKeys() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLProcedureColumns <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLProcedureColumns(QTSTRUCT  *lpqt) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if(!Supported( SQL_API_SQLPROCEDURECOLUMNS))  <br>{ <br>rc = SQLProcedureColumns(hstmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(TEXT("SQLProcedureColumns"), szNotSupported); <br>RETCHECK(SQL_ERROR, rc,TEXT("SQLProcedureColumns")); <br>} <br>else  <br>{ <br>rc = SQLProcedureColumns(hstmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0); <br>RETCHECK(SQL_SUCCESS, rc,TEXT("SQLProcedureColumns")); <br>while(rc == SQL_SUCCESS) <br>rc = SQLFetch(hstmt); <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>FreeStmt(SQL_CLOSE); <br>} <br> <br>} //TestSQLProcedureColumns() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLProcedures <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLProcedures() <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if(!Supported( SQL_API_SQLPROCEDURES))  <br>{ <br>rc = SQLProcedures(hstmt, NULL, 0, NULL, 0, NULL, 0); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(TEXT("SQLProcedures"), szNotSupported); <br>RETCHECK(SQL_ERROR, rc,TEXT("SQLProcedures")); <br>} <br>else <br>{ <br>rc = SQLProcedures(hstmt, NULL, 0, NULL, 0, NULL, 0); <br>RETCHECK(SQL_SUCCESS, rc,TEXT("SQLProcedures")); <br>while(rc == SQL_SUCCESS) <br>rc = SQLFetch(hstmt); <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>FreeStmt(SQL_CLOSE); <br>} <br> <br>} //TestSQLProcedures() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLTablePrivileges <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLTablePrivileges() <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if(!Supported( SQL_API_SQLTABLEPRIVILEGES))  <br>{ <br>rc = SQLTablePrivileges(hstmt, NULL, 0, NULL, 0, NULL, 0); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(TEXT("SQLTablePrivileges"), szNotSupported); <br>RETCHECK(SQL_ERROR, rc,TEXT("SQLTablePrivileges")); <br>} <br>else <br>{ <br>rc = SQLTablePrivileges(hstmt, NULL, 0, NULL, 0, NULL, 0); <br>RETCHECK(SQL_SUCCESS, rc,TEXT("SQLTablePrivileges")); <br>while(rc == SQL_SUCCESS)  <br>rc = SQLFetch(hstmt); <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>FreeStmt(SQL_CLOSE); <br>} <br> <br>} //TestSQLTablePrivileges() <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLColumnPrivileges <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLColumnPrivileges(QTSTRUCT  *lpqt) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br> <br>if(!Supported( SQL_API_SQLCOLUMNPRIVILEGES))  <br>{ <br>rc = SQLColumnPrivileges(hstmt, NULL, 0, NULL, 0, lpqt-&gt;szTableName, SQL_NTS, <br>NULL, 0); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(TEXT("SQLColummPrivileges"), szNotSupported); <br>RETCHECK(SQL_ERROR, rc,TEXT("SQLColumnPrivileges")); <br>}  <br>else <br>{ <br>rc = SQLColumnPrivileges(hstmt, NULL, 0, NULL, 0, lpqt-&gt;szTableName, SQL_NTS, <br>NULL, 0); <br>RETCHECK(SQL_SUCCESS, rc,TEXT("SQLColumnPrivileges")); <br>while(rc == SQL_SUCCESS) <br>rc = SQLFetch(hstmt); <br> <br>RETCHECK(SQL_NO_DATA_FOUND, rc,szSQLFETCH); <br> <br>FreeStmt(SQL_CLOSE); <br>} <br> <br>} // TestSQLColumnPrivileges() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSQLSetScrollOptions <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLSetScrollOptions() <br>{ <br>RETCODErc=SQL_SUCCESS; <br>UWORDi, <br>j; <br>UDWORDfSupportedOpt; <br>UDWORDfSupportedCon; <br>TCHARszState[100]=TEXT(""), <br>szErrMsg[XLARGEBUFF]=TEXT(""); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>if(!Supported( SQL_API_SQLSETSCROLLOPTIONS))  <br>{ <br>rc = SQLSetScrollOptions(hstmt, SQL_CONCUR_READ_ONLY, SQL_SCROLL_FORWARD_ONLY, <br>1); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLSETSCROLLOPTIONS, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLSETSCROLLOPTIONS); <br>}  <br>else <br>{ <br>rc = SQLGetInfo(hdbc, SQL_SCROLL_CONCURRENCY, &amp;fSupportedCon, 4, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br>rc = SQLGetInfo(hdbc, SQL_SCROLL_OPTIONS, &amp;fSupportedOpt, 4, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>for(i = 0; i &lt; sizeof(OptionList) / sizeof(SUPPORTOPTINFO); i ++)  <br>{ <br>for(j = 0; j &lt; sizeof(ConcurList) / sizeof(SUPPORTCONCURINFO); j++)  <br>{ <br>if(fSupportedOpt &amp; OptionList[i].Support &amp;&amp; fSupportedCon &amp; ConcurList[j].Support)  <br>{ <br>if(!((ConcurList[j].Option == SQL_CONCUR_VALUES) &amp;&amp; ((lpSI-&gt;vCursorLib ==  <br>SQL_CUR_USE_IF_NEEDED) || (lpSI-&gt;vCursorLib == SQL_CUR_USE_ODBC)))) <br>{ <br>rc = SQLSetScrollOptions(hstmt, ConcurList[j].Option,OptionList[i].Option, 1); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETSCROLLOPTIONS); <br>} <br> <br>} <br>} <br>} <br>} <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} //TestSQLSetScrollOptions() <br> <br> <br>//----------------------------------------------------------------------------- <br>//Function:  TestConnectAttr <br>//----------------------------------------------------------------------------- <br> <br>VOID PASCAL TestConnectAttr(HDBC hdbc,SDWORD fAttribute, UDWORD rgbValue,LPTSTR lpAttr,BOOL fReadOnlyAttr) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszBuff[LARGEBUFF]=TEXT(""); <br>UDWORDpvParam=0; <br>RETCODErcExp=fReadOnlyAttr ? SQL_ERROR : SQL_SUCCESS; <br> <br>rc = SQLSetConnectAttr(hdbc,fAttribute,(PTR)rgbValue,sizeof(rgbValue)); <br> <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>{ <br> <br>RETCHECK(rcExp,rc,szSQLSETCONNECTATTR); <br> <br>rc = SQLGetConnectAttr(hdbc,fAttribute,&amp;pvParam,sizeof(pvParam),NULL); <br> <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>{ <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETCONNECTATTR); <br> <br>if(!fReadOnlyAttr &amp;&amp; (pvParam != rgbValue)) <br>{ <br>wsprintf(szBuff,TEXT("%s returned incorrect value"),lpAttr); <br>DISPLAYERROR(szSQLGETCONNECTATTR,szBuff); <br>} <br>} <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLGETCONNECTATTR); <br>} <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLSETCONNECTATTR);  <br> <br>} //TestConnectAttr() <br> <br> <br>//----------------------------------------------------------------------------- <br>//Function:  TestSQLSetConnectAttr <br>//     This function tests both SQLSetConnectAttr and SQLGetConnectAttr <br>//----------------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLSetConnectAttr() <br>{ <br>RETCODE rc = SQL_SUCCESS; <br>UDWORDpvParam; </code></pre>
<p>
</p>
<pre><code>UWORDrgbValue; <br>BOOLfSupportSetConnectAttr = TRUE; <br>BOOLfSupportGetConnectAttr = TRUE; <br> <br>//make sure these APIs are supported before testing <br>if(!Supported(SQL_API_SQLSETCONNECTATTR)) <br>{ <br>rgbValue = SQL_MODE_READ_WRITE; <br>fSupportSetConnectAttr = FALSE; <br>rc = SQLSetConnectAttr(hdbc,SQL_ACCESS_MODE,&amp;rgbValue,sizeof(rgbValue)); <br>if(!FindError(SQL_HANDLE_DBC,szIM001)) <br>DISPLAYERROR(szSQLSETCONNECTATTR,TEXT("did not return Not supported message")); <br>RETCHECK(SQL_ERROR,rc,szSQLSETCONNECTATTR); <br>} <br> <br>if(!Supported(SQL_API_SQLGETCONNECTATTR)) <br>{ <br>fSupportGetConnectAttr = FALSE; <br>rc = SQLGetConnectAttr(hdbc,SQL_ACCESS_MODE,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_DBC,szIM001)) <br>DISPLAYERROR(szSQLGETCONNECTATTR,TEXT("did not return Not supported message")); <br>RETCHECK(SQL_ERROR,rc,szSQLGETCONNECTATTR); <br>} <br> <br>if(fSupportSetConnectAttr &amp;&amp; (!fSupportGetConnectAttr)) <br>{ <br>//test SQL_ACCESS_MODE <br>rgbValue = SQL_MODE_READ_WRITE; <br>rc = SQLSetConnectAttr(hdbc,SQL_ACCESS_MODE,&amp;rgbValue,sizeof(rgbValue)); <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLSETCONNECTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLSETCONNECTATTR); <br>//test SQL_AUTOCOMMIT <br>rgbValue = SQL_AUTOCOMMIT_ON; <br>rc = SQLSetConnectAttr(hdbc,SQL_AUTOCOMMIT,&amp;rgbValue,sizeof(rgbValue)); <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLSETCONNECTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLSETCONNECTATTR); <br>//test SQL_LOGIN_TIMEOUT <br>//the choice of 15 seconds for timeout is arbitrary <br>rgbValue = 15; <br>rc = SQLSetConnectAttr(hdbc,SQL_LOGIN_TIMEOUT,&amp;rgbValue,sizeof(rgbValue)); <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLSETCONNECTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLSETCONNECTATTR); <br>} <br> <br>if((!fSupportSetConnectAttr) &amp;&amp; fSupportGetConnectAttr) <br>{ <br>//test SQL_ACCESS_MODE <br>rc = SQLGetConnectAttr(hdbc,SQL_ACCESS_MODE,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETCONNECTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLGETCONNECTATTR); <br>//test SQL_AUTOCOMMIT <br>rc = SQLGetConnectAttr(hdbc,SQL_AUTOCOMMIT,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETCONNECTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLGETCONNECTATTR); <br>//test SQL_LOGIN_TIMEOUT <br>rc = SQLGetConnectAttr(hdbc,SQL_LOGIN_TIMEOUT,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETCONNECTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLGETCONNECTATTR); <br>//SQL_ATTR_AUTO_IPD is a read-only attribute <br>rc = SQLGetConnectAttr(hdbc,SQL_ATTR_AUTO_IPD,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_DBC,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETCONNECTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLGETCONNECTATTR); <br>} <br> <br>if(fSupportSetConnectAttr &amp;&amp; fSupportGetConnectAttr) <br>{ <br> <br>//test SQL_ACCESS_MODE <br>TestConnectAttr(hdbc,SQL_ACCESS_MODE,SQL_MODE_READ_WRITE,TEXT("SQL_ACCESS_MODE"),FALSE); <br> <br>//test SQL_AUTOCOMMIT <br>TestConnectAttr(hdbc,SQL_AUTOCOMMIT,SQL_AUTOCOMMIT_ON,TEXT("SQL_AUTOCOMMIT"),FALSE); <br> <br>//test SQL_LOGIN_TIMEOUT <br>//the choice of 15 seconds for timeout is arbitrary <br>TestConnectAttr(hdbc,SQL_LOGIN_TIMEOUT,15,TEXT("SQL_LOGIN_TIMEOUT"),FALSE); <br> <br>//SQL_ATTR_AUTO_IPD is a read-only attribute <br>TestConnectAttr(hdbc,SQL_ATTR_AUTO_IPD,15,TEXT("SQL_ATTR_AUTO_IPD"),TRUE); <br>} <br> <br>} //TestSQLSetConnectAttr() <br> <br> <br> <br>//----------------------------------------------------------------------------- <br>//Function:  TestSQLSetStmtAttr <br>//     This function tests both SQLSetStmtAttr and SQLGetStmtAttr <br>//----------------------------------------------------------------------------- <br> <br>void  PASCAL TestSQLSetStmtAttr() <br>{ <br>RETCODE rc = SQL_SUCCESS, rc2= SQL_SUCCESS; <br>UDWORDpvParam; <br>UWORDrgbValue; <br>BOOLfSupportSetStmtAttr = TRUE; <br>BOOLfSupportGetStmtAttr = TRUE; <br> <br>//make sure these APIs are supported before testing <br>if(!Supported(SQL_API_SQLSETSTMTATTR)) <br>{ <br>//the choice of 300 for SQL_MAX_LENGTH is arbitrary <br>rgbValue = 300; <br>fSupportSetStmtAttr = FALSE; <br>rc = SQLSetStmtAttr(hstmt,SQL_MAX_LENGTH,&amp;rgbValue,sizeof(rgbValue)); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLSETSTMTATTR,TEXT("did not return Not supported message")); <br>RETCHECK(SQL_ERROR,rc,szSQLSETSTMTATTR); <br>} <br> <br>if(!Supported(SQL_API_SQLGETSTMTATTR)) <br>{ <br>fSupportGetStmtAttr = FALSE; <br>rc = SQLGetStmtAttr(hstmt,SQL_MAX_LENGTH,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLGETSTMTATTR,TEXT("did not return Not supported message")); <br>RETCHECK(SQL_ERROR,rc,szSQLGETSTMTATTR); <br>} <br> <br>if(fSupportSetStmtAttr &amp;&amp; (!fSupportGetStmtAttr)) <br>{ <br>//test SQL_MAX_LENGTH <br>rgbValue = 300; <br>rc = SQLSetStmtAttr(hstmt,SQL_MAX_LENGTH,&amp;rgbValue,sizeof(rgbValue)); <br>if(!FindError(SQL_HANDLE_STMT,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLSETSTMTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLSETSTMTATTR); <br>//test SQL_ATTR_METADATA_ID -- new in 3.0 <br>rgbValue = SQL_FALSE; <br>rc = SQLSetStmtAttr(hstmt,SQL_ATTR_METADATA_ID,&amp;rgbValue,sizeof(rgbValue)); <br>if(!FindError(SQL_HANDLE_STMT,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLSETSTMTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLSETSTMTATTR); <br>} <br> <br>if((!fSupportSetStmtAttr) &amp;&amp; fSupportGetStmtAttr) <br>{ <br>//test SQL_MAX_LENGTH <br>rc = SQLGetStmtAttr(hstmt,SQL_MAX_LENGTH,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_STMT,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETSTMTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLGETSTMTATTR); <br>//test SQL_ATTR_METADATA_ID -- new in 3.0 <br>rc = SQLGetStmtAttr(hstmt,SQL_ATTR_METADATA_ID,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_STMT,szHYC00)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETSTMTATTR); <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLGETSTMTATTR); <br>} <br> <br>if(fSupportSetStmtAttr &amp;&amp; fSupportGetStmtAttr) <br>{ <br> <br>//test SQL_MAX_LENGTH <br>rgbValue = 300; <br>rc = SQLSetStmtAttr(hstmt,SQL_MAX_LENGTH,(PTR)rgbValue,sizeof(rgbValue)); <br>if(!FindError(SQL_HANDLE_STMT,szHYC00)) <br>{ <br>RETCHECK(SQL_SUCCESS,rc,szSQLSETSTMTATTR); <br>rc = SQLGetStmtAttr(hstmt,SQL_MAX_LENGTH,&amp;pvParam,sizeof(pvParam),NULL); <br>if(!FindError(SQL_HANDLE_STMT,szHYC00)) <br>{ <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETSTMTATTR); <br>if(pvParam != 300) <br>DISPLAYERROR(szSQLGETSTMTATTR,TEXT("SQL_MAX_LENGTH returned incorrect value")); <br>} <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLGETSTMTATTR); <br>} <br>else <br>RETCHECK(SQL_ERROR,rc,szSQLSETSTMTATTR); <br> <br> <br>//test SQL_ATTR_METADATA_ID -- new in 3.0 <br>rgbValue = SQL_FALSE; <br>rc = SQLSetStmtAttr(hstmt,SQL_ATTR_METADATA_ID,(PTR)rgbValue,sizeof(rgbValue)); <br>if (!FindError(SQL_HANDLE_STMT,szHYC00) &amp;&amp; !FindError(SQL_HANDLE_STMT,szHY092)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLSETSTMTATTR); <br> <br>rc2 = SQLGetStmtAttr(hstmt,SQL_ATTR_METADATA_ID,&amp;pvParam,sizeof(pvParam),NULL); <br>if (!FindError(SQL_HANDLE_STMT,szHYC00) &amp;&amp; !FindError(SQL_HANDLE_STMT,szHY092)) <br>RETCHECK(SQL_SUCCESS,rc,szSQLGETSTMTATTR); <br> <br>if (RC_SUCCESSFUL(rc) &amp;&amp; RC_SUCCESSFUL(rc2) &amp;&amp; pvParam != SQL_FALSE) <br>DISPLAYERROR(szSQLGETSTMTATTR,TEXT("SQL_ATTR_METADATA_ID returned incorrect value")); <br>} <br> <br>} //TestSQLSetStmtAttr() <br> <br>//-------------------------------------------------------------------------------- <br>// FUNCTION:TestOneThread <br>// PURPOSE:This function allocates the statement handle, performs simple  <br>//queries and deallocates the statement handle.  This function is called <br>//by testthreading. <br>//-------------------------------------------------------------------------------- <br>static int TestOneThread(THREAD_STRUCT *ptArg) <br>{ <br>HENVhenv0 = ptArg-&gt;henv; <br>HDBChdbc0 = ptArg-&gt;hdbc; <br>HSTMThstmt0 = NULL; <br>//RETCODErc=SQL_SUCCESS; <br> <br>/* allocate new statment handle */ <br>if (RC_NOTSUCCESSFUL(SQLAllocHandle(SQL_HANDLE_STMT,hdbc0, &amp;hstmt0))) <br>return(FALSE); <br> <br>/* perform some simple catalog functions */ <br>if (RC_NOTSUCCESSFUL(SQLStatistics(hstmt0,NULL,SQL_NTS,NULL,SQL_NTS,NULL,SQL_NTS,SQL_INDEX_ALL,SQL_QUICK))) <br>return(FALSE); <br> <br>if (RC_NOTSUCCESSFUL(SQLCloseCursor(hstmt0))) <br>return(FALSE); <br> <br>/* Get some data */ <br>GetSomeData(hstmt0, ptArg-&gt;szTableName, TRUE,ptArg-&gt;rgFieldInfo); <br> <br>if (RC_NOTSUCCESSFUL(SQLGetTypeInfo(hstmt0,SQL_CHAR))) <br>return(FALSE); <br> <br>// Cleanup <br>if (RC_NOTSUCCESSFUL(SQLFreeHandle(SQL_HANDLE_STMT,hstmt0))) <br>return(FALSE); <br> <br>return(TRUE); <br> <br>} //end of TestOneThread <br> <br>//-------------------------------------------------------------------------------- <br>// FUNCTION:ThreadLoop <br>// PURPOSE:This is the main loop for the threads, and it's called by  <br>//CreateThread() API. <br>//-------------------------------------------------------------------------------- <br>DWORD WINAPI ThreadLoop(void *pArg) <br>{ <br> <br>THREAD_STRUCT *ptArg = (THREAD_STRUCT *)pArg; <br>int i; <br>RETCODErc; <br> <br>for(i=0; i&lt; NUM_THREAD; i++) <br>TestOneThread(ptArg); <br> <br>// free connection handle for each thread <br>rc=SQLDisconnect(ptArg-&gt;hdbc); <br>    RETCHECK(SQL_SUCCESS,rc,szSQLDISCONNECT); <br>rc=SQLFreeHandle(SQL_HANDLE_DBC,ptArg-&gt;hdbc); <br>RETCHECK(SQL_SUCCESS,rc,szSQLFREEHANDLE); <br> <br>   return(0); <br>} //end of ThreadLoop <br> <br> <br>//------------------------------------------------------------------------------- <br>// FUNCTION:TestThreading <br>// PURPOSE:This function tests the multi-threading capabilities of the  <br>//driver by creating multiple threads that connect to the same data <br>// source.  Once connected, each thread performs simple queries to  <br>//test that the driver handles these queries successfully. <br>//This function is to be called inside AutoTestFunc() in QuikTest. <br>//-------------------------------------------------------------------------------- <br>void TestThreading(lpSERVERINFO lpSI,QTSTRUCT  *lpqt,FIELDINFO *rgFieldInfo) <br>{ <br>RETCODE rc=SQL_SUCCESS; <br>   THREAD_STRUCT *pArg; <br>   HANDLE hThread[NUM_THREAD]; <br>DWORD dwThreadId; <br>UWORD i; <br>HENVhenv1; <br>HDBChdbc1; <br> <br> <br>// allocate memory for the threads <br>pArg = (THREAD_STRUCT *)AllocateMemory((NUM_THREAD) * sizeof(THREAD_STRUCT)); <br> <br>if(!pArg) <br>{ <br>szWrite(TEXT("\t\t\tMultiThreading Test interrupted due to error in memory allocation"), TRUE); <br>return; <br>} <br> <br>// only one environment handle will be needed for all threads <br>rc = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv1); <br>RETCHECK(SQL_SUCCESS, rc,szSQLALLOCHANDLE); <br> <br>// Set environment attribute, or we can't allocate connection <br>rc = SQLSetEnvAttr(henv1, SQL_ATTR_ODBC_VERSION, (SQLPOINTER)SQL_OV_ODBC3, <br>SQL_IS_UINTEGER); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETENVATTR); <br> <br>for (i=0; i &lt; NUM_THREAD; i++ )  <br>{ <br>// allocate connection handle for each thread <br>rc=SQLAllocHandle(SQL_HANDLE_DBC,henv1, &amp;hdbc1); <br>RETCHECK(SQL_SUCCESS, rc,szSQLALLOCHANDLE); <br> <br>// create string to be used in connecting <br>wsprintf(lpqt-&gt;sz,TEXT("dsn=%s;uid=%s;pwd=%s;"), <br>lpSI-&gt;szValidServer0, <br>lpSI-&gt;szValidLogin0, <br>lpSI-&gt;szValidPassword0); <br> <br>SQLDriverConnect(hdbc1, lpSI-&gt;hwnd, lpqt-&gt;sz, <br>SQL_NTS, lpqt-&gt;buf, MAX_STRING_SIZE, NULL, SQL_DRIVER_COMPLETE); <br> <br>// initialize thread structure <br>pArg[i].henv = henv1; <br>pArg[i].hdbc = hdbc1; <br>lstrcpy(pArg[i].szTableName, lpqt-&gt;szTableName); <br>pArg[i].rgFieldInfo=rgFieldInfo[0]; <br> <br>// start thread <br>hThread[i]= CreateThread(NULL, <br>0, <br>ThreadLoop, <br>&amp;pArg[i], <br>0, <br>&amp;dwThreadId); <br> <br>if(hThread[i]==0) <br>{ <br>DISPLAYERROR(TEXT("TestThread failed:"),TEXT("cannot create thread")); <br>break; <br>} <br>} <br> <br>// wait for thread completion <br>WaitForMultipleObjects(NUM_THREAD,hThread,TRUE,INFINITE); <br> <br>for(i=0; i&lt;NUM_THREAD; i++ ) <br>    CloseHandle(hThread[i]); <br> <br>SQLFreeHandle(SQL_HANDLE_ENV,henv1); <br>if (pArg) <br>ReleaseMemory(pArg); <br>}//end of TestThreading() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               CreateDescRecord <br>//----------------------------------------------------------------------- <br>SWORD CreateDescRecord(SQLHDESC hdesc, SQLHSTMT hstmt, UWORD uwDescType) <br>{ <br>UDWORD cbColDef; <br>SWORD swColCount; <br>SQLRETURN rc; <br>SWORD fType, fSQLType; <br>SWORD ibScale; <br>TCHAR rgBuf[100]; <br> <br>switch(uwDescType) { <br>case SQL_ATTR_APP_ROW_DESC: <br>rc = SQLSetDescField(hdesc, 1, SQL_DESC_TYPE, (SQLPOINTER)SQL_C_DEFAULT, <br>SQL_IS_SMALLINT); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc,szSQLSETDESCFIELD); <br> <br>if (SQL_SUCCEEDED(rc)) <br>return 1; <br> <br>rc=SQLBindCol(hstmt, 1, SQL_C_TCHAR, rgBuf, sizeof(rgBuf), NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLBINDCOL); <br>if (SQL_SUCCEEDED(rc)) <br>return 1; <br>break; <br>case SQL_ATTR_IMP_PARAM_DESC: <br>case SQL_ATTR_APP_PARAM_DESC: <br>// Select statement has already been done by this time <br>rc=SQLDescribeCol(hstmt, 1, NULL, 0, NULL, &amp;fSQLType, &amp;cbColDef,  <br>&amp;ibScale, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDESCRIBECOL); <br>if (!SQL_SUCCEEDED(rc)) <br>return 0; <br> <br>if (SQL_ATTR_APP_PARAM_DESC == uwDescType) <br>fType=SQL_C_TCHAR; <br>else <br>fType=fSQLType; <br> <br>rc = SQLSetDescField(hdesc, 1, SQL_DESC_TYPE, (SQLPOINTER)fType, <br>SQL_IS_SMALLINT); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc,szSQLSETDESCFIELD); <br> <br>if (SQL_SUCCEEDED(rc)) <br>return 1; <br> <br>rc=SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_TCHAR, <br>fSQLType, cbColDef, ibScale, rgBuf, sizeof(rgBuf), NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLDESCRIBECOL); <br>if (SQL_SUCCEEDED(rc)) <br>return 1; <br>break; <br>case SQL_ATTR_IMP_ROW_DESC: <br>// Quiktest has already done the select for us <br>// Need to find out how many cols in result set <br>rc=SQLNumResultCols(hstmt, &amp;swColCount); <br>if (SQL_SUCCEEDED(rc)) <br>return(swColCount); <br>break; <br>} <br>return 0; <br>}//CreateDescRecord <br> <br>//----------------------------------------------------------------------- <br>//      Function:               CheckDescOp <br>//----------------------------------------------------------------------- <br>void CheckDescOp(SQLHDESC hdesc, SQLRETURN rc, SQLUSMALLINT uwDescIndex, <br>SQLSMALLINT swDescRecCount, SQLSMALLINT swDescRec, SQLUSMALLINT iDescField, <br>SQLINTEGER swUpdateMode) <br>{ <br>TCHAR * pszAPI, szOp[10]; <br>SQLSMALLINT fValidOp;// Descriptor types operation is valid for <br> <br>if (DESC_UPDATE_MODE_READ == swUpdateMode) <br>{ <br>pszAPI=szSQLGETDESCFIELD; <br>lstrcpy(szOp, TEXT("read")); <br>fValidOp=rgDescInfo[iDescField].fGettable; <br>} <br>else <br>{ <br>pszAPI=szSQLSETDESCFIELD; <br>lstrcpy(szOp, TEXT("write")); <br>fValidOp=rgDescInfo[iDescField].fSettable; <br>} <br> <br>// If we're reading beyond the last record, expect SQL_NO_DATA. <br>if (swDescRec &gt; swDescRecCount &amp;&amp; DESC_UPDATE_MODE_READ == swUpdateMode) <br>{ <br>wsprintf(buf,TEXT("%s: Able to %s descriptor field %s in the %s beyond last record."), <br>pszAPI, szOp, rgDescInfo[iDescField].szDescFieldName, DescTypes[uwDescIndex].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_NO_DATA, rc, buf); <br>} <br>else <br>{ <br>if (fValidOp &amp; DescTypes[uwDescIndex].uwTypeMask) <br>{ <br>wsprintf(buf,TEXT("%s: Unable to %s descriptor field %s in the %s"), <br>pszAPI, szOp, rgDescInfo[iDescField].szDescFieldName, DescTypes[uwDescIndex].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc, buf); <br>} <br>else <br>{ <br>wsprintf(buf,TEXT("%s: Able to %s descriptor field %s in the %s"), <br>pszAPI, szOp, rgDescInfo[iDescField].szDescFieldName, DescTypes[uwDescIndex].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_ERROR, rc, buf); <br>} <br>} <br>} <br> <br>//----------------------------------------------------------------------- <br>// <br>// Function: CompareDescField <br>// <br>// Compares two fields from the given descriptor, or to rgDescInfo if hdesc2 <br>// is NULL.  uwDescField contains the entry in rgDescInfo for the desired field  <br>//----------------------------------------------------------------------- <br> <br>void CompareDescField(SQLHDESC hdesc1, SQLHDESC hdesc2, SQLUSMALLINT uwDescIndex, <br>SQLSMALLINT swDescRec, SQLSMALLINT swDescRecCount, SQLUSMALLINT uwDescField, <br>TCHAR * pszAPI) <br>{ <br>SQLRETURN rc; <br> SQLTCHAR DescBuf2[MAX_DESC_BUF]; <br>SQLINTEGER cbValue2;  <br> <br>// Make sure we've got a valid descriptor handle for hdesc1 <br>// (hdesc2 is allowed to be NULL) <br>if (SQL_NULL_HDESC == hdesc1) { <br>wsprintf(buf,TEXT("\t\tCompareDescriptor: hdesc1 handle was null!")); <br>DISPLAYERROR(pszAPI, buf); <br>return; <br>} <br> <br>// Read the value from hdesc1 <br>rc = SQLGetDescField(hdesc1, swDescRec, rgDescInfo[uwDescField].uwDescField, <br>&amp;DescBuf, sizeof(DescBuf), &amp;cbValue); <br> <br>CheckDescOp(hdesc1, rc, uwDescIndex, swDescRecCount, swDescRec, uwDescField, DESC_UPDATE_MODE_READ); <br> <br>cbValue2=rgDescInfo[uwDescField].cbValue; <br> <br>// Get the value to compare to <br>if (SQL_NULL_HDESC == hdesc2) { <br> <br>// Compare to rgDescInfo if it's settable <br>if (rgDescInfo[uwDescField].fSettable &amp; DescTypes[uwDescIndex].uwTypeMask) { <br> <br>// Copy the set value into DescBuf2.  For char fields size is 0 <br>// (unknown), and the new value is actually the pointer to the start <br>// of the string. <br>SQLPOINTER pNewvalue = &amp;(rgDescInfo[uwDescField].NewValue); <br> <br>if (!rgDescInfo[uwDescField].size) <br>{ <br>pNewvalue = (SQLPOINTER)rgDescInfo[uwDescField].NewValue; <br>cbValue2= (lstrlen(pNewvalue)+1) * sizeof(TCHAR);  <br>} <br> <br>memcpy(&amp;DescBuf2, pNewvalue, cbValue2); <br>} <br>} <br>else { <br> <br>// Compare to hdesc2 <br>rc = SQLGetDescField(hdesc2, swDescRec, rgDescInfo[uwDescField].uwDescField, <br>&amp;DescBuf2, sizeof(DescBuf2), &amp;cbValue); <br> <br>// Since hdesc2 is an unassociated hdesc, treat it as an ARD <br>// (uwDescIndex=0) <br>CheckDescOp(hdesc2, rc, 0, swDescRecCount, swDescRec, uwDescField, DESC_UPDATE_MODE_READ); <br>} <br> <br>// Perform the compare if settable in source desc and settable in <br>// target desc (application descriptors) when using hdesc2 <br>if (rgDescInfo[uwDescField].fSettable &amp; DescTypes[uwDescIndex].uwTypeMask) <br>{ <br>if (!hdesc2 || (rgDescInfo[uwDescField].fSettable &amp; DESC_ARD)) <br>{ <br>// IPD field SQL_DESC_TYPE is settable for consitency check, but set <br>// value can't be retrieved, so skip compare in this case <br>if (SQL_ATTR_IMP_PARAM_DESC != DescTypes[uwDescIndex].uwDescType || <br>SQL_DESC_DATA_PTR != rgDescInfo[uwDescField].uwDescField) <br>{ <br>if (memcmp(DescBuf, DescBuf2, cbValue2)) { <br>// Compare error, print message <br>wsprintf(buf,TEXT("Compare error in %s field %s"), <br>DescTypes[uwDescIndex].szDescName,rgDescInfo[uwDescField].szDescFieldName); <br>DISPLAYERROR(pszAPI, buf); <br>} <br>} <br>} <br>} <br>} <br> <br> <br>//----------------------------------------------------------------------- <br>// <br>// Function:  CheckDescriptor <br>// <br>// Checks all fields in all records of given descriptor.  If swUpdateMode is <br>// DESC_UPDATE_MODE_READ then all fields are read, otherwise all updatable <br>// fields are written. <br>//----------------------------------------------------------------------- <br>void CheckDescriptor(SQLHDESC hdesc, SQLINTEGER swUpdateMode, SQLHSTMT hstmt, UWORD uwDescIndex) <br>{ <br> SQLINTEGER cbValue2; <br>SQLSMALLINT swDescRec=0, swDescRecCount, swAdditionalRecs=0; <br>SQLUSMALLINT iDescField, iStartField=0; <br>SQLRETURN rc; <br> <br>// Get the descriptor record count. <br>rc = SQLGetDescField(hdesc, 0, SQL_DESC_COUNT, &amp;swDescRecCount, <br>sizeof(swDescRecCount), &amp;cbValue); <br> <br>if (SQL_SUCCESS == rc) { <br> <br>// In read mode, try to read one past last record <br>if (swUpdateMode == DESC_UPDATE_MODE_READ) <br>swAdditionalRecs=1; <br> <br>// Check all records, including header <br>for (swDescRec=0; swDescRec &lt;= swDescRecCount+swAdditionalRecs; swDescRec++) { <br> <br>// Check all fields <br>for (iDescField=iStartField; iDescField &lt; sizeof(rgDescInfo)/sizeof(rgDescInfo[0]); iDescField++) { <br> <br>// If we've gone past the header fields, then break out of loop to check record fields <br>if (0 == swDescRec &amp;&amp; !rgDescInfo[iDescField].fHeader) { <br>iStartField=iDescField; <br>break; <br>} <br> <br>if (DESC_UPDATE_MODE_READ == swUpdateMode) <br>{ <br>// Read from the field <br>rc = SQLGetDescField(hdesc, swDescRec, rgDescInfo[iDescField].uwDescField, <br>&amp;DescBuf, sizeof(DescBuf), &amp;cbValue); <br> <br>CheckDescOp(hdesc, rc, uwDescIndex, swDescRecCount, swDescRec, iDescField, swUpdateMode); <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>// Compare cbValue with expected <br>cbValue2=rgDescInfo[iDescField].cbValue; // For most fields <br> <br>if (!rgDescInfo[iDescField].size) <br>cbValue2 = lstrlen((LPTSTR)DescBuf);  // For string fields <br> <br>// Make sure cbValue and cbValue2 agree <br>if (cbValue != cbValue2) <br>{ <br>wsprintf(buf,TEXT("Compare error in %s field %s, expected")\ <br>TEXT(" StringLength %d, received %d"), DescTypes[uwDescIndex].szDescName, <br>rgDescInfo[iDescField].szDescFieldName, cbValue2, cbValue); <br>DISPLAYERROR(szSQLGETDESCFIELD, buf); <br>} <br>} <br>} <br>else <br>{ <br>// Write to the field.  For char fields size is 0 (unknown), <br>// so compute the length of the string <br>rc = SQLSetDescField(hdesc, swDescRec, rgDescInfo[iDescField].uwDescField, <br>(SQLPOINTER)rgDescInfo[iDescField].NewValue, <br>(rgDescInfo[iDescField].size) ? rgDescInfo[iDescField].size : <br>lstrlen((LPTSTR)rgDescInfo[iDescField].NewValue)*sizeof(TCHAR)); <br> <br>CheckDescOp(hdesc, rc, uwDescIndex, swDescRecCount, swDescRec, iDescField, swUpdateMode); <br> <br>if (RC_SUCCESSFUL(rc)) <br>CompareDescField(hdesc, NULL, uwDescIndex, swDescRec, swDescRecCount,iDescField, szSQLSETDESCFIELD); <br>} <br>} <br>} <br>} <br>else { <br>// Unable to read record count from descriptor header, can't proceed <br>wsprintf(buf,TEXT("\t\tUnable to read record count from descriptor header.")); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc, buf); <br>} <br>} <br> <br>//----------------------------------------------------------------------- <br>// <br>// Function:  CompareDescriptor <br>// <br>// Compares two descriptors, or if hdesc2 is NULL compares hdesc1 to rgDescInfo <br>// updatable columns <br>//----------------------------------------------------------------------- <br> <br>void CompareDescriptor(SQLHDESC hdesc1, SQLHDESC hdesc2, UWORD uwDescIndex, TCHAR * pszAPI) <br>{ <br> SQLSMALLINT swDescRec, swDescRecCount; <br>SQLUSMALLINT iDescField, iStartField=0; <br>SQLRETURN rc; <br> <br>// Make sure we've got a valid descriptor handle for hdesc1 <br>// (hdesc2 is allowed to be NULL) <br>if (SQL_NULL_HDESC == hdesc1) { <br>wsprintf(buf,TEXT("\t\thCompareDescriptor: hdesc1 handle was null!")); <br>DISPLAYERROR(szSQLGETDESCFIELD, buf); <br>return; <br>} <br> <br>// Get the descriptor record count. <br>rc = SQLGetDescField(hdesc1, 0, SQL_DESC_COUNT, &amp;swDescRecCount, <br>sizeof(swDescRecCount), &amp;cbValue); <br> <br>if (SQL_SUCCESS == rc) { <br> <br>// Check all records, including header <br>for (swDescRec=0; swDescRec &lt;= swDescRecCount; swDescRec++) { <br> <br>// Check all fields <br>for (iDescField=iStartField; iDescField &lt; sizeof(rgDescInfo)/sizeof(rgDescInfo[0]); iDescField++) { <br> <br>// If we've gone past the header fields, then break out of loop to check record fields <br>if (0 == swDescRec &amp;&amp; !rgDescInfo[iDescField].fHeader) { <br>iStartField=iDescField; <br>break; <br>} <br> <br>CompareDescField(hdesc1, hdesc2, uwDescIndex, swDescRec, swDescRecCount, iDescField, pszAPI); <br>} <br>} <br>} <br>else { <br>// Unable to read record count from descriptor header, can't proceed <br>wsprintf(buf,TEXT("\t\tUnable to read record count from descriptor header.")); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc1, SQL_SUCCESS, rc, buf); <br>} <br>} <br> <br> <br>void CheckDescRecord(SQLHDESC hdesc, SQLSMALLINT swDescRec, SQLSMALLINT fType, <br>           SQLSMALLINT fSubType, SQLINTEGER cbLength, SQLSMALLINT ibPrecision, SQLSMALLINT ibScale, <br>           SQLPOINTER pData, SQLINTEGER *pcbValue, SQLINTEGER *pIndicator, SQLUSMALLINT iDescType) <br>{ <br>SQLINTEGER Length, * pIndicator2; <br>PTR pDescPtr; <br>SQLRETURN rc; <br>SQLSMALLINT fType2, fSubType2, cbName, Precision, Scale, Nullable; <br>TCHARszName[MAX_DESC_BUF]=TEXT(""); <br> <br>// Write the record <br>rc = SQLSetDescRec(hdesc, swDescRec, fType, fSubType, cbLength, ibPrecision,  <br>ibScale, pData, pcbValue, pIndicator); <br> <br>// Can't set IRD, so it should error <br>if (SQL_ATTR_IMP_ROW_DESC == DescTypes[iDescType].uwDescType) <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_ERROR, rc, szSQLSETDESCREC); <br>else <br>{ <br>wsprintf(buf,TEXT("%s: Unable to write record %d in %s"), <br>szSQLSETDESCREC, swDescRec, DescTypes[iDescType].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc, buf); <br>} <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>// Read it again <br>rc = SQLGetDescRec(hdesc, swDescRec, szName, sizeof(szName), &amp;cbName, &amp;fType2, <br>&amp;fSubType2, &amp;Length, &amp;Precision, &amp;Scale, &amp;Nullable); <br> <br>wsprintf(buf,TEXT("%s: Unable to read record %d in %s"), <br>szSQLGETDESCREC, swDescRec, DescTypes[iDescType].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc, buf); <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>// Compare values <br>if (fType2 != fType) <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("fType not set correctly")); <br> <br>if (Precision != ibPrecision) <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("ibPrecision not set correctly")); <br> <br>switch(fType) <br>{ <br>case SQL_DECIMAL: <br>case SQL_NUMERIC: <br>case SQL_C_DOUBLE: <br>case SQL_C_FLOAT: <br>// Scale is only defined for NUMERIC or DECIMAL types <br>if (Scale != ibScale) <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("ibScale not set correctly")); <br>break; <br>case SQL_DATETIME: <br>case SQL_INTEGER: <br>// Subtype is only valid for DATETIME or INTERVAL types <br>if (fSubType2 != fSubType) <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("fSubType not set correctly")); <br>break; <br>} <br> <br>// For application descriptors, compare the Length and get the <br>// data ptr value to check for accuracy <br>switch(DescTypes[iDescType].uwDescType) <br>{ <br>case SQL_ATTR_APP_ROW_DESC: <br>case SQL_ATTR_APP_PARAM_DESC: <br> <br>if (Length != cbLength) <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("cbLength not set correctly")); <br> <br>rc = SQLGetDescField(hdesc, swDescRec, SQL_DESC_DATA_PTR, <br>&amp;pDescPtr, sizeof(PTR), &amp;cbValue); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc, szSQLGETDESCFIELD); <br> <br>if (pDescPtr != pData) <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("rgbValue not set correctly")); <br> <br>// Get the octet length ptr value and check for accuracy <br>rc = SQLGetDescField(hdesc, swDescRec, SQL_DESC_OCTET_LENGTH_PTR, <br>&amp;pDescPtr, sizeof(PTR), &amp;cbValue); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc, szSQLGETDESCFIELD); <br> <br>if (pDescPtr != pcbValue) <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("cbValue not set correctly")); <br> <br>rc = SQLGetDescField(hdesc, swDescRec, SQL_DESC_INDICATOR_PTR, <br>&amp;pIndicator2, sizeof(PTR), &amp;cbValue); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc, szSQLGETDESCFIELD); <br> <br>if (pIndicator2 != pIndicator) <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("Indicator not set correctly")); <br> <br>break; <br>case SQL_ATTR_IMP_ROW_DESC: <br>case SQL_ATTR_IMP_PARAM_DESC: <br>break; <br>default: <br>DISPLAYERROR(szSQLSETDESCREC,TEXT("Unknown descriptor type.")); <br>} <br>} <br>} <br> <br>} <br> <br>SQLRETURN DescBindParameter(SQLHSTMT hstmt, SQLUSMALLINT ipar, <br>    SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType, <br>    SQLUINTEGER cbColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, <br>    SQLINTEGER cbValueMax, SQLINTEGER  *pcbValue) <br>{ <br>SQLHDESC hdescAPD, hdescIPD; <br>SQLRETURN rc; <br> <br>rc = SQLGetStmtAttr(hstmt, SQL_ATTR_APP_PARAM_DESC, &amp;hdescAPD, sizeof(hdescAPD), NULL);   <br>if (!RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR)) <br>return rc; <br> <br>rc = SQLGetStmtAttr(hstmt, SQL_ATTR_IMP_PARAM_DESC, &amp;hdescIPD, sizeof(hdescIPD), NULL);   <br>if (!RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR)) <br>return rc; <br> <br>// Parameter type <br>rc = SQLSetDescField(hdescIPD, ipar, SQL_DESC_PARAMETER_TYPE, (SQLPOINTER)fParamType, <br>SQL_IS_SMALLINT);// Set ipar and fParamType for IPD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescIPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>// C type <br>rc = SQLSetDescField(hdescAPD, ipar, SQL_DESC_CONCISE_TYPE, (SQLPOINTER)fCType, <br>SQL_IS_SMALLINT);// Set ipar and fCType of APD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescAPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>// Sql type <br>rc = SQLSetDescField(hdescIPD, ipar, SQL_DESC_CONCISE_TYPE, (SQLPOINTER)fSqlType, <br>SQL_IS_SMALLINT);// Set fSqlType of IPD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescIPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>// Column Size (Length or Precision) <br>if (fSqlType == SQL_CHAR || <br>fSqlType == SQL_VARCHAR || <br>fSqlType == SQL_LONGVARCHAR || <br>fSqlType == SQL_BINARY || <br>fSqlType == SQL_VARBINARY || <br>fSqlType == SQL_LONGVARBINARY || <br>fSqlType == SQL_TYPE_DATE || <br>fSqlType == SQL_TYPE_TIME || <br>fSqlType == SQL_TYPE_TIMESTAMP || <br>(fSqlType &gt;= SQL_INTERVAL_YEAR &amp;&amp; <br> fSqlType &lt;= SQL_INTERVAL_MINUTE_TO_SECOND)) <br>{ <br>rc = SQLSetDescField(hdescIPD, ipar, SQL_DESC_LENGTH, (SQLPOINTER)cbColDef, <br>SQL_IS_UINTEGER);// Set cbColDef (Length) of IPD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescIPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br>} <br>else if (fSqlType == SQL_DECIMAL || </code></pre>
<p>
</p>
<pre><code>fSqlType == SQL_NUMERIC || <br> fSqlType == SQL_FLOAT || <br> fSqlType == SQL_REAL || <br> fSqlType == SQL_DOUBLE) <br>{ <br>rc = SQLSetDescField(hdescIPD, ipar, SQL_DESC_PRECISION, (SQLPOINTER)cbColDef, <br>SQL_IS_SMALLINT);// Set cbColDef (Precision) of IPD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescIPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br>} <br> <br>// Scale <br>if (fSqlType == SQL_TYPE_DATE || <br>fSqlType == SQL_TYPE_TIME || <br>fSqlType == SQL_TYPE_TIMESTAMP || <br>(fSqlType &gt;= SQL_INTERVAL_YEAR &amp;&amp; <br> fSqlType &lt;= SQL_INTERVAL_MINUTE_TO_SECOND)) <br>{ <br>switch(fSqlType) <br>{ <br>case SQL_TYPE_TIME: <br>case SQL_TYPE_TIMESTAMP: <br>case SQL_INTERVAL_SECOND: <br>case SQL_INTERVAL_DAY_TO_SECOND: <br>case SQL_INTERVAL_HOUR_TO_SECOND: <br>case SQL_INTERVAL_MINUTE_TO_SECOND: <br>rc = SQLSetDescField(hdescIPD, ipar, SQL_DESC_PRECISION, (SQLPOINTER)ibScale, <br>SQL_IS_SMALLINT);// Set scale of IPD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescIPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br>break; <br>default: <br>rc = SQLSetDescField(hdescIPD, ipar, SQL_DESC_PRECISION, (SQLPOINTER)0, <br>SQL_IS_SMALLINT);// Set scale of IPD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescIPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br>} <br>} <br>else <br>{ <br>rc = SQLSetDescField(hdescIPD, ipar, SQL_DESC_SCALE, (SQLPOINTER)ibScale, <br>SQL_IS_SMALLINT);// Set scale of IPD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescIPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br>} <br> <br>// cbValueMax <br>rc = SQLSetDescField(hdescAPD, ipar, SQL_DESC_OCTET_LENGTH, (SQLPOINTER)cbValueMax, <br>SQL_IS_INTEGER);// Set cbValueMax of APD <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescAPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>// pcbValue <br>rc = SQLSetDescField(hdescAPD, ipar, SQL_DESC_OCTET_LENGTH_PTR, (SQLPOINTER)pcbValue, <br>SQL_IS_POINTER);// Set pcbValue/octet length <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescAPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>rc = SQLSetDescField(hdescAPD, ipar, SQL_DESC_INDICATOR_PTR, (SQLPOINTER)pcbValue, <br>SQL_IS_POINTER);// Set pcbValue/indicator <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdescAPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>// Data ptr <br>rc = SQLSetDescField(hdescAPD, ipar, SQL_DESC_DATA_PTR, (SQLPOINTER)rgbValue, <br>SQL_IS_POINTER);// Set rgbValue <br>ERRSHANDLE(SQL_HANDLE_DESC, hdescAPD, SQL_SUCCESS, rc,szSQLSETDESCFIELD); <br> <br>return rc; <br> <br>} <br> <br>SQLRETURN DescBindCol(SQLHSTMT hstmt, SQLSMALLINT icol, <br>           SQLSMALLINT fCType, SQLPOINTER rgbValue, <br>           SQLINTEGER cbValueMax, SQLINTEGER *pcbValue) <br>{ <br>SQLHDESC hdesc; <br>SQLRETURN rc; <br> <br>rc = SQLGetStmtAttr(hstmt, SQL_ATTR_APP_ROW_DESC, &amp;hdesc, sizeof(hdesc), NULL);   <br>if (!RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR)) <br>return rc; <br> <br>rc = SQLSetDescField(hdesc, icol, SQL_DESC_CONCISE_TYPE, (SQLPOINTER)fCType, <br>SQL_IS_SMALLINT);// Set icol and fCType <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>rc = SQLSetDescField(hdesc, icol, SQL_DESC_OCTET_LENGTH, (SQLPOINTER)cbValueMax, <br>SQL_IS_INTEGER);// Set cbValueMax <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>rc = SQLSetDescField(hdesc, icol, SQL_DESC_OCTET_LENGTH_PTR, (SQLPOINTER)pcbValue, <br>SQL_IS_POINTER);// Set pcbValue/octet length <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>rc = SQLSetDescField(hdesc, icol, SQL_DESC_INDICATOR_PTR, (SQLPOINTER)pcbValue, <br>SQL_IS_POINTER);// Set pcbValue/indicator <br>if (!ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc,szSQLSETDESCFIELD)) <br>return rc; <br> <br>rc = SQLSetDescField(hdesc, icol, SQL_DESC_DATA_PTR, (SQLPOINTER)rgbValue, <br>SQL_IS_POINTER);// Set rgbValue <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc,szSQLSETDESCFIELD); <br> <br>return rc; <br>} <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestGetDescField <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestGetDescField(QTSTRUCT * lpqt) <br>{ <br>SQLRETURN rc=SQL_SUCCESS; <br>SQLUSMALLINT iDescType; <br> <br>SQLHDESC hdesc1=NULL, hdesc2=NULL; <br>PTR rgbValue=NULL; <br>SQLSMALLINT swDescRecCount, swExpRecCount; <br>SQLINTEGER cbValue; <br>TCHARszName[MAX_DESC_BUF]=TEXT(""); <br>TCHARszQuery[XLARGEBUFF]=TEXT(""); <br> <br>if (!Supported(SQL_API_SQLGETDESCFIELD)) <br>{ <br>// Allocate a default descriptor <br>rc = SQLAllocHandle(SQL_HANDLE_DESC, hdbc, &amp;hdesc);   <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br> rc = SQLGetDescField(hdesc, 0, SQL_DESC_COUNT, &amp;DescBuf, sizeof(DescBuf), <br>&amp;cbValue); <br> <br>if(!FindError(SQL_HANDLE_DESC,szIM001)) <br>DISPLAYERROR(szSQLGETDESCFIELD, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLGETDESCFIELD); <br>} <br>} <br>else <br>{ <br>// Make sure all parameters and columns are unbound <br>ResetHstmt(&amp;hstmt); <br> <br>// Perform a select stmt <br>wsprintf(szQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>// For each descriptor type <br>for (iDescType=0; iDescType &lt; sizeof(DescTypes)/sizeof(DescTypes[0]); iDescType++) <br>{ <br> <br>// Get the handle for the automatically allocated descriptor <br>rc = SQLGetStmtAttr(hstmt, DescTypes[iDescType].uwDescType, &amp;hdesc1, sizeof(hdesc1), &amp;cbValue);   <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR); <br> <br>// Create a descriptor record so we have something to read besides header <br>swExpRecCount=CreateDescRecord(hdesc1, hstmt, DescTypes[iDescType].uwDescType); <br> <br>// Get the count of descriptor records (iRecord ignored for header fields) <br>rc = SQLGetDescField(hdesc1, 0, SQL_DESC_COUNT, &amp;swDescRecCount, <br>sizeof(swDescRecCount), &amp;cbValue); <br> <br>if (SQL_SUCCEEDED(rc))  <br>{ <br>// Check count value for expected <br>if (swExpRecCount != swDescRecCount) <br>{ <br>wsprintf(buf,TEXT("Expected record count %d, found %d"), <br>swExpRecCount, swDescRecCount); <br>DISPLAYERROR(szSQLGETDESCFIELD, buf); <br>} <br> <br>CheckDescriptor(hdesc1, DESC_UPDATE_MODE_READ, hstmt, iDescType); <br>} <br>else <br>{ <br>// Unable to read record count from descriptor header, can't proceed <br>wsprintf(buf,TEXT("Unable to read record count from descriptor header for descriptor type %d"), <br>DescTypes[iDescType].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc1, SQL_SUCCESS, rc, buf); <br>} <br>} <br> <br>rc=SQLCloseCursor(hstmt); <br>RETCHECK(SQL_SUCCESS, rc,szSQLCLOSECURSOR); <br>} <br> <br> <br>} // TestGetDescField() <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSetDescField <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSetDescField(QTSTRUCT * lpqt) <br>{ <br>SQLRETURN rc=SQL_SUCCESS; <br>SQLUSMALLINT iDescType; <br> <br>SQLHDESC hdesc1=NULL, hdesc2=NULL; <br>PTR rgbValue=NULL; <br>SQLSMALLINT swDescRecCount, swExpRecCount; <br>SQLINTEGER cbValue; <br>TCHARszName[MAX_DESC_BUF]=TEXT(""); <br>TCHARszQuery[XLARGEBUFF]=TEXT(""); <br> <br> <br>if (!Supported(SQL_API_SQLSETDESCFIELD)) <br>{ <br>// Allocate a default descriptor <br>rc = SQLAllocHandle(SQL_HANDLE_DESC, hdbc, &amp;hdesc);   <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>rc = SQLSetDescField(hdesc, 0, SQL_DESC_COUNT, &amp;swDescRecCount, <br>sizeof(swDescRecCount)); <br> <br>if(!FindError(SQL_HANDLE_DESC,szIM001)) <br>DISPLAYERROR(szSQLSETDESCFIELD, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLSETDESCFIELD); <br>} <br>} <br>else <br>{ <br>// Make sure all parameters and columns are unbound <br>ResetHstmt(&amp;hstmt); <br> <br>// Perform a select stmt <br>wsprintf(szQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>// For each descriptor type <br>for (iDescType=0; iDescType &lt; sizeof(DescTypes)/sizeof(DescTypes[0]); iDescType++) <br>{ <br> <br>// Get the handle for the automatically allocated descriptor <br>rc = SQLGetStmtAttr(hstmt, DescTypes[iDescType].uwDescType, &amp;hdesc1, sizeof(hdesc1), &amp;cbValue);   <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR); <br> <br>// Create a descriptor record so we have something to read besides header <br>swExpRecCount=CreateDescRecord(hdesc1, hstmt, DescTypes[iDescType].uwDescType); <br> <br>// Update all descriptor records to new values <br>CheckDescriptor(hdesc1, DESC_UPDATE_MODE_WRITE, hstmt, iDescType); <br> <br>// Compare the descriptor with the update values <br>// CompareDescriptor(hdesc1, NULL, iDescType, szSQLSETDESCFIELD); <br>} <br> <br>ResetHstmt(&amp;hstmt); <br>} <br> <br>} //TestSetDescField() <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestGetDescRec <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestGetDescRec(QTSTRUCT * lpqt) <br>{ <br>SQLRETURN rc=SQL_SUCCESS; <br>SQLUSMALLINT iDescType; <br> <br>SQLHDESC hdesc1=NULL, hdesc2=NULL; <br>PTR rgbValue=NULL; <br>SQLSMALLINT swDescRec, swDescRecCount, iRecord, cbNameMax, cbName, fType, fSubType, <br>Precision, Scale, Nullable, swExpRecCount; <br>SQLINTEGER Length, cbValue; <br>TCHARszName[MAX_DESC_BUF]=TEXT(""); <br>TCHARszQuery[XLARGEBUFF]=TEXT(""); <br> <br> <br>if (!Supported(SQL_API_SQLGETDESCREC)) <br>{ <br>// Allocate a default descriptor <br>rc = SQLAllocHandle(SQL_HANDLE_DESC, hdbc, &amp;hdesc);   <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>rc = SQLGetDescRec(hdesc, iRecord, szName, cbNameMax, &amp;cbName, &amp;fType, <br>&amp;fSubType, &amp;Length, &amp;Precision, &amp;Scale, &amp;Nullable); <br> <br>if(!FindError(SQL_HANDLE_DESC,szIM001)) <br>DISPLAYERROR(szSQLGETDESCREC, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLGETDESCREC); <br>} <br>} <br>else <br>{ <br>// Make sure all parameters and columns are unbound <br>ResetHstmt(&amp;hstmt); <br> <br>// Turn on bookmarks so we can retrieve from record 0 of ARD <br>rc = SQLSetStmtAttr(hstmt, SQL_ATTR_USE_BOOKMARKS, (SQLPOINTER)SQL_UB_ON, SQL_IS_INTEGER); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETSTMTATTR); <br> <br>// Perform a select stmt <br>wsprintf(szQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>// For each descriptor type <br>for (iDescType=0; iDescType &lt; sizeof(DescTypes)/sizeof(DescTypes[0]); iDescType++) <br>{ <br> <br>// Get the handle for the automatically allocated descriptor <br>rc = SQLGetStmtAttr(hstmt, DescTypes[iDescType].uwDescType, &amp;hdesc1, sizeof(hdesc1), &amp;cbValue);   <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR); <br> <br>// Create a descriptor record so we have something to read besides header <br>swExpRecCount=CreateDescRecord(hdesc1, hstmt, DescTypes[iDescType].uwDescType); <br> <br>// Get the count of descriptor records <br>// Count for automatically allocated descriptors is written in <br>// SetDescField test. <br>rc = SQLGetDescField(hdesc1, 0, SQL_DESC_COUNT, &amp;swDescRecCount, <br>sizeof(swDescRecCount), &amp;cbValue); <br> <br>if (SQL_SUCCESS == rc)  <br>{ <br> <br>// For all descriptor records <br>for (swDescRec=0; swDescRec &lt;= swDescRecCount+1; swDescRec++) <br>{ <br>// Read the record <br>rc = SQLGetDescRec(hdesc1, swDescRec, szName, sizeof(szName), &amp;cbName, &amp;fType, <br>&amp;fSubType, &amp;Length, &amp;Precision, &amp;Scale, &amp;Nullable); <br> <br>if (swDescRec &lt;= swDescRecCount) <br>{ <br>// Retrieving bookmark on IPD is an error <br>if (SQL_ATTR_IMP_PARAM_DESC == DescTypes[iDescType].uwDescType &amp;&amp; 0 == swDescRec) <br>{ <br>wsprintf(buf,TEXT("%s: Able to read record %d from %s"), <br>szSQLGETDESCREC, swDescRec, DescTypes[iDescType].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc1, SQL_ERROR, rc, buf); <br>} <br>else <br>{ <br>wsprintf(buf,TEXT("%s: Unable to read record %d from %s"), <br>szSQLGETDESCREC, swDescRec, DescTypes[iDescType].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc1, SQL_SUCCESS, rc, buf); <br>} <br>} <br>else <br>{ <br>wsprintf(buf,TEXT("%s: Did not receive SQL_NO_DATA reading record %d from %s"), <br>szSQLGETDESCREC, swDescRec, DescTypes[iDescType].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc1, SQL_NO_DATA, rc, buf); <br>} <br>} <br>} <br>else <br>{ <br>// Unable to read record count from descriptor header, can't proceed <br>wsprintf(buf,TEXT("\t\tUnable to read record count from descriptor header for %s"), <br>DescTypes[iDescType].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc1, SQL_SUCCESS, rc, buf); <br>} <br>} <br> <br>rc=SQLCloseCursor(hstmt); <br>RETCHECK(SQL_SUCCESS, rc,szSQLCLOSECURSOR); <br> <br>} <br> <br>} //TestGetDescRec() <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestSetDescRec <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestSetDescRec(QTSTRUCT * lpqt) <br>{ <br>SQLRETURN rc=SQL_SUCCESS; <br>SQLINTEGER cbLength, cbValue, Indicator; <br>SQLUSMALLINT iDescType; <br> <br>SQLHDESC hdesc1=NULL, hdesc2=NULL; <br>PTR rgbValue=NULL; <br>SQLSMALLINT swDescRec, swDescRecCount, swStartRec=1, iRecord, fType, fSubType, <br>ibPrecision, ibScale; <br>SQLSMALLINT swExpRecCount; <br>TCHARszQuery[XLARGEBUFF]=TEXT(""); <br> <br> <br>if (!Supported(SQL_API_SQLSETDESCREC)) <br>{ <br>// Allocate a default descriptor <br>rc = SQLAllocHandle(SQL_HANDLE_DESC, hdbc, &amp;hdesc);   <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>rc = SQLSetDescRec(hdesc, iRecord, fType, fSubType, cbLength, <br>ibPrecision, ibScale, &amp;DescBuf, &amp;cbValue, &amp;Indicator); <br> <br>if(!FindError(SQL_HANDLE_DESC,szIM001)) <br>DISPLAYERROR(szSQLSETDESCREC, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLSETDESCREC); <br>} <br>} <br>else <br>{ <br>// Make sure all parameters and columns are unbound <br>ResetHstmt(&amp;hstmt); <br> <br>// Perform a select stmt <br>wsprintf(szQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>// If bookmarks are supported, then we want to try to set record 0 <br>rc = SQLSetStmtAttr(hstmt, SQL_ATTR_USE_BOOKMARKS, <br>(PTR)SQL_UB_VARIABLE, SQL_IS_INTEGER); <br>if (RC_SUCCESSFUL(rc)) <br>swStartRec=0; <br> <br>// For each descriptor type <br>for (iDescType=0; iDescType &lt; sizeof(DescTypes)/sizeof(DescTypes[0]); iDescType++) <br>{ <br> <br>// Get the handle for the automatically allocated descriptor <br>rc = SQLGetStmtAttr(hstmt, DescTypes[iDescType].uwDescType, &amp;hdesc1, sizeof(hdesc1), &amp;cbValue);   <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR); <br> <br>// Create a descriptor record so we have something to read besides header <br>swExpRecCount=CreateDescRecord(hdesc1, hstmt, DescTypes[iDescType].uwDescType); <br> <br>// Get the count of descriptor records <br>rc = SQLGetDescField(hdesc1, 0, SQL_DESC_COUNT, &amp;swDescRecCount, <br>sizeof(swDescRecCount), &amp;cbValue); <br> <br>if (SQL_SUCCESS == rc)  <br>{ <br> <br>// For all descriptor records <br>for (swDescRec=swStartRec; swDescRec &lt;= swDescRecCount; swDescRec++) <br>{ <br>// Test with a DATETIME record so we can check the subtype field. <br>SQLINTEGER Indicator=0; <br>fType=SQL_DATETIME; <br>fSubType=SQL_CODE_TIMESTAMP; <br>cbLength=sizeof(TIMESTAMP_STRUCT); <br>ibPrecision=5; // For DATETIME, SQL_CODE_DATE data <br>// precision defaults to 0, but it implies it can be set otherwise. <br>ibScale=0;// Only used for DECIMAL or NUMERIC types, otherwise undefined <br> <br>CheckDescRecord(hdesc1, swDescRec, fType, fSubType, cbLength, ibPrecision,  <br>ibScale, &amp;tsval, &amp;cbValue, &amp;Indicator, iDescType); <br> <br>// Test with a numeric record to test scale <br>Indicator=0; <br>fType=SQL_NUMERIC; <br>fSubType=SQL_CODE_TIMESTAMP; <br>cbLength=sizeof(TIMESTAMP_STRUCT); <br>ibPrecision=5; // For DATETIME, SQL_CODE_DATE data <br>// precision defaults to 0, but it implies it can be set otherwise. <br>ibScale=0;// Only used for DECIMAL or NUMERIC types, otherwise undefined <br> <br>CheckDescRecord(hdesc1, swDescRec, fType, fSubType, cbLength, ibPrecision,  <br>ibScale, &amp;tsval, &amp;cbValue, &amp;Indicator, iDescType); <br>} <br>} <br>else <br>{ <br>// Unable to read record count from descriptor header, <br>// can't proceed <br>wsprintf(buf,TEXT("\t\tUnable to read record count from descriptor header for  %s"), <br>DescTypes[iDescType].szDescName); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc1, SQL_SUCCESS, rc, buf); <br>} <br>} <br>ResetHstmt(&amp;hstmt); <br>} <br> <br>} //TestSetDescRec() <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestCopyDesc <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestCopyDesc(QTSTRUCT * lpqt) <br>{ <br>SQLRETURN rc=SQL_SUCCESS; <br>SQLUSMALLINT iDescType; <br>SQLSMALLINT swExpRecCount; <br> <br>SQLHDESC hdesc1=NULL, hdesc2=NULL; <br>PTR rgbValue=NULL; <br>TCHARszName[MAX_DESC_BUF]=TEXT(""); <br>TCHARszQuery[XLARGEBUFF]=TEXT(""); <br> <br> <br>// Allocate a default descriptor <br>rc = SQLAllocHandle(SQL_HANDLE_DESC, hdbc, &amp;hdesc);   <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br> <br>if (!Supported(SQL_API_SQLCOPYDESC)) <br>{ <br>rc = SQLCopyDesc(hdesc, hdesc1); <br> <br>if(!FindError(SQL_HANDLE_DESC,szIM001)) <br>DISPLAYERROR(szSQLCOPYDESC, szNotSupported); <br>RETCHECK(SQL_ERROR, rc,szSQLCOPYDESC); <br>} <br>else <br>{ <br>ResetHstmt(&amp;hstmt); <br> <br>// Perform a select stmt <br>wsprintf(szQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>// For each descriptor type <br>for (iDescType=0; iDescType &lt; sizeof(DescTypes)/sizeof(DescTypes[0]); iDescType++) <br>{ <br>// Get the handle for the automatically allocated descriptor <br>rc = SQLGetStmtAttr(hstmt, DescTypes[iDescType].uwDescType, &amp;hdesc1, sizeof(hdesc1), &amp;cbValue);   <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR); <br> <br>// Create a descriptor record so we have something to read besides header <br>swExpRecCount=CreateDescRecord(hdesc1, hstmt, DescTypes[iDescType].uwDescType); <br> <br>// Update all descriptor records to new values <br>CheckDescriptor(hdesc1, DESC_UPDATE_MODE_WRITE, hstmt, iDescType); <br> <br>// Copy the descriptor to the newly allocated descriptor <br>rc = SQLCopyDesc(hdesc1, hdesc); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc1, SQL_SUCCESS, rc, szSQLCOPYDESC); <br>ERRSHANDLE(SQL_HANDLE_DESC, hdesc, SQL_SUCCESS, rc, szSQLCOPYDESC); <br> <br>// Compare each field in the copied descriptor to the original <br>if (RC_SUCCESSFUL(rc)) <br>CompareDescriptor(hdesc1, hdesc, iDescType, szSQLCOPYDESC); <br>} <br> <br>ResetHstmt(&amp;hstmt); <br>} <br> <br>// Free descriptor handle <br>if (hdesc) <br>{ <br>rc = SQLFreeHandle(SQL_HANDLE_DESC, hdesc);  <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREEHANDLE); <br>} <br>} <br> <br>} //TestCopyDesc() <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestDescDefaults <br>//----------------------------------------------------------------------- <br>void  PASCAL TestDescDefaults(QTSTRUCT * lpqt) <br>{ <br>SQLRETURN rc=SQL_SUCCESS; <br> SQLINTEGER cbValue; <br>SQLSMALLINT swDescRec; <br>SQLUSMALLINT iDescField, iStartField=0, iDescType; <br> <br>if (Supported(SQL_API_SQLGETDESCFIELD)) <br>{ <br> <br>// Reallocate hstmt to check defaults against <br>ResetHstmt(&amp;hstmt); <br> <br>// For each descriptor type <br>for (iDescType=0; iDescType &lt; sizeof(DescTypes)/sizeof(DescTypes[0]); iDescType++) <br>{ <br>// Get the handle for the descriptor <br>rc = SQLGetStmtAttr(hstmt, DescTypes[iDescType].uwDescType, &amp;hdesc, sizeof(hdesc), NULL);   <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR); <br> <br>swDescRec=0; <br> <br>// For each descriptor field, read the value <br>for (iDescField=iStartField; iDescField &lt; sizeof(rgDescInfo)/sizeof(rgDescInfo[0]); iDescField++) { <br> <br>// If we've gone past the header fields, then create a record and check record fields <br>if (0 == swDescRec &amp;&amp; !rgDescInfo[iDescField].fHeader) { <br>iStartField=iDescField; <br>// Make sure we're not on the IRD, 'cause you can't modify an IRD <br>if (SQL_ATTR_IMP_ROW_DESC != DescTypes[iDescType].uwDescType) <br>{ <br>// Create a record with all default values <br>rc = SQLSetDescField(hdesc, 0, SQL_DESC_COUNT, (SQLPOINTER)1, <br>SQL_IS_SMALLINT); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETDESCFIELD); <br> <br>swDescRec++; <br>} <br>continue; <br>} <br> <br>// If the field has a default value <br>if (rgDescInfo[iDescField].fDefault &amp; DescTypes[iDescType].uwTypeMask) <br>{ <br>// Read from the field <br>rc = SQLGetDescField(hdesc, swDescRec, rgDescInfo[iDescField].uwDescField, <br>&amp;DescBuf, sizeof(DescBuf), &amp;cbValue); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDESCFIELD); <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>// Perform the compare <br>if (memcmp(DescBuf, &amp;rgDescInfo[iDescField].DefaultVal, cbValue))  <br>{ <br>// Compare error, print message <br>wsprintf(buf,TEXT("Error in %s field %s default value"), <br>DescTypes[iDescType].szDescName,rgDescInfo[iDescField].szDescFieldName); <br>DISPLAYERROR(szSQLGETDESCFIELD, buf); <br>} <br>} <br>} <br>} <br>} <br>} <br>} // TestDescDefaults <br>  <br>//----------------------------------------------------------------------- <br>//      Function:               TestUseDesc <br>//----------------------------------------------------------------------- <br>void  PASCAL TestUseDesc(QTSTRUCT * lpqt, FIELDINFO  *rgFields) <br>{ <br>LPTSTR   pch=NULL; <br>SDWORD crow=0; <br>TCHARszQuery[XLARGEBUFF]=TEXT(""); <br>SQLRETURN rc; <br>UWORDrow, icol, paramno; <br>SWORDccol; <br>TCHAR * rgbMemBuf=NULL, * rgbValue=NULL; <br>SDWORD * pcbValueBuf=NULL, * pcbValue=NULL; <br> <br>if (Supported(SQL_API_SQLSETDESCFIELD)) <br>{ <br> <br>// Test descriptor bindcol <br> <br>// Reallocate hstmt to set to defaults <br>ResetHstmt(&amp;hstmt); <br> <br>// Perform a select stmt <br>wsprintf(szQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>rc=SQLNumResultCols(hstmt, &amp;ccol); <br>RETCHECK(SQL_SUCCESS, rc, szSQLNUMRESULTCOLS); <br> <br>rc=SQLFreeStmt(hstmt, SQL_CLOSE); // Close the cursor so we can insert  <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREESTMT); <br> <br>rgbMemBuf=AllocateMemory(ccol*MAX_STRING_SIZE*sizeof(TCHAR)); <br> <br>if (!rgbMemBuf) <br>{ <br>DISPLAYERROR(TEXT("Simulate BindCol"),TEXT("Out of memory!")); <br>goto ExitUseDesc; <br>} <br> <br>pcbValueBuf=(SDWORD *)AllocateMemory(ccol*sizeof(SDWORD)); <br> <br>if (!pcbValueBuf) <br>{ <br>DISPLAYERROR(TEXT("Simulate BindCol"),TEXT("Out of memory!")); <br>goto ExitUseDesc; <br>} <br> <br>// Bind a parameter for each column in the result set using descriptors <br>paramno=0; <br>for (icol=1, rgbValue=rgbMemBuf, pcbValue=pcbValueBuf; <br>icol &lt;= ccol; <br>icol++, rgbValue+=MAX_STRING_SIZE*sizeof(TCHAR), pcbValue++) <br>{ <br>pch = qtMakeData(guwRowCount, icol-1, &amp;rgFields[icol-1], rgbValue); <br> <br>// Field is not READ ONLY <br>if(pch)  <br>{ <br> // Where row and column match and field is nullable, make NULL <br>if (icol == guwRowCount &amp;&amp; rgFields[icol-1].nullable) <br>*pcbValue=SQL_NULL_DATA; <br>else <br>*pcbValue=SQL_NTS; <br> <br>paramno++; <br>//rc=SQLBindParameter(hstmt, paramno, SQL_PARAM_INPUT, SQL_C_CHAR,  <br>rc=DescBindParameter(hstmt, paramno, SQL_PARAM_INPUT, SQL_C_CHAR,  <br>rgFields[icol-1].wSQLType, rgFields[icol-1].precision, <br>rgFields[icol-1].scale, rgbValue, 0, pcbValue); <br>RETCHECK(SQL_SUCCESS, rc,TEXT("DescBindParameter")); <br>} <br>} <br> <br>// Insert the new row.  Note that the inserted row will be checked <br>// for accuracy below. <br>rc = SQLExecDirect(hstmt, szInsertStmt, SQL_NTS); <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmt, SQL_SUCCESS, rc, szSQLEXECDIRECT); <br> <br>if (RC_SUCCESSFUL(rc)) <br>guwRowCount++; <br> <br>// Perform the select stmt again <br>wsprintf(szQuery,szSELECTSTAR,lpqt-&gt;szTableName); <br>rc = SQLExecDirect(hstmt, szQuery, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>// Bind all the columns to char <br>for (icol=1, rgbValue=rgbMemBuf, pcbValue=pcbValueBuf; <br>icol &lt;= ccol; <br>icol++, rgbValue+=MAX_STRING_SIZE*sizeof(TCHAR), pcbValue++) <br>{ <br>// Bind to next column <br>rc = DescBindCol(hstmt, icol, SQL_C_CHAR, rgbValue, MAX_STRING_SIZE*sizeof(TCHAR), pcbValue); <br>//rc = SQLBindCol(hstmt, icol, SQL_C_CHAR, rgbValue, MAX_STRING_SIZE*sizeof(TCHAR), pcbValue); <br>RETCHECK(SQL_SUCCESS, rc, TEXT("DescBindCol")); <br>} <br> <br>// Fetch all the rows and check the bound value with MakeAData for <br>// each column <br>for (row=1; rc == SQL_SUCCESS; row++) <br>{ <br>rc=SQLFetch(hstmt); // Will return SQL_NO_DATA after last row <br> <br>if (SQL_SUCCESS == rc) <br>{ <br> <br>// Compare all the columns <br>for (icol=1, rgbValue=rgbMemBuf, pcbValue=pcbValueBuf; <br>icol &lt;= ccol; <br>icol++, rgbValue+=MAX_STRING_SIZE*sizeof(TCHAR), pcbValue++) <br>{ <br> <br>CompareWithExpected(rgbValue, pcbValue, row, icol, rgFields); <br>} <br>} <br>else <br>ERRSHANDLE(SQL_HANDLE_STMT, hstmt, SQL_NO_DATA, rc, szSQLFETCH); <br> <br>} <br> <br>} <br> <br>ExitUseDesc: <br>rc=SQLFreeStmt(hstmt, SQL_CLOSE); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREESTMT); <br> <br>if (rgbMemBuf) <br>ReleaseMemory(rgbMemBuf); <br>if (pcbValueBuf) <br>ReleaseMemory(pcbValueBuf); <br> <br> <br>} // TestUseDesc <br> <br>//----------------------------------------------------------------------- <br>//      Function:               TestEnvAttr <br>// <br>// Note:Only one environment attribute (SQL_ATTR_OUTPUT_NTS) exists at this <br>// time.  The default value is SQL_TRUE. <br>// <br>//For the Environment attributes we assume support if DM version &gt;= 3.00 <br>//----------------------------------------------------------------------- <br> <br>void  PASCAL TestEnvAttr() <br>{ <br>SQLINTEGERsdwEnvAttr; <br>SQLRETURNrc; <br>HENVtshenv; <br>BOOLfSetSupported = Supported(SQL_API_SQLSETENVATTR), <br>fGetSupported = Supported(SQL_API_SQLGETENVATTR); <br> <br> <br>//allocate an enviroment handle <br>rc = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;tshenv); <br>RETCHECK(SQL_SUCCESS, rc,szSQLALLOCHANDLE); <br> <br> <br>//------------------------------- <br>//-------- SQLSetEnvAttr -------- <br>//------------------------------- <br>// Set to SQL_FALSE <br>rc = SQLSetEnvAttr(tshenv, SQL_ATTR_ODBC_VERSION, (PTR)SQL_OV_ODBC3, <br>SQL_IS_UINTEGER); <br> <br>if(!fSetSupported) <br>{ <br>if (!FindError(SQL_HANDLE_ENV,szIM001)) <br>DISPLAYERROR(szSQLSETENVATTR, szNotSupported); <br> <br>RETCHECK(SQL_ERROR, rc,szSQLSETENVATTR); <br>} <br>else <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETENVATTR); <br> <br>if (RC_SUCCESSFUL(rc)) <br>{ <br>// Read it again <br>rc = SQLGetEnvAttr(tshenv, SQL_ATTR_ODBC_VERSION, &amp;sdwEnvAttr, <br>sizeof(sdwEnvAttr), NULL); <br> <br>if(!fGetSupported) <br>{ <br>if (!FindError(SQL_HANDLE_ENV,szIM001)) <br>DISPLAYERROR(szSQLGETENVATTR, szNotSupported); <br> <br>RETCHECK(SQL_ERROR, rc,szSQLGETENVATTR); <br>} <br>else <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETENVATTR); <br> <br>if (RC_SUCCESSFUL(rc) &amp;&amp; (SQL_OV_ODBC3 != sdwEnvAttr)) <br>{ <br>// New value wrong <br>DISPLAYERROR(szSQLSETENVATTR,TEXT("Unable to set environment attribute SQL_ATTR_ODBC_VERSION to SQL_OV_ODBC3.")); <br>} <br>} <br> <br>rc = SQLFreeHandle(SQL_HANDLE_ENV,tshenv); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREEHANDLE); <br> <br>//------------------------------- <br>//-------- SQLGetEnvAttr -------- <br>//------------------------------- <br>rc = SQLAllocEnv(&amp;tshenv); <br>RETCHECK(SQL_SUCCESS, rc,szSQLALLOCENV); <br> <br>rc = SQLGetEnvAttr(tshenv, SQL_ATTR_ODBC_VERSION, &amp;sdwEnvAttr, <br>sizeof(sdwEnvAttr), NULL); <br> <br>if(!fGetSupported) <br>{ <br>if (!FindError(SQL_HANDLE_ENV,szIM001)) <br>DISPLAYERROR(szSQLGETENVATTR, szNotSupported); <br> <br>RETCHECK(SQL_ERROR, rc,szSQLGETENVATTR); <br>} <br>else <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETENVATTR); <br> <br> <br>if (RC_SUCCESSFUL(rc) &amp;&amp; (SQL_OV_ODBC2 != sdwEnvAttr)) <br>{ <br>// Default value wrong <br>DISPLAYERROR(szSQLGETENVATTR,TEXT("Value was not SQL_OV_ODBC3!")); <br>} <br> <br> <br>rc = SQLFreeHandle(SQL_HANDLE_ENV,tshenv); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFREEHANDLE); <br> <br>} //TestEnvAttr() <br> <br> <br>//----------------------------------------------------------------------- <br>//    Function: GetRowCnt <br>// <br>//Get the row count of the table lpqt-&gt;szTalbeName <br>//----------------------------------------------------------------------- <br>SWORD  PASCAL GetRowCnt(QTSTRUCT  *lpqt) <br>{ <br> SWORD sRowCnt; <br>RETCODErc; <br> <br>// free the statment handle for a fresh start <br>FreeStmt(SQL_DROP); <br> <br>AllocHstmt(); <br> <br>//get row count for the table <br>wsprintf(lpqt-&gt;sz,TEXT("select count(*) from %s"), lpqt-&gt;szTableName); <br> <br>rc = SQLExecDirect(hstmt, lpqt-&gt;sz, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECDIRECT); <br> <br>rc = SQLFetch(hstmt); <br>RETCHECK(SQL_SUCCESS, rc,szSQLFETCH); <br> <br>rc = SQLGetData(hstmt,1, SQL_C_SSHORT, &amp;sRowCnt, sizeof(sRowCnt), NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETDATA); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>return sRowCnt; <br>}//GetRowCount <br> <br> <br>//----------------------------------------------------------------------- <br>//    Function: InsertOneRow <br>// <br>//Insert one row into the table. <br>// <br>//lpqt:temp place to hold data genrated <br>//rgFields:hold info about each data type in the dbs <br>//cTypes;the count of data types <br>//lpd:buffer used for SQLBindParam <br>//cSeed;the seed used to generate data <br>//fFreeHsmt:if the hstmt should be freed    <br>// <br>//Return TRUE: the insertion was successful <br>// FALSE: otherwise <br>//----------------------------------------------------------------------- </code></pre>
<p>
</p>
<pre><code><br>BOOL  PASCAL InsertOneRow(QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes, <br>DSTRUCT  *lpd,UWORD cSeed,BOOL fFreeHstmt) <br>{ <br>RETCODE  rc; <br>UWORD    w; <br>UWORD    ind; <br>LPTSTR    pch=NULL; <br>SQLHDESChdesc; <br>   SQLSMALLINT      fParamType = SQL_PARAM_INPUT; <br>TCHARszDataItem[150]; <br> <br> <br>//prepare the insert statement <br>rc = SQLPrepare(hstmt, szInsertStmt, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPREPARE); <br> <br>//going through each data type, call SQLBindParam <br>for(ind = 0, w = 0; ind &lt; cTypes; ind++)  <br>{ <br> <br>//make data according to data type description in rgFields[], cSeed is the seed <br>pch = qtMakeData(cSeed,ind,&amp;rgFields[ind], szDataItem); <br> <br>//if the data type is READ_ONLY, skip <br>if(!pch)  <br>continue; <br> <br>//populate the NULL data <br>if(*pch)  <br>{ <br>lstrcpy(lpd[w].data, pch); <br>lpd[w].cb = SQL_NTS; <br>} <br>else  <br>{ <br>lstrcpy(lpd[w].data,TEXT("")); <br>lpd[w].cb = SQL_NULL_DATA; <br>} <br> <br>if (g_f3XDriver &amp;&amp; Supported(SQL_API_SQLSETDESCFIELD)) <br>//if (0)//DEBUG <br>{ <br>//bind the data buffer in lpd[] to each column of the table <br>rc = SQLBindParam(hstmt, (SQLSMALLINT)(w+1),SQL_C_TCHAR, rgFields[ind].wSQLType, <br>rgFields[ind].precision, rgFields[ind].scale, <br>&amp;lpd[w].data, &amp;lpd[w].cb); <br>RETCHECK(SQL_SUCCESS, rc,szSQLBINDPARAM); <br> <br>if(rc!= SQL_SUCCESS) <br>return FALSE; <br> <br>//get the driver parameter descriptor handle <br>rc = SQLGetStmtAttr(hstmt,SQL_ATTR_IMP_PARAM_DESC, &amp;hdesc, sizeof(hdesc),NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETSTMTATTR); <br>if(rc!= SQL_SUCCESS) <br>return FALSE; <br> <br>//set the parameter type field in the descriptor <br>rc = SQLSetDescField(hdesc, (SQLSMALLINT)(w+1), SQL_DESC_PARAMETER_TYPE,  <br>(PTR)fParamType, sizeof(fParamType)); <br>RETCHECK(SQL_SUCCESS, rc,szSQLSETDESCFIELD); <br> <br>} <br>else <br>{ <br>rc = SQLBindParameter(hstmt, (UWORD)(w+1),SQL_PARAM_INPUT,SQL_C_TCHAR,  <br>rgFields[ind].wSQLType,rgFields[ind].precision,  <br>rgFields[ind].scale,&amp;lpd[w].data, 100, &amp;lpd[w].cb); <br> <br>RETCHECK(SQL_SUCCESS, rc,szSQLBINDPARAMETER); <br> <br>if(rc!= SQL_SUCCESS) <br>return FALSE; <br>} <br> <br> <br>//go on to next column <br>w++; <br>} <br> <br>// insert a row  <br>rc = SQLExecute(hstmt);  <br>RETCHECK(SQL_SUCCESS, rc,szSQLEXECUTE); <br>if(rc!= SQL_SUCCESS) <br>return FALSE; <br> <br>//free the hstmt if required <br>if(fFreeHstmt) <br>{ <br>if (FreeStmt(SQL_CLOSE)) <br>return FALSE; <br> <br>} <br> <br>return TRUE; <br> <br>}//InsertOneRow <br> <br>//----------------------------------------------------------------------- <br>//    Function: ExecEndTran <br>// <br>//Execute EndTran statement, return the row count of the table <br>//----------------------------------------------------------------------- <br>SWORD  PASCAL ExecEndTran(QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes, <br>DSTRUCT  *lpd,SQLSMALLINT fHandleType, SQLSMALLINT fMode, <br>UWORD cSeed) <br>{ <br>  RETCODE rc; <br> <br>//does not free the hstmt <br>if(!InsertOneRow(lpqt,rgFields,cTypes,lpd,cSeed, FALSE)) <br>return (INSERT_FAIL); <br> <br>switch(fHandleType) <br>{ <br>case SQL_HANDLE_ENV: <br>rc= SQLEndTran(fHandleType,henv,fMode); <br>break; <br>case SQL_HANDLE_DBC: <br>rc= SQLEndTran(fHandleType,hdbc,fMode); <br>break; <br>default: <br>DISPLAYERROR(TEXT("ExecEndTran"),TEXT("Did not recieve correct handle type")); <br>break; <br>} <br>RETCHECK(SQL_SUCCESS, rc,szSQLENDTRAN); <br> <br>if (SQL_COMMIT == fMode &amp;&amp; SQL_SUCCESS == rc) <br>guwRowCount++;// We inserted a row, increment global row count <br> <br>//free the hstmt handle <br>FreeStmt(SQL_CLOSE); <br> <br>return(GetRowCnt(lpqt)); <br>} //ExecEndTran <br> <br>//----------------------------------------------------------------------- <br>//    Function: TestEndTran <br>// <br>//Test the SQLEndTran for SDK 3.0 <br>//----------------------------------------------------------------------- <br>void  PASCAL TestEndTran(QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes, <br>DSTRUCT  *lpd) <br>{ <br>SWORDi; <br>RETCODE rc; <br>SWORDsTXN; <br>SWORDsRowCnt_Pre; <br>SWORDsRowCnt_Aft; <br>SQLSMALLINT fHandleType[]={SQL_HANDLE_ENV, SQL_HANDLE_DBC}; <br>SDWORDcbValue=0; <br> <br>//check if transaction is supported <br>rc = SQLGetInfo(hdbc, SQL_TXN_CAPABLE, &amp;sTXN, sizeof(sTXN), NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>//check both henv and hdbc handle <br>for(i=0; i&lt;=1; i++) <br>{  <br> <br>//get the row count of the table <br>sRowCnt_Pre = GetRowCnt(lpqt); <br> <br>//check if SQLEndTran is supported <br>if(Supported(SQL_API_SQLENDTRAN)) <br>{ <br>if(sTXN != SQL_TC_NONE) <br>{ <br>//set the autocommit to off <br>SetConnectionAttributes(hdbc,SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF); <br> <br>//insert one row, and call SQLEndTran to roll back the transction <br>sRowCnt_Aft = ExecEndTran(lpqt,rgFields,cTypes,lpd,fHandleType[i],SQL_ROLLBACK,(UWORD)(guwRowCount)); <br> <br>//the row count should be the same <br>if(sRowCnt_Aft != sRowCnt_Pre) <br>DISPLAYERROR(szSQLENDTRAN,TEXT("Did not Roll Back the insert transaction")); <br>} <br> <br>//insert one row, and call SQLEndTran to commit the transction <br>sRowCnt_Aft = ExecEndTran(lpqt,rgFields,cTypes,lpd,fHandleType[i],SQL_COMMIT,(UWORD)(guwRowCount)); <br> <br>//the row count should be increased by 1 <br>if(sRowCnt_Aft != (sRowCnt_Pre+1) ) <br>DISPLAYERROR(szSQLENDTRAN,TEXT("Did not commit the insert transaction")); <br> <br>if( sTXN != SQL_TC_NONE) <br>{ <br>//set the autocommit to off <br>SetConnectionAttributes(hdbc,SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF); <br>} <br> <br>}//end of the situation where SQLEndTran is supported <br>else <br>{ <br> <br>switch(fHandleType[i]) <br>{ <br>case SQL_HANDLE_ENV:  <br>rc= SQLEndTran(fHandleType[i],henv,SQL_COMMIT); <br>break; <br>case SQL_HANDLE_DBC:  <br>rc= SQLEndTran(fHandleType[i],hdbc,SQL_ROLLBACK); <br>break; <br>} <br> <br>//check error msg <br>if(!FindError(fHandleType[i],szIM001)) <br>DISPLAYERROR(szSQLENDTRAN,TEXT("Did not return not Supported Message")); <br> <br>RETCHECK(SQL_ERROR, rc,szSQLENDTRAN); <br> <br>//free the hstmt handle <br>FreeStmt(SQL_CLOSE); <br> <br>}//end of error msg checking <br> <br>}//end of the loop to check both henv and hdbc <br> <br>// Commit the transaction started in GetRowCnt inside ExecEndTran <br>rc= SQLEndTran(SQL_HANDLE_ENV,henv,SQL_COMMIT); <br>RETCHECK(SQL_SUCCESS, rc,szSQLENDTRAN); <br> <br>SetConnectionAttributes(hdbc,SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_ON); <br> <br>//free the hstmt handle <br>FreeStmt(SQL_CLOSE); <br> <br>} // TestEndTran() <br> <br> <br>//----------------------------------------------------------------------- <br>//    Function: TestBindParam <br>// <br>//Test the SQLBindParam for SDK 3.0 <br>//----------------------------------------------------------------------- <br>void  PASCAL TestBindParam(QTSTRUCT  *lpqt,FIELDINFO  *rgFields,UWORD cTypes, <br>DSTRUCT  *lpd) <br>{ <br> RETCODE rc; <br>SQLINTEGERcbValue = SQL_NTS; <br>TCHARszDataItem[150]; <br> <br>if(Supported(SQL_API_SQLBINDPARAM)) <br>{ <br>//test SQLBindParam by inserting one row, do not free the hstmt handle <br>if (InsertOneRow(lpqt,rgFields,cTypes,lpd,(UWORD)(guwRowCount),FALSE)) <br>guwRowCount++; // We've inserted a row <br>} <br>else <br>{ <br> //prepare the insert statement <br>rc = SQLPrepare(hstmt, szInsertStmt, SQL_NTS); <br>RETCHECK(SQL_SUCCESS, rc,szSQLPREPARE); <br> <br>//make data according to data type description in rgFields[0], cSeed is the seed <br>qtMakeData(cTypes+1,0,&amp;rgFields[0],szDataItem); <br> <br>//try to bind lpqt-&gt;szDataItem to the first column of the table <br>rc = SQLBindParam(hstmt,1,SQL_C_TCHAR, rgFields[0].wSQLType, rgFields[0].precision, <br>rgFields[0].scale,lpqt-&gt;szDataItem, &amp;cbValue); <br> <br>//check error msg <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLBINDPARAM,TEXT("Did not return Not Supported Message")); <br> <br>RETCHECK(SQL_ERROR, rc,szSQLBINDPARAM); <br>} <br> <br>//free the hstmt handle <br>FreeStmt(SQL_CLOSE); <br> <br>} // TestBindParam() <br> <br> <br> <br> <br> <br> <br>//----------------------------------------------------------------------- <br>//    Function: TestFetchScroll <br>// <br>//Test the SQLFetchScroll for SDK 3.0 <br>//----------------------------------------------------------------------- <br> <br>void PASCAL TestFetchScroll(QTSTRUCT *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszSave[MAX_QUERY_SIZE]; <br>DWORDdwLen=0; <br>SDWORDcbValue=0; <br> <br>/* check if SQLGetFunctions says your API is supported */ <br>if(!Supported( SQL_API_SQLFETCHSCROLL)) <br>{ <br>/* Call your 3.0 API here and verify that the correct state is returned */ <br>rc = SQLFetchScroll(hstmt,SQL_FETCH_FIRST, 0); <br>if(!FindError(SQL_HANDLE_STMT,szIM001)) <br>DISPLAYERROR(szSQLFETCHSCROLL, szNotSupported); <br>RETCHECK(SQL_ERROR, rc, szSQLFETCHSCROLL); <br>} <br>else <br>{ <br>ResetHstmt(&amp;hstmt); <br> <br>/* Valid Testing of SQLFetchScroll */ <br>SelectFromTable(lpqt); <br> <br>rc = SQLBindCol(hstmt, 1, SQL_C_TCHAR, lpqt-&gt;sz, MAX_BIND_ARRAY_ELEMENT, <br>&amp;cbValue); <br>RETCHECK(SQL_SUCCESS, rc, szSQLBINDCOL); <br> <br>rc = SQLFetchScroll(hstmt, SQL_FETCH_NEXT, 3); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFETCHSCROLL); <br>lstrcpy(szSave,lpqt-&gt;sz); <br> <br>rc = SQLFetchScroll(hstmt, SQL_FETCH_PRIOR, 1); <br>RETCHECK(SQL_ERROR, rc, szSQLFETCHSCROLL); <br> <br>rc = SQLFetchScroll(hstmt, SQL_FETCH_FIRST, 0); <br>RETCHECK(SQL_ERROR, rc, szSQLFETCHSCROLL); <br> <br>rc = SQLFetchScroll(hstmt, SQL_FETCH_LAST, 0); <br>RETCHECK(SQL_ERROR, rc, szSQLFETCHSCROLL); <br> <br>rc = SQLFreeStmt(hstmt, SQL_CLOSE); <br>RETCHECK(SQL_SUCCESS, rc, szSQLFREESTMT); <br> <br>} <br> <br>//free the hstmt handle <br>FreeStmt(SQL_CLOSE); <br> <br>} // TestFetchScroll() <br> <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               qtDisplayError                           */ <br>/*-----------------------------------------------------------------------*/ <br> <br>void  PASCAL qtDisplayError(LPTSTR szFunction, LPTSTR buf, LPTSTR szFile, int iLine) <br>{ <br>TCHAR szTmp[MAX_STRING_SIZE]; <br> <br>szWrite(TEXT(""), TRUE); <br>szWrite(TEXT("\t\t\t"), FALSE); <br>szWrite(szFunction, FALSE); <br>szWrite(TEXT("  FAILED"), TRUE); <br>szWrite(TEXT("\t\t\t"), FALSE); <br>szWrite(buf, TRUE); <br> <br>wsprintf(szTmp,TEXT("\t\t\t%s: %d"), szFile, iLine); <br>szWrite(szTmp, TRUE); <br> <br>szWrite(TEXT("\t\t\t  --------  "), TRUE); <br> <br>lpSI-&gt;failed++; <br> <br>return; <br>} <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               qtMakeData                               */ <br>/*-----------------------------------------------------------------------*/ <br> <br>LPTSTR  PASCAL qtMakeData(int row, int col,FIELDINFO  *rgField, LPTSTR buf) <br>{ <br>if(rgField-&gt;fAutoUpdate) <br>return NULL; <br> <br>if(rgField-&gt;nullable &amp;&amp; (row==col))  <br>{ <br>lstrcpy(buf,TEXT("")); <br>return buf; <br>} <br> <br>switch(rgField-&gt;wSQLType) { <br>case SQL_CHAR: <br>case SQL_VARCHAR: <br>case SQL_LONGVARCHAR: <br>case SQL_BINARY: <br>case SQL_VARBINARY: <br>case SQL_LONGVARBINARY: <br>if(rgField-&gt;precision &lt; 4) <br>wsprintf(buf,TEXT("%d"), 1); <br>else <br>wsprintf(buf,TEXT("%d%d"), row, row); <br>break; <br>case SQL_DECIMAL: <br>case SQL_NUMERIC: <br>case SQL_REAL: <br>case SQL_FLOAT: <br>case SQL_DOUBLE: <br>if(row == 2 &amp;&amp; !rgField-&gt;fUnsigned) /* make the second row negative for variety */ <br>wsprintf(buf,TEXT("-%d.%d"), row, row); <br>else <br>wsprintf(buf,TEXT("%d.%d"), row, row); <br>break; <br> <br>case SQL_BIT: <br>if(row &gt; 2) <br>wsprintf(buf,TEXT("%d"), 1); <br>else <br>wsprintf(buf,TEXT("%d"), 0); <br> <br>break; <br> <br>case SQL_SMALLINT: <br>case SQL_INTEGER: <br>case SQL_TINYINT: <br>case SQL_BIGINT: <br>if(row == 2 &amp;&amp; !rgField-&gt;fUnsigned) /* make the second row negative for variety */ <br>wsprintf(buf,TEXT("-%d"), row); <br>else <br>wsprintf(buf,TEXT("%d"), row); <br>break; <br> <br>case SQL_TIME: <br>case SQL_TYPE_TIME: <br>wsprintf(buf,TEXT("{t '01:%02d:%02d'}"), row % 60, row % 60); <br>break; <br>case SQL_DATE: <br>case SQL_TYPE_DATE: <br>wsprintf(buf,TEXT("{d '1994-%02d-%02d'}"), (row % 12) + 1, (row % 30) + 1); <br>break; <br>case SQL_TIMESTAMP: <br>case SQL_TYPE_TIMESTAMP: <br>wsprintf(buf,TEXT("{ts '1994-%02d-%02d 01:%02d:%02d'}"), (row % 12) + 1, (row % 30) + 1, row % 60, row % 60); <br>break; <br>} <br>return buf; <br>} <br> <br> <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               TestNumResCols                           */ <br>/*-----------------------------------------------------------------------*/ <br> <br>VOID PASCAL TestNumResCols(SDWORD cColsSelected,QTSTRUCT *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>SWORDwNum; <br> <br>SelectFromTable(lpqt); <br> <br>rc = SQLNumResultCols(hstmt, &amp;wNum); <br>RETCHECK(SQL_SUCCESS, rc,szSQLNUMRESULTCOLS); <br> <br>if(wNum != cColsSelected) <br>DISPLAYERROR(szSQLNUMRESULTCOLS,TEXT("incorrect value returned")); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} /* TestNumResCols() */ <br> <br> <br> <br>/*-----------------------------------------------------------------------*/ <br>/*      Function:               TestNumResCols                           */ <br>/*-----------------------------------------------------------------------*/ <br> <br>VOID PASCAL TestCursorName(QTSTRUCT *lpqt) <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszCursorName[MEDBUFF]; <br>SWORDcb=0; <br> <br>SelectFromTable(lpqt); <br> <br>/* the cursor name should be created by the driver since one was*/ <br>/* not specified*/ <br> <br>rc = SQLGetCursorName(hstmt, szCursorName, MAX_STRING_SIZE, &amp;cb); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETCURSORNAME); <br> <br>if(cb &gt; MAX_STRING_SIZE) <br>{ <br>DISPLAYERROR(szSQLGETCURSORNAME,TEXT("invalid cb")); <br>cb = MAX_STRING_SIZE; <br>} <br> <br>/* don't check the name itself, just make sure that*/ <br>/*something was returned */ <br>if(!*szCursorName)  <br>DISPLAYERROR(szSQLGETCURSORNAME,TEXT("no name returned")); <br> <br>FreeStmt(SQL_CLOSE); <br> <br>} /* TestCursorName() */ <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               GetDMVersion <br>//----------------------------------------------------------------------- <br> <br>UWORD PASCAL GetDMVersion() <br>{ <br>RETCODErc=SQL_SUCCESS; <br>TCHARszNum[MAX_NUM_BUFFER]; <br> <br>rc = SQLGetInfo(hdbc, SQL_ODBC_VER, &amp;szNum, MAX_NUM_BUFFER, NULL); <br>RETCHECK(SQL_SUCCESS, rc,szSQLGETINFO); <br> <br>return((UWORD)_ttoi(_tcstok(szNum,TEXT(".")))); <br> <br>} /* GetDMVersion() */ <br> <br> <br>//----------------------------------------------------------------------- <br>//      Function:               DisplayTestName <br>//----------------------------------------------------------------------- <br> <br>VOID PASCAL DisplayTestName(UWORD i) <br>{ <br>szWrite(szBLANKLINE,TRUE); <br>szWrite(szTAB,FALSE); <br>szWrite(iTestNames[i-1], TRUE); <br> <br>} /* DisplayTestName() */ <br> <br> <br> <br>/***************************  External Interfaces  *************************/ <br>/*  These functions are called by Gator to envoke the tests.               */ <br>/***************************************************************************/ <br> <br>BOOL CALLBACK AutoTestName(LPTSTR szName, UINT  * cbTestCases) <br>{ <br>static TCHAR szTestName[] = TEXT("Quick Test"); <br> <br>lstrcpy(szName, szTestName); <br> <br>*cbTestCases = sizeof(iTestNames)/sizeof(LPTSTR); <br> <br>return TRUE; <br>} <br> <br>//----------------------------------------------------------------------- <br>//      Function:               AutoTestDesc <br>//      Purpose:                        Provides gator with a list of tests which can be run. <br>//----------------------------------------------------------------------- <br>BOOL CALLBACK AutoTestDesc(UWORD iTest, LPTSTR szName, LPTSTR szDesc) <br>{ <br> <br>UWORD len=0; <br> <br>if (iTest &gt; (sizeof(iTestNames)/sizeof(LPTSTR))) <br>return FALSE; <br> <br>if (szName) <br>     lstrcpy(szName,iTestNames[iTest-1]); <br> <br>if (szDesc) <br>        lstrcpy(szDesc,TEXT(" ")); <br> <br>return TRUE; <br> <br>} <br> <br>//----------------------------------------------------------------------- <br>//      Function:               AutoTestFunc <br>//----------------------------------------------------------------------- <br> <br>void CALLBACK AutoTestFunc(lpSERVERINFO pTestSource) <br>{ <br> <br>RETCODErc; <br>UWORDcTypes; <br>UDWORDdwLen; <br>UWORDfIndex; <br>SDWORDcColsSelected; <br>FIELDINFO*rgFields = (FIELDINFO  *)AllocateMemory(sizeof(FIELDINFO) * MAX_TYPES_SUPPORTED); <br>QTSTRUCT*lpqt = (QTSTRUCT  *)AllocateMemory(sizeof (QTSTRUCT)); <br>DSTRUCT*lpd = (DSTRUCT  *)AllocateMemory(sizeof (DSTRUCT) * MAX_TYPES_SUPPORTED); <br>UWORDuDMVer; <br>SDWORDcbValue=0; <br>TCHARszAPI[MEDBUFF]; <br>UWORDi; <br>TCHARszState[100]=TEXT(""), <br>szErrMsg[XLARGEBUFF]=TEXT(""); <br> <br> <br>lpSI = pTestSource; <br>lpSI-&gt;failed = 0; <br>henv = NULL; <br>hdbc = NULL; <br>hstmt = NULL; <br>hdesc = NULL; <br> <br>if(lpSI-&gt;szValidServer0) <br>{ <br>if (Connect(lpSI,lpqt)) <br>goto ErrorRet; <br>} <br>else  <br>{ <br>henv = lpSI-&gt;henv; <br>hdbc = lpSI-&gt;hdbc; <br> <br>rc = SQLSetConnectOption(hdbc,SQL_ODBC_CURSORS,dwLen); <br>lstrcpy(szAPI,szSQLSETCONNECTOPTION); <br> <br>if(RETCHECK(SQL_SUCCESS, rc,szAPI)) <br>lpSI-&gt;vCursorLib = dwLen; <br>} <br> <br> uDMVer=GetDMVersion(); <br> <br>fIndex=CheckConformanceLevel(); <br> <br>fBindParameter=Supported(SQL_API_SQLBINDPARAMETER); <br>fDiagRecSupported=Supported(SQL_API_SQLGETDIAGREC); <br>fDiagFieldSupported=Supported(SQL_API_SQLGETDIAGFIELD); <br> <br> <br>AllocHstmt(); <br> <br>if (!(cTypes=GetTypeInfo(rgFields,lpqt))) <br>goto ErrorRet; <br> <br>guwRowCount=cTypes+1;// Extra row inserted with DAE. <br> <br>// cTypes=20;  //DEBUG <br> <br>/* build create statement */ <br>if (BuildCreateStmt(lpqt,rgFields,cTypes)) <br>goto ErrorRet; <br> <br>/* put together the insert statement, and set the parameters   */ <br>/* parameters are only set the first time through, after which */ <br>/* the contents of the pointers is changed                     */ <br>if (BuildInsertStmt(lpqt, rgFields,cTypes,lpd,&amp;cColsSelected,fBindParameter)) <br>goto ErrorRet; <br> <br>CreateParamQuery(lpqt,rgFields,cTypes); <br> <br>for(i=1;i &lt;= (sizeof(iTestNames)/sizeof(LPTSTR));i++) <br>{ <br>lpqt-&gt;sz[0] = TEXT('\0'); <br> <br>if(GETBIT(pTestSource-&gt;rglMask,i)) <br>{ <br>/* Display current Test */ <br>DisplayTestName(i); <br> <br>switch(i) <br>{ <br>case 1: <br>TestConnectionOptions(); <br>break; <br>case 2: <br>TestStmtOptions(); <br>break; <br>case 3: <br>TestCursorName(lpqt); <br>break; <br>case 4: <br>TestData(lpqt,rgFields,cTypes,lpd); <br>break; <br>case 5: <br>TestNumResCols(cColsSelected,lpqt); <br>break; <br>case 6: <br>TestMetaData(lpSI,lpqt,rgFields,cTypes); <br>break; <br>case 7: <br>TestSearchedQuery(lpqt,rgFields,cTypes,lpd,fBindParameter); <br>break; <br>case 8: <br>TestLargeQuery(lpqt,rgFields,cTypes,lpd); <br>break; <br>case 9: <br>TestSQLTables(lpqt); <br>break; <br>case 10: <br>TestSQLStatistics(lpqt,rgFields,cTypes,lpd,fIndex); <br>break; <br>case 11: <br>TestSQLSpecialCols(lpqt); <br>break; <br>case 12: <br>TestLikeQuery(lpqt,rgFields,cTypes,lpd); <br>break; <br>case 13: <br>TestSQLForeignKeys(lpqt); <br>break; <br>case 14: <br>TestSQLBrowseConnect(lpSI); <br>break; <br>case 15: <br>TestSQLDataSources(); <br>break; <br>case 16: <br>TestSQLDrivers(); <br>break; <br> case 17: <br>TestSQLMoreResults(lpqt); <br>break; <br> case 18: <br>TestSQLNativeSQL(lpqt); <br>break; <br>case 19: <br>TestSQLDescribeParam(lpqt); <br>break; <br>case 20: <br>TestSQLNumParams(lpqt); <br>break; <br>case 21: <br>TestSQLParamOptions(lpqt); <br>break; <br>case 22: <br>TestSQLPrimaryKeys(lpqt); <br>break; <br>case 23: <br>TestSQLProcedures(); <br>break; <br>case 24: <br>TestSQLTablePrivileges(); <br>break; <br>case 25: <br>TestSQLColumnPrivileges(lpqt); <br>break; <br>case 26: <br>TestSQLSetScrollOptions(); <br>break; <br>case 27: <br>TestExtendedFetch(lpqt,rgFields,cTypes); <br>break; <br>case 28: <br>TestOJCap(lpqt); <br>break; <br>case 29: <br>TestSQLSetConnectAttr(); <br>break; <br>case 30: <br>TestSQLSetStmtAttr(); <br>break; <br>case 31: <br>TestThreading(lpSI,lpqt,rgFields); <br>break; <br>case 32: <br>TestGetDescField(lpqt); <br>break; <br>case 33: <br>TestSetDescField(lpqt); <br>break; <br>case 34: <br>TestGetDescRec(lpqt); <br>break; <br>case 35: <br>TestSetDescRec(lpqt); <br>break; <br>case 36: <br>TestCopyDesc(lpqt); <br>break; <br>case 37: <br>TestDescDefaults(lpqt); <br>break; <br>case 38: <br>TestUseDesc(lpqt, rgFields); <br>break; <br>case 39: <br>TestEnvAttr(); <br>break; <br>case 40: <br>TestEndTran(lpqt,rgFields,cTypes,lpd); <br>break; <br>case 41: <br>TestBindParam(lpqt,rgFields,cTypes,lpd); <br>break; <br>case 42: <br>TestQuickRebind(lpqt,rgFields,cTypes,lpd); <br>break; <br>case 43: <br>TestFetchScroll(lpqt); <br>break; <br>case 44: <br>TestDiagRec(); <br>break; <br>case 45: <br>TestDiagField(); <br>break; <br>case 46: <br>TestMixedAnsiUnicode(lpqt); <br>break; <br> <br>} /* switch(i) */ <br> <br>} /* if(GETBIT(pTestSource-&gt;rglMask,i)) */ <br> <br>} <br> <br>//the end of test cases for ODBC SDK 3.0 <br> <br>/* finished testing, clean up */ <br>CleanUp(lpd,lpqt,rgFields,lpqt-&gt;szTableName,FALSE,lpSI-&gt;szValidServer0); <br> <br>szWrite(szBLANKLINE,TRUE); <br> <br>lpSI-&gt;cErrors = lpSI-&gt;failed; <br> <br>return; <br> <br>ErrorRet: <br>/* a failure in an ODBC function that prevents completion of the*/ <br>/* test - for example, connect to the server */ <br> <br>szWrite(TEXT("\t\t *** Unrecoverable Quick Test FAILURE ***"), TRUE); <br> <br>/* finished testing, clean up */ <br>CleanUp(lpd,lpqt,rgFields,lpqt-&gt;szTableName,FALSE,lpSI-&gt;szValidServer0); <br> <br>lpSI-&gt;cErrors = ABORT; <br> <br>return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
