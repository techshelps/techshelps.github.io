<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QUERY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2291"></a>QUERY.C</h2>
<pre><code>/* <br>    PROGRAM: QURYDEMO <br>    ======== <br> <br>    PURPOSE: <br>    ======== <br>    demonstrates a simple MDI (Multiple Document Interface)application <br>    that allows a user to simultaneously connect to multiple <br>    hetrogeneous databases and perform SQL queries to get results. <br> <br>    FUNCTIONS: <br>    ========== <br>    InitSQLEnvironment() - Initialize ODBC library <br>    DisplayDatabases() - Display available Data Sources <br>    ConnectDatabase() - Connect to a specific data source <br>    DriverConnectDatabase() - Connect through driver specific dialogs <br>    DisplayConnections() - Display List of made connections <br>    DisplayQueries() - Display list of Query Handles (hstmts) <br>    NewQueryWindow() - Open a new hstmt and update displays <br>    ChangeCurrentCursor() - Change current cursor display <br>    ChangeCurrentQuery() - Change current query display <br>    DisplayNewCrsrAndStmt() - update cusor &amp; query displays <br>    FreeConnect() - free a connection <br>    FreeQuery() - free a query handle <br>    CloseQueryWindow() - close a query window <br>    ExecuteQuery() - execute a user specified query <br>    CloseDatabases() - check if all connections are closed <br>    FreeSQLEnvironment() - free ODBC library <br>    DisplayError() - displays SQL Error and Warnings <br> <br>    COMMENTS: <br>    ========= <br>    Created by Microsoft Corporation. <br> <br>    The application uses MDI Child Window Titles to store values of <br>    connected SQLHDBCs and SQLHSTMTs. These values are also stored in the <br>    comboboxes that are displayed on the toolbar. <br> <br>*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include &lt;windows.h&gt; <br> <br>#include "sql.h" <br>#include "sqlext.h" <br>#include "qurydemo.h" <br> <br>/* <br>    FUNCTION: InitSQLEnvironment() <br>    COMMENTS: Allocate an environment handle for ODBC function calls. <br>*/ <br> <br>BOOL FAR PASCAL InitSQLEnvironment() <br>{ <br>   // reset child window count <br>   nChildCount = 0; <br> <br>   // Allocate an Environment Handle <br>   if (SQLAllocHandle(SQL_HANDLE_ENV,SQL_NULL_HANDLE,&amp;henv) != SQL_SUCCESS) <br>      return FALSE; <br> <br>   return (SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, <br>                         (SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER) == SQL_SUCCESS); <br>} <br> <br>/* <br>    FUNCTION: DisplayDatabases(HWND hWnd) <br>    COMMENTS: Display a list of available data sources. Use <br>          SQLDataSources function call. <br>*/ <br> <br>void FAR PASCAL DisplayDatabases(HWND hWnd) <br>{ <br>   SWORD     nDirection;                             //fetch direction <br>   SWORD     nDataSourceNameLength;                  //DSN str length <br>   SWORD     nSourceDescriptionLength;               //Driver Description str length <br>   char      szDataSourceName[MAXBUFLEN+1];          //DSN string <br>   char      szSourceDescription[MAXBUFLEN+1];       //Driver Description string <br>   SQLRETURN nResult;                                //Return Code <br> <br>   //Call SQLDataSources, first with SQL_FETCH_FIRST and from then on <br>   //with SQL_FETCH_NEXT until it returns SQL_NO_DATA. Add <br>   //all returned DSNs in the provided combo box for display. <br>   SendMessage(hWnd, CB_RESETCONTENT, 0, 0); <br>   for (nDirection = SQL_FETCH_FIRST; <br>        (nResult = SQLDataSources(henv, nDirection, szDataSourceName, MAXBUFLEN, <br>                                  &amp;nDataSourceNameLength, szSourceDescription, MAXBUFLEN, &amp;nSourceDescriptionLength)) != <br>        SQL_NO_DATA &amp;&amp; <br>        nResult != SQL_ERROR; <br>        nDirection = SQL_FETCH_NEXT <br>        ) <br>      SendMessage(hWnd, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szDataSourceName); <br>   SendMessage(hWnd, CB_SETCURSEL, 0, 0); <br>} <br> <br>/* <br>    FUNCTION: ConnectDatabase(HWND hWnd) <br>    COMMENTS: Connect to a DSN. <br>*/ <br> <br>BOOL FAR PASCAL ConnectDatabase(HWND hWnd) <br>{ <br>   char      szBuffer[MAXBUFLEN+1];  // buffer to display successful connection on hdbc combo-box <br>   char      szDBName[MAXBUFLEN+1];  // DSN sting <br>   char      szUserName[MAXBUFLEN+1];// User name <br>   char      szPassword[MAXBUFLEN+1];// Password <br>   SQLHDBC   hdbc;                   // hdbc <br>   SQLRETURN nResult;                // Result code <br> <br>   // check if enough windows are already open, refuse connection <br> <br>   if (nChildCount &gt;= MAXCHILDWNDS) { <br>      MessageBox(hWndFrame, MAXCHILDEXCEEDED, MAXCHLDERR, MB_OK | MB_ICONHAND); <br>      return (FALSE); <br>   } <br> <br> <br>   // retrieve DSN, UID and PWD values from the connect dialog box <br> <br>   GetDlgItemText(hWnd, IDCOMBO_DATASOURCE, szDBName, MAXBUFLEN); <br>   GetDlgItemText(hWnd, IDTEXT_USERNAME, szUserName, MAXBUFLEN); <br>   GetDlgItemText(hWnd, IDTEXT_PASSWORD, szPassword, MAXBUFLEN); <br> <br>   // Allocate a new SQLHDBC. If successful then call SQLConnect using the <br>   // allocated hdbc and supplied connection information. <br>   if ((nResult = SQLAllocHandle(SQL_HANDLE_DBC,henv, (SQLHDBC FAR *)&amp;hdbc)) != SQL_SUCCESS) { <br>      DisplayError(nResult, hWnd, SQL_HANDLE_ENV, henv); <br>      return (FALSE); <br>   } <br> <br>   nResult = SQLConnect(hdbc,(LPSTR)szDBName,SQL_NTS,(LPSTR)szUserName,SQL_NTS,(LPSTR)szPassword,SQL_NTS); <br> <br>   // if failed to connect, free the allocated hdbc before return <br>   if (nResult != SQL_SUCCESS &amp;&amp; nResult != SQL_SUCCESS_WITH_INFO) { <br>      DisplayError(nResult, hWnd, SQL_HANDLE_DBC, hdbc); <br>      SQLFreeHandle(SQL_HANDLE_DBC,hdbc); <br>      return (FALSE); <br>   } <br> <br>   // display any connection information if driver returns SQL_SUCCESS_WITH_INFO <br>   if (nResult == SQL_SUCCESS_WITH_INFO) <br>      DisplayError(nResult, hWnd, SQL_HANDLE_DBC, hdbc); <br> <br>   // update the hdbc(s) combo-box and create a new hstmt and its <br>   // associated window. <br>   wsprintf(szBuffer, DSN_HDBC_FORMAT, (LPSTR)szDBName, hdbc); <br>   nResult = (UINT)SendMessage(hWndCrsrList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   SendMessage(hWndCrsrList, CB_SETCURSEL, (WPARAM)nResult, 0); <br>   SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   ChangeCurrentCursor(hWndCrsrList); <br>   NewQueryWindow(); <br>   return (TRUE); <br>} <br> <br>/* <br>    FUNCTION: DriverConnectDatabase(HWND hWnd) <br>    COMMENTS: Connect to a DSN using SQLDriverConnect function call. It <br>          allows driver manager and drivers to interact with the user <br>          directly to prompt for connection information. <br>*/ <br> <br>BOOL FAR PASCAL DriverConnectDatabase(HWND hWnd) <br>{ <br>   char      szBuffer[MAXBUFLEN+1];  //display successful connection info on hdbc(s) combo-box <br>   char      szDBName[MAXBUFLEN+1];  //DSN string <br>   SWORD     swStrLen;               //String length <br>   SQLHDBC   hdbc;                   //hdbc <br>   SQLRETURN nResult;                //result code <br> <br>   // Allocate a new Connection Handle. <br>   if ((nResult = SQLAllocHandle(SQL_HANDLE_DBC,henv, (SQLHDBC FAR *)&amp;hdbc)) != SQL_SUCCESS) { <br>      DisplayError(nResult, hWnd, SQL_HANDLE_ENV, henv); <br>      return (FALSE); <br>   } <br> <br>   // Call SQLDriverConnect to make a connection request. Provide SQL_DRIVER_COMPLETE_REQUIRED <br>   // flag sothat driver manager and driver can ask for connection information <br>   // If failed to connect, free the allocated hdbc in previous step. <br>   nResult = SQLDriverConnect(hdbc, hWnd, "", 0, szBuffer,  MAXBUFLEN, &amp;swStrLen, SQL_DRIVER_COMPLETE_REQUIRED); <br> <br> <br>   if (nResult != SQL_SUCCESS &amp;&amp; nResult != SQL_SUCCESS_WITH_INFO) { <br>      SQLFreeHandle(SQL_HANDLE_DBC,hdbc); <br>      return (FALSE); <br>   } <br> <br>   // If driver returns additional information with SQL_SUCCESS_WITH_INFO <br>   // flag, display the information <br>   if (nResult == SQL_SUCCESS_WITH_INFO) <br>      DisplayError(nResult, hWnd, SQL_HANDLE_DBC, hdbc); <br> <br>   // Call SQLGetInfo to find out the DSN name for the above connection. <br>   // Note, application should not depend upon the DSN name being present <br>   // in the returned connection string. <br>   strcpy(szDBName, DEFDBNAME); // initialize the string value <br> <br> <br>   SQLGetInfo(hdbc, SQL_DATA_SOURCE_NAME, (PTR)szDBName, MAXBUFLEN+1, &amp;swStrLen); <br>if( !*szDBName) <br>strcpy(szDBName,"nameless"); <br> <br>   // Display the new connection information in the hdbc(s) combo-box. <br>   // Create a new hstmt and its associated window. <br>   wsprintf(szBuffer, DSN_HDBC_FORMAT, (LPSTR)szDBName, hdbc); <br>   nResult = (UINT)SendMessage(hWndCrsrList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   SendMessage(hWndCrsrList, CB_SETCURSEL, (WPARAM)nResult, 0); <br>   SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   ChangeCurrentCursor(hWndCrsrList); <br>   NewQueryWindow(); <br>   return (TRUE); <br>} <br> <br>/* <br>    FUNCTION: DisplayConnections(HWND hWndhdbc) <br>    COMMENTS: Display list of available hdbc(s) in the given list box. <br>*/ <br> <br>void FAR PASCAL DisplayConnections(HWND hWndhdbc) <br>{ <br>   int  nConnects;      // # of connections <br>   int  nIndex;                 // counter <br>   char szBuffer[MAXBUFLEN+1];  // string buffer <br> <br>   // read the information from the hdbc(s) combo-box in the tool bar <br>   // and feed it in the given list box. <br> <br>   SendMessage(hWndhdbc, LB_RESETCONTENT, 0, 0); <br>   nConnects = (int) SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0); <br>   for (nIndex = 0; nIndex &lt; nConnects; nIndex++) { <br>      SendMessage(hWndCrsrList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>      SendMessage(hWndhdbc, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   } <br>   SendMessage(hWndhdbc, LB_SETCURSEL, 0, 0); <br>} <br> <br>/* <br>    FUNCTION: DisplayQueries(HWND hWndhstmt int nCrsrIndex) <br>    COMMENTS: Display list of hstmt(s) for the currently selected hdbc <br>          in the given listbox. <br>*/ <br> <br>void FAR PASCAL DisplayQueries(HWND hWndhstmt, HWND hWndhdbc, int nCrsrIndex) <br>{ <br>   char  szBuffer[MAXBUFLEN+1];  // MDI child window title <br>   HWND  hWndChild;              // MDI child window handle <br>   SQLHDBC  hdbc1;               // hdbc in the window title <br>   SQLHDBC  hdbc2;               // selected hdbc in the list box <br>   SQLHSTMT hstmt;               // hstmt in the window title <br> <br>   // reset the hstmt list box in the disconnect dialog box <br> <br>   SendMessage(hWndhstmt, LB_RESETCONTENT, 0, 0); <br> <br>   // go through all available MDI child windows and check if the <br>   // hdbc in the title matches the one selected in the list box. <br>   // if they match, use the hstmt in the window title to create <br>   // a new entry in the hstmt(s) list box. <br> <br>   for (hWndChild=GetWindow(hWndMDIClient, GW_CHILD); hWndChild; hWndChild=GetWindow(hWndChild, GW_HWNDNEXT)) { <br>      // Class name check is necessary as some of MDI child <br>      // windows may be iconized by the user and MDIClient <br>      // in such cases create additional windows (such as <br>      // icon titles). <br> <br>      GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>      if (strcmp(szBuffer, ODBCMDICLASS)) <br>         continue; <br> <br>      GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>      sscanf(szBuffer, SCANHDBCHSTMT_FORMAT, &amp;hdbc1, &amp;hstmt); <br> <br>      SendMessage(hWndhdbc, LB_GETTEXT, (WPARAM)nCrsrIndex, (LPARAM)(LPSTR)szBuffer); <br>      sscanf(szBuffer, SCANHDBC_FORMAT, &amp;hdbc2); <br> <br>      if (hdbc1 != hdbc2) <br>         continue; <br> <br>      wsprintf(szBuffer, ((hWndChild == hWndActiveChild) ?  CURQUERY_STRING:    QUERY_STRING), hstmt); <br>      SendMessage(hWndhstmt, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   } <br>   SendMessage(hWndhstmt, LB_SETSEL, TRUE, 0); <br>} <br> <br>/* <br>    FUNCTION: NewQueryWindow() <br>    COMMENTS: Create a new hstmt on current hdbc and its associated window <br>*/ <br> <br>void FAR PASCAL NewQueryWindow() <br>{ <br>   int              nCurrenthdbc;           // current selection in the hdbc combobox <br>   char             szBuffer[MAXBUFLEN+1];  // string in the hdbc combobox on the toolbar <br>   char             szDBName[MAXBUFLEN+1];  // DSN string <br>   SQLHDBC          hdbc;                   // hdbc value in the combobox <br>   SQLHSTMT         hstmt;                  // hstmt <br>   MDICREATESTRUCT  mcs;                    // MDI child window create structure <br>   SQLRETURN        nResult;                // Result code <br> <br>   szDBName[0]='\0'; <br>szBuffer[0]= '\0'; <br> <br>// check if there is hdbc selected in the combobox <br> <br>if ((nCurrenthdbc = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0)) == CB_ERR) { <br>      MessageBox(hWndFrame, MAKECONNECT, NOHDBCERROR, MB_OK | MB_ICONHAND); <br>      return; <br>   } <br> <br>   // check if the number of windows exceeds MAXCHILDWNDS <br> <br>   if (nChildCount &gt;= MAXCHILDWNDS) { <br>      MessageBox(hWndFrame, MAXCHILDEXCEEDED, MAXCHLDERR, MB_OK | MB_ICONHAND); <br>      return; <br>   } <br> <br>   // Scan DSN string and hdbc value from the combo-box <br>   SendMessage(hWndCrsrList, CB_GETLBTEXT, (WPARAM)nCurrenthdbc, (LPARAM)(LPSTR)szBuffer); <br>   sscanf(szBuffer, SCANDSNHDBC_FORMAT, szDBName, &amp;hdbc); <br> <br> <br>   // Allocate a new Statement Handle on the scanned hdbc <br>   if ((nResult = SQLAllocHandle(SQL_HANDLE_STMT,hdbc, &amp;hstmt)) != SQL_SUCCESS) { <br>      DisplayError(nResult, hWndFrame, SQL_HANDLE_DBC, hdbc); <br>      return; <br>   } <br> <br>   // create a new MDI client window. maximized, if the previous is so. <br>   mcs.szClass = ODBCMDICLASS; <br>   mcs.szTitle = UNTITLED; <br>   mcs.hOwner  = hAppInstance; <br>   mcs.style   = hWndActiveChild &amp;&amp; IsZoomed(hWndActiveChild) ? WS_MAXIMIZE : 0; <br>   mcs.x = mcs.cx = mcs.y = mcs.cy = CW_USEDEFAULT; <br>   hWndActiveChild = (HWND)(UINT)SendMessage(hWndMDIClient, WM_MDICREATE, 0, (LPARAM)(LPMDICREATESTRUCT)&amp;mcs); <br> <br>   // check if it was created, if it wasn't free up resource and flag warning <br>   if (!hWndActiveChild) { <br>      MessageBox(hWndFrame, CREATECHILDERR, EXECERROR, MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>      SQLFreeHandle(SQL_HANDLE_STMT,hstmt); <br>      return; <br>   } <br> <br>   // display the DSN string, SQLHDBC and SQLHSTMT in the title of newly <br>   // created window. Increment the child window counter <br>   wsprintf(szBuffer, QUERY_STRING, hstmt); <br>   SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   wsprintf(szBuffer, DSN_HDBC_HSTMT_FORMAT, (LPSTR)szDBName, hdbc, hstmt); <br>   SetWindowText(hWndActiveChild, szBuffer); <br>   nChildCount++; <br> <br>   // update the hstmt(s) combo-box in the tool bar. <br>   ChangeCurrentQuery(hWndStmtList); <br>} <br> <br>/* <br>    FUNCTION: ChangeCurrentCursor(HWND hWndCrsrList) <br>    COMMENTS: Change the displayed hdbc in the hdbc(s) combobox <br>          Also activate the appropriate MDI child window that <br>          has the same hdbc as the new hdbc in the combobox. <br>*/ <br> <br>void FAR PASCAL ChangeCurrentCursor(HWND hWndCrsrList) <br>{ <br>   int      nNewhdbc;               //new hdbc position <br>   int      nConnects;              //# of connections <br>   int      nIndex;                 //counter <br>   char     szBuffer[MAXBUFLEN+1];  //string buffer <br>   BOOL     bChangedFocus;          //Activate a different MDI child? <br>   HWND     hWndChild;              //MDI Child window <br>   SQLHDBC  hdbc1;                  //hdbc in the window title <br>   SQLHDBC  hdbc2;                  //hdbc in the combobox <br>   SQLHSTMT hstmt;                  //hstmt in the window title <br> <br>   // check to see if the current selection in the combo-box <br>   // differs from the previous selection, if it is the same then <br>   // simply return. Check is made by searching a marked string <br>   // in the hdbc(s) combobox. <br>   nNewhdbc = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0); <br>   nConnects = (int)SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0); <br> <br>   for(nIndex = 0; nIndex &lt; nConnects; nIndex++) { <br>      SendMessage(hWndCrsrList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>      if (strstr(szBuffer, CUR_MARK)) <br>         break; <br>   } <br> <br>   if (nIndex == nNewhdbc) <br>      return; <br> <br>   // if there was a current marked hdbc in the combobox, remove the <br>   // mark from the string and replace it in the combobox. <br>   if (nIndex != nConnects) { <br>      SendMessage(hWndCrsrList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>      szBuffer[strlen(szBuffer)-2] = '\0'; <br>      SendMessage(hWndCrsrList, CB_INSERTSTRING, nIndex, (LPARAM)(LPSTR)szBuffer); <br>      SendMessage(hWndCrsrList, CB_DELETESTRING, nIndex+1, 0); <br>   } <br> <br>   // Create a new marked string with currently selected hdbc string in <br>   // the combobox and replace it with the original. <br>   SendMessage(hWndCrsrList, CB_GETLBTEXT, nNewhdbc, (LPARAM)(LPSTR)szBuffer); <br>   strcat(szBuffer, CUR_MARK); <br>   SendMessage(hWndCrsrList, CB_INSERTSTRING, nNewhdbc, (LPARAM)(LPSTR)szBuffer); <br>   SendMessage(hWndCrsrList, CB_DELETESTRING, nNewhdbc+1, 0); <br>   SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br> <br>   // reset the hstmt(s) combobox. Search through the MDI child windows <br>   // and collect all hstmt(s) from window titles that have the same <br>   // hdbc value as the newly selected hdbc in the hdbc(s) combo-box above. <br>   SendMessage(hWndStmtList, CB_RESETCONTENT, 0, 0); <br>   for (bChangedFocus=FALSE, hWndChild=GetWindow(hWndMDIClient, GW_CHILD);  hWndChild; hWndChild = GetWindow( <br>                                                                                                             hWndChild, GW_HWNDNEXT)) { <br>      // check class name to skip iconized titles or other <br>      // such non MDI Child windows <br>      GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>      if (strcmp(szBuffer, ODBCMDICLASS)) <br>         continue; <br> <br>      GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>      sscanf(szBuffer, SCANHDBCHSTMT_FORMAT, &amp;hdbc1, &amp;hstmt); <br> <br>      SendMessage(hWndCrsrList, CB_GETLBTEXT, (WPARAM)nNewhdbc, (LPARAM)(LPSTR)szBuffer); <br>      sscanf(szBuffer, SCANHDBC_FORMAT, &amp;hdbc2); <br> <br>      if (hdbc1 != hdbc2) <br>         continue; <br> <br>      if (!bChangedFocus) { <br>         // If the first match is found, change the active window <br>         // and update the hstmt(s) combobox with a new entry that <br>         // has hstmt marked with current marker. <br>         bChangedFocus = TRUE; <br>         hWndActiveChild = hWndChild; <br>         SendMessage(hWndMDIClient, WM_MDIACTIVATE, (WPARAM)hWndChild, 0); <br>         wsprintf(szBuffer, CURQUERY_STRING, hstmt); <br>         SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>         SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>      } <br>      else { <br>         // simply add the hstmt in the hstmt(s) combobox. <br>         wsprintf(szBuffer, QUERY_STRING, hstmt); <br>         SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>      } <br>   } <br>} <br> <br>/* <br>    FUNCTION: ChangeCurrentQuery(HWND hWndStmtList) <br>    COMMENTS: Change the current selection in the hstmt(s) combobox. <br>          Update the current marker in the combobox and activate <br>          proper MDI Child window. <br>*/ <br> <br>void FAR PASCAL ChangeCurrentQuery(HWND hWndStmtList) <br>{ <br>   int      nNewhstmt;              //new selection in combobox <br>   int      nStmts;                 //# of hstmts <br>   int      nIndex;                 //counter <br>   char     szBuffer[MAXBUFLEN+1];  //string buffer to update displays <br>   HWND     hWndChild;              //MDI child window handle <br>   SQLHDBC  hdbc1 = NULL;                  //hdbc in hdbc(s) combobox <br>   SQLHDBC  hdbc2 = NULL;                  //hdbc in child window title <br>   SQLHSTMT hstmt1 = NULL;                 //newly selected hstmt <br>   SQLHSTMT hstmt2 = NULL;                 //hstmt in child window title <br> <br>   // find the index of new selection and total number of hstmt(s) <br>   nNewhstmt = (int)SendMessage(hWndStmtList, CB_GETCURSEL, 0, 0); <br>   nStmts = (int)SendMessage(hWndStmtList, CB_GETCOUNT, 0, 0); <br> <br>   // check if the current selection is same as previous one, if <br>   // so simply return. Check for marker to determine previous selection <br>   for(nIndex = 0; nIndex &lt; nStmts; nIndex++) { <br>      SendMessage(hWndStmtList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>      if (strstr(szBuffer, CUR_MARK)) <br>         break; <br>   } <br> <br>   if (nIndex == nNewhstmt) <br>      return; <br> <br>   // if a previous selection was found, remove current marker <br>   // and update it in the hstmt(s) combobox. <br>   if (nIndex != nStmts) { <br>      SendMessage(hWndStmtList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>      szBuffer[strlen(szBuffer)-2] = '\0'; <br>      SendMessage(hWndStmtList, CB_INSERTSTRING, nIndex, (LPARAM)(LPSTR)szBuffer); <br>      SendMessage(hWndStmtList, CB_DELETESTRING, nIndex+1, 0); <br>   } <br> <br>   // mark the current selection and update it in the hstmt(s) combobox <br>   SendMessage(hWndStmtList, CB_GETLBTEXT, nNewhstmt, (LPARAM)(LPSTR)szBuffer); <br>   strcat(szBuffer, CUR_MARK); <br>   SendMessage(hWndStmtList, CB_INSERTSTRING, nNewhstmt, (LPARAM)(LPSTR)szBuffer); <br>   SendMessage(hWndStmtList, CB_DELETESTRING, nNewhstmt+1, 0); <br>   SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br> <br>   // scan hstmt value and hdbc value from current selection in <br>   // hdbc(s) and hstmt(s) comboboxes. <br>   sscanf(szBuffer, QUERY_STRING, &amp;hstmt1); <br> <br>   SendMessage(hWndCrsrList, CB_GETLBTEXT, (UINT)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0), <br>               (LPARAM)(LPSTR)szBuffer); <br>   sscanf(szBuffer, SCANHDBC_FORMAT, &amp;hdbc1); <br> <br> <br>   // go through list of MDI Child windows and match the hstmt and hdbc <br>   // values. If a match if found (must be), activate the window <br>   for (hWndChild=GetWindow(hWndMDIClient, GW_CHILD); hWndChild; hWndChild=GetWindow(hWndChild, GW_HWNDNEXT)) { <br>      // ignore non MDI child windows <br>      GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>      if (strcmp(szBuffer, ODBCMDICLASS)) <br>         continue; <br> <br>      GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>      sscanf(szBuffer, SCANHDBCHSTMT_FORMAT, &amp;hdbc2, &amp;hstmt2); <br> <br>      if (hdbc1 == hdbc2 &amp;&amp; hstmt1 == hstmt2) { <br>         hWndActiveChild = hWndChild; <br>         SendMessage(hWndMDIClient, WM_MDIACTIVATE, (WPARAM)hWndChild, 0); <br>         break; <br>      } <br>   } <br>} <br> <br>/* <br>    FUNCTION: DisplayNewCrsrAndStmt() <br>    COMMENTS: If user changes currently active MDI Child Window, both <br>          hstmt(s) and hdbc(s) comboboxes need to be updated to <br>          reflect currently selected MDI child. match the hstmt and <br>          hdbc value in the title of MDI child to those on display <br>          in hstmt(s) and hdbc(s) comboboxes respectively. <br>*/ <br> <br>void FAR PASCAL DisplayNewCrsrAndStmt() <br>{ <br>   int      nConnects;              // # of hdbc(s) <br>   int      nStmts;                 // # of hstmt(s) <br>   int      nOldhdbc;               // prev selection in hdbc combobox <br>   int      nOldhstmt;              // prev selection in hstmt combobox <br>   int      nIndex;                 // counter <br>   char     szBuffer[MAXBUFLEN+1];  // display buffer <br>   HWND     hWndChild;              // MDI Child window <br>   SQLHDBC  hdbc1;                  // hdbc in window title <br>   SQLHDBC  hdbc2;                  // hdbc in hdbc(s) combobox <br>   SQLHSTMT hstmt1;                 // hstmt in window title <br>   SQLHSTMT hstmt2;                 // hstmt in hstmt(s) combobox <br> <br>   // scan hdbc and hstmt values from newly selected window <br>   GetWindowText(hWndActiveChild, szBuffer, MAXBUFLEN); <br>   sscanf(szBuffer, SCANHDBCHSTMT_FORMAT, &amp;hdbc1, &amp;hstmt1); <br> <br>   // search through list of hdbc(s) in hdbc combobox and find <br>   // matching hdbc. remove marker from prev selection and add <br>   // marker to the new selection. update combobox accordingly. <br>   nConnects = (int)SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0); <br>   nOldhdbc = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0); <br> <br>   for(hdbc2 = (SQLHDBC)(nIndex = 0); hdbc1 != hdbc2; nIndex++) { <br>      SendMessage(hWndCrsrList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>      sscanf(szBuffer, SCANHDBC_FORMAT, &amp;hdbc2); <br>   } <br> <br>   if (--nIndex != nOldhdbc) // change in hdbc combobox required. <br>      { <br>         SendMessage(hWndCrsrList, CB_GETLBTEXT, nOldhdbc, (LPARAM)(LPSTR)szBuffer); <br>         szBuffer[strlen(szBuffer)-2] = '\0'; <br>         SendMessage(hWndCrsrList, CB_INSERTSTRING, nOldhdbc, (LPARAM)(LPSTR)szBuffer); <br>         SendMessage(hWndCrsrList, CB_DELETESTRING, nOldhdbc+1, 0); <br> <br>         SendMessage(hWndCrsrList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>         strcat(szBuffer, CUR_MARK); <br>         SendMessage(hWndCrsrList, CB_INSERTSTRING, nIndex, (LPARAM)(LPSTR)szBuffer); <br>         SendMessage(hWndCrsrList, CB_DELETESTRING, nIndex+1, 0); <br>         SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br> <br>         // reset the hstmt(s) combobox, search through the list <br>         // of MDI child windows and find all hstmt(s) associated to <br>         // new hdbc. Build the new list of hstmt(s) for the hstmt <br>         // combobox. Mark the one hstmt that matches the currently <br>         // activated MDI child window. <br>         SendMessage(hWndStmtList, CB_RESETCONTENT, 0, 0); <br>         for (hWndChild=GetWindow(hWndMDIClient,GW_CHILD);hWndChild;hWndChild=GetWindow(hWndChild,GW_HWNDNEXT)) { <br>            GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>            if (strcmp(szBuffer, ODBCMDICLASS)) <br>               continue; <br> <br>            GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>            sscanf(szBuffer, SCANHDBCHSTMT_FORMAT, &amp;hdbc2, &amp;hstmt2); <br> <br>            if (hdbc1 != hdbc2) <br>               continue; <br> <br>            if (hWndActiveChild == hWndChild) { <br>               wsprintf(szBuffer, CURQUERY_STRING, hstmt2); <br>               SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>               SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>            } <br>            else { <br>               wsprintf(szBuffer, QUERY_STRING, hstmt2); <br>               SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>            } <br>         } <br>      } <br>   else // no change in hdbc combobox required <br>      { <br>         // go through the list of hstmt(s) in hstmt combobox. <br>         // find the one that matches the currently activated MDI <br>         // child window. <br>         nOldhstmt = (int)SendMessage(hWndStmtList, CB_GETCURSEL, 0, 0); <br>         nStmts = (int)SendMessage(hWndStmtList, CB_GETCOUNT, 0, 0); <br> <br>         for(hstmt2 = (SQLHDBC)(nIndex = 0); hstmt1 != hstmt2; nIndex++) { <br>            SendMessage(hWndStmtList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>            sscanf(szBuffer, QUERY_STRING, &amp;hstmt2); <br>         } <br> <br>         if (--nIndex != nOldhstmt) // new index in hstmt differs from previous selection <br>            { <br>               // remove the marker from previous selection. Add <br>               // it to the new string and update the combobox display <br>               SendMessage(hWndStmtList, CB_GETLBTEXT, nOldhstmt, (LPARAM)(LPSTR)szBuffer); <br>               szBuffer[strlen(szBuffer)-2] = '\0'; <br>               SendMessage(hWndStmtList, CB_INSERTSTRING, nOldhstmt, (LPARAM)(LPSTR)szBuffer); <br>               SendMessage(hWndStmtList, CB_DELETESTRING, nOldhstmt+1, 0); <br> <br>               SendMessage(hWndStmtList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>               strcat(szBuffer, CUR_MARK); <br>               SendMessage(hWndStmtList, CB_INSERTSTRING, nIndex, (LPARAM)(LPSTR)szBuffer); <br>               SendMessage(hWndStmtList, CB_DELETESTRING, nIndex+1, 0); <br>               SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>            } <br>      } <br>} <br> <br>/* <br>    FUNCTION: FreeConnect(HWND hWndhdbc) <br>    COMMENTS: Disconnect and Free the currently selected hdbc in <br>          the hdbc listbox in disconnect dialog. Call SQLDisconnect <br>          and SQLFreeConnect to free the hdbc. Close all MDI <br>          child windows associated with this hdbc. That will <br>          automatically free associated hstmt(s). <br>*/ <br> <br>void FAR PASCAL FreeConnect(HWND hWndhdbc) <br>{ <br>   int     nIndex;                 // current selection in the listbox of disconnect dlg <br>   int     nCurrent;               // current selection in hdbc(s) combobox <br>   char    szBuffer[MAXBUFLEN+1];  // display buffer <br>   char    szSelect[MAXBUFLEN+1];  // original selection in hdbc(s) combobox <br>   char    szDBName[MAXBUFLEN+1];  // DSN string <br>   HWND    hWndChild;              // MDI Child window <br>   SQLHDBC hdbc1 = NULL;                  // hdbc in the list box of disconnect dlg <br>   SQLHDBC hdbc2 = NULL;                  // hdbc in the MDI child window title <br> <br>   szDBName[0]='\0'; <br>// check current selection in the list box of disconnect dialog. scan <br>   // hdbc value from the current selection. <br>   if ((nIndex = (int)SendMessage(hWndhdbc, LB_GETCURSEL, 0, 0)) == LB_ERR) <br>      return; <br> <br>   SendMessage(hWndhdbc, LB_GETTEXT, (WPARAM)nIndex, (LPARAM)(LPSTR)szBuffer); <br>   sscanf(szBuffer, SCANDSNHDBC_FORMAT, szDBName, &amp;hdbc1); <br> <br> <br>   // go through the list of MDI child windows and find matching hdbc(s) <br>   // close all children who have the same hdbc value. Closing them <br>   // automatically frees associated hstmts. see CloseQueryWindow. <br>   for(hWndChild = GetWindow(hWndMDIClient, GW_CHILD); hWndChild; ) { <br>      // store next window handle before destroying the currentone <br>      HWND hWndTemp = GetWindow(hWndChild, GW_HWNDNEXT); <br> <br>      // ignore non MDI child windows <br>      GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>      if (!strcmp(szBuffer, ODBCMDICLASS)) { <br>         GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>         sscanf(szBuffer, SCANHDBC_TITLEFORMAT, &amp;hdbc2); <br> <br>         if (hdbc1 == hdbc2) { <br>            // destroy the window and restart search <br>            SendMessage(hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChild, 0); <br>            hWndTemp = GetWindow(hWndMDIClient, GW_CHILD); <br>         } <br>      } <br>      hWndChild = hWndTemp; <br>   } <br> <br>   // call SQLDisconnect and SQLFreeConnect to disconnect and free hdbc <br>   SQLDisconnect(hdbc1); <br>   SQLFreeHandle(SQL_HANDLE_DBC,hdbc1); <br> <br>   // update the hdbc(s) combobox display by removing the deleted hdbc <br>   // from the list and reselecting the previous selection <br>   wsprintf(szBuffer, DSN_HDBC_FORMAT, (LPSTR)szDBName, hdbc1); <br>   nCurrent = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0); <br>   SendMessage(hWndCrsrList, CB_GETLBTEXT, nCurrent, (LPARAM)(LPSTR)szSelect); <br>   nIndex = (int)SendMessage(hWndCrsrList, CB_FINDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>   SendMessage(hWndCrsrList, CB_DELETESTRING, (WPARAM)nIndex, 0); </code></pre>
<p>
</p>
<pre><code>SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szSelect); <br> <br>   // if there is no query window open and the current selected SQLHDBC <br>   // was deleted, make sure to make the next available SQLHDBC as current <br>   if (SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0) &amp;&amp; <br>       !GetWindow(hWndMDIClient, GW_CHILD) &amp;&amp; (nCurrent == nIndex)) { <br>      if ((nCurrent = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0))!=CB_ERR) <br>         return; <br>      SendMessage(hWndCrsrList, CB_GETLBTEXT, 0, (LPARAM)(LPSTR)szSelect); <br>      strcat(szSelect, CUR_MARK); <br>      SendMessage(hWndCrsrList, CB_INSERTSTRING, 0, (LPARAM)(LPSTR)szSelect); <br>      SendMessage(hWndCrsrList, CB_DELETESTRING, 1, 0); <br>      SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szSelect); <br>   } <br>} <br> <br>/* <br>    FUNCTION: FreeQuery(HWND hWndhstmt, HWND hWndhdbc, int nIndex) <br>    COMMENTS: Free a query window based upon current selection in <br>          hstmt list box in the disconnect dialog. <br>*/ <br> <br>void FAR PASCAL FreeQuery(HWND hWndhstmt, HWND hWndhdbc, int nIndex) <br>{ <br>   char     szBuffer[MAXBUFLEN+1];  // display buffer <br>   HWND     hWndChild;      // MDI child window <br>   SQLHDBC  hdbc1;          // hdbc in the hdbc listbox of disconnect dlg <br>   SQLHDBC  hdbc2;          // hdbc in the MDI child window title <br>   SQLHSTMT hstmt1;         // hstmt in the hstmt listbox of disconnect dlg <br>   SQLHSTMT hstmt2;         // hstmt in the MDI child window title <br> <br>   // scan the hstmt and hdbc values from the current selections in <br>   // respective listboxes of disconnect dialog box. <br>   SendMessage(hWndhstmt, LB_GETTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>   sscanf(szBuffer, QUERY_STRING, &amp;hstmt1); <br>   SendMessage(hWndhdbc, LB_GETTEXT, (UINT)SendMessage(hWndhdbc, LB_GETCURSEL,  0, 0), (LPARAM)(LPSTR)szBuffer); <br>   sscanf(szBuffer, SCANHDBC_FORMAT, &amp;hdbc1); <br> <br>   // go through the list of MDI child windows and find matching window <br>   // that has same values for hdbc and hstmt. Destroy the matching window. <br>   // that will call CloseQueryWindow and thus free up associated hstmt. <br>   for(hWndChild=GetWindow(hWndMDIClient, GW_CHILD); hWndChild; hWndChild=GetWindow(hWndChild, GW_HWNDNEXT)) { <br>      // ignore non MDI child windows <br>      GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>      if (strcmp(szBuffer, ODBCMDICLASS)) <br>         continue; <br>      GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>      sscanf(szBuffer, SCANHDBCHSTMT_FORMAT, &amp;hdbc2, &amp;hstmt2); <br>      if (hdbc1 == hdbc2 &amp;&amp; hstmt1 == hstmt2) <br>         break; <br>   } <br>   SendMessage(hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChild, 0); <br>} <br> <br>/* <br>    FUNCTION: CloseQueryWindow(HWND hWnd) <br>    COMMENTS: Close a Query window. Call SQLFreeHandle to free <br>          associated hstmt. <br>*/ <br> <br>void FAR PASCAL CloseQueryWindow(HWND hWnd) <br>{ <br>   char szBuffer[MAXBUFLEN+1];  // display buffer <br>   char szSelect[MAXBUFLEN+1];  // current selection in hstmt(s) combobox <br>   SQLHSTMT hstmt;              // hstmt value in window title <br> <br>   // scan the hstmt value from the window title <br>   GetWindowText(hWnd, szBuffer, MAXBUFLEN); <br>   sscanf(szBuffer, SCANHSTMT_TITLEFORMAT, &amp;hstmt); <br> <br>   // Drop the current Statement Handle <br>   SQLFreeHandle(SQL_HANDLE_STMT,hstmt); <br> <br>   // find the matching hstmt in the hstmt(s) combobox and remove it <br>   // from the list. Closure of a MDI child window will cause MDIClient <br>   // to automatically activate a different child window if available. <br>   // that will automatically refresh the hstmt and hdbc displays. See <br>   // DisplayNewCrsrAndStmt function. <br>   wsprintf(szBuffer, QUERY_STRING, hstmt); <br>   SendMessage(hWndStmtList, CB_GETLBTEXT, (WPARAM)SendMessage(hWndStmtList, CB_GETCURSEL, 0, 0), (LPARAM)(LPSTR)szSelect); <br>   SendMessage(hWndStmtList, CB_DELETESTRING, (WPARAM)SendMessage(hWndStmtList, CB_FINDSTRING, 0, <br>                                                                  (LPARAM)(LPSTR)szBuffer), 0); <br>   SendMessage(hWndStmtList, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)(LPSTR)szSelect); <br> <br>   // decrement the child window counter. <br>   nChildCount--; <br>} <br> <br>/* <br>    FUNCTION: ExecuteQuery() <br>    COMMENTS: Execute the user typed SQL Statements in the currently <br>          active MDI child window. If successful, then prepare <br>          the list of results and display it in the child listbox. <br>          Display errors in the ODBC function(s) failed. <br>*/ <br> <br>void FAR PASCAL ExecuteQuery() <br>{ <br>   char      szBuffer[MAXBUFLEN+1];      // display buffer <br>   HWND      hList;                      // result listbox handle <br>   SQLHDBC   hdbc;                       // hdbc <br>   SQLHSTMT  hstmt;                      // hstmt <br>   SWORD     nCols = 0;                  // # of result columns <br>   SWORD     nCount;                     // index <br>   SWORD     swColType;                  // column data type <br>   SWORD     swColScale;                 // column scale <br>   SWORD     swColNull;                  // nullable column ? <br>   SWORD     swColLength = MAXDATALEN;   // column data length <br>   DWORD     dwText;                     // tab stop for listbox <br>   UDWORD    udwColDef;                  // precision on the column <br>   SQLRETURN nReturn;                    // return code <br>   HCURSOR   hOldCursor;                 // default cursor handle <br>   int       nRows;                      // # of result rows <br> <br>   // check if there is an active window available <br>   if (!hWndActiveChild) { <br>      MessageBox(hWndFrame, ((SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0) &lt;=0) ? <br>                             MAKECONNECT : OPENWINDOW ), NOHSTMTERROR, MB_OK | MB_ICONHAND); <br>      return; <br>   } <br> <br>   // change cursor shape to hour glass <br>   hOldCursor = SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT)); <br> <br>   // initialize column data and column data length arrays <br>   for (nCount = 0; nCount &lt; MAX_COL; nCount++) { <br>      dwDataLen[nCount] = 0; <br>      rgbData[nCount][0] = '\0'; <br>   } <br> <br>   // scan hdbc, hstmt values <br>   GetWindowText(hWndActiveChild, szBuffer, MAXBUFLEN); <br>   sscanf(szBuffer, SCANHDBCHSTMT_FORMAT, &amp;hdbc, &amp;hstmt); <br> <br>   // get the user typed SQL <br>   GetWindowText(GetDlgItem((HWND)GetWindowLong(hWndActiveChild, GWLAPP_HDLG), IDTEXT_SQL), szBuffer, MAXBUFLEN); <br> <br>   // execute SQL and process errors if any <br>   // call SQLExecDirect to execute the SQL statement <br>   nReturn = SQLExecDirect(hstmt, szBuffer, SQL_NTS); <br>   if (nReturn != SQL_SUCCESS) { <br>      DisplayError(nReturn, hWndActiveChild, SQL_HANDLE_STMT, hstmt); <br> <br>      // if the return value was just information, carry on <br>      if (nReturn != SQL_SUCCESS_WITH_INFO) { <br>         // Close the open result set. <br>         SQLCloseCursor(hstmt); <br>         SetCursor(hOldCursor); <br>         return; <br>      } <br>   } <br> <br>   // call SQLNumResultCols to calculate the number of columns in <br>   // the result set, if more than the MAX_COL (the array boundary) <br>   // limit the number to MAX_COL and display truncation warning. <br>   // if it is 0, the statement probably was a non-SELECT simply return <br>   nReturn = SQLNumResultCols(hstmt, &amp;nCols); <br>   if (nCols &gt;= MAX_COL) { <br>      nCols = MAX_COL; <br>      wsprintf(szDispBuffer, COLTRUNC_WARNG, MAX_COL); <br>      MessageBox(hWndFrame, szDispBuffer, TRUNCERR, MB_OK | MB_ICONINFORMATION); <br>   } <br>   else if (nCols == 0) { <br>      // Close the open result set. <br>      SQLCloseCursor(hstmt); <br>      SetCursor(hOldCursor); <br>      return; <br>   } <br> <br>   // call SQLBindCol to bind column data array and column data length <br>   // array to the result set <br>   for(nCount=0; nCount&lt;nCols; nCount++) <br>      SQLBindCol(hstmt, (UWORD)(nCount+1), SQL_C_CHAR, rgbData[nCount], MAXDATALEN, &amp;dwDataLen[nCount]); <br> <br>   // reset the display in the list box. Set tabstops to display <br>   // multiple columns in the list box separated by tabs. <br>   hList = GetDlgItem((HWND)GetWindowLong(hWndActiveChild, GWLAPP_HDLG), IDLIST_RSLT); <br> <br>   SendMessage(hList, LB_RESETCONTENT, 0, 0); <br>   SendMessage(hList, WM_SETREDRAW, FALSE, 0); <br>   dwText = LISTTABSTOP; <br>   SendMessage(hList, LB_SETTABSTOPS, (WPARAM)1, (LPARAM)(LPINT)&amp;dwText); <br> <br>   // call SQLDescribeCol to get description of each column in the <br>   // result set. Store the column name in the display buffer and <br>   // make it the first entry in the results list box of the MDI <br>   // child window. <br>   for(nCount=1, szDispBuffer[0]='\0'; nCount &lt;= nCols; nCount++) { <br>      SQLDescribeCol(hstmt, nCount, szBuffer, MAXDATALEN, &amp;swColLength, &amp;swColType, &amp;udwColDef, <br>                     &amp;swColScale, &amp;swColNull); <br>      strcat(szDispBuffer, szBuffer); <br>      dwText = strlen(szDispBuffer); <br>      szDispBuffer[dwText++] = '\t'; <br>      szDispBuffer[dwText] = '\0'; <br>   } <br>   if (*szDispBuffer) <br>      szDispBuffer[strlen(szDispBuffer)-1]='\0'; <br>   SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDispBuffer); <br> <br>   // call SQLFetch to fetch each row of the result set. Extract data <br>   // value and store it in the display buffer, separated by tabs. <br>   // continue until SQLFetch fails. <br>   for(nRows = 0; (nReturn = SQLFetch(hstmt))==SQL_SUCCESS || nReturn==SQL_SUCCESS_WITH_INFO;) { <br>      if (nReturn != SQL_SUCCESS) <br>         DisplayError(nReturn, hWndActiveChild, SQL_HANDLE_STMT, hstmt); <br>      for(nCount=0, szDispBuffer[0]='\0'; nCount&lt;nCols; nCount++) { <br>         // check if the column is a null value? <br>         strcat(szDispBuffer, (dwDataLen[nCount]==SQL_NULL_DATA)?NULLDATASTRING:rgbData[nCount]); <br>         dwText = strlen(szDispBuffer); <br>         szDispBuffer[dwText++] = '\t'; <br>         szDispBuffer[dwText] = '\0'; <br>      } <br>      if (*szDispBuffer) <br>         szDispBuffer[strlen(szDispBuffer)-1]='\0'; <br>      else <br>         break; <br>      SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDispBuffer); <br>      if (++nRows == MAX_ROW) { <br>         wsprintf(szDispBuffer, ROWTRUNC_WARNG, MAX_ROW); <br>         MessageBox(hWndFrame, szDispBuffer, TRUNCERR, MB_OK | MB_ICONINFORMATION); <br>         break; <br>      } <br>   } <br> <br>   // set the horizontal scroll extent in the list box and ask for repaint. <br>   SendMessage(hList, LB_SETHORIZONTALEXTENT, (WPARAM)(nCols*LISTHORZSCROLL+LISTHORZEXT), 0); <br>   SendMessage(hList, WM_SETREDRAW, TRUE, 0); <br> <br>   // if there was any error returned by SQLFetch, display it <br>   if (nReturn == SQL_ERROR) <br>      DisplayError(nReturn, hWndActiveChild, SQL_HANDLE_STMT, hstmt); <br> <br>   // Close the open result set. <br>   // Unbind all bound columns. <br>   SQLCloseCursor(hstmt); <br>   SQLFreeStmt(hstmt, SQL_UNBIND); <br> <br>   // restore the cursor to default value <br>   SetCursor(hOldCursor); <br>} <br> <br>/* <br>    FUNCTION: CloseDatabases() <br>    COMMENTS: Go through all open connections (hdbcs) and hstmt(s) <br>          and close them one by one. <br>*/ <br> <br>BOOL FAR PASCAL CloseDatabases() <br>{ <br>   int     nIndex;                 // index <br>   int     nCount;                 // # of connected hdbc(s) <br>   char    szBuffer[MAXBUFLEN+1];  // display string buffer <br>   HWND    hWndChild;              // MDI Child Window <br>   SQLHDBC hdbc1;                  // hdbc value in the hdbc(s) combobox <br>   SQLHDBC hdbc2;                  // hdbc value in the MDI Child window title <br> <br>   // get count of connected hdbc(s) from the hdbc(s) combobox on the toolbar <br>   if (!(nCount = (int)SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0))) <br>      return (TRUE); <br> <br>   // go through all available MDI child windows and for each hdbc, <br>   // find the matching MDI child window and ask it for closure, thereby <br>   // freeing the associated hstmt (see CloseQueryWindow). Once all <br>   // associated hstmt(s) are freed, free the hdbc <br>   for (nIndex = 0; nIndex &lt; nCount; nIndex++) { <br>      // scan current indexed hdbc from hdbc(s) combobox <br>      SendMessage(hWndCrsrList, CB_GETLBTEXT, (WPARAM)nIndex, (LPARAM)(LPSTR)szBuffer); <br>      sscanf(szBuffer, SCANHDBC_FORMAT, &amp;hdbc1); <br> <br>      // search through the list of MDI Child Windows <br>      for(hWndChild = GetWindow(hWndMDIClient, GW_CHILD); hWndChild; ) { <br>         // store the next child, before destroying the current <br>         HWND hWndTemp = GetWindow(hWndChild, GW_HWNDNEXT); <br> <br>         // ignore non MDI child windows <br>         GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>         if (!strcmp(szBuffer, ODBCMDICLASS)) { <br>            GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>            sscanf(szBuffer, SCANHDBC_TITLEFORMAT, &amp;hdbc2); <br>            if (hdbc1 == hdbc2) { <br>               // destroy the window and restart search <br>               SendMessage(hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChild, 0); <br>               hWndTemp = GetWindow(hWndMDIClient, GW_CHILD); <br>            } <br>         } <br>         hWndChild = hWndTemp; <br>      } <br> <br>      // call SQLDisconnect and SQLFreeConnect to disconnect and <br>      // free the curren hdbc resource <br>      SQLDisconnect(hdbc1); <br>      SQLFreeHandle(SQL_HANDLE_DBC,hdbc1); <br>   } <br> <br>   // reset the hdbc(s) combobox display and display all connections <br>   // closed message. return success to let application exit. <br>   SendMessage(hWndCrsrList, CB_RESETCONTENT, 0, 0); <br>   MessageBox(hWndFrame, CLOSEALLHDBC, LOGOUTINFO,  MB_OK | MB_ICONINFORMATION); <br>   return (TRUE); <br>} <br> <br>/* <br>    FUNCTION: FreeSQLEnvironment() <br>    COMMENTS: Free the ODBC environment. <br>*/ <br> <br>BOOL FAR PASCAL FreeSQLEnvironment() <br>{ <br>   // Free up all ODBC related resources <br>   return (SQLFreeHandle(SQL_HANDLE_ENV,henv) == SQL_SUCCESS); <br>} <br> <br>/* <br>    FUNCTION: DisplayError(SQLRETURN nResult, HWND hWnd, SWORD fHandleType, SQLHANDLE handle) <br>    COMMENTS: Format and display errors or warnings. <br>*/ <br> <br>void FAR PASCAL DisplayError(SQLRETURN nResult, HWND hWnd, SWORD fHandleType, SQLHANDLE handle) <br>{ <br>   UCHAR    szErrState[SQL_SQLSTATE_SIZE+1];    // SQL Error State string <br>   UCHAR    szErrText[SQL_MAX_MESSAGE_LENGTH+1];    // SQL Error Text string <br>   char szBuffer[SQL_SQLSTATE_SIZE+SQL_MAX_MESSAGE_LENGTH+MAXBUFLEN+1]; <br>   // formatted Error text Buffer <br>   SWORD    wErrMsgLen;             // Error message length <br>   UDWORD   dwErrCode;              // Native Error code <br>   int  iSize;                      // Display Error Text size <br>   SQLRETURN  nErrResult;             // Return Code from SQLGetDiagRec <br>   SWORD sMsgNum = 1; <br>   SWORD fFirstRun = TRUE; <br> <br>   szBuffer[0] = '\0'; <br> <br>   do <br>      { <br>         // continue to bring messageboxes till all errors are displayed. <br>         // more than one message box may be reqd. as err text has fixed <br>         // string size. <br> <br>         // initialize display buffer with the string in error text buffer <br>         strcpy(szDispBuffer, szBuffer); <br> <br>         // call SQLGetDiagRec function with proper ODBC handles, repeatedly until <br>         // function returns SQL_NO_DATA. Concatenate all error strings <br>         // in the display buffer and display all results. <br>         while ((nErrResult = SQLGetDiagRec(fHandleType, handle, sMsgNum++, <br>                                            szErrState, &amp;dwErrCode, szErrText, <br>                                            SQL_MAX_MESSAGE_LENGTH-1, &amp;wErrMsgLen)) <br>                != SQL_NO_DATA) { <br> <br> <br>if(nErrResult == SQL_ERROR || nErrResult == SQL_INVALID_HANDLE) <br>break; <br> <br>            wsprintf(szBuffer, SQLERR_FORMAT, (LPSTR)szErrState, dwErrCode, (LPSTR)szErrText); <br>            iSize = strlen(szDispBuffer); <br>            if (iSize &amp;&amp; (iSize+strlen(szBuffer)+1) &gt;= MAXDISPLAYSIZE) <br>               break; <br>            if (iSize) <br>               strcat(szDispBuffer, "\n"); <br>            strcat(szDispBuffer, szBuffer); <br>         } <br> <br>         // display proper ERROR or WARNING message with proper title <br> <br>         if (nResult == SQL_SUCCESS_WITH_INFO) <br>            MessageBox(hWnd, szDispBuffer, (fFirstRun? SQLWRNMSGTITLE : SQLWRNCNTDTITLE), <br>                       MB_OK | MB_ICONINFORMATION); <br>         else <br>            MessageBox(hWnd, szDispBuffer, (fFirstRun? SQLERRMSGTITLE : SQLERRCNTDTITLE), <br>                       MB_OK | MB_ICONEXCLAMATION); <br> <br>         if (fFirstRun) <br>            fFirstRun = FALSE; <br>      } <br>   while (!(nErrResult == SQL_NO_DATA || nErrResult == SQL_ERROR || nErrResult == SQL_INVALID_HANDLE)); <br>} <br>/********************************************* END OF FILE **************************************************/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
