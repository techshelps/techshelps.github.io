<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2290"></a>MAIN.C</h2>
<pre><code>/* <br>    PROGRAM: QURYDEMO <br>    ======== <br> <br>    PURPOSE: <br>    ======== <br>    demonstrates a simple MDI application that allows a user to <br>    simultaneously connect to multiple hetrogeneous databases <br>    and perform SQL queries to get results. <br> <br>    FUNCTIONS: <br>    ========== <br>    WinMain() - main routine <br>    MainWndProc() - processes Main Application Window messages <br>    MDIChildProc() - processes MDI child window messages <br>    ToolbarProc() - processes tool bar messages <br>    StatusbarProc() - processes Status bar messages <br>    ConnectDlgProc() - processes Connection Dialog box messages <br>    DisconnectDlgProc() - processes Disconnect Dialog box messages <br>    AboutDlgProc() - processes messages for About dialog box <br>    MDIChildDlgProc() - processes messages for dummy child dialog box <br>            in MDI child window <br>    DrawBitmap() - draws bitmaps for toolbuttons <br> <br>    COMMENTS: <br>    ========= <br>    Created by Microsoft Corporation. <br>*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;time.h&gt; <br> <br>#include &lt;windows.h&gt; <br>#ifdef WIN32 <br>#include &lt;windowsx.h&gt; <br>#else <br>#include "w16macro.h" <br>#endif <br>#include "qurydemo.h" <br> <br>CONSTSTR(szKeyWord, "query demo, features"); <br> <br> <br>/* <br>    FUNCTION: WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>    COMMENTS: Application Entry Routine. <br>          Register Classes. Create Main Window and MDI Child Window. <br>          Process Main Message Loop. <br>*/ <br> <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>{ <br>   MSG     msg;            //msg structure <br>   WNDCLASS    wc;         //class structure <br>   HICON       hMainIcon;      //App Icon <br>   HICON       hMDIChildIcon;      //MDI Child Icon <br>   HWND        hWndMDIChild;       //temp MDI Child Window Handle <br>   char        szBuffer[MAXBUFLEN+1];  //temp string buffer to check class name <br>   BOOL        bDialogMessage = FALSE; //temp boolean to check dilogbox msgs <br>   HACCEL      hAccel;         //accelerator table handle <br> <br>   hAppInstance = hInstance; <br> <br>   // check if application is already running, if <br>   // so make it active and bring it in focus <br> <br>   if (hWndFrame = FindWindow(ODBCFRAMECLASS, NULL)) { <br>      hWndFrame = GetLastActivePopup(hWndFrame); <br>      if (IsIconic(hWndFrame)) <br>         OpenIcon(hWndFrame); <br>      else <br>         BringWindowToTop(hWndFrame); <br>      ACTIVATEWINDOW(hWndFrame); <br>      return (FALSE); <br>   } <br> <br>   // initialize ODBC Driver Manager Interface <br> <br>   if (!InitSQLEnvironment()) { <br>      MessageBox(hWndFrame, INITERROR, EXECERROR, MB_OK|MB_ICONHAND); <br>      return (FALSE); <br>   } <br> <br>   // register window classes for the application - Main Window Class <br> <br>   wc.style = 0; <br>   wc.lpfnWndProc = MainWndProc; <br>   wc.cbClsExtra = 0; <br>   wc.cbWndExtra = 0; <br>   wc.hInstance = hAppInstance; <br>   wc.hIcon = hMainIcon = LoadIcon(hAppInstance, APPICON); <br>   wc.hCursor = LoadCursor((HINSTANCE)NULL, IDC_ARROW); <br>   wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE+1); <br>   wc.lpszMenuName =  QURYDEMOMENU; <br>   wc.lpszClassName = ODBCFRAMECLASS; <br> <br>   if (!RegisterClass(&amp;wc)) { <br>      MessageBox(hWndFrame, CLASSERROR, EXECERROR, MB_OK|MB_ICONHAND|MB_TASKMODAL); <br>      return (FALSE); <br>   } <br> <br>   // register Toolbar Class <br> <br>   wc.hIcon = (HICON)NULL; <br>   wc.lpszMenuName =  NULL; <br>   wc.lpfnWndProc = ToolbarProc; <br>   wc.lpszClassName = ODBCTOOLCLASS; <br> <br>   if (!RegisterClass(&amp;wc)) { <br>      MessageBox(hWndFrame, CLASSERROR, EXECERROR, MB_OK|MB_ICONHAND|MB_TASKMODAL); <br>      return (FALSE); <br>   } <br> <br>   // register Statusbar Class <br> <br>   wc.lpfnWndProc = StatusbarProc; <br>   wc.lpszClassName = ODBCSTATUSCLASS; <br> <br>   if (!RegisterClass(&amp;wc)) { <br>      MessageBox(hWndFrame, CLASSERROR, EXECERROR, MB_OK|MB_ICONHAND|MB_TASKMODAL); <br>      return (FALSE); <br>   } <br> <br>   // register MDI Child Window Class <br> <br>   wc.hIcon = hMDIChildIcon = LoadIcon(hAppInstance, QUERYWINDOWICON); <br>   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>   wc.cbWndExtra = CBWNDEXTRA; <br>   wc.lpszClassName = ODBCMDICLASS; <br>   wc.lpfnWndProc = MDIChildProc; <br> <br>   if (!RegisterClass(&amp;wc)) { <br>      MessageBox(hWndFrame, CLASSERROR, EXECERROR, MB_OK|MB_ICONHAND|MB_TASKMODAL); <br>      return (FALSE); <br>   } <br> <br>   // create Main window and the MDI Client window <br> <br>   if (!(hWndFrame = CreateWindow(ODBCFRAMECLASS, APPTITLE, WS_OVERLAPPEDWINDOW, <br>                                  CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <br>                                  (HWND)NULL, (HMENU)NULL, hAppInstance, NULL))) { <br>      MessageBox(hWndFrame, CREATEMAINERR, EXECERROR, MB_OK|MB_ICONHAND|MB_TASKMODAL); <br>      return (FALSE); <br>   } <br> <br>   ShowWindow(hWndFrame, nCmdShow); <br>   UpdateWindow(hWndFrame); <br> <br>   // load accelerators <br> <br>   hAccel = LoadAccelerators(hAppInstance, APPACCELERATOR); <br> <br>   // acquire and dispatch messages until a WM_QUIT message is received <br> <br>   while (GetMessage(&amp;msg, (HWND)NULL, 0, 0)) { <br> <br>      // check for App accelerators <br> <br>      if (TranslateAccelerator(hWndFrame, hAccel, &amp;msg)) <br>         continue; <br> <br>      // check for MDI accelerators <br> <br>      if (TranslateMDISysAccel(hWndMDIClient, &amp;msg)) <br>         continue; <br> <br>      // each MDI Child has a modeless dialog in its client area <br>      // to provide tab controls. Check for Modeless Dialog msgs. <br> <br>      for (hWndMDIChild = GetWindow(hWndMDIClient, GW_CHILD); hWndMDIChild; hWndMDIChild = GetWindow(hWndMDIChild, GW_HWNDNEXT)) { <br>         GetClassName(hWndMDIChild, szBuffer, MAXBUFLEN); <br>         if (strcmp(szBuffer, ODBCMDICLASS)) <br>            continue; <br>         if (IsDialogMessage((HWND)GetWindowLong(hWndMDIChild, GWLAPP_HDLG), &amp;msg)) { <br>            bDialogMessage = TRUE; <br>            break; <br>         } <br>      } <br> <br>      if (bDialogMessage) { <br>         bDialogMessage = FALSE; <br>         continue; <br>      } <br> <br>      // if the message does not need special processing, dispatch it <br> <br>      TranslateMessage(&amp;msg); <br>      DispatchMessage(&amp;msg); <br>   } <br> <br>   // free memory used by ODBC Driver Manager interface <br> <br>   FreeSQLEnvironment(); <br> <br> <br>   // free Icon resources <br> <br>   if (hMainIcon) <br>      DestroyIcon(hMainIcon); <br> <br>   if (hMDIChildIcon) <br>      DestroyIcon(hMDIChildIcon); <br> <br>   return (msg.wParam); <br>} <br> <br>/* <br>    FUNCTION: MainWndProc(HWND hWnd, UINT   message, WPARAM wParam, LPARAM lParam) <br>    COMMENTS: Windows Callback procedure to handle Window messages. <br>              Menu Commands and System Command messages are handled by <br>              this main window. <br>*/ <br> <br>long CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch (message) { <br>      static int  iToolY;         //remember Toolbar height for resize <br>      static int  iStatusY;       //remember Statusbar height for resize <br> <br>     case WM_CREATE: <br>      { <br>         CLIENTCREATESTRUCT  ccs;        //MDIclient window structure <br>         HDC         hDC;        //Device Context handle <br>         SIZE            sizeBar;    //Size of a text bar <br>         RECT            rectCombo;      //Size of combo box <br> <br>         // Create child windows <br>         //1. combobox to display connections - DSN, SQLHDBC <br>         //2. combobox to display SQLHSTMT on current SQLHDBC <br>         //3. Toolbar to put toolbuttons <br>         //4. Statusbat to display current action, date and time <br>         //5. MDI Client Window to process MDI children <br> <br>         hWndCrsrList = CreateWindow(COMBOBOXCLASS, NULL, <br>                                     WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | <br>                                     WS_VSCROLL | CBS_DROPDOWNLIST | CBS_DISABLENOSCROLL, <br>                                     5, 2, 180, 150, hWnd, <br>                                     (HMENU)IDW_CRSRLIST, hAppInstance, NULL); <br> <br>         hWndStmtList = CreateWindow(COMBOBOXCLASS, NULL, <br>                                     WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | <br>                                     WS_VSCROLL | CBS_DROPDOWNLIST | CBS_DISABLENOSCROLL, <br>                                     190, 2, 150, 150, hWnd, <br>                                     (HMENU)IDW_STMTLIST, hAppInstance, NULL); <br> <br>         hWndToolbar = CreateWindow(ODBCTOOLCLASS, NULL, <br>                                    WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, <br>                                    0, 0, 0, 0, hWnd, (HMENU)IDW_TOOLBAR, hAppInstance, NULL); <br> <br>         hWndStatusbar = CreateWindow(ODBCSTATUSCLASS, NULL, <br>                                      WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, <br>                                      0, 0, 0, 0, hWnd, (HMENU)IDW_STATUSBAR, hAppInstance, NULL); <br> <br>         ccs.hWindowMenu = GetSubMenu(GetMenu(hWnd), WINDOWMENUPLACE); <br>         ccs.idFirstChild = IDM_MDICHILD; <br> <br>         hWndMDIClient = CreateWindow(MDICLIENTCLASS, NULL, <br>                                      WS_CHILD | WS_CLIPSIBLINGS | <br>                                      WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL | WS_VISIBLE, <br>                                      0, 0, 0, 0, hWnd, <br>                                      (HMENU)IDW_MDICLIENT, hAppInstance, (LPSTR)&amp;ccs); <br> <br>         // check to see if any of the above window creation failed <br> <br>         if (!hWndCrsrList || !hWndStmtList || !hWndToolbar || !hWndStatusbar || !hWndMDIClient) { <br>            MessageBox(hWnd, CREATEMAINERR, EXECERROR, MB_OK|MB_ICONHAND|MB_TASKMODAL); <br>            PostMessage(hWnd, WM_CLOSE, 0, 0); <br>            break; <br>         } <br>         // calculate proper text height for tool and status bars <br> <br>         GetWindowRect(hWndStmtList, &amp;rectCombo); <br>         iToolY = rectCombo.bottom - rectCombo.top + TOOLBARMARGINY; <br> <br>         if (hDC = GetDC(hWndStatusbar)) { <br>            GetTextExtentPoint(hDC, ALPHABETS, strlen(ALPHABETS), &amp;sizeBar); <br>            ReleaseDC(hWndStatusbar, hDC); <br>            iStatusY = sizeBar.cy + STATUSBARMARGINY; <br>         } <br>         else { <br>            iStatusY = 0; <br>            DestroyWindow(hWndStatusbar); <br>         } <br> <br>         break; <br>      } <br> <br>     case WM_GETMINMAXINFO: <br> <br>      // limit minimum size of the main window <br> <br>      ((MINMAXINFO FAR*)lParam)-&gt;ptMinTrackSize.x = <br>         max(MINWIDTH, rectStatusText.right-rectStatusText.left+iTimex+iDatex+14); <br>      ((MINMAXINFO FAR*)lParam)-&gt;ptMinTrackSize.y = MINHEIGHT; <br>      break; <br> <br>     case WM_SIZE: // resize children <br>      { <br>         WORD    wWidth = LOWORD(lParam);    //width of rectangle <br>         WORD    wHeight = HIWORD(lParam);   //height of rectangle <br> <br>         MoveWindow(hWndToolbar, 0, 0, wWidth, iToolY, TRUE); <br>         MoveWindow(hWndStatusbar, 0, wHeight-iStatusY, wWidth, iStatusY, TRUE); <br>         InvalidateRect(hWndStatusbar, NULL, TRUE); <br>         MoveWindow(hWndMDIClient, 0, iToolY, wWidth, wHeight-iStatusY-iToolY, TRUE); <br>         break; <br>      } <br> <br>     case WM_SYSCOLORCHANGE: // inform 3D controls of color change <br> <br>      //      Ctl3dColorChange(); <br>      break; <br> <br>     case WM_SYSCOMMAND: // close comboboxes if dropped down <br> <br>      SendMessage(hWndCrsrList, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0); <br>      SendMessage(hWndStmtList, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0); <br>      return (DefFrameProc(hWnd, hWndMDIClient, message, wParam, lParam)); <br> <br>     case WM_INITMENUPOPUP: // initialize popup menus <br>      { <br>         int iMenuId;    //Menu ID being processed <br>         int nItems;         //# of menu items <br>         int nPos;           //Menu Position <br> <br>         //ignore the msg if it is for a system menu <br> <br>         if (HIWORD(lParam)) <br>            break; <br> <br>         // Go through the menu items for current popup menu <br>         // and enable/disable menu item, if required <br> <br>         nItems = GetMenuItemCount((HMENU)wParam); <br>         for (nPos = 0; nPos &lt; nItems; nPos++) <br>            switch (iMenuId = GetMenuItemID((HMENU)wParam, nPos)) { <br>              case IDM_DISCONNECT: <br>              case IDM_NEW: <br> <br>               EnableMenuItem((HMENU)wParam, iMenuId, MF_BYCOMMAND| <br>                              ((SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0) &gt; 0) <br>                               ? MF_ENABLED <br>                               : MF_GRAYED)); <br>               break; <br> <br>              case IDM_QUERY: <br>              case IDM_TILE: <br>              case IDM_CASCADE: <br>              case IDM_ICONS: <br>              case IDM_CLOSEALL: <br> <br>               EnableMenuItem((HMENU)wParam, iMenuId, MF_BYCOMMAND| <br>                              (GetWindow(hWndMDIClient, GW_CHILD) <br>                               ? MF_ENABLED <br>                               : MF_GRAYED)); <br>               break; <br> <br>              default: <br> <br>               break; <br>            } <br>         break; <br>      } <br> <br>     case WM_MENUSELECT: // update status bar to reflect menu selection <br>      { <br>         int iMenuFlag;      //Check menu type <br>         HMENU   hMenu;              //Menu Handle <br>         char    szMenuName[MAXBUFLEN+1];//Menu Name <br> <br>         // store Menuitem ID as a state value for text display <br> <br>         wStatusText = GET_WM_MENUSELECT_CMD(wParam, lParam); <br> <br>         // process popup menus ie non menuitem selections <br> <br>         iMenuFlag = GET_WM_MENUSELECT_FLAGS(wParam, lParam); <br> <br>         // if the selected menu is a system popup menu <br> <br>         if (wStatusText &amp;&amp; (iMenuFlag &amp; MF_SYSMENU) &amp;&amp; (iMenuFlag &amp; MF_POPUP)) <br>            wStatusText = IDM_POPUPAPPSYS; <br> <br>         // else if the selected menu is a popup menu check menu names <br>         // OR check if it is a control popup menu of maximized MDI Child window <br> <br>         else if (wStatusText &amp;&amp; (iMenuFlag &amp; MF_POPUP)) { <br>            hMenu = (HMENU)wStatusText; <br>            GetMenuString(hMenu, 0, szMenuName, MAXBUFLEN, MF_BYPOSITION); <br>            if (!strcmp(szMenuName, MENUITEMCONNECT)) <br>               wStatusText = IDM_POPUPLOGIN; <br>            else if (!strcmp(szMenuName, MENUITEMQUERY)) <br>               wStatusText = IDM_POPUPQUERY; <br>            else if (!strcmp(szMenuName, MENUITEMTILE)) <br>               wStatusText = IDM_POPUPWINDOW; <br>            else if (!strcmp(szMenuName, MENUITEMAPPHELP)) <br>               wStatusText = IDM_POPUPHELP; <br>            else if (GetMenuString(hMenu, SC_NEXTWINDOW, szMenuName, MAXBUFLEN, MF_BYCOMMAND)&gt;0) <br>               wStatusText = IDM_POPUPMDISYS; <br>            else <br>               wStatusText = 0; <br>         } <br> <br>         // invalidate status bar for repaint <br> <br>         InvalidateRect(hWndStatusbar, &amp;rectStatusText, TRUE); <br>         break; <br>      } <br> <br>     case WM_COMMAND: // process menu commands <br> <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br> <br>        case IDM_CONNECT: // bring up connect dialog &amp; do connect processing <br> <br>         DialogBox(hAppInstance, CONNECTDIALOG, hWnd,ConnectDlgProc); <br>         break; <br> <br>        case IDM_DRIVERCONNECT: // let the driver do the dialogs <br> <br>         DriverConnectDatabase(hWnd); <br>         break; <br> <br>        case IDM_DISCONNECT: // bringup disconnect dlg and do disconnects <br> <br>         DialogBox(hAppInstance, DISCONNECTDIALOG, hWnd,DisconnectDlgProc); <br>         break; <br> <br>        case IDM_QUERY: // process execute query request <br> <br>         ExecuteQuery(); <br>         break; <br> <br>        case IDM_EXIT: // process exit request <br> <br>         SendMessage(hWndFrame, WM_CLOSE, 0, 0); <br>         break; <br> <br>        case IDM_NEW: // create a new query window on current connect <br> <br>         NewQueryWindow(); <br>         break; <br> <br>        case IDM_TILE: // let MDI Client tile the MDI children <br> <br>         SendMessage(hWndMDIClient, WM_MDITILE, 0, 0); <br>         break; <br> <br>        case IDM_CASCADE: // let MDI Client cascade MDI children <br> <br>         SendMessage(hWndMDIClient, WM_MDICASCADE, 0, 0); <br>         break; <br> <br>        case IDM_ICONS: // let MDI Client arrange iconic MDI children <br> <br>         SendMessage(hWndMDIClient, WM_MDIICONARRANGE, 0, 0); <br>         break; <br> <br>        case IDM_CLOSEALL: // Close all open windows and free hstmts <br>         { <br>            HWND    hWndTemp;   //temp window handle <br> <br>            // hide MDI Client Windows to avoid repaints <br> <br>            ShowWindow(hWndMDIClient,SW_HIDE); <br>            while (hWndTemp = GetWindow(hWndMDIClient, GW_CHILD)) <br>               SendMessage(hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndTemp, 0); <br>            ShowWindow(hWndMDIClient, SW_SHOW); <br>            break; <br>         } <br> <br>        case IDM_APPHELP: // bring up Samples Help file <br> <br>         WinHelp(hWnd, SAMPLESHELPFILE, HELP_KEY,(DWORD)(LPTSTR)szKeyWord); <br>break; <br> <br>        case IDM_ABOUT: // bringup About dialog <br> <br>         DialogBox(hAppInstance, ABOUTDIALOG, hWnd, AboutDlgProc); <br>         break; <br> <br>        case IDW_CRSRLIST: // change current cursor ? <br> <br>         if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE) <br>            ChangeCurrentCursor(GET_WM_COMMAND_HWND(wParam, lParam)); <br>         else if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_KILLFOCUS) <br>            PostMessage(GET_WM_COMMAND_HWND(wParam, lParam), CB_SHOWDROPDOWN, <br>                        (WPARAM)FALSE, 0); <br>         else <br>            DefFrameProc(hWnd, hWndMDIClient, WM_COMMAND, wParam, lParam); <br>         break; <br> <br>        case IDW_STMTLIST: // change current hstmt? <br> <br>         if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE) <br>            ChangeCurrentQuery(GET_WM_COMMAND_HWND(wParam, lParam)); <br>         else if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_KILLFOCUS) <br>            PostMessage(GET_WM_COMMAND_HWND(wParam, lParam), CB_SHOWDROPDOWN, <br>                        (WPARAM)FALSE, 0); <br>         else <br>            DefFrameProc(hWnd, hWndMDIClient, WM_COMMAND, wParam, lParam); <br>         break; <br> <br>        default: <br> <br>         DefFrameProc(hWnd, hWndMDIClient, WM_COMMAND, wParam, lParam); <br>         break; <br>      } <br>      break; <br> <br>     case WM_CLOSE: //close all MDI windows, hdbcs &amp; hstmts, else fail <br> <br>      return (CloseDatabases() <br>              ? DefFrameProc(hWnd, hWndMDIClient, message, wParam, lParam) <br>              : FALSE); <br> <br>     case WM_DESTROY: <br> <br>      // Close Help File if open <br> <br>      WinHelp(hWnd, SAMPLESHELPFILE, HELP_QUIT, 0); <br>      PostQuitMessage(0); <br>      break; <br> <br>     default: <br> <br>      return (DefFrameProc(hWnd, hWndMDIClient, message, wParam, lParam)); <br>   } <br>   return (0); <br>} <br> <br>/* <br>    FUNCTION: MDIChildProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>    COMMENTS: Window Procedure for MDI Child windows <br>*/ <br> <br>long CALLBACK MDIChildProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch (message) { <br>      HWND    hWndTemp;   //temporary window handle <br>      DLGPROC lpDlgProc;  //procedure address for modeless dialog <br> <br>     case WM_CREATE: <br> <br>      // create child windows <br>      // 1. Modeless Dialog box in the background to process tabs <br>      // 2. Static Text to display prompt <br>      // 3. Edit Control to type SQL text <br>      // 4. List Box to display results <br>      // store dialog handle for future reference <br>      // set focus to edit control <br> <br>      // if create failed due to low system resources <br> <br>      if (!hWnd) <br>         break; <br> <br>      hWndActiveChild = hWnd; <br>      hWndTemp = CreateDialog(hAppInstance, MDICHILDDIALOG, hWndActiveChild, MDIChildDlgProc); <br> <br>      // check to see if the dialog was created?, if not destroy this window <br> <br>      if (!hWndTemp) { <br>         return (-1); <br>      } <br> <br>      SetWindowLong(hWnd, GWLAPP_HDLG, (LONG)hWndTemp); <br>      SetFocus(GetDlgItem(hWndTemp, IDTEXT_SQL)); <br>      break; <br> <br>     case WM_SIZE: { <br>        WORD    wWidth;         //New Width of MDI Child <br>        WORD    wHeight;        //New Height of MDI Child <br>        HDC     hDC;            //Device Context <br>        char    szBuffer[MAXBUFLEN+1];  //Static Control Text <br>        int nStrLen;        //Buffer Length <br>        SIZE    size;           //Screen size for text display <br> <br>        // call default procedure first, to let MDI position the child &amp; then move its children <br> <br>        DefMDIChildProc(hWnd, message, wParam, lParam); <br> <br>        // move child windows with proper screen size for text display <br> <br>        wWidth = LOWORD(lParam); <br>        wHeight = HIWORD(lParam); <br>        hWndTemp = (HWND)GetWindowLong(hWnd, GWLAPP_HDLG); <br> <br>        nStrLen = GetWindowText(GetDlgItem(hWndTemp, IDTEXT_PRMPT), szBuffer, MAXBUFLEN); <br>        hDC = GetDC(hWnd); <br>        GetTextExtentPoint(hDC, szBuffer, nStrLen, &amp;size); <br>        ReleaseDC(hWnd, hDC); <br> <br>        MoveWindow(hWndTemp, 0, 0, wWidth, wHeight, TRUE); <br>        MoveWindow(GetDlgItem(hWndTemp, IDTEXT_PRMPT), 0, 0, size.cx+2, size.cy+2, TRUE); <br>        MoveWindow(GetDlgItem(hWndTemp, IDTEXT_SQL), size.cx+3, 0, wWidth - (size.cx+2), size.cy+2, TRUE); <br>        MoveWindow(GetDlgItem(hWndTemp, IDLIST_RSLT), 0, size.cy+3, wWidth, wHeight - (size.cy+2), TRUE); <br>        break; <br>     } <br> <br>     case WM_MENUSELECT: // update status bar to reflect menu selection <br>      { <br>         int iMenuFlag;      //Check menu type <br> <br>         // store the Menu Item Id as a state value for text display <br> <br>         wStatusText = GET_WM_MENUSELECT_CMD(wParam, lParam); <br> <br>         // if none of the menuitems was selected, check if <br>         // the control popup menu is selected. <br> <br>         iMenuFlag = GET_WM_MENUSELECT_FLAGS(wParam, lParam); <br> <br>         // if the selected menu is a system popup menu <br> <br>         if (wStatusText &amp;&amp; (iMenuFlag &amp; MF_SYSMENU) &amp;&amp; (iMenuFlag &amp; MF_POPUP)) <br>            wStatusText = IDM_POPUPMDISYS; <br> <br>         // invalidate status bar for repaint <br> <br>         InvalidateRect(hWndStatusbar, &amp;rectStatusText, TRUE); <br>         break; <br>      } <br> <br>     case WM_MDIACTIVATE: <br> <br>      // check if the display of comboboxes require a change <br> <br>      if (GET_WM_MDIACTIVATE_FACTIVATE(hWnd, wParam, lParam) &amp;&amp; <br>          (hWndActiveChild) &amp;&amp; (hWndActiveChild != hWnd)) { <br>         hWndActiveChild = hWnd; <br>         DisplayNewCrsrAndStmt(); <br>      } <br>      break; <br> <br>     case WM_MOUSEACTIVATE: <br> <br>      // current window has changed, update comboboxes. <br> <br>      hWndActiveChild = hWnd; <br>      DisplayNewCrsrAndStmt(); <br>      break; <br> <br>     case WM_SETFOCUS: <br> <br>      // pass on the focus to the edit box for user to type in SQL <br> <br>      SetFocus(GetDlgItem((HWND)GetWindowLong(hWnd, GWLAPP_HDLG), IDTEXT_SQL)); <br>      break; <br> <br>     case WM_DESTROY: <br> <br>      // check if the window was being destroyed while creation failed <br> <br>      if (!hWnd) <br>         break; <br> <br>      // close the window and free instance thunk for modeless dialog <br> <br>      CloseQueryWindow(hWnd); <br>      lpDlgProc = (DLGPROC)GetWindowLong((HWND)GetWindowLong(hWnd, GWLAPP_HDLG), DWL_DLGPROC); <br>      DestroyWindow((HWND)GetWindowLong(hWnd, GWLAPP_HDLG)); <br>      FreeProcInstance(lpDlgProc); <br>      if (hWnd == hWndActiveChild) <br>         hWndActiveChild = (HWND)NULL; <br>      break; <br> <br>     default: <br> <br>      return (DefMDIChildProc(hWnd, message, wParam, lParam)); <br>   } <br>   return (0); <br>} <br> <br>/* <br>    FUNCTION: ToolbarProc(HWND hWnd, UINT   message, WPARAM wParam, LPARAM lParam) <br>    COMMENTS: callback window procedure for toolbar window. <br>          Handle pain and mouse messages to paint the toolbar and <br>          provide default button behaviour for toolbar buttons. <br>*/ <br> <br>long CALLBACK ToolbarProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch (message) { <br>      static HBITMAP  hbmpNewQuery;           //btn1 bitmap handle <br>      static HBITMAP  hbmpRunQuery;           //btn2 bitmap handle <br>      static RECT stNewQuery;         //btn1 rectangle <br>      static RECT stRunQuery;                     //btn2 rectangle <br>      POINT       stMousePosition;        //current mouse pos <br>      BOOL        bButtonPosition;        //mouse pos flag <br>      static BOOL bNewQueryBtnDown = FALSE;   //was btn1 down before? <br>      static BOOL bRunQueryBtnDown = FALSE;   //was btn2 down before? <br>      static int  nLastButtonDown = 0;        //Which btn was down before? <br> <br>     case WM_CREATE: <br> <br>      // load bitmaps for buttons <br>      // initialize static rectangles for button positions on toolbar <br>      // initialize state variable for status text display <br> <br>      hbmpNewQuery = LoadBitmap(hAppInstance, BMP_NEWQUERY); <br>      hbmpRunQuery = LoadBitmap(hAppInstance, BMP_RUNQUERY); <br> <br>      stNewQuery.left   = BTTNX; <br>      stNewQuery.right  = BTTNX+BTTNWIDTH+1; <br>      stNewQuery.top    = BTTNY; <br>      stNewQuery.bottom = BTTNY+BTTNHEIGHT+1; <br> <br>      stRunQuery.left   = BTTNX+BTTNWIDTH+BTTNMARGIN; <br>      stRunQuery.right  = BTTNX+BTTNWIDTH+BTTNMARGIN+BTTNWIDTH+1; <br>      stRunQuery.top    = BTTNY; <br>      stRunQuery.bottom = BTTNY+BTTNHEIGHT+1; <br> <br>      wStatusText = 0; <br>      break; <br> <br>     case WM_DESTROY: <br> <br>      // delete bitmap handles <br> <br>      if (hbmpNewQuery) <br>         DeleteObject(hbmpNewQuery); <br>      if (hbmpRunQuery) <br>         DeleteObject(hbmpRunQuery); <br>      break; <br> <br>     case WM_LBUTTONDOWN: <br> <br>      // Check if the mouse key lies on any one of the buttons <br>      // if so, set state variable to reflect that button and <br>      // invalidate proper regions on tool &amp; status bars for update. <br>      // set capture on mouse movements till the mouse key is <br>      // released. <br> <br>      stMousePosition.x = LOWORD(lParam); <br>      stMousePosition.y = HIWORD(lParam); <br> <br>      if (PtInRect(&amp;stNewQuery, stMousePosition)) { <br>         bNewQueryBtnDown = TRUE; <br>         wStatusText = nLastButtonDown = IDM_NEW; <br>         SetCapture(hWnd); <br>         InvalidateRect(hWnd, &amp;stNewQuery, TRUE); <br>         InvalidateRect(hWndStatusbar, &amp;rectStatusText, TRUE); <br>      } <br>      else if (PtInRect(&amp;stRunQuery, stMousePosition)) { <br>         bRunQueryBtnDown = TRUE; <br>         wStatusText = nLastButtonDown = IDM_QUERY; <br>         SetCapture(hWnd); <br>         InvalidateRect(hWnd, &amp;stRunQuery, TRUE); <br>         InvalidateRect(hWndStatusbar, &amp;rectStatusText, TRUE); <br>      } <br>      break; <br> <br>     case WM_LBUTTONUP: <br> <br>      // check if the mouse movements from key down movements <br>      // were captured, if so process the key release state. <br>      // if the key was released in the same button where it <br>      // was pressed, it is equivalent to a button click. <br> <br>      if (hWnd != GetCapture()) <br>         break; <br> <br>      stMousePosition.x = LOWORD(lParam); <br>      stMousePosition.y = HIWORD(lParam); <br> <br>      if (bNewQueryBtnDown &amp;&amp; PtInRect(&amp;stNewQuery, stMousePosition)) { <br>         bNewQueryBtnDown = FALSE; <br>         nLastButtonDown = 0; <br>         InvalidateRect(hWnd, &amp;stNewQuery, TRUE); <br>         PostMessage(hWndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_NEW, 0, 0)); <br>         SendMessage(hWndCrsrList, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0); <br>         SendMessage(hWndStmtList, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0); <br>      } <br>      else if (bRunQueryBtnDown &amp;&amp; PtInRect(&amp;stRunQuery, stMousePosition)) { <br>         bRunQueryBtnDown = FALSE; <br>         nLastButtonDown = 0; <br>         InvalidateRect(hWnd, &amp;stRunQuery, TRUE); <br>         PostMessage(hWndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_QUERY, 0, 0)); <br>         SendMessage(hWndCrsrList, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0); <br>         SendMessage(hWndStmtList, CB_SHOWDROPDOWN, (WPARAM)FALSE, 0); <br>      } <br> <br>      ReleaseCapture(); <br>      wStatusText = 0; <br>      InvalidateRect(hWndStatusbar, &amp;rectStatusText, TRUE); <br>      break; <br> <br>     case WM_MOUSEMOVE: <br> <br>      // process mouse movement only if the mouse key was pressed <br>      // down and its movements were being captured. If the mouse <br>      // moves outside of the currently depressed button, it needs <br>      // to be drawn again with normal state. <br> <br>      if (hWnd != GetCapture()) <br>         break; <br> <br>      stMousePosition.x = LOWORD(lParam); <br>      stMousePosition.y = HIWORD(lParam); <br> <br>      if (nLastButtonDown == IDM_NEW) { <br>         bButtonPosition = PtInRect(&amp;stNewQuery, stMousePosition); <br>         if (bNewQueryBtnDown != bButtonPosition) { <br>            bNewQueryBtnDown = bButtonPosition; <br>            InvalidateRect(hWnd, &amp;stNewQuery, TRUE); <br>         } <br>      } <br>      else if (nLastButtonDown == IDM_QUERY) { <br>         bButtonPosition = PtInRect(&amp;stRunQuery, stMousePosition); <br>         if (bRunQueryBtnDown != bButtonPosition) { <br>            bRunQueryBtnDown = bButtonPosition; <br>            InvalidateRect(hWnd, &amp;stRunQuery, TRUE); <br>         } <br>      } <br>      break; <br> <br>     case WM_PAINT: <br>      { <br>         PAINTSTRUCT ps;     //paint structure <br>         RECT        rect;       //rectangle for tool bar <br>         HDC     hDC;        //device context handle <br>         int     iWidth;     //tool bar width <br>         int     iHeight;    //tool bar height <br>         HPEN        hLtGrayPen; //buttonface color pen <br>         HPEN        hGrayPen;   //buttonshadow color pen <br>         int     btnx;       //button x coordinate position <br> <br>         if (!(hDC = BeginPaint(hWnd, &amp;ps))) <br>            break; <br> <br>         GetClientRect(hWnd, &amp;rect); <br>         iWidth = rect.right; <br>         iHeight = rect.bottom; <br> <br>         hLtGrayPen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNFACE)); <br>         hGrayPen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW)); <br> <br>         // draw background and border <br> <br>         SelectObject(hDC, GetStockObject(LTGRAY_BRUSH)); <br>         SelectObject(hDC, hLtGrayPen); <br>         Rectangle(hDC, 0, 0, iWidth, iHeight); <br> <br>         SelectObject(hDC, GetStockObject(BLACK_PEN)); <br>         MoveToEx(hDC, 0, iHeight-1, NULL); <br>         LineTo(hDC, iWidth, iHeight-1); <br> <br>         SelectObject(hDC, GetStockObject(WHITE_PEN)); <br>         MoveToEx(hDC, 0, 0, NULL); <br>         LineTo(hDC, iWidth, 0); <br> <br>         // draw tool bar buttons (new query, run query) </code></pre>
<p>
</p>
<pre><code>// check state variables to draw proper button state <br> <br>         btnx = BTTNX; <br>         SelectObject(hDC, GetStockObject(BLACK_PEN)); <br>         DRAWBTTNRECT(hDC, btnx, BTTNY, BTTNWIDTH, BTTNHEIGHT); <br>         DrawBitmap(hDC, (bNewQueryBtnDown?btnx+3:btnx+2), (bNewQueryBtnDown?BTTNY+3:BTTNY+2), hbmpNewQuery); <br>         SelectObject(hDC, (bNewQueryBtnDown ? hGrayPen : GetStockObject(WHITE_PEN))); <br>         DRAWBTTNLIFT1(hDC, btnx, BTTNY, BTTNWIDTH, BTTNHEIGHT); <br>         SelectObject(hDC, (bNewQueryBtnDown ? hLtGrayPen : hGrayPen)); <br>         DRAWBTTNLIFT2(hDC, btnx, BTTNY, BTTNWIDTH, BTTNHEIGHT); <br> <br>         btnx += BTTNWIDTH+BTTNMARGIN; <br>         SelectObject(hDC, GetStockObject(BLACK_PEN)); <br>         DRAWBTTNRECT(hDC, btnx, BTTNY, BTTNWIDTH, BTTNHEIGHT); <br>         DrawBitmap(hDC, (bRunQueryBtnDown?btnx+3:btnx+2), (bRunQueryBtnDown?BTTNY+3:BTTNY+2), hbmpRunQuery); <br>         SelectObject(hDC, (bRunQueryBtnDown ? hGrayPen : GetStockObject(WHITE_PEN))); <br>         DRAWBTTNLIFT1(hDC, btnx, BTTNY, BTTNWIDTH, BTTNHEIGHT); <br>         SelectObject(hDC, (bRunQueryBtnDown ? hLtGrayPen : hGrayPen)); <br>         DRAWBTTNLIFT2(hDC, btnx, BTTNY, BTTNWIDTH, BTTNHEIGHT); <br> <br>         SelectObject(hDC, GetStockObject(WHITE_PEN)); <br>         EndPaint(hWnd, &amp;ps); <br> <br>         // delete create objects <br> <br>         if (hLtGrayPen) <br>            DeleteObject(hLtGrayPen); <br>         if (hGrayPen) <br>            DeleteObject(hGrayPen); <br>         break; <br>      } <br> <br>     default: <br> <br>      return (DefWindowProc(hWnd, message, wParam, lParam)); <br>   } <br>   return (0); <br>} <br> <br>/* <br>    FUNCTION: StatusbarProc(HWND hWnd, UINT   message, WPARAM wParam, LPARAM lParam) <br>    COMMENTS: callback window procedure for status bar. <br>          process paint messages and timer messages to update current <br>          state, date and time <br>*/ <br> <br>long CALLBACK StatusbarProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch (message) { <br>      static RECT DateTimeRect; // remember for frequent updates <br> <br>     case WM_CREATE: <br>      { <br>         HDC hDC;        // device context <br>         SIZE    sizeText;       // size of status text box <br>         SIZE    sizeTime;       // size of time display box <br>         SIZE    sizeDate;       // size of date display box <br> <br>         // start a timer for periodic updates to date and time display <br>         // find out width of status text, date and time display boxes <br> <br>         SetTimer(hWnd,  (UINT)IDT_STATUSTIMER, (UINT)TIMERDELAY, NULL); <br> <br>         iTimex = iDatex = 0; <br>         rectStatusText.left = 2; <br>         rectStatusText.top = 3; <br> <br>         if (hDC = GetDC(hWnd)) { <br>            GetTextExtentPoint(hDC, STATUSNEW, strlen(STATUSNEW), &amp;sizeText); <br>            GetTextExtentPoint(hDC, TIMETEXT, strlen(TIMETEXT), &amp;sizeTime); <br>            GetTextExtentPoint(hDC, DATETEXT, strlen(DATETEXT), &amp;sizeDate); <br>            ReleaseDC(hWnd, hDC); <br>            rectStatusText.right = sizeText.cx + rectStatusText.left; <br>            iTimex = sizeTime.cx; <br>            iDatex = sizeDate.cx; <br>         } <br>         break; <br>      } <br> <br>     case WM_TIMER: <br> <br>      // invalidate only the date&amp;time area for update <br> <br>      InvalidateRect(hWnd, &amp;DateTimeRect, TRUE); <br>      break; <br> <br>     case WM_PAINT: <br>      { <br>         HDC     hDC;            //device context <br>         PAINTSTRUCT ps;         //paint structure <br>         RECT        rect;                   //status bar rect <br>         int     iWidth;                 //status bar width <br>         int     iHeight;                //status bar height <br>         HPEN        hLtGrayPen;             //btnface color pen <br>         HPEN        hGrayPen;               //btnshadow color pen <br>         char        szText[MAXBUFLEN];      //text buffer for display <br>         time_t      tCurrentTime;           //current date&amp;time <br>         struct tm   stTime;                 //date&amp;time structure <br> <br>         if (!(hDC = BeginPaint(hWnd, &amp;ps))) <br>            break; <br> <br>         GetClientRect(hWnd, &amp;rect); <br>         iWidth = rect.right; <br>         iHeight = rect.bottom; <br>         rectStatusText.bottom = iHeight-2; <br> <br>         hLtGrayPen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNFACE)); <br>         hGrayPen = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW)); <br> <br>         // paint background and border <br> <br>         SelectObject(hDC, GetStockObject(LTGRAY_BRUSH)); <br>         SelectObject(hDC, hLtGrayPen); <br>         Rectangle(hDC, 0, 0, iWidth, iHeight); <br> <br>         SelectObject(hDC, GetStockObject(BLACK_PEN)); <br>         MoveToEx(hDC, 0, 0, NULL); <br>         LineTo(hDC, iWidth, 0); <br>         SelectObject(hDC, GetStockObject(WHITE_PEN)); <br>         MoveToEx(hDC, 0, 1, NULL); <br>         LineTo(hDC, iWidth, 1); <br> <br>         // draw text boxes for status, time and date display <br> <br>         SelectObject(hDC, hGrayPen); <br>         MoveToEx(hDC, rectStatusText.left, rectStatusText.bottom, NULL); <br>         LineTo(hDC, rectStatusText.left, rectStatusText.top); <br>         LineTo(hDC, rectStatusText.right, rectStatusText.top); <br>         SelectObject(hDC, GetStockObject(WHITE_PEN)); <br>         LineTo(hDC, rectStatusText.right, rectStatusText.bottom); <br>         LineTo(hDC, rectStatusText.left, rectStatusText.bottom); <br> <br>         SelectObject(hDC, hGrayPen); <br>         MoveToEx(hDC, iWidth-2, 3, NULL); <br>         LineTo(hDC, iWidth-iDatex-2, 3); <br>         LineTo(hDC, iWidth-iDatex-2, iHeight-2); <br>         SelectObject(hDC, GetStockObject(WHITE_PEN)); <br>         LineTo(hDC, iWidth-2, iHeight-2); <br>         LineTo(hDC, iWidth-2, 3); <br> <br>         SelectObject(hDC, hGrayPen); <br>         MoveToEx(hDC, iWidth-iDatex-6, 3, NULL); <br>         LineTo(hDC, iWidth-iTimex-iDatex-6, 3); <br>         LineTo(hDC, iWidth-iTimex-iDatex-6, iHeight-2); <br>         SelectObject(hDC, GetStockObject(WHITE_PEN)); <br>         LineTo(hDC, iWidth-iDatex-6, iHeight-2); <br>         LineTo(hDC, iWidth-iDatex-6, 3); <br> <br>         // draw status text in the display box based on current <br>         // value of wStatusText global flag <br> <br>         SetBkMode(hDC, TRANSPARENT); <br>         SetTextColor(hDC, GetSysColor(COLOR_BTNTEXT)); <br> <br>         switch (wStatusText) { <br>           case IDM_POPUPAPPSYS: <br> <br>            strcpy(szText, STATUSPOPUPAPPSYS); <br>            break; <br> <br>           case IDM_POPUPMDISYS: <br> <br>            strcpy(szText, STATUSPOPUPMDISYS); <br>            break; <br> <br>           case SC_RESTORE: <br> <br>            strcpy(szText, STATUSRESTORE); <br>            break; <br> <br>           case SC_MOVE: <br> <br>            strcpy(szText, STATUSMOVE); <br>            break; <br> <br>           case SC_SIZE: <br> <br>            strcpy(szText, STATUSSIZE); <br>            break; <br> <br>           case SC_MINIMIZE: <br> <br>            strcpy(szText, STATUSMINIMIZE); <br>            break; <br> <br>           case SC_MAXIMIZE: <br> <br>            strcpy(szText, STATUSMAXIMIZE); <br>            break; <br> <br>           case SC_CLOSE: <br> <br>            strcpy(szText, STATUSCLOSE); <br>            break; <br> <br>           case SC_NEXTWINDOW: <br> <br>            strcpy(szText, STATUSNEXTWINDOW); <br>            break; <br> <br>           case SC_PREVWINDOW: <br> <br>            strcpy(szText, STATUSPREVWINDOW); <br>            break; <br> <br>           case SC_TASKLIST: <br> <br>            strcpy(szText, STATUSTASKLIST); <br>            break; <br> <br>           case IDM_POPUPLOGIN: <br> <br>            strcpy(szText, STATUSPOPUPLOGIN); <br>            break; <br> <br>           case IDM_CONNECT: <br> <br>            strcpy(szText, STATUSCONNECT); <br>            break; <br> <br>           case IDM_DRIVERCONNECT: <br> <br>            strcpy(szText, STATUSDRIVERCONNECT); <br>            break; <br> <br>           case IDM_DISCONNECT: <br> <br>            strcpy(szText, STATUSDISCONNECT); <br>            break; <br> <br>           case IDM_EXIT: <br> <br>            strcpy(szText, STATUSEXIT); <br>            break; <br> <br>           case IDM_POPUPQUERY: <br> <br>            strcpy(szText, STATUSPOPUPQUERY); <br>            break; <br> <br>           case IDM_QUERY: <br> <br>            strcpy(szText, STATUSQUERY); <br>            break; <br> <br>           case IDM_NEW: <br> <br>            strcpy(szText, STATUSNEW); <br>            break; <br> <br>           case IDM_POPUPWINDOW: <br> <br>            strcpy(szText, STATUSPOPUPWINDOW); <br>            break; <br> <br>           case IDM_TILE: <br> <br>            strcpy(szText, STATUSTILE); <br>            break; <br> <br>           case IDM_CASCADE: <br> <br>            strcpy(szText, STATUSCASCADE); <br>            break; <br> <br>           case IDM_ICONS: <br> <br>            strcpy(szText, STATUSICONS); <br>            break; <br> <br>           case IDM_CLOSEALL: <br> <br>            strcpy(szText, STATUSCLOSEALL); <br>            break; <br> <br>           case IDM_POPUPHELP: <br> <br>            strcpy(szText, STATUSPOPUPHELP); <br>            break; <br> <br>           case IDM_APPHELP: <br> <br>            strcpy(szText, STATUSAPPHELP); <br>            break; <br> <br>           case IDM_ABOUT: <br> <br>            strcpy(szText, STATUSABOUT); <br>            break; <br> <br>           default: <br> <br>            if (wStatusText &gt;= IDM_MDICHILD) <br>               sprintf(szText, STATUSMDICHILD, wStatusText-IDM_MDICHILD+1); <br>            else <br>               strcpy(szText, STATUSDEFAULT); <br>            break; <br>         } <br> <br>         DrawText(hDC, szText, strlen(szText), &amp;rectStatusText, DT_LEFT); <br> <br>         // get current date and time and display time in time box <br> <br>         time(&amp;tCurrentTime); <br>         stTime = *localtime(&amp;tCurrentTime); <br>         strftime(szText, MAXBUFLEN, TIMEFORMAT, &amp;stTime); <br>         rect.top = rectStatusText.top; <br>         rect.bottom = rectStatusText.bottom; <br>         rect.left  = iWidth-iTimex-iDatex-6; <br>         rect.right = iWidth-iDatex-6; <br>         DrawText(hDC, szText, strlen(szText), &amp;rect, DT_LEFT); <br> <br>         // display date in date box <br> <br>         strftime(szText, MAXBUFLEN, DATEFORMAT, &amp;stTime); <br>         rect.left  = iWidth-iDatex-2; <br>         rect.right = iWidth-2; <br>         DrawText(hDC, szText, strlen(szText), &amp;rect, DT_LEFT); <br> <br>         // remember the date&amp;time rectangle to minimize painting <br> <br>         DateTimeRect.left   = iWidth-iTimex-iDatex-6; <br>         DateTimeRect.right  = iWidth-2; <br>         DateTimeRect.top    = rect.top; <br>         DateTimeRect.bottom = rect.bottom; <br> <br>         EndPaint(hWnd, &amp;ps); <br> <br>         // delete created objects <br> <br>         if (hLtGrayPen) <br>            DeleteObject(hLtGrayPen); <br>         if (hGrayPen) <br>            DeleteObject(hGrayPen); <br>         break; <br>      } <br> <br>     default: <br> <br>      return (DefWindowProc(hWnd, message, wParam, lParam)); <br>      break; <br>   } <br>   return (0); <br>} <br> <br>/* <br>    FUNCTION: ConnectDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>    COMMENTS: Callback dialog box procedure for connect menu command <br>          displays a list of available data sources, asks for user <br>          name and password to pass default connection parameters <br>          for a data source connection <br>*/ <br> <br>BOOL CALLBACK ConnectDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch (message) { <br>      HCURSOR hOldCursor; // Default Cursor Shape <br> <br>     case WM_INITDIALOG: <br> <br>      // display list of available data sources <br> <br>      hOldCursor = SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT)); <br>      DisplayDatabases(GetDlgItem(hWnd, IDCOMBO_DATASOURCE)); <br>      SetCursor(hOldCursor); <br>      break; <br> <br>     case WM_COMMAND: <br> <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: // make a connection using the supplied values <br> <br>         hOldCursor = SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT)); <br> <br>         // check if a DSN was provided for connection <br> <br>         if (SendDlgItemMessage(hWnd, IDCOMBO_DATASOURCE, WM_GETTEXTLENGTH, 0, 0)) <br>            EndDialog(hWnd, ConnectDatabase(hWnd)); <br>         else <br>            MessageBox(hWnd, NODSNERR, MOREINFO, MB_OK|MB_ICONHAND); <br> <br>         SetCursor(hOldCursor); <br>         break; <br> <br>        case IDCANCEL: <br> <br>         EndDialog(hWnd, FALSE); <br>         break; <br> <br>        default: <br> <br>         return (FALSE); <br>         break; <br>      } <br>      break; <br> <br>     default: <br> <br>      return (FALSE); <br>      break; <br>   } <br>   return (TRUE); <br>} <br> <br>/* <br>    FUNCTION: DisconnectDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>    COMMENTS: Callback dialog box procedure for disconnect dialog. <br>          provides a list of available SQLHDBCs and a list of SQLHSTMTs <br>          for currently selected SQLHDBC. Allows closure of all SQLHDBCs <br>          and SQLHSTMTs one by one or in groups. <br>*/ <br> <br>BOOL CALLBACK DisconnectDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch (message) { <br>      static HWND hListhdbc;  //listbox that displays hdbc(s) <br>      static HWND hListstmt;      //listbox that displays hstmt(s) <br>      static HWND hPushOk;        //pushbutton to free hdbc <br>      static HWND hPushClose;     //pushbutton to free hstmt <br>      static HWND hPushCancel;    //pushbutton to close dialog <br> <br>     case WM_INITDIALOG: <br> <br>      // store handles for future reference <br> <br>      hListhdbc = GetDlgItem(hWnd, IDLIST_HDBC); <br>      hListstmt = GetDlgItem(hWnd, IDLIST_STMT); <br>      hPushOk = GetDlgItem(hWnd, IDDISCONNECT); <br>      hPushCancel = GetDlgItem(hWnd, IDCANCEL); <br>      hPushClose = GetDlgItem(hWnd, IDCLOSE_ACTVTY); <br> <br>      // display connected database handles and statements <br> <br>      DisplayConnections(hListhdbc); <br>      DisplayQueries(hListstmt, hListhdbc, 0); <br> <br>      // enable or disable pushbuttons &amp; listboxes to match available hdbc &amp; hstmt <br> <br>      if (SendMessage(hListhdbc, LB_GETCOUNT, 0, 0)&gt;0) { <br>         EnableWindow(hPushOk, TRUE); <br>         if (SendMessage(hListstmt, LB_GETCOUNT, 0, 0)&gt;0) { <br>            EnableWindow(hPushClose, TRUE); <br>            SetFocus(hPushClose); <br>            SendMessage(hPushClose, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE); <br>         } <br>         else { <br>            EnableWindow(hListstmt, FALSE); <br>            EnableWindow(hPushClose, FALSE); <br>            SetFocus(hPushOk); <br>            SendMessage(hPushOk, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE); <br>         } <br>      } <br>      else { <br>         EnableWindow(hListhdbc, FALSE); <br>         EnableWindow(hListstmt, FALSE); <br>         EnableWindow(hPushOk, FALSE); <br>         SetFocus(hPushCancel); <br>         SendMessage(hPushCancel, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE); <br>      } <br> <br>      // return FALSE to prevent default focus. <br> <br>      return (FALSE); <br> <br>     case WM_COMMAND: <br> <br>      switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDDISCONNECT: <br> <br>         // Free current hdbc, display available hdbc(s) <br> <br>         FreeConnect(hListhdbc); <br>         SendMessage(hListstmt, LB_RESETCONTENT, 0, 0); <br>         DisplayConnections(hListhdbc); <br> <br>         // update displayed hstmt(s) for current hdbc <br>         // enable or disable pushbuttons to match available <br>         // hdbc(s) and hstmt(s) for closure <br> <br>         if (SendMessage(hListhdbc, LB_GETCOUNT, 0, 0) &gt; 0) { <br>            SendMessage(hListhdbc, LB_SETCURSEL, 0, 0); <br>            EnableWindow(hListstmt, TRUE); <br>            DisplayQueries(hListstmt, hListhdbc, 0); <br>            if (SendMessage(hListstmt, LB_GETCOUNT, 0, 0)&gt;0) { <br>               EnableWindow(hPushClose, TRUE); <br>               SetFocus(hPushClose); <br>               SendMessage(hPushClose, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE); <br>            } <br>            else { <br>               EnableWindow(hListstmt, FALSE); <br>               EnableWindow(hPushClose, FALSE); <br>               SetFocus(hPushOk); <br>               SendMessage(hPushOk, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE); <br>            } <br>         } <br>         else { <br>            EnableWindow(hListhdbc, FALSE); <br>            EnableWindow(hPushOk, FALSE); <br>            EnableWindow(hPushClose, FALSE); <br>            SetFocus(hPushCancel); <br>            SendMessage(hPushCancel, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE); <br>         } <br>         break; <br> <br>        case IDCANCEL: <br> <br>         // close dialog <br> <br>         EndDialog(hWnd, FALSE); <br>         break; <br> <br>        case IDCLOSE_ACTVTY: <br>         { <br>            int nIndex; // counter to search for selected hstmt(s) <br> <br>            // go through all displayed hstmt(s) and free all highlighted ones <br> <br>            for (nIndex = (int)SendMessage(hListstmt, LB_GETCOUNT, 0, 0)-1; <br>                 nIndex &gt;= 0; nIndex--) <br>               if (SendMessage(hListstmt, LB_GETSEL, nIndex, 0)) <br>                  FreeQuery(hListstmt, hListhdbc, nIndex); <br> <br>            // reset both hdbc(s) and hstmt(s) display <br> <br>            nIndex = (int)SendMessage(hListhdbc, LB_GETCURSEL, 0, 0); <br>            DisplayConnections(hListhdbc); <br>            SendMessage(hListhdbc, LB_SETCURSEL, nIndex, 0); <br>            DisplayQueries(hListstmt, hListhdbc, nIndex); <br> <br>            // enable or disable pushbuttons to match available <br>            // hdbc(s) and hstmt(s) for closure <br> <br>            if (SendMessage(hListstmt, LB_GETCOUNT, 0, 0)&gt;0) { <br>               EnableWindow(hPushClose, TRUE); <br>               SetFocus(hPushClose); <br>               SendMessage(hPushClose, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE); <br>            } <br>            else { <br>               EnableWindow(hListstmt, FALSE); <br>               EnableWindow(hPushClose, FALSE); <br>               SetFocus(hPushOk); <br>               SendMessage(hPushOk, BM_SETSTYLE, (WPARAM)BS_DEFPUSHBUTTON, TRUE); <br>            } <br>            break; <br>         } <br> <br>        case IDLIST_HDBC: <br> <br>         // If the current selection in hdbc(s) has changed <br>         // update the list of hstmt(s) to match the new hdbc <br> <br>         if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE) <br>            DisplayQueries(hListstmt, hListhdbc, <br>                           (UINT)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETCURSEL, 0, 0)); <br> <br>         // Enable or disable hstmt listbox and close pushbutton accordingly <br> <br>         EnableWindow(hListstmt, (SendMessage(hListstmt, LB_GETCOUNT, 0, 0)&gt;0)); <br>         EnableWindow(hPushClose, (SendMessage(hListstmt, LB_GETCOUNT, 0, 0)&gt;0)); <br>         break; <br> <br>        default: <br> <br>         return (FALSE); <br>      } <br>      break; <br> <br>     default: <br> <br>      return (FALSE); <br>   } <br> <br>   return (TRUE); <br>} <br> <br>/* <br>    FUNCTION: AboutDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>    COMMENTS: Callback dialog box procedure for About dialog box <br>          displays the about information and closes upon selection of <br>          ok button <br>*/ <br> <br>BOOL CALLBACK AboutDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   if (message == WM_COMMAND) { <br>      EndDialog(hWnd, TRUE); <br>      return (TRUE); <br>   } <br>   else <br>      return (FALSE); <br>} <br> <br>/* <br>    FUNCTION: MDIChildDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>    COMMENTS: Callback dialog box procedure for modeless child dialog box <br>          in each MDI Child Window. This dialog box simply processes <br>          the tab messages (by default) to allow switching from edit <br>          control (SQL Text) to list box control (Query results). <br>*/ <br> <br>BOOL CALLBACK MDIChildDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>   return (FALSE); <br>} <br> <br>/* <br>    FUNCTION: DrawBitmap(HDC hDC, int iLeft, int iTop, HBITMAP hBitmap <br>    COMMENTS: Draws a bitmap on given Device context with given bitmap <br>          handle at given location <br>*/ <br> <br>VOID FAR PASCAL DrawBitmap(HDC hDC, int iLeft, int iTop, HBITMAP hBitmap) <br>{ <br>   HDC hMemDC;     // Device Context in Memory <br>   POINT   stPoint;        // point structure for conversion from device to logical units <br>   BITMAP  stBitmap; <br>   HGDIOBJ hObject; <br> <br>   // create a compatible device context in memory and select the bitmap <br>   // in to it. <br> <br>   if (!(hMemDC = CreateCompatibleDC(hDC))) return; <br> <br>   hObject = SelectObject(hMemDC, hBitmap); <br>   SetMapMode(hMemDC, GetMapMode(hDC)); <br> <br>   // Get bitmap size and convert it to logical units from device units. <br> <br>   GetObject(hBitmap, sizeof(BITMAP), &amp;stBitmap); <br>   stPoint.x = stBitmap.bmWidth; <br>   stPoint.y = stBitmap.bmHeight; <br>   DPtoLP(hDC, &amp;stPoint, 1); <br> <br>   // bit block transfer the bitmap from memory device context to given <br>   // device context at specified location <br> <br>   BitBlt(hDC, iLeft, iTop, stPoint.x, stPoint.y, hMemDC, 0, 0, SRCCOPY); <br> <br>   // select original object in the memory device context and destroy it <br> <br>   SelectObject(hMemDC, hObject); <br>   DeleteDC(hMemDC); <br>} <br> <br>/********************************************* END OF FILE **************************************************/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
