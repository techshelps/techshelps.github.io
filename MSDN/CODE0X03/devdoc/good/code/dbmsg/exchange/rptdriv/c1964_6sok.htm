<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REPORT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1964"></a>REPORT.C</h2>
<pre><code>// --report.c------------------------------------------------------------------- <br>//  <br>//  Module containing report functions. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>//$--REPORT_T------------------------------------------------------------------- <br>//  Report type. <br>// ----------------------------------------------------------------------------- <br>typedef enum __REPORT_T <br>{ <br>    NDR = 0,        // non-delivery report <br>    DR,             // delivery report <br>    RN,             // read notification report <br>    NRN,            // non-read notification report <br>    REPORT_LAST     // all report values are less than this  <br>} REPORT_T; <br> <br>#define VALID_REPORT_T(x) (((x) &gt;= ((ULONG)0)) &amp;&amp; \ <br>                            ((x) &lt;= ((ULONG)REPORT_LAST))) <br> <br>#include "report.chk" <br> <br>//$--HrEDKReportSubject--------------------------------------------------------- <br>//  Return a report subject. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKReportSubject(          // RETURNS: return code <br>    IN REPORT_T ReportType,                 // report type <br>    IN LPTSTR lpszSubject,                  // pointer to subject <br>    OUT LPTSTR *lppszReportSubject)         // pointer to report subject <br>{ <br>    HRESULT hr                  = NOERROR; <br>    ULONG   cch                 = 0; <br>    LPTSTR  lpszOrigSubject     = NULL; <br>    LPTSTR  lpszReportPrefix    = NULL; <br>    SCODE   sc                  = 0; <br>    ULONG   cBytes              = 0; <br> <br>    DEBUGPRIVATE("HrEDKReportSubject()\n"); <br> <br>    hr = CHK_HrEDKReportSubject( <br>        ReportType, <br>        lpszSubject, <br>        lppszReportSubject); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppszReportSubject = NULL; <br> <br>    cch = 0; <br> <br>    if(lpszSubject != NULL) <br>    { <br>        cch = lstrlen(lpszSubject); <br>    } <br> <br>    if(cch == 0) <br>    { <br>        lpszOrigSubject = TEXT(""); <br>    } <br>    else <br>    { <br>        lpszOrigSubject = lpszSubject; <br>    } <br> <br>    switch(ReportType) <br>    { <br>    case NDR: <br>        lpszReportPrefix = TEXT("Undeliverable: "); <br>        break; <br>    case DR: <br>        lpszReportPrefix = TEXT("Delivered: "); <br>        break; <br>    case RN: <br>        lpszReportPrefix = TEXT("Read: "); <br>        break; <br>    case NRN: <br>        lpszReportPrefix = TEXT("Unread: "); <br>        break; <br>    default: <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cch += lstrlen(lpszReportPrefix); <br> <br>    cch++;  // terminating NULL character <br> <br>    cBytes = cch * sizeof(TCHAR); <br> <br>    sc = MAPIAllocateBuffer(cBytes, lppszReportSubject); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    _tcscpy(*lppszReportSubject, lpszReportPrefix); <br>    _tcscat(*lppszReportSubject, lpszOrigSubject); <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppszReportSubject); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKReportMessageClass---------------------------------------------------- <br>//  Return a report message class. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKReportMessageClass(     // RETURNS: return code <br>    IN REPORT_T ReportType,                 // report type <br>    IN LPTSTR lpszMessageClass,             // pointer to message class <br>    OUT LPTSTR *lppszReportMessageClass)    // pointer to report message class <br>{ <br>    HRESULT hr                  = NOERROR; <br>    ULONG   cch                 = 0; <br>    LPTSTR  lpszMsgClass        = NULL; <br>    LPTSTR  lpszReportSuffix    = NULL; <br>    SCODE   sc                  = 0; <br>    ULONG   cBytes              = 0; <br> <br>    DEBUGPRIVATE("HrEDKReportMessageClass()\n"); <br> <br>    hr = CHK_HrEDKReportMessageClass( <br>        ReportType, <br>        lpszMessageClass, <br>        lppszReportMessageClass); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppszReportMessageClass = NULL; <br> <br>    cch = lstrlen(lpszMessageClass); <br> <br>    if(cch == 0) <br>    { <br>        lpszMsgClass = TEXT("IPM.NOTE"); <br>        cch = lstrlen(lpszMsgClass); <br>    } <br>    else <br>    { <br>        lpszMsgClass = lpszMessageClass; <br>    } <br> <br>    cch += lstrlen(TEXT("REPORT.")); <br> <br>    switch(ReportType) <br>    { <br>    case NDR: <br>        lpszReportSuffix = TEXT(".NDR"); <br>        break; <br>    case DR: <br>        lpszReportSuffix = TEXT(".DR"); <br>        break; <br>    case RN: <br>        lpszReportSuffix = TEXT(".IPNRN"); <br>        break; <br>    case NRN: <br>        lpszReportSuffix = TEXT(".IPNNRN"); <br>        break; <br>    default: <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cch += lstrlen(lpszReportSuffix); <br> <br>    cch++;  // terminating NULL character <br> <br>    cBytes = cch * sizeof(TCHAR); <br> <br>    sc = MAPIAllocateBuffer(cBytes, lppszReportMessageClass); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    _tcscpy(*lppszReportMessageClass, TEXT("REPORT.")); <br>    _tcscat(*lppszReportMessageClass, lpszMsgClass); <br>    _tcscat(*lppszReportMessageClass, lpszReportSuffix); <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppszReportMessageClass); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKSetReportMessageClass------------------------------------------------- <br>//  Set the report message class. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKSetReportMessageClass(  // RETURNS: return code <br>    IN REPORT_T ReportType,                 // report type <br>    IN LPMESSAGE lpMessage,                 // pointer to message <br>    IN OUT LPMESSAGE lpReport)              // pointer to report <br>{ <br>    HRESULT hr                      = NOERROR; <br>    HRESULT hrT                     = 0; <br>    ULONG   cbMessageClass          = 0; <br>    LPTSTR  lpszMessageClass        = NULL; <br>    LPTSTR  lpszReportMessageClass  = NULL; <br> <br>    DEBUGPRIVATE("HrEDKSetReportMessageClass()\n"); <br> <br>    hr = CHK_HrEDKSetReportMessageClass( <br>        ReportType, <br>        lpMessage, <br>        lpReport); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrMAPIGetPropString( <br>        (LPMAPIPROP)lpMessage, <br>        PR_MESSAGE_CLASS, <br>        &amp;cbMessageClass, <br>        (LPVOID *)&amp;lpszMessageClass); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrEDKReportMessageClass( <br>        ReportType, <br>        lpszMessageClass, <br>        &amp;lpszReportMessageClass); <br> <br>    MAPIFREEBUFFER(lpszMessageClass); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetPropString( <br>        (LPMAPIPROP)lpReport, <br>        PR_MESSAGE_CLASS, <br>        (LPVOID)lpszReportMessageClass); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpszMessageClass); <br> <br>    MAPIFREEBUFFER(lpszReportMessageClass); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKEnvelopeMessageClass-------------------------------------------------- <br>//  Return an envelope message class. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKEnvelopeMessageClass(   // RETURNS: return code <br>    IN LPTSTR lpszMessageClass,             // pointer to message class <br>    OUT LPTSTR *lppszEnvelopeMessageClass)  // pointer to envelope message class <br>{ <br>    HRESULT hr                  = NOERROR; <br>    ULONG   cch                 = 0; <br>    LPTSTR  lpszMsgClass        = NULL; <br>    LPTSTR  lpszReportSuffix    = NULL; <br>    SCODE   sc                  = 0; <br>    ULONG   cBytes              = 0; <br> <br>    DEBUGPRIVATE("HrEDKEnvelopeMessageClass()\n"); <br> <br>    hr = CHK_HrEDKEnvelopeMessageClass( <br>        lpszMessageClass, <br>        lppszEnvelopeMessageClass); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppszEnvelopeMessageClass = NULL; <br> <br>    cch = lstrlen(lpszMessageClass); <br> <br>    if(cch == 0) <br>    { <br>        lpszMsgClass = "IPM.NOTE"; <br>        cch = lstrlen(lpszMsgClass); <br>    } <br>    else <br>    { <br>        lpszMsgClass = lpszMessageClass; <br>    } <br> <br>    cch += lstrlen(TEXT("ENVELOPE.")); <br> <br>    cch++;  // terminating NULL character <br> <br>    cBytes = cch * sizeof(TCHAR); <br> <br>    sc = MAPIAllocateBuffer(cBytes, lppszEnvelopeMessageClass); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    _tcscpy(*lppszEnvelopeMessageClass, TEXT("ENVELOPE.")); <br>    _tcscat(*lppszEnvelopeMessageClass, lpszMsgClass); <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppszEnvelopeMessageClass); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKCopyReportProps------------------------------------------------------- <br>//  Copy report properties. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKCopyReportProps(        // RETURNS: return code <br>    IN REPORT_T ReportType,                 // report type <br>    IN LPMESSAGE lpReport,                  // pointer to report <br>    IN ULONG cbSubjectMtsId,                // count of bytes in subject MTS-ID <br>    IN LPBYTE lpSubjectMtsId,               // pointer to subject MTS-ID <br>    IN LPTSTR lpszReportName,               // pointer to report name <br>    IN ULONG cbReportEntryId,               // count of bytes in report entry ID <br>    IN LPENTRYID lpReportEntryId,           // pointer to report entry ID <br>    IN OUT LPMESSAGE lpReportEnvelope)      // pointer to report envelope <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("HrEDKCopyReportProps()\n"); <br> <br>    hr = CHK_HrEDKCopyReportProps( <br>        ReportType, <br>        lpReport, <br>        cbSubjectMtsId, <br>        lpSubjectMtsId, <br>        lpszReportName, <br>        cbReportEntryId, <br>        lpReportEntryId, <br>        lpReportEnvelope); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrMAPIMoveOneProp( <br>        (LPMAPIPROP)lpReport, <br>        PR_SUBJECT, <br>        PR_SUBJECT, <br>        FALSE, <br>        TRUE, <br>        (LPMAPIPROP)lpReportEnvelope); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrEDKSetReportMessageClass( <br>        ReportType, <br>        lpReport, <br>        lpReportEnvelope); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetPropBinary( <br>        (LPMAPIPROP)lpReportEnvelope, <br>        PR_MTS_SUBJECT_ID, <br>        cbSubjectMtsId, <br>        (LPVOID)lpSubjectMtsId); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetPropString( <br>        (LPMAPIPROP)lpReportEnvelope, <br>        PR_REPORT_DESTINATION_NAME, <br>        (LPVOID)lpszReportName); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetPropBinary( <br>        (LPMAPIPROP)lpReportEnvelope, <br>        PR_REPORT_DESTINATION_ENTRYID, <br>        cbReportEntryId, <br>        (LPVOID)lpReportEntryId); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetPropBoolean( <br>        (LPMAPIPROP)lpReportEnvelope, <br>        PR_DELETE_AFTER_SUBMIT, <br>        TRUE); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>// These strings are explicitly not localized. <br> <br>static const char lpszReport[] = "REPORT."; <br>static const char lpszIPNRN[] = ".IPNRN"; <br>static const char lpszIPNNRN[] = ".IPNNRN"; <br>static const UINT  cchReportClass = sizeof(lpszReport) + sizeof(lpszIPNNRN); <br> <br>static const enum <br>{ <br>IREPORT = 0, ICONVERSATION, ICONVERSATIONTOPIC, ICONVERSATIONIDX, ISEARCH, <br>IMSGCLASS, ISUBJECT, ISUBJECTPREFX, ISUBJECTNORM, ISENDERNAME, ISENDEREID, <br>ISENDADRTYPE, ISENDEMAIL, IREPORTNAME, IREPORTEID, IRECEIVENAME, IRECEIVEEID, <br>IPRIORITY, IIMPORTANCE, ISENTREPNAME, ISENTREPEID, IRCVDREPNAME, IRCVDREPEID, <br>IMSGDELTIME, ISUBMITTIME, IDISPTO, IDISPCC, IDISPBCC, ISENSITIVITY, <br>INDRREQUEST, IDRREQUEST, IRNREQUEST, RRN_PROP_MAX <br>}; <br> <br>static const enum <br>{ <br>IRECIPTYPE = 0, IRECIPDISPNM, IRECIPEID, IRECIPADRTYPE, IRECIPEMAIL, <br>RRN_RECIP_PROP_MAX <br>}; <br> <br> <br>//$--HrReadReceipt-------------------------------------------------------------- <br>//  Create a read/non-read notification report. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadReceipt(           // RETURNS: return code <br>    IN ULONG ulFlags,                   // flags <br>IN LPSTR lpszReportText,            // report text <br>IN LPSTR lpszSubjectPrefix,         // subject prefix <br>    IN LPMESSAGE lpMessage,             // message <br>    OUT LPMESSAGE lpReadReceipt)        // report <br>{ <br>SCODEsc= S_OK; <br>HRESULThr= hrSuccess; <br>ADRLISTAdrList             = {0}; <br>BOOLfSetError= FALSE; <br>BOOLfSubjectOpenProperty= FALSE; <br>CHARchNull= 0; <br>FILETIME ft                  = {0}; <br>LPSPropValuelpOrigProps= NULL; <br>LPSPropValuelpRecipVals= NULL; <br>LPSTRlpszMessageClass= NULL; <br>LPSTRlpszReadSubject= NULL; <br>LPSTRlpszSubjOrig= NULL; <br>SPropValue rgMsgVals[ RRN_PROP_MAX ] = {0}; <br>SYSTEMTIME st                  = {0}; <br>UINTiNumProp            = 0; <br>ULONGulSize              = 0; <br>ULONGulT                 = 0; <br>#ifdef DEBUG <br>LPSPropProblemArraylpProblem= NULL; <br>#endif <br> <br>static SizedSPropTagArray(RRN_PROP_MAX, ptagaOrigMsg) = <br>{ <br>RRN_PROP_MAX, <br>{ <br>PR_REPORT_TAG, <br>PR_CONVERSATION_KEY, <br>PR_CONVERSATION_TOPIC_A, <br>PR_CONVERSATION_INDEX, <br>PR_SEARCH_KEY,// must <br>PR_MESSAGE_CLASS_A,// must <br>PR_SUBJECT_A, <br>PR_SUBJECT_PREFIX_A, <br>PR_NORMALIZED_SUBJECT_A, <br>PR_SENDER_NAME_A, <br>PR_SENDER_ENTRYID,// must <br>PR_SENDER_ADDRTYPE, <br>PR_SENDER_EMAIL_ADDRESS, <br>PR_REPORT_NAME_A, <br>PR_REPORT_ENTRYID, <br>PR_RECEIVED_BY_NAME_A, <br>PR_RECEIVED_BY_ENTRYID, <br>PR_PRIORITY, <br>PR_IMPORTANCE, <br>PR_SENT_REPRESENTING_NAME_A, <br>PR_SENT_REPRESENTING_ENTRYID, <br>PR_RCVD_REPRESENTING_NAME_A, <br>PR_RCVD_REPRESENTING_ENTRYID, <br>PR_MESSAGE_DELIVERY_TIME,// must <br>PR_CLIENT_SUBMIT_TIME, <br>PR_DISPLAY_TO_A, <br>PR_DISPLAY_CC_A, <br>PR_DISPLAY_BCC_A, <br>PR_SENSITIVITY, <br> <br>/*Properties from here out are just place <br> *holders for values we set into a message <br> *regardless of the value in the original <br> *message <br> */ <br> <br>PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED, <br>PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED, <br>PR_READ_RECEIPT_REQUESTED <br>} <br>}; <br> <br>static enum <br>{ <br>outIREPORTTEXT = 0, outIMESSAGECLASS, outIREPORTTIME, outIORIGAUTHOREID, <br>outIORIGDELIVERYTIME, outIPARENTKEY, outIDELETEAFTERSUBMIT, <br>outCMAXIDX <br>}; <br> <br>    hr = CHK_HrReadReceipt( <br>        ulFlags, <br>    lpszReportText, <br>    lpszSubjectPrefix, <br>        lpMessage, <br>        lpReadReceipt); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>#ifdef DEBUG <br> <br>// Determine if we should fill out the out the empty message. <br> <br>hr = HrGetOneProp((LPMAPIPROP)lpMessage, PR_READ_RECEIPT_REQUESTED, &amp;lpOrigProps); <br>if (FAILED(hr) &amp;&amp; hr != ResultFromScode(MAPI_E_NOT_FOUND)) <br>{ <br>MODULE_ERROR("HrReadReceipt: Failure to get prop"); <br>goto exit; <br>} <br> <br>ASSERTERROR(!(GetScode(hr) == MAPI_E_NOT_FOUND || !lpOrigProps-&gt;Value.l), <br>"PR_READ_RECEIPT_REQUESTED Flag not found"); <br> <br>MAPIFreeBuffer(lpOrigProps); <br>lpOrigProps = NULL; <br>#endif <br> <br>// get the props we need from the original message <br> <br>hr = lpMessage-&gt;lpVtbl-&gt;GetProps(lpMessage, <br>(LPSPropTagArray)&amp;ptagaOrigMsg, 0, // ansi <br>&amp;ulT, &amp;lpOrigProps); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: Failure to get Original msg props"); <br>fSetError = TRUE; <br>goto exit; <br>} <br> <br>    // if message delivery time is not found then add it <br> <br>if(lpOrigProps[IMSGDELTIME].ulPropTag != PR_MESSAGE_DELIVERY_TIME) <br>    { <br>    GetSystemTime(&amp;st); <br>    SystemTimeToFileTime(&amp;st, &amp;ft); <br> <br>    lpOrigProps[IMSGDELTIME].ulPropTag = PR_MESSAGE_DELIVERY_TIME; <br>    lpOrigProps[IMSGDELTIME].Value.ft  = ft; <br>    } <br> <br>// check to see if we have the "must" properties <br> <br>if (lpOrigProps[ISEARCH].ulPropTag != PR_SEARCH_KEY <br>  || lpOrigProps[IMSGCLASS].ulPropTag != PR_MESSAGE_CLASS_A <br>  || lpOrigProps[ISENDEREID].ulPropTag != PR_SENDER_ENTRYID <br>  || lpOrigProps[IMSGDELTIME].ulPropTag != PR_MESSAGE_DELIVERY_TIME) <br>{ <br>hr = HR_LOG(ResultFromScode(MAPI_E_NOT_FOUND)); <br>MODULE_ERROR("HrReadReceipt: Required property(s) not found"); <br>        goto exit; <br>} <br> <br>// Get the original subject <br> <br>if (lpOrigProps[ISUBJECTNORM].ulPropTag == PR_NORMALIZED_SUBJECT_A) <br>lpszSubjOrig = lpOrigProps[ISUBJECTNORM].Value.lpszA; <br>else if (lpOrigProps[ISUBJECT].ulPropTag == PR_SUBJECT_A) <br>lpszSubjOrig = lpOrigProps[ISUBJECT].Value.lpszA; <br>else if (lpOrigProps[ISUBJECT].Value.err == MAPI_E_NOT_ENOUGH_MEMORY) <br>{ <br>//We've got a mondo subject.  Use OpenProperty... <br>// <br>LPSTREAM lpstreamSrc= NULL; <br>LPSTREAM lpstreamDst= NULL; <br>ULARGE_INTEGERuliRead = { 0 }; <br>ULARGE_INTEGERuliWritten = { 0 }; <br>ULARGE_INTEGERuliSize; <br>LARGE_INTEGERliMove; <br>ULONGcbWritten= 0; <br> <br>// open the source Stream <br> <br>hr = lpMessage-&gt;lpVtbl-&gt;OpenProperty(lpMessage, PR_SUBJECT_A, <br>&amp;IID_IStream, 0, 0, (LPUNKNOWN *)&amp;lpstreamSrc); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: Failure calling OpenProperty on subject Src"); <br>fSetError = TRUE; <br>goto openprop_cleanup; <br>} <br> <br>// open the destinationStream <br> <br>hr = lpReadReceipt-&gt;lpVtbl-&gt;OpenProperty(lpReadReceipt, PR_SUBJECT_A, <br>&amp;IID_IStream, 0, MAPI_CREATE | MAPI_MODIFY, <br>(LPUNKNOWN *)&amp;lpstreamDst); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: Failure calling OpenProperty on subject Dst"); <br>fSetError = TRUE; <br>goto openprop_cleanup; <br>} <br> <br>// Copy the Subject header to the destination <br> <br>hr = lpstreamDst-&gt;lpVtbl-&gt;Write(lpstreamDst, lpszSubjectPrefix, <br>lstrlenA(lpszSubjectPrefix), &amp;cbWritten); <br> <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: OLE IStream Write failed"); <br>goto openprop_cleanup; <br>} <br> <br>ASSERTERROR((LONG)cbWritten == lstrlenA(lpszSubjectPrefix), "Write failed"); <br> <br>// Tell OLE ISTREAM to copy all of it <br> <br>uliSize.HighPart = (ULONG) -1; <br>uliSize.LowPart  = (ULONG) -1; <br> <br>hr = lpstreamSrc-&gt;lpVtbl-&gt;CopyTo(lpstreamSrc, lpstreamDst, uliSize, <br>&amp;uliRead, &amp;uliWritten); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: OLE IStream CopyTo failed"); <br>goto openprop_cleanup; <br>} <br> <br>ASSERTERROR(uliWritten.LowPart == uliRead.LowPart, "Write failed"); <br> <br>hr = lpstreamDst-&gt;lpVtbl-&gt;Commit(lpstreamDst, 0); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: OLE IStream Commit failed"); <br>goto openprop_cleanup; <br>} <br> <br>// Handle PR_ORIGINAL_SUBJECT <br> <br>UlRelease(lpstreamDst); <br>lpstreamDst = NULL; <br> <br>hr = lpReadReceipt-&gt;lpVtbl-&gt;OpenProperty(lpReadReceipt, <br>PR_ORIGINAL_SUBJECT_A,  &amp;IID_IStream, 0, <br>MAPI_CREATE | MAPI_MODIFY, (LPUNKNOWN *)&amp;lpstreamDst); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: Failure calling OpenProperty on Orig Subject Dst"); <br>fSetError = TRUE; <br>goto openprop_cleanup; <br>} <br> <br>// rewind the source <br> <br>liMove.HighPart = 0; <br>liMove.LowPart  = 0; <br> <br>hr = lpstreamSrc-&gt;lpVtbl-&gt;Seek(lpstreamSrc, liMove, STREAM_SEEK_SET, NULL); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: Failure calling Seek on subject Src stream"); <br>goto openprop_cleanup; <br>} <br> <br>// Tell OLE ISTREAM to copy all of it <br> <br>uliSize.HighPart = (ULONG) -1; <br>uliSize.LowPart  = (ULONG) -1; <br> <br>hr = lpstreamSrc-&gt;lpVtbl-&gt;CopyTo(lpstreamSrc, lpstreamDst, uliSize, <br>&amp;uliRead, &amp;uliWritten); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: OLE IStream CopyTo failed"); <br>goto openprop_cleanup; <br>} <br> <br>ASSERTERROR(uliWritten.LowPart == uliRead.LowPart, "Write failed"); <br> <br>hr = lpstreamDst-&gt;lpVtbl-&gt;Commit(lpstreamDst, 0); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: OLE IStream Commit failed"); <br>goto openprop_cleanup; <br>} <br> <br>fSubjectOpenProperty = TRUE; <br> <br>openprop_cleanup: <br> <br>UlRelease(lpstreamSrc); <br>UlRelease(lpstreamDst); <br> <br>if (FAILED(hr)) <br>{ <br>goto exit; <br>} <br>} <br>else <br>lpszSubjOrig = &amp;chNull; <br> <br>if (!fSubjectOpenProperty) <br>{ <br>ulSize = lstrlenA (lpszSubjOrig) + lstrlenA (lpszSubjectPrefix) + 1; <br>sc = MAPIAllocateBuffer(ulSize, (LPVOID *) &amp;lpszReadSubject); <br>if (FAILED(sc)) <br>{ <br>hr = HR_LOG(ResultFromScode(sc)); <br>MODULE_ERROR("HrReadReceipt: OOM"); <br>goto exit; <br>} <br> <br>wsprintfA (lpszReadSubject, <br>"%s%s", <br>lpszSubjectPrefix, <br>lpszSubjOrig); <br>} <br> <br>// Generate the Report Message Class from the existing message class <br> <br>ASSERTERROR( <br>    lpOrigProps[IMSGCLASS].ulPropTag == PR_MESSAGE_CLASS_A, <br>    "Message class is missing"); <br> <br>ulSize = cchReportClass + lstrlenA(lpOrigProps[IMSGCLASS].Value.lpszA) + 1; <br>sc = MAPIAllocateBuffer(ulSize, (LPVOID *)&amp;lpszMessageClass); <br>if (FAILED(sc)) <br>{ <br>hr = HR_LOG(ResultFromScode(sc)); <br>MODULE_ERROR("HrReadReceipt: OOM for RRN report message class"); <br>        goto exit; <br>} <br> <br>wsprintfA(lpszMessageClass, <br>"%s%s%s", <br>lpszReport, <br>lpOrigProps[IMSGCLASS].Value.lpszA, <br>(ulFlags &amp; MAPI_NON_READ) ? (LPSTR) lpszIPNNRN : (LPSTR) lpszIPNRN); <br> <br>// <br>// Setup the "must" prop vals <br>// <br> <br>rgMsgVals[outIREPORTTEXT].ulPropTag  = PR_REPORT_TEXT_A; <br>rgMsgVals[outIREPORTTEXT].Value.lpszA = lpszReportText; <br> <br>rgMsgVals[outIMESSAGECLASS].ulPropTag = PR_MESSAGE_CLASS_A; <br>rgMsgVals[outIMESSAGECLASS].Value.lpszA= lpszMessageClass; <br> <br>GetSystemTime(&amp;st); <br>SystemTimeToFileTime(&amp;st, &amp;ft); <br> <br>rgMsgVals[outIREPORTTIME].ulPropTag= PR_REPORT_TIME; <br>rgMsgVals[outIREPORTTIME].Value.ft= ft; <br> <br>// PR_ORIGINAL_AUTHOR_?? is set from PR_SENDER_?? <br> <br>rgMsgVals[outIORIGAUTHOREID].ulPropTag = PR_ORIGINAL_AUTHOR_ENTRYID; <br>rgMsgVals[outIORIGAUTHOREID].Value.bin= lpOrigProps[ISENDEREID].Value.bin; <br> <br>rgMsgVals[outIORIGDELIVERYTIME].ulPropTag  = PR_ORIGINAL_DELIVERY_TIME; <br>rgMsgVals[outIORIGDELIVERYTIME].Value.ft = lpOrigProps[IMSGDELTIME].Value.ft; <br> <br>// Set PR_PARENT_KEY with PR_MESSAGE_KEY of the original message. <br> <br>rgMsgVals[outIPARENTKEY].ulPropTag = PR_PARENT_KEY; <br>rgMsgVals[outIPARENTKEY].Value.bin= lpOrigProps[ISEARCH].Value.bin; <br> <br>rgMsgVals[outIDELETEAFTERSUBMIT].ulPropTag = PR_DELETE_AFTER_SUBMIT; <br>rgMsgVals[outIDELETEAFTERSUBMIT].Value.b = TRUE; <br> <br>iNumProp = outCMAXIDX; <br> <br>// <br>// Setup the variable Prop Vals <br>// <br> <br>if (lpOrigProps[ISENDERNAME].ulPropTag == PR_SENDER_NAME_A) <br>{ <br>rgMsgVals[iNumProp].ulPropTag = PR_ORIGINAL_AUTHOR_NAME_A; <br>rgMsgVals[iNumProp].Value.lpszA= lpOrigProps[ISENDERNAME].Value.lpszA; <br>iNumProp++; <br>} <br> <br>// Check to see if we handled Subject props by OpenProperty... <br> <br>if (!fSubjectOpenProperty) <br>{ <br>rgMsgVals[iNumProp].ulPropTag = PR_SUBJECT_A; <br>rgMsgVals[iNumProp].Value.lpszA = lpszReadSubject; <br>iNumProp++; <br> <br>if (lpOrigProps[ISUBJECT].ulPropTag == PR_SUBJECT_A) <br>{ <br>rgMsgVals[iNumProp].ulPropTag= PR_ORIGINAL_SUBJECT_A; <br>rgMsgVals[iNumProp].Value.lpszA= lpOrigProps[ISUBJECT].Value.lpszA; <br>iNumProp++; <br>} <br>else <br>{ <br>MODULE_ERROR("HrReadReceipt: PR_SUBJECT missing"); <br>rgMsgVals[iNumProp].ulPropTag= PR_ORIGINAL_SUBJECT_A; <br>rgMsgVals[iNumProp].Value.lpszA= &amp;chNull; <br>iNumProp++; <br>} <br>} <br> <br>//The ordering here is slightly important.  PR_SUBJECT <br>//needs to be either first or last to aid in EMS processing <br>// <br>rgMsgVals[iNumProp].ulPropTag = PR_SUBJECT_PREFIX_A; <br>rgMsgVals[iNumProp].Value.lpszA = lpszSubjectPrefix; <br>iNumProp++;  <br>rgMsgVals[iNumProp].ulPropTag = PR_NORMALIZED_SUBJECT_A; <br>rgMsgVals[iNumProp].Value.lpszA = lpszSubjOrig; <br>iNumProp++;  <br> <br>// If PR_SENT_REPRESENTING_?? exists copy to PR_RCVD_REPRESENTING_?? <br> <br>if (lpOrigProps[ISENTREPNAME].ulPropTag == PR_SENT_REPRESENTING_NAME_A) <br>{ <br>rgMsgVals[iNumProp].ulPropTag = PR_RCVD_REPRESENTING_NAME_A; <br>rgMsgVals[iNumProp].Value.lpszA= lpOrigProps[ISENTREPNAME].Value.lpszA; <br>iNumProp++; <br>} <br> <br>if (lpOrigProps[ISENTREPEID].ulPropTag == PR_SENT_REPRESENTING_ENTRYID) <br>{ <br>rgMsgVals[iNumProp].ulPropTag = PR_RCVD_REPRESENTING_ENTRYID; <br>rgMsgVals[iNumProp].Value.bin= lpOrigProps[ISENTREPEID].Value.bin; <br>iNumProp++; <br>} <br> <br>// If PR_RCVD_REPRESENTING_?? exists copy to PR_SENT_REPRESENTING_?? <br> <br>if (lpOrigProps[IRCVDREPNAME].ulPropTag == PR_RCVD_REPRESENTING_NAME_A) <br>{ <br>rgMsgVals[iNumProp].ulPropTag  = PR_SENT_REPRESENTING_NAME_A; <br>rgMsgVals[iNumProp].Value.lpszA= lpOrigProps[IRCVDREPNAME].Value.lpszA; <br>iNumProp++; <br>} <br> <br>if (lpOrigProps[IRCVDREPEID].ulPropTag == PR_RCVD_REPRESENTING_ENTRYID) <br>{ <br>rgMsgVals[iNumProp].ulPropTag  = PR_SENT_REPRESENTING_ENTRYID; <br>rgMsgVals[iNumProp].Value.bin= lpOrigProps[IRCVDREPEID].Value.bin; <br>iNumProp++; <br>} <br> <br>if (lpOrigProps[ISUBMITTIME].ulPropTag == PR_CLIENT_SUBMIT_TIME) <br>{ <br>rgMsgVals[iNumProp].ulPropTag  = PR_ORIGINAL_SUBMIT_TIME; <br>rgMsgVals[iNumProp].Value.ft   = lpOrigProps[ISUBMITTIME].Value.ft; <br>iNumProp++; <br>} <br> <br>if (lpOrigProps[IDISPTO].ulPropTag == PR_DISPLAY_TO_A) <br>{ <br>rgMsgVals[iNumProp].ulPropTag= PR_ORIGINAL_DISPLAY_TO_A; <br>rgMsgVals[iNumProp].Value.lpszA = lpOrigProps[IDISPTO].Value.lpszA; <br>iNumProp++; <br>} <br> <br>if (lpOrigProps[IDISPCC].ulPropTag == PR_DISPLAY_CC_A) <br>{ <br>rgMsgVals[iNumProp].ulPropTag= PR_ORIGINAL_DISPLAY_CC_A; <br>rgMsgVals[iNumProp].Value.lpszA = lpOrigProps[IDISPCC].Value.lpszA; <br>iNumProp++; <br>} <br> <br>if (lpOrigProps[IDISPBCC].ulPropTag == PR_DISPLAY_BCC_A) <br>{ <br>rgMsgVals[iNumProp].ulPropTag= PR_ORIGINAL_DISPLAY_BCC_A; <br>rgMsgVals[iNumProp].Value.lpszA = lpOrigProps[IDISPBCC].Value.lpszA; <br>iNumProp++; <br>} <br> <br>if (lpOrigProps[IPRIORITY].ulPropTag == PR_PRIORITY) <br>rgMsgVals[iNumProp++] = lpOrigProps[IPRIORITY]; <br> <br>if (lpOrigProps[IIMPORTANCE].ulPropTag == PR_IMPORTANCE) <br>rgMsgVals[iNumProp++] = lpOrigProps[IIMPORTANCE]; <br> <br>if (lpOrigProps[ISENSITIVITY].ulPropTag == PR_SENSITIVITY) <br>rgMsgVals[iNumProp++] = lpOrigProps[ISENSITIVITY]; <br> <br>if (lpOrigProps[ICONVERSATION].ulPropTag == PR_CONVERSATION_KEY) <br>rgMsgVals[iNumProp++] = lpOrigProps[ICONVERSATION]; <br> <br>if (lpOrigProps[ICONVERSATIONTOPIC].ulPropTag == PR_CONVERSATION_TOPIC_A) <br>rgMsgVals[iNumProp++] = lpOrigProps[ICONVERSATIONTOPIC]; <br> <br>if (lpOrigProps[ICONVERSATIONIDX].ulPropTag == PR_CONVERSATION_INDEX) <br>rgMsgVals[iNumProp++] = lpOrigProps[ICONVERSATIONIDX]; <br> <br>if (lpOrigProps[IREPORT].ulPropTag == PR_REPORT_TAG) <br>rgMsgVals[iNumProp++] = lpOrigProps[IREPORT]; <br> <br>//Turn off any and all report requests <br>// <br>rgMsgVals[iNumProp].ulPropTag = PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED; <br>rgMsgVals[iNumProp].Value.b = FALSE; <br>iNumProp++; <br>rgMsgVals[iNumProp].ulPropTag = PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED; <br>rgMsgVals[iNumProp].Value.b = FALSE; <br>iNumProp++; <br>rgMsgVals[iNumProp].ulPropTag = PR_READ_RECEIPT_REQUESTED; <br>rgMsgVals[iNumProp].Value.b = FALSE; <br>iNumProp++; <br> <br>// Fill in recipient properties <br> <br>    sc = MAPIAllocateBuffer(sizeof(SPropValue) * RRN_RECIP_PROP_MAX, (LPVOID *)&amp;lpRecipVals); <br>if (FAILED(sc)) <br>{ <br>hr = HR_LOG(ResultFromScode(sc)); <br>MODULE_ERROR("HrReadReceipt: OOM for recipient props"); <br>        goto exit; <br>} <br> <br>// If PR_REPORT_NAME &amp; EID exists, use that as the MAPI_TO recipient <br>// else use PR_SENDER_NAME &amp; EID. <br> <br>lpRecipVals[IRECIPTYPE].ulPropTag = PR_RECIPIENT_TYPE; <br>lpRecipVals[IRECIPTYPE].Value.l = MAPI_TO; <br> <br>lpRecipVals[IRECIPDISPNM].ulPropTag= PR_DISPLAY_NAME_A; <br>lpRecipVals[IRECIPEID].ulPropTag= PR_ENTRYID; <br> <br>if (lpOrigProps[IREPORTNAME].ulPropTag == PR_REPORT_NAME_A <br>  &amp;&amp; lpOrigProps[IREPORTEID].ulPropTag == PR_REPORT_ENTRYID) <br>  { <br>lpRecipVals[IRECIPDISPNM].Value.lpszA= lpOrigProps[IREPORTNAME].Value.lpszA; <br>lpRecipVals[IRECIPEID].Value.bin= lpOrigProps[IREPORTEID].Value.bin; <br>lpRecipVals[IRECIPADRTYPE].ulPropTag= PR_NULL; <br>lpRecipVals[IRECIPEMAIL].ulPropTag= PR_NULL; <br>} <br>else <br>{ <br>lpRecipVals[IRECIPDISPNM].Value.lpszA= lpOrigProps[ISENDERNAME].Value.lpszA; <br>lpRecipVals[IRECIPEID].Value.bin= lpOrigProps[ISENDEREID].Value.bin; <br> <br>lpRecipVals[IRECIPADRTYPE].ulPropTag= PR_ADDRTYPE_A; <br>lpRecipVals[IRECIPADRTYPE].Value.lpszA= lpOrigProps[ISENDADRTYPE].Value.lpszA; <br> <br>lpRecipVals[IRECIPEMAIL].ulPropTag= PR_EMAIL_ADDRESS_A; <br>lpRecipVals[IRECIPEMAIL].Value.lpszA= lpOrigProps[ISENDEMAIL].Value.lpszA; <br>} <br> <br>AdrList.cEntries = 1; </code></pre>
<p>
</p>
<pre><code>AdrList.aEntries[0].cValues = RRN_RECIP_PROP_MAX; <br>AdrList.aEntries[0].rgPropVals = lpRecipVals; <br> <br>// SetProps and ModifyRecips. <br> <br>#ifdef DEBUG <br>hr = lpReadReceipt-&gt;lpVtbl-&gt;SetProps(lpReadReceipt, <br>(ULONG)iNumProp, rgMsgVals, &amp;lpProblem); <br>#else <br>hr = lpReadReceipt-&gt;lpVtbl-&gt;SetProps(lpReadReceipt, <br>(ULONG)iNumProp, rgMsgVals, NULL); <br>#endif <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: Failure setting a slew of props"); <br>fSetError = TRUE; <br>goto exit; <br>} <br> <br>#ifdef DEBUG <br>if (lpProblem) <br>{ <br>MAPIFreeBuffer(lpProblem); <br>} <br>#endif <br> <br>hr = lpReadReceipt-&gt;lpVtbl-&gt;ModifyRecipients( <br>lpReadReceipt, 0, &amp;AdrList); <br>if (FAILED(hr)) <br>{ <br>MODULE_ERROR("HrReadReceipt: Failure modifying recipients"); <br>fSetError = TRUE; <br>goto exit; <br>} <br> <br>exit: <br>MAPIFreeBuffer(lpOrigProps); <br>MAPIFreeBuffer(lpszMessageClass); <br>MAPIFreeBuffer(lpszReadSubject); <br>MAPIFreeBuffer(AdrList.aEntries[0].rgPropVals); <br> <br>return(hr); <br>} <br> <br>//$--HrEDKCreateReadReceipt----------------------------------------------------- <br>//  Create a RN/NRN report. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKCreateReadReceipt(      // RETURNS: return code <br>    IN ULONG ulFlags,                       // flags <br>    IN LPMAPIFOLDER lpFolder,               // pointer to folder <br>    IN LPMESSAGE lpMessage,                 // pointer to message <br>    IN LPTSTR lpszSubjectPrefix,            // pointer to subject prefix <br>    IN LPTSTR lpszReportText,               // pointer to report text <br>    OUT LPMESSAGE *lppReportEnvelope,       // pointer to report envelope <br>    OUT LPMESSAGE *lppReport)               // pointer to report <br>{ <br>    HRESULT      hr                = NOERROR; <br>    LPTSTR       lpszMessageClass  = NULL; <br>    LPMESSAGE    lpReportEnvelope  = NULL; <br>    ULONG        ulAttachmentNum   = 0; <br>    LPATTACH     lpAttach          = NULL; <br>    LPMESSAGE    lpReport          = NULL; <br>    HRESULT      hrT               = 0; <br>    ULONG        cValues           = 0; <br>    LPSPropValue lpProps           = NULL; <br>    LPSPropValue lpPropT           = NULL; <br> <br>    ULONG        cNewProps         = 0; <br>    LPSPropValue lpNewProps        = NULL; <br> <br>    LPMAPITABLE  lpTable           = NULL; <br>    LPADRLIST    lpAdrList         = NULL; <br> <br>    LPADRLIST    lpEnvelopeAdrList = NULL; <br> <br>    ULONG        i                 = 0; <br>    ULONG        iRecip            = 0; <br> <br>    SPropValue   RecipNumProp[1]   = {0}; <br>    SPropValue   rgProps[1]        = {0}; <br> <br>SYSTEMTIME   st                = {0}; <br>FILETIME     ft                = {0}; <br> <br>    SizedSPropTagArray(6,rgReportTags) = <br>    { <br>        6, <br>        { <br>            PR_SENT_REPRESENTING_NAME, <br>            PR_SENT_REPRESENTING_ENTRYID, <br>            PR_MESSAGE_CLASS, <br>            PR_SUBJECT, <br>            PR_PRIORITY, <br>            PR_DELETE_AFTER_SUBMIT <br>        } <br>    }; <br> <br>    DEBUGPRIVATE("HrEDKCreateReadReceipt()\n"); <br> <br>    hr = CHK_HrEDKCreateReadReceipt( <br>        ulFlags, <br>        lpFolder, <br>        lpMessage, <br>        lpszSubjectPrefix, <br>        lpszReportText, <br>        lppReportEnvelope, <br>        lppReport); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if(ulFlags == MAPI_NON_READ) <br>    { <br>        hr = HrMAPISetPropBoolean( <br>            (LPMAPIPROP)lpMessage, <br>            PR_NON_RECEIPT_NOTIFICATION_REQUESTED, <br>            TRUE); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        hr = HrMAPISetPropBoolean( <br>            (LPMAPIPROP)lpMessage, <br>            PR_READ_RECEIPT_REQUESTED, <br>            TRUE); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    *lppReportEnvelope = NULL; <br>    *lppReport = NULL; <br> <br>    // <br>    // Create a message <br>    // <br> <br>    hr = MAPICALL(lpFolder)-&gt;CreateMessage( <br>        lpFolder, <br>        NULL, <br>        (ULONG)0, <br>        &amp;lpReportEnvelope); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Create an embedded message <br>    // <br> <br>    hr = MAPICALL(lpReportEnvelope)-&gt;CreateAttach( <br>        lpReportEnvelope, <br>        NULL, <br>        (ULONG)0, <br>        &amp;ulAttachmentNum, <br>        &amp;lpAttach); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    rgProps[0].ulPropTag = PR_ATTACH_METHOD; <br>    rgProps[0].Value.ul  = ATTACH_EMBEDDED_MSG; <br> <br>    hr = MAPICALL(lpAttach)-&gt;SetProps( <br>        lpAttach, <br>        1, <br>        rgProps, <br>        NULL); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL(lpAttach)-&gt;OpenProperty( <br>        lpAttach, <br>        PR_ATTACH_DATA_OBJ, <br>        (LPIID)&amp;IID_IMessage, <br>        0, <br>        MAPI_CREATE|MAPI_MODIFY, <br>        (LPUNKNOWN *)&amp;lpReport); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    //-------------------------------------------------------------------------- <br> <br>    hrT = HrReadReceipt( <br>        ulFlags, <br>    lpszReportText, <br>    lpszSubjectPrefix, <br>        lpMessage, <br>        lpReport); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>GetSystemTime(&amp;st); <br>SystemTimeToFileTime(&amp;st, &amp;ft); <br> <br>rgProps[0].ulPropTag    = PR_CLIENT_SUBMIT_TIME; <br>rgProps[0].Value.ft     = ft; <br> <br>    hrT = MAPICALL(lpReport)-&gt;SetProps( <br>        lpReport, <br>        1, <br>        rgProps, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hrT = MAPICALL(lpReport)-&gt;GetProps( <br>        lpReport, <br>        (SPropTagArray *)&amp;rgReportTags, <br>        fMapiUnicode, <br>        &amp;cValues, <br>        &amp;lpProps); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>if((lpProps[0].ulPropTag != PR_SENT_REPRESENTING_NAME) || <br>   (lpProps[1].ulPropTag != PR_SENT_REPRESENTING_ENTRYID) || <br>   (lpProps[2].ulPropTag != PR_MESSAGE_CLASS)) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>} <br> <br>    lpProps[0].ulPropTag  = PR_ORIGINATOR_NAME; <br>    lpProps[1].ulPropTag  = PR_ORIGINATOR_ENTRYID; <br> <br>    hr = HrEDKEnvelopeMessageClass( <br>        lpProps[2].Value.LPSZ, <br>        &amp;lpszMessageClass); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lpProps[2].Value.LPSZ = lpszMessageClass; <br> <br>    hrT = MAPICALL(lpReportEnvelope)-&gt;SetProps( <br>        lpReportEnvelope, <br>        6, <br>        lpProps, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Create recipient table for report envelope. <br>    // <br> <br>    // ------------------------------------------------------------------------- <br> <br>    // <br>// Get the current recipient table from the report. <br>    // <br> <br>hrT = MAPICALL(lpReport)-&gt;GetRecipientTable(lpReport, 0, &amp;lpTable); <br> <br>if(FAILED(hrT)) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>} <br> <br>// <br>// Query all the rows. <br>// <br> <br>hrT = HrQueryAllRows( <br>    lpTable, <br>NULL, <br>NULL, <br>NULL, <br>0, <br>&amp;(LPSRowSet)lpAdrList); <br> <br>if(FAILED(hrT)) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>} <br> <br>    hr = HrMAPICreateSizedAddressList( <br>        lpAdrList-&gt;cEntries, <br>        &amp;lpEnvelopeAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    for(i = 0, iRecip = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>        RecipNumProp[0].ulPropTag = PR_RECIPIENT_NUMBER; <br>        RecipNumProp[0].Value.ul  = iRecip+1; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        hr = HrMAPIAppendSPropValues( <br>            lpAdrList-&gt;aEntries[i].cValues, <br>            lpAdrList-&gt;aEntries[i].rgPropVals, <br>            1, <br>            RecipNumProp, <br>            &amp;cNewProps, <br>            &amp;lpNewProps); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrMAPISetAddressList( <br>            iRecip, <br>            cNewProps, <br>            lpNewProps, <br>            lpEnvelopeAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        MAPIFREEBUFFER(lpNewProps); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        iRecip++; <br>    } <br> <br>    lpEnvelopeAdrList-&gt;cEntries = iRecip; <br> <br>    if(iRecip == 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hrT = MAPICALL(lpReportEnvelope)-&gt;ModifyRecipients( <br>        lpReportEnvelope, <br>        0, <br>        lpEnvelopeAdrList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // ------------------------------------------------------------------------- <br> <br>    hrT = MAPICALL(lpReport)-&gt;SaveChanges(lpReport, KEEP_OPEN_READWRITE); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hrT = MAPICALL(lpAttach)-&gt;SaveChanges(lpAttach, KEEP_OPEN_READWRITE); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Save changes to the report envelope <br>    hrT = MAPICALL(lpReportEnvelope)-&gt;SaveChanges(lpReportEnvelope, KEEP_OPEN_READWRITE); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    *lppReportEnvelope = lpReportEnvelope; <br>    *lppReport = lpReport; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpNewProps); <br> <br>    ULRELEASE(lpTable); <br> <br>    FREEPADRLIST(lpAdrList); <br> <br>    FREEPADRLIST(lpEnvelopeAdrList); <br> <br>    MAPIFREEBUFFER(lpszMessageClass); <br> <br>    ULRELEASE(lpAttach); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKCreateReadNotificationReport------------------------------------------ <br>//  Create a read notification report. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEDKCreateReadNotificationReport(  // RETURNS: return code <br>    IN LPMAPIFOLDER lpFolder,               // pointer to folder <br>    IN LPMESSAGE lpMessage,                 // pointer to message <br>    IN LPTSTR lpszReportText,               // pointer to report text <br>    OUT LPMESSAGE *lppReportEnvelope,       // pointer to report envelope <br>    OUT LPMESSAGE *lppReport)               // pointer to report <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrEDKCreateReadNotificationReport()\n"); <br> <br>    hr = CHK_HrEDKCreateReadNotificationReport( <br>        lpFolder, <br>        lpMessage, <br>        lpszReportText, <br>        lppReportEnvelope, <br>        lppReport); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrEDKCreateReadReceipt( <br>        0, <br>        lpFolder, <br>        lpMessage, <br>        TEXT("Read: "), <br>        lpszReportText, <br>        lppReportEnvelope, <br>        lppReport); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKCreateNonReadNotificationReport--------------------------------------- <br>//  Create a non-read notification report. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEDKCreateNonReadNotificationReport(   // RETURNS: return code <br>    IN LPMAPIFOLDER lpFolder,                   // pointer to folder <br>    IN LPMESSAGE lpMessage,                     // pointer to message <br>    IN LPTSTR lpszReportText,                   // pointer to report text <br>    IN ULONG ulNonReceiptReason,                // non-receipt reason <br>    IN ULONG ulDiscardReason,                   // discard reason <br>    OUT LPMESSAGE *lppReportEnvelope,           // pointer to report envelope <br>    OUT LPMESSAGE *lppReport)                   // pointer to report <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = 0; <br> <br>    DEBUGPUBLIC("HrEDKCreateNonReadNotificationReport()\n"); <br> <br>    hr = CHK_HrEDKCreateNonReadNotificationReport( <br>        lpFolder, <br>        lpMessage, <br>        lpszReportText, <br>        ulNonReceiptReason, <br>        ulDiscardReason, <br>        lppReportEnvelope, <br>        lppReport); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrEDKCreateReadReceipt( <br>        MAPI_NON_READ, <br>        lpFolder, <br>        lpMessage, <br>        TEXT("Unread: "), <br>        lpszReportText, <br>        lppReportEnvelope, <br>        lppReport); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetPropLong( <br>        (LPMAPIPROP)*lppReport, <br>        PR_DISCARD_REASON, <br>        ulDiscardReason); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetPropLong( <br>        (LPMAPIPROP)*lppReport, <br>        PR_NON_RECEIPT_REASON, <br>        ulNonReceiptReason); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Save changes to the report <br>    hrT = MAPICALL(*lppReport)-&gt;SaveChanges(*lppReport, KEEP_OPEN_READWRITE); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
