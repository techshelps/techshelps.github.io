<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROPSET.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1936"></a>PROPSET.CPP</h2>
<pre><code>//========================================================================= <br>// PROPSET.CPP <br>// <br>// Copyright (C) 1986-1996.  Microsoft Corp.  All Rights Reserved. <br>// <br>// Purpose: <br>//    Provides OLE and MAPI property set routines. <br>//========================================================================= <br> <br>#include "stdafx.h" <br>#include &lt;windowsx.h&gt; <br>#include &lt;winnls.h&gt; <br>#include &lt;mapinls.h&gt; <br>#include "edk.h" <br>#include "PostSmpl.h" <br>#include &lt;initguid.h&gt; <br>#include "freedoc.h" <br> <br> <br> <br>/* <br> * Data Strcuctures <br> */ <br> <br>typedef GUID   FMTID; <br>typedef struct _fmtidoffset <br>{ <br>   FMTID fmtid;               // FMTID for a section <br>   DWORD dwOffset;            // offset of section from start of stream <br>} FMTIDOFFSET; <br> <br>typedef struct _propsethdr <br>{ <br>   WORD  wByteOrder;    // Always 0xFFFE <br>   WORD  wFormat;    // Always 0 <br>   DWORD dwOSVer;    // Hiword: 0=Win16; 1=Mac; 2=Win32 <br>                     // Loword: GetVersion() <br>   CLSID clsid;         // App CLSID <br>   DWORD cSections;     // Number of sections <br>} PROPSETHDR; <br> <br>typedef DWORD  PID; <br>typedef struct _pidoffset <br>{ <br>   PID      pid;              // Property ID <br>   DWORD dwOffset;            // offset of property from start of section <br>} PIDOFFSET; <br> <br>typedef struct _propsectionhdr <br>{ <br>   DWORD    cbSection;        // Size of this section <br>   DWORD    cProps;           // Number of properties in this section <br>} PROPSECTIONHDR; <br> <br> <br>/* <br> * Define some of the guids we use <br> */ <br>DEFINE_GUID(FMTID_SumInfo, 0xF29F85E0L, 0x4FF9, 0x1068, 0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9); <br> <br>typedef struct _mppidmapiprop <br>{ <br>   WORD     wMapiType;        // MAPI Type <br>   LPWSTR      szW;           // MAPI Name <br>} MPPIDMAPIPROP; <br> <br>enum pidSumInfo { <br>   PID_TITLE = 2, <br>   PID_SUBJECT, <br>   PID_AUTHOR, <br>   PID_KEYWORDS, <br>   PID_COMMENTS, <br>   cpidSumInfoMax <br>}; <br> <br> <br>typedef struct _propsetstminfo <br>{ <br>   LPOLESTR       szName;              // stream name <br>   FMTID const   *pfmtid;              // FMTID of section to promote <br>   INT            cmppidmapipropMax;      // Mapping for property names <br>   MPPIDMAPIPROP *mppidmapiprop; <br>} PROPSETSTMINFO; <br> <br> <br>// Lego workaround - define the symbols for the array <br> <br>WCHAR szTitle[]      = L"Title"; <br>WCHAR szSubject[]    = L"Subject"; <br>WCHAR szAuthor[]     = L"Author"; <br>WCHAR szKeywords[]   = L"Keywords"; <br>WCHAR szComments[]   = L"Comments"; <br> <br>MPPIDMAPIPROP mppidmapipropSumInfo[] = <br>{ <br>   {  PT_NULL, NULL        }, // Dictionary <br>   {  PT_NULL, NULL        }, // Code page <br>   {  PT_STRING8,    szTitle     }, <br>   {  PT_STRING8,    szSubject   }, <br>   {  PT_STRING8,    szAuthor    }, <br>   {  PT_MV_STRING8, szKeywords  }, // Special case VT_LPSTR -&gt; MV <br>   {  PT_STRING8,    szComments  } <br>}; <br> <br>OLECHAR szSumInfo[] = OLESTR("\005SummaryInformation"); <br> <br>PROPSETSTMINFO rgpropsetstminfo[] = <br>{ <br>   {szSumInfo, &amp;FMTID_SumInfo, cpidSumInfoMax, mppidmapipropSumInfo}, <br>   {NULL, NULL, 0, NULL} <br>}; <br> <br> <br> <br>/* <br> * SzDupSz <br> * <br> * Purpose: <br> *    This function allocates a new buffer and copies the <br> *    supplied string into it. <br> * <br> * Parameters: <br> *    sz    the string to duplicate <br> * <br> * Returns: <br> *    a pointer to the new string (or NULL on failure) <br> */ <br>HRESULT SzDupSz(LPCTSTR sz, LPSTR *lppstr) <br>{ <br>   INT         cb = 0; <br>   HRESULT   hr = NOERROR; <br> <br>   if (!sz) <br>      return hr; <br> <br>   cb = (lstrlen(sz) + 1) * sizeof(TCHAR); <br>   if (!SUCCEEDED(hr = MAPIAllocateBuffer(cb, (LPVOID *)lppstr))) <br>         return hr; <br> <br>   if (!lstrcpy(*lppstr, sz)) <br>      return hr; <br> <br>   return hr; <br>} <br> <br> <br> <br> <br> <br>/* <br> * ScParseKeywords <br> * <br> * Purpose: <br> *    Parses a string of keywords listed by separators in a pval, into a <br> *    multi valued property. <br> * <br> * Arguments: <br> *    pval     Contains the keywords list string in pval-&gt;Value.lpszA <br> *    szDefSep Default list separator <br> * <br> * Returns: <br> *    SCODE    The status code <br> */ <br>SCODE ScParseKeywords(LPSPropValue pval, TCHAR * szDefSep) <br>{ <br>   SCODE    sc= S_OK; <br>   LPSTR    szKeywords= pval-&gt;Value.lpszA; <br>   CHAR *   pch= szKeywords; <br>   CHAR *   pchPrev= NULL; <br>   LPSTR *  rgsz= NULL; <br>   LONG     cKeywords= 0; <br>   LONG     isz= 0; <br>   TCHAR    szSep[3]; <br>   BOOL     fInWord= FALSE; <br>   BOOL     fFakeOneWord= FALSE; <br>   HRESULT  hr= NOERROR; <br> <br>   static TCHAR   szScParseKeywords1[] = TEXT("intl"); <br>   static TCHAR   szScParseKeywords2[] = TEXT("sList"); <br>   static TCHAR   szScParseKeywords3[] = TEXT(","); <br> <br>   // Get the list separator character <br>   GetProfileString(szScParseKeywords1, szScParseKeywords2, <br>         szScParseKeywords3, szSep, sizeof(szSep) / sizeof(TCHAR)); <br> <br> <br>   // Default list separator is the space character <br>   if (!szDefSep) <br>      szDefSep = TEXT(" "); <br> <br>   // Loop through the string zero filling non-keywords <br>   while (*pch) <br>   { <br>#ifdef DBCS <br>      if (!FGLeadByte(*pch) &amp;&amp; (*pch == szDefSep[0] || *pch == szSep[0])) <br>#else <br>      if (*pch == szDefSep[0] || *pch == szSep[0]) <br>#endif <br>      { <br>         fInWord = FALSE; <br>      } <br>      else <br>      { <br>         // If we aren't in a word, we are now <br>         if (!fInWord) <br>            cKeywords++; <br>         fInWord = TRUE; <br>      } <br> <br>      // Remember this position <br>      pchPrev = pch; <br> <br>      // Move forward <br>#ifdef DBCS <br>      pch = SzGNext(pch); <br>#else <br>      pch = AnsiNext(pch); <br>#endif <br> <br>      // If we aren't in a word, zap area from our previous position <br>      if (!fInWord) <br>         ZeroMemory(pchPrev, pch - pchPrev); <br>   } <br> <br> <br>   // Remove leading and trailing spaces from keywords <br> <br>   pch = szKeywords; <br>   isz = cKeywords; <br>   while (isz) <br>   { <br>      isz--; <br> <br>      // Skip consecutive separators <br>      while (!*pch) <br>         pch++; <br> <br>      if (*pch) <br>      { <br>         // Zero out leading spaces <br>         pchPrev = pch; <br>         while (isspace(*pch)) <br>            pch = AnsiNext(pch); <br>         ZeroMemory(pchPrev, pch - pchPrev); <br> <br>         // Blank keyword <br>         if (!*pch) <br>         { <br>            cKeywords--; <br>            continue; <br>         } <br> <br>         // Go to end of string <br>         pch = &amp;pch[lstrlen(pch)]; <br> <br>         // Zero out trailing spaces <br>         pchPrev = AnsiPrev(szKeywords, pch); <br>         while (isspace(*pchPrev)) <br>            pchPrev = AnsiPrev(szKeywords, pchPrev); <br>         pchPrev = AnsiNext(pchPrev); <br>         ZeroMemory(pchPrev, pch - pchPrev); <br>      } <br>   } <br> <br>   // Handle denegerate case where we have no keywords. MAPI requires that <br>   // there be a value, though, so we fake up a single empty string <br>   if (!cKeywords) <br>   { <br>      cKeywords = 1; <br>      fFakeOneWord = TRUE; <br>   } <br> <br>   // Now that we know how many keywords there are, it's time to allocate <br>   // space <br>   pval-&gt;Value.MVszA.cValues = cKeywords; <br>    <br>   if (!SUCCEEDED(hr = MAPIAllocateBuffer(cKeywords * sizeof(LPSTR), (LPVOID *)&amp;pval-&gt;Value.MVszA.lppszA))) <br>   { <br>       sc = E_OUTOFMEMORY; <br>   goto CleanUp; <br>   } <br> <br>   rgsz = pval-&gt;Value.MVszA.lppszA; <br> <br>   if (fFakeOneWord) <br>   { <br>      if (!SUCCEEDED(hr = SzDupSz((LPSTR) TEXT(""), &amp;rgsz[0]))) <br>  sc = E_OUTOFMEMORY; <br>      goto CleanUp; <br>   } <br> <br>   // Find the strings we had left over <br>   pch = szKeywords; <br>   while (isz &lt; cKeywords) <br>   { <br>   if (*pch) <br>   { <br>// Remember the start of the string and then zoom to the end <br>   if ( !SUCCEEDED(hr = SzDupSz(pch, &amp;rgsz[isz++]))) <br>   { <br>   sc = E_OUTOFMEMORY; <br>   goto CleanUp; <br>   } <br>    <br>   while (*pch) <br>#ifdef DBCS <br>            pch = SzGNext(pch); <br>#else <br>            ++pch; <br>#endif <br>   } <br>      ++pch; <br>   } <br> <br>CleanUp: <br>   return sc; <br>} <br> <br> <br> <br>/* <br> * ScSaveStr <br> * <br> * Purpose: <br> *    Saves a string <br> * <br> * Arguments: <br> *    pstm              The stream to load from <br> *    psz               String pointer  <br> * <br> * Returns: <br> *    SCODE             The status code <br> */ <br>SCODE ScSaveStr(LPSTREAM pstm, LPCSTR  lpstr) <br>{ <br>   SCODEsc= S_OK; <br>   HRESULT  hr= NOERROR; <br>   DWORDdwSize= sizeof(CHAR) * (lstrlen(lpstr) + 1); <br>   ULONGcb= 0; <br> <br>   // Save string size <br>   if (hr = pstm-&gt;Write(&amp;dwSize, sizeof(DWORD), &amp;cb)) <br>      goto CleanUp; <br> <br>   // Save the string <br>   if (dwSize &amp;&amp; <br>      (hr = pstm-&gt;Write(lpstr, dwSize, &amp;cb))) <br>      goto CleanUp; <br>    <br>CleanUp: <br>   sc = GetScode(hr); <br>   return sc; <br>} <br> <br> <br>/* <br> * ScLoadStr <br> * <br> * Purpose: <br> *    Load a string <br> * <br> * Arguments: <br> *    pstm              The stream to load from <br> *    psz               String pointer  <br> * <br> * Returns: <br> *    SCODE             The status code <br> */ <br>SCODE ScLoadStr(LPSTREAM pstm, CString *lpcstring) <br>{ <br>   SCODEsc= S_OK; <br>   HRESULT  hr= NOERROR; <br>   LPSTRlpstr= NULL; <br>   DWORD    dwSize= 0; <br> <br>    <br>     // Save string size <br>   if (hr = pstm-&gt;Read(&amp;dwSize, sizeof(DWORD), NULL)) <br>      goto CleanUp; <br> <br>   // Allocate space for string and then load the string <br>   if (dwSize) <br>      hr = MAPIAllocateBuffer(dwSize, (LPVOID *)&amp;lpstr); <br>   else <br>      hr = SzDupSz((LPTSTR)TEXT(""), &amp;lpstr); <br> <br>   if (!SUCCEEDED(hr)) <br>   { <br>      sc = E_OUTOFMEMORY; <br>      goto CleanUp; <br>   } <br> <br>   if (dwSize &amp;&amp; (hr = pstm-&gt;Read(lpstr, dwSize, NULL))) <br>   { <br>      sc = GetScode(hr); <br>      goto CleanUp; <br>   } <br> <br>   *lpcstring = lpstr; <br> <br>CleanUp: <br> <br>   MAPIFREEBUFFER(lpstr); <br> <br>   return sc; <br>} <br> <br> <br> <br>/* <br> * SetSummaryInfo <br> * <br> */ <br>STDAPI SetSummaryInfo <br>   ( <br>   LPSTORAGE pstg, <br>   LPCSTRlpsTitle, <br>   LPCSTR   lpsSubject, <br>   LPCSTR   lpsAuthor, <br>   LPCSTR   lpsKeywords, <br>   LPCSTR   lpsComments <br>   ) <br>{ <br>   SCODE             sc= S_OK; <br>   HRESULT           hr= NOERROR; <br>   PROPSETHDR        propsethdr; <br>   PROPSECTIONHDR    propsectionhdr; <br>   FMTIDOFFSET*      rgfmtidoffset= NULL; <br>   FMTIDOFFSET*      pfmtidoffset= NULL; <br>   PIDOFFSET*        rgpidoffset= NULL; <br>   PIDOFFSET*        ppidoffset= NULL; <br>   PROPSETSTMINFO*   ppropsetstminfo= rgpropsetstminfo;    // point to summary info part <br>   ULONG             cb= 0; <br>   BOOL              fFound= FALSE; <br>   BOOL              fSumInfoStm= FALSE; <br>   LARGE_INTEGER     li= {0}; <br>   DWORD             dwType= 0; <br>   LPSTREAM          pstm= NULL; <br> <br>    // Open the summay info stream <br>   sc = pstg-&gt;OpenStream(ppropsetstminfo-&gt;szName, <br>                         NULL, <br>                         STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>                         0, <br>                         &amp;pstm); <br> <br>//If doesn't exist, create a new summary info stream <br>if (sc == STG_E_FILENOTFOUND) <br>sc = pstg-&gt;CreateStream(ppropsetstminfo-&gt;szName, <br>                              STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>  0, <br>  0, <br>  &amp;pstm); <br> <br> <br>   if (FAILED(sc)) <br>   goto CleanUp; <br> <br>    <br>    // Write the PropSet header <br>propsethdr.cSections= 1; <br>propsethdr.wByteOrder= 0xFFFE ; <br>propsethdr.wFormat=  0; <br>propsethdr.dwOSVer= MAKELONG(LOWORD(GetVersion()),2); <br>//propsethdr.clsid=; <br> <br>if (hr = pstm-&gt;Write(&amp;propsethdr, sizeof(propsethdr), &amp;cb)) <br>      goto WriteError; <br> <br>   // Write the FMTID/OFFSET pair <br>   cb = propsethdr.cSections * sizeof(FMTIDOFFSET); <br>    <br>   if (!SUCCEEDED(hr = MAPIAllocateBuffer(cb, (LPVOID *)&amp;rgfmtidoffset))) <br>   { <br>      sc = E_OUTOFMEMORY; <br>  goto CleanUp; <br>   } <br>    <br>   pfmtidoffset = rgfmtidoffset; <br>   pfmtidoffset-&gt;fmtid = FMTID_SumInfo; <br>   pfmtidoffset-&gt;dwOffset = sizeof(PROPSETHDR) + sizeof(FMTIDOFFSET); <br>    <br>   if (hr = pstm-&gt;Write(rgfmtidoffset, cb, &amp;cb)) <br>      goto WriteError; <br> <br>  <br>   // Seek to that location in the stream <br>   LISet32(li, pfmtidoffset-&gt;dwOffset); <br>   if (hr = pstm-&gt;Seek(li, STREAM_SEEK_SET, NULL)) <br>      goto CleanUp; <br> <br>   // Write the section header  <br>   propsectionhdr.cProps = 5; <br>   propsectionhdr.cbSection = 2 * sizeof(DWORD) + <br>  propsectionhdr.cProps * 4 * sizeof(DWORD)+  <br>  sizeof(CHAR) * (lstrlen(lpsSubject) + 1)+ <br>  sizeof(CHAR) * (lstrlen(lpsTitle) +1)+ <br>  sizeof(CHAR) * (lstrlen(lpsComments) + 1)+ <br>  sizeof(CHAR) * (lstrlen(lpsAuthor) +  1)+ <br>  sizeof(CHAR) * (lstrlen(lpsKeywords) + 1) ; <br> <br>   if (hr = pstm-&gt;Write(&amp;propsectionhdr, sizeof(propsectionhdr), NULL)) <br>      goto WriteError; <br>    <br> <br>   // Write the PID/OFFSET pairs <br>   cb = propsectionhdr.cProps * sizeof(PIDOFFSET); <br>    <br>    <br>   if (!SUCCEEDED(hr = MAPIAllocateBuffer(cb, (LPVOID *)&amp;rgpidoffset))) <br>   { <br>      sc = E_OUTOFMEMORY; <br>  goto CleanUp; <br>   } <br>   ppidoffset = rgpidoffset; <br> <br>   ppidoffset-&gt;pid = PID_TITLE;  <br>   ppidoffset-&gt;dwOffset = 12 * sizeof(DWORD); <br>   ppidoffset++; <br>   ppidoffset-&gt;pid = PID_SUBJECT;  <br>   ppidoffset-&gt;dwOffset = (ppidoffset - 1)-&gt;dwOffset +  <br>sizeof(CHAR) * (lstrlen(lpsTitle) + 1) + sizeof(DWORD)*2; <br>   ppidoffset++; <br>   ppidoffset-&gt;pid = PID_AUTHOR;  <br>   ppidoffset-&gt;dwOffset = (ppidoffset - 1)-&gt;dwOffset +  <br>sizeof(CHAR) * (lstrlen(lpsSubject) + 1) + sizeof(DWORD)*2; <br>   ppidoffset++; <br>   ppidoffset-&gt;pid = PID_COMMENTS;  <br>   ppidoffset-&gt;dwOffset = (ppidoffset - 1)-&gt;dwOffset +  <br>sizeof(CHAR) * (lstrlen(lpsAuthor) + 1) + sizeof(DWORD)*2; <br>   ppidoffset++; <br>   ppidoffset-&gt;pid = PID_KEYWORDS;  <br>   ppidoffset-&gt;dwOffset = (ppidoffset - 1)-&gt;dwOffset + <br>sizeof(CHAR) * (lstrlen(lpsComments) + 1) + sizeof(DWORD)*2; <br>   ppidoffset = rgpidoffset; <br> <br>   if (hr = pstm-&gt;Write(rgpidoffset, cb, NULL)) <br>      goto WriteError; <br> <br>   // Go through all the properties <br>   for (; propsectionhdr.cProps--; ++ppidoffset) <br>   { <br>      // Seek to the data <br>      LISet32(li, ppidoffset-&gt;dwOffset + pfmtidoffset-&gt;dwOffset); <br>      if (hr = pstm-&gt;Seek(li, STREAM_SEEK_SET, NULL)) <br>         goto CleanUp; <br> <br>      // Write the type and property value <br>      hr = NOERROR; <br>      switch (ppidoffset-&gt;pid) <br>      { <br>      case PID_TITLE: <br> <br>  dwType = PT_STRING8; <br>  if (hr = pstm-&gt;Write(&amp;dwType, sizeof(DWORD), &amp;cb)) <br>goto WriteError; <br>         sc = ScSaveStr(pstm, lpsTitle); <br>         break; <br> <br>      case PID_SUBJECT: <br>   <br>  dwType = PT_STRING8; <br>  if (hr = pstm-&gt;Write(&amp;dwType, sizeof(DWORD), &amp;cb)) <br>goto WriteError; <br> <br>          sc = ScSaveStr(pstm, lpsSubject); <br>          break; <br> <br>      case PID_AUTHOR: <br>          <br>  dwType = PT_STRING8; <br>  if (hr = pstm-&gt;Write(&amp;dwType, sizeof(DWORD), &amp;cb)) <br>goto WriteError; <br>  <br>  sc = ScSaveStr(pstm, lpsAuthor); <br>  break; <br> <br>      case PID_KEYWORDS: <br>           <br>  dwType = PT_MV_STRING8; <br>  if (hr = pstm-&gt;Write(&amp;dwType, sizeof(DWORD), &amp;cb)) <br>goto WriteError; <br> <br>  sc = ScSaveStr(pstm, lpsKeywords); <br>  break; <br> <br>      case PID_COMMENTS: <br>         <br>  dwType = PT_STRING8; <br>  if (hr = pstm-&gt;Write(&amp;dwType, sizeof(DWORD), &amp;cb)) <br>  goto WriteError; <br> <br>  sc = ScSaveStr(pstm, lpsComments); <br>          break; <br> <br>      default: <br>         continue; <br>         break; <br>      } <br>      if (hr) goto WriteError; <br>   } <br> <br>   pstm-&gt;Commit(STGC_DEFAULT); <br> <br>   goto CleanUp; <br> <br>WriteError: <br>   sc = GetScode(hr); <br> <br>CleanUp: <br>   MAPIFREEBUFFER(rgfmtidoffset); <br>   MAPIFREEBUFFER(rgpidoffset); <br>   ULRELEASE(pstm); <br>   return sc; <br>} <br> <br> <br> <br> <br>/* <br> * GetSummaryInfo <br> * <br> */ <br>STDAPI GetSummaryInfo <br>   ( <br>   LPSTORAGE  pstg, <br>   CString*  lpsTitle, <br>   CString*   lpsSubject, <br>   CString*   lpsAuthor, <br>   CString*   lpsKeywords, <br>   CString*   lpsComments <br>   ) <br>{ <br>   SCODE             sc= S_OK; <br>   HRESULT           hr= NOERROR; <br>   PROPSETHDR        propsethdr; <br>   PROPSECTIONHDR    propsectionhdr; <br>   FMTIDOFFSET*      rgfmtidoffset= NULL; <br>   FMTIDOFFSET*      pfmtidoffset= NULL; <br>   PIDOFFSET*        rgpidoffset= NULL; <br>   PIDOFFSET*        ppidoffset= NULL; <br>   PROPSETSTMINFO*   ppropsetstminfo = rgpropsetstminfo;    // point to summary info part <br>   ULONG             cb= 0; <br>   BOOL              fFound= FALSE; <br>   BOOL              fSumInfoStm= FALSE; <br>   LARGE_INTEGER     li={0}; <br>   DWORD             dwType= 0; <br>   LPSTREAM          pstm= NULL; <br> <br>      <br>   *lpsTitle   = TEXT(""); <br>   *lpsSubject = TEXT(""); <br>   *lpsAuthor    = TEXT(""); <br>   *lpsKeywords= TEXT(""); <br>   *lpsComments= TEXT(""); <br>    <br>   // Open the summay info stream <br>   sc = pstg-&gt;OpenStream(ppropsetstminfo-&gt;szName, <br>                         NULL, <br>                         STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>                         0, <br>                         &amp;pstm); <br>   if (FAILED(sc)) <br>      { <br>      goto CleanUp; <br>      } <br> <br>   // Read the header to find out how many sections we need to search <br>   if (hr = pstm-&gt;Read(&amp;propsethdr, sizeof(propsethdr), NULL)) <br>      goto ReadError; <br>   if (propsethdr.cSections == 0) <br>      goto CleanUp; <br> <br>   // Allocate space for the sections list and read it in <br>   cb = propsethdr.cSections * sizeof(FMTIDOFFSET); <br>       <br>   if (!SUCCEEDED(hr = MAPIAllocateBuffer(cb, (LPVOID *)&amp;rgfmtidoffset))) <br>   { <br>      sc = E_OUTOFMEMORY; <br>  goto CleanUp; <br>   } <br>   pfmtidoffset = rgfmtidoffset; <br> <br>   if (hr = pstm-&gt;Read(rgfmtidoffset, cb, NULL)) <br>      goto ReadError; <br> <br>   // Look for the section with the matching FMTID <br>   for (fFound = FALSE; propsethdr.cSections--; ++pfmtidoffset) <br>   { <br>      if (IsEqualGUID(*ppropsetstminfo-&gt;pfmtid, pfmtidoffset-&gt;fmtid)) <br>      { <br>         fFound = TRUE; <br>         break; <br>      } <br>   } <br>   if (!fFound) <br>      goto CleanUp; <br> <br>   // Are we in the SumInfo stream <br>   fSumInfoStm = IsEqualGUID(*ppropsetstminfo-&gt;pfmtid, FMTID_SumInfo); <br> <br>   // Seek to that location in the stream <br>   LISet32(li, pfmtidoffset-&gt;dwOffset); <br>   if (hr = pstm-&gt;Seek(li, STREAM_SEEK_SET, NULL)) <br>      goto ReadError; <br> <br>   // Read the section header to find out how many props we need to read <br>   if (hr = pstm-&gt;Read(&amp;propsectionhdr, sizeof(propsectionhdr), NULL)) <br>      goto ReadError; <br>   if (propsectionhdr.cProps == 0) <br>      goto CleanUp; <br> <br>   // Allocate space for the props list and read it in <br>   cb = propsectionhdr.cProps * sizeof(PIDOFFSET); <br>       <br>   if (!SUCCEEDED(hr = MAPIAllocateBuffer(cb, (LPVOID *)&amp;rgpidoffset))) <br>   { <br>      sc = E_OUTOFMEMORY; <br>  goto CleanUp; <br>   } <br> <br>   ppidoffset = rgpidoffset; <br> <br>   if (hr = pstm-&gt;Read(rgpidoffset, cb, NULL)) <br>      goto ReadError; <br> <br>   // Go through all the properties <br>   for (; propsectionhdr.cProps--; ++ppidoffset) <br>   { <br>      // Seek to the data <br>      LISet32(li, ppidoffset-&gt;dwOffset + pfmtidoffset-&gt;dwOffset); <br>      if (hr = pstm-&gt;Seek(li, STREAM_SEEK_SET, NULL)) <br>         goto ReadError; <br> <br>      // Read the type <br>      if (hr = pstm-&gt;Read(&amp;dwType, sizeof(DWORD), NULL)) <br>         goto ReadError; <br> <br> <br>  // Load the data <br>      hr = NOERROR; <br>      switch (ppidoffset-&gt;pid) <br>      { <br>      case PID_TITLE: <br>         sc = ScLoadStr(pstm, lpsTitle); <br>         break; <br> <br>      case PID_SUBJECT: <br>         sc = ScLoadStr(pstm, lpsSubject); <br>         break; <br> <br>      case PID_AUTHOR: <br>         sc = ScLoadStr(pstm, lpsAuthor); <br>         break; <br> <br>      case PID_KEYWORDS: <br> sc = ScLoadStr(pstm, lpsKeywords); <br>         break; <br> <br>      case PID_COMMENTS: <br>         sc = ScLoadStr(pstm, lpsComments); <br>         break; <br> <br>      default: <br>         continue; <br>         break; <br>      } <br>      if (hr) goto ReadError; <br>   } <br> <br>   goto CleanUp; <br> <br>ReadError: <br>   sc = GetScode(hr); <br> <br>CleanUp: <br>   MAPIFREEBUFFER(rgfmtidoffset); <br>   MAPIFREEBUFFER(rgpidoffset); <br>   ULRELEASE(pstm); <br>   return sc; <br>} <br> <br> <br> <br>/* <br> * PromoteSummaryInfo <br> * <br> */ <br> STDAPI PromoteSummaryInfo <br>   ( <br>   LPMESSAGE   pmsg, <br>   LPSTR     lpszTitle, <br>   LPSTR     lpszSubject, <br>   LPSTR     lpszAuthor, <br>   LPSTR     lpszKeywords, <br>   LPSTR     lpszComments <br>   ) <br>{ <br>   CONST UINT        cProps = 5; <br>   HRESULT           hr= E_OUTOFMEMORY; <br>   UINT              i= 0; <br>   MPPIDMAPIPROP*    pmppidmapipropSumInfo = &amp;mppidmapipropSumInfo[2];  // start at szTitle <br>   LPMAPINAMEID*     rgpmnid = NULL; <br>   LPMAPINAMEID      rgmnid = NULL; <br>   LPSPropTagArray   ptaga = NULL; <br>   SPropValue        rgvalSumInfo[cProps]; <br> <br>   if (SUCCEEDED(hr = MAPIAllocateBuffer( cProps * sizeof(LPMAPINAMEID), (LPVOID *)&amp;rgpmnid))) <br>   { <br>      if (SUCCEEDED(hr = MAPIAllocateBuffer(cProps * sizeof(MAPINAMEID), (LPVOID*)&amp;rgmnid))) <br>      { <br>         // Initialize the name id structure and the array of pointers to the name id structurs <br>         for (i = 0; i &lt; cProps; i++) <br>         { <br>            rgmnid[i].lpguid          = (LPGUID)&amp;PS_PUBLIC_STRINGS; <br>            rgmnid[i].ulKind          = MNID_STRING; <br>            rgmnid[i].Kind.lpwstrName = pmppidmapipropSumInfo[i].szW; <br>            rgpmnid[i] = &amp;rgmnid[i]; <br>         } <br> <br>         if (SUCCEEDED(hr = pmsg-&gt;GetIDsFromNames(cProps, rgpmnid, MAPI_CREATE, &amp;ptaga))) <br>         { <br>            if (cProps == ptaga-&gt;cValues) <br>            { <br>               // Plug the IDs into the values <br>               for (i = 0; i &lt; cProps &amp;&amp; SUCCEEDED(hr);  i++) <br>               { <br>                  rgvalSumInfo[i].ulPropTag = PROP_TAG(pmppidmapipropSumInfo[i].wMapiType, <br>                                                       PROP_ID(ptaga-&gt;aulPropTag[i])); <br> <br>                  switch (i) <br>                  { <br>                     case 0: <br>                        rgvalSumInfo[i].Value.lpszA = (LPTSTR)lpszTitle; <br>                        break; <br>                     case 1: <br>                        rgvalSumInfo[i].Value.lpszA = (LPTSTR)lpszSubject; <br>                        break; <br>                     case 2: <br>                        rgvalSumInfo[i].Value.lpszA = (LPTSTR)lpszAuthor; <br>                        break; <br>                     case 3: <br>                     { <br>                        rgvalSumInfo[i].Value.lpszA = (LPTSTR)lpszKeywords; <br> <br>                        hr = ScParseKeywords(&amp;rgvalSumInfo[i], TEXT(";")); <br>                     } <br>                        break; <br>                     case 4: <br>                        rgvalSumInfo[i].Value.lpszA = (LPTSTR)lpszComments; <br>                        break; <br>                  } <br>             <br>               } <br> <br>               if (SUCCEEDED(hr)) <br>               { <br>                  // Set the values <br>                  hr = pmsg-&gt;SetProps(cProps, rgvalSumInfo, NULL); <br>               } <br> <br>               // Free our prop tag array <br>               MAPIFREEBUFFER(ptaga); <br>            } <br>         } <br>         MAPIFREEBUFFER(rgmnid); <br>      } <br>      MAPIFREEBUFFER(rgpmnid); <br>   } <br> <br>   return hr; <br>} <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
