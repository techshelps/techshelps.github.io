<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POSTDATA.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1928"></a>POSTDATA.CPP</h2>
<pre><code>//========================================================================= <br>// PostData.CPP <br>// <br>// Copyright (C) 1986-1996.  Microsoft Corp.  All Rights Reserved. <br>//  <br>// <br>// Purpose: <br>//    implementation of the CPostData class <br>// <br>//========================================================================= <br> <br> <br>#include "stdafx.h" <br>#include "PostSmpl.h" <br>#include "PostData.h" <br>#include "fldpick.h" <br>#include "freedoc.h" <br> <br> <br>CPostDataPostData; <br> <br> <br>const CHARcBackSlash='\\';// backslash character <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br> <br> <br> //------------------------------------------------------------------------- <br>// Purpose: <br>//    Open a message store if we don't already have it open. <br>// <br>//static <br>HRESULT CPostData::OpenMsgStore <br>   ( <br>   ULONG      cbeid, <br>   LPENTRYID  peid, <br>   LPMDB  *lppMDB <br>   ) <br>{ <br>   HRESULT  hr             = NOERROR; <br>   ULONG    fulIsSameStore = FALSE; <br>   INTnStore   = 0; <br>   INTii   = 0; <br>    <br>   for (ii = 0; ii &lt; nMaxStores; ii++) <br>   { <br>   if (m_pcbeidStore[ii]) <br>{ <br>// If we have a store already open, then simply return <br>hr = m_lpSession-&gt;CompareEntryIDs(cbeid, <br>                       peid, <br>                   m_pcbeidStore[ii], <br>               m_lppeidStore[ii], <br>           0, <br>       &amp;fulIsSameStore);  // fulIsSameStore == TRUE if match <br>if (SUCCEEDED(hr) &amp;&amp; fulIsSameStore) <br>{  <br>*lppMDB = m_lppMDB[ii]; <br>return hr; <br>} <br>} <br>   } <br> <br>    //Find next available slot  <br>   BOOL bFound = FALSE; <br>    for (ii = 0; ii &lt; nMaxStores &amp; !bFound; ii++) <br>{ <br>if (!m_pcbeidStore[ii]) <br>{ <br>nStore = ii; <br>bFound = TRUE; <br>} <br>} <br> <br>if (nStore == nMaxStores) <br>{ <br>hr = E_FAIL; <br>return hr; <br>} <br> <br>   // Open the new one. <br>   hr = m_lpSession-&gt;OpenMsgStore(NULL, <br>                             cbeid, <br>                             peid, <br>                             &amp;IID_IMsgStore, <br>                             MDB_WRITE | MAPI_DEFERRED_ERRORS, <br>                             &amp;m_lppMDB[nStore]); <br>    if (SUCCEEDED(hr)) <br>{ <br>  // Save the entry of the one we just opened in case we get called later. <br>  if (SUCCEEDED(hr = MAPIAllocateBuffer(cbeid, (LPVOID*)&amp;m_lppeidStore[nStore]))) <br>  { <br>CopyMemory(m_lppeidStore[nStore], peid, cbeid); <br>m_pcbeidStore[nStore] = cbeid; <br>          <br>  } <br>} <br>    <br>   *lppMDB = m_lppMDB[nStore]; <br>   return hr; <br>} <br> <br> <br>//------------------------------------------------------------------------- <br>// Purpose: <br>//    Logoff of the open message store and release it. <br>// <br>//static <br>void CPostData::LogoffMessageStore(VOID) <br>{ <br>for( INT ii = 0; ii &lt; nMaxStores; ii++) <br>{ <br>HRESULT hr = NOERROR; <br>if (m_lppMDB[ii]) <br>{ <br>ULONG ulFlags = LOGOFF_ORDERLY; <br>if (FAILED(hr = m_lppMDB[ii]-&gt;StoreLogoff(&amp;ulFlags))) <br>{        <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("LogoffMessageStore:StoreLogoff failed"); <br>#endif <br>} <br> <br>m_lppMDB[ii]-&gt;Release(); <br>m_lppMDB[ii]       = NULL; <br>m_pcbeidStore[ii]  = 0; <br>MAPIFreeBuffer(m_lppeidStore[ii]); <br>m_lppeidStore[ii]  = NULL; <br>} <br>} <br>} <br> <br> <br>     <br>HRESULT CPostData::HrInitialize() <br>{ <br>HRESULT hr   = NOERROR; <br>LPMAPITABLE pTable = NULL; <br>    LPSRowSetpRows  = NULL; <br>INTii   = 0; <br> <br> <br>// Initialize MAPI. <br>    hr = MAPIInitialize( NULL); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>     <br>    fMAPIInitialized = TRUE; <br> <br>// Open session  <br>    hr = MAPILogonEx(NULL,// UI flags, <br>                NULL,    // profile name <br>                NULL,               // password <br>                MAPI_NEW_SESSION | MAPI_LOGON_UI | MAPI_ALLOW_OTHERS,            // MAPI flags <br>                &amp;m_lpSession); <br> <br> <br>if FAILED(hr) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("HrInitialize:MAPILogonEx failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>   <br>// Open the address book and get the user entryid. <br>hr = m_lpSession-&gt;OpenAddressBook(0, NULL, AB_NO_DIALOG, &amp;m_lpAdrBook); <br> <br>if (FAILED(hr)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("HrInitialize:OpenAddressBook failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>//Get the number of stores in available session <br>if(SUCCEEDED( hr = m_lpSession-&gt;GetMsgStoresTable (0, &amp;pTable))) <br>{ <br>        hr = HrQueryAllRows (pTable, <br>                             NULL, <br>                             NULL, <br>                             NULL, <br>                             0, <br>                             &amp;pRows); <br> <br>nMaxStores = pRows-&gt;cRows; <br>} <br> <br>// Allocate all the store handles and entryids <br>hr = MAPIAllocateBuffer(pRows-&gt;cRows * sizeof(LPMDB), (LPVOID *)&amp;m_lppMDB); <br>if (FAILED(hr)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("HrInitialize:MAPIAllocateBuffer failed"); <br>#endif <br>goto cleanup; <br>} <br> <br> <br>hr = MAPIAllocateBuffer(pRows-&gt;cRows * sizeof(ULONG), (LPVOID *)&amp;m_pcbeidStore); <br>if (FAILED(hr)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("HrInitialize:MAPIAllocateBuffer failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>hr = MAPIAllocateBuffer(pRows-&gt;cRows * sizeof(LPENTRYID), (LPVOID *)&amp;m_lppeidStore); <br>if (FAILED(hr)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("HrInitialize:MAPIAllocateBuffer failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>for (ii = 0; ii &lt; nMaxStores; ii++) <br>{ <br>m_lppMDB[ii]  = NULL; <br>m_pcbeidStore[ii] = 0; <br>m_lppeidStore[ii] = NULL; <br>} <br> <br>if ( !CreateImageListExchange() ) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("HrInitialize:CreateImageListExchange failed"); <br>#endif <br>goto cleanup; <br>} <br> <br> <br>cleanup: <br>if (FAILED(hr)) <br>HrUninitialize(); <br> <br>return hr; <br> <br>} <br> <br> <br>HRESULT CPostData::HrUninitialize() <br>{ <br>HRESULT hr = NOERROR; <br> <br>if (m_lpAdrBook) <br>m_lpAdrBook-&gt;Release(); <br> <br>if (m_lpSession) <br>{ <br>   LogoffMessageStore(); <br>hr = m_lpSession-&gt;Logoff(0, 0, 0); <br>m_lpSession-&gt;Release(); <br>} <br> <br>if( fMAPIInitialized ) <br>MAPIUninitialize(); <br> <br>m_obImageListExchange.DeleteImageList(); <br> <br>return hr; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CPostData <br> <br>CPostData::CPostData() <br>{ <br>m_lpSession= NULL; <br>m_lpAdrBook= NULL; <br>fMAPIInitialized= FALSE; <br>m_lpTempFld= NULL; <br> <br>nMaxStores= 5; <br>m_pcbeidStore= NULL;  <br>m_lppeidStore= NULL; <br>m_lppMDB= NULL;      <br> <br> <br>szFile= TEXT(""); <br>szFileTitle = TEXT(""); <br>m_psTitle= TEXT(""); <br>m_psAuthor= TEXT(""); <br>m_psComments= TEXT(""); <br>m_psKeywords= TEXT(""); <br>m_psSubject= TEXT(""); <br>m_psTitle= TEXT(""); <br>  <br>} <br> <br>CPostData::~CPostData() <br>{ <br>szFile.Empty(); <br>szFileTitle.Empty(); <br>m_psAuthor.Empty();  <br>m_psComments.Empty(); <br>m_psKeywords.Empty(); <br>m_psSubject.Empty();  <br>m_psTitle.Empty();   <br>} <br> <br> <br> <br>//------------------------------------------------------------------------- <br>// Purpose: <br>//    Create our global image list used to draw mail items. <br>// <br>//  <br>BOOL CPostData::CreateImageListExchange(VOID) <br>{ <br>   BOOL  fRet = FALSE; <br> <br>   static struct SImageListInfo <br>  { <br>UINT  nIdIcon; <br>      } aImageListInfo[cimlExchange] = { ICO_Exchange, <br> ICO_Exchange, <br> ICO_Mdb, <br> ICO_MdbOpen, <br> ICO_Folder, <br> ICO_FolderOpen, <br> ICO_DefaultMdb, <br> ICO_DefaultMdbOpen, <br>   }; <br> <br>   if (m_obImageListExchange.Create(cxSmallIcon, cySmallIcon, TRUE, cimlExchange, 1)) <br>   { <br>UINT ii= 0; <br>HICON hicon = NULL; <br> <br>for (ii = 0; ii &lt; cimlExchange; ii++) <br>{ <br>         hicon = theApp.LoadIcon(MAKEINTRESOURCE(aImageListInfo[ii].nIdIcon)); <br>if (hicon) <br>{ <br>if (-1 == m_obImageListExchange.Add(hicon)) <br>            break; <br>            } <br>        } <br> <br>fRet = (cimlExchange == ii); <br>      } <br> <br>   return fRet; <br>} <br> <br> <br>BOOL CPostData::FilePost(LPSTORAGE pstg) <br>{ <br>BOOL fRet  = FALSE; <br>HRESULT hr = NOERROR; <br>CFolderPicker  FilePostDlg; <br>CString szTitle; <br>CString szSubject; <br>CString szAuthor; <br>CString szKeywords; <br>CString szComments; <br> <br>fRet = (FilePostDlg.DoModal() == IDOK); <br> <br>if (!fRet) <br>goto cleanup; <br>    <br>if (m_lpTempFld == NULL) <br>{ <br>fRet = FALSE; <br>goto cleanup; <br>} <br> <br> <br>GetSummaryInfo(pstg, &amp;szTitle, &amp;szSubject, &amp;szAuthor, &amp;szKeywords, &amp;szComments); <br> <br>// Create the free doc <br>hr = ScCreateFreeDoc( pstg, <br>m_lpTempFld, <br>                           (LPSTR)(LPCSTR)szFile, <br>   (LPSTR)(LPCSTR)szFileTitle, <br>                           (LPSTR)(LPCSTR)szTitle, <br>                   (LPSTR)(LPCSTR)szSubject, <br>                           (LPSTR)(LPCSTR)szAuthor, <br>                           (LPSTR)(LPCSTR)szKeywords, <br>                           (LPSTR)(LPCSTR)szComments); <br>if (FAILED(hr)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("Post Doc failed"); <br>#endif <br>fRet = FALSE; <br>goto cleanup; <br>} <br> <br>cleanup: <br>if (m_lpTempFld) <br>{ <br>m_lpTempFld-&gt;Release(); <br>m_lpTempFld = NULL; <br>} <br>  return fRet; <br>} <br> <br> <br> <br>void CPostData::CreateAndPostMessage() <br>{ <br>HRESULThResult= NOERROR; <br>SCODEsCode= S_OK; <br>LPMESSAGEpMessage= NULL; <br>FLAGSfCreateMessageFlags= 0L; <br>LPSPropValuepMessagePropValues= NULL; <br>ULONGcbSenderEntryIDSize= 0; <br>LPENTRYIDpSenderEntryID= NULL; <br>ULONGuObjectType= 0; <br>ULONGuCount= 0; <br>LPMAPIPROPpSender= NULL; <br>static SizedSPropTagArray(1, aSenderProps) = {1L, PR_DISPLAY_NAME}; <br>LPSPropValuepSenderProps= NULL; <br>BOOLfRet= FALSE; <br>UINTc= 0; <br>UINTuSize= 20; <br> <br>CFolderPicker  FilePostDlg; <br>    fRet = (FilePostDlg.DoModal() == IDOK); <br> <br>if (!fRet)  <br>goto cleanup; <br> <br>   if (m_lpTempFld == NULL) <br>goto cleanup; <br> <br>//Recover sender information <br>hResult = m_lpSession-&gt;QueryIdentity(&amp;cbSenderEntryIDSize,&amp;pSenderEntryID); <br> <br>if (HR_FAILED(hResult)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("CreateAndPostMessage(): QueryIdentiry failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>hResult = m_lpSession-&gt;OpenEntry(cbSenderEntryIDSize, <br>pSenderEntryID, <br>NULL, <br>MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>&amp;uObjectType, <br>(LPUNKNOWN FAR *)&amp;pSender); <br> <br>   if (HR_FAILED(hResult)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("CreateAndPostMessage(): OpenEntry failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>hResult = pSender-&gt;GetProps((LPSPropTagArray)&amp;aSenderProps, <br>0, <br>&amp;uCount, <br>&amp;pSenderProps); <br> <br>if (FAILED(hResult)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("CreateAndPostMessage(): GetProps failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>_ASSERT(pSenderProps[0].ulPropTag == PR_DISPLAY_NAME); <br> <br>//Create a message in the folder. <br>hResult = m_lpTempFld-&gt;CreateMessage(NULL,fCreateMessageFlags,&amp;pMessage); <br> <br>if (HR_FAILED(hResult)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("CreateAndPostMessage(): CreateMessage failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>//Grab memory for a message property array <br>sCode = MAPIAllocateBuffer(uSize * sizeof(SPropValue),(void **)&amp;pMessagePropValues); <br> <br>if (FAILED(sCode)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("CreateAndPostMessage(): MAPIAllocateBuffer failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>//Set some properties on the message. <br>pMessagePropValues[c  ].ulPropTag = PR_MESSAGE_CLASS; <br>pMessagePropValues[c++].Value.lpszA = "IPM.POST"; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_SUBJECT; <br>pMessagePropValues[c++].Value.lpszA = ""; <br> <br>//////////////////////////////////////////////////////////////// <br>// This property PR_BODY needs to be set with approriate text. <br>// PR_BODY property holds the message body text. <br>// Here it is modified with edit box text. <br>///////////////////////////////////////////////////////////////// <br> <br>pMessagePropValues[c  ].ulPropTag = PR_BODY; <br>pMessagePropValues[c++].Value.lpszA = (LPSTR)(LPCSTR)theApp.m_lpBuffer; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_SENDER_ENTRYID; <br>pMessagePropValues[c  ].Value.bin.cb = cbSenderEntryIDSize; <br>pMessagePropValues[c++].Value.bin.lpb = (LPBYTE)pSenderEntryID; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_SENDER_NAME; <br>pMessagePropValues[c++].Value.lpszA = pSenderProps[0].Value.lpszA; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_SENT_REPRESENTING_ENTRYID; <br>pMessagePropValues[c  ].Value.bin.cb = cbSenderEntryIDSize; <br>pMessagePropValues[c++].Value.bin.lpb = (LPBYTE)pSenderEntryID; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_SENT_REPRESENTING_NAME; <br>pMessagePropValues[c++].Value.lpszA = pSenderProps[0].Value.lpszA; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_DELETE_AFTER_SUBMIT; <br>pMessagePropValues[c++].Value.b = 0; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED; <br>pMessagePropValues[c++].Value.b = 0; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_READ_RECEIPT_REQUESTED; <br>pMessagePropValues[c++].Value.b = 0; <br> <br>pMessagePropValues[c  ].ulPropTag = PR_PRIORITY; <br>pMessagePropValues[c++].Value.ul = PRIO_NORMAL; <br> <br>//Test that the property array has not been overrun <br>_ASSERT(c &lt;= uSize); <br> <br>//Write message properties. <br>hResult = pMessage-&gt;SetProps(c,pMessagePropValues,NULL); <br>if (HR_FAILED(hResult)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("CreateAndPostMessage(): SetProps failed"); <br>#endif <br>goto cleanup; <br>} <br> <br>//Clear the read flag.  This operation requires a <br>//separate MAPI call. <br>pMessage-&gt;SetReadFlag(CLEAR_READ_FLAG); <br> <br>//Save changes made to the message <br>hResult = pMessage-&gt;SaveChanges(FORCE_SAVE); <br>if (HR_FAILED(hResult)) <br>{ <br>#ifdef _DEBUG <br>afxDump &lt;&lt; TEXT("CreateAndPostMessage(): SaveChanges failed"); <br>#endif <br> <br>goto cleanup; <br>} <br> <br>cleanup: <br>//Release MAPI objects <br>if (pMessage) <br>pMessage-&gt;Release(); <br>if (pSender) <br>pSender-&gt;Release(); <br> <br>//Free memory allocations <br>if (m_lpTempFld) <br>m_lpTempFld-&gt;Release(); <br> <br>MAPIFreeBuffer(pMessagePropValues); <br>MAPIFreeBuffer(pSenderEntryID); <br>MAPIFreeBuffer(pSenderProps); <br>} <br> <br> <br> <br>BEGIN_MESSAGE_MAP(CPostData, CWnd) <br>//{{AFX_MSG_MAP(CPostData) <br>// NOTE - the ClassWizard will add and remove mapping macros here. <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CPostData message handlers </code></pre>
<p>&nbsp;</p></body>
</HTML>
