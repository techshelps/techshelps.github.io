<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FREEDOC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1924"></a>FREEDOC.CPP</h2>
<pre><code>//========================================================================= <br>// FREEDOC.CPP <br>// <br>// Copyright (C) 1986-1996.  Microsoft Corp.  All Rights Reserved. <br>// <br>// Purpose: <br>//    Provides free-floating document routines. <br>// <br>//========================================================================= <br> <br>#include "stdafx.h" <br>#include &lt;windowsx.h&gt; <br>#include &lt;winnls.h&gt; <br>#include &lt;mapinls.h&gt; <br> <br>#include "PostSmpl.h" <br>#include "freedoc.h" <br>#include "PostData.h" <br>#include "edk.h" <br> <br>#define cbReadMax         8192 <br>#define cchPathNameMax    320 <br> <br> <br> <br>enum { <br>   ivalAttAttachMethod, <br>   ivalAttRenderingPosition, <br>   ivalAttAttachRendering, <br>   ivalAttAttachFilename, <br>   ivalAttAttachLongFilename, <br>   ivalAttCreationTime, <br>   ivalAttLastModificationTime, <br>   cvalAttMax <br>}; <br> <br>/* <br> * CREATEFREEDOC declarations <br> */ <br>enum { <br>   ivalMsgSubject, <br>   ivalMsgSenderName, <br>   ivalMsgSentRepresentingName, <br>   ivalMsgClientSubmitTime, <br>   ivalMsgMessageDeliveryTime, <br>   ivalMsgMessageClass, <br>   ivalMsgMessageFlags, <br>   ivalMsgSentRepresentingEntryid, <br>   ivalMsgSenderEntryid, <br>   ivalMsgSentRepresentingSearchKey, <br>   ivalMsgSenderSearchKey, <br>   ivalMsgIcon, <br>   ivalMsgImportance, <br>   ivalMsgPriority, <br>   ivalMsgSensitivity, <br>   ivalMsgLastModificationTime, <br>   cvalMsgMax <br>}; <br> <br> <br>typedef struct <br>{ <br>   LPTSTR         lpszPathName; <br>   LPTSTR         lpszFileName; <br>   LPMESSAGE      pmsg; <br>   LPATTACH       patt; <br>   SPropValue     rgvalAtt[cvalAttMax]; <br>   SPropValue     rgvalMsg[cvalMsgMax]; <br>    <br>} CREATEFREEDOC; <br> <br> <br>// Added to PROPSET.CPP <br>STDAPI PromoteSummaryInfo <br>   ( <br>   LPMESSAGE   pmsg, <br>   LPSTR     lpszTitle, <br>   LPSTR     lpszSubject, <br>   LPSTR     lpszAuthor, <br>   LPSTR     lpszKeywords, <br>   LPSTR     lpszComments <br>   ); <br> <br> <br>// Commonly used LARGE_INTEGER <br>static LARGE_INTEGER liZero = { 0 }; <br>// Message classes: note class and IPM root class <br>CONST CHAR szIPMDocument[] = TEXT("IPM.Document"); <br> <br>static SCODE ScLoadAttachDataFromFile(LPSTORAGE pstg, LPTSTR lpszFileName, LPATTACH patt); <br>static BOOL FGetFileTimes(LPTSTR lpszPathName, FILETIME * pftCreate, FILETIME * pftModify); <br>static HRESULT HrInitAttachment( <br>      LPMESSAGE pmsg, <br>      LPATTACH * ppatt, <br>      LPSPropValue rgvalAtt, <br>      LPTSTR lpszPathName, <br>      LPTSTR lpszFileName); <br>       <br>static HGLOBAL HmfpGetIconForFile(LPTSTR lpszPathName, LPTSTR lpszFileName); <br>static SCODE   ScGetRenderBits(HGLOBAL hmfp, ULONG * pcb, LPBYTE * ppb); <br>static void    OleUIMetafilePictIconFree(HGLOBAL); <br> <br> <br>/* <br> * HrInitAttachment <br> * <br> * Purpose: <br> *    Initialize a message with a file attachment <br> * <br> * Arguments: <br> *    pmsg           Message to add the attachment to <br> *    ppatt          Where to put the attachment <br> *    rgvalAtt       Properties for the attachment <br> *    lpszFileName        Name of the file <br>  <br> * <br> * Returns: <br> *    SCODE       the status code; <br> */ <br>HRESULT HrInitAttachment( <br>      LPMESSAGE pmsg, <br>      LPATTACH * ppatt, <br>      LPSPropValue rgvalAtt, <br>      LPTSTR lpszPathName, <br>      LPTSTR lpszFileName) <br>  <br>{ <br>   HRESULT        hr; <br>   ULONG       ulAttachNum; <br>   SYSTEMTIME     st; <br>   SCODE       sc; <br>   HGLOBAL        hmfp = NULL; <br> <br>   rgvalAtt[ivalAttAttachRendering].Value.bin.lpb = NULL; <br>   <br>   // Copy the file as an attachment <br>   if (FAILED(hr = pmsg-&gt;CreateAttach( <br>         NULL, <br>         MAPI_DEFERRED_ERRORS, <br>         &amp;ulAttachNum, <br>         ppatt))) <br>   { <br>      #ifdef _DEBUG <br>  afxDump &lt;&lt; TEXT("HrInitAttachment():CreateAttach() failed"); <br>  #endif <br> <br>      goto CleanUp; <br>   } <br> <br>    <br>   GetSystemTime(&amp;st); <br>   SystemTimeToFileTime(&amp;st, &amp;rgvalAtt[ivalAttCreationTime].Value.ft); <br> <br>   // Make assumptions about the file time properties <br>   rgvalAtt[ivalAttCreationTime].ulPropTag = PR_CREATION_TIME; <br>   rgvalAtt[ivalAttLastModificationTime].ulPropTag = PR_LAST_MODIFICATION_TIME; <br>   rgvalAtt[ivalAttLastModificationTime].Value.ft = <br>         rgvalAtt[ivalAttCreationTime].Value.ft; <br> <br>   // Save various properties <br>   rgvalAtt[ivalAttAttachMethod].ulPropTag = PR_ATTACH_METHOD; <br>   rgvalAtt[ivalAttAttachMethod].Value.l = ATTACH_BY_VALUE; <br>   rgvalAtt[ivalAttRenderingPosition].ulPropTag = PR_RENDERING_POSITION; <br>   rgvalAtt[ivalAttRenderingPosition].Value.l = -1; <br>   rgvalAtt[ivalAttAttachFilename].ulPropTag = PR_ATTACH_FILENAME; <br>   rgvalAtt[ivalAttAttachFilename].Value.LPSZ = lpszFileName; <br>   rgvalAtt[ivalAttAttachLongFilename].ulPropTag = PR_ATTACH_LONG_FILENAME; <br>   rgvalAtt[ivalAttAttachLongFilename].Value.LPSZ = lpszFileName; <br> <br>   // Also need to set icon for the attachment <br>   // Determine the icon to use with this file <br>   rgvalAtt[ivalAttAttachRendering].ulPropTag = PR_ATTACH_RENDERING; <br>   hmfp = HmfpGetIconForFile(lpszPathName, lpszFileName); <br>   if (!hmfp) <br>   { <br>      hr = ResultFromScode(E_OUTOFMEMORY); <br>      goto CleanUp; <br>   } <br>   if (sc = ScGetRenderBits(hmfp, <br>                     &amp;rgvalAtt[ivalAttAttachRendering].Value.bin.cb, <br>                     &amp;rgvalAtt[ivalAttAttachRendering].Value.bin.lpb)) <br>   { <br>      hr = ResultFromScode(sc); <br>      goto CleanUp; <br>   } <br> <br>CleanUp: <br> <br>   OleUIMetafilePictIconFree(hmfp); <br> <br>   return hr; <br>} <br> <br> <br>/* <br> * HrInitCFD <br> * <br> * Purpose: <br> *    Initialize the contents of CFD. <br> * <br> * Arguments: <br> *    pcfd        pointer to a CFD <br> * <br> * Returns: <br> *    HRESULT        Any error that has occured <br> */ <br> <br>HRESULT HrInitCFD(LPMAPIFOLDER pfld, CREATEFREEDOC* pcfd) <br>{ <br>   HRESULT        hr; <br>   LPSPropValue   rgvalMsg = pcfd-&gt;rgvalMsg; <br>   LPSPropValue   rgvalAtt = pcfd-&gt;rgvalAtt; <br> <br>   // Create a new message for the docfile <br>   if (FAILED(hr = pfld-&gt;CreateMessage( <br>         NULL, <br>         MAPI_DEFERRED_ERRORS, <br>         &amp;pcfd-&gt;pmsg))) <br>   { <br>      #ifdef _DEBUG <br>  afxDump &lt;&lt; TEXT("HrInitCFD():CreateMessage() failed"); <br>  #endif <br> <br>      goto Cleanup; <br>   } <br> <br>   // Get the initalize attachment settings <br>   if (FAILED(hr = HrInitAttachment( <br>         pcfd-&gt;pmsg, <br>         &amp;pcfd-&gt;patt, <br>         rgvalAtt, <br>         pcfd-&gt;lpszPathName, <br>         pcfd-&gt;lpszFileName <br>         ))) <br>   { <br>      goto Cleanup; <br>   } <br> <br>   // Set up the delivery time <br>   rgvalMsg[ivalMsgMessageDeliveryTime].Value.ft = <br>      rgvalAtt[ivalAttCreationTime].Value.ft; <br> <br>Cleanup: <br>   return hr; <br>} <br> <br>/* <br> * ReleaseCFD <br> * <br> * Purpose: <br> *    Clean up the contents of a CFD <br> * <br> * Arguments: <br> *    pcfd        pointer to a CFD <br> * <br> * Returns: <br> *    None. <br> */ <br>VOID ReleaseCFD(CREATEFREEDOC* pcfd) <br>{ <br>   ULRELEASE(pcfd-&gt;pmsg); <br>   ULRELEASE(pcfd-&gt;patt); <br>   MAPIFREEBUFFER(pcfd-&gt;rgvalAtt[ivalAttAttachRendering].Value.bin.lpb); <br>    <br>} <br> <br> <br>/* <br> * ScCreateFreeDocFinal <br> * <br> * Purpose: <br> *    Common code that takes care of setting message properties <br> * <br> * Arguments: <br> *    pfld        the folder where to create the FreeDoc <br> *    lpszFileName     the filename <br> * <br> * Returns: <br> *    SCODE       the status code <br> */ <br>SCODE ScCreateFreeDocFinal <br>   ( <br>   CREATEFREEDOC* pcfd, <br>   LPSTR        lpszTitle, <br>   LPSTR        lpszSubject, <br>   LPSTR        lpszAuthor, <br>   LPSTR        lpszKeywords, <br>   LPSTR        lpszComments <br>   ) <br>{ <br>   HRESULT        hr; <br>   SCODE  sc = S_OK; <br>   LPSPropValue   rgvalMsg= pcfd-&gt;rgvalMsg; <br>   LPSPropValue   rgvalAtt= pcfd-&gt;rgvalAtt; <br>   LPSPropValue   pvalName= NULL; <br>   LPSPropValue   pvalKey= NULL; <br>   LPTSTR         lpszProgId= NULL; <br>   LPTSTR         lpszClass = NULL; <br>   ULONG  cbEid= 0; <br>   LPENTRYID      peid= NULL; <br>   ULONG  ulObjType = 0; <br>   LPMAPIPROP     pmp= NULL; <br>   LPMAPISESSION  pses= NULL; <br>   ULONG  cvalMsg= cvalMsgMax - 1;   <br>   LPBYTE         lpbDest= NULL; <br>   SHFILEINFO     sfi= {0}; <br> <br> <br>   static CHAR   szScCreateFreeDocFinal1[] = TEXT("%s.%s"); <br> <br> <br>   // Set the properties <br>   if (sc = ((LPMAPIPROP)pcfd-&gt;patt)-&gt;SetProps(cvalAttMax, rgvalAtt, NULL)) <br>      goto CleanUp; <br> <br>   // Default the times <br>   rgvalMsg[ivalMsgClientSubmitTime].Value.ft = <br>                        rgvalAtt[ivalAttCreationTime].Value.ft; <br>   rgvalMsg[ivalMsgLastModificationTime].Value.ft = <br>                        rgvalAtt[ivalAttLastModificationTime].Value.ft; <br> <br>    <br>   // Find out the app name <br>   if (lpszProgId) <br>   { <br>  sc = MAPIAllocateBuffer((lstrlen(szIPMDocument) + lstrlen(lpszProgId) + 2) * sizeof(CHAR), (LPVOID *)&amp;lpszClass); <br>  if (FAILED(sc)) <br>      { <br>         sc = E_OUTOFMEMORY; <br>         goto CleanUp; <br>      } <br>      wsprintf(lpszClass, szScCreateFreeDocFinal1, szIPMDocument, lpszProgId); <br>      rgvalMsg[ivalMsgMessageClass].Value.LPSZ = lpszClass; <br>   } <br>   else <br>      rgvalMsg[ivalMsgMessageClass].Value.LPSZ = (LPTSTR) szIPMDocument; <br> <br>   // Save the changes to the attachment <br>   if (sc = pcfd-&gt;patt-&gt;SaveChanges(0)) <br>   { <br>      #ifdef _DEBUG <br>  afxDump &lt;&lt; TEXT("ScCreateFreeDocFinal:SaveChanges() failed"); <br>  #endif <br> <br>      goto CleanUp; <br>   } <br> <br>   //Shared folder doesn't like us keeping the attachment open <br>   pcfd-&gt;patt-&gt;Release(); <br>   pcfd-&gt;patt = NULL; <br> <br>   // Find out the user's name <br>   // AddRefObj(pses = CENT(pses)); <br>   pses = PostData.m_lpSession; <br>   pses-&gt;AddRef(); <br> <br>   if (pses) <br>   { <br>      // Determine our identity <br>      if (FAILED(hr = pses-&gt;QueryIdentity(&amp;cbEid, &amp;peid))) <br>      { <br> #ifdef _DEBUG <br> afxDump &lt;&lt; TEXT("ScCreateFreeDocFinal:QueryIdentity() failed"); <br> #endif <br> <br> <br>         goto CleanUp; <br>      } <br> <br>      // Get the object referring to our identity <br>      if (hr = pses-&gt;OpenEntry(cbEid, peid, NULL, MAPI_DEFERRED_ERRORS, <br>                               &amp;ulObjType, (LPUNKNOWN *) &amp;pmp)) <br>      { <br>         #ifdef _DEBUG <br> afxDump &lt;&lt; TEXT("ScCreateFreeDocFinal:OpenEntry() failed"); <br> #endif <br> <br>         goto CleanUp; <br>      } <br> <br>      // Get the display name <br>      if (sc = HrGetOneProp(pmp, PR_DISPLAY_NAME, &amp;pvalName)) <br>         goto CleanUp; <br>      if (sc = HrGetOneProp(pmp, PR_SEARCH_KEY, &amp;pvalKey)) <br>         goto CleanUp; <br>   } <br> <br>//If subject is not specified then use file's displayname as default subject <br>if (!lpszSubject) <br>{ <br>if (SHGetFileInfo( <br> pcfd-&gt;lpszPathName, <br>0, <br>&amp;sfi, <br>sizeof(SHFILEINFO), <br>SHGFI_DISPLAYNAME)) <br>{ <br>lpszSubject = sfi.szDisplayName; <br>} <br>else <br>{ <br>lpszSubject = pcfd-&gt;lpszFileName; <br>} <br>} <br> <br>   // Set up the propvals <br>   rgvalMsg[ivalMsgSubject].ulPropTag = PR_SUBJECT; <br>   rgvalMsg[ivalMsgSubject].Value.LPSZ = lpszSubject; <br>   rgvalMsg[ivalMsgSenderName].ulPropTag = PR_SENDER_NAME; <br>   rgvalMsg[ivalMsgSentRepresentingName].ulPropTag = PR_SENT_REPRESENTING_NAME; <br>   rgvalMsg[ivalMsgSenderName].Value.LPSZ = <br>   rgvalMsg[ivalMsgSentRepresentingName].Value.LPSZ = <br>                        pvalName ? pvalName-&gt;Value.LPSZ : (LPTSTR) ""; <br>   rgvalMsg[ivalMsgClientSubmitTime].ulPropTag = PR_CLIENT_SUBMIT_TIME; <br>   rgvalMsg[ivalMsgMessageDeliveryTime].ulPropTag = PR_MESSAGE_DELIVERY_TIME; <br>   rgvalMsg[ivalMsgMessageClass].ulPropTag = PR_MESSAGE_CLASS; <br>   rgvalMsg[ivalMsgMessageFlags].ulPropTag = PR_MESSAGE_FLAGS; <br>   rgvalMsg[ivalMsgMessageFlags].Value.l = 0; <br>   rgvalMsg[ivalMsgSentRepresentingEntryid].ulPropTag = <br>                        PR_SENT_REPRESENTING_ENTRYID; <br>   rgvalMsg[ivalMsgSenderEntryid].ulPropTag = PR_SENDER_ENTRYID; <br>   rgvalMsg[ivalMsgSentRepresentingEntryid].Value.bin.cb = <br>   rgvalMsg[ivalMsgSenderEntryid].Value.bin.cb = cbEid; <br>   rgvalMsg[ivalMsgSentRepresentingEntryid].Value.bin.lpb = <br>   rgvalMsg[ivalMsgSenderEntryid].Value.bin.lpb = (LPBYTE) peid; <br>   rgvalMsg[ivalMsgSentRepresentingSearchKey].ulPropTag = PR_SENT_REPRESENTING_SEARCH_KEY; <br>   rgvalMsg[ivalMsgSenderSearchKey].ulPropTag = PR_SENDER_SEARCH_KEY; <br>   rgvalMsg[ivalMsgSentRepresentingSearchKey].Value.bin.cb = <br>   rgvalMsg[ivalMsgSenderSearchKey].Value.bin.cb = pvalKey ? pvalKey-&gt;Value.bin.cb : 0; <br>   rgvalMsg[ivalMsgSentRepresentingSearchKey].Value.bin.lpb = <br>   rgvalMsg[ivalMsgSenderSearchKey].Value.bin.lpb = pvalKey ? pvalKey-&gt;Value.bin.lpb : NULL; <br>   rgvalMsg[ivalMsgIcon].ulPropTag = PR_ICON; <br>   rgvalMsg[ivalMsgIcon].Value = rgvalAtt[ivalAttAttachRendering].Value; <br>   rgvalMsg[ivalMsgImportance].ulPropTag = PR_IMPORTANCE; <br>   rgvalMsg[ivalMsgImportance].Value.l = IMPORTANCE_NORMAL; <br>   rgvalMsg[ivalMsgPriority].ulPropTag = PR_PRIORITY; <br>   rgvalMsg[ivalMsgPriority].Value.l = PRIO_NORMAL; <br>   rgvalMsg[ivalMsgSensitivity].ulPropTag = PR_SENSITIVITY; <br>   rgvalMsg[ivalMsgSensitivity].Value.l = SENSITIVITY_NONE; <br>   rgvalMsg[ivalMsgLastModificationTime].ulPropTag = PR_LAST_MODIFICATION_TIME; <br> <br> <br>   // Set the message properties <br>   if (sc = ((LPMAPIPROP)pcfd-&gt;pmsg)-&gt;SetProps(cvalMsg, pcfd-&gt;rgvalMsg, NULL)) <br>      goto CleanUp; <br> <br>       <br>   // Set the summary info properties if they have been specified <br>   if (lpszTitle <br>         || lpszSubject <br>         || lpszAuthor <br>         || lpszKeywords <br>         || lpszComments) <br>      { <br>    <br>PromoteSummaryInfo(pcfd-&gt;pmsg, lpszTitle, lpszSubject, lpszAuthor, lpszKeywords, lpszComments); <br>    <br>      } <br> <br>   sc = pcfd-&gt;pmsg-&gt;SaveChanges(0); <br> <br>CleanUp: <br>    <br>   MAPIFREEBUFFER(lpbDest); <br>   MAPIFREEBUFFER(peid); <br>   MAPIFREEBUFFER(pvalName); <br>   MAPIFREEBUFFER(pvalKey); <br>   MAPIFREEBUFFER(lpszProgId); <br>   MAPIFREEBUFFER(lpszClass); <br>   ULRELEASE(pmp); <br>   ULRELEASE(pses); <br>   return sc; <br>} <br> <br> <br>/* <br> * ScCreateFreeDoc <br> * <br> * Purpose: <br> *    Creates a FreeDoc out of a file <br> * <br> * Arguments: <br> *    pfld        the folder where to create the FreeDoc <br> *    lpszFileName     the filename <br> * <br> * Returns: <br> *    SCODE       the status code <br> */ <br>SCODE ScCreateFreeDoc <br>   ( <br>   LPSTORAGE  pstg, <br>   LPMAPIFOLDER   pfld, <br>   LPSTR          lpszPathName, <br>   LPSTR  lpszFileName, <br>   LPSTR          lpszTitle, <br>   LPSTR          lpszSubject, <br>   LPSTR          lpszAuthor, <br>   LPSTR          lpszKeywords, <br>   LPSTR          lpszComments <br>   ) <br>{ <br>   CREATEFREEDOC  cfd; <br>   SCODE       sc = S_OK; <br> <br> <br>   ZeroMemory(&amp;cfd, sizeof(CREATEFREEDOC)); <br> <br>   // Make sure we aren't trying to attach a directory <br>   if (GetFileAttributes(lpszPathName) &amp; FILE_ATTRIBUTE_DIRECTORY) <br>   { <br>     #ifdef _DEBUG <br> afxDump &lt;&lt; TEXT("ScCreateFreeDoc:Trying to attach a directory"); <br> #endif <br> goto CleanUp; <br>   } <br> <br> <br>   cfd.lpszPathName = lpszPathName; <br>   cfd.lpszFileName = lpszFileName; <br> <br>   if (sc = GetScode(HrInitCFD(pfld, &amp;cfd))) <br>      goto CleanUp; <br> <br>   // Load the file into the attachment <br>   if (FAILED(sc = ScLoadAttachDataFromFile(pstg, lpszPathName, cfd.patt))) <br>   { <br>      goto CleanUp; <br>   } <br> <br>   // Get the file time properties <br>   FGetFileTimes(lpszPathName, &amp;cfd.rgvalAtt[ivalAttCreationTime].Value.ft, <br>               &amp;cfd.rgvalAtt[ivalAttLastModificationTime].Value.ft); <br> <br>    <br> <br>   if (SUCCEEDED(sc)) <br>   { <br>      sc = ScCreateFreeDocFinal(&amp;cfd, <br>                                lpszTitle, <br>                                lpszSubject, <br>                                lpszAuthor, <br>                                lpszKeywords, <br>                                lpszComments); <br>   } <br> <br>CleanUp: <br>   ReleaseCFD(&amp;cfd); <br>   return sc; <br>} <br> <br> <br> <br>/* <br> * ScLoadAttachDataFromFile <br> * <br> * Purpose: <br> *    Reads in a file into the attachment's data stream <br> * <br> * Arguments: <br> *    lpszFileName     the file to be read in <br> *    patt        the attachment <br> * <br> * Returns: <br> *    SCODE       S_OK or an error code <br> */ <br>SCODE ScLoadAttachDataFromFile(LPSTORAGE pstg, LPTSTR lpszPathName, LPATTACH patt) <br>{ <br>   SCODE       sc= E_FAIL; // MAIL_E_STREAMINFILE; <br>   HRESULT     hr= NOERROR; <br>   LPSTREAM    pstm= NULL; <br>   UINT        cbRead= 0; <br>   ULONG       cbWritten= 0; <br>    <br>    <br>   // Get a stream interface from the attachment data <br>   if (hr = patt-&gt;OpenProperty(PR_ATTACH_DATA_BIN, <br>         (LPIID) &amp;IID_IStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>         MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS, <br>         (LPUNKNOWN *) &amp;pstm)) <br>   { <br>      #ifdef _DEBUG <br>  afxDump &lt;&lt; TEXT(" ScLoadAttachDataFromFile:OpenProperty() failed"); <br>  #endif <br>  goto CleanUp; <br>   } <br> <br>    <br>   // Reset the destination stream to the start <br>   if (hr = pstm-&gt;Seek(liZero, STREAM_SEEK_SET, NULL)) <br>   { <br>      #ifdef _DEBUG <br>  afxDump &lt;&lt; TEXT(" ScLoadAttachDataFromFile:pstm-&gt;Seek failed"); <br>  #endif <br>      goto CleanUp; <br>   } <br> <br>   cbRead = sizeof(CHAR)*(lstrlen(theApp.m_lpBuffer) + 1); <br>   if (hr = pstm-&gt;Write(theApp.m_lpBuffer, cbRead, &amp;cbWritten)) <br>   { <br>        #ifdef _DEBUG <br>afxDump &lt;&lt; TEXT(" ScLoadAttachDataFromFile:pstm-&gt;Write() failed"); <br>#endif <br>goto CleanUp; <br>} <br> <br>   sc = S_OK; <br>   goto CleanUp; <br> <br>CleanUp: <br>   ULRELEASE(pstm); <br>   return sc; <br> <br>} <br> <br> <br> <br>/* <br> * FGetFileTimes <br> * <br> * Purpose: <br> *    Gets a file's create and modify times <br> * <br> * Arguments: <br> *    szPathName        The file name <br> *    pftCreate         The creation time <br> *    pftModify         The modify time <br> * <br> * Returns: <br> *    BOOL           TRUE on success <br> */ <br>BOOL FGetFileTimes(LPTSTR lpszPathName, FILETIME * pftCreate, <br>               FILETIME * pftModify) <br>{ <br>   BOOL     fSuccess = FALSE; <br>   FILETIME ftBlank = { 0 }; <br> <br>   HANDLE   hFile; <br> <br>   if (pftCreate) <br>      *pftCreate = ftBlank; <br>   if (pftModify) <br>      *pftModify = ftBlank; <br>   hFile = CreateFile(lpszPathName, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, <br>                  OPEN_EXISTING, 0, NULL); <br>   if (hFile) <br>      fSuccess = GetFileTime(hFile, pftCreate, NULL, pftModify); <br> <br>   CloseHandle(hFile); <br> <br> <br>   // Try putting in last modify if can't get create time <br>   if (pftCreate &amp;&amp; <br>      pftModify &amp;&amp; <br>      !pftCreate-&gt;dwLowDateTime &amp;&amp; <br>      !pftCreate-&gt;dwHighDateTime) <br>      *pftCreate = *pftModify; <br>   return fSuccess; <br>} <br> <br> <br>/* <br> * HmfpGetIconForFile <br> * <br> * Purpose: <br> *    A centralized place to create a metafile picture of an icon and label <br> * <br> * Arguments: <br> *    lpszPathName     The path to the file we need an icon for <br> *    lpszFileName     The filename which becomes the label <br> * <br> * Returns: <br> *    HGLOBAL        Handle to METAFILEPICT metafile with icon and label <br> */ <br> <br>HGLOBAL HmfpGetIconForFile(LPTSTR lpszPathName, LPTSTR lpszFileName) <br>{ <br>   HGLOBAL  hmfp; <br>   HICON hicon = NULL; <br>   CHAR szDllName[cchPathNameMax]; <br>   UINT  iIcon = 0; <br>   UsesMakeOLESTR; <br> <br>    <br>   // Use filename if no pathname supplied <br>   if (!lpszPathName) <br>      lpszPathName = lpszFileName; <br> <br>   szDllName[0] = 0; <br>    <br>   hmfp = OleGetIconOfFile(MakeOLESTR(lpszPathName), FALSE); <br>   return hmfp; <br>} <br> <br> <br>/* <br> * ScGetRenderBits <br> * <br> * Purpose: <br> *    Prepares a transportable metafile picture <br> * <br> * Arguments: <br> *    hmfp        The metafile picture <br> *    pcb            The size of the transportable data <br> *    ppb            Pointer to the data <br> * <br> * Returns: <br> *    SCODE       The status code <br> */ <br>SCODE ScGetRenderBits(HGLOBAL hmfp, ULONG * pcb, LPBYTE * ppb) <br>{ <br>   SCODE          sc = S_OK; <br>   LPMETAFILEPICT    pmfp = NULL; <br>   HMETAFILE         hmf = NULL; <br>   UINT           cbMF = 0; <br>   WORD           wCheck = 0; <br> <br>   // Clear out our out parameters <br>   *pcb = 0; <br>   *ppb = NULL; <br> <br>   // Lock down our data <br>   pmfp = (LPMETAFILEPICT)GlobalLock(hmfp); <br>   if (!pmfp) <br>      goto MemErr; <br> <br>   // How much room do we need <br>   hmf = pmfp-&gt;hMF; <br> <br>   cbMF = GetMetaFileBitsEx(hmf, 0, NULL); <br>   if (!cbMF) <br>   { <br>      sc = E_FAIL; <br>      goto CleanUp; <br>   } <br> <br>   *pcb = cbMF; <br> <br>   // Allocate that space <br>    sc = MAPIAllocateBuffer(*pcb, (LPVOID *)ppb); <br>if (FAILED(sc)) <br>goto MemErr; <br> <br>   // Put together the header <br> <br> <br>   // Get the data for real <br>#ifdef DEBUG <br>   cbMF = <br>#endif <br>   GetMetaFileBitsEx(hmf, cbMF, *ppb); <br>    <br> <br> <br>   goto CleanUp; <br> <br>MemErr: <br>   sc = E_OUTOFMEMORY; <br> <br>CleanUp: <br>   if (pmfp) <br>      GlobalUnlock(hmfp); <br>   return sc; <br>} <br> <br> <br> <br> <br>/* <br> * OleUIMetafilePictIconFree <br> * <br> * Purpose: <br> *  Deletes the metafile contained in a METAFILEPICT structure and <br> *  frees the memory for the structure itself. <br> * <br> * Parameters: <br> *  hMetaPict       HGLOBAL metafilepict structure created in <br> *                  OleMetafilePictFromIconAndLabel <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void OleUIMetafilePictIconFree(HGLOBAL hMetaPict) <br>   { <br> <br>   LPMETAFILEPICT      pMF; <br> <br>   if (NULL==hMetaPict) <br>      return; <br> <br>   pMF=(LPMETAFILEPICT)GlobalLock(hMetaPict); <br> <br>   if (NULL!=pMF) <br>      { <br>      if (NULL!=pMF-&gt;hMF) <br>         DeleteMetaFile(pMF-&gt;hMF); <br>      } <br> <br>   GlobalUnlock(hMetaPict); <br>   GlobalFree(hMetaPict); <br> <br>   return; <br>   } <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
