<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSIMPORT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1774"></a>DSIMPORT.C</h2>
<pre><code>// --dsimport.c----------------------------------------------------------------- <br>// <br>//  Directory service import sample. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "dapi.h" <br> <br>// <br>// Names of Command Line Arguments <br>// <br> <br>#define ARG_FILE"FILE" <br>#define ARG_BASEPOINT"BASEPOINT" <br>#define ARG_CONTAINER"CONTAINER" <br>#define ARG_DSA"DSA" <br>#define ARG_HELP1"?" <br>#define ARG_HELP2"HELP" <br> <br>// <br>// Table of Command Line Switches for _HrExpandCommandLineArgument() <br>// <br> <br>static char * rgpszArgArray[] = { <br>ARG_FILE, <br>ARG_BASEPOINT, <br>ARG_CONTAINER, <br>ARG_DSA, <br>ARG_HELP1, <br>ARG_HELP2, <br>}; <br> <br>// <br>// Variables For Command Line Arguments <br>// <br> <br>char szDsaName[MAX_PATH+1]= {0}; <br>char szBasePoint[MAX_PATH+1]= {0}; <br>char szParentContainer[MAX_PATH+1]= {0}; <br>char szImportFile[MAX_PATH+1]= {0}; <br> <br>// <br>// Other Variables <br>// <br> <br>BOOL fDisplayedHelp= FALSE; <br>DWORD cLoggedErrors= 0; <br> <br>// <br>// Function Declarations <br>// <br> <br>static HRESULT HrParseCommandLine( <br>    int argc, <br>    char *argv[]); <br> <br>static VOID ShowUsage( <br>void); <br> <br>static VOID ShowHelp( <br>void); <br> <br>static HRESULT HrDoBatchImport( <br>void); <br> <br>// <br>// Functions <br>// <br> <br>//$--main----------------------------------------------------------------------- <br>//  Main function that performs directory import. <br>// ----------------------------------------------------------------------------- <br>int main(// RETURNS: exit code <br>int argc,// number of arguments on command line <br>char *argv[])// array of command line arguments <br>{ <br>    HRESULThr= NOERROR; <br> <br>DEBUGPUBLIC("main()\n"); <br> <br>    printf( "\n" ); <br> <br>    // Get import parameters from the command line. <br> <br>    hr = HrParseCommandLine(argc, argv); <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Do batch import <br> <br>    hr = HrDoBatchImport(); <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>// Successful completion. <br> <br>if (fDisplayedHelp) <br>{ <br>hr = NOERROR; <br>} <br>else if (SUCCEEDED(hr)) <br>{ <br>fprintf(stderr, "Import operation completed successfully.\n"); <br>} <br> <br>// Error completion. <br> <br>else if (cLoggedErrors == 1) <br>{ <br>fprintf(stderr, "ERROR: 1 error written to NT Event Log.\n"); <br>} <br>else if (cLoggedErrors &gt; 1) <br>{ <br>fprintf(stderr, "ERROR: %d errors written to NT Event Log.\n",  <br>cLoggedErrors); <br>} <br> <br>return _nEcFromHr(hr); <br>} <br> <br>//$--HrParseCommandLine--------------------------------------------------------- <br>//  Read import configuration from command line. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParseCommandLine(// RETURNS: HRESULT <br>    int argc,// number of arguments on command line <br>    char *argv[])// array of command line arguments <br>{ <br>    HRESULThr= NOERROR; <br>    HRESULThrT= NOERROR; <br>char *pszArgument= NULL; <br>char *pszValue= NULL; <br>    inti= 0; <br> <br>DEBUGPRIVATE("HrParseCommandLine()\n"); <br> <br>// If there are no command line arguments then show a usage message. <br> <br>if (argc &lt; 2) <br>{ <br>ShowUsage(); <br>hr = E_FAIL; <br>goto cleanup; <br>} <br> <br>// Do an initial check for /? or /HELP.  If found, show a help message  <br>// and don't do any other parsing. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br>hr = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>&amp;pszArgument, &amp;pszValue); <br> <br>if (SUCCEEDED(hr) &amp;&amp; pszArgument &amp;&amp;  <br>(!_stricmp(pszArgument,ARG_HELP1) ||  <br>!_stricmp(pszArgument,ARG_HELP2))) <br>{ <br>ShowHelp(); <br>hr = E_FAIL; <br>goto cleanup; <br>} <br>} <br> <br>// Loop through and parse all the command line arguments. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br>hrT = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>&amp;pszArgument, &amp;pszValue); <br> <br>if (FAILED(hrT)) <br>{ <br>hr = hrT; <br>if (hr == EDK_E_NOT_FOUND) <br>{ <br>fprintf(stderr, "ERROR: unknown command line flag: %s\n",  <br>argv[i]); <br>continue; <br>} <br>else <br>{ <br>fprintf(stderr, "ERROR: unable to parse command line.\n"); <br>goto cleanup; <br>} <br>} <br> <br>// Parse flag arguments that don't take a value. <br> <br>else if (pszArgument != NULL &amp;&amp; pszValue == NULL) <br>{ <br>fprintf(stderr, "ERROR: flag /%s requires a value\n",  <br>pszArgument); <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>// Parse flag arguments that take a value. <br> <br>else if (pszArgument != NULL &amp;&amp; pszValue != NULL) <br>{ <br>if (!_stricmp(pszArgument,ARG_DSA)) <br>{ <br>strncpy(szDsaName, pszValue, MAX_PATH); <br>                szDsaName[MAX_PATH] = 0; <br>} <br>else if (!_stricmp(pszArgument,ARG_FILE)) <br>{ <br>strncpy(szImportFile, pszValue, MAX_PATH); <br>                szImportFile[MAX_PATH] = 0; <br>} <br>else if (!_stricmp(pszArgument,ARG_BASEPOINT)) <br>{ <br>strncpy(szBasePoint, pszValue, MAX_PATH); <br>                szBasePoint[MAX_PATH] = 0; <br>} <br>else if (!_stricmp(pszArgument,ARG_CONTAINER)) <br>{ <br>strncpy(szParentContainer, pszValue, MAX_PATH); <br>                szParentContainer[MAX_PATH] = 0; <br>} <br> <br>// Other flag (must not take a value). <br> <br>else <br>{ <br>fprintf(stderr, "ERROR: flag /%s does not take a value\n",  <br>pszArgument); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Catch unknown arguments. <br> <br>else <br>{ <br>fprintf(stderr, "ERROR: unknown argument %s\n", argv[i]); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Make sure we have all the info we need. <br> <br>if (SUCCEEDED(hr)) <br>{ <br>if (*szDsaName == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify /%s\n", ARG_DSA); <br>hr = HR_LOG(E_FAIL); <br>} <br>if (*szImportFile == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify /%s\n", ARG_FILE); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br>//$--ShowUsage------------------------------------------------------------------ <br>//  Show usage information. <br>// ----------------------------------------------------------------------------- <br>static VOID ShowUsage(void)// RETURNS: nothing <br>{ <br>DEBUGPRIVATE("ShowUsage()\n"); <br> <br>    printf("USAGE: DSIMPORT [Flags]\n\n"); <br>printf("  [Flags]        Enter DSIMPORT /? for details\n"); <br> <br>fDisplayedHelp = TRUE; <br>} <br> <br>//$--ShowHelp------------------------------------------------------------------- <br>//  Show help information. <br>// ----------------------------------------------------------------------------- <br>static VOID ShowHelp(void)// RETURNS: nothing <br>{ <br>DEBUGPRIVATE("ShowHelp()\n"); <br> <br>printf("Directory Service Import sample.\n\n"); <br>printf("USAGE: DSIMPORT [Flags]\n\n"); <br>printf("  /FILE=               Name of import file\n"); <br>printf("  /DSA=                Directory Service Agent name\n"); <br>printf("  /BASEPOINT=          DN of Directory basepoint object\n"); <br>printf("  /CONTAINER=          RDN of Directory container beneath " <br>"BASEPOINT\n"); <br>printf("  /HELP or /?          Display help screen\n"); <br> <br>fDisplayedHelp = TRUE; <br>} <br> <br>//$--HrDoBatchImport------------------------------------------------------------ <br>//  Do batch import of directory objects. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDoBatchImport(void)// RETURNS: HRESULT <br>{ <br>HRESULT         hr              = NOERROR; <br>BIMPORT_PARMS BimportParms    = {0}; <br>LPBIMPORT_PARMS lpBimportParms  = &amp;BimportParms; <br> <br>DEBUGPRIVATE("HrDoBatchImport()\n"); <br> <br>lpBimportParms-&gt;dwDAPISignature = DAPI_SIGNATURE; <br>lpBimportParms-&gt;dwFlags            = <br>        DAPI_RESTRICT_ACCESS | <br>DAPI_EVENT_ALL; <br> <br>lpBimportParms-&gt;pszImportFile = szImportFile; <br>lpBimportParms-&gt;pszBasePoint = szBasePoint; <br>lpBimportParms-&gt;pszContainer     = szParentContainer; <br>lpBimportParms-&gt;pszNTDomain= NULL; <br> <br>    if(*szDsaName) <br>    { <br>    lpBimportParms-&gt;pszDSAName = szDsaName; <br>    } <br> <br>lpBimportParms-&gt;chColSep = DAPI_DEFAULT_DELIM; <br>lpBimportParms-&gt;chQuote = DAPI_DEFAULT_QUOTE; <br>lpBimportParms-&gt;chMVSep = DAPI_DEFAULT_MV_SEP; <br> <br>cLoggedErrors = BatchImport(lpBimportParms); <br>if (cLoggedErrors) <br>{ <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>    RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
