<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TNEFDEC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2023"></a>TNEFDEC.C</h2>
<pre><code>// --tnefdec.c------------------------------------------------------------------ <br>// <br>//  Converter that decodes a TNEF copy of the message as an embedded message. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#define _MEMLOG_H           // skip mem logging stuff until it works in UNICODE. <br> <br>#define USES_IID_IMessage <br>#include "edk.h" <br>#include "tnefdec.chk" <br> <br>// <br>//  TNEF global variables. <br>// <br> <br>// Note: OpenTnefStreamEx doesn't have exported wide and ansi versions. <br>// Thus, must let the compiler set the pszTNEFStreamName type. <br>static LPTSTR pszTNEFStreamName = TEXT("MAPIDATA.DAT"); <br> <br>//$--HrCnvQueryCapability------------------------------------------------------- <br>// <br>// DESCRIPTION: Routine called by the conversion engine to determine whether the converter <br>// can handle a particular message. <br>// <br>// INPUT:    <br>//          pszOptions  --  options passed from conversion <br>//          pszClass    --  class of object to be converted <br>//          pContent    --  object to be converted <br>//          pEnv    --  environment for conversion <br>// <br>// OUTPUT:  pfAmCandidate   --  TRUE if can be converted, FALSE otherwise <br>// <br>// RETURNS: HRESULT --  NOERROR if function call overall is successful <br>//                      E_INVALIDARG if bad input <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCnvQueryCapability(     <br>    IN LPCWSTR pszOptions,                  // options passed from conversion engine <br>    IN LPCWSTR pszClass,                    // class of object to be converted. <br>    IN PVOID pContent,                      // object to be covnerted. <br>    IN PEDKCNVENV pEnv,                     // environment for conversion. <br>    OUT BOOL * pfAmCandidate)               // can convert? <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("HrConvQueryCapability\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrCnvQueryCapability(pszOptions, pszClass, pContent, <br>                                  pEnv, pfAmCandidate); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pfAmCandidate = TRUE ;             // yes, we can process it. <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrCnvConvert--------------------------------------------------------------- <br>// <br>//  DESCRIPTION: Perform the conversion. <br>// <br>//  INPUT:   <br>//          pszOptions  --  options <br>//          pszClass    --  object class to be converted <br>//          pContent    --  object to be converted (GW message envelope pointer) <br>//          pEnv    --  environment for conversion <br>//          pContentOut --  converted object (stream pointer) <br>// <br>//  OUTPUT:  <br>//          pcr --  result of conversion <br>// <br>//  RETURNS:    HRESULT --  NOERROR if function call overall if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCnvConvert(       <br>    IN LPCWSTR pszOptions,                  // options. <br>    IN LPCWSTR pszClass,                    // object class to be converted. <br>    IN PVOID pContent,                      // object to be converted. <br>    IN PVOID pContentOut,                   // where to put the result. <br>    IN PEDKCNVENV pEnv,                     // environment for conversion. <br>    OUT EDKCNVRES * pcr)                    // result of conversion <br>{ <br>    HRESULT     hr          =   NOERROR;  <br>    LPMESSAGE   pEnvelope   =   NULL;       // gateway envelope pointer <br>    LPMESSAGE   pMessage    =   NULL;       // envelope content pointer <br>    LPATTACH    pAttach     =   NULL;       // envelope attachment pointer <br>    LPSTREAM    lpStream    =   NULL;       // stream to write to <br>    LPITNEF     lpTnef      =   NULL;       // pointer to TNEF object. <br>    WORD        wKey        =   0;          // magic text tag cookie. <br>    ULONG       ulAttachNum =   0;          // attachment number <br>    SPropValue  rgProps[2]  =   {0};        // attachment properties <br> <br>    // <br>    //  Declare an empty prop tag array to contain the <br>    //  list of properties that should not be included. <br>    //  I.e.:  include all properties in the TNEF. <br>    //  MAPI requires a list of properites that should not <br>    //  be copied to the TNEF.  By giving a zero length list <br>    //  for the list of properties to be excluded, all props <br>    //  will be included. <br>    // <br>    static SPropTagArray propEmptyPropTagArray  = {0, } ; <br> <br>    DEBUGPRIVATE("HrCnvConvert()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrCnvConvert(pszOptions, pszClass, pContent, <br>                          pContentOut, pEnv, pcr); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // The output is a gateway message envelope pointer <br>    pEnvelope = (LPMESSAGE) pContentOut; <br> <br>    // The input is a stream pointer. <br>    lpStream = (LPSTREAM) pContent; <br> <br>    // Get the envelope's content. <br>    hr = MAPICALL(pEnvelope)-&gt;CreateAttach( <br>                pEnvelope,      // message envelope pointer <br>                NULL,           // interface ID <br>                MAPI_DEFERRED_ERRORS, // MAPI flags <br>                &amp;ulAttachNum, <br>                &amp;pAttach);      // pointer to attachment pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    rgProps[0].ulPropTag = PR_ATTACH_METHOD; <br>    rgProps[0].Value.ul  = ATTACH_EMBEDDED_MSG; <br>    rgProps[1].ulPropTag = PR_RENDERING_POSITION; <br>    rgProps[1].Value.l   = 0; <br> <br>    hr = MAPICALL(pAttach)-&gt;SetProps(pAttach, 2, rgProps, 0); <br> <br>    if(FAILED(hr))  <br>    { <br>    goto cleanup; <br>} <br> <br>    // Open a message interface on the attachment. <br>    hr = MAPICALL(pAttach)-&gt;OpenProperty( <br>                pAttach,            // attachment pointer <br>                PR_ATTACH_DATA_OBJ, // property tag <br>                &amp;IID_IMessage,       // interface ID reference <br>                0,                  // interface flags <br>                MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS, // MAPI flags <br>                (LPUNKNOWN *) &amp;pMessage);         // message pointer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Setup TNEF.  Create a TNEF object to encode the message into <br>    //    lpStream (an attachment of the message.) <br>    //  <br>    // Note that there are no exported wide and ansi versions of OpenTnef <br>    // StreamEx.  Thus, pszTNEFStreamName's type must be set by the compiler. <br>    hr = OpenTnefStreamEx( <br>        NULL, <br>        lpStream,  <br>        pszTNEFStreamName, <br>        TNEF_DECODE, <br>        pMessage, <br>        0x01AF,       // magic number <br>                      // used to ID the TNEF <br>                      // attachment. <br>pEnv-&gt;lpAB, <br>        &amp;lpTnef); <br> <br>    if (FAILED (hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup ; <br>    } <br> <br>    ASSERTERROR(lpTnef != NULL,"NULL lpTnef variable") ; <br> <br>    // <br>    //  Specify which properties not to include. The list is empty, <br>    //  so no properties are excluded. All props are included. <br>    // <br> <br>    hr = lpTnef-&gt;lpVtbl-&gt;ExtractProps( <br>        lpTnef, <br>        TNEF_PROP_EXCLUDE, <br>        &amp;propEmptyPropTagArray, <br>        NULL); <br> <br>    if (FAILED (hr)) <br>    { <br>        goto cleanup ; <br>    } <br> <br>hr = MAPICALL(pMessage)-&gt;SaveChanges(pMessage, KEEP_OPEN_READWRITE); <br> <br>if(FAILED(hr)) <br>{ <br>    goto cleanup; <br>} <br> <br>hr = MAPICALL(pAttach)-&gt;SaveChanges(pAttach, KEEP_OPEN_READWRITE); <br>     <br>    if(FAILED (hr))  <br>    { <br>    goto cleanup; <br>} <br> <br>hr = MAPICALL(pEnvelope)-&gt;SaveChanges(pEnvelope, KEEP_OPEN_READWRITE); <br> <br>if(FAILED(hr)) <br>{ <br>    goto cleanup; <br>} <br> <br>    // <br>    //  We're done.  Tell the converter we did OK. <br>    // <br> <br>    *pcr = GCR_OK ; <br> <br>cleanup: <br> <br>    // Release OLE and MAPI objects <br>    ULRELEASE(pAttach); <br>    ULRELEASE(pMessage); <br>    ULRELEASE(lpTnef); <br> <br>    RETURN(hr) ; <br> <br>} <br> <br>//structure that points to all routines exported by this converter. <br>static CONVDLLVECT cdExportVector =  <br>{  <br>    1,  <br>    HrCnvQueryCapability,  <br>    HrCnvConvert <br>} ; <br> <br>//$--HrGetExportVector--------------------------------------------------------- <br>// <br>// DESCRIPTION: Called by conversion engine to get the vector of conversion entry points. <br>// <br>// INPUT:   dwVersionRequired   --  desired version number <br>// <br>// OUTPUT:  ppConvDLLVect    --  pointer to export vector structure <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input. <br>// <br>// ----------------------------------------------------------------------------- <br>extern HRESULT HrGetExportVector(        // RETURNS: HRESULT <br>    IN DWORD dwVersionRequired,             // desired version number <br>    OUT PCONVDLLVECT FAR * ppConvDLLVect)  // pointer to export vector structure <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPUBLIC("HrGetExportVector()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrGetExportVector(dwVersionRequired, ppConvDLLVect); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *ppConvDLLVect = &amp;cdExportVector; <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
