<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRIVIAL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2026"></a>TRIVIAL.C</h2>
<pre><code>// --trivial.c------------------------------------------------------------------ <br>//  <br>// Module demonstrates simplest message converter. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#define EDK_USES_IID <br>#include "edk.h" <br>#include "trivial.chk" <br> <br>//$--HrCnvQueryCapability------------------------------------------------------- <br>// <br>// DESCRIPTION: Routine called by the conversion engine to determine whether the converter <br>// can handle a particular message. <br>// <br>// INPUT:    <br>//          pszOptions  --  options passed from conversion (may be null) <br>//          pszClass    --  class of object to be converted <br>//          pContent    --  object to be converted <br>//          pEnv    --  environment for conversion <br>// <br>// OUTPUT:  pfAmCandidate   --  TRUE if can convert, FALSE otherwise. <br>// <br>// RETURNS: HRESULT --  NOERROR if call if successful, <br>//                      E_INVALIDARG if bad input, <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCnvQueryCapability(      <br>    IN LPCWSTR pszOptions,                  // options passed from conversion engine <br>    IN LPCWSTR pszClass,                    // class of object to be converted. <br>    IN PVOID pContent,                      // object to be covnerted. <br>    IN PEDKCNVENV pEnv,                     // environment for conversion. <br>    OUT BOOL * pfAmCandidate)               // can convert? <br>{ <br>    HRESULT hr  =   NOERROR;        // return code <br> <br>    DEBUGPRIVATE("HrCnvQueryCapability()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCnvQueryCapability(pszOptions, pszClass, pContent, <br>                                  pEnv, pfAmCandidate); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pfAmCandidate = TRUE ;                 // say that we can take it. <br> <br>    RETURN(hr) ; <br> <br>} <br> <br>//$--HrWriteToStreamA----------------------------------------------------------- <br>// <br>//  DESCRIPTION: Write an ANSI string to a stream. <br>// <br>//  INPUT:  lpStream --  stream to write to <br>//          lpsz    --  string to write <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrWriteToStreamA(         // RETURNS: HRESULT <br>    IN LPSTREAM lpStream,                   // stream to write to.     <br>    IN LPSTR lpsz)                          // ANSI string to write. <br>{ <br>    HRESULT hr  =   NOERROR;        // return code <br>    ULONG ulBytesWritten = 0 ; <br>    ULONG ulBytesToWrite = 0; <br> <br>    DEBUGPRIVATE("HrWriteToStreamA()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrWriteToStreamA(lpStream, lpsz); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    ulBytesToWrite = lstrlenA(lpsz) * sizeof(CHAR) ; <br> <br>    hr = OLECALL(lpStream)-&gt;Write(lpStream, lpsz, ulBytesToWrite, &amp;ulBytesWritten); <br>  <br>    if ( FAILED(hr) || (ulBytesWritten != ulBytesToWrite) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>         <br>        goto cleanup; <br>    }    <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrCnvConvert--------------------------------------------------------------- <br>// <br>//  DESCRIPTION: Perform the conversion. <br>// <br>//  INPUT:   <br>//          pszOptions  --  options         (may be null) <br>//          pszClass    --  object class to be converted <br>//          pContent    --  object to convert (GW message envelope) <br>//          pEnv    --  environment for conversion <br>//          pContentOut --  converted object (stream  pointer) <br>// <br>//  OUTPUT:  <br>//          pcr --  result of conversion <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCnvConvert(              <br>    IN LPCWSTR pszOptions,                  // options. <br>    IN LPCWSTR pszClass,                    // object class to be converted. <br>    IN PVOID pContent,                      // object to be covnerted. <br>    IN PVOID pContentOut,                   // where to put the result. <br>    IN PEDKCNVENV pEnv,                     // environment for conversion. <br>    OUT EDKCNVRES * pcr)                    // result of conversion <br>{ <br>    HRESULT     hr          =   NOERROR;    // return code <br>    LPMESSAGE   pEnvelope   =   NULL;       // gateway message envelope pointer <br>    LPATTACH    pAttach     =   NULL;       // envelope attachment pointer <br>    LPMESSAGE   pMessage    =   NULL;       // envelope content pointer <br>    LPSTREAM    lpStream    =   NULL;       // output stream pointer <br> <br>    DEBUGPRIVATE("HrCnvConvert()\n"); <br> <br>    // check input paramters <br>    hr = CHK_HrCnvConvert(pszOptions, pszClass, pContent, <br>                          pContentOut, pEnv, pcr); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // The input is a gateway message envelope pointer <br>    pEnvelope = (LPMESSAGE) pContent; <br> <br>    // The output is a stream pointer. <br>    lpStream = (LPSTREAM) pContentOut; <br> <br>    // Get the envelope's content. <br>    hr = MAPICALL(pEnvelope)-&gt;OpenAttach( <br>                pEnvelope,      // message envelope pointer <br>                0,              // attachment number <br>                NULL,           // interface ID reference <br>                MAPI_DEFERRED_ERRORS, // MAPI flags <br>                &amp;pAttach);      // pointer to attachment pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Open a message interface on the attachment. <br>    hr = MAPICALL(pAttach)-&gt;OpenProperty( <br>                pAttach,            // attachment pointer <br>                PR_ATTACH_DATA_OBJ, // property tag <br>                &amp;IID_IMessage,       // interface ID reference <br>                0,                  // interface flags <br>                MAPI_DEFERRED_ERRORS,             // MAPI flags <br>                (LPUNKNOWN *) &amp;pMessage);         // message pointer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Write a header to the attachment via the lpStream. <br>    // <br>    hr = HrWriteToStreamA(lpStream, "This attachment is intentionally empty.\r\n") ; <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup ; <br>    } <br> <br>    // Commit changes to the stream. <br>    hr = OLECALL(lpStream)-&gt;Commit( <br>                lpStream,       // stream pointer <br>                STGC_DEFAULT);  // commit flags <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  We're done.  Tell the converter we did OK. <br>    // <br>    *pcr = GCR_OK ; <br> <br>cleanup: <br> <br>    ULRELEASE(pAttach); <br>    ULRELEASE(pMessage);     <br> <br>    RETURN(hr) ; <br> <br>} <br> <br>// structure that points to all routines exported by this converter. <br>static CONVDLLVECT cdExportVector =  <br>{  <br>    1,  <br>    HrCnvQueryCapability,  <br>    HrCnvConvert <br>} ; <br> <br>//$--HrGetExportVector--------------------------------------------------------- <br>// <br>// DESCRIPTION: Called by conversion engine to get the vector of conversion entry points. <br>// <br>// INPUT:  dwVersion    --  version of conversion requested. <br>// <br>// OUTPUT: ppConvDLLVect --  pointer to export vector structure <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG otherwise <br>// <br>// ----------------------------------------------------------------------------- <br>extern  HRESULT HrGetExportVector(         // RETURNS: HRESULT <br>        IN DWORD dwVersion,                   // version requested <br>        OUT PCONVDLLVECT FAR * ppConvDLLVect) // pointert to export vector structure <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPUBLIC("HrGetExportVector()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrGetExportVector(dwVersion, ppConvDLLVect); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *ppConvDLLVect = &amp;cdExportVector; <br> <br>    RETURN(hr); <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
