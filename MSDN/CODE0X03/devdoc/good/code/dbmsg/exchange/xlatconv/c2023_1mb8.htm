<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TNEFENC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2024"></a>TNEFENC.C</h2>
<pre><code>// --tnefenc.c------------------------------------------------------------------ <br>// <br>//  Converter that Adds a TNEF copy of the message as an attachment. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#define _MEMLOG_H           // skip mem logging stuff until it works in UNICODE. <br> <br>#define USES_IID_IMessage <br>#include "edk.h" <br>#include "tnefenc.chk" <br> <br>// <br>//  TNEF global variables. <br>// <br>// Note:  OpenTnefStreamEx does not export separate wide character and <br>// ansi versions.  Thus, we must let the compiler set the pszTNEFStreamName <br>// type. <br>static LPTSTR pszTNEFStreamName = TEXT("MAPIDATA.DAT"); <br> <br>//$--HrCnvQueryCapability------------------------------------------------------- <br>// <br>// DESCRIPTION: Routine called by the conversion engine to determine whether the converter <br>// can handle a particular message. <br>// <br>// INPUT:    <br>//          pszOptions  --  options passed from conversion <br>//          pszClass    --  class of object to be converted <br>//          pContent    --  object to be converted <br>//          pEnv    --  environment for conversion <br>// <br>// OUTPUT:  pfAmCandidate   --  TRUE if can convert, FALSE otherwise <br>// <br>// RETURNS: HRESULT --  NOERROR if overall success,. <br>//                      E_INVALIDARG if bad input. <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCnvQueryCapability(      <br>    IN LPCWSTR pszOptions,                  // options passed from conversion engine <br>    IN LPCWSTR pszClass,                    // class of object to be converted. <br>    IN PVOID pContent,                      // object to be covnerted. <br>    IN PEDKCNVENV pEnv,                     // environment for conversion. <br>    OUT BOOL * pfAmCandidate)               // can convert? <br>{ <br>    HRESULT hr  =   NOERROR;        // return code <br> <br>    DEBUGPRIVATE("HrCnvQueryCabability()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCnvQueryCapability(pszOptions, pszClass, pContent, <br>                                  pEnv, pfAmCandidate); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pfAmCandidate = TRUE ;             // yes, we can process it. <br> <br>    RETURN(hr) ; <br> <br>} <br> <br> <br>//$--HrCnvConvert--------------------------------------------------------------- <br>// <br>//  DESCRIPTION: Perform the conversion. <br>// <br>//  INPUT:   <br>//          pszOptions  --  options <br>//          pszClass    --  class of object to convert <br>//          pContent    --  object to be converted (GW message envelope pointer) <br>//          pEnv    --  environment for conversion <br>//          pContentOut --  converted object ( stream pointer) <br>// <br>//  OUTPUT:  <br>//          pcr --  result of conversion <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCnvConvert(      <br>    IN LPCWSTR pszOptions,                  // options. <br>    IN LPCWSTR pszClass,                    // object class to be converted. <br>    IN PVOID pContent,                      // object to be covnerted. <br>    IN PVOID pContentOut,                   // where to put the result. <br>    IN PEDKCNVENV pEnv,                     // environment for conversion. <br>    OUT EDKCNVRES * pcr)                    // result of conversion <br>{ <br>    HRESULT     hr          =   NOERROR; <br>    LPMESSAGE   pEnvelope   =   NULL;       // gateway envelope pointer <br>    LPMESSAGE   pMessage    =   NULL;       // content is an IMessage. <br>    LPATTACH    pAttach     =   NULL;       // envelope attachment pointer <br>    LPSTREAM    lpStream    =   NULL;       // stream to be opened on attachment content.    <br>    ULONG       i           =   0; <br>    ULONG       cValues     =   0; <br>    ULONG       ulPropTag   =   0; <br>    LPITNEF     lpTnef      =   NULL;       // pointer to TNEF object. <br>    WORD        wKey        =   0;          // magic text tag cookie. <br> <br>    // <br>    //  Declare an property tag array to contain the <br>    //  list of properties that should not be included. <br>    // <br>    SPropTagArray *lpPropTagArray = NULL; <br> <br>    DEBUGPRIVATE("HrCnvConvert()\n"); <br> <br>    // check input <br>    hr = CHK_HrCnvConvert(pszOptions, pszClass, pContent, <br>                          pContentOut, pEnv, pcr); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // The input is a gateway message envelope pointer <br>    pEnvelope = (LPMESSAGE) pContent; <br> <br>    // The output is a stream pointer. <br>    lpStream = (LPSTREAM) pContentOut; <br> <br>    // Get the envelope's content. <br>    hr = MAPICALL(pEnvelope)-&gt;OpenAttach( <br>                pEnvelope,      // message envelope pointer <br>                0,              // attachment number <br>                NULL,           // interface ID reference <br>                MAPI_DEFERRED_ERRORS, // MAPI flags <br>                &amp;pAttach);      // pointer to attachment pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Open a message interface on the attachment. <br>    hr = MAPICALL(pAttach)-&gt;OpenProperty( <br>                pAttach,            // attachment pointer <br>                PR_ATTACH_DATA_OBJ, // property tag <br>                &amp;IID_IMessage,       // interface ID reference <br>                0,                  // interface flags <br>                MAPI_DEFERRED_ERRORS,             // MAPI flags <br>                (LPUNKNOWN *) &amp;pMessage);         // message pointer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Note:  OpenTnefStreamEx does not have exported versions for <br>    // wide character and ansi.  Thus, must let compiler set the pszTNEFStreamName <br>    // type. <br>hr = OpenTnefStreamEx( <br>    NULL, <br>    lpStream, <br>    pszTNEFStreamName,  <br>TNEF_ENCODE, <br>pMessage, <br>0x01AF, <br>pEnv-&gt;lpAB, <br>&amp;lpTnef); <br> <br>if(FAILED(hr)) <br>{ <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>} <br> <br>    ASSERTERROR(lpTnef != NULL,"NULL lpTnef variable") ; <br> <br>hr = pMessage-&gt;lpVtbl-&gt;GetPropList( <br>    pMessage, <br>    0, <br>&amp;lpPropTagArray); <br> <br>if(FAILED(hr)) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>} <br> <br>// Build a new prop tag array containing only non-transmittable properties. <br> <br>cValues = 0; <br> <br>for(i = 0; i &lt; lpPropTagArray-&gt;cValues; i++) <br>{ <br>ulPropTag = lpPropTagArray-&gt;aulPropTag[i]; <br> <br>if ((!FIsTransmittable(ulPropTag)) &amp;&amp; <br>(ulPropTag != PR_MESSAGE_RECIPIENTS) &amp;&amp; <br>(ulPropTag != PR_MESSAGE_ATTACHMENTS)) <br>{ <br>lpPropTagArray-&gt;aulPropTag[cValues++] = ulPropTag; <br>} <br>} <br> <br>lpPropTagArray-&gt;cValues = cValues; <br> <br>// Exclude selected properties from the TNEF encapsulation. <br> <br>hr = lpTnef-&gt;lpVtbl-&gt;AddProps( <br>    lpTnef, <br>TNEF_PROP_EXCLUDE, <br>0, <br>NULL, <br>lpPropTagArray); <br> <br>if(FAILED(hr)) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>} <br> <br>hr = lpTnef-&gt;lpVtbl-&gt;Finish(lpTnef, 0, &amp;wKey, NULL); <br> <br>if(FAILED(hr)) <br>{         <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>} <br> <br>    // Commit changes to stream. <br>hr = lpStream-&gt;lpVtbl-&gt;Commit(lpStream, STGC_DEFAULT); <br> <br>if(FAILED(hr)) <br>{         <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>} <br> <br>    // <br>    //  We're done.  Tell the converter we did OK. <br>    // <br>    *pcr = GCR_OK ; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropTagArray); <br> <br>    ULRELEASE(pAttach); <br>    ULRELEASE(pMessage); <br> <br>    ULRELEASE(lpTnef); <br> <br>    RETURN(hr); <br> <br>} <br> <br>// structure that points to all routines exported by this converter. <br>static CONVDLLVECT cdExportVector =  <br>{  <br>    1,  <br>    HrCnvQueryCapability,  <br>    HrCnvConvert <br>} ; <br> <br>//$--HrGetExportVector--------------------------------------------------------- <br>// <br>// DESCRIPTION: Called by conversion engine to get the vector of conversion entry points. <br>// <br>// INPUT:   dwVersionRequired   --  desired version number <br>// <br>// OUTPUT:  ppConvDLLVect   --  pointer to conversion vector structure <br>// <br>// RETURNS: HRESULT --  NOERROR if successful <br>//                      E_INVALIDARG if bad input <br>// <br>// ----------------------------------------------------------------------------- <br>extern HRESULT HrGetExportVector(        // RETURNS: HRESULT <br>    IN DWORD dwVersionRequired,             // desired versioin number <br>    OUT PCONVDLLVECT FAR *ppConvDLLVect)    //  pointer to conversion vector structure <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPUBLIC("HrGetExportVector()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrGetExportVector(dwVersionRequired, ppConvDLLVect); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *ppConvDLLVect = &amp;cdExportVector; <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
