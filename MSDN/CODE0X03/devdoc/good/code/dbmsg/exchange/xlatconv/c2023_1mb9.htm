<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOUPPER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2025"></a>TOUPPER.C</h2>
<pre><code>// --toupper.c------------------------------------------------------------------ <br>//  <br>// Converter that renders a message body to an attachment <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#define _MEMLOG_H           // skip mem logging stuff until it works in UNICODE. <br> <br>#define EDK_USES_IID <br>#include "edk.h" <br>#include "vsop.h" <br>#include "toupper.chk" <br> <br>//$--HrCnvQueryCapability------------------------------------------------------- <br>// <br>// DESCRIPTION: Routine called by the conversion engine to determine whether the converter <br>// can handle a particular message. <br>// <br>// INPUT:    <br>//          pszOptions  --  options passed from conversion <br>//          pszClass    --  class of object to be converted <br>//          pContent    --  object oto be converted. <br>//          pEnv    --  environment for conversion <br>// <br>// OUTPUT:  pfAmCandidate   --  TRUE if can convert, FALSE otherwise <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCnvQueryCapability(     <br>    IN LPCWSTR pszOptions,                  // options passed from conversion engine <br>    IN LPCWSTR pszClass,                    // class of object to be converted. <br>    IN PVOID pContent,                      // object to be covnerted. <br>    IN PEDKCNVENV pEnv,                     // environment for conversion. <br>    OUT BOOL * pfAmCandidate)               // can convert? <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("HrCnvQueryCapability()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCnvQueryCapability(pszOptions, pszClass, pContent, <br>                                  pEnv, pfAmCandidate); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pfAmCandidate = TRUE ;             // yes, we can process it. <br> <br>    RETURN(hr) ; <br> <br>} <br> <br>//$--HrConvertStreamToUpperCase----------------------------------------------- <br>// <br>// DESCRIPTION: Convert data in input stream to upper-case <br>//              equivalent in output stream. <br>// <br>// INPUT:       lpStreamIn  --  input stream to convert <br>//              lpStreamOut --  output stream to convert to <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrConvertStreamToUpperCase( <br>        IN LPSTREAM lpStreamIn,         // input stream <br>        IN LPSTREAM lpStreamOut)        // output stream <br>{ <br>// maximum # characters to read at a time <br>#defineMAX_CHARS_READ8192 <br> <br>    HRESULT hr          =   NOERROR; <br>    ULONG   cbRead      =   0;          // # bytes read <br>DWORDcchUpper=0;// # chars converted to upper case <br> <br>    const ULONG cbWanted    =   8192 * sizeof(CHAR);   // # bytes wanted <br> <br>CHARrgchBuffer[MAX_CHARS_READ]="";// text buffer <br> <br>    DEBUGPRIVATE("HrConvertStreamToUpperCase()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrConvertStreamToUpperCase(lpStreamIn, lpStreamOut); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    while ( TRUE ) <br>    { <br>        // Read a block of characters from the input stream <br>        // &amp; write the uppercase version to the output <br>        // stream. <br>        hr = OLECALL(lpStreamIn)-&gt;Read( <br>                    lpStreamIn,     // object pointer <br>                    rgchBuffer,     // data buffer <br>                    cbWanted,       // # bytes to read <br>                    &amp;cbRead);       // # bytes read <br>                             <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>             <br>            goto cleanup; <br>        } <br> <br>        // Test for end of data <br>        if ( cbRead == 0 ) <br>        { <br>            // we are done. <br>            goto cleanup; <br>        }         <br> <br>        ASSERTERROR(cbRead &lt;= cbWanted, "Bad cbRead"); <br> <br>        // convert character buffer to upper case <br>        cchUpper = CharUpperBuffA( <br>        rgchBuffer,// character buffer <br>        cbRead/sizeof(CHAR));// # characters in buffer <br> <br>ASSERTERROR((cchUpper == cbRead * sizeof(CHAR)), "Bad cchUpper"); <br> <br>        // Write the upper-cased character to the output <br>        // stream <br>        hr = OLECALL(lpStreamOut)-&gt;Write( <br>                lpStreamOut,        // object pointer <br>                rgchBuffer,         // upper cased data <br>                cbRead,             // # bytes to write <br>                NULL);              // don't care <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>    }   // end while <br> <br>    // we are done <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrWriteToStreamA----------------------------------------------------------- <br>// <br>//  DESCRIPTION: Write an ANSI string to a stream. <br>// <br>//  INPUT:  lpStream    --  stream to write to <br>//          lpsz    --  string to write to stream <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrWriteToStreamA(  // RETURNS: HRESULT <br>    IN LPSTREAM lpStream,                   // stream to write to.     <br>    IN LPSTR lpsz)                          // ANSI string to write. <br>{ <br>    HRESULT hr  =   NOERROR;        // return code <br>    ULONG ulBytesWritten = 0 ; <br>    ULONG ulBytesToWrite = 0; <br> <br>    DEBUGPRIVATE("HrWriteToStreamA()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrWriteToStreamA(lpStream, lpsz); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    ulBytesToWrite = lstrlenA(lpsz) * sizeof(CHAR) ; <br> <br>    hr = OLECALL(lpStream)-&gt;Write(lpStream, lpsz, ulBytesToWrite, &amp;ulBytesWritten); <br>     <br>    if ( FAILED(hr) || (ulBytesWritten != ulBytesToWrite) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>         <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrWriteToStreamW----------------------------------------------------------- <br>// <br>//  DESCRIPTION: Write a wide string to a stream. <br>// <br>//  INPUT:  lpStream    --  stream to write to <br>//          lpsz    --  string to write <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrWriteToStreamW(     // RETURNS: HRESULT <br>    IN LPSTREAM lpStream,                   // stream to write to.     <br>    IN LPWSTR lpsz)                         // wide string to write. <br>{ <br>    HRESULT hr  =   NOERROR;        // return code <br>    ULONG ulBytesWritten = 0 ; <br>    ULONG ulBytesToWrite = 0; <br> <br>    DEBUGPRIVATE("HrWriteToStreamW()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrWriteToStreamW(lpStream, lpsz); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    ulBytesToWrite = lstrlenW(lpsz) * sizeof(WCHAR) ; <br> <br>    hr = OLECALL(lpStream)-&gt;Write(lpStream, lpsz, ulBytesToWrite, &amp;ulBytesWritten); <br>     <br>    if ( FAILED(hr) || (ulBytesWritten != ulBytesToWrite) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>     <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrCnvConvert--------------------------------------------------------------- <br>// <br>//  DESCRIPTION: Perform the conversion. <br>// <br>//  INPUT:   <br>//          pszOptions  --  options (may be null) <br>//          pszClass    --  object class to be converted <br>//          pContent    --  objec to convert (GW message envelope pointer) <br>//          pEnv    --  environment for conversion <br>//          pContentOut --  converted object (stream pointer) <br>// <br>//  OUTPUT:  <br>//          pcr --  result of conversion <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCnvConvert(              <br>    IN LPCWSTR pszOptions,                  // options. <br>    IN LPCWSTR pszClass,                    // object class to be converted. <br>    IN PVOID pContent,                      // object to be covnerted. <br>    IN PVOID pContentOut,                   // where to put the result. <br>    IN PEDKCNVENV pEnv,                     // environment for conversion. <br>    OUT EDKCNVRES * pcr)                    // result of conversion <br>{ <br>    HRESULT     hr          = NOERROR; <br>    LPMESSAGE   pEnvelope   = NULL; // gateway message envelope pointer <br>    LPATTACH    pAttach     = NULL; // envelope's attachment <br>    LPMESSAGE   pMessage    = NULL; // content is an IMessage. <br>    LPSTREAM lpStream    = NULL;// output stream pointer <br>    PVIRTUALSTREAMONPROPERTYpStrmBody= NULL;// buffered body text stream <br>    <br>    DEBUGPRIVATE("HrCnvConvert()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCnvConvert(pszOptions, pszClass, pContent, <br>                          pContentOut, pEnv, pcr); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // The input is a gateway message envelope pointer <br>    pEnvelope = (LPMESSAGE) pContent; <br> <br>    // The output is a stream pointer. <br>    lpStream = (LPSTREAM) pContentOut; <br> <br>    // Get the envelope's content. <br>    hr = MAPICALL(pEnvelope)-&gt;OpenAttach( <br>                pEnvelope,      // message envelope pointer <br>                0,              // attachment number <br>                NULL,           // interface ID reference <br>                MAPI_DEFERRED_ERRORS, // MAPI flags <br>                &amp;pAttach);      // pointer to attachment pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!FBadUnknown(pAttach), "Bad lpAttach"); <br> <br>    // Open a message interface on the attachment. <br>    hr = MAPICALL(pAttach)-&gt;OpenProperty( <br>                pAttach,            // attachment pointer <br>                PR_ATTACH_DATA_OBJ, // property tag <br>                &amp;IID_IMessage,       // interface ID reference <br>                0,                  // interface flags <br>                MAPI_DEFERRED_ERRORS,             // MAPI flags <br>                (LPUNKNOWN *) &amp;pMessage);         // message pointer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!FBadUnknown(pMessage), "Bad pMessage"); <br> <br>    // <br>    //  Write a header to the the lpStream. <br>    // <br>    hr = HrWriteToStreamA(lpStream, "Message body follows:\r\n") ; <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup ; <br>    } <br> <br>    // <br>    // Get a buffered stream on the ASCII body of the message.from the PR_BODY <br>    // property.  (We really want PR_BODY for this <br>    // sample, since we want to print out a human-readable <br>    // body text.) <br>hr = HrOpenVirtualStreamOnProperty( <br>(LPMAPIPROP) pMessage,// object pointer <br>PR_BODY_A,// property tag <br>MAPI_DEFERRED_ERRORS,// reduces RPCs <br>&amp;pStrmBody);// buffered body stream pointer <br>                     <br>    if (SUCCEEDED(hr)) <br>    { <br>        ASSERT_IUNKNOWN_PTR(pStrmBody, "Bad pStrmBody"); <br> <br>        // <br>        // There was a body. <br>        // <br> <br>        // <br>        //  Convert the message to upper case. <br>        // <br>        hr = HrConvertStreamToUpperCase( <br>            (LPSTREAM) pStrmBody,   // buffered input stream <br>            lpStream);   // output stream <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br>    } <br>    else if (hr == MAPI_E_NOT_FOUND) <br>    { <br>        // <br>        //  No body.  Put in a fake body. <br>        // write fake body to stream <br>        hr = HrWriteToStreamA( <br>                lpStream,  <br>                "No Body") ; <br> <br>        if (FAILED(hr)) <br>        { <br>            goto cleanup ; <br>        } <br> <br>        hr = HR_LOG(NOERROR); <br>    } <br>    else <br>    { <br>        // <br>        //  Other error, die. <br>        // <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup ; <br>    } <br> <br>    // Commit changes to the stream. <br>    hr = OLECALL(lpStream)-&gt;Commit( <br>                lpStream,       // stream pointer <br>                STGC_DEFAULT);  // commit flags <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  We're done.  Tell the converter we did OK. <br>    // <br>    *pcr = GCR_OK ; <br> <br>cleanup: <br> <br>    // Release MAPI objects. <br>    ULRELEASE(pMessage); <br>    ULRELEASE(pAttach); <br>    ULRELEASE(pStrmBody); <br> <br>    RETURN(hr) ; <br> <br>} <br> <br>// structure that points to all routines exported by this converter. <br>static CONVDLLVECT cdExportVector =  <br>{  <br>    1,  <br>    HrCnvQueryCapability,  <br>    HrCnvConvert <br>} ; <br> <br>//$--HrGetExportVector--------------------------------------------------------- <br>// <br>// DESCRIPTION: Called by conversion engine to get the vector of conversion entry points. <br>// <br>// OUTPUT:  ppConvDLLVect   --  pointer to conversion vector structure <br>// <br>// ----------------------------------------------------------------------------- <br>extern HRESULT HrGetExportVector( // RETURNS: HRESULT <br>    IN DWORD dwVersionRequired,             // desired conversion DLL version number <br>    OUT PCONVDLLVECT FAR * ppConvDLLVect)   // pointer to conversion vector structure <br>{ <br>    HRESULT hr  =   NOERROR; <br> <br>    DEBUGPUBLIC("HrGetExportVector()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrGetExportVector(dwVersionRequired, ppConvDLLVect); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *ppConvDLLVect = &amp;cdExportVector; <br> <br>    RETURN(hr); <br> <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
