<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CRARUN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1767"></a>CRARUN.CPP</h2>
<pre><code>//--crarun.cpp---------------------------------------------------------------- <br>// <br>// implementation of the CExchRuleExt class <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>//---------------------------------------------------------------------------- <br> <br>#include "windows.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;MAPIX.H&gt; <br>#include &lt;MAPIUTIL.H&gt; <br>#include &lt;MAPIFORM.H&gt; <br> <br>#include "initguid.h" <br>#include "exchcli.h" <br> <br>#include "crarun.h" <br> <br>CExchRuleExt::CExchRuleExt() <br>{ <br>} <br> <br>CExchRuleExt::~CExchRuleExt() <br>{ <br>} <br> <br>STDMETHODIMP CExchRuleExt::QueryInterface(REFIID riid, LPVOID * ppvObj) <br>{ <br>    HRESULT hResult = S_OK; <br> <br>    *ppvObj = NULL; <br> <br>    if (( IID_IUnknown == riid) || ( IID_IExchangeRuleExt == riid) ) <br>    { <br>        *ppvObj = (LPUNKNOWN)this; <br>        AddRef(); <br>    } <br>    else <br>        hResult = E_NOINTERFACE; <br> <br> <br>    return hResult; <br>} <br> <br>STDMETHODIMP_(ULONG) CExchRuleExt::AddRef() <br>{ <br>    ++m_cRef; <br>    return m_cRef; <br>} <br> <br>STDMETHODIMP_(ULONG) CExchRuleExt::Release() <br>{ <br>// Use stack parameter, in case we delete ourselves <br>    ULONG ulCount = --m_cRef; <br>                          <br>if (!ulCount)  <br>{  <br>delete this; <br>} <br> <br>return ulCount; <br>} <br> <br>//$--Install------------------------------------------------------------------ <br>// Do we want to run in this context. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CExchRuleExt::Install ( <br>    LPEXCHANGERULEEXTCALLBACK percb,    // exchange rule callback <br>    ULONG context)                      // ERCONTEXT_INFO or ERCONTEXT_EXEC <br>{ <br>    return S_OK; <br>} <br> <br>//$--QueryRelease------------------------------------------------------------- <br>// This method is reserved for future use. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CExchRuleExt::QueryRelease() <br>{ <br>return S_OK; <br>} <br> <br>//$--GetCommand--------------------------------------------------------------- <br>// Display UI and fill out command and display buffers. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CExchRuleExt::GetCommand ( <br>LPEXCHANGERULEEXTCALLBACK percb,    // exchange rule callback <br>LPTSTR pszCommand,                  // an IN/OUT buffer in which to return <br>                                        // the encoded command, the buffer may <br>                                        // be pre-initialized with a previously <br>                                        // existing command for this provider. <br>    ULONG cchCommand,                   // length of the buffer given <br>LPTSTR pszDisplayName,              // IN/OUT, as the previous buffer, <br>                                        // but for the display string <br>    ULONG cchDisplayName)               // length of the buffer given <br>{ <br>    HRESULT hr; <br>    HWND hWnd; <br>    DWORD dwError; <br>    TCHAR szFileName[_MAX_PATH]; <br>    TCHAR szInitialFileName[_MAX_PATH] = {""}; <br> <br>    if ((NULL == pszCommand) || <br>        (NULL == pszDisplayName)) <br>    { <br>        return MAPI_E_INVALID_PARAMETER; <br>    } <br> <br>    sscanf (pszCommand, "launch %s", szInitialFileName); <br> <br>    hr = percb-&gt;GetWindow (&amp;hWnd); <br> <br>    if (FAILED(hr)) <br>        return hr; <br>     <br>    OPENFILENAME ofn; <br> <br>    ofn.lStructSize = sizeof (OPENFILENAME); <br>    ofn.hwndOwner = hWnd; <br>    ofn.hInstance = GetModuleHandle(NULL); <br>    ofn.lpstrFilter = "Programs\0*.exe;*.bat;*.com\0"; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0; <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = szInitialFileName; <br>    ofn.nMaxFile = _MAX_PATH; <br>    ofn.lpstrFileTitle = szFileName; <br>    ofn.nMaxFileTitle = _MAX_PATH; <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.lpstrTitle = "Program to Launch"; <br>    ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = "exe"; <br>    ofn.lCustData = 0; <br>    ofn.lpfnHook = NULL; <br>    ofn.lpTemplateName = NULL; <br> <br>    if (!GetOpenFileName (&amp;ofn)) <br>    { <br>        dwError = CommDlgExtendedError(); <br>         <br>        if (dwError) <br>            return S_FALSE; <br>         <br>        // else hit Cancel <br>    } <br>    else <br>    { <br>        if (strlen (ofn.lpstrFile) + sizeof ("launch ") &gt; cchCommand) <br>        { <br>            return TYPE_E_BUFFERTOOSMALL; <br>        } <br> <br>        if (strlen (ofn.lpstrFile) &gt; cchDisplayName) <br>        { <br>            return TYPE_E_BUFFERTOOSMALL; <br>        } <br> <br>        sprintf (pszCommand, "launch %s", ofn.lpstrFile); <br>        strcpy (pszDisplayName, ofn.lpstrFile); <br>    } <br> <br>    return S_OK; <br>} <br> <br>//$--QueryCommandDisplayName-------------------------------------------------- <br>//  What should the client display in it's display box. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CExchRuleExt::QueryCommandDisplayName( <br>LPEXCHANGERULEEXTCALLBACK percb,    // exchange rule callback <br>LPCTSTR pszCommand,                 // command buffer <br>LPTSTR pszDisplayName,              // OUT buffer for the display name <br>    ULONG cchDisplayName)               // size of buffer <br>{ <br>TCHAR szFileName[_MAX_PATH]; <br> <br>    if ((NULL == pszCommand) || <br>        (NULL == pszDisplayName)) <br>    { <br>        return MAPI_E_INVALID_PARAMETER; <br>    } <br> <br>    sscanf (pszCommand, "launch %s", szFileName); <br> <br>    if (strlen (szFileName) &gt; cchDisplayName) <br>    { <br>        return TYPE_E_BUFFERTOOSMALL; <br>    } <br> <br>    strcpy (pszDisplayName, szFileName); <br> <br>return S_OK; <br>} <br> <br>//$--Command------------------------------------------------------------------ <br>//  Run the command. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CExchRuleExt::Command( <br>LPEXCHANGERULEEXTCALLBACK percb,    // exchange rule callback <br>LPCTSTR pszCommand,                 // IN command to run <br>ULONG cb, LPENTRYID peid)           // EntryID of the message <br>{ <br>HRESULT hr; <br>    HWND hWnd; <br>    TCHAR szFileName[_MAX_PATH]; <br> <br>    if ((NULL == pszCommand) || <br>        (NULL == peid)) <br>    { <br>        return MAPI_E_INVALID_PARAMETER; <br>    } <br> <br>    sscanf (pszCommand, "launch %s", szFileName); <br>     <br>    hr = percb-&gt;GetWindow (&amp;hWnd); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    if ((HINSTANCE)32 &lt; ShellExecute (hWnd, NULL, szFileName, NULL, NULL, SW_SHOWNORMAL)) <br>    { <br>        return S_OK; <br>    } <br>    else <br>    { <br>        return S_FALSE; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
