<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOOKUP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1894"></a>LOOKUP.C</h2>
<pre><code>// --lookup.c------------------------------------------------------------------- <br>// <br>//  A simple test driver for HrGWResolveAddress() &amp; HrGWResolveProxy() <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>LPMAPISESSION lpSession        = NULL; <br>LPADRBOOK     lpAdrBook        = NULL;   // Pointer to address book <br>LPABCONT      lpGalABCont      = NULL; <br>ULONG         cbGalEid         = 0;      // count of bytes in GAL entry ID <br>LPENTRYID     lpGalEid         = NULL;   // pointer to GAL entry ID <br> <br>static BOOL   fIsInit          = FALSE; <br> <br>static BOOL   fInitializedMAPI = FALSE; // MAPI Initialized <br> <br>#define ARG_HELP1"?" <br>#define ARG_HELP2"HELP" <br> <br>static char * rgpszArgArray[] = { <br>ARG_HELP1, <br>ARG_HELP2, <br>}; <br> <br>#define ARGARRAYSIZE (sizeof(rgpszArgArray)/sizeof(rgpszArgArray[0])) <br> <br> <br>//$--InitLookup----------------------------------------------------------------- <br>//  Initialize for address lookup <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInitLookup(                       // RETURNS: return code <br>    IN LPSTR lpszProfileName)               // MAPI profile name <br>{ <br>    HRESULT hr        = NOERROR; <br>    HRESULT hrT       = NOERROR; <br>    SCODE   sc        = 0; <br>    ULONG   ulObjType = 0; <br> <br>    DEBUGPUBLIC( "HrInitLookup()\n" ); <br> <br>    DEBUGACTION("Initializing MAPI\n"); <br> <br>    hrT = MAPIInitialize(NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    fInitializedMAPI = TRUE; <br> <br>    hrT = MAPILogonEx( <br>        (ULONG) 0, <br>        lpszProfileName, <br>        NULL, <br>        MAPI_NEW_SESSION | MAPI_LOGON_UI | MAPI_EXTENDED | MAPI_NO_MAIL, <br>        &amp;lpSession); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(lpSession != NULL, "NULL lpSession variable");     <br> <br>    hrT = MAPICALL(lpSession)-&gt;OpenAddressBook( <br>        lpSession, <br>        0, <br>        NULL,  <br>        AB_NO_DIALOG, <br>        &amp;lpAdrBook); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(lpAdrBook != NULL, "NULL lpAdrBook variable"); <br> <br>    hr = HrFindExchangeGlobalAddressList( <br>        lpAdrBook, <br>        &amp;cbGalEid, <br>        &amp;lpGalEid); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Open the global recipient container <br>    hrT = MAPICALL(lpAdrBook)-&gt;OpenEntry( <br>        lpAdrBook,  <br>        cbGalEid, <br>        lpGalEid, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *)&amp;lpGalABCont); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(ulObjType != MAPI_ABCONT) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>        fIsInit = TRUE; <br>    } <br>    else <br>    { <br>        if(fInitializedMAPI == TRUE) <br>        { <br>            MAPIFREEBUFFER(lpGalEid); <br> <br>            ULRELEASE(lpGalABCont); <br> <br>            ULRELEASE(lpAdrBook); <br> <br>            ULRELEASE(lpSession); <br> <br>            MAPIUninitialize(); <br> <br>            fInitializedMAPI = FALSE; <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrUninitLookup------------------------------------------------------------ <br>//  Free all global variables <br>// ---------------------------------------------------------------------------- <br>HRESULT HrUninitLookup( void )      // RETURNS: return code <br>{ <br>    HRESULT  hr = NOERROR; <br> <br>    if(fIsInit == FALSE ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpGalEid); <br> <br>    ULRELEASE(lpGalABCont); <br> <br>    ULRELEASE(lpAdrBook); <br> <br>    ULRELEASE(lpSession); <br>     <br>    fIsInit = FALSE; <br>         <br>cleanup: <br> <br>    if(fInitializedMAPI == TRUE) <br>    { <br>        MAPIUninitialize(); <br> <br>        fInitializedMAPI = FALSE; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrPrintAddress---------------------------------------------------------- <br>// Prints the ADDRTYPE, DISPLAY_NAME &amp; EMAIL_ADDRESS of a Recipient <br>// identified by a given Recipient ENTRYID <br>// -------------------------------------------------------------------------- <br>HRESULT HrPrintAddress(         // RETURNS: return code <br>    IN BOOL      fMapiRecip,    // MAPI recipient <br>    IN ULONG     cbEntryID,     // count of bytes in entry ID <br>    IN LPENTRYID lpEntryID)     // pointer to entry ID <br>{ <br>    HRESULT       hr        = NOERROR;   <br>    HRESULT       hrT       = NOERROR; <br>    ULONG         ulObjType = 0; <br>    ULONG         cValues   = 0; <br>    LPSPropValue  lpProps   = {0}; <br>    LPMAPIPROP    lpRecip   = NULL; <br>     <br>    SizedSPropTagArray(5, sPropTags) = <br>    { <br>        5,  <br>        { <br>            PR_ENTRYID, <br>            PR_ADDRTYPE, <br>            PR_DISPLAY_NAME, <br>            PR_EMAIL_ADDRESS, <br>            PR_SEND_RICH_INFO <br>        } <br>    }; <br> <br>    DEBUGPUBLIC( "HrPrintAddress()\n" ); <br>     <br>    // Open the Recipient object <br>    hrT = MAPICALL(lpSession)-&gt;OpenEntry( <br>        lpSession, <br>        cbEntryID, <br>        lpEntryID, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *)&amp;lpRecip);  <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get the required properties of the user <br>    hrT = MAPICALL(lpRecip)-&gt;GetProps( <br>        lpRecip, <br>        (SPropTagArray *)&amp;sPropTags, <br>        fMapiUnicode, <br>        &amp;cValues, <br>        &amp;lpProps);  <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br> <br>    printf( " MAPI Recipient = %s\n", (fMapiRecip ? "TRUE" : "FALSE"));     <br>    printf( " Address Type   = \"%s\"\n",   lpProps[1].Value.LPSZ); <br>    printf( " Display Name   = \"%s\"\n",   lpProps[2].Value.LPSZ); <br>    printf( " Email Address  = \"%s\"\n\n", lpProps[3].Value.LPSZ); <br> <br>    ASSERTERROR( <br>        lpProps[4].Value.b == fMapiRecip, <br>        "PR_SEND_RICH_INFO not equal to entry ID flag"); <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpProps); <br> <br>    ULRELEASE(lpRecip); <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--main---------------------------------------------------------------------- <br>//  Test driver main entry point. <br>//   <br>//  This program loops, until terminated by the user, prompting alternately  <br>//  for input values to HrGWResolveAddress() and HrGWResolveProxy() <br>//  and prints the resolved results to a default output stream. <br>// ---------------------------------------------------------------------------- <br> <br>#define    MAX_INPUT_SZ        1024 <br> <br>int main(int argc, char *argv[]) <br>{ <br>    HRESULT    hr                       = NOERROR; <br>    SCODE      sc                       = 0; <br>    CHAR       szInput[MAX_INPUT_SZ]    = ""; <br>    LPSTR      lpszProfileName          = NULL; <br>    ULONG      cbEntryID                = 0; <br>    LPENTRYID  lpEntryID                = NULL; <br>    LPSTR      lpszProxyAddr            = NULL; <br>int        i                        = 0; <br>LPSTR      lpszArgument             = NULL; <br>LPSTR      lpszValue                = NULL; <br>BOOL       fFinishedCommandLine     = FALSE; <br>    BOOL       fMapiRecip               = FALSE; <br> <br>    printf( "\n" ); <br> <br>// If they didn't give command line args then print a usage message. <br> <br>if (argc &lt; 2) <br>{ <br>    printf("USAGE: LOOKUP Profile\n\n"); <br>printf("  [Flags]        Enter LOOKUP /? for details\n"); <br>goto cleanup; <br>} <br> <br>// If they used /? or /HELP (the only defined flags with labels) then  <br>// print a help message. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br>hr = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARGARRAYSIZE, NULL, &amp;lpszArgument, &amp;lpszValue); <br> <br>if (SUCCEEDED(hr) &amp;&amp; lpszArgument &amp;&amp;  <br>(!_stricmp(lpszArgument,ARG_HELP1) ||  <br>!_stricmp(lpszArgument,ARG_HELP2))) <br>{ <br>printf("Profile Lookup sample.\n\n"); <br>printf("USAGE: LOOKUP Profile\n\n"); <br>printf("  Profile        Name of profile to look up\n"); <br>printf("  /HELP or /?    Display help screen\n"); <br>goto cleanup; <br>} <br>} <br> <br>    // Get MAPI profile name from command line <br> <br>if (argc &gt; 2) <br>{ <br>fprintf(stderr, "ERROR: too many command line arguments\n"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>hr = _HrExpandCommandLineArgument( <br>argv[1], rgpszArgArray, ARGARRAYSIZE, NULL, &amp;lpszArgument, &amp;lpszProfileName); <br> <br>if (FAILED(hr) || lpszArgument) <br>{ <br>fprintf(stderr, "ERROR: unknown command line argument %s\n", argv[1]); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>fFinishedCommandLine = TRUE; <br> <br>// Do initialization <br> <br>    hr = HrInitLookup(lpszProfileName); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Loop until terminated by user. <br>    // <br>    for(;;) <br>    { <br>        int iTmp = 0; <br> <br>        printf( "\n\n" <br>                 "Enter address to be resolved in &lt;type&gt;:&lt;value&gt; format\n" <br>                 "or EXIT to terminate.\n" <br>                 "NOTE:  The address that you type must match exactly,\n" <br>                 "       including case.\n" <br>                 ": "); <br> <br>        // <br>        //  Get next line of number.  EOF = terminate. <br>        // <br>        if (_fgetts( szInput, MAX_INPUT_SZ, stdin ) == NULL) <br>            break; <br> <br>        // <br>        // trim the trailing '\n' <br>        // <br>        iTmp = strlen(szInput); <br> <br>        if (iTmp &gt; 0 &amp;&amp; szInput[iTmp-1] == '\n') <br>            szInput[iTmp-1] = 0; <br> <br>        // <br>        //  Check for exit. <br>        // <br>        if (_stricmp( szInput, TEXT("EXIT")) == 0) <br>            break ; <br> <br>        fMapiRecip = FALSE; <br> <br>        // <br>        //  Resolve the address. <br>        // <br> <br>        hr = HrGWResolveAddress( <br>            lpGalABCont, <br>            szInput, <br>            &amp;fMapiRecip, <br>            &amp;cbEntryID, <br>            &amp;lpEntryID); <br> <br>        if(SUCCEEDED(hr)) <br>        { <br>            printf("\n") ; <br> <br>            hr = HrPrintAddress(fMapiRecip, cbEntryID, lpEntryID); <br> <br>            if(FAILED(hr)) <br>            { <br>                printf("ERROR: could not print address [%08lX]\n", hr); <br>                continue; <br>            } <br> <br>            printf(" Enter address type to be resolved\n" <br>                     " :"); <br> <br>            if(gets(szInput) != NULL) <br>            { <br>                printf("\n") ; <br> <br>                fMapiRecip = FALSE; <br> <br>                // <br>                //  Check for exit. <br>                // <br>                if (_stricmp( szInput, TEXT("EXIT")) == 0) <br>                    break; <br> <br>                hr = HrGWResolveProxy( <br>                    lpAdrBook, <br>                    cbEntryID, <br>                    lpEntryID, <br>                    szInput, <br>                    &amp;fMapiRecip, <br>                    &amp;lpszProxyAddr); <br> <br>                printf("\n"); <br> <br>                if(FAILED(hr)) <br>                { <br>            fprintf(stderr, "ERROR: could not resolve proxy [%08lX]\n", hr); <br>                } <br>                else <br>                { <br>                    printf( " MAPI Recipient = %s\n", (fMapiRecip ? "TRUE" : "FALSE")); <br>                    printf( " Resolved Proxy = %-30s\n", lpszProxyAddr); <br> <br>                    MAPIFREEBUFFER(lpszProxyAddr); <br>                } <br>            } <br>        } <br>        else <br>        { <br>    fprintf(stderr, "ERROR: could not resolve address [%08lX]\n", hr); <br>        } <br>         <br>        MAPIFREEBUFFER(lpEntryID); <br>    } <br>             <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpEntryID); <br> <br>    // Terminate the MAPI session properly <br> <br>    if(fIsInit == TRUE) <br>    { <br>        hr = HR_LOG(HrUninitLookup()); <br>    } <br> <br>// Display results of operation. <br> <br>if (fFinishedCommandLine) <br>{ <br>if (SUCCEEDED(hr)) <br>{ <br>fprintf(stderr, "Done.\n"); <br>} <br>else <br>{ <br>fprintf(stderr, "Lookup not successful.\n"); <br>} <br>} <br> <br>    // return exit code <br>    return _nEcFromHr(hr); <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
