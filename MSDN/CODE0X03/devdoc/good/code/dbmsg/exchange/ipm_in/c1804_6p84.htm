<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVCLS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1804"></a>CONVCLS.CPP</h2>
<pre><code>// --convcls.cpp-------------------------------------------------------------- <br>// <br>// IPM to 822 conversion class source file. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "msgemit.h" <br>#include "tagnames.h"    <br>#include "convcls.h" <br>#include "convcls.chk" <br> <br>//$--CIPMConvert::CIPMConvert------------------------------------------------ <br>// <br>// DESCRIPTION: CIPMConvert conversion class constructor <br>// <br>// INPUT:   none <br>// <br>// RETURNS: nothing <br>// <br>// --------------------------------------------------------------------------- <br>CIPMConvert::CIPMConvert() <br>{ <br>    DEBUGPRIVATE("CIPMConvert::CIPMConvert()\n"); <br> <br>    // Initialize data members <br>    m_lpwszMsgClass =   NULL; <br>    m_lpStream = NULL; <br>    m_lpEnvelope = NULL; <br>    m_lpContent = NULL; <br>    m_lpAttach = NULL; <br>    m_fTNEFEncode = FALSE; <br>    m_lpszAddrType = NULL; <br>    m_lpAB = NULL; <br>    m_MsgType = mtNone; <br> <br>    ZeroMemory(m_rgszData, sizeof(m_rgszData)); <br> <br>    m_lpRcptToList = NULL; <br>    m_lpContentRecips = NULL; <br>    m_lpReportToList = NULL; <br> <br>    m_lpTraceInfo = NULL; <br>    m_lpIntTraceInfo = NULL; <br> <br>ZeroMemory( &amp;m_sOffsetHeaders, sizeof( ULARGE_INTEGER)); <br>} <br> <br>//$--CIPMConvert::~CIPMConvert------------------------------------------------ <br>// <br>// DESCRIPTION: CIPMConvert conversion class destructor <br>// <br>// INPUT:   none <br>// <br>// RETURNS: nothing <br>// <br>// --------------------------------------------------------------------------- <br>CIPMConvert::~CIPMConvert() <br>{ <br>    DEBUGPRIVATE("CIPMConvert::~CIPMConvert()\n"); <br> <br>    // Free up all memory allocated for this object <br>    Reset(); <br>} <br> <br>//$--CIPMConvert::HrInitialize----------------------------------- <br>// <br>// DESCRIPTION: Initializes conversion class instance <br>// <br>// INPUT:   lpwszMsgClass   --  message class <br>//          fTNEFEncode --  TNEF encode attachments flag <br>//          lpszAddrType--  address type <br>//          lpAddrBook  --  address book pointer <br>//          lpEnvelope  --  message envelope pointer <br>//          lpStream    --  stream pointer <br>//  <br>// NOTE:    The strings passed in as inputs are NOT duplicated. <br>//          Thus, they must stay around for the life of the <br>//          conversion. <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      EDK_E_ALREADY_EXISTS if already in use <br>// <br>// ---------------------------------------------------------------- <br>HRESULT CIPMConvert::HrInitialize(      // RETURNS: HRESULT <br>    IN LPCWSTR lpwszMsgClass,           // message class <br>    IN BOOL fTNEFEncode,                // TNEF encode attachments flag <br>    IN LPCTSTR lpszAddrType,            // address type <br>    IN LPADRBOOK lpAddrBook,            // address book pointer <br>    IN LPMESSAGE lpEnvelope,            // message envelope pointer <br>    IN LPSTREAM lpStream)               // stream to write output to <br>{ <br>    HRESULT hr      =   NOERROR;    // return code <br>    BOOL    fInUse  =   FALSE;      // TRUE if instance is in use <br> <br>    DEBUGPRIVATE("CIPMConvert::HrInitialize()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CIPMConvert_HrInitialize(lpwszMsgClass, fTNEFEncode, <br>                                      lpszAddrType, lpAddrBook, <br>                                      lpEnvelope, lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // make sure that this instance isn't already in use <br>    fInUse = fCheckInit(); <br>     <br>    if ( fInUse ) <br>    { <br>        hr = HR_LOG(EDK_E_ALREADY_EXISTS); <br> <br>        goto cleanup; <br>    } <br>         <br>    // Set mesage class, envelope, TNEF, environment <br>    // and stream data members <br>    m_lpwszMsgClass = lpwszMsgClass; <br>    m_fTNEFEncode = fTNEFEncode; <br>    m_lpszAddrType = lpszAddrType; <br>    m_lpAB = lpAddrBook; <br>    m_lpEnvelope = lpEnvelope; <br>    m_lpStream = lpStream;     <br>     <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrConvert------------------------------------ <br>// <br>// DESCRIPTION: Converts an "822-style" header to <br>//              a MAPI IPM message <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_OUTOFMEMORY if memory problems <br>//                          E_FAIL if API problems <br>//                          E_NOTIMPL if conversion not supported <br>// <br>// ---------------------------------------------------------------- <br>HRESULT CIPMConvert::HrConvert()    // RETURNS: HRESULT <br>{ <br>    HRESULT hr              =   NOERROR; <br>    BOOL    fInitialized    =   FALSE;  // TRUE if conversion instance has been initialized <br>    ULONG   nRecipients     =   0;      // # of [non]delivery recipients <br> <br>    DEBUGPRIVATE("CIPMConvert::HrConvert()\n"); <br> <br>    // Check to make sure that we have been initialized <br>    fInitialized = fCheckInit(); <br> <br>    if ( !fInitialized ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Parse message envelope and content common to <br>    // all message types and save the data. <br>    hr = HrParseEnvelopeAndContent(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Do processing which is specific to each message type. <br>    switch ( m_MsgType ) <br>    { <br>        case mtIPM:     // interpersonal message <br> <br>            // Create the message content container <br>            // This must be called before HrParseIPMSpecific(). <br>            hr = HrCreateContent(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Parse message body. <br>            hr = HrParseIPMSpecific(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Parse file attachments. <br>            hr = HrParseAttachments(); <br>             <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // set content properties <br>            hr = HrSetContentProps(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // If we are doing TNEF decoding, let TNEF decode the <br>            // content properties. <br>            if ( m_fTNEFEncode == TRUE ) <br>            { <br>                hr = HrTnefToContent(); <br> <br>                if ( FAILED(hr) ) <br>                { <br>                    goto cleanup; <br>                } <br> <br>            }   // end if doing TNEF decoding <br> <br>            // Set envelope properties <br>            hr = HrSetEnvelopeProps(); <br>             <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // done with IPM <br>            break; <br> <br>        case mtNDR:     // non-delivery report             <br>        case mtDR:      // delivery report <br>                     <br>            // Parse [non]recipient information <br>            hr = HrParseReportSpecific( <br>                        &amp;nRecipients);  // # of [non]delivery recipients <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // A [non]delivery report must have at least one <br>            // recipient. <br>            if ( nRecipients &lt; 1 ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            // If we are doing TNEF decoding, let TNEF decode the <br>            // content properties. <br>            if ( m_fTNEFEncode == TRUE ) <br>            { <br>                hr = HrTnefToContent(); <br> <br>                if ( FAILED(hr) ) <br>                { <br>                    goto cleanup; <br>                } <br> <br>            }   // end if doing TNEF decoding <br> <br>            // Set report properties. <br>            hr = HrSetReportProps(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // done with NDR or DR <br> <br>            break; <br> <br>        case mtNRN: <br>        case mtRN: <br>            // read/non-read notifications <br> <br>            // Parse notification-specific data <br>            hr = HrParseNotificationSpecific(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Create the notification content container <br>            hr = HrCreateContent(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // If we are doing TNEF decoding, let TNEF decode the <br>            // content properties. <br>            if ( m_fTNEFEncode == TRUE ) <br>            { <br>                hr = HrTnefToContent(); <br> <br>                if ( FAILED(hr) ) <br>                { <br>                    goto cleanup; <br>                } <br> <br>            }   // end if doing TNEF decoding <br> <br>            // Set envelope properties <br>            hr = HrSetEnvelopeProps(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Set notification's content properties. <br>            hr = HrSetNotifyCntProps(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Done with [non]read notification. <br> <br>            break; <br> <br>        default: <br>            // shouldn't happen <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>             <br>    }   // end switch <br> <br>    // save the changes to the output message. <br>    hr = m_lpEnvelope-&gt;SaveChanges( <br>                KEEP_OPEN_READWRITE);       // we don't own envelope pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    // Release and free MAPI objects used for conversion now.   <br>    // Don't keep them in memory any longer than necessary.   <br>    // (Also allows for re-use of thread.) <br>    Reset(); <br> <br>    RETURN(hr); <br>}     <br> <br>//$--CIPMConvert::HrParseAttachments------------------------------------------ <br>// <br>// DESCRIPTION: Handle parsing &amp; creation of binary file attachments <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrParseAttachments() <br>{ <br>    HRESULT hr  =   NOERROR; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrParseAttachments()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR(m_MsgType == mtIPM, "Bad m_MsgType"); <br> <br>    // Parse a binary file attachment at a time (if any) <br>    //  &amp; create the attachment &amp; its properties <br>    while ( TRUE ) <br>    { <br>        hr = HrCreateNextAttachment(); <br> <br>        // Check to see if we have no more attachments. <br>        // This happens when we reach the end of the file <br>        // or when we hit the beginning of TNEFed data. <br>        if ( (hr == EDK_E_END_OF_FILE) || <br>             ( (hr == EDK_E_NOT_FOUND) &amp;&amp; (m_fTNEFEncode == TRUE) ) ) <br>        { <br>            hr = NOERROR;       // not really an error <br> <br>            break;              // get out of this loop <br>        } <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // parse next attachment <br> <br>    }   // end while <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::Reset---------------------------------------- <br>// <br>// DESCRIPTION: resets all of the conversion class' data members <br>//              and frees all MAPI memory allocated by the class. <br>//              This allow the thread's class instance to be re-used <br>//              for another conversion (if desired). <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     VOID <br>// <br>// ---------------------------------------------------------------- <br>VOID CIPMConvert::Reset()        // RETURNS: VOID <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("CIPMConvert::Reset()\n"); <br> <br>    // Reset all of the conversion class' data members. <br>    // This allows the class instance to be re-used by this <br>    // thread (Also frees MAPI memory). <br>    m_lpwszMsgClass = NULL; <br>    m_lpEnvelope = NULL; <br>    m_lpStream = NULL; <br>    m_fTNEFEncode = FALSE; <br>    m_lpszAddrType = NULL; <br>    m_lpAB = NULL; <br>    m_MsgType = mtNone; <br> <br>ZeroMemory( &amp;m_sOffsetHeaders, sizeof(ULARGE_INTEGER)); <br> <br>    ULRELEASE(m_lpContent); <br>    ULRELEASE(m_lpAttach); <br> <br>    // Free the data string member array <br>    (VOID)HrFreeData(); <br> <br>    // Free the address lists <br>    FREEPADRLIST(m_lpRcptToList); <br>    FREEPADRLIST(m_lpContentRecips); <br>    FREEPADRLIST(m_lpReportToList); <br>     <br>    // Free the trace entry list <br>    // Note: Trace information list is allocated as one big <br>    // block, so it can be deallocated with MAPIFREEBUFFER. <br>    MAPIFREEBUFFER(m_lpTraceInfo); <br> <br>    // Free the internal trace entry list <br>    // Note: Internal trace information list is allocated as one big <br>    // block, so it can be deallocated with MAPIFREEBUFFER. <br>    MAPIFREEBUFFER(m_lpIntTraceInfo); <br> <br>    return; <br> <br>} <br> <br>//$--CIPMConvert::FreeData---------------------------------------------------- <br>// <br>// DESCRIPTION: Frees the memory used by the data string array member <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>VOID CIPMConvert::HrFreeData()      // RETURNS: VOID <br>{ <br>    UINT    iEntry  =   0;          // data entry index <br> <br>    DEBUGPRIVATE("CIPMConvert::HrFreeData()\n"); <br> <br>    // Free all allocated data string entries <br>    for ( iEntry = 0; iEntry &lt; nDataEntries; iEntry++ ) <br>    { <br>        MAPIFREEBUFFER(m_rgszData[iEntry]); <br> <br>    }   // end for <br> <br>    return; <br> <br>} <br> <br>//$--CIPMConvert::HrParseEnvelopeAndContent----------------------------------- <br>// <br>// DESCRIPTION: Read 822-style envelope and common content text <br>//              from stream and saves data read <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_OUTOFMEMORY if memory problems <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrParseEnvelopeAndContent() <br>{ <br>    HRESULT     hr      =   NOERROR; <br>    LPTSTR      lpTag   =   NULL;       // pointer to tag string <br>    LPTSTR      lpData  =   NULL;       // pointer to data string <br>    BOOL        fFound  =   FALSE;      // TRUE if tag is found <br>    ULONG       nRecips =   0;          // number of recipients <br>    ULONG       nTraces =   0;          // number of trace entries <br>    ULONG       nIntTraces = 0;         // number of internal trace entries <br>    ULONG       cbRead  =   0;          // number bytes read <br> <br>    // temporary string buffer <br>    TCHAR       szTempBuffer[ulMaxOutStringLen] =   TEXT(""); <br> <br>    DEBUGPRIVATE("CIPMConvert::HrParseEnvelopeAndContent()\n"); <br> <br>    // consistency checks <br>    ASSERTERROR(!FBadUnknown(m_lpEnvelope), "Bad m_lpEnvelope"); <br>    ASSERTERROR(!FBadUnknown(m_lpStream), "Bad m_lpStream"); <br> <br>    // Read the first tag and data line from the stream. <br>    // It should the the "X-Tnef-Attach" tag and data line. <br>    hr = HrParseTagAndData( <br>        m_lpStream,     // stream pointer <br>        &amp;cbRead,        // # bytes read from stream <br>        &amp;lpTag,         // pointer to tag string <br>        &amp;lpData);       // poitner to data string <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check the tag read against the tag expected <br>    if ( lstrcmp(lpTag, lpszTagTnefAttach) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERT_STRING_PTR(lpData, "Bad lpData."); <br> <br>    // Don't trust the TNEF flag passed in by the caller for inbound <br>    // conversions.  They may not know whether or not the inbound <br>    // file contains TNEF data.  (If there is TNEF data in the file, <br>    // then the X-Tnef-Attach line will have non-null data.  Otherwise, <br>    // the file doesn't contain TNEF data.) <br>    if ( *lpData == 0 ) // empty string <br>    { <br>        // Since no TNEF data file name, must not be doing <br>        // TNEF decoding. <br>        m_fTNEFEncode = FALSE; <br>    } <br> <br>    else    // TNEF data file name specified <br>    { <br>        // Since TNEF data file name, must be doing TNEF <br>        // encoding. <br>        m_fTNEFEncode = TRUE; <br> <br>        ASSERTERROR(lstrcmp(lpData, lpszTagTnefHdr) == 0, "Bad lpData."); <br>    } <br> <br>    // Free tag and data strings <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br>             <br>    // Read the "MAIL FROM" data line. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // pointer to tag string pointer <br>                &amp;(m_rgszData[iMailFrom]));       // pointer to data string pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check that the tag is what we expected. <br>    if ( lstrcmp(lpTag, lpszTagMailFrom) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Free the tag string <br>    MAPIFREEBUFFER(lpTag); <br> <br>    // Read the "RCPT TO" data lines from the stream. <br>    hr = HrParseRecipients( <br>                lpszTagRcptTo,      // tag <br>                MAPI_TO,            // MAPI recipient type <br>                &amp;m_lpRcptToList,    // target address list <br>                &amp;nRecips);          // # recipients of type found <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check the number of "RCPT TO" recipients <br>    if ( nRecips == 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Read the "DATA:" marker from the stream. <br>    hr = m_lpStream-&gt;Read( <br>                szTempBuffer,           // data buffer <br>                lstrlen(lpszTagData) * sizeof(TCHAR),  // length (no terminator) <br>                &amp;cbRead);               // # characters read. <br>                 <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Check that we have the "DATA" tag <br>    if ( lstrcmp(szTempBuffer, lpszTagData) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>             <br>        goto cleanup; <br>    } <br>         <br>    // Read the "X-Message-Class" data line from the stream. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iClass]));       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // check that the tag is what we expect <br>    if ( lstrcmp(lpTag, lpszTagMsgClass) != 0 ) <br>    { <br>        // bad tag <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Free the tag <br>    MAPIFREEBUFFER(lpTag); <br> <br>    // Set the message type <br>    hr = HrSetMessageType(m_rgszData[iClass]); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(m_MsgType != mtNone, "Bad m_MsgType"); <br>         <br>    // Read the "Date" tag and data line. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iDate]));       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check that the tag is what we expect <br>    if ( lstrcmp(lpTag, lpszTagDate) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>     <br>    // Free the tag <br>    MAPIFREEBUFFER(lpTag); <br> <br>    // Read the "X-Message-ID" tag and data line <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iXID]));       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check that the tag is what we expect <br>    if ( lstrcmp(lpTag, lpszTagMsgID) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>     <br>    // Free the tag <br>    MAPIFREEBUFFER(lpTag); <br>  <br>    // If we have a report, read the "X-Message-Subject-ID" <br>    // tag and data line. <br>    if ( m_MsgType != mtIPM ) <br>    { <br>        hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iSubjectXID]));       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Check that the tag is what we expect <br>        if ( lstrcmp(lpTag, lpszTagSubjectID) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>     <br>            goto cleanup; <br>        } <br>     <br>        // Free the tag <br>        MAPIFREEBUFFER(lpTag);             <br> <br>    }   // end if report <br> <br>    // Read trace data (if any). <br>    hr = HrParseExternalTraceData(&amp;nTraces); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Read internal trace data (if any). <br>    hr = HrParseInternalTraceData(&amp;nIntTraces); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Read the FROM tag and data line. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iFrom]));       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check that the tag is what we expect <br>    if ( lstrcmp(lpTag, lpszTagFrom) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>     <br>    // Free the tag <br>    MAPIFREEBUFFER(lpTag); <br> <br>    // Parse the "To" recipients and store the addresses. <br>    hr = HrParseRecipients( <br>                lpszTagTo,              // tag <br>                MAPI_TO,                // MAPI recipient type <br>                &amp;m_lpContentRecips,      // target address list <br>                &amp;nRecips);              // # recipients of type found <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Note: <br>    // An IPM message content is allowed to have no "To" recipients. <br>    if ( (m_MsgType != mtIPM) &amp;&amp; (nRecips &lt; 1) ) <br>    { <br>        // Notifications should have a "To" recipient <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Parse the "CC" recipients and store the addresses. <br>    hr = HrParseRecipients( <br>                lpszTagCC,              // tag <br>                MAPI_CC,                // MAPI recipient type <br>                &amp;m_lpContentRecips,     // target address list <br>                &amp;nRecips);              // # recipients of type found <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Parse the "BCC" recipients and store the addresses. <br>    hr = HrParseRecipients( <br>                lpszTagBCC,             // tag <br>                MAPI_BCC,               // MAPI recipient type <br>                &amp;m_lpContentRecips,     // target address list <br>                &amp;nRecips);              // # recipients of type found <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Read in the blank line which separates the recipients from <br>    // the subject. <br>    // First, zero out the temporary array <br>    ZeroMemory( <br>                szTempBuffer,       // buffer <br>                ulMaxOutStringLen); <br> <br>    hr = m_lpStream-&gt;Read( <br>                szTempBuffer,       // temporary buffer <br>                lstrlen(lpszNewLine) * sizeof(TCHAR),  // length (no terminator) <br>                &amp;cbRead);           // number of bytes read <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Check that we read in a new line. <br>    if ( lstrcmp(szTempBuffer, lpszNewLine) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>     <br>    // Parse the "Subject" tag and data line. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iSubject]));       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check that the tag is what we expect <br>    if ( lstrcmp(lpTag, lpszTagSubject) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>     <br>    // Free the tag <br>    MAPIFREEBUFFER(lpTag); <br> <br>    // Parse the "Priority" tag and data line. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iPriority]));       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check that the tag is what we expect <br>    if ( lstrcmp(lpTag, lpszTagPriority) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>     <br>    // Free the tag <br>    MAPIFREEBUFFER(lpTag); <br> <br>    // Parse the "Importance" tag and data line. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iImportance]));       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check that the tag is what we expect <br>    if ( lstrcmp(lpTag, lpszTagImportance) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>     <br>    // Free the tag <br>    MAPIFREEBUFFER(lpTag); <br> <br>// this location marks the end of the headers <br>{ <br>LARGE_INTEGERsOffsetZero = {0}; <br>hr = m_lpStream-&gt;Seek( <br>sOffsetZero,        // offset <br>STREAM_SEEK_CUR,    // from current <br>&amp;m_sOffsetHeaders); <br> <br>if ( FAILED(hr) ) <br>{ <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br>} <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpData); <br>    MAPIFREEBUFFER(lpTag); <br> <br>    RETURN(hr); <br>    <br>}     <br> <br>//$--CIPMConvert::HrSetMessageType-------------------------------------------- <br>// <br>// DESCRIPTION: Sets a message's type, based on the message class <br>//              property. <br>// <br>// INPUT:   lpMessageClass  --  message class. <br>// <br>// RETURNS: HRESULT --  NOERROR if successful &amp; is a supported message <br>//                      E_INVALIDARG if bad input <br>//                      E_FAIL otherwise <br>//                             <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrSetMessageType( <br>        IN LPTSTR lpszMessageClass)        // message class <br>{ <br>    HRESULT         hr                  =   NOERROR; <br> <br>    // upper-case message class <br>    TCHAR           pszClassCaps[ulMaxOutStringLen] =   TEXT(""); <br> <br>    // Message class supported <br>    const LPTSTR    lpszIPMClass    =   TEXT("IPM"); <br>    const LPTSTR    lpszReport      =   TEXT("REPORT."); <br> <br>    // Report types supported. <br>    const LPTSTR    lpszNDR         =   TEXT(".NDR"); <br>    const LPTSTR    lpszDR          =   TEXT(".DR"); <br>    const LPTSTR    lpszNRN         =   TEXT(".IPNNRN"); <br>    const LPTSTR    lpszRN          =   TEXT(".IPNRN"); <br> <br>    DEBUGPRIVATE("CIPMConvert::HrSetMessageType()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_CIPMConvert_HrSetMessageType(lpszMessageClass); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Convert the class passed in to upper case. <br>    lstrcpyn(pszClassCaps, lpszMessageClass, ulMaxOutStringLen); <br>    (VOID)CharUpper(pszClassCaps); <br> <br>    if ( !TEST_STRING_PTR(pszClassCaps) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Make sure that this is an IPM message of some sort. <br>    if ( _tcsstr(pszClassCaps, lpszIPMClass) == NULL ) <br>    { <br>        // Message is not of type IPM. <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // See if this is a report. <br>    if ( _tcsstr(pszClassCaps, lpszReport) != NULL ) <br>    { <br>        // We have a report.  See what kind it is. <br>        if ( _tcsstr(pszClassCaps, lpszNDR) != NULL ) <br>        { <br>            // we have an NDR. <br>            m_MsgType = mtNDR; <br> <br>            goto cleanup; <br>        } <br> <br>        if ( _tcsstr(pszClassCaps, lpszDR) != NULL ) </code></pre>
<p>
</p>
<pre><code>{ <br>            // we have a DR. <br>            m_MsgType = mtDR; <br> <br>            goto cleanup; <br>        } <br> <br>        if ( _tcsstr(pszClassCaps, lpszNRN) != NULL ) <br>        { <br>            // we have a NRN. <br>            m_MsgType = mtNRN; <br> <br>            goto cleanup; <br>        } <br> <br>        if ( _tcsstr(pszClassCaps, lpszRN) != NULL ) <br>        { <br>            // we have an RN. <br>            m_MsgType = mtRN; <br> <br>            goto cleanup; <br>        } <br> <br>        // Otherwise, we have an unknown report type <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br> <br>    }   // end if have an IPM REPORT. <br> <br>    // Otherwise, we have an IPM message. <br>    m_MsgType = mtIPM; <br>     <br>    // We are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrParseIPMSpecific---------------------------------------- <br>// <br>// DESCRIPTION: Parses IPM specific tag and data lines. <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_OUTOFMEMORY if memory problems, <br>//                          E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrParseIPMSpecific() <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    LPTSTR          lpTag       =   NULL;   // tag string <br>    LPTSTR          lpData      =   NULL;   // data string <br>    ULONG           cb          =   0;      // byte count <br>    ULONG           cbRead      =   0;      // number of bytes read <br>    LARGE_INTEGER   sAdvance    =   {0};    // byte offset <br> <br>    // temporary buffer <br>    TCHAR   szTempBuffer[ulMaxOutStringLen] =   TEXT(""); <br> <br>    // MAPI property creation flags <br>    const ULONG ulFlags     =   MAPI_CREATE | MAPI_MODIFY |  <br>                                MAPI_DEFERRED_ERRORS; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrParseIPMSpecific()\n"); <br> <br>    // consistency checks <br>    ASSERTERROR(!FBadUnknown(m_lpStream), "Bad m_lpStream");    <br>    ASSERTERROR(m_MsgType == mtIPM, "Bad m_MsgType"); <br> <br>    // Parse the "----beginbody" tag and data line. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // number bytes read from stream <br>                &amp;lpTag,         // tag pointer <br>                &amp;lpData);       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check that we have the expected tag <br>    if ( lstrcmp(lpTag, lpszTagBodyHdr) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Determine number of bytes in body. <br>    cb = atol(lpData); <br> <br>    if ( cb ) <br>    { <br>        if ( m_fTNEFEncode == TRUE ) <br>        { <br>            // don't create the PR_RTF_COMPRESSED property <br>            // on the content.  Let the TNEF decoding function <br>            // do this for us. <br>            // Merely skip over the message body text in the <br>            // input stream. <br>            sAdvance.LowPart = cb;  // # of bytes to advance <br>            hr = m_lpStream-&gt;Seek( <br>                        sAdvance,   // # bytes to advance <br>                        STREAM_SEEK_CUR,    // from current position <br>                        NULL);      // don't care <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>        }   // end if doing TNEF encoding <br> <br>        else    // not doing TNEF encoding <br>        { <br>            // Consistency checking <br>            ASSERTERROR(!FBadUnknown(m_lpContent), "Bad m_lpContent"); <br> <br>            // Create the RTF compressed text data in the message <br>            // from the ANSI body text. <br>            hr = HrTextToRTFCompressed( <br>                cb/sizeof(CHAR),// # characters of ANSI text <br>                m_lpStream,     // ANSI text stream pointer <br>0,// don't save attachment rendering positions <br>NULL,// don't save attachment rendering positions <br>                m_lpContent,    // MAPI message pointer <br>0);             // use current code page <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if not doing TNEF encoding <br>    }   // end if body text <br> <br>    // Free the tag and data <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br> <br>    // Read in the "\n----endbody\n" marker <br>    hr = m_lpStream-&gt;Read( <br>                szTempBuffer,   // marker <br>                lstrlen(lpszTagBodyEnd) * sizeof(TCHAR), // length (no terminator) <br>                &amp;cbRead);       // number of bytes read. <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Check that the tag is what we expect. <br>    if ( lstrcmp(szTempBuffer, lpszTagBodyEnd) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done (attachments are handled by HrCreateNextAttachment(). <br> <br>cleanup: <br> <br>    // Free tag and data <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrParseRecipients------------------------------------------- <br>// <br>// DESCRIPTION: Parses recipient tag and data lines &amp; saves addresses <br>// <br>// INPUT:   lpszTag --  expected tag <br>// <br>// INPUT/OUTPUT:    lppAdrList   --  target address list pointer <br>//           <br>// OUTPUT:  pnRecips    --  number of recipients of type found <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_OUTOFMEMORY if memory problems, <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrParseRecipients( <br>        IN LPCTSTR lpszTag,     // expected tag <br>        IN ULONG ulType,        // MAPI recipient type <br>        IN OUT LPADRLIST * lppAdrList, // target address list <br>        OUT ULONG * pnRecips)   // # recipients found of type <br>{ <br>    HRESULT         hr              =   NOERROR; <br>    LPTSTR          lpTag           =   NULL;       // tag string <br>    LPTSTR          lpData          =   NULL;       // data string <br>    ULONG           cbRead          =   0;          // # bytes read <br>    LARGE_INTEGER   sOffsetBack     =   {0};        // # bytes to back up by <br>LONGLONGcbBack=0;// # bytes to back up by <br>    LPSPropValue    lpsRecipProps   =   NULL;       // property value array pointer <br>    ULONG           cbEid           =   0;          // number of bytes in entry identifier <br>    LPENTRYID       lpEid           =   NULL;       // entry identifier <br>    ULONG           cbName          =   0;          // # bytes in email address <br>    DWORD           cbSize          =   0;          // sizeof of property value array <br> <br>    // recipient property array indices <br>    const UINT      iEmailAddr      =   0;          // email address <br>    const UINT      iRecipType      =   1;          // recipient type <br>    const UINT      iName           =   2;          // display name <br>    const UINT      iEID            =   3;          // recipient entry identifier <br>    const UINT      iAddrType       =   4;          // address type <br>    const UINT      iRecipNumber    =   5;          // recipient number <br> <br>    // # of recipient properties <br>    const ULONG     nRecipProps     =   6;           <br> <br>    DEBUGPRIVATE("CIPMConvert::HrParseRecipients()\n"); <br> <br>    // consistency checking <br> <br>    // check input paramters <br>    hr = CHK_CIPMConvert_HrParseRecipients(lpszTag, ulType,  <br>                                           lppAdrList, pnRecips); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // initialize input parameters. <br>    *pnRecips = 0; <br> <br>    while ( TRUE ) <br>    { <br>        // Free MAPI buffers <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br>        MAPIFREEBUFFER(lpEid); <br> <br>        MAPIFREEBUFFER(lpsRecipProps); <br> <br>        // Parse one recipient tag and data line at a time. <br>        hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // #bytes read <br>                &amp;lpTag,         // tag pointer <br>                &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Check that tag is of expected type. <br>        if ( lstrcmp(lpTag, lpszTag) != 0 ) <br>        { <br>            // Have run out of recipients of desired type. <br>            // This is not an error. <br>            // Back up to beginning of line just read. <br>            cbBack = ((LONGLONG) (-1)) * cbRead; <br> <br>sOffsetBack.LowPart = LOWLONG(cbBack); <br>sOffsetBack.HighPart = HILONG(cbBack); <br> <br>            hr = m_lpStream-&gt;Seek( <br>                sOffsetBack,        // number of bytes to back up by <br>                STREAM_SEEK_CUR,    // from current position <br>                NULL); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            goto cleanup; <br> <br>        }   // end if look ahead data not what we want <br> <br>        // Have found a recipient. <br>        (*pnRecips)++;    // increment count <br> <br>        // Allocate memory for this recipients properties. <br>        // (Must do dynamic allocation, as IMessage::ModifyRecipients <br>        // may reallocate property array buffer.). <br>        cbSize = sizeof(SPropValue) * nRecipProps;      // sizeof property value array <br>        hr = MAPIAllocateBuffer( <br>                    cbSize,   // # bytes to allocate <br>                    (VOID **) &amp;lpsRecipProps);                    // pointer to array pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        // Initialize property value array <br>        ZeroMemory( <br>                    lpsRecipProps,      // buffer <br>                    cbSize);            // size of buffer <br> <br>        // Allocate additional memory for the e-mail address. <br>        cbName = cbStrLen(lpData); <br>        hr = MAPIAllocateMore( <br>                    cbName,                                 // # additional bytes <br>                    lpsRecipProps,                          // original buffer <br>                    (VOID **) &amp;(lpsRecipProps[iEmailAddr].Value.LPSZ));        // email address buffer <br> <br>        if ( FAILED(hr) ) <br>        {    <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br>         <br>        // Set up properties for this recipient. <br>        lpsRecipProps[iEmailAddr].ulPropTag = PR_EMAIL_ADDRESS;   // e-mail address <br>        lstrcpy( <br>                lpsRecipProps[iEmailAddr].Value.LPSZ, <br>                lpData); <br> <br>        lpsRecipProps[iRecipType].ulPropTag = PR_RECIPIENT_TYPE;  // recipient type <br>        lpsRecipProps[iRecipType].Value.l = ulType; <br> <br>        // Allocate more memory for display name <br>        hr = MAPIAllocateMore( <br>                    cbName,                             <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iName].Value.LPSZ));     // display name buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        lpsRecipProps[iName].ulPropTag = PR_DISPLAY_NAME;   // display name <br>        lstrcpy( <br>                lpsRecipProps[iName].Value.LPSZ, <br>                lpData); <br> <br>        ASSERTERROR(!FBadUnknown(m_lpAB), "Bad m_lpAB"); <br>        ASSERTERROR(!IsBadStringPtr(m_lpszAddrType, INFINITE), <br>                    "Bad lpszAddrType"); <br> <br>        // Create an entry identifier for this "one off" address <br>        hr = m_lpAB-&gt;CreateOneOff( <br>                    lpData,         // PR_DISPLAY_NAME <br>                    (LPTSTR) m_lpszAddrType,   // PR_ADDRTYPE <br>                    lpData,         // PR_EMAIL_ADDRESS <br>                    0,              // flags <br>                    &amp;cbEid,         // #bytes in entry ID <br>                    &amp;lpEid);        // entry identifier <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Allocate more memory for entry identifier <br>        hr = MAPIAllocateMore( <br>                    cbEid,              // # bytes to add <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iEID].Value.bin.lpb));         // entry identifier buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        lpsRecipProps[iEID].ulPropTag = PR_ENTRYID;        // entry identifier <br>        lpsRecipProps[iEID].Value.bin.cb = cbEid; <br>        CopyMemory( <br>               lpsRecipProps[iEID].Value.bin.lpb,   // destination buffer <br>               lpEid,                               // source buffer <br>               cbEid);                              // count bytes <br> <br>        // Allocate more memory for address type <br>        hr = MAPIAllocateMore( <br>                    cbStrLen(m_lpszAddrType),   // # bytes to add <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iAddrType].Value.LPSZ));    // address type buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        lpsRecipProps[iAddrType].ulPropTag = PR_ADDRTYPE; <br>        lstrcpy( <br>                lpsRecipProps[iAddrType].Value.LPSZ, <br>                m_lpszAddrType); <br> <br>        lpsRecipProps[iRecipNumber].ulPropTag = PR_RECIPIENT_NUMBER; <br>        lpsRecipProps[iRecipNumber].Value.l = -1; <br> <br>        if ( *lppAdrList == NULL ) <br>        { <br>            // Create a new address list. <br>            hr = HrMAPICreateAddressList( <br>                nRecipProps,    // number of properties for address <br>                lpsRecipProps,  // recipient properties <br>                lppAdrList);    // target address list pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        } <br> <br>        else <br>        { <br>            // Append recipient to address list. <br>            hr = HrMAPIAppendAddressList( <br>                nRecipProps,    // number of properties for address <br>                lpsRecipProps,  // recipient properties <br>                lppAdrList);    // target address list pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if already have address list <br>    }   // end while <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br>    MAPIFREEBUFFER(lpEid); <br> <br>    // HrMAPICreateAddressList makes a duplicate of the <br>    // property value array passed into it.  Thus, free <br>    // property value array here. <br>    MAPIFREEBUFFER(lpsRecipProps); <br> <br>    // caller "owns" address list. <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrParseExternalTraceData-------------------------------------- <br>// <br>// DESCRIPTION: Parse trace tag and data lines and store data. <br>// <br>// OUTPUT:  pnEntries   --  # of trace entries found <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrParseExternalTraceData( <br>        OUT ULONG * pnEntries)   // # trace entries found <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    LPTSTR          lpTag       =   NULL;       // tag string <br>    LPTSTR          lpData      =   NULL;       // data string <br>    ULONG           cbRead      =   0;          // # bytes read from stream <br>    LARGE_INTEGER   sOffsetBack =   {0};        // number of bytes to seek <br>LONGLONGcbBack=0;// number of bytes to seek <br> <br>    LONG        lAction     =   0;          // trace action <br>    FILETIME    ftArrival   =   {0};        // arrival time structure <br>    FILETIME    ftDeferred  =   {0};        // deferred time structure <br> <br>    TCHAR       pszADMD[MAX_ADMD_NAME_SIZ]         = TEXT(""); // ADMD name <br>    TCHAR       pszCountry[MAX_COUNTRY_NAME_SIZ]   = TEXT(""); // country name <br>    TCHAR       pszPRMDId[MAX_PRMD_NAME_SIZ]       = TEXT(""); // PRMD ID <br>    TCHAR       pszAttADMD[MAX_ADMD_NAME_SIZ]      = TEXT(""); // attempted ADMD name <br>    TCHAR       pszAttCountry[MAX_COUNTRY_NAME_SIZ]= TEXT(""); // attempted country name <br>    TCHAR       pszAttPRMDId[MAX_PRMD_NAME_SIZ]    = TEXT(""); // attempted PRMD ID <br> <br>    DEBUGPRIVATE("CIPMConvert::HrParseExternalTraceData()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CIPMConvert_HrParseExternalTraceData(pnEntries); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pnEntries = 0;     // initialize output <br> <br>    while ( TRUE ) <br>    { <br>        // Parse "External-Received-By" tag and data line. <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check tag. <br>        if ( lstrcmp(lpTag, lpszTagExternalRcvdBy) != 0 ) <br>        { <br>            // There are no more trace entries. <br>            // This isn't an error. <br>            // Rewind back to before this string. <br>            cbBack = ((LONGLONG) (-1)) * cbRead; <br> <br>sOffsetBack.LowPart = LOWLONG(cbBack); <br>sOffsetBack.HighPart = HILONG(cbBack); <br> <br>            hr = m_lpStream-&gt;Seek( <br>                    sOffsetBack,        // offset <br>                    STREAM_SEEK_CUR,    // from current position <br>                    NULL); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            goto cleanup; <br>        } <br> <br>        // Parse the external trace data into its individual components. <br>        hr = HrParseExternalTraceString( <br>                lpData,     // trace data string <br>                &amp;lAction,   // trace action <br>                pszCountry, // country name <br>                pszADMD,    // ADMD name <br>                pszPRMDId); // PRMD identifier <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free MAPI buffer <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Parse "External-Received At" tag and data line. <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check tag. <br>        if ( lstrcmp(lpTag, lpszTagExternalRcvdAt) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Convert the date/time string to a file time <br>        // structure. <br>        hr = HrParseDateTimeString( <br>                lpData,         // date time string <br>                &amp;ftArrival);    // file time structure <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free MAPI buffers <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Parse "External-Attempted-By" tag and data line. <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check the tag <br>        if ( lstrcmp(lpTag, lpszTagExternalAttmBy) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Parse the data into its individual components <br>        hr = HrParseExternalTraceString( <br>                lpData,         // trace data string <br>                &amp;lAction,       // trace action <br>                pszAttCountry,  // attempted country name <br>                pszAttADMD,     // attempted ADMD name <br>                pszAttPRMDId);  // attempted PRMD identifier <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free MAPI buffers <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Parse "External-Deferred-At" tag and data line. <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check tag. <br>        if ( lstrcmp(lpTag, lpszTagExternalDefdAt) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Convert the date/time string to a file time <br>        // structure. <br>        hr = HrParseDateTimeString( <br>                lpData,         // date time string <br>                &amp;ftDeferred);   // file time structure <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free MAPI buffers <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Append this trace entry information to the <br>        // trace information list. <br>        if ( m_lpTraceInfo == NULL ) <br>        { <br>            // create list with entry. <br>            hr = HrTraceCreateEntryList( <br>                    lAction,        // trace action <br>                    ftArrival,      // arrival time <br>                    ftDeferred,     // deferred time <br>                    pszADMD,        // ADMD name <br>                    pszCountry,     // country name <br>                    pszPRMDId,      // PRMD identifier <br>                    pszAttADMD,     // attempted ADMD <br>                    pszAttCountry,  // attempted country <br>                    pszAttPRMDId,   // attempted PRMD ID <br>                    &amp;m_lpTraceInfo);    // pointer to trace information pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        } <br> <br>        else <br>        { <br>            // append entry to list <br>            hr = HrTraceAppendEntryList( <br>                    lAction,        // trace action <br>                    ftArrival,      // arrival time <br>                    ftDeferred,     // deferred time <br>                    pszADMD,        // ADMD name <br>                    pszCountry,     // country name <br>                    pszPRMDId,      // PRMD identifier <br>                    pszAttADMD,     // attempted ADMD <br>                    pszAttCountry,  // attempted country <br>                    pszAttPRMDId,   // attempted PRMD ID <br>                    &amp;m_lpTraceInfo);    // pointer to trace information pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if trace information list exists <br> <br>        (*pnEntries)++;   // increment # of entries found <br> <br>    }   // end while <br> <br>    // we are done. <br>         <br>cleanup: <br>     <br>    // free MAPI buffers <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrParseInternalTraceData-------------------------------------- <br>// <br>// DESCRIPTION: Parse trace tag and data lines and store data. <br>// <br>// OUTPUT:  pnEntries   --  # of trace entries found <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrParseInternalTraceData( <br>        OUT ULONG * pnEntries)   // # trace entries found <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    LPTSTR          lpTag       =   NULL;       // tag string <br>    LPTSTR          lpData      =   NULL;       // data string <br>    ULONG           cbRead      =   0;          // # bytes read from stream <br>    LARGE_INTEGER   sOffsetBack =   {0};        // number of bytes to seek <br>LONGLONGcbBack=0;// number of bytes to seek <br> <br>    LONG        lAction     =   0;          // trace action <br>    FILETIME    ftArrival   =   {0};        // arrival time structure <br>    FILETIME    ftDeferred  =   {0};        // deferred time structure <br> <br>    TCHAR       pszADMD[MAX_ADMD_NAME_SIZ]         = TEXT(""); // ADMD name <br>    TCHAR       pszCountry[MAX_COUNTRY_NAME_SIZ]   = TEXT(""); // country name <br>    TCHAR       pszPRMDId[MAX_PRMD_NAME_SIZ]       = TEXT(""); // PRMD ID <br>    TCHAR       pszMTA[MAX_ADMD_NAME_SIZ]          = TEXT(""); // MTA name <br>    TCHAR       pszAttADMD[MAX_ADMD_NAME_SIZ]      = TEXT(""); // attempted ADMD name <br>    TCHAR       pszAttCountry[MAX_COUNTRY_NAME_SIZ]= TEXT(""); // attempted country name <br>    TCHAR       pszAttPRMDId[MAX_PRMD_NAME_SIZ]    = TEXT(""); // attempted PRMD ID <br>    TCHAR       pszAttMTA[MAX_MTA_NAME_SIZ]        = TEXT(""); // attempted MTA name <br> <br>    DEBUGPRIVATE("CIPMConvert::HrParseInternalTraceData()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CIPMConvert_HrParseInternalTraceData(pnEntries); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pnEntries = 0;     // initialize output <br> <br>    while ( TRUE ) <br>    { <br>        // Parse "Internal-Received-By" tag and data line. <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check tag. <br>        if ( lstrcmp(lpTag, lpszTagInternalRcvdBy) != 0 ) <br>        { <br>            // There are no more trace entries. <br>            // This isn't an error. <br>            // Rewind back to before this string. <br>            cbBack = ((LONGLONG) (-1)) * cbRead; <br> <br>sOffsetBack.LowPart = LOWLONG(cbBack); <br>sOffsetBack.HighPart = HILONG(cbBack); <br> <br>            hr = m_lpStream-&gt;Seek( <br>                    sOffsetBack,        // offset <br>                    STREAM_SEEK_CUR,    // from current position <br>                    NULL); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            goto cleanup; <br>        } <br> <br>        // Parse the internal trace data into its individual components. <br>        hr = HrParseInternalTraceString( <br>                lpData,     // trace data string <br>                &amp;lAction,   // trace action <br>                pszCountry, // country name <br>                pszADMD,    // ADMD name <br>                pszPRMDId,  // PRMD identifier <br>                pszMTA);    // MTA name <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free MAPI buffer <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Parse "Internal-Received At" tag and data line. <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check tag. <br>        if ( lstrcmp(lpTag, lpszTagInternalRcvdAt) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Convert the date/time string to a file time <br>        // structure. <br>        hr = HrParseDateTimeString( <br>                lpData,         // date time string <br>                &amp;ftArrival);    // file time structure <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free MAPI buffers <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Parse "Internal-Attempted-By" tag and data line. <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check the tag <br>        if ( lstrcmp(lpTag, lpszTagInternalAttmBy) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Parse the data into its individual components <br>        hr = HrParseInternalTraceString( <br>                lpData,         // trace data string <br>                &amp;lAction,       // trace action <br>                pszAttCountry,  // attempted country name <br>                pszAttADMD,     // attempted ADMD name </code></pre>
<p>
</p>
<pre><code>pszAttPRMDId,   // attempted PRMD identifier <br>                pszAttMTA);     // attempted MTA name <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free MAPI buffers <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Parse "Internal-Deferred-At" tag and data line. <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check tag. <br>        if ( lstrcmp(lpTag, lpszTagInternalDefdAt) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Convert the date/time string to a file time <br>        // structure. <br>        hr = HrParseDateTimeString( <br>                lpData,         // date time string <br>                &amp;ftDeferred);   // file time structure <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free MAPI buffers <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Append this trace entry information to the <br>        // trace information list. <br>        if ( m_lpIntTraceInfo == NULL ) <br>        { <br>            // create list with entry. <br>            hr = HrInternalTraceCreateEntryList( <br>                    lAction,        // trace action <br>                    ftArrival,      // arrival time <br>                    ftDeferred,     // deferred time <br>                    pszADMD,        // ADMD name <br>                    pszCountry,     // country name <br>                    pszPRMDId,      // PRMD identifier <br>                    pszMTA,         // MTA name <br>                    pszAttADMD,     // attempted ADMD <br>                    pszAttCountry,  // attempted country <br>                    pszAttPRMDId,   // attempted PRMD ID <br>                    pszAttMTA,      // attempted MTA <br>                    &amp;m_lpIntTraceInfo);    // pointer to trace information pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        } <br> <br>        else <br>        { <br>            // append entry to list <br>            hr = HrInternalTraceAppendEntryList( <br>                    lAction,        // trace action <br>                    ftArrival,      // arrival time <br>                    ftDeferred,     // deferred time <br>                    pszADMD,        // ADMD name <br>                    pszCountry,     // country name <br>                    pszPRMDId,      // PRMD identifier <br>                    pszMTA,         // MTA name <br>                    pszAttADMD,     // attempted ADMD <br>                    pszAttCountry,  // attempted country <br>                    pszAttPRMDId,   // attempted PRMD ID <br>                    pszAttMTA,      // attempted MTA <br>                    &amp;m_lpIntTraceInfo);    // pointer to trace information pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if trace information list exists <br> <br>        (*pnEntries)++;   // increment # of entries found <br> <br>    }   // end while <br> <br>    // we are done. <br>         <br>cleanup: <br>     <br>    // free MAPI buffers <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrCreateContent--------------------------------------------- <br>// <br>// DESCRIPTION: Create an envelope content message. <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrCreateContent() <br>{ <br>    HRESULT             hr              =   NOERROR; <br>    ULONG               ulAttachNum     =   0;      // attachment number <br>    LPSPropProblemArray lpsProblems     =   NULL;   // problem array pointer <br> <br>    // MAPI flags <br>    const ULONG ulFlags                 =    <br>        MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS; <br> <br>    // property array indices <br>    const UINT  iMethod                 =   0;       <br>    const UINT  iPosition               =   1; <br> <br>    const UINT  nProps                  =   2;      // # of properties <br> <br>    SPropValue  rgAttachProps[nProps]   =   {0};    // array of properties <br> <br>    DEBUGPRIVATE("CIPMConvert::HrCreateContent()\n"); <br> <br>    // consistency checks <br>    ASSERTERROR(!FBadUnknown(m_lpEnvelope), "Bad m_lpEnvelope"); <br>    ASSERTERROR((m_MsgType == mtIPM || m_MsgType == mtRN || m_MsgType == mtNRN), <br>                "Bad m_MsgType"); <br> <br>    // If we are doing TNEF decoding, let TNEF create <br>    // the envelope attachment &amp; content. <br>    if ( m_fTNEFEncode == TRUE ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = m_lpEnvelope-&gt;CreateAttach( <br>                NULL,           // interface ID pointer <br>                MAPI_DEFERRED_ERRORS,   // MAPI flags (reduces RPC calls) <br>                &amp;ulAttachNum,   // attachment number <br>                &amp;m_lpAttach);   // pointer to attachment pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!FBadUnknown(m_lpAttach), "Bad m_lpAttach"); <br> <br>    // Set the appropriate attachment properties for a  <br>    // content message. <br>    rgAttachProps[iMethod].ulPropTag = PR_ATTACH_METHOD;  // property tag <br>    rgAttachProps[iMethod].Value.l = ATTACH_EMBEDDED_MSG; // value <br> <br>    rgAttachProps[iPosition].ulPropTag = PR_RENDERING_POSITION; <br>    rgAttachProps[iPosition].Value.l = INFINITE;  // default <br> <br>    // Set attachment properties <br>    hr = m_lpAttach-&gt;SetProps( <br>                nProps,         // # of properties <br>                rgAttachProps,  // array of properties <br>                &amp;lpsProblems);  // problem array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        lpsProblems = NULL;     // so we can safely release it <br> <br>        goto cleanup; <br>    } <br> <br>    // check problem array <br>    if ( lpsProblems ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Create a message attachment. <br>    hr = m_lpAttach-&gt;OpenProperty( <br>                PR_ATTACH_DATA_OBJ,     // for a message object <br>                &amp;IID_IMessage,          // MAPI message interface <br>                0,                      // interface flags <br>                ulFlags,                // MAPI property creation flags <br>                (LPUNKNOWN *) &amp;m_lpContent);          // envelope content pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!FBadUnknown(m_lpContent), "Bad m_lpContent"); <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    // FREE MAPI buffers <br>    MAPIFREEBUFFER(lpsProblems); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrCreateNextAttachment-------------------------------------- <br>// <br>// DESCRIPTION: Parse and create next envelope content attachment. <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      EDK_E_NOT_FOUND if no more attachments <br>//                      E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrCreateNextAttachment() <br>{ <br>    HRESULT         hr              =   NOERROR; <br>    LPTSTR          lpTag           =   NULL;   // tag string <br>    LPTSTR          lpData          =   NULL;   // data string <br>    ULONG           cb              =   0;      // # of bytes in attachment <br>    LPTSTR          lpszFileName    =   NULL;   // file name string <br>    ULONG           cbRead          =   0;      // # bytes read from stream <br>    LPATTACH        lpAttach        =   NULL;   // attachment pointer <br>    ULONG           ulAttachNum     =   0;      // attachment number <br>    PVIRTUALSTREAMONPROPERTYlpAttachStream  =   NULL;   // buffered stream <br>    LARGE_INTEGER   sOffset         =   {0};    // # bytes to retreat <br>LONGLONGcbOffset=0;// # bytes to retreat <br>    ULARGE_INTEGER  sSize           =   {0};    // # bytes in attachment <br> <br>    // temporary string buffer <br>    TCHAR       szTempBuffer[ulMaxOutStringLen] =   TEXT(""); <br> <br>   // MAPI property creation flags <br>    const ULONG ulFlags     =   MAPI_CREATE | MAPI_MODIFY | <br>                                MAPI_DEFERRED_ERRORS;   // reduces RPCs <br> <br>    const UINT  cProps      =   5;      // number of properties in array <br>    const UINT  iFileName   =   0;      // file name property index <br>    const UINT  iLongName   =   1;      // long file name property index <br>    const UINT  iMethod     =   2;      // attachment method property index <br>    const UINT  iPosition   =   3;      // renderning position property index <br>    const UINT  iName       =   4;      // display name property index <br> <br>    // Property tag array for an attachment <br>    SPropValue  sAttachProps[cProps]    =   {0}; <br> <br>    // property problem array pointer <br>    LPSPropProblemArray lpProblems      =   NULL;    <br> <br>    DEBUGPRIVATE("CIPMConvert::HrCreateNextAttachment()\n"); <br> <br>    // Parse "----beginattach" tag and data <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // # bytes read <br>                &amp;lpTag,         // tag pointer <br>                &amp;lpData);       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    {                 <br>        goto cleanup; <br>    } <br> <br>    // Check the tag. <br>    if ( lstrcmp(lpTag, lpszTagAttachHdr) != 0 ) <br>    { <br>        // We have read ahead to far. <br>        // (TNEF data may follow) <br>        // Back up to where we were before. <br>        cbOffset = ((LONGLONG) (-1)) * cbRead; // negative offset <br> <br>sOffset.LowPart = LOWLONG(cbOffset); <br>sOffset.HighPart = HILONG(cbOffset); <br> <br>        hr = m_lpStream-&gt;Seek( <br>                    sOffset,    // # bytes to retreat <br>                    STREAM_SEEK_CUR,    // from current position <br>                    NULL);      // don't care <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Let caller know that there are no more attachments <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br> <br>        goto cleanup; <br>    } <br> <br>    // Parse attachment header data into file name <br>    // and file size (in bytes) components. <br>    hr = HrParseAttachmentHeader( <br>                lpData,     // attachment header data <br>                &amp;lpszFileName,// file name <br>                &amp;cb);       // number of bytes in attachment <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(lpszFileName != NULL, "Bad lpszFileName"); <br> <br>    // check to make sure that attachment file name isn't empty. <br>    if ( *lpszFileName == 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Note: Only support binary attachments at this time. <br> <br>    // free MAPI buffers <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br> <br>    if ( m_fTNEFEncode == FALSE )   // If not doing TNEF decoding <br>    { <br>        // consistency check <br>        ASSERT_IUNKNOWN_PTR(m_lpContent, "Bad m_lpContent"); <br> <br>        // Create attachment <br>        hr = m_lpContent-&gt;CreateAttach( <br>                NULL,           // interface ID pointer <br>                MAPI_DEFERRED_ERRORS,   // flags (reduces RPCs) <br>                &amp;ulAttachNum,   // attachment number <br>                &amp;lpAttach);     // pointer to attachment pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ASSERT_IUNKNOWN_PTR(lpAttach, "Bad lpAttach"); <br> <br>        // Create a buffered stream on the attachment's binary data and <br>        // read the attachment data into it. <br>hr = HrOpenVirtualStreamOnProperty( <br>lpAttach,// MAPI property object pointer <br>            PR_ATTACH_DATA_BIN, // property tag <br>            ulFlags,            // MAPI property creation flags <br>            &amp;lpAttachStream); // buffered stream pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ASSERT_IUNKNOWN_PTR(lpAttachStream, "Bad lpAttachStream"); <br> <br>        // Read the attachment data into the attachment stream. <br>        sSize.LowPart = cb;         // # bytes in attachment <br>        hr = m_lpStream-&gt;CopyTo(    // source stream <br>            (LPSTREAM) lpAttachStream,// destination stream <br>            sSize,                  // # bytes to copy <br>            NULL, <br>            NULL); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>// Commit changes to the attachment data stream. <br>// We must do this, since the stream is buffered. <br>hr = lpAttachStream-&gt;Commit( <br>0);// not going to do anything else with it <br> <br>if ( FAILED(hr) ) <br>{ <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br>    }   // end if not doing TNEF decoding <br> <br>    else    // are doing TNEF decoding <br>    { <br>        // Let TNEF extract the attachments. <br>        // Merely skip over the attachment data for now. <br>        sOffset.LowPart = cb;    // # of bytes <br>        hr = m_lpStream-&gt;Seek( <br>                    sOffset,    // # bytes to advance <br>                    STREAM_SEEK_CUR,    // from current position, <br>                    NULL);      // don't care <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>    }   // end if doing TNEF decoding <br> <br>    // Read in "----endattach" marker <br>    hr = m_lpStream-&gt;Read( <br>            szTempBuffer,   // data buffer <br>            lstrlen(lpszTagAttachEnd) * sizeof(TCHAR), // length (no terminator) <br>            &amp;cbRead);       // number of bytes read <br> <br>    // test the marker <br>    if ( lstrcmp(szTempBuffer, lpszTagAttachEnd) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    if ( m_fTNEFEncode == FALSE ) <br>    { <br>        // Set attachment properties. <br>        sAttachProps[iFileName].ulPropTag = PR_ATTACH_FILENAME;     // property tag <br>        sAttachProps[iFileName].Value.LPSZ = lpszFileName;            // file name <br> <br>        sAttachProps[iLongName].ulPropTag = PR_ATTACH_LONG_FILENAME;// property tag <br>        sAttachProps[iLongName].Value.LPSZ = lpszFileName;            // file name <br> <br>        sAttachProps[iMethod].ulPropTag = PR_ATTACH_METHOD; // property tag <br>        sAttachProps[iMethod].Value.l = ATTACH_BY_VALUE;    // value <br> <br>        sAttachProps[iPosition].ulPropTag = PR_RENDERING_POSITION; <br>        sAttachProps[iPosition].Value.l = INFINITE;         // default <br> <br>        sAttachProps[iName].ulPropTag = PR_DISPLAY_NAME;    // property tag <br>        sAttachProps[iName].Value.LPSZ = lpszFileName;        // file name <br> <br>        // Set properties. <br>        hr = lpAttach-&gt;SetProps( <br>            cProps,                 // # property values <br>            (LPSPropValue) &amp;sAttachProps,   // property value array <br>            &amp;lpProblems);           // problem array pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            lpProblems = NULL; <br>         <br>            goto cleanup; <br>        } <br> <br>        // Fail if not all properties were set. <br>        if ( lpProblems ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Save changes to the attachment <br>        hr = lpAttach-&gt;SaveChanges( <br>                MAPI_DEFERRED_ERRORS);      // save's RPCs <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br>    }   // end if not doing TNEF decoding <br> <br>    // we are done with this attachment <br> <br>cleanup: <br> <br>    // Release MAPI objects <br>    ULRELEASE(lpAttach); <br>    ULRELEASE(lpAttachStream); <br> <br>    // free MAPI buffers <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br>    MAPIFREEBUFFER(lpszFileName); <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrSetEnvelopeProps------------------------------------------------------- <br>// <br>// DESCRIPTION: Sets IPM envelope properties <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrSetEnvelopeProps() <br>{ <br>    HRESULT             hr                  =   NOERROR; <br>    LPSPropProblemArray lpsProblems         =   NULL;   // property problem array <br>    ULONG               cbEid               =   0;      // # bytes in entry ID <br>    LPENTRYID           lpEid               =   NULL;   // entry identifier <br>    LPTSTR              lpszSubjectPrefix   =   NULL;   // subject prefix <br>    LPTSTR              lpszNormSubject     =   NULL;   // normalized subject <br>    FILETIME            ftArrival           =   {0};    // arrival time <br>    LPTSTR              lpMailFromAddr      =   NULL;   // Mail from address <br>    ULONG               nEnvProps           =   0;      // # of envelope properties <br>    BOOL                fDRRequested        =   FALSE;  // TRUE if DRs requeted for IPM <br> <br>    // message envelope class <br>    TCHAR               pszMsgClass[ulMaxOutStringLen * 2]  =   TEXT(""); <br> <br>    // Property value array indices <br>    const UINT  iClassVal               =   0; <br>    const UINT  iFromAddrVal            =   1; <br>    const UINT  iFromNameVal            =   2; <br>    const UINT  iFromEidVal             =   3; <br>    const UINT  iFromAddrTypeVal        =   4; <br>    const UINT  iXIDVal                 =   5; <br>    const UINT  iSubjectVal             =   6; <br>    const UINT  iDeleteVal              =   7; <br>    const UINT  iArrivalTimeVal         =   8; <br> <br>    // properties specific to IPMs <br>    const UINT  iDRRequested            =   9; <br> <br>    // minimum number of IPM envelope properties <br>    const ULONG nIPMEnvProps            =   10; <br> <br>    // properties specific to notifications <br>    const UINT  iNotifyReqVal           =   9; <br> <br>    // minimum number of notification properties <br>    const ULONG nNotifyEnvProps         =   10; <br> <br>    // property value array <br>    // NOTE:  The PR_TRACE_INFO and the PR_INTERNAL_TRACE_INFO properties <br>    // are optional. Thus, the maximum number of envelope properties <br>    // is two more than the minimum number of notify properties. <br>    SPropValue  rgEnvProps[nNotifyEnvProps + 2] =   {0};  <br> <br>    const LPCTSTR   lpszEnvClass        =   TEXT("ENVELOPE."); <br> <br>    DEBUGPRIVATE("CIPMConvert::HrSetEnvelopeProps()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR(!FBadUnknown(m_lpEnvelope), "Bad m_lpEnvelope"); <br>    ASSERTERROR((m_MsgType == mtIPM || m_MsgType == mtNRN || m_MsgType == mtRN), <br>                 "Bad m_MsgType"); <br> <br>    // have an IPM envelope <br>    lstrcpy(pszMsgClass, lpszEnvClass); <br> <br>    // Append message class to envelope class. <br>    lstrcat(pszMsgClass, m_rgszData[iClass]); <br> <br>    // Set properties on envelope. <br>    rgEnvProps[iClassVal].ulPropTag = PR_MESSAGE_CLASS; <br>    rgEnvProps[iClassVal].Value.LPSZ = pszMsgClass; <br> <br>    lpMailFromAddr = m_rgszData[iMailFrom]; // mail from address <br>    rgEnvProps[iFromAddrVal].ulPropTag = PR_ORIGINATOR_ADDR; <br>    rgEnvProps[iFromAddrVal].Value.LPSZ = lpMailFromAddr; <br> <br>    rgEnvProps[iFromNameVal].ulPropTag = PR_ORIGINATOR_NAME; <br>    rgEnvProps[iFromNameVal].Value.LPSZ = lpMailFromAddr; <br> <br>    // Create an entry identifier for this "one off" address <br>    hr = m_lpAB-&gt;CreateOneOff( <br>                    lpMailFromAddr,     // name <br>                    (LPTSTR) m_lpszAddrType,   // address type <br>                    lpMailFromAddr,     // address <br>                    0,              // flags <br>                    &amp;cbEid,         // #bytes in entry ID <br>                    &amp;lpEid);        // entry identifier <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    rgEnvProps[iFromEidVal].ulPropTag = PR_ORIGINATOR_ENTRYID; <br>    rgEnvProps[iFromEidVal].Value.bin.cb = cbEid; <br>    rgEnvProps[iFromEidVal].Value.bin.lpb = (BYTE *) lpEid; <br> <br>    rgEnvProps[iFromAddrTypeVal].ulPropTag = PR_ORIGINATOR_ADDRTYPE; <br>    rgEnvProps[iFromAddrTypeVal].Value.LPSZ = (LPTSTR) m_lpszAddrType; <br> <br>    rgEnvProps[iXIDVal].ulPropTag = PR_MESSAGE_SUBMISSION_ID; <br>    rgEnvProps[iXIDVal].Value.bin.cb =  <br>        cbStrLen(m_rgszData[iXID]); <br>    rgEnvProps[iXIDVal].Value.bin.lpb = (BYTE *) m_rgszData[iXID]; <br> <br>    rgEnvProps[iSubjectVal].ulPropTag = PR_SUBJECT;       // same as for content <br>    rgEnvProps[iSubjectVal].Value.LPSZ = m_rgszData[iSubject]; <br> <br>    rgEnvProps[iDeleteVal].ulPropTag = PR_DELETE_AFTER_SUBMIT; <br>    rgEnvProps[iDeleteVal].Value.b = TRUE; <br> <br>    // Determine the arrival time.  This is the current time! <br> <br>    GetSystemTimeAsFileTime( &amp;ftArrival); <br> <br>    rgEnvProps[iArrivalTimeVal].ulPropTag = PR_ARRIVAL_TIME; <br>    rgEnvProps[iArrivalTimeVal].Value.ft = ftArrival; <br> <br>    // Set the properties unique to notifications <br>    // and set the number of properties to set <br>    if ( m_MsgType == mtIPM ) <br>    { <br>        // Set the PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED property, <br>        // when available, so that delivery reports will be generated. <br>        if ( m_fTNEFEncode == TRUE ) <br>        { <br>            // Value of PR_ORIGINATORY_DELIVERY_REPORT_REQUESTED is <br>            // in the TNEF-decoded message content. <br>            // First, open the content. <br>            hr = m_lpEnvelope-&gt;OpenAttach( <br>                0,  // attachment # <br>                NULL,   // interface (whatever is appropriate) <br>                MAPI_DEFERRED_ERRORS,   // reduces RPCs <br>                &amp;m_lpAttach);         // attachment pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>             <br>                goto cleanup; <br>            } <br> <br>            ASSERT_IUNKNOWN_PTR(m_lpAttach, "Bad m_lpAttach"); <br> <br>            // Open the attachment as a message. <br>            hr = m_lpAttach-&gt;OpenProperty( <br>                PR_ATTACH_DATA_OBJ, // property tag <br>                &amp;IID_IMessage,  // interface identifier <br>                0,              // interface flags <br>                MAPI_DEFERRED_ERRORS,   // reduces RPCs <br>                (LPUNKNOWN *) &amp;m_lpContent); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            ASSERT_IUNKNOWN_PTR(m_lpContent, "Bad m_lpContent."); <br> <br>            // Retrive the content's delivery report request value. <br>            hr = HrMAPIGetPropBoolean( <br>                m_lpContent,        // message content poitner <br>                PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED,    // property tag <br>                &amp;fDRRequested);     // property value <br> <br>            // If the PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED property <br>            // doesn't exist in the content, just set leave it at to the default <br>            // value of false. <br>            if ( hr == MAPI_E_NOT_FOUND )   // does NOT return EDK_E_NOT_FOUND! <br>            { <br>                // Not an error.  Just set delivery report <br>                // requested value to FALSE. <br>                fDRRequested = FALSE; <br> <br>                hr = HR_LOG(NOERROR); <br>            } <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>        }   // end if doing TNEF decoding <br> <br>        // Set the delivery report requested value. <br>        rgEnvProps[iDRRequested].ulPropTag =  <br>            PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED; <br>        rgEnvProps[iDRRequested].Value.b = fDRRequested; <br> <br>        // set number of envelope properties <br>        nEnvProps = nIPMEnvProps; <br>    } <br> <br>    else    // have a notification <br>    { <br>        // Set the appropriate notification requested property. <br>        if ( m_MsgType == mtNRN )   // have a non-read notification <br>        { <br>            rgEnvProps[iNotifyReqVal].ulPropTag =  <br>                PR_NON_RECEIPT_NOTIFICATION_REQUESTED; <br>        } <br>     <br>        else    // have a read notification <br>        { <br>            rgEnvProps[iNotifyReqVal].ulPropTag = <br>                PR_READ_RECEIPT_REQUESTED; <br>        } <br> <br>        rgEnvProps[iNotifyReqVal].Value.b = TRUE; <br> <br>        // set number of envelope properties <br>        nEnvProps = nNotifyEnvProps; <br> <br>    }   // end if notification <br> <br>    // Set the trace information, if any. <br>    if ( m_lpTraceInfo != NULL ) <br>    { <br>        rgEnvProps[nEnvProps].ulPropTag = PR_TRACE_INFO; <br>        rgEnvProps[nEnvProps].Value.bin.cb = CbTRACEINFO(m_lpTraceInfo); <br>        rgEnvProps[nEnvProps].Value.bin.lpb = (BYTE *) m_lpTraceInfo; <br> <br>        // increment the property count <br>        nEnvProps++; <br> <br>    }   // end if trace information <br> <br>    // Set the internal trace information, if any. <br>    if ( m_lpIntTraceInfo != NULL ) <br>    { <br>        rgEnvProps[nEnvProps].ulPropTag = PR_INTERNAL_TRACE_INFO; <br>        rgEnvProps[nEnvProps].Value.bin.cb = CbINTTRACEINFO(m_lpIntTraceInfo); <br>        rgEnvProps[nEnvProps].Value.bin.lpb = (BYTE *) m_lpIntTraceInfo; <br> <br>        // increment the property count <br>        nEnvProps++; <br> <br>    }   // end if trace information <br> <br>    // Set the PR_TRANSPORT_MESSAGE_HEADER property <br>    hr = HrSetTransHdr(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br>                         <br>    hr = m_lpEnvelope-&gt;SetProps( <br>                nEnvProps,      // # of properties values <br>                rgEnvProps,     // property value array <br>                &amp;lpsProblems);  // problem array <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        lpsProblems = NULL; <br> <br>        goto cleanup; <br>    } <br> <br>    if ( lpsProblems != NULL ) <br>    { <br>        // problems with property values <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Set properties on envelope's recipient table. <br>    hr = m_lpEnvelope-&gt;ModifyRecipients( <br>                MODRECIP_ADD,       // flags <br>                m_lpRcptToList);    // address list         <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpEid); <br>    MAPIFREEBUFFER(lpszSubjectPrefix); <br>    MAPIFREEBUFFER(lpszNormSubject); <br>    MAPIFREEBUFFER(lpsProblems); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrSetContentProps------------------------------------------- <br>// <br>// DESCRIPTION: Sets IPM content properties <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrSetContentProps() <br>{ <br>    HRESULT             hr                      =   NOERROR; <br>    LPSPropProblemArray lpsProblems             =   NULL;   // problems array pointer <br>    ULONG               ulPriority              =   0;      // priority value <br>    ULONG               ulImportance            =   0;      // importance value <br>    FILETIME            ftClientSubmit          =   {0};    // file time structure <br>    ULONG               cbEid                   =   0;      // # bytes in entry identifier <br>    LPENTRYID           lpEid                   =   NULL;   // entry identifier <br> <br>    // Property value array indices <br>    const UINT          iClassVal               =   0; <br>    const UINT          iFromAddrVal            =   1; <br>    const UINT          iFromNameVal            =   2; <br>    const UINT          iFromEidVal             =   3; <br>    const UINT          iFromAddrTypeVal        =   4; <br>    const UINT          iSubmitTimeVal          =   5; <br>    const UINT          iImportanceVal          =   6; <br>    const UINT          iPriorityVal            =   7; <br>    const UINT          iSubjectVal             =   8; <br>const UINTiFromAddrVal2=9; <br>const UINTiFromNameVal2=10; <br>const UINTiFromEidVal2=11; <br>const UINTiFromAddrTypeVal2=12; <br> <br>    // # of property values <br>    const ULONG         nCntProps               =   13; <br> <br>    // property value arrray <br>    SPropValue          rgCntProps[nCntProps]   =   {0};     <br> <br>    DEBUGPRIVATE("CIPMConvert::HrSetContentProps()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR(m_MsgType == mtIPM, <br>                "Bad m_MsgType"); <br> <br>    // If TNEF decoding is desired, let TNEF extract the content <br>    // properties <br>    if ( m_fTNEFEncode == TRUE ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Set up the content properties. <br>    rgCntProps[iClassVal].ulPropTag = PR_MESSAGE_CLASS; <br>    rgCntProps[iClassVal].Value.LPSZ = m_rgszData[iClass]; <br>     <br>// PR_SENDER_* and PR_SENT_REPRESENTING_* properties <br>    rgCntProps[iFromAddrVal].ulPropTag = PR_SENDER_EMAIL_ADDRESS; <br>    rgCntProps[iFromAddrVal].Value.LPSZ = m_rgszData[iFrom]; <br> <br>    rgCntProps[iFromNameVal].ulPropTag = PR_SENDER_NAME; <br>    rgCntProps[iFromNameVal].Value.LPSZ = m_rgszData[iFrom]; <br> <br>    // Create an entry identifier for this "one off" address <br>    hr = m_lpAB-&gt;CreateOneOff( <br>                    m_rgszData[iFrom],          // name </code></pre>
<p>
</p>
<pre><code>(LPTSTR) m_lpszAddrType,    // address type <br>                    m_rgszData[iFrom],          // address <br>                    0,              // flags <br>                    &amp;cbEid,         // #bytes in entry ID <br>                    &amp;lpEid);        // entry identifier <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    rgCntProps[iFromEidVal].ulPropTag = PR_SENDER_ENTRYID; <br>    rgCntProps[iFromEidVal].Value.bin.cb = cbEid; <br>    rgCntProps[iFromEidVal].Value.bin.lpb = (BYTE *) lpEid; <br> <br>    rgCntProps[iFromAddrTypeVal].ulPropTag = PR_SENDER_ADDRTYPE; <br>    rgCntProps[iFromAddrTypeVal].Value.LPSZ = (LPTSTR) m_lpszAddrType; <br> <br>    rgCntProps[iFromAddrVal2].ulPropTag = PR_SENT_REPRESENTING_EMAIL_ADDRESS; <br>    rgCntProps[iFromAddrVal2].Value.LPSZ = m_rgszData[iFrom]; <br> <br>    rgCntProps[iFromNameVal2].ulPropTag = PR_SENT_REPRESENTING_NAME; <br>    rgCntProps[iFromNameVal2].Value.LPSZ = m_rgszData[iFrom]; <br> <br>    rgCntProps[iFromEidVal2].ulPropTag = PR_SENT_REPRESENTING_ENTRYID; <br>    rgCntProps[iFromEidVal2].Value.bin.cb = cbEid; <br>    rgCntProps[iFromEidVal2].Value.bin.lpb = (BYTE *) lpEid; <br> <br>    rgCntProps[iFromAddrTypeVal2].ulPropTag = PR_SENT_REPRESENTING_ADDRTYPE; <br>    rgCntProps[iFromAddrTypeVal2].Value.LPSZ = (LPTSTR) m_lpszAddrType; <br> <br>    // Determine the client submit file time <br>    hr = HrParseDateTimeString( <br>                m_rgszData[iDate],        // date time string <br>                &amp;ftClientSubmit);       // file time structure pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    rgCntProps[iSubmitTimeVal].ulPropTag = PR_CLIENT_SUBMIT_TIME; <br>    rgCntProps[iSubmitTimeVal].Value.ft = ftClientSubmit; <br> <br>    // Determine importance <br>    hr = HrParseImportanceString( <br>                m_rgszData[iImportance],      // importance string <br>                &amp;ulImportance);             // importance value <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    rgCntProps[iImportanceVal].ulPropTag = PR_IMPORTANCE; <br>    rgCntProps[iImportanceVal].Value.l = ulImportance; <br> <br>    // Determine priority <br>    hr = HrParsePriorityString( <br>                m_rgszData[iPriority],        // priority string <br>                &amp;ulPriority);               // priority value <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    rgCntProps[iPriorityVal].ulPropTag = PR_PRIORITY; <br>    rgCntProps[iPriorityVal].Value.l = ulPriority; <br> <br>    rgCntProps[iSubjectVal].ulPropTag = PR_SUBJECT; <br>    rgCntProps[iSubjectVal].Value.LPSZ = m_rgszData[iSubject]; <br> <br>    // more consistency checks <br>    ASSERTERROR(!FBadUnknown(m_lpContent), "Bad m_lpContent"); <br> <br>    // Set properties on the content. <br>    hr = m_lpContent-&gt;SetProps( <br>                nCntProps,      // # properties <br>                rgCntProps,     // property value array <br>                &amp;lpsProblems);  // problems array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        lpsProblems = NULL; <br> <br>        goto cleanup; <br>    } <br> <br>    if ( lpsProblems != NULL ) <br>    { <br>        // problems with property values <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Modify the content's recipient table. <br>    hr = m_lpContent-&gt;ModifyRecipients( <br>                MODRECIP_ADD,       // flags <br>                m_lpContentRecips); // address list         <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // save the changes to the message content <br>    hr = m_lpContent-&gt;SaveChanges( <br>                MAPI_DEFERRED_ERRORS);      // saves RPCs <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // save changes to the envelope attachment <br>    hr = m_lpAttach-&gt;SaveChanges( <br>                0);                     // we are done with the envelope attachment <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpEid); <br>    MAPIFREEBUFFER(lpsProblems); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrSetTransHdr------------------------------------------------ <br>// <br>// DESCRIPTION: Set the PR_TRANSPORT_MESSAGE_HEADER property <br>//              on the envelope. <br>// <br>// ASSUMPTIONS: The entire input stream has been read when this <br>//              function is called.  (i.e.  This function will only <br>//              set the PR_TRANSPORT_MESSAGE_HEADERS property equal <br>//              to the contents of the beginning of the stream to its <br>//              current position.) <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrSetTransHdr() <br>{ <br>    HRESULT         hr              =   NOERROR; <br>    PVIRTUALSTREAMONPROPERTYlpTransHdrStrm  =   NULL;   // buffered stream pointer <br>    LARGE_INTEGER   sOffsetBegin    =   {0};    // begin position <br> <br>    // MAPI property creation flags <br>    const ULONG ulFlags         =   MAPI_CREATE | MAPI_MODIFY | <br>                                    MAPI_DEFERRED_ERRORS; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrSetTransHdr()\n"); <br> <br>    // consistency checking <br>    ASSERT_IUNKNOWN_PTR(m_lpEnvelope, "Bad m_lpEnvelope"); <br>ASSERTERROR( m_sOffsetHeaders.LowPart != 0, "No headers detected"); <br> <br>    // The PR_TRANSPORT_MESSAGE_HEADERS envelope property is <br>    // merely a copy of the input "header" read by the inbound <br>    // conversion DLL. <br>    // Create this property now via a virtual (e.g. buffered) stream <br>hr = HrOpenVirtualStreamOnProperty( <br>m_lpEnvelope,// MAPI object pointer <br>PR_TRANSPORT_MESSAGE_HEADERS,// property tag <br>ulFlags,// MAPI property flags <br>&amp;lpTransHdrStrm);// virtual (buffered) stream pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(lpTransHdrStrm, "Bad lpTransHdrStrm"); <br> <br>    // Seek to begining of input stream <br>    hr = m_lpStream-&gt;Seek( <br>        sOffsetBegin,   // offset <br>        STREAM_SEEK_SET,// from beginning <br>        NULL); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Copy input stream to transport header stream <br>    hr = m_lpStream-&gt;CopyTo( <br>                (LPSTREAM) lpTransHdrStrm,     // destination stream <br>                m_sOffsetHeaders,   // should be size of headers <br>                NULL,               // don't care <br>                NULL);              // don't care <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // save changes to the PR_TRANSPORT_MESSAGE_HEADER data stream. <br>    hr = lpTransHdrStrm-&gt;Commit( <br>            0);     // not going to do anything else but free it <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    // release the PR_TRANSPORT_MESSAGE_HEADER data strem <br>    ULRELEASE(lpTransHdrStrm); <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
