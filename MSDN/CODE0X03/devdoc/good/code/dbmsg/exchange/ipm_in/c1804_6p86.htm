<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVREPT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1806"></a>CONVREPT.CPP</h2>
<pre><code>// --convrept.cpp------------------------------------------------ <br>// <br>// CIPMConvert source code for IPM reports. <br>// <br>// Copyright (C) Microsoft Corp., 1986-1996.  All rights reserved. <br>// <br>// -------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "tagnames.h" <br>#include "msgemit.h" <br>#include "convcls.h" <br>#include "convrept.chk" <br> <br>//$--CIPMConvert::HrParseReportSpecific------------------------------------------ <br>// <br>// DESCRIPTION: Parses [non]delivery report-specific tag and data lines <br>//              and constructs RCPT TO recipient list from them <br>// <br>// INPUT:   none <br>// <br>// OUTPUT:  pnRecipients    --  number of [non]recipients <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_OUTOFMEMORY if memory problems <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrParseReportSpecific( <br>            OUT ULONG * pnRecipients)   // # of [non]recipients <br>{ <br>    HRESULT hr  =   NOERROR; <br>    LPTSTR          lpTag           =   NULL;       // tag string <br>    LPTSTR          lpData          =   NULL;       // data string <br>    ULONG           cbRead          =   0;          // # bytes read <br>    LPSPropValue    lpsRecipProps   =   NULL;       // property value array pointer <br>    ULONG           nRecipProps     =   0;          // number of property values in array <br>    ULONG           cbEid           =   0;          // number of bytes in entry identifier <br>    LPENTRYID       lpEid           =   NULL;       // entry identifier <br>    ULONG           cbName          =   0;          // # bytes in email address <br>    DWORD           cbSize          =   0;          // sizeof of property value array <br>    LARGE_INTEGER   sRetreat        =   {0};        // # of bytes to back up <br>LONGLONGcbRetreat=0;// # of bytes to back up <br> <br>    // report RCPT TO recipient list property indices <br>    // These properties are common to both delivery reports <br>    // and non-delivery reports. <br>    const UINT      iEmailAddr      =   0;          // email address <br>    const UINT      iRecipType      =   1;          // recipient type <br>    const UINT      iName           =   2;          // display name <br>    const UINT      iEID            =   3;          // recipient entry identifier <br>    const UINT      iAddrType       =   4;          // address type <br>    const UINT      iRecipNumber    =   5;          // recipient number <br>    const UINT      iReportTime     =   6;          // time report was generated <br> <br>    // NDR-specific non-recipient properties <br>    const UINT      iReportText     =   7;          // report text <br>    const UINT      iDiagCode       =   8;          // NDR diagnostic code <br>    const UINT      iReasonCode     =   9;          // NDR reason code <br> <br>    // # of NDR non-recipient properties <br>    const ULONG     nNDRRecipProps  =   10; <br> <br>    // DR-specific recipient properties <br>    const UINT      iDeliverTime    =   7;          // DR delivery time <br>         <br>    // # of DR recipient properties <br>    const ULONG     nDRRecipProps   =   8; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrParseReportSpecific()\n"); <br>     <br>    // consistency checking <br>    ASSERTERROR(!FBadUnknown(m_lpStream), "Bad m_lpStream"); <br>    ASSERTERROR((m_MsgType == mtNDR || m_MsgType == mtDR),  <br>                "Bad m_MsgType"); <br>    ASSERTERROR(!FBadUnknown(m_lpAB), "Bad m_lpAB"); <br>    ASSERTERROR(!IsBadStringPtr(m_lpszAddrType, INFINITE), <br>                "Bad lpszAddrType"); <br> <br>    // Check the input parameters. <br>    hr = CHK_CIPMConvert_HrParseReportSpecific(pnRecipients); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // initialize the output parameter <br>    *pnRecipients = 0; <br> <br>    // Initialize number of recipient properties <br>    if ( m_MsgType == mtNDR )   // non-delivery report <br>    { <br>        nRecipProps = nNDRRecipProps; <br>    } <br> <br>    else    // delivery report <br>    { <br>        nRecipProps = nDRRecipProps; <br>    } <br> <br>    // Handle recipient data per [non]recipient. <br>    while ( TRUE ) <br>    { <br>        // Free MAPI buffers <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br>        MAPIFREEBUFFER(lpEid); <br> <br>        MAPIFREEBUFFER(lpsRecipProps); <br> <br>        // Parse the "Your message was not delivered to" tag and data <br>        // or the "Your message was successfully delivered to" tag and data <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer                     <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag pointer <br>                    &amp;lpData);       // data pointer <br> <br>        // Check for end of file condition <br>        if ( hr == EDK_E_END_OF_FILE ) <br>        { <br>            // Have reached the end of the file,  This <br>            // is not an error. <br>            hr = NOERROR; <br> <br>            break; <br>        } <br> <br>        if ( FAILED(hr) ) <br>        { <br>            // general failure <br>            goto cleanup; <br>        } <br> <br>        // Check the tag read against the tag expected <br>        if ( ( (m_MsgType == mtNDR) &amp;&amp;  <br>               (lstrcmp(lpTag, lpszTagNotSentTo) != 0) ) || <br>             ( (m_MsgType == mtDR) &amp;&amp;  <br>                  (lstrcmp(lpTag, lpszTagSentTo) != 0) ) ) <br>        { <br>            // doing TNEF decoding, we have read ahead too far. <br>            // Back up to where we were before. <br>            if ( m_fTNEFEncode == TRUE ) <br>            { <br>                cbRetreat = ((LONGLONG) (-1)) * cbRead; <br> <br>sRetreat.LowPart = LOWLONG(cbRetreat); <br>sRetreat.HighPart = HILONG(cbRetreat); <br> <br>                hr = m_lpStream-&gt;Seek( <br>                            sRetreat,   // negative offset <br>                            STREAM_SEEK_CUR,    // from current position <br>                            NULL);      // don't care <br> <br>                if ( FAILED(hr) ) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br> <br>                    goto cleanup; <br>                } <br> <br>                // This is not an error. <br>                hr = HR_LOG(NOERROR); <br> <br>                break;  // we are done <br> <br>            }   // end if doing TNEF decoding <br> <br>            else    // not doing TNEF decoding <br>            { <br>                // general error <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>        }   // end if tag is not what we expect <br> <br>        // Allocate memory for this recipient's properties. <br>        // (Must do dynamic allocation, as IMessage::ModifyRecipients <br>        // may reallocate property array buffer.). <br>        cbSize = sizeof(SPropValue) * nRecipProps;      // sizeof property value array <br>        hr = MAPIAllocateBuffer( <br>                    cbSize,   // # bytes to allocate <br>                    (VOID **) &amp;lpsRecipProps);                    // pointer to array pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        // Initialize property value array <br>        ZeroMemory( <br>                    lpsRecipProps,      // buffer <br>                    cbSize);            // size of buffer <br>         <br>        // save data for this non-recipient in the RCPT TO recipient property array. <br> <br>        // Allocate additional memory for the e-mail address. <br>        cbName = cbStrLen(lpData); <br>        hr = MAPIAllocateMore( <br>                    cbName,                                 // # additional bytes <br>                    lpsRecipProps,                          // original buffer <br>                    (VOID **) &amp;(lpsRecipProps[iEmailAddr].Value.LPSZ));        // email address buffer <br> <br>        if ( FAILED(hr) ) <br>        {    <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br>         <br>        // Set up properties for this recipient. <br> <br>        // Set up the e-mail address <br>        lpsRecipProps[iEmailAddr].ulPropTag = PR_EMAIL_ADDRESS;   // e-mail address <br>        lstrcpy( <br>                lpsRecipProps[iEmailAddr].Value.LPSZ, <br>                lpData); <br> <br>        // Set up the recipient type <br>        lpsRecipProps[iRecipType].ulPropTag = PR_RECIPIENT_TYPE;  // recipient type <br>        lpsRecipProps[iRecipType].Value.l = MAPI_TO; <br> <br>        // Allocate more memory for display name <br>        hr = MAPIAllocateMore( <br>                    cbName,                             <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iName].Value.LPSZ));     // display name buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        lpsRecipProps[iName].ulPropTag = PR_DISPLAY_NAME;   // display name <br>        lstrcpy( <br>                lpsRecipProps[iName].Value.LPSZ, <br>                lpData); <br> <br>        // Create an entry identifier for this "one off" address <br>        hr = m_lpAB-&gt;CreateOneOff( <br>                    lpData,         // PR_DISPLAY_NAME <br>                    (LPTSTR) m_lpszAddrType,   // PR_ADDRTYPE <br>                    lpData,         // PR_EMAIL_ADDRESS <br>                    0,              // flags <br>                    &amp;cbEid,         // #bytes in entry ID <br>                    &amp;lpEid);        // entry identifier <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Allocate more memory for entry identifier <br>        hr = MAPIAllocateMore( <br>                    cbEid,              // # bytes to add <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iEID].Value.bin.lpb));         // entry identifier buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        lpsRecipProps[iEID].ulPropTag = PR_ENTRYID;        // entry identifier <br>        lpsRecipProps[iEID].Value.bin.cb = cbEid; <br>        CopyMemory( <br>               lpsRecipProps[iEID].Value.bin.lpb,   // destination buffer <br>               lpEid,                               // source buffer <br>               cbEid);                              // count bytes <br> <br>        // Allocate more memory for address type <br>        hr = MAPIAllocateMore( <br>                    cbStrLen(m_lpszAddrType),   // # bytes to add <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iAddrType].Value.LPSZ));    // address type buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        lpsRecipProps[iAddrType].ulPropTag = PR_ADDRTYPE; <br>        lstrcpy( <br>                lpsRecipProps[iAddrType].Value.LPSZ, <br>                m_lpszAddrType); <br> <br>        lpsRecipProps[iRecipNumber].ulPropTag = PR_RECIPIENT_NUMBER; <br>        lpsRecipProps[iRecipNumber].Value.l = -1; <br> <br>        // Allocate additional memory for the report time. <br>        hr = MAPIAllocateMore( <br>                    sizeof(FILETIME),  // # bytes to add <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iReportTime].Value.ft));    // address type buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>            goto cleanup; <br>        } <br> <br>        // Report time <br>        lpsRecipProps[iReportTime].ulPropTag = PR_REPORT_TIME; <br> <br>        // Determine and fill in the report time <br>        hr = HrParseDateTimeString( <br>                m_rgszData[iDate],        // date time string <br>                &amp;(lpsRecipProps[iReportTime].Value.ft));   // file time pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            // Use a default value. <br>            GetSystemTimeAsFileTime( &amp;(lpsRecipProps[iReportTime].Value.ft)); <br>        } <br> <br>        // Free tag and data string <br>        MAPIFREEBUFFER(lpTag); <br>        MAPIFREEBUFFER(lpData); <br> <br>        // Handle NDR-specific properties <br>        if ( m_MsgType == mtNDR ) <br>        { <br>            // Parse "for the following reason" tag and data line. <br>            hr = HrParseTagAndData( <br>                        m_lpStream,     // stream pointer                         <br>                        &amp;cbRead,        // # bytes read <br>                        &amp;lpTag,         // tag pointer <br>                        &amp;lpData);       // data pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Check the tag read against the one expected <br>            if ( lstrcmp(lpTag, lpszTagReason) != 0 ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            // Allocate more memory for the report text <br>            hr = MAPIAllocateMore( <br>                    cbStrLen(lpData),   // # bytes to add <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iReportText].Value.LPSZ));    // address type buffer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_OUTOFMEMORY); <br> <br>                goto cleanup; <br>            } <br> <br>            lpsRecipProps[iReportText].ulPropTag = PR_REPORT_TEXT; <br>            lstrcpy( <br>                lpsRecipProps[iReportText].Value.LPSZ,  // buffer <br>                lpData);                                // value <br> <br>            // Free tag and data strings <br>            MAPIFREEBUFFER(lpTag); <br>            MAPIFREEBUFFER(lpData); <br> <br>            // Parse the "Diagnostic code" tag and data line <br>            hr = HrParseTagAndData( <br>                        m_lpStream,     // stream pointer                         <br>                        &amp;cbRead,        // # bytes read <br>                        &amp;lpTag,         // tag pointer <br>                        &amp;lpData);       // data pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Check the tag read against the one expected <br>            if ( lstrcmp(lpTag, lpszTagDiagCode) != 0 ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            // save data in the RCPT TO recipient property array. <br>            lpsRecipProps[iDiagCode].ulPropTag = PR_NDR_DIAG_CODE; <br>            lpsRecipProps[iDiagCode].Value.l = atol(lpData); <br> <br>            // Free tag and data strings <br>            MAPIFREEBUFFER(lpTag); <br>            MAPIFREEBUFFER(lpData); <br> <br>            // Parse the "NDR code" tag and data line. <br>            hr = HrParseTagAndData( <br>                        m_lpStream,     // stream pointer                         <br>                        &amp;cbRead,        // # bytes read <br>                        &amp;lpTag,         // tag pointer <br>                        &amp;lpData);       // data pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Check tag read against one expected <br>            if ( lstrcmp(lpTag, lpszTagNDRCode) != 0 ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            // save data in the RCPT TO recipient property array. <br>            lpsRecipProps[iReasonCode].ulPropTag = PR_NDR_REASON_CODE; <br>            lpsRecipProps[iReasonCode].Value.l = atol(lpData); <br> <br>            // Free tag and data string <br>            MAPIFREEBUFFER(lpTag); <br>            MAPIFREEBUFFER(lpData); <br> <br>        }   // end if have an NDR <br> <br>        // Handle DR specific properties <br>        else     <br>        { <br>            // Read in the "at" tag and data <br>            hr = HrParseTagAndData( <br>                        m_lpStream,     // stream pointer                         <br>                        &amp;cbRead,        // # bytes read <br>                        &amp;lpTag,         // tag pointer <br>                        &amp;lpData);       // data pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Check the tag read against the one expected <br>            if ( lstrcmp(lpTag, lpszTagAtTime) != 0 ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            // Allocate additional memory for the delivery time. <br>            hr = MAPIAllocateMore( <br>                    sizeof(FILETIME),  // # bytes to add <br>                    lpsRecipProps, <br>                    (VOID **) &amp;(lpsRecipProps[iDeliverTime].Value.ft)); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_OUTOFMEMORY); <br> <br>                goto cleanup; <br>            } <br> <br>            // Determine and set the delivery time. <br>            lpsRecipProps[iDeliverTime].ulPropTag = PR_DELIVER_TIME; <br> <br>            hr = HrParseDateTimeString( <br>                lpData,        // date time string <br>                &amp;(lpsRecipProps[iDeliverTime].Value.ft));   // file time pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                // Use a default value. <br>                GetSystemTimeAsFileTime( &amp;(lpsRecipProps[iDeliverTime].Value.ft)); <br>            } <br> <br>            // Free tag and data string <br>            MAPIFREEBUFFER(lpTag); <br>            MAPIFREEBUFFER(lpData); <br> <br>        }   // end if have a DR <br> <br>        // Add the property array to the RCPT TO recipient list. <br>        if ( m_lpReportToList == NULL ) <br>        { <br>            // Create the recipient list <br>            hr = HrMAPICreateAddressList( <br>                nRecipProps,        // # of properties for address <br>                lpsRecipProps,      // recipient properties <br>                &amp;m_lpReportToList);  // target address list pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if recipient list doesn't exist <br> <br>        else <br>        { <br>            // Append to the recipient list <br>            hr = HrMAPIAppendAddressList( <br>                nRecipProps,        // # of properties for address <br>                lpsRecipProps,      // recipient properties <br>                &amp;m_lpReportToList);  // target address list pointer <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if recipient list does exist <br> <br>        // increment [non]recipient count <br>        (*pnRecipients)++; <br> <br>        // Process next [non]recipient <br> <br>    }   // end while <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpTag); <br>    MAPIFREEBUFFER(lpData); <br>    MAPIFREEBUFFER(lpEid); <br> <br>    // HrMAPICreateAddressList makes a duplicate of the <br>    // property value array passed into it.  Thus, free <br>    // property value array here. <br>    MAPIFREEBUFFER(lpsRecipProps); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--$CIPMConvert::HrSetReportProps------------------------------------------- <br>// <br>// DESCRIPTION: Sets delivery and non-delivery report properties. <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrSetReportProps() <br>{ <br>    HRESULT             hr                  =   NOERROR; <br>    ULONG               ulImportance        =   0;      // importance value <br>    ULONG               ulPriority          =   0;      // priority value <br>    LPSPropProblemArray lpsProblems         =   NULL;   // problem array pointer <br>    ULONG               nReportProps        =   0;      // # of report properties <br>    ULONG               cbDestEid           =   0;      // # dest entry ID bytes <br>    LPENTRYID           lpDestEid           =   NULL;   // destination entry ID <br>    LPTSTR              lpszSubjectPrefix   =   NULL;   // subject prefix <br>    LPTSTR              lpszNormSubject     =   NULL;   // normalized subject <br>    SYSTEMTIME          st                  =   {0};    // current system time <br>    FILETIME            ftArrival           =   {0};    // arrival time <br>    FILETIME            ftSubmit            =   {0};    // submission time <br>    LPTSTR              lpDestAddr          =   NULL;   // destination address <br> <br>    // property value array indices <br>    const UINT  iClassVal       =   0; <br>    const UINT  iImportanceVal  =   1; <br>    const UINT  iPriorityVal    =   2; <br>    const UINT  iSubjectVal     =   3; <br>    const UINT  iDestNameVal    =   4; <br>    const UINT  iDestEidVal     =   5; <br>    const UINT  iSubjectXIDVal  =   6; <br>    const UINT  iSubPrefixVal   =   7; <br>    const UINT  iNormSubjectVal =   8; <br>    const UINT  iDeleteVal      =   9; <br>    const UINT  iArrivalTimeVal =   10; <br>    const UINT  iOrigSubmitVal  =   11; <br>    const UINT  iReportReqVal   =   12; <br>const UINTiContentRetVal=13; <br> <br>    // minimum number of report properties <br>    const ULONG nMinRptProps    =   14; <br> <br>    // maximum # of report properties. <br>    // Note: There may not be any trace information or any X message <br>    // identifier information.  Thus, the maximum number of  <br>    // properties is three more than the minimum number of properties. <br>    const ULONG nMaxRptProps    =   nMinRptProps + 3; <br> <br>    // Property value array <br>    SPropValue  rgReportProps[nMaxRptProps] =   {0}; <br> <br>    // index of email address in the envelope recipient address <br>    // list property value array. <br>    const UINT      iEmailAddr  =   0;          // email address <br> <br>    DEBUGPRIVATE("CIPMConvert::HrSetReportProps()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR(!FBadUnknown(m_lpEnvelope), "Bad m_lpEnvelope"); <br>    ASSERTERROR((m_MsgType == mtNDR || m_MsgType == mtDR),  <br>                "Bad m_MsgType"); <br>    ASSERTERROR((!IsBadReadPtr(m_lpRcptToList, sizeof(ADRLIST))),  <br>                "Bad m_lpRcptToList"); <br> <br>    // Initialize number of report properties to be the minimum <br>    // number of report properties. <br>    nReportProps = nMinRptProps; <br> <br>    // Fill in the properties to be set. <br>    rgReportProps[iClassVal].ulPropTag = PR_MESSAGE_CLASS; <br>    rgReportProps[iClassVal].Value.LPSZ = m_rgszData[iClass]; <br> <br>    // Retrieve importance value. <br>    hr = HrParseImportanceString( <br>                m_rgszData[iImportance],    // importance string <br>                &amp;ulImportance);             // importance value <br>     <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br>         <br>    rgReportProps[iImportanceVal].ulPropTag = PR_IMPORTANCE; <br>    rgReportProps[iImportanceVal].Value.l = ulImportance; <br> <br>    // Retrieve priority value <br>    hr = HrParsePriorityString( <br>                m_rgszData[iPriority],      // priority string <br>                &amp;ulPriority);               // priority value <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    rgReportProps[iPriorityVal].ulPropTag = PR_PRIORITY; <br>    rgReportProps[iPriorityVal].Value.l = ulPriority; <br> <br>    rgReportProps[iSubjectVal].ulPropTag = PR_SUBJECT; <br>    rgReportProps[iSubjectVal].Value.LPSZ = m_rgszData[iSubject]; <br> <br>    // Retrieve the report destination name. <br>    // The report destination name is actually in the  <br>    // "RCPT TO" line, which was stored in the m_lpRcptToList. <br>    lpDestAddr = m_lpRcptToList-&gt;aEntries[0].rgPropVals[iEmailAddr].Value.LPSZ; <br>    rgReportProps[iDestNameVal].ulPropTag = PR_REPORT_DESTINATION_NAME; <br>    rgReportProps[iDestNameVal].Value.LPSZ = lpDestAddr; <br> <br>    // Create an entry identifier for this "one off" address <br>    hr = m_lpAB-&gt;CreateOneOff( <br>                    lpDestAddr,     // name <br>                    (LPTSTR) m_lpszAddrType,    // address type <br>                    lpDestAddr,     // address <br>                    0,              // flags <br>                    &amp;cbDestEid,     // #bytes in entry ID <br>                    &amp;lpDestEid);    // entry identifier <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    rgReportProps[iDestEidVal].ulPropTag = PR_REPORT_DESTINATION_ENTRYID; <br>    rgReportProps[iDestEidVal].Value.bin.cb = cbDestEid; <br>    rgReportProps[iDestEidVal].Value.bin.lpb = (BYTE *) lpDestEid; <br> <br>    rgReportProps[iSubjectXIDVal].ulPropTag = PR_MTS_SUBJECT_ID; <br>    rgReportProps[iSubjectXIDVal].Value.bin.cb =  <br>        cbStrLen(m_rgszData[iSubjectXID]); <br>    rgReportProps[iSubjectXIDVal].Value.bin.lpb =  <br>        (BYTE *) m_rgszData[iSubjectXID]; <br> <br>    // Contruct subject prefix &amp; normalized subject <br>    // (Prefix is everything up to and including first colon. <br>    // Normalized subject is everything else, except first space). <br>    hr = HrEDKParseSubjectPrefix( <br>                m_rgszData[iSubject],   // subject text <br>                &amp;lpszSubjectPrefix,     // prefix <br>                &amp;lpszNormSubject);      // normalized subject <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    rgReportProps[iSubPrefixVal].ulPropTag = PR_SUBJECT_PREFIX; <br>    rgReportProps[iSubPrefixVal].Value.LPSZ = lpszSubjectPrefix; <br> <br>    rgReportProps[iNormSubjectVal].ulPropTag = PR_NORMALIZED_SUBJECT; <br>    rgReportProps[iNormSubjectVal].Value.LPSZ = lpszNormSubject; <br> <br>    rgReportProps[iDeleteVal].ulPropTag = PR_DELETE_AFTER_SUBMIT; <br>    rgReportProps[iDeleteVal].Value.b = TRUE; <br> <br>    // Determine the arrival time.  This is the current time! <br>    GetSystemTimeAsFileTime( &amp;ftArrival); <br> <br>    rgReportProps[iArrivalTimeVal].ulPropTag = PR_ARRIVAL_TIME; <br>    rgReportProps[iArrivalTimeVal].Value.ft = ftArrival; <br> <br>    // Determine the original submission time. <br>    hr = HrParseDateTimeString( <br>                m_rgszData[iDate],      // date time string <br>                &amp;ftSubmit);             // file time structure <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // Use a default value. <br>        GetSystemTimeAsFileTime( &amp;ftSubmit); <br>    } <br> <br>    rgReportProps[iOrigSubmitVal].ulPropTag = PR_CLIENT_SUBMIT_TIME; <br>    rgReportProps[iOrigSubmitVal].Value.ft = ftSubmit; <br> <br>    // Set the appropriate report requested property <br>    if ( m_MsgType == mtNDR )   // non-delivery report <br>    { <br>        rgReportProps[iReportReqVal].ulPropTag = <br>            PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED; <br>    } <br> <br>    else    // delivery report <br>    { <br>        rgReportProps[iReportReqVal].ulPropTag = <br>            PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED; <br>    } <br> <br>    rgReportProps[iReportReqVal].Value.b = TRUE; <br> <br>// Set the content return requested flag.  In general, we should <br>// try to propagate the original message content with all delivery <br>// and non-delivery reports. <br>rgReportProps[iContentRetVal].ulPropTag = PR_CONTENT_RETURN_REQUESTED; <br>// Evaluates to TRUE if TNEFed content data is available and FALSE otherwise. <br>rgReportProps[iContentRetVal].Value.b = m_fTNEFEncode; <br> <br>    // Only fill in PR_MESSAGE_SUBMISSION_ID if it is not null. <br>    if ( *(m_rgszData[iXID]) != 0 ) <br>    { <br>        // Fill in X-Message-ID <br>        rgReportProps[nReportProps].ulPropTag = PR_MESSAGE_SUBMISSION_ID; <br>        rgReportProps[nReportProps].Value.bin.cb =  <br>            cbStrLen(m_rgszData[iXID]); <br>        rgReportProps[nReportProps].Value.bin.lpb = (BYTE *) m_rgszData[iXID]; <br> <br>        // increment number of properties <br>        nReportProps++; <br>    } <br> <br>    // Set the trace information, if any. <br>    if ( m_lpTraceInfo != NULL ) <br>    { <br>        rgReportProps[nReportProps].ulPropTag = PR_TRACE_INFO; <br>        rgReportProps[nReportProps].Value.bin.cb = CbTRACEINFO(m_lpTraceInfo); <br>        rgReportProps[nReportProps].Value.bin.lpb = (BYTE *) m_lpTraceInfo; <br> <br>        // increment the property count <br>        nReportProps++; <br> <br>    }   // end if trace information <br> <br>    // Set the internal trace information, if any. <br>    if ( m_lpIntTraceInfo != NULL ) <br>    { <br>        rgReportProps[nReportProps].ulPropTag = PR_INTERNAL_TRACE_INFO; <br>        rgReportProps[nReportProps].Value.bin.cb = CbINTTRACEINFO(m_lpIntTraceInfo); <br>        rgReportProps[nReportProps].Value.bin.lpb = (BYTE *) m_lpIntTraceInfo; <br> <br>        // increment the property count <br>        nReportProps++; <br> <br>    }   // end if internal trace information <br> <br>    // Set the PR_TRANSPORT_MESSAGE_HEADER property. <br>    hr = HrSetTransHdr(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Set the report properties. <br>    hr = m_lpEnvelope-&gt;SetProps( <br>                nReportProps,       // # of properties <br>                rgReportProps,      // property value array <br>                &amp;lpsProblems);      // property problem array poniter <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        lpsProblems = NULL;     // so can safely release <br> <br>        goto cleanup; <br>    } <br> <br>    if ( lpsProblems != NULL ) <br>    { <br>        // some properties weren't accepted <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Set properties on report's recipient table. <br>    hr = m_lpEnvelope-&gt;ModifyRecipients( <br>                0,                    // flags <br>                m_lpReportToList);    // address list         <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpDestEid); <br>    MAPIFREEBUFFER(lpszSubjectPrefix); <br>    MAPIFREEBUFFER(lpszNormSubject); <br>    MAPIFREEBUFFER(lpsProblems); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrParseNotificationSpecific------------------------------------------ <br>// <br>// DESCRIPTION: Parses read/non read notification-specific tag and data lines. </code></pre>
<p>
</p>
<pre><code>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrParseNotificationSpecific() <br>{ <br>    HRESULT hr  =   NOERROR; <br>    LPTSTR          lpTag           =   NULL;       // tag string <br>    ULONG           cbRead          =   0;          // # bytes read <br> <br>    DEBUGPRIVATE("CIPMConvert::HrParseNotificaionSpecific()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR(!FBadUnknown(m_lpStream), "Bad m_lpStream"); <br>    ASSERTERROR((m_MsgType == mtNRN || m_MsgType == mtRN), <br>                "Bad m_MsgType"); <br> <br>    // Parse the "Your message was [not] read by" tag and data. <br>    hr = HrParseTagAndData( <br>                m_lpStream,     // stream pointer                 <br>                &amp;cbRead,        // # bytes read <br>                &amp;lpTag,         // tag pointer <br>                &amp;(m_rgszData[iReadBy]));       // data pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check the tag read against the one expected. <br>    if ( (m_MsgType == mtNRN) &amp;&amp; <br>         (lstrcmp(lpTag, lpszTagNotReadBy) != 0) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    else if ( (m_MsgType == mtRN) &amp;&amp; <br>              (lstrcmp(lpTag, lpszTagReadBy) != 0) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Free tag string <br>    MAPIFREEBUFFER(lpTag); <br> <br>    // Parse the "at" tag and data line. <br>    hr = HrParseTagAndData( <br>            m_lpStream,     // stream pointer <br>            &amp;cbRead,        // #bytes read <br>            &amp;lpTag,         // tag string <br>            &amp;(m_rgszData[iNotifyTime]));    // data buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Check tag read against tag expected. <br>    if ( lstrcmp(lpTag, lpszTagAtTime) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Free tag string <br>    MAPIFREEBUFFER(lpTag); <br> <br>    // Handle non-read receipt-specific information. <br>    if ( m_MsgType == mtNRN ) <br>    { <br>        // Parse "Discard Code" tag and data <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag string <br>                    &amp;(m_rgszData[iDiscardCode]));   // data buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check tag read against one expected. <br>        if ( lstrcmp(lpTag, lpszTagDiscCode) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // free tag string <br>        MAPIFREEBUFFER(lpTag); <br> <br>        // Parse "Non-receipt code" tag and data <br>        hr = HrParseTagAndData( <br>                    m_lpStream,     // stream pointer <br>                    &amp;cbRead,        // # bytes read <br>                    &amp;lpTag,         // tag string <br>                    &amp;(m_rgszData[iNonRcptCode]));   // data buffer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // check tag read against tag expected <br>        if ( lstrcmp(lpTag, lpszTagNRNCode) != 0 ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Free tag string <br>        MAPIFREEBUFFER(lpTag); <br> <br>    }   // end if NRN <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpTag); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrSetNotifyCntProps----------------------------------------- <br>// <br>// DESCRIPTION: Set content properties for read and non-read notifications <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrSetNotifyCntProps() <br>{ <br>    HRESULT             hr                  =   NOERROR; <br>    LPSPropProblemArray lpsProblems         =   NULL;   // property problems <br>    FILETIME            ftSubmit            =   {0};    // submission time struct <br>    FILETIME            ftReport            =   {0};    // report time struct <br>    ULONG               ulImportance        =   0;      // importance value <br>    ULONG               ulPriority          =   0;      // priority value <br>    ULONG               nNotifyProps        =   0;      // # of properties <br>    ULONG               cbEid               =   0;      // # bytes in entry ID <br>    LPENTRYID           lpEid               =   NULL;   // entry identifier <br>    LPTSTR              lpszNormSubject     =   NULL;   // normalized subject <br>    LPTSTR              lpszSubjectPrefix   =   NULL;   // subject prefix <br>    LPTSTR              lpszFromAddr        =   NULL;   // from address <br>    ULONG               cbParentKey         =   0;      // # bytes in binary parent key <br> <br>    // byte array for the binary parent key (PR_PARENT_KEY) property <br>    BYTE                rgbParentKey[ulMaxOutStringLen + 1] =   {0}; <br> <br>    // indices into the notification content's property value array <br>    const UINT  iClassVal       =   0; <br>    const UINT  iFromAddrVal    =   1; <br>    const UINT  iFromNameVal    =   2; <br>    const UINT  iFromEidVal     =   3; <br>    const UINT  iFromAddrTypeVal=   4; <br>    const UINT  iSubmitTimeVal  =   5; <br>    const UINT  iImportanceVal  =   6; <br>    const UINT  iPriorityVal    =   7; <br>    const UINT  iSubjectVal     =   8; <br>    const UINT  iReportTimeVal  =   9; <br>    const UINT  iSubPrefixVal   =   10; <br>    const UINT  iNormSubjectVal =   11; <br>    const UINT  iOrigSubjectVal =   12; <br>    const UINT  iOrigSubmitVal  =   13; <br>    const UINT  iOrigDestNamVal =   14; <br>    const UINT  iOrigDestEidVal =   15; <br>    const UINT  iOrigDestAddrVal=   16; <br>    const UINT  iOrigDestATypVal=   17; <br>    const UINT  iSubjectXIDVal  =   18; <br>    const UINT  iFromAddrVal2   =   19; <br>    const UINT  iFromNameVal2   =   20; <br>    const UINT  iFromEidVal2    =   21; <br>    const UINT  iFromAddrTypeVal2=  22; <br> <br>    // Properties unique to non-read notifications <br>    const UINT  iDiscardCodeVal =   23; <br>    const UINT  iNonRcptCodeVal =   24; <br> <br>    // The X-Message-Subject-ID property is not always <br>    // present for read and non-read notifications. <br>    // It's index will have to be computed. <br> <br>    // number of read notification content properties <br>    const ULONG nRNNotifyProps  =   23; <br> <br>    // number of non-read notification content properties <br>    const ULONG nNRNNotifyProps =   25; <br> <br>    // Property value array <br>    SPropValue  rgNotifyProps[nNRNNotifyProps]  =   {0}; <br>     <br>    DEBUGPRIVATE("CIPMConvert::HrSetNotifyCntProps()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR((m_MsgType == mtNRN || m_MsgType == mtRN), <br>                "Bad m_MsgType"); <br> <br>    // If we are doing TNEF decoding, let TNEF <br>    // extract the content properties. <br>    if ( m_fTNEFEncode == TRUE ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Initialize number of properties <br>    if ( m_MsgType == mtNRN ) <br>    { <br>        // non-read notification <br>        nNotifyProps = nNRNNotifyProps; <br>    } <br> <br>    else <br>    { <br>        // read notification <br>        nNotifyProps = nRNNotifyProps; <br>    } <br> <br>    // Set up notification content properties <br>    rgNotifyProps[iClassVal].ulPropTag = PR_MESSAGE_CLASS; <br>    rgNotifyProps[iClassVal].Value.LPSZ = m_rgszData[iClass]; <br> <br>// PR_SENDER_* and PR_SENT_REPRESENTING_* properties <br>    lpszFromAddr = m_rgszData[iFrom]; <br>    rgNotifyProps[iFromAddrVal].ulPropTag = PR_SENDER_EMAIL_ADDRESS; <br>    rgNotifyProps[iFromAddrVal].Value.LPSZ = lpszFromAddr; <br> <br>    rgNotifyProps[iFromNameVal].ulPropTag = PR_SENDER_NAME; <br>    rgNotifyProps[iFromNameVal].Value.LPSZ = lpszFromAddr; <br> <br>    // Create an entry identifier for this "one off" address <br>    hr = m_lpAB-&gt;CreateOneOff( <br>                    lpszFromAddr,   // name <br>                    (LPTSTR) m_lpszAddrType,    // address type <br>                    lpszFromAddr,   // address <br>                    0,              // flags <br>                    &amp;cbEid,         // #bytes in entry ID <br>                    &amp;lpEid);        // entry identifier <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    rgNotifyProps[iFromEidVal].ulPropTag = PR_SENDER_ENTRYID; <br>    rgNotifyProps[iFromEidVal].Value.bin.cb = cbEid; <br>    rgNotifyProps[iFromEidVal].Value.bin.lpb = (BYTE *) lpEid; <br> <br>    rgNotifyProps[iFromAddrTypeVal].ulPropTag = PR_SENDER_ADDRTYPE; <br>    rgNotifyProps[iFromAddrTypeVal].Value.LPSZ = (LPTSTR) m_lpszAddrType; <br> <br>    rgNotifyProps[iFromAddrVal2].ulPropTag = PR_SENT_REPRESENTING_EMAIL_ADDRESS; <br>    rgNotifyProps[iFromAddrVal2].Value.LPSZ = lpszFromAddr; <br> <br>    rgNotifyProps[iFromNameVal2].ulPropTag = PR_SENT_REPRESENTING_NAME; <br>    rgNotifyProps[iFromNameVal2].Value.LPSZ = lpszFromAddr; <br> <br>    rgNotifyProps[iFromEidVal2].ulPropTag = PR_SENT_REPRESENTING_ENTRYID; <br>    rgNotifyProps[iFromEidVal2].Value.bin.cb = cbEid; <br>    rgNotifyProps[iFromEidVal2].Value.bin.lpb = (BYTE *) lpEid; <br> <br>    rgNotifyProps[iFromAddrTypeVal2].ulPropTag = PR_SENT_REPRESENTING_ADDRTYPE; <br>    rgNotifyProps[iFromAddrTypeVal2].Value.LPSZ = (LPTSTR) m_lpszAddrType; <br> <br>    // Parse client submit time. <br>    hr = HrParseDateTimeString( <br>                m_rgszData[iDate],      // date time string <br>                &amp;ftSubmit);             // file time structure <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // Use a default value. <br>        GetSystemTimeAsFileTime( &amp;ftSubmit); <br>    } <br> <br>    rgNotifyProps[iSubmitTimeVal].ulPropTag =  <br>        PR_CLIENT_SUBMIT_TIME; <br>    rgNotifyProps[iSubmitTimeVal].Value.ft = ftSubmit; <br> <br>    // Determine importance value. <br>    hr = HrParseImportanceString( <br>                m_rgszData[iImportance],    // importance string <br>                &amp;ulImportance);             // importance value <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    rgNotifyProps[iImportanceVal].ulPropTag = PR_IMPORTANCE; <br>    rgNotifyProps[iImportanceVal].Value.l = ulImportance; <br> <br>    // Determine priority value. <br>    hr = HrParsePriorityString( <br>                m_rgszData[iPriority],  // priority string <br>                &amp;ulPriority);           // priority value <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    rgNotifyProps[iPriorityVal].ulPropTag = PR_PRIORITY; <br>    rgNotifyProps[iPriorityVal].Value.l = ulPriority; <br> <br>    rgNotifyProps[iSubjectVal].ulPropTag = PR_SUBJECT; <br>    rgNotifyProps[iSubjectVal].Value.LPSZ = m_rgszData[iSubject]; <br> <br>    // Parse report time. <br>    hr = HrParseDateTimeString( <br>                m_rgszData[iNotifyTime],    // date time string <br>                &amp;ftReport);                 // file time structure <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // Use a default value. <br>        GetSystemTimeAsFileTime( &amp;ftReport); <br>    } <br> <br>    rgNotifyProps[iReportTimeVal].ulPropTag = PR_REPORT_TIME; <br>    rgNotifyProps[iReportTimeVal].Value.ft = ftReport; <br> <br>    // Construct subject prefix <br>    // The subject prefix is everything up until the first colon <br>    // of the subject (and the next space, if any).  The normalized <br>    // subject is everything else. <br>    hr = HrEDKParseSubjectPrefix( <br>                m_rgszData[iSubject],   // subject text <br>                &amp;lpszSubjectPrefix,     // prefix <br>                &amp;lpszNormSubject);      // normalized subject <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    rgNotifyProps[iSubPrefixVal].ulPropTag = PR_SUBJECT_PREFIX; <br>    rgNotifyProps[iSubPrefixVal].Value.LPSZ = lpszSubjectPrefix; <br> <br>    rgNotifyProps[iNormSubjectVal].ulPropTag = PR_NORMALIZED_SUBJECT; <br>    rgNotifyProps[iNormSubjectVal].Value.LPSZ = lpszNormSubject; <br> <br>    // Must set original subject after have computed normalized <br>    // subject. <br>    rgNotifyProps[iOrigSubjectVal].ulPropTag = PR_ORIGINAL_SUBJECT; <br>    rgNotifyProps[iOrigSubjectVal].Value.LPSZ = lpszNormSubject; <br>     <br>    rgNotifyProps[iOrigSubmitVal].ulPropTag = PR_ORIGINAL_SUBMIT_TIME; <br>    rgNotifyProps[iOrigSubmitVal].Value.ft = ftSubmit; <br> <br>    // Note:  PR_ORIGINALLY_INTENDED_RECIPIENT_NAME is an <br>    // entry identifier, NOT a string! <br>    // Must be filled in after original destination EID is determined <br>    rgNotifyProps[iOrigDestNamVal].ulPropTag =  <br>            PR_ORIGINALLY_INTENDED_RECIPIENT_NAME; <br>    rgNotifyProps[iOrigDestNamVal].Value.bin.cb = cbEid; <br>    rgNotifyProps[iOrigDestNamVal].Value.bin.lpb = (BYTE *) lpEid; <br> <br>    rgNotifyProps[iOrigDestEidVal].ulPropTag =  <br>            PR_ORIGINALLY_INTENDED_RECIP_ENTRYID; <br>    rgNotifyProps[iOrigDestEidVal].Value.bin.cb = cbEid; <br>    rgNotifyProps[iOrigDestEidVal].Value.bin.lpb = (BYTE *) lpEid; <br> <br>    rgNotifyProps[iOrigDestAddrVal].ulPropTag =  <br>            PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS; <br>    rgNotifyProps[iOrigDestAddrVal].Value.LPSZ = lpszFromAddr; <br> <br>    rgNotifyProps[iOrigDestATypVal].ulPropTag = <br>            PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE; <br>    rgNotifyProps[iOrigDestATypVal].Value.LPSZ = (LPTSTR) m_lpszAddrType; <br> <br>    // Handle non-read notification specific properties. <br>    if ( m_MsgType == mtNRN ) <br>    { <br>        rgNotifyProps[iDiscardCodeVal].ulPropTag = PR_DISCARD_REASON; <br>        rgNotifyProps[iDiscardCodeVal].Value.l = atol(m_rgszData[iDiscardCode]); <br> <br>        rgNotifyProps[iNonRcptCodeVal].ulPropTag = PR_NON_RECEIPT_REASON; <br>        rgNotifyProps[iNonRcptCodeVal].Value.l = atol(m_rgszData[iNonRcptCode]); <br>    } <br> <br>    // Read notifications use the PR_PARENT_KEY property to <br>    // hold the IPM subject identifier. <br>    // Determine the PR_PARENT_KEY. <br>    ASSERTERROR(lstrlen(m_rgszData[iSubjectXID]) &lt;= ulMaxOutStringLen, <br>                "Bad m_rgszData[iSubjectXID]"); <br> <br>    // compute # bytes of binary data expected <br>    cbParentKey = lstrlen(m_rgszData[iSubjectXID])/2; <br> <br>    hr = ScBinFromHexBounded(    <br>            m_rgszData[iSubjectXID],    // ASCII representation of binary key <br>            rgbParentKey,               // Binary parent key pointer <br>            cbParentKey);               // # bytes of binary data <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    rgNotifyProps[iSubjectXIDVal].ulPropTag = PR_PARENT_KEY; <br>    rgNotifyProps[iSubjectXIDVal].Value.bin.cb = cbParentKey;   // # bytes  <br>    rgNotifyProps[iSubjectXIDVal].Value.bin.lpb = rgbParentKey; // binary value <br> <br>    ASSERTERROR(!FBadUnknown(m_lpContent), "Bad m_lpContent"); <br> <br>    // Set notification content properties. <br>    hr = m_lpContent-&gt;SetProps( <br>                nNotifyProps,       // # of properties <br>                rgNotifyProps,      // array of property values <br>                &amp;lpsProblems);      // problem array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        lpsProblems = NULL; <br> <br>        goto cleanup; <br>    } <br> <br>    // Check for property problems <br>    if ( lpsProblems ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Modify content's recipient table <br>    hr = m_lpContent-&gt;ModifyRecipients( <br>                MODRECIP_ADD,       // flags <br>                m_lpContentRecips); // address list         <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // save the changes to the message content <br>    hr = m_lpContent-&gt;SaveChanges( <br>                0);                     // we are done with the message content <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // save changes to the envelope attachment <br>    hr = m_lpAttach-&gt;SaveChanges( <br>                0);                     // we are done with the envelope attachment <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done <br>     <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpEid); <br>    MAPIFREEBUFFER(lpszSubjectPrefix); <br>    MAPIFREEBUFFER(lpszNormSubject); <br>    MAPIFREEBUFFER(lpsProblems); <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
