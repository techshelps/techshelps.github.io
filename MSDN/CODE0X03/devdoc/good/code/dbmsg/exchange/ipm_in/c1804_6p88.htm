<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPM_IN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1808"></a>IPM_IN.CPP</h2>
<pre><code>// --ipm_in.cpp-------------------------------------------------------------- <br>// <br>// API entry points for the ipm_in dynamic link library. <br>// Converts an 822-style message header to a MAPI message. <br>// This is the "Inbound IPM Converter". <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "ipmconv.h" <br>#include "convcls.h" <br>#include "ipm_in.chk" <br> <br>// GLOBAL VARIABLES <br> <br>// Thread local storage slot index.  <br>// This storage will be used to store the conversion class instance pointer <br>// for each thread. <br>static DWORD   dwTlsIndex   =   0xFFFFFFFF; <br> <br>// external function declarations <br> <br>// The DLL entry point extern "C" function declaration and <br>// "C" run-time library initialization extern "C" function declarations. <br>extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason,  <br>                                     LPVOID lpvReserved); <br>extern "C" BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason,  <br>                                 LPVOID lpvReserved); <br> <br>//$--HrCnvQueryCapability--------------------------------------------------------- <br>// <br>// DESCRIPTION: Determines whether or not a particular conversion can be <br>//              done.  The only conversion allowed is from <br>//              an 822 style header to a MAPI message of classes <br>//              containing ENVELOPE.IPM or <br>//              REPORT.IPM <br>// <br>// INPUT:       pszOptions  --  (not used) <br>//              pszClass    --  class of message to convert  <br>//                          (just needs to be a valid class) <br>//              pContent    --  822-style header stream pointer <br>//              pEnv    --  conversion environment pointer  <br>// <br>// OUTPUT:      pfAmCandidate   --  TRUE if can do conversion, FALSE otherwise <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>// <br>// --------------------------------------------------------------------------- <br>static HRESULT HrCnvQueryCapability( <br>        IN LPCWSTR pszOptions,  // conversion options <br>        IN LPCWSTR pszClass,    // message class to convert <br>        IN PVOID pContent,      // 822-style header stream pointer (candidate) <br>        IN PEDKCNVENV pEnv,     // conversion environment pointer <br>        OUT BOOL * pfAmCandidate)   // TRUE if can convert, FALSE otherwise <br>{ <br>    HRESULT hr  =   NOERROR; <br> <br>    DEBUGPRIVATE("HrCnvQueryCapability()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCnvQueryCapability(pszOptions, pszClass, <br>                                  pContent, pEnv, pfAmCandidate); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pfAmCandidate = FALSE;     // initialize output variable <br> <br>    // Check target message class <br>    // We can only convert classes which contain ENVELOPE.IPM or <br>    // REPORT.IPM. <br>    if ( (wcsstr(pszClass, IPMENVELOPECLASS) == NULL) &amp;&amp; <br>         (wcsstr(pszClass, IPMREPORTCLASS) == NULL) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // We assume that we can parse the input stream. <br>    *pfAmCandidate = TRUE; <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrAsciitoIPMFormat-------------------------------------------------------- <br>// <br>// DESCRIPTION: Converts an "822-style" stream input to a MAPI IPM message. <br>// <br>// NOTES:   Only one conversion may be performed at <br>//          a time (per thread). In order to do concurrent conversions, <br>//          create multiple threads. <br>// <br>// INPUT:       lpStream    --  Stream to read from <br>//              lpwszClass  --  message class <br>//              fTNEFEncode --  TNEF encoding flag <br>//              lpAddrType  --  address type <br>//              lpAddrBook  --  Address book pointer <br>//              lpEnvelope  --  message to write to <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_FAIL if API function call failure, <br>//                              E_NOTIMPL if requesting a feature not implemented <br>//                              or supported, <br>//                              EDK_E_ALREADY_EXISTS if a conversion is already <br>//                              in progress, <br>// <br>// --------------------------------------------------------------------------- <br> <br>static HRESULT HrAsciitoIPMFormat(                      <br>                               IN LPCWSTR lpwszClass,     // message class <br>                               IN BOOL fTNEFEncode,       // TNEF encoding flag <br>                               IN LPCTSTR lpAddrType,     // address type <br>                               IN LPADRBOOK lpAddrBook,   // address book pointer <br>                               IN LPSTREAM lpStream,      // pointer to stream <br>                               IN LPMESSAGE lpMessage)    // pointer to MAPI message envelope <br>{ <br>    HRESULT         hr              =   NOERROR; <br>    CIPMConvert *   lpCIPMConvert   =   NULL;   // thread-safe conversion class instance pointer <br>    BOOL            fInitialized    =   FALSE;  // TRUE if conversion instance already in use <br> <br>    DEBUGPRIVATE("HrAsciitoIPMFormat()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrAsciitoIPMFormat(lpwszClass, fTNEFEncode,  <br>                                lpAddrType, lpAddrBook, lpStream,  <br>                                lpMessage); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    ASSERTERROR(dwTlsIndex != 0xFFFFFFFF, "Bad thread storage index"); <br> <br>    // Retrieve the conversion class instance pointer for this class. <br>    lpCIPMConvert = (CIPMConvert *) TlsGetValue(dwTlsIndex); <br> <br>    if ( !lpCIPMConvert ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Initialize conversion instance <br>    hr = lpCIPMConvert-&gt;HrInitialize(lpwszClass, fTNEFEncode, <br>                                     lpAddrType, lpAddrBook, lpMessage, <br>                                     lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Go ahead and do conversion. <br>    hr = lpCIPMConvert-&gt;HrConvert(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Note: The thread-safe conversion class instance is de-initialized <br>    // at thread or process termination. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrCnvConvert--------------------------------------------------------- <br>// <br>// DESCRIPTION: Converts an 822-style header to a MAPI <br>//              ENVELOP.IPM or REPORT.IPM message. <br>//              This function is designed to be called on a per-thread <br>//              basis.  Each thread can handle one conversion at a time. <br>// <br>// INPUT:       pszOptions  --  (not used) <br>//              pszClass    --  class of message to convert  <br>//                              (just needs to be a valid class) <br>//              pContent    --  Stream to read from <br>//              pContentOut --  MAPI message envelope pointer <br>// <br>// OUTPUT:      pcr --  pointer to conversion result enumeration <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL if API call failure or syntax error. <br>//                          E_OUTOFMEMORY if memory problems <br>//                          E_NOTIMPL if conversion not supported, <br>//                          EDK_E_ALREADY_EXISTS if busy, <br>//                          EDK_E_END_OF_FILE if unexpected end-of-file encountered. <br>// <br>// --------------------------------------------------------------------------- <br>static HRESULT HrCnvConvert( <br>        IN LPCWSTR pszOptions,      // conversion options <br>        IN LPCWSTR pszClass,        // message class to convert <br>        IN PVOID pContent,          // stream to convert (candidate) <br>        IN PVOID pContentOut,       // MAPI message envelope pointer <br>        IN PEDKCNVENV pEnv,         // conversion environment pointer <br>        OUT EDKCNVRES * pcr)        // result of conversion <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    CONV_OPTIONS *  pConvOpts   =   NULL;   // conversion options structure <br> <br>    DEBUGPRIVATE("HrCnvConvert()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCnvConvert(pszOptions, pszClass, pContent, <br>                          pContentOut, pEnv, pcr); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // initialize output parameter <br>    *pcr = GCR_CONVERSION_FAILED; <br> <br>    // We can only convert classes which contain ENVELOPE.IPM or <br>    // REPORT.IPM <br>    if ( (wcsstr(pszClass, IPMENVELOPECLASS) == NULL) &amp;&amp; <br>         (wcsstr(pszClass, IPMREPORTCLASS) == NULL) ) <br>    { <br>        *pcr = GCR_CANNOT_CONVERT; <br> <br>        goto cleanup; <br>    } <br> <br>    // The pGatewayDefined field of the conversion envrironment <br>    // structure pointer points to a CONV_OPTIONS structure. <br>    // The CONV_OPTIONS structure contains the TNEF encoding <br>    // flag and the address book pointer. <br>    // Note, the CONV_OPTIONS structure was checked for validity <br>    // in the CHK function. <br>    pConvOpts = (CONV_OPTIONS *) (pEnv-&gt;pGatewayDefined); <br> <br>    // Let our helper function do the work! <br>    hr = HrAsciitoIPMFormat( <br>              pszClass,                     // message class <br>              pConvOpts-&gt;fTnefEncode,       // TNEF encoding flag <br>              pConvOpts-&gt;lpszAddressType,   // address type <br>              pEnv-&gt;lpAB,                   // addres book  <br>              (LPSTREAM) pContent,          // stream to read from <br>              (LPMESSAGE) pContentOut);     // MAPI message to write to <br> <br>    switch (hr) <br>    { <br>        case E_NOTIMPL: <br>            // don't support this conversion type <br>            *pcr = GCR_CANNOT_CONVERT; <br> <br>            goto cleanup; <br> <br>        default: <br>            if ( FAILED(hr) ) <br>            { <br>                // conversion failed. <br>                *pcr = GCR_CONVERSION_FAILED; <br> <br>                goto cleanup; <br>            } <br>    }   // end switch <br>     <br>    // if we get to here, then the conversion succeeded. <br>    *pcr = GCR_OK; <br>     <br>cleanup: <br> <br>    RETURN(hr);         <br> <br>} <br> <br>// structure containing pointers to exported functions <br>static CONVDLLVECT sExportedFuncs = <br>{ <br>    nDesiredConvDllVersion,  // version number 1 <br>    HrCnvQueryCapability, <br>    HrCnvConvert <br>}; <br> <br>//$--HrGetExportVector-------------------------------------------------------- <br>// <br>// DESCRIPTION: Gets pointer to exported functions structure. <br>// <br>// INPUT:       dwVersion   --  version requested <br>// <br>// OUTPUT:      ppExportVectors --  pointer to export vector structure pointer <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT HrGetExportVector(     // RETURNS: HRESULT <br>        IN DWORD dwVersion,         // version requested <br>        OUT PCONVDLLVECT * ppExportVectors)  // pointer to exported functions structure <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPUBLIC("HrGetExportVector()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrGetExportVector(dwVersion, ppExportVectors); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // return pointer to exported vectors structure <br>    *ppExportVectors = &amp;sExportedFuncs; <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--DllEntryPoint------------------------------------------------------------ <br>// <br>// DESCRIPTION: 32-bit Windows DLL entry point procedure.  Called on process <br>//              and thread initialization and deinitialization. <br>//              Takes care of calling _CRT_INIT to initialize the "C" run-time <br>//              library. <br>// <br>// INPUT:       hInstDll    --  DLL instance handle <br>//              fdwReason   --  Reason being called flag (PROCESS_ATTACH ...) <br>//              lpvReserved --  reserved <br>// <br>// RETURNS:     TRUE if successful, FALSE otherwise <br>// <br>// --------------------------------------------------------------------------- <br>BOOL WINAPI DllEntryPoint(                // RETURNS: BOOL <br>            IN HINSTANCE hInstDll,  // DLL instance handle <br>            IN DWORD fdwReason,     // reason this function is being called <br>            IN LPVOID lpvReserved)  // reserved (has static and dynamic call values) <br>{ <br>    BOOL            fResult         =   TRUE;   // FALSE if can't initialize <br>    CIPMConvert *   lpCIPMConvert   =   NULL;   // Per-thread conversion class instance pointer <br> <br>    // check to see why we were called. <br>    switch ( fdwReason ) <br>    {         <br>        case DLL_PROCESS_ATTACH: <br>            // Initialize the "C" run-time libarary. <br>            fResult = _CRT_INIT(hInstDll, fdwReason, lpvReserved); <br> <br>            if ( !fResult ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Get the thread local storage index. <br>            dwTlsIndex = TlsAlloc(); <br> <br>            if ( dwTlsIndex == 0xFFFFFFFF ) <br>            { <br>                // general failure <br>                fResult = FALSE; <br> <br>                goto cleanup; <br>            } <br> <br>            // Initialize a new conversion class. <br>            lpCIPMConvert = new CIPMConvert(); <br> <br>            if ( !lpCIPMConvert ) <br>            { <br>                fResult = FALSE; <br> <br>                goto cleanup; <br>            } <br> <br>            // Store the new thread-safe conversion class in the <br>            // thread local storage slot. <br>            fResult = TlsSetValue(dwTlsIndex, (LPVOID) lpCIPMConvert); <br> <br>            break; <br> <br>        case DLL_THREAD_ATTACH: <br>            // Initialize the "C" run-time libarary. <br>            fResult = _CRT_INIT(hInstDll, fdwReason, lpvReserved); <br> <br>            if ( !fResult ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Initialize a new conversion class. <br>            lpCIPMConvert = new CIPMConvert(); <br> <br>            if ( !lpCIPMConvert ) <br>            { <br>                fResult = FALSE; <br> <br>                goto cleanup; <br>            } <br> <br>            // Store the new thread-safe conversion class in the <br>            // thread local storage slot. <br>            fResult = TlsSetValue(dwTlsIndex, (LPVOID) lpCIPMConvert); <br> <br>            break; <br> <br>        case DLL_THREAD_DETACH: <br>            // Get our thread-local conversion class instance pointer <br>            lpCIPMConvert = (CIPMConvert *) TlsGetValue(dwTlsIndex); <br> <br>            if ( lpCIPMConvert ) <br>            { <br>                // free this conversion class instance. <br>                delete lpCIPMConvert; <br>            } <br> <br>            // de-initialize the "C" run-time libarary. <br>            fResult = _CRT_INIT(hInstDll, fdwReason, lpvReserved); <br> <br>            break; <br> <br>        case DLL_PROCESS_DETACH: <br>            // Get our thread-local conversion class instance pointer <br>            lpCIPMConvert = (CIPMConvert *) TlsGetValue(dwTlsIndex); <br> <br>            if ( lpCIPMConvert ) <br>            { <br>                // free this conversion class instance. <br>                delete lpCIPMConvert; <br>            } <br> <br>            // Free our thread-local storage index <br>            (VOID)TlsFree(dwTlsIndex); <br> <br>            // de-initialize the "C" run-time libarary. <br>            fResult = _CRT_INIT(hInstDll, fdwReason, lpvReserved); <br>                         <br>            break; <br> <br>        default:             <br>            // shouldn't happen <br>            ASSERTERROR(FALSE, "Bad fdwReason"); <br> <br>            fResult = FALSE; <br> <br>            break; <br> <br>    }   // end switch <br> <br>cleanup: <br> <br>    return fResult; <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
