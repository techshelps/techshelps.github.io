<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACLEDIT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1762"></a>ACLEDIT.CPP</h2>
<pre><code>//--acledit.cpp---------------------------------------------------------------- <br>// <br>// Folder ACLs editing utility. <br>//   <br>// Copyright (C) Microsoft Corp., 1986-1996.  All rights reserved. <br>// <br>//----------------------------------------------------------------------------- <br> <br>// <br>// Begin program documentation <br>// <br> <br>#if0 <br> <br>Command line arguments: See Usage(), or invoke acledit.exe with no command <br>line arguments to get a usage note. <br> <br>#endif <br> <br>// <br>// End program documentation <br>// <br> <br>#include "edk.h" <br>#include "errno.h" <br>#include "acledit.h" <br> <br>// <br>// Enumeration, structure, and other type definitions <br>// <br> <br>// ACLs editing commands: <br> <br>enum EDITCMD// ec <br>{ <br>EDITCMD_LIST, <br>EDITCMD_INSERT, <br>EDITCMD_DELETE, <br>EDITCMD_MODIFY, <br>EDITCMD_HELP, <br>EDITCMD_INVALID <br>}; <br> <br>structRIGHTSINFO// ri <br>{ <br>LPSTRpszKeyWord; <br>ULONGcchKeyWord; <br>LONGlRights; <br>}; <br> <br>// <br>// Forward function declarations. <br>// <br> <br>static <br>BOOL <br>bDoDelete(VOID); <br> <br>static <br>BOOL <br>bDoInsert(VOID); <br> <br>static <br>BOOL <br>bDoList(VOID); <br> <br>static <br>BOOL <br>bDoModify(VOID); <br> <br>static <br>BOOL <br>bParseCmdLine( <br>    IN  INT     argc, <br>    IN  CHAR *  argv[] <br>    ); <br> <br>static <br>BOOL <br>bParseRightsLst(VOID); <br> <br>static <br>VOID <br>DoHelp(VOID); <br> <br>static <br>VOID <br>EventLogHexErrorMsg( <br>INDWORDdwEvent, <br>INHRESULThr <br>); <br> <br>static <br>VOID <br>PrintRightsString( <br>INLONGlRights <br>); <br> <br>static <br>VOID <br>PrintErr( <br>INCHAR *Format <br>... <br>); <br> <br>static <br>VOID <br>Usage(VOID); <br> <br>// <br>// Static storage <br>// <br> <br>// Rights information array.  This is layed out in a specific manner, with <br>// all single bit rights first.  The order should not be changed.  The <br>// manifest constant NONEINDX is used to limit lookup of keywords to the <br>// range of single bit values, since the other keywords are special cases. <br> <br>staticRIGHTSINFOria[] = <br>{ <br>"ReadAny", sizeof("ReadAny") - 1, frightsReadAny, <br>"Create", sizeof("Create") - 1, frightsCreate, <br>"EditOwned", sizeof("EditOwned") - 1, frightsEditOwned, <br>"DeleteOwned", sizeof("DeleteOwned") - 1, frightsDeleteOwned, <br>"EditAny", sizeof("EditAny") - 1, frightsEditAny, <br>"DeleteAny", sizeof("DeleteAny") - 1, frightsDeleteAny, <br>"CreateSubfolder", sizeof("CreateSubfolder") - 1, frightsCreateSubfolder, <br>"Owner", sizeof("Owner") - 1, frightsOwner, <br>"Contact", sizeof("Contact") - 1, frightsContact, <br>"None", sizeof("None") - 1, rightsNone, <br>"ReadOnly", sizeof("ReadOnly") - 1, rightsReadOnly, <br>"ReadWrite", sizeof("ReadWrite") - 1, rightsReadWrite, <br>"All", sizeof("All") - 1, rightsAll <br>}; <br> <br>#defineNONEINDX9 <br> <br>staticLPSTRpszProfile =NULL; <br>staticLPSTRpszStore =NULL; <br>staticLPSTRpszFolder =NULL; <br>staticLPSTRpszRights =NULL; <br>staticLPSTRpszUser =NULL; <br> <br>staticBOOLfInboxArgFnd =FALSE; <br> <br>staticEDITCMDEditCmd =EDITCMD_INVALID; <br> <br>staticBOOLfPositionFnd =FALSE; <br>staticLONGlCursor =   0; <br> <br>staticLONGlRights =0; <br> <br>staticLPMAPISESSIONlpSession =NULL; <br> <br>staticLPMDBlpStore =NULL; <br> <br>staticULONGcbEIDStore  =   0; <br> <br>staticLPENTRYIDlpEIDStore =NULL; <br> <br>staticULONGcbEIDFolder =   0; <br> <br>staticLPENTRYIDlpEIDFolder =NULL; <br> <br>staticLPFOLDERACLSlpFolderACLs =NULL; <br> <br>// Command line argument flags, and array used by <br>// _HrExpandCommandLineArgument(): <br> <br>staticCHARszProfileArg[] ="profile"; <br> <br>staticCHARszStoreArg[] ="store"; <br>staticCHARszFolderArg[] ="folder"; <br>staticCHARszInboxArg[] ="inbox"; <br> <br>staticCHARszListArg[] ="list"; <br>staticCHARszInsertArg[] ="insert"; <br>staticCHARszModifyArg[] ="modify"; <br>staticCHARszDeleteArg[] ="delete"; <br> <br>staticCHARszPositionArg[] ="position"; <br> <br>staticCHARszRightsArg[] ="rights"; <br> <br>staticCHARszUserArg[] ="user"; <br> <br>staticCHARszHelpArg[] ="help"; <br> <br>staticCHARszQuestionArg[] ="?"; <br> <br>staticCHAR *rgpszArgArray[] ={ <br>szProfileArg, <br>szStoreArg, <br>szFolderArg, <br>szInboxArg, <br>szListArg, <br>szInsertArg, <br>szModifyArg, <br>szDeleteArg, <br>szPositionArg, <br>szRightsArg, <br>szUserArg, <br>szHelpArg, <br>szQuestionArg <br>}; <br> <br>staticULONGcErrs =0; <br> <br>// <br>// Functions <br>// <br> <br>// $--bDoDelete---------------------------------------------------------------- <br>// <br>// DESCRIPTION:Execute the DELETE command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:TRUE on success; FALSE otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>BOOL <br>bDoDelete(VOID)  // RETURNS: BOOL <br>{ <br>HRESULThr =NOERROR; <br>BOOLbrc =FALSE; <br>LONGlCurCursor =0; <br> <br>    DEBUGPRIVATE("bDoDelete()\n"); <br> <br>    hr = lpFolderACLs-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// We do prior check of cursor location to be able to cleanly specify <br>// the error. <br> <br>    hr = lpFolderACLs-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>if (lCurCursor == ACL_PAST_END) <br>{ <br>PrintErr("ACL at position END does not exist"); <br>goto cleanup; <br>} <br> <br>    hr = lpFolderACLs-&gt;HrDelete(); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Deletion failed. If the ACL specified is the default ACL or\n" <br> "is the ACL for the current user on a public folder, " <br> "it may not be deleted"); <br>cErrs--; <br>EventLogHexErrorMsg(ACLEDIT_DELETE_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>brc = TRUE; <br> <br>cleanup: <br> <br>return brc; <br>} <br> <br> <br>// $--bDoInsert---------------------------------------------------------------- <br>// <br>// DESCRIPTION:Execute the INSERT command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:TRUE on success; FALSE otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>BOOL <br>bDoInsert(VOID)  // RETURNS: BOOL <br>{ <br>LPSPropValueaPropVals   =   NULL; <br>BOOLbrc =FALSE; <br>ULONGcbEIDUser =0; <br>HRESULThr =NOERROR; <br>ULONGi =0; <br>LONGlCurCursor =0; <br>LONGlNewRights =0; <br>LPADRBOOKlpAdrBook =NULL; <br>LPADRENTRYlpAdrEntry  =   NULL; <br>LPADRLISTlpAdrList =NULL; <br>LPENTRYIDlpEIDUser =NULL; <br>LPSTRlpszDisplayName =NULL; <br> <br>    DEBUGPRIVATE("bDoInsert()\n"); <br> <br>    hr = lpFolderACLs-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// We do prior check of cursor location to be able to cleanly specify <br>// the error. <br> <br>    hr = lpFolderACLs-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// Open the address book and get the user entryid. <br> <br>hr = lpSession-&gt;OpenAddressBook(0, NULL, AB_NO_DIALOG, &amp;lpAdrBook); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_OPENADDRESSBOOK_FAILED, hr); <br>goto cleanup; <br>} <br> <br>hr = MAPIAllocateBuffer(CbNewADRLIST(1), (LPVOID FAR *)&amp;lpAdrList); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_ALLOCATION_FAILED, hr); <br>goto cleanup; <br>} <br> <br>lpAdrEntry  =   lpAdrList-&gt;aEntries; <br> <br>lpAdrList-&gt;cEntries = 1; <br> <br>lpAdrEntry-&gt;ulReserved1 =0; <br>lpAdrEntry-&gt;cValues =1; <br>lpAdrEntry-&gt;rgPropVals =NULL; <br> <br>hr = MAPIAllocateBuffer(sizeof(SPropValue), (LPVOID FAR *)&amp;aPropVals); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_ALLOCATION_FAILED, hr); <br>goto cleanup; <br>} <br> <br>lpAdrEntry-&gt;rgPropVals =aPropVals; <br> <br>aPropVals[0].ulPropTag =PR_DISPLAY_NAME; <br>aPropVals[0].Value.lpszA =NULL; <br> <br>hr = MAPIAllocateMore(strlen(pszUser) + 1, <br>  lpAdrEntry-&gt;rgPropVals, <br>  (LPVOID FAR *)&amp;lpAdrEntry-&gt;rgPropVals[0].Value.lpszA); <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_ALLOCATION_FAILED, hr); <br>goto cleanup; <br>} <br> <br>strcpy(lpAdrEntry-&gt;rgPropVals[0].Value.lpszA, pszUser); <br> <br>hr = lpAdrBook-&gt;ResolveName(0, 0, NULL, lpAdrList); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_RESOLVENAME_FAILED, hr); <br>goto cleanup; <br>} <br> <br>// Pick up ptr values again, assuming there was reallocation. <br> <br>lpAdrEntry  =   lpAdrList-&gt;aEntries; <br>aPropVals =lpAdrEntry-&gt;rgPropVals; <br> <br>for (i = 0; i &lt; lpAdrEntry-&gt;cValues; i++) <br>{ <br>if (aPropVals[i].ulPropTag == PR_ENTRYID) <br>{ <br>cbEIDUser = aPropVals[i].Value.bin.cb; <br>lpEIDUser = (LPENTRYID)aPropVals[i].Value.bin.lpb; <br> <br>break; <br>} <br>} <br> <br>for (i = 0; i &lt; lpAdrEntry-&gt;cValues; i++) <br>{ <br>if (aPropVals[i].ulPropTag == PR_DISPLAY_NAME) <br>{ <br>lpszDisplayName = aPropVals[i].Value.lpszA; <br>break; <br>} <br>} <br> <br>if (lpEIDUser == NULL || lpszDisplayName == NULL) <br>{ <br>hr = MAPI_E_NOT_FOUND; <br>EventLogHexErrorMsg(ACLEDIT_RESOLVENAME_FAILED, hr); <br>goto cleanup; <br> <br>} <br> <br>// Finally do the insert. <br> <br>hr = lpFolderACLs-&gt;HrInsert(lRights, <br>lpszDisplayName, <br>cbEIDUser, <br>lpEIDUser, <br>&amp;lNewRights); <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_INSERT_FAILED, hr); <br> <br>if (hr == E_FAIL) <br>{ <br>PrintErr("Insertion failed. " <br>     "If ACL for user already exists, use modify"); <br>cErrs--; <br>} <br>else <br>{ <br>PrintErr("Insertion failed"); <br>cErrs--; <br>} <br> <br>goto cleanup; <br>} <br> <br>// If the rights obtained are not exactly what is expected (which due to <br>// certain Exchange vagaries may be the case), the modified rights <br>// will be printed out. <br> <br>if (lRights != lNewRights) <br>{ <br>printf("Rights actually set are '"); <br> <br>PrintRightsString(lNewRights); <br> <br>printf("'\n\n"); <br>} <br> <br>brc = TRUE; <br> <br>cleanup: <br> <br>FREEPADRLIST(lpAdrList); <br>ULRELEASE(lpAdrBook); <br> <br>return brc; <br>} <br> <br> <br>// $--bDoList------------------------------------------------------------------ <br>// <br>// DESCRIPTION:Execute the LIST command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:TRUE on success; FALSE otherwise. <br>// <br>//--------------------------------------------------------------------------- <br> <br>BOOL <br>bDoList(VOID)    // RETURNS: BOOL <br>{ <br>HRESULThr =NOERROR; <br>BOOLbrc =FALSE; <br>HANDLEhConsole =GetStdHandle(STD_OUTPUT_HANDLE); <br>LONGlCurCursor =0; <br> <br>    DEBUGPRIVATE("bDoList()\n"); <br> <br>if (!fPositionFnd) <br>lCursor = 0; <br> <br>    hr = lpFolderACLs-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// Check for empty table or invalid cursor position. <br> <br>    hr = lpFolderACLs-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>if (pszStore == NULL) <br>pszStore = "default"; <br> <br>if (!fPositionFnd) <br>{ <br>printf("Listing of ACL table in folder \\%s in %s store:\n\n", <br>    pszFolder, pszStore); <br>} <br>else if (lCurCursor != ACL_PAST_END) <br>{ <br>printf("Listing of ACL table record %d in folder \\%s in %s store:\n\n", <br>   lCurCursor, pszFolder, pszStore); <br>} <br> <br>if (lCurCursor == ACL_PAST_END) <br>{ <br>if (fPositionFnd) <br>{ <br>PrintErr("ACL at position %d does not exist", lCursor); <br>} <br>else <br>{ <br>printf("ACL table is empty.\n"); <br>brc = TRUE; <br>} <br>goto cleanup; <br>} <br> <br>while (TRUE) <br>{ <br>ULONGcbentryid; <br>LONGlRights; <br>    LPSTRlpszDisplayName =NULL; <br>    LPENTRYIDlpentryid =NULL; <br> <br>hr = lpFolderACLs-&gt;HrGet(&amp;lRights, <br> &amp;lpszDisplayName, <br> &amp;cbentryid, <br> &amp;lpentryid); <br>if (FAILED(hr)) <br>{ <br>HRESULThrSaved = hr; <br> <br>    hr = lpFolderACLs-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>if (lCurCursor != ACL_PAST_END || hrSaved != E_FAIL) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_GET_FAILED, hrSaved); <br>        goto cleanup; <br>} <br>break; <br>} <br>else <br>{ <br>// Print listing: <br> <br>printf("For record at cursor position %d:\n\n", lCurCursor); <br> <br>printf("    User Name is '%s'\n", lpszDisplayName); <br> <br>printf("    Rights are '"); <br> <br>PrintRightsString(lRights); <br> <br>printf("'\n\n"); <br> <br>lCurCursor++; <br>} <br> <br>// Clean up allocations: <br> <br>MAPIFREEBUFFER(lpszDisplayName); <br>MAPIFREEBUFFER(lpentryid); <br> <br>// Only dump one record if cursor position was specified. <br> <br>if (fPositionFnd) <br>break; <br>} <br> <br>brc = TRUE; <br> <br>cleanup: <br> <br>return brc; <br>} <br> <br> <br>// $--bDoModify---------------------------------------------------------------- <br>// <br>// DESCRIPTION:Execute the MODIFY command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:TRUE on success; FALSE otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>BOOL <br>bDoModify(VOID)  // RETURNS: BOOL <br>{ <br>HRESULThr =NOERROR; <br>BOOLbrc =FALSE; <br>LONGlCurCursor =0; <br>LONGlNewRights =0; <br> <br>    DEBUGPRIVATE("bDoModify()\n"); <br> <br>    hr = lpFolderACLs-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// We do prior check of cursor location to be able to cleanly specify <br>// the error. <br> <br>    hr = lpFolderACLs-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogHexErrorMsg(ACLEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>if (lCurCursor == ACL_PAST_END) <br>{ <br>PrintErr("ACL at position END does not exist"); <br>goto cleanup; <br>} <br> <br>    hr = lpFolderACLs-&gt;HrModify(lRights, &amp;lNewRights); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Modification failed"); <br>cErrs--; <br>EventLogHexErrorMsg(ACLEDIT_MODIFY_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// If the rights obtained are not exactly what is expected (which due to <br>// certain Exchange vagaries may be the case), the modified rights <br>// will be printed out.  For instance the Owner right is always retained <br>// for the current user ACL on a public folder, and setting EditAny will <br>// also cause EditOwned to be set. <br> <br>if (lRights != lNewRights) <br>{ <br>printf("Rights actually set are '"); <br> <br>PrintRightsString(lNewRights); <br> <br>printf("'\n\n"); <br>} <br> <br>brc = TRUE; <br> <br>cleanup: <br> <br>return brc; <br>} <br> <br> <br>// $--bParseCmdLine------------------------------------------------------------ <br>// <br>// DESCRIPTION:    Parse the command line. <br>// <br>// INPUT: <br>// <br>//[argc]-- Count of arguments from command line. <br>//[argv]-- Array of arguments from command line. <br>// <br>// RETURNS:TRUE on success; FALSE otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>BOOL <br>bParseCmdLine(// RETURNS: BOOL <br>    IN  INT     argc,           // argument count <br>    IN  CHAR *  argv[]          // array of arguments <br>    ) <br>{ <br>    BOOL        bRetVal =   FALSE; <br>HRESULThr =NOERROR; <br>CHAR *pszArgData =NULL; <br>CHAR *pszFlagName =NULL; <br> <br>    DEBUGPRIVATE("bParseCmdLine()\n"); <br> <br>argc--;// Get rid of command argument. <br>argv++; <br> <br>if (argc == 0) <br>    goto cleanup; <br> <br>while (argc &gt; 0) <br>{ <br>hr =_HrExpandCommandLineArgument( <br>*argv, <br>rgpszArgArray, <br>sizeof(rgpszArgArray)/sizeof(rgpszArgArray[0]), <br>NULL, <br>&amp;pszFlagName, <br>&amp;pszArgData <br>); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Invalid command line argument"); <br>goto cleanup; <br>} <br> <br>if (pszFlagName == szProfileArg) <br>{ <br>if (pszProfile != NULL) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>pszProfile = pszArgData; <br>} <br>else if (pszFlagName == szStoreArg) <br>{ <br>if (pszStore != NULL) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>                goto cleanup; <br>} <br> <br>pszStore = pszArgData; <br>} <br>else if (pszFlagName == szFolderArg) <br>{ <br>if (pszFolder != NULL) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>pszFolder = pszArgData; <br>} <br>else if (pszFlagName == szInboxArg) <br>{ <br>// Note that you can put "/inbox" on the cmd line as many times <br>// as you like without creating a problem! :-) <br> <br>if (pszStore != NULL || pszFolder != NULL) <br>{ <br>PrintErr("Conflicting command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData != NULL) <br>{ <br>PrintErr("The /%s argument does not take a value", szInboxArg); <br>goto cleanup; <br>} <br> <br>fInboxArgFnd = TRUE; <br>} <br>else if (pszFlagName == szListArg) <br>{ <br>if (EditCmd != EDITCMD_INVALID) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData != NULL) <br>{ <br>PrintErr("The /%s argument does not take a value", szListArg); <br>goto cleanup; <br>} <br> <br>EditCmd = EDITCMD_LIST; <br>} <br>else if (pszFlagName == szInsertArg) <br>{ <br>if (EditCmd != EDITCMD_INVALID) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData != NULL) <br>{ <br>PrintErr("The /%s argument does not take a value",szInsertArg); <br>goto cleanup; <br>} <br> <br>EditCmd = EDITCMD_INSERT; <br>} <br>else if (pszFlagName == szModifyArg) <br>{ <br>if (EditCmd != EDITCMD_INVALID) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData != NULL) <br>{ <br>PrintErr("The /%s argument does not take a value",szInsertArg); <br>goto cleanup; <br>} <br> <br>EditCmd = EDITCMD_MODIFY; <br>} <br>else if (pszFlagName == szDeleteArg) <br>{ <br>if (EditCmd != EDITCMD_INVALID) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData != NULL) <br>{ <br>PrintErr("The /%s argument does not take a value",szDeleteArg); <br>goto cleanup; <br>} <br> <br>EditCmd = EDITCMD_DELETE; <br>} <br>else if (pszFlagName == szPositionArg) <br>{ <br>LPSTRpszValue = pszArgData; <br> <br>if (fPositionFnd) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszValue == NULL || *pszValue == '\0') <br>{ <br>PrintErr("The /%s argument requires a value", szPositionArg); <br>goto cleanup; <br>} <br> <br>if (!_stricmp(pszValue, "END")) <br>{ <br>lCursor = RULE_PAST_END; <br>} <br>else <br>{ <br>errno = 0; <br> <br>lCursor = strtol(pszValue, (CHAR **)NULL, 10); <br> <br>if ((lCursor == LONG_MAX || lCursor == LONG_MIN) &amp;&amp; <br>errno == ERANGE) <br>{ <br>PrintErr("Command line argument '%s' is invalid", *argv); <br>goto cleanup; <br>} <br>} <br> <br>fPositionFnd = TRUE; <br>} <br>else if (pszFlagName == szRightsArg) <br>{ <br>if (pszRights != NULL) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>pszRights = pszArgData; <br> <br>if (pszRights == NULL || *pszRights == '\0') <br>{ <br>PrintErr("The /%s argument requires a value", szRightsArg); <br>goto cleanup; <br>} <br> <br>if (!bParseRightsLst()) <br>goto cleanup; <br>} <br>else if (pszFlagName == szUserArg) <br>{ <br>if (pszUser != NULL) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>pszUser = pszArgData; <br> <br>if (pszUser == NULL || *pszUser == '\0') <br>{ <br>PrintErr("The /%s argument requires a value", szRightsArg); <br>goto cleanup; <br>} <br>} <br>else if (pszFlagName == szHelpArg|| <br> pszFlagName == szQuestionArg) <br>{ <br>EditCmd = EDITCMD_HELP; <br> <br>// If we encounter /help or /?, we pretty much ignore everything <br>// else and produce a help msg. <br> <br>bRetVal = TRUE; <br>goto cleanup; <br>} <br>else <br>{ <br>PrintErr("Command line argument '%s' is invalid", *argv); <br>goto cleanup; <br>} <br> <br>argc--; <br>argv++; <br>} <br> <br>// Check that all args needed have been provided. <br> <br>if (pszProfile == NULL) <br>{ <br>PrintErr("Command line must specify %s argument", szProfileArg); <br>goto cleanup; <br>} <br> <br>if (!fInboxArgFnd &amp;&amp; <br>(pszStore == NULL || *pszStore == '\0'|| <br> pszFolder == NULL || *pszFolder == '\0')) <br>{ <br>PrintErr("Command line must specify %s or %s and %s arguments", <br> szInboxArg, szStoreArg, szFolderArg); <br> <br>goto cleanup; <br>} <br> <br>if (EditCmd == EDITCMD_INVALID) <br>{ <br>PrintErr("Command line must specify a command argument"); <br>goto cleanup; <br>} <br>else if (EditCmd != EDITCMD_LIST &amp;&amp; EditCmd != EDITCMD_INSERT) <br>{ <br>if (!fPositionFnd) <br>{ <br>PrintErr("Command argument specified requires %s argument", <br> szPositionArg); <br> <br>goto cleanup; <br>} <br>} <br> <br>if (EditCmd == EDITCMD_INSERT) <br>{ <br>if (!fPositionFnd) <br>{ <br>// Defaults to end of list. <br> <br>fPositionFnd =TRUE; <br>lCursor =ACL_PAST_END; <br>} <br> <br>if (pszRights == NULL) <br>{ <br>PrintErr("Insert command requires %s argument", szRightsArg); <br>goto cleanup; <br>} <br>else if (pszUser == NULL) <br>{ <br>PrintErr("Insert command requires %s argument", szUserArg); <br>goto cleanup; <br>} <br>} <br>else if (EditCmd == EDITCMD_MODIFY) <br>{ <br>if (pszRights == NULL) <br>{ <br>PrintErr("Modify command requires %s argument", szRightsArg); <br>goto cleanup; <br>} <br>} <br>else <br>{ <br>if (pszRights != NULL) <br>{ <br>PrintErr("A %s argument is only used with the insert or modify " <br> "command", szRightsArg); <br> <br>goto cleanup; <br>} <br>else if (pszUser != NULL) <br>{ <br>PrintErr("A %s argument is only used with the insert command", <br> szUserArg); <br> <br>goto cleanup; <br>} <br>} <br> <br>bRetVal = TRUE; <br> <br>cleanup: <br> <br>    return bRetVal; <br>} <br> <br> <br>// $--bParseRightsLst---------------------------------------------------------- <br>// <br>// DESCRIPTION:Parse the rights list, storing the result in the global lRights. <br>// <br>// RETURNS:TRUE on success; FALSE otherwise. <br>// <br>// Notes:The rights keywords are case insensitive, but otherwise must <br>//match exactly.  There is no checking for keyword redundancy or <br>//conflict. <br>//----------------------------------------------------------------------------- <br> <br>BOOL <br>bParseRightsLst(VOID) <br>{ <br>BOOLbrc =FALSE; <br>ULONGcch =0; <br>ULONGi =0; <br>CHAR *pchBegin =pszRights; <br>CHAR *pchEnd =NULL; <br> <br>while (*pchBegin != '\0') <br>{ <br>while (isspace(*pchBegin)) <br>pchBegin++; <br> <br>pchEnd = pchBegin; <br> <br>do <br>{ <br>pchEnd++; <br>}while (!isspace(*pchEnd) &amp;&amp; *pchEnd != '\0'); <br> <br>cch = pchEnd - pchBegin; <br> <br>brc = FALSE; <br> <br>for (i = 0; i &lt; sizeof(ria)/sizeof(ria[0]); i++) <br>{ <br>if (cch == ria[i].cchKeyWord&amp;&amp; <br>!memicmp(pchBegin, ria[i].pszKeyWord, cch)) <br>{ <br>lRights |= ria[i].lRights; <br>brc = TRUE; <br>break; <br>} <br>} <br> <br>if (!brc) <br>{ <br>PrintErr("Invalid keyword '%.*s' in the rights list", <br> cch, pchBegin); <br> <br>goto cleanup; <br>} <br> <br>pchBegin = pchEnd; <br>} <br> <br>cleanup: <br> <br>return brc; <br>} <br> <br> <br>// $--DoHelp------------------------------------------------------------------ <br>// <br>// DESCRIPTION:Execute the HELP command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>DoHelp(VOID)  // RETURNS: VOID <br>{ <br>printf( <br>"\nUSAGE: ACLEDIT /Profile=&lt;ProfileName&gt; &lt;Folder&gt; &lt;Command&gt;\n\n" <br>"&lt;Folder&gt;   ::= /Store=&lt;NameOfStore&gt; /Folder=&lt;FolderPath&gt;                     ||\n" <br>"               /Inbox\n\n" <br>"&lt;Command&gt;  ::= /List [/Position=&lt;Pos&gt;]                                       ||\n" <br>"               /Insert /Rights=&lt;RightLst&gt; /User=&lt;UserName&gt; [/Position=&lt;Pos&gt;] ||\n" <br>"               /Modify /Position=&lt;Pos&gt; /Rights=&lt;RightLst&gt;                    ||\n" <br>"               /Delete /Position=&lt;Pos&gt;                                       ||\n" <br>"&lt;Position&gt; ::= &lt;ACL Number&gt;                                                  ||\n" <br>"               END\n\n" <br>"&lt;RightLst&gt; ::= &lt;Right&gt;...\n" <br>"&lt;Right&gt;    ::= ReadAny                                                       ||\n" <br>"               Create                                                        ||\n" <br>"               EditOwned                                                     ||\n" <br>"               DeleteOwned                                                   ||\n" <br>"               EditAny                                                       ||\n" <br>"               DeleteAny                                                     ||\n" <br>"               CreateSubfolder                                               ||\n" <br>"               Owner                                                         ||\n" <br>"               Contact                                                       ||\n" <br>"               None                                                          ||\n" <br>"               ReadOnly                                                      ||\n" <br>"               ReadWrite                                                     ||\n" <br>"               All                                                           ||\n" <br>"&lt;UserName&gt; ::= Display name of user against which ACL should be applied\n" <br>); <br>} <br> <br> <br>//$--EventLogHexErrorMsg------------------------------------------------------- <br>// <br>// DESCRIPTION: Write a message to the event log that contains a hex error code. <br>//This function is used for simple error messages that have the <br>//HRESULT (or other 4 byte error code) as the only insert. <br>// <br>// INPUT: <br>// <br>//[dwEvent]-- Event code for message string. <br>//[hr]-- HRESULT that will be printed in hex as the insert in the <br>//   message string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>EventLogHexErrorMsg( <br>INDWORDdwEvent,// event code for message string <br>INHRESULThr// HRESULT insert in the message string <br>) <br>{ <br>CHARszErrorCode[11]; <br> <br>sprintf(szErrorCode, "%#.8x", hr); <br> <br>EventLogMsg(dwEvent, 1, szErrorCode, 0); <br>} <br> <br> <br>//$--PrintErr------------------------------------------------------------------ <br>// <br>// DESCRIPTION:Print an error message to stdout in a standard format. <br>// <br>// INPUT: <br>// <br>//[Format]-- Printf-style format string. <br>//[...]-- Variable argument parameters for format string. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>PrintErr(        // RETURNS: VOID <br>INCHAR *Format      // error message format <br>... <br>) <br>{ <br>va_listargs; <br> <br>    DEBUGPRIVATE("PrintErr()\n"); <br> <br>cErrs++; <br> <br>printf("ERROR: "); <br> <br>va_start(args, Format); <br> <br>vprintf(Format, args); <br> <br>va_end(args); <br> <br>printf(".\n\n"); <br> <br>    return; <br>} <br> <br> <br>// $--PrintRightsString-------------------------------------------------------- <br>// <br>// DESCRIPTION:Print a readable representation of the rights. <br>// <br>// INPUT: <br>// <br>//[lRights]-- Rights to be printed. <br>// <br>// RETURNS:     Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>PrintRightsString( <br>INLONGlRights <br>) <br>{ <br>BOOLbSpaceNeeded =FALSE; <br>ULONGi =0; <br> <br>// We must plow through the special cases and then hit everything <br>// else.  We express 'ReadWrite' as 'ReadAny EditAny' since they are  <br>// equivalent, and 'ReadOnly' as 'ReadAny' since they are equivalent. <br> <br>if (lRights == rightsAll) <br>{ <br>printf("All"); <br>} <br>else if (lRights == rightsNone) <br>{ <br>printf("None"); <br>} <br>else <br>{ <br>for (i = 0; i &lt; NONEINDX; i++) <br>{ <br>if (lRights &amp; ria[i].lRights) <br>{ <br>if (bSpaceNeeded) <br>printf(" %s", ria[i].pszKeyWord); <br>else <br>printf("%s", ria[i].pszKeyWord); <br> <br>bSpaceNeeded = TRUE; <br>} <br>} <br>} <br>} <br> <br> <br>// $--Usage-------------------------------------------------------------------- <br>// <br>// DESCRIPTION:Print a usage message to the console. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:VOID <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>Usage(VOID)  // RETURNS: VOID <br>{ <br>    DEBUGPRIVATE("Usage()\n"); <br>printf( <br>"\nUSAGE: ACLEDIT /Profile=&lt;ProfileName&gt; &lt;Folder&gt; &lt;Command&gt;\n\n" <br>"Enter ACLEDIT /? for details.\n" <br>); <br>} <br> <br> <br>// $--main--------------------------------------------------------------------- <br>// <br>// DESCRIPTION:    acledit.exe main() routine. <br>// <br>// INPUT:   Standard argc and argv. <br>// <br>// RETURNS:     NOERROR on success; <br>//              E_INVALIDARG if bad input, <br>//              E_OUTOFMEMORY if memory problems. <br>//              E_FAIL on any execution error. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT  <br>main(               // RETURNS: HRESULT </code></pre>
<p>
</p>
<pre><code>IN  INT     argc,       // argument count <br>    IN  CHAR *  argv[]      // array of command line arguments <br>    ) <br>{ <br>HRESULThr =NOERROR; <br>BOOLbMAPIInitialized =FALSE; <br>BOOLbPrintCompletion =TRUE; <br>BOOLbEventLoggingEnabled =FALSE; <br> <br>    DEBUGPUBLIC("main()\n"); <br> <br>// Initialize event logging. <br> <br>hr = HrEventOpenLog("EDKAclEdit", NULL, NULL, NULL, NULL, NULL); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Event logging could not be enabled; error code=%#x\n",hr); <br>goto cleanup; <br>} <br>else <br>{ <br>bEventLoggingEnabled = TRUE; <br>} <br> <br>    // NOTE:  Must initialize MAPI before parsing command line, <br>    // as the parsing of the command line requires MAPI memory <br>    // allocation. <br> <br>if (argc == 1) <br>{ <br>Usage(); <br> <br>bPrintCompletion = FALSE; <br> <br>goto cleanup; <br>} <br> <br>hr = MAPIInitialize(0); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_MAPIINITIALIZE_FAILED, hr); <br>goto cleanup; <br>} <br> <br>bMAPIInitialized = TRUE; <br> <br>if (!bParseCmdLine(argc, argv)) <br>{ <br>printf("       Enter ACLEDIT /? for help.\n"); <br> <br>hr = HR_LOG(E_INVALIDARG); <br> <br>goto cleanup; <br>} <br> <br>if (EditCmd == EDITCMD_HELP) <br>{ <br>DoHelp(); <br> <br>hr = NOERROR; <br> <br>bPrintCompletion = FALSE; <br> <br>goto cleanup; <br>} <br> <br>hr = MAPILogonEx(0, <br>     pszProfile, <br>     NULL, <br>     MAPI_EXTENDED | MAPI_NEW_SESSION, <br>     &amp;lpSession); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_MAPILOGON_FAILED, hr); <br>        goto cleanup; <br>} <br> <br>// Get the entry id of the specified store and open it. <br> <br>if (fInboxArgFnd) <br>{ <br>hr = HrMAPIFindDefaultMsgStore(lpSession, &amp;cbEIDStore, &amp;lpEIDStore); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_FINDDEFAULTMSGSTORE_FAILED, hr); <br>goto cleanup; <br>} <br> <br>pszFolder = "Top of Information Store\\Inbox"; <br>} <br>else <br>{ <br>hr = HrMAPIFindStore(lpSession, pszStore, &amp;cbEIDStore, &amp;lpEIDStore); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_FINDSTORE_FAILED, hr); <br>goto cleanup; <br>} <br>} <br> <br>hr = lpSession-&gt;OpenMsgStore(0, <br> cbEIDStore, <br> lpEIDStore, <br> NULL, <br> MAPI_BEST_ACCESS| <br> MAPI_DEFERRED_ERRORS, <br> &amp;lpStore); <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_OPENMSGSTORE_FAILED, hr); <br>goto cleanup; <br>} <br> <br>// Get the entry id of the specified folder and open it. <br> <br>if (fInboxArgFnd) <br>{ <br>LPSTRlpszExplicitClass = ""; <br> <br>hr = lpStore-&gt;GetReceiveFolder(NULL, <br>   0, <br>   &amp;cbEIDFolder, <br>   &amp;lpEIDFolder, <br>   &amp;lpszExplicitClass); <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_GETRECEIVEFOLDER_FAILED, hr); <br>goto cleanup; <br>} <br> <br>pszFolder = "Inbox"; <br>} <br>else <br>{ <br>hr = HrMAPIFindFolderEx(lpStore, <br>TEXT('\\'), <br>pszFolder, <br>&amp;cbEIDFolder, <br>&amp;lpEIDFolder); <br>if (FAILED(hr)) <br>{ <br>EventLogHexErrorMsg(ACLEDIT_FINDFOLDER_FAILED, hr); <br>goto cleanup; <br>} <br>} <br> <br>// Get a folder ACL interface ptr for the specified folder. <br> <br>    hr = HrFolderACLsOpen(lpSession, lpStore, cbEIDFolder, lpEIDFolder, &amp;lpFolderACLs); <br> <br>    if (FAILED(hr)) <br>    { <br>if (hr == E_NOINTERFACE) <br>EventLogMsg(ACLEDIT_NOACLTABLE, 0, 0); <br>else <br>EventLogHexErrorMsg(ACLEDIT_FOLDERACLSOPEN_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>switch (EditCmd) <br>{ <br>case EDITCMD_LIST: <br>if (!bDoList()) <br>{ <br>hr = E_FAIL; <br>goto cleanup; <br>} <br>break; <br> <br>case EDITCMD_INSERT: <br>if (!bDoInsert()) <br>{ <br>hr = E_FAIL; <br>goto cleanup; <br>} <br>break; <br> <br>case EDITCMD_MODIFY: <br>if (!bDoModify()) <br>{ <br>hr = E_FAIL; <br>goto cleanup; <br>} <br>break; <br> <br>case EDITCMD_DELETE: <br>if (!bDoDelete()) <br>{ <br>hr = E_FAIL; <br>goto cleanup; <br>} <br>break; <br>} <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(lpEIDFolder); <br>MAPIFREEBUFFER(lpEIDStore); <br> <br>ULRELEASE(lpFolderACLs); <br>ULRELEASE(lpStore); <br> <br>if (lpSession) <br>{ <br>lpSession-&gt;Logoff(0, 0, 0); <br>ULRELEASE(lpSession); <br>} <br> <br>if (bMAPIInitialized) <br>(VOID)MAPIUninitialize(); <br> <br>if (bPrintCompletion) <br>{ <br>EDKEVENTCOUNTEvents = {0,0,0}; <br> <br>HrEventGetCounts(&amp;Events); <br> <br>cErrs += Events.cError; <br> <br>if (cErrs == 0) <br>{ <br>printf("Execution completed with no errors.\n"); <br>} <br>else <br>{ <br>if (cErrs == 1) <br>{ <br>printf("1 error encountered during execution.\n"); <br>} <br>else <br>{ <br>printf("%u errors encountered during execution.\n", cErrs); <br>} <br> <br>if (Events.cError == 1) <br>{ <br>printf("1 error written to NT Event Log.\n"); <br>} <br>else if (Events.cError &gt; 1) <br>{ <br>printf("%u errors written to NT Event Log.\n", Events.cError); <br>} <br>} <br>} <br> <br>if (bEventLoggingEnabled) <br>HrEventCloseLog(); <br> <br>    return _nEcFromHr(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
