<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSYNCOMM.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1772"></a>DSYNCOMM.C</h2>
<pre><code>// --dsyncomm.c----------------------------------------------------------------- <br>// <br>//  This file contains routines that are called by the code in dirsync.c.  <br>//  The routines in this file do the actual communication with the foreign  <br>//  system. <br>// <br>//  The routines in this file do the directory synchronization by reading and  <br>//  writing to a file in a format that can be used for directory exchange. <br>//  However, they were designed in such a way that developers can easily  <br>//  replace them with their own routines.  So for instance, they could be  <br>//  rewritten to communicate directly with a foreign mail system's API, or  <br>//  to make database read/write calls. <br>// <br>// <br>//  This file is linked with dirsync.c, and compiles to a seperate executable  <br>//  which is run from the command line. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "dirsync.h" <br>#include "dsynmsg.h" <br>#include "dsyncomm.chk" <br> <br>// <br>// Defined Constants <br>// <br> <br>// Longest line that can be read from the import file. <br> <br>#define MAX_IMPORT_LINE                         512 <br> <br>// Equates for size of array of DAPI_ENTRY's created on import,  <br>// initial allocation and growth amount. <br> <br>#define DAPI_ARRAY_ALLOCATION_INITIAL           30 <br>#define DAPI_ARRAY_ALLOCATION_GROWTH            20 <br> <br>// Equates for different ways of handling duplicate attributes  <br>// in HrAddAttributeToList(). <br> <br>#define DUPLICATE_ALLOW         0       // don't check for duplicates (faster) <br>#define DUPLICATE_DISCARD       1       // discard the duplicate <br>#define DUPLICATE_REPLACE       2       // replace orig w/ dup in same location <br>#define DUPLICATE_MULTI_VALUED  3       // make dup multi-valued part of orig <br>#define DUPLICATE_FAIL          4       // return error on duplicate <br> <br>// <br>// Variables Local to the File <br>// <br> <br>static FILE *   hExportFile                     = NULL; <br>static TCHAR    szExportFile[MAX_PATH+1]        = {0}; <br>static BOOL     fDeleteExportFile               = FALSE; <br> <br>static ULONG    cDAPIArrayElements              = DAPI_ARRAY_ALLOCATION_INITIAL; <br> <br>static FILE *   hImportFile                     = NULL; <br>static TCHAR    szImportFile[MAX_PATH+1]        = {0}; <br>static TCHAR    szObjectClass[MAX_PATH+1]       = {0}; <br>static TCHAR    szSourceStamp[MAX_PATH+1]       = {0}; <br>static TCHAR    szBasePoint[MAX_PATH+1]         = {0}; <br>static TCHAR    szContainer[MAX_PATH+1]         = {0}; <br>static TCHAR    szHomeServer[MAX_PATH+1]        = {0}; <br> <br>static CHAR     szImportLine[MAX_IMPORT_LINE]   = {0}; <br>static ULONG    cchImportLine                   = 0; <br>static BOOL     fImportLineSaved                = FALSE; <br>static ULONG    nImportLineNumber               = 0; <br>static CHAR     szTemp1[20]                     = {0}; <br>static CHAR     szRawDN[MAX_IMPORT_LINE]        = {0}; <br> <br>// <br>// Declarations for Local Routines <br>// <br> <br>static HRESULT HrCreateDAPIEntry( <br>    OUT PDAPI_ENTRY * ppDAPIEntry); <br> <br>static HRESULT HrReadImportRecordHeader( <br>    IN      LPTSTR pszBasePoint, <br>    IN      LPTSTR pszContainer, <br>    IN OUT  PDAPI_ENTRY pAttributes, <br>    IN OUT  PDAPI_ENTRY pValues, <br>    OUT     LPDIR_SYNC_OPERATION peOperation); <br> <br>static HRESULT HrReadImportDataLines( <br>    IN OUT  PDAPI_ENTRY pAttributes, <br>    IN OUT  PDAPI_ENTRY pValues); <br> <br>static HRESULT HrStripWhiteSpace( <br>    IN OUT  LPTSTR pszString); <br> <br>static HRESULT HrSkipToNextRecordHeader(void); <br> <br>static HRESULT HrReadImportLine(void); <br> <br>static HRESULT HrAddAttributeToList( <br>    IN      LPSTR       pszAttribute, <br>    IN      LPSTR       pszValue, <br>    IN      ULONG       ulDuplicateAction, <br>    IN OUT  PDAPI_ENTRY pAttributes, <br>    IN OUT  PDAPI_ENTRY pValues); <br> <br>static HRESULT HrExpandDAPIEntry( <br>    IN OUT  PDAPI_ENTRY pDAPIEntry); <br> <br> <br> <br>// <br>// User-Specified Routines <br>// <br> <br> <br> <br>//$--HrOpenExport--------------------------------------------------------------- <br>//  Function to do whatever initialization needs to be done before exporting  <br>//  records for directory synchronization.  It should return NOERROR if  <br>//  the initialization was successful and an error otherwise.  If this function  <br>//  returns an error then HrWriteExport() and HrCloseExport() will not be  <br>//  called. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrOpenExport(                       // RETURNS: HRESULT <br>    IN LPTSTR pszExportFile)                // file name from /EXPFILE <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPUBLIC("HrOpenExport()\n"); <br> <br>    hr = CHK_HrOpenExport(pszExportFile); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    lstrcpy(szExportFile, pszExportFile); <br>    fDeleteExportFile = FALSE; <br> <br>    hExportFile = fopen(szExportFile, "w"); <br>    if (hExportFile == NULL) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_CANNOT_CREATE_EXPORT_FILE,  <br>            1, szExportFile,  <br>            1, _doserrno); <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrWriteExport-------------------------------------------------------------- <br>//  Function to export a single record for directory synchronization.  It is  <br>//  called repeatedly: once for each record to be exported.  If this function  <br>//  returns an error it will not be called again, and HrCloseExport() will be  <br>//  called once to clean everything up. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrWriteExport(                      // RETURNS: HRESULT <br>    IN PDAPI_ENTRY pEntry,                  // record to export <br>    IN LPDIR_SYNC_ATTRIBUTE_INFO rgdsAttributeInfo, <br>                                            // additional information about pEntry <br>    IN LPTSTR pszDN,                        // distinguished name of this object <br>    IN DIR_SYNC_OPERATION eOperation)       // type of operation to do with object <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    int                 cBytesWritten       = 0; <br>    DWORD               i                   = 0; <br>    DWORD               iValueNumber        = 0; <br>    DWORD               chOperation         = 0; <br> <br>    DEBUGPUBLIC("HrWriteExport()\n"); <br> <br>    hr = CHK_HrWriteExport( <br>        pEntry,  <br>        rgdsAttributeInfo,  <br>        pszDN,  <br>        eOperation); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Determine the letter for the operation. <br> <br>    switch (eOperation) <br>    { <br>        case OPERATION_ADD: <br>            chOperation = 'A'; <br>            break; <br> <br>        case OPERATION_DELETE: <br>            chOperation = 'D'; <br>            break; <br> <br>        case OPERATION_MODIFY: <br>            chOperation = 'M'; <br>            break; <br> <br>        default: <br>            EventLogMsg( <br>                DIRSYNC_INTERNAL_ERROR,  <br>                0,  <br>                0); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>    } <br> <br>    // Output the first line of the record. <br> <br>    cBytesWritten = fprintf(hExportFile, "%c %s\n", chOperation, pszDN); <br>    if (cBytesWritten &lt; 0) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_CANNOT_WRITE_EXPORT_FILE,  <br>            1, szExportFile,  <br>            1, _doserrno); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // If the operation is not delete, then output each attribute. <br> <br>    if (eOperation != OPERATION_DELETE) <br>    { <br>        for (i = 0; i &lt; pEntry-&gt;unAttributes; i++) <br>        { <br>            // Output this attribute only if the user requested it. <br> <br>            if (rgdsAttributeInfo[i].fRequested) <br>            { <br>                ATT_VALUE * pValue = &amp;pEntry-&gt;rgEntryValues[i]; <br> <br>                if (pValue-&gt;pNextValue == NULL) <br>                { <br>                    // Only one instance of this value. <br> <br>                    cBytesWritten = fprintf( <br>                        hExportFile, "- %s:%s\n", <br>                        rgdsAttributeInfo[i].pszName,  <br>                        pValue-&gt;Value.pszValue ? pValue-&gt;Value.pszValue : ""); <br>                    if (cBytesWritten &lt; 0) <br>                    { <br>                        hr = HR_LOG(E_FAIL); <br>                        EventLogMsg( <br>                            DIRSYNC_CANNOT_WRITE_EXPORT_FILE,  <br>                            1, szExportFile,  <br>                            1, _doserrno); <br>                        goto cleanup; <br>                    } <br>                } <br>                else <br>                { <br>                    // Multiple instances of this value. <br> <br>                    for ( <br>                        iValueNumber = 0;  <br>                        pValue != NULL;  <br>                        iValueNumber++, pValue = pValue-&gt;pNextValue) <br>                    { <br>                        cBytesWritten = fprintf( <br>                            hExportFile,  <br>                            "- %s[%ld]:%s\n",  <br>                            rgdsAttributeInfo[i].pszName,  <br>                            iValueNumber,  <br>                            pValue-&gt;Value.pszValue ? pValue-&gt;Value.pszValue : ""); <br>                        if (cBytesWritten &lt; 0) <br>                        { <br>                            hr = HR_LOG(E_FAIL); <br>                            EventLogMsg( <br>                                DIRSYNC_CANNOT_WRITE_EXPORT_FILE,  <br>                                1, szExportFile,  <br>                                1, _doserrno); <br>                            goto cleanup; <br>                        } <br>                    } // endfor <br>                } // endif (pValue-&gt;pNextValue == NULL) <br>            } // endif (rgdsAttributeInfo[i].fRequested) <br>        } // endfor <br>    } // endif (eOperation != OPERATION_DELETE) <br> <br>    // Put a blank line between records. <br> <br>    cBytesWritten = fprintf(hExportFile, "\n"); <br>    if (cBytesWritten &lt; 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>cleanup: <br>    // If there was an error then set the flag to tell HrCloseExport()  <br>    // to delete the file. <br> <br>    if (FAILED(hr)) <br>    { <br>        fDeleteExportFile = TRUE; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCloseExport-------------------------------------------------------------- <br>//  Function to do whatever cleanup needs to be done after exporting records  <br>//  for directory synchronization. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCloseExport(void)                 // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    DWORD               i                   = 0; <br> <br>    DEBUGPUBLIC("HrCloseExport()\n"); <br> <br>    // Close the export file. <br> <br>    if (fclose(hExportFile) == EOF) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_CANNOT_CLOSE_EXPORT_FILE,  <br>            1, szExportFile,  <br>            1, _doserrno); <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    // If there was an error either on the write or on the close, then delete  <br>    // the file. <br> <br>    if (FAILED(hr) || fDeleteExportFile) <br>    { <br>        (void) remove(szExportFile); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrOpenImport--------------------------------------------------------------- <br>//  Function to do whatever initialization needs to be done before importing  <br>//  records for directory synchronization.  It should return NOERROR if  <br>//  the initialization was successful and an error otherwise.  If this function  <br>//  returns an error then HrReadImport() and HrCloseImport() will not be  <br>//  called. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrOpenImport(                       // RETURNS: HRESULT <br>    IN  LPTSTR pszImportFile,               // name of file to import <br>    IN  LPTSTR pszObjectClass,              // default object class <br>    IN  LPTSTR pszSourceStamp,              // string for Imported-From attr <br>    IN  LPTSTR pszBasePoint,                // default base point <br>    IN  LPTSTR pszContainer,                // default container <br>    IN  LPTSTR pszHomeServer)               // default home server for new mailbox <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPUBLIC("HrOpenImport()\n"); <br> <br>    hr = CHK_HrOpenImport( <br>        pszImportFile,  <br>        pszObjectClass,  <br>        pszSourceStamp,  <br>        pszBasePoint,  <br>        pszContainer,  <br>        pszHomeServer); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    lstrcpy(szImportFile, pszImportFile); <br>    lstrcpy(szObjectClass, pszObjectClass); <br>    lstrcpy(szSourceStamp, pszSourceStamp); <br>    lstrcpy(szBasePoint, pszBasePoint); <br>    lstrcpy(szContainer, pszContainer); <br>    lstrcpy(szHomeServer, pszHomeServer); <br>    strcpy(szRawDN, ""); <br> <br>    hImportFile = fopen(szImportFile, "r"); <br>    if (hImportFile == NULL) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_CANNOT_OPEN_IMPORT_FILE,  <br>            1, szImportFile,  <br>            1, _doserrno); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    fImportLineSaved = FALSE; <br>    nImportLineNumber = 0; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadImport--------------------------------------------------------------- <br>//  Function to import a single record for directory synchronization.  It is  <br>//  called repeatedly: once for each record to be imported.  If this function  <br>//  returns an error it will not be called again, and HrCloseImport() will be  <br>//  called once to clean everything up. <br>// <br>//  When there are no more records to import, HrReadImport should return  <br>//  EDK_E_END_OF_FILE. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrReadImport(                       // RETURNS: HRESULT <br>    OUT LPDIR_SYNC_OPERATION peOperation,   // type of operation <br>    OUT PDAPI_ENTRY *   ppAttributes,       // list of attribute names <br>    OUT PDAPI_ENTRY *   ppValues)           // list of attribute values <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    PDAPI_ENTRY         pAttributes         = NULL; <br>    PDAPI_ENTRY         pValues             = NULL; <br>    DIR_SYNC_OPERATION  eOperation          = 0; <br> <br>    DEBUGPUBLIC("HrReadImport()\n"); <br> <br>    hr = CHK_HrReadImport( <br>        peOperation,  <br>        ppAttributes,  <br>        ppValues); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Loop until we create a valid record or a fatal error. <br> <br>    while (TRUE) <br>    { <br>        // Free any old attribute name and value structures that  <br>        // may be around from a previous failed attempt. <br> <br>        MAPIFREEBUFFER(pAttributes); <br>        MAPIFREEBUFFER(pValues); <br> <br>        // Create new attribute name and value structures. <br> <br>        hr = HrCreateDAPIEntry(&amp;pAttributes); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        hr = HrCreateDAPIEntry(&amp;pValues); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        // Add the Obj-Class attribute to the list (this must be first!). <br> <br>        hr = HrAddAttributeToList( <br>            OBJ_CLASS,  <br>            szObjectClass,  <br>            DUPLICATE_ALLOW,  <br>            pAttributes,  <br>            pValues); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        // Read the first line of the record. <br> <br>        hr = HrReadImportRecordHeader( <br>            szBasePoint,  <br>            szContainer,  <br>            pAttributes,  <br>            pValues,  <br>            &amp;eOperation); <br>        if (FAILED(hr)) <br>        { <br>            // If it was just a parsing error (i.e. an invalid line)  <br>            // then skip to the next record header and try again. <br> <br>            if (hr == EDK_E_PARSE) <br>            { <br>                hr = HrSkipToNextRecordHeader(); <br>                if (FAILED(hr)) <br>                    goto cleanup; <br>                continue; <br>            } <br> <br>            goto cleanup; <br>        } <br> <br>        // Read the other lines in this record. <br> <br>        hr = HrReadImportDataLines(pAttributes, pValues); <br>        if (FAILED(hr)) <br>        { <br>            // If it was just a parsing error (i.e. an invalid line)  <br>            // then skip to the next record header and try again. <br> <br>            if (hr == EDK_E_PARSE) <br>            { <br>                hr = HrSkipToNextRecordHeader(); <br>                if (FAILED(hr)) <br>                    goto cleanup; <br>                continue; <br>            } <br> <br>            goto cleanup; <br>        } <br> <br>        // Add the Imported-From source stamp. <br> <br>        hr = HrAddAttributeToList( <br>            IMPORTED_FROM,  <br>            szSourceStamp,  <br>            DUPLICATE_REPLACE,  <br>            pAttributes,  <br>            pValues); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        // Succeeded, so exit the loop. <br> <br>        break; <br>    } <br> <br>cleanup: <br>    if (FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(pAttributes); <br>        MAPIFREEBUFFER(pValues); <br>    } <br>    else <br>    { <br>        *peOperation = eOperation; <br>        *ppAttributes = pAttributes; <br>        *ppValues = pValues; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCloseImport-------------------------------------------------------------- <br>//  Function to do whatever cleanup needs to be done after importing records  <br>//  for directory synchronization. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCloseImport(void)                 // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    DWORD               i                   = 0; <br> <br>    DEBUGPUBLIC("HrCloseImport()\n"); <br> <br>    // Close the import file. <br> <br>    if (fclose(hImportFile) == EOF) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_CANNOT_CLOSE_IMPORT_FILE,  <br>            1, szImportFile,  <br>            1, _doserrno); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>// <br>// Local Routines <br>// <br> <br> <br> <br>//$--HrCreateDAPIEntry---------------------------------------------------------- <br>//  Create a DAPI_ENTRY structure with an allocated array of ATT_VALUE  <br>//  structures attached to it.  The number of ATT_VALUE's is determined  <br>//  by the static variable cDAPIArrayElements.  Initially, the unAttributes  <br>//  member of the DAPI_ENTRY structure is 0, and this will be incremented  <br>//  each time one of the elements of the array of ATT_VALUE's is actually  <br>//  used. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCreateDAPIEntry(           // RETURNS: HRESULT <br>    OUT PDAPI_ENTRY * ppDAPIEntry)          // DAPI_ENTRY structure created <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    PDAPI_ENTRY         pDAPIEntry          = NULL; <br> <br>    DEBUGPRIVATE("HrCreateDAPIEntry()\n"); <br> <br>    hr = CHK_HrCreateDAPIEntry( <br>        ppDAPIEntry); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = MAPIAllocateBuffer(sizeof(DAPI_ENTRY), &amp;pDAPIEntry); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_ERROR,  <br>            0,  <br>            1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br>    ZeroMemory(pDAPIEntry, sizeof(DAPI_ENTRY)); <br> <br>    pDAPIEntry-&gt;unAttributes = 0; <br>    pDAPIEntry-&gt;ulEvalTag = TEXT_VALUE_ARRAY; <br> <br>    hr = MAPIAllocateMore( <br>        cDAPIArrayElements * sizeof(ATT_VALUE),  <br>        pDAPIEntry,  <br>        &amp;pDAPIEntry-&gt;rgEntryValues); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_ERROR,  <br>            0,  <br>            1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br>    ZeroMemory( <br>        pDAPIEntry-&gt;rgEntryValues,  <br>        cDAPIArrayElements * sizeof(ATT_VALUE)); <br> <br>cleanup: <br>    if (FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(pDAPIEntry); <br>    } <br>    else <br>    { <br>        *ppDAPIEntry = pDAPIEntry; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadImportRecordHeader--------------------------------------------------- <br>//  Reads the first line of a record from the import file and adds its data  <br>//  to the attribute name and attribute value arrays.  Also updates the global  <br>//  variable szRawDN for use in error event logging if there is a parsing error. <br>// <br>//  RETURN:         NOERROR =       operation was successful <br>//                  EDK_E_PARSE =   error but continue parsing at next record <br>//                  other error =   fatal error that makes it impossible to  <br>//                                  continue parsing the file <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadImportRecordHeader(    // RETURNS: HRESULT <br>    IN      LPTSTR pszBasePoint,            // default base point <br>    IN      LPTSTR pszContainer,            // default container <br>    IN OUT  PDAPI_ENTRY pAttributes,        // attribute name structure <br>    IN OUT  PDAPI_ENTRY pValues,            // attribute value structure <br>    OUT     LPDIR_SYNC_OPERATION peOperation) // operation type <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    char                chOperation         = 0; <br>    int                 cMatch              = 0; <br>    CHAR                szNormalizedDN[MAX_IMPORT_LINE] = {0}; <br>    DIR_SYNC_OPERATION  eOperation          = 0; <br> <br>    hr = CHK_HrReadImportRecordHeader( <br>        pszBasePoint,  <br>        pszContainer,  <br>        pAttributes,  <br>        pValues,  <br>        peOperation); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    DEBUGPRIVATE("HrReadImportRecordHeader()\n"); <br> <br>    // Clear the raw DN. <br> <br>    szRawDN[0] = 0; <br> <br>    // Get the next line (should be the first line of a record). <br> <br>    hr = HrReadImportLine(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Parse it to get the operation type and the distinguished name. <br> <br>    cMatch = sscanf(szImportLine, " %c %[^\n]", &amp;chOperation, szRawDN); <br>    if (cMatch != 2) <br>    { <br>        szRawDN[0] = 0; <br>        EventLogMsg( <br>            DIRSYNC_INVALID_IMPORT_LINE,  <br>            4, szImportFile, _itoa(nImportLineNumber,szTemp1,10), szRawDN,  <br>                szImportLine,  <br>            0); <br>        hr = HR_LOG(EDK_E_PARSE); <br>        goto cleanup; <br>    } <br> <br>    switch (toupper(chOperation)) <br>    { <br>        case 'A': <br>        case 'a': <br>            eOperation = OPERATION_ADD; <br>            break; <br> <br>        case 'M': <br>        case 'm': <br>            eOperation = OPERATION_MODIFY; <br>            break; <br> <br>        case 'D':    <br>        case 'd':    <br>            eOperation = OPERATION_DELETE; <br>            break; <br> <br>        default: <br>            szRawDN[0] = 0; <br>            EventLogMsg( <br>                DIRSYNC_INVALID_IMPORT_LINE,  <br>                4, szImportFile, _itoa(nImportLineNumber,szTemp1,10), szRawDN,  <br>                    szImportLine,  <br>                0); <br>            hr = HR_LOG(EDK_E_PARSE); <br>            goto cleanup; <br>    } <br> <br>    if (*szRawDN == 0) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_INVALID_IMPORT_LINE,  <br>            4, szImportFile, _itoa(nImportLineNumber,szTemp1,10), szRawDN,  <br>                szImportLine,  <br>            0); <br>        hr = HR_LOG(EDK_E_PARSE); <br>        goto cleanup; <br>    } <br> <br>    // If the DN starts with "/o" then don't change it. <br> <br>    if (!_strnicmp(szRawDN, "/o", 2)) <br>    { <br>        strcpy(szNormalizedDN, szRawDN); <br>    } <br> <br>    // Otherwise, normalize the DN (make sure it has /o= /ou= /cn=). <br> <br>    else <br>    { <br>        // Start with "/o=&lt;enterprise&gt;/ou=&lt;site&gt;"... <br> <br>        strcpy(szNormalizedDN, pszBasePoint); <br> <br>        // ...[add "/cn=&lt;container&gt;"]... <br> <br>        if (*pszContainer) <br>        { <br>            if (*pszContainer != '/') <br>            { <br>                strcat(szNormalizedDN, "/cn="); <br>            } <br>            strcat(szNormalizedDN, pszContainer); <br>        } <br> <br>        // ...add the DN. <br> <br>        if (*szRawDN != '/') <br>        { <br>            strcat(szNormalizedDN, "/cn="); <br>        } <br>        strcat(szNormalizedDN, szRawDN); <br>    } <br> <br>    // Add the distinguished name to the list as Common-Name. <br> <br>    hr = HrAddAttributeToList( <br>        COMMON_NAME,  <br>        szNormalizedDN,  <br>        DUPLICATE_ALLOW,  <br>        pAttributes,  <br>        pValues); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    *peOperation = eOperation; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadImportDataLines------------------------------------------------------ <br>//  Read the remaining data lines following the header into the attribute  <br>//  name and attribute value arrays. <br>// <br>//  RETURN:         NOERROR =       operation was successful <br>//                  EDK_E_PARSE =   error but continue parsing at next record <br>//                  other error =   fatal error that makes it impossible to  <br>//                                  continue parsing the file <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadImportDataLines(       // RETURNS: HRESULT <br>    IN OUT  PDAPI_ENTRY pAttributes,        // list of attribute names <br>    IN OUT  PDAPI_ENTRY pValues)            // list of attribute values <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    int                 cMatch              = 0; <br>    char                ch                  = 0; <br>    ULONG               ulDuplicateAction   = DUPLICATE_ALLOW; <br> <br>    CHAR                szAttributeName[MAX_IMPORT_LINE] = {0}; <br>    CHAR                szAttributeValue[MAX_IMPORT_LINE] = {0}; <br>    CHAR                szCurrentObjectClass[MAX_IMPORT_LINE] = {0}; <br> <br>    DEBUGPRIVATE("HrReadImportDataLines()\n"); <br> <br>    hr = CHK_HrReadImportDataLines( <br>        pAttributes,  <br>        pValues); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Make a copy of the current object class. <br> <br>    strcpy(szCurrentObjectClass, szObjectClass); <br> <br>    // Loop until end of file or a line that doesn't start with '-'. <br> <br>    while (TRUE) <br>    { <br>        // Reset the action to perform on duplicate attribute names  <br>        // (default is not to check for duplicates). <br> <br>        ulDuplicateAction = DUPLICATE_ALLOW; <br> <br>        // Get a line from the file. <br> <br>        hr = HrReadImportLine(); <br>        if (hr == EDK_E_END_OF_FILE) <br>        { <br>            hr = NOERROR; <br>            break; <br>        } <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        // If the line doesn't start with '-' then "unget" the line  <br>        // and we're done. <br> <br>        cMatch = sscanf(szImportLine, " %c", &amp;ch); <br>        if (cMatch != 1 || ch != '-') <br>        { <br>            fImportLineSaved = TRUE; <br>            break; <br>        } <br> <br>        // Try to match the line to a normal property template. <br> <br>        cMatch = sscanf( <br>            szImportLine,  <br>            " - %[-a-zA-Z] :%[^\n]",  <br>            szAttributeName,  <br>            szAttributeValue); <br> <br>        // If there was only 1 match, then check for the special case  <br>        // where the attribute value is an empty string. <br> <br>        if (cMatch == 1) <br>        { <br>            cMatch = sscanf( <br>                szImportLine,  <br>                " - %[-a-zA-Z] %[^\n]",  <br>                szAttributeName,  <br>                szAttributeValue); <br> <br>            if (cMatch == 2 &amp;&amp; !strcmp(szAttributeValue, ":")) <br>                szAttributeValue[0] = 0; <br>            else <br>                cMatch = 1; <br>        } <br> <br>        // If that didn't work, try to match it to a multi-valued  <br>        // property template. <br> <br>        if (cMatch != 2) <br>        { <br>            cMatch = sscanf( <br>                szImportLine,  <br>                " - %[-a-zA-Z] [ %*d ] :%[^\n]",  <br>                szAttributeName,  <br>                szAttributeValue); <br> <br>            // If there was only 1 match, then check for the special case  <br>            // where the attribute value is an empty string. <br> <br>            if (cMatch == 1) <br>            { <br>                cMatch = sscanf( <br>                    szImportLine,  <br>                    " - %[-a-zA-Z] [ %*d ] %[^\n]",  <br>                    szAttributeName,  <br>                    szAttributeValue); <br> <br>                if (cMatch == 2 &amp;&amp; !strcmp(szAttributeValue, ":")) <br>                    szAttributeValue[0] = 0; <br>                else <br>                    cMatch = 1; <br>            } <br> <br>            // If we couldn't match it as either a normal property  <br>            // template or a multi-valued property template, then  <br>            // it's an error. <br> <br>            if (cMatch != 2) <br>            { <br>                EventLogMsg( <br>                    DIRSYNC_INVALID_IMPORT_LINE,  <br>                    4, szImportFile, _itoa(nImportLineNumber,szTemp1,10),  <br>                        szRawDN, szImportLine,  <br>                    0); <br>                hr = HR_LOG(EDK_E_PARSE); <br>                goto cleanup; <br>            } <br> <br>            ulDuplicateAction = DUPLICATE_MULTI_VALUED; <br>        } <br> <br>        // If it's "Obj-Class", then replace the original one and store  <br>        // away the new value. <br> <br>        if (!_stricmp(szAttributeName, OBJ_CLASS)) <br>        { <br>            ulDuplicateAction = DUPLICATE_REPLACE; <br> <br>            strcpy(szCurrentObjectClass, szAttributeValue); <br>            hr = HrStripWhiteSpace(szCurrentObjectClass); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>        } <br> <br>        // Otherwise, if it's "Common-Name", then that's an error because they  <br>        // already specified "Common-Name" in the first line of the record. <br> <br>        else if (!_stricmp(szAttributeName, COMMON_NAME)) </code></pre>
<p>
</p>
<pre><code>{ <br>            EventLogMsg( <br>                DIRSYNC_CANNOT_IMPORT_COMMON_NAME,  <br>                3, szImportFile, _itoa(nImportLineNumber,szTemp1,10),  <br>                    szImportLine,  <br>                0); <br>            hr = HR_LOG(EDK_E_PARSE); <br>            goto cleanup; <br>        } <br> <br>        // Add the attribute name and value to the list. <br> <br>        hr = HrAddAttributeToList( <br>            szAttributeName,  <br>            szAttributeValue,  <br>            ulDuplicateAction,  <br>            pAttributes,  <br>            pValues); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // If the object class is "Mailbox" then add the "Home-Server" attribute,  <br>    // unless the user already specified one. <br> <br>    if (*szHomeServer &amp;&amp;  <br>        !_stricmp(szCurrentObjectClass, OBJECT_CLASS_MAILBOX)) <br>    { <br>        hr = HrAddAttributeToList( <br>            HOME_SERVER,  <br>            szHomeServer,  <br>            DUPLICATE_DISCARD,  <br>            pAttributes,  <br>            pValues); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrStripWhiteSpace---------------------------------------------------------- <br>//  Strip white space from a string. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrStripWhiteSpace(           // RETURNS: HRESULT <br>    IN OUT  LPTSTR pszString)               // string to strip white space from <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    LPTSTR              pszSrc              = pszString; <br>    LPTSTR              pszDst              = pszString; <br> <br>    DEBUGPRIVATE("HrStripWhiteSpace()\n"); <br> <br>    hr = CHK_HrStripWhiteSpace( <br>        pszString); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    while (*pszSrc) <br>    { <br>        if (isspace(*pszSrc)) <br>            pszSrc++; <br>        else <br>            *pszDst++ = *pszSrc++; <br>    } <br>    *pszDst = 0; <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrSkipToNextRecordHeader--------------------------------------------------- <br>//  Skip forward in the file to the next line that looks like a record  <br>//  header (i.e. begins with A|M|D).  After this routine is called, the  <br>//  next call to HrReadImportLine will return the record header. <br>//  This is used to resynchronize the input following a parsing error. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrSkipToNextRecordHeader(void) // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    int                 ch                  = 0; <br>    int                 cMatch              = 0; <br> <br>    DEBUGPRIVATE("HrSkipToNextRecordHeader()\n"); <br> <br>    // Loop to skip lines that aren't record headers. <br> <br>    do <br>    { <br>        hr = HrReadImportLine(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        cMatch = sscanf(szImportLine, " %c", &amp;ch); <br>        ch = toupper(ch); <br>    } <br>    while (cMatch != 1 || (ch != 'A' &amp;&amp; ch != 'M' &amp;&amp; ch != 'D')); <br> <br>    // "Unget" the line. <br> <br>    fImportLineSaved = TRUE; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadImportLine----------------------------------------------------------- <br>//  Read a line from the import file into the static variables <br>//  szImportLine and cchImportLine.  Setting fImportLineSaved == TRUE  <br>//  acts as an "unget", and causes the current contents of szImportLine  <br>//  to be used the next time this routine is called. <br>// <br>//  HrReadImportLine automatically skips empty lines, or those that begin  <br>//  with '#', signifying a comment. <br>// <br>//  Returns:    NOERROR             = success <br>//              EDK_E_END_OF_FILE   = end of file <br>//              E_FAIL              = error <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadImportLine(void)       // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    int                 ch                  = 0; <br>    int                 cMatch              = 0; <br>    char *              pszResult           = NULL; <br> <br>    DEBUGPRIVATE("HrReadImportLine()\n"); <br> <br>    // Loop until we get a line we can use. <br> <br>    do <br>    { <br>        // If we have a line saved from last time then just use that one. <br> <br>        if (fImportLineSaved) <br>            fImportLineSaved = FALSE; <br> <br>        // Otherwise read another line from the file. <br> <br>        else <br>        { <br>            pszResult =  <br>                fgets(szImportLine, sizeof(szImportLine) - 1, hImportFile); <br>            if (pszResult == NULL) <br>            { <br>                if (ferror(hImportFile)) <br>                { <br>                    EventLogMsg( <br>                        DIRSYNC_CANNOT_READ_IMPORT_FILE,  <br>                        1, szImportFile,  <br>                        1, _doserrno); <br>                    hr = HR_LOG(E_FAIL); <br>                } <br>                else <br>                { <br>                    hr = EDK_E_END_OF_FILE; <br>                } <br> <br>                goto cleanup; <br>            } <br> <br>            // Increment the line number. <br> <br>            nImportLineNumber++; <br> <br>            // Strip newline from end of line. <br> <br>            cchImportLine = strlen(szImportLine); <br>            if (cchImportLine &amp;&amp; szImportLine[cchImportLine - 1] == '\n') <br>                szImportLine[cchImportLine - 1] = 0; <br>            else <br>            { <br>                EventLogMsg( <br>                    DIRSYNC_IMPORT_LINE_TOO_LONG,  <br>                    3, szImportFile, _itoa(nImportLineNumber,szTemp1,10),  <br>                        szImportLine,  <br>                    0); <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br> <br>        // Get the first non-whitespace character in the line so we  <br>        // can make sure it exists and isn't a comment character ('#') <br> <br>        cMatch = sscanf(szImportLine, " %c", &amp;ch); <br>    } <br>    while (cMatch != 1 || ch == '#'); <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$-HrAddAttributeToList-------------------------------------------------------- <br>//  Adds an attribute name and value to the attribute name and attribute  <br>//  value arrays. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrAddAttributeToList(        // RETURNS: HRESULT <br>    IN      LPSTR       pszAttribute,       // name of attribute to add <br>    IN      LPSTR       pszValue,           // value of attribute to add <br>    IN      ULONG       ulDuplicateAction,  // action if property already in list <br>    IN OUT  PDAPI_ENTRY pAttributes,        // list of attribute names <br>    IN OUT  PDAPI_ENTRY pValues)            // list of attribute values <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    BOOL                fIsDuplicate        = FALSE; <br>    int                 iDuplicate          = 0; <br>    PATT_VALUE          pavAttribute        = NULL; <br>    PATT_VALUE          pavValue            = NULL; <br> <br>    DEBUGPRIVATE("HrAddAttributeToList()\n"); <br> <br>    hr = CHK_HrAddAttributeToList( <br>        pszAttribute,  <br>        pszValue,  <br>        ulDuplicateAction,  <br>        pAttributes,  <br>        pValues); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Check for duplicate attributes unless they are allowed. <br> <br>    if (ulDuplicateAction != DUPLICATE_ALLOW) <br>    { <br>        // Search backwards because duplicate names for multi-valued  <br>        // attributes are likely to be grouped together in the file. <br> <br>        for ( <br>            iDuplicate = pAttributes-&gt;unAttributes - 1;  <br>            iDuplicate &gt;= 0;  <br>            iDuplicate--) <br>        { <br>            if (!_stricmp( <br>                pAttributes-&gt;rgEntryValues[iDuplicate].Value.pszA,  <br>                pszAttribute)) <br>            { <br>                fIsDuplicate = TRUE; <br>                break; <br>            } <br>        } <br>    } <br> <br>    // Handle duplicates here. <br> <br>    if (fIsDuplicate) <br>    { <br>        switch (ulDuplicateAction) <br>        { <br>            // Discard duplicate -- don't change anything. <br> <br>            case DUPLICATE_DISCARD: <br>                pavAttribute = NULL; <br>                pavValue = NULL; <br>                break; <br> <br>            // Replace duplicate -- no need to re-create the name but  <br>            // overwrite the present value in the array. <br> <br>            case DUPLICATE_REPLACE: <br>                pavAttribute = NULL; <br>                pavValue = &amp;pValues-&gt;rgEntryValues[iDuplicate]; <br>                break; <br> <br>            // Make duplicate multi-valued part of original -- no need  <br>            // to re-create the name but allocate a new value structure  <br>            // and link it into the original. <br> <br>            case DUPLICATE_MULTI_VALUED: <br>                pavAttribute = NULL; <br>                hr = MAPIAllocateMore( <br>                    sizeof(ATT_VALUE),  <br>                    pValues,  <br>                    &amp;pavValue); <br>                if (FAILED(hr)) <br>                { <br>                    EventLogMsg( <br>                        DIRSYNC_ERROR,  <br>                        0,  <br>                        1, ERROR_OUTOFMEMORY); <br>                    goto cleanup; <br>                } <br> <br>                pavValue-&gt;pNextValue =  <br>                    pValues-&gt;rgEntryValues[iDuplicate].pNextValue; <br>                pValues-&gt;rgEntryValues[iDuplicate].pNextValue = pavValue; <br>                break; <br> <br>            // Fail on duplicates -- error. <br> <br>            case DUPLICATE_FAIL: <br>                EventLogMsg( <br>                    DIRSYNC_DUPLICATE_IMPORT_ATTRIBUTE,  <br>                    3, pszAttribute, szImportFile,  <br>                        _itoa(nImportLineNumber,szTemp1,10), szImportLine,  <br>                    0); <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br> <br>            // Invalid parameter. <br> <br>            default: <br>                EventLogMsg( <br>                    DIRSYNC_INTERNAL_ERROR,  <br>                    0,  <br>                    0); <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>        } <br>    } <br> <br>    // Handle non-duplicates here. <br> <br>    else <br>    { <br>        // Not a duplicate -- add both name and value to the end of  <br>        // their respective arrays. <br> <br>        // If we've run out of space in the arrays then expand them. <br> <br>        if (pAttributes-&gt;unAttributes &gt;= cDAPIArrayElements) <br>        { <br>            cDAPIArrayElements += DAPI_ARRAY_ALLOCATION_GROWTH; <br> <br>            hr = HrExpandDAPIEntry(pAttributes); <br>            if (FAILED(hr)) <br>                goto cleanup; <br> <br>            hr = HrExpandDAPIEntry(pValues); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>        } <br> <br>        pavAttribute = &amp;pAttributes-&gt;rgEntryValues[pAttributes-&gt;unAttributes++]; <br>        pavValue = &amp;pValues-&gt;rgEntryValues[pValues-&gt;unAttributes++]; <br>    } <br> <br>    // Fill in the attribute name structure. <br> <br>    if (pavAttribute) <br>    { <br>        ZeroMemory(pavAttribute, sizeof(ATT_VALUE)); <br>        pavAttribute-&gt;DapiType = DAPI_STRING8; <br>        pavAttribute-&gt;size = strlen(pszAttribute); <br>        hr = MAPIAllocateMore( <br>            pavAttribute-&gt;size + 1,  <br>            pAttributes,  <br>            &amp;pavAttribute-&gt;Value.pszA); <br>        if (FAILED(hr)) <br>        { <br>            EventLogMsg( <br>                DIRSYNC_ERROR,  <br>                0,  <br>                1, ERROR_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br>        strcpy(pavAttribute-&gt;Value.pszA, pszAttribute); <br>    } <br> <br>    // Fill in the attribute value structure. <br> <br>    if (pavValue) <br>    { <br>        ZeroMemory(pavValue, sizeof(ATT_VALUE)); <br>        pavValue-&gt;DapiType = DAPI_STRING8; <br>        pavValue-&gt;size = strlen(pszValue); <br>        hr = MAPIAllocateMore( <br>            pavValue-&gt;size + 1,  <br>            pValues,  <br>            &amp;pavValue-&gt;Value.pszA); <br>        if (FAILED(hr)) <br>        { <br>            EventLogMsg( <br>                DIRSYNC_ERROR,  <br>                0,  <br>                1, ERROR_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br>        strcpy(pavValue-&gt;Value.pszA, pszValue); <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrExpandDAPIEntry---------------------------------------------------------- <br>//  Re-allocates a DAPI_ENTRY structure with a larger array. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrExpandDAPIEntry(           // RETURNS: HRESULT <br>    IN OUT  PDAPI_ENTRY pDAPIEntry)         // DAPI_ENTRY structure <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    PATT_VALUE          pavNewBuffer        = NULL; <br> <br>    DEBUGPRIVATE("HrExpandDAPIEntry()\n"); <br> <br>    hr = CHK_HrExpandDAPIEntry( <br>        pDAPIEntry); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Allocate the new (bigger) buffer. <br> <br>    hr = MAPIAllocateMore( <br>        cDAPIArrayElements * sizeof(ATT_VALUE),  <br>        pDAPIEntry,  <br>        &amp;pavNewBuffer); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_ERROR,  <br>            0,  <br>            1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br>    ZeroMemory( <br>        pavNewBuffer,  <br>        cDAPIArrayElements * sizeof(ATT_VALUE)); <br> <br>    // Copy the old buffer to the new one. <br> <br>    CopyMemory( <br>        pavNewBuffer,  <br>        pDAPIEntry-&gt;rgEntryValues,  <br>        pDAPIEntry-&gt;unAttributes * sizeof(ATT_VALUE)); <br> <br>    // Point the header to the new buffer.  (It's OK to leave the  <br>    // old one dangling--it was allocated with MAPIAllocateMore,  <br>    // and will be freed along with the header). <br> <br>    pDAPIEntry-&gt;rgEntryValues = pavNewBuffer; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
