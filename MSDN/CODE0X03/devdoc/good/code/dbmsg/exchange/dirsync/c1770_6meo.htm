<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIRSYNC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1770"></a>DIRSYNC.C</h2>
<pre><code>// --dirsync.c------------------------------------------------------------------ <br>// <br>//  This file contains sample code showing how to do directory synchronization  <br>//  using DAPI.  It implements both the INBOUND and OUTBOUND direction. <br>//  I.E. importing an external mail system or other software system to the  <br>//  Exchange directory, and exporting the Exchange directory to an external  <br>//  mail system or other software system. <br>// <br>//  It compiles to an executable file which is run from the command line. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "dirsync.h" <br>#include "dsynmsg.h" <br>#include "dirsync.chk" <br> <br>// <br>// Bit Values and Defined Constants <br>// <br> <br>// Direction of data flow <br> <br>#define DIRECTION_EXPORT        0x00000001 <br>#define DIRECTION_IMPORT        0x00000002 <br> <br>// Source of settings <br> <br>#define SOURCE_COMMAND_LINE 0   // from command line only (no registry involved) <br>#define SOURCE_INSTANCE     1   // from named instance using &lt;Instance&gt; <br>#define SOURCE_KEY          2   // from registry key using /KEY=&lt;Key&gt; <br> <br>// Number of elements by which to grow the imported object list  <br>// when it runs out of space. <br> <br>#define IMPORTED_OBJECT_LIST_GROWTH_SIZE 1000 <br> <br>// <br>// Names of Command Line Arguments <br>// <br> <br>#define ARG_PROGRAM_NAME        "DIRSYNC" <br>#define ARG_EXPORT              "EXPORT" <br>#define ARG_IMPORT              "IMPORT" <br>#define ARG_BOTH                "BOTH" <br>#define ARG_DSA                 "DSA" <br>#define ARG_BASEPOINT           "BASEPOINT" <br>#define ARG_CONTAINER           "CONTAINER" <br>#define ARG_SERVER              "SERVER" <br>#define ARG_HOMESERVER          "HOMESERVER" <br>#define ARG_EXPLIST             "EXPLIST" <br>#define ARG_EXPFILE             "EXPFILE" <br>#define ARG_IMPFILE             "IMPFILE" <br>#define ARG_OBJCLASS            "OBJCLASS" <br>#define ARG_MVAPPEND            "MVAPPEND" <br>#define ARG_NOMVAPPEND          "NOMVAPPEND" <br>#define ARG_EXPFULL             "EXPFULL" <br>#define ARG_NOEXPFULL           "NOEXPFULL" <br>#define ARG_IMPFULL             "IMPFULL" <br>#define ARG_NOIMPFULL           "NOIMPFULL" <br>#define ARG_PROGRESS            "PROGRESS" <br>#define ARG_NOPROGRESS          "NOPROGRESS" <br>#define ARG_SUBS                "SUBS" <br>#define ARG_NOSUBS              "NOSUBS" <br>#define ARG_NTCREATE            "NTCREATE" <br>#define ARG_NONTCREATE          "NONTCREATE" <br>#define ARG_NTDELETE            "NTDELETE" <br>#define ARG_NONTDELETE          "NONTDELETE" <br>#define ARG_USN                 "USN" <br>#define ARG_HELP1               "?" <br>#define ARG_HELP2               "HELP" <br>#define ARG_SET                 "SET" <br>#define ARG_DISPLAY             "DISPLAY" <br>#define ARG_KEY                 "KEY" <br> <br>// <br>// Table of Command Line Switches for _HrExpandCommandLineArgument() <br>// <br> <br>static char * rgpszArgArray[] = { <br>    ARG_EXPORT, <br>    ARG_IMPORT, <br>    ARG_BOTH, <br>    ARG_DSA, <br>    ARG_BASEPOINT, <br>    ARG_CONTAINER, <br>    ARG_SERVER, <br>    ARG_HOMESERVER, <br>    ARG_EXPLIST, <br>    ARG_EXPFILE, <br>    ARG_IMPFILE, <br>    ARG_OBJCLASS, <br>    ARG_MVAPPEND, <br>    ARG_NOMVAPPEND, <br>    ARG_EXPFULL, <br>    ARG_NOEXPFULL, <br>    ARG_IMPFULL, <br>    ARG_NOIMPFULL, <br>    ARG_PROGRESS, <br>    ARG_NOPROGRESS, <br>    ARG_SUBS,  <br>    ARG_NOSUBS,  <br>    ARG_NTCREATE,  <br>    ARG_NONTCREATE,  <br>    ARG_NTDELETE,  <br>    ARG_NONTDELETE,  <br>    ARG_USN, <br>    ARG_HELP1, <br>    ARG_HELP2, <br>    ARG_SET, <br>    ARG_DISPLAY, <br>    ARG_KEY, <br>}; <br> <br>static char * rgpszObjClassValues[] = { <br>    OBJECT_CLASS_REMOTE, <br>    OBJECT_CLASS_MAILBOX, <br>}; <br> <br>// <br>// Command Line Parameters Also Stored In The Registry <br>// <br> <br>// (Note: BOOL's in this category have been changed to DWORD's so <br>// they can be more easily read from or written to the registry.) <br> <br>static DWORD    dwDirection                         = 0; <br>static TCHAR    szDSA           [MAX_PATH+1]        = {0}; <br>static TCHAR    szBasePoint     [MAX_PATH+1]        = {0}; <br>static TCHAR    szContainer     [MAX_PATH+1]        = {0}; <br>static TCHAR    szServer        [MAX_PATH+1]        = {0}; <br>static TCHAR    szHomeServer    [MAX_PATH+1]        = {0}; <br>static TCHAR    szExportList    [2048]              = {0}; <br>static TCHAR    szExportFile    [MAX_PATH+1]        = {0}; <br>static TCHAR    szImportFile    [MAX_PATH+1]        = {0}; <br>static TCHAR    szObjClass      [MAX_PATH+1]        = OBJECT_CLASS_REMOTE; <br>static DWORD    fFullExport                         = FALSE; <br>static DWORD    fFullImport                         = FALSE; <br>static DWORD    fProgressDialog                     = FALSE; <br>static DWORD    fSubs                               = FALSE; <br>static DWORD    fNTCreate                           = FALSE; <br>static DWORD    fNTDelete                           = FALSE; <br>static DWORD    fMVAppend                           = FALSE; <br>static DWORD    dwLastUSN                           = 0; <br> <br>// <br>// Command Line Parameters Not Stored In The Registry <br>// <br> <br>static BOOL     fHelp                               = FALSE; <br>static BOOL     fSet                                = FALSE; <br>static BOOL     fDisplay                            = FALSE; <br>static TCHAR    szKey           [MAX_PATH+1]        = {0}; <br>static TCHAR    szKeyState      [MAX_PATH+1]        = {0}; <br>static TCHAR    szInstanceName  [MAX_PATH+1]        = {0}; <br> <br>static LPDWORD  rgdwImportedObjectList              = NULL; <br>static DWORD    cdwImportedObjectList               = 0; <br>static DWORD    cdwMaxImportedObjectList            = 0; <br> <br>// <br>// Other Variables Local to the File <br>// <br> <br>static BOOL     fRespondedToUser                    = FALSE; <br> <br>static DWORD    dwSettingsSource                    = SOURCE_COMMAND_LINE; <br>static TCHAR    szSourceStamp   [MAX_PATH+1]        = {0}; <br>static HANDLE   hKey                                = NULL; <br>static HANDLE   hKeyState                           = NULL; <br> <br>static LONG     iUSNCreatedAttribute                = -1; <br>static LONG     iUSNChangedAttribute                = -1; <br>static LONG     iIsDeletedAttribute                 = -1; <br>static LONG     iObjDistNameAttribute               = -1; <br>static LONG     iImportedFromAttribute              = -1; <br>static DIR_SYNC_ATTRIBUTE_INFO * rgdsAttributes     = NULL; <br>static DWORD    cdsAttributes                       = 0; <br> <br>static DWORD    dwStartingUSN                       = 0; <br> <br>static BOOL     fErrorInCallback                    = FALSE; <br>static DWORD    cDAPILoggedErrors                   = 0; <br> <br>static DWORD    cObjectsImported                    = 0; <br>static DWORD    cObjectsExported                    = 0; <br> <br>// <br>// Structures Used For Reading/Writing Registry Data <br>// <br> <br>REG_VARIABLE rgrvInstanceData[] = { <br>    TEXT("Type"),               REG_DWORD,  sizeof(dwDirection),        &amp;dwDirection,  <br>    TEXT("DSA"),                REG_SZ,     sizeof(szDSA),              szDSA,  <br>    TEXT("Basepoint"),          REG_SZ,     sizeof(szBasePoint),        szBasePoint,  <br>    TEXT("Container"),          REG_SZ,     sizeof(szContainer),        szContainer,  <br>    TEXT("Server"),             REG_SZ,     sizeof(szServer),           szServer,  <br>    TEXT("Home Server"),        REG_SZ,     sizeof(szHomeServer),       szHomeServer,  <br>    TEXT("Export List"),        REG_SZ,     sizeof(szExportList),       szExportList,  <br>    TEXT("Export File"),        REG_SZ,     sizeof(szExportFile),       szExportFile,  <br>    TEXT("Import File"),        REG_SZ,     sizeof(szImportFile),       szImportFile,  <br>    TEXT("Object Class"),       REG_SZ,     sizeof(szObjClass),         szObjClass,  <br>    TEXT("Full Export"),        REG_DWORD,  sizeof(fFullExport),        &amp;fFullExport,  <br>    TEXT("Full Import"),        REG_DWORD,  sizeof(fFullImport),        &amp;fFullImport,  <br>    TEXT("Progress Dialog"),    REG_DWORD,  sizeof(fProgressDialog),    &amp;fProgressDialog,  <br>    TEXT("Sub-containers"),     REG_DWORD,  sizeof(fSubs),              &amp;fSubs,  <br>    TEXT("NT Create"),          REG_DWORD,  sizeof(fNTCreate),          &amp;fNTCreate,  <br>    TEXT("NT Delete"),          REG_DWORD,  sizeof(fNTDelete),          &amp;fNTDelete,  <br>    TEXT("MV Append"),          REG_DWORD,  sizeof(fMVAppend),          &amp;fMVAppend,  <br>}; <br> <br>REG_VARIABLE rgrvStateData[] = { <br>    // Note: Imported Object List must be the first element in this array. <br>    TEXT("Imported Object List"),   REG_BINARY,     0,                  NULL,  <br>    TEXT("Last USN"),           REG_DWORD,  sizeof(dwLastUSN),          &amp;dwLastUSN,  <br>}; <br> <br>// <br>// Function Declarations <br>// <br> <br>static HRESULT HrPreParseCommandLine( <br>    IN int argc, <br>    IN char *argv[]); <br> <br>static VOID PrintUsage(void); <br> <br>static VOID PrintHelp(void); <br> <br>static VOID PrintSettings(void); <br> <br>static HRESULT HrOpenRegistryKeys(void); <br> <br>static BOOL fAskCreateInstance(void); <br> <br>static HRESULT HrReadRegistryData(void); <br> <br>static HRESULT HrParseCommandLine( <br>    IN int argc, <br>    IN char *argv[]); <br> <br>static HRESULT HrWriteInstanceData(void); <br> <br>static HRESULT HrWriteStateData(void); <br> <br>static HRESULT HrCheckInfoCompleteness(void); <br> <br>static HRESULT HrDoExport(void); <br> <br>static DAPI_FNExportEntry fExportCallback; <br> <br>static HRESULT HrProcessExportHeader( <br>    IN PDAPI_ENTRY pEntry); <br> <br>static HRESULT HrProcessExportEntry( <br>    IN PDAPI_ENTRY pEntry); <br> <br>static int __cdecl nDWORDCompare( <br>    const void * pdw1, <br>    const void * pdw2); <br> <br>static BOOL fFindAttributeInList( <br>    IN LPTSTR pszAttributeName, <br>    IN LPTSTR pszAttributeList, <br>    OUT LPTSTR * ppszMatch); <br> <br>static VOID CleanupAttributeList( <br>    IN OUT LPTSTR pszAttributeList); <br> <br>static HRESULT HrDoImport(void); <br> <br>static HRESULT HrReadRegistryVariables( <br>    IN      HANDLE          hRegistryKey, <br>    IN      LPTSTR          pszRegistryKey, <br>    IN      DWORD           cVariables, <br>    IN OUT  LPREG_VARIABLE  rgrvVariables); <br> <br>static HRESULT HrWriteRegistryVariables( <br>    IN      HANDLE          hRegistryKey, <br>    IN      LPTSTR          pszRegistryKey, <br>    IN      DWORD           cVariables, <br>    IN OUT  LPREG_VARIABLE  rgrvVariables); <br> <br>static VOID PrintResults( <br>    IN  HRESULT     hr, <br>    IN  BOOL        fEventLogOpen); <br> <br>// <br>// Functions <br>// <br> <br>//$--main----------------------------------------------------------------------- <br>//  Main function that performs directory synchronization. <br>// ----------------------------------------------------------------------------- <br>int main(                                   // RETURNS: exit code <br>    IN int argc,                            // number of args on command line <br>    IN char *argv[])                        // array of command line arguments <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    BOOL                fEventLogOpen       = FALSE; <br>    BOOL                fMAPIInitialized    = FALSE; <br>    MAPIINIT_0          MapiInit            = {0}; <br> <br>    DEBUGPUBLIC("main()\n"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_main(argc, argv); <br>    if (FAILED(hr)) <br>        return _nEcFromHr(hr); <br> <br>    printf( "\n" ); <br> <br>    // If there are no command line arguments then print the usage message  <br>    // and exit. <br> <br>    if (argc &lt; 2) <br>    { <br>        PrintUsage(); <br>        goto cleanup; <br>    } <br> <br>    // Do preliminary parsing of the command line. <br> <br>    hr = HrPreParseCommandLine(argc, argv); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // If they requested help, then print a help message and exit. <br> <br>    if (fHelp) <br>    { <br>        PrintHelp(); <br>        goto cleanup; <br>    } <br> <br>    // Initialize event logging. <br> <br>    hr = HrEventOpenLog( <br>        TEXT("EDK DirSync"), NULL, NULL, NULL, NULL, NULL); <br> <br>    if (SUCCEEDED(hr)) <br>    { <br>        fEventLogOpen = TRUE; <br>    } <br>    hr = NOERROR; <br> <br>    // Initialize MAPI (for memory allocation). <br> <br>    MapiInit.ulVersion = MAPI_INIT_VERSION; <br> <br>    hr = MAPIInitialize(&amp;MapiInit); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_CANNOT_INIT_MAPI,  <br>            0,  <br>            0); <br>        goto cleanup; <br>    } <br>    fMAPIInitialized = TRUE; <br> <br>    // If we are using the registry, then open or create (depending on the  <br>    // /SET flag) the registry keys where the parameters and state information  <br>    // are kept.  Then, read the parameters and state information from the  <br>    // registry. <br> <br>    if (dwSettingsSource != SOURCE_COMMAND_LINE) <br>    { <br>        hr = HrOpenRegistryKeys(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        hr = HrReadRegistryData(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // Parse the command line arguments. <br> <br>    hr = HrParseCommandLine(argc, argv); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // If they specified the /SET flag or requested creation of a new instance  <br>    // or key, then write the (possibly changed) values back to the registry  <br>    // but don't do any actual directory synchronization. <br> <br>    if (fSet) <br>    { <br>        hr = HrWriteInstanceData(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        hr = HrWriteStateData(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // If they requested to display current settings then do it and then quit. <br> <br>    if (fDisplay) <br>    { <br>        PrintSettings(); <br>        goto cleanup; <br>    } <br> <br>    // If we are not creating a new instance or key then do the actual  <br>    // directory synchronization. <br> <br>    if (!fSet) <br>    { <br>        // Make sure we have all the information we need to do directory  <br>        // synchronization. <br> <br>        hr = HrCheckInfoCompleteness(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        // Create the source stamp. <br> <br>        STRNCPY(szSourceStamp, TEXT("EDKDirSync:")); <br>        STRNCAT(szSourceStamp, szInstanceName); <br> <br>        // Do import <br> <br>        if (dwDirection &amp; DIRECTION_IMPORT) <br>        { <br>            hr = HrDoImport(); <br>            if (FAILED(hr)) <br>                goto cleanup; <br> <br>            if (cObjectsImported == 1) <br>            { <br>                fprintf(stderr, "1 object imported to server %s.\n",  <br>                    szDSA); <br>                fRespondedToUser = TRUE; <br>            } <br>            else <br>            { <br>                fprintf(stderr, "%d objects imported to server %s.\n",  <br>                    cObjectsImported, szDSA); <br>                fRespondedToUser = TRUE; <br>            } <br>        } <br> <br>        // Do export <br> <br>        if (dwDirection &amp; DIRECTION_EXPORT) <br>        { <br>            hr = HrDoExport(); <br>            if (FAILED(hr)) <br>                goto cleanup; <br> <br>            if (cObjectsExported == 1) <br>            { <br>                fprintf(stderr, "1 object exported from server %s.\n",  <br>                    szDSA); <br>                fRespondedToUser = TRUE; <br>            } <br>            else <br>            { <br>                fprintf(stderr, "%d objects exported from server %s.\n",  <br>                    cObjectsExported, szDSA); <br>                fRespondedToUser = TRUE; <br>            } <br>        } <br>    } <br> <br>cleanup: <br>    // Print the results of the operation. <br> <br>    PrintResults(hr, fEventLogOpen); <br> <br>    // Close the registry. <br> <br>    if (hKeyState) <br>    { <br>        RegFlushKey(hKeyState); <br>        CloseHandle(hKeyState); <br>    } <br> <br>    if (hKey) <br>    { <br>        RegFlushKey(hKey); <br>        CloseHandle(hKey); <br>    } <br> <br>    // Close event logging. <br> <br>    if (fEventLogOpen) <br>    { <br>        (void) HrEventCloseLog(); <br>    } <br> <br>    // De-Initialize MAPI. <br> <br>    if (fMAPIInitialized) <br>    { <br>        MAPIUninitialize(); <br>        fMAPIInitialized = FALSE; <br>    } <br> <br>    return(_nEcFromHr(hr)); <br>} <br> <br> <br> <br>//$--HrPreParseCommandLine------------------------------------------------------ <br>//  Does preliminary parsing of the command line that is needed to decide how  <br>//  (and whether) to read data from the registry key before parsing the command  <br>//  line for real.  It looks for the following: <br>// <br>//  /? (Help)               If present, just print a help message and no other  <br>//                          processing takes place. <br>// <br>//  /DISPLAY                If present then display the current values of  <br>//                          data in the registry. <br>// <br>//  &lt;Instance Name&gt;         Used to construct a registry key name where  <br>//                          parameters should be stored. <br>// <br>//  /KEY=&lt;Registry Key&gt;     Used to specify an absolute registry key location  <br>//                          instead of using &lt;Instance Name&gt;. <br>// <br>//  /SET                    Indicates that we should create a new instance in  <br>//                          the registry but NOT do any actual directory  <br>//                          synchronization. <br>// <br>//  Note: if neither /KEY= nor &lt;Instance Name&gt; is specified, then we do not  <br>//  use the registry and all data must come from the command line. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrPreParseCommandLine(       // RETURNS: HRESULT <br>    IN int argc,                            // number of args on command line <br>    IN char *argv[])                        // array of command line arguments <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    HRESULT             hrT                 = NOERROR; <br>    int                 i                   = 0; <br>    char *              pszArgument         = NULL; <br>    char *              pszValue            = NULL; <br> <br>    DEBUGPRIVATE("HrPreParseCommandLine()\n"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_main(argc, argv); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Do an initial check for /? or /HELP or /DISPLAY. <br>    // If found, don't do any other parsing. <br> <br>    for (i = 1; i &lt; argc; i++) <br>    { <br>        hrT = _HrExpandCommandLineArgument( <br>            argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>            &amp;pszArgument, &amp;pszValue); <br> <br>        if (SUCCEEDED(hrT) &amp;&amp; pszArgument &amp;&amp;  <br>            (!_stricmp(pszArgument,ARG_HELP1) ||  <br>             !_stricmp(pszArgument,ARG_HELP2))) <br>        { <br>            fHelp = TRUE; <br>            goto cleanup; <br>        } <br>    } <br> <br>    // Search the command line arguments for /KEY=&lt;Registry Key&gt; or  <br>    // &lt;Instance Name&gt;.  Use whichever we find first to build a registry  <br>    // key name. <br> <br>    for (i = 1; i &lt; argc; i++) <br>    { <br>        hrT = _HrExpandCommandLineArgument( <br>            argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>            &amp;pszArgument, &amp;pszValue); <br> <br>        if (FAILED(hrT)) <br>        { <br>            hr = hrT; <br>            if (hr == EDK_E_NOT_FOUND) <br>            { <br>                fprintf(stderr, "ERROR: unknown command line flag: %s\n",  <br>                    argv[i]); <br>                fRespondedToUser = TRUE; <br>                continue; <br>            } <br>            else <br>            { <br>                fprintf(stderr, "ERROR: ambiguous command line flag: %s\n",  <br>                    argv[i]); <br>                fRespondedToUser = TRUE; <br>                goto cleanup; <br>            } <br>        } <br> <br>        // Check for &lt;Instance Name&gt; <br> <br>        if (pszArgument == NULL &amp;&amp; pszValue != NULL) <br>        { <br>            // Make sure this isn't a duplicate parameter. <br> <br>            if (dwSettingsSource != SOURCE_COMMAND_LINE) <br>            { <br>                fprintf(stderr, "ERROR: duplicate instance name or /%s: %s\n",  <br>                    ARG_KEY, argv[i]); <br>                fRespondedToUser = TRUE; <br>                hr = HR_LOG(E_FAIL); <br>            } <br> <br>            // Create registry key name and state key name. <br> <br>            STRNCPY(szInstanceName, argv[i]); <br> <br>            STRNCPY(szKey,  <br>                "HKEY_LOCAL_MACHINE\\SOFTWARE\\MS Exchange SDK Samples\\DirSync\\"); <br>            STRNCAT(szKey, szInstanceName); <br> <br>            STRNCPY(szKeyState, szKey); <br>            STRNCAT(szKeyState, TEXT("\\State")); <br> <br>            dwSettingsSource = SOURCE_INSTANCE; <br>        } <br> <br>        // Check for /KEY=&lt;Registry Key&gt; <br> <br>        else if (pszArgument &amp;&amp; !_stricmp(pszArgument,ARG_KEY)) <br>        { <br>            // Make sure they gave a value. <br> <br>            if (pszValue == NULL) <br>            { <br>                fprintf(stderr, "ERROR: flag /%s requires a value\n",  <br>                    pszArgument); <br>                fRespondedToUser = TRUE; <br>                hr = HR_LOG(E_FAIL); <br>            } <br> <br>            // Make sure this isn't a duplicate parameter. <br> <br>            if (dwSettingsSource != SOURCE_COMMAND_LINE) <br>            { <br>                fprintf(stderr, "ERROR: duplicate instance name or /%s: %s\n",  <br>                    ARG_KEY, argv[i]); <br>                fRespondedToUser = TRUE; <br>                hr = HR_LOG(E_FAIL); <br>            } <br> <br>            // Get registry key name. <br> <br>            if (SUCCEEDED(hr)) <br>            { <br>                STRNCPY(szKey, pszValue); <br> <br>                STRNCPY(szKeyState, szKey); <br>                STRNCAT(szKeyState, TEXT("\\State")); <br> <br>                dwSettingsSource = SOURCE_KEY; <br>            } <br>        } <br> <br>        // Check for /SET (create a new instance) <br> <br>        else if (pszArgument &amp;&amp;  <br>            (!_stricmp(pszArgument,ARG_SET))) <br>        { <br>            fSet = TRUE; <br>        } <br> <br>        // Check for /DISPLAY (display settings) <br> <br>        else if (pszArgument &amp;&amp; !_stricmp(pszArgument,ARG_DISPLAY)) <br>        { <br>            fDisplay = TRUE; <br>        } <br>    } <br> <br>    // If they use /SET then they must specify an instance name or use /KEY. <br>    // Otherwise, it's an error. <br> <br>    if (SUCCEEDED(hr) &amp;&amp; fSet &amp;&amp; dwSettingsSource == SOURCE_COMMAND_LINE) <br>    { <br>        fprintf(stderr, "ERROR: /%s requires instance name or /%s\n",  <br>            ARG_SET, ARG_KEY); <br>        fRespondedToUser = TRUE; <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--PrintUsage----------------------------------------------------------------- <br>//  Print information about how to use this program. <br>// ----------------------------------------------------------------------------- <br>static VOID PrintUsage(void)                // RETURNS: nothing <br>{ <br>    DEBUGPRIVATE("PrintUsage()\n"); <br> <br>    printf("USAGE: %s Instance [Flags]\n\n", ARG_PROGRAM_NAME); <br>    printf("  Instance       %s instance name\n", ARG_PROGRAM_NAME); <br>    printf("  [Flags]        Enter %s /%s for details\n", ARG_PROGRAM_NAME,  <br>        ARG_HELP1); <br>    fRespondedToUser = TRUE; <br>} <br> <br> <br> <br>//$--PrintHelp------------------------------------------------------------------ <br>//  Print information about the flags. <br>// ----------------------------------------------------------------------------- <br>static VOID PrintHelp(void)                 // RETURNS: nothing <br>{ <br>    DEBUGPRIVATE("PrintHelp()\n"); <br> <br>    printf("Directory Synchronization sample.\n\n"); <br>    printf("USAGE: %s Instance [Flags]\n\n", ARG_PROGRAM_NAME); <br>    printf("  Instance       %s instance name\n", ARG_PROGRAM_NAME); <br>    printf("  General Flags\n"); <br>    printf("  /BASEPOINT=    DN of Directory basepoint object\n"); <br>    printf("  /BOTH          Perform both import and export operations\n"); <br>    printf("  /CONTAINER=    RDN of Directory container beneath BASEPOINT\n"); <br>    printf("  /DISPLAY       Display current settings\n"); <br>    printf("  /DSA=          Directory Service Agent name\n"); <br>    printf("  /HELP or /?    Display help screen\n"); <br>    printf("  /KEY=          Override default registry key\n"); <br>    printf("  /SET           Create or update DirSync instance and registry value\n"); <br>    printf("  /[NO]PROGRESS  Display progress dialog\n"); <br>    printf("  /USN=          Universal Sequence Number filter\n"); <br>    printf("  Export Flags\n"); <br>    printf("  /EXPLIST=      Attribute list for Export\n"); <br>    printf("  /EXPFILE=      Export data file\n"); <br>    printf("  /[NO]EXPFULL   Perform full export (no USN filter)\n"); <br>    printf("  /EXPORT        Perform export operation\n"); <br>    printf("  /SERVER=       Exchange server name\n"); <br>    printf("  /[NO]SUBS      Export contents of sub-containers\n"); <br>    printf("  Import Flags\n"); <br>    printf("  /IMPFILE=      Import data file\n"); <br>//  printf("  /[NO]IMPFULL   Perform full import (replace entire container)\n"); <br>    printf("  /IMPORT        Perform import operation\n"); <br>    printf("  /[NO]NTCREATE  Create NT accounts for added/modified mailboxes\n"); <br>    printf("  /[NO]NTDELETE  Delete NT accounts for deleted mailboxes\n"); <br>    printf("  /OBJCLASS=     Type of imported objects to create (%s or %s)\n",  <br>        OBJECT_CLASS_MAILBOX, OBJECT_CLASS_REMOTE); <br>    printf("  /HOMESERVER=   Default home server for created mailboxes\n"); <br>    printf("  /[NO]MVAPPEND  Append multivalued properties\n\n"); <br>    printf("%s uses the NT registry key HKEY_LOCAL_MACHINE\\SOFTWARE\\\n",  <br>        ARG_PROGRAM_NAME); <br>    printf("MS Exchange SDK Samples\\DirSync\\&lt;Instance&gt; for configuration " <br>        "information.\n"); <br>    fRespondedToUser = TRUE; <br>} <br> <br> <br> <br>//$--PrintSettings-------------------------------------------------------------- <br>//  Print the current settings. <br>// ----------------------------------------------------------------------------- <br>static VOID PrintSettings(void)             // RETURNS: nothing <br>{ <br>    DWORD iObjectUSN = 0; <br> <br>    DEBUGPRIVATE("PrintSettings()\n"); <br> <br>    switch (dwSettingsSource) <br>    { <br>        case SOURCE_COMMAND_LINE: <br>            printf("Current settings from command line:\n\n"); <br>            break; <br> <br>        case SOURCE_INSTANCE: <br>            printf("Current settings for instance \"%s\":\n\n", szInstanceName); <br>            break; <br> <br>        case SOURCE_KEY: <br>            printf("Current settings for registry key \"%s\":\n\n", szKey); <br>            break; <br> <br>        default: <br>            printf("Current settings:\n\n"); <br>            break; <br>    } <br> <br>    printf("  Type                 = "); <br>    switch (dwDirection) <br>    { <br>        case DIRECTION_IMPORT: <br>            printf("Import\n"); <br>            break; <br> <br>        case DIRECTION_EXPORT: <br>            printf("Export\n"); <br>            break; <br> <br>        case DIRECTION_IMPORT | DIRECTION_EXPORT: <br>            printf("Import &amp; Export\n"); <br>            break; <br> <br>        default: <br>            printf("Unknown\n"); <br>            break; <br>    } <br> <br>    printf("  DSA                  = %s\n", szDSA); <br>    printf("  Base Point           = %s\n", szBasePoint); <br>    printf("  Object Class         = %s\n", szObjClass); <br>    printf("  Container            = %s\n", szContainer); <br>    printf("  Server               = %s\n", szServer); <br>    printf("  Home Server          = %s\n", szHomeServer); <br>    printf("  Export List          = %s\n", szExportList); <br>    printf("  Export File          = %s\n", szExportFile); <br>    printf("  Import File          = %s\n", szImportFile); <br>    printf("  Full Export          = %s\n", fFullExport ? "Yes" : "No"); <br>//  printf("  Full Import          = %s\n", fFullImport ? "Yes" : "No"); <br>    printf("  Progress Dialog      = %s\n", fProgressDialog ? "Yes" : "No"); <br>    printf("  NT Create            = %s\n", fNTCreate ? "Yes" : "No"); <br>    printf("  NT Delete            = %s\n", fNTDelete ? "Yes" : "No"); <br>    printf("  Sub-containers       = %s\n", fSubs ? "Yes" : "No"); <br>    printf("  Multi-Value Append   = %s\n", fMVAppend ? "Yes" : "No"); <br>    printf("  Last USN             = %d\n", dwLastUSN); <br> <br>    printf("  Imported Object List = "); <br>    for (iObjectUSN = 0; iObjectUSN &lt; cdwImportedObjectList; iObjectUSN++) <br>    { <br>        printf("%d", rgdwImportedObjectList[iObjectUSN]); <br>        if (iObjectUSN &lt; (cdwImportedObjectList - 1)) <br>            printf(", "); <br>    } <br>    printf("\n"); <br> <br>    fRespondedToUser = TRUE; <br>} <br> <br> <br> <br>//$--HrOpenRegistryKeys--------------------------------------------------------- <br>//  Open or create (depending on the flag fSet) two registry keys. <br>//  One key is where the default parameters for a given instance are stored.   <br>//  The other is where the state information for the instance is stored that  <br>//  tells what information was retrieved during the last dir sync, and what to  <br>//  get next.  The state key is always a subkey of the parameter key called  <br>//  "State". <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrOpenRegistryKeys(void)     // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    DWORD               dwStatus            = ERROR_SUCCESS; <br>    DWORD               dwDisposition       = 0; <br>    HKEY                hBaseKey            = NULL; <br>    char *              pszSubKey           = NULL; <br> <br>    DEBUGPRIVATE("HrOpenRegistryKeys()\n"); <br> <br>    // First, get the base key handle and sub key name from the string passed  <br>    // in /KEY or built from the instance name. <br> <br>    hr = HrIdentifyRegistryRootKey(szKey, &amp;hBaseKey, &amp;pszSubKey); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_INVALID_REGISTRY_KEY_NAME,  <br>            1, szKey,  <br>            0); <br>        goto cleanup; <br>    } <br> <br>    // Try to open the parameter key. <br> <br>    dwStatus = RegOpenKeyEx( <br>        hBaseKey,  <br>        pszSubKey,  <br>        0L,  <br>        KEY_ALL_ACCESS,  <br>        (struct HKEY__ **) &amp;hKey); <br> <br>    // If the key doesn't exist, then we need to create it... <br>     <br>    if (dwStatus == ERROR_FILE_NOT_FOUND) <br>    { <br>        // If the user didn't already ask to create a new instance with the  </code></pre>
<p>
</p>
<pre><code>// /SET flag, then ask the user whether to create a new instance. <br> <br>        if (!fSet) <br>        { <br>            if (fAskCreateInstance() == FALSE) <br>            { <br>                // User said "no", so terminate. <br> <br>                switch (dwSettingsSource) <br>                { <br>                    case SOURCE_KEY: <br>                        fprintf(stderr, "NT registry key not created.\n"); <br>                        fRespondedToUser = TRUE; <br>                        break; <br> <br>                    default: <br>                    case SOURCE_INSTANCE: <br>                        fprintf(stderr, "Instance not created.\n"); <br>                        fRespondedToUser = TRUE; <br>                        break; <br>                } <br>                hr = E_FAIL; <br>                goto cleanup; <br>            } <br>            else <br>            { <br>                // User said "yes", so set the flag the same as if it had been  <br>                // set using /SET. <br> <br>                fSet = TRUE; <br>            } <br>        } <br>    } <br> <br>    // ...otherwise, if we got some other error trying to open the parameter  <br>    // key then log it and return... <br> <br>    else if (dwStatus != ERROR_SUCCESS) <br>    { <br>        if (fSet) <br>        { <br>            EventLogMsg( <br>                DIRSYNC_CANNOT_CREATE_KEY,  <br>                1, szKey,  <br>                1, dwStatus); <br>        } <br>        else <br>        { <br>            EventLogMsg( <br>                DIRSYNC_CANNOT_OPEN_KEY,  <br>                1, szKey,  <br>                1, dwStatus); <br>        } <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // ...otherwise the parameter key was opened successfully, so open  <br>    // the state key. <br> <br>    else <br>    { <br>        dwStatus = RegOpenKeyEx( <br>            hKey,  <br>            TEXT("State"),  <br>            0L,  <br>            KEY_ALL_ACCESS,  <br>            (struct HKEY__ **) &amp;hKeyState); <br>        if (dwStatus != ERROR_SUCCESS) <br>        { <br>            EventLogMsg( <br>                DIRSYNC_CANNOT_OPEN_KEY,  <br>                1, szKeyState,  <br>                1, dwStatus); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // If we've gotten to here and the keys have not been opened yet,  <br>    // then the user must have requested that we create them. <br> <br>    if (hKey == NULL || hKeyState == NULL) <br>    { <br>        // Create a new parameter key. <br> <br>        if (hKey == NULL) <br>        { <br>            dwStatus = RegCreateKeyEx( <br>                hBaseKey,  <br>                pszSubKey,  <br>                0L,  <br>                NULL,  <br>                REG_OPTION_NON_VOLATILE,  <br>                KEY_ALL_ACCESS,  <br>                NULL,  <br>                (struct HKEY__ **) &amp;hKey,  <br>                &amp;dwDisposition); <br>            if (dwStatus != ERROR_SUCCESS) <br>            { <br>                EventLogMsg( <br>                    DIRSYNC_CANNOT_CREATE_KEY,  <br>                    1, szKey,  <br>                    1, dwStatus); <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br> <br>        // Create a new state key. <br> <br>        if (hKeyState == NULL) <br>        { <br>            dwStatus = RegCreateKeyEx( <br>                hKey,  <br>                TEXT("State"),  <br>                0L,  <br>                NULL,  <br>                REG_OPTION_NON_VOLATILE,  <br>                KEY_ALL_ACCESS,  <br>                NULL,  <br>                (struct HKEY__ **) &amp;hKeyState,  <br>                &amp;dwDisposition); <br>            if (dwStatus != ERROR_SUCCESS) <br>            { <br>                EventLogMsg( <br>                    DIRSYNC_CANNOT_CREATE_KEY,  <br>                    1, szKey,  <br>                    1, dwStatus); <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br> <br>        // Display a message that we created the keys. <br> <br>        switch (dwSettingsSource) <br>        { <br>            case SOURCE_KEY: <br>                fprintf(stderr, "Created new NT registry key:\n%s\n", szKey); <br>                fRespondedToUser = TRUE; <br>                break; <br> <br>            default: <br>            case SOURCE_INSTANCE: <br>                fprintf(stderr,  <br>                    "Created new NT registry key for instance %s:\n%s\n",  <br>                    szInstanceName, szKey); <br>                fRespondedToUser = TRUE; <br>                break; <br>        } <br>    } <br> <br>cleanup: <br>    if (FAILED(hr)) <br>    { <br>        CLOSEHANDLE(hKey); <br>        CLOSEHANDLE(hKeyState); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--fAskCreateInstance--------------------------------------------------------- <br>//  Ask the user whether or not to create a new key or instance. <br>// ----------------------------------------------------------------------------- <br>static BOOL fAskCreateInstance(void)        // RETURNS: TRUE=create, FALSE=don't <br>{ <br>    BOOL                fReturn             = TRUE; <br>    TCHAR               chAnswer            = 0; <br> <br>    DEBUGPRIVATE("fAskCreateInstance()\n"); <br> <br>    // Ask the user whether to create a new key or instance.  Keep asking until  <br>    // we get a yes or no. <br> <br>    do <br>    { <br>        if (*szInstanceName) <br>        { <br>            printf( <br>                "The instance %s is unknown.  " <br>                "Create a new instance?  (Y/N) ", szInstanceName); <br>        } <br>        else <br>        { <br>            printf( <br>                "The NT registry key\n" <br>                "%s does not exist.\n" <br>                "Create a new key? (Y/N) ", szKey); <br>        } <br> <br>        chAnswer = toupper(_getche()); <br>        printf("\n"); <br>    } <br>    while (chAnswer != 'Y' &amp;&amp; chAnswer != 'N'); <br> <br>    // Give a confirmation message telling whether we are creating a new  <br>    // key/instance or not. <br> <br>    if (chAnswer == 'Y') <br>    { <br>        fReturn = TRUE; <br>    } <br>    else <br>    { <br>        fReturn = FALSE; <br>    } <br> <br>    return(fReturn); <br>} <br> <br> <br> <br>//$--HrReadRegistryData--------------------------------------------------------- <br>//  Reads the default parameters and state information from the registry. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadRegistryData(void)     // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    DWORD               dwType              = 0; <br>    DWORD               cbImportedObjectList = 0; <br> <br>    DEBUGPRIVATE("HrReadRegistryData()\n"); <br> <br>    hr = HrReadRegistryVariables( <br>        hKey,  <br>        szKey,  <br>        ARRAY_CNT(rgrvInstanceData),  <br>        rgrvInstanceData); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    CleanupAttributeList(szExportList); <br> <br>    // Find the length of the imported object list (if the value doesn't exist  <br>    // then assume it has zero length). <br> <br>    hr = RegQueryValueEx( <br>        hKeyState,  <br>        TEXT("Imported Object List"),  <br>        NULL,  <br>        NULL,  <br>        NULL,  <br>        &amp;cbImportedObjectList); <br> <br>    if (hr == ERROR_FILE_NOT_FOUND) <br>    { <br>        cbImportedObjectList = 0; <br>        hr = NOERROR; <br>    } <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_CANNOT_READ_REGISTRY_VALUE,  <br>            2, TEXT("Imported Object List"), szKeyState,  <br>            1, hr); <br>        goto cleanup; <br>    } <br> <br>    // Set the current size of the imported object list. <br> <br>    cdwImportedObjectList = cbImportedObjectList / sizeof(DWORD); <br> <br>    // Allocate a buffer for the imported object list with room to grow. <br> <br>    cbImportedObjectList += (IMPORTED_OBJECT_LIST_GROWTH_SIZE * sizeof(DWORD)); <br> <br>    hr = MAPIAllocateBuffer( <br>        cbImportedObjectList,  <br>        &amp;rgdwImportedObjectList); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_ERROR,  <br>            0,  <br>            1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    cdwMaxImportedObjectList = cbImportedObjectList / sizeof(DWORD); <br> <br>    // Set the buffer address and size in the REG_VARIABLE structure. <br> <br>    rgrvStateData[0].cbData = cbImportedObjectList; <br>    rgrvStateData[0].pbData = rgdwImportedObjectList; <br> <br>    // Read the state data from the registry. <br> <br>    hr = HrReadRegistryVariables( <br>        hKeyState,  <br>        szKeyState,  <br>        ARRAY_CNT(rgrvStateData),  <br>        rgrvStateData); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // If the binary data was not an integral number of DWORD's  <br>    // then it's an error. <br> <br>    if (rgrvStateData[0].cbData % sizeof(DWORD)) <br>    { <br>        CHAR szDWORDSize[20] = {0}; <br> <br>        _itoa(sizeof(DWORD), szDWORDSize, 10); <br> <br>        EventLogMsg( <br>            DIRSYNC_INVALID_REGISTRY_VALUE_SIZE,  <br>            3, TEXT("Imported Object List"), szKeyState, szDWORDSize,  <br>            0); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrParseCommandLine--------------------------------------------------------- <br>//  Parse the command line arguments and put their values in the appropriate  <br>//  variables. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParseCommandLine(          // RETURNS: HRESULT <br>    IN int argc,                            // number of arguments on command line <br>    IN char *argv[])                        // array of command line arguments <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    int                 i                   = 0; <br>    char *              pszArgument         = NULL; <br>    char *              pszValue            = NULL; <br> <br>    DEBUGPRIVATE("HrParseCommandLine()\n"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_main(argc, argv); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    for (i = 1; i &lt; argc; i++) <br>    { <br>        hr = _HrExpandCommandLineArgument( <br>            argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>            &amp;pszArgument, &amp;pszValue); <br> <br>        if (FAILED(hr)) <br>        { <br>            fprintf(stderr, "ERROR: ambiguous command line flag: %s\n",  <br>            argv[i]); <br>            fRespondedToUser = TRUE; <br>            goto cleanup; <br>        } <br> <br>        if (pszArgument) <br>        { <br>            // Put all the flags that do not take a value here. <br> <br>            if (!_stricmp(pszArgument,ARG_EXPORT)) <br>            { <br>                dwDirection = DIRECTION_EXPORT; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_IMPORT)) <br>            { <br>                dwDirection = DIRECTION_IMPORT; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_BOTH)) <br>            { <br>                dwDirection = DIRECTION_IMPORT | DIRECTION_EXPORT; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_EXPFULL)) <br>            { <br>                fFullExport = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NOEXPFULL)) <br>            { <br>                fFullExport = FALSE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_IMPFULL)) <br>            { <br>                fFullImport = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NOIMPFULL)) <br>            { <br>                fFullImport = FALSE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_PROGRESS)) <br>            { <br>                fProgressDialog = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NOPROGRESS)) <br>            { <br>                fProgressDialog = FALSE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_SUBS)) <br>            { <br>                fSubs = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NOSUBS)) <br>            { <br>                fSubs = FALSE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NTCREATE)) <br>            { <br>                fNTCreate = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NONTCREATE)) <br>            { <br>                fNTCreate = FALSE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NTDELETE)) <br>            { <br>                fNTDelete = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NONTDELETE)) <br>            { <br>                fNTDelete = FALSE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_MVAPPEND)) <br>            { <br>                fMVAppend = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NOMVAPPEND)) <br>            { <br>                fMVAppend = FALSE; <br>            } <br>            else if ( <br>                !_stricmp(pszArgument,ARG_SET) ||  <br>                !_stricmp(pszArgument,ARG_DISPLAY)) <br>            { <br>                // We already parsed these, but keep this if statement as  <br>                // a placeholder so it doesn't think /SET or /DISPLAY needs  <br>                // a value. <br>            } <br> <br>            // If we got this far we know it's a flag that requires a value,  <br>            // so if they didn't give one then it's an error.  We know it  <br>            // is a valid flag because pszArgument != NULL, and that means  <br>            // the flag is in the list. <br> <br>            else if (pszValue == NULL) <br>            { <br>                fprintf(stderr, "ERROR: flag /%s requires a value\n",  <br>                    pszArgument); <br>                fRespondedToUser = TRUE; <br>                hr = HR_LOG(E_FAIL); <br>            } <br> <br>            // Put all the flags that take a value here. <br> <br>            else if (!_stricmp(pszArgument,ARG_DSA)) <br>            { <br>                STRNCPY(szDSA, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_BASEPOINT)) <br>            { <br>                STRNCPY(szBasePoint, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_CONTAINER)) <br>            { <br>                STRNCPY(szContainer, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_SERVER)) <br>            { <br>                STRNCPY(szServer, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_HOMESERVER)) <br>            { <br>                STRNCPY(szHomeServer, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_EXPLIST)) <br>            { <br>                STRNCPY(szExportList, pszValue); <br>                CleanupAttributeList(szExportList); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_EXPFILE)) <br>            { <br>                STRNCPY(szExportFile, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_IMPFILE)) <br>            { <br>                STRNCPY(szImportFile, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_USN)) <br>            { <br>                dwLastUSN = atol(pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_OBJCLASS)) <br>            { <br>                ULONG iObjClass = 0; <br> <br>                hr = _HrFindArrayValue( <br>                    pszValue,  <br>                    rgpszObjClassValues,  <br>                    ARRAY_CNT(rgpszObjClassValues),  <br>                    &amp;iObjClass); <br>                if (hr == EDK_E_NOT_FOUND || *pszValue == 0) <br>                { <br>                    fprintf( <br>                        stderr,  <br>                        "ERROR: \"%s\" is an invalid value for flag /%s.\n",  <br>                        pszValue,  <br>                        ARG_OBJCLASS); <br>                    fRespondedToUser = TRUE; <br>                    hr = HR_LOG(E_FAIL); <br>                } <br>                else if (FAILED(hr)) <br>                { <br>                    fprintf(stderr, "ERROR: unable to parse argument %s.\n", argv[i]); <br>                    fRespondedToUser = TRUE; <br>                    hr = HR_LOG(E_FAIL); <br>                } <br>                else <br>                { <br>                    STRNCPY(szObjClass, rgpszObjClassValues[iObjClass]); <br>                } <br>            } <br>        } <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrWriteInstanceData-------------------------------------------------------- <br>//  Write the instance variables to the registry. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrWriteInstanceData(void)    // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPRIVATE("HrWriteInstanceData()\n"); <br> <br>    hr = HrWriteRegistryVariables( <br>        hKey,  <br>        szKey,  <br>        ARRAY_CNT(rgrvInstanceData),  <br>        rgrvInstanceData); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrWriteStateData----------------------------------------------------------- <br>//  Write the state variables to the registry. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrWriteStateData(void)       // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPRIVATE("HrWriteStateData()\n"); <br> <br>    rgrvStateData[0].pbData = rgdwImportedObjectList; <br>    rgrvStateData[0].cbData = cdwImportedObjectList * sizeof(DWORD); <br> <br>    hr = HrWriteRegistryVariables( <br>        hKeyState,  <br>        szKeyState,  <br>        ARRAY_CNT(rgrvStateData),  <br>        rgrvStateData); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCheckInfoCompleteness---------------------------------------------------- <br>//  Make sure that we have all the information to do directory synchronization. <br>//  This information can come from the command line and/or the registry. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCheckInfoCompleteness(void) // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPRIVATE("HrCheckInfoCompleteness()\n"); <br> <br>    // If we are doing an import, then make sure the Object Class is valid. <br> <br>    if (dwDirection &amp; DIRECTION_IMPORT) <br>    { <br>        DWORD iObjClass = 0; <br>        BOOL fObjClassIsValid = FALSE; <br> <br>        for (iObjClass = 0; iObjClass &lt; ARRAY_CNT(rgpszObjClassValues); iObjClass++) <br>        { <br>            if (!_stricmp(szObjClass, rgpszObjClassValues[iObjClass])) <br>            { <br>                fObjClassIsValid = TRUE; <br>                break; <br>            } <br>        } <br>        if (!fObjClassIsValid) <br>        { <br>            fprintf( <br>                stderr,  <br>                "ERROR: Invalid Object Class value \"%s\" in registry\n",  <br>                szObjClass); <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    if (*szKey == 0 &amp;&amp; dwSettingsSource != SOURCE_COMMAND_LINE) <br>    { <br>        fprintf(stderr, "ERROR: please specify instance name or /%s\n",  <br>            ARG_KEY); <br>        fRespondedToUser = TRUE; <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if (dwDirection == 0) <br>    { <br>        fprintf(stderr, "ERROR: no action specified; " <br>            "please specify /%s, /%s or /%s.\n",  <br>            ARG_IMPORT, ARG_EXPORT, ARG_BOTH); <br>        fRespondedToUser = TRUE; <br>        hr = HR_LOG(E_FAIL); <br> <br>        // Don't give any more messages if they didn't specify an action. <br> <br>        goto cleanup; <br>    } <br> <br>    if (*szDSA == 0) <br>    { <br>        fprintf(stderr, "ERROR: please specify /%s\n", ARG_DSA); <br>        fRespondedToUser = TRUE; <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    if (*szBasePoint == 0) <br>    { <br>        fprintf(stderr, "ERROR: please specify /%s\n", ARG_BASEPOINT); <br>        fRespondedToUser = TRUE; <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    if (*szContainer == 0) <br>    { <br>        fprintf(stderr, "ERROR: please specify /%s\n", ARG_CONTAINER); <br>        fRespondedToUser = TRUE; <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    if (dwDirection &amp; DIRECTION_EXPORT) <br>    { <br>        if (*szExportFile == 0) <br>        { <br>            fprintf(stderr, "ERROR: please specify /%s\n", ARG_EXPFILE); <br>            fRespondedToUser = TRUE; <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    if (dwDirection &amp; DIRECTION_IMPORT) <br>    { <br>        if (*szImportFile == 0) <br>        { <br>            fprintf(stderr, "ERROR: please specify /%s\n", ARG_IMPFILE); <br>            fRespondedToUser = TRUE; <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrDoExport----------------------------------------------------------------- <br>//  Export to a file all objects in the DIT with USN &gt; dwLastUSN.  After each  <br>//  exported object, update dwLastUSN and write the updated copy to the  <br>//  registry. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDoExport(void)             // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    HRESULT             hrT                 = NOERROR; <br>    BEXPORT_PARMS       BExportParms        = {0}; <br>    DAPI_ENTRY          AttributesEntry     = {0}; <br>    ATT_VALUE           AttributesValue     = {0}; <br>    LPBEXPORT_PARMS     bp                  = &amp;BExportParms; <br>    LPTSTR              pszExportListCopy   = NULL; <br>    DWORD               i                   = 0; <br>    LPTSTR              pszObjClass         = NULL; <br>    BOOL                fExportOpened       = FALSE; <br> <br>    DEBUGPRIVATE("HrDoExport()\n"); <br> <br>    // Allocate a copy of the export list, and add the attributes we need if  <br>    // the user didn't include them.  We are allowing 200 bytes to add the  <br>    // extra attributes. <br> <br>    hr = MAPIAllocateBuffer(strlen(szExportList) + 200, &amp;pszExportListCopy); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_ERROR,  <br>            0,  <br>            1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    // DAPI requires that there be exactly one "Obj-Class", and that it  <br>    // be the first attribute in the list.  So, we must add it to the front  <br>    // of the string and then remove it from anywhere else. <br> <br>    // Begin the copy string with "Obj-Class," + the user's export list. <br> <br>    strcpy(pszExportListCopy, OBJ_CLASS ","); <br>    strcat(pszExportListCopy, szExportList); <br> <br>    // Search the resulting string for any instances of "Obj-Class" besides  <br>    // the one we just added to the front.  If we find any, remove them by  <br>    // overwriting them with spaces.  The spaces and extra commas will be  <br>    // cleaned up later when we call CleanupAttributeList(). <br> <br>    pszObjClass = pszExportListCopy + 1; <br>    while (fFindAttributeInList(OBJ_CLASS, pszObjClass, &amp;pszObjClass)) <br>    { <br>        _strnset(pszObjClass, ' ', strlen(OBJ_CLASS)); <br>    } <br> <br>    // Now add USN-Created, USN-Changed, Is-Deleted, Obj-Dist-Name  <br>    // and Imported-From to the string if they aren't already there. <br> <br>    if (!fFindAttributeInList(USN_CREATED, pszExportListCopy, NULL)) <br>    { <br>        strcat(pszExportListCopy, "," USN_CREATED); <br>    } <br> <br>    if (!fFindAttributeInList(USN_CHANGED, pszExportListCopy, NULL)) <br>    { <br>        strcat(pszExportListCopy, "," USN_CHANGED); <br>    } <br> <br>    if (!fFindAttributeInList(IS_DELETED, pszExportListCopy, NULL)) <br>    { <br>        strcat(pszExportListCopy, "," IS_DELETED); <br>    } <br> <br>    if (!fFindAttributeInList(OBJ_DIST_NAME, pszExportListCopy, NULL)) <br>    { <br>        strcat(pszExportListCopy, "," OBJ_DIST_NAME); <br>    } <br> <br>    if (!fFindAttributeInList(IMPORTED_FROM, pszExportListCopy, NULL)) <br>    { <br>        strcat(pszExportListCopy, "," IMPORTED_FROM); <br>    } <br> <br>    // Finally, get rid of extra spaces and commas in the string. <br> <br>    CleanupAttributeList(pszExportListCopy); <br> <br>    // Set up the structure that defines how to do the export. <br> <br>    bp-&gt;dwDAPISignature = DAPI_SIGNATURE; <br>    bp-&gt;dwFlags =  <br>        DAPI_SUPPRESS_COMPLETION |  <br>        DAPI_EVENT_ALL |  <br>        DAPI_EXPORT_MAILBOX |  <br>        DAPI_EXPORT_HIDDEN; <br>    if (!fProgressDialog) <br>    { <br>        bp-&gt;dwFlags |= DAPI_SUPPRESS_PROGRESS; <br>    } <br>    if (fSubs) <br>    { <br>        bp-&gt;dwFlags |= DAPI_EXPORT_SUBTREE; <br>    } <br> <br>    // If they set the full export flag then get all USN's. <br> <br>    if (fFullExport) <br>    { <br>        dwLastUSN = 0; <br>    } <br> <br>    // If they didn't explicitly set the full export flag but the  <br>    // starting USN is 0, then set the full export flag.  This lets  <br>    // us treat the first running of an incremental export the same  <br>    // as a full export, so we won't get Delete records exported. <br> <br>    else if (dwLastUSN == 0) <br>    { <br>        fFullExport = TRUE; <br>    } <br> <br>    // Only get USN's greater than what we got last time. <br> <br>    if (dwLastUSN) <br>    { <br>        bp-&gt;ulUSNBase = dwLastUSN + 1; <br>    } <br> <br>    // Store the starting USN value so we use it to distinguish  <br>    // adds from modifies and other things like that. <br> <br>    dwStartingUSN = bp-&gt;ulUSNBase; <br> <br>    // Fill in the rest of the structure. <br> <br>    bp-&gt;pszHomeServer = szServer; <br>    bp-&gt;pszDSAName = szDSA; <br>    bp-&gt;pszBasePoint = szBasePoint; <br>    bp-&gt;pszContainer = szContainer; <br>    bp-&gt;chColSep = DAPI_DEFAULT_DELIM; <br>    bp-&gt;chQuote = DAPI_DEFAULT_QUOTE; <br>    bp-&gt;chMVSep = DAPI_DEFAULT_MV_SEP; <br>    bp-&gt;ExportCallback.pfnExportEntry = fExportCallback; <br>    bp-&gt;ExportCallback.ulEvalTag = TEXT_VALUE_ARRAY; <br>    bp-&gt;pszExportFile = szExportFile; <br>    bp-&gt;pAttributes = &amp;AttributesEntry; <br> <br>    AttributesEntry.unAttributes = 1; <br>    AttributesEntry.ulEvalTag = TEXT_LINE; <br>    AttributesEntry.rgEntryValues = &amp;AttributesValue; <br> <br>    AttributesValue.DapiType = DAPI_TEXT; <br>    AttributesValue.Value.pszValue = pszExportListCopy; <br>    AttributesValue.size = lstrlen(pszExportListCopy); <br> <br>    // Call foreign system open export routine. <br> <br>    hr = HrOpenExport(szExportFile); <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br>    fExportOpened = TRUE; <br> <br>    // Export the records (call fExportCallback for each one). <br> <br>    fErrorInCallback = FALSE; <br>    cDAPILoggedErrors += BatchExport(bp); <br> <br>    if (cDAPILoggedErrors || fErrorInCallback) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Call foreign system close export routine. <br> <br>    fExportOpened = FALSE; <br>    hr = HrCloseExport(); <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // If we are doing an incremental export then clear the imported  <br>    // objects list. <br> <br>    if (!fFullExport) <br>    { <br>        cdwImportedObjectList = 0; <br>    } <br> <br>    // Update the state data in the registry (if we are using the registry). <br> <br>    if (dwSettingsSource != SOURCE_COMMAND_LINE) <br>    { <br>        hr = HrWriteStateData(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // Log success event. <br> <br>    switch (dwSettingsSource) <br>    { <br>        case SOURCE_INSTANCE: <br>            EventLogMsg( <br>                DIRSYNC_EXPORT_SUCCEEDED_INSTANCE,  <br>                1, szInstanceName,  <br>                0); <br>            break; <br> <br>        case SOURCE_KEY: <br>            EventLogMsg( <br>                DIRSYNC_EXPORT_SUCCEEDED_KEY,  <br>                1, szKey,  <br>                0); <br>            break; <br> <br>        default: <br>        case SOURCE_COMMAND_LINE: <br>            EventLogMsg( <br>                DIRSYNC_EXPORT_SUCCEEDED,  <br>                0,  <br>                0); <br>            break; <br>    } <br> <br>cleanup: <br>    // Call foreign system close export routine if it's open. <br> <br>    if (fExportOpened) <br>    { <br>        (void) HrCloseExport(); <br>    } <br> <br>    // Free the copy of the attribute list. <br> <br>    MAPIFREEBUFFER(pszExportListCopy); <br> <br>    // Free the allocated memory for the attribute names. <br> <br>    MAPIFREEBUFFER(rgdsAttributes); <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--fExportCallback------------------------------------------------------------ <br>//  Callback function called by DAPI first to give the list of attributes,  <br>//  then once for each record being exported. <br>// ----------------------------------------------------------------------------- <br>static BOOL PASCAL fExportCallback(         // RETURNS: TRUE=continue, FALSE=stop <br>    IN EXP_TYPE ExportDataType,             // tells whether header or data <br>    IN LPVOID lpvAppDefined,                // the user's context <br>    IN PDAPI_ENTRY pDAPIEntry)              // array of attribute data <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPRIVATE("fExportCallback()\n"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_fExportCallback( <br>        ExportDataType,  <br>        lpvAppDefined,  <br>        pDAPIEntry); <br>    if (FAILED(hr)) <br>        return(FALSE); <br> <br>    switch (ExportDataType) <br>    { <br>        // Called at start of export operation <br> <br>        case EXPORT_HEADER: <br>            hr = HrProcessExportHeader(pDAPIEntry); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>            break; <br> <br>        // Called for each exported record. <br> <br>        case EXPORT_ENTRY: <br>            hr = HrProcessExportEntry(pDAPIEntry); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>            break; <br> <br>        // Unknown ExportDataType. <br> <br>        default: <br>            EventLogMsg( <br>                DIRSYNC_INTERNAL_ERROR,  <br>                0,  <br>                0); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>    } <br> <br>cleanup: <br>    if (FAILED(hr)) <br>    { <br>        fErrorInCallback = TRUE; <br>    } <br> <br>    return(SUCCEEDED(hr)); </code></pre>
<p>
</p>
<pre><code>} <br> <br> <br> <br>//$--HrProcessExportHeader------------------------------------------------------ <br>//  Function that takes the export header and uses it to save away an allocated  <br>//  array of attribute names.  It also locates certain attributes needed for  <br>//  processing of the records. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrProcessExportHeader(       // RETURNS: HRESULT <br>    IN PDAPI_ENTRY pEntry)                  // record to export <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    DWORD               i                   = 0; <br> <br>    DEBUGPRIVATE("fProcessExportHeader()\n"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_HrProcessExportHeader(pEntry); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Get the number of attribute name strings. <br> <br>    cdsAttributes = pEntry-&gt;unAttributes; <br> <br>    // Allocate space for an array of structures representing the attributes  <br>    // that are being sent to us via DAPI callback. <br> <br>    hr = MAPIAllocateBuffer( <br>        cdsAttributes * sizeof(*rgdsAttributes),  <br>        &amp;rgdsAttributes); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_ERROR,  <br>            0,  <br>            1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    ZeroMemory(rgdsAttributes, cdsAttributes * sizeof(*rgdsAttributes)); <br> <br>    // Loop to make allocated copies of each attribute name and store them  <br>    // in the array of structures.  Look up each attribute name to see if  <br>    // the user requested it on the command line, and if so, set the flag. <br>    // Also, search for the attributes USN-Created, USN-Changed, Is-Deleted  <br>    // and Obj-Dist-Name and store away their offsets in the array. <br> <br>    iUSNCreatedAttribute = -1; <br>    iUSNChangedAttribute = -1; <br>    iIsDeletedAttribute = -1; <br>    iObjDistNameAttribute = -1; <br>    iImportedFromAttribute = -1; <br> <br>    for  (i = 0; i &lt; cdsAttributes; i++) <br>    { <br>        // Allocate a copy of the attribute name string. <br> <br>        hr = MAPIAllocateMore( <br>            strlen(pEntry-&gt;rgEntryValues[i].Value.pszValue) + 1,  <br>            rgdsAttributes,  <br>            &amp;rgdsAttributes[i].pszName); <br>        if (FAILED(hr)) <br>        { <br>            EventLogMsg( <br>                DIRSYNC_ERROR,  <br>                0,  <br>                1, ERROR_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br> <br>        strcpy( <br>            rgdsAttributes[i].pszName,  <br>            pEntry-&gt;rgEntryValues[i].Value.pszValue); <br> <br>        // See if it's one of the special ones we're looking for. <br> <br>        if (!_stricmp(rgdsAttributes[i].pszName, USN_CREATED)) <br>        { <br>            iUSNCreatedAttribute = i; <br>        } <br>        else if (!_stricmp(rgdsAttributes[i].pszName, USN_CHANGED)) <br>        { <br>            iUSNChangedAttribute = i; <br>        } <br>        else if (!_stricmp(rgdsAttributes[i].pszName, IS_DELETED)) <br>        { <br>            iIsDeletedAttribute = i; <br>        } <br>        else if (!_stricmp(rgdsAttributes[i].pszName, OBJ_DIST_NAME)) <br>        { <br>            iObjDistNameAttribute = i; <br>        } <br>        else if (!_stricmp(rgdsAttributes[i].pszName, IMPORTED_FROM)) <br>        { <br>            iImportedFromAttribute = i; <br>        } <br> <br>        // See if it was in the user's original request. <br> <br>        if (fFindAttributeInList(rgdsAttributes[i].pszName, szExportList, NULL)) <br>        { <br>            rgdsAttributes[i].fRequested = TRUE; <br>        } <br>    } <br> <br>    // If we didn't find all the attributes we were looking for then  <br>    // that's an error and we can't continue. <br> <br>    if (iUSNCreatedAttribute == -1 ||  <br>        iUSNChangedAttribute == -1 ||  <br>        iIsDeletedAttribute == -1 ||  <br>        iObjDistNameAttribute == -1 ||  <br>        iImportedFromAttribute == -1) <br>    { <br>        EventLogMsg( <br>            DIRSYNC_INTERNAL_ERROR,  <br>            0,  <br>            0); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    // In case of error, free all the allocated memory. <br> <br>    if (FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(rgdsAttributes); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrProcessExportEntry------------------------------------------------------- <br>//  Function to process an export entry.  This routine decides whether or not  <br>//  to write the entry, and whether it should be written as an Add, Modify, or  <br>//  Delete. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrProcessExportEntry(        // RETURNS: HRESULT <br>    IN PDAPI_ENTRY pDAPIEntry)              // array of attribute data <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    PATT_VALUE          pav                 = NULL; <br> <br>    DWORD               dwUSNCreated        = 0; <br>    DWORD               dwUSNChanged        = 0; <br>    BOOL                fIsDeleted          = FALSE; <br> <br>    BOOL                fExport             = FALSE; <br>    DIR_SYNC_OPERATION  eOperation          = OPERATION_ADD; <br> <br>    DEBUGPRIVATE("HrProcessExportEntry()\n"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_HrProcessExportEntry(pDAPIEntry); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Get USN-Created, USN-Changed, and Is-Deleted for this object. <br> <br>    pav = &amp;pDAPIEntry-&gt;rgEntryValues[iUSNCreatedAttribute]; <br>    if (pav-&gt;DapiType != DAPI_NO_VALUE) <br>    { <br>        dwUSNCreated = atol(pav-&gt;Value.pszValue); <br>    } <br> <br>    pav = &amp;pDAPIEntry-&gt;rgEntryValues[iUSNChangedAttribute]; <br>    if (pav-&gt;DapiType != DAPI_NO_VALUE) <br>    { <br>        dwUSNChanged = atol(pav-&gt;Value.pszValue); <br>    } <br> <br>    pav = &amp;pDAPIEntry-&gt;rgEntryValues[iIsDeletedAttribute]; <br>    if (pav-&gt;DapiType != DAPI_NO_VALUE &amp;&amp; atol(pav-&gt;Value.pszValue)) <br>    { <br>        fIsDeleted = TRUE; <br>    } <br> <br>    // Decide whether to export this record, and whether the operation  <br>    // is Add, Modify or Delete. <br> <br>    if (dwUSNChanged &gt;= dwStartingUSN) <br>    { <br>        if (fIsDeleted) <br>        { <br>            if (dwUSNCreated &lt; dwStartingUSN &amp;&amp; !fFullExport) <br>            { <br>                fExport = TRUE; <br>                eOperation = OPERATION_DELETE; <br>            } <br>        } <br>        else <br>        { <br>            if (dwUSNCreated &lt; dwStartingUSN) <br>            { <br>                fExport = TRUE; <br>                eOperation = OPERATION_MODIFY; <br>            } <br>            else <br>            { <br>                fExport = TRUE; <br>                eOperation = OPERATION_ADD; <br>            } <br>        } <br>    } <br> <br>    // If this item was imported from the foreign system then  <br>    // don't re-export it. <br> <br>    if (fExport &amp;&amp; cdwImportedObjectList &amp;&amp; bsearch( <br>        &amp;dwUSNChanged,  <br>        rgdwImportedObjectList,  <br>        cdwImportedObjectList,  <br>        sizeof(DWORD),  <br>        nDWORDCompare)) <br>    { <br>        fExport = FALSE; <br>    } <br> <br>    // Export the record. <br> <br>    if (fExport) <br>    { <br>        hr = HrWriteExport( <br>            pDAPIEntry,  <br>            rgdsAttributes,  <br>            pDAPIEntry-&gt;rgEntryValues[iObjDistNameAttribute].Value.pszValue,  <br>            eOperation); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        cObjectsExported++; <br>    } <br> <br>    // If the USN of this record is greater than the highest USN  <br>    // so far, then update the highest USN. <br> <br>    if (dwSettingsSource != SOURCE_COMMAND_LINE &amp;&amp;  <br>        dwUSNChanged &gt; dwLastUSN) <br>    { <br>        dwLastUSN = dwUSNChanged; <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--nDWORDCompare-------------------------------------------------------------- <br>//  Compares two DWORDS and returns n&gt;0, n==0, n&lt;0 depending on which is  <br>//  larger.  This is required for bsearch. <br>// ----------------------------------------------------------------------------- <br>static int __cdecl nDWORDCompare(           // RETURNS: int <br>    const void * pdw1,                      // first element to compare <br>    const void * pdw2)                      // second element to compare <br>{ <br>    return( (*((int *)pdw1)) - (*((int *)pdw2)) ); <br>} <br> <br> <br> <br>//$--fFindAttributeInList------------------------------------------------------- <br>//  Sets *ppszMatch to the address of the first occurance of the attribute  <br>//  name in the attribute list.  This routine can distinguish between a true  <br>//  match and an attribute name that is only a subset of another attribute name. <br>//  Returns TRUE if a match was found, or FALSE if not. <br>//  If ppszMatch is null, the address of the attribute is not returned, but  <br>//  the return value tells whether or not the attribute is present. <br>// ----------------------------------------------------------------------------- <br>static BOOL fFindAttributeInList(           // RETURNS: TRUE if attribute found <br>    IN LPTSTR pszAttributeName,             // name of attribute to search for <br>    IN LPTSTR pszAttributeList,             // list of attributes <br>    OUT LPTSTR * ppszMatch)                 // address of match found (or NULL) <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    BOOL                fReturn             = FALSE; <br>    LPTSTR              psz                 = NULL; <br>    LPTSTR              pszFound            = NULL; <br>    DWORD               cchNameLength       = strlen(pszAttributeName); <br> <br>    DEBUGPRIVATE("fFindAttributeInList()\n"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_fFindAttributeInList( <br>        pszAttributeName,  <br>        pszAttributeList,  <br>        ppszMatch); <br>    if (FAILED(hr)) <br>        return(FALSE); <br> <br>    // Find each occurance of the attribute name in the list. <br> <br>    for (psz = pszAttributeList; *psz; psz++) <br>    { <br>        // If we found the substring,  <br>        // and it is immediately preceeded by either the beginning of the list  <br>        // or a comma,  <br>        // and it is immediately followed by either the end of the list  <br>        // or a comma, <br>        // the we have a true match. <br> <br>        if (!_strnicmp(psz, pszAttributeName, cchNameLength) &amp;&amp;  <br>            (psz == pszAttributeList || *(psz - 1) == ',') &amp;&amp;  <br>            (psz[cchNameLength] == 0 || psz[cchNameLength] == ',')) <br>        { <br>            pszFound = psz; <br>            break; <br>        } <br>    } <br> <br>    if (ppszMatch != NULL) <br>    { <br>        *ppszMatch = pszFound; <br>    } <br> <br>    if (pszFound) <br>    { <br>        fReturn = TRUE; <br>    } <br> <br>    return(fReturn); <br>} <br> <br> <br> <br>//$--CleanupAttributeList------------------------------------------------------- <br>//  Remove white space and extra commas from an attribute list.  Editing is  <br>//  done in place. <br>// ----------------------------------------------------------------------------- <br>static VOID CleanupAttributeList(           // RETURNS: nothing <br>    IN OUT LPTSTR pszAttributeList)         // attribute list to be cleaned up <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    TCHAR *             pSrc                = pszAttributeList; <br>    TCHAR *             pDst                = pszAttributeList; <br> <br>    DEBUGPRIVATE("CleanupAttributeList()\n"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_CleanupAttributeList(pszAttributeList); <br>    if (FAILED(hr)) <br>    { <br>        HR_LOG(hr); <br>        return; <br>    } <br> <br>    // Go through the string and strip out bogus characters. <br> <br>    while (*pSrc) <br>    { <br>        // If this char is white space, or a comma at the beginning of the  <br>        // string, or a double comma then strip it out. <br> <br>        if (isspace(*pSrc) || (*pSrc == ',' &amp;&amp; pDst == pszAttributeList) ||  <br>            (*pSrc == ',' &amp;&amp; pDst &gt; pszAttributeList &amp;&amp; *(pDst - 1) == ',')) <br>        { <br>            pSrc++; <br>        } <br> <br>        // Otherwise copy it over. <br> <br>        else <br>        { <br>            *pDst++ = *pSrc++; <br>        } <br>    } <br> <br>    // If there's an extra comma at the end then get rid of it. <br> <br>    if (pDst &gt; pszAttributeList &amp;&amp; *(pDst - 1) == ',') <br>    { <br>        --pDst; <br>    } <br> <br>    // Null terminate the destination string. <br> <br>    *pDst = 0; <br>} <br> <br> <br> <br>//$--HrDoImport----------------------------------------------------------------- <br>//  Import objects from a file. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDoImport(void)             // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DAPI_PARMS          sDAPIParms          = {0}; <br>    DAPI_HANDLE         hDAPISession        = NULL; <br>    PDAPI_EVENT         pDAPIEvent          = NULL; <br>    PDAPI_EVENT         pde                 = NULL; <br> <br>    PDAPI_ENTRY         pAttributes         = NULL; <br>    PDAPI_ENTRY         pValues             = NULL; <br> <br>    DIR_SYNC_OPERATION  eOperation          = 0; <br>    DWORD               dwWriteFlags        = 0; <br>    ULONG               ulNewUSN            = 0; <br> <br>    BOOL                fImportOpened       = FALSE; <br>    BOOL                fDAPIInitialized    = FALSE; <br>    HANDLE              hDAPIEventSource    = NULL; <br> <br>    CHAR                szTemp1[20]         = {0}; <br> <br>    DEBUGPRIVATE("rcDoImport()\n"); <br> <br>    // Log that we are beginning the import operation. <br> <br>    switch (dwSettingsSource) <br>    { <br>        case SOURCE_INSTANCE: <br>            EventLogMsg( <br>                DIRSYNC_BEGIN_IMPORT_INSTANCE,  <br>                2, szDSA, szInstanceName,  <br>                0); <br>            break; <br> <br>        case SOURCE_KEY: <br>            EventLogMsg( <br>                DIRSYNC_BEGIN_IMPORT_KEY,  <br>                2, szDSA, szKey,  <br>                0); <br>            break; <br> <br>        default: <br>        case SOURCE_COMMAND_LINE: <br>            EventLogMsg( <br>                DIRSYNC_BEGIN_IMPORT,  <br>                1, szDSA,  <br>                0); <br>            break; <br>    } <br> <br>    // Reset to count of objects imported. <br> <br>    cObjectsImported = 0; <br> <br>    // Get handle to report DAPI events. <br> <br>    hDAPIEventSource = RegisterEventSource(NULL, TEXT("Directory Import")); <br>    if (hDAPIEventSource == NULL) <br>    { <br>        // Log a warning. <br> <br>        EventLogMsg( <br>            DIRSYNC_CANNOT_REGISTER_DAPI_EVENT_SOURCE,  <br>            0,  <br>            1, GetLastError()); <br>    } <br> <br>    // Initialize DAPI. <br> <br>    sDAPIParms.dwDAPISignature = DAPI_SIGNATURE; <br>    sDAPIParms.pszDSAName = szDSA; <br>    if (fNTCreate) <br>    { <br>        sDAPIParms.dwFlags |= DAPI_CREATE_NT_ACCOUNT; <br>    } <br>    if (fNTDelete) <br>    { <br>        sDAPIParms.dwFlags |= DAPI_DELETE_NT_ACCOUNT; <br>    } <br> <br>    pDAPIEvent = DAPIStart( <br>        &amp;hDAPISession,  <br>        &amp;sDAPIParms); <br>    if (pDAPIEvent) <br>    { <br>        if (hDAPIEventSource) <br>        { <br>            for (pde = pDAPIEvent; pde; pde = pde-&gt;pNextEvent) <br>            { <br>                (void) ReportEvent( <br>                    hDAPIEventSource,  <br>                    (WORD)EVENTLOG_ERROR_TYPE,  <br>                    0,  <br>                    pde-&gt;dwDAPIError,  <br>                    NULL,  <br>                    (WORD)pde-&gt;unSubst,  <br>                    0,  <br>                    pde-&gt;rgpszSubst,  <br>                    NULL); <br>                ++cDAPILoggedErrors; <br>            } <br>        } <br>        DAPIFreeMemory(pDAPIEvent); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br>    fDAPIInitialized = TRUE; <br> <br>    // Call foreign system open import routine. <br> <br>    hr = HrOpenImport( <br>        szImportFile,  <br>        szObjClass,  <br>        szSourceStamp,  <br>        szBasePoint,  <br>        szContainer,  <br>        szHomeServer); <br>    if (FAILED(hr)) <br>        goto cleanup; <br>    fImportOpened = TRUE; <br> <br>    // Loop for each record in the file. <br> <br>    while (TRUE) <br>    { <br>        // Import a record. <br> <br>        hr = HrReadImport( <br>            &amp;eOperation,  <br>            &amp;pAttributes,  <br>            &amp;pValues); <br>        if (FAILED(hr)) <br>        { <br>            // If end of file then we're done (no error). <br> <br>            if (hr == EDK_E_END_OF_FILE) <br>            { <br>                hr = NOERROR; <br>                break; <br>            } <br>            goto cleanup; <br>        } <br> <br>        // Reset write flags for this loop iteration. <br> <br>        dwWriteFlags = 0; <br> <br>        // Set the flags based on the type of operation. <br> <br>        switch (eOperation) <br>        { <br>            case OPERATION_ADD: <br>                dwWriteFlags |= DAPI_WRITE_CREATE; <br>                break; <br> <br>            case OPERATION_MODIFY: <br>                dwWriteFlags |= DAPI_WRITE_UPDATE; <br>                if (!fMVAppend) <br>                { <br>                    dwWriteFlags |= DAPI_MODIFY_REPLACE_PROPERTIES; <br>                } <br>                break; <br> <br>            case OPERATION_DELETE: <br>                dwWriteFlags |= DAPI_WRITE_DELETE; <br>                break; <br> <br>            default: <br>                EventLogMsg( <br>                    DIRSYNC_INTERNAL_ERROR,  <br>                    0,  <br>                    0); <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>        } <br> <br>        // Write the record to the DSA. <br>        // (NOTE: DAPIWrite may return events even if it was successful. <br>        // The true indicator of a successful write is that a new USN  <br>        // is returned.) <br> <br>        ulNewUSN = 0; <br>        pDAPIEvent = DAPIWrite( <br>            hDAPISession,  <br>            dwWriteFlags,  <br>            pAttributes,  <br>            pValues,  <br>            &amp;ulNewUSN,  <br>            NULL,  <br>            NULL); <br> <br>        // Log any events returned by DAPIWrite. <br> <br>        if (pDAPIEvent) <br>        { <br>            if (hDAPIEventSource) <br>            { <br>                for (pde = pDAPIEvent; pde; pde = pde-&gt;pNextEvent) <br>                { <br>                    (void) ReportEvent( <br>                        hDAPIEventSource,  <br>                        (WORD)EVENTLOG_ERROR_TYPE,  <br>                        0,  <br>                        pde-&gt;dwDAPIError,  <br>                        NULL,  <br>                        (WORD)pde-&gt;unSubst,  <br>                        0,  <br>                        pde-&gt;rgpszSubst,  <br>                        NULL); <br>                    ++cDAPILoggedErrors; <br>                } <br>            } <br>            DAPIFreeMemory(pDAPIEvent); <br>        } <br> <br>        // If DAPIWrite succeeded... <br> <br>        if (ulNewUSN != 0) <br>        { <br>            // Count this object as succesfully imported. <br> <br>            cObjectsImported++; <br> <br>            // Expand the imported object list list if it's full. <br> <br>            if (cdwImportedObjectList &gt;= cdwMaxImportedObjectList) <br>            { <br>                LPDWORD rgdwNew = NULL; <br>                DWORD cdwNew =  <br>                cdwMaxImportedObjectList + IMPORTED_OBJECT_LIST_GROWTH_SIZE; <br> <br>                // Allocate the new memory. <br> <br>                hr = MAPIAllocateBuffer( <br>                    cdwNew * sizeof(DWORD),  <br>                    &amp;rgdwNew); <br>                if (FAILED(hr)) <br>                { <br>                    EventLogMsg( <br>                        DIRSYNC_ERROR,  <br>                        0,  <br>                        1, ERROR_OUTOFMEMORY); <br>                    goto cleanup; <br>                } <br> <br>                // Copy the data from the old memory to the new. <br> <br>                if (cdwImportedObjectList &amp;&amp; rgdwImportedObjectList) <br>                { <br>                    CopyMemory( <br>                        rgdwNew,  <br>                        rgdwImportedObjectList,  <br>                        cdwImportedObjectList * sizeof(DWORD)); <br>                } <br> <br>                // Free the old memory. <br> <br>                MAPIFREEBUFFER(rgdwImportedObjectList); <br> <br>                // Replace the old memory pointer with the new. <br> <br>                rgdwImportedObjectList = rgdwNew; <br>                cdwMaxImportedObjectList = cdwNew; <br>            } <br> <br>            // Add the USN of the record we wrote to the imported object list. <br> <br>            rgdwImportedObjectList[cdwImportedObjectList++] = ulNewUSN; <br>        } <br> <br>        // Free the structures that were returned from HrReadImport(). <br> <br>        MAPIFREEBUFFER(pAttributes); <br>        MAPIFREEBUFFER(pValues); <br>    } <br> <br>    // Update the state data in the registry. <br> <br>    if (dwSettingsSource != SOURCE_COMMAND_LINE) <br>    { <br>        hr = HrWriteStateData(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // Call foreign system close import routine. <br> <br>    fImportOpened = FALSE; <br>    hr = HrCloseImport(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    // Log the number of objects imported. <br> <br>    switch (dwSettingsSource) <br>    { <br>        case SOURCE_INSTANCE: <br>            EventLogMsg( <br>                DIRSYNC_END_IMPORT_INSTANCE,  <br>                3, _itoa(cObjectsImported,szTemp1,10), szDSA, szInstanceName,  <br>                0); <br>            break; <br> <br>        case SOURCE_KEY: <br>            EventLogMsg( <br>                DIRSYNC_END_IMPORT_KEY,  <br>                3, _itoa(cObjectsImported,szTemp1,10), szDSA, szKey,  <br>                0); <br>            break; <br> <br>        default: <br>        case SOURCE_COMMAND_LINE: <br>            EventLogMsg( <br>                DIRSYNC_END_IMPORT,  <br>                2, _itoa(cObjectsImported,szTemp1,10), szDSA,  <br>                0); <br>            break; <br>    } <br> <br>    // Free any leftover memory structures. <br> <br>    MAPIFREEBUFFER(pAttributes); <br>    MAPIFREEBUFFER(pValues); <br> <br>    // Call foreign system close import routine if it's open. <br> <br>    if (fImportOpened) <br>    { <br>        (void) HrCloseImport(); <br>    } <br> <br>    // De-Initialize DAPI. <br> <br>    if (fDAPIInitialized) <br>    { <br>        DAPIEnd(&amp;hDAPISession); <br>    } <br> <br>    // Close DAPI event logging. <br> <br>    CLOSEHANDLE(hDAPIEventSource); <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadRegistryVariables---------------------------------------------------- <br>//  Read a group of registry values into variables as defined by the array of  <br>//  REG_VARIABLE structures. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadRegistryVariables(     // RETURNS: HRESULT <br>    IN      HANDLE          hRegistryKey,   // handle of reg key to read from <br>    IN      LPTSTR          pszRegistryKey, // name of registry key to read from <br>    IN      DWORD           cVariables,     // number of values to read <br>    IN OUT  LPREG_VARIABLE  rgrvVariables)  // array of structures that map  <br>                                            // values to variables <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    DWORD               iVariable           = 0; <br>    DWORD               dwType              = 0; <br> <br>    DEBUGPRIVATE("HrReadRegistryVariables()\n"); <br> <br>    hr = CHK_HrReadWriteRegistryVariables( <br>        hRegistryKey,  <br>        pszRegistryKey,  <br>        cVariables,  <br>        rgrvVariables); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    if (dwSettingsSource != SOURCE_COMMAND_LINE) <br>    { <br>        for (iVariable = 0; iVariable &lt; cVariables; iVariable++) <br>        { <br>            hr = RegQueryValueEx( <br>                hRegistryKey,  <br>                rgrvVariables[iVariable].pszValueName,  <br>                NULL,  <br>                &amp;dwType,  <br>                rgrvVariables[iVariable].pbData,  <br>                &amp;rgrvVariables[iVariable].cbData); <br>            if (hr == ERROR_FILE_NOT_FOUND) <br>            { <br>                hr = NOERROR; <br>            } <br>            else if (FAILED(hr) || rgrvVariables[iVariable].dwType != dwType) <br>            { <br>                EventLogMsg( <br>                    DIRSYNC_CANNOT_READ_REGISTRY_VALUE,  <br>                    2, rgrvVariables[iVariable].pszValueName, pszRegistryKey,  <br>                    1, hr); <br>                goto cleanup; <br>            } <br>            else if (dwType == REG_SZ) <br>            { <br>                LPTSTR psz = rgrvVariables[iVariable].pbData; <br>                DWORD cch = rgrvVariables[iVariable].cbData / sizeof(TCHAR); <br>                psz[cch] = 0; <br>            } <br>        } <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrWriteRegistryVariables--------------------------------------------------- <br>//  Write a group of variables to a registry key, as defined by the array of  <br>//  REG_VARIABLE structures. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrWriteRegistryVariables(    // RETURNS: HRESULT <br>    IN      HANDLE          hRegistryKey,   // handle of reg key to write to <br>    IN      LPTSTR          pszRegistryKey, // name of registry key to write to <br>    IN      DWORD           cVariables,     // number of values to write <br>    IN OUT  LPREG_VARIABLE  rgrvVariables)  // array of structures that map  <br>                                            // values to variables <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    DWORD               iVariable           = 0; <br>    DWORD               cbData              = 0; <br> <br>    DEBUGPRIVATE("HrWriteRegistryVariables()\n"); <br> <br>    hr = CHK_HrReadWriteRegistryVariables( <br>        hRegistryKey,  <br>        pszRegistryKey,  <br>        cVariables,  <br>        rgrvVariables); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    if (dwSettingsSource != SOURCE_COMMAND_LINE) <br>    { <br>        for (iVariable = 0; iVariable &lt; cVariables; iVariable++) <br>        { <br>            switch (rgrvVariables[iVariable].dwType) <br>            { <br>                case REG_SZ: <br>                    cbData = strlen(rgrvVariables[iVariable].pbData); <br>                    break; <br> <br>                default: <br>                    cbData = rgrvVariables[iVariable].cbData; <br>                    break; <br>            } <br> <br>            hr = RegSetValueEx( <br>                hRegistryKey,  <br>                rgrvVariables[iVariable].pszValueName,  <br>                0,  <br>                rgrvVariables[iVariable].dwType,  <br>                rgrvVariables[iVariable].pbData,  <br>                cbData); <br>            if (FAILED(hr)) <br>            { <br>                EventLogMsg( <br>                    DIRSYNC_CANNOT_WRITE_REGISTRY_VALUE,  <br>                    2, rgrvVariables[iVariable].pszValueName, pszRegistryKey,  <br>                    1, hr); <br>                goto cleanup; <br>            } <br>        } <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--PrintResults--------------------------------------------------------------- <br>//  Print the results of the directory synchronization operation. <br>//  This routine prints the number of errors and warnings logged,  <br>//  and whether the operation succeeded or failed. <br>// ----------------------------------------------------------------------------- <br>static VOID PrintResults(                   // RETURNS: nothing <br>    IN  HRESULT         hr,                 // result code from operation <br>    IN  BOOL            fEventLogOpen)      // TRUE if EDK event logging is open <br>{ <br>    HRESULT             hrT                 = NOERROR; <br>    EDKEVENTCOUNT       sEventCount         = {0}; <br> <br>    DEBUGPRIVATE("PrintResults()\n"); <br> <br>    if (fEventLogOpen) <br>    { <br>        HRESULT hrT = NOERROR; <br> <br>        hrT = HrEventGetCounts(&amp;sEventCount); <br>        if (FAILED(hrT)) <br>        { <br>            fprintf(stderr,  <br>                "WARNING: unable to get number of errors logged.\n"); <br>        } <br>        else <br>        { <br>            // Add in any errors logged by DAPI. <br> <br>            sEventCount.cError += cDAPILoggedErrors; <br> <br>            // Print the number of errors logged. <br> <br>            if (sEventCount.cError == 1) <br>            { <br>                fprintf(stderr,  <br>                    "ERROR: 1 error written to NT event log.\n"); <br>                fRespondedToUser = TRUE; <br>            } <br>            else if (sEventCount.cError &gt; 1) <br>            { <br>                fprintf(stderr,  <br>                    "ERROR: %d errors written to NT event log.\n",  <br>                    sEventCount.cError); <br>                fRespondedToUser = TRUE; <br>            } <br> <br>            // Print the number of warnings logged. <br> <br>            if (sEventCount.cWarning == 1) <br>            { <br>                fprintf(stderr,  <br>                    "WARNING: 1 warning written to NT event log.\n"); <br>            } <br>            else if (sEventCount.cWarning &gt; 1) <br>            { <br>                fprintf(stderr,  <br>                    "WARNING: %d warnings written to NT event log.\n",  <br>                    sEventCount.cWarning); <br>            } <br>        } <br>    } <br> <br>    if (!fRespondedToUser) <br>    { <br>        if (SUCCEEDED(hr)) <br>        { <br>            fprintf(stderr, "Done.\n"); <br>        } <br>        else <br>        { <br>            fprintf(stderr, "Operation failed.\n"); <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
