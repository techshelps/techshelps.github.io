<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXTDATVW.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1787"></a>EXTDATVW.C</h2>
<pre><code>// ExtDatVw.C ------------------------------------------------------------------ <br>// Functions to process the main extension data viewer property sheet.   <br>// See Admin.H and Admin.C for main handshaking with Exchange Admin. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "retcode.h" <br>#include "admin.h" <br>#include "resource.h" <br>#include "PrValAry.h" <br> <br>//---------------------------------------------------------------------------- <br>// Some of the global data needed by this module.  See end of file for more. <br>//---------------------------------------------------------------------------- <br> <br>HWND    hAdminWnd           = NULL; // Handle to parent window. <br>HWND    hEditExtDataName    = NULL; <br>HWND    hLBView             = NULL; <br>HGLOBAL hEditDlgTemplate    = NULL; <br> <br>BOOL    bExtDataHasChanged  = FALSE; <br> <br>TCHAR   szAdminTitle[100]   = TEXT( "");    // Title of parent window. <br>TCHAR   szExtDataName[100]  = TEXT( ""); <br>TCHAR   szSaveChangesMsg[]  = TEXT( "The extension data has been changed but not saved.  " <br>                                    "Do you wish to save your changes first?\n" <br>                                    "\n" <br>                                    "(press 'Yes' button followed by 'Apply' button to save changes)"); <br>WNDPROC EditCtlWndProc      = NULL; <br> <br>BOOL    bNewExtData         = TRUE; <br> <br>#define PVA_EXPAND_AMT          10      // Amount to expand the array as it grows. <br>PropValArray    pvaExtProps     = {0};  // See PrValAry.H for this data structure. <br>LPSPropValue    lpEditPropVal   = NULL; // Pointer to property to edit. <br> <br>//---------------------------------------------------------------------------- <br>// Dialog procedure for the edit property dialog implemented in EditDlg.C. <br>//---------------------------------------------------------------------------- <br> <br>BOOL CALLBACK EditDialogProc( // RETURNS: TRUE if msg was processed. <br>    IN HWND    hDlg,    // Dialog's window handle. <br>    IN UINT    wMsg,    // Window message to be processed <br>    IN WPARAM  wParam,  // Window message parameter1 <br>    IN LPARAM  lParam);  // Window message parameter2 <br> <br>//---------------------------------------------------------------------------- <br>// These integers control the size of the buffer we allocate for the  <br>// _vsnprintf() function call.  It grows when _vsnprintf() returns an <br>// error.  The effect is that we remember the largest buffer needed for <br>// string formating and always start off by allocating that size of buffer. <br>// This provides a safe string formating method. <br>//---------------------------------------------------------------------------- <br> <br>static int nLargestBuf = 256;   <br>static int nGrowSize = 128; <br> <br>//---------------------------------------------------------------------------- <br>// This performs a safe format with no memory overwrites. <br>// <br>// Takes arguments almost like sprintf().  The exception is that the first <br>// parameter is a pointer to a pointer to a buffer.  We dynamicaly allocate <br>// the buffer to the largest size we have encountered so far and increase it <br>// if needed. <br>//---------------------------------------------------------------------------- <br> <br>HRESULT HrFormat(  <br>    OUT LPTSTR* lppszBuf, // Ptr to ptr to allocated output buffer. <br>    IN  LPTSTR  pFmt,     // Ptr to format string. <br>    ...)                  // Any other parameters needed. <br>{ <br>    HRESULT hr    = NOERROR; <br>    va_list pVArg = {0}; <br> <br>    va_start( pVArg, pFmt); <br> <br>    for( ;;) <br>    {   // Take a shot at formating the string. <br>        hr = MAPIAllocateBuffer( nLargestBuf, lppszBuf); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        if( _vsntprintf( *lppszBuf, nLargestBuf, pFmt, pVArg) &gt;= 0) <br>           break;   // Format was successful. <br>             <br>        // Buffer was not big enough so enlarge it. <br>        nLargestBuf += nGrowSize; <br>        nGrowSize = (int) (nGrowSize * 3 / 2); <br>         <br>        // Free what we are not using so we can reallocate it. <br>        MAPIFREEBUFFER( *lppszBuf); <br>    } <br> <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// This formats the property value into a string buffer that you will have to  <br>// free using MAPIFreeBuffer. <br>// <br>// NOTE: A number of the possible property types don't have a conversion at <br>//       this time. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT HrFormatPrValue(  <br>    IN  LPSPropValue lpPropVal, // Ptr to property to format. <br>    OUT LPTSTR*      lppszBuf)  // Ptr to ptr to allocated output buffer. <br>{ <br>    HRESULT     hr      = NOERROR; <br>    int         ii      = 0; <br>    unsigned    ui      = 0; <br>    double      dbl     = 0; <br>    LPTSTR      lpszBuf = NULL; <br>    LPBYTE      pByte   = NULL;     <br>    SYSTEMTIME  st      = {0}; <br>    __UPV       upv     = lpPropVal-&gt;Value; <br> <br>    switch( PROP_TYPE( lpPropVal-&gt;ulPropTag)) <br>    { <br>        case PT_I2: <br>            ii = upv.i; // Convert short unsigned to regular unsigned. <br>            hr = HrFormat( lppszBuf, "PT_I2\t%d", ii); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_LONG: <br>            hr = HrFormat( lppszBuf, "PT_LONG\t%ld", upv.ul); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_R4: <br>            dbl = upv.flt; <br>            hr = HrFormat( lppszBuf, "PT_R4\t%g", dbl); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_DOUBLE: <br>            hr = HrFormat( lppszBuf, "PT_DOUBLE\t%g", upv.dbl); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_BOOLEAN: <br>            if( upv.b) <br>                hr = HrFormat( lppszBuf, "PT_BOOLEAN\tTRUE"); <br>            else <br>                hr = HrFormat( lppszBuf, "PT_BOOLEAN\tFALSE"); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_SYSTIME: <br>            if( FileTimeToSystemTime( &amp;upv.ft, &amp;st)) <br>                hr = HrFormat( lppszBuf, "PT_SYSTIME\t%.2d:%.2d:%.2d %.2d/%.2d/%.2d", <br>                    st.wHour, st.wMinute, st.wSecond, <br>                    st.wMonth, st.wDay, st.wYear); <br>            else <br>                hr = HrFormat( lppszBuf, "PT_SYSTIME\tError %lu converting file time to system time.", GetLastError()); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_STRING8: <br>            hr = HrFormat( lppszBuf, "PT_STRING8\t%s", upv.lpszA); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_BINARY: <br>            // Format the count and a place holder for up to 400 hex digits. <br>            hr = HrFormat( lppszBuf, "PT_BINARY\tCB:%d 0x%-400s", upv.bin.cb, TEXT( "PlaceHolder")); <br>             <br>            // Make sure we don't format more than 200 bytes (400 hex digits). <br>            if( upv.bin.cb &gt; 200) <br>                ii = 200; <br>            else <br>                ii = upv.bin.cb; <br> <br>            // Find "PlaceHolder" to set the starting point for formating. <br>            lpszBuf = _tcsstr( *lppszBuf, TEXT("PlaceHolder")); <br>             <br>            // Ptr to first byte in binary data to format. <br>            pByte = upv.bin.lpb; <br>             <br>            // Loop to format into hex digits. <br>            while( ii) <br>            {   // Format a single byte into a hex value and add to sRetVal. <br>                ui = *pByte; <br>                sprintf( lpszBuf, "%.2x", ui); <br>                 <br>                // Next byte. <br>                lpszBuf += 2; <br>                pByte ++; <br>                ii --; <br>            } <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_ERROR: <br>        { <br>            hr = HrFormat( lppszBuf, "PT_ERROR\tError %.8lx", upv.err); <br>            break; <br>        } <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        default:  <br>            hr = HrFormat( lppszBuf, "PT_%d\thas no conversion at this time.", PROP_TYPE( lpPropVal-&gt;ulPropTag)); <br>            break; <br>    } <br> <br>    RETURN( hr); <br>} <br> <br>//$--OnRefreshBtnClick()-------------------------------------------------------- <br>// This is called when the refresh button is clicked or the extension data name  <br>// edit control loses focus.  We need to verify that the user has saved changes <br>// before we refresh. <br>// ----------------------------------------------------------------------------- <br> <br>static VOID OnRefreshBtnClick( <br>    IN HWND    hDlg)    // Dialog's window handle. <br>{ <br>    HRESULT         hr          = NOERROR; <br>    ULONG           cExtProps   = 0;      // Count of ext data properties.  <br>    ULONG           iProp       = 0;      // Index to a single property. <br>    int             iSaveChanges= 0;       <br>    LPTSTR          lpszProp    = NULL;   // Formated property type and value for display. <br>    LPSPropValue    lpExtProps  = NULL;   // Ptr to extension data properties. <br> <br>    // If extension data has changed make sure user wants to loose their changes. <br>    if( bExtDataHasChanged) <br>    { <br>        iSaveChanges = MessageBox( hDlg, szSaveChangesMsg, szAdminTitle, MB_YESNO); <br>        if( iSaveChanges == IDYES) <br>            return; // Cancel the REFRESH so user can press the apply button. <br>    } <br> <br>    // At this point we know that data has been saved if it had been altered. <br> <br>    // Get the extension data name from the edit control. <br>    GetDlgItemText( hDlg, IDC_EDIT_EXT_DATA_NAME, szExtDataName, sizeof( szExtDataName)); <br> <br>    // Return if extension data name has not been supplied. <br>    if( szExtDataName[0] == TEXT( '\0')) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Free old property value array. <br>    PVA_Destroy( &amp;pvaExtProps); <br> <br>    // Clear the contents of the listbox. <br>    SendMessage( hLBView, LB_RESETCONTENT, 0, 0); <br> <br>    // Apply could be enabled so use this flag to tell us  <br>    // not to save anything unless it really changes later. <br>    bExtDataHasChanged = FALSE; <br> <br>    // Load the extension data as a property value array.  Ignore any <br>    // errors since they are expected. <br>    hr = HrLoadExtData( hDlg, szExtDataName, &amp;cExtProps, &amp;lpExtProps);    <br>    bNewExtData = FAILED( hr); // We expect this to fail if creating new extension data. <br> <br>    // Initialize the property value array structure. <br>    hr = PVA_HrInit( &amp;pvaExtProps, PVA_EXPAND_AMT, cExtProps, lpExtProps); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Loop to display the property values. <br>    for( iProp = 0; iProp &lt; cExtProps; iProp++) <br>    { <br>        hr = HrFormatPrValue( lpExtProps + iProp, &amp;lpszProp); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        SendMessage( hLBView, LB_ADDSTRING, 0, (LPARAM) lpszProp); <br>        MAPIFREEBUFFER( lpszProp); <br>    } <br>         <br>    // Leave a line at end of list for inserting at end. <br>    SendMessage( hLBView, LB_ADDSTRING, 0, (LPARAM) TEXT( "*** end ***")); <br> <br>cleanup: <br>    if( FAILED( hr)) <br>        SendMessage( hLBView, LB_RESETCONTENT, 0, 0); // Clear the contents of the listbox. <br> <br>    return; <br>} <br> <br>//$--OnWmKillFocus()------------------------------------------------------------ <br>// Handles the kill focus for the extension data name edit control.  We need <br>// to refresh the list box if the user changed the extension data name. <br>// ----------------------------------------------------------------------------- <br> <br>static void OnWmKillFocus( <br>    IN HWND    hWnd,    // Window handle of edit control. <br>    IN WPARAM  wParam,  // Window message parameter1 <br>    IN LPARAM  lParam)  // Window message parameter2 <br>{ <br>    HWND hDlg = NULL; <br> <br>    // If the extension data name has not change there is no need to refresh. <br>    if( szExtDataName[0] != TEXT('\0')) <br>        return;  <br> <br>    // Get the parent dialog handle. <br>    hDlg = GetParent( hWnd); <br> <br>    // Refresh the list box. <br>    OnRefreshBtnClick( hDlg); <br>} <br> <br>//$--EditWindowProc()----------------------------------------------------------- <br>// Window procedure for the edit control. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CALLBACK EditWindowProc( // RETURNS: TRUE if msg was processed. <br>    IN HWND    hWnd,    // Window handle. <br>    IN UINT    wMsg,    // Window message to be processed <br>    IN WPARAM  wParam,  // Window message parameter1 <br>    IN LPARAM  lParam)  // Window message parameter2 <br>{ <br>    switch( wMsg) <br>    { <br>        case WM_KILLFOCUS: <br>            OnWmKillFocus( hWnd, wParam, lParam); <br>            // Intentionaly drop through to also do the default processing. <br> <br>        default: <br>            return( CallWindowProc( EditCtlWndProc, hWnd, wMsg, wParam, lParam)); <br>    } <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Initialize the dialog. <br>// ----------------------------------------------------------------------------- <br> <br>static VOID OnInitDialog( <br>    IN HWND    hDlg)    // Dialog's window handle. <br>{ <br>    int nTabStops[] = {60};    // Array of tab stops. <br> <br>    // Get the parent window handle. <br>    hAdminWnd = GetParent( hDlg); <br> <br>    // Get the parent window title so we can use it in message boxes. <br>    GetWindowText( hAdminWnd, szAdminTitle, sizeof(szAdminTitle)); <br>     <br>    // Tell admin where to find our ICON and TITLE controls so it can display <br>    // the standard picture and text. <br>    pAdminFunctions-&gt;pfnSetIcon( hDlg, IDC_ADMINICON); <br>    pAdminFunctions-&gt;pfnSetTitle( hDlg, IDC_TITLE); <br> <br>    // Get the handle of the extension data name edit control. <br>    hEditExtDataName = GetDlgItem( hDlg, IDC_EDIT_EXT_DATA_NAME); <br>    if( hEditExtDataName == NULL) <br>    { <br>        HR_LOG( E_FAIL); <br>        return; <br>    } <br> <br>    // Subclass the window procedure to capture the kill focus message. <br>    EditCtlWndProc = (WNDPROC) SetWindowLong( hEditExtDataName, GWL_WNDPROC, (LONG) EditWindowProc); <br> <br>    // Get the handle of the list box view control. <br>    hLBView = GetDlgItem( hDlg, IDC_LB_VIEW); <br>    if( hLBView == NULL) <br>    { <br>        HR_LOG( E_FAIL); <br>        return; // Can't use goto since handle is invalid. <br>    } <br> <br>    // Gives us an arbitrarly large amount of room to scroll horizontaly. <br>    SendMessage( hLBView, LB_SETHORIZONTALEXTENT, 4000, 0); <br> <br>    // Set the tab stops. <br>    SendMessage( hLBView, LB_SETTABSTOPS, ARRAY_CNT( nTabStops), (LPARAM) ((int*) nTabStops)); <br>} <br> <br>//$--OnExtDataNameChange()------------------------------------------------------ <br>// When the extension data name is changed this function is called.  We need to <br>// make sure the user has saved changes that may have been made to previous data. <br>// ----------------------------------------------------------------------------- <br> <br>static VOID OnExtDataNameChange( <br>    IN HWND    hDlg)    // Dialog's window handle. <br>{ <br>    static BOOL bRecurse = FALSE;   // Used to avoid recursion  <br>    int iSaveChanges = 0; <br>     <br>    if( !bExtDataHasChanged) <br>        goto cleanup; <br> <br>    if( bRecurse) <br>        goto cleanup; <br>    bRecurse = TRUE; <br> <br>    iSaveChanges = MessageBox( hDlg, szSaveChangesMsg, szAdminTitle, MB_YESNO); <br>    if( iSaveChanges == IDYES) <br>    {   // This causes recursion. <br>        SetDlgItemText( hDlg, IDC_EDIT_EXT_DATA_NAME, szExtDataName); <br>        goto cleanup; <br>    } <br> <br>    // Indicates the extension data to view has changed. <br>    szExtDataName[0] = TEXT( '\0'); <br> <br>    // Indicates the extension data has not changed. <br>    bExtDataHasChanged = FALSE; <br> <br>cleanup:     <br>    bRecurse = FALSE; <br>} <br> <br>//$--HrEditValue()-------------------------------------------------------------- <br>// Supports editing of a property value when either the New or Modify button is  <br>// pressed. <br>// ----------------------------------------------------------------------------- <br> <br>static HRESULT HrEditValue( <br>    IN HWND hDlg,  // Dialog's window handle. <br>    IN BOOL bAdd)  // TRUE if adding a new one. <br>{ <br>    HRESULT hr       = NOERROR; <br>    int     iRet     = 0; <br>    ULONG   ulCurSel = SendMessage( hLBView, LB_GETCURSEL, 0, 0); <br>    LPTSTR  lpszProp = NULL;   // Formated property type and value for display. <br>     <br>    if( ulCurSel == LB_ERR) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Don't let them modify the last item in the list which is only a place holder. <br>    if( !bAdd &amp;&amp; ulCurSel == pvaExtProps.cTotal) <br>        goto cleanup; <br> <br>    // Is this the first time we tried to edit data? <br>    if( !hEditDlgTemplate) <br>    {   // YES, so load and initialize the dialog template. <br>        hr = HrLoadDialogTemplate( IDD_EDIT, &amp;hEditDlgTemplate); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>    } <br> <br>    // Make data to edit available. <br>    if( bAdd) <br>        lpEditPropVal = NULL; <br>    else     <br>        lpEditPropVal = pvaExtProps.lpPropVal + ulCurSel; <br> <br>    // Bring up the dialog to create the data. <br>    iRet = DialogBoxIndirect( hDLLInst, hEditDlgTemplate, hDlg, EditDialogProc); <br>    if( iRet == IDOK) <br>    {   // The user has wants to save his/her changes. <br>        if( !lpEditPropVal) <br>        { <br>            hr = HR_LOG( E_FAIL); <br>            goto cleanup; <br>        } <br>         <br>        // Insert or modify the array. <br>        if( bAdd) <br>            hr = PVA_HrInsert( &amp;pvaExtProps, ulCurSel, lpEditPropVal); <br>        else <br>            hr = PVA_HrModify( &amp;pvaExtProps, ulCurSel, lpEditPropVal); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        // Format the edited data for display in the list box. <br>        hr = HrFormatPrValue( lpEditPropVal, &amp;lpszProp); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        // If modifying an existing one delete it and then reinsert it. <br>        if( !bAdd) <br>            SendMessage( hLBView, LB_DELETESTRING, ulCurSel, 0); <br> <br>        // Insert modified data and set the selection to it. <br>        SendMessage( hLBView, LB_INSERTSTRING, ulCurSel, (LPARAM) lpszProp); <br>        if( bAdd) <br>            ulCurSel ++; <br>        SendMessage( hLBView, LB_SETCURSEL, ulCurSel, 0); <br> <br>        // Free the formated data string. <br>        MAPIFREEBUFFER( lpszProp); <br>         <br>        pAdminFunctions-&gt;pfnInfoHasChanged( hDlg); <br>        bExtDataHasChanged = TRUE; <br>    } <br>    else if( iRet != IDCANCEL) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>//$--OnDeleteBtnClick()--------------------------------------------------------- <br>// Delete a single property value from the array and list box. <br>// ----------------------------------------------------------------------------- <br> <br>static VOID OnDeleteBtnClick( <br>    IN HWND    hDlg)    // Dialog's window handle. <br>{ <br>    HRESULT hr; <br>    ULONG   ulCurSel = SendMessage( hLBView, LB_GETCURSEL, 0, 0); <br>     <br>    if( ulCurSel == LB_ERR) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Don't let them delete the last item in the list which is only a place holder. <br>    if( ulCurSel == pvaExtProps.cTotal) <br>        goto cleanup;    <br> <br>    // Delete the selected item from the array. <br>    hr = PVA_HrDelete( &amp;pvaExtProps, ulCurSel); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Delete the item for the list box and set the selection to the item below it. <br>    SendMessage( hLBView, LB_DELETESTRING, ulCurSel, 0); <br>    SendMessage( hLBView, LB_SETCURSEL, ulCurSel, 0); <br> <br>    pAdminFunctions-&gt;pfnInfoHasChanged( hDlg); <br>    bExtDataHasChanged = TRUE; <br> <br>cleanup:; <br>} <br> <br>//$--OnWmCommand()-------------------------------------------------------------- <br>// Processes a command sent to the dialog box. In this case, commands are sent  <br>// to a dialog box by the controls when the control values have changed or when <br>// a button is pressed. <br>// ----------------------------------------------------------------------------- <br> <br>static BOOL OnWmCommand( <br>    IN HWND    hDlg,    // Dialog's window handle. <br>    IN WPARAM  wParam,  // Window message parameter1 <br>    IN LPARAM  lParam)  // Window message parameter2 <br>{ <br>    HRESULT hr       = NOERROR; <br>    WORD wNotifyCode = HIWORD( wParam);     // Notification code <br>    WORD wID         = LOWORD( wParam);     // Id of control <br>      <br>    // Has an edit control changed or a button been clicked? <br>    if( wNotifyCode == EN_CHANGE || wNotifyCode == BN_CLICKED) <br>    {   // YES, so process the change or click. <br>        switch( wID) <br>        { <br>            case IDC_EDIT_EXT_DATA_NAME: <br>                OnExtDataNameChange( hDlg); <br>                return( TRUE); <br> <br>            case IDC_BTN_REFRESH: <br>                OnRefreshBtnClick( hDlg); <br>                return( TRUE); <br> <br>            case IDC_BTN_ADD: <br>                hr = HrEditValue( hDlg, TRUE); <br>                if( FAILED( hr)); <br>                return( TRUE); <br> <br>            case IDC_BTN_MODIFY: <br>                hr = HrEditValue( hDlg, FALSE); <br>                if( FAILED( hr)); <br>                return( TRUE); <br> <br>            case IDC_BTN_DELETE: <br>                OnDeleteBtnClick( hDlg); <br>                return( TRUE); <br> <br>            default: <br>                return( FALSE); <br>        } <br>    } <br>} <br> <br>//$--DialogProc() -------------------------------------------------------------- <br>// Dialog procedure for the property sheet. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CALLBACK DialogProc( // RETURNS: TRUE if msg was processed. <br>    IN HWND    hDlg,    // Dialog's window handle. <br>    IN UINT    wMsg,    // Window message to be processed <br>    IN WPARAM  wParam,  // Window message parameter1 <br>    IN LPARAM  lParam)  // Window message parameter2 <br>{ <br>    switch( wMsg) <br>    { <br>        case WM_INITDIALOG: <br>            OnInitDialog( hDlg); <br>            return( TRUE); <br> <br>        case WM_COMMAND: <br>            return( OnWmCommand( hDlg, wParam, lParam)); <br> <br>        case WM_CHILDACTIVATE: <br>            if( !bNewExtData) <br>                OnRefreshBtnClick( hDlg); <br>            return( TRUE); <br> <br>        default: <br>            return( FALSE); <br>    } <br>} <br> <br>//$--bSaveData()---------------------------------------------------------------- <br>// Called by Exchange Admin when the property sheet page loses focus.  This is <br>// where all data needs to be saved so that other property sheets can have  <br>// access to it.  Exchange Admin will not commit the data to permanant media <br>// until the OK or APPLY button has been pressed. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bSaveData(   // Returns: TRUE if successful. <br>    IN VOID* pNotUsed,       // Extension data for all sheets <br>    IN HWND  hDlg)           // Window handle of the property sheet. <br>{ <br>    HRESULT hr   = NOERROR; <br>    BOOL    bRet = TRUE; <br> <br>    DEBUGPUBLIC( "bSaveData()\n"); <br>    //if( FAILED( CHK_HrGeneral( pNotUsed, hDlg))) <br>        //return( FALSE); <br> <br>    // If our internal flag tells us that the data has not changed then don't save it. <br>    if( !bExtDataHasChanged) <br>        goto cleanup; <br>             <br>    // Packs the property value array and passes it to Exchange Admin for storage. <br>    hr = HrSaveExtData( hDlg, szExtDataName, pvaExtProps.cTotal,  <br>                        pvaExtProps.lpPropVal, bNewExtData); <br>    if( FAILED( hr)) <br>    { <br>        bRet = FALSE; <br>        goto cleanup; <br>    } <br> <br>    // The data is not new anymore. <br>    bNewExtData = FALSE; <br> <br>    // Indicates the extension data has not changed. <br>    bExtDataHasChanged = FALSE; <br> <br>    // Clear the extension data name (in memory) so it will refresh  <br>    // when we come back to form.  The name will still be on the form <br>    // so we can read it again later. <br>    szExtDataName[0] = TEXT( '\0'); <br> <br>cleanup: <br>    return( bRet); <br>} <br> <br>//$--bCommitData()-------------------------------------------------------------- <br>// This function is called by Exchange Admin when the user presses either the  <br>// OK or the APPLY buttons.  We do not save data here.  We do that in the  <br>// bSaveData() function.  Exchange Admin will commit the data to the data store <br>// if we return TRUE. <br>// <br>// Possible uses of this function are to allow you to display a message telling <br>// the user to restart an application or to save data to another location  <br>// besides the Exchange Admin managed data store. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bCommitData(            // Returns:  TRUE if successful. <br>    IN VOID* pNotUsed,       // Extension data. <br>    IN HWND  hDlg)                  // Handle of the property sheet to be committed. <br>{ <br>    DEBUGPUBLIC( "bCommitData()\n"); <br>    //if( FAILED( CHK_HrGeneral( pNotUsed, hDlg))) <br>        //return( FALSE); <br> <br>    return( TRUE); <br>} <br> <br>//$--bHasHelp()----------------------------------------------------------------- <br>// Called by Exchange Admin to find out if we support help. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bHasHelp(               // RETURNS: true if help is available. <br>    IN VOID* pNotUsed,       // Ext dll managed data area. <br>    IN HWND  hDlg)                  // Window handle of the property sheet. <br>{ <br>    DEBUGPUBLIC( "bHasHelp()\n"); <br>    //if( FAILED( CHK_HrGeneral( pNotUsed, hDlg))) <br>        //return( FALSE); <br> <br>    return( FALSE); <br>} <br> <br>//$--DoHelp()------------------------------------------------------------------- <br>// Called by Exchange Admin to displays help for the user. <br>// ----------------------------------------------------------------------------- <br> <br>VOID PASCAL DoHelp( <br>    IN VOID* pNotUsed,       // Ext dll managed data area. <br>    IN HWND  hDlg)           // Window handle of the property sheet. <br>{ <br>    DEBUGPUBLIC( "DoHelp()\n"); <br>    //if( FAILED( CHK_HrGeneral( pNotUsed, hDlg))) <br>        //return; <br>} <br> <br>//$--DeinitSheet1()------------------------------------------------------------- <br>// This function will be called by the DeinitSheet() function in Admin.C.  If <br>// you were to implement more than one property sheet this function would need <br>// to call a DeinitSheet2() function for the next sheet and so on for each  <br>// additional sheet. <br>// ----------------------------------------------------------------------------- <br> <br>VOID DeinitSheet1() <br>{ <br>    // Destroy the property value array. <br>    PVA_Destroy( &amp;pvaExtProps); <br>     <br>    // If we loaded a dialog template we need to free it. <br>    if( hEditDlgTemplate) <br>        pAdminFunctions-&gt;pfnFreeDialogResource( (LPBYTE*) &amp;hEditDlgTemplate); <br> <br>    // Call other dialog's DeinitSheet functions here. <br>} <br> <br>// ============================================================================= <br>// Globals needed by Admin.C to perform the handshaking with Exchange Admin. <br>// ============================================================================= <br> <br>// ----------------------------------------------------------------------------- <br>// These are pointers to the functions that Exchange Admin will want to access. <br>// ----------------------------------------------------------------------------- <br> <br>ADMIN_ExtensionFunction extensionFunctions = <br>{ <br>    ADMIN_ExtensionAPIVersion, <br>    bInstallExtension,      // Found in Admin.C <br>    bDeinstallExtension,    // Found in Admin.C <br>    bInitSheet,             // Found in Admin.C <br>    bShowPage,              // Found in Admin.C <br>    iStartPage,             // Found in Admin.C <br>    bHasHelp, <br>    DoHelp, <br>    bSaveData, <br>    bCommitData, <br>    DeinitSheet             // Found in Admin.C <br>}; <br> <br>// ----------------------------------------------------------------------------- <br>// This array contains a list of info for one property sheet.  If you were  <br>// writing a DLL that had more than one sheet you would need to provide a list  <br>// of information for each sheet. <br>// ----------------------------------------------------------------------------- <br> <br>ADMIN_SheetInfo rgSheetInfo[] = <br>{ <br>    {   // List of info for a single property sheet. <br>        0,                   // Place holder for instance handle. <br>        IDD_EXT_DATA_VIEWER, // Resource ID of Dialog <br>        &amp;DialogProc,         // DLGPROC      lpfnDlgProc; <br>        IDS_EXT_DATA_VIEWER, // Resource ID of name to place on tag. <br>        0,                   // LPARAM that will be passed to DlgProc on WM_INITDIALOG. <br>        0,                   // Place holder for language ID of dialog to be loaded. <br>    }, <br>    // {More property sheet info could be added here.} <br>}; <br> <br>// Count of property sheets that we implement. (needed by admin.c) <br>int cSheetInfo = ARRAY_CNT( rgSheetInfo); <br> <br>// ----------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
