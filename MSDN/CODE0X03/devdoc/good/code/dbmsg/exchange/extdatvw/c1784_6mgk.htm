<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADMIN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1784"></a>ADMIN.C</h2>
<pre><code>// Admin.C --------------------------------------------------------------------- <br>// Functions to support Exchange Admin Configuration Extension Dialogs for C  <br>// programs.  This does the majority of the handshaking necessary. <br>// (See ExAdmin.CPP for C++ support) <br>// <br>// This module is intended to be a generic MAIN source file for creating an  <br>// Exchange Administration DLL.  You could take this file and include it in your <br>// project as starting place for your DLL. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "retcode.h" <br>#include "admin.h" <br>#include "admin.chk" <br> <br>HINSTANCE hDLLInst  = NULL; <br>BOOL      bReadOnly = FALSE;     // The mode is read only if TRUE. <br> <br>ADMIN_AdministratorFunction* pAdminFunctions;  // Admin functions available to you. <br>ADMIN_ObjectInfo*            pAdminObjectInfo; // Admin server name and other useful DNs. <br> <br>extern BOOL __stdcall _CRT_INIT( HINSTANCE, DWORD, LPVOID); <br> <br>//$--LibMain-------------------------------------------------------------------- <br>// Eported Function. Called when DLL is first loaded.  <br>// ----------------------------------------------------------------------------- <br> <br>BOOL APIENTRY LibMain(        // Returns TRUE if DLL has been initialized. <br>    IN HINSTANCE   hinstDLL,  // Handle to this DLL instance <br>    IN DWORD       dwReason,  // Reason DLL is being initialized. <br>    IN LPVOID      lpContext) // Context (not used)  <br>{ <br>    // Set global instance variable. <br>    hDLLInst = hinstDLL; <br> <br>    // Initialize the C Run Time DLL. <br>    if( dwReason == DLL_PROCESS_ATTACH || dwReason == DLL_THREAD_ATTACH ) <br>    { <br>        if( _CRT_INIT( hinstDLL, dwReason, lpContext) == FALSE) <br>        { <br>            HR_LOG( E_FAIL); <br>            return( FALSE); <br>        } <br>    } <br> <br>    return( TRUE); <br>} <br> <br>//$--bInitSheet()--------------------------------------------------------------- <br>// This function initializes the property sheet info and returns it to admin. <br>//  <br>// Since this piece of code is written to be a generic MAIN source file for <br>// creating an Exchange Administration DLL we use global data defined outside <br>// of this module to contain the information about the property sheet dialogs. <br>// You will need to make sure your code contains the following two globals: <br>// <br>//  1) ADMIN_SheetInfo rgSheetInfo[]                Array of info about your  <br>//                                                  property sheets. <br>// <br>//  2) int cSheetInfo = ARRAY_CNT( rgSheetInfo);    The count of property sheets <br>//                                                  in the array. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bInitSheet(                 // RETURNS: TRUE if initialization OK <br>    IN  ADMIN_ObjectInfo* poi,          // Computer name &amp; DN. <br>    IN  ULONG             fFlags,       // Tells us if it is read only or not.                <br>    OUT ADMIN_SheetInfo** ppSheetInfo,  // Property sheet description array <br>    OUT UINT*             pcsi,         // Number of property sheets <br>    OUT VOID**            ppNotUsed)    // Local data <br>{ <br>    int              iSheet     = 0; <br> <br>    DEBUGPUBLIC( "bInitSheet()\n"); <br>    if( FAILED( CHK_bInitSheet( poi, fFlags, ppSheetInfo, pcsi, ppNotUsed))) <br>        return( FALSE); <br> <br>    // Remember these for later usage. <br>    pAdminObjectInfo = poi; <br>    bReadOnly = (fFlags &amp; fxfReadOnly) &gt; 0; <br> <br>    // Initialize Admin property sheet info array. <br>    for( iSheet = 0; iSheet &lt; cSheetInfo; iSheet++) <br>    {   // Update each array item with info we know about. <br>        rgSheetInfo[ iSheet].hInstance = hDLLInst; <br>        rgSheetInfo[ iSheet].langid = MAKELANGID(LANG_ENGLISH,SUBLANG_NEUTRAL); <br>    } <br> <br>    // Set return values. <br>    *pcsi = cSheetInfo; <br>    *ppSheetInfo = rgSheetInfo; <br>    *ppNotUsed = NULL; <br> <br>    return( TRUE); <br>} <br> <br>//$--DeinitSheet()-------------------------------------------------------------- <br>// Admin calls this when the property sheet dialog box is about to be removed. <br>// ----------------------------------------------------------------------------- <br> <br>void PASCAL DeinitSheet( <br>    IN VOID* pNotUsed)           // Extension data.  <br>{ <br>    DeinitSheet1(); <br>} <br> <br>//$--bInstallExtension()-------------------------------------------------------- <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bInstallExtension(ADMIN_ObjectInfo * poi) <br>{ <br>    return(TRUE); <br>} <br> <br>//$--bDeinstallExtension()------------------------------------------------------ <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bDeinstallExtension(ADMIN_ObjectInfo * poi) <br>{ <br>    return(TRUE); <br>} <br> <br> <br>//$--bShowPage()---------------------------------------------------------------- <br>// This is called once per standard property sheet.  Not at all for our property <br>// sheets.  If you want to disable some or all of the standard property sheets  <br>// then return FALSE for those default property sheets. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bShowPage( UINT iddAdminPage) <br>{ <br>    BOOL bRet = TRUE;   // Show the standard property sheet. <br>    return( bRet); <br>} <br> <br>//$--iStartPage()--------------------------------------------------------------- <br>// This function is called once durring initialization.  Return -1 to cause the  <br>// first standard property sheet to be displayed.  Or return the index of one of  <br>// our property sheets to have it come up first. <br>// ----------------------------------------------------------------------------- <br> <br>INT PASCAL iStartPage( void) <br>{ <br>    int i = -1; // Default to the first standard property sheet. <br>    return( i); <br>} <br> <br>//$--ADMIN_Initialize()--------------------------------------------------------- <br>// Exported function. This is the first function called by admin after the DLL  <br>// has been initialized. <br>// ----------------------------------------------------------------------------- <br> <br>VOID PASCAL ADMIN_Initialize( <br>    IN  ADMIN_AdministratorConnections* pAdminConnections,  // Global Administrator Connections <br>    IN  ADMIN_AdministratorFunction*    pAdminFuncs,        // Global admin function <br>    OUT ADMIN_ExtensionFunction**       ppExtensionFunction)// Global Extension function <br>{ <br>    DEBUGPUBLIC( "ADMIN_Initialize()\n"); <br>    if( FAILED( CHK_ADMIN_Initialize( pAdminConnections, pAdminFuncs, ppExtensionFunction))) <br>        return; <br> <br>    // We need to keep a global copy of admin's function pointers. <br>    pAdminFunctions = pAdminFuncs; <br> <br>    // Tell admin where it can find the rest of our functions that it needs. <br>    *ppExtensionFunction = &amp;extensionFunctions;   <br>} <br> <br>// ----------------------------------------------------------------------------- <br> <br> <br>// ============================================================================= <br>// Miscelaneous support functions.  The above functions are required by admin., <br>// the functions listed below are not. <br>// ============================================================================= <br> <br> <br>//$--HrLoadExtData()------------------------------------------------------------ <br>// Loads the extension data from Exchange Admin into an array of property values. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT HrLoadExtData( <br>    IN  HWND            hDlg,            // Handle of property sheet dialog. <br>    IN  LPTSTR          lpszExtDataName, // Name of extension data to retrieve. <br>    OUT ULONG*          lpcExtProps,     // Ptr to receive count of ext data properties.  <br>    OUT LPSPropValue*   lppExtProps)     // Ptr to ptr to extension data properties. <br>{ <br>    HRESULT     hr               = NOERROR; <br>    RC          rc               = RC_SUCCESS; <br>    UINT        cTemp            = 0; <br>    ULONG       cRawExtData      = 0;    // Count of raw extension data blob. <br>    LPBYTE      lpbRawExtData    = NULL; // Ptr to raw extension data blob. <br>    LPWSTR      lpwszExtDataName = NULL; // Ptr to mapi allocated WIDE extension data name. <br> <br>    //hr = CHK_HrLoadExtData( lpszExtDataName, lpcExtProps, lppExtProps);   <br>    //if( FAILED( hr)) <br>        //RETURN( hr); <br> <br>    // Make sure the property count starts at zero. <br>    *lpcExtProps = 0; <br> <br>    // Convert extension data name string to a wide string  <br>    // which is required by Exchange Admin. <br>    hr = HrStrToStrW( lpszExtDataName, &amp;lpwszExtDataName); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Ask Exchange Admin the size of the buffer needed to hold the data. <br>    rc = pAdminFunctions-&gt;pfnGetObjectDataSize( hDlg, lpwszExtDataName, &amp;cTemp); <br>    if( RC_FAILED( rc)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br>     <br>    // Convert UINT to a ULONG. <br>    cRawExtData = cTemp; <br> <br>    // Allocate a buffer to hold the extension data returned from Exchange Admin. <br>    hr = MAPIAllocateBuffer( cRawExtData, (LPVOID*) &amp;lpbRawExtData); <br>    if( FAILED( hr)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get the extension data from Exchange Admin. <br>    rc = pAdminFunctions-&gt;pfnGetObjectData( hDlg, lpwszExtDataName, lpbRawExtData, cRawExtData); <br>    if( RC_FAILED(rc)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Unpack the Exchange Admin data into a MAPI style property value array. <br>    hr = HrCfgUnpackData( cRawExtData, lpbRawExtData, NULL, lpcExtProps, lppExtProps); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpwszExtDataName); <br>    MAPIFREEBUFFER( lpbRawExtData); <br> <br>    RETURN( hr); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Saves the extension data into an Exchange Admin buffer.  Admin will not  <br>// commit this data until the user presses the Apply or OK button.  However the <br>// changed data is then available to other property sheets. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT HrSaveExtData( <br>    IN  HWND            hDlg,            // Handle of property sheet dialog. <br>    IN  LPTSTR          lpszExtDataName, // Name of extension data to save. <br>    IN  ULONG           cExtProps,       // Count of ext data properties.  <br>    IN  LPSPropValue    lpExtProps,      // Ptr to extension data properties. <br>    IN  BOOL            bNew)            // Indicates the blob is new. <br>{ <br>    HRESULT hr          = NOERROR; <br>    RC      rc          = RC_SUCCESS; <br>    ULONG   cExtData    = 0; <br>    LPBYTE  lpbExtData  = NULL; <br> <br>    // Validate the data to save. <br>    if( cExtProps != 0 &amp;&amp; !TEST_READ_PTR( lpExtProps, sizeof( SPropValue) * cExtProps)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Pack the configuration data from a MAPI style property value array  <br>    // into a format that Exchange Admin will be able to save. <br>    hr = HrCfgPackData( lpszExtDataName, cExtProps, lpExtProps, &amp;cExtData, &amp;lpbExtData); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>         <br>    // Set the extension data using Exchange Admin. <br>    rc = pAdminFunctions-&gt;pfnSetObjectData( hDlg, lpbExtData, cExtData, bNew); <br>    if( RC_FAILED(rc)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpbExtData); <br>    RETURN( hr); <br>} <br> <br>//$--HrLoadDialogTemplate()----------------------------------------------------- <br>// Use this function to create child dialog box templates.  It will ensure that  <br>// the correct language and fonts are used.   <br>// <br>// To display the dialog use DialogBoxIndirect() which is a Windows SDK  <br>// function. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT HrLoadDialogTemplate( <br>    IN  UINT     iddDialog,     // Resource ID of dialog. <br>    OUT HGLOBAL* phDlgTemplate) // Ptr to var to store handle in. <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    if( !pAdminFunctions-&gt;pfnLoadDialogResource( hDLLInst, iddDialog,  <br>            LANGIDFROMLCID(pAdminObjectInfo-&gt;lcid), (LPBYTE*) phDlgTemplate)) <br>        hr = HR_LOG( E_FAIL);     <br> <br>    RETURN( hr); <br>} <br> <br>// ----------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
