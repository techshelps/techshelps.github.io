<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POPPST.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1920"></a>POPPST.CPP</h2>
<pre><code>// --poppst.cpp--------------------------------------------------------------- <br>// <br>// Implementation of mail storage file populator program. <br>//   <br>// Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>//----------------------------------------------------------------------------- <br> <br>// <br>// Begin program documentation <br>// <br> <br>/* <br> <br>Poppst is a command line program that uses input from an ini file to create <br>messages in either a new PST or an existing PST.  If a new PST is desired, it <br>will be created in a temporary profile that is deleted when PST creation is <br>done.  If it is desired to create the messages in an existing PST, the profile <br>name is given for the PST. <br> <br>Command line arguments: <br> <br>One command line argument, the name of the ini file, is required. <br> <br>Format of the ini file: <br> <br>The following notation is used in describing the ini file grammar: <br> <br>- Angle brackets (ie. &lt;&gt;) are used to indicate a token, or syntactic element. <br>- Braces (ie. {}) are used to indicate an optional syntactic element. <br>- Ellipsis (ie. ...) are used to indicate that the preceding syntactic element <br>  may be repeated. <br>- // indicates embedded comments (ie., not part of the file format). <br>- | indicates alternation (ie., a | b implies a or b is acceptable). <br> <br>File format generalities: <br> <br>The format used is basically consistent with the standard Microsoft ini file <br>format.  Thus, there are section header lines and section entry lines.  The <br>section header lines are distinguished from section entry lines by enclosing <br>the section keyword in square brackets.  Section entry lines have an entry <br>keyword that is immediately followed by an '='.  The '=' is then immediately <br>followed by a value for the section entry.  All characters following the '=' <br>up to the newline are used for the value (ie., if there is whitespace, it will <br>be included in the value).  Leading whitespace is permitted in all lines, and <br>is not significant.  Whitespace everywhere else IS significant.  Comments may <br>be included by using ';' as the first nonwhitespace character on a line. <br>Blank lines may also be included in the ini file and are ignored.  Either a <br>newpst section or a profile section is required, and must be the first section <br>in the ini file.  Note that both a newpst section and a profile section <br>should NOT be used in one ini file.  One or more message sections should then <br>follow the newpst or profile section.  Unless otherwise noted, all section <br>entry lines are required, and must occur exactly once in a section.  The order <br>of section entries within a section is not important.The poppst program is <br>not case sensitive with regard to keywords.  The maximum line length permitted <br>is 512 chars (cbMaxIniLine) including the newline. <br> <br>!!!!!IMPORTANT INFORMATION!!!!! <br> <br>The [newpst] and [profile] sections are mutually exclusive.   <br> <br>If you specify the [newpst] section, a temporary profile will be used. <br>This means that no name resolution will be possible. <br> <br>If you specify the [profile] section, the message create <br>will be placed in the specified folder in the default message store. <br>If you want the message to be placed into your PST, then you must <br>FIRST set the PST "Personal Folders" store to be your default store <br>for the specified profile (Select Options | Delivery in the Exchange  <br>client). <br> <br>!!!!!!!!END IMPORTANT INFORMATION!!!!!!!!!!!!!!! <br> <br>Newpst section format (use to create a new pst and add msgs to it):\ <br> <br>[newpst] <br>NAME=&lt;pst display name string&gt; <br>ENCRYPTION=&lt;encryption state&gt; <br>PASSWORD=&lt;pst password string&gt; <br>PATH=&lt;file path&gt; <br> <br>Profile section format (use to add msgs to existing pst in existing profile): <br> <br>[profile] <br>NAME=&lt;profile name string&gt; <br>PASSWORD=&lt;profile password string&gt; <br> <br>Message section format: <br> <br>[message&lt;whitespace&gt;&lt;number&gt;] <br>FROM=&lt;user name&gt;{;&lt;user name&gt;}... <br>TO=&lt;user name&gt;{;&lt;user name&gt;}... <br>CC=&lt;user name&gt;{;&lt;user name&gt;}...// Optional. <br>BCC=&lt;user name&gt;{;&lt;user name&gt;}...// Optional. <br>FOLDER=&lt;folder path&gt; <br>SUBJECT=&lt;string&gt; <br>XTEXT=&lt;file path&gt;                   // Optional <br>DATE=&lt;date&gt; <br>TIME=&lt;time&gt; <br>PRIORITY=&lt;priority&gt; <br>XATTACH=&lt;file path&gt;{;&lt;file path&gt;}...// Optional. <br> <br> <br> <br>// The &lt;number&gt; value in the message section header should be unique.  Poppst <br>// doesn't acutally use the number.  It is there only for Windows API compatibility. <br> <br>BNF for syntactic elements used above: <br> <br>//This is an incomplete BNF, in that in some instances, we resolve an element <br>//to &lt;string&gt; or &lt;nonnull string&gt;, and then add a comment indicating that <br>//the string must be acceptable input for a given parameter of a given api <br>//or a valid value for a given property. <br> <br>&lt;pst display name string&gt; ::= &lt;string&gt;// Must be valid PR_DISPLAY_NAME <br>// value. <br>&lt;pst password string&gt; ::= &lt;string&gt;// Must be valid PR_PST_PW_SZ_NEW <br>// value. <br> <br>&lt;profile name string&gt; ::= &lt;nonnull string&gt;// Must be valid lpszProfileName <br>// param of MAPILogonEx(). <br> <br>&lt;profile password string&gt; ::= &lt;string&gt;// Must be valid lpszPassword <br>// param of MAPILogonEx(). <br> <br>&lt;whitespace&gt; ::= &lt;char&gt;// Where isspace(&lt;char&gt;) == TRUE. <br> <br>&lt;number&gt; ::= &lt;digit&gt;... <br> <br>&lt;user name&gt; ::= &lt;user display name&gt;{[&lt;address type&gt;:&lt;email address&gt;]} <br> <br>&lt;user display name&gt; ::= &lt;nonnull string&gt;// Must be valid PR_DISPLAY_NAME <br>// value. <br> <br>&lt;address type&gt; ::= &lt;nonnull string&gt;// Must be valid PR_ADDRTYPE value. <br> <br>&lt;email address&gt; ::= &lt;nonnull string&gt;// Must be valid PR_EMAIL_ADDRESS <br>// value. <br> <br>&lt;folder path&gt; ::= {&lt;folder namestring&gt;{\&lt;folder namestring&gt;}...}// See note <br>// below. <br>&lt;string&gt; ::= {&lt;char&gt;}... <br> <br>&lt;file path&gt; ::= &lt;nonnull string&gt;// Must be valid filename param of <br>// fopen() api. <br> <br>&lt;date&gt; ::= YYYY-MM-DD// ie., year-month-day, as digits. <br> <br>&lt;time&gt; ::= HH:MM{:SS}// ie., hour:min{sec} as digits. <br> <br>&lt;encryption state&gt; ::= ON | OFF <br> <br>&lt;priority&gt; ::= HIGH | NORMAL | LOW <br> <br>&lt;nonnull string&gt; ::= &lt;char&gt;... <br> <br>&lt;char&gt; ::= Any char other than '\n'. <br> <br>&lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 <br> <br>&lt;folder namestring&gt; ::= &lt;nonnull string&gt;// Must be valid PR_DISPLAY_NAME <br>// value for a mailstore folder. <br> <br>// Additional note on &lt;folder path&gt;: <br> <br>A null folder path is used to specify the root folder of a mail store.  If you <br>want to add mail to the user inbox, the correct folder path is: <br>"Microsoft Personal Information Store\Inbox". <br> <br>// Notes on message properties: <br> <br>The properties that are created for each entry line in a message section are <br>documented below.  In general, we have used the properties that will result <br>in the information being displayed by the Exchange client frontend. <br> <br>FROM:PR_SENDER_NAME = &lt;user name&gt; <br>PR_SENT_REPRESENTING_NAME = &lt;user name&gt; <br> <br>// The following three lines are used to set up the recipient table in <br>// a message.  If the address book is available and &lt;user name&gt; can be <br>// resolved, then PR_DISPLAY_NAME will be used to derive PR_ADDRTYPE, <br>// PR_EMAIL_ADDRESS, and PR_ENTRYID.  If the address book is available, <br>// PR_ADDRTYPE and PR_EMAIL_ADDRESS may also be provided explicitly by using <br>// a &lt;user name&gt; of form &lt;user display name&gt;[&lt;address type&gt;:&lt;email address&gt;]. <br>// All the &lt;user display name&gt;'s provided will also be used to set <br>// PR_DISPLAY_TO, PR_DISPLAY_CC, and PR_DISPLAY_BCC. <br> <br>TO:PR_RECIPIENT_TYPE = MAPI_TO; <br>PR_DISPLAY_NAME = &lt;user name&gt; for each &lt;user name&gt;; <br> <br>CC:PR_RECIPIENT_TYPE = MAPI_CC; <br>PR_DISPLAY_NAME = &lt;user name&gt; for each &lt;user name&gt;; <br> <br>BCC:PR_RECIPIENT_TYPE = MAPI_BCC; <br>PR_DISPLAY_NAME = &lt;user name&gt; for each &lt;user name&gt;; <br> <br>FOLDER:Used to find folder message should be placed in.  If it does not <br>exist, it will be created. <br> <br>SUBJECT:Used to set PR_SUBJECT. <br> <br>XTEXT:Contents of &lt;file path&gt; used to set PR_BODY &amp; PR_RTF_COMPRESSED <br> <br>DATE:Used to set PR_MESSAGE_DELIVERY_TIME. <br> <br>TIME:Used to set PR_MESSAGE_DELIVERY_TIME. <br> <br>PRIORITY:Used to set PR_PRIORITY &amp; PR_IMPORTANCE <br> <br>XATTACH:Contents of &lt;file path&gt; used to set PR_ATTACH_DATA_BIN. <br>PR_ATTACH_METHOD = ATTACH_BY_VALUE. <br>PR_ATTACH_FILENAME = &lt;file path&gt;. <br>PR_ATTACH_LONG_FILENAME = &lt;file path&gt;. <br> <br>*/ <br> <br>// <br>// End program documentation <br>// <br> <br>#include "edk.h" <br>#include "mspst.h" <br>#include "popstrs.h" <br>#include "poppstmc.h"// generated by the message compiler from poppstmc.mc <br>#include "poppst.chk" <br> <br>// <br>// Manifest constants <br>// <br> <br>const ULONG ulMapiLogonFlags    =    <br>(MAPI_NEW_SESSION | MAPI_EXPLICIT_PROFILE | MAPI_NO_MAIL); <br> <br>const UINT  cbMaxIniLine    =   512; <br> <br>// <br>// Macros <br>// <br> <br>// No macros defined. <br> <br>// <br>// Enumeration, structure, and other type definitions <br>// <br> <br>enum INIFILESECTIONTYPE// ifst <br>{ <br>    IFST_MESSAGE, <br>IFST_NEWPST, <br>    IFST_PROFILE, <br>    IFST_UNKNOWN <br>}; <br> <br>enum LINEREADSTATUS// lrs <br>{ <br>    LRS_OKAY,           // Line was read and is available. <br>    LRS_EOF,            // We are at end of file; no more lines. <br>    LRS_IOERROR,        // There was an I/O error in the last read. <br>    LRS_LINETOOLONG     // Last line too long to return. <br>}; <br> <br>struct INIFILELINEVALUE// iflv <br>{ <br>BOOLfValid; <br>    CHAR            achValue[cbMaxIniLine]; <br>}; <br> <br>struct INIFILEPARSEINFO// ifpi <br>{ <br>    CHAR *          pszKeyword; <br>    HRESULT            (*HrParseFunction)(INCHAR *pch); <br>INIFILELINEVALUE *piflv; <br>}; <br> <br>// <br>// Forward function declarations <br>// <br> <br>static <br>HRESULT <br>HrCreateMessageAttachment( <br>INLPMESSAGElpMsg, <br>INLPSTRlpszAttachPath <br>); <br> <br>static <br>HRESULT <br>HrGetNextLine(OUT LINEREADSTATUS * lpReadStatus); <br> <br>static <br>VOID <br>InitSectionData( <br>INBOOLfCommented);// TRUE if section data is commented <br> <br>static <br>HRESULT <br>HrIsSectionLine( <br>    IN      CHAR *  pch, <br>    OUT     BOOL * bIsSectionLine <br>    ); <br> <br>static <br>HRESULT <br>HrOpenFolder(OUT LPMAPIFOLDER * lppFolder); <br> <br>static <br>HRESULT <br>HrParseDateValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>HRESULT <br>HrParseEncryptionValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>HRESULT <br>HrParseEntryLine( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>HRESULT <br>HrParseLine(); <br> <br>static <br>HRESULT <br>HrParseNonNullStringValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>HRESULT <br>HrParsePriorityValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>HRESULT <br>HrParseSectionLine( <br>    IN      CHAR *  pch,// pointer to section keyword <br>INBOOLfCommented// TRUE is section is commented out <br>    ); <br> <br>static <br>HRESULT <br>HrParseStringValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>HRESULT <br>HrParseTimeValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>HRESULT <br>HrProcessMessageSection(VOID); <br> <br>static <br>HRESULT <br>HrProcessNewPSTSection(VOID); <br> <br>static <br>HRESULT <br>HrProcessProfileSection(VOID); <br> <br>static <br>HRESULT <br>HrResolveRecipientNames( <br>OUTLPADRLIST *lppAdrList <br>); <br> <br>static <br>HRESULT <br>HrResolveSenderName( <br>    IN      LPSTR pszName, <br>OUTLPADRLIST *ppAdrList <br>); <br> <br>static <br>HRESULT <br>HrSetMessageProperties( <br>INLPMESSAGElpMsg <br>); <br> <br>static <br>HRESULT <br>HrWriteMessageText( <br>INLPMESSAGElpMsg, <br>INLPSTRlpszFilePath <br>); <br> <br>// <br>// Static storage <br>// <br> <br>// Temporary profile name <br>static LPSTRlpszProfileName =   NULL; <br> <br>// Temporary profile password <br>static LPSTRlpszProfilePassword =   NULL; <br> <br>// Storage used to input and parse ini file lines and store values. <br> <br>// Ini file pointer: <br> <br>static FILE *           IniFile =NULL; <br> <br>// Current input line: <br> <br>static CHAR             achIniLine[cbMaxIniLine]  =   {0}; <br> <br>// Parser state variables: <br> <br>static BOOLfTmpProf =FALSE; <br>static INIFILESECTIONTYPEifstCurSection  =   IFST_UNKNOWN; <br> <br>// The following variable is TRUE if the current section has been  <br>// commented out (e.g. ;[newpst]) <br>static BOOLfCurSectionComment=FALSE; <br> <br>// Parsed value storage (uses ~0.5KB per value): <br> <br>static INIFILELINEVALUEiflvBCC =   {0};// For Message <br>static INIFILELINEVALUEiflvCC  =   {0};// For Message <br>static INIFILELINEVALUEiflvDATE    =   {0};// For Message <br>static INIFILELINEVALUEiflvENCRYPTION  =   {0};// For NewPST <br>static INIFILELINEVALUEiflvFOLDER  =   {0};// For Message <br>static INIFILELINEVALUEiflvFROM    =   {0};// For Message <br>static INIFILELINEVALUEiflvPROFILENAME =   {0};// For Profile <br>static INIFILELINEVALUEiflvPSTNAME =   {0};// For NewPST <br>static INIFILELINEVALUEiflvPROFILEPASSWORD =   {0};// For Profile <br>static INIFILELINEVALUEiflvPSTPASSWORD =   {0};// For NewPST <br>static INIFILELINEVALUEiflvPATH    =   {0};// For NewPST <br>static INIFILELINEVALUEiflvPRIORITY    =   {0};// For Message <br>static INIFILELINEVALUEiflvSUBJECT =   {0};// For Message <br>static INIFILELINEVALUEiflvTIME    =   {0};// For Message <br>static INIFILELINEVALUEiflvTO  =   {0};// For Message <br>static INIFILELINEVALUEiflvXATTACH =   {0};// For Message <br>static INIFILELINEVALUEiflvXTEXT   =   {0};// For Message <br> <br>// We translate some values and store them below during parsing: <br> <br>static BOOLbEncryptionNewPST   =   0; <br>static FILETIMEftCurMsg            =   {0}; <br>static LONGlPriorityCurMsg     =   0; <br>static LONG             lImportanceCurMsg   =   0; <br>static SYSTEMTIMEstCurMsg ={0, 0, 0, 0, 0, 0, 0, 0}; <br> <br>// Parser tables for entries: <br> <br>static <br>INIFILEPARSEINFO    aifpiMessageEntry[] =   { <br>                                            "BCC", HrParseNonNullStringValue, <br>&amp;iflvBCC, <br>                                            "CC", HrParseNonNullStringValue, <br>&amp;iflvCC, <br>                                            "DATE", HrParseDateValue, <br>&amp;iflvDATE, <br>                                            "FOLDER", HrParseStringValue, <br>&amp;iflvFOLDER, <br>                                            "FROM", HrParseNonNullStringValue, <br>&amp;iflvFROM, <br>                                            "PRIORITY", HrParsePriorityValue, <br>&amp;iflvPRIORITY, <br>                                            "SUBJECT", HrParseStringValue, <br>&amp;iflvSUBJECT, <br>                                            "TIME", HrParseTimeValue, <br>&amp;iflvTIME, <br>                                            "TO", HrParseNonNullStringValue, <br>&amp;iflvTO, <br>                                            "XATTACH", HrParseNonNullStringValue, <br>&amp;iflvXATTACH, <br>                                            "XTEXT", HrParseNonNullStringValue, <br>&amp;iflvXTEXT <br>                                            }; <br>static <br>INIFILEPARSEINFO  aifpiNewPSTEntry[] =     { <br>                                            "NAME", HrParseStringValue, <br>&amp;iflvPSTNAME, <br>                                            "PASSWORD", HrParseStringValue, <br>&amp;iflvPSTPASSWORD, <br>"ENCRYPTION", HrParseEncryptionValue, <br>&amp;iflvENCRYPTION, <br>"PATH", HrParseNonNullStringValue, <br>&amp;iflvPATH <br>                                            }; <br>static <br>INIFILEPARSEINFO  aifpiProfileEntry[] =     { <br>                                            "NAME", HrParseNonNullStringValue, <br>&amp;iflvPROFILENAME, <br>                                            "PASSWORD", HrParseStringValue, <br>&amp;iflvPROFILEPASSWORD <br>                                            }; <br>// Error handling variables: <br> <br>static ULONGcMsgs =0; <br>static DWORDiLine =1; <br>static DWORDiSection =1; <br> <br>// MAPI-related storage: <br> <br>static LPADRBOOKlpAdrBook =NULL; <br>static LPMDBlpMdb =NULL; <br>static LPMAPIFOLDERlpRootFolder =NULL; <br>static LPMAPISESSIONlpSession =NULL; <br> <br>// character constants <br>const CHARcSemiColon=';';// delimiter character or comment <br>const CHARcBeginSectLine='[';// begins section line <br>const CHAR cEndSectLine=']';// ends section line <br>const CHARcEquals='=';// keyword equals value character <br>const CHARcNewLine='\n';// new line character <br>const CHAR cColon=':';// colon character <br>const CHARcBackSlash='\\';// backslash character <br>const CHARcDate='d';// date template character <br> <br>// string constants <br>LPCSTRpszSeparator=";";// delimiter character <br> <br>// Application name <br>static CHARszAppName[]="POPPST"; <br> <br>// Static inline "macros" <br>// Used instead of #define macros, since they can do type checking <br> <br>// in-line static for determining if should process section <br>static inline BOOL fSectionReady(// RETURNS: BOOL <br>IN INIFILESECTIONTYPE ifstDesiredSection)// section want to process <br>{ <br> // If current section is desired section and current section <br>// is not commented out, we should try to process it. <br>return ( ( (ifstCurSection == ifstDesiredSection) &amp;&amp;  <br>  (fCurSectionComment == FALSE) ) ? TRUE : FALSE ); <br> <br>} <br> <br>// <br>// Functions <br>// <br> <br>//$--INTERNAL_ERROR---------------------------------------------------------- <br>//  Helper functions for EventLogMsg <br>// -------------------------------------------------------------------------- <br>static inline VOID INTERNAL_ERROR( <br>    IN LPCTSTR str, <br>    IN const HRESULT hr) <br>{ <br>    TCHAR szErrorCode[16] = {0}; <br> <br>    EventLogMsg( <br>        POPPST_INTERNAL_ERROR, <br>        2, str, _itot( hr, szErrorCode, 16), <br>        0); <br>} <br> <br>static inline LPCTSTR SZ_BASE10( <br>    IN const INT iNumber) <br>{ <br>    static TCHAR szTemp[16] = {0}; <br>    return( (LPCTSTR)_itot( iNumber, szTemp, 10)); <br>} <br> <br>static inline LPCTSTR SZ_BASE16( <br>    IN const ULONG ulNumber) <br>{ <br>    static TCHAR szTemp[16] = {0}; <br>    return( (LPCTSTR)_itot( ulNumber, szTemp, 16)); <br>} <br> <br> <br>//$--DisplayUserMsg---------------------------------------------------------- <br>// <br>// DESCRIPTION: Utility to display message to command line user. <br>// <br>// INPUT:       hInst   --  program instance handle <br>//              nResID  --  Resource string identifier <br>//  <br>// RETURNS:     VOID <br>// <br>// ---------------------------------------------------------------------------- <br>VOID DisplayUserMsg(            // RETURNS: nothing <br>            IN UINT nResID,     // resource string identifier <br>            ...)                // additional arguments <br>{     <br>    INT     nRetCode    = 0;// return value <br>    va_list vArgList    =   {0};        // variable argument list <br>static HMODULEhModule=NULL;// application instance handle <br>static BOOLfInit=FALSE;// TRUE if module handle has is initialized <br>DWORDnLastErr=0;// last Win32 API error <br> <br>    const INTnMsgLength=   256;        // maximum length of printed messages <br> <br>// LoadString message buffer <br>    CHAR  szMessage[nMsgLength]  =   ""; <br> <br>    DEBUGPRIVATE("DisplayUserMsg()\n"); <br> <br>    // No CHK_DisplayUserMsg() call. <br>    // We check arguments as we go, as we may be in an error state. <br> <br>    // Check the instance handle <br>    if ( fInit == FALSE ) <br>    { <br>// Retrieve this programs instance handle. <br>hModule = GetModuleHandle(NULL); <br> <br>fInit = TRUE;// have retrieved instance handle <br> <br>// Print out error if have failed. <br>if ( hModule == NULL ) <br>{ <br>nLastErr = GetLastError(); <br> <br>fprintf(stderr, "ERROR: Unable to display resource messages to console: " <br>"error code 0x%lx,\n", nLastErr); <br> <br>HR_LOG(HRESULT_FROM_WIN32(nLastErr)); <br>} <br>    } <br> <br>// Check validity of module handle <br>if ( hModule == NULL ) <br>{ <br>// can't do anything <br>goto cleanup; <br>} <br> <br>// retrieve resource string <br>    nRetCode = LoadString( <br>    hModule,  <br>    nResID,  <br>    szMessage,  <br>    nMsgLength); <br> <br>    if ( nRetCode == 0 ) <br>    { <br>        // Print out default error string. <br>nLastErr = GetLastError(); <br> <br>fprintf(stderr, "ERROR: Can't load resource string %ld: " <br>"error code 0x%lx,\n", nResID, nLastErr); <br> <br>        HR_LOG(HRESULT_FROM_WIN32(nLastErr)); <br> <br>        goto cleanup; <br>    } <br> <br>    // Get an optional argument list pointer <br>    va_start(vArgList, nResID); <br> <br>    // Print the message to standard out <br>    vprintf(szMessage,          // format string <br>            vArgList);          // variable argument list <br> <br>    va_end(vArgList); <br> <br>// we are done. <br> <br>cleanup: <br> <br>    // Return <br>    return; <br> <br>}   // end DisplayUserMsg() <br> <br>//$--main-------------------------------------------------------------------- <br>// <br>// DESCRIPTION: poppst.exe main() routine. <br>// <br>// INPUT:       argc    --  argument count <br>//              argv    --  command line arguments <br>// <br>// RETURNS:     INT --     0 on success; <br>//                         E_INVALIDARG if invalid parameter, <br>//                         E_OUTOFMEMORY if memory problems, <br>//                         E_FAIL if internal error. <br>// <br>//--------------------------------------------------------------------------- <br> <br>INT main(               // RETURNS: INT <br>    IN  INT     argc,       // # arguments on command line <br>    IN  CHAR *  argv[]      // command line arguments array <br>    ) <br>{ <br>    HRESULT hr  =   NOERROR; <br>INT            iCounter        =0;// argument index <br>BOOLbMAPIInitialized =FALSE; <br>    LINEREADSTATUS      lrs =   LRS_OKAY; <br>    BOOL    bIsSectionLine  =   FALSE;  // TRUE if the line is a section line <br>HANDLEhEvent=NULL;// event logging handle <br>EDKEVENTCOUNTsEventCount={0};// event log count structure <br>BOOLfEventLogOpened=FALSE;// TRUE if event log is open <br> <br>    DEBUGPUBLIC("main()\n"); <br> <br>    // Check input parameters. <br>hr = CHK_main(argc, argv); <br>if ( FAILED(hr) ) <br>goto cleanup; <br> <br>// parse comand line <br>    if (argc == 1) <br>    { <br>// Display usage message <br>DisplayUserMsg( <br>IDS_USAGE); <br>DisplayUserMsg( <br>IDS_NEWLINE); <br>DisplayUserMsg( <br>IDS_USAGEFILE); <br>DisplayUserMsg( <br>IDS_USAGEHELP); <br> <br>        hr = HR_LOG(E_INVALIDARG); <br> <br>        goto cleanup; <br>    } <br> <br>    // Check to see if user wants help (/? or /HELP flag) <br>    for ( iCounter = 0; iCounter &lt; argc; iCounter++ ) <br>    { <br>        ASSERT_STRING_PTR(argv[iCounter], "Bad argv[iCounter]"); <br> <br>        if ( argv[iCounter][0] == '/' || argv[iCounter][0] == '-') <br>        { <br>            if ( (argv[iCounter][1] == '?') ||  <br>                 (argv[iCounter][1] == 'H') || <br>                 (argv[iCounter][1] == 'h') ) <br>            { <br>                // display help message <br>DisplayUserMsg( <br>IDS_HELP); <br>DisplayUserMsg( <br>IDS_NEWLINE); <br>DisplayUserMsg( <br>IDS_USAGE); <br>DisplayUserMsg( <br>IDS_NEWLINE); <br>DisplayUserMsg( <br>IDS_USAGEFILE); <br>DisplayUserMsg( <br>IDS_HELPDOC); <br> <br>                hr = HR_LOG(E_INVALIDARG); <br> <br>                goto cleanup; <br>            } <br>        } <br>    }   // end for <br> <br>    // Check number of parameters.  (Should be 2, including the <br>    // program name). <br>    if ( argc != 2 ) <br>    { <br>DisplayUserMsg( <br>IDS_PARAM_NUMBER); <br> <br>        hr = HR_LOG(E_INVALIDARG); <br> <br>        goto cleanup; <br>    } <br> <br>    if ( FAILED(hr) ) <br>        goto cleanup; <br> <br>// Open an event logging handle for this application. <br> hr = HrEventOpenLog( <br>szAppName,// application name <br>NULL,// executable name (computed) <br>    NULL,// event message file (computed) <br>NULL,// parameter message file <br>NULL,// category message file <br>&amp;hEvent);// event logging handle <br> <br>if ( FAILED(hr) ) <br>{ <br>DisplayUserMsg( <br>IDS_EVENT_LOG, <br>hr); <br> <br>goto cleanup; <br>} <br> <br>ASSERTERROR((hEvent != NULL), "Bad hEvent"); <br> <br>fEventLogOpened = TRUE; <br> <br>// Let user know that we are doing something. <br>DisplayUserMsg( <br>IDS_PROCESSING,  <br>argv[1]); <br> <br>    // open the INI file. <br>    IniFile = fopen(argv[1], "r"); <br> <br>if ( IniFile == NULL ) <br>{ <br>EventLogMsg( <br>POPPST_OPEN_FILE_ERROR, <br>1,// # of string replacements <br>argv[1], <br>0);// # of Win32 error codes <br> <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>} <br> <br>hr = MAPIInitialize(0); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>POPPST_MAPIINIT_ERROR, <br>1, SZ_BASE16(hr), <br>0); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br> <br>bMAPIInitialized = TRUE; <br> <br>InitSectionData(FALSE); <br> <br>    while (TRUE) <br>    { <br>hr = HrGetNextLine(&amp;lrs); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>if (lrs == LRS_OKAY) <br>{ <br>            hr = HrIsSectionLine(achIniLine, &amp;bIsSectionLine); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>if ( bIsSectionLine ) <br>{ <br>if ( fSectionReady(IFST_MESSAGE) == TRUE ) <br>{ <br>    hr = HrProcessMessageSection(); <br> <br>                    if ( FAILED(hr) ) <br>                    { <br>                        goto cleanup; <br>                    } <br>} <br>else if ( fSectionReady(IFST_NEWPST) == TRUE ) <br>{ <br>                    hr = HrProcessNewPSTSection(); <br> <br>if ( FAILED(hr) ) <br>                    { <br>goto cleanup; <br>                    } <br>} <br>else if ( fSectionReady(IFST_PROFILE) == TRUE ) <br>{ <br>                    hr = HrProcessProfileSection(); <br> <br>if ( FAILED(hr) ) <br>                    { <br>goto cleanup; <br>                    } <br>} <br> <br>// If ifstCurSection == IFST_UNKNOWN, we don't have a valid <br>// section at present, and do nothing. <br>} <br> <br>            hr = HrParseLine(); <br> <br>        if ( FAILED(hr) ) <br>        { <br>EventLogMsg( <br>POPPST_SYNTAX_ERROR, <br>1, SZ_BASE10(iLine), <br>0); <br>            } <br>} <br>else if (lrs == LRS_LINETOOLONG) <br>{ <br>EventLogMsg( <br>POPPST_LENGTH_ERROR, <br>1, SZ_BASE10(iLine), <br>0); <br>} <br>else <br>{ <br>break; <br>} <br> <br>        iLine++; <br>    } <br> <br>    if (lrs == LRS_EOF)  <br>    { <br>if ( fSectionReady(IFST_MESSAGE) == TRUE ) <br>{ <br>hr = HrProcessMessageSection(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>} <br>else if ( fSectionReady(IFST_NEWPST) == TRUE ) <br>{ <br>            hr = HrProcessNewPSTSection(); <br> <br>if ( FAILED(hr) ) <br>            { <br>goto cleanup; <br>            } <br>} <br>else if ( fSectionReady(IFST_PROFILE) == TRUE ) <br>{ <br>            hr = HrProcessProfileSection(); <br> <br>if ( FAILED(hr) ) <br>            { <br>goto cleanup; <br>            } <br>} <br> <br>    }// end if have reached end of file <br> <br>// Dertermine number of errors, warnings and informationsl <br>// messages logged to the event log. <br>hr = HrEventGetCounts( <br>&amp;sEventCount);// structure to hold event logging statistics <br> <br>if ( FAILED(hr) ) <br>{ <br>        INTERNAL_ERROR( TEXT("HrEventGetCounts()"), hr); <br> <br>sEventCount.cError = 1;// have at least one error <br>} <br> <br>// if no errors, check for proper program termination state <br>if ( sEventCount.cError == 0 ) <br>{ <br>if ( (lrs == LRS_EOF) &amp;&amp; (ifstCurSection == IFST_UNKNOWN) ) <br>{ <br>// Have an empty INI file.   <br>// Print out error to the user. <br>hr = HR_LOG(E_FAIL); <br> <br>EventLogMsg( <br>POPPST_EMPTY_ERROR, <br>1, <br>argv[1], <br>0); <br> <br>goto cleanup; <br> <br>}// end if have an empty file <br> <br>    else if (lrs == LRS_IOERROR) <br>    { <br>EventLogMsg( <br>POPPST_IO_ERROR, <br>1, SZ_BASE10(iLine), <br>0); <br> <br>goto cleanup; <br>    } <br> <br>// Otherwise, we are successful <br>   else <br>    { <br>// Log this fact. <br>EventLogMsg( <br>POPPST_POPULATE_SUCCEEDED, <br>0, <br>0); <br>    } <br> <br>}// end if no error message printed out so far <br> <br>// We are done. <br> <br>cleanup: <br> <br>// Print out a completion message to the user. <br>// First, determine the number of errors, warnings and informationsl <br>// messages logged to the event log. <br>if ( fEventLogOpened == TRUE ) <br>{ <br>ZeroMemory(&amp;sEventCount, sizeof(sEventCount)); <br>hr = HrEventGetCounts( <br>&amp;sEventCount);// structure to hold event logging statistics <br> <br>if ( FAILED(hr) ) <br>{ <br>            INTERNAL_ERROR( TEXT("HrEventGetCounts()"), hr); <br> <br>sEventCount.cError = 1;// have at least one error <br>} <br> <br>if ( sEventCount.cError == 0 ) <br>{ <br>// print success message  <br>DisplayUserMsg( <br>IDS_SUCCESS); <br>} <br> <br>else if ( sEventCount.cError == 1 ) <br>{ <br>// print one error message <br>DisplayUserMsg( <br>IDS_1ERROR); <br>} <br> <br>else  <br>{ <br>// print multiple error message <br>DisplayUserMsg( <br>IDS_ERRORS); <br>} <br> <br>if ( sEventCount.cWarning == 1 ) <br>{ <br>// print out one warning message <br>DisplayUserMsg( <br>IDS_1WARNING); <br>} <br> <br>else if ( sEventCount.cWarning &gt; 1 ) <br>{ <br>// print out mutliple warnings message <br>DisplayUserMsg( <br>IDS_WARNINGS); <br>} <br> <br>// close event log <br>(VOID)HrEventCloseLog(); <br>hEvent = NULL; <br>fEventLogOpened = FALSE; <br> <br>}// end if have event log handle <br> <br>// Release MAPI and OLE objects <br>ULRELEASE(lpAdrBook); <br>ULRELEASE(lpRootFolder); <br>ULRELEASE(lpMdb); <br> <br>if (lpSession) <br>{ <br>    lpSession-&gt;Logoff(0, 0, 0); <br>ULRELEASE(lpSession); <br>} <br> <br>if (fTmpProf) <br>{ <br>HrCleanupPSTGlobals(lpszProfileName); <br> <br>        MAPIFREEBUFFER(lpszProfileName); </code></pre>
<p>
</p>
<pre><code>MAPIFREEBUFFER(lpszProfilePassword); <br>} <br> <br>if (bMAPIInitialized) <br>    { <br>    MAPIUninitialize(); <br>    } <br> <br>    if (IniFile) <br>    { <br>        fclose(IniFile); <br>    } <br> <br>    // return the appropriate exit code, based on our HRESULT. <br>    return _nEcFromHr(hr); <br>} <br> <br>//$--HrCreateMessageAttachment----------------------------------------------- <br>// <br>// DESCRIPTION: Create a message attachment and write the contents of the <br>//specified file to it.  Also create various required properties <br>//for the message attachment. <br>// <br>// INPUT: <br>// <br>//[lpMsg]-- Message for which attachment is to be created. <br>//[lpszAttachPath]-- Path of file containing attachment text. <br>// <br>// RETURNS: HRESULT --  NOERROR if O.K.,  <br>//                      E_INVALIDARG if invalid parameter, <br>//                      E_OUTOFMEMORY if memory problems, <br>//                      E_FAIL if call fails <br>// <br>//--------------------------------------------------------------------------- <br> <br> <br>HRESULT HrCreateMessageAttachment(          // RETURNS: HRESULT <br>INLPMESSAGElpMsg,              // MAPI message pointer <br>INLPSTRlpszAttachPath      // list of attachment file names <br>) <br>{ <br>    HRESULT         hr              =   NOERROR;    // return code <br>ULONGcb              =   0; <br>LPATTACHlpAttach        =NULL; <br>ULONGulAttachmentNum =   0; <br>    ULONG           nAttachments    =   0;      // # of attachments <br>    ULONG           iAttach         =   0;      // attachment index <br>    LPSTR           lpszCurrent     =   NULL;   // current attachment <br>LPSTR *lppszAttachTok=NULL;// array of tokenized attachments <br> <br>    // MAPI property creation flags.     <br>    const ULONG     ulFlags     =   MAPI_CREATE | MAPI_MODIFY |  <br>                                    MAPI_DEFERRED_ERRORS;   // reduces RPCs <br> <br>    // Buffer read/write size <br>    const UINT      cbBufSize           =   4096; <br> <br>    // read/write data buffer <br>BYTEab[cbBufSize]       =   {0}; <br> <br>    // # of attachment properties <br>    const ULONGcValues             =3; <br> <br>    // property value array <br>    SPropValue      aPropVals[cValues]  =   {0}; <br> <br>    DEBUGPRIVATE("HrCreateMessageAttachment()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrCreateMessageAttachment(lpMsg, lpszAttachPath); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Determine number of attachments by breaking into tokens <br>hr = HrStrTokAll( <br>lpszAttachPath,// file name list <br>(LPSTR) pszSeparator,// separator character <br>&amp;nAttachments,// # of file names <br>&amp;lppszAttachTok);// array of strings pointer <br> <br>if ( FAILED(hr) ) <br>{ <br>        INTERNAL_ERROR( TEXT("HrStrTokAll()"), hr); <br> <br>goto cleanup; <br>} <br> <br>    ASSERTERROR((nAttachments != 0), "Bad nAttachments"); <br>ASSERT_READ_PTR(lppszAttachTok, sizeof(LPSTR) * nAttachments,  <br>"Bad lppszAttachTok"); <br> <br>    // Process each attachment. <br>    for ( iAttach = 0; iAttach &lt; nAttachments; iAttach++ ) <br>    { <br>        // Release MAPI objects <br>    ULRELEASE(lpAttach); <br> <br>// Retrieve next attachment <br>lpszCurrent = lppszAttachTok[iAttach]; <br> <br>ASSERT_STRINGA_PTR(lpszCurrent, "Bad lpszCurrent"); <br> <br>    // Create the attachment in the message. <br>    hr = lpMsg-&gt;CreateAttach(NULL, <br> MAPI_DEFERRED_ERRORS,  // reduces RPCs <br> &amp;ulAttachmentNum, <br> &amp;lpAttach); <br> <br>    if ( FAILED(hr) ) <br>    {   <br>            INTERNAL_ERROR( TEXT("IMessage::CreateAttach()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br> <br>    goto cleanup; <br>    } <br> <br>        ASSERT_IUNKNOWN_PTR(lpAttach, "Bad lpAttach"); <br>         <br>    // Create required additional properties. <br>LPSPropProblemArraylpProblems =NULL; <br>LPSTRlpszFileName    =   NULL; <br> <br>aPropVals[0].ulPropTag =PR_ATTACH_METHOD; <br>aPropVals[0].Value.l =ATTACH_BY_VALUE; <br> <br>lpszFileName = strrchr(lpszCurrent, cBackSlash); <br> <br>if (!lpszFileName) <br>lpszFileName = lpszCurrent; <br>else <br>lpszFileName++;// Advance past the backslash. <br> <br>// CAVEAT - We don't do anything here to check for invalid FAT 8.3 <br>//    names.  This may be a good idea. <br>aPropVals[1].ulPropTag =PR_ATTACH_FILENAME; <br>aPropVals[1].Value.lpszA =lpszFileName; <br> <br>aPropVals[2].ulPropTag =PR_ATTACH_LONG_FILENAME; <br>aPropVals[2].Value.lpszA =lpszFileName; <br> <br>hr = lpAttach-&gt;SetProps(cValues, aPropVals, &amp;lpProblems); <br> <br>if (FAILED(hr)) <br>{ <br>            INTERNAL_ERROR( TEXT("IMAPIProp::SetProps()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (lpProblems != NULL) <br>{ <br>ULONGi   =   0; <br>for (i = 0; i &lt; lpProblems-&gt;cProblem; i++) <br>{ <br>                INTERNAL_ERROR( TEXT("IMAPIProp::SetProps()"), lpProblems-&gt;aProblem[i].scode); <br>} <br> <br>MAPIFREEBUFFER(lpProblems); <br> <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>        // Create the PR_ATTACH_DATA_BIN property from the attachment <br>        // file text. <br>        hr = HrMAPISetPropFromFile( <br>            lpAttach,               // pointer to attachment object <br>            PR_ATTACH_DATA_BIN,     // property tag <br>            lpszCurrent,            // fully-pathed file name from which to read data <br>            &amp;cb);                   // # bytes read in <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("HrMAPISetPropFromFile()"), hr); <br> <br>            goto cleanup; <br>        } <br> <br>    // Commit the attachment changes. <br>    hr = lpAttach-&gt;SaveChanges(0); <br> <br>    if (FAILED(hr)) <br>    { <br>            INTERNAL_ERROR( TEXT("IMAPIProp::SaveChanges()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>    }   // end for each attachment <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Release MAPI and OLE objects <br>ULRELEASE(lpAttach); <br> <br>// Free MAPI buffers <br>MAPIFREEBUFFER(lppszAttachTok); <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--HrGetNextLine----------------------------------------------------------- <br>// <br>// DESCRIPTION: Get the next input line from the ini file and deposit it in <br>//the input buffer (achIniLine). <br>// <br>// OUTPUT:  LINEREADSTATUS *    --  pointer to line read status <br>// <br>//  LRS_OKAY if line was read and is available. <br>//  LRS_EOF if we are at end of file; no more lines. <br>//  LRS_IOERROR if there was an I/O error in the last read. <br>//  LRS_LINETOOLONG if last line was too long to fit in the buffer. <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad parameter, <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrGetNextLine(                  // RETURNS: HRESULT <br>    OUT LINEREADSTATUS * lpReadStatus)  // pointer to line read status <br>{ <br>    HRESULT         hr  =   NOERROR;    // return code <br>    INT             ch  =   0; <br>    CHAR *          pch =       &amp;achIniLine[0]; <br>    CHAR *          pchInv =    &amp;achIniLine[cbMaxIniLine]; <br> <br>    DEBUGPRIVATE("HrGetNextLine()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrGetNextLine(lpReadStatus); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *lpReadStatus = LRS_OKAY; <br> <br>    while (TRUE) <br>    { <br>        if (pch == pchInv) <br>        { <br>            // Line is too long <br>            *lpReadStatus =           LRS_LINETOOLONG; <br>            achIniLine[0] = 0; <br>            while ((ch = getc(IniFile)) != EOF &amp;&amp; (ch != cNewLine)); <br> <br>            break; <br>        } <br> <br>        ch = getc(IniFile); <br> <br>        if (ch == cNewLine) <br>        { <br>            // Just read end of this line <br>            *lpReadStatus =   LRS_OKAY; <br>            *pch =  0; <br> <br>            break; <br>        } <br> <br>        if (ch == EOF) <br>        { <br>            // Just read last line in file <br>            // We want to process the last line, if any. <br>            *pch = 0; <br> <br>            if ( pch == &amp;achIniLine[0] ) <br>            { <br>                // we have passed the last line in the file. <br>                *lpReadStatus = feof(IniFile) ? LRS_EOF : LRS_IOERROR; <br>            } <br> <br>            else <br>            { <br>                // we just read last line.  We want to process <br>                // its data. <br>                *lpReadStatus = feof(IniFile) ? LRS_OKAY : LRS_IOERROR; <br>            } <br> <br>            break; <br> <br>        }   // end if end of file reached <br> <br>        *pch = ch; <br>        pch++; <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--InitSectionData--------------------------------------------------------- <br>// <br>// DESCRIPTION: Initialize static variables that will be used in parsing an <br>//ini file section to default values. <br>// <br>// INPUT:       None. <br>// <br>// RETURNS:     Nothing. <br>// <br>//--------------------------------------------------------------------------- <br> <br>VOID InitSectionData(           // RETURNS: VOID <br>IN BOOL fCommented)// TRUE if section is commented out <br>{ <br>    DEBUGPRIVATE("InitSectionData()\n"); <br> <br>// Record whether or not section is commented out <br>fCurSectionComment = fCommented; <br> <br>ifstCurSection =IFST_UNKNOWN; <br> <br>iflvBCC.fValid =FALSE; <br>iflvCC.fValid =FALSE; <br>iflvDATE.fValid =FALSE; <br>iflvENCRYPTION.fValid =FALSE; <br>iflvFOLDER.fValid =FALSE; <br>iflvFROM.fValid =FALSE; <br>iflvPATH.fValid =FALSE; <br>iflvPRIORITY.fValid =FALSE; <br>iflvPROFILENAME.fValid =FALSE; <br>iflvPROFILEPASSWORD.fValid =FALSE; <br>iflvPSTNAME.fValid =FALSE; <br>iflvPSTPASSWORD.fValid =FALSE; <br>iflvSUBJECT.fValid =FALSE; <br>iflvTIME.fValid =FALSE; <br>iflvTO.fValid =FALSE; <br>iflvXATTACH.fValid =FALSE; <br>iflvXTEXT.fValid =FALSE; <br>} <br> <br> <br>//$--HrIsSectionLine----------------------------------------------------------- <br>// <br>// DESCRIPTION: Determine if an input line is a section header (ie., first <br>//non-whitespace char is '['). <br>// <br>// INPUT:       [pch]-- Ptr to input line. <br>// <br>// OUTPUT:      lpbIsSectionLine    --  BOOLEAN pointer.  TRUE if is section line. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful <br>//                          E_INVALIDARG if bad parameter <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrIsSectionLine(                    // RETURNS: HRESULT <br>    IN      CHAR *  pch,                    // input line <br>    OUT     BOOL * lpbIsSectionLine     // boolean pointer <br>    ) <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("HrIsSectionLine()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrIsSectionLine(pch, lpbIsSectionLine); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>// skip leading white space and comment characters <br>    while ( (isspace(*pch) &gt; 0) || (*pch == cSemiColon) ) <br>{ <br>        pch++; <br>} <br> <br>*lpbIsSectionLine = (*pch == cBeginSectLine);// All sections must start with an '[' <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrOpenFolder------------------------------------------------------------ <br>// <br>// DESCRIPTION: Open the folder specified by the iflvFOLDER static variable. <br>// <br>// INPUT:       None. <br>// <br>// OUTPUT:      lppFolder   --  folder pointer pointer <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//              E_INVALIDARG if invalid parameters, <br>//              E_FAIL otherwise <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrOpenFolder(                   // RETURNS: HRESULT <br>    OUT LPMAPIFOLDER * lppFolder)   // output folder pointer pointer <br>{ <br>    HRESULT         hr          =   NOERROR;   <br>    UINT            cchFolder   =   0;      // # characters in folder <br> <br>    const CHAR      chSep    =   cBackSlash;      // separator character <br> <br>    DEBUGPRIVATE("HrOpenFolder()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrOpenFolder(lppFolder); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br>     <br>    *lppFolder = NULL;  // initialize <br> <br>    // Strip the trailing '\', if any. <br>    cchFolder = lstrlen(iflvFOLDER.achValue); <br> <br>    ASSERTERROR((cchFolder &gt; 0), "Bad cchFolder"); <br> <br>    if ( iflvFOLDER.achValue[cchFolder - 1] == cBackSlash ) <br>    { <br>        iflvFOLDER.achValue[cchFolder - 1] = 0; <br>    } <br> <br>    // Determine if getting root folder <br>if (iflvFOLDER.achValue[0] == 0) <br>    { <br>*lppFolder = lpRootFolder; <br>         <br>        goto cleanup; <br>    } <br> <br>    // Otherwise, opent the pathed folder. <br>    hr = HrMAPIOpenFolderEx( <br>        lpMdb,                      // message store pointer <br>        chSep,                      // folder path separator character <br>        iflvFOLDER.achValue,        // folder path <br>        lppFolder);                 // pointer to folder opened <br> <br>    if ( FAILED(hr) ) <br>    { <br>EventLogMsg( <br>POPPST_FOLDER_ERROR, <br>2, iflvFOLDER.achValue, SZ_BASE16(hr), <br>            0); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParseDateValue-------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a DATE= entry for the value. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     HRESULT --  NOERROR if success, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL if call fails. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrParseDateValue(           // RETURNS: HRESULT <br>    IN      CHAR *  pch             // date string <br>    ) <br>{ <br>    HRESULT hr  =   NOERROR;    // return value <br>    static CHAR    DateTemplate[] = "dddd-dd-dd"; <br>    INT     i = 0; <br> <br>    DEBUGPRIVATE("HrParseDateValue()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrParseDateValue(pch); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    for (i = 0; i &lt; sizeof(DateTemplate); i++) <br>    { <br>        if (DateTemplate[i] == cDate) <br>        { <br>            if (!isdigit(*(pch + i))) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br>        } <br>        else <br>        { <br>            if (DateTemplate[i] != *(pch + i)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br>        } <br>    } <br> <br>// Given that we can't REALLY do range checking without knowing about <br>// leap years, we rely on SystemTimeToFileTime() to later do complete range <br>// checking on the year/month/day values.  We can cast the values to words <br>// without a problem, given we know there are a most 4 decimal digits. <br> <br>stCurMsg.wYear =(WORD)atol(pch); <br>stCurMsg.wMonth =(WORD)atol(pch + 5); <br>stCurMsg.wDay =(WORD)atol(pch + 8); <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParseEncryptionValue---------------------------------------------------- <br>// <br>// DESCRIPTION: Parse an ENCRYPTION= entry for the value. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL if call fails <br>// <br>//--------------------------------------------------------------------------- <br>HRESULT HrParseEncryptionValue(         // RETURNS: HRESULT <br>    IN      CHAR *  pch                 // input encryption string <br>    ) <br>{ <br>    HRESULT hr  =   NOERROR;    // return value <br> <br>    DEBUGPRIVATE("HrParseEncryptionValue()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParseEncryptionValue(pch); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>if (!_stricmp(pch, "ON")) <br>bEncryptionNewPST = TRUE; <br>else if (!_stricmp(pch, "OFF")) <br>bEncryptionNewPST = FALSE; <br>else <br>    { <br>    hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParseEntryLine-------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse an ini file section entry line to determine what kind of <br>//entry it is, and store the value.  Section entry lines are the <br>//lines that follow the section header. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL if call fails. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrParseEntryLine(       // RETURNS: HRESULT <br>    IN      CHAR *  pch         // input line <br>    ) <br>{ <br>    HRESULT             hr  =                   NOERROR; <br>    INIFILEPARSEINFO *  aifpiEntry  =           NULL; <br>    CHAR                chTmp   =               0; <br>    INT                 cKeywords   =           0; <br>    INT                 i   =                   0; <br>    CHAR *              pchKeyword  =           NULL; <br> <br>    DEBUGPRIVATE("HrParseEntryLine()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrParseEntryLine(pch); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    if (ifstCurSection == IFST_MESSAGE) <br>    { <br>        aifpiEntry = aifpiMessageEntry; <br>        cKeywords = sizeof(aifpiMessageEntry)/sizeof(aifpiMessageEntry[0]); <br>    } <br>    else if (ifstCurSection == IFST_NEWPST) <br>    { <br>        aifpiEntry = aifpiNewPSTEntry; <br>        cKeywords = sizeof(aifpiNewPSTEntry)/sizeof(aifpiNewPSTEntry[0]); <br>    } <br>    else if (ifstCurSection == IFST_PROFILE) <br>    { <br>        aifpiEntry = aifpiProfileEntry; <br>        cKeywords = sizeof(aifpiProfileEntry)/sizeof(aifpiProfileEntry[0]); <br>    } <br>    else <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Save ptr to keyword. <br> <br>    pchKeyword = pch; <br> <br>    // Scan for end of keyword and delimit keyword, saving replaced char. <br> <br>    while (*pch != cEquals &amp;&amp; *pch != 0) <br>        pch++; <br> <br>    if (*pch == 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    chTmp = *pch; <br>    *pch  = 0; <br> <br>    // Compare putative keyword against valid section keywords. <br> <br>    for (i = 0; i &lt; cKeywords; i++) <br>        if (!_stricmp(pchKeyword, aifpiEntry[i].pszKeyword)) <br>            break; <br> <br>    *pch = chTmp; <br> <br>    if (i == cKeywords) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    hr = aifpiEntry[i].HrParseFunction(pch + 1); <br> <br>    // Store result if success. <br> <br>    if ( SUCCEEDED(hr) ) <br>    { <br>// Check for duplicate entries in a section: <br> <br>if (aifpiEntry[i].piflv-&gt;fValid) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>aifpiEntry[i].piflv-&gt;fValid = TRUE; <br>        strcpy(aifpiEntry[i].piflv-&gt;achValue, pch + 1); <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParseLine--------------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse an ini file line, and store the value if it is a section <br>//entry line. <br>// <br>// INPUT:       None. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrParseLine(VOID)       // RETURNS: HRESULT <br>{ <br>    HRESULT     hr  =       NOERROR; <br>    CHAR *      pch =       &amp;achIniLine[0]; <br>BOOLfCommentedSection=FALSE;// TRUE if see commented section <br> <br>    DEBUGPRIVATE("HrParseLine()\n"); <br> <br>    while ( isspace(*pch) &gt; 0 )// Skip leading line whitespace. <br>        pch++; <br> <br>    if (*pch == 0)               // It is a blank line. <br>    { <br>        goto cleanup; <br>    } <br> <br>    if (*pch == cSemiColon)           // It is a comment. <br>    { <br>// Skip intervening white spaces and comments <br>while ( (isspace(*pch) &gt; 0) || (*pch == cSemiColon) ) <br>{ <br>pch++; <br>} <br> <br>// Check to see if the commented out line is a section header. <br>// If if is, then the effect is that the entire section is <br>// commented out. <br>if ( *pch == cBeginSectLine ) <br>{ <br>// have a commented-out section <br>fCommentedSection = TRUE; <br> <br>// continue on to next if statement <br>} <br> <br>else <br>{ <br>// commented out line, ignore it. <br>        goto cleanup; <br>} <br>    } <br> <br>    if ( *pch == cBeginSectLine )  // It is a section, or is invalid <br>    { <br>iSection = iLine; <br>        hr = HrParseSectionLine( <br>        pch + 1, // pointer to section keyword <br>        fCommentedSection);// TRUE if have a commented-out section <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br>    } <br>    else                            // It is a section entry, or is invalid. <br>    { <br>        hr = HrParseEntryLine(pch); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParseNonNullStringValue----------------------------------------------- <br>// <br>// DESCRIPTION: Parse a non-null string value for an entry line (ie., the <br>//null string is not a permissible value). <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// HRESULT:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if invalid parameter, <br>//                          E_FAIL if call fails <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrParseNonNullStringValue(          // RETURNS: HRESULT <br>    IN      CHAR *  pch                     // input line <br>    ) <br>{ <br>    HRESULT hr  =   NOERROR; <br> <br>    DEBUGPRIVATE("HrParseNonNullStringValue()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrParseNonNullStringValue(pch); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    if ( *pch == 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParsePriorityValue---------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a PRIORITY= section entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// HRESULT:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL if call fails <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrParsePriorityValue(           // RETURNS: HRESULT <br>    IN      CHAR *  pch                 // input line <br>    ) <br>{ <br>    HRESULT hr  =   NOERROR;    // return value <br> <br>    DEBUGPRIVATE("HrParsePriorityValue()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrParsePriorityValue(pch); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>if (!_stricmp(pch, "NORMAL")) <br>    { <br>lPriorityCurMsg = PRIO_NORMAL; <br>        lImportanceCurMsg = IMPORTANCE_NORMAL; <br>    } <br>else if (!_stricmp(pch, "HIGH")) <br>    { <br>lPriorityCurMsg = PRIO_URGENT; <br>        lImportanceCurMsg = IMPORTANCE_HIGH; <br>    } <br>else if (!_stricmp(pch, "LOW")) <br>    { <br>lPriorityCurMsg = PRIO_NONURGENT; <br>        lImportanceCurMsg = IMPORTANCE_LOW; <br>    } <br>else <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParseSectionLine------------------------------------------------------ <br>// <br>// DESCRIPTION: Parse an ini file section header line.  <br>// <br>// INPUT:       [pch]-- Ptr to section keyword <br>//fComment--TRUE if section is commented-out <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if invalid input, <br>//                          E_FAIL if call fails. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrParseSectionLine( <br>    IN      CHAR *  pch,            // input line <br>INBOOL fComment// TRUE if section is commented <br>    ) <br>{ <br>    HRESULT     hr  =   NOERROR; <br>    CHAR        chTmp   =   0; <br>    CHAR *      pchKeyword  =   NULL; <br> <br>    DEBUGPRIVATE("HrParseSectionLine()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrParseSectionLine(pch, fComment); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>InitSectionData( <br>fComment);// TRUE if section is commented <br> <br>    // Save ptr to keyword. <br> <br>    pchKeyword = pch; <br> <br>    // Scan for end of keyword and delimit keyword, saving replaced char. <br> <br>    while (!isspace(*pch) &amp;&amp; *pch != cEndSectLine &amp;&amp; *pch != 0) <br>        pch++; <br> <br>    if (*pch == 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    chTmp = *pch; <br>    *pch  = 0; <br> <br>    // Compare putative keyword against valid section keywords. <br> <br>    if (!_stricmp(pchKeyword, "message")) <br>    { <br>// Numeric value may follow "message" keyword.  We don't use it, <br>// but we do a rough check that what we are seeing is consistent <br>// with what we expect. <br> <br>        *pch = chTmp; <br> <br>        while ( isspace(*pch) &gt; 0 ) <br>            pch++; <br> <br>        if (!isdigit(*pch)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>pch++; <br> <br>        while (isdigit(*pch)) <br>            pch++; <br> <br>        // Check for proper section entry termination. <br> <br>        if (*pch == cEndSectLine &amp;&amp; *(pch + 1) == 0) <br>        { <br>            ifstCurSection =IFST_MESSAGE; <br>        } <br>    } <br>    else if (!_stricmp(pchKeyword, "newpst")) <br>    { <br>        // Check for proper section entry termination. <br>        // NewPST sections don't have a value. <br> <br>        *pch = chTmp; <br> <br>        if (*pch == cEndSectLine &amp;&amp; *(pch + 1) == 0) <br>        { <br>            ifstCurSection =IFST_NEWPST; <br>        } <br>    } <br>    else if (!_stricmp(pchKeyword, "profile")) <br>    { <br>        // Check for proper section entry termination. <br>        // Profile sections don't have a value. <br> <br>        *pch = chTmp; <br> <br>        if (*pch == cEndSectLine &amp;&amp; *(pch + 1) == 0) <br>        { <br>            ifstCurSection =IFST_PROFILE; <br>        } <br>    } <br>    else <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        *pch = chTmp;   // Invalid section keyword. <br> <br>        goto cleanup; <br> <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParseStringValue-------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a string value for an entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// HRESULT:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrParseStringValue(     // RETURNS: HRESULT <br>    IN      CHAR *  pch         // input line <br>    ) <br>{ <br>    HRESULT hr  =   NOERROR; <br> <br>    DEBUGPRIVATE("HrParseStringValue()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrParseStringValue(pch); <br>     <br>    // Anything is a valid string! <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrParseTimeValue-------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a TIME= section entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL if call fails. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrParseTimeValue(           // RETURNS: HRESULT <br>    IN      CHAR *  pch             // input line <br>    ) <br>{ <br>    HRESULT hr  =   NOERROR; <br>    long    Hour    =   0; <br>    long    Minute  =   0; <br>    long    Second = 0; <br> <br>    DEBUGPRIVATE("HrParseTimeValue()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrParseTimeValue(pch); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    if (!isdigit(*pch)          || <br>        !isdigit(*(pch + 1))    || <br>        *(pch + 2) != cColon) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    Hour = atol(pch); <br> <br>    if (Hour &gt; 23) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>stCurMsg.wHour = (WORD)Hour; <br> <br>    pch += 3; <br> <br>    if (!isdigit(*pch)                              || <br>        !isdigit(*(pch + 1))                        || <br>        (*(pch + 2) != cColon &amp;&amp; *(pch + 2) != 0)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    Minute = atol(pch); <br> <br>    if (Minute &gt; 59) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>stCurMsg.wMinute = (WORD)Minute; <br> <br>    if (*(pch + 2) == cColon) <br>    { <br>        pch += 3; <br> <br>        if (!isdigit(*pch)                              || <br>            !isdigit(*(pch + 1))                        || <br>            *(pch + 2) != 0) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        Second = atol(pch); <br> <br>        if (Second &gt; 59) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br>    } <br> <br>stCurMsg.wSecond = (WORD)Second; <br> <br>    if (Hour * 60L * 60L + Minute * 60L + Second &gt;= 24L * 60L * 60L) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrProcessMessageSection--------------------------------------------------- </code></pre>
<p>
</p>
<pre><code>// <br>// DESCRIPTION: Process the information parsed in a message section, creating <br>//a message in a pst. <br>// <br>// INPUT:       None. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrProcessMessageSection(VOID)        // RETURNS: HRESULT <br>{ <br>HRESULThr  =   NOERROR; <br>LPADRLISTlpRecips =NULL; <br>LPMAPIFOLDERlpFolder =NULL; <br>LPMESSAGElpMsg =NULL; <br> <br>    DEBUGPRIVATE("HrProcessMessageSection()\n"); <br> <br>// Confirm that a NewPST or Profile section has been parsed and a MAPI <br>// session has been established. <br>if (!lpSession) <br>{ <br>        hr = HR_LOG(E_FAIL); <br> <br>EventLogMsg( <br>POPPST_ORDER_ERROR, <br>1, SZ_BASE10(iSection), <br>0); <br> <br>goto cleanup; <br>} <br> <br>// Confirm that the Message section has the required section entries. <br> <br>if (!iflvDATE.fValid|| <br>!iflvFOLDER.fValid|| <br>!iflvFROM.fValid|| <br>!iflvPRIORITY.fValid|| <br>!iflvSUBJECT.fValid|| <br>!iflvTIME.fValid|| <br>!iflvTO.fValid) <br>{ <br>        hr = HR_LOG(E_FAIL); <br> <br>EventLogMsg( <br>POPPST_MISSING_ERROR, <br>2, TEXT("Message"), SZ_BASE10(iSection), <br>0); <br> <br>goto cleanup; <br>} <br> <br>// Convert message date/time to FILETIME. <br> <br>if (!SystemTimeToFileTime(&amp;stCurMsg, &amp;ftCurMsg)) <br>{ <br>        INTERNAL_ERROR( TEXT("SystemTimeToFileTime()"), GetLastError()); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Open the specified folder, or if it does not exist, create it. <br>// If the root folder was specified, the value of pRootFolder will <br>// be returned. <br>    hr = HrOpenFolder(&amp;lpFolder); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>// Create the message. <br>hr = lpFolder-&gt;CreateMessage(NULL, MAPI_DEFERRED_ERRORS, &amp;lpMsg); <br> <br>if (FAILED(hr)) <br>{ <br>        INTERNAL_ERROR( TEXT("IMAPIFolder::CreateMessage()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Set the sender, subject, date/time, and priority properties. <br>    hr = HrSetMessageProperties(lpMsg); <br> <br>    if ( FAILED(hr) ) <br>    { <br>goto cleanup; <br>    } <br> <br>// Write the message text, if any <br>hr = HrWriteMessageText(lpMsg, iflvXTEXT.achValue); <br> <br>    if ( FAILED(hr) ) <br>    { <br>goto cleanup; <br>    } <br> <br>// Resolve recipient name information. <br>hr = HrResolveRecipientNames(&amp;lpRecips); <br> <br>    if ( FAILED(hr) ) <br>    { <br>goto cleanup; <br>    } <br> <br>// Set recipient info. <br>hr = lpMsg-&gt;ModifyRecipients(MODRECIP_ADD, lpRecips); <br> <br>if (FAILED(hr)) <br>{ <br>        INTERNAL_ERROR( TEXT("IMessage::ModifyRecipients()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// If there is an attachment, create it. <br>if (iflvXATTACH.fValid) <br>{ <br>hr = HrCreateMessageAttachment(lpMsg, iflvXATTACH.achValue); <br> <br>        if ( FAILED(hr) ) <br>        { <br>goto cleanup; <br>        } <br>} <br> <br>    // save the message! <br>hr = lpMsg-&gt;SaveChanges(0); <br> <br>if (FAILED(hr)) <br>{ <br>        INTERNAL_ERROR( TEXT("IMAPIProp::SaveChanges()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>// Done! <br>cMsgs++; <br> <br>cleanup: <br> <br>if (lpRecips) <br>{ <br>// Have to release the SPropVal allocations first. <br>ULONGi; <br> <br>for (i = 0; i &lt; lpRecips-&gt;cEntries; i++) <br>MAPIFREEBUFFER(lpRecips-&gt;aEntries[i].rgPropVals); <br> <br>MAPIFREEBUFFER(lpRecips); <br>} <br> <br>ULRELEASE(lpMsg); <br> <br>if (lpFolder &amp;&amp; lpFolder != lpRootFolder) <br>ULRELEASE(lpFolder); <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrProcessNewPSTSection---------------------------------------------------- <br>// <br>// DESCRIPTION: Process the information parsed in a newpst section, creating <br>//a temporary profile and new pst and logging onto a MAPI session <br>//for the temporary profile.  Also open the new pst and its <br>//root folder. <br>// <br>// INPUT:       None. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise. <br>// <br>// Notes:If this function fails, the error should be treated as a <br>//fatal error. <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrProcessNewPSTSection(VOID)        // RETURNS: HRESULT <br>{ <br>HRESULThr  =   NOERROR; <br> <br>    DEBUGPRIVATE("HrProcessNewPSTSection()\n"); <br> <br>// Confirm that this is the first NewPST section we have encountered, <br>// and there was not a Profile section. <br>if (lpSession) <br>{ <br>        hr = HR_LOG(E_FAIL); <br> <br>EventLogMsg( <br>POPPST_MUTUAL_EXCLUSIVENESS_ERROR, <br>1, SZ_BASE10(iSection), <br>0); <br> <br>goto cleanup; <br>} <br> <br>// Confirm that it has the required section entries. <br> <br>if (!iflvENCRYPTION.fValid|| <br>!iflvPATH.fValid|| <br>!iflvPSTNAME.fValid|| <br>!iflvPSTPASSWORD.fValid) <br>{ <br>        hr = HR_LOG(E_FAIL); <br> <br>EventLogMsg( <br>POPPST_MISSING_ERROR, <br>2, TEXT("NewPST"), SZ_BASE10(iSection), <br>            0); <br> <br>goto cleanup; <br>} <br> <br>fTmpProf = TRUE; // Flag used to indicate we are using a temporary profile. <br> <br>// Create the requested PST.  This also creates a new profile, and we must <br>// get a session on the new profile in order to further manipulate the PST. <br>hr = HrCreatePersonalStore(iflvPATH.achValue, <br>  bEncryptionNewPST ? <br>  PSTF_COMPRESSABLE_ENCRYPTION : <br>  PSTF_NO_ENCRYPTION, <br>  iflvPSTNAME.achValue, <br>  iflvPSTPASSWORD.achValue, <br>  &amp;lpszProfileName, <br>  &amp;lpszProfilePassword); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>POPPST_NEWPST_ERROR, <br>2, iflvPSTNAME.achValue, SZ_BASE16(hr), <br>0); <br> <br>goto cleanup; <br>} <br> <br>// Save profile values (they will be used later by HrProcessProfileSection()). <br> <br>iflvPROFILENAME.fValid = TRUE; <br> <br>strcpy(iflvPROFILENAME.achValue, lpszProfileName); <br> <br>iflvPROFILEPASSWORD.fValid = TRUE; <br> <br>strcpy(iflvPROFILEPASSWORD.achValue, lpszProfilePassword); <br> <br>// Log onto a session. <br> <br>hr = HrProcessProfileSection(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>goto cleanup; <br>    } <br> <br>    // warn the user that a temporary profile is being used <br>EventLogMsg( <br>POPPST_TEMPORARY_PROFILE_WARNING, <br>0, <br>0); <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br> <br>//$--HrProcessProfileSection------------------------------------------------- <br>// <br>// DESCRIPTION: Process the information parsed in a profile section, logging <br>//onto a MAPI profile session and opening the message store, its <br>//root folder, and the pab if one is available. <br>// <br>// INPUT:       None. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise. <br>// <br>// Notes:If this function fails, the error should be treated as a <br>//fatal error.  On successful completion, lpSession, lpMdb, and <br>//lpRootFolder are valid.  These are all opened here and left <br>//open because they need to be open during message processing. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrProcessProfileSection(VOID)       // RETURNS: HRESULT <br>{ <br>HRESULThr          =   NOERROR; <br>LPSRowSetlpRows      =NULL; <br>    ULONG           cbEid       =   0;      // # bytes in entry identifier <br>    LPENTRYID       lpEid       =   NULL;   // entry identifier <br>    ULONG    ulObjType   =   0;      // MAPI object type <br> <br>    DEBUGPRIVATE("HrProcessProfileSection()\n"); <br> <br>// Confirm that this is the first Profile section we have encountered, <br>// and there was not a NewPST section. <br>if (lpSession) <br>{ <br>        hr = HR_LOG(E_FAIL); <br> <br>EventLogMsg( <br>POPPST_MUTUAL_EXCLUSIVENESS_ERROR, <br>1, SZ_BASE10(iSection), <br>0); <br> <br>goto cleanup; <br>} <br> <br>// Confirm that it has the required section entries. <br> <br>if (!iflvPROFILEPASSWORD.fValid|| <br>!iflvPROFILENAME.fValid) <br>{ <br>        hr = HR_LOG(E_FAIL); <br> <br>EventLogMsg( <br>POPPST_MISSING_ERROR, <br>2, TEXT("Profile"), SZ_BASE10(iSection), <br>            0); <br> <br>goto cleanup; <br>} <br> <br>// Log on to the specified profile. <br> <br>hr = MAPILogonEx(0, <br>   iflvPROFILENAME.achValue, <br>   iflvPROFILEPASSWORD.achValue, <br>   ulMapiLogonFlags, <br>   &amp;lpSession); <br> <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>POPPST_LOGON_ERROR, <br>2, iflvPROFILENAME.achValue, SZ_BASE16(hr), <br>            0); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>    ASSERTERROR(!FBadUnknown(lpSession), "Bad lpSession"); <br> <br>// Find the default message store in the message stores table. <br>    hr = HrMAPIFindDefaultMsgStore( <br>                lpSession,      // MAPI session pointer <br>                &amp;cbEid,         // entry identifier byte count <br>                &amp;lpEid);        // entry identifier <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrMAPIFindDefaultMsgStore"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>// Open the default message store. <br>hr = lpSession-&gt;OpenMsgStore( <br>                0, <br>    cbEid,  // entry id byte count <br>lpEid,  // entry id <br>NULL, <br>MDB_WRITE | MAPI_DEFERRED_ERRORS,  // want write access <br>&amp;lpMdb);    // MDB pointer <br> <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>POPPST_OPEN_STORE_ERROR, <br>2, iflvPROFILENAME.achValue, SZ_BASE16(hr), <br>            0); <br> <br>        hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>    ASSERT_IUNKNOWN_PTR(lpMdb, "Bad lpMdb"); <br> <br>// Open the root folder in the default message store.  OpenEntry() opens <br>// the root folder if lpEntryID is NULL. <br>hr = lpMdb-&gt;OpenEntry(0, <br>  NULL, <br>  NULL, <br>  MAPI_MODIFY|MAPI_DEFERRED_ERRORS, <br>  &amp;ulObjType, <br>  (LPUNKNOWN *)&amp;lpRootFolder); <br> <br>if (FAILED(hr)) <br>{ <br>        INTERNAL_ERROR( TEXT("IMsgStore::OpenEntry()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (ulObjType != MAPI_FOLDER) <br>{ <br>        INTERNAL_ERROR( TEXT("IMsgStore::OpenEntry()"), MAPI_E_UNEXPECTED_TYPE); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>    ASSERTERROR(!FBadUnknown(lpRootFolder), "Bad lpRootFolder"); <br> <br>    // open address book if not using a temporary profile <br>    if ( fTmpProf == FALSE ) <br>    { <br>        // open the address book <br>    hr = lpSession-&gt;OpenAddressBook( <br>            0,              // window handle <br>            NULL,           // interface pointer <br>            AB_NO_DIALOG,   // don't want dialogue box <br>            &amp;lpAdrBook);    // address book pointer <br> <br>    if (FAILED(hr)) <br>    { <br>EventLogMsg( <br>POPPST_AB_ERROR, <br>2, iflvPROFILENAME.achValue, SZ_BASE16(hr), <br>0); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>    } <br> <br>        ASSERTERROR(!FBadUnknown(lpAdrBook), "Bad lpAdrBook"); <br> <br>    }   // end if not using temporary profile <br> <br>cleanup: <br> <br>    // free MAPI buffers and release MAPI objects <br>    MAPIFREEBUFFER(lpEid); <br> <br>FREEPROWS(lpRows); <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--HrResolveSenderName------------------------------------------------------ <br>// <br>// DESCRIPTION: Resolve the sender's name, if possible.   <br>//              Also checks number of sender names. <br>// <br>// INPUT:       pszName --  sender's display name <br>// <br>// OUTPUT:      ppAdrList   --  pointer to address list pointer <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// --------------------------------------------------------------------------- <br>HRESULT HrResolveSenderName( <br>        IN LPSTR pszName,   // sender's display name <br>        OUT LPADRLIST * ppAdrList)  // pointer to address list pointer <br>{ <br>    HRESULT hr      =   NOERROR; <br>    ULONG   cNames  =   0;          // # of sender names <br>LPSTR *lppszTemp=NULL;// array of string pointers <br> <br>    const ULONG cProps  =   2;      // # of property values <br>const LPSTRpszSep=";";// separator character <br> <br>    // property value array <br>    SPropValue  rgPropVals[cProps]  =   {0}; <br>     <br>    DEBUGPRIVATE("HrResolveSenderName()\n"); <br> <br>    hr = CHK_HrResolveSenderName(pszName, ppAdrList); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Check number of sender names.  There should only be one. <br>hr = HrStrTokAll( <br>pszName,// sender names <br>(LPSTR) pszSeparator,// separator character <br>&amp;cNames,// number of sender names <br>&amp;lppszTemp);// array of string pointers <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrStrTokAll()"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>    if ( cNames != 1 ) <br>    { <br>EventLogMsg( <br>POPPST_FROM_ERROR, <br>1, SZ_BASE10(iSection), <br>0); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>ASSERT_READ_PTR(lppszTemp, sizeof(LPSTR) * cNames, "Bad lppszTemp"); <br> <br>    // Only resolve sender name if we are not using a temporary <br>    // profile! <br>    if ( fTmpProf == FALSE ) <br>    { <br>        // Set up property value with know values. <br>        rgPropVals[0].ulPropTag = PR_DISPLAY_NAME; <br>        rgPropVals[0].Value.lpszA = pszName; <br> <br>        rgPropVals[1].ulPropTag = PR_RECIPIENT_TYPE; <br>        rgPropVals[1].Value.l = MAPI_TO; <br> <br>        // Create an address list for our sender name. <br>        hr = HrMAPICreateAddressList( <br>                cProps,         // # of property values <br>                rgPropVals,     // property value array <br>                ppAdrList);     // address list pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("HrMAPICreateAddressList()"), hr); <br> <br>            goto cleanup; <br>        } <br> <br>        // Resolve the name <br>    hr = lpAdrBook-&gt;ResolveName( <br>            0,              // window handle <br>            0,  <br>            NULL,  <br>            *ppAdrList);    // address list pointer <br> <br>        // Handle case where sender name can't be resolved. <br>        if ( FAILED(hr) ) <br>        { <br>            // some fatal error <br>EventLogMsg( <br>POPPST_SENDER_ERROR, <br>3, pszName, SZ_BASE10(iSection), SZ_BASE16(hr), <br>0); <br> <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ASSERTERROR(!IsBadReadPtr(ppAdrList, sizeof(LPADRLIST)), <br>                    "Bad ppAdrList"); <br>        ASSERTERROR(!IsBadReadPtr(*ppAdrList, sizeof(ADRLIST)), <br>                    "Bad *ppAdrList"); <br> <br>    }   // end if have a "real" address book <br> <br>cleanup: <br> <br>// Free MAPI buffers <br>MAPIFREEBUFFER(lppszTemp); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrResolveRecipientNames------------------------------------------------- <br>// <br>// DESCRIPTION: Get the properties needed for the recipients using the input <br>//information and resolves the recipient names, if possible. <br>// <br>// OUTPUT       [lppAdrList]-- Ptr to output address list with resolved <br>//   names. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input parameter, <br>//                          E_OUTOFMEMORY if memory problems <br>//                          E_FAIL if call fails. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrResolveRecipientNames(            // RETURNS: HRESULT <br>OUTLPADRLIST *lppAdrList      // address list pointer <br>) <br>{ <br>#defineCRECIPLST3// # of recipient lists <br> <br>    HRESULT         hr  =   NOERROR; <br>ULONGcRecips =   0;// total # of recipients <br>ULONGcToRecips=0;// # of TO recipients <br>ULONGcCCRecips=0;// # of CC recipients <br>ULONGcBCCRecips=0;// # of BCC recipients <br>LPADRLISTlpAdrList =NULL; <br>LPSTR *ppch =   0; <br>LPSTR *lppszToRecips=NULL;// array of tokenized TO recipients <br>LPSTR *lppszCCRecips=NULL;// array of tokenized CC recipients <br>LPSTR *lppszBCCRecips=NULL;// array of tokenized BCC recipients <br> <br>// Array of recipient INI file lines <br>INIFILELINEVALUE *apiflv[CRECIPLST]= <br>{ <br>&amp;iflvTO, <br>&amp;iflvCC, <br>&amp;iflvBCC <br>}; <br> <br>// Array of recipient types <br>LONGaRecipTypes[CRECIPLST]= <br>{ <br>MAPI_TO, <br>MAPI_CC, <br>MAPI_BCC <br>}; <br> <br>// Array of tokenized recipient names <br>LPSTR **rgRecipTokens[CRECIPLST]= <br>{ <br>&amp;lppszToRecips, <br>&amp;lppszCCRecips, <br>&amp;lppszBCCRecips <br>}; <br> <br>// Array of recipient counts <br>ULONG *rgcRecips[CRECIPLST]= <br>{ <br>&amp;cToRecips, <br>&amp;cCCRecips, <br>&amp;cBCCRecips <br>}; <br> <br>    DEBUGPRIVATE("HrResolveRecipientNames()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrResolveRecipientNames(lppAdrList); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *lppAdrList = NULL; // initialize <br> <br>if ( iflvTO.fValid ) <br>{ <br>// Count the number of recipients to be resolved by scanning the strings <br>// for semicolons. <br>hr = HrStrTokAll( <br>iflvTO.achValue,// MAPI TO recipients <br>(LPSTR) pszSeparator,// separator character <br>&amp;cToRecips,// # of TO recipients <br>&amp;lppszToRecips);// array of tokenized recipients <br>     <br>    if ( FAILED(hr) ) <br>    { <br>            INTERNAL_ERROR( TEXT("HrStrTokAll()"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>// increment total # of recipients <br>cRecips += cToRecips; <br> <br>ASSERT_READ_PTR(lppszToRecips, sizeof(LPSTR) * cToRecips,  <br>"Bad lppszToRecips"); <br>} <br> <br>if (iflvCC.fValid) <br>    { <br>hr = HrStrTokAll( <br>iflvCC.achValue,// MAPI CC recipients <br>(LPSTR) pszSeparator,// separator character <br>&amp;cCCRecips,// # of CC recipients <br>&amp;lppszCCRecips);// array of tokenized recipients <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("HrStrTokAll()"), hr); <br> <br>            goto cleanup; <br>        } <br> <br>        cRecips += cCCRecips; <br> <br>ASSERT_READ_PTR(lppszCCRecips, sizeof(LPSTR) * cCCRecips,  <br>"Bad lppszCCRecips"); <br>    } <br> <br>if (iflvBCC.fValid) <br>    { <br>hr = HrStrTokAll( <br>iflvBCC.achValue,// MAPI BCC recipients <br>(LPSTR) pszSeparator,// separator character <br>&amp;cBCCRecips,// # of BCC recipients <br>&amp;lppszBCCRecips);// array of tokenized recipients <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("HrStrTokAll()"), hr); <br> <br>            goto cleanup; <br>        } <br> <br>        cRecips += cBCCRecips; <br> <br>ASSERT_READ_PTR(lppszBCCRecips, sizeof(LPSTR) * cBCCRecips,  <br>"Bad lppszBCCRecips"); <br>    } <br> <br>// Check that there is at least one recipient. <br>if ( cRecips &lt;= 0 ) <br>{ <br>EventLogMsg( <br>POPPST_NEED_RECIPIENT_ERROR, <br>1, SZ_BASE10(iSection), <br>0); <br> <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Set up an ADRLIST to be returned to caller.  THREE levels of allocation <br>// are required! <br>hr = MAPIAllocateBuffer(CbNewADRLIST(cRecips), (LPVOID *)&amp;lpAdrList); <br> <br>if ( FAILED(hr) ) <br>{ <br>        INTERNAL_ERROR( TEXT("MAPIAllocateBuffer()"), hr); <br> <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>*lppAdrList = lpAdrList; <br> <br>{ <br>LPSPropValueaPropVals   =   NULL; <br>        ULONG           cPropVals   =   2; <br>ULONGi           =   0; <br>ULONGj           =   0; <br>LPADRENTRYlpAdrEntry  =   NULL; <br>LPSTRlpszName    =   NULL; <br> <br>lpAdrList-&gt;cEntries = cRecips; <br> <br>// Initialize the ADRENTRY's prior to actually allocating the <br>// SPropValue arrays.  This makes cleanup possible if there is an error. <br> <br>for (i = 0; i &lt; cRecips; i++) <br>{ <br>lpAdrList-&gt;aEntries[i].ulReserved1 =0; <br>lpAdrList-&gt;aEntries[i].cValues =cPropVals; <br>lpAdrList-&gt;aEntries[i].rgPropVals =NULL; <br>} <br> <br>// Now allocate and initialize the SPropValue arrays. <br>for (i = 0; i &lt; cRecips; i++) <br>{ <br>hr = MAPIAllocateBuffer(cPropVals * sizeof(SPropValue), <br>  (LPVOID *)&amp;(aPropVals)); <br>if ( FAILED(hr) ) <br>{ <br>                INTERNAL_ERROR( TEXT("MAPIAllocateBuffer()"), hr); <br> <br>                hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>lpAdrList-&gt;aEntries[i].rgPropVals = aPropVals; <br> <br>aPropVals[0].ulPropTag =PR_RECIPIENT_TYPE; <br>aPropVals[0].Value.l =0; <br> <br>aPropVals[1].ulPropTag =PR_DISPLAY_NAME; <br>aPropVals[1].Value.lpszA =NULL; <br>} <br> <br>// Now fill in the property values.  Note that we can count on the <br>// recipient lists to be non-null strings, because we checked for <br>// this during parsing. <br> <br>{ <br>lpAdrEntry = lpAdrList-&gt;aEntries; <br> <br>for (i = 0; i &lt; CRECIPLST; i++) <br>{ <br>if (!apiflv[i]-&gt;fValid) <br>continue; <br> <br>// Retrieve current recipient list of type X. <br>ppch =*(rgRecipTokens[i]); <br> <br>ASSERTERROR(ppch != NULL, "Bad ppch"); <br> <br>for ( j = 0; j &lt; *(rgcRecips[i]); j++ ) <br>{ <br>// Retrieve current recipient <br>lpszName = ppch[j]; <br> <br>ASSERT_STRINGA_PTR(lpszName, "Bad lpszName"); <br> <br>lpAdrEntry-&gt;rgPropVals[0].Value.l = aRecipTypes[i]; <br> <br>hr = MAPIAllocateMore( <br>cbStrLenA(lpszName), <br>lpAdrEntry-&gt;rgPropVals, <br>(LPVOID *) &amp;lpAdrEntry-&gt; <br>rgPropVals[1].Value.lpszA); <br> <br>if ( FAILED(hr) ) <br>{ <br>                        INTERNAL_ERROR( TEXT("MAPIAllocateMore()"), hr); <br> <br>                        hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>lstrcpyA(lpAdrEntry-&gt;rgPropVals[1].Value.lpszA, lpszName); <br> <br>lpAdrEntry++; <br> <br>} <br>} <br>} <br> <br>        // if not using a temporary profile, try to resolve the <br>        // recipient names <br>        if ( fTmpProf == FALSE ) <br>        { <br>    // If we have an address book available, use it to resolve any names <br>    // that you can.  If we don't, then whatever got entered as the user <br>    // name remains as the display name. <br> <br>    // CAVEAT - It seems that MAPI has some sort of bug whereby the first <br>    //attempt to resolve a given name fails.  A subsequent <br>    //identical request will succeed, so the first of two <br>    //messages referencing a recipient won't be resolved, but <br>    //the second will. <br>        hr = lpAdrBook-&gt;ResolveName(0, 0, NULL, lpAdrList); <br> <br>            if ( (hr == MAPI_E_NOT_FOUND) ||  <br>                 (hr == MAPI_E_AMBIGUOUS_RECIP) ) <br>            { <br>                // non-fatal errors.  Just can't resolve <br>                // this recipient name. <br>EventLogMsg( <br>POPPST_RESOLVE_WARNING, <br>2, SZ_BASE10(iSection), SZ_BASE16(hr), <br>                    0); <br> <br>                hr = HR_LOG(NOERROR); <br> <br>                // continue on. <br>            } <br> <br>    if ( FAILED(hr) ) <br>    { <br>                // Some un-recoverable error. <br>EventLogMsg( <br>POPPST_RESOLVE_ERROR, <br>2, SZ_BASE10(iSection), SZ_BASE16(hr), <br>0); <br> <br>                hr = HR_LOG(E_FAIL); <br> <br>    goto cleanup; <br>    } <br> <br>    // Now look for problems reported in the returned ADRLIST. <br>    for (i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>                HRESULT         hrT =   NOERROR; <br>                 <br>    lpAdrEntry = &amp;lpAdrList-&gt;aEntries[i]; <br> <br>    for (j = 0; j &lt; lpAdrEntry-&gt;cValues; j++) <br>    { <br>    LPSPropValuepPropVal; <br>     <br>    pPropVal = &amp;lpAdrEntry-&gt;rgPropVals[j]; <br> <br>    if (PROP_TYPE(pPropVal-&gt;ulPropTag == PT_ERROR)) <br>{ <br>    hrT = pPropVal-&gt;Value.err; <br> <br>break; <br>} <br>                }   // end for this recipient <br> <br>                if ( (hrT == MAPI_E_NOT_FOUND) || <br>                     (hrT == MAPI_E_AMBIGUOUS_RECIP) ) <br>                { <br>                    // not a fatal error.  Just can't <br>                    // resolve a particular recipient. <br>EventLogMsg( <br>POPPST_RESOLVE_WARNING, <br>2, SZ_BASE10(iSection), SZ_BASE16(hrT), <br>                        0); <br> <br>                    hrT = HR_LOG(NOERROR); <br> <br>                    // continue on. <br>                } <br> <br>                // Print out error for this recipient, if any <br>    if ( FAILED(hrT) ) <br>    { <br>                    // Some non-recoverable error. <br>EventLogMsg( <br>POPPST_RESOLVE_ERROR, <br>2, SZ_BASE10(iSection), SZ_BASE16(hrT), <br>                        0); <br> <br>                    hr = HR_LOG(hrT); <br>                    goto cleanup; <br>    } <br> <br>                // continue with next recipient <br> <br>    }   // end for <br>        }   // end if not using temporary PST <br>} <br> <br>cleanup: <br> <br>// Free MAPI buffers <br>MAPIFREEBUFFER(lppszToRecips); <br>MAPIFREEBUFFER(lppszCCRecips); <br>MAPIFREEBUFFER(lppszBCCRecips); <br> <br>// Actual cleanup of *lppAdrList and its substructures must be done by <br>// caller! <br> <br>    RETURN(hr); <br> <br>} <br> <br> <br>//$--HrSetMessageProperties-------------------------------------------------- <br>// <br>// DESCRIPTION: Set the sender, subject, date/time, and priority properties <br>//for the input message. <br>// <br>// INPUT/OUTPUT:lpMsg -- Message for which properties are to be set. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_OUTOFMEMORY if memory problems. <br>//                          E_FAIL if call fails <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrSetMessageProperties(     // RETURNS: HRESULT <br>IN OUT LPMESSAGElpMsg       // message pointer <br>) <br>{ <br>HRESULThr  =           NOERROR; <br>LPSPropProblemArraylpProblems =NULL; <br>    LPADRLIST           lpAdrList =     NULL;   // used to resolve sender's address <br>    ULONG               iProp   =       0;      // property value index <br>    LPSPropValue        lpEntry =       NULL;   // address list entry pointer <br>    ULONG               nValues =       NULL;   // # of property values <br> <br>    // String buffers for resolved sender name values. <br>    CHAR                szFromAddr[cbMaxIniLine]  =   ""; <br>    CHAR                szFromAdrTyp[cbMaxIniLine]=   "";     <br> <br>    // property value indices <br>    const UINT          iMsgClass   =   0; <br>    const UINT          iPriority   =   1; <br>    const UINT          iImportance =   2; <br>    const UINT          iftDeliver  =   3; <br>    const UINT          iftSubmit   =   4; <br>    const UINT          iSubject    =   5; <br>    const UINT          iFromName   =   6; <br>    const UINT          iRepFromName=   7; <br>    const UINT          iDelete     =   8; <br> <br>    const ULONG         cMinValues  =   9; <br>         <br>    // properties which are only set if using a real profile <br>    const UINT          iFromAddr   =   9; <br>    const UINT          iFromAdrTyp =   10; <br>    const UINT          iFromEID    =   11; <br>    const UINT          iFromKey    =   12; <br>    const UINT          iRepFromAddr=   13; <br>    const UINT          iRepFromAdrTyp= 14; <br>    const UINT          iRepFromEID =   15; <br>    const UINT          iRepFromKey =   16; <br> <br>    // maximum number of property values <br>const ULONG    cMaxValues =17; <br> <br>    // array of property values <br>    SPropValue          aPropVals[cMaxValues]  =   {0}; <br> <br>    const UINT          cbEidMax            =   256;    // max EID size <br> <br>    // entry identifier buffer <br>    SizedENTRYID(cbEidMax, eidFrom)         =   {0}; <br> <br>    DEBUGPRIVATE("HrSetMessageProperties()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrSetMessageProperties(lpMsg); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // initiliaze # of property values <br>    nValues = cMinValues; <br> <br>aPropVals[iFromName].ulPropTag = PR_SENDER_NAME; <br>aPropVals[iFromName].Value.lpszA = iflvFROM.achValue; <br> <br>aPropVals[iRepFromName].ulPropTag =PR_SENT_REPRESENTING_NAME; <br>aPropVals[iRepFromName].Value.lpszA =iflvFROM.achValue; <br> <br>aPropVals[iSubject].ulPropTag =PR_SUBJECT; <br>aPropVals[iSubject].Value.lpszA = iflvSUBJECT.achValue; <br> <br>    // PR_DELIVER_TIME is not transmittable. <br>    aPropVals[iftDeliver].ulPropTag = PR_DELIVER_TIME; <br>    aPropVals[iftDeliver].Value.ft = ftCurMsg; <br> <br>    // PR_CLIENT_SUBMIT_TIME is transmittable <br>aPropVals[iftSubmit].ulPropTag = PR_CLIENT_SUBMIT_TIME; <br>aPropVals[iftSubmit].Value.ft =ftCurMsg; <br> <br>    aPropVals[iMsgClass].ulPropTag = PR_MESSAGE_CLASS; <br>    aPropVals[iMsgClass].Value.lpszA = "IPM.Note"; <br> <br>    aPropVals[iPriority].ulPropTag = PR_PRIORITY; <br>    aPropVals[iPriority].Value.l = lPriorityCurMsg; <br> <br>    aPropVals[iImportance].ulPropTag = PR_IMPORTANCE;     <br>    aPropVals[iImportance].Value.l = lImportanceCurMsg; <br> <br>    aPropVals[iDelete].ulPropTag = PR_DELETE_AFTER_SUBMIT; <br>    aPropVals[iDelete].Value.b = TRUE; <br> <br>    // Resolve the sender's address if we are using a real <br>    // profile <br>    if ( fTmpProf == FALSE ) <br>    { <br>        hr = HrResolveSenderName( <br>                iflvFROM.achValue,  // sender's display name <br>                &amp;lpAdrList);        // address list pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Set the EMAIL_ADDRESS, ADDR_TYPE and ENTRYID properties <br>        // based on what HrResolveSenderName returned. <br>        lpEntry = lpAdrList-&gt;aEntries[0].rgPropVals;   // intialize entry pointer <br>        for ( iProp = 0; iProp &lt; lpAdrList-&gt;aEntries[0].cValues; iProp++ ) <br>        { <br>            switch ( lpEntry[iProp].ulPropTag ) <br>            { <br>                case PR_DISPLAY_NAME:            <br>                    // update sender's name with resolved name <br>                    lstrcpyn(iflvFROM.achValue, <br>                    lpEntry[iProp].Value.lpszA, cbMaxIniLine); <br> </code></pre>
<p>
</p>
<pre><code>break; <br> <br>                case PR_ADDRTYPE:             <br>                    // fill in address type <br>                    lstrcpyn( <br>                        szFromAdrTyp,  <br>                        lpEntry[iProp].Value.lpszA, <br>                        cbMaxIniLine); <br> <br>                    aPropVals[iFromAdrTyp].ulPropTag = PR_SENDER_ADDRTYPE; <br>                    aPropVals[iFromAdrTyp].Value.lpszA = <br>                        szFromAdrTyp; <br> <br>                    aPropVals[iRepFromAdrTyp].ulPropTag = PR_SENT_REPRESENTING_ADDRTYPE; <br>                    aPropVals[iRepFromAdrTyp].Value.lpszA = <br>                        szFromAdrTyp; <br> <br>                    break; <br> <br>                case PR_EMAIL_ADDRESS: <br>                    // Fill in email address <br>                    lstrcpyn( <br>                        szFromAddr, <br>                        lpEntry[iProp].Value.lpszA, <br>                        cbMaxIniLine); <br> <br>                    aPropVals[iFromAddr].ulPropTag = PR_SENDER_EMAIL_ADDRESS; <br>                    aPropVals[iFromAddr].Value.lpszA = <br>                        szFromAddr; <br> <br>                    aPropVals[iRepFromAddr].ulPropTag =  <br>                        PR_SENT_REPRESENTING_EMAIL_ADDRESS; <br>                    aPropVals[iRepFromAddr].Value.lpszA = <br>                        szFromAddr; <br> <br>                    break; <br> <br>                case PR_ENTRYID: <br>                    // fill in entry identifier                <br>                    CopyMemory( <br>                        &amp;eidFrom.ab, <br>                        lpEntry[iProp].Value.bin.lpb, <br>                        lpEntry[iProp].Value.bin.cb); <br> <br>                    aPropVals[iFromEID].ulPropTag = PR_SENDER_ENTRYID;                                                         <br>                    aPropVals[iFromEID].Value.bin.cb = <br>                        lpEntry[iProp].Value.bin.cb; <br>                    aPropVals[iFromEID].Value.bin.lpb = <br>                        (BYTE *) &amp;eidFrom.ab;                     <br> <br>                    aPropVals[iRepFromEID].ulPropTag = PR_SENT_REPRESENTING_ENTRYID; <br>                    aPropVals[iRepFromEID].Value.bin.cb = <br>                        lpEntry[iProp].Value.bin.cb; <br>                    aPropVals[iRepFromEID].Value.bin.lpb = <br>                        (BYTE *) &amp;eidFrom.ab;                     <br> <br>                    break; <br>         <br>                case PR_SEARCH_KEY: <br>                    // fill in sender's seach key <br>                    aPropVals[iFromKey].ulPropTag = PR_SENDER_SEARCH_KEY; <br>                    aPropVals[iFromKey].Value.bin.cb = <br>                        lpEntry[iProp].Value.bin.cb; <br>                    aPropVals[iFromKey].Value.bin.lpb = <br>                        lpEntry[iProp].Value.bin.lpb; <br> <br>                    aPropVals[iRepFromKey].ulPropTag =  <br>                        PR_SENT_REPRESENTING_SEARCH_KEY; <br>                    aPropVals[iRepFromKey].Value.bin.cb = <br>                        lpEntry[iProp].Value.bin.cb; <br>                    aPropVals[iRepFromKey].Value.bin.lpb = <br>                        lpEntry[iProp].Value.bin.lpb; <br> <br>                    break; <br> <br>                default: <br>                    // not concerned with this property <br>                    break; <br> <br>            }   // end switch <br>        }   // end for <br> <br>        // Re-set number of property values <br>        nValues = cMaxValues; <br> <br>    }   // end if has real profile <br> <br>    ASSERTERROR((nValues != 0), "Bad nValues"); <br> <br>hr = lpMsg-&gt;SetProps(nValues, aPropVals, &amp;lpProblems); <br> <br>if (FAILED(hr)) <br>{ <br>        INTERNAL_ERROR( TEXT("IMAPIProp::SetProps()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (lpProblems != NULL) <br>{ <br>ULONGi; <br> <br>for (i = 0; i &lt; lpProblems-&gt;cProblem; i++) <br>            INTERNAL_ERROR( TEXT("IMAPIProp::SetProps()"), lpProblems-&gt;aProblem[1].scode); <br>MAPIFREEBUFFER(lpProblems); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    FREEPADRLIST(lpAdrList); <br> <br>RETURN(hr); <br> <br>} <br> <br> <br>//$--HrWriteMessageText------------------------------------------------------ <br>// <br>// DESCRIPTION:    Write the message text (PR_BODY &amp; PR_RTF_COMPRESSED)  <br>//                 to the message, if any <br>// <br>// INPUT: <br>// <br>//[lpMsg]-- Message for which message text is to be written. <br>//[lpszFilePath]-- Path of file containing message text (may be null) <br>// <br>// RETURNS:     NOERROR if successful, <br>//              E_INVALIDARGS if bad input, <br>//              E_FAIL if call fails. <br>// <br>// Notes:We use stream methods to do this, since the SetProps() has a <br>//4KB limit for the size of a property you can set. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrWriteMessageText(             // RETURNS: HRESULT <br>INLPMESSAGElpMsg,          // message pointer <br>INLPSTRlpszFilePath    // message text path, may be null <br>) <br>{ <br>    HRESULT         hr          =   NOERROR; <br>LPSTREAM    lpStrm      =NULL; <br>    ULONG           cbText      =   0;      // # bytes in message text <br>    ULONG           cbBody      =   0;      // # bytes in PR_BODY <br>    STATSTG         sStatStg    =   {0};    // stream status structure <br> <br>    DEBUGPRIVATE("HrWriteMessageText()\n"); <br> <br>    // Check input parameters <br>    hr = CHK_HrWriteMessageText(lpMsg, lpszFilePath); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // If no message text, then we are done. <br>    if ( *lpszFilePath == 0 ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Create the PR_BODY property (needed by the PST, which is not an <br>    // rich-text aware store) from the message body file data. <br>    hr = HrMAPISetPropFromFile( <br>        lpMsg,              // pointer to message object <br>        PR_BODY,            // property tag <br>        lpszFilePath,       // pointer to source file name <br>        &amp;cbBody);           // # bytes in message body <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrMAPISetPropFromFile()"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>    // Build the RTF compressed data for the message (needed <br>    // for RTF-aware stores, such as the Exchange MDB). <br>    // First, open a virtual (bufferred) stream on the input text file. <br>    hr = HrOpenVirtualStreamOnFile( <br>        MAPIAllocateBuffer,     // allocation routine <br>        MAPIFreeBuffer,         // deallocation routine <br>        STGM_READ | STGM_SHARE_EXCLUSIVE,// interface flags <br>        lpszFilePath,           // file name <br>        NULL,                   // file prefix <br>        &amp;lpStrm);               // stream pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrOpenVirtualStreamOnFile()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(lpStrm, "Bad lpStrm"); <br> <br>    // Determine size of stream (not necessarily size of PR_BODY!) <br>    hr = lpStrm-&gt;Stat( <br>        &amp;sStatStg,          // status structure pointer <br>        0);                 // flags <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("VSOF::Stat()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cbText = sStatStg.cbSize.LowPart; <br> <br>    // See if body if too big for us to handle <br>    if ( sStatStg.cbSize.HighPart &gt; 0 ) <br>    { <br>EventLogMsg( <br>POPPST_BODY_ERROR, <br>1, SZ_BASE10(iSection), <br>            0); <br> <br>        hr = HR_LOG(E_NOTIMPL); <br>        goto cleanup; <br>    } <br> <br>    // Create RTF compressed property from the ASCII text <br>    hr = HrTextToRTFCompressed( <br>            cbText, // # of bytes of text <br>            lpStrm, // text stream pointer <br>0,// # of attachment w/ rendering positions <br>NULL,// array of attachment rendering positions <br>            lpMsg,  // message pointer <br>0);// use current code page <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrTextToRTFCompressed()"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br> <br>ULRELEASE(lpStrm); <br> <br>RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
