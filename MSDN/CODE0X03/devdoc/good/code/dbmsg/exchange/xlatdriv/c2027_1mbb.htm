<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XLATDRIV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2027"></a>XLATDRIV.C</h2>
<pre><code>// --xlatdriv.c------------------------------------------------------------------- <br>//  <br>//  Message translation sample. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "convcwrp.h" <br>#include "gwmain.h" <br>#include "ipmconv.h"        // for ipm_in &amp; ipm_out conversion DLLs <br>#include "xlatmsg.h"        // resource string identifiers <br>#include "xlatdriv.chk" <br> <br>// constants <br>#define MAX_MSG_LENGTH              1024            // maximum message length <br>#define APPLICATION_TITLE           TEXT("Message Translation Sample")    // application name <br>#define APPLICATION_EVENT_FILE      TEXT("EDKMSG.DLL")  // event logging message file <br> <br>//  Defined for NT service shell <br>TCHAR szAppName[]       = TEXT("XLATDRIV"); <br>TCHAR szWindowTitle[]   = APPLICATION_TITLE; <br> <br>static LPMAPISESSION    lpSession       = NULL; <br>static LPMDB            lpStore         = NULL; <br>static LPMAPIFOLDER     lpRootFolder    = NULL; <br>static LPMAPIFOLDER     lpMtsInFolder   = NULL; <br>static LPMAPIFOLDER     lpMtsOutFolder  = NULL; <br>static ULONG            cbGalEid        = 0; <br>static LPENTRYID        lpGalEid        = NULL; <br> <br>static HANDLE           hEventLog       = NULL; <br> <br>static HINSTANCE        hInst           = NULL; // program instance handle <br> <br>PVOID  pvConvInstance   = NULL; <br> <br>// Prefix of output *.tmp files. <br>static const LPCTSTR    lpszPrefix      = TEXT("XLT"); <br> <br>// Default inbound/outbound file directory <br>const LPCTSTR           lpszDefaultDir  = TEXT(".\\"); <br> <br>// inbound and outbound file directory <br>static TCHAR    lpszDirectory[MAX_PATH + 1] =   TEXT(""); <br> <br>// Address type used for conversion (Currently "EX") <br>static TCHAR    lpszAddressType[]   =   TEXT(EXCHANGE_ADDRTYPE);   // address type <br> <br>// Conversion options structure for the ipm_in &amp; ipm_out conversion DLLs <br>static CONV_OPTIONS   sConvOptions =  <br>{ <br>    FALSE,              // don't want TNEF decoding <br>    lpszAddressType     // address type <br>}; <br> <br>static ULONG    nMessages           =   0;              // # messages converted <br> <br>//$--ProcessMtsOut-------------------------------------------------------------------- <br>// <br>//  DESCRIPTION: Process messages arriving at MTS-OUT.  This is a Windows thread <br>//  startup routine. <br>// <br>//  INPUT:  lpParameter --  pointer to gateway thread context structure  <br>//                          (LPGWTHREADCONTEXT). <br>// <br>//  RETURNS:    DWORD   --  0 <br>// <br>// ----------------------------------------------------------------------------- <br>DWORD ProcessMtsOut(           // RETURNS: DWORD <br>    IN LPVOID lpParameter)     // gateway thread context structure pointer <br>{ <br>    HRESULT         hr                 = NOERROR;   // temporary return code <br>    ULONG           i                  = 0; <br>    ULONG           cRows              = 0; <br>    ULONG           cValues            = 0; <br>    ULONG           ulObjType          = 0; <br> <br>    LPADRBOOK       lpAdrBook          = NULL; <br> <br>    LPMESSAGE       lpEnvelope         = NULL; <br> <br>    ULONG           cbeid              = 0; <br>    LPENTRYID       lpeid              = NULL; <br> <br>    LPWSTR          pszMessageClassW   = NULL; <br>    ULONG           cbMessageClass     = 0; <br>    EDKCNVRES       crRes              = GCR_OK; <br> <br>    LPSPropValue    lpProps            = NULL; <br> <br>    LPSTREAM        lpStream           = NULL; // stream to write output to <br> <br>    // message output file name <br>    TCHAR           pszFileName[MAX_PATH+1] =   TEXT("");        <br> <br>    // <br>    //  Declare an environment for the conversion. <br>    // <br> <br>    EDKCNVENV envTmp = <br>    {  <br>        1, <br>        L"SAMPLEGW.OUTBOUND",            // L = UNICODE string always. <br>        (LHANDLE)NULL, <br>        NULL, <br>        NULL, <br>        NULL <br>    }; <br> <br>// Stream interface flags <br>const ULONGulFlags=STGM_READWRITE | STGM_CREATE |  <br>                        SOF_UNIQUEFILENAME | STGM_SHARE_EXCLUSIVE; <br> <br>    DEBUGPUBLIC("ProcessMtsOut()\n"); <br> <br>    // check input parameters <br>    hr = CHK_Process(lpParameter); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    cRows = GetGWSRowSet(lpParameter)-&gt;cRows; <br> <br>    // Open the Address Book <br>    hr = MAPICALL(lpSession)-&gt;OpenAddressBook( <br>        lpSession, <br>        0, <br>        NULL,  <br>        AB_NO_DIALOG, <br>        &amp;lpAdrBook); <br> <br>    if(FAILED(hr))                  <br>    {        <br>        goto cleanup; <br>    } <br> <br>    // Initialize conversion environment structure <br>    envTmp.lphSession       = (LHANDLE)lpSession; <br>    envTmp.lpAB             = lpAdrBook; <br>    envTmp.pGatewayDefined  = &amp;sConvOptions; <br> <br>    for(i = 0; i &lt; cRows; i++) <br>    { <br>        // Free MAPI buffer <br>        MAPIFREEBUFFER(pszMessageClassW); <br> <br>        // Release MAPI objects <br>        ULRELEASE(lpEnvelope); <br>        ULRELEASE(lpStream); <br> <br>        cValues = GetGWSRowSet(lpParameter)-&gt;aRow[i].cValues; <br> <br>        lpProps = GetGWSRowSet(lpParameter)-&gt;aRow[i].lpProps; <br> <br>        cbeid = lpProps[0].Value.bin.cb; <br>        lpeid = (LPENTRYID)lpProps[0].Value.bin.lpb; <br> <br>        // Get the message in the MTS-OUT folder <br>        hr = MAPICALL(lpMtsOutFolder)-&gt;OpenEntry( <br>            lpMtsOutFolder, <br>            cbeid, <br>            lpeid, <br>            NULL, <br>            MAPI_MODIFY|MAPI_DEFERRED_ERRORS, <br>            &amp;ulObjType, <br>            (LPUNKNOWN FAR *)&amp;lpEnvelope); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        if(ulObjType != MAPI_MESSAGE) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Initialize output file name. <br>        lstrcpy(pszFileName, lpszDirectory); <br> <br>        // Open a buffered stream interface on a unique XLT*.tmp  <br>        // output file. <br>        hr = OpenStreamOnFile( <br>                MAPIAllocateBuffer,     // allocation routine <br>                MAPIFreeBuffer,         // deallocation routine <br>                ulFlags,// stream interface flags <br>                pszFileName,            // file name <br>                (LPTSTR) lpszPrefix,    // file prefix <br>                &amp;lpStream);             // stream pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Get the message's wide character message class. <br>        hr = HrMAPIGetPropString( <br>                        (LPMAPIPROP) lpEnvelope,          // message envelope pointer <br>                        PR_MESSAGE_CLASS_W, // wide character message class <br>                        &amp;cbMessageClass, <br>                        &amp;pszMessageClassW); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // <br>        //  Perform the conversion. <br>        // <br> <br>        hr = HrConvConvert( <br>            pvConvInstance, <br>            &amp;envTmp, <br>            pszMessageClassW,  <br>            lpEnvelope, <br>            lpStream, <br>            &amp;crRes); <br> <br>        if(FAILED(hr) || crRes != GCR_OK) <br>        { <br>            goto cleanup; <br>        } <br>         <br>        // Note: Conversion DLL commits changes to stream if <br>        // successful. <br> <br> <br>        ULRELEASE(lpEnvelope); <br> <br>        // --------------------------------------------------------------------- <br> <br>        // <br>        // Remove the converted message from the MTS-OUT folder. <br>        // <br> <br>        hr = HrMAPIDeleteMessage( <br>                    lpMtsOutFolder,     // MAPI folder pointer <br>                    cbeid,              // # bytes in entry id <br>                    lpeid);             // message entry identifier <br>                     <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // increment message count <br>        nMessages++; <br> <br>    }   // end for <br> <br>cleanup: <br> <br>    // Release MAPI and OLE objects <br>    ULRELEASE(lpStream); <br>    ULRELEASE(lpEnvelope); <br>    ULRELEASE(lpAdrBook); <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(pszMessageClassW); <br> <br>    if ( (FAILED(hr) || (crRes != GCR_OK)) &amp;&amp; (pszFileName[0] != 0) ) <br>    { <br>        // If we failed, we may have an empty file <br>        // siting around. <br>        if ( lstrcmp(pszFileName, lpszDefaultDir) != 0 ) <br>        { <br>            // Remove the empty file <br>            DeleteFile(pszFileName); <br>        } <br>    } <br>              <br>    return(0); <br>} <br> <br>//$--ProcessMtsIn-------------------------------------------------------------------- <br>// <br>//  DESCRIPTION: Process files arriving in input directory.  This is a Windows thread <br>//  startup routine. <br>// <br>//  INPUT:  lpParameter --  pointer to gateway thread context structure  <br>//                          (LPGWTHREADCONTEXT). <br>// <br>//  RETURNS:    DWORD   --  0 <br>// <br>// ----------------------------------------------------------------------------- <br>DWORD ProcessMtsIn(            // RETURNS: DWORD <br>    IN LPVOID lpParameter)     // gateway thread context structure pointer <br>{ <br>    HRESULT         hr                 = NOERROR;   // temporary error code <br>    ULONG           i                  = 0;         // index <br>    ULONG           cRows              = 0;         // row count <br>    LPADRBOOK       lpAdrBook          = NULL;      // address book pointer <br>    LPMESSAGE       lpEnvelope         = NULL;      // envelope pointer <br>    EDKCNVRES       crRes              = GCR_OK;    // result of conversion <br>    LPSTREAM        lpStream           = NULL;      // stream to read input from <br>    BOOL            fRetVal            = FALSE;     // Win32 return code <br> <br>    // File data <br>LPWIN32_FIND_DATA   rgFindData               = NULL; <br>LPWIN32_FIND_DATA   lpFindData               = NULL; <br> <br>    // message output file name <br>    TCHAR           pszFileName[MAX_PATH+1] =   TEXT("");        <br> <br>    // <br>    //  Declare an environment for the conversion. <br>    // <br> <br>    EDKCNVENV envTmp = <br>    {  <br>        1, <br>        L"SAMPLEGW.INBOUND",            // L = UNICODE string always. <br>        (LHANDLE)NULL, <br>        NULL, <br>        NULL, <br>        NULL <br>    }; <br> <br>    const LPCWSTR   pszMessageClassW    =   L"ENVELOPE.IPM";    // dummy message class <br> <br>    DEBUGPUBLIC("ProcessMtsIn()\n"); <br> <br>    // check input parameters <br>    hr = CHK_Process(lpParameter); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    cRows = GetGWFindDataSize(lpParameter); <br> <br>    rgFindData = GetGWFindData(lpParameter); <br> <br>    // Open the Address Book <br>    hr = MAPICALL(lpSession)-&gt;OpenAddressBook( <br>        lpSession, <br>        0, <br>        NULL,  <br>        AB_NO_DIALOG, <br>        &amp;lpAdrBook); <br> <br>    if(FAILED(hr))                  <br>    {        <br>        goto cleanup; <br>    } <br> <br>    // Initialize the conversion environment structure <br>    envTmp.lphSession       = (LHANDLE)lpSession; <br>    envTmp.lpAB             = lpAdrBook; <br>    envTmp.pGatewayDefined  = &amp;sConvOptions; <br> <br>    for(i = 0; i &lt; cRows; i++) <br>    { <br>        // Release MAPI objects <br>        ULRELEASE(lpEnvelope); <br>        ULRELEASE(lpStream); <br> <br>    // Build file name of incoming message <br> <br>        lpFindData = &amp;rgFindData[i]; <br> <br>    lstrcpy(pszFileName, lpszDirectory); <br>    lstrcat(pszFileName, lpFindData-&gt;cFileName); <br> <br>        // Open a buffered stream on our input file. <br>    hr = OpenStreamOnFile( <br>        MAPIAllocateBuffer,     // allocation routine <br>        MAPIFreeBuffer,         // deallocation routine <br>    STGM_READ | STGM_SHARE_EXCLUSIVE,// open for reading <br>    pszFileName,            // file name <br>    NULL,                   // prefix <br>    &amp;lpStream);             // stream pointer <br> <br>        if ( (hr == MAPI_E_NO_ACCESS) || (hr == MAPI_E_NOT_FOUND) ) <br>        { <br>            // These are not really errors <br>            hr = NOERROR; <br> <br>            continue; <br>        } <br> <br>    if ( FAILED(hr) ) <br>    { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>    } <br> <br>        // Create the message envelope in the MTS-IN folder. <br>        hr = MAPICALL(lpMtsInFolder)-&gt;CreateMessage( <br>            lpMtsInFolder,  // folder pointer <br>            NULL, <br>            MAPI_DEFERRED_ERRORS, // flags <br>            &amp;lpEnvelope);   // message pointer <br> <br>        if( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // <br>        //  Perform the conversion. <br>        // <br>        hr = HrConvConvert( <br>            pvConvInstance,         // conversion instance pointer <br>            &amp;envTmp,                // environment structure pointer <br>            pszMessageClassW,       // dummy message class <br>            lpStream,               // stream to read from <br>            lpEnvelope,             // message to convert to <br>            &amp;crRes);                // result pointer <br> <br>        if(FAILED(hr) || crRes != GCR_OK) <br>        { <br>            goto cleanup; <br>        } <br>         <br>        // Note: Conversion DLL saves changes to the envelope if <br>        // successful. <br> <br>        // Save changes to the MTS-IN folder <br>        hr = MAPICALL(lpMtsInFolder)-&gt;SaveChanges( <br>                    lpMtsInFolder, <br>                    KEEP_OPEN_READWRITE);   // still need access to folder <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ULRELEASE(lpStream); <br> <br>        // Remove the converted file from the input directory. <br>        fRetVal = DeleteFile(pszFileName); <br> <br>        if ( fRetVal == FALSE ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        }         <br> <br>        // increment message count <br>        nMessages++; <br> <br>    }   // end for <br> <br>cleanup: <br> <br>    // Release MAPI and OLE objects <br>    ULRELEASE(lpStream); <br>    ULRELEASE(lpEnvelope); <br>    ULRELEASE(lpAdrBook); <br>              <br>    return(0); <br>} <br> <br>// $--DisplayUserMsg---------------------------------------------------------- <br>// <br>// DESCRIPTION: Utility to display message to command line user. <br>// <br>// INPUT:       HINSTANCE   --  XLATDRIV instance handle <br>//              UINT        --  Resource string identifier <br>//  <br>// RETURNS:     VOID <br>// <br>// ---------------------------------------------------------------------------- <br> <br>static VOID DisplayUserMsg(     // RETURNS: nothing <br>            IN HINSTANCE hInst, // program handle <br>            IN UINT nResID,     // resource string identifier <br>            ...)                // additional arguments <br>{     <br>    INT         nRetCode        =   0;              // return value <br>    va_list     vArgList        =   {0};            // variable argument list <br>    HANDLE      hFile           =   NULL;           // file handle <br> <br>    TCHAR       szMessage[MAX_MSG_LENGTH]   = TEXT(""); // message buffer <br>    TCHAR       szFormatted[MAX_MSG_LENGTH] = TEXT(""); // formatted message <br> <br>    DEBUGPRIVATE("DisplayUserMsg()\n"); <br> <br>    // No CHK_DisplayUserMsg() call. <br>    // This function can take a NULL HINSTANCE <br> <br>    // Check the instance handle passed in. <br>    if ( !hInst ) <br>    { <br>        HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    nRetCode = LoadString(hInst, nResID, szMessage, MAX_MSG_LENGTH); <br>    if ( nRetCode == 0 ) <br>    { <br>        HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Get an optional argument list pointer <br>    va_start(vArgList, nResID); <br> <br>    // Fromat the message. <br>    _vstprintf( <br>            szFormatted,        // formatted message buffer <br>            szMessage,          // format string <br>            vArgList);          // variable argument list <br> <br>    va_end(vArgList); <br> <br>    // Display the error in a message box <br>    MessageBox( <br>            NULL,           // use parent window handle <br>            szFormatted,    // message text <br>            APPLICATION_TITLE,  // message box title <br>            MB_OK); <br> <br>cleanup: <br> <br>    // close console file <br>    CLOSEHANDLE(hFile); <br> <br>    // Return <br>    return; <br> <br>}   // end DisplayUserMsg() <br> <br>// $--HrParseOptions----------------------------------------------------------- <br>// <br>// DESCRIPTION: parse command line flags. <br>// <br>// INPUT:   cArgs   --  # arguments <br>//          pArgv   --  argument array <br>// <br>// OUTPUT: <br>//          pfInbound    --  inbound flag <br>//          pfTnef       --  TNEF flag <br>//          pcThreads    --  # threads <br>//          lpszDirectory   --  file directory <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>static HRESULT HrParseOptions( <br>        IN DWORD cArgs,         // argument count <br>        IN LPTSTR * pArgv,      // argument array <br>        OUT BOOL * pfInbound,   // inbound flag <br>        OUT BOOL * pfTnef,      // TNEF encoding desired flag <br>        OUT DWORD * pcThreads,  // # threads <br>        OUT LPTSTR  lpszDirectory) // file directory <br>{ <br>// Number of flag arguments and array indeces <br>#define             iDirection      0 <br>#define             iThreads        1 <br>#define             iLocation       2 <br>#define             iHelp1          3 <br>#define             iHelp2          4 <br>#define             iTnef           5 <br>#define             nFlags          6 <br> <br>    HRESULT         hr              =   NOERROR; <br>    UINT            iLoop           =   0;          // loop index <br>    ULONG           iFlag           =   0;          // flag index <br>    LPTSTR          lpFlagName      =   NULL;       // flag name pointer <br>    LPTSTR          lpData          =   NULL;       // flag data <br>    HANDLE          hFile           =   NULL;       // file handle <br>    BOOL            fInbound        =   FALSE;      // TRUE if direction inbound <br>    BOOL            fOutbound       =   FALSE;      // TRUE if direction outbound <br>    UINT            nRet            =   0;          // Win32 API return code <br>    UINT            nChars          =   0; <br> <br>    const LPCTSTR   lpszInbound     =   TEXT("In");     // inbound value <br>    const LPCTSTR   lpszOutbound    =   TEXT("Out");    // outbound value <br>    const TCHAR     chBackSlash     =   TEXT('\\');     // back slash <br> <br>    // array of valid flags <br>    LPTSTR                rgFlags[nFlags]   = <br>    { <br>        TEXT("DIRECTION"),      // Inbound or outbound <br>        TEXT("THREADS"),        // # of threads <br>        TEXT("LOCATION"),       // location of input/output files <br>        TEXT("HELP"), <br>        TEXT("?"), <br>        TEXT("ENCODE")          // TNEF encoding/decoding desired <br>    }; <br> <br>    // temporary file name <br>    TCHAR           szTempFile[MAX_PATH + 1]    =   TEXT(""); <br> <br>    DEBUGPRIVATE("HrParseOptions()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParseOptions(cArgs, pArgv, pfInbound, pfTnef, pcThreads, <br>                    lpszDirectory); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Check to make sure that we have enough arguments. <br>    // Note:  If the use originally typed <br>    // xlatdriv notserv gdk-sample, then the arguments <br>    // which are passed to this program are everything <br>    // after the program name and the notserv option. <br>    if ( cArgs &lt; 1 ) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br> <br>        // Print out the syntax error message. <br>        DisplayUserMsg(hInst, IDS_ERROR_USAGE); <br> <br>        goto cleanup; <br>    } <br>         <br>    // initialize output parameters <br>    *pfInbound = FALSE; <br>    *pfTnef = FALSE; <br>    *pcThreads = 1; <br>    lstrcpy(lpszDirectory, lpszDefaultDir); <br> <br>    // Parse each argument, looking for a supported flag <br>    for ( iLoop = 0; iLoop &lt; cArgs; iLoop++ ) <br>    { <br>        hr = _HrExpandCommandLineArgument( <br>                pArgv[iLoop],       // command line argument <br>                rgFlags,            // array of flag names <br>                nFlags,             // number of flags <br>                &amp;iFlag,             // flag index             <br>                &amp;lpFlagName,        // flag name <br>                &amp;lpData);           // flag data <br> <br>        if ( FAILED(hr) ) <br>        { <br>            DisplayUserMsg( <br>                        hInst,              // instance handle <br>                        IDS_INVALID_ARG,    // string identifier <br>                        pArgv[iLoop]);      // argument <br> <br>            goto cleanup; <br>        } <br> <br>        if ( lpFlagName == NULL ) <br>        { <br>            // not a flag.  We are only interested in flags <br>            continue; <br>        } <br> <br>        // switch off of flag found <br>        switch ( iFlag ) <br>        { <br>            case iDirection:         // direction index <br>                if ( (lpData == NULL) || (*lpData == 0) ) <br>                { <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    DisplayUserMsg( <br>                            hInst,              // instance handle <br>                            IDS_ERROR_NOVALUE,  // string identifier <br>                            lpFlagName);        // argument <br> <br>                    goto cleanup; <br>                } <br> <br>                // Determine if inbound or outbound <br>                if ( _tcsnicmp(lpData, lpszInbound, lstrlen(lpszInbound)) <br>                     == 0 ) <br>                { <br>                    fInbound = TRUE;  <br>                    *pfInbound = TRUE;                    <br>                } <br> <br>                else if ( _tcsnicmp(lpData, lpszOutbound, lstrlen(lpszOutbound)) <br>                          == 0 ) <br>                { <br>                    fOutbound = TRUE; <br>                    *pfInbound = FALSE; <br>                } <br> <br>                else <br>                { <br>                    // print out error. <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    DisplayUserMsg( <br>                            hInst,              // instance handle <br>                            IDS_INVALID_VALUE,  // string identifier <br>                            lpData, <br>                            lpFlagName);        // argument <br> <br>                    goto cleanup; <br>                } <br> <br>                break; <br>                                 <br>            case iThreads:     // threads index <br>                // Initialize number of threads <br>                if ( (lpData == NULL) || (*lpData == 0) ) <br>                { <br>                    // print out error <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    DisplayUserMsg( <br>                            hInst,              // instance handle <br>                            IDS_ERROR_NOVALUE,  // string identifier <br>                            lpFlagName);        // argument <br> <br>                    goto cleanup; <br>                } <br> <br>                *pcThreads = atol(lpData); <br> <br>                if ( *pcThreads == 0 ) <br>                { <br>                    // print out error <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    DisplayUserMsg( <br>                            hInst,              // instance handle <br>                            IDS_INVALID_VALUE,  // string identifier <br>                            lpData, <br>                            lpFlagName);         // argument <br> <br>                    goto cleanup; <br>                } <br> <br>                break; <br> <br>            case iLocation:         // location index <br>                if ( (lpData == NULL) || (*lpData == 0) ) <br>                { <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    DisplayUserMsg( <br>                            hInst,              // instance handle <br>                            IDS_ERROR_NOVALUE,  // string identifier <br>                            lpFlagName);        // argument <br> <br>                    goto cleanup; <br>                } <br> <br>                // Make sure that we can create a file in the <br>                // directory. <br>                // First, get a temporary file name <br>                nRet = GetTempFileName( <br>                        lpData,     // directory <br>                        lpszPrefix, // file prefix <br>                        0,          // use time to create number <br>                        szTempFile);    // file name <br> <br>                if ( nRet == 0 ) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br> <br>                    DisplayUserMsg( <br>                            hInst,              // instance handle <br>                            IDS_INVALID_VALUE,    // string identifier <br>                            lpData, <br>                            lpFlagName);      // argument <br> <br>                    goto cleanup; <br>                } <br> <br>                hFile = CreateFile( <br>                        szTempFile,            // file name <br>                        GENERIC_READ | GENERIC_WRITE, <br>                        0,  <br>                        0, <br>                        CREATE_ALWAYS,  <br>                        FILE_ATTRIBUTE_NORMAL,  <br>                        0); <br> <br>                if ( hFile == INVALID_HANDLE_VALUE ) <br>                { <br>                    // print out error <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    DisplayUserMsg( <br>                            hInst,              // instance handle <br>                            IDS_INVALID_VALUE,  // string identifier <br>                            lpData, <br>                            lpFlagName);        // argument <br> <br>                    goto cleanup; <br>                } <br> <br>                // Close the file <br>                CLOSEHANDLE(hFile); <br> <br>                // Delete the file <br>                (VOID)DeleteFile( <br>                        szTempFile);   // file name <br>                                 <br>                lstrcpy(lpszDirectory, lpData); <br> <br>                // Append a back slash to the directory <br>                // name if it doesn't alredy have one. <br>                nChars = lstrlen(lpszDirectory); <br>                if ( lpszDirectory[nChars - 1] != chBackSlash ) <br>                { <br>                    lpszDirectory[nChars] = chBackSlash; <br>                    lpszDirectory[nChars + 1] = 0;  // null terminate <br>                } <br> <br>                break; <br> <br>            case iHelp1:     // help index <br>            case iHelp2:     // ? index <br>                // print out help. <br> <br>                // Not really an error, but we need <br>                // to exit early. <br>                hr = HR_LOG(E_INVALIDARG); <br> <br>                DisplayUserMsg(hInst, IDS_ERROR_HELP); <br> <br>                goto cleanup; <br> <br>            case iTnef:     // TNEF index <br>                // User wants TNEF encoding/decoding <br>                // Data portion of flag is ignored. <br>                *pfTnef = TRUE; <br> <br>                break; <br> <br>            default: <br> <br>                hr = HR_LOG(E_FAIL); <br> <br>                DisplayUserMsg( <br>                            hInst,              // instance handle <br>                            IDS_INVALID_ARG,    // string identifier <br>                            lpData);            // argument <br> <br>                goto cleanup; <br> <br>        }   // end switch <br> <br>    }   // end for <br> <br>    // make sure that haven't received conflicting directions <br>    if ( fInbound &amp;&amp; fOutbound ) <br>    { <br>        // print out error. <br>        hr = HR_LOG(E_INVALIDARG); <br> <br>        DisplayUserMsg( <br>                    hInst,                      // instance handle <br>                    IDS_CONFLICTING_DIRECTION); // string identifier <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--GWMain---------------------------------------------------------------- <br>// <br>//  DESCRIPTION: Start threads. <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS: VOID <br>// <br>// ----------------------------------------------------------------------------- <br>VOID GWMain(       // RETURNS: VOID <br>    VOID) <br>{ <br>    HRESULT               hr                     = NOERROR; <br>    EDK_SERVICE_CONTROL_T sc                     = 0; <br>    DWORD                 cArgs                  = 0; <br>    LPTSTR *              pArgv                  = NULL; <br>    BOOL                  fInbound               = FALSE; <br>    BOOL                  fTnef                  = FALSE; <br>    DWORD                 cThreads               = 1; <br>    TCHAR                 szTempPath[MAX_PATH+1] = {0}; <br>    const DWORD           cMessages              = 1; <br>    DWORD                 cch                    = 0; <br> <br>    DEBUGPUBLIC("GWMain()\n"); <br> <br>    // Get this program's instance handle. <br>    hInst = GetModuleHandle(NULL); <br> <br>    if ( hInst == NULL ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Retrieve the command line arguments <br>    // Command line is of the form <br>    // <br>    //  XLATDRIV [notserv] GWProfileName [flags] <br>    // <br>    // where flags are: <br>    // <br>    //  /DIRECTION=Inbound or /DIRECTION=Outbound <br>    //  /THREADS=#Thread <br>    //  /LOCATION=DirectoryName     (for input or output files) <br>    //  /ENCODE                     (TNEF encoding/decoding desired) <br>    // <br>    // By default, the direction is assumed to be outbound, <br>    // TNEF encoding is assumed to be FALSE, <br>    // the file location is assumed to be the current directory <br>    // and the number of threads is assumed to be 1.  (If <br>    // notserv is not specified, winwrap.c assumes that XLATDRIV <br>    // is to be run as a service.) <br> <br>    hr = HrServiceGetArgv( <br>                &amp;cArgs,         // argument count pointer <br>                &amp;pArgv);        // pointer to argument array pointer </code></pre>
<p>
</p>
<pre><code><br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Parse out options. <br>    hr = HrParseOptions( <br>                cArgs,      // argument count <br>                pArgv,      // pointer to argument array <br>                &amp;fInbound,  // inbound flag <br>                &amp;fTnef,     // TNEF desired flag <br>                &amp;cThreads,  // # threads <br>                lpszDirectory);    // file directory <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Set TNEF flag in gateway options. <br>    sConvOptions.fTnefEncode = fTnef; <br> <br>    if ( fInbound ) <br>    { <br>        // Want to do inbound conversion. <br>        // (Read files in and convert to messages in MTS-IN) <br>        hr = HrGWStartNewFileHandler( <br>            1000,                   // sleep interval <br>            (ULONG) -1,             // poll interval <br>            cMessages,              // # messages per thread <br>            cThreads,               // # of threads <br>            lpszAddressType,        // address type <br>            TEXT("XLT*.TMP"),       // file name template <br>            lpszDirectory,          // input file directory <br>            (LPTHREAD_START_ROUTINE)ProcessMtsIn); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>    else <br>    { <br>        cch = GetTempPath(MAX_PATH+1, szTempPath); <br>         <br>        if((cch == 0) || (cch &gt; (MAX_PATH+1))) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Want to do outbound conversions.   <br>        // (Read messages from MTS-OUT and convert to output <br>        // files. <br>        hr = HrGWStartNewMailHandler( <br>            1000, <br>            (ULONG)-1, <br>            cMessages, <br>            cThreads, <br>            lpszAddressType, <br>            szTempPath, <br>            (LPTHREAD_START_ROUTINE)ProcessMtsOut); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br>    }   // end if doing out bound conversions <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        ServiceStop(); <br>    } <br> <br>    // <br>    // Wait for a request for the service to stop. <br>    // <br> <br>    hr = HR_LOG(HrServiceWaitForStop(INFINITE, &amp;sc)); <br> <br>    return; <br>} <br> <br>//$--HrGWLogon------------------------------------------------------------- <br>// <br>//  Logon to the gateway. <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGWLogon(                 // RETURNS: return code <br>        VOID) <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    lpSession      = GetGWSession(); <br>    lpStore        = GetGWDefaultStore(); <br>    lpRootFolder   = GetGWRootFolder(); <br>    lpMtsInFolder  = GetGWMtsInFolder(); <br>    lpMtsOutFolder = GetGWMtsOutFolder(); <br>    cbGalEid       = GetGWGALEntryIdSize(); <br>    lpGalEid       = GetGWGALEntryId(); <br> <br>    DEBUGPUBLIC("HrGWLogon()\n"); <br> <br>    // Open an event log for this application. <br>    hr = HrEventOpenLog( <br>                APPLICATION_TITLE,  // application name <br>                NULL,           // executable name (will be computed) <br>                APPLICATION_EVENT_FILE, // event message file (will be computed) <br>                NULL,           // parameter message file (will be computed) <br>                NULL,           // category message file (will be computed) <br>                &amp;hEventLog);    // event source handle <br> <br>    if ( FAILED(hr) || (hEventLog == NULL) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Initialize conversion engine global data. <br>    hr = HrConvInitGlobals(); <br>     <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Initialize conversion engine instance data. <br>    hr = HrConvInitInstance(hEventLog, &amp;pvConvInstance); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGWLogoff------------------------------------------------------------ <br>// <br>//  Logoff of the gateway. <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGWLogoff(                // RETURNS: return code <br>    VOID) <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    EDKEVENTCOUNT   sEventCount =   {0};        // EDK event count structure <br> <br>    DEBUGPUBLIC("HrGWLogoff()\n"); <br> <br>    // De-initialize conversion engine instance data. <br>    (VOID)HrConvUninitInstance(pvConvInstance); <br>    pvConvInstance = NULL; <br> <br>    // De-intialize global conversion engine data. <br>    ConvUninitGlobals(); <br> <br>    // Display number of messages processed. <br>    if ( nMessages &gt;= 0 ) <br>    { <br>        DisplayUserMsg( <br>            hInst,              // instance handle <br>            IDS_SUCCESS,        // string identifier <br>            nMessages);         // # messages processed <br>    } <br> <br>    // Determine number of messages written to the event log. <br>    hr = HrEventGetCounts( <br>            &amp;sEventCount); <br> <br>    if ( SUCCEEDED(hr) ) <br>    { <br>        // print out number of errors printed to the <br>        // event log.  <br>        if ( sEventCount.cError == 1 ) <br>        { <br>            DisplayUserMsg( <br>                hInst, <br>                IDS_1_ERROR); <br>        } <br> <br>        else if ( sEventCount.cError &gt; 1 ) <br>        { <br>            DisplayUserMsg( <br>                hInst, <br>                IDS_NUM_ERRORS, <br>                sEventCount.cError); <br>        } <br> <br>        // Print out the number of warnings logged <br>        if ( sEventCount.cWarning == 1 ) <br>        { <br>            DisplayUserMsg( <br>                hInst, <br>                IDS_1_WARNING); <br>        } <br> <br>        else if ( sEventCount.cWarning &gt; 1 ) <br>        { <br>            DisplayUserMsg( <br>                hInst, <br>                IDS_NUM_WARNINGS, <br>                sEventCount.cWarning); <br>        } <br>    }   // end if know # of messages logged to event file <br> <br>    // Close the event log. <br>    (VOID)HrEventCloseLog(); <br>    hEventLog = NULL; <br>             <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
