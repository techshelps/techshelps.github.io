<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIMPORT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1792"></a>FIMPORT.C</h2>
<pre><code>// --fimport.c------------------------------------------------------------------ <br>// <br>//  The Exchange SDK Folder Import sample allows bulk import of data  <br>//  into an Exchange folder. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "attrname.h" <br>#include "fimportm.h" <br>#include "fimport.chk" <br> <br>// <br>// Names of Command Line Arguments <br>// <br> <br>#define ARG_PROGRAM_NAME        "FIMPORT" <br>#define ARG_HELP1               "?" <br>#define ARG_HELP2               "HELP" <br>#define ARG_APPEND              "APPEND" <br>#define ARG_UPDATE              "UPDATE" <br>#define ARG_REPLACE             "REPLACE" <br>#define ARG_FILE                "FILE" <br>#define ARG_FOLDERPATH          "FOLDERPATH" <br>#define ARG_CLASS               "CLASS" <br>#define ARG_PROFILE             "PROFILE" <br>#define ARG_SETREAD             "SETREAD" <br>#define ARG_NOSETREAD           "NOSETREAD" <br>#define ARG_EFD                 "EFD" <br>#define ARG_NOEFD               "NOEFD" <br>#define ARG_PROGRESS            "PROGRESS" <br>#define ARG_NOPROGRESS          "NOPROGRESS" <br> <br>// <br>// Table of Command Line Switches for _HrExpandCommandLineArgument() <br>// <br> <br>static char * rgpszArgArray[] = { <br>    ARG_HELP1, <br>    ARG_HELP2, <br>    ARG_APPEND, <br>    ARG_UPDATE, <br>    ARG_REPLACE, <br>    ARG_FILE, <br>    ARG_FOLDERPATH, <br>    ARG_CLASS, <br>    ARG_PROFILE, <br>    ARG_SETREAD, <br>    ARG_NOSETREAD, <br>    ARG_EFD, <br>    ARG_NOEFD, <br>    ARG_PROGRESS, <br>    ARG_NOPROGRESS, <br>}; <br> <br>// <br>// Table of Commands for First Line of .CSV File. <br>// <br> <br>static char * rgpszFileCommandArray[] = { <br>    ARG_APPEND, <br>    ARG_UPDATE, <br>    ARG_REPLACE, <br>    ARG_FOLDERPATH, <br>    ARG_CLASS, <br>    ARG_SETREAD, <br>    ARG_NOSETREAD, <br>    ARG_EFD, <br>    ARG_NOEFD, <br>}; <br> <br>// These equates MUST equal the offset of the  <br>// corresponding entry in rgpszFileCommandArray. <br> <br>typedef enum _FileCommand        // fc <br>{ <br>    FILECOMMAND_APPEND          = 0, <br>    FILECOMMAND_UPDATE          = 1, <br>    FILECOMMAND_REPLACE         = 2, <br>    FILECOMMAND_FOLDERPATH      = 3, <br>    FILECOMMAND_CLASS           = 4, <br>    FILECOMMAND_SETREAD         = 5, <br>    FILECOMMAND_NOSETREAD       = 6, <br>    FILECOMMAND_EFD             = 7, <br>    FILECOMMAND_NOEFD           = 8, <br>} <br>FILECOMMAND, *LPFILECOMMAND; <br> <br>// <br>// Enumerations, Structures and Type Definitions <br>// <br> <br>typedef enum _Operation         // op <br>{ <br>    OP_APPEND, <br>    OP_UPDATE, <br>    OP_REPLACE, <br>} <br>OPERATION, *LPOPERATION; <br> <br> <br>typedef enum _PropTypeCode      // ptc <br>{ <br>    PROPTYPECODE_LONG           = 'L', <br>    PROPTYPECODE_STRING         = 'S', <br>    PROPTYPECODE_SYSTIME        = 'T', <br>    PROPTYPECODE_UNICODE        = 'U', <br>    PROPTYPECODE_BOOLEAN        = 'B', <br>    PROPTYPECODE_BINARY         = 'X', <br>    PROPTYPECODE_GUID           = 'G', <br>    PROPTYPECODE_MULTI          = 'M', <br>} <br>PROPTYPECODE, *LPPROPTYPECODE; <br> <br>// <br>// Variables to store command line parameters <br>// <br> <br>static BOOL             fHelp                           = FALSE; <br>static OPERATION        opOperation                     = OP_APPEND; <br>static CHAR             szFile          [MAX_PATH+1]    = {0}; <br>static CHAR             szFolderPath    [MAX_PATH+1]    = {0}; <br>static CHAR             szClass         [MAX_PATH+1]    = {0}; <br>static CHAR             szProfile       [MAX_PATH+1]    = {0}; <br>static BOOL             fSetRead                        = FALSE; <br>static BOOL             fEfd                            = FALSE; <br>static BOOL             fProgress                       = TRUE; <br> <br>// <br>// Other Variables <br>// <br> <br>static LPMAPISESSION    lpSession                       = NULL; <br>static LPMAPIFOLDER     lpFolder                        = NULL; <br>static LPSPropValue     rgMessageProps                  = NULL; <br>static ULONG            cCsvFileMessageProps            = 0; <br>static ULONG            cAllMessageProps                = 0; <br>static BOOL             fImportingAttachments           = FALSE; <br> <br>#define                 MAX_CSV_FILE_LINE               1000 <br>static FILE *           fpCsvFile                       = NULL; <br>static ULONG            iCsvLine                        = 0; <br>static BOOL             fCsvLineSaved                   = FALSE; <br>static CHAR             szCsvLine[MAX_CSV_FILE_LINE]    = {0}; <br> <br>// If cMessagesImported == DONT_REPORT_MSGS_IMPORTED then don't print  <br>// the number of messages imported. <br> <br>#define                 DONT_REPORT_MSGS_IMPORTED       -1 <br>static LONG             cMessagesImported               = DONT_REPORT_MSGS_IMPORTED; <br> <br>// <br>// Function Declarations <br>// <br> <br>static VOID PrintUsage(void); <br> <br>static HRESULT HrPreParseCommandLine( <br>    IN int argc, <br>    IN char *argv[]); <br> <br>static VOID PrintHelp(void); <br> <br>static HRESULT HrParseCommandLine( <br>    IN int argc, <br>    IN char *argv[]); <br> <br>static HRESULT HrCheckInfoCompleteness(void); <br> <br>static HRESULT HrGetFolderFromPath( <br>    IN LPMAPISESSION lpSession,  <br>    IN LPSTR pszStoreFolderPath,  <br>    OUT LPMAPIFOLDER * lppFolder); <br> <br>static HRESULT HrDoImport(void); <br> <br>static HRESULT HrReadColumnHeaders(void); <br> <br>static HRESULT HrProcessMessages(void); <br> <br>static HRESULT HrParseMultiPropValue( <br>IN ULONG            ulPropTag, <br>IN LPTSTR           pszValueText, <br>IN LPVOID           pBaseObject, <br>OUT LPSPropValue    pProp); <br> <br>static HRESULT HrParsePropValue( <br>IN ULONG            ulPropTag, <br>IN LPTSTR           pszValueText, <br>IN LPVOID           pBaseObject, <br>OUT LPSPropValue    pProp); <br> <br>HRESULT HrCreateMessageAttachment( <br>INLPMESSAGElpMsg, <br>INLPSTRlpszAttachPath); <br> <br>static HRESULT HrStrAToStrWEx( <br>    IN  LPCSTR          lpszSource, <br>    IN  LPVOID          lpvBaseObject, <br>    OUT LPWSTR *        lppwszDest); <br> <br>static HRESULT HrOpenCsvFile(); <br> <br>static HRESULT HrReadCsvSettings(void); <br> <br>static HRESULT HrGetCsvLine(void); <br> <br>static HRESULT HrUngetCsvLine(void); <br> <br>static HRESULT HrCloseCsvFile(void); <br> <br>// <br>// Inline Helper Functions <br>// <br> <br>//$--SZ_BASE10------------------------------------------------------------------ <br>//  Converts an integer to its decimal string equivalent. <br>//  For use as a parameter to EventLogMsg. <br>// ----------------------------------------------------------------------------- <br>__inline static LPCTSTR SZ_BASE10( <br>    IN const INT iNumber) <br>{ <br>    static TCHAR szTemp[16] = {0}; <br>    return( (LPCTSTR)_itot( iNumber, szTemp, 10)); <br>} <br> <br>//$--SZ_BASE16------------------------------------------------------------------ <br>//  Converts an integer to its hexidecimal string equivalent. <br>//  For use as a parameter to EventLogMsg. <br>// ----------------------------------------------------------------------------- <br>__inline static LPCTSTR SZ_BASE16( <br>    IN const ULONG ulNumber) <br>{ <br>    static TCHAR szTemp[16] = {0}; <br>    return( (LPCTSTR)_itot( ulNumber, szTemp, 16)); <br>} <br> <br>//$--TRIM_WHITE_SPACE----------------------------------------------------------- <br>//  Trims white space from the front and back of a string.  Edits the string  <br>//  in place in the buffer. <br>// ----------------------------------------------------------------------------- <br>__inline static VOID TRIM_WHITE_SPACE( <br>    IN OUT LPSTR psz) <br>{ <br>    LPSTR pszSrc = psz; <br>    LPSTR pszDst = psz; <br>    LPSTR pszPlaceToNullTerminate = NULL; <br> <br>    while (isspace(*pszSrc)) <br>        pszSrc++; <br> <br>    while (*pszSrc) <br>    { <br>        if (!isspace(*pszSrc)) <br>            pszPlaceToNullTerminate = pszDst + 1; <br>        *pszDst++ = *pszSrc++; <br>    } <br> <br>    if (pszPlaceToNullTerminate) <br>        *pszPlaceToNullTerminate = 0; <br>    else <br>        *pszDst = 0; <br>} <br> <br>// <br>// Functions <br>// <br> <br>//$--main----------------------------------------------------------------------- <br>//  Main function that performs folder import. <br>// ----------------------------------------------------------------------------- <br>int main(                                   // RETURNS: exit code <br>    IN int argc,                            // number of args on command line <br>    IN char *argv[])                        // array of command line arguments <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    BOOL                fEventLogOpen       = FALSE; <br>    BOOL                fMAPIInitialized    = FALSE; <br>    BOOL                fCsvFileIsOpen      = FALSE; <br>    MAPIINIT_0          MapiInit            = {0}; <br> <br>    DEBUGPUBLIC("main()"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_main(argc, argv); <br>    if (FAILED(hr)) <br>        return _nEcFromHr(hr); <br> <br>    printf( "\n" ); <br> <br>    // If there are no command line arguments then print the usage message  <br>    // and exit. <br> <br>    if (argc &lt; 2) <br>    { <br>        PrintUsage(); <br>        goto cleanup; <br>    } <br> <br>    // Do preliminary parsing of the command line (prints a message on failure). <br> <br>    hr = HrPreParseCommandLine(argc, argv); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // If they requested help, then print a help message and exit. <br> <br>    if (fHelp) <br>    { <br>        PrintHelp(); <br>        goto cleanup; <br>    } <br> <br>    // Parse the command line arguments (prints a message on failure). <br> <br>    hr = HrParseCommandLine(argc, argv); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Start reporting the number of messages imported after here. <br> <br>    cMessagesImported = 0; <br> <br>    // Initialize event logging. <br> <br>    hr = HrEventOpenLog( <br>        TEXT("EDK FImport"), NULL, NULL, NULL, NULL, NULL); <br> <br>    if (FAILED(hr)) <br>    { <br>        fprintf(stderr,  <br>            "WARNING: unable to initialize event logging.\n"); <br>        hr = NOERROR; <br>    } <br>    else <br>    { <br>        fEventLogOpen = TRUE; <br>    } <br> <br>    // Open the .CSV file. <br> <br>    hr = HrOpenCsvFile(szFile); <br>    if (FAILED(hr)) <br>        goto cleanup; <br>    fCsvFileIsOpen = TRUE; <br> <br>    // Initialize MAPI. <br> <br>    MapiInit.ulVersion = MAPI_INIT_VERSION; <br> <br>    hr = MAPIInitialize(&amp;MapiInit); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            FIMPORT_CANNOT_INIT_MAPI,  <br>            0,  <br>            0); <br>        goto cleanup; <br>    } <br>    fMAPIInitialized = TRUE; <br> <br>    // Logon to MAPI. <br> <br>    if (szProfile[0]) <br>    { <br>    // If a profile was given on the command line then  <br>        // log on to the specified profile. <br> <br>    hr = MAPILogonEx( <br>            0, <br>            szProfile, <br>            NULL, <br>            MAPI_NEW_SESSION | MAPI_EXPLICIT_PROFILE , //| MAPI_NO_MAIL, <br>            &amp;lpSession); <br> <br>    if (FAILED(hr)) <br>    { <br>    EventLogMsg( <br>    FIMPORT_PROFILE_LOGON_ERROR, <br>    2, szProfile, SZ_BASE16(hr), <br>                0); <br> <br>            hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>    } <br>    else <br>    { <br>    // Otherwise, log onto the existing session. <br> <br>    hr = MAPILogonEx( <br>            0, <br>            szProfile, <br>            NULL, <br>            MAPI_ALLOW_OTHERS , //| MAPI_NO_MAIL, <br>            &amp;lpSession); <br> <br>    if (FAILED(hr)) <br>    { <br>    EventLogMsg( <br>    FIMPORT_LOGON_ERROR, <br>    1, SZ_BASE16(hr), <br>                0); <br> <br>            hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>    } <br> <br>    // Read the first line from the .CSV file, which contains  <br>    // arguments like those on the command line. <br> <br>    hr = HrReadCsvSettings(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Parse the command line arguments again, so that command  <br>    // line arguments will override the first line of the file. <br> <br>    hr = HrParseCommandLine(argc, argv); <br>    if (FAILED(hr)) <br>    { <br>        // Don't report number of messages imported. <br>        cMessagesImported = DONT_REPORT_MSGS_IMPORTED; <br>        goto cleanup; <br>    } <br> <br>    // Make sure we got all the information we need from the  <br>    // command line/.CSV file (prints a message on failure). <br> <br>    hr = HrCheckInfoCompleteness(); <br>    if (FAILED(hr)) <br>    { <br>        // Don't report number of messages imported. <br>        cMessagesImported = DONT_REPORT_MSGS_IMPORTED; <br>        goto cleanup; <br>    } <br> <br>    // Get a pointer to the folder. <br> <br>    hr = HrGetFolderFromPath(lpSession, szFolderPath, &amp;lpFolder); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Import from the .CSV file to the folder. <br> <br>    hr = HrDoImport(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br> <br>    // Close .CSV file. <br> <br>    if (fCsvFileIsOpen) <br>    { <br>        (void) HrCloseCsvFile(); <br>        fCsvFileIsOpen = FALSE; <br>    } <br> <br>    // Print the number of events logged, then close event logging. <br> <br>    if (fEventLogOpen) <br>    { <br>        HRESULT hrT = NOERROR; <br>        EDKEVENTCOUNT sEventCount = {0}; <br> <br>        hrT = HrEventGetCounts(&amp;sEventCount); <br>        if (SUCCEEDED(hrT)) <br>        { <br>            if (sEventCount.cError == 1) <br>            { <br>                fprintf(stderr,  <br>                    "ERROR: 1 error written to the event log.\n"); <br>            } <br>            else if (sEventCount.cError) <br>            { <br>                fprintf(stderr,  <br>                    "ERROR: %d errors written to the event log.\n",  <br>                    sEventCount.cError); <br>            } <br> <br>            if (sEventCount.cWarning == 1) <br>            { <br>                fprintf(stderr,  <br>                    "WARNING: 1 warning written to the event log.\n"); <br>            } <br>            else if (sEventCount.cWarning) <br>            { <br>                fprintf(stderr,  <br>                    "WARNING: %d warnings written to the event log.\n",  <br>                    sEventCount.cWarning); <br>            } <br>        } <br> <br>        (void) HrEventCloseLog(); <br>        fEventLogOpen = FALSE; <br>    } <br> <br>    // Print the number of messages imported. <br> <br>    if (cMessagesImported != DONT_REPORT_MSGS_IMPORTED) <br>    { <br>        if (cMessagesImported == 1) <br>        { <br>            fprintf(stderr, "There was 1 message imported.\n"); <br>        } <br>        else <br>        { <br>            fprintf(stderr,  <br>                "There were %d message(s) imported.\n", cMessagesImported); <br>        } <br>    } <br> <br>    // Release MAPI objects and de-initialize MAPI. <br> <br>    if (fMAPIInitialized) <br>    { <br>        ULRELEASE(lpFolder); <br>        ULRELEASE(lpSession); <br> <br>        MAPIUninitialize(); <br>        fMAPIInitialized = FALSE; <br>    } <br> <br>    return(_nEcFromHr(hr)); <br>} <br> <br> <br> <br>//$--PrintUsage----------------------------------------------------------------- <br>//  Print information about how to use this program. <br>// ----------------------------------------------------------------------------- <br>static VOID PrintUsage(void)                // RETURNS: nothing <br>{ <br>    DEBUGPRIVATE("PrintUsage()"); <br> <br>    printf("USAGE: %s [Flags]\n\n", ARG_PROGRAM_NAME); <br>    printf("  [Flags]        Enter %s /%s for details\n", ARG_PROGRAM_NAME,  <br>        ARG_HELP1); <br>} <br> <br> <br> <br>//$--HrPreParseCommandLine------------------------------------------------------ <br>//  Does preliminary parsing of the command line that is needed to decide  <br>//  if /HELP was included. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrPreParseCommandLine(       // RETURNS: HRESULT <br>    IN int argc,                            // number of args on command line <br>    IN char *argv[])                        // array of command line arguments <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    int                 i                   = 0; <br>    char *              pszArgument         = NULL; <br>    char *              pszValue            = NULL; <br> <br>    DEBUGPRIVATE("HrPreParseCommandLine()"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_main(argc, argv); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Check for /? or /HELP. <br> <br>    for (i = 1; i &lt; argc; i++) <br>    { <br>        hr = _HrExpandCommandLineArgument( <br>            argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>            &amp;pszArgument, &amp;pszValue); <br> <br>        if (SUCCEEDED(hr) &amp;&amp; pszArgument &amp;&amp;  <br>            (!_stricmp(pszArgument,ARG_HELP1) ||  <br>             !_stricmp(pszArgument,ARG_HELP2))) <br>        { <br>            fHelp = TRUE; <br>            break; <br>        } <br>    } <br> <br>    RETURN(NOERROR); <br>} <br> <br> <br> <br>//$--PrintHelp------------------------------------------------------------------ <br>//  Print information about the flags. <br>// ----------------------------------------------------------------------------- <br>static VOID PrintHelp(void)                 // RETURNS: nothing <br>{ <br>    DEBUGPRIVATE("PrintHelp()"); <br> <br>    printf("Folder Import sample.\n\n"); <br>    printf("USAGE: %s [Flags]\n\n", ARG_PROGRAM_NAME); <br>    printf("  Flags\n"); <br>    printf("  /FILE=         Filename of the .CSV file to import\n"); <br>    printf("  /APPEND        The content of the .CSV file is appended to the folder\n"); <br>    printf("  /UPDATE        The columns in the .CSV file replace the associated\n"); <br>    printf("                 properties in the messages in the folder.  The replacement\n"); <br>    printf("                 is carried out starting with the first message in the folder.\n"); <br>    printf("  /REPLACE       The existing messages in the folder are replaced with the\n"); <br>    printf("                 content of the .CSV file\n"); <br>    printf("  /FOLDERPATH=   Path of the folder where messages will be placed\n"); <br>    printf("  /CLASS=        Message class of the messages to place in the folder\n"); <br>    printf("  /PROFILE=      Profile to log into message store\n"); <br>    printf("  /[NO]SETREAD   Set the read flag on each new message\n"); <br>    printf("  /[NO]EFD       Set the property MS_EXCHANGE_01=1 on each new message\n"); <br>    printf("  /[NO]PROGRESS  Display progress dialog\n"); <br>    printf("  /HELP or /?    Display help screen\n"); <br>} <br> <br> <br> <br>//$--HrParseCommandLine--------------------------------------------------------- <br>//  Parse the command line arguments and put their values in the appropriate  <br>//  variables. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParseCommandLine(          // RETURNS: HRESULT <br>    IN int argc,                            // number of arguments on command line <br>    IN char *argv[])                        // array of command line arguments <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    HRESULT             hrT                 = NOERROR; <br>    int                 i                   = 0; <br>    char *              pszArgument         = NULL; <br>    char *              pszValue            = NULL; <br> <br>    DEBUGPRIVATE("HrParseCommandLine()"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_main(argc, argv); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    for (i = 1; i &lt; argc; i++) <br>    { <br>        hrT = _HrExpandCommandLineArgument( <br>            argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>            &amp;pszArgument, &amp;pszValue); <br> <br>        if (hrT == EDK_E_NOT_FOUND) <br>        { <br>            fprintf(stderr,  <br>                "ERROR: unknown command line flag: %s\n",  <br>                argv[i]); <br>            hr = hrT; <br> <br>            // Keep parsing to show all invalid flags. <br>        } <br> <br>        else if (hrT == EDK_E_AMBIGUOUS) <br>        { <br>            fprintf(stderr,  <br>                "ERROR: ambiguous command line flag: %s\n",  <br>                argv[i]); <br>            hr = hrT; <br> <br>            // Keep parsing to show all invalid flags. <br>        } <br> <br>        else if (FAILED(hrT)) <br>        { <br>            fprintf(stderr,  <br>                "ERROR: general error while parsing command line flag: %s\n",  <br>                argv[i]); <br>            hr = hrT; <br>            goto cleanup; <br>        } <br> <br>        if (pszArgument) <br>        { <br>            // Put all the flags that do not take a value here. <br> <br>            if (!_stricmp(pszArgument,ARG_APPEND)) <br>            { <br>                opOperation = OP_APPEND; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_UPDATE)) <br>            { <br>                opOperation = OP_UPDATE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_REPLACE)) <br>            { <br>                opOperation = OP_REPLACE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_SETREAD)) <br>            { <br>                fSetRead = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NOSETREAD)) <br>            { <br>                fSetRead = FALSE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_EFD)) <br>            { <br>                fEfd = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NOEFD)) <br>            { <br>                fEfd = FALSE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_PROGRESS)) <br>            { <br>                fProgress = TRUE; <br>            } <br>            else if (!_stricmp(pszArgument,ARG_NOPROGRESS)) <br>            { <br>                fProgress = FALSE; <br>            } <br> <br>            // If we got this far we know it's a flag that requires a value,  <br>            // so if they didn't give one then it's an error.  We know it  <br>            // is a valid flag because pszArgument != NULL, and that means  <br>            // the flag is in the list. <br> <br>            else if (pszValue == NULL) <br>            { <br>                fprintf(stderr, "ERROR: flag /%s requires a value\n",  <br>                    pszArgument); <br>                hr = HR_LOG(E_FAIL); <br>            } <br> <br>            // Put all the flags that take a value here. <br> <br>            else if (!_stricmp(pszArgument,ARG_FILE)) <br>            { <br>                STRNCPY(szFile, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_FOLDERPATH)) <br>            { <br>                STRNCPY(szFolderPath, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_CLASS)) <br>            { <br>                STRNCPY(szClass, pszValue); <br>            } <br>            else if (!_stricmp(pszArgument,ARG_PROFILE)) <br>            { <br>                STRNCPY(szProfile, pszValue); <br>            } <br>        } <br>    } <br> <br>    // If any of the parsing failed then stop here. <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Make sure all required information has been given. <br> <br>    if (szFile[0] == 0) <br>    { <br>        fprintf(stderr, "ERROR: please specify /%s\n", ARG_FILE); <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCheckInfoCompleteness---------------------------------------------------- <br>//  Make sure that all required information has been given either on the  <br>//  command line or in the first line of the file.  If not, print an error  <br>//  message describing what is missing and return an error. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCheckInfoCompleteness(void) // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPRIVATE("HrCheckInfoCompleteness()"); <br> <br>    if (szFolderPath[0] == 0) <br>    { <br>        fprintf(stderr,  <br>            "ERROR: Folder Path must be specified on the command " <br>            "line or in the file.\n"); <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrGetFolderFromPath-------------------------------------------------------- <br>//  Given a path string made up of the store name and folder, return a  <br>//  pointer to a MAPI folder object. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetFolderFromPath(         // RETURNS: HRESULT <br>    IN  LPMAPISESSION   lpSession,          // current MAPI session <br>    IN  LPSTR           pszStoreFolderPath, // "storename\folderpath" <br>    OUT LPMAPIFOLDER *  lppFolder)          // folder pointer <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    LPSTR               pszStore            = NULL; <br>    ULONG               cchStore            = 0; <br>    LPSTR               pszFolderPath       = NULL; <br>    ULONG               cbEntryId           = 0; <br>    LPENTRYID           pEntryId            = NULL; <br>    LPMDB               pMdb                = NULL; <br>    ULONG               ulObjType           = 0; <br> <br>    DEBUGPRIVATE("HrGetFolderFromPath()"); <br> <br>    // Check parameters. <br> <br>    hr = CHK_HrGetFolderFromPath( <br>        lpSession,  <br>        pszStoreFolderPath,  <br>        lppFolder); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Find the first '\' in the folder path.  This separates the name  <br>    // of the store from the folder only path.  If there is no '\' then  <br>    // the path must be invalid. <br> <br>    pszFolderPath = strchr(pszStoreFolderPath, '\\'); <br> <br>    if (pszFolderPath == NULL) <br>    { <br>EventLogMsg( <br>FIMPORT_INVALID_FOLDER_PATH, <br>1, pszStoreFolderPath, <br>            0); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Allocate a separate piece of memory and copy the store name into it. <br> <br>    cchStore = pszFolderPath - pszStoreFolderPath; <br> <br>    hr = MAPIAllocateBuffer( <br>        cchStore + 1,  <br>        &amp;pszStore); <br>    if (FAILED(hr)) <br>    { <br>EventLogMsg( <br>FIMPORT_ERROR, <br>0, <br>            1, ERROR_NOT_ENOUGH_MEMORY); <br>        goto cleanup; <br>    } <br> <br>    strncpy(pszStore, pszStoreFolderPath, cchStore); <br>    pszStore[cchStore] = 0; <br> <br>    TRIM_WHITE_SPACE(pszStore); <br> <br>    // Set pszFolderPath to point to the folder path. <br> <br>    pszFolderPath++; <br> <br>    // Find the requested store, or the default store if  <br>    // they use the name "@DEFAULT". <br> <br>    if (!stricmp(pszStore, "@DEFAULT")) <br>    { <br>        hr = HrMAPIFindDefaultMsgStore( <br>            lpSession,  <br>            &amp;cbEntryId,  <br>            &amp;pEntryId); <br>        if (FAILED(hr)) <br>        { <br>    EventLogMsg( <br>    FIMPORT_CANNOT_FIND_DEFAULT_STORE, <br>    1, SZ_BASE16(hr), <br>                0); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        hr = HrMAPIFindStoreA( <br>            lpSession,  <br>            pszStore,  <br>            &amp;cbEntryId,  <br>            &amp;pEntryId); <br>        if (FAILED(hr)) <br>        { <br>    EventLogMsg( <br>    FIMPORT_CANNOT_FIND_STORE, <br>    2, pszStore, SZ_BASE16(hr), <br>                0); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // Open the requested store. <br> <br>    hr = MAPICALL(lpSession)-&gt;OpenEntry( <br>        lpSession,  <br>        cbEntryId,  <br>        pEntryId,  <br>        NULL,  <br>        MAPI_MODIFY | MAPI_DEFERRED_ERRORS,  <br>        &amp;ulObjType,  <br>        (LPUNKNOWN *)&amp;pMdb); <br>    if (FAILED(hr)) <br>    { <br>EventLogMsg( <br>FIMPORT_CANNOT_OPEN_STORE, <br>2, pszStore, SZ_BASE16(hr), <br>            0); <br>        goto cleanup; <br>    } <br>    if (ulObjType != MAPI_STORE) <br>    { <br>EventLogMsg( <br>FIMPORT_WRONG_STORE_TYPE, <br>2, pszStore, SZ_BASE16(ulObjType), <br>            0); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Open the folder indicated by the folder path. <br> <br>    MAPIFREEBUFFER(pEntryId); <br>    cbEntryId = 0; <br> <br>    hr = HrMAPIFindFolderExA( <br>        pMdb,  <br>        '\\',  <br>        pszFolderPath,  <br>        &amp;cbEntryId,  <br>        &amp;pEntryId); <br>    if (FAILED(hr)) <br>    { <br>EventLogMsg( <br>FIMPORT_CANNOT_FIND_FOLDER, <br>3, pszFolderPath, pszStore, SZ_BASE16(hr), <br>            0); <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL(lpSession)-&gt;OpenEntry( <br>        lpSession,  <br>        cbEntryId,  <br>        pEntryId,  <br>        NULL,  <br>        MAPI_MODIFY | MAPI_DEFERRED_ERRORS,  <br>        &amp;ulObjType,  <br>        (LPUNKNOWN *)lppFolder); <br>    if (FAILED(hr)) <br>    { <br>EventLogMsg( <br>FIMPORT_CANNOT_OPEN_FOLDER, <br>3, pszFolderPath, pszStore, SZ_BASE16(hr), <br>            0); <br>        goto cleanup; <br>    } <br>    if (ulObjType != MAPI_FOLDER) <br>    { <br>EventLogMsg( <br>FIMPORT_WRONG_FOLDER_TYPE, <br>3, pszFolderPath, pszStore, SZ_BASE16(ulObjType), <br>            0); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    MAPIFREEBUFFER(pEntryId); <br>    MAPIFREEBUFFER(pszStore); <br>    ULRELEASE(pMdb); <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrDoImport----------------------------------------------------------------- <br>//  Import the messages from the .CSV file into the folder. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDoImport(void)             // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPRIVATE("HrDoImport()"); <br> <br>    // Read the column headers line from the .CSV file and use it  <br>    // to build an SPropValue array. <br> <br>    hr = HrReadColumnHeaders(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Read messages from the .CSV file and write them to the folder. <br> <br>    hr = HrProcessMessages(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    MAPIFREEBUFFER(rgMessageProps); <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadColumnHeaders-------------------------------------------------------- <br>//  Read the list of column headers from the next line of the .CSV file,  <br>//  and place the resulting properties in rgMessageProps.  Use PR_NULL  <br>//  for a column that says "ATTTACH". <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadColumnHeaders(void)    // RETURNS: HRESULT <br>{ </code></pre>
<p>
</p>
<pre><code>HRESULT             hr                  = NOERROR; <br>    ULONG               iToken              = 0; <br>    ULONG               cToken              = 0; <br>    LPSTR *             rgpszToken          = NULL; <br>    LPSTR               pszToken            = NULL; <br>    LPWSTR              pwszToken           = NULL; <br>    ULONG               ulNamedPropType     = 0; <br>MAPINAMEID    sNameID    = {0}; <br>LPMAPINAMEID    rglpNameID[1]    = {&amp;sNameID}; <br>LPSPropTagArray    lpPropTags    = NULL; <br>    ULONG               iGeneratedProp      = 0; <br> <br>    DEBUGPRIVATE("HrReadColumnHeaders()"); <br> <br>    // Read a line from the file. <br> <br>    hr = HrGetCsvLine(); <br>    if (FAILED(hr)) <br>    { <br>    EventLogMsg( <br>    FIMPORT_UNEXPECTED_END_OF_FILE,  <br>    2, szFile, SZ_BASE10(iCsvLine),  <br>    0); <br>    goto cleanup; <br>    } <br> <br>    // Break the line up into tokens separated by commas.  At the same time,  <br>    // count how many properties are in the line. <br> <br>    hr = HrStrTokAll( <br>        szCsvLine,  <br>        ",",  <br>        &amp;cToken,  <br>        &amp;rgpszToken); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            FIMPORT_INTERNAL_ERROR,  <br>            1, "HrStrTokAll",  <br>            0); <br>        goto cleanup; <br>    } <br> <br>    // Calculate the number of properties, both the number coming from the  <br>    // .CSV file, as well as the number being generated in other ways  <br>    // (i.e. from /EFD and /CLASS). <br> <br>    cCsvFileMessageProps = cToken; <br>    cAllMessageProps = cToken; <br>    iGeneratedProp = cToken; <br> <br>    if (fEfd) <br>        cAllMessageProps++; <br> <br>    if (szClass[0] != 0) <br>        cAllMessageProps++; <br> <br>    // Allocate an SPropValue array big enough to hold all the properties. <br> <br>    hr = MAPIAllocateBuffer( <br>        cAllMessageProps * sizeof(SPropValue),  <br>        &amp;rgMessageProps); <br>    if (FAILED(hr)) <br>    { <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>    } <br> <br>    ZeroMemory( <br>        rgMessageProps,  <br>        cAllMessageProps * sizeof(SPropValue)); <br> <br>    // If they specified /EFD then we need to set the MS_EXCHANGE_01  <br>    // property on each message, so get/create the property tag  <br>    // for that property and add it at the end of the SPropValue array. <br> <br>    if (fEfd) <br>    { <br>    // Construct the MAPINAMEID. <br>    sNameID.lpguid = (LPGUID)&amp;PS_PUBLIC_STRINGS; <br>    sNameID.ulKind = MNID_STRING; <br>    sNameID.Kind.lpwstrName = L"MS_EXCHANGE_01"; <br> <br>    // Get the MS_EXCHANGE_01 property tag. <br> <br>    hr = MAPICALL(lpFolder)-&gt;GetIDsFromNames( <br>    lpFolder,  <br>    1,  <br>    rglpNameID,  <br>    MAPI_CREATE,  <br>    &amp;lpPropTags); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>        // Add the MS_EXCHANGE_01 property tag to the end of  <br>        // the SPropValue array. <br> <br>        rgMessageProps[iGeneratedProp].ulPropTag =  <br>            CHANGE_PROP_TYPE(lpPropTags-&gt;aulPropTag[0], PT_LONG); <br>        rgMessageProps[iGeneratedProp].Value.ul = 1; <br> <br>    MAPIFREEBUFFER(lpPropTags); <br> <br>        iGeneratedProp++; <br>    } <br> <br>    // If the specified /CLASS then we need to set the PR_MESSAGE_CLASS  <br>    // property on each message, so add it at the end of the SPropValue array. <br> <br>    if (szClass[0] != 0) <br>    { <br>        rgMessageProps[iGeneratedProp].ulPropTag = PR_MESSAGE_CLASS; <br>        rgMessageProps[iGeneratedProp].Value.lpszA = szClass; <br> <br>        iGeneratedProp++; <br>    } <br> <br>    // Loop to translate each column heading into a property id. <br> <br>    for (iToken = 0; iToken &lt; cToken; iToken++) <br>    { <br>        pszToken = rgpszToken[iToken]; <br> <br>        TRIM_WHITE_SPACE(pszToken); <br> <br>        // If it's "ATTACH" then it must be an attachment, so use  <br>        // PR_NULL as a placeholder to indicate an attachment. <br> <br>        if (!stricmp(pszToken, "ATTACH")) <br>        { <br>            rgMessageProps[iToken].ulPropTag = PR_NULL; <br>            fImportingAttachments = TRUE; <br>            continue;       // skip validity check for this property <br>        } <br> <br>        // If it has a type on it like [M]&lt;type_char&gt;:&lt;property_name&gt;  <br>        // then it must be a named property. <br> <br>        else if ( <br>            (pszToken[0] != 0 &amp;&amp; pszToken[1] == ':') <br>                ||  <br>            (pszToken[0] != 0 &amp;&amp; pszToken[1] != 0 &amp;&amp; pszToken[2] == ':') <br>            ) <br>        { <br>            // Get the property type from the prefix. <br> <br>            ULONG   ulMVFlag = 0L; <br> <br>            if( toupper(*pszToken) == PROPTYPECODE_MULTI) <br>            { <br>                ulMVFlag = MV_FLAG; <br>                pszToken++; <br>            } <br> <br>            switch (toupper(*pszToken)) <br>            { <br>            case PROPTYPECODE_LONG: <br>                ulNamedPropType = PT_LONG | ulMVFlag; <br>                break; <br> <br>            case PROPTYPECODE_STRING: <br>                ulNamedPropType = PT_STRING8 | ulMVFlag; <br>                break; <br> <br>            case PROPTYPECODE_SYSTIME: <br>                ulNamedPropType = PT_SYSTIME | ulMVFlag; <br>                break; <br> <br>            case PROPTYPECODE_UNICODE: <br>                ulNamedPropType = PT_UNICODE | ulMVFlag; <br>                break; <br> <br>            case PROPTYPECODE_BOOLEAN: <br>                ulNamedPropType = PT_BOOLEAN | ulMVFlag; <br>                break; <br> <br>            case PROPTYPECODE_BINARY: <br>                ulNamedPropType = PT_BINARY | ulMVFlag; <br>                break; <br>             <br>            case PROPTYPECODE_GUID: <br>                ulNamedPropType = PT_CLSID | ulMVFlag; <br>                break; <br> <br>            default: <br>                { <br>                    CHAR szTypePrefix[2] = {pszToken[0], 0}; <br> <br>                    EventLogMsg( <br>                        FIMPORT_INVALID_TYPE_PREFIX,  <br>                        4, szFile, SZ_BASE10(iCsvLine), szCsvLine, szTypePrefix,  <br>                        0); <br>                    goto cleanup; <br>                } <br>            } <br> <br>            // Skip past explicit property type code and colon. <br> <br>            pszToken += 2; <br> <br>            // Convert the string to UNICODE so we can look up its property tag. <br> <br>            hr = HrStrAToStrWEx(pszToken, rgpszToken, &amp;pwszToken); <br>            if (FAILED(hr)) <br>            { <br>                EventLogMsg( <br>                    FIMPORT_INTERNAL_ERROR,  <br>                    1, "HrStrAToStrWEx",  <br>                    0); <br>                goto cleanup; <br>            } <br> <br>        // Construct the MAPINAMEID. <br> <br>        sNameID.lpguid = (LPGUID)&amp;PS_PUBLIC_STRINGS; <br>        sNameID.ulKind = MNID_STRING; <br>        sNameID.Kind.lpwstrName = pwszToken; <br> <br>        // Get the property tag. <br> <br>        hr = MAPICALL(lpFolder)-&gt;GetIDsFromNames( <br>        lpFolder,  <br>        1,  <br>        rglpNameID,  <br>        MAPI_CREATE,  <br>        &amp;lpPropTags); <br>        if (FAILED(hr)) <br>        goto cleanup; <br> <br>            // Add the property type to the property tag we got and  <br>            // store it in the array. <br> <br>            rgMessageProps[iToken].ulPropTag = CHANGE_PROP_TYPE( <br>                lpPropTags-&gt;aulPropTag[0],  <br>                ulNamedPropType); <br> <br>        MAPIFREEBUFFER(lpPropTags); <br>        } <br> <br>        // Otherwise it must be a normal property, so look up its  <br>        // property tag id in the table. <br> <br>        else <br>        { <br>            // Get the property tag id from the name. <br> <br>            hr = HrGetPropTagValue( <br>                pszToken,  <br>                &amp;rgMessageProps[iToken].ulPropTag); <br>            if (FAILED(hr)) <br>            { <br>                EventLogMsg( <br>                    FIMPORT_UNKNOWN_PROPERTY,  <br>                    4, szFile, SZ_BASE10(iCsvLine), szCsvLine, pszToken,  <br>                    0); <br>                goto cleanup; <br>            } <br> <br>        } <br> <br>        // Make sure the property type is one of the ones we support. <br> <br>        switch (PROP_TYPE(rgMessageProps[iToken].ulPropTag)) <br>        { <br>        case PT_BINARY: <br>        case PT_MV_BINARY: <br>        case PT_BOOLEAN: <br>        case PT_LONG: <br>        case PT_MV_LONG: <br>        case PT_STRING8: <br>        case PT_MV_STRING8: <br>        case PT_SYSTIME: <br>        case PT_UNICODE: <br>        case PT_MV_UNICODE: <br>        case PT_CLSID: <br>            // OK. <br>            break; <br> <br>        default: <br>EventLogMsg( <br>FIMPORT_UNSUPPORTED_PROPERTY_TYPE,  <br>4, szFile, SZ_BASE10(iCsvLine), szCsvLine,  <br>                    SZ_BASE16(rgMessageProps[iToken].ulPropTag),  <br>0); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>cleanup: <br>    if (FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(rgMessageProps); <br>    } <br>    MAPIFREEBUFFER(rgpszToken); <br>MAPIFREEBUFFER(lpPropTags); <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrProcessMessages---------------------------------------------------------- <br>//  Read messages from the .CSV file and write them to the folder. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrProcessMessages(void)      // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    ULONG               iToken              = 0; <br>    ULONG               cToken              = 0; <br>    LPSTR *             rgpszToken          = NULL; <br>    LPMESSAGE           pMsg                = NULL; <br>    LPSPropProblemArray pProblems           = NULL; <br>    LPMAPITABLE         lpContentsTable     = NULL; <br>    SizedSPropTagArray(1, sEntryIdOnly)     = {1, PR_ENTRYID}; <br>    LPSRowSet           pFolderRow          = NULL; <br>    ULONG               ulObjType           = 0; <br>    BOOL                fUpdateMessages     = FALSE; <br>    LPMAPITABLE         pAttachmentTable    = NULL; <br>    LPSRowSet           pAttachments        = NULL; <br>    ULONG               iAttachment         = 0; <br> <br>    DEBUGPRIVATE("HrProcessMessages()"); <br> <br>    // If they said /REPLACE then delete all the messages in the folder. <br> <br>    if (opOperation == OP_REPLACE) <br>    { <br>        hr = MAPICALL(lpFolder)-&gt;EmptyFolder( <br>            lpFolder,  <br>            0,  <br>            NULL,  <br>            0); <br>        if (FAILED(hr)) <br>        { <br>EventLogMsg( <br>FIMPORT_INTERNAL_ERROR,  <br>1, "EmptyFolder",  <br>0); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // If they said /UPDATE then open the folder's contents table. <br> <br>    if (opOperation == OP_UPDATE) <br>    { <br>        // Open the table and set to get only the entry ids. <br> <br>        hr = MAPICALL(lpFolder)-&gt;GetContentsTable( <br>            lpFolder,  <br>            MAPI_DEFERRED_ERRORS,  <br>            &amp;lpContentsTable); <br>        if (FAILED(hr)) <br>        { <br>EventLogMsg( <br>FIMPORT_INTERNAL_ERROR,  <br>1, "GetContentsTable",  <br>0); <br>            goto cleanup; <br>        } <br> <br>        hr = MAPICALL(lpContentsTable)-&gt;SetColumns( <br>            lpContentsTable,  <br>            (LPSPropTagArray) &amp;sEntryIdOnly,  <br>            0); <br>        if (FAILED(hr)) <br>        { <br>EventLogMsg( <br>FIMPORT_INTERNAL_ERROR,  <br>1, "SetColumns",  <br>0); <br>            goto cleanup; <br>        } <br> <br>        // Set the flag that shows we are updating messages. <br>        // (If we run out of messages to update, this flag will  <br>        // be set to false and we will then start creating new  <br>        // messages). <br> <br>        fUpdateMessages = TRUE; <br>    } <br> <br>    // Loop to import messages. <br> <br>    while (TRUE) <br>    { <br>        // Read a line from the file. <br> <br>        hr = HrGetCsvLine(); <br> <br>        // If we got an end of file then we're done. <br> <br>        if (hr == EDK_E_END_OF_FILE) <br>        { <br>            hr = NOERROR; <br>            break; <br>        } <br> <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        // Display a progress indicator. <br> <br>        if (fProgress) <br>        { <br>            printf("\rImporting message %d...", cMessagesImported + 1); <br>        } <br> <br>        // Break the line up into tokens separated by commas. <br> <br>        hr = HrStrTokAll( <br>            szCsvLine,  <br>            ",",  <br>            &amp;cToken,  <br>            &amp;rgpszToken); <br>        if (FAILED(hr)) <br>        { <br>            EventLogMsg( <br>                FIMPORT_INTERNAL_ERROR,  <br>                1, "HrStrTokAll",  <br>                0); <br>            goto cleanup; <br>        } <br> <br>        // Make sure the number of properties in this line matches  <br>        // the number in the header line. <br> <br>        if (cToken != cCsvFileMessageProps) <br>        { <br>            EventLogMsg( <br>                FIMPORT_WRONG_NUMBER_OF_PROPERTY_VALUES,  <br>                3, szFile, SZ_BASE10(iCsvLine), szCsvLine,  <br>                0); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // If we are updating messages then open the next message in the folder. <br> <br>        if (fUpdateMessages) <br>        { <br>            // Get the next message entry id from the contents table. <br> <br>            hr = MAPICALL(lpContentsTable)-&gt;QueryRows( <br>                lpContentsTable,  <br>                1,  <br>                0,  <br>                &amp;pFolderRow); <br>            if (FAILED(hr)) <br>            { <br>                EventLogMsg( <br>                    FIMPORT_INTERNAL_ERROR,  <br>                    1, "QueryRows",  <br>                    0); <br>                goto cleanup; <br>            } <br> <br>            // If we got a message then open it. <br> <br>            if (pFolderRow-&gt;cRows) <br>            { <br>                // Open the message. <br> <br>                hr = MAPICALL(lpFolder)-&gt;OpenEntry( <br>                    lpFolder,  <br>                    pFolderRow-&gt;aRow[0].lpProps[0].Value.bin.cb,  <br>                    (LPENTRYID)pFolderRow-&gt;aRow[0].lpProps[0].Value.bin.lpb,  <br>                    NULL,  <br>                    MAPI_MODIFY | MAPI_DEFERRED_ERRORS,  <br>                    &amp;ulObjType,  <br>                    (LPUNKNOWN *) &amp;pMsg); <br>                if (FAILED(hr)) <br>                { <br>            EventLogMsg( <br>            FIMPORT_INTERNAL_ERROR, <br>            1, "OpenEntry", <br>                        0); <br>                    goto cleanup; <br>                } <br>                if (ulObjType != MAPI_MESSAGE) <br>                { <br>            EventLogMsg( <br>            FIMPORT_WRONG_MESSAGE_TYPE, <br>            1, SZ_BASE16(ulObjType), <br>                        0); <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                // If we are importing attachments then clear  <br>                // out any old attachments in the message. <br> <br>                if (fImportingAttachments) <br>                { <br>                    SizedSPropTagArray(1, sGetAttachNums) = {1, PR_ATTACH_NUM}; <br> <br>                    // Get the attachment numbers of all the attachments. <br> <br>                    hr = MAPICALL(pMsg)-&gt;GetAttachmentTable( <br>                        pMsg,  <br>                        0,  <br>                        &amp;pAttachmentTable); <br>                    if (FAILED(hr)) <br>                    { <br>                EventLogMsg( <br>                FIMPORT_INTERNAL_ERROR, <br>                1, "GetAttachmentTable", <br>                            0); <br>                        goto cleanup; <br>                    } <br> <br>                    hr = HrQueryAllRows( <br>                        pAttachmentTable,  <br>                        (LPSPropTagArray) &amp;sGetAttachNums,  <br>                        NULL,  <br>                        NULL,  <br>                        0,  <br>                        &amp;pAttachments); <br>                    if (FAILED(hr)) <br>                    { <br>                EventLogMsg( <br>                FIMPORT_INTERNAL_ERROR, <br>                1, "HrQueryAllRows", <br>                            0); <br>                        goto cleanup; <br>                    } <br> <br>                    // Delete them all. <br> <br>                    for ( <br>                        iAttachment = 0;  <br>                        iAttachment &lt; pAttachments-&gt;cRows;  <br>                        iAttachment++) <br>                    { <br>                        hr = MAPICALL(pMsg)-&gt;DeleteAttach( <br>                            pMsg,  <br>                            pAttachments-&gt;aRow[iAttachment].lpProps[0].Value.ul,  <br>                            0,  <br>                            NULL,  <br>                            0); <br>                        if (FAILED(hr)) <br>                        { <br>                    EventLogMsg( <br>                    FIMPORT_INTERNAL_ERROR, <br>                    1, "DeleteAttach", <br>                                0); <br>                            goto cleanup; <br>                        } <br>                    } <br> <br>                    ULRELEASE(pAttachmentTable); <br>                    MAPIFREEBUFFER(pAttachments); <br>                } <br>            } <br> <br>            // If we ran out of messages then clear the flag  <br>            // and we will start creating them instead. <br> <br>            else <br>                fUpdateMessages = FALSE; <br> <br>            MAPIFREEBUFFER(pFolderRow); <br>        } <br> <br>        // If we don't have a message yet then create one. <br> <br>        if (pMsg == NULL) <br>        { <br>            hr = MAPICALL(lpFolder)-&gt;CreateMessage( <br>                lpFolder,  <br>                NULL,  <br>                MAPI_DEFERRED_ERRORS,  <br>                &amp;pMsg); <br>            if (FAILED(hr)) <br>            { <br>        EventLogMsg( <br>        FIMPORT_INTERNAL_ERROR, <br>        1, "CreateMessage", <br>                    0); <br>                goto cleanup; <br>            } <br>        } <br> <br>        // Loop to fill in values for each property. <br> <br>        for (iToken = 0; iToken &lt; cToken; iToken++) <br>        { <br>            // Clear the Value part of the SPropValue structure  <br>            // so we are sure there isn't any garbage left  <br>            // there from the previous pass through this loop. <br> <br>            ZeroMemory( <br>                &amp;(rgMessageProps[iToken].Value),  <br>                sizeof(rgMessageProps[iToken].Value)); <br> <br>            // If this "property" is really an attachment then add it  <br>            // to the message. <br> <br>            if (rgMessageProps[iToken].ulPropTag == PR_NULL) <br>            { <br>                TRIM_WHITE_SPACE(rgpszToken[iToken]); <br> <br>                hr = HrCreateMessageAttachment( <br>                    pMsg,  <br>                    rgpszToken[iToken]); <br>                if (FAILED(hr)) <br>                    goto cleanup; <br>            } <br> <br>            // Otherwise add the property to the SPropValue array. <br> <br>            else <br>            { <br>                if( rgMessageProps[iToken].ulPropTag &amp; MV_FLAG) <br>                    hr = HrParseMultiPropValue( <br>                        rgMessageProps[iToken].ulPropTag,  <br>                        rgpszToken[iToken],  <br>                        rgpszToken,  <br>                        &amp;rgMessageProps[iToken]); <br>                else <br>                    hr = HrParsePropValue( <br>                        rgMessageProps[iToken].ulPropTag,  <br>                        rgpszToken[iToken],  <br>                        rgpszToken,  <br>                        &amp;rgMessageProps[iToken]); <br>                if (FAILED(hr)) <br>                    goto cleanup; <br>            } <br>        } <br> <br>        // Set the properties on the message. <br> <br>        hr = MAPICALL(pMsg)-&gt;SetProps( <br>            pMsg,  <br>            cAllMessageProps,  <br>            rgMessageProps,  <br>            &amp;pProblems); <br>        if (FAILED(hr)) <br>        { <br>    EventLogMsg( <br>    FIMPORT_INTERNAL_ERROR, <br>    1, "SetProps", <br>                0); <br>            goto cleanup; <br>        } <br>if (pProblems != NULL) <br>{ <br>    EventLogMsg( <br>    FIMPORT_PROBLEMS_SETTING_MESSAGE_PROPERTIES, <br>    0, <br>                0); <br> <br>MAPIFREEBUFFER(pProblems); <br> <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>        // Set or clear the read flag according to /SETREAD. <br> <br>        hr = MAPICALL(pMsg)-&gt;SetReadFlag( <br>            pMsg,  <br>            fSetRead ? SUPPRESS_RECEIPT : CLEAR_READ_FLAG); <br>        if (FAILED(hr)) <br>        { <br>    EventLogMsg( <br>    FIMPORT_INTERNAL_ERROR, <br>    1, "SetReadFlag", <br>                0); <br>            goto cleanup; <br>        } <br> <br>        // Save the changes to the message and release it. <br> <br>        hr = MAPICALL(pMsg)-&gt;SaveChanges(pMsg, 0); <br>        if (FAILED(hr)) <br>        { <br>    EventLogMsg( <br>    FIMPORT_INTERNAL_ERROR, <br>    1, "SaveChanges", <br>                0); <br>            goto cleanup; <br>        } <br> <br>        ULRELEASE(pMsg); <br> <br>        // Increment the imported messages count. <br> <br>        cMessagesImported++; <br> <br>        // Free the allocated list of tokens. <br> <br>        MAPIFREEBUFFER(rgpszToken); <br>    } <br> <br>cleanup: <br>    // Clean up the progress indicator. <br> <br>    if (fProgress &amp;&amp; cMessagesImported) <br>    { <br>        printf("\r                                          \r"); <br>    } <br> <br>    // Free resources. <br>    ULRELEASE(pAttachmentTable); <br>    ULRELEASE(lpContentsTable); <br>    ULRELEASE(pMsg); <br>    MAPIFREEBUFFER(pAttachments); <br>    MAPIFREEBUFFER(pFolderRow); <br>    MAPIFREEBUFFER(rgpszToken); <br>    MAPIFREEBUFFER(pProblems); <br>    RETURN(hr); <br>} <br> <br>//$--HrParseMultiPropValue------------------------------------------------------- <br>//  Takes a text version of a multi-valued property and fills in an SPropValue  <br>//  structure.  If memory needs to be allocated, it is allocated using  <br>//  MAPIAllocateMore() based on the object passed in pBaseObject. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParseMultiPropValue(       // RETURNS: HRESULT <br>IN ULONG            ulPropTag,          // property tag of this property <br>IN LPTSTR           pszValueText,       // text of property value to parse <br>IN LPVOID           pBaseObject,        // base object for MAPIAllocateMore() <br>OUT LPSPropValue    pProp)              // structure to write results <br>{ <br>HRESULT             hr                  = NOERROR; <br>    ULONG               cToken              = 0L; <br>    LPTSTR*             rgpszToken          = NULL; <br>    SPropValue          pvaSingleProp       = {0}; <br>    ULONG               i;  // loop <br> <br>DEBUGPRIVATE("HrParseMultiPropValue()"); <br> <br>hr = CHK_HrParseMultiPropValue( <br>ulPropTag,  <br>pszValueText,  <br>pBaseObject,  <br>pProp); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrStrTokAll( <br>        pszValueText,  <br>        "%",  <br>        &amp;cToken,  <br>        &amp;rgpszToken); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            FIMPORT_INTERNAL_ERROR,  <br>            1, "HrStrTokAll",  <br>            0); <br>        goto cleanup; <br>    } <br> <br>    for( i=0; i&lt;cToken; i++) <br>    { <br>        hr = HrParsePropValue( <br>            ulPropTag &amp; ~MV_FLAG, <br>            rgpszToken[i], <br>            pBaseObject, <br>            (LPSPropValue)&amp;pvaSingleProp); <br>        if( FAILED (hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        switch (PROP_TYPE(ulPropTag)) <br>    { <br>            // PT_MV_BINARY <br> <br>    case PT_MV_BINARY: <br>    { <br>                if( !pProp-&gt;Value.MVbin.lpbin) <br>                { <br>                    hr = MAPIAllocateMore( cToken * sizeof(SBinary), pBaseObject, &amp;pProp-&gt;Value.MVbin.lpbin); <br>        if (FAILED(hr)) <br>        { <br>        EventLogMsg( <br>        EDKEVENT_ERROR,  <br>        0,  <br>        1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>        } <br> <br>                    pProp-&gt;Value.MVbin.cValues = cToken; <br>                } <br> <br>                // Relocate single value to MV property array <br> <br>                pProp-&gt;Value.MVbin.lpbin[i].cb  = pvaSingleProp.Value.bin.cb; <br>                pProp-&gt;Value.MVbin.lpbin[i].lpb = pvaSingleProp.Value.bin.lpb; <br> <br>    break; <br>    } <br> <br>            // PT_MV_LONG <br> <br>    case PT_MV_LONG: <br>            { <br>                if( !pProp-&gt;Value.MVl.lpl) <br>                { <br>                    hr = MAPIAllocateMore( cToken * sizeof(LONG), pBaseObject, &amp;pProp-&gt;Value.MVl.lpl); <br>        if (FAILED(hr)) <br>        { <br>        EventLogMsg( <br>        EDKEVENT_ERROR,  <br>        0,  <br>        1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>        } <br> <br>                    pProp-&gt;Value.MVl.cValues = cToken; <br>                } <br> <br>                // Relocate single value to MV property array <br> <br>                pProp-&gt;Value.MVl.lpl[i] = pvaSingleProp.Value.l; <br> <br>    break; <br>            } <br> <br>            // PT_MV_STRING8 <br> <br>    case PT_MV_STRING8: <br>    { <br>                if( !pProp-&gt;Value.MVszA.lppszA) <br>                { <br>                    hr = MAPIAllocateMore( cToken * sizeof(LPSTR), pBaseObject, (PVOID*)&amp;pProp-&gt;Value.MVszA.lppszA); <br>        if (FAILED(hr)) <br>        { <br>        EventLogMsg( <br>        EDKEVENT_ERROR,  <br>        0,  <br>        1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>        } <br> <br>                    pProp-&gt;Value.MVszA.cValues = cToken; <br>                } <br> <br>                // Relocate single value to MV property array <br> <br>                pProp-&gt;Value.MVszA.lppszA[i] = pvaSingleProp.Value.lpszA; <br> <br>    break; <br>    } <br> <br>            // PT_MV_UNICODE <br> <br>    case PT_MV_UNICODE: <br>    { <br>                if( !pProp-&gt;Value.MVszW.lppszW) <br>                { <br>                    hr = MAPIAllocateMore( cToken * sizeof(LPWSTR), pBaseObject, (PVOID*)&amp;pProp-&gt;Value.MVszW.lppszW); <br>        if (FAILED(hr)) <br>        { <br>        EventLogMsg( <br>        EDKEVENT_ERROR,  <br>        0,  <br>        1, ERROR_OUTOFMEMORY); <br>        goto cleanup; <br>        } <br> <br>                    pProp-&gt;Value.MVszW.cValues = cToken; <br>                } <br> <br>                // Relocate single value to MV property array <br> <br>                pProp-&gt;Value.MVszW.lppszW[i] = pvaSingleProp.Value.lpszW; <br> <br>    break; <br>    } <br> <br>            // Non-Supported Property Types <br> <br>    default: <br>    { <br>    hr = HR_LOG(E_NOTIMPL); <br>    EventLogMsg( <br>    FIMPORT_UNSUPPORTED_PROPERTY_TYPE,  <br>    4, szFile, SZ_BASE10(iCsvLine), szCsvLine, SZ_BASE16(PROP_TYPE(ulPropTag)),  <br>    0); <br>    goto cleanup; <br>    } <br>    } // switch <br>    }   // for <br> <br>pProp-&gt;ulPropTag = ulPropTag; <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrParsePropValue----------------------------------------------------------- <br>//  Takes a text version of a property value and fills in an SPropValue  <br>//  structure.  If memory needs to be allocated, it is allocated using  <br>//  MAPIAllocateMore() based on the object passed in pBaseObject. <br>// <br>//  Valid property value formats for property types are as follows (and do  <br>//  not include the quotes): <br>// <br>//  PT_BINARY   a series of two digit hex numbers separated by spaces <br>//              (e.g. "01 fe 2a 00 1c") <br>// <br>//  PT_BOOLEAN  the value 1 or 0 (1=True, 0=False) <br>// <br>//  PT_LONG     a decimal or hex constant (e.g. "127" or "0x0fff0003") <br>// <br>//  PT_STRING8  any string of characters (e.g. "Exchange is fun!") <br>// <br>//  PT_SYSTIME  a date in the format "yyyy/mm/dd hh:mm:ss"  <br>//              (e.g. "1995/12/31 23:59:59") <br>// <br>//  PT_CLSID    fully formatted GUID (e.g. "{########-####-####-####-############}" <br>//              where '#' is any hex digit) <br>//  <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParsePropValue(            // RETURNS: HRESULT <br>IN ULONG            ulPropTag,          // property tag of this property <br>IN LPTSTR           pszValueText,       // text of property value to parse <br>IN LPVOID           pBaseObject,        // base object for MAPIAllocateMore() <br>OUT LPSPropValue    pProp)              // structure to write results <br>{ <br>HRESULT             hr                  = NOERROR; <br>LPTSTR              psz                 = NULL; <br>LPTSTR              pszPrev             = NULL; <br> <br>DEBUGPRIVATE("HrParsePropValue()"); <br> <br>hr = CHK_HrParsePropValue( <br>ulPropTag,  <br>pszValueText,  <br>pBaseObject,  <br>pProp); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>switch (PROP_TYPE(ulPropTag)) <br>{ <br>        // PT_BINARY <br> <br>case PT_BINARY: <br>{ <br>ULONG cb = 0; <br>ULONG ib = 0; <br>LPBYTE pb = NULL; <br>LONG lNumber = 0; <br> <br>// Count the bytes and check that all the bytes are valid. <br> <br>psz = pszValueText; <br>while (*psz) <br>{ <br>if (isspace(*psz)) <br>psz++; <br>else <br>{ <br>pszPrev = psz; <br>lNumber = strtol(psz, &amp;psz, 16); <br>if (psz == pszPrev || lNumber &gt; UCHAR_MAX || lNumber &lt; 0) <br>            { <br>    hr = HR_LOG(E_FAIL); <br>    EventLogMsg( <br>    FIMPORT_ILLEGAL_BINARY_VALUE,  <br>    4, szFile, SZ_BASE10(iCsvLine), szCsvLine, pszValueText,  <br>    0); <br>    goto cleanup; <br>            } <br>cb++; <br>} <br>} <br> <br>// Allocate a buffer big enough for the number of bytes. <br> <br>hr = MAPIAllocateMore(cb, pBaseObject, &amp;pProp-&gt;Value.bin.lpb); <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>} <br>pProp-&gt;Value.bin.cb = cb; <br> <br>// Write the bytes into the buffer. <br> <br>psz = pszValueText; <br>for (ib = 0, pb = pProp-&gt;Value.bin.lpb; ib &lt; cb; ib++, pb++) <br>{ <br>*pb = (BYTE)strtol(psz, &amp;psz, 16); <br>} <br> <br>break; <br>} <br> <br>        // PT_CLSID <br> <br>case PT_CLSID: <br>{ <br>            CLSID     clsidTemp; <br>            LPOLESTR  pwszValueText; </code></pre>
<p>
</p>
<pre><code><br>            hr = HrStrToStrW( pszValueText, &amp;pwszValueText); <br>            if( FAILED( hr)) <br>                goto cleanup; <br> <br>            hr = CLSIDFromString( pwszValueText, &amp;clsidTemp); <br> <br>            MAPIFREEBUFFER( pwszValueText); <br> <br>            if( FAILED( hr)) <br>            { <br>EventLogMsg( <br>FIMPORT_ILLEGAL_GUID_VALUE,  <br>4, szFile, SZ_BASE10(iCsvLine), szCsvLine, pszValueText,  <br>0); <br>goto cleanup; <br>} <br> <br>// Allocate a buffer big enough for a GUID. <br> <br>hr = MAPIAllocateMore(sizeof(GUID), pBaseObject, &amp;pProp-&gt;Value.lpguid); <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>// Write the bytes into the buffer. <br> <br>CopyMemory( pProp-&gt;Value.lpguid, &amp;clsidTemp, sizeof( GUID)); <br> <br>break; <br>} <br> <br>        // PT_BOOLEAN <br> <br>case PT_BOOLEAN: <br>        { <br>        psz = pszValueText; <br> <br>        while (isspace(*psz)) <br>        psz++; <br> <br>        pszPrev = psz; <br>pProp-&gt;Value.l = strtol(psz, &amp;psz, 0); <br> <br>        while (isspace(*psz)) <br>        psz++; <br> <br>        if (psz == pszPrev || *psz ||  <br>        (pProp-&gt;Value.l != 0 &amp;&amp; pProp-&gt;Value.l != 1)) <br>        { <br>    hr = HR_LOG(E_FAIL); <br>    EventLogMsg( <br>    FIMPORT_ILLEGAL_BOOLEAN_VALUE,  <br>4, szFile, SZ_BASE10(iCsvLine), szCsvLine, pszValueText,  <br>    0); <br>    goto cleanup; <br>        } <br>    break; <br>        } <br> <br>        // PT_LONG <br> <br>case PT_LONG: <br>        { <br>        psz = pszValueText; <br> <br>        while (isspace(*psz)) <br>        psz++; <br> <br>        pszPrev = psz; <br>pProp-&gt;Value.l = strtol(psz, &amp;psz, 0); <br> <br>        while (isspace(*psz)) <br>        psz++; <br> <br>        if (psz == pszPrev || *psz) <br>        { <br>    hr = HR_LOG(E_FAIL); <br>    EventLogMsg( <br>    FIMPORT_ILLEGAL_LONG_VALUE,  <br>4, szFile, SZ_BASE10(iCsvLine), szCsvLine, pszValueText,  <br>    0); <br>    goto cleanup; <br>        } <br>break; <br>        } <br> <br>        // PT_STRING8 <br> <br>case PT_STRING8: <br>{ <br>ULONG cb = cbStrLenA(pszValueText); <br> <br>hr = MAPIAllocateMore(cb, pBaseObject, &amp;pProp-&gt;Value.lpszA); <br>if (FAILED(hr)) <br>{ <br>    hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>} <br>CopyMemory(pProp-&gt;Value.lpszA, pszValueText, cb); <br>break; <br>} <br> <br>        // PT_UNICODE <br> <br>case PT_UNICODE: <br>{ <br>            hr = HrStrAToStrWEx( <br>                pszValueText,  <br>                pBaseObject,  <br>                &amp;pProp-&gt;Value.lpszW); <br>if (FAILED(hr)) <br>{ <br>    hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>} <br>break; <br>} <br> <br>        // PT_SYSTIME <br> <br>case PT_SYSTIME: <br>{ <br>SYSTEMTIME st = {0}; <br>        CHAR chBogus = 0; <br>int lReturn = 0; <br>BOOL fItWorked = TRUE; <br> <br>lReturn = sscanf( <br>pszValueText,  <br>" %hd/%hd/%hd %hd:%hd:%hd %c",  <br>&amp;st.wYear,  <br>&amp;st.wMonth,  <br>&amp;st.wDay,  <br>&amp;st.wHour,  <br>&amp;st.wMinute,  <br>&amp;st.wSecond,  <br>&amp;chBogus); <br>if (lReturn == 0 || lReturn == EOF || chBogus) <br>{ <br>hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>FIMPORT_ILLEGAL_SYSTIME_VALUE,  <br>4, szFile, SZ_BASE10(iCsvLine), szCsvLine, pszValueText,  <br>0); <br>goto cleanup; <br>} <br> <br>fItWorked = SystemTimeToFileTime(&amp;st, &amp;pProp-&gt;Value.ft); <br>if (!fItWorked) <br>{ <br>hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>FIMPORT_INTERNAL_ERROR,  <br>1, "SystemTimeToFileTime",  <br>0); <br>goto cleanup; <br>} <br> <br>break; <br>} <br> <br>        // Non-Supported Property Types <br> <br>default: <br>{ <br>hr = HR_LOG(E_NOTIMPL); <br>EventLogMsg( <br>FIMPORT_UNSUPPORTED_PROPERTY_TYPE,  <br>4, szFile, SZ_BASE10(iCsvLine), szCsvLine, SZ_BASE16(ulPropTag),  <br>0); <br>goto cleanup; <br>} <br>} <br> <br>pProp-&gt;ulPropTag = ulPropTag; <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCreateMessageAttachment----------------------------------------------- <br>// <br>// DESCRIPTION: Create a message attachment and write the contents of the <br>//specified file to it.  Also create various required properties <br>//for the message attachment. <br>// <br>// INPUT: <br>// <br>//[lpMsg]-- Message for which attachment is to be created. <br>//[lpszAttachPath]-- Path of file containing attachment text. <br>// <br>// RETURNS: HRESULT --  NOERROR if O.K.,  <br>//                      E_INVALIDARG if invalid parameter, <br>//                      E_OUTOFMEMORY if memory problems, <br>//                      E_FAIL if call fails <br>// <br>//--------------------------------------------------------------------------- <br> <br> <br>HRESULT HrCreateMessageAttachment(          // RETURNS: HRESULT <br>INLPMESSAGElpMsg,              // MAPI message pointer <br>INLPSTRlpszAttachPath      // list of attachment file names <br>) <br>{ <br>    HRESULT         hr              =   NOERROR;    // return code <br>ULONGcb              =   0; <br>LPATTACHlpAttach        =NULL; <br>ULONGulAttachmentNum =   0; <br>    ULONG           nAttachments    =   0;      // # of attachments <br>    ULONG           iAttach         =   0;      // attachment index <br>    LPSTR           lpszCurrent     =   NULL;   // current attachment <br>LPSTR *lppszAttachTok=NULL;// array of tokenized attachments <br> <br>    // MAPI property creation flags.     <br>    const ULONG     ulFlags     =   MAPI_CREATE | MAPI_MODIFY |  <br>                                    MAPI_DEFERRED_ERRORS;   // reduces RPCs <br> <br>    // # of attachment properties <br>    #define CVALUES 3 <br> <br>    // property value array <br>    SPropValue      aPropVals[CVALUES]  =   {0}; <br> <br>    DEBUGPRIVATE("HrCreateMessageAttachment()"); <br> <br>    // Check input parameters <br>    hr = CHK_HrCreateMessageAttachment(lpMsg, lpszAttachPath); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Determine number of attachments by breaking into tokens <br>hr = HrStrTokAll( <br>lpszAttachPath,// file name list <br>";",                // separator character <br>&amp;nAttachments,// # of file names <br>&amp;lppszAttachTok);// array of strings pointer <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            FIMPORT_INTERNAL_ERROR,  <br>            1, "HrStrTokAll",  <br>            0); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR((nAttachments != 0), "Bad nAttachments"); <br>ASSERT_READ_PTR(lppszAttachTok, sizeof(LPSTR) * nAttachments,  <br>"Bad lppszAttachTok"); <br> <br>    // Process each attachment. <br>    for ( iAttach = 0; iAttach &lt; nAttachments; iAttach++ ) <br>    { <br>    // Create required additional properties. <br>LPSPropProblemArraylpProblems =NULL; <br>LPSTRlpszFileName    =   NULL; <br> <br>        // Release MAPI objects <br>    ULRELEASE(lpAttach); <br> <br>// Retrieve next attachment <br>lpszCurrent = lppszAttachTok[iAttach]; <br> <br>ASSERT_STRINGA_PTR(lpszCurrent, "Bad lpszCurrent"); <br> <br>    // Create the attachment in the message. <br>    hr = MAPICALL(lpMsg)-&gt;CreateAttach(lpMsg,  <br>                             NULL, <br> MAPI_DEFERRED_ERRORS,  // reduces RPCs <br> &amp;ulAttachmentNum, <br> &amp;lpAttach); <br>        if (FAILED(hr)) <br>        { <br>            EventLogMsg( <br>                FIMPORT_INTERNAL_ERROR,  <br>                1, "IMessage::CreateAttach()",  <br>                0); <br>            goto cleanup; <br>        } <br> <br>        ASSERT_IUNKNOWN_PTR(lpAttach, "Bad lpAttach"); <br>         <br>aPropVals[0].ulPropTag =PR_ATTACH_METHOD; <br>aPropVals[0].Value.l =ATTACH_BY_VALUE; <br> <br>lpszFileName = strrchr(lpszCurrent, '\\'); <br> <br>if (!lpszFileName) <br>lpszFileName = lpszCurrent; <br>else <br>lpszFileName++;// Advance past the backslash. <br> <br>// CAVEAT - We don't do anything here to check for  <br>        // invalid FAT 8.3 names. <br>aPropVals[1].ulPropTag =PR_ATTACH_FILENAME; <br>aPropVals[1].Value.lpszA =lpszFileName; <br> <br>aPropVals[2].ulPropTag =PR_ATTACH_LONG_FILENAME; <br>aPropVals[2].Value.lpszA =lpszFileName; <br> <br>hr = MAPICALL(lpAttach)-&gt;SetProps(lpAttach,  <br>            CVALUES,  <br>            aPropVals,  <br>            &amp;lpProblems); <br>        if (FAILED(hr)) <br>        { <br>            EventLogMsg( <br>                FIMPORT_INTERNAL_ERROR,  <br>                1, "IMAPIProp::SetProps()",  <br>                0); <br>            goto cleanup; <br>        } <br> <br>if (lpProblems != NULL) <br>{ <br>    EventLogMsg( <br>    FIMPORT_PROBLEMS_SETTING_MESSAGE_PROPERTIES, <br>    0, <br>                0); <br> <br>MAPIFREEBUFFER(lpProblems); <br> <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>        // Create the PR_ATTACH_DATA_BIN property from the attachment <br>        // file text. <br>        hr = HrMAPISetPropFromFile( <br>            (LPMAPIPROP) lpAttach,  // pointer to attachment object <br>            PR_ATTACH_DATA_BIN,     // property tag <br>            lpszCurrent,            // fully-pathed file name from which to read data <br>            &amp;cb);                   // # bytes read in <br>        if (FAILED(hr)) <br>        { <br>            EventLogMsg( <br>                FIMPORT_CANNOT_ADD_ATTACHMENT,  <br>4, szFile, SZ_BASE10(iCsvLine), szCsvLine, lpszCurrent,  <br>                0); <br>            goto cleanup; <br>        } <br> <br>    // Commit the attachment changes. <br>    hr = MAPICALL(lpAttach)-&gt;SaveChanges(lpAttach, 0); <br>        if (FAILED(hr)) <br>        { <br>            EventLogMsg( <br>                FIMPORT_INTERNAL_ERROR,  <br>                1, "IMAPIProp::SaveChanges()",  <br>                0); <br>            goto cleanup; <br>        } <br>    }   // end for each attachment <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Release MAPI and OLE objects <br>ULRELEASE(lpAttach); <br> <br>// Free MAPI buffers <br>MAPIFREEBUFFER(lppszAttachTok); <br> <br>RETURN(hr); <br> <br>} <br> <br> <br> <br>//$--HrStrAToStrWEx------------------------------------------------------------- <br>//  Convert a byte string to a word string.  The resulting string is placed in  <br>//  a buffer allocated using MAPIAllocateBuffer if lpvBaseObject == NULL,  <br>//  or MAPIAllocateMore if lpvBaseObject != NULL. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrStrAToStrWEx( <br>    IN  LPCSTR          lpszSource,     // source string <br>    IN  LPVOID          lpvBaseObject,  // base object for MAPIAllocateMore <br>    OUT LPWSTR *        lppwszDest)     // destination string <br>{ <br>    HRESULT             hr              = NOERROR; <br>    LONG                cchDest         = 0; <br>    LPWSTR              lpwszDest       = NULL; <br> <br>    DEBUGPUBLIC("HrStrAToStrWEx()"); <br> <br>    hr = CHK_HrStrAToStrWEx(lpszSource, lpvBaseObject, lppwszDest); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Compute the number of word characters needed for the destination buffer. <br> <br>    if (*lpszSource) <br>    { <br>        cchDest = MultiByteToWideChar( <br>            CP_ACP,  <br>            MB_PRECOMPOSED,  <br>            lpszSource,  <br>            strlen(lpszSource),  <br>            NULL,  <br>            0); <br>        if (cchDest == 0) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // Allocate the destination string buffer. <br> <br>    if (lpvBaseObject == NULL) <br>    { <br>        hr = MAPIAllocateBuffer( <br>            (cchDest + 1) * sizeof(WCHAR),  <br>            &amp;lpwszDest); <br>    } <br>    else <br>    { <br>        hr = MAPIAllocateMore( <br>            (cchDest + 1) * sizeof(WCHAR),  <br>            lpvBaseObject,  <br>            &amp;lpwszDest); <br>    } <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Convert from byte string to word string. <br> <br>    if (*lpszSource) <br>    { <br>        cchDest = MultiByteToWideChar( <br>            CP_ACP,  <br>            MB_PRECOMPOSED,  <br>            lpszSource,  <br>            strlen(lpszSource),  <br>            lpwszDest,  <br>            cchDest); <br>        if (cchDest == 0) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br>    lpwszDest[cchDest] = 0; <br> <br>    // Store in output parameter. <br> <br>    *lppwszDest = lpwszDest; <br> <br>cleanup: <br>    if (FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpwszDest); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>// <br>// File Access Routines <br>// <br> <br>// The import source may be changed from a file to some other  <br>// source by replacing the following routines. <br> <br> <br> <br>//$--HrOpenCsvFile-------------------------------------------------------------- <br>//  Open the .CSV file and prepare to read lines from it. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrOpenCsvFile(void)          // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPRIVATE("HrOpenCsvFile()"); <br> <br>    // Open the file. <br> <br>    fpCsvFile = fopen(szFile, "r"); <br>    if (fpCsvFile == NULL) <br>    { <br>        EventLogMsg( <br>            FIMPORT_CANNOT_OPEN_IMPORT_FILE,  <br>            1, szFile,  <br>            1, _doserrno); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Reset the line number counter. <br> <br>    iCsvLine = 0; <br>    fCsvLineSaved = FALSE; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadCsvSettings---------------------------------------------------------- <br>//  Read the settings information from the .CSV file. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadCsvSettings(void)      // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    ULONG               iToken              = 0; <br>    ULONG               cToken              = 0; <br>    LPSTR *             rgpszToken          = NULL; <br>    LPSTR               pszKeyword          = NULL; <br>    LPSTR               pszValue            = NULL; <br>    FILECOMMAND         fcCommand           = 0; <br> <br>    DEBUGPRIVATE("HrReadCsvSettings()"); <br> <br>    // Read a line from the file. <br> <br>    hr = HrGetCsvLine(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Break the line up into tokens separated by commas. <br> <br>    hr = HrStrTokAll( <br>        szCsvLine,  <br>        ",",  <br>        &amp;cToken,  <br>        &amp;rgpszToken); <br>    if (FAILED(hr)) <br>    { <br>        EventLogMsg( <br>            FIMPORT_INTERNAL_ERROR,  <br>            1, "HrStrTokAll",  <br>            0); <br>        goto cleanup; <br>    } <br> <br>    // If the first token is not "COMMAND" then the file does  <br>    // not contain a settings line. <br> <br>    TRIM_WHITE_SPACE(rgpszToken[0]); <br>    if (cToken == 0 || stricmp(rgpszToken[0], "COMMAND")) <br>    { <br>        hr = HrUngetCsvLine(); <br>        goto cleanup; <br>    } <br> <br>    // Parse each token and store the resulting setting into  <br>    // the appropriate variable. <br> <br>    for (iToken = 1; iToken &lt; cToken; iToken++) <br>    { <br>        // Break each token into keyword and value, separated  <br>        // by an equals sign. <br> <br>        pszKeyword = rgpszToken[iToken]; <br>        pszValue = strchr(pszKeyword, '='); <br>        if (pszValue) <br>            *pszValue++ = 0; <br>        TRIM_WHITE_SPACE(pszKeyword); <br> <br>        // Try to match the keyword to a valid command. <br> <br>        hr = _HrFindArrayValue( <br>            pszKeyword,  <br>            rgpszFileCommandArray,  <br>            ARRAY_CNT(rgpszFileCommandArray),  <br>            &amp;fcCommand); <br> <br>        if (FAILED(hr)) <br>        { <br>            if (hr == EDK_E_NOT_FOUND) <br>            { <br>                EventLogMsg( <br>                    FIMPORT_INVALID_KEYWORD,  <br>                    4, szFile, SZ_BASE10(iCsvLine), szCsvLine, pszKeyword,  <br>                    0); <br>            } <br>            else if (hr == EDK_E_AMBIGUOUS) <br>            { <br>                EventLogMsg( <br>                    FIMPORT_AMBIGUOUS_KEYWORD,  <br>                    4, szFile, SZ_BASE10(iCsvLine), szCsvLine, pszKeyword,  <br>                    0); <br>            } <br>            else <br>            { <br>                EventLogMsg( <br>                    FIMPORT_INTERNAL_ERROR,  <br>                    1, "_HrFindArrayValue",  <br>                    0); <br>            } <br> <br>            goto cleanup; <br>        } <br> <br>        // Set the setting variable for this keyword. <br> <br>        switch (fcCommand) <br>        { <br>        case FILECOMMAND_APPEND: <br>            opOperation = OP_APPEND; <br>            break; <br> <br>        case FILECOMMAND_UPDATE: <br>            opOperation = OP_UPDATE; <br>            break; <br> <br>        case FILECOMMAND_REPLACE: <br>            opOperation = OP_REPLACE; <br>            break; <br> <br>        case FILECOMMAND_FOLDERPATH: <br>            STRNCPY(szFolderPath, pszValue); <br>            break; <br> <br>        case FILECOMMAND_CLASS: <br>            STRNCPY(szClass, pszValue); <br>            break; <br> <br>        case FILECOMMAND_SETREAD: <br>            fSetRead = TRUE; <br>            break; <br> <br>        case FILECOMMAND_NOSETREAD: <br>            fSetRead = FALSE; <br>            break; <br> <br>        case FILECOMMAND_EFD: <br>            fEfd = TRUE; <br>            break; <br> <br>        case FILECOMMAND_NOEFD: <br>            fEfd = FALSE; <br>            break; <br>         <br>        default: <br>            EventLogMsg( <br>                FIMPORT_INTERNAL_ERROR,  <br>                1, "switch (fcCommand)",  <br>                0); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } // end for <br> <br>cleanup: <br>    MAPIFREEBUFFER(rgpszToken); <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrGetCsvLine--------------------------------------------------------------- <br>//  Read a line from the .CSV file into szCsvLine.  Setting fCsvLineSaved  <br>//  == TRUE acts as an "unget", and causes the current contents of szCsvLine  <br>//  to be used the next time this routine is called. <br>// <br>//  HrGetCsvLine automatically skips empty lines. <br>// <br>//  Returns:    NOERROR             = success <br>//              EDK_E_END_OF_FILE   = end of file <br>//              E_FAIL              = error <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetCsvLine(void)           // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    int                 ch                  = 0; <br>    int                 cMatch              = 0; <br>    char *              pszResult           = NULL; <br>    int                 cchCsvLine          = 0; <br> <br>    DEBUGPRIVATE("HrGetCsvLine()"); <br> <br>    // Loop until we get a line we can use. <br> <br>    do <br>    { <br>        // If we have a line saved from last time then just use that one. <br> <br>        if (fCsvLineSaved) <br>            fCsvLineSaved = FALSE; <br> <br>        // Otherwise read another line from the file. <br> <br>        else <br>        { <br>            pszResult =  <br>                fgets(szCsvLine, sizeof(szCsvLine) - 1, fpCsvFile); <br>            if (pszResult == NULL) <br>            { <br>                if (ferror(fpCsvFile)) <br>                { <br>                    EventLogMsg( <br>                        FIMPORT_CANNOT_READ_IMPORT_FILE,  <br>                        1, szFile,  <br>                        1, _doserrno); <br>                    hr = HR_LOG(E_FAIL); <br>                } <br>                else <br>                { <br>                    hr = EDK_E_END_OF_FILE; <br>                } <br> <br>                goto cleanup; <br>            } <br> <br>            // Increment the line number. <br> <br>            iCsvLine++; <br> <br>            // Strip newline from end of line. <br> <br>            cchCsvLine = strlen(szCsvLine); <br>            if (cchCsvLine &amp;&amp; szCsvLine[cchCsvLine - 1] == '\n') <br>                szCsvLine[cchCsvLine - 1] = 0; <br>            else <br>            { <br>                EventLogMsg( <br>                    FIMPORT_IMPORT_LINE_TOO_LONG,  <br>                    3, szFile, SZ_BASE10(iCsvLine),  <br>                        szCsvLine,  <br>                    0); <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br> <br>        // Get the first non-whitespace character in the line so we  <br>        // can make sure it isn't a blank line. <br> <br>        cMatch = sscanf(szCsvLine, " %c", &amp;ch); <br>    } <br>    while (cMatch != 1); <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrUngetCsvLine------------------------------------------------------------- <br>//  Push the current line back on the input stream so that it will be  <br>//  returned by the next call to HrGetCsvLine. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrUngetCsvLine(void)         // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br> <br>    DEBUGPRIVATE("HrUngetCsvLine()"); <br> <br>    // Make sure that there isn't already another saved line and  <br>    // that we have read at least one line from the file. <br> <br>    if (fCsvLineSaved || iCsvLine == 0) <br>    { <br>        EventLogMsg( <br>            FIMPORT_INTERNAL_ERROR,  <br>            1, "HrUngetCsvLine",  <br>            0); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Set the flag to "unget" the current line. <br> <br>    fCsvLineSaved = TRUE; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCloseCsvFile------------------------------------------------------------- <br>//  Close the .CSV file. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCloseCsvFile(void)         // RETURNS: HRESULT <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    int                 nResult             = 0; <br> <br>    DEBUGPRIVATE("HrCloseCsvFile()"); <br> <br>    // Close the file. <br> <br>    nResult = fclose(fpCsvFile); <br> <br>    if (nResult) <br>    { <br>        EventLogMsg( <br>            FIMPORT_CANNOT_CLOSE_IMPORT_FILE,  <br>            1, szFile,  <br>            1, _doserrno); <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
