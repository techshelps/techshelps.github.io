<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INSTFORM.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1803"></a>INSTFORM.CPP</h2>
<pre><code>// --InstForm.cpp--------------------------------------------------------------- <br>// Command line utility to install or remove Exchange forms. <br>//   <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "exchcli.h" <br> <br>class CUserParams;// must be declared before "instform.chk" <br> <br>#include "iformmsg.h"// created from instform.mc by the message compiler <br>#include "instform.chk" <br> <br>// Define a warning to exit if user asks for help. <br>const HRESULT EXIT_WARNING = MAPI_W_ERRORS_RETURNED; <br> <br>LPTSTRlpszAppName = TEXT("InstForm"); <br> <br>//$--INTERNAL_ERROR------------------------------------------------------------- <br>//  Helper function for EventLogMsg <br>// ----------------------------------------------------------------------------- <br>static inline VOID INTERNAL_ERROR( <br>    IN LPCTSTR str, <br>    IN const HRESULT hr) <br>{ <br>    TCHAR   szErrorCode[16] = {0}; <br> <br>    EventLogMsg( <br>        INSTFORM_INTERNAL_ERROR, <br>        2, str, _itot( hr, szErrorCode, 16), <br>        0); <br>} <br> <br>//$--fFileExists()-------------------------------------------------------------- <br>// RETURNS: TRUE if the file exists and FALSE if not. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL fFileExists(  <br>    IN LPTSTR lpszFileSpec)   // File to validate exists. <br>{ <br>    struct _tfinddata_t FileInfo = {0}; <br>    long lhRet = _tfindfirst( lpszFileSpec, &amp;FileInfo); <br> <br>    if( lhRet == -1) <br>        return( FALSE); <br>    _findclose( lhRet); <br>     <br>    return( TRUE); <br>} <br> <br> <br>//$--CUserParams---------------------------------------------------------------- <br>// Container class for user's parameters and parsing the command line. <br>// ----------------------------------------------------------------------------- <br> <br>class CUserParams <br>{ <br>public: <br>    CUserParams(); <br>     <br>    HRESULT HrParseCommandLine( <br>        IN int      argc,       // number of arguments on command line <br>        IN char*    argv[]);    // array of command line arguments <br> <br>friend HRESULTHrSetupAndDoIt( CUserParams&amp;); <br> <br>    // These members will contain the arguments  <br>    // and values specified by the user. <br>    BOOL    m_fInstall;         // TRUE when installing a form. <br> <br>protected: <br>    BOOL    m_fRemove;          // TRUE when removing a form. <br>    HFRMREG m_hFrmReg;          // The registry to install form in. <br>    char*   m_pszCfgFile;       // The configuration file name for installing a form. <br>    char*   m_pszMsgClass;      // The message class for removing a form. <br>    char*   m_pszFolder;        // The path of the folder for installing in a folder registry. <br>    char*   m_pszProfile;       // The profile to logon to. <br>    char*   m_pszPassword;      // The password for logon. <br>    char*   m_pszMsgStore;      // The Display Name of the message store. <br> <br>protected: <br>    void PrintUsage( IN BOOL fHelp = FALSE); <br>    static char*    m_pszFlagArray[]; <br>    static char*    m_pszRegArray[]; <br> <br>    // These MUST correspond to the m_pszFlagArray[]. <br>    enum eFlagIndex <br>    { <br>        NON_FLAG = MAX_ULONG, <br>        HELP1 = 0, <br>        HELP2, <br>        INSTALL, <br>        REMOVE, <br>        VALUE_REQUIRED, // Place flags that require a value below. <br>        REGISTRY = VALUE_REQUIRED, <br>        FOLDER, <br>        PASSWORD, <br>        EPROFILE, <br>        MSGSTORE, <br>    }; <br>}; <br> <br>// ----------------------------------------------------------------------------- <br>// Arrays that belong to CUserParams for parsing command line. <br>// ----------------------------------------------------------------------------- <br> <br>char* CUserParams::m_pszFlagArray[] =  <br>{ <br>    "?", <br>    "HELP", <br>    "INSTALL", <br>    "REMOVE", <br>    // Place flags that require a value below. <br>    "REGISTRY", <br>    "FOLDER", <br>    "PASSWORD", <br>    "PROFILE", <br>    "MSGSTORE", <br>}; <br> <br>// This array is defined to correspond to MAPI defined constants listed in  <br>// the m_hFrmRegArray defined below, so the order is important. <br>char* CUserParams::m_pszRegArray[] =  <br>{ <br>    "LOCAL",      <br>    "PERSONAL",   <br>    "FOLDER",     <br>    "ENTERPRISE", <br>}; <br> <br>// This array is defined to correspond to the strings  <br>// in the array m_pszRegArray defined above. <br>static HFRMREG m_hFrmRegArray[] = <br>{ <br>    HFRMREG_LOCAL, <br>    HFRMREG_PERSONAL, <br>    HFRMREG_FOLDER, <br>    HFRMREG_ENTERPRISE, <br>}; <br> <br>// $--CUserParams::PrintUsage()------------------------------------------------- <br>// Print the usage message for the command line parameters. <br>// ----------------------------------------------------------------------------- <br> <br>void CUserParams::PrintUsage(  <br>    IN BOOL fHelp) // True if complete help is wanted. <br>{ <br>    printf(  <br>        "USAGE:  INSTFORM /INSTALL cfg_file [flags]\n" <br>        "   OR:  INSTFORM /REMOVE msg_class [flags]\n"); <br>         <br>    if( !fHelp) <br>        return; <br> <br>    printf(      <br>        "\n" <br>        "   /HELP or /? Show help information.\n" <br>        "\n" <br>        "   /INSTALL    To install the form specified in the cfg_file\n" <br>        "\n" <br>        "   /REMOVE     To remove the form specified by the msg_class.\n" <br>        "\n" <br>        "   /REGISTRY=  Flag to specify which registry to install form in.\n" <br>        "               FOLDER the /FOLDER option must be specified.\n" <br>        "               PERSONAL\n" <br>        "               LOCAL\n" <br>        "               ENTERPRISE\n" <br>        "\n" <br>        "   /FOLDER=    Specify the folder path of the registry to install in. Example:\n" <br>        "                   /FOLDER=\"top of information store\\inbox\"\n" <br>        "\n" <br>        "               When this parameter is specified the /REGISTRY=FOLDER is\n" <br>        "               assumed and need not be specified.  Any other /REGISTRY=\n" <br>        "               option is an error.\n" <br>        "\n" <br>        "   /PROFILE=   Specify the profile for logon.  Optional for local registry.\n" <br>        "\n" <br>        "   /PASSWORD=  Specify the password if needed.\n" <br>        "\n" <br>        "   /MSGSTORE=  Specify the display name of the message store that contains\n" <br>        "               the folder specified.  This is only valid with folders.  If\n" <br>        "               not specified the default message store will be used.\n" <br>        "\n" <br>        "   cfg_file    The name of the configuration file of the form to install.\n" <br>        "\n" <br>        "   msg_class   The message class of the form to be removed from the\n" <br>        "               forms registry.\n" <br>    ); <br>} <br> <br>// $--CUserParams::CUserParams()------------------------------------------------ <br>// CONSTRUCTOR to initialize the user parameter container. <br>// ----------------------------------------------------------------------------- <br> <br>CUserParams::CUserParams() <br>{ <br>    m_fInstall      = FALSE; <br>    m_fRemove       = FALSE; <br>    m_hFrmReg       = MAX_ULONG; <br>    m_pszMsgClass   = NULL; <br>    m_pszCfgFile    = NULL; <br>    m_pszFolder     = NULL; <br>    m_pszProfile    = NULL; <br>    m_pszPassword   = NULL; <br>    m_pszMsgStore   = NULL; <br>} <br> <br>// $--CUserParams::HrParseCommandLine()----------------------------------------- <br>// Parse the command line arguments and place their values in the appropriate  <br>// member variables. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CUserParams::HrParseCommandLine( <br>    IN int      argc,           // number of arguments on command line <br>    IN char*    argv[])         // array of command line arguments <br>{ <br>    HRESULT     hr              = NOERROR; <br>    int         iArg            = 0; <br>    int         cNonFlagArgs    = 0; <br>    eFlagIndex  nFlagIndex      = NON_FLAG; <br>    char*       pszValue        = NULL; <br>    char*       pszFirstArg     = NULL; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    DEBUGPRIVATE( "CUserParams::HrParseCommandLine()"); <br> <br>    // If there are no flags on the command line then just print a usage message. <br>    if( argc &lt; 2) <br>    { <br>        PrintUsage(); <br>        return( EXIT_WARNING); <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Do an initial check for /? or /HELP.  If found, don't do any other parsing. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    for (iArg = 1; iArg &lt; argc; iArg++) <br>    {   // Ignore return value while we look for help flags. <br>        hr = _HrExpandCommandLineArgument( argv[iArg], m_pszFlagArray,  <br>            ARRAY_CNT( m_pszFlagArray), (ULONG*) &amp;nFlagIndex, NULL, &amp;pszValue); <br> <br>        if( SUCCEEDED( hr) &amp;&amp; nFlagIndex == HELP1 || nFlagIndex == HELP2) <br>        { <br>            PrintUsage( TRUE); <br>            return( EXIT_WARNING); <br>        } <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Loop through and parse all the command line arguments. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    for( iArg = 1; iArg &lt; argc; iArg++) <br>    { <br>        hr = _HrExpandCommandLineArgument( argv[iArg], m_pszFlagArray, <br>            ARRAY_CNT( m_pszFlagArray), (ULONG*) &amp;nFlagIndex, NULL, &amp;pszValue); <br>        if( FAILED(hr)) <br>        { <br>            fprintf(stderr, "ERROR: unknown command line parameter: %s.\n", argv[ iArg]); <br>            goto cleanup; <br>        } <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        // Parse non-flag arguments. <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        if( nFlagIndex == NON_FLAG &amp;&amp; pszValue != NULL) <br>        { <br>            switch( cNonFlagArgs ++) <br>            { <br>                case 0:     // Either cfg_file or msg_class <br>                    pszFirstArg = pszValue; <br>                    break; <br> <br>                default:    // Too many arguments!!! <br>                    fprintf( stderr, "ERROR: too many arguments: %s\n", argv[iArg]); <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>            } <br>        } <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        else // Parse the flag arguments. <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        { <br>            if( nFlagIndex &lt; VALUE_REQUIRED) <br>            {                <br>                if( pszValue) <br>                {   // No value needed here. <br>                    fprintf( stderr, "ERROR: flag /%s does not take a value.\n", m_pszFlagArray[ nFlagIndex]); <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>            } <br>            else // nFlagIndex &gt;= VALUE_REQUIRED <br>            { <br>                if( !pszValue) <br>                {   // Make sure user supplied required values. <br>                    fprintf( stderr, "ERROR: flag /%s requires a value.\n", m_pszFlagArray[ nFlagIndex]); <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>            } <br> <br>            switch( nFlagIndex) <br>            { <br>                case INSTALL: <br>                    m_fInstall = TRUE; <br>                    break; <br> <br>                case REMOVE: <br>                    m_fRemove = TRUE; <br>                    break; <br> <br>                case REGISTRY: <br>                    // Look up the registry value entered by the user and convert  <br>                    // to a value that MAPI will understand. <br>                    hr = _HrFindArrayValue( pszValue, m_pszRegArray, ARRAY_CNT( m_pszRegArray), &amp;m_hFrmReg); <br>                    if (FAILED(hr)) <br>                    { <br>                        fprintf(stderr, "ERROR: invalid registry value: %s\n", pszValue); <br>                        goto cleanup; <br>                    } <br>                    m_hFrmReg = m_hFrmRegArray[ m_hFrmReg]; <br> <br>                    // If they specified the /FOLDER= flag then the only registry <br>                    // flag they can specify is FOLDER. <br>                    if( m_hFrmReg != HFRMREG_FOLDER &amp;&amp; m_pszFolder != NULL) <br>                    { <br>                        fprintf( stderr, "ERROR: When specifying \"/FOLDER=\" omit the \"/REGISTRY=\" flag.\n"); <br>                        hr = HR_LOG(E_FAIL); <br>                        goto cleanup; <br>                    } <br>                    break; <br> <br>                case FOLDER: <br>                    if( m_hFrmReg != HFRMREG_FOLDER &amp;&amp; m_hFrmReg != MAX_ULONG) <br>                    { <br>                        fprintf( stderr, "ERROR: When specifying \"/FOLDER=\" omit the \"/REGISTRY=\" flag.\n"); <br>                        hr = HR_LOG(E_FAIL); <br>                        goto cleanup; <br>                    } <br>                    m_hFrmReg = HFRMREG_FOLDER; <br>                    m_pszFolder = pszValue; <br>                    break; <br>                 <br>                case PASSWORD: <br>                    m_pszPassword = pszValue; <br>                    break; <br> <br>                case EPROFILE: <br>                    m_pszProfile = pszValue; <br>                    break; <br> <br>                case MSGSTORE: <br>                    m_pszMsgStore = pszValue; <br>                    break; <br> <br>                default: <br>                    // Unexpected value in m_pszFlagArray and the user specified it. <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>            } <br>        } <br>    }   // End For Loop <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Final parameter validation. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Validate that either INSTALL or REMOVE was specifed. <br>    if( m_fInstall) <br>    {   // They specified /INSTALL <br>        if( m_fRemove) <br>        { <br>            fprintf( stderr, "ERROR: Conflicting command line arguments.\n" <br>                             "       Both /INSTALL and /REMOVE can not be specified.\n"); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>        if( !pszFirstArg) <br>        { <br>            fprintf( stderr, "ERROR: please specify the cfg_file name.\n"); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>        if( !fFileExists( pszFirstArg)) <br>        { <br>            fprintf( stderr, "ERROR: can not find file %s\n", pszFirstArg); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        m_pszCfgFile = pszFirstArg; <br>    } <br>    else if( m_fRemove) <br>    {   // They specified /REMOVE <br>        if( !pszFirstArg) <br>        { <br>            fprintf( stderr, "ERROR: please specify the msg_class name.\n"); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>        m_pszMsgClass = pszFirstArg; <br>    } <br>    else <br>    { <br>        fprintf( stderr, "ERROR: please specify either /INSTALL or /REMOVE.\n"); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // It is an error to specify the folder registry but no folder name. <br>    if( m_hFrmReg == HFRMREG_FOLDER &amp;&amp; !m_pszFolder) <br>    {    <br>        fprintf( stderr, "ERROR: You must specify \"/FOLDER=\" with the \"/REGISTRY=FOLDER\" flag.\n"); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // It is an error to specify message store without specifiying the folder registry. <br>    if( m_pszMsgStore &amp;&amp; m_hFrmReg != HFRMREG_FOLDER) <br>    {    <br>        fprintf( stderr, "ERROR: \"/MSGSTORE=\" is only valid when \"/FOLDER=\" has been specified.\n"); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // The profile must be specified unless using the local registry. <br>    if( m_hFrmReg != HFRMREG_LOCAL &amp;&amp; !m_pszProfile) <br>    {    <br>        fprintf( stderr, "ERROR: You must specify the profile name.\n"); <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // If user did not specify the registry then use the default one. <br>    if( m_hFrmReg == MAX_ULONG) <br>        m_hFrmReg = HFRMREG_DEFAULT; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>//$--HrOpenMsgStoreFolderByName()----------------------------------------------- <br>// Returns pointer to open folder resource.  If MsgStore is NULL, default message <br>// store is assumed. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrOpenMsgStoreFolderByName( <br>INLPMAPISESSIONlpMAPISession,  // Active session handle <br>INLPTSTRlpszMsgStore,   // Name of message store, or NULL for default <br>INLPTSTRlpszFolder,     // Folder path name to open <br>OUTLPMAPIFOLDER*lppFolder)     // RETURN: open folder interface <br>{ <br>HRESULThr = NOERROR; <br>ULONGcbeid  = 0L; <br>LPENTRYIDlpeid = NULL; <br>LPMDBlpMDB = NULL; <br>LPMAPIFOLDERlpFolder = NULL; <br> <br>DEBUGPUBLIC( "HrOpenMsgStoreFolderByName()"); <br> <br>hr = CHK_HrOpenMsgStoreFolderByName( <br>lpMAPISession, lpszMsgStore, lpszFolder, <br>lppFolder); <br>if( FAILED( hr)) <br>RETURN( hr); <br> <br>// Get the entry ID of the specified or default message store. <br>if( lpszMsgStore) <br>    hr = HrMAPIFindStore( lpMAPISession, lpszMsgStore, &amp;cbeid, &amp;lpeid); <br>else <br>    hr = HrMAPIFindDefaultMsgStore( lpMAPISession, &amp;cbeid, &amp;lpeid); <br>if( FAILED( hr)) <br>goto cleanup; <br> <br>ASSERTERROR( cbeid != 0, "Entry ID count should not be zero.");  <br>ASSERTERROR( lpeid != NULL, "NULL lpeid pointer"); <br> <br>// Open the message store. <br>hr = lpMAPISession-&gt;OpenMsgStore( <br>0, cbeid, lpeid, NULL,  <br>MDB_WRITE | MAPI_DEFERRED_ERRORS, <br>&amp;lpMDB); <br>if( FAILED(hr)) <br>    goto cleanup; <br> <br>ASSERT_IUNKNOWN_PTR( lpMDB, "Invalid store pointer"); <br> <br>    hr = HrMAPIOpenFolderEx( lpMDB, TEXT('\\'), lpszFolder, &amp;lpFolder); <br>    if( FAILED(hr)) <br>    goto cleanup; <br> <br>*lppFolder = lpFolder; <br> <br>cleanup: <br>MAPIFREEBUFFER( lpeid); <br> <br>ULRELEASE( lpMDB); <br> <br>RETURN( hr); <br>} <br> <br>//$--HrOpenFormContainer----------------------------------------------------- <br>// Returns open form container interface.  NULLs may be passed for unnecessary <br>// string values.  For all but HFRMREG_LOCAL, a MAPI session handle is also <br>// returned.  The user assumes responsibility of logging off and releasing <br>// this session. <br>// <br>// There are two container types for forms.  The first involves logging <br>// on to a MAPI session to open the form container that the form will be  <br>// installed on.  The second is simpler and does not require logging on to a <br>// MAPI session, but only works for installing local forms.  Both techniques <br>// are demonstrated below. <br>//---------------------------------------------------------------------------- <br> <br>HRESULT <br>HrOpenFormContainer( <br>INHFRMREGhFrmReg,            // Desired form registry container <br>INLPTSTRlpszProfile,        // Session profile, if needed <br>INLPTSTRlpszPassword,       // Session password, if needed <br>INLPTSTRlpszMsgStore,       // Message store of folder, if needed <br>INLPTSTRlpszFolder,         // Folder name, if needed <br>OUTLPMAPISESSION*lppMAPISession,    // RETURN: active session <br>OUTLPMAPIFORMCONTAINER*lppFormContainer)  // RETURN: open folder container <br>{ <br>HRESULThr= NOERROR; <br>LPMAPIFOLDERlpFolder= NULL; <br>    LPMAPIFORMMGRlpFormMgr= NULL; <br>LPMAPISESSIONlpMAPISession= NULL; <br>LPMAPIFORMCONTAINERlpFormContainer= NULL; <br> <br>hr = CHK_HrOpenFormContainer( <br>hFrmReg, lpszProfile, lpszPassword, lpszMsgStore, lpszFolder, <br>lppMAPISession, lppFormContainer); <br>if( FAILED( hr)) <br>RETURN( hr); <br> <br>    // Initialize return values <br>    if( lppMAPISession) <br>        *lppMAPISession = NULL; <br> <br>    *lppFormContainer = NULL; <br> <br>    if( hFrmReg == HFRMREG_LOCAL) <br>    { <br>    hr = MAPIOpenLocalFormContainer( &amp;lpFormContainer); <br>        if( FAILED( hr)) <br>        { <br>            INTERNAL_ERROR( TEXT("MAPIOpenLocalFormContainer()"), hr); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        ASSERTERROR( lppMAPISession != NULL, "NULL lppMAPISession passed"); <br>    ASSERTERROR( lpszProfile != NULL, "NULL Profile name"); <br> <br>        hr = MAPILogonEx(  <br>                NULL, lpszProfile, lpszPassword,  <br>                MAPI_LOGON_UI | MAPI_NO_MAIL | MAPI_NEW_SESSION,  <br>                &amp;lpMAPISession); <br>        if( FAILED( hr)) <br>        {             <br>            INTERNAL_ERROR( TEXT("MAPILogonEx()"), hr); <br>            goto cleanup; <br>        } <br> <br>        if( hFrmReg == HFRMREG_FOLDER) <br>        { <br>        ASSERTERROR( lpszFolder != NULL, "NULL Folder name"); <br> <br>        hr = HrOpenMsgStoreFolderByName( lpMAPISession, <br>        lpszMsgStore, lpszFolder, &amp;lpFolder); <br>        if( hr == EDK_E_NOT_FOUND) <br>        { <br>                TCHAR    szErrorCode[16] = {0}; <br> <br>        EventLogMsg( INSTFORM_NOTFOUND_ERROR, <br>        1, _itot( hr, szErrorCode, 16), <br>        0); <br> <br>        goto cleanup; <br>        } <br>        if( FAILED( hr)) { <br>                INTERNAL_ERROR( TEXT("HrOpenMsgStoreFolderByName()"), hr); <br>        goto cleanup; <br>        } <br>        } <br> <br>        // Open form manager interface. <br>        hr = MAPIOpenFormMgr( lpMAPISession, &amp;lpFormMgr); <br>        if( FAILED( hr)) <br>        { <br>            INTERNAL_ERROR( TEXT("MAPIOpenFormMgr()"), hr); <br>            goto cleanup; <br>        } <br> <br>        // Open appropriate form container. <br>        hr = lpFormMgr-&gt;OpenFormContainer( hFrmReg, lpFolder, &amp;lpFormContainer); <br>        if( FAILED( hr)) <br>        { <br>            INTERNAL_ERROR( TEXT("IMAPIFormMgr::OpenFormContainer()"), hr); <br>            goto cleanup; <br>        } <br> <br>        // Success!  Set return interface pointers. <br>        if( lppMAPISession) <br>            *lppMAPISession = lpMAPISession; <br>    } <br> <br>*lppFormContainer = lpFormContainer; <br> <br>cleanup: <br>ULRELEASE( lpFolder); <br>ULRELEASE( lpFormMgr); <br> <br>if( FAILED( hr) &amp;&amp; lpMAPISession) <br>{ <br>lpMAPISession-&gt;Logoff( 0L, 0L, 0L); <br>ULRELEASE( lpMAPISession); <br>} <br> <br>RETURN( hr); <br>} <br> <br>//$--HrSetupAndDoIt()----------------------------------------------------------- <br>// Open form container interface, and install or remove. <br>// ----------------------------------------------------------------------------- <br> <br>static HRESULT HrSetupAndDoIt( <br>    IN CUserParams&amp; UserParams)     // Parsed parameters from the user. <br>{ <br>    HRESULThr = NOERROR; <br>LPMAPISESSIONlpMAPISession= NULL; <br>LPMAPIFORMCONTAINERlpFormContainer= NULL; <br> <br>    DEBUGPRIVATE( "HrSetupAndDoIt()"); <br> <br>    // Open appropriate form container interface. <br>    hr = HrOpenFormContainer( <br>UserParams.m_hFrmReg, <br>UserParams.m_pszProfile, UserParams.m_pszPassword, <br>UserParams.m_pszMsgStore, UserParams.m_pszFolder, <br>&amp;lpMAPISession, &amp;lpFormContainer); <br>if( FAILED( hr)) <br>goto cleanup; <br> <br>    if( UserParams.m_fInstall) <br>    { <br>ULONGulUIFlags = MAPI_DIALOG; <br> <br>// Shouldn't use MAPI_DIALOG flag if installing to local forms registry. <br>if( UserParams.m_hFrmReg == HFRMREG_LOCAL) <br>ulUIFlags = 0L; <br> <br>        hr = lpFormContainer-&gt;InstallForm( NULL, ulUIFlags, UserParams.m_pszCfgFile); <br>        if( FAILED( hr)) <br>        { <br>            if( hr == MAPI_E_USER_CANCEL) <br>{ <br>                EventLogMsg( INSTFORM_USER_CANCEL_ERROR, <br>                0, <br>                0); <br>            } <br>            else <br>            { <br>                LPMAPIERROR lpMAPIError = NULL; <br>                HRESULT     hrT = NOERROR; <br> <br>                hrT = lpFormContainer-&gt;GetLastError (hr, 0L, &amp;lpMAPIError); <br> <br>                if (SUCCEEDED(hrT) &amp;&amp; lpMAPIError) <br>                { <br>EventLogMsg( INSTFORM_EXTENDED_ERROR, <br>1, lpMAPIError-&gt;lpszError, <br>0); <br>                    MAPIFREEBUFFER (lpMAPIError); <br>                } <br> <br>                INTERNAL_ERROR( TEXT("IMAPIFormContainer::InstallForm()"), hr); <br> <br>                hr = HR_LOG( E_FAIL); <br>} <br>        } <br>    } <br>    else <br>    { <br>        hr = lpFormContainer-&gt;RemoveForm( UserParams.m_pszMsgClass); <br>        if( FAILED( hr) || hr == MAPI_W_PARTIAL_COMPLETION) <br>        { <br>            if( hr == MAPI_E_NOT_FOUND) <br>{ <br>                EventLogMsg( INSTFORM_FORM_NOT_FOUND_ERROR, <br>                1, UserParams.m_pszMsgClass, <br>                0); <br>            } <br>            else <br>{ <br>                LPMAPIERROR lpMAPIError = NULL; <br>                HRESULT     hrT = NOERROR; <br> <br>                hrT = lpFormContainer-&gt;GetLastError (hr, 0L, &amp;lpMAPIError); <br> <br>                if (SUCCEEDED(hrT) &amp;&amp; lpMAPIError) <br>                { <br>EventLogMsg( INSTFORM_EXTENDED_ERROR, <br>1, lpMAPIError-&gt;lpszError, <br>0); <br>                    MAPIFREEBUFFER (lpMAPIError); <br>                } <br> <br>                INTERNAL_ERROR( TEXT("IMAPIFormContainer::RemoveForm()"), hr); <br> <br>                hr = HR_LOG( E_FAIL); <br>} <br>        } <br>    } <br> <br>cleanup: <br>ULRELEASE( lpFormContainer); <br> <br>if( lpMAPISession) <br>{ <br>lpMAPISession-&gt;Logoff( 0L, 0L, 0L); <br>ULRELEASE( lpMAPISession); <br>} <br> <br>    RETURN( hr); <br>} <br> <br>//$--main()--------------------------------------------------------------------- <br>// See CUserParams::PrintUsage() for user parameters. <br>// ----------------------------------------------------------------------------- <br> <br>int main( int argc, char *argv[]) <br>{ <br>    HRESULThr = NOERROR; <br>BOOLfMAPIInitialized = FALSE; <br>BOOLfEventLogOpen = FALSE; <br> <br>    CUserParams UserParams; <br> <br>    DEBUGPUBLIC( "main()"); <br> <br>// Parse the user's parameters. <br>    hr = UserParams.HrParseCommandLine( argc, argv); <br>    if( hr == EXIT_WARNING || FAILED( hr)) <br>        goto cleanup; <br> <br>    // Initialize MAPI. <br>    hr = MAPIInitialize( NULL); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>     <br>    fMAPIInitialized = TRUE; <br> <br>    // Open an event logging handle for this application. <br>    hr = HrEventOpenLog( <br>        lpszAppName,// application name <br>        NULL,// executable name (computed) <br>        NULL,// event message file (computed) <br>        NULL,// parameter message file (this) <br>        NULL,// category message file (this) <br>        NULL);// event logging handle <br>    if( FAILED(hr)) <br>    { <br>        fprintf( stderr, "ERROR: unable to open event log.\n"); <br>        goto cleanup; <br>} <br> <br>fEventLogOpen = TRUE; <br> <br>    hr = HrSetupAndDoIt( UserParams); <br>    if( FAILED( hr)) <br>    { <br>        printf( "FAILURE! Could not %s form.\n", UserParams.m_fInstall ? "install" : "remove"); <br>        goto cleanup; <br>    } <br> <br>    printf( "Form %s successfully.\n", UserParams.m_fInstall ? "installed" : "removed"); <br> <br>cleanup: <br> <br>if( fEventLogOpen) <br>{ <br>    EDKEVENTCOUNT   sEventCount     = {0}; <br>        HRESULThrT= NOERROR; <br> <br>        hrT = HrEventGetCounts(&amp;sEventCount); <br>        if( SUCCEEDED( hrT))  <br>        { <br>            // Print the number of errors logged. <br>            if (sEventCount.cError == 1) <br>                fprintf(stderr, "ERROR: 1 error written to NT event log.\n"); <br>            else if (sEventCount.cError &gt; 1) <br>                fprintf(stderr, "ERROR: %d errors written to NT event log.\n",  <br>                    sEventCount.cError); <br> <br>            // Print the number of warnings logged. <br>            if (sEventCount.cWarning == 1) <br>                fprintf(stderr, "WARNING: 1 warning written to NT event log.\n"); <br>            else if (sEventCount.cWarning &gt; 1) <br>                fprintf(stderr, "WARNING: %d warnings written to NT event log.\n",  <br>                    sEventCount.cWarning); <br>        } <br>else <br>{ <br>            fprintf(stderr, "WARNING: unable to get number of errors logged.\n"); <br>        } <br> <br>(void)HrEventCloseLog(); <br>    } <br> <br>if( fMAPIInitialized) <br>MAPIUninitialize(); <br> <br>    return( _nEcFromHr(hr)); <br>} <br> <br>// ----------------------------------------------------------------------------- <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
