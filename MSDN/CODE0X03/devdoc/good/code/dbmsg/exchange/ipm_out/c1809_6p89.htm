<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVCLS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1809"></a>CONVCLS.CPP</h2>
<pre><code>// --convcls.cpp-------------------------------------------------------------- <br>// <br>// IPM to 822 conversion class source file. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "ipmconv.h" <br>#include "msgemit.h" <br>#include "convcls.h" <br>#include "tagnames.h" <br>#include "convcls.chk" <br> <br>//$--CIPMConvert::CIPMConvert------------------------------------------------ <br>// <br>// DESCRIPTION: CIPMConvert conversion class constructor <br>// <br>// INPUT:   none <br>// <br>// RETURNS: nothing <br>// <br>// --------------------------------------------------------------------------- <br>CIPMConvert::CIPMConvert() <br>{ <br>    DEBUGPRIVATE("CIPMConvert::CIPMConvert()\n"); <br> <br>    // Initialize data members <br>    m_lpwszMsgClass = NULL; <br>    m_lpStream = NULL; <br>    m_fTNEFEncode = FALSE; <br>    m_lpAB = NULL; <br>    m_lpEnvelope = NULL; <br>    m_lpContent = NULL; <br>    m_lpEnvProps = NULL; <br>    m_lpCntProps = NULL; <br>    m_MsgType = mtNone; <br>    m_lpAttach = NULL; <br>} <br> <br>//$--CIPMConvert::~CIPMConvert------------------------------------------------ <br>// <br>// DESCRIPTION: CIPMConvert conversion class destructor <br>// <br>// INPUT:   none <br>// <br>// RETURNS: nothing <br>// <br>// --------------------------------------------------------------------------- <br>CIPMConvert::~CIPMConvert() <br>{ <br>    DEBUGPRIVATE("CIPMConvert::~CIPMConvert()\n"); <br> <br>    // Free all MAPI buffers and release all MAPI objects <br>    Reset(); <br> <br>} <br> <br>//$--CIPMConvert::fCheckInit-------------------------------------------------- <br>// <br>// DESCRIPTION: Inline function to check to see if conversion class instance has <br>//              been initialized via HrInitialize(). <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     BOOL    --  TRUE if initialized, FALSE otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>inline BOOL CIPMConvert::fCheckInit()   // RETURNS: BOOL <br>{ <br>    return (m_lpwszMsgClass &amp;&amp; m_lpEnvelope &amp;&amp; m_lpStream &amp;&amp; m_lpAB); <br>}; <br> <br>// $--CIPMConvert::HrInitialize----------------------------------- <br>// <br>// DESCRIPTION: Initializes conversion class instance <br>// <br>// INPUT:   lpwszMsgClass   --  message class <br>//          lpAddrBook  --  address book pointer <br>//          lpEnvelope  --  message envelope pointer <br>//          fTNEFEncode --  TNEF encode attachments flag <br>//          lpStream    --  Stream to write output to <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      EDK_E_ALREADY_EXISTS if already in use <br>//                      E_NOTIMPL if not yet implemented <br>// <br>// ---------------------------------------------------------------- <br>HRESULT CIPMConvert::HrInitialize(    <br>    IN LPCWSTR lpwszMsgClass,           // message class <br>    IN BOOL fTNEFEncode,                // TNEF encode attachments flag <br>    IN LPADRBOOK lpAddrBook,            // address book pointer <br>    IN LPMESSAGE lpEnvelope,            // message envelope pointer <br>    IN LPSTREAM lpStream)               // stream to write output to <br>{ <br>    HRESULT hr      =   NOERROR;    // return code <br>    BOOL    fInUse  =   FALSE;      // TRUE if instance is in use <br> <br>    DEBUGPRIVATE("CIPMConvert::HrInitialize()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CIPMConvert_HrInitialize(lpwszMsgClass, fTNEFEncode,  <br>                                      lpAddrBook, lpEnvelope, <br>                                      lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // make sure that this instance isn't already in use <br>    fInUse = fCheckInit(); <br>     <br>    if ( fInUse ) <br>    { <br>        hr = HR_LOG(EDK_E_ALREADY_EXISTS); <br> <br>        goto cleanup; <br>    } <br>         <br>    // Set mesage class, envelope, TNEF, address book  <br>    // and stream data members <br>    m_lpwszMsgClass = lpwszMsgClass; <br>    m_fTNEFEncode = fTNEFEncode; <br>    m_lpAB = lpAddrBook; <br>    m_lpEnvelope = lpEnvelope; <br>    m_lpStream = lpStream;     <br> <br>    // Determine the report type of the message, if any <br>    hr = HrSetMsgType(lpwszMsgClass); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrSetMsgType------------------------------- <br>// <br>// DESCRIPTION: Sets a message's type. <br>// <br>// INPUT:   lpwszReportClass    --  report class <br>// <br>// RETURNS: HRESULT --  NOERROR if successful &amp; is a report. <br>//                      E_INVALIDARG if bad input <br>//                             <br>// ------------------------------------------------------------- <br>HRESULT CIPMConvert::HrSetMsgType(       // RETURNS: HRESULT <br>        IN LPCWSTR lpwszMsgClass)        // message class <br>{ <br>    HRESULT         hr                  =   NOERROR; <br>    LPWSTR          lpwClassCaps        =   NULL;       // upper-case version of class <br>     <br>    // Report types supported. <br>    const LPWSTR    lpwszNDRClass   =   L".NDR"; <br>    const LPWSTR    lpwszDRClass    =   L".DR"; <br>    const LPWSTR    lpwszNRNClass   =   L".IPNNRN"; <br>    const LPWSTR    lpwszRNClass    =   L".IPNRN"; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrSetMsgType()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_CIPMConvert_HrSetMsgType(lpwszMsgClass); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Convert the class passed in to upper case. <br>    lpwClassCaps = CharUpperW((LPWSTR) lpwszMsgClass); <br> <br>    if ( (lpwClassCaps == NULL) ||  <br>         IsBadStringPtrW(lpwClassCaps, INFINITE) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // See if this is an IPM message. <br>    if ( wcsstr(lpwClassCaps, IPMENVELOPECLASS) != NULL ) <br>    { <br>        m_MsgType = mtIPM;  // interpersonal message <br> <br>        goto cleanup; <br>    } <br> <br>    // Check to make sure that we have a report <br>    if ( wcsstr(lpwClassCaps, IPMREPORTCLASS) == NULL ) <br>    { <br>        // Not a report or an IPM! <br>        m_MsgType = mtNone; <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Have a report. <br>    // Determine report type based on message class <br>    if ( wcsstr(lpwClassCaps, lpwszNDRClass) != NULL ) <br>    { <br>        // non-delivery report <br>        m_MsgType = mtNDR; <br> <br>        goto cleanup; <br>    } <br> <br>    if ( wcsstr(lpwClassCaps, lpwszDRClass) != NULL ) <br>    { <br>        // delivery report <br>        m_MsgType = mtDR; <br> <br>        goto cleanup; <br>    } <br> <br>    if ( wcsstr(lpwClassCaps, lpwszNRNClass) != NULL ) <br>    { <br>        // non-read notification <br>        m_MsgType = mtNRN; <br> <br>        goto cleanup; <br>    } <br> <br>    if ( wcsstr(lpwClassCaps, lpwszRNClass) != NULL ) <br>    { <br>        // read notification <br>        m_MsgType = mtRN; <br> <br>        goto cleanup; <br>    } <br> <br>    // If we get to here, we have an unrecognized report. <br>    m_MsgType = mtNone; <br> <br>    hr = HR_LOG(E_FAIL); <br> <br>    goto cleanup; <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrConvert------------------------------------ <br>// <br>// DESCRIPTION: Converts a MAPI REPORT.IPM message to a "822-style" <br>//              stream output. <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_OUTOFMEMORY if memory problems <br>//                          E_FAIL if API problems <br>//                          E_NOTIMPL if conversion not supported <br>// <br>// ---------------------------------------------------------------- <br>HRESULT CIPMConvert::HrConvert()    // RETURNS: HRESULT <br>{ <br>    HRESULT hr              =   NOERROR; <br>    BOOL    fInitialized    =   FALSE;  // TRUE if conversion instance has been initialized <br> <br>    DEBUGPRIVATE("CIPMConvert::HrConvert()\n"); <br> <br>    // Check to make sure that we have been initialized <br>    fInitialized = fCheckInit(); <br> <br>    if ( !fInitialized ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Call the appropriate conversion, based on the message <br>    // class. <br>    if ( m_MsgType == mtIPM ) <br>    { <br>        // have an ENVELOPE.IPM.* message <br>        hr = HrIPMTo822Format(); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>    else if ( m_MsgType != mtNone ) <br>    { <br>        // have some kind of supported REPORT.IPM.* message <br>        hr = HrReportTo822Format(); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>    else <br>    { <br>        // we have something we don't support <br>        hr = HR_LOG(E_NOTIMPL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Append the TNEFed envelope content and attachments to the <br>    // stream if this is desired. <br>    if ( m_fTNEFEncode == TRUE ) <br>    { <br>        // want to TNEF encode everthing attached to the envelope. <br>        hr = HrContentToTnef(); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>    }   // end if TNEF encoding desired <br> <br>    // commit the changes to the output stream. <br>    hr = m_lpStream-&gt;Commit(STGC_DEFAULT); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    // Release and free MAPI objects used for conversion now.   <br>    // Don't keep them in memory any longer than necessary.   <br>    // (Also allows for re-use of thread.) <br>    Reset(); <br> <br>    RETURN(hr); <br>}     <br> <br>//$--CIPMConvert::HrIPMto822Format-------------------------------------------------------- <br>// <br>// DESCRIPTION: Converts a MAPI ENVELOPE.IPM message to a "822-style" stream output <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_OUTOFMEMORY if memory problems, <br>//                              E_FAIL if API function call failure, <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT CIPMConvert::HrIPMTo822Format()   //  RETURNS:    HRESULT <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("CIPMConvert::HrIPMTo822Format()\n"); <br> <br>    // Convert the message envelope. <br>    hr = HrConvertEnvelope(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Convert the message. <br>    hr = HrConvertContent(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Write out each attachment. <br>    hr = HrConvertAttachments(); <br>     <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br>     <br>    RETURN(hr); <br>} <br> <br>//$--CIPMConvert::HrConvertEnvelope-------------------------------------------------------- <br>// <br>// DESCRIPTION: Handles the MAPI IPM or notification envelope conversion. <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_OUTOFMEMORY if memory problems, <br>//                              E_FAIL if API function call failure, <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT CIPMConvert::HrConvertEnvelope()   //  RETURNS:    HRESULT <br>{ <br>    HRESULT     hr              =   NOERROR;        // return code <br>    ULONG       ulNumRecips     =   0;              // number of recipients <br>    ULONG       ulCount         =   0;              // loop counter <br>    LPSRowSet   lpRecipRows     =   NULL;           // envelope's recipient table rows pointer <br>    ULONG       iProp           =   0;              // property index <br> <br>    // indices into the envelope property tag array <br>    const UINT  iClass       =    0;  // index of message class value     <br>    const UINT  iFromAddr    =    1;  // index of sender address <br>    const UINT  iXID         =    2;  // index of X-message identifier <br>    const UINT  iTrace       =    3;  // index of external trace information <br>    const UINT  iIntTrace    =    4;  // index of internal trace information <br> <br>    const ULONG nEnvProps    =    5;  // number of envelope properties to retrieve <br> <br>    // property values needed for the envelope <br>    SizedSPropTagArray(nEnvProps, sPropTagArray) = <br>    { <br>        nEnvProps,  // number of properties <br>        { <br>            PR_MESSAGE_CLASS,       // envelope message class, index iClass <br>            PR_ORIGINATOR_ADDR,     // envelope sender's email address, index iFromAddr <br>            PR_MESSAGE_SUBMISSION_ID,// content's X-Message-ID <br>            PR_TRACE_INFO,          // external trace information <br>PR_INTERNAL_TRACE_INFO, // internal trace information <br>        } <br>    }; <br> <br>    // indices into the recipient addresses property values array <br>    const UINT  iRecipient  =   0;  // PR_EMAIL_ADDRESS <br>    const UINT  iType       =   1;   <br> <br>    const ULONG nRecipProps =   2;  // number of recipient properties <br> <br>    // property columns needed from the envelope's recipient table <br>    SizedSPropTagArray(nRecipProps, sRecipProps) = <br>    { <br>        nRecipProps,  // number of columns (properties) <br>        { <br>            PR_EMAIL_ADDRESS,       // recipient Email address <br>            PR_RECIPIENT_TYPE       // recipient address type <br>        } <br>    }; <br> <br>    DEBUGPRIVATE("HrConvertEnvelope()\n"); <br> <br>    // Retrieve all of the properties which we need for the <br>    // envelope now (currently, there are two.) <br>    hr = HrRetrieveProps(m_lpEnvelope,  <br>                         (LPSPropTagArray) &amp;sPropTagArray, <br>                         &amp;m_lpEnvProps); <br> <br>    // It's O.K. if we cannot retrieve the trace information property. <br>    if ( hr == EDK_E_NOT_FOUND ) <br>    { <br>        for ( iProp = 0; iProp &lt; nEnvProps; iProp++ ) <br>        { <br>            if ( PROP_TYPE(m_lpEnvProps[iProp].ulPropTag) == PT_ERROR ) <br>            { <br>                if ( iProp == iTrace ) <br>                { <br>                    // Not finding external trace information is not fatal. <br>                    hr = HR_LOG(NOERROR); <br>                } <br> <br>                else if ( iProp == iIntTrace ) <br>                { <br>                    // Not finding internal trace information is not fatal. <br>                    hr = HR_LOG(NOERROR); <br>                } <br> <br>                else <br>                { <br>                    // some other, unexpected error. <br>                    hr = HR_LOG(E_FAIL); <br> <br>                    goto cleanup; <br>                } <br> <br>            }   // end if found a property problem <br>        }   // end for each property tag <br>    }   // end if one or more properties not found <br> <br>    // check for other failures <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the name of the TNEF data file, if any. <br>    // (Note: If we are doing TNEF encoding, the name of the attached <br>    // TNEF data is always MAPIMAIL.DAT.) <br>    hr = HrEmitTagDataLine( <br>        lpszTagTnefAttach,      // tag <br>        (LPTSTR) (m_fTNEFEncode ? lpszTagTnefHdr : lpszNullData),  // data <br>        m_lpStream);            // stream pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // build and emit the "MAIL FROM" line.   <br>    // from the sender's address string. <br>    hr = HrEmitTagDataLine( <br>                lpszTagMailFrom,        // tag <br>                m_lpEnvProps[iFromAddr].Value.LPSZ,  // sender's Email address <br>                m_lpStream);              // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build and emit the "RCPT TO" line for each recipient. <br>    // First, Retrieve the envelope's recipient table rows. <br>    hr = HrGetRecipientList( <br>                m_lpEnvelope,       // MAPI message envelope pointer <br>                (LPSPropTagArray) &amp;sRecipProps, // array of property columns to retrieve <br>                &amp;lpRecipRows);      // pointer to recipient array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Find and print out each MAPI_TO recipient <br>    ulNumRecips = 0;    // initialize number of "TO" recipients. <br>    for ( ulCount = 0; ulCount &lt; lpRecipRows-&gt;cRows; ulCount++ ) <br>    { <br>        if ( lpRecipRows-&gt;aRow[ulCount].lpProps[iType].Value.ul == <br>             MAPI_TO ) <br>        { <br>            // found a "RCPT TO" recipient <br>            ulNumRecips++;  // increment count <br> <br>            hr = HrEmitTagDataLine( <br>                lpszTagRcptTo,      // tag <br>                lpRecipRows-&gt;aRow[ulCount].lpProps[iRecipient].Value.LPSZ,  // data <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if found a to recipient <br>    }   // end for MAPI_TO recipients <br> <br>    // There had better be at least one "RCPT TO" recipient! <br>    if ( ulNumRecips == 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Emit the "DATA:" marker <br>    hr = m_lpStream-&gt;Write( <br>                lpszTagData,        // data <br>                lstrlen(lpszTagData) * sizeof(TCHAR), // length (no terminator) <br>                NULL); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // We are done. <br> <br>cleanup: <br> <br>    // Free structures <br>    FREEPROWS(lpRecipRows); <br>     <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrConvertContent-------------------------------------------------------- <br>// <br>// DESCRIPTION: Handles the MAPI IPM envelope content (original mesage) conversion. <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_OUTOFMEMORY if memory problems, <br>//                              E_FAIL if API function call failure, <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT CIPMConvert::HrConvertContent()   //  RETURNS:    HRESULT <br>{ <br>    HRESULT         hr              =   NOERROR;        // return code <br>    LPTSTR          lpTempString    =   NULL;   // data string <br>    ULONG           ulCount         =   0;      // temporary count variable <br>    ULONG           ulNumRecips     =   0;      // number of recipients <br>    LPSRowSet       lpRecipRows     =   NULL;   // content's recipient table rows pointer <br>    LPTRACEINFO     lpTraceInfo     =   NULL;   // external trace information <br>    LPTRACEENTRY    lpTraceEntry    =   NULL;   // external trace entry <br>    PINTTRACEINFO   lpIntTraceInfo  =   NULL;   // internal trace information <br>    PINTTRACEENTRY  lpIntTraceEntry =   NULL;   // internal trace entry <br>    ULONG           cbBodyText      =   0;      // # bytes in body text <br>    LPSTREAM        lpTextBody      =   NULL;   // ANSI text body stream <br>    BOOL            fBody           =   TRUE;   // FALSE if no body text <br>    ULARGE_INTEGER  scbStream       =   {0};    // # bytes to copy <br>    LARGE_INTEGER   sOffsetZero     =   {0};    // zero offset <br>    ULONG           iProp           =   0;      // index into property value array <br>    BOOL            fPriority       =   TRUE;   // FALSE if message has no priority <br> <br>    // temporary file name buffer <br>    TCHAR           szFileName[MAX_PATH + 1]    =   TEXT(".\\"); <br> <br>    // temporary string buffer <br>    TCHAR           szTempBuf[ulMaxOutStringLen + 1]   =   TEXT(""); <br> <br>    // temporary file name prefix <br>    const LPTSTR    szPrefix    =   TEXT("CNV"); <br> <br>    // indices into content properties <br>    const UINT  iClass       =    0;  // index of message class value     <br>    const UINT  iFromAddr    =    1;  // index of sender address <br>    const UINT  iXID         =    2;  // index of X-message identifier <br>    const UINT  iSentTime    =    3;  // index of sent time value <br>    const UINT  iImportance  =    4;  // index of importance value <br>    const UINT  iPriority    =    5;  // index of priority value <br>    const UINT  iSubject     =    6;  // index of the subject value <br> <br>    const ULONG nCntProps    =    7;  // # of message content properties <br> <br>    // property values needed for the message content <br>    SizedSPropTagArray(nCntProps, sPropTagArray) = <br>    { <br>        nCntProps,  // number of properties <br>        { <br>            PR_MESSAGE_CLASS,       // content's message class, index iClass <br>            PR_SENDER_EMAIL_ADDRESS,// content's sender's email address, index iFromAddr <br>            PR_SEARCH_KEY,          // dummy--acutally use PR_MESSAGE_SUBMISSION_ID on from <br>                                    // the envelope <br>            PR_CLIENT_SUBMIT_TIME,  // content's sent time, index iSentTime <br>            PR_IMPORTANCE,          // content's importance value, index iImportance <br>            PR_PRIORITY,            // content's priority value, index iPriority <br>            PR_SUBJECT              // content's subject, index iSubject <br>        } <br>    }; <br> <br>    // indices needed from envelope properties array <br>    const UINT  iTrace       =    3;  // index of external trace information <br>    const UINT  iIntTrace    =    4;  // index of internal trace information <br> <br>    // indices into the recipient addresses property values array <br>    const UINT  iRecipient  =   0;  // PR_EMAIL_ADDRESS <br>    const UINT  iType       =   1;  // PR_RECIPIENT_TYPE <br> <br>    const ULONG nRecipProps =   2;  // # of recipient properties <br> <br>    // property columns needed from the content's recipient table <br>    SizedSPropTagArray(nRecipProps, sRecipProps) = <br>    { <br>        nRecipProps,  // number of columns (properties) <br>        { <br>            PR_EMAIL_ADDRESS,       // recipient Email address <br>            PR_RECIPIENT_TYPE       // recipient address type <br>        } <br>    }; <br> <br>    // "Spread" between importance values and their corresponding  <br>    // priority values <br>    const ULONG nPriorityImportanceSpread   =   1; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrConvertContent()\n"); <br> <br>    // Open the envelope's content <br>    hr = HrOpenContent(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Retrieve and store the content properties needed. <br>    hr = HrRetrieveProps(m_lpContent, <br>                         (LPSPropTagArray) &amp;sPropTagArray, <br>                         &amp;m_lpCntProps); <br> <br>    // The PR_PRIORITY property may not be available for Schedule+ <br>    // "ENVELOPE.IPM.Schedule.Meeting.Request" messages. <br>    if ( hr == EDK_E_NOT_FOUND ) <br>    { <br>        for ( iProp == 0; iProp &lt; sPropTagArray.cValues; iProp++ ) <br>        { <br>            if ( PROP_TYPE(m_lpCntProps[iProp].ulPropTag) == PT_ERROR ) <br>            { <br>                if ( iProp == iPriority )   // no PR_PRIORITY property <br>                { <br>                    // This isn't an error for some types of IPM <br>                    // messages.  Merely compute the priority from <br>                    // the importance. <br>                    fPriority = FALSE;  // message has no priority <br> <br>                    hr = HR_LOG(NOERROR); <br>                } <br> <br>                else    // some other error <br>                { <br>                    hr = HR_LOG(E_FAIL); <br> <br>                    goto cleanup; <br>                } <br>            }   // end if found bad property tag <br>        }   // end for <br>    }   // end if property not found <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // general error case <br>        goto cleanup; <br>    } <br> <br>    // Print out the "X-Message-Class:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>                    lpszTagMsgClass,  <br>                    m_lpCntProps[iClass].Value.LPSZ, <br>                    m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build the date and time string <br>    hr = HrCreateDateTimeString( <br>                  &amp;(m_lpCntProps[iSentTime].Value.ft),  // PR_CLIENT_SUBMIT_TIME property value <br>                  &amp;lpTempString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Date:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>                    lpszTagDate,  <br>                    lpTempString,  <br>                    m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    // Print out the "X-Message-ID:" tag and data line to the stream <br>    // The X message ID is already null-terminated. <br>    hr = HrEmitTagDataLine( <br>                lpszTagMsgID,  <br>                (LPTSTR) m_lpEnvProps[iXID].Value.bin.lpb,  // really a null-terminated string <br>                m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build the trace information string, if any. <br>    if ( PROP_TYPE(m_lpEnvProps[iTrace].ulPropTag) != PT_ERROR ) <br>    { <br>        // have valid trace information <br>        lpTraceInfo = (LPTRACEINFO) (m_lpEnvProps[iTrace].Value.bin.lpb); <br> <br>        // Print out trace information data <br>        // Note:  It's O.K. for there to be no trace information <br>        // on NDR's just created by the gateway. <br>        for ( ulCount = 0; ulCount &lt; lpTraceInfo-&gt;cEntries; ulCount++ ) <br>        { <br>            // retrieve trace entry. <br>            lpTraceEntry = &amp;(lpTraceInfo-&gt;rgtraceentry[ulCount]); <br> <br>            // Create "External-Received-By" string <br>            hr = HrCreateExternalTraceString( <br>                lpTraceEntry-&gt;lAction,          // trace action <br>                lpTraceEntry-&gt;rgchCountryName,  // country name <br>                lpTraceEntry-&gt;rgchADMDName,     // ADMD name <br>                lpTraceEntry-&gt;rgchPRMDId,       // PRMD identifier <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "External-Received-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalRcvdBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "External-Received-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpTraceEntry-&gt;ftArrivalTime), // trace arrival time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out External-Received-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalRcvdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Create "External-Attempted-By" string <br>            hr = HrCreateExternalTraceString( <br>                lpTraceEntry-&gt;lAction,              // trace action <br>                lpTraceEntry-&gt;rgchAttCountryName,   // country name <br>                lpTraceEntry-&gt;rgchAttADMDName,      // ADMD name <br>                lpTraceEntry-&gt;rgchAttPRMDId,        // PRMD identifier <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "External-Attempted-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalAttmBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "External-Deferred-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpTraceEntry-&gt;ftDeferredTime), // trace deferal time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out External-Deferred-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalDefdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>        }   // end for trace entries <br>    }   // end if any trace information <br> <br>    // Build the internal trace information string, if any. <br>    if ( PROP_TYPE(m_lpEnvProps[iIntTrace].ulPropTag) != PT_ERROR ) <br>    { <br>        // have valid trace information <br>        lpIntTraceInfo = (PINTTRACEINFO) (m_lpEnvProps[iIntTrace].Value.bin.lpb); <br> <br>        // Print out trace information data <br>        // Note:  It's O.K. for there to be no trace information <br>        // on NDR's just created by the gateway. <br>        for ( ulCount = 0; ulCount &lt; lpIntTraceInfo-&gt;cEntries; ulCount++ ) <br>        { <br>            // retrieve trace entry. <br>            lpIntTraceEntry = &amp;(lpIntTraceInfo-&gt;rgIntTraceEntry[ulCount]); <br> <br>            // Create "Internal-Received-By" string <br>            hr = HrCreateInternalTraceString( <br>                lpIntTraceEntry-&gt;lAction,          // trace action <br>                lpIntTraceEntry-&gt;rgchCountryName,  // country name <br>                lpIntTraceEntry-&gt;rgchADMDName,     // ADMD name <br>                lpIntTraceEntry-&gt;rgchPRMDId,       // PRMD identifier <br>                lpIntTraceEntry-&gt;rgchMTAName,      // MTA name </code></pre>
<p>
</p>
<pre><code>&amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "Internal-Received-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalRcvdBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "Internal-Received-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpIntTraceEntry-&gt;ftArrivalTime), // trace arrival time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out Internal-Received-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalRcvdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Create "Internal-Attempted-By" string <br>            hr = HrCreateInternalTraceString( <br>                lpIntTraceEntry-&gt;lAction,              // trace action <br>                lpIntTraceEntry-&gt;rgchAttCountryName,   // country name <br>                lpIntTraceEntry-&gt;rgchAttADMDName,      // ADMD name <br>                lpIntTraceEntry-&gt;rgchAttPRMDId,        // PRMD identifier <br>                lpIntTraceEntry-&gt;rgchMTAName,      // MTA name <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "Internal-Attempted-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalAttmBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "Internal-Deferred-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpIntTraceEntry-&gt;ftDeferredTime), // trace deferal time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out Internal-Deferred-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalDefdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>        }   // end for trace entries <br>    }   // end if any trace information <br> <br>    // Print out the "From:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>        lpszTagFrom,     // tag <br>        m_lpCntProps[iFromAddr].Value.LPSZ,    // PR_SENDER_EMAIL_ADDRESS property value <br>        m_lpStream);                // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Get the recipients from the recipient table's rows. <br>    hr = HrGetRecipientList( <br>                m_lpContent,        // message content pointer <br>                (LPSPropTagArray) &amp;sRecipProps, // columns/properties desired <br>                &amp;lpRecipRows);      // pointer to recipient table row pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Find and print out the MAPI_TO recipients. <br>    ulNumRecips = 0;    // initialize count of to recipients <br>    for ( ulCount = 0; ulCount &lt; lpRecipRows-&gt;cRows; ulCount++ ) <br>    { <br>        if ( lpRecipRows-&gt;aRow[ulCount].lpProps[iType].Value.ul ==  <br>             MAPI_TO ) <br>        { <br>            // found a "TO" recipient <br>            ulNumRecips++;  // increment count <br> <br>            // Print out "TO" tag and data line <br>            hr = HrEmitTagDataLine( <br>                lpszTagTo,          // tag <br>                lpRecipRows-&gt;aRow[ulCount].lpProps[iRecipient].Value.LPSZ, // data <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if found a to recipient <br>    }   // end for <br> <br>    // It is O.K. for an IPM message content to have no "To" recipients. <br>    // (The envelope, however, must have "RCPT TO" recipients <br> <br>    // Find and print out the MAPI_CC recipients. <br>    for ( ulCount = 0; ulCount &lt; lpRecipRows-&gt;cRows; ulCount++ ) <br>    { <br>        if ( lpRecipRows-&gt;aRow[ulCount].lpProps[iType].Value.ul ==  <br>             MAPI_CC ) <br>        { <br>            // found a "CC" recipient <br>            // Print out "CC" tag and data line <br>            hr = HrEmitTagDataLine( <br>                lpszTagCC,          // tag <br>                lpRecipRows-&gt;aRow[ulCount].lpProps[iRecipient].Value.LPSZ, // data <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if found a cc recipient <br>    }   // end for <br> <br>    // find and print out BCC recipients <br>    for ( ulCount = 0; ulCount &lt; lpRecipRows-&gt;cRows; ulCount++ ) <br>    { <br>        if ( lpRecipRows-&gt;aRow[ulCount].lpProps[iType].Value.ul ==  <br>             MAPI_BCC ) <br>        { <br>            // found a "BCC" recipient <br>            // Print out "BCC" tag and data line <br>            hr = HrEmitTagDataLine( <br>                lpszTagBCC,          // tag <br>                lpRecipRows-&gt;aRow[ulCount].lpProps[iRecipient].Value.LPSZ, // data <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br>        }   // end if found a bcc recipient <br>    }   // end for <br> <br>    // Print out a blank line <br>    hr = m_lpStream-&gt;Write( <br>            lpszNewLine,        // data <br>            lstrlen(lpszNewLine) * sizeof(TCHAR),   // length (no terminator) <br>            NULL); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Subject:" tag and data line to the stream <br>    hr = HrEmitTagDataLine( <br>            lpszTagSubject, <br>            m_lpCntProps[iSubject].Value.LPSZ,  // PR_SUBJECT property value <br>            m_lpStream);                    // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build priority string. <br>    // First, check to see if a priority was assigned. <br>    if ( fPriority == FALSE ) <br>    { <br>        // Set the priority based on the message's importance. <br>        m_lpCntProps[iPriority].Value.ul = <br>            m_lpCntProps[iImportance].Value.ul - nPriorityImportanceSpread; <br> <br>    }   // end if no priority <br> <br>    hr = HrCreatePriorityString( <br>                m_lpCntProps[iPriority].Value.ul,  // PR_PRIORITY property value <br>                &amp;lpTempString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Priority:" tag and data line to the stream <br>    hr = HrEmitTagDataLine( <br>            lpszTagPriority,  <br>            lpTempString,  <br>            m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    // Build the importance string <br>    hr = HrCreateImportanceString( <br>                m_lpCntProps[iImportance].Value.ul,    // PR_IMPORTANCE property value <br>                &amp;lpTempString);                             // buffer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Importance:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>                lpszTagImportance,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br>    <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    // Write the ANSI body text header and data information <br>    // to the stream. <br>    // This means that we must first convert the compressed <br>    // rich text format body to ANSI. <br> <br>    // Create a temporary, buffered stream to hold the ANSI text. <br>    hr = OpenStreamOnFile( <br>        MAPIAllocateBuffer,     // allocation routine <br>        MAPIFreeBuffer,         // deallocation routine <br>        STGM_READWRITE | STGM_CREATE | SOF_UNIQUEFILENAME |  <br>        STGM_DELETEONRELEASE | STGM_SHARE_EXCLUSIVE,   // interface flags <br>        szFileName,             // temporary file name <br>        szPrefix,               // file prefix <br>        &amp;lpTextBody);           // stream pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!FBadUnknown(lpTextBody), "Bad lpTextBody"); <br> <br>    // Convert the RTF compressed stream data to ANSI text <br>    // data. <br>    hr = HrRTFCompressedToText( <br>                    m_lpContent,        // MAPI message pointer <br>                    lpTextBody,         // stream to copy ANSI text to <br>0,// use current code page <br>                    &amp;cbBodyText);       // # bytes copied to stream <br> <br>    // It is O.K. for there to be no RTF body text   <br>// (Note:  The MAPI error code MAPI_E_NOT_FOUND is returned in this <br>// case.) <br>    if ( hr == MAPI_E_NOT_FOUND ) <br>    { <br>        // no message body <br>        fBody = FALSE; <br> <br>        // not an error <br>        hr = HR_LOG(NOERROR); <br>    } <br> <br>    // Test for other errors <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!FBadUnknown(lpTextBody), "Bad lpTextBody."); <br> <br>    // Format the number of bytes in the message body data. <br>    wsprintf( <br>            szTempBuf,      // buffer <br>            TEXT("%ld"),    // format string <br>            cbBodyText);    // data length (in bytes) <br> <br>    // Emit the body text "----beginbody" tag and data. <br>    hr = HrEmitTagDataLine( <br>            lpszTagBodyHdr,     // tag <br>            szTempBuf,          // data <br>            m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if ( fBody == TRUE )    // There is body text <br>    { <br>        // Go back to the begging of the ANSI body text <br>        // source stream. <br>        hr = lpTextBody-&gt;Seek( <br>                    sOffsetZero,        // 0 offset <br>                    STREAM_SEEK_SET,    // from beginning <br>                    NULL);              // don't care <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Copy all the ANSI body text to the output stream <br>        scbStream.LowPart = cbBodyText;  // # bytes to copy <br>        hr = lpTextBody-&gt;CopyTo( <br>                    m_lpStream, // output stream pointer <br>                    scbStream,  // # bytes to copy <br>                    NULL,       // don't care <br>                    NULL);      // don't care <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>    }   // end if body <br> <br>    // Emit the body text footer. <br>    hr = m_lpStream-&gt;Write( <br>            lpszTagBodyEnd,         // data <br>            lstrlen(lpszTagBodyEnd) * sizeof(TCHAR), // data length (no terminator) <br>            NULL); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // We are done. <br> <br>cleanup: <br> <br>    // Release MAPI and OLE objects <br>    ULRELEASE(lpTextBody);      // Deletes temporary file as a side-effect <br> <br>    // Free buffers <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    FREEPROWS(lpRecipRows); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrConvertAttachments-------------------------------------------------------- <br>// <br>// DESCRIPTION: Handles the MAPI IPM original message attachments conversion. <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_OUTOFMEMORY if memory problems, <br>//                              E_FAIL if API function call failure, <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT CIPMConvert::HrConvertAttachments()   //  RETURNS:    HRESULT <br>{ <br>    HRESULT         hr              =   NOERROR; <br>    LPMAPITABLE     lpTable         =   NULL;   // attachments table pointer <br>    LPSRowSet       lpRows          =   NULL;   // table rows <br>    ULONG           iLoopCounter    =   0;      // loop counter index <br>    LPATTACH        lpAttachment    =   NULL;   // message attachment pointer <br>    ULONG           nProps          =   0;      // # of properties <br>    LPSPropValue    lpPropVals      =   NULL;   // property value array pointer <br>    LPTSTR          lpFileName      =   NULL;   // file name pointer <br>    ULONG           cbAttachSize    =   0;      // # bytes in attachment <br>    PVIRTUALSTREAMONPROPERTYlpStreamAtData  =   NULL;   // buffered attachment data stream <br>STATSTGsStatStg={0};// stream statistics <br> <br>    // temporary string buffer <br>    TCHAR           szTempBuffer[ulMaxOutStringLen + 1] =   TEXT(""); <br>    // Attachment header buffer <br>    TCHAR           szAttachHdr[ulMaxOutStringLen + 1]  =   TEXT(""); <br> <br>    // property tag array for attachment number <br>    SizedSPropTagArray(1, sPropAttachNum)   =    <br>    { <br>        1,  // one property <br>        { <br>            PR_ATTACH_NUM   // property tag <br>        } <br>    }; <br> <br>    // indices into the property value array <br>    const UINT  iAttachMethod   =   0; <br>    const UINT  iFileName       =   1; <br> <br>    const ULONG nAttachProps    =   2;  // # of attachment properties <br> <br>    // properties to retrieve per attachment <br>    SizedSPropTagArray(nAttachProps, sAttachPropTags) =   <br>    { <br>        nAttachProps,      // number of properties to retrieve <br>        { <br>            PR_ATTACH_METHOD,       // attachment "type" <br>            PR_ATTACH_FILENAME      // attachment 8.3 file name <br>        } <br>    }; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrConvertAttachments()\n"); <br> <br>    // Handle the attachment for the message contents. <br>    // First open the attachments table. <br>    hr = m_lpContent-&gt;GetAttachmentTable(MAPI_DEFERRED_ERRORS, &amp;lpTable); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(lpTable, "Bad lpTable"); <br> <br>    // Retrieve the desired rows. <br>    // (HrQueryAllRows does a SetColumns for us) <br>    hr = HrQueryAllRows(lpTable,        // MAPI table pointer <br>                        (LPSPropTagArray) &amp;sPropAttachNum,  // columns to retrieve <br>                        NULL,           // restriction pointer <br>                        NULL,           // order set pointer <br>                        0,              // max rows, defaults to all     <br>                        &amp;lpRows);       // pointer to row array pointer <br> <br>    if ( FAILED(hr) || (hr == MAPI_W_POSITION_CHANGED) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup;  <br> <br>    } <br> <br>    ASSERT_READ_PTR(lpRows, sizeof(SRowSet), "Bad lpRows"); <br> <br>    // handle each attachment <br>    for ( iLoopCounter = 0; iLoopCounter &lt; lpRows-&gt;cRows; iLoopCounter++ ) <br>    { <br>        // Release objects from previous iteration <br>        ULRELEASE(lpAttachment); <br>        ULRELEASE(lpStreamAtData); <br> <br>        // Free MAPI memory from previous iteration. <br>        MAPIFREEBUFFER(lpPropVals); <br> <br>        // Open the attachment <br>        hr = m_lpContent-&gt;OpenAttach( <br>            lpRows-&gt;aRow[iLoopCounter].lpProps[0].Value.ul,  // attachment # <br>            &amp;IID_IAttachment,    // interface  <br>            MAPI_DEFERRED_ERRORS, // reduces RPCs <br>            &amp;lpAttachment); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Get the desired properties for this attachment. <br> <br>        // Notes: <br>        // If the attachment is not a binary attachment, this function may fail,  <br>        // because the PR_ATTACH_FILENAME property won't be there. <br>        hr = lpAttachment-&gt;GetProps( <br>                            (LPSPropTagArray) &amp;sAttachPropTags,   // property tags <br>                            fMapiUnicode,   // flags                                 <br>                            &amp;nProps,        // number of properties <br>                            &amp;lpPropVals);   // pointer to property value arrray <br> <br>        ASSERTERROR(nProps == sAttachPropTags.cValues, <br>                    "Bad nProps"); <br>        ASSERTERROR(!IsBadReadPtr(lpPropVals, sizeof(SPropValue) * nProps), <br>                    "Bad lpPropVals"); <br> <br>        if ( hr == MAPI_W_ERRORS_RETURNED ) <br>        { <br>            // Not an error if the PR_ATTACH_FILENAME property <br>            // doesn't exist.  (This just isn't a binary attachment!) <br>            if ( (PROP_TYPE(lpPropVals[iFileName].ulPropTag) == PT_ERROR) &amp;&amp; <br>                 (lpPropVals[iFileName].Value.l == MAPI_E_NOT_FOUND) ) <br>            { <br>                // We have a non-binary attachment. <br>                // This is not really an error.   <br>                // We just drop this attachment and <br>                // continue with the next. <br>                hr = HR_LOG(NOERROR); <br> <br>                continue; <br>            } <br>        }   // end if problems getting binary attachment properties <br> <br>        if ( FAILED(hr) || ( hr == MAPI_W_ERRORS_RETURNED) ) <br>        { <br>            // If things are O.K., hr should be NOERROR now. <br>            // general failure <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Determine if this attachment is a binary attachment  <br>        // (i.e. if it has binary data in the PR_ATTACH_DATA_BIN <br>        // property).  The only types of attachments which we <br>        // handle are binary attachments (PR_ATTACH_METHOD == ATTACH_BY_VALUE).   <br>        // All unresolved, <br>        // OLE and embedded message attachments will be dropped. <br>        if ( lpPropVals[iAttachMethod].Value.l != ATTACH_BY_VALUE ) <br>        { <br>            // We don't have a resolved, binary attachment. <br>            // Just drop this attachment and continue. <br>            continue; <br> <br>        }   // end if not a resolved, binary attachment <br> <br>        // Open a buffered stream on the binary attachment data property. <br>hr = HrOpenVirtualStreamOnProperty( <br>lpAttachment,// MAPI property object pointer <br>            PR_ATTACH_DATA_BIN, // binary attachment <br>            MAPI_DEFERRED_ERRORS,   // flags (reduces RPCs) <br>            &amp;lpStreamAtData); // buffered stream pointer <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ASSERT_IUNKNOWN_PTR(lpStreamAtData, "Bad lpStreamAtData"); <br> <br>        // Determine the number of bytes of binary attachment <br>        // data. <br>        hr = lpStreamAtData-&gt;Stat( <br>&amp;sStatStg,// stream statistics structure pointer <br>STATFLAG_NONAME);// statistics flags <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // See if data is too long for us to handle <br>        if ( sStatStg.cbSize.HighPart != 0 ) <br>        { <br>            hr = HR_LOG(E_NOTIMPL); <br> <br>            goto cleanup; <br>        } <br> <br>        cbAttachSize = sStatStg.cbSize.LowPart;    // # bytes of data <br> <br>        // Make sure that the file name isn't NULL. <br>        lpFileName = lpPropVals[iFileName].Value.LPSZ; <br>        if ( (lpFileName == NULL) || (*lpFileName == 0) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Create the attachment header from the attachment <br>        // file name and the # bytes in the attachment. <br>        // <br>        // Format:   FileName:#bytes <br>        // <br>        // e.g.      FILE1.TMP:54 <br>        lstrcpy(szAttachHdr, lpFileName); <br>        AddColon(szAttachHdr);    <br>        lstrcat(szAttachHdr, _ultoa(cbAttachSize, szTempBuffer, 10)); <br>                 <br>        // Emit the attachments "----beginattach" tag and data line <br>        hr = HrEmitTagDataLine( <br>                    lpszTagAttachHdr,  <br>                    szAttachHdr,  <br>                    m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Copy the binary attachment data from the input <br>        // stream to the output stream. <br>        hr = lpStreamAtData-&gt;CopyTo( <br>            m_lpStream,     // destination stream <br>            sStatStg.cbSize,    // number of bytes to copy <br>            NULL,           // don't care <br>            NULL);          // don't care <br>                         <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Emit the attachment's footer "----endattach" text. <br>        hr = m_lpStream-&gt;Write( <br>                lpszTagAttachEnd,           // data <br>                lstrlen(lpszTagAttachEnd) * sizeof(TCHAR),// length (no terminator) <br>                NULL); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // We are done with this attachment.  Do the next <br> <br>    }   // end for <br> <br>cleanup: <br> <br>    // Free all MAPI structures <br>    FREEPROWS(lpRows); <br>    MAPIFREEBUFFER(lpPropVals); <br> <br>    // Release all MAPI  object <br>    ULRELEASE(lpTable); <br>    ULRELEASE(lpAttachment); <br>    ULRELEASE(lpStreamAtData); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrRetrieveProps-------------------------------- <br>// <br>// DESCRIPTION: Retrieves and stores properties desired on specified object <br>// <br>// INPUT:       lpObject    --  pointer to message object <br>//              lpPropTags  --  property tag array pointer <br>// <br>// <br>// OUTPUT:      lppPropVals --  pointer to property value array pointer <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          EDK_E_NOT_FOUND if one or more <br>//                          properties not found, <br>//                          E_FAIL otherwise <br>// <br>// ------------------------------------------------------------- <br>HRESULT CIPMConvert::HrRetrieveProps(       // RETURNS: HRESULT <br>    IN LPMAPIPROP lpObj,                    // MAPI object pointer <br>    IN LPSPropTagArray lpPropTags,          // counted property tag array pointer <br>    OUT LPSPropValue * lppPropVals)     // pointer to property value array pointer <br>{ <br>    HRESULT hr      =   NOERROR; <br>    ULONG   ulCount =   0;      // count of properties retrieved <br> <br>    DEBUGPRIVATE("CIPMConvert::HrRetrieveProps()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CIPMConvert_HrRetrieveProps(lpObj, lpPropTags,  <br>                                         lppPropVals); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    hr = lpObj-&gt;GetProps(lpPropTags,    // properties to retrieve <br>                         fMapiUnicode,  // flags <br>                         &amp;ulCount,      // number of properties retrieved <br>                         lppPropVals);  // array of property values <br> <br>    switch ( hr ) <br>    { <br>        case MAPI_W_ERRORS_RETURNED: <br> <br>            hr = HR_LOG(EDK_E_NOT_FOUND); <br> <br>            goto cleanup; <br> <br>        default: <br> <br>            if ( FAILED(hr) || (ulCount != lpPropTags-&gt;cValues) ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br>    }   // end switch <br> <br>    // more consistency checks <br>    ASSERTERROR(!IsBadReadPtr(lppPropVals, sizeof(LPSPropValue)),  <br>                "Bad lppPropVals"); <br>    ASSERTERROR(!IsBadReadPtr(*lppPropVals, sizeof(SPropValue) * ulCount),  <br>                "Bad *lppPropVals"); <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::Reset---------------------------------------- <br>// <br>// DESCRIPTION: resets all of the conversion class' data members <br>//              and frees all MAPI memory allocated by the class. <br>//              This allow the thread's class instance to be re-used <br>//              for another conversion (if desired). <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     VOID <br>// <br>// ---------------------------------------------------------------- <br>VOID CIPMConvert::Reset()        // RETURNS: VOID <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("CIPMConvert::Reset()\n"); <br> <br>    // Reset all of the conversion class' data members. <br>    // This allows the class instance to be re-used by this <br>    // thread (Also frees MAPI memory). <br>    m_lpwszMsgClass = NULL; <br>    m_fTNEFEncode = FALSE; <br>    m_lpAB = NULL; <br>    m_lpEnvelope = NULL; <br>    m_lpStream = NULL; <br>    m_MsgType = mtNone; <br> <br>    // Release OLE objects <br>    ULRELEASE(m_lpContent); <br>    ULRELEASE(m_lpAttach); <br> <br>    MAPIFREEBUFFER(m_lpEnvProps); <br>    MAPIFREEBUFFER(m_lpCntProps); <br> <br>    return; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
