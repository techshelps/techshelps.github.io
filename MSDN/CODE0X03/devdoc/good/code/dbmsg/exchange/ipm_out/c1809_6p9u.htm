<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVTNEF.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1812"></a>CONVTNEF.CPP</h2>
<pre><code>// --convtnef.cpp-------------------------------------------------------------- <br>// <br>// Code for messages whose content is to be TNEFed. <br>// <br>// Copyright (C) Microsoft Corp., 1986-1996.  All Rights Reserved. <br>// All rights reserved. <br>// <br>// ---------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "convcls.h" <br>#include "tagnames.h" <br>#include "msgemit.h" <br>#include "ipmcdefs.h" <br> <br>//$--CIPMConvert::HrContentToTnef--------------------------------------------------------------- <br>// <br>// DESCRIPTION: TNEF encodes everything below the envelope. <br>// (e.g. the content and its attachments) <br>// <br>// INPUT:       none <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrContentToTnef() <br>{ <br>    HRESULT             hr          =   NOERROR; <br>    LPITNEF             lpTnef      =   NULL;   // TNEF interface pointer <br>    WORD                wKey        =   0;      // attachments key <br>    LPSPropTagArray     lpsPropTags =   NULL;   // property tag array pointer <br>    ULONG               ulPropTag   =   0;      // property tag <br>    ULONG               iPropTag    =   0;      // index into the property tag array <br>    ULONG               cExclude    =   0;      // count of properties to exclude <br>    LPSTnefProblemArray lpsProblems =   NULL;   // problem array pointer <br> <br>    // Want to include the recipient properites in the TNEF data. <br>    SizedSPropTagArray(1, sRecipPropTag)    = <br>    { <br>        1, <br>        { <br>            PR_MESSAGE_RECIPIENTS <br>        } <br>    }; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrContentToTnef()\n"); <br> <br>    // consistency checks <br>    ASSERTERROR(!FBadUnknown(m_lpStream), "Bad m_lpStream"); <br>    ASSERTERROR(!FBadUnknown(m_lpAB), "Bad m_lpAB"); <br>    ASSERTERROR(!FBadUnknown(m_lpEnvelope), "Bad m_lpEnvelope"); <br> <br>    // TNEF the envelope's content and all of its attachments. <br> <br>    // First, write out the "MAPIMAIL.DAT" TNEF section header <br>    // to the output stream. <br>    hr = HrEmitTagDataLine( <br>                lpszTagTnefHdr,     // tag <br>                (LPTSTR) lpszNullData,  // data <br>                m_lpStream);        // stream pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Next, open a TNEF interface on the envelope which writes its <br>    // output to the output stream. <br>  hr = OpenTnefStreamEx( <br>            NULL, <br>        m_lpStream,         // output stream pointer <br>        (LPTSTR) szTnefFileName,    // file name associated with TNEFed data <br>    TNEF_ENCODE,        // encode the message properties <br>    m_lpEnvelope,       // source message pointer <br>    wTnefKey,           // "unique" TNEF key <br>    m_lpAB,             // address book pointer <br>    &amp;lpTnef);           // TNEF interface object pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!FBadUnknown(lpTnef), "Bad lpTnef"); <br> <br>    // Encode all transmittable properties for the envelope content and <br>    // its attachments to the TNEFed stream. <br>    // First, get a list of all properties on the source message. <br>    hr = m_lpEnvelope-&gt;GetPropList( <br>            fMapiUnicode,       // MAPI flags <br>            &amp;lpsPropTags); <br> <br>    if ( FAILED(hr) )   // don't care about MAPI_W_ERRORS_RETURNED in this case <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!IsBadReadPtr(lpsPropTags, sizeof(LPSPropTagArray)),  <br>                "Bad lpsPropTags."); <br> <br>    // Now, build a new list of non-transmittable properties <br>    // which we wish to exclude from the TNEF data. <br>    for ( iPropTag = 0; iPropTag &lt; lpsPropTags-&gt;cValues; iPropTag++ ) <br>    { <br>        ulPropTag = lpsPropTags-&gt;aulPropTag[iPropTag]; <br> <br>        // See if we have a property which is transmittable, but <br>        // we still wish to exclude (gateway can't set some <br>        // transmittable properties) <br>  if ((ulPropTag == PR_SENT_REPRESENTING_NAME) || <br>   (ulPropTag == PR_SENT_REPRESENTING_ADDRTYPE) || <br>   (ulPropTag == PR_SENT_REPRESENTING_EMAIL_ADDRESS) || <br>   (ulPropTag == PR_SENT_REPRESENTING_SEARCH_KEY) || <br>   (ulPropTag == PR_SENT_REPRESENTING_ENTRYID)) <br>        { <br>            lpsPropTags-&gt;aulPropTag[cExclude] = ulPropTag; <br>            cExclude++; <br> <br>        }   // end property transmittable but not wanted <br> <br>        // See if we have a non-transmittable property which we <br>        // really wish to exclude <br>   else if ((!FIsTransmittable(ulPropTag)) &amp;&amp; <br>    (ulPropTag != PR_TRACE_INFO) &amp;&amp; <br>    (ulPropTag != PR_MTS_SUBJECT_ID) &amp;&amp; <br>    (ulPropTag != PR_ORIGINATOR_NAME) &amp;&amp; <br>    (ulPropTag != PR_ORIGINATOR_ADDRTYPE) &amp;&amp; <br>    (ulPropTag != PR_ORIGINATOR_ADDR) &amp;&amp; <br>    (ulPropTag != PR_ORIGINATOR_ENTRYID) &amp;&amp; <br>    (ulPropTag != PR_REPORT_DESTINATION_NAME) &amp;&amp; <br>    (ulPropTag != PR_REPORT_DESTINATION_ENTRYID) &amp;&amp; <br>    (ulPropTag != PR_MESSAGE_RECIPIENTS) &amp;&amp; <br>    (ulPropTag != PR_MESSAGE_ATTACHMENTS)) <br>        { <br>            lpsPropTags-&gt;aulPropTag[cExclude] = ulPropTag; <br>            cExclude++; <br> <br>        }   // end if property is non-transmittable &amp; not wanted <br>    }   // end for <br> <br>    // Exclude the list of properties just built from the TNEFed <br>    // data. <br>    lpsPropTags-&gt;cValues = cExclude;    // # of properties to exclude <br>    hr = lpTnef-&gt;AddProps( <br>            TNEF_PROP_EXCLUDE | // wish to exclude these properties <br>            TNEF_PROP_ATTACHMENTS_ONLY, // only want to encode the attachments <br>            0,              // attachemnt ID (not used) <br>            NULL,           // no special attachment data <br>            lpsPropTags);   // property tag array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Include the message recipient properties. <br>    hr = lpTnef-&gt;AddProps( <br>            TNEF_PROP_INCLUDE | // wish to include these properties <br>            TNEF_PROP_ATTACHMENTS_ONLY, // only want to encode the attachments <br>            0,              // attacment ID (not used) <br>            NULL,           // special attachment data <br>            (LPSPropTagArray) &amp;sRecipPropTag);  // property tag array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Save the TNEFed information to the output stream. <br>    hr = lpTnef-&gt;Finish( <br>                0,      // flags <br>                &amp;wKey,  // attachments key <br>                &amp;lpsProblems);  // problem array pointer <br> <br>    if ( FAILED(hr) )   // don't care about MAPI_W_ERRORS_RETURNED in this case <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    // Release all OLE and MAPI objects <br>    ULRELEASE(lpTnef); <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpsProblems); <br>    MAPIFREEBUFFER(lpsPropTags); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrOpenContent------------------------------------------------ <br>// <br>// DESCRIPTION: Utility function to open the envelope's content. <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CIPMConvert::HrOpenContent() <br>{ <br>    HRESULT         hr              =   NOERROR; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrOpenContent()\n"); <br> <br>    // consistency checks <br>    ASSERT_IUNKNOWN_PTR(m_lpEnvelope, "Bad m_lpEnvelope"); <br>    ASSERTERROR(m_lpAttach == NULL, "MEMORY LEAK of m_lpAttach"); <br>    ASSERTERROR(m_lpContent == NULL, "MEMORY LEAK of m_lpContent"); <br> <br>    // Open the message content which is attached to the envelope. <br>    // The content's attachment number is always 0.         <br>    hr = m_lpEnvelope-&gt;OpenAttach( <br>        0,      // attachment # <br>        NULL,   // interface (whatever is appropriate) <br>        MAPI_DEFERRED_ERRORS,   // reduces RPCs <br>        &amp;m_lpAttach);         // attachment pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>             <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(m_lpAttach, "Bad m_lpAttach"); <br> <br>    // Open the attachment as a message. <br>    hr = m_lpAttach-&gt;OpenProperty(PR_ATTACH_DATA_OBJ, <br>                                    &amp;IID_IMessage,  // interface identifier <br>                                    0,              // interface flags <br>                                    MAPI_DEFERRED_ERRORS,   // reduces RPCs <br>                                    (LPUNKNOWN *) &amp;m_lpContent); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(m_lpContent, "Bad m_lpContent"); <br> <br>cleanup: <br> <br>    // m_lpContent &amp; m_lpAttachment are released by Reset(). <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
