<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPM_OUT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1813"></a>IPM_OUT.CPP</h2>
<pre><code>// --ipm_out.cpp-------------------------------------------------------------- <br>// <br>// API entry points for the ipm_out dynamic link library. <br>// Converts MAPI messages to an 822-style header. <br>// This is the "Outbound IPM Converter" refered to in "Sample Gateway <br>// Vision, Requirements, Architecture and File Formats". <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "ipmconv.h" <br>#include "msgemit.h" <br>#include "convcls.h" <br>#include "ipm_out.chk" <br> <br>// GLOBAL VARIABLES <br> <br>// Thread local storage slot index.  <br>// This storage will be used to store the conversion class instance pointer <br>// for each thread. <br>static DWORD   dwTlsIndex   =   0xFFFFFFFF; <br> <br>// external function declarations <br> <br>// The DLL entry point extern "C" function declaration and <br>// "C" run-time library initialization extern "C" function declarations. <br>extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason,  <br>                                     LPVOID lpvReserved); <br>extern "C" BOOL WINAPI _CRT_INIT(HINSTANCE hInstDll, DWORD fdwReason,  <br>                                 LPVOID lpvReserved); <br> <br>//$--HrCnvQueryCapability--------------------------------------------------------- <br>// <br>// DESCRIPTION: Determines whether or not a particular conversion can be <br>//              done.  The only conversion allowed is from <br>//              a MAPI message of class ENVELOPE.IPM.NOTE or <br>//              REPORT.IPM.NOTE to a 822-style header <br>//              which is written an output stream. <br>// <br>// INPUT:       pszOptions  --  (not used) <br>//              pszClass    --  class of message to convert <br>//              pContent    --  MAPI message to convert <br>//              pEnv    --  conversion environment pointer  <br>// <br>// OUTPUT:      pfAmCandidate   --  TRUE if can do conversion, FALSE otherwise <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>// <br>// --------------------------------------------------------------------------- <br>static HRESULT HrCnvQueryCapability( <br>        IN LPCWSTR pszOptions,  // conversion options <br>        IN LPCWSTR pszClass,    // message class to convert <br>        IN PVOID pContent,      // message to convert (candidate) <br>        IN PEDKCNVENV pEnv,     // conversion environment pointer <br>        OUT BOOL * pfAmCandidate)   // TRUE if can convert, FALSE otherwise <br>{ <br>    HRESULT hr  =   NOERROR; <br> <br>    DEBUGPRIVATE("HrCnvQueryCapability()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCnvQueryCapability(pszOptions, pszClass, <br>                                  pContent, pEnv, pfAmCandidate); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Initialize output variable. <br>    *pfAmCandidate = FALSE; <br> <br>    // We can only convert message classes which contain ENVELOPE.IPM <br>    // or REPORT.IPM <br>    if ( (wcsstr(pszClass, IPMENVELOPECLASS) == NULL) &amp;&amp; <br>         (wcsstr(pszClass, IPMREPORTCLASS) == NULL) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // If we get to here, we can convert the message <br>    *pfAmCandidate = TRUE; <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrIPMto822Format-------------------------------------------------------- <br>// <br>// DESCRIPTION: Converts a MAPI IPM message to a "822-style" stream output <br>// <br>// NOTES:   Only one conversion may be performed at <br>//          a time (per thread). In order to do concurrent conversions, <br>//          create multiple threads. <br>// <br>// INPUT:       lpwszClass  --  message class <br>//              lpAddrBook  --  address book pointer <br>//              lpMessage   --  Pointer to MAPI message. <br>//              bTNEFEncode --  Do TNEF encoding of message attachment flag <br>//              lpStream    --  Stream to write to <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_FAIL if API function call failure, <br>//                              E_NOTIMPL if requesting a feature not implemented <br>//                              or supported, <br>//                              EDK_E_ALREADY_EXISTS if a conversion is already <br>//                              in progress, <br>// <br>// --------------------------------------------------------------------------- <br> <br>static HRESULT HrIPMto822Format(                        <br>                               IN LPCWSTR lpwszClass,     // message class <br>                               IN BOOL fTNEFEncode,       // TRUE is should encode attachments <br>                               IN LPADRBOOK lpAddrBook,   // address book pointer <br>                               IN LPMESSAGE lpMessage,    // pointer to MAPI message <br>                               IN LPSTREAM lpStream)      // pointer to stream <br>{ <br>    HRESULT         hr              =   NOERROR; <br>    CIPMConvert *   lpCIPMConvert   =   NULL;   // thread-safe conversion class instance pointer <br>    BOOL            fInitialized    =   FALSE;  // TRUE if conversion instance already in use <br> <br>    DEBUGPRIVATE("HrIPMto822Format()\n"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrIPMto822Format(lpwszClass, fTNEFEncode,  <br>                              lpAddrBook, lpMessage, lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    ASSERTERROR(dwTlsIndex != 0xFFFFFFFF, "Bad thread storage index"); <br> <br>    // Retrieve the conversion class instance pointer for this class. <br>    lpCIPMConvert = (CIPMConvert *) TlsGetValue(dwTlsIndex); <br> <br>    if ( !lpCIPMConvert ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Initialize conversion instance <br>    hr = lpCIPMConvert-&gt;HrInitialize(lpwszClass, fTNEFEncode,  <br>                                     lpAddrBook, <br>                                     lpMessage, lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Go ahead and do conversion. <br>    hr = lpCIPMConvert-&gt;HrConvert(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Note: The thread-safe conversion class instance is de-initialized <br>    // at thread or process termination. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>}   // end HrIPMto822Format() <br> <br>//$--HrCnvConvert--------------------------------------------------------- <br>// <br>// DESCRIPTION: Converts MAPI ENVELOPOE.IPM.* or REPORT.IPM.* <br>//              to an 822-style header and writes <br>//              the header to the stream passed in. <br>//              This function is designed to be called on a per-thread <br>//              basis.  Each thread can handle one conversion at a time. <br>// <br>// INPUT:       pszOptions  --  (not used) <br>//              pszClass    --  class of message to convert  <br>//                              (must contain ENVELOPE.IPM or <br>//                              REPORT.IPM) <br>//              pContent    --  MAPI message to convert <br>//              pContentOut --  Stream to write header to <br>//              pEnv    --  conversion environment pointer <br>// <br>// OUTPUT:      pcr --  pointer to conversion result enumeration <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL if API call failure, <br>//                          E_OUTOFMEMORY if memory problems <br>//                          E_NOTIMPL if conversion not supported, <br>//                          EDK_E_ALREADY_EXISTS if busy <br>// <br>// --------------------------------------------------------------------------- <br>static HRESULT HrCnvConvert(         <br>        IN LPCWSTR pszOptions,  // conversion options <br>        IN LPCWSTR pszClass,    // message class to convert <br>        IN PVOID pContent,      // message to convert (candidate) <br>        IN PVOID pContentOut,   // stream to write 822-style header to <br>        IN PEDKCNVENV pEnv,     // conversion environment pointer <br>        OUT EDKCNVRES * pcr)    // result of conversion <br>{ <br>    HRESULT     hr          =   NOERROR; <br> <br>    DEBUGPRIVATE("HrCnvConvert()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCnvConvert(pszOptions, pszClass, pContent, <br>                          pContentOut, pEnv, pcr); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // initialize output parameter <br>    *pcr = GCR_CONVERSION_FAILED; <br> <br>    // We can only convert classes which contain ENVELOPE.IPM or <br>    // REPORT.IPM. <br>    if ( (wcsstr(pszClass, IPMENVELOPECLASS) == NULL) &amp;&amp; <br>         (wcsstr(pszClass, IPMREPORTCLASS) == NULL) ) <br>    { <br>        *pcr = GCR_CANNOT_CONVERT; <br> <br>        goto cleanup; <br>    } <br> <br>    // Let our helper function do the work! <br>    hr = HrIPMto822Format( <br>        pszClass,                   // message class <br>        ((CONV_OPTIONS *) (pEnv-&gt;pGatewayDefined))-&gt;fTnefEncode,  // TNEF flag <br>        pEnv-&gt;lpAB,                 // address book pointer <br>        (LPMESSAGE) pContent,       // message to convert <br>        (LPSTREAM) pContentOut);    // stream to write to <br> <br>    switch (hr) <br>    { <br>        case E_NOTIMPL: <br>            // don't support this conversion type <br>            *pcr = GCR_CANNOT_CONVERT; <br> <br>            goto cleanup; <br> <br>        default: <br>            if ( FAILED(hr) ) <br>            { <br>                // conversion failed. <br>                *pcr = GCR_CONVERSION_FAILED; <br> <br>                goto cleanup; <br>            } <br>    }   // end switch <br>     <br>    // if we get to here, then the conversion succeeded. <br>    *pcr = GCR_OK; <br>     <br>cleanup: <br> <br>    RETURN(hr);         <br> <br>} <br> <br>// structure containing pointers to exported functions <br>static CONVDLLVECT sExportedFuncs = <br>{ <br>    nDesiredConvDllVersion,  // version number 1 <br>    HrCnvQueryCapability, <br>    HrCnvConvert <br>}; <br> <br>//$--HrGetExportVector-------------------------------------------------------- <br>// <br>// DESCRIPTION: Gets pointer to exported functions structure. <br>// <br>// INPUT:       dwVersion   --  version requested <br>// <br>// OUTPUT:      ppExportVectors --  pointer to export vector structure pointer <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT HrGetExportVector(      <br>        IN DWORD dwVersion,         // version requested <br>        OUT PCONVDLLVECT * ppExportVectors)  // pointer to exported functions structure <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPUBLIC("HrGetExportVector()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrGetExportVector(dwVersion, ppExportVectors); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // return pointer to exported vectors structure <br>    *ppExportVectors = &amp;sExportedFuncs; <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--DllEntryPoint------------------------------------------------------------ <br>// <br>// DESCRIPTION: 32-bit Windows DLL entry point procedure.  Called on process <br>//              and thread initialization and deinitialization. <br>//              Takes care of calling _CRT_INIT to initialize the "C" run-time <br>//              library. <br>// <br>// INPUT:       hInstDll    --  DLL instance handle <br>//              fdwReason   --  Reason being called flag (PROCESS_ATTACH ...) <br>//              lpvReserved --  reserved <br>// <br>// RETURNS:     TRUE if successful, FALSE otherwise <br>// <br>// --------------------------------------------------------------------------- <br>BOOL WINAPI DllEntryPoint(                // RETURNS: BOOL <br>            IN HINSTANCE hInstDll,  // DLL instance handle <br>            IN DWORD fdwReason,     // reason this function is being called <br>            IN LPVOID lpvReserved)  // reserved (has static and dynamic call values) <br>{ <br>    BOOL            fResult         =   TRUE;   // FALSE if can't initialize <br>    CIPMConvert *   lpCIPMConvert   =   NULL;   // Per-thread conversion class instance pointer <br> <br>    // check to see why we were called. <br>    switch ( fdwReason ) <br>    {         <br>        case DLL_PROCESS_ATTACH: <br>            // Initialize the "C" run-time libarary. <br>            fResult = _CRT_INIT(hInstDll, fdwReason, lpvReserved); <br> <br>            if ( !fResult ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Get the thread local storage index. <br>            dwTlsIndex = TlsAlloc(); <br> <br>            if ( dwTlsIndex == 0xFFFFFFFF ) <br>            { <br>                // general failure <br>                fResult = FALSE; <br> <br>                goto cleanup; <br>            } <br> <br>            // Initialize a new conversion class. <br>            lpCIPMConvert = new CIPMConvert(); <br> <br>            if ( !lpCIPMConvert ) <br>            { <br>                fResult = FALSE; <br> <br>                goto cleanup; <br>            } <br> <br>            // Store the new thread-safe conversion class in the <br>            // thread local storage slot. <br>            fResult = TlsSetValue(dwTlsIndex, (LPVOID) lpCIPMConvert); <br> <br>            break; <br> <br>        case DLL_THREAD_ATTACH: <br>            // Initialize the "C" run-time libarary. <br>            fResult = _CRT_INIT(hInstDll, fdwReason, lpvReserved); <br> <br>            if ( !fResult ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Initialize a new conversion class. <br>            lpCIPMConvert = new CIPMConvert(); <br> <br>            if ( !lpCIPMConvert ) <br>            { <br>                fResult = FALSE; <br> <br>                goto cleanup; <br>            } <br> <br>            // Store the new thread-safe conversion class in the <br>            // thread local storage slot. <br>            fResult = TlsSetValue(dwTlsIndex, (LPVOID) lpCIPMConvert); <br> <br>            break; <br> <br>        case DLL_THREAD_DETACH: <br>            // Get our thread-local conversion class instance pointer <br>            lpCIPMConvert = (CIPMConvert *) TlsGetValue(dwTlsIndex); <br> <br>            if ( lpCIPMConvert ) <br>            { <br>                // free this conversion class instance. <br>                delete lpCIPMConvert; <br>            } <br> <br>            // de-initialize the "C" run-time libarary. <br>            fResult = _CRT_INIT(hInstDll, fdwReason, lpvReserved); <br> <br>            break; <br> <br>        case DLL_PROCESS_DETACH: <br>            // Get our thread-local conversion class instance pointer <br>            lpCIPMConvert = (CIPMConvert *) TlsGetValue(dwTlsIndex); <br> <br>            if ( lpCIPMConvert ) <br>            { <br>                // free this conversion class instance. <br>                delete lpCIPMConvert; <br>            } <br> <br>            // Free our thread-local storage index <br>            (VOID)TlsFree(dwTlsIndex); <br> <br>            // de-initialize the "C" run-time libarary. <br>            fResult = _CRT_INIT(hInstDll, fdwReason, lpvReserved); <br>                         <br>            break; <br> <br>    }   // end switch <br> <br>cleanup: <br> <br>    return fResult; <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
