<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVREPT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1811"></a>CONVREPT.CPP</h2>
<pre><code>// --convrept.cpp------------------------------------------------ <br>// <br>// CIPMConvert source code for IPM reports. <br>// <br>// Copyright (C) Microsoft Corp., 1986-1996.  All rights reserved. <br>// <br>// -------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "ipmconv.h" <br>#include "msgemit.h" <br>#include "convcls.h" <br>#include "tagnames.h" <br>#include "convrept.chk" <br> <br>//$--CIPMConvert::HrReportTo822Format--------------------------- <br>// <br>// DESCRIPTION: Handle convertion of IPM reports to 822-style header <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_OUTOFMEMORY if memory problems <br>//                      E_NOTIMPL if unknown report type is received <br>//                      E_FAIL otherwise <br>// <br>// ------------------------------------------------------------- <br>HRESULT CIPMConvert::HrReportTo822Format()  // RETURNS: HRESULT <br>{ <br>    HRESULT hr  =   NOERROR; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrReportTo822Format()\n"); <br> <br>    // switch off of report's type <br>    switch ( m_MsgType ) <br>    { <br>        case mtNDR: <br>            // non-delivery report <br> <br>            // Handle the report's envelope. <br>            hr = HrConvertReport(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Handle non-recipient table. <br>            hr = HrConvertNonRecipients(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            break; <br> <br>        case mtDR: <br>            // delivery report <br> <br>            // Handle the report's envelope. <br>            hr = HrConvertReport(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Handle recipient table <br>            hr = HrConvertRecipients(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            break; <br> <br>        case mtNRN: <br>        case mtRN: <br>            // non-read notification &amp; <br>            // read notification <br> <br>            // Handle notification envelope <br>            // (appears to be essentially the same <br>            // as a regular IPM envelope. <br>            hr = HrConvertEnvelope(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Handle read/non-read notification content. <br>            hr = HrConvertNotifyContent(); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            break; <br> <br>        default: <br>            // shouldn't happen <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br> <br>    }   // end switch <br> <br>    // we are done <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrConvertReport-------------------------------- <br>// <br>// DESCRIPTION: Handle conversion of REPORT.[N]DR delivery/non-delivery <br>//              report envelope <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_OUTOFMEMORY if memory problems, <br>//                      E_NOTIMPL if don't support report type <br>//                      E_FAIL otherwise. <br>// <br>//---------------------------------------------------------------- <br>HRESULT CIPMConvert::HrConvertReport()   // RETURNS: HRESULT <br>{ <br>    HRESULT         hr              =   NOERROR; <br>    LPTSTR          lpTempString    =   NULL;       // temporary string pointer <br>    BOOL            fReportXID      =   TRUE;       // FALSE if report does not have XID property <br>    LPTRACEINFO     lpTraceInfo     =   NULL;       // trace information structure pointer <br>    ULONG           iLoop           =   0;          // loop index <br>    LPTRACEENTRY    lpTraceEntry    =   NULL;       // trace entry pointer <br>    BOOL            fTraceInfo      =   TRUE;       // FALSE if no trace information <br>    ULONG           ulObjType       =   0;          // MAPI object type <br>    LPMAILUSER      lpReportToUser  =   NULL;       // report to recipient pointer <br>    LPSPropValue    lpRecipProps    =   NULL;       // recipient property value array pointer <br> <br>    PINTTRACEINFO   lpIntTraceInfo  =   NULL;       // trace information structure pointer <br>    PINTTRACEENTRY  lpIntTraceEntry =   NULL;       // trace entry pointer <br>    BOOL            fIntTraceInfo   =   TRUE;       // FALSE if no trace information <br> <br>    // Report property indices <br>    const UINT  iClass       =    0;  // index of message class value     <br>    const UINT  iFromAddr    =    1;  // index of sender address <br>    const UINT  iXID         =    2;  // index of X-message identifier <br>    const UINT  iTrace       =    3;  // index of trace information <br>    const UINT  iSentTime    =    4;  // index of sent time value <br>    const UINT  iImportance  =    5;  // index of importance value <br>    const UINT  iPriority    =    6;  // index of priority value <br>    const UINT  iSubject     =    7;  // index of the subject value <br>    const UINT  iReportToEID =    8;  // index of report destination entry ID <br>    const UINT  iSubjectXID  =    9;  // index of report subject X-message ID value <br>    const UINT  iIntTrace    =   10;  // index of trace information <br> <br>    // number of report properties <br>    const ULONG     nProps          =   11; <br> <br>    // Properties to retrieve for the report envelope <br>    SizedSPropTagArray(nProps, sPropTagArray) = <br>    { <br>        nProps,  // number of properties <br>        { <br>            PR_MESSAGE_CLASS,   // report class property ID <br>            PR_SENDER_EMAIL_ADDRESS,    // report from address <br>            PR_MESSAGE_SUBMISSION_ID,   // report X-identifier <br>            PR_TRACE_INFO,      // report trace information <br>            PR_CREATION_TIME,   // report creation time <br>            PR_IMPORTANCE,      // report importance <br>            PR_PRIORITY,        // report priority <br>            PR_SUBJECT,         // report subject <br>            PR_REPORT_DESTINATION_ENTRYID,  // report destination entry identifier <br>            PR_MTS_SUBJECT_ID,  // report's subject X-identifier <br>            PR_INTERNAL_TRACE_INFO,  // report internal trace information <br>        } <br>    }; <br> <br>    // indices into the recipient property array. <br>    const UINT  iEmailAddr  =   0;      // recipient's email address <br>     <br>    const ULONG nRecipProps =   1;      // # of recipient properties <br> <br>    // Array of recipient properties to retrieve <br>    SizedSPropTagArray(nRecipProps, sRecipProps) = <br>    { <br>        nRecipProps,      // # recipient properties to retrieve <br>        { <br>            PR_EMAIL_ADDRESS    // recipient's email address <br>        } <br>    }; <br> <br>    DEBUGPRIVATE("CIPMConvert::HrConvertReport()\n"); <br> <br>    // consistency checks <br>    ASSERT_IUNKNOWN_PTR(m_lpAB, "Bad m_lpAB"); <br> <br>    // Retieve the properties needed on the report envelope. <br>    hr = HrRetrieveProps(m_lpEnvelope, <br>                          (LPSPropTagArray) &amp;sPropTagArray, <br>                          &amp;m_lpEnvProps); <br> <br>    // Delivery reports may not have the PR_MESSAGE_SUBMISSION_ID <br>    // nor the PR_MTS_SUBJECT_ID property.  This is a bug.  For the time <br>    // being, however, we shall not fail because of this. <br>    if ( hr == EDK_E_NOT_FOUND ) <br>    { <br>        UINT    iPropIndex  =   0; <br>        for ( iPropIndex = 0; iPropIndex &lt; sPropTagArray.cValues; <br>              iPropIndex++ ) <br>        { <br>            if ( PROP_TYPE(m_lpEnvProps[iPropIndex].ulPropTag) ==  <br>                 PT_ERROR ) <br>            { <br>                if ( iPropIndex == iXID ) <br>                { <br>                    fReportXID = FALSE; <br> <br>                    hr = HR_LOG(NOERROR);   // not treated as an error <br>                } <br> <br>                // It's also O.K. for there to be no trace <br>                // information. <br>                else if ( iPropIndex == iTrace ) <br>                { <br>                    // no trace information <br>                    fTraceInfo = FALSE;  <br> <br>                    hr = HR_LOG(NOERROR); <br> <br>                }   // end if no PR_TRACE_INFO <br> <br>                else if ( iPropIndex == iIntTrace ) <br>                { <br>                    // no internal trace information <br>                    fIntTraceInfo = FALSE;  <br> <br>                    hr = HR_LOG(NOERROR); <br> <br>                }   // end if no PR_INTERNAL_TRACE_INFO <br> <br>                else <br>                { <br>                    hr = HR_LOG(E_FAIL);    // another property isn't set <br> <br>                    goto cleanup; <br>                } <br>            } <br>        }   // end for <br>    } <br> <br>    // Test for other errors <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build and emit the "X-Tnef-Attach" tag and data line. <br>    // The TNEF data file name is always "MAPIMAIL.DAT" if <br>    // we are doing TNEF encoding and null otherwise. <br>    hr = HrEmitTagDataLine( <br>        lpszTagTnefAttach,      // tag <br>        (LPTSTR) (m_fTNEFEncode ? lpszTagTnefHdr : lpszNullData),  // data <br>        m_lpStream);            // stream pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // build and emit the "MAIL FROM" line.   <br>    // from the sender's address string. <br>    hr = HrEmitTagDataLine( <br>            lpszTagMailFrom,        // tag <br>            m_lpEnvProps[iFromAddr].Value.LPSZ,  // sender's Email address <br>            m_lpStream);              // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Emit the "RCPT TO" tag and data line. <br>    // First, we must open the address book entry associated with the  <br>    // destination entry identifier and retrieve the entry's email <br>    // address. <br>    hr = m_lpAB-&gt;OpenEntry( <br>        m_lpEnvProps[iReportToEID].Value.bin.cb,    // # bytes in entry ID <br>        (LPENTRYID) m_lpEnvProps[iReportToEID].Value.bin.lpb,   // entry identifier <br>        NULL,                                       // interface identifer <br>        MAPI_DEFERRED_ERRORS,                       // reduces RPCs <br>        &amp;ulObjType,                                 // MAPI object type <br>        (LPUNKNOWN *) &amp;lpReportToUser);             // report to recipient pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(ulObjType == MAPI_MAILUSER, "Bad ulObjType"); <br>    ASSERT_IUNKNOWN_PTR(lpReportToUser, "Bad lpReportToUser."); <br> <br>    // Retrieve the email address of the report recipient. <br>    hr = HrRetrieveProps( <br>        lpReportToUser,     // MAPI recipient pointer <br>        (LPSPropTagArray) &amp;sRecipProps,   // property tag array <br>        &amp;lpRecipProps);     // property value array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the recipient's address for the "RCPT_TO" tag <br>    hr = HrEmitTagDataLine( <br>            lpszTagRcptTo,          // tag <br>            lpRecipProps[iEmailAddr].Value.LPSZ, // report destination <br>            m_lpStream);          // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Emit the "DATA" marker <br>    hr = m_lpStream-&gt;Write( <br>            lpszTagData,        // data <br>            lstrlen(lpszTagData) * sizeof(TCHAR),   // length (no terminator) <br>            NULL); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Print out the "X-Message-Class:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>            lpszTagMsgClass,        // tag <br>            m_lpEnvProps[iClass].Value.LPSZ,  // report class                               <br>            m_lpStream);          // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build the date and time string <br>    hr = HrCreateDateTimeString( <br>                  &amp;(m_lpEnvProps[iSentTime].Value.ft),  // PR_CLIENT_SUBMIT_TIME property value <br>                  &amp;lpTempString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Date:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>                lpszTagDate,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    // Print out the "X-Message-ID:" tag and data line to the stream <br>    // The X-Message ID string is null terminated. <br>    if ( fReportXID ) <br>    { <br>        hr = HrEmitTagDataLine( <br>            lpszTagMsgID, <br>            (LPTSTR) m_lpEnvProps[iXID].Value.bin.lpb,   // really a null-terminated string <br>            m_lpStream); <br>    } <br> <br>    else <br>    { <br>        // Delivery reports may not have a PR_MESSAGE_SUBMISSION_ID <br>        // nor a PR_MTS_SUBJECT_ID.   <br>        // We will print out a "null" XID in this case. <br>        hr = HrEmitTagDataLine( <br>            lpszTagMsgID,            // tag <br>            (LPTSTR) lpszNullData,   // blank data <br>            m_lpStream); <br>    } <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "X-Message-Subject-ID:" tag and data line to the stream <br>    // The X-Message ID string is already null terminated. <br>    hr = HrEmitTagDataLine( <br>        lpszTagSubjectID,  <br>        (LPTSTR) m_lpEnvProps[iSubjectXID].Value.bin.lpb,    // really a null-terminated string <br>        m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build the trace information string, if any <br>    if ( fTraceInfo == TRUE ) <br>    { <br>        // have trace information <br>        lpTraceInfo = (LPTRACEINFO) (m_lpEnvProps[iTrace].Value.bin.lpb); <br> <br>        // Print out trace entry data <br>        for ( iLoop = 0; iLoop &lt; lpTraceInfo-&gt;cEntries; iLoop++ ) <br>        { <br>            // retrieve trace entry. <br>            lpTraceEntry = &amp;(lpTraceInfo-&gt;rgtraceentry[iLoop]); <br> <br>            // Create "External-Received-By" string <br>            hr = HrCreateExternalTraceString( <br>                lpTraceEntry-&gt;lAction,          // trace action <br>                lpTraceEntry-&gt;rgchCountryName,  // country name <br>                lpTraceEntry-&gt;rgchADMDName,     // ADMD name <br>                lpTraceEntry-&gt;rgchPRMDId,       // PRMD identifier <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "External-Received-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalRcvdBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "External-Received-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpTraceEntry-&gt;ftArrivalTime), // trace arrival time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out External-Received-At date and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalRcvdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Create "External-Attempted-By" string <br>            hr = HrCreateExternalTraceString( <br>                lpTraceEntry-&gt;lAction,              // trace action <br>                lpTraceEntry-&gt;rgchAttCountryName,   // country name <br>                lpTraceEntry-&gt;rgchAttADMDName,      // ADMD name <br>                lpTraceEntry-&gt;rgchAttPRMDId,        // PRMD identifier <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "External-Attempted-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalAttmBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "External-Deferred-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpTraceEntry-&gt;ftDeferredTime), // trace deferal time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out External-Deferred-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalDefdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>        }   // end for each trace entry <br>    }   // end if any trace information <br> <br>    // Build the internal trace information string, if any <br>    if ( fIntTraceInfo == TRUE ) <br>    { <br>        // have trace information <br>        lpIntTraceInfo = (PINTTRACEINFO) (m_lpEnvProps[iIntTrace].Value.bin.lpb); <br> <br>        // Print out trace entry data <br>        for ( iLoop = 0; iLoop &lt; lpIntTraceInfo-&gt;cEntries; iLoop++ ) <br>        { <br>            // retrieve trace entry. <br>            lpIntTraceEntry = &amp;(lpIntTraceInfo-&gt;rgIntTraceEntry[iLoop]); <br> <br>            // Create "Internal-Received-By" string <br>            hr = HrCreateInternalTraceString( <br>                lpIntTraceEntry-&gt;lAction,          // trace action <br>                lpIntTraceEntry-&gt;rgchCountryName,  // country name <br>                lpIntTraceEntry-&gt;rgchADMDName,     // ADMD name <br>                lpIntTraceEntry-&gt;rgchPRMDId,       // PRMD identifier <br>                lpIntTraceEntry-&gt;rgchMTAName,      // ADMD name <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "Internal-Received-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalRcvdBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "Internal-Received-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpIntTraceEntry-&gt;ftArrivalTime), // trace arrival time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out Internal-Received-At date and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalRcvdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Create "Internal-Attempted-By" string <br>            hr = HrCreateInternalTraceString( <br>                lpIntTraceEntry-&gt;lAction,              // trace action <br>                lpIntTraceEntry-&gt;rgchAttCountryName,   // country name <br>                lpIntTraceEntry-&gt;rgchAttADMDName,      // ADMD name <br>                lpIntTraceEntry-&gt;rgchAttPRMDId,        // PRMD identifier <br>                lpIntTraceEntry-&gt;rgchAttMTAName,       // MTA name <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "Internal-Attempted-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalAttmBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "Internal-Deferred-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpIntTraceEntry-&gt;ftDeferredTime), // trace deferal time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out Internal-Deferred-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalDefdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>        }   // end for each internal trace entry <br>    }   // end if any internal trace information <br> <br>    // Print out the "From:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>            lpszTagFrom,     // tag <br>            m_lpEnvProps[iFromAddr].Value.LPSZ,    // report creator <br>            m_lpStream);                // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "TO:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>            lpszTagTo,     // tag <br>            lpRecipProps[iEmailAddr].Value.LPSZ,    // report destination <br>            m_lpStream);                // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out a blank line <br>    hr = m_lpStream-&gt;Write( <br>            lpszNewLine,            // data <br>            lstrlen(lpszNewLine) * sizeof(TCHAR),   // length (no terminator) <br>            NULL); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Subject:" tag and data line to the stream <br>    hr = HrEmitTagDataLine( <br>            lpszTagSubject,                // tag <br>            m_lpEnvProps[iSubject].Value.LPSZ,  // PR_SUBJECT property value <br>            m_lpStream);                    // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build priority string. <br>    hr = HrCreatePriorityString( <br>                m_lpEnvProps[iPriority].Value.ul,  // PR_PRIORITY property value <br>                &amp;lpTempString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Priority:" tag and data line to the stream <br>    hr = HrEmitTagDataLine( <br>            lpszTagPriority,  <br>            lpTempString,  <br>            m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    // Build the importance string <br>    hr = HrCreateImportanceString( <br>                m_lpEnvProps[iImportance].Value.ul,    // PR_IMPORTANCE property value <br>                &amp;lpTempString);                             // buffer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Importance:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>                lpszTagImportance,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br>    <br>    MAPIFREEBUFFER(lpTempString); <br> <br>cleanup: <br> <br>    // Release MAPI objects <br>    ULRELEASE(lpReportToUser); <br> <br>    // Release MAPI buffers <br>    MAPIFREEBUFFER(lpTempString); <br>    MAPIFREEBUFFER(lpRecipProps); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrConvertNonRecipients-------------------------- <br>// <br>// DESCRIPTION: Handle NDR report's non-recipient table <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise. <br>// <br>// ------------------------------------------------------------ <br>HRESULT CIPMConvert::HrConvertNonRecipients()    // RETURNS: HRESULT <br>{ <br>    HRESULT     hr                  =   NOERROR; <br>    LPSRowSet   lpRows              =   NULL;       // recipient table rows pointer <br>    ULONG       iRowCount           =   0;          // row counter <br> <br>    // temporary string buffer <br>    TCHAR       szTempBuffer[ulMaxOutStringLen + 1]    =   TEXT(""); <br> <br>    // Columns needed from the report's recipient table <br>    SizedSPropTagArray(4, sRecipProps)  =    <br>    { <br>        4,      // number of properties (columns) desired <br>        { <br>            PR_EMAIL_ADDRESS,   // non-recipient Email address <br>            PR_REPORT_TEXT,     // report text <br>            PR_NDR_DIAG_CODE,   // diagnostic failure code <br>            PR_NDR_REASON_CODE  // reason failure code <br>        } <br>    }; <br> <br>    // indices into the property values array <br>    const UINT  iRecipient      =   0;  // non-recipient email address <br>    const UINT  iText           =   1;  // report text <br>    const UINT  iDiagCode       =   2;  // diagnostic reason code <br>    const UINT  iNDRCode        =   3;  // non-delivery reason code <br> <br>    DEBUGPRIVATE("CIPMConvert::HrConvertNonRecipients()\n"); <br> <br>    // Retrieve the rows from the NDR's recipient table <br>    hr = HrGetRecipientList( <br>                m_lpEnvelope,   // report pointer <br>                (LPSPropTagArray) &amp;sRecipProps, // columns to retrieve <br>                &amp;lpRows);       // pointer to rows array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Make sure that we have at least one non-recipient <br>    if ( lpRows-&gt;cRows == 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Process each non-recipient <br>    for ( iRowCount = 0; iRowCount &lt; lpRows-&gt;cRows;  <br>          iRowCount++ ) <br>    { <br>        // Emit the "Your message was not delivered to" tag and  <br>        // data line. <br>        hr = HrEmitTagDataLine( <br>                lpszTagNotSentTo,   // tag <br>                lpRows-&gt;aRow[iRowCount].lpProps[iRecipient].Value.LPSZ, // data <br>                m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Emit the "for the following reason" tag and data line. <br>        hr = HrEmitTagDataLine( <br>                lpszTagReason,      // tag <br>                lpRows-&gt;aRow[iRowCount].lpProps[iText].Value.LPSZ, // data <br>                m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Format the diagnostic code <br>        wsprintf( <br>            szTempBuffer,  <br>            TEXT("%ld"),  <br>            lpRows-&gt;aRow[iRowCount].lpProps[iDiagCode].Value.ul); <br> <br>        // Emit the "Diagnostic code" tag and data line. <br>        hr = HrEmitTagDataLine( <br>            lpszTagDiagCode,        // tag <br>            szTempBuffer,           // data <br>            m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Format the NDR reason code <br>        wsprintf( <br>            szTempBuffer,  <br>            TEXT("%ld"),  <br>            lpRows-&gt;aRow[iRowCount].lpProps[iNDRCode].Value.ul); <br> <br>        // Emit the "Diagnostic reason" tag and data line. <br>        hr = HrEmitTagDataLine( <br>            lpszTagNDRCode,         // tag <br>            szTempBuffer,           // data <br>            m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // done with this recipient <br> <br>    }   // end for <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    FREEPROWS(lpRows); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrConvertRecipients-------------------------- <br>// <br>// DESCRIPTION: Handle DR report's recipient table <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise. <br>// <br>// ------------------------------------------------------------ <br>HRESULT CIPMConvert::HrConvertRecipients()    // RETURNS: HRESULT <br>{ <br>    HRESULT     hr                  =   NOERROR; <br>    LPSRowSet   lpRows              =   NULL;       // recipient table rows pointer <br>    ULONG       iRowCount           =   0;          // row counter <br>    LPTSTR      lpTempString        =   NULL;       // temporary string pointer <br> <br>    // Columns needed from the report's recipient table <br>    SizedSPropTagArray(2, sRecipProps)  =    <br>    { <br>        2,      // number of properties (columns) desired <br>        { <br>            PR_EMAIL_ADDRESS,   // non-recipient Email address <br>            PR_DELIVER_TIME     // delivery time <br>        } <br>    }; <br> <br>    // indices into the property values array <br>    const UINT  iRecipient      =   0;  // recipient email address <br>    const UINT  iTime           =   1;  // delivery time <br> <br>    DEBUGPRIVATE("CIPMConvert::HrConvertRecipients()\n"); <br> <br>    // Retrieve the rows from the DR's recipient table <br>    hr = HrGetRecipientList( <br>                m_lpEnvelope,   // report pointer <br>                (LPSPropTagArray) &amp;sRecipProps, // columns to retrieve <br>                &amp;lpRows);       // pointer to rows array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Make sure that we have at least one recipient <br>    if ( lpRows-&gt;cRows == 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; </code></pre>
<p>
</p>
<pre><code>} <br> <br>    for ( iRowCount = 0; iRowCount &lt; lpRows-&gt;cRows;  <br>          iRowCount++ ) <br>    { <br>        // Emit the "Your message was successfully delivered to" <br>        // tag and data line. <br>        hr = HrEmitTagDataLine( <br>                    lpszTagSentTo,      // tag <br>                    lpRows-&gt;aRow[iRowCount].lpProps[iRecipient].Value.LPSZ, // data <br>                    m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Create the delivery time string <br>        hr = HrCreateDateTimeString( <br>                    &amp;(lpRows-&gt;aRow[iRowCount].lpProps[iTime].Value.ft),   // delivery time <br>                    &amp;lpTempString); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Emit the "at" time tag and data line. <br>        hr = HrEmitTagDataLine( <br>                    lpszTagAtTime,      // tag <br>                    lpTempString,       // data <br>                    m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Free temporary buffer <br>        MAPIFREEBUFFER(lpTempString); <br> <br>        // We are done with this recipient <br> <br>    }   // end for <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    FREEPROWS(lpRows); <br>     <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CIPMConvert::HrConvertNotifyContent-------------------------- <br>// <br>// DESCRIPTION: Handles read and non-read notification report's content <br>// <br>// INPUT:   none <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_FAIL otherwise. <br>// <br>// ------------------------------------------------------------ <br>HRESULT CIPMConvert::HrConvertNotifyContent()    // RETURNS: HRESULT <br>{ <br>    HRESULT         hr              =   NOERROR; <br>    LPTSTR          lpTempString    =   NULL;   // temporary string pointer <br>    LPSRowSet       lpRecipRows     =   NULL;   // recipient table rows pointer <br>    LPTRACEINFO     lpTraceInfo     =   NULL;   // trace information structure pointer <br>    ULONG           iLoop           =   0;      // loop index <br>    LPTRACEENTRY    lpTraceEntry    =   NULL;   // trace entry pointer <br> <br>    PINTTRACEINFO   lpIntTraceInfo  =   NULL;   // trace information structure pointer <br>    PINTTRACEENTRY  lpIntTraceEntry =   NULL;   // trace entry pointer <br> <br>    // temporary string buffer <br>    TCHAR           szTempBuf[ulMaxOutStringLen + 1]   =   TEXT(""); <br> <br>    // common notification property indices <br>    const UINT  iClass       =    0;  // index of message class value     <br>    const UINT  iFromAddr    =    1;  // index of sender address <br>    const UINT  iXID         =    2;  // index of X-message identifier <br>    const UINT  iSentTime    =    3;  // index of sent time value <br>    const UINT  iImportance  =    4;  // index of importance value <br>    const UINT  iPriority    =    5;  // index of priority value <br>    const UINT  iSubject     =    6;  // index of the subject value <br>    const UINT  iSubjectXID  =    7;  // index of X-message subject ID <br>    const UINT  iReportTime  =    8;  // index of report time <br> <br>    // Number of read-notification properties <br>    const ULONG nRNProps     =    9;   <br> <br>    // properties unique to non read notifications <br>    const UINT  iDiscardCode =    9;  // PR_DISCARD_REASON <br>    const UINT  iNonRcptCode =    10; // PR_NON_RECEIPT_REASON <br> <br>    // number of non-read notification content properties <br>    const ULONG     nNRNProps    =   11; <br> <br>    // Properties needed from the NRN report's content <br>    SizedSPropTagArray(nNRNProps, sPropsNotify)  =    <br>    { <br>        nNRNProps,   // number of properties (columns) desired <br>        { <br>            PR_MESSAGE_CLASS,       // report class property ID <br>            PR_SENDER_EMAIL_ADDRESS,// content's sender's email address, index iFromAddr <br>            PR_SEARCH_KEY,          // dummy--acutally use PR_MESSAGE_SUBMISSION_ID on from <br>                                    // the envelope <br>            PR_CLIENT_SUBMIT_TIME,  // content's sent time, index iSentTime <br>            PR_IMPORTANCE,          // report importance <br>            PR_PRIORITY,            // report priority <br>            PR_SUBJECT,             // report subject <br>            // Notifications use PR_PARENT_KEY instread of <br>            // PR_MTS_SUBJECT_ID for the X-message subject identifier <br>            PR_PARENT_KEY,          // X-message-subject identifier <br>            PR_REPORT_TIME,         // report time <br>            PR_DISCARD_REASON,      // reason why message was discarded <br>            PR_NON_RECEIPT_REASON   // reson why message wansn't read <br>        } <br>    }; <br> <br>    // indices used into envelope property array <br>    const UINT  iTrace       =    3;  // PR_TRACE_INFO <br>    const UINT  iIntTrace    =    4;  // PR_INTERNAL_TRACE_INFO <br> <br>    // Columns needed from the report content's recipient table <br>    SizedSPropTagArray(1, sRecipProps)  =    <br>    { <br>        1,      // number of properties (columns) desired <br>        { <br>            PR_EMAIL_ADDRESS   // notification "TO" Email address <br>        } <br>    }; <br> <br>    // indices into the recipient table property values <br>    const UINT  iRecipient  =   0;  // PR_EMAIL_ADDRESS <br> <br>    DEBUGPRIVATE("CIPMConvert::HrConvertNotifyContent()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR((m_MsgType == mtNRN || m_MsgType == mtRN), <br>                "Bad m_MsgType"); <br> <br>    // Open the envelope's content. <br>    hr = HrOpenContent(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if ( m_MsgType == mtRN ) <br>    { <br>        // Adjust number of properties to retrieve for read notifications. <br>        sPropsNotify.cValues = nRNProps; <br>    } <br> <br>    // Retrieve the desired properties from the NRN or RN's <br>    // content <br>    hr = HrRetrieveProps( <br>                m_lpContent,    // report pointer <br>                (LPSPropTagArray) &amp;sPropsNotify,  // Properties to retrieve <br>                &amp;m_lpCntProps); // pointer to property array pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "X-Message-Class:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>            lpszTagMsgClass,        // tag <br>            m_lpCntProps[iClass].Value.LPSZ,  // report class                               <br>            m_lpStream);          // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build the date and time string <br>    hr = HrCreateDateTimeString( <br>                  &amp;(m_lpCntProps[iSentTime].Value.ft),  // PR_CLIENT_SUBMIT_TIME property value <br>                  &amp;lpTempString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Date:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>                lpszTagDate,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    // Print out the "X-Message-ID:" tag and data line to the stream <br>    // The X-Message ID string is null terminated. <br>    // Note:  The PR_MESSAGE_SUBMISSION_ID is really on the <br>    // envelope. <br>    hr = HrEmitTagDataLine( <br>            lpszTagMsgID, <br>            (LPTSTR) m_lpEnvProps[iXID].Value.bin.lpb,   // really a null-terminated string <br>            m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "X-Message-Subject-ID:" tag and data line to the stream <br>    // The X-Message ID string is already null terminated. <br>    // This is the binary PR_PARENT_KEY property for notifications, <br>    // so we shall need to convert it to ASCII. <br> <br>    // Check that we have enough room in our output buffer. <br>    ASSERTERROR((m_lpCntProps[iSubjectXID].Value.bin.cb * 2 &lt;= ulMaxOutStringLen), <br>                "Bad cbParentKey"); <br>    HexFromBin( <br>            m_lpCntProps[iSubjectXID].Value.bin.lpb,    // binary data <br>            m_lpCntProps[iSubjectXID].Value.bin.cb,     // # bytes of binary data <br>            szTempBuf);                                 // string buffer <br> <br>    ASSERTERROR(!IsBadStringPtr(szTempBuf, INFINITE), "Bad szTempBuf"); <br> <br>    hr = HrEmitTagDataLine( <br>            lpszTagSubjectID,       // tag <br>            szTempBuf,              // data             <br>            m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the trace information, if any. <br>    if ( PROP_TYPE(m_lpEnvProps[iTrace].ulPropTag) != PT_ERROR ) <br>    { <br>        // We have valid trace information <br>        lpTraceInfo = (LPTRACEINFO) (m_lpEnvProps[iTrace].Value.bin.lpb); <br> <br>        // Print out trace entries <br>        for ( iLoop = 0; iLoop &lt; lpTraceInfo-&gt;cEntries; iLoop++ ) <br>        { <br>            // retrieve trace entry. <br>            lpTraceEntry = &amp;(lpTraceInfo-&gt;rgtraceentry[iLoop]); <br> <br>            // Create "External-Received-By" string <br>            hr = HrCreateExternalTraceString( <br>                lpTraceEntry-&gt;lAction,          // trace action <br>                lpTraceEntry-&gt;rgchCountryName,  // country name <br>                lpTraceEntry-&gt;rgchADMDName,     // ADMD name <br>                lpTraceEntry-&gt;rgchPRMDId,       // PRMD identifier <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "External-Received-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalRcvdBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "External-Received-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpTraceEntry-&gt;ftArrivalTime), // trace arrival time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out External-Received-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalRcvdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Create "External-Attempted-By" string <br>            hr = HrCreateExternalTraceString( <br>                lpTraceEntry-&gt;lAction,              // trace action <br>                lpTraceEntry-&gt;rgchAttCountryName,   // country name <br>                lpTraceEntry-&gt;rgchAttADMDName,      // ADMD name <br>                lpTraceEntry-&gt;rgchAttPRMDId,        // PRMD identifier <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "External-Attempted-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalAttmBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "External-Deferred-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpTraceEntry-&gt;ftDeferredTime), // trace deferal time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out External-Deferred-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagExternalDefdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>        }   // end for each trace entry <br>    }   // end if trace information <br> <br>    // Print out the internal trace information, if any. <br>    if ( PROP_TYPE(m_lpEnvProps[iIntTrace].ulPropTag) != PT_ERROR ) <br>    { <br>        // We have valid trace information <br>        lpIntTraceInfo = (PINTTRACEINFO) (m_lpEnvProps[iIntTrace].Value.bin.lpb); <br> <br>        // Print out trace entries <br>        for ( iLoop = 0; iLoop &lt; lpIntTraceInfo-&gt;cEntries; iLoop++ ) <br>        { <br>            // retrieve trace entry. <br>            lpIntTraceEntry = &amp;(lpIntTraceInfo-&gt;rgIntTraceEntry[iLoop]); <br> <br>            // Create "Internal-Received-By" string <br>            hr = HrCreateInternalTraceString( <br>                lpIntTraceEntry-&gt;lAction,          // trace action <br>                lpIntTraceEntry-&gt;rgchCountryName,  // country name <br>                lpIntTraceEntry-&gt;rgchADMDName,     // ADMD name <br>                lpIntTraceEntry-&gt;rgchPRMDId,       // PRMD identifier <br>                lpIntTraceEntry-&gt;rgchMTAName,      // MTA name <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "Internal-Received-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalRcvdBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "Internal-Received-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpIntTraceEntry-&gt;ftArrivalTime), // trace arrival time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out Internal-Received-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalRcvdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Create "Internal-Attempted-By" string <br>            hr = HrCreateInternalTraceString( <br>                lpIntTraceEntry-&gt;lAction,              // trace action <br>                lpIntTraceEntry-&gt;rgchAttCountryName,   // country name <br>                lpIntTraceEntry-&gt;rgchAttADMDName,      // ADMD name <br>                lpIntTraceEntry-&gt;rgchAttPRMDId,        // PRMD identifier <br>                lpIntTraceEntry-&gt;rgchAttMTAName,       // MTA name <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out the "Internal-Attempted-By:" tag and data line to the stream. <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalAttmBy,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>            // Build "Internal-Deferred-At" date and time string <br>            hr = HrCreateDateTimeString( <br>                &amp;(lpIntTraceEntry-&gt;ftDeferredTime), // trace deferal time <br>                &amp;lpTempString); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Print out Internal-Deferred-At data and time string <br>            hr = HrEmitTagDataLine( <br>                lpszTagInternalDefdAt,  // tag <br>                lpTempString,       // data <br>                m_lpStream);        // stream <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            MAPIFREEBUFFER(lpTempString); <br> <br>        }   // end for each internal trace entry <br>    }   // end if internal trace information <br> <br>    // Print out the "From:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>            lpszTagFrom,     // tag <br>            m_lpCntProps[iFromAddr].Value.LPSZ,    // report creator <br>            m_lpStream);                // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build the "TO:" tag and data line from the <br>    // content's recipient table. <br>    hr = HrGetRecipientList( <br>            m_lpContent,        // MAPI message content pointer <br>            (LPSPropTagArray) &amp;sRecipProps,        // property columns desired array <br>            &amp;lpRecipRows);      // Rows retrieved from recipient table <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // There should only be one "TO" for a read or non-read <br>    // notification, since an IPM.NOTE message can have only one  <br>    // sender. <br>    if ( lpRecipRows-&gt;cRows != 1 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Print out the "TO:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>            lpszTagTo,     // tag <br>            lpRecipRows-&gt;aRow[0].lpProps[iRecipient].Value.LPSZ,    // report destination <br>            m_lpStream);                // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out a blank line <br>    hr = m_lpStream-&gt;Write( <br>            lpszNewLine,            // data <br>            lstrlen(lpszNewLine) * sizeof(TCHAR),   // length (no terminator) <br>            NULL); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Subject:" tag and data line to the stream <br>    hr = HrEmitTagDataLine( <br>            lpszTagSubject,                // tag <br>            m_lpCntProps[iSubject].Value.LPSZ,  // PR_SUBJECT property value <br>            m_lpStream);                    // stream <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Build priority string. <br>    hr = HrCreatePriorityString( <br>                m_lpCntProps[iPriority].Value.ul,  // PR_PRIORITY property value <br>                &amp;lpTempString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Priority:" tag and data line to the stream <br>    hr = HrEmitTagDataLine( <br>            lpszTagPriority,  <br>            lpTempString,  <br>            m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    // Build the importance string <br>    hr = HrCreateImportanceString( <br>                m_lpCntProps[iImportance].Value.ul,    // PR_IMPORTANCE property value <br>                &amp;lpTempString);                             // buffer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Print out the "Importance:" tag and data line to the stream. <br>    hr = HrEmitTagDataLine( <br>                lpszTagImportance,  <br>                lpTempString,  <br>                m_lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br>    <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    // The output for the two notifications diverges <br>    // here. <br>    if ( m_MsgType == mtNRN )    // non-read notification <br>    { <br>        // Emit the "Your message was not read by" tag <br>        // and data line <br>        hr = HrEmitTagDataLine( <br>                lpszTagNotReadBy,   // tag <br>                m_lpCntProps[iFromAddr].Value.LPSZ,    // data <br>                m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Create the report time string. <br>        hr = HrCreateDateTimeString( <br>            &amp;(m_lpCntProps[iReportTime].Value.ft),    // time <br>            &amp;lpTempString); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Emit the "at" tag and data line <br>        hr = HrEmitTagDataLine( <br>                lpszTagAtTime,      // tag <br>                lpTempString,       // data <br>                m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // free temporary string buffer <br>        MAPIFREEBUFFER(lpTempString); <br> <br>        // Format the discard code data <br>        wsprintf( <br>                szTempBuf,      // buffer <br>                TEXT("%ld"),    // format string <br>                m_lpCntProps[iDiscardCode].Value.ul);   // discard code <br> <br>        // Emit the "Discard code" tag and data line. <br>        hr = HrEmitTagDataLine( <br>                lpszTagDiscCode,    // tag <br>                szTempBuf,          // data <br>                m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Format the non-receipt code data <br>        wsprintf( <br>                szTempBuf,      // buffer <br>                TEXT("%ld"),    // format string <br>                m_lpCntProps[iNonRcptCode].Value.ul);   // code <br> <br>        // Emit the "Non-receipt code" tag and data line <br>        hr = HrEmitTagDataLine( <br>                lpszTagNRNCode,     // tag <br>                szTempBuf,          // buffer <br>                m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>    }   // end if NRN <br> <br>    else if ( m_MsgType == mtRN )    // read notification <br>    { <br>        // Emit the "Your message was read by" tag and <br>        // data line. <br>        hr = HrEmitTagDataLine( <br>                lpszTagReadBy,          // tag <br>                m_lpCntProps[iFromAddr].Value.LPSZ,    // data <br>                m_lpStream); <br> <br>        // Create the receipt time string. <br>        hr = HrCreateDateTimeString( <br>            &amp;(m_lpCntProps[iReportTime].Value.ft),    // time <br>            &amp;lpTempString); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Emit the "at" tag and data line <br>        hr = HrEmitTagDataLine( <br>                lpszTagAtTime,      // tag <br>                lpTempString,       // data <br>                m_lpStream); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // free temporary string buffer <br>        MAPIFREEBUFFER(lpTempString); <br>    } <br> <br>    else <br>    { <br>        // shouldn't happen <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    FREEPROWS(lpRecipRows); <br> <br>    MAPIFREEBUFFER(lpTempString); <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
