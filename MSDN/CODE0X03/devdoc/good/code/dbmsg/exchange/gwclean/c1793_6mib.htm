<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GWCLEAN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1793"></a>GWCLEAN.CPP</h2>
<pre><code>// --gwclean.cpp-------------------------------------------------------------- <br>// <br>// Implements the GWCLEAN gateway utility which <br>// moves all messages in a gateway's folder before a particular <br>// date and time to a PST (personal information store). <br>// <br>// Syntax: <br>//  <br>// GWCLEAN GatewayProfileName [flags] <br>// <br>// where the flags are: <br>// <br>//  -DAYS=&lt;#DaysPriorToToday&gt;    --  # of days prior to today <br>//                                   defaults to yesterday <br>//  -FILE=&lt;PSTFileName&gt;          --  PST file name to move messages to <br>//                                   defaults to GWCLEAN.PST in current <br>//                                   directory <br>//  -FOLDER=&lt;GatewayFolderName&gt;  --  folder to move gateway message from <br>//                                   defaults to MTS-OUT <br>// <br>// Copyright (C) Microsoft Corporation 1986-1996.  All Rights Reserved <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "mspst.h" <br> <br>#include "gwstring.h" <br>#include "gwobjcls.h" <br>#include "gwevents.h"// compiled from gwevents.mc <br>#include "gwclean.chk" <br> <br>// Globals <br>CGWClean * lpCGWClean  =   NULL;    // global GWCLEAN class object pointer <br> <br>// external function declarations <br>extern HRESULT HrParseCommandLine( <br>                    IN INT argc,    // argument count <br>                    IN CHAR * argv[],   // list of arguments <br>                    OUT LPTSTR lpProfile,      // GW profile name <br>                    OUT LPTSTR lpPSTName,      // PST name <br>                    OUT LPTSTR lpFolder,       // GW folder name <br>                    OUT LPFILETIME lpBeforeTime); // date/time before structure pointer <br> <br>extern VOID DisplayUserMsg(         // RETURNS: VOID <br>                    IN UINT uResID,            // resource identifier <br>                    ...);           // variable arguments <br> <br>extern HRESULT HrComputeDate(           // RETURNS: HRESULT <br>                    IN UINT,            // number of days before today <br>                    OUT LPFILETIME);    // file time structure pointer <br> <br>extern HRESULT HrCheckFileName(     // RETURNS: HRESULT <br>            IN LPTSTR lpFileName);  // file name to check <br> <br>// useful constants <br>LPTSTRpszAppName=TEXT("GWCLEAN"); <br> <br>//$--INTERNAL_ERROR----------------------------------------------------------- <br>//  Helper function for EventLogMsg <br>// --------------------------------------------------------------------------- <br>extern inline VOID INTERNAL_ERROR( <br>    IN LPCTSTR str, <br>    IN const HRESULT hr) <br>{ <br>    TCHAR szErrorCode[16] = {0}; <br> <br>    EventLogMsg( <br>        GWCLEAN_INTERNALERR, <br>        2, str, _itot( hr, szErrorCode, 16), <br>        0); <br>} <br> <br>//$--main--------------------------------------------------------------------- <br>// <br>// DESCRIPTION: Implement GWCLEAN gateway utility described above. <br>// <br>// INPUT:       INT   --  number of command line arguments <br>//              TCHAR[] *    --  command line arguments <br>// <br>// RETURNS:     int              --  0 if successful, <br>//                                  non-zero otherwise: <br>//                                  (See edkcode.h for more specifics) <br>// <br>// ---------------------------------------------------------------------------- <br> <br>INT main(                   // RETURNS: INT <br>        INT argc,           // number of command line arguments <br>        TCHAR * argv[])     // command line arguments <br>{ <br>    HRESULT     hr          =   NOERROR; <br>HRESULThrT=NOERROR;// temporary return code <br>    FILETIME    sBeforeTime =   {0};    // before date/time structure <br>    TCHAR       lpProfile[MAX_PATH+1]   =   ""; // GW profile name <br>    TCHAR       lpPSTName[MAX_PATH+1]   =   ""; // PST file name <br>    TCHAR       lpFolder[MAX_PATH+1]    =   ""; // GW folder name <br>HANDLEhEvent=NULL;// event logging handle <br>EDKEVENTCOUNTsEventCount={0};// event log count structure <br>BOOLfEventLogOpened=FALSE;// TRUE if event log is open <br>    TCHAR           szErrorCode[16]         =   {0}; <br> <br>    // Special base class which guarantees that MAPI is <br>    // unitialized when it goes out of scope. <br>    BOOL        fInitialized    =   FALSE;  // TRUE if MAPI is initialized <br> <br>    DEBUGPUBLIC("main()\n"); <br> <br>    // check command line arguments <br>    hr = CHK_main(argc, argv); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // This should never happen <br>MODULE_ERROR("Arguments to main() invalid"); <br>        return _nEcFromHr(hr); <br>    } <br> <br>// Open the NT event log for this application. <br> hr = HrEventOpenLog( <br>pszAppName,// application name <br>NULL,// executable name (computed) <br>    NULL,// event message file (computed) <br>NULL,// parameter message file <br>NULL,// category message file <br>&amp;hEvent);// event logging handle <br> <br>if ( FAILED(hr) ) <br>{ <br>DisplayUserMsg( <br>IDS_EVENT_LOG, <br>hr); <br> <br>goto cleanup; <br>} <br> <br>ASSERTERROR((hEvent != NULL), "Bad hEvent"); <br> <br>fEventLogOpened = TRUE; <br> <br>    // Instantiate a GWCLEAN object. <br>    lpCGWClean = new CGWClean(); <br> <br>    if ( !lpCGWClean ) <br>    { <br>EventLogMsg( <br>GWCLEAN_OUTOFMEMORY, <br>0,// # of string replacements <br>0);// # of Win32 error arguments <br> <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    // Parse command line arguments.  The syntax is: <br>    // <br>    // GWCLEAN &lt;GWProfileName&gt; -FILE=&lt;PSTName&gt; -DAYS=&lt;#days&gt; -FOLDER=&lt;folder&gt; <br>    // <br>    // where PSTName is a fully-pathed file name, #days <br>    // is a positive integer representing the number of days before <br>    // today for which to move all gateway &lt;folder&gt; messages which were <br>    // sent on before that date, and GWProfileName is the name of an <br>    // gateway profile. <br>    // <br>    hr = HrParseCommandLine(argc, argv, <br>            lpProfile,      // GW profile name <br>            lpPSTName,      // PST file name <br>            lpFolder,       // GW folder name <br>            &amp;sBeforeTime);  // before time pointer <br> <br>    if ( FAILED(hr) ) <br>    {    <br>        // User errors are displayed in HrParseCommandLine() <br>        goto cleanup; <br>    } <br> <br>    // Initialize use of extended MAPI. <br>    hr = MAPIInitialize(NULL); <br> <br>    if ( FAILED(hr) ) <br>    { <br>EventLogMsg( <br>GWCLEAN_MAPIINIT, <br>1, _itot( hr, szErrorCode, 16), <br>0); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    fInitialized = TRUE; // MAPI is initialized <br> <br>    // Initialize our CGWClean class instance.  This <br>    // function takes care of creating the new PST, logging <br>    // on to the gateway and temporary profiles, etc... <br>    hr = lpCGWClean-&gt;HrInitialize( <br>    lpProfile, <br>        lpPSTName, <br>        lpFolder, <br>        &amp;sBeforeTime); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // User messages are taken care of in HrInitialize(). <br>        goto cleanup; <br>    } <br> <br>    // Move messages in GW MTS-OUT folder before date/time to <br>    // new PST folder. <br>    hr = lpCGWClean-&gt;HrMoveMsgs(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // user messages displayed in HrMoveMsgs <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>// If doing event logging <br>if ( fEventLogOpened == TRUE ) <br>{ <br>// Retrieve number of errors and warnings written to the event log. <br>ZeroMemory(&amp;sEventCount, sizeof(sEventCount)); <br>hrT = HrEventGetCounts( <br>&amp;sEventCount);// structure to hold event logging statistics <br> <br>if ( FAILED(hrT) ) <br>{ <br>            INTERNAL_ERROR( TEXT("HrEventGetCounts()"), hrT); <br>sEventCount.cError = 1;// have at least one error <br>} <br> <br>if ( sEventCount.cError == 1 ) <br>{ <br>// print one error message <br>DisplayUserMsg( <br>IDS_1ERROR); <br>} <br> <br>else if ( sEventCount.cError &gt; 1 ) <br>{ <br>// print multiple error message <br>DisplayUserMsg( <br>IDS_ERRORS); <br>} <br> <br>if ( sEventCount.cWarning == 1 ) <br>{ <br>// print out one warning message <br>DisplayUserMsg( <br>IDS_1WARNING); <br>} <br> <br>else if ( sEventCount.cWarning &gt; 1 ) <br>{ <br>// print out multiple warnings message <br>DisplayUserMsg( <br>IDS_WARNINGS); <br>} <br> <br>// close event log <br>(VOID)HrEventCloseLog(); <br>hEvent = NULL; <br>fEventLogOpened = FALSE; <br> <br>}// end if doing event logging <br>  <br>    if ( lpCGWClean ) <br>    {         <br>        // delete gwclean object. <br>        // A side effect of this is that all MAPI objects are freed <br>        // and all sessions are logged off. <br>        delete lpCGWClean; <br> <br>    }   // end if lpCGWClean <br> <br>    if ( fInitialized ) <br>    { <br>        // Unitialize MAPI <br>        (VOID)MAPIUninitialize(); <br>    } <br> <br>    // We are done. <br>    // return the appropriate exit code <br>    return _nEcFromHr(hr); <br>         <br>}   // end main() <br> <br>//$--HrParseCommandLine--------------------------------------- <br>// <br>// DESCRIPTION: Parse GWCLEAN command line <br>// <br>// INPUT:   argc    --  argument count <br>//          argv    --  list of arguments <br>// <br>// OUTPUT:  lpProfile   --  GW profile name pointer (MAX_PATH + 1 character buffer) <br>//          lpPSTName   --  PST file name (MAX_PATH + 1 character buffer) <br>//          lpFolder    --  GW folder name (MAX_PATH + 1 character buffer) <br>//          pnDays      --  #days before pointer <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input <br>//                      E_FAIL otherwise <br>// <br>// ------------------------------------------------------------ <br>HRESULT HrParseCommandLine(                     // RETURNS: HRESULT <br>                    IN INT argc,                // argument count <br>                    IN TCHAR * argv[],          // list of arguments <br>                    OUT LPTSTR lpProfile,      // GW profile name <br>                    OUT LPTSTR lpPSTName,      // PST name <br>                    OUT LPTSTR lpFolder,       // GW folder name <br>                    OUT LPFILETIME lpBeforeTime)// before time pointer <br>{ <br>    HRESULT     hr          =   NOERROR; <br>    LPTSTR      lpData      =   NULL;       // pointer to flag data <br>    LPTSTR      lpFlag      =   NULL;       // pointer to flag name <br>    ULONG       iFlag       =   0;          // flag index <br>    INT         iArg        =   0;          // argument index <br>    UINT        nDays       =   0;          // number of days before today <br>    BOOL        fDaysFound  =   FALSE;      // TRUE if user specifies DAYS flag <br>    LPTSTR      lpTemp      =   0;          // temporary string pointer <br>    UINT        cchExeName  =   0;          // # characters in executable name <br>    DWORD       dwRetVal    =   0;          // Win32 API return code <br> <br>    // fully-pathed module file name <br>    TCHAR       lpszExeName[MAX_PATH + 1]   = TEXT(""); <br> <br>    // default values <br>    TCHAR       lpszPath[MAX_PATH + 1]      = TEXT(""); // default path <br>    TCHAR       lpszPSTName[MAX_PATH + 1]   = TEXT(""); // default PST name <br> <br>    const LPTSTR    lpszFolder  =   TEXT("MTS-OUT");        // gw folder <br>    const UINT      nDefDays    =   1;                      // #days <br> <br>    const TCHAR     chBackSlash =   TEXT('\\');             // back slash <br>    const LPTSTR    lpszPSTExt  =   TEXT("PST");             // PST extension <br>    const LPTSTR    lpszEXEExt  =   TEXT("EXE");            // EXE extension <br> <br>    // argument indices into the argument flag array <br>    const UINT      iHelp1      =   0;                      // HELP index <br>    const UINT      iHelp2      =   1;                      // HELP index <br>    const UINT      iDays       =   2;                      // DAYS index <br>    const UINT      iFile       =   3;                      // FILE index <br>    const UINT      iFolder     =   4;                      // FOLDER index <br> <br>    // # of command line flags <br>    const ULONG     nFlags      =   5;                       <br> <br>    // Array of known flags for this program. <br>    const LPCTSTR rgpszFlags[nFlags]  = <br>    { <br>        TEXT("HELP"),   // help flag <br>        TEXT("?"),      // help flag <br>        TEXT("DAYS"),   // # days before today flag <br>        TEXT("FILE"),   // PST file name flag <br>        TEXT("FOLDER")  // gateway folder name flag <br>    }; <br> <br>    DEBUGPRIVATE("HrParseCommandLine()\n"); <br> <br>    hr = CHK_HrParseCommandLine(argc, argv, <br>                    lpProfile, lpPSTName, lpFolder, lpBeforeTime); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // If no arguments are passed in, print the syntax <br>    // message <br>    if ( argc &lt; 2 ) <br>    { <br>        DisplayUserMsg( <br>                IDS_USAGE); <br>        DisplayUserMsg( <br>                IDS_BLANK); <br>        DisplayUserMsg( <br>                IDS_USAGEPROF); <br>        DisplayUserMsg( <br>                IDS_USAGEDAYS); <br>        DisplayUserMsg( <br>                IDS_USAGEPST); <br>        DisplayUserMsg( <br>                IDS_USAGEFOLDER); <br>        DisplayUserMsg( <br>                IDS_USAGEHELP); <br>                 <br>        hr = HR_LOG(E_INVALIDARG); <br>         <br>        goto cleanup;     <br>    } <br> <br>    // Build the default default PST file <br>    // name from the fully-pathed executable name. <br>    dwRetVal = GetModuleFileName( <br>                NULL,      // module handle (default is current application) <br>                lpszExeName,    // string buffer <br>                MAX_PATH);      // maximum length <br> <br>    if ( dwRetVal == 0 ) <br>    { <br>        INTERNAL_ERROR( TEXT("GetModuleFileName()"), dwRetVal); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cchExeName = lstrlen(lpszExeName);  // # characters in executable name <br>    lstrcpy(lpszPSTName, lpszExeName); <br> <br>    // Replace the EXE extension with the PST extension. <br>    lpTemp = lpszPSTName + (cchExeName - lstrlen(lpszEXEExt)); <br>    lstrcpy(lpTemp, <br>            lpszPSTExt); <br> <br>    // Retrieve the default path name <br>    lstrcpy(lpszPath, lpszExeName); <br>     <br>    // Strip off the executable name. <br>    lpTemp = lpszPath + (cchExeName - 1); <br>    while ( *lpTemp != chBackSlash ) <br>    { <br>        if ( lpTemp == lpszPath ) <br>        { <br>            // back at the beginning.  This is an error. <br>            INTERNAL_ERROR( TEXT("HrParseCommandLine()"), E_FAIL); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br> <br>        }   // if can't find back slash <br> <br>        lpTemp--; <br> <br>    }   // end while <br> <br>    // When we get to here, lpTemp is pointing to the back slash. <br>    *(lpTemp + 1) = 0;  // null terminate path <br> <br>    // loop throught the command line arguments <br>    // Start with the first user-supplied argument <br>    for ( iArg = 1; iArg &lt; argc; iArg++ ) <br>    { <br>        hr = _HrExpandCommandLineArgument( <br>            argv[iArg],     // argument user entered <br>            (LPTSTR *) rgpszFlags,     // array of recognized switches <br>            nFlags,         // number of known flags <br>            &amp;iFlag,         // pointer to flag index into array <br>            &amp;lpFlag,        // pointer to flag name <br>            &amp;lpData);       // pointer to flag data <br>         <br>        if ( FAILED(hr) ) <br>        { <br>            if ( hr == EDK_E_NOT_FOUND ) <br>            { <br>                // Bad command line argument. <br>                // Display error message. <br>                DisplayUserMsg( <br>                    IDS_PARAMERR); <br> <br>                hr = HR_LOG(E_INVALIDARG); <br>             <br>                goto cleanup; <br>            } <br> <br>            else <br>            { <br>                INTERNAL_ERROR( TEXT("_HrExpandCommandLineArgument()"), hr); <br>                                     <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        }             <br> <br>        if ( (lpFlag == NULL) &amp;&amp; (*lpData != 0) ) <br>        { <br>            // This should be the gateway profile name <br>            // (The profile name doesn't have a flag.) <br>            lstrcpyn(lpProfile, lpData, MAX_PATH); <br> <br>            continue;   // go on to next argument <br>        } <br> <br>        // We have a valid flag.  Copy the data <br>        // to the appropriate parameter and test it. <br>        switch ( iFlag ) <br>        { <br>            case iHelp1: <br>            case iHelp2: <br>                // user wants help message. <br>                // Print it out. <br>                DisplayUserMsg( <br>                        IDS_HELPDESCR); <br>                DisplayUserMsg( <br>                        IDS_BLANK); <br>                DisplayUserMsg( <br>                        IDS_USAGE); <br>                DisplayUserMsg( <br>                        IDS_BLANK); <br>                DisplayUserMsg( <br>                        IDS_USAGEPROF); <br>                DisplayUserMsg( <br>                        IDS_HELPDAYS1); <br>                DisplayUserMsg( <br>                        IDS_HELPDAYS2); <br>                DisplayUserMsg( <br>                        IDS_HELPDAYS3); <br>                DisplayUserMsg( <br>                        IDS_HELPDAYS4); <br>                DisplayUserMsg( <br>                        IDS_HELPDAYS5); <br>                DisplayUserMsg( <br>                        IDS_USAGEPST); <br>                DisplayUserMsg( <br>                        IDS_HELPPST); <br>                DisplayUserMsg( <br>                        IDS_USAGEFOLDER); <br>                DisplayUserMsg( <br>                        IDS_HELPFOLDER); <br>                DisplayUserMsg( <br>                        IDS_HELPHELP); <br> <br>                hr = HR_LOG(E_INVALIDARG); <br> <br>                goto cleanup; <br> <br>            case iDays: <br>                // Check number of days variable <br>                if ( (lpData == NULL) || (*lpData == 0) ) <br>                { <br>                    // Bad command line argument. <br>                    // Display error message. <br>                    DisplayUserMsg( <br>                        IDS_BADDAYS); <br> <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    goto cleanup; <br>                } <br> <br>                // Make sure number of days is a valid decimal <br>                // number less than or equal to 9999. <br>                if ( lstrlen(lpData) &gt; 4 ) <br>                { <br>                    // number of days is greater than 9999. <br>                    DisplayUserMsg(  <br>                            IDS_BADDAYS); <br> <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    goto cleanup; <br>                } <br> <br>                // check individual characters of days value <br>                lpTemp = lpData; <br>                while ( *lpTemp ) <br>                { <br>                    if ( ! isdigit(*lpTemp) ) <br>                    { <br>                        // number of days is not a non-negative <br>                        // integer! <br>                        DisplayUserMsg(  <br>                            IDS_BADDAYS); <br> <br>                        hr = HR_LOG(E_INVALIDARG); <br> <br>                        goto cleanup; <br>                    } <br> <br>                    lpTemp++; <br> <br>                }   // end while <br> <br>                // Try to convert #days to an integer. <br>                nDays = atoi(lpData); <br> <br>                fDaysFound = TRUE;  // user specified DAYS value <br> <br>                break; <br>         <br>            case iFile: <br>                // check PST output file name <br>                if ( (lpData == NULL) || (*lpData == 0) ) <br>                { <br>                    // invalid file name. <br>                    DisplayUserMsg(  <br>                            IDS_NOFILE); <br> <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    goto cleanup; <br>                } <br> <br>                // Save PST file name <br>                if ( strchr(lpData, chBackSlash) == NULL ) <br>                { <br>                    lstrcpyn(lpPSTName, lpszPath, MAX_PATH); <br>                    strncat(lpPSTName, lpData, MAX_PATH); <br>                } <br>                 <br>                else <br>                { <br>                    // already have full path <br>                    lstrcpyn(lpPSTName, lpData, MAX_PATH); <br>                } <br> <br>                break; <br> <br>            case iFolder: <br>                // check gateway folder name <br>                if ( (lpData == NULL) || (*lpData == 0) ) <br>                { <br>                    // invalid folder name. <br>                    DisplayUserMsg(  <br>                            IDS_NOFOLDER); <br> <br>                    hr = HR_LOG(E_INVALIDARG); <br> <br>                    goto cleanup; <br>                } <br> <br>                // save folder name <br>                lstrcpyn(lpFolder, lpData, MAX_PATH); <br> <br>                // let open folder call determine if its a valid <br>                // folder name. <br> <br>                break; <br> <br>            default:                 <br>                // shouldn't happen! <br>                INTERNAL_ERROR( TEXT("HrParseCommandLine()"), E_FAIL); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br> <br>        }   // end switch <br>    }   // end for <br> <br>    // Check required parameters <br>    if ( *lpProfile == 0 ) <br>    { <br>        DisplayUserMsg(  <br>                   IDS_NOPROFILE); <br> <br>        hr = HR_LOG(E_INVALIDARG); <br> <br>        goto cleanup; <br>    } <br>         <br>    // Handle default values. <br>    if ( !fDaysFound ) <br>    { <br>        // use default days value (yesterday) <br>        nDays = nDefDays; <br>    } <br> <br>    // Convert # days to a data and time. <br>    hr = HrComputeDate(nDays, lpBeforeTime); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrComputeDate()"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>    if ( *lpFolder == 0 ) <br>    { <br>        // use default folder. <br>        lstrcpyn(lpFolder, lpszFolder, MAX_PATH);  <br>    } <br> <br>    if ( *lpPSTName == 0 ) <br>    { <br>        // use default PST name <br>        lstrcpyn(lpPSTName, lpszPSTName, MAX_PATH); <br>    } <br> <br>    // Check to see if this file is valid <br>    // and can be created or overwritten <br>    hr = HrCheckFileName(lpPSTName); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // HrCheckFileName prints out error <br>        // messages. <br>        goto cleanup; <br>    } <br> <br>    // We are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrCheckFileName---------------------------------------------- <br>// <br>// DESCRIPTION: Checks to see if file exists.  If it does <br>//              prompts user as to whether or not to overwrite <br>//              it.  If file is valid file name and can be over-written, <br>//              returns NOERROR.  Otherwise, returns E_FAIL. <br>// <br>// INPUT:   lpFileName  --  file name to test for existence <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_FAIL otherwise. <br>// <br>// --------------------------------------------------------------- <br>HRESULT HrCheckFileName(           // RETURNS: HRESULT <br>            IN LPTSTR lpFileName)   // file name to check <br>{ <br>    HRESULT hr                  =   NOERROR; <br>    HANDLE  hFile               =   NULL;   // file handle <br>    DWORD   dwLastError         =   0;      // last Win32 error <br>    TCHAR   szLine[MAX_PATH]    =   {0};    // large input buffer <br> <br>    DEBUGPRIVATE("HrCheckFileName()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCheckFileName(lpFileName); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    hFile = CreateFile(lpFileName,  <br>                GENERIC_READ | GENERIC_WRITE,   <br>                0,  <br>                0, <br>                CREATE_NEW,  <br>                FILE_ATTRIBUTE_NORMAL,  <br>                0); <br> <br>    if ( hFile == INVALID_HANDLE_VALUE ) <br>    { <br>        dwLastError = GetLastError();   // Get windows error code <br>        if ( dwLastError == ERROR_FILE_EXISTS ) <br>        { <br>            // File already exists.  Ask user is he/she wants to <br>            // overwrite it. <br>            while ( hFile == INVALID_HANDLE_VALUE ) <br>            { <br>                DisplayUserMsg(  <br>                        IDS_OVERWRITEFILE, <br>                        lpFileName); <br> <br>                if ( gets(szLine) == NULL ) <br>                { <br>                    INTERNAL_ERROR( TEXT("gets()"), GetLastError()); <br> <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                switch ( szLine[0] ) <br>                { <br>                    case TEXT('Y'): <br>                    case TEXT('y'): <br>                        // overwrite the file. <br>                        hFile = CreateFile(lpFileName,  <br>                                           GENERIC_READ | GENERIC_WRITE,  <br>                                           0,  <br>                                           0, <br>                                           TRUNCATE_EXISTING,  <br>                                           FILE_ATTRIBUTE_NORMAL,  <br>                                           0); <br> <br>                        if ( hFile == INVALID_HANDLE_VALUE ) <br>                        { <br>                            DisplayUserMsg(  <br>                            IDS_OUTPUTERR, <br>                                lpFileName); <br> <br>                            hr = HR_LOG(E_FAIL); <br> <br>                            goto cleanup; <br>                        } <br> <br>                        break; <br> <br>                    case TEXT('n'): <br>                    case TEXT('N'): <br>                        // Give up! <br>                        DisplayUserMsg(  <br>                            IDS_USERCANCEL); <br> <br>                        // This is not really an error.  The user <br>                        // just wishes to terminate the program early. <br>                        hr = HR_LOG(E_FAIL); <br> <br>                        goto cleanup; <br> <br>                    default: <br>                        // ask again! <br>                        continue; <br> <br>                }   // end switch  <br>            }   // end while <br>        }   // end if file already exits. <br> <br>        else <br>        { <br>            // some other file path or permission-type error <br>            DisplayUserMsg(  <br>                    IDS_OUTPUTERR,  <br>                    lpFileName); <br> <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>    }   // end if can't create new file <br> <br>    // O.K. to overwrite file. <br>    // Delete the file just created. <br>    if ( hFile != INVALID_HANDLE_VALUE ) <br>    { <br>        CLOSEHANDLE(hFile); <br> <br>        (VOID)DeleteFile(lpFileName); <br>    } <br> <br>cleanup: <br> <br>    // close the opened file. <br>    CLOSEHANDLE(hFile); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--DisplayUserMsg---------------------------------------------------------- <br>// <br>// DESCRIPTION: Utility to display message to command line user. <br>// <br>// INPUT: UINT        --  Resource string identifier <br>// <br>// NOTES:       This function can handle up to nine variable string arguments. <br>//  <br>// RETURNS:     nothing <br>// <br>// ---------------------------------------------------------------------------- <br> <br>VOID DisplayUserMsg(            // RETURNS: VOID <br>            IN UINT nResID,     // resource string identifier <br>            ...)                // additional arguments <br>{     <br>    INT     nRetCode= 0;          // return value <br>    va_list vArgList=   {0};        // variable argument list <br>static HMODULEhInst=NULL;// application handle <br>staticBOOLfInit=FALSE;// TRUE if hInst is initialized <br> <br>    const   INT cbMsgLength=   256;        // maximum length of printed messageso <br> <br>// LoadString message buffer <br>    TCHAR   szMessage[cbMsgLength]=   TEXT("");  <br> <br>    DEBUGPRIVATE("DisplayUserMsg()\n"); <br> <br>    // No CHK_DisplayUserMsg() call. <br>    // We check arguments as we go, as we are already in an error state. <br> <br>    // Check the instance handle passed in. <br>    if ( fInit == FALSE ) <br>    { <br>// Retrieve this applications module handle. <br>hInst = GetModuleHandle(NULL); <br> <br>fInit = TRUE; <br> <br>if ( hInst == NULL ) <br>{ <br>        // Print out default error string. <br>        fprintf(stderr, "ERROR: Can't dipslay resource strings.\n"); <br> <br>        HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>} <br> <br>if ( hInst == NULL ) <br>{ <br>// nothing to do <br>goto cleanup; <br>} <br> <br>    nRetCode = LoadString(hInst, nResID, szMessage, cbMsgLength); <br> <br>    if ( nRetCode == 0 ) <br>    { <br>        // Print out default error string. <br>        fprintf(stderr, "ERROR: Can't load resource string %d.\n", nRetCode); <br> <br>        HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // Get an optional argument list pointer <br>    va_start(vArgList, nResID); <br> <br>    // Print the message to standard out <br>    _vtprintf(szMessage,        // format string <br>            vArgList);          // variable argument list <br> <br>    va_end(vArgList); <br> <br>cleanup: <br> <br>    // Return <br>    return; <br> <br>}   // end DisplayUserMsg() <br> <br>//$--HrComputeDate----------------------------------------------------------- <br>// <br>// DESCRIPTION: Computes the date of today minus the number of days passed <br>//              in and fills in the file time structure buffer passed in. <br>// <br>// OUTPUT:      lpSysFileTime   --  pointer to file time buffer <br>// <br>// RETURNS:     HRESULT --  NOERROR if O.K., <br>//                          E_INVALIDARG if bad input. <br>// <br>// --------------------------------------------------------------------------- <br> <br>static HRESULT HrComputeDate(                      // RETURNS: HRESULT <br>            IN  UINT uDaysBack,             // number of days before today <br>            OUT LPFILETIME lpSysFileTime)   // pointer to system file time <br>{ <br>    HRESULT     hr              =   NOERROR;    // return code <br>    INT         iCounter        =   0;          // loop counter <br>    SYSTEMTIME  sLocalSysTime   =   {0};        // Local system time structure </code></pre>
<p>
</p>
<pre><code>FILETIME    sLocalFileTime  =   {0};        // Local file time structure     <br>    DWORDLONG   dwlFileTime     =   0;          // file time converted to DWORDLONG <br> <br>    const DWORDLONG dwlNum100nsPerDay = 864000000000; // number of 100 nanoseconds in one day! <br> <br>    DEBUGPRIVATE("HrComputeDate\n"); <br> <br>    hr = CHK_HrComputeDate(uDaysBack, lpSysFileTime); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Compute desired system time of the before date/time variable <br>    // before which all gateway MTS-OUT messages are to be moved. <br>    // Algorithm: <br>    //  1) Today's date and time. <br>    //  2) Modify <br>    // from # days before today parameter passed in by user. <br>    // First, get the current system time and adjust it to the end <br>    // of today and convert that to a FILETIME value.  Then, convert the <br>    // FILETIME value to a DWORDLONG (64 bit) value. <br>    GetLocalTime(&amp;sLocalSysTime);    // Get local time <br>    sLocalSysTime.wHour = 23; <br>    sLocalSysTime.wMinute = 59; <br>    sLocalSysTime.wSecond = 59; <br>    sLocalSysTime.wMilliseconds = 999; <br>    if ( sLocalSysTime.wDayOfWeek ) <br>    { <br>        sLocalSysTime.wDayOfWeek--; <br>    } <br>    else <br>    { <br>        sLocalSysTime.wDayOfWeek = 6;    // Sunday to Saturday <br>    } <br>    SystemTimeToFileTime(&amp;sLocalSysTime, &amp;sLocalFileTime);   // local time to local file time <br>    LocalFileTimeToFileTime(&amp;sLocalFileTime, lpSysFileTime);   // local file time to system file time <br>    dwlFileTime = ((DWORDLONG)((DWORDLONG) lpSysFileTime-&gt;dwLowDateTime) | <br>        (DWORDLONG)(((DWORDLONG)(((DWORDLONG)lpSysFileTime-&gt;dwHighDateTime) &lt;&lt; 32)) &amp; 0xFFFFFFFF00000000)); <br> <br>    // Subtract off the desired number of 100 nanoseconds from this mornings <br>    // time. <br>    // (The FILETIME structure measures time in 100 nanoseconds intervals.) <br>    // Then, convert this value back to a FILETIME value. <br>    dwlFileTime -= (DWORDLONG)(((DWORDLONG) uDaysBack) * dwlNum100nsPerDay); <br>    lpSysFileTime-&gt;dwLowDateTime = (DWORD) dwlFileTime; <br>    lpSysFileTime-&gt;dwHighDateTime =  <br>        (DWORD) (((DWORDLONG) (dwlFileTime &gt;&gt; 32)) &amp; 0xFFFFFFFF); <br> <br>    RETURN(hr); <br> <br>}   // end HrComputeDate() <br> <br>/* <br> * EOF <br> */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
