<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GWOBJCLS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1794"></a>GWOBJCLS.CPP</h2>
<pre><code>// --gwobjcls.cpp------------------------------------------------------------- <br>// <br>// Class source file for the GWCLEAN class object. <br>// <br>// Copyright (C) Microsoft Corporation 1986-1996,  All Rights Reserved <br>// <br>// ---------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "mspst.h" <br> <br>#include "gwstring.h" <br>#include "gwobjcls.h" <br>#include "gwevents.h"// compiled from gwevents.mc <br>#include "gwobjcls.chk" <br> <br>// external function declarations <br>extern VOID DisplayUserMsg(// RETURNS: VOID <br>IN UINT uResID,// resource string identifier <br> ...);// additional arguments <br> <br>extern inline VOID INTERNAL_ERROR( <br>    IN LPCTSTR str, <br>    IN const HRESULT hr); <br> <br>//$--CGWClean::CGWClean---------------------------------------- <br>// <br>// DESCRIPTION: constructor for CGWClean <br>// <br>// INPUT:   none <br>// <br>// RETURNS: nothing <br>// <br>// ------------------------------------------------------------- <br>CGWClean::CGWClean()        // returns nothing <br>{ <br>    DEBUGPRIVATE("CGWClean::CGWClean()\n"); <br> <br>    // Initialize data members. <br>    m_fNewPST           =   FALSE; <br>    m_fNoMessages       =   FALSE; <br>    m_lpProfileName     =   NULL; <br>    m_lpPSTName         =   NULL; <br>    m_lpFolderName      =   NULL; <br>    m_lpBeforeDateTime  =   NULL; <br>    m_lpTempProfilePW   =   NULL; <br>    m_lpTempProfName    =   NULL; <br>    m_lpSessGW          =   NULL; <br>    m_lpSessNew         =   NULL; <br>    m_lpMDBGateway      =   NULL; <br>    m_lpMDBNew          =   NULL; <br>    m_lpFolderFrom      =   NULL; <br>    m_lpFolderTo        =   NULL; <br> <br>} <br> <br>//$--CGWClean::~CGWClean----------------------------------------------------- <br>// <br>// DESCRIPTION: CGWClean Destructor <br>// <br>// --------------------------------------------------------------------------- <br> <br>CGWClean::~CGWClean() <br>{     <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("CGWClean::~CGWClean()\n"); <br> <br>    if ( m_lpMDBGateway ) <br>    { <br>        // Set the PR_TRANSFER_ENABLED property so that message <br>        // transfer activity resumes on the gateway. <br>        hr = HrMAPISetPropBoolean( <br>                m_lpMDBGateway,         // MAPI object pointer <br>                PR_TRANSFER_ENABLED,    // property tag <br>                TRUE);                  // boolean value <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("HrMAPISetPropBoolean()"), hr); <br>        } <br>    } <br> <br>    // clean up after PST creation.  (Removes temporary profile) <br>    if ( m_fNewPST ) <br>    { <br>        (VOID)HrCleanupPSTGlobals(m_lpTempProfName); <br> <br>        // If there were no messages to move, delete the <br>        // PST created. <br>        if ( m_fNoMessages ) <br>        { <br>            (VOID)DeleteFile(m_lpPSTName); <br>        } <br>    } <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(m_lpTempProfilePW); <br>    MAPIFREEBUFFER(m_lpTempProfName); <br> <br>    // Release MAPI store and folder objects <br>    ULRELEASE(m_lpMDBGateway); <br>    ULRELEASE(m_lpMDBNew); <br>    ULRELEASE(m_lpFolderFrom); <br>    ULRELEASE(m_lpFolderTo); <br> <br>    // Logoff any MAPI sessions to which we are logged on. <br>    if ( m_lpSessGW ) <br>    { <br>        (VOID)m_lpSessGW-&gt;Logoff(0, 0, 0); <br>    } <br> <br>    if ( m_lpSessNew ) <br>    { <br>        (VOID)m_lpSessNew-&gt;Logoff(0, 0, 0); <br>    } <br> <br>    // Release MAPI session objects if they have not already been released. <br>    ULRELEASE(m_lpSessGW); <br>    ULRELEASE(m_lpSessNew); <br> <br>    // Delete m_lpBeforeDateTime buffer. <br>    if ( m_lpBeforeDateTime ) <br>    { <br>        delete m_lpBeforeDateTime; <br>    } <br> <br>}   // end CGWClean::~CGWClean(); <br> <br>//$--CGWClean::HrInitialize------------------------------------------------------- <br>// <br>// DESCRIPTION: CGWClean initializer.  Creates profile, <br>//              establishes sessions, opens default stores, <br>//              opens from and to folders. <br>// <br>// INPUT:   lpProfileName   --  gateway profile name <br>//          lpPSTName  --  new PST name <br>//          lpFolder    --  gateway folder name <br>//          lpBeforeDate  --  date/time before which to move messages <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_OUTOFMEMORY if memory problems, <br>//                      E_FAIL otherwise <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT CGWClean::HrInitialize( <br>             IN LPTSTR lpProfileName,       // gateway profile name <br>             IN LPTSTR lpPSTName,           // New PST name <br>             IN LPTSTR lpFolderName,        // gateway folder name <br>             IN LPFILETIME lpBeforeTime)    // date/time before which to move messages <br>{ <br>    HRESULT hr      =   NOERROR; <br>    ULONG   cbEid   =   0;          // number of bytes in entry identifier <br>    TCHAR   szErrorCode[16] = {0}; <br> <br>    // Special MAPI buffer base class which frees itself <br>    // when it goes out of scope. <br>    LPENTRYID   lpEid   =   NULL;   // entry identifier pointer <br> <br>    // MAPI session flags <br>    const ULONG ulFlags =   MAPI_EXPLICIT_PROFILE | <br>                            MAPI_NEW_SESSION | <br>                            MAPI_NO_MAIL; <br> <br>    // new PST PR_DISPLAY_NAME value <br>    const LPTSTR   lpszDisplayName =   TEXT("Mailbox - GWCLEAN"); <br> <br>    // Separator in folder name. <br>    const TCHAR     cSeparator  =   TEXT('\\'); <br> <br>    // message database store flags <br>    const ULONG     ulMDBflags  =   MDB_NO_DIALOG | MDB_WRITE; <br> <br>    DEBUGPRIVATE("CGWClean::HrInitialize()\n"); <br> <br>    hr = CHK_CGWClean_HrInitialize(lpProfileName,  <br>                                 lpPSTName, lpFolderName, lpBeforeTime); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Initialize class members <br>    m_lpProfileName = lpProfileName; <br>    m_lpPSTName = lpPSTName; <br>    m_lpFolderName = lpFolderName; <br> <br>    m_lpBeforeDateTime = new FILETIME; <br> <br>    if( !TEST_WRITE_PTR( m_lpBeforeDateTime, sizeof(FILETIME)) ) <br>    { <br>        EventLogMsg(  <br>        GWCLEAN_OUTOFMEMORY, <br>        0, <br>        0); <br> <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    m_lpBeforeDateTime-&gt;dwHighDateTime = lpBeforeTime-&gt;dwHighDateTime; <br>    m_lpBeforeDateTime-&gt;dwLowDateTime = lpBeforeTime-&gt;dwLowDateTime; <br> <br>    // Open session to gateway. <br>    hr = MAPILogonEx(0,   // UI flags, <br>                m_lpProfileName,    // profile name <br>                NULL,               // password <br>                ulFlags,            // MAPI flags <br>                &amp;m_lpSessGW); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        EventLogMsg(  <br>                GWCLEAN_PROFILEERR,  <br>2, m_lpProfileName, _itot( hr, szErrorCode, 16), <br>                0); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Create the new PST and temporary profile. <br>    hr = HrCreatePersonalStore( <br>                        m_lpPSTName,            // fully-pathed PST name <br>                        PSTF_NO_ENCRYPTION,     // type of encryption <br>                        (LPTSTR) lpszDisplayName,        // PST PR_DISPLAY_NAME value <br>                        TEXT(""),               // PST password <br>                        &amp;m_lpTempProfName,      // temporary profile name <br>                        &amp;m_lpTempProfilePW);    // temporary profile password <br> <br>    if ( FAILED(hr) ) <br>    { <br>        EventLogMsg( <br>        GWCLEAN_NEWPSTERR, <br>2, m_lpPSTName, _itot( hr, szErrorCode, 16), <br>            0); <br> <br>        goto cleanup; <br>    } <br> <br>    // Have created a new PST. <br>    m_fNewPST = TRUE; <br> <br>    // Log onto the PST's temporary profile <br>    hr = MAPILogonEx(0,       // UI flags <br>                m_lpTempProfName,   // temporary profile name <br>                m_lpTempProfilePW,  // temporary profile password <br>                ulFlags,            // MAPI flags, <br>                &amp;m_lpSessNew); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        EventLogMsg(  <br>                GWCLEAN_PROFILEERR,  <br>2, m_lpTempProfName, _itot( hr, szErrorCode, 16), <br>                0); <br> <br>        hr = HR_LOG(E_FAIL); <br>     <br>        goto cleanup; <br>    } <br> <br>    // Open gateway's default message store. <br>    // Find the default MDB message store in the gateway profile. <br>    hr = HrMAPIFindDefaultMsgStore(m_lpSessGW,    // session pointer <br>                                 &amp;cbEid,        // count of bytes in entry ID <br>                                 &amp;lpEid);       // entry id pointer for default store <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrMAPIFindDefaultMsgStore()"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>    // Open the gateway's default message store. <br>    hr = m_lpSessGW-&gt;OpenMsgStore(0,        // window handle <br>                                  cbEid,    // # of bytes in entry ID <br>                                  lpEid,    // pointer to entry ID <br>                                  NULL,     // interface ID pointer <br>                                  ulMDBflags, // flags <br>                                  &amp;m_lpMDBGateway);   // output ptr to store <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMAPISession::OpenMsgStore()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Set the PR_TRANSFER_ENABLED property so that we don't <br>    // get any activity on the gateway. <br>    hr = HrMAPISetPropBoolean( <br>            m_lpMDBGateway,         // MAPI object pointer <br>            PR_TRANSFER_ENABLED,    // property tag <br>            FALSE);                 // boolean value <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrMAPISetPropBoolean()"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>    // Free gateway message store entry ID buffer <br>    MAPIFREEBUFFER(lpEid); <br> <br>    // Open PST temporary profile's default message store. <br>    // Find the default MDB message store in the gateway profile <br>    // first <br>    hr = HrMAPIFindDefaultMsgStore(m_lpSessNew,   // session pointer <br>                                 &amp;cbEid,        // count of bytes in entry ID <br>                                 &amp;lpEid);       // entry id pointer for default store <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("HrMAPIFindDefaultMsgStore()"), hr); <br> <br>        goto cleanup; <br>    } <br> <br>    // Open the gateway's default message store. <br>    hr = m_lpSessNew-&gt;OpenMsgStore(0,       // window handle <br>                                  cbEid,    // # of bytes in entry ID <br>                                  lpEid,    // pointer to entry ID <br>                                  NULL,     // interface ID pointer <br>                                  ulMDBflags, // flags <br>                                  &amp;m_lpMDBNew);   // output ptr to store <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMAPISession::OpenMsgStore()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Open desired folder in gateway. <br>    hr = HrMAPIOpenFolderEx( <br>            m_lpMDBGateway,     // message store pointer <br>            cSeparator,         // folder path separator <br>            m_lpFolderName,     // folder path <br>            &amp;m_lpFolderFrom); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        EventLogMsg( <br>        GWCLEAN_BADFOLDER, <br>3, <br>            m_lpFolderName, <br>            m_lpProfileName, <br>            _itot( hr, szErrorCode, 16), <br>            0); <br> <br>        goto cleanup; <br>    } <br> <br>    // Create GWCLEAN folder in PST. <br>    hr = HrCreatePSTFolder(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // We are now ready to move messages from the open <br>    // gateway folder to the open PST folder. <br>    // We are done with our initialization. <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpEid); <br>     <br>    RETURN(hr); <br> <br>}   // end CGWClean::HrInitialize() <br> <br>//$--CGWClean::HrCreatePSTFolder----------------------------------------------- <br>// <br>// DESCRIPTION: Create a new folder in the new PST and <br>//              open it. <br>// <br>// RETURNS:     HRESULT   --  NOERROR if successful <br>//                            E_FAIL otherwise. <br>//  <br>// --------------------------------------------------------------------------- <br> <br>HRESULT CGWClean::HrCreatePSTFolder()         // RETURNS: HRESULT <br>{ <br>    HRESULT hr          =   NOERROR;    // MAPI return code <br>    ULONG   ulObjType   =   0;          // object type <br> <br>#ifdef USE_MAPIWRAP <br>    // Special MAPI object base classes which release <br>    // object when they goe out of scope. <br>    CMAPIInterface&lt;LPMAPIFOLDER&gt;    lpRootFolder;   // PST root folder <br>    CMAPIInterface&lt;LPMAPIFOLDER&gt;    lpTopOfStore;   // top of personal folders in PST <br>#else <br>    LPMAPIFOLDER    lpRootFolder    =   NULL;   // PST root folder pointer <br>    LPMAPIFOLDER    lpTopOfStore    =   NULL;   // top of PST personal folders <br>#endif <br> <br>    // top of store folder name for PST. <br>    const LPTSTR   lpszTopOfStoreName  =   TEXT("Top of Personal Folders"); <br> <br>    // Folder to which gateway messages are copied <br>    const LPTSTR   lpszGWCLEAN =   TEXT("GWCLEAN"); <br> <br>    DEBUGPRIVATE("CGWClean::HrCreatePSTFolder()\n"); <br> <br>    // consistency checks <br>    ASSERT_IUNKNOWN_PTR( m_lpMDBNew, "Bad m_lpMDBNew"); <br> <br>    // Find the new PST's root folder. <br>    hr = m_lpMDBNew-&gt;OpenEntry(0,     // # of bytes in entry ID <br>                                  NULL,  // ptr to entry ID <br>                                  NULL,  // interface ID pointer <br>                                  MAPI_MODIFY | MAPI_DEFERRED_ERRORS, // flags <br>                                  &amp;ulObjType,       // object type pointer <br>                (LPUNKNOWN *) &amp;lpRootFolder);       // output ptr to folder <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMsgStore::OpenEntry()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR( ulObjType == MAPI_FOLDER, "Bad ulObjType"); <br> <br>    // Create the new PST's Top of Personal Folders folder. <br>    hr = lpRootFolder-&gt;CreateFolder( <br>                FOLDER_GENERIC,    // folder type <br>                (LPTSTR) lpszTopOfStoreName,  // folder name <br>                NULL,        // folder comment <br>                NULL,        // interface ID pointer <br>                OPEN_IF_EXISTS | MAPI_DEFERRED_ERRORS,  // flags <br>                &amp;lpTopOfStore); // new folder pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // Check for insufficient disk space. <br>        if ( hr == MAPI_E_NOT_ENOUGH_DISK ) <br>        { <br>            EventLogMsg(  <br>                GWCLEAN_OUTOFDISK, <br>                0, <br>                0); <br> <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>        }                         <br> <br>        else <br>        { <br>            INTERNAL_ERROR( TEXT("IMAPIFolder::CreateFolder()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>        } <br>    }// end if creation of folder failed <br> <br>    // Create the new PST's GWCLEAN folder (under the Top of Personal Folders folder). <br>    // All gateway messages will be moved into this folder <br>    hr = lpTopOfStore-&gt;CreateFolder( <br>                FOLDER_GENERIC,  // folder type <br>                (LPTSTR) lpszGWCLEAN, // folder name <br>                NULL,        // folder comment <br>                NULL,        // interface ID pointer <br>                OPEN_IF_EXISTS | MAPI_DEFERRED_ERRORS,  // flags <br>                &amp;m_lpFolderTo); // new folder pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // Check for insufficient disk space. <br>        if ( hr == MAPI_E_NOT_ENOUGH_DISK ) <br>        { <br>            EventLogMsg(  <br>                GWCLEAN_OUTOFDISK, <br>                0, <br>                0); <br> <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>        } <br> <br>        else <br>        { <br>            INTERNAL_ERROR( TEXT("IMAPIFolder::CreateFolder()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>        } <br>    }// end if creation of folder fails <br> <br>cleanup: <br> <br>    ULRELEASE(lpTopOfStore); <br>    ULRELEASE(lpRootFolder); <br> <br>    // Base classes take care of releasing MAPI objects <br>    // and freeing MAPI memory. <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CGWClean::HrMoveMsgs------------------------------------------------------ <br>// <br>// DESCRIPTION: Move messages from gateways MTS-OUT folder to PSTs MTS-OUT folder. <br>// <br>// RESULT:      HRESULT   --  NOERROR if successful, <br>//                            EDK_E_NOT_FOUND if no messages to move, <br>//                            E_FAIL otherwise. <br>//  <br>// --------------------------------------------------------------------------- <br> <br>HRESULT CGWClean::HrMoveMsgs()         // RETURNS: HRESULT  <br>{ <br>    HRESULT hr  =   NOERROR;        // MAPI return code <br>    LPMAPITABLE lpContentsTable =   NULL;   // contents table for gateway MTS-OUT folder <br>    LPENTRYLIST lpEidList   =   NULL;       // list of entry identifiers to move <br>    LPENTRYLIST lpSearchKeyList =   NULL;   // list of search key identifiers for messages copied <br>    SizedSPropTagArray(2, SPropEntryIDs);   // property tag array containing only PR_ENTRY_ID and PR_SEARCH_KEY <br>    SRestriction    sRestriction    =   {0};// Property restriction structure <br>    SPropValue  sPropValue  =   {0};        // Property value structure <br>    LPSRowSet   lpMsgRows   =   NULL;       // Row pointer corresponding to a message <br>    ULONG       ulMsgCount  =   0;          // count of messages moved <br>    SYSTEMTIME  sSysTime    =   {0};        // local system time structure <br>    FILETIME    sLocalFileTime  =   {0};    // local file time structure <br>    TCHAR   szDateTimeString[80]    =   {0};// before date time string <br>    ULONG   ulCount =   0;                  // loop counter <br>    ULONG   ulNumBytes  =   0;              // size of entry identifier <br>    LPBYTE  lpEid   =   NULL;               // entry ID pointer for message <br>    TCHAR   szErrorCode[16] = {0};          // buffer for error code strings <br> <br>    DEBUGPRIVATE("CGWCLEAN::HrMoveMsgs()\n"); <br> <br>    // Consistency checking <br>    ASSERT_IUNKNOWN_PTR( m_lpFolderFrom, "Bad m_lpFolderFrom"); <br>    ASSERT_IUNKNOWN_PTR( m_lpFolderTo, "Bad m_lpFolderTo"); <br> <br>    // Get the contents table for the gateway's MTS-OUT folder. <br>    hr = m_lpFolderFrom-&gt;GetContentsTable( <br>                MAPI_DEFERRED_ERRORS,  // flags <br>                &amp;lpContentsTable);  // Contents table pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMAPIFolder::GetContentsTable()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR((lpContentsTable != NULL), "Bad lpContentsTable"); <br> <br>    // Get a list of all desired message IDs from the contents table. <br>    // First, call SetColumns to chose the PR_ENTRY_ID column and <br>    // PR_SEARCH_KEY columns.  (PR_SEARCH_KEY is the transmittable, <br>    // unique identifier of the message.) <br>    SPropEntryIDs.cValues = 2; <br>    SPropEntryIDs.aulPropTag[0] = PR_ENTRYID; <br>    SPropEntryIDs.aulPropTag[1] = PR_SEARCH_KEY; <br> <br>    hr = lpContentsTable-&gt;SetColumns((LPSPropTagArray) (&amp;SPropEntryIDs),    // Properties desired <br>                                     0);            // flags <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMAPITable::SetColumns()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Make a call here to Restrict to restrict the rows in the table returned <br>    // to be those where the PR_CREATION_TIME property is less than <br>    // the desired "before" date. <br> <br>    ASSERTERROR((m_lpBeforeDateTime != NULL), "Bad m_lpBeforeDateTime"); <br> <br>    sPropValue.ulPropTag    =   PR_CREATION_TIME; <br>    sPropValue.Value.ft.dwLowDateTime = m_lpBeforeDateTime-&gt;dwLowDateTime; <br>    sPropValue.Value.ft.dwHighDateTime = m_lpBeforeDateTime-&gt;dwHighDateTime; <br> <br>    sRestriction.rt                         = RES_PROPERTY; <br>    sRestriction.res.resProperty.relop      = RELOP_LT; <br>    sRestriction.res.resProperty.ulPropTag  = PR_CREATION_TIME; <br>    sRestriction.res.resProperty.lpProp     = &amp;sPropValue; <br> <br>    hr = lpContentsTable-&gt;Restrict(&amp;sRestriction, 0); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMAPITable::Restrict()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Let user know that we are starting the copy. <br>    // (Convert the FILETIME value to a string for easy <br>    // display to the user.) <br>    FileTimeToLocalFileTime(m_lpBeforeDateTime, &amp;sLocalFileTime); // system file time to local file time <br>    FileTimeToSystemTime(&amp;sLocalFileTime, &amp;sSysTime);  // local file time to local system time <br>    wsprintf(szDateTimeString, TEXT("%d:%d:%d.%d %d/%d/%d"), sSysTime.wHour, <br>            sSysTime.wMinute, sSysTime.wSecond, sSysTime.wMilliseconds, <br>            sSysTime.wMonth, sSysTime.wDay, sSysTime.wYear); <br> <br>    ASSERT_STRING_PTR( szDateTimeString, "Bad szDateTimeString"); <br> <br>    DisplayUserMsg(  <br>    IDS_STARTMOVE,  <br>        szDateTimeString,  <br>        m_lpProfileName,  <br>        m_lpPSTName); <br> <br>    // Build a list of entry identifiers for the messages which match <br>    // our criteria. <br>    while ( TRUE ) <br>    { <br>        // Free the MAPI structures (SRowSet is special!) <br>        FREEPROWS(lpMsgRows); <br> <br>        // Free EDK structures. <br>        if ( lpEidList ) <br>        { <br>            HrMAPIDestroyEntryList(&amp;lpEidList); <br>            lpEidList = NULL; <br>        } <br> <br>        if ( lpSearchKeyList ) <br>        { <br>            HrMAPIDestroyEntryList(&amp;lpSearchKeyList); <br>            lpSearchKeyList = NULL; <br>        } <br> <br>        // Retrieve the row (messages) in the table which meet our <br>        // selection criteria in EDK_MAX_QUERY_ROWS chunks (1024 at a time). <br>        hr = lpContentsTable-&gt;QueryRows(EDK_MAX_QUERY_ROWS, // count to return <br>                                        0,                  // flags <br>                                        &amp;lpMsgRows);        // returned row structure pointer <br> <br>        switch (hr) <br>        { <br>            case MAPI_W_POSITION_CHANGED: <br>                // Location in table changed by somebody else. <br>                // Warn the user. <br>                EventLogMsg(  <br>                GWCLEAN_POSCHANGED, <br>                0, <br>                0); <br> <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br> <br>            default: <br>                if ( FAILED(hr) ) <br>                { <br>                    INTERNAL_ERROR( TEXT("IMAPITable::QueryRows()"), hr); <br> <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                break; <br> <br>        }   // end switch <br> <br>        ASSERTERROR((lpMsgRows != NULL), "Bad lpMsgRows"); <br> <br>        // Check to see if any messages to process. <br>        if ( !lpMsgRows-&gt;cRows ) <br>        { <br>            // If no messages found at all, let user know. <br>            if ( !ulMsgCount ) <br>            { <br>                EventLogMsg(  <br>                GWCLEAN_NOMSGS, <br>1, <br>                    szDateTimeString, <br>                    0); <br> <br>                hr = HR_LOG(EDK_E_NOT_FOUND); <br> <br>                // Set no messages flag <br>                m_fNoMessages = TRUE; <br> <br>                goto cleanup; <br>            } <br> <br>            // Otherwise, we are done! <br>            break; <br>        } <br> <br>        // Add message identifiers for messages returned to our list of <br>        // entry IDs. <br>        ulMsgCount += lpMsgRows-&gt;cRows;  // increment message count <br>         <br>        for ( ulCount = 0; ulCount &lt; lpMsgRows-&gt;cRows; ulCount++ ) <br>        { <br>            ASSERTERROR(lpMsgRows-&gt;aRow[ulCount].cValues == 2, <br>                "Bad lpMsgRows-&gt;aRow[].cValues"); <br>            ASSERTERROR(lpMsgRows-&gt;aRow[ulCount].lpProps[0].ulPropTag == PR_ENTRYID, <br>                "Bad lpMsgRows-&gt;aRows[].lpProps[0].ulPropTag"); <br>            ASSERTERROR(lpMsgRows-&gt;aRow[ulCount].lpProps[1].ulPropTag == PR_SEARCH_KEY, <br>                "Bad lpMsgRows-&gt;aRows[].lpProps[1].ulPropTag"); <br> <br>            ulNumBytes = lpMsgRows-&gt;aRow[ulCount].lpProps[0].Value.bin.cb; <br>            lpEid = lpMsgRows-&gt;aRow[ulCount].lpProps[0].Value.bin.lpb; <br> <br>            // Add entry identifier to the entry ID list. <br>            if ( !lpEidList ) <br>            { <br>                // Create new entry identifier list. <br>                hr = HrMAPICreateEntryList(ulNumBytes, (LPENTRYID) lpEid, &amp;lpEidList);                 <br> <br>            if ( FAILED(hr) ) <br>            { <br>                    INTERNAL_ERROR( TEXT("HrMAPICreateEntryList()"), hr); <br> <br>                goto cleanup; <br>            } <br>            } <br>            else <br>            { <br>                hr = HrMAPIAppendEntryList(ulNumBytes, (LPENTRYID) lpEid, lpEidList); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                    INTERNAL_ERROR( TEXT("HrMAPIAppendEntryList()"), hr); <br> <br>                goto cleanup; <br>            } <br>            } <br> <br>            ASSERTERROR((lpEidList != NULL), "Bad lpEidList"); <br> <br>            ulNumBytes = lpMsgRows-&gt;aRow[ulCount].lpProps[1].Value.bin.cb; <br>            lpEid = lpMsgRows-&gt;aRow[ulCount].lpProps[1].Value.bin.lpb; <br> <br>            // Add seach key identifier for search key list. <br>            if ( !lpSearchKeyList ) <br>            { <br>                // Create new search key list. <br>                hr = HrMAPICreateEntryList(ulNumBytes, (LPENTRYID) lpEid, &amp;lpSearchKeyList);                 <br> <br>            if ( FAILED(hr) ) <br>            { <br>                    INTERNAL_ERROR( TEXT("HrMAPICreateEntryList()"), hr); <br> <br>                goto cleanup; <br>            } <br>            } <br>            else <br>            { <br>                hr = HrMAPIAppendEntryList(ulNumBytes, (LPENTRYID) lpEid, lpSearchKeyList); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                    INTERNAL_ERROR( TEXT("HrMAPIAppendEntryList()"), hr); <br> <br>                goto cleanup; <br>            } <br>            } <br> <br>            ASSERTERROR((lpSearchKeyList != NULL), "Bad lpSearchKeyList"); <br> <br>        }   // end for <br> <br>        ASSERTERROR((lpEidList != NULL), "Bad lpEidList");  // just in case! <br>        ASSERTERROR((lpSearchKeyList != NULL), "Bad lpSearchKeyList"); <br>         <br>        // Copy messages from gateway MTS-OUT folder to new PST's MTS-OUT <br>        // folder. <br>        hr = m_lpFolderFrom-&gt;CopyMessages(lpEidList,  // list of message IDs <br>                                        &amp;IID_IMAPIFolder,   // interface ID of destination folder <br>                                        m_lpFolderTo,  // destination folder ptr <br>                                        0,  // window handle <br>                                        0,  // progress dialogue handle <br>                                        MAPI_DECLINE_OK );   // flags <br> <br>        switch (hr) <br>        { <br>            case MAPI_E_DECLINE_COPY: <br>                // Provider doesn't support CopyMessages function. <br>                // Warn the user. <br>                EventLogMsg(  <br>                GWCLEAN_NOCOPYMSGS, <br>                0, <br>                0); <br> <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br> <br>            case MAPI_E_NOT_ENOUGH_DISK: <br>                // insufficient disk space. <br>                EventLogMsg(  <br>                GWCLEAN_OUTOFDISK, <br>                0, <br>                0); <br> <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br> <br>            case MAPI_W_PARTIAL_COMPLETION: <br>                // Couldn't copy all messages. <br>                // Warn the user. <br>                EventLogMsg(  <br>                GWCLEAN_PARTIALCOPY, <br>                1, _itot( hr, szErrorCode, 16), <br>                0); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br> <br>            default: <br>                if ( FAILED(hr) ) <br>                { <br>                    INTERNAL_ERROR( TEXT("IMAPIFolder::CopyMessages()"), hr); <br> <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                break; <br> <br>        }   // end switch <br> <br>        // Copy the extra gateway message properties not copied via CopyMessages <br>        // from the old messages to the new messages. <br>        hr = HrCopyGWMessageProps(lpEidList, lpSearchKeyList); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Now, delete messages moved from gateway MTS-OUT folder to the <br>        // new PST MTS-OUT folder. <br>        // Delete copied messages from gateway's MTS-OUT folder. <br>        hr = m_lpFolderFrom-&gt;DeleteMessages(lpEidList,  // entry identifier list <br>                                              0,          // window handle <br>                                              0,          // progress dialog <br>                                              0);         // flags <br> <br>        switch (hr) <br>        { <br>            case MAPI_W_PARTIAL_COMPLETION: <br> <br>                EventLogMsg(  <br>                GWCLEAN_PARTIALDEL, <br>                1, _itot( hr, szErrorCode, 16), <br>                0); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br> <br>            case MAPI_E_HAS_FOLDERS: <br>            case MAPI_E_SUBMITTED: <br> <br>                EventLogMsg(  <br>                GWCLEAN_PARTIALDEL, <br>                1, _itot( hr, szErrorCode, 16), <br>                0); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br> <br>            default: <br>                if ( FAILED(hr) ) <br>                { <br>                    INTERNAL_ERROR( TEXT("IMAPIFolder::DeleteMessages()"), hr); <br> <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } </code></pre>
<p>
</p>
<pre><code><br>                break; <br> <br>        }   // end switch <br>    }   // end while messages to copy <br> <br>    // We have done it! <br>    // Display a successful completion message and log event. <br>    EventLogMsg(  <br>    GWCLEAN_SUCCESS, <br>1, _itot( ulMsgCount, szErrorCode, 10), <br>0); <br> <br>DisplayUserMsg( <br>IDS_SUCCESS, <br>ulMsgCount); <br> <br>cleanup: <br> <br>    // Free EDK structures. <br>    if ( lpEidList ) <br>    { <br>        HrMAPIDestroyEntryList(&amp;lpEidList); <br>    } <br> <br>    if ( lpSearchKeyList ) <br>    { <br>        HrMAPIDestroyEntryList(&amp;lpSearchKeyList); <br>    } <br> <br>    // Free MAPI structures (SRowSet is special!) <br>    FREEPROWS(lpMsgRows); <br> <br>    // Release MAPI objects. <br>    ULRELEASE(lpContentsTable); <br> <br>    RETURN(hr); <br> <br>}   // end CGWClean::MoveMsgs() <br> <br>//$--CGWClean::HrCopyGWMessageProps-------------------------------------------- <br>// <br>// DESCRIPTION: Copy the gateway message (envelope) properties not copied by CopyMessages <br>//              from the gateway messages to the new PST messages. <br>//              The additional properties copied are determined <br>//              in HrCreateNewProps(). <br>// <br>// INPUT:       LPENTRYLIST --  list of entry identifiers of messages copied. <br>//              LPENTRYLIST --  list of search key identifiers of messages copied. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br> <br>HRESULT CGWClean::HrCopyGWMessageProps(                   // RETURNS: HRESULT <br>                        IN LPENTRYLIST lpEidList,       // entry identifiers <br>                        IN LPENTRYLIST lpSearchKeyList) // search keys <br>{ <br>    HRESULT hr  =   NOERROR;        // return code <br>    LPMESSAGE   lpMessage   =   NULL;       // original message pointer (envelope) <br>    LPMESSAGE   lpNewMessage    =   NULL;   // copied message pointer   (envelope) <br>    ULONG       ulObjType   =   0;          // MAPI object type <br>    LPMAPITABLE lpContentsTable =   NULL;   // contents table pointer for new MTS-OUT folder <br>    SRestriction    sRestriction    =   {0};// Property restriction structure <br>    SPropValue  sPropValue  =   {0};        // Property value structure <br>    LPSRowSet   lpMsgRows   =   NULL;       // Row pointer corresponding to a message <br>    SizedSPropTagArray(2, SPropEntryIDs);   // property tag array containing only PR_ENTRY_ID and PR_SEARCH_KEY <br>    ULONG   ulLoopCounter   =   0;              // loop counter <br>    ULONG   ulDupEidSize    =   0;              // duplicate message entry ID size <br>    LPBYTE  lpDupEid    =   NULL;               // duplicate message's search key <br>    ULONG   ulTempIndex =   0;                  // temporary index <br>    BOOL    bDupDone    =   FALSE;              // Duplicate done flag <br>    LPENTRYLIST lpDoneList  =   NULL;       // duplicates done list <br> <br>    DEBUGPRIVATE("CGWClean::HrCopyGWMessageProps()\n"); <br> <br>    hr = CHK_CGWClean_HrCopyGWMessageProps(lpEidList, lpSearchKeyList); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // consistency checking <br>    ASSERT_IUNKNOWN_PTR( m_lpFolderTo, "Bad m_lpFolderTo"); <br>    ASSERT_IUNKNOWN_PTR( m_lpFolderFrom, "Bad m_lpFolderFrom"); <br> <br>    // Get the contents table for the new MTS-OUT folder. <br>    hr = m_lpFolderTo-&gt;GetContentsTable(0,  // flags <br>                                             &amp;lpContentsTable);  // Contents table pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMAPFolder::GetContentsTable()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Call SetColumns to chose the PR_ENTRY_ID column and <br>    // PR_SEARCH_KEY columns for the new table.  (PR_SEARCH_KEY is the transmittable, <br>    // unique identifier of the message.) <br>    SPropEntryIDs.cValues = 2; <br>    SPropEntryIDs.aulPropTag[0] = PR_ENTRYID; <br>    SPropEntryIDs.aulPropTag[1] = PR_SEARCH_KEY; <br> <br>    hr = lpContentsTable-&gt;SetColumns((LPSPropTagArray) (&amp;SPropEntryIDs),    // Properties desired <br>                                     0);            // flags <br> <br>    if ( FAILED(hr) ) <br>    {   <br>        INTERNAL_ERROR( TEXT("IMAPITable::SetColumns()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Handle each message in the list     <br>    for ( ulLoopCounter = 0; ulLoopCounter &lt; lpEidList-&gt;cValues; ulLoopCounter++ ) <br>    {     <br>        // Release the MAPI objects. <br>        ULRELEASE(lpMessage); <br> <br>        // Free the MAPI structures (SRowSet is special!) <br>        FREEPROWS(lpMsgRows); <br> <br>        // Print out a . for every message to be copied. <br>        _puttchar(TEXT('.')); <br> <br>        // Open original message envelope. <br>        hr = m_lpFolderFrom-&gt;OpenEntry( <br>                            lpEidList-&gt;lpbin[ulLoopCounter].cb,  // # of bytes in entry ID <br>                            (LPENTRYID) (lpEidList-&gt;lpbin[ulLoopCounter].lpb),// entry ID pointer <br>                            &amp;IID_IMessage,  // interface ID pointer <br>                            0,              // flags <br>                            &amp;ulObjType,     // object type <br>                            (LPUNKNOWN FAR *) &amp;lpMessage);    // output pointer to message <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("IMAPIFolder::OpenEntry()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        ASSERT_IUNKNOWN_PTR( lpMessage, "Bad lpMessage"); <br>        ASSERTERROR(ulObjType == MAPI_MESSAGE, "Bad ulObjType"); <br> <br>        // Go about finding the corresponding new message <br> <br>        // Make a call to find the row in the new folder's table  <br>        // where the PR_SEARCH_KEY property is equal to the  <br>        // PR_SEARCH_KEY property of the original message. <br>        sPropValue.ulPropTag    =   PR_SEARCH_KEY; <br>        sPropValue.Value.bin.cb =   lpSearchKeyList-&gt;lpbin[ulLoopCounter].cb; <br>        sPropValue.Value.bin.lpb =  lpSearchKeyList-&gt;lpbin[ulLoopCounter].lpb; <br> <br>        sRestriction.rt                         = RES_PROPERTY; <br>        sRestriction.res.resProperty.relop      = RELOP_EQ; <br>        sRestriction.res.resProperty.ulPropTag  = PR_SEARCH_KEY; <br>        sRestriction.res.resProperty.lpProp     = &amp;sPropValue; <br> <br>        hr = lpContentsTable-&gt;Restrict(&amp;sRestriction, 0); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("IMAPITable::Restrict()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Retrieve the row(s) from the new table which meet the <br>        // selection criteria. <br>        hr = lpContentsTable-&gt;QueryRows(lpEidList-&gt;cValues, // maximum count to return <br>                                        0,                  // flags <br>                                        &amp;lpMsgRows);        // returned row structure pointer <br> <br>        switch (hr) <br>        { <br>            case MAPI_W_POSITION_CHANGED: <br>                // Location in table changed by somebody else. <br>                // Warn the user. <br>                EventLogMsg(  <br>                GWCLEAN_POSCHANGED, <br>                0, <br>                0); <br> <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br> <br>            default: <br>                if ( FAILED(hr) ) <br>                { <br>                    INTERNAL_ERROR( TEXT("IMAPITable::QueryRows()"), hr); <br> <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                break; <br> <br>        }   // end switch <br> <br>        ASSERT_READ_PTR( lpMsgRows, sizeof(SRowSet), "Bad lpMsgRows"); <br> <br>        ASSERTERROR( lpMsgRows-&gt;cRows, <br>            "Bad lpMsgRows-&gt;cRows"); // should be at least one match <br>        ASSERTERROR(lpMsgRows-&gt;aRow[0].cValues == 2, <br>            "Bad lpMsgRows-&gt;aRow[0].cValues"); <br>        ASSERTERROR(lpMsgRows-&gt;aRow[0].lpProps[0].ulPropTag == PR_ENTRYID, <br>            "Bad lpMsgRows-&gt;aRow[0].lpProps[0].ulPropTag"); <br>        ASSERTERROR(lpMsgRows-&gt;aRow[0].lpProps[1].ulPropTag == PR_SEARCH_KEY, <br>            "Bad lpMsgRows-&gt;aRow[0].lpProps[1].ulPropTag"); <br> <br>        // If this message has duplicates, see if we have already <br>        // handled them before.  If so, continue on to next message <br>        // in list. <br>        if ( lpMsgRows-&gt;cRows &gt; 1 ) <br>        { <br>            ulDupEidSize = lpMsgRows-&gt;aRow[0].lpProps[1].Value.bin.cb; <br>            lpDupEid = lpMsgRows-&gt;aRow[0].lpProps[1].Value.bin.lpb; <br> <br>            // if this search key is in the done list, go to the <br>            // next message.  Otherwise, add it to the done list and <br>            // handle its duplicates. <br>            if ( !lpDoneList ) <br>            { <br>                // Create done list and <br>                // record this search key in the done list. <br>                hr = HrMAPICreateEntryList(ulDupEidSize, <br>                                          (LPENTRYID) lpDupEid, <br>                                          &amp;lpDoneList); <br>                 <br>                if ( FAILED(hr) ) <br>                { <br>                    INTERNAL_ERROR( TEXT("HrMAPICreateEntryList()"), hr); <br> <br>                    goto cleanup; <br>                } <br>            } <br> <br>            else <br>            { <br>                // look for search key in done list. <br>                for ( ulTempIndex = 0, bDupDone = FALSE;  <br>                      ulTempIndex &lt; lpDoneList-&gt;cValues; ulTempIndex++ ) <br>                { <br>                    if ( memcmp(lpDupEid, lpDoneList-&gt;lpbin[ulTempIndex].lpb, ulDupEidSize) == 0 ) <br>                    { <br>                        // This duplicate has already been done. <br>                        bDupDone = TRUE; <br>                        break; <br>                    } <br> <br>                }   // end for <br> <br>                // If message's duplicates already handled, continue <br>                if ( bDupDone ) <br>                { <br>                    continue;   // go do next message <br>                } <br> <br>                // Otherwise, add this message's search key to the done list. <br>                hr = HrMAPIAppendEntryList(ulDupEidSize, <br>                                          (LPENTRYID) lpDupEid, <br>                                          lpDoneList); <br>                 <br>                if ( FAILED(hr) ) <br>                { <br>                    INTERNAL_ERROR( TEXT("HrMAPIAppendEntryList()"), hr); <br> <br>                    goto cleanup; <br>                } <br> <br>            }   // end if <br>        }   // end if message has duplicates <br> <br>        // Handle extra properties for message's duplicates <br>        ULONG ulDupCount;   // duplicate count <br>        for (ulDupCount = 0; ulDupCount &lt; lpMsgRows-&gt;cRows; ulDupCount++ ) <br>        {         <br>            // Open corresponding new message envelope. <br>            hr = m_lpFolderTo-&gt;OpenEntry( <br>                        lpMsgRows-&gt;aRow[ulDupCount].lpProps[0].Value.bin.cb,    // # of bytes in entry ID <br>                        (LPENTRYID) lpMsgRows-&gt;aRow[ulDupCount].lpProps[0].Value.bin.lpb,   // entry ID pointer <br>                        &amp;IID_IMessage,  // interface ID pointer <br>                        MAPI_MODIFY | MAPI_DEFERRED_ERRORS,    // flags <br>                        &amp;ulObjType,     // object type <br>                        (LPUNKNOWN FAR *) &amp;lpNewMessage);    // output pointer to message <br> <br>            if ( FAILED(hr) ) <br>            { <br>                INTERNAL_ERROR( TEXT("IMAPIFolder::OpenEntry()"), hr); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            ASSERT_IUNKNOWN_PTR( lpNewMessage, "Bad lpNewMessage"); <br>            ASSERTERROR(ulObjType == MAPI_MESSAGE, "Bad ulObjType"); <br> <br>            // If not all properties were copied to the new message <br>            // by IMAPIFolder::CopyMessages(), <br>            // create those properties in the new message now. <br>            hr = HrCreateNewProps(lpMessage, lpNewMessage); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Copy over the properties from the original message (envelope <br>            // attachment) to the new message (envelope attachment). <br>            hr = HrCopyGWAttachProps(lpMessage, lpNewMessage); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                goto cleanup; <br>            } <br> <br>            // Save changes to new message. <br>            hr = lpNewMessage-&gt;SaveChanges(KEEP_OPEN_READWRITE); <br>         <br>            if ( FAILED(hr) ) <br>            { <br>                // check for insufficient disk space <br>                if ( hr == MAPI_E_NOT_ENOUGH_DISK ) <br>                { <br>                    EventLogMsg(  <br>                    GWCLEAN_OUTOFDISK, <br>                    0, <br>                    0); <br> <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>                } <br> <br>else <br>{ <br>                    INTERNAL_ERROR( TEXT("IMAPIProp::SaveChanges()"), hr); <br> <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>            }// end if save changes failure <br> <br>            // Release new message MAPI object. <br>            ULRELEASE(lpNewMessage); <br> <br>        }   // end for all duplicates <br>    }   // end for <br> <br>    // We are done copying the extra gateway message properties. <br> <br>cleanup: <br> <br>    // Release MAPI objects. <br>    ULRELEASE(lpContentsTable); <br>    ULRELEASE(lpMessage); <br>    ULRELEASE(lpNewMessage); <br> <br>    // SRowSet is special! <br>    FREEPROWS(lpMsgRows); <br> <br>    // Free done list <br>    if ( lpDoneList ) <br>    { <br>        HrMAPIDestroyEntryList(&amp;lpDoneList); <br>    } <br>     <br>    RETURN(hr); <br> <br>}   // end CGWClean::CopyGWMessageProps() <br> <br>//$--CGWClean::HrCopyGWMessageProps---------------------------------------------------- <br>// <br>// DESCRIPTION: Recursively copy the gateway message &amp; attachment (message)  <br>//              properties not copied by CopyMessages <br>//              from the gateway messages to the new PST messages. <br>//              The additional properties copied are <br>//              determined in HrCreateNewProps(). <br>// <br>// INPUT:       LPMESSAGE --  Original message pointer <br>//              LPMESSAGE --  New message pointer <br>// <br>// RESULT:      HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br> <br>HRESULT CGWClean::HrCopyGWAttachProps(              // RETURNS: HRESULT <br>                        IN LPMESSAGE lpParent,      // original message pointer <br>                        IN LPMESSAGE lpNewParent)   // new message pointer <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br>    LPMAPITABLE lpAttachTable   =   NULL;   // Original message's attachment table <br>    LPMAPITABLE lpNewAttachTable    =   NULL;   // new message's attachment table <br>    LPMESSAGE   lpMessage   =   NULL;       // Original message (envelope attachment) <br>    LPMESSAGE   lpNewMessage    =   NULL;   // New message (envelope attachment) <br>    ULONG   ulCount =   0;                  // count <br>    LPSRowSet   lpRows  =   NULL;           // old message QueryRows return <br>    LPSRowSet   lpNewRows   =   NULL;       // new message QueryRows return <br>    ULONG   ulAttachNum =   0;              // old message attachment index <br>    ULONG   ulNewAttachNum  =   0;          // new message attachment index <br>    LPATTACH    lpAttachment    =   NULL;   // Original attachment <br>    LPATTACH    lpNewAttachment =   NULL;   // new attachment <br>    ULONG       ulLoopCounter   =   0;      // loop counter <br>    LPBYTE  lpSearchKey =   NULL;           // old search key <br>    LPBYTE  lpSearchKeyNew  =   NULL;       // new search key <br>    ULONG   ulCountNew  =   0; <br>    BOOL    bFound  =   FALSE;              // True if find corresponding attachment <br>    ULONG   ulLoopCount2    =   0;          // inner loop counter <br> <br>    SizedSPropTagArray(1, sPropAttachNum)   =   // PR_ATTACH_NUM property tag array <br>    { <br>        1,  // number of properties <br>        { <br>            PR_ATTACH_NUM   // property tag <br>        } <br>    }; <br> <br>    DEBUGPRIVATE("CGWClean::HrCopyGWAttachProps()\n"); <br> <br>    hr = CHK_CGWClean_HrCopyGWAttachProps(lpParent, lpNewParent); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Open the message's attachments table. <br>    hr = lpParent-&gt;GetAttachmentTable(0, &amp;lpAttachTable); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMessage::GetAttachmentTable()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = lpNewParent-&gt;GetAttachmentTable(0, &amp;lpNewAttachTable); <br>     <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMessage::GetAttachmentTable()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br>         <br>    ASSERT_IUNKNOWN_PTR( lpAttachTable, "Bad lpAttachTable"); <br>    ASSERT_IUNKNOWN_PTR( lpNewAttachTable, "Bad lpNewAttachTable"); <br> <br>    // Retrieve all the attachments for this message.  This function is now <br>    // called recursively to handle all message attachments. <br>    hr = HrQueryAllRows( <br>            lpAttachTable,  // original attachment table <br>            (LPSPropTagArray) &amp;sPropAttachNum,  // only want PR_ATTACH_NUM columns <br>            NULL,           // restriction pointer <br>            NULL,           // sort order set pointer <br>            0,              // maximum rows--defaults to all <br>            &amp;lpRows); <br> <br>    switch (hr) <br>    { <br>        case MAPI_W_POSITION_CHANGED: <br>            // Location in table changed by somebody else. <br>            // Warn the user. <br>            EventLogMsg(  <br>            GWCLEAN_POSCHANGED, <br>            0, <br>            0); <br> <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup;  <br> <br>        default: <br>            if ( FAILED(hr) ) <br>            { <br>                INTERNAL_ERROR( TEXT("HrQueryAllRows()"), hr); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            break; <br> <br>    }   // end switch() <br> <br>    ASSERT_READ_PTR( lpRows, sizeof(SRowSet), "Bad lpRows"); <br>     <br>    // If there are no attachments for this message, <br>    // we are done.  Return! <br>    if ( !(lpRows-&gt;cRows) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Get all the attachments for the new envelope. <br>    hr = HrQueryAllRows( <br>            lpNewAttachTable,   // new message attachment table <br>            (LPSPropTagArray) &amp;sPropAttachNum,  // only want PR_ATTACH_NUM columns <br>            NULL,               // restriction pointer <br>            NULL,               // sort order set pointer <br>            0,                  // maximum rows--defaults to all <br>            &amp;lpNewRows); <br> <br>    switch (hr) <br>    { <br>        case MAPI_W_POSITION_CHANGED: <br>            // Location in table changed by somebody else. <br>            // Warn the user. <br>            EventLogMsg(  <br>                GWCLEAN_POSCHANGED, <br>            0, <br>            0); <br> <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup;  <br> <br>        default: <br>            if ( FAILED(hr) ) <br>            { <br>                INTERNAL_ERROR( TEXT("HrQueryAllRows()"), hr); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>        break; <br> <br>    }   // end switch() <br> <br>    ASSERT_READ_PTR( lpNewRows, sizeof(SRowSet), "Bad lpNewRows"); <br>    ASSERTERROR(lpNewRows-&gt;cRows == lpRows-&gt;cRows, "Bad lpNewRows count"); <br> <br>    // Handle each attachment <br>    for ( ulLoopCounter = 0; ulLoopCounter &lt; lpRows-&gt;cRows; ulLoopCounter++ ) <br>    { <br>        // Release MAPI objects <br>        ULRELEASE(lpMessage); <br>        ULRELEASE(lpAttachment); <br> <br>        // Get entry identifier information for attachment. <br>        ulAttachNum = lpRows-&gt;aRow[ulLoopCounter].lpProps[0].Value.ul; <br> <br>        // Open the attachment specified by the entry identifier. <br>        hr = lpParent-&gt;OpenAttach( <br>                                    ulAttachNum,  <br>                                    0,  <br>                                    MAPI_DEFERRED_ERRORS,   // reduces RPCs <br>                                    &amp;lpAttachment); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("IMessage::OpenAttach()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        ASSERT_IUNKNOWN_PTR( lpAttachment, "Bad lpAttachment"); <br> <br>        // Try to open the attachment as a message. <br>        hr = lpAttachment-&gt;OpenProperty(PR_ATTACH_DATA_OBJ, <br>                                    &amp;IID_IMessage,  // interface identifier <br>                                    0, <br>                                    MAPI_DEFERRED_ERRORS,  // reduces RPCs <br>                                    (LPUNKNOWN FAR *) &amp;lpMessage); <br> <br>        switch (hr) <br>        { <br>            case MAPI_E_INTERFACE_NOT_SUPPORTED: <br>            case MAPI_E_NOT_FOUND: <br>                // The attachment is not a message.  <br>                // Try the next attachment. <br>                hr = HR_LOG(NOERROR);   // This isn't a failure! <br> <br>                continue;   // go to next attachment <br> <br>            default: <br> <br>                if ( FAILED(hr) ) <br>                { <br>                    INTERNAL_ERROR( TEXT("IMAPIProp::OpenProperty()"), hr); <br> <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                break; <br>        }   // end switch <br> <br>        ASSERT_IUNKNOWN_PTR( lpMessage, "Bad lpMessage"); <br> <br>        // Find the new attachment corresponding to the old attachment. <br>        for ( ulLoopCount2 = 0; ulLoopCount2 &lt; lpRows-&gt;cRows; ulLoopCount2++ ) <br>        { <br>            // Free MAPI structures <br>            MAPIFREEBUFFER(lpSearchKey); <br>            MAPIFREEBUFFER(lpSearchKeyNew); <br> <br>            // Release MAPI objects <br>            ULRELEASE(lpNewAttachment); <br>            ULRELEASE(lpNewMessage); <br> <br>            // Get entry identifier information for new message attachment. <br>            ulNewAttachNum = lpNewRows-&gt;aRow[ulLoopCount2].lpProps[0].Value.ul; <br> <br>            // Open the attachment specified by the new entry identifier. <br>            hr = lpNewParent-&gt;OpenAttach( <br>                                    ulNewAttachNum,  <br>                                    0,  <br>                                    MAPI_MODIFY | MAPI_DEFERRED_ERRORS,  <br>                                    &amp;lpNewAttachment); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                INTERNAL_ERROR( TEXT("IMessage::OpenAttach()"),  hr); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            ASSERT_IUNKNOWN_PTR( lpNewAttachment, "Bad lpNewAttachment"); <br> <br>            // Open the new attachment as a message <br>            hr = lpNewAttachment-&gt;OpenProperty(PR_ATTACH_DATA_OBJ, <br>                                       &amp;IID_IMessage, <br>                                       0, <br>                                       MAPI_MODIFY | MAPI_DEFERRED_ERRORS, <br>                                       (LPUNKNOWN FAR *) &amp;lpNewMessage); <br> <br>            switch (hr) <br>            { <br>                case MAPI_E_INTERFACE_NOT_SUPPORTED: <br>                case MAPI_E_NOT_FOUND: <br>                    // Not this attachment! (not an error)                 <br>                    hr = HR_LOG(NOERROR); <br> <br>                    // Try the next attachment <br>                    continue;                 <br> <br>                default: <br>                 <br>                    if ( FAILED(hr) ) <br>                    {   <br>                        INTERNAL_ERROR( TEXT("IMAPIProp::OpenProperty()"), hr); <br> <br>                        hr = HR_LOG(E_FAIL); <br>                        goto cleanup; <br>                    } <br> <br>                    break; <br> <br>            }   // end switch <br> <br>            ASSERT_IUNKNOWN_PTR( lpNewMessage, "Bad lpNewMessage"); <br> <br>            // Compare search key of new message to search key of <br>            // old message.  If not the same, try next new attachment <br>            // in table. <br>            hr = HrMAPIGetPropBinary( <br>                            (LPMAPIPROP) lpNewMessage, <br>                            PR_SEARCH_KEY, <br>                            &amp;ulCountNew, <br>                            (LPVOID FAR *) &amp;lpSearchKeyNew); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                INTERNAL_ERROR( TEXT("HrMAPIGetPropBinary()"), hr); <br> <br>                goto cleanup; <br>            } <br> <br>            hr = HrMAPIGetPropBinary( <br>                            (LPMAPIPROP) lpMessage, <br>                            PR_SEARCH_KEY, <br>                            &amp;ulCount, <br>                            (LPVOID FAR *) &amp;lpSearchKey); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                INTERNAL_ERROR( TEXT("HrMAPIGetPropBinary()"), hr); <br> <br>                goto cleanup; <br>            } <br> <br>            ASSERTERROR(ulCount == ulCountNew, "Bad ulCount"); <br> <br>            // manually compare search keys. (PR_SEARCH_KEY is comparable) <br>            bFound = FALSE; <br>            if ( memcmp(lpSearchKey, lpSearchKeyNew, ulCount) == 0 ) <br>            { <br>                // Found correct new attachment. <br>                bFound = TRUE; <br>                break; <br>            } <br> <br>        }   // end for <br> <br>        // Make sure we found the corresponding attachment. <br>        if ( !bFound ) <br>        { <br>            INTERNAL_ERROR( TEXT("HrCopyGWAttachProps()"),  E_FAIL); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Create and copy all properties in new attachment which aren't <br>        // in the old attachment. <br>        hr = HrCreateNewProps(lpMessage, lpNewMessage); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Call this function recursively to handle all attached messages. <br>        hr = HrCopyGWAttachProps(lpMessage, lpNewMessage); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Save changes to the new message. <br>        hr = lpNewMessage-&gt;SaveChanges(KEEP_OPEN_READWRITE); <br>         <br>        if ( FAILED(hr) ) <br>        { <br>            // check for insufficient disk space <br>            if ( hr == MAPI_E_NOT_ENOUGH_DISK ) <br>            { <br>                EventLogMsg(  <br>                GWCLEAN_OUTOFDISK, <br>                0, <br>                0); <br> <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>            } <br> <br>else <br>{ <br>                INTERNAL_ERROR( TEXT("IMAPIProp::SaveChanges()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>} <br>        }// end if save changes failure <br> <br>        // Save changes to the new attachment <br>        hr = lpNewAttachment-&gt;SaveChanges(KEEP_OPEN_READWRITE); <br>         <br>        if ( FAILED(hr) ) <br>        { <br>            // check for insufficient disk space <br>            if ( hr == MAPI_E_NOT_ENOUGH_DISK ) <br>            { <br>                EventLogMsg(  <br>                GWCLEAN_OUTOFDISK, <br>                0, <br>                0); <br> <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>            } <br> <br>else <br>{ <br>                INTERNAL_ERROR( TEXT("IMAPIProp::SaveChanges()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>} <br>        } <br>    }   // end for <br> <br>cleanup: <br> <br>    // Release the MAPI objects <br>    ULRELEASE(lpAttachTable); <br>    ULRELEASE(lpNewAttachTable); <br>    ULRELEASE(lpMessage); <br>    ULRELEASE(lpNewMessage); <br>    ULRELEASE(lpAttachment); <br>    ULRELEASE(lpNewAttachment); <br> <br>    // Free  MAPI structures.  (SRowSet is special!) <br>    FREEPROWS(lpRows); <br>    FREEPROWS(lpNewRows); <br> <br>    MAPIFREEBUFFER(lpSearchKey); <br>    MAPIFREEBUFFER(lpSearchKeyNew); <br> <br>    RETURN(hr); <br> <br>}   // end CGWClean::CopyGWAttachProps() <br> <br>//$--CGWClean::HrCreateNewProps---------------------------------------------------- <br>// <br>// DESCRIPTION: Determine which properties didn't get copied <br>//              to the new message by CopyMessages(), and then <br>//              create and set those properties on the new message. <br>// <br>// INPUT:       LPMESSAGE --  Original message pointer <br>//              LPMESSAGE --  New message pointer <br>// <br>// RESULT:      HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br> <br>HRESULT CGWClean::HrCreateNewProps(   // RETURNS: HRESULT <br>    IN LPMESSAGE lpMessage,         // source message <br>    IN LPMESSAGE lpNewMessage)                // destination message <br>{ <br>    const   INT iMaxSize    =   124;    // maximum number of properties to create <br>    HRESULT hr  =   NOERROR;    // return code <br>    ULONG   ulCount =   0;      // # props for original message <br>    ULONG   ulNewCount  =   0;  // # props for new message <br>    LPSPropValue    lpsPropValues   =   NULL;   // original message properties and values <br>    LPSPropValue    lpsPropNewValues    =   NULL;   // new message properties and values <br>    ULONG   ulLoopCount =   0;  // loop counter <br>    ULONG   ulLoopCount2    =   0;  // second loop counter <br>    ULONG   ulOrigProp  =   0;  // original message property tag <br>    BOOL    bFound  =   FALSE;  // TRUE if property is found in new message <br>    MAPINAMEID  rgNamedMsgProps[iMaxSize] =   {0}; // array of named property structures for "extra" message properties <br>    LPMAPINAMEID    lpNamedMsgProps[iMaxSize] =   {0};    // array of pointers to MAPINAMEID structures <br>    ULONG   ulCreated   =   0;  // number of named properties created in new message </code></pre>
<p>
</p>
<pre><code>SPropValue  lpsCreatedPropValues[iMaxSize]   =   {0};    // values of created properties <br>    LPSPropTagArray lpsNewPropTags  =   NULL;   // new named property tags <br>    WCHAR   lpPropNames[iMaxSize][80]  =   {0};    // named property array <br>    LPCWSTR lpBaseName  =   L"GWMSGPROP";   // base name for named property <br>    LPSPropProblemArray    lpsPropProblems =   NULL;   // for SetProps call <br>    WCHAR   lpTempString[10]    =   {0};        // temporary string for _itow <br> <br>    DEBUGPRIVATE("CGWClean::HrCreateNewProps()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CGWClean_HrCreateNewProps(lpMessage, lpNewMessage); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Get all properties for the original message <br>    hr = lpMessage-&gt;GetProps(NULL,  // get all properties <br>                                 0,     // flags <br>                                 &amp;ulCount,  // number of properties <br>                                 &amp;lpsPropValues);   // property value array pointer <br> <br>    if ( hr == MAPI_W_ERRORS_RETURNED ) <br>    { <br>        // May not have enough memory to get PR_BODY, PR_RTF_COMPRESSED <br>        // and PR_ATTACH_DATA_BIN properties if they are very large. <br>        // This is not really an error.   <br>        // CopyMessages will copy over all properties that it can. <br>        // Then, we are only interested in copying over properties which <br>        // exist in old object but not in the new. <br>        hr = HR_LOG(NOERROR); <br>    } <br> <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMAPIProp::GetProps()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERT_READ_PTR( lpsPropValues, sizeof(SPropValue), "Bad lpsPropValues"); <br> <br>   // Get all properties from the new messsage. <br>   hr = lpNewMessage-&gt;GetProps(NULL,  // get all properties <br>                                 0,     // flags <br>                                 &amp;ulNewCount,  // number of properties <br>                                 &amp;lpsPropNewValues);   // property value array pointer <br> <br>    if ( hr == MAPI_W_ERRORS_RETURNED ) <br>    { <br>        // May not have enough memory to get PR_BODY, PR_RTF_COMPRESSED <br>        // and PR_ATTACH_DATA_BIN properties if they are very large. <br>        // This is not really an error.   <br>        // CopyMessages will copy over all properties that it can. <br>        // Then, we are only interested in copying over properties which <br>        // exist in old object but not in the new. <br>        hr = HR_LOG(NOERROR); <br>    } <br>    <br>    if ( FAILED(hr) ) <br>    { <br>        INTERNAL_ERROR( TEXT("IMAPIProp::GetProps()"), hr); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERT_READ_PTR( lpsPropNewValues, sizeof(SPropValue), "Bad lpsPropNewValues"); <br>     <br>    // If the number of properties in both messages is the same, <br>    // then we are done.  Otherwise, we need to create all properties <br>    // in the new message which are in the original message, but which <br>    // are not currently in the new message. <br>    if ( ulCount != ulNewCount ) <br>    { <br>        for ( ulLoopCount = 0; ulLoopCount &lt; ulCount; ulLoopCount++ ) <br>        { <br>            // Get next original message property <br>            ulOrigProp = lpsPropValues[ulLoopCount].ulPropTag; <br> <br>            bFound = FALSE; // initialize found flag <br> <br>            // Search for original property in the new message. <br>            for ( ulLoopCount2 = 0; ulLoopCount2 &lt; ulNewCount; ulLoopCount2++ ) <br>            { <br>                if ( PROP_ID(lpsPropNewValues[ulLoopCount2].ulPropTag) == <br>                     PROP_ID(ulOrigProp) ) <br>                { <br>                    // We found it.  Done with this property check <br>                    bFound = TRUE; <br>                    break; <br>                }     <br>            }   // end for <br> <br>            // If we didn't find the property in the new message, <br>            // create it now. <br>            if ( !bFound ) <br>            { <br>                // Create a named property in the new message for the <br>                // original property in the old message <br>                // (Set up structures here.  Create when all found.) <br>                ASSERTERROR(ulCreated &lt; iMaxSize, "Bad ulCreated"); <br> <br>                rgNamedMsgProps[ulCreated].lpguid = (LPGUID) &amp;PS_PUBLIC_STRINGS; <br>                rgNamedMsgProps[ulCreated].ulKind = MNID_STRING; <br> <br>                // Named property will be GWMSGPROP# where # is an integer <br>                // starting at 0. <br>                lstrcpyW(lpPropNames[ulCreated], lpBaseName); <br>                lstrcatW(lpPropNames[ulCreated], _itow(ulCreated, lpTempString, 10)); <br>                rgNamedMsgProps[ulCreated].Kind.lpwstrName = lpPropNames[ulCreated]; <br> <br>                lpNamedMsgProps[ulCreated] = &amp;(rgNamedMsgProps[ulCreated]); <br> <br>                // Set up the value for the created property and the property tag type. <br>                lpsCreatedPropValues[ulCreated].Value = lpsPropValues[ulLoopCount].Value; <br>                lpsCreatedPropValues[ulCreated].ulPropTag = lpsPropValues[ulLoopCount].ulPropTag; <br> <br>                // increment count of named message properties created <br>                ulCreated++; <br> <br>            }   // end if not found <br>        }   // end for <br> <br>        // Create the needed named properties <br>        hr = lpNewMessage-&gt;GetIDsFromNames(ulCreated,    // # of names <br>                                           (LPMAPINAMEID FAR *) lpNamedMsgProps,// array of names <br>                                           MAPI_CREATE,     // flags <br>                                           &amp;lpsNewPropTags);// address of property tags <br> <br>        switch ( hr ) <br>        { <br>            case MAPI_W_ERRORS_RETURNED: <br>                INTERNAL_ERROR( TEXT("IMAPIProp::GetIDsFromNames()"), hr); <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br> <br>            case MAPI_E_NOT_ENOUGH_DISK: <br>                // insufficient disk space <br>                EventLogMsg(  <br>                GWCLEAN_OUTOFDISK, <br>                0, <br>                0); <br> <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br> <br>            default: <br>                if ( FAILED(hr) ) <br>                { <br>                    INTERNAL_ERROR( TEXT("IMAPIProp::GetIDsFromNames()"), hr); <br> <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                break; <br>             <br>        }   // end switch <br> <br>        // Keep the original property type, but replace the <br>        // proptery ID with the new named property ID. <br>        for ( ulLoopCount2 = 0; ulLoopCount2 &lt; ulCreated; ulLoopCount2++ ) <br>        { <br>            lpsCreatedPropValues[ulLoopCount2].ulPropTag = PROP_TAG( <br>               PROP_TYPE(lpsCreatedPropValues[ulLoopCount2].ulPropTag), <br>               PROP_ID(lpsNewPropTags-&gt;aulPropTag[ulLoopCount2])); <br> <br>        }   // end for <br> <br>        // Set the values of the new named properties <br>        hr = lpNewMessage-&gt;SetProps(ulCreated, // number of properties <br>                                    lpsCreatedPropValues,  // Property tags and values <br>                                    &amp;lpsPropProblems);    // problem structure <br> <br>        if ( FAILED(hr) ) <br>        { <br>            INTERNAL_ERROR( TEXT("IMAPIProp::SetProps()"), hr); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    }   // end if some properties not already copied over <br>     <br>cleanup: <br> <br>    // free MAPI buffers <br>    MAPIFREEBUFFER(lpsPropValues); <br>    MAPIFREEBUFFER(lpsPropNewValues); <br>    MAPIFREEBUFFER(lpsNewPropTags); <br>    MAPIFREEBUFFER(lpsPropProblems); <br> <br>    // Release MAPI and OLE objects <br> <br>    RETURN(hr); <br> <br>} <br> <br>/* <br> * EOF <br> */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
