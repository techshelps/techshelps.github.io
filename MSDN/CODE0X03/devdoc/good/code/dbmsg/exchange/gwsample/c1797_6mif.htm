<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADDRESS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1797"></a>ADDRESS.C</h2>
<pre><code>// --address.c------------------------------------------------------------------ <br>// <br>//  Find an address given a proxy address. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "_entryid.h" <br>#include "gwmain.h" <br>#include "gwsample.h" <br> <br>//$--HrCreateSearchKey----------------------------------------------------------- <br>// Create a search key given an address type and an address. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateSearchKey(              // RETURNS: return code <br>    IN LPVOID lpObject,                 // pointer to object <br>    IN LPTSTR lpszAddressType,          // pointer to address type <br>    IN LPTSTR lpszAddress,              // pointer to address <br>    OUT LPTSTR *lppszSearchKey)         // pointer to search key <br>{ <br>    HRESULT hr     = NOERROR; <br>    SCODE   sc     = 0; <br>    ULONG   cBytes = 0; <br> <br>    DEBUGPUBLIC("HrCreateSearchKey()\n"); <br> <br>    *lppszSearchKey = NULL; <br> <br>    cBytes = <br>        (lstrlen(lpszAddressType) + <br>         lstrlen(lpszAddress) + 2) * sizeof(TCHAR); <br> <br>    sc = MAPIAllocateMore(cBytes, lpObject, (void **)lppszSearchKey); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    lstrcpy(*lppszSearchKey, lpszAddressType); <br>    lstrcat(*lppszSearchKey, TEXT(":")); <br>    lstrcat(*lppszSearchKey, lpszAddress); <br>    CharUpperBuff(*lppszSearchKey, cBytes/sizeof(TCHAR)); <br> <br>cleanup: <br> <br>    return(hr); <br>} <br> <br>//$--HrCreateProxyAddress------------------------------------------------------- <br>// Create proxy address. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateProxyAddress(               // RETURNS: return code <br>    IN LPADRBOOK  lpAdrBook,                // pointer to address book <br>    IN LPVOID     lpObject,                 // pointer to object <br>    IN BOOL       fMapiRecip,               // MAPI recipient <br>    IN LPTSTR     lpszDisplayName,          // pointer to display name <br>    IN LPTSTR     lpszAddressType,          // pointer to address type <br>    IN LPTSTR     lpszAddress,              // pointer to address <br>    OUT LPTSTR    *lppszProxyDisplayName,   // proxy display name <br>    OUT LPTSTR    *lppszProxyAddressType,   // proxy address type <br>    OUT LPTSTR    *lppszProxyAddress,       // proxy address <br>    OUT LPTSTR    *lppszProxySearchKey,     // proxy search key <br>    OUT ULONG     *lpcbProxyEid,            // count of bytes in proxy entry ID <br>    OUT LPENTRYID *lppProxyEid)             // pointer to proxy entry ID <br>{ <br>    HRESULT   hr      = NOERROR; <br>    HRESULT   hrT     = NOERROR; <br>    SCODE     sc      = 0; <br> <br>    ULONG     cBytes  = 0; <br> <br>    ULONG     cbeidT  = 0; <br>    LPENTRYID lpeidT  = NULL; <br> <br>    ULONG     ulFlags = 0; <br> <br>    DEBUGPUBLIC("HrCreateProxyAddress()\n"); <br> <br>    if(lpszDisplayName == NULL) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    if(lpszAddressType == NULL) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    if(lpszAddress == NULL) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lppszProxyDisplayName = NULL; <br>    *lppszProxyAddressType = NULL; <br>    *lppszProxyAddress     = NULL; <br>    *lppszProxySearchKey   = NULL; <br>    *lpcbProxyEid          = 0; <br>    *lppProxyEid           = NULL; <br> <br>    // <br>    // Create proxy address <br>    // <br> <br>    cBytes = cbStrLen(lpszAddress); <br> <br>    sc = MAPIAllocateMore(cBytes, lpObject, (void **)lppszProxyAddress); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    CopyMemory(*lppszProxyAddress, lpszAddress, cBytes); <br> <br>    // <br>    // Create proxy display name <br>    // <br> <br>    cBytes = cbStrLen(lpszDisplayName); <br> <br>    sc = MAPIAllocateMore(cBytes, lpObject, (void **)lppszProxyDisplayName); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    CopyMemory(*lppszProxyDisplayName, lpszDisplayName, cBytes); <br> <br>    // <br>    // Create proxy address type <br>    // <br> <br>    cBytes = cbStrLen(lpszAddressType); <br> <br>    sc = MAPIAllocateMore(cBytes, lpObject, (void **)lppszProxyAddressType); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    CopyMemory(*lppszProxyAddressType, lpszAddressType, cBytes); <br> <br>    if(fMapiRecip == TRUE) <br>    { <br>        ulFlags = fMapiUnicode; <br>    } <br>    else <br>    { <br>        ulFlags = fMapiUnicode|MAPI_SEND_NO_RICH_INFO; <br>    } <br> <br>    // <br>    // Create proxy entry ID <br>    // <br> <br>    hrT = MAPICALL(lpAdrBook)-&gt;CreateOneOff( <br>        lpAdrBook, <br>        *lppszProxyDisplayName, <br>        *lppszProxyAddressType, <br>        *lppszProxyAddress, <br>        ulFlags, <br>        &amp;cbeidT, <br>        &amp;lpeidT); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    sc = MAPIAllocateMore(cbeidT, lpObject, (void **)lppProxyEid); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    *lpcbProxyEid = cbeidT; <br> <br>    CopyMemory(*lppProxyEid, lpeidT, cbeidT); <br> <br>    // <br>    // Create proxy search key <br>    // <br> <br>    hr = HrCreateSearchKey( <br>        lpObject, <br>        *lppszProxyAddressType, <br>        *lppszProxyAddress, <br>        lppszProxySearchKey); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpeidT); <br> <br>    if(FAILED(hr)) <br>    { <br>        *lppszProxyDisplayName = NULL; <br>        *lppszProxyAddressType = NULL; <br>        *lppszProxyAddress     = NULL; <br>        *lppszProxySearchKey   = NULL; <br>        *lpcbProxyEid          = 0; <br>        *lppProxyEid           = NULL; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCreateEmailAddress------------------------------------------------------- <br>// Create email address. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateEmailAddress(               // RETURNS: return code <br>    IN LPADRBOOK  lpAdrBook,                // pointer to address book <br>    IN LPVOID     lpObject,                 // pointer to object <br>    IN LPTSTR     lpszDisplayName,          // pointer to display name <br>    IN LPTSTR     lpszAddressType,          // pointer to address type <br>    IN LPTSTR     lpszAddress,              // pointer to address <br>    IN ULONG      cbeid,                    // count of bytes in entry ID <br>    IN LPENTRYID  lpeid,                    // pointer to entry ID <br>    OUT LPTSTR    *lppszEmailDisplayName,   // email display name <br>    OUT LPTSTR    *lppszEmailAddressType,   // email address type <br>    OUT LPTSTR    *lppszEmailAddress,       // email address <br>    OUT LPTSTR    *lppszEmailSearchKey,     // email search key <br>    OUT ULONG     *lpcbEmailEid,            // count of bytes in email entry ID <br>    OUT LPENTRYID *lppEmailEid)             // pointer to email entry ID <br>{ <br>    HRESULT   hr     = NOERROR; <br>    SCODE     sc     = 0; <br>    ULONG     cBytes = 0; <br> <br>    DEBUGPUBLIC("HrCreateEmailAddress()\n"); <br> <br>    *lppszEmailDisplayName = NULL; <br>    *lppszEmailAddressType = NULL; <br>    *lppszEmailAddress     = NULL; <br>    *lppszEmailSearchKey   = NULL; <br>    *lpcbEmailEid          = 0; <br>    *lppEmailEid           = NULL; <br> <br>    // <br>    // Create email address <br>    // <br> <br>    cBytes = cbStrLen(lpszAddress); <br> <br>    sc = MAPIAllocateMore(cBytes, lpObject, (void **)lppszEmailAddress); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    CopyMemory(*lppszEmailAddress, lpszAddress, cBytes); <br> <br>    // <br>    // Create email display name <br>    // <br> <br>    cBytes = cbStrLen(lpszDisplayName); <br> <br>    sc = MAPIAllocateMore(cBytes, lpObject, (void **)lppszEmailDisplayName); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    CopyMemory(*lppszEmailDisplayName, lpszDisplayName, cBytes); <br> <br>    // <br>    // Create email address type <br>    // <br> <br>    cBytes = cbStrLen(lpszAddressType); <br> <br>    sc = MAPIAllocateMore(cBytes, lpObject, (void **)lppszEmailAddressType); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    CopyMemory(*lppszEmailAddressType, lpszAddressType, cBytes); <br> <br>    // <br>    // Create email entry ID <br>    // <br> <br>    sc = MAPIAllocateMore(cbeid, lpObject, (void **)lppEmailEid); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    *lpcbEmailEid = cbeid; <br> <br>    CopyMemory(*lppEmailEid, lpeid, cbeid); <br> <br>    // <br>    // Create email search key <br>    // <br> <br>    hr = HrCreateSearchKey( <br>        lpObject, <br>        *lppszEmailAddressType, <br>        *lppszEmailAddress, <br>        lppszEmailSearchKey); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        *lppszEmailDisplayName = NULL; <br>        *lppszEmailAddressType = NULL; <br>        *lppszEmailAddress     = NULL; <br>        *lppszEmailSearchKey   = NULL; <br>        *lpcbEmailEid          = 0; <br>        *lppEmailEid           = NULL; <br>    } <br> <br>    return(hr); <br>} <br> <br>//$--HrDeleteAddressProps-------------------------------------------------------- <br>// Delete address properties from the message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrDeleteAddressProps(           // RETURNS: return code <br>    IN LPMESSAGE  lpMessage,            // pointer to message <br>    IN ULONG ulDisplayName,             // display name property tag <br>    IN ULONG ulAddressType,             // address type property tag <br>    IN ULONG ulAddress,                 // address property tag <br>    IN ULONG ulSearchKey,               // search key property tag <br>    IN ULONG ulEntryId)                 // entry ID property tag <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br>    ULONG   i   = 0; <br> <br>    SizedSPropTagArray(5, rgPropTags) = <br>    { <br>        5, <br>        { <br>            PR_NULL, <br>            PR_NULL, <br>            PR_NULL, <br>            PR_NULL, <br>            PR_NULL, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrDeleteAddressProps()\n"); <br> <br>    if(FBadPropTag(ulDisplayName) || <br>      (PROP_TYPE(ulDisplayName) == PT_NULL) || <br>      (PROP_TYPE(ulDisplayName) == PT_ERROR)) <br>    { <br>        MODULE_WARNING1("Invalid property type for property tag [%08lx]",ulDisplayName); <br>    } <br>    else <br>    { <br>        rgPropTags.aulPropTag[i++] = ulDisplayName; <br>    } <br> <br>    if(FBadPropTag(ulAddressType) || <br>      (PROP_TYPE(ulAddressType) == PT_NULL) || <br>      (PROP_TYPE(ulAddressType) == PT_ERROR)) <br>    { <br>        MODULE_WARNING1("Invalid property type for property tag [%08lx]",ulAddressType); <br>    } <br>    else <br>    { <br>        rgPropTags.aulPropTag[i++] = ulAddressType; <br>    } <br> <br>    if(FBadPropTag(ulAddress) || <br>      (PROP_TYPE(ulAddress) == PT_NULL) || <br>      (PROP_TYPE(ulAddress) == PT_ERROR)) <br>    { <br>        MODULE_WARNING1("Invalid property type for property tag [%08lx]",ulAddress); <br>    } <br>    else <br>    { <br>        rgPropTags.aulPropTag[i++] = ulAddress; <br>    } <br> <br>    if(FBadPropTag(ulSearchKey) || <br>      (PROP_TYPE(ulSearchKey) == PT_NULL) || <br>      (PROP_TYPE(ulSearchKey) == PT_ERROR)) <br>    { <br>        MODULE_WARNING1("Invalid property type for property tag [%08lx]",ulSearchKey); <br>    } <br>    else <br>    { <br>        rgPropTags.aulPropTag[i++] = ulSearchKey; <br>    } <br> <br>    if(FBadPropTag(ulEntryId) || <br>      (PROP_TYPE(ulEntryId) == PT_NULL) || <br>      (PROP_TYPE(ulEntryId) == PT_ERROR)) <br>    { <br>        MODULE_WARNING1("Invalid property type for property tag [%08lx]",ulEntryId); <br>    } <br>    else <br>    { <br>        rgPropTags.aulPropTag[i++] = ulEntryId; <br>    } <br> <br>    // <br>    // Check if there are any properties left to delete. <br>    // <br> <br>    if(i == 0) <br>    { <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br>        goto cleanup; <br>    } <br> <br>    rgPropTags.cValues = i; <br> <br>    hrT = MAPICALL(lpMessage)-&gt;DeleteProps( <br>        lpMessage, <br>        (SPropTagArray *)&amp;rgPropTags, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    return(hr); <br>} <br> <br>//$--HrDeleteAddressListProperty------------------------------------------------ <br>// Delete a property from an address list given its property tag. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrDeleteAddressListProperty(    // RETURNS: return code <br>    IN ULONG ulPropTag,                 // property tag <br>    IN OUT LPADRLIST lpAdrList)         // pointer to address list <br>{ <br>    HRESULT      hr      = NOERROR; <br>    ULONG        i       = 0; <br>    ULONG        cValues = 0; <br>    LPSPropValue lpProps = NULL; <br>    LPSPropValue lpPropT = NULL; <br> <br>    DEBUGPUBLIC("HrDeleteAddressListProperty()\n"); <br> <br>    for(i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>        cValues = lpAdrList-&gt;aEntries[i].cValues; <br>        lpProps = lpAdrList-&gt;aEntries[i].rgPropVals; <br> <br>        lpPropT = LpValFindProp(ulPropTag, cValues, lpProps); <br> <br>        if(lpPropT != NULL) <br>        { <br>            lpPropT-&gt;ulPropTag = PR_NULL; <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrSetUlongPropertyValue---------------------------------------------------- <br>// Set a ULONG property value. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrSetUlongPropertyValue(        // RETURNS: return code <br>    IN BOOL  fOverwrite,                // overwrite value if it exists <br>    IN ULONG ulPropTag,                 // property tag <br>    IN ULONG ulValue,                   // property value <br>    IN ULONG cValues,                   // count of property values <br>    IN LPSPropValue lpProps,            // pointer to property values <br>    OUT ULONG* lpcValues,               // new count of property values <br>    OUT LPSPropValue* lppProps)         // new pointer to property values <br>{ <br>    HRESULT      hr           = NOERROR; <br>    LPSPropValue lpPropT      = NULL; <br>    SPropValue   PropValue[1] = {0}; <br> <br>    DEBUGPUBLIC("HrSetUlongPropertyValue()\n"); <br> <br>    if(PROP_TYPE(ulPropTag) != PT_LONG) <br>    { <br>        RETURN(HR_LOG(E_INVALIDARG)); <br>    } <br> <br>    *lpcValues = 0; <br>    *lppProps  = NULL; <br> <br>    lpPropT = LpValFindProp(ulPropTag, cValues, lpProps); <br> <br>    if(lpPropT == NULL) <br>    { <br>        PropValue[0].ulPropTag = ulPropTag; <br>        PropValue[0].Value.ul  = ulValue; <br> <br>        hr = HrMAPIAppendSPropValues( <br>            cValues, <br>            lpProps, <br>            1, <br>            PropValue, <br>            lpcValues, <br>            lppProps); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        SCODE sc = 0; <br> <br>        sc = ScDupPropset( <br>            cValues, <br>            lpProps, <br>    MAPIAllocateBuffer, <br>    lppProps); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        *lpcValues = cValues; <br> <br>        if(fOverwrite == TRUE) <br>        { <br>            lpPropT = LpValFindProp(ulPropTag, *lpcValues, *lppProps); <br> <br>            if(lpPropT != NULL) <br>            { <br>                lpPropT-&gt;ulPropTag = ulPropTag; <br>                lpPropT-&gt;Value.ul  = ulValue; <br>            } <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrExpandMessageAddressList------------------------------------------------- <br>// Expand a list of addresses on the message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrExpandMessageAddressList(     // RETURNS: return code <br>    IN LPMESSAGE  lpMessage,            // pointer to message <br>    OUT ULONG*    lpcMesgAddr,          // count of message addresses <br>    OUT ULONG*    lpcReplyAddr,         // count of reply recipient addresses <br>    OUT ULONG*    lpcRecipAddr,         // count of recipient addresses <br>    OUT LPADRLIST *lppRecipList,        // pointer to recipient address list <br>    OUT LPADRLIST *lppAdrList)          // pointer to address list <br>{ <br>    HRESULT      hr                   = NOERROR; <br>    HRESULT      hrT                  = NOERROR; <br>    ULONG        i                    = 0; <br>    ULONG        cValues              = 0; <br>    LPSPropValue lpProps              = NULL; <br>    LPSPropValue lpPropT              = NULL; <br>    LPSRowSet    lpRows               = 0; <br> <br>    LPMAPITABLE  lpTable              = NULL; <br> <br>    SPropValue   rgProps[3]           = {0}; <br> <br>    ULONG        cEntries             = 0; <br> <br>    ULONG        cAddr                = 0; <br> <br>    ULONG        cMesgAddr            = 0; <br>    ULONG        cRecipAddr           = 0; <br>    ULONG        cReplyAddr           = 0; <br> <br>#define IREPORTDEST 10 <br> <br>#define CADDREID    14 <br> <br>    SizedSPropTagArray(CADDREID, rgPropTags) = <br>    { <br>        CADDREID, <br>        { <br>            PR_SENDER_ENTRYID, <br>            PR_SENT_REPRESENTING_ENTRYID, <br>            PR_ORIGINAL_SENDER_ENTRYID, <br>            PR_ORIGINAL_SENT_REPRESENTING_ENTRYID, <br>            PR_RECEIVED_BY_ENTRYID, <br>            PR_RCVD_REPRESENTING_ENTRYID, <br>            PR_ORIGINAL_AUTHOR_ENTRYID, <br>            PR_REPORT_ENTRYID, <br>            PR_READ_RECEIPT_ENTRYID, <br>            PR_ORIGINATOR_ENTRYID, <br>            PR_REPORT_DESTINATION_ENTRYID, <br>            PR_CREATOR_ENTRYID, <br>            PR_LAST_MODIFIER_ENTRYID, <br>            //PR_ORIGINALLY_INTENDED_RECIP_ENTRYID, <br>            PR_REPLY_RECIPIENT_ENTRIES, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrExpandMessageAddressList()\n"); <br> <br>    *lpcMesgAddr  = 0; <br>    *lpcReplyAddr = 0; <br>    *lpcRecipAddr = 0; <br>    *lppRecipList = NULL; <br>    *lppAdrList   = NULL; <br> <br>    // <br>    // Get message addresses <br>    // <br> <br>    hrT = MAPICALL(lpMessage)-&gt;GetProps( <br>        lpMessage, <br>        (SPropTagArray *)&amp;rgPropTags, <br>        fMapiUnicode, <br>        &amp;cValues, <br>        &amp;lpProps); <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpProps = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Get the recipient table for the message <br>    // <br> <br>    hrT = MAPICALL(lpMessage)-&gt;GetRecipientTable( <br>        lpMessage, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;lpTable); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// <br>//  Query all the rows <br>// <br> <br>hr = HrQueryAllRows( <br>    lpTable, <br>NULL, <br>NULL, <br>NULL, <br>0, <br>&amp;lpRows); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Calculate the total number of addresses <br>    // <br> <br>    if(lpProps[CADDREID-1].ulPropTag == PR_REPLY_RECIPIENT_ENTRIES) <br>    { <br>        cReplyAddr = lpProps[CADDREID-1].Value.MVbin.cValues; <br>    } <br>    else <br>    { <br>        cReplyAddr = 0; <br>    } <br> <br>    cEntries = cValues - 1 + lpRows-&gt;cRows + cReplyAddr; <br> <br>    for(i = 0; i &lt; lpRows-&gt;cRows; i++) <br>    { <br>        lpPropT = LpValFindProp( <br>            PR_ORIGINAL_ENTRYID, <br>            lpRows-&gt;aRow[i].cValues, <br>            lpRows-&gt;aRow[i].lpProps); <br> <br>        if((lpPropT != NULL) &amp;&amp; (lpPropT-&gt;ulPropTag == PR_ORIGINAL_ENTRYID)) <br>        { <br>            cEntries++; <br>        } <br>    } <br> <br>    // <br>    // Create an ADRLIST <br>    // <br> <br>    hr = HrMAPICreateSizedAddressList( <br>        cEntries, <br>        lppAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cAddr = 0; <br> <br>    // <br>    // Add message addresses to the address list <br>    // <br> <br>    cMesgAddr = --cValues; <br> <br>    for(i = 0; i &lt; cMesgAddr; i++, cAddr++) <br>    { <br>        if(PROP_TYPE(lpProps[i].ulPropTag) == PT_ERROR) <br>        { <br>            rgProps[0].ulPropTag     = PR_NULL; <br>            rgProps[0].Value.err     = MAPI_E_NOT_FOUND; <br>        } <br>        else <br>        { <br>            rgProps[0].ulPropTag     = PR_ENTRYID; <br>            rgProps[0].Value.bin.cb  = lpProps[i].Value.bin.cb; <br>            rgProps[0].Value.bin.lpb = lpProps[i].Value.bin.lpb; <br>        } <br> <br>        rgProps[1].ulPropTag     = PR_RECIPIENT_TYPE; <br>        rgProps[1].Value.ul      = MAPI_TO; <br> <br>        hr = HrMAPISetAddressList( <br>            cAddr, <br>            2, <br>            rgProps, <br>            *lppAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // <br>    // Add reply recipient addresses to the address list <br>    // <br> <br>    for(i = 0; i &lt; cReplyAddr; i++, cAddr++) <br>    { <br>        rgProps[0].ulPropTag     = PR_ENTRYID; <br>        rgProps[0].Value.bin.cb  = lpProps[CADDREID-1].Value.MVbin.lpbin[i].cb; <br>        rgProps[0].Value.bin.lpb = lpProps[CADDREID-1].Value.MVbin.lpbin[i].lpb; <br>        rgProps[1].ulPropTag     = PR_RECIPIENT_TYPE; <br>        rgProps[1].Value.ul      = MAPI_TO; <br> <br>        hr = HrMAPISetAddressList( <br>            cAddr, <br>            2, <br>            rgProps, <br>            *lppAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // <br>    // Add recipient addresses to the address list <br>    // <br> <br>    cRecipAddr = lpRows-&gt;cRows; <br> <br>    for(i = 0; i &lt; cRecipAddr; i++, cAddr++) <br>    { <br>        hr = HrMAPISetAddressList( <br>            cAddr, <br>            lpRows-&gt;aRow[i].cValues, <br>            lpRows-&gt;aRow[i].lpProps, <br>            *lppAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    for(i = 0; i &lt; cRecipAddr; i++) <br>    { <br>        lpPropT = LpValFindProp( <br>            PR_ORIGINAL_ENTRYID, <br>            lpRows-&gt;aRow[i].cValues, <br>            lpRows-&gt;aRow[i].lpProps); <br> <br>        if((lpPropT != NULL) &amp;&amp; (lpPropT-&gt;ulPropTag == PR_ORIGINAL_ENTRYID)) <br>        { <br>            rgProps[0].ulPropTag     = PR_ENTRYID; <br>            rgProps[0].Value.bin.cb  = lpPropT-&gt;Value.bin.cb; <br>            rgProps[0].Value.bin.lpb = lpPropT-&gt;Value.bin.lpb; <br>            rgProps[1].ulPropTag     = PR_RECIPIENT_NUMBER; <br>            rgProps[1].Value.ul      = i; <br>            rgProps[2].ulPropTag     = PR_RECIPIENT_TYPE; <br>            rgProps[2].Value.ul      = MAPI_TO; <br> <br>            hr = HrMAPISetAddressList( <br>                cAddr, <br>                3, <br>                rgProps, <br>                *lppAdrList); <br> <br>            cAddr++; <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br>    } <br> <br>    *lpcMesgAddr  = cMesgAddr; <br>    *lpcReplyAddr = cReplyAddr; <br>    *lpcRecipAddr = cRecipAddr; <br> <br>    *lppRecipList = (LPADRLIST)lpRows; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        *lpcMesgAddr  = 0; <br>        *lpcReplyAddr = 0; <br>        *lpcRecipAddr = 0; <br> <br>        FREEPADRLIST(*lppRecipList); <br>    } <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpProps); <br> <br>    // Release MAPI objects <br>    ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br> <br>#undef IREPORTDEST <br>} <br> <br>//$--HrCheckForType------------------------------------------------------------- <br>//  Check if the passed in string has the requested address type. If so, return <br>//  the address value, otherwise fail. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCheckForType(  // RETURNS: return code <br>    IN  LPUNKNOWN lpObject,     // pointer to object <br>    IN  LPTSTR lpszAddrType,    // pointer to address type <br>    IN  LPTSTR lpszProxy,       // pointer to proxy address <br>    OUT LPTSTR * lppszAddress)  // pointer to address pointer <br>{ <br>    HRESULT hr              = EDK_E_NOT_FOUND; <br>    int     rc              = 0; <br>    LPTSTR  lpszProxyAddr   = NULL; <br>    ULONG   cbAddress       = 0; <br>    SCODE   sc              = 0; <br>    ULONG   cchProxy        = 0; <br>    ULONG   cchProxyType    = 0; <br> <br>    DEBUGPUBLIC("HrCheckForType()\n"); <br> <br>    // <br>// Initialize output parameter <br>    // <br> <br>*lppszAddress = NULL; <br> <br>    // <br>    // Find the ':' separator. <br>    // <br> <br>    cchProxy = lstrlen(lpszProxy); <br> <br>    for( <br>        cchProxyType = 0; <br>        (lpszProxy[cchProxyType] != 0) &amp;&amp; (lpszProxy[cchProxyType] != TEXT(':')); <br>        cchProxyType++); <br> <br>    if((cchProxyType == 0) || (cchProxyType &gt;= cchProxy)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Does the address type match? <br>    // <br> <br>    rc = CompareString( <br>        GetSystemDefaultLCID(), <br>        NORM_IGNORECASE|NORM_IGNORENONSPACE|SORT_STRINGSORT, <br>        lpszAddrType, -1, <br>        lpszProxy, cchProxyType); <br>         <br>    if(rc == 2) <br>    {    <br>        // <br>        // Specified address type found     <br>        // <br> <br>        lpszProxyAddr = lpszProxy + cchProxyType + 1; <br> <br>        cbAddress = cbStrLen(lpszProxyAddr); <br> <br>        // <br>        // Make a buffer to hold it. <br>        // <br> <br>        sc = MAPIAllocateMore(cbAddress, lpObject, (void **)lppszAddress); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br>        else <br>        { <br>            CopyMemory(*lppszAddress, lpszProxyAddr, cbAddress); <br> <br>            hr = NOERROR; <br>        } <br>    } <br>    else if(rc == 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br>    else <br>    { <br>        hr = EDK_E_NOT_FOUND; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMapAddrToProxy----------------------------------------------------------- <br>// Map all email addresses to proxy addresses in a given address list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMapAddrToProxy(               // RETURNS: return code <br>    IN  LPADRBOOK    lpAdrBook,         // pointer to address book <br>    IN  LPTSTR       lpszAddrType,      // pointer to the address type <br>    IN OUT LPADRLIST lpAdrList)         // pointer to address list <br>{ <br>    HRESULT      hr                    = NOERROR; <br>    SCODE        sc                    = 0; <br>    ULONG        i                     = 0; <br>    ULONG        j                     = 0; <br>    ULONG        cbAddress             = 0; <br>    ULONG        cProxy                = 0; <br>    LPSPropValue lpProps               = NULL; <br>    LPSPropValue lpPropT               = NULL; <br> <br>    LPTSTR       lpszProxyDisplayName  = NULL; <br>    LPTSTR       lpszProxyAddressType  = NULL; <br>    LPTSTR       lpszProxyAddress      = NULL; <br> <br>    LPTSTR       lpszEmailDisplayName  = NULL; <br>    LPTSTR       lpszEmailAddressType  = NULL; <br>    LPTSTR       lpszEmailAddress      = NULL; <br>    LPTSTR       lpszEmailSearchKey    = NULL; <br>    ULONG        cbEmailEid            = 0; <br>    LPENTRYID    lpEmailEid            = NULL; <br> <br>    SPropValue   prop[MIN_CRECIPPROPS] = {0}; <br> <br>    SizedSPropTagArray(MIN_CRECIPPROPS, rgPropTags) = <br>    { <br>        MIN_CRECIPPROPS,  <br>        { <br>            PR_DISPLAY_NAME, <br>            PR_ADDRTYPE, <br>            PR_EMAIL_ADDRESS, <br>            PR_SEARCH_KEY, <br>            PR_ENTRYID, <br>            PR_SEND_RICH_INFO, <br>            PR_RESPONSIBILITY, <br>            PR_RECIPIENT_NUMBER, <br>            PR_ORIGINAL_DISPLAY_NAME, <br>            PR_ORIGINAL_ENTRYID, <br>            PR_EMS_AB_PROXY_ADDRESSES <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrMapAddrToProxy()\n"); <br> <br>    // <br>    // NOTE: PrepareRecips() will not create a value for PR_SEARCH_KEY. This is <br>    // why the following code has to check for PR_ADDRTYPE and PR_EMAIL_ADDRESS <br>    // and create a search key where possible. <br>    // <br> <br>    hr = MAPICALL(lpAdrBook)-&gt;PrepareRecips( <br>        lpAdrBook, <br>        0, <br>        (LPSPropTagArray)&amp;rgPropTags, <br>        lpAdrList); <br> <br>    if(HR_FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    for(i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>        lpProps = lpAdrList-&gt;aEntries[i].rgPropVals; <br> <br>        lpPropT = LpValFindProp( <br>            PR_ENTRYID, <br>            lpAdrList-&gt;aEntries[i].cValues, <br>            lpProps); <br> <br>        // <br>        // Check if this is a valid recipient entry. <br>        // <br> <br>        if((lpAdrList-&gt;aEntries[i].cValues &lt; MIN_CRECIPPROPS) || <br>           (lpPropT == NULL) || <br>           (PROP_TYPE(lpPropT-&gt;ulPropTag) == PT_ERROR)) <br>        { <br>            // <br>            // Add an empty recipient entry. <br>            // <br> <br>            MODULE_WARNING1("**** Adding an empty recipient entry [%lu] ****", i); <br> <br>            prop[0].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_DISPLAY_NAME)); <br>            prop[0].Value.err = MAPI_E_NOT_FOUND; <br>            prop[1].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_ADDRTYPE)); <br>            prop[1].Value.err = MAPI_E_NOT_FOUND; <br>            prop[2].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_EMAIL_ADDRESS)); <br>            prop[2].Value.err = MAPI_E_NOT_FOUND; <br>            prop[3].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_SEARCH_KEY)); </code></pre>
<p>
</p>
<pre><code>prop[3].Value.err = MAPI_E_NOT_FOUND; <br>            prop[4].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_SEND_RICH_INFO)); <br>            prop[4].Value.err = MAPI_E_NOT_FOUND; <br>            prop[5].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_ENTRYID)); <br>            prop[5].Value.err = MAPI_E_NOT_FOUND; <br>            prop[6].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_RESPONSIBILITY)); <br>            prop[6].Value.err = MAPI_E_NOT_FOUND; <br>            prop[7].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_RECIPIENT_NUMBER)); <br>            prop[7].Value.err = MAPI_E_NOT_FOUND; <br>            prop[8].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_ORIGINAL_DISPLAY_NAME)); <br>            prop[8].Value.err = MAPI_E_NOT_FOUND; <br>            prop[9].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_ORIGINAL_ENTRYID)); <br>            prop[9].Value.err = MAPI_E_NOT_FOUND; <br>            prop[10].ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_EMS_AB_PROXY_ADDRESSES)); <br>            prop[10].Value.err = MAPI_E_NOT_FOUND; <br> <br>            hr = HrMAPISetAddressList( <br>                i, <br>                MIN_CRECIPPROPS, <br>                prop, <br>                lpAdrList); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            lpProps = lpAdrList-&gt;aEntries[i].rgPropVals; <br>        } <br> <br>        // If the PR_RECIPIENT_NUMBER property is not set, default the value <br>        // to 1 <br> <br>        if((PROP_TYPE(lpProps[IRECIPNUM].ulPropTag) == PT_ERROR) &amp;&amp; <br>           (PROP_ID(lpProps[IRECIPNUM].ulPropTag) == PROP_ID(PR_RECIPIENT_NUMBER))) <br>        { <br>            lpProps[IRECIPNUM].ulPropTag = PR_RECIPIENT_NUMBER; <br>            lpProps[IRECIPNUM].Value.ul  = 1; <br>        } <br> <br>        // If the PR_SEND_RICH_INFO property is not set, default the value <br>        // to FALSE <br> <br>        if((PROP_TYPE(lpProps[IMAPIRECIP].ulPropTag) == PT_ERROR) &amp;&amp; <br>           (PROP_ID(lpProps[IMAPIRECIP].ulPropTag) == PROP_ID(PR_SEND_RICH_INFO))) <br>        { <br>            lpProps[IMAPIRECIP].ulPropTag = PR_SEND_RICH_INFO; <br>            lpProps[IMAPIRECIP].Value.b   = FALSE; <br>        } <br> <br>        // If the PR_RESPONSIBILITY property is not set, default the value <br>        // to FALSE <br> <br>        if((PROP_TYPE(lpProps[IRESP].ulPropTag) == PT_ERROR) &amp;&amp; <br>           (PROP_ID(lpProps[IRESP].ulPropTag) == PROP_ID(PR_RESPONSIBILITY))) <br>        { <br>            lpProps[IRESP].ulPropTag = PR_RESPONSIBILITY; <br>            lpProps[IRESP].Value.b   = FALSE; <br>        } <br> <br>        lpszProxyDisplayName = NULL; <br>        lpszProxyAddressType = NULL; <br>        lpszProxyAddress     = NULL; <br> <br>        // If the given address type matches the PR_ADDRTYPE value, <br>        // return the PR_EMAIL_ADDRESS value <br>     <br>        if((lpProps[IADDRTYPE].ulPropTag == PR_ADDRTYPE) &amp;&amp; <br>           (lpProps[IEMAILADDR].ulPropTag == PR_EMAIL_ADDRESS) &amp;&amp; <br>           (lstrcmpi(lpProps[IADDRTYPE].Value.LPSZ, lpszAddrType) == 0)) <br>        { <br>            lpszProxyAddressType = lpProps[IADDRTYPE].Value.LPSZ; <br>            lpszProxyAddress = lpProps[IEMAILADDR].Value.LPSZ; <br>        } <br> <br>        // <br>        // Search for a PR_EMS_AB_PROXY_ADDRESSES of the given type if present. <br>        // <br> <br>        else if(lpProps[IPROXYADDR].ulPropTag == PR_EMS_AB_PROXY_ADDRESSES) <br>        { <br>            BOOL IsFound = FALSE; <br> <br>            // <br>            // Count of proxy addresses <br>            // <br> <br>            cProxy = lpAdrList-&gt;aEntries[i].rgPropVals[IPROXYADDR].Value.MVSZ.cValues; <br> <br>            IsFound = FALSE; <br> <br>            for(j = 0; j &lt; cProxy; j++) <br>            { <br>                hr = HrCheckForType( <br>                    (LPUNKNOWN)lpProps, <br>                    lpszAddrType,  <br>                    lpProps[IPROXYADDR].Value.MVSZ.LPPSZ[j], <br>                    &amp;lpszProxyAddress); <br> <br>                if(hr == EDK_E_NOT_FOUND) <br>                { <br>                    continue; <br>                } <br>                else if(FAILED(hr)) <br>                { <br>                    goto cleanup; <br>                } <br>                else <br>                { <br>                    IsFound = TRUE; <br>                    break; <br>                } <br>            } <br> <br>            if(IsFound == FALSE) <br>            { <br>                MODULE_WARNING("A proxy address was not found!"); <br> <br>                if(lpProps[IADDRTYPE].ulPropTag == PR_ADDRTYPE) <br>                { <br>                    lpszProxyAddressType = lpProps[IADDRTYPE].Value.LPSZ; <br>                } <br> <br>                if(lpProps[IEMAILADDR].ulPropTag == PR_EMAIL_ADDRESS) <br>                { <br>                    lpszProxyAddress = lpProps[IEMAILADDR].Value.LPSZ; <br>                } <br>            } <br>            else <br>            { <br>                lpszProxyAddressType = lpszAddrType; <br>            } <br>        } <br>        else <br>        { <br>            if(lpProps[IADDRTYPE].ulPropTag == PR_ADDRTYPE) <br>            { <br>                lpszProxyAddressType = lpProps[IADDRTYPE].Value.LPSZ; <br>            } <br> <br>            if(lpProps[IEMAILADDR].ulPropTag == PR_EMAIL_ADDRESS) <br>            { <br>                lpszProxyAddress = lpProps[IEMAILADDR].Value.LPSZ; <br>            } <br>        } <br> <br>        // <br>        // Update proxy display name <br>        // <br> <br>        if((lpProps[IDISPNAME].ulPropTag != PR_DISPLAY_NAME) || <br>           (lpProps[IDISPNAME].Value.LPSZ == NULL) || <br>           (lstrlen(lpProps[IDISPNAME].Value.LPSZ) == 0)) <br>        { <br>            if(lpszProxyAddress != NULL) <br>            { <br>                lpszProxyDisplayName = lpszProxyAddress; <br>            } <br>            else <br>            { <br>                lpszProxyDisplayName = NULL; <br>            } <br>        } <br>        else <br>        { <br>            lpszProxyDisplayName = lpProps[IDISPNAME].Value.LPSZ; <br>        } <br> <br>        // <br>        // Create a proxy address <br>        // <br> <br>        if((lpszProxyDisplayName != NULL) &amp;&amp; <br>           (lpszProxyAddressType != NULL) &amp;&amp; <br>           (lpszProxyAddress != NULL)) <br>        { <br>            lpszEmailDisplayName = NULL; <br>            lpszEmailAddressType = NULL; <br>            lpszEmailAddress     = NULL; <br>            lpszEmailSearchKey   = NULL; <br>            cbEmailEid           = 0; <br>            lpEmailEid           = NULL; <br> <br>            hr = HrCreateProxyAddress( <br>                lpAdrBook, <br>                lpProps, <br>                lpProps[IMAPIRECIP].Value.b, <br>                lpszProxyDisplayName, <br>                lpszProxyAddressType, <br>                lpszProxyAddress, <br>                &amp;lpszEmailDisplayName, <br>                &amp;lpszEmailAddressType, <br>                &amp;lpszEmailAddress, <br>                &amp;lpszEmailSearchKey, <br>                &amp;cbEmailEid, <br>                &amp;lpEmailEid); <br> <br>            if(FAILED(hr)) <br>            { <br>                goto cleanup; <br>            } <br> <br>            lpProps[IDISPNAME].ulPropTag    = PR_DISPLAY_NAME; <br>            lpProps[IDISPNAME].Value.LPSZ   = lpszEmailDisplayName; <br> <br>            lpProps[IADDRTYPE].ulPropTag    = PR_ADDRTYPE; <br>            lpProps[IADDRTYPE].Value.LPSZ   = lpszEmailAddressType; <br> <br>            lpProps[IEMAILADDR].ulPropTag   = PR_EMAIL_ADDRESS; <br>            lpProps[IEMAILADDR].Value.LPSZ  = lpszEmailAddress; <br> <br>            lpProps[ISEARCHKEY].ulPropTag   = PR_SEARCH_KEY; <br> <br>            if(lpszEmailSearchKey == NULL) <br>            { <br>                lpProps[ISEARCHKEY].Value.bin.cb  = 0; <br>                lpProps[ISEARCHKEY].Value.bin.lpb = NULL; <br>            } <br>            else <br>            { <br>                lpProps[ISEARCHKEY].Value.bin.cb  = cbStrLen(lpszEmailSearchKey); <br>                lpProps[ISEARCHKEY].Value.bin.lpb = lpszEmailSearchKey; <br>            } <br> <br>            lpProps[IENTRYID].ulPropTag     = PR_ENTRYID; <br>            lpProps[IENTRYID].Value.bin.cb  = cbEmailEid; <br>            lpProps[IENTRYID].Value.bin.lpb = (LPBYTE)lpEmailEid; <br>        } <br>        else <br>        { <br>            MODULE_WARNING("Unable to create a proxy address!"); <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCollapseMessageAddressList----------------------------------------------- <br>// Collapse a list of addresses on the message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCollapseMessageAddressList(   // RETURNS: return code <br>    IN LPMESSAGE     lpMessage,         // pointer to message <br>    IN ULONG         cMesgAddr,         // count of message addresses <br>    IN ULONG         cReplyAddr,        // count of reply recipient addresses <br>    IN ULONG         cRecipAddr,        // count of recipient addresses <br>    IN LPADRLIST     lpAdrList,         // message address list <br>    OUT ULONG        *lpcValues,        // count of message address properties <br>    OUT LPSPropValue *lppProps,         // message address properties <br>    OUT LPADRLIST    *lppAdrList)       // recipient address list <br>{ <br>    HRESULT      hr            = NOERROR; <br>    SCODE        sc            = 0; <br>    LPSPropValue lpMesgProps   = NULL; <br>    LPTSTR       *lppDispNames = NULL; <br>    SBinary      *lppEntryIDs  = NULL; <br>    ULONG        cBytes        = 0; <br>    ULONG        i             = 0; <br>    ULONG        j             = 0; <br>    ULONG        cOrigAddr     = 0; <br>    LPADRLIST    lpRecipList   = 0; <br> <br>    ULONG        cValues       = 0; <br>    LPSPropValue lpProps       = NULL; <br> <br>#define CMESGPROPS 70 <br> <br>    SizedSPropTagArray(CMESGPROPS, rgPropTags) = <br>    { <br>        CMESGPROPS, <br>        { <br>            PR_SENDER_NAME, <br>            PR_SENDER_ADDRTYPE, <br>            PR_SENDER_EMAIL_ADDRESS, <br>            PR_SENDER_SEARCH_KEY, <br>            PR_SENDER_ENTRYID, <br>            PR_SENT_REPRESENTING_NAME, <br>            PR_SENT_REPRESENTING_ADDRTYPE, <br>            PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>            PR_SENT_REPRESENTING_SEARCH_KEY, <br>            PR_SENT_REPRESENTING_ENTRYID, <br>            PR_ORIGINAL_SENDER_NAME, <br>            PR_ORIGINAL_SENDER_ADDRTYPE, <br>            PR_ORIGINAL_SENDER_EMAIL_ADDRESS, <br>            PR_ORIGINAL_SENDER_SEARCH_KEY, <br>            PR_ORIGINAL_SENDER_ENTRYID, <br>            PR_ORIGINAL_SENT_REPRESENTING_NAME, <br>            PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE, <br>            PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS, <br>            PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY, <br>            PR_ORIGINAL_SENT_REPRESENTING_ENTRYID, <br>            PR_RECEIVED_BY_NAME, <br>            PR_NULL,//PR_RECEIVED_BY_ADDRTYPE, <br>            PR_NULL,//PR_RECEIVED_BY_EMAIL_ADDRESS, <br>            PR_RECEIVED_BY_SEARCH_KEY, <br>            PR_RECEIVED_BY_ENTRYID, <br>            PR_RCVD_REPRESENTING_NAME, <br>            PR_NULL,//PR_RCVD_REPRESENTING_ADDRTYPE, <br>            PR_NULL,//PR_RCVD_REPRESENTING_EMAIL_ADDRESS, <br>            PR_RCVD_REPRESENTING_SEARCH_KEY, <br>            PR_RCVD_REPRESENTING_ENTRYID, <br>            PR_ORIGINAL_AUTHOR_NAME, <br>            PR_ORIGINAL_AUTHOR_ADDRTYPE, <br>            PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS, <br>            PR_ORIGINAL_AUTHOR_SEARCH_KEY, <br>            PR_ORIGINAL_AUTHOR_ENTRYID, <br>            PR_REPORT_NAME, <br>            PR_NULL,//PR_REPORT_ADDRTYPE, <br>            PR_NULL,//PR_REPORT_EMAIL_ADDRESS, <br>            PR_REPORT_SEARCH_KEY, <br>            PR_REPORT_ENTRYID, <br>            PR_NULL,//PR_READ_RECEIPT_NAME, <br>            PR_NULL,//PR_READ_RECEIPT_ADDRTYPE, <br>            PR_NULL,//PR_READ_RECEIPT_EMAIL_ADDRESS, <br>            PR_READ_RECEIPT_SEARCH_KEY, <br>            PR_READ_RECEIPT_ENTRYID, <br>            PR_ORIGINATOR_NAME, <br>            PR_ORIGINATOR_ADDRTYPE, <br>            PR_ORIGINATOR_ADDR,//PR_ORIGINATOR_EMAIL_ADDRESS, <br>            PR_NULL,//PR_ORIGINATOR_SEARCH_KEY, <br>            PR_ORIGINATOR_ENTRYID, <br>            PR_REPORT_DESTINATION_NAME, <br>            PR_NULL,//PR_REPORT_DESTINATION_ADDRTYPE, <br>            PR_NULL,//PR_REPORT_DESTINATION_EMAIL_ADDRESS, <br>            PR_NULL,//PR_REPORT_DESTINATION_SEARCH_KEY, <br>            PR_REPORT_DESTINATION_ENTRYID, <br>            PR_CREATOR_NAME, <br>            PR_NULL,//PR_CREATOR_ADDRTYPE, <br>            PR_NULL,//PR_CREATOR_EMAIL_ADDRESS, <br>            PR_NULL,//PR_CREATOR_SEARCH_KEY, <br>            PR_CREATOR_ENTRYID, <br>            PR_LAST_MODIFIER_NAME, <br>            PR_NULL,//PR_LAST_MODIFIER_ADDRTYPE, <br>            PR_NULL,//PR_LAST_MODIFIER_EMAIL_ADDRESS, <br>            PR_NULL,//PR_LAST_MODIFIER_SEARCH_KEY, <br>            PR_LAST_MODIFIER_ENTRYID, <br>            //PR_ORIGINALLY_INTENDED_RECIPIENT_NAME, <br>            //PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE, <br>            //PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS, <br>            //PR_NULL,//PR_ORIGINALLY_INTENDED_RECIP_SEARCH_KEY, <br>            //PR_ORIGINALLY_INTENDED_RECIP_ENTRYID, <br>            PR_REPLY_RECIPIENT_NAMES, <br>            PR_NULL,//PR_REPLY_RECIPIENT_ADDRTYPE, <br>            PR_NULL,//PR_REPLY_RECIPIENT_EMAIL_ADDRESS, <br>            PR_NULL,//PR_REPLY_RECIPIENT_SEARCH_KEY, <br>            PR_REPLY_RECIPIENT_ENTRIES, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrCollapseMessageAddressList()\n"); <br> <br>    if(cMesgAddr != (CMESGPROPS/5-1)) <br>    { <br>        hr = HR_LOG(E_INVALIDARG);                                  <br>        goto cleanup;                                 <br>    } <br> <br>    if((cMesgAddr + cReplyAddr + cRecipAddr) &gt; lpAdrList-&gt;cEntries) <br>    { <br>        hr = HR_LOG(E_INVALIDARG);                                  <br>        goto cleanup;                                 <br>    } <br> <br>    cOrigAddr = lpAdrList-&gt;cEntries - (cMesgAddr + cReplyAddr + cRecipAddr); <br> <br>    cBytes = CbNewSPropValue(CMESGPROPS); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)&amp;lpMesgProps); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    ZeroMemory(lpMesgProps, cBytes); <br> <br>    // <br>    // Copy message address properties <br>    // <br> <br>    for(i = 0; i &lt; (CMESGPROPS/5-1); i++) <br>    { <br>        if(PROP_ID(lpAdrList-&gt;aEntries[i].rgPropVals[IDISPNAME].ulPropTag) != <br>           PROP_ID(PR_DISPLAY_NAME)) <br>        { <br>            hr = HR_LOG(E_FAIL);                                  <br>            goto cleanup;                                 <br>        } <br> <br>        if(rgPropTags.aulPropTag[i*5+IDISPNAME] != PR_NULL) <br>        { <br>            lpMesgProps[i*5+IDISPNAME].ulPropTag = <br>                PROP_TAG( <br>                    PROP_TYPE(lpAdrList-&gt;aEntries[i].rgPropVals[IDISPNAME].ulPropTag), <br>                    PROP_ID(rgPropTags.aulPropTag[i*5+IDISPNAME])); <br>        } <br>        else <br>        { <br>            lpMesgProps[i*5+IDISPNAME].ulPropTag = PR_NULL; <br>        } <br> <br>        lpMesgProps[i*5+IDISPNAME].Value.LPSZ = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IDISPNAME].Value.LPSZ; <br> <br>        if(rgPropTags.aulPropTag[i*5+IADDRTYPE] != PR_NULL) <br>        { <br>            lpMesgProps[i*5+IADDRTYPE].ulPropTag = <br>                PROP_TAG( <br>                    PROP_TYPE(lpAdrList-&gt;aEntries[i].rgPropVals[IADDRTYPE].ulPropTag), <br>                    PROP_ID(rgPropTags.aulPropTag[i*5+IADDRTYPE])); <br>        } <br>        else <br>        { <br>            lpMesgProps[i*5+IADDRTYPE].ulPropTag = PR_NULL; <br>        } <br> <br>        lpMesgProps[i*5+IADDRTYPE].Value.LPSZ = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IADDRTYPE].Value.LPSZ; <br> <br>        if(rgPropTags.aulPropTag[i*5+IEMAILADDR] != PR_NULL) <br>        { <br>            lpMesgProps[i*5+IEMAILADDR].ulPropTag = <br>                PROP_TAG( <br>                    PROP_TYPE(lpAdrList-&gt;aEntries[i].rgPropVals[IEMAILADDR].ulPropTag), <br>                    PROP_ID(rgPropTags.aulPropTag[i*5+IEMAILADDR])); <br>        } <br>        else <br>        { <br>            lpMesgProps[i*5+IEMAILADDR].ulPropTag = PR_NULL; <br>        } <br> <br>        lpMesgProps[i*5+IEMAILADDR].Value.LPSZ = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IEMAILADDR].Value.LPSZ; <br> <br>        if(rgPropTags.aulPropTag[i*5+ISEARCHKEY] != PR_NULL) <br>        { <br>            lpMesgProps[i*5+ISEARCHKEY].ulPropTag = <br>                PROP_TAG( <br>                    PROP_TYPE(lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].ulPropTag), <br>                    PROP_ID(rgPropTags.aulPropTag[i*5+ISEARCHKEY])); <br>        } <br>        else <br>        { <br>            lpMesgProps[i*5+ISEARCHKEY].ulPropTag = PR_NULL; <br>        } <br> <br>        lpMesgProps[i*5+ISEARCHKEY].Value.bin.cb = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].Value.bin.cb; <br>        lpMesgProps[i*5+ISEARCHKEY].Value.bin.lpb = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].Value.bin.lpb; <br> <br>        if(rgPropTags.aulPropTag[i*5+IENTRYID] != PR_NULL) <br>        { <br>            lpMesgProps[i*5+IENTRYID].ulPropTag = <br>                PROP_TAG( <br>                    PROP_TYPE(lpAdrList-&gt;aEntries[i].rgPropVals[IENTRYID].ulPropTag), <br>                    PROP_ID(rgPropTags.aulPropTag[i*5+IENTRYID])); <br>        } <br>        else <br>        { <br>            lpMesgProps[i*5+IENTRYID].ulPropTag = PR_NULL; <br>        } <br> <br>        lpMesgProps[i*5+IENTRYID].Value.bin.cb = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IENTRYID].Value.bin.cb; <br>        lpMesgProps[i*5+IENTRYID].Value.bin.lpb = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IENTRYID].Value.bin.lpb; <br>    } <br> <br>    // <br>    // Copy reply recipient properties <br>    // <br> <br>    if(cReplyAddr &gt; 0) <br>    { <br>        // <br>        // Copy reply recipient names <br>        // <br> <br>        cBytes = cReplyAddr*(sizeof(LPTSTR)+MAX_ALIGN); <br> <br>        sc = MAPIAllocateBuffer(cBytes, (void **)&amp;lppDispNames); <br> <br>        if(FAILED(sc))                            <br>        {                                                    <br>            hr = HR_LOG(E_OUTOFMEMORY);                                  <br>            goto cleanup;                                 <br>        }                                                    <br> <br>        ZeroMemory(lppDispNames, cBytes); <br> <br>        for(i = 0, j = cMesgAddr; i &lt; cReplyAddr; i++, j++) <br>        { <br>            lppDispNames[i] = <br>                lpAdrList-&gt;aEntries[j].rgPropVals[IDISPNAME].Value.LPSZ; <br>        } <br> <br>        // <br>        // Copy reply recipient entry IDs <br>        // <br> <br>        cBytes = cReplyAddr*(sizeof(SBinary)+MAX_ALIGN); <br> <br>        sc = MAPIAllocateBuffer(cBytes, (void **)&amp;lppEntryIDs); <br> <br>        if(FAILED(sc))                            <br>        {                                                    <br>            hr = HR_LOG(E_OUTOFMEMORY);                                  <br>            goto cleanup;                                 <br>        }                                                    <br> <br>        ZeroMemory(lppDispNames, cBytes); <br> <br>        for(i = 0, j = cMesgAddr; i &lt; cReplyAddr; i++, j++) <br>        { <br>            lppEntryIDs[i].cb = <br>                lpAdrList-&gt;aEntries[j].rgPropVals[IENTRYID].Value.bin.cb; <br> <br>            lppEntryIDs[i].lpb = <br>                lpAdrList-&gt;aEntries[j].rgPropVals[IENTRYID].Value.bin.lpb; <br>        } <br> <br>        lpMesgProps[CMESGPROPS-5].ulPropTag = rgPropTags.aulPropTag[CMESGPROPS-5]; <br>        lpMesgProps[CMESGPROPS-5].Value.MVSZ.cValues = cReplyAddr; <br>        lpMesgProps[CMESGPROPS-5].Value.MVSZ.LPPSZ   = lppDispNames; <br> <br>        lpMesgProps[CMESGPROPS-4].ulPropTag = rgPropTags.aulPropTag[CMESGPROPS-4]; <br>        lpMesgProps[CMESGPROPS-3].ulPropTag = rgPropTags.aulPropTag[CMESGPROPS-3]; <br>        lpMesgProps[CMESGPROPS-2].ulPropTag = rgPropTags.aulPropTag[CMESGPROPS-2]; <br> <br>        lpMesgProps[CMESGPROPS-1].ulPropTag = rgPropTags.aulPropTag[CMESGPROPS-1]; <br>        lpMesgProps[CMESGPROPS-1].Value.MVbin.cValues = cReplyAddr; <br>        lpMesgProps[CMESGPROPS-1].Value.MVbin.lpbin   = lppEntryIDs; <br>    } <br>    else <br>    { <br>        lpMesgProps[CMESGPROPS-5].ulPropTag = <br>            PROP_TAG(PT_ERROR,PROP_ID(rgPropTags.aulPropTag[CMESGPROPS-5])); <br>        lpMesgProps[CMESGPROPS-5].Value.err = MAPI_E_NOT_FOUND; <br> <br>        lpMesgProps[CMESGPROPS-4].ulPropTag = rgPropTags.aulPropTag[CMESGPROPS-4]; <br>        lpMesgProps[CMESGPROPS-3].ulPropTag = rgPropTags.aulPropTag[CMESGPROPS-3]; <br>        lpMesgProps[CMESGPROPS-2].ulPropTag = rgPropTags.aulPropTag[CMESGPROPS-2]; <br> <br>        lpMesgProps[CMESGPROPS-1].ulPropTag = <br>            PROP_TAG(PT_ERROR,PROP_ID(rgPropTags.aulPropTag[CMESGPROPS-1])); <br>        lpMesgProps[CMESGPROPS-1].Value.err = MAPI_E_NOT_FOUND; <br>    } <br> <br>    // <br>    // Duplicate message properties <br>    // <br> <br>    cValues = CMESGPROPS; <br>    lpProps = NULL; <br> <br>    sc = ScDupPropset( <br>        cValues, <br>        lpMesgProps, <br>MAPIAllocateBuffer, <br>&amp;lpProps); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Copy recipient address list <br>    // <br> <br>    hr = HrMAPICreateSizedAddressList( <br>        cRecipAddr, <br>        &amp;lpRecipList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    for(i = 0, j = (cMesgAddr + cReplyAddr); i &lt; cRecipAddr; i++, j++) <br>    { <br>        lpRecipList-&gt;aEntries[i] = lpAdrList-&gt;aEntries[j]; <br>    } <br> <br>    // <br>    // Copy original recipient information <br>    // <br> <br>    for(i = (cMesgAddr + cReplyAddr + cRecipAddr); i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>        j = lpAdrList-&gt;aEntries[i].rgPropVals[IRECIPNUM].Value.ul; <br> <br> <br>        lpRecipList-&gt;aEntries[j].rgPropVals[IORIGDISP] = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IDISPNAME]; <br>        lpRecipList-&gt;aEntries[j].rgPropVals[IORIGDISP].ulPropTag  = <br>            PR_ORIGINAL_DISPLAY_NAME; <br> <br>        lpRecipList-&gt;aEntries[j].rgPropVals[IORIGENTRY] = <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IENTRYID]; <br>        lpRecipList-&gt;aEntries[j].rgPropVals[IORIGENTRY].ulPropTag = <br>            PR_ORIGINAL_ENTRYID; <br>    } <br> <br>    // <br>    // Duplicate updated address list <br>    // <br> <br>    hr = HrMAPICreateSizedAddressList( <br>        lpRecipList-&gt;cEntries, <br>        lppAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    for(i = 0; i &lt; lpRecipList-&gt;cEntries; i++) <br>    { <br>        if(lpRecipList-&gt;aEntries[i].cValues &lt; MIN_CRECIPPROPS) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // <br>        // Unregistered named properties cannot be set on the recipient list. <br>        // <br>                     <br>        lpRecipList-&gt;aEntries[i].rgPropVals[IPROXYADDR].ulPropTag = PR_NULL; <br>        lpRecipList-&gt;aEntries[i].rgPropVals[IPROXYADDR].Value.ul  = 0; <br> <br> <br>        hr = HrMAPISetAddressList( <br>            i, <br>            lpRecipList-&gt;aEntries[i].cValues, <br>            lpRecipList-&gt;aEntries[i].rgPropVals, <br>            *lppAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br>         <br>    *lpcValues  = cValues; <br>    *lppProps   = lpProps; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        *lpcValues = 0; <br> <br>        if(lppProps != NULL) <br>        { <br>            MAPIFREEBUFFER(*lppProps); <br>        } <br> <br>        if(lppAdrList != NULL) <br>        { <br>            FREEPADRLIST(*lppAdrList); <br>        } <br>    } <br> <br>    MAPIFREEBUFFER(lpMesgProps); <br> <br>    MAPIFREEBUFFER(lppDispNames); <br> <br>    MAPIFREEBUFFER(lppEntryIDs); <br> <br>    MAPIFREEBUFFER(lpRecipList); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMapProxyToAddr----------------------------------------------------------- <br>// Map all proxy addresses to email addresses in a given address list. Always <br>// call HrMapAddrToProxy() before calling this function. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMapProxyToAddr(               // RETURNS: return code <br>    IN  LPADRBOOK    lpAdrBook,         // pointer to address book <br>    IN  LPABCONT     lpGalABCont,       // pointer to GAL container <br>    IN OUT LPADRLIST lpAdrList)         // pointer to address list <br>{ <br>    HRESULT         hr                   = NOERROR; <br>    HRESULT         hrT                  = NOERROR; <br>    SCODE           sc                   = 0; <br>    ULONG           i                    = 0; <br> <br>    SPropValue      prop[2]              = {0}; <br>    LPFlagList      lpFlagList           = NULL; <br>    LPADRLIST       lpRecipList          = NULL; <br> <br>    LPTSTR          lpszEmailDisplayName = NULL; <br>    LPTSTR          lpszEmailAddressType = NULL; <br>    LPTSTR          lpszEmailAddress     = NULL; <br>    LPTSTR          lpszEmailSearchKey   = NULL; <br>    ULONG           cbEmailEid           = 0; <br>    LPENTRYID       lpEmailEid           = NULL; <br> <br>    SizedSPropTagArray(MIN_CRECIPPROPS, rgPropTags) = <br>    { <br>        MIN_CRECIPPROPS,  <br>        { <br>            PR_DISPLAY_NAME, <br>            PR_ADDRTYPE, <br>            PR_EMAIL_ADDRESS, <br>            PR_SEARCH_KEY, <br>            PR_ENTRYID, <br>            PR_SEND_RICH_INFO, <br>            PR_RESPONSIBILITY, <br>            PR_RECIPIENT_NUMBER, <br>            PR_ORIGINAL_DISPLAY_NAME, <br>            PR_ORIGINAL_ENTRYID, <br>            PR_RECIPSTAT <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrMapProxyToAddr()\n"); <br> <br>    sc = MAPIAllocateBuffer( CbNewFlagList(lpAdrList-&gt;cEntries), (LPVOID*)&amp;lpFlagList); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    lpFlagList-&gt;cFlags = lpAdrList-&gt;cEntries; <br> <br>    for(i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>        lpFlagList-&gt;ulFlag[i] = MAPI_UNRESOLVED; <br>    } <br> <br>    hr = HrMAPICreateSizedAddressList(lpAdrList-&gt;cEntries, &amp;lpRecipList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    for(i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>        if((lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].ulPropTag != PR_SEARCH_KEY) || <br>           (lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].Value.bin.cb == 0) || <br>           (lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].Value.bin.lpb == NULL)) <br>        { <br>            prop[0].ulPropTag  = PR_DISPLAY_NAME; <br>            prop[0].Value.LPSZ = TEXT("UNKNOWN:UNKNOWN"); <br>        } <br>        else <br>        { <br>            prop[0].ulPropTag  = PR_DISPLAY_NAME; <br>            prop[0].Value.LPSZ = <br>                (LPTSTR)lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].Value.bin.lpb; <br>        } <br> <br>        prop[1].ulPropTag = PR_RECIPIENT_TYPE; <br>        prop[1].Value.ul = MAPI_TO; <br> <br>        hr = HrMAPISetAddressList( <br>            i, <br>            2, <br>            prop, <br>            lpRecipList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    hr = MAPICALL(lpGalABCont)-&gt;ResolveNames( <br>        lpGalABCont, <br>        (LPSPropTagArray)&amp;rgPropTags, <br>        EMS_AB_ADDRESS_LOOKUP, <br>        lpRecipList, <br>        lpFlagList); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    for(i = 0; i &lt; lpRecipList-&gt;cEntries; i++) <br>    { <br>        if(lpFlagList-&gt;ulFlag[i] != MAPI_RESOLVED) <br>        { <br>            if(lpFlagList-&gt;ulFlag[i] == MAPI_AMBIGUOUS) <br>            { <br>                hrT = MAPI_E_AMBIGUOUS_RECIP; <br>            } <br>            else <br>            { <br>                hrT = NOERROR; // MAPI_E_NOT_FOUND <br>            } <br>        } <br>        else <br>        { <br>            // <br>            // Update recipient entry only if an email address was found <br>            // <br> <br>            lpszEmailDisplayName = NULL; <br>            lpszEmailAddressType = NULL; <br>            lpszEmailAddress     = NULL; <br>            lpszEmailSearchKey   = NULL; <br>            cbEmailEid           = 0; <br>            lpEmailEid           = NULL;             <br> <br>            hr = HrCreateEmailAddress( <br>                lpAdrBook, <br>                lpAdrList-&gt;aEntries[i].rgPropVals, <br>                lpRecipList-&gt;aEntries[i].rgPropVals[IDISPNAME].Value.LPSZ, <br>                lpRecipList-&gt;aEntries[i].rgPropVals[IADDRTYPE].Value.LPSZ, <br>                lpRecipList-&gt;aEntries[i].rgPropVals[IEMAILADDR].Value.LPSZ, <br>                lpRecipList-&gt;aEntries[i].rgPropVals[IENTRYID].Value.bin.cb, <br>                (LPENTRYID)lpRecipList-&gt;aEntries[i].rgPropVals[IENTRYID].Value.bin.lpb, <br>                &amp;lpszEmailDisplayName, <br>                &amp;lpszEmailAddressType, <br>                &amp;lpszEmailAddress, <br>                &amp;lpszEmailSearchKey, <br>                &amp;cbEmailEid, <br>                &amp;lpEmailEid); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IDISPNAME].Value.LPSZ  = <br>                lpszEmailDisplayName; <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IADDRTYPE].Value.LPSZ  = <br>                lpszEmailAddressType; <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IEMAILADDR].Value.LPSZ = <br>                lpszEmailAddress; <br>             <br>            if(lpszEmailSearchKey == NULL) <br>            { <br>                lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].Value.bin.cb = 0; <br>            } <br>            else <br>            { <br>                lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].Value.bin.cb = <br>                    cbStrLen(lpszEmailSearchKey); <br>            } <br> <br>            lpAdrList-&gt;aEntries[i].rgPropVals[ISEARCHKEY].Value.bin.lpb = <br>                (LPBYTE)lpszEmailSearchKey; <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IENTRYID].Value.bin.cb  = <br>                cbEmailEid; <br>            lpAdrList-&gt;aEntries[i].rgPropVals[IENTRYID].Value.bin.lpb = <br>                (LPBYTE)lpEmailEid; <br> <br>            hrT = NOERROR; <br>        } <br> <br>        // <br>        // Add recipient status to recipient entry in address list <br>        // </code></pre>
<p>
</p>
<pre><code><br>        lpAdrList-&gt;aEntries[i].rgPropVals[IRECIPSTAT].ulPropTag = <br>            PR_RECIPSTAT; <br>        lpAdrList-&gt;aEntries[i].rgPropVals[IRECIPSTAT].Value.ul = hrT; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpFlagList); <br> <br>    FREEPADRLIST(lpRecipList); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrNonDeliverRecipient------------------------------------------------------ <br>// Non-deliver a recipient. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrNonDeliverRecipient(          // RETURNS: return code <br>    IN ULONG ulReasonCode,              // NDR reason code <br>    IN ULONG ulDiagnosticCode,          // NDR diagnostic code <br>    IN LPFILETIME lpftReportTime,       // report time <br>    IN ULONG ulRecipientNumber,         // recipient number <br>    IN ULONG ulOffset,                  // offset in NDR address list <br>    IN ULONG cValues,                   // count of property values <br>    IN LPSPropValue lpProps,            // pointer to property values <br>    IN OUT LPADRLIST lpAdrList)         // pointer to NDR address list <br>{ <br>    HRESULT      hr              = NOERROR; <br>    ULONG        i               = 0; <br>    ULONG        j               = 0; <br>    ULONG        ulExtraProps[4] = {0}; <br>    LPSPropValue lpExtraProps[4] = {NULL}; <br>    SPropValue   ExtraProps[5]   = {0}; <br>    ULONG        cNewValues      = 0; <br>    LPSPropValue lpNewProps      = NULL; <br>    LPSPropValue lpPropT         = NULL; <br> <br>    DEBUGPUBLIC("HrNonDeliverRecipient()\n"); <br> <br>    lpPropT = LpValFindProp(PR_NDR_REASON_CODE, cValues, lpProps); <br> <br>    if(lpPropT != NULL) <br>    { <br>        ulExtraProps[j  ]  = lpPropT-&gt;ulPropTag; <br>        lpExtraProps[j++]  = lpPropT; <br>        lpPropT-&gt;ulPropTag = PR_NULL; <br>    } <br> <br>    ExtraProps[i].ulPropTag = PR_NDR_REASON_CODE; <br>    ExtraProps[i].Value.ul  = ulReasonCode; <br>    i++; <br> <br>    lpPropT = LpValFindProp(PR_NDR_DIAG_CODE, cValues, lpProps); <br> <br>    if(lpPropT != NULL) <br>    { <br>        ulExtraProps[j  ]  = lpPropT-&gt;ulPropTag; <br>        lpExtraProps[j++]  = lpPropT; <br>        lpPropT-&gt;ulPropTag = PR_NULL; <br>    } <br> <br>    ExtraProps[i].ulPropTag = PR_NDR_DIAG_CODE; <br>    ExtraProps[i].Value.ul  = ulDiagnosticCode; <br>    i++; <br> <br>    lpPropT = LpValFindProp(PR_REPORT_TIME, cValues, lpProps); <br> <br>    if(lpPropT != NULL) <br>    { <br>        ulExtraProps[j  ]  = lpPropT-&gt;ulPropTag; <br>        lpExtraProps[j++]  = lpPropT; <br>        lpPropT-&gt;ulPropTag = PR_NULL; <br>    } <br> <br>    ExtraProps[i].ulPropTag = PR_REPORT_TIME; <br>    ExtraProps[i].Value.ft  = *lpftReportTime; <br>    i++; <br> <br>    lpPropT = LpValFindProp(PR_REPORT_TEXT, cValues, lpProps); <br> <br>    if(lpPropT != NULL) <br>    { <br>        ulExtraProps[j  ]  = lpPropT-&gt;ulPropTag; <br>        lpExtraProps[j++]  = lpPropT; <br>        lpPropT-&gt;ulPropTag = PR_NULL; <br>    } <br> <br>    ExtraProps[i].ulPropTag  = PR_REPORT_TEXT; <br>    ExtraProps[i].Value.LPSZ = TEXT(""); <br>    i++; <br> <br>    lpPropT = LpValFindProp(PR_RECIPIENT_NUMBER, cValues, lpProps); <br> <br>    if(lpPropT == NULL) <br>    { <br>        ExtraProps[i].ulPropTag = PR_RECIPIENT_NUMBER; <br>        ExtraProps[i].Value.ul  = ulRecipientNumber; <br>        i++; <br>    } <br> <br>    hr = HrMAPIAppendSPropValues( <br>        cValues, <br>        lpProps, <br>        i, <br>        ExtraProps, <br>        &amp;cNewValues, <br>        &amp;lpNewProps); <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpNewProps); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetAddressList( <br>        ulOffset, <br>        cNewValues, <br>        lpNewProps, <br>        lpAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpNewProps); <br> <br>    for(i = 0; i &lt; j; i++) <br>    { <br>        lpPropT = lpExtraProps[i]; <br>        lpPropT-&gt;ulPropTag = ulExtraProps[i]; <br>    } <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
