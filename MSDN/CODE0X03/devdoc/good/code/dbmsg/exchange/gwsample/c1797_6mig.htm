<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GWSAMPLE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1798"></a>GWSAMPLE.C</h2>
<pre><code>// --gwsample.c----------------------------------------------------------------- <br>// <br>//  Sample gateway application. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "gwmain.h" <br>#include "gwsample.h" <br>#include "attrname.h" <br>#include "convcwrp.h" <br>#include "ipmconv.h" <br>#include "sgwdata.h" <br> <br>TCHAR szAppName[]       = TEXT("GWSAMPLE"); <br>TCHAR szWindowTitle[]   = TEXT("Sample Gateway"); <br> <br>// Output/Input file name prefix. <br>TCHAR szFilePrefix[]    = TEXT("SGW"); <br> <br>#define C_EQU   TEXT("C=") <br>#define A_EQU   TEXT("A=") <br>#define P_EQU   TEXT("P=") <br> <br>static TCHAR szServiceName[MAX_SERVICE_NAME_LENGTH+1] = {0}; <br> <br>static LPTSTR           lpszLocalGDI    = NULL; <br>static CRITICAL_SECTION csGatewaySeqNo  = {0}; <br>static ULONG            ulGatewaySeqNo  = 0; <br> <br>static LPMAPISESSION    lpSession       = NULL; <br>static LPMDB            lpStore         = NULL; <br>static LPMAPIFOLDER     lpRootFolder    = NULL; <br>static LPMAPIFOLDER     lpMtsInFolder   = NULL; <br>static LPMAPIFOLDER     lpMtsOutFolder  = NULL; <br>static ULONG            cbGalEid        = 0; <br>static LPENTRYID        lpGalEid        = NULL; <br> <br>//performance code <br> <br>LONG    cInThreads           = 0; <br>ULONG   cInMessages          = 0; <br> <br>LPTSTR  lpszAddressType      = NULL; <br> <br>LPTSTR  lpszSysAdminName     = NULL; <br>LPTSTR  lpszSysAdminAddr     = NULL; <br> <br>LPTSTR  lpszInDirectory      = NULL; <br>LPTSTR  lpszInConverter      = NULL; <br>LPWSTR  lpszInConverterW     = NULL; <br> <br>BOOL    fInEnabled           = FALSE; <br> <br>ULONG   cbBufferSize         = 0; <br>LPBYTE  lpbBuffer            = NULL; <br>ULONG   cBufferArraySize     = 0; <br>LPTSTR  *lppszBufferArray    = NULL; <br> <br>DWORD   dwInSleepInterval    = 0; <br>DWORD   dwInPollInterval     = 0; <br> <br>LONG    cOutThreads          = 0; <br>ULONG   cOutMessages         = 0; <br> <br>LPTSTR  lpszOutDirectory     = NULL; <br>LPTSTR  lpszOutConverter     = NULL; <br>LPWSTR  lpszOutConverterW    = NULL; <br> <br>BOOL    fOutEnabled          = FALSE; <br> <br>DWORD   dwOutSleepInterval   = 0; <br>DWORD   dwOutPollInterval    = 0; <br> <br>LPTSTR  lpszArchiveDirectory = NULL; <br> <br>HANDLE  hEventLog            = NULL; <br> <br>typedef struct _id_item <br>{ <br>    CRITICAL_SECTION *lpcs;     // only used by list <br>    LPTSTR           lpszId; <br>    struct _id_item  *next; <br>} IDITEM, *LPIDITEM; <br> <br>static CRITICAL_SECTION csInboundIdList  = {0}; <br>static CRITICAL_SECTION csOutboundIdList = {0}; <br> <br>static IDITEM InboundIdList  = {0}; <br>static IDITEM OutboundIdList = {0}; <br> <br>// Size is because country 2-3, ADMD 0-16, PRMD is 1-16 and LocalId1-32 plus <br>// size for "/c=/p=/a=/l=". So 3+16+16+32+12+1 = 80. <br>#define cbMTSIDMax (80) <br> <br>//$--HrCreateIdItem------------------------------------------------------------- <br>//  Creates an ID item. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateIdItem(                 // RETURNS: return code <br>    IN  LPSTR lpszId,                   // identifier <br>    OUT LPIDITEM *lppIdItem)            // identifier item <br>{ <br>HRESULT  hr       = NOERROR; <br>    LPIDITEM lpIdItem = NULL; <br>    ULONG    cBytes   = 0; <br> <br>    *lppIdItem = NULL; <br> <br>    cBytes = sizeof(IDITEM); <br> <br>    hr = MAPIAllocateBuffer(cBytes, (void **)&amp;lpIdItem); <br> <br>    if(FAILED(hr)) <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    ZeroMemory(lpIdItem, cBytes); <br> <br>    cBytes  = cbStrLen(lpszId); <br> <br>    hr = MAPIAllocateMore(cBytes, lpIdItem, (void **)&amp;lpIdItem-&gt;lpszId); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lstrcpy(lpIdItem-&gt;lpszId, lpszId); <br> <br>    *lppIdItem = lpIdItem; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrDestroyIdItem------------------------------------------------------------ <br>//  Destroys an ID item. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrDestroyIdItem(                // RETURNS: return code <br>    IN OUT LPIDITEM *lppIdItem)         // identifier item <br>{ <br>HRESULT hr = NOERROR; <br> <br>    MAPIFREEBUFFER(*lppIdItem); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrLookupIdItem------------------------------------------------------------- <br>//  Looks up an ID item. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrLookupIdItem(                 // RETURNS: return code <br>    IN LPIDITEM lpIdList,               // identifier item list <br>    IN LPTSTR lpszId,                   // identifier <br>    IN OUT LPIDITEM *lppIdItem)         // identifier item <br>{ <br>HRESULT  hr       = EDK_E_NOT_FOUND; <br>    HRESULT  hrT      = NOERROR; <br>    LPIDITEM lpIdItem = NULL; <br> <br>    __try <br>    { <br>        *lppIdItem = NULL; <br> <br>        lpIdItem = lpIdList-&gt;next; <br>     <br>        while(lpIdItem != NULL) <br>        { <br>            if(!lstrcmpi(lpIdItem-&gt;lpszId, lpszId)) <br>            { <br>                // <br>                // Found identifier in ID list <br>                // <br> <br>                *lppIdItem = lpIdItem; <br> <br>                hr = NOERROR; <br>                goto cleanup; <br>            } <br> <br>            lpIdItem = lpIdItem-&gt;next; <br>        } <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrAddIdItem---------------------------------------------------------------- <br>//  Adds an ID item to a list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrAddIdItem(                    // RETURNS: return code <br>    IN LPIDITEM lpIdList,               // identifier item list <br>    IN LPTSTR lpszId,                   // identifier <br>    IN OUT LPIDITEM *lppIdItem)         // identifier item <br>{ <br>HRESULT  hr       = EDK_E_NOT_FOUND; <br>    HRESULT  hrT      = NOERROR; <br>    LPIDITEM lpIdItem = NULL; <br> <br>    EnterCriticalSection(lpIdList-&gt;lpcs); <br> <br>    hr = HrLookupIdItem(lpIdList, lpszId, &amp;lpIdItem); <br> <br>    if(hr != EDK_E_NOT_FOUND) <br>    { <br>        hr = HR_LOG(EDK_E_ALREADY_EXISTS); <br>        goto cleanup; <br>    } <br> <br>    __try <br>    { <br>        *lppIdItem = NULL; <br> <br>        hr = HrCreateIdItem( <br>            lpszId, <br>            &amp;lpIdItem); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        lpIdItem-&gt;next = lpIdList-&gt;next; <br> <br>        lpIdList-&gt;next = lpIdItem; <br> <br>        *lppIdItem = lpIdItem; <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>cleanup: <br> <br>    LeaveCriticalSection(lpIdList-&gt;lpcs); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveIdItem------------------------------------------------------------- <br>//  Removes an ID item from a list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveIdItem(                 // RETURNS: return code <br>    IN LPIDITEM lpIdList,               // identifier item list <br>    IN LPIDITEM lpIdItem)               // identifier item <br>{ <br>HRESULT  hr           = EDK_E_NOT_FOUND; <br>    HRESULT  hrT          = NOERROR; <br>    LPIDITEM lpPrevIdItem = NULL; <br>    LPIDITEM lpCurrIdItem = NULL; <br> <br>    EnterCriticalSection(lpIdList-&gt;lpcs); <br> <br>    __try <br>    { <br>        lpCurrIdItem = lpIdList-&gt;next; <br>     <br>        while(lpCurrIdItem != NULL) <br>        { <br>            if(lpCurrIdItem == lpIdItem) <br>            { <br>                // <br>                // Found identifier item in ID list <br>                // <br> <br>                if(lpIdList-&gt;next == lpIdItem) <br>                { <br>                    // item found at head of list <br>                    lpIdList-&gt;next = lpIdItem-&gt;next; <br>                } <br>                else <br>                { <br>                    lpPrevIdItem-&gt;next = lpIdItem-&gt;next; <br>                } <br> <br>                hr = NOERROR; <br>                goto cleanup; <br>            } <br> <br>            lpPrevIdItem = lpCurrIdItem; <br>            lpCurrIdItem = lpCurrIdItem-&gt;next; <br>        } <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>cleanup: <br> <br>    hrT = HrDestroyIdItem(&amp;lpIdItem); <br> <br>    if(FAILED(hr)) <br>    { <br>        hrT = HR_LOG(E_FAIL); <br>    } <br> <br>    LeaveCriticalSection(lpIdList-&gt;lpcs); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEmptyIdList-------------------------------------------------------------- <br>//  Empty an ID list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEmptyIdList(                  // RETURNS: return code <br>    IN LPIDITEM lpIdList)               // identifier item list <br>{ <br>HRESULT  hr       = NOERROR; <br>    HRESULT  hrT      = NOERROR; <br>    LPIDITEM lpIdItem = NULL; <br> <br>    EnterCriticalSection(lpIdList-&gt;lpcs); <br> <br>    __try <br>    { <br>        lpIdItem = lpIdList-&gt;next; <br>     <br>        while(lpIdItem != NULL) <br>        { <br>            lpIdList-&gt;next = lpIdItem-&gt;next; <br> <br>            MAPIFREEBUFFER(lpIdItem); <br> <br>            lpIdItem = lpIdList-&gt;next; <br>        } <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    LeaveCriticalSection(lpIdList-&gt;lpcs); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCreateMtsId-------------------------------------------------------------- <br>//  Returns the newly created stringized MTS identifier. It takes in a site <br>//  MTS identifier string that contains the country, ADMD and PRMD code and <br>//  creates the local identifier to create a new MTS identifier. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateMtsId(                  // RETURNS: return code <br>    IN  LPSTR lpszSiteMtsId,            // site MTS identifier <br>    IN  LPSTR lpszGatewayName,          // gateway name <br>    IN  ULONG ulSeqNo,                  // sequence number <br>    OUT LPSTR lpszMTSID)                // MTS identifier <br>{ <br>HRESULT    hr                     = NOERROR; <br>    SYSTEMTIME st                     = {0}; <br>CHAR       rgchUTC[cbMTSIDMax]    = {0}; <br>ULONG      cbMTName               = 0; <br>LPSTR      lpszMTName[cbMTSIDMax] = {0}; <br>ULONG      cbSeqNo                = 0; <br>CHAR       rgchSeqNo[9]           = {0}; <br> <br>// Get the current time and make it a UTCTime string <br>    GetSystemTime(&amp;st); <br>    sprintf(rgchUTC, "%04u%02u%02u%02u%02u%02uZ", <br>        st.wYear, <br>        st.wMonth, <br>        st.wDay, <br>        st.wHour, <br>        st.wMinute, <br>        st.wSecond); <br> <br>// format the ulSeqNo into a string and get's length <br>sprintf((LPSTR)rgchSeqNo, "%08lx", ulSeqNo); <br>cbSeqNo = strlen(rgchSeqNo); <br> <br>// find out how much of the gateway name can be put into the local identifer <br>cbMTName = 32 - cbSeqNo - strlen(rgchUTC) - 2; <br> <br>lstrcpy((LPSTR)lpszMTName, lpszGatewayName); <br> <br>if(cbMTName &lt; (ULONG)lstrlen((LPSTR)lpszMTName)) <br>    { <br>lpszMTName[cbMTName] = 0; <br>} <br> <br>    // <br>// Format of local identifier is: <br>//     "Gateway Name-stringized UTC Time-stringized ulSeqNo" <br>// NOTE: DO NOT CHANGE Delimiter to "/". <br>    // <br> <br>sprintf( <br>    lpszMTSID, <br>    "%s;L=%s-%s-%s", <br>    lpszSiteMtsId, <br>    lpszMTName, <br>    rgchUTC, <br>    rgchSeqNo); <br> <br>RETURN(hr); <br>} <br> <br>//$--DumpPropProblems----------------------------------------------------------- <br>//  Dumps property problems to the debug log. <br>//------------------------------------------------------------------------------ <br>VOID DumpPropProblems(                  // RETURNS: nothing <br>    IN LPSTR lpszFile,                  // source file name <br>    IN ULONG ulLine,                    // source line number <br>    IN LPSPropProblemArray lpProblems)  // property problems <br>{ <br>    ULONG i = 0; <br> <br>    DEBUGPUBLIC("DumpPropProblems()\n"); <br> <br>    if(lpProblems == NULL) <br>    { <br>        goto cleanup; <br>    } <br> <br>#ifdef DEBUG <br>    for(i = 0; i &lt; lpProblems-&gt;cProblem; i++) <br>    { <br>        _Assert("PROBLEM", lpszFile, ulLine, D_WARNING, 0, "%lu\t%08lx\t%08lx\n", <br>            lpProblems-&gt;aProblem[i].ulIndex, <br>            lpProblems-&gt;aProblem[i].ulPropTag, <br>            lpProblems-&gt;aProblem[i].scode); <br>    } <br>#endif <br> <br>cleanup: <br> <br>    return; <br>} <br> <br>#ifdef DEBUG <br>#define DUMPPROPPROBLEMS(_prob) DumpPropProblems(__FILE__,__LINE__,(_prob)) <br>#else <br>#define DUMPPROPPROBLEMS(_prob) ((void)0) <br>#endif <br> <br>//$--HrCreateEnterpriseGDI------------------------------------------------------ <br>//  Create the enterprise GDI from the input string. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateEnterpriseGDI(          // RETURNS: return code <br>    IN LPTSTR lpsz,                     // pointer to input string <br>    IN LPTSTR lpszEOT,                  // pointer to separator character(s) <br>    OUT LPTSTR *lppszGDI)               // pointer to enterprise GDI <br>{ <br>    HRESULT hr          = NOERROR; <br>    SCODE   sc          = 0; <br>    ULONG   cBytes      = 0; <br>    ULONG   cArraySize  = 0; <br>    LPTSTR  *lppszArray = NULL; <br>    LPTSTR  lpszCountry = NULL; <br>    LPTSTR  lpszAdmd    = NULL; <br>    LPTSTR  lpszPrmd    = NULL; <br>    ULONG   i           = 0; <br> <br>    DEBUGPUBLIC("HrCreateEnterpriseGDI()\n"); <br> <br>    *lppszGDI = NULL; <br> <br>    hr = HrStrTokAll( <br>        lpsz, <br>        lpszEOT, <br>        &amp;cArraySize, <br>        &amp;lppszArray); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    for(i = 0; i &lt; cArraySize; i++) <br>    { <br>        if(lppszArray[i] == NULL) <br>        { <br>            ; <br>        } <br>        else if(!_tcsnicmp(lppszArray[i], C_EQU, lstrlen(C_EQU))) <br>        { <br>            lpszCountry = lppszArray[i]; <br>        } <br>        else if(!_tcsnicmp(lppszArray[i], A_EQU, lstrlen(A_EQU))) <br>        { <br>            lpszAdmd = lppszArray[i]; <br>        } <br>        else if(!_tcsnicmp(lppszArray[i], P_EQU, lstrlen(P_EQU))) <br>        { <br>            lpszPrmd = lppszArray[i]; <br>        } <br>    } <br> <br>    if(lpszCountry == NULL) <br>    { <br>        lpszCountry = TEXT("C=;"); <br>    } <br> <br>    if(lpszAdmd == NULL) <br>    { <br>        lpszAdmd = TEXT("A=;"); <br>    } <br> <br>    if(lpszPrmd == NULL) <br>    { <br>        lpszPrmd = TEXT("P=;"); <br>    } <br> <br>    cBytes = (lstrlen(TEXT(";;;")) + <br>              lstrlen(lpszCountry) + <br>              lstrlen(lpszAdmd) + <br>              lstrlen(lpszPrmd) + 1) * sizeof(TCHAR); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)lppszGDI); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    lstrcpy(*lppszGDI, lpszCountry); <br>    lstrcat(*lppszGDI, TEXT(";")); <br>    lstrcat(*lppszGDI, lpszAdmd); <br>    lstrcat(*lppszGDI, TEXT(";")); <br>    lstrcat(*lppszGDI, lpszPrmd); <br>    lstrcat(*lppszGDI, TEXT(";")); <br> <br>    CharUpperBuff(*lppszGDI, cBytes/sizeof(TCHAR)); <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppszGDI); <br>    } <br> <br>    MAPIFREEBUFFER(lppszArray); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetMtsIdEnterpriseGDI---------------------------------------------------- <br>//  Get the enterprise GDI from the MTS-ID (or SUBJECT-MTS-ID). <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetMtsIdEnterpriseGDI(        // RETURNS: return code <br>    IN LPMESSAGE lpMessage,             // pointer to message <br>    IN ULONG ulPropTag,                 // MTS-ID property tag <br>    OUT LPTSTR *lppszGDI)               // pointer to enterprise GDI <br>{ <br>    HRESULT hr          = NOERROR; <br>    ULONG   cBytes      = 0; <br>    LPTSTR  lpszMtsId   = NULL; <br> <br>    DEBUGPUBLIC("HrGetMtsIdEnterpriseGDI()\n"); <br> <br>    *lppszGDI = NULL; <br> <br>    hr = HrMAPIGetPropBinary( <br>        (LPMAPIPROP)lpMessage, <br>        ulPropTag, <br>        &amp;cBytes, <br>        (LPVOID *)&amp;lpszMtsId); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = HrCreateEnterpriseGDI( <br>        lpszMtsId, <br>        TEXT("/;"), <br>        lppszGDI); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppszGDI); <br>    } <br> <br>    MAPIFREEBUFFER(lpszMtsId); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetTraceEnterpriseGDI---------------------------------------------------- <br>//  Get the enterprise GDI from the external trace information. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetTraceEnterpriseGDI(        // RETURNS: return code <br>    IN LPMESSAGE lpMessage,             // pointer to message <br>    IN ULONG ulPropTag,                 // external trace info property tag <br>    OUT LPTSTR *lppszGDI)               // pointer to enterprise GDI <br>{ <br>    HRESULT      hr           = NOERROR; <br>    SCODE        sc           = 0; <br>    ULONG        cBytes       = 0; <br>    LPTRACEINFO  lpTraceInfo  = NULL; <br>    LPTRACEENTRY lpTraceEntry = NULL; <br>    FILETIME     ft           = {0}; <br>    LPTSTR       lpszT        = NULL; <br>    LPTSTR       lpszCountry  = NULL; <br>    LPTSTR       lpszAdmd     = NULL; <br>    LPTSTR       lpszPrmd     = NULL; <br>    ULONG        i            = 0; <br> <br>    DEBUGPUBLIC("HrGetTraceEnterpriseGDI()\n"); <br> <br>    *lppszGDI = NULL; <br> <br>    hr = HrMAPIGetPropBinary( <br>        (LPMAPIPROP)lpMessage, <br>        ulPropTag, <br>        &amp;cBytes, <br>        (LPVOID *)&amp;lpTraceInfo); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = HrTraceGotoFirstEntry( <br>        lpTraceInfo, <br>        &amp;i, <br>        &amp;lpTraceEntry); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrTraceOpenEntry( <br>        lpTraceEntry, <br>        &amp;i, <br>        &amp;ft, <br>        &amp;ft, <br>        &amp;lpszAdmd, <br>        &amp;lpszCountry, <br>        &amp;lpszPrmd, <br>        &amp;lpszT, <br>        &amp;lpszT, <br>        &amp;lpszT); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(lpszCountry == NULL) <br>    { <br>        lpszCountry = TEXT("C=;"); <br>    } <br> <br>    if(lpszAdmd == NULL) <br>    { <br>        lpszAdmd = TEXT("A=;"); <br>    } <br> <br>    if(lpszPrmd == NULL) <br>    { <br>        lpszPrmd = TEXT("P=;"); <br>    } <br> <br>    cBytes = (lstrlen(TEXT("C=;A=;P=;")) + <br>              lstrlen(lpszCountry) + <br>              lstrlen(lpszAdmd) + <br>              lstrlen(lpszPrmd) + 1) * sizeof(TCHAR); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)lppszGDI); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    lstrcpy(*lppszGDI, C_EQU); <br>    lstrcat(*lppszGDI, lpszCountry); <br>    lstrcat(*lppszGDI, TEXT(";A=")); <br>    lstrcat(*lppszGDI, lpszAdmd); <br>    lstrcat(*lppszGDI, TEXT(";P=")); <br>    lstrcat(*lppszGDI, lpszPrmd); <br>    lstrcat(*lppszGDI, TEXT(";")); <br> <br>    CharUpperBuff(*lppszGDI, cBytes/sizeof(TCHAR)); <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppszGDI); <br>    } <br> <br>    MAPIFREEBUFFER(lpTraceInfo); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrFixUpRecipientNumbers---------------------------------------------------- <br>//  Fix up recipient numbers. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrFixUpRecipientNumbers( // RETURNS: return code <br>    IN OUT LPADRLIST lpEnvelopeAdrList, // pointer to envelope address list <br>    IN OUT LPADRLIST lpMessageAdrList)  // pointer to message address list <br>{ <br>    HRESULT      hr                = NOERROR; <br>    HRESULT      hrT               = NOERROR; <br>    SCODE        sc                = 0; <br>    ULONG        cb                = 0; <br> <br>    ULONG*       rgulOrigRecipNums = NULL; <br> <br>    LPSPropValue lpPropT           = NULL; <br> <br>    ULONG        i                 = 0; <br>    ULONG        j                 = 0; <br> <br>    ULONG        cValues           = 0; <br>    LPSPropValue lpProps           = NULL; <br> <br>    DEBUGPRIVATE("HrFixUpRecipientNumbers()\n"); <br> <br>    if( (!((lpMessageAdrList == NULL) || (lpMessageAdrList-&gt;cEntries == 0))) &amp;&amp; <br>        (!((lpEnvelopeAdrList == NULL) || (lpEnvelopeAdrList-&gt;cEntries == 0)))) <br>    { <br>        cb = lpMessageAdrList-&gt;cEntries * (sizeof(ULONG) + MAX_ALIGN); <br> <br>        sc = MAPIAllocateBuffer(cb, (void **)&amp;rgulOrigRecipNums); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br> <br>        for(i = 0; i &lt; lpMessageAdrList-&gt;cEntries; i++) <br>        { <br>            rgulOrigRecipNums[i] = 0; <br> <br>            cValues = lpMessageAdrList-&gt;aEntries[i].cValues; <br>            lpProps = lpMessageAdrList-&gt;aEntries[i].rgPropVals; <br> <br>            if(lpProps != NULL) <br>            { <br>                lpPropT = LpValFindProp(PR_RECIPIENT_NUMBER, cValues, lpProps); <br> <br>                if(lpPropT == NULL) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                rgulOrigRecipNums[i] = lpPropT-&gt;Value.ul; <br> <br>                lpPropT-&gt;ulPropTag =  <br>                    PROP_TAG(PT_ERROR, PROP_ID(lpPropT-&gt;ulPropTag)); <br>            } <br>        } <br> <br>        for(i = 0; i &lt; lpEnvelopeAdrList-&gt;cEntries; i++) <br>        { <br>            cValues = lpEnvelopeAdrList-&gt;aEntries[i].cValues; <br>            lpProps = lpEnvelopeAdrList-&gt;aEntries[i].rgPropVals; <br> <br>            if(lpProps != NULL) <br>            { <br>                lpPropT = LpValFindProp(PR_RECIPIENT_NUMBER, cValues, lpProps); <br> <br>                if(lpPropT == NULL) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                for(j = 0; j &lt; lpMessageAdrList-&gt;cEntries; j++) <br>                { <br>                    if(rgulOrigRecipNums[j] == lpPropT-&gt;Value.ul) <br>                    { <br>                        lpPropT-&gt;Value.ul = j+1; <br>                    } <br>                } <br>            } <br>        } <br> <br>        // <br>        // Clear recipient numbers for message address list. <br>        // <br> <br>        hr = HrDeleteAddressListProperty( <br>            PR_RECIPIENT_NUMBER, <br>            (LPADRLIST)lpMessageAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // <br>    // Clear row IDs for envelope address list. <br>    // <br> <br>    if(!((lpEnvelopeAdrList == NULL) || (lpEnvelopeAdrList-&gt;cEntries == 0))) <br>    { <br>        hr = HrDeleteAddressListProperty( <br>            PR_ROWID, <br>            (LPADRLIST)lpEnvelopeAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // <br>    // Clear row IDs for message address list. <br>    // <br> <br>    if(!((lpMessageAdrList == NULL) || (lpMessageAdrList-&gt;cEntries == 0))) <br>    { <br>        hr = HrDeleteAddressListProperty( <br>            PR_ROWID, <br>            (LPADRLIST)lpMessageAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(rgulOrigRecipNums); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrDeleteSenderProps-------------------------------------------------------- <br>// Delete sender properties from the message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrDeleteSenderProps(            // RETURNS: return code <br>    IN LPMESSAGE  lpMessage)            // pointer to message <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    LPSPropProblemArray lpProblems = NULL; <br> <br>    SizedSPropTagArray(10, rgPropTags) = <br>    { <br>        10, <br>        { <br>            PR_SENDER_NAME, <br>            PR_SENDER_ADDRTYPE, <br>            PR_SENDER_EMAIL_ADDRESS, <br>            PR_SENDER_SEARCH_KEY, <br>            PR_SENDER_ENTRYID, <br>            PR_SENT_REPRESENTING_NAME, <br>            PR_SENT_REPRESENTING_ADDRTYPE, <br>            PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>            PR_SENT_REPRESENTING_SEARCH_KEY, <br>            PR_SENT_REPRESENTING_ENTRYID, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrDeleteSenderProps()\n"); <br> <br>    hrT = MAPICALL(lpMessage)-&gt;DeleteProps( <br>        lpMessage, <br>        (SPropTagArray *)&amp;rgPropTags, <br>        &amp;lpProblems); <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpProblems = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    DUMPPROPPROBLEMS(lpProblems); <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrDeleteMtsIdProps--------------------------------------------------------- <br>// Delete MTS-ID properties from the message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrDeleteMtsIdProps(             // RETURNS: return code <br>    IN LPMESSAGE  lpMessage)            // pointer to message <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    LPSPropProblemArray lpProblems = NULL; <br> <br>    SizedSPropTagArray(1, rgPropTags) = <br>    { <br>        1, <br>        { <br>            PR_MTS_ID, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrDeleteMtsIdProps()\n"); <br> <br>    hr = MAPICALL(lpMessage)-&gt;DeleteProps( <br>        lpMessage, <br>        (SPropTagArray *)&amp;rgPropTags, <br>        &amp;lpProblems); <br> <br>    if(FAILED(hr)) <br>    { <br>        lpProblems = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    DUMPPROPPROBLEMS(lpProblems); <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrDeleteTraceProps--------------------------------------------------------- <br>// Delete trace properties from the message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrDeleteTraceProps(                  // RETURNS: return code <br>    IN LPMESSAGE  lpMessage)            // pointer to message <br>{ <br>    HRESULT hr  = NOERROR; <br> <br>    LPSPropProblemArray lpProblems = NULL; <br> <br>    SizedSPropTagArray(1, rgPropTags) = <br>    { <br>        1, <br>        { <br>            PR_TRACE_INFO, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrDeleteTraceProps()\n"); <br> <br>    hr = MAPICALL(lpMessage)-&gt;DeleteProps( <br>        lpMessage, <br>        (SPropTagArray *)&amp;rgPropTags, <br>        &amp;lpProblems); <br> <br>    if(FAILED(hr)) <br>    { <br>        lpProblems = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    DUMPPROPPROBLEMS(lpProblems); <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrNonDeliverAllRecipList--------------------------------------------------- <br>//  Create a recipient list to non-deliver all recipients. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrNonDeliverAllRecipList(       // RETURNS: return code <br>    IN LPMESSAGE lpMessage,             // message <br>    IN LPADRLIST *lppAdrList)           // address list <br>{ <br>    HRESULT      hr            = NOERROR; <br>    HRESULT      hrT           = NOERROR; <br>    LPSRowSet    lpRows        = NULL; <br>    LPADRLIST    lpAdrList     = NULL; <br>    LPADRLIST    lpAllAdrList  = NULL; <br>    LPMAPITABLE  lpTable       = NULL; <br> <br>    LPSPropValue lpPropT       = NULL; <br> <br>    ULONG        cFailedValues = 0; <br>    LPSPropValue lpFailedProps = NULL; <br> <br>    ULONG        i             = 0; <br> <br>    DEBUGPUBLIC("HrNonDeliverAllRecipList()"); <br> <br>    *lppAdrList = NULL; <br> <br>    // <br>    // Get the recipient table for the message <br>    // <br> <br>    hr = MAPICALL(lpMessage)-&gt;GetRecipientTable( <br>        lpMessage, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;lpTable); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Query all the rows <br>    // <br> <br>    hr = HrQueryAllRows( <br>    lpTable, <br>    NULL, <br>    NULL, <br>    NULL, <br>    0, <br>    &amp;lpRows); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    lpAdrList = (LPADRLIST)lpRows; <br> <br>    hr = HrNDRCreateFailedRecipList( <br>        &amp;lpAllAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    for(i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>        hr = HrNDRGetFailedRecipList( <br>            &amp;lpAdrList-&gt;aEntries[i], <br>            0, <br>            NULL, <br>            &amp;cFailedValues, <br>            &amp;lpFailedProps); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        lpPropT = LpValFindProp(PR_RECIPIENT_NUMBER, cFailedValues, lpFailedProps); <br> </code></pre>
<p>
</p>
<pre><code>if(lpPropT != NULL) <br>        { <br>            lpPropT-&gt;Value.ul = (i+1); <br>        } <br> <br>        hr = HrNDRAddToFailedRecipList( <br>            cFailedValues, <br>            lpFailedProps, <br>            &amp;lpAllAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        MAPIFREEBUFFER(lpFailedProps); <br>    }   // end for <br> <br>    *lppAdrList  = lpAllAdrList; <br>    lpAllAdrList = NULL; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpFailedProps); <br> <br>    FREEPADRLIST(lpAdrList);        // also frees lpRows <br> <br>    FREEPADRLIST(lpAllAdrList); <br> <br>    ULRELEASE(lpTable); <br> <br>    if(FAILED(hr)) <br>    { <br>        FREEPADRLIST(lpAllAdrList); <br>        *lppAdrList = NULL; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCreateNonDeliveryReport-------------------------------------------------- <br>//  Create a non-delivery report. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateNonDeliveryReport(          // RETURNS: return code <br>    IN BOOL fCreateMtsId,                   // create MTS identifier <br>    IN LPADRBOOK lpAdrBook,                 // pointer to address book <br>    IN LPMAPIFOLDER lpFolder,               // pointer to folder <br>    IN LPMESSAGE lpMessage,                 // pointer to message <br>    IN LPADRLIST lpAdrList,                 // pointer to address list <br>    OUT LPMESSAGE *lppReport)               // pointer to report <br>{ <br>    HRESULT      hr                   = NOERROR; <br>    LPMESSAGE    lpReport             = NULL; <br>    ULONG        cBytes               = 0; <br>    ULONG        cValues              = 0; <br>    LPSPropValue lpProps              = NULL; <br> <br>    LPTSTR       lpszEmailDisplayName = NULL; <br>    LPTSTR       lpszEmailAddressType = NULL; <br>    LPTSTR       lpszEmailAddress     = NULL; <br>    LPTSTR       lpszEmailSearchKey   = NULL; <br>    ULONG        cbEmailEid           = 0; <br>    LPENTRYID    lpEmailEid           = NULL; <br> <br>LPSPropProblemArray lpProblems    = NULL; <br> <br>    CHAR         szGatewayName[MAX_SERVICE_NAME_LENGTH+1] = {0}; <br> <br>    ULONG        ulMtsIdSeqNo          = 0; <br>    CHAR         rgchMTSID[cbMTSIDMax] = {0}; <br> <br>    DEBUGPUBLIC("HrCreateNonDeliveryReport()\n"); <br> <br>    *lppReport = NULL; <br> <br>    if(fCreateMtsId == TRUE) <br>    { <br>        EnterCriticalSection(&amp;csGatewaySeqNo); <br>        ulMtsIdSeqNo = ++ulGatewaySeqNo; <br>        LeaveCriticalSection(&amp;csGatewaySeqNo); <br> <br>        // <br>        // Get gateway service name. <br>        // <br> <br>        hr = HrServiceGetName( <br>            szGatewayName); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        hr = HrCreateMtsId( <br>            lpszLocalGDI, <br>            szGatewayName, <br>            ulMtsIdSeqNo, <br>            rgchMTSID); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>    hr = HrNDRGetFailedProps( <br>        lpMessage, <br>        &amp;cValues, <br>        &amp;lpProps); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrNDRCreate( <br>        lpAdrBook, <br>        lpFolder, <br>        lpMessage, <br>        lpAdrList, <br>        cValues, <br>        lpProps, <br>        &amp;lpReport); <br> <br>    MAPIFREEBUFFER(lpProps); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cBytes = CbNewSPropValue(6); <br> <br>    hr = MAPIAllocateBuffer(cBytes, (void **)&amp;lpProps); <br> <br>    if(FAILED(hr)) <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    ZeroMemory(lpProps, cBytes); <br> <br>    hr = HrCreateProxyAddress( <br>        lpAdrBook, <br>        lpProps, <br>        TRUE, <br>        SYSTEM_ADMINISTRATOR, <br>        SYSTEM, <br>        SYSTEM_ADMINISTRATOR, <br>        &amp;lpszEmailDisplayName, <br>        &amp;lpszEmailAddressType, <br>        &amp;lpszEmailAddress, <br>        &amp;lpszEmailSearchKey, <br>        &amp;cbEmailEid, <br>        &amp;lpEmailEid); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    lpProps[0].ulPropTag         = PR_SENDER_NAME; <br>    lpProps[0].Value.LPSZ        = lpszEmailDisplayName; <br> <br>    lpProps[1].ulPropTag         = PR_SENDER_ADDRTYPE; <br>    lpProps[1].Value.LPSZ        = lpszEmailAddressType; <br> <br>    lpProps[2].ulPropTag         = PR_SENDER_EMAIL_ADDRESS; <br>    lpProps[2].Value.LPSZ        = lpszEmailAddress; <br> <br>    lpProps[3].ulPropTag         = PR_SENDER_SEARCH_KEY; <br> <br>    if(lpszEmailSearchKey == NULL) <br>    { <br>        lpProps[3].Value.bin.cb  = 0; <br>        lpProps[3].Value.bin.lpb = NULL; <br>    } <br>    else <br>    { <br>        lpProps[3].Value.bin.cb  = cbStrLen(lpszEmailSearchKey); <br>        lpProps[3].Value.bin.lpb = lpszEmailSearchKey; <br>    } <br> <br>    lpProps[4].ulPropTag         = PR_SENDER_ENTRYID; <br>    lpProps[4].Value.bin.cb      = cbEmailEid; <br>    lpProps[4].Value.bin.lpb     = (LPBYTE)lpEmailEid; <br> <br>    lpProps[5].ulPropTag         = PR_MTS_ID; <br>    lpProps[5].Value.bin.cb      = cbStrLen(rgchMTSID); <br>    lpProps[5].Value.bin.lpb     = (LPBYTE)rgchMTSID; <br> <br>    if(fCreateMtsId == TRUE) <br>    { <br>        cValues = 6; <br>    } <br>    else <br>    { <br>        cValues = 5; <br>    } <br> <br>    hr = MAPICALL(lpReport)-&gt;SetProps( <br>        lpReport, <br>        cValues, <br>        lpProps, <br>        &amp;lpProblems); <br> <br>    if(FAILED(hr)) <br>    { <br>        lpProblems = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    DUMPPROPPROBLEMS(lpProblems); <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    // Save changes just made to report envelope <br>    hr = MAPICALL(lpReport)-&gt;SaveChanges( <br>        lpReport, <br>        KEEP_OPEN_READWRITE); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    *lppReport = lpReport; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpProps); <br> <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrImportMessage------------------------------------------------------------ <br>//  Process an IPM/IPN in MTS-IN. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrImportMessage(                // RETURNS: return code <br>    IN LPADRBOOK lpAdrBook,             // pointer to address book <br>    IN LPABCONT lpGalABCont,            // pointer to GAL <br>    IN BOOL fIgnoreRespValue,           // ignore  responsibility value <br>    IN BOOL fSendNDR,                   // TRUE if NDRs should be generated <br>    IN DWORD dwStartProcessingTime,     // start processing time <br>    IN OUT LPMESSAGE lpEnvelope)        // pointer to envelope <br>{ <br>    HRESULT             hr                     = NOERROR; <br>    HRESULT             hrT                    = NOERROR; <br> <br>    LPMESSAGE           lpMessage              = NULL; <br>    LPATTACH            lpAttach               = NULL; <br> <br>    ULONG               cEnvelopeValues        = 0; <br>    LPSPropValue        lpEnvelopeProps        = NULL; <br>    ULONG               cMessageValues         = 0; <br>    LPSPropValue        lpMessageProps         = NULL; <br> <br>    LPADRLIST           lpOriginalEnvelopeAdrList = NULL; <br>    LPADRLIST           lpOriginalMessageAdrList  = NULL; <br> <br>    LPADRLIST           lpEnvelopeAdrList      = NULL; <br>    LPADRLIST           lpMessageAdrList       = NULL; <br> <br>    LPADRLIST           lpEnvelope_NDR_AdrList = NULL; <br>    LPADRLIST           lpMessage_NDR_AdrList  = NULL; <br> <br>    DWORD               dwEndProcessingTime    = 0; <br>    DWORD               dwTotalProcessingTime  = 0; <br>    DWORD               dwSleepProcessingTime  = 0; <br> <br>    ULONG               cEnvelopeMesgAddr         = 0; <br>    ULONG               cEnvelopeReplyAddr        = 0; <br>    ULONG               cEnvelopeRecipAddr        = 0; <br>    LPADRLIST           lpEnvelopeAllAdrList      = NULL; <br>    LPADRLIST           lpMappedEnvelopeAdrList   = NULL; <br> <br>    ULONG               cMessageMesgAddr          = 0; <br>    ULONG               cMessageReplyAddr         = 0; <br>    ULONG               cMessageRecipAddr         = 0; <br>    LPADRLIST           lpMessageAllAdrList       = NULL; <br>    LPADRLIST           lpMappedMessageAdrList    = NULL; <br> <br>    BOOL                HasContent                = TRUE; <br> <br>LPSPropProblemArray lpProblems                = NULL; <br> <br>    DEBUGPUBLIC("HrImportMessage()\n"); <br> <br>    // Get the attachment in the envelope <br>    hrT = MAPICALL(lpEnvelope)-&gt;OpenAttach( <br>        lpEnvelope, <br>        0, <br>        NULL, <br>        MAPI_MODIFY, <br>        &amp;lpAttach); <br> <br>    if((FAILED(hrT)) &amp;&amp; (hrT != MAPI_E_NOT_FOUND)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(hrT == MAPI_E_NOT_FOUND) <br>    { <br>        // <br>        // Message does not have an attachment. <br>        // <br> <br>        HasContent = FALSE; <br>        lpAttach   = NULL; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        // Open a message interface on the attachment <br>        hrT = MAPICALL(lpAttach)-&gt;OpenProperty( <br>            lpAttach, <br>            PR_ATTACH_DATA_OBJ, <br>            (LPIID)&amp;IID_IMessage, <br>            0, <br>            MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>            (LPUNKNOWN *)&amp;lpMessage); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    // <br>    // Map envelope addresses <br>    // <br> <br>    hr = HrExpandMessageAddressList( <br>        lpEnvelope, <br>        &amp;cEnvelopeMesgAddr, <br>        &amp;cEnvelopeReplyAddr, <br>        &amp;cEnvelopeRecipAddr, <br>        &amp;lpOriginalEnvelopeAdrList, <br>        &amp;lpEnvelopeAllAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMapAddrToProxy( <br>        lpAdrBook, <br>        lpszAddressType, <br>        lpEnvelopeAllAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMapGatewayProxyToAddr( <br>        lpAdrBook, <br>        lpszAddressType, <br>        lpEnvelopeAllAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMapProxyToAddr( <br>        lpAdrBook, <br>        lpGalABCont, <br>        lpEnvelopeAllAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrCollapseMessageAddressList( <br>        lpEnvelope, <br>        cEnvelopeMesgAddr, <br>        cEnvelopeReplyAddr, <br>        cEnvelopeRecipAddr, <br>        lpEnvelopeAllAdrList, <br>        &amp;cEnvelopeValues, <br>        &amp;lpEnvelopeProps, <br>        &amp;lpMappedEnvelopeAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    FREEPADRLIST(lpEnvelopeAllAdrList); <br> <br>    // <br>    // TNEF encode is setting the value of PR_RESPONSIBILITY to FALSE <br>    // for each recipient entry. <br>    // <br> <br>    { <br>        ULONG        i       = 0; <br>        LPSPropValue lpPropT = NULL; <br> <br>        for(i = 0; i &lt; lpOriginalEnvelopeAdrList-&gt;cEntries; i++) <br>        { <br>            lpPropT = LpValFindProp( <br>                PR_RESPONSIBILITY, <br>                lpOriginalEnvelopeAdrList-&gt;aEntries[i].cValues, <br>                lpOriginalEnvelopeAdrList-&gt;aEntries[i].rgPropVals); <br> <br>            if(lpPropT != NULL) <br>            { <br>                lpPropT-&gt;Value.b = TRUE; <br>            } <br>        } <br> <br>        for(i = 0; i &lt; lpMappedEnvelopeAdrList-&gt;cEntries; i++) <br>        { <br>            lpPropT = LpValFindProp( <br>                PR_RESPONSIBILITY, <br>                lpMappedEnvelopeAdrList-&gt;aEntries[i].cValues, <br>                lpMappedEnvelopeAdrList-&gt;aEntries[i].rgPropVals); <br> <br>            if(lpPropT != NULL) <br>            { <br>                lpPropT-&gt;Value.b = TRUE; <br>            } <br>        } <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        // <br>        // Map message addresses <br>        // <br> <br>        hr = HrExpandMessageAddressList( <br>            lpMessage, <br>            &amp;cMessageMesgAddr, <br>            &amp;cMessageReplyAddr, <br>            &amp;cMessageRecipAddr, <br>            &amp;lpOriginalMessageAdrList, <br>            &amp;lpMessageAllAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrMapAddrToProxy( <br>            lpAdrBook, <br>            lpszAddressType, <br>            lpMessageAllAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrMapGatewayProxyToAddr( <br>            lpAdrBook, <br>            lpszAddressType, <br>            lpMessageAllAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrMapProxyToAddr( <br>            lpAdrBook, <br>            lpGalABCont, <br>            lpMessageAllAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrCollapseMessageAddressList( <br>            lpMessage, <br>            cMessageMesgAddr, <br>            cMessageReplyAddr, <br>            cMessageRecipAddr, <br>            lpMessageAllAdrList, <br>            &amp;cMessageValues, <br>            &amp;lpMessageProps, <br>            &amp;lpMappedMessageAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        FREEPADRLIST(lpMessageAllAdrList); <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    hr = HrMapRecipProxyToAddr( <br>        lpAdrBook, <br>        TRUE, <br>        fIgnoreRespValue, <br>        lpGalABCont, <br>        lpszAddressType, <br>        lpOriginalEnvelopeAdrList, <br>        lpMappedEnvelopeAdrList, <br>        NULL, <br>        NULL, <br>        lpEnvelope, <br>        &amp;lpEnvelopeAdrList, <br>        &amp;lpEnvelope_NDR_AdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        hr = HrMapRecipProxyToAddr( <br>            lpAdrBook, <br>            FALSE, <br>            fIgnoreRespValue, <br>            lpGalABCont, <br>            lpszAddressType, <br>            lpOriginalMessageAdrList, <br>            lpMappedMessageAdrList, <br>            lpEnvelopeAdrList, <br>            lpEnvelope_NDR_AdrList, <br>            lpMessage, <br>            &amp;lpMessageAdrList, <br>            &amp;lpMessage_NDR_AdrList); <br> <br>        FREEPADRLIST(lpOriginalMessageAdrList); <br> <br>        FREEPADRLIST(lpMessage_NDR_AdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // Non-deliver any recipients that could not be mapped. <br> <br>    if((lpEnvelope_NDR_AdrList != NULL) &amp;&amp; <br>       (lpEnvelope_NDR_AdrList-&gt;cEntries != 0) &amp;&amp; <br>       (fSendNDR == TRUE)) <br>    { <br>        LPMESSAGE lpReportEnvelope = NULL; <br> <br>        // <br>        // Clear row IDs for envelope NDR address list. <br>        // <br> <br>        hr = HrDeleteAddressListProperty( <br>            PR_ROWID, <br>            (LPADRLIST)lpEnvelope_NDR_AdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // <br>        // Create a non delivery report in MTS-OUT <br>        // <br> <br>        hr = HrCreateNonDeliveryReport( <br>            TRUE, <br>            lpAdrBook, <br>            lpMtsOutFolder, <br>            lpMessage, <br>            lpEnvelope_NDR_AdrList, <br>            &amp;lpReportEnvelope); <br> <br>        if(FAILED(hr)) <br>        { <br>            ; <br>        } <br>        else <br>        { <br>            HANDLE hNewMailEvent = GetGWNewMailEvent(); <br> <br>            if((hNewMailEvent != NULL) &amp;&amp; (!SetEvent(hNewMailEvent))) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>        } <br> <br>        ULRELEASE(lpReportEnvelope); <br>    } <br> <br>    FREEPADRLIST(lpEnvelope_NDR_AdrList); <br> <br>    if((lpEnvelopeAdrList == NULL) || (lpEnvelopeAdrList-&gt;cEntries == 0)) <br>    { <br>        FREEPADRLIST(lpEnvelopeAdrList); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        if((lpMessageAdrList == NULL) || (lpMessageAdrList-&gt;cEntries == 0)) <br>        { <br>            FREEPADRLIST(lpMessageAdrList); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    // Fix up recipient numbers <br>    hr = HrFixUpRecipientNumbers(lpEnvelopeAdrList, lpMessageAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    hrT = MAPICALL(lpEnvelope)-&gt;SetProps( <br>        lpEnvelope, <br>        cEnvelopeValues, <br>        lpEnvelopeProps, <br>        &amp;lpProblems); <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpProblems = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    DUMPPROPPROBLEMS(lpProblems); <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    hr = HrMAPISetPropBoolean( <br>        (LPMAPIPROP)lpEnvelope, <br>        PR_DELETE_AFTER_SUBMIT, <br>        TRUE); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        hrT = MAPICALL(lpMessage)-&gt;SetProps( <br>            lpMessage, <br>            cMessageValues, <br>            lpMessageProps, <br>            &amp;lpProblems); <br> <br>        if(FAILED(hrT)) <br>        { <br>            lpProblems = NULL; <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        DUMPPROPPROBLEMS(lpProblems); <br>        MAPIFREEBUFFER(lpProblems); <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    // Set envelope recipients <br>    hrT = MAPICALL(lpEnvelope)-&gt;ModifyRecipients( <br>        lpEnvelope, <br>        0, <br>        lpEnvelopeAdrList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        // Set message recipients <br>        hrT = MAPICALL(lpMessage)-&gt;ModifyRecipients( <br>            lpMessage, <br>            0, <br>            lpMessageAdrList); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    if(HasContent == TRUE) <br>    { <br>        // Save changes to the message <br>        hrT = MAPICALL(lpMessage)-&gt;SaveChanges( <br>            lpMessage, <br>            MAPI_DEFERRED_ERRORS|KEEP_OPEN_READWRITE); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Save changes to attachment object <br>        hrT = MAPICALL(lpAttach)-&gt;SaveChanges( <br>            lpAttach, <br>            MAPI_DEFERRED_ERRORS|KEEP_OPEN_READWRITE); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        ULRELEASE(lpMessage); <br> <br>        ULRELEASE(lpAttach); <br>    } <br> <br>    //---------------------------------------------------------------------- <br>    dwEndProcessingTime     = GetTickCount(); <br> <br>    dwTotalProcessingTime   = dwEndProcessingTime - dwStartProcessingTime; <br> <br>    dwSleepProcessingTime   = <br>        ((dwTotalProcessingTime &lt; dwInSleepInterval) ? <br>         (dwInSleepInterval - dwTotalProcessingTime) : 0); <br> <br>    if(dwSleepProcessingTime &gt; 0) <br>    { <br>        Sleep(dwSleepProcessingTime); <br>    } <br>    //---------------------------------------------------------------------- <br> <br>    // Submit message <br>    hrT = MAPICALL(lpEnvelope)-&gt;SubmitMessage(lpEnvelope, FORCE_SUBMIT); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    FREEPADRLIST(lpEnvelopeAdrList); <br> <br>    FREEPADRLIST(lpMessageAdrList); <br> <br>    FREEPADRLIST(lpEnvelope_NDR_AdrList); <br> <br>    FREEPADRLIST(lpMessage_NDR_AdrList); <br> <br>    FREEPADRLIST(lpOriginalEnvelopeAdrList); <br>    FREEPADRLIST(lpOriginalMessageAdrList); <br> <br>    FREEPADRLIST(lpEnvelopeAllAdrList); <br>    FREEPADRLIST(lpMessageAllAdrList); <br> <br>    FREEPADRLIST(lpMappedEnvelopeAdrList); <br>    FREEPADRLIST(lpMappedMessageAdrList); <br> <br>    MAPIFREEBUFFER(lpEnvelopeProps); <br>    MAPIFREEBUFFER(lpMessageProps); <br> <br>    ULRELEASE(lpMessage); <br> <br>    ULRELEASE(lpAttach); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCheckExternalTraceInformation-------------------------------------------- <br>// Process messages in MTS-IN. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCheckExternalTraceInformation(    // RETURNS: return code <br>    IN LPMESSAGE lpEnvelope)                // pointer to envelope <br>{ <br>    HRESULT hr           = NOERROR; <br>    LPTSTR  lpszMtsIdGDI = NULL; <br>    LPTSTR  lpszTraceGDI = NULL; <br> <br>    DEBUGPUBLIC("HrCheckExternalTraceInformation()\n"); <br> <br>    hr = HrGetMtsIdEnterpriseGDI( <br>        lpEnvelope, <br>        PR_MTS_ID, <br>        &amp;lpszMtsIdGDI); <br> <br>    if((FAILED(hr)) &amp;&amp; (hr != MAPI_E_NOT_FOUND)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrGetTraceEnterpriseGDI( <br>        lpEnvelope, <br>        PR_TRACE_INFO, <br>        &amp;lpszTraceGDI); <br> <br>    if((FAILED(hr)) &amp;&amp; (hr != MAPI_E_NOT_FOUND)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if((lpszMtsIdGDI == NULL) &amp;&amp; (lpszTraceGDI == NULL)) <br>    { <br>        // consistent <br>    } <br>    else if((lpszMtsIdGDI == NULL) || (lpszTraceGDI == NULL)) <br>    { <br>        // warning <br>        MODULE_ERROR("**** Inconsistent external trace ****"); <br> <br>        if((lpszTraceGDI != NULL) &amp;&amp; <br>           (lstrcmpi(lpszTraceGDI, lpszLocalGDI) == 0)) <br>    { <br>            // delete MTS-ID <br>            hr = HrDeleteMtsIdProps( <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>    } <br>        else if((lpszMtsIdGDI != NULL) &amp;&amp; <br>                (lstrcmpi(lpszMtsIdGDI, lpszLocalGDI) == 0)) <br>        { <br>            // delete trace <br>            hr = HrDeleteTraceProps( <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>    } <br>    else <br>    { <br>            // delete trace <br>            hr = HrDeleteTraceProps( <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            // delete MTS-ID <br>            hr = HrDeleteMtsIdProps( <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>    } <br>    } <br>    else <br>    { <br>        if(lstrcmpi(lpszMtsIdGDI, lpszTraceGDI) != 0) <br>    { <br>            // warning <br>            MODULE_ERROR("**** Inconsistent external trace ****"); <br> <br>            if(lstrcmpi(lpszTraceGDI, lpszLocalGDI) == 0) <br>    { <br>                // delete MTS-ID <br>                hr = HrDeleteMtsIdProps( <br>                    lpEnvelope); <br> <br>                if(FAILED(hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>    } <br>            else if(lstrcmpi(lpszMtsIdGDI, lpszLocalGDI) == 0) <br>    { <br>                // delete trace <br>                hr = HrDeleteTraceProps( <br>                    lpEnvelope); <br> <br>                if(FAILED(hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>    } <br>    else <br>    { <br>                // delete trace <br>                hr = HrDeleteTraceProps( <br>                    lpEnvelope); <br> <br>                if(FAILED(hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                // delete MTS-ID <br>                hr = HrDeleteMtsIdProps( <br>                    lpEnvelope); <br> <br>                if(FAILED(hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>    } <br>    } <br>    else <br>    { <br>            // consistent <br>    } <br>    } <br> <br>cleanup: <br> <br>    hr = NOERROR; <br> <br>    MAPIFREEBUFFER(lpszMtsIdGDI); <br> <br>    MAPIFREEBUFFER(lpszTraceGDI); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrNonDeliverMtsInMessage--------------------------------------------------- <br>//  Non-deliver a message in MTS-IN. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrNonDeliverMtsInMessage(       // RETURNS: zero <br>    IN LPTSTR lpszMessageClass,         // message class <br>    IN LPMESSAGE lpEnvelope)            // envelope <br>{ <br>    HRESULT   hr               = NOERROR; <br>    LPADRBOOK lpAdrBook        = NULL; <br>    LPMESSAGE lpMessage        = NULL; <br>    LPMESSAGE lpSubjectMessage = NULL; <br>    LPMESSAGE lpReportEnvelope = NULL; <br>    LPADRLIST lpReportAdrList  = NULL; <br>    LPATTACH  lpAttach         = NULL; <br>    BOOL      HasContent       = TRUE; <br> <br>    DEBUGPUBLIC("HrNonDeliverMtsInMessage()\n"); <br> <br>    lpAdrBook   = GetAdrBookPtr(); <br> <br>    MODULE_ERROR1( <br>        "**** [IN ] Unknown message class [%s] ****", <br>        ((lpszMessageClass == NULL) ? "(null)" : lpszMessageClass)); <br> <br>    hr = HrNonDeliverAllRecipList( <br>        lpEnvelope, <br>        &amp;lpReportAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Get the attachment in the envelope <br>    hr = MAPICALL(lpEnvelope)-&gt;OpenAttach( <br>        lpEnvelope, <br>        0, <br>        NULL, <br>        MAPI_MODIFY, <br>        &amp;lpAttach); <br> <br>    if((FAILED(hr)) &amp;&amp; (hr != MAPI_E_NOT_FOUND)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if(hr == MAPI_E_NOT_FOUND) <br>    { <br>        // <br>        // Message does not have an attachment. <br>        // <br> <br>        HasContent = FALSE; <br>        lpAttach   = NULL; <br>    } <br> <br>    lpSubjectMessage = NULL; <br> <br>    if(HasContent == TRUE) <br>    { <br>        // Open a message interface on the attachment <br>        hr = MAPICALL(lpAttach)-&gt;OpenProperty( <br>            lpAttach, <br>            PR_ATTACH_DATA_OBJ, <br>            (LPIID)&amp;IID_IMessage, <br>            0, <br>            MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>            (LPUNKNOWN *)&amp;lpMessage); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        lpSubjectMessage = lpMessage; <br>    } <br>    else <br>    { <br>        lpSubjectMessage = lpEnvelope; <br>    } <br> <br>    // <br>    // Create a non delivery report in MTS-OUT <br>    // <br> <br>    if(lpSubjectMessage != NULL) <br>    { <br>        hr = HrCreateNonDeliveryReport( <br>            TRUE, <br>            lpAdrBook, <br>            lpMtsOutFolder, <br>            lpSubjectMessage, <br>            lpReportAdrList, <br>            &amp;lpReportEnvelope); <br> <br>        if(FAILED(hr)) <br>        { <br>            ; <br>        } <br>        else <br>        { <br>            HANDLE hNewMailEvent = GetGWNewMailEvent(); <br> <br>            if((hNewMailEvent != NULL) &amp;&amp; (!SetEvent(hNewMailEvent))) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>        } <br>    } <br> <br>cleanup: <br> <br>    ULRELEASE(lpReportEnvelope); <br> <br>    ULRELEASE(lpMessage); <br> <br>    FREEPADRLIST(lpReportAdrList); <br> <br>    RETURN(hr); <br>} <br> <br>//$--ProcessMtsIn--------------------------------------------------------------- <br>//  Process messages in MTS-IN. <br>// ----------------------------------------------------------------------------- <br>DWORD ProcessMtsIn(                     // RETURNS: zero <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT             hr                       = NOERROR; <br>    HRESULT             hrT                      = NOERROR; <br>    ULONG               i                        = 0; <br>    ULONG               cRows                    = 0; <br> <br>    LPMESSAGE           lpEnvelope               = NULL; <br> <br>    ULONG               cbMessageClass           = 0; <br>    LPTSTR              lpszMessageClass         = NULL; <br> <br>    LPSTREAM            lpStream                 = NULL; <br>    TCHAR               rgchFileName[MAX_PATH+1] = {0}; <br> <br>    DWORD               dwStartProcessingTime    = 0; <br> <br>    LPADRBOOK           lpAdrBook                = NULL; <br>    LPABCONT            lpGalABCont              = NULL; <br>    ULONG               ulObjType                = 0; <br> <br>SPropTagArray       sptExcludeNone           = {0}; <br>LPSTnefProblemArray lptpa                    = NULL; <br> <br>LPWIN32_FIND_DATA   rgFindData               = NULL; <br>LPWIN32_FIND_DATA   lpFindData               = NULL; <br> <br>    EDKCNVRES           crRes                    = GCR_OK; <br> <br>    // <br>    //  Declare an environment for the conversion. <br>    // <br> <br>    EDKCNVENV envTmp = <br>    {  <br>        1, </code></pre>
<p>
</p>
<pre><code>lpszInConverterW, <br>        (LHANDLE)NULL, <br>        NULL, <br>        NULL, <br>        NULL <br>    }; <br> <br>    CONV_OPTIONS sConvOptions =  <br>    { <br>        FALSE,              // attach TNEF encapsulation <br>        NULL                // address type <br>    }; <br> <br>    const LPCWSTR pszMessageClassW = L"ENVELOPE.IPM"; <br> <br>    PVOID           pvConvInstance              = NULL; <br> <br>    LPIDITEM        lpIdItem                    = NULL; <br> <br>    DEBUGPUBLIC("ProcessMtsIn()\n"); <br> <br>    //performance code <br> <br>    // Initialize conversion engine instance data. <br>    hr = HrConvInitInstance(hEventLog, &amp;pvConvInstance); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cRows       = GetGWFindDataSize(lpParameter); <br> <br>    rgFindData  = GetGWFindData(lpParameter); <br> <br>    lpAdrBook   = GetAdrBookPtr(); <br> <br>    lpGalABCont = GetGWGAL(); <br> <br> <br>    for(i = 0; i &lt; cRows; i++) <br>    { <br>        dwStartProcessingTime = GetTickCount(); <br> <br>//------------------------------------------------------------------------------ <br>    // Build file name of incoming message <br> <br>        lpFindData = &amp;rgFindData[i]; <br> <br>    lstrcpy(rgchFileName, lpszInDirectory); <br>    lstrcat(rgchFileName, lpFindData-&gt;cFileName); <br> <br>    //------------------------------------------------------------------------------ <br> <br>        // Adding file to the "being processed" list! <br>        // Prevents another thread from processing this file. <br>        hr = HrAddIdItem(&amp;InboundIdList, rgchFileName, &amp;lpIdItem); <br> <br>        if(hr == EDK_E_ALREADY_EXISTS) <br>        { <br>            // <br>            // Don't process this message. It is already being processed <br>            // by another thread. <br>            // <br> <br>            continue; <br>        } <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br> <br>        // Open a buffered stream on the input file. <br>    hrT = OpenStreamOnFile( <br>        MAPIAllocateBuffer, <br>        MAPIFreeBuffer, <br>    STGM_READ | STGM_SHARE_EXCLUSIVE,// stream interface flags <br>    rgchFileName, <br>    NULL, <br>    &amp;lpStream); <br> <br>    if(FAILED(hrT)) <br>    { <br>            // Temporarily can't access this file.   <br>            // We MUST remove it from the being processed list, since <br>            // this thread added it, but now can't continue to process it. <br>  goto SKIP; <br>    } <br> <br>        lpEnvelope = NULL; <br> <br>        hrT = MAPICALL(lpMtsInFolder)-&gt;CreateMessage( <br>            lpMtsInFolder, <br>            NULL, <br>            MAPI_DEFERRED_ERRORS, <br>            &amp;lpEnvelope); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>//------------------------------------------------------------------------------ <br> <br>        // Initialize the conversion environment structure <br> <br>        sConvOptions.lpszAddressType = lpszAddressType; <br> <br>        envTmp.lphSession      = (LHANDLE)lpSession; <br>        envTmp.lpAB            = lpAdrBook; <br>        envTmp.pGatewayDefined = &amp;sConvOptions; <br> <br>        // <br>        //  Perform the conversion. <br>        // <br> <br>        hr = HrConvConvert( <br>            pvConvInstance,         // conversion instance pointer <br>            &amp;envTmp,                // environment structure pointer <br>            pszMessageClassW,       // dummy message class <br>            lpStream,               // stream to read from <br>            lpEnvelope,             // message to convert to <br>            &amp;crRes);                // result pointer <br> <br>        if(FAILED(hr) || crRes != GCR_OK) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>//------------------------------------------------------------------------------ <br> <br>        // Get the message class <br> <br>        MAPIFREEBUFFER(lpszMessageClass); <br> <br>        cbMessageClass = 0; <br>        lpszMessageClass = NULL; <br> <br>        hr = HrMAPIGetPropString( <br>            (LPMAPIPROP)lpEnvelope, <br>            PR_MESSAGE_CLASS, <br>            &amp;cbMessageClass, <br>            (void **)&amp;lpszMessageClass); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        MODULE_WARNING1( <br>            "**** [IN ] Processing message of class [%s] ****", <br>            ((lpszMessageClass == NULL) ? "(null)" : lpszMessageClass)); <br> <br>        // <br>        // Check for inconsistencies in MTS-ID &amp; external trace information. <br>        // <br> <br>        hr = HrCheckExternalTraceInformation(lpEnvelope); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Process the message <br> <br>        if(_tcsstr(lpszMessageClass, TEXT("ENVELOPE.IPM")) != NULL) <br>        { <br>            hr = HrMAPISetPropBoolean( <br>                (LPMAPIPROP)lpEnvelope, <br>                PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED, <br>                TRUE); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrMAPISetPropBoolean( <br>                (LPMAPIPROP)lpEnvelope, <br>                PR_NON_RECEIPT_NOTIFICATION_REQUESTED, <br>                TRUE); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrImportMessage( <br>                lpAdrBook, <br>                lpGalABCont, <br>                FALSE, <br>                TRUE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) &amp;&amp; <br>                (_tcsstr(lpszMessageClass, TEXT(".NDR")) != NULL)) <br>        { <br>            hr = HrMAPISetPropBoolean( <br>                (LPMAPIPROP)lpEnvelope, <br>                PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED, <br>                TRUE); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrDeleteSenderProps( <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrImportMessage( <br>                lpAdrBook, <br>                lpGalABCont, <br>                TRUE, <br>                FALSE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) &amp;&amp; <br>                (_tcsstr(lpszMessageClass, TEXT(".DR")) != NULL)) <br>        { <br>            hr = HrMAPISetPropBoolean( <br>                (LPMAPIPROP)lpEnvelope, <br>                PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED, <br>                TRUE); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrDeleteSenderProps( <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrImportMessage( <br>                lpAdrBook, <br>                lpGalABCont, <br>                TRUE, <br>                FALSE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) &amp;&amp; <br>                (_tcsstr(lpszMessageClass, TEXT(".IPNNRN")) != NULL)) <br>        { <br>            hr = HrMAPISetPropBoolean( <br>                (LPMAPIPROP)lpEnvelope, <br>                PR_NON_RECEIPT_NOTIFICATION_REQUESTED, <br>                TRUE); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrImportMessage( <br>                lpAdrBook, <br>                lpGalABCont, <br>                FALSE, <br>                FALSE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) &amp;&amp; <br>                (_tcsstr(lpszMessageClass, TEXT(".IPNRN")) != NULL)) <br>        { <br>            hr = HrMAPISetPropBoolean( <br>                (LPMAPIPROP)lpEnvelope, <br>                PR_READ_RECEIPT_REQUESTED, <br>                TRUE); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrImportMessage( <br>                lpAdrBook, <br>                lpGalABCont, <br>                FALSE, <br>                FALSE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else <br>        { <br>            hr = HrNonDeliverMtsInMessage( <br>                lpszMessageClass, <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                ; // failed to non-deliver message <br>            } <br>        } <br> <br>        if(FAILED(hr)) <br>        { <br>            MODULE_ERROR1( <br>                "**** [IN ] Error while processing message of class [%s] ****", <br>                ((lpszMessageClass == NULL) ? "(null)" : lpszMessageClass)); <br> <br>            // <br>            // This message will be moved to the archive directory. <br>            // <br> <br>            ULRELEASE(lpStream); <br>            MAPIFREEBUFFER(lpszMessageClass); <br>            ULRELEASE(lpEnvelope); <br>            continue; <br>        } <br> <br>        ULRELEASE(lpStream); <br> <br>        MAPIFREEBUFFER(lpszMessageClass); <br> <br>        ULRELEASE(lpEnvelope); <br> <br>        //performance code <br> <br>        if(!DeleteFile(rgchFileName)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br> <br>    //------------------------------------------------------------------------------ <br> <br>SKIP:   // can't process this file now, so remove it from the "being processed" list. <br> <br>        hr = HrRemoveIdItem(&amp;InboundIdList, lpIdItem); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br>    } <br> <br>cleanup: <br> <br>    ULRELEASE(lpStream); <br> <br>    MAPIFREEBUFFER(lpszMessageClass); <br> <br>    ULRELEASE(lpEnvelope); <br> <br>    if(pvConvInstance != NULL) <br>    { <br>        // De-initialize conversion engine instance data. <br>        (VOID)HrConvUninitInstance(pvConvInstance); <br>        pvConvInstance = NULL; <br>    } <br> <br>    return(0); <br>} <br> <br>//$--HrExportMessage------------------------------------------------------------ <br>// Process an IPM/IPN in MTS-OUT. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrExportMessage(                // RETURNS: return code <br>    IN LPADRBOOK lpAdrBook,             // pointer to address book <br>    IN BOOL fIgnoreRespValue,           // ignore  responsibility value <br>    IN BOOL fSendNDR,                   // TRUE if NDRs should be generated <br>    IN DWORD dwStartProcessingTime,     // start processing time <br>    IN OUT LPMESSAGE lpEnvelope)        // pointer to envelope <br>{ <br>    HRESULT             hr                        = NOERROR; <br>    HRESULT             hrT                       = NOERROR; <br> <br>    LPMESSAGE           lpMessage                 = NULL; <br>    LPATTACH            lpAttach                  = NULL; <br> <br>    ULONG               cEnvelopeValues           = 0; <br>    LPSPropValue        lpEnvelopeProps           = NULL; <br>    ULONG               cMessageValues            = 0; <br>    LPSPropValue        lpMessageProps            = NULL; <br> <br>    LPADRLIST           lpOriginalEnvelopeAdrList = NULL; <br>    LPADRLIST           lpOriginalMessageAdrList  = NULL; <br> <br>    LPADRLIST           lpEnvelopeAdrList         = NULL; <br>    LPADRLIST           lpMessageAdrList          = NULL; <br> <br>    LPADRLIST           lpEnvelope_NDR_AdrList    = NULL; <br>    LPADRLIST           lpMessage_NDR_AdrList     = NULL; <br> <br>    DWORD               dwEndProcessingTime       = 0; <br>    DWORD               dwTotalProcessingTime     = 0; <br>    DWORD               dwSleepProcessingTime     = 0; <br> <br>    ULONG               cbeid                     = 0; <br>    LPENTRYID           lpeid                     = NULL; <br> <br>    ULONG               cEnvelopeMesgAddr         = 0; <br>    ULONG               cEnvelopeReplyAddr        = 0; <br>    ULONG               cEnvelopeRecipAddr        = 0; <br>    LPADRLIST           lpEnvelopeAllAdrList      = NULL; <br>    LPADRLIST           lpMappedEnvelopeAdrList   = NULL; <br> <br>    ULONG               cMessageMesgAddr          = 0; <br>    ULONG               cMessageReplyAddr         = 0; <br>    ULONG               cMessageRecipAddr         = 0; <br>    LPADRLIST           lpMessageAllAdrList       = NULL; <br>    LPADRLIST           lpMappedMessageAdrList    = NULL; <br> <br>    BOOL                HasContent                = TRUE; <br> <br>    LPSPropProblemArray lpProblems                = NULL; <br> <br>    DEBUGPUBLIC("HrExportMessage()\n"); <br> <br>    // Get the attachment in the envelope <br>    hrT = MAPICALL(lpEnvelope)-&gt;OpenAttach( <br>        lpEnvelope, <br>        0, <br>        NULL, <br>        MAPI_MODIFY, <br>        &amp;lpAttach); <br> <br>    if((FAILED(hrT)) &amp;&amp; (hrT != MAPI_E_NOT_FOUND)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(hrT == MAPI_E_NOT_FOUND) <br>    { <br>        // <br>        // Message does not have an attachment. <br>        // <br> <br>        HasContent = FALSE; <br>        lpAttach   = NULL; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        // Open a message interface on the attachment <br>        hrT = MAPICALL(lpAttach)-&gt;OpenProperty( <br>            lpAttach, <br>            PR_ATTACH_DATA_OBJ, <br>            (LPIID)&amp;IID_IMessage, <br>            0, <br>            MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>            (LPUNKNOWN *)&amp;lpMessage); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    // <br>    // Map envelope addresses <br>    // <br> <br>    hr = HrExpandMessageAddressList( <br>        lpEnvelope, <br>        &amp;cEnvelopeMesgAddr, <br>        &amp;cEnvelopeReplyAddr, <br>        &amp;cEnvelopeRecipAddr, <br>        &amp;lpOriginalEnvelopeAdrList, <br>        &amp;lpEnvelopeAllAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMapAddrToProxy( <br>        lpAdrBook, <br>        lpszAddressType, <br>        lpEnvelopeAllAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMapGatewayAddrToProxy( <br>        lpAdrBook, <br>        lpszAddressType, <br>        lpEnvelopeAllAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrCollapseMessageAddressList( <br>        lpEnvelope, <br>        cEnvelopeMesgAddr, <br>        cEnvelopeReplyAddr, <br>        cEnvelopeRecipAddr, <br>        lpEnvelopeAllAdrList, <br>        &amp;cEnvelopeValues, <br>        &amp;lpEnvelopeProps, <br>        &amp;lpMappedEnvelopeAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    FREEPADRLIST(lpEnvelopeAllAdrList); <br> <br>    if(HasContent == TRUE) <br>    { <br>        // <br>        // Map message addresses <br>        // <br> <br>        hr = HrExpandMessageAddressList( <br>            lpMessage, <br>            &amp;cMessageMesgAddr, <br>            &amp;cMessageReplyAddr, <br>            &amp;cMessageRecipAddr, <br>            &amp;lpOriginalMessageAdrList, <br>            &amp;lpMessageAllAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrMapAddrToProxy( <br>            lpAdrBook, <br>            lpszAddressType, <br>            lpMessageAllAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrMapGatewayAddrToProxy( <br>            lpAdrBook, <br>            lpszAddressType, <br>            lpMessageAllAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrCollapseMessageAddressList( <br>            lpMessage, <br>            cMessageMesgAddr, <br>            cMessageReplyAddr, <br>            cMessageRecipAddr, <br>            lpMessageAllAdrList, <br>            &amp;cMessageValues, <br>            &amp;lpMessageProps, <br>            &amp;lpMappedMessageAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        FREEPADRLIST(lpMessageAllAdrList); <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    hr = HrMapRecipAddrToProxy( <br>        lpAdrBook, <br>        TRUE, <br>        fIgnoreRespValue, <br>        lpszAddressType, <br>        NULL, <br>        lpOriginalEnvelopeAdrList, <br>        lpMappedEnvelopeAdrList, <br>        NULL, <br>        NULL, <br>        lpEnvelope, <br>        &amp;lpEnvelopeAdrList, <br>        &amp;lpEnvelope_NDR_AdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        hr = HrMapRecipAddrToProxy( <br>            lpAdrBook, <br>            FALSE, <br>            fIgnoreRespValue, <br>            lpszAddressType, <br>            lpOriginalEnvelopeAdrList, <br>            lpOriginalMessageAdrList, <br>            lpMappedMessageAdrList, <br>            lpEnvelopeAdrList, <br>            lpEnvelope_NDR_AdrList, <br>            lpMessage, <br>            &amp;lpMessageAdrList, <br>            &amp;lpMessage_NDR_AdrList); <br> <br>        FREEPADRLIST(lpOriginalEnvelopeAdrList); <br> <br>        FREEPADRLIST(lpOriginalMessageAdrList); <br> <br>        FREEPADRLIST(lpMessage_NDR_AdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // Non-deliver any recipients that could not be mapped. <br> <br>    if((lpEnvelope_NDR_AdrList != NULL) &amp;&amp; <br>       (lpEnvelope_NDR_AdrList-&gt;cEntries != 0) &amp;&amp; <br>       (fSendNDR == TRUE)) <br>    { <br>        LPMESSAGE lpReportEnvelope = NULL; <br> <br>        // <br>        // Clear row IDs for envelope NDR address list. <br>        // <br> <br>        hr = HrDeleteAddressListProperty( <br>            PR_ROWID, <br>            (LPADRLIST)lpEnvelope_NDR_AdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // <br>        // Create a non delivery report in MTS-IN <br>        // <br> <br>        hr = HrCreateNonDeliveryReport( <br>            FALSE, <br>            lpAdrBook, <br>            lpMtsInFolder, <br>            lpMessage, <br>            lpEnvelope_NDR_AdrList, <br>            &amp;lpReportEnvelope); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        hr = HrMAPISetPropBoolean( <br>            (LPMAPIPROP)lpReportEnvelope, <br>            PR_DELETE_AFTER_SUBMIT, <br>            TRUE); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            ULRELEASE(lpReportEnvelope); <br> <br>            goto cleanup; <br>        } <br> <br>        // Submit message <br>        hrT = MAPICALL(lpReportEnvelope)-&gt;SubmitMessage(lpReportEnvelope, FORCE_SUBMIT); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hrT = HR_LOG(hrT); <br>        } <br> <br>        ULRELEASE(lpReportEnvelope); <br>    } <br> <br>    FREEPADRLIST(lpEnvelope_NDR_AdrList); <br> <br>    if((lpEnvelopeAdrList == NULL) || (lpEnvelopeAdrList-&gt;cEntries == 0)) <br>    { <br>        FREEPADRLIST(lpEnvelopeAdrList); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        if((lpMessageAdrList == NULL) || (lpMessageAdrList-&gt;cEntries == 0)) <br>        { <br>            FREEPADRLIST(lpMessageAdrList); <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    // Fix up recipient numbers <br>    hr = HrFixUpRecipientNumbers(lpEnvelopeAdrList, lpMessageAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    hrT = MAPICALL(lpEnvelope)-&gt;SetProps( <br>        lpEnvelope, <br>        cEnvelopeValues, <br>        lpEnvelopeProps, <br>        &amp;lpProblems); <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpProblems = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    DUMPPROPPROBLEMS(lpProblems); <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    if(HasContent == TRUE) <br>    { <br>        hrT = MAPICALL(lpMessage)-&gt;SetProps( <br>            lpMessage, <br>            cMessageValues, <br>            lpMessageProps, <br>            &amp;lpProblems); <br> <br>        if(FAILED(hrT)) <br>        { <br>            lpProblems = NULL; <br> <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        DUMPPROPPROBLEMS(lpProblems); <br>        MAPIFREEBUFFER(lpProblems); <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    // Set envelope recipients <br>    hrT = MAPICALL(lpEnvelope)-&gt;ModifyRecipients( <br>        lpEnvelope, <br>        0, <br>        lpEnvelopeAdrList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(HasContent == TRUE) <br>    { <br>        // Set message recipients <br>        hrT = MAPICALL(lpMessage)-&gt;ModifyRecipients( <br>            lpMessage, <br>            0, <br>            lpMessageAdrList); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>//------------------------------------------------------------------------------ <br> <br>    if(HasContent == TRUE) <br>    { <br>        // Save changes to the message <br>        hrT = MAPICALL(lpMessage)-&gt;SaveChanges( <br>            lpMessage, <br>            MAPI_DEFERRED_ERRORS|FORCE_SAVE); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Save changes to attachment object <br>        hrT = MAPICALL(lpAttach)-&gt;SaveChanges( <br>            lpAttach, <br>            MAPI_DEFERRED_ERRORS|FORCE_SAVE); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        ULRELEASE(lpMessage); <br> <br>        ULRELEASE(lpAttach); <br>    } <br> <br>    // Save changes to the envelope <br>    hrT = MAPICALL(lpEnvelope)-&gt;SaveChanges( <br>        lpEnvelope, <br>        MAPI_DEFERRED_ERRORS|KEEP_OPEN_READWRITE); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    //---------------------------------------------------------------------- <br>    dwEndProcessingTime     = GetTickCount(); <br> <br>    dwTotalProcessingTime   = dwEndProcessingTime - dwStartProcessingTime; <br> <br>    dwSleepProcessingTime   = <br>        ((dwTotalProcessingTime &lt; dwOutSleepInterval) ? <br>         (dwOutSleepInterval - dwTotalProcessingTime) : 0); <br> <br>    if(dwSleepProcessingTime &gt; 0) <br>    { <br>        Sleep(dwSleepProcessingTime); <br>    } <br>    //---------------------------------------------------------------------- <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpProblems); <br> <br>    MAPIFREEBUFFER(lpeid); <br> <br>    FREEPADRLIST(lpOriginalEnvelopeAdrList); <br> <br>    FREEPADRLIST(lpOriginalMessageAdrList); <br> <br>    FREEPADRLIST(lpEnvelopeAdrList); <br> <br>    FREEPADRLIST(lpMessageAdrList); <br> <br>    FREEPADRLIST(lpEnvelope_NDR_AdrList); <br> <br>    FREEPADRLIST(lpMessage_NDR_AdrList); <br> <br>    FREEPADRLIST(lpEnvelopeAllAdrList); <br> <br>    FREEPADRLIST(lpMessageAllAdrList); <br> <br>    FREEPADRLIST(lpMappedEnvelopeAdrList); <br>    FREEPADRLIST(lpMappedMessageAdrList); <br> <br>    MAPIFREEBUFFER(lpEnvelopeProps); <br>    MAPIFREEBUFFER(lpMessageProps); <br> <br>    ULRELEASE(lpMessage); <br> <br>    ULRELEASE(lpAttach); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrConvertMtsOut------------------------------------------------------------ <br>//  Convert a message in MTS-OUT. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrConvertMtsOut(                // RETURNS: return code <br>    IN PVOID     pvConvInstance,        // converter instance <br>    IN LPADRBOOK lpAdrBook,             // pointer to address book <br>    IN LPTSTR    lpszMessageClass,      // message class <br>    IN LPMESSAGE lpMessage)             // message <br>{ <br>    HRESULT      hr                          = NOERROR; <br>    HRESULT      hrT                         = NOERROR; <br>    LPSRowSet    lpRows                      = NULL; <br>    LPADRLIST    lpAdrList                   = NULL; <br>    LPMAPITABLE  lpTable                     = NULL; <br>    BOOL         fFileCreated                = FALSE;   // TRUE if output file created <br> <br>    ULONG        cValues                     = 0; <br>    LPSPropValue lpProps                     = NULL; <br>    LPSPropValue lpPropT                     = NULL; <br> <br>    BOOL         IsMapiRecip                 = 0; <br>    LPTSTR       lpszAddress                 = NULL; <br> <br>    LPADRLIST    lpMapiAdrList               = NULL; <br>    LPADRLIST    lpNonMapiAdrList            = NULL; <br> <br>    ULONG        i                           = 0; <br> <br>    LPSTREAM     lpStream                    = NULL; <br>    TCHAR        rgchOutFileName[MAX_PATH+1] = {0}; <br> <br>    EDKCNVRES    crRes                       = GCR_OK; <br> <br>    // <br>    //  Declare an environment for the conversion. <br>    // <br> <br>    EDKCNVENV envTmp = <br>    {  <br>        1, <br>        lpszOutConverterW, <br>        (LHANDLE)NULL, <br>        NULL, <br>        NULL, <br>        NULL <br>    }; <br> <br>    CONV_OPTIONS sConvOptions =  <br>    { <br>        FALSE,              // attach TNEF encapsulation <br>        NULL                // address type <br>    }; <br> <br>    ULONG  cbMessageClass                    = 0; <br>    LPWSTR lpszMessageClassW                 = NULL; <br> <br>    ULONG  iMapi                             = 0; <br>    ULONG  iNonMapi                          = 0; <br> <br>    SizedSPropTagArray(1, rgPropTags) = <br>    { <br>        1, <br>        { <br>            PR_REPORT_DESTINATION_ENTRYID, <br>        } <br>    }; <br> <br>// stream interface flags <br>const ULONGulFlags=STGM_CREATE | STGM_READWRITE |  <br>  SOF_UNIQUEFILENAME | STGM_SHARE_EXCLUSIVE; <br> <br>    DEBUGPUBLIC("HrConvertMtsOut()\n"); <br> <br>    if(_tcsstr(lpszMessageClass, TEXT("ENVELOPE.IPM")) != NULL) <br>    { <br>        // <br>        // Get the recipient table for the message <br>        // <br> <br>        hrT = MAPICALL(lpMessage)-&gt;GetRecipientTable( <br>            lpMessage, <br>            MAPI_DEFERRED_ERRORS, <br>            &amp;lpTable); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    // <br>    //  Query all the rows <br>    // <br> <br>    hr = HrQueryAllRows( <br>        lpTable, <br>    NULL, <br>    NULL, <br>    NULL, <br>    0, <br>    &amp;lpRows); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // <br>        // Divide recipient list into MAPI and non-MAPI recipients <br>        // <br> <br>        lpAdrList = (LPADRLIST)lpRows; <br> <br>        hr = HrMAPICreateSizedAddressList( <br>            lpAdrList-&gt;cEntries, <br>            &amp;lpMapiAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        hr = HrMAPICreateSizedAddressList( <br>            lpAdrList-&gt;cEntries, <br>            &amp;lpNonMapiAdrList); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        for(i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>        { <br>            cValues = lpAdrList-&gt;aEntries[i].cValues; <br>            lpProps = lpAdrList-&gt;aEntries[i].rgPropVals; <br> <br>            lpPropT = LpValFindProp(PR_SEND_RICH_INFO, cValues, lpProps); <br> <br>            if(lpPropT != NULL) <br>            { <br>                IsMapiRecip = lpPropT-&gt;Value.b; <br>            } <br>            else <br>            { <br>                IsMapiRecip = FALSE; <br>            } <br> <br>            if(IsMapiRecip == TRUE) <br>            { <br>                hr = HrMAPISetAddressList( <br>                    iMapi, <br>                    cValues, <br>                    lpProps, <br>                    lpMapiAdrList); <br> <br>                iMapi++; <br> <br>                if(FAILED(hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>            } <br>            else <br>            { <br>                hr = HrMAPISetAddressList( <br>                    iNonMapi, <br>                    cValues, <br>                    lpProps, <br>                    lpNonMapiAdrList); <br> <br>                iNonMapi++; <br> <br>                if(FAILED(hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>            } <br>        }   // end for <br>         <br>        // <br>        // Convert message for MAPI recipients <br>        // </code></pre>
<p>
</p>
<pre><code><br>        if(iMapi &gt; 0) <br>        { <br>            // Set envelope recipients <br>            hrT = MAPICALL(lpMessage)-&gt;ModifyRecipients( <br>                lpMessage, <br>                0, <br>                lpMapiAdrList); <br> <br>            if(FAILED(hrT)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hrT = MAPICALL(lpMessage)-&gt;SaveChanges( <br>                lpMessage, <br>                KEEP_OPEN_READWRITE); <br> <br>            if(FAILED(hrT)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>    //------------------------------------------------------------------------------ <br> <br>        lstrcpy(rgchOutFileName, lpszOutDirectory); <br> <br>            // Open a buffered stream on our SGW*.TMP output file. <br>        hrT = OpenStreamOnFile( <br>            MAPIAllocateBuffer, <br>            MAPIFreeBuffer, <br>        ulFlags,// stream interface flags <br>        rgchOutFileName, <br>        szFilePrefix, <br>        &amp;lpStream); <br> <br>        if(FAILED(hrT)) <br>        { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>        } <br> <br>            fFileCreated = TRUE;    // output file has been created <br> <br>        //------------------------------------------------------------------------------ <br> <br>            // Get the message class <br> <br>            MAPIFREEBUFFER(lpszMessageClassW); <br> <br>            cbMessageClass = 0; <br>            lpszMessageClassW = NULL; <br> <br>            hr = HrMAPIGetPropString( <br>                (LPMAPIPROP)lpMessage, <br>                PR_MESSAGE_CLASS_W, <br>                &amp;cbMessageClass, <br>                (void **)&amp;lpszMessageClassW); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            // Initialize the conversion environment structure <br> <br>            sConvOptions.fTnefEncode     = TRUE; <br>            sConvOptions.lpszAddressType = lpszAddressType; <br> <br>            envTmp.lphSession      = (LHANDLE)lpSession; <br>            envTmp.lpAB            = lpAdrBook; <br>            envTmp.pGatewayDefined = &amp;sConvOptions; <br> <br>            // <br>            //  Perform the conversion. <br>            // <br> <br>            hr = HrConvConvert( <br>                pvConvInstance,         // conversion instance pointer <br>                &amp;envTmp,                // environment structure pointer <br>                lpszMessageClassW,      // message class <br>                lpMessage,              // message to convert from <br>                lpStream,               // stream to read to <br>                &amp;crRes);                // result pointer <br> <br>            if(FAILED(hr) || crRes != GCR_OK) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>        //------------------------------------------------------------------------------ <br> <br>            ULRELEASE(lpStream); <br> <br>            // <br>            // Finished processing message <br>            // <br> <br>            { <br>                BOOL fT = FALSE; <br> <br>                fT = SetFileAttributes(rgchOutFileName, FILE_ATTRIBUTE_NORMAL); <br> <br>                if(fT == FALSE) <br>                { <br>                    hrT = HR_LOG(E_FAIL); <br>                } <br>            } <br>        }   // end if MAPI recipients <br> <br>        // <br>        // Convert message for non-MAPI recipients <br>        // <br> <br>        if(iNonMapi &gt; 0) <br>        { <br>            // Set envelope recipients <br>            hrT = MAPICALL(lpMessage)-&gt;ModifyRecipients( <br>                lpMessage, <br>                0, <br>                lpNonMapiAdrList); <br> <br>            if(FAILED(hrT)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hrT = MAPICALL(lpMessage)-&gt;SaveChanges( <br>                lpMessage, <br>                KEEP_OPEN_READWRITE); <br> <br>            if(FAILED(hrT)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>    //------------------------------------------------------------------------------ <br> <br>        lstrcpy(rgchOutFileName, lpszOutDirectory); <br> <br>        hrT = OpenStreamOnFile( <br>            MAPIAllocateBuffer, <br>            MAPIFreeBuffer, <br>        STGM_CREATE | STGM_READWRITE | SOF_UNIQUEFILENAME, <br>        rgchOutFileName, <br>        szFilePrefix, <br>        &amp;lpStream); <br> <br>        if(FAILED(hrT)) <br>        { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>        } <br> <br>            fFileCreated = TRUE;    // output file has been created <br> <br>        //------------------------------------------------------------------------------ <br> <br>            // Get the message class <br> <br>            MAPIFREEBUFFER(lpszMessageClassW); <br> <br>            cbMessageClass = 0; <br>            lpszMessageClassW = NULL; <br> <br>            hr = HrMAPIGetPropString( <br>                (LPMAPIPROP)lpMessage, <br>                PR_MESSAGE_CLASS_W, <br>                &amp;cbMessageClass, <br>                (void **)&amp;lpszMessageClassW); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            // Initialize the conversion environment structure <br> <br>            sConvOptions.fTnefEncode     = FALSE; <br>            sConvOptions.lpszAddressType = lpszAddressType; <br> <br>            envTmp.lphSession      = (LHANDLE)lpSession; <br>            envTmp.lpAB            = lpAdrBook; <br>            envTmp.pGatewayDefined = &amp;sConvOptions; <br> <br>            // <br>            //  Perform the conversion. <br>            // <br> <br>            hr = HrConvConvert( <br>                pvConvInstance,         // conversion instance pointer <br>                &amp;envTmp,                // environment structure pointer <br>                lpszMessageClassW,      // message class <br>                lpMessage,              // message to convert from <br>                lpStream,               // stream to read to <br>                &amp;crRes);                // result pointer <br> <br>            if(FAILED(hr) || crRes != GCR_OK) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>        //------------------------------------------------------------------------------ <br> <br>            ULRELEASE(lpStream); <br> <br>            // <br>            // Finished processing message <br>            // <br> <br>            { <br>                BOOL fT = FALSE; <br> <br>                fT = SetFileAttributes(rgchOutFileName, FILE_ATTRIBUTE_NORMAL); <br> <br>                if(fT == FALSE) <br>                { <br>                    hrT = HR_LOG(E_FAIL); <br>                } <br>            } <br>        }   // end if non-MAPI recipients <br>    }   // end if Interpersonal message <br> <br>    else if(_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) <br>    { <br>        // <br>        // Determine if the report/notification recipient is a MAPI <br>        // or a non-MAPI recipient. <br>        // <br> <br>        if((_tcsstr(lpszMessageClass, TEXT(".NDR")) != NULL) || <br>           (_tcsstr(lpszMessageClass, TEXT(".DR")) != NULL)) <br>        { <br>            // <br>            // Get destination of non-delivery/delivery report. <br>            // <br> <br>            hr = MAPICALL(lpMessage)-&gt;GetProps( <br>                lpMessage, <br>                (SPropTagArray *)&amp;rgPropTags, <br>                fMapiUnicode, <br>                &amp;cValues, <br>                &amp;lpProps); <br> <br>            if(FAILED(hr)) <br>            { <br>                lpProps = NULL; <br> <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            hr = HrGWResolveProxy( <br>                lpAdrBook, <br>                lpProps-&gt;Value.bin.cb, <br>                (LPENTRYID)lpProps-&gt;Value.bin.lpb, <br>                lpszAddressType, <br>                &amp;IsMapiRecip, <br>                &amp;lpszAddress); <br> <br>            MAPIFREEBUFFER(lpProps); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT(".IPNNRN")) != NULL) || <br>                (_tcsstr(lpszMessageClass, TEXT(".IPNRN")) != NULL)) <br>        { <br>            // <br>            // Get the recipient table for the non-read/read notification. <br>            // <br> <br>            hrT = MAPICALL(lpMessage)-&gt;GetRecipientTable( <br>                lpMessage, <br>                MAPI_DEFERRED_ERRORS, <br>                &amp;lpTable); <br> <br>            if(FAILED(hrT)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>        // <br>        //  Query all the rows <br>        // <br> <br>        hr = HrQueryAllRows( <br>            lpTable, <br>        NULL, <br>        NULL, <br>        NULL, <br>        0, <br>        &amp;lpRows); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            lpAdrList = (LPADRLIST)lpRows; <br>            cValues   = lpAdrList-&gt;aEntries[i].cValues; <br>            lpProps   = lpAdrList-&gt;aEntries[i].rgPropVals; <br> <br>            lpPropT = LpValFindProp(PR_SEND_RICH_INFO, cValues, lpProps); <br> <br>            if(lpPropT != NULL) <br>            { <br>                IsMapiRecip = lpPropT-&gt;Value.b; <br>            } <br>            else <br>            { <br>                IsMapiRecip = FALSE; <br>            } <br> <br>            FREEPADRLIST(lpAdrList); <br>        } <br>        else <br>        { <br>            IsMapiRecip = FALSE; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br> <br>    lstrcpy(rgchOutFileName, lpszOutDirectory); <br> <br>    hrT = OpenStreamOnFile( <br>        MAPIAllocateBuffer, <br>        MAPIFreeBuffer, <br>    STGM_CREATE | STGM_READWRITE | SOF_UNIQUEFILENAME, <br>    rgchOutFileName, <br>    szFilePrefix, <br>    &amp;lpStream); <br> <br>    if(FAILED(hrT)) <br>    { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>    } <br> <br>        fFileCreated = TRUE;    // output file has been created <br> <br>    //------------------------------------------------------------------------------ <br> <br>        // Get the message class <br> <br>        MAPIFREEBUFFER(lpszMessageClassW); <br> <br>        cbMessageClass = 0; <br>        lpszMessageClassW = NULL; <br> <br>        hr = HrMAPIGetPropString( <br>            (LPMAPIPROP)lpMessage, <br>            PR_MESSAGE_CLASS_W, <br>            &amp;cbMessageClass, <br>            (void **)&amp;lpszMessageClassW); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Initialize the conversion environment structure <br> <br>        sConvOptions.fTnefEncode     = IsMapiRecip; <br>        sConvOptions.lpszAddressType = lpszAddressType; <br> <br>        envTmp.lphSession            = (LHANDLE)lpSession; <br>        envTmp.lpAB                  = lpAdrBook; <br>        envTmp.pGatewayDefined       = &amp;sConvOptions; <br> <br>        // <br>        //  Perform the conversion. <br>        // <br> <br>        hr = HrConvConvert( <br>            pvConvInstance,         // conversion instance pointer <br>            &amp;envTmp,                // environment structure pointer <br>            lpszMessageClassW,      // message class <br>            lpMessage,              // message to convert from <br>            lpStream,               // stream to read to <br>            &amp;crRes);                // result pointer <br> <br>        if(FAILED(hr) || crRes != GCR_OK) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br> <br>        ULRELEASE(lpStream); <br> <br>        // <br>        // Finished processing message <br>        // <br> <br>        { <br>            BOOL fT = FALSE; <br> <br>            fT = SetFileAttributes(rgchOutFileName, FILE_ATTRIBUTE_NORMAL); <br> <br>            if(fT == FALSE) <br>            { <br>                hrT = HR_LOG(E_FAIL); <br>            } <br>        } <br>    }   // end if report <br> <br>    else <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // delete the output file created, if any. <br>        if ( fFileCreated == TRUE ) <br>        { <br>            // Must release the stream first! <br>            ULRELEASE(lpStream); <br> <br>            (VOID)DeleteFile(rgchOutFileName); <br>        } <br>    } <br> <br>    MAPIFREEBUFFER(lpszAddress); <br>    MAPIFREEBUFFER(lpszMessageClassW); <br> <br>    FREEPADRLIST(lpAdrList);        // also frees lpRows <br> <br>    FREEPADRLIST(lpMapiAdrList); <br> <br>    FREEPADRLIST(lpNonMapiAdrList); <br> <br>    ULRELEASE(lpStream); <br> <br>    ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrNonDeliverMtsOutMessage-------------------------------------------------- <br>//  Non-deliver a message in MTS-OUT. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrNonDeliverMtsOutMessage(      // RETURNS: zero <br>    IN LPTSTR lpszMessageClass,         // message class <br>    IN LPMESSAGE lpEnvelope)            // envelope <br>{ <br>    HRESULT   hr               = NOERROR; <br>    LPADRBOOK lpAdrBook        = NULL; <br>    LPMESSAGE lpMessage        = NULL; <br>    LPMESSAGE lpSubjectMessage = NULL; <br>    LPMESSAGE lpReportEnvelope = NULL; <br>    LPADRLIST lpReportAdrList  = NULL; <br>    LPATTACH  lpAttach         = NULL; <br>    BOOL      HasContent       = TRUE; <br> <br>    DEBUGPUBLIC("HrNonDeliverMtsOutMessage()\n"); <br> <br>    lpAdrBook   = GetAdrBookPtr(); <br> <br>    MODULE_ERROR1( <br>        "**** [IN ] Unknown message class [%s] ****", <br>        ((lpszMessageClass == NULL) ? "(null)" : lpszMessageClass)); <br> <br>    hr = HrNonDeliverAllRecipList( <br>        lpEnvelope, <br>        &amp;lpReportAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Get the attachment in the envelope <br>    hr = MAPICALL(lpEnvelope)-&gt;OpenAttach( <br>        lpEnvelope, <br>        0, <br>        NULL, <br>        MAPI_MODIFY, <br>        &amp;lpAttach); <br> <br>    if((FAILED(hr)) &amp;&amp; (hr != MAPI_E_NOT_FOUND)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if(hr == MAPI_E_NOT_FOUND) <br>    { <br>        // <br>        // Message does not have an attachment. <br>        // <br> <br>        HasContent = FALSE; <br>        lpAttach   = NULL; <br>    } <br> <br>    lpSubjectMessage = NULL; <br> <br>    if(HasContent == TRUE) <br>    { <br>        // Open a message interface on the attachment <br>        hr = MAPICALL(lpAttach)-&gt;OpenProperty( <br>            lpAttach, <br>            PR_ATTACH_DATA_OBJ, <br>            (LPIID)&amp;IID_IMessage, <br>            0, <br>            MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>            (LPUNKNOWN *)&amp;lpMessage); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        lpSubjectMessage = lpMessage; <br>    } <br>    else <br>    { <br>        lpSubjectMessage = lpEnvelope; <br>    } <br> <br>    // <br>    // Create a non delivery report in MTS-IN <br>    // <br> <br>    if(lpSubjectMessage != NULL) <br>    { <br>        hr = HrCreateNonDeliveryReport( <br>            FALSE, <br>            lpAdrBook, <br>            lpMtsInFolder, <br>            lpSubjectMessage, <br>            lpReportAdrList, <br>            &amp;lpReportEnvelope); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        hr = HrMAPISetPropBoolean( <br>            (LPMAPIPROP)lpReportEnvelope, <br>            PR_DELETE_AFTER_SUBMIT, <br>            TRUE); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // Submit message <br>        hr = MAPICALL(lpReportEnvelope)-&gt;SubmitMessage(lpReportEnvelope, FORCE_SUBMIT); <br> <br>        if(FAILED(hr)) <br>        { <br>            ; <br>        } <br>    } <br> <br>cleanup: <br> <br>    ULRELEASE(lpReportEnvelope); <br> <br>    ULRELEASE(lpMessage); <br> <br>    FREEPADRLIST(lpReportAdrList); <br> <br>    RETURN(hr); <br>} <br> <br>//$--ProcessMtsOut-------------------------------------------------------------- <br>//  Process messages in MTS-OUT. <br>// ----------------------------------------------------------------------------- <br>DWORD ProcessMtsOut(                    // RETURNS: zero <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT         hr                          = NOERROR; <br>    HRESULT         hrT                         = NOERROR; <br>    SCODE           sc                          = 0; <br>    ULONG           cbeid                       = 0; <br>    LPENTRYID       lpeid                       = NULL; <br>    ULONG           ulObjType                   = 0; <br>    ULONG           ulPropTag                   = 0; <br>    ULONG           cValues                     = 0; <br>    ULONG           i                           = 0; <br>    ULONG           j                           = 0; <br>    ULONG           cRows                       = 0; <br> <br>    LPMESSAGE       lpEnvelope                  = NULL; <br> <br>    ULONG           cbMessageClass              = 0; <br>    LPTSTR          lpszMessageClass            = NULL; <br> <br>    LPSPropValue    lpProps                     = NULL; <br> <br>LPSPropTagArray lpPropTagArray              = NULL; <br> <br>    ULONG           cValuesT                    = 0; <br>    LPSPropValue    lpPropsT                    = NULL; <br> <br>    DWORD           dwStartProcessingTime       = 0; <br> <br>    LPADRBOOK       lpAdrBook                   = NULL; <br> <br>    ULONG           cbMsgEid                    = 0; <br>    LPENTRYID       lpMsgEid                    = NULL; <br> <br>    SizedSPropTagArray(1, rgRecipPropTag) = <br>    { <br>        1, <br>        { <br>            PR_MESSAGE_RECIPIENTS <br>        } <br>    }; <br> <br>    SizedSPropTagArray(1, rgRecordKeyPropTag) = <br>    { <br>        1, <br>        { <br>            PR_RECORD_KEY <br>        } <br>    }; <br> <br>    ULONG           cBytes                      = 0; <br>    LPTSTR          lpszRecordKey               = 0; <br> <br>    PVOID           pvConvInstance              = NULL; <br> <br>    LPIDITEM        lpIdItem                    = NULL; <br> <br>    DEBUGPUBLIC("ProcessMtsOut()\n"); <br> <br>    //performance code <br> <br>    // Initialize conversion engine instance data. <br>    hr = HrConvInitInstance(hEventLog, &amp;pvConvInstance); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cRows       = GetGWSRowSet(lpParameter)-&gt;cRows; <br> <br>    lpAdrBook   = GetAdrBookPtr(); <br> <br> <br>    for(i = 0; i &lt; cRows; i++) <br>    { <br>        dwStartProcessingTime = GetTickCount(); <br> <br>        cValues = GetGWSRowSet(lpParameter)-&gt;aRow[i].cValues; <br> <br>        lpProps = GetGWSRowSet(lpParameter)-&gt;aRow[i].lpProps; <br> <br>        cbeid = lpProps[0].Value.bin.cb; <br>        lpeid = (LPENTRYID)lpProps[0].Value.bin.lpb; <br> <br>        cbMsgEid = cbeid; <br>        lpMsgEid = lpeid; <br> <br>        cValues = 0; <br>        lpProps = NULL; <br> <br>        // Get the message in the MTS-OUT folder <br>        hrT = MAPICALL(lpMtsOutFolder)-&gt;OpenEntry( <br>            lpMtsOutFolder, <br>            cbeid, <br>            lpeid, <br>            NULL, <br>            MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>            &amp;ulObjType, <br>            (LPUNKNOWN FAR *)&amp;lpEnvelope); <br> <br>        cbeid = 0; <br>        lpeid = NULL; <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        if(ulObjType != MAPI_MESSAGE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br>        // Get the message ID <br> <br>        MAPIFREEBUFFER(lpPropsT); <br>        MAPIFREEBUFFER(lpszRecordKey); <br> <br>        cValuesT = 0; <br>        lpPropsT = NULL; <br> <br>        hr = MAPICALL(lpEnvelope)-&gt;GetProps( <br>            lpEnvelope, <br>            (LPSPropTagArray)&amp;rgRecordKeyPropTag, <br>    fMapiUnicode, <br>    &amp;cValuesT, <br>    &amp;lpPropsT); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        if(lpPropsT[0].ulPropTag != PR_RECORD_KEY) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        if(lpPropsT[0].Value.bin.cb == 0) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        if(lpPropsT[0].Value.bin.lpb == NULL) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        cBytes = (lpPropsT[0].Value.bin.cb + sizeof(TCHAR)) * (2 * sizeof(TCHAR)); <br> <br>        hr = MAPIAllocateBuffer(cBytes, (void **)&amp;lpszRecordKey); <br> <br>        if(FAILED(hr)) <br>        {                                                    <br>            goto cleanup;                                 <br>        }                                                    <br> <br>        HexFromBin(lpPropsT[0].Value.bin.lpb, lpPropsT[0].Value.bin.cb, lpszRecordKey); <br> <br>        MAPIFREEBUFFER(lpPropsT); <br> <br>        hr = HrAddIdItem( <br>            &amp;OutboundIdList, <br>            lpszRecordKey, <br>            &amp;lpIdItem); <br> <br>        if(hr == EDK_E_ALREADY_EXISTS) <br>        { <br>            // <br>            // Skip this message. It is already being processed <br>            // by another thread. <br>            // <br> <br>            MAPIFREEBUFFER(lpPropsT); <br>            MAPIFREEBUFFER(lpszRecordKey); <br>            ULRELEASE(lpEnvelope); <br>            continue; <br>        } <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br>        // Get the message class <br> <br>        MAPIFREEBUFFER(lpszMessageClass); <br> <br>        cbMessageClass = 0; <br>        lpszMessageClass = NULL; <br> <br>        hr = HrMAPIGetPropString( <br>            (LPMAPIPROP)lpEnvelope, <br>            PR_MESSAGE_CLASS, <br>            &amp;cbMessageClass, <br>            (void **)&amp;lpszMessageClass); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        MODULE_WARNING1( <br>            "**** [OUT] Processing message of class [%s] ****", <br>            ((lpszMessageClass == NULL) ? "(null)" : lpszMessageClass)); <br> <br>        if(_tcsstr(lpszMessageClass, TEXT("ENVELOPE.IPM")) != NULL) <br>        { <br>            hr = HrExportMessage( <br>                lpAdrBook, <br>                FALSE, <br>                TRUE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) &amp;&amp; <br>                (_tcsstr(lpszMessageClass, TEXT(".NDR")) != NULL)) <br>        { <br>            hr = HrExportMessage( <br>                lpAdrBook, <br>                TRUE, <br>                FALSE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) &amp;&amp; <br>                (_tcsstr(lpszMessageClass, TEXT(".DR")) != NULL)) <br>        { <br>            hr = HrExportMessage( <br>                lpAdrBook, <br>                TRUE, <br>                FALSE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) &amp;&amp; <br>                (_tcsstr(lpszMessageClass, TEXT(".IPNNRN")) != NULL)) <br>        { <br>            hr = HrExportMessage( <br>                lpAdrBook, <br>                FALSE, <br>                FALSE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else if((_tcsstr(lpszMessageClass, TEXT("REPORT.IPM")) != NULL) &amp;&amp; <br>                (_tcsstr(lpszMessageClass, TEXT(".IPNRN")) != NULL)) <br>        { <br>            hr = HrExportMessage( <br>                lpAdrBook, <br>                FALSE, <br>                FALSE, <br>                dwStartProcessingTime, <br>                lpEnvelope); <br>        } <br>        else <br>        { <br>            hr = HrNonDeliverMtsOutMessage( <br>                lpszMessageClass, <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                ; // failed to non-deliver message <br>            } <br>        } <br> <br>        if(FAILED(hr)) <br>        { <br>            MODULE_ERROR1( <br>                "**** [OUT] Error while processing message of class [%s] ****", <br>                ((lpszMessageClass == NULL) ? "(null)" : lpszMessageClass)); <br> <br>            // <br>            // This message will be moved to the archive folder. <br>            // <br> <br>            MAPIFREEBUFFER(lpszMessageClass); <br>            MAPIFREEBUFFER(lpPropsT); <br>            MAPIFREEBUFFER(lpszRecordKey); <br>            ULRELEASE(lpEnvelope); <br>            continue; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br>        else <br>        { <br>            hr = HrConvertMtsOut( <br>                pvConvInstance, <br>                lpAdrBook, <br>                lpszMessageClass, <br>                lpEnvelope); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br>    //------------------------------------------------------------------------------ <br> <br>        ULRELEASE(lpEnvelope); <br> <br>        //performance code <br> <br>        hr = HrMAPIDeleteMessage( <br>            lpMtsOutFolder, <br>            cbMsgEid, <br>            lpMsgEid); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br> <br>        hr = HrRemoveIdItem(&amp;OutboundIdList, lpIdItem); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br> <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropsT); <br> <br>    MAPIFREEBUFFER(lpszRecordKey); <br> <br>    MAPIFREEBUFFER(lpszMessageClass); <br> <br>    ULRELEASE(lpEnvelope); <br> <br>    if(pvConvInstance != NULL) <br>    { <br>        // De-initialize conversion engine instance data. <br>        (VOID)HrConvUninitInstance(pvConvInstance); <br>        pvConvInstance = NULL; <br>    } <br> <br>    return(0); <br>} <br> <br>// $--AppendSlash---------------------------------------------------------- <br>//  This function will append a backslash to a pathname if one does not <br>//  already exist. <br>// ------------------------------------------------------------------------ <br>void AppendSlash (                  // RETURNS:  Nothing <br>    IN OUT LPTSTR sz1)              // pathname <br>{ <br>    LPTSTR sz2 = sz1; <br> <br>    while (*sz2)                    //  Loop through each char until '\0' <br>    { <br>        sz1 = sz2; <br>        sz2 = CharNext(sz1); <br>    } <br> <br>    //  Check there were no CharNext errors, then add a '\' if not there. <br>    if (sz2 != sz1 + 1 || *sz1 != TEXT('\\')) <br>    { <br>        *sz2++ = TEXT('\\'); <br>        *sz2 = TEXT('\0'); <br>    } <br>} <br> <br>//$--GWMain--------------------------------------------------------------------- <br>//  Start threads. <br>// ----------------------------------------------------------------------------- <br>void GWMain( <br>    void) <br>{ <br>    HRESULT      hrT                 = NOERROR; <br>    HRESULT      hr                  = NOERROR; <br> <br>    EDK_SERVICE_CONTROL_T sc = 0; <br> <br>    LPMAPIPROP   lpCurrentObject     = NULL; <br>    ULONG        ulExtensionDataTag  = 0; <br>    ULONG        cValues             = 0; <br>    LPSPropValue lpProps             = NULL; <br>    LPSBinary    lpBlobArray         = NULL; <br>    ULONG        cBlobArray          = 0; <br>    ULONG        i                   = 0; <br>    LPBYTE       lpbBlob             = NULL; <br>    ULONG        cbBlob              = 0; <br>    LPSPropValue lpUnpackedProps     = NULL; <br>    ULONG        cUnpackedProps      = 0; <br>    LPTSTR       lpszUnpackedName    = NULL; <br>    LPTSTR       lpszDir             = NULL; <br>    ULONG        cBytes              = 0; <br>    LPTSTR       lpsz                = NULL; <br> <br>SizedSPropTagArray(1, rgPropTags) = <br>{ <br>1, <br>{ <br>0, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("GWMain()\n"); <br> <br>    //-------------------------------------------------------------------------- <br> <br>    // <br>    // Get a pointer to the current object <br>    // <br> <br>hr = HrOpenSessionObject( <br>    lpSession,  <br>        &amp;lpCurrentObject); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Convert our MAPI Name ID to a property tag <br>    // <br>    hr = HrCfgPropertyTagFromNameId( <br>        lpCurrentObject, <br>        NM_EXTENSION_DATA, <br>        &amp;ulExtensionDataTag); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Now get the properties we want from the site object <br>    // <br> <br>    rgPropTags.aulPropTag[0] = <br>        PROP_TAG(MV_FLAG|PT_BINARY, PROP_ID(ulExtensionDataTag)); <br>     <br>    hr = MAPICALL(lpCurrentObject)-&gt;GetProps( <br>        lpCurrentObject, <br>        (LPSPropTagArray)&amp;rgPropTags, <br>fMapiUnicode, <br>&amp;cValues, <br>&amp;lpProps); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(PROP_TYPE(lpProps[0].ulPropTag) == PT_ERROR) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpBlobArray = lpProps-&gt;Value.MVbin.lpbin; <br>    cBlobArray  = lpProps-&gt;Value.MVbin.cValues; <br> <br>    for(i = 0; i &lt; cBlobArray; i++) </code></pre>
<p>
</p>
<pre><code>{ <br>        if (!lstrcmpW(SGWBLOBNAMEW, (LPWSTR)lpBlobArray[i].lpb)) <br>        { <br>            lpbBlob = lpBlobArray[i].lpb; <br>            cbBlob  = lpBlobArray[i].cb; <br>        } <br>    } <br> <br>    hr = HrCfgUnpackData( <br>        cbBlob,  <br>        lpbBlob,  <br>        &amp;lpszUnpackedName,  <br>        &amp;cUnpackedProps,  <br>        &amp;lpUnpackedProps); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    //-------------------------------------------------------------------------- <br> <br>    if(cUnpackedProps &lt; 17) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br> <br>    } <br> <br>    lpszAddressType     = lpUnpackedProps[IDX_ADDR_TYPE].Value.LPSZ; <br> <br>    lpszSysAdminName    = lpUnpackedProps[IDX_DISP_NAME].Value.LPSZ; <br> <br>    lpszSysAdminAddr    = lpUnpackedProps[IDX_EMAIL_ADDR].Value.LPSZ; <br> <br>    cInThreads          = lpUnpackedProps[IDX_EDIT_THREADS_IN].Value.ul; <br> <br>    cInMessages         = lpUnpackedProps[IDX_EDIT_MSGS_IN].Value.ul; <br> <br>    dwInSleepInterval   = lpUnpackedProps[IDX_EDIT_SLEEP_IN].Value.ul; <br> <br>    lpszInDirectory     = lpUnpackedProps[IDX_DIR_IN].Value.LPSZ; <br> <br>    dwInPollInterval    = lpUnpackedProps[IDX_EDIT_POLLING_IN].Value.ul; <br> <br>    lpszInConverter     = lpUnpackedProps[IDX_CONVERTER_IN].Value.LPSZ; <br> <br>    fInEnabled          = lpUnpackedProps[IDX_CHECK_IN_BOUND].Value.b; <br> <br>    cOutThreads         = lpUnpackedProps[IDX_EDIT_THREADS_OUT].Value.ul; <br> <br>    cOutMessages        = lpUnpackedProps[IDX_EDIT_MSGS_OUT].Value.ul; <br> <br>    dwOutSleepInterval  = lpUnpackedProps[IDX_EDIT_SLEEP_OUT].Value.ul; <br> <br>    lpszOutDirectory    = lpUnpackedProps[IDX_DIR_OUT].Value.LPSZ; <br> <br>    dwOutPollInterval   = lpUnpackedProps[IDX_EDIT_POLLING_OUT].Value.ul; <br> <br>    lpszOutConverter    = lpUnpackedProps[IDX_CONVERTER_OUT].Value.LPSZ; <br> <br>    fOutEnabled         = lpUnpackedProps[IDX_CHECK_OUT_BOUND].Value.b; <br> <br>    hr = HrStrToStrW(lpszInConverter, &amp;lpszInConverterW); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrStrToStrW(lpszOutConverter, &amp;lpszOutConverterW); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Add trailing slash to inbound directory. <br>    // <br> <br>    cBytes  = cbStrLen(lpszInDirectory) + sizeof(TCHAR); <br>    lpszDir = NULL; <br> <br>    hr = MAPIAllocateMore(cBytes, lpUnpackedProps, (void **)&amp;lpszDir); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lstrcpy(lpszDir, lpszInDirectory); <br>    AppendSlash(lpszDir); <br>    lpszInDirectory = lpszDir; <br> <br>    // <br>    // Add trailing slash to outbound directory. <br>    // <br> <br>    cBytes  = cbStrLen(lpszOutDirectory) + sizeof(TCHAR); <br>    lpszDir = NULL; <br> <br>    hr = MAPIAllocateMore(cBytes, lpUnpackedProps, (void **)&amp;lpszDir); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lstrcpy(lpszDir, lpszOutDirectory); <br>    AppendSlash(lpszDir); <br>    lpszOutDirectory = lpszDir; <br> <br>    // <br>    // Add trailing slash to archive directory. <br>    // <br> <br>    cBytes  = cbStrLen(lpszOutDirectory) + <br>              cbStrLen(TEXT("\\ARCHIVE")) + <br>              sizeof(TCHAR); <br> <br>    lpszDir = NULL; <br> <br>    hr = MAPIAllocateBuffer(cBytes, (void **)&amp;lpszDir); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lstrcpy(lpszDir, lpszOutDirectory); <br>    AppendSlash(lpszDir); <br>    lpszArchiveDirectory = lpszDir; <br> <br>    lpsz =  lpszArchiveDirectory; <br>    lpsz += lstrlen(lpszArchiveDirectory); <br>    lpsz --; <br>    *lpsz = 0; <br> <br>    while(lpsz != lpszArchiveDirectory) <br>    { <br>        if((*lpsz == TEXT('\\')) || (*lpsz == TEXT(':'))) <br>        { <br>            if(*lpsz == TEXT(':')) <br>                lpsz++; <br>            lstrcpy(lpsz, "\\ARCHIVE\\"); <br>            break; <br>        } <br> <br>        lpsz--; <br>    } <br> <br>    //-------------------------------------------------------------------------- <br> <br>    if(fInEnabled == TRUE) <br>    { <br>        hr = HrGWStartNewFileHandler( <br>            dwInSleepInterval, <br>            dwInPollInterval, <br>            cInMessages, <br>            cInThreads, <br>            lpszAddressType, <br>            TEXT("SGW*.TMP"), <br>            lpszInDirectory, <br>            (LPTHREAD_START_ROUTINE)ProcessMtsIn); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        MODULE_WARNING("**** [IN] Processing not enabled ****"); <br>    } <br> <br>    //-------------------------------------------------------------------------- <br> <br>    if(fOutEnabled == TRUE) <br>    { <br>        hr = HrGWStartNewMailHandler( <br>            dwOutSleepInterval, <br>            dwOutPollInterval, <br>            cOutMessages, <br>            cOutThreads, <br>            lpszAddressType, <br>            lpszOutDirectory, <br>            (LPTHREAD_START_ROUTINE)ProcessMtsOut); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        MODULE_WARNING("**** [OUT] Processing not enabled ****"); <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    MAPIFREEBUFFER(lpProps); <br> <br>    MAPIFREEBUFFER(lpszUnpackedName); <br> <br>    ULRELEASE(lpCurrentObject); <br> <br>    // <br>    // Wait for a request for the gateway to stop. <br>    // <br> <br>    hr = HR_LOG(HrServiceWaitForStop(INFINITE, &amp;sc)); <br> <br>    MAPIFREEBUFFER(lpszInConverterW); <br> <br>    MAPIFREEBUFFER(lpszOutConverterW); <br> <br>    MAPIFREEBUFFER(lpUnpackedProps); <br> <br>    // <br>    // IMPORTANT: Return from this function only if the gateway is ready to stop. <br>    // <br> <br>    return; <br>} <br> <br>//$--HrGWLogon------------------------------------------------------------------ <br>//  Logon to the gateway. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGWLogon(                      // RETURNS: return code <br>    void)                               // no arguments <br>{ <br>    HRESULT      hr                  = NOERROR; <br>    SCODE        sc                  = 0; <br>    BOOL         fStatus             = TRUE; <br>    LPTSTR       lpszT               = NULL; <br>    LPMAPIPROP   lpSiteAddressing    = NULL; <br>    ULONG        ulGatewayProxyTag   = 0; <br>    ULONG        cValues             = 0; <br>    LPSPropValue lpProps             = NULL; <br>    ULONG        i                   = 0; <br> <br>SizedSPropTagArray(1, rgPropTags) = <br>{ <br>1, <br>{ <br>0, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrGWLogon()\n"); <br> <br>    InitializeCriticalSection(&amp;csGatewaySeqNo); <br>    InitializeCriticalSection(&amp;csInboundIdList); <br>    InitializeCriticalSection(&amp;csOutboundIdList); <br> <br>    InboundIdList.lpcs  = &amp;csInboundIdList; <br>    OutboundIdList.lpcs = &amp;csOutboundIdList; <br> <br>    lpSession       = GetGWSession(); <br>    lpStore         = GetGWDefaultStore(); <br>    lpRootFolder    = GetGWRootFolder(); <br>    lpMtsInFolder   = GetGWMtsInFolder(); <br>    lpMtsOutFolder  = GetGWMtsOutFolder(); <br>    cbGalEid        = GetGWGALEntryIdSize(); <br>    lpGalEid        = GetGWGALEntryId(); <br> <br>    // <br>    // Get a pointer to the site addressing object <br> <br>hr = HrOpenSiteContainerAddressing( <br>    lpSession,  <br>        &amp;lpSiteAddressing); <br> <br>    if(FAILED(hr)) <br>    { <br>        fStatus = FALSE; <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Convert our MAPI Name ID to a property tag <br>    // <br>    hr = HrCfgPropertyTagFromNameId( <br>        lpSiteAddressing, <br>        NM_GATEWAY_PROXY, <br>        &amp;ulGatewayProxyTag); <br> <br>    if(FAILED(hr)) <br>    { <br>        fStatus = FALSE; <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Now get the properties we want from the site object <br>    // <br> <br>    rgPropTags.aulPropTag[0] = ulGatewayProxyTag; <br>     <br>    hr = MAPICALL(lpSiteAddressing)-&gt;GetProps( <br>        lpSiteAddressing, <br>        (LPSPropTagArray)&amp;rgPropTags, <br>fMapiUnicode, <br>&amp;cValues, <br>&amp;lpProps); <br> <br>    if(FAILED(hr)) <br>    { <br>        fStatus = FALSE; <br>        goto cleanup; <br>    } <br> <br>    if(PROP_TYPE(lpProps[0].ulPropTag) == PT_ERROR) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        fStatus = FALSE; <br>        goto cleanup; <br>    } <br> <br>    if(lpProps[0].Value.MVSZ.cValues == 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        fStatus = FALSE; <br>        goto cleanup; <br>    } <br> <br>    for(i = 0; i &lt; (lpProps[0].Value.MVSZ.cValues); i++) <br>    { <br>        if(!_tcsnicmp( <br>            lpProps[0].Value.MVSZ.LPPSZ[i], <br>            TEXT("X400:"), <br>            lstrlen(TEXT("X400:")))) <br>        { <br>            break; <br>        } <br>    } <br> <br>    sc = MAPIAllocateBuffer( <br>        cbStrLen(lpProps[0].Value.MVSZ.LPPSZ[i]), <br>        (void **)&amp;lpszT); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                     <br>     <br>    lstrcpy(lpszT, lpProps[0].Value.MVSZ.LPPSZ[i]); <br> <br>    // <br>    // Create the local enterprise GDI. <br>    // <br> <br>    hr = HrCreateEnterpriseGDI( <br>        lpszT, <br>        TEXT(":;"), <br>        &amp;lpszLocalGDI); <br> <br>    if(FAILED(hr)) <br>    { <br>        fStatus = FALSE; <br>        goto cleanup; <br>    } <br> <br>    // Open an event log for this application. <br>    hr = HrEventOpenLog( <br>        szAppName,          // application name <br>        NULL,               // executable name (will be computed) <br>        TEXT("EDKMSG.DLL"), // event message file <br>        NULL,               // parameter message file (will be computed) <br>        NULL,               // category message file (will be computed) <br>        &amp;hEventLog);        // event source handle <br> <br>    if ( FAILED(hr) || (hEventLog == NULL) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Initialize global conversion engine data. <br>    hr = HrConvInitGlobals(); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        fStatus = FALSE; <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    ULRELEASE(lpSiteAddressing); <br> <br>    MAPIFREEBUFFER(lpProps); <br> <br>    MAPIFREEBUFFER(lpszT); <br> <br>    if(fStatus == FALSE) <br>    { <br>        // <br>        // Gateway logon failed. <br>        // <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrArchiveMtsOut------------------------------------------------------------ <br>//  Archive messages in MTS-OUT which could not be delivered. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrArchiveMtsOut(                // RETURNS: zero <br>    VOID)                               // parameter <br>{ <br>    HRESULT         hr                          = NOERROR; <br>    ULONG           cbeid                       = 0; <br>    LPENTRYID       lpeid                       = NULL; <br>    ULONG           ulObjType                   = 0; <br>    ULONG           ulPropTag                   = 0; <br>    ULONG           cValues                     = 0; <br>    ULONG           i                           = 0; <br>    ULONG           cRows                       = 0; <br> <br>    LPMAPIFOLDER    lpArchiveFolder             = NULL; <br>    LPMAPITABLE     lpTable                     = NULL; <br> <br>    LPMESSAGE       lpEnvelope                  = NULL; <br> <br>    LPSPropValue    lpProps                     = NULL; <br> <br>LPSPropTagArray lpPropTagArray              = NULL; <br> <br>    ULONG           cValuesT                    = 0; <br>    LPSPropValue    lpPropsT                    = NULL; <br> <br>    ULONG           cbMsgEid                    = 0; <br>    LPENTRYID       lpMsgEid                    = NULL; <br> <br>    LPSRowSet       lpRows                      = NULL; <br> <br>    SizedSPropTagArray(1, rgRecordKeyPropTag) = <br>    { <br>        1, <br>        { <br>            PR_RECORD_KEY <br>        } <br>    }; <br> <br>    ULONG           cBytes                      = 0; <br>    LPTSTR          lpszRecordKey               = 0; <br> <br>    LPIDITEM        lpIdItem                    = NULL; <br> <br>    SizedSPropTagArray(1, rgPropTag) = <br>    { <br>        1, <br>        { <br>            PR_ENTRYID <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrArchiveMtsOut()\n"); <br> <br>    // <br>    // Find and open the MTS-OUT archive folder. <br>    // <br> <br>    hr = HrMAPIFindFolder( <br>        GetGWRootFolder(), <br>        TEXT("ARCHIVE"), <br>        &amp;cbeid, <br>        &amp;lpeid); <br> <br>    if(FAILED(hr)) <br>    {                                                    <br>        hr = MAPICALL(lpRootFolder)-&gt;CreateFolder( <br>            lpRootFolder, <br>            FOLDER_GENERIC, <br>            TEXT("ARCHIVE"), <br>            NULL, <br>            NULL, <br>            MAPI_DEFERRED_ERRORS, <br>            &amp;lpArchiveFolder); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        // Open the archive folder in the root folder <br>        hr = MAPICALL(lpRootFolder)-&gt;OpenEntry( <br>            lpRootFolder, <br>            cbeid, <br>            lpeid, <br>            NULL, <br>            MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>            &amp;ulObjType, <br>            (LPUNKNOWN FAR *) &amp;lpArchiveFolder); <br> <br>        MAPIFREEBUFFER(lpeid); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        if(ulObjType != MAPI_FOLDER) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    // <br>    // Get the contents table for the MTS-OUT <br>    // <br> <br>    hr = MAPICALL(lpMtsOutFolder)-&gt;GetContentsTable( <br>        lpMtsOutFolder, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;lpTable); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL(lpTable)-&gt;SetColumns( <br>        lpTable, <br>        (LPSPropTagArray)&amp;rgPropTag, <br>        TBL_BATCH); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Query all the rows <br>    // <br> <br>    hr = HrQueryAllRows( <br>    lpTable, <br>    NULL, <br>    NULL, <br>    NULL, <br>    0, <br>    &amp;lpRows); <br> <br>    ULRELEASE(lpTable); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    cRows = lpRows-&gt;cRows; <br> <br>    for(i = 0; i &lt; cRows; i++) <br>    { <br>        cValues = lpRows-&gt;aRow[i].cValues; <br> <br>        lpProps = lpRows-&gt;aRow[i].lpProps; <br> <br>        cbeid = lpProps[0].Value.bin.cb; <br>        lpeid = (LPENTRYID)lpProps[0].Value.bin.lpb; <br> <br>        cbMsgEid = cbeid; <br>        lpMsgEid = lpeid; <br> <br>        cValues = 0; <br>        lpProps = NULL; <br> <br>        // Get the message in the MTS-OUT folder <br>        hr = MAPICALL(lpMtsOutFolder)-&gt;OpenEntry( <br>            lpMtsOutFolder, <br>            cbeid, <br>            lpeid, <br>            NULL, <br>            MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>            &amp;ulObjType, <br>            (LPUNKNOWN FAR *)&amp;lpEnvelope); <br> <br>        cbeid = 0; <br>        lpeid = NULL; <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        if(ulObjType != MAPI_MESSAGE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br> <br>        // Get the message ID <br> <br>        MAPIFREEBUFFER(lpPropsT); <br>        MAPIFREEBUFFER(lpszRecordKey); <br> <br>        cValuesT = 0; <br>        lpPropsT = NULL; <br> <br>        hr = MAPICALL(lpEnvelope)-&gt;GetProps( <br>            lpEnvelope, <br>            (LPSPropTagArray)&amp;rgRecordKeyPropTag, <br>    fMapiUnicode, <br>    &amp;cValuesT, <br>    &amp;lpPropsT); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        if(lpPropsT[0].ulPropTag != PR_RECORD_KEY) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        if(lpPropsT[0].Value.bin.cb == 0) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        if(lpPropsT[0].Value.bin.lpb == NULL) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        cBytes = (lpPropsT[0].Value.bin.cb + sizeof(TCHAR)) * (2 * sizeof(TCHAR)); <br> <br>        hr = MAPIAllocateBuffer(cBytes, (void **)&amp;lpszRecordKey); <br> <br>        if(FAILED(hr)) <br>        {                                                    <br>            goto cleanup;                                 <br>        }                                                    <br> <br>        HexFromBin(lpPropsT[0].Value.bin.lpb, lpPropsT[0].Value.bin.cb, lpszRecordKey); <br> <br>        MAPIFREEBUFFER(lpPropsT); <br> <br>        hr = HrLookupIdItem( <br>            &amp;OutboundIdList, <br>            lpszRecordKey, <br>            &amp;lpIdItem); <br> <br>        if(hr == EDK_E_NOT_FOUND) <br>        { <br>            // <br>            // Skip this message. It is a new message. <br>            // <br> <br>            MAPIFREEBUFFER(lpszRecordKey); <br>            MAPIFREEBUFFER(lpPropsT); <br>            ULRELEASE(lpEnvelope); <br>            continue; <br>        } <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    //------------------------------------------------------------------------------ <br> <br>        MAPIFREEBUFFER(lpszRecordKey); <br>        MAPIFREEBUFFER(lpPropsT); <br>        ULRELEASE(lpEnvelope); <br> <br>    //------------------------------------------------------------------------------ <br> <br>        hr = HrMAPIMoveMessage( <br>            lpMtsOutFolder, <br>            lpArchiveFolder, <br>            cbMsgEid, <br>            lpMsgEid); <br> <br>        if(FAILED(hr)) <br>        { <br>            ; // create an entry in the debug log <br>        } <br>    } <br> <br>cleanup: <br> <br>    FREEPROWS(lpRows); <br> <br>    MAPIFREEBUFFER(lpPropsT); <br> <br>    MAPIFREEBUFFER(lpszRecordKey); <br> <br>    ULRELEASE(lpEnvelope); <br> <br>    ULRELEASE(lpArchiveFolder); <br> <br>    ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrArchiveMtsIn------------------------------------------------------------- <br>//  Archive messages in MTS-IN which could not be delivered. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrArchiveMtsIn(                 // RETURNS: return code <br>    VOID)                               // no arguments <br>{ <br>HRESULT  hr                       = NOERROR; <br>    HRESULT  hrT                      = NOERROR; <br>    LPIDITEM lpIdItem                 = NULL; <br>    BOOL     fRet                     = FALSE; <br>    TCHAR    rgchFileName[MAX_PATH+1] = {0}; <br>    TCHAR    rgchPathName[MAX_PATH+1] = {0}; <br>    LPTSTR   lpszPath                 = NULL; <br>    LPIDITEM lpIdList                 = NULL; <br> <br>    // <br>    // Find and open the MTS-IN archive directory. <br>    // <br> <br>    lstrcpy(rgchPathName, lpszArchiveDirectory); <br> <br>    fRet = CreateDirectory(rgchPathName, NULL); <br> <br>    if(fRet == FALSE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    lpszPath = rgchPathName; <br> <br>    lpIdList = &amp;InboundIdList; <br> <br>    EnterCriticalSection(lpIdList-&gt;lpcs); <br> <br>    __try <br>    { <br>        lpIdItem = lpIdList-&gt;next; <br>     <br>        while(lpIdItem != NULL) <br>        { <br>            lpIdList-&gt;next = lpIdItem-&gt;next; <br> <br>            rgchFileName[0] = 0; <br> <br>        fRet = GetTempFileName32(lpszPath, TEXT("BAK"), 0, (LPTSTR)rgchFileName); <br> <br>            if(fRet == FALSE) <br>        { <br>        hr = HR_LOG(E_FAIL); <br>        } <br>            else <br>            { <br>                fRet = MoveFileEx( <br>                    lpIdItem-&gt;lpszId, <br>                    (LPTSTR)rgchFileName, <br>                    MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING); <br> <br>                if(fRet == FALSE) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                } <br>            } <br> <br>            lpIdItem = lpIdList-&gt;next; <br>        } <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    LeaveCriticalSection(lpIdList-&gt;lpcs); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGWLogoff----------------------------------------------------------------- <br>//  Logoff of the gateway. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGWLogoff(                     // RETURNS: return code <br>    void)                               // no arguments <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrGWLogoff()\n"); <br> <br>    // De-initialize conversion engine global data. <br>    ConvUninitGlobals(); <br> <br>    // Close the event log. <br>    (VOID)HrEventCloseLog(); <br>    hEventLog = NULL; <br> <br>    MAPIFREEBUFFER(lpbBuffer); <br> <br>    MAPIFREEBUFFER(lppszBufferArray); <br> <br>    MAPIFREEBUFFER(lpszLocalGDI); <br> <br>    // <br>    // Archive messages which could not be delivered. <br>    // <br> <br>    hrT = HR_LOG(HrArchiveMtsIn()); <br> <br>    hrT = HR_LOG(HrArchiveMtsOut()); <br> <br> <br>    hrT = HR_LOG(HrEmptyIdList(&amp;InboundIdList)); <br> <br>    hrT = HR_LOG(HrEmptyIdList(&amp;OutboundIdList)); <br> <br>    DeleteCriticalSection(&amp;csGatewaySeqNo); <br>    DeleteCriticalSection(&amp;csInboundIdList); <br>    DeleteCriticalSection(&amp;csOutboundIdList); <br> <br>    MAPIFREEBUFFER(lpszArchiveDirectory); <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
