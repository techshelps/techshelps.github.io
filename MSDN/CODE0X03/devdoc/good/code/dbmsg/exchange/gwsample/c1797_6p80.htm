<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IADDR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1800"></a>IADDR.C</h2>
<pre><code>// --iaddr.c-------------------------------------------------------------------- <br>// <br>//  Find an address given a proxy address. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "gwsample.h" <br> <br>//$--HrMapGatewayProxyToAddr---------------------------------------------------- <br>// Map all gateway specific email addresses to proxy addresses <br>// in a given address list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMapGatewayProxyToAddr(        // RETURNS: return code <br>    IN  LPADRBOOK    lpAdrBook,         // pointer to address book <br>    IN  LPTSTR       lpszAddrType,      // pointer to the address type <br>    IN OUT LPADRLIST lpAdrList)         // pointer to address list <br>{ <br>    HRESULT         hr                   = NOERROR; <br>    SCODE           sc                   = 0; <br>    ULONG           i                    = 0; <br>    ULONG           j                    = 0; <br>    ULONG           cbAddress            = 0; <br>    ULONG           cProxy               = 0; <br>    LPSPropValue    lpProps              = NULL; <br>    LPTSTR          lpszProxyAddress     = NULL; <br> <br>    LPTSTR          lpszEmailDisplayName = NULL; <br>    LPTSTR          lpszEmailAddressType = NULL; <br>    LPTSTR          lpszEmailAddress     = NULL; <br>    LPTSTR          lpszEmailSearchKey   = NULL; <br>    ULONG           cbEmailEid           = 0; <br>    LPENTRYID       lpEmailEid           = NULL; <br> <br>    DEBUGPUBLIC("HrMapGatewayProxyToAddr()\n"); <br> <br>    for(i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>    { <br>        lpProps = lpAdrList-&gt;aEntries[i].rgPropVals; <br> <br>        if((lpProps[IDISPNAME].ulPropTag == PR_DISPLAY_NAME) &amp;&amp; <br>           ((lstrcmpi(lpszSysAdminName, lpProps[IDISPNAME].Value.LPSZ) == 0) || <br>            (lstrcmpi(TEXT("."), lpProps[IDISPNAME].Value.LPSZ) == 0) || <br>            (lstrcmpi(lpszSysAdminAddr, lpProps[IDISPNAME].Value.LPSZ) == 0))) <br> <br>        { <br>            lpszEmailDisplayName = NULL; <br>            lpszEmailAddressType = NULL; <br>            lpszEmailAddress     = NULL; <br>            lpszEmailSearchKey   = NULL; <br>            cbEmailEid           = 0; <br>            lpEmailEid           = NULL; <br> <br>            hr = HrCreateProxyAddress( <br>                lpAdrBook, <br>                lpProps, <br>                TRUE, <br>                SYSTEM_ADMINISTRATOR, <br>                SYSTEM, <br>                SYSTEM_ADMINISTRATOR, <br>                &amp;lpszEmailDisplayName, <br>                &amp;lpszEmailAddressType, <br>                &amp;lpszEmailAddress, <br>                &amp;lpszEmailSearchKey, <br>                &amp;cbEmailEid, <br>                &amp;lpEmailEid); <br> <br>            if(FAILED(hr)) <br>            { <br>                goto cleanup; <br>            } <br> <br>            lpProps[IDISPNAME].ulPropTag      = PR_DISPLAY_NAME; <br>            lpProps[IDISPNAME].Value.LPSZ     = lpszEmailDisplayName; <br> <br>            lpProps[IADDRTYPE].ulPropTag      = PR_ADDRTYPE; <br>            lpProps[IADDRTYPE].Value.LPSZ     = lpszEmailAddressType; <br> <br>            lpProps[IEMAILADDR].ulPropTag     = PR_EMAIL_ADDRESS; <br>            lpProps[IEMAILADDR].Value.LPSZ    = lpszEmailAddress; <br> <br>            lpProps[ISEARCHKEY].ulPropTag = PR_SEARCH_KEY; <br> <br>            if(lpszEmailSearchKey == NULL) <br>            { <br>                lpProps[ISEARCHKEY].Value.bin.cb  = 0; <br>                lpProps[ISEARCHKEY].Value.bin.lpb = NULL; <br>            } <br>            else <br>            { <br>                lpProps[ISEARCHKEY].Value.bin.cb  = cbStrLen(lpszEmailSearchKey); <br>                lpProps[ISEARCHKEY].Value.bin.lpb = lpszEmailSearchKey; <br>            } <br> <br>            lpProps[IENTRYID].ulPropTag       = PR_ENTRYID; <br>            lpProps[IENTRYID].Value.bin.cb    = cbEmailEid; <br>            lpProps[IENTRYID].Value.bin.lpb   = (LPBYTE)lpEmailEid; <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMapRecipProxyToAddr------------------------------------------------------ <br>// Map recipient proxy addresses to addresses. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMapRecipProxyToAddr(          // RETURNS: return code <br>    IN LPADRBOOK lpAdrBook,             // pointer to address book <br>    IN BOOL fDefaultRespValue,          // default responsibility value <br>    IN BOOL fIgnoreRespValue,           // ignore  responsibility value <br>    IN LPABCONT lpGalABCont,            // pointer to GAL container <br>    IN LPTSTR lpszAddrType,             // pointer to address type <br>    IN LPADRLIST lpOriginalAdrList,     // pointer to unmodified address list <br>    IN LPADRLIST lpMappedAdrList,       // pointer to unmodified address list <br>    IN OUT LPADRLIST lpEnvelopeAdrList, // pointer to envelope address list <br>    IN OUT LPADRLIST lpEnvelopeNDRAdrList,// pointer to envelope NDR address list <br>    IN OUT LPMESSAGE lpMessage,         // pointer to message <br>    OUT LPADRLIST *lppAdrList,          // pointer to address list <br>    OUT LPADRLIST *lppNDRAdrList)       // pointer to NDR address list <br>{ <br>    HRESULT         hrT                  = NOERROR; <br>    HRESULT         hr                   = NOERROR; <br>    SCODE           sc                   = 0; <br>    LPMAPITABLE     lpTable              = NULL; <br> <br>    ULONG           cbeid                = 0; <br>    LPENTRYID       lpeid                = NULL; <br> <br>    ULONG           cRows                = 0; <br>    LPSRowSet       lpRows               = 0; <br> <br>    LPSPropTagArray lpPropTagArray       = NULL; <br> <br>    ULONG           nName                = 0; <br>    ULONG           nAddrType            = 0; <br>    ULONG           nAddress             = 0; <br>    ULONG           nEntryId             = 0; <br>    ULONG           nSearchKey           = 0; <br>    ULONG           nRecipStat           = 0; <br> <br>    ULONG           i                    = 0; <br>    ULONG           iAck                 = 0; <br>    ULONG           iNak                 = 0; <br> <br>    ULONG           cValues              = 0; <br>    LPSPropValue    lpProps              = NULL; <br> <br>    LPSPropValue    lpEnvelopeProps      = NULL; <br>    LPSPropValue    lpMessageProps       = NULL; <br> <br>    ULONG           cbSearchKey          = 0; <br>    LPTSTR          lpszSearchKey        = NULL; <br> <br>    BOOL            fRespTrue            = FALSE; <br> <br>    FILETIME        ftReportTime         = {0}; <br> <br>    LPSPropValue    lpPropT              = NULL; <br> <br>    ULONG           cNewProps            = 0; <br>    LPSPropValue    lpNewProps           = NULL; <br> <br>    ULONG           cMapValues           = 0; <br>    LPSPropValue    lpMapProps           = NULL; <br> <br>    BOOL            fEnv                 = FALSE; <br> <br>    DEBUGPUBLIC("HrMapRecipProxyToAddr()\n"); <br> <br>    *lppAdrList    = NULL; <br>    *lppNDRAdrList = NULL; <br> <br>    // <br>    // Get the current time. <br>    // <br> <br>    GetSystemTimeAsFileTime( &amp;ftReportTime); <br> <br>    nName      = IDISPNAME; <br>    nAddrType  = IADDRTYPE; <br>    nAddress   = IEMAILADDR; <br>    nEntryId   = IENTRYID; <br>    nSearchKey = ISEARCHKEY; <br>    nRecipStat = IRECIPSTAT; <br> <br>    cRows  = lpOriginalAdrList-&gt;cEntries; <br>    lpRows = (LPSRowSet)lpOriginalAdrList; <br> <br>    if(lpRows == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(lpEnvelopeAdrList != NULL) <br>    { <br>        // <br>        // Clear recipient numbers if this is not an envelope address list. <br>        // <br> <br>        hr = HrDeleteAddressListProperty( <br>            PR_RECIPIENT_NUMBER, <br>            (LPADRLIST)lpRows); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    hr = HrMAPICreateSizedAddressList( <br>        cRows, <br>        lppAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPICreateSizedAddressList( <br>        cRows, <br>        lppNDRAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    for(i = 0; i &lt; cRows; i++) <br>    { <br>        // <br>        // Preserve original recipient number for original recipient entry <br>        // <br> <br>        cValues = lpRows-&gt;aRow[i].cValues; <br>        lpProps = lpRows-&gt;aRow[i].lpProps; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        hr = HrSetUlongPropertyValue( <br>            FALSE, <br>            PR_RECIPIENT_NUMBER, <br>            (i+1), <br>            cValues, <br>            lpProps, <br>            &amp;cNewProps, <br>            &amp;lpNewProps); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        MAPIFREEBUFFER(lpProps); <br> <br>        lpRows-&gt;aRow[i].cValues = cNewProps; <br>        lpRows-&gt;aRow[i].lpProps = lpNewProps; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        cValues = 0; <br>        lpProps = NULL; <br> <br>        // <br>        // Preserve original recipient number for mapped recipient entry <br>        // <br> <br>        cValues = lpMappedAdrList-&gt;aEntries[i].cValues; <br>        lpProps = lpMappedAdrList-&gt;aEntries[i].rgPropVals; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        hr = HrSetUlongPropertyValue( <br>            FALSE, <br>            PR_RECIPIENT_NUMBER, <br>            (i+1), <br>            cValues, <br>            lpProps, <br>            &amp;cNewProps, <br>            &amp;lpNewProps); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        MAPIFREEBUFFER(lpProps); <br> <br>        lpMappedAdrList-&gt;aEntries[i].cValues = cNewProps; <br>        lpMappedAdrList-&gt;aEntries[i].rgPropVals = lpNewProps; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        cValues = 0; <br>        lpProps = NULL; <br> <br>        // <br>        // Preserve original row number for original recipient entry <br>        // <br> <br>        cValues = lpRows-&gt;aRow[i].cValues; <br>        lpProps = lpRows-&gt;aRow[i].lpProps; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        hr = HrSetUlongPropertyValue( <br>            TRUE, <br>            PR_ROWID, <br>            i, <br>            cValues, <br>            lpProps, <br>            &amp;cNewProps, <br>            &amp;lpNewProps); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        MAPIFREEBUFFER(lpProps); <br> <br>        lpRows-&gt;aRow[i].cValues = cNewProps; <br>        lpRows-&gt;aRow[i].lpProps = lpNewProps; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        cValues = 0; <br>        lpProps = NULL; <br> <br>        // <br>        // Preserve original row number for mapped recipient entry <br>        // <br> <br>        cValues = lpMappedAdrList-&gt;aEntries[i].cValues; <br>        lpProps = lpMappedAdrList-&gt;aEntries[i].rgPropVals; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        hr = HrSetUlongPropertyValue( <br>            TRUE, <br>            PR_ROWID, <br>            i, <br>            cValues, <br>            lpProps, <br>            &amp;cNewProps, <br>            &amp;lpNewProps); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        MAPIFREEBUFFER(lpProps); <br> <br>        lpMappedAdrList-&gt;aEntries[i].cValues = cNewProps; <br>        lpMappedAdrList-&gt;aEntries[i].rgPropVals = lpNewProps; <br> <br>        cNewProps  = 0; <br>        lpNewProps = NULL; <br> <br>        cValues = 0; <br>        lpProps = NULL; <br> <br>        // <br>        // Mapped recipient entry (read-only) <br>        // <br> <br>        cMapValues = lpMappedAdrList-&gt;aEntries[i].cValues; <br>        lpMapProps = lpMappedAdrList-&gt;aEntries[i].rgPropVals; <br> <br>        // <br>        // Find the email address associated with a proxy address, <br>        // <br> <br>        // <br>        // Get the recipient responsibility <br>        // <br> <br>        lpPropT = LpValFindProp(PR_RESPONSIBILITY, cMapValues, lpMapProps); <br> <br>        if(lpPropT == NULL) <br>        { <br>            fRespTrue = fDefaultRespValue; <br>        } <br>        else <br>        { <br>            fRespTrue = lpPropT-&gt;Value.b; <br>        } <br> <br>        if(fIgnoreRespValue == TRUE) <br>        { <br>            fRespTrue = FALSE; <br>        } <br> <br>        // <br>        // NOTE: If the recipient address type is the same as the email <br>        // address type then the address was mapped. <br>        // <br> <br>        if((lpMapProps[IADDRTYPE].ulPropTag != PR_ADDRTYPE) || <br>           (lpMapProps[IADDRTYPE].Value.LPSZ == NULL)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>        else <br>        { <br>            if( (lstrcmpi(lpMapProps[IADDRTYPE].Value.LPSZ, <br>                         TEXT(EXCHANGE_ADDRTYPE)) != 0) &amp;&amp; <br>                (fRespTrue == TRUE) ) <br>            { <br>                MODULE_WARNING("email address was not found"); <br> <br>                if(lpMapProps[IRECIPSTAT].Value.ul != NOERROR) <br>                { <br>                    // <br>                    // Non-deliver recipient <br>                    // <br> <br>                    hr = HrNonDeliverRecipient( <br>                        MAPI_REASON_TRANSFER_IMPOSSIBLE, <br>                        (ULONG)MAPI_DIAG_OR_NAME_AMBIGUOUS, <br>                        &amp;ftReportTime, <br>                        (ULONG)-1, <br>                        iNak, <br>                        cMapValues, <br>                        lpMapProps, <br>                        *lppNDRAdrList); <br> <br>                    if(FAILED(hr)) <br>                    { <br>                        goto cleanup; <br>                    } <br> <br>                    iNak++; <br>                } <br>                else <br>                { <br>                    goto skip; <br>                } <br>            } <br>            else <br>            { <br>skip: <br>                hr = HrMAPISetAddressList( <br>                    iAck, <br>                    cMapValues, <br>                    lpMapProps, <br>                    *lppAdrList); <br> <br>                if(FAILED(hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                iAck++; <br>            } <br>        } <br>    } <br> <br>    (*lppAdrList)-&gt;cEntries    = iAck; <br>    (*lppNDRAdrList)-&gt;cEntries = iNak; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        if(*lppAdrList != NULL) <br>        { <br>            FREEPADRLIST(*lppAdrList); <br>        } <br> <br>        if(*lppNDRAdrList != NULL) <br>        { <br>            FREEPADRLIST(*lppNDRAdrList); <br>        } <br> <br>    } <br> <br>    MAPIFREEBUFFER(lpNewProps); <br>             <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
