<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSGEMIT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1915"></a>MSGEMIT.CPP</h2>
<pre><code>// --msgemit.cpp-------------------------------------------------------------- <br>// <br>// API entry points for the msgemit static link library. <br>// Contains helper functions for converting MAPI messages to  <br>// 822-style headers. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "msgemit.h" <br>#include "tagnames.h" <br>#include "msgemit.chk" <br> <br>// Value to string lookup tables. <br>// These tables are referrend by offset for a speedy conversion <br> <br>// Day of week lookup table <br>static const STRINGVALUEPAIRW rgDayW[nDays]  = <br>{ <br>    {0, lpszSundayW      }, <br>    {1, lpszMondayW      }, <br>    {2, lpszTuesdayW     }, <br>    {3, lpszWednesdayW   }, <br>    {4, lpszThursdayW    }, <br>    {5, lpszFridayW      }, <br>    {6, lpszSaturdayW    } <br>}; <br> <br>static const STRINGVALUEPAIRA rgDayA[nDays]  = <br>{ <br>    {0, lpszSundayA      }, <br>    {1, lpszMondayA      }, <br>    {2, lpszTuesdayA     }, <br>    {3, lpszWednesdayA   }, <br>    {4, lpszThursdayA    }, <br>    {5, lpszFridayA      }, <br>    {6, lpszSaturdayA    } <br>}; <br> <br>// Month of year lookup table <br>static const STRINGVALUEPAIRW rgMonthW[nMonths]  =    <br>{ <br>    {1,  lpszJanuaryW    }, <br>    {2,  lpszFebruaryW   }, <br>    {3,  lpszMarchW      }, <br>    {4,  lpszAprilW      }, <br>    {5,  lpszMayW        }, <br>    {6,  lpszJuneW       }, <br>    {7,  lpszJulyW       }, <br>    {8,  lpszAugustW     }, <br>    {9,  lpszSeptemberW  }, <br>    {10, lpszOctoberW    }, <br>    {11, lpszNovemberW   }, <br>    {12, lpszDecemberW   } <br>}; <br> <br>static const STRINGVALUEPAIRA rgMonthA[nMonths]  =    <br>{ <br>    {1,  lpszJanuaryA    }, <br>    {2,  lpszFebruaryA   }, <br>    {3,  lpszMarchA      }, <br>    {4,  lpszAprilA      }, <br>    {5,  lpszMayA        }, <br>    {6,  lpszJuneA       }, <br>    {7,  lpszJulyA       }, <br>    {8,  lpszAugustA     }, <br>    {9,  lpszSeptemberA  }, <br>    {10, lpszOctoberA    }, <br>    {11, lpszNovemberA   }, <br>    {12, lpszDecemberA   } <br>}; <br> <br>// Trace action lookup table <br>static const STRINGVALUEPAIR rgAction[nActions]    = <br>{ <br>    { MD_AC_EXPANDED,    lpszExpanded   },  // MD_AC_EXPANDED = -2 <br>    { MD_AC_REDIRECTED,  lpszRedirected },  // MD_AC_REDIRECTED = -1 <br>    { MD_AC_RELAYED,     lpszRelayed    },  // MD_AC_RELAYED = 0 <br>    { MD_AC_REROUTED,    lpszRerouted   }   // MD_AC_REROUTED = 1 <br>}; <br> <br>// Priority string lookup table <br>static const STRINGVALUEPAIR rgPriority[nPriorities]   =    <br>{ <br>    { PRIO_NONURGENT,   lpszNonUrgent       },  // PRIO_NONURGENT = -1 <br>    { PRIO_NORMAL,      lpszNormalUrgency   },  // PRIO_NORMAL = 0 <br>    { PRIO_URGENT,      lpszUrgent          }   // PRIO_URGENT = 1 <br>}; <br> <br>// Importance values lookup table <br>static const STRINGVALUEPAIR rgImportance[nImportances]    =    <br>{ <br>    { IMPORTANCE_LOW,       lpszLowImp      },  // IMPORTANCE_LOW = 0 <br>    { IMPORTANCE_NORMAL,    lpszNormalImp   },  // IMPORTANCE_NORAML = 1 <br>    { IMPORTANCE_HIGH,      lpszHighImp     }   // IMPORTANCE_HIGH = 2 <br>}; <br> <br>// inline constant encoding "macro" used <br>// by HrEDKEncodeBinaryStreamDataToStream and <br>// HrEDKEncodeBinaryDataToStream. <br>static inline VOID EDKEncodeByte(       // RETURNS: VOID <br>    IN BYTE b,                          // byte to encode <br>    OUT CHAR szOutBuffer[])            // static output buffer <br>{ <br>    wsprintf( <br>        szOutBuffer,            // output buffer <br>        "%2.2X ",               // format string <br>        b);                     // byte to encode <br>} <br> <br>//$--HrCreateDateTimeString@------------------------------------------------- <br>// <br>// DESCRIPTION: Builds a date &amp; time created string for a MAPI message file time <br>// <br>// INPUT:       lpFileTime  --  File Time structure pointer <br>// <br>// OUTPUT:      lppTimeString   --  Pointer to time string output buffer <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if bad input, <br>//                              E_OUTOFMEMORY if memory problems, <br>//                              E_FAIL otherwise <br>// <br>// --------------------------------------------------------------------------- <br>HRESULT HrCreateDateTimeStringW( <br>    IN LPFILETIME lpFileTime,       // message file time pointer <br>    OUT LPWSTR * lppTimeString)     // pointer to time string buffer <br>{ <br>    HRESULT     hr              =   NOERROR;    // return code <br>    SYSTEMTIME  sSystemTime     =   {0};        // system time structure <br>    WCHAR       szTempString[ulMaxOutStringLen] =   {0};        // for integer to ASCII conversions <br>    BOOL        fSucceeded      =   FALSE;      // Windows API return code <br> <br>    DEBUGPUBLIC( "HrCreateDateTimeStringW()"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrCreateDateTimeStringW(lpFileTime, lppTimeString); <br>    if ( FAILED(hr) ) <br>        RETURN(hr); <br> <br>    // Allocate memory for output string. <br>    hr = MAPIAllocateBuffer( <br>        ulMaxOutStringLen * sizeof(WCHAR),  <br>        (PVOID *)lppTimeString); <br>    if ( FAILED(hr) ) <br>        goto cleanup; <br> <br>    **lppTimeString = L'\0';    // Set output string to empty string <br> <br>    // If input time is all zeros, then we are done.  The <br>    // output string is the empty string. <br>    if ( (lpFileTime-&gt;dwLowDateTime == 0) &amp;&amp;  <br>         (lpFileTime-&gt;dwHighDateTime == 0) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Convert FILETIME structure to a SYSTEMTIME structure <br>    fSucceeded = FileTimeToSystemTime(lpFileTime, &amp;sSystemTime); <br>    if ( !fSucceeded ) <br>    { <br>        GetSystemTime(&amp;sSystemTime); <br>    } <br> <br>    // Build new date time string.  New date time string format is: <br>    //  <br>    // "DAY, DT MON YEAR HH:MM:SS" <br>    // <br>    // (Day, date month year hours:minutes:seconds) <br> <br>    ASSERTERROR(sSystemTime.wDayOfWeek &lt; nDays, "Bad sSystemTime.wDayOfWeek"); <br> <br>    // Set day of week (0 - 6)  (offset is 0) <br>    lstrcpyW( *lppTimeString,  <br>            rgDayW[sSystemTime.wDayOfWeek].lpszString); <br>                     <br>    // Set date (1-31).  Space pad it to two characters. <br>    wsprintfW(szTempString, L"%2.2d ", sSystemTime.wDay); <br>    lstrcatW(*lppTimeString, szTempString); <br> <br>    ASSERTERROR(sSystemTime.wMonth &lt;= nMonths, "Bad sSystemTime.wMonth"); <br>    ASSERTERROR(sSystemTime.wMonth &gt; 0, "Bad sSystemTime.wMonth"); <br>         <br>    // Set month (1-12) (e.g. offset is 1) <br>    lstrcatW(*lppTimeString,  <br>            rgMonthW[sSystemTime.wMonth - 1].lpszString); <br> <br>    // Set year, hour, minute and second. <br>    wsprintfW(szTempString,  <br>             L"%u %2.2u:%2.2u:%2.2u UT",   // format string <br>             sSystemTime.wYear, <br>             sSystemTime.wHour, <br>             sSystemTime.wMinute, <br>             sSystemTime.wSecond); <br>    lstrcatW(*lppTimeString, szTempString); <br> <br>cleanup: <br>    if( FAILED(hr)) <br>        MAPIFREEBUFFER(*lppTimeString); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrCreateDateTimeStringA( <br>    IN LPFILETIME lpFileTime,       // message file time pointer <br>    OUT LPSTR   * lppTimeString)    // pointer to time string buffer <br>{ <br>    HRESULT     hr              =   NOERROR;    // return code <br>    SYSTEMTIME  sSystemTime     =   {0};        // system time structure <br>    CHAR        szTempString[ulMaxOutStringLen] =   {0};        // for integer to ASCII conversions <br>    BOOL        fSucceeded      =   FALSE;      // Windows API return code <br> <br>    DEBUGPUBLIC( "HrCreateDateTimeStringA()"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrCreateDateTimeStringA(lpFileTime, lppTimeString); <br>    if ( FAILED(hr) ) <br>        RETURN(hr); <br> <br>    // Allocate memory for output string. <br>    hr = MAPIAllocateBuffer( <br>        ulMaxOutStringLen * sizeof(CHAR),  <br>        (PVOID *)lppTimeString); <br>    if (FAILED( hr)) <br>        goto cleanup; <br> <br>    **lppTimeString = '\0';    // Set output string to empty string <br> <br>    // If input time is all zeros, then we are done.  The <br>    // output string is the empty string. <br>    if ( (lpFileTime-&gt;dwLowDateTime == 0) &amp;&amp;  <br>         (lpFileTime-&gt;dwHighDateTime == 0) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Convert FILETIME structure to a SYSTEMTIME structure <br>    fSucceeded = FileTimeToSystemTime(lpFileTime, &amp;sSystemTime); <br>    if ( !fSucceeded ) <br>    { <br>        GetSystemTime(&amp;sSystemTime); <br>    } <br> <br>    // Build new date time string.  New date time string format is: <br>    //  <br>    // "DAY, DT MON YEAR HH:MM:SS" <br>    // <br>    // (Day, date month year hours:minutes:seconds) <br> <br>    ASSERTERROR(sSystemTime.wDayOfWeek &lt; nDays, "Bad sSystemTime.wDayOfWeek"); <br> <br>    // Set day of week (0 - 6)  (offset is 0) <br>    lstrcpyA( *lppTimeString,  <br>            rgDayA[sSystemTime.wDayOfWeek].lpszString); <br>                     <br>    // Set date (1-31).  Space pad it to two characters. <br>    wsprintfA(szTempString, "%2.2d ", sSystemTime.wDay); <br>    lstrcatA(*lppTimeString, szTempString); <br> <br>    ASSERTERROR(sSystemTime.wMonth &lt;= nMonths, "Bad sSystemTime.wMonth"); <br>    ASSERTERROR(sSystemTime.wMonth &gt; 0, "Bad sSystemTime.wMonth"); <br>         <br>    // Set month (1-12) (e.g. offset is 1) <br>    lstrcatA(*lppTimeString,  <br>            rgMonthA[sSystemTime.wMonth - 1].lpszString); <br> <br>    // Set year, hour, minute and second. <br>    wsprintfA(szTempString,  <br>             "%u %2.2u:%2.2u:%2.2u UT",   // format string <br>             sSystemTime.wYear, <br>             sSystemTime.wHour, <br>             sSystemTime.wMinute, <br>             sSystemTime.wSecond); <br>    lstrcatA(*lppTimeString, szTempString); <br> <br>cleanup: <br>    if( FAILED(hr)) <br>        MAPIFREEBUFFER(*lppTimeString); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCreateImportanceString------------------------------------------------ <br>// <br>// DESCRIPTION: Creates an message importance string from a MAPI message importance value <br>// <br>// INPUT:       ulImportance    --  message's PR_IMPORTANCE value <br>//               <br>// OUTPUT:      lppImportance --  Pointer to importance string buffer <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_OUTOFMEMORY if memory problems, <br>//                              E_FAIL otherwise. <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT HrCreateImportanceString(                   //  RETURNS:    HRESULT <br>                    IN ULONG ulImportance,             // message's PR_IMPORTANCE value <br>                    OUT LPSTR * lppImportance)  // pointer to importance string buffer <br>{ <br>    HRESULT hr      =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("HrCreateImportanceString()"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrCreateImportanceString(ulImportance, lppImportance); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Allocate memory for output string <br>    hr = MAPIAllocateBuffer(ulMaxOutStringLen * sizeof(CHAR),  <br>                            (LPVOID *) lppImportance); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = E_OUTOFMEMORY; <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!IsBadWritePtr(*lppImportance, sizeof(LPSTR)), <br>                "Bad *lppImportance"); <br> <br>    **lppImportance = 0;    // set output string to empty string <br>     <br>    // Create importance string (offset is 0) <br>    lstrcpy(*lppImportance, <br>            rgImportance[ulImportance].lpszString); <br> <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // free the output buffer <br>        MAPIFREEBUFFER(*lppImportance); <br>    } <br> <br>    RETURN(hr); <br> <br>}   // end HrCreateImportanceString() <br> <br>//$--HrEmitTagDataLine------------------------------------------------------- <br>// <br>// DESCRIPTION: Emits a line constructed from a static tag and dynamic <br>//              data to the specified stream.  If the data is the empty <br>//              string, writes the NULL byte (0x00) out to the stream. <br>// <br>// INPUT:       lpszTag --  tag portion of line  <br>//              lpData      --  data portion of line (may be "") <br>//              lpStream    --  stream to write line to <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter,d <br>//                              E_FAIL otherwise <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT HrEmitTagDataLine(    <br>        IN LPCSTR lpszTag,     // static portion of line <br>        IN LPSTR lpData,       // dynamic portion of line <br>        IN LPSTREAM lpStream)   // stream to write line to <br>{ <br>    HRESULT hr              =   NOERROR; <br>    ULONG   cbWritten       =   0;      // # bytes written <br> <br>    DEBUGPRIVATE("HrEmitTagDataLine()"); <br> <br>    // Check input parameters <br>    hr = CHK_HrEmitTagDataLine(lpszTag, lpData,  <br>                               lpStream); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br>     <br>    // Write tag to stream. <br>    hr = lpStream-&gt;Write(lpszTag,  <br>                         cbStrBytes(lpszTag), <br>                         &amp;cbWritten); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR((cbWritten == cbStrBytes(lpszTag)), "Bad cbWritten"); <br> <br>    // Write colon to stream <br>    hr = lpStream-&gt;Write(lpszColon,  <br>                         cbStrBytes(lpszColon), <br>                         &amp;cbWritten); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR((cbWritten == cbStrBytes(lpszColon)), "Bad cbWritten"); <br> <br>    // Write data to stream <br>    hr = lpStream-&gt;Write( <br>                lpData,  <br>                cbStrBytes(lpData),  <br>                &amp;cbWritten); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR((cbWritten == cbStrBytes(lpData)), "Bad cbWritten"); <br> <br>    // Write new line to stream (indicates end of line) <br>    hr = lpStream-&gt;Write(lpszNewLine,  <br>                         cbStrBytes(lpszNewLine), <br>                         &amp;cbWritten); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR((cbWritten == cbStrBytes(lpszNewLine)), "Bad cbWritten"); <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrCreatePriorityString------------------------------------------------------- <br>// <br>// DESCRIPTION: Creates message priority data string from a MAPI priority value <br>// <br>// INPUT:       ulPriority  --  message's PR_PRIORITY value <br>// <br>// OUTPUT:      lppPriorityString --  message priority data string pointer <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_OUTOFMEMORY if memory problems <br>//                              E_FAIL otherwise <br>// <br>// --------------------------------------------------------------------------- <br> <br>HRESULT HrCreatePriorityString(    <br>        IN ULONG ulPriority,         // message's PR_PRIORITY value <br>        OUT LPSTR * lppPriorityString)   // message priority data string pointer <br>{ <br>    HRESULT hr      =   NOERROR; <br> <br>    DEBUGPRIVATE("HrCreatePriorityString()"); <br> <br>    // check input parameters <br>    hr = CHK_HrCreatePriorityString(ulPriority, lppPriorityString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Allocate memory for output string <br>    hr = MAPIAllocateBuffer(ulMaxOutStringLen * sizeof(CHAR),  <br>                            (LPVOID *) lppPriorityString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = E_OUTOFMEMORY; <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!IsBadWritePtr(*lppPriorityString, sizeof(LPSTR)), <br>                "Bad *lppPriorityString"); <br> <br>    **lppPriorityString = 0;    // set output string to empty string <br> <br>    // Assign appropriate string (offset is -1) <br>    lstrcpy(*lppPriorityString, <br>            rgPriority[ulPriority + nPrioOffset].lpszString); <br> <br>    // we are done <br> <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // free output buffer <br>        MAPIFREEBUFFER(*lppPriorityString); <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrEDKEncodeBinaryStreamDataToStream----------------------------------------------- <br>// <br>// DESCRIPTION: Copies binary data from an input stream or <br>//              specified output stream, <br>//              encoding each byte as a two-character <br>//              hexadecimal ASCII representation of the byte. <br>//              E.g. 255 becomes 'FF'. <br>// <br>// INPUT:        <br>//              lpStreamIn  --  input stream pointer <br>//              lpStreamOut --  output stream pointer <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_FAIL otherwise <br>// <br>// --------------------------------------------------------------------------- <br>HRESULT HrEDKEncodeBinaryStreamDataToStream(                <br>    IN LPSTREAM lpStreamIn,     // input stream pointer <br>    IN LPSTREAM lpStreamOut)    // output stream pointer <br>{ <br>    HRESULT     hr                  =   NOERROR;    // return code <br>    ULONG       cbRead              =   0;          // # bytes read <br>    ULONG       cbWrite             =   0;          // # bytes to be written <br>    BYTE *      lpByteRead          =   NULL;       // pointer into bytes read buffer <br>    CHAR *     lpCharWrite         =   NULL;       // pointer into characters to write buffer <br>    ULONG       iLoopCount          =   0;          // loop counter <br> <br>    BYTE       szBinaryData[nBytesEncodePerLine] = "";        // byte buffer to read data into <br>    CHAR       szOutputLine[ulMaxOutStringLen] =   {0};       // Converted ASCII text <br>    CHAR       szTempBuffer[ulMaxOutStringLen] =   {0};       // temporary buffer <br> <br>    DEBUGPRIVATE("HrEDKEncodeBinaryStreamDataToStream()"); <br> <br>    // Check input parameters. <br>    hr = CHK_HrEDKEncodeBinaryStreamDataToStream( <br>                            lpStreamIn,  <br>                            lpStreamOut); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Read data from input stream and <br>    // write encoded version to output stream. <br>    while ( TRUE ) <br>    { <br>            // Read 24 bytes of text from input stream. <br>        hr = lpStreamIn-&gt;Read( <br>                    szBinaryData,   // buffer <br>                    nBytesEncodePerLine,      // # bytes <br>                    &amp;cbRead);       // # bytes read <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // See if there are no more bytes to process (last line of <br>        // file has exactly 24 bytes) <br>        if ( cbRead == 0 ) <br>        { <br>            // we are done! <br>            break; <br>        } <br> <br>        // Convert each byte to a two-digit hexadecimal representation <br>        // of it. <br>        lpByteRead = szBinaryData;      // initialize pointer into input buffer <br>        lpCharWrite = szOutputLine;     // initialize pointer into write buffer <br>        *lpCharWrite = 0;               // null terminate output string <br>        for ( iLoopCount = 0; iLoopCount &lt; cbRead;  <br>              iLoopCount++ ) <br>        { <br>            // Encode byte <br>            EDKEncodeByte( <br>                    *lpByteRead,        // byte to encode <br>                    szTempBuffer);      // output buffer <br> <br>            // Append encoded by to output string <br>            lstrcpy(lpCharWrite, szTempBuffer); <br>            lpCharWrite += lstrlen(szTempBuffer);   // increment write pointer <br>            lpByteRead++;       // increment read pointer by one byte <br> <br>        }   // end for <br> <br>        // replace the last space with a new line character. <br>        lpCharWrite--; <br>        lstrcpy(lpCharWrite, lpszNewLine); <br> <br>        cbWrite = lstrlen(szOutputLine) * sizeof(CHAR); <br> <br>        // Write the converted attachment text from body stream to the output stream. <br>        // Decision:  Don't try to recover from a partial write. <br>        hr = lpStreamOut-&gt;Write( <br>                    szOutputLine,   // buffer <br>                    cbWrite,        // # bytes <br>                    NULL);          // don't care <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        if ( cbRead != nBytesEncodePerLine ) <br>        { <br>            break;  // done reading from body stream <br>        } <br> <br>        // do next set of input bytes <br> <br>    }   // end while <br> <br>    // we are done <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>}   // end HrEDKEncodeBinaryStreamDataToStream() <br> <br>//$--HrCreateExternalTraceString------------------------------------------------ <br>// <br>// DESCRIPTION: Creates a string from a message's external trace information. <br>// <br>// INPUT:       lAction --  trace action <br>//              lpCountry   --  country <br>//              lpADMDName  --  ADMD name <br>//              lpPRMDId    --  PRMD identifier <br>//           <br>// OUTPUT:      lppTraceString  --  pointer to trace information string buffer <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_OUTOFMEMORY if memory problems <br>//                              E_FAIL otherwise, <br>// <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT HrCreateExternalTraceString(         <br>    IN LONG lAction,             // trace action <br>    IN LPSTR lpCountry,         // country name <br>    IN LPSTR lpADMDName,        // ADMD name <br>    IN LPSTR lpPRMDId,          // PRMD identifier     <br>    OUT LPSTR * lppTraceString)    // trace information string pointer <br>{ <br>    HRESULT         hr              =   NOERROR;     <br> <br>    DEBUGPRIVATE("HrCreateExternalTraceString()"); <br> <br>    hr = CHK_HrCreateExternalTraceString( <br>lAction, <br>lpCountry, <br>lpADMDName,  <br>        lpPRMDId, <br>lppTraceString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Allocate memory for output string. <br>    hr = MAPIAllocateBuffer(ulMaxOutStringLen * sizeof(CHAR),  <br>                            (LPVOID *) lppTraceString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!IsBadWritePtr(*lppTraceString, sizeof(LPSTR)), <br>                "Bad *lppTraceString"); <br> <br>    **lppTraceString = 0;    // Set output string to empty string <br> <br>    // Check to see if the PRMD, ADMD and country strings are <br>    // empty.  If they are, then we are done (The trace string <br>    // to output is the empty string). <br>    if ( (*lpCountry == 0) &amp;&amp; (*lpADMDName == 0) &amp;&amp; (*lpPRMDId == 0) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Format of trace string is: <br>    // by /P=&lt;Prmd&gt; /A=&lt;Admd&gt; /C=&lt;Country&gt;/;&lt;Action&gt;; <br>    // NOTE:  The trace arrival date and time is printed out <br>    // separately. <br> <br>    // Copy in "/P=" string <br>    lstrcpy(*lppTraceString, lpszPRMDId); <br> <br>    // Add the PRMD data <br>    lstrcat(*lppTraceString, lpPRMDId); <br> <br>    // Copy in the /A= string <br>    lstrcat(*lppTraceString, lpszADMDName); <br> <br>    // Add the ADMD data <br>    lstrcat(*lppTraceString, lpADMDName); <br> <br>    // Copy in the /C= string <br>    lstrcat(*lppTraceString, lpszCountry); <br> <br>    // Add the country data <br>    lstrcat(*lppTraceString, lpCountry); <br> <br>    // Copy in the /; string <br>    lstrcat(*lppTraceString, lpszCountryEnd); <br>     <br>    // Add the action data (offset is -2) <br>    lstrcat(*lppTraceString, <br>            rgAction[lAction + nActOffset].lpszString);                 <br> <br>    // We are done. <br> <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // free output buffer <br>        MAPIFREEBUFFER(*lppTraceString); <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrCreateInternalTraceString------------------------------------------------ <br>// <br>// DESCRIPTION: Creates a string from a message's internal trace information. <br>// <br>// INPUT:       lAction--  trace action <br>//              lpCountry   --  country <br>//              lpADMDName  --  ADMD name <br>//              lpPRMDId    --  PRMD identifier <br>//              lpMTAName   --  MTA name <br>//           <br>// OUTPUT:      lppTraceString  --  pointer to trace information string buffer <br>// <br>// RETURNS:     HRESULT     --  NOERROR if successful, <br>//                              E_INVALIDARG if invalid parameter, <br>//                              E_OUTOFMEMORY if memory problems <br>//                              E_FAIL otherwise, <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateInternalTraceString(         <br>    IN LONG lAction,             // trace action <br>    IN LPTSTR lpCountry,         // country name <br>    IN LPTSTR lpADMDName,        // ADMD name <br>    IN LPTSTR lpPRMDId,          // PRMD identifier     <br>IN LPTSTR lpMTAName,         // MTA name <br>    OUT LPTSTR * lppTraceString)    // trace information string pointer <br>{ <br>    HRESULT         hr              =   NOERROR;     <br> <br>    DEBUGPRIVATE("HrCreateInternalTraceString()"); <br> <br>    hr = CHK_HrCreateInternalTraceString( <br>lAction, <br>lpCountry, <br>lpADMDName,  <br>        lpPRMDId, <br>lpMTAName, <br>lppTraceString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Allocate memory for output string. <br>    hr = MAPIAllocateBuffer(ulMaxOutStringLen * sizeof(TCHAR),  <br>                            (LPVOID *) lppTraceString); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!IsBadWritePtr(*lppTraceString, sizeof(LPTSTR)), <br>                "Bad *lppTraceString"); <br> <br>    **lppTraceString = 0;    // Set output string to empty string <br> <br>    // Check to see if the PRMD, ADMD and country strings are <br>    // empty.  If they are, then we are done (The trace string <br>    // to output is the empty string). <br>    if ( (*lpCountry == 0) &amp;&amp; (*lpADMDName == 0) &amp;&amp; <br> (*lpPRMDId == 0) &amp;&amp;  (*lpMTAName == 0) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Format of trace string is: <br>    // by /M=&lt;Mta&gt; /P=&lt;Prmd&gt; /A=&lt;Admd&gt; /C=&lt;Country&gt;/;&lt;Action&gt;; <br>    // NOTE:  The trace arrival date and time is printed out <br>    // separately. <br> <br>    // Copy in the /M= string <br>    lstrcpy(*lppTraceString, lpszMTAName); <br> <br>    // Add the MTA data <br>    lstrcat(*lppTraceString, lpMTAName); <br> <br>    // Copy in "/P=" string <br>    lstrcat(*lppTraceString, lpszPRMDId); <br> <br>    // Add the PRMD data <br>    lstrcat(*lppTraceString, lpPRMDId); <br> <br>    // Copy in the /A= string <br>    lstrcat(*lppTraceString, lpszADMDName); <br> <br>    // Add the ADMD data <br>    lstrcat(*lppTraceString, lpADMDName); <br> <br>    // Copy in the /C= string <br>    lstrcat(*lppTraceString, lpszCountry); <br> <br>    // Add the country data <br>    lstrcat(*lppTraceString, lpCountry); <br> <br>    // Copy in the /; string <br>    lstrcat(*lppTraceString, lpszCountryEnd); <br>     <br>    // Add the action data (offset is -2) <br>    lstrcat(*lppTraceString, <br>            rgAction[lAction + nActOffset].lpszString);                 <br> <br>    // We are done. <br> <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // free output buffer <br>        MAPIFREEBUFFER(*lppTraceString); <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrGetRecipientList------------------------------------------ <br>// <br>// DESCRIPTION: Utility function which retrieves columns  <br>// desired from a MAPI recipient table. <br>// <br>// INPUT:   lpMessage   --  pointer to MAPI message <br>//          lpPropTags  --  list of columns (properties) to retrieve <br>//           <br>// OUTPUT:  lppRows --  pointer to array of rows returned pointer. <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_FAIL otherwise <br>// <br>// ------------------------------------------------------------- <br>HRESULT HrGetRecipientList(            <br>        IN LPMESSAGE lpMessage,         // MAPI message  pointer <br>        IN LPSPropTagArray lpPropTags,  // properties (columns) desired <br>        OUT LPSRowSet * lppRows)        // pointer to rows returned <br>{ <br>    HRESULT     hr      =   NOERROR; <br>    LPMAPITABLE lpTable =   NULL;       // MAPI table pointer  <br>      <br>    DEBUGPRIVATE("HrGetRecipientList()"); <br> <br>    // check input parameters <br>    hr = CHK_HrGetRecipientList(lpMessage, lpPropTags,  <br>                                  lppRows); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Open the report envelope's recipient table <br>    hr = lpMessage-&gt;GetRecipientTable( <br>        MAPI_DEFERRED_ERRORS | fMapiUnicode,    // flags <br>        &amp;lpTable);     // MAPI table pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!FBadUnknown(lpTable), <br>                "Bad lpTable"); <br> <br>    // Retrieve all of the rows in the table.     <br>    // (HrQueryAllRows does a SetColumns for us.) <br>    hr = HrQueryAllRows(lpTable,    // MAPI table pointer <br>                        lpPropTags, // columns to return <br>                        NULL,       // restriction pointer <br>                        NULL,       // order set pointer <br>                        0,          // maximum # rows (defaults to all) <br>                        lppRows);   // pointer to property value array pointer <br> <br>    if ( FAILED(hr) || (hr == MAPI_W_POSITION_CHANGED) ) <br>    { <br>        hr = HR_LOG(E_FAIL); </code></pre>
<p>
</p>
<pre><code><br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(lppRows != NULL, "Bad lppRows"); <br>    ASSERTERROR(!IsBadReadPtr(*lppRows, sizeof(SRowSet)), <br>                "Bad *lppRows"); <br> <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        FREEPROWS(*lppRows); <br>    } <br> <br>    // Release MAPI objects <br>    ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
