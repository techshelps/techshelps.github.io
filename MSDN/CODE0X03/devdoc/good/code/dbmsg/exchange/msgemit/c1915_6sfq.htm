<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSGPARSE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1916"></a>MSGPARSE.CPP</h2>
<pre><code>// --msgparse.cpp------------------------------------------------------------- <br>// <br>// API entry points for the msgemit static link library. <br>// Contains helper functions for converting Ascii <br>// 822-style headers to MAPI messages. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "msgemit.h" <br>#include "tagnames.h"  <br>#include "msgparse.chk" <br> <br>// Value to string lookup tables. <br> <br>// Day of week lookup table <br>static const STRINGVALUEPAIRA rgSortedDay[nDays]  = <br>{ <br>    {5, lpszFridayA      }, <br>    {1, lpszMondayA      }, <br>    {6, lpszSaturdayA    }, <br>    {0, lpszSundayA      }, <br>    {4, lpszThursdayA    }, <br>    {2, lpszTuesdayA     }, <br>    {3, lpszWednesdayA   } <br>}; <br> <br>// Month of year lookup table <br>static const STRINGVALUEPAIRA rgSortedMonth[nMonths]  =    <br>{ <br>    {4,  lpszAprilA      }, <br>    {8,  lpszAugustA     }, <br>    {12, lpszDecemberA   }, <br>    {2,  lpszFebruaryA   }, <br>    {1,  lpszJanuaryA    }, <br>    {7,  lpszJulyA       }, <br>    {6,  lpszJuneA       }, <br>    {3,  lpszMarchA      }, <br>    {5,  lpszMayA        }, <br>    {11, lpszNovemberA   }, <br>    {10, lpszOctoberA    }, <br>    {9,  lpszSeptemberA  } <br>}; <br> <br>// Trace action lookup table <br>static const STRINGVALUEPAIR rgAction[nActions]    = <br>{ <br>    { MD_AC_EXPANDED,    lpszExpanded   },  // MD_AC_EXPANDED = -2 <br>    { MD_AC_REDIRECTED,  lpszRedirected },  // MD_AC_REDIRECTED = -1 <br>    { MD_AC_RELAYED,     lpszRelayed    },  // MD_AC_RELAYED = 0 <br>    { MD_AC_REROUTED,    lpszRerouted   }   // MD_AC_REROUTED = 1 <br>}; <br> <br>// Priority string lookup table <br>static const STRINGVALUEPAIR rgPriority[nPriorities]   =    <br>{ <br>    { PRIO_NONURGENT,   lpszNonUrgent       },  // PRIO_NONURGENT = -1 <br>    { PRIO_NORMAL,      lpszNormalUrgency   },  // PRIO_NORMAL = 0 <br>    { PRIO_URGENT,      lpszUrgent          }   // PRIO_URGENT = 1 <br>}; <br> <br>// Importance values lookup table <br>static const STRINGVALUEPAIR rgImportance[nImportances]    =    <br>{ <br>    { IMPORTANCE_HIGH,      lpszHighImp     },  // IMPORTANCE_HIGH = 2 <br>    { IMPORTANCE_LOW,       lpszLowImp      },  // IMPORTANCE_LOW = 0 <br>    { IMPORTANCE_NORMAL,    lpszNormalImp   }   // IMPORTANCE_NORAML = 1 <br>}; <br> <br>// static inline "macro" function for speed of execution. <br> <br>//$--nAsciiHexToInt------------------------------------------------------------ <br>// DESCRIPTION: <br>// <br>// Static inline function which converts a hexadecimal <br>// "character" to its equivalent integer value (e.g. 'F' to 15). <br>// This function is a static inline function with <br>// no parameter checking for speed! <br>// <br>// INPUT:   chHex   --  hexadecimal character <br>// <br>// RETURNS: UINT <br>// <br>// ---------------------------------------------------------------------------- <br>static inline UINT nAsciiHexToInt( <br>            IN CHAR chHex)         // hexadecimal character <br>{ <br>    // Covert hex character to decimal <br>    if ( isdigit(chHex) )  <br>    { <br>        return(chHex - '0'); <br>    } <br>     <br>    else <br>    {         <br>        return((chHex - 'A') + 10); <br>    } <br>} <br> <br>//$----HrFindStringValue-------------------------------------------------------- <br>// <br>// DESCRIPTION: Convert a string to its associated <br>//              integer value. <br>// <br>// INPUT:       lpString  --  string <br>//              nValues --  number of values in array <br>//              rgValue --  string value pair array <br>//              <br>// OUTPUT:      pulValue --  pointer to value <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>static HRESULT HrFindStringValue( <br>    IN LPSTR lpString,         // string <br>    IN UINT nValues,            // number values in array <br>    IN const STRINGVALUEPAIR rgValue[],   // string value pair array <br>    OUT ULONG * pulValue)       // value pointer <br>{ <br>    HRESULT hr          =   NOERROR; <br>    UINT    iValue      =   0;      // current index into string value array <br>    INT     nRetVal     =   0;      // lstrcmp return value <br>    BOOL    fFound      =   FALSE;  // TRUE if value found <br> <br>    DEBUGPRIVATE("HrFindStringValue()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrFindStringValue(lpString, nValues, rgValue, pulValue); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pulValue = 0;   // initialize <br> <br>    // Find matching string <br>    // These arrays are small enough that a linear search is <br>    // acceptable. <br>    for ( iValue = 0; iValue &lt; nValues; iValue++ ) <br>    { <br>        nRetVal = lstrcmp( <br>                lpString,  <br>                rgValue[iValue].lpszString); <br> <br>        if ( nRetVal == 0 )     // strings match <br>        { <br>            // found it.  Assign value. <br>            *pulValue = rgValue[iValue].lValue; <br> <br>            fFound = TRUE; <br> <br>            break; <br>        } <br> <br>        // continue with next entry <br> <br>    }   // end for <br> <br>    // Test to see if value found <br>    if ( fFound == FALSE ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$----HrReadNextString--------------------------------------------------------- <br>// <br>// DESCRIPTION: Read string up to next separator character. <br>// <br>// INPUT:   lpString    --  input string <br>//          chSeparator --  separator character <br>//          cbBuffer    --  # bytes in output buffer           <br>// <br>// OUTPUT:  pszOutput  --  output string <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>static HRESULT HrReadNextString( <br>    IN LPSTR lpString,     // input string <br>    IN CHAR chSeparator,   // separator character <br>    IN UINT cbBuffer,       // # bytes in buffer <br>    OUT CHAR * pszOutput)  // output buffer <br>{ <br>    HRESULT hr      =   NOERROR; <br>    LPSTR  lpTemp  =   NULL;       // temporary string pointer <br>    LPSTR  lpOut   =   NULL;       // pointer intot output string <br>    UINT    cbRead  =   0;          // count of bytes read into output buffer <br>    CHAR   cTemp   =   0;          // current character <br> <br>    DEBUGPRIVATE("HrReadNextString()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrReadNextString(lpString, chSeparator, cbBuffer, <br>                              pszOutput); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pszOutput = 0;     // initialize output buffer <br> <br>    lpOut = pszOutput;  // output string pointer <br>    lpTemp = lpString;  // input string pointer <br> <br>    while ( cbRead &lt; cbBuffer ) <br>    { <br>        cTemp = *lpTemp;    // get current character <br> <br>        // Test the current character <br>        if ( cTemp == chSeparator ) <br>        { <br>            // We are done! <br>            goto cleanup; <br>        } <br>         <br>        if ( cTemp == 0 ) <br>        { <br>            // we have reached the end of the string. <br>            // and haven't seen the separator. <br>            hr = HR_LOG(E_FAIL);             <br> <br>            goto cleanup; <br>        } <br> <br>        // Otherwise, copy the character read into the  <br>        // output buffer. <br>        *lpOut = cTemp; <br> <br>        cbRead += sizeof(CHAR);    // increment # of characters read <br>         <br>        lpTemp++;   // increment pointer into input string <br>        lpOut++;    // increment pointer into output string <br> <br>    }   // end while <br> <br>    // we are done <br> <br>cleanup: <br> <br>    *lpOut = 0; <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$----HrParseTagAndData------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse ASCII 822-style header line into <br>//              tag and data components. <br>// <br>// INPUT:       lpStream    --  stream pointer to read from <br>// <br>// OUTPUT:      pcbRead --  number of bytes read from stream <br>//              ppTag   --  pointer to tag buffer <br>//              ppData  --  pointer to data buffer <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_OUTOFMEMORY if memory problem <br>//                          EDK_E_END_OF_FILE if end of stream <br>//                          E_FAIL otherwise <br>// <br>// --------------------------------------------------------------------------- <br>HRESULT HrParseTagAndData( <br>        IN LPSTREAM lpStream,   // stream pointer <br>        OUT ULONG * pcbRead,    // # of bytes read <br>        OUT LPSTR * lppTag,    // pointer to tag buffer <br>        OUT LPSTR * lppData)   // pointer to data buffer <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    CHAR           ch          =   0;          // character read <br>    ULONG           cb          =   0;          // number of bytes read <br>    ULONG           cbTag       =   0;          // number of bytes in tag <br>    ULONG           cbData      =   0;          // number of bytes in data <br>    LONGLONG   cbOffsetBack=   0;        // offset for Seek <br>LARGE_INTEGERsOffsetBack={0};// offset for Seek <br>    BOOL            fBlankLine  =   FALSE;      // TRUE if reading a blank line <br> <br>    DEBUGPRIVATE("HrParseTagAndData()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParseTagAndData(lpStream, pcbRead,  <br>                               lppTag, lppData); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Initialize output variables. <br>    *lppTag = 0; <br>    *lppData = 0; <br>    *pcbRead = 0; <br>     <br>    // Read in one character at a time until we read the <br>    // whole tag or encounter an error. <br>    while ( TRUE ) <br>    { <br>        hr = lpStream-&gt;Read( <br>                &amp;ch,            // buffer to read character into <br>                sizeof(CHAR),  // number of bytes to read <br>                &amp;cb);           // number of bytes read <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // See if we have reached the end of the file. <br>        if ( cb == 0 ) <br>        { <br>            // Early terminate of tag string. <br>            // This is an error. <br>            hr = HR_LOG(EDK_E_END_OF_FILE); <br> <br>            goto cleanup; <br>             <br>        }   // end if end of file <br> <br>        ASSERTERROR(cb == sizeof(CHAR), "Bad cb"); <br> <br>        // increment # bytes read <br>        *pcbRead += cb; <br>        cbTag += cb;    // increment # bytes in the tag <br> <br>        // Test the character read. <br>        if ( ch == chColon ) <br>        { <br>            // have read whole tag. <br>            // Go on to find the data. <br>            break;             <br> <br>        }   // end if colon character <br> <br>        if ( ch == chNewLine ) <br>        { <br>            // Read in a new line. <br>            // We have not found a tag. <br>            // This is an error if this is not a blank line <br>            // (i.e. \r\n). <br>            if ( *pcbRead == 2 ) <br>            { <br>                // have a blank line. <br>                // This is not an error. <br>                fBlankLine = TRUE; <br> <br>                // Pass back an empty tag and data <br>                cbTag = sizeof(CHAR); <br>                cbData = sizeof(CHAR); <br> <br>                break; <br>            } <br> <br>            // Otherwise, have a general error <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br> <br>        }   // end if new line character <br>    }   // end while looking for tag <br> <br>    // Read in one character at a time until we read the <br>    // whole data string or encounter an error. <br>    // Don't read any more if we have read in a blank line. <br>    while ( TRUE &amp;&amp; (fBlankLine == FALSE) ) <br>    { <br>        hr = lpStream-&gt;Read( <br>                &amp;ch,            // buffer to read character into <br>                sizeof(CHAR),  // number of bytes to read <br>                &amp;cb);           // number of bytes read <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ASSERTERROR(cb == sizeof(CHAR), "Bad cb"); <br> <br>        // See if we have reached the end of the file. <br>        if ( cb == 0 ) <br>        { <br>            // Reached end of file before new line. <br>            // This is an error. <br>            hr = HR_LOG(EDK_E_END_OF_FILE); <br> <br>            goto cleanup; <br> <br>        }   // end if end of file <br> <br>        // increment # bytes read <br>        *pcbRead += cb; <br> <br>        // Don't count the carriage return character <br>        if ( ch != chReturn ) <br>        { <br>            cbData += cb;           // increment number of data bytes <br>        } <br> <br>        if ( ch == chNewLine ) <br>        { <br>            // Found the end of this line. <br>            // We are done reading in the data. <br>            break; <br> <br>        }   // end if new line character <br>    }   // end while looking for data <br> <br>    // Allocate memory for the tag <br>    // (have room for null terminator, since <br>    // counted the colon which is not part of the tag. <br>    hr = MAPIAllocateBuffer( <br>        cbTag,      // # bytes <br>        (VOID **) lppTag);    // tag buffer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERT_WRITE_PTR(*lppTag, cbTag, "Bad *lppTag"); <br> <br>    // Initialize tag string <br>    **lppTag = 0; <br> <br>    // Allocate memory for the data string. <br>    // We have room for the null, since we <br>    // counted the newline, which is not part <br>    // of the data string. <br>    hr = MAPIAllocateBuffer( <br>        cbData,     // # of bytes <br>        (VOID **) lppData);   // data string buffer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERT_WRITE_PTR(*lppData, cbData, "Bad *lppData"); <br> <br>    // Initialize data string <br>    **lppData = 0; <br> <br>    // Read in tag and data if haven't already determined <br>    // that they are empty. <br>    if ( fBlankLine == FALSE ) <br>    { <br>        // Seek back to where we were in the stream and copy in <br>        // the tag and data. <br>        cbOffsetBack = (*pcbRead) * ((LONGLONG) (-1));// # bytes read <br> <br>sOffsetBack.LowPart = LOWLONG(cbOffsetBack); <br>sOffsetBack.HighPart = HILONG(cbOffsetBack); <br> <br>        hr = lpStream-&gt;Seek( <br>            sOffsetBack,        // negative offset <br>            STREAM_SEEK_CUR,    // from current position <br>            NULL);              // don't care <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Read in the tag <br>        hr = lpStream-&gt;Read( <br>            *lppTag,    // destination buffer. <br>            cbTag,      // # bytes to read <br>            &amp;cb);       // # bytes read <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ASSERTERROR(cb == cbTag, "Bad cb"); <br> <br>        // Null terminate tag by replacing colon with a NULL character. <br>        *(*lppTag + (cbTag/sizeof(CHAR) - 1)) = 0; <br> <br>        // Read in the data. <br>        hr = lpStream-&gt;Read( <br>            *lppData,   // destination buffer. <br>            cbData,     // # bytes to read <br>            &amp;cb);       // # bytes read <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ASSERTERROR(cb == cbData, "Bad cb"); <br> <br>        // Null terminate data by replacing carriage <br>        // return with a NULL character. <br>        ASSERTERROR(*(*lppData + (cbData/sizeof(CHAR) - 1)) == chReturn,  <br>            "Bad *lppData last character"); <br> <br>        *(*lppData + (cbData/sizeof(CHAR) - 1)) = 0; <br> <br>        // Read in the new line character. <br>        hr = lpStream-&gt;Read( <br>            &amp;ch,            // buffer <br>            sizeof(CHAR),  // # bytes <br>            &amp;cb); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        ASSERTERROR(cb == sizeof(CHAR), "Bad cb"); <br>        ASSERTERROR(ch == chNewLine, "Bad ch"); <br> <br>    }   // end if not returning blank tag and data <br> <br>    // we are done <br> <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        MAPIFREEBUFFER(*lppTag); <br>        MAPIFREEBUFFER(*lppData); <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$----HrParseDateTimeString---------------------------------------------------- <br>// <br>// DESCRIPTION: Parses a date and time string into a file time <br>//              structure. <br>// <br>// INPUT:       lpDateTimeString    --  date and time string <br>// <br>// OUTPUT:      pFileTime   --  file time pointer <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT HrParseDateTimeString( <br>    IN LPSTR lpDateTimeString,     // date and time string <br>    OUT FILETIME * pFileTime)       // file time pointer <br>{ <br>    HRESULT     hr                              = NOERROR;     <br>    CHAR       szTempBuffer[cbDateTimeString]  = {0};// temporary buffer <br>    LPSTR      lpTemp                          = NULL;    // string pointer <br>    SYSTEMTIME  sSystemTime                     = {0};     // system time structure <br>    ULONG       ulValue                         = 0;       // value pointer <br>    BOOL        fSucceeded                      = FALSE;   // Win32 API return code <br> <br>    // constants <br>    const UINT  ncDay       =   5;      // length of day string <br>    const UINT  ncMonth     =   4;      // length of month string <br>    const UINT  ncDuoDigit  =   2;      // length of two-digit integer <br>    const UINT  ncYear      =   4;      // length of year <br> <br>    DEBUGPRIVATE("HrParseDateTimeString()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParseDateTimeString(lpDateTimeString, pFileTime); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    ZeroMemory(pFileTime, sizeof(FILETIME));      // initialize output <br> <br>    // If the date/time string is empty, we are done. <br>    // (This is a valid case.) <br>    if ( lstrcmp(lpDateTimeString, lpszBlank) == 0 ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    lpTemp = lpDateTimeString;  // intialize string pointer <br> <br>    // Read in day string <br>    lstrcpyn(szTempBuffer, lpTemp, ncDay + 1); <br> <br>    // Find value associated with day of week. <br>    hr = HrFindStringValue( <br>            szTempBuffer,       // string <br>            nDays,              // number values <br>            rgSortedDay,        // string value pair array <br>            &amp;ulValue);          // value pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    sSystemTime.wDayOfWeek = (WORD) ulValue;    // set day of week <br> <br>    lpTemp += ncDay;  // increment string pointer <br> <br>    // Read in day of month (2 digits) <br>    lstrcpyn(szTempBuffer, lpTemp, ncDuoDigit + 1); <br>    sSystemTime.wDay = atoi(szTempBuffer); <br> <br>    // Check day of month <br>    if ( (sSystemTime.wDay == 0) || (sSystemTime.wDay &gt; 31) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += ncDuoDigit;   // increment string pointer <br> <br>    // Next character should be a space <br>    if ( *lpTemp != chSpace ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp ++;              // skip over space <br> <br>    // Read in month string <br>    lstrcpyn(szTempBuffer, lpTemp, ncMonth + 1); <br> <br>    // Find value associated with month. <br>    hr = HrFindStringValue( <br>            szTempBuffer,       // string <br>            nMonths,            // number values <br>            rgSortedMonth,      // string value pair array <br>            &amp;ulValue);          // value pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    sSystemTime.wMonth = (WORD) ulValue;    // set month value <br> <br>    lpTemp += ncMonth;  // increment string pointer <br> <br>    // Read in year <br>    lstrcpyn(szTempBuffer, lpTemp, ncYear + 1); <br>    sSystemTime.wYear = atoi(szTempBuffer); <br> <br>    // Check year <br>    if ( sSystemTime.wYear == 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br>     <br>    lpTemp += ncYear;   // increment string pointer <br> <br>    // Next character should be a space <br>    if ( *lpTemp != chSpace ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp++;              // skip over space <br> <br>    // read in hours <br>    lstrcpyn(szTempBuffer, lpTemp, ncDuoDigit + 1); <br>    sSystemTime.wHour = atoi(szTempBuffer); <br> <br>    // check hour <br>    if ( sSystemTime.wHour &gt; 23 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>         <br>        goto cleanup; <br>    } <br> <br>    lpTemp += ncDuoDigit;   // increment pointer <br>     <br>    // next character should be a colon <br>    if ( *lpTemp != chColon ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp++;   // skip over colon <br> <br>    // read in minutes <br>    lstrcpyn(szTempBuffer, lpTemp, ncDuoDigit + 1); <br>    sSystemTime.wMinute = atoi(szTempBuffer); <br> <br>    // check minutes <br>    if ( sSystemTime.wMinute &gt; 59 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>         <br>        goto cleanup; <br>    } <br> <br>    lpTemp += ncDuoDigit;   // increment pointer <br>     <br>    // next character should be a colon <br>    if ( *lpTemp != chColon ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp++;   // skip over colon <br>     <br>    // read in seconds <br>    lstrcpyn(szTempBuffer, lpTemp, ncDuoDigit + 1); <br>    sSystemTime.wSecond = atoi(szTempBuffer); <br> <br>    // check seconds <br>    if ( sSystemTime.wSecond &gt; 59 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>         <br>        goto cleanup; <br>    } <br> <br>    lpTemp += ncDuoDigit;   // increment pointer <br>         <br>    // read in UT string <br>    lstrcpyn(szTempBuffer, lpTemp, lstrlen(lpszUniversalTime) + 1); <br>     <br>    // check universal time string <br>    if ( lstrcmp(szTempBuffer, lpszUniversalTime) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>         <br>        goto cleanup; <br>    } <br> <br>    // Convert the system time structure to a file time <br>    // structure. <br>    fSucceeded = SystemTimeToFileTime( <br>                &amp;sSystemTime,       // system time pointer <br>                pFileTime);         // file time pointer <br>                 <br>    if ( fSucceeded == FALSE ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>         <br>        goto cleanup; <br>    } <br> <br>    // we are done <br>                 <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$----HrParsePriorityString---------------------------------------------------- <br>// <br>// DESCRIPTION: Convert a priority string to its associated <br>//              integer value. <br>// <br>// INPUT:       lpPriority  --  priority string <br>//              <br>// OUTPUT:      pulPriority --  pointer to priority value <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT HrParsePriorityString( <br>    IN LPSTR lpPriority,       // Priority string <br>    OUT ULONG * pulPriority)    // priority value pointer <br>{ <br>    HRESULT hr          =   NOERROR; <br>    UINT    iPriority   =   0;      // index into priority array <br> <br>    DEBUGPRIVATE("HrParsePriorityString()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParsePriorityString(lpPriority, pulPriority); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pulPriority = 0;   // initialize <br> <br>    // Find matching priority string <br>    hr = HrFindStringValue( <br>                lpPriority,     // string <br>                nPriorities,    // number of values <br>                rgPriority,   // string value pair array <br>                pulPriority);   // value pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$----HrParseImportanceString---------------------------------------------------- <br>// <br>// DESCRIPTION: Convert an importance string to its associated <br>//              integer value. <br>// <br>// INPUT:       lpImportance  --  importance string <br>//              <br>// OUTPUT:      pulImportance --  pointer to importance value <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT HrParseImportanceString( <br>    IN LPSTR lpImportance,     // Importance string <br>    OUT ULONG * pulImportance)  // importance value pointer <br>{ <br>    HRESULT hr          =   NOERROR; <br>    UINT    iImportance =   0;      // index into importance array <br> <br>    DEBUGPRIVATE("HrParseImportanceString()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParseImportanceString(lpImportance, pulImportance); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    *pulImportance = 0;   // initialize <br> <br>    // Find matching priority string <br>    hr = HrFindStringValue( <br>                lpImportance,       // string <br>                nImportances,       // number of values <br>                rgImportance,     // String value pair array <br>                pulImportance);     // value pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrParseExternalTraceString------------------------------------------------- <br>// <br>// DESCRIPTION: Parse External-Received-By or  <br>//              External-Attempted-By trace string into <br>//              its separate components. <br>// <br>// INPUT:       lpTraceString   --  External-Received/Attempted-By trace string <br>// <br>// OUTPUT:      plAction   --  trace action <br>//              pCountry  --  country name <br>//              pADMDName --  ADMD name <br>//              pPRMDId   --  PRMD identifier <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input <br>//                      E_FAIL otherwise <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT HrParseExternalTraceString( <br>    IN LPSTR lpTraceString,      // trace information string <br>    OUT LONG * plAction,          // trace action pointer <br>    OUT CHAR * pCountry,         // country name <br>    OUT CHAR * pADMDName,        // ADMD name <br>    OUT CHAR * pPRMDId)          // PRMD identifier <br>{ <br>    HRESULT hr      =   NOERROR; <br>    UINT    nChars  =   0;          // length of trace string <br>    LPSTR  lpTemp  =   NULL;       // temporary string pointer <br>    INT     nUnread =   0;          // number of characters not read so far. <br>    UINT    nLength =   0;          // length of current string <br> <br>    // temporary string buffer <br>    CHAR   szTempBuffer[ulMaxOutStringLen] =   {0}; <br> <br>    DEBUGPRIVATE("HrParseExternalTraceString()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParseExternalTraceString( <br>lpTraceString, <br>plAction, <br>pCountry, <br>        pADMDName, <br>pPRMDId); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Initialize parameters <br>    *plAction = 0; <br>    *pCountry = 0; <br>    *pADMDName = 0; <br>    *pPRMDId = 0; <br> <br>    // If we have no trace data, then we are done. <br>    // (This is a valid case.) <br>    if ( lstrcmp(lpTraceString, lpszBlank) == 0 ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    nChars = lstrlen(lpTraceString);    // length of input string <br>    nUnread = nChars;                   // # characters not read yet <br>    lpTemp = lpTraceString;             // string pointer <br> <br>    // Read in PRMD identifier prefix. <br>    nLength = lstrlen(lpszPRMDId);  // length of PRMD ID prefix <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszPRMDId) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Read in PRMD identifier. <br>    hr = HrReadNextString( <br>            lpTemp,         // input string <br>            chForwardSlash,    // terminating/separating character <br>            MAX_PRMD_NAME_SIZ * sizeof(CHAR),  // size of output buffer <br>            pPRMDId);     // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Determine PRMD identifier length <br>    nLength = lstrlen(pPRMDId); <br>    nUnread -= nLength;             // update # character unread <br> <br>    lpTemp += nLength;      // increment string pointer <br> <br>    // Read in ADMD name prefix. <br>    nLength = lstrlen(lpszADMDName);  // length of ADMD name prefix <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); </code></pre>
<p>
</p>
<pre><code><br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszADMDName) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Read in ADMD name <br>    hr = HrReadNextString( <br>            lpTemp,         // input string <br>            chForwardSlash,    // teminating/separating character <br>            MAX_ADMD_NAME_SIZ * sizeof(CHAR),  // size of output buffer <br>            pADMDName);       // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Determine ADMD name length <br>    nLength = lstrlen(pADMDName); <br>    nUnread -= nLength;             // update # character unread <br> <br>    lpTemp += nLength;      // increment string pointer <br> <br>    // Read in country prefix <br>    nLength = lstrlen(lpszCountry);  // length of country <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszCountry) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Read in country name <br>    hr = HrReadNextString( <br>            lpTemp,         // input string <br>            chForwardSlash,    // teminating/separating character <br>            MAX_COUNTRY_NAME_SIZ * sizeof(CHAR),  // size of output buffer <br>            pCountry);       // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Determine country name length <br>    nLength = lstrlen(pCountry); <br>    nUnread -= nLength;             // update # character unread <br> <br>    lpTemp += nLength;      // increment string pointer <br> <br>    // Read in country postfix <br>    nLength = lstrlen(lpszCountryEnd);  // length of country <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszCountryEnd) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Action is currently pointed to by lpTemp. <br>    // Convert the action string to an integer value <br>    hr = HrFindStringValue( <br>                lpTemp,         // string <br>                nActions,       // number of values <br>                rgAction,       // String value pair array <br>                (ULONG *) plAction);      // value pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrParseInternalTraceString------------------------------------------------- <br>// <br>// DESCRIPTION: Parse Internal-Received-By or  <br>//              Internal-Attempted-By trace string into <br>//              its separate components. <br>// <br>// INPUT:       lpTraceString   --  Internal-Received/Attempted-By trace string <br>// <br>// OUTPUT:      plAction  --  trace action <br>//              pCountry  --  country name <br>//              pADMDName --  ADMD name <br>//              pPRMDId   --  PRMD identifier <br>//              pMTAName  --  MTA name <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input <br>//                      E_FAIL otherwise <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT HrParseInternalTraceString( <br>    IN LPTSTR lpTraceString,      // trace information string <br>    OUT LONG * plAction,          // trace action pointer <br>    OUT CHAR * pCountry,          // country name <br>    OUT CHAR * pADMDName,         // ADMD name <br>    OUT CHAR * pPRMDId,           // PRMD identifier <br>    OUT CHAR * pMTAName)          // MTA name <br>{ <br>    HRESULT hr      =   NOERROR; <br>    UINT    nChars  =   0;          // length of trace string <br>    LPTSTR  lpTemp  =   NULL;       // temporary string pointer <br>    INT     nUnread =   0;          // number of characters not read so far. <br>    UINT    nLength =   0;          // length of current string <br> <br>    // temporary string buffer <br>    CHAR    szTempBuffer[ulMaxOutStringLen] =   TEXT(""); <br> <br>    DEBUGPRIVATE("HrParseInternalTraceString()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParseInternalTraceString( <br>lpTraceString, <br>plAction, <br>pCountry, <br>        pADMDName, <br>pPRMDId, <br>pMTAName); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Initialize parameters <br>    *plAction = 0; <br>    *pCountry = 0; <br>    *pADMDName = 0; <br>    *pPRMDId = 0; <br>    *pMTAName = 0; <br> <br>    // If we have no trace data, then we are done. <br>    // (This is a valid case.) <br>    if ( lstrcmp(lpTraceString, lpszBlank) == 0 ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    nChars = lstrlen(lpTraceString);    // length of input string <br>    nUnread = nChars;                   // # characters not read yet <br>    lpTemp = lpTraceString;             // string pointer <br> <br>    // Read in MTA name prefix. <br>    nLength = lstrlen(lpszMTAName);  // length of MTA name prefix <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszMTAName) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Read in MTA name <br>    hr = HrReadNextString( <br>            lpTemp,         // input string <br>            chForwardSlash,    // terminating/separating character <br>            MAX_MTA_NAME_SIZ * sizeof(CHAR),  // size of output buffer <br>            pMTAName);       // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Determine MTA name length <br>    nLength = lstrlen(pMTAName); <br>    nUnread -= nLength;             // update # character unread <br> <br>    lpTemp += nLength;      // increment string pointer <br> <br>    // Read in PRMD identifier prefix. <br>    nLength = lstrlen(lpszPRMDId);  // length of PRMD ID prefix <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszPRMDId) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Read in PRMD identifier. <br>    hr = HrReadNextString( <br>            lpTemp,         // input string <br>            chForwardSlash,    // terminating/separating character <br>            MAX_PRMD_NAME_SIZ * sizeof(CHAR),  // size of output buffer <br>            pPRMDId);     // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Determine PRMD identifier length <br>    nLength = lstrlen(pPRMDId); <br>    nUnread -= nLength;             // update # character unread <br> <br>    lpTemp += nLength;      // increment string pointer <br> <br>    // Read in ADMD name prefix. <br>    nLength = lstrlen(lpszADMDName);  // length of ADMD name prefix <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszADMDName) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Read in ADMD name <br>    hr = HrReadNextString( <br>            lpTemp,         // input string <br>            chForwardSlash,    // teminating/separating character <br>            MAX_ADMD_NAME_SIZ * sizeof(CHAR),  // size of output buffer <br>            pADMDName);       // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Determine ADMD name length <br>    nLength = lstrlen(pADMDName); <br>    nUnread -= nLength;             // update # character unread <br> <br>    lpTemp += nLength;      // increment string pointer <br> <br>    // Read in country prefix <br>    nLength = lstrlen(lpszCountry);  // length of country <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszCountry) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Read in country name <br>    hr = HrReadNextString( <br>            lpTemp,         // input string <br>            chForwardSlash,    // teminating/separating character <br>            MAX_COUNTRY_NAME_SIZ * sizeof(CHAR),  // size of output buffer <br>            pCountry);       // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Determine country name length <br>    nLength = lstrlen(pCountry); <br>    nUnread -= nLength;             // update # character unread <br> <br>    lpTemp += nLength;      // increment string pointer <br> <br>    // Read in country postfix <br>    nLength = lstrlen(lpszCountryEnd);  // length of country <br> <br>    // Check number of characters read. <br>    nUnread -= nLength; <br> <br>    if ( nUnread &lt; 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpyn(szTempBuffer, lpTemp, nLength + 1); <br> <br>    // Check prefix <br>    if ( lstrcmp(szTempBuffer, lpszCountryEnd) != 0 ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lpTemp += nLength;  // increment pointer <br> <br>    // Action is currently pointed to by lpTemp. <br>    // Convert the action string to an integer value <br>    hr = HrFindStringValue( <br>                lpTemp,         // string <br>                nActions,       // number of values <br>                rgAction,       // String value pair array <br>                (ULONG *) plAction);      // value pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$----HrParseAttachmentHeader-------------------------------------------------- <br>// <br>// DESCRIPTION: Parse attachment header data into its file name <br>//              and file size components. <br>// <br>// INPUT:   lpHeader    --  attachment header data string <br>// <br>// OUTPUT:  lppFileName --  attachment file name <br>//          pcb         --  pointer to # of bytes in attachment <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT HrParseAttachmentHeader( <br>    IN LPSTR lpHeader,         // attachment header data string <br>    OUT LPSTR * lppFileName,   // attachment file name <br>    OUT ULONG * pcb)            // pointer to number of bytes in file name <br>{ <br>    HRESULT hr      =   NOERROR; <br>    LPSTR  lpTemp  =   NULL;       // temporary string pointer <br>    ULONG   cbSize  =   0;          // size of file name buffer <br> <br>    DEBUGPRIVATE("HrParseAttachmentHeader()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrParseAttachmentHeader(lpHeader, lppFileName, pcb); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Allocate file name buffer <br>    cbSize = ulMaxOutStringLen * sizeof(CHAR); // size of file name buffer <br>    hr = MAPIAllocateBuffer(cbSize,     // # bytes to allocate <br>                            (LPVOID *) lppFileName); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!IsBadWritePtr(*lppFileName, sizeof(LPSTR)), <br>                "Bad *lppFileName"); <br> <br>    ZeroMemory(*lppFileName, cbSize); // intialize file name <br>    *pcb = 0;             // set number of file bytes to 0. <br> <br>    lpTemp = lpHeader;    // initialize string pointer <br> <br>    // Read in the file name. <br>    hr = HrReadNextString( <br>            lpTemp,             // input string <br>            chColon,            // teminating/separating character <br>            cbSize,             // size of output buffer             <br>            *lppFileName);      // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Skip over file name and colon character <br>    lpTemp += lstrlen(*lppFileName) + 1;    // increment pointer <br> <br>    // Read in the file size. <br>    // File size is currently pointed to by lpTemp. <br>    *pcb = atol(lpTemp); <br> <br>    // We are done. <br> <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        MAPIFREEBUFFER(*lppFileName); <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$----HrEDKDecodeBinaryStreamDataToStream----------------------------------------------- <br>// <br>// DESCRIPTION: Read attachment hexadecimal encoding from input <br>//              stream to attachment. <br>// <br>// INPUT:       cb  --  number of bytes in original binary attachment. <br>//              lpStreamIn  --  input stream pointer <br>//              lpStreamOut --  Output stream pointer <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br> <br>HRESULT HrEDKDecodeBinaryStreamDataToStream( <br>    IN LPSTREAM lpStreamIn, // input stream <br>    IN ULONG cb,            // number of bytes in original binary data <br>    IN LPSTREAM lpStreamOut)// output stream <br>{ <br>    HRESULT     hr          =   NOERROR; <br>    ULONG       iByte       =   0;          // byte index <br>    UINT        nOutput     =   0;          // integer value to write to attachment <br>    UINT        nHigh       =   0;          // 16's place <br>    UINT        nLow        =   0;          // 1's place <br>    ULONG       cbRead      =   0;          // number of bytes read from stream <br> <br>    // temporary buffer size <br>    const UINT  cbTempBuffer    =   nCharsPerEncodedByte * sizeof(CHAR); <br> <br>    // indices of characters in temporary buffer <br>    const UINT  iHigh       =   0;          // high-order hex digit <br>    const UINT  iLow        =   1;          // low-order hex digit <br>    const UINT  iReturn     =   2;          // return or space character <br> <br>    // temporary string buffer <br>    CHAR       szTempBuffer[cbTempBuffer]  =   {0}; <br> <br>    DEBUGPRIVATE("HrEDKDecodeBinaryStreamDataToStream()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrEDKDecodeBinaryStreamDataToStream(lpStreamIn, cb, lpStreamOut); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Read and convert one logical byte encoding from the <br>    // input stream to the output stream. <br>    for ( iByte = 0; iByte &lt; cb; iByte++ ) <br>    { <br>        // read in three bytes at a time from the input stream. <br>        // The first two will be an ASCII representation <br>        // of a hexadecimal number (e.g. FF).   <br>        // The third character will either be a space or <br>        // a return character. <br>        hr = lpStreamIn-&gt;Read( <br>                    szTempBuffer,       // data buffer <br>                    cbTempBuffer,       // # bytes in data buffer <br>                    &amp;cbRead);           // # bytes read. <br> <br>        if ( FAILED(hr) || (cbRead != cbTempBuffer) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Convert two-character ASCII portion of buffer to <br>        // a character to write to the output stream. <br>        nHigh = nAsciiHexToInt( <br>                szTempBuffer[iHigh]);// high-order hexadecimal character <br> <br>        nLow = nAsciiHexToInt(         <br>                szTempBuffer[iLow]);// low-order hexadecimal character <br> <br>        // compute output digit <br>        nOutput = (16 * nHigh) + nLow; <br>                                    <br>        // Write the byte to the output stream <br>        hr = lpStreamOut-&gt;Write( <br>                    (CHAR *) &amp;(nOutput),      // data buffer <br>                    sizeof(CHAR),          // # bytes in buffer <br>                    NULL); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Check for the last pair on the line <br>        if ( szTempBuffer[iReturn] == chReturn) <br>        { <br>            // We have just read the last pair on the line, <br>            // since the third character read in is the  <br>            // return character.  Since the return character <br>            // is followed by a newline character, we should read <br>            // that in now. <br>            hr = lpStreamIn-&gt;Read( <br>                        szTempBuffer,       // input buffer <br>                        sizeof(chNewLine),  // # bytes to read in <br>                        &amp;cbRead); <br> <br>            if ( FAILED(hr) ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>        }   // end if <br>    }   // end for <br> <br>    // commit changes to output stream <br>    // Do we need to do this? <br>    hr = lpStreamOut-&gt;Commit(STGC_DEFAULT); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // we are done. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrEDKParseSubjectPrefix--------------------------------------------------- <br>// <br>// DESCRIPTION: Break a subject into its prefix component &amp; its <br>//              original subject component.  (The prefix is everything <br>//              up to and including the first colon and the first space <br>//              after the colon, if any. <br>// <br>// INPUT:       pszSubject --  subject text <br>// <br>// OUTPUT       ppszPrefix  --  prefix string pointer <br>//              ppszOrigSub --  original subject pointer <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_OUTOFMEMORY if memory propblems, <br>//                          E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT HrEDKParseSubjectPrefix( <br>            IN LPSTR pszSubject,       // subject text <br>            OUT LPSTR * ppszPrefix,    // subject prefix <br>            OUT LPSTR * ppszOrigSub)   // original subject text <br>{ <br>    HRESULT hr          =   NOERROR; <br>    ULONG   cbSubject   =   0;          // # bytes in the subject <br>    CHAR   chCur       =   NULL;       // current character <br>    BOOL    fPrefix     =   FALSE;      // TRUE if a prefix is found <br>    LPSTR  pszPrefix   =   NULL;       // pointer into prefix string <br>    LPSTR  pszOrigSub  =   NULL;       // pointer into original subject <br>    LPSTR  pszCur      =   NULL;       // pointer into subject text <br> <br>    DEBUGPRIVATE("HrEDKParseSubjectPrefix()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrEDKParseSubjectPrefix(pszSubject, ppszPrefix,  <br>                                     ppszOrigSub); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // initialize pointer <br>    *ppszPrefix = NULL; <br>    *ppszOrigSub = NULL; <br> <br>    // allocate memory for output variables <br>    cbSubject = cbStrLen(pszSubject); <br>    hr = MAPIAllocateBuffer( <br>                cbSubject,      // # bytes <br>                (VOID **) ppszPrefix);    // buffer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(ppszPrefix != NULL, "Bad ppszPrefix"); <br>    ASSERTERROR(*ppszPrefix != NULL, "Bad **ppszPrefix"); <br> <br>    hr = MAPIAllocateBuffer( <br>                cbSubject,      // # bytes <br>                (VOID **) ppszOrigSub);   // buffer pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(ppszOrigSub != NULL, "Bad ppszOrigSub"); <br>    ASSERTERROR(*ppszOrigSub != NULL, "Bad *ppszOrigSub"); <br> <br>    // null-terminate strings. <br>    **ppszPrefix = 0; <br>    **ppszOrigSub = 0; <br> <br>    // look for a colon in the subject text <br>    pszCur = pszSubject; <br>    chCur = *pszCur; <br>    pszPrefix = *ppszPrefix; <br>    pszOrigSub = *ppszOrigSub; <br>    while ( chCur != 0 ) <br>    { <br>        if ( chCur == chColon ) <br>        { <br>            // there is a prefix <br>            fPrefix = TRUE; <br> <br>            // copy colon into candidate prefix <br>            *pszPrefix = chCur; <br>            pszPrefix++;        // increment prefix pointer <br> <br>            // Test next character for a space <br>            if ( *(pszCur + 1) == chSpace ) <br>            { <br>                // first space after the colon is part of the prefix <br>                pszCur++;           // increment current pointer <br>                *pszPrefix = chSpace; <br>                pszPrefix++; <br>            } <br>        } <br> <br>        else if ( fPrefix == FALSE ) <br>        { <br>            // copy character into candidate prefix <br>            *pszPrefix = chCur; <br>            pszPrefix++; <br>        } <br> <br>        else // Have already found prefix <br>        { <br>            // copy character into the original subject <br>            *pszOrigSub = chCur; <br>            pszOrigSub++; <br>        } <br> <br>        // advance to next character <br>        pszCur++; <br>        chCur = *pszCur; <br> <br>    }   // end while <br> <br>    // NULL terminate prefix and original subject found <br>    *pszPrefix = 0; <br>    *pszOrigSub = 0; <br> <br>    // handle case where no prefix found <br>    if ( fPrefix == FALSE ) <br>    { <br>        // null out prefix <br>        **ppszPrefix = 0; <br> <br>        // Copy subject into original subject <br>        lstrcpy(*ppszOrigSub, pszSubject); <br> <br>    }   // end if no prefix found <br>                         <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        // deallocate memory <br>        MAPIFREEBUFFER(*ppszOrigSub); <br>        MAPIFREEBUFFER(*ppszPrefix); <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
