<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MBLSAMPL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1895"></a>MBLSAMPL.C</h2>
<pre><code>// --MBLSampl.c----------------------------------------------------------------- <br>// <br>//  Privileged Access to logon and off of any message store. <br>//   <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "edkguid.h" <br>#include "mblsampl.chk" <br> <br>#define TPRINTF(x)          _tprintf(TEXT(x)) <br>#define TPRINTF1(x,y)       _tprintf(TEXT(x),(y)) <br> <br>#define MAX_INPUT_SZ        300  //Max. Terminal Input <br>#define MAX_MESSAGE_HDRS    50   //Max. messages per query <br> <br>// Arguments from command line <br>BOOL    fHelpRequested      = FALSE; <br>LPTSTR  lpszProfileName     = NULL; <br>LPTSTR  lpszPassword        = NULL; <br> <br>// This gets set to a string as it moves through the code.  If we fail before  <br>// interacting with the user then this will contain the reason. <br>LPTSTR  lpszReasonForFailure = TEXT( "ERROR: Unknown\n"); <br> <br>//$--HrInitialize--------------------------------------------------------------- <br>//  Initialize the application by initializing MAPI, Logging on, and opening the <br>//  Exchange message store. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrInitialize(                    // RETURNS: return code <br>    IN  LPTSTR lpszProfileName,     // MAPI profile name <br>    IN  LPTSTR lpszPassword,        // Profile password <br>    OUT LPMAPISESSION *lpplhSession,// ptr to MAPI session handle ptr. <br>    OUT LPMDB  *lppMDB)             // ptr to message store ptr. <br>{ <br>    HRESULT     hr      = E_FAIL; <br>    ULONG       cbeid   = 0;    // count of bytes in entry ID <br>    LPENTRYID   lpeid   = NULL; // Entry ID of Exchange store <br> <br>    DEBUGPRIVATE( "HrInitialize()"); <br> <br>    lpszReasonForFailure = TEXT( "ERROR: HrInitialize parameters are bad.\n");     <br>    hr = CHK_HrInitialize( lpszProfileName, lpszPassword, lpplhSession, lppMDB); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    lpszReasonForFailure = TEXT( "ERROR: Could not initialize MAPI.\n");     <br>    DEBUGACTION( "Initializing MAPI"); <br>    hr = MAPIInitialize( NULL); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>     <br>    lpszReasonForFailure = TEXT( "ERROR: Could not logon using the profile that was given.\n"); <br>    DEBUGACTION( "Logon to MAPI"); <br>    *lpplhSession = NULL; <br>    hr = (HRESULT) MAPILogonEx(  <br>            0,  <br>            lpszProfileName, <br>            lpszPassword, <br>            MAPI_NO_MAIL | MAPI_NEW_SESSION | MAPI_LOGON_UI,  <br>            lpplhSession); <br>     <br>    if( FAILED( hr)) <br>        goto cleanup; <br>    ASSERTERROR( *lpplhSession != NULL, "Null lphSession!" ); <br> <br>    // Open the Exchange message store. <br>    lpszReasonForFailure = TEXT( "ERROR: Could not open the Exchange message store.\n"); <br>    DEBUGACTION( "Opening Exchange Message Store"); <br>    hr = HrOpenExchangePrivateStore( *lpplhSession, lppMDB); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    ASSERTERROR( *lppMDB != NULL, "NULL lppMDB pointer"); <br> <br>lpszReasonForFailure = TEXT( "ERROR: Unknown\n"); <br>    hr = NOERROR; <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpeid); <br>     <br>    if( FAILED( hr)) <br>    { <br>        if( *lpplhSession) <br>        {   // Logoff a MAPI session <br>            MAPICALL((*lpplhSession))-&gt;Logoff( *lpplhSession, 0, 0, 0); <br>            ULRELEASE(*lpplhSession); <br>        } <br>        MAPIUninitialize(); <br>    } <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrShutDown----------------------------------------------------------------- <br>//  Shutdown the application by closing the Exchange message store, logging off,  <br>//  and uninitializing MAPI. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrShutDown(                     // RETURNS: return code <br>    IN OUT LPMAPISESSION *lpplhSession, // ptr to MAPI session handle ptr. <br>    IN OUT LPMDB  *lppMDB)              // ptr to message store ptr. <br>{ <br>    HRESULT hr; <br> <br>    DEBUGPRIVATE( "HrShutDown()"); <br>     <br>    hr = CHK_HrShutDown( lpplhSession, lppMDB); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    ULRELEASE( *lppMDB); <br> <br>    // Logoff a MAPI session <br>    MAPICALL((*lpplhSession))-&gt;Logoff( *lpplhSession, 0, 0, 0); <br>    ULRELEASE(*lpplhSession); <br>    <br>    MAPIUninitialize(); <br> <br>    RETURN( NOERROR); <br>} <br> <br>//$--HrGetMsgList----------------------------------------------------------- <br>//  Returns the next message list (&lt;=cMaxNRows) in a given message table; <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetMsgList( <br>    IN  LPMAPITABLE lpTable,    // ptr.to the contents table <br>    IN  ULONG       cMaxNRows,  // Max.# of rows to return <br>    OUT LPSRowSet   *lppRows )  // ptr.to address variable for SRowSet <br>{ <br>    HRESULT      hr  = NOERROR; <br>         <br>    DEBUGPRIVATE( "HrGetMsgList()" ); <br> <br>    hr = CHK_HrGetMsgList( lpTable, cMaxNRows, lppRows); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Get the next list of messages in the folder <br>    hr = MAPICALL(lpTable)-&gt;QueryRows( lpTable, cMaxNRows, 0L, lppRows ); <br>    if( SUCCEEDED( hr) &amp;&amp; (!(*lppRows) || (*lppRows)-&gt;cRows == 0)) <br>    { <br>        FREEPROWS(*lppRows); <br>        hr = HR_LOG( EDK_E_END_OF_FILE); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrReadMailboxHeaders------------------------------------------------------- <br>//  Reads and displays the subject of the mail messages found in the MDB. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDispMailboxSubjects( <br>    IN LPMDB  lpMDB)                // Message store ptr. <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    unsigned        iMsgIndx            = 0; <br>    unsigned        nCnt                = 0; <br>    ULONG           cbeid               = 0L; <br>    ULONG           ulObjType           = 0L; <br>    LPENTRYID       lpeid               = NULL; <br>    LPMAPIFOLDER    lpInboxFolder       = NULL;     // ptr to Inbox folder <br>    LPMAPITABLE     lpContentsTbl       = NULL;     // ptr to Contents folder table <br>    LPSRowSet       lpInRowSet          = NULL;     // ptr to Inbox rows <br>    LPSPropValue    lpProps             = NULL;     // Ptr to property array. <br> <br>    static const SizedSSortOrderSet(1L,sSortPrioSet) =  <br>        { 1L, 0L, 0L, { PR_CLIENT_SUBMIT_TIME, TABLE_SORT_ASCEND}}; <br> <br>    static const SizedSPropTagArray(2L,sPropColumns) = <br>        { 2L, {PR_SUBJECT, PR_ENTRYID}}; <br> <br>    DEBUGPRIVATE( "HrDispMailboxSubjects()"); <br> <br>    hr = CHK_HrDispMailboxSubjects( lpMDB); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Initialize an inbox folder object. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Find default (inbox) folder. <br>    hr = HrMAPIFindInbox( lpMDB, &amp;cbeid, &amp;lpeid); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    ASSERTERROR ( lpeid != NULL, "NULL lpeid"); <br>     <br>    // Open the default (inbox) folder. <br>    hr = MAPICALL( lpMDB)-&gt;OpenEntry( lpMDB, cbeid, lpeid, NULL, <br>        MAPI_MODIFY|MAPI_DEFERRED_ERRORS, &amp;ulObjType, (LPUNKNOWN*)&amp;lpInboxFolder); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>    if( ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Now that we have a folder we can initialize a contents table <br>// to look through. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Get the contents table for the folder. <br>    hr = MAPICALL( lpInboxFolder)-&gt;GetContentsTable( <br>        lpInboxFolder, MAPI_DEFERRED_ERRORS, &amp;lpContentsTbl); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Set the columns to return. <br>    hr = MAPICALL( lpContentsTbl)-&gt;SetColumns( lpContentsTbl, (LPSPropTagArray) &amp;sPropColumns, 0L); <br>    if(FAILED(hr)) <br>        goto cleanup; <br> <br>    // Sort the table. <br>    hr = MAPICALL( lpContentsTbl)-&gt;SortTable( lpContentsTbl, (LPSSortOrderSet) &amp;sSortPrioSet, 0L); <br>    if(FAILED(hr)) <br>        goto cleanup; <br>     <br>    // Position to the beginning of the contents table. <br>    hr = MAPICALL( lpContentsTbl)-&gt;SeekRow( lpContentsTbl, BOOKMARK_BEGINNING, 0, NULL); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Contents table has been initialize so lets display it. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>     <br>    // Display INBOX subjects until end of table reached. <br>    while( TRUE) <br>    {   // Read a group of message headers from the contents table. <br>        hr = HrGetMsgList( lpContentsTbl, MAX_MESSAGE_HDRS, &amp;lpInRowSet); <br>        if( hr == EDK_E_END_OF_FILE) <br>            break; <br>        if( FAILED( hr)) <br>            goto cleanup;; <br>             <br>        ASSERTERROR( lpInRowSet != NULL, "NULL lpInRowSet!"); <br>         <br>        // Process all messages in the current table. <br>        for( iMsgIndx = 0; iMsgIndx &lt; lpInRowSet-&gt;cRows; ++iMsgIndx ) <br>        {   // Display the subject name. <br>            lpProps = lpInRowSet-&gt;aRow[iMsgIndx].lpProps; <br> <br>            ASSERTERROR( lpProps-&gt;ulPropTag != PR_SUBJECT, "Invalid property returned!"); <br> <br>            if(lpProps-&gt;Value.LPSZ == NULL || *(lpProps-&gt;Value.LPSZ) == 0) <br>                printf( "  SUBJECT: (empty).\n"); <br>            else <br>                printf( "  SUBJECT: %s\n", lpProps-&gt;Value.LPSZ); <br>            nCnt ++; <br>        } <br>  <br>        // Free the current message list structure. <br>        FREEPROWS( lpInRowSet); <br>    } <br>     <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// All done displaying the subjects.  Time to clean up. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    hr = NOERROR; <br> <br>cleanup: <br>    if( hr == MAPI_E_NO_ACCESS) <br>        printf( "  Insufficient access rights.\n"); <br>    else if( nCnt == 0) <br>        printf( "  No messages found in this mailbox.\n"); <br> <br>    ULRELEASE( lpContentsTbl); <br>    ULRELEASE( lpInboxFolder); <br>    MAPIFREEBUFFER( lpeid); <br>     <br>    RETURN( hr); <br>} <br> <br>//$--PrintUsage----------------------------------------------------------------- <br>// Print usage text <br>// ----------------------------------------------------------------------------- <br>static VOID PrintUsage ( <br>    INLPTSTR  lpszAppName ) <br>{ <br>    LPTSTR  baseName = NULL; <br> <br>    DEBUGPRIVATE ("PrintUsage()"); <br> <br>    baseName = strrchr (lpszAppName, '\\'); <br> <br>    if (baseName) <br>        baseName++; <br>    else <br>        baseName = lpszAppName; <br> <br>    printf ("Privileged Access to Message Store Example\n" \ <br>            "\n" \ <br>            "USAGE: %s [/?] profile [password]\n", <br>            baseName); <br> <br>} <br> <br>//$--PrintHelp------------------------------------------------------------------ <br>// Print help text <br>// ----------------------------------------------------------------------------- <br>static VOID PrintHelp ( <br>    INLPTSTR  lpszAppName ) <br>{ <br>    DEBUGPRIVATE ("PrintHelp()"); <br> <br>    PrintUsage (lpszAppName); <br> <br>    printf ("\n" \ <br>            "   /?,/HELP    show help information\n" \ <br>            "   profile     the MAPI profile name for logon\n" \ <br>            "   password    the password associated with the profile\n"); <br>} <br> <br>//$--HrParseCommandLine--------------------------------------------------------- <br>// Simple command line parsing <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParseCommandLine ( <br>    IN  int     argc, <br>    IN  char    **argv ) <br>{ <br>    HRESULT     hr = NOERROR; <br>    LPTSTR      pszArgument = NULL; <br>    int         i = 0; <br>     <br>    DEBUGPRIVATE ("HrParseCommandLine()"); <br> <br>    hr = CHK_main (argc, argv); <br>    if (FAILED(hr)) <br>        RETURN (hr); <br>         <br> <br>    if (argc &lt; 2) { <br>        PrintUsage(argv[0]); <br>        printf ("\nUse /? for help details\n"); <br>        fHelpRequested = TRUE; <br>        goto cleanup; <br>    } <br> <br>    // Scan first for /? or /HELP <br>    for (i = 1; i &lt; argc; i++) <br>    { <br>        pszArgument = argv[i]; <br>        if (*pszArgument == '/' || *pszArgument == '-') <br>        { <br>            pszArgument++; <br>            if (*pszArgument &amp;&amp; (*pszArgument == '?' || <br>                _tcsnicmp (pszArgument, TEXT("HELP"), _tcslen (pszArgument)) == 0)) <br>            { <br>                PrintHelp (argv[0]); <br>                fHelpRequested = TRUE; <br>                goto cleanup; <br>            } <br>             <br>            // We only recognize /? or /HELP <br>            printf ("ERROR: Unknown command flag '/%s'\n", pszArgument); <br>            hr = HR_LOG (E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    if (argc &gt; 3) <br>    { <br>        printf ("ERROR: Too many arguments on command line\n"); <br>        hr = HR_LOG (E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lpszProfileName = argv[1]; <br> <br>    if (argc == 3) <br>        lpszPassword = argv[2]; <br> <br>cleanup: <br>    RETURN (hr); <br>} <br>         <br>//$--main----------------------------------------------------------------------- <br>// Initialize the application, loop on asking user for mailboxes and display  <br>// their subject properties. <br>// ----------------------------------------------------------------------------- <br>int main( int argc, char *argv[]) <br>{ <br>    HRESULT     hr                      = NOERROR; <br>    TCHAR       szMailbox[MAX_INPUT_SZ] = TEXT(""); <br>    TCHAR       szServer[MAX_INPUT_SZ]  = TEXT(""); <br>    LPENTRYID   lpEntryID               = NULL; <br>    LPMDB       lpMDB                   = NULL;     // Message store ptr. <br>    LPMAPISESSION lplhSession           = NULL;     // MAPI session handle ptr. <br>    LPMDB       lpMailboxMDB            = NULL;     // Mailbox message store ptr. <br>    ULONG       cStrLen                 = 0L; <br> <br> <br>    hr = HrParseCommandLine (argc, argv); <br>    if (FAILED(hr) || fHelpRequested) <br>        goto cleanup; <br> <br>    hr = HrInitialize( lpszProfileName, lpszPassword, &amp;lplhSession, &amp;lpMDB); <br>    if( FAILED( hr)) <br>    { <br>        printf( lpszReasonForFailure);         <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Loop until terminated by user. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    while( TRUE) <br>    { <br>        TCHAR *pNewLine; <br> <br>        printf( "\n---------------------------------------------------------------------------\n" <br>                "Enter the name of the SERVER that contains the mail box\n" <br>                "or EXIT to terminate.\n" <br>                "EXAMPLE: /O=&lt;Organization&gt;/OU=&lt;Site&gt;/CN=Configuration/CN=Servers/CN=&lt;ServerName&gt;\n" <br>                ": "); <br>         <br>        // Get next address.  EOF = terminate. <br>        if( _fgetts( szServer, MAX_INPUT_SZ, stdin) == NULL) <br>            break; <br> <br>        // Trim the trailing newline ('\n'). <br>        pNewLine = _tcschr( szServer, '\n'); <br>        if( pNewLine != NULL) <br>            *pNewLine = 0; <br>         <br>        //  Check for exit. <br>        if( _tcsicmp( szServer, TEXT( "EXIT")) == 0) <br>            break; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>        printf( "\n\n" <br>                "Enter the name of the mail box to access\n" <br>                "or EXIT to terminate.\n" <br>                "EXAMPLE: /O=&lt;Organization&gt;/OU=&lt;Site&gt;/CN=Recipients/CN=&lt;MailboxName&gt;\n" <br>                ": "); <br>         <br>        // Get next address.  EOF = terminate. <br>        if( _fgetts( szMailbox, MAX_INPUT_SZ, stdin) == NULL) <br>            break; <br>             <br>        // Trim the trailing newline ('\n'). <br>        pNewLine = _tcschr( szMailbox, '\n'); <br>        if( pNewLine != NULL) <br>            *pNewLine = 0; <br>         <br>        //  Check for exit. <br>        if( _tcsicmp( szMailbox, TEXT( "EXIT")) == 0) <br>            break; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>        // Change Server DN to Message Store DN by adding next container in heirarchy. <br>        // Don't need to do this if '/cn=' has already been supplied. <br>          <br>        cStrLen = _tcslen( szServer); <br>     <br>        if( cStrLen &gt;= _tcslen(TEXT("/cn=NULL")) &amp;&amp; <br>            ( _tcsicmp( &amp;szServer[cStrLen - _tcslen(TEXT("/cn="))], TEXT("/cn=")) != 0 &amp;&amp; <br>              _tcsicmp( &amp;szServer[cStrLen - _tcslen(TEXT("/cn=NULL"))], TEXT("/cn=NULL")) != 0)) <br>        { <br>            _tcsncat( szServer, TEXT("/cn=Microsoft Private MDB"), MAX_INPUT_SZ - cStrLen); <br>        } <br>         <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>        // Logon to the mailbox specified by the user. <br>        hr = HrMailboxLogon( lplhSession, lpMDB, szServer, szMailbox, &amp;lpMailboxMDB); <br>        if( FAILED( hr)) <br>        { <br>            switch( hr) <br>            { <br>                case EDK_E_NOT_FOUND: <br>                    printf( "\nYou do not have permission to access this server\n" <br>                            "or the expected registry key does not exist.\n"); <br>                    break; <br> <br>                default: <br>                    printf( "\nFailed to logon to the mailbox:\n" <br>                            "  Server:  %s\n" <br>                            "  Mailbox: %s\n", szServer, szMailbox); <br>            } <br>        } <br>        else             <br>        {   // Display the subject property of the messages found in the mailbox. <br>            hr = HrDispMailboxSubjects( lpMailboxMDB); <br>            if( FAILED( hr)); <br> <br>            // Logoff the mailbox. <br>            hr = HrMailboxLogoff( &amp;lpMailboxMDB); <br>            if( FAILED( hr)); <br>        } <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Clean up <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -                  <br> <br>    // Terminate the MAPI session properly. <br>    hr = HrShutDown( &amp;lplhSession, &amp;lpMDB); <br>    if( FAILED( hr)); <br> <br>cleanup: <br>    // return exit code <br>    return _nEcFromHr(hr) ; <br>} <br> <br>// ----------------------------------------------------------------------------- <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
