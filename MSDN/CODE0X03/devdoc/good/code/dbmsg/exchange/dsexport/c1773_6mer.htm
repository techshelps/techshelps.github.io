<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSEXPORT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1773"></a>DSEXPORT.C</h2>
<pre><code>// --dsexport.c----------------------------------------------------------------- <br>// <br>//  Directory service export sample. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "dapi.h" <br> <br>// <br>// Names of Command Line Arguments <br>// <br> <br>#define ARG_FILE"FILE" <br>#define ARG_BASEPOINT"BASEPOINT" <br>#define ARG_CONTAINER"CONTAINER" <br>#define ARG_CLASSES "CLASSES" <br>#define ARG_DSA"DSA" <br>#define ARG_HELP1"?" <br>#define ARG_HELP2"HELP" <br>#define ARG_SERVER"SERVER" <br>#define ARG_ALL_RECIPIENTS"ALL_RECIPIENTS" <br>#define ARG_ONLY_BASEPOINT"ONLY_BASEPOINT" <br>#define ARG_DIST_LIST"DIST_LIST" <br>#define ARG_MAILBOX"MAILBOX" <br>#define ARG_REMOTE_ADDRESS"REMOTE_ADDRESS" <br>#define ARG_ALL_CLASSES"ALL_CLASSES" <br>#define ARG_HIDDEN"HIDDEN" <br>#define ARG_SUBTREE             "SUBTREE" <br> <br>// <br>// Table of Command Line Switches for _HrExpandCommandLineArgument() <br>// <br> <br>static char * rgpszArgArray[] = { <br>ARG_FILE, <br>ARG_BASEPOINT, <br>ARG_CONTAINER, <br>    ARG_CLASSES, <br>ARG_DSA, <br>ARG_HELP1, <br>ARG_HELP2, <br>ARG_SERVER, <br>ARG_ALL_RECIPIENTS, <br>ARG_ONLY_BASEPOINT, <br>ARG_DIST_LIST, <br>ARG_MAILBOX, <br>ARG_REMOTE_ADDRESS, <br>    ARG_ALL_CLASSES, <br>    ARG_HIDDEN, <br>    ARG_SUBTREE, <br>}; <br> <br>// <br>// Variables For Command Line Arguments <br>// <br> <br>char    szExportFile[MAX_PATH+1]= {0}; <br>char    szDsaName[MAX_PATH+1]= {0}; <br>char    szServerName[MAX_PATH+1]= {0}; <br>char    szBasePoint[MAX_PATH+1]    = {0}; <br>char    szParentContainer[MAX_PATH+1]= {0}; <br>DWORD   ControlFlags= 0; <br>ULONG   cClasses                        = 0; <br>LPSTR*  lppszClasses                    = NULL; <br> <br>// <br>// Other Variables <br>// <br> <br>BOOL fDisplayedHelp    = FALSE; <br>DWORD cLoggedErrors    = 0; <br> <br>// <br>// Function Declarations <br>// <br> <br>static HRESULT HrParseCommandLine( <br>    IN int argc, <br>    IN char *argv[]); <br> <br>static VOID ShowUsage( <br>void); <br> <br>static VOID ShowHelp( <br>void); <br> <br>static HRESULT HrDoBatchExport( <br>void); <br> <br>// <br>// Functions <br>// <br> <br>//$--main----------------------------------------------------------------------- <br>//  Main function that performs directory export. <br>// ----------------------------------------------------------------------------- <br>int main(// RETURNS: exit code <br>IN int argc,// number of arguments on command line <br>IN char *argv[])// array of command line arguments <br>{ <br>    HRESULT hr    = NOERROR; <br>    BOOL    IsMAPIInit  = FALSE; <br> <br>DEBUGPUBLIC("main()\n"); <br> <br>    printf( "\n" ); <br> <br>    hr = MAPIInitialize(NULL); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    IsMAPIInit = TRUE; <br> <br>    // Get export parameters from the command line. <br> <br>    hr = HrParseCommandLine(argc, argv); <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Do batch export <br> <br>    hr = HrDoBatchExport(); <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(IsMAPIInit == TRUE) <br>    { <br>        MAPIUninitialize(); <br>    } <br> <br>// Successful completion. <br> <br>if (fDisplayedHelp) <br>{ <br>hr = NOERROR; <br>} <br>else if (SUCCEEDED(hr)) <br>{ <br>fprintf(stderr, "Export operation completed successfully.\n"); <br>} <br> <br>// Error completion. <br> <br>else if (cLoggedErrors == 1) <br>{ <br>fprintf(stderr, "ERROR: 1 error written to NT Event Log.\n"); <br>} <br>else if (cLoggedErrors &gt; 1) <br>{ <br>fprintf(stderr, "ERROR: %d errors written to NT Event Log.\n",  <br>cLoggedErrors); <br>} <br> <br>    MAPIFREEBUFFER(lppszClasses); <br> <br>return _nEcFromHr(hr); <br>} <br> <br>//$--HrParseCommandLine--------------------------------------------------------- <br>//  Read export configuration from command line. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParseCommandLine(// RETURNS: HRESULT <br>    IN int argc,// number of arguments on command line <br>    IN char *argv[])// array of command line arguments <br>{ <br>    HRESULThr= NOERROR; <br>    HRESULThrT= NOERROR; <br>char *pszArgument= NULL; <br>char *pszValue= NULL; <br>    inti= 0; <br>    LPTSTR      lpszSep         = "%\0"; <br> <br>DEBUGPRIVATE("HrParseCommandLine()\n"); <br> <br>// If there are no command line arguments then show a usage message. <br> <br>if (argc &lt; 2) <br>{ <br>ShowUsage(); <br>hr = E_FAIL; <br>goto cleanup; <br>} <br> <br>// Do an initial check for /? or /HELP.  If found, show a help message  <br>// and don't do any other parsing. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br>hr = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>&amp;pszArgument, &amp;pszValue); <br> <br>if (SUCCEEDED(hr) &amp;&amp; pszArgument &amp;&amp;  <br>(!_stricmp(pszArgument,ARG_HELP1) ||  <br>!_stricmp(pszArgument,ARG_HELP2))) <br>{ <br>ShowHelp(); <br>hr = E_FAIL; <br>goto cleanup; <br>} <br>} <br> <br>// Loop through and parse all the command line arguments. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br>hrT = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>&amp;pszArgument, &amp;pszValue); <br> <br>if (FAILED(hrT)) <br>{ <br>hr = hrT; <br>if (hr == EDK_E_NOT_FOUND) <br>{ <br>fprintf(stderr, "ERROR: unknown command line flag: %s\n",  <br>argv[i]); <br>continue; <br>} <br>else <br>{ <br>fprintf(stderr, "ERROR: unable to parse command line.\n"); <br>goto cleanup; <br>} <br>} <br> <br>// Parse flag arguments that don't take a value. <br> <br>if (pszArgument != NULL &amp;&amp; pszValue == NULL) <br>{ <br>// ALL_RECIPIENTS <br> <br>if (!_stricmp(pszArgument,ARG_ALL_RECIPIENTS)) <br>{ <br>ControlFlags |= DAPI_EXPORT_RECIPIENTS; <br>} <br> <br>// ONLY_BASEPOINT <br> <br>else if (!_stricmp(pszArgument,ARG_ONLY_BASEPOINT)) <br>{ <br>ControlFlags |= DAPI_EXPORT_BASEPOINT_ONLY; <br>} <br> <br>// DIST_LIST <br> <br>else if (!_stricmp(pszArgument,ARG_DIST_LIST)) <br>{ <br>ControlFlags |= DAPI_EXPORT_DIST_LIST; <br>} <br> <br>// MAILBOX <br> <br>else if (!_stricmp(pszArgument,ARG_MAILBOX)) <br>{ <br>ControlFlags |= DAPI_EXPORT_MAILBOX; <br>} <br> <br>// REMOTE_ADDRESS <br> <br>else if (!_stricmp(pszArgument,ARG_REMOTE_ADDRESS)) <br>{ <br>ControlFlags |= DAPI_EXPORT_CUSTOM; <br>} <br> <br>// ALL_CLASSES <br> <br>else if (!_stricmp(pszArgument,ARG_ALL_CLASSES)) <br>{ <br>ControlFlags |= DAPI_EXPORT_ALL_CLASSES; <br>} <br> <br>// HIDDEN <br> <br>else if (!_stricmp(pszArgument,ARG_HIDDEN)) <br>{ <br>ControlFlags |= DAPI_EXPORT_HIDDEN; <br>} <br> <br>// SUBTREE <br> <br>else if (!_stricmp(pszArgument,ARG_SUBTREE)) <br>{ <br>ControlFlags |= DAPI_EXPORT_SUBTREE; <br>} <br> <br>// Other flag (must take a value). <br> <br>else <br>{ <br>fprintf(stderr, "ERROR: flag /%s requires a value\n",  <br>pszArgument); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Parse flag arguments that take a value. <br> <br>else if (pszArgument != NULL &amp;&amp; pszValue != NULL) <br>{ <br>if (!_stricmp(pszArgument,ARG_DSA)) <br>{ <br>strncpy(szDsaName, pszValue, MAX_PATH); <br>                szDsaName[MAX_PATH] = 0; <br>} <br>else if (!_stricmp(pszArgument,ARG_SERVER)) <br>{ <br>strncpy(szServerName, pszValue, MAX_PATH); <br>                szServerName[MAX_PATH] = 0; <br>} <br>else if (!_stricmp(pszArgument,ARG_FILE)) <br>{ <br>strncpy(szExportFile, pszValue, MAX_PATH); <br>                szExportFile[MAX_PATH] = 0; <br>} <br>else if (!_stricmp(pszArgument,ARG_BASEPOINT)) <br>{ <br>strncpy(szBasePoint, pszValue, MAX_PATH); <br>                szBasePoint[MAX_PATH] = 0; <br>} <br>else if (!_stricmp(pszArgument,ARG_CONTAINER)) <br>{ <br>strncpy(szParentContainer, pszValue, MAX_PATH); <br>                szParentContainer[MAX_PATH] = 0; <br>} <br>else if (!_stricmp(pszArgument,ARG_CLASSES)) <br>{ <br> <br>                hr = HrStrTokAll( <br>                    pszValue, <br>                    lpszSep, <br>                    &amp;cClasses, <br>                    &amp;lppszClasses); <br> <br>                if(FAILED(hr)) <br>                { <br>    fprintf(stderr, "ERROR: syntax error in /%s\n",  <br>    pszArgument); <br>                    goto cleanup; <br>                } <br>            } <br> <br>// Other flag (must not take a value). <br> <br>else <br>{ <br>fprintf(stderr, "ERROR: flag /%s does not take a value\n",  <br>pszArgument); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Catch unknown arguments. <br> <br>else <br>{ <br>fprintf(stderr, "ERROR: unknown argument %s\n", argv[i]); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Make sure we have all the info we need. <br> <br>if (SUCCEEDED(hr)) <br>{ <br>if (*szDsaName == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify /%s\n", ARG_DSA); <br>hr = HR_LOG(E_FAIL); <br>} <br>if (*szExportFile == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify /%s\n", ARG_FILE); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br>//$--ShowUsage------------------------------------------------------------------ <br>//  Show usage information. <br>// ----------------------------------------------------------------------------- <br>static VOID ShowUsage(void)// RETURNS: nothing <br>{ <br>DEBUGPRIVATE("ShowUsage()\n"); <br> <br>    printf("USAGE: DSEXPORT [Flags]\n\n"); <br>printf("  [Flags]        Enter DSEXPORT /? for details\n"); <br> <br>fDisplayedHelp = TRUE; <br>} <br> <br>//$--ShowHelp------------------------------------------------------------------- <br>//  Show help information. <br>// ----------------------------------------------------------------------------- <br>static VOID ShowHelp(void)// RETURNS: nothing <br>{ <br>DEBUGPRIVATE("ShowHelp()\n"); <br> <br>printf("Directory Service Export sample.\n\n"); <br>printf("USAGE: DSEXPORT [Flags]\n\n"); <br>printf("  /FILE=               Name of export file\n"); <br>printf("  /SERVER=             Exchange server name\n"); <br>printf("  /DSA=                Directory Service Agent name\n"); <br>printf("  /BASEPOINT=          DN of Directory basepoint object\n"); <br>printf("  /CONTAINER=          RDN of Directory container beneath " <br>"BASEPOINT\n"); <br>printf("  /CLASSES=            Object classes (separated by '%%')\n"); <br>printf("  /HELP or /?          Display help screen\n"); <br>printf("  /ONLY_BASEPOINT      Export only the BASEPOINT object\n"); <br>printf("  /ALL_RECIPIENTS      Export all recipients\n"); <br>printf("  /DIST_LIST           Export distribution list recipients\n"); <br>printf("  /MAILBOX             Export mailbox recipients\n"); <br>printf("  /REMOTE_ADDRESS      Export remote address recipients\n"); <br>printf("  /ALL_CLASSES         Export all classes\n"); <br>printf("  /HIDDEN              Export hidden objects of the selected " <br>    "classes\n"); <br>printf("  /SUBTREE             Export subtree\n"); <br> <br>fDisplayedHelp = TRUE; <br>} <br> <br>//$--DoBatchExport-------------------------------------------------------------- <br>//  Do batch export of directory objects. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDoBatchExport(void)// RETURNS: HRESULT <br>{ <br>HRESULT         hr              = NOERROR; <br>BEXPORT_PARMS BexportParms    = {0}; <br>LPBEXPORT_PARMS lpBexportParms  = {0}; <br> <br>DEBUGPRIVATE("HrDoBatchExport()\n"); <br> <br>lpBexportParms = &amp;BexportParms; <br>lpBexportParms-&gt;dwDAPISignature = DAPI_SIGNATURE; <br>lpBexportParms-&gt;dwFlags = ControlFlags | DAPI_EVENT_ALL; <br>lpBexportParms-&gt;pszExportFile = szExportFile; <br>lpBexportParms-&gt;pszBasePoint = szBasePoint; <br> <br>    if (*szParentContainer) <br>    { <br>    lpBexportParms-&gt;pszContainer = szParentContainer; <br>    } <br> <br>    if (*szDsaName) <br>    { <br>    lpBexportParms-&gt;pszDSAName = szDsaName; <br>    } <br> <br>    if (*szServerName) <br>    { <br>    lpBexportParms-&gt;pszHomeServer = szServerName; <br>    } <br> <br>    if(lppszClasses != NULL) <br>    { <br>    lpBexportParms-&gt;rgpszClasses = lppszClasses; <br>    } <br> <br>lpBexportParms-&gt;chColSep = DAPI_DEFAULT_DELIM; <br>lpBexportParms-&gt;chQuote = DAPI_DEFAULT_QUOTE; <br>lpBexportParms-&gt;chMVSep = DAPI_DEFAULT_MV_SEP; <br> <br>cLoggedErrors = BatchExport(lpBexportParms); <br>if (cLoggedErrors) <br>{ <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>    RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
