<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FORMMAPI.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2008"></a>FORMMAPI.CPP</h2>
<pre><code>// --formmapi.cpp------------------------------------------------------------- <br>// <br>//    Implementation of the FRM class MAPI methods <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// --------------------------------------------------------------------------- <br> <br>#include "stdafx.h" <br>#include "tool.h" <br> <br>#include "formdata.h" <br>#include "form.h" <br> <br>#ifdef _DEBUG <br>#undef THIS_FILE <br>static char BASED_CODE THIS_FILE[] = __FILE__; <br>#endif <br> <br>#define new DEBUG_NEW <br> <br>//$--FRM::DoVerb-------------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Performs the specified verb on the message. <br>// <br>//  Returns: <br>//      HRESULT             S_OK, or error value. <br>//---------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::DoVerb( <br>         LONG iVerb,                // What to do. <br>         LPMAPIVIEWCONTEXT pmvc,    // Our view context. <br>         ULONG ulhwndParent,        // Our parent window. <br>         LPCRECT prcPosRect)        // Where we should display ourselves given <br>                                    // a choice. <br>{ <br>    ASSERT(m_cRef &gt; 0); <br> <br>    switch (iVerb) <br>    { <br>    default: <br>    case OLEIVERB_HIDE: <br>    case OLEIVERB_DISCARDUNDOSTATE: <br>        return ResultFromScode(E_NOTIMPL); <br> <br>    case OLEIVERB_UIACTIVATE: <br>    case OLEIVERB_INPLACEACTIVATE: <br>        if (iVerb &lt; 0) <br>            return ResultFromScode(E_NOTIMPL); <br>        return ResultFromScode(OLEOBJ_S_INVALIDVERB); <br> <br>    case OLEIVERB_SHOW: <br>        ShowCurrentMessage(ulhwndParent); <br>        return NOERROR; <br> <br>    case OLEIVERB_OPEN: <br>    case OLEIVERB_PRIMARY: <br>        if (m_fSentMessage) <br>{ <br>            LaunchReplyMessage(ulhwndParent); <br>} <br>        else <br>{ <br>ShowCurrentMessage(ulhwndParent); <br>} <br> <br>        return NOERROR; <br>    } <br>} <br> <br> <br>//$--FRM::ShutdownForm-------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Closes down any UI associated with the form. <br>// <br>//  Arguments: <br>//      DWORD                <br>// <br>//  Returns: <br>//      HRESULT             S_OK, or error value. <br>//---------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::ShutdownForm( <br>         DWORD dwSaveOptions) // One of OLECLOSE_SAVEIFDIRTY, OLECLOSE_NOSAVE, <br>                              // or OLECLOSE_PROMPTSAVE. <br>{ <br>    ASSERT(m_cRef &gt; 0); <br> <br>    HRESULT hr = NOERROR; <br> <br>    // ----- don't close if we're in a modal dialog <br>    //       especially if the modal dialog occurs in a remoted interface <br>if (!AfxGetMainWnd()-&gt;IsWindowEnabled()) <br>        return ResultFromScode(E_ABORT); <br> <br>    // ----- be kind, and save ourself   <br>    switch (dwSaveOptions) <br>    { <br>        case OLECLOSE_NOSAVE: <br>            break; <br> <br>        case OLECLOSE_SAVEIFDIRTY: <br>            if (m_fDirty) <br>                hr = m_pMessageSite-&gt;SaveMessage(); <br>            break; <br> <br>        default: <br>        case OLECLOSE_PROMPTSAVE: <br>            if (m_fDirty) <br>{ <br>                if (IDYES == AfxMessageBox("Save changes?", MB_YESNO)) <br>             { <br>                    hr = m_pMessageSite-&gt;SaveMessage(); <br>} <br>} <br>            break; <br> <br>    } <br> <br>    if (NOERROR == hr) <br>    { <br>        // ----- let everyone know we're shutting down <br>        ADVISE(OnShutdown); <br> <br>        // ----- Release everything we have remembered thus far <br>        Forget(); <br> <br>        // ----- make sure everyone has Unadvised <br>        ASSERT(0==m_afAdvisee[0]); <br>        ASSERT(0==m_afAdvisee[1]); <br>        ASSERT(0==m_afAdvisee[2]); <br>        ASSERT(0==m_afAdvisee[3]); <br> <br>        // ----- post a quit message to our UI <br>        AfxGetMainWnd()-&gt;SendMessage(WM_CLOSE); <br>    } <br> <br>    return hr; <br>} <br> <br>//$--FRM::SetViewContext------------------------------------------------------ <br>// <br>//  Puspose: <br>//      View context is used for next and previous behavior <br>//      The tools form does not do next and previous because <br>//      there is not a standard read note.  It is always in  <br>//      reply mode. <br>//---------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::SetViewContext(LPMAPIVIEWCONTEXT pViewContextNew) <br>{ <br>    ASSERT(m_cRef &gt; 0); <br>    ASSERT(pViewContextNew); <br> <br>    return NOERROR; <br>} <br> <br>//$--FRM::GetViewContext------------------------------------------------------ <br>// <br>// Purpose: <br>//      Get the view context <br>// <br>//  Returns: <br>//      HRESULT <br>//---------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::GetViewContext(LPMAPIVIEWCONTEXT FAR * ppViewContext) <br>{ <br>    ASSERT(m_cRef &gt; 0,); <br>    ASSERT(ppViewContext); <br> <br>    if (ppViewContext) <br>        *ppViewContext = NULL;      // not supported <br> <br>    return NOERROR; <br>} <br> <br>//$--FRM::Advise-------------------------------------------------------------- <br>// <br>//  Purpose: <br>// <br>//  Returns: <br>//      HRESULT <br>//---------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::Advise(LPMAPIVIEWADVISESINK pAdvise, ULONG FAR * pdwStatus) <br>{ <br>    LONG i = 0; <br> <br>    ASSERT(m_cRef &gt; 0); <br>    ASSERT(pdwStatus); <br>    ASSERT(pAdvise); <br> <br>    // ----- remember who to advise     <br>    for (i=0; i&lt;MAX_ADVISE; i++) <br>    { <br>        if (!m_afAdvisee[i]) <br>        { <br>            m_aAdvisePtrs[i] = pAdvise; <br>            m_afAdvisee[i] = 1; <br>            *pdwStatus = i + 1;     // ulConnection of zero is not valid <br>            pAdvise-&gt;AddRef(); <br>            return NOERROR; <br>        } <br>    } <br> <br>    // ----- bad news <br>    ASSERT(FALSE); <br>    return ResultFromScode(E_FAIL); <br>} <br> <br>//$--FRM::Unadvise------------------------------------------------------------ <br>// <br>//  Purpose: <br>// <br>//  Returns: <br>//      HRESULT <br>//---------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::Unadvise(ULONG ulConnection) <br>{ <br>    ASSERT(m_cRef &gt; 0); <br>    ASSERT(ulConnection &lt; MAX_ADVISE &amp;&amp; ulConnection &gt;= 0); <br>    ASSERT(ulConnection); <br> <br>    // ----- forget about advising this guy <br>    --ulConnection; // remember, we added one in advise <br>     <br>    ASSERT(m_afAdvisee[(int) ulConnection]); <br>    m_afAdvisee[(int) ulConnection] = 0; <br>    m_aAdvisePtrs[(int) ulConnection]-&gt;Release(); <br>     <br>    return NOERROR; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
