<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FORMPRST.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2009"></a>FORMPRST.CPP</h2>
<pre><code>// --formprst.cpp------------------------------------------------------------- <br>// <br>//   Implementation of the FRM class IPersistMessage methods <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// --------------------------------------------------------------------------- <br> <br>#include "stdafx.h" <br>#include "tool.h" <br> <br>#ifdef _DEBUG <br>#undef THIS_FILE <br>static char BASED_CODE THIS_FILE[] = __FILE__; <br>#endif <br> <br>#define new DEBUG_NEW <br> <br>#include "formdata.h" <br>#include "form.h" <br>#include "tooldoc.h" <br>#include "toolform.h" <br> <br>//$--FRM::GetLastError-------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Get the last error <br>// <br>//  Returns: <br>//      HRESULT             NOERROR always. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::GetLastError(HRESULT hResult, ULONG ulFlags, LPMAPIERROR FAR * lppMAPIError) <br>{ <br>    ASSERT(m_cRef &gt; 0); <br> <br>    if (lppMAPIError) <br>        *lppMAPIError = NULL; <br>    return NOERROR; <br>} <br> <br>//$--FRM::GetClassID---------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Get the class ID associated with this message. <br>// <br>//  Returns: <br>//      HRESULT             NOERROR always. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::GetClassID(LPCLSID pclsid) // Where to put the class ID. <br>{ <br>    ASSERT(m_cRef &gt; 0); <br> <br>    // The form only plays with things of its own class ID, so <br>    // this is easy; it's more complicated if code supports multiple <br>    // classes, or can do "treat as" operations <br>    if (pclsid) <br>        *pclsid = m_clsid; <br> <br>    return NOERROR; <br>} <br> <br> <br>//$--FRM::IsDirty------------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Returns whether the object has changed since the last save <br>// <br>//  Returns: <br>//      HRESULT             S_OK if dirty, S_FALSE if not dirty. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::IsDirty(void) <br>{ <br>    ASSERT(m_cRef &gt; 0); <br>     <br>    return m_fDirty ? NOERROR : ResultFromScode(S_FALSE); <br>} <br> <br> <br>//$--FRM::InitNew------------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Create a new message of our message class in the provided pmsg. <br>// <br>//  Returns: <br>//      HRESULT             S_OK, or error value. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::InitNew(LPMAPIMESSAGESITE pmsite, <br>             LPMESSAGE pmsg)            // Message to create the new form in. <br>{ <br>    HRESULT             hr              = NOERROR; <br>    SPropValue          prop            = {0}; <br> <br>    ASSERT(m_cRef &gt; 0); <br> <br>    // ----- Remember our pointers and such <br>    hr = Remember(pmsite,pmsg); <br>    if (FAILED(hr)) <br>    { <br>        return hr; <br>    } <br> <br>    // ----- set our message class <br>    prop.ulPropTag  = PR_MESSAGE_CLASS; <br>    prop.Value.LPSZ = TEXT(kszFormsMessageName); <br>    hr = m_pMessage-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>    { <br>        return hr; <br>    } <br> <br>    // ----- remind ourselves that this new message could not have been sent <br>    m_fSentMessage = 0; <br>    <br>    ADVISE(OnNewMessage); <br>    return hr; <br>} <br> <br> <br>//$--FRM::Load---------------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Attaches our object to the provided pmsg. <br>// <br>//  Returns: <br>//      HRESULT             S_OK, or error value. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::Load(LPMAPIMESSAGESITE pmsite, <br>          LPMESSAGE pmsg,           // Our message to remember <br>          ULONG ulMessageStatus, <br>          ULONG ulMessageFlags) <br>{ <br>    ULONG cProps = 0; <br>    const ULONG ctagMax = 10; <br>    char rgchTaga[sizeof(SPropTagArray) + (ctagMax * sizeof(ULONG))] = {0}; <br>    LPSPropTagArray ptaga = (LPSPropTagArray) rgchTaga; <br>    LPSPropValue rgval = NULL; <br>    LPSPropValue pval = NULL; <br>    HRESULT         hr=S_OK; <br> <br>    ASSERT(m_cRef &gt; 0); <br> <br>    // ----- Remember our pointers and such <br>    hr = Remember(pmsite,pmsg); <br>    if (FAILED(hr)) <br>    { <br>        return hr; <br>    } <br> <br>    // ----- If this message has been sent we would like to remember that <br>    m_fSentMessage = !( ulMessageFlags &amp; MSGFLAG_UNSENT); <br>    TRACE1("fSentMessage = %d",(int) m_fSentMessage); <br> <br>    ptaga-&gt;cValues = 0; <br>    ptaga-&gt;aulPropTag[ptaga-&gt;cValues++] = PR_SUBJECT; <br>    ptaga-&gt;aulPropTag[ptaga-&gt;cValues++] = PR_BODY; <br>    ptaga-&gt;aulPropTag[ptaga-&gt;cValues++] = PR_FORMDATA;// Form Specific <br>  <br>    hr = pmsg-&gt;GetProps(ptaga, 0, &amp;cProps, &amp;rgval); <br>    if (FAILED(hr) ) <br>    { <br>        return hr; <br>    } <br>    ASSERT(ptaga-&gt;cValues &lt;= ctagMax); <br>    ASSERT(cProps == ptaga-&gt;cValues); <br>    ASSERT(NULL != rgval); <br> <br>    // ----- set properties to variables <br> <br>    // point pval at form-specific data <br>    pval = rgval + 2; <br> <br>    POSITION pos = theApp.m_pDocTemplate-&gt;GetFirstDocPosition(); <br>    ASSERT (pos); <br> <br>    CToolDoc * pDoc = (CToolDoc*)theApp.m_pDocTemplate-&gt;GetNextDoc(pos); <br>     <br>    POSITION posVW = pDoc-&gt;GetFirstViewPosition(); <br>    ASSERT (posVW); <br> <br>    CToolForm * pView = (CToolForm*) pDoc-&gt;GetNextView (posVW); <br> <br>    if (NULL != pView) <br>{ <br>    if (pval-&gt;Value.bin.cb == sizeof(pDoc-&gt;m_theFormData))  // If the data is valid <br>        { <br>        memcpy(&amp;(pDoc-&gt;m_theFormData), pval-&gt;Value.bin.lpb,(int) pval-&gt;Value.bin.cb); <br>    pval++; // CALLERSNAME <br>} <br> <br>pView-&gt;PutDataIntoWindow(); <br>} <br> <br>    ASSERT(rgval); <br>    (*lpfnMAPIFreeBuffer)(rgval); <br>    ADVISE(OnNewMessage); <br> <br>    return hr; <br>} <br> <br> <br>//$--FRM::Save---------------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Writes out our information to the provided pmsg. Does NOT commit <br>//      changes; this is the responsibility of the caller. Puts the form <br>//      into no-scribble mode until SaveCompleted is called. <br>// <br>//  Returns: <br>//      HRESULT             S_OK, or error value. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::Save( <br>         LPMESSAGE pmsg,    // Message to write our changes to. <br>         ULONG fSameAsLoad) // TRUE if this is our home message, FALSE if <br>                            // this is a different message. <br>{ <br>    SPropValue prop = {0}; <br>    HRESULT hr = NOERROR; <br> <br>    ASSERT(m_cRef &gt; 0); <br>    ASSERT(m_pMessage); <br> <br>    // ----- If this is the same pmsg as we got back when we loaded ... <br>    if (fSameAsLoad) <br>    { <br>        pmsg = m_pMessage; <br>    } <br> <br>    // ----- set our message class <br>    prop.ulPropTag  = PR_MESSAGE_CLASS; <br>    prop.Value.LPSZ = TEXT(kszFormsMessageName); <br>    hr = m_pMessage-&gt;SetProps(1, &amp;prop, NULL); <br>    if (FAILED(hr) ) <br>    { <br>        return hr; <br>    } <br> <br>    POSITION pos = theApp.m_pDocTemplate-&gt;GetFirstDocPosition(); <br>    ASSERT (pos); <br> <br>    CToolDoc * pDoc = (CToolDoc*)theApp.m_pDocTemplate-&gt;GetNextDoc(pos); <br>     <br>    if (NULL != pDoc) <br>{ <br>//This will set the Message body to a specific text value in the form. <br>//This will be dependent on the specific form.  The intended use of this <br>//is when a receiver or the form does not have access to the form, then <br>//he/she will view a text version of the form data.  This is the text <br>//version. <br>prop.ulPropTag  = PR_BODY; <br>prop.Value.lpszA = TEXT("Sorry, no text equivalent of tool form"); <br>hr = m_pMessage-&gt;SetProps(1, &amp;prop, NULL); <br>if (FAILED(hr) ) <br>{ <br>    return hr; <br>} <br> <br>prop.ulPropTag = PR_SUBJECT; <br>prop.Value.LPSZ = TEXT(pDoc-&gt;m_theFormData.m_szTopic); <br> <br>hr = m_pMessage-&gt;SetProps(1, &amp;prop, NULL); <br>if (FAILED(hr)) <br>{ <br>   return hr; <br>} <br> <br>    prop.ulPropTag  = PR_FORMDATA; <br>    prop.Value.bin.lpb = (unsigned char *) &amp;(pDoc-&gt;m_theFormData); <br>    prop.Value.bin.cb  = sizeof(pDoc-&gt;m_theFormData); <br>    hr = m_pMessage-&gt;SetProps(1, &amp;prop, NULL); <br>if (FAILED(hr)) <br>{ <br>        return hr; <br>    } <br>} <br>    ADVISE(OnSaved); <br>    return hr; <br>} <br> <br> <br>//$--FRM::SaveCompleted------------------------------------------------------- <br>// <br>//  Purpose: <br>//      Terminates no-scribble and hands-off modes, returning the object <br>//      to its normal storage mode. <br>// <br>//  Returns: <br>//      HRESULT             S_OK, or error value. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::SaveCompleted(LPMESSAGE pmsg)  // Our new home message, if we need to change. <br>{ <br>    ASSERT(m_cRef &gt; 0); <br> <br>    // Reset modes <br>    m_fDirty = FALSE; <br> <br>    return NOERROR; <br>} <br> <br> <br>//$--FRM::HandsOffMessage----------------------------------------------------- <br>// <br>//  Purpose: <br>//      Releases our reference on the message so that a Save As operation <br>//      can occur. <br>// <br>//  Returns: <br>//      HRESULT             S_OK, or error value. <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>FRM::HandsOffMessage(void) <br>{ <br>    ASSERT(m_cRef &gt; 0); <br>    return NOERROR; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
