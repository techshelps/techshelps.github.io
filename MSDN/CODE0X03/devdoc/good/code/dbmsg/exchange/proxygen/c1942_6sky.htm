<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROXYGEN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1942"></a>PROXYGEN.C</h2>
<pre><code>//$--proxygen.c----------------------------------------------------------------- <br>// <br>//  This file implements a proxy address generating dll for SMTP style  <br>//  address@domain addresses (although can be used for any address type that <br>//  matches these conventions). <br>// <br>//  Proxies are generated from some combination of mailbox name, display name, <br>//  given name and surname (with spaces and other illegal characters replaced <br>//  or deleted) using the template specified in the site level proxy generated <br>//  by your setup program or the Microsoft Exchange Administrator program. <br>//  See the function header for rcGenerateProxy for details. <br>// <br>//  All functions will attempt to write an event log entry in the case of any <br>//  failure other than RC_MEMORY. <br>//  <br>// Copyright Microsoft Corporation 1986-1996,  All Rights Reserved <br>// ----------------------------------------------------------------------------- <br> <br>// <br>// Include Files <br>// -------------- <br> <br>#include "proxygen.h" <br>#include "proxyinf.h" <br>#include "proxymsg.h" <br> <br>// <br>// Defines <br>// ------- <br> <br>#define FREE(x) { if((x) != NULL) { free((void *)(x)); (x) = NULL; } } <br> <br>#define MAX(a,b) a&gt;b?a:b <br> <br>typedefDWORDIES; <br> <br>// RcInitProxies parses 3 data components out of the site proxy as follows: <br>//   ADDRESS-TYPE ":" FORMAT "@" DOMAIN <br>// For example, if the site proxy were "SMTP:%m@microsoft.com" then <br>//   ADDRESS TYPE is "SMTP" <br>//   FORMAT is "%m" <br>//   DOMAIN is "microsoft.com" <br>// Once these components are parsed out they are stored in the PROXYSESSION <br>// structure and accessed using the macros below. <br> <br>typedef struct _proxysession <br>{ <br>    LPWSTR      pszServer; <br>    LPWSTR      pszFormat; <br>    LPWSTR      pszType; <br>    ULONG       cchType; <br>    LPWSTR      pszDomain; <br>    ULONG       cchDomain; <br>} PROXYSESSION, *PPROXYSESSION; <br> <br>#define GET_SITE_FORMAT(x)     ((PPROXYSESSION)(x))-&gt;pszFormat <br>#define GET_SITE_TYPE(x)       ((PPROXYSESSION)(x))-&gt;pszType <br>#define GET_SITE_TYPE_CCH(x)   ((PPROXYSESSION)(x))-&gt;cchType <br>#define GET_SITE_DOMAIN(x)     ((PPROXYSESSION)(x))-&gt;pszDomain <br>#define GET_SITE_DOMAIN_CCH(x) ((PPROXYSESSION)(x))-&gt;cchDomain <br>#define GET_SERVER(x)          ((PPROXYSESSION)(x))-&gt;pszServer <br> <br>// The translation table from unicode to SMTP legal (subset of 7-bit ASCII) <br>// characters is indexed from 0 to MAX_TRANSLATE_TABLE.  Characters outside <br>// the range of the translation table are deleted.  Do not change this  <br>// constant without changing the translation table defined locally to  <br>// RcGenerateUserProxy(). <br>#define MAX_TRANSLATE_TABLE     255 <br> <br>// <br>// Globals <br>// ------- <br> <br>const PWSTR pszEventSource         = L"EDKProxy"; <br>const WCHAR chAddressTypeDelimiter  = (WCHAR)':'; <br>const WCHAR chDomainDelimiter       = (WCHAR)'@'; <br>const PWSTR pszDefaultFormat        = L"%m"; <br>const ULONG cchDefaultFormat        = 2; <br> <br>//  Local Function Prototypes <br>//  ------------------------- <br> <br>RC rcScanAndAppend(IN char *        sAnsitoSMTPMap,         // char replacement table <br>                   IN LPWSTR        pszSource,              // source buffer <br>                   IN OUT LPWSTR    pszDest,                // dest buffer <br>                   IN OUT ULONG *   piDest,                 // current index in dest buffer <br>                   IN ULONG         iMaxDest);              // max dest buffer index <br> <br>BOOL fIsWhiteSpaceW(WCHAR wc); <br> <br>VOID TrimW(IN OUT PWSTR pwstrSrc); <br> <br>VOID LogError(LPWSTR pszServer, IES ies, WORD wEventType, LPWSTR rgwsz[], WORD cwsz); <br> <br>RC RcGenerateUserProxy(                 // RETURNS: RC_SUCCESS RC_MEMORY RC_ERROR <br>    IN LPWSTR pwstrUserFormat,          // Format string for user part of proxy <br>    IN LPWSTR pwstrServer,              // Server name <br>    IN PRECIPIENTINFO pRecipientInfo,   // Recipient specific details.  <br>    INT nRetries,                       // Number of times this function <br>                                        //   has previously been called with <br>                                        //   this value for pRecipientInfo. <br>    IN OUT LPWSTR pwstrUserProxy,       // user part of SMTP proxy address <br>    OUT ULONG * pcchUserProxy);         // count of num chars in pwstrUserProxy <br> <br> <br> <br>//$--RcInitProxies-------------------------------------------------------------- <br>//  Parses and makes the site specific information accessible to the  <br>//  RcGenerateProxy, RcUpdateProxy, RcValidateProxy, RcValidateSiteProxy and <br>//  CloseProxies functions.  <br>// <br>//  The pwstrSiteProxy parameter is required as it cannot be defaulted for this <br>//  type of address. <br>// ----------------------------------------------------------------------------- <br>RC RcInitProxies(               // RETURNS:  RC_MEMORY RC_ERROR RC_SUCCESS <br>    IN LPWSTR pwstrSiteProxy,   // The site proxy for this address type.  <br>    IN LPWSTR pszServer,        // Exchange Server name <br>    OUT HANDLE *phProxySession) // Handle to the proxy session. <br>{ <br>    RC     rc           = RC_ERROR; <br>    LPWSTR pszType      = NULL; <br>    ULONG  cchType      = 0; <br>    LPWSTR pszFormat    = NULL; <br>    ULONG  cchFormat    = 0; <br>    LPWSTR pszDomain    = NULL; <br>    ULONG  cchDomain    = 0; <br>    LPWSTR pszAt        = NULL; <br>    LPWSTR pszColon     = NULL; <br> <br>    // Verify Input Parameters <br> <br>    if (pszServer == NULL) <br>    { <br>        // invalid arguments - internal error <br>        // can't write event log since no server name <br>        rc = RC_ERROR; <br>        goto error; <br>    } <br>                 <br>    // The domain proxy must be available so check this first <br> <br>    if (pwstrSiteProxy == NULL) <br>    { <br>LogError( <br>    pszServer, <br>    iesNoSiteProxy, <br>    EVENTLOG_ERROR_TYPE, <br>    NULL, <br>    0); <br>        rc = RC_ERROR; <br>        goto error; <br>    } <br> <br>    // Initialize output parameter <br> <br>    *phProxySession = NULL; <br> <br>    // Allocate a proxy session structure <br> <br>    *phProxySession = (HANDLE) malloc(sizeof(PROXYSESSION)); <br>    if (*phProxySession == NULL) <br>    { <br>        rc = RC_MEMORY; <br>        goto error; <br>    } <br> <br>    // Initialize elements of *phProxySession <br> <br>    GET_SERVER(*phProxySession) = NULL; <br>    GET_SITE_FORMAT(*phProxySession) = NULL; <br>    GET_SITE_DOMAIN(*phProxySession) = NULL; <br>    GET_SITE_DOMAIN_CCH(*phProxySession) = 0; <br>    GET_SITE_TYPE(*phProxySession) = NULL; <br>    GET_SITE_TYPE_CCH(*phProxySession) = 0; <br> <br>    // Trim blanks from pwstrSiteProxy <br> <br>    TrimW(pwstrSiteProxy); <br> <br>    // Validate pwstrSiteProxy, must be "TYPE:x@y" where x is 0 or more chars <br>    // up to the first colon and y is at least 1 char <br> <br>    cchDomain = lstrlenW(pwstrSiteProxy); <br>    pszAt = wcschr(pwstrSiteProxy, chDomainDelimiter); <br>    pszColon = wcschr(pwstrSiteProxy, chAddressTypeDelimiter); <br>     <br>    if ((cchDomain &lt; 4) ||  // min size = T:@y <br>        (pszColon == NULL) ||       // no colon <br>        (*pszColon != chAddressTypeDelimiter) ||  <br>        (pwstrSiteProxy[0] == chAddressTypeDelimiter)) // 1st char is :, no addr type <br>    { <br>        // pwstrSiteProxy is invalid <br> <br>   LPWSTR rgwsz[] =  <br>{ <br>pwstrSiteProxy <br>}; <br> <br>LogError( <br>    pszServer, <br>    iesBadSiteProxy, <br>    EVENTLOG_ERROR_TYPE, <br>    rgwsz, <br>    1); <br> <br>        rc = RC_ERROR; <br>        goto error; <br>    } <br> <br>    // Split site proxy into it's component parts <br>    // ------------------------------------------ <br> <br>    // replace : with 0 temporarily <br> <br>    *pszColon = 0; <br> <br>    // get address type <br> <br>    cchType = lstrlenW(pwstrSiteProxy); <br> <br>    pszType = malloc((cchType + 1) * sizeof(WCHAR)); <br> <br>    if (pszType == NULL) <br>    { <br>        rc = RC_MEMORY; <br>        goto error; <br>    } <br> <br>    lstrcpyW(pszType, pwstrSiteProxy); <br> <br>    // Restore ':' <br> <br>    *pszColon = chAddressTypeDelimiter; <br> <br>    // Check site proxy again for more validation <br> <br>    if ((pwstrSiteProxy[cchType] != chAddressTypeDelimiter) || <br>        (pszAt == NULL) || <br>        (*pszAt != chDomainDelimiter)) <br>    { <br>        // pwstrSiteProxy is invalid <br> <br>   LPWSTR rgwsz[] =  <br>{ <br>pwstrSiteProxy <br>}; <br> <br>LogError( <br>    pszServer, <br>    iesBadSiteProxy, <br>    EVENTLOG_ERROR_TYPE, <br>    rgwsz, <br>    1); <br> <br>        rc = RC_ERROR; <br>        goto error; <br>    } <br> <br>    // replace @ with 0 temporarily <br> <br>    *pszAt = 0; <br> <br>    // get format part <br>     <br>    cchFormat = lstrlenW(&amp;(pwstrSiteProxy[cchType+1])); <br> <br>    if (cchFormat == 0) <br>    { <br>        // use default format <br>         <br>        pszFormat = malloc((lstrlenW(pszDefaultFormat) + 1) * sizeof(WCHAR)); <br>     <br>        if (pszFormat == NULL) <br>        { <br>            rc = RC_MEMORY; <br>            goto error; <br>        } <br>         <br>        lstrcpyW(pszFormat, pszDefaultFormat); <br>    } <br>    else <br>    { <br>        // pull format out of site proxy <br> <br>        pszFormat = malloc((cchFormat+1)*sizeof(WCHAR)); <br>     <br>        if (pszFormat == NULL) <br>        { <br>            rc = RC_MEMORY; <br>            goto error; <br>        } <br>     <br>        lstrcpyW(pszFormat, &amp;(pwstrSiteProxy[cchType])+1); <br>    } <br> <br>    // get domain part <br>     <br>    cchDomain = lstrlenW(pszAt+1); <br>    pszDomain = malloc((cchDomain+1)*sizeof(WCHAR)); <br> <br>    if (pszDomain == NULL) <br>    { <br>        rc = RC_MEMORY; <br>        goto error; <br>    } <br>     <br>    lstrcpyW(pszDomain, (pszAt+1)); <br> <br>    // Restore '@' <br> <br>    *pszAt = chDomainDelimiter; <br> <br>    // Set structure members <br> <br>    GET_SERVER(*phProxySession) = pszServer; <br>    GET_SITE_FORMAT(*phProxySession) = pszFormat; <br>    GET_SITE_DOMAIN(*phProxySession) = pszDomain; <br>    GET_SITE_DOMAIN_CCH(*phProxySession) = cchDomain; <br>    GET_SITE_TYPE(*phProxySession) = pszType; <br>    GET_SITE_TYPE_CCH(*phProxySession) = cchType; <br> <br>    rc = RC_SUCCESS; <br>    goto cleanup; <br> <br>error: <br> <br>    FREE(*phProxySession); <br>    FREE(pszType); <br>    FREE(pszFormat); <br>    FREE(pszDomain); <br> <br>cleanup: <br> <br>    return rc; <br>} <br> <br> <br>//$--RcGenerateUserProxy-------------------------------------------------------- <br>//  Private helper function: Generates the user part of the proxy (before the  <br>//  '@') given the format portion of the site proxy and the recipient info. <br>// ----------------------------------------------------------------------------- <br>RC RcGenerateUserProxy(                 // RETURNS: RC_SUCCESS RC_MEMORY RC_ERROR <br>    IN LPWSTR pwstrUserFormat,          // Format string for user part of proxy <br>    IN LPWSTR pwstrServer,              // Server name <br>    IN PRECIPIENTINFO pRecipientInfo,   // Recipient specific details.  <br>    INT nRetries,                       // Number of times this function <br>                                        //   has previously been called with <br>                                        //   this value for pRecipientInfo. <br>    IN OUT LPWSTR pwstrUserProxy,       // user part of SMTP proxy address <br>    OUT ULONG * pcchUserProxy)          // count of num chars in pwstrUserProxy <br>{ <br>    RC      rc                          = RC_ERROR; <br>    LPWSTR  pszLocalFormat              = NULL; <br>    BOOL    fFreeLocalFormat            = FALSE; <br>    ULONG   iProxyBuffer                = 0, <br>            iFormat                     = 0, <br>            cchFormat                   = 0; <br>    BOOL    fEscape                     = FALSE; <br>    char sAnsitoSMTPMap[] =  <br>    {   // SMTP        ANSI        Byte <br>            0,      // null         00 <br>            0,      // (control)    01 <br>            0,      // (control)    02 <br>            0,      // (control)    03 <br>            0,      // (control)    04 <br>            0,      // (control)    05 <br>            0,      // (control)    06 <br>            0,      // (control)    07 <br>            0,      // (control)    08 <br>            0,      // (control)    09 <br>            0,      // (control)    10 <br>            0,      // (control)    11 <br>            0,      // (control)    12 <br>            0,      // (control)    13 <br>            0,      // (control)    14 <br>            0,      // (control)    15 <br>            0,      // (control)    16 <br>            0,      // (control)    17 <br>            0,      // (control)    18 <br>            0,      // (control)    19 <br>            0,      // (control)    20 <br>            0,      // (control)    21 <br>            0,      // (control)    22 <br>            0,      // (control)    23 <br>            0,      // (control)    24 <br>            0,      // (control)    25 <br>            0,      // (control)    26 <br>            0,      // (control)    27 <br>            0,      // (control)    28 <br>            0,      // (control)    29 <br>            0,      // (control)    30 <br>            0,      // (control)    31 <br>            0,      // space        32  <br>            '!',    // !            33 <br>            0,      // "            34 ** special ** <br>            '#',    // #            35 <br>            '$',    // $            36 <br>            '%',    // %            37 <br>            '&amp;',    // &amp;            38 <br>            39,     // '            39 <br>            0,      // (            40 ** special ** <br>            0,      // )            41 ** special ** <br>            '*',    // *            42 <br>            '+',    // +            43 <br>            0,      // ,            44 ** special ** <br>            '-',    // -            45 <br>            '.',    // .            46 ** This is a special but is ok here ** <br>            '/',    // /            47 <br>            '0',    // 0            48 <br>            '1',    // 1            49 <br>            '2',    // 2            50 <br>            '3',    // 3            51 <br>            '4',    // 4            52 <br>            '5',    // 5            53 <br>            '6',    // 6            54 <br>            '7',    // 7            55 <br>            '8',    // 8            56 <br>            '9',    // 9            57 <br>            0,      // :            58 ** special ** <br>            0,      // ;            59 ** special ** <br>            0,      // &lt;            60 ** special ** <br>            '=',    // =            61  <br>            0,      // &gt;            62 ** special ** <br>            '?',    // ?            63 <br>            0,      // @            64 ** special ** <br>            'A',    // A            65 <br>            'B',    // B            66 <br>            'C',    // C            67 <br>            'D',    // D            68 <br>            'E',    // E            69 <br>            'F',    // F            70 <br>            'G',    // G            71 <br>            'H',    // H            72 <br>            'I',    // I            73 <br>            'J',    // J            74 <br>            'K',    // K            75 <br>            'L',    // L            76 <br>            'M',    // M            77 <br>            'N',    // N            78 <br>            'O',    // O            79 <br>            'P',    // P            80 <br>            'Q',    // Q            81 <br>            'R',    // R            82 <br>            'S',    // S            83 <br>            'T',    // T            84 <br>            'U',    // U            85 <br>            'V',    // V            86 <br>            'W',    // W            87 <br>            'X',    // X            88 <br>            'Y',    // Y            89 <br>            'Z',    // Z            90 <br>            0,      // [            91 ** special ** <br>            '^',    // ^            92 <br>            0,      // ]            93 ** special ** <br>            0,      // ,            94 ?? - doesn't translate <br>            '_',    // _            95  <br>            '`',    // `            96 <br>            'a',    // a            97 <br>            'b',    // b            98 <br>            'c',    // c            99 <br>            'd',    // d            100 <br>            'e',    // e            101 <br>            'f',    // f            102 <br>            'g',    // g            103 <br>            'h',    // h            104 <br>            'i',    // i            105 <br>            'j',    // j            106 <br>            'k',    // k            107 <br>            'l',    // l            108 <br>            'm',    // m            109 <br>            'n',    // n            110 <br>            'o',    // o            111 <br>            'p',    // p            112 <br>            'q',    // q            113 <br>            'r',    // r            114 <br>            's',    // s            115 <br>            't',    // t            116 <br>            'u',    // u            117 <br>            'v',    // v            118 <br>            'w',    // w            119 <br>            'x',    // x            120 <br>            'y',    // y            121 <br>            'z',    // z            122 <br>            '{',    // {            123 <br>            '|',    // |            124 <br>            '}',    // }            125 <br>            '~',    // ~            126 <br>            0,      // del          127 <br>            0,      // (control)    128 <br>            0,      // (control)    129 <br>            0,      // (control)    130 <br>            0,      // (control)    131 <br>            0,      // (control)    132 <br>            0,      // (control)    133 <br>            0,      // (control)    134 <br>            0,      // (control)    135 <br>            0,      // (control)    136 <br>            0,      // (control)    137 <br>            0,      // (control)    138 <br>            0,      // (control)    139 <br>            0,      // (control)    140 <br>            0,      // (control)    141 <br>            0,      // (control)    142 <br>            0,      // (control)    143 <br>            0,      // (control)    144 <br>            0,      // (control)    145 <br>            0,      // (control)    146 <br>            0,      // (control)    147 <br>            0,      // (control)    148 <br>            0,      // (control)    149 <br>            0,      // (control)    150 <br>            0,      // (control)    151 <br>            0,      // (control)    152 <br>            0,      // (control)    153 <br>            0,      // (control)    154 <br>            0,      // (control)    155 <br>            0,      // (control)    156 <br>            0,      // (control)    157 <br>            0,      // (control)    158 <br>            0,      // (control)    159 <br>            0,      // space        160 <br>            0,      // 1st exclamn  161 <br>            'C',    // cents        162 <br>            'L',    // pounds       163 <br>            'P',    // phi          164 <br>            'Y',    // yen          165 <br>            'I',    // pipe         166 <br>            'S',    // section      167 <br>            0,      // "            168 <br>            'C',    // copyright    169 <br>            'A',    // a underscore 170 <br>            0,      // &lt;&lt;           171 <br>            0,      // not          172 <br>            '-',    // -            173 <br>            'R',    // registered   174 <br>            0,      // bar          175 <br>            0,      // degree       176 <br>            0,      // plus/minus   177 <br>            '2',    // supers 2     178 <br>            '3',    // supers 3     179 <br>            0,      // '            180 <br>            'M',    // mu           181 <br>            'P',    // paragraph    182 <br>            0,      // "            183 <br>            0,      // ,            184 <br>            '1',    // supers 1     185 <br>            'O',    // o underscore 186 <br>            0,      // &gt;&gt;           187 <br>            0,      // 1/4          188 <br>            0,      // 1/2          189 <br>            0,      // 3/4          190 <br>            0,      // 1st question 191 <br>            'A',    // A grave      192 <br>            'A',    // A acute      193 <br>            'A',    // A circumflex 194 <br>            'A',    // A tilde      195 <br>            'A',    // A umlaut     196 <br>            'A',    // A dot        197 <br>            'A',    // AE ligature  198 <br>            'C',    // C cedilla    199 <br>            'E',    // E grave      200 <br>            'E',    // E acute      201 <br>            'E',    // E circumflex 202 <br>            'E',    // E umlaut     203 <br>            'I',    // I grave      204 <br>            'I',    // I acute      205 <br>            'I',    // I circumflex 206 <br>            'I',    // I umlaut     207 <br>            'D',    // D dash       208 <br>            'N',    // N tilde      209 <br>            'O',    // O grave      210 <br>            'O',    // O acute      211 <br>            'O',    // O circumflex 212 <br>            'O',    // O tilde      213 <br>            'O',    // O umlaut     214 <br>            'X',    // multiplicn   215 <br>            '0',    // 0 slash      216 <br>            'U',    // U grave      217 <br>            'U',    // U acute      218 <br>            'U',    // U circumflex 219  <br>            'U',    // U umlaut     220 <br>            'Y',    // Y acute      221 <br>            'T',    // iapta        222 <br>            'B',    // beta         223 <br>            'a',    // a grave      224 <br>            'a',    // a acute      225 <br>            'a',    // a circumflex 226 <br>            'a',    // a tilde      227 <br>            'a',    // a umlaut     228 <br>            'a',    // a dot        229 <br>            'a',    // ae ligature  230 <br>            'c',    // c cedilla    231 <br>            'e',    // e grave      232 <br>            'e',    // e acute      233 <br>            'e',    // e circumflex 234 <br>            'e',    // e umlaut     235 <br>            'i',    // i grave      236 <br>            'i',    // i acute      237 <br>            'i',    // i circumflex 238 <br>            'i',    // i umlaut     239 <br>            'd',    // d dash       240 <br>            'n',    // n tilde      241 <br>            'o',    // o grave      242 <br>            'o',    // o acute      243 <br>            'o',    // o circumflex 244 <br>            'o',    // o tilde      245 <br>            'o',    // o umlaut     246 <br>            0,      // divide       247 <br>            '0',    // o slash      248 <br>            'u',    // u grave      249 <br>            'u',    // u acute      250 <br>            'u',    // u circumflex 251  <br>            'u',    // u umlaut     252 <br>            'y',    // y acute      253 <br>            't',    // iapta        254 <br>            'y'     // y umlaut     255 <br>    }; <br>  <br>    // Verify Input Parameters <br> <br>    if  (pwstrServer == NULL) <br>    { <br>        // invalid arguments - internal error <br>        // can't write event log since no server name <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br>                 <br>    if ((pwstrUserFormat == NULL) || <br>        (pwstrServer == NULL) || <br>        (pRecipientInfo == NULL) || <br>        (pwstrUserProxy == NULL)) <br>    { <br>        // invalid arguments - internal error <br> <br>LogError( <br>    pwstrServer, <br>    iesProxyInternalFailure, <br>    EVENTLOG_ERROR_TYPE, <br>    NULL, <br>    0); <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br>     <br>    // Initialize output parameters <br> <br>    *pwstrUserProxy = 0; <br>    *pcchUserProxy = 0; <br> <br>    // Figure out what format to use based on nRetries <br>    // ----------------------------------------------- <br> <br>    if (nRetries == 0) <br>    { <br>        pszLocalFormat = pwstrUserFormat; <br>    } <br>    else if (nRetries == 1) <br>    { <br>        pszLocalFormat = pszDefaultFormat; <br>    } <br>    else if (nRetries &gt; 1) <br>    { <br>        WCHAR pszRetries[20]; // temp buffer used to convert long to string <br>         <br>        _itow(nRetries, pszRetries, 10); // 10 is base <br>         <br>        pszLocalFormat = malloc( <br>            (cchDefaultFormat + lstrlenW(pszRetries) + 1) * sizeof(WCHAR)); <br> <br>        if (pszLocalFormat == NULL) <br>        { <br>            rc = RC_MEMORY; <br>            goto cleanup; <br>        } <br>         <br>        fFreeLocalFormat = TRUE; <br>        wsprintfW(pszLocalFormat, L"%s%s", pszDefaultFormat, pszRetries); <br>    } <br>    else <br>    { <br>        // nRetries is negative - nonsensical or nRetries is so big its negative <br> <br>   LPWSTR rgwsz[] =  <br>{ <br>pRecipientInfo-&gt;pszDisplayName <br>}; <br> <br>LogError( <br>    pwstrServer, <br>    iesUnableToCreateUniqueProxy, <br>    EVENTLOG_ERROR_TYPE, <br>    rgwsz, <br>    1); <br> <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br> <br>    cchFormat = lstrlenW(pszLocalFormat); <br> <br>    // Parse the format string  <br>    // ----------------------- <br> <br>    fEscape = FALSE; <br> <br>    for (iFormat = 0; iFormat &lt; cchFormat; iFormat++) <br>    { <br>        if (fEscape) <br>        { <br>            // next character indicates reason for escape <br> <br>            switch (pszLocalFormat[iFormat]) <br>            { <br>             <br>            case ('%'): <br>                if (iProxyBuffer+1 &lt; cchMaxProxyValue) <br>                { <br>                    pwstrUserProxy[iProxyBuffer++] = '%'; <br>                    pwstrUserProxy[iProxyBuffer] = 0; <br>                } <br>                else <br>                { <br>                    // Can't fit character in buffer <br> <br>     LPWSTR rgwsz[] =  <br>{ <br>pRecipientInfo-&gt;pszDisplayName <br>}; <br>                <br>          LogError( <br>            pwstrServer, <br>        iesProxyToBig, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br> <br>                    rc = RC_ERROR; <br>                    goto cleanup; <br>                } <br>                break; <br>                 <br>            case ('s'): // surname <br>                rc = rcScanAndAppend( <br>                    sAnsitoSMTPMap,                 // char replacement table <br>                    pRecipientInfo-&gt;pszLastName,    // source buffer <br>                    pwstrUserProxy,                 // dest buffer <br>                    &amp;iProxyBuffer,                  // current index in dest buffer <br>                    cchMaxProxyValue-1);            // dest buffer max index <br> <br>                if (RC_FAILED(rc)) <br>                { <br>                    // Can't fit last name in buffer <br> <br>     LPWSTR rgwsz[] =  <br>{ <br>pRecipientInfo-&gt;pszDisplayName <br>}; <br>                <br>          LogError( <br>            pwstrServer, <br>        iesProxyToBig, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br> <br>                    rc = RC_ERROR; <br>                    goto cleanup; <br>                } <br>                break; <br> <br>            case ('g'): // given name <br>                rc = rcScanAndAppend( <br>                    sAnsitoSMTPMap,                 // char replacement table <br>                    pRecipientInfo-&gt;pszFirstName,   // source buffer <br>                    pwstrUserProxy,                 // dest buffer <br>                    &amp;iProxyBuffer,                  // current index in dest buffer <br>                    cchMaxProxyValue-1);            // dest buffer size <br> <br>                if (RC_FAILED(rc)) <br>                { <br>                    // Can't fit given name in buffer <br> <br>     LPWSTR rgwsz[] =  <br>{ <br>pRecipientInfo-&gt;pszDisplayName <br>}; <br>                <br>          LogError( <br>            pwstrServer, <br>        iesProxyToBig, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br> <br>                    rc = RC_ERROR; <br>                    goto cleanup; <br>                } <br>                break; <br> <br>            case ('d'): // display name <br>                rc = rcScanAndAppend( <br>                    sAnsitoSMTPMap,                 // char replacement table <br>                    pRecipientInfo-&gt;pszDisplayName, // source buffer <br>                    pwstrUserProxy,                 // dest buffer <br>                    &amp;iProxyBuffer,                  // current index in dest buffer <br>                    cchMaxProxyValue-1);            // dest buffer size <br> <br>                if (RC_FAILED(rc)) <br>                { <br>                    // Can't fit display name in buffer <br> <br>     LPWSTR rgwsz[] =  <br>{ <br>pRecipientInfo-&gt;pszDisplayName <br>}; <br>                <br>          LogError( <br>            pwstrServer, <br>        iesProxyToBig, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br> <br>                    rc = RC_ERROR; <br>                    goto cleanup; <br>                } <br>                break; <br> <br>            case ('m'): // mailbox name <br>                rc = rcScanAndAppend( <br>                    sAnsitoSMTPMap,                 // char replacement table <br>                    pRecipientInfo-&gt;pszCommonName,  // source buffer <br>                    pwstrUserProxy,                 // dest buffer <br>                    &amp;iProxyBuffer,                  // current index in dest buffer <br>                    cchMaxProxyValue-1);            // dest buffer size <br> <br>                if (RC_FAILED(rc)) <br>                { <br>                    // Can't fit mailbox name in buffer <br> <br>     LPWSTR rgwsz[] =  <br>{ <br>pRecipientInfo-&gt;pszDisplayName <br>}; <br>                <br>          LogError( <br>            pwstrServer, <br>        iesProxyToBig, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br> <br>                    rc = RC_ERROR; <br>                    goto cleanup; <br>                } <br>                break; <br> <br>            case ('r'): // char replacement change <br>                if (iFormat+2 &lt; cchFormat) <br>                { <br>                    char chSrc, chDest; <br> <br>                    chSrc = (char)pszLocalFormat[iFormat+1]; <br>                    chDest = (char)pszLocalFormat[iFormat+2]; <br> <br>                    if (chSrc == chDest) <br>                    { <br>                        sAnsitoSMTPMap[chSrc] = 0; <br>                    } <br>                    else <br>                    { <br>                        sAnsitoSMTPMap[chSrc] = chDest; <br>                    } <br> <br>                    iFormat += 2; <br>                } <br>                else <br>                { <br>                    // format string is invalid <br> <br>     LPWSTR rgwsz[] =  <br>{ <br>pszLocalFormat </code></pre>
<p>
</p>
<pre><code>}; <br>                <br>          LogError( <br>            pwstrServer, <br>        iesInvalidFormatString, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br> <br>                    rc = RC_ERROR; <br>                    goto cleanup; <br>                } <br>                break; <br>                  <br>             default: <br>                // format specifier is unrecognized <br>                { <br>      LPWSTR rgwsz[] =  <br>        { <br>    pszLocalFormat <br>    }; <br>                <br>          LogError( <br>                pwstrServer, <br>        iesInvalidFormatString, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br>                } <br> <br>                rc = RC_ERROR; <br>                goto cleanup; <br>             <br>            } // switch <br> <br>            fEscape = FALSE; <br>             <br>        } // if fEscape <br>        else  <br>        {        <br>            if (pszLocalFormat[iFormat] == '%') <br>            { <br>                fEscape = TRUE; <br>            } // if escape char <br>            else <br>            { <br>                // literal character; just insert it as long as it is legal <br>                if ((pszLocalFormat[iFormat] &lt;= MAX_TRANSLATE_TABLE) &amp;&amp; <br>                    (sAnsitoSMTPMap[pszLocalFormat[iFormat]] != 0) &amp;&amp; <br>                    (iProxyBuffer &lt; cchMaxProxyValue-1)) <br>                { <br>                    pwstrUserProxy[iProxyBuffer++] = pszLocalFormat[iFormat]; <br>                    pwstrUserProxy[iProxyBuffer] = 0; <br>                } <br>                else <br>                { <br>                    // invalid literal character in format string <br> <br>     LPWSTR rgwsz[] =  <br>{ <br>pszLocalFormat <br>}; <br>                <br>          LogError( <br>            pwstrServer, <br>        iesInvalidFormatString, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br> <br>                    rc = RC_ERROR; <br>                    goto cleanup; <br>                } <br>            } // else literal <br>        } // else !fEscape <br>             <br>    } // for iFormat         <br> <br>    *pcchUserProxy = iProxyBuffer; <br>  <br>    rc = RC_SUCCESS; <br> <br>cleanup: <br>     <br>    if (fFreeLocalFormat) <br>    { <br>        FREE(pszLocalFormat); <br>    } <br> <br>    return rc; <br> <br>} <br> <br> <br>//$--RcGenerateProxy------------------------------------------------------------ <br>//  Returns a single proxy address as a unicode string.  <br>// <br>//  When nRetries == 0 <br>//  ================== <br>// <br>//  The format of this proxy is based upon the site proxy string which has the  <br>//  following format: <br>//      address-type ":" [format] "@" domain  <br>//   <br>//  The address-type and domain are uninterpreted and are written exactly as is <br>// <br>//  Format is optional, if specified it must contain only valid address <br>//  characters plus the following special symbols: <br>//      "%s"        substitute the Surname of the user  <br>//      "%g"        substitute the Given name of the user <br>//      "%d"        substitute the Display name of the user <br>//      "%m"        substitute the mailbox name of the user <br>//      "%%"        substitute a single '%' <br>//  In all the substitutions above, spaces and illegal characters will be <br>//  removed from the field before the substitution is made. To specify a  <br>//  different substitution to be used, use %r: <br>//      "%r" char1 char2  <br>//  All instances of char1 will be replaced by char2 in the substitutions  <br>//  which occur after this in the format string. If char1 == char2 the  <br>//  character will be deleted. <br>// <br>//  If the format field is not present, this is equivalent to: <br>//      address-type ":" "%m" "@" domain  <br>// <br>//  Examples: <br>// <br>//  These examples are based on: <br>//      mailbox = "dougdo" <br>//      display name = "Doug M. Dosdall" <br>//      surname = "Dosdall" <br>//      given name = "Doug" <br>// <br>//  Site Proxy                          Generated User Proxy <br>//  ----------------------------------- ---------------------------------------- <br>//  SMTP:%r _%d@wspu.microsoft.com      SMTP:Doug_M._Dosdall@wspu.microsoft.com <br>//  SAMPLE:%r..%d@wspu.microsoft.com    SAMPLE:DougMDosdall@wspu.microsoft.com <br>//  EDK:%g.%s@wspu.microsoft.com        EDK:Doug.Dosdall@wspu.microsoft.com <br>//  SMTP:@wspu.microsoft.com            SMTP:dougdo@wspu.microsoft.com <br>// <br>// <br>//  When nRetries == 1 <br>//  ================== <br>// <br>//  The user proxy is generated as per above except the format portion is  <br>//  ignored, i.e. assumed to be %m only. <br>// <br>// <br>//  When nRetries &gt; 1 <br>//  ================= <br>// <br>//  The user proxy is generated using the following format:  <br>//      address-type ":" "%m" nRetries "@" domain  <br>// <br>//  For example, when nRetries == 2, the generated user proxy for the example <br>//  above would be: <br>//   <br>//  SMTP:dougdo2@wspu.microsoft.com <br>// <br>// ----------------------------------------------------------------------------- <br>RC RcGenerateProxy(                     // RETURNS: RC_SUCCESS RC_MEMORY RC_ERROR <br>    IN HANDLE hProxySession,            // Handle to proxy sesssion.  <br>    IN PRECIPIENTINFO pRecipientInfo,   // Recipient specific details.  <br>    INT nRetries,                       // Number of times this function <br>                                        //   has previously been called with <br>                                        //   this value for pRecipientInfo. <br>    OUT LPWSTR *ppwstrProxyAddr)        // generated proxy address.  <br>{ <br>    RC      rc                          = RC_SUCCESS; <br>    WCHAR   pwstrProxyBuffer[cchMaxProxyValue] = {L'\0'}; <br>    ULONG   cchProxyBuffer              = 0; <br>    ULONG   cb                          = 0; <br>    ULONG   i                           = 0; <br>  <br>    // Verify Input Parameters <br> <br>if ((hProxySession == NULL) ||  <br>        (GET_SERVER(hProxySession) == NULL)) <br>    { <br>        // invalid arguments - internal error <br>        // can't write event log since no server name <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br>                 <br>    if ((GET_SITE_FORMAT(hProxySession) == NULL) || <br>        (GET_SITE_DOMAIN(hProxySession) == NULL) || <br>        (pRecipientInfo == NULL) || <br>        (pRecipientInfo-&gt;pszCommonName == NULL)) <br>    { <br>        // invalid arguments - internal error; RcGenerateProxy should never <br>        // be called unless RcInitProxies was succesfully called first and <br>        // RcInitProxies must always set the site format and site domain. <br> <br>LogError( <br>    GET_SERVER(hProxySession), <br>    iesProxyInternalFailure, <br>    EVENTLOG_ERROR_TYPE, <br>    NULL, <br>    0); <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br>     <br>    // Initialize output parameter <br> <br>    *ppwstrProxyAddr = NULL; <br> <br>    // Get the expanded user part of the proxy  <br>    // --------------------------------------- <br> <br>    rc = RcGenerateUserProxy( <br>        GET_SITE_FORMAT(hProxySession), <br>        GET_SERVER(hProxySession), <br>        pRecipientInfo, <br>        nRetries, <br>        pwstrProxyBuffer, <br>        &amp;cchProxyBuffer); <br> <br>    if (RC_FAILED(rc)) <br>    { <br>        // RcGenerateUserProxy generates own log entry <br>        // just pass error through <br>        goto cleanup; <br>    } <br>         <br>    // Figure out the size of the final proxy and alloc buffer <br>    // ------------------------------------------------------- <br> <br>    cb = (GET_SITE_TYPE_CCH(hProxySession) +    // e.g. "SMTP" <br>          1 +                                   // ":" <br>          cchProxyBuffer +                      // user proxy <br>          1 +                                   // @ <br>          GET_SITE_DOMAIN_CCH(hProxySession) +  // domain <br>          1) * sizeof(WCHAR);                   // terminating null <br> <br>    *ppwstrProxyAddr = malloc(cb); <br> <br>    if ((*ppwstrProxyAddr) == NULL) <br>    { <br>        rc = RC_MEMORY; <br>        goto cleanup; <br>    } <br> <br>    // Put all the pieces together in *ppwstrProxyAddr <br>    // ----------------------------------------------- <br> <br>    lstrcpyW(*ppwstrProxyAddr, GET_SITE_TYPE(hProxySession)); <br>    i = GET_SITE_TYPE_CCH(hProxySession); <br>    (*ppwstrProxyAddr)[i++] = chAddressTypeDelimiter; <br>    lstrcpyW(&amp;((*ppwstrProxyAddr)[i]), pwstrProxyBuffer); <br>    i += cchProxyBuffer; <br>    (*ppwstrProxyAddr)[i++] = chDomainDelimiter;     <br>    lstrcpyW(&amp;((*ppwstrProxyAddr)[i]), GET_SITE_DOMAIN(hProxySession)); <br> <br>cleanup: <br>     <br>    return rc; <br> <br>} <br> <br> <br>//$--RcUpdateProxy-------------------------------------------------------------- <br>//  Updates a given proxy based on given the old/new site proxy.  <br>// <br>//  Separately decides to update the user part and the domain part of the  <br>//  proxy depending on which part of the site proxy has changed - the format <br>//  part or the domain part or both. If the proxy is to be changed then it <br>//  returns fDomainMatch == TRUE and the updated proxy. If the proxy should not <br>//  be updated then it returns fDomainMatch = FALSE and the pwstrProxy parameter <br>//  should be ignored. <br>// <br>//  This allows for selective updating of proxies; it's main goal is to attempt <br>//  to only update proxies which have been previously automatically generated <br>//  and not to lose manual edits previously made by an administrator. <br>// <br>//  Example 1: Domain has changed. <br>//  Old Site Proxy: %g@acme.com <br>//  New Site Proxy: %g@acmetool.com <br>//  User Proxies: Alice@acme.com, Bob@acme.com, Carol@otherco.com <br>//  In this example, RcUpdateProxy would be called 3 times, once for each user. <br>//  For this case, we want to update Alice and Bob's proxies but not Carol's so <br>//  we return for each of the three calls: <br>//     fDomainMatch     pwstrProxy <br>//  1. TRUE             Alice@acmetool.com <br>//  2. TRUE             Bob@acmetool.com <br>//  3. FALSE            Carol@otherco.com <br>// <br>//  Example 2: Format string changed; acme is now too big to use only first names <br>//  Old Site Proxy: %g@acme.com <br>//  New Site Proxy: %g.%s@acme.com <br>//  User Proxies: alice@acme.com, bob@acme.com, TJones@acme.com <br>//  For this case, we again want to update Alice and Bob's proxies since the <br>//  user part of their current proxies still match what would have been <br>//  generated with the old site proxy. However, the address for TJones must <br>//  have been manually entered and we do not want to change it to the new <br>//  format. So the returns are: <br>//     fDomainMatch     pwstrProxy <br>//  1. TRUE             AliceN@acme.com <br>//  2. TRUE             BobB@acme.com <br>//  3. FALSE            TJones@acme.com <br>// <br>// If both the format part and domain part of the site proxy have changed then <br>// both cases are checked and evaluated separately and fDomainMatch is set to  <br>// TRUE if any part of the proxy has changed. <br>// ----------------------------------------------------------------------------- <br>RC RcUpdateProxy(                   // RETURNS: RC_SUCCESS RC_MEMORY RC_ERROR RC_NOTFOUND <br>    IN HANDLE hProxySession,            // Handle to proxy sesssion.  <br>    IN PRECIPIENTINFO pRecipientInfo, <br>    IN LPWSTR pwstrOldSiteProxy,        // Old site proxy <br>    IN LPWSTR pwstrNewSiteProxy,        // New site proxy <br>    IN OUT LPWSTR pwstrProxy,      // Proxy to modify, buffer is of  <br>                                        //   cchMaxProxyValue size <br>IN VOID * pUnused)// Unused <br>{             <br>    RC      rc = RC_SUCCESS; <br>    WCHAR   pwstrBuf[cchMaxProxyValue] = {L'\0'};   // working buffer for final proxy <br>    ULONG   iBuf            = 0; <br>    WCHAR   pwstrUserBuf[cchMaxProxyValue]; <br>    ULONG   cchUserBuf; <br>    LPWSTR  pwstrTypeOSP    = NULL; // address type part of pwstrOldSiteProxy <br>    LPWSTR  pwstrTypeP      = NULL; //                      pwstrProxy <br>    LPWSTR  pwstrTypeNSP    = NULL; //                      pwstrNewSiteProxy <br>    LPWSTR  pwstrUserOSP    = NULL; // user/format part of pwstrOldSiteProxy <br>    LPWSTR  pwstrUserP      = NULL; //                     pwstrProxy  <br>    LPWSTR  pwstrUserNSP    = NULL; //                     pwstrNewSiteProxy <br>    LPWSTR  pwstrDomainOSP  = NULL; // domain part of pwstrOldSiteProxy <br>    LPWSTR  pwstrDomainP    = NULL; //                pwstrProxy <br>    LPWSTR  pwstrDomainNSP  = NULL; //                pwstrNewSiteProxy <br> <br>    // separate out the parts we need of the input parameters <br>    // ------------------------------------------------------ <br>     <br>    // separate pwstrOldSiteProxy into type, user format and domain by temp <br>    // replacing : and @ with \0 <br> <br>    pwstrTypeOSP = pwstrOldSiteProxy; <br> <br>    pwstrUserOSP = wcschr(pwstrOldSiteProxy, chAddressTypeDelimiter); <br> <br>    if (pwstrUserOSP == NULL) <br>    { <br>        // internal error - we are getting a site proxy string which does not start <br>        // ADDRTYPE: (this should never happen) <br>LogError( <br>    GET_SERVER(hProxySession), <br>    iesProxyInternalFailure, <br>    EVENTLOG_ERROR_TYPE, <br>    NULL, <br>    0); <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br> <br>    *pwstrUserOSP = 0; <br>    pwstrUserOSP++; <br> <br>    pwstrDomainOSP = wcschr(pwstrUserOSP, chDomainDelimiter); <br> <br>    if (pwstrDomainOSP) <br>    { <br>        *pwstrDomainOSP = 0; <br>        pwstrDomainOSP++; <br>    } <br>     <br>    // separate pwstrNewSiteProxy into type, user format and domain by temp <br>    // replacing : and @ with \0 <br> <br>    pwstrTypeNSP = pwstrNewSiteProxy; <br> <br>    pwstrUserNSP = wcschr(pwstrNewSiteProxy, chAddressTypeDelimiter); <br> <br>    if (pwstrUserNSP == NULL) <br>    { <br>        // internal error - we are getting a site proxy string which does not start <br>        // ADDRTYPE: (this should never happen) <br>LogError( <br>    GET_SERVER(hProxySession), <br>    iesProxyInternalFailure, <br>    EVENTLOG_ERROR_TYPE, <br>    NULL, <br>    0); <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br> <br>    *pwstrUserNSP = 0; <br>    pwstrUserNSP++; <br> <br>    pwstrDomainNSP = wcschr(pwstrUserNSP, chDomainDelimiter); <br> <br>    if (pwstrDomainNSP) <br>    { <br>        *pwstrDomainNSP = 0; <br>        pwstrDomainNSP++; <br>    } <br> <br>    // separate pwstrProxy into type, user and domain by temporarily replacing <br>    // @ and : with \0 <br> <br>    pwstrTypeP = pwstrProxy; <br> <br>    pwstrUserP = wcschr(pwstrProxy, chAddressTypeDelimiter); <br> <br>    if (pwstrUserP == NULL) <br>    { <br>        // internal error - we are getting a site proxy string which does not start <br>        // ADDRTYPE: (this should never happen) <br>LogError( <br>    GET_SERVER(hProxySession), <br>    iesProxyInternalFailure, <br>    EVENTLOG_ERROR_TYPE, <br>    NULL, <br>    0); <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br>     <br>    *pwstrUserP = 0; <br>    pwstrUserP++; <br>     <br>    pwstrDomainP = wcschr(pwstrUserP, chDomainDelimiter); <br> <br>    if (pwstrDomainP) <br>    { <br>        *pwstrDomainP = 0; <br>        pwstrDomainP++; <br>    } <br> <br>    // Do the address types match? <br> <br>    if ((lstrcmpiW(pwstrTypeOSP, pwstrTypeP)) || (lstrcmpiW(pwstrTypeOSP, pwstrTypeNSP))) <br>    { <br>        // internal error - the address types do not match; again, this should <br>        // never occur. <br>LogError( <br>    GET_SERVER(hProxySession), <br>    iesProxyInternalFailure, <br>    EVENTLOG_ERROR_TYPE, <br>    NULL, <br>    0); <br>        rc = RC_ERROR; <br>        goto cleanup; <br>    } <br> <br>    // Start building the new proxy; however leave *pfNoDomainMatch == TRUE <br>    // until we know we have made a significate change <br>    // -------------------------------------------------------------------- <br> <br>    // Copy in the address type and ":" <br> <br>    lstrcpyW(pwstrBuf, pwstrTypeP); <br>    iBuf = lstrlenW(pwstrTypeP); <br>    pwstrBuf[iBuf++] = chAddressTypeDelimiter; <br> <br>    // if the user part of the proxy that we would generate from pRecipientInfo  <br>    // and pwstrOldSiteProxy == the user part of pwstrProxy (if its != then it <br>    // must have been manually edited for this user and we don't want to touch it) <br>    // then generate a new user part using pwstrNewSiteProxy and pRecipientInfo. <br> <br>    // generate the user part of the proxy from the user part of the old domain <br>    // proxy <br> <br>    if (pwstrUserOSP[0] == 0) <br>    { <br>        rc = RcGenerateUserProxy( <br>            pszDefaultFormat, <br>            GET_SERVER(hProxySession), <br>            pRecipientInfo, <br>            0, <br>            pwstrUserBuf, <br>            &amp;cchUserBuf); <br>    } <br>    else <br>    { <br>        rc = RcGenerateUserProxy( <br>            pwstrUserOSP, <br>            GET_SERVER(hProxySession), <br>            pRecipientInfo, <br>            0, <br>            pwstrUserBuf, <br>            &amp;cchUserBuf); <br>    } <br> <br>    if (RC_FAILED(rc)) <br>    { <br>        // RcGenerateUserProxy generates own log entry <br>        // just pass error through <br>        goto cleanup; <br>    } <br> <br>    // See how this compares to actual user part of current proxy <br>     <br>    if (lstrcmpiW(pwstrUserBuf, pwstrUserP) == 0) <br>    { <br>        // go ahead and get the updated the user part <br> <br>        if (pwstrUserNSP[0] == 0) <br>        { <br>            rc = RcGenerateUserProxy( <br>                pszDefaultFormat, <br>                GET_SERVER(hProxySession), <br>                pRecipientInfo, <br>                0, <br>                pwstrUserBuf, <br>                &amp;cchUserBuf); <br>        } <br>        else <br>        { <br>            rc = RcGenerateUserProxy( <br>                pwstrUserNSP, <br>                GET_SERVER(hProxySession), <br>                pRecipientInfo, <br>                0, <br>                pwstrUserBuf, <br>                &amp;cchUserBuf); <br>        } <br>             <br>        if (RC_FAILED(rc)) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // copy the new user part onto the final result <br> <br>        lstrcpyW(&amp;(pwstrBuf[iBuf]), pwstrUserBuf); <br>        iBuf += cchUserBuf; <br>    } <br>    else <br>    { <br>        // don't change the user part, just recopy the original  <br>        // user part <br> <br>        lstrcpyW(&amp;(pwstrBuf[iBuf]), pwstrUserP); <br>        iBuf += lstrlenW(pwstrUserP); <br>    } <br> <br>    // Always replace the domain part of the site proxy.  Add the domain <br>    // part of the site proxy the proxy if there is anything to add <br>    // ----------------------------------------------------------------- <br>     <br>    if (pwstrDomainNSP) <br>    { <br>        pwstrBuf[iBuf++] = chDomainDelimiter; <br>        lstrcpyW(&amp;(pwstrBuf[iBuf]), pwstrDomainNSP); <br>    } <br> <br>    // Always copy the final result to the output buffer <br>    // ------------------------------------------------- <br> <br>    lstrcpyW(pwstrProxy, pwstrBuf); <br> <br>cleanup: <br> <br>    // Restore the : and @ characters in the munged strings  <br> <br>    if (pwstrUserOSP) <br>    { <br>        *(pwstrUserOSP-1) = chAddressTypeDelimiter; <br>    } <br>    if (pwstrDomainOSP) <br>    { <br>        *(pwstrDomainOSP-1) = chDomainDelimiter; <br>    } <br> <br>    if (pwstrUserNSP) <br>    { <br>        *(pwstrUserNSP-1) = chAddressTypeDelimiter; <br>    } <br>    if (pwstrDomainNSP) <br>    { <br>        *(pwstrDomainNSP-1) = chDomainDelimiter; <br>    } <br> <br>    return rc; <br>} <br> <br>//$--RcValidateProxy------------------------------------------------------------ <br>//  Verifies that a manually entered proxy is at least minimally valid.   <br>// ----------------------------------------------------------------------------- <br>RC RcValidateProxy(             // RETURNS: RC_SUCCESS  RC_MEMORY RC_ERROR <br>                                //          RC_IMPLEMENTATION <br>    IN HANDLE hProxySession,    // Handle to the proxy session previously  <br>                                // returned by rcProxuInit. <br>    IN LPWSTR pwstrProxyAddr,   // The foreign format proxy address to be  <br>                                // validated. <br>    OUT BOOL *pfValid)          // Recieves TRUE if valid, FALSE otherwise. <br>                                // Undefined if other than RC_SUCCESS returned <br>                                // by function. <br>{ <br>    UINT    i,  <br>            cch = 0; <br> <br>    // assume address is valid until proven otherwise <br> <br>    *pfValid = TRUE; <br>     <br>    // The only proxy validation done here is to look for characters &lt; 33 or <br>    // &gt; 127. Obviously more should be done as more characters are illegal. <br> <br>    // Could also do some sort of content checking to verify whether the content <br>    // (i.e. the domain part) is not only legal but makes sense (this is harder). <br> <br>    cch = lstrlenW(pwstrProxyAddr); <br> <br>    for (i = 0; i &lt; cch; i++) <br>    { <br>        if ((pwstrProxyAddr[i] &lt; 33) || (pwstrProxyAddr[i] &gt; 127)) <br>        { <br> <br>            // Log error so user knows why proxy address was rejected <br> <br>       LPWSTR rgwsz[] =  <br>    { <br>    pwstrProxyAddr <br>    }; <br> <br>        LogError( <br>            GET_SERVER(hProxySession), <br>            iesInvalidCharacter, <br>            EVENTLOG_ERROR_TYPE, <br>            rgwsz, <br>            1); <br> <br>            *pfValid = FALSE; <br>            break; <br>        } <br>    } <br> <br>    return RC_SUCCESS; <br>} <br> <br> <br>//$--RcValidateSiteProxy-------------------------------------------------------- <br>// Given a Unicode string, it validates that this string is a valid site address. <br>// This is called to verify that manually generated site proxies are legal. <br>// For this implementation, it is assumed the site proxy is legal if: <br>// - We can split it into it's component parts <br>// - The format and domain parts contain only chars in the 33-127 range <br>// ----------------------------------------------------------------------------- <br>RC RcValidateSiteProxy(         // RETURNS: RC_SUCCESS  RC_MEMORY RC_ERROR <br>                                //          RC_IMPLEMENTATION <br>    IN HANDLE hProxySession,    // Handle to the proxy session previously  <br>                                // returned by rcProxuInit. <br>    IN LPWSTR pwstrSiteProxy,   // The foreign format site proxy address to be  <br>                                // validated. <br>    OUT BOOL *pfValid)        // Recieves TRUE if valid, FALSE otherwise. <br>                                // Undefined if other than RC_SUCCESS returned <br>                                // by function. <br>{ <br>    RC      rc          = RC_SUCCESS; <br>LPWSTR  pszServer   = GET_SERVER(hProxySession); <br>    LPWSTR pszType      = NULL; <br>    ULONG  cchType      = 0; <br>    LPWSTR pszFormat    = NULL; <br>    ULONG  cchFormat    = 0; <br>    LPWSTR pszDomain    = NULL; <br>    ULONG  cchDomain    = 0; <br>    LPWSTR pszAt        = NULL; <br>    LPWSTR pszColon     = NULL; <br>    BOOL   fEscape      = FALSE; <br>    ULONG  i; <br> <br>    // Initialize output parameter <br> <br>    *pfValid = TRUE; <br> <br>    // The site proxy must be available so check this first <br> <br>    if (pwstrSiteProxy == NULL) <br>    { <br>LogError( <br>    pszServer, <br>    iesNoSiteProxy, <br>    EVENTLOG_ERROR_TYPE, <br>    NULL, <br>    0); <br>        *pfValid = FALSE; <br>        goto exit; <br>    } <br> <br>    // Trim blanks from pwstrSiteProxy <br> <br>    TrimW(pwstrSiteProxy); <br> <br>    // Validate pwstrSiteProxy, must be "TYPE:x@y" where x is 0 or more chars <br>    // up to the first colon and y is at least 1 char <br> <br>    cchDomain = lstrlenW(pwstrSiteProxy); <br>    pszAt = wcschr(pwstrSiteProxy, chDomainDelimiter); <br>    pszColon = wcschr(pwstrSiteProxy, chAddressTypeDelimiter); <br>     <br>    if ((cchDomain &lt; 4) ||  // min size = T:@y <br>        (pszColon == NULL) ||       // no colon <br>        (*pszColon != chAddressTypeDelimiter) ||  <br>        (pwstrSiteProxy[0] == chAddressTypeDelimiter)) <br>    { <br>        // pwstrSiteProxy is invalid <br> <br>   LPWSTR rgwsz[] =  <br>{ <br>pwstrSiteProxy <br>}; <br> <br>LogError( <br>    pszServer, <br>    iesBadSiteProxy, <br>    EVENTLOG_ERROR_TYPE, <br>    rgwsz, <br>    1); <br> <br>        *pfValid = FALSE; <br>        goto exit; <br>    } <br> <br>    // Split site proxy into it's component parts <br>    // ------------------------------------------ <br> <br>    // replace : with 0 temporarily <br> <br>    *pszColon = 0; <br> <br>    // get address type <br> <br>    cchType = lstrlenW(pwstrSiteProxy); <br> <br>    pszType = malloc((cchType + 1) * sizeof(WCHAR)); <br> <br>    if (pszType == NULL) <br>    { <br>        rc = RC_MEMORY; <br>        goto exit; <br>    } <br> <br>    lstrcpyW(pszType, pwstrSiteProxy); <br> <br>    // Restore ':' <br> <br>    *pszColon = chAddressTypeDelimiter; <br> <br>    // Check site proxy again for more validation <br> <br>    if ((pwstrSiteProxy[cchType] != chAddressTypeDelimiter) || <br>        (pszAt == NULL) || <br>        (*pszAt != chDomainDelimiter)) <br>    { <br>        // pwstrSiteProxy is invalid <br> <br>   LPWSTR rgwsz[] =  <br>{ <br>pwstrSiteProxy <br>}; <br> <br>LogError( <br>    pszServer, <br>    iesBadSiteProxy, <br>    EVENTLOG_ERROR_TYPE, <br>    rgwsz, <br>    1); <br> <br>        *pfValid = FALSE; <br>        goto exit; <br>    } <br> <br>    // replace @ with 0 temporarily <br> <br>    *pszAt = 0; <br> <br>    // get format part <br>     <br>    cchFormat = lstrlenW(&amp;(pwstrSiteProxy[cchType+1])); <br> <br>    if (cchFormat == 0) <br>    { <br>        // use default format <br>         <br>        pszFormat = malloc((lstrlenW(pszDefaultFormat) + 1) * sizeof(WCHAR)); <br>     <br>        if (pszFormat == NULL) <br>        { <br>            rc = RC_MEMORY; <br>            goto exit; <br>        } <br>         <br>        lstrcpyW(pszFormat, pszDefaultFormat); <br>    } <br>    else <br>    { <br>        // pull format out of site proxy <br> <br>        pszFormat = malloc((cchFormat+1)*sizeof(WCHAR)); <br>     <br>        if (pszFormat == NULL) <br>        { <br>            rc = RC_MEMORY; <br>            goto exit; <br>        } <br>     <br>        lstrcpyW(pszFormat, &amp;(pwstrSiteProxy[cchType])+1); <br>    } <br> <br>    // get domain part <br>     <br>    cchDomain = lstrlenW(pszAt+1); <br>    pszDomain = malloc((cchDomain+1)*sizeof(WCHAR)); <br> <br>    if (pszDomain == NULL) <br>    { <br>        rc = RC_MEMORY; <br>        goto exit; <br>    } <br>     <br>    lstrcpyW(pszDomain, (pszAt+1)); <br> <br>    // Restore '@' <br> <br>    *pszAt = chDomainDelimiter; <br> <br>    // We've now split up the site proxy which is the minumum needed to be <br>    // able to call Generate, etc. Now validate the pieces <br> <br>    // validate address type <br>    // nothing to do, this is not user editable so we won't bother to check it <br> <br>    // validate format string  <br>    // Just check that char's after % are valid and that rest of chars <br>    // are in 33 to 127 range.  More could be done but GenerateProxy will <br>    // take care of that. <br> <br>    for (i = 0; i &lt; cchFormat; i++) <br>    { <br>         <br>        if (pszFormat[i] == '%') <br>        { <br>            i++; <br>            if ((i &gt;= cchFormat) || (wcschr(L"sgdmr%", pszFormat[i]) == NULL)) <br>            { <br>           LPWSTR rgwsz[] =  <br>        { <br>        pszFormat <br>        }; <br> <br>        LogError( <br>            pszServer, <br>        iesInvalidFormatString, <br>        EVENTLOG_ERROR_TYPE, <br>        rgwsz, <br>        1); <br> <br>                *pfValid = FALSE; <br>                goto exit; <br>            } <br>        } <br>        else if ((pszFormat[i] &lt; 33) || (pszFormat[i] &gt; 127)) <br>        { <br>       LPWSTR rgwsz[] =  <br>    { <br>    pszFormat <br>    }; <br> <br>        LogError( <br>            pszServer, <br>            iesInvalidFormatString, <br>            EVENTLOG_ERROR_TYPE, <br>            rgwsz, <br>            1); <br> <br>            *pfValid = FALSE; <br>            goto exit; <br>        } <br> <br>    } // for <br>     <br>    // validate domain part <br>    // just check for characters &lt; 33 or &gt; 127 <br> <br>    for (i = 0; i &lt; cchDomain; i++) <br>    { <br>         <br>        if ((pszDomain[i] &lt; 33) || (pszDomain[i] &gt; 127)) <br>        { <br>       LPWSTR rgwsz[] =  <br>    { <br>    pwstrSiteProxy <br>    }; <br> <br>        LogError( <br>            pszServer, <br>            iesBadSiteProxy, <br>            EVENTLOG_ERROR_TYPE, <br>            rgwsz, <br>            1); <br> <br>            *pfValid = FALSE; <br>            goto exit; <br>        } <br> <br>    } // for <br> <br>exit: <br> <br>    FREE(pszType); <br>    FREE(pszFormat); <br>    FREE(pszDomain); <br> <br>    return rc; <br>} <br> <br> <br>//$--FreeProxy------------------------------------------------------------------ <br>//  Frees the memory previously allocated by GenerateProxy for a proxy address <br>//  string. <br>//------------------------------------------------------------------------------ <br>VOID FreeProxy( <br>    IN LPWSTR pszProxy)   // the proxy string to free  May be NULL. <br>{ <br>    FREE(pszProxy); <br>} <br> <br> <br>//$--CloseProxies--------------------------------------------------------------- <br>//  Closes a proxy generation session and frees any associated data.  The DLL <br>//  can now be unloaded.  <br>// ----------------------------------------------------------------------------- <br>VOID CloseProxies( <br>    IN HANDLE hProxySession)    //  Handle to proxy session. <br>{ <br>    if (hProxySession) <br>    { <br>        FREE(GET_SITE_FORMAT(hProxySession)); <br>        FREE(GET_SITE_DOMAIN(hProxySession)); <br>        GET_SITE_DOMAIN_CCH(hProxySession) = 0; <br>        FREE(hProxySession); <br>    } <br> <br>    return; <br>} <br> <br> <br>//$--rcScanAndAppend------------------------------------------------------------ <br>//  For each character in pszSource, it maps it to a (possibly) new character  <br>//  using sAnsiToSMTPMap (chars &gt; MAX_TRANSLATE_TABLE or which map to 0 are  <br>//  deleted) then appends it to pszDest at position iDest.  pszDest and iDest <br>//  are updated. If the location to be written is &gt;= iMaxDest, then RC_ERROR is <br>//  returned. <br>// ----------------------------------------------------------------------------- <br>RC rcScanAndAppend(IN char *        sAnsitoSMTPMap, // char replacement table <br>                   IN LPWSTR        pszSource,      // source buffer <br>                   IN OUT LPWSTR    pszDest,        // dest buffer <br>                   IN OUT ULONG *   piDest,         // current index in dest buffer <br>                   IN ULONG         iMaxDest)       // max dest buffer index <br>{ <br>    RC      rc          = RC_SUCCESS; // only error paths set </code></pre>
<p>
</p>
<pre><code>ULONG   cchSource; <br>    ULONG   i; <br> <br>    // How big is source string? <br>     <br>    cchSource = lstrlenW(pszSource); <br> <br>    if ((cchSource &lt;= 0) || (pszSource == NULL)) <br>    { <br>        // nothing to append; just return success <br>        goto cleanup; <br>    } <br> <br>    // Iterate through source string and add it <br> <br>    for (i = 0; i &lt; cchSource; i++) <br>    { <br>        if ((pszSource[i] &gt;= 0) &amp;&amp; <br>            (pszSource[i] &lt;= MAX_TRANSLATE_TABLE) &amp;&amp;  <br>            (sAnsitoSMTPMap[pszSource[i]] != 0)) <br>        { <br>            // add translated character <br>             <br>            if (*piDest &lt; iMaxDest) <br>            { <br>                pszDest[(*piDest)++] = sAnsitoSMTPMap[pszSource[i]]; <br>            } <br>            else <br>            { <br>                // won't fit; return error <br>                rc = RC_ERROR; <br>                goto cleanup; <br>            } <br>                 <br>        } <br>        // else skip it <br> <br>     } // for <br> <br>     // append final null <br> <br>     pszDest[*piDest] = 0; <br> <br>cleanup: <br>    return rc; <br>} <br> <br> <br>//$--TrimW---------------------------------------------------------------------- <br>// Trims leading blanks from the begining and end of the string. <br>// ----------------------------------------------------------------------------- <br>static VOID TrimW(              // RETURNS nothing (can't fail) <br>    IN OUT PWSTR pwstrSrc)      // String to be trimmed <br>{ <br>    PWSTR pwstrDest = NULL; <br>    INT i = 0; <br> <br>    if (pwstrSrc == NULL) <br>        goto cleanup; <br> <br>    // trim leading <br> <br>    pwstrDest = pwstrSrc; <br>    while ((pwstrSrc!=L'\0') &amp;&amp; fIsWhiteSpaceW(*pwstrSrc)) <br>    { <br>        pwstrSrc++; <br>    } <br> <br>    // copy rest <br> <br>    while (*pwstrSrc!=L'\0') <br>    { <br>        *pwstrDest=*pwstrSrc; <br>        pwstrDest++; <br>        pwstrSrc++; <br>        i++; <br>    } <br>    *pwstrDest = L'\0'; <br>     <br>    // trim trailing <br> <br>    if (i&gt;0) <br>    { <br>        pwstrDest--; <br>        i--; <br> <br>        while ((i&gt;0) &amp;&amp; (fIsWhiteSpaceW(*pwstrDest))) <br>        { <br>            *pwstrDest=L'\0';     <br>            i--; <br>        } <br>    } <br> <br>cleanup: <br>    return; <br>} <br> <br> <br>//$--fIsWhiteSpaceW------------------------------------------------------------- <br>// Determines if character is a white space (space or tab). <br>// ----------------------------------------------------------------------------- <br>static BOOL fIsWhiteSpaceW(     // RETURNS:  TRUE if whitespace, FALSE o/w <br>    WCHAR wc)                   // character to test.  <br>{ <br>    BOOL bRes = TRUE; <br> <br>    if (wc == L' ') <br>        goto cleanup; <br>     <br>    if (wc == L'\t') <br>        goto cleanup; <br> <br>    bRes = FALSE; <br>     <br>cleanup: <br>    return bRes; <br>} <br> <br> <br>//$--LogError------------------------------------------------------------------- <br>// Logs an error to the application log in case of a proxy generation failure <br>// ----------------------------------------------------------------------------- <br>VOID LogError(LPWSTR pszServer, IES ies, WORD wEventType, LPWSTR rgwsz[], WORD cwsz) <br>{ <br>HANDLE h; <br> <br>h = RegisterEventSourceW(pszServer, pszEventSource); <br>if (h != NULL) <br>{ <br>ReportEventW( <br>h, <br>wEventType,  <br>0, <br>ies, <br>NULL, <br>cwsz, <br>0, <br>rgwsz, <br>NULL); <br>DeregisterEventSource(h); <br>} <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
