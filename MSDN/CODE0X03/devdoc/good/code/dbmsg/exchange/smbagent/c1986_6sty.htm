<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOPICS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1996"></a>TOPICS.C</h2>
<pre><code>// --Topics.c------------------------------------------------------------------- <br>//  <br>// This module contains functions for maintaining and using a topic object for  <br>// SMBAGENT.  A topic has a folder, an introductory message, and a list of  <br>// subscribers.   <br>// <br>// The list of subscribers are contained in the introductory  <br>// message as the "TO" recipient list.  The introductory message is contained in <br>// the topic folder.  The topic folder is contained in a root topics folder. <br>// <br>// See TOPCACHE.H for details on the relationship between the STFolderArray, the <br>// STopicCache, and the STopic objects. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>// Cause protected functions to be available. <br>#define FRIEND_OF_STOPIC <br>#define FRIEND_OF_STFOLDERARRAY <br> <br>#include "smbagent.h" <br>#include "topics.CHK" <br> <br>// ----------------------------------------------------------------------------- <br> <br>// Used to open the intro message. <br>static SizedSPropTagArray( 1, ptaIntroMsg) = { 1, {PR_ENTRYID}}; <br>static LPSPropTagArray lpptaIntroMsg = (LPSPropTagArray) &amp;ptaIntroMsg; <br> <br>// Used to load all subscribers. <br>static SizedSPropTagArray( 6, ptaSubscriber) = <br>{ 6,                       <br>    {  <br>        PR_DISPLAY_NAME,    // PT_STRING <br>        PR_ENTRYID,         // PT_BINARY   // for verifying an existing entry <br>        PR_ADDRTYPE,        // PT_STRING <br>        PR_EMAIL_ADDRESS,   // PT_STRING <br>        PR_RECIPIENT_TYPE,  // PT_LONG <br>        PR_ROWID,           // PT_LONG <br>    }  <br>}; <br>static LPSPropTagArray lpptaSubscriber = (LPSPropTagArray) &amp;ptaSubscriber; <br> <br>//$--STopic_HrOpenIntroMsg------------------------------------------------------ <br>// Open the topic message in the already opened topic folder.   <br>// <br>// The intro message has been stored in the MAPI_ASSOCIATED portion of the topic  <br>// folder.  At the time we saved it we gave it a unique message class so that <br>// we could use the FindRow() function to locate it.  This is a quick opperation <br>// since very few items will ever be stored in this location. <br>// <br>// We chose this method rather than storing it in the main portion of the topic <br>// folder to avoid sorting the folder, which could get quite large.  Sorting a <br>// folder is an expensive opperation at the server end and should only be used <br>// when it is necessary. <br>// ----------------------------------------------------------------------------- <br> <br>static HRESULT STopic_HrOpenIntroMsg( <br>    THIS STopic* lpTopic)    // The topic object we are working on. <br>{ <br>    HRESULT         hr          = NOERROR; <br>    ULONG           ulObjType   = 0;       <br>    ULONG           cbEID       = 0;       <br>    LPENTRYID       lpEID       = NULL;    <br>    LPMAPITABLE     lpMsgTable  = NULL;    <br>    LPSRowSet       lpRow       = NULL; <br>     <br>static SPropValue RestrictProp = { PR_MESSAGE_CLASS, 0L, { 0}}; <br>static SRestriction Restrict   = { RES_PROPERTY, { RELOP_EQ, PR_MESSAGE_CLASS, (ULONG)&amp;RestrictProp}}; <br>     <br>    DEBUGPRIVATE ("STopic_HrOpenIntroMsg()"); <br> <br>    hr = CHK_STopic_THIS( lpTopic); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    RestrictProp.Value.LPSZ = INTRO_MSG_CLASS; <br> <br>    // Get the contents table of the topic folder. <br>    hr = MAPICALL( lpTopic-&gt;lpFolder)-&gt;GetContentsTable( lpTopic-&gt;lpFolder, <br>        MAPI_ASSOCIATED | MAPI_DEFERRED_ERRORS, <br>        &amp;lpMsgTable); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Set the columns to return the entry id. <br>    hr = MAPICALL( lpMsgTable)-&gt;SetColumns( lpMsgTable, <br>        lpptaIntroMsg, TBL_BATCH); <br>    if( FAILED( hr)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Find just intro message. <br>    hr = MAPICALL( lpMsgTable)-&gt;Restrict( lpMsgTable, <br>        (LPSRestriction)&amp;Restrict, TBL_BATCH); <br>    if( FAILED( hr)) <br>{ <br>hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>} <br> <br>    // Get the intro message's EID. <br>    hr = MAPICALL( lpMsgTable)-&gt;QueryRows( lpMsgTable, 1, 0, &amp;lpRow); <br>    if( FAILED( hr) || !lpRow || !lpRow-&gt;cRows) <br>    {   // If we don't get at least one message there is a problem with this topic. <br>        if( hr != MAPI_E_NETWORK_ERROR) <br>        { <br>            MODULE_ERROR1( "Intro message for topic '%s' not found!", STFolderArray_GetName(lpTopic-&gt;iTFolderArray)); <br>            hr = HR_LOG( EDK_E_NOT_FOUND); <br>        } <br> <br>        goto cleanup; <br>    } <br> <br>    // Open the intro message for modification. <br>    cbEID = lpRow-&gt;aRow[0].lpProps-&gt;Value.bin.cb; <br>    lpEID = (LPENTRYID) (lpRow-&gt;aRow[0].lpProps-&gt;Value.bin.lpb); <br>    hr = MAPICALL( lpTopic-&gt;lpFolder)-&gt;OpenEntry( lpTopic-&gt;lpFolder, <br>        cbEID, <br>        lpEID, <br>        NULL,  <br>        MAPI_MODIFY | MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN*)&amp;lpTopic-&gt;lpIntroMsg); <br>    if( FAILED(hr) || ulObjType != MAPI_MESSAGE || !lpTopic-&gt;lpIntroMsg) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    ULRELEASE(lpMsgTable); <br>    FREEPROWS(lpRow); <br>    RETURN( hr); <br>} <br> <br>//$--STopic_HrReadSubscriberList----------------------------------------------- <br>// Reads the entire list of subscribers into a SRowSet structure. <br>// ---------------------------------------------------------------------------- <br> <br>static HRESULT STopic_HrReadSubscriberList( <br>    THIS STopic* lpTopic)    // The topic object we are working on. <br>{ <br>    HRESULT     hr          = NOERROR; <br>    static BOOL fInRetryMode = FALSE;   // To recover from MAPI_E_CALL_FAILED. <br> <br>    DEBUGPRIVATE ("STopic_HrReadSubscriberList()"); <br> <br>    hr = CHK_STopic_THIS( lpTopic); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Open the table of recipients. <br>    if( !lpTopic-&gt;lpSubTable) <br>    { <br>        hr = MAPICALL( lpTopic-&gt;lpIntroMsg)-&gt;GetRecipientTable( lpTopic-&gt;lpIntroMsg, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;lpTopic-&gt;lpSubTable); <br>        if( FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // Read the entire list of subscribers into a row set structure. <br>    hr = HrQueryAllRows( lpTopic-&gt;lpSubTable, lpptaSubscriber, NULL, NULL, 0,  <br>        &amp;lpTopic-&gt;lpSubscriberRowSet); <br>     <br>    if( hr == MAPI_E_CALL_FAILED &amp;&amp; !fInRetryMode) <br>    {   // Sometimes this call fails.  We can recover from this if we  <br>        // reopen the intro message and try again.  WARNING: this is a <br>        // recursive call. <br>        ULRELEASE( lpTopic-&gt;lpSubTable); <br> <br>        ULRELEASE( lpTopic-&gt;lpIntroMsg); <br>        hr = STopic_HrOpenIntroMsg( lpTopic); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>         <br>        fInRetryMode = TRUE; <br>        hr = STopic_HrReadSubscriberList( lpTopic); <br>        fInRetryMode = FALSE; <br>        if( FAILED( hr)) <br>            goto cleanup; <br>         <br>// If previous call was successful, all currency pointers <br>// are already set. <br>        goto cleanup; <br>    } <br> <br>    if( FAILED( hr) || !lpTopic-&gt;lpSubscriberRowSet ||  <br>        (lpTopic-&gt;lpSubscriberRowSet &amp;&amp; !lpTopic-&gt;lpSubscriberRowSet-&gt;cRows)) <br>    {   // If we don't find at least one subscriber (topic creator) there is  <br>        // a problem with the intro message. <br>        if( hr != MAPI_E_NETWORK_ERROR) <br>            hr = HR_LOG( EDK_E_NOT_FOUND); <br>        goto cleanup; <br>    } <br> <br>    // Set subscriber currency pointers. <br>    lpTopic-&gt;lpCurSubscriber = NULL; <br>    lpTopic-&gt;lpLastSubscriber = lpTopic-&gt;lpSubscriberRowSet-&gt;aRow +  <br>                                (lpTopic-&gt;lpSubscriberRowSet-&gt;cRows - 1); <br> <br>cleanup: <br>    //ULRELEASE( lpTopic-&gt;lpSubTable); <br>    RETURN( hr); <br>} <br> <br>//$--STopic_Init---------------------------------------------------------------- <br>// Initialize a topic cache item, setting it to an empty state. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED void STopic_Init( <br>    THIS STopic* lpTopic)   // The topic object we are working on. <br>{ <br>    // Zero everything except the index which is set to NOT_FOUND. <br>    memset( lpTopic, 0, sizeof( STopic)); <br>    lpTopic-&gt;iTFolderArray = NOT_FOUND; <br>} <br> <br>//$--STopic_Release------------------------------------------------------------- <br>// Release and free any open interfaces or buffers in the topic cache object and <br>// re-initialize to an empty state. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED void STopic_Release( <br>    THIS STopic* lpTopic)    // The topic object we are working on. <br>{ <br>    lpTopic-&gt;iTFolderArray = NOT_FOUND; <br>    lpTopic-&gt;cUsageCnt = 0; <br>    ULRELEASE( lpTopic-&gt;lpFolder); <br>    ULRELEASE( lpTopic-&gt;lpIntroMsg); <br>    FREEPROWS( lpTopic-&gt;lpSubscriberRowSet); <br>    lpTopic-&gt;lpCurSubscriber = NULL; <br>    lpTopic-&gt;lpLastSubscriber = NULL; <br>    ULRELEASE( lpTopic-&gt;lpSubTable); <br>} <br> <br>//$--STopic_HrOpen-------------------------------------------------------------- <br>// Open all interface pointers and load the subscriber list for this topic cache  <br>// item.  Some things may already be opened or loaded while others may not. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED HRESULT STopic_HrOpen(  <br>    THIS STopic* lpTopic,        // The topic object we are working on. <br>    IN   ULONG   iTFolderArray)  // Index into folder array used to initialize this topic. <br>{ <br>    HRESULT     hr          = NOERROR; <br>    ULONG       ulObjType   = 0; <br>    ULONG       cbEID       = 0; <br>    LPENTRYID   lpEID       = NULL; <br>    LPMAPITABLE lpMsgTable  = NULL; <br>    LPSRowSet   lpRow       = NULL; <br>     <br>    DEBUGPUBLIC ("STopic_HrInit()"); <br> <br>    hr = CHK_STopic_HrInit( lpTopic, iTFolderArray); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // If the topic already has a TFolderArray index verify  <br>    // that it matches what we are trying to load now. <br>    if( lpTopic-&gt;iTFolderArray == NOT_FOUND)  <br>        lpTopic-&gt;iTFolderArray = iTFolderArray; // Remember the index of this topic folder. <br>    else if( lpTopic-&gt;iTFolderArray != iTFolderArray) <br>    {   // This has not been released. <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br>     <br>    // Make sure the folder is not already opened. <br>    if( !lpTopic-&gt;lpFolder) <br>    {   // NO, it's not open so open the folder iterface for this topic. <br>        cbEID = STFolderArray_GetCbEID( iTFolderArray); <br>        lpEID = STFolderArray_GetEID( iTFolderArray); <br>        hr = MAPICALL( lpTopicsFolder)-&gt;OpenEntry( lpTopicsFolder, cbEID, lpEID, NULL, <br>            MAPI_MODIFY|MAPI_DEFERRED_ERRORS, &amp;ulObjType, (LPUNKNOWN FAR *) &amp;lpTopic-&gt;lpFolder); <br> <br>        if( FAILED( hr)) <br>            goto cleanup; <br>    } <br> <br>    // Make sure the introductory message is not already opened. <br>    if( !lpTopic-&gt;lpIntroMsg) <br>    {   //  NO, it's not open so open the introductory message. <br>        hr = STopic_HrOpenIntroMsg( lpTopic); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>    } <br> <br>     <br>    // Make sure the subscriber list is not already loaded. <br>    if( !lpTopic-&gt;lpSubscriberRowSet) <br>    {   //  NO, it's not loaded so read the subscriber list into memory. <br>        hr = STopic_HrReadSubscriberList( lpTopic); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>    } <br> <br>    // Reset the subscriber currency. <br>    lpTopic-&gt;lpCurSubscriber = NULL; <br>             <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>cleanup: <br>    if( FAILED( hr)) <br>        STopic_Release( lpTopic); <br>    RETURN( hr); <br>} <br> <br>//$--STopic_HrFindSubscriber---------------------------------------------------- <br>// Find the sender as a subscriber in the topic object and places its index or  <br>// NOT_FOUND in lpiSubscriber. <br>// <br>// RETURNS: HRESULT error only on failure. NOT_FOUND is NOT an error! <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STopic_HrFindSubscriber( <br>    THIS STopic* lpTopic,       // The topic object we are working on. <br>    OUT ULONG*   lpiSubscriber) // Index of subscriber. <br>{ <br>    HRESULT   hr            = NOERROR; <br>    LPSBinary lpBinRow      = NULL; <br>    LPSBinary lpBinSrchKey  = GetSenderEntryIdPtr(); <br>    LPSRow    lpRow         = lpTopic-&gt;lpSubscriberRowSet-&gt;aRow; <br>    ULONG     iSubscriber   = 0L; <br>    ULONG     fFoundAMatch  = FALSE; <br> <br>    DEBUGPUBLIC ("STopic_HrFindSubscriber()"); <br> <br>    *lpiSubscriber = NOT_FOUND; <br> <br>    // Search for the entry id in our row set. <br>    for( iSubscriber = 0;  <br>         iSubscriber &lt; STopic_GetSubscriberCount( lpTopic);  <br>         iSubscriber++, lpRow++) <br>    { <br>        lpBinRow = &amp;(lpRow-&gt;lpProps[IDX_ENTRYID].Value.bin); <br> <br>        hr = MAPICALL( lpAdrBook)-&gt;CompareEntryIDs( lpAdrBook,  <br>            lpBinSrchKey-&gt;cb, (LPENTRYID) lpBinSrchKey-&gt;lpb,  <br>            lpBinRow-&gt;cb,     (LPENTRYID) lpBinRow-&gt;lpb, 0, &amp;fFoundAMatch); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>         <br>        if( fFoundAMatch) <br>        { <br>            *lpiSubscriber = iSubscriber; <br>            goto cleanup; <br>        } <br>    } <br> <br>cleanup: <br>    RETURN( hr);     <br>} <br> <br>//$--STopic_GetFirstSubscriber-------------------------------------------------- <br>// RETURN the first subscriber's row of properties. <br>// ----------------------------------------------------------------------------- <br> <br>LPSRow STopic_GetFirstSubscriber( <br>    THIS STopic* lpTopic)        // The topic object we are working on. <br>{ <br>    DEBUGPUBLIC ("STopic_GetFirstSubscriber()"); <br> <br>    if( !lpTopic-&gt;lpSubscriberRowSet) <br>        return( NULL); <br>    lpTopic-&gt;lpCurSubscriber = lpTopic-&gt;lpSubscriberRowSet-&gt;aRow; <br>    return( lpTopic-&gt;lpCurSubscriber); <br>} <br> <br>//$--STopic_GetNextSubscriber--------------------------------------------------- <br>// RETURN the next subscriber's row of properties. <br>// ----------------------------------------------------------------------------- <br> <br>LPSRow STopic_GetNextSubscriber( <br>    THIS STopic* lpTopic)        // The topic object we are working on. <br>{ <br>    DEBUGPUBLIC ("STopic_GetNextSubscriber()"); <br> <br>    // Had we already reached past the end of the list? <br>    if( lpTopic-&gt;lpCurSubscriber) <br>    {   // NO. Then are we currently at the end of the list? <br>        if( lpTopic-&gt;lpCurSubscriber == lpTopic-&gt;lpLastSubscriber) <br>            lpTopic-&gt;lpCurSubscriber = NULL;    // YES, we have reached the end. <br>        else     <br>            lpTopic-&gt;lpCurSubscriber ++;    // Nope, there are more subscribers. <br>    } <br>    return( lpTopic-&gt;lpCurSubscriber); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Modifies the list of subscribers in the intro message and in memory.  You  <br>// should use STopic_HrAddSubscriber() or STopic_HrRemoveSubscriber() and not <br>// this function directly. <br>// <br>// NOTE: The subscriber list will be invalid after this call. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STopic_HrModifySubscriberList( <br>    THIS STopic*    lpTopic,    // The topic object we are working on. <br>    IN   LPADRLIST  lpAdrList,  // The address list to add or remove. <br>    IN   ULONG      ulFlags)    // MODRECIP_ADD or MODRECIP_REMOVE <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC ("STopic_HrModifySubscriberList()"); <br> <br>    // Add or Remove the entry to or from the subscriber list in the intro message. <br>    hr = MAPICALL( lpTopic-&gt;lpIntroMsg)-&gt;ModifyRecipients( lpTopic-&gt;lpIntroMsg,  <br>        ulFlags, lpAdrList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Save changes to the message. <br>    hr = MAPICALL( lpTopic-&gt;lpIntroMsg)-&gt;SaveChanges( lpTopic-&gt;lpIntroMsg,  <br>        FORCE_SAVE | KEEP_OPEN_READWRITE); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Free the subscriber list so that next time we work with this <br>    // topic we will get a fresh list with updated row ids. <br>    STopic_FreeSubscriberList( lpTopic); <br> <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>//$--STopic_HrDeleteSubscriber-------------------------------------------------- <br>// Delete the subscriber from the recipient list of the Introductory message and <br>// then free the subscriber list so that next time we work with this topic we <br>// will get a fresh list with updated row ids. <br>// <br>// NOTE: The subscriber list will be invalid after this call. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STopic_HrDeleteSubscriber( <br>    THIS STopic* lpTopic,            // The topic object we are working on. <br>    IN   ULONG   iSubscriber)        // The index of the subscriber to delete. <br>{ <br>    HRESULT     hr              = NO_ERROR; <br>    ULONG       cBytes          = 0; <br>    LPADRLIST   lpAdrList       = NULL; <br>    LPSRow      lpSubscriberRow = NULL; <br> <br>    DEBUGPUBLIC( "STopic_HrDeleteSubscriber()"); <br>    hr = CHK_STopic_HrDeleteSubscriber( lpTopic, iSubscriber); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Allocate memory for the address list buffer. <br>    cBytes = CbNewADRLIST(1); <br>    hr = MAPIAllocateBuffer( cBytes, &amp;lpAdrList); <br>    if( FAILED( hr)) <br>    { <br>        hr = HR_LOG( E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br>    memset( lpAdrList, 0, cBytes); <br> <br>    // Build an address list with one entry using the properties <br>    // found in the subscriber row passed in by the user. <br>    lpSubscriberRow = lpTopic-&gt;lpSubscriberRowSet-&gt;aRow + iSubscriber; <br>    lpAdrList-&gt;cEntries = 1; <br>    lpAdrList-&gt;aEntries[0].cValues  = lpSubscriberRow-&gt;cValues; <br>    lpAdrList-&gt;aEntries[0].rgPropVals = lpSubscriberRow-&gt;lpProps; <br> <br>    // Remove the subscriber from intro msg and memory buffer. <br>    hr = STopic_HrModifySubscriberList( lpTopic, lpAdrList, MODRECIP_REMOVE); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    // *************** W A R N I N G ! ************** <br>    // Do NOT use FREEPADRLIST on this since it points to data (lpSubscriberRow-&gt;lpProps) <br>    // that will be freed in another way (or already has been freed). <br>    MAPIFREEBUFFER( lpAdrList); <br>    // *************** W A R N I N G ! ************** <br> <br>    RETURN( hr); <br>} <br>     <br>//$--STopic_GetCopyOfSubscriberRowSet------------------------------------------- <br>// Returns a copy of the subscriber's row set as andress list this MUST be freed <br>// using FREEPROWS when the user is done with it. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STopic_GetCopyOfSubscriberRowSet(  <br>    THIS STopic*    lpTopic,    // The topic object we are working on. <br>    OUT  LPADRLIST* lppAdrList) // Ptr to LPADRLIST that we will return. <br>{ <br>    HRESULT         hr          = NOERROR; <br>    LPADRENTRY      lpAdrEntry  = NULL;         // Destination. <br>    LPSRow          lpRow       = NULL;         // Source. <br>    LPSRow          lpLastRow   = NULL; <br>    LPSPropValue    lpProps     = NULL; <br>    ULONG           cRows       = 0; <br>    ULONG           cBytes      = 0; <br>    ULONG           cBytesCopied= 0; <br> <br>    DEBUGPUBLIC( "STopic_GetCopyOfSubscriberRowSet()"); <br>    hr = CHK_STopic_GetCopyOfSubscriberRowSet( lpTopic, lppAdrList); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Alocate enough memory for an address list to hold all subscribers. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    cRows = lpTopic-&gt;lpSubscriberRowSet-&gt;cRows; <br>    cBytes = CbNewADRLIST( cRows); <br>    hr = MAPIAllocateBuffer( cBytes, lppAdrList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>    memset( *lppAdrList, 0, cBytes); <br>     <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Loop through each subscriber row and copy the properties to a new buffer and <br>// a pointer to the new buffer into the address list. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    lpAdrEntry = (*lppAdrList)-&gt;aEntries;       // Destination. <br>    lpRow = lpTopic-&gt;lpSubscriberRowSet-&gt;aRow;  // Source. <br>    lpLastRow = lpRow + (cRows - 1); <br>    while( lpRow &lt;= lpLastRow) <br>    { <br>        // Count the bytes needed for the new property array. <br>        hr = ScCountProps( lpRow-&gt;cValues, lpRow-&gt;lpProps, &amp;cBytes); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>         <br>        // Allocate a new buffer to hold the copied properties. <br>        hr = MAPIAllocateBuffer( cBytes, &amp;lpProps); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>        memset( lpProps, 0, cBytes); <br> <br>        // Copy the subscriber properties to the new buffer. <br>        hr = ScCopyProps( lpRow-&gt;cValues, lpRow-&gt;lpProps, lpProps, &amp;cBytesCopied); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>        ASSERTERROR( cBytes == cBytesCopied, "ScCountProps &amp; ScCopyProps are inconsistent!"); <br>         <br>        // Set a single address list entry. <br>        (*lppAdrList)-&gt;cEntries ++; <br>        lpAdrEntry-&gt;cValues = lpRow-&gt;cValues; <br>        lpAdrEntry-&gt;rgPropVals = lpProps; <br>        lpProps = NULL;     // Just incase we bail out. <br> <br>        // Move on to the next subscriber. <br>        lpRow ++; <br>        lpAdrEntry ++; <br>    } <br>         <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>cleanup: <br>    if( FAILED( hr)) <br>        FREEPADRLIST( *lppAdrList); <br> <br>    return( hr); <br>} <br> <br>// ----------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
