<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MESSAGES.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1988"></a>MESSAGES.C</h2>
<pre><code>// --Messages.c--------------------------------------------------------------------- <br>//  <br>//  This module contains miscellaneous utility procedures called <br>//  by the rest of SMBAGENT procedures to deal with <br>//  - creating a folder in a given folder; <br>//  - getting the sender's property values in a given message; <br>//  - getting the recipient list from a given message; <br>//  - etc. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "messages.chk" <br> <br>#include "smbagent.h" <br>#include "resource.h" <br> <br>#define EDK_ERROR_MEMORY_ALLOCATION     0x00000000U <br> <br>extern HANDLE hEventSource; <br> <br>// Global variables <br>externLPMAPISESSIONlphSession; <br>extern  LPADRBOOK       lpAdrBook; <br>extern  LPMAPIFOLDER    lpTopicsFolder; <br>extern  LPMAPIFOLDER    lpNDRFolder; <br>extern  HINSTANCE       hInst; <br> <br>extern  TCHAR           szTextBuf[]; <br>extern  TCHAR           szSubjBuf[]; <br>extern  TCHAR           szCmdBuf[]; <br> <br>externLPENTRYIDlpSMBAgentEID; <br>externULONGcbSMBAgentEID; <br> <br>LPADRLIST   lpSenderAddr = NULL; <br> <br>//$--HrGetSenderProps---------------------------------------------------------- <br>// Gets all properties of the sender's message that we use while processing it. <br>// The results are placed in a dynamically allocated array named lpSenderProps. <br>// There are defined constants that index into this array in SMBAGENT.H. <br>// Also transforms the sender props into a property array that can be used for  <br>// replying to the sender. <br>// ---------------------------------------------------------------------------- <br> <br>HRESULT HrGetSenderProps( <br>    IN  LPMESSAGE       lpMessage)  // Ptr.to the msg.to read sender prop.from <br>{ <br>    HRESULT         hr              = NOERROR;            <br>    ULONG           ulObjType       = 0; <br>    ULONG           cValues         = 0; <br>    LPSPropTagArray lpSenderPTags   = NULL; <br>   ULONGfCompare= FALSE; <br>    int             ii              = 0; <br>    LPSPropValue    lpRecipProps    = NULL; <br>  <br>    static const SizedSPropTagArray( 7, aptSenderProp) =  <br>    {   7,  <br>        {  <br>            PR_SENDER_NAME,         // The order of the first 5 must NOT change. <br>            PR_SENDER_ENTRYID, <br>            PR_SENDER_ADDRTYPE, <br>            PR_SENDER_EMAIL_ADDRESS, <br>            PR_MESSAGE_FLAGS,      // Placeholder replaced by HrAddRecipProps(). <br>            PR_MESSAGE_CLASS, <br>            PR_SUBJECT, <br>        }  <br>    }; <br> <br>    static ULONG aRecipPropTags[] =  <br>    {// This column's props will replace    these properties. <br>        PR_DISPLAY_NAME,                    // PR_SENDER_NAME          <br>        PR_ENTRYID,                         // PR_SENDER_ENTRYID       <br>        PR_ADDRTYPE,                        // PR_SENDER_ADDRTYPE      <br>        PR_EMAIL_ADDRESS,                   // PR_SENDER_EMAIL_ADDRESS <br>        PR_RECIPIENT_TYPE,                  // PR_MESSAGE_FLAGS        <br>    }; <br>    int nRecipTags = ARRAY_CNT( aRecipPropTags); <br> <br>    DEBUGPUBLIC( "HrGetSenderProps()"); <br> <br>    hr = CHK_HrGetSenderProps( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    ASSERTERROR( lpSenderProps == NULL, "lpSenderProps should be NULL"); <br>    ASSERTERROR( lpSenderAddr  == NULL, "lpSenderAddr should be NULL"); <br> <br>    // Get the properties from the message originator. <br>    hr = MAPICALL(lpMessage)-&gt;GetProps( lpMessage, <br>        (LPSPropTagArray)&amp;aptSenderProp, <br>        fMapiUnicode, &amp;cValues, &amp;lpSenderProps); <br>    if( hr == MAPI_W_ERRORS_RETURNED) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Check to make sure we got the right properties <br>    if( cValues != 7 || lpSenderProps == NULL) { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR( lpSenderProps[IDX_SENDER_NAME].ulPropTag == PR_SENDER_NAME &amp;&amp; <br>        lpSenderProps[IDX_SENDER_ENTRYID].ulPropTag       == PR_SENDER_ENTRYID &amp;&amp; <br>        lpSenderProps[IDX_SENDER_ADDRTYPE].ulPropTag      == PR_SENDER_ADDRTYPE &amp;&amp; <br>        lpSenderProps[IDX_SENDER_EMAIL_ADDRESS].ulPropTag == PR_SENDER_EMAIL_ADDRESS &amp;&amp; <br>        lpSenderProps[IDX_MESSAGE_FLAGS].ulPropTag        == PR_MESSAGE_FLAGS &amp;&amp; <br>        lpSenderProps[IDX_MESSAGE_CLASS].ulPropTag        == PR_MESSAGE_CLASS &amp;&amp; <br>        lpSenderProps[IDX_SUBJECT].ulPropTag              == PR_SUBJECT, <br>        "Mangled sender props detected"); <br> <br>// Verify that the message is NOT from the SMBAgent profile. <br>hr = MAPICALL( lphSession)-&gt;CompareEntryIDs( lphSession, <br>        lpSenderProps[IDX_SENDER_ENTRYID].Value.bin.cb, <br>        (LPENTRYID) lpSenderProps[IDX_SENDER_ENTRYID].Value.bin.lpb, <br>        cbSMBAgentEID, lpSMBAgentEID, 0L, &amp;fCompare); <br>if( FAILED( hr)) <br>goto cleanup; <br> <br>if (fCompare == TRUE) <br>{ // Message is from SMBAgent profile. <br>MODULE_WARNING( "Skipping message from SMBAgent profile"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>    // Create a single entry address list. <br>    hr = HrMAPICreateSizedAddressList( 1, &amp;lpSenderAddr); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Set the single entry to the sender properties. <br>    hr = HrMAPISetAddressList( 0, nRecipTags, lpSenderProps, lpSenderAddr); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Get the pointer to the copy of the sender properties and transform <br>    // them into recipient properties. <br>    lpRecipProps = (lpSenderAddr)-&gt;aEntries[0].rgPropVals; <br>    for( ii = 0; ii &lt; nRecipTags; ++ii) <br>    { <br>        lpRecipProps[ii].ulPropTag = aRecipPropTags[ii]; <br>        lpRecipProps[ii].dwAlignPad = 0L; <br>    } <br>     <br>    // Set PR_RECIPIENT_TYPE's value.  All other values have been set <br>    // correctly by HrGetSenderProps(). <br>    lpRecipProps[nRecipTags - 1].Value.l = MAPI_TO; <br> <br>cleanup: <br>    // Free globals only if there was a failure.   <br>    if( FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER( lpSenderProps); <br>        FREEPADRLIST( lpSenderAddr); <br>    } <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrEmbedMsgInMsg------------------------------------------------------------ <br>//  Embed a message within a message. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT HrEmbedMsgInMsg( <br>    IN LPMESSAGE lpNewMsg,      // Ptr to msg that will contain embedded msg. <br>    IN LPMESSAGE lpMsgToEmbed)  // Ptr to msg to embed. <br>{ <br>    HRESULT             hr              = 0; <br>    ULONG               ulAttNum        = 0; <br>    LPATTACH            lpNewAttach     = NULL; <br>    LPMESSAGE           lpEmbeddedMsg   = NULL; <br>    LPSPropProblemArray lpProblems      = NULL; <br> <br>    SPropValue rgPropValue[2] = { <br>        {PR_ATTACH_METHOD,      0, { ATTACH_EMBEDDED_MSG}}, <br>        {PR_RENDERING_POSITION, 0, { 0}} <br>    }; <br> <br>    hr = CHK_HrEmbedMsgInMsg( lpNewMsg, lpMsgToEmbed); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Create the attachment in the message. <br>    hr = MAPICALL(lpNewMsg)-&gt;CreateAttach( lpNewMsg, <br>        NULL,       // IID for returned object <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;ulAttNum, <br>        &amp;lpNewAttach); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ASSERT_IUNKNOWN_PTR( lpNewAttach, "INVALID lpNewAttach pointer"); <br> <br>    // Set the attachment method and rendering position. <br>    if( ulAttNum &gt; 0) <br>            rgPropValue[1].Value.ul = 400;  // arbitrary value for end of message <br>    hr = MAPICALL( lpNewAttach)-&gt;SetProps( lpNewAttach, <br>        ARRAY_CNT( rgPropValue), <br>        rgPropValue, <br>        NULL); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Open the property as a message. <br>    hr = MAPICALL( lpNewAttach)-&gt;OpenProperty( lpNewAttach, <br>        PR_ATTACH_DATA_OBJ,  <br>        (LPIID)&amp;IID_IMessage, <br>        0, <br>        MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS, <br>        (LPUNKNOWN *)&amp;lpEmbeddedMsg); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ASSERT_IUNKNOWN_PTR( lpEmbeddedMsg, "INVALID lpEmbeddedMsg pointer"); <br> <br>    // Copy message to attached message. <br>    hr = MAPICALL( lpMsgToEmbed)-&gt;CopyTo( lpMsgToEmbed, <br>        0, NULL, NULL, 0, NULL, <br>        (LPIID) &amp;IID_IMessage, <br>        lpEmbeddedMsg, 0, <br>        &amp;lpProblems); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>    if( hr == MAPI_W_ERRORS_RETURNED) <br>    {   // If you find that this error occurs check lpProblems to see what went wrong. <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Save changes to the embedded message. <br>    hr = MAPICALL( lpEmbeddedMsg)-&gt;SaveChanges( lpEmbeddedMsg, 0); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Save changes to the attachment. <br>    hr = MAPICALL( lpNewAttach)-&gt;SaveChanges( lpNewAttach, 0); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    MAPIFREEBUFFER(lpProblems); <br>    ULRELEASE( lpEmbeddedMsg); <br>    ULRELEASE( lpNewAttach); <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrCopyMessageBody--------------------------------------------------------- <br>// Copy large (&gt;=32K) PR_RTF_COMPRESSED body part.  The property must exist. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrCopyMessageBody( <br>    IN  LPMESSAGE   lpSrcMsg, <br>    IN  LPMESSAGE   lpDestMsg) <br>{ <br>    HRESULT             hr              = NOERROR; <br>STATSTGStatStg= {0}; <br>ULARGE_INTEGERcbWritten= {0}; <br>     <br>    PVIRTUALSTREAMONPROPERTYpvsSrcMsgBody   = NULL, <br>pvsDestMsgBody  = NULL; <br> <br>    DEBUGPUBLIC( "HrCopyMessageBody()"); <br> <br>// Prepare to copy message body &gt;= 32K <br>hr = HrOpenVirtualStreamOnProperty( <br>(LPMAPIPROP)lpSrcMsg,  <br>PR_RTF_COMPRESSED,  <br>0L, <br>&amp;pvsSrcMsgBody); <br>if( FAILED( hr)) <br>goto cleanup; <br> <br>// Get size of body property. <br>hr = MAPICALL( pvsSrcMsgBody)-&gt;Stat( pvsSrcMsgBody, <br>&amp;StatStg, 0L); <br>if( FAILED( hr)) <br>goto cleanup; <br> <br>// Open receiving message <br>hr = HrOpenVirtualStreamOnProperty(  <br>(LPMAPIPROP)lpDestMsg,  <br>PR_RTF_COMPRESSED,  <br>MAPI_MODIFY | MAPI_CREATE,  <br>&amp;pvsDestMsgBody); <br>if( FAILED( hr)) <br>goto cleanup; <br> <br>// Perform complete copy <br>hr = MAPICALL( pvsSrcMsgBody)-&gt;CopyTo( pvsSrcMsgBody, <br>(LPSTREAM) pvsDestMsgBody, <br>StatStg.cbSize, <br>NULL, <br>&amp;cbWritten); <br>if( FAILED( hr)) <br>goto cleanup; <br> <br>// Verify all bytes were written as expected <br>if( MAKEDWORDLONG( cbWritten.LowPart, cbWritten.HighPart) != <br>MAKEDWORDLONG( StatStg.cbSize.LowPart, StatStg.cbSize.HighPart)) <br>{ <br>hr = HR_LOG( E_FAIL); <br>goto cleanup; <br>} <br> <br>// Commit change to destination message <br>hr = MAPICALL( pvsDestMsgBody)-&gt;Commit( pvsDestMsgBody, 0L); <br>if( FAILED( hr)) <br>goto cleanup; <br> <br>cleanup: <br>   ULRELEASE( pvsSrcMsgBody); <br>ULRELEASE( pvsDestMsgBody); <br> <br>    RETURN( hr); <br>} <br> <br>// -------------------------------------------------------------------------- <br>// Property arrays for HrDuplicateMessage. <br>// -------------------------------------------------------------------------- <br> <br>SizedSPropTagArray( 14, rgptPropsToCopyForKeep) =  <br>{ 14, <br>    {  <br>        PR_SENDER_NAME, <br>        PR_SENDER_ENTRYID, <br>        PR_SENDER_ADDRTYPE, <br>        PR_SENDER_EMAIL_ADDRESS, <br>        PR_SENT_REPRESENTING_NAME, <br>        PR_SENT_REPRESENTING_ENTRYID, <br>        PR_SENT_REPRESENTING_ADDRTYPE, <br>        PR_SENT_REPRESENTING_EMAIL_ADDRESS, <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_MESSAGE_DELIVERY_TIME, <br>PR_IMPORTANCE, <br>PR_EXPIRY_TIME, <br>        PR_MESSAGE_ATTACHMENTS, <br>PR_RTF_COMPRESSED <br>    } <br>}; <br> <br>// An important thing to note is that you can not include the PR_SENDER...  <br>// or the PR_SEND_REPRESENTING... properties when creating a message for <br>// to be sent.  It causes problems for One Off Recipients. <br>SizedSPropTagArray( 6, rgptPropsToCopyForSend) =  <br>{ 6, <br>    {  <br>        PR_CLIENT_SUBMIT_TIME, <br>        PR_MESSAGE_DELIVERY_TIME, <br>PR_IMPORTANCE, <br>PR_EXPIRY_TIME, <br>        PR_MESSAGE_ATTACHMENTS, <br>PR_RTF_COMPRESSED <br>    } <br>}; <br> <br>// Properties to copy when duplicating a message for keeping or sending. <br>LPSPropTagArray lpPropsToCopyForKeep = (LPSPropTagArray) &amp;rgptPropsToCopyForKeep; <br>LPSPropTagArray lpPropsToCopyForSend = (LPSPropTagArray) &amp;rgptPropsToCopyForSend; <br> <br>//$--HrDuplicateMessage ----------------------------------------------------- <br>// Duplicates a message by creating a new message in the given folder <br>// and copying all fields of the given message in the new message <br>// -------------------------------------------------------------------------- <br> <br>HRESULT HrDuplicateMessage(  <br>    IN  LPMESSAGE       lpSrcMsg,           // pointer to the source message <br>    IN  LPMAPIFOLDER    lpDestFolder,       // pointer to the destination folder <br>    IN  ULONG           ulFlags,            // Intended to set MAPI_ASSOCIATED <br>    IN  LPSPropTagArray lpPropsToCopy,      // Pass in one of the above array pointers. <br>    OUT LPMESSAGE       *lppDestMsg)        // Addr of var.to contain ptr.to new msg. <br>{ <br>    HRESULT             hr              = NOERROR; <br>    LPSPropProblemArray lpProblemArray  = NULL; <br> <br>    DEBUGPUBLIC( "HrDuplicateMessage()"); <br> <br>    hr = CHK_HrDuplicateMessage( lpSrcMsg, lpDestFolder, ulFlags, lppDestMsg); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Create a new message in the given folder <br>    hr = MAPICALL(lpDestFolder)-&gt;CreateMessage( lpDestFolder, <br>    NULL, ulFlags | MAPI_DEFERRED_ERRORS,  <br>        lppDestMsg); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Duplicate content of source message in the new message. <br>    hr = MAPICALL(lpSrcMsg)-&gt;CopyProps( lpSrcMsg,  <br>        lpPropsToCopy,  <br>        0,  <br>        NULL,  <br>        &amp;IID_IMessage, <br>        *lppDestMsg,  <br>        0,  <br>        &amp;lpProblemArray); <br> <br>    if( FAILED( hr) || hr == MAPI_W_ERRORS_RETURNED) <br>    { <br>        if( lpProblemArray != NULL &amp;&amp; <br>            lpProblemArray-&gt;cProblem == 1 &amp;&amp; <br>            lpProblemArray-&gt;aProblem-&gt;ulPropTag == PR_RTF_COMPRESSED) <br>        { // CopyProps may fail for message bodies sized &gt;= 32K. <br>            hr = HrCopyMessageBody( lpSrcMsg, *lppDestMsg); <br>            if( FAILED( hr)) <br>                goto cleanup; <br>        } <br>        else <br>        { <br>            hr = HR_LOG( E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpProblemArray); <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrSendMessage --------------------------------------------------------- <br>// Creates and sends an IPM message with the given Subject, Recipient list, <br>// text and optional attachment(s). <br>// ------------------------------------------------------------------------- <br> <br>HRESULT HrSendMessage(  <br>    IN  LPADRLIST   lpRecipList,    // Recipient list of the message <br>    IN  LPTSTR      lpszSubject,    // Message Subject string <br>    IN  LPTSTR      lpszText,       // Message text string <br>    IN  int         cNAttach,       // # of attachments to be included <br>    IN  LPMESSAGE   lpAtts[])       // Array of pointers to attachment messages <br>{ <br>    HRESULT     hr              = NOERROR; <br>    int         i               = 0; <br>    ULONG       ulAttNum        = 0; <br>    LPMESSAGE   lpNewMsg        = NULL, <br>                lpEmbeddedMsg   = NULL; <br>    LPATTACH    lpNewAttach     = NULL; <br> <br>    DEBUGPUBLIC( "HrSendMessage()"); <br> <br>    hr = CHK_HrSendMessage( lpRecipList, lpszSubject, lpszText, cNAttach, lpAtts); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Create a message in the NDR folder. We don't use the TOPICS folder because we  <br>    // can't create a message to send when using public topic folders. <br>    hr = MAPICALL(lpNDRFolder)-&gt;CreateMessage( lpNDRFolder, <br>        NULL, MAPI_DEFERRED_ERRORS, &amp;lpNewMsg); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>    ASSERTERROR( lpNewMsg!=NULL, "NULL lpNewMsg."); <br> <br>    // Set the recipient list to that which has been given. <br>    hr = MAPICALL(lpNewMsg)-&gt;ModifyRecipients( lpNewMsg, 0L, lpRecipList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Encapsulate property setting in block to keep the code clear. <br>    { <br>        SInitPropValue SPropValues[] = <br>        { <br>            {PR_DELETE_AFTER_SUBMIT, 0, TRUE}, <br>            {PR_MESSAGE_CLASS,       0, (ULONG)SMBAGENT_MSG_CLASS }, <br>            {PR_SUBJECT,             0, (ULONG)lpszSubject}, <br>            {PR_BODY,                0, (ULONG)lpszText}, <br>        }; <br> <br>        hr = MAPICALL(lpNewMsg)-&gt;SetProps( lpNewMsg,  <br>            4L, (LPSPropValue) SPropValues, NULL); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>    } <br> <br>    // If lpAtts!=NULL, include it in the message <br>    for( i=0; i&lt;cNAttach; i++) <br>    { <br>        hr = HrEmbedMsgInMsg( lpNewMsg, lpAtts[i]); <br>        if( FAILED(hr)) <br>            goto cleanup; <br>    } <br>     <br>    // Submit the message <br>    hr = MAPICALL(lpNewMsg)-&gt;SubmitMessage( lpNewMsg, FORCE_SUBMIT); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    ULRELEASE ( lpNewMsg); <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrSendErrReport ---------------------------------------------------------- <br>// Sends an error report to the originator of the given message, including <br>// the given message as an attachment in the error report. <br>// ---------------------------------------------------------------------------- <br> <br>HRESULT HrSendErrReport( <br>    IN LPMESSAGE    lpMessage,  //Ptr.to the message to be included in report <br>    IN int          iErrText)   //Index to text string <br>{ <br>    HRESULT         hr              = NOERROR;    <br>    LPMESSAGE       lpAtt           = NULL; <br>    int             cStrLen         = 0; <br> <br>    DEBUGPUBLIC( "HrSendErrReport()"); <br> <br>    hr = CHK_HrSendErrReport( lpMessage, iErrText); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Load the Subject &amp; Text field strings. <br>    cStrLen = LoadStringA( hInst, IDS_SUBJ_ERROR, (LPTSTR)&amp;szSubjBuf, MAXSUBJLEN); <br>    cStrLen = LoadStringA( hInst, iErrText, (LPTSTR)&amp;szTextBuf, MAXTEXTLEN); <br> <br>    // Send the error report, including the given message as an attachment <br>    lpAtt = lpMessage; <br>    hr = HrSendMessage( lpSenderAddr, szSubjBuf, szTextBuf, 1, &amp;lpAtt); <br>    if( FAILED( hr)); <br>     <br>    RETURN( hr); <br>} <br> <br>//$--HrSendConfirmReport ------------------------------------------------------ <br>// Sends a confirmation to the given address w. reference to the given command <br>// ---------------------------------------------------------------------------- <br> <br>HRESULT HrSendConfirmReport( <br>    IN LPMESSAGE    lpMessage,      // Pointer to the command message <br>    IN int          iCmdName,       // Resource Id of command name <br>    IN int          iCnfText,       // Index to text string <br>    IN LPMESSAGE    lpAttach) <br>{ <br>    HRESULT         hr                  = NOERROR;  <br>    LPMESSAGE       alpAttachments[]    = {NULL, NULL}; <br>    int             cNAttach            = 1L,   // &gt;=1 attachment in error reports <br>                    cStrLen             = 0L; <br> <br>    DEBUGPUBLIC( "HrSendConfirmReport()"); <br> <br>    hr = CHK_HrSendConfirmReport( lpMessage, iCmdName, iCnfText, lpAttach); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    alpAttachments[0] = lpMessage; <br>    if( lpAttach != NULL) <br>    { <br>        alpAttachments[1] = lpAttach; <br>        cNAttach = 2; <br>    } <br> <br>    // Load subject &amp; text field strings <br>    cStrLen = LoadString( hInst, iCmdName, szSubjBuf, MAXSUBJLEN); <br>    cStrLen = LoadString( hInst, IDS_CNF_SUBJECT, szSubjBuf + cStrLen, MAXSUBJLEN - cStrLen); <br>    cStrLen = LoadString( hInst, iCnfText, szTextBuf, MAXTEXTLEN); <br> <br>    // Send the confirmation report, including the command message as an attachment <br>    hr = HrSendMessage( lpSenderAddr, szSubjBuf, szTextBuf, cNAttach, alpAttachments); <br>    if( FAILED( hr)); <br>     <br>    RETURN( hr); <br>} <br> <br>// ---------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
