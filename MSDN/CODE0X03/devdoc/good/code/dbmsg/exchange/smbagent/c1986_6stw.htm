<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOPCACHE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1994"></a>TOPCACHE.C</h2>
<pre><code>// --TopCache.C---------------------------------------------------------------- <br>//  <br>// This module contains functions for maintaining and using a topic cache for  <br>// SMBAGENT. <br>// <br>// See TOPCACHE.H for details on how the cache works and the relationship  <br>// between the STFolderArray, the STopicCache, and the STopic objects. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>// Cause protected functions to be available. <br>#define FRIEND_OF_STOPIC <br>#define FRIEND_OF_STOPICCACHE <br> <br>#include "smbagent.h" <br>#include "TopCache.CHK" <br> <br>// ----------------------------------------------------------------------------- <br>// This object contains a cache of opened topics.  The functions whose  <br>// names that begin with "STopicCache_" work on this object. <br>// ----------------------------------------------------------------------------- <br> <br>static STopicCache TopicCache; <br> <br>//$--STopicCache_Search--------------------------------------------------------- <br>// Search the cache for a folder with the given index.  Note that items in the  <br>// cache are always changing slots.  What we are looking for is a topic object <br>// whose folder index matches the given index. <br>// <br>// RETURNS: The index in the cache of the topic or NOT_FOUND. <br>// ----------------------------------------------------------------------------- <br> <br>static ULONG STopicCache_Search( <br>    IN  ULONG       iTFolderArray)  // Index into TFolderArray of topic we want. <br>{ <br>    ULONG   ii  = 0; <br> <br>    // Search for the folder in the cache. <br>    for( ii = 0; ii &lt; TopicCache.cTotItems; ii ++) <br>    { <br>        if( STopic_GetFolderIndex( TopicCache.lpTopicArray + ii) == iTFolderArray) <br>            return( ii);     <br>    } <br>    return( NOT_FOUND); <br>} <br> <br>//$--STopicCache_MoveSlotToTop-------------------------------------------------- <br>// Move the item in the topic iSlot to the top of the cache and all other items  <br>// down. <br>// ----------------------------------------------------------------------------- <br> <br>static void STopicCache_MoveSlotToTop(  <br>    IN ULONG iSlot)             // Index of the slot to move to the top. <br>{ <br>    STopic TempTopic; <br>     <br>    // Do we really need to move something? <br>    if( iSlot) <br>    {   // YES, so move slot from its present location to the top. <br> <br>        // Copy the item in the iSlot into a temporary buffer. <br>        memmove( &amp;TempTopic, TopicCache.lpTopicArray + iSlot, sizeof( STopic)); <br>     <br>        // Move the first items down until iSlot is filled. <br>        memmove( TopicCache.lpTopicArray + 1, TopicCache.lpTopicArray, sizeof( STopic) * iSlot); <br>     <br>        // Copy the temporary buffer back into the top of the cache. <br>        memmove( TopicCache.lpTopicArray, &amp;TempTopic, sizeof( STopic)); <br>    }     <br> <br>    // Increment the usage count of the first item in the cache. <br>    STopic_IncUsageCnt( TopicCache.lpTopicArray); <br>} <br> <br>//$--STopicCache_FreeFirstTopicSlot--------------------------------------------- <br>// Frees the first slot in the cache to be used for a new topic. <br>// RETURNS: a pointer to the first slot in the cache. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED STopic* STopicCache_FreeFirstTopicSlot() <br>{ <br>    ULONG ii        = 0; <br>    ULONG iSlot     = NOT_FOUND; <br>    ULONG cLowestCnt= MAX_ULONG; <br>    ULONG cUsageCnt = 0; <br> <br>    // First check to see if the cache is full. <br>    if( TopicCache.cTotItems &lt; TopicCache.cMaxItems) <br>    {   // Cache is not full so move the first empty slot to the top and return it. <br>        STopicCache_MoveSlotToTop( TopicCache.cTotItems); <br>        TopicCache.cTotItems ++; <br>        return( TopicCache.lpTopicArray); <br>    } <br> <br>    // Start at the drop zone of the cache and search to the end for the slot  <br>    // whose item has had the least use.  If more than one item has the same  <br>    // low usage count then the one with the highest index will be choosen. <br>    for( ii = TopicCache.iDropZone; ii &lt; TopicCache.cTotItems; ii++) <br>    { <br>        cUsageCnt = STopic_GetUsageCnt( TopicCache.lpTopicArray + ii); <br>        if( cUsageCnt &lt;= cLowestCnt) <br>        {   // Found the lowest usage and highest index up to this point. <br>            iSlot = ii; <br>            cLowestCnt = cUsageCnt; <br>        } <br>    } <br> <br>    // Release and free everything associated with the topic. <br>    STopic_Release( TopicCache.lpTopicArray + iSlot); <br>     <br>    // Move the now empty item from iSlot to the top of the cache <br>    // and everything else down until it fills iSlot. <br>    STopicCache_MoveSlotToTop( iSlot); <br>     <br>    // Decrement the count of the last item in the cache.  This prevents an item  <br>    // that got a burst of activity, accumulating a high usage count, and then was  <br>    // never used again from remaining in the cache forever. <br>    STopic_DecUsageCnt( TopicCache.lpTopicArray + TopicCache.cTotItems - 1); <br> <br>    // Return the pointer to the first slot. <br>    return( TopicCache.lpTopicArray); <br>} <br> <br>//$--STopicCache_AdjustIndex---------------------------------------------------- <br>// Adjust the index of all topic objects that contain an index that is greater <br>// than or equal to iTFolderArray.  This is used when a new folder in inserted <br>// into or deleted from the middle of the folder array. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED void STopicCache_AdjustIndex( <br>    IN  ULONG       iTFolderArray,  // Index into TFolderArray of topic we want. <br>    IN  int         nAddSub)        // +1 indicates insert and -1 delete folder. <br>{ <br>    ULONG ii        = 0; <br>    ULONG Index     = 0; <br> <br>    for( ii = 0; ii &lt; TopicCache.cTotItems; ii++) <br>    { <br>        Index = STopic_GetFolderIndex( TopicCache.lpTopicArray + ii);   <br>        if( Index &gt;= iTFolderArray) <br>            STopic_SetFolderIndex( TopicCache.lpTopicArray + ii, Index + nAddSub); <br>    } <br>} <br> <br>//$--STopicCache_DeleteTopic---------------------------------------------------- <br>// Remove the item from the cache and adjust the index in the topic cache that  <br>// references any index &gt;= iTFolderArray. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED void STopicCache_DeleteTopic( <br>    IN  ULONG       iTFolderArray)  // Index into TFolderArray of topic we want to delete. <br>{ <br>    STopic* lpTopic = NULL; <br>    ULONG   iSlot = 0; <br> <br>    iSlot = STopicCache_Search( iTFolderArray); <br>    if( iSlot != NOT_FOUND) <br>    {   // The folder was found in the cache. <br>        lpTopic = TopicCache.lpTopicArray + iSlot; <br>             <br>        // Release all interfaces and free all buffers associated with this topic. <br>        STopic_Release( lpTopic); <br> <br>        // There is now one less item in the cache. <br>        TopicCache.cTotItems --; <br> <br>        // Make sure we really need to move something. <br>        if( iSlot &lt; TopicCache.cTotItems) <br>        {   // YEP, we need to move cached items up to fill this now empty space. <br>            memmove( lpTopic, lpTopic + 1, sizeof( STopic) * (TopicCache.cTotItems - iSlot)); <br>             <br>            // Initialize the last item to an empty state. <br>            STopic_Init( TopicCache.lpTopicArray + TopicCache.cTotItems);     <br>        } <br>    } <br>     <br>    // Adjust all other folder indexes in the cache to reflect the deleted folder. <br>    STopicCache_AdjustIndex(  iTFolderArray, -1); <br>} <br> <br>//$--STopicCache_HrInit--------------------------------------------------------- <br>// Initialize the topic cache to an empty state. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STopicCache_HrInit( <br>    IN  ULONG   cMaxItems, // The maximum number of topics the cache will hold. <br>    IN  ULONG   iDropZone)  // The starting index at which items become available <br>{                           // for removal from the cache. <br>    HRESULT hr          = NOERROR; <br>    ULONG   cBufSize    = 0; <br>    ULONG   ii          = 0; <br> <br>    DEBUGPUBLIC( "STopicCache_HrInit()"); <br>    hr = CHK_STopicCache_HrInit( cMaxItems, iDropZone); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    TopicCache.cMaxItems = cMaxItems; <br>    TopicCache.cTotItems = 0; <br>    TopicCache.iDropZone = iDropZone; <br> <br>    // Allocate memory for the entire topic array. <br>    cBufSize = sizeof( STopic) * cMaxItems; <br>    hr = MAPIAllocateBuffer( cBufSize, &amp;TopicCache.lpTopicArray); <br>    if( FAILED(hr) || !TEST_WRITE_PTR( TopicCache.lpTopicArray, cBufSize)) <br>    { <br>        hr = HR_LOG( E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    // Initialize each item of array. <br>    for( ii = 0; ii &lt; cMaxItems; ii ++) <br>        STopic_Init( TopicCache.lpTopicArray + ii); <br>     <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>//$--STopicCache_ReleaseAll----------------------------------------------------- <br>// Release all topic items. <br>// ----------------------------------------------------------------------------- <br> <br>void STopicCache_ReleaseAll() <br>{ <br>    ULONG   ii  = 0; <br>    for( ii = 0; ii &lt; TopicCache.cTotItems; ii ++) <br>        STopic_Release( TopicCache.lpTopicArray + ii); <br>     <br>    TopicCache.cTotItems = 0; <br>} <br> <br>//$--STopicCache_GetTopic------------------------------------------------------- <br>// This function gets the topic associated with the folder specified by the <br>// iTFolderArray index.  If the topic is in the cache it moves it to the top and  <br>// then returns it, otherwise it performs all the operations necessary to open  <br>// the topic. <br>// <br>// NOTE: The data pointed to by the returned pointer will be different once this  <br>//       function is called again for a new pointer.  In this implementation <br>//       it will always return a pointer to the first slot in the cache, but <br>//       don't depend upon it since the implementation could change. <br>// <br>// RETURNS: a pointer to the STopic object. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STopicCache_HrGetTopic( <br>    IN  ULONG       iTFolderArray,  // Index into TFolderArray of topic we want. <br>    OUT STopic**    lppTopic)       // We return the topic ptr in this var. <br>{ <br>    HRESULT hr      = NOERROR; <br>    ULONG   iSlot   = 0; <br>     <br>    DEBUGPUBLIC( "STopicCache_HrGetTopic()"); <br>    hr = CHK_STopicCache_HrGetTopic( iTFolderArray, lppTopic); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Search for the topic folder in the cache. <br>    iSlot = STopicCache_Search( iTFolderArray); <br>    if( iSlot == NOT_FOUND) <br>    {   // Not found so we need to create an item in the cache for this topic. <br>        STopicCache_FreeFirstTopicSlot(); <br>    } <br>    else <br>    {   // Found the topic folder in the cache so move it to the top. <br>        STopicCache_MoveSlotToTop( iSlot); <br>    } <br>     <br>    // Load only the topic member objects that are not currently loaded. <br>    hr = STopic_HrOpen( TopicCache.lpTopicArray, iTFolderArray); <br>                 <br>    if( FAILED( hr)) <br>        *lppTopic = NULL; <br>    else <br>        *lppTopic = TopicCache.lpTopicArray; <br>    return( hr); <br>} <br> <br>// ----------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
