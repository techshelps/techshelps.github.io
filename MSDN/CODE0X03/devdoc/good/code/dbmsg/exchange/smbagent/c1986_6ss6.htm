<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1986"></a>ACL.C</h2>
<pre><code>// --acl.c---------------------------------------------------------------------- <br>// Code to manipulate the access control list for public folders. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include &lt;edk.h&gt; <br> <br>// CbNewROWLIST should be defined in EMSMDB.H but it isn't <br> <br>#define CbNewROWLIST(_centries) \ <br>    (offsetof(ROWLIST,aEntries) + (_centries)*sizeof(ROWENTRY)) <br> <br>typedef struct _FOLDERACL <br>{ <br>    LPEXCHANGEMODIFYTABLE   lpWriteTable; <br>    LPMAPITABLE             lpReadTable; <br>}   FOLDERACL, *LPFOLDERACL; <br> <br> <br>#define TEST_ROW_FLAGS(x)  \ <br>    ((((x) == ROW_ADD) |   \ <br>     ((x) == ROW_MODIFY) | \ <br>     ((x) == ROW_REMOVE) | \ <br>     ((x) == ROW_EMPTY))) <br> <br>#include "acl.chk" <br> <br>//$--HrOpenACLInterface------------------------------------------------------ <br>//  Opens the access control list interface on a folder. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrOpenACLInterface(          // RETURNS: return code <br>    IN LPMAPIFOLDER lpFolder,           // pointer to folder <br>    OUT LPFOLDERACL *lppACL)            // pointer to access control list <br>{ <br>    HRESULT     hr    = NOERROR; <br>    HRESULT     hrT   = NOERROR; <br>    SCODE       sc    = 0; <br>    LPFOLDERACL lpACL = NULL; <br> <br>    DEBUGPUBLIC("HrOpenACLInterface()"); <br>  <br>    hr = CHK_HrOpenACLInterface( <br>        lpFolder, <br>        lppACL); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize output parameter <br> <br>    *lppACL = NULL; <br> <br>    // Allocate an ACL <br> <br>    sc = MAPIAllocateBuffer(sizeof(ACL), (LPVOID FAR *)&amp;lpACL); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_FAILED(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    lpACL-&gt;lpWriteTable = NULL; <br>    lpACL-&gt;lpReadTable  = NULL; <br>     <br>    // Open the ACL table property on the folder <br> <br>    hrT = MAPICALL(lpFolder)-&gt;OpenProperty( lpFolder, <br>        PR_ACL_TABLE, <br>        (LPGUID)&amp;IID_IExchangeModifyTable, <br>        0, <br>        MAPI_DEFERRED_ERRORS, <br>        (LPUNKNOWN FAR *)&amp;lpACL-&gt;lpWriteTable); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Open a table on the ACL table property <br>     <br>    hrT = MAPICALL( lpACL-&gt;lpWriteTable)-&gt;GetTable( lpACL-&gt;lpWriteTable, <br>        0, <br>        &amp;(lpACL-&gt;lpReadTable)); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br>     <br>    *lppACL = lpACL; <br> <br>cleanup: <br> <br>    if(FAILED(hr) &amp;&amp; (lpACL != NULL)) <br>    { <br>        ULRELEASE(lpACL-&gt;lpReadTable); <br>        ULRELEASE(lpACL-&gt;lpWriteTable); <br> <br>        MAPIFREEBUFFER(lpACL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrCloseACLInterface----------------------------------------------------- <br>//  Closes the access control list interface on a folder. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCloseACLInterface(         // RETURNS: return code <br>    IN OUT LPFOLDERACL * lppACL)        // pointer to access control list <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrCloseACLInterface()"); <br>  <br>    hr = CHK_HrCloseACLInterface( <br>        lppACL); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if((*lppACL) != NULL) <br>    { <br>        ULRELEASE((*lppACL)-&gt;lpReadTable); <br>        ULRELEASE((*lppACL)-&gt;lpWriteTable); <br> <br>        MAPIFREEBUFFER(*lppACL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrOpenAccessControlList------------------------------------------------- <br>//  Opens the access control list for lpFolder and returns the first  <br>//  EDK_MAX_QUERY_ROWS rows. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrOpenAccessControlList(     // RETURNS: return code <br>    IN LPMAPIFOLDER lpFolder,           // pointer to folder <br>    OUT LPFOLDERACL * lppACL,           // pointer to access control list <br>    OUT LPSRowSet FAR *lppRows)         // pointer to SRowSet <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    static const SizedSPropTagArray(4, rgPropTag) =  <br>    { 4, <br>        { <br>            PR_MEMBER_ID, <br>            PR_MEMBER_NAME, <br>            PR_MEMBER_RIGHTS, <br>            PR_MEMBER_ENTRYID <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrOpenAccessControlList()"); <br>  <br>    hr = CHK_HrOpenAccessControlList( <br>        lpFolder, <br>        lppACL, <br>        lppRows); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize output parameters <br> <br>    *lppACL = NULL; <br>    *lppRows = NULL; <br>     <br>    // Open the ACL <br>     <br>    hr = HrOpenACLInterface(lpFolder, lppACL); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Set the columns to return <br> <br>    hrT = MAPICALL( (*lppACL)-&gt;lpReadTable)-&gt;SetColumns( (*lppACL)-&gt;lpReadTable, <br>        (SPropTagArray *)&amp;rgPropTag, <br>        0); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Seek to the beginning of the table of ACL records <br> <br>    hrT = MAPICALL( (*lppACL)-&gt;lpReadTable)-&gt;SeekRow( (*lppACL)-&gt;lpReadTable, <br>        BOOKMARK_BEGINNING, <br>        0, <br>        NULL); <br> <br>    if (FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get the first EDK_MAX_QUERY_ROWS rows <br> <br>    hrT = MAPICALL( (*lppACL)-&gt;lpReadTable)-&gt;QueryRows( (*lppACL)-&gt;lpReadTable, <br>        (ULONG)EDK_MAX_QUERY_ROWS, <br>        (ULONG)0, <br>        lppRows); <br> <br>    if( FAILED( hrT) || *lppRows == NULL) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if( (*lppRows)-&gt;cRows == 0) <br>    { <br>        FREEPROWS(*lppRows); <br> <br>        hr = HR_LOG( EDK_E_END_OF_FILE); <br>    } <br> <br>cleanup: <br> <br>    if(((*lppACL) != NULL) &amp;&amp; FAILED(hr)) <br>    { <br>        (void)HrCloseACLInterface(lppACL); <br>    } <br>     <br>    RETURN(hr);     <br>} <br> <br> <br>//$--HrNextAccessControlList------------------------------------------------- <br>//  Returns the next EDK_MAX_QUERY_ROWS rows for this ACL <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrNextAccessControlList(     // RETURNS: return code <br>    IN LPFOLDERACL lpACL,               // pointer to access control list <br>    OUT LPSRowSet FAR * lppRows)        // pointer to SRowSet <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrNextAccessControlList()"); <br>  <br>    hr = CHK_HrNextAccessControlList( <br>        lpACL, <br>        lppRows); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize output parameter <br> <br>    *lppRows = NULL; <br> <br>    // Get the next EDK_MAX_QUERY_ROWS rows <br> <br>    hrT = MAPICALL( lpACL-&gt;lpReadTable)-&gt;QueryRows( lpACL-&gt;lpReadTable, <br>        (ULONG)EDK_MAX_QUERY_ROWS, <br>        (ULONG)0, <br>        lppRows); <br> <br>    if( FAILED( hrT) || *lppRows == NULL) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if( (*lppRows)-&gt;cRows == 0) <br>    { <br>        FREEPROWS(*lppRows); <br> <br>        hr = HR_LOG( EDK_E_END_OF_FILE); <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrCloseAccessControlList------------------------------------------------ <br>//  Closes the access control list. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCloseAccessControlList(    // RETURNS: return code <br>    IN OUT LPFOLDERACL * lppACL)        // pointer to access control list <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrCloseAccessControlList()"); <br>  <br>    hr = CHK_HrCloseAccessControlList( <br>        lppACL); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    (void)HrCloseACLInterface(lppACL); <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrFillROWENTRY---------------------------------------------------------- <br>//  Helper function used by HrCreateRowList to assign/allocate members <br>//  of a ROWENTRY. <br>//------------------------------------------------------------------------------ <br>static HRESULT HrFillROWENTRY(// RETURNS: return code <br>    IN ULONG ulRowFlags,         // row flags (ROW_ADD|ROW_MODIFY|ROW_REMOVE) <br>    IN LARGE_INTEGER liMemberID, // member ID (for ROW_MODIFY|ROW_REMOVE) <br>    IN ULONG ulRights,           // member rights (for ROW_ADD|ROW_MODIFY) <br>    IN ULONG cbeid,              // count of bytes in member entry ID (for ROW_ADD) <br>    IN LPVOID lpeid,             // pointer to member entry ID (for ROW_ADD) <br>    OUT LPROWENTRY  lpRowEntry)  // pointer to row entry <br>{ <br>    HRESULT      hr         = NOERROR; <br>    SCODE        sc         = 0; <br>    ULONG        cb         = 0; <br>    LPSPropValue lpSPropVal = NULL; <br>    LPVOID       lpeidCopy  = NULL; <br>    UINT         i          = 0; <br>    ULONG        cProps     = 0; <br>         <br>    DEBUGPRIVATE("HrFillROWENTRY()"); <br>  <br>    hr = CHK_HrFillROWENTRY( <br>        ulRowFlags, <br>        liMemberID, <br>        ulRights, <br>        cbeid, <br>        lpeid, <br>        lpRowEntry); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Allocate Prop Value array <br> <br>    if (ulRowFlags == ROW_ADD) <br>    { <br>        cProps = 2; // PR_MEMBER_ENTRYID and PR_MEMBER_RIGHTS <br>    } <br>    else if (ulRowFlags == ROW_MODIFY) <br>    { <br>        cProps = 2; // PR_MEMBER_ID and PR_MEMBER_RIGHTS <br>    } <br>    else <br>    { <br>        cProps = 1; // PR_MEMBER_ID; <br>    } <br> <br>    cb = CbNewSPropValue(cProps); <br> <br>    sc = MAPIAllocateBuffer(cb, (LPVOID *)&amp;lpSPropVal); <br> <br>    if(FAILED(sc)) <br>    {                                                    <br>        hr = HR_FAILED(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    ZeroMemory(lpSPropVal, cb); <br> <br>    // Allocate/Copy Entry ID, link to prop val array allocation <br> <br>    if (cbeid != 0) <br>    { <br>        sc = MAPIAllocateMore(cbeid, lpSPropVal, &amp;lpeidCopy); <br> <br>        if (sc != SUCCESS_SUCCESS)                            <br>        {                                                    <br>            hr = HR_FAILED(E_OUTOFMEMORY);                                  <br>            goto cleanup; <br>        }                                                    <br> <br>        CopyMemory(lpeidCopy, lpeid, cbeid); <br>    } <br> <br>    // Set Row Entry values <br> <br>    lpRowEntry-&gt;ulRowFlags = ulRowFlags; <br>    lpRowEntry-&gt;cValues = cProps; <br>    lpRowEntry-&gt;rgPropVals = lpSPropVal; <br> <br>    // Set Prop Value array <br> <br>    i = 0; <br> <br>    // Set PR_MEMBER_ENTRYID property <br>     <br>    if (ulRowFlags == ROW_ADD) <br>    { <br>        lpSPropVal[i].ulPropTag = PR_MEMBER_ENTRYID; <br>        lpSPropVal[i].Value.bin.cb = cbeid; <br>        lpSPropVal[i].Value.bin.lpb = (LPBYTE)lpeidCopy; <br>        i++; <br>    } <br> <br>    // Set MEMBER_ID property <br>    if (ulRowFlags != ROW_ADD) <br>    { <br>        lpSPropVal[i].ulPropTag = PR_MEMBER_ID; <br>        lpSPropVal[i].Value.li = liMemberID; <br>        i++; <br>    } <br> <br>    // Set PR_MEMBER_RIGHTS property <br> <br>    if ((ulRowFlags == ROW_ADD) || (ulRowFlags == ROW_MODIFY)) <br>    { <br>        lpSPropVal[i].ulPropTag = PR_MEMBER_RIGHTS; <br>        lpSPropVal[i].Value.ul = ulRights; <br>        i++; <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpSPropVal); <br> <br>        lpRowEntry-&gt;ulRowFlags = 0; <br>        lpRowEntry-&gt;cValues = 0; <br>        lpRowEntry-&gt;rgPropVals = NULL; <br>    } <br> <br>    RETURN(hr);     <br>} <br> <br> <br>//$--FreeROWENTRY------------------------------------------------------------ <br>//  Helper function used wth HrFillROWENTRY to free dynamically allocated <br>//  members of a ROWENTRY. <br>//------------------------------------------------------------------------------ <br>static VOID FreeROWENTRY(            // RETURNS: nothing <br>    IN OUT LPROWENTRY  lpRowEntry)      // pointer to row entry <br>{ <br>    DEBUGPRIVATE("FreeROWENTRY()"); <br>  <br>    if (lpRowEntry) <br>    { <br>        if (lpRowEntry-&gt;rgPropVals) <br>        { <br>            // Free the property value array and property values <br>             <br>            MAPIFREEBUFFER(lpRowEntry-&gt;rgPropVals); <br>        } <br> <br>        lpRowEntry-&gt;ulRowFlags = 0; <br>        lpRowEntry-&gt;cValues = 0; <br>    } <br>} <br> <br> <br>//$--HrCreateROWLIST--------------------------------------------------------- <br>//  Create a single item ROWLIST for use with HrModifyAccessControlList(). <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCreateROWLIST(      // RETURNS: return code <br>    IN ULONG ulRowFlags,         // row flags (ROW_ADD|ROW_MODIFY|ROW_REMOVE) <br>    IN LARGE_INTEGER liMemberID, // member ID (for ROW_MODIFY|ROW_REMOVE) <br>    IN LPTSTR lpszDisplayName,   // pointer to member display name <br>    IN ULONG ulRights,           // member rights (for ROW_ADD|ROW_MODIFY) <br>    IN ULONG cbeid,              // count of bytes in member entry ID (for ROW_ADD) <br>    IN LPVOID lpeid,             // pointer to member entry ID (for ROW_ADD) <br>    OUT LPROWLIST *lppRowList)   // pointer to row list <br>{ <br>    HRESULT hr = NOERROR; <br>    SCODE   sc = 0; <br>    ULONG   cb = 0; <br>         <br>    DEBUGPUBLIC("HrCreateROWLIST()"); <br>  <br>    hr = CHK_HrCreateROWLIST( <br>        ulRowFlags, <br>        liMemberID, <br>        lpszDisplayName, <br>        ulRights, <br>        cbeid, <br>        lpeid, <br>        lppRowList); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize output variable <br> <br>    *lppRowList = NULL; <br> <br>    // Allocate a new ROWLIST <br> <br>    cb = CbNewROWLIST(1); <br> <br>    sc = MAPIAllocateBuffer(cb, (LPVOID *)lppRowList); <br> <br>    if(FAILED(sc)) <br>    {                                                    <br>        hr = HR_FAILED(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    // Set RowList values <br> <br>    ZeroMemory((*lppRowList), cb); <br> <br>    (*lppRowList)-&gt;cEntries = 1; <br> <br>    hr = HrFillROWENTRY( <br>        ulRowFlags, <br>        liMemberID, <br>        ulRights, <br>        cbeid, <br>        lpeid, <br>        &amp;((*lppRowList)-&gt;aEntries[0])); <br> <br>    if(FAILED(hr)) <br>    { <br>       goto cleanup; <br>    }         <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppRowList); <br>    } <br> <br>    RETURN(hr);     <br>} <br> <br>//$--HrFreeROWLIST----------------------------------------------------------- <br>//  Free a ROWLIST for use with HrModifyAccessControlList(). <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrFreeROWLIST(               // RETURNS: return code <br>    IN OUT LPROWLIST *lppRowList)       // pointer to row list <br>{ <br>    HRESULT hr = NOERROR; <br>    ULONG   i  = 0; <br> <br>    DEBUGPUBLIC("HrFreeROWLIST()"); <br> <br>    hr = CHK_HrFreeROWLIST( <br>        lppRowList); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    for(i = 0; i &lt; (*lppRowList)-&gt;cEntries; ++i) <br>    { <br>        FreeROWENTRY(&amp;((*lppRowList)-&gt;aEntries[i])); <br>    } <br> <br>    MAPIFREEBUFFER(*lppRowList); <br>} <br> <br> <br>//$--HrModifyAccessControlList----------------------------------------------- <br>//  Modify the access control list. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrModifyAccessControlList(   // RETURNS: return code <br>    IN LPFOLDERACL lpACL,               // pointer to access control list <br>    IN LPROWLIST FAR lpRowList)         // pointer to row list <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrModifyAccessControlList()"); <br>  <br>    hr = CHK_HrModifyAccessControlList( <br>        lpACL, <br>        lpRowList); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if((lpRowList == NULL) || (lpRowList-&gt;cEntries == 0)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hrT = MAPICALL( lpACL-&gt;lpWriteTable)-&gt;ModifyTable( lpACL-&gt;lpWriteTable, <br>        0, <br>        lpRowList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr);     <br>} <br> <br>//$--HrModifyACL---------------------------------------------------------------- <br>//  If fRemove is FALSE then, for lpFolder, either add a new user with the  <br>//  specified lRights or change the rights if the user exists to the specified  <br>//  lRights.   <br>// <br>//  If fRemove is TRUE the remove the ACL record for the indicated user. <br>//------------------------------------------------------------------------------ <br>HRESULT HrModifyACL( <br>    IN LPMAPIFOLDER lpFolder,       // Folder to modify ACL for <br>    IN LPTSTR pszUserName,          // Name of user to change <br>    IN ULONG cbUserEid,             // Byte count for User's entry id. <br>    IN LPENTRYID lpUserEid,         // User's entry id. <br>    IN BOOL fRemove,                // Flag indicating whether to remove rights <br>    IN DWORD lRights)               // New rights (ignored if fRemove) <br>{ <br>    HRESULT         hr              = NOERROR; <br>    LPFOLDERACL     lpACL           = NULL; <br>    LPSRowSet       lpRows          = NULL; <br>    LPROWLIST       lpRowList       = NULL; <br>    ULONG           iUser, iProp;  <br>    LPSPropValue    lpsCurrentProp  = NULL; <br>    BOOL            fDisplayNameSet = FALSE; <br>    BOOL            fMemberIDSet    = FALSE; <br>    LPTSTR          lpszMemberName  = NULL; <br>    ULONG           ulRowFlags      = 0; <br>    LARGE_INTEGER   liMemberID      = { 0, 0 }; <br>    LPTSTR          lpszDisplayName = NULL; <br> <br>    DEBUGPUBLIC( "HrModifyACL()"); <br> <br>    hr = CHK_HrModifyACL( lpFolder, pszUserName, cbUserEid, lpUserEid, fRemove, lRights); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Find row in the ACL corresponding to this user <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Open the ACL and read first list. <br>    hr = HrOpenAccessControlList( lpFolder, &amp;lpACL, &amp;lpRows); <br>    while( SUCCEEDED( hr)) <br>    {   // Iterate through user rows <br>        for (iUser = 0; iUser &lt; lpRows-&gt;cRows; iUser++) <br>        { <br>            // Clear properties for current user <br>            fDisplayNameSet = FALSE; <br>            fMemberIDSet = FALSE; <br> <br>            // Iterate through properties for this user and set local copies <br>            for( iProp = 0; iProp &lt; lpRows-&gt;aRow[iUser].cValues; iProp ++) <br>            { <br>                lpsCurrentProp = lpRows-&gt;aRow[iUser].lpProps + iProp; <br>                switch( lpsCurrentProp-&gt;ulPropTag) <br>                { <br>                    case PR_MEMBER_ID: <br>                        liMemberID = lpsCurrentProp-&gt;Value.li; <br>                        fMemberIDSet = TRUE; <br>                        break; <br> <br>                    case PR_MEMBER_NAME: <br>                        lpszDisplayName = lpsCurrentProp-&gt;Value.LPSZ; <br>                        fDisplayNameSet = TRUE; <br>                        break; <br>                } <br>            } <br>             <br>            // Make sure all required properties are available. <br>            if ( (! fMemberIDSet) || (! fDisplayNameSet) ) <br>            { <br>                hr = HR_LOG( E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            // Does this row correspond to the user to be changed? <br>            if( lstrcmpi( lpszDisplayName, pszUserName) == 0) <br>            {   // YES <br>                if (fRemove) <br>                    ulRowFlags = ROW_REMOVE; <br>                else <br>                    ulRowFlags = ROW_MODIFY; <br>                goto FoundUser; <br>            } <br>        } <br> <br>        FREEPROWS(lpRows); <br> <br>        // Get the next batch of rows in the access control list (if any). <br>        hr = HrNextAccessControlList( lpACL, &amp;lpRows); <br>    } <br> <br>    if( hr != EDK_E_END_OF_FILE) <br>        goto cleanup; <br> <br>    // Didn't find row for user so need to add row if not fRemove. <br>    if( fRemove) <br>    { <br>        hr = HR_LOG( EDK_E_NOT_FOUND); <br>        goto cleanup; <br>    } <br> <br>    ulRowFlags = ROW_ADD; <br>    liMemberID.LowPart = 0; <br>    liMemberID.HighPart = 0; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Modify the access control list. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>FoundUser: <br>    // Create a row which will be used to modify the ACL table. <br>    hr = HrCreateROWLIST( ulRowFlags, liMemberID, lpszMemberName, lRights, cbUserEid, lpUserEid, &amp;lpRowList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>             <br>    ASSERTERROR( lpRowList != NULL, "lpRowList is NULL"); <br>     <br>    // Modify the ACL on the folder. <br>    hr = HrModifyAccessControlList( lpACL, lpRowList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Save Changes to the folder. <br>    hr = MAPICALL( lpFolder)-&gt;SaveChanges( lpFolder, KEEP_OPEN_READWRITE); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// All done so clean up. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>cleanup: <br>    if (lpRowList) <br>        HrFreeROWLIST( &amp;lpRowList); <br>    FREEPROWS( lpRows); <br>    HrCloseAccessControlList( &amp;lpACL); <br> <br>    RETURN( hr); <br>} <br> <br>//------------------------------------------------------------------------------ </code></pre>
<p>&nbsp;</p></body>
</HTML>
