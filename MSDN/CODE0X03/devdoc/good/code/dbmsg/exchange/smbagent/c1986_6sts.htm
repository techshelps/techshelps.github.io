<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMBAGENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1990"></a>SMBAGENT.C</h2>
<pre><code>// --smbagent.c------------------------------------------------------------------- <br>// <br>// This contains the main entry point, initialization and shutdown code, and <br>// the message processing loop. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "smbdata.h" <br>#include "smbagent.chk" <br> <br>#include "smbagent.h" <br>#include "resource.h" <br> <br>#define STOP_WAIT_HINT      20000       // 20 Second wait before considering the service dead. <br>#define CFG_POLL_MSEC20000       // 20 Second wait between configuration polls <br>#define MAX_REG_STR         800 <br> <br>#define TOPIC_CACHE_SIZE10 <br>#define TOPIC_CACHE_DROP_ZONE5 <br> <br>#ifdef __cplusplus <br>extern "C" { <br>#endif // __cplusplus <br> <br>//  Defined for NT service shell <br>TCHAR szAppName[]       = TEXT("SMBAgent"); <br>TCHAR szWindowTitle[]   = TEXT("Sample Mailbox Agent"); <br>TCHAR szServiceName[]   = TEXT("SMBAgent"); <br> <br>#ifdef __cplusplus <br>} <br> <br>#endif // __cplusplus <br> <br>static HANDLE   hServiceStopEvent       = NULL; <br> <br>//Global variables <br>HINSTANCE       hInst                   = NULL; <br>LPMAPISESSION   lphSession              = NULL;     // This is a COPY do not release it! <br>LPMAPIFOLDER    lpStoreFolder           = NULL;     // Pointer to MDB root folder <br>LPMAPITABLE     lpRootTable             = NULL;     // Pointer to IPM_SUBTREE hierarchy table <br>LPMAPIFOLDER    lpRootFolder            = NULL;     // Pointer to IPM_SUBTREE folder <br>LPMAPIFOLDER    lpInFolder              = NULL;     // Pointer to Inbox folder <br>LPMAPIFOLDER    lpNDRFolder             = NULL;     // Pointer to the Undeliverable folder <br>LPMAPIFOLDER    lpTopicsFolder          = NULL;     // Pointer to the Topics folder <br>LPADRBOOK       lpAdrBook               = NULL;     // Pointer to address book <br>LPMDB           lpStore                 = NULL;     // Pointer to Private Store MDB. <br>LPMDB           lpPubStoreMDB           = NULL;     // Pointer to Public Store MDB. <br>LPMAPIFOLDER    lpPubStoreFolders       = NULL;     // Pointer to root of Public Folders. <br> <br>TCHAR           szTextBuf[MAXTEXTLEN * 2] = TEXT("");     // Make these twice as big because sometimes <br>TCHAR           szSubjBuf[MAXSUBJLEN * 2] = TEXT("");     // we concat them with two pieces of data  <br>TCHAR           szCmdBuf[MAXCMDLEN * 2]   = TEXT("");     // that can be the MAX size. <br> <br>LPSPropValue    lpSenderProps;  // Pointer to array of sender properties. <br> <br>ULONGcbSMBAgentEID;// Session identifiers <br>LPENTRYIDlpSMBAgentEID; <br> <br>// These will be updated through the CfgAdviseObject. <br>LPSPropValue    lpCfgProps              = NULL;     // Ptr to array of cfg ext data properties. <br>LPTSTR          lpszTopicRootFolderName = TOPIC_ROOT_FOLDER_NAME; <br>LPTSTR          lpszTopicRootFolderComment = TOPIC_ROOT_FOLDER_COMMENT; <br>BOOL            bPublicTopic            = FALSE; <br>DWORD           dwPollInboxMsec         = 60000 * 5; // Default to 5 minutes before polling the inbox. <br>DWORD           dwACLRights             = rightsReadOnly; <br> <br>static TCHAR INQUEUE_NAME[]  = TEXT( "Inbox"); <br>static TCHAR OUTQUEUE_NAME[] = TEXT( "Outbox"); <br>static TCHAR INQUEUE_MUTEX[] = TEXT( "InQueueLock"); <br>static TCHAR EXT_DATA_NAME[] = TEXT( "SMBAgent"); <br> <br>static LPCTSTR              szInMutexName   = INQUEUE_MUTEX;// incoming queue mutex name <br>static BOOL                 fIsInit         = FALSE; <br>static HANDLE               hChkInBoxEvent  = NULL; // Signals notification of new mail. <br>static HANDLE               hInMutex        = NULL; // Signals inbox is NOT in use by  <br>                                                    // another instance of SMBAGENT. <br>static ULONG                ulInConnection  = MAX_ULONG; <br> <br>static BOOL                 fInitializedMAPI= FALSE;        // MAPI Initialized <br> <br>static BOOL                 IsMAPILogon     = FALSE;        // logged onto MAPI <br>static LPADVISEOBJ          lpCfgAdviseObj  = NULL;     // Ptr to advise obj for cfg extension data. <br> <br>static void RegNotifyThread( IN void* UnUsed); <br> <br>//$--InBoxNotification--------------------------------------------------------- <br>// This is an event handling procedure, called whenever new message(s) arrive  <br>// in the inbox. <br>// ---------------------------------------------------------------------------- <br>static SCODE STDAPICALLTYPE InBoxNotification(  <br>    IN LPVOID           lpvContext,         //pointer to context <br>    IN ULONG            cNotification,      //count of notification <br>    IN LPNOTIFICATION   lpNotifications)    //pointer to notifications <br>{ <br>    HRESULT hr = NOERROR; <br>    if( SetEvent( hChkInBoxEvent) == FALSE) <br>        hr = HR_LOG( E_FAIL); <br>    RETURN( hr); <br>} <br> <br>//$--HrProcessInBoxMessages---------------------------------------------------- <br>// Process all messages in the Inbox until a shut down event is signaled. <br>// ---------------------------------------------------------------------------- <br>static HRESULT HrProcessInBoxMessages() <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    BOOL            bRc                 = TRUE; <br>    SCODE           sc                  = SUCCESS_SUCCESS; <br>    unsigned        iMsgIndx            = 0; <br>    ULONG           ulNMsgTotal         = 0; <br>    ULONG           ulObjType           = 0; <br>    LPMESSAGE       lpMessage           = NULL; <br>    ULONG           cbEntryID           = 0; <br>    LPENTRYID       lpEntryID           = NULL; <br>    LPTSTR          lpszCommand         = NULL; <br>    DWORD           dwRc                = 0; <br>    ENTRYLIST       elMsgID             = {1, NULL};    <br>    BOOL            fDeleted            = FALSE;    // TRUE if curr.msg.has been deleted <br>    LPSRowSet       lpInRowSet          = NULL;     // pointer to inbox rows <br>    LPMAPITABLE     lpInBoxTable        = NULL; <br> <br>    HANDLE hEventArray1[] = <br>    { <br>        hChkInBoxEvent,     // Signaled indicates that we recevied notification of new mail. <br>        hServiceStopEvent,  // Signaled indicates we are suposed to shutdown. <br>    }; <br> <br>    HANDLE hEventArray2[] = <br>    { <br>        hInMutex,           // Signaled indicates no other SMBAGENT process is using the inbox,  <br>        hServiceStopEvent,  // Signaled indicates we are suposed to shutdown. <br>    }; <br> <br>    // Request the table be sorted by submittal time. <br>    static const SizedSSortOrderSet(1L,sSortPrioSet) = <br>        { 1L, 0L, 0L, { PR_CLIENT_SUBMIT_TIME, TABLE_SORT_ASCEND}}; <br>     <br>    static const SizedSPropTagArray(2L,sPropColumns) = <br>        { 2L, {PR_ENTRYID, PR_PRIORITY}}; <br> <br>    DEBUGPUBLIC( "HrProcessInBoxMessages()"); <br> <br>    // Get the contents table for the inbox folder. <br>    ASSERTERROR( lpInFolder != NULL, "NULL lpInFolder!"); <br>    hr = MAPICALL(lpInFolder)-&gt;GetContentsTable( lpInFolder, <br>        MAPI_DEFERRED_ERRORS, &amp;lpInBoxTable); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Table operations need only be performed once <br>    hr = MAPICALL( lpInBoxTable)-&gt;SetColumns( lpInBoxTable, <br>        (LPSPropTagArray)&amp;sPropColumns, TBL_BATCH); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    hr = MAPICALL( lpInBoxTable)-&gt;SortTable( lpInBoxTable, <br>        (LPSSortOrderSet)&amp;sSortPrioSet, TBL_BATCH); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// We go to sleep at the top of this while loop to wait for either the  <br>// hServiceStopEvent to be signaled or both the hChkInBoxEvent and the hInMutex  <br>// to be signaled.   <br>// <br>// The amount of time we sleep is a SMBADMIN configuration setting.  If we time <br>// out of the sleep then we check the in box for messages.  Sometimes the  <br>// notifications are not timely enough so this gives the user the option of  <br>// setting this parameter to INFINITE or some value that makes sense for their <br>// system setup. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    while( TRUE) <br>    { <br>        // Wait for the Check In Box event or the Shutdown event to be signaled. <br>        dwRc = WaitForMultipleObjects( ARRAY_CNT( hEventArray1), hEventArray1, <br>             FALSE, dwPollInboxMsec); <br>        switch( dwRc) <br>        { <br>            case WAIT_TIMEOUT: <br>            case WAIT_OBJECT_0: <br>                break;          // We are supposed to check the inbox. <br>            case WAIT_OBJECT_0 + 1: <br>                goto cleanup;   // We are supposed to shutdown. <br>            default: <br>                HR_LOG( E_FAIL); <br>                goto cleanup; <br>        } <br> <br>        // Get ownership of InMutex to prevent another SMBAGENT instance from <br>        // accessing inbox. This only works if both are running on the same <br>        // computer.  (This is not recommended.) <br>        dwRc = WaitForMultipleObjects( ARRAY_CNT( hEventArray2), hEventArray2, <br>            FALSE, INFINITE); <br>        switch( dwRc) <br>        { <br>            case WAIT_OBJECT_0: <br>                break;          // The inbox is available. <br>            case WAIT_OBJECT_0 + 1: <br>                goto cleanup;   // We are supposed to shutdown. <br>            default: <br>                HR_LOG( E_FAIL); <br>                goto cleanup; <br>        } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// At this point we have received notification of new mail or we are just polling  <br>// to check the inbox for mail and we know no other SMBAGENT process on this machine <br>// is using the inbox. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>        DEBUGACTION( "Checking inbox..."); <br> <br>        // Resetting InboxEvent will cause us to sleep once we reach the top of <br>        // the loop unless more mail comes in while we are processing. <br>        ResetEvent( hChkInBoxEvent); <br> <br>        // Seek to the beginning of the inbox table. <br>        hr = MAPICALL( lpInBoxTable)-&gt;SeekRow( lpInBoxTable, <br>            BOOKMARK_BEGINNING, 0, NULL); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        // Get the entire list of messages that are currently in the inbox. <br>        // More messages may come in while we are processing this list but they <br>        // will not show up for us until we get the list next time. <br>        hr = HrQueryAllRows( lpInBoxTable, NULL, NULL, NULL, 0, &amp;lpInRowSet); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Main loop that actualy processes the inbox messages until end of the table  <br>// list is reached. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>  <br>        for( iMsgIndx = 0; iMsgIndx &lt; lpInRowSet-&gt;cRows; ++iMsgIndx) <br>        { <br>            // Check to make sure we are not supposed to shutdown. <br>            dwRc = WaitForSingleObject( hServiceStopEvent, 0); <br>            if( dwRc == WAIT_OBJECT_0) <br>                break;  // Time to shut down. <br>            if( dwRc != WAIT_TIMEOUT) <br>            { <br>                HR_LOG( E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            // Check to see if user paused the service. <br>            hr = HrServiceProcessControl(); <br>            if( FAILED( hr)) <br>                goto cleanup; <br> <br>            // Initialize the ENTRYLIST with the ENTRYID of the message <br>            elMsgID.lpbin = &amp;(lpInRowSet-&gt;aRow[iMsgIndx].lpProps[0].Value.bin); <br> <br>            // Open the next message in the inbox. <br>            cbEntryID = lpInRowSet-&gt;aRow[iMsgIndx].lpProps[0].Value.bin.cb; <br>            lpEntryID = (LPENTRYID) (lpInRowSet-&gt;aRow[iMsgIndx].lpProps[0].Value.bin.lpb); <br>         <br>            // Message has not been deleted since it has not been opened yet. <br>            fDeleted = FALSE; <br> <br>            // Open the message for modification. <br>            hr = MAPICALL(lpInFolder)-&gt;OpenEntry( lpInFolder, <br>                cbEntryID, lpEntryID, NULL,  <br>                MAPI_MODIFY|MAPI_DEFERRED_ERRORS, <br>                &amp;ulObjType, (LPUNKNOWN FAR *) &amp;lpMessage); <br>            if( SUCCEEDED( hr) &amp;&amp; ulObjType == MAPI_MESSAGE) <br>            {   // Process the message. <br>                ASSERTERROR( lpMessage != NULL, "NULL lpMessage!"); <br>                hr = MAPICALL(lpMessage)-&gt;SetReadFlag(lpMessage, <br>                    MAPI_DEFERRED_ERRORS); <br>                if( FAILED( hr)) <br>                    goto cleanup; <br> <br>                hr = HrProcessCommand( lpMessage, &amp;elMsgID, &amp;fDeleted); <br>                if( hr == MAPI_E_NETWORK_ERROR) <br>                    goto cleanup; <br>            } <br> <br>            // If not deleted during processing, delete the message from inbox <br>            if( lpMessage &amp;&amp; !fDeleted) <br>            { <br>                hr = MAPICALL(lpInFolder)-&gt;DeleteMessages( lpInFolder, <br>                    &amp;elMsgID, 0, NULL, 0); <br>                if( FAILED( hr)) <br>                    goto cleanup; <br>            } <br> <br>            ULRELEASE( lpMessage); // Free the message pointer <br>            lpMessage = NULL; <br>        } <br>        // Free the current row set of message structures. <br>        FREEPROWS( lpInRowSet); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// We are done with all messages in the table, there may be more in the inbox,  <br>// but not in this table.  So we release the table and prepare to go back to  <br>// sleep.  If more messages are waiting in the inbox we will have received a  <br>// signal and will continue immediately. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>        // Unlock the inbox. <br>        if( ReleaseMutex( hInMutex) == FALSE) <br>        {    <br>            HR_LOG( E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// We are supposed to shutdown.   <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>cleanup: <br> <br>    // Unlock the inbox.  This can fail if we don't have the inbox locked. <br>    // So we don't care about the return results in this case. <br>    ReleaseMutex( hInMutex); <br> <br>    ULRELEASE( lpInBoxTable); <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrOpenHierarchicalFolder--------------------------------------------------- <br>//  Finds and opens hierarchical folder.  Creates folders as necessary. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrOpenHierarchicalFolder( <br>    IN LPMAPIFOLDER lpParentFolder,     // pointer to parent folder <br>    IN LPTSTR lpszFolderPath,           // Folder name <br>    IN LPTSTR lpszDefaultComment,       // Folder comment <br>    OUT LPMAPIFOLDER *lppFolder)        // pointer to open folder <br>{ <br>    HRESULT         hr              = NOERROR; <br>    LPMAPIFOLDER    lpFolder        = NULL; <br>    LPTSTR         *lppszFolderList = NULL; <br>    ULONG           ulFolderCount   = 0L; <br>    ULONG           i               = 0L; <br>     <br>    DEBUGPUBLIC( "HrOpenHierarchicalFolder()"); <br> <br>    hr = CHK_HrOpenHierarchicalFolder( <br>        lpParentFolder, lpszFolderPath, lpszDefaultComment, <br>        lppFolder); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    *lppFolder = NULL; <br> <br>    hr = HrStrTokAll( lpszFolderPath, TEXT("\\"), &amp;ulFolderCount, &amp;lppszFolderList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Attempt to find the topics folder. <br>    for( i=0; i&lt;ulFolderCount; i++) <br>    { <br>    hr = MAPICALL(lpParentFolder)-&gt;CreateFolder( lpParentFolder, <br>    FOLDER_GENERIC, <br>    lppszFolderList[i],  <br>    lpszDefaultComment,  <br>    NULL,  <br>    fMapiUnicode | OPEN_IF_EXISTS | MAPI_DEFERRED_ERRORS, <br>    &amp;lpFolder); <br>    if( FAILED( hr)) <br>    goto cleanup; <br> <br>    ASSERT_IUNKNOWN_PTR( lpFolder, "INVALID lpFolder pointer"); <br> <br>        // No longer need parent folder. <br>        // (Don't release folder that was passed!) <br>        if( i &gt; 0L) <br>            ULRELEASE( lpParentFolder); <br> <br>        lpParentFolder = lpFolder; <br>        lpFolder = NULL; <br>    } <br> <br>    // Success! <br>    *lppFolder = lpParentFolder; <br> <br>cleanup: <br>    MAPIFREEBUFFER( lppszFolderList); <br>         <br>    if( FAILED( hr)) <br>        ULRELEASE( lpFolder);     <br>     <br>    RETURN( hr); <br>} <br> <br>//$--HrInitTopicFolders-------------------------------------------------------- <br>//  Initialize Topic folder interfaces and cache <br>// ---------------------------------------------------------------------------- <br>HRESULT HrInitTopicFolders( VOID) <br>{ <br>    HRESULT         hr              = NOERROR; <br>    LPMAPIFOLDER    lpParentFolder  = NULL; <br> <br>    DEBUGPRIVATE( "HrInitTopicFolders()"); <br> <br>    if( !lpTopicsFolder) <br>    { <br>        if( bPublicTopic) <br>            lpParentFolder = lpPubStoreFolders; <br>        else <br>            lpParentFolder = lpRootFolder; <br> <br>        hr = HrOpenHierarchicalFolder( <br>            lpParentFolder, lpszTopicRootFolderName, lpszTopicRootFolderComment, &amp;lpTopicsFolder); <br>        if( FAILED(hr)) <br>            goto cleanup; <br> <br>        if( bPublicTopic) <br>        { <br>            hr = HrModifyACL(  <br>                lpTopicsFolder, <br>                TEXT("Default"), <br>                0L, <br>                NULL, <br>                FALSE, <br>                rightsReadOnly); <br>            if( FAILED( hr)) <br>                goto cleanup; <br>        } <br> <br>        // Reinitialize the topic folder array and topic cache <br>        hr = STFolderArray_HrInit(); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        hr = STopicCache_HrInit( TOPIC_CACHE_SIZE, TOPIC_CACHE_DROP_ZONE); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>    } <br> <br>cleanup: <br>    if( FAILED( hr)) <br>        ULRELEASE( lpTopicsFolder); <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrUninitTopicFolders------------------------------------------------------ <br>//  Release folder interfaces <br>// ---------------------------------------------------------------------------- <br>static VOID UninitTopicFolders( VOID) <br>{ <br>    STopicCache_ReleaseAll(); <br>    STFolderArray_Destroy(); <br> <br>ULRELEASE( lpTopicsFolder); <br> <br>} <br> <br>//$--HrCfgChanged()------------------------------------------------------------- <br>// This function gets called once when the advise is initialized and then when  <br>// the configuration extension data changes. <br>// <br>// This data is maintained by a property sheet found in Exchange's Administration <br>// program for the mailbox that we have logged onto.  The SMBAdmin.DLL supports  <br>// the property sheet. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCfgChanged(  <br>    LPVOID          lpvUserContext,     // Not used. <br>    LPWSTR          lpwszBlobName,      // Not used. <br>    ULONG           cProps,             // Count of propetries in lpProps. <br>    LPSPropValue    lpProps)            // Pointer to the array of properties. <br>{ <br>    HRESULT         hr              = NOERROR; <br>LPMAPIFOLDER    lpParentFolder  = NULL; <br>    DWORD           dwRc        = 0; <br> <br>    HANDLE hEventArray[] = <br>    { <br>        hInMutex,           // Signaled indicates no other SMBAGENT process is using the inbox,  <br>        hServiceStopEvent,  // Signaled indicates we are suposed to shutdown. <br>    }; <br> <br> <br>    DEBUGPUBLIC( "HrCfgChanged()"); <br>     <br>    // Return a special error if there is no extension data. This is an <br>    // expected condition, but we must log why we don't continue. This  <br>    // MUST be done before the CHK_ function is called. <br>    if( cProps != SMBDATA_PROP_COUNT) <br>    { <br>        EventLogMsg( EDKEVENT_ERROR, <br>            1, "Extension data ("SMBBLOBNAME") corrupt or non-existent.  Install and run SMBAdmin.", <br>            0); <br>        RETURN( EDK_E_NOT_FOUND);    <br>    } <br> <br>    // This makes sure we have exactly the expected number of properties. <br>    hr = CHK_HrCfgChanged( lpvUserContext, lpwszBlobName, cProps, lpProps); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>     <br>    // Get ownership of InMutex so that we don't interrupt work in progress <br>    dwRc = WaitForMultipleObjects( ARRAY_CNT( hEventArray), hEventArray, FALSE, INFINITE); <br>    switch( dwRc) <br>    { <br>        case WAIT_OBJECT_0:         // The inbox is available. <br>            break; <br> <br>        case WAIT_OBJECT_0 + 1:     // We are supposed to shutdown. <br>            goto cleanup; <br> <br>        case WAIT_ABANDONED_0:      // mutex abandoned? <br>            MODULE_ERROR( "Mutex abandoned!  You may need to reboot."); <br>            /* FALL-THROUGH */ <br> <br>        default: <br>            hr = HR_LOG( E_FAIL); <br>            goto cleanup; <br>    } <br> <br>    // Release old topic folder information <br>    UninitTopicFolders(); <br> <br>    // Extract data from property array.  Note that we keep the property array <br>    // around until next time a change occurs or termination. <br>    lpszTopicRootFolderName    = lpProps[ IDX_TOPIC_ROOT_FOLDER_NAME   ].Value.LPSZ; <br>    lpszTopicRootFolderComment = lpProps[ IDX_TOPIC_ROOT_FOLDER_COMMENT].Value.LPSZ; <br>    dwPollInboxMsec            = lpProps[ IDX_POLL_INBOX_MSEC          ].Value.ul; <br>    bPublicTopic           = lpProps[ IDX_PUBLIC_TOPIC_FOLDER      ].Value.b; <br>    dwACLRights                = lpProps[ IDX_ACL_RIGHTS               ].Value.ul; <br> <br>    // Free the previous set of properties and remember the new one. <br>    MAPIFREEBUFFER( lpCfgProps); <br>    lpCfgProps = lpProps; <br> <br>    // NOTE: Topic folder is initialized when processing mail <br>    // so error message can be returned if initialization fails. <br> <br>if( ReleaseMutex( hInMutex) == FALSE) <br>{ <br>hr = HR_LOG( E_FAIL); <br>goto cleanup; <br>} <br> <br>cleanup:     <br>    RETURN( hr); <br>} <br> <br>//$--UninitSMBAGENT ---------------------------------------------------------- <br>//  Uninitialize the service <br>// ---------------------------------------------------------------------------- <br>static VOID UninitSMBAGENT( VOID) <br>{ <br>    // Release all data cached in the topic cache and destroy the folder array. <br>    UninitTopicFolders(); <br> <br>    // Stop configuration extension data notification. <br>    if( lpCfgAdviseObj) <br>    { <br>        HR_LOG( HrCfgDestroyAdviseObj( lpCfgAdviseObj)); <br>        lpCfgAdviseObj = NULL; <br>    } <br>    MAPIFREEBUFFER( lpCfgProps); <br>     <br>    // Stop inbox notifications. <br>    if((ulInConnection != MAX_ULONG) &amp;&amp; (lpStore != NULL)) <br>        MAPICALL(lpStore)-&gt;Unadvise(lpStore, ulInConnection); <br> <br>    CLOSEHANDLE( hChkInBoxEvent); <br>    CLOSEHANDLE( hInMutex); <br> <br>    // Release global object pointers. <br>    ULRELEASE( lpAdrBook); <br>    ULRELEASE( lpNDRFolder); <br>    ULRELEASE( lpInFolder); <br>    ULRELEASE( lpRootTable); <br>    ULRELEASE( lpRootFolder); <br>    ULRELEASE( lpStoreFolder); <br>     <br>    // Release the message stores <br>    ULRELEASE(lpStore); <br> <br>    ULRELEASE( lpPubStoreFolders); <br>    ULRELEASE( lpPubStoreMDB); <br> <br>MAPIFREEBUFFER( lpSMBAgentEID); <br> <br>    // Logoff a MAPI session <br>    if((IsMAPILogon == TRUE) &amp;&amp; (lphSession != NULL)) <br>    { <br>        MAPICALL( lphSession)-&gt;Logoff( lphSession, 0, 0, 0); <br>        ULRELEASE( lphSession); <br>        IsMAPILogon = FALSE; <br>    } <br> <br>    if(fInitializedMAPI == TRUE) <br>    { <br>        MAPIUninitialize(); <br>        fInitializedMAPI = FALSE; <br>    } <br> <br>    fIsInit = FALSE; <br>} <br> <br>//$--InitSMBAGENT ---------------------------------------------------------------- <br>//  Initialize for receiving &amp; sending messages <br>// ----------------------------------------------------------------------------- <br>static  HRESULT HrInitSMBAGENT( void) // RETURNS: return code <br>{ <br>    HRESULT         hr              = NOERROR; <br>    SCODE           sc              = SUCCESS_SUCCESS; <br>    LPTSTR *        lppszArgv       = NULL; <br>    LPTSTR          lpszPassword    = TEXT(""); <br>    ULONG           dwArgc          = 0,    // number of arguments to service <br>                    cbInEntryID     = 0,    // #bytes in Inbox EntryID <br>                    cbRootEntryID   = 0,    // #bytes in Root Folder EntryID <br>                    cbNDREntryID    = 0,    // #bytes in Undeliverable Folder EntryID <br>                    ulObjType       = 0, <br>                    ulFlags         = 0; <br>     <br>    LPENTRYID       lpInEntryID     = NULL, // Pointer to Inbox folder EntryID <br>                    lpRootEntryID   = NULL, // Pointer to Root folder EntryID <br>                    lpNDREntryID    = NULL; // Pointer to Undeliverable Entry ID <br>    MAPIINIT_0      MapiInit; <br> <br>    ULONG            cbeid          = 0; <br>    LPENTRYID        lpeid          = NULL; <br>    LPMAPIADVISESINK lpInAdvise     = NULL; <br> <br>    TCHAR            szServiceName[MAX_SERVICE_NAME_LENGTH+1] = {TEXT("")}; <br> <br>    TCHAR            szProfileName[MAX_PATH+1] = {0}; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Initialize MAPI, create temporary profile, and logon <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    if( !FIsService()) <br>        hr = MAPIInitialize(NULL);  // Not a service. <br>    else <br>    {   // Services need special initialization. <br>        MapiInit.ulVersion = MAPI_INIT_VERSION; <br>        MapiInit.ulFlags = MAPI_NT_SERVICE; <br>        ulFlags = MAPI_NT_SERVICE | MAPI_NO_MAIL; <br>        hr = MAPIInitialize( &amp;MapiInit); <br>    } <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    fInitializedMAPI = TRUE; <br> <br>    hr = HrServiceGetArgv(&amp;dwArgc, &amp;lppszArgv); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ASSERTERROR( dwArgc != 0L, "Zero dwArgc"); <br>    ASSERTERROR( lppszArgv != NULL, "NULL lpszArgv"); <br> <br>    if( dwArgc &gt; 1) <br>        lpszPassword = lppszArgv[1]; <br> <br>    hr = HrServiceGetName( szServiceName); <br>    if(FAILED( hr)) <br>        goto cleanup; <br> <br>    hr = HrCreateProfileName( szServiceName, MAX_PATH+1, szProfileName); <br>    if(FAILED(hr)) <br>        goto cleanup; <br> <br>hr = HrCreateMailboxAgentProfile( szServiceName, szProfileName); <br> <br>if(hr == E_ACCESSDENIED) <br>{ <br>MODULE_WARNING("Can't create profile--it already exists."); <br>        hr = NOERROR; <br>} <br>    else if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = MAPILogonEx( <br>        (ULONG) 0, <br>        szProfileName, <br>        lpszPassword, <br>        MAPI_NEW_SESSION | MAPI_EXTENDED | ulFlags, <br>        &amp;lphSession); <br> <br>    if( FAILED( hr)) <br>        goto cleanup; <br>     <br>    ASSERTERROR( lphSession!=NULL, "Null lphSession!"); <br> <br>    IsMAPILogon = TRUE; <br> <br>    // Mark profile for later deletion <br>    HR_LOG(HrRemoveProfile(szProfileName)); <br> <br>    // Make a note of who we are.  This will be used later to tell if messages are <br>// sent from the SMBAgent profile.  (Something only a tester would do...) <br>hr = MAPICALL(lphSession)-&gt;QueryIdentity (lphSession, &amp;cbSMBAgentEID, &amp;lpSMBAgentEID); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Misc. folder finding and opening including the InBox. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Open the public store MDB. <br>    hr = HrOpenExchangePublicStore(lphSession, &amp;lpPubStoreMDB); <br>    if( FAILED(hr)) <br>        RETURN( hr); <br> <br>    hr = HrOpenExchangePublicFolders( lpPubStoreMDB, &amp;lpPubStoreFolders); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Get entry ID of message store <br>    hr = HrMAPIFindDefaultMsgStore( lphSession, &amp;cbeid, &amp;lpeid); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    hr = MAPICALL( lphSession)-&gt;OpenMsgStore( lphSession, <br>        (ULONG)0, <br>        cbeid, <br>        lpeid, <br>        NULL, <br>        MDB_NO_DIALOG | MDB_WRITE, <br>        &amp;lpStore); <br> <br>    MAPIFREEBUFFER(lpeid); <br> <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Get the root folder in the default message store <br>    hr = MAPICALL(lpStore)-&gt;OpenEntry( lpStore, <br>        (ULONG)0, <br>        NULL, <br>        NULL, <br>        MAPI_MODIFY|MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *) &amp;lpStoreFolder); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Find Message Store's IPM folder subtree <br>    hr = HrMAPIFindIPMSubtree( lpStore, &amp;cbRootEntryID, &amp;lpRootEntryID); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    ASSERTERROR( cbRootEntryID != 0, "ZERO cbRootEntryID!"); <br>    ASSERTERROR( lpRootEntryID != NULL, "NULL lpRootEntryID!"); <br> <br>    // Open SMBAGENT's IPM_SUBTREE folder <br>    hr = MAPICALL(lpStoreFolder)-&gt;OpenEntry( lpStoreFolder, <br>    cbRootEntryID, <br>    lpRootEntryID, <br>        NULL, <br>        MAPI_MODIFY|MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *) &amp;lpRootFolder); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    if( ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br>     <br>    ASSERTERROR( lpRootFolder != NULL, "NULL lpRootFolder!"); <br> <br>    // Get the hierarchy table for the root folder of the message store <br>    hr = MAPICALL(lpRootFolder)-&gt;GetHierarchyTable( lpRootFolder, <br>    MAPI_DEFERRED_ERRORS,  <br>    &amp;lpRootTable); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Find SMBAGENT's Inbox folder  <br>    hr = HrMAPIFindInbox( lpStore, &amp;cbInEntryID, &amp;lpInEntryID); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ASSERTERROR ( lpInEntryID != NULL, "NULL lpInEntryID"); <br> <br>    // Open SMBAGENT's Inbox folder <br>    hr = MAPICALL(lpRootFolder)-&gt;OpenEntry( lpRootFolder, <br>    cbInEntryID,  <br>    lpInEntryID,  <br>        NULL,  <br>        MAPI_MODIFY|MAPI_DEFERRED_ERRORS,  <br>        &amp;ulObjType,  <br>        (LPUNKNOWN FAR *) &amp;lpInFolder); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    if( ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br>     <br>    ASSERTERROR( lpInFolder != NULL, "NULL lpInFolder!"); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Open the "Undeliverable" folder, create it if necessary. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - </code></pre>
<p>
</p>
<pre><code><br>    hr = HrOpenHierarchicalFolder( lpRootFolder, NDR_FOLDER_NAME, NDR_FOLDER_COMMENT, &amp;lpNDRFolder); <br>    if( FAILED(hr)) <br>        goto cleanup;    <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Open the Address Book. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    hr = MAPICALL(lphSession)-&gt;OpenAddressBook( lphSession, 0L, NULL, AB_NO_DIALOG, &amp;lpAdrBook); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ASSERTERROR( lpAdrBook != NULL, "NULL lpAdrBook!"); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Support processing the in box messages using notification and event signals. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Create Inbox mutex (w/o ownership) for possible multiple accesses <br>    hInMutex = CreateMutex( NULL, FALSE, szInMutexName); <br>    if(hInMutex == NULL) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Create an event for signaling to check the inbox for messages to process. <br>    // This is a manual reset event that is initialy signaled. <br>    hChkInBoxEvent = CreateEvent( NULL, TRUE, TRUE, NULL); <br>    if( hChkInBoxEvent == NULL) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Register incoming queue event notification handler. <br>    hr = HrAllocAdviseSink( InBoxNotification, NULL, &amp;lpInAdvise); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>    hr = MAPICALL(lpStore)-&gt;Advise( lpStore, cbInEntryID, lpInEntryID, <br>        fnevNewMail, lpInAdvise, &amp;ulInConnection); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Start configuration change notification engine.  This will cause the  <br>// HrCfgChanged() function to be called immediately and then every time a change <br>// occurs.  The configuration data is stored by Exchange as extension data and <br>// it is maintained by SMBAdmin.DLL. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    hr = HrCfgCreateAdviseObj( lphSession, CFG_POLL_MSEC, &amp;lpCfgAdviseObj); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>  <br>    hr = HrCfgAdvise( lpCfgAdviseObj, SMBBLOBNAME, &amp;HrCfgChanged, NULL); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br> <br>// HrCfgChanged will open the appropriate Topics Folder and <br>// initialize the topic cache <br>ASSERTERROR( lpTopicsFolder != NULL, "NULL lpTopicsFolder!"); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    fIsInit = TRUE; <br> <br>cleanup: <br> <br>    ULRELEASE(lpInAdvise); <br> <br>    MAPIFREEBUFFER(lpeid); <br>    MAPIFREEBUFFER(lpInEntryID); <br>    MAPIFREEBUFFER(lpRootEntryID); <br>    MAPIFREEBUFFER(lpNDREntryID); <br> <br>    if( FAILED( hr)) <br>{ <br>        UninitSMBAGENT(); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, hr); <br> <br>ServiceStop(); <br>} <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrServiceStartup---------------------------------------------------------- <br>//  This function is called at startup to initialize the application. <br>//------------------------------------------------------------------------------ <br>HRESULT HrServiceStartup( <br>    IN HINSTANCE    hInstance,      //  Handle of current instance <br>    IN HINSTANCE    hPrevInstance,  //  Handle of previous instance <br>    IN HWND         hwndMainWindow, //  Handle to Main window <br>    IN LPSTR        pszCmdLine)     //  Pointer to command line <br>{ <br>    HRESULT         hr = NOERROR; <br>     <br>    DEBUGPUBLIC( "fNTServiceStartup()"); <br> <br>    hr = CHK_HrServiceStartup( hInstance, hPrevInstance, hwndMainWindow, pszCmdLine); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Save the instance value as a global variable <br>    hInst = hInstance; <br> <br>    hServiceStopEvent = GetServiceStopEvent(); <br> <br>hr = HR_LOG(HrEventOpenLog( <br>    TEXT("SMBAGENT"), NULL, TEXT("EDKMSG.DLL"), NULL, NULL, NULL)); <br> <br>    //  Start message transfer. <br>    RETURN( HrInitSMBAGENT()); <br>} <br> <br>//$--ServiceMain-------------------------------------------------------------- <br>// This function takes care of some service overhead and starts in box message <br>// processing. <br>// <br>// This is a thread process and keeps running until it is time to shut down. <br>//------------------------------------------------------------------------------ <br>void ServiceMain( <br>    IN HANDLE NotUsed)  //  Handle to Shutdown event object <br>{ <br>    HRESULT hr                      = NOERROR; <br>    DWORD   dwRc                    = 0; <br> <br>    DEBUGPUBLIC( "ServiceMain()"); <br>    hr = CHK_ServiceMain( NotUsed); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    EventLogMsg( EDKEVENT_INFORMATION, 1, "Starting ServiceMain", 0); <br> <br>    // We have a loop for processing messages so that <br>    // we can recover when the server goes down. <br>    while( TRUE) <br>    { <br>        // Check to see if user paused the service. <br>        hr = HrServiceProcessControl(); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        hr = HrProcessInBoxMessages(); <br>        if( hr == MAPI_E_NETWORK_ERROR) <br>        {   // The server went down so we reset the program and wait for it to come back up. <br>            EventLogMsg( EDKEVENT_INFORMATION, 1, "Mailbox server is down.  Attempting to reconnect.", 0); <br> <br>            UninitSMBAGENT(); <br> <br>            while( TRUE) <br>            { <br>                hr = HrInitSMBAGENT(); <br>                if( SUCCEEDED( hr)) <br>                    break; <br>                 <br>                // Wait one minute or until administrator shuts us down. <br>                dwRc = WaitForSingleObject( hServiceStopEvent, 10000); <br>                switch( dwRc) <br>                { <br>                    case WAIT_TIMEOUT: <br>                        break;          // We are supposed to check the inbox. <br>                    case WAIT_OBJECT_0 + 1: <br>                        goto cleanup;   // We are supposed to shutdown. <br>                    default: <br>                        HR_LOG( E_FAIL); <br>                        goto cleanup; <br>                } <br>            } <br>                         <br>            EventLogMsg( EDKEVENT_INFORMATION, 1, "Mailbox server came back up.", 0); <br>            continue; <br>        } <br> <br>        // Exit loop after testing for error condition. <br>        if( FAILED( hr)) <br>            goto cleanup; <br>        break; <br>    } <br> <br>cleanup: <br>    // If an error occured we need to stop the service ourselves. <br>    if( FAILED( hr)) <br>    { <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, hr); <br> <br>        ServiceStop(); <br>    } <br>     <br>    // Call this function to let winwrap know we are done. <br>    HrServiceConfirmStop(); <br> <br>    EventLogMsg( EDKEVENT_INFORMATION, 1, "Ending ServiceMain", 0); <br>    ExitThread( hr); <br>} <br> <br>//$--HrServiceShutdown---------------------------------------------------------- <br>//  This function is called to shutdown the application. <br>//------------------------------------------------------------------------------ <br>HRESULT HrServiceShutdown (void)      // RETURNS:    Return value for WinMain <br>{ <br>    //  Uninitialize... <br>    UninitSMBAGENT(); <br> <br>    (void) HrEventCloseLog(); <br> <br>    //  Return exit code for WinMain... <br>    return( NOERROR); <br>} <br> <br>//------------------------------------------------------------------------------ </code></pre>
<p>&nbsp;</p></body>
</HTML>
