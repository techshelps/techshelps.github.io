<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TFLDRARY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1992"></a>TFLDRARY.C</h2>
<pre><code>// --TFldrAry.C---------------------------------------------------------------- <br>//  <br>// This module contains functions for maintaining and using a topic folder  <br>// array for SMBAGENT. <br>// <br>// The array is essentialy a dynamicly expanding row set of properties of all  <br>// topic folders.  Each row contains a Display Name and an Entry Id.  The array  <br>// is sorted by display name. <br>// <br>// See TOPCACHE.H for details on the relationship between the STFolderArray, the <br>// STopicCache, and the STopic objects. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>// Cause protected functions to be available. <br>#define FRIEND_OF_STOPIC <br>#define FRIEND_OF_STFOLDERARRAY <br>#define FRIEND_OF_STOPICCACHE <br> <br>#include "smbagent.h" <br>#include "TFldrAry.CHK" <br> <br>//$--Compare_DispName----------------------------------------------------------- <br>// Used by search routines to compare a search key to the display name which is <br>// the first property of a row in a SRowSet. <br>// <br>// This helper function is globaly available. <br>// RETURNS: -1 if Search Key &lt; Display Name <br>//           0 if Search Key = Display Name <br>//           1 if Search Key &gt; Display Name <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED int Compare_DispName( const void* lpszSrchKey, const void* lpRow) <br>{ <br>    return( lstrcmpi( (LPTSTR) lpszSrchKey, ((LPSRow) lpRow)-&gt;lpProps-&gt;Value.LPSZ)); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// This object contains an array of all folders.  The functions whose  <br>// names that begin with "STFolderArray_" work on this object. <br>// ----------------------------------------------------------------------------- <br> <br>STFolderArray TFolderArray; <br> <br>//$--STFolderArray_FindInsertionPt---------------------------------------------- <br>// RECURSIVE binary search routine to find the insertion point for a folder. <br>// If the topic folder name already exists one or more times in the array the  <br>// insertion point will be after the last item of the same name. <br>// RETURNS: the index to insert topic folder at. <br>// ----------------------------------------------------------------------------- <br> <br>static ULONG STFolderArray_FindInsertionPt(  <br>    IN LPTSTR  lpszTFolderName, // The name of the topic folder you want to insert. <br>    IN ULONG   cRows,           // Can not be zero.    <br>    IN LPSRow  lpRow) <br>{ <br>    int     nCmp = 0; <br>    ULONG   iMid = cRows / 2; <br> <br>    nCmp = Compare_DispName( lpszTFolderName, lpRow + iMid); <br>    if( nCmp &lt; 0) <br>    {   // Topic folder name is less than topic folder row. <br>        if( iMid == 0) <br>            return( 0); <br>        return( STFolderArray_FindInsertionPt( lpszTFolderName, iMid, lpRow)); <br>    } <br>    else <br>    {   // Topic folder name is greater than or equal to topic folder row. <br>        iMid ++; <br>        if( iMid == cRows) <br>            return( iMid); <br>        return( STFolderArray_FindInsertionPt( lpszTFolderName, cRows - iMid, lpRow + iMid) + iMid); <br>    } <br>} <br> <br>//$--STFolderArray_HrInsert------------------------------------------------------ <br>// Insert a new property value array in the row set of the topic folder array. <br>// This also adjusts the topic cache which has references to this array by index. <br>// ----------------------------------------------------------------------------- <br> <br>static HRESULT STFolderArray_HrInsert( <br>    IN ULONG        iTFolderArray,      // Index to insert a SRow object at. <br>    IN LPTSTR       lpszTFolderName,    // The name of the topic folder you want to insert. <br>    IN ULONG        cbEID,              // The count of bytes of the entry id. <br>    IN LPENTRYID    lpEID)              // The entry id of the topic folder you want to insert. <br>{ <br>    HRESULT     hr          = NOERROR; <br>    ULONG       cBytes      = 0; <br>    LPBYTE      lpBuf       = NULL; <br>    LPSRow      lpRow       = NULL; <br>    ULONG       cExpand     = 10;   // Number of items to expand array when necessary. <br>    ULONG       cTFNameSize = 0; <br> <br>    DEBUGPUBLIC( "STFolderArray_HrInsert()"); <br>    hr = CHK_STFolderArray_HrInsert( iTFolderArray, lpszTFolderName, cbEID, lpEID); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Is the array big enough to insert a SRow? <br>    if( TFolderArray.lpRows-&gt;cRows == TFolderArray.cAllocatedRows) <br>    {   // NO, so expand it. <br> <br>        // Allocate a new buffer for the row set. <br>        cBytes = CbNewSRowSet( TFolderArray.cAllocatedRows + cExpand); <br>        hr = MAPIAllocateBuffer( cBytes, &amp;lpBuf); <br>        if( FAILED( hr) || !lpBuf) <br>        { <br>            hr = HR_LOG( E_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br>         <br>        // Zero the new buffer. <br>        memset( lpBuf, 0, cBytes); <br> <br>        // Was there any rows in the last allocation? <br>        if( TFolderArray.cAllocatedRows) <br>        {   // YES, so move the old buffer to the new one. <br>            cBytes = CbNewSRowSet( TFolderArray.cAllocatedRows); <br>            memmove( lpBuf, TFolderArray.lpRows, cBytes); <br>        } <br> <br>        // Free the old buffer and use the new pointer.  Even if the last <br>        // alocation contained no rows there was minimum allocation for the <br>        // SRowSet structure with a count of zero.  We do NOT use FREEPROWS <br>        // since it would free each row which we just moved to our new buffer. <br>        MAPIFreeBuffer( TFolderArray.lpRows); <br>        TFolderArray.lpRows = (LPSRowSet) lpBuf; <br> <br>        // Increase the maximum size of the array. <br>        TFolderArray.cAllocatedRows += cExpand; <br>    } <br> <br>    // Allocate memory for the property value array. <br>    cTFNameSize = (lstrlen( lpszTFolderName) + 1) * sizeof(TCHAR); <br>    cBytes = sizeof( SPropValue) * 2 + cTFNameSize + cbEID; <br>    hr = MAPIAllocateBuffer( cBytes, &amp;lpBuf); <br>    if( FAILED( hr) || !lpBuf) <br>    { <br>        hr = HR_LOG( E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    // The address of the row we wish to place data at. <br>    lpRow = TFolderArray.lpRows-&gt;aRow + iTFolderArray; <br>     <br>    // Are we inserting in the middle of the array? <br>    if( iTFolderArray &lt; TFolderArray.lpRows-&gt;cRows) <br>    {   // YES, so make space for the new entry. <br>        ULONG cBytes = (TFolderArray.lpRows-&gt;cRows - iTFolderArray) * sizeof( SRow); <br>        memmove( lpRow + 1, lpRow, cBytes); <br>        memset( lpRow, 0, sizeof( SRow)); <br> <br>        // Adjust the index in the topic cache that references any index &gt;= iTFolderArray. <br>        STopicCache_AdjustIndex( iTFolderArray, 1); <br>    } <br>     <br>    // Increment the count of rows. <br>    TFolderArray.lpRows-&gt;cRows ++; <br> <br>    // Initialize the SRow structure object. <br>    lpRow-&gt;cValues = 2; <br>    lpRow-&gt;lpProps = (LPSPropValue) lpBuf; <br>    lpBuf += sizeof( SPropValue) * 2; <br>     <br>    // Setup the PR_DISPLAY_NAME property. <br>    lpRow-&gt;lpProps[0].ulPropTag = PR_DISPLAY_NAME; <br>    lpRow-&gt;lpProps[0].Value.LPSZ = lpBuf; <br>    memmove( lpBuf, lpszTFolderName, cTFNameSize); // Copies trailing null as well. <br>    lpBuf += cTFNameSize; <br>     <br>    // Setup the PR_ENTRYID property. <br>    lpRow-&gt;lpProps[1].ulPropTag = PR_ENTRYID; <br>    lpRow-&gt;lpProps[1].Value.bin.cb = cbEID; <br>    lpRow-&gt;lpProps[1].Value.bin.lpb = lpBuf; <br>    memmove( lpBuf, lpEID, cbEID); <br> <br>cleanup: <br>    RETURN( hr);     <br>} <br> <br>//$--STFolderArray_HrInit--------------------------------------------------------- <br>// This MUST be called only once at the begining before using the topic folders <br>// or the topic cache functions.  Be sure to use STFolderArray_Destroy() when <br>// done with the array. <br>// <br>// Initialize the global topic folder array by filling it with the display name  <br>// and entry id of all folders under the topics folder. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STFolderArray_HrInit() <br>{ <br>    HRESULT     hr              = NOERROR; <br>    LPMAPITABLE lpTopicsTable   = NULL; <br> <br>    SizedSPropTagArray( 2, PropTagArray) = { 2, { PR_DISPLAY_NAME, PR_ENTRYID}}; <br>    SizedSSortOrderSet( 1, SortOrderSet) = { 1, 0, 0, { PR_DISPLAY_NAME, TABLE_SORT_ASCEND}}; <br> <br>    DEBUGPUBLIC( "STFolderArray_HrInit()"); <br> <br>    // Initialize to an empty array. <br>    TFolderArray.cAllocatedRows = 0; <br>    TFolderArray.lpRows = NULL; <br> <br>    // Make sure the global lpTopicsFolder is initialized. <br>    if( !lpTopicsFolder) <br>    {    <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Open an interface to a table that will give us a list of all topic folders. <br>    hr = MAPICALL( lpTopicsFolder)-&gt;GetHierarchyTable( lpTopicsFolder,  <br>        MAPI_DEFERRED_ERRORS, &amp;lpTopicsTable); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Get all folder rows in a sorted order. If there were no rows we <br>    // still get a pointer to a SRowSet structure with a count of zero. <br>    hr = HrQueryAllRows( lpTopicsTable, (LPSPropTagArray) &amp;PropTagArray, NULL,  <br>        (LPSSortOrderSet) &amp;SortOrderSet, 0, &amp;TFolderArray.lpRows); <br>    if(FAILED( hr)) <br>        goto cleanup; <br> <br>    // Set the number of rows the current allocation of the array will hold. <br>    TFolderArray.cAllocatedRows = TFolderArray.lpRows-&gt;cRows; <br> <br>cleanup: <br>    ULRELEASE( lpTopicsTable); <br>    RETURN( hr); <br>} <br> <br>//$--STFolderArray_Find--------------------------------------------------------- <br>// Find a topic folder in the global topic folder array. <br>// RETURNS: The index of the topic or NOT_FOUND. <br>// ----------------------------------------------------------------------------- <br> <br>ULONG STFolderArray_Find(  <br>    IN LPTSTR lpszTFolderName)     // The name of the topic folder you want to find. <br>{ <br>    LPBYTE lpTFolder = bsearch(  <br>        lpszTFolderName,  <br>        TFolderArray.lpRows-&gt;aRow,  <br>        STFolderArray_GetCount(),  <br>        sizeof( SRow),  <br>        Compare_DispName); <br>     <br>    if( lpTFolder) <br>        return( (lpTFolder - ((LPBYTE) TFolderArray.lpRows-&gt;aRow)) / sizeof( SRow)); <br>    return( NOT_FOUND); <br>} <br> <br>//$--STFolderArray_HrCreateFolder------------------------------------------------ <br>// Create a new topic folder and insert into the array so that the array remains <br>// sorted by PR_DISPLAY_NAME and we keep the entry id.  This will also place <br>// this folder in the topic cache with just the folder open. <br>// <br>// OUTPUT:  lppNewFolder    Open folder interface ptr.  Do NOT release this. <br>//          lppTopic        Open Topic cache object pointer. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STFolderArray_HrCreateFolder(  <br>    IN  LPTSTR          lpszTFolderName,    // The name of the topic folder you want to create. <br>    OUT LPMAPIFOLDER*   lppNewFolder,       // Folder interface ptr to create. <br>    OUT STopic**        lppTopic)           // Open Topic cache object pointer. <br>{ <br>    HRESULT      hr            = NOERROR; <br>    ULONG        iTFolderArray = NOT_FOUND; <br>    ULONG        cValues       = 0L; <br>    LPSPropValue lpProp        = NULL;       // Returned binary data <br> <br>    static const SizedSPropTagArray(1,PropEID) = {1, {PR_ENTRYID}}; <br> <br>    DEBUGPUBLIC( "STFolderArray_HrCreateFolder()"); <br>    hr = CHK_STFolderArray_HrCreateFolder( lpszTFolderName, lppNewFolder, lppTopic); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Initialize output ptrs to NULL in case of failure. <br>    *lppNewFolder = NULL; <br>    *lppTopic = NULL; <br> <br>    // Create the MAPI folder. <br>    hr = MAPICALL( lpTopicsFolder)-&gt;CreateFolder( lpTopicsFolder, <br>        FOLDER_GENERIC, <br>        lpszTFolderName, <br>        lpszTFolderName, <br>        NULL, <br>        fMapiUnicode | OPEN_IF_EXISTS | MAPI_DEFERRED_ERRORS, <br>        lppNewFolder); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ASSERT_IUNKNOWN_PTR( *lppNewFolder, "INVALID new folder pointer"); <br> <br>    hr = MAPICALL( *lppNewFolder)-&gt;GetProps( *lppNewFolder, <br>        (LPSPropTagArray)&amp;PropEID, <br>        fMapiUnicode, <br>        &amp;cValues, <br>        &amp;lpProp); <br>    if( FAILED(hr) || hr == MAPI_W_ERRORS_RETURNED) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR( cValues != 0, "NO property values returned!"); <br>    ASSERTERROR( lpProp-&gt;ulPropTag == PR_ENTRYID, "INVALID property tag returned!"); <br> <br>    // Find a slot in this array to insert this topic folder at. <br>    if( TFolderArray.lpRows-&gt;cRows == 0) <br>        iTFolderArray = 0; <br>    else <br>        iTFolderArray = STFolderArray_FindInsertionPt( lpszTFolderName,  <br>            TFolderArray.lpRows-&gt;cRows, TFolderArray.lpRows-&gt;aRow); <br> <br>    // Insert new topic folder info into the array and adjust the topic cache. <br>    hr = STFolderArray_HrInsert( iTFolderArray, lpszTFolderName,  <br>        (ULONG)lpProp-&gt;Value.bin.cb, (LPENTRYID)lpProp-&gt;Value.bin.lpb); <br>    if( FAILED(hr) &amp;&amp; hr != MAPI_E_NETWORK_ERROR) <br>    { <br>        if( FAILED( HrDeleteTopicFolder( <br>            (ULONG)lpProp-&gt;Value.bin.cb, (LPENTRYID)lpProp-&gt;Value.bin.lpb))); <br>        goto cleanup; <br>    } <br>     <br>    // Place just the folder interface ptr in the first topic slot of the cache. <br>    STopicCache_SetTopicFolder( iTFolderArray, *lppNewFolder, lppTopic); <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpProp); <br> <br>    if( FAILED( hr)) <br>        ULRELEASE( *lppNewFolder); <br> <br>    RETURN( hr); <br>} <br> <br>//$--STFolderArray_HrDeleteFolder----------------------------------------------- <br>// Deletes a topic folder from the MAPI store and the TFolderArray. This also  <br>// removes it from the topic cache and adjusts the indexed references to this array. <br>// <br>// NOTE: Use STFolderArray_HrDeleteFolderSZ() if you only have the topic folder  <br>//       name and not the index. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STFolderArray_HrDeleteFolder( <br>    IN ULONG iTFolderArray)     // Index of folder to be deleted. <br>{ <br>    HRESULT     hr      = NOERROR; <br>    ULONG       cBytes  = 0;   <br>    ULONG       cbEID   = 0;          // Count of bytes in Entry ID <br>    LPENTRYID   lpEID   = NULL;       // Pointer to Entry ID. <br>    LPSRow      lpRow   = NULL; <br> <br>    DEBUGPUBLIC( "STFolderArray_HrDeleteFolder()"); <br>    hr = CHK_STFolderArray_HrDeleteFolder( iTFolderArray); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Delete the folder from the MAPI store and any messages that are in it. <br>    // This must be done before freeing the buffer that contains the entry id. <br>    cbEID = STFolderArray_GetCbEID( iTFolderArray); <br>    lpEID = STFolderArray_GetEID( iTFolderArray); <br>    hr = HrDeleteTopicFolder( cbEID, lpEID); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Remove the item from the cache and adjust the index in the <br>    // topic cache that references any index &gt;= iTFolderArray. <br>    STopicCache_DeleteTopic( iTFolderArray); <br> <br>    // The address of the row in the folder array we wish delete. <br>    lpRow = TFolderArray.lpRows-&gt;aRow + iTFolderArray; <br> <br>    // Free the buffer that contains the properties for this row. <br>    MAPIFREEBUFFER( lpRow-&gt;lpProps); <br>     <br>    // We now have one less item in the array.  <br>    TFolderArray.lpRows-&gt;cRows --; <br> <br>    // Are we deleting from the middle of the array? <br>    if( iTFolderArray &lt; TFolderArray.lpRows-&gt;cRows) <br>    {   // YES, so move all items up by one entry. <br>        cBytes = (TFolderArray.lpRows-&gt;cRows - iTFolderArray) * sizeof( SRow); <br>        memmove( lpRow, lpRow + 1, cBytes); <br>    } <br> <br>    // Zero the memory of the old last item in the array. <br>    memset( TFolderArray.lpRows-&gt;aRow + TFolderArray.lpRows-&gt;cRows, 0, sizeof( SRow)); <br> <br>cleanup: <br>    RETURN( hr);     <br>} <br> <br>// ----------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
