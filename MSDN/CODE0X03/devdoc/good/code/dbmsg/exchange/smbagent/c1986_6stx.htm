<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOPCACHE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1995"></a>TOPCACHE.H</h2>
<pre><code>// --TopCache.H---------------------------------------------------------------- <br>//  <br>// This module contains functions for maintaining and using a topic cache for  <br>// SMBAGENT. <br>// <br>// The cache is essentialy a fixed size array of open topic objects.  The first <br>// slot in the cache contains the most recently used topic and the last contains <br>// the oldest topic.   <br>// <br>// Each topic item contains a count of the times it was used while in the cache.   <br>// It also contains an index into the STFolderArray of the folder this topic <br>// belongs to.  This index is used to determine if a topic folder is in the  <br>// cache.  The index is adjusted when an item is inserted or deleted in the  <br>// STFolderArray. <br>// <br>// The cache has a DROP ZONE, which is at the end of the cache.  Both the size <br>// of the cache and the drop zone are adjustable by the user.  The drop zone is <br>// the area of the cache in which items are available for removal.  All slots <br>// above the drop zone are safe from being removed, thus giving them some time <br>// to accumulate a usage count. <br>// <br>// To decide which item to remove from the cache we start at the drop zone  <br>// index and search to the end for the slot whose item has had the least use. <br>// If more than one item has the same low usage count then the one with the  <br>// highest index will be choosen. <br>// <br>// When the cache is full the last item in the cache will have it's usage count <br>// decremented each time the cache is used.  This prevents an item that got a  <br>// burst of activity, accumulating a high usage count, and then was never used <br>// again from remaining in the cache forever. <br>// <br>// The reason for a drop zone, as opposed to always tossing out the last item,  <br>// is to give those items that are used a lot, but not always with in the time <br>// it takes to move from the top to the bottom of the cache, a chance to stick <br>// around long enough to get used again. <br>// <br>// NOTE: If you want the cache to always toss out the last item set the drop  <br>//       zone index to the maximum cache size minus one. <br>// <br>// See TOPCACHE.H for details on the relationship between the STFolderArray, the <br>// STopicCache, and the STopic objects. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#ifndef _TOPCACHE_H_ <br>#define _TOPCACHE_H_ <br> <br>#ifndef PROTECTED <br>#define PROTECTED  <br>#endif <br> <br>//$--STopicCache---------------------------------------------------------------- <br>// Topic cache structure.  There will be only one instance of this object. <br>// ----------------------------------------------------------------------------- <br> <br>typedef struct <br>{ <br>    ULONG   cMaxItems;      // Maximum items cache will hold. <br>    ULONG   cTotItems;      // Total items currently in the cache. <br>    ULONG   iDropZone;      // The starting index at which items become available  <br>                            // for removal from the cache.                         <br>    STopic* lpTopicArray;   // The actual cache array. <br>} STopicCache; <br> <br>// ----------------------------------------------------------------------------- <br>// Initialize the topic cache to an empty state. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STopicCache_HrInit( <br>    IN  ULONG   cMaxTopics, // The maximum number of topics the cache will hold. <br>    IN  ULONG   iDropZone); // The starting index at which items become available <br>                            // for removal from the cache. <br> <br>// Release all topic items. <br>void STopicCache_ReleaseAll(); <br> <br>// ----------------------------------------------------------------------------- <br>// This function gets the topic associated with the folder specified by the <br>// iTFolderArray index.  If the topic is in the cache it moves it to the top and  <br>// then returns it, otherwise it performs all the operations necessary to open  <br>// the topic. <br>// <br>// NOTE: The data pointed to by the returned pointer will be different once this  <br>//       function is called again for a new pointer.  In this implementation <br>//       it will always return a pointer to the first slot in the cache, but <br>//       don't depend upon it since the implementation could change. <br>// <br>// RETURNS: a pointer to the STopic object. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT STopicCache_HrGetTopic( <br>    IN  ULONG       iTFolderArray,  // Index into TFolderArray of topic we want. <br>    OUT STopic**    lppTopic);       // We return the topic ptr in this var. <br> <br> <br>#ifdef FRIEND_OF_STOPICCACHE <br> <br>// ----------------------------------------------------------------------------- <br>// Frees the first slot in the cache to be used for a new topic. <br>// RETURNS: a pointer to the first slot in the cache. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED STopic* STopicCache_FreeFirstTopicSlot(); <br> <br>// ----------------------------------------------------------------------------- <br>// Adjust the index of all topic objects that contain an index that is greater <br>// than or equal to iTFolderArray.  This is used when a new folder in inserted <br>// into or deleted from the middle of the folder array. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED void STopicCache_AdjustIndex( <br>    IN  ULONG       iTFolderArray,  // Index into TFolderArray of topic we want. <br>    IN  int         nAddSub);        // +1 indicates insert and -1 delete folder. <br> <br>// ----------------------------------------------------------------------------- <br>// Remove the item from the cache and adjust the index in the topic cache that  <br>// references any index &gt;= iTFolderArray. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED void STopicCache_DeleteTopic( <br>    IN  ULONG       iTFolderArray);  // Index into TFolderArray of topic we want to delete. <br> <br>// ----------------------------------------------------------------------------- <br>// Free the first topic cache slot and place just the folder interface ptr in the slot. <br>// ----------------------------------------------------------------------------- <br> <br>PROTECTED __inline void STopicCache_SetTopicFolder( <br>    IN  ULONG           iTFolderArray, // Index into TFolderArray of topic we want. <br>    IN  LPMAPIFOLDER    lpNewFolder,   // An already open folder interface ptr. <br>    OUT STopic**        lppTopic)      // We return the topic ptr in this var. <br>{ <br>    *lppTopic = STopicCache_FreeFirstTopicSlot(); <br>    STopic_SetFolder( *lppTopic, iTFolderArray, lpNewFolder); <br>} <br> <br>// ----------------------------------------------------------------------------- <br> <br>#endif //FRIEND_OF_STOPICCACHE <br>// ----------------------------------------------------------------------------- <br> <br>#endif // _TOPCACHE_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
