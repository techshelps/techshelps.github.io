<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMMANDS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1987"></a>COMMANDS.C</h2>
<pre><code>// --Commands.c----------------------------------------------------------------- <br>//  <br>// This module contains SMBAGENT's command table and the handling procedure for  <br>// each of SMBAGENT's commands. <br>// <br>//  New         Create a new topic with an introduction.                      <br>//  Join        Join a topic as a subscriber.                                 <br>//  Post        Post a message to a topic and broadcast it to all members.    <br>//  Intro       Return the introductory message of a topic to the subscriber. <br>//  Leave       Remove a subscriber from the topic.                           <br>//  Topics      List all topics placing "***" before those you subscribe to.  <br>//  Members     List all members of a topic.                                  <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include &lt;ctype.h&gt; <br>#include "commands.chk" <br> <br>#include "smbagent.h" <br>#include "resource.h" <br> <br>#define UNINITIALIZED   -1L                 // flag for uninitalized property tags <br> <br>// Command handling procedure declarations <br>static  HRESULT      HrParseCommand( LPMESSAGE); <br>static  VOID         DoneWithMessage(); <br> <br>static HRESULT     HrProcessNew( LPMESSAGE); <br>static HRESULT     HrProcessJoin( LPMESSAGE); <br>static HRESULT     HrProcessPost( LPMESSAGE); <br>static HRESULT     HrProcessIntro( LPMESSAGE); <br>static HRESULT     HrProcessLeave( LPMESSAGE); <br>static HRESULT     HrProcessTopics( LPMESSAGE); <br>static HRESULT     HrProcessMembers( LPMESSAGE); <br> <br>// Command table definition <br>typedef struct <br>{ <br>    ULONG   ulCmdRID;                   // Resource ID for command string <br>    TCHAR   szCmdName[MAXCMDLEN];       // Command name string <br>    HRESULT (*lpfnCmdProc)              // Command handling procedure <br>        (LPMESSAGE  lpMessage);         // Entry ID and size for message <br>} CMDENTRY;                             // Command entry <br> <br>static CMDENTRY aCmdTable[] = <br>{ <br>    { IDS_CMD_NEW,      TEXT(""),   HrProcessNew }, <br>    { IDS_CMD_JOIN,     TEXT(""),   HrProcessJoin }, <br>    { IDS_CMD_POST,     TEXT(""),   HrProcessPost }, <br>    { IDS_CMD_INTRO,    TEXT(""),   HrProcessIntro }, <br>    { IDS_CMD_LEAVE,    TEXT(""),   HrProcessLeave }, <br>    { IDS_CMD_TOPICS,   TEXT(""),   HrProcessTopics }, <br>    { IDS_CMD_MEMBERS,  TEXT(""),   HrProcessMembers }, <br>}; <br> <br>static  TCHAR   lpszTopicName[MAXSUBJLEN + 1] = {0};     // Topic of current msg. <br>static  LPTSTR  lpszCommand                   = NULL;    // Command of current msg. <br> <br>//$--HrParseCommand()---------------------------------------------------------- <br>// Parses out the command and the topic strings from the subject of the given  <br>// message.  One thing we found that we needed to be careful of was to eliminate <br>// all un-necessary white space from the topic string. <br>// <br>// The globals lpszCommand and lpszTopicName are used to contain the result. <br>// ---------------------------------------------------------------------------- <br> <br>static HRESULT HrParseCommand( <br>    IN  LPMESSAGE   lpMessage)      // Pointer to the current message object <br>{ <br>    HRESULT hr          = NOERROR; <br>    TCHAR   *pchSubject = lpSenderProps[IDX_SUBJECT].Value.LPSZ; <br>    TCHAR   *pchTopic   = lpszTopicName; <br>         <br>    DEBUGPUBLIC( "HrParseCommand()"); <br> <br>    hr = CHK_HrParseCommand( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    if( pchSubject == NULL) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Extract the command from the subject string. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Skip past any initial white space <br>    while( *pchSubject &amp;&amp; isspace(*pchSubject)) pchSubject++; <br>    lpszCommand = pchSubject; <br> <br>    // Skip past command string <br>    while( *pchSubject &amp;&amp; !isspace(*pchSubject)) pchSubject++; <br>if(*pchSubject) *pchSubject++ = TEXT('\0'); <br> <br>    if( lstrlen( lpszCommand) &gt; MAXCMDLEN) <br>    {   // The string is longer than any recognizeable command. <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_INVALID_COMMAND)); <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if( lstrlen( pchSubject) &gt; MAXSUBJLEN) <br>    {   // The topic name is much longer than a reasonable limit. <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_TOPIC_TOO_LONG)); <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Extract the topic string from the subject string, eliminating all  <br>// un-necessary white space. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    for( ;;) <br>    { <br>        // Skip white space <br>        while( *pchSubject &amp;&amp; isspace(*pchSubject)) <br>            pchSubject++; <br> <br>        if( !*pchSubject) <br>        { // finish the topic string <br>            *pchTopic = TEXT('\0'); <br>            goto cleanup; <br>        } <br> <br>        // Add single space to topic <br>        if( pchTopic &gt; lpszTopicName)  <br>            *pchTopic++ = TEXT(' ');     <br>         <br>        // Add the token to the topic string. <br>        while( *pchSubject &amp;&amp; !isspace( *pchSubject)) <br>            *pchTopic++ = *pchSubject++; <br>    } <br> <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>//$--HrProcessNew--------------------------------------------------------------- <br>// "New" command handling procedure <br>//  - creates a topic folder (if one does not exist) for the new topic, <br>//  - saves a modified version of the command message in the topic folder. <br>// <br>// The intro message is stored in the MAPI_ASSOCIATED portion of the topic  <br>// folder.  We gave it a unique message class so that we can use the  <br>// FindRow() function to locate it later.  This is a quick opperation <br>// since very few items will ever be stored in this location. <br>// <br>// We chose this method rather than storing it in the main portion of the topic <br>// folder to avoid sorting the folder, which could get quite large.  Sorting a <br>// folder is an expensive opperation at the server end and should only be used <br>// when it is necessary. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrProcessNew(  <br>    IN  LPMESSAGE   lpMessage)      // Pointer to the current message object <br>{ <br>    HRESULT         hr              = NOERROR; <br>    LPMAPIFOLDER    lpNewFolder     = NULL; <br>    LPMESSAGE       lpNewMsg        = NULL; <br>    ULONG           iTFolderArray   = NOT_FOUND; <br>    ULONG           cStrLen         = 0; <br>    ULONG           cbFolderEID     = 0L; <br>    LPENTRYID       lpFolderEID     = NULL; <br>    STopic*         lpTopic         = NULL; <br> <br>    DEBUGPUBLIC( "HrProcessNew()"); <br>    hr = CHK_HrProcessAny( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    if( !*lpszTopicName) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NULL_PARAM)); <br>        goto cleanup; <br>    } <br> <br>    // If the topic already exists, generate an error report <br>    iTFolderArray = STFolderArray_Find( lpszTopicName); <br>    if( iTFolderArray != NOT_FOUND) <br>    {   // Send an error report <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_TOPIC_EXISTS)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Create the new topic folder and copy the topic introduction message into the <br>// associated portion of the folder. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Create a new topic folder. <br>    hr = STFolderArray_HrCreateFolder( lpszTopicName, &amp;lpNewFolder, &amp;lpTopic); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Copy the command message into the topic folder <br>    hr = HrDuplicateMessage( lpMessage, lpNewFolder, MAPI_ASSOCIATED, <br>        lpPropsToCopyForKeep, &amp;lpNewMsg); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Initialize the topic message. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Set the recipient list to the topic creator. <br>    hr = MAPICALL( lpNewMsg)-&gt;ModifyRecipients( lpNewMsg, 0L, lpSenderAddr); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Set the Subject field. <br>    cStrLen = LoadString( hInst, IDS_SUBJ_INTRO, (LPTSTR)&amp;szSubjBuf, MAXSUBJLEN); <br>    _tcscat( szSubjBuf, lpszTopicName); <br> <br>    {   // Encapsulate to make code clear <br>        SInitPropValue SPropValues[] = <br>        { <br>            { PR_SUBJECT,       0, (ULONG) szSubjBuf}, <br>            { PR_MESSAGE_CLASS, 0, (ULONG) INTRO_MSG_CLASS} <br>        }; <br>         <br>        hr = MAPICALL( lpNewMsg)-&gt;SetProps( lpNewMsg, <br>            2L, (LPSPropValue)&amp;SPropValues, NULL); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>    } <br> <br>    // Save the changes to the message. <br>    hr = MAPICALL(lpNewMsg)-&gt;SaveChanges( lpNewMsg,  <br>        FORCE_SAVE | KEEP_OPEN_READWRITE); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Let the topic object know about the open message interface pointer. <br>    STopic_SetIntroMsg( lpTopic, lpNewMsg); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Add user to the access control list of the public folder.  This will allow  <br>// the user to read the folder with the Capone client. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    if( bPublicTopic) <br>    { <br>        // This call will fail when the originator is a one-off.  Since this feature <br>        // is not necessary to interact with the list server we ignore the error.  <br> <br>        HR_LOG( HrModifyACL(  <br>            lpNewFolder,            // Folder to modify ACL for. <br>            TEXT("Default"),        // Name of user to change. <br>            0L,                     // Byte count for User's entry id. <br>            NULL,                   // User's entry id. <br>            FALSE,                  // Do not remove rights. <br>            rightsReadOnly)); <br> <br>        HR_LOG( HrModifyACL( <br>            lpNewFolder, <br>            lpSenderProps[ IDX_SENDER_NAME].Value.LPSZ, <br>            lpSenderProps[ IDX_SENDER_ENTRYID].Value.bin.cb, <br>            (LPENTRYID)lpSenderProps[ IDX_SENDER_ENTRYID].Value.bin.lpb, <br>            FALSE, <br>            dwACLRights)); <br>    } <br> <br>    hr = HrSendConfirmReport( lpMessage, IDS_CMD_NEW, IDS_CNF_NEW, NULL); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>cleanup: <br>    if( FAILED(hr) &amp;&amp; hr != MAPI_E_NETWORK_ERROR &amp;&amp; lpNewFolder) <br>    {   // We failed after the topic folder was created so delete it <br>        // from the MAPI store, the topic array, and the topic cache. <br>        HR_LOG( STFolderArray_HrDeleteFolderSZ( lpszTopicName)); <br>    } <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrProcessJoin---------------------------------------------------------- <br>// "Join" command handling routine <br>// ------------------------------------------------------------------------- <br>static HRESULT HrProcessJoin(  <br>    IN  LPMESSAGE   lpMessage)     // Pointer to the current message object <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    LPMESSAGE       lpIntroMsg          = NULL; <br>    ULONG           iTFolderArray       = NOT_FOUND; <br>    ULONG           iSubscriber         = NOT_FOUND; <br>    STopic*         lpTopic             = NULL; <br> <br>    DEBUGPUBLIC( "HrProcessJoin()"); <br>    hr = CHK_HrProcessAny( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>if( !*lpszTopicName) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NULL_PARAM)); <br>        goto cleanup; <br>    } <br> <br>// If the topic does not exist generate an error report. <br>    iTFolderArray = STFolderArray_Find( lpszTopicName); <br>    if( iTFolderArray == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONEXIST_TOPIC)); <br>        goto cleanup; <br>    } <br>     <br>    // Get the topic object from the cache. <br>    hr = STopicCache_HrGetTopic( iTFolderArray, &amp;lpTopic); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>     <br>    // Check if the sender is already a subscriber of the topic <br>    hr = STopic_HrFindSubscriber( lpTopic, &amp;iSubscriber); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    if( iSubscriber != NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_IS_SUBSCRIBER)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Add user to the access control list of the public folder.  This will allow  <br>// the user to read the folder with the Capone client. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    if( bPublicTopic) <br>    { <br>        LPMAPIFOLDER lpJoinFolder = STopic_GetFolder( lpTopic); <br> <br>        // This call will fail when the originator is a one-off.  Since this feature <br>        // is not necessary to interact with the list server we ignore the error.  <br> <br>        HR_LOG( HrModifyACL( <br>            lpJoinFolder, <br>            lpSenderProps[ IDX_SENDER_NAME].Value.LPSZ, <br>            lpSenderProps[ IDX_SENDER_ENTRYID].Value.bin.cb, <br>            (LPENTRYID)lpSenderProps[ IDX_SENDER_ENTRYID].Value.bin.lpb, <br>            FALSE, <br>            dwACLRights)); <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Add this JOINer to the recipient list of the topic intro message, and send <br>// a confirmation to the originator. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>     <br>    // Add the subscriber to intro msg and memory buffer. <br>    hr = STopic_HrAddSubscriber( lpTopic, lpSenderAddr); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Send a confirmation report to the message originator. <br>    lpIntroMsg = STopic_GetIntroMsg( lpTopic); <br>    hr = HrSendConfirmReport( lpMessage, IDS_CMD_JOIN, IDS_CNF_JOIN, lpIntroMsg); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>  <br>    RETURN( hr); <br>} <br> <br>//$--HrProcessPost---------------------------------------------------------- <br>//  "Post" command handling procedure <br>//  - saves a copy of the command message in the topic folder, and <br>//  - distributes the command message to all subscribers of the topic <br>// ------------------------------------------------------------------------- <br>static  HRESULT HrProcessPost( <br>    IN LPMESSAGE    lpMessage)      // Pointer to the current message object <br>{ <br>    HRESULT         hr              = NOERROR; <br>    unsigned        cStrLen         = 0; <br>    ULONG           fModRecip       = 0L;   //ModifyRecipients flag -&gt; replace list <br>    LPMAPIFOLDER    lpTopicFolder   = NULL; <br>    LPMESSAGE       lpPostMsg       = NULL; <br>    LPMESSAGE       lpSendMsg       = NULL; <br>    LPADRLIST       lpAdrList       = NULL; <br>    ULONG           iTFolderArray   = NOT_FOUND; <br>    ULONG           iSubscriber     = NOT_FOUND; <br>    STopic*         lpTopic         = NULL; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Two copies of the original posted message is made.  One to keep in the topic <br>// folder, and the other to be distributed to the subscribers.   <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    DEBUGPUBLIC( "HrProcessPost()"); <br>    hr = CHK_HrProcessAny( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    if( !*lpszTopicName) <br>    { <br>        HR_LOG( HrSendErrReport(lpMessage, IDS_ERR_NULL_PARAM)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Find the topic folder and get the topic and subscriber list. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // If the topic does not exist generate an error report. <br>    iTFolderArray = STFolderArray_Find( lpszTopicName); <br>    if( iTFolderArray == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONEXIST_TOPIC)); <br>        goto cleanup; <br>    } <br>     <br>    // Get the topic object from the cache. <br>    hr = STopicCache_HrGetTopic( iTFolderArray, &amp;lpTopic); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Verify that the sender is a subscriber of the topic <br>    hr = STopic_HrFindSubscriber( lpTopic, &amp;iSubscriber); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    if( iSubscriber == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONSUBSCRIBER)); <br>        goto cleanup; <br>    } <br> <br>    // Get the pointer to the topic folder. <br>    lpTopicFolder = STopic_GetFolder( lpTopic); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Save a copy of the posting in the topic folder. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Make a copy of the command message in the topic-folder <br>    hr = HrDuplicateMessage( lpMessage, lpTopicFolder, 0, lpPropsToCopyForKeep, &amp;lpPostMsg); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Replace the Subject field with a fixed string <br>    cStrLen = LoadString( hInst, IDS_SUBJ_POST, (LPTSTR)&amp;szSubjBuf, MAXSUBJLEN); <br>    _tcsncat( szSubjBuf, lpszTopicName, MAXSUBJLEN - cStrLen); <br> <br>hr = HrMAPISetPropString( (LPMAPIPROP)lpPostMsg, PR_SUBJECT, szSubjBuf); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// Save the changes to the message <br>    hr = MAPICALL(lpPostMsg)-&gt;SaveChanges( lpPostMsg, FORCE_SAVE); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Can't send a message that's was created in a public folder, so make a copy of <br>// the posting in the NDR folder.  Place the entire subscriber list in the  <br>// 'To' field. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Make a copy of posted message in NDR folder for resubmission to all <br>    hr = HrDuplicateMessage( lpMessage, lpNDRFolder, 0, lpPropsToCopyForSend, &amp;lpSendMsg); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// Get a copy of the entire address list of subscribers.  We can't use the  <br>    // original row set since ModifyRecipients will change it which would be bad. <br>    hr = STopic_GetCopyOfSubscriberRowSet( lpTopic, &amp;lpAdrList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Replace/Add-to the TO:list in the msg. with the subscriber list <br>    hr = MAPICALL( lpSendMsg)-&gt;ModifyRecipients(lpSendMsg,  <br>        fModRecip, lpAdrList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Set additional properties then send the message. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>   // Concatenate the sender's display name onto the subject line. <br>    // Must truncate unusually long topic names so that there is enough space. <br>    { // Encapusulate to make code clear <br>        TCHAR szSenderName[MAXSUBJLEN + 1] = {0}; <br>    ULONG cNameLen                     = 0L; <br> <br>        cNameLen = LoadString( hInst, IDS_SUBJ_FROM, (LPTSTR)&amp;szSenderName, MAXSUBJLEN); <br>        _tcsncat( szSenderName, lpSenderProps[IDX_SENDER_NAME].Value.LPSZ, MAXSUBJLEN - cNameLen); <br>     <br>        cNameLen = _tcslen( szSenderName); <br>    cStrLen  = _tcslen( szSubjBuf); <br> <br>        if( cStrLen + cNameLen &gt;= MAXSUBJLEN) <br>            cStrLen = max(MAXSUBJLEN - cNameLen, 15); <br> <br>        _tcsncpy( &amp;szSubjBuf[cStrLen], szSenderName, MAXSUBJLEN - cStrLen); <br>    }   <br> <br>    { // Encapsulate to make code clear <br>        SInitPropValue SPropValues[] = <br>        { <br>            { PR_SUBJECT,             0, (ULONG) szSubjBuf}, <br>            { PR_DELETE_AFTER_SUBMIT, 0, (ULONG) TRUE}, <br>            { PR_MESSAGE_CLASS,       0, (ULONG) SMBAGENT_MSG_CLASS} <br>        }; <br> <br>        hr = MAPICALL( lpSendMsg)-&gt;SetProps( lpSendMsg, <br>            3L, (LPSPropValue)&amp;SPropValues, NULL); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>    } <br> <br>    hr = MAPICALL(lpSendMsg)-&gt;SaveChanges( lpSendMsg,  KEEP_OPEN_READWRITE); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Distribute the message to all subscribers <br>    hr = MAPICALL(lpSendMsg)-&gt;SubmitMessage( lpSendMsg, FORCE_SUBMIT); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>cleanup: <br>    FREEPADRLIST( lpAdrList); <br>    ULRELEASE( lpPostMsg); <br>    ULRELEASE( lpSendMsg); <br> <br>    RETURN( hr); <br>} <br> <br>//$--HrProcessIntro---------------------------------------------------------- <br>//  "Intro" command handling routine  <br>//  - Sends a copy of the topic Intro message to the command originator <br>// ------------------------------------------------------------------------- <br>static  HRESULT HrProcessIntro( <br>    IN  LPMESSAGE   lpMessage)      // Pointer to the current message object <br>{ <br>    HRESULT         hr              = NOERROR; <br>    LPMESSAGE       lpIntroMsg      = NULL; <br>    LPSRowSet       lpRows          = NULL; <br>    LPMAPITABLE     lpRecipTable    = NULL; <br>    ULONG           iTFolderArray   = NOT_FOUND; <br>    ULONG           iSubscriber     = NOT_FOUND; <br>    STopic*         lpTopic         = NULL; <br>    ENTRYLIST       elIntroMsg      = { 1L, NULL }; <br>    SPropTagArray   aptEntryID      = { 1L, {PR_ENTRYID} }; <br> <br> <br>    DEBUGPUBLIC( "HrProcessIntro()"); <br>    hr = CHK_HrProcessAny( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    if( !*lpszTopicName) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NULL_PARAM)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Find the topic folder and get the topic and subscriber list. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // If the topic does not exist generate an error report. <br>    iTFolderArray = STFolderArray_Find( lpszTopicName); <br>    if( iTFolderArray == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONEXIST_TOPIC)); <br>        goto cleanup; <br>    } <br>     <br>    // Get the topic object from the cache. <br>    hr = STopicCache_HrGetTopic( iTFolderArray, &amp;lpTopic); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Verify that the sender is a subscriber of the topic <br>    hr = STopic_HrFindSubscriber( lpTopic, &amp;iSubscriber); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    if( iSubscriber == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONSUBSCRIBER)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Send an confirmation report including the Intro message. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    lpIntroMsg = STopic_GetIntroMsg( lpTopic); <br>    hr = HrSendConfirmReport( lpMessage, IDS_CMD_INTRO, IDS_CNF_INTRO, lpIntroMsg); <br>    if( FAILED(hr)) <br>        goto cleanup;    <br> <br>cleanup: <br>    RETURN( hr); <br>} <br> <br> <br>//$--HrProcessLeave---------------------------------------------------------- <br>//  "Leave" command handling routine <br>//  - deletes the sender's address from the topic's subscriber list. <br>// ------------------------------------------------------------------------- <br>static  HRESULT HrProcessLeave( <br>    IN  LPMESSAGE   lpMessage)      // Pointer to the current message object <br>{ <br>    HRESULT         hr              = NOERROR; <br>    ULONG           iTFolderArray   = NOT_FOUND; <br>    ULONG           iSubscriber     = NOT_FOUND; <br>    ULONG           cSubscribers    = 0; <br>    STopic*         lpTopic         = NULL; <br> <br>    DEBUGPUBLIC( "HrProcessLeave()"); <br>    hr = CHK_HrProcessAny( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    if( !*lpszTopicName) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NULL_PARAM)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Find the topic folder and get the topic and subscriber list. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // If the topic does not exist generate an error report. <br>    iTFolderArray = STFolderArray_Find( lpszTopicName); <br>    if( iTFolderArray == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONEXIST_TOPIC)); <br>        goto cleanup; <br>    } <br>     <br>    // Get the topic object from the cache. <br>    hr = STopicCache_HrGetTopic( iTFolderArray, &amp;lpTopic); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Verify that the sender is a subscriber of the topic <br>    hr = STopic_HrFindSubscriber( lpTopic, &amp;iSubscriber); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    if( iSubscriber == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONSUBSCRIBER)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Remove user to the access control list of the public folder. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    if( bPublicTopic) <br>    { <br>        LPMAPIFOLDER lpLeaveFolder = STopic_GetFolder( lpTopic); <br> <br>        // This call will fail when the originator is a one-off.  Since this feature <br>        // is not necessary to interact with the list server we ignore the error.  <br> <br>        HR_LOG( HrModifyACL( <br>            lpLeaveFolder, <br>            lpSenderProps[ IDX_SENDER_NAME].Value.LPSZ, <br>            lpSenderProps[ IDX_SENDER_ENTRYID].Value.bin.cb, <br>            (LPENTRYID)lpSenderProps[ IDX_SENDER_ENTRYID].Value.bin.lpb, <br>            TRUE,           // Remove the ACL <br>            dwACLRights)); <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Delete the subscriber from the topic or delete the topic if this subscriber  <br>// is the only one left. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Get the count of subscribers of the topic. <br>    cSubscribers = STopic_GetSubscriberCount( lpTopic); <br> <br>    // Is this the last subscriber? <br>    if( cSubscribers == 1) <br>    {   // YES, so delete the topic and all its messages. <br>        hr = STFolderArray_HrDeleteFolder( iTFolderArray); <br>        if( FAILED(hr)) <br>            goto cleanup; <br>    } <br>    else <br>    {   // Delete sender from the topic's subscriber list.  After this call  <br>        // the subscriber portion of the topic will be uninitialized. <br>        hr = STopic_HrDeleteSubscriber( lpTopic, iSubscriber); <br>        if( FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // Send a confirmation report <br>    hr = HrSendConfirmReport( lpMessage, IDS_CMD_LEAVE, IDS_CNF_LEAVE, NULL); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>cleanup:  <br>    RETURN( hr); <br>} <br> <br>//$--HrProcessTopics---------------------------------------------------------- <br>//  "Topics" command handling routine  <br>//  - Sends a list of topics sender is a member of to the command originator <br>// ---------------------------------------------------------------------------- <br> <br>// Max length of each topic line.  +10 to append other things such as ***\t and \n. <br>#define MAXTOPICSLEN (MAXSUBJLEN + 10)       <br> <br>static  HRESULT HrProcessTopics( <br>    IN  LPMESSAGE   lpMessage)      // Pointer to the current message object <br>{ <br>    HRESULT         hr              = NOERROR; <br>    ULONG           cTopics         = 0; <br>    ULONG           cBytes          = 0; <br>    ULONG           iTFolderArray   = NOT_FOUND; <br>    ULONG           iSubscriber     = NOT_FOUND; <br>    LPTSTR          lpTopicsList    = NULL; <br>    LPTSTR          lpTopicsEntry   = NULL; <br>    BOOL            bFolderErr      = FALSE; <br>    STopic*         lpTopic         = NULL; <br>     <br>    SizedSPropTagArray(1L,aptTableProps)= { 1L, { PR_DISPLAY_NAME } }; <br> <br>    DEBUGPUBLIC( "HrProcessTopics()"); <br>    hr = CHK_HrProcessAny( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Allocate message buffer large enough for all topic names lines.  Each line  <br>// may have three asterisks, a tab, the topic name and a return.  Also allow <br>// for two extra lines worth of space for extra message at end of buffer. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    cTopics = STFolderArray_GetCount(); <br>    cBytes = (((cTopics + 2) * MAXTOPICSLEN) + 1) * sizeof (TCHAR); <br>    hr = MAPIAllocateBuffer( cBytes, &amp;lpTopicsList); <br>    if( FAILED( hr)) <br>    { <br>        hr = HR_LOG( E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br>    ASSERTERROR( lpTopicsList != NULL, "NULL lpTopicsList!"); <br>    memset (lpTopicsList, 0, cBytes); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// List every folder placing three asterisks in front of the ones that the  <br>// sender has subscribed to. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    lpTopicsEntry = lpTopicsList; <br>    for( iTFolderArray = 0; iTFolderArray &lt; cTopics; iTFolderArray ++) <br>    {    <br>        LPTSTR lpszSub;    // To hold either a blank or asterisks. <br> <br>        // Get the topic object from the cache. <br>        hr = STopicCache_HrGetTopic( iTFolderArray, &amp;lpTopic); <br>        if( SUCCEEDED(hr)) <br>        { <br>            // Check to see if the sender is a subscriber of the topic. <br>            hr = STopic_HrFindSubscriber( lpTopic, &amp;iSubscriber); <br>            if( FAILED(hr)) </code></pre>
<p>
</p>
<pre><code>goto cleanup; <br>            if( iSubscriber == NOT_FOUND) <br>                lpszSub = TEXT("\t"); <br>            else <br>                lpszSub = TEXT("***\t"); <br>        } <br>        else <br>        { <br>            lpszSub = TEXT("+++\t"); <br>            bFolderErr = TRUE; <br>        } <br>         <br>        // Record the topic name in the buffer. <br>        lpTopicsEntry += wsprintf( lpTopicsEntry, TEXT("%s%s\r\n"), lpszSub,  <br>            STFolderArray_GetName( iTFolderArray)); <br> <br>        ASSERTERROR( lpTopicsEntry &lt;= ((LPBYTE) lpTopicsList) + cBytes, "ERROR: Buffer overwrite!"); <br>    } <br> <br>    if( lpTopicsEntry == lpTopicsList) <br>    {   // No topics were listed. <br>        lpTopicsEntry += wsprintf( lpTopicsEntry, TEXT("No topics found.\r\n")); <br>    } <br>    else <br>    {   // At least one topic was listed. <br>        lpTopicsEntry += wsprintf( lpTopicsEntry, TEXT("\r\n***\tindicates you are a subscriber.\r\n")); <br> <br>        if( bFolderErr) <br>            lpTopicsEntry += wsprintf( lpTopicsEntry, TEXT( "+++\tindicates subscription information not found.\r\n")); <br>    } <br> <br>    ASSERTERROR( lpTopicsEntry &lt;= ((LPBYTE) lpTopicsList) + cBytes, "ERROR: Buffer overwrite!"); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Add the list to the original message body, save it, and send it as a  <br>// confirmation report. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>     <br>    hr = HrMAPISetPropString( (LPMAPIPROP)lpMessage, PR_BODY, lpTopicsList); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    hr = MAPICALL(lpMessage)-&gt;SaveChanges( lpMessage, KEEP_OPEN_READWRITE); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Send an confirmation report, including the Topics list <br>    hr = HrSendConfirmReport( lpMessage, IDS_CMD_TOPICS, IDS_CNF_TOPICS, NULL); <br>    if( FAILED(hr)) <br>        goto cleanup;    <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpTopicsList); <br>    RETURN( hr); <br>} <br> <br>//$--HrProcessMembers---------------------------------------------------------- <br>//  "Members" command handling routine  <br>//  - Sends a list of members for a given topic to the command originator <br>// ---------------------------------------------------------------------------- <br> <br>#define MAXMEMBERLEN            110     // max length of each member's name/address <br> <br>static  HRESULT HrProcessMembers( <br>    IN  LPMESSAGE   lpMessage)      // Pointer to the current message object <br>{ <br>    HRESULT         hr              = NOERROR; <br>    ULONG           cSubscribers    = 0; <br>    ULONG           cBytes          = 0; <br>    LPTSTR          lpMemberList    = NULL; <br>    LPTSTR          lpMemberEntry   = NULL; <br>    LPSRow          lpRow           = NULL; <br>    ULONG           iTFolderArray   = NOT_FOUND; <br>    ULONG           iSubscriber     = NOT_FOUND; <br>    STopic*         lpTopic         = NULL; <br> <br>    DEBUGPUBLIC( "HrProcessMembers()"); <br>    hr = CHK_HrProcessAny( lpMessage); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    if( !*lpszTopicName) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NULL_PARAM)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Find the topic folder and get the topic and subscriber list. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // If the topic does not exist generate an error report. <br>    iTFolderArray = STFolderArray_Find( lpszTopicName); <br>    if( iTFolderArray == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONEXIST_TOPIC)); <br>        goto cleanup; <br>    } <br>     <br>    // Get the topic object from the cache. <br>    hr = STopicCache_HrGetTopic( iTFolderArray, &amp;lpTopic); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Verify that the sender is a subscriber of the topic <br>    hr = STopic_HrFindSubscriber( lpTopic, &amp;iSubscriber); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    if( iSubscriber == NOT_FOUND) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NONSUBSCRIBER)); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Allocate message buffer for subscriber names each terminated by &lt;return&gt; <br>// and the total list terminated by zero. Assume each name is MAXNAMELEN <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     <br> <br>    cSubscribers = STopic_GetSubscriberCount( lpTopic); <br>    cBytes = ((cSubscribers * MAXMEMBERLEN) + 1) * sizeof(TCHAR); <br>    hr = MAPIAllocateBuffer( cBytes, &amp;lpMemberList); <br>    if( FAILED( hr)) <br>    { <br>        hr = HR_LOG( E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br>    ASSERTERROR( lpMemberList != NULL, "NULL lpMemberList!"); <br>    memset (lpMemberList, 0, cBytes); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     <br>// Make a list of all of the members with their display name and email address. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     <br> <br>    lpMemberEntry = lpMemberList; <br>    lpRow = STopic_GetFirstSubscriber( lpTopic); <br>    while( lpRow)    // Loop through all subscribers to the topic <br>    { <br>        // Format display name and address for one subscriber. <br>        lpMemberEntry += wsprintf( lpMemberEntry, TEXT("%.32s (%.64s)\r\n"),  <br>            lpRow-&gt;GetDispName(), lpRow-&gt;GetEmailAddr()); <br> <br>        lpRow = STopic_GetNextSubscriber( lpTopic); <br>    } <br> <br>    ASSERTERROR( lpMemberEntry &lt;= ((LPBYTE) lpMemberList) + cBytes, "ERROR: Buffer overwrite!"); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     <br>// Add the list to the original message body, save it, and send it back in a  <br>// confirmation report. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -     <br> <br>    hr = HrMAPISetPropString( (LPMAPIPROP)lpMessage, PR_BODY, lpMemberList); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    hr = MAPICALL(lpMessage)-&gt;SaveChanges( lpMessage, KEEP_OPEN_READWRITE); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>    // Send an confirmation report, including the member list <br>    hr = HrSendConfirmReport( lpMessage, IDS_CMD_MEMBERS, IDS_CNF_MEMBERS, NULL); <br>    if( FAILED(hr)) <br>        goto cleanup;    <br> <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>//$--HrProcessCommand ------------------------------------------------------ <br>//  This procedure is called for each message read from Inbox to: <br>//  - validate the command, and  <br>//  - invoke the appropriate handling procedure to process the command. <br>// ------------------------------------------------------------------------- <br>HRESULT HrProcessCommand(  <br>    IN LPMESSAGE    lpMessage,  // Pointer to the current message object <br>    IN LPENTRYLIST  lpelMsgID,  // Pointer to ENTRYLIST of the current message <br>    IN BOOL *       pfDeleted)  // Flag indicating if msg.is deleted upon return <br>{ <br>    HRESULT     hr              = NOERROR; <br>    int         i               = 0; <br>    ULONG       iErrIndex       = 0; <br>    LPTSTR      lpszClass       = NULL;     // Class string of the current msg. <br>    static BOOL fInitialized    = FALSE; <br> <br>    DEBUGPUBLIC( "HrProcessCommand()"); <br> <br>    hr = CHK_HrProcessCommand( lpMessage, lpelMsgID, pfDeleted); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    *pfDeleted = FALSE; // initialize <br>     <br>    hr = HrGetSenderProps( lpMessage); <br>    if( FAILED(hr)) <br>        goto cleanup;   // If we can't do this then we can't send an error report. <br> <br>// Initialize command name strings first time only. <br>    if( !fInitialized) <br>    { <br>        fInitialized = TRUE; <br>        for (i=0; i &lt; (sizeof (aCmdTable) / sizeof (aCmdTable[0])); i++) <br>        { <br>            if (!LoadString( hInst, aCmdTable[i].ulCmdRID, aCmdTable[i].szCmdName, MAXCMDLEN)) <br>            {   // ERROR: Command resource string not found!   <br>                // We can not continue so we signal the service to stop and  <br>                // complete this operation.  The actual stopping of the service  <br>                // will occur a little later. <br>                EventLogMsg( EDKEVENT_ERROR, 1, "Could not initialize the command table.", 0); <br>                ServiceStop(); <br> <br>                // Since we haven't determined the validity of the message, set <br>                // the deleted flag to keep the message from being deleted later. <br>                *pfDeleted = TRUE;   <br> <br>                hr = HR_LOG( E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br>    } <br> <br>    // Initialize new topic folder info if config has changed... <br>    hr = HrInitTopicFolders(); <br>    if( FAILED( hr)) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_INIT_FAILURE)); <br>        goto cleanup; <br>    } <br>     <br>    lpszClass = (LPTSTR) lpSenderProps[ IDX_MESSAGE_CLASS].Value.LPSZ; <br>    ASSERT_STRING_PTR(lpszClass, "lpszClass is not a valid string!"); <br> <br>    if( _tcsicmp(lpszClass, TEXT("IPM.NOTE")) != 0) <br>    {   // Not an IPM.Note so place in the NDR folder. <br>        hr = MAPICALL(lpInFolder)-&gt;CopyMessages( lpInFolder,  <br>            lpelMsgID, NULL, lpNDRFolder, 0L, NULL, 0L); <br>        goto cleanup; <br>    } <br> <br>    // Parse for the command in the Subject field <br>    hr = HrParseCommand( lpMessage); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    if( !*lpszCommand) <br>    { <br>        HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_NULL_COMMAND)); <br>        goto cleanup; <br>    } <br> <br>    // Validate the command by comparing the command token with  <br>    // the command entries in the command table; if match found,  <br>    // invoke the corresponding handling procedure to process the command <br>    for (i=0; i &lt; (sizeof (aCmdTable) / sizeof (aCmdTable[0])); i++) <br>    {    <br>        if( _tcsicmp(lpszCommand, aCmdTable[i].szCmdName) == 0) <br>        { <br>            // NOTE: These command should NOT return an HRESULT error if it sent a mail <br>            // message to the originator due to an error in lpMessage.  E_FAILs <br>            // are reserved to indicate an unexpected error in MAPI or a logic error. <br>            hr = (aCmdTable[i].lpfnCmdProc)( lpMessage); <br>            if( FAILED( hr)) <br>            { <br>                switch(hr) <br>                { <br>                case MAPI_E_NETWORK_ERROR: <br>                    // don't need to log an error <br>                    break; <br> <br>                case EDK_E_NOT_FOUND: <br>                    HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_BAD_TOPIC)); <br>                    break; <br> <br>                default: <br>                    HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_SMBAGENT)); <br>                    break; <br>                } <br>            } <br> <br>            // We are done so we can clean up now. <br>            goto cleanup; <br>        } <br>    } <br>     <br>    // Command not in CmdTable; send an error report to originator <br>    HR_LOG( HrSendErrReport( lpMessage, IDS_ERR_INVALID_COMMAND)); <br>     <br>cleanup: <br>    MAPIFREEBUFFER( lpSenderProps); <br>    lpszCommand = NULL; <br> <br>    RETURN( hr); <br>} <br> <br>// ------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
