<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRACK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2022"></a>TRACK.C</h2>
<pre><code>// --track.c-------------------------------------------------------------------- <br>// <br>// Gateway message tracking sample application. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#define MAX_INPUT_SIZ   1024 <br> <br>#define MAX_RECIPIENTS  7 <br> <br>PVOID       pvSession                           = NULL; <br> <br>UINT        nEventType                          = 0; <br> <br>SYSTEMTIME  stEvent                             = {0}; <br> <br>TCHAR       szGatewayName[MAX_INPUT_SIZ+1]      = {0}; <br> <br>TCHAR       szPartnerName[MAX_INPUT_SIZ+1]      = {0}; <br> <br>TCHAR       szMtsID[MAX_INPUT_SIZ+1]            = {0}; <br> <br>TCHAR       szSubjectMtsID[MAX_INPUT_SIZ+1]     = {0}; <br> <br>TCHAR       szRemoteID[MAX_INPUT_SIZ+1]         = {0}; <br> <br>TCHAR       szOriginatorName[MAX_INPUT_SIZ+1]   = {0}; <br> <br>INT         nPriority                           = 0; <br> <br>INT         nLength                             = 0; <br> <br>INT         nSeconds                            = 0; <br> <br>INT         nCost                               = 0; <br> <br>INT         cRecipients                         = 0; <br> <br>TCHAR       szRecip1[MAX_INPUT_SIZ+1]           = {0}; <br>TCHAR       szRecip2[MAX_INPUT_SIZ+1]           = {0}; <br>TCHAR       szRecip3[MAX_INPUT_SIZ+1]           = {0}; <br>TCHAR       szRecip4[MAX_INPUT_SIZ+1]           = {0}; <br>TCHAR       szRecip5[MAX_INPUT_SIZ+1]           = {0}; <br>TCHAR       szRecip6[MAX_INPUT_SIZ+1]           = {0}; <br>TCHAR       szRecip7[MAX_INPUT_SIZ+1]           = {0}; <br> <br>LPTSTR      lpszRecipients[MAX_RECIPIENTS]      = {0}; <br> <br>static BOOL fInitializedMAPI                    = FALSE; <br> <br>#include "track.chk" <br> <br>// <br>// Names of Command Line Arguments <br>// <br> <br>#define ARG_SERVER"SERVER" <br>#define ARG_HELP1"?" <br>#define ARG_HELP2"HELP" <br> <br>// <br>// Table of Command Line Switches for _HrExpandCommandLineArgument() <br>// <br> <br>static char * rgpszArgArray[] = { <br>ARG_SERVER, <br>ARG_HELP1, <br>ARG_HELP2, <br>}; <br> <br>#define ARGARRAYSIZE (sizeof(rgpszArgArray)/sizeof(rgpszArgArray[0])) <br> <br>// <br>// Variables For Command Line Arguments <br>// <br> <br>char szServer[MAX_PATH+1]= {0}; <br>BOOL fDisplayedHelp= FALSE; <br> <br>// <br>// Functions <br>// <br> <br>//$--ShowUsage------------------------------------------------------------------ <br>//  Show usage information. <br>// ----------------------------------------------------------------------------- <br>static VOID ShowUsage(void)// RETURNS: nothing <br>{ <br>DEBUGPRIVATE("ShowUsage()\n"); <br> <br>    printf("USAGE: TRACK [Flags]\n\n"); <br>printf("  [Flags]        Enter TRACK /? for details\n"); <br> <br>fDisplayedHelp = TRUE; <br>} <br> <br>//$--ShowHelp------------------------------------------------------------------- <br>//  Show help information. <br>// ----------------------------------------------------------------------------- <br>static VOID ShowHelp(void)// RETURNS: nothing <br>{ <br>DEBUGPRIVATE("ShowHelp()\n"); <br> <br>printf("Message Tracking sample.\n\n"); <br>printf("USAGE: TRACK [Flags]\n\n"); <br>printf("  Required Flags\n"); <br>printf("  /SERVER=             Server computer name\n"); <br>printf("\n"); <br>printf("  Optional Flags\n"); <br>printf("  /HELP or /?          Display help\n"); <br> <br>fDisplayedHelp = TRUE; <br>} <br> <br>//$--HrConfig------------------------------------------------------------------- <br>//  Read configuration from command line. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrConfig(           // RETURNS: return code <br>    IN int argc,            // number of arguments on command line <br>    IN char *argv[])        // array of command line arguments <br>{ <br>    HRESULThr= NOERROR; <br>    HRESULThrT= NOERROR; <br>char *pszArgument= NULL; <br>char *pszValue= NULL; <br>    inti= 0; <br> <br>DEBUGPRIVATE("HrConfig()\n"); <br> <br>// If there are no command line arguments then show a usage message. <br> <br>if (argc &lt; 2) <br>{ <br>ShowUsage(); <br>hr = E_FAIL; <br>goto cleanup; <br>} <br> <br>// Do an initial check for /? or /HELP.  If found, show a help message  <br>// and don't do any other parsing. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br>hr = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARGARRAYSIZE, NULL, &amp;pszArgument, &amp;pszValue); <br> <br>if (SUCCEEDED(hr) &amp;&amp; pszArgument &amp;&amp;  <br>(!_stricmp(pszArgument,ARG_HELP1) ||  <br>!_stricmp(pszArgument,ARG_HELP2))) <br>{ <br>ShowHelp(); <br>hr = E_FAIL; <br>goto cleanup; <br>} <br>} <br> <br>// Loop through and parse all the command line arguments. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br>hrT = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARGARRAYSIZE, NULL, &amp;pszArgument, &amp;pszValue); <br> <br>if (FAILED(hrT)) <br>{ <br>hr = hrT; <br> <br>if (hr == EDK_E_NOT_FOUND) <br>{ <br>fprintf(stderr, "ERROR: unknown command line flag: %s\n",  <br>argv[i]); <br>continue; <br>} <br>else <br>{ <br>fprintf(stderr, "ERROR: unable to parse command line.\n"); <br>goto cleanup; <br>} <br>} <br> <br>// Parse flag arguments that don't take a value. <br> <br>else if (pszArgument != NULL &amp;&amp; pszValue == NULL) <br>{ <br>// Other flag (must take a value). <br>fprintf(stderr, "ERROR: flag /%s requires a value\n",  <br>pszArgument); <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>// Parse flag arguments that take a value. <br> <br>else if (pszArgument != NULL &amp;&amp; pszValue != NULL) <br>{ <br>if (!_stricmp(pszArgument,ARG_SERVER)) <br>{    <br>strncpy(szServer, pszValue, MAX_PATH); <br>} <br> <br>// Other flag (must not take a value). <br> <br>else <br>{ <br>fprintf(stderr, "ERROR: flag /%s does not take a value\n",  <br>pszArgument); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Catch unknown arguments. <br> <br>else <br>{ <br>fprintf(stderr, "ERROR: unknown argument %s\n", argv[i]); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Make sure we have all the info we need. <br> <br>if (SUCCEEDED(hr)) <br>{ <br>    if (szServer[0] == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify /%s\n", ARG_SERVER); <br>hr = HR_LOG(E_FAIL); <br>} <br>        else <br>        { <br>            DWORD dwService      = 0; <br>            DWORD dwCurrentState = 0; <br> <br>            hr = HrGetExchangeServiceStatus( <br>                szServer, <br>                EXCHANGE_SA, <br>                &amp;dwCurrentState); <br> <br>            if(FAILED(hr)) <br>            { <br>    fprintf( <br>        stderr, <br>        "ERROR: please start Exchange system attendant on %s\n", <br>        szServer); <br>    hr = HR_LOG(E_FAIL); <br>            } <br>        } <br>} <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br>//$--HrDoEnterString------------------------------------------------------------ <br>//  Enter a string. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrDoEnterString(                // RETURNS: return code <br>    IN LPTSTR lpszPrompt,               // prompt <br>    OUT LPTSTR lpszString)              // string buffer <br>{ <br>    HRESULT hr                       = NOERROR; <br>    TCHAR   szInput[MAX_INPUT_SIZ+1] = {0}; <br> <br>    hr = CHK_HrDoEnterString( <br>        lpszPrompt, <br>        lpszString); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    lpszString[0] = 0; <br> <br>    printf("\n%s: ", (lpszPrompt != NULL ? lpszPrompt : "")); <br> <br>    if(gets(szInput) == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        printf("\nERROR: gets() failed\n"); <br>    } <br>    else <br>    { <br>        strncpy(lpszString, szInput, MAX_INPUT_SIZ); <br>        lpszString[MAX_INPUT_SIZ] = 0; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrDoEnterNumber------------------------------------------------------------ <br>//  Enter a number. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrDoEnterNumber(                // RETURNS: return code <br>    IN LPTSTR lpszPrompt,               // prompt <br>    IN BOOL fAllowNegative,             // TRUE=allow negative number <br>    OUT LONG *lplNumber)                // number <br>{ <br>    HRESULT hr                       = NOERROR; <br>    TCHAR   szInput[MAX_INPUT_SIZ+1] = {0}; <br>    LONG    lNumber                  = 0; <br>    LONG    cMatch                   = 0; <br> <br>    hr = CHK_HrDoEnterNumber( <br>        lpszPrompt, <br>        fAllowNegative, <br>        lplNumber); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lplNumber = 0; <br> <br>    printf("\n%s: ", (lpszPrompt != NULL ? lpszPrompt : "")); <br> <br>    if(gets(szInput) == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        printf("\nERROR: gets() failed\n"); <br>    } <br>    else <br>    { <br>        cMatch = sscanf(szInput, "%ld", &amp;lNumber); <br>        if (cMatch == 0 || cMatch == EOF) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        if (!fAllowNegative &amp;&amp; lNumber &lt; 0) <br>        { <br>            printf("ERROR: negative number not allowed\n"); <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        *lplNumber = lNumber; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--DoEnterCommand------------------------------------------------------------- <br>//  Enter a command. <br>// ----------------------------------------------------------------------------- <br>void DoEnterCommand(void) <br>{ <br>    ULONG   ulInput                  = 0; <br>    TCHAR   szInput[MAX_INPUT_SIZ+1] = {0}; <br>    ULONG   i                        = 0; <br> <br>    nEventType = 0; <br> <br>    ZeroMemory(&amp;stEvent, sizeof(SYSTEMTIME)); <br> <br>    ZeroMemory(szGatewayName ,MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szPartnerName ,MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szMtsID, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szSubjectMtsID, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szRemoteID, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szOriginatorName, MAX_INPUT_SIZ+1); <br> <br>    nPriority   = 0; <br> <br>    nLength     = 0; <br> <br>    nSeconds    = 0; <br> <br>    nCost       = 0; <br> <br>    cRecipients = 0; <br> <br>    ZeroMemory(szRecip1, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szRecip2, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szRecip3, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szRecip4, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szRecip5, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szRecip6, MAX_INPUT_SIZ+1); <br> <br>    ZeroMemory(szRecip7, MAX_INPUT_SIZ+1); <br> <br>    for(;;) <br>    { <br>        ULONG ulChoice = 0; <br> <br>        printf("\nMENU:\n"); <br>        printf("\t 1. event type      [%u]\n", nEventType); <br>        printf("\t 2. gateway name    [%s]\n", szGatewayName); <br>        printf("\t 3. partner name    [%s]\n", szPartnerName); <br>        printf("\t 4. MTS-ID          [%s]\n", szMtsID); <br>        printf("\t 5. subject MTS-ID  [%s]\n", szSubjectMtsID); <br>        printf("\t 6. Remote-ID       [%s]\n", szRemoteID); <br>        printf("\t 7. originator name [%s]\n", szOriginatorName); <br>        printf("\t 8. priority        [%u]\n", nPriority); <br>        printf("\t 9. length          [%u]\n", nLength); <br>        printf("\t10. seconds         [%u]\n", nSeconds); <br>        printf("\t11. cost            [%u]\n", nCost); <br>        printf("\t12. #recipients     [%u]\n", cRecipients); <br>        printf("\t13. recipient #1    [%s]\n", szRecip1); <br>        printf("\t14. recipient #2    [%s]\n", szRecip2); <br>        printf("\t15. recipient #3    [%s]\n", szRecip3); <br>        printf("\t16. recipient #4    [%s]\n", szRecip4); <br>        printf("\t17. recipient #5    [%s]\n", szRecip5); <br>        printf("\t18. recipient #6    [%s]\n", szRecip6); <br>        printf("\t19. recipient #7    [%s]\n", szRecip7); <br>        printf("\t 0. Exit\n"); <br> <br>        if(FAILED(HrDoEnterNumber("SELECTION", TRUE, &amp;ulChoice))) <br>        { <br>           continue; <br>        } <br> <br>        switch(ulChoice) <br>        { <br>        case 1: <br>            ulInput = 0; <br>            if(FAILED(HrDoEnterNumber("event type", FALSE, &amp;ulInput))) <br>            { <br>                continue; <br>            } <br>            nEventType = ulInput; <br>            break; <br>        case 2: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("gateway name", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szGatewayName, szInput, MAX_INPUT_SIZ); <br>            szGatewayName[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 3: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("partner name", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szPartnerName, szInput, MAX_INPUT_SIZ); <br>            szPartnerName[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 4: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("MTS-ID", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szMtsID, szInput, MAX_INPUT_SIZ); <br>            szMtsID[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 5: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("Subject MTS-ID", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szSubjectMtsID, szInput, MAX_INPUT_SIZ); <br>            szSubjectMtsID[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 6: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("Remote-ID", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szRemoteID, szInput, MAX_INPUT_SIZ); <br>            szRemoteID[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 7: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("originator name", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szOriginatorName, szInput, MAX_INPUT_SIZ); <br>            szOriginatorName[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 8: <br>            ulInput = 0; <br>            if(FAILED(HrDoEnterNumber("priority", FALSE, &amp;ulInput))) <br>            { <br>                continue; <br>            } <br>            nPriority = ulInput; <br>            break; <br>        case 9: <br>            ulInput = 0; <br>            if(FAILED(HrDoEnterNumber("length", FALSE, &amp;ulInput))) <br>            { <br>                continue; <br>            } <br>            nLength = ulInput; <br>            break; <br>        case 10: <br>            ulInput = 0; <br>            if(FAILED(HrDoEnterNumber("seconds", FALSE, &amp;ulInput))) <br>            { <br>                continue; <br>            } <br>            nSeconds = ulInput; <br>            break; <br>        case 11: <br>            ulInput = 0; <br>            if(FAILED(HrDoEnterNumber("cost", FALSE, &amp;ulInput))) <br>            { <br>                continue; <br>            } <br>            nCost = ulInput; <br>            break; <br>        case 12: <br>            ulInput = 0; <br>            if(FAILED(HrDoEnterNumber("#recipients", FALSE, &amp;ulInput))) <br>            { <br>                continue; <br>            } <br>            cRecipients = ulInput; <br>            break; <br>        case 13: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("recip1", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szRecip1, szInput, MAX_INPUT_SIZ); <br>            szRecip1[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 14: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("recip2", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szRecip2, szInput, MAX_INPUT_SIZ); <br>            szRecip2[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 15: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("recip3", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szRecip3, szInput, MAX_INPUT_SIZ); <br>            szRecip3[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 16: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("recip4", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szRecip4, szInput, MAX_INPUT_SIZ); <br>            szRecip4[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 17: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("recip5", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szRecip5, szInput, MAX_INPUT_SIZ); <br>            szRecip5[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 18: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("recip6", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szRecip6, szInput, MAX_INPUT_SIZ); <br>            szRecip6[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 19: <br>            szInput[0] = 0; <br>            if(FAILED(HrDoEnterString("recip7", szInput))) <br>            { <br>                continue; <br>            } <br>            strncpy(szRecip7, szInput, MAX_INPUT_SIZ); <br>            szRecip7[MAX_INPUT_SIZ] = 0; <br>            break; <br>        case 0: <br>            goto cleanup; <br>        default: <br>            printf("ERROR: unknown menu selection\n"); <br>            break; <br>        } <br>    } <br> <br>cleanup: <br> <br>    return; <br>} <br> <br>//$--DoRunCommand--------------------------------------------------------------- <br>//  Run a command. <br>// ----------------------------------------------------------------------------- <br>void DoRunCommand(void) <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    printf("running command....\n"); <br> <br>    ZeroMemory(&amp;stEvent, sizeof(SYSTEMTIME)); <br> <br>    GetSystemTime(&amp;stEvent); <br> <br>    hr = HrTrackWriteLog( <br>        pvSession, <br>        nEventType, <br>        stEvent, <br>        szGatewayName, <br>        szPartnerName, <br>        szMtsID, <br>        szSubjectMtsID, <br>        szRemoteID, <br>        szOriginatorName, <br>        nPriority, <br>        nLength, <br>        nSeconds, <br>        nCost, <br>        cRecipients, <br>        ((cRecipients == 0) ? NULL : ((LPTSTR *)&amp;lpszRecipients))); <br> <br>    if(FAILED(hr)) <br>    { <br>        printf("ERROR: tracking write failed\n"); <br> <br>        goto cleanup; <br>    } <br> <br>    printf("finished command....\n"); <br> <br>cleanup: <br> <br>    return; <br>} <br> <br>//$--main----------------------------------------------------------------------- <br>//  Gateway message tracking sample application entry point. <br>// ----------------------------------------------------------------------------- <br>int main(int argc, char *argv[]) <br>{ <br>    HRESULT hr                       = NOERROR; <br> <br>    DEBUGPUBLIC("main()\n"); <br> <br>    // <br>    // Initialize MAPI <br>    // <br> <br>    hr = MAPIInitialize(NULL); <br> <br>    if(FAILED(hr)) <br>    { <br>        printf("ERROR: MAPI initialize failed\n"); <br> <br>        goto cleanup; <br>    } <br> <br>    fInitializedMAPI = TRUE; <br> <br>    // <br>    // Configure <br>    // <br> <br>    hr = HrConfig(argc, argv); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Initialize gateway message tracking <br>    // <br> <br>    hr = HrTrackInitLog( <br>    szServer, <br>    &amp;pvSession); <br> <br>    if(FAILED(hr)) <br>    { <br>        printf("ERROR: tracking initialize failed\n"); <br> <br>        goto cleanup; <br>    } <br> <br>    lpszRecipients[0] = (LPTSTR)szRecip1; <br>    lpszRecipients[1] = (LPTSTR)szRecip2; <br>    lpszRecipients[2] = (LPTSTR)szRecip3; <br>    lpszRecipients[3] = (LPTSTR)szRecip4; <br>    lpszRecipients[4] = (LPTSTR)szRecip5; <br>    lpszRecipients[5] = (LPTSTR)szRecip6; <br>    lpszRecipients[6] = (LPTSTR)szRecip7; <br> <br>    printf("\n"); <br> <br>    printf("Processing commands.\n"); <br> <br>    for(;;) <br>    { <br>        ULONG ulChoice = 0; <br> <br>        printf("\nMENU:\n"); <br>        printf("\t 1. Enter command\n"); <br>        printf("\t 2. Run command\n"); <br>        printf("\t 0. Exit\n"); <br> <br>        if(FAILED(HrDoEnterNumber("SELECTION", TRUE, &amp;ulChoice))) <br>        { <br>            continue; <br>        } <br> <br>        switch(ulChoice) <br>        { <br>        case 1: <br>            DoEnterCommand(); <br>            break; <br>        case 2: <br>            DoRunCommand(); <br>            break; <br>        case 0: <br>            goto cleanup; <br>            break; <br>        default: <br>            printf("ERROR: unknown menu selection\n"); <br>            break; <br>        } <br>    } <br> <br>cleanup: <br> <br>    // <br>    // Uninitialize gateway message tracking <br>    // <br> <br>    if(pvSession != NULL) <br>    { <br>        hr = HrTrackUninitLog(&amp;pvSession); <br> <br>        if(FAILED(hr)) <br>        { <br>            printf("ERROR: tracking uninitialize failed\n"); <br>        } <br>    } <br> <br>    if(fInitializedMAPI == TRUE) <br>    { <br>        MAPIUninitialize(); <br> <br>        fInitializedMAPI = FALSE; <br>    } <br> <br>    // return exit code <br>    return _nEcFromHr(hr); <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
