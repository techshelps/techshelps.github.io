<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMESSAGE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1836"></a>IMESSAGE.C</h2>
<pre><code>// --imessage.c----------------------------------------------------------------- <br>//  <br>//  Module containing MAPI utility functions. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include "imessage.chk" <br> <br>//$--HrEDKSearchTableByProp----------------------------------------------------- <br>//  Find the entry IDs matching the restriction. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKSearchTableByProp(  // RETURNS: return code <br>    IN LPMAPITABLE lpTable,             // pointer to table <br>    IN LPSPropValue lpSPropValue,       // property value <br>    OUT LPENTRYLIST *lppMsgList)        // list of matching entry IDs <br>{ <br>    HRESULT       hr         = NOERROR; <br>    HRESULT       hrT        = NOERROR; <br>    LPSRowSet     lpRows     = NULL; <br>    LPENTRYLIST   lpMsgList  = NULL; <br>    ULONG         i          = 0; <br>    ULONG         cbeid      = 0; <br>    LPENTRYID     lpeid      = NULL; <br>    ULONG         cRows      = 0; <br>    SPropTagArray rgPropTags = { 1, { PR_ENTRYID } }; <br>    SRestriction  sres       = { 0 }; <br>    LPSPropValue  lpProp     = NULL; <br> <br>    DEBUGPRIVATE("HrEDKSearchTableByProp()"); <br> <br>    hr = CHK_HrEDKSearchTableByProp( <br>        lpTable, <br>        lpSPropValue, <br>        lppMsgList); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppMsgList = NULL; <br> <br>    // Set the columns to return <br>    hrT = MAPICALL(lpTable)-&gt;SetColumns(lpTable, &amp;rgPropTags, TBL_BATCH); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Restrict rows to those that match criteria <br> <br>    sres.rt                         = RES_PROPERTY; <br>    sres.res.resProperty.relop      = RELOP_EQ; <br>    sres.res.resProperty.ulPropTag  = lpSPropValue-&gt;ulPropTag; <br>    sres.res.resProperty.lpProp     = lpSPropValue; <br> <br>    hrT = MAPICALL(lpTable)-&gt;Restrict(lpTable, &amp;sres, 0); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Search the rows of the table, EDK_MAX_QUERY_ROWS at a time <br>     <br>    for(;;) <br>    { <br>     <br>        // Get a row set <br> <br>        hrT = MAPICALL(lpTable)-&gt;QueryRows( <br>            lpTable, <br>            EDK_MAX_QUERY_ROWS, <br>            0, <br>            &amp;lpRows); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        cRows = lpRows-&gt;cRows; <br> <br>        // If table is empty then no message(s) <br> <br>        if((cRows == 0) &amp;&amp; (lpMsgList == NULL)) <br>        { <br>            hr = HR_LOG(EDK_E_NOT_FOUND); <br>            goto cleanup; <br>        } <br> <br>        // Create list of entry IDs <br> <br>        for(i = 0; i &lt; cRows; i++) <br>        { <br>            lpProp = lpRows-&gt;aRow[i].lpProps; <br> <br>            if((lpProp[0].ulPropTag == PR_ENTRYID) &amp;&amp; (lpRows-&gt;aRow[i].cValues &gt; 0)) <br>            { <br>                cbeid = lpProp[0].Value.bin.cb; <br> <br>                lpeid = (LPENTRYID)lpProp[0].Value.bin.lpb; <br> <br>                if(lpMsgList == NULL) <br>                { <br>                    hrT = HrMAPICreateEntryList(cbeid,lpeid,&amp;lpMsgList); <br> <br>                    if(FAILED(hrT)) <br>                    { <br>                        hr = HR_LOG(E_FAIL); <br>                        goto cleanup; <br>                    } <br>                } <br>                else <br>                { <br>                    hrT = HrMAPIAppendEntryList(cbeid,lpeid,lpMsgList); <br> <br>                    if(FAILED(hrT)) <br>                    { <br>                        hr = HR_LOG(E_FAIL); <br>                        goto cleanup; <br>                    } <br>                } <br>            } <br>            else <br>            { <br>                ASSERTERROR( <br>                    (lpProp[0].ulPropTag == PR_ENTRYID),"INVALID property tag"); <br> <br>                ASSERTERROR((lpRows-&gt;aRow[i].cValues &gt; 0),"INVALID row entry"); <br>            } <br>        } <br> <br>        FREEPROWS(lpRows); <br>    } <br> <br>cleanup: <br> <br>    FREEPROWS(lpRows); <br> <br>    if(FAILED(hr)) <br>    { <br>        hrT = HrMAPIDestroyEntryList(&amp;lpMsgList); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br> <br>        *lppMsgList = NULL; <br>    } <br>    else <br>    { <br>        *lppMsgList = lpMsgList; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIFindMsgByProp--------------------------------------------------------- <br>//  Find the entry ID of a message given a property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIFindMsgByProp(         // RETURNS: return code <br>    IN LPMAPIFOLDER lpFolder,       // pointer to folder <br>    IN LPSPropValue lpSPropValue,   // property value <br>    OUT LPENTRYLIST *lppMsgList)    // list of matching messages <br>{ <br>    HRESULT       hr         = NOERROR; <br>    HRESULT       hrT        = NOERROR; <br>    LPMAPITABLE   lpTable    = NULL; <br> <br>    DEBUGPUBLIC("HrMAPIFindMsgByProp()"); <br> <br>    hr = CHK_HrMAPIFindMsgByProp( <br>        lpFolder, <br>        lpSPropValue, <br>        lppMsgList); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Get the contents table for the folder <br>    hrT = MAPICALL(lpFolder)-&gt;GetContentsTable( <br>        lpFolder, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;lpTable); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrEDKSearchTableByProp( <br>        lpTable, <br>        lpSPropValue, <br>        lppMsgList); <br> <br>cleanup: <br> <br>    ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIMoveMessage-------------------------------------------------------- <br>//  Move one message from one folder to another. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIMoveMessage(            // RETURNS: return code <br>    IN LPMAPIFOLDER lpSrcFolder,        // pointer to source folder <br>    IN LPMAPIFOLDER lpDstFolder,        // pointer to destination folder <br>    IN ULONG cbeid,                     // count of bytes in entry ID <br>    IN LPENTRYID lpeid)                 // pointer to entry ID <br>{ <br>    HRESULT     hr           = NOERROR; <br>    HRESULT     hrT          = NOERROR; <br>    LPENTRYLIST lpMsgList    = NULL; <br> <br>    DEBUGPUBLIC("HrMAPIMoveMessage()"); <br> <br>    hr = CHK_HrMAPIMoveMessage( <br>        lpSrcFolder, <br>        lpDstFolder, <br>        cbeid, <br>        lpeid); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrMAPICreateEntryList( <br>        cbeid, <br>        lpeid, <br>        &amp;lpMsgList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Move the message <br> <br>    hrT = MAPICALL(lpSrcFolder)-&gt;CopyMessages( <br>        lpSrcFolder, <br>        lpMsgList, <br>        NULL, <br>        lpDstFolder, <br>        (ULONG)0, <br>        NULL, <br>        MESSAGE_MOVE); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    hrT = HrMAPIDestroyEntryList( <br>        &amp;lpMsgList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPICopyMessage-------------------------------------------------------- <br>//  Copy one message from one folder to another. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPICopyMessage(            // RETURNS: return code <br>    IN LPMAPIFOLDER lpSrcFolder,        // pointer to source folder <br>    IN LPMAPIFOLDER lpDstFolder,        // pointer to destination folder <br>    IN ULONG cbeid,                     // count of bytes in entry ID <br>    IN LPENTRYID lpeid)                 // pointer to entry ID <br>{ <br>    HRESULT     hr           = NOERROR; <br>    HRESULT     hrT          = NOERROR; <br>    LPENTRYLIST lpMsgList    = NULL; <br> <br>    DEBUGPUBLIC("HrMAPICopyMessage()"); <br> <br>    hr = CHK_HrMAPICopyMessage( <br>        lpSrcFolder, <br>        lpDstFolder, <br>        cbeid, <br>        lpeid); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrMAPICreateEntryList( <br>        cbeid, <br>        lpeid, <br>        &amp;lpMsgList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Copy the message <br> <br>    hrT = MAPICALL(lpSrcFolder)-&gt;CopyMessages( <br>        lpSrcFolder, <br>        lpMsgList, <br>        NULL, <br>        lpDstFolder, <br>        (ULONG)0, <br>        NULL, <br>        0); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    hrT = HrMAPIDestroyEntryList( <br>        &amp;lpMsgList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIDeleteMessage------------------------------------------------------ <br>//  Delete one message from one folder to another. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIDeleteMessage(          // RETURNS: return code <br>    IN LPMAPIFOLDER lpFolder,           // pointer to folder <br>    IN ULONG cbeid,                     // count of bytes in entry ID <br>    IN LPENTRYID lpeid)                 // pointer to entry ID <br>{ <br>    HRESULT     hr           = NOERROR; <br>    HRESULT     hrT          = NOERROR; <br>    LPENTRYLIST lpMsgList    = NULL; <br> <br>    DEBUGPUBLIC("HrMAPIDeleteMessage()"); <br> <br>    hr = CHK_HrMAPIDeleteMessage( <br>        lpFolder, <br>        cbeid, <br>        lpeid); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrMAPICreateEntryList( <br>        cbeid, <br>        lpeid, <br>        &amp;lpMsgList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Remove the message <br> <br>    hrT = MAPICALL(lpFolder)-&gt;DeleteMessages( <br>        lpFolder, <br>        lpMsgList, <br>        (ULONG)0, <br>        NULL, <br>        (ULONG)0); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    hrT = HrMAPIDestroyEntryList( <br>        &amp;lpMsgList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
