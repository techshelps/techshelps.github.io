<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EDKEVENT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1830"></a>EDKEVENT.C</h2>
<pre><code>// --edkevent.c----------------------------------------------------------------- <br>// <br>//  Routines to do event logging for EDK. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include &lt;stdarg.h&gt; <br>#include "edkevent.chk" <br> <br> <br>static EDKEVENTCOUNTsEventCount= {0}; <br>static HANDLEhEventSource= NULL; <br>static BOOLfPreviouslyOpenedHandle= FALSE; <br> <br> <br>static VOID LogEventCommon( <br>IN BOOL fIsUnicode, <br>IN DWORD dwEvent, <br>IN DWORD cStrings, <br>IN va_list pArgList); <br> <br> <br>//$--HrEventOpenLog---------------------------------------------------------- <br>//  Initialize event logging for the EDK. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEventOpenLog(// RETURNS: HRESULT <br>IN LPSTR pszApplicationName,// name of this application <br>IN LPSTR pszExecutableName,// name of executable <br>    IN LPSTR pszEventMessageFile,      // name of event message file <br>    IN LPSTR pszParameterMessageFile,  // name of parameter message file <br>    IN LPSTR pszCategoryMessageFile,   // name of category message file <br>OUT LPHANDLE phEventSourceOut)// [returns event logging handle] <br>{ <br>    HRESULT     hr              = NOERROR; <br>DWORDdwError= ERROR_SUCCESS; <br>CHARszKeyName[MAX_PATH+1] = {0}; <br>HKEYhKey= NULL; <br>DWORDdwDisposition= 0; <br>HMODULEhinstModule= NULL; <br>CHARszExecutableBuffer[MAX_PATH+1] = {0}; <br>DWORDcch= 0; <br> <br>    LPSTR      pszMessageFile      = NULL; <br> <br>DEBUGPUBLIC("HrEventOpenLog()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrEventOpenLog( <br>pszApplicationName,  <br>pszExecutableName,  <br>        pszEventMessageFile, <br>        pszParameterMessageFile, <br>        pszCategoryMessageFile, <br>phEventSourceOut); <br> <br>if(FAILED(hr)) <br>RETURN(hr); <br> <br>// Make sure the event log isn't already open. <br> <br>if (hEventSource != NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Flag that this is not a previously opened handle, and should be closed  <br>// when HrEventCloseLog() is called. <br> <br>fPreviouslyOpenedHandle = FALSE; <br> <br>// If they didn't pass in an executable name then figure out the name  <br>// of the executable currently executing and use that. <br> <br>if (pszExecutableName == NULL) <br>{ <br>hinstModule = GetModuleHandle(NULL); <br>if (hinstModule == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>cch = GetModuleFileName( <br>hinstModule,  <br>szExecutableBuffer,  <br>sizeof(szExecutableBuffer) - 1); <br>if (cch == 0) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>pszExecutableName = szExecutableBuffer; <br>} <br> <br>// Create the name of the registry key for this application. <br> <br>lstrcpy(szKeyName,  <br>"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"); <br>lstrcat(szKeyName, pszApplicationName); <br> <br>// Open or create the registry key.  This registry key contains/will  <br>// contain values that are required by the Windows NT function  <br>// ReportEvent(). <br> <br>dwError = RegCreateKeyEx( <br>HKEY_LOCAL_MACHINE,  <br>szKeyName,  <br>0,  <br>NULL,  <br>REG_OPTION_NON_VOLATILE,  <br>KEY_ALL_ACCESS,  <br>NULL,  <br>&amp;hKey,  <br>&amp;dwDisposition); <br>if (dwError != ERROR_SUCCESS) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Add the message file names to the key. <br> <br>    if(pszEventMessageFile == NULL) <br>    { <br>        pszMessageFile = pszExecutableName; <br>    } <br>    else <br>    { <br>        pszMessageFile = pszEventMessageFile; <br>    } <br> <br>hr = _HrWriteRegistrySZ( <br>    hKey, <br>    "EventMessageFile",  <br>pszMessageFile); <br> <br>if (FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>    if(pszParameterMessageFile == NULL) <br>    { <br>        pszMessageFile = "%SystemRoot%\\System32\\kernel32.dll"; <br>    } <br>    else <br>    { <br>        pszMessageFile = pszParameterMessageFile; <br>    } <br> <br>hr = _HrWriteRegistrySZ( <br>    hKey, <br>    "ParameterMessageFile",  <br>pszMessageFile); <br> <br>if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>    if(pszCategoryMessageFile == NULL) <br>    { <br>        pszMessageFile = pszExecutableName; <br>    } <br>    else <br>    { <br>        pszMessageFile = pszCategoryMessageFile; <br>    } <br> <br>hr = _HrWriteRegistrySZ( <br>    hKey, <br>    "CategoryMessageFile",  <br>pszMessageFile); <br> <br>if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>hr = _HrWriteRegistryDWORD( <br>        hKey, <br>        "TypesSupported",  <br>EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE); <br> <br>if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>// Register the event source. <br> <br>hEventSource = RegisterEventSource(NULL, pszApplicationName); <br> <br>if (hEventSource == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Reset the event type counters. <br> <br>sEventCount.cError = 0; <br>sEventCount.cWarning = 0; <br>sEventCount.cInformation = 0; <br> <br>// Return the handle if they requested it. <br> <br>if (phEventSourceOut) <br>{ <br>*phEventSourceOut = hEventSource; <br>} <br> <br>cleanup: <br>if (hKey != NULL) <br>{ <br>dwError = RegCloseKey(hKey); <br> <br>if (dwError != ERROR_SUCCESS) <br>{ <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>hKey = NULL; <br>} <br> <br>RETURN(hr); <br>} <br> <br> <br>//$--HrEventUseExisting--------------------------------------------------- <br>//  Initialize event logging for the EDK by connecting to an already open  <br>//  event log handle.  This allows EventLogMsg() to log events to a handle  <br>//  that was opened elsewhere.  Calling HrEventCloseLog() after calling  <br>//  this routine will do internal cleanup but will not close the event log  <br>//  handle.  One example of where this routine is useful is within a DLL  <br>//  that is called by EDK code in which event logging has already been  <br>//  initialized. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEventUseExisting(// RETURNS: HRESULT <br>IN HANDLE hExistingEventSource)// previously opened event log handle <br>{ <br>HRESULT hr = NOERROR; <br> <br>DEBUGPUBLIC("HrEventUseExisting()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrEventUseExisting( <br>hExistingEventSource); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Make sure the event log isn't already open. <br> <br>if (hEventSource != NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Use the existing event log handle. <br> <br>hEventSource = hExistingEventSource; <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br>//$--EventLogMsg---------------------------------------------------------------- <br>// <br>//  EventLogMsgA -- byte string version <br>//  EventLogMsgW -- word string version <br>// <br>//  Log an event to the event log, and optionally, log the original error(s)  <br>//  that caused the event.  It has the following parameters: <br>// <br>//   DWORD    dwEvent <br>//   DWORD    cStrings <br>//  [LPSTR   pszString1] <br>//  [LPSTR   pszString2] <br>//  [...................] <br>//  [LPSTR   pszStringN] <br>//   DWORD    cErrorCodes <br>//  [DWORD    dwErrorCode1] <br>//  [DWORD    dwErrorCode2] <br>//  [.....................] <br>//  [DWORD    dwErrorCodeN] <br>// <br>//  Each of the above strings and error codes are used as parameters to the  <br>//  message in the order they appear.  This means that in event messages,  <br>//  all of the  error message replacement parameters must have higher numbers  <br>//  than all of the string replacement parameters.  For example: <br>// <br>//      EventLogMsg( <br>//          MYAPP_CANNOT_COPY_FILE,  <br>//          2, pszSourceFile, pszDestFile,  <br>//          1, dwError); <br>// <br>//  And the message would be defined as: <br>// <br>//      MessageId= <br>//      Severity=Error <br>//      Facility=Application <br>//      SymbolicName=MYAPP_CANNOT_COPY_FILE <br>//      Language=English <br>//      Cannot copy file from %1 to %2 due to the following error:%n%3. <br>//      . <br>// <br>//  Note: This routine preserves the last error value returned by  <br>//        GetLastError(). <br>// <br>// ----------------------------------------------------------------------------- <br> <br>//$--EventLogMsgA--------------------------------------------------------------- <br>//  Byte string version of EventLogMsg(). <br>// <br>//  IMPORTANT!!! The error code count [and error code list] is REQUIRED after  <br>//  the text string count [and text string list].  Failure to include the  <br>//  error code argument(s) may cause unexpected results. <br>// ----------------------------------------------------------------------------- <br>VOID EventLogMsgA(// RETURNS: nothing <br>IN DWORD dwEvent,// error code of event to log <br>IN DWORD cStrings,// number of text string parameters <br>IN ...// text string parameters <br>//IN DWORD cErrors,// number of error code parameters <br>//IN ...// error code parameters <br>) <br>{ <br>DWORD   dwSaveLastError= 0; <br>va_listpArgList        = {0}; <br> <br>dwSaveLastError = GetLastError(); <br> <br>va_start(pArgList, cStrings); <br>LogEventCommon(FALSE, dwEvent, cStrings, pArgList); <br>va_end(pArgList); <br> <br>SetLastError(dwSaveLastError); <br>} <br> <br>//$--EventLogMsgW--------------------------------------------------------------- <br>//  Word string version of EventLogMsg(). <br>// <br>//  IMPORTANT!!! The error code count [and error code list] is REQUIRED after  <br>//  the text string count [and text string list].  Failure to include the  <br>//  error code argument(s) may cause unexpected results. <br>// ----------------------------------------------------------------------------- <br>VOID EventLogMsgW(// RETURNS: nothing <br>IN DWORD dwEvent,// error code of event to log <br>IN DWORD cStrings,// number of text string parameters <br>IN ...// text string parameters <br>//IN DWORD cErrors,// number of error code parameters <br>//IN ...// error code parameters <br>) <br>{ <br>DWORDdwSaveLastError= 0; <br>va_listpArgList        = {0}; <br> <br>dwSaveLastError = GetLastError(); <br> <br>va_start(pArgList, cStrings); <br>LogEventCommon(TRUE, dwEvent, cStrings, pArgList); <br>va_end(pArgList); <br> <br>SetLastError(dwSaveLastError); <br>} <br> <br>// Maximum total number of string and error parameters allowed by EventLogMsg(). <br>#define_MAX_BUILD_STRINGS20 <br> <br>// Size of buffer to write error number string into (must be big enough to hold  <br>// a string of the form: %%&lt;decimal#&gt; in either multi-byte or UNICODE. <br>#define_MAX_ERROR_STRING_BYTES40 <br> <br>//$--LogEventCommon------------------------------------------------------------- <br>//  Common event logging code for both multi-byte and UNICODE strings. <br>// ----------------------------------------------------------------------------- <br>static VOID LogEventCommon(// RETURNS: nothing <br>IN BOOL fIsUnicode,// flag set if text strings are UNICODE <br>IN DWORD dwEvent,// error code of event to log <br>IN DWORD cStrings,// number of text strings that follow <br>IN va_list pArgList)// argument strings/error codes <br>{ <br>HRESULThr= NOERROR; <br>BOOLfItWorked= TRUE; <br>DWORDiArg= 0; <br>DWORDcBuildStrings= 0; <br>WORDwEventType= 0; <br> <br>// This array can contain either all LPSTR's or all LPWSTR's. <br>LPVOIDrgpvBuildStrings[_MAX_BUILD_STRINGS] = {NULL}; <br> <br>// This array will be used to build either WCHAR strings or CHAR strings. <br>BYTErgrgbBuildErrorStrings[_MAX_BUILD_STRINGS] <br>[_MAX_ERROR_STRING_BYTES] = {0}; <br> <br>DEBUGPRIVATE("LogEventCommon()\n"); <br> <br>// Make sure event log is open. <br> <br>if (hEventSource == NULL) <br>{ <br>OutputDebugString("Event log is not open in LogEventCommon()\n"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Get the number of string arguments and make sure it is within limits. <br> <br>cBuildStrings = cStrings; <br> <br>if (cBuildStrings &gt; _MAX_BUILD_STRINGS) <br>{ <br>OutputDebugString("Too many string parameters in LogEventCommon()\n"); <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>// Get the string arguments and make sure they are valid string pointers. <br> <br>for (iArg = 0; iArg &lt; cBuildStrings; iArg++) <br>{ <br>BOOL fIsValidString = TRUE; <br> <br>if (fIsUnicode) <br>{ <br>rgpvBuildStrings[iArg] = va_arg(pArgList, LPWSTR); <br>fIsValidString = TEST_STRINGW_PTR(rgpvBuildStrings[iArg]); <br>} <br>else <br>{ <br>rgpvBuildStrings[iArg] = va_arg(pArgList, LPSTR); <br>fIsValidString = TEST_STRINGA_PTR(rgpvBuildStrings[iArg]); <br>} <br> <br>if (!fIsValidString) <br>{ <br>OutputDebugString("Invalid string parameter in LogEventCommon()\n"); <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>} <br> <br>// Get the number of error code arguments and make sure it is within limits. <br> <br>cBuildStrings += va_arg(pArgList, DWORD); <br> <br>if (cBuildStrings &gt; _MAX_BUILD_STRINGS) <br>{ <br>OutputDebugString("Too many error code parameters in " <br>"LogEventCommon()\n"); <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>// Get the error code arguments and convert them to strings of the form:  <br>// %%&lt;Number&gt;. <br> <br>for ( ; iArg &lt; cBuildStrings; iArg++) <br>{ <br>rgpvBuildStrings[iArg] = rgrgbBuildErrorStrings[iArg]; <br> <br>if (fIsUnicode) <br>{ <br>swprintf(rgpvBuildStrings[iArg], L"%%%%%ld",  <br>va_arg(pArgList, DWORD)); <br>} <br>else <br>{ <br>sprintf(rgpvBuildStrings[iArg], "%%%%%ld",  <br>va_arg(pArgList, DWORD)); <br>} <br>} <br> <br>// Compute the event type for this event. <br> <br>switch (dwEvent &amp; 0xC0000000) <br>{ <br>case 0xC0000000: <br>wEventType = EVENTLOG_ERROR_TYPE; <br>break; <br>case 0x80000000: <br>wEventType = EVENTLOG_WARNING_TYPE; <br>break; <br>default: <br>wEventType = EVENTLOG_INFORMATION_TYPE; <br>break; <br>} <br> <br>// Log the event. <br> <br>if (fIsUnicode) <br>{ <br>fItWorked = ReportEventW( <br>hEventSource,  <br>wEventType,  <br>0,  <br>dwEvent,  <br>NULL,  <br>(WORD)cBuildStrings,  <br>0,  <br>(LPWSTR *)rgpvBuildStrings,  <br>NULL); <br>} <br>else <br>{ <br>fItWorked = ReportEventA( <br>hEventSource,  <br>wEventType,  <br>0,  <br>dwEvent,  <br>NULL,  <br>(WORD)cBuildStrings,  <br>0,  <br>(LPSTR *)rgpvBuildStrings,  <br>NULL); <br>} <br> <br>if (!fItWorked) <br>{ <br>OutputDebugString("ReportEvent() failed in LogEventCommon()\n"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Bump up the counter for the right type of event. <br> <br>switch (wEventType) <br>{ <br>case EVENTLOG_ERROR_TYPE: <br>sEventCount.cError++; <br>break; <br>case EVENTLOG_WARNING_TYPE: <br>sEventCount.cWarning++; <br>break; <br>case EVENTLOG_INFORMATION_TYPE: <br>sEventCount.cInformation++; <br>break; <br>default: <br>OutputDebugString( <br>"Cannot increment event type counter for " <br>"unknown event type.\n"); <br>break; <br>} <br> <br>cleanup: <br>// If we couldn't log it to the event log, then output a message to the  <br>// error log and debug log. <br> <br>if (FAILED(hr)) <br>{ <br>CHAR szDescription[100] = {0}; <br>sprintf(szDescription, "Unable to log event 0x%08lx\n", dwEvent); <br>OutputDebugString(szDescription); <br>} <br>} <br> <br> <br>//$--HrEventGetCounts-------------------------------------------------------- <br>//  Returns the number of Error, Warning, and Information events logged (by the  <br>//  current executable). <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEventGetCounts(// RETURNS: HRESULT <br>OUT LPEDKEVENTCOUNT lpsEventCount)// structure to return event counts <br>{ <br>HRESULThr= NOERROR; <br> <br>DEBUGPUBLIC("HrEventGetCounts(lpsEventCount)\n"); <br> <br>hr = CHK_HrEventGetCounts( <br>lpsEventCount); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Return the values. <br> <br>MoveMemory(lpsEventCount, &amp;sEventCount, sizeof(sEventCount)); <br> <br>RETURN(hr); <br>} <br> <br> <br>//$--HrEventCloseLog--------------------------------------------------------- <br>//  Shut down event logging for the EDK. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEventCloseLog()// RETURNS: HRESULT <br>{ <br>HRESULThr= NOERROR; <br>BOOLfItWorked= FALSE; <br> <br>DEBUGPUBLIC("HrEventCloseLog()\n"); <br> <br>if (hEventSource &amp;&amp; !fPreviouslyOpenedHandle) <br>{ <br>fItWorked = CloseEventLog(hEventSource); <br>if (!fItWorked) <br>{ <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>hEventSource = NULL; <br> <br>RETURN(hr); <br>} <br> <br>// $--HrEventGetHandle------------------------------------------------------ <br>// <br>// DESCRIPTION: Retrieve event handle for this executable. <br>// <br>// OUTPUT:  phEventLog   --  event log handle pointer <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//                      E_FAIL otherwise. <br>// <br>// Notes:   <br>// <br>// 1) The event handle returned will be NULL if there is <br>// no open event log. <br>// <br>// 2) DLLs may not call this function to retrieve the event handle <br>// which their parent executable set.  If the parent executable sets <br>// an event handle, then it must pass the event handle to the DLL. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT HrEventGetHandle( <br>        IN HANDLE * phEventLog)       // event log handle pointer <br>{ <br>    HRESULT hr  =   NOERROR;     <br> <br>    DEBUGPRIVATE("HrEventGetHandle"); <br>         <br>    // check input parameters <br>    hr = CHK_HrEventGetHandle(phEventLog); <br>     <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Return current event log handle.  Note that it <br>    // may be NULL.     <br>    *phEventLog = hEventSource; <br> <br>    RETURN(hr); <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
