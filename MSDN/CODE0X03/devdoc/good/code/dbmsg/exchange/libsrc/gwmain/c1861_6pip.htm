<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GWMAIN.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1861"></a>GWMAIN.C</h2>
<pre><code>// --gwmain.c------------------------------------------------------------------- <br>//  <br>//  Logon/logoff a gateway. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#define USES_IID_IMailUser <br>#include "edk.h" <br>#include "gwmain.h" <br> <br>#define NOTIFY_TIMEOUT  60000 <br> <br>static ULONG         ulNewMailAdvise = 0xFFFFFFFFU; <br> <br>static HANDLE        hNewMailEvent   = NULL;  // new mail event <br>static LPMAPISESSION lpSession       = NULL;  // session pointer <br>static LPMDB         lpStore         = NULL;  // message store pointer <br>static LPMAPIFOLDER  lpRootFolder    = NULL;  // root folder pointer <br>static LPMAPIFOLDER  lpMtsInFolder   = NULL;  // MTS-IN folder pointer <br>static LPMAPIFOLDER  lpMtsOutFolder  = NULL;  // MTS-OUT folder pointer <br>static LPADRBOOK     lpAdrBook       = NULL;  // pointer to address book <br>static ULONG         cbGalEid        = 0;     // count of bytes in GAL entry ID <br>static LPENTRYID     lpGalEid        = NULL;  // pointer to GAL entry ID <br>static LPABCONT      lpGalABCont     = NULL;  // pointer to GAL object <br> <br>static BOOL          IsInitMAPI      = FALSE; // MAPI Initialized <br>static BOOL          IsMAPILogon     = FALSE; // MAPI Logon <br> <br>CRITICAL_SECTION     csNewMailList   = {0}; <br>CRITICAL_SECTION     csNewFileList   = {0}; <br> <br>static CHAR         szServerName[MAX_COMPUTERNAME_LENGTH+1] = {0}; <br> <br>HANDLE               hNewMailThread  = NULL;  // new mail thread <br>HANDLE               hNewFileThread  = NULL;  // new file thread <br> <br>DWORD                dwNewMailTimeout = NOTIFY_TIMEOUT; <br>DWORD                dwNewFileTimeout = NOTIFY_TIMEOUT; <br> <br>//$--GetGWExchangeServerName------------------------------------------------------ <br>//  Get Exchange server name. <br>// ----------------------------------------------------------------------------- <br>LPSTR GetGWExchangeServerName(void) <br>{ <br>    DEBUGPUBLIC("GetGWExchangeServerName()\n"); <br> <br>    return(szServerName); <br>} <br> <br>//$--GetGWSession------------------------------------------------------------- <br>//  Get MAPI session pointer. <br>// ----------------------------------------------------------------------------- <br>LPMAPISESSION GetGWSession(void) <br>{ <br>    DEBUGPUBLIC("GetGWSession()\n"); <br> <br>    return(lpSession); <br>} <br> <br>//$--GetGWDefaultStore------------------------------------------------------------ <br>//  Get default store pointer. <br>// ----------------------------------------------------------------------------- <br>LPMDB GetGWDefaultStore(void) <br>{ <br>    DEBUGPUBLIC("GetGWDefaultStore()\n"); <br> <br>    return(lpStore); <br>} <br> <br>//$--GetGWRootFolder------------------------------------------------------------- <br>//  Get root folder pointer. <br>// ----------------------------------------------------------------------------- <br>LPMAPIFOLDER GetGWRootFolder(void) <br>{ <br>    DEBUGPUBLIC("GetGWRootFolder()\n"); <br> <br>    return(lpRootFolder); <br>} <br> <br>//$--GetGWMtsInFolder------------------------------------------------------------- <br>//  Get MTS-IN folder pointer. <br>// ----------------------------------------------------------------------------- <br>LPMAPIFOLDER GetGWMtsInFolder(void) <br>{ <br>    DEBUGPUBLIC("GetGWMtsInFolder()\n"); <br> <br>    return(lpMtsInFolder); <br>} <br> <br>//$--GetGWMtsOutFolder------------------------------------------------------------ <br>//  Get MTS-OUT folder pointer. <br>// ----------------------------------------------------------------------------- <br>LPMAPIFOLDER GetGWMtsOutFolder(void) <br>{ <br>    DEBUGPUBLIC("GetGWMtsOutFolder()\n"); <br> <br>    return(lpMtsOutFolder); <br>} <br> <br>//$--GetGWGALEntryIdSize-------------------------------------------------------------- <br>//  Get count of bytes in GAL entry ID. <br>// ----------------------------------------------------------------------------- <br>ULONG GetGWGALEntryIdSize(void) <br>{ <br>    DEBUGPUBLIC("GetGWGALEntryIdSize()\n"); <br> <br>    return(cbGalEid); <br>} <br> <br>//$--GetGWGALEntryId------------------------------------------------------------------ <br>//  Get GAL entry ID pointer. <br>// ----------------------------------------------------------------------------- <br>LPENTRYID GetGWGALEntryId(void) <br>{ <br>    DEBUGPUBLIC("GetGWGALEntryId()\n"); <br> <br>    return(lpGalEid); <br>} <br> <br>//$--GetAdrBookPtr-------------------------------------------------------------- <br>//  Get address book pointer pointer. <br>// ----------------------------------------------------------------------------- <br>LPADRBOOK GetAdrBookPtr(void) <br>{ <br>    DEBUGPUBLIC("GetAdrBookPtr()\n"); <br> <br>    return(lpAdrBook); <br>} <br> <br>//$--GetGWGAL------------------------------------------------------------------ <br>//  Get GAL pointer. <br>// ----------------------------------------------------------------------------- <br>LPABCONT GetGWGAL(void) <br>{ <br>    DEBUGPUBLIC("GetGWGAL()\n"); <br> <br>    return(lpGalABCont); <br>} <br> <br>//$--GetGWNewMailEvent------------------------------------------------------------ <br>//  Get new mail event. <br>// ----------------------------------------------------------------------------- <br>HANDLE GetGWNewMailEvent(void) <br>{ <br>    DEBUGPUBLIC("GetGWNewMailEvent()\n"); <br> <br>    return(hNewMailEvent); <br>} <br> <br>//$--GetGWNewMailStatus----------------------------------------------------------- <br>//  Get new mail status. <br>// ----------------------------------------------------------------------------- <br>BOOL GetGWNewMailStatus(void) <br>{ <br>    BOOL  IsNewMail = TRUE; <br>    DWORD dw        = 0; <br> <br>    DEBUGPUBLIC("GetGWNewMailStatus()\n"); <br> <br>    if(hNewMailEvent == NULL) <br>    { <br>        IsNewMail = FALSE; <br>        goto cleanup; <br>    } <br> <br>    dw = WaitForSingleObject(hNewMailEvent, 0);  <br> <br>    if((dw != WAIT_OBJECT_0) &amp;&amp; (dw != WAIT_ABANDONED)) <br>    { <br>        HRESULT hr = HR_LOG(E_FAIL); <br> <br>        IsNewMail = FALSE; <br>    } <br> <br>cleanup: <br> <br>    return(IsNewMail); <br>} <br> <br>//$--ScNewMailHandler----------------------------------------------------------- <br>//  Handle the arrival of new messages. <br>// ----------------------------------------------------------------------------- <br>static SCODE STDAPICALLTYPE ScNewMailHandler(       // RETURNS: status code <br>    IN LPVOID lpvContext,                           // pointer to context <br>    IN ULONG cNotification,                         // count of notifications <br>    IN LPNOTIFICATION lpNotifications)              // pointer to notifications <br>{ <br>    DEBUGPRIVATE("ScNewMailHandler()\n"); <br> <br>    if((hNewMailEvent != NULL) &amp;&amp; (!SetEvent(hNewMailEvent))) <br>    { <br>        HRESULT hr = HR_LOG(E_FAIL); <br>    } <br> <br>    return(0); <br>} <br> <br>//$--HrGWWaitForStop---------------------------------------------------- <br>//  Wait for the gateway to stop. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGWWaitForStop(        // RETURNS: return code <br>    void)                               // no arguments <br>{ <br>    HRESULT hr          = NOERROR; <br>    HANDLE  hObjects[2] = {0}; <br>    DWORD   dwT         = WAIT_FAILED; <br>    ULONG   i           = 0; <br> <br>    DEBUGPUBLIC("HrGWWaitForStop()\n"); <br> <br>    if(hNewMailThread != NULL) <br>    { <br>        hObjects[i++] = hNewMailThread; <br>    } <br> <br>    if(hNewFileThread != NULL) <br>    { <br>        hObjects[i++] = hNewFileThread; <br>    } <br> <br>    if(i &gt; 0) <br>    { <br>        dwT = WaitForMultipleObjects(i, hObjects, TRUE, INFINITE); <br> <br>        if(dwT == WAIT_FAILED) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetArbValue-------------------------------------------------------------- <br>//  Get an arbitrary value - allocating memory to hold it. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetArbValue(       // RETURNS: return code <br>    IN HKEY hk,                     // the key. <br>    IN LPSTR pszValue,              // value name in key. <br>    OUT DWORD * pType,              // where to put type info. <br>    OUT DWORD * pcb,                // where to put byte count info. <br>    OUT LPVOID * ppData)            // where to put the data. <br>{ <br>    HRESULT hr   = E_FAIL; <br>    LONG    lRet = 0; <br> <br>    DEBUGPRIVATE("HrGetArbValue()\n"); <br> <br>    *ppData = NULL; <br> <br>    // <br>    //  Get its size. <br>    // <br>    lRet = RegQueryValueEx( <br>        hk, <br>        pszValue, <br>        NULL, <br>        pType, <br>        NULL, <br>        pcb); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Allocate memory for it. <br>    // <br> <br>    *ppData = GlobalAlloc(GPTR, *pcb); <br> <br>    if(*ppData == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // get the current value <br>    // <br>    lRet = RegQueryValueEx(hk, pszValue, NULL, pType, *ppData, pcb); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = NOERROR; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        if(ppData != NULL) <br>        { <br>            GLOBALFREE(*ppData); <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCheckExchangeRunning----------------------------------------------------- <br>//  Check if the Exchange server is running. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCheckExchangeRunning(      // RETURNS: return code <br>    IN LPSTR lpszServiceName) <br>{ <br>    HRESULT hr                          = NOERROR; <br>    LONG    lRet                        = 0; <br>    DWORD   dwService                   = 0; <br>    DWORD   dwCurrentState              = 0; <br>DWORD   dwType                      = 0; <br>DWORD   cbOrig                      = 0; <br>    LPSTR  lpszServerName              = NULL; <br>HKEY    hkParameters                = INVALID_HANDLE_VALUE; <br>CHAR   szParametersKey[MAX_PATH+1] = {0}; <br> <br>    // <br>    //  Open the parameters key. <br>    // <br> <br>sprintf( <br>    szParametersKey, <br>    "SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters", <br>    lpszServiceName); <br> <br>    lRet = RegOpenKeyEx( <br>        HKEY_LOCAL_MACHINE, <br>        szParametersKey,  <br>        0, <br>        KEY_READ, <br>        &amp;hkParameters); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Get the Exchange server name. <br>    // <br> <br>    hr = HrGetArbValue( <br>        hkParameters, "HomeDSA", &amp;dwType, &amp;cbOrig, (LPVOID) &amp;lpszServerName); <br> <br>    if(FAILED(hr) || dwType != REG_SZ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Copy Exchange server name. <br>    // <br> <br>    lstrcpyn(szServerName, lpszServerName, MAX_COMPUTERNAME_LENGTH); <br>    szServerName[MAX_COMPUTERNAME_LENGTH] = 0; <br> <br>// TODO: remove "#ifndef" and "#endif" <br>#ifndef DEBUG <br>    hr = HrGetExchangeStatus( <br>        lpszServerName, <br>        &amp;dwService, <br>        &amp;dwCurrentState); <br> <br>    if(FAILED(hr)) <br>    { <br>MODULE_ERROR1( <br>    "The Exchange server on %s is not running!", <br>    lpszServerName); <br> <br>    hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br>#endif <br> <br>cleanup: <br> <br>    GLOBALFREE(lpszServerName); <br> <br>    if(hkParameters != INVALID_HANDLE_VALUE) <br>    { <br>        HR_LOG(HRESULT_FROM_WIN32(RegCloseKey(hkParameters))); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInternalGatewayLogon----------------------------------------------------- <br>//  Logon to the gateway. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrInternalGatewayLogon(void)  // RETURNS: return code <br>{ <br>    HRESULT         hr               = NOERROR; <br> <br>    ULONG           cValues          = 0; <br>    LPSPropValue    lpProp           = NULL; <br> <br>    ULONG           ulObjType        = 0; <br> <br>    ULONG           cbStoreEid       = 0; <br>    LPENTRYID       lpStoreEid       = NULL; <br> <br>    SPropTagArray   rgMtsInEntryId   = { 1, { PR_GW_MTSIN_ENTRYID } }; <br>    ULONG           cbMtsInEid       = 0; <br>    LPENTRYID       lpMtsInEid       = NULL; <br> <br>    SPropTagArray   rgMtsOutEntryId  = { 1, { PR_GW_MTSOUT_ENTRYID } }; <br>    ULONG           cbMtsOutEid      = 0; <br>    LPENTRYID       lpMtsOutEid      = NULL; <br> <br>    CHAR           szGatewayName[MAX_SERVICE_NAME_LENGTH+1] = {0}; <br> <br>MAPIINIT_0MapiInit         = { 0 }; <br> <br>    ULONG           ulFlags          = 0; <br> <br>    LPMAPIADVISESINK lpAdvise        = NULL; <br> <br>    CHAR           szProfileName[MAX_PATH+1] = {0}; <br> <br>    BOOL            IsProfileCreated = FALSE; <br> <br>    DEBUGPRIVATE("HrInternalGatewayLogon()\n"); <br> <br>    // <br>    // Initialize critical section for new mail list. <br>    // <br> <br>    InitializeCriticalSection(&amp;csNewMailList); <br> <br>    // <br>    // Initialize critical section for new file list. <br>    // <br> <br>    InitializeCriticalSection(&amp;csNewFileList); <br> <br>    // <br>    // Get gateway service name. <br>    // <br> <br>    hr = HrServiceGetName( <br>        szGatewayName); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Check if Exchange is running. <br>    // <br> <br>    hr = HrCheckExchangeRunning( <br>        szGatewayName); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Create the event object. The new mail event handler function signals <br>    // this event when it receives a new mail notification. <br> <br>    hNewMailEvent = CreateEvent( <br>        NULL,    // no security attributes <br>        FALSE,   // auto-reset event <br>        FALSE,   // not-signalled <br>        NULL);   // no name <br> <br>    if(hNewMailEvent == (HANDLE)NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    MapiInit.ulVersion = MAPI_INIT_VERSION; <br> <br>    ulFlags = MAPI_NEW_SESSION|MAPI_EXTENDED|MAPI_NO_MAIL; <br> <br>  if(FIsService()) <br>{// Services need special initialization. <br>  MapiInit.ulFlags = MAPI_NT_SERVICE; <br>ulFlags |= MAPI_NT_SERVICE; <br>} <br> <br>    hr = MAPIInitialize(&amp;MapiInit); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    IsInitMAPI = TRUE; <br> <br>    hr = HrCreateProfileName( <br>        szGatewayName, <br>        MAX_PATH+1, <br>        szProfileName); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>hr = HrCreateGatewayProfile(szGatewayName, szProfileName); <br> <br>if(hr == E_ACCESSDENIED) <br>{ <br>MODULE_WARNING( <br>"Could not create profile since previous profile with same name " <br>"is still logged on."); <br>        hr = NOERROR; <br>} <br>    else if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br>    else <br>    { <br>        IsProfileCreated = TRUE; <br>    } <br> <br>    // Create a MAPI session <br>    hr = MAPILogonEx( <br>        0, <br>        szProfileName, <br>        NULL, <br>        ulFlags, <br>        &amp;lpSession); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    IsMAPILogon = TRUE; <br> <br>#define PSESSION ((LPMAPISESSION)lpSession) <br> <br>    // Get entry ID of message store <br>    hr = HrMAPIFindDefaultMsgStore(lpSession, &amp;cbStoreEid, &amp;lpStoreEid); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL(PSESSION)-&gt;OpenMsgStore( <br>        PSESSION, <br>        (ULONG)0, <br>        cbStoreEid, <br>        lpStoreEid, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS | MDB_NO_DIALOG | MDB_WRITE, <br>        &amp;lpStore); <br> <br>#undef PSESSION <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Get the root folder in the default message store <br>    hr = MAPICALL(lpStore)-&gt;OpenEntry( <br>        lpStore, <br>        (ULONG)0, <br>        NULL, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *) &amp;lpRootFolder); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Get the MTS-IN entry ID property.  <br>    hr = MAPICALL(lpStore)-&gt;GetProps( <br>        lpStore, <br>        &amp;rgMtsInEntryId, <br>        fMapiUnicode, <br>        &amp;cValues, <br>        &amp;lpProp); <br> <br>    if(FAILED(hr)) <br>    { <br>        lpProp = NULL; <br> <br>        goto cleanup; <br>    } <br> <br>    // Check to make sure we got the right property. <br>    if (lpProp-&gt;ulPropTag != PR_GW_MTSIN_ENTRYID) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cbMtsInEid = lpProp-&gt;Value.bin.cb; <br> <br>    hr = MAPIAllocateBuffer(cbMtsInEid, (void **)&amp;lpMtsInEid); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Copy MTS-IN Entry ID <br>    CopyMemory(lpMtsInEid,lpProp-&gt;Value.bin.lpb,cbMtsInEid); <br> <br>    MAPIFREEBUFFER(lpProp); <br> <br>    // Get the MTS-OUT entry ID property.  <br>    hr = MAPICALL(lpStore)-&gt;GetProps( <br>        lpStore, <br>        &amp;rgMtsOutEntryId, <br>        fMapiUnicode, <br>        &amp;cValues, <br>        &amp;lpProp); <br> <br>    if(FAILED(hr)) <br>    { <br>        lpProp = NULL; <br> <br>        goto cleanup; <br>    } <br> <br>    // Check to make sure we got the right property. <br>    if(lpProp-&gt;ulPropTag != PR_GW_MTSOUT_ENTRYID) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cbMtsOutEid = lpProp-&gt;Value.bin.cb; <br> <br>    hr = MAPIAllocateBuffer(cbMtsOutEid, (void **)&amp;lpMtsOutEid); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Copy MTS-OUT Entry ID <br>    CopyMemory(lpMtsOutEid,lpProp-&gt;Value.bin.lpb,cbMtsOutEid); <br> <br>    MAPIFREEBUFFER(lpProp); <br> <br>    // Open the MTS-IN folder in the root folder <br>    hr = MAPICALL(lpRootFolder)-&gt;OpenEntry( <br>        lpRootFolder, <br>        cbMtsInEid, <br>        lpMtsInEid, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *) &amp;lpMtsInFolder); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if(ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Open the MTS-OUT folder in the root folder <br>    hr = MAPICALL(lpRootFolder)-&gt;OpenEntry( <br>        lpRootFolder, <br>        cbMtsOutEid, <br>        lpMtsOutEid, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS|MAPI_MODIFY, <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *) &amp;lpMtsOutFolder); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if(ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Open the Address Book <br>    hr = MAPICALL(lpSession)-&gt;OpenAddressBook( <br>        lpSession, <br>        0, <br>        NULL,  <br>        AB_NO_DIALOG, <br>        &amp;lpAdrBook); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = HrFindExchangeGlobalAddressList( <br>        lpAdrBook, <br>        &amp;cbGalEid, <br>        &amp;lpGalEid); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrAllocAdviseSink(ScNewMailHandler, NULL, &amp;lpAdvise); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL(lpStore)-&gt;Advise( <br>        lpStore, <br>        cbMtsOutEid, <br>        lpMtsOutEid, <br>        fnevNewMail, <br>        lpAdvise, <br>        &amp;ulNewMailAdvise); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Open the global recipient container <br>    hr = MAPICALL(lpAdrBook)-&gt;OpenEntry( <br>        lpAdrBook,  <br>        cbGalEid, <br>        lpGalEid, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *)&amp;lpGalABCont); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if(ulObjType != MAPI_ABCONT) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(IsProfileCreated == TRUE) <br>    { <br>        // Mark profile for deletion <br>        HR_LOG(HrRemoveProfile(szProfileName)); <br>    }; <br> <br>    ULRELEASE(lpAdvise); <br> <br>    MAPIFREEBUFFER(lpProp); <br> <br>    if(FAILED(hr)) <br>    { <br>        if((ulNewMailAdvise != 0xFFFFFFFFL) &amp;&amp; (lpStore != NULL)) <br>        { <br>            MAPICALL(lpStore)-&gt;Unadvise(lpStore, ulNewMailAdvise); <br>        } <br> <br>        if(hNewMailEvent != NULL) <br>        { <br>            if(!CloseHandle(hNewMailEvent)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>        } <br> <br> <br>        ULRELEASE(lpGalABCont); <br> <br>        ULRELEASE(lpAdrBook); <br> <br>        ULRELEASE(lpMtsInFolder); <br> <br>        ULRELEASE(lpMtsOutFolder); <br> <br>        ULRELEASE(lpRootFolder); <br> <br>        ULRELEASE(lpStore); <br> <br>        MAPIFREEBUFFER(lpGalEid); <br> <br>        if(IsMAPILogon == TRUE) <br>        { <br>            // Logoff a MAPI session <br>            MAPICALL(lpSession)-&gt;Logoff( <br>                lpSession, <br>                (ULONG)0, <br>                (ULONG)0, <br>                (ULONG)0); <br> <br>            MAPICALL(lpSession)-&gt;Release( <br>                lpSession); <br> <br>            lpSession = NULL; <br>        } <br> <br>        if(IsInitMAPI == TRUE) <br>        { <br>            MAPIUninitialize(); <br> <br>            IsInitMAPI = FALSE; <br>        } <br> <br>        IsMAPILogon = FALSE; <br>    } <br> <br>    MAPIFREEBUFFER(lpMtsInEid); <br> <br>    MAPIFREEBUFFER(lpMtsOutEid); <br> <br>    MAPIFREEBUFFER(lpStoreEid); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInternalGatewayLogoff---------------------------------------------------- <br>//  Logoff of the gateway. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrInternalGatewayLogoff(void) // RETURNS: return code <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("HrInternalGatewayLogoff()\n"); <br> <br>    if((ulNewMailAdvise != 0xFFFFFFFFL) &amp;&amp; (lpStore != NULL)) <br>    { <br>        MAPICALL(lpStore)-&gt;Unadvise(lpStore, ulNewMailAdvise); <br>    } <br> <br>    if(hNewMailEvent != NULL) <br>    { <br>        if(!CloseHandle(hNewMailEvent)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    if(hNewMailThread != NULL) <br>    { <br>        if(!CloseHandle(hNewMailThread)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    if(hNewFileThread != NULL) <br>    { <br>        if(!CloseHandle(hNewFileThread)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    ULRELEASE(lpMtsInFolder); <br> <br>    ULRELEASE(lpMtsOutFolder); <br> <br>    ULRELEASE(lpRootFolder); <br> <br>    ULRELEASE(lpStore); <br> <br>    MAPIFREEBUFFER(lpGalEid); <br> <br>    ULRELEASE(lpGalABCont); <br> <br>    ULRELEASE(lpAdrBook); <br> <br>    if(IsMAPILogon == TRUE) <br>    { <br>        // Logoff a MAPI session <br>        MAPICALL(lpSession)-&gt;Logoff( <br>            lpSession, <br>            (ULONG)0, <br>            (ULONG)0, <br>            (ULONG)0); <br> <br>        MAPICALL(lpSession)-&gt;Release( <br>            lpSession); <br> <br>        lpSession = NULL; <br>    } <br> <br>    if(IsInitMAPI == TRUE) <br>    { <br>        MAPIUninitialize(); <br> <br>        IsInitMAPI = FALSE; <br>    } <br> <br>    IsMAPILogon = FALSE; <br> <br>    DeleteCriticalSection(&amp;csNewMailList); <br> <br>    DeleteCriticalSection(&amp;csNewFileList); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrServiceStartup--------------------------------------------------------- <br>//  This function is called at startup to initialize the gateway. <br>//------------------------------------------------------------------------------ <br>HRESULT HrServiceStartup(         // RETURNS: return code <br>    IN HINSTANCE    hInstance,      // handle of current instance <br>    IN HINSTANCE    hPrevInstance,  // handle of previous instance <br>    IN HWND         hwndMainWindow, // handle to main window <br>    IN LPSTR        lpszCmdLine)    // pointer to command line <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrServiceStartup()\n"); <br> <br>    hr = HrInternalGatewayLogon(); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = HrGWLogon(); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--ServiceMain-------------------------------------------------------------- <br>//  This function is given its own thread to execute. <br>//------------------------------------------------------------------------------ <br>void ServiceMain(                 // RETURNS: nothing <br>    IN HANDLE hEventShutdown)       // handle to shutdown event object <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("ServiceMain()\n"); <br> <br>    __try <br>    { <br>        GWMain(); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br> <br>    } <br> <br>    // <br>    // Wait for the gateway to stop. <br>    // <br> <br>    __try <br>    { <br>        hr = HrGWWaitForStop(); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(hr); <br>    } <br> <br>    // <br>    // Confirm that the gateway has stopped. <br>    // <br> <br>    __try <br>    { <br>        hr = HrServiceConfirmStop(); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(hr); <br>    } <br> <br>    ExitThread(0); <br>} <br> <br>//$--HrServiceShutdown-------------------------------------------------------- <br>//  This function is called to shutdown the gateway. <br>//------------------------------------------------------------------------------ <br>HRESULT HrServiceShutdown(            // RETURNS: exit code <br>    void) <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrServiceShutdown()\n"); <br> <br>    hr = HrGWLogoff(); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br>         <br>    hr = HrInternalGatewayLogoff(); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
