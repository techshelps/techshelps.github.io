<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVDLL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1868"></a>CONVDLL.CPP</h2>
<pre><code>// --convdll.cpp---------------------------------------------------------------- <br>//  <br>// Conversion DLL code. <br>// Handles loading, unloading and using conversion DLLs. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#include "convincl.h" <br>#include "convdll.chk" <br> <br>// external declarations <br>extern CEDKConvReg *  pCConvReg;        // global conversion registry information pointer <br> <br> <br>//$--CEDKConvDll::CEDKConvDll--------------------------------------------------- <br>// <br>// DESCRIPTION: CEDKConvDLL class constructor <br>// <br>// INPUT:   pep --  CDllEntryPoint class instance <br>//                  hEventSource    --  event source handle <br>// <br>// RETURNS: nothing <br>// <br>//------------------------------------------------------------------------------ <br>CEDKConvDll::CEDKConvDll( <br>    IN CDllEntryPoint * pep, <br>    IN HANDLE hEventSource) <br>{ <br>    DEBUGPRIVATE("CEDKConvDll::CEDKConvDll()\n"); <br> <br>    // check input parameters <br>    CHK_CEDKConvDll_CEDKConvDll(pep, hEventSource); <br> <br>    m_pepEntry = pep; <br>    m_hEventSource = hEventSource; <br> <br>    // initialize other class data members <br>    m_hDll = NULL; <br>    m_pDllVector = NULL; <br> <br>} <br> <br>//$--CEDKConvDll::~CEDKConvDll-------------------------------------------------- <br>// <br>// DESCRIPTION: CEDKConvDLL class destructor <br>//  <br>// INPUT:   none <br>// <br>// RETURNS: nothing <br>// <br>//------------------------------------------------------------------------------ <br>CEDKConvDll::~CEDKConvDll() <br>{ <br>    DEBUGPRIVATE("CEDKConvDLL::~CEDKConvDLL()\n"); <br> <br>    m_pepEntry = NULL; <br>} <br> <br>//$--CEDKConvDll::HrEDKLoad-------------------------------------------------------- <br>// <br>//  DESCRIPTION: Load the specified DLL, find the entry point and invoke the <br>//  initialization method.  If this method fails, it frees the <br>//  DLL and entry point.  If this method succeeds, rcUnLoad must <br>//  be called to release the library. <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    HRESULT --  NOERROR if no error, <br>//                          E_FAIL otherwise. <br>// <br>//------------------------------------------------------------------------------ <br>HRESULT CEDKConvDll::HrEDKLoad()        // RETURNS:  HRESULT <br>{ <br>    HRESULT         hr      =   NOERROR;    // return code <br>    PCONVDLLENTRYFN pfnTmp  =   NULL;       // DLL entry point <br>     <br>    DEBUGPRIVATE("CEDKConvDLL::HrEDKLoad()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR(m_pepEntry != NULL, "NULL m_pepEntry parameter."); <br>    ASSERTERROR(pCConvReg != NULL, "NULL pCConvReg"); <br> <br>    // <br>    //  Find the library in our cache <br>    // <br>    hr = pCConvReg-&gt;HrGetDllHandle( <br>        m_pepEntry-&gt;pszDllName(),   // DLL name <br>        &amp;m_hDll);                   // DLL instance pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(m_hDll != NULL, "Bad m_hDll"); <br> <br>    // <br>    //  Find the entry point. <br>    // <br>    pfnTmp = (PCONVDLLENTRYFN)GetProcAddress( <br>            m_hDll,  <br>            m_pepEntry-&gt;pszEntryPoint()); <br> <br>    if(pfnTmp != NULL) <br>    { <br>        // <br>        //  Get the vector table. <br>        // <br>        hr = pfnTmp(nDesiredConvDllVersion, &amp;m_pDllVector); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>    else <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if( FAILED(hr) ) <br>    { <br>        m_pDllVector = NULL; <br>        m_hDll = NULL;             <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--CEDKConvDll::HrEDKUnLoad------------------------------------------------------ <br>// <br>//  DESCRIPTION: Invoke the DLL cleanup method and release the library. <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise <br>// <br>//------------------------------------------------------------------------------ <br>HRESULT CEDKConvDll::HrEDKUnLoad() <br>{ <br>    HRESULT hr  =   NOERROR;        // return code <br> <br>    DEBUGPRIVATE("CEDKConvDLL::HrEDKUnLoad()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR(m_pDllVector != NULL,"NULL m_pDllVector parameter"); <br> <br>    ASSERTERROR(m_hDll != NULL,"NULL m_hDll parameter"); <br> <br>    // <br>    //  Free the library. <br>    // <br> <br>    FreeLibrary(m_hDll); <br> <br>    m_pDllVector = NULL; <br>    m_hDll = NULL; <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKConvDll::HrEDKQueryCapability--------------------------------------------- <br>// <br>//  DESCRIPTION: Invoke the query capability method of the dll. <br>// <br>//  INPUT:  pEnv    --  environment for conversion <br>//          pszContentClass --  class to be converted <br>//          pConent --  pointer to the content <br>// <br>//  OUTPUT: fAmCandidate    --  TRUE if can be converted, FALSE otherwise. <br>// <br>//  RETURNS:    HRESULT --  NOERROR if overall function call succeeds, <br>//                          E_INVALIDARG if bad input <br>// <br>//------------------------------------------------------------------------------ <br>HRESULT CEDKConvDll::HrEDKQueryCapability(  // RETURN - HRESULT <br>    IN PEDKCNVENV pEnv,             // environment for conversion. <br>    IN LPCWSTR pszContentClass,     // class to be converted. <br>    IN PVOID pContent,              // pointer to the content. <br>    OUT BOOL &amp;fAmCandidate)         // result of the conversion. <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("CEDKConvDLL::HrEDKQueryCapability()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CEDKConvDll_HrEDKQueryCapability(pEnv, pszContentClass, pContent, <br>                                  fAmCandidate); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // consistency checking <br>    ASSERTERROR(m_pDllVector != NULL,"NULL m_pDllVector parameter"); <br> <br>    ASSERTERROR(m_hDll != NULL,"NULL m_hDll parameter"); <br> <br>    hr = m_pDllVector-&gt;pfnCnvQueryCapability( <br>            m_pepEntry-&gt;pszOptions(),  <br>            pszContentClass, <br>            pContent, <br>            pEnv, <br>            &amp;fAmCandidate); <br> <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKConvDll::HrEDKConvert----------------------------------------------------- <br>// <br>//  DESCRIPTION: Invoke the converter. <br>// <br>//  INPUT:  pEnv    --  environment <br>//          lpszContentClass    --  class of content to convert <br>//          pContentIn  --  source <br>//          pContentOut --  target of conversion <br>//           <br>//  OUTPUT:  <br>//          crResult    --  result of conversion <br>// <br>//  RETURNS:    HRESULT --  NOERROR if overall call succeeds, <br>//                          E_INVALIDARG if bad input. <br>// <br>//------------------------------------------------------------------------------ <br>HRESULT CEDKConvDll::HrEDKConvert(  // RETURNS: HRESULT <br>    IN PEDKCNVENV pEnv,             // environment <br>    IN LPCWSTR lpszContentClass,    // class of content to convert. <br>    IN PVOID pContentIn,            // source. <br>    IN PVOID pContentOut,           // target of conversion <br>    OUT EDKCNVRES &amp; crResult)       // result of conversion <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("CEDKConvDLL::HrEDKConvert()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CEDKConvDll_HrEDKConvert(pEnv, lpszContentClass, pContentIn, pContentOut, <br>                          crResult); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // consistency checking <br>    ASSERTERROR(m_pDllVector != NULL,"NULL m_pDllVector parameter"); <br> <br>    ASSERTERROR(m_hDll != NULL,"NULL m_hDll parameter"); <br> <br>    hr = m_pDllVector-&gt;pfnCnvConvert( <br>            m_pepEntry-&gt;pszOptions(),  <br>            lpszContentClass, <br>            pContentIn, <br>            pContentOut, <br>            pEnv, <br>            &amp;crResult); <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
