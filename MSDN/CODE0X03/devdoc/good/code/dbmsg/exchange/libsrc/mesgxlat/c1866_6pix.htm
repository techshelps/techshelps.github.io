<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVDLLC.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1869"></a>CONVDLLC.CPP</h2>
<pre><code>// --convdllc.cpp-------------------------------------------------------------- <br>// <br>// Conversion DLL cache source code. <br>// <br>// Copyright (C) Microsoft Corp., 1986-1996.  All rights reserved. <br>// <br>// ---------------------------------------------------------------------------- <br> <br>#include "convincl.h" <br>#include "convdllc.chk" <br> <br>//$--CDllCache::CDllCache()---------------------------------------------------- <br>// <br>// DESCRIPTION: constructor <br>// <br>// INPUT: none <br>// <br>// RETURNS; nothing <br>// <br>//----------------------------------------------------------------------------- <br>CDllCache::CDllCache() <br>{ <br>    DEBUGPRIVATE("CDllCache::CDllCache()\n"); <br> <br>    ZeroMemory(m_rgSDllCache, sizeof(m_rgSDllCache)); <br>} <br> <br>//$--CDllCache::~CDllCache()---------------------------------------------------- <br>// <br>// DESCRIPTION: destructor <br>// <br>// INPUT: none <br>// <br>// RETURNS; nothing <br>// <br>//----------------------------------------------------------------------------- <br>CDllCache::~CDllCache() <br>{ <br>    UINT            iDll    =   0;      // index into DLL cache <br>    SDllCache *     pDll    =   NULL;   // current DLL pointer <br> <br>    DEBUGPRIVATE("CDllCache::~CDllCache()\n"); <br> <br>    // Unload any loaded DLLs <br>    for ( iDll = 0; iDll &lt; nCachedDlls; iDll++ ) <br>    { <br>        // get current DLL pointer <br>        pDll = m_rgSDllCache[iDll]; <br> <br>        // See if its valid <br>        if ( pDll != NULL ) <br>        { <br>            // unload the DLL <br>            ASSERTERROR(pDll-&gt;hInst != NULL, "Bad pDll-&gt;hInst"); <br>            (VOID)FreeLibrary(pDll-&gt;hInst); <br> <br>            // Free the DLL cache entry <br>            delete pDll; <br> <br>            pDll = NULL;    // null out pointer <br>        } <br> <br>    }   // end for each cached DLL <br> <br>} <br> <br>//$--CDllCache::HrAdd---------------------------------------------------------- <br>// <br>// DESCRIPTION: Loads DLL and adds it to the cache. <br>// <br>// INPUT:       lpwszDllName  --  DLL name <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_OUTOFMEMORY if memory problems. <br>//                          E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CDllCache::HrAdd( <br>        IN LPWSTR lpwszDllName)     // DLL to add <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    SDllCache *     pDllCur     =   NULL;   // current cached DLL pointer <br>    UINT            iDll        =   0;      // index into DLL cache <br>    BOOL            fLoaded     =   FALSE;  // TRUE if DLL loaded <br> <br>    DEBUGPRIVATE("CDllCache::HrAdd()\n"); <br> <br>    // check input parameters            <br>    hr = CHK_CDllCache_HrAdd(lpwszDllName); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Find next empty space in the DLL cache <br>    for ( iDll = 0; iDll &lt; nCachedDlls; iDll++ ) <br>    { <br>        pDllCur = m_rgSDllCache[iDll]; <br> <br>        if ( pDllCur == NULL ) <br>        { <br>            // found an place for this DLL. <br>            pDllCur = new SDllCache;    // allocate new cache entry <br> <br>            if ( pDllCur == NULL ) <br>            { <br>                hr = HR_LOG(E_OUTOFMEMORY); <br> <br>                goto cleanup; <br>            } <br> <br>            // fill in DLL entry information. <br>            lstrcpyW(pDllCur-&gt;lpwszName, lpwszDllName);  // copy DLL name <br> <br>            // Load DLL <br>            pDllCur-&gt;hInst = LoadLibraryW(lpwszDllName); <br> <br>            if ( pDllCur-&gt;hInst == NULL ) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            // Save DLL entry information in the cache. <br>            m_rgSDllCache[iDll] = pDllCur; <br> <br>            fLoaded = TRUE; // DLL is now loaded <br> <br>            break; <br> <br>        }   // end if found space <br> <br>        // Otherwise, make sure that this DLL isn't already loaded. <br>        else if ( lstrcmpiW(pDllCur-&gt;lpwszName, lpwszDllName) == 0 ) <br>        { <br>            // Dll already here.   <br>            ASSERTERROR(pDllCur-&gt;hInst != NULL, "Bad pDllCur-&gt;hInst"); <br> <br>            fLoaded = TRUE; <br> <br>            // We are done! <br>            break; <br>        } <br>    }   // end for <br> <br>    // handle case where can't load DLL <br>    if ( fLoaded == FALSE ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CDllCache::HrFind------------------------------------------------ <br>// <br>// DESCRIPTION: Finds instance handle of DLL in cache. <br>// <br>// INPUT:       lpwszDllName  --  DLL name <br>// <br>// OUTPUT:      phInst  --  pointer to DLL instance handle <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CDllCache::HrFind( <br>        IN LPWSTR lpwszDllName,     // DLL to find <br>        OUT HINSTANCE * phInst)     // pointer to DLL instance handle <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    SDllCache *     pDllCur     =   NULL;   // current cached DLL pointer <br>    UINT            iDll        =   0;      // index into DLL cache <br>    BOOL            fFound      =   FALSE;  // TRUE if DLL is currently cached <br> <br>    DEBUGPRIVATE("CDllCache::HrFind()\n"); <br> <br>    // check input parameters            <br>    hr = CHK_CDllCache_HrFind(lpwszDllName, phInst); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // intialize output parameter <br>    *phInst = NULL; <br> <br>    // See if this DLL is already loaded and determine the index <br>    // of least used DLL in cache <br>    for ( iDll = 0; iDll &lt; nCachedDlls; iDll++ ) <br>    { <br>        // get pointer to current DLL. <br>        pDllCur = m_rgSDllCache[iDll]; <br> <br>        // See if it is a valid pointer <br>        if ( pDllCur == NULL ) <br>        { <br>            // No more cached DLLs <br>            break; <br>        } <br> <br>        // See if this DLL is already loaded <br>        if ( lstrcmpiW(lpwszDllName, pDllCur-&gt;lpwszName) == 0 ) <br>        { <br>            // found DLL <br>            fFound = TRUE; <br> <br>            // Succeeded.   <br>            // Set our output variable <br>            *phInst = pDllCur-&gt;hInst; <br> <br>            // done <br>            break; <br>        } <br>    }   // end for each DLL in cache <br> <br>    // See if DLL was found <br>    if ( fFound == FALSE ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br> <br>    }   // end if DLL not loaded. <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
