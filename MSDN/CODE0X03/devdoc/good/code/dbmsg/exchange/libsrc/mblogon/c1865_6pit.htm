<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MBLOGON.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1865"></a>MBLOGON.C</h2>
<pre><code>// --MBLOGON.c------------------------------------------------------------------ <br>// <br>//  Privileged Access to logon and off of any message store. <br>//   <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "edkguid.h" <br>#include "mblogon.chk" <br> <br>//$--HrMailboxLogon------------------------------------------------------ <br>// Logon to a mailbox.  Before calling this function do the following: <br>//  1) Create a profile that has Exchange administrator privileges. <br>//  2) Logon to Exchange using this profile. <br>//  3) Open the mailbox using the Message Store DN and Mailbox DN. <br>// <br>// This version of the function needs the server and mailbox names to be <br>// in the form of distinguished names.  They would look something like this: <br>//       /O=&lt;Organization&gt;/OU=&lt;Site&gt;/CN=Servers/CN=&lt;ServerName&gt;/CN=NULL <br>//       /O=&lt;Organization&gt;/OU=&lt;Site&gt;/CN=&lt;Container&gt;/CN=&lt;MailboxName&gt; <br>// where items in &lt;brackets&gt; would need to be set to appropriate values <br>//  <br>// Note1: The message store DN is nearly identical to the server DN, except <br>// for the addition of a trailing '/CN=' part.  This part is required although <br>// its actual value is ignored. <br>// <br>// Note2: A NULL lpszMailboxDN indicates the public store should be opened. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT HrMailboxLogon( <br>    IN  LPMAPISESSION   lplhSession,      // MAPI session handle <br>    IN  LPMDB           lpMDB,            // open message store <br>    IN  LPSTR           lpszMsgStoreDN,   // desired message store DN <br>    IN  LPSTR           lpszMailboxDN,    // desired mailbox DN or NULL <br>    OUT LPMDB           *lppMailboxMDB)   // ptr to mailbox message store ptr <br>{ <br>    HRESULT                 hr              = NOERROR; <br>    LPEXCHANGEMANAGESTORE   lpXManageStore  = NULL; <br>    LPMDB                   lpMailboxMDB    = NULL; <br>    ULONG                   ulFlags         = 0L; <br>    ULONG                   cbeid           = 0L;     // count of bytes in entry ID <br>    LPENTRYID               lpeid           = NULL;   // Entry ID of default store <br> <br>    DEBUGPUBLIC( "HrMailboxLogon()"); <br> <br>    hr = CHK_HrMailboxLogon( <br>        lplhSession, lpMDB, lpszMsgStoreDN, lpszMailboxDN,  <br>        lppMailboxMDB); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Cheap firewall against API abuse <br>    if( !lplhSession || !lpMDB || !lpszMsgStoreDN) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL( lpMDB)-&gt;QueryInterface( lpMDB, <br>        (REFIID) &amp;IID_IExchangeManageStore, <br>        (LPVOID*) &amp;lpXManageStore); <br>    if( FAILED( hr)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR( lpXManageStore != NULL, "NULL lpXManageStore pointer"); <br>             <br>    // Use NULL MailboxDN for opening the public store <br>    if( lpszMailboxDN == NULL || !*lpszMailboxDN) <br>    { <br>        ulFlags = OPENSTORE_PUBLIC; <br>    } <br> <br>    hr = MAPICALL( lpXManageStore)-&gt;CreateStoreEntryID( lpXManageStore, <br>        lpszMsgStoreDN, lpszMailboxDN, <br>        ulFlags | OPENSTORE_USE_ADMIN_PRIVILEGE | OPENSTORE_TAKE_OWNERSHIP, <br>        &amp;cbeid, &amp;lpeid); <br>    if( FAILED( hr)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br>         <br>    ASSERTERROR( lpeid != NULL, "NULL lpeid pointer"); <br> <br>    hr = MAPICALL( lplhSession)-&gt;OpenMsgStore( <br>        lplhSession, 0, cbeid, lpeid, NULL, <br>    MDB_NO_DIALOG | <br>        MDB_NO_MAIL |       // spooler not notified of our presence <br>        MDB_TEMPORARY |     // message store not added to MAPI profile <br>        MAPI_BEST_ACCESS,   // normally WRITE, but allow access to RO store <br>    &amp;lpMailboxMDB); <br>    if( FAILED(hr)) <br>    { <br>        if( hr == MAPI_E_NOT_FOUND) <br>            hr = HR_LOG( EDK_E_NOT_FOUND); <br>        else <br>            hr = HR_LOG( E_FAIL); <br>         <br>        goto cleanup; <br>    } <br> <br>    if( hr == MAPI_W_ERRORS_RETURNED) <br>    { <br>        ULRELEASE( lpMailboxMDB); <br> <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if( lppMailboxMDB) <br>        *lppMailboxMDB = lpMailboxMDB; <br> <br>cleanup:     <br>    MAPIFREEBUFFER( lpeid); <br>    ULRELEASE( lpXManageStore); <br>     <br>    RETURN( hr); <br>} <br> <br>//$--HrMailboxLogoff------------------------------------------------------------ <br>//  Logoff of a mailbox. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT HrMailboxLogoff( <br>    IN OUT LPMDB *lppMailboxMDB)          // ptr to mailbox message store ptr <br>{ <br>    HRESULT hr      = NOERROR; <br>    ULONG   ulFlags = LOGOFF_NO_WAIT; <br> <br>    DEBUGPUBLIC( "HrMailboxLogoff()"); <br> <br>    hr = CHK_HrMailboxLogoff( lppMailboxMDB); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Cheap firewall against API abuse <br>    if( lppMailboxMDB &amp;&amp; *lppMailboxMDB) <br>    { <br>        hr = MAPICALL( *lppMailboxMDB)-&gt;StoreLogoff( *lppMailboxMDB, <br>            &amp;ulFlags); <br>        if( FAILED( hr)) <br>            goto cleanup; <br>     <br>        ULRELEASE( *lppMailboxMDB); <br>    } <br> <br>cleanup: <br> <br>    RETURN( hr); <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
