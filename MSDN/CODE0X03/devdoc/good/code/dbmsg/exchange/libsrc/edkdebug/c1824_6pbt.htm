<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MEMORY.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1829"></a>MEMORY.C</h2>
<pre><code>// --memory.c------------------------------------------------------------------- <br>//  <br>//  Memory wrapping functions for DEBUG builds. <br>// <br>// Copyright 1986 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#define _PRIVATE_EDKDEBUG_H    <br>#define _PRIVATE_MEMORY_H <br> <br>#include &lt;malloc.h&gt; <br> <br>#define _INC_MALLOC <br> <br>#include "edk.h" <br>#include "_exchdbg.h" <br> <br>#ifdef _NTSDK <br>#undef _NTSDK <br>#endif <br> <br>#include &lt;stddef.h&gt; <br> <br>#undef _INC_MALLOC <br> <br> <br>//$--_DebugMemoryStatus--------------------------------------------------------- <br>//  Writes an entry in the debug log for memory status. <br>// ----------------------------------------------------------------------------- <br>void _DebugMemoryStatus(                // RETURNS: nothing <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN ULONG cBytes)                    // count of bytes <br>{ <br>    CHAR         buf[BUFSIZ+1] = {0}; <br>    MEMORYSTATUS ms            = {0}; <br> <br>    ZeroMemory(&amp;ms, sizeof(MEMORYSTATUS)); <br> <br>    ms.dwLength = sizeof(MEMORYSTATUS); <br> <br>    GlobalMemoryStatus(&amp;ms); <br> <br>_snprintf( <br>    buf, <br>        BUFSIZ, <br>    "\n\tMEMORY:\tAllocBytes: %lu\n" <br>    "\t\tMemoryLoad: %lu\n" <br>    "\t\tTotalPhys: %lu ; AvailPhys: %lu\n" <br>    "\t\tTotalPageFile: %lu ; AvailPageFile: %lu\n" <br>    "\t\tTotalVirtual: %lu ; AvailVirtual: %lu\n", <br>        cBytes, <br>    ms.dwMemoryLoad, <br>    ms.dwTotalPhys, <br>    ms.dwAvailPhys, <br>    ms.dwTotalPageFile, <br>    ms.dwAvailPageFile, <br>    ms.dwTotalVirtual, <br>    ms.dwAvailVirtual); <br> <br>    REPORT_STATUS(buf); <br>} <br> <br>//$--_DebugHeapStatus----------------------------------------------------------- <br>//  Writes an entry in the debug log. <br>// ----------------------------------------------------------------------------- <br>static void _DebugHeapStatus(           // RETURNS: nothing <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN int heapstatus)                  // heap status <br>{ <br>    CHAR buf[BUFSIZ+1] = {0}; <br> <br>    switch (heapstatus) <br>{ <br>    case _FREEENTRY: <br>    _snprintf(buf,BUFSIZ,"HEAP: free entry in heap\n"); <br>    break; <br>    case _HEAPOK: <br>    break; <br>    case _HEAPEMPTY: <br>    _snprintf(buf,BUFSIZ,"HEAP: heap is empty\n"); <br>        break; <br>    case _HEAPEND: <br>    _snprintf(buf,BUFSIZ,"HEAP: end of heap\n"); <br>    break; <br>    case _HEAPBADPTR: <br>    _snprintf(buf,BUFSIZ,"HEAP: bad pointer to heap\n"); <br>    break; <br>    case _HEAPBADBEGIN: <br>    _snprintf(buf,BUFSIZ,"HEAP: bad start of heap\n"); <br>    break; <br>    case _HEAPBADNODE: <br>    _snprintf(buf,BUFSIZ,"HEAP: bad node in heap\n"); <br>    break; <br>    default: <br>    _snprintf(buf,BUFSIZ,"HEAP: _heapchk returned [%u]\n", heapstatus); <br>    } <br> <br>    if(heapstatus != _HEAPOK) <br>    { <br>        REPORT_ERROR(buf); <br>    } <br>} <br> <br>//$--_DebugHeapCheck------------------------------------------------------------ <br>//  Writes an entry in the debug log. This function is only called in <br>//  DEBUG builds through the DebugHeapCheck() macro. <br>// ----------------------------------------------------------------------------- <br>void _DebugHeapCheck(                   // RETURNS: return code <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile)                  // file name <br>{ <br>    int heapstatus = _HEAPOK; <br> <br>    heapstatus = _heapchk(); <br>     <br>    _DebugHeapStatus(ulLine, lpszFile, heapstatus); <br>} <br> <br>//$--_DebugDumpHeap------------------------------------------------------------- <br>//  Writes an entry in the debug log. This function is only called in <br>//  DEBUG builds through the DebugDumpHeap() macro. <br>// ----------------------------------------------------------------------------- <br>void _DebugDumpHeap(                    // RETURNS: nothing <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile)                  // file name <br>{ <br>    _HEAPINFO hi            = {0}; <br>    int       heapstatus    = _HEAPOK; <br>    CHAR      buf[BUFSIZ+1] = {0}; <br> <br>    ZeroMemory(&amp;hi, sizeof(_HEAPINFO)); <br> <br>    while((heapstatus = _heapwalk (&amp;hi)) == _HEAPOK) <br>    { <br>        if (hi._useflag == _USEDENTRY) <br>        { <br>            _snprintf(buf, BUFSIZ, "HEAP: used block at %08lx of size %u\n", <br>                hi._pentry, <br>                hi._size ); <br> <br>            REPORT_STATUS(buf); <br>        } <br>    } <br> <br>    if(heapstatus != _HEAPOK) <br>    { <br>        _DebugHeapStatus(ulLine, lpszFile, heapstatus); <br>    } <br>} <br> <br>//$--EDKDBG_malloc-------------------------------------------------------------- <br>//  Wrapper for malloc(). <br>// ----------------------------------------------------------------------------- <br>LPVOID EDKDBG_malloc(                   // RETURNS: pointer to memory block <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN ULONG ulSize)                    // size of memory block <br>{ <br>    LPVOID lpv           = NULL; <br>    CHAR   buf[BUFSIZ+1] = {0}; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    lpv = malloc(ulSize); <br> <br>    if(lpv != NULL) <br>    { <br>        if(ulSize &gt; 0) <br>        { <br>            FillMemory(lpv, ulSize, 0xCC); <br>        } <br>    } <br>    else <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",ulSize,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,ulSize); <br>    } <br> <br>    return(lpv); <br>} <br> <br>//$--EDKDBG_calloc-------------------------------------------------------------- <br>//  Wrapper for calloc(). <br>// ----------------------------------------------------------------------------- <br>LPVOID EDKDBG_calloc(                   // RETURNS: pointer to memory block <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN ULONG ulNum,                     // number of elements <br>    IN ULONG ulSize)                    // size of element <br>{ <br>    LPVOID lpv           = NULL; <br>    CHAR   buf[BUFSIZ+1] = {0}; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    lpv = calloc(ulNum, ulSize); <br> <br>    // Calloc cannot fill with 0xCC since that changes the known behaviour of calloc <br> <br>    if(lpv == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",ulSize,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,ulSize); <br>    } <br> <br>    return(lpv); <br>} <br> <br>//$--EDKDBG_realloc------------------------------------------------------------- <br>//  Wrapper for realloc(). <br>// ----------------------------------------------------------------------------- <br>LPVOID EDKDBG_realloc(                  // RETURNS: pointer to memory block <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN LPVOID lpvBlock,                 // pointer to memory block <br>    IN ULONG ulSize)                    // new size of memory block <br>{ <br>    LPVOID lpv           = NULL; <br>    CHAR   buf[BUFSIZ+1] = {0}; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    lpv = realloc(lpvBlock, ulSize); <br> <br>    if(lpv == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",ulSize,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,ulSize); <br>    } <br> <br>    return(lpv); <br>} <br> <br>//$--EDKDBG_strdup-------------------------------------------------------------- <br>//  Wrapper for strdup(). <br>// ----------------------------------------------------------------------------- <br>char* EDKDBG_strdup(                    // RETURNS: pointer to allocated string <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN const char *lpsz)                // pointer to string <br>{ <br>    LPVOID lpv           = NULL; <br>    CHAR   buf[BUFSIZ+1] = {0}; <br> <br>    if(IsBadStringPtrA(lpsz, INFINITE)) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid pointer [%08lx]\n", lpsz); <br> <br>        REPORT_ERROR(buf); <br> <br>        return(lpv); <br>    } <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    lpv = _strdup(lpsz); <br> <br>    if(lpv == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",0,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,0); <br>    } <br> <br>    return((char *)lpv); <br>} <br> <br>//$--EDKDBG_wcsdup-------------------------------------------------------------- <br>//  Wrapper for _wcsdup(). <br>// ----------------------------------------------------------------------------- <br>wchar_t* EDKDBG_wcsdup(                 // RETURNS: pointer to allocated string <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN const wchar_t *lpsz)             // pointer to string <br>{ <br>    LPVOID lpv           = NULL; <br>    CHAR   buf[BUFSIZ+1] = {0}; <br> <br>    if(IsBadStringPtrW(lpsz, INFINITE)) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid pointer [%08lx]\n", lpsz); <br> <br>        REPORT_ERROR(buf); <br> <br>        return(lpv); <br>    } <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    lpv = _wcsdup(lpsz); <br> <br>    if(lpv == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",0,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,0); <br>    } <br> <br>    return((wchar_t *)lpv); <br>} <br> <br>//$--EDKDBG_free---------------------------------------------------------------- <br>//  Wrapper for free(). <br>// ----------------------------------------------------------------------------- <br>void EDKDBG_free(                       // RETURNS: nothing <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN LPVOID lpv)                      // pointer to memory block <br>{ <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    free(lpv); <br> <br>    return; <br>} <br> <br>//$--EDKDBG_GlobalAlloc--------------------------------------------------------- <br>//  Wrapper for GlobalAlloc(). <br>// ----------------------------------------------------------------------------- <br>HGLOBAL EDKDBG_GlobalAlloc(             // RETURNS: pointer to memory block <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN UINT  fuFlags,                   // allocation flags <br>    IN DWORD dwSize)                    // size of memory block <br>{ <br>    LPVOID  lpv           = NULL; <br>    HGLOBAL hglb          = NULL; <br>    DWORD   cBytes        = 0; <br>    CHAR    buf[BUFSIZ+1] = {0}; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    if((fuFlags != 0) &amp;&amp; (! (fuFlags &amp; GMEM_VALID_FLAGS))) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid allocation flags [%08lx]\n", fuFlags); <br> <br>        REPORT_ERROR(buf); <br>    } <br> <br>    hglb = GlobalAlloc(fuFlags, dwSize); <br> <br>    if(hglb == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",dwSize,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,dwSize); <br>    } <br> <br>    return(hglb); <br>} <br> <br>//$--EDKDBG_GlobalReAlloc------------------------------------------------------- <br>//  Wrapper for GlobalReAlloc(). <br>// ----------------------------------------------------------------------------- <br>HGLOBAL EDKDBG_GlobalReAlloc(           // RETURNS: pointer to memory block <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN HGLOBAL hglb,                    // pointer to memory block <br>    IN DWORD cbBytes,                   // new size of memory block <br>    IN UINT  fuFlags)                   // allocation flags <br>{ <br>    LPVOID  lpv           = NULL; <br>    CHAR    buf[BUFSIZ+1] = {0}; <br>    UINT    gflags        = 0; <br>    HGLOBAL hglbMem       = 0; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    if((fuFlags != 0) &amp;&amp; (! (fuFlags &amp; GMEM_VALID_FLAGS))) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid allocation flags [%08lx]\n", fuFlags); <br> <br>        REPORT_ERROR(buf); <br>    } <br> <br>    gflags = GlobalFlags(hglb); <br> <br>    if(gflags == GMEM_INVALID_HANDLE) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid handle [%08lx]\n", hglb); <br> <br>        REPORT_ERROR(buf); <br> <br>        return(hglbMem); <br>    } <br> <br>    hglbMem = GlobalReAlloc(hglb, cbBytes, fuFlags); <br> <br>    if(hglbMem == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",cbBytes,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,cbBytes); <br>    } <br> <br>    return(hglbMem); <br>} <br> <br>//$--EDKDBG_GlobalFree---------------------------------------------------------- <br>//  Wrapper for GlobalFree(). <br>// ----------------------------------------------------------------------------- <br>HGLOBAL EDKDBG_GlobalFree(              // RETURNS: nothing <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN HGLOBAL hglb)                    // pointer to memory block <br>{ <br>    LPVOID  lpv           = NULL; <br>    CHAR    buf[BUFSIZ+1] = {0}; <br>    UINT    gflags        = 0; <br>    HGLOBAL hglbMem       = 0; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    gflags = GlobalFlags(hglb); <br> <br>    if(gflags == GMEM_INVALID_HANDLE) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid handle [%08lx]\n", hglb); <br> <br>        REPORT_ERROR(buf); <br> <br>        SetLastError(ERROR_INVALID_HANDLE); <br> <br>        return(hglb); <br>    } <br> <br>    if(hglb == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid handle [%08lx]\n", hglb); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,0); <br>    } <br> <br>    hglbMem = GlobalFree(hglb); <br> <br>    if(hglbMem != NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: deallocation failed [%08lx]\n", GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,0); <br>    } <br> <br>    return(hglbMem); <br>} <br> <br>//$--EDKDBG_LocalAlloc---------------------------------------------------------- <br>//  Wrapper for LocalAlloc(). <br>// ----------------------------------------------------------------------------- <br>HGLOBAL EDKDBG_LocalAlloc(              // RETURNS: pointer to memory block <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN UINT  fuFlags,                   // allocation flags <br>    IN DWORD dwSize)                    // size of memory block <br>{ <br>    LPVOID  lpv           = NULL; <br>    HGLOBAL hglb          = NULL; <br>    CHAR    buf[BUFSIZ+1] = {0}; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    if((fuFlags != 0) &amp;&amp; (! (fuFlags &amp; LMEM_VALID_FLAGS))) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid allocation flags [%08lx]\n", fuFlags); <br> <br>        REPORT_ERROR(buf); <br>    } <br> <br>    hglb = LocalAlloc(fuFlags, dwSize); <br> <br>    if(hglb == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",dwSize,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,dwSize); <br>    } <br> <br>    return(hglb); <br>} <br> <br>//$--EDKDBG_LocalReAlloc-------------------------------------------------------- <br>//  Wrapper for LocalReAlloc(). <br>// ----------------------------------------------------------------------------- <br>HGLOBAL EDKDBG_LocalReAlloc(            // RETURNS: pointer to memory block <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN HGLOBAL hglb,                    // pointer to memory block <br>    IN DWORD cbBytes,                   // new size of memory block <br>    IN UINT  fuFlags)                   // allocation flags <br>{ <br>    LPVOID  lpv           = NULL; <br>    CHAR    buf[BUFSIZ+1] = {0}; <br>    UINT    gflags        = 0; <br>    HGLOBAL hglbMem       = 0; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    if((fuFlags != 0) &amp;&amp; (! (fuFlags &amp; LMEM_VALID_FLAGS))) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid allocation flags [%08lx]\n", fuFlags); <br> <br>        REPORT_ERROR(buf); <br>    } <br> <br>    gflags = LocalFlags(hglb); <br> <br>    if(gflags == LMEM_INVALID_HANDLE) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid handle [%08lx]\n", hglb); <br> <br>        REPORT_ERROR(buf); <br> <br>        return(hglbMem); <br>    } <br> <br>    hglbMem = LocalReAlloc(hglb, cbBytes, fuFlags); <br> <br>    if(hglbMem == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: allocation of [%lu] bytes failed [%08lx]\n",cbBytes,GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,cbBytes); <br>    } <br> <br>    return(hglbMem); <br>} <br> <br>//$--EDKDBG_LocalFree----------------------------------------------------------- <br>//  Wrapper for LocalFree(). <br>// ----------------------------------------------------------------------------- <br>HGLOBAL EDKDBG_LocalFree(               // RETURNS: nothing <br>    IN ULONG ulLine,                    // line number <br>    IN LPSTR lpszFile,                  // file name <br>    IN HGLOBAL hglb)                    // pointer to memory block <br>{ <br>    LPVOID  lpv           = NULL; <br>    CHAR    buf[BUFSIZ+1] = {0}; <br>    UINT    gflags        = 0; <br>    HGLOBAL hglbMem       = 0; <br> <br>    _DebugHeapCheck(ulLine, lpszFile); <br> <br>    gflags = LocalFlags(hglb); <br> <br>    if(gflags == LMEM_INVALID_HANDLE) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid handle [%08lx]\n", hglb); <br> <br>        REPORT_ERROR(buf); <br> <br>        SetLastError(ERROR_INVALID_HANDLE); <br> <br>        return(hglb); <br>    } <br> <br>    if(hglb == NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: invalid handle [%08lx]\n", hglb); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,0); <br>    } <br> <br>    hglbMem = LocalFree(hglb); <br> <br>    if(hglbMem != NULL) <br>    { <br>    _snprintf(buf,BUFSIZ,"MEMORY: deallocation failed [%08lx]\n", GetLastError()); <br> <br>        REPORT_ERROR(buf); <br> <br>        _DebugMemoryStatus(ulLine,lpszFile,0); <br>    } <br> <br>    return(hglbMem); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
