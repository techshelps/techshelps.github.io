<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EDKLOG.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1826"></a>EDKLOG.C</h2>
<pre><code>// --edklog.c------------------------------------------------------------------- <br>// <br>//  Functions to log debugging information in DEBUG builds. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br>  <br>#define _PRIVATE_EDKDEBUG_H <br>#define _PRIVATE_MEMORY_H <br>#include "edk.h" <br> <br>#define REPORT_ERROR(x) \ <br>    _WriteDebugString( \ <br>        "***** error: %s, %lu, [%08lX] *****\n", __FILE__,__LINE__,(x)) <br> <br>#define DECL_FENCE(_name)   ULONG _dbg_##_name = 0xAAAAAAAA <br> <br>#define TEST_FENCE(_name)   \ <br>{ \ <br>    if(_dbg_##_name != 0xAAAAAAAA) \ <br>    { \ <br>        _WriteDebugString( \ <br>            "***** error: %s, %lu, memory overwrite at tag '%s'! *****\n", \ <br>            __FILE__,__LINE__,#_name); \ <br>    } \ <br>} <br> <br>DECL_FENCE(EDKDEBUG1); <br> <br>static BOOL fDebugLevel[D_LAST] = <br>    { <br>        TRUE, <br>        TRUE, <br>        TRUE, <br>        TRUE, <br>        TRUE, <br>        TRUE, <br>        TRUE <br>    }; <br> <br>DECL_FENCE(EDKDEBUG2); <br> <br>static BOOL             IsAssertOff = TRUE; <br> <br>DECL_FENCE(EDKDEBUG3); <br> <br>static BOOL             IsDebugOff  = FALSE; <br> <br>DECL_FENCE(EDKDEBUG4); <br> <br>static CHAR szFileName[MAX_PATH+1]  = {0}; <br> <br>DECL_FENCE(EDKDEBUG5); <br> <br>static FILE*            fp          = NULL; <br> <br>DECL_FENCE(EDKDEBUG6); <br> <br>static CRITICAL_SECTION cs          = {0}; <br> <br>DECL_FENCE(EDKDEBUG7); <br> <br>#define TEST_ALL_FENCES \ <br>{ \ <br>    TEST_FENCE(EDKDEBUG1); \ <br>    TEST_FENCE(EDKDEBUG2); \ <br>    TEST_FENCE(EDKDEBUG3); \ <br>    TEST_FENCE(EDKDEBUG4); \ <br>    TEST_FENCE(EDKDEBUG5); \ <br>    TEST_FENCE(EDKDEBUG6); \ <br>    TEST_FENCE(EDKDEBUG7); \ <br>} <br> <br>//$--_WriteDebugString---------------------------------------------------------- <br>// <br>//  Write a string to the debugger output window. <br>//   <br>// ----------------------------------------------------------------------------- <br>void _WriteDebugString(                 // RETURNS: nothing <br>    IN LPSTR lpszFormat,                // format string <br>    ...)                                // arguments <br>{ <br>    char lpsz[BUFSIZ+1] = {0}; <br>    va_list va_alist    = {0}; <br> <br>    SetLastError(ERROR_SUCCESS); <br> <br>    __try <br>    { <br>        va_start( va_alist, lpszFormat ); <br> <br>        _vsnprintf( lpsz, BUFSIZ, lpszFormat, va_alist ); <br> <br>        va_end( va_alist ); <br> <br>        OutputDebugString(lpsz); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br>    } <br>} <br> <br>//$--_StatusShowAssert---------------------------------------------------------- <br>// <br>//  Status of the assert prompt. <br>//   <br>// ----------------------------------------------------------------------------- <br>BOOL _StatusShowAssert(             // RETURNS: TRUE if assert prompt <br>    void)                           // no arguments <br>{ <br>    TEST_ALL_FENCES // Check for memory overwrites in global variables <br> <br>    return(!IsAssertOff); <br>} <br> <br>//$--_StatusDebugFile----------------------------------------------------------- <br>// <br>//  Status of the debug log file. <br>//   <br>// ----------------------------------------------------------------------------- <br>BOOL _StatusDebugFile(              // RETURNS: TRUE if debug log available <br>    void)                           // no arguments <br>{ <br>    BOOL fStatus = TRUE; <br> <br>    TEST_ALL_FENCES // Check for memory overwrites in global variables <br> <br>    if((fp == NULL) || (IsDebugOff == TRUE)) <br>    { <br>        fStatus = FALSE; <br>    } <br> <br>    return(fStatus); <br>} <br> <br>//$--_StatusDebugLevel---------------------------------------------------------- <br>// <br>//  Status of the debug level. <br>//   <br>// ----------------------------------------------------------------------------- <br>BOOL _StatusDebugLevel(             // RETURNS: nothing <br>    IN DEBUGLEVEL level)            // debug level <br>{ <br>    BOOL fStatus = TRUE; <br> <br>    TEST_ALL_FENCES // Check for memory overwrites in global variables <br> <br>    if( (_StatusDebugFile() == FALSE) || <br>        (level &gt;= D_LAST) || <br>        (fDebugLevel[(int)level] == FALSE)) <br>    { <br> <br>        fStatus = FALSE; <br>    } <br> <br>    return(fStatus); <br>} <br> <br>//$--_LockDebugFile------------------------------------------------------------- <br>// <br>//  Lock the debug log file. <br>//   <br>// ----------------------------------------------------------------------------- <br>void _LockDebugFile(                // RETURNS: nothing <br>    void)                           // no arguments <br>{ <br>    CHAR sz[BUFSIZ+1] = {0}; <br> <br>    TEST_ALL_FENCES // Check for memory overwrites in global variables <br> <br>    __try <br>    { <br>        EnterCriticalSection(&amp;cs); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        REPORT_ERROR(_exception_code()); <br>    } <br>} <br> <br>//$--_UnlockDebugFile----------------------------------------------------------- <br>// <br>//  Unlock the debug log file. <br>//   <br>// ----------------------------------------------------------------------------- <br>void _UnlockDebugFile(              // RETURNS: nothing <br>    void)                           // no arguments <br>{ <br>    CHAR sz[BUFSIZ+1] = {0}; <br> <br>    TEST_ALL_FENCES // Check for memory overwrites in global variables <br> <br>    __try <br>    { <br>        LeaveCriticalSection(&amp;cs); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        REPORT_ERROR(_exception_code()); <br>    } <br>} <br> <br>//$--_WriteDebugFile------------------------------------------------------------ <br>// <br>//  Write to the debug log file. <br>//   <br>// ----------------------------------------------------------------------------- <br>void _WriteDebugFile(               // RETURNS: nothing <br>    IN LPSTR lpszFormat,            // format string <br>    ...)                            // arguments <br>{ <br>    va_list va_alist   = {0}; <br> <br>    TEST_ALL_FENCES // Check for memory overwrites in global variables <br> <br>    if(fp == NULL) <br>    { <br>        REPORT_ERROR(ERROR_INVALID_PARAMETER); <br>        goto cleanup; <br>    } <br> <br>    __try <br>    { <br>        EnterCriticalSection(&amp;cs); <br> <br>        __try <br>        { <br>            va_start( va_alist, lpszFormat ); <br> <br>            vfprintf( fp, lpszFormat, va_alist ); <br>     <br>            va_end( va_alist ); <br> <br>            fflush(fp); <br>        } <br>        __except(EXCEPTION_EXECUTE_HANDLER) <br>        { <br>            REPORT_ERROR(_exception_code()); <br>        } <br> <br>        LeaveCriticalSection(&amp;cs); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        REPORT_ERROR(_exception_code()); <br>    } <br> <br>cleanup: <br> <br>    return; <br>} <br> <br>//$--SetDebugLevel-------------------------------------------------------------- <br>//  Set debug levels to log. <br>// ----------------------------------------------------------------------------- <br>static void SetDebugLevel(              // RETURNS: nothing <br>    IN LPSTR lpszLevel)                 // textized debug level <br>{ <br>    int   level         = 0; <br>    char* lpszToken     = NULL; <br>    char  buf[BUFSIZ+1] = {0}; <br> <br>    TEST_ALL_FENCES // Check for memory overwrites in global variables <br> <br>    if(lpszLevel == NULL) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if(IsBadStringPtrA(lpszLevel, INFINITE)) <br>    { <br>        REPORT_ERROR(ERROR_INVALID_PARAMETER); <br>        goto cleanup; <br>    } <br> <br>    IsDebugOff = TRUE; <br> <br>    for(level = 0; level &lt; D_LAST; level++) <br>    { <br>        // Turn the debug level off <br>        fDebugLevel[level] = FALSE; <br>    } <br> <br>    strncpy(buf, lpszLevel, BUFSIZ); <br>    buf[BUFSIZ] = 0; <br> <br>    lpszToken = strtok(buf,", "); <br> <br>    while(lpszToken != NULL) <br>    { <br>        if(!_stricmp("D_PUBLIC", lpszToken)) <br>        { <br>            // Turn the debug level on <br>            fDebugLevel[(int)D_PUBLIC] = TRUE; IsDebugOff = FALSE; <br>        } <br>        else if(!_stricmp("D_PRIVATE", lpszToken)) <br>        { <br>            // Turn the debug level on <br>            fDebugLevel[(int)D_PRIVATE] = TRUE; IsDebugOff = FALSE; <br>        } <br>        else if(!_stricmp("D_ERROR", lpszToken)) <br>        { <br>            // Turn the debug level on <br>            fDebugLevel[(int)D_ERROR] = TRUE; IsDebugOff = FALSE; <br>        }    <br>        else if(!_stricmp("D_WARNING", lpszToken)) <br>        { <br>            // Turn the debug level on <br>            fDebugLevel[(int)D_WARNING] = TRUE; IsDebugOff = FALSE; <br>        }    <br>        else if(!_stricmp("D_STATUS", lpszToken)) <br>        { <br>            // Turn the debug level on <br>            fDebugLevel[(int)D_STATUS] = TRUE; IsDebugOff = FALSE; <br>        }    <br>        else if(!_stricmp("D_ACTION", lpszToken)) <br>        { <br>            // Turn the debug level on <br>            fDebugLevel[(int)D_ACTION] = TRUE; IsDebugOff = FALSE; <br>        }    <br>        else if(!_stricmp("D_OTHER", lpszToken)) <br>        { <br>            // Turn the debug level on <br>            fDebugLevel[(int)D_OTHER] = TRUE; IsDebugOff = FALSE; <br>        } <br> <br>        lpszToken = strtok(NULL, ", "); <br>    } <br> <br>cleanup: <br> <br>    return; <br>} <br> <br>//$--_InitDebugFile------------------------------------------------------------- <br>// <br>//  Initialize the debug log file. <br>//   <br>// ----------------------------------------------------------------------------- <br>void _InitDebugFile(                // RETURNS: nothing <br>    void)                           // no arguments <br>{ <br>    HANDLE hT                      = NULL; <br>    DWORD  dwT                     = 0; <br>    CHAR   szMutexName[MAX_PATH+1] = {0}; <br>CHAR   szTempPath[MAX_PATH+1]  = {0};    // temporary file name path <br> <br>    TEST_ALL_FENCES // Check for memory overwrites in global variables <br> <br>    if((fp == NULL) &amp;&amp; (IsDebugOff == FALSE)) <br>    { <br>        _snprintf(szMutexName, MAX_PATH, "EDK%08lX", GetCurrentProcessId()); <br> <br>        hT = CreateMutex(NULL, FALSE, szMutexName); <br> <br>        if(hT == NULL) <br>        { <br>            REPORT_ERROR(GetLastError()); <br>            return; <br>        } <br> <br>        if((hT != NULL) &amp;&amp; (GetLastError() == ERROR_ALREADY_EXISTS)) <br>        { <br>            __try <br>            { <br>                dwT = WaitForSingleObject(hT, INFINITE); <br> <br>                if((dwT == WAIT_OBJECT_0) || (dwT == WAIT_ABANDONED)) <br>                { <br>                    ReleaseMutex(hT); <br>                } <br> <br>                CloseHandle(hT); <br>            } <br>            __except(EXCEPTION_EXECUTE_HANDLER) <br>            { <br>                REPORT_ERROR(_exception_code()); <br>            } <br> <br>            return; <br>        } <br> <br>        dwT = WaitForSingleObject(hT, INFINITE); <br> <br>        if((dwT == WAIT_OBJECT_0) || (dwT == WAIT_ABANDONED)) <br>        { <br>            LPSTR lpsz = NULL; <br> <br>            InitializeCriticalSection(&amp;cs); <br> <br>            SetDebugLevel(getenv("EDK_DEBUG")); <br> <br>            if(IsDebugOff == FALSE) <br>            { <br>                lpsz = getenv("EDK_DEBUG_FILE"); <br> <br>                if(lpsz == NULL) <br>                { <br>// Create a file in the temporary file directory <br>// with name equal to "EDKxxx.log". <br>dwT = GetTempPath( <br>MAX_PATH,// length of buffer <br>szTempPath);// string buffer <br> <br>if ( dwT != 0 ) <br>{ <br>                        // If TEMP has been removed, we'll create it <br>                        (VOID)CreateDirectory( <br>                            szTempPath, <br>                            NULL); <br> <br>dwT = GetTempFileName( <br>szTempPath,// temporary file path <br>EDK_LOG_FILE_PREFIX,// log file prefix <br>0,// creates unique file name <br>szFileName);// file name buffer <br> <br>if ( dwT != 0 ) <br>{ <br>                            UINT    iFileSuffix = 0; <br> <br>                            // Delete the edk*.tmp file created as a side <br>                            // effect of GetTempFileName(). <br>                            (VOID)DeleteFile(szFileName); <br>     <br>                            // Replace .TMP suffix with .LOG suffix. <br>                            iFileSuffix = cbStrLenA(szFileName) - sizeof("TMP"); <br>                            lstrcpyA( &amp;szFileName[iFileSuffix], EDK_LOG_FILE_SUFFIX); <br>} <br>                        else <br>                        { <br>REPORT_ERROR(GetLastError()); <br>                        } <br>} <br>else <br>{ <br>REPORT_ERROR(GetLastError()); <br>} <br>                } <br>                else <br>                { <br>                    strncpy((char *)szFileName, lpsz, MAX_PATH); <br>                } <br> <br>                szFileName[MAX_PATH] = 0; <br> <br>                if((fp = fopen(szFileName, "w")) == NULL) <br>                { <br>                    REPORT_ERROR(ERROR_INVALID_PARAMETER); <br>                } <br>            } <br> <br>            lpsz = getenv("EDK_ASSERT"); <br> <br>            if((lpsz != NULL) &amp;&amp; (lstrcmpiA(lpsz, "TRUE") == 0)) <br>            { <br>                IsAssertOff = FALSE; <br>            } <br> <br>            ReleaseMutex(hT); <br>        } <br>        else <br>        { <br>            REPORT_ERROR(GetLastError()); <br>        } <br> <br>        CloseHandle(hT); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
