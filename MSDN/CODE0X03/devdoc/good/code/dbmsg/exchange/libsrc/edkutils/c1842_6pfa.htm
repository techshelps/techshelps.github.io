<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EDKUTILS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1846"></a>EDKUTILS.C</h2>
<pre><code><br>//  <br>//  EDK utility functions. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include "edkutils.chk" <br> <br>//$--_HrWriteFile--------------------------------------------------------------- <br>//  Transfer contents from a given memory location &amp; length to an open file. <br>// ----------------------------------------------------------------------------- <br>HRESULT _HrWriteFile(  <br>    IN HANDLE hFile,                    // file handle <br>    IN ULONG cbmem,                     // count of bytes of memory <br>    IN LPBYTE lpbmem)                   // pointer to memory <br>{ <br>    HRESULT hr             = NOERROR; <br>    DWORD   dwBytesWritten = 0; <br>    BOOL    fStatus        = FALSE; <br> <br>    DEBUGPUBLIC("_HrWriteFile()"); <br> <br>    hr = CHK__HrWriteFile( <br>        hFile, <br>        cbmem, <br>        lpbmem); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    fStatus = WriteFile( <br>        hFile, <br>        lpbmem, <br>        cbmem, <br>        &amp;dwBytesWritten, <br>        NULL); <br> <br>    if(fStatus == FALSE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Check if out of disk space <br>    if(dwBytesWritten != cbmem) <br>    { <br>        hr = HR_LOG(MAPI_E_NOT_ENOUGH_DISK); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCreateDirEntryId------------------------------------------------------ <br>//  Create a directory entry ID given the address of the object <br>//  in the directory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateDirEntryId(          // RETURNS: return code <br>    IN LPSTR lpszAddress,               // pointer to address <br>    OUT ULONG *lpcbeid,                 // count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)              // pointer to entry ID <br>{ <br>    HRESULT hr       = NOERROR; <br>    SCODE   sc       = 0; <br>    LPBYTE  lpdireid = NULL; <br>    ULONG   cbdireid = 0; <br>    BYTE    muid[16] = MUIDEMSAB; <br>    ULONG   cbAddr   = 0; <br> <br>    DEBUGPUBLIC("HrCreateDirEntryId()"); <br> <br>    hr = CHK_HrCreateDirEntryId( <br>        lpszAddress, <br>        lpcbeid, <br>        lppeid); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcbeid = 0; <br>    *lppeid  = NULL; <br> <br>    cbAddr = cbStrLen(lpszAddress); <br> <br>    cbdireid = sizeof(DIR_ENTRYID) + cbAddr; <br> <br>    sc = MAPIAllocateBuffer(cbdireid, (void **)&amp;lpdireid); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br>    else <br>    { <br>        ZeroMemory(lpdireid, cbdireid); <br> <br>        ((LPDIR_ENTRYID)lpdireid)-&gt;ulVersion = EMS_VERSION; <br> <br>        CopyMemory( <br>            (LPBYTE)&amp;((LPDIR_ENTRYID)lpdireid)-&gt;muid, <br>            muid, <br>            sizeof(muid)); <br> <br>        CopyMemory( <br>            lpdireid + sizeof(DIR_ENTRYID), <br>            (LPBYTE)lpszAddress, <br>            cbAddr); <br>    } <br> <br>    *lpcbeid = cbdireid; <br>    *lppeid  = (LPENTRYID)lpdireid; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--_HrMemoryToFile---------------------------------------------------------- <br>//  Transfer contents from a given memory location &amp; length to a given file. <br>// ----------------------------------------------------------------------------- <br>HRESULT _HrMemoryToFile(              // RETURNS: return code <br>    IN ULONG cbmem,                     // count of bytes of memory <br>    IN LPBYTE lpbmem,                   // pointer to memory <br>    IN LPSTR lpszFilename)             // pointer to destination file name <br>{ <br>    HRESULT hr             = NOERROR; <br>    HANDLE  hFile          = INVALID_HANDLE_VALUE; <br>    DWORD   dwBytesWritten = 0; <br> <br>    DEBUGPUBLIC("_HrMemoryToFile()"); <br> <br>    hr = CHK__HrMemoryToFile( <br>        cbmem, <br>        lpbmem, <br>        lpszFilename); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hFile = CreateFile( <br>        lpszFilename, <br>        GENERIC_WRITE, <br>        0, <br>        NULL, <br>        CREATE_ALWAYS, <br>        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, <br>        NULL); <br> <br>    if(hFile == INVALID_HANDLE_VALUE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = _HrWriteFile(hFile, cbmem, lpbmem); <br> <br>cleanup: <br> <br>    // Close the file <br>    if(hFile != INVALID_HANDLE_VALUE) <br>    { <br>        if(CloseHandle(hFile) == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--_HrFileToMemory---------------------------------------------------------- <br>//  Transfer contents from a given file to memory. <br>// ----------------------------------------------------------------------------- <br>HRESULT _HrFileToMemory(              // RETURNS: return code <br>    IN LPSTR lpszFilename,             // pointer to source file name <br>    OUT ULONG *lpcbmem,                 // pointer to count of bytes of memory <br>                                        // variable <br>    OUT LPBYTE *lppbmem)                // pointer to bytes of memory address <br>                                        // variable <br>{ <br>    HRESULT        hr          = NOERROR; <br>    SCODE          sc          = 0; <br>    HFILE          hFile       = HFILE_ERROR; <br>    OFSTRUCT       ofStruct    = {0}; <br>    DWORD          dwBytesRead = 0; <br>    ULARGE_INTEGER ll          = {0,0}; <br>    ULONG          ulFileSize  = 0; <br>    ULONG          ulMemSize   = 0; <br>    BOOL           fStatus     = FALSE; <br> <br>    DEBUGPUBLIC("_HrFileToMemory()"); <br> <br>    hr = CHK__HrFileToMemory( <br>        lpszFilename, <br>        lpcbmem, <br>        lppbmem); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcbmem = 0; <br>    *lppbmem = NULL; <br> <br>    hFile = OpenFile( <br>        lpszFilename, <br>        &amp;ofStruct, <br>        OF_READ); <br> <br>    if(hFile == HFILE_ERROR) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get file size <br>    if((ulFileSize = GetFileSize((HANDLE)hFile, NULL)) == (DWORD)HFILE_ERROR) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Allocate the memory for the file contents <br>    ulMemSize = ulFileSize + 2 * sizeof(wchar_t); <br> <br>    sc = MAPIAllocateBuffer(ulMemSize, (void **)lppbmem); <br> <br>    // An error occured allocating the block buffer <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Initialize block of memory <br>    ZeroMemory(*lppbmem, ulMemSize); <br> <br>    // Read the property value into memory <br>    fStatus = ReadFile( <br>        (HANDLE)hFile, <br>        *lppbmem, <br>        ulFileSize, <br>        &amp;dwBytesRead, <br>        NULL); <br> <br>    if(fStatus == FALSE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Check if the entire file was read <br>    if(dwBytesRead != ulFileSize) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    *lpcbmem = ulFileSize; <br> <br>cleanup: <br> <br>    // Close the file <br>    if(hFile != HFILE_ERROR) <br>    { <br>        if(CloseHandle((HANDLE)hFile) == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppbmem); <br> <br>        *lpcbmem = 0; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceStatus------------------------------------------------------ <br>//  Get the current state of a service on a given machine. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceStatus(          // RETURNS: return code <br>    IN LPSTR lpszMachineName,          // machine name <br>    IN LPSTR lpszServiceName,          // service name <br>    OUT DWORD *lpdwCurrentState)        // current state <br>{ <br>    HRESULT         hr               = NOERROR; <br>    SC_HANDLE       schSCManager     = NULL; <br>    SC_HANDLE       schService       = NULL; <br>    DWORD           fdwDesiredAccess = 0; <br>    SERVICE_STATUS  ssServiceStatus  = {0}; <br>    BOOL            fRet             = FALSE; <br> <br>    hr = CHK_HrGetServiceStatus( <br>        lpszMachineName, <br>        lpszServiceName, <br>        lpdwCurrentState); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpdwCurrentState = 0; <br> <br>    fdwDesiredAccess = GENERIC_READ; <br> <br>    schSCManager = OpenSCManager( <br>        lpszMachineName,    // address of machine name string  <br>        NULL,               // address of database name string  <br>        fdwDesiredAccess    // type of access  <br>    ); <br> <br>    if(schSCManager == NULL) <br>    { <br>        hr = HR_LOG(GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    schService = OpenService( <br>        schSCManager,       // handle of service control manager database   <br>        lpszServiceName,    // address of name of service to start  <br>        fdwDesiredAccess    // type of access to service  <br>    ); <br> <br>    if(schService == NULL) <br>    { <br>        hr = HR_LOG(GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    fRet = QueryServiceStatus( <br>        schService,         // handle of service  <br>        &amp;ssServiceStatus    // address of service status structure   <br>    ); <br> <br>    if(fRet == FALSE) <br>    { <br>        hr = HR_LOG(GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    *lpdwCurrentState = ssServiceStatus.dwCurrentState; <br> <br>cleanup: <br> <br>    CloseServiceHandle(schService); <br>    CloseServiceHandle(schSCManager); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetExchangeStatus----------------------------------------------------- <br>//  Get the current state of the Exchange server on a given machine. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetExchangeStatus(         // RETURNS: return code <br>    IN LPSTR lpszMachineName,          // machine name <br>    OUT DWORD *lpdwService,             // service <br>    OUT DWORD *lpdwCurrentState)        // current state <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    hr = CHK_HrGetExchangeStatus( <br>        lpszMachineName, <br>        lpdwService, <br>        lpdwCurrentState); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpdwService = 0; <br>    *lpdwCurrentState = 0; <br> <br>    hr = HrGetServiceStatus( <br>        lpszMachineName, <br>        "MSExchangeSA", <br>        lpdwCurrentState); <br> <br>    if(FAILED(hr) || (*lpdwCurrentState != SERVICE_RUNNING)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        *lpdwService = EXCHANGE_SA; <br>        goto cleanup; <br>    } <br> <br>    hr = HrGetServiceStatus( <br>        lpszMachineName, <br>        "MSExchangeDS", <br>        lpdwCurrentState); <br> <br>    if(FAILED(hr) || (*lpdwCurrentState != SERVICE_RUNNING)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        *lpdwService = EXCHANGE_DS; <br>        goto cleanup; <br>    } <br> <br>    hr = HrGetServiceStatus( <br>        lpszMachineName, <br>        "MSExchangeMTA", <br>        lpdwCurrentState); <br> <br>    if(FAILED(hr) || (*lpdwCurrentState != SERVICE_RUNNING)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        *lpdwService = EXCHANGE_MTA; <br>        goto cleanup; <br>    } <br> <br>    hr = HrGetServiceStatus( <br>        lpszMachineName, <br>        "MSExchangeIS", <br>        lpdwCurrentState); <br> <br>    if(FAILED(hr) || (*lpdwCurrentState != SERVICE_RUNNING)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        *lpdwService = EXCHANGE_IS; <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetExchangeServiceStatus---------------------------------------------- <br>//  Get the current state of an Exchange service on a given machine. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetExchangeServiceStatus(  // RETURNS: return code <br>    IN LPSTR lpszMachineName,          // machine name <br>    IN  DWORD dwService,                // service <br>    OUT DWORD *lpdwCurrentState)        // current state <br>{ <br>    HRESULT hr              = NOERROR; <br>    LPSTR  lpszServiceName = NULL; <br> <br>    hr = CHK_HrGetExchangeServiceStatus( <br>        lpszMachineName, <br>        dwService, <br>        lpdwCurrentState); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpdwCurrentState = 0; <br> <br>    switch(dwService) <br>    { <br>    case EXCHANGE_DS: <br>        lpszServiceName = "MSExchangeDS"; <br>        break; <br>    case EXCHANGE_IS: <br>        lpszServiceName = "MSExchangeIS"; <br>        break; <br>    case EXCHANGE_MTA: <br>        lpszServiceName = "MSExchangeMTA"; <br>        break; <br>    case EXCHANGE_SA: <br>        lpszServiceName = "MSExchangeSA"; <br>        break; <br>    default: <br>        hr = HR_LOG(E_INVALIDARG); <br> <br>        *lpdwCurrentState = SERVICE_STOPPED; <br>        goto cleanup; <br>    } <br> <br>    hr = HrGetServiceStatus( <br>        lpszMachineName, <br>        lpszServiceName, <br>        lpdwCurrentState); <br> <br>    if(FAILED(hr) || (*lpdwCurrentState != SERVICE_RUNNING)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--FMachineExists--------------------------------------------------------- <br>//  Returns TRUE if the computer exists. <br>// ----------------------------------------------------------------------------- <br>BOOL FMachineExists(                // RETURNS: TRUE/FALSE <br>    IN LPSTR  lpszComputerName)        // address of name of remote computer  <br>{ <br>    HRESULT hr       = NOERROR; <br>    BOOL    fRet     = TRUE; <br>    LONG    lRet     = 0; <br>    HKEY    hkResult = NULL; <br> <br>    hr = CHK_HrEDKComputerExists(lpszComputerName); <br> <br>    if(FAILED(hr)) <br>        return(FALSE); <br> <br>    lRet = RegConnectRegistry( <br>        lpszComputerName, <br>        HKEY_LOCAL_MACHINE, <br>        &amp;hkResult); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        fRet = FALSE; <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RegCloseKey(hkResult); <br> <br>    return(fRet); <br>} <br> <br>//$--_HrFindFile-------------------------------------------------------------- <br>//  Find a file in a directory subtree. <br>// ----------------------------------------------------------------------------- <br>HRESULT _HrFindFile(                      // RETURNS: return code <br>    IN LPSTR lpszInPathName,               // starting path name <br>    IN LPSTR lpszInFileName,               // file name <br>    OUT LPSTR lpszOutPathName)             // path name where file first found <br>{ <br>    HRESULT         hr                     = NOERROR; <br>    HANDLE          hFile                  = INVALID_HANDLE_VALUE; <br>    HANDLE          hDir                   = INVALID_HANDLE_VALUE; <br>    CHAR           szPathName[MAX_PATH+1] = {0}; <br>    CHAR           szFileName[MAX_PATH+1] = {0}; <br>    WIN32_FIND_DATA wfdFile                = {0}; <br>    WIN32_FIND_DATA wfdDir                 = {0}; <br> <br>    DEBUGPUBLIC("_HrFindFile()"); <br> <br>    wsprintf( <br>        szFileName, "%s\\%s", lpszInPathName, lpszInFileName); <br> <br>    hFile = FindFirstFile(szFileName, &amp;wfdFile); <br> <br>    if(hFile != INVALID_HANDLE_VALUE) <br>    { <br>        lstrcpy(lpszOutPathName, lpszInPathName); <br>        goto cleanup; <br>    } <br> <br>    wsprintf( <br>        szFileName, "%s\\%s", lpszInPathName, "*.*"); <br> <br>    hDir = FindFirstFile(szFileName, &amp;wfdDir); <br> <br>    if(hDir != INVALID_HANDLE_VALUE) <br>    { <br>        while(1) <br>        { <br>            if(!lstrcmp(wfdDir.cFileName, ".")) <br>            { <br>                ; // skip current directory <br>            } <br>            else if(!lstrcmp(wfdDir.cFileName, "..")) <br>            { <br>                ; // skip parent directory <br>            } <br>            else if(wfdDir.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY) <br>            { <br>                wsprintf( <br>                    szPathName, "%s\\%s", lpszInPathName, wfdDir.cFileName); <br> <br>                hr = _HrFindFile( <br>                    szPathName, <br>                    lpszInFileName, <br>                    lpszOutPathName); <br> <br>                if(SUCCEEDED(hr)) <br>                { <br>                    goto cleanup; <br>                } <br>            } <br> <br>            if(! FindNextFile(hDir, &amp;wfdDir)) <br>            { <br>                hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>                break; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>cleanup: <br> <br>    if(hFile != INVALID_HANDLE_VALUE) <br>    { <br>        FindClose(hFile); <br>    } <br> <br>    if(hDir != INVALID_HANDLE_VALUE) <br>    { <br>        FindClose(hDir); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--GetSystemEnvironmentVariable----------------------------------------------- <br>//  Gets a system environment variable. <br>// ----------------------------------------------------------------------------- <br>DWORD GetSystemEnvironmentVariable( // RETURNS: size of value <br>    IN LPSTR  lpszName,           // address of environment variable name  <br>    OUT LPSTR  lpszValue,          // address of buffer for variable value  <br>    OUT DWORD  cchValue)            // size of buffer, in characters  <br>{ <br>    HRESULT hr         = NOERROR; <br>    BOOL    fRet       = TRUE; <br>    LONG    lRet       = 0; <br>    HKEY    hKey       = INVALID_HANDLE_VALUE; <br>    DWORD   cbData     = 0; <br>    DWORD   dwType     = 0; <br> <br>    DEBUGPUBLIC("GetSystemEnvironmentVariable()"); <br> <br>    // <br>    //  Open the system Environment key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>        HKEY_LOCAL_MACHINE, <br>        "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment",  <br>        0, <br>        KEY_QUERY_VALUE, <br>        &amp;hKey); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        fRet = FALSE; <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Get size of value. <br>    // <br> <br>    lRet = RegQueryValueEx( <br>        hKey, <br>        lpszName, <br>        NULL, <br>        &amp;dwType, <br>        NULL, <br>        &amp;cbData); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        cbData = 0; <br>        goto cleanup; <br>    } <br> <br>    if(cchValue &lt; (cbData/sizeof(CHAR))) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Get the current value. <br>    // <br> <br>    lRet = RegQueryValueEx( <br>        hKey, <br>        lpszName, <br>        NULL, <br>        &amp;dwType, <br>        lpszValue, <br>        &amp;cbData); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        cbData = 0; <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(hKey != INVALID_HANDLE_VALUE) <br>    { <br>        RegCloseKey(hKey); <br>    } <br> <br>    return(cbData); <br>} <br> <br>//$--SetSystemEnvironmentVariable----------------------------------------------- <br>//  Sets a system environment variable permanently. <br>// ----------------------------------------------------------------------------- <br>BOOL SetSystemEnvironmentVariable(  // RETURNS: TRUE/FALSE <br>    IN LPCSTR  lpszName,           // address of environment variable name   <br>    IN LPCSTR  lpszValue)          // address of new value for variable  <br>{ <br>    HRESULT hr         = NOERROR; <br>    BOOL    fRet       = TRUE; <br>    LONG    lRet       = 0; <br>    HKEY    hKey       = INVALID_HANDLE_VALUE; <br>    DWORD   cbData     = 0; <br> <br>    DEBUGPUBLIC("SetSystemEnvironmentVariable()"); <br> <br>    // <br>    //  Open the system Environment key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>        HKEY_LOCAL_MACHINE, <br>        "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment",  <br>        0, <br>        KEY_SET_VALUE, <br>        &amp;hKey); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        fRet = FALSE; <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Set the Environment value. <br>    // <br> <br>    cbData = cbStrLen(lpszValue); <br> <br>    lRet = RegSetValueEx( <br>        hKey, <br>        lpszName, <br>        0, <br>        REG_EXPAND_SZ, <br>        (CONST BYTE *)lpszValue, <br>        cbData); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(hKey != INVALID_HANDLE_VALUE) <br>    { <br>        RegCloseKey(hKey); <br>    } <br> <br>    return(fRet); <br>} <br> <br>//$--GetUserEnvironmentVariable------------------------------------------------- <br>//  Gets a user environment variable. <br>// ----------------------------------------------------------------------------- <br>DWORD GetUserEnvironmentVariable(   // RETURNS: size of value <br>    IN LPSTR  lpszName,           // address of environment variable name  <br>    OUT LPSTR  lpszValue,          // address of buffer for variable value  <br>    OUT DWORD  cchValue)            // size of buffer, in characters  <br>{ <br>    HRESULT hr         = NOERROR; <br>    BOOL    fRet       = TRUE; <br>    LONG    lRet       = 0; <br>    HKEY    hKey       = INVALID_HANDLE_VALUE; <br>    DWORD   cbData     = 0; <br>    DWORD   dwType     = 0; <br> <br>    DEBUGPUBLIC("GetUserEnvironmentVariable()"); <br> <br>    // <br>    //  Open the user Environment key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>        HKEY_CURRENT_USER, <br>        "Environment",  <br>        0, <br>        KEY_QUERY_VALUE, <br>        &amp;hKey); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        fRet = FALSE; <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Get size of value. <br>    // <br> <br>    lRet = RegQueryValueEx( <br>        hKey, <br>        lpszName, <br>        NULL, <br>        &amp;dwType, <br>        NULL, <br>        &amp;cbData); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        cbData = 0; <br>        goto cleanup; <br>    } <br> <br>    if(cchValue &lt; (cbData/sizeof(CHAR))) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Get the current value. <br>    // <br> <br>    lRet = RegQueryValueEx( <br>        hKey, <br>        lpszName, <br>        NULL, <br>        &amp;dwType, <br>        lpszValue, <br>        &amp;cbData); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        cbData = 0; <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(hKey != INVALID_HANDLE_VALUE) <br>    { <br>        RegCloseKey(hKey); <br>    } <br> <br>    return(cbData); <br>} <br> <br>//$--SetUserEnvironmentVariable------------------------------------------------- <br>//  Sets a user environment variable permanently. <br>// ----------------------------------------------------------------------------- <br>BOOL SetUserEnvironmentVariable(    // RETURNS: TRUE/FALSE <br>    IN LPCSTR  lpszName,           // address of environment variable name   <br>    IN LPCSTR  lpszValue)          // address of new value for variable  <br>{ <br>    HRESULT hr         = NOERROR; <br>    BOOL    fRet       = TRUE; <br>    LONG    lRet       = 0; <br>    HKEY    hKey       = INVALID_HANDLE_VALUE; <br>    DWORD   cbData     = 0; <br> <br>    DEBUGPUBLIC("SetUserEnvironmentVariable()"); <br> <br>    // <br>    //  Open the user Environment key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>        HKEY_CURRENT_USER, <br>        "Environment",  <br>        0, <br>        KEY_SET_VALUE, <br>        &amp;hKey); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        fRet = FALSE; <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Set the Environment value. <br>    // <br> <br>    cbData = cbStrLen(lpszValue); <br> <br>    lRet = RegSetValueEx( <br>        hKey, <br>        lpszName, <br>        0, <br>        REG_EXPAND_SZ, <br>        (CONST BYTE *)lpszValue, <br>        cbData); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(hKey != INVALID_HANDLE_VALUE) <br>    { <br>        RegCloseKey(hKey); <br>    } <br> <br>    return(fRet); <br>} <br> <br>//$--IsDelimiter@--------------------------------------------------------------- <br>//  Returns TRUE if character is a delimiter. <br>//------------------------------------------------------------------------------ <br>__inline static BOOL IsDelimiterW( <br>    IN LPCWSTR lpszDelimiters,      // delimiters <br>    IN WCHAR ch)                    // character <br>{ <br>    LPCWSTR pch = lpszDelimiters; <br> <br>    if(pch) <br>    { <br>        while(*pch) <br>        { <br>            if(*pch == ch) <br>                return(TRUE); <br> <br>            pch++; <br>        } <br>    } <br> <br>    return(FALSE); <br>} <br> <br>__inline static BOOL IsDelimiterA( <br>    IN LPCSTR lpszDelimiters,       // delimiters <br>    IN CHAR ch)                     // character <br>{ <br>    LPCSTR pch = lpszDelimiters; <br> <br>    if(pch) <br>    { <br>        while(*pch) <br>        { <br>            if(*pch == ch) <br>                return(TRUE); <br> <br>            pch++; <br>        } <br>    } <br> <br>    return(FALSE); <br>} <br> <br>//$--HrStrTokAll@--------------------------------------------------------------- <br>//  Splits string lpsz at token separators and points elements of array <br>//  *lpppsz to string components. <br>//------------------------------------------------------------------------------ <br>HRESULT HrStrTokAllW(               // RETURNS: return code <br>    IN LPCWSTR lpsz,                // separated string <br>    IN LPCWSTR lpszEOT,             // pointer to string containing separators <br>    OUT ULONG * lpcpsz,             // count of string pointers <br>    OUT LPWSTR ** lpppsz)           // pointer to list of strings <br>{ <br>    HRESULT hr      = NOERROR; <br>    SCODE   sc      = 0; <br>    LPCWSTR pch     = NULL; <br>    LPBYTE  lpb     = NULL; <br>    LPWSTR *lppsz   = NULL; <br>    LPWSTR  pchNew  = NULL; <br>    ULONG   cToken  = 0; <br>    ULONG   cArrayBytes = 0; <br>    ULONG   cBytes  = 0; <br>    ULONG   csz     = 0; <br> <br>    DEBUGPUBLIC("HrStrTokAllW()"); <br> <br>    hr = CHK_HrStrTokAllW( <br>        lpsz, lpszEOT, lpcpsz, lpppsz); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcpsz = 0; <br>    *lpppsz = NULL; <br> <br>    // Skip to end if nothing to do <br>    if( *lpsz == 0) <br>        goto cleanup; <br> <br>    // Count the number of tokens. <br>    pch = lpsz; <br>    while( *pch) <br>    { <br>        // Skip adjacent delimiter characters <br>        while( IsDelimiterW( lpszEOT, *pch)) <br>            pch++; <br> <br>        if( *pch == 0) break; <br>     <br>        cToken++; <br> <br>        // Skip next token <br>        while( *pch &amp;&amp; !IsDelimiterW( lpszEOT, *pch)) <br>            pch++; <br>    } <br> <br>    // Array will consist of pointers followed by the tokenized string <br>    cArrayBytes = ( (cToken + 1) * (sizeof(LPWSTR) + MAX_ALIGN)); <br>    cBytes = cArrayBytes + cbStrLenW(lpsz); <br> <br>    sc = MAPIAllocateBuffer( cBytes, (PVOID*) &amp;lpb); <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    lppsz  = (LPWSTR*) lpb; <br>    pchNew = (LPWSTR) (lpb + cArrayBytes); <br> <br>    lstrcpyW( pchNew, lpsz); <br> <br>    while( *pchNew) <br>    { <br>        // remove and skip delimiter characters <br>        while( IsDelimiterW( lpszEOT, *pchNew)) <br>            *pchNew++ = 0; <br> <br>        if( *pchNew == 0) break; <br> <br>        lppsz[csz++] = pchNew; <br> <br>        // skip next token <br>        while( *pchNew &amp;&amp; !IsDelimiterW( lpszEOT, *pchNew)) <br>            pchNew++; <br>    } <br> <br>    lppsz[csz] = NULL; <br> <br>    ASSERTERROR( csz == cToken, "Error tokenizing string"); <br> <br>    *lpcpsz = csz; <br>    *lpppsz = lppsz; <br> <br>cleanup: <br>    if(FAILED(hr)) <br>        MAPIFREEBUFFER(lpb); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrStrTokAllA(               // RETURNS: return code <br>    IN LPCSTR lpsz,                 // separated string <br>    IN LPCSTR lpszEOT,              // pointer to string containing separators <br>    OUT ULONG * lpcpsz,             // count of string pointers <br>    OUT LPSTR ** lpppsz)            // pointer to list of strings <br>{ <br>    HRESULT hr      = NOERROR; <br>    SCODE   sc      = 0; <br>    LPCSTR  pch     = NULL; <br>    LPBYTE  lpb     = NULL; <br>    LPSTR  *lppsz   = NULL; <br>    LPSTR   pchNew  = NULL; <br>    ULONG   cToken  = 0; <br>    ULONG   cArrayBytes = 0; <br>    ULONG   cBytes  = 0; <br>    ULONG   csz     = 0; <br> <br>    DEBUGPUBLIC("HrStrTokAllA()"); <br> <br>    hr = CHK_HrStrTokAllA( <br>        lpsz, lpszEOT, lpcpsz, lpppsz); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcpsz = 0; <br>    *lpppsz = NULL; <br> <br>    // Skip to end if nothing to do <br>    if( *lpsz == 0) <br>        goto cleanup; <br> <br>    // Count the number of tokens. <br>    pch = lpsz; <br>    while( *pch) <br>    { <br>        // Skip adjacent delimiter characters <br>        while( IsDelimiterA( lpszEOT, *pch)) <br>            pch++; <br> <br>        if( *pch == 0) break; <br>     <br>        cToken++; <br> <br>        // Skip next token <br>        while( *pch &amp;&amp; !IsDelimiterA( lpszEOT, *pch)) <br>            pch++; <br>    } <br> <br>    // Array will consist of pointers followed by the tokenized string <br>    cArrayBytes = ( (cToken + 1) * (sizeof(LPSTR) + MAX_ALIGN)); <br>    cBytes = cArrayBytes + cbStrLenA(lpsz); <br> <br>    sc = MAPIAllocateBuffer( cBytes, (PVOID*) &amp;lpb); <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    lppsz  = (LPSTR*) lpb; <br>    pchNew = (LPSTR) (lpb + cArrayBytes); <br> <br>    lstrcpyA( pchNew, lpsz); <br> <br>    while( *pchNew) <br>    { <br>        // remove and skip delimiter characters <br>        while( IsDelimiterA( lpszEOT, *pchNew)) <br>            *pchNew++ = 0; <br> <br>        if( *pchNew == 0) break; <br> <br>        lppsz[csz++] = pchNew; </code></pre>
<p>
</p>
<pre><code><br>        // skip next token <br>        while( *pchNew &amp;&amp; !IsDelimiterA( lpszEOT, *pchNew)) <br>            pchNew++; <br>    } <br> <br>    lppsz[csz] = NULL; <br> <br>    ASSERTERROR( csz == cToken, "Error tokenizing string"); <br> <br>    *lpcpsz = csz; <br>    *lpppsz = lppsz; <br> <br>cleanup: <br>    if(FAILED(hr)) <br>        MAPIFREEBUFFER(lpb); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCreateProfileName----------------------------------------------------- <br>//  Create a unique profile name. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateProfileName(         // RETURNS: return code <br>    IN  LPSTR lpszPrefix,              // prefix of profile name <br>    IN  ULONG  cBufferSize,             // size of buffer in bytes <br>    IN OUT LPSTR lpszBuffer)           // buffer <br>{ <br>    HRESULT    hr     = NOERROR; <br>    SYSTEMTIME st     = {0}; <br>FILETIME   ft     = {0}; <br>    INT        cBytes = 0; <br>    BOOL       fRet   = FALSE; <br> <br>    DEBUGPUBLIC("HrCreateProfileName()"); <br> <br>    ZeroMemory(lpszBuffer, cBufferSize); <br> <br>GetSystemTime(&amp;st); <br> <br>fRet = SystemTimeToFileTime(&amp;st, &amp;ft); <br> <br>    if(fRet == FALSE) <br>    { <br>        hr = HRESULT_FROM_WIN32(GetLastError()); <br>        goto cleanup; <br>    } <br> <br>    cBytes = _snprintf( <br>        lpszBuffer, <br>        cBufferSize, <br>        "%s %08lx%08lx%08lx", <br>        lpszPrefix, <br>        GetCurrentProcessId(), <br>        ft.dwHighDateTime, <br>        ft.dwLowDateTime); <br> <br>    if(cBytes &lt; 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        ZeroMemory(lpszBuffer, cBufferSize); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetFileVersionInfo---------------------------------------------------- <br>//  Get the file version information. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetFileVersionInfo(            // RETURNS: return code <br>    IN  LPSTR lpszFileName,                // file name <br>    OUT LPVOID *lppVersionInfo)             // file version information <br>{ <br>    HRESULT hr            = NOERROR; <br>    DWORD   dwVerInfoSize = 0; <br>    DWORD   dwVerHandle   = 0; <br>    BOOL    fRet          = 0; <br> <br>    DEBUGPUBLIC("HrGetFileVersionInfo()"); <br> <br>    *lppVersionInfo = NULL; <br> <br>    dwVerInfoSize = GetFileVersionInfoSize(lpszFileName, &amp;dwVerHandle); <br> <br>    if(dwVerInfoSize != 0) <br>    { <br>        *lppVersionInfo = <br>            (LPVOID)GlobalAlloc(GMEM_FIXED, dwVerInfoSize); <br> <br>        if(*lppVersionInfo == NULL) <br>        { <br>            hr = HRESULT_FROM_WIN32(GetLastError()); <br>            goto cleanup; <br>        } <br>     <br>        fRet = GetFileVersionInfo( <br>            lpszFileName, <br>            0, <br>            dwVerInfoSize, <br>            (LPVOID)*lppVersionInfo); <br> <br>        if(fRet == FALSE) <br>        { <br>            hr = HRESULT_FROM_WIN32(GetLastError()); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        hr = HRESULT_FROM_WIN32(GetLastError()); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        if(lppVersionInfo != NULL) <br>        { <br>            GLOBALFREE(*lppVersionInfo); <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--_GetFileNameFromFullPath-------------------------------------------------- <br>//  Return a pointer to the file name. <br>// ----------------------------------------------------------------------------- <br>LPSTR _GetFileNameFromFullPath( <br>    IN LPSTR lpszFullPath)                // full path name <br>{ <br>    LPSTR pszT = NULL; <br>    LPSTR psz  = NULL; <br> <br>    DEBUGPUBLIC("_GetFileNameFromFullPath()"); <br> <br>    psz  = lpszFullPath; <br> <br>    pszT = lpszFullPath + lstrlen(lpszFullPath); <br> <br>    while(pszT &gt;= lpszFullPath) <br>    { <br>        if((*pszT == '\\') || (*pszT == ':')) <br>        { <br>            psz = pszT; <br>            break; <br>        } <br> <br>        pszT--; <br>    } <br>     <br>    if((*psz == '\\') || (*psz == ':')) <br>    { <br>        psz++; <br>    } <br> <br>    return(psz); <br>} <br> <br> <br> <br>//$--HrSearchGAL---------------------------------------------------------------- <br>//  Look for the entry ID by searching for the DN in the global address list. <br>// <br>//  RETURNS:hr == NOERROR           Found <br>//hr == EDK_E_NOT_FOUND   DN Not Found <br>//hr == (anything else)   Other Error <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrSearchGAL(// RETURNS: HRESULT <br>INLPADRBOOKlpAdrBook,// address book (directory) to look in <br>INLPSTRlpszDN,            // object distinguished name <br>OUTULONG *lpcbEntryID,// count of bytes in entry ID <br>OUTLPENTRYID * lppEntryID)    // pointer to entry ID <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    LPSTR           lpszAddress         = NULL; <br>    ULONG           cbGALEntryID        = 0; <br>    LPENTRYID       lpGALEntryID        = NULL; <br>    ULONG           ulGALObjectType     = 0; <br>    LPABCONT        lpGAL               = NULL; <br>    BOOL            fMapiRecip          = FALSE; <br> <br>    DEBUGPRIVATE("HrSearchGAL()"); <br> <br>    hr = CHK_HrSearchGAL( <br>        lpAdrBook,  <br>        lpszDN, <br>        lpcbEntryID, <br>        lppEntryID); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initially zero out the return variables. <br> <br>    *lpcbEntryID = 0; <br>    *lppEntryID = NULL; <br> <br>    // Create an address string consisting of "EX:" followed by the DN. <br> <br>    hr = MAPIAllocateBuffer( <br>        strlen(EXCHANGE_ADDRTYPE ":") + strlen(lpszDN) + 1,  <br>        &amp;lpszAddress); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    strcpy(lpszAddress, EXCHANGE_ADDRTYPE ":"); <br>    strcat(lpszAddress, lpszDN); <br> <br>    // Open the global address list. <br> <br>    hr = HrFindExchangeGlobalAddressList( <br>        lpAdrBook,  <br>        &amp;cbGALEntryID,  <br>        &amp;lpGALEntryID); <br>    if (FAILED(hr)) <br>        goto cleanup; <br>     <br>    hr = MAPICALL(lpAdrBook)-&gt;OpenEntry( <br>        lpAdrBook,  <br>        cbGALEntryID,  <br>        lpGALEntryID,  <br>        &amp;IID_IMAPIContainer,  <br>        MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS,  <br>        &amp;ulGALObjectType,  <br>        (LPUNKNOWN *) &amp;lpGAL); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Make sure it's the right object type. <br> <br>    if (ulGALObjectType != MAPI_ABCONT) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Resolve the address (returns EDK_E_NOT_FOUND if not found). <br> <br>    hr = HrGWResolveAddress( <br>        lpGAL,  <br>        lpszAddress,  <br>        &amp;fMapiRecip,  <br>        lpcbEntryID,  <br>        lppEntryID); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    ULRELEASE(lpGAL); <br>    MAPIFREEBUFFER(lpGALEntryID); <br>    MAPIFREEBUFFER(lpszAddress); <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrSearchHierarchyTable----------------------------------------------------- <br>//  Look for the entry ID by searching for the DN in the hierarchy table. <br>// <br>//  RETURNS:hr == NOERROR           Found <br>//hr == EDK_E_NOT_FOUND   DN Not Found <br>//hr == (anything else)   Other Error <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrSearchHierarchyTable(  // RETURNS: HRESULT <br>INLPADRBOOKlpAdrBook,// address book (directory) to look in <br>INLPSTRlpszDN,            // object distinguished name <br>OUTULONG *lpcbEntryID,// count of bytes in entry ID <br>OUTLPENTRYID * lppEntryID)    // pointer to entry ID <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    ULONG           ulObjectType        = 0; <br>    LPMAPICONTAINER lpRootContainer     = NULL; <br>    LPMAPITABLE     lpHierarchyTable    = NULL; <br>    SizedSPropTagArray(1, sGetEntryID)  = {1, PR_ENTRYID}; <br>    const ULONG     cMaxBatchRows       = 100; <br>    LPSRowSet       lpBatch             = NULL; <br>    ULONG           cbEntryID           = 0; <br>    LPENTRYID       lpEntryID           = NULL; <br>    LPSTR           lpszDNInsideEntryID = NULL; <br>    ULONG           iRow                = 0; <br>    MAPIUID         muidEMSAB           = MUIDEMSAB; <br>    LPMAPIUID       lpmuid              = NULL; <br> <br>    DEBUGPRIVATE("HrSearchHierarchyTable()"); <br> <br>    hr = CHK_HrSearchHierarchyTable( <br>        lpAdrBook,  <br>        lpszDN, <br>        lpcbEntryID, <br>        lppEntryID); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initially zero out the return variables. <br> <br>    *lpcbEntryID = 0; <br>    *lppEntryID = NULL; <br> <br>    // Get the hierarchy table for the address book. <br> <br>    hr = MAPICALL(lpAdrBook)-&gt;OpenEntry( <br>        lpAdrBook,  <br>        0,  <br>        NULL,  <br>        NULL,  <br>        MAPI_DEFERRED_ERRORS,  <br>        &amp;ulObjectType,  <br>        (LPUNKNOWN *) &amp;lpRootContainer); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>    if (ulObjectType != MAPI_ABCONT) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL(lpRootContainer)-&gt;GetHierarchyTable( <br>        lpRootContainer,  <br>        CONVENIENT_DEPTH | MAPI_DEFERRED_ERRORS,  <br>        &amp;lpHierarchyTable); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>    // We are only interested in the entry ID property. <br> <br>    hr = MAPICALL(lpHierarchyTable)-&gt;SetColumns( <br>        lpHierarchyTable,  <br>        (LPSPropTagArray) &amp;sGetEntryID,  <br>        0); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>    // Loop to get batches of entry IDs and search each batch for our DN. <br> <br>    while (TRUE) <br>    { <br>        // Get a new batch of entry IDs. <br> <br>        hr = MAPICALL(lpHierarchyTable)-&gt;QueryRows( <br>            lpHierarchyTable,  <br>            cMaxBatchRows,  <br>            0,  <br>            &amp;lpBatch); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>        // If we didn't get any rows then we are at the end of the table  <br>        // so stop searching. <br> <br>        if (lpBatch-&gt;cRows == 0) <br>            break; <br> <br>        // Search through this batch for our DN. <br> <br>        for (iRow = 0; iRow &lt; lpBatch-&gt;cRows; iRow++) <br>        { <br>            // Get each row's entry ID and the MAPIUID contained inside of it. <br> <br>            cbEntryID = lpBatch-&gt;aRow[iRow].lpProps[0].Value.bin.cb; <br>            lpEntryID = (LPENTRYID) lpBatch-&gt;aRow[iRow].lpProps[0].Value.bin.lpb; <br>            lpmuid = &amp;(((LPDIR_ENTRYID)lpEntryID)-&gt;muid); <br> <br>            // Make sure this entry ID is from the Exchange address book <br> <br>            if (IsEqualMAPIUID(lpmuid, &amp;muidEMSAB)) <br>            { <br>                // Get the DN contained inside of the entry ID. <br> <br>                lpszDNInsideEntryID = (LPSTR)  <br>                    (lpBatch-&gt;aRow[iRow].lpProps[0].Value.bin.lpb  <br>                    + sizeof(DIR_ENTRYID)); <br> <br>                // If the entry ID DN matches the one we're looking for then  <br>                // we've found the entry ID we need to return. <br> <br>                if (!_stricmp(lpszDNInsideEntryID, lpszDN)) <br>                { <br>                    // Make a copy of the entry ID and return it  <br>                    // in the return variables. <br> <br>                    hr = MAPIAllocateBuffer(cbEntryID, lppEntryID); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br>                    MoveMemory(*lppEntryID, lpEntryID,cbEntryID); <br>                    *lpcbEntryID = cbEntryID; <br> <br>                    hr = NOERROR; <br>                    goto cleanup; <br>                } <br>            } <br> <br>            // Free this row. <br> <br>            MAPIFREEBUFFER(lpBatch-&gt;aRow[iRow].lpProps); <br>        } <br> <br>        // Free the row set for the batch, so we can go  get another one. <br> <br>        MAPIFREEBUFFER(lpBatch); <br>    } <br> <br>    // If we got here then we didn't find the DN in the hierarchy table. <br> <br>    hr = EDK_E_NOT_FOUND; <br> <br>cleanup: <br>    if (lpBatch) <br>    { <br>        for (iRow = 0; iRow &lt; lpBatch-&gt;cRows; iRow++) <br>            MAPIFREEBUFFER(lpBatch-&gt;aRow[iRow].lpProps); <br>        MAPIFREEBUFFER(lpBatch); <br>    } <br>    ULRELEASE(lpHierarchyTable); <br>    ULRELEASE(lpRootContainer); <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCreateDirEntryIdEx------------------------------------------------------- <br>//  Create a directory entry ID given the address of the object <br>//  in the directory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCreateDirEntryIdEx(// RETURNS: HRESULT <br>INLPADRBOOKlpAdrBook,// address book (directory) to look in <br>INLPSTRlpszAddress,// object distinguished name <br>OUTULONG *lpcbEntryID,// count of bytes in entry ID <br>OUTLPENTRYID * lppEntryID)    // pointer to entry ID <br>{ <br>HRESULThr= NOERROR; <br>    ULONG           cbHierarchyEntryID  = 0; <br>    LPENTRYID       lpHierarchyEntryID  = NULL; <br>    ULONG           ulEntryIDType       = 0; <br> <br>DEBUGPUBLIC("HrCreateDirEntryIdEx()"); <br> <br>    hr = CHK_HrCreateDirEntryIdEx( <br>        lpAdrBook,  <br>        lpszAddress, <br>        lpcbEntryID, <br>        lppEntryID); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initially zero out the return variables. <br> <br>    *lpcbEntryID = 0; <br>    *lppEntryID = NULL; <br> <br>// Look for the DN in the global address list. <br> <br>hr = HrSearchGAL( <br>lpAdrBook,  <br>lpszAddress,  <br>        lpcbEntryID,  <br>        lppEntryID); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>    // If the type was DT_AGENT or DT_ORGANIZATION, then we have to  <br>    // do a further lookup in the hierarchy table to determine the  <br>    // DN's real type. <br> <br>    ulEntryIDType = ((LPDIR_ENTRYID) *lppEntryID)-&gt;ulType; <br> <br>    if (ulEntryIDType == DT_AGENT ||  <br>        ulEntryIDType == DT_ORGANIZATION) <br>    { <br>    // Look for the DN in the hierarchy table. <br> <br>    hr = HrSearchHierarchyTable( <br>    lpAdrBook,  <br>    lpszAddress,  <br>    &amp;cbHierarchyEntryID,  <br>    &amp;lpHierarchyEntryID); <br> <br>        // If we didn't find it in the hierarchy table then  <br>        // use the DT_AGENT entry ID. <br> <br>        if (hr == EDK_E_NOT_FOUND) <br>        { <br>            hr = NOERROR; <br>            goto cleanup; <br>        } <br> <br>        // Free the DT_AGENT entry ID. <br> <br>        MAPIFREEBUFFER(*lppEntryID); <br>        *lpcbEntryID = 0; <br> <br>        // If HrSearchHierarchyTable returned any other error  <br>        // then return failure. <br> <br>        if (FAILED(hr)) <br>    goto cleanup; <br> <br>        // Replace the DT_AGENT entry ID with the new one from  <br>        // the hierarchy table. <br> <br>        *lpcbEntryID = cbHierarchyEntryID; <br>        *lppEntryID = lpHierarchyEntryID; <br>    } <br> <br>cleanup: <br>RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
