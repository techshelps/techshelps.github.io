<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROCESS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1862"></a>PROCESS.C</h2>
<pre><code>// --process.c------------------------------------------------------------------ <br>// <br>//  Functions to start a thread to handle processing of new mail or files. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "gwmain.h" <br> <br>#define SLEEP_TIME  3000 <br> <br>extern HANDLE hNewMailThread; <br>extern HANDLE hNewFileThread; <br> <br>extern DWORD  dwNewMailTimeout; <br>extern DWORD  dwNewFileTimeout; <br> <br>extern CRITICAL_SECTION csNewMailList; <br>extern CRITICAL_SECTION csNewFileList; <br> <br>static HANDLE hFindData  = INVALID_HANDLE_VALUE; // change notification handle <br>static HANDLE PollHandle = INVALID_HANDLE_VALUE; // poll handle <br> <br>//$--_GWThreadContext----------------------------------------------------------- <br>//  Type for gateway thread context information. <br>// ----------------------------------------------------------------------------- <br>typedef struct _GWThreadContext <br>{ <br>    BOOL                   fUseFindData;            // if TRUE use lpFindData <br> <br>    CHAR                   szAddrType[MAX_PATH+1];  // address type <br> <br>    DWORD                  dwSubmitInterval;        // submit interval <br>    DWORD                  dwPollingInterval;       // polling interval <br>    DWORD                  cMessages;               // #messages/thread <br>    DWORD                  cThreads;                // #threads <br> <br>    ULONG                  ulThreadNumber;          // thread# <br> <br>    CHAR                   szFindPath[MAX_PATH+1];  // path <br>    CHAR                   szFindMask[MAX_PATH+1];  // find mask <br>    HANDLE                 *lphFindData;            // change notifcation handle <br>    ULONG                  cFindData;               // find data count <br>LPWIN32_FIND_DATA      lpFindData;              // find data <br>    HANDLE                 *lpPollHandle;           // poll handle <br> <br>    LPSRowSet              lpRows;                  // rows <br>    LPMAPITABLE            lpTable;                 // contents table <br> <br>    LPTHREAD_START_ROUTINE lpStartAddress;          // thread function <br> <br>} GWTHREADCONTEXT, *LPGWTHREADCONTEXT; <br> <br>#include "process.chk" <br> <br>//$--GetGWPath------------------------------------------------------------------ <br>//  Get a gateway path pointer. <br>// ----------------------------------------------------------------------------- <br>LPSTR GetGWPath(                       // RETURNS: gateway path <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("GetGWPath()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        return(NULL); <br> <br>    if(((LPGWTHREADCONTEXT)lpParameter)-&gt;fUseFindData == FALSE) <br>    { <br>        return(NULL); <br>    } <br> <br>    return(((LPGWTHREADCONTEXT)lpParameter)-&gt;szFindPath); <br>} <br> <br>//$--GetGWSRowSet----------------------------------------------------------------- <br>//  Get a SRowSet pointer. <br>// ----------------------------------------------------------------------------- <br>LPSRowSet GetGWSRowSet(                   // RETURNS: SRowSet <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("GetGWSRowSet()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        return(NULL); <br> <br>    if(((LPGWTHREADCONTEXT)lpParameter)-&gt;fUseFindData == TRUE) <br>    { <br>        return(NULL); <br>    } <br> <br>    return(((LPGWTHREADCONTEXT)lpParameter)-&gt;lpRows); <br>} <br> <br>//$--GetGWFindData----------------------------------------------------------- <br>//  Get a WIN32_FIND_DATA pointer. <br>// ----------------------------------------------------------------------------- <br>LPWIN32_FIND_DATA GetGWFindData(     // RETURNS: WIN32_FIND_DATA <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("GetGWFindData()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        return(NULL); <br> <br>    if(((LPGWTHREADCONTEXT)lpParameter)-&gt;fUseFindData == FALSE) <br>    { <br>        return(NULL); <br>    } <br> <br>    return(((LPGWTHREADCONTEXT)lpParameter)-&gt;lpFindData); <br>} <br> <br>//$--GetGWFindDataSize------------------------------------------------------- <br>//  Get a WIN32_FIND_DATA size. <br>// ----------------------------------------------------------------------------- <br>ULONG GetGWFindDataSize(             // RETURNS: count of WIN32_FIND_DATA <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("GetGWFindDataSize()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        return(0); <br> <br>    if(((LPGWTHREADCONTEXT)lpParameter)-&gt;fUseFindData == FALSE) <br>    { <br>        return(0); <br>    } <br> <br>    return(((LPGWTHREADCONTEXT)lpParameter)-&gt;cFindData); <br>} <br> <br>//$--GetGWSubmitInterval---------------------------------------------------------- <br>//  Get the submit interval. <br>// ----------------------------------------------------------------------------- <br>DWORD GetGWSubmitInterval(                // RETURNS: submit interval <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("GetGWSubmitInterval()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        return(0); <br> <br>    return(((LPGWTHREADCONTEXT)lpParameter)-&gt;dwSubmitInterval); <br>} <br> <br>//$--FreeThreadParameter-------------------------------------------------------- <br>//  Free the thread parameter. <br>// ----------------------------------------------------------------------------- <br>VOID FreeThreadParameter(               // RETURNS: nothing <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("FreeThreadParameter()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        return; <br> <br>    if(((LPGWTHREADCONTEXT)lpParameter)-&gt;lpRows != NULL) <br>    { <br>        FREEPROWS(((LPGWTHREADCONTEXT)lpParameter)-&gt;lpRows); <br>    } <br> <br>    if(((LPGWTHREADCONTEXT)lpParameter)-&gt;lpFindData != NULL) <br>    { <br>        MAPIFREEBUFFER(((LPGWTHREADCONTEXT)lpParameter)-&gt;lpFindData); <br>    } <br> <br>    MAPIFREEBUFFER(lpParameter); <br>} <br> <br>//$--HrGetNewMailList----------------------------------------------------------- <br>//  Get list of new mail. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetNewMailList(        // RETURNS: return code <br>    IN  LPMAPITABLE lpTable,            // contents table <br>    IN  ULONG cMessages,                // maximum number of messages to get <br>    IN  DWORD dwPollingInterval,        // polling interval <br>    OUT LPSRowSet *lppRows)             // new mail list <br>{ <br>    HRESULT   hr     = NOERROR; <br>    LPSRowSet lpRows = NULL; <br> <br>    DEBUGPRIVATE("HrGetNewMailList()"); <br> <br>    EnterCriticalSection(&amp;csNewMailList); <br> <br>START: <br> <br>    // <br>    // Check for service control <br>    // <br> <br>    hr = HrServiceProcessControl(); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL(lpTable)-&gt;QueryRows( <br>        lpTable, <br>        cMessages, <br>        0, <br>        &amp;lpRows); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if((lpRows == NULL) || (lpRows-&gt;cRows == 0)) <br>    { <br>        FREEPROWS(lpRows); <br>    } <br>    else <br>    { <br>        goto cleanup; <br>    } <br> <br>    if((dwPollingInterval == ((DWORD)-1)) &amp;&amp; (GetGWNewMailEvent() != NULL)) <br>    { <br>        DWORD   dw          = 0; <br>        HANDLE  hObjects[2] = {0}; <br> <br>        hObjects[0] = GetServiceStopEvent(); <br>        hObjects[1] = GetGWNewMailEvent(); <br> <br>        dw = WaitForMultipleObjects(2, hObjects, FALSE, dwNewMailTimeout); <br> <br>        switch(dw) <br>        { <br>        case WAIT_OBJECT_0: <br>        case (WAIT_ABANDONED_0): <br> <br>            // <br>            // Service is stopping. <br>            // <br> <br>            hr = HR_LOG(EDK_E_SHUTDOWN_SERVICE); <br> <br>            goto cleanup; <br>            break; <br>        case (WAIT_OBJECT_0+1): <br>        case (WAIT_ABANDONED_0+1): <br>            break; <br>        case (WAIT_TIMEOUT): <br>            break; <br>        default: <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        if(dwPollingInterval == ((DWORD)-1)) <br>        { <br>            dwPollingInterval = SLEEP_TIME; <br>        } <br> <br>        Sleep(dwPollingInterval); <br>    } <br> <br>    // Go to the beginning of the contents table for the folder <br>    hr = MAPICALL(lpTable)-&gt;SeekRow(lpTable, BOOKMARK_BEGINNING, 0, NULL); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    goto START; <br>                 <br>cleanup: <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>        *lppRows = lpRows; <br>    } <br>    else <br>    { <br>        FREEPROWS(lpRows); <br>    } <br> <br>    LeaveCriticalSection(&amp;csNewMailList); <br> <br>    RETURN(hr); <br>} <br> <br>//$--FnNewMailPool-------------------------------------------------------------- <br>//  New mail thread pool function <br>// ----------------------------------------------------------------------------- <br>static VOID FnNewMailPool(              // RETURNS: nothing <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("FnNewMailPool()"); <br> <br>    __try <br>    { <br>        for(;;) <br>        { <br>            hr = HrGetNewMailList( <br>                ((LPGWTHREADCONTEXT)lpParameter)-&gt;lpTable, <br>                ((LPGWTHREADCONTEXT)lpParameter)-&gt;cMessages, <br>                ((LPGWTHREADCONTEXT)lpParameter)-&gt;dwPollingInterval, <br>                &amp;((LPGWTHREADCONTEXT)lpParameter)-&gt;lpRows); <br> <br>            if(FAILED(hr)) <br>            { <br>                break; <br>            } <br> <br>            (*((LPGWTHREADCONTEXT)lpParameter)-&gt;lpStartAddress)(lpParameter); <br> <br>            FREEPROWS(((LPGWTHREADCONTEXT)lpParameter)-&gt;lpRows); <br>        } <br> <br>        FreeThreadParameter(lpParameter); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br> <br>    } <br>} <br> <br>//$--FnNewMailMain-------------------------------------------------------------- <br>//  New mail handler main loop. <br>// ----------------------------------------------------------------------------- <br>static VOID FnNewMailMain(              // RETURNS: nothing <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr                = NOERROR; <br>    SCODE   sc                = 0; <br>    DWORD   dw                = 0; <br>    ULONG   i                 = 0; <br>    BOOL    fStatus           = FALSE; <br> <br>    LPMAPITABLE lpTable       = NULL; <br> <br>    DWORD   dwThreadId        = 0; <br>    HANDLE  hThread           = NULL; <br> <br>    LONG    NumStartThreads   = 0; <br>    LONG    NumStopThreads    = 0; <br> <br>    LONG    cThreads          = 0; <br> <br>    LONG    cRunningThreads   = 0; <br> <br>    LPMAPIFOLDER     lpMtsOutFolder  = NULL; <br> <br>    LPGWTHREADCONTEXT lpContext       = NULL; <br>    LPGWTHREADCONTEXT lpThreadContext = NULL; <br> <br>    SizedSPropTagArray(1, rgPropTag) = <br>    { <br>        1, <br>        { <br>            PR_ENTRYID <br>        } <br>    }; <br> <br>    DEBUGPRIVATE("FnNewMailMain()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        return; <br> <br>    lpContext = (LPGWTHREADCONTEXT)lpParameter; <br> <br>    cThreads = lpContext-&gt;cThreads; <br> <br>    lpMtsOutFolder = GetGWMtsOutFolder(); <br> <br>    //-------------------------------------------------------------------------- <br> <br>    hr = MAPICALL(lpMtsOutFolder)-&gt;GetContentsTable( <br>        lpMtsOutFolder, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;lpTable); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL(lpTable)-&gt;SetColumns( <br>        lpTable, <br>        (LPSPropTagArray)&amp;rgPropTag, <br>        TBL_BATCH); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Check for service control <br>    // <br> <br>    hr = HrServiceProcessControl(); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    NumStartThreads = 0; <br>    NumStopThreads  = 0; <br> <br>    cRunningThreads = 0; <br> <br>    for(i = 0 ; i &lt; ((ULONG)cThreads) ; i++) <br>    { <br>        lpThreadContext = NULL; <br> <br>        sc = MAPIAllocateBuffer(sizeof(GWTHREADCONTEXT), (void **)&amp;lpThreadContext); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br> <br>        CopyMemory(lpThreadContext, lpContext, sizeof(GWTHREADCONTEXT)); <br> <br>        lpThreadContext-&gt;ulThreadNumber = i; <br>        lpThreadContext-&gt;lpTable        = lpTable; <br>        lpThreadContext-&gt;lpRows         = NULL; <br> <br>        hThread = HServiceCreateThread( <br>            &amp;NumStartThreads, <br>            &amp;NumStopThreads, <br>            NULL, <br>            0, <br>            (LPTHREAD_START_ROUTINE)FnNewMailPool, <br>            (LPVOID)lpThreadContext, <br>            0, <br>            &amp;dwThreadId); <br> <br>        if(hThread == NULL) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            if(cRunningThreads == 0) <br>                goto cleanup; <br>            else <br>                goto WAIT; <br>        } <br> <br>        CloseHandle(hThread); <br> <br>        cRunningThreads = i; <br>        cRunningThreads++; <br>    } <br> <br>WAIT: <br> <br>    // Wait for all threads to start <br>    while(NumStartThreads != cRunningThreads) <br>    { <br>        Sleep(SLEEP_TIME); <br>    } <br> <br>    // Wait for all threads to exit <br>    while(NumStopThreads != cRunningThreads) <br>    { <br>        Sleep(SLEEP_TIME); <br>    } <br>                 <br>cleanup: <br> <br>    ULRELEASE(lpTable); <br> <br>    if(FAILED(hr)) <br>    { <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    return; <br>} <br> <br>//$--FnNewMailThread------------------------------------------------------------ <br>//  New mail thread function <br>// ----------------------------------------------------------------------------- <br>static VOID FnNewMailThread(            // RETURNS: nothing <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr      = NOERROR; <br>    HGLOBAL hglobal = NULL; <br> <br>    DEBUGPRIVATE("FnNewMailThread()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        ExitThread(0); <br> <br>    __try <br>    { <br>        FnNewMailMain(lpParameter); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br> <br>    } <br> <br>    MAPIFREEBUFFER( lpParameter); <br> <br>    ExitThread(0); <br>} <br> <br>//$--HrGWStartNewMailHandler@-------------------------------------------------- <br>//  Start a thread to handle processing of new mail. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGWStartNewMailHandlerW( <br>    IN DWORD   dwSubmitInterval,                // submit interval <br>    IN DWORD   dwPollingInterval,               // polling interval <br>    IN DWORD   cMessages,                       // #messages/thread <br>    IN DWORD   cThreads,                        // #threads <br>    IN LPCWSTR lpszAddrType,                    // address type <br>    IN LPCWSTR lpszPath,                        // path <br>    IN LPTHREAD_START_ROUTINE lpStartAddress)   // thread function <br>{ <br>    HRESULT hr            = NOERROR; <br>    HGLOBAL hglobal       = NULL; <br>    LPSTR   lpszAddrTypeA = NULL; <br>    LPSTR   lpszPathA     = NULL; <br>    DWORD   dwThreadId    = 0; <br> <br>    LPGWTHREADCONTEXT lpContext = NULL; <br> <br>    DEBUGPUBLIC("HrGWStartNewMailHandlerW()"); <br> <br>    hr = CHK_HrGWStartNewMailHandlerW( <br>        dwSubmitInterval,  <br>        dwPollingInterval, <br>        cMessages,  <br>        cThreads,  <br>        lpszAddrType,  <br>        lpszPath,  <br>        lpStartAddress); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = MAPIAllocateBuffer( sizeof(GWTHREADCONTEXT), (PVOID)&amp;lpContext); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ZeroMemory(lpContext, sizeof(GWTHREADCONTEXT)); <br> <br>    lpContext-&gt;fUseFindData      = FALSE; <br>    lpContext-&gt;dwSubmitInterval  = dwSubmitInterval; <br>    lpContext-&gt;dwPollingInterval = dwPollingInterval; <br>    lpContext-&gt;lpStartAddress    = lpStartAddress; <br>    lpContext-&gt;cMessages         = cMessages; <br>    lpContext-&gt;cThreads          = cThreads; <br>    lpContext-&gt;lpStartAddress    = lpStartAddress; <br> <br>    hr = HrStrWToStrA( lpszAddrType, &amp;lpszAddrTypeA); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    hr = HrStrWToStrA( lpszPath, &amp;lpszPathA); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    lstrcpyA(lpContext-&gt;szAddrType, lpszAddrTypeA); <br>    lstrcpyA(lpContext-&gt;szFindPath, lpszPathA); <br> <br>    hNewMailThread = CreateThread( <br>        NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE)FnNewMailThread, <br>        (LPVOID)lpContext, <br>        0, <br>        &amp;dwThreadId); <br> <br>    if(hNewMailThread == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpszAddrTypeA); <br>    MAPIFREEBUFFER( lpszPathA); <br> <br>    if(FAILED(hr)) <br>        MAPIFREEBUFFER( lpContext); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrGWStartNewMailHandlerA( <br>    IN DWORD   dwSubmitInterval,                // submit interval <br>    IN DWORD   dwPollingInterval,               // polling interval <br>    IN DWORD   cMessages,                       // #messages/thread <br>    IN DWORD   cThreads,                        // #threads <br>    IN LPCSTR  lpszAddrType,                    // address type <br>    IN LPCSTR  lpszPath,                        // path <br>    IN LPTHREAD_START_ROUTINE lpStartAddress)   // thread function <br>{ <br>    HRESULT hr         = NOERROR; <br>    HGLOBAL hglobal    = NULL; <br>    DWORD   dwThreadId = 0; <br> <br>    LPGWTHREADCONTEXT lpContext = NULL; <br> <br>    DEBUGPUBLIC("HrGWStartNewMailHandlerA()"); <br> <br>    hr = CHK_HrGWStartNewMailHandlerA( <br>        dwSubmitInterval,  <br>        dwPollingInterval, <br>        cMessages,  <br>        cThreads,  <br>        lpszAddrType,  <br>        lpszPath,  <br>        lpStartAddress); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = MAPIAllocateBuffer( sizeof(GWTHREADCONTEXT), (PVOID)&amp;lpContext); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ZeroMemory(lpContext, sizeof(GWTHREADCONTEXT)); <br> <br>    lpContext-&gt;fUseFindData      = FALSE; <br>    lpContext-&gt;dwSubmitInterval  = dwSubmitInterval; <br>    lpContext-&gt;dwPollingInterval = dwPollingInterval; <br>    lpContext-&gt;lpStartAddress    = lpStartAddress; <br>    lpContext-&gt;cMessages         = cMessages; <br>    lpContext-&gt;cThreads          = cThreads; <br>    lpContext-&gt;lpStartAddress    = lpStartAddress; <br> <br>    lstrcpyA( lpContext-&gt;szAddrType, lpszAddrType); <br>    lstrcpyA( lpContext-&gt;szFindPath, lpszPath); <br> <br>    hNewMailThread = CreateThread( <br>        NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE)FnNewMailThread, <br>        (LPVOID)lpContext, <br>        0, <br>        &amp;dwThreadId); <br> <br>    if(hNewMailThread == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    if(FAILED(hr)) <br>        MAPIFREEBUFFER( lpContext); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrPollFile----------------------------------------------------------------- <br>//  Poll for a file. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrPollFile(                  // RETURNS: return code <br>    IN LPSTR             lpszDirectory,    // pointer to directory <br>    IN LPSTR             lpszFindMask,     // pointer to find mask <br>    OUT HANDLE            *lpPollHandle,    // pointer to find data handle <br>OUT LPWIN32_FIND_DATA lpFindData)       // pointer to find data <br>{ <br>    HRESULT hr              = NOERROR; <br>BOOL    fFound          = FALSE; <br>DWORD   dwIgnoreAttrs   = <br>                        FILE_ATTRIBUTE_READONLY | <br>                        FILE_ATTRIBUTE_SYSTEM | <br>                        FILE_ATTRIBUTE_DIRECTORY | <br>                        FILE_ATTRIBUTE_TEMPORARY; <br> <br>    DEBUGPRIVATE("HrPollFile()"); <br> <br>    hr = CHK_HrPollFile( <br>        lpszDirectory, <br>        lpszFindMask, <br>        lpPollHandle, <br>    lpFindData); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>//One of the following is now true: <br>    // <br>//A)We have a search already active, use FindNextFile. <br>//If it fails, we will want to restart the search <br>//(in case something appeared in the search behind <br>//us. <br>    // <br>//B)We don't have a search active, use FindFirstFile. <br> <br>// Try the active search <br> <br>if (*lpPollHandle != INVALID_HANDLE_VALUE) <br>{ <br>fFound = FindNextFile(*lpPollHandle, lpFindData); <br> <br>// If we fail, close the old search so we can start <br>// a new one below. <br> <br>if (!fFound) <br>{ <br>FindClose(*lpPollHandle); <br>*lpPollHandle = INVALID_HANDLE_VALUE; <br> <br>            // <br>            // If we don't find a file, then return. <br>            // <br> <br>            if(GetLastError() == ERROR_NO_MORE_FILES) <br>            { <br>                hr = HR_LOG(EDK_E_NOT_FOUND); <br>            } <br>            else <br>            { <br>                hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>            } <br> <br>goto cleanup; <br>} <br>} <br> <br>// If there was no search or if the old one was just closed above <br> <br>if (*lpPollHandle == INVALID_HANDLE_VALUE) <br>{ <br>HANDLE hFindT; <br>CHAR rgchFileName[MAX_PATH]; <br> <br>// Copy the directory name. Note that we trust the value in the <br>// profile to be correct, since the UI should have enforced a <br>// syntax that included a trailing : or \ in the spec. <br> <br>lstrcpy(rgchFileName, lpszDirectory); <br> <br>lstrcat(rgchFileName, lpszFindMask); <br> <br>hFindT = FindFirstFile(rgchFileName, lpFindData); <br> <br>// If nothing's found, we're done here. <br> <br>if (hFindT == INVALID_HANDLE_VALUE) <br>        { <br>            hr = HR_LOG(EDK_E_NOT_FOUND); <br>goto cleanup; <br>        } <br> <br>// Found something, continue along. <br> <br>fFound = TRUE; <br>*lpPollHandle = hFindT; <br>} <br> <br> <br>//Here on a match. Exclude unwanted files. <br>    // <br>//Any match with DIRECTORY, READONLY, SYSTEM or TEMPORARY attribute <br>//is ignored. Keep trying until we exhaust the current supply or we <br>//find a file without these attributes. Also, ignore files smaller <br>//than some arbitrary size, they're probably trash. <br> <br>while (fFound) <br>{ <br>//We found a file. Does it have any of the attributes we <br>//want to ignore? If not, get out. If so, try another. <br> <br>#define MIN_USEFUL_FILESIZE ((DWORD) 64) <br> <br>if ((!((lpFindData)-&gt;dwFileAttributes &amp; dwIgnoreAttrs)) &amp;&amp; <br>((lpFindData-&gt;nFileSizeHigh != 0) || <br>(lpFindData-&gt;nFileSizeLow &gt;= MIN_USEFUL_FILESIZE))) <br>break; <br> <br>fFound = FindNextFile(*lpPollHandle, lpFindData); <br>} <br> <br>if(!fFound) <br>{ <br>FindClose(*lpPollHandle); <br>*lpPollHandle = INVALID_HANDLE_VALUE; <br> <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br>        goto cleanup; <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br>//$--HrGetNewFileList----------------------------------------------------------- <br>//  Get list of new files. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetNewFileList(        // RETURNS: return code <br>    IN  ULONG cMessages,                // maximum number of messages to get <br>    IN  DWORD dwPollingInterval,        // polling interval <br>    IN  LPSTR lpszFindPath,            // find path <br>    IN  LPSTR lpszFindMask,            // find mask <br>    IN OUT HANDLE *lpPollHandle,        // poll handle <br>    IN OUT HANDLE *lphFindData,         // change notifcation handle <br>    OUT ULONG *lpcFindData,             // count of find data <br>    OUT LPWIN32_FIND_DATA *lppFindData) // new file list <br>{ <br>    HRESULT           hr         = NOERROR; <br>LPWIN32_FIND_DATA lpFindData = NULL; <br>    ULONG             cBytes     = 0; <br>    SCODE             sc         = NOERROR; <br>    ULONG             j          = 0; <br>    BOOL              fStatus    = FALSE; <br> <br>    DEBUGPRIVATE("HrGetNewFileList()"); <br> <br>    *lpcFindData = 0; <br>    *lppFindData = NULL; <br> <br>    EnterCriticalSection(&amp;csNewFileList); <br> <br>START: <br> <br>    // <br>    // Check for service control <br>    // <br> <br>    hr = HrServiceProcessControl(); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    lpFindData = NULL; <br> <br>    cBytes = cMessages*(sizeof(WIN32_FIND_DATA) + MAX_ALIGN); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)&amp;lpFindData); <br> <br>    ZeroMemory(lpFindData, cBytes); <br> <br>    // An error occured allocating the messages buffer <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    for(j = 0 ; j &lt; ((ULONG)cMessages) ; j++) <br>    { <br>        hr = HrPollFile( <br>            lpszFindPath, <br>            lpszFindMask, <br>            lpPollHandle, <br>            &amp;lpFindData[j]); <br> <br>        if(hr == EDK_E_NOT_FOUND) <br>        { <br>            hr = NOERROR; <br> <br>            // <br>            // Don't start any more threads after the current one is <br>            // started since there are no more files to process. <br>            // <br> <br>            break; <br>        } <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    if(j == 0) <br>    { <br>        MAPIFREEBUFFER(lpFindData); <br>    } <br>    else <br>    { <br>        *lpcFindData = j; <br>        *lppFindData = lpFindData; <br>        goto cleanup; <br>    } <br> <br>    if((dwPollingInterval == ((DWORD)-1)) &amp;&amp; (*lphFindData != NULL)) <br>    { <br>        DWORD   dw          = 0; <br>        HANDLE  hObjects[2] = {0}; <br> <br>        hObjects[0] = GetServiceStopEvent(); <br>        hObjects[1] = *lphFindData; <br> <br>        dw = WaitForMultipleObjects(2, hObjects, FALSE, dwNewFileTimeout); <br> <br>        switch(dw) <br>        { <br>        case WAIT_OBJECT_0: <br>        case (WAIT_ABANDONED_0): <br> <br>            // <br>            // Service is stopping. <br>            // <br> <br>            hr = HR_LOG(EDK_E_SHUTDOWN_SERVICE); <br> <br>            goto cleanup; <br>            break; <br>        case (WAIT_OBJECT_0+1): <br>        case (WAIT_ABANDONED_0+1): <br>            break; <br>        case (WAIT_TIMEOUT): <br>            goto START; <br>            break; <br>        default: <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        fStatus = FindNextChangeNotification(*lphFindData); <br> <br>        if(fStatus == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            FindCloseChangeNotification(*lphFindData); <br>            *lphFindData = NULL; <br>        } <br>    } <br>    else <br>    { <br>        if(dwPollingInterval == ((DWORD)-1)) <br>        { <br>            dwPollingInterval = SLEEP_TIME; <br>        } <br> <br>        Sleep(dwPollingInterval); <br>    } <br> <br>    goto START; <br>                 <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        *lpcFindData = 0; <br>        *lppFindData = NULL; <br> <br>        MAPIFREEBUFFER(lpFindData); <br>    } <br> <br>    LeaveCriticalSection(&amp;csNewFileList); <br> <br>    RETURN(hr); <br>} <br> <br>//$--FnNewFilePool-------------------------------------------------------------- <br>//  New file thread pool function <br>// ----------------------------------------------------------------------------- <br>static VOID FnNewFilePool(              // RETURNS: nothing <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("FnNewFilePool()"); <br> <br>    __try <br>    { <br>        for(;;) <br>        { <br>            hr = HrGetNewFileList( <br>                    ((LPGWTHREADCONTEXT)lpParameter)-&gt;cMessages, <br>                    ((LPGWTHREADCONTEXT)lpParameter)-&gt;dwPollingInterval, <br>                    ((LPGWTHREADCONTEXT)lpParameter)-&gt;szFindPath, <br>                    ((LPGWTHREADCONTEXT)lpParameter)-&gt;szFindMask, <br>                    ((LPGWTHREADCONTEXT)lpParameter)-&gt;lpPollHandle, <br>                    ((LPGWTHREADCONTEXT)lpParameter)-&gt;lphFindData, <br>                    &amp;((LPGWTHREADCONTEXT)lpParameter)-&gt;cFindData, <br>                    &amp;((LPGWTHREADCONTEXT)lpParameter)-&gt;lpFindData); <br> <br>            if(FAILED(hr)) <br>            { <br>                break; <br>            } <br> <br>            (*((LPGWTHREADCONTEXT)lpParameter)-&gt;lpStartAddress)(lpParameter); <br> <br>            MAPIFREEBUFFER(((LPGWTHREADCONTEXT)lpParameter)-&gt;lpFindData); <br>        } <br> <br>        FreeThreadParameter(lpParameter); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br> <br>    } <br>} <br> <br>//$--FnNewFileMain-------------------------------------------------------------- <br>//  New file handler main loop. <br>// ----------------------------------------------------------------------------- <br>static VOID FnNewFileMain(              // RETURNS: nothing <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr                = NOERROR; <br>    HRESULT hrT               = NOERROR; <br>    SCODE   sc                = 0; <br>    DWORD   dw                = 0; </code></pre>
<p>
</p>
<pre><code>BOOL    fStatus           = 0; <br>    ULONG   i                 = 0; <br> <br>    ULONG   cBytes            = 0; <br> <br>    DWORD   dwThreadId        = 0; <br>    HANDLE  hThread           = NULL; <br> <br>    LONG    NumStartThreads   = 0; <br>    LONG    NumStopThreads    = 0; <br> <br>    LONG    cThreads          = 0; <br>    ULONG   cMessages         = 0; <br> <br>    LONG    cRunningThreads   = 0; <br> <br>    DWORD   dwPollingInterval = 0; <br> <br>    LPGWTHREADCONTEXT lpContext       = NULL; <br>    LPGWTHREADCONTEXT lpThreadContext = NULL; <br> <br>    DEBUGPRIVATE("FnNewFileMain()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        return; <br> <br>    lpContext = (LPGWTHREADCONTEXT)lpParameter; <br> <br>    cThreads = lpContext-&gt;cThreads; <br> <br>    //-------------------------------------------------------------------------- <br> <br>    // <br>    // Check for service control <br>    // <br> <br>    hr = HrServiceProcessControl(); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    NumStartThreads = 0; <br>    NumStopThreads  = 0; <br> <br>    cRunningThreads = 0; <br> <br>    for(i = 0 ; i &lt; ((ULONG)cThreads) ; i++) <br>    { <br>        lpThreadContext = NULL; <br> <br>        sc = MAPIAllocateBuffer(sizeof(GWTHREADCONTEXT), (void **)&amp;lpThreadContext); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        CopyMemory(lpThreadContext, lpContext, sizeof(GWTHREADCONTEXT)); <br> <br>        lpThreadContext-&gt;ulThreadNumber = i; <br>        lpThreadContext-&gt;cFindData      = 0; <br>        lpThreadContext-&gt;lpFindData     = NULL; <br> <br>        hThread = HServiceCreateThread( <br>            &amp;NumStartThreads, <br>            &amp;NumStopThreads, <br>            NULL, <br>            0, <br>            (LPTHREAD_START_ROUTINE)FnNewFilePool, <br>            (LPVOID)lpThreadContext, <br>            0, <br>            &amp;dwThreadId); <br> <br>        if(hThread == NULL) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            if(cRunningThreads == 0) <br>                goto cleanup; <br>            else <br>                goto WAIT; <br>        } <br> <br>        CloseHandle(hThread); <br> <br>        cRunningThreads = i; <br>        cRunningThreads++; <br>    } <br> <br>WAIT: <br> <br>    // Wait for all threads to start <br>    while(NumStartThreads != cRunningThreads) <br>    { <br>        Sleep(SLEEP_TIME); <br>    } <br> <br>    // Wait for all threads to exit <br>    while(NumStopThreads != cRunningThreads) <br>    { <br>        Sleep(SLEEP_TIME); <br>    } <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    return; <br>} <br> <br>//$--FnNewFileThread------------------------------------------------------------ <br>//  New file thread function <br>// ----------------------------------------------------------------------------- <br>static VOID FnNewFileThread(            // RETURNS: nothing <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr      = NOERROR; <br>    BOOL    fStatus = FALSE; <br> <br>    DEBUGPRIVATE("FnNewFileThread()"); <br> <br>    hr = CHK_HrCheckParameter(lpParameter); <br> <br>    if(FAILED(hr)) <br>        ExitThread(0); <br> <br>    __try <br>    { <br>        FnNewFileMain(lpParameter); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br> <br>        MODULE_WARNING("**** Stopping gateway ****"); <br> <br>        SetServiceExitCode( ERROR_INTERNAL_ERROR, NOERROR); <br> <br>        ServiceStop(); <br>    } <br> <br>    __try <br>    { <br>        if(*((LPGWTHREADCONTEXT)lpParameter)-&gt;lphFindData != NULL) <br>        { <br>            fStatus = FindCloseChangeNotification( <br>                *((LPGWTHREADCONTEXT)lpParameter)-&gt;lphFindData); <br> <br>            if(fStatus == FALSE) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>        } <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    MAPIFREEBUFFER( lpParameter); <br> <br>    ExitThread(0); <br>} <br> <br>//$--HrGWStartNewFileHandler@-------------------------------------------------- <br>//  Start a thread to handle processing of new files. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGWStartNewFileHandlerW( <br>    IN DWORD   dwSubmitInterval,                // submit interval <br>    IN DWORD   dwPollingInterval,               // polling interval <br>    IN DWORD   cMessages,                       // #messages/thread <br>    IN DWORD   cThreads,                        // #threads <br>    IN LPCWSTR lpszAddrType,                    // address type <br>    IN LPCWSTR lpszFileMask,                    // file mask <br>    IN LPCWSTR lpszPath,                        // path <br>    IN LPTHREAD_START_ROUTINE lpStartAddress)   // thread function <br>{ <br>    HRESULT hr         = NOERROR; <br>    HANDLE  hThread    = NULL; <br>    LPSTR   lpszAddrTypeA = NULL; <br>    LPSTR   lpszFileMaskA = NULL; <br>    LPSTR   lpszPathA     = NULL; <br>    DWORD   dwThreadId = 0; <br> <br>    LPGWTHREADCONTEXT lpContext = NULL; <br> <br>    DEBUGPUBLIC("HrGWStartNewFileHandlerW()"); <br> <br>    hr = CHK_HrGWStartNewFileHandlerW( <br>        dwSubmitInterval, <br>        dwPollingInterval, <br>        cMessages, <br>        cThreads, <br>        lpszAddrType, <br>        lpszFileMask, <br>        lpszPath, <br>        lpStartAddress); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = MAPIAllocateBuffer( sizeof(GWTHREADCONTEXT), (PVOID)&amp;lpContext); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ZeroMemory(lpContext, sizeof(GWTHREADCONTEXT)); <br> <br>    lpContext-&gt;fUseFindData      = TRUE; <br>    lpContext-&gt;dwSubmitInterval  = dwSubmitInterval; <br>    lpContext-&gt;dwPollingInterval = dwPollingInterval; <br>    lpContext-&gt;lpStartAddress    = lpStartAddress; <br>    lpContext-&gt;cMessages         = cMessages; <br>    lpContext-&gt;cThreads          = cThreads; <br>    lpContext-&gt;lpStartAddress    = lpStartAddress; <br> <br>    hr = HrStrWToStrA( lpszAddrType, &amp;lpszAddrTypeA); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    hr = HrStrWToStrA( lpszFileMask, &amp;lpszFileMaskA); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    hr = HrStrWToStrA( lpszPath, &amp;lpszPathA); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    lstrcpyA(lpContext-&gt;szAddrType, lpszAddrTypeA); <br>    lstrcpyA(lpContext-&gt;szFindMask, lpszFileMaskA); <br>    lstrcpyA(lpContext-&gt;szFindPath, lpszPathA); <br> <br>    hFindData = FindFirstChangeNotification( <br>        lpContext-&gt;szFindPath, <br>        FALSE, <br>        FILE_NOTIFY_CHANGE_ATTRIBUTES); <br> <br>    if(hFindData == INVALID_HANDLE_VALUE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lpContext-&gt;lphFindData  = &amp;hFindData; <br>    lpContext-&gt;lpPollHandle = &amp;PollHandle; <br> <br>    hNewFileThread = CreateThread( <br>        NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE)FnNewFileThread, <br>        (LPVOID)lpContext, <br>        0, <br>        &amp;dwThreadId); <br> <br>    if(hNewFileThread == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpszAddrTypeA); <br>    MAPIFREEBUFFER( lpszFileMaskA); <br>    MAPIFREEBUFFER( lpszPathA); <br> <br>    if(FAILED(hr)) <br>        MAPIFREEBUFFER( lpContext); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrGWStartNewFileHandlerA( <br>    IN DWORD   dwSubmitInterval,                // submit interval <br>    IN DWORD   dwPollingInterval,               // polling interval <br>    IN DWORD   cMessages,                       // #messages/thread <br>    IN DWORD   cThreads,                        // #threads <br>    IN LPCSTR  lpszAddrType,                    // address type <br>    IN LPCSTR  lpszFileMask,                    // file mask <br>    IN LPCSTR  lpszPath,                        // path <br>    IN LPTHREAD_START_ROUTINE lpStartAddress)   // thread function <br>{ <br>    HRESULT hr            = NOERROR; <br>    HANDLE  hThread       = NULL; <br>    DWORD   dwThreadId    = 0; <br> <br>    LPGWTHREADCONTEXT lpContext = NULL; <br> <br>    DEBUGPUBLIC("HrGWStartNewFileHandlerA()"); <br> <br>    hr = CHK_HrGWStartNewFileHandlerA( <br>        dwSubmitInterval, <br>        dwPollingInterval, <br>        cMessages, <br>        cThreads, <br>        lpszAddrType, <br>        lpszFileMask, <br>        lpszPath, <br>        lpStartAddress); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = MAPIAllocateBuffer( sizeof(GWTHREADCONTEXT), (PVOID)&amp;lpContext); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    ZeroMemory(lpContext, sizeof(GWTHREADCONTEXT)); <br> <br>    lpContext-&gt;fUseFindData      = TRUE; <br>    lpContext-&gt;dwSubmitInterval  = dwSubmitInterval; <br>    lpContext-&gt;dwPollingInterval = dwPollingInterval; <br>    lpContext-&gt;lpStartAddress    = lpStartAddress; <br>    lpContext-&gt;cMessages         = cMessages; <br>    lpContext-&gt;cThreads          = cThreads; <br>    lpContext-&gt;lpStartAddress    = lpStartAddress; <br> <br>    lstrcpy(lpContext-&gt;szAddrType, lpszAddrType); <br>    lstrcpy(lpContext-&gt;szFindMask, lpszFileMask); <br>    lstrcpy(lpContext-&gt;szFindPath, lpszPath); <br> <br>    hFindData = FindFirstChangeNotification( <br>        lpContext-&gt;szFindPath, <br>        FALSE, <br>        FILE_NOTIFY_CHANGE_ATTRIBUTES); <br> <br>    if(hFindData == INVALID_HANDLE_VALUE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lpContext-&gt;lphFindData  = &amp;hFindData; <br>    lpContext-&gt;lpPollHandle = &amp;PollHandle; <br> <br>    hNewFileThread = CreateThread( <br>        NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE)FnNewFileThread, <br>        (LPVOID)lpContext, <br>        0, <br>        &amp;dwThreadId); <br> <br>    if(hNewFileThread == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>    if(FAILED(hr)) <br>        MAPIFREEBUFFER( lpContext); <br> <br>    RETURN(hr); <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
