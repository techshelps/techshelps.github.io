<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTL_CLI.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1847"></a>UTL_CLI.C</h2>
<pre><code>// --UTL_CLI.C------------------------------------------------------------------ <br>// <br>// Command line argument parsing helper functions. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include "utl_cli.chk" <br> <br>#define NO_MATCH    ((ULONG) ~0) <br>#define MAXARG      250     // Maximum length of a single command line argument. <br>         <br>//$--_HrFindArrayValue-------------------------------------------------------- <br>// Scan through an array of string pointers searching for a value string that <br>// matches up to the length of the value string.  Case INSENSITIVE. <br>// <br>// OUTPUT:  pnIndex will contain the index into the array of the match.  It will <br>//          contain ~0 if no match was found.   <br>// <br>// RETURNS: NOERROR <br>//          EDK_E_NOT_FOUND if match was not found. <br>//          EDK_E_AMBIGUOUS if more than one match was found. <br>//          E_INVALIDARG <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT _HrFindArrayValue( <br>    IN  char*  pszValue,    // Ptr to string value to find. <br>    IN  char** rgpszArray,  // Array of strings containing known values. <br>    IN  ULONG  nArraySize,  // Number of known values. <br>    OUT ULONG* pnIndex)     // Ptr to index of known value, ~0 if no match found. <br>{ <br>    HRESULT hr          = NOERROR; <br>    ULONG   ii          = 0; <br>    int     nCompLen    = 0; <br> <br>    DEBUGPUBLIC( "_HrFindArrayValue()\n"); <br> <br>    // Check the input parameters. <br>    hr = CHK__HrFindArrayValue( pszValue, rgpszArray, nArraySize, pnIndex); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br>     <br>    // Get the length of the input string and verify that it is greater than zero. <br>    nCompLen = lstrlenA( pszValue); <br>    if( nCompLen &lt;= 0) <br>        RETURN( E_INVALIDARG); <br> <br>    // Initialize output parameter and return value. <br>    *pnIndex = NO_MATCH; <br>    hr = EDK_E_NOT_FOUND;   <br> <br>    // Search for the value. <br>    for( ii = 0; ii &lt; nArraySize; ii ++) <br>    { <br>        // Ignore NULL's in the array. <br>        if( rgpszArray[ ii] == NULL) <br>            continue; <br> <br>        // Compare value and entry in array.  The comparison is NOT case sensitive. <br>        if( _strnicmp( pszValue, rgpszArray[ ii], nCompLen) == 0) <br>        {   //  If no previous matches have been found, then remember <br>            //  the current array index.  If a match has already been <br>            //  found then abort. <br>            if( *pnIndex == NO_MATCH) <br>            {   // The first match has been found <br>                *pnIndex = ii; <br>                hr = NOERROR; <br>            } <br>            else <br>            {   // Second match, this is ambiguous. <br>                *pnIndex = NO_MATCH; <br> <br>                // Return the appropriate error. <br>                hr = EDK_E_AMBIGUOUS; <br> <br>                goto cleanup; <br>            } <br>        } <br>    } <br> <br>cleanup: <br>    // Don't use RETURN() since it would log EDK_E_NOT_FOUND as an error <br>    // and we don't wish to log this here. Let the caller do it if need be. <br>    return( hr); <br>} <br> <br> <br>//$--_HrExpandCommandLineArgument----------------------------------------------- <br>// <br>// DESCRIPTION: Expands abbreviated command line flags of the form -FLAG=VALUE (or <br>//              /FLAG=VALUE) to their full text forms returning the index of the   <br>//              matching flag and a pointer to the data part of the flag (ie the  <br>//              part after the equals sign).  The caller passes an array of known  <br>//              flag names, and the function tries to make an unambiguous match  <br>//              with one of the names.  In this way users can be offered the  <br>//              convenience of entering /V=Foo, instead of <br>//              /VERY-LONG-AND-CLUMSY-NAME=Foo (assuming no other flag begins with <br>//              V, otherwise the user might have to enter more letters). <br>// <br>//              The comparison is not case sensitive; the flag names /BLUTO and <br>//              -bluto are not distinguished, and /b might match on either of them. <br>// <br>//              To maintain greater compatibility with other Microsoft NT and DOS <br>//              command line applications, the ":" character may be substituted  <br>//              for the "=".  So /FLAG:VALUE or -FLAG:VALUE are also valid. <br>// <br>// <br>//  INPUT:  pszArg          command line flag <br>//          rgpszArgArray   array of known flag names (without leading dashes) <br>//          nArraySize      number of elements in rgpszArgArray <br>// <br>//  OUTPUT: pnFlagIndex     pointer to index of matching flag name, ~0 if no match. <br>//          ppszFlagName    pointer to known flag name. <br>//                          Either of the above output parameters may be NULL. <br>//          ppszArgData     pointer to flag data. (NULL is NOT okay) <br>// <br>//  RETURNS:    HRESULT     NOERROR if no error (value without flag is OK), <br>//                          E_INVALIDARG if bad input, <br>//                          EDK_E_NOT_FOUND if unknown flag name <br>//                          EDK_E_AMBIGUOUS if more than one match found. <br>//                          E_FAIL if user argument is too long. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT _HrExpandCommandLineArgument( <br>    IN  char*  pszArg,          // flag user entered <br>    IN  char** rgpszArgArray,   // array of known flag names (w/o leading dashes) <br>    IN  ULONG  nArraySize,      // number of known flags <br>    OUT ULONG* pnFlagIndex,     // ptr to index of known flag, -1 if no match found. <br>OUT char** ppszFlagName,// pointer to known flag name <br>    OUT char** ppszArgData)     // ptr to user data for flag <br>{ <br>    HRESULT hr                  = NOERROR; <br>    ULONG   nMatchIndex         = NO_MATCH; <br>    int     nCompLen            = 0; <br>    char*   pszSeparatorChar    = NULL; <br>    char    szArg[MAXARG + 1]  = ""; <br> <br>    DEBUGPUBLIC("_HrExpandCommandLineArgument()\n"); <br> <br>    // Check the input parameters <br>    hr = CHK__HrExpandCommandLineArgument( pszArg, rgpszArgArray, nArraySize, <br>                                            pnFlagIndex, ppszFlagName, ppszArgData); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Initialize output parameters.         <br>    if( pnFlagIndex) <br>        *pnFlagIndex = NO_MATCH; <br>    if( ppszFlagName) <br>        *ppszFlagName = NULL; <br>    *ppszArgData = NULL; <br> <br>    if (*pszArg != '-' &amp;&amp; *pszArg != '/') <br>    { <br>        // <br>        //  If this is not a flag parameter, set the argument <br>        //  data pointer to point to the beginning of the <br>        //  argument. <br>        // <br> <br>        *ppszArgData = pszArg; <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Advance beyond the flag introducer. <br>    // <br> <br>    ++pszArg; <br> <br>    // <br>    //  Look for an separator character ('=' or ':'), marking the end of the <br>    //  flag text and the start of the flag data.  Only use characters before  <br>    //  the separator character (if it is there) for matching. <br>    // <br> <br>    pszSeparatorChar = pszArg + strcspn(pszArg,"=:"); <br>    if (*pszSeparatorChar == 0) <br>        pszSeparatorChar = NULL; <br> <br>    if (pszSeparatorChar == NULL) <br>        nCompLen = lstrlenA(pszArg); <br>    else <br>        nCompLen = (pszSeparatorChar - pszArg); <br> <br>    // <br>    //  Abort if there is nothing to examine. <br>    // <br> <br>    if (nCompLen &lt;= 0) <br>    { <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br>        goto cleanup; <br>    } <br> <br> <br>    // If argument is not too long copy it into a buffer. <br>    if( nCompLen &gt; MAXARG) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br>    CopyMemory( szArg, pszArg, nCompLen); <br>    szArg[ nCompLen] = '\0'; <br>     <br> <br>    // Scan through the argument array looking for matches with the  <br>    // command line argument. <br>    hr = _HrFindArrayValue( szArg, rgpszArgArray, nArraySize, &amp;nMatchIndex); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Found the argument so set the output parameters. <br>    if (pszSeparatorChar != NULL) <br>        *ppszArgData = pszSeparatorChar + 1; <br>    if( pnFlagIndex) <br>        *pnFlagIndex = nMatchIndex; <br>    if( ppszFlagName) <br>        *ppszFlagName = rgpszArgArray[ nMatchIndex]; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--_nEcFromHr-------------------------------------------------------------- <br>// <br>// DESCRIPTION: <br>// <br>// Convert an HRESULT to an exit code suitable for return <br>// from a console application. <br>// <br>// NOTE: <br>// <br>// EDK HRESULTS get converted to their "code" (current 1 - 6). <br>// Any successful HRESULT converts to zero. <br>// Any EDK "approved" Win32 or OLE HRESULT gets converted <br>// to its EDK exit code (currently 11 - 15). <br>// Any non-EDK approved HRESULT gets converted to EC_EDK_E_UNKNOWN <br>// (currently 20).  See edkcode.h for definitions. <br>// <br>// INPUT:       hr  --  HRESULT to convert <br>// <br>// RETURNS:     INT --  see note above <br>// <br>//----------------------------------------------------------------------------- <br>INT _nEcFromHr(      // returns INT <br>            IN HRESULT hr)      // HRESULT to convert to exit code <br>{                       <br>    INT ec  =   0;              // console application exit code <br> <br>    DEBUGPUBLIC("_nEcFromHr()\n"); <br> <br>    // doesn't need a check function. <br>         <br>    if ( SCODE_FACILITY(hr) == <br>         FACILITY_EDK )        <br>    {                          <br>        // EDK HRESULT defined in edk.h <br>        // return HRESULT code. <br>        ec = SCODE_CODE(hr);  <br>        goto cleanup; <br>    }                          <br> <br>    // See if we have an "approved" EDK Win32 or OLE HRESULT     <br>    switch ( hr )              <br>    {                          <br>        case NOERROR: <br>            // Success!  Return standard "success" exit <br>            // code <br>            ec = 0; <br>            break; <br> <br>        case E_FAIL:           <br>            // return corresponding EDK exit code <br>            ec = EC_EDK_E_FAIL;  <br>            break; <br>                                   <br>        case E_INVALIDARG:         <br>            // return corresponding EDK exit code <br>            ec = EC_EDK_E_INVALIDARG; <br>            break; <br>                                          <br>        case E_NOTIMPL:                   <br>            // return corresponding EDK exit code <br>            ec = EC_EDK_E_NOTIMPL;      <br>            break; <br>                                          <br>        case E_NOINTERFACE:               <br>            // return corresponding EDK exit code <br>            ec = EC_EDK_E_NOINTERFACE;  <br>            break; <br>                                          <br>        case E_OUTOFMEMORY:               <br>            // return corresponding EDK exit code <br>            ec = EC_EDK_E_OUTOFMEMORY;  <br>            break; <br> <br>case E_ACCESSDENIED: <br>// return corresponding EDK exit code <br>ec = EC_EDK_E_ACCESSDENIED; <br>break; <br>                                          <br>        default:                          <br>            // Non-EDK approved HRESULT. <br>            // return "unknown" exit code. <br>            ec = EC_EDK_E_UNKNOWN; <br>            break; <br> <br>    }   // end switch <br> <br>cleanup: <br> <br>    // we are done <br>    return ec; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
