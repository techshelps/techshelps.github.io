<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPROP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1837"></a>IPROP.C</h2>
<pre><code>// --iprop.c-------------------------------------------------------------------- <br>//  <br>//  Module containing MAPI utility functions for properties. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include "iprop.chk" <br> <br>//$--HrMAPIOpenCachedProp-------------------------------------------------------- <br>// <br>//  DESCRIPTION: Create a new (local) IPropData object in which the original object <br>//  properties are cached.  The local cached can be created for <br>//  reading (for use with GetProp calls) for for writing (for use with <br>//  SetProp calls).  The purpose of this function and HrMAPICloseCachedProp <br>//  is to reduce the number of remote procedure calls made by code <br>//  which performs many GetProp or SetProp calls on an object. <br>// <br>//  INPUT:  lpObj   --  property object to cache <br>//          lpPropList  --  list of properties to cache (for reading) <br>//                          defaults to all properties if NULL. <br>//          ulFlags --  read OR write access flag (EDK_CACHE_READ <br>//                      or EDK_CACHE_WRITE) <br>//           <br>//  OUTPUT: lppCachedObj    --  cached property object <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>//  NOTE:   This function creates a cached object for reading only <br>//          or for writing only.  It does not support and object <br>//          for both reading and writing. <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIOpenCachedProp(            // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // source object <br>    IN LPSPropTagArray lpPropList,      // list of properties to cache <br>    IN ULONG ulFlags,                   // open for reading only or for writing only <br>OUT LPPROPDATA FAR * lppCachedObj)  // cached version of source object <br>{ <br>HRESULT             hr         = NOERROR; <br>LPSPropProblemArray lpProblems = NULL; <br>    LPSPropValue        lpPropVals = NULL; <br>    ULONG               ulPropCount= 0;     // number of properties <br> <br>    DEBUGPUBLIC("HrMAPIOpenCachedProp()\n"); <br> <br>    hr = CHK_HrMAPIOpenCachedProp( <br>        lpObj, <br>        lpPropList, <br>        ulFlags, <br>    lppCachedObj); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppCachedObj = NULL; <br> <br>    // <br>// Call CreateIProp() to create a new IPropData object. <br>// Since IPropData inherits from IMAPIProp, we can use it as our <br>// IMAPIProp cache pointer. <br>    // <br> <br>hr = CreateIProp( <br>    &amp;IID_IMAPIPropData, // interface type <br>MAPIAllocateBuffer,// allocation routine <br>    MAPIAllocateMore,   // allocate more routine <br>    MAPIFreeBuffer,     // deallocation routine <br>    0,                  // reserved <br>    lppCachedObj);      // address of pointer to new IPropData object <br> <br>   if(FAILED(hr)) <br>   { <br>hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>} <br> <br>    // If we are creating the cache for reading, then <br>    // we must populate the new object with properties.  <br>    // Otherwise, we pass an "empty" object back to the user <br>    // for property writing. <br>    if ( ulFlags == EDK_CACHE_READ ) <br>    { <br>        // Get properties from remote object and set these same properties <br>        // on the local object.   <br>        hr = MAPICALL(lpObj)-&gt;GetProps( <br>lpObj,                  // for C to C++ vtbl resolution <br>            lpPropList,             // Get all properties <br>            fMapiUnicode,           // flags <br>            &amp;ulPropCount,           // number of properties retrieved <br>            &amp;lpPropVals);           // property values structure pointer <br> <br>        // handle errors <br>        // If there is an error, release the cached object <br>        if ( FAILED(hr) || (hr == MAPI_W_ERRORS_RETURNED) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>                     <br>            goto cleanup; <br>        } <br> <br>        hr = MAPICALL(*lppCachedObj)-&gt;SetProps(*lppCachedObj, <br>                                               ulPropCount, <br>                                               lpPropVals, <br>                                               &amp;lpProblems); <br>       <br>        // handle errors <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup;     <br>        } <br> <br>        // Check to see if there were any problems setting the <br>        // properties <br>        if ( lpProblems != NULL ) <br>        { <br>            // We have an error <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br>    }   // end if creating cache for reading <br> <br>    // We have been successful. <br> <br>cleanup: <br> <br>    // Handle error case <br>    if ( FAILED(hr) ) <br>    { <br>        ULRELEASE(*lppCachedObj); <br>    } <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpProblems); <br>    MAPIFREEBUFFER(lpPropVals); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPICloseCachedProp------------------------------------------------------- <br>// <br>//  DESCRIPTION: If object was created as a write cache, <br>//               copy properties in local cached object <br>//               back to original remote object. <br>// <br>//  INPUT:  lpCachedObj --  cached property object <br>//          lpOriginalObj   --  original property object <br>//          ulFlags --  read cache or write cache flag (EDK_CACHE_READ <br>//                      or EDK_CACHE_WRITE) <br>// <br>//  OUTPUT: lppProblems --  set to the property problem array returned <br>//          by if there were problems setting properties on the original <br>//          object <br>// <br>//  NOTES:  lppProblems:  It may be set, even though overall call <br>//          is successful.  This is because all of the SetProps have been "deferred" on the <br>//          original object until this call, the user will need to evaluate <br>//          the contents of the lppProblems buffer pointer based on which <br>//          properties he/or she actually tried to set.   <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise <br>// <br>//                          lppProblems will only be valid if return code <br>//                          is NOERROR. <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPICloseCachedProp(           // RETURNS: return code <br>    IN LPPROPDATA lpCachedObj,          // cached property object <br>    IN LPMAPIPROP lpOriginalObj,        // original object <br>    IN ULONG ulFlags,                   // cache type (EDK_CACHE_READ or EDK_CACHE_WRITE) <br>    OUT LPSPropProblemArray FAR * lppProblems) // pointer to property problems array if problems setting properties <br>{ <br>HRESULT             hr          = NOERROR; <br>    ULONG               ulPropCount = 0;        // number of properties <br>    LPSPropValue        lpPropVals  = NULL;     // property values <br> <br>    DEBUGPUBLIC("HrMAPICloseCachedProp()\n"); <br> <br>    hr = CHK_HrMAPICloseCachedProp( <br>        lpCachedObj, <br>        lpOriginalObj, <br>        ulFlags, <br>        lppProblems); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppProblems = NULL;    // initialize output <br> <br>    // If the cache was opened for writing, copy all of the <br>    // properties from the cached object back to the original <br>    // object. <br>    if ( ulFlags == EDK_CACHE_WRITE ) <br>    { <br>        // Get properties from local object and set these same properties <br>        // on the remote object.  CopyTo() is not sufficient, because it <br>        // won't copy read-only properties. <br>        hr = MAPICALL(lpCachedObj)-&gt;GetProps( <br>lpCachedObj,            // for C to C++ vtbl resolution <br>            NULL,                   // get all properties <br>            fMapiUnicode,           // flags <br>            &amp;ulPropCount,           // number of properties retrieved <br>            &amp;lpPropVals);           // property values structure pointer <br> <br>        // handle errors <br>        if ( FAILED(hr) || (hr == MAPI_W_ERRORS_RETURNED) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Set all properties retrieved in the remote object         <br>        hr = MAPICALL(lpOriginalObj)-&gt;SetProps(lpOriginalObj, <br>                                               ulPropCount, <br>                                               lpPropVals, <br>                                               lppProblems); <br>       <br>        // handle errors <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br> <br>        } <br>    }   // end if cache created for writing <br> <br>    // The user will need to evaluate why the set property <br>    // call has failed (if *lppProblems has been set <br>    // by the SetProps call) based on what properties (if any) <br>    // they have set in the cached object. <br> <br>    // Overall, we have been successful. <br> <br>cleanup: <br> <br>    // Free MAPI buffers <br>    MAPIFREEBUFFER(lpPropVals); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGetPropString--------------------------------------------------------- <br>//  Get a string property.  <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIGetPropString(             // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    OUT ULONG *lpcbProp,                // count of bytes in property <br>    OUT LPVOID *lppvProp)               // pointer to property address variable <br>{ <br>    HRESULT      hr          = NOERROR; <br>    HRESULT      hrT         = NOERROR; <br>    ULONG        cValues     = 0; <br>    LPSPropValue lpPropValue = NULL; <br>    ULONG        cbProp      = 0; <br>    SCODE        sc          = 0; <br> <br>    SizedSPropTagArray(1, rgPropTag) = <br>    { <br>        1, <br>        { <br>            0 <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrMAPIGetPropString()\n"); <br> <br>    hr = CHK_HrMAPIGetPropString( <br>        lpObj, <br>        ulPropTag, <br>        lpcbProp, <br>        lppvProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcbProp = 0; <br>    *lppvProp = NULL; <br> <br>    rgPropTag.cValues = 1; <br>    rgPropTag.aulPropTag[0] = ulPropTag; <br> <br>    hrT = MAPICALL(lpObj)-&gt;GetProps( <br>         lpObj, <br>         (LPSPropTagArray)&amp;rgPropTag, <br>         fMapiUnicode, <br>         &amp;cValues, <br>         &amp;lpPropValue); <br> <br>    if(hrT == MAPI_W_ERRORS_RETURNED) <br>    { <br>        if((lpPropValue != NULL) &amp;&amp; (lpPropValue-&gt;Value.ul == MAPI_E_NOT_FOUND)) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        goto cleanup; <br>    } <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpPropValue = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(cValues != 0, "ZERO cValues variable"); <br> <br>    ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br> <br>    if(PROP_TYPE(ulPropTag) == PT_STRING8) <br>    { <br>        cbProp = ((lpPropValue-&gt;Value.lpszA == NULL) ? <br>            sizeof(CHAR) : <br>            cbStrLenA(lpPropValue-&gt;Value.lpszA)); <br>    } <br>    else <br>    { <br>        cbProp = ((lpPropValue-&gt;Value.lpszW == NULL) ? <br>            sizeof(WCHAR) : <br>            cbStrLenW(lpPropValue-&gt;Value.lpszW)); <br>    } <br> <br>    sc = MAPIAllocateBuffer(cbProp, lppvProp); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(*lppvProp != NULL, "NULL *lppvProp pointer"); <br> <br>    if(PROP_TYPE(ulPropTag) == PT_STRING8) <br>    { <br>        memcpy(*lppvProp, lpPropValue-&gt;Value.lpszA, cbProp); <br>    } <br>    else <br>    { <br>        memcpy(*lppvProp, lpPropValue-&gt;Value.lpszW, cbProp); <br>    } <br> <br>    *lpcbProp = cbProp; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropValue); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPISetPropString--------------------------------------------------------- <br>//  Set a string property.  <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPISetPropString(             // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    IN LPVOID lpvProp)                  // pointer to property <br>{ <br>    HRESULT    hr        = NOERROR; <br>    HRESULT    hrT       = NOERROR; <br>    ULONG      cValues   = 1; <br>    SPropValue PropValue = {0}; <br> <br>    DEBUGPUBLIC("HrMAPISetPropString()\n"); <br> <br>    hr = CHK_HrMAPISetPropString( <br>        lpObj, <br>        ulPropTag, <br>        lpvProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize SPropValue structure <br>    memset(&amp;PropValue, 0, sizeof(PropValue)); <br> <br>    PropValue.ulPropTag     = ulPropTag; <br> <br>    if(PROP_TYPE(ulPropTag) == PT_STRING8) <br>    { <br>        PropValue.Value.lpszA = (LPSTR)lpvProp; <br>    } <br>    else <br>    { <br>        PropValue.Value.lpszW = (LPWSTR)lpvProp; <br>    } <br> <br>    hrT = MAPICALL(lpObj)-&gt;SetProps( <br>        lpObj, <br>        cValues, <br>        &amp;PropValue, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGetPropBinary--------------------------------------------------------- <br>//  Get a binary property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIGetPropBinary(             // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    OUT ULONG *lpcbProp,                // count of bytes in property <br>    OUT LPVOID *lppvProp)               // pointer to property address variable <br>{ <br>    HRESULT      hr          = NOERROR; <br>    HRESULT      hrT         = NOERROR; <br>    ULONG        cValues     = 0; <br>    LPSPropValue lpPropValue = NULL; <br>    ULONG        cbProp      = 0; <br>    SCODE        sc          = 0; <br> <br>    SizedSPropTagArray(1, rgPropTag) = <br>    { <br>        1, <br>        { <br>            0 <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrMAPIGetPropBinary()\n"); <br> <br>    hr = CHK_HrMAPIGetPropBinary( <br>        lpObj, <br>        ulPropTag, <br>        lpcbProp, <br>        lppvProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcbProp = 0L; <br>    *lppvProp = NULL; <br> <br>    rgPropTag.cValues = 1; <br>    rgPropTag.aulPropTag[0] = ulPropTag; <br> <br>    hrT = MAPICALL(lpObj)-&gt;GetProps( <br>         lpObj, <br>         (LPSPropTagArray)&amp;rgPropTag, <br>         fMapiUnicode, <br>         &amp;cValues, <br>         &amp;lpPropValue); <br> <br>    if(hrT == MAPI_W_ERRORS_RETURNED) <br>    { <br>        if((lpPropValue != NULL) &amp;&amp; (lpPropValue-&gt;Value.ul == MAPI_E_NOT_FOUND)) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        goto cleanup; <br>    } <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpPropValue = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(cValues != 0, "ZERO cValues variable"); <br> <br>    ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br> <br>    cbProp = lpPropValue-&gt;Value.bin.cb; <br> <br>    sc = MAPIAllocateBuffer(cbProp, lppvProp); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(*lppvProp != NULL, "NULL *lppvProp pointer"); <br> <br>    // Copy property value <br>    memcpy(*lppvProp, lpPropValue-&gt;Value.bin.lpb, cbProp); <br> <br>    *lpcbProp = cbProp; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropValue); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPISetPropBinary--------------------------------------------------------- <br>//  Set a binary property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPISetPropBinary(             // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    IN ULONG cbProp,                    // count of bytes in property <br>    IN LPVOID lpvProp)                  // pointer to property <br>{ <br>    HRESULT    hr        = NOERROR; <br>    HRESULT    hrT       = NOERROR; <br>    ULONG      cValues   = 1; <br>    SPropValue PropValue = {0}; <br> <br>    DEBUGPUBLIC("HrMAPISetPropBinary()\n"); <br> <br>    hr = CHK_HrMAPISetPropBinary( <br>        lpObj, <br>        ulPropTag, <br>        cbProp, <br>        lpvProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize SPropValue structure <br>    memset(&amp;PropValue, 0, sizeof(PropValue)); <br> <br>    PropValue.ulPropTag     = ulPropTag; <br>    PropValue.Value.bin.cb  = cbProp; <br>    PropValue.Value.bin.lpb = (LPBYTE)lpvProp; <br> <br>    hrT = MAPICALL(lpObj)-&gt;SetProps( <br>        lpObj, <br>        cValues, <br>        &amp;PropValue, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGetPropBoolean-------------------------------------------------------- <br>//  Get a boolean property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIGetPropBoolean(            // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    OUT BOOL *lpfProp)                  // pointer to property variable <br>{ <br>    HRESULT      hr          = NOERROR; <br>    HRESULT      hrT         = NOERROR; <br>    ULONG        cValues     = 0; <br>    LPSPropValue lpPropValue = NULL; <br>    SCODE        sc          = 0; <br> <br>    SizedSPropTagArray(1, rgPropTag) = <br>    { <br>        1, <br>        { <br>            0 <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrMAPIGetPropBoolean()\n"); <br> <br>    hr = CHK_HrMAPIGetPropBoolean( <br>        lpObj, <br>        ulPropTag, <br>        lpfProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpfProp = FALSE; <br> <br>    rgPropTag.cValues = 1; <br>    rgPropTag.aulPropTag[0] = ulPropTag; <br> <br>    hrT = MAPICALL(lpObj)-&gt;GetProps( <br>         lpObj, <br>         (LPSPropTagArray)&amp;rgPropTag, <br>         fMapiUnicode, <br>         &amp;cValues, <br>         &amp;lpPropValue); <br> <br>    if(hrT == MAPI_W_ERRORS_RETURNED) <br>    { <br>        if((lpPropValue != NULL) &amp;&amp; (lpPropValue-&gt;Value.ul == MAPI_E_NOT_FOUND)) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        goto cleanup; <br>    } <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpPropValue = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(cValues != 0, "ZERO cValues variable"); <br> <br>    ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br> <br>    *lpfProp = (BOOL)(lpPropValue-&gt;Value.b); <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropValue); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPISetPropBoolean-------------------------------------------------------- <br>//  Set a boolean property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPISetPropBoolean(            // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    IN BOOL fProp)                      // property <br>{ <br>    HRESULT    hr        = NOERROR; <br>    HRESULT    hrT       = NOERROR; <br>    ULONG      cValues   = 1; <br>    SPropValue PropValue = {0}; <br> <br>    DEBUGPUBLIC("HrMAPISetPropBoolean()\n"); <br> <br>    hr = CHK_HrMAPISetPropBoolean( <br>        lpObj, <br>        ulPropTag, <br>        fProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize SPropValue structure <br>    ZeroMemory(&amp;PropValue, sizeof(PropValue)); <br> <br>    PropValue.ulPropTag = ulPropTag; <br>    PropValue.Value.b   = fProp; <br> <br>    hrT = MAPICALL(lpObj)-&gt;SetProps( <br>        lpObj, <br>        cValues, <br>        &amp;PropValue, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGetPropLong----------------------------------------------------------- <br>//  Get a long property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIGetPropLong(               // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    OUT ULONG *lpulProp)                // pointer to property variable <br>{ <br>    HRESULT      hr          = NOERROR; <br>    HRESULT      hrT         = NOERROR; <br>    ULONG        cValues     = 0; <br>    LPSPropValue lpPropValue = NULL; <br>    SCODE        sc          = 0; <br> <br>    SizedSPropTagArray(1, rgPropTag) = <br>    { <br>        1, <br>        { <br>            0 <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrMAPIGetPropLong()\n"); <br> <br>    hr = CHK_HrMAPIGetPropLong( <br>        lpObj, <br>        ulPropTag, <br>        lpulProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpulProp = 0; <br> <br>    rgPropTag.cValues = 1; <br>    rgPropTag.aulPropTag[0] = ulPropTag; <br> <br>    hrT = MAPICALL(lpObj)-&gt;GetProps( <br>         lpObj, <br>         (LPSPropTagArray)&amp;rgPropTag, <br>         fMapiUnicode, <br>         &amp;cValues, <br>         &amp;lpPropValue); <br> <br>    if(hrT == MAPI_W_ERRORS_RETURNED) <br>    { <br>        if((lpPropValue != NULL) &amp;&amp; (lpPropValue-&gt;Value.ul == MAPI_E_NOT_FOUND)) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        goto cleanup; <br>    } <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpPropValue = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(cValues != 0, "ZERO cValues variable"); <br> <br>    ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br> <br>    *lpulProp = lpPropValue-&gt;Value.ul; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropValue); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPISetPropLong----------------------------------------------------------- <br>//  Set a long property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPISetPropLong(               // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    IN ULONG ulProp)                    // property <br>{ <br>    HRESULT    hr        = NOERROR; <br>    HRESULT    hrT       = NOERROR; <br>    ULONG      cValues   = 1; <br>    SPropValue PropValue = {0}; <br> <br>    DEBUGPUBLIC("HrMAPISetPropLong()\n"); <br> <br>    hr = CHK_HrMAPISetPropLong( <br>        lpObj, <br>        ulPropTag, <br>        ulProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize SPropValue structure <br>    ZeroMemory(&amp;PropValue, sizeof(PropValue)); <br> <br>    PropValue.ulPropTag = ulPropTag; <br>    PropValue.Value.ul  = ulProp; <br> <br>    hrT = MAPICALL(lpObj)-&gt;SetProps( <br>        lpObj, <br>        cValues, <br>        &amp;PropValue, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGetPropSystime-------------------------------------------------------- <br>//  Get a systime property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIGetPropSystime(            // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    OUT LPFILETIME lpSystime)           // pointer to property variable <br>{ <br>    HRESULT      hr          = NOERROR; <br>    HRESULT      hrT         = NOERROR; <br>    ULONG        cValues     = 0; <br>    LPSPropValue lpPropValue = NULL; <br>    SCODE        sc          = 0; <br> <br>    SizedSPropTagArray(1, rgPropTag) = <br>    { <br>        1, <br>        { <br>            0 <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrMAPIGetPropSystime()\n"); <br> <br>    hr = CHK_HrMAPIGetPropSystime( <br>        lpObj, <br>        ulPropTag, <br>        lpSystime); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize FILETIME structure <br>    ZeroMemory(lpSystime, sizeof(FILETIME)); <br> <br>    rgPropTag.cValues = 1; <br>    rgPropTag.aulPropTag[0] = ulPropTag; <br> <br>    hrT = MAPICALL(lpObj)-&gt;GetProps( <br>         lpObj, <br>         (LPSPropTagArray)&amp;rgPropTag, <br>         fMapiUnicode, <br>         &amp;cValues, <br>         &amp;lpPropValue); <br> <br>    if(hrT == MAPI_W_ERRORS_RETURNED) <br>    { <br>        if((lpPropValue != NULL) &amp;&amp; (lpPropValue-&gt;Value.ul == MAPI_E_NOT_FOUND)) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        goto cleanup; <br>    } <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpPropValue = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(cValues != 0, "ZERO cValues variable"); <br> <br>    ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br> <br>    lpSystime-&gt;dwLowDateTime = lpPropValue-&gt;Value.ft.dwLowDateTime; <br>    lpSystime-&gt;dwHighDateTime = lpPropValue-&gt;Value.ft.dwHighDateTime; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropValue); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPISetPropSystime-------------------------------------------------------- <br>//  Set a systime property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPISetPropSystime(            // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    IN LPFILETIME lpSystime)            // pointer to property <br>{ <br>    HRESULT    hr        = NOERROR; <br>    HRESULT    hrT       = NOERROR; <br>    ULONG      cValues   = 1; <br>    SPropValue PropValue = {0}; <br> <br>    DEBUGPUBLIC("HrMAPISetPropSystime()\n"); <br> <br>    hr = CHK_HrMAPISetPropSystime( <br>        lpObj, <br>        ulPropTag, <br>        lpSystime); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Initialize SPropValue structure <br>    ZeroMemory(&amp;PropValue, sizeof(PropValue)); <br> <br>    PropValue.ulPropTag                 = ulPropTag; <br>    PropValue.Value.ft.dwLowDateTime    = lpSystime-&gt;dwLowDateTime; <br>    PropValue.Value.ft.dwHighDateTime   = lpSystime-&gt;dwHighDateTime; <br> <br>    hrT = MAPICALL(lpObj)-&gt;SetProps( <br>        lpObj, <br>        cValues, <br>        &amp;PropValue, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGetPropToFile--------------------------------------------------------- <br>//  Get a property and put in a given file. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIGetPropToFile(             // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    IN LPSTR lpszFilename,             // pointer to destination file name <br>    OUT ULONG *lpcbProp)                // pointer to count of bytes address <br>                                        // variable <br>{ <br>    HRESULT  hr             = NOERROR; <br>    HRESULT  hrT            = NOERROR; <br>    SCODE    sc             = 0; <br>    LPSTREAM lpStream       = NULL; <br>    HANDLE   hFile          = NULL; <br>    ULONG    ulBytesRead    = 0; <br>    LPBYTE   lpbBlock       = NULL; <br>    DWORD    dwBytesWritten = 0; <br> <br>    DEBUGPUBLIC("HrMAPIGetPropToFile()\n"); <br> <br>    hr = CHK_HrMAPIGetPropToFile( <br>        lpObj, <br>        ulPropTag, <br>        lpszFilename, <br>        lpcbProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Open a stream on the property <br>    hrT = MAPICALL(lpObj)-&gt;OpenProperty( <br>        lpObj, <br>        ulPropTag, <br>        (LPIID)&amp;IID_IStream, <br>        STGM_READ, <br>        MAPI_DEFERRED_ERRORS, <br>        (LPUNKNOWN *)&amp;lpStream); <br> <br>    if(FAILED(hrT)) <br>    { <br>        // Streams are not supported by provider <br>        if((hrT == MAPI_E_NO_SUPPORT) || (hrT == MAPI_E_INTERFACE_NOT_SUPPORTED)) <br>        { <br>            ULONG PropType = 0; <br> <br>            lpStream = NULL; <br> <br>            MODULE_WARNING1("Streams are not supported by provider [%08lx]",hrT); <br> <br>            PropType = PROP_TYPE(ulPropTag); <br> <br>            // Read property into memory             <br>            switch(PropType) <br>            { <br>            case PT_BINARY: <br>                hr = HrMAPIGetPropBinary( <br>                    lpObj, <br>                    ulPropTag, <br>                    &amp;ulBytesRead, <br>                    (void **)&amp;lpbBlock); <br>                break; <br>            default: <br>                hr = HrMAPIGetPropString( <br>                    lpObj, <br>                    ulPropTag, <br>                    &amp;ulBytesRead, <br>                    (void **)&amp;lpbBlock); <br>            } <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>    hFile = CreateFile( <br>        lpszFilename, <br>        GENERIC_WRITE, <br>        0, <br>        NULL, <br>        CREATE_ALWAYS, <br>        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, <br>        NULL); <br> <br>    if(hFile == INVALID_HANDLE_VALUE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    //  Copy propery value to the file <br>    if(lpStream != NULL) <br>    { <br>        sc = MAPIAllocateBuffer(EDK_CBTRANSFER, (void **)&amp;lpbBlock); </code></pre>
<p>
</p>
<pre><code><br>        // An error occured allocating the block buffer <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br> <br>        for (;;) <br>        { <br>            // Read a block from the stream <br>            hrT = OLECALL(lpStream)-&gt;Read( <br>                lpStream, <br>                lpbBlock, <br>                EDK_CBTRANSFER, <br>                &amp;ulBytesRead); <br> <br>            if(FAILED(hrT)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            if(ulBytesRead == 0L) <br>                break; <br> <br>            // Write the block to the file <br>            hr = _HrWriteFile(hFile, ulBytesRead, lpbBlock); <br> <br>            if(FAILED(hr)) <br>            { <br>                goto cleanup; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        // Write the block to the file <br>        hr = _HrWriteFile(hFile, ulBytesRead, lpbBlock); <br> <br>        if(FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br> <br>cleanup: <br> <br>    // Close the file <br>    if(hFile != NULL) <br>    { <br>        if(CloseHandle(hFile) == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    // Release the stream <br>    ULOLERELEASE(lpStream); <br> <br>    MAPIFREEBUFFER(lpbBlock); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPISetPropFromFile------------------------------------------------------- <br>//  Set a property from a given file. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPISetPropFromFile(           // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    IN LPSTR lpszFilename,             // pointer to source file name <br>    OUT ULONG *lpcbProp)                // pointer to count of bytes address <br>                                        // variable <br>{ <br>    HRESULT        hr             = NOERROR; <br>    HRESULT        hrT            = NOERROR; <br>    SCODE          sc             = 0; <br>    LPSTREAM       lpStream       = NULL; <br>    HFILE          hFile          = HFILE_ERROR; <br>    OFSTRUCT       ofStruct       = {0}; <br>    DWORD          dwBytesRead    = 0; <br>    LPBYTE         lpbBlock       = NULL; <br>    ULONG          ulBytesWritten = 0; <br>    ULARGE_INTEGER ll             = {0,0}; <br>    ULONG          ulFileSize     = 0; <br>    BYTE           bLastByte      = 0xFF; <br>    ULONG          cbProp         = 0; <br> <br>    DEBUGPUBLIC("HrMAPISetPropFromFile()\n"); <br> <br>    hr = CHK_HrMAPISetPropFromFile( <br>        lpObj, <br>        ulPropTag, <br>        lpszFilename, <br>        lpcbProp); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcbProp = 0; <br> <br>    // Open a stream on the property <br>    hrT = MAPICALL(lpObj)-&gt;OpenProperty( <br>        lpObj, <br>        ulPropTag, <br>        (LPIID)&amp;IID_IStream, <br>        STGM_DIRECT | STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, <br>        MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS, <br>        (LPUNKNOWN *)&amp;lpStream); <br> <br>    if(FAILED(hrT)) <br>    { <br>        // Streams are not supported by provider <br>        if((hrT == MAPI_E_NO_SUPPORT) || (hrT == MAPI_E_INTERFACE_NOT_SUPPORTED)) <br>        { <br>            lpStream = NULL; <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    hFile = OpenFile( <br>        lpszFilename, <br>        &amp;ofStruct, <br>        OF_READ); <br> <br>    if(hFile == HFILE_ERROR) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get file size <br>    if((ulFileSize = GetFileSize((HANDLE)hFile, NULL)) == (DWORD)HFILE_ERROR) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if(PROP_TYPE(ulPropTag) == PT_UNICODE) <br>    { <br>        if((ulFileSize % sizeof(wchar_t)) != 0) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    cbProp = ulFileSize; <br> <br>    //  Copy propery value to the file <br>    if(lpStream != NULL) <br>    { <br>        // Allocate memory for the block buffer <br>        sc = MAPIAllocateBuffer(EDK_CBTRANSFER, (void **)&amp;lpbBlock); <br> <br>        // An error occured allocating the block buffer <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>            goto cleanup; <br>        } <br> <br>        ll.LowPart  = ulFileSize; <br>        ll.HighPart = 0L; <br> <br>        hrT = OLECALL(lpStream)-&gt;SetSize(lpStream, ll); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        for (;;) <br>        { <br>            BOOL    fStatus; <br> <br>            // Read a block from the file <br>            fStatus = ReadFile( <br>                (HANDLE)hFile, <br>                lpbBlock, <br>                EDK_CBTRANSFER, <br>                &amp;dwBytesRead, <br>                NULL); <br> <br>            if(fStatus == FALSE) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            if(dwBytesRead == 0L) <br>                break; <br> <br>            bLastByte = lpbBlock[dwBytesRead - 1L]; <br> <br>            // Write a block to the stream <br>            hrT = OLECALL(lpStream)-&gt;Write( <br>                lpStream, <br>                lpbBlock, <br>                dwBytesRead, <br>                &amp;ulBytesWritten); <br> <br>            if(FAILED(hrT)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            if(ulBytesWritten &lt; dwBytesRead) <br>            { <br>                hr = HR_LOG(MAPI_E_NOT_ENOUGH_DISK); <br>                goto cleanup; <br>            } <br>        } <br> <br>        if((PROP_TYPE(ulPropTag) == PT_STRING8) || <br>           (PROP_TYPE(ulPropTag) == PT_UNICODE)) <br>        { <br>            // NULL terminate if not already <br>            if(bLastByte != 0) <br>            { <br>                // Initialize with enough zeroes for a NULL character <br>                ZeroMemory(lpbBlock, sizeof(wchar_t)); <br> <br>                if(PROP_TYPE(ulPropTag) == PT_UNICODE) <br>                { <br>                    dwBytesRead = sizeof(wchar_t); <br>                } <br>                else <br>                { <br>                    dwBytesRead = 1L; <br>                } <br> <br>                ulBytesWritten = 0L; <br> <br>                // Write a block to the stream <br>                hrT = OLECALL(lpStream)-&gt;Write( <br>                    lpStream, <br>                    lpbBlock, <br>                    dwBytesRead, <br>                    &amp;ulBytesWritten); <br> <br>                if(FAILED(hrT)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br> <br>                if(ulBytesWritten &lt; dwBytesRead) <br>                { <br>                    hr = HR_LOG(MAPI_E_NOT_ENOUGH_DISK); <br>                    goto cleanup; <br>                } <br> <br>                cbProp += ulBytesWritten; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        BOOL  fStatus  = FALSE; <br>        ULONG PropType = 0; <br> <br>        // Allocate the memory for the property value <br>        sc = MAPIAllocateBuffer( <br>            ulFileSize + 2 * sizeof(wchar_t), <br>            (void **)&amp;lpbBlock); <br> <br>        // An error occured allocating the block buffer <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Read the property value into memory <br>        fStatus = ReadFile( <br>            (HANDLE)hFile, <br>            lpbBlock, <br>            ulFileSize, <br>            &amp;dwBytesRead, <br>            NULL); <br> <br>        if(fStatus == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Check if the entire file was read <br>        if(dwBytesRead != ulFileSize) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        if((PROP_TYPE(ulPropTag) == PT_STRING8) || <br>           (PROP_TYPE(ulPropTag) == PT_UNICODE)) <br>        { <br>            // NULL terminate if not already <br>            bLastByte = lpbBlock[dwBytesRead - 1L]; <br> <br>            if(bLastByte != 0) <br>            { <br>                if(PROP_TYPE(ulPropTag) == PT_UNICODE) <br>                { <br>                    ((wchar_t *)lpbBlock)[dwBytesRead/sizeof(wchar_t)] = '\0'; <br>                    ulFileSize += sizeof(wchar_t); <br>                } <br>                else <br>                { <br>                    lpbBlock[dwBytesRead] = 0; <br>                    ulFileSize++; <br>                } <br> <br>                cbProp = ulFileSize; <br>            } <br>        } <br> <br>        PropType = PROP_TYPE(ulPropTag); <br> <br>        // Set property <br>        switch(PropType) <br>        { <br>        case PT_BINARY: <br>            hr = HrMAPISetPropBinary( <br>                lpObj, <br>                ulPropTag, <br>                ulFileSize, <br>                &amp;lpbBlock); <br>            break; <br>        default: <br>            hr = HrMAPISetPropString( <br>                lpObj, <br>                ulPropTag, <br>                &amp;lpbBlock); <br>        } <br>    } <br> <br> <br>cleanup: <br> <br>    // Close the file <br>    if(hFile != HFILE_ERROR) <br>    { <br>        if(CloseHandle((HANDLE)hFile) == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    // Release the stream <br>    ULOLERELEASE(lpStream); <br> <br>    MAPIFREEBUFFER(lpbBlock); <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>        *lpcbProp = cbProp; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIOpenStreamOnProperty------------------------------------------------- <br>//  Open a stream on a given property. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIOpenStreamOnProperty(      // RETURNS: return code <br>    IN LPMAPIPROP lpObj,                // pointer to object <br>    IN ULONG ulPropTag,                 // property tag <br>    IN ULONG ulFlags,                   // flags (MAPI_CREATE and/or MAPI_MODIFY) <br>    OUT LPSTREAM *lppStream)            // pointer to stream address variable <br>{ <br>    HRESULT  hr          = NOERROR; <br>    HRESULT  hrT         = NOERROR; <br>    LPSTREAM lpStream    = NULL; <br>    ULONG    ulStgmFlags = STGM_READ; <br> <br>    DEBUGPUBLIC("HrMAPIOpenStreamOnProperty()\n"); <br> <br>    hr = CHK_HrMAPIOpenStreamOnProperty( <br>        lpObj, <br>        ulPropTag, <br>        ulFlags, <br>        lppStream); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppStream = NULL; <br> <br>    if(ulFlags &amp; MAPI_CREATE) <br>    { <br>        ulStgmFlags |= STGM_CREATE; <br>    } <br> <br>    if(ulFlags &amp; MAPI_MODIFY) <br>    { <br>        ulStgmFlags |= STGM_WRITE; <br>    } <br> <br>    hrT = MAPICALL(lpObj)-&gt;OpenProperty( <br>        lpObj, <br>        ulPropTag, <br>        (LPIID)&amp;IID_IStream, <br>        STGM_DIRECT | STGM_SHARE_EXCLUSIVE | ulStgmFlags, <br>        MAPI_DEFERRED_ERRORS | ulFlags, <br>        (LPUNKNOWN *)&amp;lpStream); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    *lppStream = lpStream; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIAppendSPropValues----------------------------------------------------- <br>//  Append one set of SPropValue's to another. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIAppendSPropValues(         // RETURNS: return code <br>    IN ULONG cHeadProps,                // count of property values in head <br>    IN LPSPropValue lpHeadProps,        // pointer to property values in <br>                                        // head <br>    IN ULONG cTailProps,                // count of property values in tail <br>    IN LPSPropValue lpTailProps,        // pointer to property values in <br>                                        // tail <br>    OUT ULONG *lpcNewProps,             // pointer to count of property <br>                                        // values <br>    OUT LPSPropValue *lppNewProps)      // pointer to property values  <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    SCODE           sc                  = 0; <br>    ULONG           cNewProps           = 0; <br>    LPSPropValue    lpTmpProps          = NULL; <br>    LPSPropValue    lpNewProps          = NULL; <br>    ULONG           cBytes              = 0; <br>    ULONG           i                   = 0; <br>    ULONG           j                   = 0; <br> <br>    DEBUGPUBLIC("HrMAPIAppendSPropValues()\n"); <br> <br>    hr = CHK_HrMAPIAppendSPropValues( <br>        cHeadProps, <br>        lpHeadProps, <br>        cTailProps, <br>        lpTailProps, <br>        lpcNewProps, <br>        lppNewProps); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcNewProps = 0; <br>    *lppNewProps = NULL; <br> <br>    cNewProps = cHeadProps + cTailProps; <br> <br>    cBytes = CbSPropValue(cNewProps); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)&amp;lpTmpProps); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    // Copy existing property values <br>    for(i = 0; i &lt; cHeadProps; i++) <br>    { <br>        lpTmpProps[i] = lpHeadProps[i]; <br>    } <br> <br>    for(i = cHeadProps, j = 0; i &lt; cNewProps; i++, j++) <br>    { <br>        lpTmpProps[i] = lpTailProps[j]; <br>    } <br> <br>    sc = ScDupPropset( <br>        cNewProps, <br>        lpTmpProps, <br>MAPIAllocateBuffer, <br>&amp;lpNewProps); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    *lpcNewProps = cNewProps; <br>    *lppNewProps = lpNewProps; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpTmpProps); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIMoveOneProp----------------------------------------------------------- <br>//  Move one property from a source object to a destination object. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIMoveOneProp(               // RETURNS: return code <br>    IN LPMAPIPROP lpSrcObj,             // pointer to source object <br>    IN ULONG ulSrcPropTag,              // source property tag <br>    IN ULONG ulDstPropTag,              // destination property tag <br>    IN BOOL IsMust,                     // TRUE if a required property <br>    IN BOOL IsReplace,                  // TRUE if existing destination <br>                                        // property can be replaced <br>    IN OUT LPMAPIPROP lpDstObj)         // pointer to destination object <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    HRESULT         hrT                 = NOERROR; <br>    SCODE           sc                  = 0; <br>    ULONG           cProps              = 0; <br>    LPSPropValue    lpProps             = NULL; <br>    SizedSPropTagArray(1, rgPropTag)    = { 1, 0 }; <br> <br>    DEBUGPUBLIC("HrMAPIMoveOneProp()\n"); <br> <br>    hr = CHK_HrMAPIMoveOneProp( <br>        lpSrcObj, <br>        ulSrcPropTag, <br>        ulDstPropTag, <br>        IsMust, <br>        IsReplace, <br>        lpDstObj); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if(PROP_TYPE(ulSrcPropTag) != PROP_TYPE(ulDstPropTag)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if((IsReplace == FALSE) &amp;&amp; FPropExists(lpDstObj, ulDstPropTag)) <br>    { <br>        MODULE_WARNING("Destination property exists and not overwritten."); <br> <br>        goto cleanup; <br>    } <br> <br>    rgPropTag.cValues = 1; <br>    rgPropTag.aulPropTag[0] = ulSrcPropTag; <br> <br>    hrT = MAPICALL(lpSrcObj)-&gt;GetProps( <br>        lpSrcObj, <br>        (LPSPropTagArray)&amp;rgPropTag, <br>        fMapiUnicode, <br>        &amp;cProps, <br>        &amp;lpProps); <br> <br>    if(hrT == MAPI_W_ERRORS_RETURNED) <br>    { <br>        hrT = lpProps-&gt;Value.ul; <br> <br>        if(hrT != MAPI_E_NOT_FOUND) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        else if(IsMust == TRUE) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_FOUND); <br>        } <br> <br>        goto cleanup; <br>    } <br> <br>    if(FAILED(hrT)) <br>    { <br>        lpProps = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(cProps != 0, "ZERO cProps variable"); <br> <br>    ASSERTERROR(lpProps != NULL, "NULL lpProps variable"); <br> <br>    lpProps-&gt;ulPropTag = ulDstPropTag; <br> <br>    hrT = MAPICALL(lpDstObj)-&gt;SetProps( <br>        lpDstObj, <br>        cProps, <br>        lpProps, <br>        NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br>          <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpProps); <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
