<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VSOF.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1853"></a>VSOF.C</h2>
<pre><code>//--vsof.c--------------------------------------------------------------------- <br>// <br>// This file contains methods and code for implementing an OLE 2.0 <br>// storage stream (as defined in the OLE 2.0 specs) on top of OS file. <br>// <br>// Copyright 1986-1996.  Microsoft Corporation.  All Rights Reserved. <br>// <br>// Notes: <br>// <br>// Specifying STGM_DELETEONRELEASE makes the file opened a temporary file (It <br>// will be deleted when the stream is released). <br>// <br>// Specifying STGM_SHARE_EXCLUSIVE makes the file writable by only one application <br>// at a time. <br>// <br>//----------------------------------------------------------------------------- <br>#include "edk.h" <br>#include "_vsof.h" <br>#include "vsof.chk" <br> <br>//$--ComputeShareFlags--------------------------------------------------------------- <br>// <br>// DESCRIPTION:computes the file share flags based on the stream share flags. <br>// <br>// INPUT:ulFlags--stream flags <br>// <br>// RETURNS:DWORD--file share flags <br>// <br>//----------------------------------------------------------------------------- <br>static __inline DWORD dwComputeShareFlags( <br>IN ULONG ulFlags)// stream flags <br>{ <br>// By default, the file created is shareable for reading &amp; writing <br>DWORDfdwShare=FILE_SHARE_READ | FILE_SHARE_WRITE; <br> <br>// Determine if concurrent access to file is restricted <br>if ( ulFlags &amp; STGM_SHARE_EXCLUSIVE ) <br>{ <br>fdwShare = 0;// file not to be shared at all <br>} <br> <br>else  <br>{ <br>if ( ulFlags &amp; STGM_SHARE_DENY_WRITE ) <br>{ <br>fdwShare &amp;= ~FILE_SHARE_WRITE;// don't allow sharing on writes <br>} <br> <br>if ( ulFlags &amp; STGM_SHARE_DENY_READ ) <br>{ <br>fdwShare &amp;= ~FILE_SHARE_READ;// don't allow sharing on reads <br>} <br>}// end if not exclusive access file <br> <br>// We are done <br> <br>return fdwShare; <br> <br>} <br> <br>//$--ScGetVSOFFilename--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Get virtual stream on file file name <br>// <br>// INPUT:lpszPath--file path <br>//lpszPrefix--file prefix <br>//lpszBuf--file name output buffer <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//E_INVALIDARG if bad input, <br>//E_FAIL otherwise <br>// <br>//----------------------------------------------------------------------------- <br>HRESULT ScGetVSOFFilename ( <br>IN LPSTR lpszPath, // file path <br>IN LPSTR lpszPrefix, // file name prefix <br>IN LPSTR lpszBuf)// file name output buffer <br>{ <br>HRESULThr=NOERROR; <br>CHARrgchPath[MAX_PATH]= {0}; <br> <br>DEBUGPRIVATE("ScGetVSOFFilename()\n"); <br> <br>// check input parameters <br>hr = CHK_ScGetVSOFFilename(lpszPath, lpszPrefix, lpszBuf); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>if (lpszPrefix == NULL) <br>{ <br>lpszPrefix = VSOF_DEFAULT_PREFIX; <br>} <br> <br>if (!lpszPath) <br>{ <br>if (!GetTempPath (MAX_PATH, rgchPath)) <br>{ <br>//Init the Path to the current directory (".") <br>// <br>rgchPath[0] = '.'; <br>rgchPath[1] = 0; <br>} <br>lpszPath = rgchPath; <br>} <br> <br>if (!GetTempFileName32 (lpszPath, lpszPrefix, 0, lpszBuf)) <br>{ <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--MakeReal------------------------------------------------------------------ <br>// <br>// DESCRIPTION:Create a "real" temporary file. <br>// <br>// INPUT:vhFile--virtual file handle <br>// <br>// RETURNS:BOOL <br>// <br>// NOTES:This function is only called when it is necessary to make a in-buffer <br>// temporary file real. <br>// <br>//----------------------------------------------------------------------------- <br>#ifndef DEBUG <br>__inline <br>#endif <br>BOOL MakeReal(// RETURNS: BOOL <br>IN VSOF_HANDLE vhFile)// virtual file handle <br>{ <br>HRESULThr =NOERROR; <br>BOOLfMadeReal=FALSE;// TRUE if file made real <br>    charszPath[MAX_PATH]=""; <br>    char *lpszPath=NULL; <br>    char   szPrefix[MAX_PATH]=""; <br>    char *lpszPrefix=NULL; <br>    char *p=NULL; <br>    DWORD dwSizeWritten=0; <br>DWORDfdwShare=0;// share flags for created file <br> <br>const DWORDfdwAttr=FILE_ATTRIBUTE_TEMPORARY |  <br>FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_SEQUENTIAL_SCAN;; <br> <br>DEBUGPRIVATE("MakeReal()\n"); <br> <br>    if (lstrlen(vhFile-&gt;rgchFile) &gt;= MAX_PATH)  <br>    { <br>        SetLastError(ERROR_INVALID_PARAMETER); <br>hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    lstrcpy(szPath, vhFile-&gt;rgchFile); <br>     <br>    p = lstrlen(vhFile-&gt;rgchFile)+vhFile-&gt;rgchFile+1; <br>    if (lstrlen(p) &gt;= MAX_PATH)  <br>    { <br>        SetLastError(ERROR_INVALID_PARAMETER); <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br>    lstrcpy(szPrefix, p); <br>    lpszPath = szPath; <br>    lpszPrefix = szPrefix; <br>     <br>    if (!lstrlen(szPath)) <br>        lpszPath = NULL; <br>    if (!lstrlen(szPrefix)) <br>        lpszPrefix = NULL; <br> <br>    if (ScGetVSOFFilename (lpszPath, lpszPrefix, vhFile-&gt;rgchFile)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Determine whether this file will have concurrent access. <br>fdwShare = dwComputeShareFlags(vhFile-&gt;ulFlags); <br> <br>// Create a temporary file for writing (this function is only <br>// called for temporary files!)     <br>    vhFile-&gt;hf = CreateFile (vhFile-&gt;rgchFile, <br>                             GENERIC_READ | GENERIC_WRITE, <br> fdwShare, <br>                             NULL, <br>                             CREATE_ALWAYS, <br>     fdwAttr, <br>                             NULL); <br> <br>if (vhFile-&gt;hf == INVALID_HANDLE_VALUE) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>    if (vhFile-&gt;ulFileSize)  <br>    { <br>        if (!WriteFile(vhFile-&gt;hf, vhFile-&gt;lpvVBuff, vhFile-&gt;ulFileSize, <br>                       &amp;dwSizeWritten, NULL)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>        else if (dwSizeWritten != vhFile-&gt;ulFileSize) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>    } <br>     <br>    if (SetFilePointer(vhFile-&gt;hf, vhFile-&gt;ulFilePointer, NULL, FILE_BEGIN) == <br>        0xFFFFFFFF) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// The file is now real. <br>fMadeReal = TRUE; <br> <br>// We are done. <br> <br>cleanup: <br>     <br>    return fMadeReal; <br> <br>} <br> <br>//$--VSOF_SetFilePointer------------------------------------------------------- <br>// <br>// DESCRIPTION:performs seek <br>// <br>// INPUT:vhFile--virtual file handle <br>//lDistanceToMove--distance to move <br>//lpDistanceToMoveHigh-- pointer to 64-bit distance to move <br>//dwMoveMethod--origin <br>// <br>// RETURNS:DWORD-- new file position or error code <br>// <br>//----------------------------------------------------------------------------- <br>#ifndef DEBUG <br>__inline <br>#endif <br>DWORD VSOF_SetFilePointer(// RETURNS: DWORD <br>IN VSOF_HANDLE vhFile,// file handle <br>    IN LONG lDistanceToMove,// distance to move <br>    IN PLONG lpDistanceToMoveHigh,// pointer to 64 bit distance to move <br>    IN DWORD dwMoveMethod// origin <br>    ) <br>{    <br>HRESULThr=NOERROR; <br>DWORDposNew=SET_FILE_POINTER_ERROR;// error code <br> <br>DEBUGPRIVATE("VSOF_SetFilePointer()\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_SetFilePointer(vhFile, lDistanceToMove, lpDistanceToMoveHigh,  <br>                             dwMoveMethod); <br> <br>if ( FAILED(hr) ) <br>{ <br>SetLastError(ERROR_INVALID_PARAMETER); <br> <br>return SET_FILE_POINTER_ERROR; <br>} <br> <br>    if (vhFile-&gt;hf != INVALID_HANDLE_VALUE) <br>{ <br>        goto NonVirtual; <br>} <br>     <br>    if (lpDistanceToMoveHigh &amp;&amp; *lpDistanceToMoveHigh)  <br>    { <br>        if (!MakeReal(vhFile)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>        else <br>{ <br>            goto NonVirtual; <br>} <br>    } <br>     <br>    switch (dwMoveMethod)  <br>    { <br>    case FILE_BEGIN: <br>        if (lDistanceToMove &gt;= (long)vhFile-&gt;dwVirtualBufferSize)  <br>        { <br>            if (!MakeReal(vhFile)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>            else <br>{ <br>                goto NonVirtual;             <br>} <br>        }  <br>        else if (lDistanceToMove &lt; 0)  <br>        { <br>            SetLastError(ERROR_INVALID_PARAMETER); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>        }         <br>        vhFile-&gt;ulFilePointer = lDistanceToMove; <br>        break; <br>    case FILE_CURRENT: <br>        if ((lDistanceToMove+(long)vhFile-&gt;ulFilePointer) &gt;= (long)vhFile-&gt;dwVirtualBufferSize)  <br>        { <br>            if (!MakeReal(vhFile)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>            else <br>{ <br>                goto NonVirtual;             <br>} <br>        }  <br>        else if ((lDistanceToMove+(long)vhFile-&gt;ulFilePointer) &lt; 0)  <br>        { <br>hr = HR_LOG(E_FAIL); <br>            SetLastError(ERROR_INVALID_PARAMETER); <br>goto cleanup; <br>        }         <br>        vhFile-&gt;ulFilePointer = lDistanceToMove+(long)vhFile-&gt;ulFilePointer; <br>        break; <br>    case FILE_END: <br>        if ((lDistanceToMove+(long)vhFile-&gt;ulFileSize) &gt;= (long)vhFile-&gt;dwVirtualBufferSize)  <br>        { <br>            if (!MakeReal(vhFile)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>            else <br>{ <br>                goto NonVirtual; <br>} <br>        }  <br>        else if ((lDistanceToMove+(long)vhFile-&gt;ulFileSize) &lt; 0)  <br>        { <br>            SetLastError(ERROR_INVALID_PARAMETER); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>        } <br>        vhFile-&gt;ulFilePointer = lDistanceToMove + (long)vhFile-&gt;ulFileSize; <br>        break; <br>    default: <br>        SetLastError(ERROR_INVALID_PARAMETER); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>// Return new file position. <br>posNew = vhFile-&gt;ulFilePointer; <br> <br>goto cleanup; <br>     <br>NonVirtual: <br>// real file <br>    posNew = SetFilePointer( <br>    vhFile-&gt;hf, <br>        lDistanceToMove, <br>        lpDistanceToMoveHigh, <br>        dwMoveMethod); <br> <br>goto cleanup; <br> <br>cleanup: <br> <br>return posNew; <br> <br>} <br> <br>//$--VSOF_SetEndOfFile--------------------------------------------------------- <br>// <br>// DESCRIPTION:set end of file <br>// <br>// INPUT:vhFile--virtual file handle <br>// <br>// RETURNS:BOOL <br>// <br>//----------------------------------------------------------------------------- <br>#ifndef DEBUG <br>__inline <br>#endif <br>BOOL VSOF_SetEndOfFile(// RETURNS BOOL <br>    IN VSOF_HANDLE vhFile// virtual file handle <br>    ) <br>{ <br>BOOLfSet=FALSE;// TRUE if successful <br> <br>DEBUGPRIVATE("VSOF_SetEndOfFile()\n"); <br> <br>    if (vhFile-&gt;hf != INVALID_HANDLE_VALUE) <br>{ <br>        goto NonVirtual; <br>} <br>     <br>    vhFile-&gt;ulFileSize = vhFile-&gt;ulFilePointer; <br> <br>fSet = TRUE; <br> <br>    goto cleanup; <br>     <br>NonVirtual: <br>// real file <br>    fSet = SetEndOfFile(vhFile-&gt;hf); <br> <br>goto cleanup; <br> <br>cleanup: <br> <br>return fSet; <br> <br>} <br> <br>//$--VSOF_FlushFileBuffers----------------------------------------------------- <br>// <br>// DESCRIPTION:Flushes buffered data to file. <br>// <br>// INPUT:vhFile--virtual file handle <br>// <br>// RETURNS:BOOL-- TRUE if successful, FALSE otherwise. <br>// <br>//----------------------------------------------------------------------------- <br>#ifndef DEBUG <br>__inline <br>#endif <br>BOOL VSOF_FlushFileBuffers(// RETURNS: BOOL <br>    IN VSOF_HANDLE vhFile// virtual file handle <br>    ) <br>{ <br>HRESULThr=NOERROR; <br>BOOLfFlushed=FALSE;// TRUE if flushed <br> <br>DEBUGPRIVATE("VSOF_FlushFileBuffers()\n"); <br> <br>    if (vhFile-&gt;hf != INVALID_HANDLE_VALUE) <br>{ <br>        goto NonVirtual; <br>} <br>    if (!MakeReal(vhFile)) <br>{ <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br> <br>// Fall through! <br> <br>NonVirtual: <br>// real file <br>    fFlushed = FlushFileBuffers(vhFile-&gt;hf); <br> <br>goto cleanup; <br> <br>cleanup: <br> <br>return fFlushed; <br> <br>} <br> <br>//$--VSOF_ReadFile------------------------------------------------------------- <br>// <br>// DESCRIPTION:Read from file/buffer <br>// <br>// INPUT:vhFile--virtual file handle <br>//lpBuffer--output buffer <br>//nNumberOfBytesToRead--# bytes to read <br>//lpNumberOfBytesRead--# bytes read <br>//lpOverlapped <br>// <br>// RETURNS:BOOL <br>// <br>//----------------------------------------------------------------------------- <br>#ifndef DEBUG <br>__inline <br>#endif <br>BOOL VSOF_ReadFile(// RETURNS: BOOL <br>    IN VSOF_HANDLE vhFile,// virtual file handle <br>    IN LPVOID lpBuffer,// output buffer <br>    IN DWORD nNumberOfBytesToRead,// # bytes to read <br>    OUT LPDWORD lpNumberOfBytesRead,// # bytes read <br>    OUT LPOVERLAPPED lpOverlapped <br>    ) <br>{ <br>HRESULThr=NOERROR; <br>BOOLfRead=FALSE;// TRUE if successful <br> <br>DEBUGPRIVATE("VSOF_ReadFile()"); <br> <br>hr = CHK_VSOF_ReadFile(vhFile, lpBuffer, nNumberOfBytesToRead, <br>                       lpNumberOfBytesRead, lpOverlapped); <br> <br>if ( FAILED(hr) ) <br>{ <br>SetLastError(ERROR_INVALID_PARAMETER); <br> <br>return FALSE; <br>} <br> <br>    if (vhFile-&gt;hf != INVALID_HANDLE_VALUE) <br>{ <br>        goto NonVirtual; <br>} <br>     <br>// Initialize output parameters <br>*lpNumberOfBytesRead = 0; <br>if ( lpOverlapped != NULL ) <br>{ <br>ZeroMemory(lpOverlapped, sizeof(OVERLAPPED)); <br>} <br>     <br>    if (!nNumberOfBytesToRead)  <br>    { <br>        *lpNumberOfBytesRead = 0; <br>        fRead = TRUE; <br>goto cleanup; <br>    } <br>         <br>    if (vhFile-&gt;ulFilePointer &gt;= vhFile-&gt;ulFileSize)  <br>    { <br>        *lpNumberOfBytesRead = 0; <br>fRead = TRUE;// EOF for synchronous read <br>goto cleanup; <br>    } <br>         <br>    // Take which ever is less. <br>    *lpNumberOfBytesRead = nNumberOfBytesToRead &lt; <br>        (vhFile-&gt;ulFileSize - vhFile-&gt;ulFilePointer) ? <br>        nNumberOfBytesToRead : (vhFile-&gt;ulFileSize - vhFile-&gt;ulFilePointer); <br>     <br>    CopyMemory(lpBuffer, ((unsigned char*)vhFile-&gt;lpvVBuff) + <br>               vhFile-&gt;ulFilePointer,  <br>               *lpNumberOfBytesRead); <br>     <br>    vhFile-&gt;ulFilePointer += *lpNumberOfBytesRead;  // update file pointer. <br> <br>fRead = TRUE;     <br> <br>goto cleanup; <br>     <br>NonVirtual: <br>// real file <br>    fRead = ReadFile( <br>    vhFile-&gt;hf, <br>        lpBuffer, <br>        nNumberOfBytesToRead, <br>        lpNumberOfBytesRead, <br>        lpOverlapped); <br> <br>goto cleanup; <br> <br>cleanup: <br> <br>return fRead; <br> <br>} <br> <br>//$--VSOF_WriteFile------------------------------------------------------------ <br>// <br>// DESCRIPTION:Writes buffer to file. <br>// <br>// INPUT:vhFile--file handle <br>//lpBuffer--input buffer <br>//nNumberOfBytesToWrite--# bytes to write <br>//lpNumberOfBytesWritten--# bytes written <br>//lpOverlapped--overlapped <br>// <br>// RETURNS:BOOL--TRUE if successful <br>// <br>//----------------------------------------------------------------------------- <br>#ifndef DEBUG <br>__inline <br>#endif <br>BOOL VSOF_WriteFile(// RETURNS: BOOL <br>    IN VSOF_HANDLE vhFile,// file handle <br>    IN LPCVOID lpBuffer,// input buffer <br>    IN DWORD nNumberOfBytesToWrite,// # bytes to write <br>    OUT LPDWORD lpNumberOfBytesWritten,// # bytes written <br>    OUT LPOVERLAPPED lpOverlapped// overlapped <br>    ) <br>{ <br>HRESULThr=NOERROR; <br>BOOLfWritten=FALSE;// TRUE if successful <br> <br>DEBUGPRIVATE("VSOF_WriteFile()\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_WriteFile(vhFile, lpBuffer, nNumberOfBytesToWrite, <br>                        lpNumberOfBytesWritten, lpOverlapped); <br> <br>if ( FAILED(hr) ) <br>{ <br>SetLastError(ERROR_INVALID_PARAMETER); <br> <br>return FALSE; <br>} <br> <br>// Initialize output parameters <br>*lpNumberOfBytesWritten = 0; <br>if ( lpOverlapped != NULL ) <br>{ <br>ZeroMemory(lpOverlapped, sizeof(OVERLAPPED)); <br>} <br> <br>    if (vhFile-&gt;hf != INVALID_HANDLE_VALUE) <br>{ <br>        goto NonVirtual; <br>} <br>     <br>    if ((nNumberOfBytesToWrite+vhFile-&gt;ulFilePointer) &gt;= vhFile-&gt;dwVirtualBufferSize)  <br>    { <br>        if (!MakeReal(vhFile)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>        goto NonVirtual; <br>    } <br>     <br>    CopyMemory(((unsigned char *)vhFile-&gt;lpvVBuff)+vhFile-&gt;ulFilePointer, lpBuffer, <br>               nNumberOfBytesToWrite); <br>     <br>    *lpNumberOfBytesWritten = nNumberOfBytesToWrite; <br>     <br>    vhFile-&gt;ulFilePointer += nNumberOfBytesToWrite;  // Update file pointer. <br>    vhFile-&gt;ulFileSize = vhFile-&gt;ulFilePointer;      // Update file size. <br> <br>fWritten = TRUE; <br> <br>goto cleanup; <br>     <br>NonVirtual: <br>// real file <br>    fWritten = WriteFile( <br>    vhFile-&gt;hf, <br>        lpBuffer, <br>        nNumberOfBytesToWrite, <br>        lpNumberOfBytesWritten, <br>        lpOverlapped); <br> <br>goto cleanup; <br> <br>cleanup: <br> <br>return fWritten; <br> <br>} <br> <br>//$--VSOF_GetFileSize---------------------------------------------------------- <br>// <br>// DESCRIPTION:Gets the file's files <br>// <br>// INPUT:vhFile--file handle <br>// <br>// OUTPUT:lpFileSizeHigh--pointer to 64-bit file size <br>// <br>// RETURNS:DWORD--file size <br>// <br>//----------------------------------------------------------------------------- <br>#ifndef DEBUG <br>__inline <br>#endif <br>DWORD VSOF_GetFileSize(// RETURNS: DWORD <br>    IN VSOF_HANDLE vhFile,// file handle <br>    OUT LPDWORD lpFileSizeHigh// high file size <br>    ) <br>{ <br>HRESULThr=NOERROR; <br>DWORDdwFileSize=0;// file size <br> <br>DEBUGPRIVATE("VSOF_GetFileSize()\n"); <br> <br>hr = CHK_VSOF_GetFileSize(vhFile, lpFileSizeHigh); <br> <br>if ( FAILED(hr) ) <br>{ <br>SetLastError(ERROR_INVALID_PARAMETER); <br> <br>return 0; <br>} <br> <br>    if (vhFile-&gt;hf != INVALID_HANDLE_VALUE) <br>{ <br>        goto NonVirtual; <br>} <br>     <br>    if (lpFileSizeHigh) <br>{ <br>        *lpFileSizeHigh = 0; <br>} <br>     <br>dwFileSize = vhFile-&gt;ulFileSize; <br> <br>goto cleanup;  <br>     <br>NonVirtual: <br>// real file <br>    dwFileSize = GetFileSize( <br>    vhFile-&gt;hf, <br>        lpFileSizeHigh); <br> <br>goto cleanup; <br> <br>cleanup: <br> <br>return dwFileSize; <br> <br>} <br> <br>//$--VSOF_CloseHandle---------------------------------------------------------- <br>// <br>// DESCRIPTION:Close file. <br>// <br>// INPUT:vhObject--file handle <br>// <br>// RETURNS:BOOL--TRUE if successful. <br>// <br>//---------------------------------------------------------------------------- <br>#ifndef DEBUG <br>__inline <br>#endif <br>BOOL VSOF_CloseHandle(// RETURNS: BOOL <br>    VSOF_HANDLE vhObject// file handle <br>    ) <br>{ <br>BOOLfClosed=FALSE;// TRUE if successful <br> <br>DEBUGPRIVATE("VSOF_CloseHandle()\n"); <br> <br>    if (vhObject-&gt;hf != INVALID_HANDLE_VALUE) <br>{ <br>        goto NonVirtual; <br>} <br>     <br>    fClosed = TRUE; <br> <br>goto cleanup; <br>     <br>NonVirtual: <br>// real file <br>    fClosed = CloseHandle(vhObject-&gt;hf); <br> <br>goto cleanup; <br> <br>cleanup: <br> <br>return fClosed; <br> <br>} <br> <br>// Special virtual stream interface extensions for performance... <br>// There are certain situations where knowing if the stream has changed can be <br>// used to make desicions that will improve performance. <br> <br>//$--VSOF_SetClean------------------------------------------------------------- <br>// <br>// DESCRIPTION:Unsets stream dirty flag <br>// <br>// INPUT:lpStream--stream pointer <br>// <br>// RETURNS:HRESULT--NOERROF if successful, <br>//E_INVALIDARG if bad input. <br>// <br>//----------------------------------------------------------------------------- <br>HRESULT VSOF_SetClean( <br>IN LPSTREAM lpStream)// stream pointer <br>{ <br>HRESULThr=NOERROR; <br> <br>// check input parameters <br>hr = CHK_VSOF_SetClean(lpStream); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Unset stream dirty flag <br>    if (((LPVSOF)lpStream)-&gt;lpVSOFOrig) <br>        ((LPVSOF)lpStream)-&gt;lpVSOFOrig-&gt;fDirty = FALSE; <br>    else <br>        ((LPVSOF)lpStream)-&gt;fDirty = FALSE; <br> <br>// we are done <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--VSOF_IsDirty------------------------------------------------------------- <br>// <br>// DESCRIPTION:Returns stream dirty flag <br>// <br>// INPUT:lpStream--stream pointer <br>// <br>// RETURNS:HRESULT--NOERROF if successful, <br>//E_INVALIDARG if bad input. <br>// <br>//----------------------------------------------------------------------------- <br>HRESULT VSOF_IsDirty(// RETURNS:BOOL <br>IN LPSTREAM lpStream,// stream pointer <br>OUT BOOL * pfDirty)// dirty flag pointer <br>{ <br>HRESULThr=NOERROR; <br> <br>// check input parameters <br>hr = CHK_VSOF_IsDirty(lpStream, pfDirty); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Return dirty flag <br>    if (((LPVSOF)lpStream)-&gt;lpVSOFOrig) <br>{ <br>        *pfDirty = ((LPVSOF)lpStream)-&gt;lpVSOFOrig-&gt;fDirty; <br>} <br>    else <br>{ <br>        *pfDirty = ((LPVSOF)lpStream)-&gt;fDirty; <br>} <br> <br>// we are done <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--VSOF_SetDirty------------------------------------------------------------- <br>// <br>// DESCRIPTION:Sets stream dirty flag macro <br>// <br>// INPUT:lpStream--stream pointer <br>// <br>// RETURNS:VOID <br>// <br>//----------------------------------------------------------------------------- <br>static __inline VOID VSOF_SetDirty(// RETURNS:VOID <br>IN LPVSOF lpVSOF)// Virtual Stream On File pointer <br>{ <br>// consistency checking <br>ASSERT_WRITE_PTR(lpVSOF, sizeof(VSOF), "Bad lpVSOF"); <br> <br>// Set dirty flag <br>    if (lpVSOF-&gt;lpVSOFOrig) <br>        lpVSOF-&gt;lpVSOFOrig-&gt;fDirty = TRUE; <br>    else <br>        lpVSOF-&gt;fDirty = TRUE; <br>} <br> <br>/* Unimplemented methods. */ <br> <br>//$--VSOF_Revert--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::Revert() <br>// <br>// INPUT:Same as for IStream::Revert() <br>// <br>// RETURNS:HRESULT--STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_Revert( <br>IN LPVSOF lpVSOF)// this <br>{ <br>HRESULThr=NOERROR; <br> <br>    DEBUGPUBLIC("VSOF_Revert()\n"); <br> <br>// Check input parameters <br>hr = CHK_VSOF_Revert(lpVSOF); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>RETURN(STG_E_INVALIDFUNCTION); <br> <br>} <br> <br>//$--VSOF_LockRegion--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::LockRegion() <br>// <br>// INPUT:Same as for IStream::LockRegion() <br>// <br>// RETURNS:HRESULT--STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_LockRegion ( <br>IN LPVSOF lpVSOF, // this <br>IN ULARGE_INTEGER uliOffset, // offset <br>IN ULARGE_INTEGER uliSize, // size <br>IN DWORD dwLockType)// lock type <br>{ <br>HRESULThr=NOERROR; <br> <br>    DEBUGPUBLIC("VSOF_LockRegion()\n"); <br> <br>hr = CHK_VSOF_LockRegion(lpVSOF, uliOffset, uliSize, dwLockType); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>RETURN(STG_E_INVALIDFUNCTION); <br> <br>} <br> <br>//$--VSOF_UnlockRegion--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::UnlockRegion() <br>// <br>// INPUT:Same as for IStream::UnlockRegion() <br>// <br>// RETURNS:HRESULT--STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_UnlockRegion ( <br>IN LPVSOF lpVSOF, // this <br>IN ULARGE_INTEGER uliOffset, // offset <br>IN ULARGE_INTEGER uliSize, // length <br>IN DWORD dwLockType)// lock type <br>{ <br>HRESULThr=NOERROR; <br> <br>    DEBUGPUBLIC("VSOF_UnlockRegion()\n"); <br> <br>hr = CHK_VSOF_UnlockRegion(lpVSOF, uliOffset, uliSize, dwLockType); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>RETURN(STG_E_INVALIDFUNCTION); <br> <br>} <br> <br>// IUnknown methods: <br> <br>//$--VSOF_QueryInterface--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::QueryInterface() <br>// <br>// INPUT:Same as for IStream::QueryInterface() <br>// <br>// RETURNS:HRESULT--NOERRORif VSOF object supports interface, <br>//E_NOINTERFACE if VSOF object doesn't support interface, <br>//E_INVALIDARG if bad input. <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_QueryInterface( <br>IN LPVSOF lpVSOF, // this <br>IN REFIID riid, // interface identifier reference <br>OUT LPVOID FAR * lppvObj)// interface object pointer <br>{ <br>HRESULThr=NOERROR; <br> <br>    DEBUGPUBLIC("VSOF_QueryInterface()\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_QueryInterface(lpVSOF, riid, lppvObj); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Initialize output parameters <br>*lppvObj = NULL; <br> <br>if ( (IsEqualIID(riid, &amp;IID_IUnknown) == FALSE) &amp;&amp; <br> ( IsEqualIID(riid, &amp;IID_IStream) == FALSE) ) <br>{ <br>hr = HR_LOG(E_NOINTERFACE); <br> <br>goto cleanup; <br>} <br> <br>lpVSOF-&gt;lcInit++; <br>*lppvObj = lpVSOF; <br> <br>// we are done. <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br> <br>//$--VSOF_AddRef--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::AddRef() <br>// <br>// INPUT:this <br>// <br>// RETURNS:ULONG--reference count <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) VSOF_AddRef(// RETURNS: ULONG <br>IN LPVSOF lpVSOF)// this <br>{ <br>HRESULThr=NOERROR; <br> <br>DEBUGPUBLIC("VSOF_AddRef()\n"); <br> <br>hr = CHK_VSOF_AddRef(lpVSOF); <br> <br>if ( FAILED(hr) ) <br>{ <br>return 0; <br>} <br> <br>return (++lpVSOF-&gt;lcInit); <br>} <br> <br>//$--VSOF_Clone--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::Clone() <br>// <br>// INPUT:this, <br>// <br>// OUTPUT:virtual stream pointer <br>// <br>// RETURNS:HRESULT--NOERROR if successful, <br>//E_INVALIDARG if bad input, <br>//E_ACCESSDENIED if no access, <br>//EDK_E_NOT_FOUND if file not found, <br>//E_FAIL otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_Clone ( <br>IN LPVSOF lpVSOF, // this <br>OUT LPSTREAM FAR *lppStm)// virtual stream pointer <br>{ <br>    HRESULThr =NOERROR; <br>    LPVSOFlpVSOFClone=NULL; <br>DWORDfdwAccess=0; <br>DWORDfdwCreate=0; <br>    DWORDfdwShare=0; <br>    DWORDfdwAttr=0; <br>    LARGE_INTEGERli ={0}; <br> <br>DEBUGPUBLIC("VSOF_Clone()\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_Clone(lpVSOF, lppStm); <br>     <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// initialize output parameters <br>    *lppStm = NULL; <br>     <br>    ASSERTERROR(lpVSOF-&gt;ulFlags &amp; VSOF_CLONEABLE, "Bad lpVSOF-&gt;ulFlags"); <br>     <br>    li.LowPart = VSOF_SetFilePointer( <br>    lpVSOF, <br>        0, <br>        &amp;li.HighPart, <br>        FILE_CURRENT); <br>     <br>    if (li.LowPart == 0xFFFFFFFF)  <br>    {  <br>    // check for an error; <br>        hr = HRESULT_FROM_WIN32(GetLastError());  <br>if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        }             <br>    } <br>                         <br>hr = (*(lpVSOF-&gt;lpfnAlloc)) (sizeof(VSOF), &amp;lpVSOFClone); <br>if (FAILED (hr))  <br>{ <br>goto cleanup; <br>    } <br>     <br>ZeroMemory(lpVSOFClone, sizeof(VSOF)); <br>lpVSOFClone-&gt;lpVtbl = (VSOF_Vtbl FAR *)&amp;VtblVSOF; <br>lpVSOFClone-&gt;lcInit = 1; <br>lpVSOFClone-&gt;ulFlags = lpVSOF-&gt;ulFlags; <br>lpVSOFClone-&gt;lpfnAlloc = lpVSOF-&gt;lpfnAlloc; <br>lpVSOFClone-&gt;lpfnFree = lpVSOF-&gt;lpfnFree; <br>     <br>lpVSOFClone-&gt;hf = INVALID_HANDLE_VALUE; <br>         <br>fdwCreate = OPEN_EXISTING; <br> <br>    fdwAttr = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN; <br>    if (lpVSOF-&gt;ulFlags &amp; STGM_DELETEONRELEASE) <br>        fdwAttr = FILE_ATTRIBUTE_TEMPORARY;  // keeps more data in memory. <br>     <br>    if (lpVSOF-&gt;ulFlags &amp; STGM_READWRITE)  <br>    { <br>fdwAccess = GENERIC_READ | GENERIC_WRITE; <br>    }  <br>    else  <br>    { <br>fdwAccess = GENERIC_READ; <br>    } <br> <br>// Determine level of concurrent access allowed for file. <br>fdwShare = dwComputeShareFlags(lpVSOF-&gt;ulFlags); <br> <br>    if (lpVSOF-&gt;lpVSOFOrig)  <br>    { <br>        lpVSOFClone-&gt;lpVSOFOrig = lpVSOF-&gt;lpVSOFOrig; <br>        lpVSOFClone-&gt;hf = CreateFile ( <br>        lpVSOF-&gt;lpVSOFOrig-&gt;rgchFile, <br>            fdwAccess, <br>            fdwShare, <br>            NULL, <br>            fdwCreate, <br>            fdwAttr, <br>            NULL); <br>    }  <br>    else  <br>    { <br>        lpVSOFClone-&gt;lpVSOFOrig = lpVSOF; <br>        lpVSOFClone-&gt;hf = CreateFile ( <br>        lpVSOF-&gt;rgchFile, <br>            fdwAccess, <br>            fdwShare, <br>            NULL, <br>            fdwCreate, <br>            fdwAttr, <br>            NULL); <br>    } <br>     <br>if (lpVSOFClone-&gt;hf == INVALID_HANDLE_VALUE) <br>{ <br>DWORD dwLastError = GetLastError(); <br> <br>switch(dwLastError) <br>{ <br>case ERROR_ACCESS_DENIED: <br>hr = HR_LOG(E_ACCESSDENIED); <br>goto cleanup; <br> <br>case ERROR_FILE_NOT_FOUND: <br>hr = HR_LOG(EDK_E_NOT_FOUND); <br>goto cleanup; <br> <br>default: <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>}         <br>} <br> <br>    // Set the file position to match that of the file we're cloning. <br>    li.LowPart = VSOF_SetFilePointer( <br>    lpVSOFClone, <br>        li.LowPart, <br>        &amp;li.HighPart, <br>        FILE_BEGIN); <br> <br>    if (li.LowPart == 0xFFFFFFFF)  <br>    { // check for an error; <br>hr = HRESULT_FROM_WIN32(GetLastError()); <br>if ( FAILED(hr) ) <br>{             <br>            goto cleanup; <br>        }             <br>    } <br>     <br>    if (lpVSOF-&gt;lpVSOFOrig)  <br>    { <br>        lpVSOF-&gt;lpVSOFOrig-&gt;lpVtbl-&gt;AddRef(lpVSOF);  // for ourself.     <br>    }  <br>    else  <br>    { <br>        lpVSOF-&gt;lpVtbl-&gt;AddRef(lpVSOF);  // for ourself.     <br>    } <br>    *lppStm = (LPSTREAM)lpVSOFClone; <br>     <br>cleanup: <br> <br>    if ( FAILED(hr) ) <br>    { <br>        if (lpVSOFClone)  <br>        { <br>            if (lpVSOFClone-&gt;hf == INVALID_HANDLE_VALUE) <br>{ <br>                VSOF_CloseHandle(lpVSOFClone); </code></pre>
<p>
</p>
<pre><code>} <br>            (*(lpVSOF-&gt;lpfnFree)) (lpVSOFClone); <br>        } <br>    } <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--VSOF_Release--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::Release() <br>// <br>// INPUT:this, <br>// <br>// RETURNS:ULONG--new reference count. <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) VSOF_Release (// RETURNS:ULONG <br>IN LPVSOF lpVSOF)// this <br>{ <br>HRESULThr=NOERROR; <br>ULONGnRefCount=0;// new reference count <br> <br>DEBUGPUBLIC("VSOF_Release()\n"); <br> <br>// Check input parameters <br>hr = CHK_VSOF_Release(lpVSOF); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>if ((--lpVSOF-&gt;lcInit) == 0) <br>{ <br>// last reference to object <br>        if (lpVSOF-&gt;lpVSOFOrig)  // This is a clone.. <br>        { <br>            lpVSOF-&gt;lpVSOFOrig-&gt;lpVtbl-&gt;Release(lpVSOF-&gt;lpVSOFOrig); <br>             <br>if (!VSOF_CloseHandle (lpVSOF)) <br>{ <br>                HR_LOG(E_FAIL); <br> <br>lpVSOF-&gt;lcInit = 1; <br>nRefCount = 0xFFFFFFFF; <br> <br>goto cleanup; <br>} <br>        } <br>        else if (lpVSOF-&gt;hf != INVALID_HANDLE_VALUE)  <br>        { <br>if (!VSOF_CloseHandle (lpVSOF)) <br>{ <br>                HR_LOG(E_FAIL); <br> <br>lpVSOF-&gt;lcInit = 1; <br>nRefCount = 0xFFFFFFFF; <br> <br>goto cleanup; <br>} <br> <br>if (lpVSOF-&gt;ulFlags &amp; (STGM_DELETEONRELEASE | VSOF_CLONEABLE)) <br>{ <br>DeleteFile (lpVSOF-&gt;rgchFile); <br>} <br>} <br>        if (lpVSOF-&gt;lpvVBuff) <br>{ <br>            (*lpVSOF-&gt;lpfnFree) (lpVSOF-&gt;lpvVBuff); <br>} <br>(*lpVSOF-&gt;lpfnFree) (lpVSOF); <br> <br>// It's gone! <br>nRefCount = 0; <br> <br>goto cleanup; <br>} <br> <br>// Still has references <br>nRefCount = lpVSOF-&gt;lcInit; <br> <br>cleanup: <br> <br>return nRefCount; <br> <br>} <br> <br>//$--VSOF_Read--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::Read() <br>// <br>// INPUT:lpVSOF--this, <br>//lpvData--read buffer <br>//cbSize--size of read buffer <br>// <br>// OUTPUT:lpcbRead--# bytes read <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//STG_E_INVALIDPARAM if bad input, <br>//STG_E_READFAULT otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_Read ( <br>IN LPVSOF lpVSOF,// this <br>IN VOID HUGEP * lpvData,// buffer to read data into <br>IN ULONG cbSize,// # bytes to read <br>OUT ULONG FAR * lpcbRead)// # bytes read <br>{ <br>HRESULT hr = NOERROR; <br>ULONG cbRead=0;// # bytes read <br> <br>    DEBUGPUBLIC("VSOF_Read()\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_Read(lpVSOF, lpvData, cbSize, lpcbRead); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Initialize output parameters <br>if ( lpcbRead != NULL ) <br>{ <br>*lpcbRead = 0; <br>} <br> <br>ASSERTERROR ((lpVSOF-&gt;hf != INVALID_HANDLE_VALUE) || (lpVSOF-&gt;lpvVBuff), <br>    "Bad lpVSOF-&gt;hf or bad lpVSOF-&gt;lpvVBuff"); <br>if (!VSOF_ReadFile (lpVSOF, lpvData, cbSize, &amp;cbRead, NULL)) <br>{ <br>        hr = HR_LOG(STG_E_READFAULT); <br>// don't exit early! <br>} <br> <br>// Set output parameters <br>if (lpcbRead != NULL) <br>{ <br>*lpcbRead = cbRead; <br>} <br> <br>RETURN(hr); <br>} <br> <br>//$--VSOF_Write--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::Write() <br>// <br>// INPUT:lpVSOF--this, <br>//lpvData--write buffer <br>//cbSize--size of write buffer <br>// <br>// OUTPUT:lpcbWritten--# bytes written <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//STG_E_INVALIDPARAM if bad input, <br>//STG_E_MEDIUMFULL otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_Write( <br>IN LPVSOF lpVSOF,// this <br>IN VOID HUGEP * lpvData,// buffer to write data from <br>IN ULONG cbSize,// size of buffer <br>OUT ULONG FAR * lpcbWritten)// # bytes written <br>{ <br>HRESULT hr = NOERROR; <br>ULONG cbWritten=0;// # bytes written <br> <br>    DEBUGPUBLIC("VSOF_Write()\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_Write(lpVSOF, lpvData, cbSize, lpcbWritten); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Initialize output parameters <br>if ( lpcbWritten != NULL ) <br>{ <br>*lpcbWritten = 0; <br>} <br> <br>// Set dirty flag on stream. <br>    VSOF_SetDirty(lpVSOF); <br> <br>ASSERTERROR ((lpVSOF-&gt;hf != INVALID_HANDLE_VALUE) || (lpVSOF-&gt;lpvVBuff), <br>    "Bad lpVSOF-&gt;hf or bad lpVSOF-&gt;lpvVBuff"); <br>if (!VSOF_WriteFile (lpVSOF, lpvData, cbSize, &amp;cbWritten, NULL)) <br>{ <br>hr = HR_LOG(STG_E_MEDIUMFULL); <br>// don't exit early <br>} <br> <br>// Set output parameters <br>if (lpcbWritten != NULL) <br>{ <br>*lpcbWritten = cbWritten; <br>} <br> <br>RETURN (hr); <br>} <br> <br>//$--VSOF_Seek--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::Seek() <br>// <br>// INPUT:lpVSOF--this, <br>//liMOve--offset <br>//dwMode--origin <br>// <br>// OUTPUT:lpliPos--new position <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//STG_E_INVALIDPARAM if bad input, <br>//STG_E_SEEKERROR otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_Seek ( <br>IN LPVSOF lpVSOF,// this <br>IN LARGE_INTEGER liMove,// offset <br>IN DWORD dwMode,// origin <br>OUT ULARGE_INTEGER FAR * lpliPos)// new position <br>{ <br>HRESULThr=NOERROR; <br>ULONGibLow=0; <br>ULONGibHigh=0; <br> <br>    DEBUGPUBLIC("VSOF_Seek()\n"); <br> <br>ASSERTERROR (STREAM_SEEK_SET == FILE_BEGIN, "Bad STREAM_SEEK_SET"); <br>ASSERTERROR (STREAM_SEEK_CUR == FILE_CURRENT, "Bad STREAM_SEEK_CUR"); <br>ASSERTERROR (STREAM_SEEK_END == FILE_END, "Bad STREAM_SEEK_END"); <br> <br>// Check input parameters <br>hr = CHK_VSOF_Seek(lpVSOF, liMove, dwMode, lpliPos); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Initialize output parameters <br>if ( lpliPos != NULL ) <br>{ <br>ZeroMemory(lpliPos, sizeof(ULARGE_INTEGER)); <br>} <br> <br>ASSERTERROR ((lpVSOF-&gt;hf != INVALID_HANDLE_VALUE) || (lpVSOF-&gt;lpvVBuff), <br>    "Bad lpVSOF-&gt;hf or bad lpVSOF-&gt;lpvVBuff"); <br> <br>#ifdef CHICAGO <br> <br>//Windows 95 doesn't support large seeks <br>// <br>ibHigh = liMove.HighPart; <br>ibLow = VSOF_SetFilePointer (lpVSOF, liMove.LowPart, NULL, dwMode); <br>ibHigh = 0; <br> <br>#else <br> <br>ibHigh = liMove.HighPart; <br>ibLow = VSOF_SetFilePointer (lpVSOF, liMove.LowPart, &amp;ibHigh, dwMode); <br> <br>#endif <br> <br>if ((ibLow == 0xFFFFFFFF) &amp;&amp; GetLastError()) <br>{ <br>hr = HR_LOG(STG_E_SEEKERROR); <br> <br>goto cleanup; <br>} <br> <br>// Set output parameters <br>if (lpliPos) <br>{ <br>lpliPos-&gt;LowPart = ibLow; <br>lpliPos-&gt;HighPart = ibHigh; <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--VSOF_SetSize--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::SetSize() <br>// <br>// INPUT:lpVSOF--this, <br>//liSize--new size <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//STG_E_INVALIDPARAM if bad input, <br>//STG_E_SEEKERROR otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_SetSize ( <br>IN LPVSOF lpVSOF, // this <br>IN ULARGE_INTEGER liSize)// new size <br>{ <br>HRESULThr=NOERROR; <br>ULONGibLow=0; <br>ULONG ibHigh=0; <br> <br>    DEBUGPUBLIC("VSOF_SetSize()\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_SetSize(lpVSOF, liSize); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Set stream dirty flag. <br>VSOF_SetDirty(lpVSOF); <br> <br>ibLow = VSOF_SetFilePointer (lpVSOF, 0, &amp;ibHigh, FILE_CURRENT); <br>if ((ibLow == 0xFFFFFFFF) &amp;&amp; GetLastError()) <br>{ <br>hr = HR_LOG(STG_E_SEEKERROR); <br>goto cleanup; <br>} <br> <br>liSize.LowPart = VSOF_SetFilePointer (lpVSOF, liSize.LowPart, &amp;liSize.HighPart, FILE_BEGIN); <br>if ((liSize.LowPart == 0xFFFFFFFF) &amp;&amp; GetLastError()) <br>{ <br>hr = HR_LOG(STG_E_SEEKERROR); <br>goto cleanup; <br>} <br> <br>if (!VSOF_SetEndOfFile (lpVSOF)) <br>{ <br>hr = HR_LOG(STG_E_WRITEFAULT); <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>ibLow = VSOF_SetFilePointer (lpVSOF, ibLow, &amp;ibHigh, FILE_BEGIN); <br>if ((ibLow == 0xFFFFFFFF) &amp;&amp; GetLastError()) <br>{ <br>hr = HR_LOG(STG_E_SEEKERROR); <br>goto cleanup; <br>} <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--VSOF_CopyTo--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::CopyTo() <br>// <br>// INPUT:lpVSOF--this, <br>//lpStrmDest--destination stream pointer <br>//cbCopy--# bytes to copy <br>// <br>// OUTPUT:lpcbRead--# bytes read from source stream <br>//lpcbWritten--# bytes written to destination stream <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//STG_E_INVALIDPARAM if bad input, <br>//STG_E_MEDIUMFULL if disk full, <br>//STG_E_READFAULT otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_CopyTo ( <br>IN LPVSOF lpVSOF,// this <br>IN LPSTREAM lpStrmDst,// destination stream pointer <br>IN ULARGE_INTEGER cbCopy,// # bytes to copy <br>OUT ULARGE_INTEGER FAR * lpcbRead,// # bytes read <br>OUT ULARGE_INTEGER FAR * lpcbWritten)// # bytes written <br>{ <br>HRESULT hr=NOERROR; <br>LPBYTE lpb = NULL; <br>ULONG cbr=0; <br>ULONG cbrTotal=0; <br>ULONG cbw=0; <br>ULONG cbwTotal = 0; <br> <br>    DEBUGPUBLIC("VSOF_CopyTo()\n"); <br> <br>// Check input parameters <br>hr = CHK_VSOF_CopyTo(lpVSOF, lpStrmDst, cbCopy, lpcbRead, lpcbWritten); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Initialixe output paramters <br>if ( lpcbRead != NULL ) <br>{ <br>ZeroMemory(lpcbRead, sizeof(ULARGE_INTEGER)); <br>} <br> <br>if ( lpcbWritten != NULL ) <br>{ <br>ZeroMemory(lpcbWritten, sizeof(ULARGE_INTEGER)); <br>} <br> <br>//Since we are really not supporting excessively large <br>//streams, we are not gonna deal with the high long <br>// <br>hr = (*lpVSOF-&gt;lpfnAlloc) (BUFFER_SIZE, &amp;lpb); <br>if (FAILED (hr)) <br>{ <br>goto cleanup; <br>} <br> <br>while (cbCopy.LowPart) <br>{ <br>ULONG cb = min (cbCopy.LowPart, BUFFER_SIZE); <br> <br>if (!VSOF_ReadFile (lpVSOF, lpb, cb, &amp;cbr, NULL)) <br>{ <br>hr = HR_LOG(STG_E_READFAULT); <br>goto cleanup; <br>} <br> <br>hr = lpStrmDst-&gt;lpVtbl-&gt;Write (lpStrmDst, lpb, cbr, &amp;cbw); <br>if (FAILED (hr)) <br>{ <br>goto cleanup; <br>} <br> <br>if (cbr != cbw) <br>{ <br>ASSERTERROR (FALSE, "VSOF_CopyTo(), bytes read != bytes written\n"); <br>hr = HR_LOG(STG_E_MEDIUMFULL); <br>goto cleanup; <br>} <br> <br>cbrTotal += cbr; <br>cbwTotal += cbw; <br> <br>//They asked to copy more than available <br>// <br>if (cb != cbr) <br>{ <br>break; <br>} <br> <br>cbCopy.LowPart -= cb; <br>} <br> <br>cleanup: <br> <br>// Set output parameters <br>if (lpcbRead != NULL) <br>{ <br>lpcbRead-&gt;LowPart = cbrTotal; <br>lpcbRead-&gt;HighPart = 0; <br>} <br> <br>if (lpcbWritten != NULL) <br>{ <br>lpcbWritten-&gt;LowPart = cbwTotal; <br>lpcbWritten-&gt;HighPart = 0; <br>} <br> <br>if (lpb) <br>{ <br>(*lpVSOF-&gt;lpfnFree) (lpb); <br>} <br> <br>RETURN (hr); <br> <br>} <br> <br>//$--VSOF_Commit--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::Commit() <br>// <br>// INPUT:lpVSOF--this, <br>//ulFlags--flags <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//STG_E_INVALIDPARAM if bad input, <br>//STG_E_WRITEFAULT otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_Commit( <br>IN LPVSOF lpVSOF, // this <br>IN ULONG ulFlags)// flags <br>{ <br>HRESULThr=NOERROR; <br> <br>    DEBUGPUBLIC("VSOF_Commit()\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_Commit(lpVSOF, ulFlags); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>//There is no 16bit equivilent here <br>// <br>if (!VSOF_FlushFileBuffers (lpVSOF)) <br>{ <br>hr = HR_LOG(STG_E_WRITEFAULT); <br> <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--VSOF_Stat--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Same as for IStream::Stat() <br>// <br>// INPUT:lpVSOF--this, <br>//lpStg--storage statistics pointer <br>//ulFlags--flags <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//STG_E_INVALIDPARAM if bad input, <br>//STG_E_INVALIDHEADER otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP VSOF_Stat( <br>IN LPVSOF lpVSOF,// this <br>IN STATSTG FAR * lpStg, // storage statistics pointer <br>IN DWORD dwFlags)// flags <br>{ <br>HRESULThr=NOERROR; <br>ULONGcbLow=0; <br>ULONGcbHigh=0; <br> <br>    DEBUGPUBLIC("VSOF_Stat)\n"); <br> <br>// check input parameters <br>hr = CHK_VSOF_Stat(lpVSOF, lpStg, dwFlags); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Initlialize output parameter <br>ZeroMemory(lpStg, sizeof(STATSTG)); <br> <br>cbLow = VSOF_GetFileSize (lpVSOF, &amp;cbHigh); <br>if ((cbLow == 0xFFFFFFFF) &amp;&amp; GetLastError()) <br>{ <br>hr = HR_LOG(STG_E_INVALIDHEADER); <br>// don't return early! <br>} <br> <br>lpStg-&gt;type = STGTY_STREAM; <br>lpStg-&gt;cbSize.LowPart = cbLow; <br>lpStg-&gt;cbSize.HighPart = cbHigh; <br>lpStg-&gt;grfMode = lpVSOF-&gt;ulFlags; <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--HrOpenVirtualStreamOnFile--------------------------------------------------------------- <br>// <br>// DESCRIPTION:Open/create a virtual stream on the specified file. <br>// <br>// INPUT:lpfnAlloc--memory allocation routine <br>//lpfnFree--memory deallocation routine <br>//ulFlags--stream flags <br>//lpszPath--fully pathed file name <br>//lpszPrefix--file prefix <br>// <br>// OUTPUT:lppStream--virtual stream pointer <br>// <br>// RETURNS:HRESULT--NOERROR if sucessful, <br>//E_INVALIDARG if bad input, <br>//E_ACCESSDENIED if no access, <br>//EDK_E_NOT_FOUND if file not found, <br>//E_FAIL otherwise <br>// <br>//----------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE HrOpenVirtualStreamOnFile( <br>IN LPALLOCATEBUFFER lpfnAlloc,// allocation routine <br>IN LPFREEBUFFER lpfnFree,// deallocation routine <br>IN ULONG ulFlags,// stream flags <br>IN LPSTR lpszFile,// fully-pathed file name <br>IN LPSTR lpszPrefix,// file prefix <br>OUT LPSTREAM FAR * lppStrm)// virtual stream pointer <br>{ <br>HRESULT hr=NOERROR; <br>DWORD fdwAccess=0; <br>DWORD fdwCreate=0; <br>    DWORD fdwShare=0; <br>    DWORD fdwAttr=0; <br>    DWORD dwVirtualBufferSize=0; <br>    char *lpszVirtualBufferSize=0; <br>LPVSOF lpVSOF = NULL; <br> <br>    DEBUGPUBLIC("HrOpenVirtualStreamOnFile()\n"); <br> <br>// Check input parameters <br>hr = CHK_HrOpenVirtualStreamOnFile(lpfnAlloc, lpfnFree, ulFlags, lpszFile, <br> lpszPrefix, lppStrm); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>    fdwAttr = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN; <br>    if (ulFlags &amp; STGM_DELETEONRELEASE)  <br>    { <br>        fdwAttr = FILE_ATTRIBUTE_TEMPORARY;  // keeps more data in memory. <br>        if (!(ulFlags &amp; VSOF_CLONEABLE)) <br>{ <br>            fdwAttr |= FILE_FLAG_DELETE_ON_CLOSE;  // faster than DeleteFile()! <br>} <br>    } <br>     <br>if (ulFlags &amp; STGM_READWRITE) <br>{ <br>fdwAccess = GENERIC_READ | GENERIC_WRITE; <br>         <br>if (ulFlags &amp; STGM_CREATE) <br>{ <br>fdwCreate = CREATE_ALWAYS; <br>} <br>else <br>{ <br>fdwCreate = TRUNCATE_EXISTING; <br>} <br>} <br>else <br>{ <br>fdwCreate = OPEN_EXISTING; <br>fdwAccess = GENERIC_READ; <br>} <br> <br>// Determine level of concurrent access allowed for file. <br>fdwShare = dwComputeShareFlags(ulFlags); <br> <br>hr = (*lpfnAlloc) (sizeof(VSOF), &amp;lpVSOF); <br>if (FAILED (hr)) <br>{ <br>goto cleanup; <br>} <br> <br>ZeroMemory(lpVSOF, sizeof(VSOF)); <br>lpVSOF-&gt;hf = INVALID_HANDLE_VALUE; <br>lpVSOF-&gt;lpVtbl = (VSOF_Vtbl FAR *)&amp;VtblVSOF; <br>lpVSOF-&gt;lcInit = 1; <br>lpVSOF-&gt;ulFlags = ulFlags &amp; ~VSOF_UNIQUEFILENAME; <br>lpVSOF-&gt;lpfnAlloc = lpfnAlloc; <br>lpVSOF-&gt;lpfnFree = lpfnFree; <br> <br>    dwVirtualBufferSize = VIRTUAL_BUFFER_SIZE; <br>    if (lpszVirtualBufferSize = getenv(VBUFF_ENV_NAME)) <br>{ <br>        dwVirtualBufferSize = atol(lpszVirtualBufferSize); <br>} <br> <br>// Algorithm: <br>// 1) Open "non-temporary" files for reading or writing.     <br>// 2) Create a buffer for "temporary" file data. <br> <br>if (ulFlags &amp; VSOF_UNIQUEFILENAME) <br>{ <br>        if ((ulFlags &amp; STGM_DELETEONRELEASE) &amp;&amp; !(ulFlags &amp; VSOF_CLONEABLE) &amp;&amp; <br>            dwVirtualBufferSize)  <br>        { <br>// User wants a temporary file. <br>            // We take the virtual fork in the road... <br>            if (!lpszFile) <br>{ <br>                lpszFile = ""; <br>} <br>            if (!lpszPrefix) <br>{ <br>                lpszPrefix = ""; <br>} <br>                 <br>            hr = (*lpfnAlloc) (dwVirtualBufferSize, &amp;lpVSOF-&gt;lpvVBuff); <br>            if ( FAILED(hr) ) <br>{ <br>                goto cleanup; <br>} <br>             <br>            if ((lstrlen(lpszFile) + lstrlen(lpszPrefix) + 2) &gt;= MAX_PATH)  <br>            { <br>                ASSERTERROR(FALSE,"lpszFile and lpszPrefix are too long!"); <br> <br>                hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>            } <br> <br>            // Copy the filename and prefix so we can create a temp file later. <br>            lstrcpy(lpVSOF-&gt;rgchFile, lpszFile); <br>            lstrcpy(lpVSOF-&gt;rgchFile + lstrlen(lpszFile) + 1, lpszPrefix); <br>            lpVSOF-&gt;dwVirtualBufferSize = dwVirtualBufferSize; <br> <br>// We are done with setup for a temporary (virtual) file. <br>            goto cleanup; <br>        } <br>         <br>hr = ScGetVSOFFilename (lpszFile, lpszPrefix, lpVSOF-&gt;rgchFile); <br>if (FAILED (hr)) <br>{ <br>goto cleanup; <br>} <br>} <br>else <br>{ <br>ASSERTERROR (lstrlen (lpszFile) &lt;= MAX_PATH, "Bad lstrlen(lpszFile)"); <br>lstrcpy (lpVSOF-&gt;rgchFile, lpszFile); <br>} <br> <br>// Want a non-temporary (real) file. <br>lpVSOF-&gt;hf = CreateFile( <br>lpVSOF-&gt;rgchFile, <br>fdwAccess, <br>fdwShare, <br>NULL, <br>fdwCreate, <br>fdwAttr, <br>NULL); <br> <br>if (lpVSOF-&gt;hf == INVALID_HANDLE_VALUE) <br>{ <br>DWORD dwLastError = GetLastError(); <br> <br>switch(dwLastError) <br>{ <br>case ERROR_ACCESS_DENIED: <br> <br>hr = HR_LOG(E_ACCESSDENIED); <br>goto cleanup; <br> <br>case ERROR_FILE_NOT_FOUND: <br> <br>hr = HR_LOG(EDK_E_NOT_FOUND); <br>goto cleanup; <br> <br>default: <br> <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>cleanup: <br> <br>if (FAILED (hr)) <br>{ <br>if (lpVSOF) <br>{ <br>if (lpVSOF-&gt;hf != INVALID_HANDLE_VALUE) <br>{ <br>VSOF_CloseHandle (lpVSOF); <br>if (ulFlags &amp; STGM_DELETEONRELEASE) <br>DeleteFile (lpVSOF-&gt;rgchFile); <br>} <br>(*lpfnFree) (lpVSOF); <br>lpVSOF = NULL; <br>} <br>} <br> <br>*lppStrm = (LPSTREAM)lpVSOF; <br> <br>RETURN(hr); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
