<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EDKMAPI.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1832"></a>EDKMAPI.C</h2>
<pre><code>// --edkmapi.c------------------------------------------------------------------ <br>//  <br>//  Module containing MAPI utility functions. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include "edkmapi.chk" <br> <br>//$--HrMAPIGetFirstSRowSet------------------------------------------------------- <br>//  Gets the first SRowSet from a table <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIGetFirstSRowSet(           // RETURNS: return code <br>    IN LPMAPITABLE  lpTable,            // pointer to table address variable <br>    IN ULONG cRows,                     // count of number of rows in SRowSet <br>    IN LPSPropTagArray rgPropTags,      // array of property tags <br>    OUT LPSRowSet FAR *lppRows)         // pointer to address variable for <br>                                        // SRowSet <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrMAPIGetFirstSRowSet()\n"); <br> <br>    hr = CHK_HrMAPIGetFirstSRowSet( <br>        lpTable, <br>        cRows, <br>        rgPropTags, <br>        lppRows); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppRows = NULL; <br> <br>    // Set the columns to return <br>    hrT = MAPICALL(lpTable)-&gt;SetColumns(lpTable, rgPropTags, (ULONG)0); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Go to the beginning of the table <br>    hrT = MAPICALL(lpTable)-&gt;SeekRow(lpTable, BOOKMARK_BEGINNING, 0, NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get the next SRowSet <br>    hrT = MAPICALL(lpTable)-&gt;QueryRows( <br>        lpTable, <br>        cRows, <br>        (ULONG)0, <br>        lppRows); <br> <br>    if(SUCCEEDED(hrT) &amp;&amp; ((*lppRows) != NULL) &amp;&amp; ((*lppRows)-&gt;cRows == 0)) <br>    { <br>        FREEPROWS(*lppRows); <br> <br>        hrT = EDK_E_NOT_FOUND; <br>    } <br> <br>    if(FAILED(hrT) || ((*lppRows) == NULL)) <br>    { <br>        if (hrT != EDK_E_NOT_FOUND) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(EDK_E_END_OF_FILE); <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGetNextSRowSet-------------------------------------------------------- <br>//  Gets the next SRowSet from a table <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIGetNextSRowSet(            // RETURNS: return code <br>    IN LPMAPITABLE lpTable,             // pointer to table <br>    IN ULONG cRows,                     // count of number of rows in SRowSet <br>    IN LPSPropTagArray rgPropTags,      // array of property tags <br>    OUT LPSRowSet FAR *lppRows)         // pointer to address variable for <br>                                        // SRowSet <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrMAPIGetNextSRowSet()\n"); <br> <br>    hr = CHK_HrMAPIGetNextSRowSet( <br>        lpTable, <br>        cRows, <br>        rgPropTags, <br>        lppRows); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppRows = NULL; <br> <br>    // Set the columns to return <br>    hrT = MAPICALL(lpTable)-&gt;SetColumns(lpTable, rgPropTags, (ULONG)0); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get the next SRowSet <br>    hrT = MAPICALL(lpTable)-&gt;QueryRows( <br>        lpTable, <br>        cRows, <br>        (ULONG)0, <br>        lppRows); <br> <br>    if(SUCCEEDED(hrT) &amp;&amp; ((*lppRows) != NULL) &amp;&amp; ((*lppRows)-&gt;cRows == 0)) <br>    { <br>        FREEPROWS(*lppRows); <br> <br>        hrT = EDK_E_NOT_FOUND; <br>    } <br> <br>    if(FAILED(hrT) || ((*lppRows) == NULL)) <br>    { <br>        if (hrT != EDK_E_NOT_FOUND) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(EDK_E_END_OF_FILE); <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPICreateEntryList------------------------------------------------------- <br>//  Creates an ENTRYLIST.  <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPICreateEntryList(           // RETURNS: return code <br>    IN ULONG cbeid,                     // count of bytes in Entry ID <br>    IN LPENTRYID lpeid,                 // pointer to Entry ID <br>    OUT LPENTRYLIST FAR *lppEntryList)  // pointer to address variable of Entry <br>                                        // list <br>{ <br>    HRESULT hr              = NOERROR; <br>    SCODE   sc              = 0; <br>    LPVOID  lpvSBinaryArray = NULL; <br>    LPVOID  lpvSBinary      = NULL; <br>    LPVOID  lpv             = NULL; <br> <br>    DEBUGPUBLIC("HrMAPICreateEntryList()\n"); <br> <br>    hr = CHK_HrMAPICreateEntryList( <br>        cbeid, <br>        lpeid, <br>        lppEntryList); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppEntryList = NULL; <br> <br>    sc = MAPIAllocateBuffer(cbeid, &amp;lpv);                   <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    // Copy entry ID <br>    CopyMemory(lpv, lpeid, cbeid); <br> <br>    sc = MAPIAllocateBuffer(sizeof(SBinary), &amp;lpvSBinary); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    // Initialize SBinary structure <br>    ZeroMemory(lpvSBinary, sizeof(SBinary)); <br> <br>    ((LPSBinary)lpvSBinary)-&gt;cb = cbeid; <br>    ((LPSBinary)lpvSBinary)-&gt;lpb = (LPBYTE)lpv; <br> <br>    sc = MAPIAllocateBuffer(sizeof(SBinaryArray), &amp;lpvSBinaryArray); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    // Initialize SBinaryArray structure <br>    ZeroMemory(lpvSBinaryArray, sizeof(SBinaryArray)); <br> <br>    ((SBinaryArray *)lpvSBinaryArray)-&gt;cValues = 1; <br>    ((SBinaryArray *)lpvSBinaryArray)-&gt;lpbin = (LPSBinary)lpvSBinary; <br> <br>    *lppEntryList = (LPENTRYLIST)lpvSBinaryArray; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpv); <br> <br>        MAPIFREEBUFFER(lpvSBinary); <br> <br>        MAPIFREEBUFFER(lpvSBinaryArray); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIAppendEntryList------------------------------------------------------- <br>//  Appends to an ENTRYLIST. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIAppendEntryList(           // RETURNS: return code <br>    IN ULONG cbeid,                     // count of bytes in Entry ID <br>    IN LPENTRYID lpeid,                 // pointer to Entry ID <br>    OUT LPENTRYLIST FAR lpEntryList)    // pointer to address variable of Entry <br>                                        // list <br>{ <br>    HRESULT hr          = NOERROR; <br>    SCODE   sc          = 0; <br>    LPVOID  lpvSBinary  = NULL; <br>    LPVOID  lpv         = NULL; <br>    ULONG   cValues     = 0; <br>    ULONG   cSBinary    = 0; <br>    ULONG   i           = 0; <br> <br>    DEBUGPUBLIC("HrMAPIAppendEntryList()\n"); <br> <br>    hr = CHK_HrMAPIAppendEntryList( <br>        cbeid, <br>        lpeid, <br>        lpEntryList); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    sc = MAPIAllocateBuffer(cbeid, &amp;lpv); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                               <br> <br>    // Copy Entry ID <br>    CopyMemory(lpv, lpeid, cbeid); <br> <br>    cValues = lpEntryList-&gt;cValues; <br> <br>    cSBinary = sizeof(SBinary) * (cValues + 1); <br> <br>    sc = MAPIAllocateBuffer(cSBinary, &amp;lpvSBinary); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup; <br>    }                                                    <br> <br>    // Initialize SBinary structure <br>    ZeroMemory(lpvSBinary, cSBinary); <br> <br>#define BINLIST ((LPSBinary)lpvSBinary) <br> <br>    // Copy values from old SBinary list to new SBinary list <br>    for(i = 0; i &lt; cValues; i++) <br>    { <br>        BINLIST[i].cb  = lpEntryList-&gt;lpbin[i].cb; <br>        BINLIST[i].lpb = lpEntryList-&gt;lpbin[i].lpb; <br>    } <br> <br>    // Add new entry to the end of the list <br>    BINLIST[cValues].cb  = cbeid; <br>    BINLIST[cValues].lpb = (LPBYTE)lpv; <br> <br>    // Free old SBinary list <br>    MAPIFREEBUFFER(lpEntryList-&gt;lpbin); <br> <br>    // Increment number of cValues <br>    cValues++; <br> <br>    // Update Entry list <br>    lpEntryList-&gt;cValues = cValues; <br>    lpEntryList-&gt;lpbin = BINLIST; <br> <br>#undef BINLIST <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpv); <br> <br>        MAPIFREEBUFFER(lpvSBinary); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIDestroyEntryList--------------------------------------------------------- <br>//  Frees an ENTRYLIST.  <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIDestroyEntryList(              // RETURNS: return code <br>    IN OUT LPENTRYLIST FAR *lppEntryList)// pointer to address variable of Entry <br>                                         // list <br>{ <br>    HRESULT     hr          = NOERROR; <br>    ULONG       i           = 0; <br>    LPENTRYLIST lpEntryList = NULL; <br> <br>    DEBUGPUBLIC("HrMAPIDestroyEntryList()\n"); <br> <br>    hr = CHK_HrMAPIDestroyEntryList( <br>        lppEntryList); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if(lppEntryList != NULL) <br>    { <br>        lpEntryList = *lppEntryList; <br> <br>        if(lpEntryList != NULL) <br>        { <br>            if(lpEntryList-&gt;lpbin != NULL) <br>            { <br>                // Free values in SBinary list <br>                for(i = 0; i &lt; lpEntryList-&gt;cValues; i++) <br>                { <br>                    MAPIFREEBUFFER(lpEntryList-&gt;lpbin[i].lpb); <br>                } <br>     <br>                // Free SBinary list <br>                MAPIFREEBUFFER(lpEntryList-&gt;lpbin); <br>            } <br> <br>            lpEntryList-&gt;cValues = 0; <br> <br>            // Free SBinary array <br>            MAPIFREEBUFFER(lpEntryList); <br> <br>            *lppEntryList = NULL; <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIWriteStreamToFile---------------------------------------------------- <br>//  Write stream to a file given a file handle. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIWriteStreamToFile(        // RETURNS: return code <br>    IN LPSTREAM lpStream,               // Pointer to stream <br>    OUT HANDLE hFile)                   // Handle to file <br>{ <br>    HRESULT hr              = NOERROR; <br>    HRESULT hrT             = NOERROR; <br>    ULONG   cBytesRead      = 0; <br>    DWORD   cBytesWritten   = 0; <br>    BYTE    byteBuffer[128] = {0}; <br>    BOOL    fWriteOk        = FALSE; <br> <br>    DEBUGPUBLIC("HrMAPIWriteStreamToFile()\n"); <br> <br>    hr = CHK_HrMAPIWriteStreamToFile( <br>        lpStream, <br>        hFile); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    for(;;) <br>    { <br>        hrT = OLECALL(lpStream)-&gt;Read( <br>            lpStream, <br>            byteBuffer,  <br>            sizeof(byteBuffer), <br>            &amp;cBytesRead); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            break; <br>        } <br> <br>        if (cBytesRead == 0) <br>        { <br>            hr = NOERROR; <br>            break ;     <br>        } <br> <br>        fWriteOk = WriteFile( <br>            hFile, <br>            byteBuffer, <br>            cBytesRead, <br>            &amp;cBytesWritten, <br>            NULL); <br> <br>        if(fWriteOk == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            break; <br>        } <br> <br>        if(cBytesWritten != cBytesRead) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_ENOUGH_DISK); <br>            break; <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrMAPIWriteFileToStream---------------------------------------------------- <br>//  Write file to a stream given a stream pointer. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIWriteFileToStream(        // RETURNS: return code <br>    IN HANDLE hFile,                    // Handle to file <br>    OUT LPSTREAM lpStream)              // Pointer to stream <br>{ <br>    HRESULT hr              = NOERROR; <br>    HRESULT hrT             = NOERROR; <br>    DWORD   cBytesRead      = 0; <br>    ULONG   cBytesWritten   = 0; <br>    BYTE    byteBuffer[128] = {0}; <br>    BOOL    fReadOk         = FALSE; <br> <br>    DEBUGPUBLIC("HrMAPIWriteFileToStream()\n"); <br> <br>    hr = CHK_HrMAPIWriteFileToStream( <br>        hFile, <br>        lpStream); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    for(;;) <br>    { <br>        fReadOk = ReadFile( <br>            hFile, <br>            byteBuffer, <br>            sizeof(byteBuffer), <br>            &amp;cBytesRead, <br>            NULL); <br> <br>        if(fReadOk == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            break; <br>        } <br> <br>        if(cBytesRead == 0) <br>        { <br>            hr = NOERROR; <br>            break; <br>        } <br> <br>        hrT = OLECALL(lpStream)-&gt;Write( <br>            lpStream, <br>            byteBuffer,  <br>            cBytesRead, <br>            &amp;cBytesWritten); <br> <br>        if(FAILED(hrT)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            break; <br>        } <br>         <br>        if(cBytesWritten != cBytesRead) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_ENOUGH_DISK); <br>            break; <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrMAPIWriteAttachmentToFile----------------------------------------------- <br>//  Write the identified message attachment to a file. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIWriteAttachmentToFile(   // RETURNS: return code <br>    IN LPMESSAGE lpMessage,             // message containing the attachments <br>    IN ULONG iAttach,                   // attachment identifier <br>    OUT HANDLE hFile)                   // handle to file <br>{ <br>    HRESULT  hr          = NOERROR; <br>    HRESULT  hrT         = NOERROR; <br>    LPATTACH lpAttach    = NULL; <br>    LPSTREAM lpAttStream = NULL; <br> <br>    DEBUGPUBLIC("HrMAPIWriteAttachmentToFile()\n"); <br> <br>    hr = CHK_HrMAPIWriteAttachmentToFile( <br>        lpMessage, <br>        iAttach, <br>        hFile); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // <br>    //  Open the attachment. <br>    // <br> <br>    hrT = MAPICALL(lpMessage)-&gt;OpenAttach( <br>        lpMessage, <br>        iAttach, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS, <br>        &amp;lpAttach); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(lpAttach != NULL, "NULL lpAttach variable"); <br> <br>    // <br>    //  Get a stream interface on the attachment <br>    // <br> <br>    hrT = MAPICALL(lpAttach)-&gt;OpenProperty( <br>        lpAttach, <br>        PR_ATTACH_DATA_BIN, <br>        (LPIID)&amp;IID_IStream,  <br>        STGM_READ | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, <br>        MAPI_DEFERRED_ERRORS, <br>        (LPUNKNOWN *)&amp;lpAttStream); <br> <br>    if(FAILED(hrT)) <br>    { <br>        if(hrT == MAPI_E_NOT_FOUND) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Copy the attachment into a file. <br>    // <br> <br>    hrT = HrMAPIWriteStreamToFile(lpAttStream, hFile); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if(lpAttStream != NULL) <br>        OLECALL(lpAttStream)-&gt;Release(lpAttStream); <br> <br>    if(lpAttach != NULL) <br>        MAPICALL(lpAttach)-&gt;Release(lpAttach); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGotoSRow-------------------------------------------------------------- <br>//  Goto the specified SRow in an SRowSet. <br>//------------------------------------------------------------------------------ <br>HRESULT HrMAPIGotoSRow(                  // RETURNS: return code <br>    IN LPSRowSet FAR lpRows,            // pointer to SRowSet <br>    IN ULONG ulRow,                     // index of SRow in SRowSet <br>    OUT LPSRow *lppRow)                 // pointer to SRow <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrMAPIGotoSRow()\n"); <br> <br>    hr = CHK_HrMAPIGotoSRow( <br>        lpRows, <br>        ulRow, <br>        lppRow); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppRow = NULL; <br> <br>    if(ulRow &lt; lpRows-&gt;cRows) <br>    { <br>        *lppRow = &amp;(lpRows-&gt;aRow[ulRow]); <br>    } <br>    else <br>    { <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGotoFirstSRow--------------------------------------------------------- <br>//  Goto the first SRow in an SRowSet. <br>//------------------------------------------------------------------------------ <br>HRESULT HrMAPIGotoFirstSRow(             // RETURNS: return code <br>    IN LPSRowSet FAR lpRows,            // pointer to SRowSet <br>    OUT ULONG *lpulRow,                 // index of SRow in SRowSet <br>    OUT LPSRow *lppRow)                 // pointer to SRow <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrMAPIGotoFirstSRow()\n"); <br> <br>    hr = CHK_HrMAPIGotoFirstSRow( <br>        lpRows, <br>        lpulRow, <br>        lppRow); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpulRow = 0; <br> <br>    hr = HrMAPIGotoSRow( <br>        lpRows, <br>        0, <br>        lppRow); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIGotoNextSRow---------------------------------------------------------- <br>//  Goto the next SRow in an SRowSet. <br>//------------------------------------------------------------------------------ <br>HRESULT HrMAPIGotoNextSRow(              // RETURNS: return code <br>    IN LPSRowSet FAR lpRows,            // pointer to SRowSet <br>    IN OUT ULONG *lpulRow,              // index of SRow in SRowSet <br>    OUT LPSRow *lppRow)                 // pointer to SRow <br>{ <br>    HRESULT hr    = NOERROR; <br>    ULONG   ulRow = 0; <br> <br>    DEBUGPUBLIC("HrMAPIGotoNextSRow()\n"); <br> <br>    hr = CHK_HrMAPIGotoNextSRow( <br>        lpRows, <br>        lpulRow, <br>        lppRow); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    ulRow = *lpulRow; <br> <br>    ulRow++; <br> <br>    *lpulRow = ulRow; <br> <br>    hr = HrMAPIGotoSRow( <br>        lpRows, <br>        ulRow, <br>        lppRow); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIWriteStreamToMemory---------------------------------------------------- <br>//  Reads a given number of bytes from a stream to a block of memory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIWriteStreamToMemory(        // RETURNS: return code <br>    IN LPSTREAM lpStream,               // pointer to stream <br>    IN ULONG cBytes,                    // count of bytes in memory <br>    IN LPBYTE lpbBytes,                 // pointer to memory <br>    OUT ULONG *lpcBytesRead)            // count of bytes read from stream <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrMAPIWriteStreamToMemory()\n"); <br> <br>    hr = CHK_HrMAPIWriteStreamToMemory( <br>        lpStream, <br>        cBytes, <br>        lpbBytes, <br>        lpcBytesRead); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcBytesRead = 0; <br> <br>    // Read from the stream <br>    hrT = OLECALL(lpStream)-&gt;Read( <br>        lpStream, <br>        lpbBytes, <br>        cBytes, <br>        lpcBytesRead); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIWriteMemoryToStream--------------------------------------------------- <br>//  Writes a given number of bytes from a block of memory to a stream <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIWriteMemoryToStream(       // RETURNS: return code <br>    IN LPSTREAM lpStream,               // pointer to stream <br>    IN ULONG cBytes,                    // count of bytes in memory <br>    IN LPBYTE lpbBytes,                 // pointer to memory <br>    OUT ULONG *lpcBytesWritten)         // count of bytes written from stream <br>{ <br>    HRESULT hr  = NOERROR; <br>    HRESULT hrT = NOERROR; <br> <br>    DEBUGPUBLIC("HrMAPIWriteMemoryToStream()\n"); <br> <br>    hr = CHK_HrMAPIWriteMemoryToStream( <br>        lpStream, <br>        cBytes, <br>        lpbBytes, <br>        lpcBytesWritten); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcBytesWritten = 0; <br> <br>    // Write a block to the stream <br>    hrT = OLECALL(lpStream)-&gt;Write( <br>        lpStream, <br>        lpbBytes, <br>        cBytes, <br>        lpcBytesWritten); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if((*lpcBytesWritten) &lt; cBytes) <br>    { <br>        hr = HR_LOG(MAPI_E_NOT_ENOUGH_DISK); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPISetStreamSize--------------------------------------------------------- <br>//  Sets the size of the given stream. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPISetStreamSize(             // RETURNS: return code <br>    IN LPSTREAM lpStream,               // pointer to stream <br>    IN ULONG cBytes)                    // count of bytes in stream <br>{ <br>    HRESULT        hr  = NOERROR; <br>    HRESULT        hrT = NOERROR; <br>    ULARGE_INTEGER ll  = {0}; <br> <br>    DEBUGPUBLIC("HrMAPISetStreamSize()\n"); <br> <br>    hr = CHK_HrMAPISetStreamSize( <br>        lpStream, <br>        cBytes); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    ll.LowPart  = cBytes; <br>    ll.HighPart = 0; <br> <br>    hrT = OLECALL(lpStream)-&gt;SetSize(lpStream, ll); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
