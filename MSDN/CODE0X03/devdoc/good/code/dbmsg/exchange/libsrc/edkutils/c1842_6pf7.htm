<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>_VSOP.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1843"></a>_VSOP.H</h2>
<pre><code>//--_vsop.h-------------------------------------------------------------------- <br>// <br>// CEDKVirtualStreamOnProperty class header file. <br>// <br>// Copyright Microsoft Corp., 1986-1996.  All rights reserved. <br>// <br>//----------------------------------------------------------------------------- <br> <br>#ifndef __VSOP_H <br>#define __VSOP_H <br> <br>// maximum number of stream characters to buffer <br>const ULONGcbMaxBuffered=8192;// 8K data bytes <br> <br>//--$CEDKVirtualStreamOnProperty--------------------------------------------------------- <br>// <br>// Class which buffers stream access to a binary or string property. <br>// <br>//----------------------------------------------------------------------------- <br> <br>class CEDKVirtualStreamOnProperty : public IUnknown <br>{ <br>public: <br> <br>// The HrOpenVirtualStreamOnProperty() function is CEDKVirtualStreamOnProperty <br>// friend. <br>friend HRESULT _HrOpenVirtualStreamOnProperty( <br>    IN LPMAPIPROP pPropObject,// MAPI property object pointer <br>    IN ULONG ulPropTag,     // property tag to open virtual stream on <br>IN ULONG ulFlags,// MAPI property flags <br>    OUT PVIRTUALSTREAMONPROPERTY * ppVirtualStreamOnProperty);  // pointer buffered stream <br> <br>    // methods <br> <br>    // Note:  Order IS important.  The CEDKVirtualStreamOnProperty interface <br>    // must have the same vtable order as the IStream interface. <br> <br>    // IUnknown methods <br>STDMETHOD(QueryInterface)( <br>IN REFIID riid,         // interface identifier reference <br>OUT LPVOID * ppvObj);   // pointer to object pointer <br> <br>STDMETHOD_(ULONG, AddRef)(); <br> <br>STDMETHOD_(ULONG, Release)(); <br> <br>    // IStream Methods. <br>    //  <br>    // Note: Some methods are not currrently suppoerted. <br>    // These methods all return STG_E_INVALIDFUNCTION: <br>    // Seek, Clone, Revert, SetSize, UnlockRegion &amp; LockRegion. <br>    // <br>    STDMETHOD(Read)( <br>        IN LPVOID pv,       // output buffer pointer <br>        IN ULONG cb,        // maximum # of bytes to read <br>        OUT ULONG * pcb);   // # of bytes read <br> <br>    STDMETHOD(Write)( <br>        IN VOID const * pv, // data to write <br>        IN ULONG cb,        // # bytes to write <br>        OUT ULONG *pcb);    // # bytes written <br> <br>    STDMETHOD(Seek)( <br>        IN LARGE_INTEGER cbOffset,      // byte offset <br>        IN DWORD dwOrigin,              // origin <br>        OUT ULARGE_INTEGER * pcbPos);   // new position <br> <br>    STDMETHOD(SetSize)( <br>        IN ULARGE_INTEGER nSize);    // new size <br> <br>    STDMETHOD(CopyTo)( <br>        IN LPSTREAM pStrm,              // destination stream pointer <br>        IN ULARGE_INTEGER cb,           // # bytes to copy <br>        OUT ULARGE_INTEGER * pcbRead,   // # bytes read <br>        OUT ULARGE_INTEGER * pcbWritten);// # bytes written <br> <br>    STDMETHOD(Commit)(  <br>        IN DWORD dwFlags);   // flags <br> <br>    STDMETHOD(Revert)(); <br> <br>    STDMETHOD(LockRegion)( <br>        IN ULARGE_INTEGER cbOffset, // offset <br>        IN ULARGE_INTEGER cbLength, // length <br>        IN DWORD dwFlags);          // flags <br> <br>    STDMETHOD(UnlockRegion)( <br>        IN ULARGE_INTEGER cbOffset, // offset <br>        IN ULARGE_INTEGER cbLength, // length <br>        IN DWORD dwFlags);          // flags <br> <br>    STDMETHOD(Stat)( <br>        OUT STATSTG * pStatStg,     // stream statistic pointer <br>        IN DWORD dwFlags);          // flags <br> <br>    STDMETHOD(Clone)( <br>        OUT LPSTREAM * ppStrm);      // pointer to new stream <br> <br>protected: <br> <br>    // constructor <br>    CEDKVirtualStreamOnProperty(); <br> <br>    // destructor <br>    ~CEDKVirtualStreamOnProperty(); <br> <br>    // Initialize virtual stream on property data <br>    HRESULT HrInitialize( <br>    IN LPMAPIPROP pPropObject,// MAPI property object pointer <br>    IN ULONG ulPropTag,     // property tag to open virtual stream on <br>IN ULONG ulFlags);// MAPI property flags <br> <br>private: <br> <br>// Utility functions <br> <br>// Sets mode in the storage statistics structure <br>inline VOID SetMode( <br>IN ULONG ulMode)// stream mode <br>{ <br>m_StatStg.grfMode = ulMode; <br>} <br> <br>// returns TRUE if property opened for writing <br>inline BOOL fIsWriteProperty() <br>{ <br>return ( ((m_ulFlags &amp; MAPI_MODIFY) == MAPI_MODIFY) ); <br>} <br> <br>// returns TRUE if property to be created <br>inline BOOL fIsNewProperty() <br>{ <br>return ( ((m_ulFlags &amp; MAPI_CREATE) == MAPI_CREATE) ); <br>} <br> <br>// returns TRUE if property not opened for writing     <br>inline BOOL fIsReadProperty() <br>{ <br>return ( ((m_ulFlags &amp; MAPI_MODIFY) == 0) &amp;&amp;  <br>         ((m_ulFlags &amp; MAPI_CREATE) == 0) ); <br>} <br> <br>// calculates current size of stream. <br>HRESULT HrComputeCurrentSize( <br>IN ULARGE_INTEGER * pcbSize); <br> <br>// Initializes newly created data buffer to a particular size <br>inline VOID InitBufferSize( <br>IN ULONG cbSize)// new buffer size <br>{ <br>ASSERT_READ_PTR(m_rgbBuffer, cbSize, "Bad m_rgbBuffer"); <br> <br>m_cbBuffer = cbSize;// new buffer size <br>m_pbBuffer = m_rgbBuffer;// current data pointer <br>m_fDataInitialized = TRUE;// have read data <br> <br>// If buffer is a write buffer, <br>// then zero fill write buffer, including <br>// the extra space left for null-terminating <br>// exactly 8K long strings. (Read <br>// buffers will already be filled with data read.) <br>if ( fIsWriteProperty() == TRUE ) <br>{ <br>ASSERTERROR(cbSize == cbMaxBuffered, "Bad cbSize"); <br> <br>ZeroMemory( <br>m_rgbBuffer, <br>cbSize + sizeof(CHAR)); <br>} <br>} <br> <br>// Retrieves number of unread bytes in local data buffer <br>inline ULONG GetBytesUnread() <br>{ <br>return (m_cbBuffer - (m_pbBuffer - m_rgbBuffer)); <br>} <br> <br>// Retrieves number of unwritten bytes in local data buffer <br>inline ULONG GetBytesUnwritten() <br>{ <br>return (m_cbBuffer - (m_pbBuffer - m_rgbBuffer)); <br>} <br> <br>inline ULONG GetBytesWritten() <br>// Retrieves number of bytes written to local data buffer <br>{ <br>return (m_pbBuffer - m_rgbBuffer); <br>} <br> <br>// Increments number of bytes read in local data buffer <br>inline VOID IncrementBytesRead( <br>IN ULONG cbRead)// number of bytes read <br>{ <br>m_pbBuffer += cbRead; <br>} <br> <br>// Increments number of bytes written to local data buffer <br>inline VOID IncrementBytesWritten( <br>IN ULONG cbWritten)// number of bytes written <br>{ <br>m_pbBuffer += cbWritten; <br>} <br> <br>// Increments size of underlying stream <br>inline VOID IncrementStreamSize( <br>IN LARGE_INTEGER cbAdd)// number of bytes to add to stream size <br>{ <br>DWORDLONGcbCurrent=0;// current size <br>DWORDLONGcbIncrement=0;// amount ot add <br> <br>// Determine current stream size <br>cbCurrent = MAKEDWORDLONG(m_StatStg.cbSize.LowPart, <br>  m_StatStg.cbSize.HighPart); <br> <br>// Determine amount to increase stream size by. <br>cbIncrement = MAKEDWORDLONG(cbAdd.LowPart,cbAdd.HighPart); <br> <br>// Increment current stream size <br>cbCurrent += cbIncrement; <br> <br>// Set size in storage statistics structure <br>m_StatStg.cbSize.LowPart = LOWDWORD(cbCurrent); <br>m_StatStg.cbSize.HighPart = HIDWORD(cbCurrent);; <br> <br>} <br> <br>// Retrieves value of data initialized flag <br>inline BOOL fDataInitialized() <br>{ <br>return m_fDataInitialized; <br>} <br> <br>// Opens/Creates an underlying property stream for reading or writing. <br>HRESULT HrOpenUnderlyingStream(); <br> <br>// Flushes the data in the write buffer to the underlying stream. <br>HRESULT HrFlushWriteBuffer( <br>IN BOOL fCleanWriteBuffer);// TRUE if should zero out write buffer also <br> <br>// data members <br> <br>LPMAPIPROPm_pPropObject;// MAPI property object pointer <br>ULONGm_ulFlags;// MAPI property flags <br>ULONGm_ulPropTag;// MAPI property tag (must be string or binary) <br> <br>// underlying stream structures (if there is an underlying stream) <br>LPSTREAMm_pStream;// unbuffered stream pointer (if any) <br>    STATSTG m_StatStg;      // stream statistics <br> <br>// buffered read or write data (exclusive OR) <br>BYTE *m_rgbBuffer; <br>BYTE *m_pbBuffer;// pointer into the data buffer <br>ULONGm_cbBuffer;// current size of data buffer <br>BOOLm_fDataInitialized;// TRUE if data buffer has been initialized <br> <br>    ULONG   m_refs;         // reference count <br> <br>}; <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
