<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NEWPST.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1877"></a>NEWPST.CPP</h2>
<pre><code>// --newpst.cpp--------------------------------------------------------------- <br>// <br>// Implementation of the newpst library <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>//----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "mspst.h" <br>#include "newpst.chk" <br> <br>// <br>// Static storage <br>// <br> <br>static BOOLfProfileCreated =FALSE; <br> <br>static LPPROFADMINlpProfAdmin     =   NULL; <br>static LPSERVICEADMINlpSvcAdmin      =NULL; <br> <br>static MAPIUIDMsgStoreUID     =   {0}; <br> <br>// <br>// Functions <br>// <br> <br>// $--HrCreatePersonalStore---------------------------------------------------------- <br>// <br>// DESCRIPTION: Create a New PST with properties determined by the input <br>//parameters in a temporary profile.  The name and password <br>//of the temporary PST are returned to the user. <br>// <br>// INPUT: <br>// <br>//[lpszPSTPath]-- Value for PR_PST_PATH (new PST path). <br>//[dwEncryption]-- Value for PR_PST_ENCRYPTION (TBS). <br>//[lpszPSTDisplayName]-- Value for PR_DISPLAY_NAME (new PST display name). <br>//[lpszPSTPassword]-- Value for PR_PST_PW_SZ_NEW (new PST password, <br>//   NULL not accepted). <br>// <br>// OUTPUT: <br>// <br>//lppszProfileName-- Ptr that will be set to point at temporary <br>//   profile name on return; this may be used to <br>//   establish a MAPI session. <br>//lppszProfilePassword-- Ptr that will be set to point at temporary <br>//   profile password on return; this may be used to <br>//   establish a MAPI session. <br>// <br>// RETURNS:     NOERROR on success, <br>//              E_INVALIDARG if bad input, <br>//              E_ACCESSDENIED if can access profile <br>//  `           E_OUTOFMEMORY if memory problems <br>//              E_FAIL on general failure. <br>// <br>// Notes:Successive calls to CreateNewPST() should not be made without <br>//intervening calls to NewPSTCleanup().  Due to use of internal <br>//static storage for objects and profile strings, only one new <br>//PST may be created and used at a time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrCreatePersonalStore(                 // RETURNS HRESULT <br>INLPSTRlpszPSTPath,            // new PST fully-pathed name <br>INDWORDdwEncryption,           // encryption level <br>INLPSTRlpszPSTDisplayName,     // PR_DISPLAY_NAME value <br>INLPSTRlpszPSTPassword,        // new PST password <br>OUTLPSTR *lppszProfileName,       // temporary profile name <br>OUTLPSTR *lppszProfilePassword    // temporary profile password <br>) <br>{ <br>HRESULThr          =           NOERROR; <br>LPSPropValueaPropVals   =NULL; <br>LPSRowSetlpRows      =NULL; <br>LPMAPITABLElpTable     =NULL; <br>    const UINT      cbProfile   =           14;     // # chars in temporary profile name <br>    const UINT      cbPassword  =           1;      // # char in temporary password       <br> <br>    DEBUGPUBLIC("HrCreatePersonalStore()\n"); <br> <br>    // Check input values <br>    hr = CHK_HrCreatePersonalStore(lpszPSTPath, dwEncryption, lpszPSTDisplayName, <br>                            lpszPSTPassword, lppszProfileName, <br>                            lppszProfilePassword); <br>                                 <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>// Make sure we have not previously called CreateNewPST() without <br>// an intervening NewPSTCleanup() call.  When this occurs, we just <br>// return E_FAIL and do no cleanup, thus leaving the  <br>// previous profile and PST in place. <br> <br>if (lpProfAdmin != NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>} <br> <br>// Get a profile administration object. <br> <br>hr = MAPIAdminProfiles(0, &amp;lpProfAdmin); <br> <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>    } <br> <br>    // Allocate memory for temporary profile and password. <br>// Create the temporary profile. <br>    hr = MAPIAllocateBuffer(cbPassword * sizeof(CHAR),   // one character password <br>                            (PVOID *) lppszProfilePassword);  // pointer to string pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateBuffer(cbProfile * sizeof(CHAR), <br>                            (PVOID *) lppszProfileName); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(!IsBadWritePtr(lppszProfileName, sizeof(LPSTR)), <br>                "Bad lppszProfileName"); <br>    ASSERTERROR(!IsBadWritePtr(lppszProfilePassword, sizeof(LPSTR)), <br>                "Bad lppszProfilePassword"); <br> <br>{ <br>inti; <br> <br>**lppszProfilePassword = '\0';  // no password <br> <br>for (i = 0; (i &lt; 1000) &amp;&amp; (!fProfileCreated); i++) <br>{ <br>sprintf(*lppszProfileName, "PstLoadTmp%03.3u", i); <br> <br>hr = lpProfAdmin-&gt;CreateProfile(*lppszProfileName, <br>*lppszProfilePassword, <br>0, <br>0); <br> <br>            switch (hr)  <br>            {                 <br>               case MAPI_E_NO_ACCESS:   // name collision <br> <br>                hr = HR_LOG(E_ACCESSDENIED); <br> <br>                break; <br> <br>               default: <br>                if ( FAILED(hr) ) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br> <br>                    goto cleanup; <br>                } <br> <br>                fProfileCreated = TRUE; <br>                 <br>            }   // end switch    <br>}   // end for <br> <br>if (i == 1000) <br>        { <br>goto cleanup;// MAPI_E_NO_ACCESS will be returned. <br>        } <br>} <br> <br>// Get a service administration object. <br> <br>hr = lpProfAdmin-&gt;AdminServices(*lppszProfileName, <br>*lppszProfilePassword, <br>0, <br>0, <br>&amp;lpSvcAdmin); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>         <br>goto cleanup; <br>    } <br> <br>// Add the MS Personal Information Store service to the temporary profile. <br>// This will also happen to be set as the default store. <br> <br>hr = lpSvcAdmin-&gt;CreateMsgService("MSPST MS", <br>  "", // UI not used, so not needed. <br>  0, <br>  0); <br> <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>    } <br> <br>// Configure the MS Personal Information Store per NewPST entries. <br> <br>{ <br>ULONGcValues =   0; <br>LPSPropValuelpProp  =   NULL; <br> <br>    hr = lpSvcAdmin-&gt;GetMsgServiceTable(0, &amp;lpTable); <br> <br>if (FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>        } <br> <br>// We don't need to worry about checking all the columns; there should <br>// only be one since we just created the profile and added one service. <br> <br>    hr = lpTable-&gt;QueryRows(1, 0, &amp;lpRows); <br> <br>    if (FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>             <br>goto cleanup; <br>        } <br> <br>    if (lpRows == NULL) <br>{ <br>hr = HR_LOG(E_FAIL);// highly unlikely. <br> <br>goto cleanup; <br>} <br> <br>    cValues =lpRows-&gt;aRow[0].cValues; <br>    lpProp =lpRows-&gt;aRow[0].lpProps; <br> <br>    while (cValues) <br>    { <br>        if (lpProp-&gt;ulPropTag == PR_SERVICE_UID) <br>{ <br>MsgStoreUID = *((LPMAPIUID)lpProp-&gt;Value.bin.lpb); <br>break; <br>} <br> <br>        lpProp++; <br>cValues--; <br>    } <br> <br>if (cValues == 0) <br>{ <br>hr = HR_LOG(E_FAIL);// highly unlikely. <br> <br>goto cleanup; <br>} <br> <br>cValues = 6; <br> <br>hr = MAPIAllocateBuffer(cValues * sizeof(SPropValue), <br>(LPVOID *)&amp;aPropVals); <br> <br>        if ( FAILED(hr) ) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br> <br>goto cleanup; <br>} <br> <br>aPropVals[0].ulPropTag =PR_DISPLAY_NAME; <br>aPropVals[0].Value.lpszA =lpszPSTDisplayName; <br> <br>aPropVals[1].ulPropTag =PR_PST_PATH; <br>aPropVals[1].Value.lpszA =lpszPSTPath;; <br> <br>aPropVals[2].ulPropTag =PR_PST_REMEMBER_PW; <br>aPropVals[2].Value.b =TRUE; <br> <br>aPropVals[3].ulPropTag =PR_PST_ENCRYPTION; <br>aPropVals[3].Value.l =dwEncryption; <br> <br>aPropVals[4].ulPropTag =PR_PST_PW_SZ_NEW; <br>aPropVals[4].Value.lpszA =lpszPSTPassword; <br> <br>aPropVals[5].ulPropTag =PR_PST_PW_SZ_OLD; <br>aPropVals[5].Value.lpszA =*lppszProfilePassword; <br> <br>hr = lpSvcAdmin-&gt;ConfigureMsgService(&amp;MsgStoreUID, <br> 0, <br> 0, <br> cValues, <br> aPropVals); <br>if (FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>             <br>goto cleanup; <br>        } <br>} <br> <br>cleanup: <br> <br>    FREEPROWS(lpRows); <br> <br>ULRELEASE(lpTable); <br> <br>    MAPIFREEBUFFER(aPropVals); <br> <br>// This makes it an "all or none" call. <br> <br>if ( FAILED(hr) ) <br>    { <br>        if ( lppszProfileName ) <br>        { <br>            // remove temporary profile and  <br>            // release administration service. <br>    HrCleanupPSTGlobals(*lppszProfileName); <br> <br>            MAPIFREEBUFFER(*lppszProfileName); <br>        } <br> <br>        if ( lppszProfilePassword ) <br>        { <br>            MAPIFREEBUFFER(*lppszProfilePassword); <br>        } <br>    }   // end if failure <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrCleanupPSTGlobals----------------------------------------------------------- <br>// <br>// DESCRIPTION: Release objects involved in creation of a new PST. <br>// <br>// INPUT:       temporary profile name <br>// <br>// RETURNS:     NOERROR on success, <br>//              E_FAIL if error. <br>// <br>// Notes:This should be called after Logoff() and Release() are called <br>//for the LPSESSION and before MAPIUninitialize() is called. <br>//--------------------------------------------------------------------------- <br> <br>HRESULT HrCleanupPSTGlobals(         // RETURNS: HRESULT <br>        IN LPSTR lpszProfileName)   // temporary profile name <br>{ <br>HRESULThr  =   NOERROR;    // return code <br> <br>    DEBUGPUBLIC("HrCleanupPSTGlobals()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrCleanupPSTGlobals(lpszProfileName); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    ULRELEASE(lpSvcAdmin); <br> <br>if (fProfileCreated) <br>    { <br>hr = lpProfAdmin-&gt;DeleteProfile(lpszProfileName, 0); <br>    } <br> <br>ULRELEASE(lpProfAdmin); <br> <br>lpSvcAdmin =NULL; <br>fProfileCreated =FALSE; <br>lpProfAdmin =NULL; <br> <br>RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
