<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RULECLSI.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1882"></a>RULECLSI.CPP</h2>
<pre><code>// --ruleclsi.cpp------------------------------------------------------------- <br>// <br>//  Implementation file for the CIExchangeFolderRules programmer interface <br>//class. <br>// <br>//  The CFolderRules class is the controlling class.  It controls the <br>//  CIExchangeFolderRules class (which implements the IExchangeFolderRules  <br>//  programatic interface defined in rulecls.h and which this file <br>//  implements). <br>// <br>//  Copyright (C) Microsoft Corp. 1986-1996, All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "srowlst.h" <br>#include "ruleclsf.h" <br>#include "ruleclsi.chk" <br> <br>// IUnknown Methods --  <br>// Let the controlling parent object handle all of these! <br> <br>// $--CIExchangeFolderRules::QueryInterface------------------------------------ <br>// <br>// DESCRIPTION:Return ptr to object which implements the desired <br>//interface, if this object supports the interface. <br>// <br>//Implemented via the parent object's (CFolderRules') <br>//QueryInterface. <br>// <br>// INPUT: <br>// <br>// [riid]-- Reference to interface identifier of desired interface. <br>// <br>// OUTPUT: <br>// <br>// [ppvObj]-- Pointer to object which supports interface.  NULL if none. <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input; <br>//E_NOINTERFACEif interface not supported. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderRules::QueryInterface(// RETURNS: HRESULT <br>INREFIIDriid,       // interface ID reference <br>OUTLPVOID FAR *ppvObj      // ptr to interface ptr <br>) <br>{ <br>    HRESULThr =NOERROR; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::QueryInterface().\n"); <br> <br>    hr = CHK_CIExchangeFolderRules_QueryInterface(riid, ppvObj); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), <br>                            "Bad m_pFR"); <br> <br>    // Let parent controlling object handle this.  (Let it do all <br>    // parameter checking also!) <br> <br>    hr = m_pFR-&gt;QueryInterface(riid, ppvObj); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderRules::AddRef-------------------------------------------- <br>// <br>// DESCRIPTION:Increment this object's reference count. <br>// <br>//Implemented via the parent object's (CFolderRules') AddRef(). <br>// <br>// INPUT:None. <br>// <br>// RETURNS:New reference count. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CIExchangeFolderRules::AddRef()// RETURNS: ULONG <br>{ <br>    ULONGulRefCount =0; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::AddRef().\n"); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), <br>                            "Bad m_pFR"); <br> <br>    // Let parent controlling object handle this. <br> <br>    ulRefCount = m_pFR-&gt;AddRef(); <br> <br>    return ulRefCount; <br>} <br> <br> <br>// $--CIExchangeFolderRules::Release------------------------------------------- <br>// <br>// DESCRIPTION:Decrement this object's reference count. <br>// <br>//Implemented via the parent object's (CFolderRules') <br>//Release(). <br>// <br>// INPUT:None. <br>// <br>// RETURNS:New reference count. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CIExchangeFolderRules::Release()    // RETURNS: ULONG <br>{ <br>    ULONGulRefCount =0; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::Release().\n"); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), <br>                            "Bad m_pFR"); <br> <br>    // Let parent controlling object handle this. <br> <br>    ulRefCount = m_pFR-&gt;Release(); <br> <br>    return ulRefCount; <br>} <br> <br>// <br>// Methods unique to the IExchangeFolderRules interface. <br>// <br> <br>// $--CIExchangeFolderRules::HrDelete------------------------------------------ <br>// <br>// DESCRIPTION:Delete the current record. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:NOERRORif successful;  <br>//              E_FAILif cursor at RULE_PAST_END; <br>//              E_OUTOFMEMORYif insufficient memory. <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderRules::HrDelete(VOID)// RETURNS: HRESULT <br>{ <br>    HRESULThr =NOERROR; <br>LPMAPITABLElpMapiTbl =NULL; <br>LPROWLISTlpRowList =NULL; <br>LPSRowSetlpRows =NULL; <br>CSROWNODE *pDeletedNode =NULL; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::HrDelete().\n"); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), "Bad m_pFR."); <br> <br>hr = m_pFR-&gt;m_SRowLst.HrRemoveFromLst(&amp;pDeletedNode); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (m_pFR-&gt;m_SRowLst.GetNodeCount() + <br>m_pFR-&gt;m_SRowLst.GetOtherProvNodeCount() &gt; 0) <br>{ <br>hr = m_pFR-&gt;m_SRowLst.HrWriteToTable(m_pFR-&gt;m_lpExchTbl); <br>} <br>else <br>{ <br>// Workaround BUGFIX for bug 2435.  This code works around a problem <br>// in IExchangeModifyTable::ModifyTable() whereby a ROWLIST_REPLACE <br>// operation fails if the replacement table is empty.  We should be <br>// able to remove this code once this problem is fixed in <br>// IExchangeModifyTable. <br> <br>SizedSPropTagArray(1, rgPropTag) = <br>{ <br>1, <br>{ <br>PR_RULE_ID <br>} <br>}; <br> <br>// Get the PR_RULE_ID for the one remaining rule in the table. <br> <br>hr = m_pFR-&gt;m_lpExchTbl-&gt;GetTable(0, &amp;lpMapiTbl); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Select columns needed. <br> <br>hr = lpMapiTbl-&gt;SetColumns((LPSPropTagArray)&amp;rgPropTag, 0); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>hr = lpMapiTbl-&gt;QueryRows(1, 0, &amp;lpRows); <br> <br>if (FAILED(hr) || lpRows-&gt;cRows != 1) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Delete the rule. <br> <br>hr = MAPIAllocateBuffer(CbNewROWLIST(1), (LPVOID FAR *)&amp;lpRowList); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>lpRowList-&gt;cEntries = 1; <br> <br>lpRowList-&gt;aEntries[0].ulRowFlags =ROW_REMOVE; <br>lpRowList-&gt;aEntries[0].cValues =lpRows-&gt;aRow[0].cValues; <br>lpRowList-&gt;aEntries[0].rgPropVals =lpRows-&gt;aRow[0].lpProps; <br> <br>// Remove the entry. <br> <br>hr = m_pFR-&gt;m_lpExchTbl-&gt;ModifyTable(0, lpRowList); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>cleanup: <br> <br>if (FAILED(hr) &amp;&amp; pDeletedNode != NULL) <br>{ <br>HRESULThrTmp = m_pFR-&gt;m_SRowLst.HrInsert(&amp;pDeletedNode-&gt;m_SRow); <br> <br>if (FAILED(hrTmp)) <br>hr = HR_LOG(E_UNEXPECTED); <br>else <br>pDeletedNode-&gt;m_SRow.lpProps = NULL; <br>} <br> <br>delete pDeletedNode; <br> <br>MAPIFREEBUFFER(lpRowList); <br>FREEPROWS(lpRows); <br>ULRELEASE(lpMapiTbl); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderRules::HrDisable----------------------------------------- <br>// <br>// DESCRIPTION:Disable the current rule. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:NOERRORif successful;  <br>//              E_FAILif cursor at RULE_PAST_END or corrupt data; <br>//              E_OUTOFMEMORYif insufficient memory. <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderRules::HrDisable(VOID)// RETURNS: HRESULT <br>{ <br>    HRESULThr =NOERROR; <br>LONGlPrevState =0; <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::HrDisable().\n"); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), <br>                            "Bad m_pFR."); <br> <br>pNode = m_pFR-&gt;m_SRowLst.GetCurrentNode(); <br> <br>if (pNode == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (pNode-&gt;m_SRow.cValues &lt; C_RULEPROPS || <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].ulPropTag != PR_RULE_STATE) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Save the previous state in case the table write fails. <br> <br>lPrevState = pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l; <br> <br>// Note - Given the actual values for ST_ENABLED and ST_DISABLED, the <br>// following clearing AND setting of bits is really not necessary; however <br>// we do it this way in case the bits ever get redefined (currently <br>// ST_DISABLED == 0x0000). <br> <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l &amp;= ~ST_ENABLED; <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l |= ST_DISABLED; <br> <br>hr = m_pFR-&gt;m_SRowLst.HrWriteToTable(m_pFR-&gt;m_lpExchTbl); <br> <br>if (FAILED(hr)) <br>{ <br>// The table write failed, so reset the list to the previous value. <br> <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l = lPrevState; <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderRules::HrEnable------------------------------------------ <br>// <br>// DESCRIPTION:Enable the current rule. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:NOERRORif successful;  <br>//              E_FAILif cursor at RULE_PAST_END or corrupt data; <br>//              E_OUTOFMEMORYif insufficient memory. <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderRules::HrEnable(VOID)// RETURNS: HRESULT <br>{ <br>    HRESULThr =NOERROR; <br>LONGlPrevState =0; <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::HrEnable().\n"); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), <br>                            "Bad m_pFR."); <br> <br>pNode = m_pFR-&gt;m_SRowLst.GetCurrentNode(); <br> <br>if (pNode == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (pNode-&gt;m_SRow.cValues &lt; C_RULEPROPS || <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].ulPropTag != PR_RULE_STATE) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Save the previous state in case the table write fails. <br> <br>lPrevState = pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l; <br> <br>// Note - Given the actual values for ST_ENABLED and ST_DISABLED, the <br>// following clearing AND setting of bits is really not necessary; however <br>// we do it this way in case the bits ever get redefined (currently <br>// ST_DISABLED == 0x0000). <br> <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l &amp;= ~ST_DISABLED; <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l |= ST_ENABLED; <br> <br>hr = m_pFR-&gt;m_SRowLst.HrWriteToTable(m_pFR-&gt;m_lpExchTbl); <br> <br>if (FAILED(hr)) <br>{ <br>// The table write failed, so reset the list to the previous value. <br> <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l = lPrevState; <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderRules::HrGet--------------------------------------------- <br>// <br>// DESCRIPTION:Get the current record and advance the cursor. <br>// <br>// OUTPUT: <br>// <br>//   [lplState]--  Rule state buffer. <br>//   [lppRestriction]--  Restriction buffer. <br>//   [lppActions]--  Actions buffer. <br>//   [lplLevel]--  Rule level buffer. <br>//   [lppszName]--  Rule name buffer. <br>// <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input; <br>//              E_FAILif cursor at RULE_PAST_END; <br>//              E_OUTOFMEMORYif insufficient memory. <br>// <br>// Notes:Space for *lplState and *lplLevel is allocated by the user. <br>//Space for the other parameters is allocated by this method. <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderRules::HrGet(// RETURNS: HRESULT <br>OUTLPLONGlplState,// state ptr <br>OUTLPSRestriction FAR *lppRestriction, // restriction buffer ptr <br>OUTLPACTIONS FAR *lppActions,// actions buffer ptr <br>OUTLPLONGlplLevel,// level ptr <br>OUTLPSTR FAR *lppszName   // rule name ptr <br>) <br>{ <br>    HRESULThr =NOERROR;     <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::HrGet().\n"); <br> <br>    hr = CHK_CIExchangeFolderRules_HrGet(lplState, <br>        lppRestriction, <br>        lppActions, <br>     lplLevel, <br>     lppszName); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>// Null the ptrs so we can free them on failure. <br> <br>*lppRestriction =NULL; <br>*lppActions =NULL; <br>*lppszName =NULL; <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), "Bad m_pFR."); <br> <br>pNode = m_pFR-&gt;m_SRowLst.GetCurrentNode(); <br> <br>if (pNode == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (pNode-&gt;m_SRow.cValues &lt; C_RULEPROPS|| <br>pNode-&gt;m_SRow.lpProps[I_RULE_SEQUENCE].ulPropTag != <br>PR_RULE_SEQUENCE|| <br>pNode-&gt;m_SRow.lpProps[I_RULE_STATE].ulPropTag != <br>PR_RULE_STATE|| <br>pNode-&gt;m_SRow.lpProps[I_RULE_CONDITION].ulPropTag != <br>PR_RULE_CONDITION|| <br>pNode-&gt;m_SRow.lpProps[I_RULE_ACTIONS].ulPropTag != <br>PR_RULE_ACTIONS|| <br>pNode-&gt;m_SRow.lpProps[I_RULE_LEVEL].ulPropTag != <br>PR_RULE_LEVEL|| <br>pNode-&gt;m_SRow.lpProps[I_RULE_NAME].ulPropTag != <br>PR_RULE_NAME) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>*lplState = pNode-&gt;m_SRow.lpProps[I_RULE_STATE].Value.l; <br> <br>if (pNode-&gt;m_SRow.lpProps[I_RULE_CONDITION].Value.x != NULL) <br>{ <br>hr = HrCopyRestriction((LPSRestriction)pNode-&gt; <br>   m_SRow.lpProps[I_RULE_CONDITION].Value.x, <br>   NULL, <br>       lppRestriction); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>hr = HrCopyActions( <br>(LPACTIONS)pNode-&gt;m_SRow.lpProps[I_RULE_ACTIONS].Value.x, <br>NULL, <br>lppActions); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>*lplLevel = pNode-&gt;m_SRow.lpProps[I_RULE_LEVEL].Value.l; <br> <br>if (pNode-&gt;m_SRow.lpProps[I_RULE_NAME].Value.lpszA != NULL) <br>{ <br>ULONGcb = strlen(pNode-&gt;m_SRow.lpProps[I_RULE_NAME].Value.lpszA)  <br> + sizeof(char); <br> <br>hr = MAPIAllocateBuffer(cb, (LPVOID FAR *)lppszName); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>strcpy(*lppszName, <br>   pNode-&gt;m_SRow.lpProps[I_RULE_NAME].Value.lpszA); <br>} <br> <br>// Advance the cursor. <br> <br>m_pFR-&gt;m_SRowLst.SetCursor(m_pFR-&gt;m_SRowLst.GetCursor() + 1); <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(*lppRestriction); <br>MAPIFREEBUFFER(*lppActions); <br>MAPIFREEBUFFER(*lppszName); <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderRules::HrInsert------------------------------------------ <br>// <br>// DESCRIPTION:Insert record before the current record and advance the cursor. <br>// <br>// INPUT: <br>// <br>//   [lState]-- Rule state. <br>//   [lpRestriction]-- Restriction. <br>//   [lpActions]-- Actions. <br>//   [lLevel]-- Rule level. <br>//   [lpszRule]-- Rule name. <br>// <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input; <br>//              E_OUTOFMEMORYif memory problems; <br>//              E_FAILotherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderRules::HrInsert(// RETURNS: HRESULT <br>INLONGlState,         // rule state <br>INLPSRestrictionlpRestriction,  // restriction ptr <br>INLPACTIONSlpActions,      // actions ptr <br>INLONGlLevel,// rule level <br>INLPSTRlpszName// rule name <br>) <br>{ <br>    HRESULThr =NOERROR; <br>LPACTIONSlpActionsCopy =NULL; <br>LPSRestrictionlpRestrictionCopy =NULL; <br>LPSTRlpszNameCopy =NULL; <br>LONGlPosInsertion =RULE_PAST_END; <br>SRowsr = {0, C_RULEPROPS, NULL}; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::HrInsert().\n"); <br> <br>    hr = CHK_CIExchangeFolderRules_HrInsert(lState, <br>  lpRestriction, <br>  lpActions, <br>  lLevel, <br>  lpszName); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), <br>                            "Bad m_pFR."); <br> <br>hr = MAPIAllocateBuffer(sizeof(SPropValue) * C_RULEPROPS, <br>(LPVOID FAR *)&amp;sr.lpProps); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>goto cleanup; <br>    } <br> <br>memset(sr.lpProps, 0, sizeof(SPropValue) * C_RULEPROPS); <br> <br>hr = HrCopyActions(lpActions, sr.lpProps, &amp;lpActionsCopy); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = HrCopyRestriction(lpRestriction, sr.lpProps, &amp;lpRestrictionCopy); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = MAPIAllocateMore(strlen(lpszName) + sizeof(char), <br>  sr.lpProps, <br>    (LPVOID FAR *)&amp;lpszNameCopy); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>goto cleanup; <br>    } <br> <br>strcpy(lpszNameCopy, lpszName); <br> <br>sr.lpProps[I_RULE_SEQUENCE].ulPropTag = PR_RULE_SEQUENCE; <br>sr.lpProps[I_RULE_SEQUENCE].Value.ul =0; <br>// SROWLST::Insert() resets value as appropriate. <br> <br>sr.lpProps[I_RULE_STATE].ulPropTag =PR_RULE_STATE; <br>sr.lpProps[I_RULE_STATE].Value.l =lState; <br> <br>sr.lpProps[I_RULE_CONDITION].ulPropTag =PR_RULE_CONDITION; <br>sr.lpProps[I_RULE_CONDITION].Value.ul =(ULONG)lpRestrictionCopy; <br> <br>sr.lpProps[I_RULE_ACTIONS].ulPropTag =PR_RULE_ACTIONS; <br>sr.lpProps[I_RULE_ACTIONS].Value.ul =(ULONG)lpActionsCopy; <br> <br>sr.lpProps[I_RULE_PROVIDER].ulPropTag =PR_RULE_PROVIDER; <br>sr.lpProps[I_RULE_PROVIDER].Value.lpszA =NULL; <br>// SROWLST::Insert() sets value as appropriate. <br> <br>sr.lpProps[I_RULE_LEVEL].ulPropTag =PR_RULE_LEVEL; <br>sr.lpProps[I_RULE_LEVEL].Value.l =lLevel; <br> <br>sr.lpProps[I_RULE_NAME].ulPropTag =PR_RULE_NAME; <br>sr.lpProps[I_RULE_NAME].Value.lpszA =lpszNameCopy; <br> <br>// The following code determines the cursor value the newly inserted <br>// record will have.  This is done so we can easily delete the <br>// record if the table write fails. <br> <br>lPosInsertion = m_pFR-&gt;m_SRowLst.GetCursor(); <br> <br>if (lPosInsertion == RULE_PAST_END) <br>lPosInsertion = m_pFR-&gt;m_SRowLst.GetNodeCount(); <br> <br>hr = m_pFR-&gt;m_SRowLst.HrInsert(&amp;sr); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = m_pFR-&gt;m_SRowLst.HrWriteToTable(m_pFR-&gt;m_lpExchTbl); <br> <br>if (FAILED(hr)) <br>{ <br>HRESULThrTmp =NOERROR; <br> <br>// Delete the node from the list, since the table write failed. <br> <br>m_pFR-&gt;m_SRowLst.SetCursor(lPosInsertion); <br> <br>hrTmp = m_pFR-&gt;m_SRowLst.HrDelete(); <br> <br>if (FAILED(hrTmp)) <br>hr = HR_LOG(E_UNEXPECTED); <br> <br>// The memory allocated by this method was cleaned up when the <br>// node was deleted. <br> <br>sr.lpProps = NULL; <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>MAPIFREEBUFFER(sr.lpProps); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderRules::HrSeek-------------------------------------------- <br>// <br>// DESCRIPTION:Set the current cursor position. <br>// <br>// INPUT: <br>// <br>// [lPos]-- New cursor position. <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderRules::HrSeek(// RETURNS: HRESULT <br>INLONGlPos// cursor position <br>) <br>{ <br>    HRESULThr =NOERROR; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::HrSeek().\n"); <br> <br>    hr = CHK_CIExchangeFolderRules_HrSeek(lPos); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), "Bad m_pFR."); <br> <br>m_pFR-&gt;m_SRowLst.SetCursor(lPos); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderRules::HrTell-------------------------------------------- <br>// <br>// DESCRIPTION:Return the current cursor position. <br>// <br>// OUTPUT: <br>// <br>// [plPos]-- Pointer for returning current cursor position. <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderRules::HrTell(// RETURNS: HRESULT <br>OUTLPLONGlplPos// cursor position ptr <br>) <br>{ <br>    HRESULThr =NOERROR; <br> <br>    DEBUGPUBLIC("CIExchangeFolderRules::HrTell().\n"); <br> <br>    hr = CHK_CIExchangeFolderRules_HrTell(lplPos); <br>     <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFR, sizeof(CFolderRules FAR *), "Bad m_pFR."); <br> <br>*lplPos = m_pFR-&gt;m_SRowLst.GetCursor(); <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
