<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MONITOR.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1876"></a>MONITOR.C</h2>
<pre><code>// --monitor.c------------------------------------------------------------------ <br>// <br>//  This file implements the monitored object side of the EDK performance  <br>//  monitoring component. <br>// <br>//  This component uses the stats.lib to generate a suite of statistics.  The  <br>//  statistics are periodically copied to a memory area shared with the other  <br>//  side of the performance monitoring component: a performance DLL which is  <br>//  called by the NT Performance Monitor. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "monshare.h" <br>#include "monctx.h" <br>#include "monitor.chk" <br> <br>// <br>// Internal Function Declarations <br>// <br> <br>static HRESULT HrAllocateContext( <br>OUT LPMONCONTEXT *lppmcx); <br> <br>static HRESULT HrGetCurrentTime( <br>OUT __int64 * lpdwlTime); <br> <br>static HRESULT HrReadObjectClass( <br>IN LPMONCONTEXT lpmcx); <br> <br>static HRESULT HrReadRegistryInfo( <br>IN LPMONCONTEXT lpmcx); <br> <br>static HRESULT HrReadRegistryDWORD( <br>IN HKEY hKey, <br>IN LPSTR lpszValueName, <br>OUT LPDWORD lpdwValue); <br> <br>static HRESULT HrCreateSharedMemory( <br>IN LPMONCONTEXT lpmcx); <br> <br>static HRESULT HrFillInSharedMemory( <br>IN LPMONCONTEXT lpmcx,  <br>IN DWORD ccdCounters, <br>IN LPCOUNTERDEF lpcdCounters); <br> <br>static HRESULT HrBuildStructures( <br>IN LPMONCONTEXT lpmcx, <br>IN DWORD ccdCounters, <br>IN LPCOUNTERDEF lpcdCounters); <br> <br>static HRESULT HrMonFindFolder( <br>IN  LPMONFOLDER   lpmfFolderList, <br>IN  LPMAPIFOLDER  lpFolder, <br>OUT LPMONFOLDER * lppmfFolder); <br> <br>static HRESULT HrStartUpdateThread( <br>IN LPMONCONTEXT lpmcx); <br> <br>static DWORD WINAPI UpdateThread( <br>IN LPVOID lpThreadParameter); <br> <br>static HRESULT HrFreeEverything( <br>IN LPMONCONTEXT *lppmcx); <br> <br>static HRESULT HrFreeCounterList( <br>IN LPMONCOUNTER *lppmcCounterList); <br> <br>static HRESULT HrFreeFolderList( <br>IN LPMONFOLDER *lppmfFolderList); <br> <br>static HRESULT HrAddToCounters( <br>IN LPMONCONTEXT lpmcx, <br>IN LPMONCOUNTER lpmcList, <br>IN LONG dwAmount); <br> <br>static HRESULT HrSetCounters( <br>IN LPMONCOUNTER lpmcList, <br>IN DWORD dwAmount); <br> <br>static HRESULT HrComputeCounterType( <br>IN  COUNTERTYPE ctStatistic, <br>IN  PERIODTYPE perPeriod, <br>IN  DWORD dwUserCounterType, <br>OUT DWORD *lpdwCounterType); <br> <br>static HRESULT HrAlignPointer( <br>IN     DWORD cbAlignment, <br>IN OUT LPVOID * lppvPointer); <br> <br>static ULONG STDAPICALLTYPE FolderNotification( <br>IN LPVOID lpvContext, <br>IN DWORD cNotification, <br>IN LPNOTIFICATION lpNotifications); <br> <br>static HRESULT HrWakeUpdateThread( <br>IN LPMONCONTEXT lpmcx); <br> <br>static HRESULT HrRegisterNotification( <br>IN LPMONCONTEXT lpmcx); <br> <br>static HRESULT HrLinkCounterIntoList( <br>IN LPMONCONTEXT lpmcx, <br>IN LPMONFOLDER lpmf, <br>IN LPMONCOUNTER lpmc, <br>IN COUNTERTYPE ctCounterType); <br> <br>static HRESULT HrVerifyLinkage( <br>IN LPMONCONTEXT lpmcx); <br> <br>static HRESULT HrSaveSharedMemoryInRegistry( <br>    IN LPMONCONTEXT lpmcx); <br> <br>// <br>// Local Variable Declarations <br>// <br> <br>static LPMONCONTEXT lpmcxContext = NULL; // place to save allocated context <br> <br>// Security descriptor to allow all access -- only need to initialize once!!! <br> <br>static BOOL fSecurityDescriptorInitialized = FALSE; <br> <br>static SECURITY_ATTRIBUTES sa; <br>static char rgbForSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH]; <br> <br>static SECURITY_ATTRIBUTES * psa = &amp;sa; <br>static SECURITY_DESCRIPTOR * psd  <br>                    = (SECURITY_DESCRIPTOR *)rgbForSecurityDescriptor; <br> <br>// <br>// Monitor API Routines <br>// <br> <br>//$--HrMonInit-------------------------------------------------------------- <br>//  Begins performance monitoring of the current monitored object. <br>// <br>//  If lpszObjectClass != NULL, then use lpszObjectClass as the class of the   <br>//  monitored object. <br>//  If lpszObjectClass == NULL, then read the object class from the  <br>//  Parameters\ObjectClass value under the object's registry key, or if  <br>//  it's not present, assume that the object class is the same as the object  <br>//  name. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMonInit( // RETURNS: HRESULT <br>IN DWORD dwFlags,// for future use--must be zero <br>IN LPSTR lpszObjectClass,// class of monitored object, or NULL <br>IN LPSTR lpszObjectName, // gateway instance name <br>IN DWORD dwObjectTitleOffset,// index number of object name in  <br>// the registry database (offset from <br>// First Counter) <br>IN DWORD dwObjectDetailLevel,// complexity of object (see winperf.h) <br>IN LONG dwDefaultCounter,// zero-based number of default counter  <br>// for this object <br>IN DWORD ccdNumberOfCounters,// number of counter structures <br>// being passed in <br>IN LPCOUNTERDEF lpcdCounters)// pointer to array of counter <br>// structures <br>{ <br>    // This routine creates a "context" structure in allocated memory that  <br>    // holds all the information needed for performance monitoring.  When fully  <br>    // allocated, this context contains open handles to various objects, and  <br>    // pointers to other allocated memory structures.  HrMonInit() calls  <br>    // several other routines, each of which allocates some of the handles  <br>    // and structures attached to the context. <br>    // <br>    // If one of these routines fails for any reason, it does NOT clean up what  <br>    // it has created in the context.  Instead, it simply returns an error, and  <br>    // then HrMonInit calls a "catch-all" cleanup routine called  <br>    // HrFreeEverything().  HrFreeEverything frees/closes anything attached  <br>    // to the context and then frees the context itself.  HrFreeEverything()  <br>    // is also called by MonitorShutdown() to end performance monitoring. <br> <br>HRESULThr = NOERROR; <br> <br>DEBUGPUBLIC("HrMonInit()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrMonInit( <br>dwFlags,  <br>lpszObjectClass,  <br>lpszObjectName,  <br>dwObjectTitleOffset,  <br>dwObjectDetailLevel,  <br>dwDefaultCounter,  <br>ccdNumberOfCounters,  <br>lpcdCounters); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // Set up a security descriptor with a NULL DACL, to allow all <br>    // access to an object.  This is used if we need to create the <br>    // mutex and shared memory section. <br> <br>    if (!fSecurityDescriptorInitialized) <br>    { <br>        if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)) <br>        { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup_no_free; <br>        } <br> <br>        if (!SetSecurityDescriptorDacl(psd, TRUE, (PACL) NULL, FALSE)) <br>        { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup_no_free; <br>        } <br> <br>        psa-&gt;nLength = sizeof(*psa); <br>        psa-&gt;lpSecurityDescriptor = psd; <br>        psa-&gt;bInheritHandle = TRUE; <br> <br>        fSecurityDescriptorInitialized = TRUE; <br>    } <br> <br>    // Make sure this hasn't already been called before. <br> <br>if (lpmcxContext != NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup_no_free; <br>} <br> <br>// Allocate and zero out performance monitoring context. <br> <br>hr = HrAllocateContext(&amp;lpmcxContext); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// Store various parameters in the context. <br> <br>lpmcxContext-&gt;iObjectTitleOffset = dwObjectTitleOffset; <br>lpmcxContext-&gt;dwObjectDetailLevel = dwObjectDetailLevel; <br>lpmcxContext-&gt;dwDefaultCounter = dwDefaultCounter; <br> <br>// Get the current system time and put it in the context. <br> <br>hr = HrGetCurrentTime(&amp;lpmcxContext-&gt;dwlCurrentTime); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// Add allocated copies of the gateway type name and instance name to  <br>// the performance monitoring context.  If they passed NULL for the  <br>    // gateway type then read it from the Parameters\ObjectClass value  <br>    // under the gateway's service entry in the registry. <br> <br>lpmcxContext-&gt;lpszObjectName = _strdup(lpszObjectName); <br>if (lpmcxContext-&gt;lpszObjectName == NULL) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>    if (lpszObjectClass) <br>    { <br>    lpmcxContext-&gt;lpszObjectClass = _strdup(lpszObjectClass); <br>    if (lpmcxContext-&gt;lpszObjectClass == NULL) <br>    { <br>    hr = HR_LOG(E_OUTOFMEMORY); <br>    goto cleanup; <br>    } <br>    } <br>    else <br>    { <br>        hr = HrReadObjectClass(lpmcxContext); <br>        if (FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>    // Verify that there is a back link from the gateway type to the  <br>    // gateway name so the DLL can link to our shared memory section. <br> <br>    hr = HrVerifyLinkage(lpmcxContext); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// Read the Counter and Help values from the registry. <br> <br>hr = HrReadRegistryInfo(lpmcxContext); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// Create the shared memory section and mutex.  This leaves us as the  <br>// owner of the mutex and we must release it before we return. <br> <br>hr = HrCreateSharedMemory(lpmcxContext); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// Fill in the shared memory section with the structure that will be  <br>// passed to the DLL, and from there to the Performance Monitor. <br> <br>hr = HrFillInSharedMemory( <br>lpmcxContext, ccdNumberOfCounters, lpcdCounters); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>    // Save a copy of the shared memory block to the registry so that  <br>    // GWPERF.DLL will be able to generate a blank set of counters when  <br>    // the gateway isn't running. <br> <br>    hr = HrSaveSharedMemoryInRegistry(lpmcxContext); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// Set up structures representing folders, and linked lists of counters  <br>// hanging off the performance monitoring context. <br> <br>hr = HrBuildStructures( <br>lpmcxContext, ccdNumberOfCounters, lpcdCounters); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// Register the notification routines on all folders that need them. <br> <br>hr = HrRegisterNotification(lpmcxContext); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// If there are any jumping sliding windows or folders, then start  <br>// the thread that updates them. <br> <br>if (lpmcxContext-&gt;lpmcJSWCounterList || lpmcxContext-&gt;lpmfFolderList) <br>{ <br>hr = HrStartUpdateThread(lpmcxContext); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br>} <br> <br>// Set flag that the shared memory data structure is now valid. <br> <br>lpmcxContext-&gt;lpmsmSharedMemory-&gt;fDataIsValid = TRUE; <br> <br>// Release the mutex (it was "locked" when the mutex was created). <br> <br>hr = HrMonUnlockCounters(); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>cleanup: <br>if (FAILED(hr)) <br>{ <br>        HRESULT hrT = NOERROR; <br> <br>hrT = HrFreeEverything(&amp;lpmcxContext); <br>        if (FAILED(hrT)) <br>            HR_LOG(hrT); <br>} <br> <br>cleanup_no_free: <br>RETURN(hr); <br>} <br> <br> <br>  <br>//$--HrMonUninit---------------------------------------------------------- <br>//  Ends performance monitoring of the current gateway. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMonUninit(void)    // RETURNS: HRESULT <br>{ <br>HRESULThr = NOERROR; <br> <br>DEBUGPUBLIC("HrMonUninit()\n"); <br> <br>    // Make sure there's a context. <br> <br>    if (lpmcxContext == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>ASSERT_WRITE_PTR(lpmcxContext, sizeof(*lpmcxContext),  <br>"lpmcxContext: bad write pointer"); <br> <br>// Shut down, and free the context and all memory attached to it. <br> <br>hr = HrFreeEverything(&amp;lpmcxContext); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrMonCollectNDRStats---------------------------------------------------- <br>//  Call this after processing an NDR. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMonCollectNDRStats(// RETURNS: HRESULT <br>IN DWORD cNDRs,// number of NDR's processed <br>IN DIRECTIONTYPE dir)// direction of NDR's <br>{ <br>HRESULThr = NOERROR; <br>HRESULThrT= NOERROR; <br> <br>DEBUGPUBLIC("HrMonCollectNDRStats()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrMonCollectNDRStats(cNDRs, dir); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // Make sure there's a context. <br> <br>    if (lpmcxContext == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>ASSERT_WRITE_PTR(lpmcxContext, sizeof(*lpmcxContext),  <br>"lpmcxContext: bad write pointer"); <br> <br>    // Lock the shared memory against modification. <br> <br>hr = HrMonLockCounters(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Get current time for JSW's. <br> <br>hr = HrGetCurrentTime(&amp;lpmcxContext-&gt;dwlCurrentTime); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Update the counters. <br> <br>switch (dir) <br>{ <br>case DIRECTIONTYPE_IN: <br>hr = HrAddToCounters(lpmcxContext, lpmcxContext-&gt;lpmcNDRsIn, cNDRs); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>break; <br> <br>case DIRECTIONTYPE_OUT: <br>hr = HrAddToCounters(lpmcxContext, lpmcxContext-&gt;lpmcNDRsOut, cNDRs); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>break; <br>} <br> <br>cleanup: <br>    // Unlock the shared memory. <br> <br>    if (lpmcxContext) <br>    { <br>    hrT = HrMonUnlockCounters(); <br>        if (FAILED(hrT)) <br>        { <br>            hr = hrT; <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrMonCollectMessageXferStats------------------------------------- <br>//  Call this after transferring a message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMonCollectMessageXferStats( // RETURNS: HRESULT <br>IN DWORD cMessages, // number of messages transferred <br>IN DWORD cBytes, // number of bytes transferred <br>IN DIRECTIONTYPE dir)// direction of message transfer <br>{ <br>HRESULThr= NOERROR; <br>HRESULThrT= NOERROR; <br> <br>DEBUGPUBLIC("HrMonCollectMessageXferStats()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrMonCollectMessageXferStats(cMessages, cBytes, dir); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // Make sure there's a context. <br> <br>    if (lpmcxContext == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>ASSERT_WRITE_PTR(lpmcxContext, sizeof(*lpmcxContext),  <br>"lpmcxContext: bad write pointer"); <br> <br>hr = HrMonLockCounters(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>hr = HrGetCurrentTime(&amp;lpmcxContext-&gt;dwlCurrentTime); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>switch (dir) <br>{ <br>case DIRECTIONTYPE_IN: <br> <br>hr = HrAddToCounters( <br>lpmcxContext,  <br>lpmcxContext-&gt;lpmcMessagesTransferredIn,  <br>cMessages); <br>            if (FAILED(hr)) <br>                goto cleanup; <br> <br>hr = HrAddToCounters( <br>lpmcxContext,  <br>lpmcxContext-&gt;lpmcBytesTransferredIn,  <br>cBytes); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>break; <br> <br>case DIRECTIONTYPE_OUT: <br> <br>hr = HrAddToCounters( <br>lpmcxContext,  <br>lpmcxContext-&gt;lpmcMessagesTransferredOut,  <br>cMessages); <br>            if (FAILED(hr)) <br>                goto cleanup; <br> <br>hr = HrAddToCounters( <br>lpmcxContext,  <br>lpmcxContext-&gt;lpmcBytesTransferredOut,  <br>cBytes); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>break; <br>} <br> <br>cleanup: <br>    if (lpmcxContext) <br>    { <br>    hrT = HrMonUnlockCounters(); <br>        if (FAILED(hrT)) <br>        { <br>            hr = hrT; <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrMonCollectAssociationStats-------------------------------------------- <br>//  Call this after making or breaking an association, or to set a new total  <br>//  number of associations. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMonCollectAssociationStats( // RETURNS: HRESULT <br>IN BOOL fSetNewTotal,// if TRUE, iAssociations becomes  <br>// the new total of associations. <br>// if FALSE, iAssociations is added  <br>// to the number of associations. <br> <br>IN LONG cAssociations)// number of associations to add to <br>// total (can be negative), or new  <br>// total if fSetNewTotal == TRUE <br>{ <br>HRESULThr= NOERROR; <br>HRESULThrT= NOERROR; <br> <br>DEBUGPUBLIC("HrMonCollectAssociationStats()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrMonCollectAssociationStats(fSetNewTotal, cAssociations); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // Make sure there's a context. <br> <br>    if (lpmcxContext == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>ASSERT_WRITE_PTR(lpmcxContext, sizeof(*lpmcxContext),  <br>"lpmcxContext: bad write pointer"); <br> <br>hr = HrMonLockCounters(); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>hr = HrGetCurrentTime(&amp;lpmcxContext-&gt;dwlCurrentTime); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>if (fSetNewTotal) <br>{ <br>// Set all counters to the given value. <br> <br>ASSERTERROR(cAssociations &gt;= 0,  <br>"cAssociations &lt; 0 on set associations"); <br> <br>hr = HrSetCounters( <br>lpmcxContext-&gt;lpmcAssociations,  <br>cAssociations); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>} <br>else <br>{ <br>// Add given value to counters (value can be negative). <br> <br>hr = HrAddToCounters( <br>lpmcxContext,  <br>lpmcxContext-&gt;lpmcAssociations,  <br>cAssociations); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>} <br> <br>cleanup: <br>    if (lpmcxContext) <br>    { <br>    hrT = HrMonUnlockCounters(); <br>        if (FAILED(hrT)) <br>        { <br>            hr = hrT; <br>        } <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrMonLockCounters------------------------------------------------------ <br>//  Locks the block of counters against access by other threads/processes. <br>//  This should be called before accessing a user defined counter. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMonLockCounters(void)// RETURNS: HRESULT <br>{ <br>    HRESULT         hr              = NOERROR; <br>DWORDdwReturnValue= 0; <br> <br>DEBUGPUBLIC("HrMonLockCounters()\n"); <br> <br>    // Make sure there's a context. <br> <br>    if (lpmcxContext == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>ASSERT_WRITE_PTR(lpmcxContext, sizeof(*lpmcxContext),  <br>"lpmcxContext: bad write pointer"); <br>ASSERTERROR(lpmcxContext-&gt;hSharedMemoryMutex != NULL,  <br>"lpmcxContext-&gt;hSharedMemoryMutex == NULL"); <br> <br>dwReturnValue = WaitForSingleObject( <br>lpmcxContext-&gt;hSharedMemoryMutex,  <br>MON_MUTEX_TIMEOUT); <br>if (dwReturnValue == WAIT_FAILED || dwReturnValue == WAIT_TIMEOUT) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>ASSERTERROR( <br>dwReturnValue == WAIT_FAILED ||  <br>dwReturnValue == WAIT_ABANDONED ||  <br>dwReturnValue == WAIT_OBJECT_0 ||  <br>dwReturnValue == WAIT_TIMEOUT,  <br>"dwReturnValue: illegal value"); <br> <br>ASSERTERROR(dwReturnValue != WAIT_TIMEOUT,  <br>"lpmcxContext-&gt;hSharedMemoryMutex: dwReturnValue == WAIT_TIMEOUT"); <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrMonUnlockCounters---------------------------------------------------- <br>//  Unlocks the block of counters to allow access by other threads/processes. <br>//  This should be called after accessing a user defined counter. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMonUnlockCounters(void)// RETURNS: HRESULT <br>{ <br>    HRESULT         hr              = NOERROR; <br>BOOL fItWorked = FALSE; <br> <br>DEBUGPUBLIC("HrMonUnlockCounters()\n"); <br> <br>    // Make sure there's a context. <br> <br>    if (lpmcxContext == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>ASSERT_WRITE_PTR(lpmcxContext, sizeof(*lpmcxContext),  <br>"lpmcxContext: bad write pointer"); <br>ASSERTERROR(lpmcxContext-&gt;hSharedMemoryMutex != NULL,  <br>"lpmcxContext-&gt;hSharedMemoryMutex == NULL"); <br> <br>fItWorked = ReleaseMutex(lpmcxContext-&gt;hSharedMemoryMutex); <br>if (!fItWorked) <br>{ <br>        DWORD dwStatus = GetLastError(); <br> <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>// <br>// Internal Helper Functions <br>// <br> <br> <br> <br>//$--HrAllocateContext---------------------------------------------------------- <br>//  Helper function that allocates a new performance monitoring context and  <br>//  zeros out its components. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrAllocateContext(    // RETURNS: HRESULT <br>OUT LPMONCONTEXT *lppmcx)// pointer to address variable for <br>// performance monitor context ptr <br>{ <br>LPMONCONTEXTlpmcxNew = NULL; <br>HRESULThr = NOERROR; <br> <br>DEBUGPRIVATE("HrAllocateContext()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrAllocateContext(lppmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>lpmcxNew = malloc(sizeof(*lpmcxNew)); <br>if (lpmcxNew == NULL) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br>ZeroMemory(lpmcxNew, sizeof(*lpmcxNew)); <br>*lppmcx = lpmcxNew; <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrGetCurrentTime----------------------------------------------------------- <br>//  Helper function that returns the current system time in 8-byte format. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetCurrentTime(// RETURNS: HRESULT <br>OUT __int64 * lpdwlTime)// current time <br>{ <br>HRESULThr = NOERROR; <br>SYSTEMTIMEst= {0}; <br>__int64dwlTime= 0; <br>BOOLfItWorked= TRUE; <br> <br>DEBUGPRIVATE("HrGetCurrentTime()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrGetCurrentTime(lpdwlTime); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>GetSystemTime(&amp;st); <br>fItWorked = SystemTimeToFileTime(&amp;st, &amp;TO_FILETIME(dwlTime)); <br>if (!fItWorked) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>} <br> <br>*lpdwlTime = dwlTime; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadRegistryInfo--------------------------------------------------------- <br>//  Helper function that reads the First Counter and First Help values from the  <br>//  SYSTEM\CurrentControlSet\Services\&lt;lpszObjectClass&gt;\Performance key. <br>//  Note that the context must already have lpszObjectClass defined. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadRegistryInfo(    // RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx)// pointer to perf mon context <br>{ <br>HRESULThr            = NOERROR; <br>DWORDdwStatus        = 0; <br>TCHARszKeyName[MAX_PATH]     = {0}; <br>HKEYhKey        = NULL; <br>DWORDcch        = 0; <br> <br>DEBUGPRIVATE("HrReadRegistryInfo()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrReadRegistryInfo(lpmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>ASSERT_STRING_PTR(lpmcx-&gt;lpszObjectClass,  <br>"lpmcx-&gt;lpszObjectClass: bad string pointer"); <br> <br>// Create the registry key name from the gateway type. <br> <br>cch = wsprintf( <br>szKeyName,  <br>TEXT("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance"),  <br>lpmcx-&gt;lpszObjectClass); <br>ASSERTERROR( <br>(cch * sizeof(*szKeyName)) &lt; sizeof(szKeyName),  <br>"wsprintf overflow: szKeyName"); <br> <br>// Open the registry key. <br> <br>dwStatus = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE,  <br>szKeyName,  <br>0L,  <br>KEY_READ,  <br>&amp;hKey); <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Read the values: First Counter, First help, Last Counter, Last Help. <br> <br>hr = HrReadRegistryDWORD(hKey, "First Counter",  <br>&amp;lpmcx-&gt;dwFirstCounter); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>hr = HrReadRegistryDWORD(hKey, "First Help",  <br>&amp;lpmcx-&gt;dwFirstHelp); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>hr = HrReadRegistryDWORD(hKey, "Last Counter",  <br>&amp;lpmcx-&gt;dwLastCounter); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>hr = HrReadRegistryDWORD(hKey, "Last Help",  <br>&amp;lpmcx-&gt;dwLastHelp); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>// Close the registry key (if it's open). <br> <br>if (hKey) <br>{ <br>dwStatus = RegCloseKey(hKey); <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>            hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>RETURN (hr); <br>} <br> <br> <br> <br>//$--HrReadObjectClass---------------------------------------------------------- <br>//  Helper function that reads the gateway type out of the registry. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadObjectClass(       // RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx)              // pointer to perf mon context <br>{ <br>HRESULThr        = NOERROR; <br>    DWORD       dwStatus                = ERROR_SUCCESS; <br>    BOOL        fValueNotFound          = FALSE; <br>TCHARszKeyName[MAX_PATH]     = {0}; <br>HKEYhKey        = NULL; <br>DWORDcch        = 0; <br>    DWORD       dwType                  = 0; <br>    TCHAR       szObjectClass[MAX_PATH] = {0}; <br>    DWORD       cbObjectClass           = sizeof(szObjectClass); <br> <br>DEBUGPRIVATE("HrReadObjectClass()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrReadObjectClass(lpmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Create the registry key name from the gateway name. <br> <br>cch = wsprintf( <br>szKeyName,  <br>TEXT("SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters"),  <br>lpmcx-&gt;lpszObjectName); <br>ASSERTERROR( <br>(cch * sizeof(*szKeyName)) &lt; sizeof(szKeyName),  <br>"wsprintf overflow: szKeyName"); <br> <br>// Open the registry key. <br> <br>dwStatus = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE,  <br>szKeyName,  <br>0L,  <br>KEY_READ,  <br>&amp;hKey); <br>if (dwStatus != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    // Read the value. <br> <br>    dwStatus = RegQueryValueEx( <br>        hKey,  <br>        TEXT("ObjectClass"),  <br>        NULL,  <br>        &amp;dwType,  <br>        szObjectClass,  <br>        &amp;cbObjectClass); <br>if (dwStatus != ERROR_SUCCESS || dwType != REG_SZ) <br>    { <br>        if (dwStatus == ERROR_FILE_NOT_FOUND) <br>            fValueNotFound = TRUE; <br>        else <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    // Add it to the context. <br> <br>    lpmcx-&gt;lpszObjectClass = _strdup(szObjectClass); <br>    if (lpmcx-&gt;lpszObjectClass == NULL) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>    } <br> <br>cleanup: <br>    // If we couldn't read it then use the gateway name as the type. <br> <br>    if (fValueNotFound) <br>    { <br>        lpmcx-&gt;lpszObjectClass = _strdup(lpmcx-&gt;lpszObjectClass); <br>        if (lpmcx-&gt;lpszObjectClass == NULL) <br>    hr = HR_LOG(E_FAIL); <br>    } <br> <br>// Close the registry key (if it's open). <br> <br>if (hKey) <br>{ <br>dwStatus = RegCloseKey(hKey); <br>        if (dwStatus != ERROR_SUCCESS) <br>            hr = HR_LOG(E_FAIL); <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadRegistryDWORD-------------------------------------------------------- <br>//  Helper function that reads a DWORD value from the registry and makes sure <br>//  everything is as it should be. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadRegistryDWORD(    // RETURNS: HRESULT <br>IN HKEY hKey,// open key handle <br>IN LPSTR lpszValueName,// name of value to get <br>OUT LPDWORD lpdwValue)// address of DWORD to return value <br>{ <br>HRESULThr= NOERROR; <br>DWORDdwStatus= ERROR_SUCCESS; <br>DWORDdwValueType= 0; <br>DWORDdwValueSize= sizeof(*lpdwValue); <br> <br>DEBUGPRIVATE("HrReadRegistryDWORD()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrReadRegistryDWORD(hKey, lpszValueName, lpdwValue); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>dwStatus = RegQueryValueEx( <br>hKey,  <br>lpszValueName,  <br>0L,  <br>&amp;dwValueType,  <br>(LPBYTE)lpdwValue,  <br>&amp;dwValueSize); <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>hr = HR_LOG(E_FAIL); <br>} <br>else if (dwValueType != REG_DWORD) <br>{ <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCreateSharedMemory------------------------------------------------------- <br>//  Helper function that creates a shared memory section and a mutex. <br>//  NOTE: On successful return, the mutex will be owned by the current thread <br>//  and must be released. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCreateSharedMemory(// RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx)// pointer to performance monitoring <br>// context <br>{ <br>HRESULThr            = NOERROR; <br>CHARszMappingName[MAX_PATH]     = {0}; <br>CHARszMutexName[MAX_PATH]       = {0}; <br>BOOLfItWorked            = FALSE; <br>DWORDcch            = 0; <br> <br>DEBUGPRIVATE("HrCreateSharedMemory()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrCreateSharedMemory(lpmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>ASSERTERROR(lpmcx-&gt;cbSharedMemorySize == 0,  <br>"lpmcx-&gt;cbSharedMemorySize != 0"); <br>ASSERTERROR(lpmcx-&gt;hSharedMemoryMapping == NULL,  <br>"lpmcx-&gt;hSharedMemoryMapping != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmsmSharedMemory == NULL,  <br>"lpmcx-&gt;lpmsmSharedMemory != NULL"); <br>ASSERTERROR(lpmcx-&gt;hSharedMemoryMutex == NULL,  <br>"lpmcx-&gt;hSharedMemoryMutex != NULL"); <br> <br>// Create the name of the mutex that controls access to the shared memory. <br> <br>cch = wsprintf( <br>szMutexName,  <br>MON_MUTEX_NAME_TEMPLATE,  <br>lpmcx-&gt;lpszObjectName); <br>ASSERTERROR( <br>(cch * sizeof(*szMutexName)) &lt; sizeof(szMutexName),  </code></pre>
<p>
</p>
<pre><code>"wsprintf overflow: szMutexName"); <br>(void) CharUpper(szMutexName); <br> <br>MODULE_STATUS1("mutex name = [%s]", szMutexName); <br> <br>// First try to open the mutex and get ownership. <br> <br>lpmcx-&gt;hSharedMemoryMutex = OpenMutex( <br>        MUTEX_ALL_ACCESS,  <br>        FALSE,  <br>        szMutexName); <br>    if (lpmcx-&gt;hSharedMemoryMutex) <br>    { <br>        hr = HrMonLockCounters(); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // If the mutex didn't exist then create it and get ownership. <br> <br>    else <br>    { <br>        if (GetLastError() != ERROR_FILE_NOT_FOUND) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    lpmcx-&gt;hSharedMemoryMutex = CreateMutex( <br>    psa, <br>    TRUE, <br>    szMutexName); <br>    if (lpmcx-&gt;hSharedMemoryMutex == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>    } <br> <br>// Set the shared memory size. <br> <br>lpmcx-&gt;cbSharedMemorySize = sizeof(MONSHAREDMEMORY); <br> <br>// Create name of shared memory file mapping object. <br> <br>cch = wsprintf( <br>szMappingName,  <br>MON_MAPPING_NAME_TEMPLATE,  <br>lpmcx-&gt;lpszObjectName); <br>ASSERTERROR( <br>(cch * sizeof(*szMappingName)) &lt; sizeof(szMappingName),  <br>"wsprintf overflow: szMappingName"); <br>(void) CharUpper(szMappingName); <br> <br>MODULE_STATUS1("mapping name = [%s]", szMappingName); <br> <br>    // First try to open the shared memory file mapping object. <br> <br>lpmcx-&gt;hSharedMemoryMapping = OpenFileMapping( <br>        FILE_MAP_ALL_ACCESS,  <br>        FALSE,  <br>        szMappingName); <br> <br>// If the file mapping object didn't exist then create it. <br> <br>    if (lpmcx-&gt;hSharedMemoryMapping == NULL) <br>    { <br>        if (GetLastError() != ERROR_FILE_NOT_FOUND) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>    lpmcx-&gt;hSharedMemoryMapping = CreateFileMapping( <br>    (HANDLE)0xFFFFFFFF, // create in paging file <br>    psa, // no security <br>    PAGE_READWRITE, // read/write access <br>    0, // size (high) <br>    lpmcx-&gt;cbSharedMemorySize, // size(low) <br>    szMappingName);// mapping object name <br> <br>    if (lpmcx-&gt;hSharedMemoryMapping == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>    } <br> <br>// Map a view of the file mapping object. <br> <br>lpmcx-&gt;lpmsmSharedMemory = MapViewOfFile( <br>lpmcx-&gt;hSharedMemoryMapping,  <br>FILE_MAP_ALL_ACCESS,  <br>0,  <br>0,  <br>lpmcx-&gt;cbSharedMemorySize); <br> <br>if (lpmcx-&gt;lpmsmSharedMemory == NULL) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br>    ZeroMemory(lpmcx-&gt;lpmsmSharedMemory, lpmcx-&gt;cbSharedMemorySize); <br> <br>// Set the flag that the shared memory is not valid yet. <br> <br>lpmcx-&gt;lpmsmSharedMemory-&gt;fDataIsValid = FALSE; <br> <br>    // Set the signature value. <br> <br>    lpmcx-&gt;lpmsmSharedMemory-&gt;dwSignature = MON_SHARED_MEMORY_SIGNATURE; <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrFillInSharedMemory------------------------------------------------------- <br>//  Helper function that fills in the shared memory section with the structure  <br>//  that is sent to the Windows NT Performance Monitor via the DLL. <br>// <br>//  This process is done in two passes.  The first pass sets up the various  <br>//  pointers into the structure where data will be written, but does not write  <br>//  any actual data.  After the first pass, the size of the resulting structure  <br>//  is known, and a check is made to see that the resulting structure will fit  <br>//  into the shared memory section.  The second pass then takes the pointers  <br>//  that were set up by the first pass and fills in the actual data. <br>// <br>//  The structure that is created in the shared memory section has the  <br>//  following format, which conforms to the specification in WINPERF.H for  <br>//  the structure used to communicate with the Windows NT Performance Monitor: <br>// <br>//   /+===============================+ <br>//  / |  _PERF_OBJECT_TYPE            | <br>// |  +===============================+ <br>// |  |  _PERF_COUNTER_DEFINITION #1  | <br>// |  +-------------------------------+ <br>//"Header ----&gt;|  |  _PERF_COUNTER_DEFINITION #2  | <br>// Data" |  +-------------------------------+ <br>// |  :  ...........................  : <br>// |  +-------------------------------+ <br>//  \ |  _PERF_COUNTER_DEFINITION #N  | <br>//   &gt;+===============================+ <br>//  / |  _PERF_INSTANCE_DEFINITION    | <br>// |  +-------------------------------+ <br>// |  |  Instance Name (UNICODE)      | <br>// |  +===============================+ <br>// |  |  _PERF_COUNTER_BLOCK          | <br>// |  +-------------------------------+ <br>//"Instance --&gt;|  |  Counter #1 (COUNTER)         | <br>// Data" |  +-------------------------------+ <br>// |  |  Counter #2 (COUNTER)         | <br>// |  +-------------------------------+ <br>// |  |  ....................         : <br>// |  +-------------------------------+ <br>//  \ |  Counter #N (COUNTER)         | <br>//   \+===============================+ <br>// <br>//  In addition to the above structure, the shared memory section contains  <br>//  some housekeeping information that is used to communicate with the  <br>//  DLL, but is not sent to the Windows NT Performance Monitor.  This  <br>//  information is described in the shared memory structure defined in  <br>//  MONSHARE.H.  In this housekeeping information is information that tells  <br>//  the DLL how to break the structure diagrammed above into two parts:  <br>//  "Header Data" and "Instance Data".  This is done so that if there are two  <br>//  instances of a gateway communicating with the same DLL, the DLL can easily  <br>//  take the "Header Data" from one gateway and combine it with the  <br>//  "Instance Data" sections from both gateways to form a single  <br>//  structure to pass to the Windows NT Performance Monitor.  This allows  <br>//  the user of Performance Monitor to see the gateways as a single object  <br>//  with multiple instances, rather than two separate objects. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrFillInSharedMemory(// RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx, // pointer to perf mon context <br>IN DWORD ccdCounters,// number of COUNTERDEF structures <br>IN LPCOUNTERDEF lpcdCounters)// array of COUNTERDEF structures <br>{ <br>HRESULThr= NOERROR; <br> <br>// Variables used to create _PERF_COUNTER_DEFINITION structures, and to  <br>// create MONFOLDER and MONCOUNTER structures. <br> <br>DWORDiCounter= 0; <br>LPCOUNTERDEFlpcdSrc= NULL; <br>PPERF_COUNTER_DEFINITIONlpDest= NULL; <br>LPCOUNTERDEFlpcdCounter= NULL; <br> <br>// Pointers used to allocate chunks off of the  <br>// MONSHAREDMEMORY.rgbDataBlock[] structure. <br> <br>LPBYTElpbNextFreeByte= NULL; <br>LPBYTElpbNextFreeByteLim= NULL; <br> <br>// Pointers to structures defined in winperf.h. <br> <br>PPERF_OBJECT_TYPElpObjectType= NULL; <br>PPERF_COUNTER_DEFINITIONlpCounterDefinition= NULL; <br>PPERF_INSTANCE_DEFINITIONlpInstanceDefinition= NULL; <br>LPWSTRlpwszInstanceName= NULL; <br>DWORDcwInstanceNameSize= 0; <br>PPERF_COUNTER_BLOCKlpCounterBlock= NULL; <br>LPCOUNTERlpcntCounter= NULL; <br>    DWORD                       cLargeCounters          = 0; <br>    DWORD                       iCounterAllocated       = 0; <br>LPBYTElpbStructureEnd= NULL; <br> <br>DEBUGPRIVATE("HrFillInSharedMemory()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrFillInSharedMemory(lpmcx, ccdCounters, lpcdCounters); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>ASSERTERROR(lpmcx-&gt;lpcntCounter == NULL, "lpmcx-&gt;lpcntCounter != NULL"); <br> <br>    // Count the number of user-defined counters that are of size  <br>    // PERF_SIZE_LARGE because we will have to allow double space for them. <br>    // While we're counting, if we find any counters of size PERF_SIZE_ZERO  <br>    // or PERF_SIZE_VARIABLE_LEN then return an error, because we don't  <br>    // support those types. <br> <br>    for (iCounter = 0; iCounter &lt; ccdCounters; iCounter++) <br>    { <br>        if (lpcdCounters[iCounter].ctStatistic == COUNTERTYPE_USER_DEFINED) <br>        { <br>            switch (lpcdCounters[iCounter].dwUserCounterType &amp; 0x00000300) <br>            { <br>                case PERF_SIZE_LARGE: <br>                    cLargeCounters++; <br>                    break; <br> <br>                case PERF_SIZE_DWORD: <br>                    break; <br> <br>                default: <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>            } <br>        } <br>    } <br> <br>    // Initially zero out the block in shared memory. <br> <br>    ZeroMemory(lpmcx-&gt;lpmsmSharedMemory-&gt;rgbDataBlock, MON_DATA_BLOCK_SIZE); <br> <br>// Set pointers into the build buffer area of shared memory. <br>// These pointers are used to get chunks of memory from the  <br>// buffer and check for overflow. <br> <br>lpbNextFreeByte = lpmcx-&gt;lpmsmSharedMemory-&gt;rgbDataBlock; <br>lpbNextFreeByteLim = lpbNextFreeByte + MON_DATA_BLOCK_SIZE; <br> <br>// Set pointers into the build buffer for where the various structures  <br>// will go (don't fill anything in just yet--we have to check for overflow  <br>// first!). <br> <br>hr = HrAlignPointer(4, &amp;lpbNextFreeByte); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>lpObjectType = (PERF_OBJECT_TYPE *)lpbNextFreeByte; <br>lpbNextFreeByte += sizeof(*lpObjectType); <br> <br>lpCounterDefinition = (PERF_COUNTER_DEFINITION *)lpbNextFreeByte; <br>lpbNextFreeByte += ccdCounters * sizeof(*lpCounterDefinition); <br> <br>lpInstanceDefinition = (PERF_INSTANCE_DEFINITION *)lpbNextFreeByte; <br>lpbNextFreeByte += sizeof(*lpInstanceDefinition); <br> <br>// NOTE: Instance name is always UNICODE!!! <br> <br>lpwszInstanceName = (LPWSTR)lpbNextFreeByte; <br> <br>// Calculate how many characters are needed for the conversion. <br>if (lstrlen(lpmcx-&gt;lpszObjectName) == 0) <br>{ <br>cwInstanceNameSize = 0; <br>} <br>else <br>{ <br>cwInstanceNameSize = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,  <br>lpmcx-&gt;lpszObjectName, -1, 0, 0); <br>if (cwInstanceNameSize == 0) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>cwInstanceNameSize--; <br>} <br> <br>lpbNextFreeByte += (cwInstanceNameSize + 1) * sizeof(WCHAR); <br> <br>hr = HrAlignPointer(4, &amp;lpbNextFreeByte); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>lpCounterBlock = (PERF_COUNTER_BLOCK *)lpbNextFreeByte; <br>lpbNextFreeByte += sizeof(lpCounterBlock-&gt;ByteLength); <br> <br>lpcntCounter = (LPCOUNTER)lpbNextFreeByte; <br>lpbNextFreeByte += (ccdCounters + cLargeCounters) * sizeof(COUNTER); <br> <br>hr = HrAlignPointer(4, &amp;lpbNextFreeByte); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>lpbStructureEnd = lpbNextFreeByte; <br> <br>// Check for overflow. <br> <br>if (lpbNextFreeByte &gt; lpbNextFreeByteLim) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>// Fill in _PERF_OBJECT_TYPE structure. <br> <br>lpObjectType-&gt;TotalByteLength = lpbStructureEnd - (LPBYTE)lpObjectType; <br>lpObjectType-&gt;DefinitionLength =  <br>(LPBYTE)lpInstanceDefinition - (LPBYTE)lpObjectType; <br>lpObjectType-&gt;HeaderLength =  <br>(LPBYTE)lpCounterDefinition - (LPBYTE)lpObjectType; <br>lpObjectType-&gt;ObjectNameTitleIndex =  <br>lpmcx-&gt;dwFirstCounter + lpmcx-&gt;iObjectTitleOffset; <br>if (lpObjectType-&gt;ObjectNameTitleIndex &gt; lpmcx-&gt;dwLastCounter) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>lpObjectType-&gt;ObjectNameTitle = NULL; <br>lpObjectType-&gt;ObjectHelpTitleIndex =  <br>lpmcx-&gt;dwFirstHelp + lpmcx-&gt;iObjectTitleOffset; <br>if (lpObjectType-&gt;ObjectHelpTitleIndex &gt; lpmcx-&gt;dwLastHelp) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>lpObjectType-&gt;ObjectHelpTitle = NULL; <br>lpObjectType-&gt;DetailLevel = lpmcx-&gt;dwObjectDetailLevel; <br>lpObjectType-&gt;NumCounters = ccdCounters; <br>lpObjectType-&gt;DefaultCounter = lpmcx-&gt;dwDefaultCounter; <br>lpObjectType-&gt;NumInstances = 1; <br>lpObjectType-&gt;CodePage = 0; <br>lpObjectType-&gt;PerfTime.LowPart = 0; <br>lpObjectType-&gt;PerfTime.HighPart = 0; <br>lpObjectType-&gt;PerfFreq.LowPart = 0; <br>lpObjectType-&gt;PerfFreq.HighPart = 0; <br> <br> <br>// Fill in _PERF_COUNTER_DEFINITION structures. <br> <br>    // Set iCounterAllocated = 1 to skip a DWORD at the front for the  <br>    // PERF_COUNTER_BLOCK header. <br> <br>    iCounterAllocated = 1; <br> <br>for (iCounter = 0; iCounter &lt; ccdCounters; ++iCounter) <br>{ <br>lpcdSrc = &amp;lpcdCounters[iCounter]; <br>lpDest = &amp;lpCounterDefinition[iCounter]; <br> <br>ASSERT_DETAIL_LEVEL(lpcdSrc-&gt;dwDetailLevel,  <br>"lpcdSrc-&gt;dwDetailLevel: invalid value"); <br> <br>lpDest-&gt;ByteLength = sizeof(*lpDest); <br>lpDest-&gt;CounterNameTitleIndex =  <br>lpmcx-&gt;dwFirstCounter + lpcdSrc-&gt;iCounterTitleOffset; <br>if (lpDest-&gt;CounterNameTitleIndex &gt; lpmcx-&gt;dwLastCounter) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>lpDest-&gt;CounterNameTitle = NULL; <br>lpDest-&gt;CounterHelpTitleIndex =  <br>lpmcx-&gt;dwFirstHelp + lpcdSrc-&gt;iCounterTitleOffset; <br>if (lpDest-&gt;CounterHelpTitleIndex &gt; lpmcx-&gt;dwLastHelp) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>lpDest-&gt;CounterNameTitle = NULL; <br>lpDest-&gt;DefaultScale = lpcdSrc-&gt;dwDefaultScale; <br>lpDest-&gt;DetailLevel = lpcdSrc-&gt;dwDetailLevel; <br>hr = HrComputeCounterType( <br>lpcdSrc-&gt;ctStatistic,  <br>lpcdSrc-&gt;perPeriod,  <br>lpcdSrc-&gt;dwUserCounterType,  <br>&amp;lpDest-&gt;CounterType); <br>        if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>        if ((lpcdSrc-&gt;dwUserCounterType &amp; 0x00000300) == PERF_SIZE_LARGE) <br>        { <br>    lpDest-&gt;CounterSize = 2 * sizeof(COUNTER); <br>    lpDest-&gt;CounterOffset = iCounterAllocated * sizeof(COUNTER); <br>            iCounterAllocated += 2; <br>        } <br>        else <br>        { <br>    lpDest-&gt;CounterSize = sizeof(COUNTER); <br>    lpDest-&gt;CounterOffset = iCounterAllocated * sizeof(COUNTER); <br>            iCounterAllocated++; <br>        } <br>} <br> <br>// Fill in _PERF_INSTANCE_DEFINITION structure. <br> <br>lpInstanceDefinition-&gt;ByteLength =  <br>(LPBYTE)lpCounterBlock - (LPBYTE)lpInstanceDefinition; <br>lpInstanceDefinition-&gt;ParentObjectTitleIndex = 0; <br>lpInstanceDefinition-&gt;ParentObjectInstance = 0; <br>lpInstanceDefinition-&gt;UniqueID = PERF_NO_UNIQUE_ID; <br>lpInstanceDefinition-&gt;NameOffset = sizeof(*lpInstanceDefinition); <br> <br>// Fill in instance name.  NOTE: Instance name is always UNICODE!!! <br> <br>lpInstanceDefinition-&gt;NameLength = (cwInstanceNameSize + 1) * sizeof(WCHAR); <br> <br>if (lstrlen(lpmcx-&gt;lpszObjectName) == 0) <br>{ <br>cwInstanceNameSize = 0; <br>} <br>else <br>{ <br>if ( <br>MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpmcx-&gt;lpszObjectName,  <br>-1, lpwszInstanceName, cwInstanceNameSize + 1) == 0) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br>lpwszInstanceName[cwInstanceNameSize] = 0; <br> <br>// Fill in _PERF_COUNTER_BLOCK structure. <br> <br>lpCounterBlock-&gt;ByteLength = lpbStructureEnd - (LPBYTE)lpCounterBlock; <br> <br>// Fill in the shared memory header block (this is some information in the  <br>// shared memory, before the _PERF blocks, which helps the DLL get easy  <br>// access to the two halves of the _PERF structure group that it needs). <br> <br>lpmcx-&gt;lpmsmSharedMemory-&gt;ibHeaderOffset =  <br>(LPBYTE)lpObjectType - (LPBYTE)lpmcx-&gt;lpmsmSharedMemory; <br>lpmcx-&gt;lpmsmSharedMemory-&gt;cbHeaderSize =  <br>(LPBYTE)lpInstanceDefinition - (LPBYTE)lpObjectType; <br>lpmcx-&gt;lpmsmSharedMemory-&gt;ibInstanceOffset =  <br>(LPBYTE)lpInstanceDefinition - (LPBYTE)lpmcx-&gt;lpmsmSharedMemory; <br>lpmcx-&gt;lpmsmSharedMemory-&gt;cbInstanceSize =  <br>lpbStructureEnd - (LPBYTE)lpInstanceDefinition; <br> <br>// Save a pointer to the counters in the context (for use by <br>// HrMonBuildStructures). <br> <br>lpmcx-&gt;lpcntCounter = lpcntCounter; <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrBuildStructures---------------------------------------------------------- <br>//  Helper function that sets up structures representing folders and counters <br>//  in the performance monitoring context. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrBuildStructures(    // RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx,// pointer to perf mon context <br>IN DWORD ccdCounters,// number of COUNTERDEF structures <br>IN LPCOUNTERDEF lpcdCounters)// array of COUNTERDEF structures <br>{ <br>HRESULThr= NOERROR; <br>HRESULThrT= NOERROR; <br> <br>// Variables used to create MONFOLDER and MONCOUNTER structures. <br> <br>LPMONCOUNTERlpmcCounter= NULL; <br>LPMONFOLDERlpmfFolder= NULL; <br> <br>// Variables used to access COUNTERDEF structures. <br> <br>DWORDiCounter= 0; <br>LPCOUNTERDEFlpcdCounter= NULL; <br> <br>// Variables used to create jumping sliding windows (JSW's). <br> <br>__int64dwlJSWStartTime= 0; <br> <br>DEBUGPRIVATE("HrBuildStructures()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrBuildStructures(lpmcx, ccdCounters, lpcdCounters); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>ASSERTERROR(lpmcx-&gt;lpmcMessagesTransferredIn == NULL,  <br>"lpmcx-&gt;lpmcMessagesTransferredIn != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmcMessagesTransferredOut == NULL,  <br>"lpmcx-&gt;lpmcMessagesTransferredOut != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmcBytesTransferredIn == NULL,  <br>"lpmcx-&gt;lpmcBytesTransferredIn != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmcBytesTransferredOut == NULL,  <br>"lpmcx-&gt;lpmcBytesTransferredOut != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmcNDRsIn == NULL,  <br>"lpmcx-&gt;lpmcNDRsIn != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmcNDRsOut == NULL,  <br>"lpmcx-&gt;lpmcNDRsOut != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmcAssociations == NULL,  <br>"lpmcx-&gt;lpmcAssociations != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmcFreeList == NULL,  <br>"lpmcx-&gt;lpmcFreeList != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmcJSWCounterList == NULL,  <br>"lpmcx-&gt;lpmcJSWCounterList != NULL"); <br>ASSERTERROR(lpmcx-&gt;lpmfFolderList == NULL,  <br>"lpmcx-&gt;lpmfFolderList != NULL"); <br> <br>// Compute time to use as base for JSW's, which should be on an even  <br>// minute boundry. <br> <br>dwlJSWStartTime = (lpmcx-&gt;dwlCurrentTime / ONE_MINUTE) * ONE_MINUTE; <br> <br>// Process each COUNTERDEF structure.  If it is for a user defined counter  <br>// then return a pointer to it to the caller of HrMonInit().  If it is  <br>// for any other type of counter, then add entries to the MONCOUNTER lists  <br>// and the MONFOLDER list as appropriate and create a JSWindow structure  <br>// if needed. <br> <br>for (iCounter = 0; iCounter &lt; ccdCounters; ++iCounter) <br>{ <br>lpcdCounter = &amp;lpcdCounters[iCounter]; <br> <br>// If this is a user defined counter then return a pointer to  <br>// the actual counter in the place requested in the call to  <br>// HrMonInit(). <br> <br>if (lpcdCounter-&gt;ctStatistic == COUNTERTYPE_USER_DEFINED) <br>{ <br>ASSERTERROR(lpcdCounter-&gt;lppcntUserCounter != NULL,  <br>"lpcdCounter-&gt;lppcntUserCounter == NULL"); <br>ASSERTERROR(lpcdCounter-&gt;perPeriod == PERIODTYPE_NONE,  <br>"lpcdCounter-&gt;perPeriod != PERIODTYPE_NONE"); <br> <br>*(lpcdCounter-&gt;lppcntUserCounter) =  <br>&amp;(lpmcx-&gt;lpcntCounter[iCounter]); <br> <br>// Skip to the next COUNTERDEF. <br> <br>continue; <br>} <br> <br>// If we reach here then it's not a user defined counter. <br> <br>ASSERTERROR(lpcdCounter-&gt;ctStatistic &lt; COUNTERTYPE_LAST,  <br>"lpcdCounter-&gt;ctStatistic: illegal value"); <br>ASSERTERROR(lpcdCounter-&gt;perPeriod &lt; PERIODTYPE_LAST,  <br>"lpcdCounter-&gt;perPeriod: illegal value"); <br>ASSERT_DETAIL_LEVEL(lpcdCounter-&gt;dwDetailLevel,  <br>"lpcd-&gt;dwDetailLevel: illegal value"); <br> <br>// Allocate and fill in a new MONCOUNTER structure.  Put new  <br>// MONCOUNTER structure on the free list so MonFreeEverything()  <br>// will be able to find it and free it in case we have to abort. <br>// The free list is really just a temporary holding area that  <br>// will never have more than one entry at a time. <br> <br>lpmcCounter = malloc(sizeof(*lpmcCounter)); <br>if (lpmcCounter == NULL) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br>ZeroMemory(lpmcCounter, sizeof(*lpmcCounter)); <br> <br>lpmcCounter-&gt;lpmcNext = lpmcx-&gt;lpmcFreeList; <br>lpmcx-&gt;lpmcFreeList = lpmcCounter; <br> <br>        // If the period type is anything other than PERIODTYPE_CONTINUOUS  <br>        // then we need to zero out the counter when HrMonUninit is called. <br>        // This makes sure all the counters go to zero for any PerfMon still  <br>        // watching.  We shouldn't zero the "continuous" ones, because their  <br>        // displayed value is based on their increase, and zeroing them may  <br>        // result in a huge value being briefly displayed.  Of course, we  <br>        // will see that huge value anyway if PerfMon is still watching when  <br>        // the gateway restarts, but that seems like a better place to take  <br>        // the hit. <br> <br>        if (lpcdCounter-&gt;perPeriod != PERIODTYPE_CONTINUOUS) <br>            lpmcCounter-&gt;fZeroOnFree = TRUE; <br> <br>// If there is a folder associated with this COUNTERDEF, then we need  <br>// to find a MONFOLDER structure that matches it or create a new one if  <br>// one does not already exist.  If there is no folder associated with  <br>// this counter then we can skip this part. <br> <br>lpmfFolder = NULL; <br> <br>if (lpcdCounter-&gt;lpFolder != NULL) <br>{ <br>// See if a MONFOLDER structure has already been defined for this  <br>// folder. <br> <br>hrT = HrMonFindFolder(lpmcx-&gt;lpmfFolderList, lpcdCounter-&gt;lpFolder,  <br>&amp;lpmfFolder); <br>if (FAILED(hrT)) <br>{ <br>            ULONGcValues= 0; <br>            LPSPropValuelpProps= NULL; <br>            SizedSPropTagArray(1, rgPropTags) =  <br>                {1, {PR_MESSAGE_SIZE}}; <br> <br>// A MONFOLDER structure has not already been defined for  <br>// this folder, so allocate one, fill it in and add it to  <br>// the folder list. <br> <br>lpmfFolder = malloc(sizeof(*lpmfFolder)); <br>if (lpmfFolder == NULL) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br>ZeroMemory(lpmfFolder, sizeof(*lpmfFolder)); <br> <br>lpmfFolder-&gt;lpmcx = lpmcx; <br>lpmfFolder-&gt;lpFolder = lpcdCounter-&gt;lpFolder; <br> <br>                // We need to do AddRef/Release because we are keeping  <br>                // folder pointers around between HrMonInit and HrMonUninit. <br> <br>                MAPICALL(lpmfFolder-&gt;lpFolder)-&gt;AddRef(lpmfFolder-&gt;lpFolder); <br> <br>lpmfFolder-&gt;lpmfNext = lpmcx-&gt;lpmfFolderList; <br>lpmcx-&gt;lpmfFolderList = lpmfFolder; <br> <br>                // Get the number of bytes in the folder (PR_MESSAGE_SIZE)  <br>                // and store it in lpmfFolder-&gt;cTotalBytesEnteringFolder. <br>                // This will allow proper handling of the "bytes leaving  <br>                // folder" counter in the case where messages are waiting  <br>                // in the folder when monitoring starts. <br> <br>hr = lpmfFolder-&gt;lpFolder-&gt;lpVtbl-&gt;GetProps( <br>lpmfFolder-&gt;lpFolder,  <br>(LPSPropTagArray) &amp;rgPropTags,  <br>fMapiUnicode,  <br>&amp;cValues,  <br>&amp;lpProps); <br>                if (FAILED(hr) || hr == MAPI_W_ERRORS_RETURNED) <br>                { <br>                    if (hr == MAPI_W_ERRORS_RETURNED) <br>                    { <br>                        MAPIFREEBUFFER(lpProps); <br>                        hr = HR_LOG(E_FAIL); <br>                    } <br>                    goto cleanup; <br>                } <br> <br>lpmfFolder-&gt;cTotalBytesEnteringFolder = lpProps[0].Value.ul; <br> <br>MAPIFREEBUFFER(lpProps); <br>                 <br>                // Create a critical section for this folder. <br> <br>InitializeCriticalSection(&amp;lpmfFolder-&gt;csCriticalSection); <br>lpmfFolder-&gt;fCriticalSectionInitialized = TRUE; <br> <br>// Set the folder to get it's initial size. <br> <br>lpmfFolder-&gt;fUpdateFolderSize = TRUE; <br>} <br>} <br> <br>// Take the MONCOUNTER structure off the free list in preparation  <br>// for linking it into another list. <br> <br>ASSERTERROR(lpmcx-&gt;lpmcFreeList != NULL, "free list empty"); <br> <br>lpmcCounter = lpmcx-&gt;lpmcFreeList; <br>lpmcx-&gt;lpmcFreeList = lpmcx-&gt;lpmcFreeList-&gt;lpmcNext; <br> <br>// Link the MONCOUNTER structure into the proper list.  This could  <br>// be a general list attached to the context structure, or a folder- <br>// specific list attached to a MONFOLDER structure. <br> <br>hr = HrLinkCounterIntoList( <br>lpmcx,  <br>lpmfFolder,  <br>lpmcCounter,  <br>lpcdCounter-&gt;ctStatistic); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>// Create the JSW attached to the counter structure if one is requested  <br>// by the PERIODTYPE. <br> <br>if (lpcdCounter-&gt;perPeriod == PERIODTYPE_LAST_N_MINUTES) <br>{ <br>__int64 dwlJumpTime = ONE_MINUTE; <br> <br>hr = HrJSOpen( <br>JSWINDOW_TOTAL_RATE,  <br>&amp;TO_FILETIME(dwlJSWStartTime),  <br>&amp;TO_FILETIME(dwlJumpTime),  <br>lpcdCounter-&gt;cMinutes,  <br>&amp;lpmcCounter-&gt;hjswJumpWindow); <br> <br>if (FAILED(hr)) <br>{ <br>lpmcCounter-&gt;hjswJumpWindow = NULL;// Just to make sure. <br>goto cleanup; <br>} <br> <br>// Also add the counter structure to the list of counter structures  <br>// that have JSWs. <br> <br>lpmcCounter-&gt;lpmcNextJSW = lpmcx-&gt;lpmcJSWCounterList; <br>lpmcx-&gt;lpmcJSWCounterList = lpmcCounter; <br>} <br> <br>// Add a pointer to the counter to the MONCOUNTER structure. <br> <br>if (lpmcCounter) <br>{ <br>lpmcCounter-&gt;lpcntCounter = &amp;(lpmcx-&gt;lpcntCounter[iCounter]); <br>} <br> <br>} // end for <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrMonFindFolder------------------------------------------------------------ <br>//  Helper function that takes a MAPIFOLDER as input and searches a list of  <br>//  folders to find a MONFOLDER structure for that folder.  If the folder is  <br>//  found a pointer to it is placed in the memory pointed to by lppmfFolder and  <br>//  NOERROR is returned.  Otherwise, and error is returned. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrMonFindFolder(// RETURNS: HRESULT <br>IN  LPMONFOLDER   lpmfFolderList,// list of folder structs to search <br>IN  LPMAPIFOLDER  lpFolder,// folder to search for <br>OUT LPMONFOLDER * lppmfFolder)// folder found <br>{ <br>HRESULThr= NOERROR; <br> <br>DEBUGPRIVATE("HrMonFindFolder()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrMonFindFolder(lpmfFolderList, lpFolder, lppmfFolder); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>while (lpmfFolderList &amp;&amp; lpmfFolderList-&gt;lpFolder != lpFolder) <br>{ <br>lpmfFolderList = lpmfFolderList-&gt;lpmfNext; <br> <br>ASSERT_READ_PTR_OR_NULL(lpmfFolderList, sizeof(*lpmfFolderList),  <br>"lpmfFolderList: bad read pointer"); <br>} <br> <br>if (lpmfFolderList == NULL) <br>{ <br>hr = HR_LOG(EDK_E_NOT_FOUND); <br>} <br>else <br>{ <br>*lppmfFolder = lpmfFolderList; <br>} <br> <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrStartUpdateThread-------------------------------------------------------- <br>//  Helper function that starts the thread that wakes up periodically to update  <br>//  the jumping sliding windows and folders. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrStartUpdateThread(     // RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx)              // pointer to perf mon context <br>{ <br>HRESULThr= NOERROR; <br>SECURITY_ATTRIBUTESsaEvent= {0, NULL, TRUE}; <br> <br>DEBUGPRIVATE("HrStartUpdateThread()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrStartUpdateThread(lpmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>ASSERTERROR(!lpmcx-&gt;fUpdateThreadRunning, "thread already running"); <br>ASSERTERROR(lpmcx-&gt;hUpdateThread == NULL, "lpmcx-&gt;hUpdateThread != NULL"); <br>ASSERTERROR(lpmcx-&gt;hUpdateThreadWakeEvent == NULL,  <br>"lpmcx-&gt;hUpdateThreadWakeEvent != NULL"); <br>ASSERTERROR(lpmcx-&gt;dwUpdateThreadID == 0, "lpmcx-&gt;dwUpdateThreadID != 0"); <br>ASSERTERROR(lpmcx-&gt;fUpdateThreadTerminate == FALSE,  <br>"lpmcx-&gt;fUpdateThreadTerminate != FALSE"); <br> <br>// Create an unnamed, inheritable, auto-reset event.  This will be  <br>// set by the gateway process to wake the thread, either to update  <br>// or to terminate.  Start it signaled so the update thread wakes  <br>// up to set the initial values of the folder counters. <br> <br>lpmcx-&gt;hUpdateThreadWakeEvent = CreateEvent(&amp;saEvent, FALSE, TRUE, NULL); <br>if (lpmcx-&gt;hUpdateThreadWakeEvent == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Create the thread. <br> <br>lpmcx-&gt;hUpdateThread = CreateThread(NULL, 0, UpdateThread, lpmcx, 0,  <br>&amp;lpmcx-&gt;dwUpdateThreadID); <br>if (lpmcx-&gt;hUpdateThread == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>cleanup: <br>if (FAILED(hr)) <br>{ <br>CLOSEHANDLE(lpmcx-&gt;hUpdateThreadWakeEvent); <br>} <br>RETURN (hr); <br>} <br> <br> <br> <br>//$--UpdateThread--------------------------------------------------------------- <br>//  Function that is called as a seperate thread.  It wakes up periodically and  <br>//  updates the jumping sliding windows and folders. <br>// ----------------------------------------------------------------------------- <br>static DWORD WINAPI UpdateThread(    // RETURNS: error code <br>IN LPVOID lpThreadParameter)// pointer to perf mon context <br>{ <br>static BOOLfGetPropsErrorLoggedOnce= FALSE; <br>static BOOLfJSWFailureLoggedOnce= FALSE; <br> <br>LPMONCONTEXTlpmcx= lpThreadParameter; <br> <br>HRESULThr= NOERROR; <br>DWORDdwStatus= ERROR_SUCCESS; <br> <br>LPMONCOUNTERlpmc= NULL; <br>LPMONFOLDERlpmf= NULL; <br> <br>DWORDdwMillisecondsToWait= 0; <br>DWORDdwWindowValue= 0; <br>DWORDdwFractionCompleteNum= 0; <br>DWORDdwFractionCompleteDen= 0; <br> <br>DWORDcMessagesInFolder= 0; <br>DWORDcBytesInFolder= 0; <br>DWORDcMessagesEnteringFolder= 0; <br>DWORDcBytesEnteringFolder= 0; <br>DWORDcMessagesLeavingFolder= 0;  <br>DWORDcBytesLeavingFolder= 0; <br> <br>ULONGcValues= 0; <br>LPSPropValuelpProps= NULL; <br>SizedSPropTagArray(2, rgPropTags) =  <br>    {2, {PR_CONTENT_COUNT, PR_MESSAGE_SIZE}}; <br> <br>    BOOL            fCountersLocked             = FALSE; <br> <br> <br>DEBUGPRIVATE("UpdateThread()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_UpdateThread(lpThreadParameter); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Loop until flag is set to stop the thread. <br> </code></pre>
<p>
</p>
<pre><code>while (!lpmcx-&gt;fUpdateThreadTerminate) <br>{ <br>// If we have JSW's, then calculate how many milliseconds to wait  <br>// until the next even minute mark.  Wait an extra second just to  <br>// be sure we don't wake up too early. <br> <br>if (lpmcx-&gt;lpmcJSWCounterList) <br>{ <br>__int64 dwlCurrentTime = 0; <br> <br>    hr = HrGetCurrentTime(&amp;dwlCurrentTime); <br>            if (FAILED(hr)) <br>                goto cleanup; <br> <br>dwMillisecondsToWait = (DWORD) <br>(((ONE_MINUTE - (dwlCurrentTime % ONE_MINUTE))  <br>+ 10000000) / 10000); <br>} <br> <br>// Otherwise, wait until the other thread wakes us up. <br> <br>else <br>{ <br>dwMillisecondsToWait = INFINITE; <br>} <br> <br>// Wait for specified time or wake event. <br> <br>dwStatus = WaitForSingleObject( <br>lpmcx-&gt;hUpdateThreadWakeEvent,  <br>dwMillisecondsToWait); <br>        if (dwStatus != WAIT_TIMEOUT &amp;&amp; dwStatus != WAIT_OBJECT_0) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Check for terminate request. <br> <br>if (lpmcx-&gt;fUpdateThreadTerminate) <br>goto cleanup; <br> <br>// Update the folder counters from the "update request" variables. <br> <br>if (lpmcx-&gt;lpmfFolderList) <br>{ <br>for ( <br>lpmf = lpmcx-&gt;lpmfFolderList;  <br>lpmf;  <br>lpmf = lpmf-&gt;lpmfNext) <br>{ <br>cMessagesEnteringFolder = 0; <br>cBytesEnteringFolder = 0; <br>cMessagesLeavingFolder = 0; <br>cBytesLeavingFolder = 0; <br>cMessagesInFolder = 0; <br>cBytesInFolder = 0; <br> <br>if (lpmf-&gt;fUpdateFolderSize) <br>{ <br>// Check for terminate request. <br> <br>if (lpmcx-&gt;fUpdateThreadTerminate) <br>goto cleanup; <br> <br>// Get and reset the "update request" variables. <br> <br>EnterCriticalSection(&amp;lpmf-&gt;csCriticalSection); <br> <br>cMessagesEnteringFolder = lpmf-&gt;cMessagesEnteringFolder; <br>lpmf-&gt;cMessagesEnteringFolder = 0; <br>cBytesEnteringFolder = lpmf-&gt;cBytesEnteringFolder; <br>lpmf-&gt;cBytesEnteringFolder = 0; <br>cMessagesLeavingFolder = lpmf-&gt;cMessagesLeavingFolder; <br>lpmf-&gt;cMessagesLeavingFolder = 0; <br>cBytesLeavingFolder = lpmf-&gt;cBytesLeavingFolder; <br>lpmf-&gt;cBytesLeavingFolder = 0; <br>lpmf-&gt;fUpdateFolderSize = FALSE; <br> <br>LeaveCriticalSection(&amp;lpmf-&gt;csCriticalSection); <br> <br>// Check for terminate request. <br> <br>if (lpmcx-&gt;fUpdateThreadTerminate) <br>goto cleanup; <br> <br>// Get number of messages and bytes in folder. <br> <br>if (lpmf-&gt;lpmcMessagesInFolder ||  <br>    lpmf-&gt;lpmcBytesInFolder ||  <br>    lpmf-&gt;lpmcBytesLeavingFolder) <br>{ <br>// Get the PR_CONTENT_COUNT and PR_MESSAGE_SIZE props. <br> <br>hr = lpmf-&gt;lpFolder-&gt;lpVtbl-&gt;GetProps( <br>lpmf-&gt;lpFolder,  <br>(LPSPropTagArray) &amp;rgPropTags,  <br>fMapiUnicode,  <br>&amp;cValues,  <br>&amp;lpProps); <br>                        if (FAILED(hr) || hr == MAPI_W_ERRORS_RETURNED) <br>                        { <br>                            if (hr == MAPI_W_ERRORS_RETURNED) <br>                            { <br>                                MAPIFREEBUFFER(lpProps); <br>                            } <br>                            goto cleanup; <br>                        } <br> <br>cMessagesInFolder = lpProps[0].Value.ul; <br>cBytesInFolder = lpProps[1].Value.ul; <br> <br>MAPIFREEBUFFER(lpProps); <br>} <br> <br>// Check for terminate request. <br> <br>if (lpmcx-&gt;fUpdateThreadTerminate) <br>goto cleanup; <br> <br>// If they want the number of bytes leaving the folder  <br>// then calculate it and keep track of it here. <br> <br>if (lpmf-&gt;lpmcBytesLeavingFolder) <br>{ <br>// Compute the total number of bytes entering folder  <br>// so far. <br> <br>lpmf-&gt;cTotalBytesEnteringFolder += cBytesEnteringFolder; <br> <br>// Figure out how many bytes should be in the folder  <br>// according to the running totals of bytes entering  <br>// and bytes leaving that we have reported.  If the  <br>// "should be" is higher than the actual, then report   <br>// the difference as the number of bytes leaving the  <br>// folder, and update the reported number leaving. <br> <br>if (lpmf-&gt;cTotalBytesEnteringFolder -  <br>lpmf-&gt;cTotalBytesLeavingFolder &gt;  <br>cBytesInFolder) <br>{ <br>cBytesLeavingFolder =  <br>lpmf-&gt;cTotalBytesEnteringFolder -  <br>lpmf-&gt;cTotalBytesLeavingFolder -  <br>cBytesInFolder; <br>lpmf-&gt;cTotalBytesLeavingFolder +=  <br>cBytesLeavingFolder; <br>} <br>} <br> <br>// Lock the counters. <br> <br>hr = HrMonLockCounters(); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br>                    fCountersLocked = TRUE; <br> <br>                    // Get the system time. <br> <br>hr = HrGetCurrentTime(&amp;lpmcx-&gt;dwlCurrentTime); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br> <br>                    // Update the counters. <br> <br>hr = HrAddToCounters( <br>lpmcx,  <br>lpmf-&gt;lpmcMessagesEnteringFolder,  <br>cMessagesEnteringFolder); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br> <br>hr = HrAddToCounters( <br>lpmcx,  <br>lpmf-&gt;lpmcBytesEnteringFolder,  <br>cBytesEnteringFolder); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br> <br>hr = HrAddToCounters( <br>lpmcx,  <br>lpmf-&gt;lpmcMessagesLeavingFolder,  <br>cMessagesLeavingFolder); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br> <br>hr = HrAddToCounters( <br>lpmcx,  <br>lpmf-&gt;lpmcBytesLeavingFolder,  <br>cBytesLeavingFolder); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br> <br>hr = HrSetCounters( <br>lpmf-&gt;lpmcMessagesInFolder,  <br>cMessagesInFolder); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br> <br>hr = HrSetCounters( <br>lpmf-&gt;lpmcBytesInFolder,  <br>cBytesInFolder); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br> <br>                    // Unlock the counters. <br> <br>                    fCountersLocked = FALSE; <br>hr = HrMonUnlockCounters(); <br>                    if (FAILED(hr)) <br>                        goto cleanup; <br>} <br>} <br>} <br> <br>// Update the JSW counters. <br> <br>if (lpmcx-&gt;lpmcJSWCounterList) <br>{ <br>for ( <br>lpmc = lpmcx-&gt;lpmcJSWCounterList;  <br>lpmc;  <br>lpmc = lpmc-&gt;lpmcNextJSW) <br>{ <br>ASSERT_READ_PTR(lpmc, sizeof(*lpmc),  <br>"lpmc: bad write pointer"); <br>ASSERT_WRITE_PTR(lpmc-&gt;lpcntCounter,  <br>sizeof(*lpmc-&gt;lpcntCounter),  <br>"lpmc-&gt;lpcntCounter: bad write pointer"); <br>ASSERTERROR(lpmc-&gt;hjswJumpWindow != NULL,  <br>"lpmc-&gt;hjswJumpWindow == NULL"); <br> <br>// Check for terminate request. <br> <br>if (lpmcx-&gt;fUpdateThreadTerminate) <br>goto cleanup; <br> <br>// Lock the counters. <br> <br>hr = HrMonLockCounters(); <br>                if (FAILED(hr)) <br>                    goto cleanup; <br>                fCountersLocked = TRUE; <br> <br>// Get the value of the JSWindow (update system time). <br> <br>hr = HrGetCurrentTime(&amp;lpmcx-&gt;dwlCurrentTime); <br>                if (FAILED(hr)) <br>                    goto cleanup; <br> <br>hr = HrJSGetValue( <br>lpmc-&gt;hjswJumpWindow,  <br>&amp;TO_FILETIME(lpmcx-&gt;dwlCurrentTime),  <br>&amp;dwWindowValue,  <br>&amp;dwFractionCompleteNum,  <br>&amp;dwFractionCompleteDen); <br>if (FAILED(hr)) <br>                    goto cleanup; <br> <br>*lpmc-&gt;lpcntCounter = dwWindowValue; <br> <br>                // Unlock the counters. <br> <br>                fCountersLocked = FALSE; <br>hr = HrMonUnlockCounters(); <br>                if (FAILED(hr)) <br>                    goto cleanup; <br>} // end for <br> <br>} // end if <br> <br>} // end while (!lpmcx-&gt;fUpdateThreadTerminate) <br> <br>cleanup: <br>    // Unlock the counters if they're locked. <br> <br>    if (fCountersLocked) <br>    { <br>    hr = HrMonUnlockCounters(); <br>        if (FAILED(hr)) <br>            HR_LOG(hr); <br>    } <br> <br>    // Always return success. <br> <br>return(ERROR_SUCCESS); <br>} <br> <br> <br> <br>//$--HrFreeEverything----------------------------------------------------------- <br>//  Helper function that shuts down the thread, monitoring, and frees memory. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrFreeEverything(// RETURNS: HRESULT <br>IN LPMONCONTEXT *lppmcx)// the address of the pointer to the  <br>// performance monitoring context (the  <br>// pointer will be set to NULL) <br>{ <br>BOOLfItWorked= FALSE; <br>HRESULThr= NOERROR; <br>HRESULThrT= NOERROR; <br>LPMONCONTEXTlpmcx= NULL; <br>LPMONFOLDERlpmf= NULL; <br>LPMONCOUNTERlpmc= NULL; <br> <br>DEBUGPRIVATE("HrFreeEverything()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrFreeEverything(lppmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// This pointer is easier to use. <br> <br>lpmcx = *lppmcx; <br> <br>// Free the context only if there is one allocated. <br> <br>if (lpmcx) <br>{ <br>// Tell the update thread to shut down and wait for it to do so. <br> <br>if (lpmcx-&gt;hUpdateThread) <br>{ <br>lpmcx-&gt;fUpdateThreadTerminate = TRUE; <br> <br>hrT = HrWakeUpdateThread(lpmcx); <br>            if (FAILED(hrT)) <br>                hr = hrT; <br>else <br>{ <br>DWORD dw = WaitForSingleObject(lpmcx-&gt;hUpdateThread, INFINITE); <br>if (dw != WAIT_OBJECT_0) <br>{ <br>                    hr = HR_LOG(E_FAIL); <br>} <br>} <br>CLOSEHANDLE(lpmcx-&gt;hUpdateThread); <br>lpmcx-&gt;dwUpdateThreadID = 0; <br>} <br> <br>// Close the handle to the thread termination event. <br> <br>CLOSEHANDLE(lpmcx-&gt;hUpdateThreadWakeEvent); <br> <br>// Unhook monitoring routines and delete critical sections for folders. <br> <br>for ( <br>lpmf = lpmcx-&gt;lpmfFolderList;  <br>lpmf;  <br>lpmf = lpmf-&gt;lpmfNext) <br>{ <br>if (lpmf-&gt;fCriticalSectionInitialized) <br>{ <br>DeleteCriticalSection(&amp;lpmf-&gt;csCriticalSection); <br>lpmf-&gt;fCriticalSectionInitialized = FALSE; <br>} <br> <br>if (lpmf-&gt;lpTable) <br>{ <br>hrT = MAPICALL(lpmf-&gt;lpTable)-&gt; <br>Unadvise(lpmf-&gt;lpTable, lpmf-&gt;ulConnection); <br>                if (FAILED(hrT)) <br>                    hr = hrT; <br>lpmf-&gt;lpTable = NULL; <br> <br>ULRELEASE(lpmf-&gt;lpTable); <br>lpmf-&gt;lpTable = NULL; <br>} <br>ULRELEASE(lpmf-&gt;lpAdvise); <br>lpmf-&gt;lpAdvise = NULL; <br>lpmf-&gt;ulConnection = 0; <br>} <br> <br>// Free strings attached to the context. <br> <br>ASSERT_STRING_PTR_OR_NULL(lpmcx-&gt;lpszObjectName,  <br>"lpmcx-&gt;lpszObjectName: bad string pointer"); <br>FREE(lpmcx-&gt;lpszObjectName); <br> <br>ASSERT_STRING_PTR_OR_NULL(lpmcx-&gt;lpszObjectClass,  <br>"lpmcx-&gt;lpszObjectClass: bad string pointer"); <br>FREE(lpmcx-&gt;lpszObjectClass); <br> <br>// Close all the JSW's. <br> <br>for (lpmc = lpmcx-&gt;lpmcJSWCounterList; lpmc; lpmc = lpmc-&gt;lpmcNextJSW) <br>{ <br>ASSERTERROR(lpmc-&gt;hjswJumpWindow != NULL,  <br>"lpmc-&gt;hjswJumpWindow == NULL"); <br> <br>JSClose(lpmc-&gt;hjswJumpWindow); <br>lpmc-&gt;hjswJumpWindow = NULL; <br>} <br>lpmcx-&gt;lpmcJSWCounterList = NULL; <br> <br>// Free all the MONCOUNTER structures attached directly to the context. <br> <br>hrT = HrFreeCounterList(&amp;lpmcx-&gt;lpmcMessagesTransferredIn); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmcx-&gt;lpmcMessagesTransferredOut); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmcx-&gt;lpmcBytesTransferredIn); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmcx-&gt;lpmcBytesTransferredOut); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmcx-&gt;lpmcNDRsIn); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmcx-&gt;lpmcNDRsOut); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmcx-&gt;lpmcAssociations); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmcx-&gt;lpmcFreeList); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>// Free all the MONFOLDER structures, including the MONCOUNTER  <br>// structures attached to the folders. <br> <br>hrT = HrFreeFolderList(&amp;lpmcx-&gt;lpmfFolderList); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>// If we mapped the shared memory, unmap the view of the file. <br>        // NOTE: LEAVE THE fDateIsValid FLAG UNCHANGED SO ANYBODY STILL  <br>        // WATCHING US WILL SEE VALID DATA!!! <br> <br>if (lpmcx-&gt;lpmsmSharedMemory) <br>{ <br>fItWorked = UnmapViewOfFile(lpmcx-&gt;lpmsmSharedMemory); <br>if (!fItWorked) <br>{ <br>                hr = HR_LOG(E_FAIL); <br>} <br>lpmcx-&gt;lpmsmSharedMemory = NULL; <br>} <br> <br>// Close file mapping object if it is open. <br> <br>CLOSEHANDLE(lpmcx-&gt;hSharedMemoryMapping); <br> <br>// Clear other shared memory variables. <br> <br>lpmcx-&gt;cbSharedMemorySize = 0; <br> <br>// Close mutex handle if it is open. <br> <br>CLOSEHANDLE(lpmcx-&gt;hSharedMemoryMutex); <br> <br>// Free the context itself. <br> <br>FREE(*lppmcx); <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrFreeCounterList---------------------------------------------------------- <br>//  Helper function that frees a list of MONCOUNTER structures. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrFreeCounterList(// RETURNS: HRESULT <br>IN LPMONCOUNTER *lppmcCounterList)// address of pointer to first element <br>// of counter list to be freed <br>{ <br>HRESULThr= NOERROR; <br>LPMONCOUNTER lpmc= NULL; <br>LPMONCOUNTERlpmcNext= NULL; <br> <br>DEBUGPRIVATE("HrFreeCounterList()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrFreeCounterList(lppmcCounterList); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>lpmc = *lppmcCounterList; <br>while (lpmc) <br>{ <br>ASSERT_WRITE_PTR(lpmc, sizeof(*lpmc), "lpmc: bad write pointer"); <br>ASSERTWARNING(lpmc-&gt;hjswJumpWindow == NULL,  <br>"lpmc-&gt;hjswJumpWindow != NULL"); <br> <br>        // Zero out the actual counter if requested. <br> <br>        if (lpmc-&gt;fZeroOnFree &amp;&amp; lpmc-&gt;lpcntCounter) <br>            *(lpmc-&gt;lpcntCounter) = 0; <br> <br>        // Now free this node and move to the next one. <br> <br>lpmcNext = lpmc-&gt;lpmcNext; <br>FREE(lpmc); <br>lpmc = lpmcNext; <br>} <br>*lppmcCounterList = NULL; <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrFreeFolderList----------------------------------------------------------- <br>//  Helper function that frees a list of MONFOLDER structures and the  <br>//  MONCOUNTER structures attached to them. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrFreeFolderList(// RETURNS: HRESULT <br>IN LPMONFOLDER *lppmfFolderList)// address of pointer to first element <br>// of folder list to be freed <br>{ <br>HRESULThr= NOERROR; <br>HRESULThrT= NOERROR; <br>LPMONFOLDER lpmf= NULL; <br>LPMONFOLDERlpmfNext= NULL; <br> <br>DEBUGPRIVATE("HrFreeFolderList()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrFreeFolderList(lppmfFolderList); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>lpmf = *lppmfFolderList; <br>while (lpmf) <br>{ <br>        ULONG ulRefCount = 0; <br> <br>ASSERT_WRITE_PTR(lpmf, sizeof(*lpmf), "lpmf: bad write pointer"); <br> <br>        // We need to do AddRef/Release because we are keeping  <br>        // folder pointers around between HrMonInit and HrMonUninit. <br> <br>        ulRefCount = MAPICALL(lpmf-&gt;lpFolder)-&gt;Release(lpmf-&gt;lpFolder); <br>        ASSERTWARNING(ulRefCount &lt;= 2, "ulRefCount &gt; 2"); <br> <br>hrT = HrFreeCounterList(&amp;lpmf-&gt;lpmcMessagesInFolder); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmf-&gt;lpmcBytesInFolder); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmf-&gt;lpmcMessagesEnteringFolder); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmf-&gt;lpmcBytesEnteringFolder); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmf-&gt;lpmcMessagesLeavingFolder); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>hrT = HrFreeCounterList(&amp;lpmf-&gt;lpmcBytesLeavingFolder); <br>        if (FAILED(hrT)) <br>            hr = hrT; <br> <br>lpmfNext = lpmf-&gt;lpmfNext; <br>FREE(lpmf); <br>lpmf = lpmfNext; <br>} <br>*lppmfFolderList = NULL; <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br> <br>//$--HrAddToCounters------------------------------------------------------------ <br>//  Helper function that adds a value to each of the counters on the list. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrAddToCounters(// RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx,// pointer to perf mon context <br>IN LPMONCOUNTER lpmcList,// pointer to list of counters <br>IN LONG dwAmount)// amount to add to each one <br>{ <br>static BOOLfLoggedOnce= FALSE; <br>HRESULThr= NOERROR; <br>LPMONCOUNTERlpmc= NULL; <br> <br>DEBUGPRIVATE("HrAddToCounters()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrAddToCounters(lpmcx, lpmcList, dwAmount); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>for (lpmc = lpmcList; lpmc; lpmc = lpmc-&gt;lpmcNext) <br>{ <br>ASSERT_READ_PTR(lpmc, sizeof(*lpmc), "lpmc: bad read pointer"); <br> <br>if (lpmc-&gt;hjswJumpWindow) <br>{ <br>// Update jump window. <br> <br>hr = HrJSCollectDataPoint( <br>lpmc-&gt;hjswJumpWindow,  <br>&amp;TO_FILETIME(lpmcx-&gt;dwlCurrentTime),  <br>dwAmount); <br>if (FAILED(hr)) <br>                goto cleanup; <br>} <br>else <br>{ <br>// Update counter directly. <br> <br>ASSERT_WRITE_PTR( <br>lpmc-&gt;lpcntCounter,  <br>sizeof(*lpmc-&gt;lpcntCounter),  <br>"lpmc-&gt;lpcntCounter: bad write pointer"); <br> <br>*lpmc-&gt;lpcntCounter += dwAmount; <br>} <br>} <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrSetCounters-------------------------------------------------------------- <br>//  Helper function that assigns a value to each of the counters on the list. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrSetCounters(// RETURNS: HRESULT <br>IN LPMONCOUNTER lpmcList,// pointer to list of counters <br>IN DWORD dwAmount)// amount to set each one to <br>{ <br>HRESULThr= NOERROR; <br>LPMONCOUNTERlpmc= NULL; <br> <br>DEBUGPRIVATE("HrSetCounters()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrSetCounters(lpmcList, dwAmount); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>for (lpmc = lpmcList; lpmc; lpmc = lpmc-&gt;lpmcNext) <br>{ <br>ASSERT_READ_PTR(lpmc, sizeof(*lpmc), "lpmc: bad read pointer"); <br>ASSERTERROR(lpmc-&gt;hjswJumpWindow == NULL,  <br>"lpmc-&gt;hjswJumpWindow != NULL"); <br>ASSERT_WRITE_PTR(lpmc-&gt;lpcntCounter, sizeof(*lpmc-&gt;lpcntCounter),  <br>"lpmc-&gt;lpcntCounter: bad write pointer"); <br> <br>*lpmc-&gt;lpcntCounter = dwAmount; <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrComputeCounterType------------------------------------------------------- <br>//  Helper function that computes the counter type value to use in the  <br>//  _PERF_COUNTER_DEFINITION structure defined in winperf.h. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrComputeCounterType(// RETURNS: HRESULT <br>IN  COUNTERTYPE ctStatistic,// the statistic this counter monitors <br>IN  PERIODTYPE perPeriod,// the period of this counter <br>IN  DWORD dwUserCounterType,// the CounterType (if ctStatistic is  <br>// COUNTERTYPE_USER_DEFINED) <br>OUT DWORD * lpdwCounterType)// returned counter type <br>{ <br>HRESULThr= NOERROR; <br>DWORDdwCounterType= PERF_COUNTER_RAWCOUNT; <br> <br>DEBUGPRIVATE("HrComputeCounterType()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrComputeCounterType( <br>ctStatistic,  <br>perPeriod,  <br>dwUserCounterType,  <br>lpdwCounterType); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>switch (ctStatistic) <br>{ <br>case COUNTERTYPE_MESSAGES_IN_FOLDER: <br>case COUNTERTYPE_BYTES_IN_FOLDER: <br>case COUNTERTYPE_ASSOCIATIONS: <br>ASSERTERROR(perPeriod == PERIODTYPE_NONE,  <br>"perPeriod != PERIODTYPE_NONE"); <br>dwCounterType = PERF_COUNTER_RAWCOUNT; <br>break; <br> <br>case COUNTERTYPE_MESSAGES_ENTERING_FOLDER: <br>case COUNTERTYPE_BYTES_ENTERING_FOLDER: <br>case COUNTERTYPE_MESSAGES_LEAVING_FOLDER: <br>case COUNTERTYPE_BYTES_LEAVING_FOLDER: <br>case COUNTERTYPE_MESSAGES_TRANSFERRED_IN: <br>case COUNTERTYPE_BYTES_TRANSFERRED_IN: <br>case COUNTERTYPE_MESSAGES_TRANSFERRED_OUT: <br>case COUNTERTYPE_BYTES_TRANSFERRED_OUT: <br>case COUNTERTYPE_NDRS_IN: <br>case COUNTERTYPE_NDRS_OUT: <br>ASSERTERROR(perPeriod != PERIODTYPE_NONE,  <br>"perPeriod == PERIODTYPE_NONE"); <br>if (perPeriod == PERIODTYPE_CONTINUOUS) <br>{ <br>dwCounterType = PERF_COUNTER_COUNTER; <br>} <br>else <br>{ <br>dwCounterType = PERF_COUNTER_RAWCOUNT; <br>} <br>break; <br> <br>case COUNTERTYPE_USER_DEFINED: <br>dwCounterType = dwUserCounterType; <br>break; <br> <br>default: <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>*lpdwCounterType = dwCounterType; <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrAlignPointer------------------------------------------------------------- <br>//  Helper function that moves a pointer forward, if nescessary, so that it has  <br>//  a given alignment.  NOTE: the alignment must be a power of 2. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrAlignPointer(    // RETURNS: HRESULT <br>IN     DWORD cbAlignment,// the alignment desired <br>IN OUT LPVOID * lppvPointer)// the pointer to be aligned <br>{ <br>HRESULThr= NOERROR; <br> <br>DEBUGPRIVATE("HrAlignPointer()\n"); <br> <br>// Make sure the alignment is a power of 2. <br> <br>// Check the parameters. <br> <br>hr = CHK_HrAlignPointer(cbAlignment, lppvPointer); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>*lppvPointer = ((LPVOID) <br>(((DWORD)(((LPBYTE)(*lppvPointer)) + cbAlignment - 1)) &amp;  <br>(~(cbAlignment - 1))) <br>); <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--FolderNotification--------------------------------------------------------- <br>//  Function called by the notification engine when a folder is changed.   <br>//It sets the "update request" variables to tell the folder update thread  <br>//to update the counters associated with this folder.  In order to make this  <br>//routine run faster it does not update the counters directly.  Since the  <br>//notification engine only allows one notification routine per process to  <br>//run at any one time, this improves efficiency. <br>// ----------------------------------------------------------------------------- <br>static ULONG STDAPICALLTYPE FolderNotification(   // RETURNS: S_OK (always) <br>IN LPVOID lpvContext,// pointer to MONFOLDER structure <br>IN DWORD cNotification,// number of elements in following array <br>IN LPNOTIFICATION lpNotifications)// array of notification structures <br>{ <br>HRESULThr= NOERROR; <br>LPMONFOLDERlpmf= lpvContext; <br>ULONGcValues= 0; <br>LPSPropValuelpProps= NULL; <br> <br>DWORDcBytesEnteringFolder= 0; <br>DWORDcMessagesEnteringFolder= 0; <br>DWORDcBytesLeavingFolder= 0; <br>DWORDcMessagesLeavingFolder= 0; <br>BOOLfUpdateFolderSize= FALSE; <br> <br>DEBUGPRIVATE("FolderNotification()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_FolderNotification(lpvContext, cNotification, lpNotifications); <br>if (FAILED(hr)) <br>return (S_OK); <br> <br>// If cNotification == 0, just take a snapshot of the folder. <br> <br>if (cNotification == 0) <br>{ <br>fUpdateFolderSize = TRUE; <br>} <br> <br>// Go through the list of notifications, counting up the number of bytes  <br>// and messages that entered or left the folder.  Also figure out if the  <br>// folder size changed so we know if we need to get the new size. <br> <br>for (; cNotification; cNotification--, lpNotifications++) <br>{ <br>// If it's not a table notification then ignore it. <br> <br>if (lpNotifications-&gt;ulEventType == fnevTableModified) <br>{ <br>// Handle different types of table notifications. <br> <br>switch (lpNotifications-&gt;info.tab.ulTableEvent) <br>{ <br>case TABLE_ROW_ADDED: <br>// Update counters for bytes and messages entering folder. <br> <br>if (lpmf-&gt;lpmcBytesEnteringFolder) <br>{ <br>for ( <br>lpProps = lpNotifications-&gt;info.tab.row.lpProps,  <br>cValues = lpNotifications-&gt;info.tab.row.cValues;  <br>cValues;  <br>cValues--, lpProps++) <br>{ <br>if (lpProps-&gt;ulPropTag == PR_MESSAGE_SIZE) <br>{ <br>cBytesEnteringFolder += lpProps-&gt;Value.ul; <br>break; <br>} <br>} <br>ASSERTWARNING(cValues,  <br>"PR_MESSAGE_SIZE not found: 0 assumed"); <br>} <br> <br>cMessagesEnteringFolder++; <br> <br>fUpdateFolderSize = TRUE; <br>break; <br> <br>case TABLE_ROW_DELETED: <br>// Update counter for messages leaving folder.  The  <br>// number of bytes leaving the folder will be calculated  <br>// in the thread, since the notification engine doesn't  <br>//  give us that information. <br> <br>cMessagesLeavingFolder++; <br> <br>fUpdateFolderSize = TRUE; <br>break; <br> <br>case TABLE_SORT_DONE: <br>case TABLE_RESTRICT_DONE: <br>case TABLE_SETCOL_DONE: <br>// Nothing really changed in the folder. <br>break; <br> <br>default: <br>// (fall through) <br>case TABLE_ROW_MODIFIED: <br>case TABLE_CHANGED: <br>case TABLE_ERROR: <br>fUpdateFolderSize = TRUE; <br>break; <br>} // end switch <br>} // end if <br>} // end for <br> <br> <br>// Now set the "update request" variables for any counters that need  <br>// updating. <br> <br>if (fUpdateFolderSize) <br>{ <br>EnterCriticalSection(&amp;lpmf-&gt;csCriticalSection); <br> <br>lpmf-&gt;fUpdateFolderSize = TRUE; <br>if (cBytesEnteringFolder &amp;&amp; lpmf-&gt;lpmcBytesEnteringFolder) <br>lpmf-&gt;cBytesEnteringFolder += cBytesEnteringFolder; <br>if (cMessagesEnteringFolder &amp;&amp; lpmf-&gt;lpmcMessagesEnteringFolder) <br>lpmf-&gt;cMessagesEnteringFolder += cMessagesEnteringFolder; <br>if (cBytesLeavingFolder &amp;&amp; lpmf-&gt;lpmcBytesLeavingFolder) <br>lpmf-&gt;cBytesLeavingFolder += cBytesLeavingFolder; <br>if (cMessagesLeavingFolder &amp;&amp; lpmf-&gt;lpmcMessagesLeavingFolder) <br>lpmf-&gt;cMessagesLeavingFolder += cMessagesLeavingFolder; <br> <br>LeaveCriticalSection(&amp;lpmf-&gt;csCriticalSection); <br> <br>(void) HrWakeUpdateThread(lpmf-&gt;lpmcx); <br>} <br> <br>return (S_OK); <br>} <br> <br> <br> <br>//$--HrWakeUpdateThread--------------------------------------------------------- <br>//  Helper function that signals the update thread to wake up. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrWakeUpdateThread( <br>IN LPMONCONTEXT lpmcx) <br>{ <br>HRESULThr= NOERROR; <br>BOOLfItWorked= TRUE; <br> <br>DEBUGPRIVATE("HrWakeUpdateThread()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrWakeUpdateThread(lpmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>fItWorked = SetEvent(lpmcx-&gt;hUpdateThreadWakeEvent); <br>if (!fItWorked) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrRegisterNotification----------------------------------------------------- <br>//  Helper function that registers notification on folders. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrRegisterNotification(  // RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx)              // pointer to perf mon context <br>{ <br>    HRESULT            hr             = NOERROR; <br>    HRESULT          hrT= SUCCESS_SUCCESS; <br>LPMONFOLDERlpmf= NULL; <br>SPropTagArrayrgPropTagBytesInMessage= {1, {PR_MESSAGE_SIZE}}; <br>    ULONG               ulRowCount              = 0; <br> <br>DEBUGPRIVATE("HrRegisterNotification()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrRegisterNotification(lpmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Start monitoring for each folder in the list. <br> <br>for (lpmf = lpmcx-&gt;lpmfFolderList; lpmf; lpmf = lpmf-&gt;lpmfNext) <br>{ <br>ASSERT_WRITE_PTR(lpmf, sizeof(*lpmf), "lpmf: bad write pointer"); <br>ASSERTERROR(lpmf-&gt;lpmcx == lpmcx, "lpmf-&gt;lpmcx != lpmcx"); <br>ASSERTERROR(lpmf-&gt;lpFolder != NULL, "lpmf-&gt;lpFolder == NULL"); <br>ASSERTERROR(lpmf-&gt;ulConnection == 0,  <br>"lpmf: folder already has notification set"); <br>ASSERTWARNING( <br>lpmf-&gt;lpmcMessagesInFolder ||  <br>lpmf-&gt;lpmcBytesInFolder ||  <br>lpmf-&gt;lpmcMessagesEnteringFolder ||  <br>lpmf-&gt;lpmcBytesEnteringFolder ||  <br>lpmf-&gt;lpmcMessagesLeavingFolder ||  <br>lpmf-&gt;lpmcBytesLeavingFolder,  <br>"lpmf: folder without counters"); <br>ASSERTWARNING(lpmf-&gt;lpTable == NULL, "lpmf-&gt;lpTable != NULL"); <br>ASSERTWARNING(lpmf-&gt;lpAdvise == NULL, "lpmf-&gt;lpAdvise != NULL"); <br> <br>// Set notification on this folder. <br> <br>hrT = MAPICALL(lpmf-&gt;lpFolder)-&gt;GetContentsTable(lpmf-&gt;lpFolder, MAPI_DEFERRED_ERRORS,  <br>&amp;lpmf-&gt;lpTable); <br>    if (FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>hrT = MAPICALL(lpmf-&gt;lpTable)-&gt;SetColumns(lpmf-&gt;lpTable,  <br>&amp;rgPropTagBytesInMessage, 0); <br>    if (FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hrT = HrAllocAdviseSink(FolderNotification, lpmf, &amp;lpmf-&gt;lpAdvise); <br>    if (FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hrT = MAPICALL(lpmf-&gt;lpTable)-&gt;Advise( <br>        lpmf-&gt;lpTable, <br>        fnevTableModified, <br>        lpmf-&gt;lpAdvise, <br>        &amp;lpmf-&gt;ulConnection); <br>    if (FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>        // Call GetRowCount to make Advise work correctly. <br> <br>        hrT = MAPICALL(lpmf-&gt;lpTable)-&gt;GetRowCount( <br>            lpmf-&gt;lpTable,  <br>            0,  <br>            &amp;ulRowCount); <br>    if (FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>} // end for <br> <br>cleanup: <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrLinkCounterIntoList------------------------------------------------------ </code></pre>
<p>
</p>
<pre><code>//  Helper function that takes a MONCOUNTER structure and links it into the  <br>//  proper list in the MONCONTEXT or the specified MONFOLDER, depending on the  <br>//  counter type. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrLinkCounterIntoList(// RETURNS: return code <br>IN LPMONCONTEXT lpmcx,// pointer to perf mon context <br>IN LPMONFOLDER lpmf,// for folder-specific counters <br>IN LPMONCOUNTER lpmc,// counter structure to add to list <br>IN COUNTERTYPE ctCounterType)// type of counter this is <br>{ <br>MONCOUNTER **lppmcPlaceToAdd= NULL; <br>HRESULThr= NOERROR; <br> <br>DEBUGPRIVATE("HrLinkCounterIntoList()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrLinkCounterIntoList(lpmcx, lpmf, lpmc, ctCounterType); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>switch (ctCounterType) <br>{ <br>case COUNTERTYPE_MESSAGES_IN_FOLDER: <br>ASSERT_WRITE_PTR(lpmf, sizeof(*lpmf), "lpmf: bad write pointer"); <br>lppmcPlaceToAdd = &amp;lpmf-&gt;lpmcMessagesInFolder; <br>break; <br>case COUNTERTYPE_BYTES_IN_FOLDER: <br>ASSERT_WRITE_PTR(lpmf, sizeof(*lpmf), "lpmf: bad write pointer"); <br>lppmcPlaceToAdd = &amp;lpmf-&gt;lpmcBytesInFolder; <br>break; <br>case COUNTERTYPE_MESSAGES_ENTERING_FOLDER: <br>ASSERT_WRITE_PTR(lpmf, sizeof(*lpmf), "lpmf: bad write pointer"); <br>lppmcPlaceToAdd = &amp;lpmf-&gt;lpmcMessagesEnteringFolder; <br>break; <br>case COUNTERTYPE_BYTES_ENTERING_FOLDER: <br>ASSERT_WRITE_PTR(lpmf, sizeof(*lpmf), "lpmf: bad write pointer"); <br>lppmcPlaceToAdd = &amp;lpmf-&gt;lpmcBytesEnteringFolder; <br>break; <br>case COUNTERTYPE_MESSAGES_LEAVING_FOLDER: <br>ASSERT_WRITE_PTR(lpmf, sizeof(*lpmf), "lpmf: bad write pointer"); <br>lppmcPlaceToAdd = &amp;lpmf-&gt;lpmcMessagesLeavingFolder; <br>break; <br>case COUNTERTYPE_BYTES_LEAVING_FOLDER: <br>ASSERT_WRITE_PTR(lpmf, sizeof(*lpmf), "lpmf: bad write pointer"); <br>lppmcPlaceToAdd = &amp;lpmf-&gt;lpmcBytesLeavingFolder; <br>break; <br>case COUNTERTYPE_MESSAGES_TRANSFERRED_IN: <br>lppmcPlaceToAdd = &amp;lpmcx-&gt;lpmcMessagesTransferredIn; <br>break; <br>case COUNTERTYPE_BYTES_TRANSFERRED_IN: <br>lppmcPlaceToAdd = &amp;lpmcx-&gt;lpmcBytesTransferredIn; <br>break; <br>case COUNTERTYPE_MESSAGES_TRANSFERRED_OUT: <br>lppmcPlaceToAdd = &amp;lpmcx-&gt;lpmcMessagesTransferredOut; <br>break; <br>case COUNTERTYPE_BYTES_TRANSFERRED_OUT: <br>lppmcPlaceToAdd = &amp;lpmcx-&gt;lpmcBytesTransferredOut; <br>break; <br>case COUNTERTYPE_NDRS_IN: <br>lppmcPlaceToAdd = &amp;lpmcx-&gt;lpmcNDRsIn; <br>break; <br>case COUNTERTYPE_NDRS_OUT: <br>lppmcPlaceToAdd = &amp;lpmcx-&gt;lpmcNDRsOut; <br>break; <br>case COUNTERTYPE_ASSOCIATIONS: <br>lppmcPlaceToAdd = &amp;lpmcx-&gt;lpmcAssociations; <br>break; <br>default: <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>lpmc-&gt;lpmcNext = *lppmcPlaceToAdd; <br>*lppmcPlaceToAdd = lpmc; <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrVerifyLinkage------------------------------------------------------------ <br>//  Verify that the Export value in the Linkage key for the gateway type  <br>//  exists and contains the gateway name. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrVerifyLinkage(         // RETURNS: HRESULT <br>IN LPMONCONTEXT lpmcx)              // pointer to perf mon context <br>{ <br>HRESULThr        = NOERROR; <br>    DWORD       dwStatus                = ERROR_SUCCESS; <br>TCHARszKeyName[MAX_PATH]     = {0}; <br>HKEYhKey        = NULL; <br>DWORDcch        = 0; <br>    DWORD       dwType                  = 0; <br>    TCHAR       szExport[1000]          = {0}; <br>    DWORD       cbExport                = sizeof(szExport); <br>    BOOL        fFound                  = FALSE; <br>    LPTSTR      psz                     = NULL; <br> <br>DEBUGPRIVATE("HrVerifyLinkage()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrVerifyLinkage(lpmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Create the registry key name from the gateway name. <br> <br>cch = wsprintf( <br>szKeyName,  <br>TEXT("SYSTEM\\CurrentControlSet\\Services\\%s\\Linkage"),  <br>lpmcx-&gt;lpszObjectClass); <br>ASSERTERROR( <br>(cch * sizeof(*szKeyName)) &lt; sizeof(szKeyName),  <br>"wsprintf overflow: szKeyName"); <br> <br>// Open the registry key. <br> <br>dwStatus = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE,  <br>szKeyName,  <br>0L,  <br>KEY_READ,  <br>&amp;hKey); <br>if (dwStatus != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    // Read the value. <br> <br>    dwStatus = RegQueryValueEx( <br>        hKey,  <br>        TEXT("Export"),  <br>        NULL,  <br>        &amp;dwType,  <br>        szExport,  <br>        &amp;cbExport); <br>if (dwStatus != ERROR_SUCCESS || dwType != REG_MULTI_SZ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    // Look in the multi-valued value for the gateway name. <br> <br>    fFound = FALSE; <br>    for (psz = szExport; *psz; psz += (strlen(psz) + 1)) <br>    { <br>        if (!lstrcmpi(psz, lpmcx-&gt;lpszObjectName)) <br>        { <br>            fFound = TRUE; <br>            break; <br>        } <br>    } <br> <br>    // If we didn't find it then return an error. <br> <br>    if (!fFound) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br>// Close the registry key (if it's open). <br> <br>if (hKey) <br>{ <br>dwStatus = RegCloseKey(hKey); <br>        if (dwStatus != ERROR_SUCCESS) <br>            hr = HR_LOG(E_FAIL); <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrSaveSharedMemoryInRegistry----------------------------------------------- <br>//  Save a copy of the shared memory block to the registry so that  <br>//  GWPERF.DLL will be able to generate a blank set of counters when  <br>//  the gateway isn't running. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrSaveSharedMemoryInRegistry(    // RETURNS: HRESULT <br>    IN LPMONCONTEXT lpmcx)                      // pointer to perf mon context <br>{ <br>HRESULThr        = NOERROR; <br>    DWORD       dwStatus                = ERROR_SUCCESS; <br>TCHARszKeyName[MAX_PATH]     = {0}; <br>HKEYhKey        = NULL; <br>DWORDcch        = 0; <br>    BOOL        fSave_DataIsValid       = FALSE; <br> <br>DEBUGPRIVATE("HrSaveSharedMemoryInRegistry()\n"); <br> <br>// Check the parameters. <br> <br>hr = CHK_HrSaveSharedMemoryInRegistry(lpmcx); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // Save off the previous value of fDataIsValid. <br> <br>    fSave_DataIsValid = lpmcx-&gt;lpmsmSharedMemory-&gt;fDataIsValid; <br> <br>    // Create the registry key name from the gateway instance name. <br> <br>cch = wsprintf( <br>szKeyName,  <br>TEXT("SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters"),  <br>lpmcx-&gt;lpszObjectName); <br>ASSERTERROR( <br>(cch * sizeof(*szKeyName)) &lt; sizeof(szKeyName),  <br>"wsprintf overflow: szKeyName"); <br> <br>// Open the registry key. <br> <br>dwStatus = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE,  <br>szKeyName,  <br>0L,  <br>KEY_SET_VALUE,  <br>&amp;hKey); <br>if (dwStatus != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>// Temporarily set the flag that the data in the shared memory  <br>    // is valid, so that it will be stored as valid in the registry. <br> <br>lpmcx-&gt;lpmsmSharedMemory-&gt;fDataIsValid = TRUE; <br> <br>    // Write the value (calculate the size of the block that contains  <br>    // real data by adding the offset of the instance data and its size). <br> <br>    dwStatus = RegSetValueEx( <br>        hKey,  <br>        TEXT("ObjectDefaultPerformanceData"),  <br>        0,  <br>        REG_BINARY,  <br>        (LPBYTE) lpmcx-&gt;lpmsmSharedMemory,  <br>        lpmcx-&gt;lpmsmSharedMemory-&gt;ibInstanceOffset +  <br>            lpmcx-&gt;lpmsmSharedMemory-&gt;cbInstanceSize); <br>if (dwStatus != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>cleanup: <br>// Restore the previous value of fDataIsValid. <br> <br>lpmcx-&gt;lpmsmSharedMemory-&gt;fDataIsValid = fSave_DataIsValid; <br> <br>// Close the registry key (if it's open). <br> <br>if (hKey) <br>{ <br>dwStatus = RegCloseKey(hKey); <br>        if (dwStatus != ERROR_SUCCESS) <br>            hr = HR_LOG(E_FAIL); <br>} <br> <br>    RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
