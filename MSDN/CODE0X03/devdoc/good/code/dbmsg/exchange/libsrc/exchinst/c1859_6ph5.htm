<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXCHINST.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1859"></a>EXCHINST.C</h2>
<pre><code>// --exchinst.c----------------------------------------------------------------- <br>// <br>// Functions for installing Exchange objects. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "dapi.h" <br> <br>#include "exchinst.chk" <br> <br>// <br>// Miscellaneous Defines <br>// <br> <br>#define MAX_CSV_LINE_SIZ                2048 <br>#define MAX_WORD                        0xFFFF <br>#define FILE_PREFIX                     "EXCH" <br>#define NEW_LINE                        "\r\n" <br> <br>#define EXCHINST_DELIM                  '\t' <br>#define EXCHINST_QUOTE                  '"' <br>#define EXCHINST_MV_SEP                 '%' <br> <br>#define SZ_EXCHINST_DELIM               "\t" <br>#define SZ_EXCHINST_QUOTE               "\"" <br>#define SZ_EXCHINST_MV_SEP              "%" <br> <br>#define BEGIN_CSV_LINE(a,b)  lstrcpy(a, b) <br> <br>#define APPEND_CSV_LINE(a,b)           \ <br>    {                                  \ <br>lstrcat(a, SZ_EXCHINST_DELIM); \ <br>lstrcat(a, b);                 \ <br>    } <br> <br>#define DELETEFILE(_file)                       \ <br>{                                               \ <br>    if((_file) != NULL &amp;&amp; (_file)[0] != 0)      \ <br>    {                                           \ <br>if(! DeleteFile ((_file)))              \ <br>{                                       \ <br>    HRESULT _hr = HR_LOG(E_FAIL);       \ <br>}                                       \ <br>    }                                           \ <br>    (_file)[0] = 0;                             \ <br>} <br> <br>// <br>// Attribute Defines <br>// <br> <br>#define OBJ_CLASS                       "Obj-Class" <br>#define MODE                            "Mode" <br>#define ADDR_SYNTAX                     "Address-Syntax" <br>#define ADDR_ENTRY_DT                   "Address-Entry-Display-Table" <br>#define ADDR_TYPE                       "Address-Type" <br>#define ADMIN_DISPLAY_NAME              "Admin-Display-Name" <br>#define DISPLAY_NAME                    "Display-Name" <br>#define COMMON_NAME                     "Common-Name" <br>#define DELIVERY_MECHANISM              "Delivery-Mechanism" <br>#define DELIV_EXT_CONT_TYPES            "Deliv-Ext-Cont-Types" <br>#define EXTENSION_DATA                  "Extension-Data" <br>#define EXTENSION_NAME                  "Extension-Name" <br>#define HELP_FILE_NAME                  "Help-File-Name" <br>#define COMPUTER_NAME                   "Computer-Name" <br>#define GATEWAY_PROXY                   "Gateway-Proxy" <br>#define HOME_SERVER                     "Home-Server" <br>#define FILE_VERSION                    "File-Version" <br>#define PER_MSG_DDT                     "Per-Msg-Dialog-Display-Table" <br>#define PER_RECIP_DDT                   "Per-Recip-Dialog-Display-Table" <br>#define PROXY_GENERATOR_DLL             "Proxy-Generator-DLL" <br>#define ROUTING_LIST                    "Routing-List" <br>#define OBJ_DIST_NAME                   "Obj-Dist-Name" <br>#define ORGANIZATION                    "Organization" <br>#define ORGANIZATIONAL_UNIT             "Organizational-Unit" <br>#define CONTAINER                       "Container" <br>#define HELP_DATA16                     "Help-Data16" <br>#define HELP_DATA32                     "Help-Data32" <br>#define OBJ_ADMIN                       "Obj-Admins" <br>#define SITE_ADDRESSING                 "Site-Addressing" <br>#define ADMIN_EXTENSION_DLL             "Admin-Extension-Dll" <br>#define CAN_PRESERVE_DNS                "Can-Preserve-DNs" <br>#define HEURISTICS                      "Heuristics" <br>#define CONTAINER_INFO                  "Container-Info" <br> <br>// <br>// Attribute Value Defines <br>// <br> <br>#define OBJ_CLASS_GW                    "Mail-Gateway" <br>#define OBJ_CLASS_MB                    "Mailbox-Agent" <br>#define OBJ_CLASS_SITE                  "Site-Addressing" <br>#define OBJ_CLASS_ADDR_TYPE             "Addr-Type" <br>#define OBJ_CLASS_ADDR_TEMPLATE         "Address-Template" <br>#define OBJ_CLASS_ADMIN_EXTENSION       "Admin-Extension" <br>#define OBJ_CLASS_COMPUTER              "Computer" <br>#define OBJ_CLASS_CONTAINER             "Container" <br> <br>// <br>// Container Information Defines <br>// <br> <br>#define ADDRESS_TEMPLATE_CONTAINER_INFO "256" <br> <br>// <br>// Import Mode Defines <br>// <br> <br>#define MODE_CREATE                                             "Create" <br>#define MODE_MODIFY                                             "Modify" <br>#define MODE_DELETE                                             "Delete" <br> <br>#define DELIVERY_MECHANISM_GW                   "2" <br>#define DELIVERY_MECHANISM_MB                   "0" <br> <br>#define CONTAINER_CONFIGURATION         "/cn=Configuration" <br>#define CONTAINER_GW                    "/cn=Configuration/cn=Connections" <br>#define CONTAINER_ADDR_TYPE             "/cn=Configuration/cn=Addressing/cn=Address-Types" <br>#define CONTAINER_ADDR_TEMPLATE         "/cn=Configuration/cn=Addressing/cn=Address-Templates" <br>#define CONTAINER_SERVERS               "/cn=Configuration/cn=Servers" <br>#define CONTAINER_SITE_ADDR             "/cn=Configuration/cn=Site-Addressing" <br>#define CONTAINER_ADD_INS               "/cn=Configuration/cn=Add-Ins" <br> <br>#define ACCOUNT_NAME                    "Obj-Users" <br> <br>// <br>//  Common macros. <br>// <br> <br>#define CREATEKEY(hkParent, pszName, hkOut, dwDisposition) \ <br>    RegCreateKeyEx(hkParent, pszName, 0, "", REG_OPTION_NON_VOLATILE, \ <br>KEY_ALL_ACCESS, NULL, &amp;hkOut, &amp;dwDisposition) <br> <br>#define SETSZVALUE(hk, pszName, pszValue) \ <br>    RegSetValueEx(hk, pszName, 0, REG_SZ, pszValue, lstrlen(pszValue)+1) <br> <br>#define SETMULTISZVALUE(hk, pszName, pszValue) \ <br>    RegSetValueEx(hk, pszName, 0, REG_MULTI_SZ, pszValue, \ <br>CbMultiSz(pszValue)+sizeof(CHAR)) <br> <br>#define FREEHKEY(hk) \ <br>    if(hk != INVALID_HANDLE_VALUE) \ <br>RegCloseKey(hk); <br> <br>static CHAR szExport[]          = "Export"; <br> <br>static CHAR szNull[]            = "(null)"; <br> <br>static CHAR szNullDisplayName[] = "No Display Name!"; <br> <br>//$--CbMultiSz------------------------------------------------------------------ <br>//  Count of bytes in a REG_MULTI_SZ string (not including terminating NULL). <br>// ----------------------------------------------------------------------------- <br>static DWORD CbMultiSz(                 // RETURNS: count of bytes <br>    IN LPSTR lpszRegMultiSz)           // REG_MULTI_SZ string <br>{ <br>    HRESULT hr   = NOERROR; <br>    DWORD   cch  = 0; <br>    DWORD   cb   = 0; <br>    LPSTR  lpsz = NULL; <br> <br>    DEBUGPRIVATE("CbMultiSz()"); <br> <br>    hr = CHK_HrMultiSz(lpszRegMultiSz); <br>    if(FAILED(hr)) <br>return(0); <br> <br>    if(lpszRegMultiSz == NULL) <br>    { <br>goto cleanup; <br>    } <br> <br>    lpsz = lpszRegMultiSz; <br> <br>    while(*lpsz) <br>    { <br>cch = lstrlen(lpsz); <br> <br>cch++; <br> <br>cb  += cch * sizeof(CHAR); <br> <br>lpsz += cch; <br>    } <br> <br>cleanup: <br> <br>    return(cb); <br>} <br> <br>//$--HrGetRegistryValue--------------------------------------------------------- <br>//  Get a registry value - allocating memory to hold it. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetRegistryValue(  // RETURNS: return code <br>    IN  HKEY hk,                    // the key. <br>    IN  LPSTR lpszValue,           // value name in key. <br>    OUT DWORD * lpType,             // where to put type info. <br>    OUT DWORD * lpcb,               // where to put byte count info. <br>    OUT LPVOID * lppData)           // where to put the data. <br>{ <br>    HRESULT hr   = E_FAIL; <br>    LONG    lRet = 0; <br> <br>    DEBUGPRIVATE("HrGetRegistryValue()\n"); <br> <br>    hr = CHK_HrGetRegistryValue( <br>hk, <br>lpszValue, <br>lpType, <br>lpcb, <br>lppData); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    *lppData = NULL; <br> <br>    // <br>    //  Get its size <br>    // <br> <br>    lRet = RegQueryValueEx( <br>hk, <br>lpszValue, <br>NULL, <br>lpType, <br>NULL, <br>lpcb); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Allocate memory for it <br>    // <br> <br>    *lppData = (LPVOID)GlobalAlloc(GMEM_FIXED, *lpcb); <br> <br>    if(*lppData == NULL) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // <br>    // Get the current value <br>    // <br> <br>    lRet = RegQueryValueEx(hk, lpszValue, NULL, lpType, *lppData, lpcb); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    hr = NOERROR; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>if(lppData != NULL) <br>{ <br>    GLOBALFREE(*lppData); <br>} <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--FCsvGetField--------------------------------------------------------------- <br>// Given a record and a field separator and a field number, this routine  <br>// will extract the field requested. <br>//------------------------------------------------------------------------------ <br>static BOOL FCsvGetField(       // RETURNS: TRUE/FALSE <br>    IN  WORD wLen,              // maximum length of the field to extract <br>    IN  WORD wFieldNum,         // field number we want from the record <br>    IN  CHAR cFieldSeparator,  // character to use as a field separator <br>    IN  CHAR *lpszRecord,      // record to extract the field from <br>    OUT CHAR *lpszField)       // field we have extracted <br>{ <br>    HRESULT hr              = NOERROR; <br>    BOOL    fRet            = FALSE; <br>    CHAR   *lpszBeginField = lpszField; <br> <br>    DEBUGPRIVATE("FCsvGetField()"); <br> <br>    hr = CHK_HrCsvGetField( <br>wLen, <br>wFieldNum, <br>cFieldSeparator, <br>lpszRecord, <br>lpszField); <br>    if(FAILED(hr)) <br>return(FALSE); <br> <br>    while((wFieldNum &gt; 0) &amp;&amp; (*lpszRecord != 0)) <br>    { <br>// If we found a field separator, increment current field <br>if(*lpszRecord == cFieldSeparator) <br>{ <br>    wFieldNum--; <br>} <br>// If we are at the desired field, copy the current character into it <br>else if(wFieldNum == 1 &amp;&amp; wLen &gt; 1) <br>{ <br>    *lpszField = *lpszRecord; <br>    lpszField++; <br>    wLen--; <br>} <br> <br>lpszRecord++; <br>    } <br> <br>    *lpszField = 0; <br> <br>    // If the requested field # existed, return True, <br>    // otherwise we ran out of fields - return False <br> <br>    if(wFieldNum &lt;= 1) <br>    { <br>fRet = TRUE; <br>    } <br>    else <br>    { <br>fRet = FALSE; <br>    } <br> <br>    return(fRet); <br>} <br> <br>//$--FCsvGetRecord-------------------------------------------------------------- <br>// Given a buffer, the buffer's length and a file handle, this <br>// function fills the buffer with a single line read from the file.  <br>// The NL &amp; CR are NOT put into the buffer. No unprintable characters are <br>// placed in the buffer <br>// ----------------------------------------------------------------------------- <br>BOOL FCsvGetRecord(                 // RETURNS: TRUE/FALSE <br>    IN  WORD wBufferLen,            // length of the record buffer <br>    IN  HANDLE hFile,               // file handle to read from <br>    OUT CHAR *lpszBuffer)          // record we have retrieved <br>{ <br>    HRESULT hr          = NOERROR; <br>    DWORD   dwBytesRead = 0; <br>    BOOL    fReadData   = FALSE; <br> <br>    DEBUGPRIVATE("FCsvGetRecord()"); <br> <br>    hr = CHK_HrCsvGetRecord( <br>wBufferLen, <br>hFile, <br>lpszBuffer); <br>    if(FAILED(hr)) <br>return(FALSE); <br> <br>    while((ReadFile(hFile, (LPVOID)lpszBuffer, 1, &amp;dwBytesRead, NULL) == TRUE) &amp;&amp; <br>  (wBufferLen &gt; 1) &amp;&amp; (*lpszBuffer != '\n') &amp;&amp; (dwBytesRead &gt; 0)) <br>    { <br>fReadData = TRUE; <br> <br>// Only store character in buffer if it is printable! <br> <br>if((isprint(*lpszBuffer)) || (*lpszBuffer == EXCHINST_DELIM)) <br>{ <br>    lpszBuffer++; <br>    wBufferLen--; <br>} <br>    } <br> <br>    // If a given record is too long it is a problem!!! <br> <br>    if(wBufferLen &lt;= 0) <br>    { <br>fReadData = FALSE; <br>    } <br> <br>    *lpszBuffer = 0; <br> <br>    return(fReadData); <br>} <br> <br>//$--HrEDKExportObject---------------------------------------------------------- <br>// This function will export an object from an Exchange server. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKExportObject(       // RETURNS: return code <br>    IN  LPSTR lpszServer,              // server name <br>    IN  LPSTR lpszBasePoint,           // base point <br>    IN  DWORD dwControlFlags,           // control flags <br>    IN  LPSTR *rgpszClasses,           // classes <br>    IN  LPSTR lpszObjectAttributes,    // list of attributes to export <br>    OUT LPSTR lpszTempName)            // temporary file name <br>{ <br>    HRESULT       hr                     = E_FAIL; <br>    ULONG         cErrors                = 0; <br>    HANDLE        hTempFile              = INVALID_HANDLE_VALUE; <br>    CHAR          szTempPath[MAX_PATH+1] = {0}; <br>    DWORD         dwNumberOfBytesWritten = 0; <br>    BEXPORT_PARMS BExportParms           = {0}; <br>    BOOL          fRet                   = FALSE; <br> <br>    DEBUGPRIVATE("HrEDKExportObject()"); <br> <br>    hr = CHK_HrEDKExportObject( <br>lpszServer, <br>lpszBasePoint, <br>dwControlFlags, <br>rgpszClasses, <br>lpszObjectAttributes, <br>lpszTempName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // Get temporary directory path <br> <br>    if(!GetTempPath(MAX_PATH, szTempPath)) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // Get temporary file name <br> <br>    if(!GetTempFileName(szTempPath, FILE_PREFIX, 0, lpszTempName)) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // Create the temporary file <br>    hTempFile = CreateFile(lpszTempName, <br>GENERIC_WRITE, <br>0, <br>(LPSECURITY_ATTRIBUTES)NULL, <br>CREATE_ALWAYS, <br>FILE_ATTRIBUTE_NORMAL, <br>(HANDLE)NULL); <br> <br>    // Check to see if temporary file was created... <br> <br>    if(hTempFile == INVALID_HANDLE_VALUE) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // Write data to the temporary file &amp; close it <br> <br>    fRet = WriteFile( <br>hTempFile, <br>lpszObjectAttributes, <br>lstrlen(lpszObjectAttributes)*sizeof(CHAR), <br>&amp;dwNumberOfBytesWritten, <br>NULL); <br> <br>    if(fRet == FALSE) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br> <br>    fRet = WriteFile( <br>hTempFile, <br>NEW_LINE, <br>lstrlen(NEW_LINE)*sizeof(CHAR), <br>&amp;dwNumberOfBytesWritten, <br>NULL); <br> <br>    if(fRet == FALSE) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    // <br>    // Batch Export <br>    // <br> <br>    BExportParms.dwDAPISignature = DAPI_SIGNATURE; <br>    BExportParms.dwFlags         = dwControlFlags |  <br>   DAPI_MODIFY_REPLACE_PROPERTIES |  <br>   DAPI_SUPPRESS_PROGRESS |  <br>   DAPI_SUPPRESS_COMPLETION |  <br>                   DAPI_SUPPRESS_ARCHIVES |  <br>                   DAPI_IMPORT_NO_ERR_FILE; <br>    BExportParms.pszExportFile   = lpszTempName; <br>    BExportParms.pszBasePoint    = lpszBasePoint; <br>    BExportParms.pszDSAName      = lpszServer; <br>    BExportParms.rgpszClasses    = rgpszClasses; <br>    BExportParms.chColSep        = EXCHINST_DELIM; <br>    BExportParms.chQuote         = EXCHINST_QUOTE; <br>    BExportParms.chMVSep         = EXCHINST_MV_SEP; <br> <br>    cErrors = BatchExport(&amp;BExportParms); <br> <br>    if(cErrors == 0) <br>    { <br>hr = NOERROR; <br>    } <br>    else <br>    { <br>hr = HR_LOG(E_FAIL); <br>    } <br>     <br>cleanup: <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKImportObject---------------------------------------------------------- <br>// This function will import an object into an Exchange server. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKImportObject (      // RETURNS: return code <br>    IN  LPSTR lpszServer,              // server name <br>    IN  LPSTR lpszBasePoint,           // base point <br>    IN  LPSTR lpszObjectAttributes,    // list of attributes to import <br>    IN  LPSTR lpszAttributeValues)     // list of attributes values to import <br>{ <br>    HRESULT       hr                     = E_FAIL; <br>    ULONG         cErrors                = 0; <br>    HANDLE        hTempFile              = INVALID_HANDLE_VALUE; <br>    CHAR         szTempName[MAX_PATH+1] = {0}; <br>    CHAR         szTempPath[MAX_PATH+1] = {0}; <br>    DWORD         cBytes                 = 0; <br>    BIMPORT_PARMS BImportParms           = {0}; <br>    BOOL          fRet                   = FALSE; <br> <br>    DEBUGPRIVATE("HrEDKImportObject()"); <br> <br>    hr = CHK_HrEDKImportObject( <br>lpszServer, <br>lpszBasePoint, <br>lpszObjectAttributes, <br>lpszAttributeValues); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // Get temporary directory path <br> <br>    if(!GetTempPath(MAX_PATH, szTempPath)) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // Get temporary file name <br> <br>    if(!GetTempFileName(szTempPath, FILE_PREFIX, 0, szTempName)) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // Create the temporary file <br> <br>    hTempFile = CreateFile(szTempName, <br>GENERIC_WRITE, <br>0, <br>(LPSECURITY_ATTRIBUTES)NULL, <br>CREATE_ALWAYS, <br>FILE_ATTRIBUTE_NORMAL, <br>(HANDLE)NULL); <br> <br>    // Check to see if temporary file was created <br> <br>    if(hTempFile == INVALID_HANDLE_VALUE) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // Write data to the temporary file &amp; close it <br> <br>    fRet = WriteFile( <br>hTempFile, <br>lpszObjectAttributes, <br>lstrlen(lpszObjectAttributes)*sizeof(CHAR), <br>&amp;cBytes, <br>NULL); <br> <br>    if(fRet == FALSE) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    fRet = WriteFile( <br>hTempFile, <br>NEW_LINE, <br>lstrlen(NEW_LINE)*sizeof(CHAR), <br>&amp;cBytes, <br>NULL); <br> <br>    if(fRet == FALSE) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    fRet = WriteFile( <br>hTempFile, <br>lpszAttributeValues, <br>lstrlen(lpszAttributeValues)*sizeof(CHAR), <br>&amp;cBytes, <br>NULL); <br> <br>    if(fRet == FALSE) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    // <br>    // Batch Import <br>    // <br> <br>    BImportParms.dwDAPISignature = DAPI_SIGNATURE; <br>    BImportParms.dwFlags         = DAPI_RESTRICT_ACCESS |  <br>   DAPI_SUPPRESS_PROGRESS | <br>                   DAPI_MODIFY_REPLACE_PROPERTIES | <br>   DAPI_YES_TO_ALL | <br>   DAPI_EVENT_ALL | <br>   DAPI_SUPPRESS_COMPLETION |  <br>                   DAPI_SUPPRESS_ARCHIVES |  <br>                   DAPI_IMPORT_NO_ERR_FILE; <br>    BImportParms.pszImportFile   = szTempName; <br>    BImportParms.pszBasePoint    = lpszBasePoint; <br>    BImportParms.pszDSAName      = lpszServer; <br>    BImportParms.chColSep        = EXCHINST_DELIM; <br>    BImportParms.chQuote         = EXCHINST_QUOTE; <br>    BImportParms.chMVSep         = EXCHINST_MV_SEP; <br> <br>    cErrors = BatchImport(&amp;BImportParms); <br> <br>    if(cErrors == 0) <br>    { <br>hr = NOERROR; <br>    } <br>    else <br>    { <br>hr = HR_LOG(E_FAIL); <br>    } <br>     <br>cleanup: <br> <br>    CLOSEHANDLE(hTempFile); <br>    DELETEFILE(szTempName); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrDeleteObject---------------------------------------------------------- <br>//  Deletes an object from an Exchange server <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDeleteObject(   // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszBasepoint,        // base point <br>    IN LPSTR lpszCommonName,       // common name <br>    IN LPSTR lpszObjClass)         // object class <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues [MAX_CSV_LINE_SIZ] = {0}; <br> <br>    DEBUGPRIVATE("HrDeleteObject()"); <br> <br>    hr = CHK_HrDeleteObject( <br>lpszServer, <br>lpszBasepoint, <br>lpszCommonName, <br>lpszObjClass); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , lpszObjClass); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_DELETE); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszCommonName); <br> <br>    hr = HR_LOG(HrEDKImportObject( <br>lpszServer, <br>lpszBasepoint, <br>szObjectAttributes, <br>szAttributeValues)); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKObjectExists---------------------------------------------------------- <br>//  Checks if an object exists in the directory. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKObjectExists(   // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszBasePoint,        // base point <br>    IN LPSTR lpszObjClass,         // object class <br>    IN LPSTR lpszCommonName)       // common name <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues [MAX_CSV_LINE_SIZ] = {0}; <br> <br>    DEBUGPRIVATE("HrEDKObjectExists()"); <br> <br>    hr = CHK_HrEDKObjectExists( <br>lpszServer, <br>lpszBasePoint, <br>lpszCommonName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , lpszObjClass); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_MODIFY); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszCommonName); <br> <br>    hr = HR_LOG(HrEDKImportObject( <br>lpszServer, <br>lpszBasePoint, <br>szObjectAttributes, <br>szAttributeValues)); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKEnumAttrib------------------------------------------------------------ <br>//  Enumerates the given attribute. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKEnumAttrib(          // RETURNS: return code <br>    IN  LPSTR lpszRootDN,               // distinguished name of DIT root <br>    IN  LPSTR lpszServer,               // server name <br>    IN  LPSTR *rgpszClasses,            // classes <br>    IN  LPSTR lpszAttribName,           // attribute name <br>    OUT LPSTR *lppszAttribValues)       // attribute values <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    HANDLE  hTempFile                            = INVALID_HANDLE_VALUE; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCurRecord[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szCurLine[MAX_CSV_LINE_SIZ]          = {0}; <br>    CHAR   szCurField[MAX_PATH+1]               = {0}; <br>    CHAR   szTempName[MAX_PATH+1]               = {0}; <br>    WORD    wAttribField                         = MAX_WORD; <br>    WORD    wCurrField                           = 0; <br>    LPSTR  lpsz                                 = NULL; <br>    LPSTR  lpszCurrAttrib                       = NULL; <br> <br>    DEBUGPRIVATE("HrEDKEnumAttrib()"); <br> <br>    hr = CHK_HrEDKEnumAttrib( <br>lpszRootDN, <br>lpszServer, <br>rgpszClasses, <br>lpszAttribName, <br>lppszAttribValues); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    *lppszAttribValues = NULL; <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    APPEND_CSV_LINE (szObjectAttributes, lpszAttribName); <br> <br>    hr = HrEDKExportObject( <br>lpszServer, <br>lpszRootDN, <br>DAPI_EXPORT_BASEPOINT_ONLY, <br>rgpszClasses, <br>szObjectAttributes, <br>szTempName); <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>// Open the temporary file <br>hTempFile = CreateFile ( <br>    szTempName, <br>    GENERIC_READ, <br>    0, <br>    (LPSECURITY_ATTRIBUTES)NULL, <br>    OPEN_EXISTING, <br>    FILE_FLAG_DELETE_ON_CLOSE, <br>    (HANDLE)NULL); <br> <br>if(hTempFile == INVALID_HANDLE_VALUE) <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>// <br>// The first line contains the list of fields - find which field has <br>// the attribute we are looking for. <br>// <br> <br>FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>for( <br>    wCurrField = 1; <br> <br>    FCsvGetField( <br>MAX_PATH, <br>wCurrField, <br>EXCHINST_DELIM, <br>szCurLine, <br>szCurField); <br> <br>    wCurrField++) <br>{ <br>    if(strcmp(szCurField, lpszAttribName) == 0)  <br>    { <br>wAttribField = wCurrField; <br>break; <br>    } <br>} <br> <br>// Was the field exported &amp; found above? <br> <br>if(wAttribField == MAX_WORD)  <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br> <br>while( FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine)) <br>{ <br>    FCsvGetField( <br>MAX_CSV_LINE_SIZ, <br>wAttribField, <br>EXCHINST_DELIM, <br>szCurLine, <br>szCurRecord); <br> <br>    if( *szCurRecord) <br>    { <br>lpsz = (LPSTR)GlobalAlloc( <br>    GMEM_FIXED, <br>    cbStrLen(szCurRecord) + sizeof(CHAR)); <br> <br>if(lpsz == NULL) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>    goto cleanup; <br>} <br> <br>lpszCurrAttrib = lpsz; <br> <br>for( <br>    wCurrField = 1; <br> <br>    FCsvGetField( <br>MAX_PATH, <br>wCurrField, <br>EXCHINST_MV_SEP, <br>szCurRecord, <br>szCurField); <br> <br>    wCurrField++) <br>{ <br>    lstrcpy(lpszCurrAttrib, szCurField); <br> <br>    lpszCurrAttrib += cbStrLen(lpszCurrAttrib); <br>} <br> <br>*lpszCurrAttrib = 0; <br>break;  // single record only <br>    } <br>} <br>    } <br> <br>    *lppszAttribValues = lpsz; <br> <br>cleanup: <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    if(FAILED(hr)) <br>    { <br>GLOBALFREE(*lppszAttribValues); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKEnumDNs--------------------------------------------------------------- <br>//  Enumerates the distinguished name(s). <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKEnumDNs(             // RETURNS: return code <br>    IN  LPSTR lpszRootDN,               // distinguished name of DIT root <br>    IN  LPSTR lpszServer,               // server name <br>    IN  DWORD  dwControlFlags,           // control flags <br>    IN  LPSTR *rgpszClasses,            // classes <br>    OUT LPSTR *lppszDNs)                // distinguished names <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    HANDLE  hTempFile                            = INVALID_HANDLE_VALUE; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCurRecord[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szCurLine[MAX_CSV_LINE_SIZ]          = {0}; <br>    CHAR   szCurField[MAX_PATH+1]               = {0}; <br>    CHAR   szTempName[MAX_PATH+1]               = {0}; <br>    WORD    wAttribField                         = MAX_WORD; <br>    WORD    wCurrField                           = 0; <br>    LPSTR  lpsz                                 = NULL; <br>    ULONG   ulCurrOffset                         = 0; <br> <br>    DEBUGPRIVATE("HrEDKEnumDNs()"); <br> <br>    hr = CHK_HrEDKEnumDNs( <br>lpszRootDN, <br>lpszServer, <br>dwControlFlags, <br>rgpszClasses, <br>lppszDNs); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    *lppszDNs = NULL; <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    APPEND_CSV_LINE (szObjectAttributes, OBJ_DIST_NAME); <br> <br>    hr = HrEDKExportObject( <br>lpszServer, <br>lpszRootDN, <br>dwControlFlags, <br>rgpszClasses, <br>szObjectAttributes, <br>szTempName); <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>// Open the temporary file <br>hTempFile = CreateFile ( <br>    szTempName, <br>    GENERIC_READ, <br>    0, <br>    (LPSECURITY_ATTRIBUTES)NULL, <br>    OPEN_EXISTING, <br>    FILE_FLAG_DELETE_ON_CLOSE, <br>    (HANDLE)NULL); <br> <br>if(hTempFile == INVALID_HANDLE_VALUE) <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>// <br>// The first line contains the list of fields - find which field has <br>// the attribute we are looking for. <br>// <br> <br>FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>for( <br>    wCurrField = 1; <br> <br>    FCsvGetField( <br>MAX_PATH, <br>wCurrField, <br>EXCHINST_DELIM, <br>szCurLine, <br>szCurField); <br> <br>    wCurrField++) <br>{ <br>    if(strcmp(szCurField, OBJ_DIST_NAME) == 0)  <br>    { <br>wAttribField = wCurrField; <br>break; <br>    } <br>} <br> <br>// Was the field exported &amp; found above? <br> <br>if(wAttribField == MAX_WORD)  <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>ulCurrOffset = 0; <br> <br>while(FCsvGetRecord (MAX_CSV_LINE_SIZ, hTempFile, szCurLine)) <br>{ <br>    FCsvGetField( <br>MAX_PATH, <br>wAttribField, <br>EXCHINST_DELIM, <br>szCurLine, <br>szCurField); <br> <br>    if( *szCurField) <br>    { <br>if(lpsz == NULL) <br>{ <br>    lpsz = (LPSTR)GlobalAlloc( <br>GMEM_FIXED, <br>cbStrLen(szCurField) + sizeof(CHAR)); <br>} <br>else <br>{ <br>    lpsz = (LPSTR)GlobalReAlloc( <br>lpsz, <br>GlobalSize(lpsz) + cbStrLen(szCurField), <br>GMEM_MOVEABLE); <br>} <br> <br>if(lpsz == NULL) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>    goto cleanup; <br>} <br> <br>lstrcpy(&amp;lpsz[ulCurrOffset], szCurField); <br> <br>ulCurrOffset += cbStrLen(szCurField); <br> <br>lpsz[ulCurrOffset] = 0; <br>    } <br>} <br>    } <br>     <br>    *lppszDNs = lpsz; <br> <br>cleanup: <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    if(FAILED(hr)) <br>    { <br>GLOBALFREE(*lppszDNs); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEnumOrganizations----------------------------------------------------- <br>//  Enumerates the organization name(s). <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEnumOrganizations(          // RETURNS: return code <br>    IN  LPSTR lpszRootDN,               // distinguished name of DIT root <br>    IN  LPSTR lpszServer,               // server name <br>    OUT LPSTR *lppszOrganizations)      // organizations </code></pre>
<p>
</p>
<pre><code>{ <br>    HRESULT hr              = NOERROR; <br>    LPSTR  rgpszClasses[2] = {0}; <br> <br>    DEBUGPUBLIC("HrEnumOrganizations()"); <br> <br>    hr = CHK_HrEnumOrganizations( <br>lpszRootDN, <br>lpszServer, <br>lppszOrganizations); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    rgpszClasses[0] = ORGANIZATION; <br>    rgpszClasses[1] = NULL; <br> <br>    hr = HrEDKEnumDNs( <br>lpszRootDN, <br>lpszServer, <br>DAPI_EXPORT_SUBTREE, <br>rgpszClasses, <br>lppszOrganizations); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEnumSites------------------------------------------------------------- <br>//  Enumerates the site name(s). <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEnumSites(                  // RETURNS: return code <br>    IN  LPSTR lpszServer,               // server name <br>    IN  LPSTR lpszOrganizationDN,       // distinguished name of organization <br>    OUT LPSTR *lppszSites)              // sites <br>{ <br>    HRESULT hr              = NOERROR; <br>    LPSTR  rgpszClasses[2] = {0}; <br> <br>    DEBUGPUBLIC("HrEnumSites()"); <br> <br>    hr = CHK_HrEnumSites( <br>lpszServer, <br>lpszOrganizationDN, <br>lppszSites); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    rgpszClasses[0] = ORGANIZATIONAL_UNIT; <br>    rgpszClasses[1] = NULL; <br> <br>    hr = HrEDKEnumDNs( <br>lpszOrganizationDN, <br>lpszServer, <br>0, <br>rgpszClasses, <br>lppszSites); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEnumContainers-------------------------------------------------------- <br>//  Enumerates the container name(s). <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEnumContainers(             // RETURNS: return code <br>    IN  LPSTR lpszServer,               // server name <br>    IN  LPSTR lpszSiteDN,               // distinguished name of site <br>    IN  BOOL   fSubtree,                 // sub-tree? <br>    OUT LPSTR *lppszContainers)         // containers <br>{ <br>    HRESULT hr              = NOERROR; <br>    LPSTR  rgpszClasses[2] = {0}; <br>    DWORD   dwControlFlags  = 0; <br> <br>    DEBUGPUBLIC("HrEnumContainers()"); <br> <br>    hr = CHK_HrEnumContainers( <br>lpszServer, <br>lpszSiteDN, <br>fSubtree, <br>lppszContainers); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    rgpszClasses[0] = CONTAINER; <br>    rgpszClasses[1] = NULL; <br> <br>    if(fSubtree == TRUE) <br>    { <br>dwControlFlags = DAPI_EXPORT_SUBTREE; <br>    } <br> <br>    hr = HrEDKEnumDNs( <br>lpszSiteDN, <br>lpszServer, <br>dwControlFlags, <br>rgpszClasses, <br>lppszContainers); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEnumSiteAdmins-------------------------------------------------------- <br>//  Enumerates the administrators for a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEnumSiteAdmins(             // RETURNS: return code <br>    IN  LPSTR lpszServer,               // server name <br>    IN  LPSTR lpszSiteDN,               // distinguished name of site <br>    OUT LPSTR *lppszAdmins)             // administrator accounts <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrEnumSiteAdmins()"); <br> <br>    hr = CHK_HrEnumSiteAdmins( <br>lpszServer, <br>lpszSiteDN, <br>lppszAdmins); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrEDKEnumAttrib( <br>lpszSiteDN, <br>lpszServer, <br>NULL, <br>OBJ_ADMIN, <br>lppszAdmins); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEnumProductServices--------------------------------------------------- <br>//  Enumerates the services for a product. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrEnumProductServices(        // RETURNS: return code <br>    IN  LPSTR lpszProductGuid,          // product GUID <br>    OUT LPSTR *lppszServices,           // service names <br>    OUT LPSTR *lppszDisplayNames)       // service display names <br>{ <br>    HRESULT   hr                        = NOERROR; <br>    LONG      lRet                      = 0; <br>    HKEY      hkServices                = INVALID_HANDLE_VALUE; <br>    HKEY      hKey                      = INVALID_HANDLE_VALUE; <br>    SC_HANDLE schSCManager              = NULL;  <br>    SC_HANDLE schService                = NULL; <br>    DWORD     dwType                    = 0; <br>    DWORD     cbGuid                    = 0; <br>    LPSTR    lpszGuid                  = NULL; <br>    DWORD     cbName                    = 0; <br>    LPSTR    lpszName                  = NULL; <br> <br>    CHAR     szServiceName[MAX_PATH+1] = {0}; <br>    LPSTR    lpszServices              = NULL; <br>    LPSTR    lpszDisplayNames          = NULL; <br>    FILETIME  ftLastWrite               = {0}; <br>    DWORD     dwBufferSize              = 0; <br>    DWORD     iSubKey                   = 0; <br>    ULONG     ulServOffset              = 0; <br>    ULONG     ulDispOffset              = 0; <br>    CHAR     szSubKey[MAX_PATH+1]      = {0}; <br>    LONG      cBytes                    = 0; <br> <br>    DEBUGPUBLIC("HrEnumProductServices()"); <br> <br>    hr = CHK_HrEnumProductServices( <br>lpszProductGuid, <br>lppszServices, <br>lppszDisplayNames); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    *lppszServices = NULL; <br>    *lppszDisplayNames = NULL; <br> <br>    // <br>    //  Connect to service control manager. <br>    // <br> <br>    schSCManager = OpenSCManager( <br>NULL,                       // machine (NULL == local) <br>NULL,                       // database (NULL == default) <br>SC_MANAGER_ALL_ACCESS);     // access required <br> <br>    if(schSCManager == NULL) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open the services key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE, <br>"SYSTEM\\CurrentControlSet\\Services",  <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hkServices); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    ulServOffset = 0; <br>    ulDispOffset = 0; <br> <br>    for(;;) <br>    { <br>if(lpszGuid != szNull) <br>{ <br>    GLOBALFREE(lpszGuid); <br>} <br> <br>if(lpszName != szNullDisplayName) <br>{ <br>    GLOBALFREE(lpszName); <br>} <br> <br>dwBufferSize = MAX_PATH+1; <br> <br>lRet = RegEnumKeyEx( <br>    hkServices, <br>    iSubKey, <br>    szServiceName, <br>    &amp;dwBufferSize, <br>    NULL, <br>    NULL, <br>    NULL, <br>    &amp;ftLastWrite);       <br> <br>iSubKey++; <br> <br>if(lRet == ERROR_NO_MORE_ITEMS) <br>{ <br>    break; <br>} <br> <br>// <br>//  Open the service "Parameters" key. <br>// <br> <br>cBytes = _snprintf( <br>    szSubKey, <br>    MAX_PATH+1, <br>    "%s\\Parameters", <br>    szServiceName); <br> <br>if(cBytes &lt; 0) <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>lRet = RegOpenKeyEx( <br>    hkServices, <br>    szSubKey,  <br>    0, <br>    KEY_ALL_ACCESS, <br>    &amp;hKey); <br> <br>if(lRet != ERROR_SUCCESS) <br>{ <br>    continue; <br>} <br> <br>// <br>//  Get the current value. <br>// <br> <br>hr = HrGetRegistryValue( <br>    hKey, <br>    "ProductGUID", <br>    &amp;dwType, <br>    &amp;cbGuid, <br>    &amp;lpszGuid); <br> <br>FREEHKEY(hKey); <br> <br>if(FAILED(hr) || dwType != REG_SZ) <br>{ <br>    continue; <br>} <br> <br>if(lpszGuid == NULL) <br>{ <br>    lpszGuid = szNull; <br>} <br> <br>// <br>//  Open the service key. <br>// <br> <br>cBytes = _snprintf( <br>    szSubKey, <br>    MAX_PATH+1, <br>    "%s", <br>    szServiceName); <br> <br>if(cBytes &lt; 0) <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>lRet = RegOpenKeyEx( <br>    hkServices, <br>    szSubKey,  <br>    0, <br>    KEY_ALL_ACCESS, <br>    &amp;hKey); <br> <br>if(lRet != ERROR_SUCCESS) <br>{ <br>    continue; <br>} <br> <br>// <br>//  Get the current value. <br>// <br> <br>hr = HrGetRegistryValue( <br>    hKey, <br>    "DisplayName", <br>    &amp;dwType, <br>    &amp;cbName, <br>    &amp;lpszName); <br> <br>FREEHKEY(hKey); <br> <br>if(FAILED(hr) || dwType != REG_SZ) <br>{ <br>    lpszName = szNullDisplayName; <br>} <br> <br>if(lpszName == NULL) <br>{ <br>    lpszName = szNullDisplayName; <br>} <br> <br>if(!lstrcmpi(lpszProductGuid, lpszGuid)) <br>{ <br>    // <br>    // Add the service name to the list. <br>    // <br> <br>    if(lpszServices == NULL) <br>    { <br>cBytes = cbStrLen(szServiceName) + sizeof(CHAR); <br> <br>lpszServices = (LPSTR)GlobalAlloc( <br>    GMEM_FIXED, <br>    cBytes); <br>    } <br>    else <br>    { <br>LPSTR lpszT = NULL; <br> <br>cBytes = GlobalSize(lpszServices) + <br> cbStrLen(szServiceName) + <br> sizeof(CHAR); <br> <br>lpszT = (LPSTR)GlobalReAlloc( <br>    lpszServices, <br>    cBytes, <br>    GMEM_MOVEABLE); <br> <br>if(lpszT != NULL) <br>{ <br>    lpszServices = lpszT; <br>} <br>    } <br> <br>    if(lpszServices == NULL) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    lstrcpy(&amp;lpszServices[ulServOffset], szServiceName); <br> <br>    ulServOffset += lstrlen(szServiceName); <br>    lpszServices[ulServOffset] = 0; <br> <br>    ulServOffset ++; <br>    lpszServices[ulServOffset] = 0; <br> <br>    // <br>    // Add the service display name to the list. <br>    // <br> <br>    if(lpszDisplayNames == NULL) <br>    { <br>cBytes = cbStrLen(lpszName) + sizeof(CHAR); <br> <br>lpszDisplayNames = (LPSTR)GlobalAlloc( <br>    GMEM_FIXED, <br>    cBytes); <br>    } <br>    else <br>    { <br>LPSTR lpszT = NULL; <br> <br>cBytes = GlobalSize(lpszDisplayNames) + <br> cbStrLen(lpszName) + <br> sizeof(CHAR); <br> <br>lpszT = (LPSTR)GlobalReAlloc( <br>    lpszDisplayNames, <br>    cBytes, <br>    GMEM_MOVEABLE); <br> <br>if(lpszT != NULL) <br>{ <br>    lpszDisplayNames = lpszT; <br>} <br>    } <br> <br>    if(lpszDisplayNames == NULL) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    lstrcpy(&amp;lpszDisplayNames[ulDispOffset], lpszName); <br> <br>    ulDispOffset += lstrlen(lpszName); <br>    lpszDisplayNames[ulDispOffset] = 0; <br> <br>    ulDispOffset ++; <br>    lpszDisplayNames[ulDispOffset] = 0; <br>} <br> <br>if(lpszGuid != szNull) <br>{ <br>    GLOBALFREE(lpszGuid); <br>} <br> <br>if(lpszName != szNullDisplayName) <br>{ <br>    GLOBALFREE(lpszName); <br>} <br>    } <br> <br>    *lppszServices = lpszServices; <br>    *lppszDisplayNames = lpszDisplayNames; <br> <br>    hr = NOERROR; <br> <br>cleanup: <br> <br>    FREEHSCM(schService); <br>    FREEHSCM(schSCManager); <br> <br>    FREEHKEY(hkServices); <br>    FREEHKEY(hKey); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    if(lpszGuid != szNull) <br>    { <br>GLOBALFREE(lpszGuid); <br>    } <br> <br> <br>    if(lpszName != szNull) <br>    { <br>GLOBALFREE(lpszName); <br>    } <br> <br>    if(FAILED(hr)) <br>    { <br>GLOBALFREE(*lppszServices); <br>GLOBALFREE(*lppszDisplayNames); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallService-------------------------------------------------------- <br>//  Installs a service associated with an Exchange object. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallService(            // RETURNS: return code <br>    IN LPSTR  lpszServer,              // server name <br>    IN LPSTR  lpszSiteDN,              // distinguished name of site <br>    IN LPSTR  lpszServiceDisplayName,  // service display name <br>    IN LPSTR  lpszServiceName,         // service name <br>    IN LPSTR  lpszCommonName,          // object relative distinguished name <br>    IN LPSTR  lpszObjectGuid,          // object GUID <br>    IN LPSTR  lpszProductGuid,         // product GUID <br>    IN LPSTR  lpszExeName,             // executable name <br>    IN LPCSTR lpszDependencies,        // dependencies <br>    IN LPSTR  lpszAccount,             // account <br>    IN LPSTR  lpszPassword)            // password <br>{ <br>    HRESULT   hr                 = NOERROR; <br>    LONG      lRet               = 0; <br>    HKEY      hkServices         = INVALID_HANDLE_VALUE; <br>    HKEY      hkObject           = INVALID_HANDLE_VALUE; <br>    HKEY      hkTmp              = INVALID_HANDLE_VALUE; <br>    DWORD     dwDisposition      = 0; <br>    BOOL      bObjectKeyCreated  = FALSE; <br>    SC_HANDLE schSCManager       = NULL;  <br>    SC_HANDLE schService         = NULL; <br> <br>    DEBUGPUBLIC("HrInstallService()"); <br> <br>    hr = CHK_HrInstallService( <br>lpszServer, <br>lpszSiteDN, <br>lpszServiceDisplayName, <br>lpszServiceName, <br>lpszCommonName, <br>lpszObjectGuid, <br>lpszProductGuid, <br>lpszExeName, <br>lpszDependencies, <br>lpszAccount, <br>lpszPassword); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // <br>    //  Connect to service control manager. <br>    // <br> <br>    schSCManager = OpenSCManager( <br>NULL,                       // machine (NULL == local) <br>NULL,                       // database (NULL == default) <br>SC_MANAGER_ALL_ACCESS);     // access required <br> <br>    if(schSCManager == NULL) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Create the service. <br>    // <br> <br>    schService = CreateService( <br>schSCManager,               // SCManager database <br>lpszServiceName,            // service name <br>lpszServiceDisplayName,     // service display name <br>SERVICE_ALL_ACCESS,         // desired access <br>SERVICE_WIN32_OWN_PROCESS,  // service type <br>SERVICE_DEMAND_START,       // start type <br>SERVICE_ERROR_NORMAL,       // error control type <br>lpszExeName,                // service's binary <br>NULL,                       // no load ordering group <br>NULL,                       // no tag identifier <br>lpszDependencies,           // dependencies <br>lpszAccount,                // account <br>lpszPassword);              // password <br> <br>    if(schService == NULL) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open the services key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE, <br>"SYSTEM\\CurrentControlSet\\Services",  <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hkServices); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Create the object key. <br>    // <br> <br>    lRet = CREATEKEY(hkServices, lpszServiceName, hkObject, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    bObjectKeyCreated = TRUE; <br> <br>    // <br>    // Create Parameters key. <br>    // <br> <br>    lRet = CREATEKEY(hkObject, "Parameters", hkTmp, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // Create new values under Parameters key <br> <br>    lRet = SETSZVALUE(hkTmp, "HomeDSA", lpszServer); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    lRet = SETSZVALUE(hkTmp, "SiteDN", lpszSiteDN); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    lRet = SETSZVALUE(hkTmp, "CommonName", lpszCommonName); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    lRet = SETSZVALUE(hkTmp, "ObjectGUID", lpszObjectGuid); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    lRet = SETSZVALUE(hkTmp, "ProductGUID", lpszProductGuid); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    FREEHSCM(schService); <br>    FREEHSCM(schSCManager); <br> <br>    FREEHKEY(hkServices); <br>    FREEHKEY(hkObject); <br>    FREEHKEY(hkTmp); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetRegistryString----------------------------------------------------- <br>//  Get a string value from the registry. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrGetRegistryString(  // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    IN  LPSTR  lpszServicePath,        // service path <br>    IN  LPSTR  lpszValueName,          // registry value name <br>    IN  DWORD   dwExpectedType,         // expected registry data type <br>    OUT LPSTR  *lppszString)           // string <br>{ <br>    HRESULT hr                           = NOERROR; <br>    LONG    lRet                         = 0; <br>DWORD   dwType                       = 0; <br>DWORD   cbOrig                       = 0; <br>CHAR    szKey[MAX_PATH+1]            = {0}; <br>HKEY    hKey                         = INVALID_HANDLE_VALUE; <br> <br>    DEBUGPUBLIC("HrGetRegistryString()"); <br> <br>    hr = CHK_HrGetRegistryString( <br>lpszServiceName, <br>lpszServicePath, <br>lpszValueName, <br>dwExpectedType, <br>lppszString); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // <br>    //  Open the key. <br>    // <br> <br>lRet = _snprintf( <br>    szKey, <br>MAX_PATH+1, <br>    lpszServicePath, <br>    lpszServiceName); <br> <br>    if(lRet &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    lRet = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE, <br>szKey,  <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hKey); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    hr = HrGetRegistryValue( <br>hKey, lpszValueName, &amp;dwType, &amp;cbOrig, (LPVOID)lppszString); <br> <br>    if(FAILED(hr) || dwType != dwExpectedType) <br>    { <br>if(dwType != dwExpectedType) <br>    hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>FREEHKEY(hKey); <br> <br>    if(FAILED(hr)) <br>    { <br>GLOBALFREE(*lppszString); <br>    } <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceServerName-------------------------------------------------- <br>//  Get the Exchange server name associated with the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceServerName(      // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    OUT LPSTR  *lppszServerName)       // server name <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrGetServiceServerName()"); <br> <br>    hr = CHK_HrGetServiceServerName( <br>lpszServiceName, <br>lppszServerName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrGetRegistryString( <br>lpszServiceName, <br>"SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters", <br>"HomeDSA", <br>REG_SZ, <br>lppszServerName); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceSiteDN------------------------------------------------------ <br>//  Get the site DN of the Exchange object associated with the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceSiteDN(          // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    OUT LPSTR  *lppszSiteDN)           // site distinguished name <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrGetServiceSiteDN()"); <br> <br>    hr = CHK_HrGetServiceSiteDN( <br>lpszServiceName, <br>lppszSiteDN); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrGetRegistryString( <br>lpszServiceName, <br>"SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters", <br>"SiteDN", <br>REG_SZ, <br>lppszSiteDN); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceCommonName-------------------------------------------------- <br>//  Get the common name of the Exchange object associated with the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceCommonName(      // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    OUT LPSTR  *lppszCommonName)       // object relative distinguished name <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrGetServiceCommonName()"); <br> <br>    hr = CHK_HrGetServiceCommonName( <br>lpszServiceName, <br>lppszCommonName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrGetRegistryString( <br>lpszServiceName, <br>"SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters", <br>"CommonName", <br>REG_SZ, <br>lppszCommonName); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceObjectGUID-------------------------------------------------- <br>//  Get the object GUID associated with the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceObjectGUID(      // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    OUT LPSTR  *lppszObjectGUID)       // object GUID <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrGetServiceObjectGUID()"); <br> <br>    hr = CHK_HrGetServiceObjectGUID( <br>lpszServiceName, <br>lppszObjectGUID); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrGetRegistryString( <br>lpszServiceName, <br>"SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters", <br>"ObjectGUID", <br>REG_SZ, <br>lppszObjectGUID); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceProductGUID------------------------------------------------- <br>//  Get the product GUID associated with the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceProductGUID(     // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    OUT LPSTR  *lppszProductGUID)      // product GUID <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrGetServiceProductGUID()"); <br> <br>    hr = CHK_HrGetServiceProductGUID( <br>lpszServiceName, <br>lppszProductGUID); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrGetRegistryString( <br>lpszServiceName, <br>"SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters", <br>"ProductGUID", <br>REG_SZ, <br>lppszProductGUID); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceDisplayName------------------------------------------------- <br>//  Get the display name associated with the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceDisplayName(     // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    OUT LPSTR  *lppszDisplayName)      // display name <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrGetServiceDisplayName()"); <br> <br>    hr = CHK_HrGetServiceDisplayName( <br>lpszServiceName, <br>lppszDisplayName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrGetRegistryString( <br>lpszServiceName, <br>"SYSTEM\\CurrentControlSet\\Services\\%s", <br>"DisplayName", <br>REG_SZ, <br>lppszDisplayName); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceExecutableName---------------------------------------------- <br>//  Get the executable name associated with the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceExecutableName(  // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    OUT LPSTR  *lppszExecutableName)   // executable name <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrGetServiceExecutableName()"); <br> <br>    hr = CHK_HrGetServiceExecutableName( <br>lpszServiceName, <br>lppszExecutableName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrGetRegistryString( <br>lpszServiceName, <br>"SYSTEM\\CurrentControlSet\\Services\\%s", <br>"ImagePath", <br>REG_EXPAND_SZ, <br>lppszExecutableName); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetServiceAccountName------------------------------------------------- <br>//  Get the account name associated with the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetServiceAccountName(     // RETURNS: return code <br>    IN  LPSTR  lpszServiceName,        // service name <br>    OUT LPSTR  *lppszAccountName)      // account name <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrGetServiceAccountName()"); <br> <br>    hr = CHK_HrGetServiceAccountName( <br>lpszServiceName, <br>lppszAccountName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrGetRegistryString( <br>lpszServiceName, <br>"SYSTEM\\CurrentControlSet\\Services\\%s", <br>"ObjectName", <br>REG_SZ, <br>lppszAccountName); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveService--------------------------------------------------------- <br>//  Removes a service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveService(             // RETURNS: return code <br>    IN LPCSTR lpszServiceName)         // service name <br>{ <br>    HRESULT   hr           = NOERROR; <br>    SC_HANDLE schService   = NULL; <br>    SC_HANDLE schSCManager = NULL; <br>    BOOL      fStatus      = FALSE; <br> <br>    DEBUGPUBLIC("HrRemoveService()\n"); <br> <br>    hr = CHK_HrRemoveService( <br>lpszServiceName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    schSCManager = OpenSCManager( <br>NULL, <br>NULL, <br>SC_MANAGER_ALL_ACCESS); <br> <br>    if(schSCManager == NULL) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    schService = OpenService(schSCManager, lpszServiceName, SERVICE_ALL_ACCESS); <br> <br>    if(schService == NULL)  <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    fStatus = DeleteService(schService); <br> <br>    if(fStatus == FALSE)  <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br>     <br>cleanup: <br> <br>    FREEHSCM(schService); <br>    FREEHSCM(schSCManager); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrNameContained------------------------------------------------------------ <br>// Determine if the name is in the list. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrNameContained( // RETURNS: return code <br>    IN LPSTR lpszName,         // name to find <br>    IN LPSTR lpszList,         // list to search <br>    IN DWORD cbListLen)         // max length to search <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("HrNameContained()\n"); <br> <br>    hr = CHK_HrNameContained( <br>lpszName, <br>lpszList, <br>cbListLen); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = EDK_E_NOT_FOUND; <br> <br>    while(*lpszList) <br>    { <br>// does it match? <br>if(!lstrcmpi(lpszName, lpszList)) <br>{ <br>    hr = NOERROR; <br>    break; <br>} <br> <br>// go to next element    <br>lpszList += sizeof(CHAR)*(1+lstrlen(lpszList)); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrEDKAddServiceToLinkage--------------------------------------------------- <br>//  Add service name to the export value in the key. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrEDKAddServiceToLinkage(// RETURNS: return code <br>    IN HKEY hkLinkage,                  // key containing export list. <br>    IN LPSTR lpszServiceName)          // service name. <br>{ <br>    HRESULT hr            = E_FAIL; <br>    HRESULT hrT           = NOERROR; <br>    LONG    lRet          = 0; <br>    DWORD   dwType        = 0; <br>    DWORD   cbOrig        = 0; <br>    DWORD   cbServiceName = 0; <br>    LPBYTE  lpOrig        = NULL; <br>    LPBYTE  lpRes         = NULL; <br> <br>    DEBUGPRIVATE("HrEDKAddServiceToLinkage()\n"); <br> <br>    hr = CHK_HrEDKAddServiceToLinkage( <br>hkLinkage, <br>lpszServiceName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // <br>    // How big is the current value? <br>    // <br> <br>    hrT = HrGetRegistryValue(hkLinkage, szExport, &amp;dwType, &amp;cbOrig, &amp;lpOrig); <br> <br>    if(SUCCEEDED(hrT)) <br>    { <br>ASSERTERROR(lpOrig != NULL, "NULL lpOrig variable"); <br> <br>// If the name is already there, don't add it again. <br> <br>// has value, make sure it is the right type. <br>if(dwType != REG_MULTI_SZ) <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>hrT = HrNameContained(lpszServiceName, (LPSTR)lpOrig, cbOrig); <br> <br>if(SUCCEEDED(hrT)) <br>{ <br>    hr = NOERROR; <br>    goto cleanup; <br>} <br>    } <br>    else <br>    { <br>// Assume that there is no initial value, so leave space <br>// for a double-null terminator. <br>cbOrig = 1; <br>    } <br> <br>    // Allocate space for the result. <br> <br>    cbServiceName = cbStrLen(lpszServiceName); <br> <br>    lpRes = GlobalAlloc(GMEM_FIXED, cbServiceName + cbOrig); <br> <br>    if(lpRes == NULL) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // put out new name in and put in extra null in case orig value was empty <br>    lstrcpy(lpRes, lpszServiceName); <br> <br>    // put in the rest of the name if it exists <br>    if(lpOrig != NULL) <br>    { <br>CopyMemory(((LPSTR)lpRes)+cbServiceName, lpOrig, cbOrig); <br>    } <br>    else <br>    { <br>*((LPSTR)(lpRes+cbServiceName)) = 0; <br>    } <br> <br>    // Now, write the result. <br>    lRet = RegSetValueEx( <br>hkLinkage, <br>szExport, <br>0,  <br>REG_MULTI_SZ, <br>lpRes, <br>cbServiceName + cbOrig); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = NOERROR; <br> <br>cleanup: <br> <br>    GLOBALFREE(lpOrig); <br>    GLOBALFREE(lpRes); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallServicePerfMon------------------------------------------------- <br>//  Installs service performance monitoring. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallServicePerfMon(         // RETURNS: return code <br>    IN LPSTR lpszServiceName,              // service name <br>    IN LPSTR lpszClassName,                // class name <br>    IN LPSTR lpszLibraryName,              // library name <br>    IN LPSTR lpszLibraryOpenFunction,      // open function <br>    IN LPSTR lpszLibraryCollectFunction,   // collect function <br>    IN LPSTR lpszLibraryCloseFunction)     // close function <br>{ <br>    HRESULT hr             = E_FAIL; <br>    LONG    lRet           = 0; <br> <br>    HKEY    hkServices     = INVALID_HANDLE_VALUE; <br> <br>    HKEY    hkServiceClass = INVALID_HANDLE_VALUE; </code></pre>
<p>
</p>
<pre><code>HKEY    hkLinkage      = INVALID_HANDLE_VALUE; <br>    HKEY    hkPerformance  = INVALID_HANDLE_VALUE; <br> <br>    HKEY    hkServiceName  = INVALID_HANDLE_VALUE; <br>    HKEY    hkLinkage2     = INVALID_HANDLE_VALUE; <br>    HKEY    hkParameters   = INVALID_HANDLE_VALUE; <br> <br>    DWORD   dwDisposition  = 0; <br> <br>    DEBUGPUBLIC("HrInstallServicePerfMon()\n"); <br> <br>    hr = CHK_HrInstallServicePerfMon( <br>lpszServiceName, <br>lpszClassName, <br>lpszLibraryName, <br>lpszLibraryOpenFunction, <br>lpszLibraryCollectFunction, <br>lpszLibraryCloseFunction); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // <br>    //  Open the general services key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE, <br>"SYSTEM\\CurrentControlSet\\Services",  <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hkServices); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open or create the class key. <br>    // <br>    lRet = CREATEKEY(hkServices, lpszClassName, hkServiceClass, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open or create the linkage key <br>    // <br>    lRet = CREATEKEY(hkServiceClass, "Linkage", hkLinkage, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open or create the performance key <br>    // <br>    lRet = CREATEKEY(hkServiceClass, "Performance", hkPerformance, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    // setup performance data. <br>    // <br>    lRet = SETSZVALUE(hkPerformance, "Library", lpszLibraryName); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    lRet = SETSZVALUE(hkPerformance, "Open", lpszLibraryOpenFunction); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    lRet = SETSZVALUE(hkPerformance, "Collect", lpszLibraryCollectFunction); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    lRet = SETSZVALUE(hkPerformance, "Close", lpszLibraryCloseFunction); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    // Link the service name into the Export list. <br>    // <br> <br>    hr = HrEDKAddServiceToLinkage(hkLinkage, lpszServiceName); <br> <br>    if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open or create the service key. <br>    // <br> <br>    lRet = CREATEKEY(hkServices, lpszServiceName, hkServiceName, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open or create the linkage key <br>    // <br> <br>    lRet = CREATEKEY(hkServiceName, "Linkage", hkLinkage2, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open or create the performance key <br>    // <br> <br>    lRet = CREATEKEY(hkServiceName, "Parameters", hkParameters, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    // Setup parameters data <br>    // <br> <br>    lRet = SETSZVALUE(hkParameters, "ObjectClass", lpszClassName); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    FREEHKEY(hkLinkage); <br>    FREEHKEY(hkPerformance); <br>    FREEHKEY(hkServiceClass); <br> <br>    FREEHKEY(hkLinkage2); <br>    FREEHKEY(hkParameters); <br>    FREEHKEY(hkServiceName); <br> <br>    FREEHKEY(hkServices); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>// $--HrDeleteContainedKeysInternal--------------------------------------------- <br>//  recursive delete keys.  Is passed in lpszwName for storage. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDeleteContainedKeysInternal(   // RETURNS: return code <br>    IN HKEY hKey,                               // registry key handle <br>    IN LPWSTR lpszwName)                        // temporary storage <br>{ <br>#define cchName 255 <br>    HRESULT hr           = NOERROR; <br>    DWORD   dwEnumResult = !ERROR_NO_MORE_ITEMS; <br>    HKEY    hSubKey      = NULL; <br> <br>    DEBUGPRIVATE("HrDeleteContainedKeysInternal()\n"); <br> <br>    hr = CHK_HrDeleteContainedKeysInternal( <br>hKey, <br>lpszwName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // <br>    // Enumerate each sub key and delete it recursively. Temporary memory <br>    // for the sub-key name is allocated and freed before and after the  <br>    // recursive call but not during to prevent a recursive storage <br>    // build up. <br>    // <br> <br>    do  <br>    { <br>DWORD    dwResult = 0; <br>DWORD    cbSubKey = cchName; <br>FILETIME ftDummy  = {0}; <br> <br>// <br>// Get the name of the next remaining sub-key. <br>// <br> <br>dwEnumResult = RegEnumKeyExW( <br>    hKey, 0, lpszwName, &amp;cbSubKey, NULL, NULL, NULL, &amp;ftDummy); <br> <br>if(dwEnumResult == ERROR_SUCCESS) <br>{ <br>    // <br>    // Convert the name of the sub-key into an open handle.  <br>    // Dispose of the name. <br>    // <br> <br>    dwResult = RegOpenKeyExW( <br>hKey, lpszwName, 0, KEY_ALL_ACCESS, &amp;hSubKey); <br> <br>    if(dwResult == ERROR_SUCCESS) <br>    { <br>// <br>// Recursively call delete with this sub-key handle. <br>// <br> <br>hr = HrDeleteContainedKeysInternal(hSubKey, lpszwName); <br> <br>if(FAILED(hr)) <br>{ <br>    goto cleanup; <br>} <br> <br>FREEHKEY(hSubKey);                   <br> <br>// <br>// Get the name of the sub-key again <br>// <br> <br>cbSubKey = cchName; <br> <br>dwEnumResult = RegEnumKeyExW( <br>    hKey, 0, lpszwName, &amp;cbSubKey, NULL, NULL, NULL, &amp;ftDummy); <br> <br>if(dwEnumResult != ERROR_SUCCESS) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(dwEnumResult)); <br>    goto cleanup;     <br>} <br> <br>dwResult = RegDeleteKeyW(hKey, lpszwName); <br> <br>if(dwResult != ERROR_SUCCESS) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(dwResult)); <br>    goto cleanup;     <br>} <br>    } <br>    else <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(dwResult)); <br>goto cleanup;     <br>    } <br> <br>    FREEHKEY(hSubKey);                   <br>} <br>else if(dwEnumResult != ERROR_NO_MORE_ITEMS) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(dwEnumResult)); <br>    goto cleanup;     <br>} <br>    } while (dwEnumResult != ERROR_NO_MORE_ITEMS); // do <br> <br>cleanup: <br> <br>    FREEHKEY(hSubKey); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrDeleteContainedKeys------------------------------------------------------ <br>//  The recursive component of delete key. Each invocation of this function <br>//  will enumerate the subkeys of a key and delete them one by one <br>//  recursively. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDeleteContainedKeys(       // RETURNS: return code <br>    IN HKEY hKey)                           // registry key handle <br>{ <br>    HRESULT hr                = NOERROR; <br>    WCHAR   rgchName[cchName] = {0}; <br> <br>    DEBUGPRIVATE("HrDeleteContainedKeys()"); <br> <br>    hr = CHK_HrDeleteContainedKeys( <br>hKey); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    hr = HrDeleteContainedKeysInternal(hKey, rgchName); <br> <br>    RETURN(hr); <br> <br>#undef  cchName <br>} <br> <br>//$--HrRemoveRegistry----------------------------------------------------------- <br>//  Remove the registry for the service. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveRegistry(              // RETURNS: nothing <br>    IN LPCSTR lpszServiceName)         // service name <br>{ <br>    HRESULT hr         = NOERROR; <br>    LONG    lRet       = 0; <br>    HKEY    hkServices = INVALID_HANDLE_VALUE; <br>    HKEY    hkSvc      = INVALID_HANDLE_VALUE; <br> <br>    DEBUGPUBLIC("HrRemoveRegistry()"); <br> <br>    hr = CHK_HrEDKRemoveRegistry( <br>lpszServiceName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // <br>    //  Open the services key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE, <br>"SYSTEM\\CurrentControlSet\\Services",  <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hkServices); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open the service key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>hkServices, <br>lpszServiceName, <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hkSvc); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    hr = HrDeleteContainedKeys(hkSvc); <br> <br>    if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>    lRet = RegDeleteKey(hkServices, lpszServiceName); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    FREEHKEY(hkSvc); <br>    FREEHKEY(hkServices); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveName--------------------------------------------------------------- <br>//  Remove the service name from the export list and signal if we're now empty <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrRemoveName(        // RETURNS: return code <br>    IN HKEY hkLinkage,              // key containing export <br>    IN LPSTR lpszServiceName,      // service name <br>    OUT BOOL * pfEmpty)             // flag to indicate its empty. <br>{ <br>    LONG    lRet     = 0; <br>    HRESULT hr       = E_FAIL; <br>    HRESULT hrT      = NOERROR; <br>    BOOL    fChanged = FALSE; <br>    BOOL    fEmpty   = TRUE; <br>    DWORD   dwType   = 0; <br>    DWORD   cbOrig   = 0; <br>    LPVOID  pOrig    = NULL; <br>    LPVOID  pNew     = NULL; <br>    DWORD   cbNew    = 0; <br>    LPSTR  lpszOrig  = NULL; <br>    LPSTR  lpszNew   = NULL; <br> <br>    DEBUGPRIVATE("HrRemoveName()\n"); <br> <br>    hr = CHK_HrRemoveName( <br>hkLinkage, <br>lpszServiceName, <br>pfEmpty); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // <br>    //  Get the current value. <br>    // <br> <br>    hrT = HrGetRegistryValue(hkLinkage, szExport, &amp;dwType, &amp;cbOrig, &amp;pOrig); <br> <br>    if(FAILED(hrT) || dwType != REG_MULTI_SZ) <br>    { <br>if(dwType != REG_MULTI_SZ) <br>    hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Allocate a buffer big enough to hold a copy. <br>    // <br> <br>    pNew = GlobalAlloc(GMEM_FIXED, cbOrig); <br> <br>    if(pNew == NULL) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    lpszOrig = (LPSTR)pOrig; <br>    lpszNew = (LPSTR)pNew; <br> <br>    // <br>    //  Loop through the source. <br>    // <br> <br>    while(*lpszOrig) <br>    { <br>int cchNameLen = strlen(lpszOrig) + 1;   <br> <br>if(!_strcmpi(lpszOrig, lpszServiceName)) <br>{ <br>    // found an instance. <br>    fChanged = TRUE; <br>} <br>else <br>{ <br>    lstrcpy(lpszNew, lpszOrig); <br> <br>    lpszNew += cchNameLen; <br>    cbNew += sizeof(CHAR) * cchNameLen; <br> <br>    fEmpty = FALSE; <br>} <br> <br>lpszOrig += cchNameLen; <br>    } <br> <br>    // <br>    // Add final NULL <br>    // <br> <br>    *lpszNew = 0; <br>    cbNew += sizeof(CHAR); <br> <br>    if(fChanged) <br>    { <br>// <br>//  If it has changed, write it back. <br>// <br> <br>lRet = RegSetValueEx(hkLinkage, szExport, 0, REG_MULTI_SZ, pNew, cbNew); <br> <br>if(lRet != ERROR_SUCCESS) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>    goto cleanup; <br>} <br>    } <br> <br>    hr = NOERROR; <br> <br>    *pfEmpty = fEmpty; <br> <br>cleanup: <br> <br>    GLOBALFREE(pOrig); <br>    GLOBALFREE(pNew); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveServicePerfMon-------------------------------------------------- <br>//  Removes service performance monitoring. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveServicePerfMon(          // RETURNS: return code <br>    IN  LPSTR lpszServiceName,             // service name <br>    IN  LPSTR lpszClassName,               // class name <br>    OUT BOOL   *lpfUnloadCounters)          // unload counters? <br>{ <br>    HRESULT hr             = E_FAIL; <br>    LONG    lRet           = 0; <br>    BOOL    bEmpty         = FALSE; <br>    HKEY    hkServices     = INVALID_HANDLE_VALUE; <br>    HKEY    hkServiceClass = INVALID_HANDLE_VALUE; <br>    HKEY    hkLinkage      = INVALID_HANDLE_VALUE; <br>    DWORD   dwDisposition  = 0; <br> <br>    DEBUGPUBLIC("HrRemoveServicePerfMon()\n"); <br> <br>    hr = CHK_HrRemoveServicePerfMon( <br>lpszServiceName, <br>lpszClassName, <br>lpfUnloadCounters); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    *lpfUnloadCounters = FALSE; <br> <br>    // <br>    //  Open the general services key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE, <br>"SYSTEM\\CurrentControlSet\\Services",  <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hkServices); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open or create the class key. <br>    // <br> <br>    lRet = CREATEKEY(hkServices, lpszClassName, hkServiceClass, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open or create the linkage key <br>    // <br> <br>    lRet = CREATEKEY(hkServiceClass, "Linkage", hkLinkage, dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Remove the name. <br>    // <br> <br>    hr = HrRemoveName(hkLinkage, lpszServiceName, &amp;bEmpty); <br> <br>    if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    FREEHKEY(hkLinkage); <br> <br>    if(SUCCEEDED(hr) &amp;&amp; bEmpty) <br>    { <br>*lpfUnloadCounters = TRUE; <br>    } <br> <br>    FREEHKEY(hkServiceClass); <br>    FREEHKEY(hkServices); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallGateway-------------------------------------------------------- <br>// Installs a gateway into a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallGateway(        // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszDisplayName,      // display name <br>    IN LPSTR lpszCommonName,       // common name <br>    IN LPSTR lpszExtensionName,    // admin extension name <br>    IN LPSTR lpszExtensionData,    // extension data file <br>    IN LPSTR lpszAddressType,      // address type handled by this gateway <br>    IN LPSTR lpszAccountName,      // account name <br>    IN BOOL   fCanPreserveDNs)      // can this gateway preserve DNs? <br>{ <br>    HRESULT hr                                          = NOERROR; <br>    CHAR   szTmpBuf[MAX_CSV_LINE_SIZ]                  = {0}; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]               = {0}; <br>    CHAR   szHomeServer[MAX_CSV_LINE_SIZ]              = {0}; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szAttributeValues[MAX_CSV_LINE_SIZ]         = {0}; <br>    CHAR   lpszComputerName[MAX_COMPUTERNAME_LENGTH+1] = {0}; <br>    DWORD   cbComputerName                              = MAX_COMPUTERNAME_LENGTH+1; <br>    INT     cBytes                                      = 0; <br> <br>    DEBUGPUBLIC("HrInstallGateway()"); <br> <br>    hr = CHK_HrInstallGateway( <br>lpszServer, <br>lpszSiteDN, <br>lpszDisplayName, <br>lpszCommonName, <br>lpszExtensionName, <br>lpszExtensionData, <br>lpszAddressType, <br>lpszAccountName, <br>fCanPreserveDNs); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_GW); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    cBytes = _snprintf( <br>szHomeServer, <br>MAX_CSV_LINE_SIZ, <br>"%s%s/cn=%s", <br>lpszSiteDN, <br>CONTAINER_SERVERS, <br>lpszServer); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , OBJ_CLASS_GW); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_CREATE); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszCommonName); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, ADMIN_DISPLAY_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszDisplayName); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, DELIVERY_MECHANISM); <br>    APPEND_CSV_LINE (szAttributeValues , DELIVERY_MECHANISM_GW); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, DELIV_EXT_CONT_TYPES); <br>    APPEND_CSV_LINE (szAttributeValues , "2A864886F7140501"); <br> <br>    if((lpszExtensionData != NULL) &amp;&amp; (lstrlen(lpszExtensionData) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, EXTENSION_DATA); <br>sprintf(szTmpBuf, "=%s", lpszExtensionData); <br>APPEND_CSV_LINE (szAttributeValues , szTmpBuf);  <br>    } <br> <br>    if((lpszExtensionName != NULL) &amp;&amp; (lstrlen(lpszExtensionName) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, EXTENSION_NAME); <br>APPEND_CSV_LINE (szAttributeValues , lpszExtensionName); <br>    } <br> <br>    APPEND_CSV_LINE (szObjectAttributes, COMPUTER_NAME); <br>    GetComputerName((LPSTR)lpszComputerName, &amp;cbComputerName); <br>    APPEND_CSV_LINE (szAttributeValues , lpszComputerName);  <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, HOME_SERVER); <br> <br>    APPEND_CSV_LINE (szAttributeValues , szHomeServer);  <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, ROUTING_LIST); <br>    sprintf(szTmpBuf, "%s:*;1", lpszAddressType); <br>    APPEND_CSV_LINE (szAttributeValues , szTmpBuf);  <br>     <br>    if((lpszAccountName != NULL) &amp;&amp; (lstrlen(lpszAccountName) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, ACCOUNT_NAME); <br>APPEND_CSV_LINE (szAttributeValues , lpszAccountName); <br>    } <br> <br>    if(fCanPreserveDNs == TRUE) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, CAN_PRESERVE_DNS); <br>sprintf(szTmpBuf, "1"); <br>APPEND_CSV_LINE (szAttributeValues , szTmpBuf); <br>    } <br>    else <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, CAN_PRESERVE_DNS); <br>sprintf(szTmpBuf, "0"); <br>APPEND_CSV_LINE (szAttributeValues , szTmpBuf); <br>    } <br> <br>    hr = HR_LOG(HrEDKImportObject( <br>lpszServer, <br>szBasePoint, <br>szObjectAttributes, <br>szAttributeValues)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveGateway--------------------------------------------------------- <br>//  Removes a gateway from a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveGateway(         // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszCommonName)       // common name <br>{ <br>    HRESULT hr                            = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                        = 0; <br> <br>    DEBUGPUBLIC("HrRemoveGateway()"); <br> <br>    hr = CHK_HrRemoveGateway( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_GW); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br>     <br>    hr = HR_LOG(HrDeleteObject( <br>lpszServer, <br>szBasePoint, <br>lpszCommonName, <br>OBJ_CLASS_GW)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGatewayExists--------------------------------------------------------- <br>//  Checks if a gateway exists on a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGatewayExists(         // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszCommonName)       // common name <br>{ <br>    HRESULT hr                            = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                        = 0; <br> <br>    DEBUGPUBLIC("HrGatewayExists()"); <br> <br>    hr = CHK_HrGatewayExists( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_GW); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrEDKObjectExists( <br>lpszServer, <br>szBasePoint, <br>OBJ_CLASS_GW, <br>lpszCommonName); <br> <br>    if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallMailboxAgent--------------------------------------------------- <br>//  Installs a mailbox agent into a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallMailboxAgent(   // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszDisplayName,      // display name <br>    IN LPSTR lpszRDN,              // relative distinguished name <br>    IN LPSTR lpszExtensionName,    // admin extension name <br>    IN LPSTR lpszExtensionData,    // extension data file <br>    IN LPSTR lpszAccountName)      // account name <br>{ <br>    HRESULT hr                                           = NOERROR; <br>    CHAR   szTempBuffer[MAX_CSV_LINE_SIZ]               = {0}; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]                = {0}; <br>    CHAR   szHomeServer[MAX_CSV_LINE_SIZ]               = {0}; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ]         = {0}; <br>    CHAR   szAttributeValues[MAX_CSV_LINE_SIZ]          = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ]               = {0}; <br>    CHAR   lpszComputerName[MAX_COMPUTERNAME_LENGTH+1]  = {0}; <br>    DWORD   cbComputerName                               = MAX_COMPUTERNAME_LENGTH+1; <br>    INT     cBytes                                       = 0; <br>    LPSTR  lpsz                                         = NULL; <br>    LPSTR  lpszT                                        = NULL; <br>    LPSTR  lpszCommonName                               = NULL; <br>    BOOL    IsFound                                      = FALSE; <br> <br>    DEBUGPUBLIC("HrInstallMailboxAgent()"); <br> <br>    hr = CHK_HrInstallMailboxAgent( <br>lpszServer, <br>lpszSiteDN, <br>lpszDisplayName, <br>lpszRDN, <br>lpszExtensionName, <br>lpszExtensionData, <br>lpszAccountName); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szHomeServer, <br>MAX_CSV_LINE_SIZ, <br>"%s%s/cn=%s", <br>lpszSiteDN, <br>CONTAINER_SERVERS, <br>lpszServer); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    IsFound = FALSE; <br> <br>    lpsz = lpszRDN + lstrlen(lpszRDN); <br> <br>    while(lpsz != lpszRDN) <br>    { <br>lpsz--; <br> <br>if(*lpsz == '/') <br>{ <br>    IsFound = TRUE; <br>    break; <br>} <br>    } <br> <br>    if(IsFound == FALSE) <br>    { <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>    } <br> <br>    lpszCommonName = lpsz + sizeof("cn="); <br> <br>    lstrcpy(szCommonName, lpszCommonName); <br> <br>    lstrcpy(szBasePoint, lpszSiteDN); <br>    lstrcpyn(szBasePoint + lstrlen(szBasePoint), lpszRDN, lpsz - lpszRDN + 1); <br> <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , OBJ_CLASS_MB); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_CREATE); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , szCommonName); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, DISPLAY_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszDisplayName); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, DELIVERY_MECHANISM); <br>    APPEND_CSV_LINE (szAttributeValues , DELIVERY_MECHANISM_MB); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, DELIV_EXT_CONT_TYPES); <br>    APPEND_CSV_LINE (szAttributeValues , "2A864886F7140501"); <br> <br>    if((lpszExtensionData != NULL) &amp;&amp; (lstrlen(lpszExtensionData) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, EXTENSION_DATA); <br>sprintf(szTempBuffer, "=%s", lpszExtensionData); <br>APPEND_CSV_LINE (szAttributeValues , szTempBuffer);  <br>    } <br> <br>    if((lpszExtensionName != NULL) &amp;&amp; (lstrlen(lpszExtensionName) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, EXTENSION_NAME); <br>APPEND_CSV_LINE (szAttributeValues , lpszExtensionName); <br>    } <br> <br>    APPEND_CSV_LINE (szObjectAttributes, COMPUTER_NAME); <br>    GetComputerName((LPSTR)lpszComputerName, &amp;cbComputerName); <br>    APPEND_CSV_LINE (szAttributeValues , lpszComputerName);  <br> <br>    if((lpszAccountName != NULL) &amp;&amp; (lstrlen(lpszAccountName) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, ACCOUNT_NAME); <br>APPEND_CSV_LINE (szAttributeValues , lpszAccountName); <br>    } <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, HOME_SERVER); <br> <br>    APPEND_CSV_LINE (szAttributeValues , szHomeServer); <br>     <br>    hr = HR_LOG(HrEDKImportObject( <br>lpszServer, <br>szBasePoint, <br>szObjectAttributes, <br>szAttributeValues)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveMailboxAgent---------------------------------------------------- <br>// Removes a mailbox agent from a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveMailboxAgent(    // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszRDN)              // relative distinguished name <br>{ <br>    HRESULT hr                             = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ] = {0}; <br>    LPSTR  lpsz                           = NULL; <br>    LPSTR  lpszT                          = NULL; <br>    LPSTR  lpszCommonName                 = NULL; <br>    BOOL    IsFound                        = FALSE; <br> <br>    DEBUGPUBLIC("HrRemoveMailboxAgent()"); <br> <br>    hr = CHK_HrRemoveMailboxAgent( <br>lpszServer, <br>lpszSiteDN, <br>lpszRDN); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    IsFound = FALSE; <br> <br>    lpsz = lpszRDN + lstrlenA(lpszRDN); <br> <br>    while(lpsz != lpszRDN) <br>    { <br>lpsz--; <br> <br>if(*lpsz == '/') <br>{ <br>    IsFound = TRUE; <br>    break; <br>} <br>    } <br> <br>    if(IsFound == FALSE) <br>    { <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>    } <br> <br>    lpszCommonName = lpsz + sizeof("cn="); <br> <br>    lstrcpy(szCommonName, lpszCommonName); <br> <br>    lstrcpy(szBasePoint, lpszSiteDN); <br>    lstrcpyn(szBasePoint + lstrlen(szBasePoint), lpszRDN, lpsz - lpszRDN + 1); <br>     <br>    hr = HR_LOG(HrDeleteObject( <br>lpszServer, <br>szBasePoint, <br>szCommonName, <br>OBJ_CLASS_MB)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMailboxAgentExists---------------------------------------------------- <br>//  Checks if a mailbox agent exists on a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMailboxAgentExists(    // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszRDN)              // relative distinguished name <br>{ <br>    HRESULT hr                             = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ] = {0}; <br>    LPSTR  lpsz                           = NULL; <br>    LPSTR  lpszT                          = NULL; <br>    LPSTR  lpszCommonName                 = NULL; <br>    BOOL    IsFound                        = FALSE; <br> <br>    DEBUGPUBLIC("HrMailboxAgentExists()"); <br> <br>    hr = CHK_HrMailboxAgentExists( <br>lpszServer, <br>lpszSiteDN, <br>lpszRDN); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    IsFound = FALSE; <br> <br>    lpsz = lpszRDN + lstrlen(lpszRDN); <br> <br>    while(lpsz != lpszRDN) <br>    { <br>lpsz--; <br> <br>if(*lpsz == '/') <br>{ <br>    IsFound = TRUE; <br>    break; <br>} <br>    } <br> <br>    if(IsFound == FALSE) <br>    { <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>    } <br> <br>    lpszCommonName = lpsz + sizeof("cn="); <br> <br>    lstrcpy(szCommonName, lpszCommonName); <br> <br>    lstrcpy(szBasePoint, lpszSiteDN); <br>    lstrcpyn(szBasePoint + lstrlen(szBasePoint), lpszRDN, lpsz - lpszRDN + 1); <br> <br>    hr = HrEDKObjectExists( <br>lpszServer, <br>szBasePoint, <br>OBJ_CLASS_MB, <br>szCommonName); <br> <br>    if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallAddressType---------------------------------------------------- <br>//  Installs an address type object into a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallAddressType(    // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszDisplayName,      // display name <br>    IN LPSTR lpszCommonName,       // common name <br>    IN DWORD  dwFileVersionMS,      // high-order 32 bits of file version number <br>    IN DWORD  dwFileVersionLS,      // low-order 32 bits of file version number <br>    IN LPSTR lpszProxyGenDLL,      // proxy generator DLL file name <br>    IN LPSTR lpszMachineType)      // machine type (e.g. "i386") </code></pre>
<p>
</p>
<pre><code>{ <br>    HRESULT hr                                   = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ]       = {0}; <br>    CHAR   szFileVersion[MAX_CSV_LINE_SIZ]      = {0}; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues [MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                               = 0; <br>    WORD    wver[4]                              = {0}; <br>    BYTE    bver[8]                              = {0}; <br> <br>    DEBUGPUBLIC("HrInstallAddressType()"); <br> <br>    hr = CHK_HrInstallAddressType( <br>lpszServer, <br>lpszSiteDN, <br>lpszDisplayName, <br>lpszCommonName, <br>dwFileVersionMS, <br>dwFileVersionLS, <br>lpszProxyGenDLL, <br>lpszMachineType); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_ADDR_TYPE); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    cBytes = _snprintf( <br>szCommonName, <br>MAX_CSV_LINE_SIZ, <br>"%s:%s", <br>lpszCommonName, <br>lpszMachineType); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    wver[0] = LOWORD(dwFileVersionLS); <br>    wver[1] = HIWORD(dwFileVersionLS); <br>    wver[2] = LOWORD(dwFileVersionMS); <br>    wver[3] = HIWORD(dwFileVersionMS); <br> <br>    bver[0] = LOBYTE(wver[0]); <br>    bver[1] = HIBYTE(wver[0]); <br>    bver[2] = LOBYTE(wver[1]); <br>    bver[3] = HIBYTE(wver[1]); <br>    bver[4] = LOBYTE(wver[2]); <br>    bver[5] = HIBYTE(wver[2]); <br>    bver[6] = LOBYTE(wver[3]); <br>    bver[7] = HIBYTE(wver[3]); <br> <br>    cBytes = _snprintf( <br>szFileVersion, <br>MAX_CSV_LINE_SIZ, <br>"%02x%02x%02x%02x%02x%02x%02x%02x", <br>bver[0], bver[1], bver[2], bver[3], <br>bver[4], bver[5], bver[6], bver[7]); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , OBJ_CLASS_ADDR_TYPE); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_CREATE); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, ADMIN_DISPLAY_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszDisplayName); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, ADDR_TYPE); <br>    APPEND_CSV_LINE (szAttributeValues , lpszCommonName); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br> <br>    APPEND_CSV_LINE (szAttributeValues , szCommonName); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, PROXY_GENERATOR_DLL); <br>    APPEND_CSV_LINE (szAttributeValues , lpszProxyGenDLL); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, FILE_VERSION); <br>    APPEND_CSV_LINE (szAttributeValues , szFileVersion); <br>     <br>    hr = HR_LOG(HrEDKImportObject( <br>lpszServer, <br>szBasePoint, <br>szObjectAttributes, <br>szAttributeValues)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveAddressType----------------------------------------------------- <br>//  Removes an address type from a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveAddressType(     // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszCommonName,       // common name <br>    IN LPSTR lpszMachineType)      // machine type (e.g. "i386") <br>{ <br>    HRESULT hr                             = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                         = 0; <br> <br>    DEBUGPUBLIC("HrRemoveAddressType()"); <br> <br>    hr = CHK_HrRemoveAddressType( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName, <br>lpszMachineType); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_ADDR_TYPE); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    cBytes = _snprintf( <br>szCommonName, <br>MAX_CSV_LINE_SIZ, <br>"%s:%s", <br>lpszCommonName, <br>lpszMachineType); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br>     <br>    hr = HR_LOG(HrDeleteObject( <br>lpszServer, <br>szBasePoint, <br>szCommonName, <br>OBJ_CLASS_ADDR_TYPE)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrAddressTypeExists----------------------------------------------------- <br>//  Checks if an address type exists on a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrAddressTypeExists(     // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszCommonName,       // common name <br>    IN LPSTR lpszMachineType)      // machine type (e.g. "i386") <br>{ <br>    HRESULT hr                             = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                         = 0; <br> <br>    DEBUGPUBLIC("HrAddressTypeExists()"); <br> <br>    hr = CHK_HrAddressTypeExists( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName, <br>lpszMachineType); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_ADDR_TYPE); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    cBytes = _snprintf( <br>szCommonName, <br>MAX_CSV_LINE_SIZ, <br>"%s:%s", <br>lpszCommonName, <br>lpszMachineType); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrEDKObjectExists( <br>lpszServer, <br>szBasePoint, <br>OBJ_CLASS_ADDR_TYPE, <br>szCommonName); <br> <br>    if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetAddressTypeVersion------------------------------------------------- <br>//  Get the version of an address type object in a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetAddressTypeVersion( // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszCommonName,       // common name <br>    IN LPSTR lpszMachineType,      // machine type (e.g. "i386") <br>    OUT DWORD *lpdwFileVersionMS,   // high-order 32 bits of file version <br>    OUT DWORD *lpdwFileVersionLS)   // low-order 32 bits of file version <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    HANDLE  hTempFile                            = INVALID_HANDLE_VALUE; <br>    INT     cBytes                               = 0; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCurVersionRecord[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szCurLine[MAX_CSV_LINE_SIZ]          = {0}; <br>    CHAR   szFileVersionMS[2*sizeof(DWORD)+3]   = {0}; <br>    CHAR   szFileVersionLS[2*sizeof(DWORD)+3]   = {0}; <br>    CHAR   szCurField[MAX_PATH]                 = {0}; <br>    CHAR   szTempName[MAX_PATH]                 = {0}; <br>    WORD    wVersionField                        = MAX_WORD; <br>    WORD    wCurField                            = 0; <br>    LPSTR  endptr                               = NULL; <br> <br>    DEBUGPUBLIC("HrGetAddressTypeVersion()"); <br> <br>    hr = CHK_HrGetAddressTypeVersion( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName, <br>lpszMachineType, <br>lpdwFileVersionMS, <br>lpdwFileVersionLS); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    *lpdwFileVersionMS = 0; <br>    *lpdwFileVersionLS = 0; <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    APPEND_CSV_LINE (szObjectAttributes, FILE_VERSION); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s/cn=%s:%s", <br>lpszSiteDN, <br>CONTAINER_ADDR_TYPE, <br>lpszCommonName, <br>lpszMachineType); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrEDKExportObject( <br>lpszServer, <br>szBasePoint, <br>DAPI_EXPORT_BASEPOINT_ONLY, <br>NULL, <br>szObjectAttributes, <br>szTempName); <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>hTempFile = CreateFile( <br>    szTempName, <br>    GENERIC_READ, <br>    0, <br>    (LPSECURITY_ATTRIBUTES)NULL, <br>    OPEN_EXISTING, <br>    FILE_FLAG_DELETE_ON_CLOSE, <br>    (HANDLE)NULL); <br> <br>if(hTempFile == INVALID_HANDLE_VALUE) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>    goto cleanup; <br>} <br> <br>// <br>// The first line contains the list of fields - find which field has <br>// the file version. <br>// <br> <br>FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>for( <br>    wCurField = 1; <br> <br>    FCsvGetField( <br>MAX_PATH, <br>wCurField, <br>EXCHINST_DELIM, <br>szCurLine, <br>szCurField); <br> <br>    wCurField++) <br>{ <br>    if(lstrcmp(szCurField, FILE_VERSION) == 0)  <br>    { <br>wVersionField = wCurField; <br>break; <br>    } <br>} <br> <br>// Was the file version field exported &amp; found above? <br> <br>if(wVersionField == MAX_WORD)  <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>FCsvGetField( <br>    MAX_CSV_LINE_SIZ, <br>    wVersionField, <br>    EXCHINST_DELIM, <br>    szCurLine, <br>    szCurVersionRecord); <br> <br>szFileVersionMS[ 0] = '0'; <br>szFileVersionMS[ 1] = 'x'; <br>szFileVersionMS[ 2] = szCurVersionRecord[16]; <br>szFileVersionMS[ 3] = szCurVersionRecord[17]; <br>szFileVersionMS[ 4] = szCurVersionRecord[14]; <br>szFileVersionMS[ 5] = szCurVersionRecord[15]; <br>szFileVersionMS[ 6] = szCurVersionRecord[12]; <br>szFileVersionMS[ 7] = szCurVersionRecord[13]; <br>szFileVersionMS[ 8] = szCurVersionRecord[10]; <br>szFileVersionMS[ 9] = szCurVersionRecord[11]; <br>szFileVersionMS[10] = 0; <br> <br>szFileVersionLS[ 0] = '0'; <br>szFileVersionLS[ 1] = 'x'; <br>szFileVersionLS[ 2] = szCurVersionRecord[ 8]; <br>szFileVersionLS[ 3] = szCurVersionRecord[ 9]; <br>szFileVersionLS[ 4] = szCurVersionRecord[ 6]; <br>szFileVersionLS[ 5] = szCurVersionRecord[ 7]; <br>szFileVersionLS[ 6] = szCurVersionRecord[ 4]; <br>szFileVersionLS[ 7] = szCurVersionRecord[ 5]; <br>szFileVersionLS[ 8] = szCurVersionRecord[ 2]; <br>szFileVersionLS[ 9] = szCurVersionRecord[ 3]; <br>szFileVersionLS[10] = 0; <br> <br>*lpdwFileVersionMS = _tcstoul(szFileVersionMS, &amp;endptr, 16); <br>*lpdwFileVersionLS = _tcstoul(szFileVersionLS, &amp;endptr, 16); <br>    } <br> <br>cleanup: <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallAddressTemplate------------------------------------------------ <br>//  Installs an address template into a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallAddressTemplate( // RETURNS: return code <br>    IN LPSTR lpszServer,            // server name <br>    IN LPSTR lpszSiteDN,            // distinguished name of site <br>    IN LPSTR lpszDisplayName,       // display name <br>    IN LPSTR lpszCommonName,        // common name <br>    IN LPSTR lpszAddressSyntax,     // address syntax generator file <br>    IN LPSTR lpszAddressType,       // address type supported by this template <br>    IN LPSTR lpszPerMessageDDT,     // per-message dialog file <br>    IN LPSTR lpszPerRecipientDDT,   // per-recipient dialog file <br>    IN LPSTR lpszAddressEntryDDT,   // address entry dialog file <br>    IN LPSTR lpszLanguage,          // language supported by this template <br>    IN LPSTR lpszHelpData16,        // help data for 16-bit clients <br>    IN LPSTR lpszHelpData32,        // help data for 32-bit clients <br>    IN LPSTR lpszHelpFile)          // client help file name <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ]       = {0}; <br>    CHAR   szTempBuffer[MAX_CSV_LINE_SIZ]       = {0}; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues [MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                               = 0; <br> <br>    DEBUGPUBLIC("HrInstallAddressTemplate()"); <br> <br>    hr = CHK_HrInstallAddressTemplate( <br>lpszServer, <br>lpszSiteDN, <br>lpszDisplayName, <br>lpszCommonName, <br>lpszAddressSyntax, <br>lpszAddressType, <br>lpszPerMessageDDT, <br>lpszPerRecipientDDT, <br>lpszAddressEntryDDT, <br>lpszLanguage, <br>lpszHelpData16, <br>lpszHelpData32, <br>lpszHelpFile); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s/cn=%s", <br>lpszSiteDN, <br>CONTAINER_ADDR_TEMPLATE, <br>lpszLanguage); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , OBJ_CLASS_ADDR_TEMPLATE); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_CREATE); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, ADMIN_DISPLAY_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszDisplayName); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszCommonName); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, ADDR_SYNTAX); <br>    sprintf(szTempBuffer, "=%s", lpszAddressSyntax);    <br>    APPEND_CSV_LINE (szAttributeValues , szTempBuffer); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, ADDR_TYPE); <br>    APPEND_CSV_LINE (szAttributeValues , lpszAddressType); <br>     <br>    if((lpszPerMessageDDT != NULL) &amp;&amp; (lstrlen(lpszPerMessageDDT) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, PER_MSG_DDT); <br>sprintf(szTempBuffer, "=%s", lpszPerMessageDDT);     <br>APPEND_CSV_LINE (szAttributeValues , szTempBuffer); <br>    } <br> <br>    if((lpszPerRecipientDDT != NULL) &amp;&amp; (lstrlen(lpszPerRecipientDDT) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, PER_RECIP_DDT); <br>sprintf(szTempBuffer, "=%s", lpszPerRecipientDDT);   <br>APPEND_CSV_LINE (szAttributeValues , szTempBuffer); <br>    } <br> <br>    APPEND_CSV_LINE (szObjectAttributes, ADDR_ENTRY_DT); <br>    sprintf(szTempBuffer, "=%s", lpszAddressEntryDDT); <br>    APPEND_CSV_LINE (szAttributeValues , szTempBuffer); <br> <br>    if((lpszHelpData16 != NULL) &amp;&amp; (lstrlen(lpszHelpData16) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, HELP_DATA16); <br>sprintf(szTempBuffer, "=%s", lpszHelpData16);     <br>APPEND_CSV_LINE (szAttributeValues , szTempBuffer); <br>    } <br> <br>    if((lpszHelpData32 != NULL) &amp;&amp; (lstrlen(lpszHelpData32) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, HELP_DATA32); <br>sprintf(szTempBuffer, "=%s", lpszHelpData32); <br>APPEND_CSV_LINE (szAttributeValues , szTempBuffer); <br>    } <br> <br>    if((lpszHelpFile != NULL) &amp;&amp; (lstrlen(lpszHelpFile) &gt; 0)) <br>    { <br>APPEND_CSV_LINE (szObjectAttributes, HELP_FILE_NAME); <br>APPEND_CSV_LINE (szAttributeValues , lpszHelpFile); <br>    } <br> <br>    hr = HR_LOG(HrEDKImportObject( <br>lpszServer, <br>szBasePoint, <br>szObjectAttributes, <br>szAttributeValues)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveAddressTemplate------------------------------------------------- <br>//  Removes an address template from a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveAddressTemplate(  // RETURNS: return code <br>    IN LPSTR lpszServer,            // server name <br>    IN LPSTR lpszSiteDN,            // distinguished name of site <br>    IN LPSTR lpszCommonName,        // common name <br>    IN LPSTR lpszAddressType,       // address type supported by this template <br>    IN LPSTR lpszLanguage)          // language supported by this template <br>{ <br>    HRESULT hr                             = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br>    INT     cBytes                         = 0; <br> <br>    DEBUGPUBLIC("HrRemoveAddressTemplate()"); <br> <br>    hr = CHK_HrRemoveAddressTemplate( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName, <br>lpszAddressType, <br>lpszLanguage); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s/cn=%s", <br>lpszSiteDN, <br>CONTAINER_ADDR_TEMPLATE, <br>lpszLanguage); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HR_LOG(HrDeleteObject( <br>lpszServer, <br>szBasePoint, <br>lpszCommonName, <br>OBJ_CLASS_ADDR_TEMPLATE)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrAddressTemplateExists------------------------------------------------- <br>//  Checks if an address template exists on a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrAddressTemplateExists(  // RETURNS: return code <br>    IN LPSTR lpszServer,            // server name <br>    IN LPSTR lpszSiteDN,            // distinguished name of site <br>    IN LPSTR lpszCommonName,        // common name <br>    IN LPSTR lpszAddressType,       // address type supported by this template <br>    IN LPSTR lpszLanguage)          // language supported by this template <br>{ <br>    HRESULT hr                             = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br>    INT     cBytes                         = 0; <br> <br>    DEBUGPUBLIC("HrAddressTemplateExists()"); <br> <br>    hr = CHK_HrAddressTemplateExists( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName, <br>lpszAddressType, <br>lpszLanguage); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s/cn=%s", <br>lpszSiteDN, <br>CONTAINER_ADDR_TEMPLATE, <br>lpszLanguage); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrEDKObjectExists( <br>lpszServer, <br>szBasePoint, <br>OBJ_CLASS_ADDR_TEMPLATE, <br>lpszCommonName); <br> <br>    if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallAdminExtension------------------------------------------------- <br>//  Installs an admin extension object into a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallAdminExtension( // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszDisplayName,      // display name <br>    IN LPSTR lpszCommonName,       // common name <br>    IN DWORD  dwFileVersionMS,      // high-order 32 bits of file version number <br>    IN DWORD  dwFileVersionLS,      // low-order 32 bits of file version number <br>    IN LPSTR lpszExtensionDLL,     // admin extension DLL file name <br>    IN LPSTR lpszMachineType)      // machine type (e.g. "i386") <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ]       = {0}; <br>    CHAR   szFileVersion[MAX_CSV_LINE_SIZ]      = {0}; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues [MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                               = 0; <br>    WORD    wver[4]                              = {0}; <br>    BYTE    bver[8]                              = {0}; <br> <br>    DEBUGPUBLIC("HrInstallAdminExtension()"); <br> <br>    hr = CHK_HrInstallAdminExtension( <br>lpszServer, <br>lpszSiteDN, <br>lpszDisplayName, <br>lpszCommonName, <br>dwFileVersionMS, <br>dwFileVersionLS, <br>lpszExtensionDLL, <br>lpszMachineType); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_ADD_INS); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    cBytes = _snprintf( <br>szCommonName, <br>MAX_CSV_LINE_SIZ, <br>"%s:%s", <br>lpszCommonName, <br>lpszMachineType); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    wver[0] = LOWORD(dwFileVersionLS); <br>    wver[1] = HIWORD(dwFileVersionLS); <br>    wver[2] = LOWORD(dwFileVersionMS); <br>    wver[3] = HIWORD(dwFileVersionMS); <br> <br>    bver[0] = LOBYTE(wver[0]); <br>    bver[1] = HIBYTE(wver[0]); <br>    bver[2] = LOBYTE(wver[1]); <br>    bver[3] = HIBYTE(wver[1]); <br>    bver[4] = LOBYTE(wver[2]); <br>    bver[5] = HIBYTE(wver[2]); <br>    bver[6] = LOBYTE(wver[3]); <br>    bver[7] = HIBYTE(wver[3]); <br> <br>    cBytes = _snprintf( <br>szFileVersion, <br>MAX_CSV_LINE_SIZ, <br>"%02x%02x%02x%02x%02x%02x%02x%02x", <br>bver[0], bver[1], bver[2], bver[3], <br>bver[4], bver[5], bver[6], bver[7]); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , OBJ_CLASS_ADMIN_EXTENSION); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_CREATE); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, ADMIN_DISPLAY_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszDisplayName); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , szCommonName); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, ADMIN_EXTENSION_DLL); <br>    APPEND_CSV_LINE (szAttributeValues , lpszExtensionDLL); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, FILE_VERSION); <br>    APPEND_CSV_LINE (szAttributeValues , szFileVersion); <br>     <br>    hr = HR_LOG(HrEDKImportObject( <br>lpszServer, <br>szBasePoint, <br>szObjectAttributes, <br>szAttributeValues)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveAdminExtension-------------------------------------------------- <br>//  Removes an admin extension from a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveAdminExtension(  // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszCommonName,       // common name <br>    IN LPSTR lpszMachineType)      // machine type (e.g. "i386") <br>{ <br>    HRESULT hr                             = 0; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                         = 0; <br> <br>    DEBUGPUBLIC("HrRemoveAdminExtension()"); <br> <br>    hr = CHK_HrRemoveAdminExtension( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName, <br>lpszMachineType); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_ADD_INS); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    cBytes = _snprintf( <br>szCommonName, <br>MAX_CSV_LINE_SIZ, <br>"%s:%s", <br>lpszCommonName, <br>lpszMachineType); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br>     <br>    hr = HR_LOG(HrDeleteObject( <br>lpszServer, <br>szBasePoint, <br>szCommonName, <br>OBJ_CLASS_ADMIN_EXTENSION)); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrAdminExtensionExists-------------------------------------------------- <br>//  Checks if an admin extension exists on a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrAdminExtensionExists(  // RETURNS: return code <br>    IN LPSTR lpszServer,           // server name <br>    IN LPSTR lpszSiteDN,           // distinguished name of site <br>    IN LPSTR lpszCommonName,       // common name <br>    IN LPSTR lpszMachineType)      // machine type (e.g. "i386") <br>{ <br>    HRESULT hr                             = NOERROR; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCommonName[MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                         = 0; <br> <br>    DEBUGPUBLIC("HrAdminExtensionExists()"); <br> <br>    hr = CHK_HrAdminExtensionExists( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName, <br>lpszMachineType); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_ADD_INS); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    cBytes = _snprintf( <br>szCommonName, <br>MAX_CSV_LINE_SIZ, <br>"%s:%s", <br>lpszCommonName, <br>lpszMachineType); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrEDKObjectExists( <br>lpszServer, <br>szBasePoint, <br>OBJ_CLASS_ADMIN_EXTENSION, <br>szCommonName); <br> <br>    if(FAILED(hr)) <br>    { <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGetAdminExtensionVersion---------------------------------------------- <br>//  Get the version of an admin extension object in a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetAdminExtensionVersion(  // RETURNS: return code <br>    IN LPSTR lpszServer,               // server name <br>    IN LPSTR lpszSiteDN,               // distinguished name of site <br>    IN LPSTR lpszCommonName,           // common name <br>    IN LPSTR lpszMachineType,          // machine type (e.g. "i386") <br>    OUT DWORD *lpdwFileVersionMS,       // high-order 32 bits of file version <br>    OUT DWORD *lpdwFileVersionLS)       // low-order 32 bits of file version <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    HANDLE  hTempFile                            = INVALID_HANDLE_VALUE; <br>    INT     cBytes                               = 0; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCurVersionRecord[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szCurLine[MAX_CSV_LINE_SIZ]          = {0}; <br>    CHAR   szFileVersionMS[2*sizeof(DWORD)+3]   = {0}; <br>    CHAR   szFileVersionLS[2*sizeof(DWORD)+3]   = {0}; <br>    CHAR   szCurField[MAX_PATH]                 = {0}; <br>    CHAR   szTempName[MAX_PATH]                 = {0}; <br>    WORD    wVersionField                        = MAX_WORD; <br>    WORD    wCurField                            = 0; <br>    LPSTR  endptr                               = NULL; <br> <br>    DEBUGPUBLIC("HrGetAdminExtensionVersion()"); <br> <br>    hr = CHK_HrGetAdminExtensionVersion( <br>lpszServer, <br>lpszSiteDN, <br>lpszCommonName, <br>lpszMachineType, <br>lpdwFileVersionMS, <br>lpdwFileVersionLS); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    *lpdwFileVersionMS = 0; <br>    *lpdwFileVersionLS = 0; <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    APPEND_CSV_LINE (szObjectAttributes, FILE_VERSION); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s/cn=%s:%s", <br>lpszSiteDN, <br>CONTAINER_ADD_INS, <br>lpszCommonName, <br>lpszMachineType); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrEDKExportObject( <br>lpszServer, <br>szBasePoint, <br>DAPI_EXPORT_BASEPOINT_ONLY, <br>NULL, <br>szObjectAttributes, <br>szTempName); <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>hTempFile = CreateFile( <br>    szTempName, <br>    GENERIC_READ, <br>    0, <br>    (LPSECURITY_ATTRIBUTES)NULL, <br>    OPEN_EXISTING, <br>    FILE_FLAG_DELETE_ON_CLOSE, <br>    (HANDLE)NULL); <br> <br>if(hTempFile == INVALID_HANDLE_VALUE) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>    goto cleanup; <br>} <br> <br>// <br>// The first line contains the list of fields - find which field has <br>// the file version. <br>// <br> <br>FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>for( <br>    wCurField = 1; <br> <br>    FCsvGetField( <br>MAX_PATH, <br>wCurField, <br>EXCHINST_DELIM, <br>szCurLine, <br>szCurField); <br> <br>    wCurField++) <br>{ <br>    if(lstrcmp(szCurField, FILE_VERSION) == 0)  <br>    { <br>wVersionField = wCurField; <br>break; <br>    } <br>} <br> <br>// Was the file version field exported &amp; found above? <br> <br>if(wVersionField == MAX_WORD)  <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>FCsvGetField( <br>    MAX_CSV_LINE_SIZ, <br>    wVersionField, <br>    EXCHINST_DELIM, <br>    szCurLine, <br>    szCurVersionRecord); <br> <br>szFileVersionMS[ 0] = '0'; <br>szFileVersionMS[ 1] = 'x'; <br>szFileVersionMS[ 2] = szCurVersionRecord[16]; <br>szFileVersionMS[ 3] = szCurVersionRecord[17]; <br>szFileVersionMS[ 4] = szCurVersionRecord[14]; <br>szFileVersionMS[ 5] = szCurVersionRecord[15]; <br>szFileVersionMS[ 6] = szCurVersionRecord[12]; <br>szFileVersionMS[ 7] = szCurVersionRecord[13]; <br>szFileVersionMS[ 8] = szCurVersionRecord[10]; <br>szFileVersionMS[ 9] = szCurVersionRecord[11]; <br>szFileVersionMS[10] = 0; <br> <br>szFileVersionLS[ 0] = '0'; <br>szFileVersionLS[ 1] = 'x'; <br>szFileVersionLS[ 2] = szCurVersionRecord[ 8]; <br>szFileVersionLS[ 3] = szCurVersionRecord[ 9]; <br>szFileVersionLS[ 4] = szCurVersionRecord[ 6]; <br>szFileVersionLS[ 5] = szCurVersionRecord[ 7]; <br>szFileVersionLS[ 6] = szCurVersionRecord[ 4]; <br>szFileVersionLS[ 7] = szCurVersionRecord[ 5]; <br>szFileVersionLS[ 8] = szCurVersionRecord[ 2]; <br>szFileVersionLS[ 9] = szCurVersionRecord[ 3]; <br>szFileVersionLS[10] = 0; <br> <br>*lpdwFileVersionMS = _tcstoul(szFileVersionMS, &amp;endptr, 16); <br>*lpdwFileVersionLS = _tcstoul(szFileVersionLS, &amp;endptr, 16); <br>    } <br> <br>cleanup: <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallContainer--------------------------------------------------------- <br>//  Installs a container in the directory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallContainer(         // RETURNS: return code <br>    IN LPSTR lpszServer,            // server name <br>    IN LPSTR lpszBasePoint,         // base point <br>    IN LPSTR lpszCommonName,        // common name </code></pre>
<p>
</p>
<pre><code>IN LPSTR lpszDisplayName,       // display name <br>    IN LPSTR lpszContainerInfo)     // container information <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    CHAR    szTempBuffer[MAX_CSV_LINE_SIZ]       = {0}; <br>    CHAR    szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR    szAttributeValues [MAX_CSV_LINE_SIZ] = {0}; <br>    INT     cBytes                               = 0; <br> <br>    DEBUGPUBLIC("HrInstallContainer()"); <br> <br>    hr = CHK_HrInstallContainer( <br>        lpszServer, <br>        lpszBasePoint, <br>        lpszCommonName, <br>        lpszDisplayName, <br>        lpszContainerInfo); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , OBJ_CLASS_CONTAINER); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_CREATE); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, ADMIN_DISPLAY_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszDisplayName); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszCommonName); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, CONTAINER_INFO); <br>    APPEND_CSV_LINE (szAttributeValues , lpszContainerInfo); <br> <br>    hr = HR_LOG(HrEDKImportObject( <br>        lpszServer, <br>        lpszBasePoint, <br>        szObjectAttributes, <br>        szAttributeValues)); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveContainer---------------------------------------------------------- <br>//  Removes a container from the directory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveContainer(          // RETURNS: return code <br>    IN LPSTR lpszServer,            // server name <br>    IN LPSTR lpszBasePoint,         // base point <br>    IN LPSTR lpszCommonName)        // common name <br>{ <br>    HRESULT hr                             = NOERROR; <br>    INT     cBytes                         = 0; <br> <br>    DEBUGPUBLIC("HrRemoveContainer()"); <br> <br>    hr = CHK_HrRemoveContainer( <br>        lpszServer, <br>        lpszBasePoint, <br>        lpszCommonName); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HR_LOG(HrDeleteObject( <br>        lpszServer, <br>        lpszBasePoint, <br>        lpszCommonName, <br>        OBJ_CLASS_CONTAINER)); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrContainerExists---------------------------------------------------------- <br>//  Checks if a container exists in the directory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrContainerExists(          // RETURNS: return code <br>    IN LPSTR lpszServer,            // server name <br>    IN LPSTR lpszBasePoint,         // base point <br>    IN LPSTR lpszCommonName)        // common name <br>{ <br>    HRESULT hr                             = NOERROR; <br>    INT     cBytes                         = 0; <br> <br>    DEBUGPUBLIC("HrContainerExists()"); <br> <br>    hr = CHK_HrContainerExists( <br>        lpszServer, <br>        lpszBasePoint, <br>        lpszCommonName); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrEDKObjectExists( <br>        lpszServer, <br>        lpszBasePoint, <br>        OBJ_CLASS_CONTAINER, <br>        lpszCommonName); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallAddressTemplateContainer------------------------------------------ <br>//  Installs an address template container in the directory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallAddressTemplateContainer(  // RETURNS: return code <br>    IN LPSTR lpszServer,                    // server name <br>    IN LPSTR lpszSiteDN,                    // site distinguished name <br>    IN LPSTR lpszLanguage,                  // language supported by container <br>    IN LPSTR lpszDisplayName)               // display name <br>{ <br>    HRESULT hr                             = NOERROR; <br>    INT     cBytes                         = 0; <br>    CHAR    szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br> <br>    DEBUGPUBLIC("HrInstallAddressTemplateContainer()"); <br> <br>    hr = CHK_HrInstallAddressTemplateContainer( <br>        lpszServer, <br>        lpszSiteDN, <br>        lpszLanguage, <br>        lpszDisplayName); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    cBytes = _snprintf( <br>        szBasePoint, <br>        MAX_CSV_LINE_SIZ, <br>        "%s%s", <br>        lpszSiteDN, <br>        CONTAINER_ADDR_TEMPLATE); <br> <br>    if(cBytes &lt; 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrInstallContainer( <br>        lpszServer, <br>        szBasePoint, <br>        lpszLanguage, <br>        lpszDisplayName, <br>        ADDRESS_TEMPLATE_CONTAINER_INFO); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveAddressTemplateContainer------------------------------------------- <br>//  Removes an address template container from the directory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveAddressTemplateContainer(   // RETURNS: return code <br>    IN LPSTR lpszServer,                    // server name <br>    IN LPSTR lpszSiteDN,                    // site distinguished name <br>    IN LPSTR lpszLanguage)                  // language supported by container <br>{ <br>    HRESULT hr                             = NOERROR; <br>    INT     cBytes                         = 0; <br>    CHAR    szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br> <br>    DEBUGPUBLIC("HrRemoveAddressTemplateContainer()"); <br> <br>    hr = CHK_HrRemoveAddressTemplateContainer( <br>        lpszServer, <br>        lpszSiteDN, <br>        lpszLanguage); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    cBytes = _snprintf( <br>        szBasePoint, <br>        MAX_CSV_LINE_SIZ, <br>        "%s%s", <br>        lpszSiteDN, <br>        CONTAINER_ADDR_TEMPLATE); <br> <br>    if(cBytes &lt; 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrRemoveContainer( <br>        lpszServer, <br>        szBasePoint, <br>        lpszLanguage); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrAddressTemplateContainerExists------------------------------------------- <br>//  Checks if an address template container exists in the directory. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrAddressTemplateContainerExists(   // RETURNS: return code <br>    IN LPSTR lpszServer,                    // server name <br>    IN LPSTR lpszSiteDN,                    // site distinguished name <br>    IN LPSTR lpszLanguage)                  // language supported by container <br>{ <br>    HRESULT hr                             = NOERROR; <br>    INT     cBytes                         = 0; <br>    CHAR    szBasePoint[MAX_CSV_LINE_SIZ]  = {0}; <br> <br>    DEBUGPUBLIC("HrAddressTemplateContainerExists()"); <br> <br>    hr = CHK_HrAddressTemplateContainerExists( <br>        lpszServer, <br>        lpszSiteDN, <br>        lpszLanguage); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    cBytes = _snprintf( <br>        szBasePoint, <br>        MAX_CSV_LINE_SIZ, <br>        "%s%s", <br>        lpszSiteDN, <br>        CONTAINER_ADDR_TEMPLATE); <br> <br>    if(cBytes &lt; 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrContainerExists( <br>        lpszServer, <br>        szBasePoint, <br>        lpszLanguage); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrAddDelGatewayProxy------------------------------------------------------- <br>// This function will add/delete our gateway proxy to/from the given site. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrAddDelGatewayProxy(    // RETURNS: return code <br>    IN  LPSTR lpszServer,               // server name <br>    IN  LPSTR lpszSiteDN,               // site distinguished name <br>    IN  LPSTR lpszOurProxyString,       // proxy string for our gateway <br>    IN  BOOL  fAddProxy)                // If TRUE we will add proxy <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    HANDLE  hTempFile                            = INVALID_HANDLE_VALUE; <br>    INT     cBytes                               = 0; <br>    CHAR   szBasePoint[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR   szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR   szAttributeValues[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR   szCurProxyRecord[MAX_CSV_LINE_SIZ]   = {0}; <br>    CHAR   szNewProxyRecord[MAX_CSV_LINE_SIZ]   = {0}; <br>    CHAR   szCurProxyString[MAX_CSV_LINE_SIZ]   = {0}; <br>    CHAR   szCurLine[MAX_CSV_LINE_SIZ]          = {0}; <br>    CHAR   szCurField[MAX_PATH]                 = {0}; <br>    CHAR   szTempName[MAX_PATH]                 = {0}; <br>    CHAR   szTmpBuf[MAX_CSV_LINE_SIZ]           = {0}; <br>    WORD    wGatewayProxyField                   = MAX_WORD; <br>    WORD    wCurField                            = 0; <br>    BOOL    fOurProxyExist                       = FALSE; <br>    DWORD   cchOurProxyString                    = 0; <br> <br>    hr = CHK_HrAddDelGatewayProxy( <br>lpszServer, <br>lpszSiteDN, <br>lpszOurProxyString, <br>fAddProxy); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    APPEND_CSV_LINE (szObjectAttributes, GATEWAY_PROXY); <br> <br>    cBytes = _snprintf( <br>szBasePoint, <br>MAX_CSV_LINE_SIZ, <br>"%s%s", <br>lpszSiteDN, <br>CONTAINER_SITE_ADDR); <br> <br>    if(cBytes &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrEDKExportObject( <br>lpszServer, <br>szBasePoint, <br>DAPI_EXPORT_BASEPOINT_ONLY, <br>NULL, <br>szObjectAttributes, <br>szTempName); <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>hTempFile = CreateFile( <br>    szTempName, <br>    GENERIC_READ, <br>    0, <br>    (LPSECURITY_ATTRIBUTES)NULL, <br>    OPEN_EXISTING, <br>    FILE_FLAG_DELETE_ON_CLOSE, <br>    (HANDLE)NULL); <br> <br>if(hTempFile == INVALID_HANDLE_VALUE) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>    goto cleanup; <br>} <br> <br>// <br>// The first line contains the list of fields - find which field has <br>// the gateway proxy. <br>// <br> <br>FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>for( <br>    wCurField = 1; <br> <br>    FCsvGetField( <br>MAX_PATH, <br>wCurField, <br>EXCHINST_DELIM, <br>szCurLine, <br>szCurField); <br> <br>    wCurField++) <br>{ <br>    if(strcmp(szCurField, GATEWAY_PROXY) == 0)  <br>    { <br>wGatewayProxyField = wCurField; <br>break; <br>    } <br>} <br> <br>// Was the gateway proxy field exported &amp; found above? <br> <br>if(wGatewayProxyField == MAX_WORD)  <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>cchOurProxyString = lstrlen(lpszOurProxyString); <br> <br>// <br>// Get the current Proxy record and Add or Delete it as specified <br>// (Add only if it doesnt exist) <br>// (e.g. Proxy record: SMTP:@site.ent.com%MS:site/ent%EDK:@site.ent.com) <br>// <br> <br>FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>FCsvGetField( <br>    MAX_CSV_LINE_SIZ, <br>    wGatewayProxyField, <br>    EXCHINST_DELIM, <br>    szCurLine, <br>    szCurProxyRecord); <br> <br>for( <br>    wCurField = 1; <br> <br>    FCsvGetField( <br>MAX_PATH, <br>wCurField, <br>EXCHINST_MV_SEP, <br>szCurProxyRecord, <br>szCurProxyString); <br> <br>    wCurField++) <br>{ <br>    if(_strnicmp( <br>szCurProxyString, lpszOurProxyString, cchOurProxyString) == 0) <br>    { <br>fOurProxyExist = TRUE; <br> <br>if(fAddProxy) <br>{ <br>    if(lstrlen(szNewProxyRecord) != 0) <br>lstrcat(szNewProxyRecord, SZ_EXCHINST_MV_SEP); <br>    lstrcat(szNewProxyRecord, szCurProxyString); <br>} <br>    } <br>    else  <br>    { <br>if(lstrlen(szNewProxyRecord) != 0) <br>    lstrcat(szNewProxyRecord, SZ_EXCHINST_MV_SEP); <br>lstrcat(szNewProxyRecord, szCurProxyString); <br>    } <br>} <br> <br>if(fOurProxyExist == FALSE) <br>{ <br>    if(fAddProxy) <br>    { <br>if(lstrlen(szNewProxyRecord) != 0) <br>    lstrcat(szNewProxyRecord, SZ_EXCHINST_MV_SEP); <br>lstrcat(szNewProxyRecord, lpszOurProxyString); <br>    } <br>    else <br>    { <br>hr = HR_LOG(EDK_E_NOT_FOUND); <br>goto cleanup; <br>    } <br>} <br> <br>// Build line to perform the modification. <br> <br>BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>BEGIN_CSV_LINE  (szAttributeValues , OBJ_CLASS_SITE); <br> <br>APPEND_CSV_LINE (szObjectAttributes, MODE); <br>APPEND_CSV_LINE (szAttributeValues , MODE_MODIFY); <br> <br>APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>APPEND_CSV_LINE (szAttributeValues , SITE_ADDRESSING); <br>     <br>APPEND_CSV_LINE (szObjectAttributes, GATEWAY_PROXY); <br>APPEND_CSV_LINE (szAttributeValues , szNewProxyRecord); <br> <br>cBytes = _snprintf( <br>    szBasePoint, <br>    MAX_CSV_LINE_SIZ, <br>    "%s%s", <br>    lpszSiteDN, <br>    CONTAINER_CONFIGURATION); <br> <br>if(cBytes &lt; 0) <br>{ <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>} <br> <br>hr = HR_LOG(HrEDKImportObject( <br>    lpszServer, <br>    szBasePoint, <br>    szObjectAttributes, <br>    szAttributeValues)); <br>    } <br> <br>cleanup: <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInstallGatewayProxy--------------------------------------------------- <br>//  Installs a gateway proxy into a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallGatewayProxy(    // RETURNS: return code <br>    IN LPSTR lpszServer,            // server name <br>    IN LPSTR lpszSiteDN,            // distinguished name of site <br>    IN LPSTR lpszProxy)             // gateway proxy <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrInstallGatewayProxy()"); <br> <br>    hr = CHK_HrInstallGatewayProxy( <br>lpszServer, <br>lpszSiteDN, <br>lpszProxy); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    RETURN(HrAddDelGatewayProxy( <br>lpszServer, <br>lpszSiteDN, <br>lpszProxy, <br>TRUE)); <br>} <br> <br>//$--HrRemoveGatewayProxy---------------------------------------------------- <br>//  Removes a gateway proxy from a given site. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrRemoveGatewayProxy(     // RETURNS: return code <br>    IN LPSTR lpszServer,            // server name <br>    IN LPSTR lpszSiteDN,            // distinguished name of site <br>    IN LPSTR lpszProxy)             // gateway proxy <br>{ <br>    RETURN(HrAddDelGatewayProxy( <br>lpszServer, <br>lpszSiteDN, <br>lpszProxy, <br>FALSE)); <br>} <br> <br>//$--FHasAdminPrivs---------------------------------------------------------------- <br>//  Returns TRUE if the current user is an administrator. <br>// ----------------------------------------------------------------------------- <br>BOOL FHasAdminPrivs(                    // RETURNS: TRUE/FALSE <br>    void)                            // no arguments <br>{ <br>    BOOL                     fRet               = TRUE; <br>    HANDLE                   hProcess           = INVALID_HANDLE_VALUE; <br>    HANDLE                   hAccessToken       = INVALID_HANDLE_VALUE; <br>    UCHAR                    InfoBuffer[1024]   = {0}; <br>    PTOKEN_GROUPS            ptgGroups          = (PTOKEN_GROUPS)InfoBuffer; <br>    DWORD                    dwInfoBufferSize   = 0; <br>    PSID                     psidAdministrators = NULL; <br>    SID_IDENTIFIER_AUTHORITY siaNtAuthority     = SECURITY_NT_AUTHORITY; <br>    UINT                     x                  = 0; <br> <br>    hProcess = GetCurrentProcess(); <br> <br>    if(!OpenProcessToken(hProcess,TOKEN_READ,&amp;hAccessToken)) <br>return(FALSE); <br> <br>    if(!GetTokenInformation( <br>hAccessToken,TokenGroups, InfoBuffer, 1024, &amp;dwInfoBufferSize)) <br>return(FALSE); <br> <br>    fRet = AllocateAndInitializeSid( <br>&amp;siaNtAuthority, <br>2, <br>SECURITY_BUILTIN_DOMAIN_RID, <br>DOMAIN_ALIAS_RID_ADMINS, <br>0, <br>0, <br>0, <br>0, <br>0, <br>0, <br>&amp;psidAdministrators); <br> <br>    if (!fRet) <br>    { <br>return(FALSE); <br>    } <br> <br>    for(x = 0; x &lt; ptgGroups-&gt;GroupCount; x++) <br>    { <br>if(EqualSid(psidAdministrators, ptgGroups-&gt;Groups[x].Sid)) <br>{ <br>    FreeSid(psidAdministrators); <br>    return(TRUE); <br>} <br>    } <br> <br>    FreeSid(psidAdministrators); <br> <br>    return(FALSE); <br>} <br> <br>//$--HrInstallMessageConverter----------------------------------------------- <br>// Installs a message conversion DLL. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInstallMessageConverter(   // RETURNS: return code <br>    IN LPSTR lpszConverter,            // converter name <br>    IN LPSTR lpszDllName,              // name of conversion DLL <br>    IN LPSTR lpszMessageClasses,       // message classes <br>    IN LPSTR lpszOptions,              // options string <br>    IN LPSTR lpszPoint)                // conversion point <br>{ <br>    HRESULT hr                 = NOERROR; <br>    LONG    lRet               = 0; <br>    HKEY    hkClasses          = INVALID_HANDLE_VALUE; <br>    HKEY    hkObject           = INVALID_HANDLE_VALUE; <br>    HKEY    hkTmp              = INVALID_HANDLE_VALUE; <br>    DWORD   dwDisposition      = 0; <br> <br>    DEBUGPUBLIC("HrInstallMessageConverter()\n"); <br> <br>    hr = CHK_HrInstallMessageConverter( <br>lpszConverter, <br>lpszDllName, <br>lpszMessageClasses, <br>lpszOptions, <br>lpszPoint); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    lRet = RegCreateKeyEx( <br>HKEY_LOCAL_MACHINE, <br>"Software\\Classes\\MAPI Conversions", <br>0, <br>"", <br>REG_OPTION_NON_VOLATILE, <br>KEY_ALL_ACCESS, <br>NULL, <br>&amp;hkClasses, <br>&amp;dwDisposition); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Create the object key. <br>    // <br> <br>    lRet = CREATEKEY(hkClasses, lpszDllName, hkObject, dwDisposition); <br> <br>    if((lRet != ERROR_SUCCESS) &amp;&amp; (lRet != ERROR_ALREADY_EXISTS)) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // <br>    // Create GetTrivialVector key. <br>    // <br> <br>    lRet = CREATEKEY(hkObject, "GetTrivialVector", hkTmp, dwDisposition); <br> <br>    if((lRet != ERROR_SUCCESS) &amp;&amp; (lRet != ERROR_ALREADY_EXISTS)) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    // Create new values under GetTrivialVector key <br> <br>    lRet = SETMULTISZVALUE(hkTmp, "Classes", lpszMessageClasses); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>    if(lpszOptions != NULL) <br>    { <br>lRet = SETSZVALUE(hkTmp, "Options", lpszOptions); <br> <br>if(lRet != ERROR_SUCCESS) <br>{ <br>    hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>    goto cleanup; <br>} <br>    } <br> <br>    lRet = SETSZVALUE(hkTmp, "Point", lpszPoint); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    FREEHKEY(hkClasses); <br>    FREEHKEY(hkObject); <br>    FREEHKEY(hkTmp); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrRemoveMessageConverter----------------------------------------------- <br>//  Delete a message conversion DLL. <br>// ---------------------------------------------------------------------------- <br>HRESULT HrRemoveMessageConverter(    // RETURNS: return code <br>    IN LPCSTR lpszConverter)           // converter name <br>{ <br>    HRESULT hr         = NOERROR; <br>    LONG    lRet       = 0; <br>    HKEY    hkClasses  = INVALID_HANDLE_VALUE; <br>    HKEY    hkObject   = INVALID_HANDLE_VALUE; <br> <br>    DEBUGPUBLIC("HrRemoveMessageConverter()\n"); <br> <br>    hr = CHK_HrRemoveMessageConverter( <br>lpszConverter); <br>    if(FAILED(hr)) <br>RETURN(hr); <br> <br>    // <br>    //  Open the services key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE, <br>TEXT("Software\\Classes\\MAPI Conversions"),  <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hkClasses); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    // <br>    //  Open the conversion key. <br>    // <br> <br>    lRet = RegOpenKeyEx( <br>hkClasses, <br>lpszConverter, <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hkObject); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    (void)HrDeleteContainedKeys(hkObject); <br> <br>    lRet = RegDeleteKey(hkClasses, lpszConverter); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    FREEHKEY(hkObject); <br>    FREEHKEY(hkClasses); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrAdminProgramExists--------------------------------------------------- <br>//  Check if the admin program has been installed on the local computer. <br>// ---------------------------------------------------------------------------- <br>HRESULT HrAdminProgramExists(        // RETURNS: return code <br>    void)                               // nothing <br>{ <br>    HRESULT hr                     = NOERROR; <br>    LONG    lRet                   = 0; <br>    HKEY    hKey                   = INVALID_HANDLE_VALUE; <br>    DWORD   dwType                 = 0; <br>    DWORD   cBytes                 = 0; <br>    LPSTR  lpszAdminDest          = NULL; <br>    CHAR   szFileName[MAX_PATH+1] = {0}; <br>    ULONG   cch                    = 0; <br>    DWORD   dwAttrib               = 0; <br> <br>    DEBUGPUBLIC("HrAdminProgramExists()\n"); <br> <br>    lRet = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE, <br>TEXT("Software\\Microsoft\\Exchange\\Setup"),  <br>0, <br>KEY_ALL_ACCESS, <br>&amp;hKey); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(lRet)); <br>goto cleanup; <br>    } <br> <br>    hr = HrGetRegistryValue( <br>hKey, "AdminDest", &amp;dwType, &amp;cBytes, (LPVOID) &amp;lpszAdminDest); <br> <br>    if(FAILED(hr) || dwType != REG_SZ) <br>    { <br>if(dwType != REG_SZ) <br>    hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    if(lpszAdminDest == NULL) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    cch = lstrlen(lpszAdminDest); <br> <br>    if(cch == 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>    lstrcpy(szFileName, lpszAdminDest); <br> <br>    if(szFileName[cch-1] != '\\') <br>    { <br>lstrcatA(szFileName, "\\"); <br>    } <br> <br>    lstrcatA(szFileName, "ADMIN.EXE"); <br> <br>    dwAttrib = GetFileAttributes(szFileName); <br> <br>    if(dwAttrib == 0xFFFFFFFF) <br>    { <br>hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>GLOBALFREE(lpszAdminDest); <br>    FREEHKEY(hKey); <br> <br>    RegFlushKey(HKEY_LOCAL_MACHINE); <br>    RegFlushKey(HKEY_CURRENT_USER); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrSetGatewayBit------------------------------------------------------------ <br>//  This function will set the gateway bit on a given server. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrSetGatewayBit(                // RETURNS: return code <br>    IN  LPSTR lpszServer,               // server name <br>    IN  LPSTR lpszSiteDN,               // site distinguished name <br>    IN  LPSTR lpszServerName)           // server name <br>{ <br>    HRESULT hr                                   = NOERROR; <br>    HANDLE  hTempFile                            = INVALID_HANDLE_VALUE; <br>    INT     cBytes                               = 0; <br>    CHAR    szBasePoint[MAX_CSV_LINE_SIZ]        = {0}; <br>    CHAR    szObjectAttributes[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR    szAttributeValues[MAX_CSV_LINE_SIZ]  = {0}; <br>    CHAR    szCurHeuristicRecord[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR    szNewHeuristicRecord[MAX_CSV_LINE_SIZ] = {0}; <br>    CHAR    szCurLine[MAX_CSV_LINE_SIZ]          = {0}; <br>    CHAR    szCurField[MAX_PATH]                 = {0}; <br>    CHAR    szTempName[MAX_PATH]                 = {0}; <br>    CHAR    szTmpBuf[MAX_CSV_LINE_SIZ]           = {0}; <br>    WORD    wHeuristicField                      = MAX_WORD; <br>    WORD    wCurField                            = 0; <br>    ULONG   ulHeuristic                          = 0; <br> <br>    hr = CHK_HrSetGatewayBit( <br>    lpszServer, <br>    lpszSiteDN, <br>    lpszServerName); <br>    if(FAILED(hr)) <br>    RETURN(hr); <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    APPEND_CSV_LINE (szObjectAttributes, HEURISTICS); <br> <br>    cBytes = _snprintf( <br>    szBasePoint, <br>    MAX_CSV_LINE_SIZ, <br>    "%s%s/cn=%s", <br>    lpszSiteDN, <br>    CONTAINER_SERVERS, <br>        lpszServerName); <br> <br>    if(cBytes &lt; 0) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = HrEDKExportObject( <br>    lpszServer, <br>    szBasePoint, <br>    DAPI_EXPORT_BASEPOINT_ONLY, <br>    NULL, <br>    szObjectAttributes, <br>    szTempName); <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>    hTempFile = CreateFile( <br>        szTempName, <br>        GENERIC_READ, <br>        0, <br>        (LPSECURITY_ATTRIBUTES)NULL, <br>        OPEN_EXISTING, <br>        FILE_FLAG_DELETE_ON_CLOSE, <br>        (HANDLE)NULL); <br> <br>    if(hTempFile == INVALID_HANDLE_VALUE) <br>    { <br>        hr = HR_LOG(HRESULT_FROM_WIN32(GetLastError())); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // The first line contains the list of fields - find which field has <br>    // the heuristic. <br>    // <br> <br>    FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>    for( <br>        wCurField = 1; <br> <br>        FCsvGetField( <br>    MAX_PATH, <br>    wCurField, <br>    EXCHINST_DELIM, <br>    szCurLine, <br>    szCurField); <br> <br>        wCurField++) <br>    { <br>        if(strcmp(szCurField, HEURISTICS) == 0)  <br>        { <br>        wHeuristicField = wCurField; <br>        break; <br>        } <br>    } <br> <br>    // Was the heuristic field exported &amp; found above? <br> <br>    if(wHeuristicField == MAX_WORD)  <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Get the current value of the heuristic attribute. <br>    // <br> <br>    FCsvGetRecord(MAX_CSV_LINE_SIZ, hTempFile, szCurLine); <br> <br>    FCsvGetField( <br>        MAX_CSV_LINE_SIZ, <br>        wHeuristicField, <br>        EXCHINST_DELIM, <br>        szCurLine, <br>        szCurHeuristicRecord); <br> <br>        // <br>        // Set the gateway bit. <br>        // <br> <br>        ulHeuristic  = atol(szCurHeuristicRecord); <br> <br>        ulHeuristic |= 2; <br> <br>        cBytes = _snprintf( <br>        szNewHeuristicRecord, <br>        MAX_CSV_LINE_SIZ, <br>        "%lu", <br>            ulHeuristic); <br> <br>        if(cBytes &lt; 0) <br>        { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>        } <br> <br>    // Build line to perform the modification. <br> <br>    BEGIN_CSV_LINE  (szObjectAttributes, OBJ_CLASS); <br>    BEGIN_CSV_LINE  (szAttributeValues , OBJ_CLASS_COMPUTER); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, MODE); <br>    APPEND_CSV_LINE (szAttributeValues , MODE_MODIFY); <br> <br>    APPEND_CSV_LINE (szObjectAttributes, COMMON_NAME); <br>    APPEND_CSV_LINE (szAttributeValues , lpszServerName); <br>     <br>    APPEND_CSV_LINE (szObjectAttributes, HEURISTICS); <br>    APPEND_CSV_LINE (szAttributeValues , szNewHeuristicRecord); <br> <br>        cBytes = _snprintf( <br>        szBasePoint, <br>        MAX_CSV_LINE_SIZ, <br>        "%s%s", <br>        lpszSiteDN, <br>        CONTAINER_SERVERS); <br> <br>        if(cBytes &lt; 0) <br>        { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>        } <br> <br>    hr = HR_LOG(HrEDKImportObject( <br>        lpszServer, <br>        szBasePoint, <br>        szObjectAttributes, <br>        szAttributeValues)); <br>    } <br> <br>cleanup: <br> <br>    CLOSEHANDLE(hTempFile); <br> <br>    RETURN(hr); <br>} <br> <br>#include "exchprof.c" </code></pre>
<p>&nbsp;</p></body>
</HTML>
