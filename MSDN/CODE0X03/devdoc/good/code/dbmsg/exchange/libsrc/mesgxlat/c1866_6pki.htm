<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVREG.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1872"></a>CONVREG.CPP</h2>
<pre><code>// --convreg.cpp---------------------------------------------------------------- <br>//  <br>// Conversion registry code. <br>// Locates converters that are stored in DLLs from info stored in the  <br>// registry. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#include "convincl.h" <br>#include "convreg.chk" <br> <br>// <br>//  String constants used to find registry keys. <br>// <br>static const LPWSTR pszMAPIConvKey = L"SOFTWARE\\Classes\\MAPI Conversions"; <br> <br>// <br>//  Conversion KEY values. <br>// <br>static const LPWSTR pszClassesKey =  L"Classes";       <br>static const LPWSTR pszPointKey =    L"Point"; <br>static const LPWSTR pszOptionsKey =  L"Options"; <br> <br>// <br>// limiting constants. <br>// <br>static const int cMaxKeyNameSize = 100;                    // maximum conversion key size. <br> <br>// Static variables shared by all instances <br>HKEY CEDKConvReg::ms_hkConversions             = NULL;     // handle to conversion key. <br>CClassName * CEDKConvReg::ms_pcnClasses        = NULL;     // common cache of conversion info <br>CDllCache * CEDKConvReg::ms_pDllCache          = NULL;     // common DLL cache <br> <br>//$--CEDKConvReg::CEDKConvReg------------------------------------------ <br>// <br>//  DESCRIPTION:     CEDKConvReg class constructor <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    nothing <br>// <br>//--------------------------------------------------------------------- <br>CEDKConvReg::CEDKConvReg() <br>{ <br>    DEBUGPRIVATE("CEDKConvReg::CEDKConvReg()\n"); <br>} <br> <br>//$--CEDKConvReg::~CEDKConvReg----------------------------------------- <br>// <br>//  DESCRIPTION: CEDKConvReg class destructor <br>// <br>//  INPUT:   none <br>// <br>//  RETURNS:    nothing <br>// <br>//--------------------------------------------------------------------- <br>CEDKConvReg::~CEDKConvReg() <br>{ <br>    DEBUGPRIVATE("CEDKConvReg::~CEDKConvReg()\n"); <br>} <br> <br>//$--CEDKConvReg::HrEDKInitialize----------------------------------------- <br>// <br>//  DESCRIPTION: Perform loading part of Conversion registry initialization. <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_FAIL otherwise <br>// <br>//--------------------------------------------------------------------- <br>HRESULT CEDKConvReg::HrEDKInitialize() <br>{ <br>    HRESULT hr  =   NOERROR;    //  return code <br>    LONG lRet = ERROR_SUCCESS;  // win32 return code <br> <br>    DEBUGPRIVATE("CEDKConvReg::HrEDKInitialize()\n"); <br> <br>    // <br>    //  Skip initialization if it has already been done. <br>    // <br>    if(ms_pcnClasses != NULL)     <br>    {         <br>        goto cleanup; <br>    } <br> <br>    // consistency checking <br>    ASSERTERROR(ms_hkConversions == NULL,"NULL ms_hkConversions variable"); <br> <br>    // Create the DLL cache. <br>    ms_pDllCache = new CDllCache; <br> <br>    if ( ms_pDllCache == NULL ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Open key that contains all conversions. <br>    // <br>    lRet = RegOpenKeyExW( <br>        HKEY_LOCAL_MACHINE, <br>        pszMAPIConvKey,  <br>        0, <br>        KEY_READ, <br>        &amp;ms_hkConversions);     <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Parse the contented keys and values. <br>    // <br>    hr = HrEDKParseConfiguration(); <br>     <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKConvReg::HrEDKParseConfiguration--------------------------------- <br>// <br>//  DESCRIPTION: Parse the list of all conversions from the registry conversion keys <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    HRESULT --  NOERROR if no error successful, <br>//                          EDK_E_END_OF_FILE if syntax error <br>//                          E_FAIL otherwise <br>// <br>//--------------------------------------------------------------------- <br>HRESULT CEDKConvReg::HrEDKParseConfiguration()  // RETURNS: HRESULT <br>{ <br>    HRESULT hr        = NOERROR;    // return code <br>    LONG lRet         = 0; <br>    HKEY hkDll        = NULL; <br>    HKEY hkEntryPoint = NULL; <br> <br>    DEBUGPRIVATE("CEDKConvReg::HrEDKParseConfiguration()\n"); <br> <br>    // consistency checking <br>    ASSERTERROR(ms_hkConversions != NULL,"NULL ms_hkConversions parameter"); <br> <br>    ASSERTERROR(ms_pcnClasses == NULL,"NULL ms_pcnClasses parameter"); <br> <br>    m_bSyntaxError = FALSE; <br> <br>    // <br>    // Enumerate all conversion DLLs.  These are sub-keys of hkConversions <br>    // At the same time, load each DLL found and add to the DLL cache. <br>    // <br> <br>    UINT    iDll    =   0;  // DLL index <br> <br>    for(iDll = 0;;iDll++) <br>    { <br>        FILETIME ftDummy                  = {0}; <br>        WCHAR    szDll[cMaxKeyNameSize+1] = {0}; <br>        DWORD    dwDummy                  = cMaxKeyNameSize; <br> <br>        // DLL loop bounds <br>        ASSERTERROR(iDll &gt;= 0 &amp;&amp; iDll &lt; 1024,"iDll out of bounds"); <br> <br>        // <br>        //  Get the next key <br>        // <br>        lRet = RegEnumKeyExW( <br>            ms_hkConversions, iDll, szDll, &amp;dwDummy, NULL, NULL, NULL, &amp;ftDummy); <br> <br>        if(lRet == ERROR_NO_MORE_ITEMS) <br>            break; <br> <br>        if(lRet != ERROR_SUCCESS) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // <br>        //  Open the conversion DLL key <br>        // <br>        lRet = RegOpenKeyExW(ms_hkConversions, szDll, 0L, KEY_READ, &amp;hkDll); <br> <br>        if(lRet != ERROR_SUCCESS) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>        } <br> <br>        // Add the conversion DLL to the global DLL cache.  <br>        // (This also loads the DLL.) <br>        hr = ms_pDllCache-&gt;HrAdd( <br>            szDll);     // DLL name to load and add <br> <br>        if ( FAILED(hr) ) <br>        { <br>            goto cleanup; <br>        } <br> <br>        // <br>        // enumerate all entry point keys contained in the DLL key. <br>        // <br>        int iEntryPoint = 0; <br> <br>        for (iEntryPoint = 0;;iEntryPoint++) <br>        { <br>            WCHAR szEntryPoint[cMaxKeyNameSize+1] = {0}; <br> <br>            // Entry point loop bounds <br>            ASSERTERROR( <br>                iEntryPoint &gt;= 0 &amp;&amp; iEntryPoint &lt; 1024, <br>                "iEntryPoint out of bounds"); <br>     <br>            dwDummy = cMaxKeyNameSize; <br> <br>            lRet = RegEnumKeyExW( <br>                hkDll, iEntryPoint, szEntryPoint, &amp;dwDummy, NULL, NULL, NULL, &amp;ftDummy); <br> <br>            if(lRet == ERROR_NO_MORE_ITEMS) <br>                break; <br> <br>            if(lRet != ERROR_SUCCESS) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            // <br>            //  Open the entry point <br>            // <br>            lRet = RegOpenKeyExW(hkDll, szEntryPoint, 0L, KEY_READ, &amp;hkEntryPoint); <br> <br>            if(lRet != ERROR_SUCCESS) <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>            // <br>            //  Get values and put them in the in-memory structure. <br>            // <br>            hr = HrEDKRecordValues(hkEntryPoint, szDll, szEntryPoint); <br> <br>            if(hr == EDK_E_END_OF_FILE) <br>            { <br>                // Error reported by HrEDKRecordValues <br>                hr = HR_LOG(NOERROR);   // not a critical error <br>            } <br> <br>            if(FAILED(hr)) <br>            { <br>                goto cleanup; <br>            } <br> <br> <br>            // <br>            //  Close entry point key. <br>            // <br>            REGCLOSEKEY(hkEntryPoint); <br>        } <br> <br>        if(!iEntryPoint) <br>        { <br>            EDKSyntaxError( <br>                szDll, <br>                NULL, <br>                NULL, <br>                NULL, <br>                NULL); <br>        } <br> <br>        // <br>        //  Close DLL key. <br>        // <br>        REGCLOSEKEY(hkDll); <br>    } <br> <br>    if(!iDll) <br>    { <br>        EDKSyntaxError( <br>            NULL, <br>            NULL, <br>            NULL, <br>            NULL, <br>            NULL); <br>    } <br> <br>cleanup: <br> <br>    REGCLOSEKEY(hkDll); <br>    REGCLOSEKEY(hkEntryPoint); <br> <br>    if(m_bSyntaxError) <br>    { <br>        hr = HR_LOG(EDK_E_END_OF_FILE); <br>    } <br> <br>    ASSERTERROR(hkDll == NULL,"NULL hkDll variable"); <br> <br>    ASSERTERROR(hkEntryPoint == NULL,"NULL hkEntryPoint variable"); <br>        <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKConvReg::HrEDKRecordValues--------------------------------------- <br>// <br>//  DESCRIPTION: We have found an entry point.  Get its details and record them in <br>//  the in-memory list of classes/entry points. <br>// <br>//  INPUT:  hkEntryPoint    --  entry point key <br>//          pszDll  --  DLL name <br>//          pszEntryPoint   --  name of DLL's entry point function <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          EDK_E_END_OF_FILE if bad syntax, <br>//                          E_FAIL otherwise <br>// <br>//--------------------------------------------------------------------- <br>HRESULT CEDKConvReg::HrEDKRecordValues(     // RETURN:  HRESULT <br>                                    //   if a required value is not present <br>                                    //   SyntaxError() is also called. <br>    IN HKEY const hkEntryPoint,     // Entry point key that contain details <br>    IN LPCWSTR pszDll,              // dll containing entry point. <br>    IN LPCWSTR pszEntryPoint)       // name of entry point in dll. <br>{ <br>    HRESULT        hr             = NOERROR;    // return code <br>    PVOID          pClasses       = NULL; <br>    PVOID          pPoint         = NULL; <br>    PVOID          pOptions       = NULL; <br>    DWORD          cbSize         = 0; <br>    DWORD          nType          = 0; <br>    LPCWSTR        pszClassName   = NULL; <br>    CDllEntryPoint *pEntryPoint   = NULL; <br> <br>    DEBUGPRIVATE("CEDKConvReg::HrEDKRecordValues()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CEDKConvReg_HrEDKRecordValues(hkEntryPoint, pszDll,  <br>                                           pszEntryPoint); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // <br>    //  Get the key values. <br>    // <br> <br>    // <br>    //  Supported classes. <br>    // <br>    hr = HrGetArbSizeValue(hkEntryPoint, pszClassesKey,  <br>                              pClasses, cbSize, nType); <br> <br>    if(hr == EDK_E_END_OF_FILE || nType != REG_MULTI_SZ) <br>    { <br>        hr = HR_LOG(EDK_E_END_OF_FILE); <br>    } <br>     <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Conversion point. <br>    // <br>    hr = HrGetArbSizeValue(hkEntryPoint, pszPointKey,  <br>                              pPoint, cbSize, nType); <br> <br>    if(hr == EDK_E_END_OF_FILE || nType != REG_SZ) <br>    { <br>        hr = HR_LOG(EDK_E_END_OF_FILE); <br>    } <br>     <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Options. <br>    // <br>    hr = HrGetArbSizeValue(hkEntryPoint, pszOptionsKey,  <br>                              pOptions, cbSize, nType); <br> <br>    // ignore absent value. <br>    if(SUCCEEDED(hr) &amp;&amp; nType != REG_SZ) <br>    { <br>        hr = HR_LOG(EDK_E_END_OF_FILE); <br> <br>        goto cleanup; <br>    } <br>    else <br>    { <br>        hr = HR_LOG(NOERROR); <br>    } <br> <br>    // <br>    //  Setup pointer to first class name. <br>    // <br>    pszClassName = (LPCWSTR)pClasses; <br> <br>    ASSERTERROR(pszClassName != NULL, "Bad pszClassName"); <br>    ASSERTERROR(pPoint != NULL, "Bad pPoint"); <br> <br>    if( (*pszClassName == 0) || (*((LPWSTR)pPoint) == 0) ) <br>    { <br>        hr = HR_LOG(EDK_E_END_OF_FILE); <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  Create a new entry point. <br>    // <br> <br>    pEntryPoint = new CDllEntryPoint; <br> <br>    if(pEntryPoint == NULL) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = pEntryPoint-&gt;HrEDKSet( <br>        pszDll, (LPCWSTR)pszEntryPoint, (LPCWSTR)pPoint, (LPWSTR)pOptions); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // <br>    //  For each class in pClasses <br>    // <br> <br>    for(; *pszClassName; pszClassName += lstrlenW(pszClassName)+1) <br>    { <br>        // <br>        //  Make a new class structre <br>        // <br> <br>        CClassName * pNewClass = new CClassName; <br> <br>        if(pNewClass == NULL) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup;     <br>        }     <br> <br>        hr = pNewClass-&gt;HrEDKSet(pszClassName, pEntryPoint); <br> <br>        if(FAILED(hr)) <br>        { <br>            delete pNewClass; <br>            goto cleanup; <br>        } <br> <br>        // <br>        // insert class in list of classes. <br>        // <br> <br>        CClassName ** ppcnTmp = &amp;ms_pcnClasses; <br> <br>        for(;;) <br>        { <br>            ASSERTERROR(ppcnTmp != NULL,"NULL ppcnTmp variable"); <br> <br>            if(*ppcnTmp == NULL) <br>                break; <br> <br>            ASSERTERROR(*ppcnTmp != NULL,"NULL *ppcnTmp variable"); <br> <br>            if(pNewClass-&gt;cNameLength() &gt;= (*ppcnTmp)-&gt;cNameLength()) <br>                break;             <br> <br>            ppcnTmp= &amp;((*ppcnTmp)-&gt;m_pcnNext); <br>        } <br> <br>        pNewClass-&gt;m_pcnNext = *ppcnTmp; <br> <br>        *ppcnTmp = pNewClass; <br>    } <br> <br>cleanup: <br> <br>    if ( hr == EDK_E_END_OF_FILE ) <br>    { <br>        // report syntax error to event log <br>        EDKSyntaxError( <br>                (LPWSTR) pszDll, <br>                (LPWSTR) pszEntryPoint, <br>                (LPWSTR) pClasses, <br>                (LPWSTR) pOptions, <br>                (LPWSTR) pPoint); <br>    } <br> <br>    MAPIFREEBUFFER(pClasses); <br>    MAPIFREEBUFFER(pPoint); <br>    MAPIFREEBUFFER(pOptions); <br> <br>    if(pEntryPoint != NULL) <br>    { <br>        pEntryPoint-&gt;Release(); <br>        pEntryPoint = NULL; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--CEDKConvReg::HrEDKSearchOpen--------------------------------------------- <br>// <br>//  DESCRIPTION: Initiate the search for candidate converters. <br>//  Call HrEDKSearchNext to find subsequent converters. <br>//  Must call SearchClose after finished, even if errors <br>//  are returned.   <br>// <br>//  INPUT:  pszConversionPoint  --  what conversion point <br>//          pszContentClass --  what class <br>// <br>//  OUTPUT: pep --  hold candidate conversion if found <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>//--------------------------------------------------------------------- <br>HRESULT CEDKConvReg::HrEDKSearchOpen(       // returns HRESULT <br>    IN LPCWSTR pszConversionPoint,          // what conversion point. <br>    IN LPCWSTR pszContentClass,             // what class <br>    OUT CDllEntryPoint * &amp;pep)              // holds candidate if found. <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br> <br>    DEBUGPRIVATE("CEDKConvReg::HrEDKSearchOpen()\n"); <br> <br>    // check for bad input <br>    hr = CHK_CEDKConvReg_HrEDKSearchOpen(pszConversionPoint,  <br>                                         pszContentClass, pep); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    m_ppep = &amp;pep; <br>    m_pszConversionPoint = pszConversionPoint; <br>    m_pszContentClass = pszContentClass; <br>    m_pcnCurrentClass = ms_pcnClasses; <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKConvReg::HrEDKSearchNext----------------------------------------- <br>// <br>//  DESCRIPTION: Find the next candidate conversion.  HrEDKSearchOpen must be called  <br>//  first.  SearchClose must be called after.  EDK_E_END_OF_FILE indicates that <br>//  no candidates can be found. <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          EDK_E_END_OF_FILE is no candidates found, <br>//                          E_FAIL otherwise. <br>// <br>//--------------------------------------------------------------------- <br>HRESULT CEDKConvReg::HrEDKSearchNext()      // RETURNS: HRESULT <br>{ <br>    HRESULT             hr      =   NOERROR;    // return code <br>    CDllEntryPoint *    pdepTmp =   NULL;       // temporary conversion DLL <br>    HRESULT             hrT     =   NOERROR;    // temporary return code <br>    BOOL                fFound  =   FALSE;      // TRUE if found DLL <br> <br>    DEBUGPRIVATE("CEDKConvReg::HrEDKSearchNext()\n"); <br> <br>    // <br>    //  Search remaining conversions. <br>    // <br>    while (m_pcnCurrentClass != NULL) <br>    {        <br>        CClassName * pcnTmp = m_pcnCurrentClass; <br>        m_pcnCurrentClass = m_pcnCurrentClass-&gt;m_pcnNext; <br> <br>        pdepTmp = pcnTmp-&gt;pEntryPoint(); <br> <br>        hrT = HrStrstriW( <br>                    pcnTmp-&gt;pszClassName(),     // substring <br>                    m_pszContentClass);         // message class <br> <br>        if ( FAILED(hrT) ) <br>        { <br>            // not a match, <br>            // continue. <br>            continue; <br>        } <br> <br>        // Class names "match" <br>        // Check conversion pointer for a match. <br>        LPWSTR lpszCurPoint = pdepTmp-&gt;pszGwPoint(); <br>        if ( lstrcmpiW(m_pszConversionPoint, lpszCurPoint) == 0 ) <br>        { <br>            // <br>            // found a match, break; <br>            // <br>            fFound = TRUE; <br> <br>            break; <br>        } <br>    } <br> <br>    // Check to make sure that conversion was found. <br>    if ( (fFound == FALSE) || (pdepTmp == NULL) ) <br>    { <br>        hr = HR_LOG(EDK_E_END_OF_FILE); <br> <br>        goto cleanup; <br>    } <br> <br>    *m_ppep = pdepTmp; <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKConvReg::EDKSearchClose------------------------------------------ <br>// <br>//  DESCRIPTION: must be called after HrEDKSearchOpen. <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    void <br>// <br>//--------------------------------------------------------------------- <br>void CEDKConvReg::EDKSearchClose() // RETURNS: void <br>{ <br>    DEBUGPRIVATE("CEDKConvReg::EDKSearchClose()\n"); <br> <br>} <br> <br>//$--CEDKConvReg::EDKFree------------------------------------------------- <br>// <br>//  DESCRIPTION: internal routine to free conversion structure. <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    void <br>// <br>//--------------------------------------------------------------------- <br>void CEDKConvReg::EDKFree()    // RETURNS: void <br>{ <br>    DEBUGPRIVATE("CEDKConvReg::EDKFree()\n"); <br> <br>    CClassName * pcnTmp = ms_pcnClasses; <br> <br>    while (pcnTmp != NULL)  <br>    { <br>        CClassName * pcnNext = pcnTmp-&gt;m_pcnNext; <br> <br>        delete pcnTmp; <br> <br>        pcnTmp = pcnNext; <br>    } <br>    ms_pcnClasses = NULL; <br> <br>    REGCLOSEKEY(ms_hkConversions); <br> <br>    // delete the DLL cache.  (This also unloads the DLLs previously <br>    // loaded. <br>    delete ms_pDllCache; <br> <br>    ms_pDllCache = NULL; <br> <br>} <br> <br> <br>//$--CEDKConvReg::EDKDumpMappings----------------------------------------- <br>// <br>//  DESCRIPTION: debug routine to display mappings. <br>// <br>//  INPUT:  none <br>// <br>//  RETURNS:    void <br>// <br>//--------------------------------------------------------------------- <br>void CEDKConvReg::EDKDumpMappings()     // RETURNS void <br>{ <br>    DEBUGPRIVATE("CEDKConvReg::EDKDumpMappings()\n"); <br> <br>    CClassName * pcnTmp = ms_pcnClasses; <br> <br>    // incompatabile with WINWRAP _tprintf(TEXT("Dump of mappings...\n")); <br>    while (pcnTmp != NULL)  <br>    { <br>        pcnTmp-&gt;EDKDump(); <br> <br>        pcnTmp = pcnTmp-&gt;m_pcnNext; <br>    } <br>     <br>} <br> <br>//$--CEDKConvReg::EDKSyntaxError------------------------------------------ <br>// <br>//  DESCRIPTION: debug routine called whenever a syntax error is detected. <br>// <br>//  INPUT:      pszDll  --  DLL key name <br>//              pszEntryPoint   -- entry point name <br>//              pszClass    --  message class key name <br>//              pszOptions  --  conversion options key name <br>//              pszPoint    --  conversion point key name <br>// <br>//  RETURNS:    VOID <br>// <br>//--------------------------------------------------------------------- <br>VOID CEDKConvReg::EDKSyntaxError(         // RETURNS: VOID <br>        IN LPWSTR   pszDll,     // DLL name <br>        IN LPWSTR   pszEntryPoint,  // entry point name <br>        IN LPWSTR   pszClass,   // message class <br>        IN LPWSTR   pszOptions, // conversion options <br>        IN LPWSTR   pszPoint)   // conversion point <br>{ <br>    LPWSTR  lpszBlank   =   L"";    // blank string <br> <br>    LPWSTR  lpszDllName =   lpszBlank;   // conversion DLL name <br>    LPWSTR  lpszEntry   =   lpszBlank;   // entry point name <br>    LPWSTR  lpszPoint   =   lpszBlank;   // conversion point <br>    LPWSTR  lpszClass   =   lpszBlank;   // message class <br>    LPWSTR  lpszOptions =   lpszBlank;   // options <br> <br>    DEBUGPRIVATE("CEDKConvReg::EDKSyntaxError()\n"); <br> <br>    // No check function for this routine.  It is an event <br>    // logging routine and all parameters may be NULL. <br> <br>    m_bSyntaxError = TRUE; <br> <br>    if ( pszDll != NULL ) <br>    { <br>        lpszDllName = pszDll; <br>    } <br> <br>    if ( pszEntryPoint != NULL ) <br>    { <br>        lpszEntry = pszEntryPoint; <br>    } <br> <br>    if ( pszPoint != NULL ) <br>    { <br>        lpszPoint = pszPoint; <br>    } <br> <br>    if ( pszClass != NULL ) <br>    { <br>        lpszClass = pszClass; <br>    } <br> <br>    if ( pszOptions != NULL ) <br>    { <br>        lpszOptions = pszOptions; <br>    } <br> <br>    // Log event to the event log. <br>    EventLogMsgW( <br>            MESGXLAT_CNV_BAD_SYNTAX,    // event identfier <br>            5,                          // # of strings <br>            lpszDllName,                // string 1 <br>            lpszEntry, <br>            lpszClass,                <br>            lpszOptions, <br>            lpszPoint,          <br>            0);                         // # of error codes <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
