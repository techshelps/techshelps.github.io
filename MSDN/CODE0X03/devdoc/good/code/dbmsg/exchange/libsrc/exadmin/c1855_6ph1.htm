<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXADMIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1855"></a>EXADMIN.CPP</h2>
<pre><code>// ----------------------------------------------------------------------------- <br>// ExAdmin.CPP: Implements methods which support Exchange Admin Configuration  <br>//              Extension Dialogs. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#if defined(UNICODE) || defined(_UNICODE) <br>#error EXADMIN cannot be compiled in UNICODE. <br>#endif <br> <br>#include "edkafx.h" <br>#include "ExAdmin.h" <br>#include "helpers.h" <br>#include "ErrCpp.H" <br> <br>#ifdef _DEBUG <br>#undef THIS_FILE <br>static char BASED_CODE THIS_FILE[] = __FILE__; <br>#endif <br> <br>// ----------------------------------------------------------------------------- <br>// Following is used to determine the languages we support <br> <br>struct EnumLangParams <br>{ <br>WORD langRequested; <br>BOOL fFound; <br>}; <br>typedef EnumLangParams*PEnumLangParams; <br> <br>BOOL CALLBACK  EnumResTypesCallback(HANDLE hModule,LPTSTR lpszType,LONG lParam); <br>BOOL CALLBACK  EnumResNamesCallback(HANDLE hModule, LPCTSTR lpszType, <br>   LPTSTR lpszName, LONG lParam); <br>BOOL CALLBACK  fEnumLangProc(HANDLE hMod, LPCTSTR ptzType, LPCTSTR ptzName, WORD wLang, LONG lParam); <br> <br>// ----------------------------------------------------------------------------- <br> <br>__inline HRESULT CHK_HrGeneral( <br>    IN VOID* pvExtensionData,       // Extension data for all sheets <br>    IN HWND  hDlg)                  // Window handle of the property sheet. <br>{ <br>    if( !hDlg) <br>        RETURN( E_INVALIDARG); <br> <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br> <br>__inline HRESULT CHK_bInitSheet( <br>    IN  ADMIN_ObjectInfo* poi,              // Server name &amp; other DNs. <br>    IN  ULONG             fFlags,                        <br>    OUT ADMIN_SheetInfo** ppSheetInfo,      // Property sheet description array <br>    OUT UINT*             pcsi,             // Number of property sheets <br>    OUT VOID**            ppvNotUsed) // Local data (NOT USED) <br>{ <br>    if( !TEST_READ_PTR( poi, sizeof( ADMIN_ObjectInfo))) <br>        RETURN( E_INVALIDARG); <br> <br>    if( !TEST_WRITE_PTR( ppSheetInfo, sizeof( VOID *))) <br>        RETURN( E_INVALIDARG); <br> <br>    if( !TEST_WRITE_PTR( pcsi, sizeof( UINT))) <br>        RETURN( E_INVALIDARG); <br>     <br>    if( !TEST_WRITE_PTR( ppvNotUsed, sizeof( VOID *))) <br>        RETURN( E_INVALIDARG); <br> <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br> <br>__inline HRESULT CHK_ADMIN_Initialize( <br>    IN  ADMIN_AdministratorConnections* pAdminConnections,  // Global Administrator Connections <br>    IN  ADMIN_AdministratorFunction*    pAdminFunctions,    // Global admin function <br>    OUT ADMIN_ExtensionFunction**       ppExtensionFunction)// Global Extension function <br>{ <br>    if( !TEST_READ_PTR( pAdminConnections, sizeof( ADMIN_AdministratorConnections))) <br>        RETURN( E_INVALIDARG); <br> <br>    if( !TEST_READ_PTR( pAdminFunctions, sizeof( ADMIN_AdministratorFunction))) <br>        RETURN( E_INVALIDARG); <br> <br>    if( !TEST_WRITE_PTR( ppExtensionFunction, sizeof( VOID *))) <br>        RETURN( E_INVALIDARG); <br> <br>    if( !TEST_FUNCTION_PTR( (FARPROC) pAdminFunctions-&gt;pfnGetObjectData)) <br>        RETURN( E_INVALIDARG); <br> <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br> <br>__inline HRESULT CHK_LoadStringA( <br>UINT wID,// ID of resource <br>LPSTR szBuf,// Buffer to store resource <br>int cchBuf)// Size of buffer in chars <br>{ <br>    if( wID == 0) <br>        RETURN( E_INVALIDARG); <br> <br>    if( !TEST_WRITE_PTR( szBuf, cchBuf)) <br>        RETURN( E_INVALIDARG); <br> <br>    return( NOERROR); <br>}    <br> <br>__inline HRESULT CHK_LoadStringW( <br>UINT wID,// ID of resource <br>LPWSTR wzBuf,// Buffer to store resource <br>int cchBuf)// Size of buffer in chars <br>{ <br>    if( wID == 0) <br>        RETURN( E_INVALIDARG); <br> <br>    if( !TEST_WRITE_PTR( wzBuf, sizeof( WCHAR ) * cchBuf)) <br>        RETURN( E_INVALIDARG); <br> <br>    return( NOERROR); <br>}    <br> <br>//$--CInitDLL::InitInstance()--------------------------------------------------- <br>// MFC initialization for the DLL.  No multi-threaded code allowed. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CInitDLL::InitInstance() <br>{ <br>    // Any DLL initialization goes here. <br>    TRACE0("InitDLL.DLL initializing\n"); <br>    SetDialogBkColor();     // Grey dialogs in the DLL as well. <br>    return TRUE; <br>} <br> <br>//$--CInitDLL::ExitInstance()--------------------------------------------------- <br>// Exit MFC for the DLL gracefully.  No multi-threaded code allowed. <br>// ----------------------------------------------------------------------------- <br> <br>int CInitDLL::ExitInstance() <br>{ <br>    // Any DLL termination goes here (WEP-like code). <br>    return CWinApp::ExitInstance(); <br>} <br> <br>//$--CInitDLL::~CInitDLL()------------------------------------------------------ <br>// Detach from property sheet window of Admin program then delete the CWnd we  <br>// created in AdminDlgProc().  The reason we attach to the property sheet window <br>// of admin is so that MFC will give us Modal dialog boxes. <br>// ----------------------------------------------------------------------------- <br> <br>CInitDLL::~CInitDLL() <br>{ <br>    if( m_pMainWnd) <br>    { <br>        m_pMainWnd-&gt;Detach(); <br>        delete m_pMainWnd; <br>        m_pMainWnd = NULL; <br>    } <br>} <br> <br>//$--CAdmin::HrSubclassWindow()------------------------------------------------- <br>// Make subclassing windows to controls with error checking a little easier. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CADialog::HrSubclassWindow(  <br>    int   nID,  // Id of a control in this dialog. <br>    CWnd&amp; Wnd)  // Reference to MFC CWnd object to connect to Windows control. <br>{ <br>    CWnd* pWnd = GetDlgItem( nID); <br>    if( !pWnd) <br>    {   // Could not find id (%d) of control in dialog. <br>        RETURN( E_FAIL); <br>    } <br> <br>    // Connect the windows control to a MFC CWnd derived object. <br>    Wnd.SubclassWindow( pWnd-&gt;GetSafeHwnd()); <br>    return( NOERROR); <br>} <br> <br>//$--AdminDlgProc()------------------------------------------------------------- <br>// Subclasses the dialog the first time in and always calls the MFC dialog proc <br>// to handle the message. When message == WM_INITDIALOG then lParam is a pointer <br>// to the CAdminDialog. <br>// ----------------------------------------------------------------------------- <br> <br>LRESULT CALLBACK AdminDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)   <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    if( message == WM_INITDIALOG) <br>    {   // First time using this dialog so subclass its window so that MFC <br>        // code will work as expected. <br>        CAdminDialog* pAdminDlg = (CAdminDialog*) lParam; <br>        pAdminDlg-&gt;SubclassWindow( hDlg); <br> <br>        // We attach to the property sheet window of admin so that MFC will give us  <br>        // modal dialog boxes.  We don't want to subclass this window because we  <br>        // would start receiving it's messages and we don't want that. <br>        if( !AfxGetApp()-&gt;m_pMainWnd) <br>        {   // We only need to do this once. <br>            AfxGetApp()-&gt;m_pMainWnd = new CWnd; <br>            AfxGetApp()-&gt;m_pMainWnd-&gt;Attach( GetParent( hDlg)); <br>        } <br>    } <br> <br>    // Prepare to call MFC dialog proc to handle the message. <br>    MSG msg; <br>    msg.hwnd = hDlg; <br>    msg.message = message; <br>    msg.wParam = wParam; <br>    msg.lParam = lParam; <br> <br>    return( AfxDlgProc( hDlg, message, wParam, lParam)); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Message map for CAdminDialog. <br>// ----------------------------------------------------------------------------- <br> <br>BEGIN_MESSAGE_MAP(CAdminDialog, CDialog) <br>    //{{AFX_MSG_MAP(CAdminDialog) <br>    ON_MESSAGE( WM_CHILDACTIVATE, OnChildActivate) <br>    //}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>//$--CAdminDialog::CAdminDialog()----------------------------------------------- <br>// CONSTRUCTOR -- Records static information to be used later. <br>// ----------------------------------------------------------------------------- <br> <br>CAdminDialog::CAdminDialog(  <br>    UINT iddDialog,     // The resource ID of your dialog. <br>    UINT idsName,       // The resource ID of the string containing the name <br>                        // used by admin for the tab of your property sheet. <br>    LPSTR lpszBlobName)// Name of extension data blob. <br>    : CADialog()        // Construct our ancestor. <br>{ <br>    // Remember the caller's dialog, property sheet names, and extension blob name. <br>    m_iddDialog = iddDialog; <br>    m_idsName = idsName; <br> <br>    // Remember the blob name as a wide string.  The pointer will  <br>    // be NULL if the derived class does not have extension data. <br>    if( !lpszBlobName) <br>        m_lpwszBlobName = NULL; <br>    else <br>    { <br>        CHRESULT hr = HrStrAToStrW( lpszBlobName, &amp;m_lpwszBlobName); <br>        if( FAILED( hr)); <br>    } <br> <br>    // Initialize other member variables. <br>    m_cExtData = 0; <br>    m_lpbExtData = NULL; <br>    m_cExtProps = 0; <br>    m_lpExtProps = NULL; <br>     <br>    // Add the "this" pointer of the dialog to a static list.  We need to know <br>    // about all dialogs so we can tell admin about them later. <br>    m_DlgList.AddTail( (void*) this); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// DESTRUCTOR  <br>// ----------------------------------------------------------------------------- <br> <br>CAdminDialog::~CAdminDialog() <br>{ <br>    MAPIFREEBUFFER( m_lpbExtData); <br>    MAPIFREEBUFFER( m_lpExtProps); <br>    MAPIFREEBUFFER( m_lpwszBlobName); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// If the caller does not pass in the lpszCaption then use the title of the  <br>// parent window for the default title of our message box. <br>// ----------------------------------------------------------------------------- <br> <br>int CAdminDialog::MessageBox( LPCSTR lpszText, LPCSTR lpszCaption, UINT nType) <br>{ <br>    if( lpszCaption == NULL) <br>        lpszCaption = m_sMsgBoxCaption; <br>    return( CWnd::MessageBox( lpszText, lpszCaption, nType)); <br>} <br> <br>int CAdminDialog::MessageBox2( int IDText, int IDCaption, UINT nType) <br>{ <br>    CString MBText; <br>    CString MBCaption; <br>int nSize = -1; <br>int nLen; <br> <br>// try buffer size of 256, then larger size until entire string is retrieved <br>do <br>{ <br>nSize += 256; <br>nLen = LoadStringA(IDText, MBText.GetBuffer(nSize), nSize+1); <br>} while (nLen == nSize); <br>MBText.ReleaseBuffer(); <br> <br>if( IDCaption == 0) <br>        MBCaption = m_sMsgBoxCaption; <br>else <br>{ <br>nSize = -1; <br>do <br>{ <br>nSize += 256; <br>nLen = LoadStringA( IDCaption, MBCaption.GetBuffer(nSize), nSize+1); <br>} while (nLen == nSize); <br>MBCaption.ReleaseBuffer(); <br>} <br> <br> <br>    return( CWnd::MessageBox( MBText, MBCaption, nType)); <br>} <br> <br>//$--CAdminDialog::LoadDialogTemplate()----------------------------------------- <br>// Use this function to create child dialog box templates.  It will ensure that  <br>// the correct language and fonts are used.   <br>// <br>// To create the dialog use the default constructor (no parameters) and then use <br>// the CDialog::InitModalIndirect() function to initialize the dialog.  Then you <br>// can call CDialog::DoModal() to process the dialog. <br>// ----------------------------------------------------------------------------- <br> <br>const HGLOBAL CAdminDialog::LoadDialogTemplate( UINT iddDialog) <br>{ <br>    HGLOBAL hDlgTemplate = NULL; <br> <br>    if( m_pAdminFunctions-&gt;pfnLoadDialogResource( AfxGetInstanceHandle(), <br>                          iddDialog, GetLanguageId(), (LPBYTE*) &amp;hDlgTemplate)) <br>        return( hDlgTemplate); <br>    else <br>        return( NULL); <br>} <br> <br>//$--CAdminDialog::LoadString()------------------------------------------------ <br>// Loads a string resource by id and language <br>// and (A version) converts to the current ANSI code page. <br>// Note that strings are stored in blocks of 16, and the ID gives <br>// us the number of the block, and the offset into the block. <br>// ----------------------------------------------------------------------------- <br>int CAdminDialog::LoadStringA(UINT wID, LPSTR szBuf, int cchBuf) <br>{ <br>    UINT    block, num; <br>    int     len = 0;     <br>    HRSRC   hRC = NULL; <br>    HGLOBAL hgl = NULL;; <br>    LPWSTR  str = NULL; <br>    register UINT i; <br>     <br>    DEBUGPUBLIC( "CAdminDialog::LoadStringA()\n"); <br>CHRESULT hr = CHK_LoadStringA( wID, szBuf, cchBuf); <br>    if( FAILED( hr)) <br>        return( 0 ); <br> <br>szBuf[0] = '\0'; <br> <br>    block = (wID &gt;&gt; 4) + 1;// compute block number <br>    num = wID &amp; 0xf;// compute offset into block <br>     <br>    hRC = FindResourceEx(AfxGetInstanceHandle(), RT_STRING, MAKEINTRESOURCE(block), GetLanguageId()); <br>    if (!hRC)  <br>goto Error; <br> <br>hgl = LoadResource(AfxGetInstanceHandle(), hRC); <br>if (!hgl) <br>goto Error; <br> <br>    str = (LPWSTR)LockResource(hgl); <br>    if (!str)  <br>goto Error; <br> <br>// Move up block to string we want <br>for (i = 0; i &lt; num; i++) <br>    str += *str + 1; <br> <br>// convert the string to current code page <br>len = WideCharToMultiByte(CP_ACP, <br>  WC_COMPOSITECHECK, <br>  str + 1, *str, <br>  szBuf, cchBuf - 1, <br>  NULL, NULL); <br> <br>szBuf[min(cchBuf-1, *str)] = '\0'; <br> <br>Error: <br> <br>if (hgl) <br>{ <br>UnlockResource(hgl);// maybe not needed <br>    FreeResource(hgl);    // maybe not needed <br>} <br> <br>    return len; <br>} <br> <br>int CAdminDialog::LoadStringW(UINT wID, LPWSTR wzBuf, int cchBuf) <br>{ <br> <br>    UINT    block, num; <br>    int     len = 0;     <br>    HRSRC   hRC = NULL; <br>    HGLOBAL hgl = NULL; <br>    LPWSTR  str = NULL; <br>    register UINT i; <br>     <br>    DEBUGPUBLIC( "CAdminDialog::LoadStringW()\n"); <br>CHRESULT hr = CHK_LoadStringW( wID, wzBuf, cchBuf); <br>    if( FAILED( hr)) <br>        return( 0 ); <br> <br>wzBuf[0] = TEXT('\0'); <br> <br>    block = (wID &gt;&gt; 4) + 1;// compute block number <br>    num = wID &amp; 0xf;// compute offset into block <br>     <br>    hRC = FindResourceEx(AfxGetInstanceHandle(), RT_STRING, MAKEINTRESOURCE(block), GetLanguageId()); <br>    if (!hRC)  <br>goto Error; <br> <br>hgl = LoadResource(AfxGetInstanceHandle(), hRC); <br>if (!hgl) <br>goto Error; <br> <br>    str = (LPWSTR)LockResource(hgl); <br>    if (str)  <br>    { <br>for (i = 0; i &lt; num; i++) <br>    str += *str + 1; <br>wcsncpy(wzBuf, str + 1, min(cchBuf - 1, *str)); <br>    } <br> <br>wzBuf[min(cchBuf-1, *str) ] = '\0'; <br> <br>len = *str + 1; <br> <br>Error: <br> <br>if (hgl) <br>{ <br>UnlockResource(hgl);// maybe not needed <br>    FreeResource(hgl);    // maybe not needed <br>} <br> <br>    return len; <br>} <br> <br>//$--CAdminDialog::GetExtBin()-------------------------------------------------- <br>// Use this to get a binary extension data property. <br>// ----------------------------------------------------------------------------- <br> <br>LPSBinary CAdminDialog::GetExtBinary( <br>    ULONG iProp)        // Index of property. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::GetExtBin()\n"); <br>    CHRESULT hr = CHK_HrExtData( iProp, PT_BINARY); <br>    if( FAILED( hr)) <br>        return( NULL); <br>     <br>    return( &amp;m_lpExtProps[iProp].Value.bin); <br>} <br> <br>//$--CAdminDialog::GetExtString()----------------------------------------------- <br>// Use this to get a string extension data property. <br>// ----------------------------------------------------------------------------- <br> <br>LPSTR CAdminDialog::GetExtString( <br>    ULONG iProp)        // Index of property. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::GetExtString()\n"); <br>    CHRESULT hr = CHK_HrExtData( iProp, PT_STRING8); <br>    if( FAILED( hr)) <br>        return( NULL); <br> <br>    return( m_lpExtProps[iProp].Value.lpszA); <br>} <br> <br>//$--CAdminDialog::GetExtLong()------------------------------------------------- <br>// Use this to get a long extension data property. <br>// ----------------------------------------------------------------------------- <br> <br>LONG CAdminDialog::GetExtLong( <br>    ULONG iProp)        // Index of property. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::GetExtLong()\n"); <br>    CHRESULT hr = CHK_HrExtData( iProp, PT_LONG); <br>    if( FAILED( hr)) <br>        return( -1); <br>     <br>    return( m_lpExtProps[iProp].Value.l); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Use this to get a boolean extension data property. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CAdminDialog::GetExtBool( <br>    ULONG iProp)        // Index of property. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::GetExtBool()\n"); <br>    CHRESULT hr = CHK_HrExtData( iProp, PT_BOOLEAN); <br>    if( FAILED( hr)) <br>        return( FALSE); <br>     <br>    return( m_lpExtProps[iProp].Value.b); <br>} <br> <br>//$--CAdminDialog::GetExtSysTime()---------------------------------------------- <br>// Use this to get a system time extension data property. <br>// ----------------------------------------------------------------------------- <br> <br>FILETIME CAdminDialog::GetExtSysTime( <br>    ULONG iProp)        // Index of property. <br>{ <br>    FILETIME ft = {0}; <br>     <br>    DEBUGPUBLIC( "CAdminDialog::GetExtSysTime()\n"); <br>    CHRESULT hr = CHK_HrExtData( iProp, PT_SYSTIME); <br>    if( FAILED( hr)) <br>        return( ft); <br>     <br>    return( m_lpExtProps[iProp].Value.ft); <br>} <br> <br>//$--CAdminDialog::HrModExtBin()------------------------------------------------ <br>// Use this to modify a binary extension data property.  It will allocate more <br>// memory only if the new buffer is larger. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrModExtBinary( <br>    IN ULONG  iProp,    // Index of property <br>    IN ULONG  cb,       // Count of new data bytes. <br>    IN const LPBYTE lpNew)    // New data bytes. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::HrModExtBin()\n"); <br>    CHRESULT hr = CHK_HrModExtBin( iProp, cb, lpNew); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // New binary data will be copied to this address.  <br>    LPBYTE lpb = m_lpExtProps[ iProp].Value.bin.lpb; <br>     <br>    if( cb &gt; m_lpExtProps[ iProp].Value.bin.cb) <br>    {   // New binary data is too big so alloacate a new buffer to stick it in. <br>        CHRESULT hr = MAPIAllocateMore( cb, m_lpExtProps, (LPVOID*) &amp;lpb); <br>        if( FAILED( hr)) <br>            RETURN( hr); <br> <br>        // Replace old buffer ptr to new one. <br>        m_lpExtProps[ iProp].Value.bin.lpb = lpb;             <br>    } <br>     <br>    // Copy new data to MAPI buffer. <br>    memmove( lpb, lpNew, cb); <br>    m_lpExtProps[ iProp].Value.bin.cb = cb; <br>    return( NOERROR); <br>} <br> <br>//$--CAdminDialog::HrModExtString()--------------------------------------------- <br>// Use this to modify a string extension data property.  It will allocate more <br>// memory only if the new string is larger. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrModExtString( <br>    IN ULONG   iProp,    // Index of property <br>    IN LPCSTR lpszNew)  // New data string. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::HrModExtString()\n"); <br>    CHRESULT hr = CHK_HrModExtString( iProp, lpszNew); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Size of original string. <br>    ULONG cb = cbStrLenA( m_lpExtProps[ iProp].Value.lpszA); <br>     <br>    // Size of new string. <br>    ULONG cbNew = cbStrLenA( lpszNew); <br>     <br>    // New binary data will be copied to this address.  <br>    LPSTR lpsz = m_lpExtProps[ iProp].Value.lpszA; <br>     <br>    if( cbNew &gt; cb) <br>    {   // New binary data is too big so alloacate a new buffer to stick it in. <br>        CHRESULT hr = MAPIAllocateMore( cbNew, m_lpExtProps, (LPVOID*) &amp;lpsz); <br>        if( FAILED( hr)) <br>            RETURN( hr); <br> <br>        // Replace old buffer ptr to new one. <br>        m_lpExtProps[ iProp].Value.lpszA = lpsz; <br>    } <br>     <br>    // Copy new data to MAPI buffer. <br>    memmove( lpsz, lpszNew, cbNew); <br>    return( NOERROR); <br>} <br> <br>//$--CAdminDialog::HrModExtLong()----------------------------------------------- <br>// Use this to modify a long extension data property. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrModExtLong( <br>    IN ULONG  iProp,    // Index of property <br>    IN LONG   lNew)     // New long data value. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::HrModExtLong()\n"); <br>    CHRESULT hr = CHK_HrExtData( iProp, PT_LONG); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Copy new data to MAPI buffer. <br>    m_lpExtProps[ iProp].Value.l = lNew; <br>    return( NOERROR); <br>} <br> <br>//$--CAdminDialog::HrModExtBool()----------------------------------------------- <br>// Use this to modify a boolean extension data property. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrModExtBool( <br>    IN ULONG  iProp,    // Index of property <br>    IN BOOL   bNew)     // New boolean data value. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::HrModExtBool()\n"); <br>    CHRESULT hr = CHK_HrExtData( iProp, PT_BOOLEAN); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Copy new data to MAPI buffer. <br>    m_lpExtProps[ iProp].Value.b = bNew; <br>    return( NOERROR); <br>} <br> <br>//$--CAdminDialog::HrModExtSysTime()----------------------------------------------- <br>// Use this to modify a SysTime extension data property. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrModExtSysTime( <br>    IN ULONG    iProp,    // Index of property <br>    IN FILETIME ftNew)    // New boolean data value. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::HrModExtSysTime()\n"); <br>    CHRESULT hr = CHK_HrExtData( iProp, PT_SYSTIME); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Copy new data to MAPI buffer. <br>    m_lpExtProps[ iProp].Value.ft = ftNew; <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Set the extension data properties to an existing property value array.  This <br>// can be used to create a blob for the first time.  To do this initialized the <br>// lpExtProps array with just property types and no real data.  Then use the  <br>// HrMod...() functions to set the values. <br>// <br>// NOTE: Since this MUST be a MAPI allocated buffer, and since it is not as easy <br>//       to initialize a MAPI allocated buffer as a static one, we copy the  <br>//       buffer the user passes in.  Therefore the user will need to free their <br>//       buffer if it is not a static one. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrSetExtProps( <br>    ULONG        cExtProps,     // Count of extension data properties. <br>    LPSPropValue lpExtProps)    // Array of properties to set extension data to. <br>{ <br>    DEBUGPUBLIC( "CAdminDialog::HrSetExtProps()\n"); <br>    CHRESULT hr = CHK_HrSetExtProps( cExtProps, lpExtProps); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Free old extension properties and set to the new ones.  We do not <br>    // free the old blob pointer here because its existence signifies that <br>    // we are not creating a new blob. <br>    MAPIFREEBUFFER( m_lpExtProps); <br>    m_cExtProps = 0; <br>     <br>    // Make sure that all property tags have a non zero property id. This is done  <br>    // because ScCountProps() does a validation to make sure all properties have a  <br>    // non zero id.  This should be fixed in some future version of MAPI. <br>    ULONG iProp = 0; <br>    for( iProp = 0; iProp &lt; cExtProps; iProp++) <br>    { <br>        if( PROP_ID( lpExtProps[ iProp].ulPropTag) == 0) <br>            lpExtProps[ iProp].ulPropTag = PROP_TAG( PROP_TYPE( lpExtProps[ iProp].ulPropTag), 1); <br>    } <br> <br>    // Count the bytes needed for the new property array. <br>    ULONG cBytes = 0; <br>    hr = ScCountProps( cExtProps, lpExtProps, &amp;cBytes); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br>     <br>    // Allocate a new buffer to hold the copied properties. <br>    hr = MAPIAllocateBuffer( cBytes, (LPVOID*) &amp;m_lpExtProps); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br>    memset( m_lpExtProps, 0, cBytes); <br> <br>    // Copy the subscriber properties to the new buffer. <br>    ULONG cBytesCopied = 0; <br>    hr = ScCopyProps( cExtProps, lpExtProps, m_lpExtProps, &amp;cBytesCopied); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br>    ASSERTERROR( cBytes == cBytesCopied, "ScCountProps &amp; ScCopyProps are inconsistent!"); <br>     <br>    // We completed this successfuly so set the count. <br>    m_cExtProps = cExtProps; <br>     <br>    DataHasChanged(); <br> <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Loads the extension data into a buffer that is contained in this object.  Use <br>// GetExtCount() and GetExtData() to get individual items. Use the HrMod...()  <br>// functions to modify a property value. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrLoadExtData() <br>{ <br>    MAPIFREEBUFFER( m_lpbExtData); <br>    m_cExtData = 0; <br> <br>    MAPIFREEBUFFER( m_lpExtProps); <br>    m_cExtProps = 0; <br> <br>    if( m_lpwszBlobName == NULL) <br>        return( NOERROR); <br>     <br>    // Determine the size of the buffer needed to hold the data. <br>    UINT cTemp; <br>    RC rc = m_pAdminFunctions-&gt;pfnGetObjectDataSize( GetSafeHwnd(), m_lpwszBlobName, &amp;cTemp); <br>    if(RC_FAILED(rc)) <br>        RETURN( E_FAIL); <br>     <br>    // Convert UINT to a ULONG. <br>    m_cExtData = cTemp; <br> <br>    // Allocate a buffer to hold the extension data. <br>    CHRESULT hr = MAPIAllocateBuffer( m_cExtData, (LPVOID*) &amp;m_lpbExtData); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Get the extension data. <br>    rc = m_pAdminFunctions-&gt;pfnGetObjectData( GetSafeHwnd(), m_lpwszBlobName, m_lpbExtData, m_cExtData); <br>    if( RC_FAILED(rc)) <br>        RETURN( E_FAIL); <br> <br>    // Unpack the data into a MAPI style property value array. <br>    hr = HrCfgUnpackData( m_cExtData, m_lpbExtData, NULL, &amp;m_cExtProps, &amp;m_lpExtProps); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Saves the extension data that is held in a buffer contained in this object. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrSaveExtData() <br>{ <br>    if( m_lpwszBlobName == NULL) <br>        return( NOERROR); <br> <br>    if( m_cExtProps == 0 || !TEST_READ_PTR( m_lpExtProps, sizeof( SPropValue) * m_cExtProps)) <br>        return( E_FAIL); <br> <br>    // If we did not have extension blob data then we are creating a new blob. <br>    BOOL bNew = (m_lpbExtData == NULL); <br>    MAPIFREEBUFFER( m_lpbExtData); <br>    m_cExtData = 0; <br> <br>    // Pack the configuration data from a MAPI style property value array. <br>    CHRESULT hr = HrCfgPackDataW( m_lpwszBlobName, m_cExtProps, m_lpExtProps, &amp;m_cExtData, &amp;m_lpbExtData); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Set the extension data. <br>    RC rc = m_pAdminFunctions-&gt;pfnSetObjectData( GetSafeHwnd(), m_lpbExtData, m_cExtData, bNew); <br>    if( RC_FAILED(rc)) <br>        RETURN( E_FAIL); <br>     <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Add service to be tracked by Server Monitor. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrAddService( <br>    IN LPSTR lpszServiceName)      // SHORT name of the service. <br>{ <br>    // Not UNICODE, so convert to wide string. <br>    CMAPIBuffer&lt; LPWSTR&gt; lpwszServiceName; <br>    CHRESULT hr = HrStrAToStrW( lpszServiceName, &amp;lpwszServiceName); <br>    if( FAILED( hr)) <br>        return( hr); <br> <br>    if( !m_pAdminFunctions-&gt;pfnAddService( GetSafeHwnd(), lpwszServiceName)) <br>        RETURN( E_FAIL); <br> <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Remove service to be tracked by Server Monitor. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CAdminDialog::HrRemoveService(  <br>    IN LPSTR lpszServiceName)      // SHORT name of the service. <br>{ <br>    // Not UNICODE, so convert to wide string. <br>    CMAPIBuffer&lt; LPWSTR&gt; lpwszServiceName; <br>    CHRESULT hr = HrStrAToStrW( lpszServiceName, &amp;lpwszServiceName); <br>    if( FAILED( hr)) <br>        return( hr); <br> <br>    if( !m_pAdminFunctions-&gt;pfnRemoveService( GetSafeHwnd(), lpwszServiceName)) <br>        RETURN( E_FAIL); <br> <br>    return( NOERROR); <br>} <br> <br>//$--CAdminDialog::GetNameList()------------------------------------------------ <br>// You MUST release the array with FreeNameList. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CAdminDialog::GetNameList(  <br>    OUT int*     lpcNameList,       // Ptr to number of WIDE strings in the array. <br>    OUT LPWSTR** lppwszNameList)    // Ptr to a ptr of WIDE string array.   <br>{ <br>    BOOL fRes = m_pAdminFunctions-&gt;pfnGetNameList( GetSafeHwnd(), lpcNameList, lppwszNameList); <br>    if( !fRes) <br>        RETURN( E_FAIL); <br> <br>    return( NOERROR); <br>} <br> <br>//$--CAdminDialog::SetNameList()------------------------------------------------ <br>// Set the name list. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CAdminDialog::SetNameList( <br>    IN int      cNameList,        // Number of WIDE strings in the array. <br>    IN LPWSTR*  lpwszNameList)    // Ptr to a WIDE string array.   <br>{ <br>    BOOL fRes = m_pAdminFunctions-&gt;pfnSetNameList( GetSafeHwnd(), cNameList, lpwszNameList); <br>    if( !fRes ) <br>        RETURN( E_FAIL); <br> <br>    return( NOERROR); <br>} <br> <br>//$--CAdminDialog::fSetLcid()--------------------------------------------------- <br>// Set the LCID we will use.   </code></pre>
<p>
</p>
<pre><code>// Note that Exchange Admin could ask for any locale, but this dll typically only <br>// supports a subset.  This function checks to see if the dll has resources of the  <br>// requested locale, and sets a default if not.  <br>// ----------------------------------------------------------------------------- <br>void CAdminDialog::SetLcid(LCID lcid) <br>{ <br>EnumLangParams ELP; <br> <br>// We're just concerned with the primary language <br>ELP.langRequested = MAKELANGID(PRIMARYLANGID( LANGIDFROMLCID(lcid) ), SUBLANG_NEUTRAL); <br>ELP.fFound = FALSE; <br> <br>    // Check that we support this language, use default if not <br>    // This check works by walking the resource tree. It stops as soon as one resource with  <br>    // a matching language is found. <br>if (!EnumResourceTypes(AfxGetInstanceHandle(), (ENUMRESTYPEPROC) EnumResTypesCallback, (LONG) &amp;ELP)) <br>{ <br>// Note: EnumResourceTypes returns false if one of the callbacks returns false <br>// (indicating that the search can be stopped) <br>} <br> <br>// Default to English <br>if (ELP.fFound) <br>m_lcid = ELP.langRequested; <br>else <br>m_lcid = MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL),  SORT_DEFAULT); <br> <br>return;  // We always succeed <br>} <br> <br>// $--CAdminDialog::bInitSheet()------------------------------------------------ <br>// This function initializes the property sheet info and returns it to ADMIN. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CAdminDialog::bInitSheet(              // RETURNS: TRUE if initialization OK <br>    IN  ADMIN_ObjectInfo* poi,              // Server name &amp; other DNs. <br>    IN  ULONG             fFlags,                        <br>    OUT ADMIN_SheetInfo** ppSheetInfo,      // Property sheet description array <br>    OUT UINT*             pcsi,             // Number of property sheets <br>    OUT VOID**            ppNotUsed)        // Local data (NOT USED) <br>{ <br>    ASSERT_READ_PTR( poi, sizeof( ADMIN_ObjectInfo), "Admin sent us a bad pointer."); <br> <br>    // Remember these for later usage. <br>    m_pAdminObjectInfo = poi; <br>    m_bReadOnly = (fFlags &amp; fxfReadOnly) &gt; 0; <br> <br>  <br>// Choose the language we will display <br>SetLcid( poi-&gt;lcid ); <br> <br> <br>// Allocate memory for the property sheet info array. <br>    *pcsi = m_DlgList.GetCount(); <br>    m_pSheetInfo = new ADMIN_SheetInfo[ *pcsi]; <br>    if( !m_pSheetInfo) <br>    {   // Memory allocation error! <br>        return( FALSE); <br>    } <br> <br>    // Initialize Admin property sheet info array. <br>    POSITION pos = m_DlgList.GetHeadPosition(); <br>    ADMIN_SheetInfo* pSheetInfo = m_pSheetInfo; <br>    while( pos) <br>    {   // Tell admin about all of the CAdminDialog derived objects that <br>        // have been instantiated. <br>        CAdminDialog* pAdminDlg = (CAdminDialog*) m_DlgList.GetNext( pos); <br> <br>        pSheetInfo-&gt;hInstance = AfxGetInstanceHandle(); <br>        pSheetInfo-&gt;iddDialog = pAdminDlg-&gt;m_iddDialog; <br>        pSheetInfo-&gt;lpfnDlgProc = (DLGPROC) AdminDlgProc; <br>        pSheetInfo-&gt;idsName = pAdminDlg-&gt;m_idsName; <br>        pSheetInfo-&gt;lParam = (LPARAM) pAdminDlg; <br>        pSheetInfo-&gt;langid = GetLanguageId(); <br>         <br>        pSheetInfo ++; <br>    } <br> <br>    // Set return values. <br>    *ppSheetInfo = m_pSheetInfo; <br>    *ppNotUsed = NULL; <br> <br>    return( TRUE);  // TRUE indicates success. <br>} <br> <br>// $--CAdminDialog::DeinitSheet()----------------------------------------------- <br>// Admin calls this when the property sheet dialog box is about to be removed  <br>// and after the OnDestroy() functions of the individual property page dialogs <br>// have been called. <br>// ----------------------------------------------------------------------------- <br> <br>void CAdminDialog::DeinitSheet(         // Returns nothing <br>    IN VOID* pNotUsed)           // Extension data.  <br>{ <br>    delete m_pSheetInfo; <br>    m_pSheetInfo = NULL; <br>} <br> <br>// $--CAdminDialog::FindDlg()--------------------------------------------------- <br>// Finds and returns a pointer to a CAdminDialog object using its dialog handle. <br>// ----------------------------------------------------------------------------- <br> <br>CAdminDialog* CAdminDialog::FindDlg( HWND hDlg) <br>{ <br>    POSITION pos = m_DlgList.GetHeadPosition(); <br>    while( pos) <br>    {   // Get pointer to next CAdminDialog object and see if its window  <br>        // handle matches the one we are looking for. <br>        CAdminDialog* pAdminDlg = (CAdminDialog*) m_DlgList.GetNext( pos); <br>        if( pAdminDlg-&gt;m_hWnd == hDlg) <br>            return( pAdminDlg);             // Found it! <br>    } <br>    return( NULL);      // Not found. <br>} <br> <br>// $--CAdminDialog::ADMIN_Initialize()------------------------------------------ <br>// Helper function used to access private and protected members. <br>// ----------------------------------------------------------------------------- <br> <br>VOID CAdminDialog::ADMIN_Initialize(                        // Returns nothing. <br>    IN  ADMIN_AdministratorConnections* pAdminConnections,  // Global Administrator Connections <br>    IN  ADMIN_AdministratorFunction*    pAdminFunctions)    // Global admin function <br>{ <br>    if( m_pMAPISession != pAdminConnections-&gt;psesMapi) <br>    {   // Add a reference to the admin's MAPI session. <br>        m_pMAPISession = pAdminConnections-&gt;psesMapi; <br>        m_pAddrBook = pAdminConnections-&gt;pab; <br>        m_pABContainer = pAdminConnections-&gt;pabContainer; <br>    } <br> <br>    m_pAdminFunctions = pAdminFunctions; <br>} <br> <br>// $--CAdminDialog::OnInitDialog()---------------------------------------------- <br>// Calls the admin function to set the icon and title for the property sheet. <br>// Make sure your derived classes OnInitDialog() calls this function. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CAdminDialog::OnInitDialog() <br>{ <br>    CDialog::OnInitDialog(); <br>     <br>    // Get the title of the parent window to use as the default  <br>    // caption of our message boxes. <br>    GetParent()-&gt;GetWindowText( m_sMsgBoxCaption); <br> <br>    // Set the icon and title for this dialog. <br>    m_pAdminFunctions-&gt;pfnSetIcon( m_hWnd, IDC_ADMINICON); <br>    m_pAdminFunctions-&gt;pfnSetTitle( m_hWnd, IDC_TITLE); <br> <br>    // Load the extension data if there is any. <br>    CHRESULT hr = HrLoadExtData(); <br>    if( FAILED( hr)); <br> <br>    return TRUE;  // Return TRUE unless you set the focus to a control. <br>} <br> <br>//$--CAdminDialog::OnChildActivate()-------------------------------------------- <br>// This gets called when we receive a WM_CHILDACTIVATE message.  This indicates <br>// that the property sheet has just been brought into focus. <br>// ----------------------------------------------------------------------------- <br> <br>LONG CAdminDialog::OnChildActivate( UINT, LONG ) <br>{ <br>    // Load the extension data if there is any. <br>    CHRESULT hr = HrLoadExtData(); <br>    if( FAILED( hr)); <br> <br>    // Call the user's function to refresh their dialog. <br>    Refresh(); <br> <br>    return( hr); <br>} <br> <br>//$--CAdminDialog::Refresh()---------------------------------------------------- <br>// A do nothing function so the user is not required to implement this function <br>// if they really don't need it. <br>// ----------------------------------------------------------------------------- <br> <br>void CAdminDialog::Refresh() <br>{ <br>} <br> <br>//$--CAdminDialog::InvalidEntry()----------------------------------------------- <br>// Displays a message box with a resource string for invalid entries.  After <br>// the user presses OK the appropriate control gets focus. <br>// ----------------------------------------------------------------------------- <br> <br>void CAdminDialog::InvalidEntry( int nResourceStrID, CWnd&amp; wndCtrl) <br>{ <br>    CString sResourceString; <br>    if( sResourceString.LoadString( nResourceStrID)) <br>        MessageBox2( nResourceStrID); <br>    else <br>    {   // The nResourceStrID must be bad, display a general  <br>        // purpose message and log the error. <br>        HR_LOG( E_FAIL); <br>        MessageBoxA( "Invalid entry."); <br>    } <br>    wndCtrl.SetFocus(); <br>} <br> <br>// $--CAdminDialog::bSaveData()------------------------------------------------- <br>// Override this virtual function if you need to validate data when the property  <br>// sheet changes, or when the Ok or Apply button is pressed.  This is the appropriate <br>// place to check edit control values, list box selections etc. <br>// Default behavior is to do nothing but continue. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CAdminDialog::bSaveData() <br>{ <br>    // Save the extension data if there is any. <br>    CHRESULT hr = HrSaveExtData(); <br>    if( FAILED( hr)) <br>        return( FALSE); <br> <br>    return( TRUE); <br>} <br> <br>// $--CAdminDialog::bCommitData()----------------------------------------------- <br>// Override this virtual function if you need to save data to permanent storage  <br>// when the Ok or Apply button is pressed. (You can assume the data is good, because <br>// you should have checked it in the bSaveData() call.) <br>// Default behavior is to do nothing but continue. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CAdminDialog::bCommitData() <br>{ <br>    return( TRUE); <br>} <br> <br>// $--CAdminDialog::bHasHelp()-------------------------------------------------- <br>// Override this virtual function if you supply help. <br>// Default behavior is NO help. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CAdminDialog::bHasHelp() <br>{ <br>    MessageBox( "Help is not available for this property sheet."); <br>    return( FALSE); <br>} <br> <br>// $--CAdminDialog::DoHelp()---------------------------------------------------- <br>// Override this virtual function if you supply help. <br>// Default behavior is to display a message. <br>// ----------------------------------------------------------------------------- <br> <br>VOID CAdminDialog::DoHelp() <br>{ <br>    MessageBox( "Help is not available for this property sheet."); <br>} <br> <br>// $--bInitSheet()-------------------------------------------------------------- <br>// This function initializes the property sheet info and returns it to admin. <br>// It uses the static member function since this one can NOT access the static  <br>// member data. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bInitSheet(                 // RETURNS: TRUE if initialization OK <br>    IN  ADMIN_ObjectInfo* poi,              // Computer name &amp; DN. <br>    IN  ULONG             fFlags,                        <br>    OUT ADMIN_SheetInfo** ppSheetInfo,      // Property sheet description array <br>    OUT UINT*             pcsi,             // Number of property sheets <br>    OUT VOID**            ppNotUsed) // Local data <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    DEBUGPUBLIC( "bInitSheet()\n"); <br>    if( FAILED( CHK_bInitSheet( poi, fFlags, ppSheetInfo, pcsi, ppNotUsed))) <br>        return( FALSE); <br> <br>    return( CAdminDialog::bInitSheet( poi, fFlags, ppSheetInfo, pcsi, ppNotUsed)); <br>} <br> <br>// $--DeinitSheet()------------------------------------------------------------- <br>// Admin calls this when the property sheet dialog box is about to be removed. <br>// ----------------------------------------------------------------------------- <br> <br>void PASCAL DeinitSheet(                // Returns nothing <br>    IN VOID* pNotUsed)           // Extension data.  <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    CAdminDialog::DeinitSheet( pNotUsed); <br>} <br> <br>// $--bInstallExtension()------------------------------------------------------- <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bInstallExtension(ADMIN_ObjectInfo * poi) <br>{ <br>    return(TRUE); <br>} <br> <br>// $--bDeinstallExtension()----------------------------------------------------- <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bDeinstallExtension(ADMIN_ObjectInfo * poi) <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br>    return(TRUE); <br>} <br> <br>// $--bSaveData()----------------------------------------------------------- <br>// Called by admin when the property sheet page loses focus. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bSaveData(   // Returns: TRUE if successful. <br>    IN VOID* pNotUsed,       // Extension data for all sheets <br>    IN HWND  hDlg)           // Window handle of the property sheet. <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    DEBUGPUBLIC( "bSaveData()\n"); <br>    if( FAILED( CHK_HrGeneral( pNotUsed, hDlg))) <br>        return( FALSE); <br> <br>    CAdminDialog* pAdminDlg = CAdminDialog::FindDlg( hDlg); <br>    if( !pAdminDlg) <br>    { <br>        HR_LOG( E_FAIL); <br>        return( FALSE); <br>    } <br>    return( pAdminDlg-&gt;bSaveData()); <br>} <br> <br>// $--bCommitData()------------------------------------------------------------- <br>// This function is called by admin when the user presses either the OK or the  <br>// APPLY buttons. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bCommitData(            // Returns:  TRUE if successful. <br>    IN VOID* pNotUsed,       // Extension data. <br>    IN HWND  hDlg)                  // Handle of the property sheet to be committed. <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    DEBUGPUBLIC( "bCommitData()\n"); <br>    if( FAILED( CHK_HrGeneral( pNotUsed, hDlg))) <br>        return( FALSE); <br> <br>    CAdminDialog* pAdminDlg = CAdminDialog::FindDlg( hDlg); <br>    if( !pAdminDlg) <br>    { <br>        HR_LOG( E_FAIL); <br>        return( FALSE); <br>    } <br>    return( pAdminDlg-&gt;bCommitData()); <br>} <br> <br>// $--bHasHelp()---------------------------------------------------------------- <br>// Called by admin to find out if we support help. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL PASCAL bHasHelp(               // RETURNS: true if help is available. <br>    IN VOID* pNotUsed,       // Ext dll managed data area. <br>    IN HWND  hDlg)                  // Window handle of the property sheet. <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    DEBUGPUBLIC( "bHasHelp()\n"); <br>    if( FAILED( CHK_HrGeneral( pNotUsed, hDlg))) <br>        return( FALSE); <br> <br>    CAdminDialog* pAdminDlg = CAdminDialog::FindDlg( hDlg); <br>    if( !pAdminDlg) <br>    { <br>        HR_LOG( E_FAIL); <br>        return( FALSE); <br>    } <br>    return( pAdminDlg-&gt;bHasHelp()); <br>} <br> <br>// $--DoHelp()------------------------------------------------------------------ <br>// Called by admin to displays help for the user. <br>// ----------------------------------------------------------------------------- <br> <br>VOID PASCAL DoHelp(                 // RETURNS: Nothing <br>    IN VOID* pNotUsed,       // Ext dll managed data area. <br>    IN HWND  hDlg)                  // Window handle of the property sheet. <br>{ <br>    AFX_MANAGE_STATE(AfxGetStaticModuleState()); <br> <br>    DEBUGPUBLIC( "DoHelp()\n"); <br>    if( FAILED( CHK_HrGeneral( pNotUsed, hDlg))) <br>        return; <br>     <br>    CAdminDialog* pAdminDlg = CAdminDialog::FindDlg( hDlg); <br>    if( !pAdminDlg) <br>    { <br>        HR_LOG( E_FAIL); <br>        return; <br>    } <br>    pAdminDlg-&gt;DoHelp(); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// NOTE: The admin program will keep a pointer to this.  These are pointers to <br>//       the functions that admin will want to access. <br>// ----------------------------------------------------------------------------- <br> <br>ADMIN_ExtensionFunction extensionFunctions = <br>{ <br>    ADMIN_ExtensionAPIVersion, <br>    bInstallExtension, <br>    bDeinstallExtension, <br>    bInitSheet, <br>    bShowPage,  // This one can be defined in your dll code, otherwise it will come from ShowPage.CPP. <br>    iStartPage, // This one can be defined in your dll code, otherwise it will come from StrtPage.CPP. <br>    bHasHelp, <br>    DoHelp, <br>    bSaveData, <br>    bCommitData, <br>    DeinitSheet <br>}; <br> <br>// $--ADMIN_Initialize()-------------------------------------------------------- <br>// Exported function. This is the first function called by admin after the DLL  <br>// has been initialized. <br>// ----------------------------------------------------------------------------- <br> <br>extern "C" VOID PASCAL ADMIN_Initialize(                    // Returns nothing. <br>    IN  ADMIN_AdministratorConnections* pAdminConnections,  // Global Administrator Connections <br>    IN  ADMIN_AdministratorFunction*    pAdminFunctions,    // Global admin function <br>    OUT ADMIN_ExtensionFunction**       ppExtensionFunction)// Global Extension function <br>{ <br>    DEBUGPUBLIC( "ADMIN_Initialize()\n"); <br>    if( FAILED( CHK_ADMIN_Initialize( pAdminConnections, pAdminFunctions, ppExtensionFunction))) <br>        return; <br> <br>    CAdminDialog::ADMIN_Initialize( pAdminConnections, pAdminFunctions); <br>     <br>    // Tell admin where it can find the rest of our functions that it needs. <br>    *ppExtensionFunction = &amp;extensionFunctions;   <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Detemine what languages this dll supports <br> <br>BOOL CALLBACK EnumResTypesCallback(HANDLE hModule,LPTSTR lpszType,LONG lParam) <br>{ <br>PEnumLangParams pELP = (PEnumLangParams) lParam; <br> <br>    EnumResourceNames((HINSTANCE) hModule, lpszType, (ENUMRESNAMEPROC) EnumResNamesCallback, lParam); <br> <br>if (pELP-&gt;fFound) <br>return FALSE;// terminates search <br>else <br>return TRUE; <br>} <br> <br>BOOL CALLBACK EnumResNamesCallback(HANDLE hModule, LPCTSTR lpszType, <br>   LPTSTR lpszName, LONG lParam) <br>{ <br>PEnumLangParams pELP = (PEnumLangParams) lParam; <br> <br>    EnumResourceLanguages((HINSTANCE)hModule, lpszType, lpszName, (ENUMRESLANGPROC) fEnumLangProc, <br>  lParam); <br> <br>if (pELP-&gt;fFound) <br>return FALSE;// terminates search <br>else <br>return TRUE; <br>} <br> <br>BOOL CALLBACK fEnumLangProc(HANDLE hMod, LPCTSTR ptzType, LPCTSTR ptzName, WORD wLang, LONG lParam) <br>{ <br>PEnumLangParams pELP = (PEnumLangParams) lParam; <br> <br>if (wLang == pELP-&gt;langRequested) <br>pELP-&gt;fFound = TRUE; <br> <br>if (pELP-&gt;fFound) <br>return FALSE;// terminates search <br>else <br>return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
