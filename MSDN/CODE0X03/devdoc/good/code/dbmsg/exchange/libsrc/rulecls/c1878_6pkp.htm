<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RULECLS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1879"></a>RULECLS.CPP</h2>
<pre><code>// --rulecls.cpp------------------------------------------------------------- <br>// <br>//  API entry points into the Rule Class Library (rulecls). <br>// <br>//  Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include &lt;errno.h&gt; <br>#include "srowlst.h" <br>#include "ruleclsf.h" <br>#include "proptag.h"// temporary location for GetPropTag* functions. <br>#include "toktypes.h" <br> <br>#include "rulecls.chk" <br> <br> <br>// <br>// Manifest constants. <br>// <br> <br>#defineRES_UNINITIALIZED((ULONG) 0xffffffff) <br> <br>//  <br>// Macros <br>// <br> <br>// ISNONTERMINALRESTRICTION() returns TRUE if lpRes is a nonterminal restriction <br> <br>#define ISNONTERMINALRESTRICTION(lpRes)(((lpRes)-&gt;rt == RES_AND)||\ <br> ((lpRes)-&gt;rt == RES_OR)||\ <br> ((lpRes)-&gt;rt == RES_NOT)) <br> <br>// Forward function declarations. <br> <br>static <br>HRESULT <br>HrAdrListDisplayNamesToString(           <br>INLPADRLISTlpAdrList, <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer <br>); <br> <br>static <br>HRESULT <br>HrAndRestrictionToString( <br>INLPSRestrictionlpRes, <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer <br>); <br> <br>static <br>HRESULT <br>HrContentRestrictionToString( <br>INLPSRestrictionlpRes, <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer <br>); <br> <br>static <br>HRESULT <br>HrCopyProps( <br>INintcprop, <br>INLPSPropValuergprop, <br>OUTLPVOIDpvDst, <br>OUTULONG FAR * pcb <br>); <br> <br>static <br>HRESULT <br>HrCopyRestrictionArray( <br>INLPSRestrictionlpResSrc, <br>INLPVOIDlpObject, <br>INULONGcRes, <br>OUTLPSRestrictionlpResDest <br>); <br> <br>static <br>HRESULT <br>HrCountProps( <br>INint cprop, <br>INLPSPropValuergprop, <br>OUTULONG FAR *pcb <br>); <br> <br>static <br>HRESULT <br>HrCreateReplyMsg( <br>INLPMAPIFOLDERlpFolder, <br>INLPSTRlpszReplyText, <br>INLPVOIDlpObject, <br>OUTULONG FAR *lpcbentryid, <br>OUTLPENTRYID FAR *lppentryid <br>); <br> <br>static <br>HRESULT <br>HrDupPropset( <br>INintcprop, <br>INLPSPropValuergprop, <br>INLPVOIDlpObject, <br>OUTLPSPropValue FAR *prgprop <br>); <br> <br>static <br>HRESULT <br>HrGetExplicitTag( <br>IN OUTTOKENINFO *pti <br>); <br> <br>static <br>HRESULT <br>HrGetExpressionToken( <br>IN OUTTOKENINFO *pti <br>); <br> <br>static <br>HRESULT <br>HrGetFolderPath( <br>INLPMDBlpMDB, <br>INULONGcbentryid, <br>INLPENTRYIDlpentryid, <br>OUTLPSTR FAR *lppszFolderPath <br>); <br> <br>static <br>HRESULT <br>HrGetMoveCopyArgs( <br>INLPMAPISESSIONlpSession, <br>INLPSTRpszFolder, <br>INLPVOIDlpObject, <br>IN OUTLPACTIONlpAction <br>); <br> <br>static <br>HRESULT <br>HrGetNamedTag( <br>IN OUTTOKENINFO *pti <br>); <br> <br>static <br>HRESULT <br>HrGetNumericLiteral( <br>IN OUTTOKENINFO *pti <br>); <br> <br>static <br>HRESULT <br>HrGetStoreName(          <br>INLPMDBlpMDB, <br>OUTLPSTR FAR *lppszName  <br>); <br> <br>static <br>HRESULT <br>HrGetStringLiteral( <br>IN OUTTOKENINFO *pti <br>); <br> <br>static <br>HRESULT <br>HrGetTimeLiteral( <br>IN OUTTOKENINFO *pti <br>); <br> <br>static <br>HRESULT <br>HrNotRestrictionToString( <br>INLPSRestrictionlpRes, <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer <br>); <br> <br>static <br>HRESULT <br>HrOrRestrictionToString( <br>INLPSRestrictionlpRes, <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer <br>); <br> <br>static <br>HRESULT <br>HrParseAction( <br>INLPMAPISESSIONlpSession, <br>INLPMAPIFOLDERlpFolder, <br>INLPVOIDlpObject, <br>INCHAR *pch, <br>IN OUTLPACTIONlpAction <br>); <br> <br>static <br>HRESULT <br>HrParseCondition( <br>INLPVOIDlpObject, <br>IN OUTCHAR **ppch, <br>IN OUTLPSRestrictionlpRes <br>); <br> <br>static <br>HRESULT <br>HrPrintToString( <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer, <br>INLPSTRFormat <br>... <br>); <br> <br>static <br>HRESULT <br>HrPrivateRestrictionToString( <br>INLPSRestrictionlpRes, <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer <br>); <br> <br>static <br>HRESULT <br>HrPropertyRestrictionToString( <br>INLPSRestrictionlpRes, <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer <br>); <br> <br>static <br>HRESULT <br>HrPropValueToString(           <br>INLPSPropValuelpProp, <br>IN OUTLPSTR FAR *lppszString, <br>IN OUTLPULONGlpcbString, <br>IN OUTLPULONGlpcbBuffer <br>); <br> <br>inline <br>CHAR * <br>lpszSkipNonWhiteSpace( <br>INCHAR *pch <br>); <br> <br>inline <br>CHAR * <br>lpszSkipWhiteSpace( <br>INCHAR *pch <br>); <br> <br>// <br>// Public functions <br>// <br> <br>// $--HrCopyActions------------------------------------------------------------ <br>// <br>// DESCRIPTION:Make a copy of an ACTIONS structure and all its subelements. <br>// <br>// INPUT: <br>// <br>//[lpActsSrc]-- Ptr to ACTIONS structure to be copied. <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//   MAPIAllocateBuffer(), or NULL if the returned structure <br>//   is to be allocated using MAPIAllocateBuffer(). <br>// OUTPUT: <br>// <br>//[lppActsDest]-- Ptr to be set to copy of ACTIONS structure. <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif out of memory; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrCopyActions(// RETURNS: HRESULT <br>INLPACTIONSlpActsSrc,  // source action ptr <br>INLPVOIDlpObject,// ptr to existing MAPI buffer <br>OUTLPACTIONS FAR *lppActsDest // ptr to destination ACTIONS buffer <br>) <br>{ <br>BOOLfNullObject =(lpObject == NULL); <br>HRESULThr =NOERROR; <br>ULONGi =0; <br>LPACTIONlpActDest =NULL; <br>LPACTIONlpActSrc =NULL; <br>LPACTIONSlpActsDest =NULL; <br> <br>    DEBUGPUBLIC("HrCopyActions()\n"); <br> <br>hr = CHK_HrCopyActions(lpActsSrc, lpObject, lppActsDest); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>*lppActsDest = NULL; <br> <br>if (lpActsSrc-&gt;cActions &lt;= 0 || lpActsSrc-&gt;lpAction == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (lpObject != NULL) <br>{ <br>hr = MAPIAllocateMore(sizeof(ACTIONS), <br>  lpObject, <br>  (LPVOID FAR *)lppActsDest); <br>} <br>else <br>{ <br>hr = MAPIAllocateBuffer(sizeof(ACTIONS), <br>(LPVOID FAR *)lppActsDest); <br> <br>lpObject = *lppActsDest; <br>} <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>lpActsDest = *lppActsDest; <br> <br>*lpActsDest = *lpActsSrc; <br> <br>lpActsDest-&gt;lpAction = NULL; <br> <br>hr = MAPIAllocateMore(sizeof(ACTION) * lpActsDest-&gt;cActions, <br>  lpObject, <br>  (LPVOID FAR *)&amp;(lpActsDest-&gt;lpAction)); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Initialize acttype values for all members of the array to a value <br>// that will not cause deallocation errors should the copy fail. <br> <br>for (i = 0; i &lt; lpActsDest-&gt;cActions; i++) <br>lpActsDest-&gt;lpAction[i].acttype = OP_BOUNCE; <br> <br>// Now actually copy all the members of the array.   The number of  <br>// actions should be small, so we don't worry about a more efficient <br>// loop implementation (getting rid of i and just using ptrs). <br> <br>for (i = 0; i &lt; lpActsDest-&gt;cActions; i++) <br>{ <br>lpActDest =&amp;(lpActsDest-&gt;lpAction[i]); <br>lpActSrc =&amp;(lpActsSrc-&gt;lpAction[i]); <br> <br>*lpActDest = *lpActSrc; <br> <br>// Note -Any 0 source allocations (ie. cb==0 or ptr==NULL) cause <br>//the function to fail.  If there are instances in which <br>//such input is valid, we should evaluate them case by <br>//case. <br> <br>switch (lpActSrc-&gt;acttype) <br>{ <br>    case OP_MOVE:// actMoveCopy <br>    case OP_COPY: <br>    { <br>    if (lpActDest-&gt;actMoveCopy.cbStoreEntryId == 0|| <br>lpActDest-&gt;actMoveCopy.lpStoreEntryId == NULL|| <br>lpActDest-&gt;actMoveCopy.cbFldEntryId == 0|| <br>lpActDest-&gt;actMoveCopy.lpFldEntryId == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateMore(lpActDest-&gt;actMoveCopy.cbStoreEntryId, <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;(lpActDest-&gt;actMoveCopy.lpStoreEntryId)); <br>    if (FAILED(hr)) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    memcpy(lpActDest-&gt;actMoveCopy.lpStoreEntryId, <br>       lpActSrc-&gt;actMoveCopy.lpStoreEntryId, <br>       lpActSrc-&gt;actMoveCopy.cbStoreEntryId); <br> <br>    hr = MAPIAllocateMore(lpActDest-&gt;actMoveCopy.cbFldEntryId, <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;(lpActDest-&gt;actMoveCopy.lpFldEntryId)); <br>    if (FAILED(hr)) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    memcpy(lpActDest-&gt;actMoveCopy.lpFldEntryId, <br>       lpActSrc-&gt;actMoveCopy.lpFldEntryId, <br>       lpActSrc-&gt;actMoveCopy.cbFldEntryId); <br> <br>    break; <br>    } <br> <br>    case OP_REPLY:// actReply <br>    case OP_OOF_REPLY: <br>    { <br>    if (lpActDest-&gt;actReply.cbEntryId == 0|| <br>lpActDest-&gt;actReply.lpEntryId == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateMore(lpActDest-&gt;actReply.cbEntryId, <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;(lpActDest-&gt;actReply.lpEntryId)); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    memcpy(lpActDest-&gt;actReply.lpEntryId, <br>   lpActSrc-&gt;actReply.lpEntryId, <br>   lpActSrc-&gt;actReply.cbEntryId); <br> <br>    break; <br>    } <br> <br>    case OP_DEFER_ACTION:// actDeferAction <br>    { <br>    if (lpActSrc-&gt;actDeferAction.pbData == NULL|| <br>lpActSrc-&gt;actDeferAction.cbData == 0) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>hr = MAPIAllocateMore(lpActDest-&gt;actDeferAction.cbData, <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;(lpActDest-&gt;actDeferAction.pbData)); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>memcpy(lpActDest-&gt;actDeferAction.pbData, <br>   lpActSrc-&gt;actDeferAction.pbData, <br>   lpActDest-&gt;actDeferAction.cbData); <br> <br>    break; <br>    } <br> <br>    case OP_BOUNCE:// scBounceCode <br>    { <br>    // Nothing to do! <br>     <br>    break; <br>    } <br> <br> <br>    case OP_FORWARD:// lpadrlist <br>    case OP_DELEGATE: <br>    { <br>    ULONGcEntries =0; <br>    ULONGi =0; <br>    LPADRLISTlpAdrListSrc =lpActSrc-&gt;lpadrlist; <br>    LPADRLISTlpAdrListDest =NULL; <br> <br>    lpActDest-&gt;lpadrlist = NULL; <br> <br>    if (lpAdrListSrc == NULL || lpAdrListSrc-&gt;cEntries == 0) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateMore(CbADRLIST(lpAdrListSrc), <br>  lpObject, <br> (LPVOID FAR *)&amp;(lpActDest-&gt;lpadrlist)); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    cEntries = lpAdrListSrc-&gt;cEntries; <br> <br>    lpAdrListDest = lpActDest-&gt;lpadrlist; <br> <br>lpAdrListDest-&gt;cEntries = cEntries; <br> <br>    // Initialize the new ADRENTRY's and validate cValues. <br> <br>    for (i = 0; i &lt; cEntries; i++) <br>    { <br>    lpAdrListDest-&gt;aEntries[i] = lpAdrListSrc-&gt;aEntries[i]; <br>                 <br>    lpAdrListDest-&gt;aEntries[i].rgPropVals = NULL; <br> <br>    if (lpAdrListDest-&gt;aEntries[i].cValues == 0) <br>    hr = HR_LOG(E_FAIL); <br>    } <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    // Copy the rgPropVals. <br>         <br>    for (i = 0; i &lt; cEntries; i++) <br>    { <br>    hr = HrDupPropset(lpAdrListDest-&gt;aEntries[i].cValues, <br>    lpAdrListSrc-&gt;aEntries[i].rgPropVals, <br>  lpObject, <br>    &amp;lpAdrListDest-&gt;aEntries[i].rgPropVals); <br> <br>    if (FAILED(hr)) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>    } <br> <br>    break; <br>    } <br> <br>    case OP_TAG:// propTag <br>{ <br>hr = PropCopyMore(&amp;lpActDest-&gt;propTag, <br>  &amp;lpActSrc-&gt;propTag, <br>  MAPIAllocateMore, <br>  lpObject); <br> <br>if (FAILED(hr)) <br>{ <br>if (hr != MAPI_E_NOT_ENOUGH_MEMORY) <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br> <br>break; <br>} <br> <br>    case OP_DELETE:// union not used <br>    case OP_MARK_AS_READ: <br>    { <br>    // Nothing to do! <br>     <br>    break; <br>    } <br> <br>    default:// error! <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>} <br>} <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>{ <br>if (fNullObject) <br>    MAPIFREEBUFFER(*lppActsDest); <br>} <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrCopyRestriction-------------------------------------------------------- <br>// <br>// DESCRIPTION:Make a copy of an SRestriction structure and all its <br>//subelements. <br>// <br>// INPUT: <br>// <br>//[lpResSrc]-- Ptr to restriction to be copied. <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//   MAPIAllocateBuffer(), or NULL if the returned structure <br>//   is to be allocated using MAPIAllocateBuffer(). <br>// <br>// OUTPUT: <br>// <br>//[lppResDest]-- Ptr to be set to copy of restriction. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif out of memory; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrCopyRestriction(// RETURNS: HRESULT <br>INLPSRestrictionlpResSrc,   // source restriction ptr <br>INLPVOIDlpObject,// ptr to existing MAPI buffer <br>OUTLPSRestriction FAR *lppResDest  // dest restriction buffer ptr <br>) <br>{ <br>BOOLfNullObject =(lpObject == NULL); <br>HRESULThr =NOERROR; <br> <br>    DEBUGPUBLIC("HrCopyRestriction()\n"); <br> <br>hr = CHK_HrCopyRestriction(lpResSrc, lpObject, lppResDest); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>*lppResDest = NULL; <br> <br>if (lpObject != NULL) <br>{ <br>hr = MAPIAllocateMore(sizeof(SRestriction), <br>  lpObject, <br>  (LPVOID FAR *)lppResDest); <br>} <br>else <br>{ <br>hr = MAPIAllocateBuffer(sizeof(SRestriction), <br>(LPVOID FAR *)lppResDest); <br> <br>lpObject = *lppResDest; <br>} <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = HrCopyRestrictionArray(lpResSrc, lpObject, 1, *lppResDest); <br> <br>if (FAILED(hr)) <br>{ <br>if (fNullObject) <br>MAPIFREEBUFFER(*lppResDest); <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrFolderRulesGetProviders------------------------------------------------ <br>// <br>// DESCRIPTION:Get an array of rules provider names for a given folder. <br>// <br>// INPUT: <br>// <br>//[lpMDB]-- Pointer to message store containing folder. <br>//  [cbentryid]-- Number of bytes in folder's entry identifier. <br>//  [lpentryid]-- Folder's entry identifier. <br>// <br>// OUTPUT: <br>// <br>//  [lpcProviders]-- Pointer to ulong that will be set to count of <br>//   providers on successful return. <br>//[lpppszProviders]-- Pointer to array of string pointers that will be set <br>//   to point at an array of provider name string pointers <br>//   on successful return. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif not enough memory; <br>//E_NOINTERFACEif rules table does not exist on folder; <br>//              E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrFolderRulesGetProviders(// RETURNS: HRESULT <br>INLPMDBlpMDB,// MAPI MDB store ptr <br>INULONGcbentryid,// # bytes in entry ID <br>INLPENTRYIDlpentryid,// entry ID ptr <br>OUTLPULONGlpcProviders,// count of providers <br>OUTLPSTR FAR * FAR *lpppszProviders// ptr to array of providers <br>) <br>{ <br>    HRESULThr =NOERROR; <br>    CFolderRules FAR *pFolderRules =NULL; <br> <br>    DEBUGPUBLIC("HrFolderRulesGetProviders()\n"); <br> <br>    hr = CHK_HrFolderRulesGetProviders(cbentryid, <br>   lpentryid, <br>   lpcProviders, <br>   lpppszProviders); <br>    if (FAILED(hr)) <br>        RETURN(hr);         <br> <br>    // Initialize controlling class object. <br> <br>    pFolderRules = new CFolderRules(); <br> <br>if (pFolderRules == NULL) <br>{ <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>// Open the folder in the controlling class object. <br> <br>hr = pFolderRules-&gt;HrOpen(lpMDB, cbentryid, lpentryid, NULL); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = pFolderRules-&gt;HrGetProviders(lpcProviders, lpppszProviders); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>cleanup: <br> <br>    // Release our copy of the CFolderRules object.   <br> <br>    ULRELEASE(pFolderRules);// Ref count now 1. <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrFolderRulesOpen-------------------------------------------------------- <br>// <br>// DESCRIPTION:Get a pointer to an object which implements the <br>//IExchangeFolderRules interface defined in rulecls.h. <br>// <br>// INPUT: <br>// <br>//[lpMDB]-- Pointer to message store containing folder. <br>//  [cbentryid]-- Number of bytes in folder's entry identifier. <br>//  [lpentryid]-- Folder's entry identifier. <br>//  [lpszProvider]-- Provider for rules.  Multiple providers may have <br>//   rules on a folder. The IExchangeFolderRules interface <br>//   provides access to the rules associated with a <br>//   single specified provider. <br>// <br>// OUTPUT: <br>// <br>//  [lppFolderRules]-- Pointer to object which supports interface. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif not enough memory; <br>//E_NOINTERFACEif rules table does not exist on folder; <br>//              E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrFolderRulesOpen(// RETURNS: HRESULT <br>INLPMDBlpMDB,// MAPI MDB store ptr <br>INULONGcbentryid,// # bytes in entry ID <br>INLPENTRYIDlpentryid,// entry ID ptr <br>INLPSTRlpszProvider,// provider name <br>OUTLPFOLDERRULES FAR *lppFolderRules  // ptr to folder rules buffer <br>) <br>{ <br>    HRESULThr =NOERROR; <br>    CFolderRules FAR *pFolderRules =NULL; <br> <br>    DEBUGPUBLIC("HrFolderRulesOpen()\n"); <br> <br>    hr = CHK_HrFolderRulesOpen(cbentryid, <br>   lpentryid, <br>   lpszProvider, <br>   lppFolderRules); <br>    if (FAILED(hr)) <br>        RETURN(hr);         <br> <br>    *lppFolderRules = NULL; <br> <br>    // Initialize controlling class object. <br> <br>    pFolderRules = new CFolderRules(); <br> <br>if (pFolderRules == NULL) <br>{ <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>// Open the folder in the controlling class object. <br> <br>hr = pFolderRules-&gt;HrOpen(lpMDB, cbentryid, lpentryid, lpszProvider); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>    // Give the user access to the programmer interface (CIExchangeFolderRules) <br>    // on the controlling CFolderRules object.     <br> <br>    hr = pFolderRules-&gt;QueryInterface(IID_IExchangeFolderRules, <br> (LPVOID FAR *)lppFolderRules); <br>    // Ref count now 2. <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    ASSERT_READ_PTR_OR_NULL(*lppFolderRules, sizeof(LPFOLDERRULES), <br>                             "Bad lppFolderRules."); <br> <br>cleanup: <br> <br>    // Release our copy of the CFolderRules object.   <br> <br>    ULRELEASE(pFolderRules);// Ref count now 1. <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrActionToString--------------------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of an ACTION. <br>// <br>// INPUT: <br>// <br>//  [lpSession]-- MAPI session ptr. <br>//[lpAction]-- Ptr to ACTION. <br>// <br>// OUTPUT: <br>// <br>//[lppszString]-- Ptr to ptr that will be set to point at generated <br>//   string representation on successful return. <br>// <br>// RETURNS:     NOERROR             if successful; <br>//              E_INVALIDARG    if bad input; <br>//              E_OUTOFMEMORYif not enough memory; <br>//              E_FAILotherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrActionToString(// RETURNS: HRESULT <br>INLPMAPISESSIONlpSession,  // MAPI session ptr <br>INLPACTIONlpAction,// action ptr <br>OUTLPSTR FAR *lppszString// string ptr ptr <br>) <br>{ <br>ULONGcbBuffer =0; <br>ULONGcbString =0; <br>HRESULThr =NOERROR; <br>LPSTRlpszActType =NULL; <br> <br>    DEBUGPUBLIC("HrActionToString()\n"); <br> <br>hr = CHK_HrActionToString(lpSession, lpAction, lppszString); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>*lppszString = NULL; <br> <br>switch (lpAction-&gt;acttype) <br>{ <br>case OP_MOVE: <br>lpszActType = "Move to "; <br>break; <br> <br>case OP_COPY: <br>lpszActType = "Copy to "; <br>break; <br> <br>case OP_REPLY: <br>lpszActType = "Reply"; <br>break; <br> <br>case OP_OOF_REPLY: <br>lpszActType = "Out-of-Office Reply"; <br>break; <br> <br>case OP_DEFER_ACTION: <br>lpszActType = "Provider-specific deferred action"; <br>break; <br> <br>case OP_BOUNCE: <br>lpszActType = "Bounce with error code "; <br>break; <br> <br>case OP_FORWARD: <br>lpszActType = "Forward to "; <br>break; <br> <br>case OP_DELEGATE: <br>lpszActType = "Delegate to "; <br>break; <br> <br>case OP_TAG: <br>lpszActType = "Tag "; <br>break; <br> <br>case OP_DELETE: <br>lpszActType = "Delete"; <br>break; <br> <br>case OP_MARK_AS_READ: <br>lpszActType = "Mark as Read"; <br>break; <br> <br>default: <br>lpszActType = "Invalid action type"; <br>break; <br>} <br> <br>hr = HrPrintToString(lppszString, &amp;cbString, &amp;cbBuffer, lpszActType); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>switch (lpAction-&gt;acttype) <br>{ <br>case OP_MOVE: <br>case OP_COPY: <br>{ <br>LPMDBlpMDB =NULL; <br>LPSTRlpszFolderPath =NULL; <br>LPSTRlpszStoreName = NULL; <br> <br>// Open the message store. <br> <br>hr = lpSession-&gt;OpenMsgStore(0, <br> lpAction-&gt;actMoveCopy.cbStoreEntryId, <br> lpAction-&gt;actMoveCopy.lpStoreEntryId, <br>  NULL, <br>  MAPI_DEFERRED_ERRORS, <br>  &amp;lpMDB); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = HrGetStoreName(lpMDB, &amp;lpszStoreName); <br> <br>    if (FAILED(hr)) <br>{ <br>ULRELEASE(lpMDB); <br>        goto cleanup; <br>} <br> <br>hr = HrGetFolderPath(lpMDB, <br> lpAction-&gt;actMoveCopy.cbFldEntryId, <br> lpAction-&gt;actMoveCopy.lpFldEntryId, <br> &amp;lpszFolderPath); <br> <br>    if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(lpszStoreName); <br>ULRELEASE(lpMDB); <br>        goto cleanup; <br>} <br> <br>hr = HrPrintToString(lppszString, <br> &amp;cbString, <br> &amp;cbBuffer, <br> "%s\\%s", lpszStoreName, lpszFolderPath); <br> <br>MAPIFREEBUFFER(lpszFolderPath); <br>MAPIFREEBUFFER(lpszStoreName); <br>ULRELEASE(lpMDB); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>break; <br>} <br> <br>case OP_REPLY: <br>case OP_OOF_REPLY: <br>{ <br>;// Nothing more to do. <br>break; <br>} <br> <br>case OP_DEFER_ACTION: <br>{ <br>;// Nothing more to do. <br>break; <br>} <br> <br>case OP_BOUNCE: <br>{ <br>LPSTRlpszBounceCode = NULL; <br> <br>if (lpAction-&gt;scBounceCode == BOUNCE_MESSAGE_SIZE_TOO_LARGE) <br>lpszBounceCode = "BOUNCE_MESSAGE_SIZE_TOO_LARGE"; <br>else if (lpAction-&gt;scBounceCode == BOUNCE_FORMS_MISMATCH) <br>lpszBounceCode = "BOUNCE_FORMS_MISMATCH"; <br>else if (lpAction-&gt;scBounceCode == BOUNCE_ACCESS_DENIED) <br>lpszBounceCode = "BOUNCE_ACCESS_DENIED"; <br> <br>if (lpszBounceCode != NULL) <br>{ <br>hr = HrPrintToString(lppszString, <br> &amp;cbString, <br> &amp;cbBuffer, <br> lpszBounceCode); <br>} <br>else <br>{ <br>hr = HrPrintToString(lppszString, <br> &amp;cbString, <br> &amp;cbBuffer, <br> "%#x (invalid bounce code)", <br>lpAction-&gt;scBounceCode); <br>} <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>break; <br>} <br> <br>case OP_FORWARD: <br>case OP_DELEGATE: <br>{ <br>hr = HrAdrListDisplayNamesToString(lpAction-&gt;lpadrlist, <br>   lppszString, <br>   &amp;cbString, <br>   &amp;cbBuffer); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>break; <br>} <br> <br>case OP_TAG: <br>{ <br>LPSTRlpszPropTag =NULL; <br>LPSTRlpszPropValue =NULL; <br> <br>hr = HrGetPropTagName(lpAction-&gt;propTag.ulPropTag, <br>   &amp;lpszPropTag); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>{ <br>ULONGcbString =0; <br>ULONGcbBuffer =0; <br> <br>hr = HrPropValueToString(&amp;lpAction-&gt;propTag, <br>  &amp;lpszPropValue, <br>  &amp;cbString, <br>  &amp;cbBuffer); <br>} <br> <br>    if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(lpszPropTag); <br>        goto cleanup; <br>} <br> <br>hr = HrPrintToString(lppszString, <br> &amp;cbString, <br> &amp;cbBuffer, <br> "%s = %s", lpszPropTag, lpszPropValue); <br> <br>MAPIFREEBUFFER(lpszPropTag); <br>MAPIFREEBUFFER(lpszPropValue); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>break; <br>} <br> <br>case OP_DELETE: <br>{ <br>;// Nothing more to do. <br>break; <br>} <br> <br>case OP_MARK_AS_READ: <br>{ <br>;// Nothing more to do. <br>break; <br>} <br> <br>default: <br>{ <br>;// Nothing more to do. <br>break; <br>} <br>} <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(*lppszString); <br>} <br>else <br>{ <br>// If buffer is longer than necessary, reallocate. <br> <br>if (cbBuffer &gt; cbString) <br>{ <br>LPSTRlpszString = NULL; <br> <br>hr = MAPIAllocateBuffer(cbString, (LPVOID FAR *)&amp;lpszString); <br> <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(*lppszString); <br>} <br>else <br>{ <br>memcpy(lpszString, *lppszString, cbString); <br> <br>MAPIFREEBUFFER(*lppszString); <br> <br>*lppszString = lpszString; <br>} <br>} <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrRestrictionToString---------------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of an SRestriction. <br>// <br>// INPUT: <br>// <br>//[lpRestriction]-- Ptr to restriction. <br>// <br>// OUTPUT: <br>// <br>//[lppszString]-- Ptr to ptr that will be set to point at generated <br>//   string representation on successful return. <br>// <br>// RETURNS:     NOERROR             if successful; <br>//              E_INVALIDARG    if bad input; <br>//              E_OUTOFMEMORYif not enough memory; <br>//              E_FAILotherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrRestrictionToString(// RETURNS: HRESULT <br>INLPSRestrictionlpRestriction,// restriction ptr <br>OUTLPSTR FAR *lppszString// string ptr ptr <br>) <br>{ <br>ULONGcbBuffer =0; <br>ULONGcbString =0; <br>HRESULThr =NOERROR; <br> <br>    DEBUGPUBLIC("HrRestrictionToString()\n"); <br> <br>hr = CHK_HrRestrictionToString(lpRestriction, lppszString); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>*lppszString = NULL; <br> <br>hr = HrPrivateRestrictionToString(lpRestriction, <br>  lppszString, <br>  &amp;cbString, <br>  &amp;cbBuffer); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(*lppszString); <br>} <br>else <br>{ <br>// If buffer is longer than necessary, reallocate. <br> <br>if (cbBuffer &gt; cbString) <br>{ <br>LPSTRlpszString = NULL; <br> <br>hr = MAPIAllocateBuffer(cbString, (LPVOID FAR *)&amp;lpszString); <br> <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(*lppszString); <br>} <br>else <br>{ <br>memcpy(lpszString, *lppszString, cbString); <br> <br>MAPIFREEBUFFER(*lppszString); <br> <br>*lppszString = lpszString; <br>} <br>} <br>} <br> <br>    RETURN(hr); <br>}; <br> <br> <br>// $--HrStringToAction--------------------------------------------------------- <br>// <br>// DESCRIPTION:Generate an ACTION structure that describes the action <br>//provided in *lpszString. <br>// <br>// INPUT: <br>// <br>//[lpSession]-- Ptr to MAPI session. <br>//[lpFolder]-- Ptr to MAPI folder action applies to.  MUST have been <br>//   opened with MAPI_MODIFY access. <br>//[lpszString]-- Action string specifying ACTION to be generated. <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//   MAPIAllocateBuffer().  NULL is not permitted. Ideally, <br>//   this is a ptr to the parent ACTIONS structure. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lpAction]-- Ptr to ACTION structure that will be filled in.  This <br>//   is allocated by the caller.  Ideally, this is a ptr to <br>//   an ACTION array element that was allocated by the caller <br>//   using a MAPIAllocateMore() that referenced the parent <br>//   ACTIONS structure. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//              E_OUTOFMEMORYif out of memory; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrStringToAction(// RETURNS: HRESULT <br>INLPMAPISESSIONlpSession,// ptr to MAPI session <br>INLPMAPIFOLDERlpFolder,// ptr to MAPI folder <br>INLPSTRlpszString,// string ptr <br>INLPVOIDlpObject,// ptr to existing MAPI buf <br>IN OUTLPACTIONlpAction  // ACTION ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>LPSTRlpszStringCopy =NULL; <br> <br>    DEBUGPUBLIC("HrStringToAction()\n"); <br> <br>    hr = CHK_HrStringToAction(lpSession, <br>  lpFolder, <br>  lpszString, <br>  lpObject, <br>  lpAction); <br>    if (FAILED(hr)) </code></pre>
<p>
</p>
<pre><code>RETURN(hr); <br> <br>// Make copy of lpszString so you can write to it safely. <br> <br>hr = MAPIAllocateBuffer(strlen(lpszString) + 1, <br>(LPVOID FAR *)&amp;lpszStringCopy); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>strcpy(lpszStringCopy, lpszString); <br> <br>hr = HrParseAction(lpSession, lpFolder, lpObject, lpszStringCopy, lpAction); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(lpszStringCopy); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrStringToRestriction---------------------------------------------------- <br>// <br>// DESCRIPTION:Generate an SRestriction structure that describes the  <br>//restriction condition provided in *lpszString.  The <br>//grammar for *lpszString is given in the header file <br>//rulecls.h. <br>// <br>// INPUT: <br>// <br>//[lpszString]-- Condition string specifying restriction to be generated. <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//   MAPIAllocateBuffer(), or NULL if the returned structure <br>//   is to be allocated using MAPIAllocateBuffer(). <br>// <br>// OUTPUT: <br>// <br>//[lppRestriction]-- Ptr to ptr that will be set to point at generated <br>//   restriction on successful return. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//              E_OUTOFMEMORYif out of memory; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrStringToRestriction(// RETURNS: HRESULT <br>INLPSTRlpszString,// string <br>INLPVOIDlpObject,// ptr to existing MAPI buf <br>OUTLPSRestriction FAR *lppRestriction  // restriction buffer ptr <br>) <br>{ <br>BOOLfNullObject =(lpObject == NULL); <br>HRESULThr =NOERROR; <br>LPSTRlpszStringCopy =NULL; <br>CHAR *pch =NULL; <br> <br>    DEBUGPUBLIC("HrStringToRestriction()\n"); <br> <br>    hr = CHK_HrStringToRestriction(lpszString, lpObject, lppRestriction); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>// Make copy of lpszString so you can write to it safely. <br> <br>hr = MAPIAllocateBuffer(strlen(lpszString) + 1, <br>(LPVOID FAR *)&amp;lpszStringCopy); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>strcpy(lpszStringCopy, lpszString); <br> <br>if (lpObject != NULL) <br>{ <br>hr = MAPIAllocateMore(sizeof(SRestriction), <br>  lpObject, <br>  (LPVOID FAR *)lppRestriction); <br>} <br>else <br>{ <br>hr = MAPIAllocateBuffer(sizeof(SRestriction), <br>(LPVOID FAR *)lppRestriction); <br> <br>lpObject = *lppRestriction; <br>} <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>(*lppRestriction)-&gt;rt = RES_UNINITIALIZED; <br> <br>pch = lpszStringCopy; <br> <br>hr = HrParseCondition(lpObject, &amp;pch, *lppRestriction); <br> <br>if (*pch != '\0') <br>hr = HR_LOG(E_INVALIDARG); <br> <br>if (FAILED(hr)) <br>{ <br>if (fNullObject) <br>MAPIFREEBUFFER(*lppRestriction); <br> <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(lpszStringCopy); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// <br>// Private functions <br>// <br> <br> <br>// $--HrAdrListDisplayNamesToString-------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of the display names in an ADRLIST. <br>// <br>// INPUT: <br>// <br>//[lpAdrList]-- Ptr to ADRLIST, the display names of which are to be <br>//   represented as a string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrAdrListDisplayNamesToString(          // RETURNS: HRESULT <br>INLPADRLISTlpAdrList,// address list ptr <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer// ptr to count of bytes in buffer <br>) <br>{ <br>HRESULThr =NOERROR; <br>ULONGi =0; <br>ULONGj =0; <br>LPADRENTRYlpAdrEntry =NULL; <br>LPSTRlpszFormat ="\"%s\""; <br> <br>    DEBUGPRIVATE("HrAdrListDisplayNamesToString()\n"); <br> <br>for (i = 0; i &lt; lpAdrList-&gt;cEntries; i++) <br>{ <br>lpAdrEntry = &amp;lpAdrList-&gt;aEntries[i]; <br> <br>for (j = 0; j &lt; lpAdrEntry-&gt;cValues; j++) <br>{ <br>if (lpAdrEntry-&gt;rgPropVals[j].ulPropTag == PR_DISPLAY_NAME) <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> lpszFormat, <br> lpAdrEntry-&gt;rgPropVals[j].Value.lpszA); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>lpszFormat = ", \"%s\""; <br> <br>break; <br>} <br>} <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrAndRestrictionToString------------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of an SAndRestriction. <br>// <br>// INPUT: <br>// <br>//[lpRes]-- Ptr to and restriction to be represented as a string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrAndRestrictionToString(     // RETURNS: HRESULT <br>INLPSRestrictionlpRes,// restriction ptr <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer// ptr to count of bytes in buffer <br>) <br>{ <br>HRESULThr =NOERROR; <br>ULONGi =0; <br>SAndRestriction *presAnd=NULL; <br> <br>    DEBUGPRIVATE("HrAndRestrictionToString()\n"); <br> <br>    presAnd = &amp;lpRes-&gt;res.resAnd; <br> <br>if (presAnd-&gt;cRes &lt; 2) <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;Invalid SAndRestriction&gt;"); <br>    if (FAILED(hr)) <br>        goto cleanup; <br>} <br>else <br>{ <br>hr = HrPrivateRestrictionToString(presAnd-&gt;lpRes, <br>    lppszString, <br>    lpcbString, <br>    lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>for (i = 1; i &lt; presAnd-&gt;cRes; i++) <br>{ <br>hr = HrPrintToString(lppszString, lpcbString, lpcbBuffer, " &amp; "); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>if (ISNONTERMINALRESTRICTION(presAnd-&gt;lpRes + i)) <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "("); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>hr = HrPrivateRestrictionToString(presAnd-&gt;lpRes + i, <br>    lppszString, <br>    lpcbString, <br>    lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> ")"); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br>else <br>{ <br>hr = HrPrivateRestrictionToString(presAnd-&gt;lpRes + i, <br>    lppszString, <br>    lpcbString, <br>    lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br>} <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrContentRestrictionToString--------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of an SContentRestriction. <br>// <br>// INPUT: <br>// <br>//[lpRes]-- Ptr to content restriction to be represented as a string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrContentRestrictionToString(     // RETURNS: HRESULT <br>INLPSRestrictionlpRes,// restriction ptr <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer// ptr to count of bytes in buffer <br>) <br>{ <br>HRESULThr = NOERROR; <br>LPSTRlpszPropName =NULL; <br> <br>    DEBUGPRIVATE("HrContentRestrictionToString()\n"); <br> <br>hr = HrGetPropTagName(lpRes-&gt;res.resContent.ulPropTag, <br>   &amp;lpszPropName); <br>if (FAILED(hr)) <br>goto cleanup; <br>  <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "%s } ", <br> lpszPropName); <br>if (FAILED(hr)) <br>goto cleanup; <br>  <br>hr = HrPropValueToString(lpRes-&gt;res.resProperty.lpProp, <br> lppszString, <br>   lpcbString, <br>   lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(lpszPropName); <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrCopyRestrictionArray--------------------------------------------------- <br>// <br>// DESCRIPTION:    Copy an SRestriction array. <br>// <br>// INPUT: <br>// <br>//[lpResSrc]-- Ptr to restriction array to be copied. <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//   MAPIAllocateBuffer(). NULL is not permitted! <br>//[cRes]-- Count of array elements. <br>// <br>// OUTPUT: <br>// <br>//[lpResDest]-- Ptr to destination restriction array (allocated by caller). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif out of memory; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrCopyRestrictionArray(// RETURNS: HRESULT <br>INLPSRestrictionlpResSrc,       // source restriction <br>INLPVOIDlpObject,// ptr to existing MAPI buffer <br>INULONGcRes,           // # elements in array <br>OUTLPSRestrictionlpResDest       // destination restriction <br>) <br>{ <br>HRESULThr =NOERROR; <br>ULONGi; <br> <br>    DEBUGPRIVATE("HrCopyRestrictionArray()\n"); <br> <br>for (i = 0; i &lt; cRes; i++)  <br>{ <br>lpResDest[i] = lpResSrc[i]; <br> <br>switch (lpResSrc[i].rt) <br>{ <br>    case RES_AND: <br>    { <br>    ULONGcRes =lpResSrc[i].res.resAnd.cRes; <br>    LPSRestrictionlpRes =lpResSrc[i].res.resAnd.lpRes; <br> <br>    if (cRes == 0 || lpRes == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateMore(sizeof(SRestriction) * cRes, <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;lpResDest[i].res.resAnd.lpRes); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    hr = HrCopyRestrictionArray(lpRes, <br>   lpObject, <br>   cRes, <br>     lpResDest[i].res.resAnd.lpRes); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    break; <br>    } <br> <br>    case RES_OR: <br>    { <br>    ULONGcRes =lpResSrc[i].res.resOr.cRes; <br>    LPSRestrictionlpRes =lpResSrc[i].res.resOr.lpRes; <br> <br>    if (cRes == 0 || lpRes == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateMore(sizeof(SRestriction) * cRes, <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;lpResDest[i].res.resOr.lpRes); <br>    if (FAILED(hr)) <br>                    goto cleanup; <br> <br>    hr = HrCopyRestrictionArray(lpRes, <br>   lpObject, <br>   cRes, <br>     lpResDest[i].res.resOr.lpRes); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    break; <br>    } <br> <br>    case RES_NOT: <br>    { <br>    LPSRestrictionlpRes = lpResSrc[i].res.resNot.lpRes; <br> <br>    if (lpRes == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateMore(sizeof(SRestriction), <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;lpResDest[i].res.resNot.lpRes); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    hr = HrCopyRestrictionArray(lpRes, <br>   lpObject, <br>   1, <br>   lpResDest[i].res.resNot.lpRes); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    break; <br>    } <br> <br>    case RES_CONTENT: <br>    { <br>    if (lpResSrc[i].res.resContent.lpProp == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = HrDupPropset(1, <br>  lpResSrc[i].res.resContent.lpProp, <br>  lpObject, <br>  &amp;lpResDest[i].res.resContent.lpProp); <br>    if (FAILED(hr)) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    break; <br>    } <br> <br>    case RES_PROPERTY: <br>    { <br>    if (lpResSrc[i].res.resProperty.lpProp == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = HrDupPropset(1, <br>    lpResSrc[i].res.resProperty.lpProp, <br>  lpObject, <br>    &amp;lpResDest[i].res.resProperty.lpProp); <br>    if (FAILED(hr)) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    break; <br>    } <br> <br>    case RES_COMPAREPROPS: <br>    case RES_BITMASK: <br>    case RES_SIZE: <br>    case RES_EXIST: <br>    { <br>    // Nothing to do. <br> <br>    break; <br>    } <br> <br>    case RES_SUBRESTRICTION: <br>    { <br>    LPSRestrictionlpRes = lpResSrc[i].res.resSub.lpRes; <br> <br>    if (lpRes == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateMore(sizeof(SRestriction), <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;lpResDest[i].res.resSub.lpRes); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    hr = HrCopyRestrictionArray(lpRes, <br>   lpObject, <br>   1, <br>   lpResDest[i].res.resSub.lpRes); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    break; <br>    } <br> <br>    case RES_COMMENT: <br>    { <br>    LPSRestrictionlpRes = lpResSrc[i].res.resComment.lpRes; <br> <br>    if (lpRes == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateMore(sizeof(SRestriction), <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;lpResDest[i].res.resComment.lpRes); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    hr = HrCopyRestrictionArray(lpRes, <br>lpObject, <br>1, <br>lpResDest[i].res.resComment.lpRes); <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    break; <br>    } <br> <br>    default: <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>} <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrCreateReplyMsg--------------------------------------------------------- <br>// <br>// DESCRIPTION:Create a reply message for the reply action. <br>// <br>// INPUT: <br>// <br>//[lpFolder]-- Ptr to MAPI folder action applies to. <br>//[lpszReplyText]-- Ptr to message text. <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//      MAPIAllocateBuffer().  NULL is not permitted. <br>// <br>// OUTPUT: <br>// <br>//  [lpcbentryid]-- Number of bytes in message's entry identifier. <br>//  [lppentryid]-- Ptr to message entry identifier. <br>// <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrCreateReplyMsg(// RETURNS:HRESULT <br>INLPMAPIFOLDERlpFolder,// ptr to MAPI folder <br>INLPSTRlpszReplyText,// ptr to message text <br>INLPVOIDlpObject,// ptr to existing MAPI buf <br>OUTULONG FAR *lpcbentryid,    // ptr to message entry ID size <br>OUTLPENTRYID FAR *lppentryid// message entry ID buffer ptr <br>) <br>{ <br>static <br>SizedSPropTagArray(1, PropTagArray) ={1, {PR_ENTRYID}}; <br> <br>    SPropValueaPropVals[5] ={0}; <br>ULONGcValues =   0; <br>HRESULThr =NOERROR; <br>LPMESSAGElpMsg =NULL; <br>LPSPropProblemArraylpProblems =NULL; <br>LPSPropValuergPropVals =NULL; <br>ULONGulOldStatus =0; <br> <br>    DEBUGPRIVATE("HrCreateReplyMsg()\n"); <br> <br>hr = lpFolder-&gt;CreateMessage(NULL, MAPI_ASSOCIATED, &amp;lpMsg); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>    aPropVals[0].ulPropTag =PR_MESSAGE_CLASS; <br>    aPropVals[0].Value.lpszA ="IPM.Note.Rules.ReplyTemplate.Microsoft"; <br>    aPropVals[1].ulPropTag =PR_DELETE_AFTER_SUBMIT; <br>    aPropVals[1].Value.b =FALSE; <br>    aPropVals[2].ulPropTag =PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED; <br>    aPropVals[2].Value.b =FALSE; <br>    aPropVals[3].ulPropTag =PR_MESSAGE_FLAGS; <br>    aPropVals[3].Value.l =MSGFLAG_READ | MSGFLAG_UNSENT; <br>    aPropVals[4].ulPropTag =PR_BODY; <br>    aPropVals[4].Value.lpszA =lpszReplyText; <br> <br>hr = lpMsg-&gt;SetProps(5, aPropVals, &amp;lpProblems); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (lpProblems != NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>MAPIFREEBUFFER(lpProblems); <br>goto cleanup; <br>} <br> <br>hr = lpMsg-&gt;SaveChanges(KEEP_OPEN_READWRITE); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Now get the entryid for the newly created msg. <br> <br>hr = lpMsg-&gt;GetProps((LPSPropTagArray)&amp;PropTagArray, <br> 0, <br> &amp;cValues, <br> &amp;rgPropVals); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (cValues != 1|| <br>rgPropVals[0].ulPropTag != PR_ENTRYID) <br>{ <br>hr = HR_LOG(EDK_E_NOT_FOUND); <br>goto cleanup; <br>} <br> <br>// Allocate space for entryid and store it. <br> <br>*lpcbentryid = rgPropVals[0].Value.bin.cb; <br> <br>hr = MAPIAllocateMore(*lpcbentryid, <br>  lpObject, <br>  (LPVOID FAR *)lppentryid); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>memcpy(*lppentryid, rgPropVals[0].Value.bin.lpb, *lpcbentryid); <br> <br>cleanup: <br> <br>ULRELEASE(lpMsg); <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrGetExplicitTag--------------------------------------------------------- <br>// <br>// DESCRIPTION:Parse an explicit property tag token, returning results in <br>//*pti.  A value for ulPropTag is returned in pti-&gt;dwValue. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[pti]-- Ptr to token information structure. <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetExplicitTag(     // RETURNS: HRESULT <br>IN OUTTOKENINFO *pti// ptr to token information <br>) <br>{ <br>    HRESULT hr =NOERROR; <br>CHARchtmp =0; <br>CHAR *pchDigit =NULL; <br>CHAR *pch =NULL; <br>ULONGulPropTag =0; <br> <br>    DEBUGPRIVATE("HrGetExplicitTag()\n"); <br> <br>    pch = pti-&gt;pch + 1; <br> <br>if (*pch != 'B' &amp;&amp; *pch != 'b'&amp;&amp; <br>*pch != 'N' &amp;&amp; *pch != 'n'&amp;&amp; <br>*pch != 'S' &amp;&amp; *pch != 's'&amp;&amp; <br>*pch != 'T' &amp;&amp; *pch != 't') <br>    { <br>hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>pch++; <br> <br>pch = lpszSkipWhiteSpace(pch); <br> <br>pchDigit = pch; <br> <br>if (!isxdigit(*pch)) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>while (isxdigit(*pch)) <br>    { <br>pch++; <br>    } <br> <br>// We temporarily terminate the hex number string, just to be absolutely <br>// certain that the following character is not used. <br> <br>chtmp =*pch; <br>*pch ='\0'; <br> <br>    errno = 0;  // initialize it <br> <br>ulPropTag = strtoul(pchDigit, (CHAR **)NULL, 16); <br> <br>*pch = chtmp; <br> <br>if (ulPropTag == ULONG_MAX &amp;&amp; errno == ERANGE) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>pch = lpszSkipWhiteSpace(pch); <br> <br>if (*pch != ']') <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>if (*(pti-&gt;pch + 1) == 'B' || *(pti-&gt;pch + 1) == 'b') <br>{ <br>if (PROP_TYPE(ulPropTag) != PT_BOOLEAN) <br>{ <br>pti-&gt;tt = InvalidTag; <br>            hr = HR_LOG(E_INVALIDARG); <br>            goto cleanup; <br>} <br> <br>pti-&gt;tt = BooleanTag; <br>} <br>else if (*(pti-&gt;pch + 1) == 'N' || *(pti-&gt;pch + 1) == 'n') <br>{ <br>if (PROP_TYPE(ulPropTag) != PT_LONG) <br>{ <br>pti-&gt;tt = InvalidTag; <br>            hr = HR_LOG(E_INVALIDARG); <br>            goto cleanup; <br>} <br> <br>pti-&gt;tt = NumericTag; <br>} <br>else if (*(pti-&gt;pch + 1) == 'S' || *(pti-&gt;pch + 1) == 's') <br>{ <br>if (PROP_TYPE(ulPropTag) != PT_STRING8&amp;&amp; <br>PROP_TYPE(ulPropTag) != PT_UNICODE) <br>{ <br>pti-&gt;tt = InvalidTag; <br>            hr = HR_LOG(E_INVALIDARG); <br>            goto cleanup; <br>} <br> <br>pti-&gt;tt = StringTag; <br>} <br>else if (*(pti-&gt;pch + 1) == 'T' || *(pti-&gt;pch + 1) == 't') <br>{ <br>if (PROP_TYPE(ulPropTag) != PT_SYSTIME) <br>{ <br>pti-&gt;tt = InvalidTag; <br>            hr = HR_LOG(E_INVALIDARG); <br>            goto cleanup; <br>} <br> <br>pti-&gt;tt = TimeTag; <br>} <br>else <br>{ <br>// We should not have gotten past the preliminary input check, but <br>// we include this to prevent maintenance headaches. <br> <br>hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>} <br> <br>pti-&gt;cch =pch - pti-&gt;pch + 1; <br>pti-&gt;dwValue =ulPropTag; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrGetExpressionToken----------------------------------------------------- <br>// <br>// DESCRIPTION:Parse a token in a condition expression, returning results in <br>//*pti.  The types of token that may be parsed are defined by the <br>//TOKENTYPE enumeration. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[pti]-- Ptr to token information structure. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//E_*otherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetExpressionToken(       // RETURNS: HRESULT <br>IN OUTTOKENINFO *pti     // token information ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>CHAR *pch =NULL; <br> <br>    DEBUGPRIVATE("HrGetExpressionToken()\n"); <br> <br>    pch = lpszSkipWhiteSpace(pti-&gt;pch); <br> <br>pti-&gt;pch =pch; <br>pti-&gt;cch =0; <br>pti-&gt;tt =NotRecognized; <br>pti-&gt;dwValue =0;// Only valid if otherwise assigned below. <br> <br>switch (*pch) <br>{ <br>    case '&amp;': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =AndOp; <br>    break; <br> <br>    case '}': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =ContainsOp; <br>    break; <br> <br>    case '\0': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =EndOfString; <br>    break; <br> <br>    case '=': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =EqualOp; <br>    break; <br> <br>    case '&gt;': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =GreaterThanOp; <br>    break; <br> <br>    case '(': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =LeftParen; <br>    break; <br> <br>    case '&lt;': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =LessThanOp; <br>    break; <br> <br>    case '#': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =NotEqualOp; <br>    break; <br> <br>    case '!': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =NotOp; <br>    break; <br> <br>    case '0': <br>    case '1': <br>    case '2': <br>    case '3': <br>    case '4': <br>    case '5': <br>    case '6': <br>    case '7': <br>    case '8': <br>    case '9': <br>// We try to match a time first; if this fails, we then try to <br>// just match a number.  This order is important; a correct <br>// time format will always match a number format. <br> <br>    hr = HrGetTimeLiteral(pti); <br> <br>if (FAILED(hr)) <br>hr = HrGetNumericLiteral(pti); <br> <br>    break; <br> <br>    case '-': <br>    case '+': <br>    hr = HrGetNumericLiteral(pti); <br>    break; <br> <br>    case 'P': <br>    case 'p': <br>    hr = HrGetNamedTag(pti); <br>    break; <br> <br>    case '[': <br>    hr = HrGetExplicitTag(pti); <br>    break; <br> <br>    case '|': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =OrOp; <br>    break; <br> <br>    case ')': <br>    pti-&gt;cch =1; <br>    pti-&gt;tt =RightParen; <br>    break; <br> <br>    case '"': <br>    hr = HrGetStringLiteral(pti); <br>    break; <br> <br>    default: <br>            hr = HR_LOG(E_INVALIDARG);     <br>    break; <br>} <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrGetFolderPath---------------------------------------------------------- <br>// <br>// DESCRIPTION:Given the ENTRYID for a folder and a ptr to its store, <br>//get its path name. <br>// <br>// INPUT: <br>// <br>//  [lpMDB]-- MAPI store ptr. <br>//  [cbentryid]-- Count of bytes in folder's entry identifier. <br>//  [lpentryid]-- Ptr to folder entry identifier. <br>// <br>// OUTPUT: <br>// <br>//[lppszFolderPath]-- Ptr to ptr that will be set to point at folder path <br>//   on successful return. <br>// <br>// RETURNS:     NOERROR if successful; <br>//E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif out of memory; <br>//EDK_E_NOT_FOUNDif specified store not found; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetFolderPath(         // RETURNS: HRESULT <br>INLPMDBlpMDB,// MAPI store ptr <br>INULONGcbentryid,// count of bytes in folder entry ID <br>INLPENTRYIDlpentryid,// folder entry ID ptr <br>OUTLPSTR FAR *lppszFolderPath // folder path ptr ptr <br>) <br>{ <br>static <br>SizedSPropTagArray(3, PropTagArray) ={3, {PR_DISPLAY_NAME, <br> PR_PARENT_ENTRYID, <br> PR_FOLDER_TYPE}}; <br>ULONGcValues =   0; <br>HRESULThr =NOERROR; <br>LPMAPIFOLDERlpFolder =NULL; <br>LPSTRlpszParentFolderPath =NULL; <br>LPSPropValuergPropVals =NULL; <br>ULONGulObjType =0; <br> <br>    DEBUGPRIVATE("HrGetFolderPath()\n"); <br> <br>// Get the folder object; <br> <br>hr = lpMDB-&gt;OpenEntry(cbentryid, <br>  lpentryid, <br>  NULL, <br>  MAPI_DEFERRED_ERRORS, <br>  &amp;ulObjType, <br>  (LPUNKNOWN FAR *)&amp;lpFolder); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (ulObjType != MAPI_FOLDER) <br>{ <br>hr = HR_LOG(EDK_E_NOT_FOUND); <br>goto cleanup; <br>} <br> <br>// Get the needed properties. <br> <br>hr = lpFolder-&gt;GetProps((LPSPropTagArray)&amp;PropTagArray, <br> 0, <br> &amp;cValues, <br> &amp;rgPropVals); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (cValues != 3|| <br>rgPropVals[0].ulPropTag != PR_DISPLAY_NAME|| <br>rgPropVals[1].ulPropTag != PR_PARENT_ENTRYID|| <br>rgPropVals[2].ulPropTag != PR_FOLDER_TYPE) <br>{ <br>hr = HR_LOG(EDK_E_NOT_FOUND); <br>goto cleanup; <br>} <br> <br>if (rgPropVals[2].Value.l == FOLDER_ROOT) <br>{ <br>// We protect ourselves from various possible implementations of the <br>// root folder name by covering all possibilities. <br> <br>if (rgPropVals[0].Value.lpszA != NULL) <br>{ <br>hr = MAPIAllocateBuffer(strlen(rgPropVals[0].Value.lpszA) + 1, <br>(LPVOID FAR *)lppszFolderPath); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>strcpy(*lppszFolderPath, rgPropVals[0].Value.lpszA); <br>} <br>else <br>{ <br>hr = MAPIAllocateBuffer(1, (LPVOID FAR *)lppszFolderPath); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>*lppszFolderPath[0] = '\0'; <br>} <br>} <br>else <br>{ <br>hr = HrGetFolderPath(lpMDB, <br> rgPropVals[1].Value.bin.cb, <br> (LPENTRYID)rgPropVals[1].Value.bin.lpb, <br> &amp;lpszParentFolderPath); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = MAPIAllocateBuffer(strlen(lpszParentFolderPath) + <br>strlen(rgPropVals[0].Value.lpszA) + 2, <br>    (LPVOID FAR *)lppszFolderPath); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>strcpy(*lppszFolderPath, lpszParentFolderPath); <br> <br>if (*lppszFolderPath[0] != '\0') <br>strcat(*lppszFolderPath, "\\"); <br> <br>strcat(*lppszFolderPath, rgPropVals[0].Value.lpszA); <br>} <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(lpszParentFolderPath); <br>MAPIFREEBUFFER(rgPropVals); <br>ULRELEASE(lpFolder); <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrGetMoveCopyArgs--------------------------------------------------------- <br>// <br>// DESCRIPTION:Parse the parenthetical expression following a move or copy <br>//action argument.  The results are stored in the ACTION struct <br>//passed in as an argument. <br>// <br>// INPUT: <br>// <br>//[lpSession]-- Ptr to MAPI session. <br>//[pszFolder]-- Target folder path for move or copy. <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//   MAPIAllocateBuffer(). NULL is not permitted! <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lpAction]-- Action structure to set up. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//E_*otherwise. <br>//----------------------------------------------------------------------------- </code></pre>
<p>
</p>
<pre><code><br>HRESULT <br>HrGetMoveCopyArgs(// RETURNS: HRESULT <br>INLPMAPISESSIONlpSession,// ptr to MAPI session <br>INLPSTRpszFolder,// target folder path <br>INLPVOIDlpObject,// ptr to existing MAPI buffer <br>IN OUTLPACTIONlpAction// ACTION structure to set up <br>) <br>{ <br>ULONGcbEIDActsFolder =0; <br>ULONGcbEIDActsStore =0; <br>    HRESULT hr =NOERROR; <br>LPMDBlpActsStore =NULL; <br>LPENTRYIDlpEIDActsFolder =NULL; <br>LPENTRYIDlpEIDActsStore =NULL; <br>LPENTRYIDlpEIDTmp =NULL; <br>CHAR *pch =NULL; <br>CHARszActsFolder[MAX_PATH + 1]; <br>CHARszActsStore[MAX_PATH + 1]; <br> <br>    DEBUGPRIVATE("HrGetMoveCopyArgs()\n"); <br> <br>pch = strchr(pszFolder, '\\'); <br> <br>if (pch == NULL|| <br>pch - pszFolder == 0|| <br>pch - pszFolder + 1 &gt; sizeof(szActsStore)) <br>    { <br>hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup; <br>    } <br> <br>memcpy(szActsStore, pszFolder, pch - pszFolder); <br> <br>szActsStore[pch - pszFolder] = '\0'; <br> <br>pch++; <br> <br>if (*pch == '\0'|| <br>strlen(pch) + 1 &gt; sizeof(szActsFolder)) <br>    { <br>hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup; <br>    } <br> <br>strcpy(szActsFolder, pch); <br> <br>hr = HrMAPIFindStore(lpSession, szActsStore, &amp;cbEIDActsStore, &amp;lpEIDTmp); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = MAPIAllocateMore(cbEIDActsStore, <br>  lpObject, <br>  (LPVOID FAR *)&amp;lpEIDActsStore); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>memcpy(lpEIDActsStore, lpEIDTmp, cbEIDActsStore); <br> <br>MAPIFREEBUFFER(lpEIDTmp); <br> <br>hr = lpSession-&gt;OpenMsgStore(0, <br> cbEIDActsStore, <br> lpEIDActsStore, <br> NULL, <br> MAPI_DEFERRED_ERRORS, <br> &amp;lpActsStore); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = HrMAPIFindFolderEx(lpActsStore, <br>'\\', <br>szActsFolder, <br>&amp;cbEIDActsFolder, <br>&amp;lpEIDTmp); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = MAPIAllocateMore(cbEIDActsFolder, <br>  lpObject, <br>  (LPVOID FAR *)&amp;lpEIDActsFolder); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>memcpy(lpEIDActsFolder, lpEIDTmp, cbEIDActsFolder); <br> <br>MAPIFREEBUFFER(lpEIDTmp); <br> <br>lpAction-&gt;actMoveCopy.cbStoreEntryId =cbEIDActsStore; <br>lpAction-&gt;actMoveCopy.lpStoreEntryId =lpEIDActsStore; <br>lpAction-&gt;actMoveCopy.cbFldEntryId =cbEIDActsFolder; <br>lpAction-&gt;actMoveCopy.lpFldEntryId =lpEIDActsFolder; <br> <br>cleanup: <br> <br>ULRELEASE(lpActsStore); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrGetNamedTag------------------------------------------------------------ <br>// <br>// DESCRIPTION:Parse a named property tag token (PR_*), returning results in <br>//*pti.  A value for ulPropTag is returned in pti-&gt;dwValue. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[pti]-- Ptr to token information structure. <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetNamedTag(        // RETURNS: HRESULT <br>IN OUTTOKENINFO *pti     // ptr to token information <br>) <br>{ <br>HRESULThr =NOERROR; <br>CHARchtmp =0; <br>CHAR *pch =NULL; <br>ULONGulPropTag =0; <br> <br>    DEBUGPRIVATE("HrGetNamedTag()\n"); <br> <br>    pch = pti-&gt;pch + 1; <br> <br>while (isalnum(*pch) || *pch == '_') <br>pch++; <br> <br>// Terminate the putative PR_ string so we can look it up in the PropTbl. <br> <br>chtmp =*pch; <br>*pch ='\0'; <br> <br>hr = HrGetPropTagValue(pti-&gt;pch, &amp;ulPropTag); <br> <br>*pch = chtmp; <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (PROP_TYPE(ulPropTag) == PT_BOOLEAN) <br>{ <br>pti-&gt;tt = BooleanTag; <br>} <br>else if (PROP_TYPE(ulPropTag) == PT_LONG) <br>{ <br>pti-&gt;tt = NumericTag; <br>} <br>else if (PROP_TYPE(ulPropTag) == PT_STRING8|| <br> PROP_TYPE(ulPropTag) == PT_UNICODE) <br>{ <br>pti-&gt;tt = StringTag; <br>} <br>else if (PROP_TYPE(ulPropTag) == PT_SYSTIME) <br>{ <br>pti-&gt;tt = TimeTag; <br>} <br>else <br>{ <br>pti-&gt;tt = InvalidTag; <br> <br>hr = HR_LOG(E_INVALIDARG); <br>} <br> <br>pti-&gt;cch =pch - pti-&gt;pch; <br>pti-&gt;dwValue =ulPropTag; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrGetNumericLiteral------------------------------------------------------ <br>// <br>// DESCRIPTION:Parse a numeric literal token, returning results in <br>//*pti.  A value for the numeric literal is returned in <br>//pti-&gt;dwValue. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[pti]-- Ptr to token information structure. <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetNumericLiteral(      // RETURNS: HRESULT <br>IN OUTTOKENINFO *pti// ptr to token info structure <br>) <br>{ <br>    HRESULThr =   NOERROR; <br>CHARchtmp =0; <br>LONGlValue =0; <br>CHAR *pch =NULL; <br>ULONGulValue =   0; <br> <br>    DEBUGPRIVATE("HrGetNumericLiteral()\n"); <br> <br>    pch = pti-&gt;pch + 1; <br> <br>while (isdigit(*pch)) <br>pch++; <br> <br>// If there is only 1 CHAR, it better be a digit rather than a sign. <br> <br>if (pch == pti-&gt;pch + 1&amp;&amp; !isdigit(*(pti-&gt;pch))) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>// We temporarily terminate the number string, just to be absolutely <br>// certain that the following character is not used. <br> <br>chtmp =*pch; <br>*pch ='\0'; <br> <br>errno = 0;  // initialize it <br> <br>// Use strtol() if the number is negative; otherwise use strtoul(). <br> <br>if (*(pti-&gt;pch) == '-') <br>{ <br>lValue = strtol(pti-&gt;pch, (CHAR **)NULL, 10); <br> <br>*pch = chtmp; <br> <br>if ((lValue == LONG_MAX || lValue == LONG_MIN) &amp;&amp; errno == ERANGE) <br>        { <br>            hr = HR_LOG(E_INVALIDARG); <br>            goto cleanup; <br>        } <br> <br>pti-&gt;dwValue = lValue; <br>} <br>else <br>{ <br>ulValue = strtoul(pti-&gt;pch, (CHAR **)NULL, 10); <br> <br>*pch = chtmp; <br> <br>if (ulValue == ULONG_MAX &amp;&amp; errno == ERANGE) <br>        { <br>            hr = HR_LOG(E_INVALIDARG); <br>            goto cleanup; <br>        } <br> <br>pti-&gt;dwValue =ulValue; <br>} <br> <br>pti-&gt;cch =pch - pti-&gt;pch; <br>pti-&gt;tt =NumericLiteral; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrGetStoreName----------------------------------------------------------- <br>// <br>// DESCRIPTION:Given a ptr to a store, get its display name. <br>// <br>// INPUT: <br>// <br>//  [lpMDB]-- MAPI store ptr. <br>// <br>// OUTPUT: <br>// <br>//[lppszName]-- Ptr to ptr that will be set to point at store display <br>//   name on successful return. <br>// <br>// RETURNS:     NOERROR if successful; <br>//E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif out of memory; <br>//EDK_E_NOT_FOUNDif specified store not found; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetStoreName(         // RETURNS: HRESULT <br>INLPMDBlpMDB,// MAPI store ptr <br>OUTLPSTR FAR *lppszName  // store name ptr ptr <br>) <br>{ <br>static <br>SizedSPropTagArray(1, PropTagArray) ={1, {PR_DISPLAY_NAME}}; <br> <br>ULONGcValues =   0; <br>HRESULThr =NOERROR; <br>LPSPropValuelpProp  =   NULL; <br> <br>    DEBUGPRIVATE("HrGetStoreName()\n"); <br> <br>// Get the display name property. <br> <br>hr = lpMDB-&gt;GetProps((LPSPropTagArray)&amp;PropTagArray, 0, &amp;cValues, &amp;lpProp); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (cValues != 1 || lpProp-&gt;ulPropTag != PR_DISPLAY_NAME) <br>{ <br>hr = HR_LOG(EDK_E_NOT_FOUND); <br>goto cleanup; <br>} <br> <br>hr = MAPIAllocateBuffer(strlen(lpProp-&gt;Value.lpszA) + 1, <br>(LPVOID FAR *)lppszName); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>strcpy(*lppszName, lpProp-&gt;Value.lpszA); <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(lpProp); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrGetStringLiteral------------------------------------------------------- <br>// <br>// DESCRIPTION:Parse a string literal token, returning results in <br>//*pti.  The user should allocate separate storage to save the <br>//string literal if it is to be converted to a MAPI property <br>//value. <br>// INPUT/OUTPUT: <br>// <br>//[pti]-- Ptr to token information structure. <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>// <br>// Notes:pti-&gt;pch is left pointing at the opening quote and the value <br>//returned for pti-&gt;cch includes the leading and trailing quotes <br>//(ie. pti-&gt;cch &gt;= 2). <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetStringLiteral(// RETURNS: HRESULT <br>IN OUTTOKENINFO *pti         // ptr to token information <br>) <br>{ <br>    HRESULT hr =NOERROR; <br>CHAR *pch =   NULL; <br> <br>    DEBUGPRIVATE("HrGetStringLiteral()\n"); <br> <br>    pch = pti-&gt;pch + 1; <br> <br>while (*pch != '"' &amp;&amp; *pch != '\0') <br>pch++; <br> <br>if (*pch != '"') <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>pti-&gt;cch =pch - pti-&gt;pch + 1; <br>pti-&gt;tt =StringLiteral; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrGetTimeLiteral--------------------------------------------------------- <br>// <br>// DESCRIPTION:Parse a time literal token, returning results in *pti. <br>//A value for the time literal is returned in pti-&gt;ftValue. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[pti]-- Ptr to token information structure. <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetTimeLiteral(      // RETURNS: HRESULT <br>IN OUTTOKENINFO *pti// ptr to token info structure <br>) <br>{ <br>    static CHARDateTemplate[] ="dddd-dd-dd"; <br> <br>CHARchtmp =0; <br>FILETIMEftLocal ={0}; <br>    LONGHour =0; <br>    HRESULThr =   NOERROR; <br>    INTi =0; <br>    LONGMinute =0; <br>    LONGSecond =0; <br>CHAR *pch =pti-&gt;pch; <br>SYSTEMTIMEst ={0}; <br> <br> <br>    DEBUGPRIVATE("HrGetTimeLiteral()\n"); <br> <br>    if (!isdigit(*pch)|| <br>        !isdigit(*(pch + 1))|| <br>        *(pch + 2) != ':') <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    Hour = atol(pch); <br> <br>    if (Hour &gt; 23) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>st.wHour = (WORD)Hour; <br> <br>    pch += 3; <br> <br>    if (!isdigit(*pch)|| <br>        !isdigit(*(pch + 1))|| <br>        (*(pch + 2) != ':' &amp;&amp; !isspace(*(pch + 2)))) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    Minute = atol(pch); <br> <br>    if (Minute &gt; 59) <br>    { <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>st.wMinute = (WORD)Minute; <br> <br>    if (*(pch + 2) == ':') <br>    { <br>        pch += 3; <br> <br>        if (!isdigit(*pch)|| <br>            !isdigit(*(pch + 1))|| <br>            !isspace(*(pch + 2))) <br>        { <br>            hr = HR_LOG(E_INVALIDARG); <br>            goto cleanup; <br>        } <br> <br>        Second = atol(pch); <br> <br>        if (Second &gt; 59) <br>        { <br>            hr = HR_LOG(E_INVALIDARG); <br>            goto cleanup; <br>        } <br> <br>st.wSecond = (WORD)Second; <br>    } <br> <br>pch += 2; <br> <br>pch = lpszSkipWhiteSpace(pch); <br> <br>    for (i = 0; i &lt; sizeof(DateTemplate) - 1; i++) <br>    { <br>        if (DateTemplate[i] == 'd') <br>        { <br>            if (!isdigit(*(pch + i))) <br>            { <br>                hr = HR_LOG(E_INVALIDARG); <br>                goto cleanup; <br>            } <br>        } <br>        else <br>        { <br>            if (DateTemplate[i] != *(pch + i)) <br>            { <br>                hr = HR_LOG(E_INVALIDARG); <br>                goto cleanup; <br>            } <br>        } <br>    } <br> <br>// We let SystemTimeToFileTime() worry about range checking the date values. <br> <br>st.wYear =(WORD)atol(pch); <br>st.wMonth =(WORD)atol(pch + 5); <br> <br>// We terminate the day value just in case (insures correct day <br>// interpretation even if the rest of the expression is not well formed). <br> <br>chtmp = *(pch + sizeof(DateTemplate) - 1); <br>*(pch + sizeof(DateTemplate) - 1) = '\0'; <br> <br>st.wDay =(WORD)atol(pch + 8); <br> <br>*(pch + sizeof(DateTemplate) - 1) = chtmp; <br> <br>pch += (sizeof(DateTemplate) - 1); <br> <br>// Convert SYSTEMTIME to FILETIME. <br> <br>if (!SystemTimeToFileTime(&amp;st, &amp;ftLocal)) <br>{ <br>        hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>// We now presumably have a local FILETIME.  Convert to UTC. <br> <br>if (!LocalFileTimeToFileTime(&amp;ftLocal, &amp;pti-&gt;ftValue)) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>pti-&gt;cch =pch - pti-&gt;pch; <br>pti-&gt;tt =TimeLiteral; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrNotRestrictionToString------------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of an SNotRestriction. <br>// <br>// INPUT: <br>// <br>//[lpRes]-- Ptr to not restriction to be represented as a string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrNotRestrictionToString(// RETURNS: HRESULT <br>INLPSRestrictionlpRes,// restriction ptr <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer// ptr to count of bytes in buffer <br>) <br>{ <br>HRESULThr =NOERROR; <br>SNotRestriction *presNot=NULL; <br> <br>    DEBUGPRIVATE("HrNotRestrictionToString()\n"); <br> <br>    presNot=&amp;lpRes-&gt;res.resNot; <br> <br>hr = HrPrintToString(lppszString, lpcbString, lpcbBuffer, "!"); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br>  <br>if (ISNONTERMINALRESTRICTION(presNot-&gt;lpRes)) <br>{ <br>hr = HrPrintToString(lppszString, lpcbString, lpcbBuffer, "("); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br>  <br>hr = HrPrivateRestrictionToString(presNot-&gt;lpRes, <br>  lppszString, <br>  lpcbString, <br>  lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br>  <br>hr = HrPrintToString(lppszString, lpcbString, lpcbBuffer, ")"); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br>else <br>{ <br>hr = HrPrivateRestrictionToString(presNot-&gt;lpRes, <br>  lppszString, <br>  lpcbString, <br>  lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrOrRestrictionToString-------------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of an SOrRestriction. <br>// <br>// INPUT: <br>// <br>//[lpRes]-- Ptr to or restriction to be represented as a string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrOrRestrictionToString(// RETURNS: HRESULT <br>INLPSRestrictionlpRes,// restriction ptr <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer// ptr to count of bytes in buffer <br>) <br>{ <br>HRESULThr = NOERROR; <br>ULONGi =0; <br>SOrRestriction *presOr =NULL; <br> <br>    DEBUGPRIVATE("HrOrRestrictionToString()\n"); <br> <br>    presOr = &amp;lpRes-&gt;res.resOr; <br> <br>if (presOr-&gt;cRes &lt; 2) <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;Invalid SOrRestriction&gt;"); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br>else <br>{ <br>hr = HrPrivateRestrictionToString(presOr-&gt;lpRes, <br>  lppszString, <br>  lpcbString, <br>  lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>for (i = 1; i &lt; presOr-&gt;cRes; i++) <br>{ <br>hr = HrPrintToString(lppszString, lpcbString, lpcbBuffer, " | "); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>if (ISNONTERMINALRESTRICTION(presOr-&gt;lpRes + i)) <br>{ <br>hr = HrPrintToString(lppszString, lpcbString, lpcbBuffer, "("); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>hr = HrPrivateRestrictionToString(presOr-&gt;lpRes + i, <br>  lppszString, <br>  lpcbString, <br>  lpcbBuffer); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>hr = HrPrintToString(lppszString, lpcbString, lpcbBuffer, ")"); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br>} <br>else <br>{ <br>hr = HrPrivateRestrictionToString(presOr-&gt;lpRes + i, <br>  lppszString, <br>  lpcbString, <br>  lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br>} <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrParseAction------------------------------------------------------------ <br>// <br>// DESCRIPTION:Parse an action string. <br>// <br>// INPUT: <br>// <br>//[lpSession]-- Ptr to MAPI session. <br>// <br>//[lpFolder]-- Ptr to MAPI folder action applies to. <br>// <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//   MAPIAllocateBuffer(). NULL is not permitted! <br>// <br>//[pch]-- Ptr to string to be parsed. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lpAction]-- Ptr to uninitialized ACTION structure on input; <br>//   It will be appropriately initialized on output. <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_OUTOFMEMORYif out of memory; <br>//E_UNEXPECTEDif there is an internal error; <br>//              E_*otherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrParseAction(// RETURNS: HRESULT <br>INLPMAPISESSIONlpSession,// ptr to MAPI session <br>INLPMAPIFOLDERlpFolder,// ptr to MAPI folder <br>INLPVOIDlpObject,// ptr to existing MAPI buffer <br>INCHAR *pch,   // string ptr <br>IN OUTLPACTIONlpAction   // action ptr <br>) <br>{ <br>static CHARszBounceKeyword[] ="bounce"; <br>static CHARszCopyKeyword[] ="copy"; <br>static CHARszDelegateKeyword[] ="delegate"; <br>static CHARszDeleteKeyword[] ="delete"; <br>static CHARszForwardKeyword[] ="forward"; <br>static CHARszMarkReadKeyword[] ="markread"; <br>static CHARszMoveKeyword[] ="move"; <br>static CHARszMsgIdKeyword[] ="msgid"; <br>static CHARszReplyKeyword[] ="reply"; <br>static CHARszTagKeyword[] ="tag"; <br> <br>CHARchtmp =0; <br>HRESULThr =NOERROR; <br>LPADRBOOKlpAdrBook =NULL; <br>LPADRLISTlpAdrList =NULL; <br>CHAR *pchEnd =pch; <br> <br>// Set all fields in ACTION struct to 0. <br> <br>memset(lpAction, 0, sizeof(*lpAction)); <br> <br>// Find the start of the action keyword. <br> <br>pch = lpszSkipWhiteSpace(pch); <br> <br>pchEnd = lpszSkipNonWhiteSpace(pch); <br> <br>// Terminate the action keyword so we can parse it. <br> <br>chtmp =*pchEnd; <br>*pchEnd ='\0'; <br> <br>// Identify the action keyword. <br> <br>if (!stricmp(pch, szBounceKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_BOUNCE; <br>} <br>else if (!stricmp(pch, szCopyKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_COPY; <br>} <br>else if (!stricmp(pch, szDelegateKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_DELEGATE; <br>} <br>else if (!stricmp(pch, szDeleteKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_DELETE; <br>} <br>else if (!stricmp(pch, szForwardKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_FORWARD; <br>} <br>else if (!stricmp(pch, szMarkReadKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_MARK_AS_READ; <br>} <br>else if (!stricmp(pch, szMoveKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_MOVE; <br>} <br>else if (!stricmp(pch, szReplyKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_REPLY; <br>} <br>else if (!stricmp(pch, szTagKeyword)) <br>{ <br>lpAction-&gt;acttype = OP_TAG; <br>} <br>else <br>{ <br>*pchEnd = chtmp; <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>*pchEnd = chtmp; <br> <br>pch = lpszSkipWhiteSpace(pchEnd); <br> <br>switch (lpAction-&gt;acttype) <br>{ <br>case OP_BOUNCE: <br>{ <br>pchEnd = lpszSkipNonWhiteSpace(pch); <br> <br>// Terminate the bounce code so we can parse it. <br> <br>chtmp =*pchEnd; <br>*pchEnd ='\0'; <br> <br>if (!strcmp(pch, "BOUNCE_MESSAGE_SIZE_TOO_LARGE")) <br>{ <br>lpAction-&gt;scBounceCode = BOUNCE_MESSAGE_SIZE_TOO_LARGE; <br>} <br>else if (!strcmp(pch, "BOUNCE_FORMS_MISMATCH")) <br>{ <br>lpAction-&gt;scBounceCode = BOUNCE_FORMS_MISMATCH; <br>} <br>else if (!strcmp(pch, "BOUNCE_ACCESS_DENIED")) <br>{ <br>lpAction-&gt;scBounceCode = BOUNCE_ACCESS_DENIED; <br>} <br>else <br>{ <br>*pchEnd = chtmp; <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>*pchEnd = chtmp; <br> <br>pch = lpszSkipWhiteSpace(pchEnd); <br> <br>if (*pch != '\0') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>break; <br>} <br> <br>case OP_COPY: <br>case OP_MOVE: <br>{ <br>hr = HrGetMoveCopyArgs(lpSession, pch, lpObject, lpAction); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>break; <br>} <br> <br>case OP_DELEGATE: <br>case OP_FORWARD: <br>{ <br>ULONGcRecips =0; <br>ULONGcQuotes =0; <br>CHAR *pQuote =pch; <br> <br>// Count quotation mark pairs to arrive at a count of recipients. <br>// This is more reliable than counting comma's since a comma may <br>// be embedded in a recipient name. <br> <br>while ((pQuote = strchr(pQuote, '"')) != NULL) <br>{ <br>cQuotes++; <br>pQuote++; <br>} <br> <br>if (cQuotes == 0 || (cQuotes &amp; 1) != 0) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>cRecips = cQuotes &gt;&gt; 1; <br> <br>hr = MAPIAllocateBuffer(CbNewADRLIST(cRecips), (LPVOID *)&amp;lpAdrList); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>{ <br>ULONGi           =   0; <br>LPADRENTRYlpAdrEntry  =   NULL; <br>LPSTRlpszName    =   NULL; <br> <br>lpAdrList-&gt;cEntries = cRecips; <br> <br>// Init the ADRENTRY's prior to actually allocating the SPropValue <br>// arrays.  This makes cleanup possible if there is an error. <br> <br>for (i = 0; i &lt; cRecips; i++) <br>{ <br>lpAdrList-&gt;aEntries[i].ulReserved1 =0; <br>lpAdrList-&gt;aEntries[i].cValues =1; <br>lpAdrList-&gt;aEntries[i].rgPropVals =NULL; <br>} <br> <br>// Now allocate and initialize the SPropValue arrays. <br> <br>for (i = 0; i &lt; cRecips; i++) <br>{ <br>hr = MAPIAllocateBuffer(sizeof(SPropValue), <br> (LPVOID *)&amp;lpAdrList-&gt;aEntries[i].rgPropVals); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>lpAdrList-&gt;aEntries[i].rgPropVals-&gt;ulPropTag = PR_DISPLAY_NAME; <br>lpAdrList-&gt;aEntries[i].rgPropVals-&gt;Value.lpszA = NULL; <br>} <br> <br>lpAdrEntry = lpAdrList-&gt;aEntries; <br> <br>// Parse the recipient names. <br> <br>// Note that the index used below is 1-based (ie., don't use it <br>// for a 0-based array!). <br> <br>for (i = 1; i &lt;= cRecips; i++) <br>{ <br>if (*pch != '"') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>pch++; <br> <br>lpszName = pch; <br> <br>while (*pch != '"' &amp;&amp; *pch != '\0') <br>pch++; <br> <br>if (*pch == '\0') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>*pch = '\0'; <br> <br>hr = MAPIAllocateMore(strlen(lpszName) + 1, <br>  lpAdrEntry-&gt;rgPropVals, <br>  (LPVOID *)&amp;lpAdrEntry-&gt; <br>  rgPropVals[0].Value.lpszA); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>strcpy(lpAdrEntry-&gt;rgPropVals[0].Value.lpszA, lpszName); <br> <br>lpAdrEntry++; <br> <br>*pch = '"'; <br> <br>pch++; <br> <br>pch = lpszSkipWhiteSpace(pch); <br> <br>if (i != cRecips) <br>{ <br>if (*pch != ',') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>pch++; <br> <br>pch = lpszSkipWhiteSpace(pch); <br>} <br>else <br>{ <br>if (*pch != '\0') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>} <br>} <br> <br>hr = lpSession-&gt;OpenAddressBook(0, NULL, AB_NO_DIALOG, &amp;lpAdrBook); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = lpAdrBook-&gt;ResolveName(0, 0, NULL, lpAdrList); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Now look for problems reported in the returned ADRLIST. <br> <br>for (i = 0; i &lt; cRecips; i++) <br>{ <br>ULONGj; <br> <br>lpAdrEntry = &amp;lpAdrList-&gt;aEntries[i]; <br> <br>for (j = 0; j &lt; lpAdrEntry-&gt;cValues; j++) <br>{ <br>LPSPropValuepPropVal; <br> <br>pPropVal = &amp;lpAdrEntry-&gt;rgPropVals[j]; <br> <br>if (PROP_TYPE(pPropVal-&gt;ulPropTag == PT_ERROR)) <br>{ <br>hr = pPropVal-&gt;Value.err; <br> <br>break; <br>} <br>} <br> <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Now reallocate the ADRLIST using linked allocation; we did <br>// not do this at first to avoid problems in ResolveName(). <br> <br>lpAction-&gt;lpadrlist = NULL; <br> <br>hr = MAPIAllocateMore(CbNewADRLIST(cRecips), <br>  lpObject, <br>  (LPVOID *)&amp;lpAction-&gt;lpadrlist); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>memcpy(lpAction-&gt;lpadrlist, lpAdrList, CbNewADRLIST(cRecips)); <br> <br>for (i = 0; i &lt; cRecips; i++) <br>{ <br>hr = HrDupPropset(lpAdrList-&gt;aEntries[i].cValues, <br>  lpAdrList-&gt;aEntries[i].rgPropVals, <br>  lpObject, <br>  &amp;lpAction-&gt;lpadrlist-&gt;aEntries[i].rgPropVals); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br>} <br> <br>break; <br>} <br> <br>case OP_DELETE: <br>case OP_MARK_AS_READ: <br>{ <br>if (*pch != '\0') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>break; <br>} <br> <br>case OP_REPLY: <br>{ <br>if (*pch == '"') <br>{ <br>pch++; <br> <br>pchEnd = pch; <br> <br>while (*pchEnd != '"' &amp;&amp; *pchEnd != '\0') <br>pchEnd++; <br> <br>if (*pchEnd == '\0') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>*pchEnd = '\0'; <br> <br>// Make a message from *pch. <br> <br>hr = HrCreateReplyMsg(lpFolder, <br>  pch, <br>  lpObject, <br>  &amp;lpAction-&gt;actReply.cbEntryId, <br>  &amp;lpAction-&gt;actReply.lpEntryId); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>*pchEnd = '"'; <br> <br>pchEnd++; <br>} <br>else <br>{ <br>ULONGcNibbles =0; <br> <br>pchEnd = lpszSkipNonWhiteSpace(pch); <br> <br>// Terminate the keyword so we can parse it. <br> <br>chtmp =*pchEnd; <br>*pchEnd ='\0'; <br> <br>if (stricmp(pch, szMsgIdKeyword)) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>*pchEnd = chtmp; <br> <br>pch = lpszSkipWhiteSpace(pchEnd); <br> <br>if (*pch == '0' &amp;&amp; (*(pch + 1) == 'x' || *(pch + 1) == 'X')) <br>pch += 2; <br> <br>pchEnd = pch; <br> <br>while (isxdigit(*pchEnd)) <br>pchEnd++; <br> <br>cNibbles = pchEnd - pch; <br> <br>if (cNibbles == 0 || (cNibbles &amp; 1) != 0) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>lpAction-&gt;actReply.cbEntryId = cNibbles &gt;&gt; 1; <br> <br>// Allocate space for entryid. <br> <br>hr = MAPIAllocateMore(lpAction-&gt;actReply.cbEntryId, <br>  lpObject, <br>  (LPVOID FAR *)&amp;lpAction-&gt;actReply.lpEntryId); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Determine it's value and store it. <br> <br>BYTEloNibble =0; <br>BYTEhiNibble =0; <br>BYTE *pByte =(BYTE *)lpAction-&gt;actReply.lpEntryId; <br> <br>while (pch &lt; pchEnd) <br>{ <br>if (*pch &gt;= '0' &amp;&amp; *pch &lt;= '9') <br>hiNibble = *pch - '0'; <br>else if (*pch &gt;= 'a' &amp;&amp; *pch &lt;= 'f') <br>hiNibble = *pch - ('a' - 0xa); <br>else <br>hiNibble = *pch - ('A' - 0xa); <br> <br>pch++; <br> <br>if (*pch &gt;= '0' &amp;&amp; *pch &lt;= '9') <br>loNibble = *pch - '0'; <br>else if (*pch &gt;= 'a' &amp;&amp; *pch &lt;= 'f') <br>loNibble = *pch - ('a' - 0xa); <br>else <br>loNibble = *pch - ('A' - 0xa); <br> <br>pch++; <br> <br>*pByte = (hiNibble &lt;&lt; 4) + loNibble; <br> <br>pByte++; <br>} <br>} <br> <br>// Finish parsing line. <br> <br>pch = lpszSkipWhiteSpace(pchEnd); <br> <br>if (*pch != '\0') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>break; <br>} <br> <br>case OP_TAG: <br>{ <br>TOKENINFOti ={pch, 0, NotRecognized, 0}; <br>ULONGpt =PT_UNSPECIFIED; <br> <br>if (*pch == 'P' || *pch == 'p') <br>hr = HrGetNamedTag(&amp;ti); <br>else if (*pch == '[') <br>hr = HrGetExplicitTag(&amp;ti); <br>else <br>hr = HR_LOG(E_INVALIDARG); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pch = ti.pch + ti.cch; <br> <br>pt = PROP_TYPE(ti.dwValue); <br> <br>pch = lpszSkipWhiteSpace(pch); </code></pre>
<p>
</p>
<pre><code><br>if (*pch != ',') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>pch++;// Skip over the comma. <br> <br>pch = lpszSkipWhiteSpace(pch); <br> <br>lpAction-&gt;propTag.ulPropTag = ti.dwValue; <br> <br>ti.pch = pch; <br>ti.cch = 0; <br>ti.tt =NotRecognized; <br>ti.dwValue =0; <br> <br>if (pt == PT_BOOLEAN) <br>{ <br>hr = HrGetExpressionToken(&amp;ti); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pch = ti.pch + ti.cch; <br> <br>// A boolean literal is essentially a numeric literal with <br>// a restricted range, so... <br> <br>if (ti.tt != NumericLiteral|| ti.dwValue &gt; 1) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>lpAction-&gt;propTag.Value.b = (USHORT)ti.dwValue; <br>} <br>else if (pt == PT_LONG) <br>{ <br>hr = HrGetExpressionToken(&amp;ti); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pch = ti.pch + ti.cch; <br> <br>if (ti.tt != NumericLiteral) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>lpAction-&gt;propTag.Value.l = ti.dwValue; <br>} <br>else if (pt == PT_STRING8) <br>{ <br>hr = HrGetExpressionToken(&amp;ti); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pch = ti.pch + ti.cch; <br> <br>if (ti.tt != StringLiteral) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>hr = MAPIAllocateMore(ti.cch + 1 - 2, lpObject, <br>  (LPVOID FAR *)&amp;lpAction-&gt;propTag.Value.lpszA); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>memcpy(lpAction-&gt;propTag.Value.lpszA, ti.pch + 1, ti.cch - 2); <br> <br>*(lpAction-&gt;propTag.Value.lpszA + ti.cch - 2) = '\0'; <br>} <br>else if (pt == PT_SYSTIME) <br>{ <br>hr = HrGetExpressionToken(&amp;ti); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pch = ti.pch + ti.cch; <br> <br>if (ti.tt != TimeLiteral) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>lpAction-&gt;propTag.Value.ft = ti.ftValue; <br>} <br>else if (pt == PT_UNICODE) <br>{ <br>INTcch = 0; <br> <br>hr = HrGetExpressionToken(&amp;ti); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pch = ti.pch + ti.cch; <br> <br>if (ti.tt != StringLiteral) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>if (ti.cch &gt; 2) <br>{ <br>cch = MultiByteToWideChar(CP_ACP, <br>  0, <br>  ti.pch + 1, <br>  ti.cch - 2, <br>  NULL, <br>  0); <br> <br>if (cch == 0) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>} <br> <br>hr = MAPIAllocateMore((cch + 1) * sizeof(WCHAR), lpObject, <br>  (LPVOID FAR *)&amp;lpAction-&gt;propTag.Value.lpszW); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (ti.cch &gt; 2) <br>{ <br>if (!MultiByteToWideChar(CP_ACP, <br> 0, <br> ti.pch + 1, <br> ti.cch - 2, <br> lpAction-&gt;propTag.Value.lpszW, <br> cch)) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>} <br> <br>*(lpAction-&gt;propTag.Value.lpszW + cch) = 0; <br>} <br>else <br>{ <br>hr = HR_LOG(E_UNEXPECTED);// There is an internal error. <br>goto cleanup; <br>} <br> <br>pch = lpszSkipWhiteSpace(pch); <br> <br>if (*pch != '\0') <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br> <br>break; <br>} <br> <br>default: <br>{ <br>hr = HR_LOG(E_UNEXPECTED);// There is an internal error. <br>goto cleanup; <br> <br>break; <br>} <br>} <br> <br>cleanup: <br> <br>ULRELEASE(lpAdrBook); <br>FREEPADRLIST(lpAdrList); <br> <br>    return hr; <br>} <br> <br> <br> <br>// $--HrParseCondition--------------------------------------------------------- <br>// <br>// DESCRIPTION:Parse a restriction condition expression or parenthetical <br>//subexpression. <br>// <br>// INPUT: <br>// <br>//[lpObject]-- Ptr to an existing MAPI buffer allocated by  <br>//   MAPIAllocateBuffer(). NULL is not permitted! <br>// <br>// INPUT/OUTPUT: <br>// <br>//[ppch]-- Ptr to ptr to string to be parsed on input; <br>//   ptr to ptr to first unparsed CHAR on output. <br>// <br>//[lpRes]-- Ptr to uninitialized SRestriction structure on input; <br>//   It will be appropriately initialized and may include <br>//   other allocated SRestrictions on output. <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif out of memory; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrParseCondition(// RETURNS: HRESULT <br>INLPVOIDlpObject,// ptr to existing MAPI buffer <br>IN OUTCHAR **ppch,   // string <br>IN OUTLPSRestrictionlpRes   // restriction ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>LPSRestrictionlpNxtRes =lpRes; <br>LPSPropValuelpProp =   NULL; <br>CHAR *pch =NULL; <br>TOKENINFOti ={0}; <br> <br>    DEBUGPRIVATE("HrParseCondition()\n"); <br> <br>    pch = *ppch; <br> <br>while (TRUE) <br>{ <br>ti.pch = pch; <br> <br>hr = HrGetExpressionToken(&amp;ti); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pch = ti.pch + ti.cch;// Now pch points to next token. <br> <br>switch (ti.tt) <br>{ <br>    case LeftParen: <br>    { <br>    hr = HrParseCondition(lpObject, &amp;pch, lpNxtRes); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    ti.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;ti); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    pch = ti.pch + ti.cch; <br> <br>    if (ti.tt != RightParen) <br>    { <br>    hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup; <br>                } <br> <br>    break; <br>    } <br> <br>    case NotOp: <br>    { <br>    lpNxtRes-&gt;rt = RES_NOT; <br> <br>    lpNxtRes-&gt;res.resNot.ulReserved =0; <br>    lpNxtRes-&gt;res.resNot.lpRes =NULL; <br> <br>    hr = MAPIAllocateMore(sizeof(SRestriction), <br>  lpObject, <br>  (LPVOID FAR *) <br>  &amp;lpNxtRes-&gt;res.resNot.lpRes); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    lpNxtRes-&gt;res.resNot.lpRes-&gt;rt = RES_UNINITIALIZED; <br> <br>    lpNxtRes = lpNxtRes-&gt;res.resNot.lpRes; <br> <br>    continue; <br>    } <br> <br>    case BooleanTag: <br>    { <br>    TOKENINFOtiBooleanTag =ti; <br>    TOKENINFOtiBooleanOp; <br>    TOKENINFOtiBooleanLiteral; <br> <br>    tiBooleanOp.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;tiBooleanOp); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    pch = tiBooleanOp.pch + tiBooleanOp.cch; <br> <br>    tiBooleanLiteral.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;tiBooleanLiteral); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    pch = tiBooleanLiteral.pch + tiBooleanLiteral.cch; <br> <br>// A boolean literal is essentially a numeric literal with <br>// a restricted range, so... <br> <br>    if (tiBooleanLiteral.tt != NumericLiteral|| <br>tiBooleanLiteral.dwValue &gt; 1) <br>    { <br>    hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup; <br>    } <br> <br>if (tiBooleanOp.tt != EqualOp) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup;         <br>} <br> <br>    lpNxtRes-&gt;rt = RES_PROPERTY; <br> <br>    lpNxtRes-&gt;res.resProperty.relop =RELOP_EQ; <br>    lpNxtRes-&gt;res.resProperty.ulPropTag =tiBooleanTag.dwValue; <br>    lpNxtRes-&gt;res.resProperty.lpProp =NULL; <br> <br>    hr = MAPIAllocateMore(sizeof(SPropValue), <br>  lpObject, <br> (LPVOID FAR *)&amp;lpProp); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    lpProp-&gt;ulPropTag =tiBooleanTag.dwValue; <br>    lpProp-&gt;Value.b =(USHORT)tiBooleanLiteral.dwValue; <br> <br>    lpNxtRes-&gt;res.resProperty.lpProp = lpProp; <br> <br>    break; <br>    } <br> <br>    case NumericTag: <br>    { <br>    ULONGrelop; <br>    TOKENINFOtiNumericTag =ti; <br>    TOKENINFOtiNumericOp; <br>    TOKENINFOtiNumericLiteral; <br> <br>    tiNumericOp.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;tiNumericOp); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    pch = tiNumericOp.pch + tiNumericOp.cch; <br> <br>    tiNumericLiteral.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;tiNumericLiteral); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    pch = tiNumericLiteral.pch + tiNumericLiteral.cch; <br> <br>    if (tiNumericLiteral.tt != NumericLiteral) <br>    { <br>    hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup; <br>    } <br> <br>    switch (tiNumericOp.tt) <br>    { <br>        case NotEqualOp: <br>        relop = RELOP_NE; <br>        break; <br> <br>        case EqualOp: <br>        relop = RELOP_EQ; <br>        break; <br> <br>        case GreaterThanOp: <br>        relop = RELOP_GT; <br>        break; <br> <br>        case LessThanOp: <br>        relop = RELOP_LT; <br>        break; <br> <br>        default: <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup;         <br> <br>    } <br> <br>    lpNxtRes-&gt;rt = RES_PROPERTY; <br> <br>    lpNxtRes-&gt;res.resProperty.relop =relop; <br>    lpNxtRes-&gt;res.resProperty.ulPropTag =tiNumericTag.dwValue; <br>    lpNxtRes-&gt;res.resProperty.lpProp =NULL; <br> <br>    hr = MAPIAllocateMore(sizeof(SPropValue), <br>  lpObject, <br> (LPVOID FAR *)&amp;lpProp); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    lpProp-&gt;ulPropTag = tiNumericTag.dwValue; <br>    lpProp-&gt;Value.l =tiNumericLiteral.dwValue; <br> <br>    lpNxtRes-&gt;res.resProperty.lpProp = lpProp; <br> <br>    break; <br>    } <br> <br>    case StringTag: <br>    { <br>    ULONGrelop; <br>    ULONGrt; <br>    TOKENINFOtiStringTag =ti; <br>    TOKENINFOtiStringOp; <br>    TOKENINFOtiStringLiteral; <br> <br>    tiStringOp.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;tiStringOp); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    pch = tiStringOp.pch + tiStringOp.cch; <br> <br>    tiStringLiteral.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;tiStringLiteral); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>// Note that the string literal returned includes the  <br>// opening and closing quotes (hence all the strange mods <br>// to pch and cch). <br> <br>    pch = tiStringLiteral.pch + tiStringLiteral.cch; <br> <br>    if (tiStringLiteral.tt != StringLiteral) <br>    { <br>    hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup; <br>    } <br> <br>    switch (tiStringOp.tt) <br>    { <br>        case NotEqualOp: <br>        relop = RELOP_NE; <br>        rt =RES_PROPERTY; <br>        break; <br> <br>        case EqualOp: <br>        relop = RELOP_EQ; <br>        rt =RES_PROPERTY; <br>        break; <br> <br>        case ContainsOp: <br>        rt =RES_CONTENT; <br>        break; <br> <br>        default: <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    lpNxtRes-&gt;rt = rt; <br> <br>    if (rt == RES_PROPERTY) <br>    { <br>    lpNxtRes-&gt;res.resProperty.relop =  relop; <br>    lpNxtRes-&gt;res.resProperty.ulPropTag = tiStringTag.dwValue; <br>    lpNxtRes-&gt;res.resProperty.lpProp =  NULL; <br>    } <br>    else// rt == RES_CONTENT <br>    { <br>    lpNxtRes-&gt;res.resContent.ulFuzzyLevel =FL_SUBSTRING| <br>FL_IGNORECASE; <br> <br>    lpNxtRes-&gt;res.resContent.ulPropTag = tiStringTag.dwValue; <br>    lpNxtRes-&gt;res.resContent.lpProp =    NULL; <br>    } <br> <br>    hr = MAPIAllocateMore(sizeof(SPropValue), <br>  lpObject, <br>  (LPVOID FAR *)&amp;lpProp); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    if (rt == RES_PROPERTY) <br>    { <br>    lpNxtRes-&gt;res.resProperty.lpProp =lpProp; <br>    } <br>    else// rt == RES_CONTENT <br>    { <br>    lpNxtRes-&gt;res.resContent.lpProp =lpProp; <br>    } <br> <br>    lpProp-&gt;ulPropTag =tiStringTag.dwValue; <br> <br>if (PROP_TYPE(lpProp-&gt;ulPropTag) == PT_STRING8) <br>{ <br>    lpProp-&gt;Value.lpszA =NULL; <br> <br>hr = MAPIAllocateMore(tiStringLiteral.cch + 1 - 2, lpObject, <br>  (LPVOID FAR *)&amp;lpProp-&gt;Value.lpszA); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>memcpy(lpProp-&gt;Value.lpszA, <br>   tiStringLiteral.pch + 1, <br>   tiStringLiteral.cch - 2); <br> <br>*(lpProp-&gt;Value.lpszA + tiStringLiteral.cch - 2) = '\0'; <br>} <br>else// it is UNICODE <br>{ <br>INTcch = 0; <br> <br>    lpProp-&gt;Value.lpszW =NULL; <br> <br>if (tiStringLiteral.cch &gt; 2) <br>{ <br>cch = MultiByteToWideChar(CP_ACP, <br>  0, <br>  tiStringLiteral.pch + 1, <br>  tiStringLiteral.cch - 2, <br>  NULL, <br>  0); <br>if (cch == 0) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>hr = MAPIAllocateMore((cch + 1) * sizeof(WCHAR), lpObject, <br>  (LPVOID FAR *)&amp;lpProp-&gt;Value.lpszW); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (tiStringLiteral.cch &gt; 2) <br>{ <br>if (!MultiByteToWideChar(CP_ACP, <br> 0, <br> tiStringLiteral.pch + 1, <br> tiStringLiteral.cch - 2, <br> lpProp-&gt;Value.lpszW, <br> cch)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>*(lpProp-&gt;Value.lpszW + cch) = 0; <br>} <br> <br>    break; <br>    } <br> <br>    case TimeTag: <br>    { <br>    ULONGrelop; <br>    TOKENINFOtiTimeTag =ti; <br>    TOKENINFOtiTimeOp; <br>    TOKENINFOtiTimeLiteral; <br> <br>    tiTimeOp.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;tiTimeOp); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    pch = tiTimeOp.pch + tiTimeOp.cch; <br> <br>    tiTimeLiteral.pch = pch; <br> <br>    hr = HrGetExpressionToken(&amp;tiTimeLiteral); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    pch = tiTimeLiteral.pch + tiTimeLiteral.cch; <br> <br>    if (tiTimeLiteral.tt != TimeLiteral) <br>    { <br>    hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup; <br>    } <br> <br>    switch (tiTimeOp.tt) <br>    { <br>        case NotEqualOp: <br>        relop = RELOP_NE; <br>        break; <br> <br>        case EqualOp: <br>        relop = RELOP_EQ; <br>        break; <br> <br>        case GreaterThanOp: <br>        relop = RELOP_GT; <br>        break; <br> <br>        case LessThanOp: <br>        relop = RELOP_LT; <br>        break; <br> <br>        default: <br>        hr = HR_LOG(E_INVALIDARG); <br>        goto cleanup;         <br> <br>    } <br> <br>    lpNxtRes-&gt;rt = RES_PROPERTY; <br> <br>    lpNxtRes-&gt;res.resProperty.relop =relop; <br>    lpNxtRes-&gt;res.resProperty.ulPropTag =tiTimeTag.dwValue; <br>    lpNxtRes-&gt;res.resProperty.lpProp =NULL; <br> <br>    hr = MAPIAllocateMore(sizeof(SPropValue), <br>  lpObject, <br> (LPVOID FAR *)&amp;lpProp); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    lpProp-&gt;ulPropTag = tiTimeTag.dwValue; <br>    lpProp-&gt;Value.ft =tiTimeLiteral.ftValue; <br> <br>    lpNxtRes-&gt;res.resProperty.lpProp = lpProp; <br> <br>    break; <br>} <br> <br>    default: <br>    { <br>    hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup;     <br>    } <br>} <br> <br>ti.pch = pch; <br> <br>hr = HrGetExpressionToken(&amp;ti); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pch = ti.pch + ti.cch;// Now pch points to next token. <br> <br>switch (ti.tt) <br>{ <br>    case AndOp: <br>    { <br>    LPSRestrictionlpResArray =NULL; <br> <br>    hr = MAPIAllocateMore(sizeof(SRestriction) * 2, <br>  lpObject, <br>  (LPVOID FAR *)&amp;lpResArray); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    lpResArray[0] = *lpRes; <br> <br>    lpResArray[1].rt = RES_UNINITIALIZED; <br> <br>    lpRes-&gt;rt = RES_AND; <br> <br>    lpRes-&gt;res.resAnd.cRes =2; <br>    lpRes-&gt;res.resAnd.lpRes =lpResArray; <br> <br>    lpNxtRes = &amp;lpResArray[1]; <br> <br>    break; <br>    } <br> <br>    case OrOp: <br>    { <br>    LPSRestrictionlpResArray =NULL; <br> <br>    hr = MAPIAllocateMore(sizeof(SRestriction) * 2, <br>  lpObject, <br>  (LPVOID FAR *)&amp;lpResArray); <br> <br>    if (FAILED(hr)) <br>    goto cleanup; <br> <br>    lpResArray[0] = *lpRes; <br> <br>    lpResArray[1].rt = RES_UNINITIALIZED; <br> <br>    lpRes-&gt;rt = RES_OR; <br>     <br>    lpRes-&gt;res.resOr.cRes =2; <br>    lpRes-&gt;res.resOr.lpRes =lpResArray; <br> <br>    lpNxtRes = &amp;lpResArray[1]; <br>     <br>    break; <br>    } <br> <br>    case EndOfString: <br>    case RightParen: <br>    { <br>    pch = ti.pch;// Push this token back and return to caller. <br> <br>    if (lpRes-&gt;rt == RES_UNINITIALIZED) <br>    hr = HR_LOG(E_INVALIDARG); <br> <br>        goto cleanup;// Done! <br>    } <br> <br>    default: <br>    { <br>    hr = HR_LOG(E_INVALIDARG); <br>    goto cleanup; <br>    } <br>} <br>} <br> <br>cleanup: <br> <br>*ppch = pch; <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrPrintToString---------------------------------------------------------- <br>// <br>// DESCRIPTION:Write the formatted string to the end of the supplied <br>//output string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// INPUT: <br>// <br>//[Format]-- A printf style format string. <br>//[...]-- Format arguments. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_OUTOFMEMORYif out of memory; <br>//              E_*otherwise. <br>// <br>// Notes:This routine appends the formatted string to the end of an <br>//existing string.  If the existing string is NULL, (ie. <br>//*lppszString == NULL) then this routine will do the initial <br>//allocation.  Note that *lppszString may be reallocated as <br>//necessary to grow the buffer, and the old copy will be released. <br>//The routine uses MAPIAllocateBuffer() and MAPIFreeBuffer(). <br>// <br>//----------------------------------------------------------------------------- <br> <br>#defineHRPRINTTOSTRING_BUFINCR1024 <br> <br>HRESULT <br>HrPrintToString(// RETURNS: HRESULT <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer,// ptr to count of bytes in buffer <br>INLPSTRFormat  // message format <br>...                 // variable arguments <br>) <br>{ <br>va_listargs; <br>LONGcb =0; <br>HRESULThr =NOERROR; <br>LPSTRlpszStringCopy =NULL; <br> <br>    DEBUGPRIVATE("HrPrintToString()\n"); <br> <br>if (*lppszString == NULL) <br>{ <br>hr = MAPIAllocateBuffer(HRPRINTTOSTRING_BUFINCR, <br>(LPVOID FAR *)lppszString); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>*lpcbBuffer =HRPRINTTOSTRING_BUFINCR; <br>*lpcbString =1; <br>*lppszString[0] ='\0';  <br>} <br> <br>va_start(args, Format); <br> <br>while (TRUE) <br>{ <br>cb = _vsnprintf(*lppszString + *lpcbString - 1, <br>*lpcbBuffer - *lpcbString + 1, <br>Format, <br>args); <br> <br>if (cb &gt;= 0) <br>{ <br>*lpcbString += cb; <br>break; <br>} <br> <br>hr = MAPIAllocateBuffer(*lpcbBuffer + HRPRINTTOSTRING_BUFINCR, <br>(LPVOID FAR *)&amp;lpszStringCopy); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>*lpcbBuffer += HRPRINTTOSTRING_BUFINCR; <br> <br>memcpy(lpszStringCopy, *lppszString, *lpcbString); <br> <br>MAPIFREEBUFFER(*lppszString); <br> <br>*lppszString = lpszStringCopy; <br>} <br> <br>cleanup: <br> <br>va_end(args); <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrPrivateRestrictionToString--------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of an SRestriction. <br>// <br>// INPUT: <br>// <br>//[lpRes]-- Ptr to restriction to be represented as a string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrPrivateRestrictionToString( <br>INLPSRestrictionlpRes,// restriction ptr <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer// ptr to count of bytes in buffer <br>) <br>{ <br>HRESULThr =NOERROR; <br> <br>    DEBUGPRIVATE("HrPrivateRestrictionToString()\n"); <br> <br>if (lpRes == NULL) <br>{ <br>hr = HrPrintToString(lppszString, lpcbString, lpcbBuffer, "&lt;NULL&gt;"); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br>} <br>else <br>{ <br>switch (lpRes-&gt;rt) <br>{ <br>    case RES_AND: <br>    hr = HrAndRestrictionToString(lpRes, <br>  lppszString, <br>  lpcbString, <br>  lpcbBuffer); <br>    break; <br> <br>    case RES_OR: <br>    hr = HrOrRestrictionToString(lpRes, <br>  lppszString, <br>  lpcbString, <br>  lpcbBuffer); <br>    break; <br> <br>    case RES_NOT: <br>    hr = HrNotRestrictionToString(lpRes, <br>    lppszString, <br>    lpcbString, <br>    lpcbBuffer); <br>    break; <br> <br>    case RES_CONTENT: <br>    hr = HrContentRestrictionToString(lpRes, <br>    lppszString, <br>    lpcbString, <br>    lpcbBuffer); <br>    break; <br> <br>    case RES_PROPERTY: <br>    hr = HrPropertyRestrictionToString(lpRes, <br>      lppszString, <br>      lpcbString, <br>      lpcbBuffer); <br>    break; <br> <br>    case RES_COMPAREPROPS: <br>    hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;SComparePropsRestriction&gt;"); <br>    break; <br> <br>    case RES_BITMASK: <br>    hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;SBitMaskRestriction&gt;"); <br>    break; <br> <br>    case RES_SIZE: <br>    hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;SSizeRestriction&gt;"); <br>    break; <br> <br>    case RES_EXIST: <br>    hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;SExistRestriction&gt;"); <br>    break; <br> <br>    case RES_SUBRESTRICTION: <br>    hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;SSubRestriction&gt;"); <br>    break; <br> <br>    case RES_COMMENT: <br>    hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;SCommentRestriction&gt;"); <br>    break; <br> <br>    case RES_UNINITIALIZED: <br>    hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;Uninitialized SRestriction&gt;"); <br>    break; <br> <br>    default: <br>    hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;Invalid SRestriction&gt;"); <br>    break; <br>} <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br>// $-HrPropertyRestrictionToString--------------------------------------------- <br>// <br>// DESCRIPTION:Get a string representation of an SPropertyRestriction. <br>// <br>// INPUT: <br>// <br>//[lpRes]-- Ptr to property restriction to be represented as a <br>//   string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrPropertyRestrictionToString(// RETURNS: HRESULT <br>INLPSRestrictionlpRes,// restriction ptr <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer// ptr to count of bytes in buffer <br>) <br>{ <br>HRESULThr = NOERROR; <br>LPSTRlpszPropName =NULL; <br>LPSTRlpszRelop   =   NULL; <br> <br>    DEBUGPRIVATE("HrPropertyRestrictionToString()\n"); <br> <br>switch (lpRes-&gt;res.resProperty.relop) <br>{ <br>    case RELOP_LT: <br>    lpszRelop = " &lt; "; <br>    break; <br> <br>    case RELOP_LE: <br>    lpszRelop = " &lt;= "; <br>    break; <br> <br>    case RELOP_GT: <br>    lpszRelop = " &gt; "; <br>    break; <br> <br>    case RELOP_GE: <br>    lpszRelop = " &gt;= "; <br>    break; <br> <br>    case RELOP_EQ: <br>    lpszRelop = " = "; <br>    break; <br> <br>    case RELOP_NE: <br>    lpszRelop = " # "; <br>    break; <br> <br>    case RELOP_RE: <br>    lpszRelop = " &lt;RELOP_RE Operator&gt; "; <br>    break; <br> <br>    default: <br>    lpszRelop = " &lt;Invalid Operator&gt; "; <br>    break; <br>} <br> <br>hr = HrGetPropTagName(lpRes-&gt;res.resProperty.ulPropTag, <br>   &amp;lpszPropName); <br>if (FAILED(hr)) <br>goto cleanup; <br>  <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "%s%s", <br> lpszPropName, <br> lpszRelop); <br>if (FAILED(hr)) <br>goto cleanup; <br>  <br>hr = HrPropValueToString(lpRes-&gt;res.resProperty.lpProp, <br> lppszString, <br> lpcbString, <br> lpcbBuffer); <br>if (FAILED(hr)) <br>goto cleanup; <br>  <br>cleanup: <br> <br>MAPIFREEBUFFER(lpszPropName); <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--HrPropValueToString------------------------------------------------------ <br>// <br>// DESCRIPTION:Get a string representation of an SPropValue.. <br>// <br>// INPUT: <br>// <br>//[lpProp]-- Ptr to property value to be represented as a string. <br>// <br>// INPUT/OUTPUT: <br>// <br>//[lppszString]-- Output string ptr ptr.  If *lppszString == NULL, then <br>//   a string will be allocated by this routine. <br>//[lpcbString]-- Ptr to count of bytes in input string on input (including <br>//   terminating '\0'); count of bytes in string after <br>//   appending formatted string on output. <br>//[lpcbBuffer]-- Ptr to count of bytes in input string buffer on input; <br>//   count of bytes in string buffer after appending formatted <br>//   string on output (buffer size may increase if allocation <br>//   was necessary). <br>// <br>// RETURNS:     NOERRORif successful; <br>//              E_INVALIDARGif bad input; <br>//              E_FAILotherwise. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrPropValueToString(          // RETURNS: VOID <br>INLPSPropValuelpProp,// property value ptr <br>IN OUTLPSTR FAR *lppszString,// output string ptr ptr <br>IN OUTLPULONGlpcbString,// ptr to count of bytes in string <br>IN OUTLPULONGlpcbBuffer// ptr to count of bytes in buffer <br>) <br>{ <br>HRESULThr =NOERROR; <br> <br>    DEBUGPRIVATE("HrPropValueToString()\n"); <br> <br>if (lpProp == NULL) <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;Undefined SPropValue&gt;"); <br>    if (FAILED(hr)) <br>        goto cleanup; <br>} <br>else <br>{ <br>ULONGulPropTag =0; <br> <br>ulPropTag = lpProp-&gt;ulPropTag; <br> <br>switch (PROP_TYPE(ulPropTag)) <br>{ <br>case PT_I2: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "%#hx", <br> lpProp-&gt;Value.i); <br>break; <br>} <br> <br>case PT_LONG: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "%#x", <br> lpProp-&gt;Value.ul); <br>break; <br>} <br> <br>case PT_R4: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_R4 value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_DOUBLE: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_DOUBLE value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_BOOLEAN: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> lpProp-&gt;Value.b ? "TRUE" : "FALSE"); <br>break; <br>} <br> <br>case PT_CURRENCY: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_CURRENCY value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_APPTIME: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_APPTIME value dump not supported&gt;"); <br>break; <br>} <br> </code></pre>
<p>
</p>
<pre><code>case PT_SYSTIME: <br>{ <br>SYSTEMTIMEst ={0}; <br>FILETIMEftLocal ={0}; <br> <br>// Convert UTC FILETIME to Local FILETIME. <br> <br>if (!FileTimeToLocalFileTime(&amp;lpProp-&gt;Value.ft, &amp;ftLocal)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Convert Local FILETIME to SYSTEMTIME. <br> <br>if (!FileTimeToSystemTime(&amp;ftLocal, &amp;st)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "%02hu:%02hu:%02hu %04hu-%02hu-%02hu", <br> st.wHour, <br> st.wMinute, <br> st.wSecond, <br> st.wYear, <br> st.wMonth, <br> st.wDay); <br>break; <br>} <br> <br>case PT_STRING8: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "\"%s\"", <br> lpProp-&gt;Value.lpszA); <br>break; <br>} <br> <br>case PT_BINARY: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_BINARY value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_UNICODE: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "\"%S\"", <br> lpProp-&gt;Value.lpszW); <br>break; <br>} <br> <br>case PT_CLSID: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_CLSID value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_I8: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_I8 value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_I2: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_I2 value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_LONG: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_LONG value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_R4: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_R4 value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_DOUBLE: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_DOUBLE value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_CURRENCY: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_CURRENCY value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_APPTIME: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_APPTIME value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_SYSTIME: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_SYSTIME value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_BINARY: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_BINARY value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_STRING8: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_STRING8 value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_UNICODE: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_UNICODE value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_CLSID: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_CLSID value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_MV_I8: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_MV_I8 value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_ERROR: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "%x", <br> lpProp-&gt;Value.err); <br>break; <br>} <br> <br>case PT_NULL: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_NULL value dump not supported&gt;"); <br>break; <br>} <br> <br>case PT_OBJECT: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;PT_OBJECT value dump not supported&gt;"); <br>break; <br>} <br> <br>default: <br>{ <br>hr = HrPrintToString(lppszString, <br> lpcbString, <br> lpcbBuffer, <br> "&lt;Undefined property type value!&gt;"); <br>} <br>} <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--lpszSkipNonWhiteSpace---------------------------------------------------- <br>// <br>// DESCRIPTION:    Find first whitespace CHAR or '\0' in *pch. <br>// <br>// INPUT: <br>// <br>//[pch]-- Ptr to string to be examined for whitespace CHAR. <br>// <br>// RETURNS:     Ptr to first whitespace CHAR or '\0' in *pch. <br>// <br>//----------------------------------------------------------------------------- <br> <br>inline <br>CHAR * <br>lpszSkipNonWhiteSpace(// RETURNS CHAR * <br>INCHAR *pch     // input string <br>) <br>{ <br>while (!isspace(*pch) &amp;&amp; *pch != '\0') <br>pch++; <br> <br>return pch; <br>} <br> <br> <br>// $--lpszSkipWhiteSpace------------------------------------------------------- <br>// <br>// DESCRIPTION:    Find first nonwhitespace CHAR in *pch. <br>// <br>// INPUT: <br>// <br>//[pch]-- Ptr to string to be examined for nonwhitespace CHAR. <br>// <br>// RETURNS:     Ptr to first nonwhitespace CHAR in *pch. <br>// <br>//----------------------------------------------------------------------------- <br> <br>inline <br>CHAR * <br>lpszSkipWhiteSpace(// RETURNS CHAR * <br>INCHAR *pch     // input string <br>) <br>{ <br>while (isspace(*pch)) <br>pch++; <br> <br>return pch; <br>} <br> <br> <br>// NOTE NOTE NOTE - Code below here does not yet conform to coding standards <br>//because we do not yet know if it will be left in the <br>//product.  It will be appropriately munged when and if <br>//necessary. <br> <br>HRESULT <br>HrCountProps( <br>INint cprop, <br>INLPSPropValuergprop, <br>OUTULONG FAR *pcb <br>) <br>{ <br>LPSPropValuepprop; <br>ULONGcb = 0; <br>ULONGcbMV; <br>intiValue; <br> <br>if ((rgprop &amp;&amp; !cprop) || IsBadReadPtr(rgprop, cprop*sizeof(SPropValue))) <br>return E_INVALIDARG; <br> <br>for (pprop = rgprop; cprop--; ++pprop) <br>{ <br>ULONGulType = PROP_TYPE(pprop-&gt;ulPropTag); <br> <br>//Check for valid PROP_TYPE and count memory consumed. <br> <br>cb += sizeof(SPropValue); <br> <br>switch (PROP_TYPE(pprop-&gt;ulPropTag)) <br>{ <br>case PT_UNSPECIFIED: <br>case PT_OBJECT: <br>default: <br>{ <br>return E_INVALIDARG; <br>} <br> <br>case PT_I2: <br>case PT_LONG: <br>case PT_R4: <br>case PT_APPTIME: <br>case PT_DOUBLE: <br>case PT_BOOLEAN: <br>case PT_CURRENCY: <br>case PT_SYSTIME: <br>case PT_CLSID: <br>case PT_I8: <br>case PT_ERROR: <br>case PT_NULL: <br>{ <br>break; <br>} <br> <br>case PT_BINARY: <br>{ <br>cb += pprop-&gt;Value.bin.cb; <br> <br>if (pprop-&gt;Value.bin.cb&amp;&amp; <br>IsBadReadPtr(pprop-&gt;Value.bin.lpb, <br> (UINT)(pprop-&gt;Value.bin.cb))) <br>{ <br>goto badProp; <br>} <br> <br>break; <br>} <br> <br>case PT_STRING8: <br>{ <br>if (IsBadStringPtrA(pprop-&gt;Value.lpszA, INFINITE)) <br>goto badProp; <br> <br>cb += (lstrlenA( pprop-&gt;Value.lpszA ) + 1) * sizeof(CHAR); <br> <br>break; <br>} <br> <br>case PT_UNICODE: <br>{ <br>if (IsBadStringPtrW(pprop-&gt;Value.lpszW, INFINITE)) <br>goto badProp; <br> <br>cb += (lstrlenW(pprop-&gt;Value.lpszW) + 1) * sizeof(WCHAR); <br> <br>break; <br>} <br> <br>            //Note!MVxxx.cValues may NOT be zero (DCR 2789). <br> <br>case PT_MV_I2: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVi.cValues * sizeof(short int)) || <br>IsBadReadPtr(pprop-&gt;Value.MVi.lpi, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_LONG: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVl.cValues * sizeof(LONG)) || <br>IsBadReadPtr(pprop-&gt;Value.MVl.lpl, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_R4: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVflt.cValues * sizeof(float)) || <br>IsBadReadPtr(pprop-&gt;Value.MVflt.lpflt, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_APPTIME: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVat.cValues * sizeof(double)) || <br>IsBadReadPtr(pprop-&gt;Value.MVat.lpat, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_DOUBLE: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVdbl.cValues * sizeof(double)) || <br>IsBadReadPtr(pprop-&gt;Value.MVdbl.lpdbl, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_CURRENCY: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVcur.cValues * sizeof(CURRENCY)) || <br>IsBadReadPtr(pprop-&gt;Value.MVcur.lpcur, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_SYSTIME: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVft.cValues * sizeof(FILETIME)) || <br>IsBadReadPtr(pprop-&gt;Value.MVft.lpft, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_CLSID: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVguid.cValues * sizeof(GUID)) || <br>IsBadReadPtr(pprop-&gt;Value.MVguid.lpguid, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_I8: <br>{ <br>if (!(cbMV = <br>  pprop-&gt;Value.MVli.cValues * sizeof(LARGE_INTEGER)) || <br>IsBadReadPtr(pprop-&gt;Value.MVli.lpli, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_BINARY: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVbin.cValues * sizeof(SBinary)) || <br>IsBadReadPtr(pprop-&gt;Value.MVbin.lpbin, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>for (iValue = 0; <br> (ULONG)iValue &lt; pprop-&gt;Value.MVbin.cValues; <br> iValue++) <br>{ <br>if (IsBadReadPtr(pprop-&gt;Value.MVbin.lpbin[iValue].lpb, <br> (UINT)pprop-&gt;Value.MVbin.lpbin[iValue].cb)) <br>{ <br>goto badProp; <br>} <br> <br>cb += pprop-&gt;Value.MVbin.lpbin[iValue].cb; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_STRING8: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVszA.cValues * sizeof(LPVOID)) || <br>IsBadReadPtr(pprop-&gt;Value.MVszA.lppszA, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>for (iValue = 0; <br>   (ULONG)iValue &lt; pprop-&gt;Value.MVszA.cValues; <br> iValue++) <br>{ <br>if (IsBadStringPtrA(pprop-&gt;Value.MVszA.lppszA[iValue], <br>INFINITE)) <br>{ <br>goto badProp; <br>} <br> <br>cb += lstrlenA(pprop-&gt;Value.MVszA.lppszA[iValue]) + 1; <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br> <br>case PT_MV_UNICODE: <br>{ <br>if (!(cbMV = pprop-&gt;Value.MVszW.cValues * sizeof(LPVOID)) || <br>IsBadReadPtr(pprop-&gt;Value.MVszW.lppszW, (UINT)cbMV)) <br>{ <br>goto badProp; <br>} <br> <br>for (iValue = 0; <br>   (ULONG)iValue &lt; pprop-&gt;Value.MVszW.cValues; <br> iValue++) <br>{ <br>if (IsBadStringPtrW(pprop-&gt;Value.MVszW.lppszW[iValue], <br>INFINITE)) <br>{ <br>goto badProp; <br>} <br> <br>cb +=(lstrlenW(pprop-&gt;Value.MVszW.lppszW[iValue]) + 1) * <br>sizeof(WCHAR); <br>} <br> <br>cb += cbMV; <br> <br>break; <br>} <br>} <br>} <br> <br>if (pcb) <br>*pcb = cb; <br> <br>return NOERROR; <br> <br>badProp: <br> <br>return E_INVALIDARG; <br>} <br> <br> <br>HRESULT <br>HrCopyProps( <br>INintcprop, <br>INLPSPropValuergprop, <br>OUTLPVOIDpvDst, <br>OUTULONG FAR * pcb <br>) <br>{ <br>LPSPropValuepprop; <br>LPSPropValueppropDst; <br>ULONGcb; <br>LPBYTEpb; <br>UINTcbT; <br>intiValue; <br> <br>cb = cprop * sizeof(SPropValue); <br> <br>memcpy(pvDst, rgprop, (UINT)cb); <br> <br>pb = (LPBYTE)pvDst + cb; <br> <br>for (pprop = rgprop, ppropDst = (LPSPropValue)pvDst; <br> cprop--; <br> ++pprop, ++ppropDst) <br>{ <br>//Tricky: common code after the switch increments pb and cb <br>//by the amount copied. If no increment is necessary, the case <br>//uses 'continue' rather than 'break' to exit the switch, thus <br>//skipping the increment -- AND any other code which may be <br>//added after the switch. <br> <br>switch (PROP_TYPE(pprop-&gt;ulPropTag)) <br>{ <br>default: <br>return E_INVALIDARG; <br> <br>case PT_I2: <br>case PT_LONG: <br>case PT_R4: <br>case PT_APPTIME: <br>case PT_DOUBLE: <br>case PT_BOOLEAN: <br>case PT_CURRENCY: <br>case PT_SYSTIME: <br>case PT_CLSID: <br>case PT_I8: <br>case PT_ERROR: <br>case PT_NULL: <br>continue;//nothing to add <br> <br>case PT_BINARY: <br>ppropDst-&gt;Value.bin.lpb = pb; <br>cbT = (UINT)pprop-&gt;Value.bin.cb; <br>memcpy(pb, pprop-&gt;Value.bin.lpb, cbT); <br>break; <br> <br>case PT_STRING8: <br>ppropDst-&gt;Value.lpszA = (LPSTR)pb; <br>cbT = lstrlenA( pprop-&gt;Value.lpszA ) + 1; <br>memcpy(pb, pprop-&gt;Value.lpszA, cbT); <br>break; <br> <br>case PT_UNICODE: <br>ppropDst-&gt;Value.lpszW = (LPWSTR)pb; <br>cbT = (lstrlenW( pprop-&gt;Value.lpszW ) + 1) * sizeof(WCHAR); <br>memcpy(pb, pprop-&gt;Value.lpszW, cbT); <br>break; <br> <br> <br>case PT_MV_I2: <br>ppropDst-&gt;Value.MVi.lpi = (short int FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVi.cValues * sizeof(short int); <br>memcpy(pb, pprop-&gt;Value.MVi.lpi, cbT); <br>break; <br> <br>case PT_MV_LONG: <br>ppropDst-&gt;Value.MVl.lpl = (LONG FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVl.cValues * sizeof(LONG); <br>memcpy(pb, pprop-&gt;Value.MVl.lpl, cbT); <br>break; <br> <br>case PT_MV_R4: <br>ppropDst-&gt;Value.MVflt.lpflt = (float FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVflt.cValues * sizeof(float); <br>memcpy(pb, pprop-&gt;Value.MVflt.lpflt, cbT); <br>break; <br> <br>case PT_MV_APPTIME: <br>ppropDst-&gt;Value.MVat.lpat = (double FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVat.cValues * sizeof(double); <br>memcpy(pb, pprop-&gt;Value.MVat.lpat, cbT); <br>break; <br> <br>case PT_MV_DOUBLE: <br>ppropDst-&gt;Value.MVdbl.lpdbl = (double FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVdbl.cValues * sizeof(double); <br>memcpy(pb, pprop-&gt;Value.MVdbl.lpdbl, cbT); <br>break; <br> <br>case PT_MV_CURRENCY: <br>ppropDst-&gt;Value.MVcur.lpcur = (CURRENCY FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVcur.cValues * sizeof(CURRENCY); <br>memcpy(pb, pprop-&gt;Value.MVcur.lpcur, cbT); <br>break; <br> <br>case PT_MV_SYSTIME: <br>ppropDst-&gt;Value.MVft.lpft = (FILETIME FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVft.cValues * sizeof(FILETIME); <br>memcpy(pb, pprop-&gt;Value.MVft.lpft, cbT); <br>break; <br> <br>case PT_MV_CLSID: <br>ppropDst-&gt;Value.MVguid.lpguid = (GUID FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVguid.cValues * sizeof(GUID); <br>memcpy(pb, pprop-&gt;Value.MVguid.lpguid, cbT); <br>break; <br> <br>case PT_MV_I8: <br>ppropDst-&gt;Value.MVli.lpli = (LARGE_INTEGER FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVli.cValues * sizeof(LARGE_INTEGER); <br>memcpy(pb, pprop-&gt;Value.MVli.lpli, cbT); <br>break; <br> <br>case PT_MV_BINARY: <br>ppropDst-&gt;Value.MVbin.lpbin = (SBinary *) pb; <br>pb += pprop-&gt;Value.MVbin.cValues * sizeof(SBinary); <br>for (iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVbin.cValues; <br>  iValue++) <br>{ <br>ppropDst-&gt;Value.MVbin.lpbin[iValue].lpb = pb; <br>cbT = (UINT)pprop-&gt;Value.MVbin.lpbin[iValue].cb; <br>memcpy(pb, pprop-&gt;Value.MVbin.lpbin[iValue].lpb, cbT); <br>cb += cbT; <br>pb += cbT; <br>} <br>continue;//already updated, don't do it again <br> <br>case PT_MV_STRING8: <br>ppropDst-&gt;Value.MVszA.lppszA = (LPSTR *) pb; <br>pb += pprop-&gt;Value.MVszA.cValues * sizeof(LPSTR); <br>for (iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVszA.cValues; <br>  iValue++) <br>{ <br>ppropDst-&gt;Value.MVszA.lppszA[iValue] = (LPSTR)pb; <br>cbT = lstrlenA(pprop-&gt;Value.MVszA.lppszA[iValue]) + 1; <br>memcpy(pb, pprop-&gt;Value.MVszA.lppszA[iValue], cbT); <br>pb += cbT; <br>cb += cbT; <br>} <br>continue;//already updated, don't do it again <br> <br>case PT_MV_UNICODE: <br>ppropDst-&gt;Value.MVszW.lppszW = (LPWSTR *) pb; <br>pb += pprop-&gt;Value.MVszW.cValues * sizeof(LPWSTR); <br>for (iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVszW.cValues; <br>  iValue++) <br>{ <br>ppropDst-&gt;Value.MVszW.lppszW[iValue] = (LPWSTR)pb; <br>cbT = (lstrlenW(pprop-&gt;Value.MVszW.lppszW[iValue]) + 1) <br>* sizeof(WCHAR); <br>memcpy(pb, pprop-&gt;Value.MVszW.lppszW[iValue], cbT); <br>pb += cbT; <br>cb += cbT; <br>} <br>continue;//already updated, don't do it again <br>} <br> <br>//Advance ptr and total count by the amount copied <br>pb += cbT; <br>cb += cbT; <br>} <br> <br>if (pcb) <br>*pcb = cb; <br> <br>return NOERROR; <br>} <br> <br>/* <br> *Wrapper function to just duplicate a property value array <br> *into a single block of MAPI memory. <br> */ <br> <br>HRESULT <br>HrDupPropset( <br>INint cprop, <br>INLPSPropValuergprop, <br>INLPVOIDlpObject, <br>OUTLPSPropValue FAR *prgprop <br>) <br>{ <br>ULONGcb; <br>HRESULThr; <br> <br>//Find out how much memory we need <br> <br>if (hr = HrCountProps(cprop, rgprop, &amp;cb)) <br>goto ret; <br> <br>//Obtain memory <br> <br>if (lpObject != NULL) <br>hr = MAPIAllocateMore(cb, lpObject, (LPVOID FAR *)prgprop); <br>else <br>hr = MAPIAllocateBuffer(cb, (LPVOID FAR *)prgprop); <br> <br>if (hr) <br>goto ret; <br> <br>//Copy the properties <br> <br>if (hr = HrCopyProps(cprop, rgprop, *prgprop, &amp;cb)) <br>goto ret; <br> <br>ret: <br>return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
