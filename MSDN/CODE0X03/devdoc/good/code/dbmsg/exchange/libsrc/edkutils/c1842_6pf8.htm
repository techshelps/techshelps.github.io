<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EDKRTF.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1844"></a>EDKRTF.C</h2>
<pre><code>// --edkrtf.c------------------------------------------------------------------ <br>// <br>// EDK utility functions to help with creating the PR_RTF_COMPRESSED <br>// message property. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996, All rights reserved. <br>// <br>// ---------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "edkrtf.chk" <br> <br>//$--HrTextToRTFCompressed------------------------------------------------ <br>// <br>// DESCRIPTION: Convert plain ANSI text to its RTF compressed  <br>//              equivalent for a MAPI message. <br>//  <br>// INPUT:       cchText --  number of text character to convert <br>//              lpText  --  plain ANSI text to convert <br>//                              cAttachments    --      # of message attachments <br>//                              rgiRendering    --      array of attachment rendering positions <br>//              lpMsg   --  MAPI message pointer for which to create <br>//                          the compressed rich text <br>//              cpid    --  code page of the text stream <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                                                      MAPI_E_* if IMAPIProp::OpenProperty() fails during RTF  <br>//                                                              property creation, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT HrTextToRTFCompressed( <br>    IN ULONG cchText,       // # characters of text <br>    IN LPSTREAM lpText,     // plain text stream pointer <br>IN ULONG cAttachments,  // # of message attachments <br>IN ULONG * rgiRendering,// array of attachment rendering positions <br>    IN LPMESSAGE lpMsg,     // MAPI message pointer <br>IN ULONG cpid) <br>{ <br>    HRESULT         hr                      =  NOERROR; <br>    LPSTREAM        lpText2                 =  NULL;// text stream <br>LPSTREAM        lpRTFText               =  NULL;// uncompressed RTF stream <br>    LPSTREAM        lpRTFComp               =  NULL;// RTF compressed stream <br>    LPSTREAM        lpRTFUnComp             =  NULL;// uncompressed RTF stream <br>ULONG           iAttach                 =  0;   // attachment index <br>ULARGE_INTEGER  cbBlockSize             =  {INT_MAX,0}; <br>ULARGE_INTEGER  cbTextSize              =  {cchText,0}; <br>    ULARGE_INTEGER  scbRead                 =  {0}; // # bytes read from stream <br>    ULARGE_INTEGER  scbWritten              =  {0}; // # bytes written to stream <br>    LARGE_INTEGER   cbTopOfFile             =  {0}; <br>    // MAPI property creation flags <br>    const ULONG ulFlags = MAPI_CREATE | MAPI_MODIFY | MAPI_DEFERRED_ERRORS; <br> <br>    DEBUGPUBLIC("HrTextToRTFCompressed()\n"); <br>     <br>// check input parameters <br>    hr = CHK_HrTextToRTFCompressed(cchText, lpText, cAttachments,  <br>      rgiRendering, lpMsg, cpid); <br>if (FAILED(hr)) <br>{ <br>RETURN(hr); <br>} <br> <br>    // Create another stream and copy only the bytes we want to it. <br>    // We do this since we don't know the number of RTF compressed <br>    // bytes to copy to the message. <br>    // 1.) Create lpTextStream2 <br>    // 2.) Copy the correct number of bytes over <br>     <br>hr = CreateStreamOnHGlobal( <br>            NULL,   // it will allocate the memory <br>            TRUE,   // free memory on release <br>            &amp;lpText2); <br> <br>if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = OLECALL(lpText)-&gt;CopyTo(lpText, lpText2, cbTextSize, &amp;scbRead, &amp;scbWritten); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>hr = OLECALL(lpText2)-&gt;Commit(lpText2, STGC_DEFAULT); <br> <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>    hr = OLECALL(lpText2)-&gt;Seek(lpText2,  <br>cbTopOfFile,     <br>STREAM_SEEK_SET, <br>NULL); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>    hr  = HrRTFFromTextStream(lpText2, &amp;lpRTFText, cpid, cAttachments, rgiRendering); <br> <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>    ASSERT_IUNKNOWN_PTR(lpRTFText, "Bad lpRTFText"); <br> <br>    // Open a stream on the newly created PR_RTF_COMPRESSED <br>    // message property. <br>    hr = MAPICALL(lpMsg)-&gt;OpenProperty( <br>    lpMsg,                  // message pointer <br>    PR_RTF_COMPRESSED,      // property tag <br>    &amp;IID_IStream,           // interface ID reference <br>    STGM_CREATE | STGM_WRITE,   // interface flags <br>    ulFlags,                // MAPI flags <br>    (LPUNKNOWN *) &amp;lpRTFComp);  // stream pointer <br> <br>if (FAILED(hr)) <br>{ <br>// Return MAPI error. <br> <br>goto cleanup; <br>} <br> <br>    ASSERT_IUNKNOWN_PTR(lpRTFComp, "Bad lpRTFComp"); <br> <br>hr = WrapCompressedRTFStream (lpRTFComp, MAPI_CREATE | MAPI_MODIFY, &amp;lpRTFUnComp); <br> <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>hr = OLECALL(lpRTFText)-&gt;CopyTo(lpRTFText, <br>lpRTFUnComp, <br>cbBlockSize, <br>&amp;scbRead, <br>&amp;scbWritten); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br> <br>hr = OLECALL(lpRTFUnComp)-&gt;Commit(lpRTFUnComp, STGC_DEFAULT); <br> <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>    // Release MAPI &amp; OLE objects <br>    ULRELEASE(lpText2); <br>    ULRELEASE(lpRTFText); <br>    ULRELEASE(lpRTFComp); <br>ULRELEASE(lpRTFUnComp); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrRTFCompressedToText-------------------------------------------------- <br>// <br>// DESCRIPTION: Convert message's compressed RTF to its ANSI  <br>//              equivalent. <br>//  <br>// INPUT:       lpMsg   --  MAPI message pointer for which to retrieve <br>//                          the ANSI text. <br>//              pText   --  pointer to stream to copy ANSI text to. <br>//              cpid    --  code page for the text stream <br>// <br>// OUTPUT:      pcb     --  # bytes copied to stream <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          MAPI_E_* if IMAPIProp::OpenProperty() fails during RTF <br>//                                                              property open, <br>//                          E_FAIL otherwise <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT HrRTFCompressedToText( <br>    IN LPMESSAGE lpMsg,         // MAPI message pointer <br>    IN LPSTREAM pText,          // stream to copy ANSI text to <br>IN ULONG cpid,                          // code page <br>    OUT ULONG * pcb)            // # bytes copied to stream <br>{ <br>    HRESULT         hr          =   NOERROR; <br>    LPSTREAM        lpRTFComp   =   NULL;   // RTF compressed stream <br>    LPSTREAM        lpTextWrap  =   NULL;   // "wrapper" stream pointer <br>    RTFSYNCINFO     sRtfSync    =   {0};    // RTFSYNCINFO structure <br>    ULARGE_INTEGER  scbInfinite =   {0};    // "infinite" large integer <br>    ULARGE_INTEGER  scbWritten  =   {0};    // # bytes written to stream <br> <br>    DEBUGPUBLIC("HrRTFCompressedToText()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrRTFCompressedToText(lpMsg, pText, cpid, pcb); <br> <br>    if ( FAILED(hr) ) <br>    { <br>RETURN(hr); <br>    } <br> <br>    // initialize output parameters <br>    *pcb = 0; <br> <br>    // Open a stream interface on the message's RFT compressed <br>    // message text property. <br>    hr = MAPICALL(lpMsg)-&gt;OpenProperty( <br>lpMsg,                  // message pointer <br>PR_RTF_COMPRESSED,      // property tag <br>&amp;IID_IStream,           // interface ID reference <br>STGM_READ,              // interface flags <br>MAPI_DEFERRED_ERRORS,   // reduces RPCs <br>(LPUNKNOWN *) &amp;lpRTFComp);  // stream pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>// Return MAPI error. <br> <br>goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(lpRTFComp, "Bad lpRTFComp"); <br> <br>    // Convert RTF compressed stream data to ANSI "wrapper" stream. <br>    // The ANSI wrapper stream supports only the CopyTo and Read <br>    // methods. <br>    hr = HrTextFromCompressedRTFStreamEx( <br>lpRTFComp,  // RTF compressed stream pointer <br>&amp;lpTextWrap,// pointer to wrapper stream pointer <br>&amp;sRtfSync,  // RTFSYNCINFO pointer <br>cpid,       // code page (use default) <br>0,          // zero attachments <br>NULL);      // no attachment array <br> <br>    if ( FAILED(hr) ) <br>    { <br>goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(lpTextWrap, "Bad lpTextWrap"); <br> <br>    // Copy the contents of the "wrapper" stream (which only supports <br>    // the Read &amp; CopyTo methods) to the stream provided. <br>    scbInfinite.LowPart = INFINITE; // want to copy all data <br>    hr = OLECALL(lpTextWrap)-&gt;CopyTo( <br>lpTextWrap,     // stream pointer <br>pText,          // destination stream <br>scbInfinite,    // # bytes to copy <br>NULL,           // don't care <br>&amp;scbWritten);   // # bytes copied <br> <br>    if ( FAILED(hr) ) <br>    { <br>goto cleanup; <br>    } <br> <br>    // check that number of bytes written is less than <br>    // what we can handle. <br>    if ( (scbWritten.LowPart == INFINITE) || <br> (scbWritten.HighPart != 0) ) <br>    { <br>hr = HR_LOG(E_NOTIMPL); <br> <br>goto cleanup; <br>    } <br> <br>    // Fill in number of bytes copied <br>    *pcb = scbWritten.LowPart; <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Release MAPI and OLE objects <br>    ULRELEASE(lpRTFComp); <br>    ULRELEASE(lpTextWrap); <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
