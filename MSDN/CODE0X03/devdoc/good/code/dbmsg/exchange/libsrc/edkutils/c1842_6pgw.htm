<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTL_REG.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1850"></a>UTL_REG.C</h2>
<pre><code>// --UTL_REG.C------------------------------------------------------------------ <br>// <br>// Registry key helper functions. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "utl_reg.chk" <br> <br>//$--HrIdentifyRegistryRootKey------------------------------------------------------ <br>// <br>//  DESCRIPTION:Checks that a fully qualified key name begins with one of the four <br>//predefined NT Registry keys: HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT, <br>//HKEY_CURRENT_USER, or HKEY_USERS.  The output from this function <br>//can be passed to registry functions like RegOpenKeyEx(). <br>// <br>//INPUT:pszKey - pointer to fully qualified key name <br>// <br>//OUTPUT:phkKeyHandle - pointer to key handle <br>//ppszSubKey - pointer to subkey section of pszKey <br>// <br>//RETURNS:HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise, <br>// <br>//Notes:   Successful completion.  hkKey is the Registry key handle, <br>//pszSubKey points to the remainder of the subkey string.  Note <br>//that it is legitimate for pszSubKey to be NULL, meaning that <br>//the user is trying to access values in the root of one of the <br>//predefined registry keys. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#defineNOT_A_KEY_HANDLE(0) <br> <br>HRESULT HrIdentifyRegistryRootKey(      // RETURNS: HRESULT <br>                                    IN  char *pszKey,   // pointer to fully qualified key name <br>OUT HKEY *phkKeyHandle, // pointer to key handle <br>OUT char **ppszSubKey)  // pointer to subkey section <br>{ <br>    HRESULT     hr  =   NOERROR; <br>char *pszBackslashChar    =   NULL; <br>intnCompLen    =   0; <br> <br>    DEBUGPUBLIC("HrIdentifyRegistryRootKey()"); <br> <br>    // check input parameters <br>    hr = CHK_HrIdentifyRegistryRootKey(pszKey, phkKeyHandle, ppszSubKey); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>// <br>//initialise <br>//outputs. <br>// <br> <br>    *phkKeyHandle = NOT_A_KEY_HANDLE; <br>*ppszSubKey = NULL; <br> <br>// <br>//Ignore leading backslash character. <br>// <br>//e.g. pszKey = "\HKEY_LOCAL_MACHINE\SubKey" <br>// <br> <br>if (*pszKey == '\\') <br>++pszKey; <br> <br>// <br>//Search for the next backslash in the key name <br>// <br> <br>pszBackslashChar = strchr(pszKey,'\\'); <br> <br>// <br>//The subkey string begins with the first character <br>//after the backslash delimiter.  (In NT 3.5 the function <br>//RegCreateKeyEx() requires that subkey strings *not* <br>//begin with a backslash). <br>// <br> <br>if (pszBackslashChar == NULL) <br>*ppszSubKey = NULL; <br>else <br>{ <br>*ppszSubKey = pszBackslashChar + 1; <br> <br>// <br>//Set pszSubKey to NULL if there are no characters after <br>//the backslash delimiter. <br>// <br>//e.g. pszKey = "HKEY_LOCAL_KEY\" <br>// <br> <br>if (**ppszSubKey == '\0') <br>*ppszSubKey = NULL; <br>} <br> <br>// <br>//Perform comparisons only on characters before <br>//the backslash delimiter. <br>// <br> <br>if (pszBackslashChar == NULL) <br>nCompLen = strlen(pszKey); <br>else <br>nCompLen = (pszBackslashChar - pszKey); <br> <br>// <br>//Exit if there is nothing to compare. <br>// <br> <br>if (nCompLen &lt;= 0) <br>{ <br>        hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br> <br>// <br>//Select on the number of characters to compare, <br>//then check for a string match. <br>// <br> <br>ASSERTERROR(strlen("HKEY_LOCAL_MACHINE") == 18,"Invalid string length"); <br>ASSERTERROR(strlen("HKEY_CLASSES_ROOT") == 17,"Invalid string length"); <br>ASSERTERROR(strlen("HKEY_CURRENT_USER") == 17,"Invalid string length"); <br>ASSERTERROR(strlen("HKEY_USERS") == 10,"Invalid string length"); <br> <br>switch(nCompLen) <br>{ <br>case 18 : <br> <br>if (strncmp(pszKey,"HKEY_LOCAL_MACHINE",nCompLen) == 0) <br>*phkKeyHandle = HKEY_LOCAL_MACHINE; <br>else <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>break; <br> <br>case 17 : <br> <br>if (strncmp(pszKey,"HKEY_CLASSES_ROOT",nCompLen) == 0) <br>*phkKeyHandle = HKEY_CLASSES_ROOT; <br>else <br>if (strncmp(pszKey,"HKEY_CURRENT_USER",nCompLen) == 0) <br>*phkKeyHandle = HKEY_CURRENT_USER; <br>else <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>} <br> <br>break; <br> <br>case 10 : <br> <br>if (strncmp(pszKey,"HKEY_USERS",nCompLen) == 0) <br>*phkKeyHandle = HKEY_USERS; <br>else <br>            { <br>                hr = HR_LOG(E_FAIL); <br> <br>                goto cleanup; <br>            } <br> <br>break; <br> <br>default : <br> <br>            hr = HR_LOG(E_FAIL); <br> <br>            goto cleanup; <br>} <br> <br>cleanup: <br> <br>if ( FAILED(hr) &amp;&amp; (hr != E_INVALIDARG) ) <br>{ <br>*phkKeyHandle = NOT_A_KEY_HANDLE; <br>*ppszSubKey = NULL; <br>} <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--_HrReadRegistrySZ-------------------------------------------------------- <br>// <br>//  DESCRIPTION :Read a string from the registry. <br>// <br>//  INPUT:  hRegistryKey    --  registry key to read value from <br>//          lpszValueName   --  name of value to read <br>// <br>//  INPUT OUTPUT:   lpcbBufferSize  --  size of buffer for value and size of value <br>// <br>//  OUTPUT: lpszBuffer      -- buffer to read value into <br>// <br>//  RETURNS:    HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input <br>//                          EDK_E_NOT_FOUND if value does not exist <br>//                          E_FAIL if failure due to other error <br>// <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT _HrReadRegistrySZ(// RETURNS: HRESULT <br>IN HKEY hRegistryKey,// registry key to read value from <br>IN LPSTR lpszValueName,// name of value to read <br>OUT LPSTR lpszBuffer,// buffer to read value into <br>IN OUT DWORD *lpcbBufferSize)// size of buffer to read value into <br>{ <br>    HRESULT     hr          = NOERROR; <br>DWORDdwStatus= ERROR_SUCCESS; <br>DWORDdwType= 0; <br> <br>DEBUGPUBLIC("_HrReadRegistrySZ()"); <br> <br>    // Check input parameters <br>    hr = CHK__HrReadRegistrySZ(hRegistryKey, lpszValueName, lpszBuffer, lpcbBufferSize); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>dwStatus = RegQueryValueEx( <br>hRegistryKey,  <br>lpszValueName,  <br>NULL,  <br>&amp;dwType,  <br>(LPBYTE)lpszBuffer,  <br>lpcbBufferSize); <br> <br>if (dwStatus != ERROR_SUCCESS || dwType != REG_SZ) <br>{ <br>        if(dwStatus != ERROR_SUCCESS) <br>        { <br>            hr = HR_LOG(HRESULT_FROM_WIN32(dwStatus)); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br> <br>        goto cleanup; <br>} <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--_HrReadRegistryDWORD----------------------------------------------------- <br>// <br>//  DESCRIPTION: Read a DWORD integer from the registry. <br>// <br>//  INPUT:  hRegistryKey    --  registry key to read value from <br>//          lpszValueName   --  name of value to read <br>// <br>//  OUTPUT: lpdwBuffer  --  DWORD buffer to read value into <br>// <br>//  RETURNS:    HRESULT --  NOERROR is success, <br>//                          E_INVALIDARG if bad input <br>//                          EDK_E_NOT_FOUND if value does not exist <br>//                          E_FAIL if failure due to other error <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT _HrReadRegistryDWORD(// RETURNS: HRESULT <br>IN HKEY hRegistryKey,// registry key to read value from <br>IN LPSTR lpszValueName,// name of value to read <br>OUT LPDWORD lpdwBuffer)// address of DWORD to read value into <br>{ <br>    HRESULT     hr              = NOERROR; <br>DWORDdwStatus= ERROR_SUCCESS; <br>DWORDdwType= 0; <br>DWORDcbBufferSize= sizeof(DWORD); <br> <br>DEBUGPUBLIC("_HrReadRegistryDWORD()"); <br> <br>    // Check input parameters. <br>    hr = CHK__HrReadRegistryDWORD(hRegistryKey, lpszValueName, lpdwBuffer); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>dwStatus = RegQueryValueEx( <br>hRegistryKey,  <br>lpszValueName,  <br>NULL,  <br>&amp;dwType,  <br>(LPBYTE)lpdwBuffer,  <br>&amp;cbBufferSize); <br> <br>if (dwStatus != ERROR_SUCCESS || dwType != REG_DWORD) <br>{ <br>        if(dwStatus != ERROR_SUCCESS) <br>        { <br>            hr = HR_LOG(HRESULT_FROM_WIN32(dwStatus)); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br> <br>        goto cleanup; <br>} <br> <br>cleanup:     <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--_HrWriteRegistrySZ------------------------------------------------------- <br>// <br>//  DESCRIPTION: Write a string to the registry. <br>// <br>//  INPUT:  hRegistryKey    --  registry key to write value to <br>//          lpszValueName   --  name of value to write <br>//          lpszValue       --  string value to write <br>// <br>//  RETURNS:    HRESULT --  NOERROR if success <br>//                          E_INVALIDARG if bad input <br>//                          E_FAIL otherwise. <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT _HrWriteRegistrySZ(// RETURNS: HRESULT <br>IN HKEY hRegistryKey,// registry key to write value to <br>IN LPSTR lpszValueName,// name of value to write <br>IN LPCSTR lpszValue)// string value to write <br>{ <br>    HRESULT     hr          = NOERROR; <br>DWORDdwStatus= ERROR_SUCCESS; <br> <br>DEBUGPUBLIC("_HrWriteRegistrySZ()"); <br> <br>    // Check input parameters <br>    hr = CHK__HrWriteRegistrySZ(hRegistryKey, lpszValueName, lpszValue); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>dwStatus = RegSetValueEx( <br>hRegistryKey,  <br>lpszValueName,  <br>0L,  <br>REG_SZ,  <br>(LPBYTE)lpszValue,  <br>(lstrlen(lpszValue) + 1) * sizeof(CHAR)); <br> <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>        hr = HR_LOG(HRESULT_FROM_WIN32(dwStatus)); <br> <br>        goto cleanup; <br>} <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--_HrWriteRegistryDWORD---------------------------------------------------- <br>// <br>//  DESCRIPTION: Write a DWORD integer to the registry. <br>// <br>//  INPUT:  hRegistryKey    --  registry key to write value to <br>//          lpszValueName   --  name of value to write <br>//          dwValue         --  value to write <br>// <br>//  RETURNS:    HRESULT --  NOERROR is success, <br>//              E_INVALIDARG if bad input <br>//              E_FAIL otherwise <br>// <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT _HrWriteRegistryDWORD(// RETURNS: HRESULT <br>IN HKEY hRegistryKey,// registry key to write value to <br>IN LPSTR lpszValueName,// name of value to write <br>IN DWORD dwValue)// DWORD value to write <br>{ <br>    HRESULT     hr          = NOERROR; <br>DWORDdwStatus= ERROR_SUCCESS; <br> <br>DEBUGPUBLIC("_HrWriteRegistryDWORD()"); <br> <br>    // Check input parameters <br>    hr = CHK__HrWriteRegistryDWORD(hRegistryKey, lpszValueName, dwValue); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>dwStatus = RegSetValueEx( <br>hRegistryKey,  <br>lpszValueName,  <br>0L,  <br>REG_DWORD,  <br>(LPBYTE)&amp;dwValue,  <br>sizeof(dwValue)); <br> <br>if (dwStatus != ERROR_SUCCESS) <br>{ <br>        hr = HR_LOG(HRESULT_FROM_WIN32(dwStatus)); <br> <br>        goto cleanup; <br>} <br> <br>cleanup: <br> <br>    RETURN(hr); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
