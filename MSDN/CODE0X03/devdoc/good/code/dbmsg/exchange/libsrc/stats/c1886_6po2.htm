<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1892"></a>STATS.CPP</h2>
<pre><code>// --stats.cpp------------------------------------------------------------------ <br>// <br>//  C wrappers for the C++ stats library. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "fldmtrc.h" <br>#include "jswindow.h" <br>#include "stats.chk" <br> <br>extern "C" { <br> <br>#define INT64_FROM_FILETIME(li) (*((__int64 *)&amp;(li))) <br>#define FILETIME_FROM_INT64(li) (*((FILETIME *)&amp;(li))) <br> <br> <br>//$--HrOpenFolderMetrics-------------------------------------------------------- <br>//  Prepares a folder for retreiving metrics. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrOpenFolderMetrics(            // RETURNS: HRESULT <br>    IN LPMAPIFOLDER lpFolder,           // pointer to target mapi folder <br>    OUT HFLDMTRC *phFolderMetrics)      // receives handle to folder metric <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrOpenFolderMetrics()\n"); <br> <br>hr = CHK_HrOpenFolderMetrics(lpFolder, phFolderMetrics); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    if (phFolderMetrics == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    *phFolderMetrics = (HFLDMTRC *)new CFolderMetrics(); <br> <br>    if (*phFolderMetrics == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br> <br>    hr = ((CFolderMetrics *)*phFolderMetrics)-&gt;HrReset(lpFolder); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if ((FAILED(hr)) &amp;&amp; (*phFolderMetrics != NULL)) <br>    { <br>        delete (CFolderMetrics *)*phFolderMetrics; <br> <br>        *phFolderMetrics = NULL; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br> <br>//$--HrGetFolderMetrics--------------------------------------------------------- <br>//  Retrieves the metrics (size, longest wait, total wait) from a folder. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGetFolderMetrics(             // RETURNS: HRESULT <br>    IN HFLDMTRC hFolderMetrics,         // handle created from rcOpenFolderMetrics <br>    IN FILETIME *pftNow,                // Current time expressed as FILETIME <br>    IN DWORD fMetric,                   // Flags for metric requested. May <br>                                        //  be or'ed combination of: <br>                                        //     FM_CMESSAGES <br>                                        //     FM_LONGEST_WAIT <br>                                        //     FM_TOTAL_WAIT <br>    OUT DWORD *pcMessages,              // If requested, recieves the number  <br>                                        // of messages in folder. 0 otherwise <br>    OUT FILETIME *pftLongestWait,       // If requested, receives the longest <br>                                        // wait of messages currently in folder. <br>    OUT FILETIME *pftTotalWait)         // If requested, receives the total <br>                                        // wait of all messages in folder. <br>{ <br> <br>    HRESULT hr              = NOERROR; <br>    __int64 liNow           = 0; <br> <br>    __int64 liLongestWait   = 0; <br>    __int64 liTotalWait     = 0; <br> <br>    DEBUGPRIVATE("HrGetFolderMetrics()\n"); <br> <br>hr = CHK_HrGetFolderMetrics( <br>hFolderMetrics,  <br>pftNow,  <br>fMetric,  <br>pcMessages,  <br>pftLongestWait,  <br>pftTotalWait); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    liNow = INT64_FROM_FILETIME(*pftNow); <br> <br>    hr = ((CFolderMetrics *)hFolderMetrics)-&gt;HrGetFolderMetrics( <br>    liNow, fMetric, *pcMessages, liLongestWait, liTotalWait); <br> <br>if (SUCCEEDED(hr)) <br>{ <br>*pftLongestWait = FILETIME_FROM_INT64(liLongestWait); <br>*pftTotalWait = FILETIME_FROM_INT64(liTotalWait); <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--CloseFolderMetrics--------------------------------------------------------- <br>//  Releases resources allocated in OpenFolderMetric. <br>// ----------------------------------------------------------------------------- <br>VOID CloseFolderMetrics(                // RETURNS: nothing <br>    IN HFLDMTRC hFolderMetrics)         // handle generated by OpenFolderMetric <br>{ <br>    HRESULT hr              = NOERROR; <br> <br>    DEBUGPRIVATE("CloseFolderMetrics()\n"); <br> <br>hr = CHK_CloseFolderMetrics(hFolderMetrics); <br>if (FAILED(hr)) <br>return; <br> <br>    delete (CFolderMetrics *) hFolderMetrics; <br>} <br> <br> <br>//$--HrJSOpen------------------------------------------------------------- <br>//  Opens a JumpSlide windows. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrJSOpen(         // RETURNS: HRESULT <br>    IN JSWINDOWTYPE enType,     // The type of window to open <br>    IN FILETIME *pftNow,        // The current time expressed as a FILETIME <br>    IN FILETIME *pftResolution, // The resolution of the window. The <br>                                // window will jump in intervals of this <br>                                // size. <br>    IN DWORD dwWindowDuration,  // Duration of window expressed in resoution <br>                                // units. <br>    OUT HJSWINDOW *phJSWindow)  // Receives handle to newly opened window. <br>{ <br>    HRESULT hr              = NOERROR; <br>    __int64 liNow           = 0; <br>    __int64 liResolution    = 0; <br> <br>    DEBUGPUBLIC("HrJSOpen()\n"); <br> <br>hr = CHK_HrJSOpen( <br>enType,  <br>pftNow,  <br>pftResolution,  <br>dwWindowDuration,  <br>phJSWindow); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    switch (enType) <br>    { <br>        case (JSWINDOW_MIN) : <br>            *phJSWindow = (HJSWINDOW) new CJSWindowMin(); <br>            break; <br>        case (JSWINDOW_MAX) : <br>            *phJSWindow = (HJSWINDOW) new CJSWindowMax(); <br>            break; <br>        case (JSWINDOW_AVERAGE) : <br>            *phJSWindow = (HJSWINDOW) new CJSWindowAverage(); <br>            break; <br>        case (JSWINDOW_TOTAL_RATE) : <br>            *phJSWindow = (HJSWINDOW) new CJSWindowTotal(); <br>            break; <br>        default: <br>            *phJSWindow = NULL; <br>    } <br> <br>    if (*phJSWindow == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    liNow = INT64_FROM_FILETIME(*pftNow); <br>    liResolution = INT64_FROM_FILETIME(*pftResolution); <br> <br>    hr = ((CJSWindow *)(*phJSWindow))-&gt;HrReset( <br>    liNow, liResolution, dwWindowDuration); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if ((FAILED(hr)) &amp;&amp; (*phJSWindow!=NULL)) <br>    { <br>        delete (CJSWindow *) *phJSWindow; <br>        *phJSWindow = NULL; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrJSCollectDataPoint------------------------------------------------- <br>//  Places a new data point into the window. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrJSCollectDataPoint(     // RETURNS: HRESULT <br>    IN HJSWINDOW hJSWindow,             // Handle to TARGET JSWindow <br>    IN FILETIME *pftNow,                // Current time expressed as FILETIME <br>    IN DWORD dwValue)                   // Value of data point to add <br>{ <br>    HRESULT hr      = NOERROR; <br>    __int64 liNow   = 0; <br> <br>    DEBUGPRIVATE("HrJSCollectDataPoint()\n"); <br> <br>hr = CHK_HrJSCollectDataPoint(hJSWindow, pftNow, dwValue); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    liNow = INT64_FROM_FILETIME(*pftNow); <br> <br>    ((CJSWindow *)hJSWindow)-&gt;DataPoint(liNow, dwValue); <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrJSGetValue--------------------------------------------------------- <br>//  Retrieves and interval value from a window. <br>// <br>//  If the window has not had sufficient time to fill, an estimate of a <br>//  filled window can be made by normalizing the return value. The normalizing <br>//  fraction is returned in the parameters pdwFractionCompleteNum, <br>//  and pdwFractionCompleteDen. <br>// <br>//  Querying the window value after it has had time to fill will always <br>//  return a fraction complete of 1.  <br>// <br>//  (ie. *pdwFractionCompleteNum/*pdwFractionCompleteDen == 1) <br>// <br>//  Example: <br>//  A JSWindow of TOTAL type with a duration of 1 hour. <br>//  The window has only been gathering Data points for 30 minutes. <br>//  Calling JSWindowGetValue() will return the total of the data points <br>//  in the last 30 minutes and return a fraction complete of 1/2. <br>// <br>//  The calling program can turn the returned value into an estimate of  <br>//  total of data points over the last period if it normalizes the value <br>//  by the fraction complete.  In the above example multiplying the returned <br>//  value by 2 will generate the hourly estimate. <br>// <br>// ----------------------------------------------------------------------------- <br>HRESULT HrJSGetValue(             // RETURNS: HRESULT <br>    IN HJSWINDOW hJSWindow,             // Hand of window. <br>    IN FILETIME *pftNow,                // Current time expressed as FILETIME <br>    OUT DWORD *pdwWindowValue,          // Window value <br>    OUT DWORD *pdwFractionCompleteNum,  // Fraction of window that was filled <br>                                        // numerator. <br>    OUT DWORD *pdwFractionCompleteDen)  // Fraction of window that was filled <br>                                        // denominator. <br>{ <br>    HRESULT hr      = NOERROR; <br>    __int64 liNow   = 0; <br> <br>    DEBUGPUBLIC("HrJSGetValue()\n"); <br> <br>hr = CHK_HrJSGetValue( <br>hJSWindow,  <br>pftNow,  <br>pdwWindowValue,  <br>pdwFractionCompleteNum,  <br>pdwFractionCompleteDen); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    liNow = INT64_FROM_FILETIME(*pftNow); <br> <br>    hr = ((CJSWindow *)hJSWindow)-&gt;HrGetValue(liNow, *pdwWindowValue,  <br>    *pdwFractionCompleteNum, *pdwFractionCompleteDen); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--JSClose-------------------------------------------------------------- <br>//  Closes and destroys a Jump Slide Window. <br>// ----------------------------------------------------------------------------- <br>VOID JSClose(                     // RETURNS: nothing <br>    IN HJSWINDOW hJSWindow)             // handle of window to close <br>{ <br>    HRESULT hr      = NOERROR; <br> <br>    DEBUGPRIVATE("JSClose()\n"); <br> <br>hr = CHK_JSClose(hJSWindow); <br>if (FAILED(hr)) <br>return; <br> <br>    delete (CJSWindow *)hJSWindow; <br>} <br> <br> <br>//$--HrFileTimeToSeconds-------------------------------------------------------- <br>//  Converts a FILETIME to the number of seconds.  The FILETIME may <br>//  represent the number of seconds larger than can be represenred in  <br>//  a DWORD.  In that case, this function will return E_FAIL. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrFileTimeToSeconds(            // RETURNS: HRESULT <br>    IN FILETIME *pft,                   // file time to convert  <br>    OUT DWORD *pdwSec)                  // receives time in seconds (0 if error) <br>{ <br>    HRESULT hr      = NOERROR; <br>    __int64 lift    = 0; <br>    __int64 liSec   = 0; <br> <br>    DEBUGPUBLIC("HrFileTimeToSeconds()\n"); <br> <br>hr = CHK_HrFileTimeToSeconds(pft, pdwSec); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    *pdwSec = 0; <br> <br>    lift = INT64_FROM_FILETIME(*pft); <br> <br>    liSec = lift / (DWORD) 10000000L; <br> <br>    if (FILETIME_FROM_INT64(liSec).dwHighDateTime != 0) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    *pdwSec = (DWORD)liSec; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>}  // extern "C" <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
