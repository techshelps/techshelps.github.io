<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADDRLKUP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1821"></a>ADDRLKUP.C</h2>
<pre><code>// --addrlkup.c----------------------------------------------------------------- <br>// <br>//  Functions used in address mapping. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include "addrlkup.chk" <br> <br>//$--HrFindExchangeGlobalAddressList------------------------------------------------- <br>// Returns the entry ID of the global address list container in the address <br>// book. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrFindExchangeGlobalAddressList( // RETURNS: return code <br>    IN LPADRBOOK  lpAdrBook,        // address book pointer <br>    OUT ULONG *lpcbeid,             // pointer to count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)          // pointer to entry ID pointer <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    ULONG           ulObjType           = 0; <br>    ULONG           i                   = 0; <br>    LPMAPIPROP      lpRootContainer     = NULL; <br>    LPMAPIPROP      lpContainer         = NULL; <br>    LPMAPITABLE     lpContainerTable    = NULL; <br>    LPSRowSet       lpRows              = NULL; <br>    ULONG           cbContainerEntryId  = 0; <br>    LPENTRYID       lpContainerEntryId  = NULL; <br>    LPSPropValue    lpCurrProp          = NULL; <br>    SRestriction    SRestrictAnd[2]     = {0}; <br>    SRestriction    SRestrictGAL        = {0}; <br>    SPropValue      SPropID             = {0}; <br>    SPropValue      SPropProvider       = {0}; <br>    BYTE            muid[]              = MUIDEMSAB; <br> <br>    SizedSPropTagArray(1, rgPropTags) = <br>    { <br>        1,  <br>        { <br>            PR_ENTRYID, <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrFindExchangeGlobalAddressList()"); <br> <br>    hr = CHK_HrFindExchangeGlobalAddressList( <br>        lpAdrBook, <br>        lpcbeid, <br>        lppeid); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcbeid = 0; <br>    *lppeid  = NULL; <br> <br>    // Open the root container of the address book <br>    hr = MAPICALL(lpAdrBook)-&gt;OpenEntry( <br>        lpAdrBook,  <br>        0, <br>        NULL, <br>        NULL, <br>        MAPI_DEFERRED_ERRORS,  <br>        &amp;ulObjType, <br>        (LPUNKNOWN FAR *)&amp;lpRootContainer); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if(ulObjType != MAPI_ABCONT) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get the hierarchy table of the root container <br>    hr = MAPICALL(((LPABCONT)lpRootContainer))-&gt;GetHierarchyTable( <br>        (LPABCONT)lpRootContainer, <br>        MAPI_DEFERRED_ERRORS|CONVENIENT_DEPTH, <br>        &amp;lpContainerTable); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Restrict the table to the global address list (GAL) <br>    // --------------------------------------------------- <br> <br>    // Initialize provider restriction to only Exchange providers <br> <br>    SRestrictAnd[0].rt                          = RES_PROPERTY; <br>    SRestrictAnd[0].res.resProperty.relop       = RELOP_EQ; <br>    SRestrictAnd[0].res.resProperty.ulPropTag   = PR_AB_PROVIDER_ID; <br>    SPropProvider.ulPropTag                     = PR_AB_PROVIDER_ID; <br> <br>    SPropProvider.Value.bin.cb                  = 16; <br>    SPropProvider.Value.bin.lpb                 = (LPBYTE)muid; <br>    SRestrictAnd[0].res.resProperty.lpProp      = &amp;SPropProvider; <br> <br>    // Initialize container ID restriction to only GAL container <br> <br>    SRestrictAnd[1].rt                          = RES_PROPERTY; <br>    SRestrictAnd[1].res.resProperty.relop       = RELOP_EQ; <br>    SRestrictAnd[1].res.resProperty.ulPropTag   = PR_EMS_AB_CONTAINERID; <br>    SPropID.ulPropTag                           = PR_EMS_AB_CONTAINERID; <br>    SPropID.Value.l                             = 0; <br>    SRestrictAnd[1].res.resProperty.lpProp      = &amp;SPropID; <br> <br>    // Initialize AND restriction  <br>     <br>    SRestrictGAL.rt                             = RES_AND; <br>    SRestrictGAL.res.resAnd.cRes                = 2; <br>    SRestrictGAL.res.resAnd.lpRes               = &amp;SRestrictAnd[0]; <br> <br>    // Restrict the table to the GAL - only a single row should remain <br> <br>    // Get the row corresponding to the GAL <br> <br>// <br>//  Query all the rows <br>// <br> <br>hr = HrQueryAllRows( <br>    lpContainerTable, <br>(LPSPropTagArray)&amp;rgPropTags, <br>&amp;SRestrictGAL, <br>NULL, <br>0, <br>&amp;lpRows); <br> <br>    if(FAILED(hr) || (lpRows == NULL) || (lpRows-&gt;cRows != 1)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get the entry ID for the GAL <br> <br>    lpCurrProp = &amp;(lpRows-&gt;aRow[0].lpProps[0]); <br> <br>    if(lpCurrProp-&gt;ulPropTag == PR_ENTRYID) <br>    { <br>        cbContainerEntryId = lpCurrProp-&gt;Value.bin.cb; <br>        lpContainerEntryId = (LPENTRYID)lpCurrProp-&gt;Value.bin.lpb; <br>    } <br>    else <br>    { <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br>        goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateBuffer(cbContainerEntryId, (LPVOID *)lppeid); <br> <br>    if(FAILED(hr)) <br>    { <br>        *lpcbeid = 0; <br>        *lppeid = NULL; <br>    } <br>    else <br>    { <br>        CopyMemory( <br>            *lppeid, <br>            lpContainerEntryId, <br>            cbContainerEntryId); <br> <br>        *lpcbeid = cbContainerEntryId; <br>    } <br> <br>cleanup: <br> <br>    ULRELEASE(lpRootContainer); <br>    ULRELEASE(lpContainerTable); <br>    ULRELEASE(lpContainer); <br> <br>    FREEPROWS(lpRows); <br>     <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(*lppeid); <br> <br>        *lpcbeid = 0; <br>        *lppeid = NULL; <br>    } <br>     <br>    RETURN(hr); <br>} <br> <br>//$--HrGWResolveAddress@------------------------------------------------------- <br>// Returns the entry ID for the recipient identified by a given address. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrGWResolveAddressW( <br>    IN LPABCONT lpGalABCont,        // pointer to GAL container <br>    IN LPCWSTR lpszAddress,         // pointer to proxy address <br>    OUT BOOL *lpfMapiRecip,         // MAPI recipient <br>    OUT ULONG *lpcbEntryID,         // count of bytes in entry ID <br>    OUT LPENTRYID *lppEntryID)      // pointer to entry ID <br>{ <br>    HRESULT     hr           = NOERROR; <br>    LPSTR       lpszAddressA = NULL; <br> <br>    DEBUGPUBLIC( "HrGWResolveAddressW()"); <br> <br>    hr = CHK_HrGWResolveAddressW( <br>        lpGalABCont, lpszAddress, lpfMapiRecip, <br>        lpcbEntryID, lppEntryID); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br>     <br>    // MAPI doesn't officially support resolution of UNICODE <br>    // addresses.  Therefore, the address is converted to ANSI... <br> <br>    hr = HrStrWToStrA( lpszAddress, &amp;lpszAddressA); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>     <br>    hr = HrGWResolveAddressA( <br>        lpGalABCont, lpszAddressA, lpfMapiRecip, <br>        lpcbEntryID, lppEntryID); <br> <br>cleanup: <br>    MAPIFREEBUFFER( lpszAddressA); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrGWResolveAddressA( <br>    IN LPABCONT lpGalABCont,        // pointer to GAL container <br>    IN LPCSTR lpszAddress,          // pointer to proxy address <br>    OUT BOOL *lpfMapiRecip,         // MAPI recipient <br>    OUT ULONG *lpcbEntryID,         // count of bytes in entry ID <br>    OUT LPENTRYID *lppEntryID)      // pointer to entry ID <br>{ <br>    HRESULT     hr          = NOERROR; <br>    HRESULT     hrT         = 0; <br>    SCODE       sc          = 0; <br>    LPADRLIST   lpAdrList   = NULL; <br>    LPFlagList  lpFlagList  = NULL; <br>    SPropValue  prop[2]     = {0}; <br>    ULONG       cbEntryID   = 0; <br>    LPENTRYID   lpEntryID   = NULL; <br> <br>    static const SizedSPropTagArray(2, rgPropTags) = <br>    { 2,  <br>        { <br>            PR_ENTRYID, <br>            PR_SEND_RICH_INFO <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrGWResolveAddressA()"); <br> <br>    hr = CHK_HrGWResolveAddressA( <br>        lpGalABCont, <br>        lpszAddress, <br>        lpfMapiRecip, <br>        lpcbEntryID, <br>        lppEntryID); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpfMapiRecip = FALSE; <br>    *lpcbEntryID  = 0; <br>    *lppEntryID   = NULL; <br> <br>    sc = MAPIAllocateBuffer( CbNewFlagList(1), (LPVOID*)&amp;lpFlagList); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    lpFlagList-&gt;cFlags    = 1; <br>    lpFlagList-&gt;ulFlag[0] = MAPI_UNRESOLVED; <br> <br>    hr = HrMAPICreateSizedAddressList(1, &amp;lpAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    prop[0].ulPropTag = PR_DISPLAY_NAME_A; <br>    prop[0].Value.lpszA = (LPSTR)lpszAddress; <br>    prop[1].ulPropTag = PR_RECIPIENT_TYPE; <br>    prop[1].Value.ul = MAPI_TO; <br> <br>    hr = HrMAPISetAddressList( <br>        0, <br>        2, <br>        prop, <br>        lpAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hrT = MAPICALL(lpGalABCont)-&gt;ResolveNames( <br>        lpGalABCont, <br>        (LPSPropTagArray)&amp;rgPropTags, <br>        EMS_AB_ADDRESS_LOOKUP, <br>        lpAdrList, <br>        lpFlagList); <br> <br>    if(lpFlagList-&gt;ulFlag[0] != MAPI_RESOLVED) <br>    { <br>        if(lpFlagList-&gt;ulFlag[0] == MAPI_AMBIGUOUS) <br>        { <br>            hrT = MAPI_E_AMBIGUOUS_RECIP; <br>        } <br>        else <br>        { <br>            hrT = MAPI_E_NOT_FOUND; <br>        } <br>    } <br> <br>    if(FAILED(hrT)) <br>    { <br>        if(hrT == MAPI_E_NOT_FOUND) <br>        { <br>            hr = HR_LOG(EDK_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        }; <br> <br>        goto cleanup; <br>    } <br> <br>    cbEntryID = lpAdrList-&gt;aEntries[0].rgPropVals[0].Value.bin.cb; <br>    lpEntryID = (LPENTRYID)lpAdrList-&gt;aEntries[0].rgPropVals[0].Value.bin.lpb; <br> <br>    sc = MAPIAllocateBuffer( cbEntryID, (LPVOID*)lppEntryID); <br> <br>    if(FAILED(sc)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    CopyMemory(*lppEntryID, lpEntryID, cbEntryID); <br>    *lpcbEntryID  = cbEntryID; <br>    *lpfMapiRecip = lpAdrList-&gt;aEntries[0].rgPropVals[1].Value.b; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpFlagList); <br> <br>    FREEPADRLIST(lpAdrList); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCheckForType@------------------------------------------------------------ <br>//  Check if the passed in string has the requested address type. If so, return <br>//  the address value, otherwise fail. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCheckForTypeW(  // RETURNS: return code <br>    IN  LPCWSTR lpszAddrType,    // pointer to address type <br>    IN  LPCWSTR lpszProxy,       // pointer to proxy address <br>    OUT LPWSTR * lppszAddress)   // pointer to address pointer <br>{ <br>    HRESULT hr              = EDK_E_NOT_FOUND; <br>    LPCWSTR lpszProxyAddr   = NULL; <br>    ULONG   cbAddress       = 0; <br>    SCODE   sc              = 0; <br>    ULONG   cchProxy        = 0; <br>    ULONG   cchProxyType    = 0; <br> <br>    DEBUGPRIVATE("HrCheckForTypeW()"); <br> <br>    hr = CHK_HrCheckForTypeW( <br>        lpszAddrType, <br>        lpszProxy, <br>        lppszAddress); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>// Initialize output parameter <br> <br>*lppszAddress = NULL; <br> <br>    // find the ':' separator. <br> <br>    cchProxy     = wcslen(lpszProxy); <br>    cchProxyType = wcscspn(lpszProxy, L":"); <br> <br>    if((cchProxyType == 0) || (cchProxyType &gt;= cchProxy)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = EDK_E_NOT_FOUND; <br> <br>    // does the address type match? <br>    if((cchProxyType == wcslen(lpszAddrType)) &amp;&amp; <br>       (_wcsnicmp(lpszProxy, lpszAddrType, cchProxyType) == 0)) <br>    {    <br>        // specified address type found     <br>        lpszProxyAddr = lpszProxy + cchProxyType + 1; <br> <br>        cbAddress = cbStrLenW(lpszProxyAddr); <br> <br>        // make a buffer to hold it. <br>        sc = MAPIAllocateBuffer(cbAddress, (void **)lppszAddress); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>        } <br>        else <br>        { <br>            CopyMemory(*lppszAddress, lpszProxyAddr, cbAddress); <br> <br>            hr = NOERROR; <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>static HRESULT HrCheckForTypeA( // RETURNS: return code <br>    IN  LPCSTR lpszAddrType,    // pointer to address type <br>    IN  LPCSTR lpszProxy,       // pointer to proxy address <br>    OUT LPSTR * lppszAddress)   // pointer to address pointer <br>{ <br>    HRESULT hr              = EDK_E_NOT_FOUND; <br>    LPCSTR  lpszProxyAddr   = NULL; <br>    ULONG   cbAddress       = 0; <br>    SCODE   sc              = 0; <br>    ULONG   cchProxy        = 0; <br>    ULONG   cchProxyType    = 0; <br> <br>    DEBUGPRIVATE("HrCheckForTypeA()"); <br> <br>    hr = CHK_HrCheckForTypeA( <br>        lpszAddrType, <br>        lpszProxy, <br>        lppszAddress); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>// Initialize output parameter <br> <br>*lppszAddress = NULL; <br> <br>    // find the ':' separator. <br> <br>    cchProxy     = lstrlenA(lpszProxy); <br>    cchProxyType = strcspn(lpszProxy, ":"); <br> <br>    if((cchProxyType == 0) || (cchProxyType &gt;= cchProxy)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = EDK_E_NOT_FOUND; <br> <br>    // does the address type match? <br>    if((cchProxyType == (ULONG)lstrlenA(lpszAddrType)) &amp;&amp; <br>       (_strnicmp(lpszProxy, lpszAddrType, cchProxyType) == 0)) <br>    {    <br>        // specified address type found     <br>        lpszProxyAddr = lpszProxy + cchProxyType + 1; <br> <br>        cbAddress = cbStrLenA(lpszProxyAddr); <br> <br>        // make a buffer to hold it. <br>        sc = MAPIAllocateBuffer(cbAddress, (void **)lppszAddress); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>        } <br>        else <br>        { <br>            CopyMemory(*lppszAddress, lpszProxyAddr, cbAddress); <br> <br>            hr = NOERROR; <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrGWResolveProxy@--------------------------------------------------------- <br>// Returns the address of a specified type for the recipient identified by <br>// a given entry ID. <br>// ----------------------------------------------------------------------------- <br>#define IADDRTYPE  0 <br>#define IEMAILADDR 1 <br>#define IMAPIRECIP 2 <br>#define IPROXYADDR 3 <br> <br>HRESULT HrGWResolveProxyW(         // RETURNS: return code <br>    IN  LPADRBOOK   lpAdrBook,      // pointer to address book <br>    IN  ULONG       cbeid,          // count of bytes in the entry ID <br>    IN  LPENTRYID   lpeid,          // pointer to the entry ID <br>    IN  LPCWSTR     lpszAddrType,   // pointer to the address type <br>    OUT BOOL *lpfMapiRecip,         // MAPI recipient <br>    OUT LPWSTR *    lppszAddress)   // pointer to the address pointer <br>{ <br>    HRESULT         hr              = EDK_E_NOT_FOUND; <br>    HRESULT         hrT             = 0; <br>    SCODE           sc              = 0; <br>    ULONG           i               = 0; <br>    ULONG           cbAddress       = 0; <br>    ULONG           cProxy          = 0; <br>    LPSPropValue    lpProps         = NULL; <br>    LPADRLIST       lpAdrList       = NULL; <br>    SPropValue      prop[2]         = {0}; <br> <br>    SizedSPropTagArray(4, rgPropTags) = <br>    { <br>        4,  <br>        { <br>            PR_ADDRTYPE_W, <br>            PR_EMAIL_ADDRESS_W, <br>            PR_SEND_RICH_INFO, <br>            PR_EMS_AB_PROXY_ADDRESSES_W <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrGWResolveProxyW()"); <br> <br>    hr = CHK_HrGWResolveProxyW( <br>        lpAdrBook, <br>        cbeid, <br>        lpeid, <br>        lpszAddrType, <br>        lpfMapiRecip, <br>        lppszAddress); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>// Initialize output parameters <br> <br>    *lpfMapiRecip = FALSE; <br>*lppszAddress = NULL; <br> <br>    hr = HrMAPICreateSizedAddressList(1, &amp;lpAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    prop[0].ulPropTag       = PR_ENTRYID; <br>    prop[0].Value.bin.cb    = cbeid; <br>    prop[0].Value.bin.lpb   = (LPBYTE)lpeid; <br>    prop[1].ulPropTag       = PR_RECIPIENT_TYPE; <br>    prop[1].Value.ul        = MAPI_TO; <br> <br>    hr = HrMAPISetAddressList( <br>        0, <br>        2, <br>        prop, <br>        lpAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hrT = MAPICALL(lpAdrBook)-&gt;PrepareRecips( lpAdrBook, <br>        0, <br>        (LPSPropTagArray)&amp;rgPropTags, <br>        lpAdrList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lpProps = lpAdrList-&gt;aEntries[0].rgPropVals; <br> <br>    // <br>    //  Hack:  detect the case where prepare recips doesn't work correctly. <br>    //      This happens when trying to look up a recipient that is in <br>    //      a replicated directory but not in the local directory. <br>    // <br>    if (lpAdrList-&gt;aEntries[0].cValues == 3) <br>    { <br>        MODULE_ERROR("PrepareRecips() failed but did not declare."); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // If the given address type matches the PR_ADDRTYPE value, <br>    // return the PR_EMAIL_ADDRESS value <br>     <br>    if((PROP_TYPE(lpProps[IADDRTYPE].ulPropTag) != PT_ERROR) &amp;&amp; <br>       (PROP_TYPE(lpProps[IEMAILADDR].ulPropTag) != PT_ERROR) &amp;&amp; <br>       (_wcsicmp(lpProps[IADDRTYPE].Value.lpszW, lpszAddrType) == 0)) <br>    { <br>        cbAddress = cbStrLenW(lpProps[IEMAILADDR].Value.lpszW); <br> <br>        sc = MAPIAllocateBuffer(cbAddress, (void **)lppszAddress); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>        } <br>        else <br>        { <br>            CopyMemory(*lppszAddress, lpProps[IEMAILADDR].Value.lpszW, cbAddress); <br>            hr = NOERROR; <br>        } <br> <br>        goto cleanup; <br>    } <br> <br>    // Search for a PR_EMS_AB_PROXY_ADDRESSES of the given type if present. <br> <br>    else if(PROP_TYPE(lpProps[IPROXYADDR].ulPropTag) != PT_ERROR) <br>    { <br>        // count of proxy addresses <br>        cProxy = lpAdrList-&gt;aEntries[0].rgPropVals[IPROXYADDR].Value.MVszW.cValues; <br> <br>        for(i = 0; i &lt; cProxy; i++) <br>        { <br>            hr = HrCheckForTypeW( <br>                lpszAddrType,  <br>                lpProps[IPROXYADDR].Value.MVszW.lppszW[i], <br>                lppszAddress); <br> <br>            if(hr == EDK_E_NOT_FOUND) <br>            { <br>                continue; <br>            } <br>            else if(FAILED(hr)) <br>            { <br>                goto cleanup; <br>            } <br>            else <br>            { <br>                // <br>                // Found a matching proxy address. <br>                // <br> <br>                goto cleanup; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br>        goto cleanup; <br>    }     <br> <br>cleanup: <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>        *lpfMapiRecip = lpAdrList-&gt;aEntries[0].rgPropVals[IMAPIRECIP].Value.b; <br>    } <br> <br>    FREEPADRLIST(lpAdrList); <br>     <br>    RETURN(hr); <br>} <br> <br>HRESULT HrGWResolveProxyA(         // RETURNS: return code <br>    IN  LPADRBOOK   lpAdrBook,      // pointer to address book <br>    IN  ULONG       cbeid,          // count of bytes in the entry ID <br>    IN  LPENTRYID   lpeid,          // pointer to the entry ID <br>    IN  LPCSTR      lpszAddrType,   // pointer to the address type <br>    OUT BOOL *lpfMapiRecip,         // MAPI recipient <br>    OUT LPSTR *     lppszAddress)   // pointer to the address pointer <br>{ <br>    HRESULT         hr              = EDK_E_NOT_FOUND; <br>    HRESULT         hrT             = 0; <br>    SCODE           sc              = 0; <br>    ULONG           i               = 0; <br>    ULONG           cbAddress       = 0; <br>    ULONG           cProxy          = 0; <br>    LPSPropValue    lpProps         = NULL; <br>    LPADRLIST       lpAdrList       = NULL; <br>    SPropValue      prop[2]         = {0}; <br> <br>    SizedSPropTagArray(4, rgPropTags) = <br>    { <br>        4,  <br>        { <br>            PR_ADDRTYPE_A, <br>            PR_EMAIL_ADDRESS_A, <br>            PR_SEND_RICH_INFO, <br>            PR_EMS_AB_PROXY_ADDRESSES_A <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrGWResolveProxyA()"); <br> <br>    hr = CHK_HrGWResolveProxyA( <br>        lpAdrBook, <br>        cbeid, <br>        lpeid, <br>        lpszAddrType, <br>        lpfMapiRecip, <br>        lppszAddress); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>// Initialize output parameters <br> <br>    *lpfMapiRecip = FALSE; <br>*lppszAddress = NULL; <br> <br>    hr = HrMAPICreateSizedAddressList(1, &amp;lpAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    prop[0].ulPropTag       = PR_ENTRYID; <br>    prop[0].Value.bin.cb    = cbeid; <br>    prop[0].Value.bin.lpb   = (LPBYTE)lpeid; <br>    prop[1].ulPropTag       = PR_RECIPIENT_TYPE; <br>    prop[1].Value.ul        = MAPI_TO; <br> <br>    hr = HrMAPISetAddressList( <br>        0, <br>        2, <br>        prop, <br>        lpAdrList); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hrT = MAPICALL(lpAdrBook)-&gt;PrepareRecips( lpAdrBook, <br>        0, <br>        (LPSPropTagArray)&amp;rgPropTags, <br>        lpAdrList); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lpProps = lpAdrList-&gt;aEntries[0].rgPropVals; <br> <br>    // <br>    //  Hack:  detect the case where prepare recips doesn't work correctly. <br>    //      This happens when trying to look up a recipient that is in <br>    //      a replicated directory but not in the local directory. <br>    // <br>    if (lpAdrList-&gt;aEntries[0].cValues == 3) <br>    { <br>        MODULE_ERROR("PrepareRecips() failed but did not declare."); <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // If the given address type matches the PR_ADDRTYPE value, <br>    // return the PR_EMAIL_ADDRESS value <br>     <br>    if((PROP_TYPE(lpProps[IADDRTYPE].ulPropTag) != PT_ERROR) &amp;&amp; <br>       (PROP_TYPE(lpProps[IEMAILADDR].ulPropTag) != PT_ERROR) &amp;&amp; <br>       (_strcmpi(lpProps[IADDRTYPE].Value.lpszA, lpszAddrType) == 0)) <br>    { <br>        cbAddress = cbStrLenA(lpProps[IEMAILADDR].Value.lpszA); <br> <br>        sc = MAPIAllocateBuffer(cbAddress, (void **)lppszAddress); <br> <br>        if(FAILED(sc)) <br>        { <br>            hr = HR_LOG(E_OUTOFMEMORY); <br>        } <br>        else <br>        { <br>            CopyMemory(*lppszAddress, lpProps[IEMAILADDR].Value.lpszW, cbAddress); <br>            hr = NOERROR; <br>        } <br> <br>        goto cleanup; <br>    } <br> <br>    // Search for a PR_EMS_AB_PROXY_ADDRESSES of the given type if present. <br> <br>    else if(PROP_TYPE(lpProps[IPROXYADDR].ulPropTag) != PT_ERROR) <br>    { <br>        // count of proxy addresses <br>        cProxy = lpAdrList-&gt;aEntries[0].rgPropVals[IPROXYADDR].Value.MVszA.cValues; <br> <br>        for(i = 0; i &lt; cProxy; i++) <br>        { <br>            hr = HrCheckForTypeA( <br>                lpszAddrType,  <br>                lpProps[IPROXYADDR].Value.MVszA.lppszA[i], <br>                lppszAddress); <br> <br>            if(hr == EDK_E_NOT_FOUND) <br>            { <br>                continue; <br>            } <br>            else if(FAILED(hr)) <br>            { <br>                goto cleanup; <br>            } <br>            else <br>            { <br>                // <br>                // Found a matching proxy address. <br>                // <br> <br>                goto cleanup; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br>        goto cleanup; <br>    }     <br> <br>cleanup: <br> <br>    if(SUCCEEDED(hr)) <br>    { <br>        *lpfMapiRecip = lpAdrList-&gt;aEntries[0].rgPropVals[IMAPIRECIP].Value.b; <br>    } <br> <br>    FREEPADRLIST(lpAdrList); <br>     <br>    RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
