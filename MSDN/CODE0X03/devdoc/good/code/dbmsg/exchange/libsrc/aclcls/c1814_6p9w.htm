<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACLCLS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1814"></a>ACLCLS.CPP</h2>
<pre><code>// --aclcls.cpp------------------------------------------------------------- <br>// <br>//  API entry points into the ACL Class Library (aclcls). <br>// <br>//  Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "srowlst.h" <br>#include "aclclsf.h" <br> <br>#include "aclcls.chk" <br> <br>// <br>// Functions <br>// <br> <br>// $--HrFolderACLsOpen----------------------------------------------------- <br>// <br>// DESCRIPTION:Get a ptr to an object which implements the IExchangeFolderACLs <br>//interface defined in aclcls.h. <br>// <br>// INPUT: <br>// <br>//  [lpSession]         -- Pointer to MAPI session. <br>//  [lpMDB]-- Ptr to message store containing folder. <br>//  [cbentryid]-- Number of bytes in folder's entry identifier. <br>//  [lpentryid]-- Folder's entry identifier. <br>// <br>// OUTPUT: <br>// <br>//  [lppFolderACLs]-- Ptr to object which supports interface; <br>//   NULL if none. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif not enough memory; <br>//E_NOINTERFACEif acl table does not exist on folder; <br>//              E_FAILotherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDAPI <br>HrFolderACLsOpen(// RETURNS: HRESULT <br>    IN      LPMAPISESSION       lpSession,      // MAPI session pointer <br>    INLPMDBlpMDB,// MAPI MDB store ptr <br>INULONGcbentryid,// # bytes in entry ID <br>INLPENTRYIDlpentryid,// entry ID ptr <br>OUTLPFOLDERACLS FAR *lppFolderACLs// IExchangeFolderACLs ptr ptr <br>) <br>{ <br>    HRESULThr =NOERROR; <br>    CFolderACLs FAR *pFolderACLs =NULL; <br> <br>    DEBUGPUBLIC("HrFolderACLsOpen().\n"); <br> <br>    hr = CHK_HrFolderACLsOpen(cbentryid, lpentryid, lppFolderACLs); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr);         <br> <br>    *lppFolderACLs = NULL; <br> <br>    // Initialize controlling class object. <br> <br>    pFolderACLs = new CFolderACLs(); <br> <br>if (pFolderACLs == NULL) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>// Open the folder in the controlling class object. <br> <br>hr = pFolderACLs-&gt;HrOpen(lpSession, lpMDB, cbentryid, lpentryid); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>    // Give the user access to the programmer interface (CIExchangeFolderACLs) <br>    // on the controlling CFolderACLs object.     <br> <br>    hr = pFolderACLs-&gt;QueryInterface(IID_IExchangeFolderACLs, <br> (LPVOID FAR *)lppFolderACLs); <br>    // Ref count now 2. <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    ASSERT_READ_PTR_OR_NULL(*lppFolderACLs, sizeof(LPFOLDERACLS), <br>                             "Bad lppFolderACLs."); <br> <br>cleanup: <br> <br>    // Release our copy of the CFolderACLs object.   <br> <br>    ULRELEASE(pFolderACLs);// Ref count now 1. <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
