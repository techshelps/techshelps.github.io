<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IFOLDER.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1835"></a>IFOLDER.C</h2>
<pre><code>// --ifolder.c------------------------------------------------------------------ <br>//  <br>//  Module containing MAPI utility functions for folders. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include "ifolder.chk" <br> <br>typedef struct { <br>    ULONG   cbRootFolderA; <br>    LPSTR   lpszRootFolderA; <br>    ULONG   cbRootFolderW; <br>    LPWSTR  lpszRootFolderW; <br>    ULONG   ulPropTag; <br>} ROOT_LOOKUP; <br> <br>#define RLENTRY(str,ul) {sizeof(str), str, sizeof(L##str), L##str, ul} <br> <br>static const ROOT_LOOKUP rgRootLookup[] = { <br>    RLENTRY( "@PR_IPM_SUBTREE_ENTRYID",              PR_IPM_SUBTREE_ENTRYID), <br>    RLENTRY( "@PR_IPM_OUTBOX_ENTRYID",               PR_IPM_OUTBOX_ENTRYID), <br>    RLENTRY( "@PR_IPM_WASTEBASKET_ENTRYID",          PR_IPM_WASTEBASKET_ENTRYID), <br>    RLENTRY( "@PR_IPM_SENTMAIL_ENTRYID",             PR_IPM_SENTMAIL_ENTRYID), <br>    RLENTRY( "@PR_IPM_PUBLIC_FOLDERS_ENTRYID",       PR_IPM_PUBLIC_FOLDERS_ENTRYID), <br>    RLENTRY( "@PR_IPM_FAVORITES_ENTRYID",            PR_IPM_FAVORITES_ENTRYID), <br>    RLENTRY( "@PR_NON_IPM_SUBTREE_ENTRYID",          PR_NON_IPM_SUBTREE_ENTRYID), <br>    RLENTRY( "@PR_GW_MTSIN_ENTRYID",                 PR_GW_MTSIN_ENTRYID), <br>    RLENTRY( "@PR_GW_MTSOUT_ENTRYID",                PR_GW_MTSOUT_ENTRYID), <br>    RLENTRY( "@PR_VIEWS_ENTRYID",                    PR_VIEWS_ENTRYID), <br>    RLENTRY( "@PR_DEFAULT_VIEW_ENTRYID",             PR_DEFAULT_VIEW_ENTRYID), <br>    RLENTRY( "@PR_COMMON_VIEWS_ENTRYID",             PR_COMMON_VIEWS_ENTRYID), <br>    RLENTRY( "@PR_FINDER_ENTRYID",                   PR_FINDER_ENTRYID), <br>    RLENTRY( "@PR_HEADER_FOLDER_ENTRYID",            PR_HEADER_FOLDER_ENTRYID), <br>    RLENTRY( "@PR_SCHEDULE_FOLDER_ENTRYID",          PR_SCHEDULE_FOLDER_ENTRYID), <br>    RLENTRY( "@PR_IPM_DAF_ENTRYID",                  PR_IPM_DAF_ENTRYID), <br>    RLENTRY( "@PR_EFORMS_REGISTRY_ENTRYID",          PR_EFORMS_REGISTRY_ENTRYID), <br>    RLENTRY( "@PR_SPLUS_FREE_BUSY_ENTRYID",          PR_SPLUS_FREE_BUSY_ENTRYID), <br>    RLENTRY( "@PR_OFFLINE_ADDRBOOK_ENTRYID",         PR_OFFLINE_ADDRBOOK_ENTRYID), <br>    RLENTRY( "@PR_EFORMS_FOR_LOCALE_ENTRYID",        PR_EFORMS_FOR_LOCALE_ENTRYID), <br>    RLENTRY( "@PR_FREE_BUSY_FOR_LOCAL_SITE_ENTRYID", PR_FREE_BUSY_FOR_LOCAL_SITE_ENTRYID), <br>    RLENTRY( "@PR_ADDRBOOK_FOR_LOCAL_SITE_ENTRYID",  PR_ADDRBOOK_FOR_LOCAL_SITE_ENTRYID), <br>}; <br> <br>static const ULONG ulRootLookupCount = ARRAY_CNT(rgRootLookup); <br> <br>//$--_HrLookupRootFolder@------------------------------------------------------ <br>//  Compare folder name to known root folder ENTRYID strings.  Return ENTRYID, <br>//  if matched. <br>// ----------------------------------------------------------------------------- <br>static HRESULT _HrLookupRootFolderW( <br>    IN  LPMDB lpMdb,                // pointer to open message store <br>    IN  LPCWSTR lpszRootFolder,     // root folder name only (no separators) <br>    OUT ULONG *lpcbeid,             // size of entryid <br>    OUT LPENTRYID *lppeid)          // pointer to entryid <br>{ <br>    HRESULT      hr           = NOERROR; <br> <br>    DEBUGPRIVATE( "HrMAPIFindRootFolderW()"); <br> <br>    hr = CHK_HrMAPIFindRootFolderW( lpMdb, lpszRootFolder, lpcbeid, lppeid); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    *lpcbeid = 0L; <br>    *lppeid  = NULL; <br> <br>    // Since there are no ENTRYID properties for "Inbox"... <br>    if( _wcsicmp( lpszRootFolder, L"@PR_IPM_INBOX_ENTRYID") == 0) <br>    { <br>        hr = MAPICALL( lpMdb)-&gt;GetReceiveFolder( lpMdb, <br>            NULL,       // default message class ("IPM") <br>            MAPI_UNICODE, <br>            lpcbeid, <br>            lppeid, <br>            NULL); <br>        if( FAILED( hr)) <br>        { <br>            if( hr == MAPI_E_NOT_FOUND) <br>                hr = HR_LOG( EDK_E_NOT_FOUND); <br>            else <br>                hr = HR_LOG( E_FAIL); <br> <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        ULONG cbRootFolder = 0L; <br>        ULONG i            = 0L; <br> <br>        // Calculate length of folder name to speed up search somewhat <br>        cbRootFolder = cbStrLenW( lpszRootFolder); <br> <br>        for( i = 0L; i &lt; ulRootLookupCount; i++) <br>        { <br>            if( cbRootFolder == rgRootLookup[i].cbRootFolderW &amp;&amp; <br>                _wcsicmp( rgRootLookup[i].lpszRootFolderW, lpszRootFolder) == 0 ) <br>            { <br>                SPropTagArray rgPropTag    = { 1, { rgRootLookup[i].ulPropTag}}; <br>                LPSPropValue  lpPropValue  = NULL; <br>                ULONG         cValues      = 0L; <br> <br>                // Get the outbox entry ID property.  <br>                hr = MAPICALL(lpMdb)-&gt;GetProps( lpMdb, <br>                    &amp;rgPropTag, <br>                    MAPI_UNICODE, <br>                    &amp;cValues, <br>                    &amp;lpPropValue); <br>                if( FAILED( hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>         <br>                if( hr == MAPI_W_ERRORS_RETURNED) <br>                { <br>                    if( lpPropValue &amp;&amp; lpPropValue-&gt;Value.ul == MAPI_E_NOT_FOUND) <br>                        hr = HR_LOG( MAPI_E_NOT_FOUND); <br>                    else <br>                        hr = HR_LOG( E_FAIL); <br> <br>                    goto cleanup; <br>                } <br>         <br>                ASSERTERROR(cValues != 0, "ZERO properties returned"); <br>                ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br>         <br>                // Check to make sure we got the right property. <br>                if (lpPropValue-&gt;ulPropTag == rgRootLookup[i].ulPropTag) <br>                { <br>                    *lpcbeid = lpPropValue-&gt;Value.bin.cb; <br>     <br>                    hr = MAPIAllocateBuffer( *lpcbeid, (PVOID*)lppeid); <br>                    if( SUCCEEDED( hr)) <br>                    { <br>                        CopyMemory( *lppeid, lpPropValue-&gt;Value.bin.lpb, *lpcbeid); <br>                    } <br>                    else <br>                    { <br>                        hr = HR_LOG( E_OUTOFMEMORY); <br>                    } <br>                } <br>                else <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                } <br> <br>                MAPIFREEBUFFER( lpPropValue); <br>                goto cleanup; <br>            } <br>        }  <br> <br>        // Not a recognized root folder <br>        hr = HR_LOG( EDK_E_NOT_FOUND); <br>    } <br> <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>static HRESULT _HrLookupRootFolderA( <br>    IN  LPMDB lpMdb,                // pointer to open message store <br>    IN  LPCSTR lpszRootFolder,      // root folder name only (no separators) <br>    OUT ULONG *lpcbeid,             // size of entryid <br>    OUT LPENTRYID *lppeid)          // pointer to entryid <br>{ <br>    HRESULT      hr           = NOERROR; <br> <br>    DEBUGPUBLIC( "HrMAPIFindRootFolderA()"); <br> <br>    hr = CHK_HrMAPIFindRootFolderA( lpMdb, lpszRootFolder, lpcbeid, lppeid); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    *lpcbeid = 0L; <br>    *lppeid  = NULL; <br> <br>    // Since there are no ENTRYID properties for "Inbox"... <br>    if( _strcmpi( lpszRootFolder, "@PR_IPM_INBOX_ENTRYID") == 0) <br>    { <br>        hr = MAPICALL( lpMdb)-&gt;GetReceiveFolder( lpMdb, <br>            NULL,       // default message class ("IPM") <br>            0L, <br>            lpcbeid, <br>            lppeid, <br>            NULL); <br>        if( FAILED( hr)) <br>        { <br>            if( hr == MAPI_E_NOT_FOUND) <br>                hr = HR_LOG( EDK_E_NOT_FOUND); <br>            else <br>                hr = HR_LOG( E_FAIL); <br> <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        ULONG cbRootFolder = 0L; <br>        ULONG i            = 0L; <br> <br>        // Calculate length of folder name to speed up search somewhat <br>        cbRootFolder = cbStrLenA( lpszRootFolder); <br> <br>        for( i = 0L; i &lt; ulRootLookupCount; i++) <br>        { <br>            if( cbRootFolder == rgRootLookup[i].cbRootFolderA &amp;&amp; <br>                _strcmpi( rgRootLookup[i].lpszRootFolderA, lpszRootFolder) == 0 ) <br>            { <br>                SPropTagArray rgPropTag    = { 1, { rgRootLookup[i].ulPropTag}}; <br>                LPSPropValue  lpPropValue  = NULL; <br>                ULONG         cValues      = 0L; <br> <br>                // Get the outbox entry ID property.  <br>                hr = MAPICALL(lpMdb)-&gt;GetProps( lpMdb, <br>                    &amp;rgPropTag, <br>                    0L, <br>                    &amp;cValues, <br>                    &amp;lpPropValue); <br>                if( FAILED( hr)) <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                    goto cleanup; <br>                } <br>         <br>                if( hr == MAPI_W_ERRORS_RETURNED) <br>                { <br>                    if( lpPropValue &amp;&amp; lpPropValue-&gt;Value.ul == MAPI_E_NOT_FOUND) <br>                        hr = HR_LOG( MAPI_E_NOT_FOUND); <br>                    else <br>                        hr = HR_LOG( E_FAIL); <br> <br>                    goto cleanup; <br>                } <br>         <br>                ASSERTERROR(cValues != 0, "ZERO properties returned"); <br>                ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br>         <br>                // Check to make sure we got the right property. <br>                if (lpPropValue-&gt;ulPropTag == rgRootLookup[i].ulPropTag) <br>                { <br>                    *lpcbeid = lpPropValue-&gt;Value.bin.cb; <br>     <br>                    hr = MAPIAllocateBuffer( *lpcbeid, (PVOID*)lppeid); <br>                    if( SUCCEEDED( hr)) <br>                    { <br>                        CopyMemory( *lppeid, lpPropValue-&gt;Value.bin.lpb, *lpcbeid); <br>                    } <br>                    else <br>                    { <br>                        hr = HR_LOG( E_OUTOFMEMORY); <br>                    } <br>                } <br>                else <br>                { <br>                    hr = HR_LOG(E_FAIL); <br>                } <br> <br>                MAPIFREEBUFFER( lpPropValue); <br>                goto cleanup; <br>            } <br>        }  <br> <br>        // Not a recognized root folder <br>        hr = HR_LOG( EDK_E_NOT_FOUND); <br>    } <br> <br>cleanup: <br>    RETURN( hr); <br>} <br> <br>//$--HrMAPIFindFolder@----------------------------------------------------- <br>//  Search folder for entry ID of child folder by name. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIFindFolderW(         // RETURNS: return code <br>    IN LPMAPIFOLDER lpFolder,           // pointer to folder <br>    IN LPCWSTR lpszName,                // name of folder to find <br>    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)              // pointer to entry ID pointer <br>{ <br>    HRESULThr           = NOERROR; <br>LPMAPITABLElpTable      = NULL; <br>LPSRowSetlpRow        = NULL; <br>    LPSPropValue    lpRowProp    = NULL; <br>    ULONG           i            = 0L; <br> <br>    static const enum { IDISPNAME, IENTRYID }; <br>    static const SizedSPropTagArray( 2, rgColProps) = { 2, { PR_DISPLAY_NAME_W, PR_ENTRYID}}; <br>     <br>DEBUGPUBLIC( "HrMAPIFindFolderW()"); <br> <br>    hr = CHK_HrMAPIFindFolderW( lpFolder, lpszName, lpcbeid, lppeid); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Avoid dereferencing a NULL in retail builds <br>    if( !lpcbeid || !lppeid) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lpcbeid = 0; <br>    *lppeid  = NULL; <br> <br>    if( !lpFolder) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>hr = MAPICALL( lpFolder)-&gt;GetHierarchyTable( lpFolder, <br>        MAPI_UNICODE | MAPI_DEFERRED_ERRORS, &amp;lpTable); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrQueryAllRows( lpTable, (LPSPropTagArray)&amp;rgColProps, NULL, NULL, 0L, &amp;lpRow); <br>if( FAILED( hr)) <br>    { <br>        if( hr == MAPI_E_NOT_FOUND) <br>            hr = HR_LOG( EDK_E_NOT_FOUND); <br>        else <br>            hr = HR_LOG( E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR( lpRow != NULL, "NULL lpRow returned from QueryRows!"); <br>     <br>    // Search rows for the folder in question <br>    for(i = 0; i &lt; lpRow-&gt;cRows; i++) <br>    { <br>        ASSERTERROR( <br>            lpRow-&gt;aRow[i].cValues &gt; 0, <br>            "Row is empty of properties."); <br> <br>        lpRowProp = lpRow-&gt;aRow[i].lpProps; <br> <br>        ASSERTERROR( <br>            lpRowProp[IENTRYID].ulPropTag == PR_ENTRYID, <br>            "Row does not contain entry id"); <br>        ASSERTERROR( <br>            lpRowProp[IDISPNAME].ulPropTag == PR_DISPLAY_NAME_A, <br>            "Row does not contain display name"); <br> <br>        if(_wcsicmp(lpRowProp[IDISPNAME].Value.lpszW, lpszName) == 0) <br>        { <br>            *lpcbeid = lpRowProp[IENTRYID].Value.bin.cb; <br> <br>            hr = MAPIAllocateBuffer(*lpcbeid, (PVOID*)lppeid); <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_OUTOFMEMORY); <br>                goto cleanup; <br>            } <br> <br>            // Copy entry ID <br>            CopyMemory( *lppeid, lpRowProp[IENTRYID].Value.bin.lpb, *lpcbeid); <br>            goto cleanup; <br>        } <br> <br>    }  // for <br> <br>    hr = HR_LOG( EDK_E_NOT_FOUND); <br> <br>cleanup: <br>FREEPROWS(lpRow); <br>ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrMAPIFindFolderA(         // RETURNS: return code <br>    IN LPMAPIFOLDER lpFolder,           // pointer to folder <br>    IN LPCSTR  lpszName,                // name of folder to find <br>    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)              // pointer to entry ID pointer <br>{ <br>    HRESULThr           = NOERROR; <br>LPMAPITABLElpTable      = NULL; <br>LPSRowSetlpRow        = NULL; <br>    LPSPropValue    lpRowProp    = NULL; <br>    ULONG           i            = 0L; <br> <br>    static const enum { IDISPNAME, IENTRYID }; <br>    static SizedSPropTagArray( 2, rgColProps) = { 2, { PR_DISPLAY_NAME_A, PR_ENTRYID}}; <br>     <br>DEBUGPUBLIC( "HrMAPIFindFolderA()"); <br> <br>    hr = CHK_HrMAPIFindFolderA( lpFolder, lpszName, lpcbeid, lppeid); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Avoid dereferencing a NULL in retail builds <br>    if( !lpcbeid || !lppeid) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lpcbeid = 0; <br>    *lppeid  = NULL; <br> <br>    if( !lpFolder) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>hr = MAPICALL( lpFolder)-&gt;GetHierarchyTable( lpFolder, <br>        MAPI_DEFERRED_ERRORS, &amp;lpTable); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrQueryAllRows( lpTable, (LPSPropTagArray)&amp;rgColProps, NULL, NULL, 0L, &amp;lpRow); <br>if( FAILED( hr)) <br>    { <br>        if( hr == MAPI_E_NOT_FOUND) <br>            hr = HR_LOG( EDK_E_NOT_FOUND); <br>        else <br>            hr = HR_LOG( E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR( lpRow != NULL, "NULL lpRow returned from QueryRows!"); <br>     <br>    // Search rows for the folder in question <br>    for(i = 0; i &lt; lpRow-&gt;cRows; i++) <br>    { <br>        ASSERTERROR( <br>            lpRow-&gt;aRow[i].cValues &gt; 0, <br>            "Row is empty of properties."); <br> <br>        lpRowProp = lpRow-&gt;aRow[i].lpProps; <br> <br>        ASSERTERROR( <br>            lpRowProp[IENTRYID].ulPropTag == PR_ENTRYID, <br>            "Row does not contain entry id"); <br>        ASSERTERROR( <br>            lpRowProp[IDISPNAME].ulPropTag == PR_DISPLAY_NAME_A, <br>            "Row does not contain display name"); <br> <br>        if(_strcmpi(lpRowProp[IDISPNAME].Value.lpszA, lpszName) == 0) <br>        { <br>            *lpcbeid = lpRowProp[IENTRYID].Value.bin.cb; <br> <br>            hr = MAPIAllocateBuffer(*lpcbeid, (PVOID*)lppeid); <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_OUTOFMEMORY); <br>                goto cleanup; <br>            } <br> <br>            // Copy entry ID <br>            CopyMemory( *lppeid, lpRowProp[IENTRYID].Value.bin.lpb, *lpcbeid); <br>            goto cleanup; <br>        } <br> <br>    }  // for <br> <br>    hr = HR_LOG( EDK_E_NOT_FOUND); <br> <br>cleanup: <br>FREEPROWS(lpRow); <br>ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIFindSubfolderEx@--------------------------------------------------------- <br>//  Finds an arbitrarily nested folder in the indicated folder given it's  <br>//  path name. <br>//------------------------------------------------------------------------------ <br>HRESULT HrMAPIFindSubfolderExW( <br>    IN LPMAPIFOLDER lpRootFolder,       // open root folder <br>    IN WCHAR chSep,                     // folder path separator character <br>    IN LPCWSTR lpszFolderPath,          // folder path <br>    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)              // pointer to entry ID pointer <br>{ <br>    HRESULT         hr              = NOERROR; <br>    LPMAPIFOLDER    lpParentFolder  = lpRootFolder; <br>    LPMAPIFOLDER    lpChildFolder   = NULL; <br>ULONG           cbeid           = 0L; <br>    LPENTRYID       lpeid           = NULL; <br>    LPWSTR         *lppszFolderList = NULL; <br>    WCHAR           rgchSep[2]      = L"\\"; <br>    ULONG           ulFolderCount   = 0L; <br>ULONGulObjType    = 0L; <br>    ULONG           i               = 0L; <br> <br>    DEBUGPUBLIC( "HrMAPIFindSubfolderExW()"); <br> <br>    hr = CHK_HrMAPIFindSubfolderExW( <br>        lpRootFolder, chSep, lpszFolderPath, lpcbeid, lppeid); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    if( !lpcbeid || !lppeid) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    // Set the user defined separator character <br>    rgchSep[0] = chSep; <br> <br>    hr = HrStrTokAllW( lpszFolderPath, rgchSep, &amp;ulFolderCount, &amp;lppszFolderList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    for(i = 0L; i &lt; ulFolderCount; i++) <br>    { <br>        // Free entryid before re-use. <br>        MAPIFREEBUFFER( lpeid); <br> <br>        hr = HrMAPIFindFolderW( lpParentFolder, lppszFolderList[i], &amp;cbeid, &amp;lpeid);  <br>        if( FAILED( hr)) <br>            goto cleanup; <br>         <br>        // Only OpenEntry if needed for next tier of folder path. <br>        if( lppszFolderList[i+1] != NULL) <br>        { <br>            hr = MAPICALL( lpParentFolder)-&gt;OpenEntry( lpParentFolder, <br>                cbeid, <br>                lpeid, <br>                NULL, <br>                MAPI_DEFERRED_ERRORS, <br>                &amp;ulObjType, <br>                (LPUNKNOWN*)&amp;lpChildFolder); <br>            if( FAILED( hr) || ulObjType != MAPI_FOLDER) <br>            { <br>                MAPIFREEBUFFER( lpeid); <br> <br>                hr = HR_LOG( E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br> <br>        // No longer need the parent folder <br>        // (Don't release the folder that was passed!) <br>        if( i &gt; 0L) <br>            ULRELEASE( lpParentFolder); <br>         <br>        lpParentFolder = lpChildFolder; <br>        lpChildFolder  = NULL; <br>    } <br> <br>    // Success! <br>    *lpcbeid = cbeid; <br>    *lppeid  = lpeid; <br> <br>cleanup: <br>    MAPIFREEBUFFER( lppszFolderList); <br> <br>    RETURN( hr); <br>} <br> <br>HRESULT HrMAPIFindSubfolderExA( <br>    IN LPMAPIFOLDER lpRootFolder,       // open root folder <br>    IN CHAR chSep,                      // folder path separator character <br>    IN LPCSTR lpszFolderPath,           // folder path <br>    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)              // pointer to entry ID pointer <br>{ <br>    HRESULT         hr              = NOERROR; <br>    LPMAPIFOLDER    lpParentFolder  = lpRootFolder; <br>    LPMAPIFOLDER    lpChildFolder   = NULL; <br>ULONG           cbeid           = 0L; <br>    LPENTRYID       lpeid           = NULL; <br>    LPSTR          *lppszFolderList = NULL; <br>    CHAR            rgchSep[2]      = "\\"; <br>    ULONG           ulFolderCount   = 0L; <br>ULONGulObjType    = 0L; <br>    ULONG           i               = 0L; <br> <br>    DEBUGPUBLIC( "HrMAPIFindSubfolderExA()"); <br> <br>    hr = CHK_HrMAPIFindSubfolderExA( <br>        lpRootFolder, chSep, lpszFolderPath, lpcbeid, lppeid); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    if( !lpcbeid || !lppeid) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    // Set the user defined separator character <br>    rgchSep[0] = chSep; <br> <br>    hr = HrStrTokAllA( lpszFolderPath, rgchSep, &amp;ulFolderCount, &amp;lppszFolderList); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    for(i = 0L; i &lt; ulFolderCount; i++) <br>    { <br>        // Free entryid before re-use. <br>        MAPIFREEBUFFER( lpeid); <br> <br>        hr = HrMAPIFindFolderA( lpParentFolder, lppszFolderList[i], &amp;cbeid, &amp;lpeid);  <br>        if( FAILED( hr)) <br>            goto cleanup; <br>         <br>        // Only OpenEntry if needed for next tier of folder path. <br>        if( lppszFolderList[i+1] != NULL) <br>        { <br>            hr = MAPICALL( lpParentFolder)-&gt;OpenEntry( lpParentFolder, <br>                cbeid, <br>                lpeid, <br>                NULL, <br>                MAPI_DEFERRED_ERRORS, <br>                &amp;ulObjType, <br>                (LPUNKNOWN*)&amp;lpChildFolder); <br>            if( FAILED( hr) || ulObjType != MAPI_FOLDER) <br>            { <br>                MAPIFREEBUFFER( lpeid); <br> <br>                hr = HR_LOG( E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br> <br>        // No longer need the parent folder <br>        // (Don't release the folder that was passed!) <br>        if( i &gt; 0L) <br>            ULRELEASE( lpParentFolder); <br>         <br>        lpParentFolder = lpChildFolder; <br>        lpChildFolder  = NULL; <br>    } <br> <br>    // Success! <br>    *lpcbeid = cbeid; <br>    *lppeid  = lpeid; <br> <br>cleanup: <br>    MAPIFREEBUFFER( lppszFolderList); <br> <br>    RETURN( hr); <br>} <br>     <br>//$--HrMAPIFindFolderEx@----------------------------------------------- <br>//  Finds an arbitrarily nested folder in the indicated store given it's  <br>//  path name. <br>//------------------------------------------------------------------------------ <br>HRESULT HrMAPIFindFolderExW( <br>    IN LPMDB lpMdb,                     // Open message store <br>    IN WCHAR  chSep,                    // folder path separator character <br>    IN LPCWSTR lpszFolderPath,          // folder path <br>    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)              // pointer to entry ID pointer <br>{ <br>    HRESULT      hr              = NOERROR; <br>    LPMAPIFOLDER lpRootFolder    = NULL; <br>    const WCHAR *cpPath          = lpszFolderPath; <br>    ULONG        cbeid           = 0L; <br>    LPENTRYID    lpeid           = NULL; <br> <br>    DEBUGPUBLIC("HrMAPIFindFolderExW()"); <br>             <br>    hr = CHK_HrMAPIFindFolderExW( <br>        lpMdb, chSep, lpszFolderPath, lpcbeid, lppeid); <br>    if( FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Avoid dereferencing a NULL in retail builds <br>    if( !lpcbeid || !lppeid) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lpcbeid = 0L; <br>    *lppeid  = NULL; <br> <br>    if( !lpMdb) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Move forward past any initial path separators <br>    while( *cpPath &amp;&amp; *cpPath == chSep) cpPath++; <br> <br>    // Check for literal property name <br>    if( *cpPath == L'@') <br>    { <br>        WCHAR  szRootFolder[MAX_PATH + 1] = {0}; <br>        WCHAR *cpFolder        = szRootFolder; <br> <br>        // Copy root folder to string buffer <br>        while( *cpPath &amp;&amp; *cpPath != chSep) *cpFolder++ = *cpPath++; <br>     <br>        *cpFolder = 0; <br>     <br>        hr = _HrLookupRootFolderW( lpMdb, szRootFolder, &amp;cbeid, &amp;lpeid); <br>        if( hr == EDK_E_NOT_FOUND) <br>        {   // Folder was unrecognized!  Try opening the REAL root folder, <br>            // and pass the FULL path to HrMAPIFindSubfolderEx(). <br>     <br>            cpPath = lpszFolderPath; <br>            cbeid  = 0L;      // force REAL root folder <br>            lpeid  = NULL; <br>        } <br>        else if( FAILED( hr)) <br>            goto cleanup; <br>        else <br>        {   // Folder found! If path continues, open the returned ENTRYID <br>            // and pass the REMAINING path to HrMAPIFindSubfolderEx(). <br>     <br>            // Skip past next separators, if necessary <br>            while( *cpPath &amp;&amp; *cpPath == chSep) cpPath++; <br>        } <br>    } <br> <br>    if( *cpPath) <br>    {   // The path continues! <br> <br>        ULONG ulObjType = 0; <br> <br>        hr = MAPICALL( lpMdb)-&gt;OpenEntry( lpMdb, <br>            cbeid, <br>            lpeid, <br>            NULL, <br>            MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>            &amp;ulObjType, <br>            (LPUNKNOWN*)&amp;lpRootFolder); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        if( ulObjType != MAPI_FOLDER) <br>        { <br>            hr = HR_LOG( E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Free before re-use <br>        MAPIFREEBUFFER( lpeid); <br> <br>        // Find the subfolder in question <br>        hr = HrMAPIFindSubfolderExW( <br>            lpRootFolder, chSep, cpPath, &amp;cbeid, &amp;lpeid); <br>        if(FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // Success! <br>    *lpcbeid = cbeid; <br>    *lppeid  = lpeid; <br> <br>cleanup: <br>    ULRELEASE(lpRootFolder); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrMAPIFindFolderExA( <br>    IN LPMDB lpMdb,                     // Open message store <br>    IN CHAR  chSep,                     // folder path separator character <br>    IN LPCSTR lpszFolderPath,           // folder path <br>    OUT ULONG *lpcbeid,                 // pointer to count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)              // pointer to entry ID pointer <br>{ <br>    HRESULT      hr              = NOERROR; <br>    LPMAPIFOLDER lpRootFolder    = NULL; <br>    const CHAR  *cpPath          = lpszFolderPath; <br>    ULONG        cbeid           = 0L; <br>    LPENTRYID    lpeid           = NULL; <br> <br>    DEBUGPUBLIC("HrMAPIFindFolderExA()"); <br>             <br>    hr = CHK_HrMAPIFindFolderExA( <br>        lpMdb, chSep, lpszFolderPath, lpcbeid, lppeid); <br>    if( FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Avoid dereferencing a NULL in retail builds <br>    if( !lpcbeid || !lppeid) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lpcbeid = 0L; <br>    *lppeid  = NULL; <br> <br>    if( !lpMdb) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Move forward past any initial path separators <br>    while( *cpPath &amp;&amp; *cpPath == chSep) cpPath++; <br> <br>    // Check for literal property name <br>    if( *cpPath == '@') <br>    { <br>        CHAR  szRootFolder[MAX_PATH + 1] = {0}; <br>        CHAR *cpFolder        = szRootFolder; <br>     <br>        // Copy root folder to string buffer <br>        while( *cpPath &amp;&amp; *cpPath != chSep) *cpFolder++ = *cpPath++; <br>     <br>        *cpFolder = 0; <br>     <br>        hr = _HrLookupRootFolderA( lpMdb, szRootFolder, &amp;cbeid, &amp;lpeid); <br>        if( hr == EDK_E_NOT_FOUND) <br>        {   // Folder was unrecognized!  Try opening the REAL root folder, <br>            // and pass the FULL path to HrMAPIFindSubfolderEx(). <br>     <br>            cpPath = lpszFolderPath; <br>            cbeid  = 0L;      // force REAL root folder <br>            lpeid  = NULL; <br>        } <br>        else if( FAILED( hr)) <br>            goto cleanup; <br>        else <br>        {   // Folder found! If path continues, open the returned ENTRYID <br>            // and pass the REMAINING path to HrMAPIFindSubfolderEx(). <br>     <br>            // Skip past next separators, if necessary <br>            while( *cpPath &amp;&amp; *cpPath == chSep) cpPath++; <br>        } <br>    } <br>     <br>    if( *cpPath) <br>    {   // The path continues! <br> <br>        ULONG ulObjType = 0; <br> <br>        hr = MAPICALL( lpMdb)-&gt;OpenEntry( lpMdb, <br>            cbeid, <br>            lpeid, <br>            NULL, <br>            MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>            &amp;ulObjType, <br>            (LPUNKNOWN*)&amp;lpRootFolder); <br>        if( FAILED( hr)) <br>            goto cleanup; <br> <br>        if( ulObjType != MAPI_FOLDER) <br>        { <br>            hr = HR_LOG( E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        // Free before re-use <br>        MAPIFREEBUFFER( lpeid); <br> <br>        // Find the subfolder in question <br>        hr = HrMAPIFindSubfolderExA( <br>            lpRootFolder, chSep, cpPath, &amp;cbeid, &amp;lpeid); <br>        if(FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // Success! <br>    *lpcbeid = cbeid; <br>    *lppeid  = lpeid; <br> <br>cleanup: <br>    ULRELEASE(lpRootFolder); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIOpenFolderEx@----------------------------------------------- <br>//  Opens an arbitrarily nested folder in the indicated store given it's  <br>//  path name. <br>//------------------------------------------------------------------------------ <br>HRESULT HrMAPIOpenFolderExW( <br>    IN LPMDB lpMdb,                     // Open message store <br>    IN WCHAR chSep,                     // folder path separator character <br>    IN LPCWSTR lpszFolderPath,          // folder path <br>    OUT LPMAPIFOLDER * lppFolder)       // pointer to folder opened <br>{ <br>    HRESULT   hr        = NOERROR; <br>    LPENTRYID lpeid     = NULL; <br>    ULONG     cbeid     = 0; <br>    ULONG     ulObjType = 0; <br> <br>    DEBUGPUBLIC( "HrMAPIOpenFolderExW()"); <br>             <br>    hr = CHK_HrMAPIOpenFolderExW( <br>        lpMdb, chSep, lpszFolderPath, lppFolder); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if( !lppFolder) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lppFolder = NULL; <br> <br>    hr = HrMAPIFindFolderExW( <br>        lpMdb, chSep, lpszFolderPath, <br>        &amp;cbeid, &amp;lpeid); <br>    if(FAILED(hr)) <br>        goto cleanup; <br> <br>    hr = MAPICALL( lpMdb)-&gt;OpenEntry( lpMdb, <br>        cbeid, <br>        lpeid, <br>        NULL, </code></pre>
<p>
</p>
<pre><code>MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN*)lppFolder); <br>    if( FAILED( hr) || ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR( *lppFolder, "INVALID *lppFolder pointer"); <br> <br>cleanup: <br>    MAPIFREEBUFFER(lpeid); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrMAPIOpenFolderExA( <br>    IN LPMDB lpMdb,                     // Open message store <br>    IN CHAR chSep,                      // folder path separator character <br>    IN LPCSTR lpszFolderPath,           // folder path <br>    OUT LPMAPIFOLDER * lppFolder)       // pointer to folder opened <br>{ <br>    HRESULT   hr        = NOERROR; <br>    LPENTRYID lpeid     = NULL; <br>    ULONG     cbeid     = 0; <br>    ULONG     ulObjType = 0; <br> <br>    DEBUGPUBLIC( "HrMAPIOpenFolderExA()"); <br>             <br>    hr = CHK_HrMAPIOpenFolderExA( <br>        lpMdb, chSep, lpszFolderPath, lppFolder); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if( !lppFolder) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lppFolder = NULL; <br> <br>    hr = HrMAPIFindFolderExA( <br>        lpMdb, chSep, lpszFolderPath, <br>        &amp;cbeid, &amp;lpeid); <br>    if(FAILED(hr)) <br>        goto cleanup; <br> <br>    hr = MAPICALL(lpMdb)-&gt;OpenEntry( lpMdb, <br>        cbeid, <br>        lpeid, <br>        NULL, <br>        MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN*)lppFolder); <br>    if( FAILED( hr) || ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(*lppFolder, "INVALID *lppFolder pointer"); <br> <br>cleanup: <br>    MAPIFREEBUFFER(lpeid); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIOpenSubfolderEx@--------------------------------------------------- <br>//  Opens an aribtrarily nested folder in the indicated folder given <br>//  its path name.  <br>//------------------------------------------------------------------------ <br>HRESULT HrMAPIOpenSubfolderExW( <br>    IN LPMAPIFOLDER lpRootFolder,       // open root folder <br>    IN WCHAR chSep,                     // character used as path separator <br>    IN LPCWSTR lpszFolderPath,          // folder path <br>    OUT LPMAPIFOLDER *lppFolder)        // pointer to open child folder <br>{ <br>    HRESULT   hr        = NOERROR; <br>    LPENTRYID lpeid     = NULL; <br>    ULONG     cbeid     = 0; <br>    ULONG     ulObjType = 0; <br> <br>    DEBUGPUBLIC( "HrMAPIOpenSubfolderExW()"); <br>             <br>    hr = CHK_HrMAPIOpenSubfolderExW( <br>        lpRootFolder, chSep, lpszFolderPath, lppFolder); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if( !lppFolder) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lppFolder = NULL; <br> <br>    hr = HrMAPIFindSubfolderExW( <br>        lpRootFolder, chSep, lpszFolderPath, <br>        &amp;cbeid, &amp;lpeid); <br>    if(FAILED(hr)) <br>        goto cleanup; <br> <br>    hr = MAPICALL( lpRootFolder)-&gt;OpenEntry( lpRootFolder, <br>        cbeid, <br>        lpeid, <br>        NULL, <br>        MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN*)lppFolder); <br>    if( FAILED( hr) || ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR( *lppFolder, "INVALID Folder!"); <br> <br>cleanup: <br>    MAPIFREEBUFFER(lpeid); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrMAPIOpenSubfolderExA( <br>    IN LPMAPIFOLDER lpRootFolder,       // open root folder <br>    IN CHAR chSep,                      // character used as path separator <br>    IN LPCSTR lpszFolderPath,           // folder path <br>    OUT LPMAPIFOLDER *lppFolder)        // pointer to open child folder <br>{ <br>    HRESULT   hr        = NOERROR; <br>    LPENTRYID lpeid     = NULL; <br>    ULONG     cbeid     = 0; <br>    ULONG     ulObjType = 0; <br> <br>    DEBUGPUBLIC( "HrMAPIOpenSubfolderExA()"); <br>             <br>    hr = CHK_HrMAPIOpenSubfolderExA( <br>        lpRootFolder, chSep, lpszFolderPath, lppFolder); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    if( !lppFolder) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    *lppFolder = NULL; <br> <br>    hr = HrMAPIFindSubfolderExA( <br>        lpRootFolder, chSep, lpszFolderPath, <br>        &amp;cbeid, &amp;lpeid); <br>    if(FAILED(hr)) <br>        goto cleanup; <br> <br>    hr = MAPICALL( lpRootFolder)-&gt;OpenEntry( lpRootFolder, <br>        cbeid, <br>        lpeid, <br>        NULL, <br>        MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN*)lppFolder); <br>    if( FAILED( hr) || ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR( *lppFolder, "INVALID Folder!"); <br> <br>cleanup: <br>    MAPIFREEBUFFER(lpeid); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrOpenExchangePublicFolders----------------------------------------------- <br>//  Opens the root of the public folder heirarchy. <br>//------------------------------------------------------------------------ <br>HRESULT HrOpenExchangePublicFolders( <br>    IN LPMDB lpPubStore,                // pointer to public message store <br>    OUT LPMAPIFOLDER *lppRootFolder)    // return ptr to public folder root <br>{ <br>    HRESULT       hr           = NOERROR; <br>    ULONG         cValues      = 0L; <br>    LPSPropValue  lpPropValue  = NULL; <br>    SPropTagArray rgPropTag    = { 1, { PR_IPM_PUBLIC_FOLDERS_ENTRYID } }; <br>    ULONG         ulObjType    = 0L; <br>    LPMAPIFOLDER  lpRootFolder = NULL; <br>     <br>    DEBUGPUBLIC( "HrOpenExchangePublicFolders()"); <br> <br>    hr = CHK_HrOpenExchangePublicFolders( lpPubStore, lppRootFolder); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Avoid dereferencing a NULL in retail builds <br>    if( !lpPubStore) <br>    { <br>        hr = HR_LOG( E_INVALIDARG); <br>        goto cleanup; <br>    } <br> <br>    // Get the outbox entry ID property.  <br>    hr = MAPICALL(lpPubStore)-&gt;GetProps( lpPubStore, <br>        &amp;rgPropTag, <br>        fMapiUnicode, <br>        &amp;cValues, <br>        &amp;lpPropValue); <br>    if( FAILED( hr)) <br>    { <br>        lpPropValue = NULL; <br> <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if( hr == MAPI_W_ERRORS_RETURNED) <br>    { <br>        if((lpPropValue != NULL) &amp;&amp; (lpPropValue-&gt;Value.ul == MAPI_E_NOT_FOUND)) <br>        { <br>            hr = HR_LOG(MAPI_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(cValues != 0, "ZERO cValues variable"); <br> <br>    ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br> <br>    // Check to make sure we got the right property. <br>    if (lpPropValue-&gt;ulPropTag != PR_IPM_PUBLIC_FOLDERS_ENTRYID) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = MAPICALL( lpPubStore)-&gt;OpenEntry( lpPubStore, <br>        lpPropValue-&gt;Value.bin.cb, <br>        (LPENTRYID)lpPropValue-&gt;Value.bin.lpb, <br>        NULL, <br>        MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS, <br>        &amp;ulObjType, <br>        (LPUNKNOWN*)&amp;lpRootFolder); <br>    if( FAILED( hr) || ulObjType != MAPI_FOLDER) <br>        goto cleanup; <br> <br>    *lppRootFolder = lpRootFolder; <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropValue); <br> <br>    RETURN(hr); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
