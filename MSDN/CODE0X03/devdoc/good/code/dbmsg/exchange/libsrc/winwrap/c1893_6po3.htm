<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINWRAP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1893"></a>WINWRAP.C</h2>
<pre><code>// --winwrap.c------------------------------------------------------------------ <br>//  <br>//  Windows NT service (Windows application) shell for EDK applications. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include &lt;stdlib.h&gt; <br> <br>static struct _tparam <br>{ <br>    LPLONG                 lplStartThreads; <br>    LPLONG                 lplStopThreads; <br>    LPTHREAD_START_ROUTINE lpStartAddress; <br>    LPVOID                 lpParameter; <br>}; <br> <br>#include "winwrap.chk" <br> <br>#define DEFAULT_WAIT_HINT   30000 <br> <br>#define SERVICE_NAME        "WINWRAP" <br> <br>#define WAIT_DESTROY        120000 <br> <br> <br>LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); <br> <br>static BOOL                    fIsService                = TRUE; <br> <br>static DWORD                   dwStartWaitHint           = DEFAULT_WAIT_HINT; <br>static DWORD                   dwStartCheckPoint         = 0; <br> <br>static DWORD                   dwPauseWaitHint           = DEFAULT_WAIT_HINT; <br>static DWORD                   dwPauseCheckPoint         = 0; <br> <br>static DWORD                   dwContinueWaitHint        = DEFAULT_WAIT_HINT; <br>static DWORD                   dwContinueCheckPoint      = 0; <br> <br>static DWORD                   dwStopWaitHint            = DEFAULT_WAIT_HINT; <br>static DWORD                   dwStopCheckPoint          = 0; <br> <br>static HINSTANCE               hInst                     = NULL; <br> <br>static HANDLE                  hServiceStopEvent         = NULL; <br>static HANDLE                  hServicePauseEvent        = NULL; <br>static HANDLE                  hServiceContinueEvent     = NULL; <br> <br>static HANDLE                  hStopConfirmEvent         = NULL; <br> <br>static SERVICE_STATUS          ssStatus                  = {0}; <br> <br>static SERVICE_STATUS_HANDLE   sshStatusHandle           = 0; <br> <br>static HWND                    hAppWnd                   = NULL; <br> <br>static DWORD                   dwWorkerTID               = 0; <br>static HANDLE                  hWorkerThread             = NULL; <br> <br>static DWORD                   dwShutdownTID             = 0; <br>static HANDLE                  hShutdownThread           = NULL; <br> <br>static DWORD                   dwServiceTID              = 0; <br>static HANDLE                  hServiceThread            = NULL; <br> <br>// ----------------------------------------------------------------------------- <br> <br>static DWORD                   dwServiceArgc             = 0; <br>static LPSTR                  *lpszServiceArgv          = NULL; <br> <br>static CHAR                   szServiceName[MAX_SERVICE_NAME_LENGTH+1] = {0}; <br> <br>static DWORD                   dwSvcWin32ExitCode           = 0; <br>static DWORD                   dwSvcServiceSpecificExitCode = 0; <br> <br>static struct _WinMainContext <br>{ <br>    HINSTANCE   hInstance; <br>    HINSTANCE   hPrevInstance; <br>    LPSTR       lpszCmdLine; <br>    int         nCmdShow; <br>}   WinMainContext; <br> <br>//$--FIsService----------------------------------------------------------------- <br>//  Returns TRUE if the application is running as an NT service. <br>// ----------------------------------------------------------------------------- <br>BOOL FIsService(                        // RETURNS: TRUE if service <br>    VOID)                               // no arguments <br>{ <br>    return(fIsService); <br>} <br> <br>//$--GetServiceStopEvent------------------------------------------------------- <br>//  Returns the handle for the service stop event. <br>// ----------------------------------------------------------------------------- <br>HANDLE GetServiceStopEvent(            // RETURNS: handle to stop event <br>    VOID)                               // no arguments <br>{ <br>    return(hServiceStopEvent); <br>} <br> <br>//$--GetServiceInstance-------------------------------------------------------- <br>//  Returns the handle for the service instance. <br>// ----------------------------------------------------------------------------- <br>HANDLE GetServiceInstance(             // RETURNS: handle to service instance <br>    VOID)                               // no arguments <br>{ <br>    return(hInst); <br>} <br> <br>//$--FnCreateThread------------------------------------------------------------- <br>//  Wrapper for CreateThread() function. <br>// ----------------------------------------------------------------------------- <br>static VOID FnCreateThread(             // RETURNS: nothing <br>    IN LPVOID lpParameter)              // parameter <br>{ <br>    HRESULT hr      = NOERROR; <br>    HGLOBAL hglobal = NULL; <br> <br>    struct _tparam *lpContext = NULL; <br> <br>    DEBUGPRIVATE("FnCreateThread()\n"); <br> <br>    hr = CHK_HrFnCreateThread( <br>        lpParameter); <br> <br>    if(FAILED(hr)) <br>        return; <br> <br>    lpContext = (struct _tparam *)lpParameter; <br> <br>    InterlockedIncrement(lpContext-&gt;lplStartThreads); <br> <br>    __try <br>    { <br>        (*(lpContext-&gt;lpStartAddress))(lpContext-&gt;lpParameter); <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    InterlockedIncrement(lpContext-&gt;lplStopThreads); <br> <br>    __try <br>    { <br>        hglobal = GlobalFree(lpContext); <br> <br>        if(hglobal != NULL) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br>    __except(EXCEPTION_EXECUTE_HANDLER) <br>    { <br>        SetLastError(_exception_code()); <br> <br>        hr = HR_LOG(E_FAIL); <br>    } <br>} <br> <br>//$--HServiceCreateThread----------------------------------------------------------- <br>//  Create a wrapped thread. <br>// ----------------------------------------------------------------------------- <br>HANDLE HServiceCreateThread(                            // RETURNS: handle <br>    IN  LPLONG lplStartThreads,                     // number of running threads <br>    IN  LPLONG lplStopThreads,                      // number of stopped threads <br>    IN  LPSECURITY_ATTRIBUTES lpThreadAttributes,   // thread attributes <br>    IN  DWORD dwStackSize,                          // stack size <br>    IN  LPTHREAD_START_ROUTINE lpStartAddress,      // start address <br>    IN  LPVOID lpParameter,                         // parameter <br>    IN  DWORD dwCreationFlags,                      // creation flags <br>    OUT LPDWORD lpThreadId)                         // thread ID <br>{ <br>    HRESULT        hr         = NOERROR; <br>    HGLOBAL        hglobal    = NULL; <br>    HANDLE         handle     = NULL; <br>    struct _tparam *lpContext = NULL; <br> <br>    DEBUGPUBLIC("HServiceCreateThread()\n"); <br> <br>    SetLastError(ERROR_SUCCESS); <br> <br>    hr = CHK_HrEDKCreateThread( <br>        lplStartThreads, <br>        lplStopThreads, <br>        lpThreadAttributes, <br>        dwStackSize, <br>        lpStartAddress, <br>        lpParameter, <br>        dwCreationFlags, <br>        lpThreadId); <br> <br>    if(FAILED(hr)) <br>        return(NULL); <br> <br>    lpContext = (struct _tparam *)GlobalAlloc(GPTR, sizeof(struct _tparam)); <br> <br>    if(lpContext == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        SetLastError(ERROR_NOT_ENOUGH_MEMORY); <br>        goto cleanup; <br>    } <br> <br>    lpContext-&gt;lplStartThreads = lplStartThreads; <br>    lpContext-&gt;lplStopThreads  = lplStopThreads; <br>    lpContext-&gt;lpStartAddress  = lpStartAddress; <br>    lpContext-&gt;lpParameter     = lpParameter; <br> <br>    handle = CreateThread( <br>        lpThreadAttributes, <br>        dwStackSize, <br>        (LPTHREAD_START_ROUTINE)FnCreateThread, <br>        (LPVOID)lpContext, <br>        dwCreationFlags, <br>        lpThreadId); <br> <br>cleanup: <br> <br>    if((handle == NULL) &amp;&amp; (lpContext != NULL)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        __try <br>        { <br>            hglobal = GlobalFree(lpContext); <br> <br>            if(hglobal != NULL) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>        } <br>        __except(EXCEPTION_EXECUTE_HANDLER) <br>        { <br>            SetLastError(_exception_code()); <br> <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    return(handle); <br>} <br> <br>//$--HrServiceGetName-------------------------------------------------------- <br>//  The HrServiceGetName function can be used by any thread to get the <br>//  service name after the service has been started. lpszName must point to a <br>//  block of memory at least MAX_SERVICE_NAME_LENGTH+1 bytes in length. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrServiceGetName(            // RETURNS: return code <br>    OUT LPSTR lpszName)                // pointer to service name buffer <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrServiceGetName()\n"); <br> <br>    hr = CHK_HrServiceGetName( <br>        lpszName); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    lstrcpyn(lpszName, szServiceName, MAX_SERVICE_NAME_LENGTH+1); <br> <br>    lpszName[MAX_SERVICE_NAME_LENGTH] = 0; <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrServiceGetArgv-------------------------------------------------------- <br>//  The HrServiceGetArgv function can be used by any thread to get the <br>//  service argv[] after the service has been started. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrServiceGetArgv(            // RETURNS: return code <br>    OUT DWORD  *lpdwArgc,               // pointer to argc address variable <br>    OUT LPSTR **lppszArgv)             // pointer to argv[] address variable <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrServiceGetArgv()\n"); <br> <br>    hr = CHK_HrServiceGetArgv( <br>        lpdwArgc, <br>        lppszArgv); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppszArgv = lpszServiceArgv; <br>    *lpdwArgc  = dwServiceArgc; <br> <br>    RETURN(hr); <br>} <br> <br>//$--WaitShutdown--------------------------------------------------------------- <br>//  Thread that will send WM_DESTROY once hShutdownEvent is signalled. <br>//------------------------------------------------------------------------------ <br>void WaitShutdown(                  // RETURNS: nothing <br>    IN HANDLE hShutdownEvent)       // Handle to Shutdown event object <br>{ <br>    HRESULT hr = NOERROR; <br>    DWORD   dw = 0; <br> <br>    DEBUGPUBLIC("WaitShutdown()\n"); <br> <br>    hr = CHK_HrWaitShutdown( <br>        hShutdownEvent); <br> <br>    if(FAILED(hr)) <br>        return; <br> <br>    if(hAppWnd == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        return; <br>    } <br> <br>    dw = WaitForSingleObject(hShutdownEvent, INFINITE); <br> <br>    if((dw != WAIT_OBJECT_0) &amp;&amp; (dw != WAIT_ABANDONED)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    if(hAppWnd != NULL) <br>    { <br>        PostMessage(hAppWnd, WM_DESTROY, 0, 0); <br>    } <br> <br>    ExitThread(0); <br> <br>    return; <br>} <br> <br>//$--fInitApplication----------------------------------------------------------- <br>//  Initializes window data and registers window class <br>// ----------------------------------------------------------------------------- <br>BOOL fInitApplication(              // RETURNS: TRUE if successful <br>    IN HINSTANCE hInstance)         // Handle to instance of application <br>{ <br>    WNDCLASS wc = {0}; <br> <br>    DEBUGPUBLIC("fInitApplication()\n"); <br> <br>    // Fill in window class structure with parameters that describe the <br>    // main window. <br> <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; // Class style(s). <br>    wc.lpfnWndProc   = (WNDPROC)WndProc;        // Window Procedure <br>    wc.cbClsExtra    = 0;                       // No per-class extra data. <br>    wc.cbWndExtra    = 0;                       // No per-window extra data. <br>    wc.hInstance     = hInstance;               // Owner of this class <br>    wc.hIcon         = LoadIcon(hInstance, IDI_APPLICATION);   // Icon <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);            // Cursor <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);// Default color <br>    wc.lpszMenuName  = NULL;                    // Menu name <br>    wc.lpszClassName = szAppName;               // Name to register as <br> <br>    if(wc.hIcon == NULL) <br>    { <br>        wc.hIcon     = LoadIcon(NULL, IDI_APPLICATION);        // Icon <br>    } <br> <br>    // Register the window class and return success/failure code. <br> <br>    return(RegisterClass(&amp;wc)); <br>} <br> <br>//$--fInitInstance-------------------------------------------------------------- <br>//  Saves instance handle and creates main window <br>// ----------------------------------------------------------------------------- <br>BOOL fInitInstance(                 // RETURNS: TRUE if successful <br>    IN HINSTANCE hInstance,         // handle to instance of application <br>    IN int       nCmdShow)          // argument for ShowWindow() <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("fInitInstance()\n"); <br> <br>    // Save the instance handle in static variable, which will be used in <br>    // many subsequence calls from this application to Windows. <br> <br>    hInst = hInstance; // Store instance handle in our global variable <br> <br>    // Create a main window for this application instance. <br> <br>    hAppWnd = CreateWindow( <br>        szAppName,                  // See RegisterClass() call. <br>        szWindowTitle,              // Text for window title bar. <br>        WS_MINIMIZE | <br>        WS_POPUP | <br>        WS_SYSMENU | <br>        WS_VISIBLE,                 // Window style. <br>        CW_USEDEFAULT, 0,           // Use default positioning <br>        CW_USEDEFAULT, 0,           // Use default positioning <br>        NULL,                       // Overlapped windows have no parent. <br>        NULL,                       // Use the window class menu. <br>        hInstance,                  // This instance owns this window. <br>        NULL                        // We don't use any data in our WM_CREATE <br>    ); <br> <br>    // <br>    // If window could not be created, return "failure" <br>    // <br> <br>    if(hAppWnd == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        return(FALSE); <br>    } <br> <br>    if(fIsService == FALSE) <br>    { <br>        // <br>        // Make the window visible; update its client area; and return "success" <br>        // <br> <br>        ShowWindow(hAppWnd, nCmdShow);  // Show the window <br>        UpdateWindow(hAppWnd);          // Sends WM_PAINT message <br>    } <br> <br>    return(TRUE); <br>} <br> <br>//$--WorkerThread--------------------------------------------------------------- <br>//  This function does the actual nuts and bolts work that <br>//  the service requires.  It will also Pause or Stop when <br>//  asked by the ServiceCtrlProc function. <br>// ----------------------------------------------------------------------------- <br>VOID WorkerThread(                  // RETURNS: nothing <br>    IN HANDLE hShutdownEvent)       // service shutdown event handle <br>{ <br>    HRESULT   hr            = NOERROR; <br>    HINSTANCE hInstance     = NULL; <br>    HINSTANCE hPrevInstance = NULL; <br>    LPSTR     lpszCmdLine   = NULL; <br>    int       nCmdShow      = 0; <br>    MSG       msg           = {0}; <br>    BOOL      fT            = FALSE; <br> <br>    DEBUGPUBLIC("WorkerThread()\n"); <br> <br>    hInstance     = WinMainContext.hInstance; <br>    hPrevInstance = WinMainContext.hPrevInstance; <br>    lpszCmdLine   = WinMainContext.lpszCmdLine; <br>    nCmdShow      = WinMainContext.nCmdShow; <br> <br>    hr = CHK_HrWorkerThread( <br>        hShutdownEvent); <br> <br>    if(FAILED(hr)) <br>        return; <br> <br>    // Are there other instances of the app running? <br>    if(hPrevInstance == NULL)                <br>    {// YES, so initialize shared things. <br>        if(fInitApplication(hInstance) == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            ServiceStop(); <br> <br>            goto cleanup; <br>        } <br>    } <br> <br>    // Perform initializations that apply to a specific instance <br>    if(fInitInstance(hInstance, nCmdShow) == FALSE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        ServiceStop(); <br> <br>        goto cleanup; <br>    } <br> <br>    hr = HrServiceStartup(hInstance, hPrevInstance, hAppWnd, lpszCmdLine); <br> <br>    if(FAILED(hr)) <br>    { <br>        ServiceStop(); <br> <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Create a thread that waits for the shut down event to trigger. <br>    // <br> <br>    hShutdownThread = CreateThread( <br>        NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE)WaitShutdown, <br>        (LPVOID)hShutdownEvent, <br>        0, <br>        &amp;dwShutdownTID); <br> <br>    if(hShutdownThread == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        ServiceStop(); <br> <br>        // <br>        // The service thread has not started yet so just shut down. <br>        // <br> <br>        (void)HrServiceShutdown(); <br> <br>        goto cleanup; <br>    } <br> <br>    // Start a thread that executes the ServiceMain function. <br>    hServiceThread = CreateThread( <br>        NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE)ServiceMain, <br>        (LPVOID)hShutdownEvent, <br>        0, <br>        &amp;dwServiceTID); <br> <br>    if(hServiceThread == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        ServiceStop(); <br>    } <br> <br>    // Acquire and dispatch messages until a WM_QUIT message is received. <br>    while (GetMessage( <br>        &amp;msg,   // message structure <br>        NULL,   // handle of window receiving the message <br>        0,      // lowest message to examine <br>        0))     // highest message to examine <br>    { <br>        TranslateMessage(&amp;msg);// Translates virtual key codes <br>        DispatchMessage(&amp;msg); // Dispatches message to window <br>    } <br> <br>    hr = NOERROR; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>        SetServiceExitCode( ERROR_SERVICE_LOGON_FAILED, NOERROR); <br> <br>    CLOSEHANDLE(hShutdownThread); <br> <br>    ExitThread(0); <br> <br>    return; <br>} <br> <br>//$--SzMakeServiceName---------------------------------------------------------- <br>//  Make a service name from the EXE name. <br>// ----------------------------------------------------------------------------- <br>static LPSTR SzMakeServiceName(        // RETURNS: name of service <br>    IN LPSTR lpszExe)                  // executable name <br>{ <br>    LPSTR lpszCurr    = NULL; <br>    LPSTR lpszName    = NULL; <br> <br>    if(lpszExe == NULL) <br>    { <br>        return(NULL); <br>    } <br> <br>    lpszName = lpszExe + lstrlen(lpszExe); <br> <br>    while(lpszName != lpszExe) <br>    { <br>        // <br>        // Check if character is a delimiter <br>        // <br> <br>        lpszCurr = ":\\"; <br> <br>        while(*lpszCurr) <br>        { <br>            if(*lpszName == *lpszCurr) <br>            { <br>                // <br>                // Found a delimiter <br>                // <br> <br>                goto cleanup; <br>            } <br> <br>            lpszCurr++; <br>        } <br> <br>        // <br>        // Remove file extension <br>        // <br> <br>        if(*lpszName == '.') <br>        { <br>            *lpszName = 0; <br>        } <br> <br>        lpszName--; <br>    } <br> <br>cleanup: <br> <br>    if(lpszName != lpszExe) <br>    { <br>        // <br>        // Advance past delimiter <br>        // <br> <br>        lpszName++; <br>    } <br> <br>    return(lpszName); <br>} <br> <br>//$--dwDoServiceCtrlPause------------------------------------------------------- <br>//  This function is called by ServiceCtrl whenever <br>//  someone calls ControlService to pause our service. <br>// ----------------------------------------------------------------------------- <br>static DWORD dwDoServiceCtrlPause(         // RETURNS: service state <br>    VOID)                           // no arguments <br>{ <br>    HRESULT hr       = NOERROR; <br>    DWORD   dwState  = SERVICE_RUNNING; <br>    DWORD   dwStatus = 0; <br>    BOOL    fStatus  = TRUE; <br> <br>    DEBUGPUBLIC("dwDoServiceCtrlPause()\n"); <br> <br>    dwState = ssStatus.dwCurrentState; <br> <br>    if(ssStatus.dwCurrentState == SERVICE_RUNNING) <br>    { <br>        // Report the status, specifying the checkpoint and wait-hint, <br>        // before setting the continue event. <br> <br>        dwState = SERVICE_PAUSED; <br> <br>        dwPauseCheckPoint++; <br> <br>        FServiceReportStatus( <br>            dwState,              // current state <br>            NOERROR,              // exit code <br>            NOERROR,              // exit code <br>            dwPauseCheckPoint,    // checkpoint <br>            dwPauseWaitHint);     // wait hint <br> <br>        if((hServicePauseEvent != NULL) &amp;&amp; (hServiceContinueEvent != NULL)) <br>        { <br>            fStatus = ResetEvent(hServiceContinueEvent); <br> <br>            if(fStatus == FALSE) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br> <br>            fStatus = SetEvent(hServicePauseEvent); <br> <br>            if(fStatus == FALSE) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    return(dwState); <br>} <br> <br>//$--dwDoServiceCtrlContinue---------------------------------------------------- <br>//  This function is called by ServiceCtrl whenever <br>//  someone calls ControlService to continue our service. <br>// ----------------------------------------------------------------------------- <br>static DWORD dwDoServiceCtrlContinue(      // RETURNS: service state <br>    VOID)                           // no arguments <br>{ <br>    HRESULT hr       = NOERROR; <br>    DWORD   dwState  = SERVICE_RUNNING; <br>    DWORD   dwStatus = 0; <br>    BOOL    fStatus  = TRUE; <br> <br>    DEBUGPUBLIC("dwDoServiceCtrlContinue()\n"); <br> <br>    dwState = ssStatus.dwCurrentState; <br> <br>    if(ssStatus.dwCurrentState == SERVICE_PAUSED) <br>    { <br>        // Report the status, specifying the checkpoint and wait-hint, <br>        // before setting the continue event. <br> <br>        dwState = SERVICE_RUNNING; <br> <br>        dwContinueCheckPoint++; <br> <br>        FServiceReportStatus( <br>            dwState,              // current state <br>            NOERROR,              // exit code <br>            NOERROR,              // exit code <br>            dwContinueCheckPoint, // checkpoint <br>            dwContinueWaitHint);  // wait hint <br> <br>        if((hServicePauseEvent != NULL) &amp;&amp; (hServiceContinueEvent != NULL)) <br>        { <br>            fStatus = ResetEvent(hServicePauseEvent); <br> <br>            if(fStatus == FALSE) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br> <br>            fStatus = SetEvent(hServiceContinueEvent); <br> <br>            if(fStatus == FALSE) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    return(dwState); <br>} <br> <br>//$--dwDoServiceCtrlStop-------------------------------------------------------- <br>//  This function is called by ServiceCtrl whenever <br>//  someone calls ControlService to stop our service. <br>// ----------------------------------------------------------------------------- <br>static DWORD dwDoServiceCtrlStop(          // RETURNS: service state <br>    VOID)                           // no arguments <br>{ <br>    HRESULT hr       = NOERROR; <br>    DWORD   dwState  = SERVICE_RUNNING; <br>    DWORD   dwStatus = 0; <br>    BOOL    fStatus  = TRUE; <br> <br>    DEBUGPUBLIC("dwDoServiceCtrlStop()\n"); <br> <br>    dwState = SERVICE_STOP_PENDING; <br> <br>    // Report the status, specifying the checkpoint and wait-hint, <br>    // before setting the termination event. <br> <br>    dwStopCheckPoint++; <br> <br>    FServiceReportStatus( <br>        SERVICE_STOP_PENDING, // current state <br>        NOERROR,              // exit code <br>        NOERROR,              // exit code <br>        dwStopCheckPoint,     // checkpoint <br>        dwStopWaitHint);      // wait hint <br> <br>    if(hServiceStopEvent != NULL) <br>    { <br>        fStatus = SetEvent(hServiceStopEvent); <br> <br>        if(fStatus == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    return(dwState); <br>} <br> <br>//$--ServiceCtrlProc------------------------------------------------------------ <br>//  This function is called by the Service Controller whenever <br>//  someone calls ControlService in reference to our service. <br>// ----------------------------------------------------------------------------- <br>static VOID WINAPI ServiceCtrlProc(         // RETURNS: nothing <br>    IN DWORD dwCtrlCode)            // control code <br>{ <br>    HRESULT hr       = NOERROR; <br>    DWORD   dwState  = SERVICE_RUNNING; <br>    DWORD   dwStatus = 0; <br>    BOOL    fStatus  = FALSE; <br> <br>    DEBUGPUBLIC("ServiceCtrlProc()\n"); <br> <br>    // <br>    // Handle the requested control code. <br>    // <br> <br>    switch(dwCtrlCode)  <br>    { <br>        // Pause the service if it is running. <br>        case SERVICE_CONTROL_PAUSE: <br>            dwState = dwDoServiceCtrlPause(); <br>            break; <br> <br>        // Resume the paused service. <br>        case SERVICE_CONTROL_CONTINUE: <br>            dwState = dwDoServiceCtrlContinue(); <br>            break; <br> <br>        // Stop the service. <br>        case SERVICE_CONTROL_STOP: <br>            dwState = dwDoServiceCtrlStop(); <br>            return; <br> <br>        // Update the service status. <br>        case SERVICE_CONTROL_INTERROGATE: <br>            break; <br> <br>        // Invalid control code <br>        default: <br>            break; <br>    } <br> <br>    // <br>    // Send a status response. <br>    // <br> <br>    fStatus = FServiceReportStatus(dwState, NOERROR, NOERROR, 0, 0); <br> <br>    if(fStatus == FALSE) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br>} <br> <br>//$--_ServiceMain--------------------------------------------------------------- <br>//  This function takes care of actually starting the service, <br>//  informing the service controller at each step along the way. <br>//  After launching the worker thread, it waits on the event <br>//  that the worker thread will signal at its termination. <br>// ----------------------------------------------------------------------------- <br>VOID _ServiceMain(                   // RETURNS: nothing <br>    IN DWORD dwArgc,                // count of arguments <br>    IN LPSTR *lpszArgv)            // pointer to arguments <br>{ <br>    HRESULT hr         = NOERROR; <br>    DWORD   dw         = 0; <br>    DWORD   dwThreadID = 0; <br>    BOOL    fStatus    = FALSE; <br> <br>    DEBUGPUBLIC("_ServiceMain()"); <br> <br>    hr = CHK__ServiceMain( <br>        dwArgc, <br>        lpszArgv); <br> <br>    if(FAILED(hr)) <br>        return; <br> <br>    // Register our service control handler: <br> <br>    lstrcpyn( <br>        szServiceName, <br>        SzMakeServiceName(lpszArgv[0]), <br>        MAX_SERVICE_NAME_LENGTH); <br> <br>    szServiceName[MAX_SERVICE_NAME_LENGTH] = 0; <br> <br>    dwServiceArgc   = dwArgc; <br>    lpszServiceArgv = lpszArgv; <br> <br>    if(fIsService == TRUE) <br>    { <br>        sshStatusHandle = RegisterServiceCtrlHandler( <br>            szServiceName, <br>            ServiceCtrlProc); <br> <br>        if(sshStatusHandle == 0) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    ssStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS; <br>    ssStatus.dwServiceSpecificExitCode = 0; <br> <br>    // Report the status to Service Control Manager. <br> <br>    dwStartCheckPoint++; <br> <br>    if(FServiceReportStatus( <br>        SERVICE_START_PENDING,      // service state <br>        NOERROR,                    // exit code <br>        NOERROR,                    // exit code <br>        dwStartCheckPoint,          // checkpoint <br>        dwStartWaitHint) == FALSE)  // wait hint <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Create the event object. The control handler function signals <br>    // this event when it receives the "stop" control code. <br> <br>    hServiceStopEvent = CreateEvent( <br>        NULL,    // no security attributes <br>        TRUE,    // manual reset event <br>        FALSE,   // not-signalled <br>        NULL);   // no name <br> <br>    if(hServiceStopEvent == (HANDLE)NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Create the event object. The control handler function signals <br>    // this event when it receives the "pause" control code. <br> <br>    hServicePauseEvent = CreateEvent( <br>        NULL,    // no security attributes <br>        TRUE,    // manual reset event <br>        FALSE,   // not-signalled <br>        NULL);   // no name <br> <br>    if(hServicePauseEvent == (HANDLE)NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Create the event object. The control handler function signals <br>    // this event when it receives the "continue" control code. <br> <br>    hServiceContinueEvent = CreateEvent( <br>        NULL,    // no security attributes <br>        TRUE,    // manual reset event <br>        FALSE,   // not-signalled <br>        NULL);   // no name <br> <br>    if(hServiceContinueEvent == (HANDLE)NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Create the event object. The application signals <br>    // this event when it is ready to "stop". <br> <br>    hStopConfirmEvent = CreateEvent( <br>        NULL,    // no security attributes <br>        TRUE,    // manual reset event <br>        FALSE,   // not-signalled <br>        NULL);   // no name <br> <br>    if(hStopConfirmEvent == (HANDLE)NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Report the status to the service control manager. <br> <br>    dwStartCheckPoint++; <br> <br>    if(FServiceReportStatus( <br>        SERVICE_START_PENDING,      // service state <br>        NOERROR,                    // exit code <br>        NOERROR,                    // exit code <br>        dwStartCheckPoint,          // checkpoint <br>        dwStartWaitHint) == FALSE)  // wait hint <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Start the thread that performs the work of the service. <br>    hWorkerThread = CreateThread( <br>        NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE)WorkerThread, <br>        (LPVOID)hServiceStopEvent, <br>        0, <br>        &amp;dwWorkerTID); <br> <br>    if(hWorkerThread == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } </code></pre>
<p>
</p>
<pre><code><br>    // Report the status to the service control manager. <br>    if(FServiceReportStatus( <br>        SERVICE_RUNNING, // service state <br>        NOERROR,         // exit code <br>        NOERROR,         // exit code <br>        0,               // checkpoint <br>        0) == FALSE)     // wait hint <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // <br>    // Wait indefinitely until worker thread exits. <br>    // <br> <br>    dw = WaitForSingleObject(hWorkerThread, INFINITE); <br> <br>    if((dw != WAIT_OBJECT_0) &amp;&amp; (dw != WAIT_ABANDONED)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>cleanup: <br> <br>    CLOSEHANDLE(hWorkerThread); <br> <br>    CLOSEHANDLE(hServiceStopEvent); <br> <br>    CLOSEHANDLE(hServicePauseEvent); <br> <br>    CLOSEHANDLE(hServiceContinueEvent); <br> <br>    CLOSEHANDLE(hStopConfirmEvent); <br> <br>    // <br>    // Try to report the stopped status to the service control manager. <br>    // <br> <br>    if(sshStatusHandle != 0) <br>    { <br>        fStatus = FServiceReportStatus( <br>            SERVICE_STOPPED, <br>            dwSvcWin32ExitCode, <br>            dwSvcServiceSpecificExitCode, <br>            0, <br>            0); <br> <br>        if(fStatus == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br> <br>    // When SERVICE MAIN FUNCTION returns in a single service <br>    // process, the StartServiceCtrlDispatcher function in <br>    // the main thread returns, terminating the process. <br> <br>    return; <br>} <br> <br>//$--HrWaitServiceStopConfirm--------------------------------------------------- <br>//  This function is called to wait for the application to stop. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrWaitServiceStopConfirm(   // RETURNS: return code <br>    VOID)                           // no arguments <br>{ <br>    HRESULT hr            = NOERROR; <br>    DWORD   dwT           = 0; <br>    DWORD   dwStopTimeOut = dwStopWaitHint/2; <br> <br>    DEBUGPUBLIC("HrWaitServiceStopConfirm()\n"); <br> <br>    for(;;) <br>    { <br>        if(fIsService == TRUE) <br>        { <br>            // Report the status, specifying the checkpoint and wait-hint. <br> <br>            dwStopCheckPoint++; <br> <br>            FServiceReportStatus( <br>                SERVICE_STOP_PENDING, // current state <br>                NOERROR,              // exit code <br>                NOERROR,              // exit code <br>                dwStopCheckPoint,     // checkpoint <br>                dwStopWaitHint);      // wait hint <br>        } <br> <br>        // <br>        // Wait until application has stopped or a timeout occurs. <br>        // <br> <br>        dwT = WaitForSingleObject(hStopConfirmEvent, dwStopTimeOut); <br> <br>        switch(dwT) <br>        { <br>        case (WAIT_OBJECT_0): <br>        case (WAIT_ABANDONED_0): <br>            hr = NOERROR; <br>            goto cleanup; <br>            break; <br>        case WAIT_TIMEOUT: <br>            break; <br>        default: <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--SetServiceExitCode--------------------------------------------------------- <br>//  This function is called by the application to set the service exit code. <br>// <br>//  dwWin32ExitCode <br>// <br>//      - specifies a Win32 error code that the service uses to <br>//        report an error that occurs when it is starting or <br>//        stopping. To return an error code specific to the service, <br>//        the service must set this value to <br>//        ERROR_SERVICE_SPECIFIC_ERROR to indicate that the <br>//        dwServiceSpecificExitCode member contains the error code. <br>//        The service should set this value to NO_ERROR when it is <br>//        running and on normal termination.  <br>// <br>//  dwServiceSpecificExitCode <br>// <br>//      - specifies a service specific error code that the <br>//        service returns when an error occurs while the service is <br>//        starting or stopping. This value is ignored unless the <br>//        dwWin32ExitCode member is set to ERROR_SERVICE_SPECIFIC_ERROR.  <br>//       <br>// ----------------------------------------------------------------------------- <br>VOID SetServiceExitCode( <br>    IN DWORD dwWin32ExitCode,           // Win32 exit code <br>    IN DWORD dwServiceSpecificExitCode) // service specific exit code <br>{ <br>    DEBUGPUBLIC("SetServiceExitCode()"); <br> <br>    dwSvcWin32ExitCode           = dwWin32ExitCode; <br>    dwSvcServiceSpecificExitCode = dwServiceSpecificExitCode; <br>} <br> <br>//$--HrServiceConfirmStop---------------------------------------------------- <br>//  This function is called by the application to indicate that it has stopped. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrServiceConfirmStop(    // RETURNS: return code <br>    VOID)                           // no arguments <br>{ <br>    HRESULT hr      = NOERROR; <br>    BOOL    fStatus = TRUE; <br> <br>    DEBUGPUBLIC("HrServiceConfirmStop()\n"); <br> <br>    if(hStopConfirmEvent != NULL) <br>    { <br>        fStatus = SetEvent(hStopConfirmEvent); <br> <br>        if(fStatus == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br>    else <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//------------------------------------------------------------------------------ <br>// Utility functions... <br>//------------------------------------------------------------------------------ <br> <br>//$--FServiceReportStatus------------------------------------------------------- <br>//  This function is called by the private _ServiceMain() and <br>//  ServCtrlHandler() functions to update the service's status <br>//  to the service control manager. <br>// ----------------------------------------------------------------------------- <br>BOOL FServiceReportStatus(              // RETURNS: TRUE if successful <br>    IN DWORD dwCurrentState,            // current state of service <br>    IN DWORD dwWin32ExitCode,           // service Win32 exit code <br>    IN DWORD dwServiceSpecificExitCode, // service specific exit code <br>    IN DWORD dwCheckPoint,              // check point number <br>    IN DWORD dwWaitHint)                // time to wait <br>{ <br>    BOOL fResult = TRUE; <br> <br>    DEBUGPUBLIC("FServiceReportStatus()\n"); <br> <br>    // Disable control requests until the service is started. <br> <br>    if(dwCurrentState == SERVICE_START_PENDING) <br>    { <br>        ssStatus.dwControlsAccepted = 0; <br>    } <br>    else <br>    { <br>        ssStatus.dwControlsAccepted = <br>            SERVICE_ACCEPT_STOP | <br>            SERVICE_ACCEPT_PAUSE_CONTINUE; <br>    } <br> <br>    // These SERVICE_STATUS members are set from parameters. <br> <br>    ssStatus.dwCurrentState            = dwCurrentState; <br>    ssStatus.dwWin32ExitCode           = dwWin32ExitCode; <br>    ssStatus.dwServiceSpecificExitCode = dwServiceSpecificExitCode; <br>    ssStatus.dwCheckPoint              = dwCheckPoint; <br>    ssStatus.dwWaitHint                = dwWaitHint; <br> <br>    // Report the status of the service to the service control manager. <br> <br>    if(fIsService == TRUE) <br>    { <br>        fResult = SetServiceStatus( <br>            sshStatusHandle,    // service reference handle <br>            &amp;ssStatus);         // SERVICE_STATUS structure <br> <br>        if(fResult == FALSE) <br>        { <br>            // If an error occurs, stop the service. <br> <br>            ServiceStop(); <br>        } <br>    } <br> <br>    return(fResult); <br>} <br> <br>//$--ServiceStop------------------------------------------------------------- <br>//  This function can be used by any thread to stop the service. <br>// ----------------------------------------------------------------------------- <br>VOID ServiceStop(                // RETURNS: nothing <br>    VOID)                           // no argument <br>{ <br>    HRESULT hr      = NOERROR; <br>    BOOL    fStatus = TRUE; <br> <br>    DEBUGPUBLIC("ServiceStop()\n"); <br> <br>    // Set a termination event to stop SERVICE MAIN FUNCTION. <br> <br>    if(hServiceStopEvent != NULL) <br>    { <br>        fStatus = SetEvent(hServiceStopEvent); <br> <br>        if(fStatus == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>    } <br>} <br> <br>//$--HrServiceWaitForControl---------------------------------------------------- <br>//  The HrServiceWaitForControl function can be used by any thread to get or <br>//  wait for service control after the service has been started. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrServiceWaitForControl(        // RETURNS: return code <br>    IN DWORD dwTimeout,                 // time-out interval in milliseconds <br>    OUT EDK_SERVICE_CONTROL_T *pedksc)  // pointer to service name buffer <br>{ <br>    HRESULT hr          = NOERROR; <br>    DWORD   cObjects    = 3; <br>    HANDLE  hObjects[3] = {0}; <br>    DWORD   dwResult    = WAIT_FAILED; <br> <br>    DEBUGPUBLIC("HrServiceWaitForControl()\n"); <br> <br>    hr = CHK_HrServiceWaitForControl( <br>        dwTimeout, <br>        pedksc); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hObjects[0] = hServiceStopEvent; <br>    hObjects[1] = hServicePauseEvent; <br>    hObjects[2] = hServiceContinueEvent; <br> <br>    dwResult = WaitForMultipleObjects(cObjects, hObjects, FALSE, dwTimeout); <br> <br>    *pedksc = EDK_SC_NONE; <br> <br>    switch(dwResult) <br>    { <br>    case (WAIT_OBJECT_0): <br>        *pedksc = EDK_SC_STOP; <br>        break; <br>    case (WAIT_OBJECT_0+1): <br>        *pedksc = EDK_SC_PAUSE; <br>        break; <br>    case (WAIT_OBJECT_0+2): <br>        *pedksc = EDK_SC_CONTINUE; <br>        break; <br>    case (WAIT_ABANDONED_0): <br>        break; <br>    case (WAIT_ABANDONED_0+1): <br>        break; <br>    case (WAIT_ABANDONED_0+2): <br>        break; <br>    case WAIT_TIMEOUT: <br>        break; <br>    default: <br>        *pedksc = EDK_SC_STOP; <br> <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrServiceWaitForContinue--------------------------------------------------- <br>//  The HrServiceWaitForContinue function can be used by any thread to get or <br>//  wait for service control after the service has been started. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrServiceWaitForContinue(       // RETURNS: return code <br>    IN DWORD dwTimeout,                 // time-out interval in milliseconds <br>    OUT EDK_SERVICE_CONTROL_T *pedksc)  // pointer to service name buffer <br>{ <br>    HRESULT hr          = NOERROR; <br>    DWORD   cObjects    = 2; <br>    HANDLE  hObjects[2] = {0}; <br>    DWORD   dwResult    = WAIT_FAILED; <br> <br>    DEBUGPUBLIC("HrServiceWaitForContinue()\n"); <br> <br>    hr = CHK_HrServiceWaitForContinue( <br>        dwTimeout, <br>        pedksc); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hObjects[0] = hServiceStopEvent; <br>    hObjects[1] = hServiceContinueEvent; <br> <br>    dwResult = WaitForMultipleObjects(cObjects, hObjects, FALSE, dwTimeout); <br> <br>    *pedksc = EDK_SC_NONE; <br> <br>    switch(dwResult) <br>    { <br>    case (WAIT_OBJECT_0): <br>        *pedksc = EDK_SC_STOP; <br>        break; <br>    case (WAIT_OBJECT_0+1): <br>        *pedksc = EDK_SC_CONTINUE; <br>        break; <br>    case (WAIT_ABANDONED_0): <br>        break; <br>    case (WAIT_ABANDONED_0+1): <br>        break; <br>    case WAIT_TIMEOUT: <br>        break; <br>    default: <br>        *pedksc = EDK_SC_STOP; <br> <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrServiceWaitForStop------------------------------------------------------- <br>//  The HrServiceWaitForStop function can be used by any thread to get or <br>//  wait for service control after the service has been started. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrServiceWaitForStop(           // RETURNS: return code <br>    IN DWORD dwTimeout,                 // time-out interval in milliseconds <br>    OUT EDK_SERVICE_CONTROL_T *pedksc)  // pointer to service name buffer <br>{ <br>    HRESULT hr          = NOERROR; <br>    DWORD   cObjects    = 1; <br>    HANDLE  hObjects[1] = {0}; <br>    DWORD   dwResult    = WAIT_FAILED; <br> <br>    DEBUGPUBLIC("HrServiceWaitForStop()\n"); <br> <br>    hr = CHK_HrServiceWaitForStop( <br>        dwTimeout, <br>        pedksc); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hObjects[0] = hServiceStopEvent; <br> <br>    dwResult = WaitForMultipleObjects(cObjects, hObjects, FALSE, dwTimeout); <br> <br>    *pedksc = EDK_SC_NONE; <br> <br>    switch(dwResult) <br>    { <br>    case (WAIT_OBJECT_0): <br>        *pedksc = EDK_SC_STOP; <br>        break; <br>    case (WAIT_ABANDONED_0): <br>        break; <br>    case WAIT_TIMEOUT: <br>        break; <br>    default: <br>        *pedksc = EDK_SC_STOP; <br> <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrServiceProcessControl--------------------------------------------------- <br>//  Check for service control <br>// ----------------------------------------------------------------------------- <br>HRESULT HrServiceProcessControl(       // RETURNS: return code <br>    VOID)                               // no arguments <br>{ <br>    HRESULT               hr    = NOERROR; <br>    HRESULT               hrT   = NOERROR; <br>    EDK_SERVICE_CONTROL_T edksc = EDK_SC_NONE; <br> <br>    DEBUGPUBLIC("HrServiceProcessControl()\n"); <br> <br>    for(;;) <br>    { <br>        switch(edksc) <br>        { <br>        case EDK_SC_PAUSE: <br>            // Wait for service to continue or stop <br>            hrT = HrServiceWaitForContinue(INFINITE, &amp;edksc); <br>            break; <br>        default: <br>            // Wait for service to pause, continue or stop <br>            hrT = HrServiceWaitForControl(0, &amp;edksc); <br>        } <br> <br>        if(SUCCEEDED(hrT)) <br>        { <br>            switch(edksc) <br>            { <br>            case EDK_SC_NONE: <br>                goto cleanup; <br>                break; <br>            case EDK_SC_PAUSE: <br>                break; <br>            case EDK_SC_CONTINUE: <br>                goto cleanup; <br>                break; <br>            case EDK_SC_STOP: <br>                hr = HR_LOG(EDK_E_SHUTDOWN_SERVICE); <br>                goto cleanup; <br>                break; <br>            default: <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrFreeArgvW---------------------------------------------------------------- <br>//  Free a wide character copy of argv[]. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrFreeArgvW(         // RETURNS: exit code <br>    IN     DWORD  dwArgc,           // Number of arguments <br>    IN OUT LPWSTR **lppszArgvW)     // pointer to wide character command line <br>{ <br>    HRESULT hr     = NOERROR; <br>    DWORD   i      = 0; <br>    LPWSTR  *lpwsz = NULL; <br> <br>    DEBUGPRIVATE("HrFreeArgvW()\n"); <br> <br>    hr = CHK_HrFreeArgvW( <br>        dwArgc, <br>        lppszArgvW); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    lpwsz = *lppszArgvW; <br> <br>    if(lpwsz != NULL) <br>    { <br>        for(i = 0 ; i &lt; dwArgc ; i++) <br>        { <br>            if(lpwsz[i] != NULL) <br>            { <br>                free(lpwsz[i]); <br>                lpwsz[i] = NULL; <br>            } <br>        } <br> <br>        free(lpwsz); <br>        lpwsz = NULL; <br>    } <br> <br>    *lppszArgvW = NULL; <br> <br>    RETURN(hr); <br>} <br> <br>//$--ControlHandler------------------------------------------------------------- <br>//  Handle console control events. <br>// ----------------------------------------------------------------------------- <br>static BOOL WINAPI ControlHandler(          // RETURNS: TRUE if successful <br>    IN DWORD dwCtrlType)                    // control event type <br>{ <br>    switch( dwCtrlType ) <br>    { <br>    case CTRL_BREAK_EVENT:  // use Ctrl+C or Ctrl+Break to simulate <br>    case CTRL_C_EVENT:      // SERVICE_CONTROL_STOP in debug mode <br> <br>        ServiceStop(); <br> <br>        return(TRUE); <br>        break; <br>    default: <br>        ; <br>    } <br> <br>    return(FALSE); <br>} <br> <br>//$--WinMain-------------------------------------------------------------------- <br>//  This function starts the service. <br>// ----------------------------------------------------------------------------- <br>int APIENTRY WinMain(               // RETURNS: exit code <br>    IN  HINSTANCE hInstance,        // Handle to instance of application <br>    IN  HINSTANCE hPrevInstance,    // Handle to previous instance <br>    IN  LPSTR lpszCmdLine,          // Pointer to command line <br>    IN  int nCmdShow)               // Argument for ShowWindow() <br>{ <br>    HRESULT hr       = NOERROR; <br>    DWORD   dwArgc   = 0; <br>    LPSTR* lpszArgv = NULL; <br> <br>    SERVICE_TABLE_ENTRY dispatchTable[] = <br>    { <br>        { SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)_ServiceMain }, <br>        { NULL, NULL } <br>    }; <br> <br>    DEBUGPUBLIC("WinMain()\n"); <br> <br>    // <br>    // Parse command line <br>    // <br> <br>    dwArgc   = (DWORD) __argc; <br>    lpszArgv = __argv; <br> <br>    // <br>    // Check if running as a service <br>    // <br> <br>    if((dwArgc &gt; 1) &amp;&amp; (lstrcmpi(lpszArgv[1], "NOTSERV") == 0)) <br>    { <br>        fIsService = FALSE; <br>    } <br> <br>    WinMainContext.hInstance     = hInstance; <br>    WinMainContext.hPrevInstance = hPrevInstance; <br>    WinMainContext.lpszCmdLine   = lpszCmdLine; <br>    WinMainContext.nCmdShow      = nCmdShow; <br> <br>    if(fIsService == TRUE) <br>    { <br>        // <br>        // Run as a service <br>        // <br> <br>        if(StartServiceCtrlDispatcher(dispatchTable) == FALSE) <br>        { <br>            hr = HR_LOG(E_FAIL); <br> <br>            ServiceStop(); <br>        } <br>    } <br>    else <br>    { <br>        SetConsoleCtrlHandler(ControlHandler, TRUE); <br> <br>        if(dwArgc == 2) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        else <br>        { <br>            _ServiceMain(dwArgc-2, lpszArgv+2);  // NOTE:  if we're running by command line, <br>                                                // need to pass arg after 'NOTSERV' as service <br>                                                // name rather than exe name. <br>        } <br>    } <br> <br>    return(0); <br>} <br> <br>//$--WndProc-------------------------------------------------------------------- <br>//  Processes messages <br>// ----------------------------------------------------------------------------- <br>LRESULT CALLBACK WndProc(           // RETURNS: LRESULT <br>    IN HWND hWnd,                   // window handle <br>    IN UINT message,                // type of message <br>    IN WPARAM uParam,               // additional information <br>    IN LPARAM lParam)               // additional information <br>{ <br>    HRESULT hr        = NOERROR; <br>    HRESULT hrT       = NOERROR; <br>    LRESULT lRetVal   = 0; <br>    BOOL    fStatus   = TRUE; <br>    DWORD   dw        = 0; <br> <br>    DEBUGPUBLIC("WndProc()\n"); <br> <br>    switch( message) <br>    { <br>    //  Closing the window will signal the shutdown event object and cause <br>    //  WaitShutdown to send a WM_DESTROY message and end its thread. <br>    case WM_CLOSE: <br>ServiceStop(); <br>        break; <br> <br>    //  Before destroying the window, call NTServiceShutdown. <br>    case WM_DESTROY: <br> <br>        // <br>        // Wait for application to stop. <br>        // <br> <br>        hrT = HR_LOG(HrWaitServiceStopConfirm()); <br> <br>        // <br>        // Wait for service thread to exit. <br>        // <br> <br>        if(hServiceThread != NULL) <br>        { <br>            dw = WaitForSingleObject(hServiceThread, WAIT_DESTROY); <br> <br>            if((dw != WAIT_OBJECT_0) &amp;&amp; (dw != WAIT_ABANDONED_0)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br> <br>            CLOSEHANDLE(hServiceThread); <br>        } <br> <br>        hrT = HR_LOG(HrServiceShutdown()); <br> <br>        // <br>        // Cause message loop in WorkerThread() to terminate. <br>        // <br> <br>        PostQuitMessage(0); <br>        break; <br> <br>    //  Paint the icon if its background is erased. <br>    case WM_ICONERASEBKGND: <br> <br>        DefWindowProc(hWnd, WM_ICONERASEBKGND, uParam, lParam); <br>        PostMessage(hWnd, WM_PAINTICON, 0, 0); <br>        break; <br> <br>    //  Users are not allowed to "Switch To" this application via Task Manager <br>    //  since it has no main window.  According to the API, if the icon can not <br>    //  be opened, this message should return FALSE. <br>    case WM_QUERYOPEN: <br> <br>        lRetVal = (LRESULT)FALSE; <br>        break; <br> <br>    //  Do the default action for any other message. <br>    default: <br> <br>        lRetVal = DefWindowProc(hWnd, message, uParam, lParam); <br>        break; <br>    } <br> <br>    return(lRetVal); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
