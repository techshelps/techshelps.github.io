<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CFGNOTIF.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1822"></a>CFGNOTIF.C</h2>
<pre><code>// --cfgnotif.c----------------------------------------------------------------- <br>// <br>//  Routines to provide notification when a given extension data section has  <br>//  changed, and read the new data. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "attrname.h" <br>#include "cfgnotif.chk" <br> <br>// <br>// Internal Function Declarations <br>// <br> <br>static DWORD WINAPI PollThread( <br>    IN LPVOID lpvThreadParam); <br> <br>static HRESULT HrUpdateAdviseNotify( <br>    IN      LPSPropValue    lpNewData, <br>    IN OUT  LPADVISENOTIFY  lpNotify); <br> <br>static HRESULT HrDestroyAdviseNotify( <br>    IN OUT  LPADVISENOTIFY * lppNotify); <br> <br>// <br>// Configuration API Routines <br>// <br> <br>//$--HrCfgCreateAdviseObj------------------------------------------------------- <br>//  Begin monitoring of a MAPI session for changes to extension data. <br>//  This routine should be called once to create an advise object for a MAPI  <br>//  session that is being monitored.  Then, HrCfgAdvise() should be called  <br>//  once for each extension data section that is being monitored. <br>//  If nPollInterval == 0 then no monitoring thread is created, and the user  <br>//  must do polling manually by calling HrCfgPollAdviseObj(). <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCfgCreateAdviseObj(               // RETURNS: HRESULT <br>    IN  LPMAPISESSION       lpSession,      // MAPI session to monitor <br>    IN  ULONG               nPollInterval,  // milliseconds between polling <br>    OUT LPADVISEOBJ *       lppAdviseObj)   // created advise object <br>{ <br>    HRESULT                 hr              = NOERROR; <br>    LPADVISEOBJ             lpAdviseObj     = NULL; <br>SECURITY_ATTRIBUTES     saEvent         = {0, NULL, TRUE}; <br>    BOOL                    fCriticalSectionInitialized     = FALSE; <br> <br>    hr = CHK_HrCfgCreateAdviseObj( <br>        lpSession,  <br>        nPollInterval,  <br>        lppAdviseObj); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    DEBUGPUBLIC("HrCfgCreateAdviseObj()\n"); <br> <br>    // Get memory for the advise object. <br> <br>    hr = MAPIAllocateBuffer(sizeof(*lpAdviseObj), &amp;lpAdviseObj); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    ZeroMemory(lpAdviseObj, sizeof(*lpAdviseObj)); <br> <br>    // Store parameters in advise object. <br> <br>    lpAdviseObj-&gt;lpSession = lpSession; <br>    lpAdviseObj-&gt;nPollInterval = nPollInterval; <br> <br>    // Get an IMAPIProp interface on the current object. <br> <br>    hr = HrOpenSessionObject(lpSession, &amp;lpAdviseObj-&gt;lpCurrentObject); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Get the property tag for USN-Changed. <br> <br>    hr = HrCfgPropertyTagFromNameId( <br>        lpAdviseObj-&gt;lpCurrentObject,  <br>        NM_USN_CHANGED,  <br>        &amp;lpAdviseObj-&gt;ulUSNChangedPropTag); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // If it came back without the property type then set it to PT_LONG. <br> <br>    if (PROP_TYPE(lpAdviseObj-&gt;ulUSNChangedPropTag) == 0) <br>    { <br>        lpAdviseObj-&gt;ulUSNChangedPropTag =  <br>            CHANGE_PROP_TYPE(lpAdviseObj-&gt;ulUSNChangedPropTag,  <br>            PT_LONG); <br>    } <br> <br>    // Get the property tag for Extension-Data. <br> <br>    hr = HrCfgPropertyTagFromNameId( <br>        lpAdviseObj-&gt;lpCurrentObject,  <br>        NM_EXTENSION_DATA,  <br>        &amp;lpAdviseObj-&gt;ulExtensionDataPropTag); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // If it came back without the property type then set it to PT_MV_BINARY. <br> <br>    if (PROP_TYPE(lpAdviseObj-&gt;ulExtensionDataPropTag) == 0) <br>    { <br>        lpAdviseObj-&gt;ulExtensionDataPropTag =  <br>            CHANGE_PROP_TYPE(lpAdviseObj-&gt;ulExtensionDataPropTag,  <br>            PT_MV_BINARY); <br>    } <br> <br>    // Create a critical section to synchronize access to the advise object. <br> <br>    InitializeCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br>    fCriticalSectionInitialized = TRUE; <br> <br>    // "Poll" the object to get the initial values of the extension data blobs. <br> <br>    hr = HrCfgPollAdviseObj(lpAdviseObj); <br>    if (FAILED(hr)) <br>        goto cleanup;  <br> <br>    // Only create the thread if nPollInterval != 0. <br> <br>    if (nPollInterval != 0) <br>    { <br>        // Create an event to stop the polling thread. <br> <br>        lpAdviseObj-&gt;hPollThreadStop = CreateEvent(&amp;saEvent, FALSE, FALSE, NULL); <br>    if (lpAdviseObj-&gt;hPollThreadStop == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br> <br>    // Create the polling thread. <br> <br>    lpAdviseObj-&gt;hPollThread = CreateThread( <br>        NULL,  <br>        0,  <br>        PollThread,  <br>        lpAdviseObj,  <br>        0,  <br>    &amp;lpAdviseObj-&gt;ulPollThreadID); <br>    if (lpAdviseObj-&gt;hPollThread == NULL) <br>    { <br>    hr = HR_LOG(E_FAIL); <br>    goto cleanup; <br>    } <br>    } <br> <br>    // Set the return variable. <br> <br>    *lppAdviseObj = lpAdviseObj; <br> <br>cleanup: <br>    if (FAILED(hr) &amp;&amp; lpAdviseObj) <br>    { <br>        CLOSEHANDLE(lpAdviseObj-&gt;hPollThreadStop); <br> <br>        if (fCriticalSectionInitialized) <br>            DeleteCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br> <br>        ULRELEASE(lpAdviseObj-&gt;lpCurrentObject); <br> <br>        MAPIFREEBUFFER(lpAdviseObj); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCfgPollAdviseObj--------------------------------------------------------- <br>//  Checks an advise object against what is stored in the DSA.  Calls the  <br>//  notification routines if there are any changes. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCfgPollAdviseObj(                 // RETURNS: HRESULT <br>    IN  LPADVISEOBJ     lpAdviseObj)        // advise object to poll <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    ULONG               ulNewUSNChanged     = 0; <br>    LPSPropValue        lpNewExtensionData  = NULL; <br>    ULONG               cValues             = 0; <br>    LPADVISENOTIFY      lpAdviseNotify      = NULL; <br> <br>    hr = CHK_HrCfgPollAdviseObj( <br>        lpAdviseObj); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    DEBUGPUBLIC("HrCfgPollAdviseObj()\n"); <br> <br>    // Lock the object against access by other threads. <br> <br>    EnterCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br> <br>    // Get the new USN-Changed from the DSA.  If the new USN-Changed is  <br>    // different from the one we have stored then something in the object  <br>    // has changed (possibly the extension data).  Note: the first time these  <br>    // statements are executed, USN-Changed will always have "changed" since  <br>    // the one we have stored starts out at 0. <br> <br>    hr = HrMAPIGetPropLong( <br>        lpAdviseObj-&gt;lpCurrentObject,  <br>        lpAdviseObj-&gt;ulUSNChangedPropTag,  <br>        &amp;ulNewUSNChanged); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // If USN-Changed is different then do the update. <br> <br>    if (ulNewUSNChanged != lpAdviseObj-&gt;ulUSNChanged) <br>    { <br>        SizedSPropTagArray(1, ExtDataTag) =  <br>            {1, {lpAdviseObj-&gt;ulExtensionDataPropTag}}; <br> <br>        // Read the new extension data. <br> <br>        hr = MAPICALL(lpAdviseObj-&gt;lpCurrentObject)-&gt;GetProps( <br>            lpAdviseObj-&gt;lpCurrentObject,  <br>            (LPSPropTagArray) &amp;ExtDataTag,  <br>            0,  <br>            &amp;cValues,  <br>            &amp;lpNewExtensionData); <br> <br>        // If the property was not found then allocate an empty multivalued  <br>        // binary property and store it as if it had been read from the  <br>        // extension data property. <br> <br>        if (hr == MAPI_W_ERRORS_RETURNED &amp;&amp;  <br>            cValues == 1 &amp;&amp;  <br>            PROP_TYPE(lpNewExtensionData-&gt;ulPropTag) == PT_ERROR &amp;&amp;  <br>            lpNewExtensionData-&gt;Value.err == MAPI_E_NOT_FOUND) <br>        { <br>            lpNewExtensionData-&gt;ulPropTag = lpAdviseObj-&gt;ulExtensionDataPropTag; <br>            lpNewExtensionData-&gt;Value.MVbin.cValues = 0; <br> <br>            hr = MAPIAllocateMore( <br>                0,  <br>                lpNewExtensionData,  <br>                &amp;lpNewExtensionData-&gt;Value.MVbin.lpbin); <br>            if (FAILED(hr)) <br>                goto cleanup; <br> <br>            hr = NOERROR; <br>        } <br> <br>        // If there was any other error then return. <br> <br>        if (FAILED(hr) || hr == MAPI_W_ERRORS_RETURNED) <br>            goto cleanup; <br> <br>        // Loop for each ADVISENOTIFY and check to see if it's data has changed. <br>        // If it has, update it and call the callback routine.  After this  <br>        // loop is done, the blob pointers in the ADVISENOTIFY structures will  <br>        // point into the new extension data property, not the old one.  Then,  <br>        // the old one can be freed and replaced in the ADVISEOBJ structure  <br>        // by the new one. <br> <br>        for ( <br>            lpAdviseNotify = lpAdviseObj-&gt;lpNotifyList;  <br>            lpAdviseNotify;  <br>            lpAdviseNotify = lpAdviseNotify-&gt;lpNext) <br>        { <br>            hr = HrUpdateAdviseNotify(lpNewExtensionData, lpAdviseNotify); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>        } <br> <br>        // Replace the old extension data property with the new one. <br> <br>        MAPIFREEBUFFER(lpAdviseObj-&gt;lpExtensionData); <br>        lpAdviseObj-&gt;lpExtensionData = lpNewExtensionData; <br>        lpNewExtensionData = NULL; <br> <br>        // Replace the old USN-Changed value with the new one. <br> <br>        lpAdviseObj-&gt;ulUSNChanged = ulNewUSNChanged; <br>    } <br> <br>cleanup: <br>    MAPIFREEBUFFER(lpNewExtensionData); <br> <br>    // Unlock the object to allow access by other threads. <br> <br>    LeaveCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCfgDestroyAdviseObj------------------------------------------------------ <br>//  End monitoring of a MAPI session.  This routine calls HrCfgUnadvise() for  <br>//  any extension data sections that are actively being monitored. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCfgDestroyAdviseObj(              // RETURNS: HRESULT <br>    IN  LPADVISEOBJ         lpAdviseObj)    // advise object to destroy <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    HRESULT             hrT                 = NOERROR; <br>    BOOL                fItWorked           = TRUE; <br>    DWORD               dwStatus            = 0; <br> <br>    DEBUGPUBLIC("HrCfgDestroyAdviseObj()\n"); <br> <br>    hr = CHK_HrCfgDestroyAdviseObj( <br>        lpAdviseObj); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    if (lpAdviseObj) <br>    { <br>        // Signal the thread to stop and then release the signal event. <br> <br>        if (lpAdviseObj-&gt;hPollThreadStop) <br>        { <br>            fItWorked = SetEvent(lpAdviseObj-&gt;hPollThreadStop); <br>            if (!fItWorked) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>            CLOSEHANDLE(lpAdviseObj-&gt;hPollThreadStop); <br>        } <br> <br>        // Wait for thread to terminate and then release it's handle. <br> <br>        if (lpAdviseObj-&gt;hPollThread) <br>        { <br>            dwStatus = WaitForSingleObject(lpAdviseObj-&gt;hPollThread, INFINITE); <br>            if (dwStatus != WAIT_OBJECT_0) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>            } <br>            CLOSEHANDLE(lpAdviseObj-&gt;hPollThread); <br>        } <br> <br>        // Free the notification structures. <br> <br>        while (lpAdviseObj-&gt;lpNotifyList) <br>        { <br>            hrT = HrDestroyAdviseNotify(&amp;lpAdviseObj-&gt;lpNotifyList); <br>            if (FAILED(hrT)) <br>            { <br>                hr = hrT; <br>            } <br>        } <br> <br>        // Delete the critical section. <br> <br>        DeleteCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br> <br>        // Release the IMAPIProp interface. <br> <br>        ULRELEASE(lpAdviseObj-&gt;lpCurrentObject); <br> <br>        // Free the extension data property. <br> <br>        MAPIFREEBUFFER(lpAdviseObj-&gt;lpExtensionData); <br> <br>        // Free the advise object itself. <br> <br>        MAPIFREEBUFFER(lpAdviseObj); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCfgAdvise---------------------------------------------------------------- <br>//  Begin monitoring of an extension data section.  When the extension data  <br>//  changes, the specified callback routine is called.  Note: The callback  <br>//  routine will be called once from hrCfgAdvise() to set the initial extension  <br>//  data values. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCfgAdvise(                        // RETURNS: HRESULT <br>    IN  LPADVISEOBJ         lpAdviseObj,    // advise object <br>    IN  LPSTR              lpszSection,    // name of extension data section <br>    IN  LPADVISECALLBACK    lpfnCallback,   // function to call on changes <br>    IN  LPVOID              lpvUserContext) // user-defined context <br>{ <br>    HRESULT                 hr              = NOERROR; <br>    LPADVISENOTIFY          lpNotify        = NULL; <br>    ULONG                   cchSection      = 0; <br>    ULONG                   cchActual       = 0; <br> <br>    DEBUGPUBLIC("HrCfgAdvise()\n"); <br> <br>    hr = CHK_HrCfgAdvise( <br>        lpAdviseObj,  <br>        lpszSection,  <br>        lpfnCallback,  <br>        lpvUserContext); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Allocate memory for the ADVISENOTIFY structure. <br> <br>    hr = MAPIAllocateBuffer( <br>        sizeof(*lpNotify),  <br>        &amp;lpNotify); <br>    if (FAILED(hr)) <br>        goto cleanup; <br>    ZeroMemory(lpNotify, sizeof(*lpNotify)); <br> <br>    // Get the number of characters in the section name. <br> <br>    cchSection = lstrlen(lpszSection); <br> <br>    // Allocate memory for the LPSTR section name and copy the section  <br>    // name into it. <br> <br>    hr = MAPIAllocateMore( <br>        cchSection + 1,  <br>        lpNotify,  <br>        &amp;lpNotify-&gt;lpszOwnerTag); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    lstrcpy(lpNotify-&gt;lpszOwnerTag, lpszSection); <br> <br>    // Allocate memory for the UNICODE section name, and copy the section  <br>    // name into it, converting to UNICODE. <br> <br>    hr = MAPIAllocateMore( <br>        (cchSection + 1) * sizeof(WCHAR),  <br>        lpNotify,  <br>        &amp;lpNotify-&gt;lpwszOwnerTag); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>SetLastError(ERROR_SUCCESS); <br> <br>    cchActual = wsprintfW(lpNotify-&gt;lpwszOwnerTag, L"%hs", lpszSection); <br>if (GetLastError() != ERROR_SUCCESS || cchActual != cchSection) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>    // Fill in the structure members. <br> <br>    lpNotify-&gt;lpfnCallback = lpfnCallback; <br>    lpNotify-&gt;lpvUserContext = lpvUserContext; <br> <br>    // Lock the object against access by other threads. <br> <br>    EnterCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br> <br>    // Cause the callback routine to be called for the first time. <br> <br>    lpNotify-&gt;fFirstTime = TRUE; <br>    hr = HrUpdateAdviseNotify(lpAdviseObj-&gt;lpExtensionData, lpNotify); <br> <br>    // NOTE: Don't check the return value for failure until after  <br>    // we leave the critical section. <br> <br>    // Link the structure into the object's list. <br> <br>    if (SUCCEEDED(hr)) <br>    { <br>        lpNotify-&gt;lpNext = lpAdviseObj-&gt;lpNotifyList; <br>        lpAdviseObj-&gt;lpNotifyList = lpNotify; <br>    } <br> <br>    // Unlock the object to allow access by other threads. <br> <br>    LeaveCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br> <br>cleanup: <br>    if (FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpNotify); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrCfgUnadvise-------------------------------------------------------------- <br>//  End monitoring of an extension data section. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCfgUnadvise(                      // RETURNS: HRESULT <br>    IN  LPADVISEOBJ         lpAdviseObj,    // advise object <br>    IN  LPSTR              lpszSection)    // name of extension data section <br>{ <br>    HRESULT                 hr              = NOERROR; <br>    LPADVISENOTIFY *        lppNotify       = NULL; <br>    BOOL                    fFound          = FALSE; <br> <br>    DEBUGPUBLIC("HrCfgAdvise()\n"); <br> <br>    hr = CHK_HrCfgUnadvise( <br>        lpAdviseObj,  <br>        lpszSection); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Lock the object against access by other threads. <br> <br>    EnterCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br> <br>    // Search the list of ADVISENOTIFY structures for the section name we want. <br> <br>    for ( <br>        lppNotify = &amp;lpAdviseObj-&gt;lpNotifyList;  <br>        *lppNotify;  <br>        lppNotify = &amp;((*lppNotify)-&gt;lpNext)) <br>    { <br>        if (!lstrcmp(lpszSection, (*lppNotify)-&gt;lpszOwnerTag)) <br>        { <br>            // Found it, so destroy it. <br> <br>            hr = HrDestroyAdviseNotify(lppNotify); <br> <br>            fFound = TRUE; <br>            break; <br>        } <br>    } <br> <br>    if (!fFound) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    // Unlock the object to allow access by other threads. <br> <br>    LeaveCriticalSection(&amp;lpAdviseObj-&gt;csCriticalSection); <br> <br>    RETURN(hr); <br>} <br> <br>// <br>// Local Helper Routines <br>// <br> <br>//$--PollThread----------------------------------------------------------------- <br>//  Function that is called as a seperate thread.  It wakes up periodically  <br>//  and polls the extension data sections.  If any have changed, it calls  <br>//  the routine registered for that section. <br>// ----------------------------------------------------------------------------- <br>static DWORD WINAPI PollThread(             // RETURNS: error code <br>    IN  LPVOID          lpvThreadParam)     // pointer to advise object <br>{ <br>    HRESULT             hr                  = NOERROR; <br>LPADVISEOBJ         lpAdviseObj         = lpvThreadParam; <br>    BOOL                fDone               = FALSE; <br>    DWORD               dwStatus            = 0; <br> <br>    DEBUGPRIVATE("PollThread()\n"); <br> <br>    hr = CHK_PollThread( <br>        lpvThreadParam); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Main loop: sleep, poll object. <br> <br>    while (!fDone) <br>    { <br>        // Sleep and wait for the timer. <br> <br>        dwStatus = WaitForSingleObject( <br>            lpAdviseObj-&gt;hPollThreadStop,  <br>            lpAdviseObj-&gt;nPollInterval); <br> <br>switch (dwStatus) <br>{ <br>case WAIT_TIMEOUT: <br>                // Poll the object. <br>                hr = HrCfgPollAdviseObj(lpAdviseObj); <br>                if (FAILED(hr)) <br>                    goto cleanup; <br>                break; <br> <br>case WAIT_OBJECT_0: <br>                // Thread terminate request. <br>fDone = TRUE; <br>break; <br> <br>default: <br>// Some kind of error. <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>} <br>    } <br> <br>cleanup: <br>    return(ERROR_SUCCESS); <br>} <br> <br>//$--HrUpdateAdviseNotify------------------------------------------------------- <br>//  Compare new extension data property with the old one for changes to the  <br>//  blob defined by the ADVISENOTIFY structure.  If it has changed, then call  <br>//  the callback routine.  In any case, point the ADVISENOTIFY structure at the  <br>//  new extension data blob, so that the old one may be freed. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrUpdateAdviseNotify(        // RETURNS: HRESULT <br>    IN      LPSPropValue    lpNewData,      // new extension data <br>    IN OUT  LPADVISENOTIFY  lpNotify)       // notification structure <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    LPSBinary           lpNewBlobArray      = NULL; <br>    ULONG               cNewBlobArray       = 0; <br>    ULONG               iBlob               = 0; <br>    LPBYTE              lpbNewBlob          = NULL; <br>    ULONG               cbNewBlob           = 0; <br>    LPSPropValue        lpUnpackedProps     = NULL; <br>    ULONG               cUnpackedProps      = 0; <br>    LPSTR              lpszUnpackedName    = NULL; <br> <br>    DEBUGPRIVATE("HrUpdateAdviseNotify()\n"); <br> <br>    hr = CHK_HrUpdateAdviseNotify( <br>        lpNewData,  <br>        lpNotify); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Find the owner tag in the new extension data property array. <br> <br>    if (lpNewData) <br>    { <br>        lpNewBlobArray = lpNewData-&gt;Value.MVbin.lpbin; <br>        cNewBlobArray = lpNewData-&gt;Value.MVbin.cValues; <br> <br>        for (iBlob = 0; iBlob &lt; cNewBlobArray; iBlob++) <br>        { <br>            if (!wcscmp( <br>                lpNotify-&gt;lpwszOwnerTag,  <br>                (LPWSTR) lpNewBlobArray[iBlob].lpb)) <br>            { <br>                lpbNewBlob = lpNewBlobArray[iBlob].lpb; <br>                cbNewBlob = lpNewBlobArray[iBlob].cb; <br>            } <br>        } <br>    } <br> <br>    // If the blob has changed then unpack the properties and call the  <br>    // callback routine. <br> <br>    if (lpNotify-&gt;fFirstTime ||  <br>        lpNotify-&gt;cbBlob != cbNewBlob ||  <br>        (lpNotify-&gt;lpbBlob &amp;&amp;  <br>        lpbNewBlob &amp;&amp;  <br>        memcmp(lpNotify-&gt;lpbBlob, lpbNewBlob, cbNewBlob))) <br>    { <br>        // If the new blob exists then unpack the properties. <br>        // Otherwise, use a NULL pointer for a non-existant blob. <br> <br>        if (lpbNewBlob) <br>        { <br>            hr = HrCfgUnpackData( <br>                cbNewBlob,  <br>                lpbNewBlob,  <br>                &amp;lpszUnpackedName,  <br>                &amp;cUnpackedProps,  <br>                &amp;lpUnpackedProps); <br>            if (FAILED(hr)) <br>                goto cleanup; <br>        } <br> <br>        // Call the callback routine. <br> <br>        hr = (*lpNotify-&gt;lpfnCallback)( <br>            lpNotify-&gt;lpvUserContext,  <br>            lpNotify-&gt;lpwszOwnerTag,  <br>            cUnpackedProps,  <br>            lpUnpackedProps); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        // If the callback succeeded then zero out the unpacked property  <br>        // variables so we don't free them (that's the user's responsiblity). <br> <br>        cUnpackedProps = 0; <br>        lpUnpackedProps = NULL; <br> <br>        // Callback has now been called at least once. <br> <br>        lpNotify-&gt;fFirstTime = FALSE; <br>    } <br> <br>    // Replace the old blob with the new one in the ADVISENOTIFY structure. <br> <br>    lpNotify-&gt;lpbBlob = lpbNewBlob; <br>    lpNotify-&gt;cbBlob = cbNewBlob; <br> <br>cleanup: <br>    MAPIFREEBUFFER(lpszUnpackedName); <br>    if (FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpUnpackedProps); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrDestroyAdviseNotify------------------------------------------------------ <br>//  Destroy an ADVISENOTIFY structure and remove it from the linked list. <br>//  This routine takes as its argument the address of a pointer to the  <br>//  structure to be destroyed and returns with that pointer pointing to  <br>//  the next structure in the linked list. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrDestroyAdviseNotify(       // RETURNS: HRESULT <br>    IN OUT  LPADVISENOTIFY * lppNotify)     // address of ptr to ADVISENOTIFY <br>{ <br>    HRESULT             hr                  = NOERROR; <br>    LPADVISENOTIFY      lpNotify            = NULL; <br> <br>    DEBUGPRIVATE("HrDestroyAdviseNotify()\n"); <br> <br>    hr = CHK_HrDestroyAdviseNotify( <br>        lppNotify); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Save pointer to the structure. <br> <br>    lpNotify = *lppNotify; <br> <br>    // Take structure out of list, by making whatever pointed to it point  <br>    // to the next thing on the list. <br> <br>    *lppNotify = lpNotify-&gt;lpNext; <br> <br>    // Free the structure. <br> <br>    MAPIFREEBUFFER(lpNotify); <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
