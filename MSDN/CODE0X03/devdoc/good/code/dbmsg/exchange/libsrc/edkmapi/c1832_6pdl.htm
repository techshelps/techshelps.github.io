<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ITRACE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1839"></a>ITRACE.C</h2>
<pre><code>// --itrace.c------------------------------------------------------------------- <br>//  <br>//  Module containing MAPI utility functions for message traces. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include "itrace.chk" <br> <br>//$--HrTraceGetEntryListSize-------------------------------------------------- <br>//  Get the size of the hop trace information in bytes. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceGetEntryListSize(      // RETURNS: return code <br>    IN LPTRACEINFO lpTraceInfo,         // Pointer to hop trace address variable <br>    OUT ULONG      *lpcbTraceInfo)      // Count of bytes in hop trace list <br>{ <br>    HRESULT hr         = NOERROR; <br>    LPBYTE  lpbFirst   = NULL; <br>    LPBYTE  lpbLast    = NULL; <br>    ULONG   cBytes     = 0; <br>    ULONG   cbExpected = 0; <br>    ULONG   cEntries   = 0; <br> <br>    DEBUGPUBLIC("HrTraceGetEntryListSize()"); <br> <br>    hr = CHK_HrTraceGetEntryListSize( <br>        lpTraceInfo, <br>        lpcbTraceInfo); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpcbTraceInfo = 0; <br> <br>    lpbFirst = (LPBYTE)lpTraceInfo; <br> <br>    cEntries = lpTraceInfo-&gt;cEntries; <br> <br>    lpbLast  = (LPBYTE)&amp;(lpTraceInfo-&gt;rgtraceentry[cEntries]) - 1; <br> <br>    cBytes = ((lpbFirst &lt;= lpbLast) ? (lpbLast-lpbFirst) : (lpbFirst-lpbLast)); <br> <br>    cBytes++; <br> <br>    cbExpected = CbTRACEINFO(lpTraceInfo); <br> <br>    if(cBytes != cbExpected) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    *lpcbTraceInfo = cBytes; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceGetEntryList----------------------------------------------------- <br>//  Get the hop trace information for a given message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceGetEntryList(         // RETURNS: return code <br>    IN LPMESSAGE   lpMessage,           // Pointer to message. <br>    OUT LPTRACEINFO *lppTraceInfo)      // Pointer to hop trace address variable <br>{ <br>    HRESULT hr         = NOERROR; <br>    ULONG   cBytes     = 0; <br>    ULONG   cbExpected = 0; <br> <br>    DEBUGPUBLIC("HrTraceGetEntryList()"); <br> <br>    hr = CHK_HrTraceGetEntryList( <br>        lpMessage, <br>        lppTraceInfo); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppTraceInfo = NULL; <br> <br>    hr = HrMAPIGetPropBinary( <br>        (LPMAPIPROP)lpMessage, <br>        PR_TRACE_INFO, <br>        &amp;cBytes, <br>        (LPVOID *)lppTraceInfo); <br> <br>    if(FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR((*lppTraceInfo)-&gt;cEntries != 0, "ZERO cEntries variable"); <br> <br>    cbExpected = CbTRACEINFO((*lppTraceInfo)); <br> <br>    if(cBytes != cbExpected) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceSetEntryList----------------------------------------------------- <br>//  Set the hop trace information for a given message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceSetEntryList(         // RETURNS: return code <br>    IN LPMESSAGE   lpMessage,           // Pointer to message. <br>    IN LPTRACEINFO lpTraceInfo)         // Pointer to hop trace address variable <br>{ <br>    HRESULT hr         = NOERROR; <br>    ULONG   cBytes     = 0; <br>    ULONG   cbExpected = 0; <br> <br>    DEBUGPUBLIC("HrTraceSetEntryList()"); <br> <br>    hr = CHK_HrTraceSetEntryList( <br>        lpMessage, <br>        lpTraceInfo); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrTraceGetEntryListSize(lpTraceInfo, &amp;cBytes); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    cbExpected = CbTRACEINFO(lpTraceInfo); <br> <br>    if(cBytes != cbExpected) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrMAPISetPropBinary( <br>        (LPMAPIPROP)lpMessage, <br>        PR_TRACE_INFO, <br>        cBytes, <br>        (LPVOID *)lpTraceInfo); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceCopyEntry-------------------------------------------------------- <br>//  Copy trace entry information to a trace entry structure. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceCopyEntry(            // RETURNS: return code <br>    IN LONG     lAction,                // The routing action the tracing site <br>                                        // took. <br>    IN FILETIME ftArrivalTime,          // The time at which the communique <br>                                        // entered the tracing site. <br>    IN FILETIME ftDeferredTime,         // The time are which the tracing site <br>                                        // released the message. <br>    IN LPSTR    lpszADMDName,           // ADMD Name <br>    IN LPSTR    lpszCountryName,        // Country Name <br>    IN LPSTR    lpszPRMDId,             // PRMD Identifier <br>    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name <br>    IN LPSTR    lpszAttCountryName,     // Attempted Country Name <br>    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier <br>    OUT LPTRACEENTRY lpTraceEntry)      // Pointer to trace entry address <br>                                        // variable. <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("HrTraceCopyEntry()"); <br> <br>    hr = CHK_HrTraceCopyEntry( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        lpTraceEntry); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    lpTraceEntry-&gt;lAction = lAction; <br> <br>    lpTraceEntry-&gt;ftArrivalTime = ftArrivalTime; <br> <br>    lpTraceEntry-&gt;ftDeferredTime = ftDeferredTime; <br> <br>    if((lpszADMDName != NULL) &amp;&amp; (strlen(lpszADMDName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchADMDName, lpszADMDName, MAX_ADMD_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchADMDName[MAX_ADMD_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszCountryName != NULL) &amp;&amp; (strlen(lpszCountryName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchCountryName, lpszCountryName, MAX_COUNTRY_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchCountryName[MAX_COUNTRY_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszPRMDId != NULL) &amp;&amp; (strlen(lpszPRMDId) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchPRMDId, lpszPRMDId, MAX_PRMD_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchPRMDId[MAX_PRMD_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszAttADMDName != NULL) &amp;&amp; (strlen(lpszAttADMDName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchAttADMDName, lpszAttADMDName, MAX_ADMD_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchAttADMDName[MAX_ADMD_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszAttCountryName != NULL) &amp;&amp; (strlen(lpszAttCountryName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchAttCountryName, lpszAttCountryName, MAX_COUNTRY_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchAttCountryName[MAX_COUNTRY_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszAttPRMDId != NULL) &amp;&amp; (strlen(lpszAttPRMDId) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchAttPRMDId, lpszAttPRMDId, MAX_PRMD_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchAttPRMDId[MAX_PRMD_NAME_SIZ] = '\0'; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceCreateEntryList-------------------------------------------------- <br>//  Create a hop trace information list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceCreateEntryList(      // RETURNS: return code <br>    IN LONG     lAction,                // The routing action the tracing site <br>                                        // took. <br>    IN FILETIME ftArrivalTime,          // The time at which the communique <br>                                        // entered the tracing site. <br>    IN FILETIME ftDeferredTime,         // The time are which the tracing site <br>                                        // released the message. <br>    IN LPSTR    lpszADMDName,           // ADMD Name <br>    IN LPSTR    lpszCountryName,        // Country Name <br>    IN LPSTR    lpszPRMDId,             // PRMD Identifier <br>    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name <br>    IN LPSTR    lpszAttCountryName,     // Attempted Country Name <br>    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier <br>    OUT LPTRACEINFO *lppTraceInfo)      // Pointer to hop trace address variable <br>{ <br>    HRESULT     hr          = NOERROR; <br>    ULONG       cBytes      = 0; <br>    LPTRACEINFO lpTraceInfo = NULL; <br>    SCODE       sc          = 0; <br> <br>    DEBUGPUBLIC("HrTraceCreateEntryList()"); <br> <br>    hr = CHK_HrTraceCreateEntryList( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        lppTraceInfo); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Allocate a trace entry list <br> <br>    cBytes = CbNewTRACEINFO(1); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)lppTraceInfo); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    // Initialize trace entry list <br>    ZeroMemory(*lppTraceInfo, cBytes); <br> <br>    lpTraceInfo = *lppTraceInfo; <br> <br>    lpTraceInfo-&gt;cEntries = 1; <br> <br>    hr = HrTraceCopyEntry( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        &amp;(lpTraceInfo-&gt;rgtraceentry[0])); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceAppendEntryList-------------------------------------------------- <br>//  Append to an existing hop trace information list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceAppendEntryList(      // RETURNS: return code <br>    IN LONG     lAction,                // The routing action the tracing site <br>                                        // took. <br>    IN FILETIME ftArrivalTime,          // The time at which the communique <br>                                        // entered the tracing site. <br>    IN FILETIME ftDeferredTime,         // The time are which the tracing site <br>                                        // released the message. <br>    IN LPSTR    lpszADMDName,           // ADMD Name <br>    IN LPSTR    lpszCountryName,        // Country Name <br>    IN LPSTR    lpszPRMDId,             // PRMD Identifier <br>    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name <br>    IN LPSTR    lpszAttCountryName,     // Attempted Country Name <br>    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier <br>    IN OUT LPTRACEINFO *lppTraceInfo)   // Pointer to hop trace address variable <br>{ <br>    HRESULT      hr             = NOERROR; <br>    ULONG        i              = 0; <br>    ULONG        cBytes         = 0; <br>    ULONG        cEntries       = 0; <br>    LPTRACEINFO  lpTraceInfo    = NULL; <br>    LPTRACEENTRY lpTraceEntry   = NULL; <br>    LPTRACEINFO  lpNewTraceInfo = NULL; <br>    SCODE        sc             = 0; <br> <br>    DEBUGPUBLIC("HrTraceAppendEntryList()"); <br> <br>    hr = CHK_HrTraceAppendEntryList( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        lppTraceInfo); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Allocate a trace entry list <br> <br>    lpTraceInfo = *lppTraceInfo; <br> <br>    cEntries = lpTraceInfo-&gt;cEntries + 1; <br> <br>    cBytes = CbNewTRACEINFO(cEntries); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)&amp;lpNewTraceInfo); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    // Initialize trace entry list <br>    ZeroMemory(lpNewTraceInfo, cBytes); <br> <br>    lpNewTraceInfo-&gt;cEntries = cEntries; <br> <br>    cEntries--; <br> <br>    for(i = 0; i &lt; cEntries; i++) <br>    { <br>        lpTraceEntry = &amp;(lpTraceInfo-&gt;rgtraceentry[i]); <br> <br>        hr = HrTraceCopyEntry( <br>            lpTraceEntry-&gt;lAction, <br>            lpTraceEntry-&gt;ftArrivalTime, <br>            lpTraceEntry-&gt;ftDeferredTime, <br>            lpTraceEntry-&gt;rgchADMDName, <br>            lpTraceEntry-&gt;rgchCountryName, <br>            lpTraceEntry-&gt;rgchPRMDId, <br>            lpTraceEntry-&gt;rgchAttADMDName, <br>            lpTraceEntry-&gt;rgchAttCountryName, <br>            lpTraceEntry-&gt;rgchAttPRMDId, <br>            &amp;(lpNewTraceInfo-&gt;rgtraceentry[i])); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    hr = HrTraceCopyEntry( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        &amp;(lpNewTraceInfo-&gt;rgtraceentry[cEntries])); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpTraceInfo); <br> <br>    *lppTraceInfo = lpNewTraceInfo; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpNewTraceInfo); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceGotoEntry-------------------------------------------------------- <br>//  Goto the specified TRACEENTRY in a TRACEINFO <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceGotoEntry(            // RETURNS: return code <br>    IN LPTRACEINFO lpTraceInfo,         // pointer to TRACEINFO <br>    IN ULONG ulIndex,                   // index of TRACEENTRY in TRACEINFO <br>    OUT LPTRACEENTRY *lppTraceEntry)    // pointer to TRACEENTRY <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrTraceGotoEntry()"); <br> <br>    hr = CHK_HrTraceGotoEntry( <br>        lpTraceInfo, <br>        ulIndex, <br>        lppTraceEntry); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lppTraceEntry = NULL; <br> <br>    if(ulIndex &lt; lpTraceInfo-&gt;cEntries) <br>    { <br>        *lppTraceEntry = &amp;(lpTraceInfo-&gt;rgtraceentry[ulIndex]); <br>    } <br>    else <br>    { <br>        hr = HR_LOG(EDK_E_NOT_FOUND); <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceGotoFirstEntry--------------------------------------------------- <br>//  Goto the first TRACEENTRY in a TRACEINFO <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceGotoFirstEntry(       // RETURNS: return code <br>    IN LPTRACEINFO lpTraceInfo,         // pointer to TRACEINFO <br>    OUT ULONG *lpulIndex,               // index of TRACEENTRY in TRACEINFO <br>    OUT LPTRACEENTRY *lppTraceEntry)    // pointer to TRACEENTRY <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrTraceGotoFirstEntry()"); <br> <br>    hr = CHK_HrTraceGotoFirstEntry( <br>        lpTraceInfo, <br>        lpulIndex, <br>        lppTraceEntry); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *lpulIndex = 0; <br> <br>    hr = HrTraceGotoEntry( <br>        lpTraceInfo, <br>        0, <br>        lppTraceEntry); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceGotoNextEntry---------------------------------------------------- <br>//  Goto the next TRACEENTRY in a TRACEINFO <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceGotoNextEntry(        // RETURNS: return code <br>    IN LPTRACEINFO lpTraceInfo,         // pointer to TRACEINFO <br>    IN OUT ULONG *lpulIndex,            // index of TRACEENTRY in TRACEINFO <br>    OUT LPTRACEENTRY *lppTraceEntry)    // pointer to TRACEENTRY <br>{ <br>    HRESULT hr      = NOERROR; <br>    ULONG   ulIndex = 0; <br> <br>    DEBUGPUBLIC("HrTraceGotoNextEntry()"); <br> <br>    hr = CHK_HrTraceGotoNextEntry( <br>        lpTraceInfo, <br>        lpulIndex, <br>        lppTraceEntry); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    ulIndex = *lpulIndex; <br> <br>    ulIndex++; <br> <br>    *lpulIndex = ulIndex; <br> <br>    hr = HrTraceGotoEntry( <br>        lpTraceInfo, <br>        ulIndex, <br>        lppTraceEntry); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceOpenEntry-------------------------------------------------------- <br>//  Open a TRACEENTRY. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceOpenEntry(            // RETURNS: return code <br>    IN LPTRACEENTRY lpTraceEntry,       // pointer to TRACEENTRY <br>    OUT LONG     *plAction,             // The routing action the tracing site <br>                                        // took. <br>    OUT FILETIME *pftArrivalTime,       // The time at which the communique <br>                                        // entered the tracing site. <br>    OUT FILETIME *pftDeferredTime,      // The time are which the tracing site <br>                                        // released the message. <br>    OUT LPSTR    *lppszADMDName,        // ADMD Name <br>    OUT LPSTR    *lppszCountryName,     // Country Name <br>    OUT LPSTR    *lppszPRMDId,          // PRMD Identifier <br>    OUT LPSTR    *lppszAttADMDName,     // Attempted ADMD Name <br>    OUT LPSTR    *lppszAttCountryName,  // Attempted Country Name <br>    OUT LPSTR    *lppszAttPRMDId)       // Attempted PRMD Identifier <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPUBLIC("HrTraceOpenEntry()"); <br> <br>    hr = CHK_HrTraceOpenEntry( <br>        lpTraceEntry, <br>        plAction, <br>        pftArrivalTime, <br>        pftDeferredTime, <br>        lppszADMDName, <br>        lppszCountryName, <br>        lppszPRMDId, <br>        lppszAttADMDName, <br>        lppszAttCountryName, <br>        lppszAttPRMDId); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    *plAction               = lpTraceEntry-&gt;lAction; <br>    *pftArrivalTime         = lpTraceEntry-&gt;ftArrivalTime; <br>    *pftDeferredTime        = lpTraceEntry-&gt;ftDeferredTime; <br>    *lppszADMDName          = lpTraceEntry-&gt;rgchADMDName; <br>    *lppszCountryName       = lpTraceEntry-&gt;rgchCountryName; <br>    *lppszPRMDId            = lpTraceEntry-&gt;rgchPRMDId; <br>    *lppszAttADMDName       = lpTraceEntry-&gt;rgchAttADMDName; <br>    *lppszAttCountryName    = lpTraceEntry-&gt;rgchAttCountryName; <br>    *lppszAttPRMDId         = lpTraceEntry-&gt;rgchAttPRMDId; <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceSetInfo---------------------------------------------------------- <br>//  Set the trace-info on a message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceSetInfo(              // RETURNS: return code <br>    IN LONG lAction,                    // pointer to action <br>    IN FILETIME *lpftArrivalTime,       // pointer to arrival time <br>    IN FILETIME *lpftDeferredTime,      // pointer to deferred time <br>    IN LPSTR lpszCountry,               // pointer to country <br>    IN LPSTR lpszADMD,                  // pointer to ADMD <br>    IN LPSTR lpszPRMD,                  // pointer to PRMD <br>    IN OUT LPMESSAGE lpMessage)         // pointer to message <br>{ <br>    HRESULT     hr          = NOERROR; <br>    LPTRACEINFO lpTraceInfo = NULL; <br> <br>    DEBUGPUBLIC("HrTraceSetInfo()"); <br> <br>    hr = CHK_HrTraceSetInfo( <br>        lAction, <br>        lpftArrivalTime, <br>        lpftDeferredTime, <br>        lpszCountry, <br>        lpszADMD, <br>        lpszPRMD, <br>        lpMessage); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrTraceCreateEntryList( <br>        lAction, <br>        *lpftArrivalTime, <br>        *lpftDeferredTime, <br>        lpszADMD, <br>        lpszCountry, <br>        lpszPRMD, <br>        NULL, <br>        NULL, <br>        NULL, <br>        &amp;lpTraceInfo); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    hr = HrTraceSetEntryList( <br>        lpMessage, <br>        lpTraceInfo); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpTraceInfo); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrTraceUpdateInfo------------------------------------------------------- <br>//  Update the trace-info on a message. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrTraceUpdateInfo(           // RETURNS: return code <br>    IN LONG lAction,                    // pointer to action <br>    IN FILETIME *lpftArrivalTime,       // pointer to arrival time <br>    IN FILETIME *lpftDeferredTime,      // pointer to deferred time <br>    IN LPSTR lpszCountry,               // pointer to country <br>    IN LPSTR lpszADMD,                  // pointer to ADMD <br>    IN LPSTR lpszPRMD,                  // pointer to PRMD <br>    IN OUT LPMESSAGE lpMessage)         // pointer to message <br>{ <br>    HRESULT      hr                 = NOERROR; <br>    LPTRACEINFO  lpTraceInfo        = NULL; <br>    LPTRACEENTRY lpTraceEntry       = NULL; <br>    ULONG        index              = 0; <br>    LONG         lCurrAction        = 0; <br>    FILETIME     ftCurrArrivalTime  = {0}; <br>    FILETIME     ftCurrDeferredTime = {0}; <br>    LPSTR       lpszCurrCountry    = NULL; <br>    LPSTR       lpszCurrADMD       = NULL; <br>    LPSTR       lpszCurrPRMD       = NULL; <br>    LPSTR       lpszCurrAttCountry = NULL; <br>    LPSTR       lpszCurrAttADMD    = NULL; <br>    LPSTR       lpszCurrAttPRMD    = NULL; <br> <br>    DEBUGPUBLIC("HrTraceUpdateInfo()"); <br> <br>    hr = CHK_HrTraceUpdateInfo( <br>        lAction, <br>        lpftArrivalTime, <br>        lpftDeferredTime, <br>        lpszCountry, <br>        lpszADMD, <br>        lpszPRMD, <br>        lpMessage); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    hr = HrTraceGetEntryList( <br>        lpMessage, <br>        &amp;lpTraceInfo); <br> <br>    if(FAILED(hr)) <br>    { <br>        if(hr != EDK_E_NOT_FOUND) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    if(hr == EDK_E_NOT_FOUND) <br>    { <br>        hr = HrTraceCreateEntryList( <br>            lAction, <br>            *lpftArrivalTime, <br>            *lpftDeferredTime, <br>            lpszADMD, <br>            lpszCountry, <br>            lpszPRMD, <br>            NULL, <br>            NULL, <br>            NULL, <br>            &amp;lpTraceInfo); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br>    else <br>    { <br>        hr = HrTraceGotoFirstEntry(lpTraceInfo, &amp;index, &amp;lpTraceEntry); <br> <br>        while(SUCCEEDED(hr)) <br>        { <br> <br>            hr = HrTraceOpenEntry( <br>                lpTraceEntry, <br>                &amp;lCurrAction, <br>                &amp;ftCurrArrivalTime, <br>                &amp;ftCurrDeferredTime, <br>                &amp;lpszCurrADMD, <br>                &amp;lpszCurrCountry, <br>                &amp;lpszCurrPRMD, <br>                &amp;lpszCurrAttADMD, <br>                &amp;lpszCurrAttCountry, <br>                &amp;lpszCurrAttPRMD); <br> <br>            if(FAILED(hr)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br> <br>            if( (lstrcmpi(lpszADMD, lpszCurrADMD) == 0) &amp;&amp; <br>                (lstrcmpi(lpszPRMD, lpszCurrPRMD) == 0) &amp;&amp; <br>                (lstrcmpi(lpszCountry, lpszCurrCountry) == 0)) <br>            { <br>                hr = HR_LOG(EDK_E_ALREADY_EXISTS); <br>                goto cleanup; <br> <br>            } <br> <br>            hr = HrTraceGotoNextEntry( <br>                lpTraceInfo, <br>                &amp;index, <br>                &amp;lpTraceEntry); <br> <br>            if((FAILED(hr)) &amp;&amp; (hr != EDK_E_NOT_FOUND)) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>        } <br> <br>        hr = HrTraceAppendEntryList( <br>            lAction, <br>            *lpftArrivalTime, <br>            *lpftDeferredTime, <br>            lpszADMD, <br>            lpszCountry, <br>            lpszPRMD, <br>            NULL, <br>            NULL, <br>            NULL, <br>            &amp;lpTraceInfo); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    hr = HrTraceSetEntryList( <br>        lpMessage, <br>        lpTraceInfo); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpTraceInfo); <br> <br>    RETURN(hr); <br>} <br> <br> <br>//------------------------------------------------------------------------------ <br>// <br>// INTERNAL TRACE INFORMATION FUNCTIONS <br>// <br>//------------------------------------------------------------------------------ <br> <br>//$--HrInternalTraceCopyEntry--------------------------------------------------- <br>//  Copy internal trace entry information to an internal trace entry structure. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInternalTraceCopyEntry(       // RETURNS: return code <br>    IN LONG     lAction,                // The routing action the tracing site <br>                                        // took. <br>    IN FILETIME ftArrivalTime,          // The time at which the communique <br>                                        // entered the tracing site. <br>    IN FILETIME ftDeferredTime,         // The time are which the tracing site <br>                                        // released the message. <br>    IN LPSTR    lpszADMDName,           // ADMD Name <br>    IN LPSTR    lpszCountryName,        // Country Name <br>    IN LPSTR    lpszPRMDId,             // PRMD Identifier <br>    IN LPSTR    lpszMTAName,            // MTA Name <br>    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name <br>    IN LPSTR    lpszAttCountryName,     // Attempted Country Name <br>    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier <br>    IN LPSTR    lpszAttMTAName,         // Attempted MTA Name <br>    OUT PINTTRACEENTRY lpTraceEntry)    // Pointer to trace entry address <br>                                        // variable. <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("HrInternalTraceCopyEntry()"); <br> <br>    hr = CHK_HrInternalTraceCopyEntry( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszMTAName, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        lpszAttMTAName, <br>        lpTraceEntry); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    lpTraceEntry-&gt;lAction = lAction; <br> <br>    lpTraceEntry-&gt;ftArrivalTime = ftArrivalTime; <br> <br>    lpTraceEntry-&gt;ftDeferredTime = ftDeferredTime; <br> <br>    if((lpszADMDName != NULL) &amp;&amp; (strlen(lpszADMDName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchADMDName, lpszADMDName, MAX_ADMD_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchADMDName[MAX_ADMD_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszCountryName != NULL) &amp;&amp; (strlen(lpszCountryName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchCountryName, lpszCountryName, MAX_COUNTRY_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchCountryName[MAX_COUNTRY_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszPRMDId != NULL) &amp;&amp; (strlen(lpszPRMDId) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchPRMDId, lpszPRMDId, MAX_PRMD_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchPRMDId[MAX_PRMD_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszMTAName != NULL) &amp;&amp; (strlen(lpszMTAName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchMTAName, lpszMTAName, MAX_MTA_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchMTAName[MAX_MTA_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszAttADMDName != NULL) &amp;&amp; (strlen(lpszAttADMDName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchAttADMDName, lpszAttADMDName, MAX_ADMD_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchAttADMDName[MAX_ADMD_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszAttCountryName != NULL) &amp;&amp; (strlen(lpszAttCountryName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchAttCountryName, lpszAttCountryName, MAX_COUNTRY_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchAttCountryName[MAX_COUNTRY_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    if((lpszAttPRMDId != NULL) &amp;&amp; (strlen(lpszAttPRMDId) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchAttPRMDId, lpszAttPRMDId, MAX_PRMD_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchAttPRMDId[MAX_PRMD_NAME_SIZ] = '\0'; <br>    } <br> <br>    if((lpszAttMTAName != NULL) &amp;&amp; (strlen(lpszAttMTAName) &gt; 0)) <br>    { <br>        strncpy(lpTraceEntry-&gt;rgchAttMTAName, lpszAttMTAName, MAX_MTA_NAME_SIZ); <br>        lpTraceEntry-&gt;rgchAttMTAName[MAX_MTA_NAME_SIZ-1] = '\0'; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInternalTraceCreateEntryList--------------------------------------------- <br>//  Create a internal hop trace information list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInternalTraceCreateEntryList( // RETURNS: return code <br>    IN LONG     lAction,                // The routing action the tracing site <br>                                        // took. <br>    IN FILETIME ftArrivalTime,          // The time at which the communique <br>                                        // entered the tracing site. <br>    IN FILETIME ftDeferredTime,         // The time are which the tracing site <br>                                        // released the message. <br>    IN LPSTR    lpszADMDName,           // ADMD Name <br>    IN LPSTR    lpszCountryName,        // Country Name <br>    IN LPSTR    lpszPRMDId,             // PRMD Identifier <br>    IN LPSTR    lpszMTAName,            // MTA Name </code></pre>
<p>
</p>
<pre><code>IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name <br>    IN LPSTR    lpszAttCountryName,     // Attempted Country Name <br>    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier <br>    IN LPSTR    lpszAttMTAName,         // Attempted MTA Name <br>    OUT PINTTRACEINFO *lppTraceInfo)    // Pointer to hop trace address variable <br>{ <br>    HRESULT       hr          = NOERROR; <br>    ULONG         cBytes      = 0; <br>    PINTTRACEINFO lpTraceInfo = NULL; <br>    SCODE         sc          = 0; <br> <br>    DEBUGPUBLIC("HrInternalTraceCreateEntryList()"); <br> <br>    hr = CHK_HrInternalTraceCreateEntryList( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszMTAName, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        lpszAttMTAName, <br>        lppTraceInfo); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Allocate a trace entry list <br> <br>    cBytes = CbNewINTTRACEINFO(1); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)lppTraceInfo); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    // Initialize trace entry list <br>    ZeroMemory(*lppTraceInfo, cBytes); <br> <br>    lpTraceInfo = *lppTraceInfo; <br> <br>    lpTraceInfo-&gt;cEntries = 1; <br> <br>    hr = HrInternalTraceCopyEntry( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszMTAName, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        lpszAttMTAName, <br>        &amp;(lpTraceInfo-&gt;rgIntTraceEntry[0])); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrInternalTraceAppendEntryList--------------------------------------------- <br>//  Append to an existing internal hop trace information list. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrInternalTraceAppendEntryList( // RETURNS: return code <br>    IN LONG     lAction,                // The routing action the tracing site <br>                                        // took. <br>    IN FILETIME ftArrivalTime,          // The time at which the communique <br>                                        // entered the tracing site. <br>    IN FILETIME ftDeferredTime,         // The time are which the tracing site <br>                                        // released the message. <br>    IN LPSTR    lpszADMDName,           // ADMD Name <br>    IN LPSTR    lpszCountryName,        // Country Name <br>    IN LPSTR    lpszPRMDId,             // PRMD Identifier <br>    IN LPSTR    lpszMTAName,            // MTA Name <br>    IN LPSTR    lpszAttADMDName,        // Attempted ADMD Name <br>    IN LPSTR    lpszAttCountryName,     // Attempted Country Name <br>    IN LPSTR    lpszAttPRMDId,          // Attempted PRMD Identifier <br>    IN LPSTR    lpszAttMTAName,         // Attempted MTA Name <br>    IN OUT PINTTRACEINFO *lppTraceInfo) // Pointer to hop trace address variable <br>{ <br>    HRESULT        hr             = NOERROR; <br>    ULONG          i              = 0; <br>    ULONG          cBytes         = 0; <br>    ULONG          cEntries       = 0; <br>    PINTTRACEINFO  lpTraceInfo    = NULL; <br>    PINTTRACEENTRY lpTraceEntry   = NULL; <br>    PINTTRACEINFO  lpNewTraceInfo = NULL; <br>    SCODE          sc             = 0; <br> <br>    DEBUGPUBLIC("HrInternalTraceAppendEntryList()"); <br> <br>    hr = CHK_HrInternalTraceAppendEntryList( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszMTAName, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        lpszAttMTAName, <br>        lppTraceInfo); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Allocate a trace entry list <br> <br>    lpTraceInfo = *lppTraceInfo; <br> <br>    cEntries = lpTraceInfo-&gt;cEntries + 1; <br> <br>    cBytes = CbNewINTTRACEINFO(cEntries); <br> <br>    sc = MAPIAllocateBuffer(cBytes, (void **)&amp;lpNewTraceInfo); <br> <br>    if(FAILED(sc))                            <br>    {                                                    <br>        hr = HR_LOG(E_OUTOFMEMORY);                                  <br>        goto cleanup;                                 <br>    }                                                    <br> <br>    // Initialize trace entry list <br>    ZeroMemory(lpNewTraceInfo, cBytes); <br> <br>    lpNewTraceInfo-&gt;cEntries = cEntries; <br> <br>    cEntries--; <br> <br>    for(i = 0; i &lt; cEntries; i++) <br>    { <br>        lpTraceEntry = &amp;(lpTraceInfo-&gt;rgIntTraceEntry[i]); <br> <br>        hr = HrInternalTraceCopyEntry( <br>            lpTraceEntry-&gt;lAction, <br>            lpTraceEntry-&gt;ftArrivalTime, <br>            lpTraceEntry-&gt;ftDeferredTime, <br>            lpTraceEntry-&gt;rgchADMDName, <br>            lpTraceEntry-&gt;rgchCountryName, <br>            lpTraceEntry-&gt;rgchPRMDId, <br>            lpTraceEntry-&gt;rgchMTAName, <br>            lpTraceEntry-&gt;rgchAttADMDName, <br>            lpTraceEntry-&gt;rgchAttCountryName, <br>            lpTraceEntry-&gt;rgchAttPRMDId, <br>            lpTraceEntry-&gt;rgchAttMTAName, <br>            &amp;(lpNewTraceInfo-&gt;rgIntTraceEntry[i])); <br> <br>        if(FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br>    } <br> <br>    hr = HrInternalTraceCopyEntry( <br>        lAction, <br>        ftArrivalTime, <br>        ftDeferredTime, <br>        lpszADMDName, <br>        lpszCountryName, <br>        lpszPRMDId, <br>        lpszMTAName, <br>        lpszAttADMDName, <br>        lpszAttCountryName, <br>        lpszAttPRMDId, <br>        lpszAttMTAName, <br>        &amp;(lpNewTraceInfo-&gt;rgIntTraceEntry[cEntries])); <br> <br>    if(FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    MAPIFREEBUFFER(lpTraceInfo); <br> <br>    *lppTraceInfo = lpNewTraceInfo; <br> <br>cleanup: <br> <br>    if(FAILED(hr)) <br>    { <br>        MAPIFREEBUFFER(lpNewTraceInfo); <br>    } <br> <br>    RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
