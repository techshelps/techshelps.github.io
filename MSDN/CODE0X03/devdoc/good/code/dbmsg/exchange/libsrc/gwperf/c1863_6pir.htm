<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GWPERF.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1863"></a>GWPERF.C</h2>
<pre><code>// --gwperf.c------------------------------------------------------------------- <br>// <br>//  This file contains the DLL side of the Exchange SDK performance  <br>//  monitoring component.  When this DLL is called by the NT Performance  <br>//  Monitor it reads the performance data from a shared memory section  <br>//  created by the gateway side, and returns it to the Performance Monitor. <br>//  This DLL is also capable of reading the data from several different  <br>//  gateway processes and combining them into one single Performance  <br>//  Monitor object with multiple instances. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "monitor.h" <br>#include "monshare.h" <br>#include "gwperfm.h" <br>#include &lt;winperf.h&gt; <br> <br>// <br>// Debugging Information <br>// <br> <br>// Define VERBOSE_DEBUG here to write to the debug log with every call to  <br>// CollectGatewayPerformanceData and the routines it calls.  Do this only  <br>// if you need it, since this routine is called once every second and can  <br>// quickly fill up your disk!!! <br> <br>// #define VERBOSE_DEBUG <br> <br>// <br>// Local Structure Declarations <br>// <br> <br>//$--GINSTANCE------------------------------------------------------------------ <br>//  Holds information about a single gateway instance. <br>// ----------------------------------------------------------------------------- <br>typedef struct _GInstance        // (hungarian notation = gi) <br>{ <br>    BOOL                fOpen;              // TRUE if this instance is open <br>HANDLE              hFileMapping;    // file mapping handle <br>    LONG                cLockReference;     // mutex lock reference count <br>HANDLE              hMutex;    // mutex handle <br>LPMONSHAREDMEMORY   lpmsmMemory;    // shared mem for gw communication <br>    LPWSTR              lpwszName;          // gateway instance name <br>} GINSTANCE, *LPGINSTANCE; <br> <br>//$--GTYPE---------------------------------------------------------------------- <br>//  Holds information about the gateway type that this DLL handles. <br>// ----------------------------------------------------------------------------- <br>typedef struct _GType                       // (hungarian notation = gt) <br>{ <br>    ULONG               cCollectFailures;   // number of times error on collect <br>    ULONG               cInstances;         // number of instances in array <br>    LPGINSTANCE         rggiInstances;      // alloc'd array of instance structs <br>    LONG                iObjectName;        // title index of obj we return <br>} GTYPE, *LPGTYPE; <br> <br>// <br>// Public Function Declarations <br>// <br> <br>PM_OPEN_PROC OpenGatewayPerformanceData; <br>PM_COLLECT_PROC CollectGatewayPerformanceData; <br>PM_CLOSE_PROC CloseGatewayPerformanceData; <br> <br>// <br>// Local Function Declarations <br>// <br> <br>static DWORD CreateGType( <br>    IN  LPWSTR          grwszInstanceNames, <br>    OUT LPGTYPE *       lppgt); <br> <br>static DWORD DestroyGType( <br>    IN OUT  LPGTYPE     lpgt); <br> <br>static DWORD OpenGInstance( <br>    IN      LPWSTR      lpwszInstanceName, <br>    IN OUT  LPGINSTANCE lpgi, <br>    OUT     LPLONG      lpiObjectName); <br> <br>static DWORD CloseGInstance( <br>    IN OUT  LPGINSTANCE lpgi); <br> <br>static DWORD CountMultiStrings( <br>    IN  LPWSTR          grwsz, <br>    OUT LPULONG         pcwsz); <br> <br>static DWORD LockSharedMemory( <br>IN  LPGINSTANCE     lpgi); <br> <br>static DWORD UnlockSharedMemory( <br>IN  LPGINSTANCE     lpgi); <br> <br>static BOOL fOurDataRequested( <br>    IN  LPGTYPE         lpgt, <br>    IN  LPWSTR          lpwszRequest); <br> <br>static VOID ReadSharedMemoryFromRegistry( <br>IN OUT  LPGINSTANCE lpgi); <br> <br>// <br>// Local Constants <br>// <br> <br>static const ULONG MAX_COLLECT_FAILURES = 10; <br> <br>// <br>// Local Variables <br>// <br> <br>static LPGTYPE lpgtContext = NULL; <br> <br>static SECURITY_ATTRIBUTES sa; <br>static char rgbForSecurityDescriptor[SECURITY_DESCRIPTOR_MIN_LENGTH]; <br> <br>static SECURITY_ATTRIBUTES * psa; <br>static SECURITY_DESCRIPTOR * psd; <br> <br>// <br>// DLL Hook Routines <br>// <br> <br>//$--DllEntryPoint------------------------------------------------------------ <br>//  Perform DLL initialization and shutdown.  Returns TRUE if successful,  <br>//  and FALSE if unsuccessful. <br>// --------------------------------------------------------------------------- <br>BOOL WINAPI DllEntryPoint(                  // RETURNS: BOOL <br>    IN  HINSTANCE       hInstDll,           // DLL instance handle <br>    IN  DWORD           fdwReason,          // reason we're being called <br>    IN  LPVOID          lpvReserved)        // reserved <br>{ <br>    BOOL                fResult             = TRUE; <br>    BOOL                fEventLogOpen       = FALSE; <br>    HRESULT             hr                  = NOERROR; <br>    CHAR                szDllPath[MAX_PATH+1] = {0}; <br>    DWORD               cchDllPath          = 0; <br> <br>    DEBUGPUBLIC("DllEntryPoint()\n"); <br> <br>    // Check to see why we were called. <br> <br>    switch (fdwReason) <br>    {         <br>        case DLL_PROCESS_ATTACH: <br> <br>            DEBUGACTION("DLL_PROCESS_ATTACH"); <br> <br>            // Get the path and file name of this DLL. <br> <br>            cchDllPath = GetModuleFileName( <br>                GetInstanceModule(hInstDll),  <br>                szDllPath,  <br>                sizeof(szDllPath) - 1); <br>            if (cchDllPath == 0) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                MODULE_WARNING( <br>                    "GWPERF_DLL_ENTRY_MODULE_NAME: GetModuleFileName() failed."); <br>            } <br> <br>            // If getting the name succeeded then initialize event logging. <br> <br>            else <br>            { <br>                hr = HrEventOpenLog( <br>                    "EDK GWPerf",  <br>                    szDllPath,  <br>                    NULL,  <br>                    NULL,  <br>                    NULL,  <br>                    NULL); <br>                if (FAILED(hr)) <br>                { <br>                    MODULE_WARNING1( <br>                        "GWPERF_DLL_ENTRY_OPEN_LOG: HrEventOpenLog() failed for DLL %s.",  <br>                        szDllPath); <br>                } <br>                else <br>                { <br>                    fEventLogOpen = TRUE; <br>                } <br>            } <br> <br>            // Set up a security descriptor with a NULL DACL, to allow all <br>            // access to an object.  This is used if we need to create the <br>            // mutex and shared memory section.  Failure to do this is a  <br>            // fatal error. <br> <br>            psa = &amp;sa; <br>            psd = (SECURITY_DESCRIPTOR *)rgbForSecurityDescriptor; <br> <br>            if (!InitializeSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION)) <br>            { <br>                EventLogMsg( <br>                    GWPERF_ERROR,  <br>                    0,  <br>                    GetLastError()); <br>                fResult = FALSE; <br>            } <br>            else if (!SetSecurityDescriptorDacl(psd, TRUE, (PACL) NULL, FALSE)) <br>            { <br>                EventLogMsg( <br>                    GWPERF_ERROR,  <br>                    0,  <br>                    GetLastError()); <br>                fResult = FALSE; <br>            } <br>            else <br>            { <br>                psa-&gt;nLength = sizeof(*psa); <br>                psa-&gt;lpSecurityDescriptor = psd; <br>                psa-&gt;bInheritHandle = TRUE; <br>            } <br> <br>            // If there was a fatal error on open, then close the event log. <br> <br>            if (fResult == FALSE &amp;&amp; fEventLogOpen == TRUE) <br>            { <br>                (void) HrEventCloseLog(); <br>                fEventLogOpen = FALSE; <br>            } <br>             <br>            break; <br> <br>        case DLL_THREAD_ATTACH: <br>            DEBUGACTION("DLL_THREAD_ATTACH"); <br>            break; <br> <br>        case DLL_THREAD_DETACH: <br>            DEBUGACTION("DLL_THREAD_DETACH"); <br>            break; <br> <br>        case DLL_PROCESS_DETACH: <br> <br>            DEBUGACTION("DLL_PROCESS_DETACH"); <br> <br>            // Shut down event logging. <br> <br>            hr = HrEventCloseLog(); <br>            if (FAILED(hr)) <br>            { <br>                MODULE_WARNING( <br>                    "GWPERF_DLL_ENTRY_CLOSE_LOG: HrEventCloseLog() failed for DLL %s."); <br>            } <br> <br>            break; <br> <br>        default:             <br> <br>            // Invalid reason. <br> <br>            MODULE_ERROR("GWPERF_DLL_ENTRY_REASON: Invalid reason code."); <br> <br>            fResult = FALSE; <br> <br>            break; <br>    } <br> <br>    ASSERTERROR(fResult, "GWPERF_DLL_ENTRY_FAILED: GWPerf.dll failed to load."); <br>    return fResult; <br>} <br> <br> <br> <br>//$--OpenGatewayPerformanceData------------------------------------------------- <br>//  Function called by the NT Performance Monitor (via the registry) to begin  <br>//  performance monitoring on a gateway. <br>// <br>//  NOTE: In this function, all strings are explicitly WCHAR UNICODE strings  <br>//  because that is what is passed in as device names. <br>// ----------------------------------------------------------------------------- <br>DWORD APIENTRY OpenGatewayPerformanceData(// RETURNS: Win32 error code <br>IN  LPWSTR          grwszInstanceNames)// strings from Linkage\Export <br>{ <br>DWORDdwStatus      = ERROR_SUCCESS; <br> <br>    DEBUGPUBLIC("OpenGatewayPerformanceData()\n"); <br> <br>    // If we're already open then the path to this DLL must exist in multiple  <br>    // Performance keys, which is an error. <br> <br>    if (lpgtContext) <br>    { <br>        dwStatus = ERROR_DLL_INIT_FAILED; <br>        EventLogMsg( <br>            GWPERF_OPEN_ALREADY_OPEN,  <br>            0,  <br>            0); <br>        goto cleanup; <br>    } <br> <br>// If they didn't have a Linkage\Export value then we can't continue. <br> <br>if (grwszInstanceNames == NULL) <br>{ <br>        dwStatus = ERROR_DLL_INIT_FAILED; <br>        EventLogMsg( <br>            GWPERF_OPEN_NO_LINKAGE,  <br>            0,  <br>            0); <br>        goto cleanup; <br>} <br> <br>    // Create the GTYPE structure and begin all the monitoring. <br> <br>    dwStatus = CreateGType(grwszInstanceNames, &amp;lpgtContext); <br>    if (dwStatus) <br>        goto cleanup; <br> <br>cleanup: <br>    return dwStatus; <br>} <br> <br> <br> <br>//$--CollectGatewayPerformanceData---------------------------------------------- <br>//  Function called by the NT Performance Monitor to collect performance data  <br>//  on a gateway.  Always returns either ERROR_SUCCESS or ERROR_MORE_DATA. <br>// ----------------------------------------------------------------------------- <br>DWORD APIENTRY CollectGatewayPerformanceData( // RETURNS: Win32 error code <br>IN      LPWSTR      lpwszRequest,// type of data requested <br>IN OUT  LPVOID *    lppvData,// buffer where data should be put <br>IN OUT  LPDWORD     lpcbBytes,// size of data buffer <br>OUT     LPDWORD     lpcObjectTypes)// number of object types returned <br>{ <br>DWORDdwStatus      = ERROR_SUCCESS; <br> <br>LPBYTE*lppData= (LPBYTE *)lppvData; <br>DWORDigi= 0; <br>LPGINSTANCE        lpgi= NULL; <br>LPMONSHAREDMEMORYlpmsm= NULL; <br>BOOLfPOTCopied= FALSE; <br> <br>LPBYTElpOutBuf= *lppData; <br>LPBYTElpOutBufPtr= *lppData; <br>DWORDcbOutBufSize= *lpcbBytes; <br>BOOLfFoundRunning    = FALSE; <br> <br>PPERF_OBJECT_TYPElpOutPOT= NULL; <br> <br>#ifdef VERBOSE_DEBUG <br>    DEBUGPUBLIC("CollectGatewayPerformanceData()\n"); <br>#endif <br> <br>// Set the return variables to return no data. <br> <br>*lpcbBytes = 0; <br>*lpcObjectTypes = 0; <br>dwStatus = ERROR_SUCCESS; <br> <br>    // If they didn't call open before calling here, then log an  <br>    // error (but only once). <br> <br>    if (lpgtContext == NULL) <br>    { <br>        static BOOL fAlreadyLogged = FALSE; <br> <br>        if (!fAlreadyLogged) <br>        { <br>            EventLogMsg( <br>                GWPERF_COLLECT_NOT_OPEN,  <br>                0,  <br>                0); <br>            fAlreadyLogged = TRUE; <br>        } <br>        goto cleanup; <br>    } <br> <br>    // If we've failed too many times then return with no data. <br> <br>    if (lpgtContext-&gt;cCollectFailures &gt; MAX_COLLECT_FAILURES) <br>    { <br>goto cleanup; <br>    } <br> <br>    // If we know what our object number is, and the request string is not  <br>    // asking for our object number, then return with no data. <br> <br>    if (lpgtContext-&gt;iObjectName != -1 &amp;&amp;  <br>        !fOurDataRequested(lpgtContext, lpwszRequest)) <br>        goto cleanup; <br> <br>// Loop to build the data structure for all instances by appending  <br>// together the structures for each instance.  The new data structure  <br>// is created in the buffer provided by the caller. <br> <br>for (igi = 0; igi &lt; lpgtContext-&gt;cInstances; igi++) <br>{ <br>lpgi = &amp;lpgtContext-&gt;rggiInstances[igi]; <br>lpmsm = lpgi-&gt;lpmsmMemory; <br> <br>// Initial check for valid data.  If not valid here then don't bother  <br>        // locking the mutex.  This keeps us from degrading system performance  <br>        // by locking and unlocking a mutex every time we are called when <br>        // our gateway isn't running. <br> <br>if (!lpmsm-&gt;fDataIsValid) <br>continue; <br>         <br>        // Lock shared memory for gateway instance.  It will be unlocked  <br>        // later.  Any exceptional conditions between now and "later" must  <br>        // call UnlockSharedMemory. <br> <br>dwStatus = LockSharedMemory(lpgi); <br>        if (dwStatus) <br>            goto cleanup; <br> <br>// If this shared memory block doesn't contain valid data then skip it. <br> <br>lpmsm = lpgi-&gt;lpmsmMemory; <br> <br>if (!lpmsm-&gt;fDataIsValid) <br>{ <br>dwStatus = UnlockSharedMemory(lpgi); <br>            if (dwStatus) <br>                goto cleanup; <br>continue; <br>} <br> <br>        // If we don't already have our object number then get it from the  <br>        // shared memory block. <br> <br>        if (lpgtContext-&gt;iObjectName == -1) <br>        { <br>            PPERF_OBJECT_TYPE lpPOT = NULL; <br> <br>            lpPOT = (PPERF_OBJECT_TYPE)  <br>                (((LPBYTE)(lpgi-&gt;lpmsmMemory))  <br>                + lpgi-&gt;lpmsmMemory-&gt;ibHeaderOffset); <br>        lpgtContext-&gt;iObjectName = lpPOT-&gt;ObjectNameTitleIndex; <br> <br>            // Now that we finally know our number, check to make sure it is one  <br>            // of the ones requested. <br> <br>            if (!fOurDataRequested(lpgtContext, lpwszRequest)) <br>            { <br>        dwStatus = UnlockSharedMemory(lpgi); <br>                goto cleanup; <br>            } <br>        } <br>         <br>        // Flag that we found a running gateway instance (i.e. one that has  <br>        // the fDataIsValid flag set). <br> <br>fFoundRunning = TRUE; <br> <br>// Copy PERF_OBJECT_TYPE header structure from the first running  <br>// gateway instance we find. <br> <br>if (!fPOTCopied) <br>{ <br>            // If the buffer isn't big enough then request a larger buffer  <br>            // from the caller. <br> <br>if (lpmsm-&gt;cbHeaderSize &gt; cbOutBufSize) <br>{ <br>    dwStatus = UnlockSharedMemory(lpgi); <br>                if (dwStatus) <br>                    goto cleanup; <br> <br>dwStatus = ERROR_MORE_DATA; <br>goto cleanup; <br>} <br> <br>            // Copy the header. <br> <br>MoveMemory( <br>lpOutBufPtr,  <br>((LPBYTE)(lpmsm)) + lpmsm-&gt;ibHeaderOffset,  <br>lpmsm-&gt;cbHeaderSize); <br>lpOutPOT = (PPERF_OBJECT_TYPE)lpOutBufPtr; <br>lpOutBufPtr += lpmsm-&gt;cbHeaderSize; <br>cbOutBufSize -= lpmsm-&gt;cbHeaderSize; <br> <br>// Start the header's instance count at 0 instances (it will  <br>// be incremented each time we add an instance structure). <br> <br>lpOutPOT-&gt;NumInstances = 0; <br> <br>// Flag that we copied over the PERF_OBJECT_TYPE header structure. <br> <br>fPOTCopied = TRUE; <br>} <br> <br>        // If the buffer isn't big enough then request a larger buffer  <br>        // from the caller. <br> <br>if (lpmsm-&gt;cbInstanceSize &gt; cbOutBufSize) <br>{ <br>dwStatus = UnlockSharedMemory(lpgi); <br>            if (dwStatus) <br>                goto cleanup; <br> <br>dwStatus = ERROR_MORE_DATA; <br>goto cleanup; <br>} <br> <br>// Copy the instance data from this gateway instance. <br> <br>MoveMemory( <br>lpOutBufPtr,  <br>((LPBYTE)(lpmsm)) + lpmsm-&gt;ibInstanceOffset,  <br>lpmsm-&gt;cbInstanceSize); <br>lpOutBufPtr += lpmsm-&gt;cbInstanceSize; <br>cbOutBufSize -= lpmsm-&gt;cbInstanceSize; <br> <br>// Bump up variables in the PERF_OBJECT_TYPE header to reflect  <br>// the addition of this instance. <br> <br>lpOutPOT-&gt;TotalByteLength = lpOutBufPtr - lpOutBuf; <br>lpOutPOT-&gt;NumInstances++; <br> <br>// Unlock the shared memory. <br> <br>dwStatus = UnlockSharedMemory(lpgi); <br>        if (dwStatus) <br>            goto cleanup; <br>} <br> <br>// If we found a running gateway instance then update the return variables. <br> <br>if (fFoundRunning) <br>{ <br>*lpcObjectTypes = 1; <br>*lppData = lpOutBufPtr; <br>*lpcbBytes = lpOutBufPtr - lpOutBuf; <br>} <br> <br>cleanup: <br>    // If there was an error other than ERROR_MORE_DATA, then increment  <br>    // the collect failure count.  When there gets to be too many errors,  <br>    // we will start returning "no data" on every call to collect. <br> <br>    if (dwStatus &amp;&amp; dwStatus != ERROR_MORE_DATA) <br>    { <br>        ++lpgtContext-&gt;cCollectFailures; <br> <br>        if (lpgtContext-&gt;cCollectFailures &gt; MAX_COLLECT_FAILURES) <br>        { <br>            EventLogMsg( <br>                GWPERF_COLLECT_TOO_MANY_FAILURES,  <br>                0,  <br>                0); <br>        } <br> <br>        dwStatus = ERROR_SUCCESS; <br>    } <br> <br>return dwStatus; <br>} <br> <br> <br> <br>//$--CloseGatewayPerformanceData------------------------------------------------ <br>//  Function called by the NT Performance Monitor to end collection of  <br>//  performance data. <br>// ----------------------------------------------------------------------------- <br>DWORD APIENTRY CloseGatewayPerformanceData(// RETURNS: Win32 error code <br>void) <br>{ <br>DWORDdwStatus      = ERROR_SUCCESS; <br> <br>    DEBUGPUBLIC("CloseGatewayPerformanceData()\n"); <br> <br>    // If they didn't call "open" then log an error (but only once). <br> <br>    if (lpgtContext == NULL) <br>    { <br>        static BOOL fAlreadyLogged = FALSE; <br> <br>        if (!fAlreadyLogged) <br>        { <br>            EventLogMsg( <br>                GWPERF_CLOSE_NOT_OPEN,  <br>                0,  <br>                0); <br>            fAlreadyLogged = TRUE; <br>        } <br>        goto cleanup; <br>    } <br> <br>    // Free the gateway type context. <br> <br>    dwStatus = DestroyGType(lpgtContext); <br>    if (dwStatus) <br>        goto cleanup; <br>    lpgtContext = NULL; <br> <br>cleanup: <br>return dwStatus; <br>} <br> <br> <br> <br>//$--CreateGType---------------------------------------------------------------- <br>//  Create a GTYPE structure. <br>// ----------------------------------------------------------------------------- <br>static DWORD CreateGType(                   // RETURNS: Win32 error code <br>    IN  LPWSTR          grwszInstanceNames, // group of instance name strings <br>    OUT LPGTYPE *       lppgt)              // allocated GTYPE structure <br>{ <br>DWORDdwStatus      = ERROR_SUCCESS; <br>    ULONG               cInstances          = 0; <br>LPGINSTANCE        lpgi= NULL; <br>ULONGigi= 0; <br>LPWSTRlpwszInstanceName= NULL; <br>    DWORD               iObjectName         = 0; <br>    LPGTYPE             lpgt                = NULL; <br> <br>    DEBUGPRIVATE("CreateGType()\n"); <br> <br>    // Count the instance name strings passed to us. <br> <br>dwStatus = CountMultiStrings(grwszInstanceNames, &amp;cInstances); <br>    if (dwStatus) <br>        goto cleanup; <br> <br>    // Allocate the GTYPE structure. <br> <br>    lpgt = malloc(sizeof(*lpgt)); <br>    if (lpgt == NULL) <br>    { <br>        dwStatus = ERROR_NOT_ENOUGH_MEMORY; <br>        EventLogMsg( <br>            GWPERF_OPEN_ERROR,  <br>            0,  <br>            1, dwStatus); <br>        goto cleanup; <br>    } <br>ZeroMemory(lpgt, sizeof(*lpgt)); <br> <br>    // Fill in various fields in the GTYPE. <br> <br>    lpgt-&gt;cInstances = cInstances; <br>    lpgt-&gt;iObjectName = -1; <br> <br>// Allocate an array of GINSTANCE's, one for each instance name string. <br> <br>lpgt-&gt;rggiInstances = calloc(cInstances, sizeof(GINSTANCE)); <br>if (lpgt-&gt;rggiInstances == NULL) <br>    { <br>        dwStatus = ERROR_NOT_ENOUGH_MEMORY; <br>        EventLogMsg( <br>            GWPERF_OPEN_ERROR,  <br>            0,  <br>            1, dwStatus); <br>        goto cleanup; <br>    } <br>ZeroMemory(lpgt-&gt;rggiInstances, cInstances * sizeof(GINSTANCE)); <br> <br>// Loop to open the GINSTANCE's. <br> <br>    for ( <br>        igi = 0, lpwszInstanceName = grwszInstanceNames;  <br>        igi &lt; lpgt-&gt;cInstances;  <br>        igi++, lpwszInstanceName += (wcslen(lpwszInstanceName) + 1)) <br>{ <br>lpgi = &amp;lpgt-&gt;rggiInstances[igi]; <br> <br>        // Open this gateway instance. <br> <br>        dwStatus = OpenGInstance(lpwszInstanceName, lpgi, &amp;iObjectName); <br>        if (dwStatus) <br>            goto cleanup; <br> <br>        // If we haven't found the object name title index yet, and  <br>        // one was returned from OpenGInstance, use it. <br> <br>        if (lpgt-&gt;iObjectName == -1) <br>        { <br>            lpgt-&gt;iObjectName = iObjectName; <br>        } <br>} <br> <br>    // Return the pointer to the GTYPE. <br> <br>    *lppgt = lpgt; <br> <br>cleanup: <br>if (dwStatus &amp;&amp; lpgt) <br>    { <br>        (void) DestroyGType(lpgt); <br>    } <br> <br>return dwStatus; <br>} <br> <br> <br> <br>//$--DestroyGType--------------------------------------------------------------- <br>//  Destroy a GTYPE structure (even a partially constructed one). <br>// ----------------------------------------------------------------------------- <br>static DWORD DestroyGType(                  // RETURNS: Win32 error code <br>    IN OUT  LPGTYPE     lpgt)               // allocated GTYPE structure <br>{ <br>DWORDdwStatus      = ERROR_SUCCESS; <br>DWORDdwStatusTemp  = ERROR_SUCCESS; <br>ULONGigi= 0; <br> <br>    DEBUGPRIVATE("DestroyGType()\n"); <br> <br>    if (lpgt) <br>    { <br>        // Loop to close each GINSTANCE. <br> <br>        if (lpgt-&gt;rggiInstances) <br>        { <br>            for (igi = 0; igi &lt; lpgt-&gt;cInstances; igi++) <br>            { <br>                dwStatusTemp = CloseGInstance(&amp;lpgt-&gt;rggiInstances[igi]); <br>                if (dwStatusTemp) <br>                { <br>                    dwStatus = dwStatusTemp; <br>                } <br>            } <br>            FREE(lpgt-&gt;rggiInstances); <br>        } <br> <br>        // Free the GTYPE. <br> <br>        FREE(lpgt); <br>    } <br> <br>    return dwStatus; <br>} <br> <br> <br> <br>//$--OpenGInstance-------------------------------------------------------------- <br>//  Sets up a GINSTANCE structure and maps its shared memory. <br>// ----------------------------------------------------------------------------- <br>static DWORD OpenGInstance(                 // RETURNS: Win32 error code <br>    IN      LPWSTR      lpwszInstanceName,  // name of gateway instance <br>    IN OUT  LPGINSTANCE lpgi,               // instance struct to fill in <br>    OUT     LPLONG      lpiObjectName)      // obj title name index for instance <br>                                            // (-1 = it doesn't have valid data) <br>{ <br>DWORDdwStatus      = ERROR_SUCCESS; <br>LONG                cchOutSize          = 0; <br>    PPERF_OBJECT_TYPE   lpPOT               = NULL; <br>WCHARwszMappingName[MAX_PATH] = {0}; <br>WCHARwszMutexName[MAX_PATH] = {0}; <br>    LONG                iObjectName         = -1; <br> <br>    DEBUGPRIVATE("OpenGInstance()\n"); <br> <br>    // Initially assume the instance is not locked. <br> <br>    lpgi-&gt;cLockReference = 0; <br> <br>    // Add an allocated copy of the instance name to the GINSTANCE structure. <br> <br>    lpgi-&gt;lpwszName = _wcsdup(lpwszInstanceName); <br>    if (lpgi-&gt;lpwszName == NULL) <br>    { <br>        dwStatus = ERROR_NOT_ENOUGH_MEMORY; <br>        EventLogMsg( <br>            GWPERF_OPEN_ERROR,  <br>            0,  <br>            1, dwStatus); <br>        goto cleanup; <br>    } <br> <br>    // Create the name of the mutex. <br> <br>cchOutSize = wsprintfW( <br>wszMutexName,  <br>MON_MUTEX_NAME_TEMPLATE_W,  <br>lpwszInstanceName); <br> <br>    if ((cchOutSize + 1) * sizeof(CHAR) &gt; sizeof(wszMutexName)) <br>    { <br>        dwStatus = ERROR_BUFFER_OVERFLOW; <br>        EventLogMsg( <br>            GWPERF_OPEN_ERROR,  <br>            0,  <br>            1, dwStatus); <br>        goto cleanup; <br>    } <br> <br>(void) CharUpperW(wszMutexName); <br> <br>    // Create the name of the shared memory mapping. <br> <br>cchOutSize = wsprintfW( <br>wszMappingName,  <br>MON_MAPPING_NAME_TEMPLATE_W,  <br>lpwszInstanceName); <br> <br>    if ((cchOutSize + 1) * sizeof(CHAR) &gt; sizeof(wszMappingName)) <br>    { <br>        dwStatus = ERROR_BUFFER_OVERFLOW; <br>        EventLogMsg( <br>            GWPERF_OPEN_ERROR,  <br>            0,  <br>            1, dwStatus); <br>        goto cleanup; <br>    } <br> <br>(void) CharUpperW(wszMappingName); <br> <br>// First try to open the mutex and get ownership. <br> <br>lpgi-&gt;hMutex = OpenMutexW( <br>    MUTEX_ALL_ACCESS,  <br>    FALSE,  <br>    wszMutexName); <br>if (lpgi-&gt;hMutex) <br>    { <br>        dwStatus = LockSharedMemory(lpgi); <br>        if (dwStatus) <br>            goto cleanup; <br>    } <br> <br>    // If the mutex didn't exist then create it and get ownership. <br> <br>    else <br>{ <br>        dwStatus = GetLastError(); <br>        if (dwStatus != ERROR_FILE_NOT_FOUND) <br>        { <br>            EventLogMsg( <br>                GWPERF_OPEN_ERROR,  <br>                0,  <br>                1, dwStatus); <br>            goto cleanup; <br>        } <br> <br>        lpgi-&gt;hMutex = CreateMutexW( <br>            psa,  <br>            TRUE,  <br>            wszMutexName); <br>        if (lpgi-&gt;hMutex == NULL) <br>        { <br>            dwStatus = GetLastError(); <br>            EventLogMsg( <br>                GWPERF_OPEN_ERROR,  <br>                0,  <br>                1, dwStatus); <br>            goto cleanup; <br>        } <br>        lpgi-&gt;cLockReference++; <br>} <br> <br>    // First try to open the shared memory mapping. <br> <br>lpgi-&gt;hFileMapping = OpenFileMappingW( <br>    FILE_MAP_WRITE,  <br>    FALSE,  <br>    wszMappingName); <br> <br>    // If the shared memory mapping didn't exist then create it. <br> <br>if (lpgi-&gt;hFileMapping == NULL) <br>{ <br>dwStatus = GetLastError(); <br>        if (dwStatus != ERROR_FILE_NOT_FOUND) <br>        { <br>            EventLogMsg( <br>                GWPERF_OPEN_ERROR,  <br>                0,  <br>                1, dwStatus); <br>    goto cleanup; <br>        } <br> <br>    lpgi-&gt;hFileMapping = CreateFileMappingW( <br>    (HANDLE)0xFFFFFFFF, // create in paging file <br>    psa, // no security <br>    PAGE_READWRITE, // read/write access <br>    0, // size (high) <br>    sizeof(MONSHAREDMEMORY), // size(low) <br>    wszMappingName);// mapping object name <br> <br>    if (lpgi-&gt;hFileMapping == NULL) <br>    { <br>    dwStatus = GetLastError(); <br>            EventLogMsg( <br>                GWPERF_OPEN_ERROR,  <br>                0,  <br>                1, dwStatus); <br>    goto cleanup; <br>    } <br>} <br> <br>// Map a view of the shared memory file. <br> <br>lpgi-&gt;lpmsmMemory = MapViewOfFile( <br>lpgi-&gt;hFileMapping,  <br>FILE_MAP_WRITE,  <br>0, 0, 0); <br>if (lpgi-&gt;lpmsmMemory == NULL) <br>{ <br>        dwStatus = GetLastError(); <br> <br>        EventLogMsg( <br>            GWPERF_OPEN_ERROR,  <br>            0,  <br>            1, dwStatus); <br>        goto cleanup; <br>} <br> <br>    // If the signature isn't correct then we have a version mismatch. <br>    // (0 probably means it hasn't been fully created yet). <br> <br>    if (lpgi-&gt;lpmsmMemory-&gt;dwSignature != MON_SHARED_MEMORY_SIGNATURE &amp;&amp;  <br>        lpgi-&gt;lpmsmMemory-&gt;dwSignature != 0) <br>    { <br>        EventLogMsgW( <br>            GWPERF_VERSION_MISMATCH,  <br>            1, lpwszInstanceName,  <br>            0); <br>        dwStatus = ERROR_DLL_INIT_FAILED; <br>        goto cleanup; <br>    } <br> <br>    // If there is no valid data in the shared memory section then try  <br>    // to read it from the registry where the gateway saved it the last  <br>    // time it was started.  If there was an error then the shared memory  <br>    // fDataIsValid flag is returned as FALSE. <br> <br>    if (!lpgi-&gt;lpmsmMemory-&gt;fDataIsValid) <br>    { <br>        ReadSharedMemoryFromRegistry(lpgi); <br> <br>        // Check the signature again because we just read it in. <br> <br>        if (lpgi-&gt;lpmsmMemory-&gt;dwSignature != MON_SHARED_MEMORY_SIGNATURE &amp;&amp;  <br>            lpgi-&gt;lpmsmMemory-&gt;dwSignature != 0) <br>        { <br>            EventLogMsgW( <br>                GWPERF_VERSION_MISMATCH,  <br>                1, lpwszInstanceName,  <br>                0); <br>            dwStatus = ERROR_DLL_INIT_FAILED; <br>            goto cleanup; <br>        } <br>    } <br> <br>    // If there is valid data in the shared memory section then get the  <br>    // object name title index from it. <br> <br>    if (lpgi-&gt;lpmsmMemory-&gt;fDataIsValid) <br>    { <br>        lpPOT = (PPERF_OBJECT_TYPE) (((LPBYTE)(lpgi-&gt;lpmsmMemory))  <br>            + lpgi-&gt;lpmsmMemory-&gt;ibHeaderOffset); <br>    iObjectName = lpPOT-&gt;ObjectNameTitleIndex; <br>    } <br> <br>    // Unlock the mutex. <br> <br>    dwStatus = UnlockSharedMemory(lpgi); <br>    if (dwStatus) <br>        goto cleanup; <br> <br>    // Flag that the instance is open. <br> <br>lpgi-&gt;fOpen = TRUE; <br> <br>    // Return the object name title index. <br> <br>    *lpiObjectName = iObjectName; <br> <br>cleanup: <br>    // If we had an error then close the GINSTANCE and return the error code. <br> <br>    if (dwStatus) <br>    { <br>        (void) CloseGInstance(lpgi); <br>    } <br> <br>    return dwStatus; <br>} <br> <br> <br> <br>//$--CloseGInstance------------------------------------------------------------- <br>//  Closes a GINSTANCE structure, closes handles, unmaps shared memory, etc.  <br>//  (even a partially opened one). <br>// ----------------------------------------------------------------------------- <br>static DWORD CloseGInstance(                // RETURNS: Win32 error code <br>    IN OUT  LPGINSTANCE lpgi)               // instance struct to fill in <br>{ <br>DWORDdwStatus      = ERROR_SUCCESS; <br>DWORDdwStatusTemp  = ERROR_SUCCESS; <br>    BOOL                fItWorked           = TRUE; <br> <br>    DEBUGPRIVATE("CloseGInstance()\n"); <br> <br>    // Free the allocated instance name. <br> <br>    FREE(lpgi-&gt;lpwszName); </code></pre>
<p>
</p>
<pre><code><br>    // Release and close the shared memory mutex. <br> <br>if (lpgi-&gt;hMutex) <br>{ <br>        // Release the mutex lock. <br> <br>        while (lpgi-&gt;cLockReference &gt; 0) <br>        { <br>            dwStatusTemp = UnlockSharedMemory(lpgi); <br>            if (dwStatusTemp) <br>            { <br>                dwStatus = dwStatusTemp; <br>                break; <br>            } <br>        } <br> <br>        // Close the handle to the mutex. <br> <br>fItWorked = CloseHandle(lpgi-&gt;hMutex); <br>if (!fItWorked) <br>{ <br>            dwStatus = GetLastError(); <br>            EventLogMsg( <br>                GWPERF_ERROR,  <br>                0,  <br>                1, dwStatus); <br>} <br>lpgi-&gt;hMutex = NULL; <br>} <br> <br>    // Unmap the view of the shared memory. <br> <br>if (lpgi-&gt;lpmsmMemory) <br>{ <br>fItWorked = UnmapViewOfFile(lpgi-&gt;lpmsmMemory); <br>if (!fItWorked) <br>{ <br>            dwStatus = GetLastError(); <br>            EventLogMsg( <br>                GWPERF_ERROR,  <br>                0,  <br>                1, dwStatus); <br>} <br>lpgi-&gt;lpmsmMemory = NULL; <br>} <br> <br>    // Close the file mapping handle. <br> <br>if (lpgi-&gt;hFileMapping) <br>{ <br>fItWorked = CloseHandle(lpgi-&gt;hFileMapping); <br>if (!fItWorked) <br>{ <br>            dwStatus = GetLastError(); <br>            EventLogMsg( <br>                GWPERF_ERROR,  <br>                0,  <br>                1, dwStatus); <br>} <br>lpgi-&gt;hFileMapping = NULL; <br>} <br> <br>    // Zero out the GINSTANCE structure (which will also clear the fOpen flag). <br> <br>    ZeroMemory(lpgi, sizeof(*lpgi)); <br> <br>    return dwStatus; <br>} <br> <br> <br> <br>//$--CountMultiStrings---------------------------------------------------------- <br>//  Returns the number of null terminated strings in a group of word strings. <br>//  A group of word strings consists of zero or more null-terminated word  <br>//  strings followed by a null word. <br>// ----------------------------------------------------------------------------- <br>static DWORD CountMultiStrings(             // RETURNS: Win32 error code <br>    IN  LPWSTR          grwsz,              // group of strings to count <br>    OUT LPULONG         pcwsz)              // number of strings found <br>{ <br>    DWORD               dwStatus            = ERROR_SUCCESS; <br>LPWSTR    pwsz        = NULL; <br> <br>    DEBUGPRIVATE("CountMultiStrings()\n"); <br> <br>    *pcwsz = 0; <br>    for (pwsz = grwsz; *pwsz; pwsz += (wcslen(pwsz) + 1)) <br>{ <br>        (*pcwsz)++; <br>    } <br> <br>    return dwStatus; <br>} <br> <br> <br> <br>//$--LockSharedMemory----------------------------------------------------------- <br>//  Locks the mutex associated with a shared memory block. <br>// ----------------------------------------------------------------------------- <br>static DWORD LockSharedMemory(        // RETURNS: Win32 error code <br>IN  LPGINSTANCE     lpgi)        // gateway instance to lock <br>{ <br>    DWORD               dwStatus             = ERROR_SUCCESS; <br>    DWORD               dwWaitStatus         = 0; <br> <br>#ifdef VERBOSE_DEBUG <br>    DEBUGPRIVATE("LockSharedMemory()\n"); <br>#endif <br> <br>    // Lock the mutex. <br> <br>dwWaitStatus = WaitForSingleObject(lpgi-&gt;hMutex, MON_MUTEX_TIMEOUT); <br>    switch (dwWaitStatus) <br>    { <br>        // Failed--log and return error. <br> <br>        case WAIT_FAILED: <br>            dwStatus = GetLastError(); <br>            EventLogMsg( <br>                GWPERF_ERROR,  <br>                0,  <br>                1, dwStatus); <br>            goto cleanup; <br> <br>        // Timed out--log and return error. <br> <br>        case WAIT_TIMEOUT: <br>            dwStatus = ERROR_DLL_INIT_FAILED; <br>            EventLogMsgW( <br>                GWPERF_MUTEX_TIMEOUT,  <br>                1, lpgi-&gt;lpwszName,  <br>                0); <br>            goto cleanup; <br> <br>        // Success--increment the reference count. <br> <br>        default: <br>            ++lpgi-&gt;cLockReference; <br>            break; <br>    } <br> <br>cleanup: <br>    return dwStatus; <br>} <br> <br> <br> <br>//$--UnlockSharedMemory--------------------------------------------------------- <br>//  Unlocks the mutex associated with a shared memory block. <br>// ----------------------------------------------------------------------------- <br>static DWORD UnlockSharedMemory(        // RETURNS: Win32 error code <br>IN  LPGINSTANCE     lpgi)    // gateway instance to unlock <br>{ <br>    DWORD               dwStatus            = ERROR_SUCCESS; <br>BOOL         fItWorked     = FALSE; <br> <br>#ifdef VERBOSE_DEBUG <br>    DEBUGPRIVATE("UnlockSharedMemory()\n"); <br>#endif <br> <br>    // Don't unlock more than we lock. <br> <br>    if (lpgi-&gt;cLockReference &gt; 0) <br>    { <br>        // Unlock the mutex. <br> <br>    fItWorked = ReleaseMutex(lpgi-&gt;hMutex); <br>    if (!fItWorked) <br>        { <br>            dwStatus = GetLastError(); <br>            EventLogMsg( <br>                GWPERF_ERROR,  <br>                0,  <br>                1, dwStatus); <br>            goto cleanup; <br>        } <br> <br>        // Decrement the reference count. <br> <br>        --lpgi-&gt;cLockReference; <br>    } <br> <br>cleanup: <br>    return dwStatus; <br>} <br> <br> <br> <br>//$--fOurDataRequested---------------------------------------------------------- <br>//  Returns TRUE if the value request string is requesting our data. <br>// ----------------------------------------------------------------------------- <br>static BOOL fOurDataRequested(    // RETURNS: TRUE=yes, FALSE=no <br>    IN  LPGTYPE         lpgt,               // gateway type structure <br>    IN  LPWSTR          lpwszRequest)// perfomance data request string <br>{ <br>BOOL                fReturn             = FALSE; <br>LPWSTR        lpwszOldPtr        = NULL; <br>LONG        iObjectName        = 0; <br> <br>    DEBUGPRIVATE("fOurDataRequested()\n"); <br> <br>// If they requested "Global", "Costly" or an empty string then  <br>// they want our data. <br> <br>    if (*lpwszRequest == 0 ||  <br>    !wcscmp(lpwszRequest, L"Global") ||  <br>    !wcscmp(lpwszRequest, L"Costly")) <br>{ <br>fReturn = TRUE; <br>        goto cleanup; <br>} <br> <br>    // If they requested "Foreign" then they don't want our data. <br> <br>if (!wcscmp(lpwszRequest, L"Foreign")) <br>{ <br>fReturn = FALSE; <br>        goto cleanup; <br>} <br> <br>    // Search the list for our number. <br> <br>    fReturn = FALSE; <br>while (lpwszRequest != lpwszOldPtr) <br>{ <br>lpwszOldPtr = lpwszRequest; <br> <br>iObjectName = wcstol(lpwszRequest, &amp;lpwszRequest, 10); <br> <br>if (iObjectName == lpgt-&gt;iObjectName &amp;&amp;  <br>lpwszRequest != lpwszOldPtr) <br>{ <br>fReturn = TRUE; <br>goto cleanup; <br>} <br>} <br> <br>cleanup: <br>return fReturn; <br>} <br> <br> <br> <br>//$--ReadSharedMemoryFromRegistry----------------------------------------------- <br>//  Read the default shared memory data from the registry, where it was stored  <br>//  the last time the gateway started.    If there was an error then the shared  <br>//  memory fDataIsValid flag is returned as FALSE. <br>// ----------------------------------------------------------------------------- <br>static VOID ReadSharedMemoryFromRegistry(// RETURNS: nothing <br>IN OUT  LPGINSTANCE lpgi)    // gateway instance to unlock <br>{ <br>    DWORD               dwStatus            = ERROR_SUCCESS; <br>BOOL         fItWorked     = FALSE; <br>CHAR        szKeyName[MAX_PATH] = {0}; <br>HKEY        hKey    = NULL; <br>DWORD        cch    = 0; <br>DWORD        dwType              = 0; <br>    DWORD               cbData              = 0; <br> <br>    DEBUGPRIVATE("ReadSharedMemoryFromRegistry()\n"); <br> <br>    // Zero out the shared memory section first. <br> <br>    ZeroMemory(lpgi-&gt;lpmsmMemory,  sizeof(*(lpgi-&gt;lpmsmMemory))); <br> <br>    // Create the registry key name from the gateway instance name. <br> <br>cch = sprintf( <br>szKeyName,  <br>"SYSTEM\\CurrentControlSet\\Services\\%S\\Parameters",  <br>lpgi-&gt;lpwszName); <br>ASSERTERROR( <br>(cch * sizeof(*szKeyName)) &lt; sizeof(szKeyName),  <br>"wsprintf overflow: szKeyName"); <br> <br>// Open the registry key. <br> <br>dwStatus = RegOpenKeyEx( <br>HKEY_LOCAL_MACHINE,  <br>szKeyName,  <br>0L,  <br>KEY_READ,  <br>&amp;hKey); <br>if (dwStatus != ERROR_SUCCESS) <br>    { <br>        EventLogMsg( <br>            GWPERF_OPEN_DEFAULT_COUNTERS,  <br>            1, szKeyName,  <br>            1, dwStatus); <br>goto cleanup; <br>    } <br> <br>    // Read the value into the shared memory section. <br> <br>    cbData = sizeof(*(lpgi-&gt;lpmsmMemory)); <br> <br>    dwStatus = RegQueryValueEx( <br>        hKey,  <br>        "ObjectDefaultPerformanceData",  <br>        NULL,  <br>        &amp;dwType,  <br>        (LPBYTE) lpgi-&gt;lpmsmMemory,  <br>        &amp;cbData); <br>     <br>    // If it is not found then log a message telling the user to run the  <br>    // gateway once first. <br> <br>    if (dwStatus == ERROR_FILE_NOT_FOUND) <br>    { <br>        EventLogMsgW( <br>            GWPERF_NO_DEFAULT_COUNTERS,  <br>            1, lpgi-&gt;lpwszName,  <br>            0); <br>goto cleanup; <br>    } <br>     <br>    if (dwStatus != ERROR_SUCCESS) <br>    { <br>        EventLogMsg( <br>            GWPERF_READ_DEFAULT_COUNTERS,  <br>            1, szKeyName,  <br>            1, dwStatus); <br>goto cleanup; <br>    } <br>     <br>    if (dwType != REG_BINARY) <br>    { <br>        EventLogMsg( <br>            GWPERF_DEFAULT_COUNTERS_WRONG_TYPE,  <br>            1, szKeyName,  <br>            0); <br>        dwStatus = ERROR_FILE_NOT_FOUND; <br>goto cleanup; <br>    } <br> <br>cleanup: <br>// Close the registry key (if it's open). <br> <br>if (hKey) <br>{ <br>dwStatus = RegCloseKey(hKey); <br>        if (dwStatus != ERROR_SUCCESS) <br>        { <br>            EventLogMsg( <br>                GWPERF_CLOSE_DEFAULT_COUNTERS,  <br>                1, szKeyName,  <br>                1, dwStatus); <br> <br>            // We can ignore an error here. <br> <br>            dwStatus = ERROR_SUCCESS; <br>        } <br>} <br> <br>    // If it didn't work, then clear out the shared memory, mark it  <br>    // as having no valid data and continue on. <br> <br>    if (dwStatus) <br>    { <br>        ZeroMemory(lpgi-&gt;lpmsmMemory,  sizeof(*(lpgi-&gt;lpmsmMemory))); <br> <br>        lpgi-&gt;lpmsmMemory-&gt;fDataIsValid = FALSE; <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
