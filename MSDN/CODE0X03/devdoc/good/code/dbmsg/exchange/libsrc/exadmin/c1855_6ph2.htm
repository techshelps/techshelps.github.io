<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HELPERS.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1856"></a>HELPERS.H</h2>
<pre><code>// ----------------------------------------------------------------------------- <br>// Helpers.h: Template Class that wraps MAPI buffers or interfaces so that you <br>//            don't have to concern yourself with freeing or releasing them. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#ifndef _HELPERS_H_ <br>#define _HELPERS_H_ <br> <br>// ----------------------------------------------------------------------------- <br>// Use this class to wrap a pointer to a mapi buffer.  It will automaticly get  <br>// freed when it goes out of scope.  Use the instance of this just as you would <br>// its base type.  Example: <br>//     CMAPIBuffer&lt; LPENTRYID&gt;  lpeid; <br>//     HRESULT hr = HrMAPIFindDefaultMsgStore( m_pMAPISession, &amp;cbeid, &amp;lpeid); <br>//     hr = m_pMAPISession-&gt;OpenMsgStore( 0, cbeid, lpeid, ... <br>// <br>// The intended use of this class is for declaring mapi buffer pointers on the <br>// stack or inside of another class or structure.  There is NO value in creating <br>// an instance of this class on the heap with new().  It's sole purpose in life <br>// is to keep you from having to remember to free the buffer. <br>// <br>// If you need to reuse the pointer be sure to call MAPIFREEBUFFER before  <br>// reusing it.  Example: <br>//     CMAPIBuffer&lt; LPENTRYID&gt;  lpeid; <br>//     HRESULT hr = HrMAPIFindDefaultMsgStore( m_pMAPISession, &amp;cbeid, &amp;lpeid); <br>//     ... // Do some other work...  <br>//     MAPIFREEBUFFER( lpeid); <br>//     hr = HrGetSomeOtherEID( &amp;cbeid, &amp;lpeid); <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class TYPE&gt; <br>class CMAPIBuffer <br>{ <br>public: <br>    CMAPIBuffer( TYPE ptr = NULL)   { m_ptr = ptr;} <br>    ~CMAPIBuffer()                  { MAPIFREEBUFFER( m_ptr);} <br> <br>    // Returns a pointer to the TYPE by just specifying the object. <br>    operator TYPE() {return( m_ptr);} <br> <br>    // Returns the address of the object correct for the base type. <br>    TYPE* operator &amp;() {return( &amp;m_ptr);} <br> <br>    void operator =(LPVOID lpv)  {m_ptr = (TYPE) lpv;} <br> <br>protected: <br>    TYPE m_ptr; <br>}; <br> <br>// ----------------------------------------------------------------------------- <br>// Use this class to wrap a pointer to a mapi interface.  It is nearly identical <br>// to the above class except that it releases the interface pointer when the  <br>// instance of the object goes out of scope. <br>// <br>// The intended use of this class is for declaring mapi interface pointers on the <br>// stack or inside of another class or structure.  There is NO value in creating <br>// an instance of this class on the heap with new().  It's sole purpose in life <br>// is to keep you from having to remember to release the interface. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class TYPE&gt; <br>class CMAPIInterface <br>{ <br>public: <br>    CMAPIInterface( TYPE ptr = NULL)   { m_ptr = ptr;} <br>    ~CMAPIInterface()                  { ULRELEASE( m_ptr);} <br> <br>    // Returns a pointer to the TYPE by just specifying the object. <br>    operator TYPE()         {return( m_ptr);} <br> <br>    // Returns the address of the object correct for the base type. <br>    TYPE* operator &amp;() {return( &amp;m_ptr);} <br> <br>    // Returns a pointer to the TYPE for -&gt; operations. <br>    TYPE operator -&gt;()      {return( m_ptr);} <br> <br>    void operator =(LPVOID lpv)  {m_ptr = (TYPE) lpv;} <br> <br>protected: <br>    TYPE m_ptr; <br>}; <br> <br>// $--CMAPIIsInitialized-------------------------------------------------------- <br>// Initialize MAPI using MAPIInitialize().  If it is successful then create an <br>// instance of this object which will uninitialize MAPI at destruction. <br>// ----------------------------------------------------------------------------- <br> <br>class CMAPIIsInitialized <br>{ <br>public: <br>    ~CMAPIIsInitialized()     {MAPIUninitialize();} <br>}; <br> <br>// $--CMAPISession-------------------------------------------------------------- <br>// Works just like CMAPIInterface but it also Logs off at destruction. <br>// ----------------------------------------------------------------------------- <br> <br>class CMAPISession : public CMAPIInterface&lt; LPMAPISESSION&gt; <br>{ <br>public: <br>    // DESTRUCTOR logs off of the MAPI session and releases the session handle. <br>    ~CMAPISession()  <br>    { <br>        if( m_ptr) <br>            m_ptr-&gt;Logoff( 0L, 0L, 0L); <br>    } <br>}; <br> <br>// ----------------------------------------------------------------------------- <br> <br>#endif // _HELPERS_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
