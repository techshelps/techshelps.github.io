<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VSOP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1854"></a>VSOP.CPP</h2>
<pre><code>//--vsop.cpp--------------------------------------------------------------- <br>// <br>// Stream wrapper class for large MAPI properties. <br>// <br>// Copyright (C) Microsoft Corp, 1986-1996.  All rights reserved. <br>// <br>//----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "_vsop.h" <br>#include "vsop.chk" <br> <br>//$--HrOpenVirtualStreamOnProperty------------------------------------------ <br>// <br>// DESCRIPTION: <br>// API to open a buffered stream on a binary or string property <br>// Callable from "C" or "C++" <br>// <br>// INPUT:pPropObject--MAPI property object pointer <br>//ulPropTag--property tag to open stream on <br>//ulFlags--MAPI property flags (MAPI_MODIFY, MAPI_CREATE) <br>// <br>// OUTPUT:ppVirtualStreamOnProperty-- pointer to buffered stream on property <br>// <br>// RETURNS:HRESULT--NOERROR if successful, <br>//E_INVALIDARG if bad input, <br>//E_OUTOFMEMORY if memory problems, <br>//E_FAIL otherwise <br>// <br>//----------------------------------------------------------------------------- <br>STDAPI HrOpenVirtualStreamOnProperty( <br>    IN LPMAPIPROP pPropObject,// MAPI property object pointer <br>    IN ULONG ulPropTag,     // property tag to open virtual stream on <br>IN ULONG ulFlags,// MAPI property flags <br>    OUT PVIRTUALSTREAMONPROPERTY * ppVirtualStreamOnProperty)  // pointer buffered stream <br>{ <br>// Implemented by local C++ function _HrOpenVirtualStreamOnProperty(). <br>// Doing this allows us to declare _HrOpenVirtualStreamOnProperty() as <br>// a friend of the CEDKVitrualStreamOnProperty class. <br>RETURN(_HrOpenVirtualStreamOnProperty(pPropObject, ulPropTag, ulFlags, ppVirtualStreamOnProperty)); <br>} <br> <br>//$--_HrOpenVirtualStreamOnProperty--------------------------------------------- <br>// <br>// DESCRIPTION:  same as for _HrOpenVirtualStreamOnProperty, but its a local <br>// C++ function instead of an exported "C" function. <br>// <br>// INPUT:ditto <br>// <br>// OUTPUT:ditto <br>// <br>// RETURNS:ditto <br>// <br>//----------------------------------------------------------------------------- <br>HRESULT _HrOpenVirtualStreamOnProperty( <br>    IN LPMAPIPROP pPropObject,// MAPI property object pointer <br>    IN ULONG ulPropTag,     // property tag to open virtual stream on <br>IN ULONG ulFlags,// MAPI property flags <br>    OUT PVIRTUALSTREAMONPROPERTY * ppVirtualStreamOnProperty)  // pointer buffered stream <br>{ <br>    HRESULT             hr              =   NOERROR; <br>    CEDKVirtualStreamOnProperty * pVirtualStreamOnProperty    =   NULL;       // stream wrapper pointer <br> <br>    DEBUGPUBLIC("HrOpenVirtualStreamOnProperty()"); <br> <br>    // check input parameters <br>    hr = CHK_HrOpenVirtualStreamOnProperty(pPropObject, ulPropTag, ulFlags, <br>      ppVirtualStreamOnProperty); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // initialize output parameters. <br>    *ppVirtualStreamOnProperty = NULL; <br> <br>    // Instantiate a new virtual stream on property object <br>    pVirtualStreamOnProperty = new CEDKVirtualStreamOnProperty(); <br>     <br>    if ( pVirtualStreamOnProperty == NULL ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    ASSERT_IUNKNOWN_PTR(pVirtualStreamOnProperty, "Bad pVirtualStreamOnProperty"); <br> <br>    // pVirtualStreamOnProperty reference count is now 1. <br> <br>    // Initialize VSOP instance. <br>    hr = pVirtualStreamOnProperty-&gt;HrInitialize( <br>    pPropObject,// property object pointer <br>    ulPropTag,// property tag <br>    ulFlags);// MAPI property flags <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Retrieve an IEDKVirtualStreamOnProperty interface. <br>    hr = pVirtualStreamOnProperty-&gt;QueryInterface( <br>        IID_IEDKVirtualStreamOnProperty,          // interfac ID reference <br>        (LPVOID *) ppVirtualStreamOnProperty);      // IEDKVirtualStreamOnProperty interface pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        goto cleanup; <br>    } <br> <br>    ASSERT_READ_PTR(ppVirtualStreamOnProperty, sizeof(PVIRTUALSTREAMONPROPERTY),  <br>        "Bad ppVirtualStreamOnProperty"); <br>    ASSERT_IUNKNOWN_PTR(*ppVirtualStreamOnProperty, "Bad *ppVirtualStreamOnProperty"); <br> <br>    // pVirtualStreamOnProperty reference count is now 2. <br> <br>    // we are done <br> <br>cleanup: <br> <br>    // Release our copy of the pVirtualStreamOnProperty pointer. <br>    ULRELEASE(pVirtualStreamOnProperty); <br> <br>    // pVirtualStreamOnProperty reference count is now 1 in success case. <br> <br>    RETURN(hr); <br> <br>} <br> <br>//--$CEDKVirtualStreamOnProperty::CEDKVirtualStreamOnProperty--------------------------------------- <br>// <br>// DESCRIPTION: Constructor for CEDKVirtualStreamOnProperty. <br>// <br>// INPUT: none <br>// <br>// RETURNS: nothing <br>// <br>//----------------------------------------------------------------------------- <br>CEDKVirtualStreamOnProperty::CEDKVirtualStreamOnProperty() <br>{ <br>    DEBUGPRIVATE("CEDKVirtualStreamOnProperty::CEDKVirtualStreamOnProperty()\n"); <br> <br>// initialize data members <br>m_pStream = NULL;// unbuffered stream pointer (if any) <br>m_pPropObject = NULL; <br>m_ulPropTag = 0; <br>m_ulFlags = 0;// MAPI property flags <br>m_rgbBuffer = NULL; <br>m_pbBuffer = NULL;// pointer into the character buffer <br>m_cbBuffer = 0;// current size of character buffer <br>m_fDataInitialized = FALSE;// TRUE if data buffer has been initialized <br> <br>    ZeroMemory( <br>    &amp;m_StatStg, <br>sizeof(m_StatStg)); <br> <br>// increment reference count         <br>    m_refs = 1; <br> <br>} <br> <br>//--$CEDKVirtualStreamOnProperty::~CEDKVirtualStreamOnProperty--------------------------------------- <br>// <br>// DESCRIPTION: Destructor for CEDKVirtualStreamOnProperty. <br>// <br>// INPUT: none <br>// <br>// RETURNS: nothing <br>// <br>//----------------------------------------------------------------------------- <br>CEDKVirtualStreamOnProperty::~CEDKVirtualStreamOnProperty() <br>{ <br>    DEBUGPRIVATE("CEDKVirtualStreamOnProperty::~CEDKVirtualStreamOnProperty()\n"); <br> <br>// consistency check <br>ASSERTERROR(m_refs == 0, "Bad m_refs."); <br> <br>// Release "real" stream, if any <br>ULRELEASE(m_pStream); <br> <br>m_ulFlags = 0;// MAPI property flags <br>m_pPropObject = NULL; <br>m_ulPropTag = 0; <br> <br>// Free data buffer memory, if any. <br>MAPIFREEBUFFER(m_rgbBuffer); <br> <br>m_pbBuffer = NULL;// pointer into the character buffer <br>m_cbBuffer = 0;// current size of character buffer <br>m_fDataInitialized = FALSE; <br> <br>    ZeroMemory( <br>    &amp;m_StatStg, <br>sizeof(m_StatStg)); <br> <br>    m_refs = 0; <br> <br>} <br> <br>//--$CEDKVirtualStreamOnProperty::HrInitialize------------------------------------------- <br>// <br>// DESCRIPTION:  Initialize CEDKVirtualStreamOnProperty instance. <br>// <br>// INPUT:   pPropObject--pointer to MAPI property object <br>//          ulPropTag--property tag <br>//ulFlags--MAPI property access flags <br>// <br>// RETURNS: HRESULT --  NOERROR if successful, <br>//                      E_INVALIDARG if bad input, <br>//E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br>HRESULT CEDKVirtualStreamOnProperty::HrInitialize( <br>IN LPMAPIPROP pPropObject,// pointer to MAPI property object <br>IN ULONG ulPropTag,// property tag <br>IN ULONG ulFlags)// MAPI property access flags <br>{ <br>    HRESULT     hr          =   NOERROR; <br>    SYSTEMTIME  sSystemTime =   {0};        // System Time structure <br>    BOOL        fRetVal     =   FALSE;      // Win32 error code. <br> <br>    DEBUGPRIVATE("CEDKVirtualStreamOnProperty::HrInitialize()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CEDKVirtualStreamOnProperty_HrInitialize(pPropObject, ulPropTag, <br>    ulFlags); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>// Save options <br>m_ulFlags = ulFlags; <br>m_pPropObject = pPropObject; <br>m_ulPropTag = ulPropTag; <br> <br>// Zero out storage statistics function. <br>ZeroMemory(&amp;m_StatStg, sizeof(STATSTG)); <br>                 <br>// Set storage type for streams. <br>    m_StatStg.type = STGTY_STREAM; <br> <br>// Set mode in storage statistics structure to <br>// lowest common denominator (for reads). <br>    SetMode(STGM_READ | STGM_SHARE_EXCLUSIVE); <br> <br>    // Don't care about or support other stream statistics. <br> <br>    // we are done <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::HrOpenUnderlyingStream-------------------------------- <br>// <br>// DESCRIPTION:Open or create an underlying stream for reading or writing. <br>// <br>// INPUT:none <br>// <br>// RETURNS:HRESULT--NOERROR if successful, <br>//E_FAIL otherwise. <br>// <br>// ---------------------------------------------------------------------------- <br>HRESULT CEDKVirtualStreamOnProperty::HrOpenUnderlyingStream() <br>{ <br>HRESULThr=NOERROR; <br>ULONGulIIDFlags=STGM_SHARE_EXCLUSIVE;// default stream mode flags <br> <br>DEBUGPRIVATE("CEDKVirtualStreamOnProperty::HrOpenUnderlyingStream()\n"); <br> <br>// consistency check <br>ASSERT_IUNKNOWN_PTR(m_pPropObject, "Bad m_pPropObject"); <br> <br>// Determine if need stream modification (writing) <br>if ( fIsWriteProperty() == TRUE ) <br>{ <br>ulIIDFlags |= STGM_WRITE; <br>} <br> <br>// Determine if need stream creation. <br>if ( fIsNewProperty() == TRUE ) <br>{ <br>ulIIDFlags |= STGM_CREATE; <br>} <br> <br>// Open/create a stream on the property <br>hr = m_pPropObject-&gt;OpenProperty( <br>m_ulPropTag,// property tag <br>&amp;IID_IStream,// interface identifier reference <br>ulIIDFlags,// interface flags <br>m_ulFlags | MAPI_DEFERRED_ERRORS,// MAPI property creation flags <br>(LPUNKNOWN *) &amp;m_pStream);// stream pointer <br> <br>if ( FAILED(hr) ) <br>{ <br>// Return the MAPI error code <br> <br>goto cleanup; <br>} <br> <br>// Adjust mode in the storage statistics structure <br>SetMode(ulIIDFlags); <br> <br> // we are done. <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::HrFlushWriteBuffer--------------------------- <br>// <br>// DESCRIPTION:Flushes data in write buffer to the underlying stream. <br>// <br>// INPUT:fCleanOutWriteBuffer--TRUE if should zero out the write buffer <br>// <br>// RETURNS:HRESULT--NOERROR if successful, <br>//E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br>HRESULT CEDKVirtualStreamOnProperty::HrFlushWriteBuffer( <br>IN BOOL fCleanWriteBuffer)// TRUE if should zero out the write buffer <br>{ <br>HRESULThr=NOERROR; <br>ULONGcbWrite=0;// # bytes to flush <br>ULONGcbWritten=0;// # bytes written <br>LARGE_INTEGERcbWriteStream={0};// # bytes to write to underlying stream <br> <br>DEBUGPRIVATE("CEDKVirtualStreamOnProperty::HrFlushWriteBuffer()\n"); <br> <br>// See if we have an underlying stream to write to. <br>if ( m_pStream == NULL ) <br>{ <br>// Open stream on property &amp; write contents <br>// of buffer to it &amp; readjust buffer data members. <br>hr = HrOpenUnderlyingStream(); <br> <br>if ( FAILED(hr) ) <br>{ <br>// Return any possible MAPI error code due to property access errors. <br> <br>goto cleanup; <br>} <br>}// end if no underlying stream <br> <br>// By the time we get here, we should have an underlying <br>// stream <br>ASSERT_IUNKNOWN_PTR(m_pStream, "Bad m_pStream"); <br> <br>// Determine number of bytes which need to be flushed from buffer. <br>cbWrite = GetBytesWritten(); <br> <br>// Flush contents of buffer to the stream <br>hr = m_pStream-&gt;Write( <br>m_rgbBuffer,// Source buffer <br>cbWrite,// # bytes to write <br>&amp;cbWritten);// # bytes written <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br> <br>// Check # of bytes written <br>if ( cbWritten != cbWrite ) <br>{ <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br> <br>// Adjust size of stream in the storage statistics <br>// structure. <br>cbWriteStream.LowPart = cbWritten; <br>IncrementStreamSize(cbWriteStream); <br> <br>// Clean out write buffer, if requested <br>if ( fCleanWriteBuffer == TRUE ) <br>{ <br>InitBufferSize(m_cbBuffer); <br>} <br> <br>// We are done <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br>//--------------------------------------------------------------------- <br>//                        IUnknown methods <br>//--------------------------------------------------------------------- <br> <br>// $--CEDKVirtualStreamOnProperty::QueryInterface------------------------------------------ <br>// <br>// DESCRIPTION:Return pointer to object which implements the desired <br>//interface, if this object supports the interface. <br>// <br>// INPUT: <br>// <br>//  [riid]-- Reference to interface identifier of desired interface. <br>// <br>//  [ppv]-- Ptr to object which supports interface.  NULL if none. <br>// <br>// RETURNS:     NOERROR if successful; <br>//E_INVALIDARG if bad input. <br>//E_NOINTERFACE if interface isn't supported. <br>// <br>//  Interfaces supported: <br>//       <br>//      IUnknown <br>//      IEDKVirtualStreamOnProperty <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP CEDKVirtualStreamOnProperty::QueryInterface( <br>IN REFIID riid,   // interface ID reference <br>OUTLPVOID * ppvObj)    // pointer to interface pointer <br>{ <br>    HRESULT hr =NOERROR; <br> <br>    DEBUGPRIVATE("CEDKVirtualStreamOnProperty::QueryInterface().\n"); <br> <br>    hr = CHK_CEDKVirtualStreamOnProperty_QueryInterface(riid, ppvObj); <br> <br>    if (FAILED(hr)) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // initialize output parameter <br>    *ppvObj = NULL; <br> <br>    // See if we support the requested interface. <br> <br>    if (IsEqualIID(riid, IID_IUnknown))   // IUnknown interface is ourself <br>{ <br>    *ppvObj = this;    // Return ourself <br>} <br> <br>    else if (IsEqualIID(riid, IID_IEDKVirtualStreamOnProperty)) <br>    { <br>        // User wants our programatic interface, which is ourselves. <br>    *ppvObj = this; <br>    } <br>    else  <br>    { <br>        // We don't support the requested interface. <br>        hr = HR_LOG(E_NOINTERFACE);                  <br> <br>        goto cleanup; <br>    } <br> <br>    // If we reach this point, no error occurred.  Increment reference count. <br>    AddRef(); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::AddRef-------------------------------------------------- <br>// <br>// DESCRIPTION:Increment the reference count on this object. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     New reference count. <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) CEDKVirtualStreamOnProperty::AddRef()// RETURNS: ULONG <br>{ <br>    DEBUGPRIVATE("CEDKVirtualStreamOnProperty::AddRef().\n"); <br> <br>    ASSERTERROR(m_refs, "Bad m_refs."); <br> <br>    m_refs++; <br> <br>    return m_refs; <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::Release------------------------------------------------- <br>// <br>// DESCRIPTION:Decrement the reference count on this object.  If the <br>//reference count reaches 0, destroy this object. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     New reference count. <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) CEDKVirtualStreamOnProperty::Release()// RETURNS: ULONG <br>{ <br>    ULONG   ulRefCount =0; <br> <br>    DEBUGPRIVATE("CEDKVirtualStreamOnProperty::Release().\n"); <br> <br>    ASSERTERROR(m_refs, "Bad m_refs."); <br> <br>    m_refs--; <br> <br>    if ( m_refs == 0 ) <br>    { <br>        delete this; <br>        ulRefCount = 0; <br>    } <br>    else <br>    { <br>        ulRefCount = m_refs; <br>    } <br> <br>    return ulRefCount; <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::HrComputeCurrentSize------------------------- <br>// <br>// DESCRIPTION:Calculates current stream size <br>// <br>// IN:pcbSize--unsigned large integer structure pointer <br>// <br>// RETURNS:HRESULT--NOERROR if successful, <br>//E_INVALIDARG if bad input, <br>//E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br>HRESULT CEDKVirtualStreamOnProperty::HrComputeCurrentSize( <br>IN ULARGE_INTEGER * pcbSize)// unsigned large integer pointer <br>{ <br>HRESULThr=NOERROR; <br>DWORDLONGcbTotal=0;// total size of virtual stream <br>DWORDLONGcbStream=0;// size of underlying stream <br> <br>DEBUGPRIVATE("CEDKVirtualStreamOnProperty()\n"); <br> <br>// check input parameters <br>hr = CHK_CEDKVirtualStreamOnProperty_HrComputeCurrentSize(pcbSize); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Intialize output parameter <br>ZeroMemory(pcbSize, sizeof(ULARGE_INTEGER)); <br> <br>// Check to see that data buffer is initialized <br>if ( fDataInitialized() == FALSE ) <br>{ <br>// First data buffer has not been initialized. <br>if ( fIsWriteProperty() == TRUE ) <br>{ <br>// Have a write property. <br>// Currently, virtual write stream is zero bytes. <br>// We are done. <br>goto cleanup; <br>} <br> <br>else <br>{ <br>// Have a read property. <br>// Need to set up underlying data. <br>// Do this by reading 0 bytes from the property. <br>hr = Read( <br>NULL, <br>0, <br>NULL); <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br> <br>ASSERT_IUNKNOWN_PTR(m_pStream, "Bad m_pStream"); <br> <br>}// end if read property <br>}// end if underlying data hasn't been initialized <br> <br>// By the time we get to here, the underlying data has <br>// been initialize. <br>ASSERTERROR(fDataInitialized() == TRUE, "Bad state"); <br> <br>// See if there is an uderlying stream. <br>if ( m_pStream == NULL ) <br>{ <br>if ( fIsReadProperty() == TRUE ) <br>{ <br>// have a read property <br>// size of stream is size of property buffer. <br>cbTotal = m_cbBuffer; <br>} <br> <br>else// have a write property <br>{ <br>// size of stream is number of bytes written to write buffer. <br>cbTotal = GetBytesWritten(); <br>} <br>}// end if no underlying stream <br> <br>else// have an underlying stream <br>{ <br>// Stream size if the size of the underlying stream <br>// (which is maintained in the stream statistics structure for <br>// write buffers and must be read directly from stream for <br>// read buffers) <br>// plus the size of the write data buffer. <br>cbStream = MAKEDWORDLONG(// Size of underlying stream <br> m_StatStg.cbSize.LowPart, <br>m_StatStg.cbSize.HighPart); <br> <br>// See if we have a read or a write stream <br>if ( (fIsWriteProperty() == TRUE) ) <br>{ <br>// have a write stream  <br>cbTotal = cbStream + GetBytesWritten(); <br>} <br> <br>else// have a read stream <br>{ <br>// See if we need to retrieve the stream size <br>if ( cbStream == 0 ) <br>{ <br>// need to retrieve read stream size. <br>hr = m_pStream-&gt;Stat( <br>&amp;m_StatStg,// storage statistics structure pointer <br>STATFLAG_NONAME);// statistics flags <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br>} <br> <br> // Size of virtual read stream is just size of underlying stream. <br>cbTotal = MAKEDWORDLONG( <br>m_StatStg.cbSize.LowPart, <br>m_StatStg.cbSize.HighPart); <br> <br>}// end if have a read stream <br>}// end if there is an underlying buffer <br> <br>// Set output variables. <br>pcbSize-&gt;LowPart = LOWDWORD(cbTotal); <br>pcbSize-&gt;HighPart = HIDWORD(cbTotal); <br> <br>// We are done <br> <br>cleanup: <br> <br>RETURN(hr); <br> <br>} <br> <br>// IStream methods <br> <br>//$--CEDKVirtualStreamOnProperty::Read--------------------------------------------------- <br>// <br>// DESCRIPTION: Read the number of bytes requested from our "stream" to the <br>//              output buffer. <br>// <br>// INPUT:       pv  --  pointer to output buffer <br>//              cb  --  maximum number of bytes to read <br>// <br>// OUTPUT:      pcb --  number of bytes actually read, may be NULL. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          STG_E_INVALIDPARAMETER if bad input, <br>//STG_E_ACCESSDENIED if not read stream, <br>//STG_E_INSUFFICIENTMEMORY if memory problems, <br>//MAPI_E_* if property access fails, <br>//STG_E_UNKNOWN if unexpected error, <br>//                          STG_E_READFAULT otherwise. <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::Read( <br>        IN LPVOID pv,       // output buffer pointer <br>        IN ULONG cb,        // maximum # of bytes to read <br>        OUT ULONG * pcb)    // # of bytes read <br>{ <br>    HRESULT hr      =   NOERROR; <br>LPSPropValuelpsProp=NULL;// property array pointer <br>ULONGnProps=0;// # of properties <br>ULONGcbProp=0;// # bytes in property <br>BYTE *pbData=NULL;// data pointer <br>ULONGcbUnread=0;// # bytes unread in buffer <br>ULONGcbRead=0;// # bytes to read from buffer <br>BYTE *pbDest=NULL;// pointer into output buffer <br>ULONGcbTotalRead=0;// Total # bytes read <br> <br>SizedSPropTagArray(1, sPropTag) =// property tag array <br>{ <br>1,// number of properties <br>{ <br>m_ulPropTag// property tag desired <br>} <br>}; <br> <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::Read()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CEDKVirtualStreamOnProperty_Read(pv, cb, pcb); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Initialize output variables <br>if ( pcb != NULL ) <br>{ <br>    *pcb = 0; <br>} <br> <br>    ZeroMemory(pv, cb); <br>         <br>pbDest = (BYTE *) pv;// pointer into output buffer <br> <br>// Read is only valid for properties opened for reading <br>if ( fIsReadProperty() == FALSE ) <br>{ <br>hr = HR_LOG(STG_E_ACCESSDENIED); <br> <br>goto cleanup; <br>} <br> <br>// Algorithm: (simplified for clarity).  These steps may correspond <br>// to helper methods yet to be written. <br>// <br>// 1) If data buffer is empty, try to retrieve entire property at once <br>// via the IMAPIProp::GetProps() method. <br>// If this succeeds, read cb bytes out of data buffer into <br>// output buffer and goto cleanup. <br>// <br>// 2) If data buffer is empty, then  <br>// open a "real" stream on the property and copy 8K bytes from the <br>// stream to the data buffer.  Read cb bytes out of the data buffer <br>// into the output buffer and goto cleanup. <br>// <br>// 3) If data buffer is not empty and we have not reached the end of the data <br>// buffer, then read the next cb bytes out of the data buffer into the <br>// output buffer and goto cleanup. <br>// <br>// 4) If we have reached the end of the data buffer and there is no underlying <br>// stream, then read 0 bytes from the data buffer and goto cleanup. <br>// <br>// 5) Otherwise, we have reached the end of the data buffer and there is <br>// an underlying stream. Retrieve the next 8K bytes from the stream and  <br>// copy these to the data buffer.  Read cb bytes from the data buffer to the <br>// output buffer and goto cleanup. <br>//  <br> <br>// Check to see if data buffer is empty because <br>// we haven't retrieved any data yet. <br>if ( fDataInitialized() == FALSE ) <br>{ <br>// data buffer is empty. <br>// Try to retrieve whole property into 8K buffer. <br>hr = m_pPropObject-&gt;GetProps( <br>(LPSPropTagArray) &amp;sPropTag,// property tag array pointer <br>fMapiUnicode,// MAPI flags <br>&amp;nProps,// number of properties retrieved <br>&amp;lpsProp);// property array pointer <br> <br>// Check to see if property is too big to fit in buffer <br>if ( FAILED(hr) || (hr == MAPI_W_ERRORS_RETURNED) ) <br>{ <br>// Check to see if property is to big to retrieve <br>// via GetProps() <br>if ( ( (hr == MAPI_W_ERRORS_RETURNED) &amp;&amp; <br>       (lpsProp[0].Value.l == MAPI_E_NOT_ENOUGH_MEMORY) ) || <br> (hr == MAPI_E_NOT_ENOUGH_MEMORY) ) <br>{ <br>// Open a stream on the property. <br>ASSERT_IUNKNOWN_PTR(m_pPropObject, "Bad m_pPropObject"); <br> <br>hr = m_pPropObject-&gt;OpenProperty( <br>m_ulPropTag,// property tag <br>&amp;IID_IStream,// stream interface <br>STGM_READ | STGM_SHARE_EXCLUSIVE,// interface flags <br>MAPI_DEFERRED_ERRORS,// reduces RPCs <br>(LPUNKNOWN *) &amp;m_pStream);// stream pointer <br> <br>if ( FAILED(hr) ) <br>{ <br>// Return MAPI error code. <br> <br>goto cleanup; <br>} <br> <br>ASSERT_IUNKNOWN_PTR(m_pStream, "Bad m_pStream"); <br> <br>// Allocate 8K buffer to hold some of the stream data. <br>hr = MAPIAllocateBuffer( <br>cbMaxBuffered,// # bytes to allocate <br>(LPVOID *) &amp;m_rgbBuffer);// data buffer pointer <br> <br>if ( FAILED(hr) ) <br>{ <br>hr = HR_LOG(STG_E_INSUFFICIENTMEMORY); <br> <br>goto cleanup; <br>} <br> <br>ASSERT_READ_PTR(m_rgbBuffer, cbMaxBuffered, "Bad m_rgbBuffer"); <br> <br>// Read 8K of stream data into the data buffer and <br>hr = m_pStream-&gt;Read( <br>m_rgbBuffer,// destination buffer pointer <br>cbMaxBuffered,// # bytes to read <br>&amp;cbRead);// # bytes read <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br> <br>// set data buffer members. <br>InitBufferSize(cbRead); <br> <br>}// end if property too big <br> <br>// Otherwise, we have a fatal error <br>else <br>{ <br>// Return MAPI error code. <br> <br>goto cleanup; <br> <br>}// end if have other error <br>}// end if error on GetProps() call <br> <br>else if ( SUCCEEDED(hr) ) <br>{ <br>// Property can be retrieved via GetProps(). <br>// Do some checks <br>ASSERTERROR(nProps == 1, "Bad nProps"); <br>ASSERT_READ_PTR(lpsProp, sizeof(SPropTagArray), "Bad lpsProp"); <br> <br>// Make sure that property will fit in our buffer. <br>if ( PROP_TYPE(m_ulPropTag) == PT_BINARY ) <br>{ <br>// have a binary property <br>cbProp = lpsProp[0].Value.bin.cb; <br>pbData = lpsProp[0].Value.bin.lpb;// data pointer <br>} <br> <br>else if ( PROP_TYPE(m_ulPropTag) == PT_TSTRING ) <br>{ <br>// have a string property <br>cbProp = lstrlen(lpsProp[0].Value.LPSZ) * sizeof(CHAR); <br>pbData = (BYTE *) lpsProp[0].Value.LPSZ;// data pointer <br>} <br> <br>else <br>{ <br>// This shouldn't happen <br>ASSERTERROR(FALSE, "Bad m_ulPropTag"); <br> <br>hr = HR_LOG(STG_E_UNKNOWN); <br> <br>goto cleanup; <br>} <br> <br>// Set data buffer members <br>// First, copy property data to our local data buffer <br>hr = MAPIAllocateBuffer( <br>cbProp,// number of bytes to allocate <br>(LPVOID *) &amp;m_rgbBuffer);// data buffer pointer <br> <br>if ( FAILED(hr) ) <br>{ <br>hr = HR_LOG(STG_E_INSUFFICIENTMEMORY); <br> <br>goto cleanup; <br>} <br> <br>ASSERT_READ_PTR(m_rgbBuffer, cbProp, "Bad m_rgbBuffer"); <br> <br>CopyMemory( <br>m_rgbBuffer,// destination buffer <br>pbData,// source buffer <br>cbProp);// number of bytes <br> <br>// Set data buffer members <br>InitBufferSize(cbProp); <br> <br>}// end if property can fit in our data buffer <br> <br>// Test for real failures <br>else if ( FAILED(hr) || (hr == MAPI_W_ERRORS_RETURNED) ) <br>{ <br>// Return MAPI error code. <br> <br>goto cleanup; <br>} <br>}// end if haven't gotten any data yet. <br> <br>ASSERT_READ_PTR(m_rgbBuffer, m_cbBuffer, "Bad m_rgbBuffer"); <br> <br>// When we get to here, we will have data in the buffer. <br>// Try to read the desired number of bytes from the buffer. <br>while ( cbTotalRead &lt; cb ) <br>{ <br>// First, determine the number of unread bytes in the buffer. <br>cbUnread = GetBytesUnread(); <br> <br>// Check to see if we need to refill the data buffer <br>if ( cbUnread == 0 ) <br>{ <br>// We need to refill the data buffer. <br>// See if there is an underlying stream to read more <br>// data from.  If not, then we are done. <br>if ( m_pStream == NULL ) <br>{ <br>// No more data.  <br>// We are done. <br>break; <br>} <br> <br>ASSERT_IUNKNOWN_PTR(m_pStream, "Bad m_pStream"); <br> <br>// Read more data from underlying stream <br>hr = m_pStream-&gt;Read( <br>m_rgbBuffer,// data buffer pointer <br>cbMaxBuffered,// # bytes to read <br>&amp;cbRead);// # bytes read <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br> <br>// Set up data buffer members <br>InitBufferSize(cbRead); <br> <br>// Re-calculate the number of unread data bytes <br>cbUnread = GetBytesUnread(); <br> <br>// Re-test for end of data condition <br>if ( cbUnread == 0 ) <br>{ <br>// we are done. <br>break; <br>} <br> <br>}// end if need to refill data buffer <br> <br>// Determine number of bytes to read from buffer. <br>cbRead = min(cbUnread, cb); <br> <br>// Read data from data buffer to output buffer <br>CopyMemory( <br>pbDest,// destination buffer pointer <br>m_pbBuffer,// source buffer <br>cbRead);// # bytes to copy <br> <br>// Adjust data buffer pointers <br>IncrementBytesRead(cbRead); <br>pbDest += cbRead; <br> <br>// increment number of bytes read <br>cbTotalRead += cbRead; <br> <br>}// end while <br> <br>    // we are done <br> <br>cleanup: <br> <br>// Set output variables (handles case of partial reads) <br>if ( pcb != NULL ) <br>{ <br>(*pcb) = cbTotalRead; <br>} <br> <br>// Free MAPI buffers <br>MAPIFREEBUFFER(lpsProp); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::Write--------------------------------------------------- <br>// <br>// DESCRIPTION: Write the number of bytes requested from the buffer to the <br>//              "stream". <br>// <br>// INPUT:       pv  --  pointer to buffer <br>//              cb  --  number of bytes to write <br>// <br>// OUTPUT:      pcb --  number of bytes written -- may be NULL <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          STG_E_INVALIDPARAMETER if bad input, <br>//STG_E_ACCESSDENIED if not write stream, <br>//STG_E_INSUFFICIENTMEMORY if memory problems, <br>//MAPI_E_* if property access fails, <br>//                          STG_E_WRITEFAULT otherwise. <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::Write( <br>        IN VOID const * pv, // data to write <br>        IN ULONG cb,        // # bytes to write <br>        OUT ULONG *pcb)     // # bytes written <br>{ <br>HRESULT hr=NOERROR; <br>BYTE *pbSource=NULL;// pointer into source buffer <br>ULONGcbUnwritten=0;// # of unwritten bytes in buffer </code></pre>
<p>
</p>
<pre><code>ULONGcbWrite=0;// # of bytes to write <br>ULONGcbTotalWrite=0;// total # bytes written <br> <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::Write()\n"); <br> <br>// Check input parameters <br>hr = CHK_CEDKVirtualStreamOnProperty_Write(pv, cb, pcb); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// Initialize output paramters. <br>if ( pcb != NULL ) <br>{ <br>*pcb = 0; <br>} <br> <br>pbSource = (BYTE *) pv;// pointer into source buffer <br> <br>// If we don't have a write buffer, then we fail. <br>if ( fIsWriteProperty() == FALSE ) <br>{ <br>hr = HR_LOG(STG_E_ACCESSDENIED); <br> <br>goto cleanup; <br>} <br> <br>// Algorithm: <br>// <br>// 1) If data buffer isn't full, copy cb bytes from input buffer <br>// to the data buffer.  If data buffer becomes full during this process, <br>// goto step 2).  Otherwise, goto cleanup. <br>// <br>// 2) If data buffer is full or has become full in step and there is <br>// no underlying stream, then open or create <br>// the underlying stream on the property, as appropriate (based on m_ulFlags). <br>// <br>// 3) If the data buffer is full, write the contents of the data buffer <br>// to the underlying stream.  Then, if there is still any additional data <br>// to be written, copy it to the now empty data buffer.  Goto cleanup. <br> <br>// If no current data buffer, make one. <br>if ( fDataInitialized() == FALSE ) <br>{ <br>// Create a data buffer to write to. <br>// Buffer includes "extra" room for null-termination of exactly 8K <br>// string. <br>hr = MAPIAllocateBuffer( <br>cbMaxBuffered + sizeof(CHAR),// # bytes to allocate <br>(LPVOID *) &amp;m_rgbBuffer);// data buffer pointer <br> <br>if ( FAILED(hr) ) <br>{ <br>hr = HR_LOG(STG_E_INSUFFICIENTMEMORY); <br> <br>goto cleanup; <br>} <br> <br>// Set data buffer members <br>InitBufferSize(cbMaxBuffered); <br> <br>}// end if no data buffer <br> <br>ASSERT_READ_PTR(m_rgbBuffer, m_cbBuffer, "Bad m_rgbBuffer"); <br> <br>// Copy data to data buffer, <br>while ( cbTotalWrite &lt; cb ) <br>{ <br>// Determine number of unwritten bytes left in buffer. <br>cbUnwritten = GetBytesUnwritten(); <br> <br>// See if we need to flush out the write buffer. <br>if ( cbUnwritten == 0 ) <br>{ <br>// Flush data written to the underlying stream, <br>// making sure to reset the write buffer. <br>hr = HrFlushWriteBuffer(TRUE); <br> <br>if ( FAILED(hr) ) <br>{ <br>// Return possbile MAPI error code due to property access failure <br> <br>goto cleanup; <br>} <br> <br>// continue on to handle writing of pv input data <br>continue; <br> <br>}// end if need to flush write buffer <br> <br>ASSERTERROR(cbUnwritten != 0, "Bad cbUnwritten"); <br> <br>// Compute number of byte to write to data buffer <br>cbWrite = min(cb, cbUnwritten); <br> <br>// Write the desired number of bytes <br>CopyMemory( <br>m_pbBuffer,// destination buffer pointer <br>pbSource,// source buffer <br>cbWrite);// # bytes to copy <br> <br>// Update the number of bytes written <br>IncrementBytesWritten(cbWrite); <br>pbSource += cbWrite; <br> <br>// increment total number of bytes written <br>cbTotalWrite += cbWrite; <br> <br>}// end while <br> <br>// We are done. <br> <br>cleanup: <br> <br>// Set output variables (handles case of partial writes) <br>if ( pcb != NULL ) <br>{ <br>(*pcb) = cbTotalWrite; <br>} <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::CopyTo--------------------------------------------------- <br>// <br>// DESCRIPTION: Copy the number of bytes requested from the "source" stream to the <br>//              destination stream. <br>// <br>// INPUT:       pStrm  --  destination stream pointer <br>//              cb  --  number of bytes to copy <br>// <br>// OUTPUT:      pcbRead --  number of bytes read -- may be NULL <br>//              pcbWritten  --  number of bytes written -- may be NULL <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          STG_E_INVALIDPARAMETER if bad input, <br>//error codes from Read() and Write(), <br>//                          E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::CopyTo( <br>        IN LPSTREAM pStrm,              // destination stream pointer <br>        IN ULARGE_INTEGER cb,           // # bytes to copy <br>        OUT ULARGE_INTEGER * pcbRead,   // # bytes read <br>        OUT ULARGE_INTEGER * pcbWritten)// # bytes written <br>{ <br>    HRESULT hr          =   NOERROR; <br>    ULONG   cbRead      =   0;          // # bytes read from source <br>    ULONG   cbWritten   =   0;          // # bytes written to destination <br>ULONGcbDesired=0;// # bytes desired <br>DWORDLONGcbTemp1=0;// temporary byte count <br>DWORDLONGcbTotalRead=0; // # bytes read so far <br>DWORDLONGcbTotalWrite=0;// # bytes written so far <br>DWORDLONGcbTotalReq=0;// # total bytes desired <br> <br>CHARrgchBuffer[cbMaxBuffered]={0};// data buffer <br> <br>    DEBUGPUBLIC("CEDKStreamWrappr::CopyTo()\n"); <br> <br>    // check input parameters <br>    hr = CHK_CEDKVirtualStreamOnProperty_CopyTo(pStrm, cb, pcbRead, pcbWritten); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Initialize output variables <br>if ( pcbRead != NULL ) <br>{ <br>ZeroMemory(pcbRead, sizeof(ULARGE_INTEGER)); <br>} <br> <br>if ( pcbWritten != NULL ) <br>{ <br>ZeroMemory(pcbWritten, sizeof(ULARGE_INTEGER)); <br>} <br> <br>// _int64s are easier to do arithmetic on than LARGE_INTEGER structures <br>cbTotalReq = MAKEDWORDLONG(cb.LowPart, cb.HighPart); <br> <br>while ( cbTotalRead &lt; cbTotalReq ) <br>{ <br>    // Read up to 8K bytes from the source stream (using IStream::Read() method) <br> <br>// First, determine # bytes to read. <br>cbTemp1 = cbTotalReq - cbTotalRead; <br> <br>if ( HIDWORD(cbTemp1) != 0 ) <br>{ <br>cbDesired = cbMaxBuffered;// read 8K bytes <br>} <br> <br>else <br>{ <br>cbDesired = min(cbMaxBuffered, LOWDWORD(cbTemp1)); <br>} <br> <br>hr = Read( <br>rgchBuffer,// data buffer <br>cbDesired,// # bytes to read <br>&amp;cbRead);// # bytes read <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br> <br>// compute current total number of bytes read. <br>cbTotalRead += cbRead; <br> <br>// Check for end of stream <br>if ( cbRead == 0 ) <br>{ <br>// we are done <br>break; <br>} <br> <br>ASSERTERROR(cbRead == cbDesired, "Bad cbRead"); <br> <br>    // Write cb bytes to the destination stream (using IStream::Write() method) <br>hr = pStrm-&gt;Write( <br>rgchBuffer,// data buffer <br>cbRead,// # bytes just read <br>&amp;cbWritten);// # bytes written <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br> <br>// Compute current total number of bytes written <br>cbTotalWrite += cbWritten; <br> <br>ASSERTERROR(cbWritten == cbRead, "Bad cbWritten"); <br> <br>}// end while <br> <br>    // We are done <br>         <br>cleanup: <br> <br>// Set output paremeters (handles case of partial read or write) <br>if ( pcbRead != NULL ) <br>{ <br>pcbRead-&gt;LowPart = LOWDWORD(cbTotalRead); <br>pcbRead-&gt;HighPart = HIDWORD(cbTotalRead); <br>} <br> <br>if ( pcbWritten != NULL ) <br>{ <br>pcbWritten-&gt;LowPart = LOWDWORD(cbTotalWrite); <br>pcbWritten-&gt;HighPart = HIDWORD(cbTotalWrite); <br>} <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::Commit--------------------------------------------------- <br>// <br>// DESCRIPTION: Save changes to the stream. <br>// <br>// INPUT:       dwFlags --  flags <br>// <br>// OUTPUT:      None <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//STG_E_WRITEFAULT if problems writting, <br>//MAPI_E_* if property access fails, <br>//STG_E_UNKNOWN if unexpected problem. <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::Commit(  <br>        IN DWORD dwFlags)   // flags <br>{ <br>HRESULThr=NOERROR; <br>SPropValuesPropValue={0};// property value <br>LPSPropProblemArraylpsProblems=NULL;// property problem array pointer <br>ULONGcbWrite=0;// # bytes to write to stream <br>ULONGiProp=0;// property problem index <br> <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::Commit()"); <br> <br>// Check to see if are only doing reads on the property/ <br>if ( fIsReadProperty() == TRUE ) <br>{ <br>// nothing to do. <br>MODULE_WARNING("Commit() does nothing when called on a read stream."); <br> <br>goto cleanup; <br>} <br> <br>// Algorithm: <br>// <br>// 1) If there is no underlying stream and there is data in the buffer, <br>// then try to write the data to the property via the IMAPIPROP::SetProps() method. <br>// If this succeeds, then save the changes to the property object and <br>// go to cleanup. <br>// <br>// 2) If the SetProps() in step 1) failed, then open or create a stream <br>// on the underlying property. <br>// <br>// 3) Write any data in the buffer to the underlying stream.  Commit the <br>// changes to the underlying stream and save the changes to the  <br>// property object.  Go to cleanup. <br> <br>// See if there is any unflushed data in the data buffer. <br>cbWrite = GetBytesWritten(); <br> <br>if ( cbWrite &gt; 0 ) <br>{ <br>// If we have no underlying stream, try a SetProps() <br>// first. <br>if ( m_pStream == NULL ) <br>{ <br>ASSERT_IUNKNOWN_PTR(m_pPropObject, "Bad m_pPropObject"); <br> <br>// Set up property value structure. <br>sPropValue.ulPropTag = m_ulPropTag;// property tag <br> <br>if ( PROP_TYPE(m_ulPropTag) == PT_BINARY ) <br>{ <br>// have a binary property <br>sPropValue.Value.bin.cb = cbWrite;// property size <br>sPropValue.Value.bin.lpb = m_rgbBuffer;// property value <br>} <br> <br>else if ( PROP_TYPE(m_ulPropTag) == PT_TSTRING ) <br>{ <br>// have a string property <br>sPropValue.Value.LPSZ = (LPSTR) m_rgbBuffer;// property value <br>} <br> <br>else <br>{ <br>// This shouldn't happen <br>ASSERTERROR(FALSE, "Bad property tag type"); <br> <br>hr = HR_LOG(STG_E_UNKNOWN); <br> <br>goto cleanup; <br>} <br> <br>hr = m_pPropObject-&gt;SetProps( <br>1,// # of properties <br>&amp;sPropValue,// property value pointer <br>&amp;lpsProblems);// property problem array pointer <br> <br>if ( SUCCEEDED(hr) &amp;&amp; (lpsProblems == NULL) ) <br>{ <br>// We are done! <br>goto cleanup; <br>} <br> <br>// Check for errors other than not enough memory <br>if ( FAILED(hr) &amp;&amp; (hr != MAPI_E_NOT_ENOUGH_MEMORY) ) <br>{ <br>// fatal error <br>// Return MAPI error code <br> <br>goto cleanup; <br>} <br> <br>// Check property problem array <br>if ( lpsProblems != NULL ) <br>{ <br>ASSERT_READ_PTR(lpsProblems, sizeof(SPropProblemArray),  <br>"Bad lpsProblems"); <br> <br>for ( iProp = 0; iProp &lt; lpsProblems-&gt;cProblem; iProp++ ) <br>{ <br>if ( lpsProblems-&gt;aProblem[iProp].scode !=  <br>     MAPI_E_NOT_ENOUGH_MEMORY ) <br>{ <br>// fatal error <br>// Return MAPI error code <br>hr = HR_LOG(lpsProblems-&gt;aProblem[iProp].scode); <br> <br>goto cleanup; <br>} <br>}// end for each problem  <br>} <br> <br>// Otherwise, there is too much <br>// data to use SetProps. <br>// Open a stream on the property. <br>hr = HrOpenUnderlyingStream(); <br> <br>if ( FAILED(hr) ) <br>{ <br>// Return possible MAPI error code due to property access problem. <br> <br>goto cleanup; <br>} <br>}// end if no underlying stream <br> <br>// If we get to here, we  <br>// have an underlying stream. <br>ASSERT_IUNKNOWN_PTR(m_pStream, "Bad m_pStream"); <br> <br>// Flush buffered data to the underlying stream. <br>// making sure that we do NOT reset the write buffer. <br>hr = HrFlushWriteBuffer(FALSE); <br> <br>if ( FAILED(hr) ) <br>{ <br>// Return possible MAPI error code due to property access failure <br> <br>goto cleanup; <br>}    <br>}// end if unflushed data in the buffer <br> <br>// If there is an underlying stream, commit the changes to it now. <br>if ( m_pStream != NULL ) <br>{ <br>ASSERT_IUNKNOWN_PTR(m_pStream, "Bad m_pStream"); <br> <br>hr = m_pStream-&gt;Commit(dwFlags); <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br> <br>}// end if underlying stream <br> <br>// We are done. <br> <br>cleanup: <br> <br>// Free MAPI buffers <br>MAPIFREEBUFFER(lpsProblems); <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::Stat--------------------------------------------------- <br>// <br>// DESCRIPTION: Return "stream" statistics <br>// <br>// INPUT:        <br>//              dwFlags --  flags <br>// <br>// OUTPUT:      pStatStg    --  statistics buffer pointer <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::Stat( <br>        OUT STATSTG * pStatStg,     // stream statistic pointer <br>        IN DWORD dwFlags)           // flags <br>{    <br>    HRESULT hr  =   NOERROR; <br>ULARGE_INTEGERcbSize={0};// virtual stream size <br> <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::Stat()\n"); <br> <br>    // Check parameters <br>    hr = CHK_CEDKVirtualStreamOnProperty_Stat(pStatStg, dwFlags); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    // Initialize output buffer <br>    ZeroMemory( <br>        pStatStg, <br>        sizeof(STATSTG)); <br> <br>    // Get the current size of the stream <br>hr = HrComputeCurrentSize( <br>&amp;cbSize);// large integer structure pointer <br> <br>if ( FAILED(hr) ) <br>{ <br>goto cleanup; <br>} <br> <br>    // Note:  last modification and access time are not supported. <br> <br>    // copy of the default stream statistics to the output buffer <br>    CopyMemory( <br>        pStatStg,           // destination buffer <br>        &amp;m_StatStg,         // source buffer <br>        sizeof(m_StatStg)); // # bytes to copy <br> <br>// Set the current size of the virtual stream <br>pStatStg-&gt;cbSize.LowPart = cbSize.LowPart; <br>pStatStg-&gt;cbSize.HighPart = cbSize.HighPart; <br> <br>    // we are done <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br>// Methods not currently supported for our stream wrapper class: <br>// <br>// Seek, Clone, Revert, SetSize, UnlockRegion, LockRegion. <br>// <br>// These methods all return STG_E_INVALIDFUNCTION. <br> <br>//$--CEDKVirtualStreamOnProperty::Seek--------------------------------------------------- <br>// <br>// DESCRIPTION: Go to the specified position in the "stream". <br>// <br>// INPUT:       cbOffset    --  offset <br>//              dwOrigin    --  origin <br>//                   <br>// OUTPUT:      pcbPos  --  new position pointer -- may be NULL <br>// <br>// RETURNS:     HRESULT --  STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::Seek( <br>        IN LARGE_INTEGER cbOffset,      // byte offset <br>        IN DWORD dwOrigin,              // origin <br>        OUT ULARGE_INTEGER * pcbPos)    // new position <br>{ <br>    HRESULT         hr      =   NOERROR; <br> <br>DEBUGPUBLIC("CEDKVirtualStreamOnProperty::Seek()\n"); <br> <br>// check input parameters <br>hr = CHK_CEDKVirtualStreamOnProperty_Seek(cbOffset, dwOrigin, pcbPos); <br> <br>if ( FAILED(hr) ) <br>{ <br>RETURN(hr); <br>} <br> <br>// not implemented. <br>    RETURN(STG_E_INVALIDFUNCTION); <br> <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::Clone--------------------------------------------------- <br>// <br>// DESCRIPTION: Duplicate "stream" <br>// <br>// INPUT:       ppStrm  --  duplicate stream pointer <br>// <br>// OUTPUT:      None <br>// <br>// RETURNS:     HRESULT --  STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::Clone( <br>        OUT LPSTREAM * ppStrm)      // pointer to new stream <br>{ <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::Clone()\n"); <br> <br>    RETURN(STG_E_INVALIDFUNCTION); <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::Revert--------------------------------------------------- <br>// <br>// DESCRIPTION: Undo changes to stream <br>// <br>// INPUT:       None <br>// <br>// OUTPUT:      None <br>// <br>// RETURNS:     HRESULT --  STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::Revert() <br>{ <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::Revert()\n"); <br> <br>    RETURN(STG_E_INVALIDFUNCTION); <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::SetSize--------------------------------------------------- <br>// <br>// DESCRIPTION: Grow or shrink "stream" <br>// <br>// INPUT:       nSize   --  new size <br>// <br>// OUTPUT:      None <br>// <br>// RETURNS:     HRESULT --  STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::SetSize( <br>        IN ULARGE_INTEGER nSize)    // new size <br>{ <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::SetSize()\n"); <br> <br>    RETURN(STG_E_INVALIDFUNCTION); <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::UnlockRegion--------------------------------------------------- <br>// <br>// DESCRIPTION: Unlock section of "stream" <br>// <br>// INPUT:       cbOffset    --  offset <br>//              cbLength    --  length <br>//              dwFlags     --  flags <br>// <br>// OUTPUT:      None <br>// <br>// RETURNS:     HRESULT --  STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::UnlockRegion( <br>        IN ULARGE_INTEGER cbOffset, // offset <br>        IN ULARGE_INTEGER cbLength, // length <br>        IN DWORD dwFlags)           // flags <br>{ <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::UnlockRegion()\n"); <br> <br>    RETURN(STG_E_INVALIDFUNCTION); <br>} <br> <br>//$--CEDKVirtualStreamOnProperty::LockRegion--------------------------------------------------- <br>// <br>// DESCRIPTION: lock section of "stream" <br>// <br>// INPUT:       cbOffset    --  offset <br>//              cbLength    --  length <br>//              dwFlags     --  flags <br>// <br>// OUTPUT:      None <br>// <br>// RETURNS:     HRESULT --  STG_E_INVALIDFUNCTION <br>// <br>//----------------------------------------------------------------------------- <br>STDMETHODIMP CEDKVirtualStreamOnProperty::LockRegion( <br>        IN ULARGE_INTEGER cbOffset, // offset <br>        IN ULARGE_INTEGER cbLength, // length <br>        IN DWORD dwFlags)           // flags <br>{ <br>    DEBUGPUBLIC("CEDKVirtualStreamOnProperty::LockRegion()\n"); <br> <br>    RETURN(STG_E_INVALIDFUNCTION); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
