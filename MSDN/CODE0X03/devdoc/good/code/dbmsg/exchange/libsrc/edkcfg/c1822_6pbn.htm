<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EDKCFG.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1823"></a>EDKCFG.C</h2>
<pre><code>// --edkcfg.c------------------------------------------------------------------- <br>// <br>//  Routines to aid in saving and retrieving configuration information for  <br>//  gateways and other objects to and from the DIT. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "attrname.h" <br>#include "edkcfg.chk" <br> <br>static HRESULT HrCfgCountProps( <br>    IN  int cprop,  <br>    IN  LPSPropValue rgprop,  <br>    OUT ULONG FAR *pcb); <br> <br>static HRESULT HrCfgCopyProps( <br>    IN  int cprop,  <br>    IN  LPSPropValue rgprop,  <br>    OUT LPVOID pvDst,  <br>    OUT ULONG FAR *pcb); <br> <br>#define Align(_cb)(((_cb) + 7) &amp; ~7) <br> <br>//Pointer manipulation macros for use in the Reloc functions <br>#ifdef WIN16 <br>#define SEG(_fp)HIWORD((DWORD)_fp) <br>#define OFF(_fp)LOWORD((DWORD)_fp) <br> <br>#define PvRelocPv(_p,_baseOld,_baseNew) \ <br>((LPVOID)MAKELONG(OFF(_p) - OFF(_baseOld) + OFF(_baseNew), SEG(_baseNew))) <br>#else <br>#define PvRelocPv(_p,_baseOld,_baseNew)\ <br>((LPVOID)((LPBYTE)(_p) - (LPBYTE)(_baseOld) + (LPBYTE)(_baseNew))) <br>#endif <br> <br> <br>#define SITE_ADDRESSING_RDN "/cn=Configuration/cn=Site-Addressing" <br> <br>// Magic number to indicate that this is a valid configuration data structure. <br>// The value 0x10101010 was chosen because older code used the byte value 0x10  <br>// to mean "end of record", so any older code reading this structure will  <br>// ignore the data. <br>#define EDKCFG_MAGIC_NUMBER0x10101010 <br> <br>// Version number that determines the format of the data that comes after it  <br>// in the structure. <br>#define EDKCFG_VERSION_NUMBER1 <br> <br>// The routines in this file pack and unpack a set of MAPI properties into a  <br>// binary data structure which can be stored in a file or the directory  <br>// information tree.  The binary data structure has the following format: <br>// <br>// +---------------------------------------+ <br>// | UNICODE Config Name (null-terminated) | <br>// +---------------------------------------+ <br>// | DWORD EDKCFG_MAGIC_NUMBER             | <br>// +---------------------------------------+ <br>// | DWORD EDKCFG_VERSION_NUMBER           | <br>// +---------------------------------------+ <br>// | DWORD Number of properties            | <br>// +---------------------------------------+ <br>// | Packed binary array of properties     | <br>// +---------------------------------------+ <br> <br>//$--HrCfgPackData-------------------------------------------------------------- <br>//  Take a configuration name and a set of MAPI properties and pack them into  <br>//  a binary buffer suitable to be saved in the directory information tree for  <br>//  the gateway or other object. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCfgPackDataA(                     // RETURN: HRESULT <br>INLPSTRlpszOwnerTag,// name of configuration (or NULL) <br>INULONGcProps,// number of MAPI properties <br>INLPSPropValuelpProps,// MAPI properties for this config. <br>OUTULONG *lpcbConfigData,// size of resulting binary struct. <br>OUTLPBYTE *lppbConfigData)// resulting binary structure <br>{ <br>HRESULThr= NOERROR; <br>    LPWSTR      lpwszOwnerTag       = NULL; <br> <br>DEBUGPUBLIC("HrCfgPackDataA()\n"); <br> <br>hr = CHK_HrCfgPackDataA( <br>lpszOwnerTag,  <br>cProps,  <br>lpProps,  <br>lpcbConfigData,  <br>lppbConfigData); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // Convert config name to word string. <br> <br>    if (lpszOwnerTag) <br>    { <br>        hr = HrStrAToStrW(lpszOwnerTag, &amp;lpwszOwnerTag); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>    // Do the packing operation. <br> <br>    hr = HrCfgPackDataW( <br>        lpwszOwnerTag,  <br>        cProps,  <br>        lpProps,  <br>        lpcbConfigData,  <br>        lppbConfigData); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    MAPIFREEBUFFER(lpwszOwnerTag); <br> <br>    RETURN(hr); <br>} <br> <br> <br>HRESULT HrCfgPackDataW(                     // RETURN: HRESULT <br>INLPWSTRlpwszOwnerTag,    // name of configuration (or NULL) <br>INULONGcProps,// number of MAPI properties <br>INLPSPropValuelpProps,// MAPI properties for this config. <br>OUTULONG *lpcbConfigData,// size of resulting binary struct. <br>OUTLPBYTE *lppbConfigData)// resulting binary structure <br>{ <br>HRESULThr= NOERROR; <br> <br>ULONGcbConfigData= 0; <br>LPBYTEpbConfigData= NULL; <br> <br>ULONGib= 0; <br>ULONGibOwnerTag    = 0; <br>ULONGcchOwnerTag    = 0; <br>ULONGibMagicNumber= 0; <br>ULONGibVersionNumber= 0; <br>ULONGibPropCount= 0; <br>ULONGibPackedProps= 0; <br>ULONGcbPackedProps= 0; <br> <br>DEBUGPUBLIC("HrCfgPackDataW()\n"); <br> <br>hr = CHK_HrCfgPackDataW( <br>lpwszOwnerTag,  <br>cProps,  <br>lpProps,  <br>lpcbConfigData,  <br>lppbConfigData); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // If they passed NULL for configuration name then use an empty string. <br> <br>    if (lpwszOwnerTag == NULL) <br>    { <br>        lpwszOwnerTag = L""; <br>    } <br> <br>// Figure out how much memory to allocate, and the offsets of the various  <br>// fields within the allocated memory.  Also figure out the size of the  <br>// packed property structure. <br> <br>ib = 0; <br> <br>ibOwnerTag = ib; <br>cchOwnerTag = wcslen(lpwszOwnerTag); <br>ib += ((cchOwnerTag + 1) * sizeof(WCHAR)); <br> <br>ibMagicNumber = ib; <br>ib += sizeof(DWORD); <br> <br>ibVersionNumber = ib; <br>ib += sizeof(DWORD); <br> <br>ibPropCount = ib; <br>ib += sizeof(DWORD); <br> <br>if (cProps) <br>{ <br>ibPackedProps = ib; <br>hr = HrCfgCountProps(cProps, lpProps, &amp;cbPackedProps); <br>if (FAILED(hr)) <br>goto cleanup; <br>ib += cbPackedProps; <br>} <br> <br>cbConfigData = ib; <br> <br>// Allocate the memory. <br> <br>hr = MAPIAllocateBuffer(cbConfigData, &amp;pbConfigData); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Write the properties (if any) to the buffer.  This must be done first. <br> <br>if (cProps) <br>{ <br>ULONG cbSizeRequired = 0; <br> <br>// Convert the properties to a packed binary structure AT THE FRONT  <br>// of the memory we just allocated.  It will be moved to the back  <br>// later.  This makes sure the conversion output buffer is aligned  <br>// on an eight-byte boundry. <br> <br>hr = HrCfgCopyProps(cProps, lpProps, pbConfigData, &amp;cbSizeRequired); <br>if (FAILED(hr)) <br>goto cleanup; <br>if (cbSizeRequired &gt; cbPackedProps) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Make all pointers relative to the start of the property array. <br> <br>hr = ScRelocProps(cProps, (LPSPropValue)pbConfigData, pbConfigData, 0,  <br>&amp;cbSizeRequired); <br>if (FAILED(hr)) <br>goto cleanup; <br>if (cbSizeRequired &gt; cbPackedProps) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Now copy the packed property array to the back of the buffer. <br> <br>MoveMemory(pbConfigData + ibPackedProps, pbConfigData, cbPackedProps); <br>} <br> <br>// Write the configuration name to the buffer. <br> <br>{ <br>        wcscpy((LPWSTR)(pbConfigData + ibOwnerTag), lpwszOwnerTag); <br>} <br> <br>// Write magic number, version number, and number of properties  <br>// to the buffer. <br> <br>{ <br>DWORDdwMagicNumber= EDKCFG_MAGIC_NUMBER; <br>DWORDdwVersionNumber= EDKCFG_VERSION_NUMBER; <br>DWORDdwPropCount= cProps; <br> <br>MoveMemory(pbConfigData + ibMagicNumber, &amp;dwMagicNumber,  <br>sizeof(dwMagicNumber)); <br>MoveMemory(pbConfigData + ibVersionNumber, &amp;dwVersionNumber,  <br>sizeof(dwVersionNumber)); <br>MoveMemory(pbConfigData + ibPropCount, &amp;dwPropCount,  <br>sizeof(dwPropCount)); <br>} <br> <br>// Return the address and size of the buffer to the caller. <br> <br>*lpcbConfigData = cbConfigData; <br>*lppbConfigData = pbConfigData; <br> <br>cleanup: <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(pbConfigData); <br>} <br> <br>RETURN(hr); <br>} <br> <br> <br>//$--HrCfgUnpackData------------------------------------------------------------ <br>//  Take a packed binary buffer and unpack it to yield a configuration name,  <br>//  number of properties, and an array of MAPI properties.  If the number of  <br>//  properties is zero then NULL is returned for the array of properties. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCfgUnpackDataA(// RETURNS: HRESULT <br>INULONGcbConfigData,// size of of binary structure <br>INLPBYTElpbConfigData,// pointer to binary structure <br>OUTLPSTR *    lppszOwnerTag,    // name of configuration (or NULL) <br>OUTULONG *lpcProps,// number of MAPI properties <br>OUTLPSPropValue *lppProps)// MAPI properties for this config. <br>{ <br>HRESULThr= NOERROR; <br>    LPWSTR          pwszOwnerTag    = NULL; <br>    LPSTR           pszOwnerTag     = NULL; <br> <br>DEBUGPUBLIC("HrCfgUnpackDataA()\n"); <br> <br>hr = CHK_HrCfgUnpackDataA( <br>cbConfigData,  <br>lpbConfigData,  <br>lppszOwnerTag,  <br>lpcProps,  <br>lppProps); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // If they want the name returned then call the UNICODE version  <br>    // and then convert the name to a byte string. <br> <br>    if (lppszOwnerTag) <br>    { <br>        hr = HrCfgUnpackDataW( <br>            cbConfigData,  <br>            lpbConfigData,  <br>            &amp;pwszOwnerTag,  <br>            lpcProps,  <br>            lppProps); <br>        if (FAILED(hr)) <br>            goto cleanup; <br> <br>        hr = HrStrWToStrA(pwszOwnerTag, &amp;pszOwnerTag); <br>        if (FAILED(hr)) <br>            RETURN(hr); <br> <br>        *lppszOwnerTag = pszOwnerTag; <br>    } <br> <br>    // If they don't care about the name, then just call the UNICODE  <br>    // version and return. <br> <br>    else <br>    { <br>        hr = HrCfgUnpackDataW( <br>            cbConfigData,  <br>            lpbConfigData,  <br>            NULL,  <br>            lpcProps,  <br>            lppProps); <br>        if (FAILED(hr)) <br>            goto cleanup; <br>    } <br> <br>cleanup: <br>    MAPIFREEBUFFER(pwszOwnerTag); <br> <br>    RETURN(hr); <br>} <br> <br> <br>HRESULT HrCfgUnpackDataW(// RETURNS: HRESULT <br>INULONGcbConfigData,// size of of binary structure <br>INLPBYTElpbConfigData,// pointer to binary structure <br>OUTLPWSTR *lppwszOwnerTag,    // name of configuration (or NULL) <br>OUTULONG *lpcProps,// number of MAPI properties <br>OUTLPSPropValue *lppProps)// MAPI properties for this config. <br>{ <br>HRESULThr= NOERROR; <br>LPBYTEpb= lpbConfigData; <br>ULONGcb= cbConfigData; <br>LPWSTRpwszOwnerTag= NULL; <br>ULONGcProps= 0; <br>LPSPropValuepProps= NULL; <br>    ULONG           cchOwnerTag     = 0; <br> <br>DEBUGPUBLIC("HrCfgUnpackDataW()\n"); <br> <br>hr = CHK_HrCfgUnpackDataW( <br>cbConfigData,  <br>lpbConfigData,  <br>lppwszOwnerTag,  <br>lpcProps,  <br>lppProps); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// If they requested the configuration name then get it. <br> <br>if (lppwszOwnerTag) <br>{ <br> <br>        hr = HrStrWToStrW((LPWSTR)pb, &amp;pwszOwnerTag); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>    cchOwnerTag = wcslen((LPWSTR)pb); <br>pb += ((cchOwnerTag + 1) * sizeof(WCHAR)); <br>cb -= ((cchOwnerTag + 1) * sizeof(WCHAR)); <br> <br>// Make sure the magic number is correct. <br> <br>{ <br>DWORD dwMagicNumber = 0; <br> <br>MoveMemory(&amp;dwMagicNumber, pb, sizeof(dwMagicNumber)); <br>pb += sizeof(dwMagicNumber); <br>cb -= sizeof(dwMagicNumber); <br> <br>if (dwMagicNumber != EDKCFG_MAGIC_NUMBER) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>// Make sure the version number is correct. <br> <br>{ <br>DWORD dwVersionNumber = 0; <br> <br>MoveMemory(&amp;dwVersionNumber, pb, sizeof(dwVersionNumber)); <br>pb += sizeof(dwVersionNumber); <br>cb -= sizeof(dwVersionNumber); <br> <br>if (dwVersionNumber != EDKCFG_VERSION_NUMBER) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>// Get the number of properties. <br> <br>{ <br>DWORD dwPropCount = 0; <br> <br>MoveMemory(&amp;dwPropCount, pb, sizeof(dwPropCount)); <br>pb += sizeof(dwPropCount); <br>cb -= sizeof(dwPropCount); <br>cProps = dwPropCount; <br>} <br> <br>// Get and unpack the property structure if there are any properties  <br>    // (otherwise we return NULL for the pointer to the property array). <br> <br>    if (cProps) <br>{ <br>ULONG cbSizeRequired = 0; <br> <br>hr = MAPIAllocateBuffer(cb, &amp;pProps); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (cProps) <br>{ <br>MoveMemory(pProps, pb, cb); <br>hr = ScRelocProps(cProps, pProps, 0, pProps, &amp;cbSizeRequired); <br>if (FAILED(hr)) <br>goto cleanup; <br>            if (cbSizeRequired &gt; cb) <br>            { <br>                hr = HR_LOG(E_FAIL); <br>                goto cleanup; <br>            } <br>} <br>} <br> <br>// Fill in output parameters. <br> <br>if (lppwszOwnerTag) <br>{ <br>*lppwszOwnerTag = pwszOwnerTag; <br>} <br>*lpcProps = cProps; <br>*lppProps = pProps; <br> <br>cleanup: <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(pwszOwnerTag); <br>MAPIFREEBUFFER(pProps); <br>} <br> <br>RETURN(hr); <br>} <br> <br>//$--HrOpenSiteContainer----------------------------------------------------------------- <br>//  Takes a pointer to a MAPI session and returns an IMAPIProp interface for  <br>//  the current site object. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrOpenSiteContainer(// RETURNS: HRESULT <br>INLPMAPISESSIONlpSession,// MAPI session <br>OUTLPMAPIPROP *lppSite)// current site <br>{ <br>HRESULThr= NOERROR; <br>LPMAPIPROPpCurrentObjectInterface= NULL; <br>LPSPropValuepEmailAddressProps= NULL; <br>LPSTRpszDN= NULL; <br>ULONGcbSiteEntryID= 0; <br>LPENTRYIDpSiteEntryID= NULL; <br>LPMAPIPROPpSiteInterface= NULL; <br> <br>DEBUGPUBLIC("HrOpenSiteContainer()\n"); <br> <br>hr = CHK_HrOpenSiteContainer( <br>lpSession,  <br>lppSite); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Get an IMAPIProp interface for the current object. <br> <br>hr = HrOpenSessionObject(lpSession, &amp;pCurrentObjectInterface); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Get the PR_EMAIL_ADDRESS property. <br> <br>{ <br>SPropTagArray GetEmailAddress = {1, {PR_EMAIL_ADDRESS_A}}; <br>ULONG cProps = 0; <br> <br>hr = MAPICALL(pCurrentObjectInterface)-&gt;GetProps( <br>pCurrentObjectInterface,  <br>&amp;GetEmailAddress,  <br>0L,  <br>&amp;cProps,  <br>&amp;pEmailAddressProps); <br>if (cProps != 1) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>if (hr == MAPI_W_ERRORS_RETURNED) <br>{ <br>hr = HR_LOG(pEmailAddressProps-&gt;Value.err); <br>goto cleanup; <br>} <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Create the DN from the PR_EMAIL_ADDRESS property. <br> <br>{ <br>LPSTR pszSrc = pEmailAddressProps-&gt;Value.lpszA; <br>LPSTR pszSrcLim = pszSrc; <br>ULONG cbDN = 0; <br> <br>// Find the first '/' after the "/o=" and "/ou=", to extract the  <br>// DN from the e-mail address. <br> <br>while (*pszSrcLim &amp;&amp; ( <br>*pszSrcLim != '/' ||  <br>!_strnicmp(pszSrcLim,"/o=",3) ||  <br>!_strnicmp(pszSrcLim,"/ou=",4))) <br>{ <br>pszSrcLim++; <br>} <br>cbDN = pszSrcLim - pszSrc; <br> <br>// Copy the string into an allocated buffer. <br> <br>hr = MAPIAllocateBuffer(cbDN + 1, &amp;pszDN); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>MoveMemory(pszDN, pszSrc, cbDN); <br>pszDN[cbDN] = 0; <br>} <br> <br>// Create a directory entry ID for this site using the DN. <br> <br>{ <br>hr = HrCreateDirEntryId(pszDN, &amp;cbSiteEntryID, &amp;pSiteEntryID); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Open the site entry ID and get an IMAPIProp interface. <br> <br>{ <br>ULONG ulObjType = 0; <br> <br>hr = MAPICALL(lpSession)-&gt;OpenEntry( <br>lpSession,  <br>cbSiteEntryID,  <br>pSiteEntryID,  <br>&amp;IID_IMAPIProp,  <br>MAPI_MODIFY | MAPI_DEFERRED_ERRORS,  <br>&amp;ulObjType,  <br>(LPUNKNOWN FAR *)&amp;pSiteInterface); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Everything was successful, so return the site interface to the caller. <br> <br>*lppSite = pSiteInterface; <br> <br>cleanup: <br> <br>ULRELEASE(pCurrentObjectInterface); <br> <br>MAPIFREEBUFFER(pEmailAddressProps); <br>MAPIFREEBUFFER(pszDN); <br>MAPIFREEBUFFER(pSiteEntryID); <br> <br>if (FAILED(hr)) <br>{ <br>ULRELEASE(pSiteInterface); <br>*lppSite = NULL; <br>} <br> <br>RETURN(hr); <br>} <br> <br>//$--HrOpenSiteContainerAddressing------------------------------------------------------- <br>//  Takes a pointer to a MAPI session and returns an IMAPIProp interface for  <br>//  the current site addressing object. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrOpenSiteContainerAddressing(               // RETURNS: HRESULT <br>INLPMAPISESSIONlpSession,          // MAPI session <br>OUTLPMAPIPROP *lppSiteAddressing)  // current site addressing <br>{ <br>HRESULThr= NOERROR; <br>LPMAPIPROPpCurrentObjectInterface= NULL; <br>LPSPropValuepEmailAddressProps= NULL; <br>LPSTRpszDN= NULL; <br>ULONGcbSiteAddrEntryID       = 0; <br>LPENTRYIDpSiteAddrEntryID        = NULL; <br>LPMAPIPROPpSiteAddrInterface      = NULL; <br> <br>DEBUGPUBLIC("HrOpenSiteContainerAddressing()\n"); <br> <br>hr = CHK_HrOpenSiteContainerAddressing( <br>lpSession,  <br>lppSiteAddressing); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Get an IMAPIProp interface for the current object. <br> <br>hr = HrOpenSessionObject(lpSession, &amp;pCurrentObjectInterface); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Get the PR_EMAIL_ADDRESS property. <br> <br>{ <br>SPropTagArray GetEmailAddress = {1, {PR_EMAIL_ADDRESS_A}}; <br>ULONG cProps = 0; <br> <br>hr = MAPICALL(pCurrentObjectInterface)-&gt;GetProps( <br>pCurrentObjectInterface,  <br>&amp;GetEmailAddress,  <br>0L,  <br>&amp;cProps,  <br>&amp;pEmailAddressProps); <br>if (cProps != 1) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>if (hr == MAPI_W_ERRORS_RETURNED) <br>{ <br>hr = HR_LOG(pEmailAddressProps-&gt;Value.err); <br>goto cleanup; <br>} <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Create the DN from the PR_EMAIL_ADDRESS property. <br> <br>{ <br>LPSTR pszSrc    = pEmailAddressProps-&gt;Value.lpszA; <br>LPSTR pszSrcLim = pszSrc; <br>ULONG cbDN      = 0; <br>ULONG cbRDN     = 0; <br> <br>// Find the first '/' after the "/o=" and "/ou=", to extract the  <br>// DN from the e-mail address. <br> <br>while (*pszSrcLim &amp;&amp; ( <br>*pszSrcLim != '/' ||  <br>!_strnicmp(pszSrcLim,"/o=",3) ||  <br>!_strnicmp(pszSrcLim,"/ou=",4))) <br>{ <br>pszSrcLim++; <br>} <br> <br>cbDN  = pszSrcLim - pszSrc; <br> <br>        cbRDN = strlen(SITE_ADDRESSING_RDN); <br> <br>// Copy the string into an allocated buffer. <br> <br>hr = MAPIAllocateBuffer(cbDN + cbRDN + 1, &amp;pszDN); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>MoveMemory(pszDN, pszSrc, cbDN); <br>pszDN[cbDN] = 0; <br>        strcat(pszDN,SITE_ADDRESSING_RDN); <br>} <br> <br>// Create a directory entry ID for this site addressing object using the DN. <br> <br>{ <br>hr = HrCreateDirEntryId( <br>    pszDN, <br>    &amp;cbSiteAddrEntryID, <br>    &amp;pSiteAddrEntryID); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Open the site addressing entry ID and get an IMAPIProp interface. <br> <br>{ <br>ULONG ulObjType = 0; <br> <br>hr = MAPICALL(lpSession)-&gt;OpenEntry( <br>lpSession,  <br>cbSiteAddrEntryID,  <br>pSiteAddrEntryID,  <br>&amp;IID_IMAPIProp,  <br>MAPI_MODIFY | MAPI_DEFERRED_ERRORS,  <br>&amp;ulObjType,  <br>(LPUNKNOWN FAR *)&amp;pSiteAddrInterface); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Everything was successful, so return the site addressing interface <br>// to the caller. <br> <br>*lppSiteAddressing = pSiteAddrInterface; <br> <br>cleanup: <br> <br>ULRELEASE(pCurrentObjectInterface); <br> <br>MAPIFREEBUFFER(pEmailAddressProps); <br>MAPIFREEBUFFER(pszDN); <br>MAPIFREEBUFFER(pSiteAddrEntryID); <br> <br>if (FAILED(hr)) <br>{ <br>ULRELEASE(pSiteAddrInterface); <br>*lppSiteAddressing = NULL; <br>} <br> <br>RETURN(hr); <br>} <br> <br>//$--HrOpenSessionObject-------------------------------------------------------- <br>//  Takes a pointer to a MAPI session and returns an IMAPIProp interface for  <br>//  the current object that the session is logged in as. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrOpenSessionObject(// RETURNS: HRESULT <br>INLPMAPISESSIONlpSession,// MAPI session <br>OUTLPMAPIPROP *lppCurrentObject)// current object <br>{ <br>HRESULThr= NOERROR; <br>ULONGcbSessionEntryID= 0; <br>LPENTRYIDpSessionEntryID= NULL; <br>LPMAPIPROPpCurrentObjectInterface= NULL; <br> <br>DEBUGPUBLIC("HrOpenSessionObject()\n"); <br> <br>hr = CHK_HrOpenSessionObject( <br>lpSession,  <br>lppCurrentObject); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Get the entry ID for the session. <br> <br>{ <br>hr = MAPICALL(lpSession)-&gt;QueryIdentity( <br>lpSession,  <br>&amp;cbSessionEntryID,  <br>&amp;pSessionEntryID); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Open the entry ID and get an IMAPIProp interface. <br> <br>{ <br>ULONG ulObjType = 0; <br> <br>hr = MAPICALL(lpSession)-&gt;OpenEntry( <br>lpSession,  <br>cbSessionEntryID,  <br>pSessionEntryID,  <br>&amp;IID_IMAPIProp,  <br>MAPI_BEST_ACCESS | MAPI_DEFERRED_ERRORS,  <br>&amp;ulObjType,  <br>(LPUNKNOWN FAR *)&amp;pCurrentObjectInterface); <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>// Everything was successful, so return the site interface to the caller. <br> <br>*lppCurrentObject = pCurrentObjectInterface; <br> <br>cleanup: <br>    if (FAILED(hr)) <br>    { <br>        ULRELEASE(pCurrentObjectInterface); <br>        *lppCurrentObject = NULL; <br>    } <br>MAPIFREEBUFFER(pSessionEntryID); <br>RETURN(hr); <br>} <br> <br>//$--HrCfgPropertyTagFromNameId---------------------------------------------------- <br>//  Takes a pointer to an IMAPIProp interface and a name ID, and returns the  <br>//  MAPI property tag that represents the given name ID for that interface. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrCfgPropertyTagFromNameId(// RETURNS: HRESULT <br>INLPMAPIPROPlpMAPIProp,// IMAPIProp interface <br>    IN  LONG            lNameID,            // Name ID <br>OUTULONG *lpulPropTag)// MAPI property tag of name ID <br>{ <br>HRESULThr= NOERROR; <br>MAPINAMEIDsNameID= {0}; <br>LPMAPINAMEIDrglpNameID[1]= {&amp;sNameID}; <br>LPSPropTagArraylpPropTags= NULL; <br> <br>DEBUGPUBLIC("HrCfgPropertyTagFromNameId()\n"); <br> <br>hr = CHK_HrCfgPropertyTagFromNameId( <br>lpMAPIProp,  <br>lNameID,  <br>lpulPropTag); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Construct the MAPINAMEID. <br> <br>sNameID.lpguid = (LPGUID)PS_EXCHANGE_DIRECTORY; <br>sNameID.ulKind = MNID_ID; <br>sNameID.Kind.lID = lNameID; <br> <br>// Get the property tag. <br> <br>hr = MAPICALL(lpMAPIProp)-&gt;GetIDsFromNames( <br>lpMAPIProp,  <br>1,  <br>rglpNameID,  <br>0,  <br>&amp;lpPropTags); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Extract the property tag from the array. <br> <br>*lpulPropTag = lpPropTags-&gt;aulPropTag[0]; <br> <br>cleanup: <br>MAPIFREEBUFFER(lpPropTags); <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCfgCountProps------------------------------------------------------------ <br>//  Counts the size of the memory needed to hold a property array. <br>//  This works like the MAPI routine ScCountProps but always uses  <br>//  RISC-like 8-byte alignment. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCfgCountProps(             // RETURNS: HRESULT <br>    IN  int cprop,                          // number of properties <br>    IN  LPSPropValue rgprop,                // array of properties <br>    OUT ULONG FAR *pcb)                     // number of bytes needed <br>{ <br>    HRESULT             hr                  = NOERROR; <br>LPSPropValue    pprop               = NULL; <br>ULONG    cb                  = 0; <br>ULONG    cbMV                = 0; <br>int    iValue              = 0; <br> <br>    DEBUGPRIVATE("HrCfgCountProps()"); <br> <br>for (pprop = rgprop; cprop--; ++pprop) <br>{ <br>ULONGulID = PROP_ID(pprop-&gt;ulPropTag); <br>ULONGulType = PROP_TYPE(pprop-&gt;ulPropTag); <br> <br>//Check for valid PROP_ID. <br> <br>if (   (ulID == PROP_ID_INVALID) <br>|| ((ulType == PT_NULL) &amp;&amp; (ulID != PROP_ID_NULL)) <br>|| ((ulType != PT_NULL) &amp;&amp; (ulID == PROP_ID_NULL))) <br>        { <br>            hr = E_INVALIDARG; <br>            goto cleanup; <br>        } <br> <br>//Check for valid PROP_TYPE and count memory consumed. <br> <br>cb += sizeof(SPropValue); <br>switch ( PROP_TYPE(pprop-&gt;ulPropTag) ) <br>{ <br>case PT_UNSPECIFIED: <br>default: <br>                hr = E_INVALIDARG; <br>                goto cleanup; <br> <br>case PT_I2: <br>case PT_LONG: <br>case PT_R4: <br>case PT_APPTIME: <br>case PT_DOUBLE: <br>case PT_BOOLEAN: <br>case PT_CURRENCY: <br>case PT_SYSTIME: <br>case PT_I8: <br>case PT_ERROR: <br>case PT_OBJECT: <br>case PT_NULL: <br>break; <br> <br>case PT_CLSID: <br>if (IsBadReadPtr(pprop-&gt;Value.lpguid, sizeof(GUID))) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += Align(sizeof(GUID)); <br>break; <br> <br>case PT_BINARY: <br>if (pprop-&gt;Value.bin.cb &amp;&amp; IsBadReadPtr( pprop-&gt;Value.bin.lpb <br>, (UINT) (pprop-&gt;Value.bin.cb))) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += Align(pprop-&gt;Value.bin.cb); <br>break; <br> <br>case PT_STRING8: <br>if (IsBadStringPtrA(pprop-&gt;Value.lpszA, INFINITE)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += Align((lstrlenA( pprop-&gt;Value.lpszA ) + 1) * sizeof(CHAR)); <br>break; <br> <br>case PT_UNICODE: <br>if (IsBadStringPtrW(pprop-&gt;Value.lpszW, INFINITE)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += Align((lstrlenW( pprop-&gt;Value.lpszW ) + 1) * sizeof(WCHAR)); <br>break; <br> <br>case PT_MV_I2: <br>if (   !(cbMV = pprop-&gt;Value.MVi.cValues * sizeof(short int)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVi.lpi, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += Align(cbMV); <br>break; <br> <br>case PT_MV_LONG: <br>if (   !(cbMV = pprop-&gt;Value.MVl.cValues * sizeof(LONG)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVl.lpl, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += Align(cbMV); <br>break; <br> <br>case PT_MV_R4: <br>if (   !(cbMV = pprop-&gt;Value.MVflt.cValues * sizeof(float)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVflt.lpflt, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += Align(cbMV); <br>break; <br> <br>case PT_MV_APPTIME: <br>if (   !(cbMV = pprop-&gt;Value.MVat.cValues * sizeof(double)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVat.lpat, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += cbMV; <br>break; <br> <br>case PT_MV_DOUBLE: <br>if (   !(cbMV = pprop-&gt;Value.MVdbl.cValues * sizeof(double)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVdbl.lpdbl, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += cbMV; <br>break; <br> <br>case PT_MV_CURRENCY: <br>if (   !(cbMV = pprop-&gt;Value.MVcur.cValues * sizeof(CURRENCY)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVcur.lpcur, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += cbMV; <br>break; <br> <br>case PT_MV_SYSTIME: <br>if (   !(cbMV = pprop-&gt;Value.MVft.cValues * sizeof(FILETIME)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVft.lpft, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += cbMV; <br>break; <br> <br>case PT_MV_CLSID: <br>if (   !(cbMV = pprop-&gt;Value.MVguid.cValues * sizeof(GUID)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVguid.lpguid, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += cbMV; <br>break; <br> <br>case PT_MV_I8: <br>if (   !(cbMV = pprop-&gt;Value.MVli.cValues * sizeof(LARGE_INTEGER)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVli.lpli, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br>cb += cbMV; <br>break; <br> <br> <br>case PT_MV_BINARY: <br>if (   !(cbMV = pprop-&gt;Value.MVbin.cValues * sizeof(SBinary)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVbin.lpbin, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br> <br>ASSERTERROR(Align(cbMV) == cbMV, "Align(cbMV) != cbMV"); <br>cb += cbMV; <br> <br>for ( iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVbin.cValues; <br>  iValue++ ) <br>{ <br>if (IsBadReadPtr(pprop-&gt;Value.MVbin.lpbin[iValue].lpb, <br>(UINT)pprop-&gt;Value.MVbin.lpbin[iValue].cb)) <br>                    { <br>                        hr = E_INVALIDARG; <br>                        goto cleanup; <br>                    } <br>cb += Align(pprop-&gt;Value.MVbin.lpbin[iValue].cb); <br>} <br>break; <br> <br>case PT_MV_STRING8: <br>if (   !(cbMV = pprop-&gt;Value.MVszA.cValues * sizeof(LPVOID)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVszA.lppszA, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br> <br>cb += cbMV; <br> <br>for ( iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVszA.cValues; <br>  iValue++ ) <br>{ <br>if (IsBadStringPtrA(pprop-&gt;Value.MVszA.lppszA[iValue], <br>INFINITE)) <br>                    { <br>                        hr = E_INVALIDARG; <br>                        goto cleanup; </code></pre>
<p>
</p>
<pre><code>} <br>cb += lstrlenA(pprop-&gt;Value.MVszA.lppszA[iValue]) + 1; <br>} <br> <br>cb = Align(cb); <br> <br>break; <br> <br>case PT_MV_UNICODE: <br>if (   !(cbMV = pprop-&gt;Value.MVszW.cValues * sizeof(LPVOID)) <br>|| IsBadReadPtr(pprop-&gt;Value.MVszW.lppszW, (UINT) cbMV)) <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup; <br>                } <br> <br>cb += cbMV; <br> <br>for ( iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVszW.cValues; <br>  iValue++ ) <br>{ <br>if (IsBadStringPtrW(pprop-&gt;Value.MVszW.lppszW[iValue], INFINITE)) <br>                    { <br>                        hr = E_INVALIDARG; <br>                        goto cleanup; <br>                    } <br>cb += (lstrlenW(pprop-&gt;Value.MVszW.lppszW[iValue]) + 1) <br>  * sizeof(WCHAR); <br>} <br> <br>cb = Align(cb); <br> <br>break; <br>} <br>} <br> <br>if (pcb) <br>{ <br>*pcb = cb; <br>} <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCfgCopyProps------------------------------------------------------------- <br>//  Copies a prop table into a single block of memory. <br>//  This works like the MAPI routine ScCopyProps but always uses  <br>//  RISC-like 8-byte alignment. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCfgCopyProps(              // RETURNS: HRESULT <br>    IN  int cprop,                          // number of properties <br>    IN  LPSPropValue rgprop,                // array of properties <br>    OUT LPVOID pvDst,                       // pointer to destination memory <br>    OUT ULONG FAR *pcb)                     // number of bytes needed <br>{ <br>    HRESULT             hr                  = NOERROR; <br>LPSPropValue    pprop               = NULL; <br>LPSPropValue    ppropDst            = NULL; <br>ULONG    cb                  = 0; <br>ULONG    cbMV                = 0; <br>LPBYTE    pb                  = NULL; <br>UINT    cbT                 = 0; <br>int    iValue              = 0; <br> <br>    DEBUGPRIVATE("HrCfgCopyProps()"); <br> <br>cb = cprop * sizeof(SPropValue); <br>CopyMemory(pvDst, rgprop, (UINT)cb); <br>pb = (LPBYTE)pvDst + cb; <br> <br>for (pprop = rgprop, ppropDst = pvDst; cprop--; ++pprop, ++ppropDst) <br>{ <br>//Tricky: common code after the switch increments pb and cb <br>//by the amount copied. If no increment is necessary, the case <br>//uses 'continue' rather than 'break' to exit the switch, thus <br>//skipping the increment -- AND any other code which may be <br>//added after the switch. <br> <br>switch ( PROP_TYPE(pprop-&gt;ulPropTag) ) <br>{ <br>default: <br>                hr = E_INVALIDARG; <br>                goto cleanup; <br> <br>case PT_I2: <br>case PT_LONG: <br>case PT_R4: <br>case PT_APPTIME: <br>case PT_DOUBLE: <br>case PT_BOOLEAN: <br>case PT_CURRENCY: <br>case PT_SYSTIME: <br>case PT_I8: <br>case PT_ERROR: <br>case PT_OBJECT: <br>case PT_NULL: <br>continue;//nothing to add <br> <br>case PT_CLSID: <br>ppropDst-&gt;Value.lpguid = (LPGUID) pb; <br>cbT = sizeof(GUID); <br>CopyMemory(pb, (LPBYTE) pprop-&gt;Value.lpguid, cbT); <br>break; <br> <br>case PT_BINARY: <br>ppropDst-&gt;Value.bin.lpb = pb; <br>cbT = (UINT)pprop-&gt;Value.bin.cb; <br>CopyMemory(pb, pprop-&gt;Value.bin.lpb, cbT); <br>break; <br> <br>case PT_STRING8: <br>ppropDst-&gt;Value.lpszA = (LPSTR)pb; <br>cbT = lstrlenA( pprop-&gt;Value.lpszA ) + 1; <br>CopyMemory(pb, pprop-&gt;Value.lpszA, cbT); <br>break; <br> <br>case PT_UNICODE: <br>ppropDst-&gt;Value.lpszW = (LPWSTR)pb; <br>cbT = (lstrlenW( pprop-&gt;Value.lpszW ) + 1) * sizeof(WCHAR); <br>CopyMemory(pb, pprop-&gt;Value.lpszW, cbT); <br>break; <br> <br>case PT_MV_I2: <br>ppropDst-&gt;Value.MVi.lpi = (short int FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVi.cValues * sizeof(short int); <br>CopyMemory(pb, pprop-&gt;Value.MVi.lpi, cbT); <br>break; <br> <br>case PT_MV_LONG: <br>ppropDst-&gt;Value.MVl.lpl = (LONG FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVl.cValues * sizeof(LONG); <br>CopyMemory(pb, pprop-&gt;Value.MVl.lpl, cbT); <br>break; <br> <br>case PT_MV_R4: <br>ppropDst-&gt;Value.MVflt.lpflt = (float FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVflt.cValues * sizeof(float); <br>CopyMemory(pb, pprop-&gt;Value.MVflt.lpflt, cbT); <br>break; <br> <br>case PT_MV_APPTIME: <br>ppropDst-&gt;Value.MVat.lpat = (double FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVat.cValues * sizeof(double); <br>CopyMemory(pb, pprop-&gt;Value.MVat.lpat, cbT); <br>break; <br> <br>case PT_MV_DOUBLE: <br>ppropDst-&gt;Value.MVdbl.lpdbl = (double FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVdbl.cValues * sizeof(double); <br>CopyMemory(pb, pprop-&gt;Value.MVdbl.lpdbl, cbT); <br>break; <br> <br>case PT_MV_CURRENCY: <br>ppropDst-&gt;Value.MVcur.lpcur = (CURRENCY FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVcur.cValues * sizeof(CURRENCY); <br>CopyMemory(pb, pprop-&gt;Value.MVcur.lpcur, cbT); <br>break; <br> <br>case PT_MV_SYSTIME: <br>ppropDst-&gt;Value.MVft.lpft = (FILETIME FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVft.cValues * sizeof(FILETIME); <br>CopyMemory(pb, pprop-&gt;Value.MVft.lpft, cbT); <br>break; <br> <br>case PT_MV_CLSID: <br>ppropDst-&gt;Value.MVguid.lpguid = (GUID FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVguid.cValues * sizeof(GUID); <br>CopyMemory(pb, pprop-&gt;Value.MVguid.lpguid, cbT); <br>break; <br> <br>case PT_MV_I8: <br>ppropDst-&gt;Value.MVli.lpli = (LARGE_INTEGER FAR *)pb; <br>cbT = (UINT)pprop-&gt;Value.MVli.cValues * sizeof(LARGE_INTEGER); <br>CopyMemory(pb, pprop-&gt;Value.MVli.lpli, cbT); <br>break; <br> <br>case PT_MV_BINARY: <br>ppropDst-&gt;Value.MVbin.lpbin = (SBinary *) pb; <br>cbMV = pprop-&gt;Value.MVbin.cValues * sizeof(SBinary); <br>pb += cbMV; <br>cb += cbMV; <br>for (iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVbin.cValues; <br>  iValue++) <br>{ <br>ppropDst-&gt;Value.MVbin.lpbin[iValue].lpb = pb; <br>cbT = (UINT)pprop-&gt;Value.MVbin.lpbin[iValue].cb; <br>ppropDst-&gt;Value.MVbin.lpbin[iValue].cb = (ULONG)cbT; <br>CopyMemory(pb, pprop-&gt;Value.MVbin.lpbin[iValue].lpb, cbT); <br>cbT = Align(cbT); <br>cb += cbT; <br>pb += cbT; <br>} <br>continue;//already updated, don't do it again <br> <br>case PT_MV_STRING8: <br>ppropDst-&gt;Value.MVszA.lppszA = (LPSTR *) pb; <br>cbMV = pprop-&gt;Value.MVszA.cValues * sizeof(LPSTR); <br>pb += cbMV; <br>cb += cbMV; <br>for (iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVszA.cValues; <br>  iValue++) <br>{ <br>ppropDst-&gt;Value.MVszA.lppszA[iValue] = (LPSTR)pb; <br>cbT = lstrlenA(pprop-&gt;Value.MVszA.lppszA[iValue]) + 1; <br>CopyMemory(pb, pprop-&gt;Value.MVszA.lppszA[iValue], cbT); <br>pb += cbT; <br>cb += cbT; <br>} <br>cbT = (UINT)Align(cb); <br>pb += cbT - cb; <br>cb  = cbT; <br>continue;//already updated, don't do it again <br> <br>case PT_MV_UNICODE: <br>ppropDst-&gt;Value.MVszW.lppszW = (LPWSTR *) pb; <br>cbMV = pprop-&gt;Value.MVszW.cValues * sizeof(LPWSTR); <br>pb += cbMV; <br>cb += cbMV; <br>for (iValue = 0; <br>  (ULONG)iValue &lt; pprop-&gt;Value.MVszW.cValues; <br>  iValue++) <br>{ <br>ppropDst-&gt;Value.MVszW.lppszW[iValue] = (LPWSTR)pb; <br>cbT = (lstrlenW(pprop-&gt;Value.MVszW.lppszW[iValue]) + 1) <br>* sizeof(WCHAR); <br>CopyMemory(pb, pprop-&gt;Value.MVszW.lppszW[iValue], cbT); <br>pb += cbT; <br>cb += cbT; <br>} <br>cbT = (UINT)Align(cb); <br>pb += cbT - cb; <br>cb  = cbT; <br>continue;//already updated, don't do it again <br>} <br> <br>//Advance pointer and total count by the amount copied <br>cbT = Align(cbT); <br>pb += cbT; <br>cb += cbT; <br>} <br> <br>if (pcb) <br>{ <br>*pcb = cb; <br>} <br> <br>cleanup: <br>RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
