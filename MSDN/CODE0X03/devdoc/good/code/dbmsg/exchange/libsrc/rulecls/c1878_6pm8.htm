<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RULECLSF.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1880"></a>RULECLSF.CPP</h2>
<pre><code>// --ruleclsf.cpp------------------------------------------------------------- <br>// <br>//  Implementation file for the CFolderRules control class and its <br>//class factory. <br>// <br>//  The CFolderRules class is a controlling class.  It controls the <br>//  CIExchangeFolderRules class (which implements the IExchangeFolderRules  <br>//  programatic interface defined in rulecls.h).  When we add automation <br>//  capabilities, it will also control the standard OLE dispatch interface <br>//  for this class. <br>// <br>//  Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "srowlst.h" <br>#include "ruleclsf.h" <br>#include "ruleclsf.chk" <br> <br> <br>// $--CFolderRules::CFolderRules----------------------------------------------- <br>// <br>// DESCRIPTION:CFolderRules controlling class class constructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     Ptr to new CFolderRules instance. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CFolderRules::CFolderRules() <br>{ <br>    DEBUGPRIVATE("CFolderRules::CFolderRules().\n"); <br> <br>    m_hr =NOERROR;    // no error so far <br>    m_refs =1; <br>m_lpMapiTbl =NULL; <br>m_lpExchTbl =NULL; <br>m_lpFolder =NULL; <br> <br>    m_prog_interface = new CIExchangeFolderRules; <br> <br>    if ( m_prog_interface == NULL ) <br>    { <br>        m_hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Set programming interface ptr to this object. <br> <br>    m_prog_interface-&gt;m_pFR = this; <br> <br>cleanup: <br>     <br>    ;   // no operation <br>} <br> <br> <br>// $--CFolderRules::~CFolderRules---------------------------------------------- <br>// <br>// DESCRIPTION:CFolderRules controlling class class destructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CFolderRules::~CFolderRules() <br>{ <br>    DEBUGPRIVATE("CFolderRules::~CFolderRules().\n"); <br> <br>delete m_prog_interface; <br> <br>ULRELEASE(m_lpMapiTbl); <br>ULRELEASE(m_lpExchTbl); <br>ULRELEASE(m_lpFolder); <br>} <br> <br>// $--CFolderRules::Create----------------------------------------------------- <br>// <br>// DESCRIPTION:Create a new instance of the CFolderRules object. <br>//Also take care of setting up the standard OLE dispatch <br>//object pointer for the new instance. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     Ptr to new CFolderRules object on success; NULL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CFolderRules FAR * <br>CFolderRules::Create()// RETURNS CFolderRules pointer <br>{ <br>    CFolderRules FAR *pFolderRules =NULL; <br> <br>    DEBUGPRIVATE("CFolderRules::Create().\n"); <br> <br>    // Create an instance of CFolderRules. <br> <br>    pFolderRules = new FAR CFolderRules(); <br> <br>    if (pFolderRules == NULL) <br>    { <br>        HR_LOG(E_FAIL); <br>        pFolderRules = NULL; <br>        goto cleanup; <br>    } <br> <br>    if (FAILED(pFolderRules-&gt;m_hr)) <br>    { <br>        HR_LOG(pFolderRules-&gt;m_hr); <br>        ULRELEASE(pFolderRules); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    return pFolderRules;  <br>} <br> <br> <br>// $--CFolderRules::HrGetProviders--------------------------------------------- <br>// <br>// DESCRIPTION:Get an array of rules provider names. <br>// <br>// OUTPUT: <br>// <br>//  [lpcProviders]-- Pointer to ulong that will be set to count of <br>//   providers on successful return. <br>//[lpppszProviders]-- Pointer to array of string pointers that will be set <br>//   to point at an array of provider name string pointers <br>//   on successful return. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_OUTOFMEMORYif not enough memory; <br>//              E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CFolderRules::HrGetProviders(// RETURNS: HRESULT <br>OUTLPULONGlpcProviders,// count of providers <br>OUTLPSTR FAR * FAR *lpppszProviders// ptr to array of providers <br>) <br>{ <br>HRESULThr =NOERROR; <br> <br>    DEBUGPRIVATE("CFolderRules::HrGetProviders()\n"); <br> <br>if (m_lpFolder == NULL) <br>hr = E_FAIL; <br>else <br>hr = m_SRowLst.HrGetProviders(lpcProviders, lpppszProviders); <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--CFolderRules::HrOpen----------------------------------------------------- <br>// <br>// DESCRIPTION:Open the object on a rules folder. <br>// <br>// INPUT: <br>// <br>//  [lpMDB]-- Ptr to MDB object containing the rules folder. <br>//  [cbentryid]-- Number of bytes in folder's entry identifier. <br>//  [lpentryid]-- Folder's entry identifier. <br>//  [lpszProvider]-- Provider for rules.  Multiple providers may have <br>//   rules on a folder. The IExchangeFolderRules interface <br>//   provides access to the rules associated with a <br>//   single specified provider.  May be NULL, in which case <br>//   a provider list can be obtained, but no other operations <br>//   are possible. <br>// <br>// RETURNS:     NOERROR on success; <br>//              E_INVALIDARG if bad input; <br>//E_NOINTERFACE if the rules table does not exist on the folder; <br>//              E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CFolderRules::HrOpen(// RETURNS: HRESULT <br>INLPMDBlpMDB,// MDB store pointer <br>INULONGcbentryid,  // # bytes in entry ID <br>INLPENTRYIDlpentryid,// entry ID pointer <br>INLPSTRlpszProvider// provider name <br>) <br>{ <br>HRESULThr =NOERROR; <br>LPSRowSetlpRows =NULL; <br>ULONGulObjType =0; <br> <br>// NOTE: The following order of properties is assumed by lots <br>//       of other code (CFolderRules, CIExchangeFolderRules). <br> <br>    SizedSPropTagArray(C_RULEPROPS, rgPropTag) = <br>    { <br>    C_RULEPROPS, <br>    { <br>    PR_RULE_SEQUENCE, <br>    PR_RULE_STATE, <br>    PR_RULE_CONDITION, <br>    PR_RULE_ACTIONS, <br>    PR_RULE_PROVIDER, <br>PR_RULE_LEVEL, <br>PR_RULE_NAME <br>    } <br>    }; <br> <br>    DEBUGPRIVATE("CFolderRules::HrOpen()\n"); <br> <br>    hr = CHK_CFolderRules_HrOpen(lpMDB, cbentryid, lpentryid, lpszProvider); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>// Don't allow multiple opens on one object. <br> <br>if (m_lpFolder != NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Open the folder. <br> <br>hr = lpMDB-&gt;OpenEntry(cbentryid, <br>  lpentryid, <br>  NULL, <br>  MAPI_BEST_ACCESS| <br>  MAPI_DEFERRED_ERRORS, <br>  &amp;ulObjType, <br>  (LPUNKNOWN FAR *)&amp;m_lpFolder); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>if (ulObjType != MAPI_FOLDER) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>    // Open the RULE table property on the folder.  The returned table <br>// pointer may be used to get a MAPI table for reading and it can <br>// also be used to modify the rules table.  If there is no rules table, <br>// this call will fail with E_NOINTERFACE. <br> <br>    hr = m_lpFolder-&gt;OpenProperty(PR_RULES_TABLE, <br>  (LPGUID)&amp;IID_IExchangeModifyTable, <br>  0, <br>  MAPI_DEFERRED_ERRORS, <br>  (LPUNKNOWN FAR *)&amp;m_lpExchTbl); <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>    // Open a MAPI table on the RULE table property.  This table can be <br>// read to determine what the rules table looks like. <br>     <br>    hr = m_lpExchTbl-&gt;GetTable(0, &amp;m_lpMapiTbl); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// Select columns needed. <br> <br>hr = m_lpMapiTbl-&gt;SetColumns((LPSPropTagArray)&amp;rgPropTag, 0); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// Get all the rows in the table up to EDK_MAX_QUERY_ROWS.  If there <br>// are more rows than this, fail with MAPI_E_TABLE_TOO_BIG. <br> <br>hr = m_lpMapiTbl-&gt;QueryRows(EDK_MAX_QUERY_ROWS, 0, &amp;lpRows); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// Check to be sure that table is not bigger than EDK_MAX_QUERY_ROWS. <br>// We do this by checking whether or not the cursor is positioned at <br>// the end of the table. <br> <br>if (lpRows-&gt;cRows == EDK_MAX_QUERY_ROWS) <br>{ <br>ULONGulRow =0; <br>ULONGulNumerator =0; <br>ULONGulDenominator =0; <br> <br>hr = m_lpMapiTbl-&gt;QueryPosition(&amp;ulRow, &amp;ulNumerator, &amp;ulDenominator); <br> <br>if (FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>        } <br> <br>// SeekRowApprox() doc states that if ulNumerator == ulDenominator, you <br>// are at the end of the table. <br> <br>if (ulNumerator != ulDenominator) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>// Store the table in a sorted and more manageable format. <br> <br>hr = m_SRowLst.HrInitialize(lpszProvider, lpRows); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>// NOTE - lpRows gets deallocated in SROWLST::Initialize().  We NULL it <br>//  out here as a safeguard against future use. <br> <br>lpRows = NULL; <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>{ <br>ULRELEASE(m_lpMapiTbl); <br>ULRELEASE(m_lpExchTbl); <br>ULRELEASE(m_lpFolder); <br>} <br> <br>    RETURN(hr);  <br>} <br> <br>//--------------------------------------------------------------------- <br>//                        IUnknown methods <br>//--------------------------------------------------------------------- <br> <br>// $--CFolderRules::QueryInterface--------------------------------------------- <br>// <br>// DESCRIPTION:Return pointer to object which implements the desired <br>//interface, if this object supports the interface. <br>// <br>// INPUT: <br>// <br>//  [riid]-- Reference to interface identifier of desired interface. <br>// <br>//  [ppv]-- Ptr to object which supports interface.  NULL if none. <br>// <br>// RETURNS:     NOERROR if successful; <br>//E_INVALIDARG if bad input. <br>//E_NOINTERFACE if interface isn't supported. <br>// <br>//  Interfaces supported: <br>//       <br>//      IUnknown <br>//      IDispatch   (eventually) <br>//      IExchangeFolderRules <br>//      DFolderRules (eventually) <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CFolderRules::QueryInterface(// RETURNS: HRESULT <br>INREFIIDriid,   // interface ID reference <br>OUTLPVOID FAR *ppv     // pointer to interface pointer <br>) <br>{ <br>    HRESULT hr =NOERROR; <br> <br>    DEBUGPRIVATE("CFolderRules::QueryInterface().\n"); <br> <br>    hr = CHK_CFolderRules_QueryInterface(riid, ppv); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    *ppv = NULL; <br> <br>    // See if we support the requested interface. <br> <br>    if (IsEqualIID(riid, IID_IUnknown))   // IUnknown interface is ourself <br>{ <br>    *ppv = this;    // Return ourself <br>} <br>    else if (IsEqualIID(riid, IID_IExchangeFolderRules)) <br>    { <br>        // User wants our programatic interface. <br> <br>    *ppv = m_prog_interface; <br>    } <br>    else  <br>    { <br>        // We don't support the requested interface. <br> <br>      *ppv = NULL; <br>        hr = HR_LOG(E_NOINTERFACE); <br>        goto cleanup; <br>    } <br> <br>    // If we reach this point, no error occurred.  Increment reference count. <br> <br>    AddRef(); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CFolderRules::AddRef----------------------------------------------------- <br>// <br>// DESCRIPTION:Increment the reference count on this object. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     New reference count. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CFolderRules::AddRef()// RETURNS: ULONG <br>{ <br>    DEBUGPRIVATE("CFolderRules::AddRef().\n"); <br> <br>    ASSERTERROR(m_refs, "Bad m_refs."); <br> <br>    m_refs++; <br> <br>    return m_refs; <br>} <br> <br> <br>// $--CFolderRules::Release---------------------------------------------------- <br>// <br>// DESCRIPTION:Decrement the reference count on this object.  If the <br>//reference count reaches 0, destroy this object. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     New reference count. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CFolderRules::Release()// RETURNS: ULONG <br>{ <br>    ULONG   ulRefCount =0; <br> <br>    DEBUGPRIVATE("CFolderRules::Release().\n"); <br> <br>    ASSERTERROR(m_refs, "Bad m_refs."); <br> <br>    m_refs--; <br> <br>    if (!m_refs) <br>    { <br>        delete this; <br>        ulRefCount = 0; <br>    } <br>    else <br>    { <br>        ulRefCount = m_refs; <br>    } <br> <br>    return ulRefCount; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
