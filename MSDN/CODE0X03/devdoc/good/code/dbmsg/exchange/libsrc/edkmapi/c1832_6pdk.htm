<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ISTORE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1838"></a>ISTORE.C</h2>
<pre><code>// --istore.c------------------------------------------------------------------- <br>//  <br>//  Module containing MAPI utility functions for message stores. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br> <br>#include "istore.chk" <br> <br>// $--HrMAPIFindStore@---------------------------------------------------------- <br>// <br>// DESCRIPTION:Find an MDB store based on a string. <br>// <br>// INPUT: <br>// <br>//  [lpSession]-- MAPI session ptr. <br>//  [lpszStore]-- Store name (PR_DISPLAY_NAME). <br>// <br>// OUTPUT: <br>// <br>//  [lpcbentryid]-- Number of bytes in store's entry identifier. <br>//  [lppentryid]-- Ptr to store entry identifier. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif not enough memory; <br>//EDK_E_NOT_FOUNDif specified store not found; <br>//              E_FAILotherwise. <br>// <br>//--------------------------------------------------------------------------- <br>HRESULT HrMAPIFindStoreW( <br>INLPMAPISESSIONlpSession,  // MAPI session ptr <br>INLPCWSTRlpszStore,  // store name <br>OUTULONG FAR *lpcbentryid,    // ptr to # byte in entry ID <br>OUTLPENTRYID FAR *lppentryid)// entry ID buffer ptr <br>{ <br>    HRESULThr           = NOERROR; <br>    LPSTR           lpszStoreA   = NULL; <br> <br>DEBUGPUBLIC( "HrMAPIFindStoreW()"); <br> <br>    hr = CHK_HrMAPIFindStoreW( lpSession, lpszStore, lpcbentryid, lppentryid); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>// Because MAPI doesn't officially support UNICODE strings, we are forced <br>    // to do a string conversion and call the other function... <br>hr = HrStrWToStrA( lpszStore, &amp;lpszStoreA); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    hr = HrMAPIFindStoreA( lpSession, lpszStoreA, lpcbentryid, lppentryid); <br> <br>cleanup: <br>MAPIFREEBUFFER( lpszStoreA); <br> <br>    RETURN(hr); <br>} <br> <br>HRESULT HrMAPIFindStoreA( <br>INLPMAPISESSIONlpSession,  // MAPI session ptr <br>INLPCSTRlpszStore,  // store name <br>OUTULONG FAR *lpcbentryid,    // ptr to # byte in entry ID <br>OUTLPENTRYID FAR *lppentryid)// entry ID buffer ptr <br>{ <br>    HRESULThr           = NOERROR; <br>LPMAPITABLElpTable      = NULL; <br>LPSRowSetlpRow        = NULL; <br>    LPSPropValue    lpProp       = NULL; <br> <br>    static SizedSPropTagArray( 1, EntryID) = { 1, { PR_ENTRYID}}; <br>    static SPropValue RestrictProp = { PR_DISPLAY_NAME_A, 0L, { 0}}; <br>    static SRestriction Restriction = { RES_PROPERTY, { RELOP_EQ, PR_DISPLAY_NAME_A, (ULONG)&amp;RestrictProp}}; <br>     <br>DEBUGPUBLIC( "HrMAPIFindStoreA()"); <br> <br>    hr = CHK_HrMAPIFindStoreA( lpSession, lpszStore, lpcbentryid, lppentryid); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Set name of the store name to find. <br>    RestrictProp.Value.lpszA = (LPSTR)lpszStore; <br> <br>hr = MAPICALL( lpSession)-&gt;GetMsgStoresTable( lpSession, <br>        0L, &amp;lpTable); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>goto cleanup; <br>    } <br> <br>    hr = HrQueryAllRows( <br>        lpTable, (LPSPropTagArray)&amp;EntryID,  <br>        &amp;Restriction, NULL, 0, &amp;lpRow); <br>if( FAILED( hr)) <br>    { <br>        if( hr == MAPI_E_NOT_FOUND) <br>            hr = HR_LOG( EDK_E_NOT_FOUND); <br>        else <br>            hr = HR_LOG( E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    if (lpRow == NULL || lpRow-&gt;cRows != 1) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    lpProp = &amp;lpRow-&gt;aRow[0].lpProps[0]; <br> <br>hr = MAPIAllocateBuffer(lpProp-&gt;Value.bin.cb, (LPVOID FAR *)lppentryid); <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>memcpy(*lppentryid, lpProp-&gt;Value.bin.lpb, lpProp-&gt;Value.bin.cb); <br>*lpcbentryid = lpProp-&gt;Value.bin.cb; <br> <br>cleanup: <br>FREEPROWS(lpRow); <br>ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br>} <br> <br>//$--HrMAPIFindDefaultMsgStore---------------------------------------------------- <br>//  Get the entry ID of the default message store. <br>// ----------------------------------------------------------------------------- <br>HRESULT HrMAPIFindDefaultMsgStore(    // RETURNS: return code <br>    IN LPMAPISESSION lplhSession,   // session pointer <br>    OUT ULONG *lpcbeid,             // count of bytes in entry ID <br>    OUT LPENTRYID *lppeid)          // entry ID of default store <br>{    <br>    HRESULT     hr      = NOERROR; <br>    HRESULT     hrT     = NOERROR; <br>    SCODE       sc      = 0; <br>    LPMAPITABLE lpTable = NULL; <br>    LPSRowSet   lpRows  = NULL; <br>    LPENTRYID   lpeid   = NULL; <br>    ULONG       cbeid   = 0; <br>    ULONG       cRows   = 0; <br>    ULONG       i       = 0; <br> <br>    SizedSPropTagArray(2, rgPropTagArray) = <br>    { <br>        2, <br>        { <br>            PR_DEFAULT_STORE, <br>            PR_ENTRYID <br>        } <br>    }; <br> <br>    DEBUGPUBLIC("HrMAPIFindDefaultMsgStore()\n"); <br> <br>    hr = CHK_HrMAPIFindDefaultMsgStore( <br>        lplhSession, <br>        lpcbeid, <br>        lppeid); <br> <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Get the list of available message stores from MAPI <br> <br>    hrT = MAPICALL(lplhSession)-&gt;GetMsgStoresTable(lplhSession, 0, &amp;lpTable); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Get the row count for the message recipient table <br>    hrT = MAPICALL(lpTable)-&gt;GetRowCount(lpTable, 0, &amp;cRows); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Set the columns to return <br>    hrT = MAPICALL(lpTable)-&gt;SetColumns(lpTable, (LPSPropTagArray)&amp;rgPropTagArray, 0); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Go to the beginning of the recipient table for the envelope <br>    hrT = MAPICALL(lpTable)-&gt;SeekRow(lpTable, BOOKMARK_BEGINNING, 0, NULL); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Read all the rows of the table <br>    hrT = MAPICALL(lpTable)-&gt;QueryRows(lpTable, cRows, 0, &amp;lpRows); <br> <br>    if(SUCCEEDED(hrT) &amp;&amp; (lpRows != NULL) &amp;&amp; (lpRows-&gt;cRows == 0)) <br>    { <br>        FREEPROWS(lpRows); <br> <br>        hrT = EDK_E_NOT_FOUND; <br>    } <br> <br>    if(FAILED(hrT) || (lpRows == NULL)) <br>    { <br>        if(hrT != EDK_E_NOT_FOUND) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(EDK_E_NOT_FOUND); <br>        } <br> <br>        goto cleanup; <br>    } <br> <br> <br>    for(i = 0; i &lt; cRows; i++) <br>    { <br>        if(lpRows-&gt;aRow[i].lpProps[0].Value.b == TRUE) <br>        { <br>            cbeid = lpRows-&gt;aRow[i].lpProps[1].Value.bin.cb; <br> <br>            sc = MAPIAllocateBuffer(cbeid, (void **)&amp;lpeid); <br> <br>            if(FAILED(sc)) <br>            { <br>                cbeid = 0; <br>                lpeid = NULL; <br> <br>                hr = HR_LOG(E_OUTOFMEMORY); <br>                goto cleanup; <br>            } <br> <br>            // Copy entry ID of message store <br>            CopyMemory( <br>                lpeid, <br>                lpRows-&gt;aRow[i].lpProps[1].Value.bin.lpb, <br>                cbeid); <br> <br>            break; <br>        } <br>    } <br> <br>    if(lpeid == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>    } <br> <br>    ASSERTERROR(cbeid != 0, "ZERO cbeid variable"); <br> <br>    ASSERT_READ_PTR(lpeid, cbeid, "INVALID lpeid variable"); <br> <br>cleanup: <br> <br>    if(lpRows != NULL) <br>    { <br>        FreeProws(lpRows); <br>    } <br> <br>    ULRELEASE(lpTable); <br> <br>    *lpcbeid = cbeid; <br>    *lppeid = lpeid; <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--FIsPublicStore------------------------------------------------------------ <br>//  Returns TRUE if the MDB is a public store. <br>// ----------------------------------------------------------------------------- <br>BOOL FIsPublicStore( <br>    IN LPMDB lpmdb)                     // pointer to message store <br>     <br>{ <br>    BOOL          bIsPublic   = FALSE; <br>    HRESULT       hrT         = NOERROR; <br>    ULONG         cValues     = 0; <br>    LPSPropValue  lpPropValue = NULL; <br>    ULONG         cbeid       = 0; <br> <br>    static SPropTagArray rgPropTag = { 1, { PR_MDB_PROVIDER } }; <br>     <br>    DEBUGPUBLIC( "FIsPublicStore()"); <br> <br>    hrT = CHK_FIsPublicStore( lpmdb); <br>    if(FAILED(hrT)) <br>        return(FALSE); <br> <br>    // Get the property.  <br>    hrT = MAPICALL(lpmdb)-&gt;GetProps( lpmdb, <br>        &amp;rgPropTag, <br>        fMapiUnicode, <br>        &amp;cValues, <br>        &amp;lpPropValue); <br> <br>    if(FAILED(hrT) || hrT == MAPI_W_ERRORS_RETURNED) <br>    { <br>        HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ASSERTERROR(cValues != 0, "ZERO cValues variable"); <br> <br>    ASSERTERROR(lpPropValue != NULL, "NULL lpPropValue variable"); <br> <br>    // Check to make sure we got the right property. <br>    if (lpPropValue-&gt;ulPropTag != PR_MDB_PROVIDER) <br>    { <br>        HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // See if PR_MDB_PROVIDER == pbExchangeProviderPublicGuid <br> <br>    if ( (lpPropValue-&gt;Value.bin.cb == sizeof(GUID)) &amp;&amp; <br>         (memcmp(lpPropValue-&gt;Value.bin.lpb, <br>            pbExchangeProviderPublicGuid, sizeof(GUID)) == 0) ) <br>    { <br>         bIsPublic = TRUE; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropValue); <br> <br>    return(bIsPublic); <br>} <br> <br>//$--_HrOpenStoreFromGuid------------------------------------------------------- <br>//  Locates the store provider based on GUID and returns open interface pointer <br>//------------------------------------------------------------------------------ <br>HRESULT _HrOpenStoreFromGuid ( <br>    IN  LPMAPISESSION lphSession, <br>    IN  LPGUID        pbStoreProviderGuid, <br>    OUT LPMDB        *lppMDB) <br>{ <br>    HRESULT       hr         = NOERROR; <br>    HRESULT       hrT        = NOERROR; <br>    LPMAPITABLE   lpTable    = NULL; <br>    LPSRowSet     lpRows     = NULL; <br> <br>    static SPropTagArray aptEntryID = { 1, { PR_ENTRYID } }; <br>    static SPropValue    SProp = { PR_MDB_PROVIDER, 0L, { 0}}; <br>    static SRestriction  SRestrict = { RES_PROPERTY, <br>        { RELOP_EQ, PR_MDB_PROVIDER, (LONG)&amp;SProp } }; <br>     <br>    DEBUGPRIVATE("_HrOpenStoreFromGuid()"); <br> <br>    hr = CHK_HrOpenStoreFromGuid( lphSession, pbStoreProviderGuid, lppMDB); <br>    if(FAILED(hr)) <br>        RETURN(hr); <br> <br>    // Clear return value <br> <br>    *lppMDB = NULL; <br> <br>    // Get table of message stores <br> <br>    hrT = MAPICALL(lphSession)-&gt;GetMsgStoresTable(lphSession, 0, &amp;lpTable); <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Restrict the table to the appropriate Exchange store <br>    SProp.Value.bin.cb  = sizeof(GUID); <br>    SProp.Value.bin.lpb = (LPBYTE)pbStoreProviderGuid; <br> <br>    hrT = HrQueryAllRows( lpTable, &amp;aptEntryID, &amp;SRestrict, NULL, 0L, &amp;lpRows); <br>    if(FAILED(hrT) || (lpRows-&gt;cRows == 0)) <br>    { <br>        if((hrT == MAPI_E_NOT_FOUND) || <br>           ((hrT == SUCCESS_SUCCESS) &amp;&amp; (lpRows-&gt;cRows == 0))) <br>        { <br>            hr = HR_LOG(EDK_E_NOT_FOUND); <br>        } <br>        else <br>        { <br>            hr = HR_LOG(E_FAIL); <br>        } <br> <br>        goto cleanup; <br>    } <br> <br>    if((lpRows-&gt;aRow-&gt;cValues != 1) ||  <br>        (lpRows-&gt;aRow-&gt;lpProps[0].ulPropTag != PR_ENTRYID)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Open the message store  <br> <br>    hrT = MAPICALL(lphSession)-&gt;OpenMsgStore( <br>        lphSession, <br>        (ULONG)0, <br>        lpRows-&gt;aRow-&gt;lpProps[0].Value.bin.cb, <br>        (LPENTRYID)lpRows-&gt;aRow-&gt;lpProps[0].Value.bin.lpb, <br>        NULL, <br>        MAPI_BEST_ACCESS, <br>        lppMDB); <br> <br>    if(FAILED(hrT)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    FREEPROWS(lpRows); <br> <br>    ULRELEASE(lpTable); <br> <br>    RETURN(hr); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
