<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACLCLSF.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1815"></a>ACLCLSF.CPP</h2>
<pre><code>// --aclclsf.cpp--------------------------------------------------------------- <br>// <br>//  Implementation file for the CFolderACLs control class and its <br>//class factory. <br>// <br>//  The CFolderACLs class is a controlling class.  It controls the <br>//  CIExchangeFolderACLs class (which implements the IExchangeFolderACLs  <br>//  programatic interface defined in aclcls.h).  When we add automation <br>//  capabilities, it will also control the standard OLE dispatch interface <br>//  for this class. <br>// <br>//  Copyright (C) Microsoft Corp. 1986-1996.  All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "srowlst.h" <br>#include "aclclsf.h" <br>#include "aclclsf.chk" <br> <br>// $--CFolderACLs::CFolderACLs------------------------------------------------- <br>// <br>// DESCRIPTION:CFolderACLs controlling class class constructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     Ptr to new CFolderACLs instance. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CFolderACLs::CFolderACLs() <br>{ <br>    DEBUGPRIVATE("CFolderACLs::CFolderACLs().\n"); <br> <br>    m_hr =NOERROR;    // no error so far <br>    m_refs =1; <br>m_lpMapiTbl =NULL; <br>m_lpExchTbl =NULL; <br>m_lpFolder =NULL; <br> <br>    m_prog_interface = new CIExchangeFolderACLs; <br> <br>    if (m_prog_interface == NULL) <br>    { <br>        m_hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // Set programming interface ptr to this object. <br> <br>    m_prog_interface-&gt;m_pFA = this; <br> <br>    m_lpSession = NULL; <br> <br>cleanup: <br>     <br>    ;   // no operation <br>} <br> <br> <br>// $--CFolderACLs::~CFolderACLs------------------------------------------------ <br>// <br>// DESCRIPTION:CFolderACLs controlling class class destructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CFolderACLs::~CFolderACLs() <br>{ <br>    DEBUGPRIVATE("CFolderACLs::~CFolderACLs().\n"); <br> <br>delete m_prog_interface; <br> <br>    ULRELEASE(m_lpSession); <br>ULRELEASE(m_lpMapiTbl); <br>ULRELEASE(m_lpExchTbl); <br>ULRELEASE(m_lpFolder); <br>} <br> <br>// $--CFolderACLs::Create------------------------------------------------------ <br>// <br>// DESCRIPTION:Create a new instance of the CFolderACLs object. <br>//Also take care of setting up the standard OLE dispatch <br>//object ptr for the new instance. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     Ptr to new CFolderACLs object on success; NULL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CFolderACLs FAR * <br>CFolderACLs::Create()// RETURNS CFolderACLs ptr <br>{ <br>    CFolderACLs FAR *pFolderACLs =NULL; <br> <br>    DEBUGPRIVATE("CFolderACLs::Create().\n"); <br> <br>    // Create an instance of CFolderACLs. <br> <br>    pFolderACLs = new FAR CFolderACLs(); <br> <br>    if (pFolderACLs == NULL) <br>    { <br>        HR_LOG(E_FAIL); <br>        pFolderACLs = NULL; <br>        goto cleanup; <br>    } <br> <br>    if (FAILED(pFolderACLs-&gt;m_hr)) <br>    { <br>        HR_LOG(pFolderACLs-&gt;m_hr); <br>        ULRELEASE(pFolderACLs); <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    return pFolderACLs;  <br>} <br> <br> <br>// $--CFolderACLs::HrGetTableEntry--------------------------------------------- <br>// <br>// DESCRIPTION:Get a IExchangeModifyTable ACL table entry using the entryid. <br>// <br>// INPUT: <br>// <br>//   [cbentryid]--  Count of bytes in member entry ID. <br>//   [lpentryid]--  Ptr to member entry ID. <br>// <br>// OUTPUT: <br>// <br>//   [lppszDisplayName]--  Member display name buffer (set to NULL if not <br>//wanted). <br>//   [lplRights]--  ACL rights bits buffer. <br>// <br>// RETURNS:     NOERRORon success; <br>//EDK_E_NOT_FOUNDif not found; <br>//              E_FAILotherwise. <br>// <br>// Notes:We use this method to examine the table entries to see if a <br>//requested action was actually completed.  IExchangeModifyTable <br>//code may reset rights, readd entries, etc., so we have to check. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CFolderACLs::HrGetTableEntry(// RETURNS: HRESULT <br>INULONGcbentryid,// # of bytes in entry ID <br>INLPENTRYIDlpentryid,// entry ID ptr <br>OUTLPSTR FAR *lppszDisplayName,// display name ptr <br>OUTLPLONGlplRights// rights ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>ULONGi =0; <br>LPMAPITABLElpMapiTbl =NULL; <br>LPSRowlpRow =NULL; <br>LPSRowSetlpRows =NULL; <br>    LPADRBOOK       lpAdrBook =     NULL; <br>    ULONG           ulResult =      FALSE; <br> <br>// NOTE: The following order of properties is assumed by lots <br>//       of other code (CFolderACLs, CIExchangeFolderACLs).  <br> <br>    SizedSPropTagArray(C_ACLPROPS, rgPropTag) = <br>    { <br>    C_ACLPROPS, <br>    { <br>    PR_MEMBER_ENTRYID, <br>    PR_MEMBER_RIGHTS, <br>    PR_MEMBER_NAME <br>    } <br>    }; <br> <br>    DEBUGPRIVATE("CFolderACLs::HrGetTableEntry()\n"); <br> <br>if (lppszDisplayName != NULL) <br>*lppszDisplayName = NULL; <br> <br>    hr = m_lpSession-&gt;OpenAddressBook( <br>        0, <br>        NULL,  <br>        AB_NO_DIALOG, <br>        &amp;lpAdrBook); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // Open a MAPI table on the ACL table property.  This table can be <br>// read to determine what the ACLs table looks like. <br>     <br>    hr = m_lpExchTbl-&gt;GetTable(0, &amp;lpMapiTbl); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>// Select columns needed. <br> <br>hr = lpMapiTbl-&gt;SetColumns((LPSPropTagArray)&amp;rgPropTag, 0); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// Get all the rows in the table up to EDK_MAX_QUERY_ROWS.  If there <br>// are more rows than this, fail with MAPI_E_TABLE_TOO_BIG. <br> <br>hr = lpMapiTbl-&gt;QueryRows(EDK_MAX_QUERY_ROWS, 0, &amp;lpRows); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// Check to be sure that table is not bigger than EDK_MAX_QUERY_ROWS. <br>// We do this by checking whether or not the cursor is positioned at <br>// the end of the table. <br> <br>if (lpRows-&gt;cRows == EDK_MAX_QUERY_ROWS) <br>{ <br>ULONGulRow =0; <br>ULONGulNumerator =0; <br>ULONGulDenominator =0; <br> <br>hr = lpMapiTbl-&gt;QueryPosition(&amp;ulRow, &amp;ulNumerator, &amp;ulDenominator); <br> <br>if (FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>        } <br> <br>// SeekRowApprox() doc states that if ulNumerator == ulDenominator, you <br>// are at the end of the table. <br> <br>if (ulNumerator != ulDenominator) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>// Search for the entry and return values. <br> <br>for (i = 0; i &lt; lpRows-&gt;cRows; i++) <br>{ <br>lpRow = &amp;lpRows-&gt;aRow[i]; <br> <br>if (lpRow-&gt;lpProps[I_MEMBER_ENTRYID].ulPropTag == PR_MEMBER_ENTRYID&amp;&amp; <br>lpRow-&gt;lpProps[I_MEMBER_ENTRYID].Value.bin.cb == cbentryid) <br>{ <br>// When we pass in an entryid to IExchangeModifyTable, it upcases <br>// any embedded distinguisheed names.  We therefore have to use <br>// a case insensitive compare.  Can't guarantee it won't <br>// misidentify something, but the odds seem pretty long, and this <br>// is the only way we can get around this IExchangeModifyTable <br>// feature (since they also don't guarantee that table position <br>// will be maintained). <br> <br>            hr = lpAdrBook-&gt;CompareEntryIDs( <br>                lpRow-&gt;lpProps[I_MEMBER_ENTRYID].Value.bin.cb, <br>                (LPENTRYID)(lpRow-&gt;lpProps[I_MEMBER_ENTRYID].Value.bin.lpb), <br>                cbentryid, <br>                lpentryid, <br>                0, <br>                &amp;ulResult); <br> <br>            if(SUCCEEDED(hr) &amp;&amp; (ulResult == TRUE)) <br>{ <br>// Found the match! Make sure you have values available, and <br>// then return them. <br> <br>if (lpRow-&gt;cValues &lt; C_ACLPROPS|| <br>lpRow-&gt;lpProps[I_MEMBER_RIGHTS].ulPropTag != <br>PR_MEMBER_RIGHTS|| <br>lpRow-&gt;lpProps[I_MEMBER_NAME].ulPropTag != <br>PR_MEMBER_NAME) <br>{ <br>hr = HR_LOG(E_UNEXPECTED); // Data from mdb is invalid! <br>goto cleanup; <br>} <br> <br>*lplRights = lpRow-&gt;lpProps[I_MEMBER_RIGHTS].Value.l; <br> <br>if (lppszDisplayName != NULL) <br>{ <br>if (lpRow-&gt;lpProps[I_MEMBER_NAME].Value.lpszA != NULL) <br>{ <br>ULONG cb = <br>strlen(lpRow-&gt;lpProps[I_MEMBER_NAME].Value.lpszA) + <br> sizeof(char); <br> <br>hr = MAPIAllocateBuffer(strlen(lpRow-&gt; <br>lpProps[I_MEMBER_NAME].Value.lpszA) + <br>sizeof(char), <br>(LPVOID FAR *)lppszDisplayName); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>strcpy(*lppszDisplayName, <br>   lpRow-&gt;lpProps[I_MEMBER_NAME].Value.lpszA); <br>} <br>} <br> <br>goto cleanup;// Success! <br>} <br>} <br>} <br> <br>hr = HR_LOG(EDK_E_NOT_FOUND); // Not found! <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>{ <br>if (lppszDisplayName != NULL) <br>MAPIFREEBUFFER(*lppszDisplayName); <br>} <br> <br>FREEPROWS(lpRows); <br>ULRELEASE(lpMapiTbl); <br>    ULRELEASE(lpAdrBook); <br> <br>    RETURN(hr);  <br>} <br> <br> <br>// $--CFolderACLs::HrOpen------------------------------------------------------ <br>// <br>// DESCRIPTION:Open the object on a ACLs folder. <br>// <br>// INPUT: <br>// <br>//  [lpMDB]-- Ptr to MDB object containing the ACLs folder. <br>//  [cbentryid]-- Number of bytes in folder's entry identifier. <br>//  [lpentryid]-- Folder's entry identifier. <br>// <br>// RETURNS:     NOERROR on success; <br>//              E_INVALIDARG if bad input; <br>//E_NOINTERFACE if acl table does not exist on folder; <br>//              E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CFolderACLs::HrOpen(// RETURNS: HRESULT <br>    IN      LPMAPISESSION   lpSession,  // MAPI session pointer <br>INLPMDBlpMDB,// MDB store ptr <br>INULONGcbentryid,  // # bytes in entry ID <br>INLPENTRYIDlpentryid   // entry ID ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>LPSRowSetlpRows =NULL; <br>ULONGulObjType =0; <br> <br>// NOTE: The following order of properties is assumed by lots <br>//       of other code (CFolderACLs, CIExchangeFolderACLs).  We place the <br>// member name last so we can drop it when we write the ACL's <br>// back (in ModifyTable()). <br> <br>    SizedSPropTagArray(C_ACLPROPS, rgPropTag) = <br>    { <br>    C_ACLPROPS, <br>    { <br>    PR_MEMBER_ENTRYID, <br>    PR_MEMBER_RIGHTS, <br>    PR_MEMBER_NAME <br>    } <br>    }; <br> <br>    DEBUGPRIVATE("CFolderACLs::HrOpen()\n"); <br> <br>    hr = CHK_CFolderACLs_HrOpen(lpMDB, cbentryid, lpentryid); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>// Don't allow multiple opens on one object. <br> <br>if (m_lpFolder != NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>    // AddRef the MAPI session pointer <br> <br>    lpSession-&gt;AddRef(); <br> <br>    m_lpSession = lpSession; <br> <br>// Open the folder. <br> <br>hr = lpMDB-&gt;OpenEntry(cbentryid, <br>  lpentryid, <br>  NULL, <br>  MAPI_BEST_ACCESS| <br>  MAPI_DEFERRED_ERRORS, <br>  &amp;ulObjType, <br>  (LPUNKNOWN FAR *)&amp;m_lpFolder); <br> <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>if (ulObjType != MAPI_FOLDER) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>    // Open the ACL table property on the folder.  The returned table <br>// ptr may be used to get a MAPI table for reading and it can <br>// also be used to modify the ACLs table.  If there is no acl table, <br>// this call will fail with E_NOINTERFACE. <br> <br>    hr = m_lpFolder-&gt;OpenProperty(PR_ACL_TABLE, <br>  (LPGUID)&amp;IID_IExchangeModifyTable, <br>  0, <br>  MAPI_DEFERRED_ERRORS, <br>  (LPUNKNOWN FAR *)&amp;m_lpExchTbl); <br> <br>    if (FAILED(hr)) <br>goto cleanup; <br> <br>    // Open a MAPI table on the ACL table property.  This table can be <br>// read to determine what the ACLs table looks like. <br>     <br>    hr = m_lpExchTbl-&gt;GetTable(0, &amp;m_lpMapiTbl); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// Select columns needed. <br> <br>hr = m_lpMapiTbl-&gt;SetColumns((LPSPropTagArray)&amp;rgPropTag, 0); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// Get all the rows in the table up to EDK_MAX_QUERY_ROWS.  If there <br>// are more rows than this, fail with MAPI_E_TABLE_TOO_BIG. <br> <br>hr = m_lpMapiTbl-&gt;QueryRows(EDK_MAX_QUERY_ROWS, 0, &amp;lpRows); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// Check to be sure that table is not bigger than EDK_MAX_QUERY_ROWS. <br>// We do this by checking whether or not the cursor is positioned at <br>// the end of the table. <br> <br>if (lpRows-&gt;cRows == EDK_MAX_QUERY_ROWS) <br>{ <br>ULONGulRow =0; <br>ULONGulNumerator =0; <br>ULONGulDenominator =0; <br> <br>hr = m_lpMapiTbl-&gt;QueryPosition(&amp;ulRow, &amp;ulNumerator, &amp;ulDenominator); <br> <br>if (FAILED(hr)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>        } <br> <br>// SeekRowApprox() doc states that if ulNumerator == ulDenominator, you <br>// are at the end of the table. <br> <br>if (ulNumerator != ulDenominator) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>// Store the table in a sorted and more manageable format. <br> <br>hr = m_SRowLst.HrInitialize(lpRows); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>// NOTE - lpRows gets deallocated in SROWLST::Initialize().  We NULL it <br>//  out here as a safeguard against future use. <br> <br>lpRows = NULL; <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>{ <br>        ULRELEASE(m_lpSession); <br>ULRELEASE(m_lpMapiTbl); <br>ULRELEASE(m_lpExchTbl); <br>ULRELEASE(m_lpFolder); <br>} <br> <br>    RETURN(hr);  <br>} <br> <br>//--------------------------------------------------------------------- <br>//                        IUnknown methods <br>//--------------------------------------------------------------------- <br> <br>// $--CFolderACLs::QueryInterface------------------------------------------ <br>// <br>// DESCRIPTION:Return ptr to object which implements the desired <br>//interface, if this object supports the interface. <br>// <br>// INPUT: <br>// <br>//  [riid]-- Reference to interface identifier of desired interface. <br>// <br>//  [ppv]-- Ptr to object which supports interface.  NULL if none. <br>// <br>// RETURNS:     NOERROR if successful; <br>//E_INVALIDARG if bad input. <br>//E_NOINTERFACE if interface isn't supported. <br>// <br>//  Interfaces supported: <br>//       <br>//      IUnknown <br>//      IDispatch   (eventually) <br>//      IExchangeFolderACLs <br>//      DFolderACLs (eventually) <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CFolderACLs::QueryInterface(// RETURNS: HRESULT <br>INREFIIDriid,   // interface ID reference <br>OUTLPVOID FAR *ppv     // interface ptr ptr <br>) <br>{ <br>    HRESULT hr =NOERROR; <br> <br>    DEBUGPRIVATE("CFolderACLs::QueryInterface().\n"); <br> <br>    hr = CHK_CFolderACLs_QueryInterface(riid, ppv); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    *ppv = NULL; <br> <br>    // See if we support the requested interface. <br> <br>    if (IsEqualIID(riid, IID_IUnknown))   // IUnknown interface is ourself <br>{ <br>    *ppv = this;    // Return ourself <br>} <br>    else if (IsEqualIID(riid, IID_IExchangeFolderACLs)) <br>    { <br>        // User wants our programatic interface. <br> <br>    *ppv = m_prog_interface; <br>    } <br>    else  <br>    { <br>        // We don't support the requested interface. <br> <br>      *ppv = NULL; <br>        hr = HR_LOG(E_NOINTERFACE); <br>        goto cleanup; <br>    } <br> <br>    // If we reach this point, no error occurred.  Increment reference count. <br> <br>    AddRef(); <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CFolderACLs::AddRef-------------------------------------------------- <br>// <br>// DESCRIPTION:Increment the reference count on this object. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     New reference count. <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CFolderACLs::AddRef()// RETURNS: ULONG <br>{ <br>    DEBUGPRIVATE("CFolderACLs::AddRef().\n"); <br> <br>    ASSERTERROR(m_refs, "Bad m_refs."); <br> <br>    m_refs++; <br> <br>    return m_refs; <br>} <br> <br> <br>// $--CFolderACLs::Release------------------------------------------------- <br>// <br>// DESCRIPTION:Decrement the reference count on this object.  If the <br>//reference count reaches 0, destroy this object. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:     New reference count. <br>// <br>//--------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CFolderACLs::Release()// RETURNS: ULONG <br>{ <br>    ULONG   ulRefCount =0; <br> <br>    DEBUGPRIVATE("CFolderACLs::Release().\n"); <br> <br>    ASSERTERROR(m_refs, "Bad m_refs."); <br> <br>    m_refs--; <br> <br>    if (!m_refs) <br>    { <br>        delete this; <br>        ulRefCount = 0; <br>    } <br>    else <br>    { <br>        ulRefCount = m_refs; <br>    } <br> <br>    return ulRefCount; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
