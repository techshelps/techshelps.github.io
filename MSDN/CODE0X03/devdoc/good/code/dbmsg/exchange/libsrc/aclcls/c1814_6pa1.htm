<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SROWLST.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1819"></a>SROWLST.CPP</h2>
<pre><code>// --srowlst.cpp--------------------------------------------------------------- <br>// <br>// Implementation of classes CSROWNODE and CSROWLST. <br>//   <br>// Copyright (C) Microsoft Corp., 1986-1996.  All rights reserved. <br>// <br>//----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "srowlst.h" <br> <br>// ROWLIST allocation helper macro for IExchangeModifyTable interface. <br> <br>#defineCbNewROWLIST(_centries)(offsetof(ROWLIST,aEntries) + \ <br>(_centries)*sizeof(ROWENTRY)) <br> <br>// $--CSROWNODE::CSROWNODE----------------------------------------------------- <br>// <br>// DESCRIPTION:CSROWNODE constructor. <br>// <br>// INPUT: <br>// <br>//[lpSRow]-- Ptr to SRow for the CSROWNODE to be constructed. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CSROWNODE::CSROWNODE( <br>INLPSRowlpSRow  // row set ptr <br>    ) <br>{ <br>    DEBUGPRIVATE("CSROWNODE::CSROWNODE()\n"); <br> <br>    m_pNxt =NULL; <br>    m_pPrv =NULL; <br>m_SRow =*lpSRow; <br>} <br> <br> <br>// $--CSROWNODE::~CSROWNODE---------------------------------------------------- <br>// <br>// DESCRIPTION:CSROWNODE destructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CSROWNODE::~CSROWNODE() <br>{ <br>    DEBUGPRIVATE("CSROWNODE::~CSROWNODE()\n"); <br> <br>MAPIFREEBUFFER(m_SRow.lpProps); <br>} <br> <br>// $--CSROWLST::CSROWLST------------------------------------------------------- <br>// <br>// DESCRIPTION:CSROWLST constructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CSROWLST::CSROWLST() <br>{ <br>    DEBUGPRIVATE("CSROWLST::CSROWLST()\n"); <br> <br>m_cNodes =0; <br>m_lPos =ACL_PAST_END; <br>    m_pCurNode =NULL; <br>    m_pLstHd =NULL; <br>} <br> <br> <br>// $--CSROWLST::~CSROWLST------------------------------------------------------ <br>// <br>// DESCRIPTION:CSROWLST destructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CSROWLST::~CSROWLST() <br>{ <br>    CSROWNODE *pNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::~CSROWLST()\n"); <br> <br>    while (m_pLstHd != NULL) <br>    { <br>        pNode = m_pLstHd; <br>        m_pLstHd = m_pLstHd-&gt;m_pNxt; <br>delete pNode; <br>    } <br>} <br> <br>// $--CSROWLST::HrInitialize--------------------------------------------------- <br>// <br>// DESCRIPTION:Initialize an CSROWLST.  An SRowSet is stored in the CSROWLST. <br>//The SROWNODES are ordered according to the order they are <br>//found in the table. Upon completion of this method, either <br>//successful or unsuccessful, all storage associated with lpRows <br>//has either been reassigned to the CSROWLST, or has been <br>//deallocated. <br>// <br>// INPUT: <br>// <br>//[lpRows]-- Ptr to SRowSet to use in initializing the CSROWLST. <br>// <br>// RETURNS:NOERROR on success; <br>//              E_INVALIDARG if bad input, <br>//              E_FAIL otherwise <br>// <br>// Warning:lpRows is NO LONGER VALID after calling this function and <br>//should NOT be used or deallocated! <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrInitialize(// RETURNS: HRESULT <br>INLPSRowSetlpRows      // row set ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>ULONGi =0; <br>    CSROWNODE *pCurNode =NULL; <br>    CSROWNODE *pNewNode =NULL; <br>ULONGulCurSeqNo =0; <br>ULONGulNewSeqNo =0; <br> <br>    DEBUGPRIVATE("CSROWLST::HrInitialize()\n"); <br> <br>// Verify that all rows have the proper number of properties. <br> <br>for (i = 0; i &lt; lpRows-&gt;cRows; i++) <br>{ <br>if (lpRows-&gt;aRow[i].cValues &lt; C_ACLPROPS) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>} <br> <br>// Now add the SRow's in the SRowSet to the row list. <br> <br>for (i = 0; i &lt; lpRows-&gt;cRows; i++) <br>{ <br>pNewNode = new CSROWNODE(&amp;lpRows-&gt;aRow[i]); <br> <br>if (pNewNode == NULL) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>// The lpProps storage no longer belongs to the SRowSet, so: <br> <br>lpRows-&gt;aRow[i].cValues = 0; <br>lpRows-&gt;aRow[i].lpProps = NULL; <br> <br>AddToDLLTail(pNewNode, m_pLstHd); <br> <br>m_cNodes++; <br>} <br> <br>if (m_cNodes &gt; 0) <br>{ <br>m_lPos = 0; <br>m_pCurNode = m_pLstHd; <br>} <br> <br>cleanup: <br> <br>FREEPROWS(lpRows); <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--CSROWLST::HrDelete---------------------------------------------------- <br>// <br>// DESCRIPTION:Delete the current record. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:NOERROR on success; <br>//E_FAIL if current cursor value is ACL_PAST_END. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrDelete(VOID)// RETURNS: HRESULT <br>{ <br>    HRESULThr =NOERROR; <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::HrDelete()\n"); <br> <br>hr = HrRemoveFromLst(&amp;pNode); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>delete pNode; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CSROWLST::HrInsert---------------------------------------------------- <br>// <br>// DESCRIPTION:Insert a new CSROWNODE before the current record and advance <br>//the cursor. <br>// <br>// INPUT: <br>// <br>//[lpSRow]-- Ptr to SRow for the CSROWNODE to be inserted. <br>// <br>// RETURNS:NOERROR on success; <br>//              E_INVALIDARG if bad input; <br>//              E_FAIL otherwise; <br>// <br>// Notes:The cursor is advanced only if it is not at ACL_PAST_END. <br>//E_FAIL is returned if there is already an entry for the <br>//user. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrInsert(// RETURNS: HRESULT <br>INLPSRowlpSRow      // row set ptr <br>) <br>{ <br>    HRESULThr =NOERROR; <br>CSROWNODE *pNewNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::HrInsert()\n"); <br> <br>if (m_cNodes == EDK_MAX_QUERY_ROWS) <br>    { <br>hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>{ <br>CSROWNODE *pNode =m_pLstHd; <br> <br>while (pNode != NULL) <br>{ <br>if (!stricmp(lpSRow-&gt;lpProps[I_MEMBER_NAME].Value.lpszA, <br> pNode-&gt;m_SRow.lpProps[I_MEMBER_NAME].Value.lpszA)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>pNode = pNode-&gt;m_pNxt; <br>} <br>} <br> <br>pNewNode = new CSROWNODE(lpSRow); <br> <br>if (pNewNode == NULL) <br>    { <br>    hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>if (m_pCurNode == m_pLstHd)// Covers empty list and insertion at head. <br>{ <br>AddToDLLHead(pNewNode, m_pLstHd); <br>} <br>else if (m_pCurNode == NULL)// Covers insertion at tail. <br>{ <br>AddToDLLTail(pNewNode, m_pLstHd); <br>} <br>else// Covers all other cases. <br>{ <br>// It is important to store the previous node ptr in a separate <br>// location because m_pCurNode-&gt;m_pPrv gets stomped on in <br>// InsertIntoDLL(). <br> <br>CSROWNODE *pPrvNode = m_pCurNode-&gt;m_pPrv; <br> <br>InsertIntoDLL(pNewNode, m_pLstHd, pPrvNode); <br>} <br> <br>m_cNodes++; <br> <br>if (m_lPos != ACL_PAST_END) <br>m_lPos++; <br> <br>// Note that m_pCurNode does not change regardless of the insertion point. <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CSROWLST::HrRemoveFromLst------------------------------------------------ <br>// <br>// DESCRIPTION:Remove the current record from the list and make it available <br>//to the caller.  The caller is responsible for deleting the <br>//record when he no longer needs it. <br>// <br>// OUTPUT: <br>// <br>//[ppRemovedNode]-- Ptr that will be set to removed node on successful <br>//   return. <br>// <br>// RETURNS:NOERROR on success; <br>//E_FAIL if current cursor value is ACL_PAST_END. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrRemoveFromLst( <br>OUTCSROWNODE * *ppRemovedNode <br>) <br>{ <br>    HRESULThr =NOERROR; <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::HrRemoveFromLst()\n"); <br> <br>*ppRemovedNode = NULL; <br> <br>if (m_lPos == ACL_PAST_END) <br>    { <br>hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>pNode = m_pCurNode; <br> <br>m_pCurNode = m_pCurNode-&gt;m_pNxt; <br> <br>if (m_pCurNode == NULL) <br>m_lPos = ACL_PAST_END; <br> <br>RmFromDLL(pNode, m_pLstHd); <br> <br>m_cNodes--; <br> <br>*ppRemovedNode = pNode; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CSROWLST::SetCursor------------------------------------------------------ <br>// <br>// DESCRIPTION:Standard C++ set member function which sets the current <br>//cursor position. <br>// <br>// INPUT: <br>// <br>//[lPos]-- New cursor position.  If &lt; 0 or past end of list, then the <br>//   new cursor positon will be set to ACL_PAST_END. <br>// <br>// RETURNS:The new cursor position. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LONG <br>CSROWLST::SetCursor(// RETURNS: LONG <br>INLONGlPos// cursor position <br>) <br>{ <br>    DEBUGPRIVATE("CSROWLST::SetCursor()\n"); <br> <br>if (lPos &gt;= 0 &amp;&amp; lPos &lt; (LONG) m_cNodes) <br>{ <br>if (m_lPos == ACL_PAST_END || m_lPos &gt; lPos) <br>{ <br>m_pCurNode = m_pLstHd; <br>m_lPos = 0; <br>} <br> <br>while (m_lPos &lt; lPos) <br>{ <br>m_pCurNode = m_pCurNode-&gt;m_pNxt; <br>m_lPos++; <br>} <br>} <br>else <br>{ <br>m_lPos =ACL_PAST_END; <br>m_pCurNode =NULL; <br>} <br> <br>    return m_lPos; <br>} <br> <br> <br>// $--CSROWLST::HrWriteToTable------------------------------------------------- <br>// <br>// DESCRIPTION:Write the contents of the CSROWLST to an EXCHANGEMODIFYTABLE. <br>// <br>// INPUT: <br>// <br>//[lpExchTbl]-- Ptr to the EXCHANGEMODIFYTABLE that will be rewritten based <br>//   on the contents of the CSROWLST. <br>// <br>// RETURNS:NOERROR on success;  <br>//              E_INVALIDARG if bad input; <br>//              E_FAIL otherwise. <br>// <br>//--------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrWriteToTable(// RETURNS: HRESULT <br>INLPEXCHANGEMODIFYTABLElpExchTbl   // Exchange modify tbl i/f ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>LPROWENTRYlpRowEntry =NULL; <br>LPROWLISTlpRowList =NULL; <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::HrWriteToTable()\n"); <br> <br>// Make a ROWLIST for use with the IExchangeModifyTable interface.  We <br>// explicitly call MAPIAllocateBuffer() here due to the size vagaries  <br>// of MAPI structures.  In writing to the table, we have to drop off <br>// the PR_MEMBER_NAME property, which we have conveniently placed last <br>// in the SPropValue array. <br> <br>hr = MAPIAllocateBuffer(CbNewROWLIST(m_cNodes), (LPVOID FAR *)&amp;lpRowList); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>lpRowList-&gt;cEntries = m_cNodes; <br> <br>pNode = m_pLstHd; <br> <br>lpRowEntry = lpRowList-&gt;aEntries; <br> <br>while (pNode != NULL) <br>{ <br>lpRowEntry-&gt;ulRowFlags =ROW_ADD; <br>lpRowEntry-&gt;cValues =pNode-&gt;m_SRow.cValues - 1;//drop member name <br>lpRowEntry-&gt;rgPropVals =pNode-&gt;m_SRow.lpProps; <br> <br>lpRowEntry++; <br> <br>pNode = pNode-&gt;m_pNxt; <br>} <br> <br>// Modify the entire table. <br> <br>hr = lpExchTbl-&gt;ModifyTable(ROWLIST_REPLACE, lpRowList); <br> <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>// Deallocate the ROWLIST (not including the SPropValue ptrs, since they <br>// still actually belong to the CSROWLST). <br> <br>MAPIFREEBUFFER(lpRowList); <br> <br>RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
