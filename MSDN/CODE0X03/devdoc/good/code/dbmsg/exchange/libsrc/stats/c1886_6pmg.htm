<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FLDMTRC.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1888"></a>FLDMTRC.CPP</h2>
<pre><code>// --fldmtrc.cpp---------------------------------------------------------------- <br>// <br>//  Implements the folder metrics code. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "fldmtrc.h" <br>#include "fldmtrc.chk" <br> <br>// Class constants <br>// --------------- <br>SPropTagArray CFolderMetrics::m_sFolderContentCount     = { 1L, {PR_CONTENT_COUNT } }; <br>SSortOrderSet CFolderMetrics::m_sSortOrderSet           = { 1L, 0, 0, {PR_MESSAGE_DELIVERY_TIME , TABLE_SORT_ASCEND} }; <br>SPropTagArray CFolderMetrics::m_sInFolderSince          = { 1L, {PR_MESSAGE_DELIVERY_TIME } }; <br> <br> <br>//$--CFolderMetrics::CFolderMetrics--------------------------------------------- <br>//  Constructor for Folder Metrics object. <br>// ----------------------------------------------------------------------------- <br>CFolderMetrics::CFolderMetrics() <br>{ <br> <br>    DEBUGPUBLIC("CFolderMetrics::CFolderMetrics()\n"); <br> <br>    m_lpFolder = NULL; <br>    m_lpTable = NULL; <br>} <br> <br> <br>//$--CFolderMetrics::~CFolderMetrics-------------------------------------------- <br>//  Destructor for folder Metrics object. <br>// ----------------------------------------------------------------------------- <br>CFolderMetrics::~CFolderMetrics() <br>{ <br>    DEBUGPUBLIC("CFolderMetrics::~CFolderMetrics()\n"); <br> <br>    // m_lpFolder isn't freed because we didn't create it. <br>    // --------------------------------------------------- <br> <br>    ULRELEASE(m_lpTable); <br>} <br> <br> <br>//$--CFolderMetrics::HrReset---------------------------------------------------- <br>//  Resets and assigns the folder metrics object to a particular folder. <br>// ----------------------------------------------------------------------------- <br>HRESULT CFolderMetrics::HrReset(        // HRESULT <br>    IN LPMAPIFOLDER lpFolder)           // Object is assigned to this folder. <br>{ <br>    HRESULT hr = NOERROR; <br> <br>    DEBUGPRIVATE("CFolderMetrics::HrReset()\n"); <br> <br>hr = CHK_CFolderMetrics_HrReset(lpFolder); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    if (lpFolder == NULL) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    ULRELEASE(m_lpTable); <br> <br>    // Open content table for lpFolder and set columns for PR_IN_FOLDER_SINCE <br>    // ---------------------------------------------------------------------- <br>    hr = lpFolder-&gt;GetContentsTable(MAPI_DEFERRED_ERRORS, &amp;m_lpTable); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = m_lpTable-&gt;SetColumns(&amp;m_sInFolderSince, (ULONG)0); <br> <br>    if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    m_lpFolder = lpFolder; <br> <br>cleanup: <br>    // m_lpFolder isn't freed because we didn't create it. <br>    // --------------------------------------------------- <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--CFolderMetrics::HrGetFolderMetrics----------------------------------------- <br>//  Determine and return the folder metrics values. <br>// ----------------------------------------------------------------------------- <br>HRESULT CFolderMetrics::HrGetFolderMetrics( // RETURNS: HRESULT <br>    IN __int64 liNow,                       // Current time expressed as a file time. <br>    IN DWORD fMetric,                       // Flag to determine the metric <br>                                            //  to query. May be an or'ed <br>                                            //  combination of: <br>                                            //  FM_CMESSAGES, FM_LONGEST_WAIT <br>                                            //  FM_TOTAL_WAIT. <br>    OUT DWORD &amp;cMessages,                   // Receives number of mesages <br>                                            //  in folder if FM_CMESSAGES <br>                                            //  is specified. = 0 otherwise. <br>    OUT __int64 &amp;liLongestWait,             // Receives longest wait <br>                                            //  expressed as a file time if <br>                                            //  FM_LONGEST_WAIT specified. <br>                                            //  = 0 otherwise. <br>    OUT __int64 &amp;liTotalWait)               // Recieves total wait <br>                                            //  expresses as a file time if <br>                                            //  FM_TOTAL_WAIT specified. <br>                                            // = 0 otherwise. <br>{ <br>    HRESULT hr       = NOERROR; <br> <br>    DEBUGPRIVATE("CFolderMetrics::HrGetFolderMetrics()\n"); <br> <br>    // pre-clear all return values <br>    // --------------------------- <br>    cMessages = 0; <br>    liLongestWait = 0; <br>    liTotalWait   = 0; <br> <br>hr = CHK_CFolderMetrics_HrGetFolderMetrics( <br>    liNow,  <br>fMetric,  <br>cMessages,  <br>liLongestWait,  <br>liTotalWait); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    // The message count can be generated as a side effect of <br>    // calculating the FM_TOTAL_WAIT or queried separately as a folder <br>    // property.  If FM_TOTAL_WAIT is not requested then <br>    // then query the message count as a less expensive folder property. <br>    // ---------------------------------------------------------- <br>    if (!(fMetric &amp; FM_TOTAL_WAIT)) <br>    { <br>        hr = HrGetcMessages(cMessages); <br> <br>        if (FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br> <br>    // Re-sort contents table and go to the start of the table. <br>    // -------------------------------------------------------- <br>    hr = m_lpTable-&gt;SortTable(&amp;m_sSortOrderSet, 0); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    hr = m_lpTable-&gt;SeekRow(BOOKMARK_BEGINNING, 0, NULL); <br> <br>    if (FAILED(hr)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // If longest wait metric requested, then get longest wait. <br>    // -------------------------------------------------------- <br>    if (fMetric &amp; FM_LONGEST_WAIT) <br>    { <br>        hr = HrGetLongestWait(liNow, liLongestWait); <br> <br>        if (FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>    // If total wait metric requested, then get total wait. <br>    // ---------------------------------------------------- <br>    if (fMetric &amp; FM_TOTAL_WAIT) <br>    { <br>        hr = HrGetTotalWait(liNow, cMessages, liTotalWait); <br> <br>        if (FAILED(hr)) <br>        { <br>            goto cleanup; <br>        } <br>    } <br> <br>cleanup: <br> <br>    // if they didn't ask for it then don't give it to them. <br>    // ----------------------------------------------------- <br>    if (!(fMetric &amp; FM_CMESSAGES)) <br>    { <br>        cMessages     = 0; <br>    } <br> <br>    if (!(fMetric &amp; FM_LONGEST_WAIT)) <br>    { <br>        liLongestWait = 0; <br>    } <br> <br>    if (!(fMetric &amp; FM_TOTAL_WAIT)) <br>    { <br>        liTotalWait = 0; <br>    } <br> <br>    RETURN(hr); <br>} <br> <br> <br>// ----------------------------------------------------------------------------- <br>//  Private member functions <br>// ----------------------------------------------------------------------------- <br> <br>//$--CFolderMetrics::HrGetcMessages--------------------------------------------- <br>//  Returns the number of messages in the object folder. <br>// ----------------------------------------------------------------------------- <br>HRESULT CFolderMetrics::HrGetcMessages( // RETURNS: HRESULT <br>    OUT DWORD &amp;cMessage)                // Receives number of messages in folder. <br>{ <br>    HRESULT         hr          = NOERROR; <br>    DWORD           cValues     = 0; <br>    LPSPropValue    lpPropValue = NULL; <br> <br> <br>    DEBUGPRIVATE("CFolderMetrics::HrGetMessages()\n"); <br> <br>hr = CHK_CFolderMetrics_HrGetcMessages(cMessage); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    cMessage = 0; <br> <br>    hr = m_lpFolder-&gt;GetProps( <br>        &amp;m_sFolderContentCount, fMapiUnicode, &amp;cValues, &amp;lpPropValue); <br> <br>    if (FAILED(hr) || (hr == MAPI_W_ERRORS_RETURNED)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    if ( cValues &gt; 0 ) <br>    { <br>        cMessage = (DWORD) lpPropValue-&gt;Value.l; <br>    } <br> <br>cleanup: <br> <br>    MAPIFREEBUFFER(lpPropValue); <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--CFolderMetrics::HrGetLongestWait------------------------------------------- <br>//  Retrieves duration in the folder of the oldest message. <br>// ----------------------------------------------------------------------------- <br>HRESULT CFolderMetrics::HrGetLongestWait(   // RETURNS: HRESULT <br>    IN __int64 liNow,                       // Current Time expressed as a <br>                                            //   file time. <br>    OUT __int64 &amp;liLongestWait)             // Receives the longest time that <br>                                            //   a messages has been in <br>                                            //   the folder expressed as a <br>                                            //   file time. <br>{ <br>    HRESULT hr                  = NOERROR; <br>    LONG    lRes                = 0; <br> <br>    LPSRowSet lpRows            = NULL; <br>    LPSPropValue lpProps        = NULL; <br>    ULONG ulType                = 0; <br>    __int64  liInFolderSince= 0; <br> <br>    DEBUGPRIVATE("CFolderMetrics::HrGetLongestWait()\n"); <br> <br>hr = CHK_CFolderMetrics_HrGetLongestWait(liNow, liLongestWait); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    liLongestWait = 0; <br> <br>    hr = m_lpTable-&gt;QueryRows(1, TBL_NOADVANCE, &amp;lpRows); <br> <br>    if (FAILED(hr) || (hr == MAPI_W_ERRORS_RETURNED)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>    // If no entries, then quit. <br>    // ------------------------- <br>    if (lpRows-&gt;cRows == 0) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // If number values differs from 1 then quit. <br>    // ------------------------------------------ <br>    if (lpRows-&gt;aRow[0].cValues != 1) <br>    { <br>        ASSERTERROR(FALSE,"CFolderMetrics::rcGetLongestWait() Content " <br>        "table contains other than 1 Value type."); <br>        goto cleanup; <br>    } <br> <br>    lpProps = lpRows-&gt;aRow[0].lpProps; <br> <br>    ulType = PROP_TYPE(lpProps-&gt;ulPropTag); <br> <br>    if (ulType!= PT_SYSTIME) <br>    { <br>        // OK, fake it <br>        liLongestWait = 0 ; <br>        goto cleanup ; <br>    } <br> <br>    // If time is more recent than now then ignore it. <br>    // ----------------------------------------------- <br>    liInFolderSince = INT64_FROM_FILETIME(lpProps-&gt;Value.ft); <br> <br>    if (liInFolderSince &lt; liNow) <br>    { <br>       liLongestWait = liNow - liInFolderSince; <br>    } <br> <br>cleanup: <br> <br>    FreeProws(lpRows); <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrGetTotalWait------------------------------------------------------------- <br>//  Returns the sum of all of the waiting periods of each message in the folder. <br>// ----------------------------------------------------------------------------- <br>HRESULT CFolderMetrics::HrGetTotalWait( // RETURNS: HRESULT <br>    IN __int64 liNow,                   // Current time expressed as a file time. <br>    OUT DWORD &amp;cMessages,               // Receives number of messages in file. <br>    OUT __int64 &amp;liTotalWait)           // Receives total wait of messages in file. <br>{ <br>    HRESULT hr          = NOERROR; <br>    LONG  lRes          = 0; <br> <br>    __int64  liInFolderSince = 0; <br> <br>    LPSRowSet lpRows = NULL; <br>    LPSPropValue lpProps = NULL; <br> <br>    DWORD i             = 0; <br>    DWORD cRows         = 0; <br> <br> <br>    DEBUGPRIVATE("CFolderMetrics::HrGetTotalWait()\n"); <br> <br>hr = CHK_CFolderMetrics_HrGetTotalWait(liNow, cMessages, liTotalWait); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    liInFolderSince = 0; <br>    liTotalWait = 0; <br>    cMessages = 0; <br> <br>    // Read entries 100 at a time and calculate the total wait <br>    // from the in folder since time. <br>    // --------------------------------------------------------- <br>    do <br>    { <br>        hr = m_lpTable-&gt;QueryRows(100, 0, &amp;lpRows); <br> <br>        if (FAILED(hr) || (hr == MAPI_W_ERRORS_RETURNED)) <br>        { <br>            hr = HR_LOG(E_FAIL); <br>            goto cleanup; <br>        } <br> <br>        cMessages += lpRows-&gt;cRows; <br>        cRows = lpRows-&gt;cRows; <br> <br>        for (i=0; i&lt;cRows; i++) <br>        { <br>            // Get the property value from the row. <br>            // ------------------------------------ <br>            if (lpRows-&gt;aRow[i].cValues != 1) <br>            { <br>                ASSERTERROR(FALSE,"Content table contains other than 1 " <br>                "Value type."); <br>                goto cleanup; <br>            } <br> <br>            lpProps = lpRows-&gt;aRow[i].lpProps; <br>            if (PROP_TYPE(lpProps-&gt;ulPropTag) != PT_SYSTIME) <br>            { <br>                // ok, fake it. <br>                continue ; <br>            } <br> <br>            // If folder submit time is more recent than <br>            // now, then don't include this item in average. <br>            // ---------------------------------------------- <br>            liInFolderSince =  INT64_FROM_FILETIME(lpProps-&gt;Value.ft); <br>            if (liInFolderSince &lt; liNow) <br>            { <br>                liTotalWait = liTotalWait + (liNow - liInFolderSince); <br>            } <br>        } <br> <br>        FreeProws(lpRows); <br>        lpRows = NULL; <br>    } <br>    while (cRows != 0); // end of DO {  } WHILE () . <br> <br>cleanup: <br> <br>    FreeProws(lpRows); <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
