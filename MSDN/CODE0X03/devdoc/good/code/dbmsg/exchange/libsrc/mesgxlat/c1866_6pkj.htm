<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVREGH.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1873"></a>CONVREGH.CPP</h2>
<pre><code>// --convregh.cpp--------------------------------------------------------------- <br>//  <br>// Class that represents conversion class name/list info. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// <br>// ----------------------------------------------------------------------------- <br> <br>#include "convincl.h" <br>#include "convregh.chk" <br> <br>//$--HrGetArbSizeValue--------------------------------------------------------- <br>// <br>//  DESCRIPTION: Allocate sufficient memory to read a value from the the registry  <br>//  and read it.   <br>// <br>//  INPUT:  hk  --  key that contains value <br>//          lpszValueName   --  name of value <br>//        <br>//  OUTPUT: pValue  --  pointer to key's value <br>//          cbSize  --  size of value (including null) <br>//          nType   --  type of value <br>// <br>//  RETURNS:    HRESULT -   NOERROR if successful, <br>//                          E_INVALIDARG if bad input, <br>//                          EDK_E_END_OF_FILE if key not found, <br>//                          E_FAIL otherwise. <br>// <br>//------------------------------------------------------------------------------ <br>HRESULT HrGetArbSizeValue(       // RETURNS: HRESULT <br>    IN HKEY hk,                 // key that contains the value <br>    IN LPWSTR lpszValueName,    // name of the value <br>    OUT PVOID &amp; pValue,         // pointer to its value <br>    OUT DWORD &amp; cbSize,         // how big is it (including trailing null(s) <br>    OUT DWORD &amp; nType)          // what type <br>{ <br>    HRESULT hr  =   NOERROR;    // return code <br>    LONG lRet = 0; <br> <br>    DEBUGPRIVATE("HrGetArbSizeValue()\n"); <br> <br>    // check input parameters <br>    hr = CHK_HrGetArbSizeValue(hk, lpszValueName, pValue, cbSize, nType); <br> <br>    if ( FAILED(hr) ) <br>    { <br>        RETURN(hr); <br>    } <br> <br>    pValue = NULL; <br> <br>    lRet = RegQueryValueExW(hk, lpszValueName, NULL, &amp;nType, NULL, &amp;cbSize); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(EDK_E_END_OF_FILE); <br> <br>        goto cleanup; <br>    } <br> <br>    hr = MAPIAllocateBuffer( <br>                cbSize,     // # of bytes <br>                &amp;pValue);   // output buffer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br> <br>        goto cleanup; <br>    } <br> <br>    lRet = RegQueryValueExW(hk, lpszValueName, NULL, &amp;nType, (PBYTE)pValue, &amp;cbSize); <br> <br>    if(lRet != ERROR_SUCCESS) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>    if( FAILED(hr) ) <br>    { <br>        MAPIFREEBUFFER(pValue); <br>    } <br> <br>    RETURN(hr); <br> <br>} <br> <br>//$--HrStrstriW------------------------------------------------------- <br>// <br>// DESCRIPTION: determines whether one string is a sub-string of another. <br>// Not case sensitive. <br>// <br>// INPUT:   pszSubString   --  the sub-string to check for <br>//          pszString   --  the string <br>// <br>// RETURNS: HRESULT --  NOERROR if string contains the sub-string. <br>//                      E_FAIL otherwise. <br>// <br>//--------------------------------------------------------------------- <br>HRESULT HrStrstriW(            <br>    IN LPCWSTR pszSubString,    // the candidate substring <br>    IN LPCWSTR pszString)       // the string. <br>{ <br>    HRESULT hr          =   NOERROR;    // return code <br>    LPWSTR  pszStringT  =   NULL;       // string copy <br>    LPWSTR  pszSubStrT  =   NULL;       // substring copy <br> <br>    DEBUGPRIVATE("HrStrstriW()\n"); <br>     <br>    // DON'T check input parameters, as null strings are allowed. <br>    if((pszString == NULL) &amp;&amp; (pszSubString == NULL)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    if((pszString == NULL) &amp;&amp; (pszSubString != NULL)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    if((pszString != NULL) &amp;&amp; (pszSubString == NULL)) <br>    { <br>        goto cleanup; <br>    } <br> <br>    // upper-case the strings so that our comparison will be <br>    // case-insensitive.  Duplicate the strings first, however. <br>    hr = HrStrWToStrW( <br>                pszString,          // input string <br>                &amp;pszStringT);       // output string pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    hr = HrStrWToStrW( <br>                pszSubString,       // input string <br>                &amp;pszSubStrT);       // output string pointer <br> <br>    if ( FAILED(hr) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    pszStringT = _wcsupr(pszStringT); <br>    pszSubStrT = _wcsupr(pszSubStrT); <br> <br>    if ( (pszSubStrT == NULL) || (pszStringT == NULL) ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    if ( wcsstr(pszStringT, pszSubStrT) == NULL ) <br>    { <br>        hr = HR_LOG(E_FAIL); <br> <br>        goto cleanup; <br>    } <br> <br>    // substring exists in string <br> <br>cleanup: <br> <br>    // free MAPI buffers <br>    MAPIFREEBUFFER(pszStringT); <br>    MAPIFREEBUFFER(pszSubStrT); <br> <br>    RETURN(hr); <br>         <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
