<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACLCLSI.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1817"></a>ACLCLSI.CPP</h2>
<pre><code>// --aclclsi.cpp------------------------------------------------------------- <br>// <br>//  Implementation file for the CIExchangeFolderACLs programmer interface class. <br>// <br>//  The CFolderACLs class is the controlling class.  It controls the <br>//  CIExchangeFolderACLs class (which implements the IExchangeFolderACLs <br>//programatic interface defined in aclcls.h and which this file implements). <br>// <br>//  Copyright (C) Microsoft Corp. 1986-1996, All rights reserved. <br>// <br>// --------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "srowlst.h" <br>#include "aclclsf.h" <br>#include "aclclsi.chk" <br> <br>// IUnknown Methods --  <br>// Let the controlling parent object handle all of these! <br> <br>// $--CIExchangeFolderACLs::QueryInterface------------------------------------- <br>// <br>// DESCRIPTION:Return ptr to object which implements the desired <br>//interface, if this object supports the interface. <br>// <br>//Implemented via the parent object's (CFolderACLs') <br>//QueryInterface. <br>// INPUT: <br>// <br>// [riid]-- Reference to interface identifier of desired interface. <br>// <br>// OUTPUT: <br>// <br>// [ppvObj]-- Ptr to object which supports interface.  NULL if none. <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input; <br>//E_NOINTERFACEif interface not supported. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderACLs::QueryInterface(// RETURNS: HRESULT <br>INREFIIDriid,       // interface ID reference <br>OUTLPVOID FAR *ppvObj      // interface ptr ptr <br>) <br>{ <br>    HRESULThr =NOERROR; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::QueryInterface().\n"); <br> <br>    hr = CHK_CIExchangeFolderACLs_QueryInterface(riid, ppvObj); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA"); <br> <br>    // Let parent controlling object handle this.  (Let it do all <br>    // parameter checking also!) <br> <br>    hr = m_pFA-&gt;QueryInterface(riid, ppvObj); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderACLs::AddRef--------------------------------------------- <br>// <br>// DESCRIPTION:Increment this object's reference count. <br>// <br>//Implemented via the parent object's (CFolderACLs') AddRef(). <br>// <br>// INPUT:None. <br>// <br>// RETURNS:New reference count. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CIExchangeFolderACLs::AddRef()// RETURNS: ULONG <br>{ <br>    ULONGulRefCount =0; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::AddRef().\n"); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA"); <br> <br>    // Let parent controlling object handle this. <br> <br>    ulRefCount = m_pFA-&gt;AddRef(); <br> <br>    return ulRefCount; <br>} <br> <br> <br>// $--CIExchangeFolderACLs::Release-------------------------------------------- <br>// <br>// DESCRIPTION:Decrement this object's reference count. <br>// <br>//Implemented via the parent object's (CFolderACLs') Release(). <br>// <br>// INPUT:None. <br>// <br>// RETURNS:New reference count. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) <br>CIExchangeFolderACLs::Release()    // RETURNS: ULONG <br>{ <br>    ULONGulRefCount =0; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::Release().\n"); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA"); <br> <br>    // Let parent controlling object handle this. <br> <br>    ulRefCount = m_pFA-&gt;Release(); <br> <br>    return ulRefCount; <br>} <br> <br>// <br>// Methods unique to the IExchangeFolderACLs interface. <br>// <br> <br>// $--CIExchangeFolderACLs::HrDelete------------------------------------------- <br>// <br>// DESCRIPTION:Delete the current record. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:NOERRORif successful;  <br>//              E_OUTOFMEMORYif insufficient memory; <br>//              E_FAILif cursor at ACL_PAST_END, or if the <br>//current record is the default ACL or is <br>//the ACL for the current user. <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderACLs::HrDelete(VOID)// RETURNS: HRESULT <br>{ <br>    HRESULThr =NOERROR; <br>LONGlPosDeletion =ACL_PAST_END; <br>LONGlNewRights =0; <br>LPSRowlpRow =NULL; <br>CSROWNODE *pDeletedNode =NULL; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::HrDelete().\n"); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA."); <br> <br>lPosDeletion = m_pFA-&gt;m_SRowLst.GetCursor(); <br> <br>hr = m_pFA-&gt;m_SRowLst.HrRemoveFromLst(&amp;pDeletedNode); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>lpRow = &amp;pDeletedNode-&gt;m_SRow; <br> <br>if (lpRow-&gt;lpProps[I_MEMBER_ENTRYID].Value.bin.cb == 0) <br>{ <br>hr = HR_LOG(E_FAIL);// Cannot delete default ACL! <br>} <br>else <br>{ <br>hr = m_pFA-&gt;m_SRowLst.HrWriteToTable(m_pFA-&gt;m_lpExchTbl); <br>} <br> <br>if (FAILED(hr)) <br>{ <br>HRESULThrTmp = m_pFA-&gt;m_SRowLst.HrInsert(lpRow); <br> <br>if (FAILED(hrTmp)) <br>hr = HR_LOG(E_UNEXPECTED); <br>else <br>lpRow-&gt;lpProps = NULL; <br> <br>goto cleanup; <br>} <br> <br>// Check that the deletion actually worked.  IExchangeModifyTable will <br>// actually add back the current user acl if you attempt to delete it, <br>// albeit with different rights.  If we detect that this has happened, <br>// we modify back to the original rights and fail the call. <br> <br>hr = m_pFA-&gt;HrGetTableEntry(lpRow-&gt;lpProps[I_MEMBER_ENTRYID].Value.bin.cb, <br>(LPENTRYID) <br>lpRow-&gt;lpProps[I_MEMBER_ENTRYID].Value.bin.lpb, <br>NULL, <br>&amp;lNewRights); <br> <br>if (hr == EDK_E_NOT_FOUND) <br>{ <br>hr = NOERROR; <br>} <br>else <br>{ <br>if (FAILED(hr)) <br>{ <br>// This is not expected to happen.  If it does, we need to fix <br>// the problem so that we can insure that the table and list are <br>// in sync. <br> <br>hr = HR_LOG(E_UNEXPECTED); <br>goto cleanup; <br>} <br>else <br>{ <br>// The entry is still in the table, so reinsert it into the list <br>// and rewrite the table to insure that the rights are in sync. <br> <br>hr = HR_LOG(E_FAIL); <br> <br>HRESULThrTmp = m_pFA-&gt;m_SRowLst.HrInsert(lpRow); <br> <br>if (FAILED(hrTmp)) <br>{ <br>hr = HR_LOG(E_UNEXPECTED); <br>goto cleanup; <br>} <br>else <br>{ <br>lpRow-&gt;lpProps = NULL; <br>} <br> <br>hrTmp = m_pFA-&gt;m_SRowLst.HrWriteToTable(m_pFA-&gt;m_lpExchTbl); <br> <br>if (FAILED(hrTmp)) <br>hr = HR_LOG(E_UNEXPECTED); <br> <br>goto cleanup; <br>} <br>} <br> <br>cleanup: <br> <br>delete pDeletedNode; <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderACLs::HrGet---------------------------------------------- <br>// <br>// DESCRIPTION:Get the current record and advance the cursor. <br>// <br>// OUTPUT: <br>// <br>//   [lplRights]--  ACL rights bits buffer. <br>//   [lppszDisplayName]--  Member display name buffer. <br>//   [lpcbentryid]--  Count of bytes in member entry ID. <br>//   [lppentryid]--  Member entry ID buffer. <br>// <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input; <br>//              E_FAILif cursor at ACL_PAST_END; <br>//              E_OUTOFMEMORYif insufficient memory. <br>// <br>// Notes:Space for *lplRights and *lpcbentryid is allocated by the user. <br>//Space for the other parameters is allocated by this method. <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderACLs::HrGet(// RETURNS: HRESULT <br>OUTLPLONGlplRights,// rights ptr <br>OUTLPSTR FAR *lppszDisplayName,   // display name ptr <br>OUTULONG FAR *lpcbentryid,// # of bytes in entry ID ptr <br>OUTLPENTRYID FAR *lppentryid// entry ID ptr ptr <br>) <br>{ <br>    HRESULThr =NOERROR;     <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::HrGet().\n"); <br> <br>    hr = CHK_CIExchangeFolderACLs_HrGet(lplRights, <br>      lppszDisplayName, <br>      lpcbentryid, <br>      lppentryid); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>// Null the ptrs so we can free them on failure. <br> <br>*lppszDisplayName =NULL; <br>*lppentryid =NULL; <br> <br>*lpcbentryid =0;// Safeguard against misuse. <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA."); <br> <br>pNode = m_pFA-&gt;m_SRowLst.GetCurrentNode(); <br> <br>if (pNode == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (pNode-&gt;m_SRow.cValues &lt; C_ACLPROPS|| <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_ENTRYID].ulPropTag != <br>PR_MEMBER_ENTRYID|| <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_RIGHTS].ulPropTag != <br>PR_MEMBER_RIGHTS|| <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_NAME].ulPropTag != <br>PR_MEMBER_NAME) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>*lpcbentryid = pNode-&gt;m_SRow.lpProps[I_MEMBER_ENTRYID].Value.bin.cb; <br> <br>if (*lpcbentryid != 0&amp;&amp; <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_ENTRYID].Value.bin.lpb != NULL) <br>{ <br>hr = MAPIAllocateBuffer(*lpcbentryid, (LPVOID FAR *)lppentryid); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>memcpy(*lppentryid, <br>   pNode-&gt;m_SRow.lpProps[I_MEMBER_ENTRYID].Value.bin.lpb, <br>   *lpcbentryid); <br>} <br> <br>*lplRights = pNode-&gt;m_SRow.lpProps[I_MEMBER_RIGHTS].Value.l; <br> <br>if (pNode-&gt;m_SRow.lpProps[I_MEMBER_NAME].Value.lpszA != NULL) <br>{ <br>ULONGcb = strlen(pNode-&gt;m_SRow.lpProps[I_MEMBER_NAME].Value.lpszA) + <br> sizeof(char); <br> <br>hr = MAPIAllocateBuffer(cb, (LPVOID FAR *)lppszDisplayName); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>strcpy(*lppszDisplayName, <br>   pNode-&gt;m_SRow.lpProps[I_MEMBER_NAME].Value.lpszA); <br>} <br> <br>// Advance the cursor. <br> <br>m_pFA-&gt;m_SRowLst.SetCursor(m_pFA-&gt;m_SRowLst.GetCursor() + 1); <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(*lppszDisplayName); <br>MAPIFREEBUFFER(*lppentryid); <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderACLs::HrInsert------------------------------------------- <br>// <br>// DESCRIPTION:Insert record before the current record and advance the cursor. <br>// <br>// INPUT: <br>// <br>//  [lRights]-- Member's ACL Rights bits. <br>//  [lpszDisplayName]-- Member's Display Name. <br>//  [cbentryid]-- Count of bytes in member's entry identifier. <br>//[lpentryid]-- Ptr to member's entry identifier. <br>// <br>// OUTPUT: <br>// <br>//[lplRights]-- Ptr to rights bits actually set on completion; if <br>//   this info is not wanted, specify NULL. <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input; <br>//              E_OUTOFMEMORYif memory problems; <br>//              E_FAILotherwise (attempting to insert an acl for <br>//another existing user, etc.). <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderACLs::HrInsert(// RETURNS: HRESULT <br>INLONGlRights,         // rights bits <br>INLPSTRlpszDisplayName,    // display name <br>INULONGcbentryid,// # bytes in entry ID <br>INLPENTRYIDlpentryid,// entry ID ptr <br>OUTLPLONGlplRights// ptr to output rights bits <br>) <br>{ <br>    HRESULThr =NOERROR; <br>LONGlNewRights =0; <br>LPSTRlpszDisplayNameCopy =NULL; <br>LPENTRYIDlpentryidCopy =NULL; <br>LONGlPosInsertion =ACL_PAST_END; <br>SRowsr = {0, C_ACLPROPS, NULL}; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::HrInsert().\n"); <br> <br>    hr = CHK_CIExchangeFolderACLs_HrInsert(lRights, <br>     lpszDisplayName, <br>     cbentryid, <br>     lpentryid, <br>   lplRights); <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA."); <br> <br>lPosInsertion = m_pFA-&gt;m_SRowLst.GetCursor(); <br> <br>if (lPosInsertion == ACL_PAST_END) <br>lPosInsertion = m_pFA-&gt;m_SRowLst.GetNodeCount(); <br> <br>hr = MAPIAllocateBuffer(sizeof(SPropValue) * C_ACLPROPS, <br>(LPVOID FAR *)&amp;sr.lpProps); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>    } <br> <br>memset(sr.lpProps, 0, sizeof(SPropValue) * C_ACLPROPS); <br> <br>hr = MAPIAllocateMore(cbentryid, <br>  sr.lpProps, <br>    (LPVOID FAR *)&amp;lpentryidCopy); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>    } <br> <br>memcpy(lpentryidCopy, lpentryid, cbentryid); <br> <br>hr = MAPIAllocateMore(strlen(lpszDisplayName) + sizeof(char), <br>  sr.lpProps, <br>    (LPVOID FAR *)&amp;lpszDisplayNameCopy); <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>    } <br> <br>strcpy(lpszDisplayNameCopy, lpszDisplayName); <br> <br>sr.lpProps[I_MEMBER_ENTRYID].ulPropTag =PR_MEMBER_ENTRYID; <br>sr.lpProps[I_MEMBER_ENTRYID].Value.bin.cb =cbentryid; <br>sr.lpProps[I_MEMBER_ENTRYID].Value.bin.lpb =(LPBYTE)lpentryidCopy; <br> <br>sr.lpProps[I_MEMBER_RIGHTS].ulPropTag =PR_MEMBER_RIGHTS; <br>sr.lpProps[I_MEMBER_RIGHTS].Value.l =lRights; <br> <br>sr.lpProps[I_MEMBER_NAME].ulPropTag =PR_MEMBER_NAME; <br>sr.lpProps[I_MEMBER_NAME].Value.lpszA =lpszDisplayNameCopy; <br> <br>hr = m_pFA-&gt;m_SRowLst.HrInsert(&amp;sr); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = m_pFA-&gt;m_SRowLst.HrWriteToTable(m_pFA-&gt;m_lpExchTbl); <br> <br>if (FAILED(hr)) <br>{ <br>HRESULThrTmp = NOERROR; <br> <br>// Delete the node from the list, since the table write failed. <br> <br>m_pFA-&gt;m_SRowLst.SetCursor(lPosInsertion); <br> <br>hrTmp = m_pFA-&gt;m_SRowLst.HrDelete(); <br> <br>if (FAILED(hrTmp)) <br>hr = HR_LOG(E_UNEXPECTED); <br> <br>// The memory allocated by this method was cleaned up when the <br>// node was deleted. <br> <br>sr.lpProps = NULL; <br>goto cleanup; <br>} <br> <br>// Determine what rights bits are actually set. <br> <br>hr = m_pFA-&gt;HrGetTableEntry(cbentryid, <br>lpentryid, <br>NULL, <br>&amp;lNewRights); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_UNEXPECTED); <br> <br>// The memory allocated by this method is still associated with <br>// the list. <br> <br>sr.lpProps = NULL; <br>goto cleanup; <br>} <br> <br>if (lNewRights != lRights) <br>{ <br>LONGlPos =m_pFA-&gt;m_SRowLst.GetCursor(); <br>CSROWNODE *pNode = NULL; <br> <br>m_pFA-&gt;m_SRowLst.SetCursor(lPosInsertion); <br> <br>pNode = m_pFA-&gt;m_SRowLst.GetCurrentNode(); <br> <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_RIGHTS].Value.l = lNewRights; <br> <br>m_pFA-&gt;m_SRowLst.SetCursor(lPos); <br>} <br> <br>if (lplRights != NULL) <br>*lplRights = lNewRights; <br> <br>cleanup: <br> <br>if (FAILED(hr)) <br>MAPIFREEBUFFER(sr.lpProps); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderACLs::HrModify------------------------------------------- <br>// <br>// DESCRIPTION:Modify rights for the current record. <br>// <br>// INPUT: <br>// <br>//[lRights]-- Rights bits requested to be set. <br>// <br>// OUTPUT: <br>// <br>//[lplRights]-- Ptr to rights bits actually set on completion; if <br>//   this info is not wanted, specify NULL. <br>// <br>// RETURNS:NOERRORif successful;  <br>//              E_FAILotherwise. <br>// <br>// Notes:We need to return *lplRights because the Exchange MDB may set <br>//extra bits, depending on the user and other circumstances. <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderACLs::HrModify(// RETURNS: HRESULT <br>INLONGlRights,         // input rights bits <br>OUTLPLONGlplRights// ptr to output rights bits <br>) <br>{ <br>    HRESULThr =NOERROR; <br>LONGlNewRights =0; <br>LONGlPrvRights =0; <br>CSROWNODE *pNode = NULL; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::HrModify().\n"); <br> <br>    hr = CHK_CIExchangeFolderACLs_HrModify(lplRights); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA."); <br> <br>pNode = m_pFA-&gt;m_SRowLst.GetCurrentNode(); <br> <br>if (pNode == NULL) <br>{ <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>lPrvRights = pNode-&gt;m_SRow.lpProps[I_MEMBER_RIGHTS].Value.l; <br> <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_RIGHTS].Value.l = lRights; <br> <br>hr = m_pFA-&gt;m_SRowLst.HrWriteToTable(m_pFA-&gt;m_lpExchTbl); <br> <br>if (FAILED(hr)) <br>{ <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_RIGHTS].Value.l = lPrvRights; <br>goto cleanup; <br>} <br> <br>// Determine what rights bits are actually set. <br> <br>hr = m_pFA-&gt;HrGetTableEntry( <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_ENTRYID].Value.bin.cb, <br>(LPENTRYID)pNode-&gt;m_SRow.lpProps[I_MEMBER_ENTRYID].Value.bin.lpb, <br>NULL, <br>&amp;lNewRights); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>pNode-&gt;m_SRow.lpProps[I_MEMBER_RIGHTS].Value.l = lNewRights; <br> <br>if (lplRights != NULL) <br>*lplRights = lNewRights; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderACLs::HrSeek--------------------------------------------- <br>// <br>// DESCRIPTION:Set the current cursor position. <br>// <br>// INPUT: <br>// <br>// [lPos]-- New cursor position. <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderACLs::HrSeek(// RETURNS: HRESULT <br>INLONGlPos// cursor position <br>) <br>{ <br>    HRESULThr =NOERROR; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::HrSeek().\n"); <br> <br>    hr = CHK_CIExchangeFolderACLs_HrSeek(lPos); <br> <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA."); <br> <br>m_pFA-&gt;m_SRowLst.SetCursor(lPos); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CIExchangeFolderACLs::HrTell--------------------------------------------- <br>// <br>// DESCRIPTION:Return the current cursor position. <br>// <br>// OUTPUT: <br>// <br>// [lplPos]-- Ptr for returning current cursor position. <br>// <br>// RETURNS:NOERRORif successful;  <br>//E_INVALIDARGif bad input. <br>// <br>//----------------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CIExchangeFolderACLs::HrTell(// RETURNS: HRESULT <br>OUTLPLONGlplPos// cursor position ptr <br>) <br>{ <br>    HRESULThr =NOERROR; <br> <br>    DEBUGPUBLIC("CIExchangeFolderACLs::HrTell().\n"); <br> <br>    hr = CHK_CIExchangeFolderACLs_HrTell(lplPos); <br>     <br>    if (FAILED(hr)) <br>        RETURN(hr); <br> <br>    ASSERT_READ_PTR_OR_NULL(m_pFA, sizeof(CFolderACLs FAR *), "Bad m_pFA."); <br> <br>*lplPos = m_pFA-&gt;m_SRowLst.GetCursor(); <br> <br>    RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
