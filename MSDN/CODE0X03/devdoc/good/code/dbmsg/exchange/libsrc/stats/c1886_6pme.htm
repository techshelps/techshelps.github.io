<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIFO.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1886"></a>FIFO.CPP</h2>
<pre><code>// --fifo.cpp------------------------------------------------------------------- <br>//  <br>//  Implements a FIFO buffer. <br>//  <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "fifo.h" <br>#include "fifo.chk" <br> <br>//$--CFIFO::CFIFO--------------------------------------------------------------- <br>//  Constructor <br>// ----------------------------------------------------------------------------- <br>CFIFO::CFIFO() <br>{ <br>    DEBUGPRIVATE("CFIFO::CFIFIO()\n"); <br> <br>    m_nElements       = 0; <br>    m_maxElements     = 0; <br>    m_iCurrentElement = 0; <br>    m_padwFIFOBuffer  = NULL; <br>} <br> <br>//$--CFIFO::~CFIFO-------------------------------------------------------------- <br>//  Destructor <br>// ----------------------------------------------------------------------------- <br>CFIFO::~CFIFO() <br>{ <br>    DEBUGPRIVATE("CFIFO::~CFIFIO()\n"); <br> <br>    FREE(m_padwFIFOBuffer); <br>} <br> <br> <br>//$--CFIFO::HrReset------------------------------------------------------------- <br>//  Resets the FIFO buffer. Should be called after object is constructed <br>//  and before it is used. <br>// ----------------------------------------------------------------------------- <br>HRESULT CFIFO::HrReset(                 // RETURNS: NOERROR if reset successful. <br>    IN DWORD maxElements)               // Maximum number of elements in buffer.  <br>{ <br>    HRESULT hr  = NOERROR; <br>    DWORD cb    = sizeof(DWORD) * maxElements; <br> <br>    DEBUGPRIVATE("CFIFO::HrReset()\n"); <br> <br>hr = CHK_CFIFO_HrReset(maxElements); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>    FREE(m_padwFIFOBuffer); <br> <br>    m_padwFIFOBuffer = (DWORD *) malloc( cb ); <br>    if (m_padwFIFOBuffer == NULL) <br>    { <br>        hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>    FillMemory(m_padwFIFOBuffer,cb,0); <br> <br>    m_maxElements     = maxElements; <br>    m_nElements       = 0; <br>    m_iCurrentElement = 0; <br> <br>cleanup: <br>    RETURN(hr);         <br>     <br>} <br> <br> <br>//$--CFIFO::PushElement--------------------------------------------------------- <br>//  Pushes a new element into the FIFO buffer. Returns the value pushed out <br>//  the other side. <br>// ----------------------------------------------------------------------------- <br>VOID CFIFO::PushElement(         <br>    IN DWORD dwValue,           // New Value to Push into buffer.  <br>    OUT DWORD &amp;dwPushedOut)     // Recieves old value pushed out of buffer.  <br>{ <br>    HRESULT hr  = NOERROR; <br> <br>    DEBUGPRIVATE("CFIFO::PushElement()\n"); <br> <br>hr = CHK_CFIFO_PushElement(dwValue, dwPushedOut); <br>if (FAILED(hr)) <br>return; <br> <br>    // Return whatever is at curent element. <br>    // ------------------------------------- <br>    dwPushedOut = m_padwFIFOBuffer[m_iCurrentElement]; <br>    m_padwFIFOBuffer[m_iCurrentElement] = dwValue; <br> <br>    if (m_nElements &lt; m_maxElements) <br>    { <br>        m_nElements++; <br>    } <br>         <br>    // Update current element pointer <br>    //------------------------------- <br>    m_iCurrentElement++; <br>    if (m_iCurrentElement &gt;= m_maxElements) <br>    { <br>        m_iCurrentElement = 0; <br>    } <br> <br>    return; <br>} <br> <br> <br>//$--CFIFO::PushNNulls---------------------------------------------------------- <br>//  Push a number of 0 Values into the FIFO buffer.  Returns a summation <br>//  of the values pushed out the other side. <br>// ----------------------------------------------------------------------------- <br>VOID CFIFO::PushNNulls(          <br>    IN DWORD cNulls,            // Number of NULLS to push.  <br>    OUT DWORD &amp;dwPushedOut)     // Receives total values pushed out.  <br>{ <br>    HRESULT hr  = NOERROR; <br>    DWORD i = 0; <br>    DWORD cCurrentToEnd = 0; <br> <br>    DEBUGPRIVATE("CFIFO::PushNNulls()\n"); <br> <br>hr = CHK_CFIFO_PushNNulls(cNulls, dwPushedOut); <br>if (FAILED(hr)) <br>return; <br> <br>    dwPushedOut = 0; <br> <br>    if (cNulls == 0) <br>        goto cleanup; <br> <br>    // case: cNulls is larger than the max number of buffer elements. <br>    // Action: Clear the entire buffer and reset the current index. <br>    // ------------------------------------------------------------ <br>    if (cNulls &gt;=  m_maxElements) <br>    { <br>        for (i=0; i&lt;m_maxElements; i++) <br>        { <br>            dwPushedOut += m_padwFIFOBuffer[i]; <br>            m_padwFIFOBuffer[i] = 0 ; <br>        } <br> <br>        m_iCurrentElement = 0; <br>        goto cleanup; <br>    } <br> <br>    // case: cNulls will advance current index past end of buffer <br>    // action:  1) clear the elements from current index+1 to end of buffer. <br>    //          2) clear elements from start of buffer to new index.  <br>    // --------------------------------------------------------------------- <br>    cCurrentToEnd = (m_maxElements-1) - m_iCurrentElement; <br>    if (cNulls &gt; cCurrentToEnd) <br>    { <br>        for (i=m_iCurrentElement; i&lt;m_maxElements; i++) <br>        { <br>            dwPushedOut += m_padwFIFOBuffer[i]; <br>            m_padwFIFOBuffer[i] = 0; <br>        }  <br> <br>        m_iCurrentElement = cNulls - cCurrentToEnd - 1; <br>        for (i=0; i&lt; m_iCurrentElement; i++) <br>        { <br>            dwPushedOut += m_padwFIFOBuffer[i]; <br>            m_padwFIFOBuffer[i] = 0; <br>        }  <br>        goto cleanup; <br>    } <br> <br>    // case: cbDelta will not advance current pointer past end of buffer <br>    // action: clear the elements between the old current index and the <br>    //         new current index. <br>    // ----------------------------------------------------------------- <br>    for (i=0; i&lt;cNulls; i++)    <br>    { <br>        dwPushedOut += m_padwFIFOBuffer[m_iCurrentElement+i]; <br>        m_padwFIFOBuffer[m_iCurrentElement+i] = 0; <br>    }  <br>    m_iCurrentElement += cNulls; <br> <br>cleanup: <br>    m_nElements += cNulls; <br>    if (m_nElements &gt; m_maxElements) <br>    { <br>        m_nElements = m_maxElements; <br>    } <br> <br>    return; <br>} <br> <br> <br>//$--CFIFO::Min----------------------------------------------------------------- <br>// Returns the minimum value in the buffer.  <br>// ----------------------------------------------------------------------------- <br>VOID CFIFO::Min( <br>    OUT DWORD &amp;dwMin)  // receives the minimum of all values in the buffer.  <br>{ <br>    HRESULT hr  = NOERROR; <br>    DWORD i = 0; <br> <br>    DEBUGPRIVATE("CFIFO::Min()\n"); <br> <br>hr = CHK_CFIFO_Min(dwMin); <br>if (FAILED(hr)) <br>return; <br> <br>    dwMin = MAXWORD; <br> <br>    if (m_nElements == 0) <br>    { <br>        dwMin = 0; <br>        goto cleanup; <br>    } <br> <br>    for (i=0; i&lt;m_iCurrentElement; i++) <br>    { <br>        if (m_padwFIFOBuffer[i] &lt; dwMin ) <br>            dwMin = m_padwFIFOBuffer[i]; <br>    } <br> <br>    for (i=m_iCurrentElement; i&lt;m_nElements; i++) <br>    { <br>        if (m_padwFIFOBuffer[i] &lt; dwMin ) <br>            dwMin = m_padwFIFOBuffer[i]; <br>    } <br> <br>cleanup: <br>    return; <br>} <br> <br> <br>//$--CFIFO::Max----------------------------------------------------------------- <br>// Returns the maximum value in a buffer.  <br>// ----------------------------------------------------------------------------- <br>VOID CFIFO::Max( <br>    OUT DWORD &amp;dwMax)  // receives the maximum value in the buffer.  <br>{ <br>    HRESULT hr  = NOERROR; <br>    DWORD i = 0; <br> <br>    DEBUGPRIVATE("CFIFO::Max()\n"); <br> <br>hr = CHK_CFIFO_Max(dwMax); <br>if (FAILED(hr)) <br>return; <br> <br>    dwMax = 0; <br>   <br>    for (i=0; i&lt;m_iCurrentElement; i++) <br>    { <br>        if (m_padwFIFOBuffer[i] &gt; dwMax ) <br>           dwMax = m_padwFIFOBuffer[i]; <br>    } <br> <br>    for (i=m_iCurrentElement; i&lt;m_nElements; i++) <br>    { <br>        if (m_padwFIFOBuffer[i] &gt; dwMax ) <br>            dwMax = m_padwFIFOBuffer[i]; <br>    } <br> <br>    return; <br>} <br> <br> <br>//$--CFIFO::Average------------------------------------------------------------- <br>// Returns the average value in the buffer. <br>// ----------------------------------------------------------------------------- <br>VOID CFIFO::Average( <br>    OUT DWORD &amp;dwAverage)  // receives buffer average  <br>{ <br>    HRESULT hr  = NOERROR; <br>    DWORD i = 0; <br>    DWORD dwSum = 0; <br> <br>    DEBUGPRIVATE("CFIFO::Average()\n"); <br> <br>hr = CHK_CFIFO_Average(dwAverage); <br>if (FAILED(hr)) <br>return; <br> <br>    dwAverage = 0; <br>   <br>    for (i=0; i&lt;m_iCurrentElement; i++) <br>    { <br>        dwSum += m_padwFIFOBuffer[i]; <br>    } <br> <br>    for (i=m_iCurrentElement; i&lt;m_nElements; i++) <br>    { <br>        dwSum += m_padwFIFOBuffer[i]; <br>    } <br> <br>    if (m_nElements != 0) <br>        dwAverage = dwSum / m_nElements; <br>    return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
