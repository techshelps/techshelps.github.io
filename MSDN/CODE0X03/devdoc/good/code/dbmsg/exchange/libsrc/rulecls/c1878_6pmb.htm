<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SROWLST.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1883"></a>SROWLST.CPP</h2>
<pre><code>// --srowlst.cpp--------------------------------------------------------------- <br>// <br>// Implementation of classes CSROWNODE and CSROWLST. <br>//   <br>// Copyright (C) Microsoft Corp., 1986-1996.  All rights reserved. <br>// <br>//----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "srowlst.h" <br> <br>// $--CSROWNODE::CSROWNODE----------------------------------------------------- <br>// <br>// DESCRIPTION:CSROWNODE constructor. <br>// <br>// INPUT: <br>// <br>//[lpSRow]-- Ptr to SRow for the CSROWNODE to be constructed. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CSROWNODE::CSROWNODE( <br>INLPSRowlpSRow  // row set ptr <br>    ) <br>{ <br>    DEBUGPRIVATE("CSROWNODE::CSROWNODE()\n"); <br> <br>    m_pNxt =NULL; <br>    m_pPrv =NULL; <br>m_SRow =*lpSRow; <br>} <br> <br> <br>// $--CSROWNODE::~CSROWNODE---------------------------------------------------- <br>// <br>// DESCRIPTION:CSROWNODE destructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CSROWNODE::~CSROWNODE() <br>{ <br>    DEBUGPRIVATE("CSROWNODE::~CSROWNODE()\n"); <br> <br>MAPIFREEBUFFER(m_SRow.lpProps); <br>} <br> <br>// $--CSROWLST::CSROWLST------------------------------------------------------- <br>// <br>// DESCRIPTION:CSROWLST constructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CSROWLST::CSROWLST() <br>{ <br>    DEBUGPRIVATE("CSROWLST::CSROWLST()\n"); <br> <br>m_cNodes =0; <br>m_cOtherProvNodes =0; <br>m_lPos =RULE_PAST_END; <br>m_lpszProvider =NULL; <br>    m_pCurNode =NULL; <br>    m_pLstHd =NULL; <br>m_pOtherProvLstHd =NULL; <br>} <br> <br> <br>// $--CSROWLST::~CSROWLST------------------------------------------------------ <br>// <br>// DESCRIPTION:CSROWLST destructor. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>CSROWLST::~CSROWLST() <br>{ <br>    CSROWNODE *pNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::~CSROWLST()\n"); <br> <br>MAPIFREEBUFFER(m_lpszProvider); <br> <br>    while (m_pLstHd != NULL) <br>    { <br>        pNode = m_pLstHd; <br>        m_pLstHd = m_pLstHd-&gt;m_pNxt; <br>delete pNode; <br>    } <br> <br>    while (m_pOtherProvLstHd != NULL) <br>    { <br>        pNode = m_pOtherProvLstHd; <br>        m_pOtherProvLstHd = m_pOtherProvLstHd-&gt;m_pNxt; <br>delete pNode; <br>    } <br>} <br> <br> <br>// $--CSROWLST::HrInitialize--------------------------------------------------- <br>// <br>// DESCRIPTION:Initialize an CSROWLST.  An SRowSet is stored in the CSROWLST. <br>//The SROWNODES are sorted in ascending order based on the <br>//value of PR_RULE_SEQUENCE in the SRow's.  Upon completion of <br>//this method, either successful or unsuccessful, all storage <br>//associated with lpRows has either been reassigned to the <br>//CSROWLST, or has been deallocated.  Only rules associated <br>//with lpszProvider are visible to users.  Other rules are <br>//stored in the m_pOtherProvLstHd list so they may be written back <br>//out to the rules table when necessary. <br>// <br>// INPUT: <br>// <br>//  [lpszProvider]-- Provider for rules.  Multiple providers may have <br>//   rules on a folder. The IExchangeFolderRules interface <br>//   provides access to the rules associated with a <br>//   single specified provider.  May be NULL, in which case <br>//   a provider list can be obtained, but no other operations <br>//   are possible. <br>// <br>//INPUT/OUTPUT: <br>// <br>//[lpRows]-- Ptr to SRowSet to use in initializing the CSROWLST. <br>// <br>// RETURNS:NOERROR on success; <br>//              E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif insufficient memory; <br>//              E_FAILotherwise. <br>// <br>// Warning:lpRows is NO LONGER VALID after calling this function and <br>//should NOT be used or deallocated! <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrInitialize(// RETURNS: HRESULT <br>INLPSTRlpszProvider,// provider name <br>IN OUTLPSRowSetlpRows      // row set ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>ULONGi =0; <br>    CSROWNODE *pCurNode =NULL; <br>    CSROWNODE *pNewNode =NULL; <br>ULONGulCurSeqNo =0; <br>ULONGulNewSeqNo =0; <br> <br>    DEBUGPRIVATE("CSROWLST::HrInitialize()\n"); <br> <br>// Verify that all rows have the necessary properties.  We are somewhat <br>// draconian in insisting that everything is right; given a multiplicity <br>// of providers, however, it is a good safeguard against the unexpected. <br> <br>for (i = 0; i &lt; lpRows-&gt;cRows; i++) <br>{ <br>if (lpRows-&gt;aRow[i].cValues &lt; C_RULEPROPS|| <br>lpRows-&gt;aRow[i].lpProps[I_RULE_SEQUENCE].ulPropTag != <br>PR_RULE_SEQUENCE|| <br>lpRows-&gt;aRow[i].lpProps[I_RULE_STATE].ulPropTag != <br>PR_RULE_STATE|| <br>lpRows-&gt;aRow[i].lpProps[I_RULE_CONDITION].ulPropTag != <br>PR_RULE_CONDITION|| <br>lpRows-&gt;aRow[i].lpProps[I_RULE_ACTIONS].ulPropTag != <br>PR_RULE_ACTIONS|| <br>lpRows-&gt;aRow[i].lpProps[I_RULE_PROVIDER].ulPropTag != <br>PR_RULE_PROVIDER|| <br>lpRows-&gt;aRow[i].lpProps[I_RULE_PROVIDER].Value.lpszA == NULL|| <br>lpRows-&gt;aRow[i].lpProps[I_RULE_LEVEL].ulPropTag != <br>PR_RULE_LEVEL|| <br>lpRows-&gt;aRow[i].lpProps[I_RULE_NAME].ulPropTag != <br>PR_RULE_NAME) <br>{ <br>hr = HR_LOG(E_INVALIDARG); <br>goto cleanup; <br>} <br>} <br> <br>if (lpszProvider == NULL) <br>{ <br>for (i = 0; i &lt; lpRows-&gt;cRows; i++) <br>{ <br>pNewNode = new CSROWNODE(&amp;lpRows-&gt;aRow[i]); <br> <br>if (pNewNode == NULL) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>// The lpProps storage no longer belongs to the SRowSet, so: <br> <br>lpRows-&gt;aRow[i].cValues = 0; <br>lpRows-&gt;aRow[i].lpProps = NULL; <br> <br>AddToDLLTail(pNewNode, m_pOtherProvLstHd); <br> <br>m_cOtherProvNodes++; <br>} <br>} <br>else <br>{ <br>// Add the SRow's in the SRowSet to the row list.  If there are <br>// two identical sequence numbers associated with one provider, abort <br>// with an error.  Note that SRow's associated with the specified <br>// provider are added to the m_pLstHd list, and all other SRow's are <br>// added to the m_pOtherProvLstHd list. <br> <br>hr = MAPIAllocateBuffer(strlen(lpszProvider) + 1, <br>(LPVOID FAR *)&amp;m_lpszProvider); <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>strcpy(m_lpszProvider, lpszProvider); <br> <br>for (i = 0; i &lt; lpRows-&gt;cRows; i++) <br>{ <br>pNewNode = new CSROWNODE(&amp;lpRows-&gt;aRow[i]); <br> <br>if (pNewNode == NULL) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>// The lpProps storage no longer belongs to the SRowSet, so: <br> <br>lpRows-&gt;aRow[i].cValues = 0; <br>lpRows-&gt;aRow[i].lpProps = NULL; <br> <br>if (stricmp(lpszProvider, <br>pNewNode-&gt;m_SRow.lpProps[I_RULE_PROVIDER].Value.lpszA)) <br>{ <br>AddToDLLTail(pNewNode, m_pOtherProvLstHd); <br> <br>m_cOtherProvNodes++; <br>} <br>else <br>{ <br>if (m_pLstHd == NULL) <br>{ <br>AddToDLLHead(pNewNode, m_pLstHd); <br>m_cNodes++; <br>} <br>else <br>{ <br>ulNewSeqNo = <br>pNewNode-&gt;m_SRow.lpProps[I_RULE_SEQUENCE].Value.ul; <br> <br>// We walk through the list backwards to insert the new <br>// node, in order to get an O(n) sort for a previously <br>// sorted table (which is what we always write, but we have <br>// to do this because there are no guarantees regarding <br>// what others write).  See llmacro.h to understand the <br>// double linked list structure and macro calls. <br> <br>pCurNode = m_pLstHd-&gt;m_pPrv; <br> <br>ulCurSeqNo = <br>pCurNode-&gt;m_SRow.lpProps[I_RULE_SEQUENCE].Value.ul; <br> <br>while (TRUE) <br>{ <br>if (ulCurSeqNo &lt; ulNewSeqNo) <br>{ <br>InsertIntoDLL(pNewNode, m_pLstHd, pCurNode); <br>m_cNodes++; <br>break; <br>} <br>else if (ulCurSeqNo == ulNewSeqNo) <br>{ <br>delete pNewNode; <br> <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>else <br>{ <br>if (pCurNode == m_pLstHd) <br>{ <br>AddToDLLHead(pNewNode, m_pLstHd); <br>m_cNodes++; <br>break; <br>} <br>else <br>{ <br>pCurNode = pCurNode-&gt;m_pPrv; <br> <br>ulCurSeqNo = <br>pCurNode-&gt; <br>m_SRow.lpProps[I_RULE_SEQUENCE].Value.ul; <br>} <br>} <br>} <br>} <br>} <br>} <br>} <br> <br>if (m_cNodes &gt; 0) <br>{ <br>m_lPos = 0; <br>m_pCurNode = m_pLstHd; <br>} <br> <br>cleanup: <br> <br>FREEPROWS(lpRows); <br> <br>RETURN(hr); <br>} <br> <br> <br>// $--CSROWLST::HrDelete------------------------------------------------------- <br>// <br>// DESCRIPTION:Delete the current record. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:NOERROR on success; <br>//E_FAIL if current cursor value is RULE_PAST_END. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrDelete(VOID)// RETURNS: HRESULT <br>{ <br>    HRESULThr =NOERROR; <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::HrDelete()\n"); <br> <br>hr = HrRemoveFromLst(&amp;pNode); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>delete pNode; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--HrGetProviders----------------------------------------------------------- <br>// <br>// DESCRIPTION:Get an array of rules provider names. <br>// <br>// OUTPUT: <br>// <br>//  [lpcProviders]-- Pointer to ulong that will be set to count of <br>//   providers on successful return. <br>//[lpppszProviders]-- Pointer to array of string pointers that will be set <br>//   to point at an array of provider name string pointers <br>//   on successful return. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_OUTOFMEMORYif not enough memory; <br>//              E_FAIL otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrGetProviders(// RETURNS: HRESULT <br>OUTLPULONGlpcProviders,// count of providers <br>OUTLPSTR FAR * FAR *lpppszProviders// ptr to array of providers <br>) <br>{ <br>ULONGcProviders =0; <br>ULONGcProvidersMax =(m_cNodes &gt; 0 ? 1 : 0) + m_cOtherProvNodes; <br>    HRESULThr =NOERROR; <br>ULONGi =0; <br>LPSTRlpszProvider=NULL; <br>LPSTR *lppszProviders =NULL; <br>CSROWNODE *pNode =m_pOtherProvLstHd; <br> <br>    DEBUGPRIVATE("HrGetProviders()\n"); <br> <br>*lpppszProviders = NULL; <br> <br>hr = MAPIAllocateBuffer(cProvidersMax * sizeof(LPSTR), <br>(LPVOID FAR *)&amp;lppszProviders); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// Get an array of ptrs to all the providers. <br> <br>while (pNode != NULL) <br>{ <br>lpszProvider = pNode-&gt;m_SRow.lpProps[I_RULE_PROVIDER].Value.lpszA; <br> <br>for (i = 0; i &lt; cProviders; i++) <br>if (!stricmp(lpszProvider, lppszProviders[i])) <br>break; <br> <br>if (i == cProviders) <br>{ <br>lppszProviders[cProviders] = lpszProvider; <br>cProviders++; <br>} <br> <br>pNode = pNode-&gt;m_pNxt; <br>} <br> <br>if (m_lpszProvider != NULL) <br>{ <br>lppszProviders[cProviders] = m_lpszProvider; <br>cProviders++; <br>} <br> <br>// Now allocate a copy for the user. <br> <br>{ <br>ULONGcch =cProviders * sizeof(LPSTR); <br>LPSTR *lppsz =NULL; <br>CHAR *pch = NULL; <br> <br>for (i = 0; i &lt; cProviders; i++) <br>cch += (strlen(lppszProviders[i]) + 1); <br> <br>hr = MAPIAllocateBuffer(cch, (LPVOID FAR *)lpppszProviders); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>lppsz = *lpppszProviders; <br> <br>pch = ((CHAR *)lppsz) + (cProviders * sizeof(LPSTR)); <br> <br>for (i = 0; i &lt; cProviders; i++) <br>{ <br>strcpy(pch, lppszProviders[i]); <br> <br>lppsz[i] = pch; <br> <br>pch += (strlen(lppszProviders[i]) + 1); <br>} <br>} <br> <br>*lpcProviders = cProviders; <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(lppszProviders); <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CSROWLST::HrInsert------------------------------------------------------- <br>// <br>// DESCRIPTION:Insert a new CSROWNODE before the current record and advance <br>//the cursor.  This also adjusts PR_RULE_SEQUENCE values as <br>//appropriate, and provides a value for PR_RULE_PROVIDER (ie., <br>//the caller should leave this value NULL). <br>// <br>// INPUT: <br>// <br>//[lpSRow]-- Ptr to SRow for the CSROWNODE to be inserted. <br>// <br>// RETURNS:NOERRORon success; <br>//E_OUTOFMEMORYif insufficient memory; <br>//              E_FAILotherwise. <br>// <br>// Notes:The cursor is advanced only if it is not at RULE_PAST_END. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrInsert(// RETURNS: HRESULT <br>INLPSRowlpSRow      // row set ptr <br>) <br>{ <br>    HRESULThr =NOERROR; <br>CSROWNODE *pNewNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::HrInsert()\n"); <br> <br>if (m_cNodes == EDK_MAX_QUERY_ROWS) <br>    { <br>hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>if (m_lpszProvider == NULL) <br>    { <br>hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>pNewNode = new CSROWNODE(lpSRow); <br> <br>if (pNewNode == NULL) <br>    { <br>    hr = HR_LOG(E_OUTOFMEMORY); <br>        goto cleanup; <br>    } <br> <br>pNewNode-&gt;m_SRow.lpProps[I_RULE_PROVIDER].Value.lpszA = m_lpszProvider; <br> <br>if (m_pCurNode == m_pLstHd)// Covers empty list and insertion at head. <br>{ <br>AddToDLLHead(pNewNode, m_pLstHd); <br>} <br>else if (m_pCurNode == NULL)// Covers insertion at tail. <br>{ <br>AddToDLLTail(pNewNode, m_pLstHd); <br>} <br>else// Covers all other cases. <br>{ <br>// It is important to store the previous node ptr in a separate <br>// location because m_pCurNode-&gt;m_pPrv gets stomped on in <br>// InsertIntoDLL(). <br> <br>CSROWNODE *pPrvNode = m_pCurNode-&gt;m_pPrv; <br> <br>InsertIntoDLL(pNewNode, m_pLstHd, pPrvNode); <br>} <br> <br>m_cNodes++; <br> <br>if (m_lPos != RULE_PAST_END) <br>m_lPos++; <br> <br>ReSequence(); <br> <br>// Note that m_pCurNode does not change regardless of the insertion point. <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CSROWLST::HrRemoveFromLst------------------------------------------------ <br>// <br>// DESCRIPTION:Remove the current record from the list and make it available <br>//to the caller.  The caller is responsible for deleting the <br>//record when he no longer needs it. <br>// <br>// OUTPUT: <br>// <br>//[ppRemovedNode]-- Ptr that will be set to removed node on successful <br>//   return. <br>// <br>// RETURNS:NOERROR on success; <br>//E_FAIL if current cursor value is RULE_PAST_END. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrRemoveFromLst( <br>OUTCSROWNODE * *ppRemovedNode <br>) <br>{ <br>    HRESULThr =NOERROR; <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::HrRemoveFromLst()\n"); <br> <br>*ppRemovedNode = NULL; <br> <br>if (m_lPos == RULE_PAST_END) <br>    { <br>hr = HR_LOG(E_FAIL); <br>        goto cleanup; <br>    } <br> <br>pNode = m_pCurNode; <br> <br>m_pCurNode = m_pCurNode-&gt;m_pNxt; <br> <br>if (m_pCurNode == NULL) <br>m_lPos = RULE_PAST_END; <br> <br>RmFromDLL(pNode, m_pLstHd); <br> <br>m_cNodes--; <br> <br>*ppRemovedNode = pNode; <br> <br>cleanup: <br> <br>    RETURN(hr); <br>} <br> <br> <br>// $--CSROWLST::SetCursor------------------------------------------------------ <br>// <br>// DESCRIPTION:Standard C++ set member function which sets the current <br>//cursor position. <br>// <br>// INPUT: <br>// <br>//[lPos]-- New cursor position.  If &lt; 0 or past end of list, then the <br>//   new cursor positon will be set to RULE_PAST_END. <br>// <br>// RETURNS:The new cursor position. <br>// <br>//----------------------------------------------------------------------------- <br> <br>LONG <br>CSROWLST::SetCursor(// RETURNS: LONG <br>INLONGlPos// cursor position <br>) <br>{ <br>    DEBUGPRIVATE("CSROWLST::SetCursor()\n"); <br> <br>if (lPos &gt;= 0 &amp;&amp; lPos &lt; (LONG) m_cNodes) <br>{ <br>if (m_lPos == RULE_PAST_END || m_lPos &gt; lPos) <br>{ <br>m_pCurNode = m_pLstHd; <br>m_lPos = 0; <br>} <br> <br>while (m_lPos &lt; lPos) <br>{ <br>m_pCurNode = m_pCurNode-&gt;m_pNxt; <br>m_lPos++; <br>} <br>} <br>else <br>{ <br>m_lPos = RULE_PAST_END; <br>m_pCurNode =NULL; <br>} <br> <br>    return m_lPos; <br>} <br> <br> <br>// $--CSROWLST::ReSequence----------------------------------------------------- <br>// <br>// DESCRIPTION:Resequence the PR_RULE_SEQUENCE values so they are valid. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>CSROWLST::ReSequence(VOID)      // RETURNS: VOID <br>{ <br>CSROWNODE *pNode = NULL; <br>ULONGulLastSeqNo =0; <br> <br>    DEBUGPRIVATE("CSROWLST::ReSequence()\n"); <br> <br>// The following algorithm is designed to not change sequence numbers <br>// unless it is necessary.  This is done to protect providers that may <br>// assign special significance to some sequence values (not a great idea, <br>// but it is rumored to have occurred).  There is no protection against <br>// rollover of values, but that is hopefully not a very likely occurrence. <br> <br>if (m_pLstHd == NULL) <br>goto cleanup; <br> <br>ulLastSeqNo = m_pLstHd-&gt;m_SRow.lpProps[I_RULE_SEQUENCE].Value.ul; <br> <br>pNode = m_pLstHd-&gt;m_pNxt; <br> <br>while (pNode != NULL) <br>{ <br>if (pNode-&gt;m_SRow.lpProps[I_RULE_SEQUENCE].Value.ul &lt;= ulLastSeqNo) <br>pNode-&gt;m_SRow.lpProps[I_RULE_SEQUENCE].Value.ul = ulLastSeqNo + 1; <br> <br>ulLastSeqNo = pNode-&gt;m_SRow.lpProps[I_RULE_SEQUENCE].Value.ul; <br> <br>pNode = pNode-&gt;m_pNxt; <br>} <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>// $--CSROWLST::HrWriteToTable------------------------------------------------- <br>// <br>// DESCRIPTION:Write the contents of the CSROWLST to an EXCHANGEMODIFYTABLE. <br>// <br>// INPUT: <br>// <br>//[lpExchTbl]-- Ptr to the EXCHANGEMODIFYTABLE that will be rewritten based <br>//   on the contents of the CSROWLST. <br>// <br>// RETURNS:NOERRORon success;  <br>//              E_INVALIDARGif bad input; <br>//E_OUTOFMEMORYif insufficient memory; <br>//              E_FAILotherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>CSROWLST::HrWriteToTable(// RETURNS: HRESULT <br>INLPEXCHANGEMODIFYTABLElpExchTbl   // Exchange modify tbl i/f ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>LPROWENTRYlpRowEntry =NULL; <br>LPROWLISTlpRowList =NULL; <br>CSROWNODE *pNode =NULL; <br> <br>    DEBUGPRIVATE("CSROWLST::HrWriteToTable()\n"); <br> <br>// Make a ROWLIST for use with the IExchangeModifyTable interface.  We <br>// explicitly call MAPIAllocateBuffer() here due to the size vagaries  <br>// of MAPI structures. <br> <br>hr = MAPIAllocateBuffer(CbNewROWLIST(m_cNodes + m_cOtherProvNodes), <br>(LPVOID FAR *)&amp;lpRowList); <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>lpRowList-&gt;cEntries = m_cNodes + m_cOtherProvNodes; <br> <br>pNode = m_pLstHd; <br> <br>lpRowEntry = lpRowList-&gt;aEntries; <br> <br>while (pNode != NULL) <br>{ <br>lpRowEntry-&gt;ulRowFlags =ROW_ADD; <br>lpRowEntry-&gt;cValues =pNode-&gt;m_SRow.cValues; <br>lpRowEntry-&gt;rgPropVals =pNode-&gt;m_SRow.lpProps; <br> <br>lpRowEntry++; <br> <br>pNode = pNode-&gt;m_pNxt; <br>} <br> <br>pNode = m_pOtherProvLstHd; <br> <br>while (pNode != NULL) <br>{ <br>lpRowEntry-&gt;ulRowFlags =ROW_ADD; <br>lpRowEntry-&gt;cValues =pNode-&gt;m_SRow.cValues; <br>lpRowEntry-&gt;rgPropVals =pNode-&gt;m_SRow.lpProps; <br> <br>lpRowEntry++; <br> <br>pNode = pNode-&gt;m_pNxt; <br>} <br> <br>// Modify the entire table. <br> <br>hr = lpExchTbl-&gt;ModifyTable(ROWLIST_REPLACE, lpRowList); <br> <br>if (FAILED(hr)) <br>    { <br>        hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>    } <br> <br>cleanup: <br> <br>// Deallocate the ROWLIST (not including the SPropValue ptrs, since they <br>// still actually belong to the CSROWLST). <br> <br>MAPIFREEBUFFER(lpRowList); <br> <br>RETURN(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
