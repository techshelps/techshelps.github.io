<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DYNARRAY.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1947"></a>DYNARRAY.H</h2>
<pre><code>// ----------------------------------------------------------------------------- <br>// DynArray.h: Template Class that allows you to make a dynamic array of almost  <br>//             any type or class. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#ifndef _DYNARRAY_H_ <br>#define _DYNARRAY_H_ <br> <br>// ----------------------------------------------------------------------------- <br>// Use this class to create an array of almost any type or class.  The exception <br>// is with classes that have construction that does not initialize all data to  <br>// zero, classes that need destructors, or classes that can not be binary copied. <br>// <br>// Once the object is created usage of it is nearly identical to using a regular <br>// array of that type or class.  See example of usage at the end of this file. <br>// <br>// NOTE: When passing an object of CDynamicArray&lt; type&gt; as a parameter for a <br>//       variable argument list you must type cast it.  This is different usage  <br>//       from when the parameter is fixed and the compiler knows the type.   <br>//       See and example of this at the very end of this file. <br>//  <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class TYPE&gt; <br>class CDynamicArray <br>{ <br>public: <br>    // CONSTRUCTOR: Dynamicly creates an array. <br>    CDynamicArray( ULONG nCnt = 0); <br>     <br>    // DESTRUCTOR: Frees the memory that was allocated. <br>    ~CDynamicArray() {Delete();} <br> <br>    // Returns a pointer to the TYPE by just specifying the object. <br>    operator TYPE*() {return( m_ptr);} <br>     <br>    // Frees the memory that was allocated. <br>    void Delete(); <br> <br>    // Frees the memory that was allocated and then allocates a new block. <br>    void New( ULONG nCnt); <br> <br>    // Expand the array by nCnt.  Return TRUE if it was expanded. <br>    BOOL bExpand( ULONG nCnt); <br> <br>protected: <br>    TYPE*   m_ptr;  // Pointer to the array you ordered. <br>    ULONG   m_Size; // Number of items allocated. <br>}; <br> <br>// $--CDynamicArray&lt; TYPE&gt;::CDynamicArray()------------------------------------- <br>// CONSTRUCTOR: Dynamicly creates an array. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class TYPE&gt; <br>CDynamicArray&lt; TYPE&gt;::CDynamicArray( <br>    ULONG nCnt)     // Initial size of array.  It is okay to pass zero. <br>{ <br>    m_ptr = NULL; <br>    m_Size = 0; <br>    New( nCnt); <br>} <br> <br>// $--CDynamicArray&lt; TYPE&gt;::Delete()-------------------------------------------- <br>// Frees the memory that was allocated. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class TYPE&gt; <br>void CDynamicArray&lt; TYPE&gt;::Delete() <br>{ <br>    if( m_ptr) <br>    { <br>        delete [] m_ptr; <br>        m_ptr = NULL; <br>        m_Size = 0; <br>    } <br>} <br> <br>// $--CDynamicArray&lt; TYPE&gt;::New()----------------------------------------------- <br>// Frees the memory that was allocated and then allocates a new block. <br>// NOTE: If you already had copy of a pointer to this array you must reload it. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class TYPE&gt; <br>void CDynamicArray&lt; TYPE&gt;::New(  <br>    ULONG nCnt)     // Initial size of array.  It is okay to pass zero. <br>{ <br>    Delete();   // If there was data delete it. <br>    bExpand( nCnt); <br>} <br> <br>// $--CDynamicArray&lt; TYPE&gt;::bExpand()------------------------------------------- <br>// Expand the array by nCnt.  Return TRUE if it was expanded. <br>// NOTE: If you already had copy of a pointer to this array you must reload it. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class TYPE&gt; <br>BOOL CDynamicArray&lt; TYPE&gt;::bExpand( // RETURNS: TRUE if successful. <br>    ULONG nCnt)                     // Amount to expand array by. <br>{ <br>    if( !nCnt) <br>        return( TRUE);  // It is okay to pass zero. <br> <br>    // Allocate the additonal memory. <br>    TYPE* pNew = new TYPE[ m_Size + nCnt]; <br>    if( !pNew) <br>    {   // Could not allocate that much memory. <br>        HR_LOG( E_OUTOFMEMORY); <br>        return( FALSE); <br>    } <br> <br>    // Is this the first allocation? <br>    if( m_ptr) <br>    {   // NO, so copy previous allocation into this block. <br>        memcpy( pNew, m_ptr, m_Size * sizeof( TYPE)); <br>        delete [] m_ptr; <br>    } <br>     <br>    // Initialize new block of data to zero. <br>    memset( pNew + m_Size, 0, nCnt * sizeof( TYPE)); <br> <br>    // Adjust working pointers. <br>    m_ptr = pNew; <br>    m_Size += nCnt; <br>     <br>    return( TRUE); <br>} <br> <br>// ----------------------------------------------------------------------------- <br> <br>#ifdef _EXAMPLES_ <br>void TestCDynamicArray() <br>{ <br>    CDynamicArray&lt; char&gt; Str( 20);      // Construct an array of 20 characters. <br>    CDynamicArray&lt; int&gt; IntArray( 3);   // Construct an array of 3 integers. <br> <br>    if( !IntArray || !Str) <br>        return; // Could not allocate memory. <br>         <br>    strcpy( Str, "This is a dynamic test."); <br> <br>    IntArray[0] = 1; <br>    IntArray[1] = 2; <br>    IntArray[2] = 3; <br> <br>    IntArray.New( 6);       // Free old memory and reallocate 6 integers. <br>    if( !IntArray) <br>        return; // Could not allocate memory. <br> <br>    IntArray[0] = 11; <br>    IntArray[1] = 12; <br>    IntArray[2] = 13; <br>    IntArray[3] = 14; <br>    IntArray[4] = 15; <br>    IntArray[5] = 16; <br> <br>    // Expand array by 4 and bring it to a total size of 10. <br>    if( !IntArray.bExpand( 4)) <br>        return; // Could not allocate memory. <br> <br>    IntArray[6] = 17; <br>    IntArray[7] = 18; <br>    IntArray[8] = 19; <br>    IntArray[9] = 20; <br>         <br>    CDynamicArray&lt; char&gt; Buf( 100);     // Construct an array of 100 characters. <br>    if( !Buf) <br>        return; // Could not allocate memory. <br>     <br>    // NOTE: When passing an object of CDynamicArray&lt; type&gt; as a parameter for a <br>    //       variable argument list you must either type cast it.  This is different  <br>    //       usage from when the parameter is fixed and the compiler knows the type.   <br>    // <br>    //       Notice the difference in the way Buf is used and the way Str is used. The <br>    //       compiler knows the first parameter is a char* so it can use the opperator <br>    //       defined in our class to place m_ptr on the stack.  But in the case of Str <br>    //       The compiler does not know what the expected parameter is supposed to be <br>    //       so by default it will place the entire class on the stack.  In this case <br>    //       it would be m_ptr and m_Size. <br>    sprintf( Buf, "Look at some of the data. %s %d %d", (char*) Str, IntArray[3], IntArray[9]); <br>} <br> <br>#endif _EXAMPLES_ <br> <br>// ----------------------------------------------------------------------------- <br>#endif // _DYNARRAY_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
