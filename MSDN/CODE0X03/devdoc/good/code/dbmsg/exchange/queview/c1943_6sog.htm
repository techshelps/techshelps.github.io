<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRPLSTCB.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1960"></a>PRPLSTCB.H</h2>
<pre><code>// ----------------------------------------------------------------------------- <br>// PrpLstCb.h : header file <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#ifndef _PRPLSTCB_H_ <br>#define _PRPLSTCB_H_ <br> <br>#include "ErrCpp.h" <br>#include "Property.h" <br>#include "prplstcb.chk" <br> <br>// ----------------------------------------------------------------------------- <br> <br>#define ADMINOP_HIDDEN  0x01L <br>#define ADMINOP_DEFER   0x02L <br>#define ADMINOP_DELETE  0x04L <br>#define ADMINOP_NDR     0x08L <br> <br>// ----------------------------------------------------------------------------- <br>// Used to contain properties such as entry id and flags. <br>// ----------------------------------------------------------------------------- <br> <br>class CProps <br>{ <br>public: <br>    CProps( ULONG cbEID, BYTE* pEID, DWORD dwFlags); <br>    ~CProps(); <br> <br>    // Get the entry id and byte count for a specific index. <br>    ULONG GetByteCnt() {return( m_cbEID);} <br>    LPENTRYID GetEID() {return( (LPENTRYID) m_pEID);} <br>     <br>    // Functions to return the state of a flag. <br>    BOOL bTestFlags( DWORD dwBits) {return( (m_dwFlags &amp; dwBits) == dwBits);} <br>    BOOL bIsHidden()    {return( bTestFlags(ADMINOP_HIDDEN));} <br>    BOOL bIsDefer()     {return( bTestFlags(ADMINOP_DEFER));} <br>    BOOL bIsDelete()    {return( bTestFlags(ADMINOP_DELETE));} <br>    BOOL bIsNDR()       {return( bTestFlags(ADMINOP_NDR));} <br>    DWORD dwGetFlags()  {return( m_dwFlags);}   // Returns all of the flags. <br>     <br>    // Set one of the flags (pass in TRUE or FALSE). <br>    void SetHidden( BOOL bState)    { m_dwFlags = (m_dwFlags &amp; ~ADMINOP_HIDDEN) | bState;} <br>    void SetDefer( BOOL bState)     { m_dwFlags = (m_dwFlags &amp; ~ADMINOP_DEFER ) | bState &lt;&lt; 1;} <br>    void SetDelete( BOOL bState)    { m_dwFlags = (m_dwFlags &amp; ~ADMINOP_DELETE) | bState &lt;&lt; 2;} <br>    void SetNDR( BOOL bState)       { m_dwFlags = (m_dwFlags &amp; ~ADMINOP_NDR   ) | bState &lt;&lt; 3;} <br>     <br>protected: <br>    ULONG   m_cbEID; <br>    BYTE*   m_pEID; <br>    DWORD   m_dwFlags; <br>}; <br> <br>// Helper function. <br>inline BOOL bIsHidden( DWORD dwFlags) {return( (dwFlags &amp; 0x01) == 0x01);} <br> <br>// Used to replace a null CProps*. <br>extern CProps  NullCProps; <br> <br>// ----------------------------------------------------------------------------- <br>// Definition of a class that keeps a list of entry ids using struct _EID to  <br>// contain them.  This is a template class which is to be derived from either  <br>// CListBox or CComboBox. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class BASE_CLASS&gt; <br>class CPropsListComboBox : public BASE_CLASS <br>{ <br>public: <br>    CPropsListComboBox()    { m_pProps = NULL;} <br>    ~CPropsListComboBox()   { Destruct();} <br> <br>    // Fills the list or combo box with data from the table, uses HrAddItem to prepare the data. <br>    HRESULT HrFillBox( LPMAPITABLE pTable);     <br>     <br>    // Clears all data from the box. <br>    void ResetContent(); <br> <br>    // Use this to remove an item from the list. <br>    int DeleteString( int ii); <br>     <br>    // Get the entry id and byte count for a specific index. <br>    CProps* GetProps( int ii);  // Always returns valid pointer, GUARENTEED! <br>    ULONG GetByteCnt( int ii)   {return( GetProps( ii)-&gt;GetByteCnt());} <br>    LPENTRYID GetEID( int ii)   {return( GetProps( ii)-&gt;GetEID());} <br>    DWORD dwGetFlags( int ii)   {return( GetProps( ii)-&gt;dwGetFlags());} <br> <br>protected:     <br>    LPSPropTagArray     m_psPropColumns;    // Set this in your derived class. <br>    LPSSortOrderSet     m_psSortPrioSet;    // Set this in your derived class. <br>    CProps*             m_pProps;           // Used by AddString() and HrFillBox() <br> <br>    // Pure virtual function called by HrFillBox. <br>    virtual HRESULT HrAddItem( CProperty&amp; Properties) = 0; <br> <br>    // Used to add a string and its properties. <br>    int AddString( const LPCTSTR lpszItem); <br>     <br>    // Use this because we can't use a message map in a template class. <br>    virtual LRESULT WindowProc( UINT message, WPARAM wParam, LPARAM lParam); <br> <br>    // Clean up when the window has been destroyed. <br>    virtual void Destruct(); <br> <br>    // These functions may not be used unless they are implemented properly. <br>    int InsertString( UINT nIndex, LPCTSTR lpszItem)  <br>    {  <br>        ASSERTERROR( FALSE, "NOT IMPLEMENTED"); <br>        return( LB_ERR); <br>    } <br>}; <br> <br>// $--CPropsListComboBox&lt; BASE_CLASS&gt;::HrFillBox()------------------------------ <br>// Fill the list or combo box with data from a table.  This function reads the  <br>// data from the caller specified table and validates it. <br>//  <br>// A pure virtual function named HrAddItem() supplies the method for formating  <br>// and placing the data into the list or combo box.  HrAddItem() could also  <br>// decide to throw it away or use it.   <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class BASE_CLASS&gt; <br>HRESULT CPropsListComboBox&lt; BASE_CLASS&gt;::HrFillBox( <br>    LPMAPITABLE     pTable) <br>{ <br>    DEBUGPUBLIC( "CPropsListComboBox&lt; BASE_CLASS&gt;::HrFillBox()\n"); <br>    CHRESULT hr = CHK_CPropsListComboBox_HrFillBox( pTable); <br>    if(FAILED(hr)) <br>        RETURN( hr); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Setup the table's columns and sort order.   <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Set the columns to return. <br>    hr = pTable-&gt;SetColumns( m_psPropColumns, 0L); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Sort the table. <br>    hr = pTable-&gt;SortTable( m_psSortPrioSet, 0L); <br>    if(FAILED(hr)) <br>        RETURN( hr); <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Contents table has been initialize so lets display it. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>     <br>    // Clear the list/combo box of all entries. <br>    ResetContent();    <br> <br>    // Fill list/combo box with info from folder until end of table reached. <br>    while( TRUE) <br>    {   // Read the first 10 message headers from the contents table. <br>        CPropertyRows PropRowSet; <br>        CHRESULT hr = PropRowSet.HrGetTblRows( pTable); <br>        if( hr == EDK_E_END_OF_FILE ) <br>            return( NOERROR);    // All done. <br> <br>        if( FAILED( hr)) <br>            RETURN( hr); <br>             <br>        // Process all messages in the current table. <br>        for( PropRowSet.FirstRow(); !PropRowSet.bAtEndOfRows(); PropRowSet.NextRow()) <br>        {   // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>            // Validate that the property array has the correct number of values <br>            // and that it has the correct properties in the expected order. <br>            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>            //#ifdef DEBUG <br>                PropRowSet.First(); <br>                unsigned cProps = m_psPropColumns-&gt;cValues; <br>                if( PropRowSet.GetCount() &lt; cProps) <br>                { <br>                    RETURN( E_FAIL); <br>                } <br>                 <br>                if( PropRowSet.ulGetPrID() != PROP_ID( PR_GW_ADMIN_OPERATIONS)) <br>                { <br>                    RETURN( E_FAIL); <br>                } <br>                 <br>                PropRowSet.Next(); <br>                if( PropRowSet.ulGetPrID() != PROP_ID( PR_ENTRYID)) <br>                { <br>                    RETURN( E_FAIL); <br>                } <br> <br>                unsigned ii; <br>                for( ii = 2; ii &lt; cProps; ii ++) <br>                { <br>                    PropRowSet.Next(); <br>                    if( PropRowSet.ulGetPrID() != PROP_ID( m_psPropColumns-&gt;aulPropTag[ ii])) <br>                    { <br>                        RETURN( E_FAIL); <br>                    } <br>                } <br>            //#endif <br>             <br>            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>            // Extract the properties from pRowSet into useable objects. <br>            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>            PropRowSet.First(); <br> <br>            // PR_GW_ADMIN_OPERATIONS <br>            DWORD dwFlags; <br>            if( PropRowSet.ulGetPrType() != PT_LONG) <br>                dwFlags = 0; <br>            else <br>                dwFlags = PropRowSet.upvGetPrValue().ul; <br>            if( bIsHidden( dwFlags)) <br>                continue;   // No need to go any further, this one is hidden. <br> <br>            // PR_ENTRYID <br>            // Create a CProps object which will be added to list in AddString(). <br>            PropRowSet.Next(); <br>            if( m_pProps) <br>                delete m_pProps;     <br>            if( PropRowSet.ulGetPrType() != PT_BINARY) <br>                m_pProps = new CProps( 0, NULL, dwFlags); <br>            else <br>                m_pProps = new CProps( PropRowSet.upvGetPrValue().bin.cb, PropRowSet.upvGetPrValue().bin.lpb, dwFlags); <br> <br>            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>            // Add the item to the list. <br>            // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>            PropRowSet.Next(); <br>            hr = HrAddItem( PropRowSet); <br>            if( FAILED( hr)) <br>                RETURN( hr); <br>        } // End For Loop <br>    } <br>} <br> <br>// $--CPropsListComboBox&lt; BASE_CLASS&gt;::ResetContent()--------------------------- <br>// Frees all entry ids associated with the list box items and clears the list box. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class BASE_CLASS&gt; <br>void CPropsListComboBox&lt; BASE_CLASS&gt;::ResetContent() <br>{ <br>    // Are we still connected to the windows control? <br>    if( !::IsWindow(m_hWnd)) <br>        return; // NO, we are not connected. <br> <br>    // Free all property info objects. <br>    int ii = GetCount(); <br>    while( ii) <br>    { <br>        ii --; <br>        CProps* pProps = (CProps*) GetItemDataPtr( ii); <br>        delete pProps; <br>    } <br>    BASE_CLASS::ResetContent(); <br>} <br> <br>// $--CPropsListComboBox&lt; BASE_CLASS&gt;::DeleteString()--------------------------- <br>// Use this to remove an item from the list. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class BASE_CLASS&gt; <br>int CPropsListComboBox&lt; BASE_CLASS&gt;::DeleteString( int ii) // Index of list item. <br>{ <br>    // Are we still connected to the windows control? <br>    if( !::IsWindow(m_hWnd)) <br>    {   // NO, we are not connected. <br>        HR_LOG( E_FAIL); <br>        return(0);   <br>    } <br> <br>    // NOTE: This parameter test MUST be done after the above test since <br>    //       the GetCount() function depends upon being connected to the <br>    //       windows control. <br>    if( ii &lt; 0 || ii &gt;= GetCount()) <br>    { <br>        HR_LOG( E_FAIL); <br>        return( 0); <br>    } <br>     <br>    CProps* pProps = (CProps*) GetItemDataPtr( ii); <br>    delete pProps; <br>    return( BASE_CLASS::DeleteString( (UINT) ii)); <br>}     <br>     <br>// $--CPropsListComboBox&lt; BASE_CLASS&gt;::GetProps()------------------------------- <br>// Returns CProps object and GUARENTEES it to be valid.  This does error  <br>// checking and if it can't get the pointer requested it returns a pointer to  <br>// NullCProps which has NULL for all values and always exists. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class BASE_CLASS&gt; <br>CProps* CPropsListComboBox&lt; BASE_CLASS&gt;::GetProps( int ii)   // Index of entry id. <br>{ <br>    // Are we still connected to the windows control? <br>    if( !::IsWindow(m_hWnd)) <br>    { <br>        HR_LOG( E_FAIL); <br>        return(0);  // NO we are not connected. <br>    } <br> <br>    // NOTE: This parameter test MUST be done after the above test since <br>    //       the GetCount() function depends upon being connected to the <br>    //       windows control. <br>    if( ii &lt; 0 || ii &gt;= GetCount()) <br>    { <br>        HR_LOG( E_FAIL); <br>        return( &amp;NullCProps); <br>    } <br> <br>    CProps* pProps = (CProps*) GetItemDataPtr( ii); <br>    if( !pProps || pProps == (CProps*) -1l) <br>    { <br>        HR_LOG( E_FAIL); <br>        return( &amp;NullCProps); <br>    } <br> <br>    return( pProps); <br>} <br> <br>// $--CPropsListComboBox&lt; BASE_CLASS&gt;::AddString()------------------------------ <br>// Add a string to the list box and an entry id to associate with it. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class BASE_CLASS&gt; <br>int CPropsListComboBox&lt; BASE_CLASS&gt;::AddString( // Return index of list box item. <br>    const LPCTSTR lpszItem)                     // Ptr to string to add to list. <br>{ <br>    DEBUGPUBLIC( "CPropsListComboBox&lt; BASE_CLASS&gt;::AddString()\n"); <br>    if( FAILED( CHK_CPropsListComboBox_AddString( lpszItem))) <br>        return( LB_ERR); <br> <br>    // Add the displayable row to the list box. <br>int ii = BASE_CLASS::AddString( lpszItem); <br>    if( ii == LB_ERR) <br>    { <br>        HR_LOG( E_FAIL); <br>        return( ii); <br>    } <br>    else if( ii == LB_ERRSPACE) <br>    { <br>        HR_LOG( E_FAIL); <br>        return( ii); <br>    } <br> <br>// Add a pointer to the properties as additional data. <br>// Do we have properties to add? <br>if( m_pProps) <br>    {   // YES, so associate it with the box's row. <br>        SetItemDataPtr( ii, (void*) m_pProps); <br>        m_pProps = NULL;    // So it does not get deleted before it should. <br>    } <br>     <br>    return( ii); <br>} <br> <br>// $--CPropsListComboBox&lt; BASE_CLASS&gt;::WindowProc()----------------------------- <br>// Clean up when list box is being destroyed. <br>// Use this because we can't use a message map in a template class therefore <br>// we can't capture ON_WM_DESTROY in the usual MFC manor. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class BASE_CLASS&gt; <br>LRESULT CPropsListComboBox&lt; BASE_CLASS&gt;::WindowProc( UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    if( message == WM_DESTROY) <br>        Destruct(); <br>    return( CWnd::WindowProc( message, wParam, lParam)); // Dispatch message anyway. <br>} <br> <br>// $--CPropsListComboBox&lt; BASE_CLASS&gt;::Destruct()------------------------------- <br>// Clean up when the window has been destroyed.  This virtual function is  <br>// supplied so that derived classes do not have to implement a message map or  <br>// a WindowProc().  Plus we must delete all CProps objects. <br>// ----------------------------------------------------------------------------- <br> <br>template&lt; class BASE_CLASS&gt; <br>void CPropsListComboBox&lt; BASE_CLASS&gt;::Destruct() <br>{ <br>    ResetContent(); <br>    if( m_pProps) <br>    { <br>        delete m_pProps; <br>        m_pProps = NULL; <br>    } <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Derived class to support the list box in the QueViewer. <br>// ----------------------------------------------------------------------------- <br> <br>class CPropsListBox : public CPropsListComboBox&lt; CListBox&gt; <br>{ <br>public: <br>    CPropsListBox(); <br> <br>protected: <br>    // Virtual function called by HrFillBox. <br>    virtual HRESULT HrAddItem( CProperty&amp; Properties); <br>}; <br> <br>// ----------------------------------------------------------------------------- <br>// Derived class to support the combo box in the QueViewer. <br>// ----------------------------------------------------------------------------- <br> <br>class CPropsComboBox : public CPropsListComboBox&lt; CComboBox&gt; <br>{ <br>public: <br>    CPropsComboBox();     <br> <br>    // Find all folders, and open default folder. <br>    HRESULT HrInitialize( <br>        LPMDB   pMDB);  // Ptr to MDB that contain gateway folders. <br> <br>    // Returns TRUE if a folder selection has changed. <br>    BOOL bSelectionChanged() { return( m_iFolder != GetCurSel());} <br> <br>    // Returns the folder that is selected. <br>    LPMAPIFOLDER GetFolder() {return( m_pFolder);} <br>    BOOL bIsDefer()    { return( GetProps( m_iFolder)-&gt;bIsDefer());} <br>    BOOL bIsDelete()   { return( GetProps( m_iFolder)-&gt;bIsDelete());} <br>    BOOL bIsNDR()      { return( GetProps( m_iFolder)-&gt;bIsNDR());} <br> <br>protected: <br>    int                     m_iFolder;  // Index of folder being viewed. <br>    LPMAPIFOLDER            m_pFolder;  // Ptr to folder being viewed. <br>    LPMDB                   m_pMDB;     // Ptr to MSD of gateway.        <br>    CString                 m_sCurFolderName; // Contains name of selected folder. <br> <br>    // Open the selected folder. <br>    BOOL HrOpenFolder(); <br> <br>    // Virtual function called by HrFillBox. <br>    virtual HRESULT HrAddItem( CProperty&amp; Properties); <br>     <br>    // Clean up when the window has been destroyed. <br>    virtual void Destruct(); <br>}; <br> <br>// ----------------------------------------------------------------------------- <br>#ifdef _GLOBAL_OBJECTS_ <br>#pragma message("Declaration of global objects for: " __FILE__) <br> <br>// Used to replace a null CProps*. <br>CProps  NullCProps( 0, NULL, 0); <br> <br>#endif //_GLOBAL_OBJECTS_ <br>// ----------------------------------------------------------------------------- <br> <br>#endif //_PRPLSTCB_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
