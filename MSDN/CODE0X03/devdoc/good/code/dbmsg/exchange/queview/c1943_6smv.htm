<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROPERTY.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1957"></a>PROPERTY.CPP</h2>
<pre><code>// ----------------------------------------------------------------------------- <br>// Property.cpp: Implements methods for classes that works with IMAPIProp. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edkafx.h" <br>#include "property.h" <br>#include "propdef.h"    // Include only here!  Contains static declarations. <br>#include "ErrCpp.h" <br>#include "property.chk" <br> <br>#ifdef _DEBUG <br>#undef THIS_FILE <br>static char BASED_CODE THIS_FILE[] = __FILE__; <br>#endif <br> <br>// ----------------------------------------------------------------------------- <br>// CONSTRUCTOR <br>// ----------------------------------------------------------------------------- <br> <br>CProperty::CProperty() :  <br>    m_idlPropIDs( PropIDs, ARRAY_CNT( PropIDs)), <br>    m_idlPropTypes( PropTypes, ARRAY_CNT( PropTypes)) <br>{ <br>    Init(); <br>    m_bUnsigned = TRUE;     // Default treatment of int and long to unsigned. <br>    m_sDblFmt = "%10.2g";   // Default format for printing doubles. <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Set the default sign format for int and long.  Used by szGetPrValue() when <br>// caller does not provide a parameter. <br>// ----------------------------------------------------------------------------- <br> <br>BOOL CProperty::bSetUnsigned( BOOL bUnsigned) <br>{ <br>    BOOL bOldVal = m_bUnsigned; <br>    m_bUnsigned = bUnsigned; <br>    return( bOldVal); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Set the default format used for doubles and floats.  This would be in  <br>// printf() format. <br>// ----------------------------------------------------------------------------- <br> <br>CString CProperty::SetDblFmt( LPSTR pszDblFmt) <br>{ <br>    CString sRetVal = m_sDblFmt; <br>    m_sDblFmt = pszDblFmt; <br>    return( m_sDblFmt); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Frees the property list array. <br>// ----------------------------------------------------------------------------- <br> <br>void CProperty::Free(  <br>    ULONG cValues,          // Count of new properties. <br>    LPSPropValue pProps)    // Ptr to list of new properties. <br>{    <br>    MAPIFREEBUFFER( m_pFirstProp);  // Free old list of properties. <br>    Init( cValues, pProps);         // Initialize list with new properties. <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Gets the properties using an IMAPIProp interface. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CProperty::GetProps(  <br>    IMAPIProp*      imapiProp,  // MAPI interface to access properties with. <br>    LPSPropTagArray pta,        // Ptr to property tag array. <br>    ULONG           ulFlags)    // Optional flags, default to zero. <br>{ <br>    DEBUGPUBLIC( "CProperty::GetProps()\n"); <br>    CHRESULT hr = CHK_CProperty_GetProps( imapiProp, pta, ulFlags); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    Free(); <br>     <br>    // Get the properties using MAPI. <br>    hr = imapiProp-&gt;GetProps( pta, ulFlags, &amp;m_cValues, &amp;m_pFirstProp); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br>     <br>    // Setup to transverse through list of properties. <br>    m_pLastProp = m_pFirstProp + (m_cValues - 1);  <br>    First(); <br>     <br>    return( NOERROR); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Set current property to the next property. <br>// ----------------------------------------------------------------------------- <br> <br>void CProperty::Next() <br>{ <br>    if( m_pCurProp == NULL) <br>        m_pCurProp = m_pFirstProp; <br>    else if( m_pCurProp == m_pLastProp) <br>        m_pCurProp = NULL; <br>    else <br>        m_pCurProp ++; <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Get the current property ID as a ULONG. <br>// ----------------------------------------------------------------------------- <br> <br>ULONG CProperty::ulGetPrID() <br>{ <br>    ASSERTERROR( m_pCurProp != NULL, "m_pCurProp is NULL!"); <br>    if( m_pCurProp == NULL) <br>        return( 0); <br>     <br>    return( PROP_ID(m_pCurProp-&gt;ulPropTag)); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Get the current property TYPE as a ULONG. <br>// ----------------------------------------------------------------------------- <br> <br>ULONG CProperty::ulGetPrType() <br>{ <br>    ASSERTERROR( m_pCurProp != NULL, "m_pCurProp is NULL!"); <br>    if( m_pCurProp == NULL) <br>        return( 0); <br>     <br>    return(PROP_TYPE( m_pCurProp-&gt;ulPropTag)); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Get the current property VALUE as a union _PV as defined in MAPI. <br>// ----------------------------------------------------------------------------- <br> <br>UPropVal CProperty::upvGetPrValue() <br>{ <br>    UPropVal upv; <br>    upv.ul = 0;     // On error return this property value. <br> <br>    ASSERTERROR( m_pCurProp != NULL, "m_pCurProp is NULL!"); <br>    if( m_pCurProp == NULL) <br>        return( upv); <br>     <br>    return( m_pCurProp-&gt;Value); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Get the current property VALUE as a formated CString.  Pass TRUE to treat  <br>// ints or longs as unsigned, FALSE otherwise.  If no params passed in we <br>// default to a value that may be set through bSetUnsigned(). <br>// <br>// NOTE: A number of the possible property types don't have a conversion at <br>//       this time. <br>// ----------------------------------------------------------------------------- <br> <br>CString CProperty::szGetPrValue( BOOL bUnsigned) <br>{ <br>    int         ii; <br>    unsigned    ui; <br>    double      dbl; <br>    char        chBuf[4]; <br>    LPBYTE      pByte; <br>    CString     sRetVal; <br>    FILETIME    LocalFT = {0}; <br>    SYSTEMTIME  st = {0}; <br>    UPropVal    upv = upvGetPrValue(); <br> <br>    if( bUnsigned == -1) <br>        bUnsigned = m_bUnsigned; <br> <br>    switch( ulGetPrType()) <br>    { <br>        case PT_I2: <br>            if( bUnsigned) <br>            { <br>                ui = (unsigned) upv.i; // Convert to short unsigned to regular unsigned. <br>                sRetVal.Format( "%u", ui); <br>            } <br>            else <br>            { <br>                ii = upv.i;             // Convert to short int to regular int. <br>                sRetVal.Format( "%d", ii); <br>            } <br>            break; <br>         <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_LONG: <br>            if( bUnsigned) <br>                sRetVal.Format( "%lu", upv.ul); <br>            else <br>                sRetVal.Format( "%ld", upv.l); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_R4: <br>            dbl = upv.flt; <br>            sRetVal.Format( m_sDblFmt, dbl); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_DOUBLE: <br>            sRetVal.Format( m_sDblFmt, upv.dbl); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_BOOLEAN: <br>            if( upv.b) <br>                sRetVal = "TRUE"; <br>            else <br>                sRetVal = "FALSE"; <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_SYSTIME: <br>            if( FileTimeToLocalFileTime( &amp;upv.ft, &amp;LocalFT)) <br>            { <br>                if( FileTimeToSystemTime( &amp;LocalFT, &amp;st)) <br>                { <br>                    sRetVal.Format( "%.2d:%.2d:%.2d %.2d/%.2d/%.2d", <br>                        st.wHour, st.wMinute, st.wSecond, <br>                        st.wMonth, st.wDay, st.wYear); <br>                    break; <br>                } <br>            } <br> <br>            sRetVal.Format( "Error %lu converting file time to local or system time.", GetLastError()); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_STRING8: <br>            sRetVal.Format( "%s", upv.lpszA); <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_BINARY: <br>            sRetVal.Format( "CB:%d 0x", upv.bin.cb);  // Format the count. <br>             <br>            // Make sure we don't format more than 100 bytes. <br>            if( upv.bin.cb &gt; 100) <br>                ii = 100; <br>            else <br>                ii = upv.bin.cb; <br>             <br>            // Loop to format into hex digits. <br>            pByte = upv.bin.lpb; <br>            while( ii) <br>            {   // Format a single byte into a hex value and add to sRetVal. <br>                ui = *pByte; <br>                sprintf( chBuf, "%.2x", ui); <br>                sRetVal += chBuf; <br>                 <br>                // Next byte. <br>                pByte ++; <br>                ii --; <br>            } <br>            break; <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        case PT_ERROR: <br>        { <br>            CHRESULT hr = upv.err; <br>            sRetVal.Format( "Error %s [%.8lx]", hr.Msg(), hr); <br>            break; <br>        } <br> <br>        // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>        default:  <br>            sRetVal = szGetPrType(); <br>            sRetVal += " has no conversion at this time."; <br>            break; <br>    } <br>    return( sRetVal); <br>} <br> <br>// $--CProperty::Init()--------------------------------------------------------- <br>// Initializes property counters and pointers. <br>// ----------------------------------------------------------------------------- <br> <br>void CProperty::Init( ULONG cValues, LPSPropValue pProps) <br>{ <br>    m_cValues = cValues; <br>    m_pFirstProp = pProps; <br>    m_pLastProp = m_pFirstProp + (m_cValues - 1); <br>    m_pCurProp = NULL; <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// CONSTRUCTOR <br>// ----------------------------------------------------------------------------- <br> <br>CPropertyRows::CPropertyRows() <br>{ <br>    m_pRowSet = NULL;                   // No property row set. <br>    m_ulCurRowIndex = PR_ROW_SET_END;   // No current row. <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Frees the rows of properties then initializes the base class values since we <br>// don't want it trying to free a single row of properties that no longer exists. <br>// ----------------------------------------------------------------------------- <br> <br>void CPropertyRows::Free() <br>{ <br>    if( !m_pRowSet) <br>        return; <br> <br>    FreeProws( m_pRowSet); <br>    m_pRowSet = NULL; <br>    m_ulCurRowIndex = PR_ROW_SET_END;   // No current row. <br> <br>    Init( 0, NULL); <br>} <br> <br>// ----------------------------------------------------------------------------- <br>// Gets a row of properties from a MAPI table. <br>// ----------------------------------------------------------------------------- <br> <br>HRESULT CPropertyRows::HrGetTblRows( // RETURNS: return code <br>    LPMAPITABLE lpTable,        // Ptr to a mapi table. <br>    ULONG       cMaxNRows)      // Max.# of rows to return <br>{ <br>    DEBUGPUBLIC( "CPropertyRows::HrGetTblRows()\n"); <br>    CHRESULT hr = CHK_CPropertyRows_HrGetTblRows( lpTable, cMaxNRows); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Free last row set before trying to get another. <br>    Free();      <br> <br>    // Get the next list of messages in the folder <br>    hr = lpTable-&gt;QueryRows( cMaxNRows, 0L, &amp;m_pRowSet); <br>    if( FAILED( hr)) <br>        RETURN( hr); <br> <br>    // Make sure we received a valid pointer. <br>    if( !m_pRowSet) <br>        RETURN( E_FAIL); <br>     <br>    // Have we reached the end of the row list? <br>    if( m_pRowSet-&gt;cRows == 0) <br>        RETURN( EDK_E_END_OF_FILE);    // YES, since no rows found return EDK_E_END_OF_FILE. <br> <br>    FirstRow(); <br> <br>    return( NOERROR); <br>} <br> <br>// $--CPropertyRows::SetCurRow()------------------------------------------------ <br>// Set currency to either the first or the next row of properties. <br>// ----------------------------------------------------------------------------- <br> <br>void CPropertyRows::SetCurRow( BOOL bFirst) // TRUE sets to first row, FALSE sets to next row. <br>{ <br>    if( !m_pRowSet) <br>        return; // There is no row set. <br> <br>    // Were we requested to set to the first row, or were we at the end of the row list? <br>    if( bFirst || m_ulCurRowIndex == PR_ROW_SET_END) <br>        m_ulCurRowIndex = 0;    // YES, so set to first row. <br>    else <br>        m_ulCurRowIndex ++;     // NO, so set to the next row. <br>        <br>    if( bAtEndOfRows()) <br>    {    <br>        m_ulCurRowIndex = PR_ROW_SET_END; <br>        return; <br>    } <br> <br>    // Initialize base class so that it's first and current property  <br>    // point to the first one in this row. <br>    Init( m_pRowSet-&gt;aRow[ m_ulCurRowIndex].cValues, m_pRowSet-&gt;aRow[ m_ulCurRowIndex].lpProps);  <br>    First();    // First property of this row. <br>} <br> <br>// ----------------------------------------------------------------------------- </code></pre>
<p>&nbsp;</p></body>
</HTML>
