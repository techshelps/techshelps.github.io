<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RULEEDIT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1967"></a>RULEEDIT.CPP</h2>
<pre><code>//--ruleedit.cpp--------------------------------------------------------------- <br>// <br>// Folder rules editing utility. <br>//   <br>// Copyright (C) Microsoft Corp., 1986-1996.  All rights reserved. <br>// <br>//----------------------------------------------------------------------------- <br> <br> <br>// <br>// Begin program documentation <br>// <br> <br>#if0 <br> <br>Command line arguments: See Usage(), or invoke ruleedit.exe with no command <br>line arguments to get a usage note. <br> <br>#endif <br> <br>// <br>// End program documentation <br>// <br> <br>#include "edk.h" <br>#include "errno.h" <br>#include "ruleedit.h" <br> <br>// <br>// Manifest constants <br>// <br> <br>const UINT  cbMaxIniLine =1024; <br>const UINT  cMaxActions =16; <br> <br>// <br>// Enumeration, structure, and other type definitions <br>// <br> <br>enum EDITCMD// ec <br>{ <br>EDITCMD_DELETE, <br>EDITCMD_DISABLE, <br>EDITCMD_ENABLE, <br>EDITCMD_HELP, <br>EDITCMD_INSERT, <br>EDITCMD_LIST, <br>EDITCMD_INVALID <br>}; <br> <br>struct INIFILEPARSEINFO// ifpi <br>{ <br>    CHAR *          pszKeyword; <br>    VOID            (*ParseFunction)(INCHAR *pch); <br>}; <br> <br>enum INIFILESECTIONTYPE// ifst <br>{ <br>    IFST_INITIALIZATION, <br>IFST_COMMAND, <br>    IFST_UNKNOWN <br>}; <br> <br>enum LINEREADSTATUS// lrs <br>{ <br>    LRS_OKAY,           // Line was read and is available. <br>    LRS_EOF,            // We are at end of file; no more lines. <br>    LRS_IOERROR,        // There was an I/O error in the last read. <br>    LRS_LINETOOLONG     // Last line too long to return. <br>}; <br> <br>enum STORETYPE// st <br>{ <br>ST_UNKNOWN,// Store type not determined. <br>ST_EXCHANGEMAILBOX,// Microsoft Exchange Mailbox Store. <br>ST_EXCHANGEPUBLIC,// Microsoft Exchange Public Store. <br>ST_NONEXCHANGE// Store not provided by Exchange. <br>}; <br> <br>// <br>// Forward function declarations. <br>// <br> <br>static <br>BOOL <br>bParseCmdLine( <br>    IN  INT     argc, <br>    IN  CHAR *  argv[] <br>    ); <br> <br>static <br>VOID <br>DoDelete(VOID); <br> <br>static <br>VOID <br>DoDisable(VOID); <br> <br>static <br>VOID <br>DoEnable(VOID); <br> <br>static <br>VOID <br>DoHelp(VOID); <br> <br>static <br>VOID <br>DoInsert(VOID); <br> <br>static <br>VOID <br>DoList( <br>INLPSTRlpszProvider <br>); <br> <br>static <br>VOID <br>EventLogHexErrorMsg( <br>INDWORDdwEvent, <br>INHRESULThr <br>); <br> <br>static <br>HRESULT <br>HrGetDefaultStoreName( <br>INLPMAPISESSIONlpSession, <br>OUTLPSTR FAR *lppDisplayName <br>    ); <br> <br>static <br>HRESULT <br>HrGetStoreType( <br>INLPMAPISESSIONlpSession, <br>INLPMDBlpMDB, <br>INLPSTRlpDisplayName, <br>OUTSTORETYPE *lpStoreType <br>    ); <br> <br>static <br>HRESULT <br>HrProcessCommandSection(VOID); <br> <br>static <br>HRESULT <br>HrProcessInitializationSection(VOID); <br> <br>static <br>BOOL <br>IsSectionLine( <br>    INCHAR *  pch <br>    ); <br> <br>static <br>LINEREADSTATUS <br>lrsGetNextLine(VOID); <br> <br>static <br>VOID  <br>ParseLine(VOID); <br> <br>static <br>VOID <br>ParseSectionLine( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParseEntryLine( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParseActionValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParseCommandValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParseConditionValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParseFlagsValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParsePositionValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParseFolderValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParseProfileValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>ParseProviderValue( <br>    IN      CHAR *  pch <br>    ); <br> <br>static <br>VOID <br>PrintActions( <br>INLPACTIONSlpActs <br>); <br> <br>static <br>VOID <br>PrintErr( <br>INCHAR *Format <br>... <br>); <br> <br>static <br>VOID <br>PrintIniFileErr( <br>INCHAR *Format <br>... <br>); <br> <br>static <br>VOID <br>PrintStateFlags( <br>INLONGlStateFlags <br>); <br> <br>static <br>VOID <br>Usage(VOID); <br> <br>// <br>// Static storage <br>// <br> <br>// All the keywords used by the program: <br> <br>staticCHARszActionKeyword[] ="action"; <br>staticCHARszCommandKeyword[] ="command"; <br>staticCHARszConditionKeyword[] ="condition"; <br>staticCHARszDeleteKeyword[] ="delete"; <br>staticCHARszDisableKeyword[] ="disable"; <br>staticCHARszDisabledKeyword[] ="disabled"; <br>staticCHARszEnableKeyword[] ="enable"; <br>staticCHARszEnabledKeyword[] ="enabled"; <br>staticCHARszErrorKeyword[] ="error"; <br>staticCHARszExitLevelKeyword[] ="exitlevel"; <br>staticCHARszFileKeyword[] ="file"; <br>staticCHARszFlagsKeyword[] ="flags"; <br>staticCHARszFolderKeyword[] ="folder"; <br>staticCHARszHelpKeyword[] ="help"; <br>staticCHARszInboxKeyword[] ="inbox"; <br>staticCHARszInitializationKeyword[] ="initialization"; <br>staticCHARszInsertKeyword[] ="insert"; <br>staticCHARszKeepOOFHistKeyword[] ="keepoofhist"; <br>staticCHARszListKeyword[] ="list"; <br>staticCHARszPositionKeyword[] ="position"; <br>staticCHARszProfileKeyword[] ="profile"; <br>staticCHARszProviderKeyword[] ="provider"; <br>staticCHARszQuestionKeyword[] ="?"; <br>staticCHARszUserOOFKeyword[] ="useroof"; <br> <br> <br>// Command line arg flags, and array used by _HrExpandCommandLineArgument(): <br> <br>staticCHAR *rgpszArgArray[] ={ <br>szFileKeyword, <br>szFolderKeyword, <br>szHelpKeyword, <br>szListKeyword, <br>szProfileKeyword, <br>szProviderKeyword, <br>szQuestionKeyword <br>}; <br> <br>// Storage used to input and parse ini file lines and store values: <br> <br>// Ini file ptr: <br> <br>static FILE *IniFile =NULL; <br> <br>// Current input line: <br> <br>static CHARachIniLine[cbMaxIniLine] ={0}; <br> <br>// Parser tables for entries: <br> <br>static <br>INIFILEPARSEINFO    aifpiInitializationEntry[] =   { <br>                                            szProfileKeyword, <br>ParseProfileValue, <br>                                            szFolderKeyword, <br>ParseFolderValue, <br>szProviderKeyword, <br>ParseProviderValue <br>                                            }; <br>static <br>INIFILEPARSEINFO    aifpiCommandEntry[] =   { <br>                                            szCommandKeyword, <br>ParseCommandValue, <br>                                            szPositionKeyword, <br>ParsePositionValue, <br>                                            szConditionKeyword, <br>ParseConditionValue, <br>                                            szActionKeyword, <br>ParseActionValue, <br>szFlagsKeyword, <br>ParseFlagsValue <br>                                            }; <br> <br>// Parser state variables: <br> <br>static INIFILESECTIONTYPEifstCurSection =IFST_UNKNOWN; <br> <br> <br>staticCHARszProfile[MAX_PATH + 1] ={0}; <br> <br>staticBOOLfSkipProfileArg =FALSE; <br> <br>staticLPMAPISESSIONlpSession =NULL; <br> <br> <br>staticCHARszStore[MAX_PATH + 1] ={0}; <br> <br>staticLPMDBlpStore =NULL; <br> <br>staticULONGcbEIDStore  =   0; <br> <br>staticLPENTRYIDlpEIDStore =NULL; <br> <br>staticSTORETYPEstStoreType =ST_UNKNOWN; <br> <br> <br>staticCHARszFolder[MAX_PATH + 1] ={0}; <br> <br>staticLPMAPIFOLDERlpFolder =NULL; <br> <br>staticULONGcbEIDFolder =0; <br> <br>staticLPENTRYIDlpEIDFolder =NULL; <br> <br>static <br>IExchangeFolderRules *lpFRules =NULL; <br> <br> <br>staticBOOLfInboxArgFnd =FALSE; <br> <br>staticBOOLfSkipFolderArg =FALSE; <br> <br> <br>staticCHARszProvider[MAX_PATH + 1] ={0}; <br> <br>staticBOOLfSkipProviderArg =FALSE; <br> <br>staticBOOLfProviderArgFnd =FALSE; <br> <br>staticULONGcProviders =0; <br> <br>staticLPSTR FAR *lppszProviders =NULL; <br> <br> <br>staticEDITCMDEditCmd =EDITCMD_INVALID; <br> <br> <br>staticLONGlCursor =0; <br> <br>staticBOOLfPositionArgFnd =FALSE; <br> <br> <br>staticLPACTIONSlpActions =NULL; <br> <br>staticLPSRestrictionlpRes =NULL; <br> <br>staticLONGlStateFlags =ST_ENABLED; <br> <br>staticBOOLfFlagsArgFnd =FALSE; <br> <br> <br>// Error handling variables: <br> <br>staticULONGcErrs =0; <br>staticULONGcPriorErrs =0;// Used in determining if a section should <br>// be executed. <br> <br>static DWORDiLine =1; <br>static DWORDiSection =1; <br> <br>// <br>// Functions <br>// <br> <br> <br>//$--main---------------------------------------------------------------------- <br>// <br>// DESCRIPTION:    ruleedit.exe main() routine. <br>// <br>// INPUT:Standard argc and argv. <br>// <br>// RETURNS:integer from edkcode.h <br>// <br>//----------------------------------------------------------------------------- <br> <br>INT <br>main(                   // RETURNS: INT <br>    IN  INT     argc,       // argument count <br>    IN  CHAR *  argv[]      // array of command line arguments <br>) <br>{ <br>BOOLbMAPIInitialized =FALSE; <br>BOOLbPrintCompletion =TRUE; <br>BOOLbEventLoggingEnabled =FALSE; <br>HRESULThr =NOERROR; <br>LINEREADSTATUSlrs =LRS_OKAY; <br> <br>    DEBUGPUBLIC("main()\n"); <br> <br>// Initialize event logging. <br> <br>hr = HrEventOpenLog("EDKRuleEdit", NULL, NULL, NULL, NULL, NULL); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Event logging could not be enabled; error code=%#x", hr); <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br>else <br>{ <br>bEventLoggingEnabled = TRUE; <br>} <br> <br>    // NOTE:  Must initialize MAPI before parsing command line, <br>    // as the parsing of the command line requires MAPI memory <br>    // allocation. <br> <br>if (argc &lt; 2) <br>{ <br>Usage(); <br>bPrintCompletion = FALSE; <br> <br>goto cleanup; <br>} <br> <br>hr = MAPIInitialize(0); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("MAPI initialization failed"); <br>EventLogHexErrorMsg(RULEEDIT_MAPIINITIALIZE_FAILED, hr); <br>hr = HR_LOG(E_FAIL); <br> <br>goto cleanup; <br>} <br> <br>bMAPIInitialized = TRUE; <br> <br>if (!bParseCmdLine(argc, argv)) <br>{ <br>Usage(); <br>hr = HR_LOG(E_INVALIDARG); <br> <br>goto cleanup; <br>} <br> <br>if (EditCmd == EDITCMD_HELP) <br>{ <br>DoHelp(); <br>bPrintCompletion = FALSE; <br> <br>goto cleanup; <br>} <br> <br>ifstCurSection = IFST_UNKNOWN; <br> <br>// /List can be specified on the cmd line instead of specifying an <br>// ini file to process.  If this is the case, we handle it here. <br> <br>if (EditCmd == EDITCMD_LIST) <br>{ <br>if (!fSkipProfileArg) <br>{ <br>PrintErr("/PROFILE must be specified on command line with /LIST"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>else if (!fSkipFolderArg) <br>{ <br>PrintErr("/FOLDER must be specified on command line with /LIST"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>hr = HrProcessInitializationSection(); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (fProviderArgFnd) <br>{ <br>DoList(szProvider); <br>} <br>else <br>{ <br>ULONGi = 0; <br> <br>hr = HrFolderRulesGetProviders(lpStore, <br>   cbEIDFolder, <br>   lpEIDFolder, <br>   &amp;cProviders, <br>   &amp;lppszProviders); <br>if (FAILED(hr)) <br>{ <br>PrintErr("Folder providers could not be determined"); <br>EventLogHexErrorMsg(RULEEDIT_FOLDERRULESGETPROVIDERS_FAILED,hr); <br> <br>goto cleanup; <br>} <br> <br>if (cProviders == 0) <br>printf("Rules table is empty.\n\n"); <br>else <br>for (i = 0; i &lt; cProviders; i++) <br>DoList(lppszProviders[i]); <br>} <br> <br>// Note that execution always ends here. <br> <br>goto cleanup; <br>} <br> <br>while (TRUE) <br>{ <br>lrs = lrsGetNextLine(); <br> <br>if (lrs == LRS_OKAY) <br>{ <br>if (IsSectionLine(achIniLine)) <br>{ <br>if (ifstCurSection == IFST_COMMAND) <br>hr = HrProcessCommandSection(); <br>else if (ifstCurSection == IFST_INITIALIZATION) <br>hr = HrProcessInitializationSection(); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>ParseLine(); <br>} <br>else if (lrs == LRS_LINETOOLONG) <br>{ <br>PrintErr("Line %u too long in Ini File", iLine); <br>} <br>else <br>{ <br>break; <br>} <br> <br>iLine++; <br>} <br> <br>if (lrs == LRS_EOF) <br>{ <br>if (ifstCurSection == IFST_COMMAND) <br>hr = HrProcessCommandSection(); <br>else if (ifstCurSection == IFST_INITIALIZATION) <br>hr = HrProcessInitializationSection(); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(lpActions); <br>MAPIFREEBUFFER(lpRes); <br>MAPIFREEBUFFER(lpEIDFolder); <br>MAPIFREEBUFFER(lpEIDStore); <br>MAPIFREEBUFFER(lppszProviders); <br> <br>ULRELEASE(lpFRules); <br>ULRELEASE(lpFolder); <br>ULRELEASE(lpStore); <br> <br>if (lpSession) <br>{ <br>lpSession-&gt;Logoff(0, 0, 0); <br>ULRELEASE(lpSession); <br>} <br> <br>if (bMAPIInitialized) <br>(VOID)MAPIUninitialize(); <br> <br>if (bPrintCompletion) <br>{ <br>EDKEVENTCOUNTEvents = {0,0,0}; <br> <br>HrEventGetCounts(&amp;Events); <br> <br>if (cErrs == 0) <br>{ <br>printf("Execution completed with no errors.\n"); <br>} <br>else <br>{ <br>if (cErrs == 1) <br>{ <br>printf("1 error encountered during execution.\n"); <br>} <br>else <br>{ <br>printf("%u errors encountered during execution.\n", cErrs); <br>} <br> <br>if (Events.cError == 1) <br>{ <br>printf("1 error written to NT Event Log.\n"); <br>} <br>else if (Events.cError &gt; 1) <br>{ <br>printf("%u errors written to NT Event Log.\n", Events.cError); <br>} <br>} <br>} <br> <br>if (bEventLoggingEnabled) <br>HrEventCloseLog(); <br> <br>if (SUCCEEDED(hr) &amp;&amp; cErrs &gt; 0) <br>hr = HR_LOG(E_FAIL); <br> <br>    return _nEcFromHr(hr); <br>} <br> <br> <br>//$--bParseCmdLine------------------------------------------------------------- <br>// <br>// DESCRIPTION:    Parse the command line. <br>// <br>// INPUT: <br>// <br>//[argc]-- Count of arguments from command line. <br>//[argv]-- Array of arguments from command line. <br>// <br>// RETURNS:TRUE on success; FALSE otherwise. <br>// <br>//----------------------------------------------------------------------------- <br> <br>BOOL <br>bParseCmdLine(// RETURNS: BOOL <br>    IN  INT     argc,           // argument count <br>    IN  CHAR *  argv[]          // array of arguments <br>    ) <br>{ <br>    BOOL        brc =   FALSE; <br>HRESULThr =NOERROR; <br>CHAR *pszArgData =NULL; <br>CHAR *pszFlagName =NULL; <br> <br>    DEBUGPRIVATE("bParseCmdLine()\n"); <br> <br>argc--;// Get rid of command argument. <br>argv++; <br> <br>if (argc == 0) <br>    goto cleanup; <br> <br>while (argc &gt; 0) <br>{ <br>hr =_HrExpandCommandLineArgument( <br>*argv, <br>rgpszArgArray, <br>sizeof(rgpszArgArray)/sizeof(rgpszArgArray[0]), <br>NULL, <br>&amp;pszFlagName, <br>&amp;pszArgData <br>); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Invalid command line argument"); <br>goto cleanup; <br>} <br> <br>if (pszFlagName == szFileKeyword) <br>{ <br>if (IniFile != NULL) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData == NULL || pszArgData[0] == '\0') <br>{ <br>pszArgData = "ruleedit.ini"; <br>} <br> <br>if ((IniFile = fopen(pszArgData, "r")) == NULL) <br>{ <br>CHARszTmpFileName[MAX_PATH + 1]; <br> <br>if (strchr(pszArgData, '.') != NULL|| <br>strlen(pszArgData) + 4 &gt;= sizeof(szTmpFileName)) <br>{ <br>PrintErr("Ini file %s could not be opened", pszArgData); <br>goto cleanup; <br>} <br> <br>// Try appending ".ini". <br> <br>strcpy(szTmpFileName, pszArgData); <br>strcat(szTmpFileName, ".ini"); <br> <br>if ((IniFile = fopen(szTmpFileName, "r")) == NULL) <br>{ <br>PrintErr("Ini file %s could not be opened", szTmpFileName); <br>goto cleanup; <br>} <br>} <br>} <br>else if (pszFlagName == szFolderKeyword) <br>{ <br>if (szFolder[0] != '\0' || fInboxArgFnd) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData == NULL || pszArgData[0] == '\0') <br>{ <br>PrintErr("Command line %s argument requires a value", <br> szFolderKeyword); <br>goto cleanup; <br>} <br> <br>if (!stricmp(pszArgData, szInboxKeyword)) <br>{ <br>// It is the special name "inbox", which is interpreted as <br>// appropriate. <br> <br>fInboxArgFnd = TRUE; <br>} <br>else <br>{ <br>// Split the store and folder names and check their lengths. <br> <br>CHAR *pch = strchr(pszArgData, '\\'); <br> <br>if (pch == NULL) <br>{ <br>PrintErr("Command line %s argument invalid", <br> szFolderKeyword); <br>goto cleanup; <br>} <br> <br>*pch = '\0'; <br>pch++; <br> <br>if (*pszArgData == '\0') <br>{ <br>PrintErr("Command line %s argument invalid", <br> szFolderKeyword); <br>goto cleanup; <br>} <br> <br>if (strlen(pszArgData) &gt;= sizeof(szStore)) <br>{ <br>PrintErr("Command line %s argument too long", <br> szFolderKeyword); <br>goto cleanup; <br>} <br> <br>strcpy(szStore, pszArgData); <br> <br>if (*pch == '\0') <br>{ <br>PrintErr("Command line %s argument invalid", <br> szFolderKeyword); <br>goto cleanup; <br>} <br> <br>if (strlen(pch) &gt;= sizeof(szFolder)) <br>{ <br>PrintErr("Command line %s argument too long", <br> szFolderKeyword); <br>goto cleanup; <br>} <br> <br>strcpy(szFolder, pch); <br>} <br> <br>fSkipFolderArg = TRUE; <br>} <br>else if (pszFlagName == szHelpKeyword|| <br> pszFlagName == szQuestionKeyword) <br>{ <br>EditCmd = EDITCMD_HELP; <br> <br>// If we encounter /help or /?, we pretty much ignore everything <br>// else and produce a help msg. <br> <br>brc = TRUE; <br>goto cleanup; <br>} <br>else if (pszFlagName == szListKeyword) <br>{ <br>if (EditCmd == EDITCMD_LIST) <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>EditCmd = EDITCMD_LIST; <br>} <br>else if (pszFlagName == szProfileKeyword) <br>{ <br>if (szProfile[0] != '\0') <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData == NULL || pszArgData[0] == '\0') <br>{ <br>PrintErr("Command line %s argument requires a value", <br> szProfileKeyword); <br>goto cleanup; <br>} <br> <br>if (strlen(pszArgData) &gt;= sizeof(szProfile)) <br>{ <br>PrintErr("Command line %s argument too long", <br> szProfileKeyword); <br>goto cleanup; <br>} <br> <br>strcpy(szProfile, pszArgData); <br> <br>fSkipProfileArg = TRUE;// Ignore ini file value. <br>} <br>else if (pszFlagName == szProviderKeyword) <br>{ <br>if (szProvider[0] != '\0') <br>{ <br>PrintErr("Duplicate command line arguments"); <br>goto cleanup; <br>} <br> <br>if (pszArgData == NULL || pszArgData[0] == '\0') <br>{ <br>PrintErr("Command line %s argument requires a value", <br> szProviderKeyword); <br>goto cleanup; <br>} <br> <br>if (strlen(pszArgData) &gt;= sizeof(szProvider)) <br>{ <br>PrintErr("Command line %s argument too long", <br> szProviderKeyword); <br>goto cleanup; <br>} <br> <br>strcpy(szProvider, pszArgData); <br> <br>fSkipProviderArg =TRUE;// Ignore ini file value. <br>fProviderArgFnd =TRUE; <br>} <br>else <br>{ <br>PrintErr("Command line argument '%s' is invalid", *argv); <br>goto cleanup; <br>} <br> <br>argc--; <br>argv++; <br>} <br> <br>// Check for required arguments. <br> <br>if (IniFile == NULL) <br>{ <br>if (EditCmd != EDITCMD_LIST) <br>{ <br>if ((IniFile = fopen("ruleedit.ini", "r")) == NULL) <br>{ <br>PrintErr("Ini file ruleedit.ini could not be opened"); <br>goto cleanup; <br>} <br>} <br>} <br>else <br>{ <br>if (EditCmd == EDITCMD_LIST) <br>{ <br>PrintErr("/list and /file parameters may not both be specified"); <br>goto cleanup; <br>} <br>} <br> <br>brc = TRUE; <br> <br>cleanup: <br> <br>    return brc; <br>} <br> <br> <br>//$--DoDelete------------------------------------------------------------------ <br>// <br>// DESCRIPTION:Execute the DELETE command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>DoDelete(VOID)// RETURNS: VOID <br>{ <br>HRESULThr =NOERROR; <br>LONGlCurCursor =0; <br> <br>    DEBUGPRIVATE("DoDelete()\n"); <br> <br>    hr = lpFRules-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Delete command at line %u failed.\n\n", iSection); <br>EventLogHexErrorMsg(RULEEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// We do prior check of cursor location to be able to cleanly specify <br>// the error. <br> <br>    hr = lpFRules-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Delete command at line %u failed.\n\n", iSection); <br>EventLogHexErrorMsg(RULEEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>if (lCurCursor == RULE_PAST_END) <br>{ <br>PrintErr("Delete command at line %u failed; " <br> "rule at position %d does not exist", iSection, lCursor); <br>goto cleanup; <br>} <br> <br>    hr = lpFRules-&gt;HrDelete(); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Delete command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_DELETE_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>printf("Delete command at line %u succeeded.\n\n", iSection); <br> <br>cleanup: <br> <br>return; <br>} <br> <br> <br>//$--DoDisable----------------------------------------------------------------- <br>// <br>// DESCRIPTION:Execute the DISABLE command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>DoDisable(VOID)// RETURNS:VOID <br>{ <br>HRESULThr; <br>LONGlCurCursor; <br> <br>    DEBUGPRIVATE("DoDisable()\n"); <br> <br>    hr = lpFRules-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Disable command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// We do prior check of cursor location to be able to cleanly specify <br>// the error. <br> <br>    hr = lpFRules-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Disable command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>if (lCurCursor == RULE_PAST_END) <br>{ <br>PrintErr("Disable command at line %u failed; " <br> "rule at position %d does not exist", iSection, lCursor); <br>goto cleanup; <br>} <br> <br>    hr = lpFRules-&gt;HrDisable(); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Disable command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_DISABLE_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>printf("Disable command at line %u succeeded.\n\n", iSection); <br> <br>cleanup: <br> <br>return; <br>} <br> <br> <br>//$--DoEnable------------------------------------------------------------------ <br>// <br>// DESCRIPTION:Execute the ENABLE command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>DoEnable(VOID)// RETURNS: VOID <br>{ <br>HRESULThr =NOERROR; <br>LONGlCurCursor =0; <br> <br>    DEBUGPRIVATE("DoEnable()\n"); <br> <br>    hr = lpFRules-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Enable command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// We do prior check of cursor location to be able to cleanly specify <br>// the error. <br> <br>    hr = lpFRules-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Enable command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>if (lCurCursor == RULE_PAST_END) <br>{ <br>PrintErr("Enable command at line %u failed; " <br> "rule at position %d does not exist", iSection, lCursor); <br>goto cleanup; <br>} <br> <br>    hr = lpFRules-&gt;HrEnable(); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Enable command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_ENABLE_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>printf("Enable command at line %u succeeded.\n\n", iSection); <br> <br>cleanup: <br> <br>return; <br>} <br> <br> <br>//$--DoHelp-------------------------------------------------------------------- <br>// <br>// DESCRIPTION:Execute the HELP command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>DoHelp(VOID)  // RETURNS: VOID <br>{ <br>printf( <br>"\n" <br>"USAGE: RULEEDIT [/Profile=&lt;ProfileName&gt;]" <br>"\n" <br>"                [&lt;Folder&gt;]" <br>"\n" <br>"                [/List | /File=&lt;IniFile&gt;]" <br>"\n" <br>"                [/Provider=&lt;ProviderName&gt;]" <br>"\n" <br>"\n" <br>"&lt;Folder&gt; ::= /Folder=&lt;StoreName&gt;\\&lt;FolderPath&gt; | /Folder=Inbox" <br>"\n" <br>"\n" <br>); <br>} <br> <br> <br>//$--DoInsert------------------------------------------------------------------ <br>// <br>// DESCRIPTION:Execute the INSERT command. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>DoInsert(VOID)// RETURNS: VOID <br>{ <br>HRESULThr =NOERROR; <br>ULONGi =0; <br> <br>    DEBUGPRIVATE("DoInsert()\n"); <br> <br>    hr = lpFRules-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("Insert command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>hr = lpFRules-&gt;HrInsert(lStateFlags, lpRes, lpActions, 0, ""); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Insert command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_INSERT_FAILED, hr); <br>goto cleanup; <br>} <br> <br>printf("Insert command at line %u succeeded.\n\n", iSection); <br> <br>cleanup: <br> <br>return; <br>} <br> <br> <br>//$--DoList-------------------------------------------------------------------- <br>// <br>// DESCRIPTION:Execute the LIST command. <br>// <br>// INPUT: <br>// <br>//[lpszProvider]-- Provider to list rules for. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>DoList(// RETURNS: VOID <br>INLPSTRlpszProvider// Provider name <br>) <br>{ <br>HRESULThr =NOERROR; <br>LONGlCurCursor =0; <br>LPACTIONSlpActs =NULL; <br>LPSRestrictionlpRes =NULL; <br>LPSTRlpszRes =NULL; <br>   LPSTRlpszRuleName =NULL; <br>LPFOLDERRULESlpFRulesLst =NULL; <br> <br>    DEBUGPRIVATE("DoList()\n"); <br> <br>if (!fPositionArgFnd) <br>lCursor = 0; <br> <br>// If the provider being listed is not the provider that the global <br>// rules folder ptr has been opened for, we have to get a local rules <br>// folder ptr for that provider. <br> <br>if (stricmp(lpszProvider, szProvider)) <br>{ <br>hr = HrFolderRulesOpen(lpStore, <br>   cbEIDFolder, <br>   lpEIDFolder, <br>   lpszProvider, <br>   &amp;lpFRulesLst); <br> <br>// An error is highly unexpected here, since this code should never <br>// execute without the global folder rules ptr having been opened. <br> <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_UNEXPECTED); <br>PrintErr("Unexpected internal error in ruleedit"); <br>EventLogHexErrorMsg(RULEEDIT_INTERNAL_ERROR, hr); <br>goto cleanup; <br>} <br>} <br>else <br>{ <br>lpFRulesLst = lpFRules;// AddRef() not necessary due to scope. <br>} <br> <br>    hr = lpFRulesLst-&gt;HrSeek(lCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("List command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_SEEK_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>// Check for empty table or invalid cursor position. <br> <br>    hr = lpFRulesLst-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("List command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>printf("Listing of rules for provider '%s'\n" <br>   "in folder '%s' in store '%s':\n\n", <br>   lpszProvider, szFolder, szStore); <br> <br>if (lCurCursor == RULE_PAST_END) <br>{ <br>if (fPositionArgFnd) <br>PrintErr("List command at line %u failed; " <br> "Rule at specified position (%d) does not exist", <br> iSection, lCursor); <br>else <br>printf("There are no rules for provider '%s'\n\n", lpszProvider); <br> <br>goto cleanup; <br>} <br> <br>while (TRUE) <br>{ <br>LONGlStateFlags; <br>LONGlLevel; <br> <br>hr = lpFRulesLst-&gt;HrGet(&amp;lStateFlags, <br> &amp;lpRes, <br> &amp;lpActs, <br> &amp;lLevel, <br> &amp;lpszRuleName); <br>if (FAILED(hr)) <br>{ <br>HRESULThrSaved = hr; <br> <br>    hr = lpFRulesLst-&gt;HrTell(&amp;lCurCursor); <br> <br>    if (FAILED(hr)) <br>    { <br>PrintErr("List command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_TELL_FAILED, hr); <br>        goto cleanup; <br>    } <br> <br>if (lCurCursor != RULE_PAST_END || hrSaved != E_FAIL) <br>{ <br>PrintErr("List command at line %u failed", iSection); <br>EventLogHexErrorMsg(RULEEDIT_GET_FAILED, hrSaved); <br>        goto cleanup; <br>} <br>break; <br>} <br>else <br>{ <br>// Print listing: <br> <br>printf("Row number = %d\n", lCurCursor); <br> <br>if (lpRes != NULL) <br>{ <br>hr = HrRestrictionToString(lpRes, &amp;lpszRes); <br> <br>if (FAILED(hr)) <br>{ <br>printf("String representation of rule condition " <br>   "could not be determined.\n"); <br>cErrs++; <br>EventLogHexErrorMsg(RULEEDIT_RESTRICTIONTOSTRING_FAILED, hr); <br>} <br>else <br>{ <br>printf("Rule Condition = %s\n", lpszRes); <br>} <br>} <br>else <br>{ <br>printf("Rule Condition is not defined (NULL)\n"); <br>} <br> <br>PrintActions(lpActs); <br> <br>PrintStateFlags(lStateFlags); <br> <br>printf("Rule Level = %u\n", lLevel); </code></pre>
<p>
</p>
<pre><code><br>printf("Rule Name = %s\n", lpszRuleName); <br> <br>printf("\n"); <br> <br>lCurCursor++; <br>} <br> <br>// Only print one record if cursor position was specified. <br> <br>if (fPositionArgFnd) <br>break; <br> <br>// Loop repeats; clean up allocations so ptrs can be reused. <br>// Note that MAPIFREEBUFFER() is a macro that nulls the ptr. <br> <br>MAPIFREEBUFFER(lpRes); <br>MAPIFREEBUFFER(lpszRes); <br>MAPIFREEBUFFER(lpActs); <br>MAPIFREEBUFFER(lpszRuleName); <br>} <br> <br>cleanup: <br> <br>printf("\n"); <br> <br>// Clean up allocations: <br> <br>MAPIFREEBUFFER(lpRes); <br>MAPIFREEBUFFER(lpszRes); <br>MAPIFREEBUFFER(lpActs); <br>MAPIFREEBUFFER(lpszRuleName); <br> <br>if (lpFRulesLst != lpFRules) <br>ULRELEASE(lpFRulesLst); <br> <br>return; <br>} <br> <br> <br>//$--EventLogHexErrorMsg------------------------------------------------------- <br>// <br>// DESCRIPTION: Write a message to the event log that contains a hex error code. <br>//This function is used for simple error messages that have the <br>//HRESULT (or other 4 byte error code) as the only insert. <br>// <br>// INPUT: <br>// <br>//[dwEvent]-- Event code for message string. <br>//[hr]-- HRESULT that will be printed in hex as the insert in the <br>//   message string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>EventLogHexErrorMsg( <br>INDWORDdwEvent,// event code for message string <br>INHRESULThr// HRESULT insert in the message string <br>) <br>{ <br>CHARszErrorCode[11]; <br> <br>sprintf(szErrorCode, "%#.8x", hr); <br> <br>EventLogMsg(dwEvent, 1, szErrorCode, 0); <br>} <br> <br> <br>//$--HrGetDefaultStoreName----------------------------------------------------- <br>// <br>// DESCRIPTION: Get the display name for the default store. <br>// <br>// INPUT: <br>// <br>//[lpSession]-- Ptr to MAPI session. <br>// <br>// OUTPUT: <br>// <br>//[lppDisplayName]-- Ptr to ptr that will be set to point at store <br>//   display name on successful return. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_*if call failed. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetDefaultStoreName(// RETURNS:HRESULT <br>INLPMAPISESSIONlpSession,// MAPI session ptr <br>OUTLPSTR FAR *lppDisplayName// Display name buffer ptr <br>    ) <br>{ <br>static <br>SizedSPropTagArray(2, Columns) = {2,{PR_DEFAULT_STORE,PR_DISPLAY_NAME}}; <br> <br>ULONGcchDisplayName =0; <br>HRESULThr =NOERROR; <br>LPSTRlpDisplayName =NULL; <br>LPSRowSetlpRows =NULL; <br>LPMAPITABLElpTable =NULL; <br> <br>    DEBUGPRIVATE("HrGetDefaultStoreName()\n"); <br> <br>hr = lpSession-&gt;GetMsgStoresTable(0, &amp;lpTable); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = lpTable-&gt;SetColumns((LPSPropTagArray)&amp;Columns, 0); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>while (TRUE) <br>{ <br>LPSPropValuelpProp; <br> <br>hr = lpTable-&gt;QueryRows(1, 0, &amp;lpRows); <br> <br>if (FAILED(hr) || lpRows-&gt;cRows != 1) <br>break; <br> <br>lpProp = &amp;lpRows-&gt;aRow[0].lpProps[0]; <br> <br>if (lpProp-&gt;ulPropTag == PR_DEFAULT_STORE &amp;&amp; lpProp-&gt;Value.b) <br>break; <br> <br>FREEPROWS(lpRows); <br>} <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (lpRows == NULL|| <br>lpRows-&gt;cRows != 1|| <br>lpRows-&gt;aRow[0].lpProps[1].ulPropTag != PR_DISPLAY_NAME|| <br>lpRows-&gt;aRow[0].lpProps[1].Value.lpszA == NULL) <br>{ <br>hr = HR_LOG(MAPI_E_NOT_FOUND); <br>goto cleanup; <br>} <br> <br>// Allocate space for the display name to be returned and copy it out. <br> <br>lpDisplayName = lpRows-&gt;aRow[0].lpProps[1].Value.lpszA; <br> <br>cchDisplayName = strlen(lpDisplayName) + 1; <br> <br>hr = MAPIAllocateBuffer(cchDisplayName, (LPVOID FAR *)lppDisplayName); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>strcpy(*lppDisplayName, lpDisplayName); <br> <br>cleanup: <br> <br>if (lpRows) <br>FREEPROWS(lpRows); <br> <br>ULRELEASE(lpTable); <br> <br>RETURN(hr); <br>} <br> <br> <br>//$--HrGetStoreType------------------------------------------------------------ <br>// <br>// DESCRIPTION: Determine the store type of a given message store. <br>// <br>// INPUT: <br>// <br>//[lpSession]-- Ptr to MAPI session. <br>//[lpMDB]-- Ptr to MAPI store. <br>//[lpDisplayName]-- Ptr to display name of store to be evaluated. <br>// <br>// OUTPUT: <br>// <br>//[lpStoreType]-- Ptr to store type that will be set on successful return. <br>// <br>// RETURNS:     NOERRORif successful; <br>//E_*if call failed. <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrGetStoreType(// RETURNS:HRESULT <br>INLPMAPISESSIONlpSession,// MAPI session ptr <br>INLPMDBlpMDB,// store ptr <br>INLPSTRlpDisplayName,// store display name ptr <br>OUTSTORETYPE *lpStoreType// store type ptr <br>    ) <br>{ <br>// Note - There may be a problem with the following name changing. <br>//  Unfortunately, there is not a good other solution for <br>//  distinguishing between an exchange vs a non-exchange store <br>//  at present. <br> <br>static CHARszExchangeName[] = "Microsoft Exchange Server"; <br> <br>static <br>SizedSPropTagArray(2, Columns) = {2,{PR_DISPLAY_NAME,PR_PROVIDER_DISPLAY}}; <br> <br>HRESULThr =NOERROR; <br>LPSRowSetlpRows =NULL; <br>LPMAPITABLElpTable =NULL; <br> <br>    DEBUGPRIVATE("HrGetStoreType()\n"); <br> <br>hr = lpSession-&gt;GetMsgStoresTable(0, &amp;lpTable); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>hr = lpTable-&gt;SetColumns((LPSPropTagArray)&amp;Columns, 0); <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>while (TRUE) <br>{ <br>LPSPropValuelpProp; <br> <br>hr = lpTable-&gt;QueryRows(1, 0, &amp;lpRows); <br> <br>if (FAILED(hr) || lpRows-&gt;cRows != 1) <br>break; <br> <br>lpProp = &amp;lpRows-&gt;aRow[0].lpProps[0]; <br> <br>if (lpProp-&gt;ulPropTag == PR_DISPLAY_NAME) <br>{ <br>if (!stricmp(lpProp-&gt;Value.lpszA, lpDisplayName)) <br>break; <br>} <br> <br>FREEPROWS(lpRows); <br>} <br> <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>if (lpRows == NULL|| <br>lpRows-&gt;cRows != 1|| <br>lpRows-&gt;aRow[0].lpProps[1].ulPropTag != PR_PROVIDER_DISPLAY) <br>{ <br>hr = HR_LOG(MAPI_E_NOT_FOUND); <br>goto cleanup; <br>} <br> <br>if (!memcmp(lpRows-&gt;aRow[0].lpProps[1].Value.lpszA, <br>    szExchangeName, sizeof(szExchangeName) - 1)) <br>{ <br>if (FIsPublicStore(lpMDB)) <br>*lpStoreType = ST_EXCHANGEPUBLIC; <br>else <br>*lpStoreType = ST_EXCHANGEMAILBOX; <br>} <br>else <br>{ <br>*lpStoreType = ST_NONEXCHANGE; <br>} <br> <br>cleanup: <br> <br>if (lpRows) <br>FREEPROWS(lpRows); <br> <br>ULRELEASE(lpTable); <br> <br>RETURN(hr); <br>} <br> <br> <br>//$--HrProcessCommandSection--------------------------------------------------- <br>// <br>// DESCRIPTION: Process the information parsed in a command section, and <br>//execute the command. <br>// <br>// INPUT:       None. <br>// <br>// RETURNS:     HRESULT --  NOERROR if execution should continue; <br>//                          E_FAIL if there is an initialization error; <br>//E_UNEXPECTED if there is an internal error. <br>// <br>// Notes:This function logs or prints errors associated with <br>//failure of an individual command, but does not return an <br>//error code.  If a more major error occurs that should <br>//stop execution, then an error code is returned. <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrProcessCommandSection(VOID)        // RETURNS: HRESULT <br>{ <br>BOOLfSkipExec =FALSE; <br>HRESULThr =NOERROR; <br> <br>    DEBUGPRIVATE("HrProcessCommandSection()\n"); <br> <br>// Confirm that initialization has been done. <br> <br>if (lpFRules == NULL) <br>{ <br>        hr = HR_LOG(E_FAIL); <br>PrintErr("Initialization section missing, or not at start of file"); <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br> <br>// Confirm that the command section has the required section entries. <br>// If anything past this point fails, we report or log the error, but <br>// return NOERROR and keep on going. <br> <br>if (EditCmd == EDITCMD_INVALID) <br>{ <br>PrintErr("Command must include a command argument"); <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br>else if (EditCmd != EDITCMD_LIST) <br>{ <br>if (!fPositionArgFnd) <br>{ <br>if (EditCmd == EDITCMD_INSERT) <br>{ <br>lCursor = RULE_PAST_END; <br>} <br>else <br>{ <br>PrintErr("Command specified requires %s argument", <br> szPositionKeyword); <br> <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br>} <br> <br>if (EditCmd == EDITCMD_INSERT) <br>{ <br>if (lpRes == NULL) <br>{ <br>PrintErr("Insert command requires %s argument", <br> szConditionKeyword); <br> <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br>else if (lpActions == NULL) <br>{ <br>PrintErr("Insert command requires %s argument", <br> szActionKeyword); <br> <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br> <br>{ <br>LPACTIONlpAction =lpActions-&gt;lpAction; <br>LPACTIONlpActionInv =lpActions-&gt;lpAction + <br>lpActions-&gt;cActions; <br> <br>while (lpAction &lt; lpActionInv) <br>{ <br>if (lpAction-&gt;acttype == OP_MOVE|| <br>lpAction-&gt;acttype == OP_COPY) <br>{ <br>if (stStoreType == ST_EXCHANGEPUBLIC) <br>{ <br>PrintErr("Move and Copy actions are only supported" <br>  " by Exchange mailboxes"); <br> <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br> <br>if (lpAction-&gt;actMoveCopy.cbStoreEntryId != <br>cbEIDStore|| <br>memcmp(lpAction-&gt;actMoveCopy.lpStoreEntryId, <br>   lpEIDStore, <br>   cbEIDStore)) <br>{ <br>PrintErr("Move and Copy actions are only supported" <br>  " to destinations in the same store"); <br> <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br>} <br>else if (lpAction-&gt;acttype == OP_BOUNCE) <br>{ <br>if (stStoreType == ST_EXCHANGEMAILBOX) <br>{ <br>PrintErr("Bounce actions are only supported" <br>  " by Exchange public stores"); <br> <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br>} <br>else if (lpAction-&gt;acttype == OP_DELEGATE) <br>{ <br>if (stStoreType == ST_EXCHANGEPUBLIC) <br>{ <br>PrintErr("Delegate actions are only supported" <br>  " by Exchange mailboxes"); <br> <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br>} <br> <br>lpAction++; <br>} <br>} <br>} <br>} <br> <br>// Only process the section if there were no errors in parsing it. <br> <br>if (cErrs &gt; cPriorErrs) <br>{ <br>fSkipExec = TRUE; <br>goto cleanup; <br>} <br> <br>switch (EditCmd) <br>{ <br>case EDITCMD_LIST: <br>if (fProviderArgFnd) <br>{ <br>DoList(szProvider); <br>} <br>else <br>{ <br>ULONGi = 0; <br> <br>// We have to redetermine the providers every time we do a list <br>// because RuleEdit may have inserted rules in the table. <br> <br>MAPIFREEBUFFER(lppszProviders); <br> <br>hr = HrFolderRulesGetProviders(lpStore, <br>   cbEIDFolder, <br>   lpEIDFolder, <br>   &amp;cProviders, <br>   &amp;lppszProviders); <br>if (FAILED(hr)) <br>{ <br>PrintErr("Folder providers could not be determined"); <br>EventLogHexErrorMsg(RULEEDIT_FOLDERRULESGETPROVIDERS_FAILED,hr); <br> <br>// We treat this as a killer error. <br> <br>goto cleanup; <br>} <br> <br>if (cProviders == 0) <br>printf("Rules table is empty.\n\n"); <br>else <br>for (i = 0; i &lt; cProviders; i++) <br>DoList(lppszProviders[i]); <br>} <br>break; <br> <br>case EDITCMD_INSERT: <br>DoInsert(); <br>break; <br> <br>case EDITCMD_DELETE: <br>DoDelete(); <br>break; <br> <br>case EDITCMD_ENABLE: <br>DoEnable(); <br>break; <br> <br>case EDITCMD_DISABLE: <br>DoDisable(); <br>break; <br> <br>// Can only occur if the code gets screwed up in maintenance: <br> <br>default: <br>hr = HR_LOG(E_UNEXPECTED); <br>PrintErr("Unexpected internal error in ruleedit"); <br>EventLogHexErrorMsg(RULEEDIT_INTERNAL_ERROR, hr); <br>goto cleanup; <br>break; <br>} <br> <br>cleanup: <br> <br>if (fSkipExec) <br>{ <br>printf("Execution of command at line %u not attempted " <br>   "due to errors.\n\n", iSection); <br>} <br> <br>    RETURN(hr); <br>} <br> <br> <br>//$--HrProcessInitializationSection-------------------------------------------- <br>// <br>// DESCRIPTION: Process the information parsed in an initialization section, <br>//logging onto a MAPI profile session and opening the message <br>//store, its folder, and rules table.  If profile or folder info <br>//was provided on the command line, that is processed instead. <br>// <br>// INPUT:       None. <br>// <br>// RETURNS:     HRESULT --  NOERROR if successful, <br>//                          E_* otherwise. <br>// <br>// Notes:If this function fails, the error should be treated as a <br>//fatal error.  <br>// <br>//----------------------------------------------------------------------------- <br> <br>HRESULT <br>HrProcessInitializationSection(VOID)       // RETURNS: HRESULT <br>{ <br>HRESULThr =NOERROR; <br>LPSTRpszStore =NULL; <br>ULONGulObjType =0; <br> <br>    DEBUGPRIVATE("HrProcessInitializationSection()\n"); <br> <br>// Confirm that this is the first Initialization section we have <br>// encountered. <br> <br>if (lpFRules != NULL) <br>{ <br>if (!fSkipProfileArg || !fSkipFolderArg) <br>{ <br>PrintErr("Multiple Initialization sections in Ini File"); <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>// It is okay to find an initialization section after initialization <br>// if all args were specified on the command line. <br> <br>goto cleanup; <br>} <br> <br>// Only process the section if there were no errors in parsing it. <br> <br>if (cErrs &gt; cPriorErrs) <br>goto cleanup; <br> <br>if (szProfile[0] == '\0') <br>{ <br>PrintErr("Profile not specified on command line or in Ini File"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if (szFolder[0] == '\0' &amp;&amp; !fInboxArgFnd) <br>{ <br>PrintErr("Folder not specified on command line or in Ini File"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Use default provider value if one was not specified. <br> <br>if (!fProviderArgFnd) <br>strcpy(szProvider, "MSFT:RuleEdit"); <br> <br>hr = MAPILogonEx(0, <br>     szProfile, <br>     NULL, <br>     MAPI_EXTENDED | MAPI_NEW_SESSION, <br>     &amp;lpSession); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("MAPI Logon failed"); <br>EventLogHexErrorMsg(RULEEDIT_MAPILOGON_FAILED, hr); <br>        goto cleanup; <br>} <br> <br>// Get the entry id of the specified store and open it. <br> <br>if (fInboxArgFnd) <br>{ <br>hr = HrMAPIFindDefaultMsgStore(lpSession, &amp;cbEIDStore, &amp;lpEIDStore); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Default message store could not be determined"); <br>EventLogHexErrorMsg(RULEEDIT_FINDDEFAULTMSGSTORE_FAILED, hr); <br>goto cleanup; <br>} <br> <br>hr = HrGetDefaultStoreName(lpSession, &amp;pszStore); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Default message store name could not be determined"); <br>EventLogHexErrorMsg(RULEEDIT_GETDEFAULTSTORENAME_FAILED, hr); <br>goto cleanup; <br>} <br> <br>if (strlen(pszStore) &gt;= sizeof(szStore)) <br>{ <br>PrintErr("Default store name too long"); // Highly unexpected. <br>goto cleanup; <br>} <br> <br>strcpy(szStore, pszStore); <br>} <br>else <br>{ <br>hr = HrMAPIFindStore(lpSession, szStore, &amp;cbEIDStore, &amp;lpEIDStore); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Message store not found"); <br>EventLogHexErrorMsg(RULEEDIT_FINDSTORE_FAILED, hr); <br>goto cleanup; <br>} <br>} <br> <br>hr = lpSession-&gt;OpenMsgStore(0, <br> cbEIDStore, <br> lpEIDStore, <br> NULL, <br> MAPI_DEFERRED_ERRORS | MAPI_BEST_ACCESS, <br> &amp;lpStore); <br>if (FAILED(hr)) <br>{ <br>PrintErr("Message store could not be opened"); <br>EventLogHexErrorMsg(RULEEDIT_OPENMSGSTORE_FAILED, hr); <br>goto cleanup; <br>} <br> <br>// Confirm that this is an Exchange store.  We stop processing if it <br>// is not. <br> <br>hr = HrGetStoreType(lpSession, lpStore, szStore, &amp;stStoreType); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Message store provider type could not be determined"); <br>EventLogHexErrorMsg(RULEEDIT_GETSTORETYPE_FAILED, hr); <br>goto cleanup; <br>} <br> <br>if (stStoreType == ST_NONEXCHANGE) <br>{ <br>PrintErr("Rules are only supported by Exchange Server stores"); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Get the entry id of the specified folder and open it. <br> <br>if (fInboxArgFnd) <br>{ <br>LPSTRlpszExplicitClass = ""; <br> <br>hr = lpStore-&gt;GetReceiveFolder(NULL, <br>   0, <br>   &amp;cbEIDFolder, <br>   &amp;lpEIDFolder, <br>   &amp;lpszExplicitClass); <br>if (FAILED(hr)) <br>{ <br>PrintErr("Inbox not found"); <br>EventLogHexErrorMsg(RULEEDIT_GETRECEIVEFOLDER_FAILED, hr); <br>goto cleanup; <br>} <br> <br>// BUGBUG - We may want to look this up instead of hardwiring it. <br> <br>strcpy(szFolder, "Top of Information Store\\Inbox"); <br>} <br>else <br>{ <br>hr = HrMAPIFindFolderEx(lpStore, <br>'\\', <br>szFolder, <br>&amp;cbEIDFolder, <br>&amp;lpEIDFolder); <br>if (FAILED(hr)) <br>{ <br>PrintErr("Specified folder not found"); <br>EventLogHexErrorMsg(RULEEDIT_FINDFOLDER_FAILED, hr); <br>goto cleanup; <br>} <br>} <br> <br>// Get a folder pointer.  This is required for HrStringToAction(). <br> <br>hr = lpStore-&gt;OpenEntry(cbEIDFolder, <br>lpEIDFolder, <br>NULL, <br>MAPI_BEST_ACCESS | <br>MAPI_DEFERRED_ERRORS, <br>&amp;ulObjType, <br>(LPUNKNOWN FAR *)&amp;lpFolder); <br>if (FAILED(hr)) <br>{ <br>PrintErr("Specified folder could not be opened"); <br>EventLogHexErrorMsg(RULEEDIT_OPENENTRY_FAILED, hr); <br>goto cleanup; <br>} <br> <br>// Get a folder rules interface ptr for the specified folder.  This ptr <br>// will be used for all commands with the exception of the list command <br>// when no provider has been specified.  In that instance, the list <br>// command has to get a ptr for each provider. <br> <br>    hr = HrFolderRulesOpen(lpStore, <br>   cbEIDFolder, <br>   lpEIDFolder, <br>   szProvider, <br>   &amp;lpFRules); <br> <br>    if (FAILED(hr)) <br>    { <br>if (hr == E_NOINTERFACE) <br>{ <br>PrintErr("Specified folder does not support rules"); <br>EventLogMsg(RULEEDIT_NORULESTABLE, 0, 0); <br>} <br>else <br>{ <br>PrintErr("Specified folder could not be opened"); <br>EventLogHexErrorMsg(RULEEDIT_FOLDERRULESOPEN_FAILED, hr); <br>} <br>        goto cleanup; <br>    } <br> <br>cleanup: <br> <br>MAPIFREEBUFFER(pszStore); <br> <br>RETURN(hr); <br>} <br> <br> <br>//$--IsSectionLine------------------------------------------------------------- <br>// <br>// DESCRIPTION: Determine if an input line is a section header (ie., first <br>//non-whitespace char is '['). <br>// <br>// INPUT:       [pch]-- Ptr to input line. <br>// <br>// RETURNS:     TRUE if input line is a section line; FALSE otherwise. <br>//----------------------------------------------------------------------------- <br> <br>BOOL <br>IsSectionLine(// RETURNS: BOOL <br>    INCHAR *  pch// input line <br>    ) <br>{ <br>    DEBUGPRIVATE("IsSectionLine()\n"); <br> <br>while (isspace(*pch))// Skip leading line whitespace. <br>pch++; <br> <br>return (*pch == '['); <br>} <br> <br> <br>//$--lrsGetNextLine------------------------------------------------------------ <br>// <br>// DESCRIPTION: Get the next input line from the ini file and deposit it in <br>//the input buffer (achIniLine). <br>// <br>// INPUT:None. <br>// <br>// RETURNS:  <br>// <br>//  LRS_OKAY if line was read and is available. <br>//  LRS_EOF if we are at end of file; no more lines. <br>//  LRS_IOERROR if there was an I/O error in the last read. <br>//  LRS_LINETOOLONG if last line was too long to fit in the buffer. <br>//----------------------------------------------------------------------------- <br> <br>LINEREADSTATUS <br>lrsGetNextLine(VOID)// RETURNS: LINEREADSTATUS <br>{ <br>    INT             ch =0; <br>LINEREADSTATUSlrs =LRS_OKAY; <br>    CHAR *          pch =       &amp;achIniLine[0]; <br>    CHAR *          pchInv =    &amp;achIniLine[cbMaxIniLine]; <br> <br>    DEBUGPRIVATE("lrsGetNextLine()\n"); <br> <br>    while (TRUE) <br>    { <br>        if (pch == pchInv) <br>        { <br>            // Line is too long. <br> <br>            lrs =           LRS_LINETOOLONG; <br>            achIniLine[0] = '\0'; <br>            while ((ch = getc(IniFile)) != EOF &amp;&amp; (ch != '\n')); <br> <br>            break; <br>        } <br> <br>        ch = getc(IniFile); <br> <br>        if (ch == '\n') <br>        { <br>            // Just read end of this line. <br> <br>            lrs =   LRS_OKAY; <br>            *pch =  '\0'; <br> <br>            break; <br>        } <br> <br>        if (ch == EOF) <br>        { <br>            // We have read last line in file. <br>            // We want to process the last line, if any. <br> <br>            *pch = '\0'; <br> <br>            if (pch == &amp;achIniLine[0]) <br>            { <br>                // The last line was properly terminated with a newline <br>// and we are truly at EOF. <br> <br>                lrs = feof(IniFile) ? LRS_EOF : LRS_IOERROR; <br>            } <br>            else <br>            { <br>                // The last line was not properly terminated and has data. <br> <br>                lrs = feof(IniFile) ? LRS_OKAY : LRS_IOERROR; <br>            } <br> <br>            break; <br>        } <br> <br>        *pch = ch; <br>        pch++; <br>    } <br> <br>    return lrs; <br>} <br> <br> <br>//$--ParseLine----------------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse an ini file line, and store the value if it is a section <br>//entry line. <br>// <br>// INPUT:       None. <br>// <br>// RETURNS:     Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID  <br>ParseLine(VOID)// RETURNS: VOID <br>{ <br>    CHAR *      pch =&amp;achIniLine[0]; <br> <br>    DEBUGPRIVATE("ParseLine()\n"); <br> <br>    while (isspace(*pch))           // Skip leading line whitespace. <br>        pch++; <br> <br>    if (*pch == '\0')               // It is a blank line. <br>    { <br>; <br>    } <br>    else if (*pch == ';')           // It is a comment. <br>    { <br>; <br>    } <br>else <br>{ <br>if ( *pch == '[' )  // It is a section, or is invalid <br>{ <br>iSection = iLine; <br>cPriorErrs = cErrs; <br>ParseSectionLine(pch + 1); <br>} <br>else                            // It is a section entry, or is invalid. <br>{ <br>ParseEntryLine(pch); <br>} <br>} <br>} <br> <br> <br>//$--ParseSectionLine---------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse an ini file section header line.  <br>// <br>// INPUT:       [pch]-- Ptr to section keyword. <br>// <br>// RETURNS:     Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseSectionLine(// RETURNS:VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>    CHAR        chTmp   =   '\0'; <br>BOOLfBadSyntax =FALSE; <br>    CHAR *      pchKeyword  =   NULL; <br> <br>    DEBUGPRIVATE("ParseSectionLine()\n"); <br> <br>    // Save ptr to keyword. <br> <br>    pchKeyword = pch; <br> <br>    // Scan for end of keyword and delimit keyword, saving replaced char. <br> <br>    while (!isspace(*pch) &amp;&amp; *pch != ']' &amp;&amp; *pch != '\0') <br>        pch++; <br> <br>    if (*pch == '\0') <br>{ <br>fBadSyntax = TRUE; <br>goto cleanup; <br>} <br> <br>    chTmp = *pch; <br>    *pch  = '\0'; <br> <br>    // Compare putative keyword against valid section keywords. <br> <br>    if (!stricmp(pchKeyword, szCommandKeyword)) <br>    { <br>// Numeric value may follow "command" keyword.  We don't use it, <br>// but we do a rough check that what we are seeing is consistent <br>// with what we expect. <br> <br>        *pch = chTmp; <br> <br>        while (isspace(*pch)) <br>            pch++; <br> <br>        if (!isdigit(*pch)) <br>{ <br>fBadSyntax = TRUE; <br>goto cleanup; <br>} <br> <br>pch++; <br> <br>        while (isdigit(*pch)) <br>            pch++; <br> <br>        // Check for proper section entry termination. <br> <br>        if (*pch != ']' || *(pch + 1) != '\0') <br>{ <br>fBadSyntax = TRUE; <br>goto cleanup; <br>} <br> <br>ifstCurSection = IFST_COMMAND; <br> <br>// Initialize command section parser state. <br> <br>EditCmd =EDITCMD_INVALID; <br>fPositionArgFnd = FALSE; <br> <br>MAPIFREEBUFFER(lpActions); <br>MAPIFREEBUFFER(lpRes); <br> <br>lStateFlags = ST_ENABLED; <br>fFlagsArgFnd = FALSE; <br>    } <br>    else if (!stricmp(pchKeyword, szInitializationKeyword)) <br>    { <br>        // Check for proper section entry termination. <br>        // Initialization sections don't have a value. <br> <br>        *pch = chTmp; <br> <br>        if (*pch != ']' || *(pch + 1) != '\0') <br>{ <br>fBadSyntax = TRUE; <br>goto cleanup; <br>} <br> <br>        ifstCurSection = IFST_INITIALIZATION; <br>    } <br>    else <br>    { <br>PrintIniFileErr("Invalid keyword"); <br> <br>ifstCurSection = IFST_UNKNOWN;// Invalid section keyword. <br>        *pch = chTmp; <br>goto cleanup; <br>    } <br> <br>fBadSyntax = FALSE; <br> <br>cleanup: <br> <br>if (fBadSyntax) <br>PrintIniFileErr("Bad syntax"); <br> <br>return; <br>} <br> <br> <br>//$--ParseEntryLine------------------------------------------------------------ <br>// <br>// DESCRIPTION: Parse an ini file section entry line to determine what kind of <br>//entry it is, and store the value.  Section entry lines are the <br>//lines that follow the section header. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseEntryLine(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>    INIFILEPARSEINFO *  aifpiEntry =NULL; <br>    CHAR                chTmp ='\0'; <br>    INT                 cKeywords =0; <br>    INT                 i =0; <br>    CHAR *              pchKeyword =NULL; <br> <br>    DEBUGPRIVATE("ParseEntryLine()\n"); <br> <br>    if (ifstCurSection == IFST_COMMAND) <br>    { <br>        aifpiEntry = aifpiCommandEntry; <br>        cKeywords = sizeof(aifpiCommandEntry) / <br>sizeof(aifpiCommandEntry[0]); <br>    } <br>    else if (ifstCurSection == IFST_INITIALIZATION) <br>    { <br>        aifpiEntry = aifpiInitializationEntry; <br>        cKeywords = sizeof(aifpiInitializationEntry) / <br>sizeof(aifpiInitializationEntry[0]); <br>    } <br>    else <br>    { <br>PrintIniFileErr("Entry line not in a valid section"); <br>        goto cleanup; <br>    } <br> <br>    // Save ptr to keyword. <br> <br>    pchKeyword = pch; <br> <br>    // Scan for end of keyword and delimit keyword, saving replaced char. <br> <br>    while (*pch != '=' &amp;&amp;  *pch != ':' &amp;&amp;  !isspace(*pch) &amp;&amp; *pch != '\0') <br>        pch++; <br> <br>    chTmp = *pch; <br> <br>    *pch  = '\0'; <br> <br>    // Compare putative keyword against valid section keywords. <br> <br>    for (i = 0; i &lt; cKeywords; i++) <br>        if (!stricmp(pchKeyword, aifpiEntry[i].pszKeyword)) <br>            break; <br> <br>    *pch = chTmp; <br> <br>    if (i == cKeywords) <br>{ <br>PrintIniFileErr("Invalid keyword"); <br>        goto cleanup; <br>} <br> <br>while (isspace(*pch)) <br>pch++; <br> <br>    aifpiEntry[i].ParseFunction(*pch == '\0' ? NULL : pch + 1); <br> <br>cleanup: <br> <br>return; <br>} <br> <br> <br>//$--ParseActionValue---------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse an Action value entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>// <br>// Notes:In the case of an OP_MOVE or OP_COPY action, it is necessary <br>//to have a MAPI session to properly set up the action struct. <br>//If a session has not been established, we don't report an error <br>//even though the action could not have been completed, because <br>//the error will be caught as a fatal error in  <br>//HrProcessCommandSection(). <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseActionValue(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>static CHARszCopyKeyword[] ="copy"; <br>static CHARszMoveKeyword[] ="move"; <br>static CHARszReplyKeyword[] ="reply"; <br> <br>HRESULThr =NOERROR; <br> <br>    DEBUGPRIVATE("ParseActionValue()\n"); <br> <br>if (pch == NULL|| *pch == '\0') <br>{ <br>PrintIniFileErr("Action entry must have a value"); <br>goto cleanup; <br>} <br> <br>if (lpActions == NULL) <br>{ <br>hr = MAPIAllocateBuffer(sizeof(ACTIONS), (LPVOID FAR *)&amp;lpActions); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErr("Memory allocation failed"); <br>EventLogHexErrorMsg(RULEEDIT_ALLOCATION_FAILED, hr); <br>goto cleanup; <br>} <br> <br>lpActions-&gt;ulVersion =EDK_RULES_VERSION; <br>lpActions-&gt;cActions =0; <br>lpActions-&gt;lpAction =NULL; <br> <br>hr = MAPIAllocateMore(sizeof(ACTION) * cMaxActions, <br>  lpActions, <br>  (LPVOID FAR *)&amp;lpActions-&gt;lpAction); <br>if (FAILED(hr)) <br>{ <br>PrintErr("Memory allocation failed"); <br>EventLogHexErrorMsg(RULEEDIT_ALLOCATION_FAILED, hr); <br>goto cleanup; <br>} <br> <br>memset(lpActions-&gt;lpAction, 0, sizeof(ACTION) * cMaxActions); <br>} <br>else <br>{ <br>if (lpActions-&gt;cActions &gt; cMaxActions) <br>{ <br>PrintIniFileErr("Maximum count of rule actions exceeded"); <br>goto cleanup; <br>} <br>} <br> <br>// Check if the session ptr is NULL.  If so, further check to see if <br>// this is a move, copy or reply action.  In that case we know <br>// HrStringToAction() would fail, and simply return.  The fact that the <br>// session was not established will be reported by other code <br>// (see note above). <br> <br>if (lpSession == NULL) <br>{ <br>if (!memicmp(szCopyKeyword, pch, sizeof(szCopyKeyword) - 1)|| <br>!memicmp(szMoveKeyword, pch, sizeof(szMoveKeyword) - 1)|| <br>!memicmp(szReplyKeyword, pch, sizeof(szReplyKeyword) - 1)) <br>goto cleanup; <br>} <br> <br>hr = HrStringToAction(lpSession, <br>  lpFolder, <br>  pch, <br>  lpActions, <br>  &amp;lpActions-&gt;lpAction[lpActions-&gt;cActions]); <br> <br>if (FAILED(hr)) <br>{ <br>if (hr == E_INVALIDARG) <br>PrintIniFileErr("Bad syntax or value in action value"); <br>else <br>PrintErr("Action creation failed for action at line %u of ini file;" </code></pre>
<p>
</p>
<pre><code>"Error code = %#x", iLine, hr); <br>goto cleanup; <br>} <br> <br>lpActions-&gt;cActions++; <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>//$--ParseCommandValue--------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a Command value entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseCommandValue(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>    DEBUGPRIVATE("ParseCommandValue()\n"); <br> <br>if (pch == NULL || *pch == '\0') <br>{ <br>PrintIniFileErr("Command entry must have a value"); <br>goto cleanup; <br>} <br> <br>if (EditCmd != EDITCMD_INVALID) <br>{ <br>PrintIniFileErr("Multiple command entries"); <br>goto cleanup; <br>} <br> <br>if (!stricmp(pch, szDeleteKeyword)) <br>{ <br>EditCmd = EDITCMD_DELETE; <br>} <br>else if (!stricmp(pch, szDisableKeyword)) <br>{ <br>EditCmd = EDITCMD_DISABLE; <br>} <br>else if (!stricmp(pch, szEnableKeyword)) <br>{ <br>EditCmd = EDITCMD_ENABLE; <br>} <br>else if (!stricmp(pch, szInsertKeyword)) <br>{ <br>EditCmd = EDITCMD_INSERT; <br>} <br>else if (!stricmp(pch, szListKeyword)) <br>{ <br>EditCmd = EDITCMD_LIST; <br>} <br>else <br>{ <br>PrintIniFileErr("Command '%s' is not valid", pch); <br>} <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>//$--ParseConditionValue------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a Condition value entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseConditionValue(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>HRESULThr =NOERROR; <br> <br>    DEBUGPRIVATE("ParseConditionValue()\n"); <br> <br>if (pch == NULL || *pch == '\0') <br>{ <br>PrintIniFileErr("Condition entry must have a value"); <br>goto cleanup; <br>} <br> <br>if (lpRes != NULL) <br>{ <br>PrintIniFileErr("Multiple condition entries"); <br>goto cleanup; <br>} <br> <br>hr = HrStringToRestriction(pch, NULL, &amp;lpRes); <br> <br>if (FAILED(hr)) <br>{ <br>if (hr == E_INVALIDARG) <br>PrintIniFileErr("Bad syntax or value in condition expression"); <br>else <br>PrintErr("Restriction creation failed for condition at line %u " <br> "of ini file; Error code = %#x", iLine, hr); <br>goto cleanup; <br>} <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>//$--ParseFlagsValue----------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a Flags value entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseFlagsValue(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>CHARchTmp ='\0'; <br>BOOLfBadSyntax =FALSE; <br>BOOLfDisabledKeywordFnd =FALSE; <br>CHAR *pchEnd =NULL; <br> <br>    DEBUGPRIVATE("ParseFlagsValue()\n"); <br> <br>if (pch == NULL || *pch == '\0') <br>{ <br>PrintIniFileErr("Flags entry must have a value"); <br>goto cleanup; <br>} <br> <br>if (fFlagsArgFnd) <br>{ <br>PrintIniFileErr("Multiple Flags entries"); <br>goto cleanup; <br>} <br> <br>while (isspace(*pch))// Skip leading line whitespace. <br>pch++; <br> <br>if (*pch == '\0') <br>{ <br>fBadSyntax = TRUE; <br>goto cleanup; <br>} <br> <br>// We override the default of ST_ENABLED since we have a flags= entry. <br> <br>lStateFlags = ST_DISABLED; <br> <br>while(TRUE) <br>{ <br>pchEnd = pch; <br> <br>while (isalpha(*pchEnd)) <br>pchEnd++; <br> <br>chTmp = *pchEnd; <br> <br>*pchEnd = '\0'; <br> <br>if (!stricmp(pch, szEnabledKeyword)) <br>{ <br>lStateFlags |=ST_ENABLED; <br>} <br>else if (!stricmp(pch, szDisabledKeyword)) <br>{ <br>fDisabledKeywordFnd = TRUE; <br>} <br>else if (!stricmp(pch, szUserOOFKeyword)) <br>{ <br>lStateFlags |=ST_ONLY_WHEN_OOF; <br>} <br>else if (!stricmp(pch, szErrorKeyword)) <br>{ <br>lStateFlags |=ST_ERROR; <br>} <br>else if (!stricmp(pch, szKeepOOFHistKeyword)) <br>{ <br>lStateFlags |=ST_KEEP_OOF_HIST; <br>} <br>else if (!stricmp(pch, szExitLevelKeyword)) <br>{ <br>lStateFlags |=ST_EXIT_LEVEL; <br>} <br>else <br>{ <br>*pchEnd = chTmp; <br>fBadSyntax = TRUE; <br>goto cleanup; <br>} <br> <br>*pchEnd = chTmp; <br> <br>pch = pchEnd; <br> <br>while (isspace(*pch)) <br>pch++; <br> <br>if (*pch == '\0') <br>break; <br> <br>if (*pch == ',') <br>{ <br>pch++; <br>} <br>else <br>{ <br>fBadSyntax = TRUE; <br>goto cleanup; <br>} <br> <br>while (isspace(*pch)) <br>pch++; <br>} <br> <br>if ((lStateFlags &amp; ST_ENABLED) &amp;&amp; fDisabledKeywordFnd) <br>{ <br>PrintIniFileErr("Conflicting flags in Flags entry"); <br>goto cleanup; <br>} <br> <br>fFlagsArgFnd = TRUE; <br> <br>cleanup: <br> <br>if (fBadSyntax) <br>{ <br>PrintIniFileErr("Bad syntax in Flags entry"); <br>goto cleanup; <br>} <br> <br>    return; <br>} <br> <br> <br>//$--ParsePositionValue-------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a position value entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParsePositionValue(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>    DEBUGPRIVATE("ParsePositionValue()\n"); <br> <br>if (pch == NULL || *pch == '\0') <br>{ <br>PrintIniFileErr("Position entry must have a value"); <br>goto cleanup; <br>} <br> <br>if (fPositionArgFnd) <br>{ <br>PrintIniFileErr("Multiple position entries"); <br>goto cleanup; <br>} <br> <br>if (!stricmp(pch, "END")) <br>{ <br>lCursor = RULE_PAST_END; <br>} <br>else <br>{ <br>errno = 0; <br> <br>lCursor = strtol(pch, (CHAR **)NULL, 10); <br> <br>if ((lCursor == LONG_MAX || lCursor == LONG_MIN) &amp;&amp; <br>errno == ERANGE) <br>{ <br>PrintIniFileErr("Position value invalid"); <br>goto cleanup; <br>} <br>} <br> <br>fPositionArgFnd = TRUE; <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>//$--ParseFolderValue---------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a Folder value entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseFolderValue(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>    DEBUGPRIVATE("ParseFolderValue()\n"); <br> <br>if (fSkipFolderArg) <br>goto cleanup; <br> <br>if (pch == NULL || *pch == '\0') <br>{ <br>PrintIniFileErr("Folder entry must have a value"); <br>goto cleanup; <br>} <br> <br>if (szFolder[0] != '\0' || fInboxArgFnd) <br>{ <br>PrintIniFileErr("Multiple folder entries"); <br>goto cleanup; <br>} <br> <br>if (!stricmp(pch, szInboxKeyword)) <br>{ <br>// It is the special name "inbox", which is interpreted as <br>// appropriate. <br> <br>fInboxArgFnd = TRUE; <br>} <br>else <br>{ <br>// Split the store and folder names and check their lengths. <br> <br>CHAR *pszFolder = strchr(pch, '\\'); <br> <br>if (pszFolder == NULL) <br>{ <br>PrintIniFileErr("Invalid folder name"); <br>goto cleanup; <br>} <br> <br>*pszFolder = '\0'; <br>pszFolder++; <br> <br>if (*pch == '\0') <br>{ <br>PrintIniFileErr("Invalid folder name"); <br>goto cleanup; <br>} <br> <br>if (strlen(pch) &gt;= sizeof(szStore)) <br>{ <br>PrintIniFileErr("Folder name too long"); <br>goto cleanup; <br>} <br> <br>strcpy(szStore, pch); <br> <br>if (*pszFolder == '\0') <br>{ <br>PrintIniFileErr("Invalid folder name"); <br>goto cleanup; <br>} <br> <br>if (strlen(pszFolder) &gt;= sizeof(szFolder)) <br>{ <br>PrintIniFileErr("Folder name too long"); <br>goto cleanup; <br>} <br> <br>strcpy(szFolder, pszFolder); <br>} <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>//$--ParseProfileValue--------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a Profile value entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseProfileValue(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>    DEBUGPRIVATE("ParseProfileValue()\n"); <br> <br>if (fSkipProfileArg) <br>goto cleanup; <br> <br>if (pch == NULL || *pch == '\0') <br>{ <br>PrintIniFileErr("Profile entry must have a value"); <br>goto cleanup; <br>} <br> <br>if (szProfile[0] != '\0') <br>{ <br>PrintIniFileErr("Multiple profile entries"); <br>goto cleanup; <br>} <br> <br>if (strlen(pch) &gt;= sizeof(szProfile)) <br>{ <br>PrintIniFileErr("Profile name too long"); <br>goto cleanup; <br>} <br> <br>strcpy(szProfile, pch); <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>//$--ParseProviderValue-------------------------------------------------------- <br>// <br>// DESCRIPTION: Parse a Provider value entry line. <br>// <br>// INPUT:       [pch]-- Ptr to input string. <br>// <br>// RETURNS:     Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>ParseProviderValue(// RETURNS: VOID <br>    IN      CHAR *  pch// input line <br>    ) <br>{ <br>    DEBUGPRIVATE("ParseProviderValue()\n"); <br> <br>if (fSkipProviderArg) <br>goto cleanup; <br> <br>if (pch == NULL || *pch == '\0') <br>{ <br>PrintIniFileErr("Provider entry must have a value"); <br>goto cleanup; <br>} <br> <br>if (szProvider[0] != '\0') <br>{ <br>PrintIniFileErr("Multiple provider entries"); <br>goto cleanup; <br>} <br> <br>if (strlen(pch) &gt;= sizeof(szProvider)) <br>{ <br>PrintIniFileErr("Provider name too long"); <br>goto cleanup; <br>} <br> <br>strcpy(szProvider, pch); <br> <br>fProviderArgFnd = TRUE; <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>//$--PrintActions-------------------------------------------------------------- <br>// <br>// DESCRIPTION:    Print the rule actions. <br>// <br>// INPUT: <br>// <br>//[lpActs]-- Rule actions to print. <br>// <br>// RETURNS:VOID <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>PrintActions(     // RETURNS: VOID <br>INLPACTIONSlpActs  // actions ptr <br>) <br>{ <br>HRESULThr =NOERROR; <br>ULONGi; <br>LPACTIONlpAct =NULL; <br>LPSTRlpszAct =NULL; <br> <br>    DEBUGPRIVATE("PrintActions()\n"); <br>    <br>if (lpActs-&gt;cActions &lt;= 0 || lpActs-&gt;lpAction == NULL) <br>{ <br>printf("Rule Actions structure is invalid.\n"); <br>        goto cleanup; <br>} <br> <br>for (i = 0; i &lt; lpActs-&gt;cActions; i++) <br>{ <br>lpAct =&amp;(lpActs-&gt;lpAction[i]); <br> <br>hr = HrActionToString(lpSession, lpAct, &amp;lpszAct); <br> <br>if (FAILED(hr)) <br>{ <br>printf("String representation of rule action %u " <br>   "could not be determined.\n", i); <br>cErrs++; <br>EventLogHexErrorMsg(RULEEDIT_ACTIONTOSTRING_FAILED, hr); <br>} <br>else <br>{ <br>printf("Rule Action %u = %s\n", i, lpszAct); <br>} <br> <br>MAPIFREEBUFFER(lpszAct); <br>} <br> <br>cleanup: <br> <br>    return; <br>} <br> <br> <br>//$--PrintErr------------------------------------------------------------------ <br>// <br>// DESCRIPTION:Print an error message to stdout in a standard format. <br>// <br>// INPUT: <br>// <br>//[Format]-- Printf-style format string. <br>//[...]-- Variable argument parameters for format string. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>PrintErr(        // RETURNS: VOID <br>INCHAR *Format      // error message format <br>... <br>) <br>{ <br>va_listargs; <br> <br>    DEBUGPRIVATE("PrintErr()\n"); <br> <br>cErrs++; <br> <br>printf("ERROR: "); <br> <br>va_start(args, Format); <br> <br>vprintf(Format, args); <br> <br>va_end(args); <br> <br>printf(".\n\n"); <br> <br>    return; <br>} <br> <br> <br>//$--PrintIniFileErr----------------------------------------------------------- <br>// <br>// DESCRIPTION:Print an error message to stdout in a standard format. <br>//This is intended primarily for use in reporting ini file  <br>//input errors. <br>// <br>// INPUT: <br>// <br>//[Format]-- Printf-style format string. <br>//[...]-- Variable argument parameters for format string. <br>// <br>// RETURNS:Nothing. <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>PrintIniFileErr(        // RETURNS: VOID <br>INCHAR *Format      // error message format <br>... <br>) <br>{ <br>va_listargs; <br> <br>    DEBUGPRIVATE("PrintIniFileErr()\n"); <br> <br>cErrs++; <br> <br>printf("ERROR: "); <br> <br>va_start(args, Format); <br> <br>vprintf(Format, args); <br> <br>va_end(args); <br> <br>printf(" in line %u of Ini File.\n\n", iLine); <br> <br>    return; <br>} <br> <br> <br>//$--PrintStateFlags----------------------------------------------------------- <br>// <br>// DESCRIPTION:    Print the rule state flags. <br>// <br>// INPUT: <br>// <br>//[lStateFlags]-- Rule state flags to print. <br>// <br>// RETURNS:VOID <br>// <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>PrintStateFlags(   // RETURNS: VOID <br>INLONGlStateFlags// state flags <br>) <br>{ <br>    DEBUGPRIVATE("PrintStateFlags()\n"); <br> <br>printf("Rule state flags ="); <br> <br>if (lStateFlags &amp; ST_ENABLED) <br>printf(" Enabled"); <br>else <br>printf(" Disabled"); <br> <br>if (lStateFlags &amp; ST_ERROR) <br>printf(", Error"); <br> <br>if (lStateFlags &amp; ST_ONLY_WHEN_OOF) <br>printf(", UserOOF"); <br> <br>if (lStateFlags &amp; ST_KEEP_OOF_HIST) <br>printf(", KeepOOFHist"); <br> <br>if (lStateFlags &amp; ST_EXIT_LEVEL) <br>printf(", ExitLevel"); <br> <br>printf("\n"); <br> <br>    return; <br>} <br> <br> <br>//$--Usage--------------------------------------------------------------------- <br>// <br>// DESCRIPTION:Print a usage message to the console. <br>// <br>// INPUT:None. <br>// <br>// RETURNS:Nothing. <br>//----------------------------------------------------------------------------- <br> <br>VOID <br>Usage(VOID)  // RETURNS: VOID <br>{ <br>    DEBUGPRIVATE("Usage()\n"); <br> <br>printf( <br>"\n" <br>"USAGE: RULEEDIT [/Profile=&lt;ProfileName&gt;]" <br>"\n" <br>"                [&lt;Folder&gt;]" <br>"\n" <br>"                [/List | /File=&lt;IniFile&gt;]" <br>"\n" <br>"                [/Provider=&lt;ProviderName&gt;]" <br>"\n" <br>"\n" <br>"&lt;Folder&gt; ::= /Folder=&lt;StoreName&gt;\\&lt;FolderPath&gt; | /Folder=Inbox" <br>"\n" <br>"\n" <br>"Enter RULEEDIT /? for more details." <br>"\n" <br>"\n" <br>); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
