<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CFGCODE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1766"></a>CFGCODE.C</h2>
<pre><code>// --cfgcode.c------------------------------------------------------------------ <br>// <br>//  Program to take a .INI file containing property values as input, and create  <br>//  a file containing packed configuration data as output. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include "cfgcode.chk" <br>#include "cfgcodem.h" <br>#include &lt;io.h&gt; <br>#include &lt;sys/stat.h&gt; <br> <br>// <br>// Command Line Argument Names <br>// <br> <br>#define ARG_PROGRAM_NAME        "CFGCODE" <br>#define ARG_INPUT_FILE          "InFile" <br>#define ARG_OUTPUT_FILE         "OutFile" <br>#define ARG_SECTION             "SECTION" <br>#define ARG_CONFIG_NAME         "NAME" <br>#define ARG_HELP1               "?" <br>#define ARG_HELP2               "HELP" <br> <br>static char * rgpszArgArray[] = <br>{ <br>ARG_PROGRAM_NAME, <br>ARG_INPUT_FILE, <br>ARG_OUTPUT_FILE, <br>ARG_SECTION, <br>ARG_CONFIG_NAME, <br>ARG_HELP1, <br>ARG_HELP2, <br>}; <br> <br>// <br>// Command Line Argument Variables <br>// <br> <br>static TCHAR    szInputFile[MAX_PATH+1]  = {0}; <br>static TCHAR    szOutputFile[MAX_PATH+1] = {0}; <br>static TCHAR    szSection[MAX_PATH+1]    = {0}; <br>static TCHAR    szConfigName[MAX_PATH+1] = {0}; <br>static BOOL     fPrintHelp               = FALSE; <br>static BOOL     fPrintUsage              = FALSE; <br> <br>// <br>// Function Declarations <br>// <br> <br>static VOID PrintUsage(void); <br> <br>static VOID PrintHelp(void); <br> <br>static HRESULT HrParseCommandLine( <br>IN      int                     argc, <br>IN      char *                  argv[]); <br> <br>static HRESULT HrReadPropsFromINIFile( <br>IN      LPTSTR                  pszInputFile, <br>IN      LPTSTR                  pszSection, <br>OUT     ULONG *                 pcProps, <br>OUT     LPSPropValue *  ppProps); <br> <br>static HRESULT HrParsePropValue( <br>    IN      LPTSTR                  pszFullLine, <br>IN      ULONG                   ulPropTag, <br>IN      LPTSTR                  pszValueText, <br>IN      LPVOID                  pBaseObject, <br>OUT     LPSPropValue            pProp); <br> <br>static HRESULT HrCreateBinaryDataFile( <br>IN      LPTSTR                  pszOutputFile, <br>IN      ULONG                   cbData, <br>IN      LPBYTE                  pbData); <br> <br>// <br>// Functions <br>// <br> <br>//$--main----------------------------------------------------------------------- <br>//  Main function that performs file conversion. <br>// ----------------------------------------------------------------------------- <br>int main(                               // RETURNS: exit code <br>IN      int                 argc,   // number of arguments on command line <br>IN      char *              argv[]) // array of command line arguments <br>{ <br>HRESULT                 hr                      = NOERROR; <br>BOOL                    fMAPIInitialized        = FALSE; <br>MAPIINIT_0              MapiInit                = { 0 }; <br>BOOL                    fPrintResult            = FALSE; <br>ULONG                   cProps                  = 0; <br>LPSPropValue            pProps                  = NULL; <br>ULONG                   cbConfigData            = 0; <br>LPBYTE                  pbConfigData            = NULL; <br>BOOL                    fEventLogOpen           = FALSE; <br> <br>DEBUGPUBLIC("main()\n"); <br> <br>hr = CHK_main(argc, argv); <br>if (FAILED(hr)) <br>return _nEcFromHr(EC_EDK_E_FAIL); <br> <br>    printf( "\n" ); <br> <br>// Parse the command line arguments. <br> <br>hr = HrParseCommandLine(argc, argv); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>// If they requested a usage message (i.e. no arguments) then  <br>// print a usage message and exit. <br> <br>if (fPrintUsage) <br>{ <br>PrintUsage(); <br>goto cleanup; <br>} <br> <br>// If they requested help then print a help message and exit. <br> <br>if (fPrintHelp) <br>{ <br>PrintHelp(); <br>goto cleanup; <br>} <br> <br>// Open the event log. <br> <br>hr = HrEventOpenLog( <br>    TEXT("EDK CFGCODE"), NULL, NULL, NULL, NULL, NULL); <br> <br>if (FAILED(hr)) <br>{ <br>fprintf(stderr, "ERROR: Can't open event log.\n"); <br>goto cleanup; <br>} <br>fEventLogOpen = TRUE; <br> <br>// After this point we print the result of the operation and number  <br>// of events logged. <br> <br>fPrintResult = TRUE; <br> <br>// Initialize MAPI. <br> <br>    MapiInit.ulVersion = MAPI_INIT_VERSION; <br> <br>    hr = MAPIInitialize(&amp;MapiInit); <br>    if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>EDKEVENT_CANNOT_INIT_MAPI,  <br>0,  <br>0); <br>goto cleanup; <br>} <br> <br>fMAPIInitialized = TRUE; <br> <br>// If the input file name is not a full path then add the current  <br>// directory to the front of the name. <br> <br>if (strchr(szInputFile,':') == NULL &amp;&amp; strchr(szInputFile,'\\') == NULL) <br>{ <br>TCHAR szCurrentDir[MAX_PATH+1] = {0}; <br>ULONG cchCurrentDir = 0; <br> <br>cchCurrentDir = GetCurrentDirectory(MAX_PATH, szCurrentDir); <br>if (cchCurrentDir == 0) <br>{ <br>EventLogMsg( <br>CFGCODE_CANNOT_GET_CURRENT_DIR,  <br>0,  <br>1, GetLastError()); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>if ( <br>szCurrentDir[cchCurrentDir - 1] != ':' &amp;&amp;  <br>szCurrentDir[cchCurrentDir - 1] != '\\') <br>{ <br>strcat(szCurrentDir, "\\"); <br>} <br>strcat(szCurrentDir, szInputFile); <br>strcpy(szInputFile, szCurrentDir); <br>} <br> <br>// Do the operation. <br> <br>hr = HrReadPropsFromINIFile(szInputFile, szSection, &amp;cProps, &amp;pProps); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>hr = HrCfgPackData( <br>szConfigName, cProps, pProps, &amp;cbConfigData, &amp;pbConfigData); <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>CFGCODE_CANNOT_PACK_CONFIG_INFO,  <br>0,  <br>0); <br>goto cleanup; <br>} <br> <br>hr = HrCreateBinaryDataFile(szOutputFile, cbConfigData, pbConfigData); <br>if (FAILED(hr)) <br>{ <br>goto cleanup; <br>} <br> <br>cleanup: <br>// Print the results of the operation if we got that far. <br> <br>if (fPrintResult) <br>{ <br>if (SUCCEEDED(hr)) <br>{ <br>printf("File created.\n"); <br>} <br>else <br>{ <br>HRESULT hrT = NOERROR; <br>EDKEVENTCOUNT sEventCount = {0}; <br> <br>hrT = HrEventGetCounts(&amp;sEventCount); <br>if (FAILED(hrT) ||  <br>(sEventCount.cError == 0 &amp;&amp; sEventCount.cWarning == 0)) <br>{ <br>fprintf(stderr, "ERROR: operation failed.\n"); <br>} <br> <br>// Print the number of errors logged. <br> <br>if (sEventCount.cError == 1) <br>{ <br>fprintf(stderr,  <br>"ERROR: 1 error written to NT event log.\n"); <br>} <br>else if (sEventCount.cError &gt; 1) <br>{ <br>fprintf(stderr,  <br>"ERROR: %d errors written to NT event log.\n"); <br>} <br> <br>// Print the number of warnings logged. <br> <br>if (sEventCount.cWarning == 1) <br>{ <br>fprintf(stderr,  <br>"WARNING: 1 warning written to NT event log.\n"); <br>} <br>else if (sEventCount.cWarning &gt; 1) <br>{ <br>fprintf(stderr,  <br>"WARNING: %d warnings written to NT event log.\n"); <br>} <br>} <br>} <br> <br>// Free up everything. <br> <br>if (fMAPIInitialized) <br>{ <br>MAPIFREEBUFFER(pProps); <br>MAPIFREEBUFFER(pbConfigData); <br>MAPIUninitialize(); <br>} <br> <br>// Close event logging. <br> <br>if (fEventLogOpen) <br>{ <br>(void)HrEventCloseLog(); <br>fEventLogOpen = FALSE; <br>} <br> <br>    // return exit code <br>    return _nEcFromHr(hr); <br> <br>} <br> <br> <br> <br>//$--PrintUsage----------------------------------------------------------------- <br>//  Print brief message about how to use this program. <br>// ----------------------------------------------------------------------------- <br>static VOID PrintUsage(void)                    // RETURNS: nothing <br>{ <br>DEBUGPRIVATE("PrintUsage()\n"); <br> <br>printf("USAGE: CFGCODE InFile OutFile [Flags]\n"); <br>printf("\n"); <br>printf("  [Flags]        Enter CFGCODE /? for details\n"); <br>} <br> <br> <br> <br>//$--PrintHelp------------------------------------------------------------------ <br>//  Print more detailed message about how to use this program. <br>// ----------------------------------------------------------------------------- <br>static VOID PrintHelp(void)                             // RETURNS: nothing <br>{ <br>DEBUGPRIVATE("PrintHelp()\n"); <br> <br>printf("Utility to create a packed configuration data file from a .INI " <br>"file.\n"); <br>printf("\n"); <br>printf("USAGE: CFGCODE InFile OutFile [Flags]\n"); <br>printf("\n"); <br>printf("  InFile         Input .INI file containing MAPI properties\n"); <br>printf("  OutFile        Output file to write packed configuration data\n"); <br>printf("  /SECTION=      Name of the [Section] in the .INI file\n"); <br>printf("  /NAME=         Configuration name for packed data\n"); <br>printf("  /HELP or /?    Display help screen\n"); <br>} <br> <br> <br> <br>//$--HrParseCommandLine--------------------------------------------------------- <br>//  Parse the command line arguments and put their values in the appropriate  <br>//  variables. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParseCommandLine(              // RETURNS: HRESULT <br>IN      int                             argc,                   // number of arguments on command line <br>IN      char *                  argv[])                 // array of command line arguments <br>{ <br>HRESULT         hr                              = NOERROR; <br>HRESULT         hrT                             = NOERROR; <br>int                     i                               = 0; <br>char *          pszArgument             = NULL; <br>char *          pszValue                = NULL; <br>int                     cNonFlagArgs    = 0; <br> <br>DEBUGPRIVATE("HrParseCommandLine()\n"); <br> <br>hr = CHK_main(argc, argv); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// If there are no flags on the command line then just print usage message. <br> <br>if (argc &lt; 2) <br>{ <br>fPrintUsage = TRUE; <br>goto cleanup; <br>} <br> <br>// Do an initial check for /? or /HELP.  If found, don't do any other  <br>// parsing. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br>hrT = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>&amp;pszArgument, &amp;pszValue); <br> <br>if (SUCCEEDED(hrT) &amp;&amp; pszArgument &amp;&amp;  <br>(!_stricmp(pszArgument,ARG_HELP1) ||  <br>!_stricmp(pszArgument,ARG_HELP2))) <br>{ <br>fPrintHelp = TRUE; <br>goto cleanup; <br>} <br>} <br> <br>// Loop through and parse all the command line arguments. <br> <br>for (i = 1; i &lt; argc; i++) <br>{ <br> hr = _HrExpandCommandLineArgument( <br>argv[i], rgpszArgArray, ARRAY_CNT(rgpszArgArray), NULL,  <br>&amp;pszArgument, &amp;pszValue); <br>if (FAILED(hr)) <br>{ <br>fprintf(stderr, "ERROR: unable to parse command line flags.\n"); <br>goto cleanup; <br>} <br> <br>// Parse non-flag arguments. <br> <br>if (pszArgument == NULL &amp;&amp; pszValue != NULL) <br>{ <br>switch (++cNonFlagArgs) <br>{ <br>case 1:         // Input File <br>STRNCPY(szInputFile, pszValue); <br>break; <br> <br>case 2:         // Output File <br>STRNCPY(szOutputFile, pszValue); <br>break; <br> <br>default:        // Too many arguments!!! <br>fprintf(stderr, "ERROR: unknown argument %s\n", argv[i]); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Parse flag arguments that don't take a value. <br> <br>else if (pszArgument != NULL &amp;&amp; pszValue == NULL) <br>{ <br>fprintf(stderr, "ERROR: flag /%s requires a value\n",  <br>pszArgument); <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>// Parse flag arguments that take a value. <br> <br>else if (pszArgument != NULL &amp;&amp; pszValue != NULL) <br>{ <br>if (!_stricmp(pszArgument,ARG_SECTION)) <br>{ <br>STRNCPY(szSection, pszValue); <br>} <br>else <br>if (!_stricmp(pszArgument,ARG_CONFIG_NAME)) <br>{ <br>STRNCPY(szConfigName, pszValue); <br>} <br>else <br>{ <br>fprintf(stderr, "ERROR: flag /%s does not take a value\n",  <br>pszArgument); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Catch unknown flags. <br> <br>else <br>{ <br>fprintf(stderr, "ERROR: unknown flag %s\n", argv[i]); <br>hr = HR_LOG(E_FAIL); <br>} <br>} <br> <br>// Now make sure that all the flags are valid. <br> <br>if (*szInputFile == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify %s\n", ARG_INPUT_FILE); <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>if (*szOutputFile == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify %s\n", ARG_OUTPUT_FILE); <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>if (*szSection == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify /%s\n", ARG_SECTION); <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>if (*szConfigName == 0) <br>{ <br>fprintf(stderr, "ERROR: please specify /%s\n", ARG_CONFIG_NAME); <br>hr = HR_LOG(E_FAIL); <br>} <br> <br>cleanup: <br> <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrReadPropsFromINIFile----------------------------------------------------- <br>//  Read a set of MAPI properties from a .INI file. <br>// <br>//  Properties are stored with the property tags as hex values, as follows: <br>// <br>//  [Section_Name] <br>//  &lt;property_tag&gt;=&lt;value&gt; <br>//  &lt;property_tag&gt;=&lt;value&gt; <br>//  &lt;property_tag&gt;=&lt;value&gt; <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrReadPropsFromINIFile(  // RETURNS: HRESULT <br>IN      LPTSTR                  pszInputFile,   // name of file to read properties from <br>IN      LPTSTR                  pszSection,             // name of section in file <br>OUT     ULONG *                 pcProps,                // number of properties read from file <br>OUT     LPSPropValue *  ppProps)                // array of properties read from file <br>{ <br>HRESULT                 hr                                      = NOERROR; <br>LPTSTR                  pszSectionBuffer        = NULL; <br>ULONG                   cchSectionBuffer        = 2048; <br>ULONG                   cchActualSize           = 0; <br>LPTSTR                  psz                                     = NULL; <br>LPTSTR                  pszFullLine                     = NULL; <br>ULONG                   iProp                           = 0; <br>ULONG                   cProps                          = 0; <br>LPSPropValue    pProps                          = NULL; <br>ULONG                   ulPropTag                       = 0; <br>ULONG                   ulError                         = ERROR_SUCCESS; <br> <br>DEBUGPRIVATE("HrReadPropsFromINIFile()\n"); <br> <br>hr = CHK_HrReadPropsFromINIFile( <br>pszInputFile,  <br>pszSection,  <br>pcProps,  <br>ppProps); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>// Read the entire section from the .INI file into the buffer. <br>// If the buffer is too small then double its size and keep trying. <br> <br>while (TRUE) <br>{ <br>// Get the memory for the buffer to read in the section. <br> <br>hr = MAPIAllocateBuffer(cchSectionBuffer, &amp;pszSectionBuffer); <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>} <br>ZeroMemory(pszSectionBuffer, cchSectionBuffer); <br> <br>// Read in the section data. <br> <br>SetLastError(ERROR_SUCCESS); <br>cchActualSize = GetPrivateProfileSection( <br>pszSection,  <br>pszSectionBuffer,  <br>cchSectionBuffer,  <br>pszInputFile); <br>ulError = GetLastError(); <br>if (ulError != ERROR_SUCCESS) <br>{ <br>    if (ulError == ERROR_FILE_NOT_FOUND) <br>    { <br>EventLogMsg( <br>CFGCODE_CANNOT_READ_PROFILE_SECTION_FNF,  <br>2, pszSection, pszInputFile,  <br>0); <br>    } <br>    else <br>    { <br>EventLogMsg( <br>CFGCODE_CANNOT_READ_PROFILE_SECTION,  <br>2, pszSection, pszInputFile,  <br>1, GetLastError()); <br>    } <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// If the buffer was big enough then we're done.  If the buffer is  <br>// not big enough then the return value is the buffer size minus  <br>// two (see GetPrivateProfileSection() documentation). <br> <br>if (cchActualSize &lt; (cchSectionBuffer - 2)) <br>break; <br> <br>// Otherwise, add 2K to the buffer size and try again. <br> <br>MAPIFREEBUFFER(pszSectionBuffer); <br> <br>cchSectionBuffer += 2048; <br>} <br> <br>// Count the number of properties we've read. <br> <br>for (psz = pszSectionBuffer; *psz; psz += (lstrlen(psz) + 1)) <br>{ <br>cProps++; <br>} <br> <br>// Allocate an array of SPropValue's big enough to hold all the properties. <br> <br>hr = MAPIAllocateBuffer(cProps * sizeof(SPropValue), &amp;pProps); <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>} <br> <br>// Read in the data and store it in the allocated array.  We may also need  <br>// to allocate other pieces of memory to put the values of data items. <br> <br>for ( <br>psz = pszSectionBuffer, iProp = 0;  <br>*psz;  <br>psz += (lstrlen(psz) + 1), iProp++) <br>{ <br>ASSERTERROR(iProp &lt; cProps, "iProp &gt;= cProps: array overflow!"); <br> <br>// Save pointer to original string in case we have to log an error. <br> <br>pszFullLine = psz; <br> <br>// Get the property tag. <br> <br>ulPropTag = strtol(psz, &amp;psz, 16); <br>if (psz == pszFullLine) <br>{ <br>EventLogMsg( <br>CFGCODE_NO_PROP_TAG,  <br>1, pszFullLine,  <br>0); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Make sure there's an equal sign. <br> <br>if (*psz++ != '=') <br>{ <br>EventLogMsg( <br>CFGCODE_PROP_TAG_WITHOUT_EQUALS,  <br>1, pszFullLine,  <br>0); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>// Get the value based on the property type. <br> <br>hr = HrParsePropValue(pszFullLine, ulPropTag, psz, pProps, &amp;pProps[iProp]); <br>if (FAILED(hr)) <br>goto cleanup; <br> <br>} // end for <br> <br>// Set the output parameters. <br> <br>*pcProps = cProps; <br>*ppProps = pProps; <br> <br>cleanup: <br>MAPIFREEBUFFER(pszSectionBuffer); <br>if (FAILED(hr)) <br>{ <br>MAPIFREEBUFFER(pProps); <br>} <br> <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrParsePropValue----------------------------------------------------------- <br>//  Takes a text version of a property value and fills in an SPropValue  <br>//  structure.  If memory needs to be allocated, it is allocated using  <br>//  MAPIAllocateMore() based on the object passed in pBaseObject. <br>// <br>//  Valid property value formats for property types are as follows (and do  <br>//  not include the quotes): <br>// <br>//  PT_BINARY   a series of two digit hex numbers separated by spaces <br>//              (e.g. "01 fe 2a 00 1c") <br>// <br>//  PT_BOOLEAN  the value 1 or 0 (1=True, 0=False) <br>// <br>//  PT_LONG     a decimal or hex constant (e.g. "127" or "0x0fff0003") <br>// <br>//  PT_STRING8  any string of characters (e.g. "This is fun!") <br>// <br>//  PT_SYSTIME  a date in the format "yyyy/mm/dd hh:mm:ss"  <br>//              (e.g. "1995/12/31 23:59:59") <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrParsePropValue(                // RETURNS: HRESULT <br>    IN  LPTSTR          pszFullLine,    // the full line (for error logging) <br>IN      ULONG                   ulPropTag,              // property tag of this property <br>IN      LPTSTR                  pszValueText,   // text of property value to parse <br>IN      LPVOID                  pBaseObject,    // base object for MAPIAllocateMore() <br>OUT     LPSPropValue    pProp)                  // structure to write results <br>{ <br>HRESULT                 hr                              = NOERROR; <br>LPTSTR          psz             = NULL; <br>LPTSTR          pszPrev         = NULL; <br> <br>DEBUGPRIVATE("HrParsePropValue()\n"); <br> <br>hr = CHK_HrParsePropValue( <br>pszFullLine,  <br>ulPropTag,  <br>pszValueText,  <br>pBaseObject,  <br>pProp); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>switch (PROP_TYPE(ulPropTag)) <br>{ <br>case PT_BINARY: <br>{ <br>ULONG cb = 0; <br>ULONG ib = 0; <br>LPBYTE pb = NULL; <br>LONG lNumber = 0; <br> <br>// Count the bytes and check that all the bytes are valid. <br> <br>psz = pszValueText; <br>while (*psz) <br>{ <br>if (isspace(*psz)) <br>psz++; <br>else <br>{ <br>pszPrev = psz; <br>lNumber = strtol(psz, &amp;psz, 16); <br>if (psz == pszPrev || lNumber &gt; 255 || lNumber &lt; 0) <br>    { <br>hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>CFGCODE_ILLEGAL_BINARY_VALUE,  <br>1, pszFullLine,  <br>0); <br>goto cleanup; <br>    } <br>cb++; <br>} <br>} <br> <br>// Allocate a buffer big enough for the number of bytes. <br> <br>hr = MAPIAllocateMore(cb, pBaseObject, &amp;pProp-&gt;Value.bin.lpb); <br>if (FAILED(hr)) <br>{ <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>} <br>pProp-&gt;Value.bin.cb = cb; <br> <br>// Write the bytes into the buffer. <br> <br>psz = pszValueText; <br>for (ib = 0, pb = pProp-&gt;Value.bin.lpb; ib &lt; cb; ib++, pb++) <br>{ <br>*pb = (BYTE)strtol(psz, &amp;psz, 16); <br>} <br> <br>break; <br>} <br> <br>case PT_BOOLEAN: <br>    psz = pszValueText; <br> <br>    while (isspace(*psz)) <br>psz++; <br> <br>    pszPrev = psz; <br>pProp-&gt;Value.l = strtol(psz, &amp;psz, 0); <br> <br>    while (isspace(*psz)) <br>psz++; <br> <br>    if (psz == pszPrev || *psz ||  <br>(pProp-&gt;Value.l != 0 &amp;&amp; pProp-&gt;Value.l != 1)) <br>    { <br>hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>CFGCODE_ILLEGAL_BOOLEAN_VALUE,  <br>1, pszFullLine,  <br>0); <br>goto cleanup; <br>    } <br>break; <br> <br>case PT_LONG: <br>    psz = pszValueText; <br> <br>    while (isspace(*psz)) <br>psz++; <br> <br>    pszPrev = psz; <br>pProp-&gt;Value.l = strtol(psz, &amp;psz, 0); <br> <br>    while (isspace(*psz)) <br>psz++; <br> <br>    if (psz == pszPrev || *psz) <br>    { <br>hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>CFGCODE_ILLEGAL_LONG_VALUE,  <br>1, pszFullLine,  <br>0); <br>goto cleanup; <br>    } <br>break; <br> <br>case PT_STRING8: <br>{ <br>ULONG cb = strlen(pszValueText) + 1; <br> <br>hr = MAPIAllocateMore(cb, pBaseObject, &amp;pProp-&gt;Value.lpszA); <br>if (FAILED(hr)) <br>{ <br>hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>EDKEVENT_ERROR,  <br>0,  <br>1, ERROR_OUTOFMEMORY); <br>goto cleanup; <br>} <br>MoveMemory(pProp-&gt;Value.lpszA, pszValueText, cb); <br>break; <br>} <br> <br>case PT_SYSTIME: <br>{ <br>SYSTEMTIME st = {0}; <br>    CHAR chBogus = 0; <br>int lReturn = 0; <br>BOOL fItWorked = TRUE; <br> <br>lReturn = sscanf( <br>pszValueText,  <br>" %hd/%hd/%hd %hd:%hd:%hd %c",  <br>&amp;st.wYear,  <br>&amp;st.wMonth,  <br>&amp;st.wDay,  <br>&amp;st.wHour,  <br>&amp;st.wMinute,  <br>&amp;st.wSecond,  <br>&amp;chBogus); <br>if (lReturn == 0 || lReturn == EOF || chBogus) <br>{ <br>hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>CFGCODE_ILLEGAL_SYSTIME_VALUE,  <br>1, pszFullLine,  <br>0); <br>goto cleanup; <br>} <br> <br>fItWorked = SystemTimeToFileTime(&amp;st, &amp;pProp-&gt;Value.ft); <br>if (!fItWorked) <br>{ <br>hr = HR_LOG(E_FAIL); <br>EventLogMsg( <br>CFGCODE_CANNOT_CONVERT_TIME,  <br>1, pszFullLine,  <br>1, GetLastError()); <br>goto cleanup; <br>} <br> <br>break; <br>} <br> <br>default: <br>{ <br>TCHAR szPropType[9] = {0}; <br> <br>wsprintf(szPropType, TEXT("%08lx"), PROP_TYPE(ulPropTag)); <br> <br>hr = HR_LOG(E_NOTIMPL); <br>EventLogMsg( <br>CFGCODE_UNSUPPORTED_PROPERTY_TYPE,  <br>1, pszFullLine,  <br>0); <br>goto cleanup; <br>} <br>} <br> <br>pProp-&gt;ulPropTag = ulPropTag; <br> <br>cleanup: <br>RETURN(hr); <br>} <br> <br> <br> <br>//$--HrCreateBinaryDataFile----------------------------------------------------- <br>//  Create a file and write binary data to it. <br>// ----------------------------------------------------------------------------- <br>static HRESULT HrCreateBinaryDataFile(  // RETURNS: HRESULT <br>IN      LPTSTR                  pszOutputFile,  // name of file to create <br>IN      ULONG                   cbData,                 // number of bytes to write to file <br>IN      LPBYTE                  pbData)                 // binary data to write to file <br>{ <br>HRESULT                 hr                              = NOERROR; <br>HANDLE                  hOutputFile             = INVALID_HANDLE_VALUE; <br>BOOL                    fItWorked               = TRUE; <br>DWORD                   cbBytesWritten  = 0; <br> <br>DEBUGPRIVATE("HrCreateBinaryDataFile()\n"); <br> <br>hr = CHK_HrCreateBinaryDataFile( <br>pszOutputFile,  <br>cbData,  <br>pbData); <br>if (FAILED(hr)) <br>RETURN(hr); <br> <br>hOutputFile = CreateFile( <br>pszOutputFile,                                  // file name <br>GENERIC_WRITE,                                  // open for write <br>0,                                                              // no sharing <br>NULL,                                                   // default security <br>CREATE_ALWAYS,                                  // overwrite existing file <br>FILE_ATTRIBUTE_NORMAL,                  // normal file <br>NULL);                                                  // no template file <br>if (hOutputFile == INVALID_HANDLE_VALUE) <br>{ <br>EventLogMsg( <br>CFGCODE_COULD_NOT_CREATE_FILE,  <br>1, pszOutputFile,  <br>1, GetLastError()); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>fItWorked = WriteFile( <br>hOutputFile,                                    // file handle <br>pbData,                                                 // buffer to write <br>cbData,                                                 // number of bytes to write <br>&amp;cbBytesWritten,                                // number of bytes actually written <br>NULL);                                                  // no overlapped <br>if (!fItWorked || cbBytesWritten != cbData) <br>{ <br>EventLogMsg( <br>CFGCODE_COULD_NOT_WRITE_FILE,  <br>1, pszOutputFile,  <br>1, GetLastError()); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br> <br>fItWorked = CloseHandle(hOutputFile); <br>if (!fItWorked) <br>{ <br>EventLogMsg( <br>CFGCODE_COULD_NOT_CLOSE_FILE,  <br>1, pszOutputFile,  <br>1, GetLastError()); <br>hr = HR_LOG(E_FAIL); <br>goto cleanup; <br>} <br>hOutputFile = INVALID_HANDLE_VALUE; <br> <br>cleanup: <br>if (FAILED(hr) &amp;&amp; hOutputFile != INVALID_HANDLE_VALUE) <br>{ <br>CloseHandle(hOutputFile); <br>DeleteFile(pszOutputFile); <br>} <br> <br>RETURN(hr); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
