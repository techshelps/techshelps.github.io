<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DCHKMAIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1902"></a>DCHKMAIL.CPP</h2>
<pre><code>//--dchkmail.cpp-------------------------------------------------------------- <br>// <br>// implementation of the CCheckMailDlg class <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>//---------------------------------------------------------------------------- <br> <br> <br>#include "stdafx.h" <br>#include "mbxserv.h" <br> <br>#include "oditem.h"// COwnerDrawItem <br>#include "odlist.h"// COwnerDrawListBox <br>#include "dchkmail.h" <br>#include "dabout.h"// CAboutDlg <br> <br>#include "mbxdata.h" <br>#include "emsabtag.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>#define MAX_MESSAGE_HDRS    50   //Max. messages per query <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CCheckMailDlg dialog <br> <br>CCheckMailDlg::CCheckMailDlg(CWnd* pParent /*=NULL*/) <br>: CDialog(CCheckMailDlg::IDD, pParent) <br>{ <br>//{{AFX_DATA_INIT(CCheckMailDlg) <br>m_strAlias = _T(""); <br>m_strPassword = _T(""); <br>//}}AFX_DATA_INIT <br>// Note that LoadIcon does not require a subsequent DestroyIcon in Win32 <br>m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); <br>m_lpGAL = NULL; <br>m_lpSession = NULL; <br>m_lpMDB = NULL; <br>} <br> <br>void CCheckMailDlg::DoDataExchange(CDataExchange* pDX) <br>{ <br>CDialog::DoDataExchange(pDX); <br>//{{AFX_DATA_MAP(CCheckMailDlg) <br>DDX_Control(pDX, IDC_MAIL, m_lbMail); <br>DDX_Text(pDX, IDC_ALIAS, m_strAlias); <br>DDX_Text(pDX, IDC_PASSWORD, m_strPassword); <br>//}}AFX_DATA_MAP <br>} <br> <br>BEGIN_MESSAGE_MAP(CCheckMailDlg, CDialog) <br>//{{AFX_MSG_MAP(CCheckMailDlg) <br>ON_WM_SYSCOMMAND() <br>ON_BN_CLICKED(IDOK, OnGetMail) <br>ON_EN_CHANGE(IDC_ALIAS, OnChange) <br>ON_EN_CHANGE(IDC_PASSWORD, OnChange) <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CCheckMailDlg message handlers <br> <br>BOOL CCheckMailDlg::OnInitDialog() <br>{ <br>CDialog::OnInitDialog(); <br> <br>// Add "About..." menu item to system menu. <br> <br>// IDM_ABOUTBOX must be in the system command range. <br>ASSERTERROR((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX, <br>            "IDM_ABOUTBOX is out of range"); <br>    ASSERTERROR(IDM_ABOUTBOX &lt; 0xF000,"IDM_ABOUTBOX is out of range"); <br> <br>CMenu* pSysMenu = GetSystemMenu(FALSE); <br>CString strAboutMenu; <br>strAboutMenu.LoadString(IDS_ABOUTBOX); <br>if (!strAboutMenu.IsEmpty()) <br>{ <br>pSysMenu-&gt;AppendMenu(MF_SEPARATOR); <br>pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); <br>} <br> <br>// Set the icon for this dialog.  The framework does this automatically <br>//  when the application's main window is not a dialog <br>SetIcon(m_hIcon, TRUE);// Set big icon <br>SetIcon(m_hIcon, FALSE);// Set small icon <br> <br>    SetClassLong (m_hWnd, GCL_HICON, (LONG)m_hIcon); <br> <br>OnChange(); <br> <br>return TRUE;  // return TRUE  unless you set the focus to a control <br>} <br> <br>void CCheckMailDlg::OnSysCommand(UINT nID, LPARAM lParam) <br>{ <br>if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) <br>{ <br>CAboutDlg dlgAbout; <br>dlgAbout.DoModal(); <br>} <br>else <br>{ <br>CDialog::OnSysCommand(nID, lParam); <br>} <br>} <br> <br>void CCheckMailDlg::OnGetMail()  <br>{ <br>HRESULT hr; <br>ULONGulLoop; <br>LPSTRlpszMsgStoreDN= NULL; <br>LPSTRlpszMailboxDN= NULL; <br>SBinaryArray *lpbaExtData= NULL; <br> <br>LPMAPITABLElpGALTable= NULL; <br>LPMDBlpMailboxMDB= NULL; <br>LPSRowSetlpRowSet= NULL; <br>     <br>SRestrictionresNickname; <br>SPropValueprop; <br> <br>m_lbMail.ResetContent();// Clear listbox <br> <br>    UpdateData (TRUE); <br> <br>    ASSERTERROR (!m_strAlias.IsEmpty(), "Can't get mail with out an alias"); <br>ASSERTERROR (!m_strPassword.IsEmpty(), "Can't get mail with out a password"); <br> <br>    ASSERTERROR (m_lpGAL != NULL, "No pointer to the global address list"); <br> <br>static const SizedSPropTagArray(3, StoreAttributes) =  <br>{ <br>3, <br>{ <br>PR_EMAIL_ADDRESS,// lpszMsgStoreDN <br>PR_EMS_AB_HOME_MDB,// lpszMailboxDN <br>PR_EMS_AB_EXTENSION_DATA,     // extension data <br>} <br>}; <br> <br>    hr = m_lpGAL-&gt;GetContentsTable (MAPI_DEFERRED_ERRORS, &amp;lpGALTable); <br>     <br>    if (FAILED(hr)) <br>goto cleanup; <br> <br>resNickname.rt = RES_CONTENT; <br>resNickname.res.resContent.ulFuzzyLevel = FL_PREFIX;// FL_FULLSTRING == MAPI_E_TOO_COMPLEX  <br>resNickname.res.resContent.ulPropTag = PR_ACCOUNT; <br>resNickname.res.resContent.lpProp = &amp;prop; <br>prop.ulPropTag = PR_ACCOUNT; <br>prop.Value.lpszA = (LPSTR)(LPCSTR)m_strAlias; <br> <br>    hr = HrQueryAllRows ( <br>            lpGALTable, <br>            (LPSPropTagArray)&amp;StoreAttributes, <br>            &amp;resNickname, <br>            NULL, <br>            2, <br>            &amp;lpRowSet); <br> <br>    if (FAILED(hr)) <br>goto cleanup; <br> <br>if (lpRowSet-&gt;cRows != 1) <br>{ <br>AfxMessageBox ("Name not found or name is ambiguous."); <br>goto cleanup; <br>} <br> <br>ASSERTERROR (lpRowSet-&gt;cRows == 1, "Using ambiguous name"); <br> <br>// go find the values we need <br>for (ulLoop = 0;ulLoop &lt; lpRowSet-&gt;aRow[0].cValues; ulLoop++) <br>{ <br>switch (lpRowSet-&gt;aRow[0].lpProps[ulLoop].ulPropTag) <br>{ <br>case PR_EMS_AB_EXTENSION_DATA: <br>lpbaExtData = &amp;lpRowSet-&gt;aRow[0].lpProps[ulLoop].Value.MVbin; <br>break; <br>case PR_EMS_AB_HOME_MDB: <br>lpszMsgStoreDN = lpRowSet-&gt;aRow[0].lpProps[ulLoop].Value.lpszA; <br>break; <br>case PR_EMAIL_ADDRESS: <br>lpszMailboxDN = lpRowSet-&gt;aRow[0].lpProps[ulLoop].Value.lpszA; <br>break; <br>} <br>} <br> <br>if (lpbaExtData == NULL) <br>{ <br>AfxMessageBox ("Mailbox has not been configured"); <br>goto cleanup; <br>} <br> <br>if ((lpszMsgStoreDN == NULL) || (lpszMailboxDN == NULL)) <br>{ <br>AfxMessageBox ("Could not find message store information"); <br>goto cleanup; <br>} <br> <br>hr = HrCheckPassword (lpbaExtData, m_strPassword); <br> <br>    if (FAILED(hr)) <br>goto cleanup; <br> <br>    hr = HrMailboxLogon (m_lpSession, m_lpMDB, lpszMsgStoreDN, lpszMailboxDN,  <br>            &amp;lpMailboxMDB); <br> <br>    if (FAILED(hr)) <br>goto cleanup; <br> <br>    hr = HrDispMailboxSubjects (lpMailboxMDB); <br> <br>    if (FAILED(hr)) <br>        goto cleanup; <br> <br>cleanup: <br>    if (lpMailboxMDB) <br>        hr = HrMailboxLogoff (&amp;lpMailboxMDB); <br>     <br>    ULRELEASE(lpGALTable); <br>    ULRELEASE(lpMailboxMDB); <br>MAPIFREEBUFFER(lpRowSet); <br>} <br> <br>void CCheckMailDlg::OnChange()  <br>{ <br>// Enable Get Mail button only when we have an alias and password <br> <br>UpdateData (TRUE); <br> <br>CWnd * pWnd = GetDlgItem (IDOK); <br>ASSERTERROR (pWnd != NULL, "Could not find OK button"); <br> <br>if (m_strAlias.IsEmpty() || m_strPassword.IsEmpty()) <br>{ <br>pWnd-&gt;EnableWindow (FALSE); <br>} <br>else <br>{ <br>pWnd-&gt;EnableWindow (TRUE); <br>} <br>} <br> <br>HRESULT CCheckMailDlg::HrDispMailboxSubjects(LPMDB  lpMDB) <br>{ <br>    HRESULT         hr                  = NOERROR; <br>    unsigned        iMsgIndx            = 0; <br>    unsigned        nCnt                = 0; <br>    ULONG           cbeid               = 0L; <br>    ULONG           ulObjType           = 0L; <br>    LPENTRYID       lpeid               = NULL; <br>    LPMAPIFOLDER    lpInboxFolder       = NULL;     // ptr to Inbox folder <br>    LPMAPITABLE     lpContentsTbl       = NULL;     // ptr to Contents folder table <br>    LPSRowSet       lpInRowSet          = NULL;     // ptr to Inbox rows <br>    LPSPropValue    lpProps             = NULL;     // Ptr to property array. <br> <br>    static const SizedSSortOrderSet(1L,sSortPrioSet) =  <br>        { 1L, 0L, 0L, { PR_CLIENT_SUBMIT_TIME, TABLE_SORT_ASCEND}}; <br> <br>    static const SizedSPropTagArray(3L,sPropColumns) = <br>        { 3L, {PR_SUBJECT, PR_MESSAGE_FLAGS, PR_ENTRYID}}; <br> <br>    DEBUGPRIVATE( "HrDispMailboxSubjects()"); <br> <br>    if (lpMDB == NULL) <br>        return E_INVALIDARG; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Initialize an inbox folder object. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Find default (inbox) folder. <br>    hr = HrMAPIFindInbox( lpMDB, &amp;cbeid, &amp;lpeid); <br>    if( FAILED(hr)) <br>        goto cleanup; <br>    ASSERTERROR ( lpeid != NULL, "NULL lpeid"); <br>     <br>    // Open the default (inbox) folder. <br>    hr = lpMDB-&gt;OpenEntry(cbeid, lpeid, NULL, <br>MAPI_MODIFY|MAPI_DEFERRED_ERRORS, &amp;ulObjType, (LPUNKNOWN*)&amp;lpInboxFolder); <br>    if( FAILED( hr)) <br>        goto cleanup; <br>    if( ulObjType != MAPI_FOLDER) <br>    { <br>        hr = HR_LOG( E_FAIL); <br>        goto cleanup; <br>    } <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Now that we have a folder we can initialize a contents table <br>// to look through. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br> <br>    // Get the contents table for the folder. <br>    hr = lpInboxFolder-&gt;GetContentsTable( <br>MAPI_DEFERRED_ERRORS, &amp;lpContentsTbl); <br>    if( FAILED( hr)) <br>        goto cleanup; <br> <br>    // Set the columns to return. <br>    hr = lpContentsTbl-&gt;SetColumns((LPSPropTagArray) &amp;sPropColumns, 0L); <br>    if(FAILED(hr)) <br>        goto cleanup; <br> <br>    // Sort the table. <br>    hr = lpContentsTbl-&gt;SortTable((LPSSortOrderSet) &amp;sSortPrioSet, 0L); <br>    if(FAILED(hr)) <br>        goto cleanup; <br>     <br>    // Position to the beginning of the contents table. <br>    hr = lpContentsTbl-&gt;SeekRow(BOOKMARK_BEGINNING, 0, NULL); <br>    if( FAILED(hr)) <br>        goto cleanup; <br> <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>// Contents table has been initialize so lets display it. <br>// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - <br>     <br>    // Display INBOX subjects until end of table reached. <br>    while (TRUE) <br>    {   // Read a group of message headers from the contents table. <br>        hr = HrGetMsgList( lpContentsTbl, MAX_MESSAGE_HDRS, &amp;lpInRowSet); <br>        if (hr == MAPI_E_NOT_FOUND) <br>            break; <br> <br>        if (FAILED( hr)) <br>            goto cleanup;; <br>             <br>        ASSERTERROR( lpInRowSet != NULL, "NULL lpInRowSet!"); <br>         <br>        // Process all messages in the current table. <br>        for (iMsgIndx = 0; iMsgIndx &lt; lpInRowSet-&gt;cRows; ++iMsgIndx ) <br>        {   // Display the subject name. <br>            lpProps = lpInRowSet-&gt;aRow[iMsgIndx].lpProps; <br> <br>            ASSERTERROR(PROP_ID(lpProps-&gt;ulPropTag) == PROP_ID(PR_SUBJECT), <br>                        "Invalid property returned!"); <br> <br>CString strSubject; <br>if (lpProps-&gt;Value.LPSZ == NULL || *(lpProps-&gt;Value.LPSZ) == 0) <br>{ <br>strSubject = "  SUBJECT: (empty)."; <br>} <br>            else <br>{ <br>strSubject = lpProps-&gt;Value.LPSZ; <br>} <br> <br>COwnerDrawItem * pODI = new COwnerDrawItem(); <br>if (lpProps[1].Value.l &amp; MSGFLAG_READ) <br>{ <br>pODI-&gt;Create (NULL, strSubject); <br>} <br>else <br>{ <br>pODI-&gt;Create (NULL, strSubject,ODI_BOLDTEXT); <br>} <br> <br>m_lbMail.AddODI(pODI); <br>nCnt ++; <br>        } <br>  <br>// Free the current message list structure. <br>        FREEPROWS( lpInRowSet); <br>    } <br> <br>if (nCnt == 0) <br>{ <br>COwnerDrawItem * pODI = new COwnerDrawItem(); <br>pODI-&gt;Create (NULL, "No messages found"); <br>m_lbMail.AddODI(pODI); <br>} <br> <br>cleanup: <br>return S_OK; <br>} <br> <br>HRESULT CCheckMailDlg::HrGetMsgList( <br>    LPMAPITABLE lpTable,    // ptr.to the contents table <br>    LONG       cMaxNRows,  // Max.# of rows to return <br>    LPSRowSet   *lppRows )  // ptr.to address variable for SRowSet <br>{ <br>    HRESULT      hr  = NOERROR; <br> <br>    if ((lpTable == NULL) || <br>        (lppRows == NULL)) <br>    { <br>        return E_INVALIDARG; <br>    } <br> <br>    DEBUGPRIVATE( "HrGetMsgList()" ); <br> <br>    // Get the next list of messages in the folder <br>    hr = lpTable-&gt;QueryRows(cMaxNRows, 0L, lppRows ); <br>    if( SUCCEEDED(hr) &amp;&amp; ((*lppRows) != NULL) &amp;&amp; ((*lppRows)-&gt;cRows == 0)) <br>    { <br>        FREEPROWS(*lppRows); <br>        hr = MAPI_E_NOT_FOUND; <br>    } <br> <br>    return hr; <br>} <br> <br>HRESULT CCheckMailDlg::HrCheckPassword (SBinaryArray * lpbaExtData, LPCTSTR szPassword) <br>{ <br>HRESULT hr = E_FAIL; <br> <br>    if ((lpbaExtData == NULL) || <br>        (szPassword == NULL)) <br>    { <br>        return E_INVALIDARG; <br>    } <br>// For each blob returned <br>for (ULONG ulLoop = 0; ulLoop &lt; lpbaExtData-&gt;cValues; ulLoop++) <br>{ <br>// Find our blob (the name is the first thing; UNICODE) <br>if (wcsicmp (MBXBLOBNAMEW, (LPWSTR)lpbaExtData-&gt;lpbin[ulLoop].lpb) == 0) <br>{ <br>LPSPropValue pvData = NULL; <br>ULONG ulData; <br> <br>hr = HrCfgUnpackData ( <br>lpbaExtData-&gt;lpbin[ulLoop].cb, <br>lpbaExtData-&gt;lpbin[ulLoop].lpb, NULL, &amp;ulData, &amp;pvData); <br> <br>if (FAILED (hr)) <br>return hr; <br> <br>ASSERTERROR (ulData == 1, "Extension data in unknown format"); <br> <br>if (lstrcmp (szPassword, pvData[0].Value.lpszA) == 0) <br>{ <br>hr = S_OK; <br>} <br>else <br>{ <br>AfxMessageBox ("Invalid Password"); <br>hr = E_FAIL; <br>} <br>MAPIFREEBUFFER (pvData); <br>} <br>} <br>return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
