<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RESTTEST.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1765"></a>RESTTEST.CPP</h2>
<pre><code>// --resttest.cpp--------------------------------------------------------------- <br>// <br>//  Backup restore sample. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br> <br>#include "edk.h" <br>#include &lt;edbback.h&gt; <br>#include &lt;edbbcli.h&gt; <br>#include &lt;time.h&gt; <br>#include "backtest.h" <br> <br>DWORD <br>cbReadSize = 0x10000; <br> <br>CHAR <br>rgchComputerName[ MAX_COMPUTERNAME_LENGTH ]; <br> <br>ERR <br>ErrRestoreFile( <br>HANDLE hBackup, <br>EDB_RSTMAP *rgrstmap, <br>I *irgRestMap, <br>SZ szDatabaseLocationList, <br>SZ *pszBackupLogDirectory = NULL, <br>    PBOOL pfSetGen = NULL, <br>PDWORD gen = NULL <br>); <br> <br> <br>ERR <br>ErrReadStructure( <br>HANDLE hFile, <br>VOID *pvStruct, <br>CB cbStruct <br>) <br>{ <br>CB cbRead = 0; <br> <br>if (!ReadFile(hFile, pvStruct, cbStruct, (PDWORD)&amp;cbRead, NULL)) <br>{ <br>printf("Unable to read log headers from backup file %d\n", GetLastError()); <br>return(GetLastError()); <br>} <br> <br>if (cbRead != cbStruct) <br>{ <br>printf("Unable to read all of log header from backup file\n"); <br>return(1); <br>} <br>return(ERROR_SUCCESS); <br>} <br> <br>ERR <br>ErrReadHeader( <br>HANDLE hFile, <br>PBackupHeader bh <br>) <br>{ <br>ERR err = 0; <br>if (err = ErrReadStructure(hFile, bh, sizeof(BackupHeader))) <br>{ <br>printf("Unable to read log headers from backup file: %d\n", err); <br>return(err); <br>} <br> <br>if (bh-&gt;ulSignature != BACKUP_SIGNATURE) <br>{ <br>printf("Log signature does not match, backup is probably corrupt\n"); <br>return(1); <br>} <br>return(ERROR_SUCCESS); <br>} <br> <br>ERR <br>ErrReadHeader( <br>HANDLE hFile, <br>PBackupFile bf <br>) <br>{ <br>ERR err = 0; <br>if (err = ErrReadStructure(hFile, bf, sizeof(BackupFile))) <br>{ <br>printf("Unable to read log headers from backup file: %d\n", err); <br>return(err); <br>} <br> <br>if (bf-&gt;ulFileSignature != FILE_SIGNATURE) <br>{ <br>printf("Log signature does not match, backup is probably corrupt\n"); <br>return(1); <br>} <br>return(ERROR_SUCCESS); <br>} <br> <br>ERR <br>ErrReadHeader( <br>HANDLE hFile, <br>PLogHeader lh <br>) <br>{ <br>ERR err = 0; <br>if (err = ErrReadStructure(hFile, lh, sizeof(LogHeader))) <br>{ <br>printf("Unable to read log headers from backup file: %d\n", err); <br>return(err); <br>} <br> <br>if (lh-&gt;ulLogSignature != LOG_SIGNATURE) <br>{ <br>printf("Log signature does not match, backup is probably corrupt\n"); <br>return(1); <br>} <br>return(ERROR_SUCCESS); <br>} <br> <br>SZ <br>SzFindBFT( <br>SZ szDatabaseLocationList, <br>BFT bft <br>) <br>{ <br>SZszDatabaseLocation = szDatabaseLocationList; <br> <br>while (*szDatabaseLocation) <br>{ <br>BFT bftLocation = *szDatabaseLocation++; <br> <br>if (bftLocation == bft) <br>{ <br>return szDatabaseLocation; <br>break; <br>} <br> <br>szDatabaseLocation += strlen(szDatabaseLocation)+1; <br>} <br> <br>return NULL; <br>} <br> <br>ERR <br>ErrRestoreFile( <br>HANDLE hBackup, <br>EDB_RSTMAP *prstmap, <br>I *pirgrstmap, <br>SZ szDatabaseLocationList, <br>SZ *pszBackupLogDirectory, <br>    PBOOL pfSetGen, <br>PDWORD gen <br>) <br>{ <br>ERR err = 0; <br>BackupFile bf = {0}; <br>SZ szNewFileName = NULL; <br>HANDLE hRestoreFile = NULL; <br>CB cbRead = 0; <br>BFT bftFile = 0; <br>SZ szFileName = NULL; <br>PVOID pvBuffer = NULL; <br>char rgchDrive[_MAX_DRIVE] = {0}; <br>char rgchDir[_MAX_DIR] = {0}; <br>char rgchFileName[_MAX_FNAME] = {0}; <br>char rgchExtension[_MAX_EXT] = {0}; <br>LARGE_INTEGER liBytesRemaining = {0}; <br>DWORD cbToRead = 0; <br> <br>// <br>//Read the backup header for the file. <br>// <br> <br>    if (pfSetGen) <br>        *pfSetGen = fFalse; <br> <br>err = ErrReadHeader(hBackup, &amp;bf); <br> <br>szFileName = new char[bf.cbFileNameLength]; <br> <br>if (szFileName == NULL) <br>{ <br>printf("Error allocating space for database name\n"); <br>err = ERROR_NOT_ENOUGH_MEMORY; <br>        goto cleanup; <br>} <br> <br>if (!ReadFile(hBackup, szFileName, bf.cbFileNameLength, (PDWORD)&amp;cbRead, NULL)) <br>{ <br>printf("Unable to read file name from backup file: %d\n", GetLastError()); <br>err = GetLastError(); <br>        goto cleanup; <br>} <br> <br>// <br>//Save away the backup file type of this file. <br>// <br> <br>bftFile = bf.bft; <br> <br>// <br>//Crack the incoming database name to determine the file name. <br>// <br> <br>_splitpath(szFileName, rgchDrive, rgchDir, rgchFileName, rgchExtension); <br> <br>if (gen != NULL) <br>{ <br>// <br>//We want to find out the generation of this file if it's a log file. <br>// <br> <br>if (strnicmp(rgchFileName, "EDB", 3) == 0) <br>{ <br>if (stricmp(rgchExtension, ".LOG") == 0) <br>{ <br>// <br>//log file generations are hex digits. <br>// <br> <br>*gen = strtoul(&amp;rgchFileName[3], NULL, 16); <br>                if (pfSetGen) <br>                    *pfSetGen = fTrue; <br> <br>// <br>//If we want to find out the log directory, return it. <br>// <br> <br>if (pszBackupLogDirectory != NULL) <br>{ <br>if (rgchDir[strlen(rgchDir)-1] == '\\') <br>{ <br>rgchDir[strlen(rgchDir)-1] = '\0'; <br>} <br> <br>// <br>//Save away the backup log directory if needed. <br>// <br> <br>*pszBackupLogDirectory = strdup(rgchDir); <br>} <br> <br>} <br>} <br>} <br> <br>// <br>//Ok, now find out where we are goingto put this file. <br>// <br> <br> <br>// <br>//First scan for an exact match on BFT. <br>// <br> <br>szNewFileName = SzFindBFT(szDatabaseLocationList, bftFile); <br> <br>if (szNewFileName == NULL) <br>{ <br>// <br>//Ok, we didn't find it exactly, let's try to find it's directory. <br>// <br> <br>if (bftFile &amp; BFT_LOG_DIRECTORY) <br>{ <br>SZ szLogDir = NULL; <br> <br>// <br>//This guy goes into the log directory.  Find out where that is. <br>// <br> <br>szLogDir = SzFindBFT(szDatabaseLocationList, BFT_LOG_DIR); <br> <br>if (szLogDir == NULL) <br>{ <br>printf("Could not find log directory"); <br>err = ERROR_FILE_NOT_FOUND; <br>                goto cleanup; <br>} <br> <br>szNewFileName = new char[strlen(szLogDir)+1+strlen(rgchFileName)+strlen(rgchExtension)+2]; <br>strcpy(szNewFileName, szLogDir); <br>strcat(szNewFileName, "\\"); <br>strcat(szNewFileName, rgchFileName); <br>strcat(szNewFileName, rgchExtension); <br>} <br>else if (bftFile &amp; BFT_DATABASE_DIRECTORY) <br>{ <br>printf("Don't support inexact match in datbase directory yet"); <br>err = ERROR_FILE_NOT_FOUND; <br>} <br>} <br> <br>// <br>//If this goes into the database directory, it needs to go into the RSTMAP. <br>// <br> <br>if (bftFile &amp; BFT_DATABASE_DIRECTORY) <br>{ <br>prstmap[*pirgrstmap].szDatabaseName = szFileName; <br>prstmap[*pirgrstmap].szNewDatabaseName = strdup(szNewFileName); <br>*pirgrstmap+=1; <br>} <br> <br>// <br>//If the munged name in the database is on our current machine, then unmunge the name for efficency. <br>// <br> <br>if (szNewFileName[0] == '\\' &amp;&amp; szNewFileName[1] == '\\') <br>{ <br>// <br>//Ok, this is a munged file name. <br>// <br>SZ szBackslash = strchr(&amp;szNewFileName[2], '\\'); <br> <br>if (szBackslash != NULL) <br>{ <br>if (_strnicmp(&amp;szNewFileName[2], rgchComputerName, szBackslash-&amp;szNewFileName[2]) == 0) <br>{ <br>// <br>//Ok, the current computer name matches the munged name, we want to munge the <br>//  destination file specified to match the local name. <br>// <br> <br>szNewFileName = _strdup(szBackslash+1); <br> <br>if (szNewFileName[1] == '$') <br>{ <br>szNewFileName[1] = ':'; <br>} <br>} <br>} <br>} <br> <br>hRestoreFile = CreateFile(szNewFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, <br>FILE_FLAG_SEQUENTIAL_SCAN, NULL); <br> <br>if (hRestoreFile == INVALID_HANDLE_VALUE) <br>{ <br>err = GetLastError(); <br> <br>if (ERROR_SHARING_VIOLATION==err) <br>{ <br>printf("Unable to open %s. Make sure the Store service has been " <br>"stopped before restoring.\n", szNewFileName, GetLastError()); <br>} <br>else <br>{ <br>printf("Unable to open file %s for restore: %d\n", szNewFileName, err); <br>} <br>goto cleanup; <br>} <br> <br>liBytesRemaining = bf.liFileSize; <br> <br>pvBuffer = (void *)new char[cbReadSize]; <br> <br>if (pvBuffer == NULL) <br>{ <br>printf("Unable to allocate buffer for file restore.\n"); <br>err = 1; <br>        goto cleanup; <br>} <br> <br>cbToRead = cbReadSize; <br> <br>while (liBytesRemaining.QuadPart != 0) <br>{ <br>DWORD cbRead = 0; <br>DWORD cbWritten = 0; <br> <br>if (liBytesRemaining.QuadPart &lt; cbReadSize) <br>{ <br>cbToRead = liBytesRemaining.LowPart; <br>} <br> <br>if (!ReadFile(hBackup, pvBuffer, cbToRead, &amp;cbRead, NULL)) <br>{ <br>printf("Unable to read from restore file: %d\n", GetLastError()); <br>err = GetLastError(); <br>            goto cleanup; <br>} <br> <br>if (cbRead != cbToRead) <br>{ <br>printf("Unable to read from restore file: %d\n", GetLastError()); <br>err = GetLastError(); <br>            goto cleanup; <br>} <br> <br>if (!WriteFile(hRestoreFile, pvBuffer, cbRead, &amp;cbWritten, NULL)) <br>{ <br>printf("Unable to write to restored file: %d\n", GetLastError()); <br>err = GetLastError(); <br>            goto cleanup; <br>} <br> <br>if (cbRead != cbWritten) <br>{ <br>printf("Unable to write to restored file: %d\n", GetLastError()); <br>err = GetLastError(); <br>            goto cleanup; <br>} <br> <br>liBytesRemaining.QuadPart -= cbRead; <br>} <br> <br>CloseHandle(hRestoreFile); <br> <br>err = ERROR_SUCCESS; <br> <br>cleanup: <br>    if (pvBuffer) <br>    { <br>    delete pvBuffer; <br>    } <br> <br>    return(err); <br>} <br> <br>int <br>_cdecl <br>main (int cArg, char *rgszArgv[]) <br>{ <br>I irgsz = 0; <br>BOOL fDsa = fFalse; <br>BOOL fMdb = fFalse; <br> <br>SZ szBackupFile = DEF_BACKUP_FILE; <br>SZ szBackupServer = NULL; <br>HANDLE hBackupFile = NULL; <br>DWORD cbComputerName = sizeof(rgchComputerName); <br>SZ szDatabaseLocationList = NULL; <br>DWORD cbLocationList = 0; <br> <br>    BOOL fInvalidArg = fFalse; <br> <br>if (!GetComputerName(rgchComputerName, &amp;cbComputerName)) <br>{ <br>printf("Unable to query computer name: %d\n", GetLastError()); <br>return(GetLastError()); <br>} <br> <br>for (irgsz = 1; irgsz &lt; cArg ; irgsz += 1) <br>{ <br>if (rgszArgv[irgsz][0] == '-' || rgszArgv[irgsz][0]=='/' ) <br>{ <br>if (toupper(rgszArgv[irgsz][1]) == 'B') <br>{ <br>szBackupFile = (rgszArgv[irgsz][2] == ':' ? &amp;rgszArgv[irgsz][3] : rgszArgv[++irgsz]); <br>} <br>else if (toupper(rgszArgv[irgsz][1]) == 'S') <br>{ <br>szBackupServer = (rgszArgv[irgsz][2] == ':' ? &amp;rgszArgv[irgsz][3] : rgszArgv[++irgsz]); <br>} <br>else <br>{ <br>                fInvalidArg = fTrue; <br>                break; <br>} <br>} <br>} <br> <br>    if (fInvalidArg || cArg &lt;= 1) <br>{ <br>printf("\nUsage: RestTest\t -S:&lt;Server&gt;\n\t\t -B:&lt;Backup File&gt;\n"); <br>        return(0); <br>} <br> <br>if (szBackupServer == NULL) <br>{ <br>szBackupServer = rgchComputerName; <br>} <br> <br>// <br>//Open up the backup file for write access. <br>// <br> <br>hBackupFile = CreateFile(szBackupFile, <br>GENERIC_READ, <br>0, <br>NULL, <br>OPEN_EXISTING, <br>FILE_FLAG_SEQUENTIAL_SCAN, <br>NULL <br>); <br>if (hBackupFile == INVALID_HANDLE_VALUE) <br>{ <br>printf("Unable to open backup file %s: %d\n", szBackupFile, GetLastError()); <br>return(GetLastError()); <br>} <br> <br>BackupHeader bh = {0}; <br>CB cbRead = 0; <br> <br>ERR err = 0; <br> <br>err = ErrReadHeader(hBackupFile, &amp;bh); <br> <br>if (err != ERROR_SUCCESS) <br>{ <br>return(err); <br>} <br> <br>SZ szRestoreAnnotation = NULL; <br>szRestoreAnnotation = new char[bh.cbDatabaseNameLength]; <br> <br>if (szRestoreAnnotation == NULL) <br>{ <br>printf("Out of memory error\n"); <br>return(1); <br>} <br>if (!ReadFile(hBackupFile, szRestoreAnnotation, bh.cbDatabaseNameLength, (PDWORD)&amp;cbRead, NULL)) <br>{ <br>printf("Unable to read from backup file %s: %d\n", szBackupFile, GetLastError()); <br>return(GetLastError()); <br>} <br> <br>if (cbRead != bh.cbDatabaseNameLength) <br>{ <br>printf("Unable to read all of database name from backup file %s\n", szBackupFile); <br>return(GetLastError()); <br>} <br> <br>if (strlen(szRestoreAnnotation) != (ULONG)bh.cbDatabaseNameLength-1) <br>{ <br>printf("Database name %s corrupted in backup file %s\n", szRestoreAnnotation, szBackupFile); <br>return(GetLastError()); <br>} <br> <br>printf("Now performing component specific restoration\n"); <br> <br>HBC hbc = NULL; <br> <br>    err = HrRestorePrepare(szBackupServer, szRestoreAnnotation, &amp;hbc); <br> <br>if (err != ERROR_SUCCESS) <br>{ <br>printf("Unable to connect to restore provider on server %s\n", szBackupServer); <br>return(err); <br>} <br> <br>err = HrRestoreGetDatabaseLocations( <br>hbc, <br>&amp;szDatabaseLocationList, <br>&amp;cbLocationList); <br> <br>if (err != ERROR_SUCCESS) <br>{ <br>printf("Unable to query database locations on %s\n", szBackupServer); <br>return(err); <br>} <br> <br> <br>C cRemainingBackupFiles = bh.cBackupFiles; <br> <br>// <br>//Skip past the files to the log headers. <br>// <br> <br>while (cRemainingBackupFiles--) <br>{ <br>BackupFile bf = {0}; <br> <br>err = ErrReadHeader(hBackupFile, &amp;bf); <br> <br>if (err != ERROR_SUCCESS) <br>{ <br>return(err); <br>} <br>LARGE_INTEGER liMoveDelta = {0}; <br> <br>liMoveDelta = bf.liFileSize; <br> <br>liMoveDelta.QuadPart += bf.cbFileNameLength; <br> <br>if (!SetFilePointer(hBackupFile, liMoveDelta.LowPart, &amp;liMoveDelta.HighPart, FILE_CURRENT)) { <br>printf("Unable to set file pointer past file.\n"); <br>return(1); <br>} <br>} <br> <br>LogHeader lh = {0}; <br> <br>err = ErrReadHeader(hBackupFile, &amp;lh); <br> <br>if (err != ERROR_SUCCESS) <br>{ <br>return(err); <br>} <br>// <br>//We now know the total number of logs to back up. <br>// <br> <br>C cBackupFiles = lh.cLogFiles + bh.cBackupFiles; <br> <br> <br>printf("Restoring %s database\n", szRestoreAnnotation); <br> <br>if (!SetFilePointer(hBackupFile, sizeof(BackupHeader)+bh.cbDatabaseNameLength, NULL, FILE_BEGIN)) { <br>printf("Unable to reset database pointer to start of database.\n"); <br>return(1); <br>} <br> <br>I irgRestMap = 0; <br>EDB_RSTMAP *rgRestMap=NULL; <br> <br> <br>// <br>//If cRemainingBackupFiles == 0 then we are doing an  <br>//- incremental restore <br>// <br>cRemainingBackupFiles = bh.cBackupFiles; <br>if (cRemainingBackupFiles) <br>{ <br>rgRestMap = new EDB_RSTMAP[cBackupFiles]; <br>if (rgRestMap == NULL) <br>{ <br>printf("Error allocating memory for restore map\n"); <br>return(1); <br>} <br>} <br> <br>// <br>//Now copy the restore database. <br>// <br> <br>while (cRemainingBackupFiles--) <br>{ <br>ERR err = ErrRestoreFile(hBackupFile, rgRestMap, &amp;irgRestMap, szDatabaseLocationList); <br>if (err != ERROR_SUCCESS) <br>{ <br>printf("Unable to restore file.\n"); <br>return(err); <br>} <br>} <br> <br>// <br>//Now read the log header again. <br>// <br>err = ErrReadHeader(hBackupFile, &amp;lh); <br> <br>cRemainingBackupFiles = lh.cLogFiles; <br> <br>DWORD genLow = 0xffffffffL; <br>DWORD genHigh = 0; <br> <br>SZ szBackupLogPath = NULL; <br> <br>while (cRemainingBackupFiles--) <br>{ <br>DWORD gen = 0; <br>        BOOL fSetGen = fFalse; <br> <br>ERR err = ErrRestoreFile( <br>            hBackupFile,  <br>            rgRestMap,  <br>            &amp;irgRestMap,  <br>            szDatabaseLocationList,  <br>            &amp;szBackupLogPath,  <br>            &amp;fSetGen,  <br>            &amp;gen); <br>if (err != ERROR_SUCCESS) <br>{ <br>printf("Unable to restore file.\n"); <br>return(err); <br>} <br>        if (fSetGen) <br>        { <br>    if (gen &lt; genLow) <br>    { <br>    genLow = gen; <br>    } <br> <br>    if (gen &gt; genHigh) <br>    { <br>    genHigh = gen; <br>    } <br>        } <br>} <br> <br>printf("Databases successfully restored\n"); <br> <br>SZ szLogPath = NULL; <br> <br>SZ szCheckpointDir = NULL; <br> <br>// <br>//Now find out where the database locations go. <br>// <br> <br>SZ szDatabaseLocation = szDatabaseLocationList; <br> <br>while (*szDatabaseLocation) <br>{ <br>BFT bftLocation = *szDatabaseLocation++; <br>if (bftLocation == BFT_LOG_DIR) <br>{ <br>szLogPath = szDatabaseLocation; <br>} <br>else if (bftLocation == BFT_CHECKPOINT_DIR) <br>{ <br>szCheckpointDir = szDatabaseLocation; <br>} <br>else <br> <br>szDatabaseLocation += strlen(szDatabaseLocation)+1; <br>} <br> <br>err = HrRestoreRegister(hbc, szCheckpointDir, szLogPath, rgRestMap, irgRestMap, szBackupLogPath, genLow, genHigh); <br> <br>if (err != ERROR_SUCCESS) <br>{ <br>    (void) HrRestoreRegisterComplete(hbc, err); <br>    (void) HrRestoreEnd(hbc); <br>printf("Unable to perform restore %d\n", err); <br>return(err); <br>} <br> <br>(void) HrRestoreRegisterComplete(hbc, hrNone); <br> <br>err = HrRestoreEnd(hbc); <br> <br>if (err != ERROR_SUCCESS) <br>{ <br>printf("Unable to complete restore: %d\n", err); <br>return(err); <br>} <br> <br>return(0); <br> <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
