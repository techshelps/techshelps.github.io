<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BACKTEST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1763"></a>BACKTEST.C</h2>
<pre><code>// --backtest.c----------------------------------------------------------------- <br>// <br>//  Backup sample. <br>// <br>// Copyright (C) Microsoft Corp. 1986-1996.  All Rights Reserved. <br>// ----------------------------------------------------------------------------- <br>//kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib edbbcli.lib  <br>#include "edk.h" <br>#include &lt;edbback.h&gt; <br>#include &lt;edbbcli.h&gt; <br>#include &lt;time.h&gt; <br>#include "backtest.h" <br> <br>#define MIN_READ_HINT_SIZE 8193 <br> <br>DWORD <br>g_cbReadHintSize= 65536; <br> <br>BOOL <br>g_fRandomReads= fFalse; <br> <br>SZ <br>SzFromHr( <br>HRESULT hr <br>) <br>{ <br>SZ szReturn = NULL; <br>HMODULE hmoduleEdb = NULL; <br> <br>hmoduleEdb = LoadLibrary(TEXT("edbbcli.dll")); <br> <br>if (hmoduleEdb == NULL) <br>{ <br>return ""; <br>} <br> <br>if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, <br>hmoduleEdb, <br>hr, <br>GetUserDefaultLangID(), <br>(CHAR *)&amp;szReturn, <br>0, <br>NULL) == 0) <br>{ <br>if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, <br>NULL, <br>hr, <br>GetUserDefaultLangID(), <br>(CHAR *)&amp;szReturn, <br>0, <br>NULL) == 0) <br>return "Unknown"; <br>} <br> <br>return szReturn; <br>} <br> <br>unsigned long <br>msfrompc( <br>LARGE_INTEGER lipcDuration <br>) <br>{ <br>LARGE_INTEGER lipcFrequency = {0};// Ticks/second. <br> <br>if (!QueryPerformanceFrequency(&amp;lipcFrequency)) { <br>return(0); <br>} <br> <br>lipcFrequency.QuadPart /= 1000;// Convert to ticks/millisecond <br> <br>return(unsigned long)(lipcDuration.QuadPart / lipcFrequency.QuadPart); <br>} <br> <br>EC <br>EcBackupFile( <br>HBC hbcBackupContext, <br>SZ szFile, <br>HANDLE hBackupFile <br>) <br>{ <br>LARGE_INTEGER liFileSize = {0}; <br>LARGE_INTEGER liBytesRead = {0}; <br>LARGE_INTEGER lipcStart = {0}; <br>LARGE_INTEGER lipcEnd = {0}; <br>LARGE_INTEGER lipcDuration = {0}; <br>CB cbRead = 0; <br>HRESULT hrStatus = NOERROR; <br>BackupFile bf = {0}; <br>CB cbWritten = 0; <br>BFT bft = 0; <br> <br>VOID *pvBuffer = malloc(g_cbReadHintSize); <br> <br>if (pvBuffer == NULL) <br>{ <br>return(hrError); <br>} <br> <br>printf("Back up %s\n", szFile); <br> <br>liBytesRead.QuadPart = 0; <br> <br>// <br>//Open the remote database. <br>// <br> <br>if (!QueryPerformanceCounter(&amp;lipcStart)) <br>{ <br>printf("Unable to query performance counter: %d\n", GetLastError()); <br>} <br> <br>// <br>//Open the remote database. <br>// <br> <br>bft = *szFile++; <br> <br>hrStatus = HrBackupOpenFile(hbcBackupContext, szFile, <br>g_cbReadHintSize, &amp;liFileSize); <br> <br>if (hrStatus != ERROR_SUCCESS) { <br>printf("Open failed:%s %d\n", szFile, hrStatus); <br>free(pvBuffer); <br>HrBackupClose(hbcBackupContext); <br>return hrStatus; <br>} <br> <br>bf.ulFileSignature = FILE_SIGNATURE; <br>bf.liFileSize = liFileSize; <br>bf.cbFileNameLength = strlen(szFile)+1; <br>bf.bft = bft; <br> <br>if (hBackupFile) <br>{ <br>if (!WriteFile(hBackupFile, &amp;bf, sizeof(bf), &amp;cbWritten, NULL)) <br>{ <br>hrStatus = GetLastError(); <br>free(pvBuffer); <br>HrBackupClose(hbcBackupContext); <br>return(hrStatus); <br>} <br> <br>if (cbWritten != sizeof(bf)) <br>{ <br>hrStatus = ERROR_HANDLE_DISK_FULL; <br>free(pvBuffer); <br>HrBackupClose(hbcBackupContext); <br>return(hrStatus); <br>} <br> <br>if (!WriteFile(hBackupFile, szFile, bf.cbFileNameLength, &amp;cbWritten, NULL)) <br>{ <br>hrStatus = GetLastError(); <br>free(pvBuffer); <br>HrBackupClose(hbcBackupContext); <br>return(hrStatus); <br>} <br> <br>if (cbWritten != bf.cbFileNameLength) <br>{ <br>hrStatus = ERROR_HANDLE_DISK_FULL; <br>free(pvBuffer); <br>HrBackupClose(hbcBackupContext); <br>return(hrStatus); <br>} <br>} <br> <br>if (!QueryPerformanceCounter(&amp;lipcEnd)) <br>{ <br>printf("Unable to query performance counter: %d\n", GetLastError()); <br>} <br> <br>lipcDuration.QuadPart = lipcEnd.QuadPart - lipcStart.QuadPart; <br> <br>printf("EcBackupOpenFile took %d milliseconds\n", msfrompc(lipcDuration)); <br> <br>if (!QueryPerformanceCounter(&amp;lipcStart)) <br>{ <br>printf("Unable to query performance counter: %d\n", GetLastError()); <br>} <br> <br>while ((hrStatus == ERROR_SUCCESS) &amp;&amp; <br>   (liBytesRead.QuadPart &lt; liFileSize.QuadPart)) { <br>CB cbToRead = g_cbReadHintSize; <br> <br>if (g_fRandomReads) <br>{ <br>cbToRead = rand() % g_cbReadHintSize; <br>            if (cbToRead &lt; MIN_READ_HINT_SIZE) <br>            { <br>                cbToRead = MIN_READ_HINT_SIZE; <br>            } <br>} <br> <br>// <br>//  Read the next chunk from the database. <br>// <br>hrStatus = HrBackupRead(hbcBackupContext, <br>pvBuffer, <br>cbToRead, <br>&amp;cbRead); <br> <br>if (hrStatus == ERROR_SUCCESS) { <br>liBytesRead.QuadPart += cbRead; <br>        }  <br>else  <br>{ <br>printf("Read failed:%s %d\n", szFile, hrStatus); <br>break; <br>} <br> <br>if (hBackupFile) <br>{ <br>if (!WriteFile(hBackupFile, pvBuffer, cbRead, &amp;cbWritten, NULL)) <br>{ <br>hrStatus = GetLastError(); <br>free(pvBuffer); <br>HrBackupClose(hbcBackupContext); <br>return(hrStatus); <br>} <br> <br>if (cbWritten != cbRead) <br>{ <br>hrStatus = ERROR_HANDLE_DISK_FULL; <br>free(pvBuffer); <br>HrBackupClose(hbcBackupContext); <br>return(hrStatus); <br>} <br>} <br>} <br> <br>if (!QueryPerformanceCounter(&amp;lipcEnd)) <br>{ <br>printf("Unable to query performance counter: %d\n", GetLastError()); <br>} <br> <br>lipcDuration.QuadPart = lipcEnd.QuadPart - lipcStart.QuadPart; <br>if (hrStatus == ERROR_HANDLE_EOF) { <br>hrStatus = ERROR_SUCCESS; <br>} <br> <br>if (hrStatus == ERROR_SUCCESS) { <br>printf("Read %I64d bytes from the file, %3.3fs %f kb/second.\n", liBytesRead.QuadPart, ((double)msfrompc(lipcDuration) / 1000.0), (msfrompc(lipcDuration) ? ((double)liBytesRead.QuadPart / (double)(msfrompc(lipcDuration))) : 0)); <br>} <br> <br>hrStatus = HrBackupClose(hbcBackupContext); <br> <br>if (hrStatus != hrNone) <br>{ <br>printf("Close failed:%s %d\n", szFile, hrStatus); <br>} <br> <br>free(pvBuffer); <br>return(hrStatus); <br>} <br> <br>EC <br>EcDoBackup( <br>BOOL fIncremental, <br>SZ szBackupServer, <br>SZ szBackupAnnotation, <br>SZ szBackupFile <br>) <br>{ <br>HBC hbcBackupContext = NULL; <br>SZ szAttachmentInformation = NULL; <br>CB cbSize = 0; <br>EC hrStatus =  0; <br>SZ szAttachment = 0; <br>SZ szBackupLogFile = NULL; <br>SZ szBackupLogName = NULL; <br>HANDLE hBackupFile = NULL; <br>BackupHeader bh = {0}; <br>LogHeader lh = {0}; <br>C cAttachment = 0; <br>C cLogs = 0; <br>CB cbWritten = 0; <br> <br>// <br>//Contact the component on the server to be backed up - the <br>//  szBackupAnnotation field indicates which component on the <br>//  server is to be contacted. <br>// <br> <br>if (fIncremental) <br>{ <br>hrStatus = HrBackupPrepare(szBackupServer,  <br>szBackupAnnotation,  <br>1, <br>BACKUP_TYPE_LOGS_ONLY,  <br>&amp;hbcBackupContext); <br>} <br>else <br>{ <br>hrStatus = HrBackupPrepare(szBackupServer,  <br>szBackupAnnotation,  <br>0, <br>BACKUP_TYPE_FULL,  <br>&amp;hbcBackupContext); <br>} <br> <br>if (hrStatus != ERROR_SUCCESS)  <br>{ <br>return hrStatus; <br>    } <br> <br>if (szBackupFile) <br>{ <br>// <br>//Open up the backup file for write access. <br>// <br>hBackupFile = CreateFile(szBackupFile, <br>GENERIC_WRITE | GENERIC_READ, <br>0, <br>NULL, <br>OPEN_ALWAYS, <br>FILE_FLAG_SEQUENTIAL_SCAN, <br>NULL <br>); <br>if (hBackupFile == INVALID_HANDLE_VALUE) <br>{ <br>return(GetLastError()); <br>} <br>} <br> <br>cAttachment = 0; <br>if (!fIncremental) <br>{ <br>// <br>//Get the list of attached databases to perform the backup <br>// <br>hrStatus = HrBackupGetDatabaseNames(hbcBackupContext, <br>&amp;szAttachmentInformation, <br>&amp;cbSize); <br>if (hrStatus != ERROR_SUCCESS) { <br>HrBackupEnd(hbcBackupContext); <br>if (hBackupFile) <br>{ <br>CloseHandle(hBackupFile); <br>} <br>return hrStatus; <br>} <br> <br>szAttachment = szAttachmentInformation; <br> <br>while (*szAttachment != '\0') <br>{ <br>cAttachment  += 1; <br>szAttachment += strlen(szAttachment)+1; <br>} <br>} <br> <br>if (hBackupFile) <br>{ <br>// <br>//Write the header for the backup into the file. <br>// <br>bh.ulSignature = BACKUP_SIGNATURE; <br>bh.ulVersion = BACKUP_VERSION; <br>bh.cbDatabaseNameLength = strlen(szBackupAnnotation)+1; <br>bh.cBackupFiles = cAttachment; <br> <br>if (!WriteFile(hBackupFile, &amp;bh, sizeof(bh), &amp;cbWritten, NULL)) <br>{ <br>hrStatus = GetLastError(); <br>HrBackupEnd(hbcBackupContext); <br>return(hrStatus); <br>} <br> <br>if (cbWritten != sizeof(bh)) <br>{ <br>hrStatus = ERROR_HANDLE_DISK_FULL; <br>HrBackupEnd(hbcBackupContext); <br>return(hrStatus); <br>} <br> <br>if (!WriteFile(hBackupFile, szBackupAnnotation, bh.cbDatabaseNameLength, &amp;cbWritten, NULL)) <br>{ <br>hrStatus = GetLastError(); <br>HrBackupEnd(hbcBackupContext); <br>return(hrStatus); <br>} <br> <br>if (cbWritten != bh.cbDatabaseNameLength) <br>{ <br>hrStatus = ERROR_HANDLE_DISK_FULL; <br>HrBackupEnd(hbcBackupContext); <br>return(hrStatus); <br>} <br>} <br> <br>if (!fIncremental) <br>{ <br>szAttachment = szAttachmentInformation; <br>while (*szAttachment != '\0')  <br>{ <br>hrStatus = EcBackupFile(hbcBackupContext, szAttachment, hBackupFile); <br> <br>if (hrStatus != hrNone) <br>{ <br>BackupFree(szAttachmentInformation); <br>HrBackupEnd(hbcBackupContext); <br>if (hBackupFile) <br>{ <br>CloseHandle(hBackupFile); <br>} <br>return(hrStatus); <br>} <br>szAttachment += strlen(szAttachment)+1; <br>} <br> <br>BackupFree(szAttachmentInformation); <br>} <br> <br> <br>// <br>//We've successfully backed up the system, now clear  <br>    //  out the logs by truncating them. <br>// <br> <br>hrStatus = HrBackupGetBackupLogs(hbcBackupContext, <br>&amp;szBackupLogFile, <br>&amp;cbSize); <br> <br>if (hrStatus != ERROR_SUCCESS) { <br>HrBackupEnd(hbcBackupContext); <br>if (hBackupFile) <br>{ <br>CloseHandle(hBackupFile); <br>} <br>return hrStatus; <br>} <br> <br>cLogs = 0; <br> <br>szBackupLogName = szBackupLogFile; <br> <br>while (*szBackupLogName != '\0') <br>{ <br>cLogs += 1; <br>szBackupLogName += strlen(szBackupLogName)+1; <br>} <br> <br>if (hBackupFile) <br>{ <br>// <br>//Write the header for the log portion of the backup into the file. <br>// <br> <br>lh.ulLogSignature = LOG_SIGNATURE; <br>lh.cLogFiles = cLogs; <br> <br>if (!WriteFile(hBackupFile, &amp;lh, sizeof(lh), &amp;cbWritten, NULL)) <br>{ <br>hrStatus = GetLastError(); <br>HrBackupEnd(hbcBackupContext); <br>return(hrStatus); <br>} <br> <br>if (cbWritten != sizeof(lh)) <br>{ <br>hrStatus = ERROR_HANDLE_DISK_FULL; <br>HrBackupEnd(hbcBackupContext); <br>return(hrStatus); <br>} <br>} <br> <br>szBackupLogName = szBackupLogFile; <br> <br>while (*szBackupLogName != '\0') { <br>hrStatus = EcBackupFile(hbcBackupContext, szBackupLogName, hBackupFile); <br>if (hrStatus != hrNone) <br>{ <br>BackupFree(szBackupLogFile); <br>HrBackupEnd(hbcBackupContext); <br>if (hBackupFile) <br>{ <br>CloseHandle(hBackupFile); <br>} <br>return(hrStatus); <br>} <br>szBackupLogName += strlen(szBackupLogName)+1; <br>} <br> <br>BackupFree(szBackupLogFile); <br> <br>printf("All logs and files backed up.\n"); <br> <br>if (!fIncremental) <br>{ <br>hrStatus = HrBackupTruncateLogs(hbcBackupContext); <br> <br>if (hrStatus != hrNone) <br>{ <br>printf("Unable to truncate log: %d (%x).\n", hrStatus, hrStatus); <br>if (hBackupFile) <br>{ <br>CloseHandle(hBackupFile); <br>} <br> <br>return(hrStatus); <br>} <br> <br>} <br> <br>hrStatus = HrBackupEnd(hbcBackupContext); <br> <br>if (hBackupFile) <br>{ <br>CloseHandle(hBackupFile); <br>} <br> <br>return(hrStatus); <br>} <br> <br> <br>void <br>usage(void) <br>{ <br>    printf("\nUsage: BackTest\t -S:&lt;Server&gt;" <br>        "\n\t\t -B:&lt;Backup File&gt;" <br>        "\n\t\t -T:&lt;MDB|DSA&gt;" <br>        "\n\t\t[-R:&lt;Read Buffer Size&gt;]" <br>        "\n\t\t[-R:R]  (generate random buffer sizes on successive reads)" <br>"\n\t\t[-I]    (incremental backup)\n" ); <br>} <br> <br>int <br>_cdecl <br>main (int cArg, char *rgszArgv[]) <br>{ <br>EC ecResult = 0; <br>I irgsz = 0; <br>BOOL fDsa = fFalse; <br>BOOL fMdb = fFalse; <br>SZ szServerName = NULL; <br>SZ szBackupType = NULL; <br>SZ szBackupFile = NULL; <br>char rgComputerName[ MAX_COMPUTERNAME_LENGTH ] = {0}; <br>ERR err = 0; <br>BOOL fIncremental = fFalse; <br> <br>    if (cArg &lt;= 1) <br>    { <br>        usage(); <br>        exit(1); <br>    } <br> <br>for (irgsz = 1; irgsz &lt; cArg ; irgsz += 1) <br>{ <br>if (rgszArgv[irgsz][0] == '-' || rgszArgv[irgsz][0]=='/' ) <br>{ <br>if (toupper(rgszArgv[irgsz][1]) == 'T') <br>{ <br>szBackupType = (rgszArgv[irgsz][2] == ':' ? &amp;rgszArgv[irgsz][3] : rgszArgv[++irgsz]); <br>} <br>else if (toupper(rgszArgv[irgsz][1]) == 'S') <br>{ <br>szServerName = (rgszArgv[irgsz][2] == ':' ? &amp;rgszArgv[irgsz][3] : rgszArgv[++irgsz]); <br>} <br>else if (toupper(rgszArgv[irgsz][1]) == 'B') <br>{ <br>szBackupFile = (rgszArgv[irgsz][2] == ':' ? &amp;rgszArgv[irgsz][3] : rgszArgv[++irgsz]); <br>} <br>else if (toupper(rgszArgv[irgsz][1]) == 'R') <br>{ <br>SZ szReadHint = (rgszArgv[irgsz][2] == ':' ? &amp;rgszArgv[irgsz][3] : rgszArgv[++irgsz]); <br>if (isdigit(*szReadHint)) <br>{ <br>g_cbReadHintSize = atoi(szReadHint); <br>                    if (g_cbReadHintSize &lt; MIN_READ_HINT_SIZE) <br>                    { <br>                        g_cbReadHintSize = MIN_READ_HINT_SIZE; <br>                    } <br>} <br>else <br>{ <br>switch (toupper(*szReadHint)) <br>{ <br>case 'R': <br>case 'r': <br>g_fRandomReads = fTrue; <br>srand(time(NULL)); <br>break; <br>default: <br>usage(); <br>exit(1); <br>} <br>} <br>} <br>else if (toupper(rgszArgv[irgsz][1]) == 'I') <br>{ <br>fIncremental = fTrue; <br>} <br>else <br>{ <br>usage(); <br>exit(1); <br>} <br>} <br>} <br> <br>if (szServerName == NULL) <br>{ <br>CB cbComputerName = sizeof(rgComputerName); <br>if (!GetComputerName(rgComputerName, &amp;cbComputerName)) { <br>printf("Unable to query local computer name %d", GetLastError()); <br>return(GetLastError()); <br>} <br>szServerName = rgComputerName; <br>} <br> <br>if (szBackupType == NULL) <br>{ <br>usage(); <br>printf("Must specify a backup type\n"); <br>return(hrError); <br>} <br>else if (_stricmp(szBackupType, "MDB") == 0) <br>{ <br>fMdb = fTrue; <br>} <br>else if (_stricmp(szBackupType, "DSA") == 0) <br>{ <br>fDsa = fTrue; <br>} <br> <br>if (!fMdb &amp;&amp; !fDsa) <br>{ <br>usage(); <br>printf("Must specify either MDB or DSA as the backup type"); <br>return(hrError); <br>} <br> <br>ecResult = EcDoBackup(fIncremental, szServerName, ( fMdb ? EDBBACK_MDB_SERVER : (fDsa ? EDBBACK_DS_SERVER : NULL)), szBackupFile); <br> <br>printf("ecResult: %s (%d/0x%x)\n", SzFromHr(ecResult), ecResult, ecResult); <br> <br>return(ecResult); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
