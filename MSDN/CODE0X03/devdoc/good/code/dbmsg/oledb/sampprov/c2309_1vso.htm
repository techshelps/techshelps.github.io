<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILEIO.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2328"></a>FILEIO.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB  <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module FILEIO.CPP | This module contains the File Manipulation code <br>// for a Comma Seperated Value (CSV) Simple Provider. <br>// <br>// <br>#include "headers.h" <br>#include "fileio.h" <br> <br>static const ARRAY_INIT_SIZE = 1000; <br> <br>// Data Types supported <br>static const TYPE_CHAR = 1; <br>static const TYPE_SLONG = 3; <br> <br>// Data Type Parse strings and lengths <br>static const char CHAR_STRING[] = "CHAR"; <br>static const CHAR_STRING_SIZE = 4; <br>static const char SLONG_STRING[] = "SLONG"; <br>static const SLONG_STRING_SIZE = 5; <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Constructor for this class <br>// <br>// @rdesc NONE <br>// <br>CFileIO::CFileIO() <br>{ <br>    m_pColNames        = NULL; <br>    m_pvInput          = NULL; <br>    m_ulDataTypeOffset = 0; <br>    m_dwColumns        = 0; <br>    m_cRows            = 0; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Destructor for this class <br>// <br>// @rdesc NONE <br>// <br>CFileIO:: ~CFileIO() <br>{ <br>    // Close file <br>    if (is_open()) <br>        close(); <br> <br>    // Delete buffers <br>    delete[] m_pColNames; <br>    delete[] m_pvInput; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Initialization routine, opens file specified and creates <br>// buffers <br>// <br>// @rdesc HRESULTs <br>//      @flag S_OK | Succeeded <br>//      @flag E_FAIL | Failed to Initialize <br>// <br>HRESULT CFileIO::fInit <br>    ( <br>    LPSTR ptstrFileName         //@parm IN | File Name to Open <br>    ) <br>{ <br>    // Allocate Stream Buffer <br>    m_pvInput = new char[MAX_INPUT_BUFFER ]; <br>    if (NULL == m_pvInput) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Open the File <br>//@DEVNOTE: csv file must not be read only, else E_FAIL will be returned. <br>    open( ptstrFileName, ios::in | ios::out | ios::nocreate, filebuf::sh_none ); <br>    if (!is_open()) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Obtain the Column Names, Data Types, and Indexes <br>    // for each of the rows <br>    if (FAILED( GenerateFileInfo())) <br>        return ResultFromScode( E_FAIL ); <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Retrieve the Name associated with a particular column.  If <br>// names have not been read from the file yet, retrieve those names. <br>// If a name does not exist for a column, fabricate one. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Succeeded <br>//      @flag E_FAIL | Invalid Column Number <br>// <br>HRESULT CFileIO::GetColumnName <br>    ( <br>    DWORD   dwCol,          //@parm IN | Column Number <br>    LPSTR*  pptstrName      //@parm OUT | Pointer to Column Name <br>    ) <br>{ <br>    // Column number greater than MAX <br>    if (dwCol &gt; MAX_COLUMNS) <br>        { <br>        TRACE( "dwCol &gt; MAX_COLUMNS" ); <br>        return ResultFromScode( E_FAIL ); <br>        } <br> <br>    // If Column Names have not been retrieved, <br>    // then retrieve them into the internal array <br>    if (!m_pColNames) <br>        { <br>        // Save Current Position and move to beginning of file <br>        seekg( 0L ); <br>        clear(); <br> <br>        // Retrieve the column names record <br>        getline( m_pvInput, MAX_INPUT_BUFFER ); <br>        if (good() &amp;&amp; 0 &lt; gcount()) <br>        { <br>m_pColNames = new char[gcount() ]; <br>memcpy( m_pColNames, m_pvInput, gcount()); <br>        } <br>else <br>{ <br>//Invalid Table, first line does not contain  <br>//column metadata. <br>return ResultFromScode(E_FAIL); <br>} <br>         <br>ParseColumnNames( m_pColNames ); <br> <br>        return ResultFromScode( S_FALSE ); <br>        } <br> <br>    ASSERT( pptstrName ); <br> <br>    // If the column number is in range then return <br>    // the pointer <br>    if ((0 == dwCol) || (m_dwColumns &lt; dwCol)) <br>        return ResultFromScode( E_FAIL ); <br>    else <br>        { <br>        *pptstrName = m_rgpColNames[dwCol]; <br>        return ResultFromScode( S_OK ); <br>        } <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Tokenize the column names <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Parsing yielded no Error <br>// <br>HRESULT CFileIO::ParseColumnNames <br>    ( <br>    LPTSTR ptstrInput <br>    ) <br>{ <br>    LPTSTR  pvInput = ptstrInput; <br> <br>    ASSERT( pvInput ); <br> <br>    // Set first column pointer <br>    if ('\0' != *pvInput) <br>        { <br>        m_rgpColNames[++m_dwColumns] = pvInput; <br>        } <br> <br>    // Null Terminate each column <br>    while ('\0' != *pvInput) <br>        { <br>        // Check for Comma <br>        if (0 == strncmp( ",", pvInput, sizeof( char ))) <br>            { <br>            memcpy( pvInput, "", sizeof( char )); <br> <br>            if (0 != strncmp( "", (LPTSTR) ((ULONG) pvInput + 1), sizeof( char ))) <br>                { <br>                m_rgpColNames[++m_dwColumns] = (LPTSTR) ((ULONG) pvInput + 1); <br>                } <br>            } <br> <br>        pvInput++; <br>        } <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Retrieves the columns data characteristics <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Succeeded <br>//      @flag E_FAIL | Invalid Column Number <br>// <br>HRESULT CFileIO::GetDataTypes <br>    ( <br>    DWORD dwCol,        //@parm IN | Column number <br>    SWORD* pswType,     //@parm OUT | Data Type <br>    UDWORD* pudwColDef, //@parm OUT | Precision of the column <br>    BOOL* pfSigned      //@parm OUT | Is the columns signed <br>    ) <br>{ <br>    HRESULT hr; <br> <br>    // Column number greater than MAX <br>    if (dwCol &gt; MAX_COLUMNS) <br>        { <br>        TRACE( "dwCol &gt; MAX_COLUMNS" ); <br>        return ResultFromScode( E_FAIL ); <br>        } <br> <br>    // If Data Types have not been retrieved, <br>    // then retrieve them into the internal array <br>    if (0 == m_ulDataTypeOffset) <br>        { <br>        seekg( 0L ); <br>        clear(); <br> <br>        // To retrieve the Column Data Types, we need <br>        // to skip the first row and get to the 2nd row <br>        getline( m_pvInput, MAX_INPUT_BUFFER ); <br>        m_ulDataTypeOffset = tellg(); <br>        getline( m_pvInput, MAX_INPUT_BUFFER ); <br> <br>        // Check Stream status <br>        if (bad() || 0 == gcount()) <br>            return ResultFromScode( E_FAIL ); <br> <br>        // Parse the datatypes from the stream. <br>        hr = ParseDataTypes(); <br>        if (FAILED( hr )) <br>            return hr; <br> <br>        return ResultFromScode( S_FALSE ); <br>        } <br> <br>    assert( pswType || pudwColDef || pfSigned ); <br> <br>    // If the column number is in range then return <br>    // the pointer <br>    if ((0 == dwCol) || (m_dwColumns &lt; dwCol)) <br>        return ResultFromScode( E_FAIL ); <br>    else <br>        { <br>        *pswType = m_rgswColType[dwCol]; <br>        *pudwColDef = m_rgudwColSize[dwCol]; <br>        *pfSigned = m_rgfSigned[dwCol]; <br>        return ResultFromScode( S_OK ); <br>        } <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Tokenize the DataTypes and Lengths <br>// Valid Data Types are CHAR(n), INTEGER, and LONG <br>// <br>// CHAR, SLONG <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Parsing yielded no Error <br>// <br>HRESULT CFileIO::ParseDataTypes() <br>{ <br>    ULONG   ulColumn = 0; <br>    LPSTR   pVal, pOpen; <br> <br>    assert( m_pvInput ); <br> <br>    pVal = strtok( m_pvInput, ",\0" ); <br>    if (NULL == pVal) <br>        return ResultFromScode( E_FAIL ); <br> <br>    while (NULL != pVal) <br>        { <br>        ulColumn++; <br> <br>        if (0 == _strnicmp( pVal, CHAR_STRING, CHAR_STRING_SIZE )) <br>            { <br>            m_rgswColType[ulColumn] = TYPE_CHAR; <br>            pOpen = strstr( pVal, "(" ); <br>            m_rgudwColSize[ulColumn] = atol( ++pOpen ) + 1; <br>            m_rgfSigned[ulColumn] = FALSE; <br>            } <br>        else if (0 == _strnicmp( pVal, SLONG_STRING, SLONG_STRING_SIZE )) <br>            { <br>            m_rgswColType[ulColumn] = TYPE_SLONG; <br>            m_rgudwColSize[ulColumn] = 4; <br>            m_rgfSigned[ulColumn] = TRUE; <br>            } <br>        else <br>            return ResultFromScode( E_FAIL ); <br> <br>        pVal = strtok( NULL, ",\0" ); <br>        } <br> <br>    // should have exactly the same number of types as we have columns <br>    if (ulColumn != m_dwColumns) <br>        return ResultFromScode( E_FAIL ); <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Obtain the offsets into the file that each row exists at. <br>// Ignore any deleted rows while reading the file. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Got the offsets, Column Names and Data Types <br>//      @flag E_FAIL | Could not obtain all the necessary info <br>// <br>HRESULT CFileIO::GenerateFileInfo() <br>{ <br>    ULONG ulDex = 0; <br>    ULONG ulSavePos; <br> <br>    // Generate Column Info, if NULL is returned, a problem <br>    // was encountered while reading the Column Names. <br>    if (S_FALSE != GetColumnName( 0, NULL )) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Generate DataType Mapping, if FALSE is returned, a problem <br>    // was encountered while reading the DataTypes <br>    if (S_FALSE != GetDataTypes( 0, NULL, NULL, NULL )) <br>        return ResultFromScode( E_FAIL ); <br> <br> <br>    // Create and Initialize the Index Array <br>    if (FALSE == m_FileIdx.fInit()) <br>        return ResultFromScode( E_FAIL ); <br> <br> <br>    // Obtain the starting offset for each row <br>    seekg( m_ulDataTypeOffset ); <br>    ulSavePos = tellg(); <br>    getline( m_pvInput, MAX_INPUT_BUFFER ); <br>    while (good() &amp;&amp; !eof()) <br>        { <br>        //Ignore Deleted Lines <br>        if ('@' != *m_pvInput &amp;&amp; '\0' != *m_pvInput) <br>            m_FileIdx.SetIndex( ulDex++, ulSavePos ); <br>        ulSavePos = tellg(); <br>        getline( m_pvInput, MAX_INPUT_BUFFER ); <br>        } <br> <br>    // Store the number of rows <br>    m_cRows = ulDex - 1; <br> <br>#ifdef _DEBUG <br>    for (ULONG i=0; i &lt; ulDex; i++) <br>        { <br>        // printf("%d - %u\r\n", i, m_FileIdx.GetRowOffset(i)); <br>        } <br>#endif <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Check if the row has already been deleted <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Row already deleted <br>//      @flag S_FALSE | Row not deleted <br>// <br>HRESULT CFileIO::IsDeleted <br>    ( <br>    ULONG ulRow                 //@parm IN | Row to Check <br>    ) <br>{ <br>    // Already deleted <br>    if (TRUE == m_FileIdx.IsDeleted( ulRow )) <br>        return ResultFromScode( S_OK ); <br>    else <br>        return ResultFromScode( S_FALSE ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Fill the row with '@' characters, the deletion pattern.. <br>// And set the Deletion status flag in the index class. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Deleted Row <br>//      @flag E_FAIL | Row Number was invalid or problem deleting. <br>// <br>HRESULT CFileIO::DeleteRow <br>    ( <br>    ULONG ulRow                 //@parm IN | Row to Delete <br>    ) <br>{ <br>    assert( is_open()); <br>    assert( m_pvInput ); <br> <br>    // Check the Row Number <br>    if ((ulRow &lt; 1) || (ulRow &gt; m_cRows)) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // If already deleted, just ignore. <br>    if (TRUE == m_FileIdx.IsDeleted( ulRow )) <br>        return ResultFromScode( S_OK ); <br> <br>    // Set the File Pointer <br>    seekg( m_FileIdx.GetRowOffset( ulRow )); <br>    clear(); <br> <br>    // Delete the row in the file and mark the status <br>    // as deleted in the index Array <br>    getline( m_pvInput, MAX_INPUT_BUFFER ); <br>    if (good()) <br>        { <br>        // Set the number bytes in the stream minus <br>        // the null terminator to this pattern <br>        memset( m_pvInput, '@', gcount() - 1 ); <br>        seekp( m_FileIdx.GetRowOffset( ulRow )); <br>        clear(); <br>        write( m_pvInput, gcount() - 1 ); <br>        if (bad()) <br>            return ResultFromScode( E_FAIL ); <br>        else <br>            flush(); <br>        } <br>    else <br>        return ResultFromScode( E_FAIL ); <br> <br>    m_FileIdx.DeleteRow( ulRow ); <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Establish the Binding Information for the given file <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Binding set <br>//      @flag E_FAIL | Problem setting the binding <br>// <br>HRESULT CFileIO::SetColumnBind <br>    ( <br>    DWORD dwCol,            //@parm IN | Column Number <br>    PCOLUMNDATA pColumn,    //@parm IN | Pointer to the Data Area <br>    SDWORD sdwMaxLen        //@parm IN | Maximum size for the value <br>    ) <br>{ <br>    assert( is_open()); <br>    assert( m_rgpColumnData ); <br>    assert( m_rgsdwMaxLen ); <br> <br>    // If the column number is in range then return <br>    // the pointer <br>    if ((0 == dwCol) || (m_dwColumns &lt; dwCol)) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Expect valid pointer <br>    assert( pColumn ); <br> <br>    m_rgpColumnData[dwCol] = pColumn; <br>    m_rgsdwMaxLen[dwCol] = sdwMaxLen; <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Fetch the row data from the stream to the internal data <br>// buffers <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK    | Row Retrieve successfully <br>//      @flag S_FALSE | End of Result Set <br>//      @flag E_FAIL  | Row could not be retrieved <br>// <br>HRESULT CFileIO::Fetch <br>    ( <br>    ULONG   ulRow           //@parm IN | Row to retrieve <br>    ) <br>{ <br>    assert( is_open()); <br>    assert( m_rgpColumnData ); <br>    assert( m_rgsdwMaxLen ); <br> <br>    // Check the Row Number <br>    if ((ulRow &lt; 1)) <br>        return ResultFromScode( E_FAIL ); <br> <br>    //Check end of Result Set <br>    if (ulRow &gt; m_cRows) <br>        return ResultFromScode( S_FALSE ); <br> <br>    // Set the File Pointer to the row. <br>    seekg( m_FileIdx.GetRowOffset( ulRow )); <br>    clear(); <br> <br>    // Retrieve the column names record <br>    getline( m_pvInput, MAX_INPUT_BUFFER ); <br>    if (good() &amp;&amp; 0 &lt; gcount()) <br>        { <br>        return ParseRowValues(); <br>        } <br> <br>    return ResultFromScode( E_FAIL ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Tokenize the Data values and put them into the correct <br>// binding areas <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Parsing yielded no Error <br>//      @flag E_FAIL | Data value could not be parsed or stored <br>// <br>HRESULT CFileIO::ParseRowValues <br>    ( <br>    void <br>    ) <br>{ <br>    DWORD   dwColumns = 0; <br>    DWORD   cQuotes = 0; <br>    LPTSTR  pvCopy, <br>        pvInput, <br>        pLastQuote; <br> <br>    pLastQuote = NULL; <br>    pvCopy = NULL; <br>    pvInput = m_pvInput; <br> <br>    assert( pvInput ); <br>    assert( m_dwColumns &gt; 0 ); <br> <br>    while ('\0' != *pvInput) <br>        { <br> <br>        // Check for Quotes <br>        if (0 == strncmp( "\"", pvInput, sizeof( char ))) <br>            { <br>            pLastQuote = pvInput; <br>            cQuotes++; <br>            goto TermCheck; <br>            } <br> <br>        // Check for Comma <br>        // NOTE: THIS won't handle """ <br>        if (0 == strncmp( ",", pvInput, sizeof( char )) &amp;&amp; <br>             0 == cQuotes % 2) <br>            { <br>            if (pLastQuote) <br>                memcpy( pLastQuote, "", sizeof( char )); <br>            else <br>                memcpy( pvInput, "", sizeof( char )); <br> <br>            // Increment Columns processed <br>            dwColumns++; <br> <br>            //          TRACE(pvCopy ? pvCopy : "&lt;NULL&gt;"); <br>            if (FAILED( FillBinding( dwColumns, pvCopy ))) <br>                return ResultFromScode( E_FAIL ); <br> <br>            pLastQuote = NULL; <br>            pvCopy = NULL; <br>            cQuotes = 0; <br>            goto TermCheck; <br>            } <br> <br>        //Valid First character for next column <br>        if (NULL == pvCopy) <br>            pvCopy = pvInput; <br> <br>        TermCheck: <br>        // Check for Final Null Terminator <br>        if (0 == strncmp( "", (LPTSTR) ((ULONG) pvInput + 1), sizeof( char ))) <br>            { <br>            //If we are to the null terminator and have unbalanced "'s <br>            //then we fail <br>            if (0 != cQuotes % 2) <br>                return ResultFromScode( E_FAIL ); <br> <br>            if (pLastQuote) <br>                memcpy( pLastQuote, "", sizeof( char )); <br> <br>            // Increment Columns processed <br>            dwColumns++; <br> <br>            //          TRACE(pvCopy ? pvCopy : "&lt;NULL&gt;"); <br>            if (FAILED( FillBinding( dwColumns, pvCopy ))) <br>                return ResultFromScode( E_FAIL ); <br>            } <br> <br>        pvInput++; <br>        } <br> <br>    // Check that we returned the correct number of columns <br>    if (dwColumns &lt; m_dwColumns) <br>        return ResultFromScode( E_FAIL ); <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Based on the given bindings and column data, put the data <br>// in the correct area, update the status and length fields <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Data copied to the specified location <br>// <br>HRESULT CFileIO::FillBinding <br>    ( <br>    DWORD dwColumn,     //@parm IN | Column that value is for <br>    LPTSTR pvCopy       //@parm IN | Pointer to data value to transfer <br>    ) <br>{ <br>    assert( m_rgswColType ); <br>    assert( m_rgpColumnData ); <br>    assert( m_rgsdwMaxLen ); <br> <br>    // Null Value <br>    if (!pvCopy) <br>        { <br>        m_rgpColumnData[dwColumn]-&gt;dwStatus = DBSTATUS_S_ISNULL; <br>        return ResultFromScode( S_OK ); <br>        } <br> <br>    switch (m_rgswColType[dwColumn]) <br>        { <br>    case TYPE_CHAR: <br>        lstrcpyn((LPTSTR) m_rgpColumnData[dwColumn]-&gt;bData, pvCopy, m_rgsdwMaxLen[dwColumn] ); <br>        m_rgpColumnData[dwColumn]-&gt;dwLength = lstrlen( pvCopy ) + sizeof( char ); <br>        m_rgpColumnData[dwColumn]-&gt;dwStatus = DBSTATUS_S_OK; <br>        break; <br> <br>    case TYPE_SLONG: <br>        *(ULONG*) m_rgpColumnData[dwColumn]-&gt;bData = atol( pvCopy ); <br>        m_rgpColumnData[dwColumn]-&gt;dwLength = 4; <br>        m_rgpColumnData[dwColumn]-&gt;dwStatus = DBSTATUS_S_OK; <br>        break; <br> <br>    default: <br>        assert( !"Unknown Data Type" ); <br>        break; <br>        } <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Given a pointer to the new data and the row the the data is <br>// for, write the data to the file. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Record and Indexes updated <br>//      @flag E_FAIL | Problems updating record <br>// <br>HRESULT CFileIO::UpdateRow <br>    ( <br>    ULONG       ulRow,      //@parm IN | Row to update <br>    ULONG*      ulOffset,   //@parm IN | Array of offsets for the columns <br>    BYTE*       pbProvRow   //@parm IN | Data to update row with. <br>    ) <br>{ <br>    LPSTR       pvInput = m_pvInput; <br>    PCOLUMNDATA pColData; <br>    DWORD       i; <br>    int         nCnt; <br>    LONG        lPos; <br> <br>    // Check the Row Number <br>    if ((ulRow &lt; 0) || (ulRow &gt; m_cRows)) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Updated Rows are added to the end of the file, the row number will <br>    // remain the same until the rowset is closed, because the old <br>    // offset is deleted and the new is put in it's place. <br>    for (i = 1; i &lt;= m_dwColumns; i++) <br>        { <br>        nCnt = 0; <br> <br>        pColData = (PCOLUMNDATA) (pbProvRow + ulOffset[i]); <br> <br>        // Handle NULL Data <br>        if (pColData-&gt;dwStatus != DBSTATUS_S_ISNULL) <br>            { <br>            switch (m_rgswColType[i]) <br>                { <br>            case TYPE_CHAR: <br>                nCnt = wsprintf( pvInput, "\"%s\"", <br>                    (LPTSTR) pColData-&gt;bData ); <br>                break; <br> <br>            case TYPE_SLONG: <br>                nCnt = wsprintf( pvInput, "%d", <br>                    (signed long) *pColData-&gt;bData ); <br>                break; <br> <br>            default: <br>                assert( !"Unknown Data Type" ); <br>                break; <br> <br>                } <br> <br>            } <br> <br>        //Calculate the next append area <br>        pvInput = (LPTSTR) ((ULONG) pvInput + (nCnt * sizeof( char ))); <br> <br>        if (i == m_dwColumns) <br>            lstrcat( pvInput, "\n" ); <br>        else <br>            { <br>            lstrcat( pvInput, "," ); <br>            pvInput = (LPTSTR) ((ULONG) pvInput + sizeof( char )); <br>            } <br>        } <br> <br>    // Write Stream to File <br>    seekg( 0, ios::end ); <br>    lPos = tellg(); <br>    clear(); <br>    write( m_pvInput, lstrlen( m_pvInput )); <br>    if (bad()) <br>        return ResultFromScode( E_FAIL ); <br>    else <br>        flush(); <br> <br>    // Delete old Row and fix up Row offset value <br>    if (SUCCEEDED( DeleteRow( ulRow ))) <br>        m_FileIdx.SetIndex( ulRow, lPos ); <br>    else <br>        return ResultFromScode( E_FAIL ); <br> <br>    return ResultFromScode( S_OK ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
