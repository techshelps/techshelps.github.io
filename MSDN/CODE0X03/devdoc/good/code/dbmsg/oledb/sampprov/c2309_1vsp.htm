<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILEIO.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2329"></a>FILEIO.H</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module FILEIO.H | Class Definitions for CFileIO Class <br>// <br>// <br>#ifndef _FILEIO_H_ <br>#define _FILEIO_H_ <br> <br>#include &lt;fstream.h&gt; <br>#include "fileidx.h" <br>#include "hashtbl.h" <br> <br>#define MAX_INPUT_BUFFER 2048 <br>#define MAX_COLUMNS129// 128 columns supported, but 1 extra <br>// is needed since 1 based. <br> <br>//-------------------------------------------------------------------- <br>// @class CFileIO | Opens and manipulates a given CSV file.  Allows  <br>// deletions, reads, and updates. <br>//  <br>// @hungarian  <br>// <br>class CFileIO : public fstream//@base public | fstream <br>{ <br>private: //@access private <br>//@cmember Count of rows in the table  <br>ULONGm_cRows; <br>//@cmember Count of columns in the table <br>DWORDm_dwColumns; <br>//@cmember Pointer to Column Names buffer <br>LPTSTRm_pColNames; <br>//@cmember Array of pointers into the Column Names buffer <br>LPTSTRm_rgpColNames[MAX_COLUMNS]; <br>//@cmember Array of Column Data Types <br>SWORDm_rgswColType[MAX_COLUMNS]; <br>//@cmember Array of Precision values for columns <br>UDWORDm_rgudwColSize[MAX_COLUMNS]; <br>//@cmember True if columns contains signed values <br>BOOLm_rgfSigned[MAX_COLUMNS]; <br>//@cmember Array of pointers to Data <br>PCOLUMNDATA m_rgpColumnData[MAX_COLUMNS]; <br>//@cmember Array of Lengths for the data <br>SDWORDm_rgsdwMaxLen[MAX_COLUMNS]; <br>//@cmember Input buffer of size MAX_INPUT_BUFFER <br>LPTSTRm_pvInput; <br>//@cmember Offset into file for DataTypes <br>ULONGm_ulDataTypeOffset; <br>//@cmember Index Class declaration <br>CFileIdxm_FileIdx; <br> <br>private: //@access private <br>//@cmember Break a stream into column names <br>HRESULT ParseColumnNames(LPTSTR ptstrInput); <br>//@cmember Break a stream into MetaData information <br>HRESULT ParseDataTypes(); <br>//@cmember Control procedure to Read and parse intitial <br>//information from the file <br>HRESULT GenerateFileInfo(); <br>//@cmember Fill the COLUMNDATA structure <br>HRESULT CFileIO::FillBinding(DWORD dwColumn, LPTSTR pvCopy); <br> <br> <br>public: //@access public <br>//@cmember Constructor <br>CFileIO(void); <br>//@cmember Destructor <br>~CFileIO(void); <br>//@cmember Initialization routine <br>HRESULT fInit(LPTSTR pstrFileName); <br>//@cmember Return the number of columns in the file <br>inline DWORD GetColumnCnt() { return m_dwColumns; }; <br>//@cmember Return the number of rows in the file <br>inline DWORD GetRowCnt() { return m_cRows; }; <br>//@cmember Retrieve pointers to the columns names <br>HRESULT GetColumnName(DWORD dwCol, LPTSTR* pptstrName = NULL); <br>//@cmember Retrieve the metadata for a particular column <br>HRESULT GetDataTypes(DWORD dwCol, SWORD* pswType, UDWORD* pudwColDef, BOOL* pfSigned); <br>//@cmember Set the Binding Areas. <br>HRESULT SetColumnBind(DWORD dwcol, PCOLUMNDATA pColumn, SDWORD sdwMaxLen); <br>//@cmember Extract the data from a stream <br>HRESULT ParseRowValues(); <br>//@cmember Fetch A single rows data values <br>HRESULT Fetch(ULONG ulRow); <br>//@cmember Update the current rows values <br>HRESULT UpdateRow(ULONG ulRow, ULONG* ulOffset, BYTE* pbProvRow); <br>//@cmember Remove the specified row from the file <br>HRESULT DeleteRow(ULONG ulRow); <br>//@cmember Determines if the row has already been deleted <br>HRESULT IsDeleted(ULONG ulRow); <br>}; <br> <br>typedef CFileIO FAR * PCFILEIO; <br> <br>#endif <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
