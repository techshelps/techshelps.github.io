<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILPROP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2345"></a>UTILPROP.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module UTILPROP.CPP | Properties utility object implementation <br>// <br> <br> <br>// <br>// Notes - there are two main methods in this module: <br>//     - CUtilProps::GetPropertyInfo, a helper function for IDBInfo::GetPropertyInfo <br>//     - CUtilProps::GetProperties, a helper function for IRowsetInfo::GetProperties <br>// <br>// Our property implementation is simplified considerably by the fact that we <br>// only support reading\getting the properties, we do not support <br>// writing\setting them. This makes sense because we are a simple provider, <br>// and our rowset object always creates all the interfaces it exposes. In <br>// other words, there are really no properties the consumer could set. <br>// <br>// The implementation is very simple - we keep a global table of the <br>// properties we support in s_rgprop. We search this table sequentially. <br>// <br>// Note that a full-featured provider would probably need to use a more <br>// sophisticated implementation. We keep the entire GUID for each property in <br>// our struct, which would become a waste of space if we had a lot more <br>// properties. Similarly, with large numbers of properties some sort of <br>// hashing would be better than the sequential search used here. <br>// <br> <br>// Includes ------------------------------------------------------------------ <br> <br>#include "headers.h" <br> <br> <br> <br>// Struct containing the properties we know about. The GUID and string fields are <br>// initialized in the constructor, because C++ makes it awkward to do so at declaration <br>// time. So, if you change this table, be sure to make parallel changes in CUtilProp::CUtilProp. <br>PROPSTRUCT s_rgprop[] = <br>   { <br>        /* 0 */ {DBPROP_IAccessor,FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 1 */ {DBPROP_IColumnsInfo,FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 2 */ {DBPROP_IRowset,FLAGS_ROWSETRW,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 3 */ {DBPROP_IRowsetChange,FLAGS_ROWSETRW,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 4 */ {DBPROP_IRowsetInfo,FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 5 */ {DBPROP_DBMSNAME,FLAGS_DATASOURCE,VT_BSTR, FALSE,  0, NULL}, <br>        /* 6 */ {DBPROP_DBMSVER,FLAGS_DATASOURCE,VT_BSTR, FALSE,  0, NULL}, <br>        /* 7 */ {DBPROP_INIT_DATASOURCE,FLAGS_DBINITRW,VT_BSTR, FALSE,  0, NULL} <br>    }; <br> <br>PROPSTRUCT s_rgDBInitProp[] = <br>{ <br>        /* 0 */ {DBPROP_INIT_DATASOURCE,FLAGS_DBINITRW,VT_BSTR, FALSE,  0, NULL}, <br>}; <br> <br>PROPSTRUCT s_rgDataSourceInfoProp[] = <br>   { <br>        /* 0 */ {DBPROP_DBMSNAME,FLAGS_DATASOURCE,VT_BSTR, FALSE,  0, NULL}, <br>        /* 1 */ {DBPROP_DBMSVER,FLAGS_DATASOURCE,VT_BSTR, FALSE,  0, NULL} <br>    }; <br> <br>PROPSTRUCT s_rgRowsetProp[] = <br>   { <br>        /* 0 */ {DBPROP_IAccessor,FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 1 */ {DBPROP_IColumnsInfo,FLAGS_ROWSETRW,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 2 */ {DBPROP_IRowset,FLAGS_ROWSETRW,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 3 */ {DBPROP_IRowsetChange,FLAGS_ROWSETRW,     VT_BOOL, TRUE,   0, NULL}, <br>        /* 4 */ {DBPROP_IRowsetInfo,FLAGS_ROWSETRO,     VT_BOOL, TRUE,   0, NULL}, <br>    }; <br> <br>// Number of supported properties per property set <br>#defineNUMBER_OF_SUPPORTED_PROPERTY_SETS3 <br> <br>#define NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES1 <br>#defineNUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES2 <br>#defineNUMBER_OF_SUPPORTED_ROWSET_PROPERTIES5 <br> <br>#defineNUMBER_OF_SUPPORTED_PROPERTIES\ <br>(NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES +\ <br>NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES +\ <br>NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES) <br> <br> <br> <br>// Code ---------------------------------------------------------------------- <br> <br>// CUtilProp::CUtilProp ---------------------------------------------------------- <br>// <br>// @mfunc Constructor for this class <br>// <br>// @rdesc NONE <br>// <br>CUtilProp::CUtilProp <br>    ( <br>    void <br>    ) <br>{ <br>    // initialize the members of our global table that we couldn't initialize <br>    // in the declaration <br>s_rgprop[0].pwstrDescBuffer,L"IAccessor"; <br>s_rgprop[1].pwstrDescBuffer,L"IColumnsInfo"; <br>s_rgprop[2].pwstrDescBuffer,L"IRowset"; <br>s_rgprop[3].pwstrDescBuffer,L"IRowsetChange"; <br>s_rgprop[4].pwstrDescBuffer,L"IRowsetInfo"; <br> <br>    s_rgprop[5].pwstrVal = L"Sampprov"; <br>s_rgprop[5].pwstrDescBuffer,L"DBMS Name"; <br> <br>    s_rgprop[6].pwstrVal = L"00.99.0000"; <br>s_rgprop[6].pwstrDescBuffer,L"DBMS Version"; <br> <br>s_rgprop[7].pwstrVal = L""; <br>s_rgprop[7].pwstrDescBuffer,L"Data Source"; <br> <br>s_rgRowsetProp[0].pwstrDescBuffer,L"IAccessor"; <br>s_rgRowsetProp[1].pwstrDescBuffer,L"IColumnsInfo"; <br>s_rgRowsetProp[2].pwstrDescBuffer,L"IRowset"; <br>s_rgRowsetProp[3].pwstrDescBuffer,L"IRowsetChange"; <br>s_rgRowsetProp[4].pwstrDescBuffer,L"IRowsetInfo"; <br> <br>    s_rgDataSourceInfoProp[0].pwstrVal = L"Sampprov"; <br>s_rgDataSourceInfoProp[0].pwstrDescBuffer,L"DBMS Name"; <br> <br>    s_rgDataSourceInfoProp[1].pwstrVal = L"00.99.0000"; <br>s_rgDataSourceInfoProp[1].pwstrDescBuffer,L"DBMS Version"; <br> <br>s_rgDBInitProp[0].pwstrVal,L""; <br>s_rgDBInitProp[0].pwstrDescBuffer,L"Data Source"; <br> <br>    return; <br>} <br> <br> <br>// CUtilProp::~CUtilProp --------------------------------------------------------- <br>// <br>// @mfunc Destructor for this class <br>// <br>// @rdesc NONE <br>// <br>CUtilProp:: ~CUtilProp <br>    ( <br>    void <br>    ) <br>{ <br>if ( s_rgDBInitProp[0].pwstrVal ) <br>g_pIMalloc-&gt;Free( s_rgDBInitProp[0].pwstrVal ); <br> <br>    return; <br>} <br> <br> <br> <br>// CUtilProp::GetPropIndex ---------------------------------------------------- <br>// <br>// @mfunc Returns index of the given property in our global table of properties <br>// <br>// @rdesc BOOL <br>//      @flag TRUE      | found match, copied it to pulIndex out-param <br>//      @flag FALSE     | no match. In this case, pulIndex has no meaning <br>// <br>BOOL CUtilProp::GetPropIndex <br>    ( <br>DBPROPIDdwPropertyID,   //@parm IN  | PROPID of desired property <br>    ULONG*pulIndex//@parm OUT | index of desired property if return was TRUE <br>    ) <br>{ <br>    ULONG cNumberOfProperties; <br>    assert( pulIndex ); <br> <br>    for (cNumberOfProperties = 0;  <br>cNumberOfProperties &lt; NUMBER_OF_SUPPORTED_PROPERTIES;  <br>cNumberOfProperties++) <br>    { <br>        if (dwPropertyID == s_rgprop[cNumberOfProperties].dwPropertyID ) <br>        { <br>            // found a match <br>            *pulIndex = cNumberOfProperties; <br>            return TRUE; <br>         } <br>    } <br>    // found no matches <br>    return FALSE; <br>} <br> <br> <br> <br>// CUtilProp::LoadDBPROPINFO  ---------------------------------------------------- <br>// <br>// @mfunc Helper for GetPropertyInfo. Loads field of DBPROPINFO structure. <br>// <br>// @rdesc BOOL <br>//      @flag TRUE          | Method succeeded <br>//      @flag FALSE         | Method failed (couldn't allocate memory) <br>// <br>BOOL CUtilProp::LoadDBPROPINFO <br>    ( <br>    PROPSTRUCT*pPropStruct, <br>    DBPROPINFO*pPropInfo <br>    ) <br>{ <br>    // asserts <br>    assert( pPropStruct ); <br>    assert( pPropInfo ); <br> <br>    // init the variant <br>    VariantInit( &amp;pPropInfo-&gt;vValues ); <br> <br>    // set the easy fields.. <br>    pPropInfo-&gt;dwPropertyID= pPropStruct-&gt;dwPropertyID; <br>    pPropInfo-&gt;dwFlags= pPropStruct-&gt;dwFlags; <br>    pPropInfo-&gt;vtType= pPropStruct-&gt;vtType; <br> <br>    switch (pPropStruct-&gt;vtType) <br>    { <br>    case VT_BOOL: <br>V_VT( &amp;pPropInfo-&gt;vValues ) = VT_BOOL; <br>V_BOOL( &amp;pPropInfo-&gt;vValues ) = pPropStruct-&gt;boolVal; <br>break; <br>         <br>case VT_I4: <br>V_VT( &amp;pPropInfo-&gt;vValues ) = VT_I4; <br>V_I4( &amp;pPropInfo-&gt;vValues ) = pPropStruct-&gt;longVal; <br>break; <br>         <br>case VT_BSTR: <br>V_VT( &amp;pPropInfo-&gt;vValues ) = VT_BSTR; <br> <br>V_BSTR( &amp;pPropInfo-&gt;vValues ) = SysAllocString( pPropStruct-&gt;pwstrVal ); <br> <br>if (NULL == V_BSTR( &amp;pPropInfo-&gt;vValues )) <br>            { <br>VariantClear( &amp;pPropInfo-&gt;vValues ); <br>return FALSE; <br>            } <br>break; <br>         <br>default: <br>assert( !"LoadDBPROPINFO unknown variant type!\n\r" ); <br>break; <br>       } <br>    // all went well <br>    return TRUE; <br>} <br> <br> <br>// CUtilProp::LoadDBPROP  ---------------------------------------------------- <br>// <br>// @mfunc Helper for GetProperties. Loads field of DBPROP structure. <br>// <br>// @rdesc BOOL <br>//      @flag TRUE          | Method succeeded <br>//      @flag FALSE         | Method failed (couldn't allocate memory) <br>// <br>BOOL CUtilProp::LoadDBPROP <br>    ( <br>    PROPSTRUCT*pPropStruct, <br>    DBPROP*pPropSupport <br>    ) <br>{ <br>    // asserts <br>    assert( pPropStruct ); <br>    assert( pPropSupport ); <br> <br>    // init the variant <br>    VariantInit( &amp;pPropSupport-&gt;vValue ); <br> <br>    // set the easy fields.. <br>    pPropSupport-&gt;dwPropertyID  = pPropStruct-&gt;dwPropertyID; <br>    pPropSupport-&gt;colid= DB_NULLID; <br> <br>    // set pPropSupport-&gt;vValue based on Variant type <br>    switch (pPropStruct-&gt;vtType) <br>    { <br>    case VT_BOOL: <br>V_VT( &amp;pPropSupport-&gt;vValue ) = VT_BOOL; <br>V_BOOL( &amp;pPropSupport-&gt;vValue ) = pPropStruct-&gt;boolVal; <br>break; <br>         <br>    case VT_I4: <br>    V_VT( &amp;pPropSupport-&gt;vValue ) = VT_I4; <br>V_I4( &amp;pPropSupport-&gt;vValue ) = pPropStruct-&gt;longVal; <br>break; <br>         <br>    case VT_BSTR: <br>    V_VT( &amp;pPropSupport-&gt;vValue ) = VT_BSTR; <br> <br>V_BSTR( &amp;pPropSupport-&gt;vValue ) = SysAllocString( pPropStruct-&gt;pwstrVal ); <br> <br>        if (NULL == V_BSTR( &amp;pPropSupport-&gt;vValue )) <br>            { <br>VariantClear( &amp;pPropSupport-&gt;vValue ); <br>return FALSE; <br>            } <br>break; <br>         <br>default: <br>assert( !"LoadDBPROP unknown variant type!\n\r" ); <br>break; <br>    } <br>    // all went well <br>    return TRUE; <br>} <br> <br> <br> <br>// CUtilProp::GetPropertyInfo  ----------------------------------------- <br>// <br>// @mfuncReturns information about rowset and data source properties  <br>//supported by the provider <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK          | The method succeeded <br>//      @flag E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL <br>//      @flag E_OUTOFMEMORY | Out of memory <br>// <br> <br>STDMETHODIMP CUtilProp::GetPropertyInfo <br>    ( <br>    ULONGcPropertyIDSets,//@parm IN | # properties <br>    const DBPROPIDSETrgPropertyIDSets[],//@parm IN | Array of property sets <br>ULONG*pcPropertyInfoSets,//@parm OUT | # DBPROPSET structures <br>DBPROPINFOSET**prgPropertyInfoSets,//@parm OUT | DBPROPSET structures property  <br>//| information returned <br>WCHAR**ppDescBuffer//@parm OUT| Property descriptions <br>    ) <br>{ <br>    ULONGcNumberOfPropertySets, cNumberOfProperties; <br>ULONGcCount; <br>    ULONGcProps = 0; <br>    DBPROPINFO*pPropInfo; <br>    DBPROPINFOSET*pPropInfoSet; <br>    BOOLfRet; <br> <br>    // asserts <br>    assert( s_rgprop ); <br> <br>    // check params <br>    if (!pcPropertyInfoSets || !prgPropertyInfoSets) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    if ((cPropertyIDSets != 0) &amp;&amp; !rgPropertyIDSets) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // if no restriction array, count our properties <br>    if (cPropertyIDSets == 0) <br>    { <br>        cProps = NUMBER_OF_SUPPORTED_PROPERTY_SETS; <br>    } <br>    // restriction array specified, so get the count <br>    else <br>    { <br>        if (cPropertyIDSets &gt; NUMBER_OF_SUPPORTED_PROPERTY_SETS) <br>return ( E_INVALIDARG ); <br>else <br>cProps = cPropertyIDSets; <br>    } <br> <br>    // init out params <br>    *pcPropertyInfoSets= 0; <br>    *prgPropertyInfoSets= NULL; <br> <br>    // use task memory allocater to alloc a DBPROPINFOSET struct <br>    pPropInfoSet = (DBPROPINFOSET*) g_pIMalloc-&gt;Alloc <br>(cProps * <br>sizeof( DBPROPINFOSET )); <br>    if (!pPropInfoSet) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    memset( pPropInfoSet, 0, (cProps * sizeof( DBPROPINFOSET ))); <br> <br> <br>// For each supported Property Set <br>for (cNumberOfPropertySets=0; cNumberOfPropertySets &lt; cProps; cNumberOfPropertySets++) <br>{ <br> <br>// If no restrictions return all properties from the three supported property sets <br>if (cPropertyIDSets == 0) <br>{ <br>if (cNumberOfPropertySets == 0) <br>pPropInfoSet[cNumberOfPropertySets].guidPropertySet = DBPROPSET_DBINIT; <br>else if (cNumberOfPropertySets == 1) <br>pPropInfoSet[cNumberOfPropertySets].guidPropertySet = DBPROPSET_DATASOURCEINFOALL; <br>else if (cNumberOfPropertySets == 2) <br>pPropInfoSet[cNumberOfPropertySets].guidPropertySet = DBPROPSET_ROWSET; <br>} <br>else  <br>{ <br>pPropInfoSet[cNumberOfPropertySets].guidPropertySet =  <br>rgPropertyIDSets[cNumberOfPropertySets].guidPropertySet; <br>} <br> <br>// Check supported property sets <br>if (IsEqualGUID(pPropInfoSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_DBINIT)) <br>{ <br>cNumberOfProperties = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES; <br>} <br>else if (IsEqualGUID(pPropInfoSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_DATASOURCEINFOALL)) <br>{ <br>cNumberOfProperties = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES; <br>} <br>else if (IsEqualGUID(pPropInfoSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_ROWSET)) <br>{ <br>cNumberOfProperties = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES; <br>} <br>else  <br>{ <br>cNumberOfProperties = 0; <br>} <br> <br>if (0 != cNumberOfProperties) <br>{ <br>    // use task memory allocater to alloc array of DBPROPINFO structs <br>pPropInfo = (DBPROPINFO*) g_pIMalloc-&gt;Alloc <br>( cNumberOfProperties *  <br>sizeof( DBPROPINFO )); <br> <br>if (!pPropInfo) <br>return ResultFromScode( E_OUTOFMEMORY ); <br> <br>memset( pPropInfo, 0,  <br>(cNumberOfProperties * sizeof( DBPROPINFO ))); <br>} <br> <br>    // for each prop in our table.. <br>for (cCount=0; cCount &lt; cNumberOfProperties; cCount++) <br>{ <br> <br>// init the Variant right up front <br>// that way we can VariantClear with no worried (if we need to) <br>VariantInit( &amp;pPropInfo[cCount].vValues ); <br> <br>// Check supported property sets <br>if (IsEqualGUID(pPropInfoSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_DBINIT)) <br>{ <br>// load up their DBPROPINFO from our table <br>fRet = LoadDBPROPINFO( &amp;s_rgDBInitProp[cCount], &amp;pPropInfo[cCount] ); <br>} <br>else if (IsEqualGUID(pPropInfoSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_DATASOURCEINFOALL)) <br>{ <br>// load up their DBPROPINFO from our table <br>fRet = LoadDBPROPINFO( &amp;s_rgDataSourceInfoProp[cCount], &amp;pPropInfo[cCount] ); <br>} <br>else if (IsEqualGUID(pPropInfoSet[cNumberOfPropertySets].guidPropertySet, <br>DBPROPSET_ROWSET)) <br>{ <br>// load up their DBPROPINFO from our table <br>fRet = LoadDBPROPINFO( &amp;s_rgRowsetProp[cCount], &amp;pPropInfo[cCount] ); <br>} <br> <br>if (!fRet) <br>{ <br>ULONG ulFor; <br> <br>// something went wrong <br>// clear all variants used so far.. <br>for (ulFor = 0; ulFor &lt; cCount; ulFor++) <br>{ <br>VariantClear( &amp;pPropInfo[ulFor].vValues ); <br>} <br>// .. delete the pPropInfo array, return failure <br>g_pIMalloc-&gt;Free( pPropInfo ); <br>return ResultFromScode( E_OUTOFMEMORY ); <br>} <br>pPropInfoSet[cNumberOfPropertySets].rgPropertyInfos[cCount] =  <br>pPropInfo[cCount]; <br>}// for each property <br>}// for each property set <br> <br>// set count of properties and property information <br>    *pcPropertyInfoSets= cProps; <br>    *prgPropertyInfoSets= pPropInfoSet; <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br>// CUtilProp::GetProperties ---------------------------------------------------- <br>// <br>// @mfunc Returns current settings of all properties supported by the DSO/rowset <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK          | The method succeeded <br>//      @flag E_INVALIDARG  | pcProperties or prgPropertyInfo was NULL <br>//      @flag E_OUTOFMEMORY | Out of memory <br>// <br>STDMETHODIMP CUtilProp::GetProperties <br>    ( <br>ULONGcPropertyIDSets,//@parm IN | # of restiction property IDs <br>const DBPROPIDSETrgPropertyIDSets[],//@parm IN | restriction guids <br>ULONG*              pcPropertySets,//@parm OUT | count of properties returned <br>DBPROPSET**prgPropertySets//@parm OUT | property information returned <br>    ) <br>{ <br>    ULONGcNumberOfPropertySets, cNumberOfProperties; <br>ULONGcCount; <br>    ULONGcProps = 0; <br>    DBPROP*pProp; <br>    DBPROPSET*pPropSet; <br>    BOOLfRet; <br> <br>    // asserts <br>    assert( s_rgprop ); <br> <br>    // check params <br>    if (!pcPropertySets || !prgPropertySets) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    if ((cPropertyIDSets != 0) &amp;&amp; !rgPropertyIDSets) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // if no restriction array, count our properties <br>    if (cPropertyIDSets == 0) <br>    { <br>        cProps = NUMBER_OF_SUPPORTED_PROPERTY_SETS; <br>    } <br>    // restriction array specified, so get the count <br>    else <br>    { <br>        if (cPropertyIDSets &gt; NUMBER_OF_SUPPORTED_PROPERTY_SETS) <br>return ( E_INVALIDARG ); <br>else <br>cProps = cPropertyIDSets; <br>    } <br> <br>    // init out params <br>    *pcPropertySets= 0; <br>    *prgPropertySets= NULL; <br> <br>    // use task memory allocater to alloc a DBPROPINFOSET struct <br>    pPropSet = (DBPROPSET*) g_pIMalloc-&gt;Alloc <br>(cProps * <br>sizeof( DBPROPSET )); <br>    if (!pPropSet) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    memset( pPropSet, 0, (cProps * sizeof( DBPROPSET ))); <br> <br> <br>// For each supported Property Set <br>for (cNumberOfPropertySets=0; cNumberOfPropertySets &lt; cProps; cNumberOfPropertySets++) <br>{ <br> <br>// If no restrictions return all properties from the two supported property sets <br>if (cPropertyIDSets == 0) <br>{ <br>if (cNumberOfPropertySets == 0) <br>pPropSet[cNumberOfPropertySets].guidPropertySet = DBPROPSET_DATASOURCEINFOALL; <br>else if (cNumberOfPropertySets == 1) <br>pPropSet[cNumberOfPropertySets].guidPropertySet = DBPROPSET_ROWSET; <br>} <br>else  <br>{ <br>pPropSet[cNumberOfPropertySets].guidPropertySet =  <br>rgPropertyIDSets[cNumberOfPropertySets].guidPropertySet; <br>} <br> <br>// Check supported property sets <br>if (IsEqualGUID(pPropSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_DBINIT)) <br>{ <br>cNumberOfProperties = NUMBER_OF_SUPPORTED_DBINIT_PROPERTIES; <br>} <br>else if (IsEqualGUID(pPropSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_DATASOURCEINFOALL)) <br>{ <br>cNumberOfProperties = NUMBER_OF_SUPPORTED_DATASOURCEINFO_PROPERTIES; <br>} <br>else if (IsEqualGUID(pPropSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_ROWSET)) <br>{ <br>cNumberOfProperties = NUMBER_OF_SUPPORTED_ROWSET_PROPERTIES; <br>} <br>else  <br>{ <br>cNumberOfProperties = 0; <br>} <br> <br>if (0 != cNumberOfProperties) <br>{ <br>    // use task memory allocater to alloc array of DBPROP structs <br>pProp = (DBPROP*) g_pIMalloc-&gt;Alloc <br>( cNumberOfProperties *  <br>sizeof( DBPROP )); <br> <br>if (!pProp) <br>{ <br>g_pIMalloc-&gt;Free( pPropSet ); <br>return ResultFromScode( E_OUTOFMEMORY ); <br>} <br> <br>memset( pProp, 0,  <br>(cNumberOfProperties * sizeof( DBPROP ))); <br>} <br> <br>    // for each prop in our table.. <br>for (cCount=0; cCount &lt; cNumberOfProperties; cCount++) <br>{ <br> <br>// init the Variant right up front <br>// that way we can VariantClear with no worried (if we need to) <br>VariantInit( &amp;pProp[cCount].vValue ); <br> <br>// Check supported property sets <br>if (IsEqualGUID(pPropSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_DBINIT)) <br>{ <br>// load up their DBPROP from our table <br>fRet = LoadDBPROP( &amp;s_rgDBInitProp[cCount], &amp;pProp[cCount] ); <br>} <br>else if (IsEqualGUID(pPropSet[cNumberOfPropertySets].guidPropertySet,  <br>DBPROPSET_DATASOURCEINFOALL)) <br>{ <br>// load up their DBPROP from our table <br>fRet = LoadDBPROP( &amp;s_rgDataSourceInfoProp[cCount], &amp;pProp[cCount] ); <br>} <br>else if (IsEqualGUID(pPropSet[cNumberOfPropertySets].guidPropertySet, <br>DBPROPSET_ROWSET)) <br>{ <br>// load up their DBPROP from our table <br>fRet = LoadDBPROP( &amp;s_rgRowsetProp[cCount], &amp;pProp[cCount] ); <br>} <br> <br>if (!fRet) <br>{ <br>ULONG ulFor; <br> <br>// something went wrong <br>// clear all variants used so far.. <br>for (ulFor = 0; ulFor &lt; cCount; ulFor++) <br>{ <br>VariantClear( &amp;pProp[ulFor].vValue ); <br>} <br>// .. delete the pProp array, return failure <br>g_pIMalloc-&gt;Free( pProp ); <br>g_pIMalloc-&gt;Free( pPropSet ); <br>return ResultFromScode( E_OUTOFMEMORY ); <br>} <br>}// for each property <br>pPropSet[cNumberOfPropertySets].rgProperties = pProp; <br>}// for each property set <br> <br>// set count of properties and property information <br>    *pcPropertySets= cProps; <br>    *prgPropertySets= pPropSet; <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>// CUtilProp::SetProperties ---------------------------------------------------- <br>// <br>// @mfunc Set current settings of properties supported by the DSO/rowset <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK          | The method succeeded <br>//      @flag E_INVALIDARG  | pcProperties or prgPropertyInfo was NULL <br>//      @flag E_OUTOFMEMORY | Out of memory <br>// <br>STDMETHODIMP CUtilProp::SetProperties <br>    ( <br>ULONGcPropertyIDSets,//@parm IN# of DBPROPSET <br>DBPROPSETrgPropertyIDSets[]//@parm INOUTArray of property sets <br>) <br>{ <br>// Quick Exit with 0 PropertyIDSets <br>if ( cPropertyIDSets == 0 ) <br>return ResultFromScode( S_OK ); <br> <br>    // Check params <br>    if ((0 != cPropertyIDSets) &amp;&amp; (NULL == rgPropertyIDSets)) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    if (1 != cPropertyIDSets) <br>        return ResultFromScode( E_FAIL ); <br> <br>    if (!IsEqualGUID(rgPropertyIDSets[0].guidPropertySet,DBPROPSET_DBINIT)) <br>        return ResultFromScode( E_FAIL ); <br> <br>if (rgPropertyIDSets[0].cProperties == 0) <br>return ResultFromScode( S_OK ); <br> <br>// If rg.cProperties is not 0 and rg.rgProperties is NULL, this is <br>// an error. <br>if (rgPropertyIDSets[0].rgProperties == NULL) <br>return ResultFromScode(E_INVALIDARG); <br> <br>switch(rgPropertyIDSets[0].rgProperties-&gt;dwPropertyID) <br>{ <br>case DBPROP_INIT_DATASOURCE: <br> <br>    // get the directory path string and convert it to ANSI <br>s_rgDBInitProp[0].pwstrVal = (WCHAR *) g_pIMalloc-&gt;Alloc(MAX_PATH); <br> <br>WideCharToMultiByte( CP_ACP, 0, V_BSTR( &amp;rgPropertyIDSets[0].rgProperties-&gt;vValue ), -1, <br>                 (char *)s_rgDBInitProp[0].pwstrVal, MAX_PATH, NULL, NULL ); <br> <br>return ResultFromScode( S_OK ); <br>} <br>return ResultFromScode( E_FAIL ); <br>} <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
