<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IROWSET.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2336"></a>IROWSET.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module IROWSET.CPP | IRowset interface implementation <br>// <br>// <br> <br>// Includes ------------------------------------------------------------------ <br> <br>#include "headers.h" <br> <br>// Code ---------------------------------------------------------------------- <br> <br>//  IRowset specific interface methods <br> <br>// CImpIRowset::GetData -------------------------------------------------- <br>// <br>// @mfunc Retrieves data from the rowset's cache <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                   | Method Succeeded <br>//      @flag DB_S_ERRORSOCCURED     | Could not coerce a column value <br>//      @flag DB_E_BADACCESSORHANDLE | Invalid Accessor given <br>//      @flag DB_E_BADROWHANDLE      | Invalid row handle given <br>//      @flag E_INVALIDARG           | pData was NULL <br>//      @flag OTHER                  | Other HRESULTs returned by called functions <br>// <br>STDMETHODIMP CImpIRowset::GetData <br>    ( <br>    HROW        hRow,       //@parm IN | Row Handle <br>    HACCESSOR   hAccessor,  //@parm IN | Accessor to use <br>    void       *pData       //@parm OUT | Pointer to buffer where data should go. <br>    ) <br>{ <br>    PACCESSOR   pAccessor; <br>    ULONG       icol, ibind; <br>    ROWBUFF     *pRowBuff; <br>    COLUMNDATA  *pColumnData; <br>    DBBINDING   *pBinding; <br>    ULONG       cBindings; <br>    ULONG       ulErrorCount; <br>    DBTYPE      dwSrcType; <br>    DBTYPE      dwDstType; <br>    void        *pSrc; <br>    void        *pDst; <br>    ULONG       ulSrcLength; <br>    ULONG       *pulDstLength; <br>    ULONG       ulDstMaxLength; <br>    DWORD       dwSrcStatus; <br>    DWORD       *pdwDstStatus; <br>    DWORD       dwPart; <br>    HRESULT     hr; <br> <br>    // Coerce data for row 'hRow', according to hAccessor. <br>    // Put in location 'pData'.  Offsets and types are in hAccessor's bindings. <br>    // <br>    // Return S_OK if all lossless conversions, <br>    // return DB_S_ERRORSOCCURED if lossy conversion (truncation, rounding, etc.) <br>    // Return E_FAIL, etc., if horrible errors. <br> <br>    // GetItemOfExtBuffer is basically operator[]. <br>    // It takes an index (or handle) (referenced from 1...n), <br>    // and a ptr for where to write the data. <br>    // <br>    // It holds ptrs to a variable-length ACCESSOR struct. <br>    // So we get the ACCESSOR ptr for the client's accessor handle. <br> <br>    assert( m_pObj-&gt;m_pextbufferAccessor ); <br>    hr = m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;pAccessor ); <br>    if (FAILED( hr ) || pAccessor == NULL) <br>        return ResultFromScode( DB_E_BADACCESSORHANDLE ); <br> <br>    assert( pAccessor ); <br>    cBindings = pAccessor-&gt;cBindings; <br>    pBinding  = pAccessor-&gt;rgBindings; <br> <br>    // IsSlotSet returns S_OK    if row is marked. <br>    //                   S_FALSE if row is not marked. <br>    // The "mark" means that there is data present in the row. <br>    // Rows are [1...n], slot marks are [0...n-1]. <br>    if (m_pObj-&gt;m_prowbitsIBuffer-&gt;IsSlotSet((ULONG) hRow ) != S_OK) <br>        return ResultFromScode( DB_E_BADROWHANDLE ); <br> <br>    // Ensure a place to put data. <br>    if (pData == NULL) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    pRowBuff = m_pObj-&gt;GetRowBuff((ULONG) hRow ); <br> <br>    // Internal error for a 0 reference count on this row, <br>    // since we depend on the slot-set stuff. <br>    assert( pRowBuff-&gt;ulRefCount ); <br> <br> <br>    ulErrorCount = 0; <br>    for (ibind = 0; ibind &lt; cBindings; ibind++) <br>        { <br>        icol = pBinding[ibind].iOrdinal; <br>        pColumnData = (COLUMNDATA *) ((BYTE *) pRowBuff + m_pObj-&gt;m_rgdwDataOffsets[icol]); <br> <br>        dwSrcType      = m_pObj-&gt;m_rgdbcolinfo[icol].wType; <br>        pSrc           = &amp;(pColumnData-&gt;bData); <br>        ulSrcLength    = pColumnData-&gt;dwLength; <br>        dwSrcStatus    = pColumnData-&gt;dwStatus; <br>        ulDstMaxLength = pBinding[ibind].cbMaxLen; <br>        dwDstType      = pBinding[ibind].wType; <br>        dwPart         = pBinding[ibind].dwPart; <br> <br>        pDst           = dwPart &amp; DBPART_VALUE ? ((BYTE*) pData + pBinding[ibind].obValue) : NULL; <br>        pulDstLength   = dwPart &amp; DBPART_LENGTH ? (ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) : NULL; <br>        pdwDstStatus   = dwPart &amp; DBPART_STATUS ? (ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) : NULL; <br> <br>        hr = g_pIDataConvert-&gt;DataConvert( <br>                dwSrcType, <br>                dwDstType, <br>                ulSrcLength, <br>                pulDstLength, <br>                pSrc, <br>                pDst, <br>                ulDstMaxLength, <br>                dwSrcStatus, <br>                pdwDstStatus, <br>                0,// bPrecision for conversion to DBNUMERIC <br>0,// bScale for conversion to DBNUMERIC <br>DBDATACONVERT_DEFAULT); <br>        if (FAILED( hr )) <br>            return hr;  // fatal error <br>        if (hr != ResultFromScode( S_OK )) <br>            ulErrorCount++; // can't coerce <br>        } <br> <br>    // We report any lossy conversions with a special status. <br>    // Note that DB_S_ERRORSOCCURED is a success, rather than failure. <br>    return ResultFromScode( ulErrorCount ? DB_S_ERRORSOCCURRED : S_OK ); <br>} <br> <br> <br> <br>// CImpIRowset::GetNextRows -------------------------------------------------- <br>// <br>// @mfunc Fetches rows in a sequential style, remembering the previous position <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                      | Method Succeeded <br>//      @flag DB_S_ENDOFROWSET          | Reached end of rowset <br>//      @flag DB_E_CANTFETCHBACKWARDS   | cRows was negative and we can't fetch backwards <br>//      @flag DB_E_ROWSNOTRELEASED      | Must release all HROWs before calling GetNextRows <br>//      @flag E_FAIL                    | Provider-specific error <br>//      @flag E_INVALIDARG              | pcRowsObtained or prghRows was NULL <br>//      @flag E_OUTOFMEMORY             | Out of Memory <br>//      @flag OTHER                     | Other HRESULTs returned by called functions <br>// <br>STDMETHODIMP CImpIRowset::GetNextRows <br>    ( <br>    HCHAPTER   hReserved,       //@parm IN | Reserved for future use. Ingored. <br>    LONG       cRowsToSkip,     //@parm IN | Rows to skip before reading <br>    LONG       cRows,           //@parm IN | Number of rows to fetch <br>    ULONG      *pcRowsObtained, //@parm OUT | Number of rows obtained <br>    HROW       **prghRows       //@parm OUT | Array of Hrows obtained <br>    ) <br>{ <br>    ULONG    cRowsTmp; <br>    BOOL     fExtraRow; <br>    ULONG    cSlotAlloc =0; <br>    ULONG    di; <br>    LONG     irow, ih; <br>    ULONG    irowFirst, irowLast; <br>    PROWBUFF prowbuff; <br>    HRESULT  hr; <br>    BYTE     *pbRowFirst; <br> <br> <br>    // Check validity of arguments. <br>    if (pcRowsObtained == NULL || prghRows == NULL) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // init out-params <br>    *pcRowsObtained = 0; <br> <br>    // No-op case always succeeds. <br>    if (cRows == 0 &amp;&amp; cRowsToSkip == 0) <br>        return ResultFromScode( S_OK ); <br> <br>    // This implementation doesn't support scrolling backward. <br>    if (cRows &lt; 0 || cRowsToSkip &lt; 0) <br>        return ResultFromScode( DB_E_CANTFETCHBACKWARDS ); <br> <br>    // Are there any unreleased rows? <br>    if ((m_pObj-&gt;m_prowbitsIBuffer)-&gt;ArrayEmpty() != S_OK) <br>        return ResultFromScode( DB_E_ROWSNOTRELEASED ); <br>    assert( m_pObj-&gt;m_ulRowRefCount == 0 ); // should be true since array was empty <br> <br>    // Is the cursor fully materialized (end-of-cursor condition)? <br>    if (m_pObj-&gt;m_dwStatus &amp; STAT_ENDOFCURSOR) <br>        return ResultFromScode( DB_S_ENDOFROWSET ); <br> <br>    assert( m_pObj-&gt;m_rgbRowData ); <br>    if (FAILED( m_pObj-&gt;Rebind((BYTE *) m_pObj-&gt;GetRowBuff( m_pObj-&gt;m_irowMin )))) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Sometimes we need an extra row to fetch data and copy it to appropriate place. <br>    fExtraRow = (cRows &gt; 1); <br>    cRowsTmp = cRows + (fExtraRow ? 1 : 0); <br> <br> <br>    if (FAILED( hr = GetNextSlots( m_pObj-&gt;m_pIBuffer, cRowsTmp, &amp;irowFirst ))) <br>        return hr; <br>    cSlotAlloc = cRowsTmp; <br> <br>    // <br>    // Fetch Data <br>    // <br>    if (cRowsToSkip) <br>        { <br>        // Calculate the new position <br>        m_pObj-&gt;m_irowFilePos += cRowsToSkip; <br> <br>        // Check if skip causes END_OF_ROWSET <br>        if (m_pObj-&gt;m_irowFilePos &gt; m_pObj-&gt;m_pFileio-&gt;GetRowCnt() || <br>            m_pObj-&gt;m_irowFilePos &lt;= 0) <br>            { <br>            m_pObj-&gt;m_dwStatus |= STAT_ENDOFCURSOR; <br>            return ResultFromScode( DB_S_ENDOFROWSET ); <br>            } <br>        } <br> <br>    pbRowFirst = (BYTE *) m_pObj-&gt;GetRowBuff( irowFirst ); <br>    for (irow =1; irow &lt;= cRows; irow++) <br>        { <br>        // Get the Data from the File into the row buffer <br>        if (S_FALSE == (hr =  m_pObj-&gt;m_pFileio-&gt;Fetch( m_pObj-&gt;m_irowFilePos + irow ))) <br>            { <br>            m_pObj-&gt;m_dwStatus |= STAT_ENDOFCURSOR; <br>            break; <br>            } <br>        else <br>            { <br>            if (FAILED( hr )) <br>                return ResultFromScode( E_FAIL ); <br>            } <br> <br>        // Got a row, so copy it from bound row to the destination. <br>        // Very first row is Fetch buffer, we give out rows [2...cRows+1]. <br>        if (fExtraRow) <br>            memcpy( pbRowFirst + (m_pObj-&gt;m_cbRowSize * irow), pbRowFirst, m_pObj-&gt;m_cbRowSize ); <br>        } <br> <br>    cRowsTmp = irow - 1; //Irow will be +1 because of For Loop <br>    m_pObj-&gt;m_irowLastFilePos = m_pObj-&gt;m_irowFilePos; <br>    m_pObj-&gt;m_irowFilePos += cRowsTmp; <br> <br> <br>    // <br>    // Through fetching many rows of data <br>    // <br>    // Allocate row handles for client. <br>    // Note that we need to use IMalloc for this. <br>    // <br>    // Should only malloc cRowsTmp, instead of cRows. <br>    // <br>    // Modified to use IMalloc. <br>    // Should malloc cRows, since client will assume it's that big. <br>    // <br> <br>    *pcRowsObtained = cRowsTmp; <br>    if (*prghRows == NULL) <br>        { <br>        *prghRows = (HROW *) g_pIMalloc-&gt;Alloc( cRows*sizeof( HROW )); <br>        } <br> <br>    if (NULL == *prghRows) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    // <br>    // Fill in the status information: Length, IsNull <br>    // May be able to wait until first call to GetData, <br>    // but have to do it sometime. <br>    // <br>    // Suggest keeping an array of structs of accessor info. <br>    // One element is whether accessor requires any status info or length info. <br>    // Then we could skip this whole section. <br>    // <br>    // Added check for cRowsTmp to MarkRows call. <br>    // Don't want to call if cRowsTmp==0. <br>    // (Range passed to MarkRows is inclusive, so can't specify marking 0 rows.) <br>    // <br>    // Note that SetSlots is a CBitArray member function -- not an IBuffer function. <br>    // <br>    // Bits are [0...n-1], row handles are [1...n]. <br>    // <br>    // Cleanup. Row handles, bits, indices are the same [m....(m+n)], where m is some # &gt;0, <br>    // <br>    // Added row-wise reference counts and cursor-wise reference counts. <br>    // <br> <br>    // Set row handles, fix data length field and compute data status field.// <br>    di = fExtraRow ? 1 : 0; <br>    m_pObj-&gt;m_cRows   = cRowsTmp; <br>    irowLast = irowFirst + di + cRowsTmp - 1; <br> <br>    // Cleanup extra slots where no hRow actually was put.. <br>    //  ** Because of less rows than asked for <br>    //  ** Because of temporary for for data transfer. <br>    if (fExtraRow) <br>        if (FAILED( hr = ReleaseSlots( m_pObj-&gt;m_pIBuffer, irowFirst, 1 ))) <br>            return hr; <br>    if (cSlotAlloc &gt; (cRowsTmp + di)) <br>        if (FAILED( hr = ReleaseSlots( m_pObj-&gt;m_pIBuffer, irowFirst + cRowsTmp + di, (cSlotAlloc - cRowsTmp - di)))) <br>            return hr; <br> <br>    for (irow = (LONG) (irowFirst + di), ih =0; irow &lt;= (LONG) irowLast; irow++, ih++) <br>        { <br>        // Increment the rows-read count, <br>        // then store it as the bookmark in the very first DWORD of the row. <br> <br>        prowbuff = m_pObj-&gt;GetRowBuff( irow ); <br> <br>        // Insert the bookmark and its row number (from 1...n) into a hash table. <br>        // This allows us to quickly determine the presence of a row in mem, given the bookmark. <br>        // The bookmark is contained in the row buffer, at the very beginning. <br>        // Bookmark is the row number within the entire result set [1...num_rows_read]. <br> <br>        // This was a new Bookmark, not in memory, <br>        // so return to user (in *prghRows) the hRow we stored. <br>        prowbuff-&gt;ulRefCount++; <br>        prowbuff-&gt;pbBmk = (BYTE*) m_pObj-&gt;m_irowLastFilePos + ih + 1; <br>        m_pObj-&gt;m_ulRowRefCount++; <br> <br>        (*prghRows)[ih] = (HROW) (irow); <br>        } <br> <br>    if (m_pObj-&gt;m_dwStatus &amp; STAT_ENDOFCURSOR) <br>        return ResultFromScode( DB_S_ENDOFROWSET ); <br>    else <br>        return ResultFromScode( S_OK ); <br>} <br> <br> <br> <br>// CImpIRowset::ReleaseRows --------------------------------------- <br>// <br>// @mfunc Releases row handles <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK              | Method Succeeded <br>//      @flag E_INVALIDARG      | Invalid parameters were specified <br>//      @flag DB_E_BADROWHANDLE | Row handle was invalid <br>// <br>STDMETHODIMP CImpIRowset::ReleaseRows <br>    ( <br>    ULONGcRow,           //@parm IN | Number of rows to release <br>    const HROWrghRow[],       //@parm IN | Array of handles of rows to be released <br>DBROWOPTIONSrgRowOptions[],//@parm IN | Additional Options <br>    ULONG*pcRowReleased, //@parm OUT | Count of rows actually released <br>    ULONGrgRefCount[]    //@parm OUT | Array of refcnts for the rows <br>    ) <br>{ <br>    ULONG   ihRow; <br>    BOOL    fEncounteredError; <br>    ROWBUFF *pRowBuff; <br>    ULONG   cRowReleased = 0; <br> <br> <br>    // check params <br>    if (cRow &amp;&amp; !rghRow) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // init out param <br>    if (pcRowReleased) <br>        *pcRowReleased = 0; <br> <br>    fEncounteredError = FALSE; <br>    ihRow = 0; <br> <br>    while (ihRow &lt; cRow) <br>        { <br>        if ((m_pObj-&gt;m_prowbitsIBuffer)-&gt;IsSlotSet((ULONG) rghRow[ihRow] ) == S_OK) <br>            { <br>            // Found valid row, so decrement reference counts. <br>            // (Internal error for refcount to be 0 here, since slot set.) <br>            pRowBuff = m_pObj-&gt;GetRowBuff((ULONG) rghRow[ihRow] ); <br>            assert( pRowBuff-&gt;ulRefCount != 0 ); <br>            assert( m_pObj-&gt;m_ulRowRefCount != 0 ); <br>            --pRowBuff-&gt;ulRefCount; <br>            --m_pObj-&gt;m_ulRowRefCount; <br> <br>            if (rgRefCount) <br>                rgRefCount[ihRow] = pRowBuff-&gt;ulRefCount; <br> <br>            if (pRowBuff-&gt;ulRefCount == 0) <br>                { <br>                ReleaseSlots( m_pObj-&gt;m_pIBuffer, (ULONG) rghRow[ihRow], 1 ); <br>                cRowReleased++; <br>                } <br>            ihRow++; <br>            } <br>        else <br>            { <br>            // It is an error for client to try to release a row <br>            // for which "IsSetSlot" is false.  Client gave us an invalid handle. <br>            // Ignore it (we can't release it...) and report error when done. <br>            fEncounteredError = TRUE; <br>            if (rgRefCount) <br>                rgRefCount[ihRow] = 0; <br>            // stop looping if we hit an error     <br>            break;     <br>            } <br>        } <br> <br>    if (pcRowReleased) <br>        *pcRowReleased = cRowReleased; <br> <br>    if (fEncounteredError) <br>        return ResultFromScode( DB_E_BADROWHANDLE ); <br>    else <br>        return ResultFromScode( S_OK ); <br>} <br> <br> <br> <br> <br> <br> <br>// CImpIRowset::ResartPosition --------------------------------------- <br>// <br>// @mfunc Repositions the next fetch position to the start of the rowset <br>// <br>// - all rows must be released before calling this method <br>// - it is not expensive to Restart us, because we are from a single table <br>// <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                  | Method Succeeded <br>//      @flag DB_E_ROWSNOTRELEASED  | All HROWs must be released before calling <br>// <br>STDMETHODIMP CImpIRowset::RestartPosition <br>    ( <br>    HCHAPTER    hReserved        //@parm IN | Reserved for future use.  Ignored. <br>    ) <br>{ <br>    // make sure all rows have been released <br>    if (S_OK != (m_pObj-&gt;m_prowbitsIBuffer)-&gt;ArrayEmpty()) <br>        return DB_E_ROWSNOTRELEASED; <br>    assert( m_pObj-&gt;m_ulRowRefCount == 0 ); // should be true since array was empty <br> <br>    // set "next fetch" position to the start of the rowset <br>    m_pObj-&gt;m_irowFilePos = 0; <br> <br>    // clear "end of cursor" flag <br>    m_pObj-&gt;m_dwStatus &amp;= ~STAT_ENDOFCURSOR; <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>// CImpIRowset::AddRefRows -------------------------------------------------- <br>// <br>// @mfunc Adds a reference count to an existing row handle <br>// <br>// @rdesc HResult <br>//      @flag S_OK              | Method Succeeded <br>//      @flag E_INVALIDARG      | rghRows was NULL and cRows was not 0 <br>//      @flag DB_E_BADROWHANDLE | An element of rghRows was invalid <br> <br>STDMETHODIMP  CImpIRowset::AddRefRows <br>    ( <br>    ULONG           cRows,          // @parm IN     | Number of rows to refcount <br>    const HROW      rghRows[],      // @parm IN     | Array of row handles to refcount <br>    ULONG*          pcRefCounted,   // @parm OUT    | Number successfully refcounted <br>    ULONG           rgRefCounts[]   // @parm OUT    | Array of refcounts <br>    ) <br>{ <br>    ULONG   ihRow = 0; <br>    ROWBUFF *pRowBuff; <br>    ULONG   cAddRef; <br> <br>    // init out param <br>    if (pcRefCounted) <br>        *pcRefCounted = 0; <br> <br>    // check params <br>    if (cRows &amp;&amp; !rghRows) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    cAddRef = 0; <br> <br>    // for each of the HROWs the caller provided... <br>    for (ihRow = 0; ihRow &lt; cRows; ihRow++) <br>        { <br>        // check the row handle <br>        if (S_OK != (m_pObj-&gt;m_prowbitsIBuffer)-&gt;IsSlotSet((ULONG) rghRows[ihRow] )) <br>            return ResultFromScode( DB_E_BADROWHANDLE ); <br> <br>        // bump refcount <br>        pRowBuff = m_pObj-&gt;GetRowBuff((ULONG) rghRows[ihRow] ); <br>        assert( pRowBuff-&gt;ulRefCount != 0 ); <br>        assert( m_pObj-&gt;m_ulRowRefCount != 0 ); <br>        ++pRowBuff-&gt;ulRefCount; <br>        ++m_pObj-&gt;m_ulRowRefCount; <br> <br>        // bump total refcounted <br>        cAddRef++; <br> <br>        // stuff new refcount into caller's array <br>        if (rgRefCounts) <br>            rgRefCounts[ihRow] = pRowBuff-&gt;ulRefCount; <br>        } <br> <br>    // fill out-param <br>    if (pcRefCounted) <br>        (*pcRefCounted) = cAddRef; <br> <br>    return ResultFromScode( S_OK ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
