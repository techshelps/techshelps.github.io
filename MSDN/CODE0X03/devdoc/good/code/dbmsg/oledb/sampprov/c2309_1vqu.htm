<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COLINFO.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2316"></a>COLINFO.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module COLINFO.CPP | IColumnsInfo interface implementation <br>// <br> <br>// Includes ------------------------------------------------------------------ <br> <br>#include "headers.h" <br> <br>// Code ---------------------------------------------------------------------- <br> <br>//  IColumnsInfo specific methods <br> <br>// CImpIColumnsInfo::GetColumnInfo ------------------------------------------- <br>// <br>// @mfunc Returns the column metadata needed by most consumers. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK              | The method succeeded <br>//      @flag E_OUTOFMEMORY     | Out of memory <br>//      @flag E_INVALIDARG      | pcColumns or prginfo or ppStringsbuffer was NULL <br>// <br>STDMETHODIMP CImpIColumnsInfo::GetColumnInfo <br>    ( <br>    ULONG*          pcColumns,      //@parm OUT | Number of columns in rowset <br>    DBCOLUMNINFO**  prgInfo,        //@parm OUT | Array of DBCOLUMNINFO Structures <br>    WCHAR**         ppStringsBuffer //@parm OUT | Storage for all string values <br>    ) <br>{ <br>    ULONG           icol, <br>        icolStart; <br>    DBCOLUMNINFO*   rgdbcolinfo; <br>    WCHAR*          pstrBuffer; <br> <br>    // Usual argument checking, prescribed by the spec. <br>    if (pcColumns == NULL || prgInfo == NULL || ppStringsBuffer == NULL) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // Fill in with something, in case of error later. <br>    *pcColumns   = 0; <br>    *prgInfo     = NULL; <br>    *ppStringsBuffer = NULL; <br> <br>    icolStart   = 1; <br>    rgdbcolinfo = (DBCOLUMNINFO *) g_pIMalloc-&gt;Alloc( m_pObj-&gt;m_cCols*sizeof( DBCOLUMNINFO )); <br>    if (rgdbcolinfo == NULL) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    memcpy( rgdbcolinfo, &amp;(m_pObj-&gt;m_rgdbcolinfo[icolStart]), m_pObj-&gt;m_cCols*sizeof( DBCOLUMNINFO )); <br> <br>    // Copy the heap for column names. <br>    if (m_pObj-&gt;m_cbHeapUsed) <br>        { <br>        ptrdiff_t dp; <br> <br>        pstrBuffer = (WCHAR *) g_pIMalloc-&gt;Alloc( m_pObj-&gt;m_cbHeapUsed ); <br>        if (pstrBuffer == NULL) <br>            { <br>            g_pIMalloc-&gt;Free( rgdbcolinfo ); <br>            return ResultFromScode( E_OUTOFMEMORY ); <br>            } <br>        memcpy( pstrBuffer, m_pObj-&gt;m_pbHeap, m_pObj-&gt;m_cbHeapUsed ); <br>        dp = (LONG) pstrBuffer - (LONG) (m_pObj-&gt;m_pbHeap); <br>        dp &gt;&gt;= 1; <br> <br>        /* Loop through columns and adjust pointers to column names. */ <br>        for (icol =0; icol &lt; m_pObj-&gt;m_cCols; icol++) <br>            { <br>            if (rgdbcolinfo[icol].pwszName) <br>                rgdbcolinfo[icol].pwszName += dp; <br>            } <br>        } <br> <br>    *prgInfo     = rgdbcolinfo; <br>    *ppStringsBuffer = pstrBuffer; <br>    *pcColumns   = m_pObj-&gt;m_cCols; <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br>// CImpIColumnsInfo::MapColumnIDs -------------------------------------------- <br>// <br>// @mfunc Returns an array of ordinals of the columns in a rowset that are <br>// identified by the specified column IDs. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                      | The method succeeded <br>//      @flag E_INVALIDARG              | cColumnIDs was not 0 and rgColumnIDs was NULL, <br>//                                        rgColumns was NULL <br>//      @flag DB_E_COLUMNUNAVAILABLE    | An element of rgColumnIDs was invalid <br>// <br>STDMETHODIMP CImpIColumnsInfo::MapColumnIDs <br>    ( <br>    ULONG           cColumnIDs,     //@parm IN | Number of Column IDs to map <br>    const DBIDrgColumnIDs[],  //@parm IN | Column IDs to map <br>    ULONG           rgColumns[]     //@parm OUT | Ordinal values <br>    ) <br>{ <br>    BOOL    fError = FALSE; <br>    ULONG   i; <br> <br>    // Check arguments <br>    if ((cColumnIDs != 0) &amp;&amp; (NULL == rgColumnIDs)) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    if (NULL == rgColumns) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    if (0 == cColumnIDs) <br>        { <br>        return ResultFromScode( S_OK ); <br>        } <br> <br>    // Walk the Column ID structs and determine <br>    // the ordinal value <br>    for (i=0; i &lt; cColumnIDs; i++) <br>        { <br>        if ((rgColumnIDs[i].uName.ulPropid &lt; 1)               || <br>            (rgColumnIDs[i].uName.ulPropid &gt; m_pObj-&gt;m_cCols) || <br>            (rgColumnIDs[i].eKind != DBKIND_GUID_PROPID)      || <br>            (rgColumnIDs[i].uGuid.guid != GUID_NULL)) <br>            { <br>            rgColumns[i] = DB_INVALIDCOLUMN; <br>            fError = TRUE; <br>            } <br>        else <br>            rgColumns[i] = rgColumnIDs[i].uName.ulPropid; <br>        } <br> <br>    if (TRUE == fError) <br>        return ResultFromScode( DB_S_ERRORSOCCURRED ); <br> <br>    return ResultFromScode( S_OK ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
