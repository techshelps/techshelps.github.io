<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXTBUFF.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2324"></a>EXTBUFF.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module EXTBUFF.CPP | This class provides an array-based access to <br>// a big block of memory. You pass in the fixed size of each element <br>// to the constructor. Get (read)  an element with GetItemOfExtBuffer. <br>// Set (write) an element with InsertIntoExtBuffer. <br>// You must also pass in the system page size (found with GetSystemInfo). <br>// 'hItem' is the index into the array, beginning with 1. <br>// The array always contains m_cItem elements. <br>// <br>// GetItemOfExtBuffer returns element hItem, where hItem=1 is the first element. <br>// (Copies block to caller's memory.) <br>// <br>// InsertIntoExtBuffer always appends elements to the tail of the array, <br>// and returns the index of the newly appended element. <br>// (So adding first element will return 1.) <br>// <br>// <br>#include "headers.h" <br>#include "extbuff.h" <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Constructor for this class <br>// <br>// @rdesc NONE <br>// <br>CExtBuffer::CExtBuffer <br>    ( <br>    void <br>    ) <br>{ <br>    m_cItem   = 0; <br>    m_cbAlloc = 0; <br>    m_rgItem  = NULL; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Destructor for this class <br>// <br>// @rdesc NONE <br>// <br>CExtBuffer:: ~CExtBuffer <br>    ( <br>    void <br>    ) <br>{ <br>    if (m_cbAlloc) <br>        VirtualFree((VOID *) m_rgItem, m_cbAlloc, MEM_DECOMMIT ); <br> <br>    if (m_rgItem) <br>        VirtualFree((VOID *) m_rgItem, 0, MEM_RELEASE ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Allocate and Initialize Buffer <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK | Initialization succeeded <br>//      @flag  E_OUTOFMEMORY | Not enough memory to allocate buffer <br>// <br>STDMETHODIMP CExtBuffer::FInit <br>    ( <br>    ULONG cItemMax,     //@parm IN | Maximum number of items ever <br>    ULONG cbItem,       //@parm IN | Size of each item, in bytes <br>    ULONG cbPage        //@parm IN | Size of system page size (from SysInfo) <br>    ) <br>{ <br>    BYTE  *pb; <br> <br>    m_cbReserved = ((cbItem *cItemMax) / cbPage + 1) *cbPage; <br>    m_rgItem = (BYTE *) VirtualAlloc( NULL, m_cbReserved, MEM_RESERVE, PAGE_READWRITE ); <br> <br>    if (m_rgItem == NULL) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    m_cbItem  = cbItem; <br>    m_dbAlloc = (cbItem / cbPage + 1) *cbPage; <br>    pb = (BYTE *) VirtualAlloc( m_rgItem, m_dbAlloc, MEM_COMMIT, PAGE_READWRITE ); <br>    if (pb == NULL) <br>        { <br>        VirtualFree((VOID *) m_rgItem, 0, MEM_RELEASE ); <br>        m_rgItem = NULL; <br>        return ResultFromScode( E_OUTOFMEMORY ); <br>        } <br> <br>    m_cbAlloc = m_dbAlloc; <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Retrieves a pointer to the value at given index <br>// <br>// @rdesc If index is within the range of 1 to m_cItems then a valid <br>// pointer is returned, else NULL is returned. <br>// <br>void* CExtBuffer::operator[] <br>    ( <br>    ULONG hItem          //@parm IN | Index of element in buffer <br>    ) <br>{ <br>    // Return ptr to element [n], where n = 1...m_cItem. <br>    // Returns NULL if 'n' is out of range. <br>    // <br>    // You must use InsertIntoExtBuffer to add new elements. <br>    // Thereafter you can use this operator to retrieve the address of the item. <br>    // (You can't delete an element, but you can overwrite its space.) <br> <br>    if (1 &lt;= hItem &amp;&amp; hItem &lt;= m_cItem) <br>        return m_rgItem + (hItem - 1) *m_cbItem; <br>    else <br>        return NULL; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Add Data to the fixed buffers and return the index it was <br>// added at. <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK | Data copied successfully <br>//      @flag  E_OUTOFMEMORY | Not enough memory to allocate buffer <br>// <br>STDMETHODIMP CExtBuffer::InsertIntoExtBuffer <br>    ( <br>    VOID* pvItem,       //@parm IN | Pointer to buffer to copy <br>    ULONG &amp;hItem        //@parm OUT | Index of where data was placed <br>    ) <br>{ <br>    ULONG cbOffset; <br> <br>    cbOffset = m_cItem*m_cbItem; <br>    if ((cbOffset + m_cbItem) &gt; m_cbAlloc) <br>        { <br>        BYTE *pb; <br> <br>        if ((m_cbAlloc + m_dbAlloc) &gt; m_cbReserved) <br>            pb = NULL; <br>        else <br>            pb = (BYTE *) VirtualAlloc( m_rgItem + m_cbAlloc, <br>                                        m_dbAlloc, <br>                                        MEM_COMMIT, <br>                                        PAGE_READWRITE ); <br>        if (pb == NULL) <br>            { <br>            return ResultFromScode( E_OUTOFMEMORY ); <br>            } <br>        m_cbAlloc += m_dbAlloc; <br>        } <br> <br>    memcpy((m_rgItem + cbOffset), (BYTE *) pvItem, m_cbItem ); <br>    m_cItem++; <br>    hItem = m_cItem; <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Obtain a pointer to the data at a given index into the buffer <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK | pvItem contains a pointer to the data requested <br>//      @flag  E_INVALIDARG | Invalid Index passed in <br>// <br>STDMETHODIMP CExtBuffer::GetItemOfExtBuffer <br>    ( <br>    ULONG hItem,        //@parm IN | Index of item to get <br>    VOID* pvItem        //@parm OUT | Pointer to block at index <br>    ) <br>{ <br>    if ((hItem &gt; m_cItem) || <br>(hItem == 0) ) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    memcpy((BYTE *) pvItem, (m_rgItem + (hItem - 1) *m_cbItem), m_cbItem ); <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Get the extents of the currently allocated buffers <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK | Extents were obtained successfuly <br>// <br>STDMETHODIMP CExtBuffer::GetFirstLastItemH <br>    ( <br>    ULONG &amp;hItemFirst,      //@parm OUT | First item allocated <br>    ULONG &amp;hItemLast        //@parm OUT | Last item allocated <br>    ) <br>{ <br>    hItemFirst = 1; <br>    hItemLast  = m_cItem; <br>    return ResultFromScode( S_OK ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
