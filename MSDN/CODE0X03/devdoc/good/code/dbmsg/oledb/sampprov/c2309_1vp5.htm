<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACCESSOR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2309"></a>ACCESSOR.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module ACCESSOR.CPP | CImpIAccessor object implementation <br>// <br>// <br>// <br> <br>// Includes ------------------------------------------------------------------ <br> <br>#include "headers.h" <br> <br>// Code ---------------------------------------------------------------------- <br> <br>// IAccessor specific methods <br> <br>// CImpIAccessor::AddRefAccessor ----------------------------------------- <br>// <br>// @mfunc Adds a reference count to an existing accessor <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                      | Method Succeeded <br>//      @flag E_FAIL                    | Provider specific Error <br>// <br>STDMETHODIMP CImpIAccessor::AddRefAccessor <br>    ( <br>HACCESSORhAccessor,//@parm IN | Accessor Handle <br>ULONG*pcRefCounts//@parm OUT | Reference Count <br>    ) <br>{ <br>    // Retrieve our accessor structure from the client's hAccessor, <br>    // free it, then mark accessor ptr as unused. <br>    // We do not re-use accessor handles.  This way, we hope <br>    // to catch more client errors.  (Also, ExtBuffer doesn't <br>    // maintain a free list, so it doesn't know how to.) <br> <br>    PACCESSOR   pAccessor; <br>    HRESULT     hr; <br> <br>    if( pcRefCounts ) <br>*pcRefCounts = 0; <br> <br>hr = m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;pAccessor ); <br>    if (FAILED( hr ) || pAccessor == NULL) <br>        return ResultFromScode( DB_E_BADACCESSORHANDLE ); <br> <br>InterlockedIncrement(&amp;(pAccessor-&gt;cRef)); <br> <br>if( pcRefCounts ) <br>*pcRefCounts = (ULONG)(pAccessor-&gt;cRef); <br> <br>return ResultFromScode(S_OK); <br>} <br> <br> <br>// CImpIAccessor::CreateAccessor ----------------------------------------- <br>// <br>// @mfunc Creates a set of bindings that can be used to send data <br>// to or retrieve data from the data cache. <br>// NOTE:  Currently does not support returning rgStatus[]. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                      | Method Succeeded <br>//      @flag E_FAIL                    | Provider specific Error <br>//      @flag E_INVALIDARG              | pHAccessor was NULL, dwAccessorFlags was <br>//                                        invalid, or cBindings was not 0 and <br>//                                        rgBindings was NULL <br>//      @flag E_OUTOFMEMORY             | Out of Memory <br>//      @flag DB_E_ERRORSOCCURRED| dwBindPart in an rgBindings element was invalid, OR <br>//    | Column number specified was out of range, OR <br>//| Requested coercion is not supported. <br>//      @flag OTHER                     | Other HRESULTs returned by called functions <br>// <br>STDMETHODIMP CImpIAccessor::CreateAccessor <br>    ( <br>    DBACCESSORFLAGS dwAccessorFlags, <br>    ULONG           cBindings,      //@parm IN | Number of Bindings <br>    const DBBINDING rgBindings[],   //@parm IN | Array of DBBINDINGS <br>    ULONG           cbRowSize,      //@parm IN | Number of bytes in consumer's buffer <br>    HACCESSOR*      phAccessor,     //@parm OUT | Accessor Handle <br>DBBINDSTATUSrgStatus[]//@parm OUT| Binding status <br>    ) <br>{ <br>    PACCESSOR   pAccessor; <br>    ULONG       hAccessor; <br>    ULONG       ibind; <br>    ULONG       icol; <br>    HRESULT     hr; <br> <br> <br>    // Check Parameters <br>    if( (cBindings &amp;&amp; !rgBindings) || <br>(phAccessor == NULL) ) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // init out params <br>    *phAccessor = (HACCESSOR) 0; <br> <br> <br>    // Check for the binding types we don't accept.. <br>    if ((dwAccessorFlags &amp; DBACCESSOR_PASSBYREF)        || <br>        (dwAccessorFlags &amp; DBACCESSOR_PARAMETERDATA)) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // .. then check for the binding type that is required <br>    if (!(dwAccessorFlags &amp; DBACCESSOR_ROWDATA)) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br> <br>    // Check on the bindings the user gave us. <br>    for (ibind =0, hr =NOERROR; ibind &lt; cBindings; ibind++) <br>    { <br>        icol = rgBindings[ibind].iOrdinal; <br> <br>        // make sure column number is in range <br>        if (!(0 &lt; icol &amp;&amp; icol &lt;= m_pObj-&gt;m_cCols)) <br>        { <br>            TRACE( "CreateAccessor failure: binding %d, bad column number %d\n", ibind, icol ); <br>            hr = ResultFromScode( DB_E_ERRORSOCCURRED ); <br>            break; <br>        } <br> <br>        // At least one of these valid parts has to be set. In SetData I assume it is the case. <br>        if ((rgBindings[ibind].dwPart &amp; DBPART_VALUE)  == 0 <br>         &amp;&amp; (rgBindings[ibind].dwPart &amp; DBPART_LENGTH) == 0 <br>         &amp;&amp; (rgBindings[ibind].dwPart &amp; DBPART_STATUS) == 0) <br>         { <br>            TRACE( "CreateAccessor failure: binding %d, column %d, _VALUE, _LENGTH, _STATUS not specified", ibind, icol ); <br>            hr = ResultFromScode( DB_E_ERRORSOCCURRED ); <br> <br>if ( rgStatus ) <br>{ <br>//  Set Bind status to DBBINDSTATUS_BADBINDINFO <br>} <br>            break; <br>        } <br> <br>        // Make sure we can do the coercion that is requested <br>        if( NOERROR != g_pIDataConvert-&gt;CanConvert(rgBindings[ibind].wType, m_pObj-&gt;m_rgdbcolinfo[icol].wType) || <br>NOERROR != g_pIDataConvert-&gt;CanConvert(m_pObj-&gt;m_rgdbcolinfo[icol].wType, rgBindings[ibind].wType) ) <br>        { <br>            TRACE( "CreateAccessor failure: binding %d, column %d, cannot coerce types\n", ibind, icol ); <br>            hr = ResultFromScode( DB_E_ERRORSOCCURRED ); <br>if ( rgStatus ) <br>{ <br>//  Set Bind status to DBBINDSTATUS_UNSUPPORTEDCONVERSION <br>} <br>        break; <br>        } <br>    } <br> <br>    // Any errors amongst those checks? <br>    if (hr != NOERROR) <br>    { <br>        return hr; <br>    } <br> <br>    // Make a copy of the client's binding array, and the type of binding. <br>    // Note: accessors with no bindings (cBindings=0) are legal. <br>    pAccessor = (ACCESSOR *) new BYTE[sizeof( ACCESSOR ) + (cBindings - 1) *sizeof( DBBINDING )]; <br>    if (pAccessor == NULL) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    // We store a ptr to the newly created variable-sized ACCESSOR. <br>    // We have an array of ptrs (to ACCESSOR's). <br>    // The handle is the index into the array of ptrs. <br>    // The InsertIntoExtBuffer function appends to the end of the array. <br>    assert( m_pObj-&gt;m_pextbufferAccessor ); <br>    hr = m_pObj-&gt;m_pextbufferAccessor-&gt;InsertIntoExtBuffer( &amp;pAccessor, hAccessor ); <br>    if (FAILED( hr )) <br>        { <br>        delete [] pAccessor; <br>        return ResultFromScode( E_OUTOFMEMORY ); <br>        } <br>    assert( hAccessor ); <br> <br>    // Copy the client's bindings into the ACCESSOR. <br>    pAccessor-&gt;dwAccessorFlags= dwAccessorFlags; <br>    pAccessor-&gt;cBindings= cBindings; <br>    pAccessor-&gt;cRef= 1;// Establish Reference count. <br>memcpy( &amp;(pAccessor-&gt;rgBindings[0]), &amp;rgBindings[0], cBindings*sizeof( DBBINDING )); <br> <br>    // fill out-param and return <br>    *phAccessor = (HACCESSOR) hAccessor; <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>// CImpIAccessor::GetBindings -------------------------------------------------- <br>// <br>// @mfunc Returns the bindings in an accessor <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                      | Method Succeeded <br>//      @flag E_INVALIDARG              | pdwAccessorFlags/pcBinding/prgBinding were NULL <br>//      @flag E_OUTOFMEMORY             | Out of Memory <br>//      @flag DB_E_BADACCESSORHANDLE    | Invalid Accessor given <br>// <br>STDMETHODIMP CImpIAccessor::GetBindings <br>    ( <br>    HACCESSOR        hAccessor,         //@parm IN | Accessor Handle <br>    DBACCESSORFLAGS* pdwAccessorFlags,  //@parm OUT | Binding Type flag <br>    ULONG*           pcBindings,        //@parm OUT | Number of Bindings returned <br>    DBBINDING**      prgBindings        //@parm OUT | Bindings <br>    ) <br>{ <br>    // Retrieve our accessor structure from the client's hAccessor, <br>    // make a copy of the bindings for the user, then done. <br>    PACCESSOR   pAccessor; <br>    ULONG       cBindingSize; <br>    HRESULT     hr; <br> <br>    // check parameters <br>    if (!pdwAccessorFlags || !pcBindings || !prgBindings) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // init out-params <br>    *pdwAccessorFlags = 0; <br>    *pcBindings       = 0; <br>    *prgBindings      = NULL; <br> <br>    // Validate Accessor Handle <br>    hr = m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;pAccessor ); <br>    if (FAILED( hr ) || pAccessor == NULL) <br>        return ResultFromScode( DB_E_BADACCESSORHANDLE ); <br> <br>    // Allocate and return Array of bindings <br>    cBindingSize = pAccessor-&gt;cBindings * sizeof( DBBINDING ); <br>    *prgBindings = (DBBINDING *) g_pIMalloc-&gt;Alloc( cBindingSize ); <br>    if (*prgBindings) <br>        { <br>        *pdwAccessorFlags = pAccessor-&gt;dwAccessorFlags; <br>        *pcBindings = pAccessor-&gt;cBindings; <br>        memcpy( *prgBindings, pAccessor-&gt;rgBindings, cBindingSize ); <br>        } <br>    else <br>        { <br>        return ResultFromScode( E_OUTOFMEMORY ); <br>        } <br> <br>    // all went well.. <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br> <br>// CImpIAccessor::ReleaseAccessor --------------------------------------- <br>// <br>// @mfunc Releases an Accessor <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                      | Method Succeeded <br>//      @flag DB_E_BADACCESSORHANDLE    | hAccessor was invalid <br>// <br>STDMETHODIMP CImpIAccessor::ReleaseAccessor <br>    ( <br>    HACCESSORhAccessor,      //@parm IN | Accessor handle to release <br>ULONG*pcRefCounts//@parm OUT | Reference Count <br>    ) <br>{ <br>    // Retrieve our accessor structure from the client's hAccessor, <br>    // free it, then mark accessor ptr as unused. <br>    // We do not re-use accessor handles.  This way, we hope <br>    // to catch more client errors.  (Also, ExtBuffer doesn't <br>    // maintain a free list, so it doesn't know how to.) <br> <br>    PACCESSOR   pAccessor; <br>    HRESULT     hr; <br> <br>if( pcRefCounts ) <br>*pcRefCounts = 0; <br> <br>    hr = m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;pAccessor ); <br>    if (FAILED( hr ) || pAccessor == NULL) <br>        return ResultFromScode( DB_E_BADACCESSORHANDLE ); <br> <br>    // Free the actual structure. <br>InterlockedDecrement(&amp;(pAccessor-&gt;cRef)); <br>assert( pAccessor-&gt;cRef &gt;= 0 ); <br>if( pAccessor-&gt;cRef &lt;= 0 ) <br>{ <br>delete [] pAccessor; <br>if( pcRefCounts ) <br>*pcRefCounts = 0; <br>} <br>else <br>{ <br>if( pcRefCounts ) <br>*pcRefCounts = (ULONG)(pAccessor-&gt;cRef); <br>} <br> <br>    // Store a null in our array-of-ptrs, <br>    // so we know next time that it is invalid. <br>    // (operator[] returns a ptr to the space where the ptr is stored.) <br>    *(PACCESSOR*) ((*m_pObj-&gt;m_pextbufferAccessor)[ (ULONG) hAccessor]) = NULL; <br> <br>    return ResultFromScode( S_OK ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
