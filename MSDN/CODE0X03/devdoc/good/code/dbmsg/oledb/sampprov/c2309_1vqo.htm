<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ASSERTS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2310"></a>ASSERTS.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module ASSERTS.CPP | Simple Assertion Routines <br>// <br>// <br>#include "headers.h" <br>#include &lt;time.h&gt; <br>#include "asserts.h" <br> <br>#ifdef DEBUG    // only compile for debug! <br> <br>//-------------------------------------------------------------------- <br>// @func Variable argument formatter and Dump routine for messages <br>// <br>// @rdesc NONE <br>// <br>void OLEDB_Trace <br>    ( <br>    const char *format,     //@parm IN | Format String <br>    ...                     //@parm IN | Variable Arg List <br>    ) <br>{ <br>    char buff[300 ]; <br>    int cBytesWritten; <br>    va_list argptr; <br> <br>    // If this overflows, it will wipe out the return stack. <br>    // However, we have a wonderful version that ensures no overwrite. <br>    // Nice because we can't do anything about errors here. <br> <br>    va_start( argptr, format ); <br>    cBytesWritten = _vsnprintf( buff, sizeof( buff ), format, argptr ); <br>    va_end( argptr ); <br> <br>    // assert would report overflow first, recursively, but don't bother. <br>    // Would be OK, since this assert could be proven <br>    // not to overflow temp buffer in assert. <br>    //assert( cBytesWritten &lt; sizeof(buff) ); <br> <br>    OutputDebugString( buff ); <br>} <br> <br>//-------------------------------------------------------------------- <br>// @func This an internal assertion routine that dumps more information <br>// than the normal assertion routines.. <br>// <br>// @rdesc NONE <br>// <br>void OLEDB_Assert <br>    ( <br>    LPSTR expression,   //@parm IN | Expression to assert on <br>    LPSTR filename,     //@parm IN | Filname where assertion occurred <br>    long linenum        //@parm IN | Line number where assertion occurred <br>    ) <br>{ <br>    char          szbuff[350 ]; <br>    int           cBytesWritten; <br>    volatile int  fAbort; <br> <br>    // If this overflows, it will wipe out the return stack. <br>    // However, we have a wonderful version that ensures no overwrite. <br>    // Good thing, because we can't do much about overflows here anyway. <br>    // (However, use of "%.nns" works well.) <br> <br>    cBytesWritten = _snprintf( szbuff, sizeof( szbuff ), <br>        "Assertion error!\n  File '%.50s', line '%ld'\n  Expression '%.200s'\n", <br>        filename, linenum, expression ); <br> <br>    TRACE( szbuff ); <br> <br>    // We're a DLL (therefore Windows), so may not have an output stream we can write to. <br>    ::MessageBox( <br>        NULL,   // HWND, which we don't have <br>        szbuff, // Text <br>        "Assertion Error",  // Title <br>        MB_SYSTEMMODAL | MB_ICONHAND | MB_OK ); <br> <br>    // Break and let the user get a crack at it. <br>    // You can set fAbort=0 to continue merrily along. <br>    fAbort = 1; <br>    if (fAbort)  <br>        { <br>        abort();    // Raises SIGABRT <br>        } <br>} <br>#endif <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
