<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILEIDX.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2326"></a>FILEIDX.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module FILEIDX.CPP | This module contains the index array code <br>// for a Comma Seperated Value (CSV) Simple Provider. <br>// <br>// <br>#include &lt;assert.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "fileidx.h" <br> <br>static const ARRAY_INIT_SIZE = 1000; <br>static const DELETED_ROW = 1; <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Constructor for this class <br>// <br>// @rdesc NONE <br>// <br>CFileIdx::CFileIdx <br>    ( <br>    void <br>    ) <br>{ <br>    m_rgDex = NULL; <br>    m_ulDexCnt = 0; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Destructor for this class <br>// <br>// @rdesc NONE <br>// <br>CFileIdx:: ~CFileIdx() <br>{ <br>    if (m_rgDex) <br>        free( m_rgDex ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Initialization routine <br>// <br>// @rdesc BOOLEAN value <br>//      @flag TRUE | Succeeded <br>//      @flag FALSE | Failed to Initialize <br>// <br>BOOL CFileIdx::fInit <br>    ( <br>    void <br>    ) <br>{ <br>    //Allocate Offset Array <br>    m_rgDex = (LPFILEDEX) calloc( ARRAY_INIT_SIZE, sizeof( FILEDEX )); <br>    if (NULL == m_rgDex) <br>        return FALSE; <br> <br>    m_ulDexCnt = ARRAY_INIT_SIZE; <br>    return TRUE; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc ReAllocation of Current Index Array.  This can be called to <br>// increase the array of index structures. <br>// <br>// @rdesc BOOLEAN value <br>//      @flag TRUE | Succeeded <br>//      @flag FALSE | Failed to Initialize <br>// <br>BOOL CFileIdx::ReAlloc <br>    ( <br>    ULONG ulRows                //@parm IN | Number of rows to increase array for. <br>    ) <br>{ <br>    VOID* pDex; <br> <br>    // Change the array size <br>    pDex = realloc( m_rgDex, ((m_ulDexCnt + ulRows) * sizeof( FILEDEX ))); <br>    if (NULL == pDex) <br>        return FALSE; <br> <br>m_ulDexCnt += ulRows; <br>    m_rgDex = (FILEDEX*) pDex; <br>    return TRUE; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Set the offset into the file in bytes for a particular row. <br>// If the Index is beyond current allocation, reallocation is attempted. <br>// <br>// @rdesc BOOLEAN value <br>//      @flag TRUE | Succeeded <br>//      @flag FALSE | Failed to Initialize <br>// <br>BOOL CFileIdx::SetIndex <br>    ( <br>    ULONG ulDex,        //@parm IN | Row Index value <br>    ULONG ulOffset      //@parm IN | Offset of Row in the File <br>    ) <br>{ <br>    // Check index and realloc if beyond our current range <br>    if (m_ulDexCnt &lt;= ulDex) <br>        if (FALSE == ReAlloc( ARRAY_INIT_SIZE )) <br>            return FALSE; <br> <br>    m_rgDex[ulDex].ulOffset = ulOffset; <br>    m_rgDex[ulDex].bStatus = FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Mark the row as deleted. <br>// <br>// @rdesc BOOLEAN value <br>//      @flag TRUE | Succeeded <br>//      @flag FALSE | Failed to Initialize <br>// <br>BOOL CFileIdx::DeleteRow <br>    ( <br>    ULONG ulDex                 //@parm IN | Row Index value <br>    ) <br>{ <br>    // Index should alway be valid <br>    assert((0 &lt;= ulDex) &amp;&amp; (m_ulDexCnt &gt; ulDex)); <br> <br>    // Mark Row <br>    m_rgDex[ulDex].bStatus = DELETED_ROW; <br> <br>    return TRUE; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Has the row been deleted or not <br>// <br>// @rdesc BOOLEAN value <br>//      @flag TRUE | Row Already Deleted <br>//      @flag FALSE | Row has not been Deleted <br>// <br>BOOL CFileIdx::IsDeleted <br>    ( <br>    ULONG ulDex                 //@parm IN | Row Index value <br>    ) <br>{ <br>    // Index should alway be valid <br>    assert((0 &lt;= ulDex) &amp;&amp; (m_ulDexCnt &gt; ulDex)); <br> <br>    // Check deletion status <br>    if (DELETED_ROW != m_rgDex[ulDex].bStatus) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Return the File Offset that the row starts <br>// <br>// @rdesc Offset from Beginning of File <br>// <br>ULONG CFileIdx::GetRowOffset <br>    ( <br>    ULONG ulDex                 //@parm IN | Row Index value <br>    ) <br>{ <br>    // Index should alway be valid <br>    assert((0 &lt;= ulDex) &amp;&amp; (m_ulDexCnt &gt; ulDex)); <br> <br>    return m_rgDex[ulDex].ulOffset; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
