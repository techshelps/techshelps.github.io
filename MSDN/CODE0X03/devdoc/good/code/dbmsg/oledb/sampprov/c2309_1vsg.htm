<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBINIT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2320"></a>DBINIT.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module DBINIT.CPP | IDBInitialize interface implementation <br>// <br>// <br> <br>// Includes ------------------------------------------------------------------ <br>#include "headers.h" <br> <br>// IDBInitialize specific interface methods <br> <br> <br>// CImpIDBInitialize::Initialize --------------------------------------------- <br>// <br>// @mfunc Initializes the DataSource object.. For this provider it requires <br>// that a valid path is given to where the file will be located. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK          | Path exists <br>//      @flag E_FAIL        | Invalid path <br>//      @flag E_INVALIDARG  | Invalid Parameters passed in <br>// <br>STDMETHODIMP CImpIDBInitialize::Initialize <br>    ( <br>) <br>{ <br>HRESULThr; <br>DBPROPIDSETrgPropertyIDSets[1]; <br>ULONGcPropertySets; <br>DBPROPSET*prgPropertySets; <br>DBPROPIDrgPropId[1]; <br> <br>    char szNewVal[MAX_PATH ]; <br> <br>    assert( m_pObj ); <br> <br>    if (m_pObj-&gt;m_fDSOInitialized) <br>        return ResultFromScode( DB_E_ALREADYINITIALIZED ); <br> <br>rgPropId[0]= DBPROP_INIT_DATASOURCE; <br>  <br>rgPropertyIDSets[0].guidPropertySet= DBPROPSET_DBINIT; <br>rgPropertyIDSets[0].rgPropertyIDs= rgPropId; <br>rgPropertyIDSets[0].cPropertyIDs= 1; <br> <br>    // Get the value of the DBPROP_INIT_DATASOURCE property <br>    hr = m_pObj-&gt;m_pUtilProp-&gt;GetProperties(  <br>1,  <br>rgPropertyIDSets, <br>&amp;cPropertySets, <br>&amp;prgPropertySets ); <br> <br>// On failure treat it as if we were opening with prompt.. <br>    if( SUCCEEDED(hr) ) <br>lstrcpy(szNewVal, (char *)V_BSTR(&amp;prgPropertySets[0].rgProperties-&gt;vValue)); <br>else <br>*szNewVal = '\0'; <br> <br>    // if caller didn't supply a directory path, ask the user <br>    if (*szNewVal == '\0') <br>    { <br>    if (!BrowseDirs( GetDesktopWindow(), g_hInstance, NULL, szNewVal )) <br>        { <br>            return ResultFromScode( E_FAIL ); <br>    } <br>        else <br>        { <br>        lstrcpyn( m_pObj-&gt;m_szPath, szNewVal, MAX_PATH ); <br>m_pObj-&gt;m_fDSOInitialized = TRUE; <br>return ResultFromScode( S_OK ); <br>        } <br>    } <br>    else    // caller did supply a directory path <br>    { <br>    // Check if the directory is a valid directory <br>if (SetCurrentDirectory( szNewVal )) <br>        { <br>lstrcpyn( m_pObj-&gt;m_szPath, szNewVal, MAX_PATH ); <br>m_pObj-&gt;m_fDSOInitialized = TRUE; <br>return ResultFromScode( S_OK ); <br>        } <br>    else <br>        { <br>return ResultFromScode( E_FAIL ); <br>        } <br>    } <br>} <br> <br> <br> <br>// CImpIDBInitialize::Uninitialize --------------------------------------------- <br>// <br>// @mfunc Returns the Data Source Object to an uninitialized state <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK            | The method succeeded <br>//      @flag DB_E_OBJECTOPEN | A DBSession object was already created <br>STDMETHODIMP CImpIDBInitialize::Uninitialize <br>    ( <br>    void <br>    ) <br>{ <br>    assert( m_pObj ); <br> <br>    if (!m_pObj-&gt;m_fDSOInitialized) <br>        { <br>        // data source object is not initialized; do nothing <br>        return ResultFromScode( S_OK ); <br>        } <br>    else <br>        { <br>        if (!m_pObj-&gt;m_fDBSessionCreated) <br>            { <br>            // DSO initialized, but no DBSession has been created. <br>            // So, reset DSO to uninitialized state <br>            m_pObj-&gt;m_fDSOInitialized = FALSE; <br>            return ResultFromScode( S_OK ); <br>            } <br>        else <br>            { <br>            // DBSession has already been created; trying to uninit <br>            // the DSO now is an error <br>            return ResultFromScode( DB_E_OBJECTOPEN ); <br>            } <br>        } <br>} <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//   Helper Functions   Helper Functions    Helper Functions <br>////////////////////////////////////////////////////////////////////////////// <br> <br> <br>// BrowseDirs ---------------------------------------------------------------- <br>// <br>// @func Common dialog look-alike which allows you to select a direcotry. <br>// <br>// @rdesc BOOLEAN value indicates success or failure <br>//      @flag TRUE | Directory was obtained <br>//      @flag FALSE | No Directory was obtained <br>// <br>BOOL WINAPI BrowseDirs <br>    ( <br>    HWND        hDlg,       //@parm IN | Window Handle <br>    HINSTANCE   hInst,      //@parm IN | Instance of this DLL <br>    LPCSTR      lpszPrompt, //@parm IN | Prompt text for dialog, NULL for default <br>    LPSTR       lpszDrive   //@parm OUT | Drive Name <br>    ) <br>{ <br>    OPENFILENAME    ofn; <br>    char            szFile[_MAX_PATH ]; <br>    BROWSEINFO      bi; <br> <br>    lstrcpy( szFile, "DUMMY.TXT" ); <br> <br>    memset( &amp;bi, 0, sizeof( BROWSEINFO )); <br>    bi.szPrompt = lpszPrompt; <br> <br>    memset( &amp;ofn, 0, sizeof( ofn )); <br>    ofn.lStructSize       = sizeof( OPENFILENAME ); <br>    ofn.hwndOwner         = hDlg; <br>    ofn.hInstance         = hInst; <br>    ofn.lpstrFile         = (LPSTR) szFile; <br>    ofn.nMaxFile          = sizeof( szFile ); <br>    ofn.lpstrInitialDir   = lpszDrive; <br>    ofn.Flags             = OFN_ENABLEHOOK       | <br>                            OFN_ENABLETEMPLATE   | <br>                            OFN_HIDEREADONLY     | <br>                            OFN_NOTESTFILECREATE | <br>                            OFN_PATHMUSTEXIST    | <br>                            OFN_SHAREAWARE; <br>    ofn.lpfnHook          = CommDlgHook; <br>    ofn.lpTemplateName    = MAKEINTRESOURCE( IDD_BROWSE ); <br>    ofn.lCustData         = (LPARAM) (lpBROWSEINFO) &amp; bi; <br>    if (GetOpenFileName( &amp;ofn )) <br>        { <br>        lstrcpyn( lpszDrive, szFile, ofn.nFileOffset ); <br>        *(lpszDrive + ofn.nFileOffset - 1) = '\0'; <br>        return TRUE; <br>        } <br> <br>    return FALSE; <br>} <br> <br> <br>// CenterDialog -------------------------------------------------------------- <br>// <br>// @func Center the dialog over the parent window. <br>// <br>// @rdesc NONE <br>// <br>void WINAPI CenterDialog <br>    ( <br>    HWND hDlg                   //@parm IN | Window to Center <br>    ) <br>{ <br>    RECT  rcParent;         // Parent window client rect <br>    RECT  rcDlg;            // Dialog window rect <br>    int   nLeft, nTop;      // Top-left coordinates <br>    int   cWidth, cHeight;  // Width and height <br>    HWND  hwnd; <br> <br>    // Get frame window client rect in screen coordinates <br>    if ((hwnd = GetParent( hDlg )) == NULL) <br>        { <br>        rcParent.top = rcParent.left = 0; <br>        rcParent.right = GetSystemMetrics( SM_CXFULLSCREEN ); <br>        rcParent.bottom = GetSystemMetrics( SM_CYFULLSCREEN ); <br>        } <br>    else <br>        GetWindowRect( hwnd, &amp;rcParent ); <br> <br>    // Determine the top-left point for the dialog to be centered <br>    GetWindowRect( hDlg, &amp;rcDlg ); <br>    cWidth  = rcDlg.right - rcDlg.left; <br>    cHeight = rcDlg.bottom - rcDlg.top; <br>    nLeft   = rcParent.left + <br>        (((rcParent.right - rcParent.left) - cWidth) / 2); <br>    nTop    = rcParent.top + <br>        (((rcParent.bottom - rcParent.top) - cHeight) / 2); <br>    if (nLeft &lt; 0) <br>        nLeft = 0; <br>    if (nTop &lt; 0) <br>        nTop  = 0; <br> <br>    // Place the dialog <br>    MoveWindow( hDlg, nLeft, nTop, cWidth, cHeight, TRUE ); <br>    return; <br>} <br> <br> <br>// CommDlgHook --------------------------------------------------------------- <br>// <br>// @func Hook function for browsing a directory.  Need for custom info. <br>// <br>// @rdesc UINT value indicating hook procs status <br>// <br>UINT CALLBACK CommDlgHook <br>    ( <br>    HWND    hDlg,   //@parm IN | Window Handle <br>    UINT    msg,    //@parm IN | Window Message <br>    WPARAM  wParam, //@parm IN | Standard Value <br>    LPARAM  lParam  //@parm IN | Standard Value <br>    ) <br>{ <br>    lpBROWSEINFO    lpbi; <br> <br>    lpbi = (lpBROWSEINFO) GetWindowLong( hDlg, GWL_USERDATA ); <br> <br>    switch (msg) <br>        { <br>    case WM_INITDIALOG: <br>        { <br>            OPENFILENAME FAR *  lpofn; <br> <br>            lpofn = (OPENFILENAME FAR *) lParam; <br>            lpbi = (lpBROWSEINFO) lpofn-&gt;lCustData; <br>            SetWindowLong( hDlg, GWL_USERDATA, (LONG) lpbi ); <br> <br>            CenterDialog( hDlg ); <br> <br>            lpbi-&gt;uFileOkString = RegisterWindowMessage( FILEOKSTRING ); <br>            lpbi-&gt;lpofn         = (LPOPENFILENAME) lParam; <br>            if (lpbi-&gt;szPrompt) <br>                SetWindowText( GetDlgItem( hDlg, IDT_PROMPT ), (LPSTR) lpbi-&gt;szPrompt ); <br>        } <br>        return TRUE; <br> <br>    case WM_CLOSE: <br>        if (lpbi) <br>            SetWindowLong( hDlg, GWL_USERDATA, (LONG) 0L ); <br>        break; <br> <br>    default: <br>        break; <br>        } <br> <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
