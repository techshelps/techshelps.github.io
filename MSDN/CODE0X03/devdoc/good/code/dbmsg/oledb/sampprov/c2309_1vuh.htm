<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ROWCHNG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2339"></a>ROWCHNG.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module ROWCHNG.CPP | IRowsetChange interface implementation <br>// <br>// <br> <br>// Includes ------------------------------------------------------------------ <br> <br>#include "headers.h" <br> <br>// Code ---------------------------------------------------------------------- <br> <br> <br> <br> <br>//  IRowsetChange specific methods <br> <br>// CImpIRowsetChange::SetData ------------------------------------------------ <br>// <br>// @mfunc Sets new data values into fields of a row. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK                   | The method succeeded <br>//      @flag E_OUTOFMEMORY          | Out of memory <br>//      @flag DB_E_BADACCESSORHANDLE | Bad accessor handle <br>//      @flag DB_E_READONLYACCESSOR  | Tried to write through a read-only accessor <br>//      @flag DB_E_BADROWHANDLE      | Invalid row handle <br>//      @flag E_INVALIDARG           | pData was NULL <br>//      @flag E_FAIL                 | Provider-specific error <br>//      @flag OTHER                  | Other HRESULTs returned by called functions <br>// <br>STDMETHODIMP CImpIRowsetChange::SetData <br>    ( <br>    HROW        hRow,       //@parm IN | Handle of the row in which to set the data <br>    HACCESSOR   hAccessor,  //@parm IN | Handle to the accessor to use <br>    void*pData       //@parm IN | Pointer to the data <br>    ) <br>{ <br>    PACCESSOR       paccessor; <br>    ULONG           icol, ibind; <br>    BYTE*           pbProvRow; <br>    HRESULT         hr; <br>    ULONG           cBindings; <br>    DBBINDING*      pBinding; <br>    ULONG           dwErrorCount; <br>    DBTYPE          dwSrcType; <br>    DBTYPE          dwDstType; <br>    void*           pSrc; <br>    void*           pDst; <br>    ULONG           dwSrcLength; <br>    ULONG*          pdwDstLength; <br>    ULONG           dwDstMaxLength; <br>    DWORD           dwSrcStatus; <br>    DWORD*          pdwDstStatus; <br>    DWORD           dwPart; <br>    PCOLUMNDATA     pColumnData; <br>    BYTE            b; <br> <br>    BYTE*           rgbRowDataSave = NULL; <br> <br>    rgbRowDataSave = (BYTE *) malloc( m_pObj-&gt;m_cbRowSize ); <br>    if (NULL == rgbRowDataSave) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    if (   m_pObj-&gt;m_pextbufferAccessor == NULL      <br>        || FAILED( m_pObj-&gt;m_pextbufferAccessor-&gt;GetItemOfExtBuffer((ULONG) hAccessor, &amp;paccessor)) <br>        || paccessor == NULL) <br>        { <br>        return ResultFromScode( DB_E_BADACCESSORHANDLE ); <br>        } <br>         <br>    assert( paccessor ); <br> <br>    cBindings = paccessor-&gt;cBindings; <br>    pBinding  = paccessor-&gt;rgBindings; <br> <br>    // Is row handle right? <br>    if ((m_pObj-&gt;m_prowbitsIBuffer)-&gt;IsSlotSet((ULONG) hRow ) != S_OK) <br>        return ResultFromScode( DB_E_BADROWHANDLE ); <br> <br>    // Ensure a source of data. <br>    if (pData == NULL) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    pbProvRow = (BYTE *) (m_pObj-&gt;GetRowBuff((ULONG) hRow )); <br> <br>    // Save the row. <br>    memcpy( rgbRowDataSave, pbProvRow, m_pObj-&gt;m_cbRowSize ); <br> <br> <br>    // Apply accessor to data. <br>    for (ibind = 0, dwErrorCount = 0; ibind &lt; cBindings; ibind++) <br>        { <br>        icol = pBinding[ibind].iOrdinal; <br>        pColumnData = (COLUMNDATA *) (pbProvRow + m_pObj-&gt;m_rgdwDataOffsets[icol]); <br> <br>        dwDstType      = m_pObj-&gt;m_rgdbcolinfo[icol].wType; <br>        pDst           = &amp;(pColumnData-&gt;bData); <br>        pdwDstLength   = (ULONG *) &amp; (pColumnData-&gt;dwLength); <br>        pdwDstStatus   = &amp;(pColumnData-&gt;dwStatus); <br>        dwDstMaxLength = m_pObj-&gt;m_rgdbcolinfo[icol].ulColumnSize; <br> <br>        dwPart         = pBinding[ibind].dwPart; <br>        dwSrcType      = pBinding[ibind].wType; <br> <br>        if ((dwPart &amp; DBPART_VALUE) == 0) <br>            { <br>            if (((dwPart &amp; DBPART_STATUS) <br>                &amp;&amp; (*(ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) &amp; DBSTATUS_S_ISNULL)) <br>               || ((dwPart &amp; DBPART_LENGTH) &amp;&amp; *(ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) == 0)) <br>                { <br>                pSrc = &amp;b; <br>                b = 0x00; <br>                } <br>            else <br>                return ResultFromScode( E_FAIL ); <br>            } <br>        else <br>            { <br>            pSrc = (void *) ((BYTE*) pData + pBinding[ibind].obValue); <br>            } <br> <br>        dwSrcLength = (dwPart &amp; DBPART_LENGTH) ? *(ULONG *) ((BYTE*) pData + pBinding[ibind].obLength) : 0; <br> <br>        dwSrcStatus = (dwPart &amp; DBPART_STATUS) ? *(ULONG *) ((BYTE*) pData + pBinding[ibind].obStatus) <br>            : DBSTATUS_S_OK; <br> <br>        hr = g_pIDataConvert-&gt;DataConvert( <br>dwSrcType, <br>                dwDstType, <br>                dwSrcLength, <br>                pdwDstLength, <br>                pSrc, <br>                pDst, <br>                dwDstMaxLength, <br>                dwSrcStatus, <br>                pdwDstStatus, <br>0,// bPrecision for conversion to DBNUMERIC <br>0,// bScale for conversion to DBNUMERIC <br>DBDATACONVERT_SETDATABEHAVIOR); <br>        if (FAILED( hr )) <br>            return hr;  // fatal error <br>        if (hr != S_OK) <br>            dwErrorCount++; // rounding or truncation or can't coerce <br>        } <br> <br>    // Carry out the update. <br>    if (FAILED( m_pObj-&gt;m_pFileio-&gt;UpdateRow((ULONG) ((PROWBUFF) pbProvRow)-&gt;pbBmk, m_pObj-&gt;m_rgdwDataOffsets, pbProvRow ))) <br>        { <br>        // Restore the row to its previous state */ <br>        memcpy( pbProvRow, rgbRowDataSave, m_pObj-&gt;m_cbRowSize ); <br>        return ResultFromScode( E_FAIL ); <br>        } <br> <br>    free( rgbRowDataSave ); <br> <br>    // We report any lossy conversions with a special status. <br>    // Note that DB_S_ERRORSOCCURED is a success, rather than failure. <br>    return ResultFromScode( dwErrorCount ? DB_S_ERRORSOCCURRED : S_OK ); <br>} <br> <br> <br> <br>// CImpIRowsetChange::DeleteRows --------------------------------------- <br>// <br>// @mfunc Deletes rows from the provider.  If Errors on individual rows <br>// occur, the DBERRORINFO array is updated to reflect the error and S_FALSE <br>// is returned instead of S_OK. <br>// <br>// @rdesc HRESULT indicating the status of the method <br>//      @Flag S_OK                  | All row handles deleted <br>//      @Flag DB_S_ERRORSOCCURRED   | Some, but not all, row handles deleted <br>//      @Flag E_INVALIDARG          | Arguments did not match spec. <br>//      @Flag E_OUTOFMEMORY         | Could not allocated error array <br>// <br>STDMETHODIMP CImpIRowsetChange::DeleteRows <br>    ( <br>HCHAPTERhReserved,//@parm IN| Reserved for future use <br>ULONG           cRows,//@parm IN| Number of rows to delete <br>const HROW      rghRows[],//@parm IN| Array of handles to delete <br>DBROWSTATUSrgRowStatus[]//@parm OUT | Error information <br>    ) <br>{ <br>    ULONG           ihRow        = 0L; <br>    ULONG           cErrors      = 0L; <br>    ULONG           cRowReleased = 0L; <br>    BYTE*           pbProvRow; <br> <br>    // If No Row handle, just return. <br>    if (0 == cRows) <br>        return ResultFromScode( S_OK ); <br> <br>    // Check for Invalid Arguments <br>    if ((1 &gt;= cRows) &amp;&amp; (NULL == rghRows)) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // Process row handles <br>    while (ihRow &lt; cRows) <br>    { <br>if (rgRowStatus) <br>rgRowStatus[ihRow] = DBROWSTATUS_S_OK; <br> <br>        // Is row handle valid <br>        if (S_OK != (m_pObj-&gt;m_prowbitsIBuffer)-&gt;IsSlotSet((ULONG) rghRows[ihRow] )) <br>        { <br>            // Log Error <br>if (rgRowStatus) <br>rgRowStatus[ihRow]= DBROWSTATUS_E_INVALID; <br> <br>            cErrors++; <br>            ihRow++; <br>            continue; <br>} <br> <br>        // Get RowBuffer to look at which row this applies to <br>        pbProvRow = (BYTE *) (m_pObj-&gt;GetRowBuff((ULONG) rghRows[ihRow] )); <br> <br>        // Has row already been deleted <br>        //  S_OK means deleted <br>        if (S_OK == m_pObj-&gt;m_pFileio-&gt;IsDeleted((ULONG) ((PROWBUFF) pbProvRow)-&gt;pbBmk )) <br>        { <br>if (rgRowStatus) <br>rgRowStatus[ihRow] = DBROWSTATUS_E_DELETED; <br>            cErrors++; <br>            ihRow++; <br>            continue; <br>        } <br> <br>        // Delete the Row, <br>        if (S_OK != m_pObj-&gt;m_pFileio-&gt;DeleteRow((ULONG) ((PROWBUFF) pbProvRow)-&gt;pbBmk )) <br>        { <br>// Some better decision as to what rowstatus to set could be done here.. <br>if (rgRowStatus) <br>rgRowStatus[ihRow] = DBROWSTATUS_E_PERMISSIONDENIED; <br>            cErrors++; <br>            ihRow++; <br>            continue; <br>        } <br>} //while <br> <br> <br>// If everything went OK except errors in rows use DB_S_ERRORSOCCURRED. <br>return cErrors ? (cErrors &lt; cRows) ?  <br>ResultFromScode(DB_S_ERRORSOCCURRED) :  <br> ResultFromScode(DB_E_ERRORSOCCURRED) :  <br> ResultFromScode(S_OK); <br>} <br> <br>// CImpIRowsetChange::InsetRow  -------------------------------------------- <br>// <br>// @mfunc Insert row into provider <br>// <br>// @rdesc HRESULT <br>//      @flag E_NOTSUPPORTED| this method is not implemented <br>// <br>STDMETHODIMP    CImpIRowsetChange::InsertRow <br>    ( <br>    HCHAPTERhReserved, <br>HACCESSORhAccessor, <br>void*pData, <br>HROW*phRow <br>) <br>{ <br>    return ResultFromScode( DB_E_NOTSUPPORTED ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
