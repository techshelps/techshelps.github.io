<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLASSFAC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2314"></a>CLASSFAC.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module CLASSFAC.CPP | The module contains the DLL Entry and Exit <br>// points, plus the OLE ClassFactory class. <br>// <br>// <br> <br>// Includes ------------------------------------------------------------------ <br> <br>#include "headers.h" <br>#include "classfac.h" <br> <br> <br>// Static vars --------------------------------------------------------------- <br> <br>static const char * s_strDllName = "SampProv";  // used with GetModuleHandle <br>static const struct <br>{ <br>    char * strRegKey; <br>    char * strValue; <br>} s_rgRegInfo[] = <br>{ <br>    { "SampProv",  "Microsoft OLE DB Sample Provider" }, <br>    { "SampProv\\Clsid", "{E8CCCB79-7C36-101B-AC3A-00AA0044773D}" }, <br>    { "CLSID\\{E8CCCB79-7C36-101B-AC3A-00AA0044773D}", "SampProv" }, <br>    { "CLSID\\{E8CCCB79-7C36-101B-AC3A-00AA0044773D}\\ProgID", "SampProv" }, <br>    { "CLSID\\{E8CCCB79-7C36-101B-AC3A-00AA0044773D}\\VersionIndependentProgID", "SampProv" }, <br>    { "CLSID\\{E8CCCB79-7C36-101B-AC3A-00AA0044773D}\\InprocServer32", "%s" }, <br>{ "CLSID\\{E8CCCB79-7C36-101B-AC3A-00AA0044773D}\\OLE DB Provider", "Microsoft OLE DB Sample Provider"}, <br>}; <br> <br>// Code ---------------------------------------------------------------------- <br> <br>// DllMain ------------------------------------------------------------------- <br>// <br>// @func DLL Entry point where Instance and Thread attach/detach notifications <br>// takes place.  OLE is initialized and the IMalloc Interface pointer is obtained. <br>// <br>// @rdesc Boolean Flag <br>//      @flag TRUE | Successful initialization <br>//      @flag FALSE | Failure to intialize <br>// <br>BOOL WINAPI DllMain <br>    ( <br>    HINSTANCE   hInstDLL,   //@parm IN | Application Instance Handle <br>    DWORD       fdwReason,  //@parm IN | Indicated Process or Thread activity <br>    LPVOID      lpvReserved //@parm IN | Reserved... <br>    ) <br>{ <br>    BOOL        fRetVal = FALSE; <br>    HRESULT     hr; <br>    SYSTEM_INFO SystemInformation; <br> <br>    switch (fdwReason) <br>        { <br>    case DLL_PROCESS_ATTACH: <br> <br>        // Assume successfully initialized <br>        fRetVal = TRUE; <br> <br>        // Do one-time initialization when first process attaches <br>        if (!g_cAttachedProcesses) <br>            { <br>            g_hInstance = hInstDLL; <br> <br>            // Get the OLE task memory allocator; we'll use it to allocate <br>            // all memory that we return to the client <br>            hr = CoGetMalloc( MEMCTX_TASK, &amp;g_pIMalloc ); <br>            if (!g_pIMalloc || !SUCCEEDED( hr )) <br>                { <br>                fRetVal = FALSE; <br>                break; <br>                } <br> <br>            // Get the system page size <br>            if (!g_dwPageSize) <br>                { <br>                GetSystemInfo( &amp;SystemInformation );    // can't fail <br>                g_dwPageSize = SystemInformation.dwPageSize; <br>                } <br>            } <br> <br>        // Do per-process initialization here... <br>         <br>        // Remember that another process successfully attached <br>        g_cAttachedProcesses++; <br>        break; <br> <br>    case DLL_PROCESS_DETACH: <br>        // Clean up when the last process is going away <br>        if (g_cAttachedProcesses == 1) <br>            { <br>            // Release the memory allocator object. <br>            if (g_pIMalloc) <br>                g_pIMalloc-&gt;Release(); <br>            g_pIMalloc = NULL; <br> <br>            } <br> <br>        // Do per-process clean up here... <br> <br>        // Remember that a process has detached <br>        g_cAttachedProcesses--; <br>        break; <br> <br>    case DLL_THREAD_ATTACH: <br>        break; <br> <br>    case DLL_THREAD_DETACH: <br>        break; <br>        } <br> <br>    return fRetVal; <br>} <br> <br> <br>// DllGetClassObject --------------------------------------------------------- <br>// <br>// @func This function is exposed to OLE so that the classfactory can <br>// be obtained. <br>// <br>// @rdesc HRESULT indicating status of routine <br>//      @flag S_OK                      | The object was retrieved successfully. <br>//      @flag CLASS_E_CLASSNOTAVAILABLE | DLL does not support class. <br>//      @flag E_OUTOFMEMORY             | Out of memory. <br>//      @flag E_INVALIDARG              | One or more arguments are invalid. <br>//      @flag E_UNEXPECTED              | An unexpected error occurred. <br>//      @flag OTHER | Other HRESULTs returned by called functions <br>// <br>HRESULT CALLBACK DllGetClassObject <br>    ( <br>    REFCLSID    rclsid, //@parm IN | CLSID of the object class to be loaded <br>    REFIID      riid,   //@parm IN | Interface on object to be instantiated <br>    LPVOID *    ppvObj  //@parm OUT | Pointer to interface that was instantiated <br>    ) <br>{ <br>    CClassFactory * pClassFactory; <br>    HRESULT         hr; <br> <br>    // Check for valid ppvObj pointer <br>    if (!ppvObj) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // In case we fail, we need to zero output arguments <br>    *ppvObj = NULL; <br> <br>    // We only service CLSID_SampProv <br>    if (rclsid != CLSID_SampProv) <br>        return ResultFromScode( CLASS_E_CLASSNOTAVAILABLE ); <br> <br>    // We only support the IUnknown and IClassFactory interfaces <br>    if (riid != IID_IUnknown &amp;&amp; <br>        riid != IID_IClassFactory) <br>        return ResultFromScode( E_NOINTERFACE ); <br> <br>    // Create our ClassFactory object <br>    pClassFactory = new CClassFactory(); <br>    if (pClassFactory == NULL) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    // Get the desired interface on this object <br>    hr = pClassFactory-&gt;QueryInterface( riid, ppvObj ); <br>    if (!SUCCEEDED( hr )) <br>        delete pClassFactory; <br> <br>    return hr; <br>} <br> <br> <br>// DllCanUnloadNow ----------------------------------------------------------- <br>// <br>// @func Indicates whether the DLL is no longer in use and <br>// can be unloaded. <br>// <br>// @rdesc HRESULT indicating status of routine <br>//      @flag S_OK | DLL can be unloaded now. <br>//      @flag S_FALSE | DLL cannot be unloaded now. <br>// <br>STDAPI DllCanUnloadNow( void ) <br>{ <br>    if (!g_cObj &amp;&amp; !g_cLock) <br>        return ResultFromScode( S_OK ); <br>    else <br>        return ResultFromScode( S_FALSE ); <br>} <br> <br> <br>//----------------------------------------------------------------------------- <br>// CClassFactory <br>//----------------------------------------------------------------------------- <br> <br>// CClassFactory ------------------------------------------------------------- <br>// <br>// @mfunc Constructor for this class <br>// <br>// @rdesc NONE <br>// <br>CClassFactory::CClassFactory <br>    ( <br>    void <br>    ) <br>{ <br>    m_cRef = 0; <br> <br>    // Increment global object count <br>    OBJECT_CONSTRUCTED(); <br>} <br> <br>// ~CClassFactory ------------------------------------------------------------ <br>// <br>// @mfunc Destructor for this class <br>// <br>// @rdesc NONE <br>// <br>CClassFactory:: ~CClassFactory( void ) <br>{ <br>    // Decrement global object count <br>    OBJECT_DESTRUCTED(); <br>} <br> <br>// QueryInterface ------------------------------------------------------------ <br>// <br>// @mfunc Returns a pointer to a specified interface. Callers use <br>// QueryInterface to determine which interfaces the called object <br>// supports. <br>// <br>// @rdesc HRESULT indicating the status of the method <br>//      @flag S_OK          | Interface is supported and ppvObject is set. <br>//      @flag E_NOINTERFACE | Interface is not supported by the object <br>//      @flag E_INVALIDARG  | One or more arguments are invalid. <br>// <br>STDMETHODIMP CClassFactory::QueryInterface <br>    ( <br>    REFIID      riid,   //@parm IN | Interface ID of the interface being queried for. <br>    LPVOID *    ppvObj  //@parm OUT | Pointer to interface that was instantiated <br>    ) <br>{ <br>    // Check for valid ppvObj pointer <br>    if (!ppvObj) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // In case we fail, we need to zero output arguments <br>    *ppvObj = NULL; <br> <br>    // Do we support this interface? <br>    if (riid == IID_IUnknown || <br>        riid == IID_IClassFactory) <br>        *ppvObj = (LPVOID) this; <br> <br>    // If we're going to return an interface, AddRef it first <br>    if (*ppvObj) <br>        { <br>        ((LPUNKNOWN) *ppvObj)-&gt;AddRef(); <br>        return ResultFromScode( S_OK ); <br>        } <br>    else <br>        return ResultFromScode( E_NOINTERFACE ); <br>} <br> <br>// AddRef -------------------------------------------------------------------- <br>// <br>// @mfunc Increments a persistence count for the object <br>// <br>// @rdesc Current reference count <br>// <br>STDMETHODIMP_( ULONG ) CClassFactory::AddRef( void ) <br>{ <br>    return ++m_cRef; <br>} <br> <br>// Release ------------------------------------------------------------------- <br>// <br>// @mfunc Decrements a persistence count for the object and if <br>// persistence count is 0, the object destroys itself. <br>// <br>// @rdesc Current reference count <br>// <br>STDMETHODIMP_( ULONG ) CClassFactory::Release( void ) <br>{ <br>    if (!--m_cRef) <br>        { <br>        delete this; <br>        return 0; <br>        } <br> <br>    return m_cRef; <br>} <br> <br>// CreateInstance ------------------------------------------------------------ <br>// <br>// @mfunc Creates an uninitialized instance of an object class. <br>// Initialization is subsequently performed using another <br>// interface-specific method <br>// <br>// @rdesc HRESULT indicating the status of the method <br>//      @flag S_OK          | Interface is supported and ppvObject is set. <br>//      @flag E_NOINTERFACE | Interface is not supported by the object <br>//      @flag E_INVALIDARG  | One or more arguments are invalid. <br>//      @flag E_OUTOFMEMORY | Memory could not be allocated <br>//      @flag OTHER         | Other HRESULTs returned by called functions <br>// <br>STDMETHODIMP CClassFactory::CreateInstance <br>    ( <br>    LPUNKNOWN   pUnkOuter,  //@parm IN | Points to the controlling IUnknown interface <br>    REFIID      riid,       //@parm IN | Interface ID of the interface being queried for. <br>    LPVOID *    ppvObj      //@parm OUT | Pointer to interface that was instantiated <br>    ) <br>{ <br>    PCDATASOURCE    pObj; <br>    HRESULT         hr; <br> <br>    // Check for valid ppvObj pointer <br>    if (ppvObj == NULL) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    // In case we fail, we need to zero output arguments <br>    *ppvObj = NULL; <br> <br>    // If we're given a controlling IUnknown, it must ask for IUnknown. <br>    // Otherwise, the caller will end up getting a pointer to their pUnkOuter <br>    // instead of to the new object we create and will have no way of getting <br>    // back to this new object, so they won't be able to free it.  Bad! <br>    if (pUnkOuter &amp;&amp; riid != IID_IUnknown) <br>        return ResultFromScode( E_NOINTERFACE ); <br> <br>    // Prepare for the possibility that there might be an error <br>    hr = ResultFromScode( E_OUTOFMEMORY ); <br> <br>    // Create a CDataSource object <br>    if (!(pObj = new CDataSource( pUnkOuter ))) <br>        return hr; <br> <br>    // Initialize it <br>    if (pObj-&gt;FInit()) <br>        hr = pObj-&gt;QueryInterface( riid, ppvObj ); <br> <br>    if (FAILED( hr )) <br>        delete pObj; <br> <br>    return hr; <br>} <br> <br>// LockServer ---------------------------------------------------------------- <br>// <br>// @mfunc Controls whether an object application is kept in memory. <br>// Keeping the application alive in memory allows instances of this <br>// class to be created more quickly. <br>// <br>// @rdesc HRESULT indicating the status of the method <br>//      @flag S_OK | Interface is supported and ppvObject is set. <br>// <br>STDMETHODIMP CClassFactory::LockServer <br>    ( <br>    BOOL fLock                  //@parm IN | TRUE or FALSE to lock or unlock <br>    ) <br>{ <br>    if (fLock) <br>        InterlockedIncrement( &amp;g_cLock ); <br>    else <br>        InterlockedDecrement( &amp;g_cLock ); <br> <br>    return NOERROR; <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// @func    Removes keys to the registry. <br>// <br>// @rdesc Returns NOERROR <br>// <br>// @comm <br>// Special Notes:   This allows us to avoid using a .reg file. <br>// <br>// Note that a more robust method would be to trace existing <br>// CLSID and ProgID, and trace each from the other.  This would handle the <br>// case where either changed.  Then should probably enumerate all keys under <br>// the ProgID and CLSID, then delete them. <br>// <br>// Also note the problem with our exposing a different CLSID for the debug <br>// and ndebug versions, yet the ProgID remains the same.  Should we have <br>// different ProgID's also? <br>// <br>//--------------------------------------------------------------------------- <br>STDAPI DllUnregisterServer <br>    ( <br>    void <br>    ) <br>{ <br>    int     i; <br>    int     iNumErrors = 0; <br>LONGstat; <br> <br>    // Delete all table entries.  Loop in reverse order, since they <br>    // are entered in a basic-to-complex order. <br>    // We cannot delete a key that has subkeys. <br>    // Ignore errors. <br>    for (i=NUMELEM( s_rgRegInfo ) - 1; i &gt;= 0; i--) <br>        { <br>stat = RegDeleteKey( HKEY_CLASSES_ROOT, s_rgRegInfo[i].strRegKey ); <br>        if ((stat != ERROR_SUCCESS) &amp;&amp;  <br>        (stat != ERROR_FILE_NOT_FOUND) ) <br>            iNumErrors++; <br>        } <br> <br>    return ResultFromScode( iNumErrors ? E_FAIL : S_OK ); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// @func    Adds necessary keys to the registry. <br>// <br>// @rdesc Returns one of the following <br>// @flag NOERROR    | Registration succeeded <br>// @flag E_FAIL     | Something didn't work <br>// <br>// @comm <br>// Special Notes:   This allows us to avoid using a .reg file. <br>// Here is what was in the SampProv.REG file of yore. <br>// Note that now we have two CLSID's, one for DEBUG.  Then each one <br>// can point to a different .DLL. <br>// <br>//--------------------------------------------------------------------------- <br>STDAPI DllRegisterServer <br>    ( <br>    void <br>    ) <br>{ <br>    int         i; <br>    HKEY        hk; <br>    HMODULE     hModule; <br>    DWORD       dwDisposition; <br>    LONG        stat; <br>    char        strOutBuff[300 ], strFileName[MAX_PATH + 1 ]; <br> <br>    // Get the full path name for this DLL. <br>    if (NULL == (hModule = GetModuleHandle( s_strDllName ))) <br>        return ResultFromScode( E_FAIL ); <br>    if (0 == GetModuleFileName( hModule, strFileName, sizeof( strFileName ) / sizeof( char ))) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Make a clean start <br>    DllUnregisterServer(); <br> <br>    // Loop through s_rgRegInfo, and put everything in it. <br>    // Every entry is based on HKEY_CLASSES_ROOT. <br>    for (i=0; i &lt; NUMELEM( s_rgRegInfo ); i++) <br>        { <br>        // Fill in any "%s" arguments with the name of this DLL. <br>        wsprintf( strOutBuff, s_rgRegInfo[i].strValue, strFileName ); <br> <br>        // Create the Key.  If it exists, we open it. <br>        // Thus we can still change the value below. <br>        stat = RegCreateKeyEx( <br>                HKEY_CLASSES_ROOT, <br>                s_rgRegInfo[i].strRegKey, <br>                0,  // dwReserved <br>                NULL,   // lpszClass <br>                REG_OPTION_NON_VOLATILE, <br>                KEY_ALL_ACCESS, // security access mask <br>                NULL,   // lpSecurityAttributes <br>                &amp;hk,    // phkResult <br>                &amp;dwDisposition ); <br>        if (stat != ERROR_SUCCESS) <br>            return ResultFromScode( E_FAIL ); <br> <br>        stat = RegSetValueEx( <br>                hk, // created above <br>                NULL,   // lpszValueName <br>                0,  // dwReserved <br>                REG_SZ, // fdwType <br>                (BYTE *) strOutBuff,    // value <br>                strlen( strOutBuff ) + sizeof( char )); // cbData, including null terminator <br>        RegCloseKey( hk ); <br>        if (stat != ERROR_SUCCESS) <br>            return ResultFromScode( E_FAIL ); <br>        } <br> <br>    return ResultFromScode( S_OK ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
