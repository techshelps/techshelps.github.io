<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BITARRAY.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2312"></a>BITARRAY.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module BITARRAY.CPP | This contains an implementation of a bit array <br>// class currently used by the Internal Buffer to mark released or <br>// unreleased rows. <br>// <br>// <br>#include "headers.h" <br>#include "bitarray.h" <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Constructor for this class <br>// <br>// @rdesc NONE <br>// <br>CBitArray::CBitArray <br>    ( <br>    void <br>    ) <br>{ <br>    m_rgbBit       = NULL; <br>    m_cPageMax     = 0; <br>    m_cPageCurrent = 0; <br>    m_cslotCurrent = 0; <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Destructor for this class <br>// <br>// @rdesc NONE <br>// <br>CBitArray:: ~CBitArray <br>    ( <br>    void <br>    ) <br>{ <br>    if (m_rgbBit) <br>        { <br>        if (m_cPageCurrent) <br>            VirtualFree((VOID *) m_rgbBit, m_cPageCurrent *m_cbPage, MEM_DECOMMIT ); <br>        VirtualFree((VOID *) m_rgbBit, 0, MEM_RELEASE ); <br>        } <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Allocate and Initialize the array of bits <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK          | Initialization succeeded <br>//      @flag  E_OUTOFMEMORY | Not enough memory to allocate bit array <br>// <br>STDMETHODIMP CBitArray::FInit <br>    ( <br>    ULONG cslotMax,     //@parm IN  | Maximum number of slot <br>    ULONG cbPage        //@parm IN  | Count of bytes per page <br>    ) <br>{ <br>    ULONG cPage; <br>    ULONG ib; <br> <br>    cPage = (cslotMax / 8 + 1) / cbPage + 1; <br>    m_rgbBit = (BYTE *) VirtualAlloc( NULL, cbPage *cPage, MEM_RESERVE, PAGE_READWRITE ); <br> <br>    if (m_rgbBit == NULL) <br>        return ResultFromScode( E_OUTOFMEMORY ); <br> <br>    m_cPageMax = cPage; <br> <br>    m_cbPage = cbPage; <br> <br>    for (ib =0; ib &lt; 8; ib++) <br>        m_rgbBitMask[ib] = (1 &lt;&lt; ib); <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Set a range of bit slots <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK          | Initialization succeeded <br>//      @flag  E_OUTOFMEMORY | Not enough memory to allocate bit array <br>// <br>STDMETHODIMP CBitArray::SetSlots <br>    ( <br>    ULONG islotFirst,   //@parm IN | First slot in range to set <br>    ULONG islotLast             //@parm IN | Last slot in range to set <br>    ) <br>{ <br>    ULONG islot; <br> <br>    if (islotLast &gt;=    m_cslotCurrent) <br>        { <br>        ULONG cPageAdd; <br> <br>        cPageAdd = ((islotLast - m_cslotCurrent + 1) / 8 + 1) / m_cbPage + 1; <br> <br>        if ((cPageAdd + m_cPageCurrent) &gt; m_cPageMax <br>            || VirtualAlloc( m_rgbBit + m_cPageCurrent*m_cbPage, cPageAdd *m_cbPage, MEM_COMMIT, PAGE_READWRITE ) == NULL) <br>            return ResultFromScode( E_OUTOFMEMORY ); <br> <br>        memset( m_rgbBit + m_cPageCurrent*m_cbPage, 0x00, cPageAdd *m_cbPage ); <br>        m_cPageCurrent += cPageAdd; <br>        m_cslotCurrent += cPageAdd *m_cbPage *8; <br>        } <br> <br>    // Only do this top section <br>    // if we have at least 2 byte's worth of bits to set. <br>    // Although no real speedup until we have 3 byte's worth. <br>    // Note really ought to be ((ilast-ifirst+1) &gt;= 2*8). <br>    // (Note could use CHAR_BIT, num bits in a char.) <br>    // Also optimized end cases, so nothing is done <br>    // if the start or end is byte aligned. <br>    // Need this copied into ResetSlots. <br> <br>    //if((islotLast -islotFirst) &gt; 2*sizeof(BYTE)) <br>    if (islotLast - islotFirst &gt; 2 * 8) <br>        { <br>        ULONG ibFirst, ibLast; <br>        int iFixFirst, iFixLast; <br> <br>        ibFirst = islotFirst / 8; <br>        ibLast  = islotLast / 8; <br>        iFixFirst = (islotFirst % 8 != 0);  // set to 1 if first byte not totally set <br>        iFixLast  = (islotLast % 8 != 7);   // set to 1 if last  byte not totally set <br> <br>        if (iFixFirst) <br>            for (islot = islotFirst; (islot / 8) == ibFirst; islot++) <br>                m_rgbBit[islot / 8] |= m_rgbBitMask[islot % 8]; <br> <br>        memset( &amp;m_rgbBit[ibFirst + iFixFirst], 0xff, ibLast - ibFirst + 1 - iFixFirst - iFixLast ); <br> <br>        if (iFixLast) <br>            for (islot = islotLast; (islot / 8) == ibLast; islot--) <br>                m_rgbBit[islot / 8] |= m_rgbBitMask[islot % 8]; <br>        } <br>    else <br>        { <br>        for (islot = islotFirst; islot &lt;= islotLast; islot++) <br>            m_rgbBit[islot / 8] |= m_rgbBitMask[islot % 8]; <br>        } <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Clear all bit slots <br>// <br>// @rdesc NONE <br>// <br>VOID CBitArray::ResetAllSlots <br>    ( <br>    void <br>    ) <br>{ <br>    memset( m_rgbBit, 0x00, m_cPageCurrent*m_cbPage ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Reset a range of slots <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK | Reset Succeeded <br>// <br>STDMETHODIMP CBitArray::ResetSlots <br>    ( <br>    ULONG islotFirst,   //@parm IN | First slot in range to reset <br>    ULONG islotLast     //@parm IN | Last slot in range to reset <br>    ) <br>{ <br>    ULONG ibFirst, ibLast, islot; <br> <br>    if (islotFirst &lt; m_cslotCurrent) <br>        { <br>        if (islotLast &gt;=    m_cslotCurrent) <br>            islotLast = m_cslotCurrent - 1; <br> <br>        if ((islotLast - islotFirst) &gt; 2*8) <br>            { <br>            ibFirst = islotFirst / 8; <br>            ibLast  = islotLast / 8; <br>            for (islot = islotFirst; (islot / 8) == ibFirst; islot++) <br>                m_rgbBit[islot / 8] &amp;= ~m_rgbBitMask[islot % 8]; <br>            memset( &amp;m_rgbBit[ibFirst + 1], 0x00, ibLast - ibFirst - 1 ); <br>            for (islot = islotLast; (islot / 8) == ibLast; islot--) <br>                m_rgbBit[islot / 8] &amp;= ~m_rgbBitMask[islot % 8]; <br>            } <br>        else <br>            { <br>            for (islot = islotFirst; islot &lt;= islotLast; islot++) <br>                m_rgbBit[islot / 8] &amp;= ~m_rgbBitMask[islot % 8]; <br>            } <br>        } <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Determines if any bits are set <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK     | Array is Empty <br>//      @flag  S_FALSE  | Array contains set bits <br>// <br>STDMETHODIMP CBitArray::ArrayEmpty <br>    ( <br>    void <br>    ) <br>{ <br>    if (m_cPageCurrent) <br>        { <br>        ULONG idw, cdw, *rgdw; <br> <br>        cdw = m_cPageCurrent * (m_cbPage / sizeof( ULONG )); <br>        rgdw = (ULONG *) m_rgbBit; <br>        for (idw =0; idw &lt; cdw; idw++) <br>            if (rgdw[idw]) <br>                return ResultFromScode( S_FALSE ); <br>        } <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Determine if a particular bit slot is set <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK          | Slot is set <br>//      @flag  E_OUTOFMEMORY | Slot is not set <br>// <br>STDMETHODIMP CBitArray::IsSlotSet <br>    ( <br>    ULONG islot                 //@parm IN | Bit slot to check <br>    ) <br>{ <br>    if (islot &gt;= m_cslotCurrent || (m_rgbBit[islot / 8] &amp; m_rgbBitMask[islot % 8]) == 0x00) <br>        return ResultFromScode( S_FALSE );  // not set <br>    else <br>        return ResultFromScode( S_OK ); // is set <br>} <br> <br> <br>//-------------------------------------------------------------------- <br>// @mfunc Find the first set slot within the bit array given a starting <br>// position <br>// <br>// @rdesc HRESULT indicating routines status <br>//      @flag  S_OK          | Initialization succeeded <br>//      @flag  E_OUTOFMEMORY | Not enough memory to allocate bit array <br>// <br>STDMETHODIMP CBitArray::FindSet <br>    ( <br>    ULONG islotStart,   //@parm IN | Starting slot to search from <br>    ULONG islotLimit,   //@parm IN | Number of slots to check <br>    ULONG *pislot       //@parm OUT | Index of first set slot <br>    ) <br>{ <br>    ULONG ibStart, ibLimit, idwStart, idwLimit, ibEnd, ib, islot, islotEnd, idw, *pdw; <br> <br>    if (islotStart &gt; islotLimit) <br>        { <br>        ibStart  = islotStart / 8; <br>        ibLimit  = islotLimit / 8; <br>        if ((ibStart - ibLimit) &gt; 1) <br>            { <br>            islotEnd = ibStart*8; <br>            for (islot = islotStart; islot &gt;= islotEnd; islot--) <br>                if (m_rgbBit[islot / 8] &amp; m_rgbBitMask[islot % 8]) <br>                    { <br>                    *pislot = islot; <br>                    return ResultFromScode( S_OK ); <br>                    } <br>            idwStart = islotStart / 32; <br>            idwLimit = islotLimit / 32; <br>            if (idwStart - idwLimit &gt; 1) <br>                { <br>                ibEnd = idwStart*4; <br>                for (ib = ibStart - 1; ib &gt;= ibEnd; ib--) <br>                    if (m_rgbBit[ib]) <br>                        { <br>                        islot = ib*8 + 7; <br>                        goto Found1; <br>                        } <br>                for (pdw = (ULONG *) &amp; m_rgbBit[ (idwStart - 1) *4], idw = idwStart - 1; idw &gt; idwLimit; idw--, pdw--) <br>                    if (*pdw) <br>                        { <br>                        islot = idw*32 + 31; <br>                        goto Found1; <br>                        } <br>                ib = (idwLimit*4 + 3); <br>                } <br>            else <br>                ib = ibStart - 1; <br>            for (; ib &gt; ibLimit; ib--) <br>                if (m_rgbBit[ib]) <br>                    { <br>                    islot = ib*8 + 7; <br>                    goto Found1; <br>                    } <br>            islot = (ibLimit*8 + 7); <br>            } <br>        else <br>            islot = islotStart; <br> <br>        Found1: <br>        for (; islot &gt;= islotLimit; islot--) <br>            if (m_rgbBit[islot / 8] &amp; m_rgbBitMask[islot % 8]) <br>                { <br>                *pislot = islot; <br>                return ResultFromScode( S_OK ); <br>                } <br>        return ResultFromScode( S_FALSE );  // not found <br>        } <br>    else <br>        return ResultFromScode( E_FAIL ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
