<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ROWSET.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2341"></a>ROWSET.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Provider <br>// (C) Copyright 1994 - 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module ROWSET.CPP | CRowset object implementation <br>// <br>// <br> <br>// Includes ------------------------------------------------------------------ <br> <br>#include "headers.h" <br> <br>static const MAX_BITS = 1008; <br> <br>static const TYPE_CHAR = 1; <br>static const TYPE_SLONG = 3; <br> <br>// Code ---------------------------------------------------------------------- <br> <br>// CRowset::CRowset ---------------------------------------------------------- <br>// <br>// @mfunc Constructor for this class <br>// <br>// @rdesc NONE <br>// <br>CRowset::CRowset <br>    ( <br>    LPUNKNOWN pUnkOuter         //@parm IN | Outer Unkown Pointer <br>    ) <br>{ <br> <br>    //  Initialize simple member vars <br>    m_cRef          = 0L; <br>    m_pUnkOuter     = pUnkOuter; <br> <br>    // Intialize buffered row count + pointers to allocated memory <br>    m_pFileio           = NULL; <br>    m_cRows             = 0; <br>    m_irowFilePos       = 0; <br>    m_irowLastFilePos   = 0; <br>    m_cbRowSize         = 0; <br>    m_cbHeapUsed        = 0; <br>    m_irowMin           = 0; <br>    m_ulRowRefCount     = 0; <br>    m_rgdbcolinfo       = NULL; <br>    m_pbHeap            = NULL; <br>    m_rgdwDataOffsets   = NULL; <br>    m_rgfIsSigned       = NULL; <br>    m_rgcbLen           = NULL; <br>    m_pextbufferAccessor= NULL; <br>    m_pIBuffer          = NULL; <br>    m_prowbitsIBuffer   = NULL; <br>    m_pLastBindBase     = NULL; <br>    m_rgbRowData        = NULL; <br>    m_dwStatus          = 0; <br>    m_pUtilProp         = NULL; <br>m_pCreator= NULL; <br> <br>    //  Initially, NULL all contained interfaces <br>    m_pIColumnsInfo                 = NULL; <br>    m_pIRowset                      = NULL; <br>    m_pIRowsetChange                = NULL; <br>    m_pIAccessor                    = NULL; <br>    m_pIRowsetInfo                  = NULL; <br> <br>    // Increment global object count. <br>    OBJECT_CONSTRUCTED(); <br> <br>    return; <br>} <br> <br> <br>// CRowset::~CRowset --------------------------------------------------------- <br>// <br>// @mfunc Destructor for this class <br>// <br>// @rdesc NONE <br>// <br>CRowset:: ~CRowset <br>    ( <br>    void <br>    ) <br>{ <br>    // Release buffer for column names (pointed to by m_rgdbcolinfo). <br>    if (NULL != m_pbHeap) <br>        VirtualFree((VOID *) m_pbHeap, 0, MEM_RELEASE ); <br> <br>    // Free pointers. <br>    // (Note delete is safe for NULL ptr.) <br>    delete [] m_rgdbcolinfo; <br>    delete [] m_rgdwDataOffsets; <br>    delete [] m_rgfIsSigned; <br>    delete [] m_rgcbLen; <br>    delete    m_prowbitsIBuffer; <br>    delete    m_pUtilProp; <br> <br>    if (NULL != m_pIBuffer) <br>        ReleaseSlotList( m_pIBuffer ); <br> <br>    // Free accessors. <br>    // Each accessor is allocated via new/delete. <br>    // We store an array of ptrs to each accessor (m_pextbufferAccessor). <br>    if (NULL != m_pextbufferAccessor) <br>        { <br>        ULONG       hAccessor, hAccessorLast; <br>        PACCESSOR   pAccessor; <br> <br>        m_pextbufferAccessor-&gt;GetFirstLastItemH( hAccessor, hAccessorLast ); <br>        for (; hAccessor &lt;= hAccessorLast; hAccessor++) <br>            { <br>            m_pextbufferAccessor-&gt;GetItemOfExtBuffer( hAccessor, &amp;pAccessor ); <br>            delete [] pAccessor; <br>            } <br>        delete m_pextbufferAccessor; <br>        } <br> <br>    //  Free contained interfaces <br>    delete m_pIColumnsInfo; <br>    delete m_pIRowset; <br>    delete m_pIRowsetChange; <br>    delete m_pIAccessor; <br>    delete m_pIRowsetInfo; <br> <br>    // free CFileio object <br>    if (m_pFileio) <br>        delete m_pFileio; <br> <br>// Decrement the DBSession Count.  GetSpecification is not possible anymore <br>if( m_pCreator ) <br>{ <br>// Mark the session as not having an open rowset anymore <br>m_pCreator-&gt;RowsetDestroyed(); <br>m_pCreator-&gt;Release(); <br>} <br> <br>    // Decrement global object count. <br>    OBJECT_DESTRUCTED(); <br> <br>    return; <br>} <br> <br>// CRowset::FInit ------------------------------------------------------------ <br>// <br>// @mfunc Initialize the rowset Object <br>// <br>// @rdesc Did the Initialization Succeed <br>//      @flag  TRUE | Initialization succeeded <br>//      @flag  FALSE | Initialization failed <br>// <br>BOOL CRowset::FInit <br>    ( <br>    CFileIO*    pCFileio        //@parm IN | pointer to Fileio object <br>    ) <br>{ <br>    LPUNKNOWN   pIUnknown = (LPUNKNOWN) this; <br> <br>    if (m_pUnkOuter) <br>        pIUnknown = m_pUnkOuter; <br> <br>    m_pFileio = pCFileio; <br> <br>    // Find # of columns in the result set. <br>    m_cCols = m_pFileio-&gt;GetColumnCnt(); <br>    if (m_cCols &lt;= 0) <br>        return FALSE; <br> <br>    //--------------------- <br>    // Allocate info arrays <br>    //--------------------- <br> <br>    // Heap for column names. <br>    // Commit it all, then de-commit and release once we know size. <br>    m_pbHeap = (BYTE *) VirtualAlloc( NULL, <br>                                      MAX_HEAP_SIZE, <br>                                      MEM_RESERVE | MEM_COMMIT, <br>                                      PAGE_READWRITE ); <br>    if (NULL == m_pbHeap) <br>        return FALSE; <br> <br>    // Add an extra index, so we can be 1 based <br>    m_rgdbcolinfo     = new DBCOLUMNINFO[m_cCols + 1]; <br>    m_rgdwDataOffsets = new ULONG[m_cCols + 1]; <br>    m_rgfIsSigned     = new BOOL[m_cCols + 1]; <br>    m_rgcbLen         = new SDWORD[m_cCols + 1]; <br> <br>    if (   m_rgdbcolinfo == NULL <br>        || m_rgdwDataOffsets == NULL <br>        || m_rgfIsSigned == NULL <br>        || m_rgcbLen == NULL) <br>        return FALSE; <br> <br>    if (FAILED( GatherColumnInfo())) <br>        return FALSE; <br> <br>    if (FAILED( CreateHelperFunctions())) <br>        return FALSE; <br> <br>    //-------------------- <br>    // Perform binding <br>    //-------------------- <br>    // Bind result set columns to the first row of the internal buffer. <br>    // For each column bind it's data as well as length. Leave space for <br>    // derived status info. <br>    // Note that we could defer binding, but this way we can check for <br>    // bad errors before we begin. <br>    // We may need to bind again if going back and forth <br>    // with GetNextRows. <br>    assert( m_rgbRowData ); <br>    if (FAILED( Rebind((BYTE *) GetRowBuff( m_irowMin )))) <br>        return FALSE; <br> <br>    // allocate utility object that manages our properties <br>    m_pUtilProp = new CUtilProp(); <br> <br>    // Allocate contained interface objects <br>    // Note that our approach is simple - we always create *all* of the Rowset interfaces <br>    // If our properties were read\write (i.e., could be set), we would need to <br>    // consult properties to known which interfaces to create. <br>    // Also, none of our interfaces conflict. If any did conflict, then we could <br>    // not just blindly create them all. <br>    m_pIColumnsInfo             = new CImpIColumnsInfo( this, pIUnknown ); <br>    m_pIRowset                  = new CImpIRowset( this, pIUnknown ); <br>    m_pIRowsetChange            = new CImpIRowsetChange( this, pIUnknown ); <br>    m_pIAccessor                = new CImpIAccessor( this, pIUnknown ); <br>    m_pIRowsetInfo              = new CImpIRowsetInfo( this, pIUnknown ); <br> <br> <br>    // if all interfaces were created, return success <br>    return (BOOL) (m_pIColumnsInfo &amp;&amp; <br>                   m_pIRowset &amp;&amp; <br>                   m_pIRowsetChange &amp;&amp; <br>                   m_pIAccessor &amp;&amp; <br>                   m_pIRowsetInfo); <br>} <br> <br> <br>// CRowset::QueryInterface --------------------------------------------------- <br>// <br>// @mfunc Returns a pointer to a specified interface. Callers use <br>// QueryInterface to determine which interfaces the called object <br>// supports. <br>// <br>// @rdesc HRESULT indicating the status of the method <br>//      @flag S_OK | Interface is supported and ppvObject is set. <br>//      @flag E_NOINTERFACE | Interface is not supported by the object <br>//      @flag E_INVALIDARG | One or more arguments are invalid. <br>// <br>STDMETHODIMP CRowset::QueryInterface <br>    ( <br>    REFIID riid, <br>    LPVOID * ppv <br>    ) <br>{ <br>    if (NULL == ppv) <br>        return ResultFromScode( E_INVALIDARG ); <br> <br>    //  Place NULL in *ppv in case of failure <br>    *ppv = NULL; <br> <br>    //  This is the non-delegating IUnknown implementation <br>    if (riid == IID_IUnknown) <br>        *ppv = (LPVOID) this; <br>    else if (riid == IID_IRowset) <br>        *ppv = (LPVOID) m_pIRowset; <br>    else if (riid == IID_IColumnsInfo) <br>        *ppv = (LPVOID) m_pIColumnsInfo; <br>    else if (riid == IID_IRowsetChange) <br>        *ppv = (LPVOID) m_pIRowsetChange; <br>    else if (riid == IID_IAccessor) <br>        *ppv = (LPVOID) m_pIAccessor; <br>    else if (riid == IID_IRowsetInfo) <br>        *ppv = (LPVOID) m_pIRowsetInfo; <br> <br> <br>    //  If we're going to return an interface, AddRef it first <br>    if (*ppv) <br>        { <br>        ((LPUNKNOWN) *ppv)-&gt;AddRef(); <br>        return ResultFromScode( S_OK ); <br>        } <br>    else <br>        return ResultFromScode( E_NOINTERFACE ); <br>} <br> <br> <br>// CRowset::AddRef ----------------------------------------------------------- <br>// <br>// @mfunc Increments a persistence count for the object <br>// <br>// @rdesc Current reference count <br>// <br>STDMETHODIMP_( ULONG ) CRowset::AddRef <br>     ( <br>     void <br>     ) <br>{ <br>    return ++m_cRef; <br>} <br> <br> <br>// CRowset::Release ---------------------------------------------------------- <br>// <br>// @mfunc Decrements a persistence count for the object and if <br>// persistence count is 0, the object destroys itself. <br>// <br>// @rdesc Current reference count <br>// <br>STDMETHODIMP_( ULONG ) CRowset::Release <br>     ( <br>     void <br>     ) <br>{ <br>    if (!--m_cRef) <br>        { <br>        delete this; <br>        return 0; <br>        } <br> <br>    return m_cRef; <br>} <br> <br>// CRowset::CreateHelperFunctions -------------------------------------------- <br>// <br>// @mfunc Creates Helper classes that are needed to manage the Rowset Object <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Helper classes created <br>//      @flag E_FAIL | Helper classes were not created <br>// <br>HRESULT CRowset::CreateHelperFunctions <br>    ( <br>    void <br>    ) <br>{ <br>    //---------------------- <br>    // Create helper objects <br>    //---------------------- <br> <br>    // Bit array to track presence/absense of rows. <br>    m_prowbitsIBuffer = new CBitArray; <br>    if (m_prowbitsIBuffer == NULL || FAILED( m_prowbitsIBuffer-&gt;FInit( MAX_BITS, g_dwPageSize ))) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // List of free slots. <br>    // This manages the allocation of sets of contiguous rows. <br>    if (FAILED( InitializeSlotList( MAX_TOTAL_ROWBUFF_SIZE / m_cbRowSize, <br>                         m_cbRowSize, g_dwPageSize, m_prowbitsIBuffer, <br>                         &amp;m_pIBuffer, &amp;m_rgbRowData ))) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Create the ExtBuffer array. <br>    // This is an array of pointers to malloc'd accessors. <br>    m_pextbufferAccessor = (LPEXTBUFFER) new CExtBuffer; <br>    if (m_pextbufferAccessor == NULL || FAILED( m_pextbufferAccessor-&gt;FInit( 1, sizeof( PACCESSOR ), g_dwPageSize ))) <br>        return ResultFromScode( E_FAIL ); <br> <br>    // Locate some free slots. <br>    // Should be at very beginning. <br>    // This tells us which row we will bind to: m_irowMin. <br>    if (FAILED( GetNextSlots( m_pIBuffer, 1, &amp;m_irowMin ))) <br>        return ResultFromScode( E_FAIL ); <br> <br>    ReleaseSlots( m_pIBuffer, m_irowMin, 1 ); <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>// CRowset::GatherColumnInfo ------------------------------------------------- <br>// <br>// @mfunc Creates DBCOLINFO structures for each column in the result set. <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Column Info Obtained <br>//      @flag E_FAIL | Problems getting Column Info <br>// <br>HRESULT CRowset::GatherColumnInfo <br>    ( <br>    void <br>    ) <br>{ <br>    HRESULT         hr; <br>    LPWSTR          lpwstr; <br>    int             cchFree, cchWide; <br>    DBCOLUMNINFO*   pcolinfo; <br>    ULONG           dwOffset; <br>    UWORD           icol; <br>    SWORD           cbName; <br>    SWORD           swCSVType; <br>    UDWORD          cbColDef; <br>    DWORD           dwdbtype; <br> <br>    //---------------------------------- <br>    // Gather column info <br>    //---------------------------------- <br> <br>    lpwstr  = (LPWSTR) m_pbHeap; <br>    cchFree = MAX_HEAP_SIZE / 2; <br> <br>    pcolinfo = &amp;m_rgdbcolinfo[1]; <br>    dwOffset = offsetof( ROWBUFF, cdData ); <br> <br>    for (icol=1; icol &lt;= m_cCols; icol++, pcolinfo++) <br>        { <br>        LPTSTR ptstrName; <br> <br>        // Get Column Names and Lengths <br>        hr = m_pFileio-&gt;GetColumnName( icol, &amp;ptstrName ); <br>        if (FAILED( hr )) <br>            return ResultFromScode( E_FAIL ); <br> <br>        // Store the Column Name in the Heap <br>        if (cchFree) <br>            { <br>            cbName = lstrlen( ptstrName ); <br>            if (cbName) <br>                cchWide = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, ptstrName, (int) cbName, lpwstr, cchFree ); <br>            else <br>                cchWide = 0; <br>            pcolinfo-&gt;pwszName = lpwstr; <br>            lpwstr += cchWide; <br> <br>            cchFree -= cchWide; <br>            if (cchFree) <br>                { <br>                *lpwstr++ = 0; <br>                cchFree--; <br>                } <br>            else <br>                *(lpwstr - 1) = 0; <br>            } <br>        else <br>            pcolinfo-&gt;pwszName = NULL; <br> <br>        // Get DataTypes and Precision <br>        hr = m_pFileio-&gt;GetDataTypes( icol, <br>                        &amp;swCSVType, // CSV data type <br>                        &amp;cbColDef,  // Precision <br>                        &amp;m_rgfIsSigned[icol]    // Signed or Unsigned <br>                        ); <br>        if (FAILED( hr )) <br>            return ResultFromScode( E_FAIL ); <br> <br>        // We use ordinal numbers for our columns <br>        pcolinfo-&gt;columnid.eKind          = DBKIND_GUID_PROPID; <br>        pcolinfo-&gt;columnid.uGuid.guid     = GUID_NULL; <br>        pcolinfo-&gt;columnid.uName.ulPropid = icol; <br> <br>        // Determine the OLE DB type, for binding. <br>        hr = GetInternalTypeFromCSVType( swCSVType,              // in <br>                                         m_rgfIsSigned[icol],    // in <br>                                         &amp;dwdbtype );            // out, DBTYPE to show client <br>        if (FAILED( hr )) <br>            return ResultFromScode( E_FAIL ); <br> <br>        // Check for overflow of size. <br>        m_rgcbLen[icol] = cbColDef; <br>        m_rgcbLen[icol] = MIN( m_rgcbLen[icol], MAX_BIND_LEN ); <br> <br>        pcolinfo-&gt;iOrdinal= icol; <br>        pcolinfo-&gt;wType= (DBTYPE) dwdbtype; <br>        pcolinfo-&gt;pTypeInfo     = NULL; <br>        pcolinfo-&gt;ulColumnSize  = m_rgcbLen[icol]; <br>        pcolinfo-&gt;bPrecision    = (BYTE)cbColDef; <br>        pcolinfo-&gt;bScale        = 0; <br>        pcolinfo-&gt;dwFlags       = 0; <br> <br>        // Is it a fixed length datatype <br>        if(pcolinfo-&gt;wType != DBTYPE_STR) <br>        pcolinfo-&gt;dwFlags |= DBCOLUMNFLAGS_ISFIXEDLENGTH; <br> <br>        // We do support nulls <br>        pcolinfo-&gt;dwFlags |= DBCOLUMNFLAGS_ISNULLABLE; <br> <br>        //We should always be able to write to the column <br>        pcolinfo-&gt;dwFlags |= DBCOLUMNFLAGS_WRITE; <br> <br>        // Set the offset from the start of the row, <br>        // for this column, then advance past. <br>        dwOffset = ROUND_UP( dwOffset, COLUMN_ALIGNVAL ); <br>        m_rgdwDataOffsets[icol] = dwOffset; <br>        dwOffset += offsetof( COLUMNDATA, bData ) + m_rgcbLen[icol]; <br>        } <br> <br>    m_cbRowSize = ROUND_UP( dwOffset, COLUMN_ALIGNVAL ); <br>    m_cbHeapUsed = MAX_HEAP_SIZE - 2*cchFree; <br> <br>    // Decommit unused memory in our column-name buffer. <br>    // We know it will never grow beyond what it is now. <br>    // Decommit all pages past where we currently are. <br>    BYTE  *pDiscardPage; <br>    ULONG  ulSize; <br>    pDiscardPage = (BYTE *) ROUND_UP( lpwstr, g_dwPageSize ); <br>    ulSize       = MAX_HEAP_SIZE - (pDiscardPage - m_pbHeap); <br>    if (ulSize &gt; 0) <br>        VirtualFree( pDiscardPage, ulSize, MEM_DECOMMIT ); <br>    assert( '\0' == (*lpwstr = '\0'));  // We shouldn't generate a mem fault. <br> <br>    return ResultFromScode( S_OK ); <br> <br>} <br> <br>// CRowset::Rebind -------------------------------------------- <br>// <br>// @mfunc Establishes data offsets and type for the file <br>// routines to place the data <br>// <br>// @rdesc HRESULT <br>//      @flag S_OK | Bindings set fine <br>//      @flag E_FAIL | Bindings could not be set <br>// <br>HRESULT CRowset::Rebind <br>    ( <br>    BYTE *pBase                 //@parm IN | Base pointer for Data Area <br>    ) <br>{ <br>    UWORD       icol; <br>    COLUMNDATA  *pColumn; <br> <br>    // Bind result set columns. <br>    // Use established types and sizes and offsets. <br>    // Bind to internal row buffer, area beginning with 'pRowBuff'. <br>    // <br>    // For each column, bind it's data as well as length. <br>    // Offsets point to start of COLUMNDATA structure. <br> <br>    assert( pBase ); <br>    assert( m_rgdwDataOffsets ); <br>    assert( m_rgcbLen ); <br> <br>    // Optimize by not doing it over again. <br>    if (pBase != m_pLastBindBase) <br>        { <br>        m_pLastBindBase = 0; <br> <br>        for (icol=1; icol &lt;= m_cCols; icol++) <br>            { <br>            pColumn = (COLUMNDATA *) (pBase + m_rgdwDataOffsets[icol]); <br>            if (FAILED( m_pFileio-&gt;SetColumnBind( icol, pColumn, m_rgcbLen[icol] ))) <br>                return ResultFromScode( E_FAIL ); <br>            } <br> <br>        // Remember in case we bind to same place again. <br>        m_pLastBindBase = pBase; <br>        } <br> <br>    return ResultFromScode( S_OK ); <br>} <br> <br> <br>// CRowset::GetRowBuff-------------------------------------------- <br>// <br>// @mfunc Shorthand way to get the address of a row buffer. <br>// Later we may extend this so that it can span several <br>// non-contiguous blocks of memory. <br>// <br>// @rdesc Pointer to the buffer. <br>// <br>ROWBUFF* CRowset::GetRowBuff <br>    ( <br>    ULONG iRow                  //@parm IN | Row to get address of. <br>    ) <br>{ <br>    // This assumes iRow is valid... <br>    // How can we calculate maximum row? <br>    // Should we return NULL if it's out of range? <br>    assert( m_rgbRowData ); <br>    assert( m_cbRowSize ); <br>    assert( iRow &gt; 0 ); <br>    return (ROWBUFF *) (m_rgbRowData + m_cbRowSize*iRow); <br>} <br> <br> <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>//      Helper functions    Helper functions    Helper functions <br>////////////////////////////////////////////////////////////////////////////// <br> <br>// GetInternalTypeFromCSVType ------------------------------------------------ <br>// <br>// @func This function returns the default OLE DB representation <br>// for a data type <br>// <br>HRESULT GetInternalTypeFromCSVType <br>    ( <br>    SWORD  swDataType,  //@parm IN | Data Type <br>    BOOL   fIsSigned,   //@parm IN | Signed or Unsigned <br>    DWORD  *pdwdbType   //@parm OUT | OLE DB type for DBColumnInfo <br>    ) <br>{ <br>    static struct { <br>        SWORD   swCSVType; <br>        BOOL    fIsSigned;          // 1=signed, 0=unsigned <br>        BOOL    fSignedDistinction; // 1=signed matters <br>        DWORD   dwdbType; <br>    } TypeTable[] = <br>        { <br>            {TYPE_CHAR,         0, 0, DBTYPE_STR }, <br>            {TYPE_SLONG,        1, 1, DBTYPE_I4  }, <br>        }; <br> <br>    for (int j=0; j &lt; NUMELEM( TypeTable ); j++) <br>        { <br>        if (swDataType == TypeTable[j].swCSVType        // type match <br>        &amp;&amp; (!TypeTable[j].fSignedDistinction            // care about sign? <br>            || fIsSigned == TypeTable[j].fIsSigned))    // sign match <br>            { <br>            assert( pdwdbType ); <br>            *pdwdbType     = TypeTable[j].dwdbType; <br>            return ResultFromScode( S_OK ); <br>            } <br>        } <br> <br>    // Should never get here, since we supposedly have <br>    // a table of all possible CSV types. <br>    assert( !"Unmatched CSV Type." ); <br>    return ResultFromScode( E_FAIL ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
