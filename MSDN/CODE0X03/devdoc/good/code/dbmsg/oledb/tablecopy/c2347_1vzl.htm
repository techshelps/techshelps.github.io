<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STEP1.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2361"></a>STEP1.CPP</h2>
<pre><code>//----------------------------------------------------------------------------- <br>// Microsoft OLE DB TABLECOPY Sample <br>// Copyright (C) 1996 By Microsoft Corporation. <br>// <br>// @doc <br>// <br>// @module STEP1.CPP <br>// <br>//----------------------------------------------------------------------------- <br> <br>///////////////////////////////////////////////////////////////////// <br>// Includes <br>// <br>///////////////////////////////////////////////////////////////////// <br>#include "wizard.h" <br>#include "common.h" <br>#include "table.h" <br> <br> <br>///////////////////////////////////////////////////////////////////// <br>// CS1Dialog::CS1Dialog <br>// <br>///////////////////////////////////////////////////////////////////// <br>CS1Dialog::CS1Dialog(HWND hWnd, HINSTANCE hInst, CTableCopy* pCTableCopy) <br>: CDialog(hWnd, hInst) <br>{ <br>ASSERT(pCTableCopy); <br>m_pCTableCopy = pCTableCopy; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////// <br>// CS1Dialog::~CS1Dialog <br>// <br>///////////////////////////////////////////////////////////////////// <br>CS1Dialog::~CS1Dialog() <br>{ <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ULONG CS1Dialog::Display <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>ULONG CS1Dialog::Display() <br>{ <br>return DialogBoxParam(m_hInst, MAKEINTRESOURCE(IDD_FROM_INFO), NULL, DlgProc, (LPARAM)this); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////// <br>// CS1Dialog::DlgProc <br>// <br>///////////////////////////////////////////////////////////////////// <br>BOOL WINAPI CS1Dialog::DlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>switch(msg)  <br>{ <br>case WM_INITDIALOG: <br>{ <br>//Store the "this" pointer, since this is a static method <br>CS1Dialog* pThis = (CS1Dialog*)lParam; <br>SetWindowLong(hWnd, GWL_USERDATA, (LONG)pThis); <br> <br>//On INIT we know we have a valid hWnd to store <br>pThis-&gt;m_hWnd = hWnd; <br>CTable* pCFromTable = pThis-&gt;m_pCTableCopy-&gt;m_pCFromTable; <br> <br>//Init all controls to the default values <br>pThis-&gt;InitControls(); <br> <br>// If there is a source to look at, Display the table list <br>if(pCFromTable-&gt;IsConnected())  <br>pThis-&gt;ResetTableList(GetDlgItem(hWnd, IDL_TABLES), GetDlgItem(hWnd, IDL_COLUMNS)); <br> <br>pThis-&gt;RefreshControls(); <br>CenterDialog(hWnd); <br>return HANDLED_MSG; <br>} <br> <br>case WM_COMMAND: <br>{ <br>//Obtain the "this" pointer <br>CS1Dialog* pThis = (CS1Dialog*)GetWindowLong(hWnd, GWL_USERDATA); <br> <br>CTable* pCFromTable = pThis-&gt;m_pCTableCopy-&gt;m_pCFromTable; <br>CTable* pCToTable = pThis-&gt;m_pCTableCopy-&gt;m_pCToTable; <br> <br>// First check for regular command ids <br>switch(GET_WM_COMMAND_ID(wParam, lParam))  <br>{ <br>case IDB_FROM_CONNECT: <br>{ <br>//Try to connect to the DataSource <br>if(pCFromTable-&gt;Connect(hWnd)) <br>pThis-&gt;ResetTableList(GetDlgItem(hWnd, IDL_TABLES), GetDlgItem(hWnd, IDL_COLUMNS)); <br> <br>pThis-&gt;RefreshControls(); <br>return HANDLED_MSG; <br>} <br> <br>case IDC_TABLES: <br>case IDC_VIEWS: <br>case IDC_SYSTABLES: <br>case IDC_SYNONYMS: <br>{ <br>//Reset the available table list, with the new restrictions <br>pThis-&gt;ResetTableList(GetDlgItem(hWnd, IDL_TABLES), GetDlgItem(hWnd, IDL_COLUMNS)); <br> <br>//refresh any controls <br>pThis-&gt;RefreshControls(); <br>return HANDLED_MSG; <br>} <br> <br>                case IDOK: <br>pThis-&gt;GetTableColInfo(); <br> <br>case IDCANCEL: <br>                EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam)); <br>return HANDLED_MSG; <br>} <br> <br>// Now look for notification messages <br>switch (GET_WM_COMMAND_CMD(wParam, lParam))  <br>case LBN_SELCHANGE: <br>{ <br>// A table change requires a new list of columns <br>if(IDL_TABLES == GET_WM_COMMAND_ID(wParam, lParam))  <br>{ <br>WCHAR wszName[MAX_NAME_LEN]; <br> <br>//Obtain the TableName includes (username.tablename) <br>WPARAM nRow = (WPARAM)SendDlgItemMessage(hWnd, IDL_TABLES, LB_GETCURSEL, 0, 0L); <br>wSendMessage(GetDlgItem(hWnd, IDL_TABLES), LB_GETTEXT, (WPARAM)nRow, wszName); <br>  <br>//Only Reset if selected a different TableName <br>if(wcscmp(wszName, pCFromTable-&gt;m_wszQualTableName)!=0) <br>{ <br>//Extract just the tablename <br>ULONG ulTableOffset = SendDlgItemMessage(hWnd, IDL_TABLES, LB_GETITEMDATA, nRow, 0L); <br> <br>//Qualified Name <br>wcscpy(pCFromTable-&gt;m_wszQualTableName, wszName); <br>wcscpy(pCFromTable-&gt;m_wszTableName, wszName + ulTableOffset); <br> <br>//Schema Name <br>wcsncpy(pCFromTable-&gt;m_wszSchemaName, wszName, ulTableOffset); <br>pCFromTable-&gt;m_wszSchemaName[ulTableOffset-1] = L'\0'; <br> <br>//Free the current columns list, since the new  <br>//table will have diffent columns <br>pCFromTable-&gt;m_cColumns = 0; <br>SAFE_FREE(pCFromTable-&gt;m_rgColDesc); <br> <br>//Reset the column list, since we have a new table <br>pThis-&gt;ResetColInfo(GetDlgItem(hWnd, IDL_COLUMNS)); <br> <br>//Reset the index list, since we have a new table <br>pCFromTable-&gt;m_cIndexes = 0; <br>SAFE_FREE(pCFromTable-&gt;m_rgIndexInfo); <br> <br>//Reset the "To" table, since we have a new table <br>pCToTable-&gt;m_wszTableName[0] = L'\0'; <br>} <br>} <br> <br>pThis-&gt;RefreshControls(); <br>return HANDLED_MSG; <br>} <br>} <br>} <br> <br>return UNHANDLED_MSG; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS1Dialog::InitControls <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS1Dialog::InitControls() <br>{ <br>//Setup defaults <br>CheckDlgButton(m_hWnd, IDC_TABLES,m_pCTableCopy-&gt;m_dwShowTypes &amp; SHOW_TABLES? BST_CHECKED : BST_UNCHECKED); <br>CheckDlgButton(m_hWnd, IDC_VIEWS,m_pCTableCopy-&gt;m_dwShowTypes &amp; SHOW_VIEWS? BST_CHECKED : BST_UNCHECKED); <br>CheckDlgButton(m_hWnd, IDC_SYSTABLES,m_pCTableCopy-&gt;m_dwShowTypes &amp; SHOW_SYSTABLES? BST_CHECKED : BST_UNCHECKED); <br>CheckDlgButton(m_hWnd, IDC_SYNONYMS,m_pCTableCopy-&gt;m_dwShowTypes &amp; SHOW_SYNONYMS? BST_CHECKED : BST_UNCHECKED); <br> <br>//Set Horizontal ScrollBar dimensions <br>SendDlgItemMessage(m_hWnd, IDL_TABLES, LB_SETHORIZONTALEXTENT, (WPARAM)120*4, (LPARAM)0); <br>SendDlgItemMessage(m_hWnd, IDL_COLUMNS, LB_SETHORIZONTALEXTENT, (WPARAM)120*4, (LPARAM)0); <br> <br>return TRUE; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS1Dialog::RefreshControls <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS1Dialog::RefreshControls() <br>{ <br>// Must have a connection to edit other controls <br>BOOL fConnected = m_pCTableCopy-&gt;m_pCFromTable-&gt;IsConnected(); <br>CDataSource* pCDataSource = m_pCTableCopy-&gt;m_pCFromTable-&gt;m_pCDataSource; <br> <br>//Enable dialog items, only if connected <br>EnableWindow(GetDlgItem(m_hWnd, IDC_SHOW_TYPES),fConnected); <br>EnableWindow(GetDlgItem(m_hWnd, IDC_TABLES),fConnected); <br>EnableWindow(GetDlgItem(m_hWnd, IDC_VIEWS),fConnected); <br>EnableWindow(GetDlgItem(m_hWnd, IDC_SYSTABLES),fConnected); <br>EnableWindow(GetDlgItem(m_hWnd, IDC_SYNONYMS),fConnected); <br> <br>EnableWindow(GetDlgItem(m_hWnd, IDT_TABLE_LIST),fConnected); <br>EnableWindow(GetDlgItem(m_hWnd, IDT_COLUMN_LIST),fConnected); <br>EnableWindow(GetDlgItem(m_hWnd, IDL_TABLES),fConnected); <br>EnableWindow(GetDlgItem(m_hWnd, IDL_COLUMNS),fConnected); <br> <br>//Save CheckBoxes status <br>m_pCTableCopy-&gt;m_dwShowTypes = SHOW_NONE; <br>if(IsDlgButtonChecked(m_hWnd, IDC_TABLES) == BST_CHECKED) <br>m_pCTableCopy-&gt;m_dwShowTypes |= SHOW_TABLES; <br>if(IsDlgButtonChecked(m_hWnd, IDC_VIEWS) == BST_CHECKED) <br>m_pCTableCopy-&gt;m_dwShowTypes |= SHOW_VIEWS; <br>if(IsDlgButtonChecked(m_hWnd, IDC_SYSTABLES) == BST_CHECKED) <br>m_pCTableCopy-&gt;m_dwShowTypes |= SHOW_SYSTABLES; <br>if(IsDlgButtonChecked(m_hWnd, IDC_SYNONYMS) == BST_CHECKED) <br>m_pCTableCopy-&gt;m_dwShowTypes |= SHOW_SYNONYMS; <br>  <br>//If there is at a table selected and at least 1 columns select <br>BOOL fColumnsSelected = (fConnected &amp;&amp;  <br>SendDlgItemMessage(m_hWnd, IDL_COLUMNS, LB_GETSELCOUNT, 0, 0L)); <br> <br>//Enable OK/Next if there is at least 1 columns selected <br>EnableWindow(GetDlgItem(m_hWnd, IDOK),fColumnsSelected); <br> <br>// Show user the connection string <br>if(fConnected) <br>{ <br>wSetDlgItemText(m_hWnd, IDT_CONNECT, wsz_CONNECT_STRING_,  <br>pCDataSource-&gt;m_pwszDataSource,  <br>pCDataSource-&gt;m_pwszUserName, <br>pCDataSource-&gt;m_pwszPassword, <br>pCDataSource-&gt;m_pwszDBMS, <br>pCDataSource-&gt;m_pwszDBMSVer); <br>} <br>else <br>{ <br>wSetDlgItemText(m_hWnd, IDT_CONNECT, wsz_NOT_CONNECTED); <br>wSetDlgItemText(m_hWnd, IDT_PROVIDER, wsz_NO_PROVIDER); <br>} <br> <br>if(pCDataSource-&gt;m_pwszProvider) <br>{ <br>wSetDlgItemText(m_hWnd, IDT_PROVIDER, wsz_PROVIDER_STRING_,  <br>pCDataSource-&gt;m_pwszProvider,  <br>pCDataSource-&gt;m_pwszProviderVer, <br>pCDataSource-&gt;m_pwszProviderOLEDBVer); <br>} <br>else <br>{ <br>wSetDlgItemText(m_hWnd, IDT_PROVIDER, wsz_NO_PROVIDER); <br>} <br> <br>return TRUE; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS1Dialog::GetTableColInfo <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS1Dialog::GetTableColInfo() <br>{ <br>CTable* pCFromTable = m_pCTableCopy-&gt;m_pCFromTable; <br> <br>// Initialize working variables <br>HWND hWndCol = GetDlgItem(m_hWnd, IDL_COLUMNS); <br> <br>// Get the list of selected items <br>LONG cColumns = SendDlgItemMessage(m_hWnd, IDL_COLUMNS, LB_GETSELCOUNT, 0, 0L); <br>LONG*rgColumns = NULL; <br>SAFE_ALLOC(rgColumns, LONG, cColumns); <br>SendMessage(hWndCol, LB_GETSELITEMS, (WPARAM)cColumns, (LPARAM)rgColumns); <br> <br>//Allocate space for the ColNames <br>SAFE_FREE(pCFromTable-&gt;m_rgColDesc); <br>SAFE_ALLOC(pCFromTable-&gt;m_rgColDesc, COLDESC, cColumns); <br>memset(pCFromTable-&gt;m_rgColDesc, 0, cColumns*sizeof(COLDESC)); <br>pCFromTable-&gt;m_cColumns = cColumns; <br> <br>if(LB_ERR != SendMessage(hWndCol, LB_GETSELITEMS, (WPARAM)cColumns, (LPARAM)rgColumns)) <br>{ <br>for(LONG i=0; i&lt;cColumns; i++)  <br>{ <br>//Obtain the entire ColumnName with TypeInfo <br>wSendMessage(hWndCol, LB_GETTEXT, (WPARAM)rgColumns[i], pCFromTable-&gt;m_rgColDesc[i].wszColName); <br> <br>//Obtain the ending point for just the table name <br>LONG lColumnOffset = SendMessage(hWndCol, LB_GETITEMDATA, (WPARAM)rgColumns[i], (LPARAM)0L); <br>ASSERT(lColumnOffset&gt;=0 &amp;&amp; lColumnOffset&lt;MAX_NAME_LEN); <br> <br>//End the ColName with an EOL, don't include the typeinfo <br>pCFromTable-&gt;m_rgColDesc[i].wszColName[lColumnOffset] = EOL; <br>} <br>} <br> <br>CLEANUP: <br>SAFE_FREE(rgColumns); <br>return TRUE; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS1Dialog::ResetTableList <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS1Dialog::ResetTableList(HWND hWndTable, HWND hWndCol) <br>{ <br>HRESULT hr; <br> <br>DWORDdwTableLoc; <br>LONGiRow; <br> <br>WCHARwszTypes[MAX_NAME_LEN]; <br>WCHARwszBuffer[MAX_NAME_LEN*2]; <br>SCHEMATABLESSchemaTables; <br> <br>IDBSchemaRowset* pIDBSchemaRowset = NULL; <br>IRowset* pIRowset = NULL; <br>IAccessor* pIAccessor = NULL; <br> <br>//get the data <br>HROW*rghRows = NULL; <br>ULONGi,cRowsObtained = 0; <br> <br>HACCESSOR hAccessor = DB_NULL_HACCESSOR; <br>Busy(); <br> <br>//Use the passed in Session interface <br>CTable*pCFromTable = m_pCTableCopy-&gt;m_pCFromTable; <br>IDBCreateCommand* pIDBCreateCommand = pCFromTable-&gt;m_pCDataSource-&gt;m_pIDBCreateCommand; <br> <br>// Figure out types to enumrate based on options <br>SendMessage(hWndTable, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0L); <br>GetTypes(wszTypes); <br>  <br>//set up the restrictions <br>const ULONG cRestrictions = 4; <br>VARIANTrgRestrictions[cRestrictions]; <br> <br>//Init the restrictions <br>InitVariants(cRestrictions, rgRestrictions); <br> <br>// Bind the user and table name for the list <br>const ULONG cBindings = 2; <br>const DBBINDING rgBindings[cBindings] = { <br>2,  <br>offsetof(SCHEMATABLES, wszUserName),// offset of value in consumers buffer <br>0,// offset of length <br>0,// offset of status <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies Value is bound only <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>MAX_NAME_LEN,// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_WSTR, // data type indicator <br>0,// precision <br>0, // scale <br> <br> <br>3, // ordinal <br>offsetof(SCHEMATABLES, wszTableName),// offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies Value only <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,// input param <br>MAX_NAME_LEN,// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_WSTR, // data type indicator <br>0,// precision <br>0, // scale <br> <br>}; <br> <br>//Setup the restrictions <br>rgRestrictions[0].vt = VT_BSTR; <br>SAFE_SYSALLOC(rgRestrictions[0].bstrVal, pCFromTable-&gt;m_pCDataSource-&gt;m_pwszCatalog); <br>rgRestrictions[1].vt = VT_EMPTY; <br>rgRestrictions[2].vt = VT_EMPTY; <br>rgRestrictions[3].vt = VT_BSTR; <br>SAFE_SYSALLOC(rgRestrictions[3].bstrVal, wszTypes); <br> <br>//get IDBSchemaRowset interface <br>XTESTC(hr = pIDBCreateCommand-&gt;QueryInterface(IID_IDBSchemaRowset,(void**)&amp;pIDBSchemaRowset)); <br> <br>//GetRowset <br>//DBSCHEMA_TABLES is required a SCHEMA <br>XTESTC(hr = pIDBSchemaRowset-&gt;GetRowset(NULL, DBSCHEMA_TABLES, cRestrictions, rgRestrictions,  <br>IID_IRowset, 0, NULL,(IUnknown **)&amp;pIRowset)); <br> <br>XTESTC(hr = pIRowset-&gt;QueryInterface(IID_IAccessor, (void **)&amp;pIAccessor)); <br> <br>//Create the Accessor <br>XTESTC(hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, cBindings, rgBindings, 0, &amp;hAccessor, NULL)); <br> <br> <br>//Grab all the rows <br>while(TRUE) <br>{ <br>hr = pIRowset-&gt;GetNextRows(NULL, 0, MAX_BLOCK_SIZE, &amp;cRowsObtained, &amp;rghRows); <br>if(FAILED(hr) || cRowsObtained==0) <br>break; <br> <br>//Loop over the rows retrived <br>for (i=0; i&lt;cRowsObtained; i++)  <br>{ <br>//Reset the SchemaTables <br>memset(&amp;SchemaTables, 0, sizeof(SCHEMATABLES)); <br> <br>//Get the Data <br>XTESTC(hr = pIRowset-&gt;GetData(rghRows[i], hAccessor, (void *)&amp;SchemaTables)); <br> <br>// If there is a user, format buffer in a familiar way <br>if(SchemaTables.wszUserName[0])  <br>{ <br>//QualififedTableName = "dbo.authors" <br>swprintf(wszBuffer, L"%s%s%s", SchemaTables.wszUserName, pCFromTable-&gt;m_wszIDSeperator, SchemaTables.wszTableName); <br>iRow = wSendMessage(hWndTable, LB_ADDSTRING, (WPARAM)0, wszBuffer); <br>dwTableLoc = wcslen(SchemaTables.wszUserName) + wcslen(pCFromTable-&gt;m_wszIDSeperator); <br>} <br>else  <br>{ <br>//QualififedTableName = "authors" <br>iRow = wSendMessage(hWndTable, LB_ADDSTRING, (WPARAM)0, SchemaTables.wszTableName); <br>dwTableLoc = 0; <br>} <br> <br>// Store the offset of the table name with the item, so that we know <br>// where to start translating later. <br>SendMessage(hWndTable, LB_SETITEMDATA, (WPARAM)iRow, (LPARAM)dwTableLoc); <br>} <br> <br>//Release the rows obtained <br>XTESTC(hr = pIRowset-&gt;ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL)); <br>SAFE_FREE(rghRows); <br>} <br> <br>// If there was a previous selection, select it again on Back <br>    if(pCFromTable-&gt;m_wszQualTableName[0])  <br>{ <br>    LONGlFoundTable; <br> <br>lFoundTable = wSendMessage(hWndTable, LB_FINDSTRINGEXACT, <br>    (WPARAM)0, pCFromTable-&gt;m_wszQualTableName); <br>         <br>    // If there was a selection, select it now <br>    if(lFoundTable != LB_ERR) <br>{ <br>SendMessage(hWndTable, LB_SETCURSEL, (WPARAM)lFoundTable, (LPARAM)0L); <br>ResetColInfo(hWndCol); <br>} <br>else   <br>{ <br>   //else we need to clear the columns list <br>   SendMessage(hWndCol, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0L); <br>} <br>    } <br>     <br>Busy(); <br> <br> <br>CLEANUP: <br>//Free Restrictions <br>FreeVariants(cRestrictions, rgRestrictions); <br> <br>if(hAccessor &amp;&amp; pIAccessor) <br>XTEST(pIAccessor-&gt;ReleaseAccessor(hAccessor,NULL)); <br> <br>SAFE_RELEASE(pIDBSchemaRowset); <br>SAFE_RELEASE(pIRowset); <br>SAFE_RELEASE(pIAccessor); <br> <br>SAFE_FREE(rghRows); <br>return hr==S_OK; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS1Dialog::ResetColInfo <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS1Dialog::ResetColInfo(HWND hWndCol) <br>{ <br>HRESULT hr; <br> <br>WCHARwszBuffer[MAX_NAME_LEN]; <br>SCHEMACOLUMNSSchemaColumns; <br> <br>IDBSchemaRowset* pIDBSchemaRowset = NULL; <br>IRowset* pIRowset = NULL; <br>IAccessor* pIAccessor = NULL; <br> <br>HACCESSOR hAccessor = DB_NULL_HACCESSOR; <br> <br>HROW*rghRows = NULL; <br>ULONGi,cRowsObtained = 0; <br>Busy(); <br> <br>//Use the passed in Session interface <br>//Use the passed in Session interface <br>CTable*pCFromTable = m_pCTableCopy-&gt;m_pCFromTable; <br>IDBCreateCommand* pIDBCreateCommand = pCFromTable-&gt;m_pCDataSource-&gt;m_pIDBCreateCommand; <br> <br>// Get a list of columns based on the selected table <br>SendMessage(hWndCol, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0L); <br> <br>//set up the restrictions <br>const ULONG cRestrictions = 4; <br>VARIANTrgRestrictions[cRestrictions]; <br> <br>InitVariants(cRestrictions, rgRestrictions); <br> <br>// Bind the user and table name for the list <br>const ULONG cBindings = 9; <br>const DBBINDING rgBindings[cBindings] =  <br>{ <br>4,  <br>offsetof(SCHEMACOLUMNS, wszColName),// offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>MAX_NAME_LEN,// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_WSTR, // data type indicator <br>0,// precision <br>0, // scale <br> <br>5,  <br>offsetof(SCHEMACOLUMNS, guidCol),// offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(GUID),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_GUID, // data type indicator <br>0,// precision <br>0, // scale <br> <br>7,  <br>offsetof(SCHEMACOLUMNS, iOrdinal),// offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(ULONG),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_UI4, // data type indicator <br>0,// precision <br>0, // scale <br> <br>10,  <br>offsetof(SCHEMACOLUMNS, dwFlags),// offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(DBCOLUMNFLAGS),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_UI4, // data type indicator <br>0,// precision <br>0, // scale <br> <br>12,  <br>offsetof(SCHEMACOLUMNS, wType), // offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(USHORT),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_UI2, // data type indicator <br>0,// precision <br>0, // scale <br> <br>13,  <br>offsetof(SCHEMACOLUMNS, guidType), // offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(GUID),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_GUID, // data type indicator <br>0,// precision <br>0, // scale <br> <br>14,  <br>offsetof(SCHEMACOLUMNS, ulMaxLength),// offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(ULONG),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_UI4, // data type indicator <br>0,// precision <br>0, // scale <br> <br>16,  <br>offsetof(SCHEMACOLUMNS, wPrecision),// offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(USHORT),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_UI2, // data type indicator <br>0,// precision <br>0, // scale <br> <br>17,  <br>offsetof(SCHEMACOLUMNS, wScale),// offset of value in consumers buffer <br>0,// offset of length in consumers buffer <br>0,// offset of status in consumers buffer <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies value parts <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(USHORT),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_UI2, // data type indicator <br>0,// precision <br>0, // scale <br>}; <br> <br> <br>//set up the restrictions <br>rgRestrictions[0].vt = DBTYPE_BSTR; <br>SAFE_SYSALLOC(rgRestrictions[0].bstrVal, pCFromTable-&gt;m_pCDataSource-&gt;m_pwszCatalog); <br>rgRestrictions[1].vt = DBTYPE_EMPTY; <br>rgRestrictions[2].vt = DBTYPE_BSTR; <br>SAFE_SYSALLOC(rgRestrictions[2].bstrVal, pCFromTable-&gt;m_wszTableName); <br>rgRestrictions[3].vt = DBTYPE_EMPTY; <br> <br>//get IDBSchemaRowset interface <br>XTESTC(hr = pIDBCreateCommand-&gt;QueryInterface(IID_IDBSchemaRowset,(void**)&amp;pIDBSchemaRowset)); <br> <br>//GetRowset <br>//DBSCHEMA_COLUMNS is required a SCHEMA <br>XTESTC(hr = pIDBSchemaRowset-&gt;GetRowset(NULL, DBSCHEMA_COLUMNS, cRestrictions, rgRestrictions,  <br>IID_IRowset, 0, NULL, (IUnknown **)&amp;pIRowset)); <br> <br>XTESTC(hr = pIRowset-&gt;QueryInterface(IID_IAccessor, (void **)&amp;pIAccessor)); <br> <br>//Create the Accessor <br>XTESTC(hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, cBindings, rgBindings, 0, &amp;hAccessor, NULL)); <br> <br>//Grab all the rows <br>while(TRUE) <br>{ <br>hr = pIRowset-&gt;GetNextRows(NULL, 0, MAX_BLOCK_SIZE, &amp;cRowsObtained, &amp;rghRows); <br>if(FAILED(hr) || cRowsObtained==0) <br>break; <br> <br>//Loop over the rows retrived <br>for(ULONG i=0; i&lt;cRowsObtained; i++)  <br>{ <br>ULONG iColumn = 0; <br> <br>//Reset the SchemaColumn struct <br>memset(&amp;SchemaColumns, 0, sizeof(SCHEMACOLUMNS)); <br> <br>//Get the Data into the SchemaStruct <br>XTESTC(hr = pIRowset-&gt;GetData(rghRows[i], hAccessor, (void*)&amp;SchemaColumns)); <br> <br>//Format the string <br>//ColumnName Type- For Non-Numeric Columns - Fixed Columns <br>//ColumnName Type(ulMaxLength)- For Non-Numeric Columns - Vairable Columns  <br>//ColumnName Type(Precision, Scale)- For Numeric Columns  <br>//ColumnName Type(Precision)- For Numeric Columns - No Scale <br>if(IsVariableType(SchemaColumns.wType)) <br>{ <br>swprintf(wszBuffer, L"%-20s \t[%s](%lu)", SchemaColumns.wszColName, GetDBTypeName(SchemaColumns.wType), SchemaColumns.ulMaxLength); <br>} <br>else if(SchemaColumns.wType==DBTYPE_NUMERIC || SchemaColumns.wType==DBTYPE_DECIMAL) <br>{ <br>if(SchemaColumns.wScale) <br>swprintf(wszBuffer, L"%-20s \t[%s](%lu,%lu)", SchemaColumns.wszColName, GetDBTypeName(SchemaColumns.wType), SchemaColumns.wPrecision, SchemaColumns.wScale); <br>else <br>swprintf(wszBuffer, L"%-20s \t[%s](%lu)", SchemaColumns.wszColName, GetDBTypeName(SchemaColumns.wType), SchemaColumns.wPrecision); <br>} <br>else  <br>{ <br>swprintf(wszBuffer, wsz_COLUMN_FORMAT_, SchemaColumns.wszColName, GetDBTypeName(SchemaColumns.wType)); <br>} <br> <br>//Send the Formated String to the Window  <br>iColumn = wSendMessage(hWndCol, LB_ADDSTRING, (WPARAM)0, wszBuffer); <br> <br>//Now send where the ColName ends to the window <br>SendMessage(hWndCol, LB_SETITEMDATA, iColumn, (LPARAM)wcslen(SchemaColumns.wszColName)); <br>} <br> <br>//Release all rows <br>XTESTC(hr = pIRowset-&gt;ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL)); <br>SAFE_FREE(rghRows); <br>} <br> <br>// If there is an existing columns list (only on Back or error), then <br>// the user already has a list so use it. <br>for(i=0; i&lt;pCFromTable-&gt;m_cColumns; i++)  <br>{ <br>ASSERT(pCFromTable-&gt;m_rgColDesc); <br> <br>//Find the Column Name in the Window List <br>swprintf(wszBuffer, L"%s ", pCFromTable-&gt;m_rgColDesc[i].wszColName); <br>LONG lFoundColumn = wSendMessage(hWndCol, LB_FINDSTRING, (WPARAM)0, wszBuffer); <br> <br>//Select the Column Name if found in the list <br>if(lFoundColumn != LB_ERR) <br>SendMessage(hWndCol, LB_SETSEL, (WPARAM)TRUE, (LPARAM)lFoundColumn); <br>} <br> <br>//Otherwise, just select all as default <br>if(pCFromTable-&gt;m_cColumns == 0) <br>SendMessage(hWndCol, LB_SETSEL, (WPARAM)TRUE, (LPARAM)-1L); <br> <br>Busy(); <br> <br>CLEANUP: <br>//Free Restrictions <br>FreeVariants(cRestrictions, rgRestrictions); <br> <br>if(hAccessor &amp;&amp; pIAccessor) <br>XTEST(pIAccessor-&gt;ReleaseAccessor(hAccessor,NULL)); <br> <br>SAFE_RELEASE(pIDBSchemaRowset); <br>SAFE_RELEASE(pIRowset); <br>SAFE_RELEASE(pIAccessor); <br> <br>SAFE_FREE(rghRows); <br>return hr==S_OK; <br>} <br> <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS1Dialog::GetTypes <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS1Dialog::GetTypes(WCHAR* pwszTypes) <br>{ <br>ASSERT(pwszTypes); <br>pwszTypes[0] = EOL; <br> <br>//IDC_TABLES <br>if(IsDlgButtonChecked(m_hWnd, IDC_TABLES) == BST_CHECKED) <br>wcscat(pwszTypes, L"'TABLE',"); <br> <br>//IDC_VIEWS <br>if(IsDlgButtonChecked(m_hWnd, IDC_VIEWS) == BST_CHECKED) <br>wcscat(pwszTypes, L"'VIEW',"); <br> <br>//IDC_SYSTABLES <br>if(IsDlgButtonChecked(m_hWnd, IDC_SYSTABLES) == BST_CHECKED) <br>wcscat(pwszTypes, L"'SYSTEM TABLE',"); <br> <br>//IDC_SYNONYMS <br>if(IsDlgButtonChecked(m_hWnd, IDC_SYNONYMS) == BST_CHECKED) <br>wcscat(pwszTypes, L"'SYNONYM',"); <br> <br>//remove the trailing comma <br>if(pwszTypes[0] != EOL) <br>pwszTypes[wcslen(pwszTypes)-1] = EOL; <br> <br>return TRUE; <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
