<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STEP2.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2362"></a>STEP2.CPP</h2>
<pre><code>//----------------------------------------------------------------------------- <br>// Microsoft OLE DB TABLECOPY Sample <br>// Copyright (C) 1996 By Microsoft Corporation. <br>// <br>// @doc <br>// <br>// @module STEP2.CPP <br>// <br>//----------------------------------------------------------------------------- <br> <br> <br>///////////////////////////////////////////////////////////////////// <br>// Includes <br>// <br>///////////////////////////////////////////////////////////////////// <br>#include "wizard.h" <br>#include "common.h" <br>#include "tablecopy.h" <br>#include "table.h" <br> <br> <br> <br>///////////////////////////////////////////////////////////////////// <br>// CS2Dialog::CS2Dialog <br>// <br>///////////////////////////////////////////////////////////////////// <br>CS2Dialog::CS2Dialog(HWND hWnd, HINSTANCE hInst, CTableCopy* pCTableCopy) <br>: CDialog(hWnd, hInst) <br>{ <br>ASSERT(pCTableCopy); <br>m_pCTableCopy = pCTableCopy; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////// <br>// CS2Dialog::~CS2Dialog <br>// <br>///////////////////////////////////////////////////////////////////// <br>CS2Dialog::~CS2Dialog() <br>{ <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ULONG CS2Dialog::Display <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>ULONG CS2Dialog::Display() <br>{ <br>return DialogBoxParam(m_hInst, MAKEINTRESOURCE(IDD_INDEX_INFO), NULL, DlgProc, (LPARAM)this); <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////// <br>// CS2Dialog::DlgProc <br>// <br>///////////////////////////////////////////////////////////////////// <br>BOOL WINAPI CS2Dialog::DlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>switch(msg)  <br>{ <br>case WM_INITDIALOG: <br>{ <br>//Store the "this" pointer, since this is a static method <br>CS2Dialog* pThis = (CS2Dialog*)lParam; <br>SetWindowLong(hWnd, GWL_USERDATA, (LONG)pThis); <br> <br>//On INIT we know we have a valid hWnd to store <br>pThis-&gt;m_hWnd = hWnd; <br> <br>//Set Horizontal ScrollBar dimensions <br>SendDlgItemMessage(hWnd, IDL_INDEXES, LB_SETHORIZONTALEXTENT, (WPARAM)200, (LPARAM)0); <br> <br>pThis-&gt;ResetIndexList(GetDlgItem(hWnd, IDL_INDEXES)); <br>CenterDialog(hWnd); <br>return HANDLED_MSG; <br>} <br> <br>case WM_COMMAND: <br>{ <br>//Obtain the "this" pointer <br>CS2Dialog* pThis = (CS2Dialog*)GetWindowLong(hWnd, GWL_USERDATA); <br> <br>// All buttons are handled the same way <br>switch(GET_WM_COMMAND_ID(wParam, lParam))  <br>{ <br>                case IDB_PREV: <br>                case IDOK: <br> <br>case IDCANCEL: <br>//Record all selected indexes <br>pThis-&gt;RecordSelectedIndexes(GetDlgItem(hWnd, IDL_INDEXES)); <br> <br>//Get which indexes are really PrimaryKeys,  <br>pThis-&gt;GetPrimaryKeys(); <br> <br>EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam)); <br>                return HANDLED_MSG; <br>} <br>} <br>} <br> <br>return UNHANDLED_MSG; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS2Dialog::ResetIndexList <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS2Dialog::ResetIndexList(HWND hWnd) <br>{ <br>HRESULT hr; <br>IDBSchemaRowset* pIDBSchemaRowset = NULL; <br> <br>HROW* rghRows = NULL; <br>ULONG cRowsObtained = 0; <br>IRowset* pIRowset = NULL; <br> <br>IAccessor* pIAccessor = NULL; <br>HACCESSOR hAccessor = DB_NULL_HACCESSOR; <br> <br>ULONG cIndexes = 0; <br>INDEXINFO* pIndexInfo = NULL; <br> <br>Busy(); <br> <br>//set up the restrictions <br>const ULONG cRestrictions = 5; <br>VARIANT rgRestrictions[cRestrictions]; <br>InitVariants(cRestrictions, rgRestrictions); <br> <br>//Use the passed in Session interface <br>CTable* pCFromTable = m_pCTableCopy-&gt;m_pCFromTable; <br>IDBCreateCommand* pIDBCreateCommand = pCFromTable-&gt;m_pCDataSource-&gt;m_pIDBCreateCommand; <br> <br>// Now make the call <br>SendMessage(hWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0L); <br> <br>// Bind the user and table name for the list <br>const ULONG cBindings = 6; <br>const DBBINDING rgBindings[cBindings] =  <br>{ <br>6,  <br>offsetof(INDEXINFO, wszIndexName), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE, <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>MAX_NAME_LEN,  <br>0,  <br>DBTYPE_WSTR,  <br>0, <br>0,  <br> <br>8,  <br>offsetof(INDEXINFO, fUnique), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE, <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>sizeof(BOOL),  <br>0,  <br>DBTYPE_BOOL,  <br>0, <br>0,  <br> <br>17,  <br>offsetof(INDEXINFO, iOrdinal), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE, <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>sizeof(ULONG),  <br>0,  <br>DBTYPE_UI4,  <br>0, <br>0,  <br> <br>18,  <br>offsetof(INDEXINFO, wszColName), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE, <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>MAX_NAME_LEN,  <br>0,  <br>DBTYPE_WSTR,  <br>0, <br>0,  <br> <br>19,  <br>offsetof(INDEXINFO, guidCol), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE, <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>sizeof(GUID),  <br>0,  <br>DBTYPE_GUID,  <br>0, <br>0,  <br> <br>21,  <br>offsetof(INDEXINFO, dwCollation), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE,  <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>sizeof(DWORD),  <br>0,  <br>DBTYPE_I4,  <br>0, <br>0,  <br>}; <br> <br>//set up the restrictions <br>rgRestrictions[0].vt = DBTYPE_BSTR; <br>SAFE_SYSALLOC(rgRestrictions[0].bstrVal, pCFromTable-&gt;m_pCDataSource-&gt;m_pwszCatalog); <br>rgRestrictions[1].vt = DBTYPE_EMPTY; <br>rgRestrictions[2].vt = DBTYPE_EMPTY; <br>rgRestrictions[3].vt = DBTYPE_EMPTY; <br>rgRestrictions[4].vt = DBTYPE_BSTR; <br>SAFE_SYSALLOC(rgRestrictions[4].bstrVal, pCFromTable-&gt;m_wszTableName); <br> <br>//Get IDBSchemaRowset interface <br>XTESTC(hr = pIDBCreateCommand-&gt;QueryInterface(IID_IDBSchemaRowset,(void **)&amp;pIDBSchemaRowset)); <br> <br>//GetRowset <br>//DBSCHEMA_INDEXES may not be supported by the driver.  <br>//If an error occurs, just don't display IndexInfo <br>TESTC(hr = pIDBSchemaRowset-&gt;GetRowset(NULL, DBSCHEMA_INDEXES, cRestrictions, rgRestrictions,  <br>IID_IRowset, 0, NULL, (IUnknown **)&amp;pIRowset)); <br> <br>XTESTC(hr = pIRowset-&gt;QueryInterface(IID_IAccessor, (void **)&amp;pIAccessor)); <br> <br>//Create Accessor for IndexInfo <br>XTESTC(hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, cBindings, rgBindings, 0, &amp;hAccessor, NULL)); <br> <br>while(TRUE) <br>{ <br>hr = pIRowset-&gt;GetNextRows(NULL, 0, MAX_BLOCK_SIZE, &amp;cRowsObtained, &amp;rghRows); <br>if(FAILED(hr) || cRowsObtained==0)  <br>break; <br> <br>for (ULONG i=0; i&lt;cRowsObtained; i++)  <br>{ <br>ULONG iSel = 0; <br>SAFE_FREE(pIndexInfo); <br>SAFE_ALLOC(pIndexInfo, INDEXINFO, 1); <br> <br>//Reset the IndexInfo <br>memset(pIndexInfo, 0, sizeof(INDEXINFO)); <br> <br>//Get the Data <br>XTESTC(hr = pIRowset-&gt;GetData(rghRows[i], hAccessor, (void*)pIndexInfo)); <br> <br>//If this is an index the ordinal will be 1 based <br>if(pIndexInfo-&gt;iOrdinal==0) <br>continue; <br> <br>// New indexes are added to the list box <br>// Note: We pass an alloced pointer to the window to store <br>// We need to free all the pointers when the window closes <br>iSel = wSendMessage(hWnd, LB_ADDSTRING, (WPARAM)0, pIndexInfo-&gt;wszIndexName); <br>SendMessage(hWnd, LB_SETITEMDATA, (WPARAM)iSel, (LPARAM)pIndexInfo); <br> <br>//Now that we have an actual index... <br>//Set pIndexInfo to NULL since its now stored in the Window ITEMDATA <br>//And we don't want the CLEANUP veriosn to delete it again <br>pIndexInfo = NULL; <br>cIndexes++; <br>} <br> <br>//Release all the rows <br>XTESTC(hr = pIRowset-&gt;ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL)); <br>SAFE_FREE(rghRows); <br>} <br> <br>// If there was a previous selection, select it again on Back <br>    if(pCFromTable-&gt;m_rgIndexInfo)  <br>{ <br>    LONGlFoundIndex; <br> <br>for(ULONG i=0; i&lt;pCFromTable-&gt;m_cIndexes; i++) <br>{ <br>lFoundIndex = wSendMessage(hWnd, LB_FINDSTRINGEXACT, <br>    (WPARAM)0, pCFromTable-&gt;m_rgIndexInfo[i].wszIndexName); <br>         <br>    // If there was a selection, select it now <br>    if(lFoundIndex != LB_ERR) <br>SendMessage(hWnd, LB_SETSEL, (WPARAM)TRUE, (LPARAM)lFoundIndex); <br>} <br>    } <br>//Otherwise select all as default <br>else <br>SendMessage(hWnd, LB_SETSEL, (WPARAM)TRUE, (LPARAM)-1L); <br> <br>//Only enable the ListBox/Title if there are indexes <br>EnableWindow(GetDlgItem(m_hWnd, IDT_INDEXES),cIndexes); <br>EnableWindow(GetDlgItem(m_hWnd, IDL_INDEXES),cIndexes); <br> <br>Busy(); <br> <br>CLEANUP: <br>//Free Resriticions <br>FreeVariants(cRestrictions, rgRestrictions); <br> <br>if(hAccessor &amp;&amp; pIAccessor) <br>XTEST(pIAccessor-&gt;ReleaseAccessor(hAccessor,NULL)); <br> <br>SAFE_RELEASE(pIDBSchemaRowset); <br>SAFE_RELEASE(pIRowset); <br>SAFE_RELEASE(pIAccessor); <br>SAFE_FREE(pIndexInfo); <br>SAFE_FREE(rghRows); <br>return hr==S_OK; <br>} <br> <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS2Dialog::GetPrimaryKeys <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS2Dialog::GetPrimaryKeys() <br>{ <br>HRESULT hr; <br>IDBSchemaRowset* pIDBSchemaRowset = NULL; <br> <br>HROW* rghRows = NULL; <br>ULONG cRowsObtained = 0; <br>IRowset* pIRowset = NULL; <br> <br>IAccessor* pIAccessor = NULL; <br>HACCESSOR hAccessor = DB_NULL_HACCESSOR; <br> <br>PRIMARYKEY PrimaryKey; <br>Busy(); <br> <br>//set up the restrictions <br>const ULONG cRestrictions = 3; <br>VARIANT rgRestrictions[cRestrictions]; <br>InitVariants(cRestrictions, rgRestrictions); <br> <br>//Use the passed in Session interface <br>CTable* pCFromTable = m_pCTableCopy-&gt;m_pCFromTable; <br>IDBCreateCommand* pIDBCreateCommand = pCFromTable-&gt;m_pCDataSource-&gt;m_pIDBCreateCommand; <br> <br>// Bind the user and table name for the list <br>const ULONG cBindings = 3; <br>const DBBINDING rgBindings[cBindings] =  <br>{ <br>4,  <br>offsetof(PRIMARYKEY, wszColName), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE, <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>MAX_NAME_LEN,  <br>0,  <br>DBTYPE_WSTR,  <br>0, <br>0,  <br> <br>5,  <br>offsetof(PRIMARYKEY, guidCol), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE, <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>sizeof(GUID),  <br>0,  <br>DBTYPE_GUID,  <br>0, <br>0,  <br> <br>7,  <br>offsetof(PRIMARYKEY, iOrdinal), <br>0, <br>0, <br>NULL, <br>NULL,  <br>NULL, <br>DBPART_VALUE, <br>DBMEMOWNER_CLIENTOWNED, <br>DBPARAMIO_NOTPARAM,  <br>sizeof(ULONG),  <br>0,  <br>DBTYPE_UI4,  <br>0, <br>0,  <br>}; <br> <br>//set up the restrictions <br>rgRestrictions[0].vt = DBTYPE_BSTR; <br>SAFE_SYSALLOC(rgRestrictions[0].bstrVal, pCFromTable-&gt;m_pCDataSource-&gt;m_pwszCatalog); <br>rgRestrictions[1].vt = DBTYPE_EMPTY; <br>rgRestrictions[2].vt = DBTYPE_BSTR; <br>SAFE_SYSALLOC(rgRestrictions[2].bstrVal, pCFromTable-&gt;m_wszTableName); <br> <br>//Get IDBSchemaRowset interface <br>XTESTC(hr = pIDBCreateCommand-&gt;QueryInterface(IID_IDBSchemaRowset,(void **)&amp;pIDBSchemaRowset)); <br> <br>//GetRowset <br>//DBSCHEMA_PRIMARY_KEYS may not be supported by the driver.  <br>//If an error occurs, just don't display PrimaryKey info <br>TESTC(hr = pIDBSchemaRowset-&gt;GetRowset(NULL, DBSCHEMA_PRIMARY_KEYS, cRestrictions, rgRestrictions,  <br>IID_IRowset, 0, NULL, (IUnknown **)&amp;pIRowset)); <br> <br>XTESTC(hr = pIRowset-&gt;QueryInterface(IID_IAccessor, (void **)&amp;pIAccessor)); <br> <br>//Create Accessor for IndexInfo <br>XTESTC(hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, cBindings, rgBindings, 0, &amp;hAccessor, NULL)); <br> <br>while(TRUE) <br>{ <br>hr = pIRowset-&gt;GetNextRows(NULL, 0, MAX_BLOCK_SIZE, &amp;cRowsObtained, &amp;rghRows); <br>if(FAILED(hr) || cRowsObtained==0)  <br>break; <br> <br>for (ULONG i=0; i&lt;cRowsObtained; i++)  <br>{ <br>//Reset the PrimaryKey <br>memset(&amp;PrimaryKey, 0, sizeof(PRIMARYKEY)); <br> <br>//Get the Data <br>XTESTC(hr = pIRowset-&gt;GetData(rghRows[i], hAccessor, (void*)&amp;PrimaryKey)); <br> <br>//Need to find the corresponding column in IndexInfo and  <br>//mark it as a primary key column <br>for(ULONG iIndex=0; iIndex&lt;pCFromTable-&gt;m_cIndexes; iIndex++) <br>if(wcscmp(PrimaryKey.wszColName, pCFromTable-&gt;m_rgIndexInfo[iIndex].wszColName)==0) <br>pCFromTable-&gt;m_rgIndexInfo[iIndex].fIsPrimaryKey = TRUE; <br>} <br> <br>//Release all the rows <br>XTESTC(hr = pIRowset-&gt;ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL)); <br>SAFE_FREE(rghRows); <br>} <br> <br>Busy(); <br> <br>CLEANUP: <br>//Free Resriticions <br>FreeVariants(cRestrictions, rgRestrictions); <br> <br>if(hAccessor &amp;&amp; pIAccessor) <br>XTEST(pIAccessor-&gt;ReleaseAccessor(hAccessor,NULL)); <br> <br>SAFE_RELEASE(pIDBSchemaRowset); <br>SAFE_RELEASE(pIRowset); <br>SAFE_RELEASE(pIAccessor); <br>SAFE_FREE(rghRows); <br>return hr==S_OK; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CS2Dialog::RecordSelectedIndexes <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CS2Dialog::RecordSelectedIndexes(HWND hWnd) <br>{ <br>CTable* pCTable = m_pCTableCopy-&gt;m_pCFromTable; <br>LONG i,iSel; <br> <br>//When we setup the IndexList, we stored the pointer of the index <br>//in the window.  So now we need free all the indexes stored, and <br>//save all the indexes selected by the user. <br> <br>//Get the Total Number of indexes in the window <br>LONG cIndexes = SendMessage(hWnd, LB_GETCOUNT, (WPARAM)0, (LPARAM)0l); <br>//Get the Number of selected indexes <br>LONG cSelIndexes = SendMessage(hWnd, LB_GETSELCOUNT, (WPARAM)0, (LPARAM)0l); <br> <br>//Get the selected index ordinals  <br>LONG* rgSelIndexes = NULL; <br>SAFE_ALLOC(rgSelIndexes, LONG, cSelIndexes); <br>SendMessage(hWnd, LB_GETSELITEMS, (WPARAM)cSelIndexes, (LPARAM)rgSelIndexes); <br> <br>//Alloc Table struct for Indexes <br>pCTable-&gt;m_cIndexes = cSelIndexes; <br>SAFE_FREE(pCTable-&gt;m_rgIndexInfo); <br>SAFE_ALLOC(pCTable-&gt;m_rgIndexInfo, INDEXINFO, cSelIndexes); <br> <br>//Loop over all the indexes <br>for(i=0, iSel=0; i&lt;cIndexes; i++)  <br>{ <br>//Get the index pointer for this ordinal from the window <br>INDEXINFO* pIndexInfo = (INDEXINFO*)SendMessage(hWnd, LB_GETITEMDATA, (WPARAM)i, (LPARAM)0); <br>ASSERT(pIndexInfo); <br> <br>//Save this index, if it is a selected one <br>if(iSel&lt;cSelIndexes &amp;&amp; i==rgSelIndexes[iSel]) <br>{ <br>memcpy(&amp;pCTable-&gt;m_rgIndexInfo[iSel], pIndexInfo, sizeof(INDEXINFO)); <br>iSel++; <br>} <br>   <br>//delete the indexinfo <br>SAFE_FREE(pIndexInfo); <br>} <br> <br> <br>CLEANUP: <br>SAFE_FREE(rgSelIndexes); <br>return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
