<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPY.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2359"></a>SPY.CPP</h2>
<pre><code>//----------------------------------------------------------------------------- <br>// Microsoft OLE DB TABLECOPY Sample <br>// Copyright (C) 1996 By Microsoft Corporation. <br>// <br>// @doc <br>// <br>// @module SPY.CPP <br>// <br>//----------------------------------------------------------------------------- <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Includes <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>#include "spy.h" <br>#include "common.h" <br>  <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Defines <br>// <br>///////////////////////////////////////////////////////////////////////////// <br> <br>// HEADER + BUFFER + FOOTER <br>// HEADER = HEADSIGNITURE + BUFFERSIZE + BUFFERID <br>// FOOTER = TAILSIGNITURE <br> <br>//All the header info must be ULONGs, <br>//so that the user buffer falls on a word boundary <br>//The tail must be a byte, since if it was a ULONG it would <br>//also require a word boundary, but the users buffer could <br>//be an odd number of bytes, so instead of rounding up, just use BYTE <br> <br>const ULONG HEADSIZE= sizeof(ULONG);  //HEADSIGNITURE <br>const ULONG LENGTHSIZE= sizeof(ULONG);  //BUFFERSIZE <br>const ULONG IDSIZE= sizeof(ULONG);  //BUFFERIF <br>const ULONG TAILSIZE= sizeof(BYTE);  //TAILSIGNITURE <br> <br>const ULONG HEADERSIZE = ROUNDUP(HEADSIZE + LENGTHSIZE + IDSIZE); <br>const ULONG FOOTERSIZE = TAILSIZE; <br> <br>const BYTE  HEADSIGN = '{'; <br>const BYTE  TAILSIGN = '}'; <br> <br>const BYTE  ALLOCSIGN = '$'; <br>const BYTE  FREESIGN  = 'Z'; <br> <br>#define HEAD_OFFSET(pHeader)((BYTE*)pHeader) <br>#define TAIL_OFFSET(pHeader)(USERS_OFFSET(pHeader)+BUFFER_LENGTH(pHeader)) <br> <br>#define USERS_OFFSET(pHeader)(HEAD_OFFSET(pHeader) + HEADERSIZE) <br>#define HEADER_OFFSET(pUserBuffer) ((BYTE*)(pUserBuffer) - HEADERSIZE) <br> <br>#define LENGTH_OFFSET(pHeader)(HEAD_OFFSET(pHeader) + HEADSIZE) <br>#define BUFFER_LENGTH(pHeader)(*(ULONG*)LENGTH_OFFSET(pHeader)) <br> <br>#define ID_OFFSET(pHeader)(LENGTH_OFFSET(pHeader) + LENGTHSIZE) <br>#define BUFFER_ID(pHeader)(*(ULONG*)ID_OFFSET(pHeader)) <br> <br>#define HEAD_SIGNITURE(pHeader)(*(ULONG*)HEAD_OFFSET(pHeader)) <br>#define TAIL_SIGNITURE(pHeader)(*(BYTE*)TAIL_OFFSET(pHeader)) <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CMallocSpy::CMallocSpy() <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>CMallocSpy::CMallocSpy() <br>{ <br>    m_cRef = 0; <br>m_cbRequest = 0; <br> <br>//AddRef, so delete is required <br>AddRef(); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CMallocSpy::~CMallocSpy() <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>CMallocSpy::~CMallocSpy() <br>{ <br>//Remove all the elements of the list <br>CAllocList.RemoveAll(); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CMallocSpy::Add <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CMallocSpy::Add(void* pv) <br>{ <br>ASSERT(pv); <br> <br>//Add this element to the list <br>CAllocList.AddTail(pv); <br>return TRUE; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CMallocSpy::Remove <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CMallocSpy::Remove(void* pv) <br>{ <br>ASSERT(pv); <br> <br>//Remove this element from the list <br>CAllocList.RemoveAt(CAllocList.Find(pv)); <br>return TRUE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CMallocSpy::DumpLeaks <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CMallocSpy::DumpLeaks() <br>{ <br>ULONG ulTotalLeaked = 0; <br> <br>//Display Leaks to the Output Window <br>while(!CAllocList.IsEmpty()) <br>{ <br>//Obtain the pointer to the leaked memory <br>void* pUsersBuffer = CAllocList.RemoveHead(); <br>ASSERT(pUsersBuffer); <br> <br>void* pHeader = HEADER_OFFSET(pUsersBuffer); <br>ASSERT(pHeader); <br> <br>//Make sure that the head/tail signitures are intact <br>if(HEAD_SIGNITURE(pHeader) != HEADSIGN) <br>TRACE(L"-- IMallocSpy HeadSigniture Corrupted! - 0x%08x, ID=%08lu, %lu bytes\n", pUsersBuffer, BUFFER_ID(pHeader), BUFFER_LENGTH(pHeader)); <br> <br>if(TAIL_SIGNITURE(pHeader) != TAILSIGN) <br>TRACE(L"-- IMallocSpy TailSigniture Corrupted! - 0x%08x, ID=%08lu, %lu bytes\n", pUsersBuffer, BUFFER_ID(pHeader), BUFFER_LENGTH(pHeader)); <br> <br>ULONG ulSize = BUFFER_LENGTH(pHeader); <br>ULONG ulID = BUFFER_ID(pHeader); <br> <br>TRACE(L"-- IMallocSpy LEAK! - 0x%08x, ID=%08lu, %lu bytes\n", pUsersBuffer, ulID, ulSize); <br>ulTotalLeaked += ulSize; <br>} <br> <br>if(ulTotalLeaked) <br>TRACE(L"-- IMallocSpy Total LEAKED! - %lu bytes\n", ulTotalLeaked); <br> <br>return TRUE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// HRESULT CMallocSpy::QueryInterface <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT CMallocSpy::QueryInterface(REFIID riid, void** ppIUnknown) <br>{ <br>if(!ppIUnknown) <br>return E_INVALIDARG; <br> <br>*ppIUnknown = NULL; <br> <br>//IID_IUnknown <br>    if(riid == IID_IUnknown) <br>*ppIUnknown = this; <br>    //IDD_IMallocSpy <br>else if(riid == IID_IMallocSpy) <br>         *ppIUnknown =  this; <br>     <br>if(*ppIUnknown) <br>    { <br>        ((IUnknown*)*ppIUnknown)-&gt;AddRef(); <br>        return S_OK; <br>} <br> <br>return E_NOINTERFACE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ULONG CMallocSpy::AddRef <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>ULONG CMallocSpy::AddRef() <br>{ <br>    return ++m_cRef; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ULONG CMallocSpy::Release <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>ULONG CMallocSpy::Release() <br>{ <br>    if(--m_cRef) <br>    return m_cRef; <br> <br>TRACE(L"Releasing IMallocSpy\n"); <br> <br>    delete this; <br>    return 0; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ULONG CMallocSpy::PreAlloc <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>ULONG CMallocSpy::PreAlloc(ULONG cbRequest) <br>{ <br>//cbRequest is the orginal number of bytes requested by the user <br>//Store the users requested size <br>    m_cbRequest = cbRequest; <br> <br>//Return the total size requested, plus extra for header/footer <br>return (m_cbRequest + HEADERSIZE + FOOTERSIZE); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// void* CMallocSpy::PostAlloc <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void* CMallocSpy::PostAlloc(void* pHeader) <br>{ <br>//pActual is the pointer to the head of the buffer, including the header <br>//Add the users pointer to the list <br>Add(USERS_OFFSET(pHeader)); <br> <br>//Place the HeadSigniture in the HEADER <br>HEAD_SIGNITURE(pHeader) = HEADSIGN; <br> <br>//Place the Size in the HEADER <br>BUFFER_LENGTH(pHeader) = m_cbRequest; <br> <br>//Place the ID in the HEADER <br>static ULONG ulID = 0; <br>BUFFER_ID(pHeader) = ++ulID; <br> <br>//Set the UsersBuffer to a known char <br>    memset(USERS_OFFSET(pHeader), ALLOCSIGN, m_cbRequest); <br> <br>//Place the TailSigniture in the HEADER <br>TAIL_SIGNITURE(pHeader) = TAILSIGN; <br> <br>#ifdef FINDLEAKS <br>TRACE(L"-- IMallocSpy Alloc - 0x%08x, ID=%08lu, %lu bytes\n", USERS_OFFSET(pHeader), ulID, m_cbRequest); <br>#endif // FINDLEAKS <br> <br>// Return the actual users buffer <br>    return USERS_OFFSET(pHeader); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// void* CMallocSpy::PreFree <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void* CMallocSpy::PreFree(void* pUsersBuffer, BOOL fSpyed) <br>{ <br>//pUsersBuffer is the users pointer to thier buffer, not the header <br> <br>// Check for NULL <br>    if(pUsersBuffer == NULL) <br>        return NULL; <br> <br>    //If this memory was alloced under IMallocSpy, need to remove it <br>    if(fSpyed) <br>{ <br>//Remove this pointer form the list <br>Remove(pUsersBuffer); <br> <br>void* pHeader = HEADER_OFFSET(pUsersBuffer); <br> <br>//Make sure that the head/tail signitures are intact <br>if(HEAD_SIGNITURE(pHeader) != HEADSIGN) <br>TRACE(L"-- IMallocSpy HeadSigniture Corrupted! - 0x%08x, ID=%08lu, %lu bytes\n", pUsersBuffer, BUFFER_ID(pHeader), BUFFER_LENGTH(pHeader)); <br> <br>if(TAIL_SIGNITURE(pHeader) != TAILSIGN) <br>TRACE(L"-- IMallocSpy TailSigniture Corrupted! - 0x%08x, ID=%08lu, %lu bytes\n", pUsersBuffer, BUFFER_ID(pHeader), BUFFER_LENGTH(pHeader)); <br> <br>//Set the UsersBuffer to a known char <br>memset(pUsersBuffer, FREESIGN, BUFFER_LENGTH(pHeader)); <br> <br>//Need to return the actual header pointer to <br>//free the entire buffer including the heading <br>return pHeader; <br>} <br> <br>//else <br>return pUsersBuffer; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// void CMallocSpy::PostFree <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void CMallocSpy::PostFree(BOOL fSpyed) <br>{ <br>    // Note the free or whatever <br>    return; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ULONG CMallocSpy::PreRealloc <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>ULONG CMallocSpy::PreRealloc(void* pUsersBuffer, ULONG cbRequest, <br>                             void** ppNewRequest, BOOL fSpyed) <br>{ <br>ASSERT(pUsersBuffer &amp;&amp; ppNewRequest); <br>     <br>//If this was alloced under IMallocSpy we need to adjust <br>//the size stored in the header <br>    if(fSpyed) <br>    { <br>        //Find the start  <br>*ppNewRequest = HEADER_OFFSET(pUsersBuffer); <br> <br>//Store the new desired size <br>m_cbRequest = cbRequest; <br> <br>//Return the total size, including extra <br>return (m_cbRequest + HEADERSIZE + FOOTERSIZE); <br>    } <br> <br>//else <br>*ppNewRequest = pUsersBuffer; <br>    return cbRequest; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// void* CMallocSpy::PostRealloc <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void* CMallocSpy::PostRealloc(void* pHeader, BOOL fSpyed) <br>{ <br>    //If this buffer was alloced under IMallocSpy <br>    if(fSpyed) <br>    { <br>//HeadSigniture should still be intact <br>if(HEAD_SIGNITURE(pHeader) != HEADSIGN) <br>TRACE(L"-- IMallocSpy HeadSigniture Corrupted! - 0x%08x, ID=%08lu, %lu bytes\n", USERS_OFFSET(pHeader), BUFFER_ID(pHeader), BUFFER_LENGTH(pHeader)); <br> <br>//ID should still be intact <br> <br>//Place the new Size in the HEADER <br>BUFFER_LENGTH(pHeader) = m_cbRequest; <br> <br>        //Need to place the tail signiture again,  <br>//since it will be over written by the realloc <br>TAIL_SIGNITURE(pHeader) = TAILSIGN; <br> <br>//Return the actual "user" buffer <br>return USERS_OFFSET(pHeader); <br>    } <br>     <br>//else <br>    return pHeader; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// void* CMallocSpy::PreGetSize <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void* CMallocSpy::PreGetSize(void* pUsersBuffer, BOOL fSpyed) <br>{ <br>    if (fSpyed) <br>        return HEADER_OFFSET(pUsersBuffer); <br> <br>    return pUsersBuffer; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ULONG CMallocSpy::PostGetSize <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>ULONG CMallocSpy::PostGetSize(ULONG cbActual, BOOL fSpyed) <br>{ <br>    if (fSpyed) <br>        return cbActual - HEADERSIZE - FOOTERSIZE; <br> <br>    return cbActual; <br>} <br> <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// void* CMallocSpy::PreDidAlloc <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void* CMallocSpy::PreDidAlloc(void* pUsersBuffer, BOOL fSpyed) <br>{ <br>    if (fSpyed) <br>        return HEADER_OFFSET(pUsersBuffer); <br> <br>return pUsersBuffer; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL CMallocSpy::PostDidAlloc <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL CMallocSpy::PostDidAlloc(void* pRequest, BOOL fSpyed, BOOL fActual) <br>{ <br>    return fActual; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// void CMallocSpy::PreHeapMinimize <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void CMallocSpy::PreHeapMinimize() <br>{ <br>    // We don't do anything here <br>    return; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// void CMallocSpy::PostHeapMinimize <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>void CMallocSpy::PostHeapMinimize() <br>{ <br>    // We don't do anything here <br>    return; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Resgistration <br>// <br>///////////////////////////////////////////////////////////////////////////// <br> <br>#ifdef _DEBUG <br>void MallocSpyRegister(CMallocSpy** ppCMallocSpy) <br>{ <br>ASSERT(ppCMallocSpy); <br> <br>//Allocate Interface <br>*ppCMallocSpy = new CMallocSpy(); //Constructor AddRef's <br> <br>//Regisiter Interface <br>CoRegisterMallocSpy(*ppCMallocSpy); // Does an AddRef on Object <br>} <br> <br>void MallocSpyUnRegister(CMallocSpy* pCMallocSpy) <br>{ <br>ASSERT(pCMallocSpy); <br>CoRevokeMallocSpy(); //Does a Release on Object <br>} <br> <br>void MallocSpyDump(CMallocSpy* pCMallocSpy) <br>{ <br>ASSERT(pCMallocSpy); <br>pCMallocSpy-&gt;DumpLeaks();  <br>} <br> <br>#else <br>void MallocSpyRegister(CMallocSpy** ppCMallocSpy) {return; }; <br>void MallocSpyUnRegister(CMallocSpy* pCMallocSpy) {return; }; <br>void MallocSpyDump(CMallocSpy* pCMallocSpy)  { return; }; <br>#endif //DEBUG <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
