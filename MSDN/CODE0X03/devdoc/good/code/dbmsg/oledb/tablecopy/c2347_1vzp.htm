<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TABLE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2365"></a>TABLE.CPP</h2>
<pre><code>//----------------------------------------------------------------------------- <br>// Microsoft OLE DB TABLECOPY Sample <br>// Copyright (C) 1996 By Microsoft Corporation. <br>// <br>// @doc <br>// <br>// @module TABLE.H <br>// <br>//----------------------------------------------------------------------------- <br> <br>///////////////////////////////////////////////////////////////////// <br>// Includes <br>// <br>///////////////////////////////////////////////////////////////////// <br>#include "winmain.h" <br>#include "common.h" <br>#include "tablecopy.h" <br>#include "table.h" <br>#include "wizard.h" <br>#include "progress.h" <br> <br> <br>////////////////////////////////////////////////////////////////////////////// <br>// Defines / Macros <br>// <br>////////////////////////////////////////////////////////////////////////////// <br>#define NO_MATCH0x0000 <br>#define MATCH_EXACT0x0001 <br>#define MATCH_TYPE0x0002 <br>#define MATCH_SIZE0x0004 <br>#define MATCH_DEFAULT0x0008 <br> <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// CTable::CTable <br>// <br>///////////////////////////////////////////////////////////////// <br>CTable::CTable(CWizard* pCWizard) <br>{ <br>ASSERT(pCWizard); <br> <br>m_pCDataSource   = new CDataSource; <br> <br>m_wszIDQuote[0]= EOL; <br>m_wszIDSeperator[0]= EOL; <br> <br>m_wszSchemaName[0]= EOL; <br>m_wszTableName[0]= EOL; <br>m_wszQualTableName[0]= EOL; <br> <br>//IndexInfo <br>m_cIndexes= 0;// Count of indexes <br>m_rgIndexInfo= NULL;// Index information <br> <br>//ColumnInfo <br>m_cColumns= 0;// Count of columns <br>m_rgColDesc= NULL;// Column information <br>m_cBlobs= 0;// 0 Blob Columns <br> <br>m_pCWizard= pCWizard;// Back pointer to Windowing class <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// CTable::~CTable <br>// <br>///////////////////////////////////////////////////////////////// <br>CTable::~CTable() <br>{ <br>delete m_pCDataSource; <br> <br>SAFE_FREE(m_rgIndexInfo); <br>SAFE_FREE(m_rgColDesc); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// BOOL CTable::Connect <br>// <br>///////////////////////////////////////////////////////////////// <br>BOOL CTable::Connect(HWND hWnd) <br>{ <br>ASSERT(m_pCDataSource); <br>if(m_pCDataSource-&gt;Connect(hWnd)) <br>{ <br>//Get LiteralInfo for this table <br>GetLiteralInfo(); <br>} <br> <br>return m_pCDataSource-&gt;IsConnected(); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// BOOL CTable::IsConnected <br>// <br>///////////////////////////////////////////////////////////////// <br>BOOL CTable::IsConnected() <br>{ <br>ASSERT(m_pCDataSource); <br>return m_pCDataSource-&gt;IsConnected(); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// BOOL CTable::TranslateNames <br>// <br>///////////////////////////////////////////////////////////////// <br>BOOL CTable::TranslateNames() <br>{ <br>//Converts all DSN dependents names to allowable chars <br>MakeAlphaNumeric(m_wszTableName, UNDERSCORE); <br> <br>for(ULONG i=0; i&lt;m_cColumns; i++) <br>{ <br>ASSERT(m_rgColDesc); <br>MakeAlphaNumeric(m_rgColDesc[i].wszColName, UNDERSCORE); <br>} <br> <br>for(i=0; i&lt;m_cIndexes; i++) <br>{ <br>ASSERT(m_rgIndexInfo); <br>MakeAlphaNumeric(m_rgIndexInfo[i].wszIndexName, UNDERSCORE); <br>MakeAlphaNumeric(m_rgIndexInfo[i].wszColName, UNDERSCORE); <br>} <br> <br>return TRUE; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::GetLiteralInfo <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::GetLiteralInfo() <br>{ <br>ASSERT(m_pCDataSource); <br>ASSERT(m_pCDataSource-&gt;m_pIDBInitialize); <br> <br>HRESULT hr; <br> <br>const ULONG cLiterals = 2; <br>DBLITERAL rgLiterals[cLiterals] = {DBLITERAL_QUOTE, DBLITERAL_CATALOG_SEPARATOR}; <br> <br>IDBInfo* pIDBInfo = NULL; <br> <br>ULONGcLiteralInfo = 0; <br>DBLITERALINFO* rgLiteralInfo = NULL; <br>WCHAR* pwszCharBuffer = NULL; <br> <br>//Obtain IDBInfo interface <br>XTESTC(hr = m_pCDataSource-&gt;m_pIDBInitialize-&gt;QueryInterface(IID_IDBInfo, (void **)&amp;pIDBInfo)); <br> <br>//GetLiteralInfo <br>XTESTC(hr = pIDBInfo-&gt;GetLiteralInfo(cLiterals, rgLiterals, &amp;cLiteralInfo,&amp;rgLiteralInfo, &amp;pwszCharBuffer)); <br>    <br>//DBLITERAL_QUOTE <br>if(rgLiteralInfo[0].fSupported)  <br>wcscpy(m_wszIDQuote, rgLiteralInfo[0].pwszLiteralValue); <br> <br>//DBLITERAL_CATALOG_SEPARATOR <br>if(rgLiteralInfo[1].fSupported)  <br>wcscpy(m_wszIDSeperator, rgLiteralInfo[1].pwszLiteralValue); <br> <br> <br>CLEANUP: <br>SAFE_RELEASE(pIDBInfo); <br>SAFE_FREE(rgLiteralInfo); <br>SAFE_FREE(pwszCharBuffer); <br>return hr; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// BOOL CTable::GetQuotedID <br>// <br>///////////////////////////////////////////////////////////////// <br>BOOL CTable::GetQuotedID(WCHAR* pwszOutBuff, WCHAR* pwszInBuff) <br>{ <br>return ::GetQuotedID(pwszOutBuff, pwszInBuff, m_wszIDQuote, m_wszIDSeperator); <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::GetColInfo <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::GetColInfo() <br>{ <br>ASSERT(m_pCDataSource); <br>ASSERT(m_pCDataSource-&gt;m_pICommandText); <br>HRESULT hr; <br> <br>WCHAR     wszSqlStmt[MAX_QUERY_LEN]; // from SELECT statement <br>IColumnsInfo* pIColumnsInfo = NULL; <br> <br>ULONG cColumns = 0; <br>DBCOLUMNINFO* rgColInfo = NULL; <br>WCHAR*rgStringBuffer = NULL; <br> <br>IRowset* pIRowset = NULL; <br>LONG cRowsAffected = 0; <br> <br>ULONG i; <br>//Create the SELECT statment, BOGUS WHERE Clause <br>CreateSQLStmt(ESQL_SELECT_BOGUS, wszSqlStmt, FALSE); <br> <br>//Set the command text <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wszSqlStmt)); <br> <br>// Execute the query and retrieve the results <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;Execute(NULL, IID_IRowset, NULL, &amp;cRowsAffected, (IUnknown **)&amp;pIRowset)); <br> <br>//Now finally GetColInfo <br>XTESTC(hr = pIRowset-&gt;QueryInterface(IID_IColumnsInfo, (void **)&amp;pIColumnsInfo)); <br>XTESTC(hr = pIColumnsInfo-&gt;GetColumnInfo(&amp;cColumns, &amp;rgColInfo, &amp;rgStringBuffer)); <br> <br>//Loop through the ColInfo and Copy to our ColDesc <br>m_cColumns = 0; <br>m_cBlobs = 0; <br> <br>for(i=0; i&lt;cColumns; i++) <br>{ <br>//ignore Bookmark columns <br>if(rgColInfo[i].iOrdinal == 0) <br>continue; <br> <br>//Don't need to alloc the rgColDesc struct, since that should have already  <br>//been done in the selection phase of Step1, and the ColName <br>//Should have already been copied as well, but make sure <br>ASSERT(m_rgColDesc); <br>ASSERT(wcscmp(m_rgColDesc[m_cColumns].wszColName, rgColInfo[i].pwszName)==0); <br> <br>//Now copy the rest of the info <br>//DBCOLUMNINFO <br>m_rgColDesc[m_cColumns].iOrdinal= rgColInfo[i].iOrdinal; <br>m_rgColDesc[m_cColumns].ulColumnSize= rgColInfo[i].ulColumnSize; <br>m_rgColDesc[m_cColumns].wType= rgColInfo[i].wType; <br>m_rgColDesc[m_cColumns].dwFlags= rgColInfo[i].dwFlags; <br>m_rgColDesc[m_cColumns].bPrecision= rgColInfo[i].bPrecision; <br>m_rgColDesc[m_cColumns].bScale= rgColInfo[i].bScale; <br> <br>//BLOB Columns <br>if(rgColInfo[i].dwFlags &amp; DBCOLUMNFLAGS_ISLONG) <br>m_cBlobs++; <br> <br>m_cColumns++; <br>} <br> <br> <br>CLEANUP: <br>SAFE_RELEASE(pIRowset);  <br>SAFE_RELEASE(pIColumnsInfo);  <br> <br>SAFE_FREE(rgColInfo); <br>SAFE_FREE(rgStringBuffer); <br>return hr; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::GetTypeInfo <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::GetTypeInfo() <br>{ <br>ASSERT(m_pCDataSource); <br>HRESULT hr; <br> <br>IRowset*pIRowset = NULL; <br>IAccessor*pIAccessor = NULL; <br>HACCESSORhAccessor = DB_NULL_HACCESSOR; <br> <br>ULONGi; <br>ULONGcRowsObtained = 0; <br>HROW*rghRows = NULL; <br> <br>//Current SchemaInfo for each type, until we find the correct match <br>TYPEINFO TypeInfo; <br>TYPEINFO* rgTypeInfo = NULL; <br>ULONG* rgMatch = NULL; <br> <br>//Arrays to store best TypeInfo <br>SAFE_ALLOC(rgTypeInfo, TYPEINFO, m_cColumns); <br>SAFE_ALLOC(rgMatch, ULONG, m_cColumns); <br>memset(rgMatch, NO_MATCH, m_cColumns*sizeof(ULONG)); <br> <br>//Get ProviderTypes rowset IDBSchemaRowset <br>TESTC(hr = GetTypeInfoRowset(&amp;pIAccessor, &amp;hAccessor, &amp;pIRowset)); <br> <br>//Loop over all the Schema TypeInfo rowset <br>//And match up with ColInfo <br>while(TRUE) <br>{ <br>hr = pIRowset-&gt;GetNextRows(NULL,0,MAX_BLOCK_SIZE,&amp;cRowsObtained, &amp;rghRows); <br>if(FAILED(hr) || cRowsObtained==0) <br>break; <br> <br>//Loop over the BLOCK of rows obtained <br>for (i=0; i&lt;cRowsObtained; i++) <br>{ <br>//Reset all the TypeInfo fields <br>memset(&amp;TypeInfo, 0, sizeof(TYPEINFO)); <br> <br>//Put the data for one type into the TypeInfo Struct <br>XTESTC(hr = pIRowset-&gt;GetData(rghRows[i],hAccessor, (void*)&amp;TypeInfo)); <br> <br>//Loop over all the columns and see if they match this type <br>for(ULONG iCol=0; iCol&lt;m_cColumns; iCol++) <br>{ <br>ASSERT(m_rgColDesc);  <br> <br>//Only try matching if this is the correct type and <br>//the column doesn't already have a perfect match <br>if(TypeInfo.wType != m_rgColDesc[iCol].wType || (rgMatch[iCol] &amp; MATCH_EXACT)) <br>continue; <br> <br>//A Nullable type cannot be mapped to a non-Nullable type <br>if(m_rgColDesc[iCol].fIsNullable &amp;&amp; !TypeInfo.fIsNullable) <br>continue; <br> <br>//If never matched before, we at least know they match by type <br>if(!rgMatch[iCol]) <br>{ <br>rgMatch[iCol] |= MATCH_TYPE; <br>rgTypeInfo[iCol] = TypeInfo; <br>} <br> <br>// Exact type/size matches take precedence <br> if(COLINFO_SIZE(m_rgColDesc[iCol]) == TypeInfo.ulColumnSize) <br>{ <br>rgMatch[iCol] |= MATCH_EXACT; <br>rgTypeInfo[iCol] = TypeInfo; <br>} <br> <br>// Otherwise try best fit size <br>if(COLINFO_SIZE(m_rgColDesc[iCol]) &lt; TypeInfo.ulColumnSize &amp;&amp; <br>TypeInfo.ulColumnSize &lt; rgTypeInfo[iCol].ulColumnSize) <br>{ <br>rgMatch[iCol] |= MATCH_SIZE; <br>rgTypeInfo[iCol] = TypeInfo; <br>} <br>} <br>} <br> <br>//Release this group of rows <br>XTESTC(hr = pIRowset-&gt;ReleaseRows(cRowsObtained,rghRows,NULL,NULL,NULL)); <br>SAFE_FREE(rghRows); <br>} <br> <br>//Now that we have the TypeInfo matched, fill in our ColDesc struct <br>for(i=0; i&lt;m_cColumns; i++)  <br>{ <br>ASSERT(m_rgColDesc);  <br>if(rgMatch[i]) <br>{ <br>//TYPEINFO <br>wcscpy(m_rgColDesc[i].wszTypeName, rgTypeInfo[i].wszTypeName); <br>m_rgColDesc[i].ulCreateParams= GetCreateParams(rgTypeInfo[i].wszCreateParams); <br>m_rgColDesc[i].fIsNullable= rgTypeInfo[i].fIsNullable == VARIANT_TRUE; <br>m_rgColDesc[i].guidType= rgTypeInfo[i].guidType; <br>} <br>else <br>{ <br>wMessageBox(NULL, MB_ICONEXCLAMATION | MB_OK, wsz_ERROR,  <br>wsz_NO_TYPE_FOUND_, GetDBTypeName(m_rgColDesc[i].wType)); <br>} <br>} <br> <br> <br>CLEANUP: <br>if(hAccessor &amp;&amp; pIAccessor) <br>XTEST(pIAccessor-&gt;ReleaseAccessor(hAccessor,NULL)); <br> <br>SAFE_RELEASE(pIAccessor); <br>SAFE_RELEASE(pIRowset); <br> <br>SAFE_FREE(rgMatch); <br>SAFE_FREE(rgTypeInfo); <br> <br>SAFE_FREE(rghRows); <br>return hr; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::MapTableInfo <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::MapTableInfo(CTable* pCSourceTable) <br>{ <br>ASSERT(pCSourceTable); <br>ASSERT(m_pCDataSource); <br>HRESULT hr; <br> <br>IAccessor* pIAccessor = NULL; <br>HACCESSOR  hAccessor = DB_NULL_HACCESSOR; <br> <br>IRowset* pIRowset = NULL; <br> <br>ULONGcRowsObtained = 0; <br>HROW*rghRows = NULL; <br> <br>//Match bitmask, indicating what type of match was found <br>BOOL fMatchedAll = FALSE; <br> <br>TYPEINFO TypeInfo; <br>TYPEINFO* rgTypeInfo = NULL; <br>ULONG* rgMatch = NULL; <br> <br>//ColumnInfo <br>m_cColumns= pCSourceTable-&gt;m_cColumns; <br>SAFE_FREE(m_rgColDesc); <br>SAFE_ALLOC(m_rgColDesc, COLDESC, m_cColumns); <br>memcpy(m_rgColDesc,pCSourceTable-&gt;m_rgColDesc, m_cColumns * sizeof(COLDESC)); <br> <br>//IndexInfo <br>m_cIndexes= pCSourceTable-&gt;m_cIndexes; <br>SAFE_FREE(m_rgIndexInfo); <br>SAFE_ALLOC(m_rgIndexInfo, INDEXINFO, m_cIndexes); <br>memcpy(m_rgIndexInfo, pCSourceTable-&gt;m_rgIndexInfo, m_cIndexes * sizeof(INDEXINFO)); <br> <br>//Arrays to store best TypeInfo <br>SAFE_ALLOC(rgTypeInfo, TYPEINFO, m_cColumns); <br>SAFE_ALLOC(rgMatch, ULONG, m_cColumns); <br>memset(rgMatch, NO_MATCH, m_cColumns*sizeof(ULONG)); <br> <br>//Get ProviderTypes rowset IDBSchemaRowset <br>TESTC(hr = GetTypeInfoRowset(&amp;pIAccessor, &amp;hAccessor, &amp;pIRowset)); <br> <br>//Loop until all types are matched. <br>//We may not find a match, which promotes the type to the next higher <br>//type, which will require another cycle to match that type... <br>while(!fMatchedAll)  <br>{ <br>//Get data for each row in rowset <br>XTESTC(hr = pIRowset-&gt;RestartPosition(NULL)); <br> <br>//Loops over the entire SchemaRowset <br>while(TRUE) <br>{ <br>hr = pIRowset-&gt;GetNextRows(NULL, 0, MAX_BLOCK_SIZE, &amp;cRowsObtained, &amp;rghRows); <br>if(FAILED(hr) || cRowsObtained == 0) <br>break; <br> <br>//Loop over the BLOCK of rows obtained <br>for (ULONG i=0; i&lt;cRowsObtained; i++) <br>{ <br>ASSERT(m_rgColDesc);  <br> <br>//Reset all the TypeInfo fields <br>memset(&amp;TypeInfo, 0, sizeof(TYPEINFO)); <br> <br>//Put the data for one type into the TypeInfo Struct <br>XTESTC(hr = pIRowset-&gt;GetData(rghRows[i], hAccessor, (void *)&amp;TypeInfo)); <br> <br>//Loop over the columns and get TypeInfo <br>for(ULONG iCol=0; iCol&lt;m_cColumns; iCol++) <br>{ <br>//Only try matching if this is the correct type and <br>//the column doesn't already have a perfect match <br>if(TypeInfo.wType != m_rgColDesc[iCol].wType || (rgMatch[iCol] &amp; MATCH_EXACT))  <br>continue; <br> <br>//A Nullable type cannot be mapped to a non-Nullable type <br>if(m_rgColDesc[iCol].fIsNullable &amp;&amp; !TypeInfo.fIsNullable) <br>continue; <br> <br>//If never matched before, we at least know they match by type <br>if(!rgMatch[iCol]) <br>{ <br>rgMatch[iCol] |= MATCH_TYPE; <br>rgTypeInfo[iCol] = TypeInfo; <br>} <br> <br>// Exact type/size matches take precedence <br>if(COLINFO_SIZE(m_rgColDesc[iCol]) == TypeInfo.ulColumnSize) <br>{ <br>rgMatch[iCol] |= MATCH_EXACT; <br>rgTypeInfo[iCol] = TypeInfo; <br>} <br> <br>// Otherwise try best fit size <br>if(COLINFO_SIZE(m_rgColDesc[iCol]) &lt; TypeInfo.ulColumnSize &amp;&amp; <br>TypeInfo.ulColumnSize &lt; rgTypeInfo[iCol].ulColumnSize) <br>{ <br>rgMatch[iCol] |= MATCH_SIZE; <br>rgTypeInfo[iCol] = TypeInfo; <br>} <br>} <br>} <br> <br>//Release this group of rows <br>XTESTC(hr = pIRowset-&gt;ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL)); <br>SAFE_FREE(rghRows); <br>} <br> <br>// See if every type has a match <br>fMatchedAll = TRUE; <br>for(ULONG i=0; i&lt;m_cColumns; i++)  <br>{ <br>ASSERT(m_rgColDesc);  <br> <br>// If not we will have to promote a type and try again <br>if(rgMatch[i]) <br>{ <br>//If found a match fill in the TypeInfo fileds of our ColDesc <br>wcscpy(m_rgColDesc[i].wszTypeName, rgTypeInfo[i].wszTypeName); <br>m_rgColDesc[i].ulCreateParams= GetCreateParams(rgTypeInfo[i].wszCreateParams); <br>m_rgColDesc[i].fIsNullable= rgTypeInfo[i].fIsNullable == VARIANT_TRUE; <br>} <br>else <br>{ <br>fMatchedAll = FALSE; <br> <br>//Try to promote it to the next largest type <br>if(!GetPromotedType(&amp;m_rgColDesc[i].wType))  <br>{ <br>//If unable to promote, we are out of luck <br>wMessageBox(NULL, MB_ICONEXCLAMATION | MB_OK, wsz_ERROR,  <br>wsz_NO_TYPE_MATCH_, GetDBTypeName(m_rgColDesc[i].wType)); <br>goto CLEANUP; <br>} <br>} <br>} <br>} <br> <br> <br>CLEANUP: <br>if(hAccessor &amp;&amp; pIAccessor) <br>XTEST(pIAccessor-&gt;ReleaseAccessor(hAccessor, NULL)); <br> <br>SAFE_RELEASE(pIAccessor); <br>SAFE_RELEASE(pIRowset); <br> <br>SAFE_FREE(rgMatch); <br>SAFE_FREE(rgTypeInfo); <br> <br>SAFE_FREE(rghRows); <br>return hr; <br>} <br> <br> <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::CreateTable <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::CreateTable() <br>{ <br>ASSERT(m_pCDataSource); <br>ASSERT(m_pCDataSource-&gt;m_pICommandText); <br>HRESULT hr; <br> <br>BSTRbstrSqlState = NULL; <br>WCHARwszSqlStmt[MAX_QUERY_LEN];// Create table statement <br> <br>ULONG cRecords = 0; <br>IErrorRecords* pIErrorRecords = NULL; <br>ICommandText* pICommandText = NULL; <br> <br>Busy(); <br> <br>// Setup the initialize CREATE TABLE '&lt;CTableName&gt;' <br>CreateSQLStmt(ESQL_CREATE_TABLE, wszSqlStmt); <br> <br>// Set the Command Text <br>pICommandText = m_pCDataSource-&gt;m_pICommandText; <br>XTESTC(hr = pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wszSqlStmt)); <br> <br>// Execute the command <br>hr = pICommandText-&gt;Execute(NULL, IID_NULL, NULL, NULL, NULL); <br> <br>// If this didn't work, then we need to display messages, and if the <br>// error was a duplicate table, offer to drop. <br>if(FAILED(hr))  <br>{ <br>//Get the Error Records, need to save them, since every call <br>//cleans the previous error objects <br>TESTC(GetErrorRecords(&amp;cRecords, &amp;pIErrorRecords)); <br> <br>//If Error was due to an existing table, just ask to drop it <br>if(GetSqlErrorInfo(0, pIErrorRecords, &amp;bstrSqlState)==S_OK &amp;&amp;  <br>bstrSqlState &amp;&amp; wcscmp(bstrSqlState, L"S0001")==0)  <br>{ <br>WCHAR wszBuffer[MAX_QUERY_LEN]; <br> <br>//If the user doesn't wants to drop it, exit <br>if(IDNO == wMessageBox(NULL, MB_ICONQUESTION | MB_YESNO, wsz_ERROR,  <br>wsz_ASK_DROP_TABLE_, m_wszQualTableName))  <br>goto CLEANUP; <br> <br>//Otherwise drop that table and continue <br>CreateSQLStmt(ESQL_DROP_TABLE, wszBuffer); <br> <br>//Drop the existing Table <br>XTESTC(hr = pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wszBuffer)); <br>XTESTC(hr = pICommandText-&gt;Execute(NULL, IID_NULL, NULL, NULL, NULL)); <br> <br>//Now reset the CreateTable text to the SqlStmt and Execute <br>XTESTC(hr = pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wszSqlStmt)); <br>XTESTC(hr = pICommandText-&gt;Execute(NULL, IID_NULL, NULL, NULL, NULL)); <br>} <br>else <br>{ <br>//Otherwsie unknown error, just display it to the user <br>DisplayErrorRecords(NULL, cRecords, pIErrorRecords); <br>} <br>} <br> <br>CLEANUP: <br>Busy();    <br>SAFE_SYSFREE(bstrSqlState); <br>SAFE_RELEASE(pIErrorRecords); <br>return hr; <br>} <br> <br> <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::CopyIndexes <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::CopyIndexes(CTable* pCTable) <br>{ <br>ASSERT(pCTable); <br>HRESULT hr; <br> <br>WCHARwszBuffer[MAX_NAME_LEN]; <br>WCHARwszSqlStmt[MAX_QUERY_LEN]; <br>ULONG i; <br> <br>//Copy Index Info from Source table <br>m_cIndexes= pCTable-&gt;m_cIndexes; <br> <br>//Array to indicate which index/columns we have used <br>ULONG* rgIndexUsed = NULL; <br>SAFE_ALLOC(rgIndexUsed, ULONG, m_cIndexes); <br>memset(rgIndexUsed, 0, m_cIndexes * sizeof(ULONG)); <br> <br>SAFE_FREE(m_rgIndexInfo); <br>SAFE_ALLOC(m_rgIndexInfo, INDEXINFO, m_cIndexes); <br>memcpy(m_rgIndexInfo, pCTable-&gt;m_rgIndexInfo, m_cIndexes * sizeof(INDEXINFO)); <br> <br>// Loop around each index that is valid.  See if any are to be created <br>for(i=0; i&lt;m_cIndexes; i++)  <br>{ <br>//If this index has already been created, skip <br>//might have been used in another index creation <br>if(rgIndexUsed[i]) <br>continue; <br> <br>//If this index is used as a primary key, skip <br>//PrimaryKeys are taken care of differently <br>if(m_rgIndexInfo[i].fIsPrimaryKey) <br>continue; <br> <br>//"CREATE &lt;UNIQUE&gt; INDEX " <br>swprintf(wszSqlStmt, wsz_CREATE_INDEX_, (m_rgIndexInfo[i].fUnique) ? wsz_UNIQUE_INDEX : wsz_SPACE); <br> <br>//Add IndexName <br>GetQuotedID(wszBuffer, m_rgIndexInfo[i].wszIndexName); <br>wcscat(wszSqlStmt, wszBuffer);  <br> <br>//Add CTableName <br>wcscat(wszSqlStmt, L" ON "); <br>GetQuotedID(wszBuffer, m_wszQualTableName); <br>wcscat(wszSqlStmt, wszBuffer);  <br> <br>wcscat(wszSqlStmt, wsz_LPAREN); <br> <br>// Now loop through the indexes and find all columns that  <br>// belong to this index <br>for(ULONG iCol=i; iCol&lt;m_cIndexes; iCol++)  <br>{ <br>//If not the same index skip <br>if(wcscmp(m_rgIndexInfo[i].wszIndexName, m_rgIndexInfo[iCol].wszIndexName)!=0) <br>continue; <br> <br>//mark this Index as used <br>rgIndexUsed[iCol] = TRUE; <br> <br>// Add the column to the list <br>GetQuotedID(wszBuffer, m_rgIndexInfo[iCol].wszColName); <br>wcscat(wszSqlStmt, wszBuffer); <br> <br>// Indicate Asending or Decending <br>if(m_rgIndexInfo[iCol].dwCollation == DB_COLLATION_DESC) <br>wcscat(wszSqlStmt, wsz_INDEX_DESC);  <br> <br>//Add trailing "," between col names <br>wcscat(wszSqlStmt, wsz_COMMA); <br>} <br> <br>//Replace last trailing "," with a ")" <br>wcscpy(&amp;wszSqlStmt[wcslen(wszSqlStmt)-wcslen(wsz_COMMA)], wsz_RPAREN); <br> <br>// If user wants to see the statement, show it to them <br>if(m_pCWizard-&gt;m_pCTableCopy-&gt;m_fShowQuery) <br>wMessageBox(NULL, MB_OK | MB_ICONINFORMATION, wsz_SHOW_SQL_TITLE,  <br>wsz_SHOW_SQL_, m_pCDataSource-&gt;m_pwszDataSource, wszSqlStmt); <br> <br>//Set the command text <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wszSqlStmt)); <br> <br>//Execute the command <br>//Don't exit yet, the user might want to continue even though this index failed <br>XTEST(hr = m_pCDataSource-&gt;m_pICommandText-&gt;Execute(NULL, IID_NULL, NULL, NULL, NULL)); <br> <br>//If INDEX Failed <br>if(FAILED(hr)) <br>{ <br>//Index Failed, Do you want to Continue? <br>if(IDNO == wMessageBox(NULL, MB_ICONINFORMATION | MB_YESNO, wsz_ERROR,  <br>wsz_INDEX_FAILED_, m_rgIndexInfo[i].wszIndexName)) <br>goto CLEANUP; <br>} <br> <br>//Since the User didn't exit, continue as normal <br>hr = S_OK; <br>} <br> <br>CLEANUP: <br>Busy(); <br>SAFE_FREE(rgIndexUsed); <br>return hr; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::CreateSQLStmt <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::CreateSQLStmt(ESQL_STMT eSqlStmt, WCHAR* pwszSqlStmt, BOOL fShowSql) <br>{ <br>ASSERT(pwszSqlStmt); <br>HRESULT hr = S_OK; <br>WCHAR     wszBuffer[MAX_NAME_LEN*2]; // Buffer <br> <br>switch(eSqlStmt) <br>{ <br>//SELECT &lt;ColumnList&gt; FROM &lt;QualifiedTableName&gt; <br>case ESQL_SELECT: <br>{ <br>//Create the SELECT statment <br>wcscpy(pwszSqlStmt, wsz_SELECT); <br> <br>// Loop through each column <br>for(ULONG i=0; i&lt;m_cColumns; i++)  <br>{ <br>// Add the column to the list <br>GetQuotedID(wszBuffer, m_rgColDesc[i].wszColName); <br>wcscat(pwszSqlStmt, wszBuffer); <br> <br>if(i&lt;m_cColumns-1) <br>wcscat(pwszSqlStmt, wsz_COMMA); <br>}      <br>     <br>// Add the Table Name <br>wcscat(pwszSqlStmt, wsz_FROM); <br>GetQuotedID(wszBuffer, m_wszQualTableName); <br>wcscat(pwszSqlStmt, wszBuffer); <br>} <br>break; <br> <br>case ESQL_SELECT_BOGUS: <br>{ <br>//Create the column list first in standard order <br>wcscpy(pwszSqlStmt, wsz_SELECT); <br> <br>// Loop through each column <br>for(ULONG i=0; i&lt;m_cColumns; i++)  <br>{ <br>GetQuotedID(wszBuffer, m_rgColDesc[i].wszColName); <br>wcscat(pwszSqlStmt, wszBuffer); <br> <br>if(i&lt;m_cColumns-1) <br>wcscat(pwszSqlStmt, wsz_COMMA); <br>} <br> <br>// Add the table name <br>wcscat(pwszSqlStmt, wsz_FROM); <br>GetQuotedID(wszBuffer, m_wszQualTableName); <br>wcscat(pwszSqlStmt, wszBuffer); <br> <br>// Finally, add a bogus WHERE clause. Because we want this <br>// statement to get only metadata, we'll try to tell the <br>// server not to actually get rows. <br>wcscat(pwszSqlStmt, wsz_BOGUS_WHERE); <br>} <br>break; <br> <br>case ESQL_INSERT: <br>{ <br>wcscpy(pwszSqlStmt, wsz_INSERT_INTO); <br> <br>//Add the Table Name <br>GetQuotedID(wszBuffer, m_wszQualTableName); <br>wcscat(pwszSqlStmt, wszBuffer); <br>wcscat(pwszSqlStmt, wsz_LPAREN); <br> <br>// Add the column list <br>for (ULONG i=0; i&lt;m_cColumns; i++)  <br>{ <br>//Only Bind updatable columns <br>if(m_rgColDesc[i].dwFlags &amp; DBCOLUMNFLAGS_WRITE || m_rgColDesc[i].dwFlags &amp; DBCOLUMNFLAGS_WRITEUNKNOWN) <br>{ <br>// Quote each column name if required <br>GetQuotedID(wszBuffer, m_rgColDesc[i].wszColName); <br>wcscat(pwszSqlStmt, wszBuffer); <br> <br>// Now add ", " <br>if(i&lt;m_cColumns-1) <br>wcscat(pwszSqlStmt, wsz_COMMA); <br>} <br>}  <br> <br>// And finally the values list, which will just be parameter markers <br>wcscat(pwszSqlStmt, wsz_VALUES_CLAUSE); <br> <br>// Loop through each column <br>for(i=0; i&lt;m_cColumns; i++)  <br>{ <br>//Only Bind those columns that are updatable <br>if(m_rgColDesc[i].dwFlags &amp; DBCOLUMNFLAGS_WRITE || m_rgColDesc[i].dwFlags &amp; DBCOLUMNFLAGS_WRITEUNKNOWN) <br>{ <br>wcscat(pwszSqlStmt, wsz_PARAM); <br>if(i&lt;m_cColumns-1) <br>wcscat(pwszSqlStmt, wsz_COMMA); <br>} <br>}  <br> <br>// Finish off the string <br>wcscat(pwszSqlStmt, wsz_RPAREN); <br>} <br>break; <br> <br>case ESQL_CREATE_TABLE: <br>{ <br> <br>// Setup the initialize CREATE TABLE '&lt;CTableName&gt;' <br>wcscpy(pwszSqlStmt, wsz_CREATE_TABLE); <br>GetQuotedID(wszBuffer, m_wszQualTableName); <br>wcscat(pwszSqlStmt, wszBuffer); <br> <br>// Setup (&lt;ColList&gt;) <br>wcscat(pwszSqlStmt, wsz_LPAREN); <br> <br>// Loop through each column and format the column name, type, and precision <br>for(ULONG i=0; i&lt;m_cColumns; i++)  <br>{ <br>// Add the ColumnName <br>GetQuotedID(wszBuffer, m_rgColDesc[i].wszColName); <br>wcscat(pwszSqlStmt, wszBuffer); <br> <br>// Add the ColumnType <br>wcscat(pwszSqlStmt, wsz_SPACE); <br>wcscat(pwszSqlStmt, m_rgColDesc[i].wszTypeName); <br> <br>// If required, add the precision and scale information <br>if(m_rgColDesc[i].ulCreateParams &amp; CP_LENGTH) <br>{ <br>swprintf(wszBuffer, L"(%lu)", COLINFO_SIZE(m_rgColDesc[i])); <br>wcscat(pwszSqlStmt, wszBuffer); <br>} <br>else if(m_rgColDesc[i].ulCreateParams &amp; CP_PRECISION &amp;&amp; <br>m_rgColDesc[i].ulCreateParams &amp; CP_SCALE) <br>{ <br>swprintf(wszBuffer, L"(%lu,%lu)", COLINFO_SIZE(m_rgColDesc[i]), m_rgColDesc[i].bScale); <br>wcscat(pwszSqlStmt, wszBuffer); <br>} <br> <br>//Add PRIMARY KEY if Supported and a PrimaryKey Column <br>if(m_pCDataSource-&gt;m_fPrimaryKeysSupported) <br>{ <br>BOOL fPrimaryKey = FALSE; <br> <br>//Loop through the index info and see if this Column  <br>//is supposed to be a primary key of the table <br>for(ULONG iIndex=0; iIndex&lt;m_cIndexes; iIndex++) <br>if(m_rgIndexInfo[iIndex].fIsPrimaryKey &amp;&amp; wcscmp(m_rgIndexInfo[iIndex].wszColName, m_rgColDesc[i].wszColName)==0) <br>fPrimaryKey = TRUE; <br> <br>//If PrimaryKey, add PRIMARY KEY info <br>if(fPrimaryKey) <br>wcscat(pwszSqlStmt, wsz_PRIMARY_KEY); <br>} <br> <br>if(i&lt;m_cColumns-1) <br>wcscat(pwszSqlStmt, wsz_COMMA); <br>} <br> <br>//Add trailing ")" <br>wcscat(pwszSqlStmt, wsz_RPAREN); <br>} <br>break; <br> <br>case ESQL_DROP_TABLE: <br>{ <br>swprintf(pwszSqlStmt, wsz_DROP_TABLE_, m_wszQualTableName); <br>} <br>break; <br> <br>default: <br>ASSERT(!"Unhandled Case!"); <br>break; <br>}; <br> <br>// If user wants to see the statement, show it to them <br>if(m_pCWizard-&gt;m_pCTableCopy-&gt;m_fShowQuery &amp;&amp; fShowSql) <br>wMessageBox(NULL, MB_OK | MB_ICONINFORMATION, wsz_SHOW_SQL_TITLE,  <br>wsz_SHOW_SQL_, m_pCDataSource-&gt;m_pwszDataSource, pwszSqlStmt); <br> <br>return hr; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::GetRowset <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::GetRowset(REFIID riid, IUnknown** ppIRowset, HACCESSOR* phAccessor, ULONG* pRowSize, ULONG ulBlobSize) <br>{ <br>ASSERT(ppIRowset); <br>ASSERT(m_pCDataSource); <br>ASSERT(m_pCDataSource-&gt;m_pICommandText); <br> <br>HRESULT hr; <br> <br>WCHAR*pwszCol = NULL;// String manipulation <br>    WCHARwszSqlStmt[MAX_QUERY_LEN];// Format the select statement <br> <br>ULONGi;// Column index <br> <br>ULONG ulOffset = 0; <br>ULONG cBindings = 0; <br>DBBINDING* rgBindings = NULL; <br> <br>const ULONG cPropSets = 1; <br>DBPROPSET rgPropSets[cPropSets]; <br>const ULONG cProperties = 3; <br>DBPROP rgProperties[cProperties]; <br> <br>rgPropSets[0].cProperties = cProperties; <br>rgPropSets[0].rgProperties = rgProperties; <br>rgPropSets[0].guidPropertySet = DBPROPSET_ROWSET; <br> <br>    Busy(); <br> <br>ICommandProperties* pICommandProperties = NULL; <br>IAccessor* pIAccessor = NULL; <br> <br>//Alloc the space to hold the Bindings <br>SAFE_ALLOC(rgBindings, DBBINDING, m_cColumns); <br> <br>//Create the SELECT statment <br>CreateSQLStmt(ESQL_SELECT, wszSqlStmt); <br> <br>// Now execute the select statement <br>LONGcRowsAffected; <br> <br>rgPropSets[0].cProperties = 0; <br>if(m_cBlobs) <br>{ <br>//Kagera's Implementation requires IID_RowsetLocate for BLOB Support <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].dwPropertyID= DBPROP_IRowsetLocate; <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].dwOptions= DBPROPOPTIONS_REQUIRED; <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].dwStatus= DBPROPSTATUS_OK; <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].colid= DB_NULLID; <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].vValue.vt= VT_BOOL; <br>V_BOOL(&amp;rgPropSets[0].rgProperties[rgPropSets[0].cProperties].vValue) = VARIANT_TRUE; <br>rgPropSets[0].cProperties++; <br>} <br> <br>if(riid == IID_IRowsetChange) <br>{ <br>//Set UPDATABILITY for IID_IRowsetChange <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].dwPropertyID= DBPROP_UPDATABILITY; <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].dwOptions= DBPROPOPTIONS_REQUIRED; <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].dwStatus= DBPROPSTATUS_OK; <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].colid= DB_NULLID; <br>rgPropSets[0].rgProperties[rgPropSets[0].cProperties].vValue.vt= VT_I4; <br>V_I4(&amp;rgPropSets[0].rgProperties[rgPropSets[0].cProperties].vValue) = DBPROPVAL_UP_CHANGE | DBPROPVAL_UP_DELETE | DBPROPVAL_UP_INSERT; <br>rgPropSets[0].cProperties++; <br>} <br> <br>//Set any properties </code></pre>
<p>
</p>
<pre><code>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;QueryInterface(IID_ICommandProperties, (void**)&amp;pICommandProperties)); <br>XTESTC(hr = pICommandProperties-&gt;SetProperties(cPropSets, rgPropSets)); <br> <br>//Set the command text <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wszSqlStmt)); <br> <br>//Execute the Command <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;Execute(NULL, riid, NULL, &amp;cRowsAffected, (IUnknown**)ppIRowset)); <br> <br>// Prepare the bindings and create the accessor for each column <br>XTESTC(hr = (*ppIRowset)-&gt;QueryInterface(IID_IAccessor, (void **)&amp;pIAccessor)); <br> <br>ulOffset = 0; <br>cBindings = 0; <br>for(i=0; i&lt;m_cColumns; i++)  <br>{ <br>//SetUp the Bindings <br>rgBindings[cBindings].iOrdinal= i+1; <br>rgBindings[cBindings].obStatus= ulOffset; <br>rgBindings[cBindings].obLength= ulOffset + sizeof(DBSTATUS); <br>rgBindings[cBindings].obValue= ulOffset + sizeof(DBSTATUS) + sizeof(ULONG); <br> <br>rgBindings[cBindings].pTypeInfo = NULL; <br>rgBindings[cBindings].pBindExt  = NULL; <br> <br>rgBindings[cBindings].dwPart= DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS; <br>rgBindings[cBindings].dwMemOwner= DBMEMOWNER_CLIENTOWNED; <br>rgBindings[cBindings].eParamIO= DBPARAMIO_NOTPARAM; <br> <br>rgBindings[cBindings].dwFlags= 0; <br>rgBindings[cBindings].bPrecision= m_rgColDesc[i].bPrecision; <br>rgBindings[cBindings].bScale= m_rgColDesc[i].bScale; <br> <br>rgBindings[cBindings].pObject= NULL; <br>rgBindings[cBindings].wType= m_rgColDesc[i].wType; <br>rgBindings[cBindings].cbMaxLen= m_rgColDesc[i].ulColumnSize; <br> <br>//Adjust ISLONG Columns if not bound as ISeqStream <br>if(m_rgColDesc[i].dwFlags &amp; DBCOLUMNFLAGS_ISLONG) <br>ADJUST_SIZE(rgBindings[cBindings].cbMaxLen, ulBlobSize); <br> <br>ulOffset = ROUNDUP(rgBindings[cBindings].obValue + rgBindings[cBindings].cbMaxLen); <br>cBindings++; <br>} <br> <br>//Size for pData <br>if(pRowSize) <br>*pRowSize = ulOffset; <br> <br>//Create the accessor for the entire row <br>if(phAccessor) <br>XTESTC(hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, cBindings, rgBindings, 0, phAccessor, NULL)); <br> <br> <br>CLEANUP: <br>Busy(); <br>FreeBindings(cBindings, rgBindings); <br>SAFE_RELEASE(pICommandProperties); <br>SAFE_RELEASE(pIAccessor); <br>return hr; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////// <br>// HRESULT CTable::CopyData <br>// <br>///////////////////////////////////////////////////////////////// <br>HRESULT CTable::CopyData(CTable* pCTable, ULONG* pcRows, ULONG ulParamSets, ULONG ulBlobSize) <br>{ <br>ASSERT(pCTable &amp;&amp; pcRows); <br>ASSERT(m_pCDataSource); <br>ASSERT(m_pCDataSource-&gt;m_pICommandText); <br>HRESULT hr; <br> <br>WCHARwszSqlStmt[MAX_QUERY_LEN];// Format the select statement <br>WCHARwszBuffer[MAX_NAME_LEN]; <br> <br>ULONGi,iCol;// Column index <br>    ULONGulOffset = 0; <br>ULONGcBindings = 0; <br>DBBINDING*rgBindings = NULL; <br> <br>IAccessor* pIAccessor = NULL; <br>HACCESSOR  hAccessor = DB_NULL_HACCESSOR; <br> <br>ULONG cRowSize = 0; <br> <br>IRowsetChange* pIRowsetChange = NULL; <br> <br>ULONG cRowsObtained = 0; <br>HROW* rghRows = NULL; <br> <br>DBPARAMS DBParams; <br> <br>void* pData = NULL; <br>ULONG cRows = 0; <br>ULONG cMaxRows = *pcRows; <br> <br>    Busy(); <br>     <br>HACCESSOR hFromAccessor = DB_NULL_HACCESSOR; <br>IRowset* pIFromRowset = NULL; <br> <br>//Get the Rowset from the FromCTable <br>TESTC(hr = pCTable-&gt;GetRowset(IID_IRowset, (IUnknown**)&amp;pIFromRowset, &amp;hFromAccessor, &amp;cRowSize, ulBlobSize)); <br> <br>//Obtain the Accessor <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;QueryInterface(IID_IAccessor, (void **)&amp;pIAccessor)); <br>SAFE_ALLOC(rgBindings, DBBINDING, m_cColumns); <br> <br>cBindings = 0;  <br>for(i=0; i&lt;m_cColumns; i++)  <br>{ <br>rgBindings[cBindings].iOrdinal= ulParamSets ? cBindings+1 : i+1; <br>rgBindings[cBindings].obStatus  = ulOffset; <br>rgBindings[cBindings].obLength  = ulOffset + sizeof(DBSTATUS); <br>rgBindings[cBindings].obValue   = ulOffset + sizeof(ULONG) + sizeof(DBSTATUS); <br> <br>rgBindings[cBindings].pTypeInfo = NULL; <br>rgBindings[cBindings].pBindExt  = NULL; <br> <br>rgBindings[cBindings].dwPart= DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS; <br>rgBindings[cBindings].dwMemOwner= DBMEMOWNER_CLIENTOWNED; <br>rgBindings[cBindings].eParamIO= ulParamSets ? DBPARAMIO_INPUT : DBPARAMIO_NOTPARAM; <br>rgBindings[cBindings].dwFlags= 0; <br> <br>rgBindings[cBindings].bPrecision= pCTable-&gt;m_rgColDesc[i].bPrecision; <br>rgBindings[cBindings].bScale= pCTable-&gt;m_rgColDesc[i].bScale; <br> <br>rgBindings[cBindings].pObject= NULL; <br>rgBindings[cBindings].wType= m_rgColDesc[i].wType; <br>rgBindings[cBindings].cbMaxLen= pCTable-&gt;m_rgColDesc[i].ulColumnSize; <br> <br>//Adjust ISLONG Columns if not bound as ISeqStream <br>if(m_rgColDesc[i].dwFlags &amp; DBCOLUMNFLAGS_ISLONG) <br>ADJUST_SIZE(rgBindings[cBindings].cbMaxLen, ulBlobSize); <br> <br>ulOffset = ROUNDUP(rgBindings[cBindings].obValue + rgBindings[cBindings].cbMaxLen); <br> <br>//Only Bind Updatable columns <br>//Note, we are not using the Source info here, since in the process <br>//of adjusting columns to a different DSN, the columns may have become writeable <br>if(m_rgColDesc[i].dwFlags &amp; DBCOLUMNFLAGS_WRITE || m_rgColDesc[i].dwFlags &amp; DBCOLUMNFLAGS_WRITEUNKNOWN) <br>cBindings++; <br>} <br> <br>if (cBindings)  <br>XTESTC(hr = pIAccessor-&gt;CreateAccessor(ulParamSets ? DBACCESSOR_PARAMETERDATA : DBACCESSOR_ROWDATA, cBindings,rgBindings, ulOffset, &amp;hAccessor, NULL)); <br> <br> <br>//If using Parameters to INSERT the Data <br>if(ulParamSets) <br>{ <br>// Now create the INSERT INTO statment <br>CreateSQLStmt(ESQL_INSERT, wszSqlStmt, ulParamSets); <br> <br>//Set the command text <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wszSqlStmt)); <br>} <br>//Oterwise were using InsertRow <br>else <br>{ <br>//Create the TargetRowset  <br>TESTC(hr = GetRowset(IID_IRowsetChange, (IUnknown**)&amp;pIRowsetChange, NULL, NULL, ulBlobSize)); <br>} <br> <br> <br>// Display the progress dialog <br>ASSERT(m_pCWizard &amp;&amp; m_pCWizard-&gt;m_pCProgress); <br>m_pCWizard-&gt;m_pCProgress-&gt;Display(); <br>m_pCWizard-&gt;m_pCProgress-&gt;SetWorkingItem(wsz_COPYING); <br> <br>//Alloc room for pData <br>SAFE_ALLOC(pData, BYTE, max(ulParamSets, MAX_BLOCK_SIZE) * cRowSize); <br> <br>//Setup DBPARAMS Struct <br>DBParams.cParamSets = 1;//Numer of Parameter sets <br>DBParams.hAccessor= hAccessor;//Target Param Accessor <br>DBParams.pData= pData;//Source Data <br> <br>while(cRows &lt; cMaxRows) <br>{ <br>hr = pIFromRowset-&gt;GetNextRows(NULL, 0, (ulParamSets &gt; 1) ? ulParamSets : MAX_BLOCK_SIZE, &amp;cRowsObtained, &amp;rghRows); <br>if(FAILED(hr) || cRowsObtained==0) <br>break; <br> <br>//Determine the number of rows that are actually needed to retrieve <br>//The user might have specfified the number of rows to retrieve which could  <br>//be smaller than the number in the block size <br>ULONG cRowsNeeded = min(cRowsObtained, cMaxRows-cRows); <br> <br>//Use Parameters to INSERT the data, use MultipleParamSets <br>if(ulParamSets &gt; 1) <br>{ <br>//GetData <br>for (i=0; i&lt;cRowsNeeded; i++)  <br>XTESTC(hr = pIFromRowset-&gt;GetData(rghRows[i], hFromAccessor, (BYTE*)pData + (i*cRowSize))); <br> <br>//Adjust the paramerer sets <br>DBParams.cParamSets = cRowsNeeded; <br> <br>//Execute the INSERT (multiple param sets) <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;Execute(NULL, IID_NULL, &amp;DBParams, NULL, NULL)); <br> <br>// Update insert progress <br>swprintf(wszBuffer, wsz_COPIED_RECORDS, (cRows += cRowsNeeded)); <br>if(!m_pCWizard-&gt;m_pCProgress-&gt;UpdateProgress(wsz_COPYING, wszBuffer)) <br>goto CLEANUP; <br>} <br>//Use Paramseters to INSERT the data, but only 1 ParamSet (not multiple) <br>else if(ulParamSets == 1) <br>{ <br>for (i=0; i&lt;cRowsNeeded; i++)  <br>{ <br>//GetData <br>XTESTC(hr = pIFromRowset-&gt;GetData(rghRows[i], hFromAccessor, pData)); <br> <br>//Execute the INSERT <br>XTESTC(hr = m_pCDataSource-&gt;m_pICommandText-&gt;Execute(NULL, IID_NULL, &amp;DBParams, NULL, NULL)); <br> <br>// Update insert progress <br>swprintf(wszBuffer, wsz_COPIED_RECORDS, cRows++); <br>if(!m_pCWizard-&gt;m_pCProgress-&gt;UpdateProgress(wsz_COPYING, wszBuffer)) <br>goto CLEANUP; <br>} <br>} <br>//Use IRowsetChange::InsertRow to INSERT the Data <br>else <br>{ <br>for (i=0; i&lt;cRowsNeeded; i++)  <br>{ <br>//GetData from the Source <br>XTESTC(hr = pIFromRowset-&gt;GetData(rghRows[i], hFromAccessor, pData)); <br> <br>//Adjust the Status fields to be DBSTATUS_S_OK | DBSTATUS_S_ISNULL <br>//GetData mihgt have reported DB_S_TRUNCATED or other minor problems <br>for(iCol = 0; iCol &lt; cBindings; iCol++) <br>if(STATUS_IS_BOUND(rgBindings[iCol]) &amp;&amp; BINDING_STATUS(rgBindings[iCol], pData) != DBSTATUS_S_ISNULL) <br>BINDING_STATUS(rgBindings[iCol],pData) = DBSTATUS_S_OK; <br> <br>//InsertRow to the Target <br>XTESTC(hr = pIRowsetChange-&gt;InsertRow(NULL, hAccessor, pData, NULL)); <br> <br>// Update insert progress <br>swprintf(wszBuffer, wsz_COPIED_RECORDS, cRows++); <br>if(!m_pCWizard-&gt;m_pCProgress-&gt;UpdateProgress(wsz_COPYING, wszBuffer)) <br>goto CLEANUP; <br>} <br>} <br> <br>//Release the group of rows <br>XTESTC(hr = pIFromRowset-&gt;ReleaseRows(cRowsObtained, rghRows, NULL, NULL, NULL)); <br>SAFE_FREE(rghRows); <br>} <br> <br>CLEANUP: <br>//Stop the propgress <br>m_pCWizard-&gt;m_pCProgress-&gt;StopProgress(); <br> <br>Busy(); <br>*pcRows = cRows; <br> <br>//Release Accessors <br>if(m_pCDataSource-&gt;m_pICommandText &amp;&amp; hAccessor) <br>XTEST(pIAccessor-&gt;ReleaseAccessor(hAccessor, NULL)); <br>SAFE_RELEASE(pIAccessor); <br> <br>//Release Accessors <br>if(pIFromRowset &amp;&amp; hFromAccessor) <br>{ <br>XTEST(pIFromRowset-&gt;QueryInterface(IID_IAccessor, (void **)&amp;pIAccessor)); <br>XTEST(pIAccessor-&gt;ReleaseAccessor(hFromAccessor, NULL)); <br>} <br>SAFE_RELEASE(pIAccessor); <br>SAFE_RELEASE(pIFromRowset); <br>SAFE_RELEASE(pIRowsetChange); <br> <br>FreeBindings(cBindings, rgBindings);  <br>SAFE_FREE(rghRows); <br>SAFE_FREE(pData); <br>return hr; <br>} <br> <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// HRESULT CTable::GetTypeInfoRowset <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT CTable::GetTypeInfoRowset(IAccessor** ppIAccessor, HACCESSOR* phAccessor, IRowset** ppIRowset) <br>{ <br>ASSERT(ppIAccessor &amp;&amp; phAccessor &amp;&amp; ppIRowset); <br>ASSERT(m_pCDataSource &amp;&amp; m_pCDataSource-&gt;m_pIDBCreateCommand); <br>HRESULT hr; <br> <br>IDBSchemaRowset* pIDBSchemaRowset = NULL; <br>  <br>//Bind all the columns from types rowset:  <br>const ULONG cBindings = 6; <br>const DBBINDING rgBindings[cBindings] =  <br>{ <br>1,  <br>offsetof(TYPEINFO, wszTypeName),// offset of value in consumers buffer <br>0,// offset of length <br>0,// offset of status <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies Value is bound only <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>MAX_NAME_LEN,// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_WSTR, // data type indicator <br>0,// precision <br>0, // scale <br> <br>2,  <br>offsetof(TYPEINFO, wType),// offset of value in consumers buffer <br>0,// offset of length <br>0,// offset of status <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies Value is bound only <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(USHORT),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_UI2, // data type indicator <br>0,// precision <br>0, // scale <br> <br>3,  <br>offsetof(TYPEINFO, ulColumnSize),// offset of value in consumers buffer <br>0,// offset of length <br>0,// offset of status <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies Value is bound only <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(ULONG),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_UI4, // data type indicator <br>0,// precision <br>0, // scale <br> <br>6,  <br>offsetof(TYPEINFO, wszCreateParams),// offset of value in consumers buffer <br>0,// offset of length <br>0,// offset of status <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies Value is bound only <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>MAX_NAME_LEN,// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_WSTR, // data type indicator <br>0,// precision <br>0, // scale <br> <br>7,  <br>offsetof(TYPEINFO, fIsNullable),// offset of value in consumers buffer <br>0,// offset of length <br>0,// offset of status <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies Value is bound only <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(VARIANT_BOOL),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_BOOL, // data type indicator <br>0,// precision <br>0, // scale <br> <br>16,  <br>offsetof(TYPEINFO, guidType),// offset of value in consumers buffer <br>0,// offset of length <br>0,// offset of status <br>NULL,// reserved <br>NULL,// for ole object <br> NULL,// reserved <br>DBPART_VALUE,// specifies Value is bound only <br>DBMEMOWNER_CLIENTOWNED,// memory is client owned <br>DBPARAMIO_NOTPARAM,//  <br>sizeof(GUID),// size in bytes of the value part in the consumers buffer <br>0, // reserved <br>DBTYPE_GUID, // data type indicator <br>0,// precision <br>0, // scale <br>}; <br> <br>//Return if this interface is not supported  <br>XTESTC(hr = m_pCDataSource-&gt;m_pIDBCreateCommand-&gt;QueryInterface(IID_IDBSchemaRowset, (void **)&amp;pIDBSchemaRowset)); <br> <br>//GetRowset <br>//DBSCHEMA_PROVIDER_TYPES is required a SCHEMA <br>XTESTC(hr = pIDBSchemaRowset-&gt;GetRowset(NULL, DBSCHEMA_PROVIDER_TYPES, 0, NULL, IID_IRowset,0, NULL, (IUnknown**)ppIRowset)); <br> <br>//Create the the Accessor <br>XTESTC(hr = (*ppIRowset)-&gt;QueryInterface(IID_IAccessor, (void **)ppIAccessor)); <br>XTESTC(hr = (*ppIAccessor)-&gt;CreateAccessor(DBACCESSOR_ROWDATA, cBindings, rgBindings, 0, phAccessor, NULL)); <br> <br> <br>CLEANUP: <br>SAFE_RELEASE(pIDBSchemaRowset); <br>return hr; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
