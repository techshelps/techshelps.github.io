<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINMAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2370"></a>WINMAIN.CPP</h2>
<pre><code>//----------------------------------------------------------------------------- <br>// Microsoft OLE DB TABLECOPY Sample <br>// Copyright (C) 1996 By Microsoft Corporation. <br>// <br>// @doc <br>// <br>// @module WINMAIN.CPP <br>// <br>//----------------------------------------------------------------------------- <br> <br> <br>/////////////////////////////////////////////////////////////////////// <br>// Includes <br>// <br>/////////////////////////////////////////////////////////////////////// <br>#include "winmain.h" <br>#include "wizard.h" <br>#include "common.h" <br>#include "tablecopy.h" <br>#include "table.h" <br>#include "spy.h" <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// int WINAPI WinMain <br>// <br>// Main application entry point <br>////////////////////////////////////////////////////////////////// <br>int WINAPI WinMain(HINSTANCE hInstance, <br>                    HINSTANCE hPrevInstance, <br>                    CHAR*  pszCmdLine, <br>                    INT    nCmdShow) <br>{ <br>//Register IMallocSpy <br>CMallocSpy* pCMallocSpy = NULL;  <br>MallocSpyRegister(&amp;pCMallocSpy);  <br> <br>CWizard* pCWizard = new CWizard(NULL, hInstance); <br>HRESULT hr; <br> <br>XTESTC(hr = CoInitialize(NULL)); <br> <br>//Main Execution <br>pCWizard-&gt;Run(); <br> <br>CLEANUP: <br>delete pCWizard; <br> <br>MallocSpyUnRegister(pCMallocSpy); <br>CoUninitialize(); <br> <br>//Dump all the leaks <br>MallocSpyDump(pCMallocSpy); <br>delete pCMallocSpy; <br> <br>return (hr==S_OK); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// void SyncSibling <br>// <br>////////////////////////////////////////////////////////////////// <br>void SyncSibling(HWND hToWnd, HWND hFromWnd) <br>{ <br>ASSERT(hToWnd &amp;&amp; hFromWnd); <br> <br>//Make both windows synched,  <br>//Get the current selection from the Source <br>LONG lSel = SendMessage(hFromWnd, LB_GETCURSEL, (WPARAM)0, (LPARAM)0L); <br> <br>//Tell the Target to select the same selection <br>if(lSel != LB_ERR) <br>SendMessage(hToWnd, LB_SETCURSEL, (WPARAM)lSel, (LPARAM)0L); <br>}                 <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// void InternalAssert <br>// <br>////////////////////////////////////////////////////////////////// <br>void InternalAssert( <br>char*pszExp,// The expression causing assert <br>char*pszFile,// The file name <br>UINTiLine// Line number of assert <br>) <br>{ <br>CHARszMsg[MAX_QUERY_LEN]; <br>_snprintf(szMsg, MAX_NAME_LEN, "Assertion Error!\n File '%s', Line '%lu'\n" <br>"Expression '%s'\n\n" <br>"Do you wish to Continue?  (Press 'OK' to ignore the assertion." <br>"  Press 'Cancel to debug.)",pszFile, iLine, pszExp); <br> <br>//Popup a MessageBox <br>LONG dwSelection = MessageBoxA(NULL, szMsg,"Assertion Error", <br>MB_APPLMODAL | MB_ICONSTOP | MB_OKCANCEL | MB_DEFBUTTON1 ); <br> <br>switch (dwSelection) <br>{ <br>case IDOK: <br>break; <br>case IDCANCEL: <br>DebugBreak(); <br>break; <br>default: <br>ASSERT(!L"Unhandled Choice"); <br>} <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// void InternalTrace <br>// <br>////////////////////////////////////////////////////////////////// <br>void InternalTrace(WCHAR*pwszFmt, ...) <br>{ <br>va_listmarker; <br>WCHARwszBuffer[MAX_NAME_LEN]; <br>CHARszBuffer[MAX_NAME_LEN]; <br> <br>// Use format and arguements as input <br>//This version will not overwrite the stack, since it only copies <br>//upto the max size of the array <br>va_start(marker, pwszFmt); <br>_vsnwprintf(wszBuffer, MAX_NAME_LEN, pwszFmt, marker); <br>va_end(marker); <br> <br>//Make sure there is a NULL Terminator, vsnwprintf will not copy <br>//the terminator if length==MAX_NAME_LEN <br>wszBuffer[MAX_NAME_LEN-1] = EOL; <br> <br>//Convert to MBCS <br>ConvertToMBCS(wszBuffer, szBuffer, MAX_NAME_LEN); <br> <br>//Output to the DebugWindow <br>OutputDebugString(szBuffer); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// void InternalTrace <br>// <br>////////////////////////////////////////////////////////////////// <br>void InternalTrace(CHAR*pszFmt, ...) <br>{ <br>va_listmarker; <br>CHARszBuffer[MAX_NAME_LEN]; <br> <br>// Use format and arguements as input <br>//This version will not overwrite the stack, since it only copies <br>//upto the max size of the array <br>va_start(marker, pszFmt); <br>_vsnprintf(szBuffer, MAX_NAME_LEN, pszFmt, marker); <br>va_end(marker); <br> <br>//Make sure there is a NULL Terminator, vsnwprintf will not copy <br>//the terminator if length==MAX_NAME_LEN <br>szBuffer[MAX_NAME_LEN-1] = '\0'; <br> <br>OutputDebugStringA(szBuffer); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// void Busy <br>// <br>////////////////////////////////////////////////////////////////// <br>void Busy(void) <br>{ <br>static HCURSORhCursor; <br> <br>ShowCursor(FALSE); <br> <br>if(hCursor == NULL)  <br>hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>else  <br>{ <br>SetCursor(hCursor); <br>hCursor = NULL; <br>} <br> <br>ShowCursor(TRUE); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// void OutOfMemory <br>// <br>////////////////////////////////////////////////////////////////// <br>void OutOfMemory(HWND hWnd) <br>{ <br>//Unicode version is supported on Win95/WinNT <br>MessageBoxW(hWnd, L"Out of memory", L"Error", MB_OK); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// BOOL CenterDialog <br>// <br>////////////////////////////////////////////////////////////////// <br>BOOL CenterDialog(HWND hdlg) <br>{ <br>RECT  rcParent;                         // Parent window client rect <br>RECT  rcDlg;                            // Dialog window rect <br>int   nLeft, nTop;                      // Top-left coordinates <br>int   cWidth, cHeight;                  // Width and height <br>HWNDhwnd; <br> <br>// Get frame window client rect in screen coordinates <br>hwnd = GetParent(hdlg); <br>if(hwnd == NULL || hwnd == GetDesktopWindow())  <br>{ <br>rcParent.top = rcParent.left = 0; <br>rcParent.right = GetSystemMetrics(SM_CXFULLSCREEN); <br>rcParent.bottom = GetSystemMetrics(SM_CYFULLSCREEN); <br>} <br>else  <br>GetWindowRect(hwnd, &amp;rcParent); <br> <br>// Determine the top-left point for the dialog to be centered <br>GetWindowRect(hdlg, &amp;rcDlg); <br>cWidth  = rcDlg.right  - rcDlg.left; <br>cHeight = rcDlg.bottom - rcDlg.top; <br>nLeft   = rcParent.left +  <br>            (((rcParent.right  - rcParent.left) - cWidth ) / 2); <br>nTop    = rcParent.top  + <br>            (((rcParent.bottom - rcParent.top ) - cHeight) / 2); <br>if (nLeft &lt; 0) nLeft = 0; <br>if (nTop  &lt; 0) nTop  = 0; <br> <br>// Place the dialog <br>return MoveWindow(hdlg, nLeft, nTop, cWidth, cHeight, TRUE); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// ULONG wMessageBox <br>// <br>////////////////////////////////////////////////////////////////// <br>INT wMessageBox( <br>HWND hwnd,// Parent window for message display <br>UINT uiStyle,// Style of message box <br>WCHAR* pwszTitle,// Title for message <br>WCHAR* pwszFmt,// Format string <br>...// Substitution parameters <br>) <br>{ <br>va_listmarker; <br>WCHARwszBuffer[MAX_QUERY_LEN]; <br> <br>// Use format and arguements as input <br>//This version will not overwrite the stack, since it only copies <br>//upto the max size of the array <br>va_start(marker, pwszFmt); <br>_vsnwprintf(wszBuffer, MAX_QUERY_LEN, pwszFmt, marker); <br>va_end(marker); <br>    <br>//Make sure there is a NULL Terminator, vsnwprintf will not copy <br>//the terminator if length==MAX_QUERY_LEN <br>wszBuffer[MAX_QUERY_LEN-1] = EOL; <br> <br>//Unicode version is supported on both Win95 / WinNT do need to convert <br>return MessageBoxW(hwnd, wszBuffer, pwszTitle, uiStyle); <br>} <br> <br> <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// void wSetDlgItemText <br>// <br>////////////////////////////////////////////////////////////////// <br>void wSetDlgItemText(HWND hWnd, INT DlgItem, WCHAR* pwszFmt, ...) <br>{ <br>va_listmarker; <br>WCHARwszBuffer[MAX_NAME_LEN]; <br>CHARszBuffer[MAX_NAME_LEN]; <br> <br>// Use format and arguements as input <br>//This version will not overwrite the stack, since it only copies <br>//upto the max size of the array <br>va_start(marker, pwszFmt); <br>_vsnwprintf(wszBuffer, MAX_NAME_LEN, pwszFmt, marker); <br>va_end(marker); <br> <br>//Make sure there is a NULL Terminator, vsnwprintf will not copy <br>//the terminator if length==MAX_NAME_LEN <br>wszBuffer[MAX_NAME_LEN-1] = EOL; <br> <br>//convert to MBCS <br>ConvertToMBCS(wszBuffer, szBuffer, MAX_NAME_LEN); <br> <br>SetDlgItemTextA(hWnd, DlgItem, szBuffer); <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// UINT wGetDlgItemText <br>// <br>////////////////////////////////////////////////////////////////// <br>UINT wGetDlgItemText(HWND hWnd, INT DlgItem, WCHAR* pwsz, INT nMaxSize) <br>{ <br>ASSERT(pwsz); <br>CHAR szBuffer[MAX_NAME_LEN]; <br> <br>UINT iReturn = GetDlgItemTextA(hWnd, DlgItem, szBuffer, MAX_NAME_LEN); <br> <br>//convert to WCHAR <br>ConvertToWCHAR(szBuffer, pwsz, MAX_NAME_LEN); <br>return iReturn; <br>} <br> <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// LRESULT wSendMessage <br>// <br>////////////////////////////////////////////////////////////////// <br>LRESULT wSendMessage(HWND hWnd, UINT Msg, WPARAM wParam, WCHAR* pwszName) <br>{ <br>ASSERT(pwszName); <br>CHAR szBuffer[MAX_NAME_LEN];   <br> <br>//Convert to ANSI before sending, since we don't know if this was a GET/SET message <br>ConvertToMBCS(pwszName, szBuffer, MAX_NAME_LEN); <br> <br>//Send the message with an ANSI Buffer  <br>LRESULT lResult = SendMessage(hWnd, Msg, (WPARAM)wParam, (LPARAM)szBuffer); <br> <br>//Now convert the result into the users WCHAR buffer <br>ConvertToWCHAR(szBuffer, pwszName, MAX_NAME_LEN); <br>return lResult; <br>} <br> <br> <br>////////////////////////////////////////////////////////////////// <br>// BOOL GetEditBoxValue <br>// <br>////////////////////////////////////////////////////////////////// <br>BOOL GetEditBoxValue(HWND hEditWnd, ULONG ulMin, ULONG ulMax, ULONG* pulCount) <br>{ <br>ASSERT(hEditWnd); <br>ASSERT(pulCount); <br> <br>ULONGulCount = 0; <br>WCHARwszBuffer[MAX_NAME_LEN]; <br>WCHAR*  pwszEnd = NULL; <br> <br>//Get the EditText <br>wSendMessage(hEditWnd, WM_GETTEXT, MAX_NAME_LEN, wszBuffer); <br> <br>//Convert to ULONG <br>ulCount = wcstoul(wszBuffer, &amp;pwszEnd, 10); <br>if(!wszBuffer[0] || ulCount&lt;ulMin || ulCount&gt;ulMax || pwszEnd==NULL || pwszEnd[0]!=EOL)  <br>{ <br>wMessageBox(hEditWnd, MB_ICONEXCLAMATION | MB_OK, wsz_ERROR,  <br>wsz_INVALID_VALUE_, wszBuffer, ulMin, ulMax); <br>SetFocus(hEditWnd); <br>return FALSE; <br>} <br> <br>*pulCount = ulCount; <br>return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
