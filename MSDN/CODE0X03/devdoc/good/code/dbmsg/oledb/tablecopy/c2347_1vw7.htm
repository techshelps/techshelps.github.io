<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMMON.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2347"></a>COMMON.CPP</h2>
<pre><code>//----------------------------------------------------------------------------- <br>// Microsoft OLE DB TABLECOPY Sample <br>// Copyright (C) 1996 By Microsoft Corporation. <br>// <br>// @doc <br>// <br>// @module COMMON.CPP <br>// <br>//----------------------------------------------------------------------------- <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Include <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>#include "winmain.h" <br>#include "common.h" <br>#include "tablecopy.h" <br>#include "table.h" <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Defines <br>// <br>///////////////////////////////////////////////////////////////////////////// <br> <br>//Displays values like VALUE as   VALUE , L"VALUE" <br>#define VALUE_WCHAR(value) value, L#value <br> <br>typedef struct _TYPEMAP <br>{ <br>DBTYPEwType;// The sql type value <br>WCHAR*pwszTypeName;// Name for display <br>} TYPEMAP; <br> <br>TYPEMAP rgDBTypes[] =  <br>{ <br>VALUE_WCHAR(DBTYPE_I1), <br>VALUE_WCHAR(DBTYPE_I2), <br>VALUE_WCHAR(DBTYPE_I4), <br>VALUE_WCHAR(DBTYPE_I8), <br>VALUE_WCHAR(DBTYPE_UI1), <br>VALUE_WCHAR(DBTYPE_UI2), <br>VALUE_WCHAR(DBTYPE_UI4), <br>VALUE_WCHAR(DBTYPE_UI8), <br>VALUE_WCHAR(DBTYPE_R4), <br>VALUE_WCHAR(DBTYPE_R8), <br>VALUE_WCHAR(DBTYPE_CY), <br>VALUE_WCHAR(DBTYPE_DECIMAL), <br>VALUE_WCHAR(DBTYPE_NUMERIC), <br>VALUE_WCHAR(DBTYPE_BOOL), <br>VALUE_WCHAR(DBTYPE_ERROR), <br>VALUE_WCHAR(DBTYPE_UDT), <br>VALUE_WCHAR(DBTYPE_VARIANT), <br>VALUE_WCHAR(DBTYPE_IDISPATCH), <br>VALUE_WCHAR(DBTYPE_IUNKNOWN), <br>VALUE_WCHAR(DBTYPE_GUID), <br>VALUE_WCHAR(DBTYPE_DATE), <br>VALUE_WCHAR(DBTYPE_DBDATE), <br>VALUE_WCHAR(DBTYPE_DBTIME), <br>VALUE_WCHAR(DBTYPE_DBTIMESTAMP), <br>VALUE_WCHAR(DBTYPE_BSTR), <br>VALUE_WCHAR(DBTYPE_STR), <br>VALUE_WCHAR(DBTYPE_WSTR), <br>VALUE_WCHAR(DBTYPE_BYTES), <br>}; <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// HRESULT ConvertToMBCS <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT ConvertToMBCS(WCHAR* pwsz, CHAR* psz, ULONG cbStrLen) <br>{ <br>ASSERT(pwsz &amp;&amp; psz); <br> <br>//Convert the string to MBCS <br>INT iResult = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cbStrLen, NULL, NULL); <br>return iResult ? S_OK : E_FAIL; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// HRESULT ConvertToWCHAR <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>HRESULT ConvertToWCHAR(CHAR* psz, WCHAR* pwsz, ULONG cbStrLen) <br>{ <br>ASSERT(psz &amp;&amp; pwsz); <br> <br>//Convert the string to MBCS <br>INT iResult = MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cbStrLen); <br>return iResult ? S_OK : E_FAIL; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// WCHAR* wcsDuplicate <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>WCHAR* wcsDuplicate(WCHAR* pwsz) <br>{ <br>ASSERT(pwsz); <br>ULONG cLen= wcslen(pwsz); <br> <br>//Allocate space for the string <br>WCHAR* pwszBuffer = NULL; <br>SAFE_ALLOC(pwszBuffer, WCHAR, cLen+1); <br> <br>//Now copy the string <br>wcscpy(pwszBuffer, pwsz); <br> <br>CLEANUP: <br>return pwszBuffer; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL GetQuotedID <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL GetQuotedID( <br>WCHAR* pwszOutBuff,// User's output buffer <br>WCHAR* pwszInBuff,// User's input buffer <br>WCHAR* pwszQuote,// QUOTE Character <br>WCHAR* pwszSeperator    // SEPERATOR Character <br>) <br>{ <br>ASSERT(pwszOutBuff &amp;&amp; pwszInBuff); <br> <br>WCHAR pwsz[MAX_NAME_LEN*2]; <br>WCHAR* pwszItr = pwsz; <br> <br>ULONG cQuoteLen = pwszQuote ? wcslen(pwszQuote) : 0; <br>ULONG cSepLen= pwszSeperator ? wcslen(pwszSeperator) : 0; <br> <br>//Put on front delimeter <br>if(pwszQuote) <br>wcscpy(pwszItr, pwszQuote); <br>pwszItr += cQuoteLen; <br> <br>//Copy from Source to Temp <br>while(*pwszInBuff!=EOL) <br>{ <br>//If we have a seperator char, we need to quote both pieces <br>if(pwszSeperator &amp;&amp; wcsncmp(pwszInBuff, pwszSeperator, cSepLen)==0) <br>{ <br>// "dbo.authors -&gt; "dbo"."authors <br>wcscat(pwszItr, pwszQuote);//Ending Quote <br>wcscat(pwszItr, pwszSeperator);//Seperator <br>wcscat(pwszItr, pwszQuote);//Beginning Quote <br>pwszItr += cQuoteLen + cSepLen + cQuoteLen; <br>} <br>else <br>{ <br>*pwszItr = *pwszInBuff;//Actual Character <br>pwszItr++; <br>} <br> <br>pwszInBuff++; <br>*pwszItr = EOL; <br>} <br> <br>//Put on the Tail delimeter <br>if(pwszQuote) <br>wcscat(pwszItr, pwszQuote); <br> <br>//Give back to the user <br>wcscpy(pwszOutBuff, pwsz); <br>return TRUE; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL MakeAlphaNumeric <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL MakeAlphaNumeric( <br>WCHAR* pwszBuffer,// buffer to translate <br>WCHAR  wchReplace// New character for unallowed <br>) <br>{ <br>ASSERT(pwszBuffer &amp;&amp; wchReplace); <br> <br>while(pwszBuffer[0])  <br>{    <br>// If the character is not a normal alpha numeric value <br>// replace it with an acceptable one <br>if(!iswalnum(pwszBuffer[0])) <br>pwszBuffer[0] = wchReplace; <br> <br>pwszBuffer++; <br>} <br> <br>return TRUE; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// ULONG GetCreateParams <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>ULONG GetCreateParams(WCHAR* pwszCreateParam) <br>{ <br>ASSERT(pwszCreateParam); <br> <br>ULONGulType = 0;   <br> <br>if(wcsstr(pwszCreateParam, L"precision") || wcsstr(pwszCreateParam, L"PRECISION")) <br>ulType |= CP_PRECISION; <br>if(wcsstr(pwszCreateParam, L"scale") || wcsstr(pwszCreateParam, L"SCALE")) <br>ulType |= CP_SCALE; <br>if(wcsstr(pwszCreateParam, L"length") || wcsstr(pwszCreateParam, L"LENGTH")) <br>ulType |= CP_LENGTH; <br>if(wcsstr(pwszCreateParam, L"max length") || wcsstr(pwszCreateParam, L"MAX LENGTH")) <br>ulType |= CP_LENGTH; <br> <br>return ulType; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL IsVariableType <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL IsVariableType(DBTYPE wType) <br>{ <br>//According to OLEDB Spec Appendix A (Variable-Length Data Types) <br>switch(wType)  <br>{ <br>case DBTYPE_STR: <br>case DBTYPE_WSTR: <br>case DBTYPE_BYTES: <br>return TRUE; <br>} <br>return FALSE; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL IsFixedType <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL IsFixedType(DBTYPE wType) <br>{ <br>return !IsVariableType(wType); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL IsNumericType <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL IsNumericType(DBTYPE wType) <br>{ <br>//According to OLEDB Spec Appendix A (Variable-Length Data Types) <br>switch(wType)  <br>{ <br>case DBTYPE_I1: <br>case DBTYPE_I2: <br>case DBTYPE_I4: <br>case DBTYPE_I8: <br>case DBTYPE_UI1: <br>case DBTYPE_UI2: <br>case DBTYPE_UI4: <br>case DBTYPE_UI8: <br>case DBTYPE_R4: <br>case DBTYPE_R8: <br>case DBTYPE_CY: <br>case DBTYPE_DECIMAL: <br>case DBTYPE_NUMERIC: <br>return TRUE; <br>} <br>return FALSE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// WCHAR* GetDBTypeName <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>WCHAR* GetDBTypeName(DBTYPE wType) <br>{ <br>// Do a table look-up on the type <br>for(ULONG i=0; i&lt;NUMELE(rgDBTypes); i++) <br>{ <br>if(wType == rgDBTypes[i].wType)  <br>return rgDBTypes[i].pwszTypeName; <br>} <br> <br>ASSERT(!"Type not in rgSqlType list"); <br>return NULL; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// BOOL GetPromotedType <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>BOOL GetPromotedType(DBTYPE* pwType) <br>{ <br>ASSERT(pwType); <br> <br>switch(*pwType)  <br>{ <br> <br>// Integer family <br>case DBTYPE_BOOL: <br>*pwType = DBTYPE_I1; <br>break; <br> <br>case DBTYPE_I1: <br>case DBTYPE_UI1: <br>*pwType = DBTYPE_I2; <br>break; <br> <br>case DBTYPE_I2: <br>case DBTYPE_UI2: <br>*pwType = DBTYPE_I4; <br>break; <br> <br>case DBTYPE_I4: <br>case DBTYPE_UI4: <br>case DBTYPE_CY: <br>*pwType = DBTYPE_I8; <br>break; <br> <br>case DBTYPE_I8: <br>case DBTYPE_UI8: <br>*pwType = DBTYPE_NUMERIC; <br>break; <br> <br> <br>// Floating-point type family.  FLOAT and DOUBLE actually <br>// have the same precision, so do a mutual promotion (that <br>// is, allow FLOAT to become DOUBLE and DOUBLE to become <br>// FLOAT) before going to CHAR. <br>// <br>case DBTYPE_R4: <br>*pwType = DBTYPE_R8; <br>break; <br> <br>// Fixed-point exact numerics. Ordering of the two types <br>// is unimportant--for our purposes they have exactly the <br>// same semantics.   <br>// <br>case DBTYPE_NUMERIC: <br>*pwType = DBTYPE_DECIMAL; <br>break; <br> <br>case DBTYPE_DECIMAL: <br>*pwType = DBTYPE_R8; <br>break; <br> <br> <br>// Binary types <br>case DBTYPE_BYTES: <br>*pwType = DBTYPE_STR; <br>break; <br> <br>// Date/Time family <br>case DBTYPE_DATE: <br>case DBTYPE_DBTIME: <br>case DBTYPE_DBDATE: <br>*pwType = DBTYPE_DBTIMESTAMP; <br>break; <br> <br>case DBTYPE_R8: <br>case DBTYPE_DBTIMESTAMP: <br>*pwType = DBTYPE_BYTES; <br>break; <br> <br>//we don't support any other types <br>default: <br>ASSERT(0); <br>return FALSE; <br>} <br> <br>return TRUE; <br>} <br> <br> <br> <br>/////////////////////////////////////////////////////////////// <br>// BOOL FreeBindings <br>// <br>/////////////////////////////////////////////////////////////// <br>BOOL FreeBindings(ULONG cBindings, DBBINDING* rgBindings) <br>{ <br>//Need to walk the array and free any pObject structures <br>for(ULONG i=0; i&lt;cBindings; i++) <br>SAFE_FREE(rgBindings[i].pObject); <br> <br>//Now we can free the outer struct <br>SAFE_FREE(rgBindings); <br>return TRUE; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////// <br>// Static Strings Messages <br>// <br>/////////////////////////////////////////////////////////////// <br> <br>extern WCHAR wsz_ERROR[]= L"OLEDB TableCopy - Error"; <br>extern WCHAR wsz_SUCCESS[]= L"OLEDB TableCopy - Success"; <br>extern WCHAR wsz_WARNING[]= L"OLEDB TableCopy - Warning"; <br>extern WCHAR wsz_CANCEL[]= L"OLEDB TableCopy - Cancel"; <br>extern WCHAR wsz_ERRORINFO[]= L"OLEDB TableCopy - IErrorInfo"; <br>  <br>//Copying Status <br>extern WCHAR wsz_COPYING[] = L"Copying records"; <br>extern WCHAR wsz_COPIED_RECORDS[]= L"%lu records copied"; <br>extern WCHAR wsz_COPY_SUCCESS[]= L"Copy succeeded, %lu records copied!"; <br>extern WCHAR wsz_COPY_FAILURE[]= L"Copy failed!"; <br>extern WCHAR wsz_CANCEL_OP[]= L"Do you want to cancel?"; <br> <br>//Tables <br>extern WCHAR wsz_CREATE_TABLE[]= L"CREATE TABLE "; <br>extern WCHAR wsz_DROP_TABLE_[]= L"DROP TABLE %s "; <br>extern WCHAR wsz_ASK_DROP_TABLE_[] = L"Table %s already exists.  Would you like to drop it?"; <br>extern WCHAR wsz_SAME_TABLE_NAME[] = L"Target table name must be different on the same DataSource"; <br> <br>//Indexes <br>extern WCHAR wsz_CREATE_INDEX_[]= L"CREATE%sINDEX "; <br>extern WCHAR wsz_UNIQUE_INDEX[]= L" UNIQUE "; <br>extern WCHAR wsz_INDEX_DESC[] = L" DESC "; <br>extern WCHAR wsz_INDEX_FAILED_[]= L"INDEX %s failed to be created.  Would you like to Continue?"; <br> <br>//Columns <br>extern WCHAR wsz_TYPE_FORMAT_[]= L"%-20s \t%-20s \t[%s]"; <br>extern WCHAR wsz_COLUMN_FORMAT_[]= L"%-20s \t[%s]"; <br>extern WCHAR wsz_NO_TYPE_MATCH_[]= L"Target Data type not found for %s type"; <br>extern WCHAR wsz_NO_TYPE_FOUND_[]= L"Source Data type not found for %s type"; <br> <br>extern WCHAR wsz_CONNECT_STRING_[]= L"DSN=%s, UID=%s, PWD=%s, (%s %s)"; <br>extern WCHAR wsz_NOT_CONNECTED[]= L"Press Connect to establish a connection"; <br>extern WCHAR wsz_FROM_TABLE_DSN_[]= L"From: %s in %s"; <br>extern WCHAR wsz_TO_TABLE_DSN_[]= L"To: %s in %s"; <br> <br>extern WCHAR wsz_PROVIDER_STRING_[]= L"%s %s %s"; <br>extern WCHAR wsz_NO_PROVIDER[]= L""; <br> <br>extern WCHAR wsz_INVALID_VALUE_[]= L"Invalid Value '%s' specified.  Please specify a value &gt;= %lu and &lt;= %lu."; <br>extern WCHAR wsz_READONLY_DATASOURCE_[]= L"Datasource %s is read only and not valid as a target."; <br> <br>//Query <br>extern WCHAR wsz_SHOW_SQL_TITLE[]= L"OLEDB TableCopy - ICommand::Execute Query"; <br>extern WCHAR wsz_SHOW_SQL_[]= L"DSN = %s\n\nSQL = %s"; <br>extern WCHAR wsz_SELECT[]= L" SELECT "; <br>extern WCHAR wsz_FROM[]= L" FROM "; <br>extern WCHAR wsz_BOGUS_WHERE[]= L" WHERE 0 = 1"; <br>extern WCHAR wsz_INSERT_INTO[]= L"INSERT INTO "; <br>extern WCHAR wsz_VALUES_CLAUSE[]= L" ) VALUES ( "; <br>extern WCHAR wsz_PARAM[]= L"?"; <br>extern WCHAR wsz_PRIMARY_KEY[]= L" PRIMARY KEY"; <br> <br>//General String Values <br>extern WCHAR wsz_COMMA[]= L", "; <br>extern WCHAR wsz_LPAREN[]= L" ( "; <br>extern WCHAR wsz_RPAREN[]= L" ) "; <br>extern WCHAR wsz_SPACE[]= L" "; </code></pre>
<p>&nbsp;</p></body>
</HTML>
