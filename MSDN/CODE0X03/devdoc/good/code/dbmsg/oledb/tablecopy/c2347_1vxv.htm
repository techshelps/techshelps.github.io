<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LIST.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2353"></a>LIST.H</h2>
<pre><code>//----------------------------------------------------------------------------- <br>// Microsoft OLE DB TABLECOPY Sample <br>// Copyright (C) 1996 By Microsoft Corporation. <br>// <br>// @doc <br>// <br>// @module LIST.H <br>// <br>//----------------------------------------------------------------------------- <br>#ifndef _LIST_H_ <br>#define _LIST_H_ <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Includes <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>#include "winmain.h" <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// Defines <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>#define POSITION CNode&lt;TYPE&gt;* <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CNode <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; class CNode <br>{ <br>public: <br>// constructors <br>CNode(TYPE val, CNode* pPrevNode, CNode* pNextNode); <br> <br>// members <br>TYPE     m_data;       // element data <br>CNode*   m_pNextNode;  // next CNode <br>CNode*   m_pPrevNode;  // prev CNode <br>}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CNode::CNode <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; CNode&lt;TYPE&gt;::CNode(TYPE data, CNode&lt;TYPE&gt;* pPrevNode, CNode&lt;TYPE&gt;* pNextNode) <br>{ <br>  //Constructor <br>  m_data = data; <br>  m_pPrevNode = pPrevNode; <br>  m_pNextNode = pNextNode; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; class CList <br>{ <br>  public: <br> <br>//constructors <br>CList(); <br>virtual ~CList(); <br> <br>//members <br> <br>//list modifying operations <br>virtual POSITIONAddHead(TYPE element);// Add to Head <br>virtual POSITIONAddTail(TYPE element);// Add to Tail <br> <br>virtual POSITIONInsertBefore(POSITION position, TYPE newdata);// Add before position <br>virtual POSITIONInsertAfter(POSITION position, TYPE newdata);// Add after m_pItr <br> <br>virtual TYPERemoveHead();// Remove from Head <br>virtual TYPERemoveTail();// Remove from Tail <br>virtual voidRemoveAt(POSITION position);// RemoveAt position <br>virtual voidRemoveAll();// Remove all elements <br> <br>//Seeking operations <br>virtual POSITIONFind(TYPE element);        // Find element <br> <br>//Peek operations <br>virtual TYPEGetHead();// Head element <br>virtual TYPEGetTail();// Tail element <br>virtual TYPEGetNext(POSITION position);// Next element <br>virtual TYPEGetPrev(POSITION position);// Prev element <br> <br>//informational operations <br>virtual BOOLIsEmpty();// IsEmpty <br>virtual ULONGGetCount();// m_ulLengthgth of CList <br> <br>//data <br>CNode&lt;TYPE&gt;*  m_pHeadNode;// Head of CList <br>CNode&lt;TYPE&gt;*  m_pTailNode;// Tail of CList <br> <br>ULONGm_ulLength;// m_ulLengthgth of CList <br>}; <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::CList <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; CList&lt;TYPE&gt;::CList() <br>{ <br>//constructor <br>m_pHeadNode = NULL; <br>m_pTailNode = NULL; <br>m_ulLength = 0; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::~CList <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; CList&lt;TYPE&gt;::~CList()  <br>{ <br>//Remove all elements <br>RemoveAll(); <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::AddHead <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; POSITION CList&lt;TYPE&gt;::AddHead(TYPE element)  <br>{ <br>//Add to the Head of the CList, (stack) <br>CNode&lt;TYPE&gt;* pHeadNode = new CNode&lt;TYPE&gt;(element, NULL, m_pHeadNode); <br>ASSERT(pHeadNode); <br> <br>//If there was a list hook the head-&gt;prev to the new head <br>if(m_pHeadNode)  <br>  m_pHeadNode-&gt;m_pPrevNode = pHeadNode; <br> <br>//If there isn't a tail element, hook it to the head <br>if(!m_pTailNode) <br>  m_pTailNode = pHeadNode; <br> <br>m_pHeadNode = pHeadNode; <br>m_ulLength++; <br>return m_pHeadNode; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::AddTail <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; POSITION CList&lt;TYPE&gt;::AddTail(TYPE element)  <br>{ <br>//Add to the m_pTailNode of the CList <br>CNode&lt;TYPE&gt;* pTailNode = new CNode&lt;TYPE&gt;(element, m_pTailNode, 0); <br>ASSERT(pTailNode); <br> <br>//if previously empty <br>if(!m_pHeadNode) <br>m_pHeadNode = pTailNode; <br>else <br>m_pTailNode-&gt;m_pNextNode = pTailNode; <br> <br>m_pTailNode = pTailNode; <br>m_ulLength++; <br>return m_pTailNode; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::GetHead <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; inline TYPE CList&lt;TYPE&gt;::GetHead()  <br>{ <br>//return Head element value <br>ASSERT(m_pHeadNode); <br>return m_pHeadNode-&gt;m_data; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::AddTail <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; inline TYPE CList&lt;TYPE&gt;::GetTail()  <br>{ <br>// return Tail element value <br>ASSERT(m_pTailNode); <br>return m_pTailNode-&gt;m_data; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::GetNext <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; inline TYPE CList&lt;TYPE&gt;::GetNext(POSITION position)  <br>{ <br>ASSERT(position); <br> <br>// return the next element <br>return position-&gt;m_pNextNode-&gt;m_data; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::GetPrev <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; inline TYPE CList&lt;TYPE&gt;::GetPrev(POSITION position)  <br>{ <br>ASSERT(position); <br> <br>// return the prev element <br>return position-&gt;m_pPrevNode-&gt;m_data; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::Find <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; POSITION CList&lt;TYPE&gt;::Find(TYPE element)  <br>{ <br>//return pointer to found element <br>for(CNode&lt;TYPE&gt;* p = m_pHeadNode; p; p = p-&gt;m_pNextNode) <br>  if(p-&gt;m_data == element) <br>return p;   // return position to found CNode <br> <br>return NULL;  // return NULL if not found <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::IsEmpty <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; inline BOOL CList&lt;TYPE&gt;::IsEmpty()  <br>{ <br>// returns TRUE if Empty <br>return m_ulLength == 0; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::RemoveHead <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; TYPE CList&lt;TYPE&gt;::RemoveHead()  <br>{ <br>//Remove and return from the Head of the List <br>ASSERT(m_pHeadNode); <br> <br>CNode&lt;TYPE&gt;* pHeadNode = m_pHeadNode;// pointer to the Removed node <br>TYPE element = GetHead();//make a copy, before deleteing <br> <br>m_pHeadNode = pHeadNode-&gt;m_pNextNode;// reroute Head to exclude the first element <br>if(m_pHeadNode) <br>m_pHeadNode-&gt;m_pPrevNode = NULL; <br>else <br>m_pTailNode = NULL; <br> <br>m_ulLength--; <br>delete pHeadNode;// delete head <br>return element; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::RemoveTail <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; TYPE CList&lt;TYPE&gt;::RemoveTail()  <br>{ <br>//Remove and return from the m_pTailNode of the CList <br>ASSERT(m_pTailNode); <br> <br>CNode&lt;TYPE&gt;* pTailNode = m_pTailNode-&gt;m_pPrevNode; <br>TYPE element = GetTail();  //make a copy before deleteing <br> <br>m_pTailNode = pTailNode; <br>if(m_pTailNode) <br>m_pTailNode-&gt;m_pNextNode = NULL; <br>else <br>m_pHeadNode = NULL; <br> <br>m_ulLength--; <br>delete m_pTailNode; <br>return element; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::RemoveAt <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; void CList&lt;TYPE&gt;::RemoveAt(POSITION position) <br>{ <br>//Remove CList[position] <br>ASSERT(position); <br> <br>CNode&lt;TYPE&gt;* pNode = position; <br> <br>// If removing the head <br>if (pNode == m_pHeadNode) <br>m_pHeadNode = pNode-&gt;m_pNextNode; <br>else <br>pNode-&gt;m_pPrevNode-&gt;m_pNextNode = pNode-&gt;m_pNextNode; <br> <br>//If removing the tail <br>if (pNode == m_pTailNode) <br>m_pTailNode = pNode-&gt;m_pPrevNode; <br>else <br>pNode-&gt;m_pNextNode-&gt;m_pPrevNode = pNode-&gt;m_pPrevNode; <br> <br>m_ulLength--; <br>delete pNode; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::RemoveAll <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; void CList&lt;TYPE&gt;::RemoveAll()  <br>{ <br>// Remove all items from the CList <br>for (CNode&lt;TYPE&gt;* p = m_pHeadNode; p; p = p-&gt;m_pNextNode)  <br>delete p; <br> <br>m_pHeadNode   = NULL; <br>m_pTailNode   = NULL; <br>m_ulLength    = 0; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::GetCount <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; inline ULONG CList&lt;TYPE&gt;::GetCount()  <br>{ <br>// return the Length <br>return m_ulLength; <br>} <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::InsertBefore <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; POSITION CList&lt;TYPE&gt;::InsertBefore(POSITION position, TYPE element) <br>{ <br>//insert before the position <br>if(position == m_pHeadNode)    // Add before Head <br>  return AddHead(element); <br> <br>//otherwise a little more difficult <br>CNode&lt;TYPE&gt;* pNode = new CNode&lt;TYPE&gt;(element, position-&gt;m_pPrevNode, position); <br> <br>//Create the new node <br>pNode-&gt;m_pNextNode = new CNode&lt;TYPE&gt;(element, position-&gt;m_pPrevNode, position-&gt;m_pNextNode); <br> <br>//Hook up before after nodes to it <br>position-&gt;m_pPrevNode-&gt;m_pNextNode = pNode; <br>position-&gt;m_pPrevNode = pNode; <br> <br>m_ulLength++; <br>return pNode; <br>} <br> <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CList::InsertAfter <br>// <br>///////////////////////////////////////////////////////////////////////////// <br>template &lt;class TYPE&gt; POSITION CList&lt;TYPE&gt;::InsertAfter(POSITION position, TYPE element) <br>{ <br>//insert after the position <br>if(position == m_pTailNode)     // Add after the m_pTailNode <br>  return AddTail(element); <br> <br>//other wise a little more difficult <br>CNode&lt;TYPE&gt;* pNode = new CNode&lt;TYPE&gt;(element, position, position-&gt;m_pNextNode); <br> <br>//Hook up before after nodes to it <br>position-&gt;m_pNextNode-&gt;m_pPrevNode = pNode; <br>position-&gt;m_pNextNode = pNode; <br> <br>m_ulLength++; <br>return pNode; <br>} <br> <br> <br> <br>#endif //_LIST_H_ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
