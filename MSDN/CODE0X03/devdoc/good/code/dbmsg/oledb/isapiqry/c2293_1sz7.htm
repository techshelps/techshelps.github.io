<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCLIENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2293"></a>DOCLIENT.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB ISAPI Sample <br>// Copyight(c) 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc <br>// <br>// @module DOclient.CPP | OLE DB DO client, it connects to the provider,  <br>//                 runs SQL SELECT statement, prints data onto a webpage <br>// <br>// @rev 1 | 06-11-96 | Created <br>// <br> <br> <br>//----------------------------------------------------------------------------- <br>// Includes  <br>//----------------------------------------------------------------------------- <br>#include &lt;afxole.h&gt; <br> <br>#define DBINITCONSTANTS  <br> <br>#include &lt;iostream.h&gt; <br>#include &lt;assert.h&gt; <br>#include &lt;oledb.h&gt; <br>#include &lt;msdasql.h&gt; <br>#include &lt;oledberr.h&gt; <br>#include "DOclient.h"   //Data Objects Client header file <br> <br>#define NUMELEM(p1) (sizeof(p1) / sizeof(p1[0])) <br> <br>//----------------------------------------------------------------------------- <br>// Global Variables <br>//----------------------------------------------------------------------------- <br> <br>IMalloc* g_pIMalloc = NULL;                      //Memory allocator <br> <br> <br> <br>//----------------------------------------------------------------------------------- <br>// ConnectDB  <br>// <br>// @func HRESULT| ConnectDB  | Instantiates Kagera, Initialize OLE DB, Create Session <br>// <br>// @rdesc HRESULT <br>//      @flag E_FAIL  | Failed <br>//      @flag E_NOERROR | Success   <br>//----------------------------------------------------------------------------------- <br>HRESULT ConnectDB  <br>( <br>IDBCreateCommand **ppIDBCreateCommand_out,//@param OUT | Pointer to Create Command <br>LPCSTR pstrDNS,                                 //@param IN  | Login Inforamtion  <br>LPCSTR pstrUserName,                            //@param IN  | Login Inforamtion <br>LPCSTR pstrPassword,                            //@param IN  | Login Inforamtion <br>CHttpServerContext* pCtxt//@param IN  | HTML page context <br>) <br>{ <br>ULONGcVar;     //Utility Variables <br>HRESULThr = ResultFromScode(S_OK); <br>    <br>IDBProperties * pIDBProps    = NULL; // IDBInitialize Object <br>IDBInitialize * pIDBInit    = NULL; // IDBInitialize Object <br>IDBCreateSession *pIDBCreateSession= NULL;// IDBCreateSession <br>IDBCreateCommand *pIDBCreateCommand   = NULL;// IDBCreateCommand <br> <br>DBPROPSETrgPropertySet[1];// Array of property sets <br>DBPROPrgProperties[3];// Array of property values <br> <br> // Strings for OLE DB DO (CHAR &amp; WCHAR) <br>*ppIDBCreateCommand_out=NULL; <br> <br>// Set up the Property Buffer <br>rgPropertySet[0].guidPropertySet=DBPROPSET_DBINIT; <br>rgPropertySet[0].rgProperties=rgProperties; <br>rgPropertySet[0].cProperties=NUMELEM(rgProperties); <br> <br>if( FAILED(hr = SetInitializationData(pstrDNS, pstrUserName, pstrPassword, <br>rgPropertySet, pCtxt)) ) <br>goto error; <br> <br>// Initialize OLE <br>hr = CoInitialize( NULL ); <br>if (FAILED(hr)) <br>{    <br>*pCtxt &lt;&lt; "&lt;p&gt;Ole Failed&lt;/p&gt;"; <br>goto error; <br>} <br>    <br>    // Retrieve the task memory allocator <br>    hr = CoGetMalloc( MEMCTX_TASK, &amp;g_pIMalloc ); <br>    if (FAILED(hr)) <br>{ <br>*pCtxt &lt;&lt; "&lt;p&gt;CoGetMalloc Failed&lt;/p&gt;"; <br>goto error; <br>} <br>     <br>    GUID ProviderClsid  = CLSID_MSDASQL;    <br>// Get IDBProperties Pointer <br>hr = CoCreateInstance( ProviderClsid, NULL,  <br>CLSCTX_INPROC_SERVER, IID_IDBProperties, (LPVOID*)&amp;pIDBProps ); <br>if (FAILED(hr)) <br>{ <br>*pCtxt &lt;&lt; "&lt;p&gt;CoCreateInstance Failed&lt;/p&gt;"; <br>        *pCtxt &lt;&lt; "&lt;p&gt;"&lt;&lt;hr&lt;&lt;"&lt;/p&gt;"; <br>goto error; <br>} <br> <br>// Set DSO init properties. <br>hr = pIDBProps-&gt;SetProperties(NUMELEM(rgPropertySet), rgPropertySet); <br>if (FAILED(hr)) <br>{ <br>*pCtxt &lt;&lt; "&lt;p&gt;Set properties.&lt;/p&gt;"; <br>        *pCtxt &lt;&lt; "&lt;p&gt;"&lt;&lt;hr&lt;&lt;"&lt;/p&gt;"; <br>goto error; <br>} <br> <br>//Get IDBInitialize pointer. <br>hr = pIDBProps-&gt;QueryInterface (IID_IDBInitialize,(LPVOID*)&amp;pIDBInit); <br>if (FAILED(hr)) <br>{ <br>*pCtxt &lt;&lt; "&lt;p&gt;QI for IDBInit failed.&lt;/p&gt;"; <br>        *pCtxt &lt;&lt; "&lt;p&gt;"&lt;&lt;hr&lt;&lt;"&lt;/p&gt;"; <br>goto error; <br>} <br> <br>//Initialize DSO. <br>hr = pIDBInit-&gt;Initialize(); <br>if (FAILED(hr)) <br>{                   <br>PrintErrorInfo (pIDBInit,IID_IDBInitialize,pCtxt); <br>*pCtxt&lt;&lt;"&lt;p&gt;Initialize Failed&lt;/p&gt;"; <br>*pCtxt&lt;&lt;"&lt;h3&gt;Check your login parameters&lt;/h3&gt;"; <br>goto error; <br>} <br> <br>// from the DataSource Object get the Session Object <br>hr = pIDBInit-&gt;QueryInterface(IID_IDBCreateSession,  <br> (void**)&amp;pIDBCreateSession ); <br>    if (FAILED(hr)) <br>{ <br>PrintErrorInfo (pIDBInit,IID_IUnknown,pCtxt); <br>*pCtxt&lt;&lt;"&lt;p&gt;QI for Session Object failed &lt;/p&gt;"; <br>goto error; <br>} <br> <br>// From the Session object, get a Command Object <br>hr = pIDBCreateSession-&gt;CreateSession(NULL, IID_IDBCreateCommand, (IUnknown**) ppIDBCreateCommand_out); <br>if (FAILED(hr)) <br>{ <br>PrintErrorInfo (pIDBCreateSession,IID_IDBCreateCommand,pCtxt); <br>*pCtxt&lt;&lt;"&lt;p&gt;Create Session failed !&lt;/p&gt;"; <br>goto error; <br>} <br> <br>error : <br>//Release resources that are not essential anymore.  <br>for (cVar=0; cVar&lt;rgPropertySet[0].cProperties; cVar++) <br>VariantClear(&amp;rgPropertySet[0].rgProperties[cVar].vValue); <br> <br>if( pIDBCreateSession ) <br>pIDBCreateSession-&gt;Release(); <br>if( pIDBProps ) <br>pIDBProps-&gt;Release(); <br>if( pIDBInit ) <br>pIDBInit-&gt;Release(); <br> <br>return hr; <br>}  //ConnectDB <br> <br> <br>//----------------------------------------------------------------------------------- <br>// SetAndExecute <br>// <br>// @func HRESULT| SetAndExecute | Sets the query, executes and sets up the ground <br>//                for data retrieval <br>// <br>// @rdesc HRESULT <br>//      @flag E_FAIL  | Failed <br>//      @flag E_NOERROR | Success   <br>//----------------------------------------------------------------------------------- <br> <br>HRESULT SetAndExecute  <br>( <br>WCHAR *wszSQLCommand,       <br>IDBCreateCommand *pIDBCreateCommand, <br>IRowset**ppIRowset_out, <br>DBCOLUMNINFO **ppColumnInfo_out,    <br>WCHAR **ppStringBuffer_out, <br>ULONG *pcCol,               <br>DBBINDING **pprgBind,            <br>ULONG *pcBind,              <br>HACCESSOR *phAccessor,          <br>ULONG *pcbMaxRowSize,       <br>CHttpServerContext*pCtxt           <br>) <br>{ <br>HRESULThr = S_OK; <br> <br>//Column Info Variables <br>ULONGcCol; <br>DBCOLUMNINFO *pColumnInfo; <br>WCHAR*pStringBuffer;                    //It is needed for printing column names <br>ULONG               cBind; <br>HACCESSOR           hAccessor= NULL; <br>IAccessor*pIAccessor= NULL; <br>IColumnsInfo*pIColumnsInfo= NULL; <br>ICommandText *      pICommandText       = NULL;   // <br>IRowset *           pIRowset            = NULL;   //   <br>ULONG               cbMaxRowSize; <br> <br> <br>    <br> hr = pIDBCreateCommand-&gt;CreateCommand(NULL,IID_ICommandText,(IUnknown**)&amp;pICommandText); <br>if (FAILED(hr)) <br>    { <br>PrintErrorInfo (pIDBCreateCommand,IID_ICommand,pCtxt);   //????? <br>*pCtxt &lt;&lt; "&lt;h3&gt;ERROR : Create Command Text Failed&lt;/h3&gt;"; <br>goto error; <br>} <br>else <br>{ <br>hr = pICommandText-&gt;SetCommandText (DBGUID_DBSQL,wszSQLCommand);   <br>if (FAILED (hr)) <br>{ <br>PrintErrorInfo (pIDBCreateCommand,IID_ICommandText,pCtxt);    <br>*pCtxt &lt;&lt;"&lt;h3&gt; ERROR : Could not set command &lt;/h3&gt;"; <br>goto error; <br>} <br>}  <br> <br>//Execute Query <br>hr = pICommandText-&gt;Execute ( <br>NULL, <br>IID_IRowset, <br>NULL, <br>NULL, <br>(IUnknown**)&amp;pIRowset); <br>   <br>if (FAILED(hr)) <br>{ <br>PrintErrorInfo (pICommandText,IID_ICommandText,pCtxt);  <br>*pCtxt&lt;&lt;"&lt;h3&gt;ERROR : Execution failed, Check your SQL statement.&lt;/h3&gt;"; <br>goto error; <br>} <br> <br>//Get column Info <br>hr = pIRowset-&gt;QueryInterface(IID_IColumnsInfo,(void **) &amp;pIColumnsInfo); <br>if (FAILED(hr))  <br>{ <br>PrintErrorInfo (pIRowset,IID_IRowset,pCtxt);  <br>goto error; <br>} <br>    <br>hr = pIColumnsInfo-&gt;GetColumnInfo(&amp;cCol,&amp;pColumnInfo,&amp;pStringBuffer); <br>if (FAILED(hr))  <br>{ <br>PrintErrorInfo (pIColumnsInfo,IID_IRowset,pCtxt);  <br>goto error; <br>} <br> <br> <br>//Allocate array of Bindings <br>(*pprgBind) = new DBBINDING [cCol]; <br>if (*pprgBind==NULL) <br>{ <br>*pCtxt &lt;&lt; "&lt;p&gt;Could not allocate required number of columns.\n&lt;p&gt;"; <br>*pCtxt &lt;&lt; "&lt;p&gt;Out of memory.\n&lt;p&gt;"; <br>goto error; <br>} <br> <br>if (cCol==0) <br>{ <br>*pCtxt &lt;&lt; "&lt;p&gt;No Data (no columns found). \n&lt;p&gt;"; <br>goto error; <br>} <br> <br>hr = SetupBindings(cCol,pColumnInfo,*pprgBind,&amp;cBind,&amp;cbMaxRowSize); <br>if (FAILED(hr)) <br>{ <br>*pCtxt&lt;&lt;"&lt;h3&gt;ERROR : Could not setup bindings&lt;/h3&gt;"; <br>goto error; <br>} <br> <br>  // Get an accessor for our bindings from the rowset, via IAccessor  <br>hr = pIRowset-&gt;QueryInterface( IID_IAccessor, (void**)&amp;pIAccessor ); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErrorInfo (pIRowset,IID_IRowset,pCtxt); <br>goto error; <br>} <br> <br>hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA,  <br>cBind,  <br>*pprgBind,  <br>0, <br>&amp;hAccessor, <br>NULL); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErrorInfo (pIAccessor,IID_IAccessor,pCtxt); <br>goto error; <br>} <br> <br> <br>//Assign out parameters <br>error : <br>if( SUCCEEDED(hr) ) <br>{ <br>*ppIRowset_out = pIRowset; <br>pIRowset = NULL; <br>*ppColumnInfo_out = pColumnInfo; <br>pColumnInfo = NULL; <br>*ppStringBuffer_out = pStringBuffer; <br>pStringBuffer = NULL; <br>*pcCol = cCol; <br>*pcBind = cBind; <br>*phAccessor = hAccessor; <br>*pcbMaxRowSize  = cbMaxRowSize; <br>} <br>else  <br>{ <br>*ppIRowset_out = NULL; <br>*ppColumnInfo_out = NULL; <br>*ppStringBuffer_out = NULL; <br>*pcCol = 0; <br>*pcBind = 0; <br>*phAccessor = NULL; <br>*pcbMaxRowSize  = 0; <br>} <br> <br>if( pStringBuffer ) <br>g_pIMalloc-&gt;Free(pStringBuffer); <br>if( pIRowset ) <br>pIRowset-&gt;Release(); <br>if( pIColumnsInfo ) <br>pIColumnsInfo-&gt;Release(); <br>if( pIAccessor ) <br>    pIAccessor-&gt;Release(); <br>if( pICommandText ) <br>pICommandText-&gt;Release(); <br>if( pIDBCreateCommand ) <br>pIDBCreateCommand-&gt;Release(); <br> <br>return hr; <br>} //Set And Execute <br> <br> <br>//----------------------------------------------------------------------------------- <br>// GetAndWrite <br>// <br>// @func HRESULT| GetAndWrite | Gets data from the rowset. <br>// <br>// @rdesc HRESULT <br>//      @flag E_FAIL  | Failed <br>//      @flag E_NOERROR | Success   <br>//----------------------------------------------------------------------------------- <br>HRESULT GetAndWrite <br>( <br>IRowset*pIRowset,                   //@param IN | Pointer to set of rows  <br>ULONG   cMaxRowSize,//@param IN | MaxRowSize <br>    HACCESSOR   hAccessor,//@param IN | Accessor Handle <br>    DBBINDING*rgBind,  //@param IN | Array of bindings <br>    ULONGcBind,  //@param IN | Number of bindings <br>    DBCOLUMNINFO*pColumnInfo,//@param IN | Points to an array of DBCOLUMNIFO structures <br>    ULONGcCol,//@param IN | Number of columns <br>CHttpServerContext* pCtxt//@param IN | Output place <br>    ) <br> <br>{ <br>ULONG cRowsObtained;   // Number of rows obtained <br>ULONGiRow;   // Row Count <br>BYTE*pRowData = NULL;   // Memory for Data <br>HROW rghRows[NUMROWS_CHUNK];    // Row Handles <br>HROW*pRows = &amp;rghRows[0];   // Pointer to the Row Handles <br>HRESULT hr=S_OK;   // HRESULT <br> <br>ULONG   ulCount;                   //Counter <br>    CHAR    szBuffer[MAXBUFLEN+1]; <br> <br>// Asserts <br>assert(pIRowset != NULL); <br>    assert(rgBind != NULL); <br>    assert(pColumnInfo  != NULL); <br> <br> <br>// Create a buffer for row data, big enough to hold the biggest row <br>pRowData = (BYTE *) malloc( cMaxRowSize ); <br>if (!pRowData) <br>goto error; <br> <br>    //Initialize table output <br>*pCtxt &lt;&lt; "&lt;CENTER&gt;\n"; <br>    *pCtxt &lt;&lt; "&lt;table&gt;\n"; <br>    *pCtxt &lt;&lt; "&lt;TABLE BORDER&gt;\n"; <br>*pCtxt &lt;&lt; "&lt;caption&gt; &lt;h3&gt; The data you requested: &lt;h3&gt; &lt;/caption&gt;\n"; <br>    <br>    //Print Column Names <br>*pCtxt &lt;&lt; "&lt;TR&gt;"; <br>    for (ulCount=0;ulCount&lt;cCol;ulCount++) <br>    { <br>WideCharToMultiByte(CP_ACP, 0, pColumnInfo[ulCount].pwszName, -1, szBuffer, MAXBUFLEN+1, NULL, NULL); <br>*pCtxt &lt;&lt; "&lt;TH&gt;&lt;B&gt;"&lt;&lt;szBuffer&lt;&lt;"&lt;/B&gt;&lt;/TH&gt;"; <br>    } <br>    *pCtxt &lt;&lt; "&lt;/TR&gt;"; <br> <br> <br>    // Process all the rows, NUMROWS_CHUNK rows at a time <br>while (1) <br>{ <br>hr = pIRowset-&gt;GetNextRows( <br>0,// cbChapter <br>0,// cRowsToSkip <br>NUMROWS_CHUNK,// cRowsDesired <br>&amp;cRowsObtained,// cRowsObtained <br>&amp;pRows );// filled in w/ row handles <br> <br>if (FAILED(hr)) <br>{   <br>PrintErrorInfo (pIRowset,IID_IRowset,pCtxt); <br>goto error; <br>} <br> <br>// All done, no more rows left to get <br>if ( cRowsObtained == 0 ) <br>break; <br> <br>// Loop over rows obtained, getting data for each <br>for ( iRow=0; iRow &lt; cRowsObtained; iRow++ ) <br>{ <br>hr = pIRowset-&gt;GetData( <br>rghRows[iRow], <br>hAccessor, <br>pRowData ); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErrorInfo (pIRowset,IID_IRowset,pCtxt); <br>goto error; <br>} <br> <br> <br>// Print to web page <br>*pCtxt &lt;&lt;"&lt;tr&gt;\n"; <br>            DumpRow( rgBind, cBind,pRowData,pCtxt); <br>            *pCtxt &lt;&lt;"&lt;/tr&gt;\n"; <br>} //for <br> <br> <br>// Release row handles <br>hr = pIRowset-&gt;ReleaseRows( cRowsObtained, rghRows, NULL, NULL, NULL ); <br> <br>if (FAILED(hr)) <br>{ <br>PrintErrorInfo (pIRowset,IID_IRowset,pCtxt); <br>goto error; <br>} <br> <br>}// end while <br>*pCtxt &lt;&lt; "&lt;/table&gt;";   //End of table (no more data) <br> <br>error: <br>if( pRowData ) <br>free( pRowData ); <br>     <br>return hr; <br>} //GetAndWrite <br> <br>//----------------------------------------------------------------------------------- <br>// FreeEnvironment <br>// <br>// @func void| FreeEnvironment | Deallocates resources <br>// <br>// @rdesc NONE <br>//----------------------------------------------------------------------------------- <br>void FreeEnvironment  <br>( <br>IRowset*pIRowset,                   //@param IN | Pointer to set of rows  <br>HACCESSOR   hAccessor,//@param IN | Accessor Handle <br>DBCOLUMNINFO*pColumnInfo, //@param IN | DBCOLUMNINFO array pointer  <br>WCHAR * pStringBuffer                    //@param IN | String Buffer contining the info about columns <br>) <br>{ <br>HRESULT hr; <br>IAccessor*pIAccessor = NULL;// Pointer to an Accessor <br> <br>// Tell the rowset object it can release the accessor, via IAccessor <br>if  (pIRowset) <br>hr = pIRowset-&gt;QueryInterface( IID_IAccessor, (void**)&amp;pIAccessor ); <br>else  <br>goto error; <br> <br>if (FAILED(hr)) <br>goto error; <br> <br>hr = pIAccessor-&gt;ReleaseAccessor( hAccessor,NULL ); <br>if (FAILED(hr)) <br>goto error; <br> <br>error : <br>if( pIAccessor ) <br>    pIAccessor-&gt;Release(); <br>if( pIRowset ) <br>pIRowset-&gt;Release(); <br> <br>if (pStringBuffer!=NULL)  <br>{ <br>g_pIMalloc-&gt;Free(pStringBuffer);  <br>pStringBuffer = NULL; <br>} <br> <br>if (pColumnInfo!=NULL)  <br>{ <br>g_pIMalloc-&gt;Free(pColumnInfo);  <br>pColumnInfo = NULL; <br>} <br> <br>if (g_pIMalloc)  <br>g_pIMalloc-&gt;Release(); <br> <br>SetErrorInfo(0, NULL); <br> <br>CoUninitialize();     <br> <br>} //Free Environment <br> <br> <br>//----------------------------------------------------------------------------------- <br>//Functions that are not called directly by MainFunction but are used by  <br>//functions described above. <br>//----------------------------------------------------------------------------------- <br> <br>HRESULT SetInitializationData  <br>( <br>LPCSTR pstrDNS,//@param IN  | DNS Name <br>LPCSTR pstrUserName,//@param IN  | User Name <br>LPCSTR pstrPassword,//@param IN  | Passwd <br>DBPROPSET rgPropertySet[],//@param OUT | Array of propery sets (only one) <br>CHttpServerContext* pCtxt//@param IN  | Web page context <br>) <br>{ <br>HRESULT hr = ResultFromScode(S_OK); <br> <br>    CHARszDBName[MAXBUFLEN+1];// DSN <br>CHARszUserName[MAXBUFLEN+1];    // User Name   <br>CHARszPassword[MAXBUFLEN+1];        // Password <br> <br>WCHARwszDBName[MAXBUFLEN+1];// DSN String (WCHAR) <br>WCHARwszUserName[MAXBUFLEN+1];// User Name  (WCHAR) <br>WCHARwszPassword[MAXBUFLEN+1];// Password   (WCHAR) <br> <br>strcpy (szDBName,pstrDNS); <br>strcpy (szUserName,pstrUserName); <br>strcpy (szPassword,pstrPassword); <br> <br>//Reset the out parameter(s) <br>//***************************************************************** <br>// Identify Property Set <br>// Initialize property values <br>for(ULONG ul=0; ul&lt;rgPropertySet[0].cProperties; ul++) <br>{ <br>VariantInit(&amp;rgPropertySet[0].rgProperties[ul].vValue); <br> <br>// Set Common structure values <br>rgPropertySet[0].rgProperties[ul].dwOptions=DBPROPOPTIONS_REQUIRED; <br>rgPropertySet[0].rgProperties[ul].colid=DB_NULLID; <br>rgPropertySet[0].rgProperties[ul].vValue.vt=VT_BSTR; <br>} <br> <br>// Fill in Data Source <br>rgPropertySet[0].rgProperties[0].dwPropertyID=DBPROP_INIT_DATASOURCE; <br>if (0==MultiByteToWideChar(CP_ACP, 0, szDBName, -1, wszDBName, MAXBUFLEN+1)) <br>{ <br>*pCtxt &lt;&lt; "MultiByteToWideChar szDBName, wszDBName FAILED"; <br>hr = E_FAIL; <br>goto error; <br>} <br>rgPropertySet[0].rgProperties[0].vValue.bstrVal=SysAllocString(wszDBName); <br>if (rgPropertySet[0].rgProperties[0].vValue.bstrVal==NULL) <br>{ <br>*pCtxt &lt;&lt; "Error during string allocation #0 (ConnectDB)\n"; <br> hr = E_OUTOFMEMORY; <br> goto error; <br>} <br> <br>// Fill in User Name <br>rgPropertySet[0].rgProperties[1].dwPropertyID=DBPROP_AUTH_USERID; <br>if (0==MultiByteToWideChar(CP_ACP, 0, szUserName, -1, wszUserName, MAXBUFLEN+1)) <br>{ <br>*pCtxt &lt;&lt; "MultiByteToWideChar szDBName, wszDBName FAILED"; <br>hr = E_FAIL; <br>goto error; <br>} <br>rgPropertySet[0].rgProperties[1].vValue.bstrVal=SysAllocString(wszUserName); <br>if (rgPropertySet[0].rgProperties[1].vValue.bstrVal==NULL) <br>{ <br>*pCtxt &lt;&lt; "Error during string allocation #1 (ConnectDB)\n"; <br> hr = E_OUTOFMEMORY; <br> goto error; <br>} <br> <br>// Fill in Password <br>rgPropertySet[0].rgProperties[2].dwPropertyID=DBPROP_AUTH_PASSWORD; <br>if (0==MultiByteToWideChar(CP_ACP, 0, szPassword, -1, wszPassword, MAXBUFLEN+1)) <br>{ <br>*pCtxt &lt;&lt; "MultiByteToWideChar szDBName, wszDBName FAILED"; <br>hr = E_FAIL; <br>goto error; <br>} <br>rgPropertySet[0].rgProperties[2].vValue.bstrVal=SysAllocString(wszPassword); <br>if (rgPropertySet[0].rgProperties[2].vValue.bstrVal==NULL) <br>{ <br>*pCtxt &lt;&lt; "Error during string allocation #2(ConnectDB)\n"; <br> hr = E_OUTOFMEMORY; <br> goto error; <br>} <br> <br>error : <br>return hr; <br>} //SetInitializationData <br> <br> <br>//----------------------------------------------------------------------------------- <br>// PrintErrorInfo <br>// <br>// @func void| PrintErrorInfo | Uses error collection data to issue an error. <br>// <br>// @rdesc HRESULT <br>//----------------------------------------------------------------------------------- <br>void PrintErrorInfo  <br>      ( <br>   IUnknown * pBadObject,                   //@param IN | Pointer to the object where error happened <br>   REFIID IID_BadIntereface,                  //@param IN | Interface that caused the error <br>   CHttpServerContext* pCtxt//@param IN | Output place <br>  ) <br>{ <br>HRESULT             hr = S_OK; <br>IErrorInfo *        pErrorInfo= NULL;  <br>IErrorInfo *    pErrorInfoRec= NULL; <br>IErrorRecords *     pErrorRecords= NULL; <br>ISupportErrorInfo * pSupportErrorInfo= NULL; <br>ULONG               i,ulNumErrorRecs; <br>ERRORINFO           ErrorInfo;        <br>BSTRbstrDescriptionOfError = NULL; <br>BSTRbstrSourceOfError = NULL; <br> <br>CHAR                 szBuffer [MAXBUFLEN+1];  //Error Info Buffer <br>DWORD                MYLOCALEID;               <br> <br> <br>MYLOCALEID = GetSystemDefaultLCID(); <br> <br>hr = pBadObject-&gt;QueryInterface (IID_ISupportErrorInfo, <br>            (LPVOID FAR*)&amp;pSupportErrorInfo); <br>    <br>if (SUCCEEDED(hr))  <br>{ <br>hr = pSupportErrorInfo-&gt;InterfaceSupportsErrorInfo(IID_BadIntereface); <br>if( hr == S_OK )  <br>{ <br>//Get Error Object. Return if no object Exists <br>GetErrorInfo (0,&amp;pErrorInfo); <br>if( !pErrorInfo )  <br>goto error; <br> <br>//Get the IErrorRecord interface and get the count of error recs. <br>pErrorInfo-&gt;QueryInterface (IID_IErrorRecords,(LPVOID FAR*)&amp;pErrorRecords); <br>pErrorRecords-&gt;GetRecordCount (&amp;ulNumErrorRecs); <br> <br>//Go through and print messages <br>for (i=0;i&lt;ulNumErrorRecs;i++)  <br>{ <br>pErrorRecords-&gt;GetBasicErrorInfo(i,&amp;ErrorInfo); <br>pErrorRecords-&gt;GetErrorInfo (i,MYLOCALEID,&amp;pErrorInfoRec); <br> <br>hr = pErrorInfoRec-&gt;GetDescription (&amp;bstrDescriptionOfError); <br>if (FAILED(hr)) <br>{    <br>*pCtxt &lt;&lt; "pErrorInfoRec-&gt;GetDescription FAILED!!! \n"; <br>goto error; <br>} <br> <br>hr = pErrorInfoRec-&gt;GetSource (&amp;bstrSourceOfError); <br>if (FAILED(hr)) <br>{ <br>*pCtxt &lt;&lt; "pErrorInfoRec-&gt;GetSource FAILED!!! \n"; <br>goto error; <br>} <br>                <br>        <br>if (0==WideCharToMultiByte(CP_ACP, 0, bstrDescriptionOfError, -1, szBuffer, MAXBUFLEN+1, NULL, NULL)) <br>{ <br>*pCtxt &lt;&lt; "WideChar -&gt; Multi Conversion #1 failed. ERROR in PrintErrorInfo. \n"; <br>goto error; <br>} <br> <br>*pCtxt &lt;&lt; "&lt;p&gt; Error Description : &lt;/p&gt;"; <br>*pCtxt &lt;&lt;"&lt;p&gt;" &lt;&lt; szBuffer&lt;&lt; "&lt;/p&gt;\n"; <br>if (0==WideCharToMultiByte(CP_ACP, 0, bstrSourceOfError, -1, szBuffer, MAXBUFLEN+1, NULL, NULL)) <br>{ <br>*pCtxt &lt;&lt; "WideChar -&gt; Multi Conversion  #2 failed. ERROR in PrintErrorInfo. \n";   <br>goto error; <br>} <br> <br>  *pCtxt &lt;&lt; "&lt;p&gt; Error Source : &lt;/p&gt;"; <br>*pCtxt &lt;&lt;"&lt;p&gt;" &lt;&lt; szBuffer&lt;&lt; "&lt;/p&gt;\n"; <br> <br>        <br>if( bstrDescriptionOfError ) <br>{ <br>SysFreeString (bstrDescriptionOfError); <br>bstrDescriptionOfError = NULL; <br>} <br>if( bstrSourceOfError ) <br>{ <br>SysFreeString (bstrSourceOfError); <br>bstrSourceOfError = NULL; <br>} <br> <br>pErrorInfoRec-&gt;Release(); <br>pErrorInfoRec = NULL; <br>} <br> <br>pErrorInfo-&gt;Release(); <br>pErrorInfo = NULL; <br> <br>pErrorRecords-&gt;Release(); <br>pErrorRecords = NULL; <br>} //S_OK <br>    } //if (SUCCEEDED) <br>  <br>error : <br>if( bstrDescriptionOfError ) <br>SysFreeString (bstrDescriptionOfError); <br>if( bstrSourceOfError ) <br>SysFreeString (bstrSourceOfError); <br>if( pErrorInfo ) <br>pErrorInfo-&gt;Release(); <br>if( pErrorRecords ) <br>pErrorRecords-&gt;Release(); <br>if( pErrorInfoRec ) <br>pErrorInfoRec-&gt;Release(); <br>if( pSupportErrorInfo ) <br>pSupportErrorInfo-&gt;Release(); <br>} //PrintErrorInfo <br> <br>//----------------------------------------------------------------------------------- <br>// SetupBindings <br>// <br>// @func HRESULT| SetupBindings  | Recycle <br>// <br>// @rdesc HRESULT <br>//      @flag E_FAIL  | Failed <br>//      @flag E_NOERROR | Success   <br>//----------------------------------------------------------------------------------- <br>HRESULT SetupBindings <br>( <br>ULONG cCol, <br>DBCOLUMNINFO*pColumnInfo, <br>DBBINDING*rgBind_out, <br>ULONG*pcBind_out, <br>ULONG*pcMaxRowSize_out <br>) <br>{ <br>ULONG dwOffset;// Length of a Row <br>ULONG iCol;// Column Count <br>ULONG iBind;// Binding Index <br> <br>// Asserts <br>    assert(pColumnInfo!= NULL); <br>    assert(rgBind_out != NULL); <br>    assert(pcBind_out != NULL); <br>    assert(pcMaxRowSize_out != NULL); <br> <br>   // Create bindings. <br>// Bind everything as a string just to keep things simple. <br>dwOffset = 0; <br>iBind=0; <br>for (iCol=0; iCol &lt; cCol; iCol++) <br>{ <br>// Binding Structure <br>rgBind_out[iBind].dwPart    = DBPART_VALUE | DBPART_LENGTH | <br>  DBPART_STATUS; <br>rgBind_out[iBind].eParamIO  = DBPARAMIO_OUTPUT; <br>rgBind_out[iBind].iOrdinal  = pColumnInfo[iCol].iOrdinal; <br>rgBind_out[iBind].wType     = DBTYPE_STR; <br>rgBind_out[iBind].pTypeInfo = NULL; <br>rgBind_out[iBind].dwMemOwner = DBMEMOWNER_CLIENTOWNED; <br>rgBind_out[iBind].obValue   = dwOffset + offsetof(COLUMNDATA,bData); <br>rgBind_out[iBind].obLength  = dwOffset + offsetof(COLUMNDATA,dwLength); <br>rgBind_out[iBind].obStatus  = dwOffset + offsetof(COLUMNDATA,wStatus); <br>rgBind_out[iBind].cbMaxLen  = pColumnInfo[iCol].wType == DBTYPE_STR ?  <br>  pColumnInfo[iCol].ulColumnSize + 1 : DEFAULT_CBMAXLENGTH; <br> <br>// LONG DATA hack  <br>if(rgBind_out[iBind].cbMaxLen &gt; MAX_ROW_SIZE) <br>rgBind_out[iBind].cbMaxLen = MAX_ROW_SIZE; <br> <br>dwOffset += rgBind_out[iBind].cbMaxLen + offsetof( COLUMNDATA, bData ); <br>dwOffset = ROUND_UP( dwOffset, COLUMN_ALIGNVAL ); <br>iBind++; <br>}   <br> <br>// Return Values     <br>*pcBind_out   = iBind; <br>*pcMaxRowSize_out = dwOffset; <br> <br>return S_OK; <br>} <br> <br> <br>//----------------------------------------------------------------------------------- <br>// DumpRow <br>// <br>// @func void | DumpRow | Puts data onto the webpage <br>// <br>//----------------------------------------------------------------------------------- <br> <br>void DumpRow <br>( <br>DBBINDING* rgBind,                    //@param  IN | Column bindings <br>    ULONGcBind,                     //@param  IN | Count of bindings <br>    BYTE* pData,                     //@param  IN | Data Pointer <br>CHttpServerContext* pCtxt              //@param  IN | Web Server context <br>) <br>{ <br>ULONG iBind;// Binding Count <br>    COLUMNDATA*pColumn;// Data Structure <br>    CHARszDispBuffer[MAXBUFLEN+1];//Display Buffer <br> <br> <br>// Print each column we're bound to. <br>szDispBuffer[0] = '\0'; <br>for (iBind=0; iBind &lt; cBind; iBind++) <br>{ <br>pColumn = (COLUMNDATA *) (pData + rgBind[iBind].obLength); <br> <br>// Check Status for NULL / OK / CANTCONVERT. <br>switch (pColumn-&gt;wStatus) <br>{ <br>case DBSTATUS_S_ISNULL: <br>strcpy(szDispBuffer, (LPSTR)"&lt;b&gt;NULL&lt;/b&gt;\n"); <br>break; <br>case DBSTATUS_S_OK: <br>            pColumn-&gt;bData[MAXBUFLEN] = '\0';         //Long data problem solved??! <br>            if (NULL==lstrcpy(szDispBuffer, (LPSTR)pColumn-&gt;bData)) <br>*pCtxt &lt;&lt; "lstrcpy ERROR. ";   <br>break; <br>case DBSTATUS_E_CANTCONVERTVALUE: <br>strcpy(szDispBuffer,(LPSTR)"&lt;b&gt;can't convert&lt;/b&gt;\n"); <br>break; <br>default: <br>strcpy(szDispBuffer,(LPSTR)"&lt;b&gt;unknown status&lt;/b&gt;\n"); <br>break; <br>} <br> <br>*pCtxt&lt;&lt;"&lt;td&gt;"&lt;&lt;szDispBuffer&lt;&lt;"&lt;/td&gt;\n"; <br>} <br>       <br>}//DumpRow <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
