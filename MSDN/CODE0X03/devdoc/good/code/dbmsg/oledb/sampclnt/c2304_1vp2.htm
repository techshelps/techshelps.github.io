<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMPCLNT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2306"></a>SAMPCLNT.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Consumer <br>// (C) Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved. <br>// <br>// File name: SAMPCLNT.CPP <br>// <br>//      Implementation file for a simple OLE DB consumer. <br>//      Dump\output routines for SAMPCLNT are in DUMP.CPP <br>//      SAMPCLNT.H is the header file. <br>// <br>//      See OLE DB SDK Guide for information on building and running  <br>//this sample, as well as notes concerning the implementation of  <br>//a simple OLE DB consumer. <br>// <br>// Functions: <br>// <br>//      See SAMPCLNT.H for function prototypes <br>// <br>//  <br>// SampClnt is structured to match the steps required for simple OLE DB data access: <br>//  <br>// DoTests <br>// GetSampprovDataSource <br>//      GetDBSessionFromDataSource <br>//      GetRowsetFromDBSession <br>// GetDataFromRowset <br>// GetColumnsInfo <br>// SetupBindings <br>// CreateAccessor <br>// GetData <br>// CleanupRowset <br>//  <br> <br> <br> <br> <br>#define INITGUID <br>#define DBINITCONSTANTS <br>#include "sampclnt.h" <br> <br> <br>IMalloc* g_pIMalloc = NULL; <br>FILE*    g_fpLogFile = NULL;    // our log file <br> <br> <br> <br> <br>//********************************************************************** <br>//  <br>// main <br>//  <br>// Purpose: <br>// <br>//     Entry point for this program. <br>//  <br>// Parameters: <br>// <br>//     none <br>//      <br>// Return Value: <br>// <br>//     none <br>//  <br>// Comments:       <br>// <br>//     Main does some initializing, then calls DoTests, then cleans up. <br>//     All of the interesting action in this program happens in DoTests. <br>//  <br>//********************************************************************** <br> <br> <br>void main() <br>{ <br>DWORD   dwVersion; <br>HRESULT hr; <br>time_tttime; <br>    BOOL fOleInitialized = FALSE; <br>charch; <br> <br>  g_fpLogFile = fopen( "sampclnt.out", "at"); <br>    if (!g_fpLogFile) <br>    { <br>    DumpErrorMsg( "Warning: cannot open log file sampclnt.out\n" ); <br>        } <br>   <br>  time(&amp;ttime); <br>     <br>    DumpStatusMsg( "\n-------------------------\n\n"); <br>    DumpStatusMsg( "running sampclnt.exe\n%s\n\n", ctime(&amp;ttime) ); <br> <br>dwVersion = OleBuildVersion(); <br>    if (HIWORD(dwVersion) != rmm) <br>{ <br>DumpErrorMsg( "Error: OLE version mismatch. Build version %ld, current version %ld\n", <br>rmm, HIWORD(dwVersion) ); <br>        goto error;     <br>} <br> <br>hr = OleInitialize( NULL ); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorMsg("Error: OleInitialize failed\n"); <br>        goto error; <br>} <br>fOleInitialized = TRUE; <br>      <br>    hr = CoGetMalloc( MEMCTX_TASK, &amp;g_pIMalloc ); <br> if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorMsg("Error: CoGetMalloc failed\n"); <br>        goto error; <br>        } <br>    <br>    hr = DoTests(); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "DoTests"); <br>        goto error; <br>        } <br>     <br>    g_pIMalloc-&gt;Release(); <br>OleUninitialize(); <br> <br>if (g_fpLogFile) <br>    fclose(g_fpLogFile); <br> <br>/* Pause before we quit, in case user ran from an icon, so they can see our messages. */ <br>printf("\n\n&gt;&gt;&gt; Output has gone into 'sampclnt.out'."); <br>printf("\n&gt;&gt;&gt; You may wish to use a wide-column editor to view this file.\n\n"); <br>printf("&lt;press any key to continue&gt;"); <br>ch = _getch(); <br>return; <br>     <br>error: <br>    if (g_pIMalloc) <br>    g_pIMalloc-&gt;Release();     <br>if (fOleInitialized) <br>    OleUninitialize(); <br>if (g_fpLogFile) <br>    fclose(g_fpLogFile); <br> <br>/* Pause before we quit, in case user ran from an icon, so they can see our messages. */ <br>printf("\n\n&gt;&gt;&gt; Output has gone into 'sampclnt.out'."); <br>printf("\n&gt;&gt;&gt; You may wish to use a wide-column editor to view this file.\n\n"); <br>printf("&lt;press any key to continue&gt;"); <br>ch = _getch(); <br> <br>return;     <br>}     <br> <br> <br> <br>//********************************************************************** <br>//   <br>//  DoTests <br>//   <br>//  Purpose: <br>// <br>//     Hooks up to the SAMPPROV OLE DB provider application, asks the provider <br>//     for all data in the CSV file CUSTOMER.CSV, and logs the resulting data  <br>//     to sampclnt.out         <br>//   <br>//  Parameters: <br>//   <br>//  none <br>//       <br>//  Return Value: <br>//   <br>//  S_OK- Success <br>//      E_*- Failure <br>//   <br>//       <br>//  Comments:       <br>//   <br>//     At a high level, an OLE DB data consumer obtains data by  <br>//      <br>//     1. Getting hooked up to a data provider's Data Source object, <br>//        and initializing that object <br>//     2. Getting a DBSession object from the Data Source object <br>//     3. Getting the data from the Rowset object. <br>//      <br>//     DoTests follows these steps by making calls to GetSampprovDataSource, <br>//     GetDBSessionDataSource, and GetDataFromRowset     <br>//   <br>//********************************************************************** <br> <br> <br>HRESULT DoTests <br>( <br>) <br>{ <br>IDBInitialize*    pIDBInitialize = NULL; <br>    IOpenRowset*        pIOpenRowset    = NULL; <br>    IRowset*    pIRowset= NULL; <br>LPWSTR    pwszTableName   = L"customer.csv"; <br>HRESULT    hr; <br> <br> <br>hr = GetSampprovDataSource( &amp;pIDBInitialize ); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "GetSampprovDataSource" ); <br>        goto error; <br>        } <br> <br>    hr = GetDBSessionFromDataSource( pIDBInitialize, &amp;pIOpenRowset ); <br>    if (FAILED(hr)) <br>        { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "GetDBSessionFromDataSource" ); <br>        goto error; <br>        } <br> <br>    pIDBInitialize-&gt;Release(); <br>    pIDBInitialize = NULL;     <br> <br>    hr = GetRowsetFromDBSession( pIOpenRowset, pwszTableName, &amp;pIRowset ); <br>    if (FAILED(hr)) <br>        { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "GetRowsetFromDBCreateSession" ); <br>        goto error; <br>        } <br>         <br>    pIOpenRowset-&gt;Release(); <br>    pIOpenRowset = NULL;     <br> <br>hr = GetDataFromRowset( pIRowset ); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "GetDataFromRowset" ); <br>        goto error; <br>        } <br>    pIRowset-&gt;Release();  <br>    pIRowset = NULL; <br>CoFreeUnusedLibraries(); <br> <br>DumpStatusMsg( "\nDone! "); <br>printf("\n\nFor more data from this run, see the log file sampclnt.out\n" ); <br>return ResultFromScode( S_OK ); <br>     <br>error:     <br>if (pIRowset)  <br>pIRowset-&gt;Release(); <br>    if (pIOpenRowset) <br>        pIOpenRowset-&gt;Release();     <br>    if (pIDBInitialize) <br>    pIDBInitialize-&gt;Release();     <br> <br>return ResultFromScode( hr ); <br>}     <br> <br> <br> <br> <br> <br>//********************************************************************** <br>//   <br>// GetSampprovDataSource <br>//  <br>// Purpose: <br>// <br>//     Calls OLE to find and load the SAMPPROV data provider.  <br>//     Returns an IDBInitialize interface pointer on SAMPPROV's  <br>//     Data Source object. <br>// <br>// Parameters: <br>//  <br>//   IDBInitialize** ppIDBInitialize_out  - out pointer through which to return <br>//         IDBInitialize pointer on data  <br>//            provider's Data Source object  <br>//  <br>// Return Value: <br>//  <br>// S_OK- Success <br>//  E_*    - Failure <br>//      <br>// <br>// Comments:       <br>//  <br>//     The call to CoCreateInstance is hard-coded with SAMPPROV's CLSID. <br>//     The pointer returned through ppIDBInitialize_out has been AddRef'ed, <br>//     it must be Release'd later by the caller. <br>//   <br>//********************************************************************** <br> <br>HRESULT GetSampprovDataSource <br>( <br>IDBInitialize**ppIDBInitialize_out <br>) <br>{ <br>IDBInitialize*pIDBInit = NULL; <br>IDBProperties*pIDBProperties = NULL; <br>DBPROPSETdbPropSet[1]; <br>DBPROPdbProp[1]; <br> <br>HRESULThr; <br> <br> <br>DumpStatusMsg( "Connecting to the SampProv sample data provider...\n" ); <br> <br>assert(ppIDBInitialize_out != NULL); <br> <br>VariantInit(&amp;(dbProp[0].vValue)); <br> <br>// Create an instance of the SampProv sample data provider <br>hr = CoCreateInstance( CLSID_SampProv, NULL, CLSCTX_INPROC_SERVER,  <br>IID_IDBInitialize, (void **)&amp;pIDBInit );  <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "CoCreateInstance" ); <br>        goto error; <br>        } <br> <br>// Initialize this provider with the path to the customer.csv file <br>dbPropSet[0].rgProperties= &amp;dbProp[0]; <br>dbPropSet[0].cProperties= 1; <br>dbPropSet[0].guidPropertySet= DBPROPSET_DBINIT; <br> <br>dbProp[0].dwPropertyID= DBPROP_INIT_DATASOURCE; <br>dbProp[0].dwOptions= DBPROPOPTIONS_REQUIRED; <br>dbProp[0].colid= DB_NULLID; <br>V_VT(&amp;(dbProp[0].vValue))= VT_BSTR; <br>V_BSTR(&amp;(dbProp[0].vValue))= SysAllocString( L"." ); <br>    if ( NULL == V_BSTR(&amp;(dbProp[0].vValue)) ) <br>        { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorMsg( "SysAllocString failed\n" ); <br>        goto error; <br>        } <br> <br>    hr = pIDBInit-&gt;QueryInterface( IID_IDBProperties, (void**)&amp;pIDBProperties); <br>    if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "IDBInitialize::QI for IDBProperties"); <br>        goto error; <br>        } <br> <br>hr = pIDBProperties-&gt;SetProperties( 1, &amp;dbPropSet[0]); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "IDBProperties::SetProperties" ); <br>        goto error; <br>        } <br> <br>hr = pIDBInit-&gt;Initialize(); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "IDBInitialize::Initialize" ); <br>        goto error; <br>        } <br> <br>*ppIDBInitialize_out = pIDBInit; <br> <br>hr = ResultFromScode( S_OK ); <br> <br>error:     <br>    VariantClear( &amp;(dbProp[0].vValue) ); <br> <br>if( pIDBProperties ) <br>pIDBProperties-&gt;Release(); <br> <br>if( FAILED(hr) ) <br>{ <br>if (pIDBInit) <br>    pIDBInit-&gt;Release(); <br>*ppIDBInitialize_out = NULL; <br>} <br> <br>return hr;     <br>} <br> <br> <br> <br> <br>//  ********************************************************************** <br>// <br>// GetDBSessionFromDataSource <br>// <br>// Purpose: <br>//      Calls the provider's Data Source object to get an IOpenRowset interface <br>//      pointer on a DBSession object.   <br>//       <br>// Parameters: <br>//      pIDBInitialize      - pointer to Data Source object <br>//      ppIOpenRowset_out   - out pointer through which to return  <br>//                            IOpenRowset pointer on DBSession object <br>// <br>// Return Value:  <br>// <br>// S_OK- Success <br>//  E_*    - Failure <br>// <br>// <br>// Comments: <br>// <br>//      The interface pointer returned through ppIOpenRowset_out has been  <br>//      AddRef'ed, the caller must Release it later. <br>// <br>//********************************************************************** <br> <br>HRESULT GetDBSessionFromDataSource <br>    ( <br>    IDBInitialize*      pIDBInitialize,      // [in] <br>    IOpenRowset**       ppIOpenRowset_out    // [out] <br>    ) <br>{ <br>    IDBCreateSession*   pIDBCreateSession; <br>    IOpenRowset*        pIOpenRowset; <br>    HRESULT             hr; <br> <br> <br>    DumpStatusMsg( "Getting a DBSession object from the data source object...\n" ); <br>     <br>    assert(pIDBInitialize != NULL); <br>    assert(ppIOpenRowset_out  != NULL ); <br> <br>    hr = pIDBInitialize-&gt;QueryInterface( IID_IDBCreateSession, (void**)&amp;pIDBCreateSession); <br>    if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "IDBInitialize::QI for IDBCreateSession"); <br>        goto error; <br>        } <br>         <br>    hr = pIDBCreateSession-&gt;CreateSession( NULL, IID_IOpenRowset, (IUnknown**)&amp;pIOpenRowset );     <br>    if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "IDBCreateSession::CreateSession"); <br>        goto error; <br>        } <br>     pIDBCreateSession-&gt;Release(); <br>     pIDBCreateSession = NULL; <br>      <br>     // all went well <br>     *ppIOpenRowset_out = pIOpenRowset; <br>     return ResultFromScode( S_OK ); <br>      <br>error: <br>    if (pIDBCreateSession) <br>        pIDBCreateSession-&gt;Release(); <br>         <br>    *ppIOpenRowset_out = NULL;     <br>    return ResultFromScode( hr ); <br>} <br> <br> <br> <br>//********************************************************************** <br>// <br>// GetRowsetFromDBSession <br>// <br>// Purpose: <br>//      Calls the provider's DBSession object to get an IRowset interface <br>//      pointer on a Rowset object.   <br>//       <br>// Parameters: <br>//      pIOpenRowset        - interface pointer on DBSession object <br>//      pwszTableName       - name of "table" (in this case text file) <br>//      ppIRowset_out       - out pointer through which to return  <br>//                            IRowset pointer on Rowset object <br>// <br>// Return Value:  <br>// <br>// S_OK- Success <br>//  E_*    - Failure <br>// <br>// Comments: <br>// <br>//      The interface pointer returned through ppIRowset_out has been  <br>//      AddRef'ed, the caller must Release it later. <br>// <br>///********************************************************************** <br> <br>HRESULT GetRowsetFromDBSession <br>    ( <br>    IOpenRowset*   pIOpenRowset,    // [in] <br>    LPWSTR         pwszTableName,   // [in]  <br>    IRowset**      ppIRowset_out    // [out] <br>    ) <br>{ <br>    DBID            dbcolid; <br>    IRowset*        pIRowset = NULL; <br>    HRESULT         hr; <br> <br>    DumpStatusMsg( "Getting a rowset object from the DBSession object...\n" ); <br>     <br>    assert(pIOpenRowset != NULL); <br>    assert(ppIRowset_out  != NULL ); <br>     <br>    // tell the provider which table to open <br>    dbcolid.eKind           = DBKIND_NAME; <br>    dbcolid.uName.pwszName  = pwszTableName; <br>     <br>    hr = pIOpenRowset-&gt;OpenRowset <br>                        ( <br>                        NULL,                   // pUnkOuter - we are not aggregating <br>                        &amp;dbcolid,               // pTableID -  the table we want <br>NULL,// pIndexID - the index we want <br>                        IID_IRowset,            // riid - interface we want on the rowset object <br>                        0,                      // cProperties - we are niave about props for now <br>                        NULL,                   // prgProperties[] <br>                        (IUnknown**)&amp;pIRowset   // ppRowset <br>                        ); <br>    if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "IOpenRowset::OpenRowset" ); <br>        goto error; <br>        } <br>     <br>    // all went well <br>    *ppIRowset_out = pIRowset; <br>    return ResultFromScode( S_OK ); <br> <br>error: <br>    if (pIRowset) <br>        pIRowset-&gt;Release(); <br>    *ppIRowset_out = NULL;             <br>     <br>    return ResultFromScode( hr ); <br>}     <br> <br> <br>//********************************************************************** <br>//  <br>// GetDataFromRowset <br>//  <br>// Purpose: <br>//  <br>//     Pulls the data from a Rowset object. <br>//      <br>// Parameters: <br>//  <br>// IRowset*pIRowset    -  interface pointer on data provider's <br>//                             Rowset object <br>//  <br>// Return Value: <br>//  <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//  <br>// Comments:       <br>//  <br>//     At a high level, a consumer pulls the data from a Rowset object by: <br>//      <br>//     1. getting metadata for the Rowset's columns <br>//     2. using that metadata, along with the consumer's own knowledge of <br>//        how it wants to recieve the data, to create bindings. Bindings <br>//        represent how the actual data in the Rowset's columns is <br>//        actually transferred to the consumer's buffer. <br>//     3. pass the bindings to the Rowset, and get in return an accessor <br>//        handle that represents that particulr set of bindings    <br>//     4. get the actual data <br>//     5. clean up the rowset (at a minumum, release the accessor)  <br>//      <br>//     GetDataFromRowset performs these steps by calling GetColumnsInfo, <br>//     SetupBindings, CreateAccessor, GetData, and CleanupRowset <br>//        <br>//********************************************************************** <br> <br>HRESULT GetDataFromRowset <br>( <br>IRowset*pIRowset <br>) <br>{ <br>ULONG cCol; <br>ULONG cbMaxRowSize;// buffer size for 1 row's data <br>ULONG cBind; <br>DBBINDINGrgBind[MAX_BINDINGS]; <br>HACCESSORhAccessor= NULL; <br>DBCOLUMNINFO*pColumnInfo = NULL; <br>WCHAR*pStringsBuffer  = NULL; <br>HRESULT hr; <br>     <br> <br> <br>DumpStatusMsg( "Reading all the data in the rowset...\n" ); <br> <br>assert(pIRowset != NULL); <br>assert(g_pIMalloc != NULL); <br> <br>hr = GetColumnsInfo( pIRowset, &amp;cCol, &amp;pColumnInfo, &amp;pStringsBuffer ); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr,  "GetColumnsInfo"); <br>        goto error; <br>        } <br> <br>hr = SetupBindings( cCol, pColumnInfo, rgBind, &amp;cBind, &amp;cbMaxRowSize ); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr,  "SetupBindings"); <br>        goto error; <br>        } <br> <br>hr = CreateAccessor( pIRowset, rgBind, cBind, &amp;hAccessor ); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr,  "CreateAccessor" ); <br>        goto error; <br>        } <br> <br>hr = GetData( pIRowset, cbMaxRowSize, hAccessor, rgBind, cBind, pColumnInfo, cCol ); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr,  "GetData" ); <br>        goto error; <br>        } <br> <br>g_pIMalloc-&gt;Free( pColumnInfo ); <br>    pColumnInfo = NULL; <br>g_pIMalloc-&gt;Free( pStringsBuffer ); <br>    pStringsBuffer = NULL; <br> <br>hr = CleanupRowset( pIRowset, hAccessor ); <br>if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr,  "CleanupRowset" ); <br>        goto error; <br>        } <br> <br>return ResultFromScode( S_OK ); <br>     <br>error:     <br>if (pColumnInfo) <br>g_pIMalloc-&gt;Free( pColumnInfo ); <br>if (pStringsBuffer) <br>g_pIMalloc-&gt;Free( pStringsBuffer );     <br>     <br>    return ResultFromScode( hr );     <br>} <br> <br> <br> <br> <br> <br> <br>//********************************************************************** <br>//  <br>// GetColumnsInfo <br>// <br>// Purpose: <br>//  <br>//     Obtains information (metadata) about the columns in the rowset - the types <br>//     of the data and so on. <br>// <br>//  <br>// Parameters: <br>// IRowset*pIRowset            - interface pointer on data provider's <br>//                                        Rowset object   <br>// ULONG*pcCol_out           - out pointer through which to return <br>//                                        number of columns in the rowset <br>// DBCOLUMNINFO**ppColumnInfo_out    - out pointer through which to return <br>//                                        pointer to structure containing <br>//                                        metadata for the columns in the rowset <br>// WCHAR**ppStringsBuffer_out - out pointer through which to return <br>//                                        pointer to table of strings. see comments.  <br>//  <br>// Return Value: <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//      <br>//      <br>// Comments:       <br>//  <br>//     ppColumnInfo_out and ppStringsBuffer_out are used to return pointers <br>//     to two buffers. These buffers are allocated by the data provider <br>//     (when GetColumnsInfo calls IColumnsInfo::GetColumnInfo). The data <br>//     provider uses IMalloc to allocate the buffers; therefore, the caller <br>//     of this routine must at a later point use IMalloc::Free to free <br>//     both of these buffers. The StringsBuffer contains strings pointed <br>//     to by pointers in the ColumnInfo buffer, therefore the StringsBuffer <br>//     should be freed *after* the ColumnInfo pointer.     <br>// <br>//     GetColumnsInfo calls DumpColumnsInfo to dump the column metadata to <br>//     the log file. <br>//  <br>//********************************************************************** <br> <br>HRESULT GetColumnsInfo <br>( <br>IRowset*pIRowset, <br>ULONG*pcCol_out, <br>DBCOLUMNINFO**ppColumnInfo_out, <br>WCHAR**ppStringsBuffer_out <br>) <br>{ <br>IColumnsInfo* pIColumnsInfo = NULL; <br>    ULONGcCol; <br>    DBCOLUMNINFO*pColumnInfo; <br>    WCHAR*pStringsBuffer; <br>HRESULT hr; <br>     <br> <br>assert(pIRowset != NULL); <br>    assert(pcCol_out != NULL); <br>    assert(ppColumnInfo_out != NULL); <br>    assert(ppStringsBuffer_out != NULL); <br> <br>// get column information from the command object via IColumnsInfo  <br>hr = pIRowset-&gt;QueryInterface( IID_IColumnsInfo, (void **) &amp;pIColumnsInfo ); <br>    if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "IRowset::QI for IID_IColumnsInfo" ); <br>        goto error; <br>        } <br>hr = pIColumnsInfo-&gt;GetColumnInfo(  <br>&amp;cCol,  <br>&amp;pColumnInfo, <br>&amp;pStringsBuffer ); <br>    if (FAILED(hr)) <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "pIColumnsInfo-&gt;GetColumnInfo" ); <br>        goto error; <br>        } <br>pIColumnsInfo-&gt;Release(); <br>pIColumnsInfo = NULL; <br> <br>DumpColumnsInfo( pColumnInfo, cCol ); <br>     <br>    // fill out-params <br>    *pcCol_out = cCol; <br>    *ppColumnInfo_out = pColumnInfo; <br>    *ppStringsBuffer_out = pStringsBuffer; <br>     <br>return ResultFromScode( S_OK ); <br> <br>error: <br>if (pIColumnsInfo) <br>    pIColumnsInfo-&gt;Release(); <br>         <br>*pcCol_out = 0; <br>    *ppColumnInfo_out = NULL; <br>    *ppStringsBuffer_out = NULL; <br> <br>return ResultFromScode( hr ); <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// SetupBindings <br>//  <br>// Purpose: <br>//  <br>//     Creates bindings that map the data in the rowset's columns to  <br>//     slots in the consumer's data buffer. <br>//      <br>// Parameters: <br>// <br>// ULONG cCol                - number of columns in rowset to bind <br>// DBCOLUMNINFO*pColumnInfo         - pointer to column metadata <br>// DBBINDING*rgBind_out          - out pointer through which to return <br>//                                        an array of binding structures, one <br>//                                        structure per column bound <br>// ULONG*pcBind_out          - out pointer through which to return    <br>//                                        the number of columns bound (number <br>//                                        of valid elements in rgBind_out)               <br>// ULONG*pcMaxRowSize_out    - out pointer through which to return <br>//                                        the buffer size necessary to hold <br>//                                        the largest row data <br>//  <br>// Return Value: <br>//     S_OK         - Success <br>//     E_*          - Failure <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br> <br>HRESULT SetupBindings <br>( <br>ULONG cCol, <br>DBCOLUMNINFO*pColumnInfo, <br>DBBINDING*rgBind_out, <br>ULONG*pcBind_out, <br>ULONG*pcMaxRowSize_out <br>) <br>{ <br>ULONG dwOffset; <br>ULONG iCol; <br>ULONG iBind; <br> <br>     <br>    assert(pColumnInfo != NULL); <br>    assert(rgBind_out != NULL); <br>    assert(pcBind_out != NULL); <br>    assert(pcMaxRowSize_out != NULL); <br>     <br>// Create bindings. <br>// Bind everything as a string just to keep things simple. <br>dwOffset = 0; <br>iBind=0; <br>for (iCol=0; iCol &lt; cCol; iCol++) <br>{ <br>// Skip columns of type _VECTOR. Probably binary data. <br>if (pColumnInfo[iCol].wType &amp; DBTYPE_VECTOR) <br>continue; <br> <br>rgBind_out[iBind].dwPart= DBPART_VALUE | DBPART_LENGTH | <br>  DBPART_STATUS; <br>        rgBind_out[iBind].eParamIO  = DBPARAMIO_NOTPARAM;                               <br>rgBind_out[iBind].iOrdinal  = pColumnInfo[iCol].iOrdinal; <br>rgBind_out[iBind].wType= DBTYPE_STR; <br>rgBind_out[iBind].pTypeInfo = NULL; <br>rgBind_out[iBind].obValue   = dwOffset + offsetof(COLUMNDATA,bData); <br> rgBind_out[iBind].obLength  = dwOffset + offsetof(COLUMNDATA,dwLength); <br>rgBind_out[iBind].obStatus  = dwOffset + offsetof(COLUMNDATA,dwStatus); <br>rgBind_out[iBind].cbMaxLen  = pColumnInfo[iCol].wType == DBTYPE_STR ?  <br>pColumnInfo[iCol].ulColumnSize + sizeof(char) : DEFAULT_CBMAXLENGTH; <br>rgBind_out[iBind].pObject= NULL; <br>dwOffset += rgBind_out[iBind].cbMaxLen + offsetof( COLUMNDATA, bData ); <br>dwOffset = ROUND_UP( dwOffset, COLUMN_ALIGNVAL ); <br>iBind++; <br>}   <br>     <br>*pcBind_out   = iBind; <br>*pcMaxRowSize_out = dwOffset; <br> <br>return ResultFromScode( S_OK ); <br>} <br> <br> <br> <br>//********************************************************************** <br>//  <br>// CreateAccessor <br>//  <br>// Purpose: <br>// <br>//     Passes a set of bindings to the data provider and recieves in return <br>//     an accessor handle that represents those bindings.  <br>//       <br>// Parameters: <br>// IRowset*pIRowset        - interface pointer on data provider's Rowset <br>//                                object <br>// DBBINDING*rgBind          - array of binding structures <br>// ULONGcBind           - number of binding structures in rgBind <br>// HACCESSOR*phAccessor_out  - out pointer through which to return an  <br>//                                accessor handle that represents all the bindings <br>//                                in rgBind <br>//  <br>// Return Value: <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br> <br>HRESULT CreateAccessor <br>( <br>IRowset*pIRowset, <br>DBBINDING*rgBind, <br>ULONGcBind, <br>HACCESSOR*phAccessor_out  <br>) <br>{ <br>IAccessor*pIAccessor = NULL; <br>HACCESSOR   hAccessor; <br>HRESULT hr; <br> <br> <br>assert(pIRowset != NULL); <br>    assert(rgBind != NULL); <br>    assert(phAccessor_out != NULL); <br> <br>  // Get an accessor for our bindings from the rowset, via IAccessor  <br>hr = pIRowset-&gt;QueryInterface( IID_IAccessor, (void**)&amp;pIAccessor ); <br>if (FAILED(hr))    <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "pIRowset-&gt;QI for IID_IAccessor" ); <br>        goto error; <br>        } <br>hr = pIAccessor-&gt;CreateAccessor( DBACCESSOR_ROWDATA, cBind, rgBind, 0,  <br>                                 &amp;hAccessor, NULL ); <br>if (FAILED(hr))    <br>    { <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorHResult( hr, "pIAccessor-&gt;CreateAccessor" ); <br>        goto error; <br>        } <br>pIAccessor-&gt;Release(); <br>pIAccessor = NULL; <br> <br>*phAccessor_out = hAccessor; <br> <br>return ResultFromScode( S_OK ); <br> <br>error: <br>if (pIAccessor) <br>    pIAccessor-&gt;Release(); <br>*phAccessor_out = NULL; <br> <br>return ResultFromScode( hr ); <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// GetData <br>//  <br>// Purpose: <br>//  <br>//     Reads the data from a rowset. <br>//  <br>// Parameters: <br>// <br>//    IRowset* pIRowset           - interface pointer on data provider's <br>//                                    Rowset object <br>//    ULONG    cMaxRowSize        - size of buffer needed to hold the data <br>//                                    for the largest row <br>//     HACCESSOR hAccessor          - accessor handle representing the set <br>//                                    of desired bindings <br>//     DBBINDING*rgBind  - needed only for pretty printing <br>//     ULONGcBind  - for pretty printing   <br>//     DBCOLUMNINFO*pColumnInfo - for pretty printing   <br>//     ULONGcCol- for pretty printing   <br>//  <br>//  <br>// Return Value: <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//  <br>//  <br>//      <br>// Comments:       <br>// <br>//     GetData reads all the rows in the rowset, sequentially. <br>//      <br>//     GetData calls CalcPrettyPrintMaxColWidth, DumpColumnHeadings, and <br>//     DumpRow to dump the row data to a log file. <br>//   <br>//  <br>//********************************************************************** <br> <br>HRESULT GetData <br>( <br>IRowset*pIRowset, <br>ULONG   cMaxRowSize, <br>    HACCESSOR   hAccessor, <br>    DBBINDING*rgBind,     <br>    ULONGcBind,     <br>    DBCOLUMNINFO*pColumnInfo,   <br>    ULONGcCol   <br>) <br>{ <br>ULONG cRowsObtained; <br>ULONGiRow; <br>BYTE*pRowData = NULL; <br>HROW rghRows[NUMROWS_CHUNK]; <br>HROW*pRows = &amp;rghRows[0]; <br>ULONGcMaxColWidth;  // needed for pretty printing <br>HRESULT hr; <br>     <br> <br>assert(pIRowset != NULL); <br>    assert(rgBind != NULL); <br>    assert(pColumnInfo != NULL); <br> <br>// create a buffer for row data, big enough to hold the biggest row <br>pRowData = (BYTE *) malloc( cMaxRowSize ); <br>if (!pRowData) <br>{ <br>        DUMP_ERROR_LINENUMBER(); <br>        DumpErrorMsg("GetData: malloc failed\n"); <br>        goto error; <br>} <br> <br>// pretty print <br>    cMaxColWidth = CalcPrettyPrintMaxColWidth( rgBind, cBind ); <br>     <br>    // pretty print <br>DumpColumnHeadings( rgBind, cBind, pColumnInfo, cCol, cMaxColWidth ); <br> <br>    // process all the rows, NUMROWS_CHUNK rows at a time <br>while (1) <br>{ <br>hr = pIRowset-&gt;GetNextRows( <br>NULL,// hChapter <br>0,// cRowsToSkip <br>NUMROWS_CHUNK,// cRowsDesired <br>&amp;cRowsObtained,             // pcRowsObtained <br>&amp;pRows );// filled in w/ row handles <br>if (FAILED(hr)) <br>{ <br>            DUMP_ERROR_LINENUMBER(); <br>            DumpErrorHResult( hr, "pIRowset-&gt;GetNextRows" ); <br>            goto error; <br>} <br> <br>if ( cRowsObtained == 0 )// all done, no more rows left to get <br>break; <br> <br>// loop over rows obtained, getting data for each <br>for ( iRow=0; iRow &lt; cRowsObtained; iRow++ ) <br>{ <br>hr = pIRowset-&gt;GetData( <br>rghRows[iRow], <br>hAccessor, <br>pRowData ); <br>             if (FAILED(hr)) <br>             { <br>                DUMP_ERROR_LINENUMBER(); <br>                DumpErrorHResult( hr, "pIRowset-&gt;GetData" ); <br>                goto error; <br>             }    <br> <br>// pretty print <br>            DumpRow( rgBind, cBind, cMaxColWidth, pRowData ); </code></pre>
<p>
</p>
<pre><code>} <br>// release row handles <br>hr = pIRowset-&gt;ReleaseRows( cRowsObtained, rghRows, NULL, NULL, NULL ); <br>        if (FAILED(hr)) <br>             { <br>                DUMP_ERROR_LINENUMBER(); <br>                DumpErrorHResult( hr, "pIRowset-&gt;ReleaseRows" ); <br>                goto error; <br>             }  <br>}// end while <br> <br>// free row data buffer <br>free( pRowData ); <br>return ResultFromScode( S_OK ); <br>     <br>error: <br>if (pRowData) <br>free( pRowData ); <br>     <br>    return ResultFromScode( hr ); <br>} <br> <br> <br> <br>//********************************************************************** <br>//  <br>// CleanupRowset <br>//  <br>// Purpose: <br>// <br>//     Allows the rowset to perform any necessary cleanup. <br>//   <br>// Parameters: <br>// <br>// IRowset*pIRowset    - interface pointer on data provider's Rowset <br>//                            object <br>// HACCESSOR hAccessor   - accessor handle to release <br>//  <br>// Return Value: <br>// <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//      <br>//      <br>// Comments:       <br>// <br>//     In this sample, the only cleanup that the rowset needs to do is <br>//     release the accessor handle.  <br>//  <br>//********************************************************************** <br> <br>HRESULT CleanupRowset <br>( <br>IRowset*pIRowset, <br>HACCESSOR hAccessor <br>) <br>{ <br>IAccessor*pIAccessor = NULL; <br>HRESULThr; <br>     <br>    assert(pIRowset != NULL); <br>     <br>// tell the rowset object it can release the accessor, via IAccessor <br>hr = pIRowset-&gt;QueryInterface( IID_IAccessor, (void**)&amp;pIAccessor ); <br>if (FAILED(hr)) <br>{ <br>        DUMP_ERROR_LINENUMBER(); <br>DumpErrorHResult( hr, "pIRowset-&gt;QI for IID_IAccessor" ); <br>goto error; <br>}  <br>hr = pIAccessor-&gt;ReleaseAccessor( hAccessor, NULL ); <br>if (FAILED(hr)) <br>{ <br>        DUMP_ERROR_LINENUMBER(); <br>DumpErrorHResult( hr, "pIAccessor-&gt;ReleaseAccessor" ); <br>goto error; <br>}     <br>pIAccessor-&gt;Release(); <br>pIAccessor = NULL; <br> <br>return ResultFromScode( S_OK ); <br>     <br>error:     <br>if (pIAccessor) <br>    pIAccessor-&gt;Release(); <br> <br>    return ResultFromScode( hr );     <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
