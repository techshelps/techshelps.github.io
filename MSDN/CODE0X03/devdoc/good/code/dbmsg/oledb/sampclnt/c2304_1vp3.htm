<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SAMPCLNT.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2307"></a>SAMPCLNT.H</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Consumer <br>// (C) Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved. <br>// <br>// File name: SAMPCLNT.H <br>// <br>//      Declaration file for a simple OLE DB consumer. <br>// <br>//      See OLE DB SDK Guide for information on building and running  <br>//this sample, as well as notes concerning the implementation of  <br>//a simple OLE DB consumer. <br>// <br> <br> <br>#define WIN32_LEAN_AND_MEAN// avoid the world <br>#define INC_OLE2// tell windows.h to always include ole2.h <br> <br>#include &lt;windows.h&gt;//  <br>#include &lt;ole2ver.h&gt;// OLE2.0 build version <br>#include &lt;cguid.h&gt;// GUID_NULL <br>#include &lt;stdio.h&gt;// vsnprintf, etc. <br>#include &lt;stddef.h&gt;// offsetof <br>#include &lt;stdarg.h&gt;// va_arg <br>#include &lt;time.h&gt;// time <br>#include &lt;assert.h&gt;// assert <br>#include &lt;conio.h&gt;// _getch() <br> <br>//OLE DB headers <br>#include &lt;oledb.h&gt; <br>#include &lt;oledberr.h&gt; <br> <br> <br>//----------------------------------- <br>//constants  <br>//------------------------------------ <br> <br>// Alignment for placement of each column within memory. <br>// Rule of thumb is "natural" boundary, i.e. 4-byte member should be <br>// aligned on address that is multiple of 4. <br>// Worst case is double or __int64 (8 bytes). <br>#define COLUMN_ALIGNVAL 8 <br> <br>#define MAX_GUID_STRING     42// size of a GUID, in characters <br>#define MAX_NAME_STRING     60  // size of DBCOLOD name or propid string <br>#define MAX_BINDINGS       100// size of binding array <br>#define NUMROWS_CHUNK       20// number of rows to grab at a time <br>#define DEFAULT_CBMAXLENGTH 40// cbMaxLength for binding <br> <br> <br>// for pretty printing <br>#define PRETTYPRINT_MAXTOTALWIDTH200     // max entire width of printed row  <br>#define PRETTYPRINT_MINCOLWIDTH     6        // min width of printed column <br> <br> <br> <br>//----------------------------------- <br>//macros  <br>//------------------------------------ <br> <br> <br>// Rounding amount is always a power of two. <br>#define ROUND_UP(   Size, Amount ) (((DWORD)(Size) +  ((Amount) - 1)) &amp; ~((Amount) - 1)) <br> <br>#ifndef  NUMELEM <br># define NUMELEM(p) (sizeof(p)/sizeof(*p)) <br>#endif <br> <br>// usage: DUMPLINE(); <br>#define DUMP_ERROR_LINENUMBER() DumpErrorMsg("Error at file: %s  line: %u  \n", __FILE__, __LINE__) <br> <br> <br> <br>//----------------------------------- <br>//type and structure definitions  <br>//------------------------------------ <br> <br>// How to lay out each column in memory. <br>// Issue? we depend on the dwLength field being first in memory (see assert) <br>// is there another way to handle this? <br>struct COLUMNDATA  <br>{ <br>DWORDdwLength;// length of data (not space allocated) <br>DWORDdwStatus;// status of column <br>BYTEbData[1];// data here and beyond <br>}; <br> <br> <br>// Lists of value/string pairs. <br>typedef struct { <br>DWORD dwFlag; <br>char *szText; <br>} Note; <br> <br>#define NOTE(s) { (DWORD) s, #s } <br> <br> <br> <br> <br>//----------------------------------- <br>//global variables and functions that are private to the file  <br>//------------------------------------ <br> <br> <br>DEFINE_GUID(CLSID_SampProv, 0xE8CCCB79L,0x7C36,0x101B,0xAC,0x3A,0x00,0xAA,0x00,0x44,0x77,0x3D); <br>DEFINE_GUID(DBINIT_OPT_SAMPPROV_PATH, 0xe9fbaf50, 0xd402, 0x11ce, 0xbe, 0xdc, 0x0, 0xaa, 0x0, 0xa1, 0x4d, 0x7d); <br> <br>extern IMalloc*g_pIMalloc; <br>extern FILE*    g_fpLogFile; <br> <br> <br> <br> <br> <br> <br>// function prototypes, sampclnt.cpp <br> <br>void main(); <br> <br>HRESULT DoTests(); <br> <br> <br>HRESULT GetSampprovDataSource <br>( <br>IDBInitialize**ppIDBInitialize_out <br>); <br> <br> <br>HRESULT GetDBSessionFromDataSource <br>    ( <br>    IDBInitialize*      pIDBInitialize,      <br>    IOpenRowset**       ppIOpenRowset_out    <br>    ); <br> <br> <br>HRESULT GetRowsetFromDBSession <br>    ( <br>    IOpenRowset*   pIOpenRowset,    <br>    LPWSTR         pwszTableName,       <br>    IRowset**      ppIRowset_out        <br>    ); <br> <br>     <br>HRESULT GetDataFromRowset <br>( <br>IRowset*pIRowset <br>); <br>     <br>     <br>HRESULT GetColumnsInfo <br>( <br>IRowset*pIRowset, <br>ULONG*pcCol_out, <br>DBCOLUMNINFO**ppColumnInfo_out, <br>WCHAR**ppStringsBuffer_out <br>); <br> <br>    <br>HRESULT SetupBindings <br>( <br>ULONG cCol, <br>DBCOLUMNINFO*pColumnInfo, <br>DBBINDING*rgBind_out, <br>ULONG*cBind_out, <br>    ULONG*          pcMaxRowSize_out <br>); <br> <br>     <br>HRESULT CreateAccessor <br>( <br>IRowset*pIRowset, <br>DBBINDING*rgBind, <br>ULONGcBind, <br>HACCESSOR*phAccessor_out <br>); <br> <br>     <br>HRESULT GetData <br>( <br>IRowset*pIRowset, <br>ULONG   cMaxRowSize, <br>    HACCESSORhAccessor, <br>    DBBINDING*    rgBind,// needed for pretty printing <br>    ULONG    cBind,    // for pretty printing <br>    DBCOLUMNINFO*pColumnInfo, // for pretty printing <br>    ULONGcCol// for pretty printing <br>); <br> <br> <br>HRESULT CleanupRowset <br>( <br>IRowset*pIRowset, <br>HACCESSOR hAccessor <br>); <br>     <br>     <br>     <br>// function prototypes, dump.cpp <br> <br>void DumpErrorMsg <br>( <br>    const char* format, <br>    ... <br>); <br> <br> <br>void DumpStatusMsg <br>( <br>    const char* format, <br>    ... <br>); <br> <br> <br>HRESULT DumpErrorHResult <br>( <br>HRESULT      hr_return, <br>const char  *format, <br>...  <br>); <br> <br> <br>void DumpColumnsInfo <br>( <br>    DBCOLUMNINFO* pColInfo, <br>    ULONG      cCol <br>    ); <br> <br> <br> <br>void WriteColumnInfo <br>( <br>FILE*fp, <br>DBCOLUMNINFO*p  <br>); <br>     <br> <br>char* GetNoteString <br>    (  <br>Note * rgNote,  <br>int    cNote, <br>DWORD  dwValue  <br>); <br> <br> <br>     <br>char* GetNoteStringBitvals <br>( <br>Note* rgNote, <br>int     cNote, <br>DWORD   dwValue  <br>); <br> <br> <br>ULONG CalcPrettyPrintMaxColWidth <br>    ( <br>    DBBINDING*rgBind, <br>    ULONG       cBind <br>    ); <br>  <br>     <br>void DumpColumnHeadings <br>( <br>DBBINDING*rgBind,  <br>ULONGcBind,  <br>DBCOLUMNINFO* pColInfo,  <br>ULONGcCol, <br>    ULONGcMaxColWidth <br>); <br> <br> <br>WCHAR* LookupColumnName <br>( <br>DBCOLUMNINFO*rgColInfo, <br>ULONG cCol, <br>ULONG iCol  <br>); <br> <br>void DumpRow <br>( <br>    DBBINDING* rgBind, <br>    ULONGcBind, <br>    ULONGcMaxColWidth, <br>    BYTE* pData <br>    ); <br> <br> <br>void PrintColumn <br>( <br>COLUMNDATA    *pColumn, <br>DBBINDING     *rgBind, <br>ULONG          iBind, <br>ULONG          cMaxColWidth  <br>); <br> <br>     <br>void tfprintf <br>( <br>FILE*fp, <br>const char* format, <br>...  <br>); <br> <br> <br>void tvfprintf <br>( <br>FILE*fp, <br>const char* format, <br>va_listargptr  <br>); <br> <br> <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
