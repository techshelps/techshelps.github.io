<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DUMP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2304"></a>DUMP.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft OLE DB Sample Consumer <br>// (C) Copyright 1995 - 1996 Microsoft Corporation. All Rights Reserved. <br>// <br>// File name: DUMP.CPP <br>// <br>//      Dump\output routines for the SAMPCLNT sample OLE DB consumer. <br>// <br>//      See README.TXT for more information on the SAMPCLNT sample. <br>// <br>// Functions: <br>// <br>//      See SAMPCLNT.H for function prototypes <br>// <br> <br> <br> <br>#include "sampclnt.h" <br> <br> <br> <br> <br>void DumpErrorMsg <br>( <br>    const char* format, <br>    ... <br>) <br>{ <br>va_list argptr;     <br> <br>assert(format != NULL); <br> <br>// log this message to stderr and to our log file <br>va_start( argptr, format ); <br>tvfprintf( stderr, format, argptr); <br>    tvfprintf( g_fpLogFile, format, argptr); <br>va_end( argptr ); <br>}     <br> <br> <br> <br>void DumpStatusMsg <br>( <br>    const char* format, <br>    ... <br>) <br>{ <br>va_list argptr; <br> <br>assert(format != NULL); <br> <br>// log this message to stdout and to our log file <br>va_start( argptr, format ); <br>tvfprintf( stdout, format, argptr ); <br>    tvfprintf( g_fpLogFile, format, argptr ); <br>va_end( argptr ); <br>}     <br> <br> <br> <br> <br>HRESULT DumpErrorHResult <br>( <br>HRESULT      hr_return, <br>const char  *format,// can be NULL <br>...  <br>) <br>{ <br>char     buff[100]; <br>int      cBytesWritten; <br>va_list  argptr; <br> <br>// <br>// Dump an error message. <br>// Print the text of the HRESULT, <br>// Return the HRESULT we were passed. <br> <br>    // these result codes were generated from the oledberr.h  <br>static Note ResultCodes[] = { <br>// oledberr.h error codes <br>NOTE(DB_E_BADACCESSORHANDLE), <br>NOTE(DB_E_BADACCESSORHANDLE), <br>NOTE(DB_E_ROWLIMITEXCEEDED), <br>NOTE(DB_E_READONLYACCESSOR), <br>NOTE(DB_E_SCHEMAVIOLATION), <br>NOTE(DB_E_BADROWHANDLE), <br>NOTE(DB_E_OBJECTOPEN), <br>NOTE(DB_E_BADBINDINFO), <br>NOTE(DB_SEC_E_PERMISSIONDENIED), <br>NOTE(DB_E_NOTAREFERENCECOLUMN), <br>NOTE(DB_E_NOCOMMAND), <br>NOTE(DB_E_BADBOOKMARK), <br>NOTE(DB_E_BADLOCKMODE), <br>NOTE(DB_E_PARAMNOTOPTIONAL), <br>NOTE(DB_E_BADRATIO), <br>NOTE(DB_E_ERRORSINCOMMAND), <br>NOTE(DB_E_CANNOTFREE), <br>NOTE(DB_E_BADSTARTPOSITION), <br>NOTE(DB_E_NOTREENTRANT), <br>NOTE(DB_E_NOAGGREGATION), <br>NOTE(DB_E_DELETEDROW), <br>NOTE(DB_E_CANTFETCHBACKWARDS), <br>NOTE(DB_E_ROWSNOTRELEASED), <br>NOTE(DB_E_BADSTORAGEFLAG), <br>NOTE(DB_E_BADSTATUSVALUE), <br>NOTE(DB_E_CANTSCROLLBACKWARDS), <br>NOTE(DB_E_INTEGRITYVIOLATION), <br>NOTE(DB_E_ABORTLIMITREACHED), <br>NOTE(DB_E_ROWSETINCOMMAND), <br>NOTE(DB_E_DUPLICATEINDEXID), <br>NOTE(DB_E_NOINDEX), <br>NOTE(DB_E_INDEXINUSE), <br>NOTE(DB_E_NOTABLE), <br>NOTE(DB_E_CONCURRENCYVIOLATION), <br>NOTE(DB_E_BADCOPY), <br>NOTE(DB_E_BADPRECISION), <br>NOTE(DB_E_BADSCALE), <br>NOTE(DB_E_BADID), <br>NOTE(DB_E_BADTYPE), <br>NOTE(DB_E_DUPLICATECOLUMNID), <br>NOTE(DB_E_DUPLICATETABLEID), <br>NOTE(DB_E_TABLEINUSE), <br>NOTE(DB_E_NOLOCALE), <br>NOTE(DB_E_BADRECORDNUM), <br>NOTE(DB_E_BOOKMARKSKIPPED), <br>NOTE(DB_E_BADPROPERTYVALUE), <br>NOTE(DB_E_INVALID), <br>NOTE(DB_E_BADACCESSORFLAGS), <br>NOTE(DB_E_BADSTORAGEFLAGS), <br>NOTE(DB_E_BYREFACCESSORNOTSUPPORTED), <br>NOTE(DB_E_NULLACCESSORNOTSUPPORTED), <br>NOTE(DB_E_NOTPREPARED), <br>NOTE(DB_E_BADACCESSORTYPE), <br>NOTE(DB_E_WRITEONLYACCESSOR), <br>NOTE(DB_SEC_E_AUTH_FAILED), <br>NOTE(DB_E_CANCELED), <br>NOTE(DB_E_BADSOURCEHANDLE), <br>NOTE(DB_S_ROWLIMITEXCEEDED), <br>NOTE(DB_S_COLUMNTYPEMISMATCH), <br>NOTE(DB_S_TYPEINFOOVERRIDDEN), <br>NOTE(DB_S_BOOKMARKSKIPPED), <br>NOTE(DB_S_ENDOFROWSET), <br>NOTE(DB_S_BUFFERFULL), <br>NOTE(DB_S_CANTRELEASE), <br>NOTE(DB_S_DIALECTIGNORED), <br>NOTE(DB_S_UNWANTEDPHASE), <br>NOTE(DB_S_COLUMNSCHANGED), <br>NOTE(DB_S_ERRORSRETURNED), <br>NOTE(DB_S_BADROWHANDLE), <br>NOTE(DB_S_DELETEDROW), <br>NOTE(DB_S_STOPLIMITREACHED), <br>NOTE(DB_S_LOCKUPGRADED), <br>NOTE(DB_S_PROPERTIESCHANGED), <br>NOTE(DB_S_ERRORSOCCURRED), <br>NOTE(DB_S_PARAMUNAVAILABLE), <br>NOTE(DB_S_MULTIPLECHANGES), <br> <br>// winerr.h <br>NOTE(E_UNEXPECTED), <br>NOTE(E_NOTIMPL), <br>NOTE(E_OUTOFMEMORY), <br>NOTE(E_INVALIDARG), <br>NOTE(E_NOINTERFACE), <br>NOTE(E_POINTER), <br>NOTE(E_HANDLE), <br>NOTE(E_ABORT), <br>NOTE(E_FAIL), <br>NOTE(E_ACCESSDENIED), <br>NOTE(S_OK), <br>NOTE(S_FALSE), <br>NOTE(E_UNEXPECTED), <br>NOTE(E_NOTIMPL), <br>NOTE(E_OUTOFMEMORY), <br>NOTE(E_INVALIDARG), <br>NOTE(E_NOINTERFACE), <br>NOTE(E_POINTER), <br>NOTE(E_HANDLE), <br>NOTE(E_ABORT), <br>NOTE(E_FAIL), <br>NOTE(E_ACCESSDENIED), <br>// BindMoniker Errors <br>NOTE(MK_E_NOOBJECT), <br>NOTE(MK_E_EXCEEDEDDEADLINE), <br>NOTE(MK_E_CONNECTMANUALLY), <br>NOTE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED), <br>NOTE(STG_E_ACCESSDENIED), <br>NOTE(MK_E_SYNTAX), <br>NOTE(MK_E_CANTOPENFILE), <br>}; <br> <br> <br>// Format the message. <br>// Print name of hresult code. <br> <br>if (format) <br>{ <br>va_start( argptr, format ); <br>cBytesWritten = _vsnprintf( buff, sizeof(buff), format, argptr ); <br>va_end( argptr ); <br>} <br>else <br>strcpy( buff, "" ); <br> <br>// log to stderr and also to our log file <br>tfprintf( stderr, "%.*s: Returned %.30s\n",  <br>sizeof(buff), buff,  <br>GetNoteString( ResultCodes, NUMELEM(ResultCodes), GetScode(hr_return)) ); <br>         <br>   tfprintf( g_fpLogFile, "%.*s: Returned %.30s\n",  <br>sizeof(buff), buff,  <br>GetNoteString( ResultCodes, NUMELEM(ResultCodes), GetScode(hr_return)) ); <br> <br>return ResultFromScode( hr_return ); <br>} <br> <br> <br> <br> <br>void DumpColumnsInfo <br>( <br>    DBCOLUMNINFO* pColInfo, <br>    ULONG      cCol <br>    ) <br>{ <br>ULONG j; <br> <br>assert(pColInfo != NULL); <br>  <br>tfprintf( g_fpLogFile, "\nColumn Information:\n\n");  <br>     <br>for (j=0; j &lt; cCol; j++) <br>{ <br>WriteColumnInfo( g_fpLogFile, &amp;pColInfo[j] ); <br>} <br>} <br> <br> <br> <br>void WriteColumnInfo <br>( <br>FILE*fp, <br>DBCOLUMNINFO*p  <br>) <br>{ <br>DBID     *pCol; <br>    DBKIND      eKind; <br>wchar_t wszGuidBuff[MAX_GUID_STRING]; <br>    wchar_t     wszNameBuff[MAX_GUID_STRING];     <br>     <br>static char *szDbcolkind[] = { "Guid+Name", "Guid+PropID", "Name",  <br>    "Guid+Name", "Guid+PropID", "PropID", "Guid" }; <br> <br>assert(p != NULL); <br> <br>// For DBTYPEENUM.  Doesn't need to be in order. <br>// Below we mask off the high bits. <br>static Note typenotes[] =  <br>    { <br>NOTE(DBTYPE_EMPTY), <br>NOTE(DBTYPE_NULL), <br>NOTE(DBTYPE_I2), <br>NOTE(DBTYPE_I4), <br>NOTE(DBTYPE_R4), <br>NOTE(DBTYPE_R8), <br>NOTE(DBTYPE_CY), <br>NOTE(DBTYPE_DATE), <br>NOTE(DBTYPE_BSTR), <br>NOTE(DBTYPE_IDISPATCH), <br>NOTE(DBTYPE_ERROR), <br>NOTE(DBTYPE_BOOL), <br>NOTE(DBTYPE_VARIANT), <br>NOTE(DBTYPE_IUNKNOWN), <br>NOTE(DBTYPE_DECIMAL), <br>NOTE(DBTYPE_UI1), <br>NOTE(DBTYPE_ARRAY), <br>NOTE(DBTYPE_BYREF), <br>NOTE(DBTYPE_I1), <br>NOTE(DBTYPE_UI2), <br>NOTE(DBTYPE_UI4), <br>NOTE(DBTYPE_I8), <br>NOTE(DBTYPE_UI8), <br>NOTE(DBTYPE_GUID), <br>NOTE(DBTYPE_VECTOR), <br>NOTE(DBTYPE_RESERVED), <br>NOTE(DBTYPE_BYTES), <br>NOTE(DBTYPE_STR), <br>NOTE(DBTYPE_WSTR), <br>NOTE(DBTYPE_NUMERIC), <br>NOTE(DBTYPE_UDT), <br>NOTE(DBTYPE_DBDATE), <br>NOTE(DBTYPE_DBTIME), <br>NOTE(DBTYPE_DBTIMESTAMP), <br>    }; <br> <br>static Note flagnotes[] =  <br>    { <br>NOTE(DBCOLUMNFLAGS_ISBOOKMARK), <br>NOTE(DBCOLUMNFLAGS_MAYDEFER), <br>NOTE(DBCOLUMNFLAGS_WRITE), <br>NOTE(DBCOLUMNFLAGS_WRITEUNKNOWN), <br>NOTE(DBCOLUMNFLAGS_ISFIXEDLENGTH), <br>NOTE(DBCOLUMNFLAGS_ISNULLABLE), <br>NOTE(DBCOLUMNFLAGS_MAYBENULL), <br>NOTE(DBCOLUMNFLAGS_ISLONG), <br>NOTE(DBCOLUMNFLAGS_ISROWID), <br>NOTE(DBCOLUMNFLAGS_ISROWVER), <br>NOTE(DBCOLUMNFLAGS_CACHEDEFERRED), <br>}; <br> <br>pCol = &amp; p-&gt;columnid; <br>    eKind = pCol-&gt;eKind; <br> <br>    // stringize GUID for pretty printing <br>    switch (eKind) <br>        { <br>        case DBKIND_GUID_NAME: <br>        case DBKIND_GUID_PROPID: <br>        case DBKIND_GUID: <br>        StringFromGUID2( pCol-&gt;uGuid.guid, wszGuidBuff, sizeof(wszGuidBuff) ); <br>            break; <br>        case DBKIND_PGUID_NAME: <br>        case DBKIND_PGUID_PROPID:           <br>        StringFromGUID2( *(pCol-&gt;uGuid.pguid), wszGuidBuff, sizeof(wszGuidBuff) ); <br>            break; <br>        default: <br>            wcscpy( wszGuidBuff, L"&lt;none&gt;" ); <br>            break;     <br>        } <br>         <br>    // stringize name or propID for pretty printing    <br>    switch (eKind) <br>        { <br>        case DBKIND_GUID_NAME: <br>        case DBKIND_NAME: <br>        case DBKIND_PGUID_NAME: <br>            swprintf( wszNameBuff, L"[name=%.50S]", pCol-&gt;uName.pwszName ? pCol-&gt;uName.pwszName : L"(unknown)" ); <br>            break; <br>        case DBKIND_GUID_PROPID: <br>        case DBKIND_PGUID_PROPID: <br>        case DBKIND_PROPID: <br>            swprintf( wszNameBuff, L"[propid=%lu]", pCol-&gt;uName.ulPropid ); <br>            break; <br>        default: <br>            wcscpy( wszNameBuff, L"" ); <br>            break;     <br>        }    <br> <br>    // pretty print column info <br>    tfprintf( fp, "ColumnId [kind=%.40s] [guid=%.40S] %.60S\n",  <br>        szDbcolkind[eKind], wszGuidBuff, wszNameBuff ); <br>         <br> <br>// Now move on to other stuff... <br>// Name in DBCOLUMNINFO different than name in DBCOLUMNID (maybe). <br>tfprintf(fp, "  Name          = '%.50S'\n", p-&gt;pwszName ); <br>tfprintf(fp, "  iOrdinal      = %d\n", p-&gt;iOrdinal); <br>tfprintf(fp, "  wType         = %.100s\n",  <br>GetNoteString( typenotes, NUMELEM(typenotes), <br>    p-&gt;wType &amp; (~DBTYPE_BYREF) &amp; (~DBTYPE_ARRAY) &amp; (~DBTYPE_VECTOR) ) ); <br>if (p-&gt;wType &amp; DBTYPE_BYREF) <br>tfprintf(fp, "      (BYREF)\n"); <br>if (p-&gt;wType &amp; DBTYPE_ARRAY) <br>tfprintf(fp, "      (ARRAY)\n"); <br>if (p-&gt;wType &amp; DBTYPE_VECTOR) <br>tfprintf(fp, "      (VECTOR)\n"); <br>tfprintf(fp, "  ulColumnSize  = %ld\n", p-&gt;ulColumnSize ); <br>tfprintf(fp, "  bPrecision    = %b\n",  p-&gt;bPrecision ); <br>tfprintf(fp, "  bScale        = %b\n",  p-&gt;bScale ); <br>tfprintf(fp, "  dwFlags       = %s\n\n", <br>GetNoteStringBitvals( flagnotes, NUMELEM(flagnotes), p-&gt;dwFlags ) ); <br> <br> <br>} <br> <br> <br>char* GetNoteString <br>    (  <br>Note * rgNote,  <br>int    cNote, <br>DWORD  dwValue  <br>) <br>{ <br>int j; <br> <br>assert(rgNote != NULL); <br> <br>// Scan a table of value/string, <br>// return ptr to string found. <br> <br>for (j=0; j &lt; cNote; j++) { <br>if (rgNote[j].dwFlag == dwValue) <br>return rgNote[j].szText; <br>} <br>return "&lt;unknown&gt;"; <br>} <br> <br> <br> <br> <br> <br> <br> <br>char*GetNoteStringBitvals <br>( <br>Note* rgNote, <br>int     cNote, <br>DWORD   dwValue  <br>) <br>{ <br>static char buff[400]; <br>int j; <br> <br>assert(rgNote != NULL); <br> <br>// Make a string that combines all the bits ORed together. <br> <br>strcpy(buff, ""); <br>for (j=0; j &lt; cNote; j++) { <br>if (rgNote[j].dwFlag &amp; dwValue) { <br>if (buff[0]) <br>strcat( buff, " | " ); <br>strcat( buff, rgNote[j].szText ); <br>} <br>} <br>assert(strlen(buff) &lt; sizeof(buff)); <br>return buff; <br>} <br> <br> <br> <br> <br>ULONG CalcPrettyPrintMaxColWidth <br>    ( <br>    DBBINDING*rgBind, <br>    ULONG       cBind <br>    ) <br>{ <br>ULONGcMaxWidth; <br>    ULONG   cTotalWidth; <br>    ULONGiBind; <br> <br>assert(rgBind != NULL); <br> <br>cMaxWidth = DEFAULT_CBMAXLENGTH; <br>while (1) <br>{ <br>cTotalWidth = 0; <br> <br>for (iBind=0; iBind &lt; cBind; iBind++) <br>cTotalWidth += min( cMaxWidth, rgBind[iBind].cbMaxLen ) + 1; <br> <br>if (cTotalWidth &lt; PRETTYPRINT_MAXTOTALWIDTH || cMaxWidth &lt; PRETTYPRINT_MINCOLWIDTH) <br>break; <br> <br>cMaxWidth--; <br>} <br> <br>return cMaxWidth; <br>} <br> <br> <br> <br>void DumpColumnHeadings <br>( <br>DBBINDING*rgBind,  <br>ULONGcBind,  <br>DBCOLUMNINFO* pColInfo,  <br>ULONGcCol, <br>    ULONGcMaxColWidth <br>) <br>{ <br>ULONG iBind; <br> <br>assert(rgBind != NULL); <br>    assert(pColInfo != NULL); <br>  <br>for (iBind=0; iBind &lt; cBind; iBind++) <br>tfprintf( g_fpLogFile, "%-*.*S ", <br>min( cMaxColWidth, rgBind[iBind].cbMaxLen ), <br>min( cMaxColWidth, rgBind[iBind].cbMaxLen ), <br>LookupColumnName( pColInfo, cCol, rgBind[iBind].iOrdinal ) ); <br>tfprintf( g_fpLogFile, "\n" ); <br>for (iBind=0; iBind &lt; cBind; iBind++) <br>tfprintf( g_fpLogFile, "%-*.*s ", <br>min( cMaxColWidth, rgBind[iBind].cbMaxLen ), <br>min( cMaxColWidth, rgBind[iBind].cbMaxLen ), <br>"------------------------------" ); <br>tfprintf( g_fpLogFile, "\n" ); <br>} <br> <br> <br> <br>WCHAR* LookupColumnName <br>( <br>DBCOLUMNINFO*rgColInfo, <br>ULONG cCol, <br>ULONG iCol  <br>) <br>{ <br>ULONG j; <br> <br>assert(rgColInfo != NULL); <br> <br>// A really slow way to get the column name, given the ordinal. <br>// The problem is that result-set ordinals do not necessarily match <br>// the index into the ColumnInfo array. <br>// (May have bookmark, which is always column 0.) <br> <br>for (j=0; j &lt; cCol; j++) <br>if (rgColInfo[j].iOrdinal == iCol) <br>return rgColInfo[j].pwszName; <br>             <br>return L"Error"; <br>} <br> <br> <br> <br> <br>void DumpRow <br>( <br>    DBBINDING* rgBind, <br>    ULONGcBind, <br>    ULONGcMaxColWidth, <br>    BYTE* pData <br>    ) <br>{ <br>ULONG iBind; <br>    COLUMNDATA*pColumn; <br>     <br>assert(rgBind); <br>assert( offsetof(COLUMNDATA, dwLength) == 0); <br>     <br>// Print each column we're bound to. <br>for (iBind=0; iBind &lt; cBind; iBind++) <br>{ <br>// Columns are bound differently; not so easy. <br>// Print out to at least DEFAULT_CBMAXLENGTH width (pretty), <br>// Limit to first dwLength characters. <br> <br>pColumn = (COLUMNDATA *) (pData + rgBind[iBind].obLength); <br>PrintColumn( pColumn, rgBind, iBind, cMaxColWidth ); <br>} <br>tfprintf( g_fpLogFile, "\n" ); <br>}     <br> <br> <br> <br> <br> <br>void PrintColumn <br>( <br>COLUMNDATA    *pColumn, <br>DBBINDING     *rgBind, <br>ULONG          iBind, <br>ULONG          cMaxColWidth  <br>) <br>{ <br>void*p; <br>ULONG   ulPrintWidth; <br>ULONG   ulPrintPrecision; <br>DWORD   dwStatus; <br>DWORD   dwLength; <br>BOOL    fDidVariant; <br>BOOL    fIsUnicode; <br>char*sFormat; <br>HRESULT hr; <br> <br>    assert(pColumn != NULL); <br>    assert(rgBind != NULL); <br>     <br>// Pretty print a column. <br>// May have different type of binding. <br> <br>fDidVariant = FALSE; <br>fIsUnicode  = FALSE; <br>dwStatus = pColumn-&gt;dwStatus; <br>dwLength = pColumn-&gt;dwLength; <br> <br>if (dwStatus == DBSTATUS_S_ISNULL) <br>{ <br>p = "&lt;null&gt;"; <br>dwLength = strlen( (char *) p); <br>} <br>    else if (dwStatus == DBBINDSTATUS_UNSUPPORTEDCONVERSION) <br>        { <br>        p = "&lt;unsupportedconversion&gt;"; <br>dwLength = strlen( (char *) p); <br>        }     <br>else <br>{ <br>switch (rgBind[iBind].wType)  <br>{ <br>case DBTYPE_STR: <br>// We have a string in our buffer, so use it. <br>p = (void *) &amp;pColumn-&gt;bData; <br>break; <br>case DBTYPE_VARIANT: <br>// We have a variant in our buffer, so convert to string. <br>p = (void *) &amp;pColumn-&gt;bData; <br>hr = VariantChangeTypeEx( <br>(VARIANT *) p,// Destination (convert in place) <br>(VARIANT *) p,// Source <br>LOCALE_SYSTEM_DEFAULT,// LCID <br>0,// dwFlags <br>VT_BSTR ); <br>if (FAILED(hr)) <br>            { <br>DumpErrorHResult( hr, "VariantChangeTypeEx, field %d", iBind ); <br>                return; <br>                } <br>p = (wchar_t *) (((VARIANT *)p)-&gt;bstrVal) ; <br>dwLength = ((DWORD *)p)[-1] / sizeof(wchar_t); <br>fDidVariant = TRUE; <br>fIsUnicode  = TRUE; <br>break; <br>default: <br>p = "??? unknown type ???"; <br>break; <br>} <br>} <br> <br>// Print the column. <br>// If it has been truncated or rounded, print a '#' in <br>// the far right-hand column. <br>ulPrintWidth     = min( cMaxColWidth, rgBind[iBind].cbMaxLen ); <br>ulPrintPrecision = min( cMaxColWidth, dwLength ); <br>if (dwStatus == DBSTATUS_S_TRUNCATED ||  cMaxColWidth &lt; dwLength) <br>{ <br>ulPrintWidth--; <br>ulPrintPrecision--; <br>} <br> <br>sFormat = fIsUnicode ? "%-*.*S" : "%-*.*s"; <br> <br>tfprintf( g_fpLogFile, sFormat, ulPrintWidth, ulPrintPrecision, p ); <br> <br>if (dwStatus == DBSTATUS_S_TRUNCATED ||  cMaxColWidth &lt; dwLength) <br>tfprintf( g_fpLogFile, "#" ); <br>tfprintf( g_fpLogFile, " " ); <br> <br>// Free memory used by the variant. <br>if (fDidVariant) <br>VariantClear( (VARIANT *) &amp;pColumn-&gt;bData ); <br>         <br>return; <br>} <br> <br> <br> <br> <br>void tfprintf <br>( <br>FILE*fp, <br>const char* format, <br>...  <br>) <br>{ <br>int cBytesWritten; <br>char buff[400]; <br>va_list argptr; <br> <br>assert(format != NULL); <br> <br>// Dump a formatted string. <br>    // _vsnprintf prevents overflowing our buffer. <br>va_start( argptr, format ); <br>cBytesWritten = _vsnprintf( buff, sizeof(buff), format, argptr ); <br>va_end( argptr ); <br>buff[sizeof(buff)-1] = '\0'; <br> <br>// Can't use fprintf, because string could contain '%'. <br>if (fp) <br>fputs( buff, fp ); <br>} <br> <br> <br> <br>void tvfprintf <br>( <br>FILE*fp, <br>const char* format, <br>va_listargptr  <br>) <br>{ <br>int cBytesWritten; <br>char buff[400]; <br> <br> <br>assert(format != NULL); <br> <br>// Dump a formatted string. <br>    // _vsnprintf prevents overflowing our buffer. <br>cBytesWritten = _vsnprintf( buff, sizeof(buff), format, argptr ); <br>buff[sizeof(buff)-1] = '\0'; <br> <br>// Can't use fprintf, because string could contain '%'. <br>if (fp) <br>fputs( buff, fp ); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
