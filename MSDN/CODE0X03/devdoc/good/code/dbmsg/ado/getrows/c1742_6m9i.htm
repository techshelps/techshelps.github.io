<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GETRDLG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1746"></a>GETRDLG.CPP</h2>
<pre><code>//-------------------------------------------------------------------- <br>// Microsoft ADO Samples <br>// <br>// (c) 1996 Microsoft Corporation.  All Rights Reserved. <br>// <br>// @doc GetRows Sample <br>// <br>// @modulegetrdlg.cpp <br>// <br>// @devnote None <br>//-------------------------------------------------------------------- <br> <br>#include "stdafx.h" <br>#include "GetRows.h" <br>#include "GetRDlg.h" <br> <br>const LPCTSTR x_lpcszSource = _T("OLE_DB_NWind_Jet"); <br>const LPCTSTR x_lpcszUser = _T("Admin");     <br>const LPCTSTR x_lpcszPassword = _T(""); <br>const LPCTSTR x_lpcszSQL = _T("select EmployeeId, LastName, FirstName from Employees"); <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CAboutDlg dialog used for App About <br> <br>class CAboutDlg : public CDialog <br>{ <br>public: <br>CAboutDlg(); <br> <br>// Dialog Data <br>//{{AFX_DATA(CAboutDlg) <br>enum { IDD = IDD_ABOUTBOX }; <br>//}}AFX_DATA <br> <br>// ClassWizard generated virtual function overrides <br>//{{AFX_VIRTUAL(CAboutDlg) <br>protected: <br>virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support <br>//}}AFX_VIRTUAL <br> <br>// Implementation <br>protected: <br>//{{AFX_MSG(CAboutDlg) <br>//}}AFX_MSG <br>DECLARE_MESSAGE_MAP() <br>}; <br> <br>CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD) <br>{ <br>//{{AFX_DATA_INIT(CAboutDlg) <br>//}}AFX_DATA_INIT <br>} <br> <br>void CAboutDlg::DoDataExchange(CDataExchange* pDX) <br>{ <br>CDialog::DoDataExchange(pDX); <br>//{{AFX_DATA_MAP(CAboutDlg) <br>//}}AFX_DATA_MAP <br>} <br> <br>BEGIN_MESSAGE_MAP(CAboutDlg, CDialog) <br> //{{AFX_MSG_MAP(CAboutDlg) <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CGetRowsDlg dialog <br> <br>CGetRowsDlg::CGetRowsDlg(CWnd* pParent /*=NULL*/) <br>: CDialog(CGetRowsDlg::IDD, pParent) <br>{ <br>//{{AFX_DATA_INIT(CGetRowsDlg) <br>// NOTE: the ClassWizard will add member initialization here <br>//}}AFX_DATA_INIT <br>// Note that LoadIcon does not require a subsequent DestroyIcon in Win32 <br>m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); <br>m_piConnection = NULL; <br>m_piEmpRecordSet = NULL; <br>m_strSource = x_lpcszSource; <br>m_strUser = x_lpcszUser; <br>m_strPassword = x_lpcszPassword; <br>m_strSQL = x_lpcszSQL; <br>} <br> <br>CGetRowsDlg::~CGetRowsDlg() <br>{ <br>if ( m_piConnection != NULL ) <br>m_piConnection-&gt;Release();  <br>if ( m_piEmpRecordSet != NULL ) <br>m_piEmpRecordSet-&gt;Release(); <br>m_piConnection = NULL; <br>m_piEmpRecordSet = NULL; <br>} <br> <br> <br>void CGetRowsDlg::DoDataExchange(CDataExchange* pDX) <br>{ <br>CDialog::DoDataExchange(pDX); <br>//{{AFX_DATA_MAP(CGetRowsDlg) <br>// NOTE: the ClassWizard will add DDX and DDV calls here <br>//}}AFX_DATA_MAP <br>} <br> <br>BEGIN_MESSAGE_MAP(CGetRowsDlg, CDialog) <br>//{{AFX_MSG_MAP(CGetRowsDlg) <br>ON_WM_SYSCOMMAND() <br>ON_WM_PAINT() <br>ON_WM_QUERYDRAGICON() <br>ON_BN_CLICKED(IDD_EXECUTE, OnExecute) <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CGetRowsDlg message handlers <br> <br>BOOL CGetRowsDlg::OnInitDialog() <br>{ <br>CDialog::OnInitDialog(); <br> <br>// Add "About..." menu item to system menu. <br> <br>// IDM_ABOUTBOX must be in the system command range. <br>ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); <br>ASSERT(IDM_ABOUTBOX &lt; 0xF000); <br> <br>CMenu* pSysMenu = GetSystemMenu(FALSE); <br>CString strAboutMenu; <br>strAboutMenu.LoadString(IDS_ABOUTBOX); <br>if (!strAboutMenu.IsEmpty()) <br>{ <br>pSysMenu-&gt;AppendMenu(MF_SEPARATOR); <br>pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); <br>} <br> <br>// Set the icon for this dialog.  The framework does this automatically <br>//  when the application's main window is not a dialog <br>SetIcon(m_hIcon, TRUE);// Set big icon <br>SetIcon(m_hIcon, FALSE);// Set small icon <br> <br>return TRUE;  // return TRUE  unless you set the focus to a control <br>} <br> <br>void CGetRowsDlg::OnSysCommand(UINT nID, LPARAM lParam) <br>{ <br>if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) <br>{ <br>CAboutDlg dlgAbout; <br>dlgAbout.DoModal(); <br>} <br>else <br>{ <br>CDialog::OnSysCommand(nID, lParam); <br>} <br>} <br> <br>// If you add a minimize button to your dialog, you will need the code below <br>//  to draw the icon.  For MFC applications using the document/view model, <br>//  this is automatically done for you by the framework. <br> <br>void CGetRowsDlg::OnPaint()  <br>{ <br>if (IsIconic()) <br>{ <br>CPaintDC dc(this); // device context for painting <br> <br>SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); <br> <br>// Center icon in client rectangle <br>int cxIcon = GetSystemMetrics(SM_CXICON); <br>int cyIcon = GetSystemMetrics(SM_CYICON); <br>CRect rect; <br>GetClientRect(&amp;rect); <br>int x = (rect.Width() - cxIcon + 1) / 2; <br>int y = (rect.Height() - cyIcon + 1) / 2; <br> <br>// Draw the icon <br>dc.DrawIcon(x, y, m_hIcon); <br>} <br>else <br>{ <br>CDialog::OnPaint(); <br>} <br>} <br> <br>// The system calls this to obtain the cursor to display while the user drags <br>//  the minimized window. <br>HCURSOR CGetRowsDlg::OnQueryDragIcon() <br>{ <br>return (HCURSOR) m_hIcon; <br>} <br> <br> <br>void CGetRowsDlg::OnExecute()  <br>{ <br>BSTRbstrSource = NULL; <br>BSTRbstrUser = NULL; <br>BSTRbstrPassword = NULL; <br>BSTRbstrSQL = NULL; <br>HRESULThr; <br>COleVariantvNull; <br> <br>//Open the database and the recordset <br>if ( m_piConnection == NULL || m_piEmpRecordSet == NULL) <br>{ <br>hr = CoInitialize(NULL); <br>if (FAILED(hr))goto ErrorExit; <br> <br>hr = CoCreateInstance(CLSID_CADOConnection, NULL, CLSCTX_INPROC_SERVER, IID_IADOConnection, (LPVOID *)&amp;m_piConnection); <br>if (FAILED(hr))goto ErrorExit; <br> <br>bstrSource = m_strSource.AllocSysString(); <br>bstrUser = m_strUser.AllocSysString(); <br>bstrPassword = m_strPassword.AllocSysString(); <br>bstrSQL = m_strSQL.AllocSysString(); <br>if ( bstrSource == NULL || bstrUser == NULL || bstrSQL == NULL ) <br>goto ErrorExit; <br> <br>hr = m_piConnection-&gt;Open( bstrSource, bstrUser, bstrPassword );  <br> if (FAILED(hr))goto ErrorExit; <br> <br> <br>  hr = CoCreateInstance(CLSID_CADORecordset, NULL, CLSCTX_INPROC_SERVER, IID_IADORecordset, (LPVOID *)&amp;m_piEmpRecordSet); <br>if (FAILED(hr))goto ErrorExit; <br> <br>hr = m_piEmpRecordSet-&gt;put_Source(bstrSQL); <br>if (FAILED(hr))goto ErrorExit; <br> <br>hr = m_piEmpRecordSet-&gt;putref_ActiveConnection(m_piConnection); <br>if (FAILED(hr))goto ErrorExit; <br> <br>vNull.vt = VT_ERROR; <br>vNull.scode = DISP_E_PARAMNOTFOUND; <br>hr = m_piEmpRecordSet-&gt;Open(vNull, vNull, adOpenKeyset, adLockOptimistic, adCmdUnknown); <br>if (FAILED(hr))goto ErrorExit; <br>} <br> <br>// Perform the two GetRows functions <br>hr = DoGetRows(); <br> if (FAILED(hr))goto ErrorExit; <br> <br>// Reset the recordset <br>m_piEmpRecordSet-&gt;MoveFirst(); <br> <br>SysFreeString(bstrSource); <br>SysFreeString(bstrUser);  <br>SysFreeString(bstrPassword); <br>SysFreeString(bstrSQL); <br> <br>return ; <br> <br>ErrorExit: <br>TCHAR szBuf[256]; <br>wsprintf(szBuf, _T("Error: %d \n"), hr); <br>AfxMessageBox(szBuf); <br> <br>SysFreeString(bstrSource); <br>SysFreeString(bstrUser); <br>SysFreeString(bstrPassword); <br>SysFreeString(bstrSQL); <br>return ; <br>} <br> <br> <br>// Perform standard GetRows against the Employee table <br>HRESULT CGetRowsDlg::DoGetRows()  <br>{ <br>HRESULThr; <br>COleVariantvBookmark, rgvFields; <br>COleVariantcRows; <br>COleVariantvarField, varNewField; <br>CStringstrLBRow; <br>LONGlNumOfCol, lNumRecords; <br>LONGlIndex[2]; <br>CListBox*pListBox = (CListBox *)GetDlgItem(IDD_GETROWSLIST); <br> <br>//Perform GetRows on Employee table <br> <br>//Start from the current place  <br>vBookmark.vt = VT_ERROR; <br>vBookmark.scode = DISP_E_PARAMNOTFOUND; <br> <br>//Get all columns.     <br>rgvFields.vt = VT_ERROR; <br>rgvFields.scode = DISP_E_PARAMNOTFOUND; <br> <br>if (!m_piEmpRecordSet) <br>return E_NOINTERFACE; <br> <br>hr = m_piEmpRecordSet-&gt;GetRows(adGetRowsRest, //MAX_EMP_REC,// non-optional,  <br>vBookmark, <br>rgvFields, <br>&amp;cRows  <br>); <br>if (FAILED(hr)) goto ErrorExit; <br> <br> <br>//Find out how many records were actually retrieved <br>//(SafeArrays are 1-based) <br>lNumOfCol = 2; <br>SafeArrayGetUBound(cRows.parray, 2, &amp;lNumRecords); <br> <br>//Clear the listbox <br>pListBox-&gt;ResetContent(); <br> <br>for (lIndex[1] = 0; lIndex[1] &lt;= lNumRecords; lIndex[1]++) <br>{ <br>strLBRow.Empty();//Clear the string <br> <br>for (lIndex[0] = 0; lIndex[0] &lt;= lNumOfCol; lIndex[0]++)   // get 3 columns <br>{ <br>SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField); <br> <br>hr = VariantChangeType(&amp;varNewField, &amp;varField, 0, VT_BSTR); <br> <br>if(hr == S_OK) <br>{ <br>strLBRow += (LPCWSTR)varNewField.bstrVal; <br>strLBRow += _T(", "); <br>} <br>varField.Clear(); <br>varNewField.Clear(); <br>} <br>pListBox-&gt;AddString(strLBRow); <br>} <br> <br>return hr; <br> <br>ErrorExit: <br>TCHAR szBuf[256]; <br>wsprintf(szBuf, _T("Error: %d \n"), hr); <br>AfxMessageBox(szBuf); <br> <br>return hr; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
