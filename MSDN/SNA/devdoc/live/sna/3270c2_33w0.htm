<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Receiving Messages</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sna_receiving_messages_3270"></a>Receiving Messages</h2>
<h4>For Win32 and OS/2</h4>
<p>
The method for receiving messages from the DMOD is illustrated in the following figure.</p>
<p>
<img src="images/32702a.gif" border=0></p>
<p>
<b>Receiving messages using a routing procedure</b></p>
<p>
After DMOD initialization, the 3270 emulator registers the routing procedure by calling <a href="entrypts_5ucw.htm"><b>sepdrout</b></a>. When the DMOD receives a message, it calls the 3270 emulator routing procedure, which can then process the message.</p>
<p>
With this approach, there is no context switch between the DMOD thread and the 3270 emulator thread. However, the routing procedure must return control to the DMOD fairly quickly. For instance, it cannot suspend waiting for a keyboard input.</p>
<p>
The application must determine whether the received message is for this application or for another application. If the message is not for this application, the routing procedure must return, indicating that the message was not processed. If the application processes the message, it is responsible for freeing the buffer when the processing is finished.</p>
<p>
In some cases, the routing procedure can process the message to completion. An alternative is for the routing procedure to put the message on an application queue and then clear an application semaphore. The application can then subsequently process the message.</p>
<p>
A further performance gain can be achieved by sending a <a href="3270c4_16uo.htm"><b>Status-Resource</b></a> message (to return credit to the local node, allowing it to send further data) from the routing procedure when a message is received, rather than waiting until the message is processed to completion. This usage is illustrated in <a href="3270c2_3re9.htm">Sample Code: Initialization and Routing Procedure</a>. See <a href="3270c3_30q8.htm">Pacing and Chunking</a> for more information on credit and flow control.</p>
<h4>For Windows version 3.<i>x</i></h4>
<p>
If an application wishes to schedule its main (noncallback) part on receipt of a message, it can do so by posting a Windows message to its WndProc.</p>
<h4>For all operating systems</h4>
<p>
Note that after the application has received a message it is responsible for the buffer in which the message was received; it must either reuse the buffer to send a message (using <a href="entrypts_6acw.htm"><b>sbpusend</b></a>) or release it (using <a href="entrypts_36nk.htm"><b>sepdburl</b></a>). If the buffer to be reused does not contain the correct number of elements for the message to be sent, the application can obtain additional elements (using <a href="entrypts_9qpc.htm"><b>sbpibegt</b></a>) or release existing ones (using <a href="entrypts_3aeo.htm"><b>sbpiberl</b></a>); in this case, it must also ensure that the <b>numelts</b> field in the buffer header indicates the correct number of elements.</p>
<p>&nbsp;</p></body>
</HTML>
