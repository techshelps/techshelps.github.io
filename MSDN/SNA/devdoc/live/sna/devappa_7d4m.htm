<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IOCTL Command Summary</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sna_ioctl_command_summary_dev"></a>IOCTL Command Summary</h2>
<p>
The parameters to the IOCTL request packet are stored in the following fields in the associated I/O request packet (IRP).</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=63%>IRP.CurrentStackLocation -&gt; IOControlCode</th>
<th align=left width=37%>Function code</th>
</tr>
<tr valign=top>
<td width=63%><b>IRP.SystemBuffer</b></td>
<td width=37%>Address of parameter buffer (if used)</td>
</tr>
<tr valign=top>
<td width=63%><b>IRP.CurrentStackLocation -&gt; InputBufferLength</b></td>
<td width=37%>Length of parameter buffer</td>
</tr>
<tr valign=top>
<td width=63%><b>IRP.UserBuffer</b></td>
<td width=37%>Address of data buffer</td>
</tr>
<tr valign=top>
<td width=63%><b>IRP.CurrentStackLocation -&gt; OutputBufferLength</b></td>
<td width=37%>Length of data buffer</td>
</tr>
</table><br>
<p>
Note that under Windows NT, the operating system reserves the low nibble of IOCTL function codes to determine the method used to map the various buffers passed on the <b>DeviceIoControl</b> function call into the driver address space. The various options available to device driver writers are:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=21%>Low nibble</th>
<th align=left width=79%>IOCTL definition</th>
</tr>
<tr valign=top>
<td width=21%>0</td>
<td width=79%>METHOD_BUFFERED</td>
</tr>
<tr valign=top>
<td width=21%>1</td>
<td width=79%>METHOD_IN_DIRECT</td>
</tr>
<tr valign=top>
<td width=21%>2</td>
<td width=79%>METHOD_OUT_DIRECT</td>
</tr>
<tr valign=top>
<td width=21%>3</td>
<td width=79%>METHOD_NEITHER</td>
</tr>
</table><br>
<p>
For further details of the memory mapping performed by these various options, refer to the Windows NT DDK documentation.</p>
<p>
For a driver function code of ZZ, using memory mapping code M, the IOCTL code passed on the <b>DeviceIoControl</b> function call is 0xZZM.</p>
<p>
The function codes are set out as shown below. Note that all other function codes will be returned with the error ERROR_INVALID_DEVICE_REQUEST in the field <b>IoStatus.Status</b>. The Windows NT I/O System validates the address and length of the areas passed as parameter and data packets. If the address validation fails, an exception will be raised.</p>
<p>
All requests must return immediately. In general, they are simple, immediate operations, but in the case of Transmit Frame and Receive Frame, the driver must not suspend the calling SNALink thread while waiting for I/O to complete — a relevant return code should be sent instead, allowing the SNALink to retry.</p>
<p>
The complete list of functions is as follows:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=39%>Function</th>
<th align=left width=26%>Function code</th>
<th align=left width=35%>Windows NT IOCTL code</th>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_30hi.htm"><b>Set Event/Semaphore Handle</b></a></td>
<td width=26%>0x41</td>
<td width=35%>0x410</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_1cc6.htm"><b>Set Link Characteristics</b></a></td>
<td width=26%>0x42</td>
<td width=35%>0x420</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_5eeu.htm"><b>Set V24 Output Status</b></a></td>
<td width=26%>0x43</td>
<td width=35%>0x430</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_5c8m.htm"><b>Transmit Frame</b></a></td>
<td width=26%>0x44</td>
<td width=35%>0x441</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_659y.htm"><b>Abort Transmitter</b></a></td>
<td width=26%>0x45</td>
<td width=35%>0x450</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_7e7q.htm"><b>Abort Receiver</b></a></td>
<td width=26%>0x46</td>
<td width=35%>0x460</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_5zcm.htm"><b>Off-Board Load</b></a></td>
<td width=26%>0x47</td>
<td width=35%>0x470</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_2aba.htm"><b>Get/Set Interface Record</b></a></td>
<td width=26%>0x61</td>
<td width=35%>0x613</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_601i.htm"><b>Get V24 Status</b></a></td>
<td width=26%>0x62</td>
<td width=35%>0x622</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_2246.htm"><b>Receive Frame</b></a></td>
<td width=26%>0x63</td>
<td width=35%>0x632</td>
</tr>
<tr valign=top>
<td width=39%><a href="ioctlcmd_0zzq.htm"><b>Read Interface Record</b></a></td>
<td width=26%>0x64</td>
<td width=35%>0x642</td>
</tr>
</table><br>
<p>
In the function descriptions in the following topics, the bit-numbering convention is: The bits in a byte are numbered 0 through 7, where bit 0 is the least significant and bit 7 is the most significant.</p>
<p>
<b>Note</b>  There is no function for the controlling autodialer across the synchronous dumb card interface. This autodial feature is implemented in the link service itself. The Microsoft link services that support the synchronous dumb card interface first perform the dial operation by sending the dial string containing the server-stored number to a COM port rather than the SDLC chip, and then sending a command to the device driver to raise DTR via an Set V24 Output Status IOCTL.</p>
<p>&nbsp;</p></body>
</HTML>
