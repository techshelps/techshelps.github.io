<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Receiving Data</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sna_receiving_data_cpic"></a>Receiving Data</h2>
<p>
The following calls or extensions allow a program to receive data from its partner program.
<dl>
<dt>
<a href="cpic03_3vhf.htm"><b>Receive</b></a> (<b>cmrcv</b>)</dt>
<dd>
Issuing this call while the conversation is in RECEIVE state causes the local program to receive any data that is currently available from the partner program. If no data is available and the receive type is set to CM_RECEIVE _AND_WAIT, the local program waits for data to arrive. If the receive type is set to CM_RECEIVE_IMMEDIATE, the program does not wait.
<p>
Issuing this call while the conversation is in SEND or SEND_PENDING state is allowed only if the receive type is set to CM_RECEIVE_AND_WAIT. This flushes the LU's send buffer and changes the conversation state to RECEIVE. The local program then begins to receive data.
</dd>
<dt>
<a href="cpic03_12qr.htm"><b>Set_Fill</b></a> (<b>cmsf</b>)</dt>
<dd>
Used in a basic conversation, this call sets the conversation's fill type, which specifies whether programs will receive data in the form of logical records or as a specified length of data. This call has an effect only in basic conversations. The fill value affects all subsequent <b>Receive</b> calls. It can be changed by reissuing <b>Set_Fill</b>.</dd>
<dt>
<a href="cpic03_5uoz.htm"><b>Set_Processing_Mode</b></a> (<b>cmspm</b>)</dt>
<dd>
Specifies for the conversation whether subsequent calls will be returned when the operation they have requested is complete (blocking) or immediately after the operation is initiated (nonblocking). A program is notified of the completion of nonblocking calls when it issues <a href="cpic03_6un7.htm"><b>Wait_For_Conversation</b></a> or through a Windows message sent to a  WndProc identified by the <i>hwndNotify</i> parameter in <b>Specify_Windows_Handle</b>.</dd>
<dt>
<a href="cpic03_919f.htm"><b>Set_Receive_Type</b></a> (<b>cmsrt</b>)</dt>
<dd>
Sets the conversation's receive type, which specifies whether a program issuing a <b>Receive</b> call will wait for data to arrive if data is not available. The receive type value affects all subsequent <b>Receive</b> calls. It can be changed by reissuing <b>Set_Receive_Type</b>.</dd>
<dt>
<a href="cpic03_3kir.htm"><b>Specify_Windows_Handle</b></a> (<b>xchwnd</b>)</dt>
<dd>
Sets the window handle to which a message is sent on completion of an operation in nonblocking mode. An application can set the processing mode by calling <b>Set_Processing_Mode</b>. If the window handle is set to NULL or this call is never issued, then the application must call <b>Wait_For_Conversation</b> to be notified when the outstanding operation completes.</dd>
<dt>
<a href="cpic04_4l2b.htm"><b>WinCPICSetBlockingHook</b></a></dt>
<dd>
Allows a Windows CPI-C implementation to block CPI-C function calls by means of a new function. This call must be explicitly issued for Windows version 3.<i>x</i> applications to make blocking calls without blocking the rest of the system.
<p>
A Windows CPI-C implementation has a default mechanism by which blocking CPI-C functions are implemented. This function enables the application to execute its own function at blocking time in place of the default function.

</dd>
</dl>
<p>&nbsp;</p></body>
</HTML>
