<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Status-Acknowledge(Ack)</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_sna_status_acknowledge_ack__3270"></a>Status-Acknowledge(Ack)</h1>
<p>
The <b>Status-Acknowledge(Ack)</b> message flows from the node to the application and from the application to the node, and is used with both SSCP and PLU connections.</p>
<p>
The following structure shows the message format for all SSCP messages and for PLU messages flowing from the node to the application.</p>
<pre><code>struct Status-Acknowledge(Ack) {
    PTRBFHDR  nxtqptr;
    PTRBFELT  hdreptr;
    CHAR      numelts;
    CHAR      msgtype;
    CHAR      srcl;
    CHAR      srcp;
    INTEGER   srci;
    CHAR      destl;
    CHAR      destp;
    INTEGER   desti;
    CHAR      sfhdr.stackhdr.akstat;
    CHAR      sfhdr.stackhdr.akqual;
    INTEGER   sfhdr.stackhdr.akmsgkey;
    CHAR      sfhdr.stackhdr.akflags1;
    CHAR      sfhdr.stackhdr.akflags2;
    INTEGER   sfhdr.stackhdr.aknumb1;
    INTEGER   sfhdr.stackhdr.aknumb2;
    INTEGER   sfhdr.stackhdr.akseqno;
}; 
<b> </b></code></pre>
<p>
<b>LUA only (see Remarks):<br>
Element</b></p>
<pre><code>struct Status-Acknowledge(Ack) {
    PTRBFELT   hdreptr-&gt;elteptr;
    INTEGER    hdreptr-&gt;startd;
    INTEGER    hdreptr-&gt;endd;
    CHAR       hdreptr-&gt;trpad;
    CHAR[268]  hdreptr-&gt;dataru;
}; 
 </code></pre>
<h4>Members</h4>
<dl>
<dt>
<b>nxtqptr</b></dt>
<dd>
Pointer to next buffer header.</dd>
<dt>
<b>hdreptr</b></dt>
<dd>
Pointer to buffer element (NIL if not using LUA).</dd>
<dt>
<b>numelts</b></dt>
<dd>
Number of buffer elements (0x00 if not using LUA).</dd>
<dt>
<b>msgtype</b></dt>
<dd>
Message type STATFMI (0x21).</dd>
<dt>
<b>srcl</b></dt>
<dd>
Source locality.</dd>
<dt>
<b>srcp</b></dt>
<dd>
Source partner.</dd>
<dt>
<b>srci</b></dt>
<dd>
Source index.</dd>
<dt>
<b>destl</b></dt>
<dd>
Destination locality.</dd>
<dt>
<b>destp</b></dt>
<dd>
Destination partner.</dd>
<dt>
<b>desti</b></dt>
<dd>
Destination index.</dd>
<dt>
<b>sfhdr.stackhdr.akstat</b></dt>
<dd>
Status type ACK (0x01).</dd>
<dt>
<b>sfhdr.stackhdr.akqual</b></dt>
<dd>
Acknowledgment type ACKPOS (0x02).</dd>
<dt>
<b>sfhdr.stackhdr.akmsgkey</b></dt>
<dd>
Message key.</dd>
<dt>
<b>sfhdr.stackhdr.akflags1</b></dt>
<dd>
Application flag 1.</dd>
<dt>
<b>sfhdr.stackhdr.akflags2</b></dt>
<dd>
Application flag 2.</dd>
<dt>
<b>sfhdr.stackhdr.aknumb1</b></dt>
<dd>
Undefined.</dd>
<dt>
<b>sfhdr.stackhdr.aknumb2</b></dt>
<dd>
Reserved.</dd>
<dt>
<b>sfhdr.stackhdr.akseqno</b></dt>
<dd>
SNA sequence number.
</dd>
</dl>
<p>
<b>LUA only (see Remarks):<br>
Element</b>
<dl>
<dt>
<b>hdreptr–&gt;elteptr</b></dt>
<dd>
Pointer to buffer element (NIL).</dd>
<dt>
<b>hdreptr–&gt;startd</b></dt>
<dd>
Start of data in this buffer element
<p>
13 or<br>
10 for second and subsequent segments of outbound segmented RUs 
</dd>
<dt>
<b>hdreptr–&gt;endd</b></dt>
<dd>
End of data in this buffer element.</dd>
<dt>
<b>hdreptr–&gt;trpad</b></dt>
<dd>
Reserved.</dd>
<dt>
<b>hdreptr–&gt;dataru</b></dt>
<dd>
Data RU.
</dd>
</dl>
<p>
The message format for PLU messages flowing from the application to the node is identical to the preceding format, except that the application flag 1 and application flag 2 fields are not used. They are replaced by the following INTEGER field:
<dl>
<dt>
<b>sfhdr.stackhdr.akmsgtim</b></dt>
<dd>
Last host response time
<p>
0xFFFF - no response time measured<br>
0x<i>nnnn</i> - last response time measured, in units of 0.1 second

</dd>
</dl>
<h4>Remarks</h4>
<ul>
<li>
The message key and application flags reflect the message key and application flags of the data message to which this is an acknowledgment (see note on LUA below).</li>
<li>
For outbound <b>Status-Acknowledge(Ack)</b> messages from the local node to the application, the SNA sequence number gives the sequence number of the inbound data message to which this is an acknowledgment (see note on LUA below); it is normally used only by TS profile 4 applications.</li>
<li>
For inbound <b>Status-Acknowledge(Ack)</b> messages from the application to the local node, the SNA sequence number reflects the sequence number of the outbound data message to which this is an acknowledgment.</li>
<li>
If the host specified that response time statistics are to be maintained (see <a href="3270c3_19m8.htm">RTM Parameters</a> and <a href="3270c3_5m5s.htm">Response Time Monitor Data</a> for details), the application is responsible for measuring and reporting response times to the local node, using the <b>akmsgtim</b> field of this message.</li>
<li>
If the application is using the LUA variant of the FMI (see <a href="3270c3_886o.htm">FMI Concepts</a>), the TH and (if appropriate) RH are included in the data, and the <b>startd</b> field points to the TH. The <b>akmsgkey</b>, <b>akflags1</b>, and <b>akflags2</b> fields are undefined and should not be used; the corresponding data from the element should be used instead. The <b>akseqno</b> field is similarly undefined on messages from the local node to the application; it must be set on messages from the application to the local node. The <b>akseqno</b> field is used to hold the sequence number of the request being acknowledged.</li>
<li>
If the application is not using the LUA variant of the FMI, the message consists of a buffer header only; there is no buffer element.</li>
</ul>
<p>&nbsp;</p></body>
</HTML>
