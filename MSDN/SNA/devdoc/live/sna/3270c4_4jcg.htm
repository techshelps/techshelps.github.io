<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Open(SSCP) Request</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_sna_open_sscp_request_3270"></a>Open(SSCP) Request</h1>
<p>
The <b>Open(SSCP) Request</b> message flows from the application to the node. It is used with an SSCP connection.</p>
<pre><code>struct Open(SSCP) Request {
    PTRBFHDR  nxtqptr;
    PTRBFELT  hdrept;
    CHAR      numelts;
    CHAR      msgtype;
    CHAR      srcl;
    CHAR      srcp;
    INTEGER   srci;
    CHAR      destl;
    CHAR      destp;
    INTEGER   desti;
    CHAR      ophdr.openqual;
    CHAR      ophdr.opentype;
    CHAR      ophdr.appltype;
    CHAR      ophdr.opluno;
    INTEGER   ophdr.opresid;
    INTEGER   ophdr.icreditr;
    INTEGER   ophdr.icredits;
    CHAR      ophdr.opninfo1;
    CHAR      ophdr.opnpad1;
}; 
<i> </i></code></pre>
<p>
<b>Element 1</b></p>
<pre><code>struct Open(SSCP) Request {
    PTRBFELT   hdreptr-&gt;elteptr;
    INTEGER    hdreptr-&gt;startd;
    INTEGER    hdreptr-&gt;endd;
    CHAR       hdreptr-&gt;trpad;
    CHAR[268]  hdreptr-&gt;dataru;
};
 </code></pre>
<p>
<b>Element 2</b></p>
<pre><code>struct Open(SSCP) Request {
    PTRBFELT  hdreptr-&gt;elteptr-&gt;elteptr;
    INTEGER   hdreptr-&gt;elteptr-&gt;startd;
    INTEGER   hdreptr-&gt;elteptr-&gt;endd;
    CHAR      hdreptr-&gt;elteptr-&gt;trpad;
    CHAR[268] hdreptr-&gt;elteptr-&gt;dataru;
};
 </code></pre>
<h4>Members</h4>
<dl>
<dt>
<b>nxtqptr</b></dt>
<dd>
Pointer to next buffer header.</dd>
<dt>
<b>hdrept</b></dt>
<dd>
Pointer to first buffer element.</dd>
<dt>
<b>numelts</b></dt>
<dd>
Number of buffer elements  (0x02).</dd>
<dt>
<b>msgtype</b></dt>
<dd>
Message type OPENMSG  (0x01).</dd>
<dt>
<b>srcl</b></dt>
<dd>
Source locality.</dd>
<dt>
<b>srcp</b></dt>
<dd>
Source partner (see Remarks).</dd>
<dt>
<b>srci</b></dt>
<dd>
Source index.</dd>
<dt>
<b>destl</b></dt>
<dd>
Destination locality.</dd>
<dt>
<b>destp</b></dt>
<dd>
Destination partner.</dd>
<dt>
<b>desti</b></dt>
<dd>
Destination index.</dd>
<dt>
<b>ophdr.openqual</b></dt>
<dd>
Open qualifier REQU  (0x01).</dd>
<dt>
<b>ophdr.opentype</b></dt>
<dd>
Open type SSCPSEC  (0x01).</dd>
<dt>
<b>ophdr.appltype</b></dt>
<dd>
Application program interface type
<p>
FMI without chunking    (0x02)<br>
FMI with chunking        (0x82) (see Remarks).
</dd>
<dt>
<b>ophdr.opluno</b></dt>
<dd>
Logical unit number (see Remarks).</dd>
<dt>
<b>ophdr.opresid</b></dt>
<dd>
Resource identifier.</dd>
<dt>
<b>ophdr.icreditr</b></dt>
<dd>
Reserved.</dd>
<dt>
<b>ophdr.icredits</b></dt>
<dd>
Reserved.</dd>
<dt>
<b>ophdr.opninfo1</b></dt>
<dd>
Reserved.</dd>
<dt>
<b>ophdr.opnpad1</b></dt>
<dd>
Open force type (see Remarks)
<p>
OPEN_TEST       (0x00)<br>
OPEN_FORCE    (0x01)

</dd>
</dl>
<p>
<b>Element 1</b>
<dl>
<dt>
<b>hdreptr–&gt;elteptr</b></dt>
<dd>
Pointer to next buffer element.</dd>
<dt>
<b>hdreptr–&gt;startd</b></dt>
<dd>
Start of data in this buffer element (1).</dd>
<dt>
<b>hdreptr–&gt;endd</b></dt>
<dd>
End of data in this buffer element.</dd>
<dt>
<b>hdreptr–&gt;trpad</b></dt>
<dd>
Reserved (1 byte).</dd>
<dt>
<b>hdreptr–&gt;dataru</b></dt>
<dd>
Data RU, as follows:
<dl>
<dt>
<b>dataru[0–9]</b></dt>
<dd>
Source name. Should be filled with blanks.</dd>
<dt>
<b>dataru[10–19</b><i>]</i></dt>
<dd>
Destination name. Set to the LU you want to communicate with.</dd>
<dt>
<b>dataru[20]</b></dt>
<dd>
Sense 4003 flag.</dd>
<dt>
<b>dataru[21]</b></dt>
<dd>
Sense 4004 flag.</dd>
<dt>
<b>dataru[22]</b></dt>
<dd>
Sense 4006 flag.</dd>
<dt>
<b>dataru[23]</b></dt>
<dd>
Sense 4007 flag.</dd>
<dt>
<b>dataru[24]</b></dt>
<dd>
Sense 4009 flag.</dd>
<dt>
<b>dataru[25]</b></dt>
<dd>
Sense 400A flag.</dd>
<dt>
<b>dataru[26]</b></dt>
<dd>
Sense 400B flag.</dd>
<dt>
<b>dataru[27]</b></dt>
<dd>
Sense 400C flag.</dd>
<dt>
<b>dataru[28]</b></dt>
<dd>
Sense 400D flag.</dd>
<dt>
<b>dataru[29]</b></dt>
<dd>
Sense 400F flag.</dd>
<dt>
<b>dataru[30]</b></dt>
<dd>
Sense 4011 flag.</dd>
<dt>
<b>dataru[31]</b></dt>
<dd>
Sense 4012 flag .</dd>
<dt>
<b>dataru[32]</b></dt>
<dd>
Sense 4014 flag .</dd>
<dt>
<b>dataru[33]</b></dt>
<dd>
High priority indicator
<p>
HIGH    (0x01)<br>
LOW    (0x02)
</dd>
<dt>
<b>dataru[34]</b></dt>
<dd>
LUA supported indicator
<p>
Supported          (0x01)<br>
Not supported    (0x00)
</dd>
<dt>
<b>dataru[35–36]</b></dt>
<dd>
Chunk size obtained from DMOD (see Remarks).</dd>
<dt>
<b>dataru[37]</b></dt>
<dd>
Segment delivery option
<p>
Do not deliver RU segments    (0x00)<br>
Deliver RU segments              (0x01)
</dd>
<dt>
<b>dataru[38]</b></dt>
<dd>
HLLAPI session identifier (see Remarks).
</dd>
</dl>
</dd>
</dl>
<p>
<b>Element 2</b>
<dl>
<dt>
<b>hdreptr–&gt;elteptr–&gt;elteptr</b></dt>
<dd>
Pointer to next buffer element (NIL). </dd>
<dt>
<b>hdreptr–&gt;elteptr–&gt;startd</b></dt>
<dd>
Start of data in this buffer element (1). </dd>
<dt>
<b>hdreptr–&gt;elteptr–&gt;endd</b></dt>
<dd>
End of data in this buffer element.</dd>
<dt>
<b>hdreptr–&gt;elteptr–&gt;trpad</b></dt>
<dd>
Reserved.</dd>
<dt>
<b>hdreptr–&gt;elteptr–&gt;dataru</b></dt>
<dd>
Data RU, as follows: 
<dl>
<dt>
<b>dataru[0]</b></dt>
<dd>
ASCII string identifying the 3270 emulator (see Remarks).
</dd>
</dl>
</dd>
</dl>
<h4>Remarks</h4>
<ul>
<li>
The <b>Open(SSCP) Request</b> message consists of a buffer header and two buffer elements.</li>
<li>
The source L value, the destination LPI values, and the source name are reserved.</li>
<li>
For a 3270 emulator, the source P value must be set to S3PROD (0x12), which identifies the application as a 3270 emulator. The destination name should be set to the LU name or pool name taken from the 3270 user record (right-filled with ASCII spaces if fewer than 10 characters).</li>
<li>
An LUA application uses the source P value LUAPROD (0x1D). This is independent of the value of the LUA supported indicator (see below), which selects the LUA variant of the FMI.</li>
<li>
The SNS4003 to SNS4014 fields together with the high priority indicator are referred to in the text (see <a href="3270c3_425s.htm">Opening the SSCP Connection</a>) as the SSCP connection information control block (CICB). A value of 0x00 indicates that the DFC receive check corresponding to the sense code is not supported for this LU. A value of 0x01 indicates that it is supported. Note that the corresponding send checks are always performed regardless of these values.</li>
<li>
The LU number is only used internally in the local node on the <b>Open(SSCP) Request</b>. It is generated from the destination name in the first element.</li>
<li>
The open force type field is used when locating resources across more than one server and for automatic activation of connections when the application wishes to use an LU for which the connection is inactive. The application does not need to set this flag; it is used by the DL-BASE. See <a href="3270c3_425s.htm">Opening the SSCP Connection</a> for details.</li>
<li>
The application program interface type field defines whether RU chunking is used from the local node to the application; this may be necessary if large RUs are being used. See <a href="3270c3_30q8.htm">Pacing and Chunking</a> for more information on FMI chunking. This feature is not yet supported in SNA Server but is described here for completeness because support is planned for a future version.</li>
<li>
The chunk size field (at <b>dataru[35]</b>) is an integer value.</li>
<li>
The segment delivery option specifies whether the local node should deliver segments of RUs to the application as soon as they are received or should assemble whole RUs before delivering them to the application. Segment delivery allows the application to update the user's screen as soon as data is received ("window shading"), which can result in a faster perceived response. See <a href="3270c3_9vg0.htm">Segment Delivery</a> for more information. This option is required only when chunking is being used; it is included on this message so that the local node can calculate the initial chunk credit values on the corresponding PLU connection. The option must still be set on the <b>Open(PLU) Response</b>; the setting specified on that message will override the one specified here if there is a conflict. If this happens, the initial credit values may not be suitable.</li>
<li>
The LUA supported indicator specifies whether the application uses the LUA variant of the FMI.</li>
<li>
If the element is shorter than (s+34) bytes, SNA Server assumes no LUA and no chunking. This ensures backward compatibility with previous versions of the local node software in which these options were not available.</li>
<li>
The HLLAPI session identifier is a single ASCII character that identifies the 3270 display session to which the <b>Open(SSCP)</b> applies. HLLAPI uses this to identify a particular 3270 presentation space to which an HLLAPI function refers; it is also referred to by 3270 as the session's short name, or by HLLAPI as the presentation space identifier (PS identifier). If the 3270 emulator does not support session identifiers, this field should be set to zero.</li>
<li>
The second element contains an ASCII string that you can use to identify the type of 3270 emulator, such as "Select SNA Server OS/2 3270." This string will be logged in the audit log file by the client's DL-BASE and can also be seen in traces. The <b>startd</b> and <b>endd</b> fields must be set up to define the limits of this string.</li>
</ul>
<p>&nbsp;</p></body>
</HTML>
