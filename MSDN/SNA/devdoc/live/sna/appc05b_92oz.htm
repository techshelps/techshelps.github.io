<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RECEIVE_AND_POST</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_sna_receive_and_post_appc"></a>RECEIVE_AND_POST</h1>
<p>
The <b>RECEIVE_AND_POST</b> verb receives application data and status information asynchronously. This allows the local TP to proceed with processing while data is still arriving at the local LU.</p>
<p>
<b>RECEIVE_AND_POST</b> is only supported under the Microsoft® Windows NT®, Microsoft® Windows® 95, and OS/2 operating systems. For similar functionality under the Windows version 3.<i>x</i> graphical environment, use <a href="appc05b_19er.htm"><b>RECEIVE_AND_WAIT</b></a> in conjunction with <a href="appc06_66sj.htm"><b>WinAsyncAPPC</b></a>. Specifically, while an asynchronous<b> RECEIVE_AND_POST</b> is outstanding, the following verbs can be issued on the same conversation:</p>
<p class=indent1>
<a href="appc05a_4ndv.htm"><b>DEALLOCATE</b></a><b> </b>(AP_ABEND_PROG, AP_ABEND_SVC, or AP_ABEND_TIMER)</p>
<p class=indent1>
<a href="appc05a_5o0z.htm"><b>GET_ATTRIBUTES</b></a></p>
<p class=indent1>
<a href="appc05a_4nab.htm"><b>GET_TYPE</b></a></p>
<p class=indent1>
<a href="appc05b_54kj.htm"><b>REQUEST_TO_SEND</b></a></p>
<p class=indent1>
<a href="appc05b_1azn.htm"><b>SEND_ERROR</b></a></p>
<p class=indent1>
<a href="appc05b_8kf7.htm"><b>TEST_RTS</b></a></p>
<p class=indent1>
<a href="appc04_8k0z.htm"><b>TP_ENDED</b></a></p>
<p>
This allows an application to use an asynchronous <b>RECEIVE_AND_POST</b> to receive data. While the <b>RECEIVE_AND_POST</b> is outstanding, it can still use <b>SEND_ERROR</b> and <b>REQUEST_TO_SEND</b>. It is recommended that you use this feature for full asynchronous support. For information on how a TP receives data and how to use this verb, see Remarks in this topic.</p>
<p>
The following structure describes the verb control block used by the <b>RECEIVE_AND_POST</b> verb.</p>
<pre><code>struct receive_and_post {
    unsigned short      opcode;
    unsigned char       opext;
    unsigned char       reserv2;
    unsigned short      primary_rc;
    unsigned long       secondary_rc;
    unsigned char       tp_id[8];
    unsigned long       conv_id;
    unsigned short      what_rcvd;
    unsigned char       rtn_status;
    unsigned char       fill;
    unsigned char       rts_rcvd;
    unsigned char       reserv4;
    unsigned short      max_len;
    unsigned short      dlen;
    unsigned char FAR * dptr;
    unsigned char FAR * sema;
    unsigned char       reserv5;
}; 
 </code></pre>
<h4>Members</h4>
<dl>
<dt>
<b>opcode</b></dt>
<dd>
Supplied parameter. Specifies the verb operation code, AP_B_RECEIVE_AND_POST.</dd>
<dt>
<b>opext</b></dt>
<dd>
Supplied parameter. Specifies the verb operation extension, AP_BASIC_CONVERSATION.</dd>
<dt>
<b>primary_rc</b></dt>
<dd>
Returned parameter. Specifies the primary return code set by APPC at the completion of the verb. The valid return codes vary depending on the APPC verb issued. See Return Codes for valid error codes for this verb.</dd>
<dt>
<b>secondary_rc</b></dt>
<dd>
Returned parameter. Specifies the secondary return code set by APPC at the completion of the verb. The valid return codes vary depending on the APPC verb issued. See Return Codes for valid error codes for this verb.</dd>
<dt>
<b>tp_id</b></dt>
<dd>
Supplied parameter. Identifies the local TP. The value of this parameter is returned by <a href="appc04_0fs3.htm"><b>TP_STARTED</b></a> in the invoking TP or by<b> <a href="appc05b_0m77.htm">RECEIVE_ALLOCATE</a></b> in the invoked TP.</dd>
<dt>
<b>conv_id</b></dt>
<dd>
Supplied parameter. Provides the conversation identifier. The value of this parameter is returned by <a href="appc05a_1ckj.htm"><b>ALLOCATE</b></a><b> </b>in the invoking TP or by <b>RECEIVE_ALLOCATE</b> in the invoked TP.</dd>
<dt>
<b>what_rcvd</b></dt>
<dd>
Returned parameter. Indicates whether data or conversation status was received.
<ul>
<li>
ap_confirm_deallocate indicates that the partner TP issued <a href="appc05a_4ndv.htm"><b>DEALLOCATE</b></a> with <b>dealloc_type</b> set to AP_SYNC_LEVEL. The conversation's synchronization level, established by <a href="appc05a_1ckj.htm"><b>ALLOCATE</b></a>, is AP_CONFIRM_SYNC_LEVEL. Upon receiving this value, the local TP normally issues <a href="appc05a_53z7.htm"><b>CONFIRMED</b></a>.</li>
<li>
ap_confirm_send indicates that the partner TP issued <a href="appc05b_9aar.htm"><b>PREPARE_TO_RECEIVE</b></a> with <b>ptr_type</b> set to AP_SYNC_LEVEL. The conversation's synchronization level, established by <b>ALLOCATE</b>, is AP_CONFIRM_SYNC_LEVEL. Upon receiving this value, the local TP normally issues <b>CONFIRMED</b>, and begins to send data.</li>
<li>
ap_confirm_what_received indicates that the partner TP issued <a href="appc05a_4i1v.htm"><b>CONFIRM</b></a>. Upon receiving this value, the local TP normally issues <b>CONFIRMED</b>.</li>
<li>
ap_data indicates that this value can be returned by <b>RECEIVE_AND_POST</b> if <b>fill </b>is set to AP_BUFFER. The local TP received data until <b>max_len</b> or the end of the data was reached. For more information, see Remarks in this topic.</li>
<li>
ap_data_complete indicates, for <b>RECEIVE_AND_POST</b>, that the local TP has received a complete data record or the last part of a data record.<p>
For <b>RECEIVE_AND_POST</b> with <b>fill</b> set to AP_LL, this value indicates that the local TP has received a complete logical record or the end of a logical record.
<p>
Upon receiving this value, the local TP normally reissues <b>RECEIVE_AND_POST</b> or issues another receive verb. If the partner TP has sent more data, the local TP begins to receive a new unit of data.
<p>
Otherwise, the local TP examines status information.
<p>
If <b>primary_rc</b> contains ap_ok and <b>what_rcvd</b> contains AP_SEND, AP_CONFIRM_SEND, AP_CONFIRM_DEALLOCATE, or AP_CONFIRM_WHAT_RECEIVED, see the description of the value (in this section) for the next action the local TP normally takes.
<p>
If <b>primary_rc</b> contains AP_DEALLOC_NORMAL, the conversation has been deallocated in response to the <a href="appc05a_4okj.htm"><b>DEALLOCATE</b></a> issued by the partner TP.
</li>
<li>
ap_data_incomplete indicates, for <b>RECEIVE_AND_POST</b>, that the local TP has received an incomplete data record. The <b>max_len</b> parameter specified a value less than the length of the data record (or less than the remainder of the data record if this is not the first receive verb to read the record).<p>
For <b>RECEIVE_AND_POST</b> with <b>fill</b> set to AP_LL, this value indicates that the local TP has received an incomplete logical record.
<p>
Upon receiving this value, the local TP normally reissues <b>RECEIVE_AND_POST</b> (or issues another receive verb) to receive the next part of the record.
</li>
<li>
ap_none indicates that the TP did not receive data or conversation status indicators.</li>
<li>
ap_send indicates, for the partner TP, that the conversation has entered RECEIVE state. For the local TP, the conversation is now in SEND state. Upon receiving this value, the local TP normally uses <a href="appc05b_8iub.htm"><b>SEND_DATA</b></a> to begin sending data.</li>
</ul>
</dd>
<dt>
<b>rtn_status</b></dt>
<dd>
Supplied parameter. Indicates whether both data and conversation status indicators should be returned within one API call.
<ul>
<li>
AP_NO specifies that indicators should be returned individually on separate invocations of the verb.</li>
<li>
AP_YES specifies that indicators should be returned together, provided both are available. Both can be returned when:<p>
The receive buffer is large enough to hold all of the data that precedes the status indicator.
<p>
The <b>fill</b> parameter specifies BUFFER or LL, and the data is the last logical record before the status indicator.
</li>
</ul>
</dd>
<dt>
<b>fill</b></dt>
<dd>
Supplied parameter. Specifies how the local TP receives data.
<p>
Use AP_BUFFER to indicate that the local TP receives data until the number of bytes specified by <b>max_len</b> is reached or until end of data. Data is received without regard for the logical-record format.

<p>
Use AP_LL to indicate that data is received in logical-record format. The data received can be:

<ul>
<li>
A complete logical record.</li>
<li>
A <b>max_len</b> byte portion of a logical record.</li>
<li>
The end of a logical record<b>.</b></li>
</ul>
</dd>
<dt>
<b>rts_rcvd</b></dt>
<dd>
Returned parameter. Indicates whether the partner TP issued <a href="appc05b_0737.htm"><b>REQUEST_TO_SEND</b></a>. Possible values are:
<ul>
<li>
ap_yes indicates that the partner TP issued <b>REQUEST_TO_SEND</b>, which requests that the local TP change the conversation to RECEIVE state.</li>
<li>
ap_no indicates that the partner TP has not issued <b>REQUEST_TO_SEND</b>.</li>
</ul>
</dd>
<dt>
<b>max_len</b></dt>
<dd>
Supplied parameter. Specifies the maximum number of bytes of data the local TP can receive. The range is from 0 through 65535.
<p>
The value must not exceed the length of the buffer to contain the received data. The offset of <b>dptr</b> plus the value of <b>max_len</b> must not exceed the size of the data segment.
</dd>
<dt>
<b>dlen</b></dt>
<dd>
Returned parameter. Specifies the number of bytes of data received. Data is stored in the buffer specified by <b>dptr</b>. A length of zero indicates that no data was received.</dd>
<dt>
<b>dptr</b></dt>
<dd>
Supplied parameter. Provides the address of the buffer to contain the data received by the local LU.
<p>
For the Windows NT and Windows 95 operating systems, the data buffer can reside in a static data area or in a globally allocated area. The data buffer must fit entirely within this area.

<p>
For the OS/2 operating system, the data buffer must reside on an unnamed, shared segment, which is allocated by the <b>DosAllocSeg</b> function with <b>Flags</b> equal to 1. The data buffer must fit entirely on the data segment.
</dd>
<dt>
<b>sema</b></dt>
<dd>
Supplied parameter. Provides the address of the semaphore that APPC is to clear when the asynchronous receiving operation is finished. On OS/2, the <b>sema</b> parameter is either a RAM or system semaphore. On Windows NT and Windows 95, the <b>sema</b> parameter is an event handle obtained by calling either the <b>CreateEvent</b> or <b>OpenEvent</b> Win32® function.
</dd>
</dl>
<h4>Return Codes</h4>
<dl>
<dt>
ap_ok</dt>
<dd>
Primary return code; the verb executed successfully.</dd>
</dl>
<p>
When <b>rtn_status</b> is ap_yes, the preceding return code or one of the following return codes can be returned.
<dl>
<dt>
ap_data_complete_send</dt>
<dd>
Primary return code; this is a combination of ap_data_complete and ap_send.</dd>
<dt>
ap_data_complete_confirm_send</dt>
<dd>
Primary return code; this is a combination of ap_data_complete and ap_confirm_send.</dd>
<dt>
ap_data_complete_confirm</dt>
<dd>
Primary return code; this is a combination of ap_data_complete and ap_confirm_what_received.</dd>
<dt>
ap_data_complete_confirm_deall</dt>
<dd>
Primary return code; this is a combination of ap_data_complete and ap_confirm_deallocate.</dd>
<dt>
AP_DATA_SEND</dt>
<dd>
Primary return code; this is a combination of ap_data and ap_send.</dd>
<dt>
AP_DATA_CONFIRM_SEND</dt>
<dd>
Primary return code; this is a combination of ap_data and ap_confirm_send.</dd>
<dt>
AP_DATA_CONFIRM</dt>
<dd>
Primary return code; this is a combination of ap_data and ap_confirm.</dd>
<dt>
AP_DATA_CONFIRM_DEALLOCATE</dt>
<dd>
Primary return code; this is a combination of ap_data and ap_confirm_deallocate.
</dd>
<dt>
ap_dealloc_normal</dt>
<dd>
Primary return code; the partner TP issued <a href="appc05a_4ndv.htm"><b>DEALLOCATE</b></a> with <b>dealloc_type</b> set to AP_FLUSH or AP_SYNC_LEVEL with the synchronization level of the conversation specified as AP_NONE.
<p>
If <b>rtn_status</b> is AP_YES, examine <b>what_rcvd</b> also.
</dd>
<dt>
ap_parameter_check</dt>
<dd>
Primary return code; the verb did not execute because of a parameter error.
<dl>
<dt>
ap_bad_conv_id</dt>
<dd>
Secondary return code; the value of <b>conv_id</b> did not match a conversation identifier assigned by APPC.</dd>
<dt>
ap_bad_tp_id</dt>
<dd>
Secondary return code; the value of <b>tp_id</b> did not match a TP identifier assigned by APPC.</dd>
<dt>
ap_bad_return_status_with_data</dt>
<dd>
Secondary return code; the specified <b>rtn_status</b> value was not recognized by APPC.</dd>
<dt>
ap_invalid_data_segment</dt>
<dd>
Secondary return code; the length specified for the data buffer was longer than the segment allocated to contain the buffer.</dd>
<dt>
ap_invalid_semaphore_handle</dt>
<dd>
Secondary return code; the address of the RAM semaphore or system semaphore handle was invalid.

<p>
<b>Note  </b>APPC cannot trap all invalid semaphore handles. If the TP passes a bad RAM semaphore handle, a protection violation results.

</dd>
<dt>
ap_rcv_and_post_bad_fill</dt>
<dd>
Secondary return code; the <b>fill</b> parameter was set to an invalid value.
</dd>
</dl>
</dd>
<dt>
ap_state_check</dt>
<dd>
Primary return code; the verb did not execute because it was issued in an invalid state.
<dl>
<dt>
ap_rcv_and_post_bad_state</dt>
<dd>
Secondary return code; the conversation was not in RECEIVE or SEND state when the TP issued this verb.</dd>
<dt>
ap_rcv_and_post_not_ll_bdy</dt>
<dd>
Secondary return code; the conversation was in SEND state; the TP began but did not finish sending a logical record.
</dd>
</dl>
</dd>
<dt>
ap_canceled</dt>
<dd>
Primary return code; the local TP issued one of the following verbs, which canceled <b>RECEIVE_AND_POST</b>:
<p class=indent1>
<a href="appc05a_4ndv.htm"><b>DEALLOCATE</b></a> with <b>dealloc_type</b> set to AP_ABEND_PROG, AP_ABEND_SVC, or AP_ABEND_TIMER</p>

<p class=indent1>
<a href="appc05b_1azn.htm"><b>SEND_ERROR</b></a></p>

<p class=indent1>
<a href="appc04_8k0z.htm"><b>TP_ENDED</b></a></p>

<p>
Issuing one of these verbs causes the semaphore to be cleared.
</dd>
<dt>
ap_allocation_error</dt>
<dd>
Primary return code; APPC has failed to allocate a conversation. The conversation state is set to RESET.
<p>
This code can be returned through a verb issued after <a href="appc05a_38f7.htm"><b>ALLOCATE</b></a>.

<dl>
<dt>
ap_allocation_failure_no_retry</dt>
<dd>
Secondary return code; the conversation cannot be allocated because of a permanent condition, such as a configuration error or session protocol error. To determine the error, the system administrator should examine the error log file. Do not retry the allocation until the error has been corrected.</dd>
<dt>
ap_allocation_failure_retry</dt>
<dd>
Secondary return code; the conversation could not be allocated because of a temporary condition, such as a link failure. The reason for the failure is logged in the system error log. Retry the allocation.</dd>
<dt>
ap_conversation_type_mismatch</dt>
<dd>
Secondary return code; the partner LU or TP does not support the conversation type (basic or mapped) specified in the allocation request.</dd>
<dt>
ap_pip_not_allowed</dt>
<dd>
Secondary return code; the allocation request specified PIP data, but either the partner TP does not require this data, or the partner LU does not support it.</dd>
<dt>
ap_pip_not_specified_correctly</dt>
<dd>
Secondary return code; the partner TP requires PIP data, but the allocation request specified either no PIP data or an incorrect number of parameters.</dd>
<dt>
ap_security_not_valid</dt>
<dd>
Secondary return code; the user identifier or password specified in the allocation request was not accepted by the partner LU.</dd>
<dt>
ap_sync_level_not_supported</dt>
<dd>
Secondary return code; the partner TP does not support the <b>sync_level</b> (AP_NONE or AP_CONFIRM_SYNC_LEVEL) specified in the allocation request, or the <b>sync_level</b> was not recognized.</dd>
<dt>
ap_tp_name_not_recognized</dt>
<dd>
Secondary return code; the partner LU does not recognize the TP name specified in the allocation request.</dd>
<dt>
ap_trans_pgm_not_avail_no_retry</dt>
<dd>
Secondary return code; the remote LU rejected the allocation request because it was unable to start the requested partner TP. The condition is permanent. The reason for the error may be logged on the remote node. Do not retry the allocation until the error has been corrected.</dd>
<dt>
ap_trans_pgm_not_avail_retry</dt>
<dd>
Secondary return code; the remote LU rejected the allocation request because it was unable to start the requested partner TP. The condition may be temporary, such as a time-out. The reason for the error may be logged on the remote node. Retry the allocation.
</dd>
</dl>
</dd>
<dt>
ap_comm_subsystem_abended</dt>
<dd>
Primary return code; indicates one of the following conditions:
<ul>
<li>
The node used by this conversation encountered an ABEND.</li>
<li>
The connection between the TP and the PU 2.1 node has been broken (a LAN error).</li>
<li>
The SnaBase at the TP's computer encountered an ABEND.</li>
</ul>

<p>
The system administrator should examine the error log to determine the reason for the ABEND.
</dd>
<dt>
ap_comm_subsystem_not_loaded</dt>
<dd>
Primary return code; a required component could not be loaded or terminated while processing the verb. Thus, communication could not take place. Contact the system administrator for corrective action.
<p>
When this return code is used with <a href="appc05a_1ckj.htm"><b>ALLOCATE</b></a>, it can indicate that no communications subsystem could be found to support the local LU. (For example, the local LU alias specified with <a href="appc04_0fs3.htm"><b>TP_STARTED</b></a> is incorrect or has not been configured.) Note that if <b>lu_alias</b> or <b>mode_name</b> is fewer than eight characters, you must ensure that these fields are filled with spaces to the right. This error is returned if these parameters are not filled with spaces, since there is no node available that can satisfy the <b>ALLOCATE</b> request.

<p>
When <b>ALLOCATE</b> produces this return code for a Microsoft® SNA Server Client system configured with multiple nodes, there are two secondary return codes as follows:

<dl>
<dt>
0xf0000001</dt>
<dd>
Secondary return code; no nodes have been started.</dd>
<dt>
0x<small>f0000002</small></dt>
<dd>
Secondary return code; at least one node has been started, but the local LU (when <b>TP_STARTED</b> is issued) is not configured on any active nodes. The problem could be either of the following:
<table cellspacing=4 cols=1>
<tr valign=top>
<td width=100%><font face="Symbol">·</font>&nbsp;&nbsp;&nbsp;&nbsp;The node with the local LU is not started.</td>
</tr>
<tr valign=top>
<td width=100%><font face="Symbol">·</font>&nbsp;&nbsp;&nbsp;&nbsp;The local LU is not configured.</td>
</tr>
</table><br>

</dd>
</dl>
</dd>
<dt>
ap_conv_failure_no_retry</dt>
<dd>
Primary return code; the conversation was terminated because of a permanent condition, such as a session protocol error. The system administrator should examine the system error log to determine the cause of the error. Do not retry the conversation until the error has been corrected.</dd>
<dt>
ap_conv_failure_retry</dt>
<dd>
Primary return code; the conversation was terminated because of a temporary error. Restart the TP to see if the problem occurs again. If it does, the system administrator should examine the error log to determine the cause of the error.</dd>
<dt>
ap_conversation_type_mixed</dt>
<dd>
Primary return code; the TP has issued both basic and mapped conversation verbs. Only one type can be issued in a single conversation.</dd>
<dt>
ap_invalid_verb_segment</dt>
<dd>
Primary return code; the VCB extended beyond the end of the data segment.</dd>
<dt>
ap_prog_error_no_trunc</dt>
<dd>
Primary return code; the partner TP issued <a href="appc05b_1azn.htm"><b>SEND_ERROR</b></a> with <b>err_type</b> set to AP_PROG while the conversation was in SEND state. Data was not truncated.</dd>
<dt>
ap_prog_error_purging</dt>
<dd>
Primary return code; while in RECEIVE, PENDING, PENDING_POST (Windows NT, Windows 95, and OS/2 only), CONFIRM, CONFIRM_SEND, or CONFIRM_DEALLOCATE state, the partner TP issued <b>SEND_ERROR</b> with<b> err_type </b>set to AP_PROG. Data sent but not yet received is purged.</dd>
<dt>
ap_prog_error_trunc</dt>
<dd>
Primary return code; in SEND state, after sending an incomplete logical record, the partner TP issued <b>SEND_ERROR</b> with <b>err_type</b> set to AP_PROG. The local TP may have received the first part of the logical record through a receive verb.</dd>
<dt>
ap_stack_too_small</dt>
<dd>
Primary return code; the stack size of the application is too small to execute the verb. Increase the stack size of your application.</dd>
<dt>
ap_conv_busy</dt>
<dd>
Primary return code; there can only be one outstanding conversation verb at a time on any conversation. This can occur if the local TP has multiple threads, and more than one thread is issuing APPC calls using the same <b>conv_id</b>.</dd>
<dt>
ap_unexpected_dos_error</dt>
<dd>
Primary return code; the operating system has returned an error to APPC while processing an APPC call from the local TP. The operating system return code is returned through the <b>secondary_rc</b>. It appears in Intel byte-swapped order. If the problem persists, consult the system administrator.</dd>
<dt>
ap_dealloc_abend_prog</dt>
<dd>
Primary return code; the conversation has been deallocated for one of the following reasons:
<ul>
<li>
The partner TP issued <a href="appc05a_4ndv.htm"><b>DEALLOCATE</b></a> with<b> dealloc_type </b>set to AP_ABEND_PROG.</li>
<li>
The partner TP has encountered an ABEND, causing the partner LU to send a <b>DEALLOCATE</b> request.</li>
</ul>
</dd>
<dt>
AP_DEALLOC_ABEND_SVC</dt>
<dd>
Primary return code; the conversation has been deallocated because the partner TP issued <b>DEALLOCATE</b> with <b>dealloc_type</b> set to AP_ABEND_SVC.</dd>
<dt>
AP_DEALLOC_ABEND_TIMER</dt>
<dd>
Primary return code; the conversation has been deallocated because the partner TP issued <b>DEALLOCATE</b> with <b>dealloc_type</b> set to AP_ABEND_TIMER.</dd>
<dt>
AP_SVC_ERROR_NO_TRUNC</dt>
<dd>
Primary return code; while in SEND state, the partner TP (or partner LU) issued <a href="appc05b_1azn.htm"><b>SEND_ERROR</b></a> with <b>err_type</b> set to AP_SVC. Data was not truncated.</dd>
<dt>
AP_SVC_ERROR_PURGING</dt>
<dd>
Primary return code; the partner TP (or partner LU) issued <b>SEND_ERROR</b> with <b>err_type</b> set to AP_SVC while in RECEIVE, PENDING_POST (Windows NT, Windows 95, and OS/2 only), CONFIRM, CONFIRM_SEND, or CONFIRM_DEALLOCATE state. Data sent to the partner TP may have been purged.</dd>
<dt>
AP_SVC_ERROR_TRUNC</dt>
<dd>
Primary return code; in SEND state, after sending an incomplete logical record, the partner TP (or partner LU) issued <b>SEND_ERROR</b>. The local TP may have received the first part of the logical record.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The local TP receives data through the following process:
<ol>
<li>
The local TP issues a receive verb until it finishes receiving a complete unit of data. The data received can be:<ul>
<li>
One logical record.</li>
<li>
A buffer of data received independent of its logical-record format.</li>
</ul>
<p>
The local TP may need to issue the receive verb several times in order to receive a complete unit of data. After a complete unit of data has been received, the local TP can manipulate it. The receive verbs are <b>RECEIVE_AND_POST</b> (Windows NT, Windows 95, and OS/2), <a href="appc05b_19er.htm"><b>RECEIVE_AND_WAIT</b></a>, and <a href="appc05b_5tnn.htm"><b>RECEIVE_IMMEDIATE</b></a>.
</li>
<li>
The local TP issues the receive verb again. This has one of the following effects:<ul>
<li>
If the partner TP has sent more data, the local TP begins to receive a new unit of data.</li>
<li>
If the partner TP has finished sending data or is waiting for confirmation, status information (available through <b>what_rcvd</b>) indicates the next action the local TP normally takes.</li>
</ul>
</li>
</ol>
<p>
The following procedure shows tasks performed by the local TP in using <b>RECEIVE_AND_POST</b>.</p>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To use RECEIVE_AND_POST</h5>
<ol>
<li>
For the Windows NT and Windows 95 operating systems, the TP retrieves the <a href="appc06_66sj.htm"><b>WinAsyncAPPC</b></a> message number by calling the <b>RegisterWindowMessage</b> API or allocating a semaphore. The <b>sema</b> field should be set to NULL if the application expects to be notified through the Windows message mechanism.<p>
APPC sends the Windows message or clears the semaphore when the local TP finishes receiving data.
<p>
For the OS/2 operating system, the TP uses the <b>DosSemSet</b> function to set the semaphore pointed to by <b>sema</b>.
<p>
The semaphore will remain set while the local TP receives data asynchronously. APPC will clear the semaphore when the local TP finishes receiving data.
</li>
<li>
The TP issues <b>RECEIVE_AND_POST</b>.</li>
<li>
The TP checks the value of <b>primary_rc</b>.<p>
If <b>primary_rc</b> is ap_ok, the receive buffer (pointed to by <b>dptr</b>) is asynchronously receiving data from the partner TP. While receiving data asynchronously, the local TP can:
<ul>
<li>
Perform tasks not related to this conversation.</li>
<li>
Issue <a href="appc05b_54kj.htm"><b>REQUEST_TO_SEND</b></a>.</li>
<li>
Gather information about this conversation by issuing <a href="appc05a_4nab.htm"><b>GET_TYPE</b></a>, <a href="appc05a_5o0z.htm"><b>GET_ATTRIBUTES</b></a>, or <a href="appc05b_8kf7.htm"><b>TEST_RTS</b></a>.</li>
<li>
Prematurely cancel <b>RECEIVE_AND_POST</b> by issuing <a href="appc05a_4ndv.htm"><b>DEALLOCATE</b></a> with <b>dealloc_type</b> set to AP_ABEND_PROG, AP_ABEND_SVC, or AP_ABEND_TIMER; <a href="appc05b_1azn.htm"><b>SEND_ERROR</b></a>;<b> </b>or <a href="appc04_8k0z.htm"><b>TP_ENDED</b></a>.</li>
</ul>
<p>
If, however, <b>primary_rc</b> is not ap_ok, <b>RECEIVE_AND_POST</b> has failed. In this case, the local TP does not perform the next two tasks.
</li>
<li>
For the Windows NT and Windows 95 operating systems, when the TP finishes receiving data asynchronously, APPC issues the <a href="appc06_66sj.htm"><b>WinAsyncAPPC</b></a> Windows message or clears the semaphore.<p>
For the OS/2 operating system, the TP uses the <b>DosSemWait</b> function to wait for APPC to clear the semaphore pointed to by <b>sema</b>. When the TP finishes receiving data asynchronously, APPC clears the semaphore. To prevent the local TP from waiting, have it test the semaphore (invoking <b>DosSemWait</b> with <b>Timeout</b> set to zero) until APPC clears the semaphore.
</li>
<li>
The TP checks the new value of <b>primary_rc</b>.<p>
If <b>primary_rc</b> is ap_ok, the local TP can examine the other returned parameters and manipulate the asynchronously received data.
<p>
If <b>primary_rc</b> is not ap_ok, only <b>secondary_rc</b> and <b>rts_rcvd</b> (request-to-send received) are meaningful.
</li>
</ol>
<h4>Conversation State Effects</h4>
<p>
The conversation must be in RECEIVE or SEND state when the TP issues this verb.</p>
<p>
Issuing <b>RECEIVE_AND_POST</b> while the conversation is in SEND state has the following effects:
<ul>
<li>
The local LU sends the information in its send buffer and a SEND indicator to the partner TP.</li>
<li>
The conversation changes to PENDING_POST state; the local TP is ready to receive information from the partner TP asynchronously.</li>
</ul>
<p>
The conversation changes states twice:
<ul>
<li>
Upon initial return of the verb, if <b>primary_rc</b> contains ap_ok, the conversation changes to PENDING_POST state.</li>
<li>
After completion of the verb, the state changes depending on the value of the following:<p class=indent1>
The <b>primary_rc</b> parameter</p>
<p class=indent1>
The <b>what_rcvd</b> parameter if <b>primary_rc</b> is ap_ok</p>
</li>
</ul>
<p>
The following table shows the new state associated with each value of <b>what_rcvd</b> when <b>primary_rc</b> is AP_OK.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=60%>what_rcvd</th>
<th align=left width=40%>New state</th>
</tr>
<tr valign=top>
<td width=60%>AP_CONFIRM_DEALLOCATE</td>
<td width=40%>CONFIRM_DEALLOCATE</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_COMPLETE_CONFIRM_DEALL</td>
<td width=40%>CONFIRM_DEALLOCATE</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_CONFIRM_DEALLOCATE</td>
<td width=40%>CONFIRM_DEALLOCATE</td>
</tr>
<tr valign=top>
<td width=60%>AP_CONFIRM_SEND</td>
<td width=40%>CONFIRM_SEND</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_COMPLETE_CONFIRM_SEND</td>
<td width=40%>CONFIRM_SEND</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_CONFIRM_SEND</td>
<td width=40%>CONFIRM_SEND</td>
</tr>
<tr valign=top>
<td width=60%>AP_CONFIRM_WHAT_RECEIVED</td>
<td width=40%>CONFIRM</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_COMPLETE_CONFIRM</td>
<td width=40%>CONFIRM</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_CONFIRM</td>
<td width=40%>CONFIRM</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA</td>
<td width=40%>RECEIVE</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_COMPLETE</td>
<td width=40%>RECEIVE</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_INCOMPLETE</td>
<td width=40%>RECEIVE</td>
</tr>
<tr valign=top>
<td width=60%>AP_SEND</td>
<td width=40%>SEND</td>
</tr>
<tr valign=top>
<td width=60%>AP_DATA_COMPLETE_SEND</td>
<td width=40%>SEND_PENDING</td>
</tr>
</table><br>
<p>
The following table shows the new state associated with each value of <b>primary_rc</b> other than AP_OK.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=58%>primary_rc</th>
<th align=left width=42%>New state</th>
</tr>
<tr valign=top>
<td width=58%>ap_canceled</td>
<td width=42%>No change</td>
</tr>
<tr valign=top>
<td width=58%>ap_conv_failure_retry</td>
<td width=42%>RESET</td>
</tr>
<tr valign=top>
<td width=58%>ap_conv_failure_no_retry</td>
<td width=42%>RESET</td>
</tr>
<tr valign=top>
<td width=58%>ap_dealloc_abend</td>
<td width=42%>RESET</td>
</tr>
<tr valign=top>
<td width=58%>ap_dealloc_abend_prog</td>
<td width=42%>RESET</td>
</tr>
<tr valign=top>
<td width=58%>ap_dealloc_abend_svc</td>
<td width=42%>RESET</td>
</tr>
<tr valign=top>
<td width=58%>ap_dealloc_abend_timer</td>
<td width=42%>RESET</td>
</tr>
<tr valign=top>
<td width=58%>AP_DEALLOC_NORMAL</td>
<td width=42%>RESET</td>
</tr>
<tr valign=top>
<td width=58%>ap_prog_error_purging</td>
<td width=42%>RECEIVE</td>
</tr>
<tr valign=top>
<td width=58%>ap_prog_error_no_trunc</td>
<td width=42%>RECEIVE</td>
</tr>
<tr valign=top>
<td width=58%>ap_svc_error_purging</td>
<td width=42%>RECEIVE</td>
</tr>
<tr valign=top>
<td width=58%>ap_svc_error_no_trunc</td>
<td width=42%>RECEIVE</td>
</tr>
<tr valign=top>
<td width=58%>ap_prog_error_trunc</td>
<td width=42%>RECEIVE</td>
</tr>
<tr valign=top>
<td width=58%>ap_svc_error_trunc</td>
<td width=42%>RECEIVE</td>
</tr>
</table><br>
<h4>End of Data for a Basic Conversation</h4>
<p>
If the local TP issues <b>RECEIVE_AND_POST</b> and sets <b>fill</b> to AP_BUFFER, the receipt of data ends when <b>max_len</b> or the end of the data is reached. The end of the data is indicated by either <b>primary_rc</b> with a value other than ap_ok (for example, ap_dealloc_normal), or by <b>what_rcvd</b> with one of the following values:</p>
<p class=indent1>
AP_SEND</p>
<p class=indent1>
AP_CONFIRM_SEND</p>
<p class=indent1>
AP_CONFIRM_DEALLOCATE</p>
<p class=indent1>
AP_CONFIRM_WHAT_RECEIVED</p>
<p class=indent1>
AP_DATA_CONFIRM_SEND</p>
<p class=indent1>
AP_DATA_CONFIRM_DEALLOCATE</p>
<p class=indent1>
AP_DATA_CONFIRM</p>
<p>
To determine if the end of the data has been reached, the local TP reissues <b>RECEIVE_AND_POST</b>. If the new <b>primary_rc</b> contains ap_ok and <b>what_rcvd</b> contains AP_DATA, the end of the data has not been reached. If, however, the end of the data has been reached, <b>primary_rc</b> or <b>what_rcvd</b> will indicate the cause of the end of the data.</p>
<h4>Troubleshooting</h4>
<p>
The local TP can wait indefinitely if one of the following situations occurs:
<ul>
<li>
For the Windows NT and Windows 95 operating systems, the local TP issues a <b>RECEIVE_AND_POST</b> request, but either the partner TP has not sent data or the initial <b>primary_rc</b> is not ap_ok.</li>
<li>
For the OS/2 operating system, the local TP issues a <b>DosSemWait</b> function call, but either the partner TP has not sent data or the initial <b>primary_rc</b> is not ap_ok.</li>
</ul>
<p>
This is because APPC will not issue the Windows message or clear the semaphore.</p>
<p>
When a condition resulting in one of the following <b>primary_rc</b> parameters occurs, APPC does not clear the semaphore:</p>
<p class=indent1>
AP_INVALID_SEMAPHORE_HANDLE</p>
<p class=indent1>
AP_INVALID_VERB_SEGMENT</p>
<p class=indent1>
AP_STACK_TOO_SMALL</p>
<p>
To test <b>what_rcvd</b>, issue <b>RECEIVE_AND_POST</b> with <b>max_len</b> set to zero, so that the local TP can determine whether the partner TP has data to send, seeks confirmation, or has changed the conversation state.</p>
<p>&nbsp;</p></body>
</HTML>
