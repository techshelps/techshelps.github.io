<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Before Using Windows CPI-C</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sna_before_using_windows_cpi_c_cpic"></a>Before Using Windows CPI-C</h2>
<p>
The following CPI-C calls and Windows extensions are of particular importance and should be reviewed before using this version of SNA Server. Note that the names of the calls are pseudonyms. The actual C function names appear in parentheses after the pseudonym. For example, <b>Set_Processing_Mode</b> is the pseudonym for a call. The actual function name is <b>cmspm</b>.
<dl>
<dt>
<a href="cpic03_5uoz.htm"><b>Set_Processing_Mode</b></a> (<b>cmspm</b>)</dt>
<dd>
Specifies for the conversation whether subsequent calls will be returned when the operation they request is complete (blocking) or immediately after the operation is initiated (nonblocking). A program is notified of the completion of nonblocking calls when it issues <b>Wait_For_Conversation</b> or through a Windows message sent to a WndProc identified by <i>hwndNotify</i> in <b>Specify_Windows_Handle</b>. When the processing mode is set for a conversation, it applies to all subsequent calls on the conversation until the mode is set again.</dd>
<dt>
<a href="cpic03_3kir.htm"><b>Specify_Windows_Handle</b></a> (<b>xchwnd</b>)</dt>
<dd>
Sets the window handle to which a message is sent on completion of an operation in nonblocking mode.</dd>
<dt>
<a href="cpic03_6un7.htm"><b>Wait_For_Conversation</b></a> (<b>cmwait</b>)</dt>
<dd>
Waits for the completion of an operation that was initiated when the<i> </i>processing mode conversation characteristic was set to CM_NON_BLOCKING and cm_operation_incomplete was returned in the <i>return_code</i> parameter. Use <b>Wait_For_Conversation</b> when running a background thread or a single-threaded application for the Windows NT, Windows 95, or Windows version 3.<i>x</i> systems.

<p>
<b>Important  </b>An application can set the processing mode by calling <b>Set_Processing_Mode</b>. If the window handle is set to NULL, or this call is never issued, then the application must call <b>Wait_For_Conversation</b> to be notified when the outstanding operation completes.


<p>
When an asynchronous operation is complete, the application's window <i>hwndNotify</i> receives the message returned by <b>RegisterWindowMessage</b> with "WinAsyncCPIC" as the input string. The <i>wParam</i> value contains the conversation return code from the operation that is completing. Its values depend on which operation was originally issued. The <i>lParam</i> argument contains the CM_PTR to the conversation identifier specified in the original function call.
</dd>
<dt>
<a href="cpic04_455v.htm"><b>WinCPICCleanup</b></a></dt>
<dd>
Terminates and deregisters an application from a Windows CPI-C implementation.

<p>
<b>Important  </b>This function must be called by an application when finished to deregister the application from the Windows CPI-C implementation.

</dd>
<dt>
<a href="cpic04_51yb.htm"><b>WinCPICExtractEvent</b></a></dt>
<dd>
Provides a method for an application to determine the event handle being used for a CPI-C conversation. </dd>
<dt>
<a href="cpic04_55pf.htm"><b>WinCPICIsBlocking</b></a></dt>
<dd>
Determines if a task is executing while waiting for a previous blocking call to finish. Windows version 3.<i>x</i> goes into a <b>PeekMessageLoop</b> while allowing Windows to continue. Although a call issued on a blocking function appears to an application as though it blocks, the Windows CPI-C dynamic-link library (DLL) has to relinquish the processor to allow other applications to run. This means that it is possible for the application that issued the blocking call to be re-entered, depending on the message(s) it receives. In this instance, <b>WinCPICIsBlocking</b> can be used to determine whether the application task currently has been re-entered while waiting for an outstanding blocking call to finish.
<p>
This extension is intended to provide help to an application written to use the CM_BLOCKING characteristic of the Windows <b>Specify_Processing_Mode</b> function. <b>WinCPICIsBlocking</b> serves the same purpose as <b>InSendMessage</b> in the Windows API.

<p>
Applications targeted at Windows version 3.<i>x</i> that support multiple conversations must specify CM_NONBLOCKING in <b>Specify_Processing_Mode</b> so they can support multiple outstanding operations simultaneously. Applications are still limited to one outstanding operation per conversation in all environments. Note that Windows CPI-C prohibits more than one outstanding blocking call per thread.
</dd>
<dt>
<a href="cpic04_4l2b.htm"><b>WinCPICSetBlockingHook</b></a></dt>
<dd>
Allows a Windows CPI-C implementation to block CPI-C function calls by means of a new function. Blocking calls apply only if you do not use asynchronous calls. If a function needs to block, the blocking call is called repeatedly until the original request completes. This allows Windows to continue to run while the original application waits for the call to return. Note that while inside the blocking call, the application can be re-entered. <b>WinCPICSetBlockingHook</b> is used by Windows version 3.<i>x</i> applications that go into a <b>PeekMessageLoop</b> to make blocking calls without blocking the rest of the system.

<p>
<b>Note  </b>By default, Windows NT and Windows 95 do not go into a <b>PeekMessageLoop</b>; rather, they actually block on an event waiting for the call to complete. The only time you need to use <b>WinCPICSetBlockingHook</b> for Windows NT and Windows 95 is when a single-threaded application for both Windows NT or Windows 95 and Windows version 3.<i>x</i> share common source code. In this case, you must explicitly make this call. Contrast this call with <b>WinCPICIsBlocking</b> and <b>WinCPICUnhookBlockingHook</b>.

</dd>
<dt>
<a href="cpic04_0yw3.htm"><b>WinCPICSetEvent</b></a></dt>
<dd>
Associates a Win32 event handle with a verb completion.</dd>
<dt>
<a href="cpic04_3rqb.htm"><b>WinCPICStartup</b></a></dt>
<dd>
Allows an application to specify the version of Windows CPI-C required and to retrieve details of the specific CPI-C implementation.

<p>
<b>Important  </b>An application must call this function to register itself with a Windows CPI-C implementation before issuing any further Windows CPI-C calls.

</dd>
<dt>
<a href="cpic04_0jhf.htm"><b>WinCPICUnhookBlockingHook</b></a></dt>
<dd>
Removes any previous blocking hook that has been installed and reinstalls the default blocking mechanism.
</dd>
</dl>
<p>&nbsp;</p></body>
</HTML>
