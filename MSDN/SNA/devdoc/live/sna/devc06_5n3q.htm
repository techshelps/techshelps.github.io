<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Common Code Section</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_sna_common_code_section_dev"></a>Common Code Section</h3>
<p>
This section contains most of the actual code that the script runs. It expects to receive the name of an option and an index as parameters. It also checks to see that the language specified in <i>STF_LANGUAGE</i> is supported. It then checks the <i>NTN_InstallMode</i> variable to determine what it should do. Before proceeding to the section of code that will complete the required task, the script sets up default values for all the variables of the particular option being installed.</p>
<h4>Main Entry Section</h4>
<p>
This section checks the value of the <i>NTN_InstallMode</i> variable and determines the label of the code that will complete that operation. It also assigns defaults values for the variables.</p>
<h4>Set Defaults (set_defaults)</h4>
<p>
This section sets the default values for the options; among them are the service name, title, and description. These three must be set in this section; however, more variables can be added as needed.</p>
<h4>Install Component (install_component)</h4>
<p>
This section checks to see if there are any instances of this component already installed. If there are none, it sets the install index to one and continues. Otherwise, if one instance exists, it checks for the value of the <i>ProductExclusive</i> variable to determine what it should do. If it needs to install another instance of the component, it executes the utility file and finds the next available index to use.</p>
<p>
When it is ready, the script determines the service name for this component using an algorithmic definition (<b>install_nextstep</b>). If the <i>ProductServiceQuery</i> variable is set to TRUE, the user is presented with this value and is allowed to change it. When all the variables are ready, it proceeds to the parameter modification section.</p>
<h4>Configure Component (config_component)</h4>
<p>
This section determines whether or not the component in question is installed. If the component is not installed or if the index is invalid, it fails with an error. Otherwise, it reads the parameters for this component from the registry (<b>read_params</b>). This code reads the parameters from the <b>Parameters</b> and <b>ExtraParameters</b> keys in the registry and creates a list of their values. It then loops through the list and assigns the values to the variables using a switch/case construct (<b>assign_value_<i>option</i></b>). When that is done, there is an extra section (<b>assign_extra_<i>option</i></b>) where other parameters that do not reside in the standard location can be read or any other code that assigns values to variables can be placed. When the variables are all assigned, the code proceeds to the parameter modification section.</p>
<h4>Modify Parameters (modify_params)</h4>
<p>
This section contains the code that modifies the variables or calls out other code that modifies them. As soon as this section is entered, control is routed to subsections, one for each option (<b>modify_params_<i>option</i></b>). These subsections should contain all of the actual modification code. When this section is done, the variables are ready to write to the registry and the code proceeds to the adjustment section.</p>
<h4>Adjust Parameters (adjust_params)</h4>
<p>
This section takes control from the parameter modification section. If the script is supposed to configure an existing component, the control is routed directly to the code that writes the parameters to the registry. Otherwise, control falls to code that creates the appropriate service entries in the registry before it writes out the variables.</p>
<h4>Create Registry Entries (create_regvals)</h4>
<p>
This section creates the service and registry entries for this component. It also writes out some of the values that the product entry under the <b>SOFTWARE\Microsoft </b>key needs to contain. This section is also currently in charge of the NCPA bindings information. If the product files have not been copied, this code shells out to the installation section that handles file copying (<b>InstallRemove</b>). When all the keys are created, control falls to the section that writes out the variable values to the registry.</p>
<h4>Write Out Variables (write_params)</h4>
<p>
This section first ensures that the appropriate handles are open and then routes control to a subsection that prepares the appropriate variables for registry output (<b>write_params_<i>option</i></b>). Each of these sections must prepare the <i>ProductParams </i>and <i>ProductExtraParams</i> variables to be written to the registry. Each of these parameters is a list of registry creation lists. Each registry creation list must contain the name of the entry to be created, the <i>NoTitle</i> variable, the type of entry to create, and the value of the entry. See the existing link service .INF scripts.</p>
<p>
The <i>ProductParams</i> variable must contain the name and option entries. Both variables can contain any additional entries that are needed. Also, any other parameter-writing code should be written in these sections. For an example, see the setup script for the NDIS 802.2 link support (SNADLC.INF).</p>
<p>
After the subsections are finished, control is passed to the code that actually adds the list of entries to the registry. It also prepares the data return structure and finishes by using the <b>successful</b> escape hatch.</p>
<h4>Get Bindings From Component (getbind_component)</h4>
<p>
This section is responsible for communicating the option bindings back to SNA Server Setup. It queries the NCPA bindings, sets the information in the data return structure, and returns it to SNA Server Setup. SNA Server Setup then uses this information to determine whether this particular instance can be removed or not. An instance can be removed if it is not needed (bound to) by any other component.</p>
<h4>Remove Component (remove_component)</h4>
<p>
This code is in charge of removing one or all of the instances for a particular product. In the case of a complete removal, it also removes the files and software entries for this product. In the case of a single instance removal, the code passes control to the <b>remove_one_piece</b> subsection, which handles a single removal. Otherwise, code control goes to the <b>remove_all_pieces</b> subsection.</p>
<p>
For a full removal, the setup script loops through all of the instances and calls the <b>remove_one_piece</b> subsection for each of those instances. When the loop is complete, the code control is passed to a common point for both removal types (<b>remove_product</b>). The subsection <b>remove_one_piece</b> removes the software entry for the instance and deletes the service from the Service Control Architecture. If it is dealing with a complete removal, it returns control to the loop, otherwise, it falls to the <b>remove_product</b> subsection. This subsection determines whether files should be removed (full removal) and calls the appropriate installation section (<b>InstallRemove</b>). After all is done, it uses the <b>successful </b>escape hatch to return control to SNA Server Setup.</p>
<h4>Escape Hatches</h4>
<p>
These are all the available hatches that can be used throughout the setup script.
<dl>
<dt>
<b>Successful (successful)</b></dt>
<dd>
Sets the status to <i>STATUS_SUCCESSFUL</i> and exits through <b>end</b>.</dd>
<dt>
<b>Warning Message (warning_msg)</b></dt>
<dd>
This hatch displays a warning dialog box with the error message stored in the variable <i>Error. </i>This variable should be defined before calling this escape hatch. This warning dialog box has two dialog buttons: <b>OK</b> and <b>Cancel</b>. If the user chooses to continue, control is passed to the <i>to</i> label, otherwise, control is returned to the <i>from</i> label. If the warning box fails, the script exits through <b>end</b>.</dd>
<dt>
<b>Nonfatal Message (nonfatal_msg)</b></dt>
<dd>
This hatch displays a nonfatal warning dialog box with the error message stored in the variable <i>Error</i>. This variable should be defined before calling this escape hatch. This dialog box has only one button, <b>OK</b>. After the user presses this button, control is returned to the <i>from </i>label. If the nonfatal warning dialog box fails, the script exits through <b>end</b>.</dd>
<dt>
<b>Fatal Registry Message (fatal_registry)</b></dt>
<dd>
This is probably the most-used escape hatch, next to the <b>successful</b> hatch. It sets up the <i>Error</i> variable with a template that includes three other variables: <i>ErrMesg</i>, <i>ErrProc</i>, and <i>ErrFunc</i>. The first should be a short message describing the error. The second should be the section or subsection that called the registry function. The third should be the name of the registry function that was called. All three variables should be set before calling this escape hatch. After the error message is prepared, the <b>fatal_msg</b> escape hatch gets control.</dd>
<dt>
<b>Fatal Message (fatal_msg)</b></dt>
<dd>
This hatch displays a dialog box with the fatal error message. When the user clicks the button, this hatch exits through the <b>set_status_failed</b> escape hatch.</dd>
<dt>
<b>Shell Code Error (ShellCodeError)</b></dt>
<dd>
This hatch is only used when a shell execution fails. If the script receives a <i>ShellCode</i> that is not zero, it calls this hatch. This hatch displays an error message and exits through the <b>set_status_failed</b> hatch.</dd>
<dt>
<b>Failed Exit (set_status_failed)</b></dt>
<dd>
This hatch sets the status to <i>STATUS_FAILED</i> and exits through <b>end</b>.</dd>
<dt>
<b>End</b></dt>
<dd>
This hatch ensures that the handle to the SRL for this file is closed and exits this script. It should not be called directly without ensuring that the <i>Status</i> variable contains the correct return value for the operation.
</dd>
</dl>
<p>&nbsp;</p></body>
</HTML>
