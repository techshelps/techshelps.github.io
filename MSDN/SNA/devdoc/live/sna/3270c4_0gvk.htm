<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Open(PLU) Request</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_sna_open_plu_request_3270"></a>Open(PLU) Request</h1>
<p>
The <b>Open(PLU) Request</b> message flows from the node to the application. It is used with a PLU connection.</p>
<pre><code>struct Open(PLU) Request {
    PTRBFHDR  nxtqptr;
    PTRBFELT  hdreptr;
    CHAR      numelts;
    CHAR      msgtype;
    CHAR      srcl;
    CHAR      srcp;
    INTEGER   srci;
    CHAR      destl;
    CHAR      destp;
    INTEGER   desti;
    CHAR      ophdr.openqual;
    CHAR      ophdr.opentype;
    CHAR      ophdr.appltype;
    CHAR      ophdr.opluno;
    INTEGER   ophdr.opresid;
    INTEGER   ophdr.icreditr;
    INTEGER   ophdr.icredits;
    CHAR      ophdr.opninfo1;
}; 
<b> </b></code></pre>
<p>
<b>Element 1</b></p>
<pre><code>struct Open(PLU) Request {
    PTRBFELT   hdreptr-&gt;elteptr;
    INTEGER    hdreptr-&gt;startd;
    INTEGER    hdreptr-&gt;endd;
    CHAR       hdreptr-&gt;trpad;
    CHAR[268]  hdreptr-&gt;dataru;
}; 
 </code></pre>
<p>
<b>Element 2</b></p>
<pre><code>struct Open(PLU) Request {
    PTRBFELT  hdreptr-&gt;elteptr-&gt;elteptr;
    INTEGER   hdreptr-&gt;elteptr-&gt;startd;
    INTEGER   hdreptr-&gt;elteptr-&gt;endd;
    CHAR      hdreptr-&gt;elteptr-&gt;trpad;
    CHAR[ ]   hdreptr-&gt;elteptr-&gt;dataru;
}; 
 </code></pre>
<h4>Members</h4>
<dl>
<dt>
<b>nxtqptr</b></dt>
<dd>
Pointer to next buffer header.</dd>
<dt>
<b>hdreptr</b></dt>
<dd>
Pointer to first buffer element.</dd>
<dt>
<b>numelts</b></dt>
<dd>
Number of buffer elements (0x02).</dd>
<dt>
<b>msgtype</b></dt>
<dd>
Message type OPENMSG (0x01).</dd>
<dt>
<b>srcl</b></dt>
<dd>
Source locality.</dd>
<dt>
<b>srcp</b></dt>
<dd>
Source partner.</dd>
<dt>
<b>srci</b></dt>
<dd>
Source index.</dd>
<dt>
<b>destl</b></dt>
<dd>
Destination locality.</dd>
<dt>
<b>destp</b></dt>
<dd>
Destination partner.</dd>
<dt>
<b>desti</b></dt>
<dd>
Destination index.</dd>
<dt>
<b>ophdr.openqual</b></dt>
<dd>
Open qualifier REQU (0x01).</dd>
<dt>
<b>ophdr.opentype</b></dt>
<dd>
Open type LUSEC (0x02).</dd>
<dt>
<b>ophdr.appltype</b></dt>
<dd>
Application program interface type
<p>
0x02 (FMI application)
</dd>
<dt>
<b>ophdr.opluno</b></dt>
<dd>
Logical unit number.</dd>
<dt>
<b>ophdr.opresid</b></dt>
<dd>
Resource identifier.</dd>
<dt>
<b>ophdr.icreditr</b></dt>
<dd>
Initial credit for flow from application to local node: zero (no flow control).</dd>
<dt>
<b>ophdr.icredits</b></dt>
<dd>
Recommended initial credit for flow from local node to application:<br>
Pacing window + 1.</dd>
<dt>
<b>ophdr.opninfo1</b></dt>
<dd>
Negotiable bind indicator
<p>
Bind is not negotiable  (0x00)<br>
Bind is negotiable        (0x01)

</dd>
</dl>
<p>
<b>Element 1</b>
<dl>
<dt>
<b>hdreptr–&gt;elteptr</b></dt>
<dd>
Pointer to buffer element.</dd>
<dt>
<b>hdreptr–&gt;startd</b></dt>
<dd>
Start of data in this buffer element (1).</dd>
<dt>
<b>hdreptr–&gt;endd</b></dt>
<dd>
End of data in this buffer element.</dd>
<dt>
<b>hdreptr–&gt;trpad</b></dt>
<dd>
Reserved.</dd>
<dt>
<b>hdreptr–&gt;dataru</b></dt>
<dd>
Data RU, as follows:
<dl>
<dt>
<b>dataru[0–9]</b></dt>
<dd>
Source name.</dd>
<dt>
<b>dataru[10–19]</b></dt>
<dd>
Destination name.</dd>
<dt>
<b>dataru[20]</b></dt>
<dd>
Secondary pacing send window.</dd>
<dt>
<b>dataru[21]</b></dt>
<dd>
Secondary pacing receive window.</dd>
<dt>
<b>dataru[22–23]</b></dt>
<dd>
Secondary send maximum RU size (see Remarks).</dd>
<dt>
<b>dataru[24–25]</b></dt>
<dd>
Primary send maximum RU size (see Remarks).</dd>
<dt>
<b>dataru[26]</b></dt>
<dd>
Secondary send chunk size (in units of elements).</dd>
<dt>
<b>dataru[27]</b></dt>
<dd>
Primary send chunk size (in units of elements).
</dd>
</dl>
</dd>
</dl>
<p>
<b>Element 2</b>
<dl>
<dt>
<b>hdreptr–&gt;elteptr–&gt;elteptr</b></dt>
<dd>
Pointer to buffer element (NIL).</dd>
<dt>
<b>hdreptr–&gt;elteptr–&gt;startd</b></dt>
<dd>
Start of data in this buffer element (13).</dd>
<dt>
<b>hdreptr–&gt;elteptr–&gt;endd</b></dt>
<dd>
End of data in this buffer element.</dd>
<dt>
<b>hdreptr–&gt;elteptr–&gt;trpad</b></dt>
<dd>
Reserved.</dd>
<dt>
<b>hdreptr–&gt;elteptr–&gt;dataru</b></dt>
<dd>
Data RU, as follows:
<dl>
<dt>
<b>dataru[13]</b></dt>
<dd>
The BIND RU received from the host.
</dd>
</dl>
</dd>
</dl>
<h4>Remarks</h4>
<ul>
<li>
The <b>Open(PLU) Request</b> message consists of a buffer header, an initial element containing the source and destination names, RU sizes, and so on, followed by a second element containing the BIND RU received from the host.</li>
<li>
The source LPI and the L and P parts of the destination LPI are valid, but the I part of the destination LPI is reserved.</li>
<li>
The two send maximum RU size fields (in <b>dataru[22–</b><b>25]</b>) are both integer values.</li>
<li>
The BIND RU can be up to 256 bytes in length.</li>
<li>
If the application is using the LUA variant of the FMI (see <a href="3270c3_886o.htm">FMI Concepts</a>), the BIND RU is preceded by its TH and RH; the <b>startd</b> field of the second element points to the TH.</li>
<li>
The LU number matches that allocated to the named application on the <a href="3270c4_299s.htm"><b>Open(SSCP) Response</b></a>.</li>
<li>
The resource identifier matches the value used by the application on the <a href="3270c4_4jcg.htm"><b>Open(SSCP) Request</b></a>.</li>
<li>
If chunking was specified on the <b>Open(SSCP) Request</b>, the <b>icredits</b> (initial credit from local node to application) field specifies the number of chunks, rather than RUs, that can be transmitted. The two send chunk size parameters are specified in units of elements (each element contains up to 256 bytes of RU data). A value of zero indicates that the chunk size is not the limiting factor in determining the size of messages; the limiting factor is the RU size or the segment size, so chunking is not required. In this case, credit will still be used, with the unit of credit being a message.</li>
<li>
The <b>icreditr</b> (initial credit from application to local node) field is not used and must be set to zero.</li>
</ul>
<p>&nbsp;</p></body>
</HTML>
