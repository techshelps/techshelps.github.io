<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Chunking</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_sna_chunking_3270"></a>Chunking</h3>
<p>
<b>Note</b>  Previous versions of this document indicated this as a future feature. The support is enabled in Comm Server 1.2 (and later) under OS/2, and in the first release of Microsoft® SNA Server for Microsoft® Windows NT® and Microsoft® Windows® 95. Applications should therefore test the product version returned on a call to <a href="entrypts_63cg.htm"><b>sepdgetinfo</b></a> for version 1.2 or later before using the chunking system.</p>
<p>
In some cases, the RU size used by the local node may be too large for the length of the path between the local node and an FMI application; for example, when using a 16MB token-ring link, which can support 16KB frames. The local node allows an FMI application to specify that data transfer should be in smaller units, called chunks.</p>
<p>
For example, consider an implementation using OS/2 named pipes, with a maximum pipe size of 4K. If the maximum RU size is 8K, the application can specify that data is to be transferred in smaller chunks of 1K. Together with a credit limit, this ensures that the pipe will never be completely full. (It is important to ensure that the pipe is never filled, because if the local node attempts to write to a full pipe, it will be blocked, causing severe performance problems.)</p>
<p>
Chunking can be thought of as similar to segmentation (see <a href="3270c3_9vg0.htm">Segment Delivery</a> for more information); the distinction is that segmentation is determined by the communications link between the local node and the remote system, whereas chunking is determined by the communications link between the application and the local node.</p>
<p>
The application indicates on the <a href="3270c4_4jcg.htm"><b>Open(SSCP) Request</b></a> whether it supports chunking, and, if so, the chunk size in bytes that it wishes to use. The local node then uses the RU size, the chunk size, and the segment size (if applicable) to determine whether chunking is necessary. It then specifies the chunk sizes used for inbound and outbound flow (which need not be the same) on the <a href="3270c4_0gvk.htm"><b>Open(PLU) Request</b></a>; these values are specified in units of elements (see <a href="3270c1_1bzk.htm">Messages</a> for more information). A value of zero for either of these sizes indicates that chunking is not necessary because the chunk size is not the limiting factor. Note that in chunking data, an RU will not be split in the middle of an element; this avoids data copying.</p>
<p>
For example, assume that the local node is using an RU size of 8K and segments of 2K, and the application's <b>Open(SSCP) Request</b> specifies segment delivery and a chunk size of 4K. Chunking will be used on inbound data flow (because the chunk size is smaller than the RU size), but is not necessary on outbound data flow (because data will be delivered in segments that are smaller than the chunk size).</p>
<p>
If chunking is being used in either direction, then all credit values specify the number of chunks that can be sent in that direction, not the number of RUs. Note that the segment delivery option is included on the <b>Open(SSCP) Request</b> to allow the local node to calculate the initial chunk credit values on the corresponding PLU connection. The application must also set this option on the <b>Open(PLU) Response</b>; if the <b>Open(SSCP) Request</b> and the <b>Open(PLU) Response</b> have different settings of this option, the setting from the <b>Open(PLU) Response</b> will be used. This can mean that the initial credit value used is not appropriate.</p>
<p>
If session-level pacing is being used, the local node links this to the chunking credit. In particular, if the application withholds credit, the local node will delay sending a pacing response to the host, thereby applying back pressure to the host. This linkage is handled by the local node and need not concern the application.</p>
<p>
Application flags (see <a href="3270c3_74vk.htm">Application Flags</a>) on chunks of RUs are handled in the same way as those on segments (see <a href="3270c3_9vg0.htm">Segment Delivery</a> for more information). In particular:
<ul>
<li>
FMHI, BCI, COMMIT, BBI, EBI, CODE, ENCRYP, ENPAD, QRI, and CEI are only set on the first chunk of an RU.</li>
<li>
ECI and CDI are only set on the last chunk of an RU.</li>
<li>
BBIUI is always set on the first chunk of an RU.</li>
<li>
EBIUI is always set on the last chunk of an RU.</li>
</ul>
<p>
Note that EBI is set on the first chunk of the last RU in a bracket and not on the last chunk as might be expected; this is the same behavior as for segment delivery. The application should use the <b>Status-Session(BETB)</b> message, not the EBI flag, to determine when a bracket has ended.</p>
<p>
Chunks are identified using the segmentation flags BBIUI and EBIUI, and therefore the application cannot distinguish between chunks and segments if both segmentation and chunking are being used outbound. However, there is generally no need for the distinction; the application can perform window shading (see <a href="3270c3_9vg0.htm">Segment Delivery</a> for more information) by displaying each unit of data as it is received, whether the unit of data is a segment or a chunk.</p>
<p>&nbsp;</p></body>
</HTML>
