<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Inbound Data</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sna_inbound_data_3270"></a>Inbound Data</h2>
<p>
This section describes inbound data flows from the application to the local node. The overall structure of the protocols described applies to the SSCP and PLU connections, but more complex aspects (such as the use of delayed request mode) are only applicable to the PLU connection.</p>
<p>
The application can send inbound data on any of the three connections, as follows:
<ul>
<li>
FMD NS (session services) and FMD character-coded data intended for the host SSCP should be sent to the local node on the SSCP connection.</li>
<li>
FMD data intended for the host PLU should be sent to the local node on the PLU connection.</li>
</ul>
<p>
The application cannot use <a href="3270c4_4eeo.htm"><b>Data</b></a> messages to send DFC or session control request messages to the host. Instead it must use <b>Status-Control</b> messages (see <a href="3270c3_11ps.htm"><b>Status-Control</b> Message</a> for further details).</p>
<p>
For all three connections, the application must fill in certain key fields in the <b>Data</b> message's header. In particular it must:
<ul>
<li>
Set the message-type to DATAFMI.</li>
<li>
Allocate a new message key for inbound <b>Data</b> messages on this connection.</li>
<li>
Set the ACKRQD field if required (see below).</li>
<li>
Set the application flags (see <a href="3270c3_74vk.htm">Application Flags</a>).</li>
</ul>
<p>
The <b>nxtqptr</b>, <b>hdreptr</b> and <b>numelts</b> fields in the message header, and the <b>elteptr</b> and <b>startd</b> fields in the message elements are set up by SNA Server's buffer management routines (see <a href="3270c2_46b4.htm">The DL-BASE/DMOD Interface</a>). The application is responsible for setting the <b>endd</b> field.</p>
<p>
Where the application does not have access to these routines (for example, where the operating environment does not support intertask procedure calls and shared memory), all the fields in the header must be set by the application.</p>
<p>
The TH and RH indicators are not available to the application on inbound <a href="3270c4_4eeo.htm"><b>Data</b></a> messages. The application should set the appropriate application flags in the message header to control chaining, direction, and so on—see <a href="3270c3_74vk.htm">Application Flags</a> for a description of the available application flags for inbound data and later topics in this section for a description of how the flags are used to control inbound data flows.</p>
<p>
For inbound data, the first byte is RU[0] for standard FMI.</p>
<p>
The message key supplied by the application in the inbound <b>Data</b> message header is used by the local node to indicate which <b>Data</b> message on this connection an outbound <b>Status-Acknowledge</b> refers to. The application should maintain a unique message key sequence for the inbound data flow on each connection it has with the local node, so that the application can use the message key to correlate inbound <b>Data</b> messages and outbound <b>Status-Acknowledge</b> messages on the connection. Note that the application must also provide a message key on <b>Status-Control Request</b> messages to differentiate between multiple RQE LUSTAT messages.</p>
<p>
The inbound data acknowledgment protocol reflects the secondary chain response protocol and request mode in use on the session, as follows:
<ul>
<li>
Inbound <a href="3270c4_4eeo.htm"><b>Data</b></a> messages with ACKRQD set in the header generate RQD requests.</li>
<li>
Inbound <b>Data</b> messages without ACKRQD set in the header generate RQE or RQN requests depending on the chain response protocol.</li>
<li>
The application should only set ACKRQD on <b>Data</b> messages that have the ECI (end chain indicator) application flag set.</li>
<li>
If the session specifies that the secondary uses immediate request mode, the application can still send further <b>Data</b> messages after sending data with ACKRQD set, even though it has not received a <b>Status-Acknowledge</b> message for that <b>Data</b> message. The messages are queued within the local node and are progressively sent as positive responses are received.</li>
<li>
If the session specifies that the secondary uses delayed request mode, then after sending a <b>Data</b> message with ACKRQD set, the application can continue to send <b>Data</b> messages.</li>
</ul>
<p>
If the application sets the ACKRQD field in the message header of a <a href="3270c4_4eeo.htm"><b>Data</b></a> message, it indicates that it requires an acknowledgment to this <b>Data</b> message. The local node acknowledges an inbound <b>Data</b> message by sending a <b>Status-Acknowledge</b> message to the application on the same connection and using the same message key as the <b>Data</b> message (see the first figure at the end of this topic).</p>
<p>
The local node processes inbound <b>Data</b> messages from the application through its internal state machines, assigns the correct SNA sequence number or an identifier for this flow, and sends the data in a request to the host. The chain-response type of the request depends on whether ACKRQD was set in the <b>Data</b> message and the session parameters.</p>
<p>
The local node maps a positive response from the host to a <a href="3270c4_5z00.htm"><b>Status-Acknowledge(Ack)</b></a> to the application. The application can use the message key in the <b>Status-Acknowledge</b> to correlate the acknowledgment with the original <b>Data</b> message. Therefore, receipt of a <b>Status-Acknowledge(Ack)</b> for a particular <b>Data</b> message implies that the local node has received a positive SNA response from the host to the inbound SNA request (see the second figure at the end of this topic).</p>
<p>
Note that responses are absorbed on the SSCP-PU session.</p>
<p>
Note that outbound <a href="3270c4_5z00.htm"><b>Status-Acknowledge(Ack)</b></a> messages contain application flags and a sequence number. The application flags reflect the RH indicators in the response. The sequence number is the SNA sequence number from the response, and provides a mechanism for applications using TS profile 4 to track the SNA secondary sequence number corresponding to a unit of work.</p>
<p>
The local node maps a negative response from the host to a <a href="3270c4_11bk.htm"><b>Status-Acknowledge(Nack-1)</b></a> message to the application. The application can use the message key in the <b>Status-Acknowledge</b> to correlate the negative acknowledgment with the original <b>Data</b> message. The outbound <b>Status-Acknowledge(Nack-1)</b> message contains the SNA sense codes and sequence number from the negative response (see the third and fourth figures at the end of this topic).</p>
<p>
If the local node detects an error in the format of an inbound <b>Data</b> message, or the <b>Data</b> message is not appropriate to the current state of the session, it sends a <a href="3270c4_7wxc.htm"><b>Status-Acknowledge(Nack-2)</b></a> to the application containing an error code (see <a href="3270c5_4a5s.htm">Error and Sense Codes</a> for a list of error codes). The local node does not send a request to the host corresponding to the <b>Data</b> message in error and does not advance the SNA sequence number for the session. The application can use any message key in its next inbound <b>Data</b> message (assuming the error does not cause a critical failure).</p>
<p>
An example of a serious chaining error, where the application sends a <b>Data</b> message with ACKRQD but without ECI in the application flags, is shown in the last figure at the end of this topic. Note that after detecting this particular error, the local node marks the application's connection as critically failed, closes the connection, and sends a TERM-SELF request to the SSCP to elicit an UNBIND (see <a href="3270c3_95kg.htm">Recovery</a>).</p>
<p>
Inbound <b>Status-Control</b> messages, which cause the generation of expedited-flow requests, can be sent at any time and do not affect the sending of a positive or negative acknowledgment to inbound <b>Data</b> messages. See <a href="3270c3_11ps.htm"><b>Status-Control</b> Message</a> for details of which <b>Status-Control</b> messages correspond to SNA expedited-flow requests.</p>
<p>
The following five figures illustrate examples of the inbound data acknowledgment protocols (and the underlying SNA protocols) for different chain-response types and secondary session request modes.</p>
<p>
The figures show:
<ul>
<li>
The ACKRQD field on <a href="3270c4_4eeo.htm"><b>Data</b></a> messages.</li>
<li>
The message key on <b>Data</b> messages.</li>
<li>
Any relevant application flags on <b>Data</b> messages.</li>
<li>
Error codes (shown as "ERROR=...") on <b>Data</b> messages.</li>
<li>
Relevant RH flags on SNA requests/responses.</li>
<li>
Sequence numbers on SNA requests/responses.</li>
<li>
Sense codes (shown as "SENSE=....") on SNA requests/responses.</li>
</ul>
<p>
For simplicity, all messages are assumed to be flowing on the same PLU session.</p>
<p>
In the following illustration, the application successfully sends a <b>Data</b> message.</p>
<p>
<img src="images/32703x.gif" border=0></p>
<p>
In the following illustration, the application successfully sends a chain of <b>Data</b> messages.</p>
<p>
<img src="images/32703xa.gif" border=0></p>
<p>
In the following illustration, the host rejects a chain of <b>Data</b> messages.</p>
<p>
<img src="images/32703xb.gif" border=0></p>
<p>
In the following illustration, the host rejects the first definite-response chain and rejects the third exception-response chain on a delayed request session. Note that the negative response to the third chain implies a positive response to the second chain.</p>
<p>
<img src="images/32703xc.gif" border=0></p>
<p>
In the following illustration, the local node detects the application's invalid use of ACKRQD without the ECI application flag on a <b>Data</b> message. Note that no data is sent to the host; however, since the error is critical, the local node will send a TERM-SELF message to the SSCP.</p>
<p>
<img src="images/32703xd.gif" border=0></p>
<p>&nbsp;</p></body>
</HTML>
