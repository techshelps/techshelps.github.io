<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPI-C Send and Receive TPs</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sna_cpi_c_send_and_receive_tps_cpic"></a>CPI-C Send and Receive TPs</h2>
<p>
These TPs are CPI-C versions of the APPC send and receive TPs. The sample code illustrates the use of asynchronous CPI-C calls.</p>
<h4>Setup</h4>
<h5><img src="../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To set up the send and receive TPs</h5>
<ol>
<li>
Create an appropriate APPC LU-LU-mode triplet.</li>
<li>
Set up a CPI-C symbolic destination name that contains the configured remote LU and mode. (The default symbolic destination name is CPICRECV.)</li>
<li>
Assign the local APPC LU to the CPICSEND TP, either by using a registry entry of CPICSEND:REG_SZ:<i>LocalLUAlias</i> in the <b>SnaBase\Parameters\Clients</b> key, or by assigning the local LU as the default local APPC LU for the user who will run CPICSEND.</li>
</ol>
<p>
For example, use SENDLU-RECVLU-#INTER as your LU-LU-mode triplet. Then create a CPI-C symbolic destination name CPICRECV containing the application TP name CPICRECV, the partner LU alias RECVLU, and the mode name #INTER. Finally, add the intended user to the users list, and assign SENDLU as the user's default local APPC LU.</p>
<h4>Input and Output</h4>
<p>
CPICSEND and CPICRECV use the files CPICSEND.CFG and CPICRECV.CFG for input. These files should be placed in the directory that contains the TP (executable file). These files are similar to the input files for the APPC send and receive TPs. </p>
<p>
The following entries are for CPICSEND only:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=27%>Line</th>
<th align=left width=27%>Default value</th>
<th align=left width=46%>Value to supply</th>
</tr>
<tr valign=top>
<td width=27%><code>ResultFile =</code></td>
<td width=27%>C:\CPICSEND.OUT</td>
<td width=46%>File name to print timings to.</td>
</tr>
<tr valign=top>
<td width=27%><code>NumSends =</code></td>
<td width=27%>2</td>
<td width=46%>Number of <a href="cpic03_94ir.htm"><b>Send_Data</b></a> calls per conversation.</td>
</tr>
<tr valign=top>
<td width=27%><code>SendSize =</code></td>
<td width=27%>1024</td>
<td width=46%>Size in bytes of data sent each time.</td>
</tr>
<tr valign=top>
<td width=27%><code>ConfirmEvery =</code></td>
<td width=27%>1</td>
<td width=46%>Number of <b>Send_Data</b> calls between <a href="cpic03_5q8z.htm"><b>Confirm</b></a> calls.</td>
</tr>
<tr valign=top>
<td width=27%><code>SymDestName =</code></td>
<td width=27%>CPICSEND</td>
<td width=46%>Symbolic destination name.</td>
</tr>
<tr valign=top>
<td width=27%><code>NumConversations =</code></td>
<td width=27%> — </td>
<td width=46%>Number of conversations. This setting must be the same for CPICSEND and CPICRECV (they do not negotiate the number).</td>
</tr>
<tr valign=top>
<td width=27%><code>WaitMode=</code></td>
<td width=27%>NO</td>
<td width=46%>YES or NO: Use wait mode with asynchronous call completion. If NO, the TPs issue <a href="cpic03_3kir.htm"><b>Specify_Windows_Handle</b></a> with their window handle so that Windows CPI-C will post completion messages to them. If YES, the TPs issue <b>Specify_Windows_Handle</b> with NULL so that the TPs must then issue the <a href="cpic03_6un7.htm"><b>Wait_For_Conversation</b></a> call to wait for the asynchronous call to complete.</td>
</tr>
</table><br>
<p>
The following entries are for CPICRECV only:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=27%>Line</th>
<th align=left width=27%>Default value</th>
<th align=left width=46%>Value to supply</th>
</tr>
<tr valign=top>
<td width=27%><code>LocalTPName =</code></td>
<td width=27%>CPICRECV</td>
<td width=46%>Local TP name to use on <a href="cpic03_68wz.htm"><b>Specify_Local_TP_Name</b></a> call.</td>
</tr>
<tr valign=top>
<td width=27%><code>NumConversations =</code></td>
<td width=27%> — </td>
<td width=46%>Number of conversations. This setting must be the same for CPICSEND and CPICRECV (they do not negotiate the number).</td>
</tr>
<tr valign=top>
<td width=27%><code>WaitMode=</code></td>
<td width=27%>NO</td>
<td width=46%>YES or NO: Use wait mode with asynchronous call completion. If NO, the TPs issue <a href="cpic03_3kir.htm"><b>Specify_Windows_Handle</b></a> with their window handle so that Windows CPI-C will post completion messages to them. If YES, the TPs issue <b>Specify_Windows_Handle</b> with NULL so that the TPs must then issue the <a href="cpic03_6un7.htm"><b>Wait_For_Conversation</b></a> call to wait for the asynchronous call to complete.</td>
</tr>
</table><br>
<p>
As with SENDTP, CPICSEND produces C:\CPICSEND.OUT (by default) with timings of the conversations in it.</p>
<h4>Operation</h4>
<p>
CPICRECV should be started first; it issues <a href="cpic03_68wz.htm"><b>Specify_Local_TP_Name</b></a> to set its local TP name, and then <a href="cpic03_70df.htm"><b>Accept_Conversation</b></a> to accept a conversation (note that because <b>Specify_Local_TP_Name</b> is issued, the <b>Accept_Conversation</b> will complete asynchronously).</p>
<p>
Both TPs issue <a href="cpic03_3kir.htm"><b>Specify_Windows_Handle</b></a> during initialization to set either the window handle or NULL. CPICSEND calls <a href="cpic03_5uoz.htm"><b>Set_Processing_Mode</b></a> after completion of <a href="cpic03_0jhf.htm"><b>Initialize_Conversation</b></a> to set the processing mode to nonblocking for this conversation.</p>
<p>
After each call is issued, the return code is checked; if it is not cm_operation_incomplete, the call has already completed, so an ASYNC_COMPLETE message is posted to trigger the next call. If <i>WaitMode</i> is set to YES and the issued call did not complete immediately, then a <a href="cpic03_6un7.htm"><b>Wait_For_Conversation</b></a> call is issued to wait for call completion, at which point an ASYNC_COMPLETE message is posted. If <i>WaitMode</i> is set to NO and the issued call did not complete immediately, then Windows CPI-C detects call completion and posts an ASYNC_COMPLETE message. Receipt of the ASYNC_COMPLETE message triggers the next call to be issued. </p>
<p>
For CPICSEND, each conversation consists of an <a href="cpic03_2krn.htm"><b>Allocate</b></a> call, followed by a given number of <a href="cpic03_94ir.htm"><b>Send_Data</b></a> calls of given size and interspersed with <a href="cpic03_5q8z.htm"><b>Confirm</b></a> calls at a given interval, followed by a <a href="cpic03_5vkz.htm"><b>Deallocate</b></a>.</p>
<p>
CPICRECV issues <a href="cpic03_3vhf.htm"><b>Receive</b></a> on completion of the <a href="cpic03_70df.htm"><b>Accept_Conversation</b></a>, and then issues either <b>Receive</b> or <a href="cpic03_6c6b.htm"><b>Confirmed</b></a> according to the return from the previous <b>Receive</b>.</p>
<p>
At any stage, if the TPs encounter an error, they terminate. Use CPI-C API tracing to diagnose problems with the configuration.</p>
<p>
Both TPs are built from a single source-code file, CPICSR.C. CPICSEND is compiled only if -DCPICSEND is used on the command line.</p>
<p>
The TPs run as Windows NT or Windows 95 applications with a minimized window, the title of which displays the status. When the WndProc of this window, TPWndProc, receives the WM_CREATE message for the window, this triggers the issuing of the first call. When TPWndProc receives an ASYNC_COMPLETE message from Windows CPI-C, this triggers the issuing of the next call, dependent on what the previous call was. When the window is closed, <a href="cpic04_455v.htm"><b>WinCPICCleanup</b></a><b> </b>is issued to terminate any active conversations.</p>
<p>&nbsp;</p></body>
</HTML>
