<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Windows NT and Windows 95 Considerations</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_sna_windows_nt_and_windows_95_considerations_cpic"></a>Windows NT and Windows 95 Considerations</h1>
<p>
This topic summarizes things to keep in mind when you are developing programs on a server based on Microsoft® Windows NT® or Windows® 95.
<dl>
<dt>
<b>Asynchronous completion notification using message posting</b></dt>
<dd>
When an asynchronous operation is complete, the application's window <i>hwndNotify</i> receives the message returned by <b>RegisterWindowMessage</b> with "WinAsyncCPIC" as the input string. The <i>wParam</i> value contains the <i>conversation_return_code</i> from the operation that is completing. Its values depend on which operation was originally issued. The <i>IParam</i> argument contains the CM_PTR to the <i>conversation_ID</i> specified in the original function call.</dd>
<dt>
<b>Asynchronous completion notification using Win32 events</b></dt>
<dd>
When a verb is issued on a non-blocking conversation, it returns CM_OPERATION_INCOMPLETE if it is going to complete asynchronously. If an event has been registered with the conversation, then the application can call <b>WaitForSingleObject</b> or <b>WaitForMultipleObjects</b> to be notified of the completion of the verb. <a href="cpic04_51yb.htm"><b>WinCPICExtractEvent</b></a> allows a CPI-C application<b> </b>to determine this event handle. After the verb has completed, the application must call <a href="cpic03_6un7.htm"><b>Wait_for_Conversation</b></a><b> </b>to determine the return code for the asynchronous verb. The <a href="cpic03_017n.htm"><b>Cancel_Conversation</b></a><b> </b>function can be called to cancel an operation and the conversation itself.
<p>
It is the responsibility of the application to reset the event, as it is with other APIs.

<p>
If no event has been registered, then the asynchronous verb completes as it does at present, which is by posting a message to the window that the application has registered with the CPI-C library.
</dd>
<dt>
<b>Byte ordering</b></dt>
<dd>
By default, Intel byte ordering is used. For inline environments, defining NON_INTEL_BYTE_ORDER will do all the required flipping for constants. Nonconstant input parameters in verb control blocks (VCBs)—for example, lengths and pointers—are always in the native format.</dd>
<dt>
<b>Events</b></dt>
<dd>
To receive data asynchronously, an event handle is passed in the semaphore field of the VCB. This event must be in the nonsignaled state when passed to CPI-C, and the handle must have EVENT_MODIFY_STATE access to the event. </dd>
<dt>
<b>Library name</b></dt>
<dd>
In preparation for the coexistence of Win16 and Win32® API libraries on the same computer, the Win32 DLL name has been changed from WINCPIC.DLL to WINCPIC32.DLL.
<p>
The old DLL name should be used for Win32-based applications that are required to run on Microsoft® SNA Server version 2.0. The new DLL name should be used for Win32-based applications that are intended to run only on SNA Server version 2.1 or later versions.

<p>
If you intend your Win32-based application to be used with SNA Server version 2.0, you should link with the library included with SNA Server version 2.0. Otherwise use the new library provided with SNA Server version 2.1.
</dd>
<dt>
<b>Multiple threads</b></dt>
<dd>
A TP can have multiple threads that issue verbs. Windows CPI-C makes provisions for multithreaded Windows-based processes. A process contains one or more threads of execution. All references to threads refer to actual threads in a multithreaded Windows environment.</dd>
<dt>
<b>Packing</b></dt>
<dd>
For performance reasons, the VCBs are not packed. As a result of this, DWORDs are on DWORD boundaries, WORDs on WORDs, and BYTEs on BYTEs. VCBs should be accessed using the structures provided.</dd>
<dt>
<b>Run-time linking</b></dt>
<dd>
For a TP to be dynamically linked to CPI-C at run time, the TP must issue:
<ul>
<li>
<b>LoadLibrary</b> to dynamically load WINCPIC.DLL or WINCPIC32.DLL, the libraries for WINCPIC.</li>
<li>
<b>GetProcAddress</b> to specify WINCPIC as the desired entry point to the dynamic-link library (DLL).</li>
</ul>

<p>
Issue the <b>FreeLibrary</b> call when the CPI-C library is no longer required.
</dd>
<dt>
<b>Simultaneous conversations</b></dt>
<dd>
A program can simultaneously participate in as many as 64 conversations per process.</dd>
<dt>
<b>Terminating applications</b></dt>
<dd>
In the Windows NT and Windows 95 environments, CPI-C cannot tell when an application terminates. Therefore, if an application must close (for example, it receives a WM_CLOSE message as a result of an ALT+F4 from a user), the application should call <a href="cpic04_455v.htm"><b>WinCPICCleanup</b></a>.</dd>
<dt>
<b>Yielding to other components</b></dt>
<dd>
When processing CPI-C and Common Service Verbs (CSV), it may be necessary for the library code to yield to allow another component, such as the SnaBase, to receive messages and pass them to the application. This can be accomplished by using the Windows extensions <a href="cpic04_4l2b.htm"><b>WinCPICSetBlockingHook</b></a> and <a href="cpic04_0jhf.htm"><b>WinCPICUnhookBlockingHook</b></a>.
<p>
<b>WinCPICSetBlockingHook</b> allows a Windows CPI-C implementation to block CPI-C function calls by means of a new function. This call is used by Windows version 3.<i>x </i>applications to make blocking calls without blocking the rest of the system. To call <b>WinCPICSetBlockingHook</b>:

<pre><code>FARPROC WINAPI WinCPICSetBlockingHook (FARPROC 1pBlockFunc)
 </code></pre>

<p>
<b>WinCPICUnhookBlockingHook</b> removes any previous blocking hook that has been installed and reinstalls the default blocking mechanism. To call <b>WinCPICUnhookBlockingHook</b>:

<pre><code>BOOL WINAPI WinCPICUnhookBlockingHook (void)
 </code></pre>
</dd>
</dl>
<p>&nbsp;</p></body>
</HTML>
