<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SNA Considerations</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_sna_sna_considerations_lua"></a>SNA Considerations</h1>
<p>
This section explains SNA information you need to consider when writing LUA applications.
<dl>
<dt>
<b>BIND checking</b></dt>
<dd>
During initialization of the LU session, the host sends to the LUA application a BIND message that contains information such as RU sizes for use by the LU session. Microsoft® SNA Server returns this message to the LUA application on <a href="luac03_7dwh.htm"><b>RUI_READ</b></a>. The LUA application must verify that the parameters specified on the BIND are suitable. The application has the following options:
<ul>
<li>
It can accept the BIND as it is, by issuing <a href="luac03_7uap.htm"><b>RUI_WRITE</b></a> containing an OK response to the BIND. No additional BIND data can be sent on the response.</li>
<li>
It can try to negotiate one or more BIND parameters (this is only permitted if the BIND is negotiable). To do this, the application issues <b>RUI_WRITE</b> containing an OK response, but including the modified BIND as data.</li>
<li>
It can reject the BIND by issuing <b>RUI_WRITE</b> containing a negative response, using an appropriate SNA sense code as data.</li>
</ul>

<p>
Note that validating the BIND parameters, and ensuring that all messages sent are consistent with them, is the responsibility of the LUA application. However, the following two restrictions apply:

<ul>
<li>
SNA Server rejects any <b>RUI_WRITE</b> that specifies an RU length greater than the size specified on the BIND.</li>
<li>
SNA Server requires the BIND to specify that the secondary LU is the contention winner and that error recovery is the responsibility of the contention loser.</li>
</ul>

<p>
<b>Note  </b>For SLI, an application must specify that it will use <a href="luac04_6rkx.htm"><b>SLI_BIND_ROUTINE</b></a> on the <a href="luac04_7bxd.htm"><b>SLI_OPEN</b></a> if it will do any BIND checking.

</dd>
<dt>
<b>Courtesy acknowledgments</b></dt>
<dd>
SNA Server keeps a record of requests received from the host in order to correlate any response sent by the application with the appropriate request. When the application sends a response, SNA Server correlates the response with the data from the original request, and can then free the storage associated with it.
<p>
If the host specifies exception response only (a negative response can be sent but a positive response should not be sent), SNA Server must still keep a record of the request in case the application subsequently sends a negative response. If the application does not send a response, the storage associated with this request cannot be freed.

<p>
Because of this, SNA Server allows the LUA application to issue a positive response to an exception-response-only request from the host (this is known as a courtesy acknowledgment). The response is not sent to the host, but is used by LUA to clear the storage associated with the request.

<p>
Note that the application does not need to send a courtesy acknowledgment for each exception-response-only request. For efficiency, the application can respond less frequently. The node treats a courtesy acknowledgment as an implicit acknowledgment for all prior pending requests.
</dd>
<dt>
<b>Distinguishing SNA sense codes from other secondary return codes</b></dt>
<dd>
A secondary return code that is not a sense code always contains a value of zero in its first two bytes.
<p>
An SNA sense code always contains a nonzero value in its first two bytes; the first byte gives the sense code category and the second identifies a particular sense code within that category. (The third and fourth bytes can contain additional information or can be zero.)
</dd>
<dt>
<b>Information on SNA sense codes</b></dt>
<dd>
If you need information on a returned sense code, see Sense Codes in the SNA Formats document. The sense codes are listed in numerical order by category.</dd>
<dt>
<b>Negative responses and SNA sense codes</b></dt>
<dd>
SNA sense codes can be returned to an LUA application in the following cases:
<ul>
<li>
When the host sends a negative response to a request from the LUA application, it includes an SNA sense code indicating the reason for the negative response. This is reported to the application on a subsequent <a href="luac03_7dwh.htm"><b>RUI_READ</b></a> or <a href="luac04_2nfl.htm"><b>SLI_RECEIVE</b></a> with the following information:<table cellspacing=4 cols=2>
<tr valign=top>
<td width=52%>Primary return code</td>
<td width=48%>LUA_OK</td>
</tr>
<tr valign=top>
<td width=52%>Request/response indicator, response type indicator, and sense data included indicator</td>
<td width=48%>All set to 1, indicating a negative response that includes sense data.</td>
</tr>
<tr valign=top>
<td width=52%>Data returned</td>
<td width=48%>The SNA sense code.</td>
</tr>
</table><br>
</li>
<li>
When SNA Server receives invalid data from the host, it generally sends a negative response to the host and does not pass the invalid data to the LUA application. This is reported to the application on a subsequent <a href="luac03_7dwh.htm"><b>RUI_READ</b></a><b>, <a href="luac04_2nfl.htm">SLI_RECEIVE</a>,</b> <a href="luac03_8fmp.htm"><b>RUI_BID</b></a><b>, </b>or<b> <a href="luac04_5z8h.htm">SLI_BID</a></b> with the following information:<table cellspacing=4 cols=2>
<tr valign=top>
<td width=50%>Primary return code</td>
<td width=50%>LUA_NEGATIVE_RESPONSE</td>
</tr>
<tr valign=top>
<td width=50%>Secondary return code</td>
<td width=50%>The SNA sense code sent to the host.</td>
</tr>
</table><br>
</li>
<li>
In some cases, SNA Server detects that data supplied by the host is invalid, but cannot determine the correct sense code to send. In this case, it passes the invalid data in an exception request (EXR) to the LUA application on <a href="luac03_7dwh.htm"><b>RUI_READ</b></a> or <a href="luac04_2nfl.htm"><b>SLI_RECEIVE</b></a> with the following information:<table cellspacing=4 cols=2>
<tr valign=top>
<td width=52%>Request/response indicator</td>
<td width=48%>Set to 0, indicating a request.</td>
</tr>
<tr valign=top>
<td width=52%>Sense data included indicator</td>
<td width=48%>Set to 1, indicating that sense data is included. (This indicator is normally used only for a response.)</td>
</tr>
<tr valign=top>
<td width=52%>Message data</td>
<td width=48%>A suggested SNA sense code.</td>
</tr>
</table><br>
<p>
The application must then send a negative response to the message; it can use the sense code suggested by SNA Server, or it can alter the sense code.
</li>
<li>
SNA Server can send a sense code to the application to indicate that data supplied by the application was invalid. This is reported to the application on <a href="luac03_7uap.htm"><b>RUI_WRITE</b></a> or <a href="luac04_2lr5.htm"><b>SLI_SEND</b></a> with the following information:<table cellspacing=4 cols=2>
<tr valign=top>
<td width=52%>Primary return code</td>
<td width=48%>LUA_UNSUCCESSFUL</td>
</tr>
<tr valign=top>
<td width=52%>Secondary return code</td>
<td width=48%>SNA sense code.</td>
</tr>
</table><br>
<p>
The sense codes that can be returned as secondary return codes on LUA verbs are listed in the WINLUA.H header file; see the SNA Server Software Development Kit for this file.
</li>
</ul>
</dd>
<dt>
<b>Pacing</b></dt>
<dd>
Pacing is handled by the LUA interface; an LUA application does not need to control pacing and should never set the pacing indicator flag.
<p>
If pacing is being used on data sent from the LUA application to the host (this is determined by the BIND), <a href="luac03_7uap.htm"><b>RUI_WRITE</b></a> or <a href="luac04_2lr5.htm"><b>SLI_SEND</b></a> may take some time to complete. This is because LUA has to wait for a pacing response from the host before it can send more data.

<p>
If an LUA application transfers large quantities of data in one direction, either to the host or from the host (for example, a file transfer application), then the host configuration should specify that pacing is used in that direction. This ensures that the node receiving the data is not flooded with data and does not run out of data storage.
</dd>
<dt>
<b>Purging data to end of chain</b></dt>
<dd>
When the host sends a chain of request units to an LUA application, the application can wait until the last RU in the chain is received before sending a response, or it can send a negative response to an RU that is not the last in the chain. If a negative response is sent midchain, LUA purges all subsequent RUs from this chain and does not send them to the application.
<p>
When LUA receives the last RU in the chain, it indicates this to the application by setting the primary return code of <a href="luac03_7dwh.htm"><b>RUI_READ</b></a> or <a href="luac03_8fmp.htm"><b>RUI_BID</b></a> to lua_negative_response with a zero secondary return code.

<p>
Note that the host can terminate the chain by sending a message such as CANCEL while in midchain. In this case, the CANCEL message is returned to the application on <b>RUI_READ</b>. The lua_negative_response return code is not used.
</dd>
<dt>
<b>Segmentation</b></dt>
<dd>
Segmentation of RUs is handled by the LUA interface. LUA always passes complete RUs to the application, and the application should pass complete RUs to LUA.
</dd>
</dl>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
