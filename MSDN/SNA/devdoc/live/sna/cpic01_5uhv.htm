<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Asynchronous Call Completion</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sna_using_asynchronous_call_completion_cpic"></a>Using Asynchronous Call Completion</h2>
<p>
With one exception, SNA Server permits one outstanding Windows SNA asynchronous call per connection and one blocking verb per thread. The exception to this guideline is that when issuing an asynchronous <a href="cpic03_3vhf.htm"><b>Receive</b></a> call, the following calls can be issued while the <b>Receive</b> is outstanding:</p>
<p class=indent1>
<a href="cpic03_017n.htm"><b>Cancel_Conversation</b></a></p>
<p class=indent1>
<a href="cpic03_5vkz.htm"><b>Deallocate</b></a></p>
<p class=indent1>
<a href="cpic03_6crn.htm"><b>Request_To_Send</b></a></p>
<p class=indent1>
<a href="cpic03_2j6r.htm"><b>Send_Error</b></a></p>
<p class=indent1>
<a href="cpic03_1z1f.htm"><b>Test_Request_To_Send_Received</b></a></p>
<p>
This allows an application, in particular a 5250 emulator, to use an asynchronous <b>Receive</b> to receive data. Use of this feature is strongly recommended.</p>
<p>
The following example illustrates how to use asynchronous call completion for SNA Server:</p>
<pre><code>void ProcessVerbCompletion (WPARAM wParam LPARAM lParam)

{
    for ( i = 0; i&lt;nPendingVerbs; i++ )
        if (memcmp  (pPending [i].ConvID, (Conversation_ID) lParam) = = 0)
            ProcessCommand  (wParam, lParam);

}

LRESULT CALLBACK SampleWndProc  ( . . .)

{
    if (msg = = uAsyncCPIC )   {
        ProcessVerbCompletion  (wParam, lParam);
    }
    else switch  (msg)  {
       case WM_USER:
        Initialize_Conversation  ( lpConvId,  "GORDM",  &amp;lError  );
        if  ( lError  ! = CM_OK )   {
            ErrorDisplay ( ) ;
            break ;
        }
        Set_Processing_Mode  ( lpConvId,  CM_NON_BLOCKING,  &amp;lError  ) ;
        if  ( lError ! = CM_OK )  {
            ErrorDisplay ( ) ;
            break ;
        }
        Allocate  ( lpConvId,  &amp;lError )  ;
        switch  ( lError )  {

        case CM_OK:
            break ;

        case CM_OPERATION_INCOMPLETE:
            memcopy  (pPending [nPending ++].ConvId,  lpConvId,  sizeof  (C) ;
            break ;
        default:
            ErrorDisplay ( ) ;

        }
        break ;
}

WinMain  ( . . . )
{
    if  ( ( WinCPICStartup  ( . . . )  =  =  FALSE  )   {
        return FALSE;

    }
    uAsyncCPIC = RegisterWindowMessage  ("WinAsyncCPIC"");
    Specify_Windows_Handle  (hwndSample) ;
    while  (GetMessage  ( . . . )   )   {
    . . . . .
    }
    WinCPICCleanup  ( . . . )

}
 </code></pre>
<p>
For more information on CPI-C calls and Windows extensions, see <a href="cpic03_4w83.htm">CPI-C Calls</a> and <a href="cpic04_5xcz.htm">Extensions for the Windows Environment</a>. For additional information on using CPI-C, see the <i>IBM Systems Application Architecture Common Programming Interface Communications Reference</i>, part number SC26-4399-04.</p>
<p>&nbsp;</p></body>
</HTML>
