<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Outbound Data</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sna_outbound_data_3270"></a>Outbound Data</h2>
<p>
This section describes the outbound data flows from the local node to the application. The overall structure of the protocols described applies to the SSCP and PLU connections, but certain features (such as the use of delayed request mode) are only applicable to the PLU connection.</p>
<p>
The local node presents data originating at the host to the application on different connections, depending on the SNA session on which the data flows, as follows:
<ul>
<li>
FMD NS (session services) data and FMD data originating at the host SSCP and directed to the Microsoft® SNA Server LU is sent to the application on the SSCP connection.</li>
<li>
FMD data originating at the host PLU and directed to an SNA Server LU is sent to the application on the PLU connection.</li>
</ul>
<p>
For all connections, only FMD requests are presented to the application as <a href="3270c4_4eeo.htm"><b>Data</b></a> messages (that is, with message-type = DATAFMI). DFC and session control requests are used to generate <b>Status-Control</b> messages (see <a href="3270c3_11ps.htm"><b>Status-Control</b> Message</a>).</p>
<p>
The local node performs the data flow control state changes required by the RH indicators in the request, before sending a <b>Data</b> message to the application.</p>
<p>
The SNA request TH (transmission header) and RH indicators are not available to the application on outbound <b>Data</b> messages. Instead, the local node provides application flags in the <b>Data</b> message header that reflect the settings of a subset of the RH indicators, but are interpreted by the local node to shield the application from the more obscure aspects of chaining and bracket usage. See <a href="3270c3_74vk.htm">Application Flags</a> for a description of the available flags and the way in which the local node uses them on outbound data.</p>
<p>
For outbound data, the first byte is RU[0] for standard FMI, and TH[0] for the LUA variant of FMI.</p>
<p>
All <a href="3270c4_4eeo.htm"><b>Data</b></a> messages from the local node to an application contain a message key. The local node maintains a unique message key sequence for each outbound data flow to an application. When the local node sends a <b>Data</b> message to an application on a particular connection, it places the next message key in the outbound sequence into the message header, sets the application flags, and sends the message to the application. This means that the message key uniquely identifies a <b>Data</b> message on a particular connection between the local node and the application. Note that the local node also places message keys on outbound <b>Status-Control Request</b> messages.</p>
<p>
The acknowledgment protocol enforced by SNA Server reflects the chain response protocol and request mode in use on the SNA session, as follows:
<ul>
<li>
Outbound RQD requests generate <a href="3270c4_4eeo.htm"><b>Data</b></a> messages with ACKRQD set in the message header.</li>
<li>
Outbound RQE requests generate <b>Data</b> messages without ACKRQD set.</li>
<li>
Outbound RQN requests generate <b>Data</b> messages without ACKRQD set.</li>
<li>
If the session uses primary immediate request mode, a <b>Data</b> message with ACKRQD set must be acknowledged by the application before further <b>Data</b> messages will be received.</li>
<li>
If the session uses primary delayed request mode, a <b>Data</b> message with ACKRQD set need not be immediately acknowledged by the application; <b>Data</b> messages will continue to be received.</li>
</ul>
<p>
Note that SNA Server enforces the equivalent of immediate response mode for the outbound data acknowledgment protocol for all connections. That is, the application must send acknowledgments in order.</p>
<p>
If the local node sets the ACKRQD field in the message header of a <a href="3270c4_4eeo.htm"><b>Data</b></a> message to the application, it indicates that an acknowledgment to this <b>Data</b> message is required. The application acknowledges an outbound <b>Data</b> message by sending a <b>Status-Acknowledge</b> message to the local node on the same connection, which contains the same message key and sequence number fields as the <b>Data</b> message.</p>
<p>
On receipt of a <a href="3270c4_5z00.htm"><b>Status-Acknowledge(Ack)</b></a>, the local node correlates the message key with outstanding outbound messages and generates an SNA positive response to the appropriate SNA request.</p>
<p>
The application should use the <a href="3270c4_11bk.htm"><b>Status-Acknowledge(Nack-1)</b></a> message as a negative acknowledgment. On receipt of a <b>Status-Acknowledge(Nack-1)</b>, the local node correlates the message with outstanding outbound messages and generates an SNA negative response plus sense data to the appropriate SNA request. The application supplies the sense data that should accompany the negative response as part of the <b>Status-Acknowledge(Nack-1)</b> message and must include the same message key, application flags, and sequence number fields as the <b>Data</b> message to which this is a negative acknowledgment.</p>
<p>
<b>Status-Control</b> messages caused by expedited-flow requests can be sent at any time and do not affect the sending of positive or negative acknowledgment to normal flow outbound <b>Data</b> messages. The fact that they can occur between an outbound <b>Data</b> message and the matching <b>Status-Acknowledge</b> message is purely coincidental. See <a href="3270c3_11ps.htm"><b>Status-Control</b> Message</a> for details of which <b>Status-Control</b> messages correspond to SNA requests.</p>
<p>
If errors are detected in the format of a normal flow request from the host or the request is inappropriate for the state of the session, the local node generates an error <a href="3270c4_4eeo.htm"><b>Data</b></a> message for the application with the following characteristics:
<ul>
<li>
The SDI and ECI application flags are set.</li>
<li>
The sense code associated with the error occupies the first four bytes of the <b>Data</b> message (see <a href="3270c3_11ps.htm"><b>Status-Control</b> Message</a>).</li>
<li>
ACKRQD is set.</li>
</ul>
<p>
The application should return a <a href="3270c4_5z00.htm"><b>Status-Acknowledge(Ack)</b></a>, and the local node generates a negative response carrying the sense code appropriate to the detected error. This mechanism:
<ul>
<li>
Informs the application of the detected error.</li>
<li>
Allows the application to respond to any previously-received data before the local node sends the negative response to this <b>Data</b> message.</li>
</ul>
<p>
On sessions where the application is receiving a series of RQE chains, the local node will be retaining correlation information for each chain (in case the application wishes to send negative responses to any of the chains). If the local node runs out of correlation table entries, it will attempt to allocate more entries and (if this fails) will be forced to terminate sessions. To prevent this, the application should provide <b>Status-Acknowledge(Ack)</b> messages for RQE data that it does not wish to reject in this case; a response after five consecutive RQE chains should be sufficient. Such messages are referred to as courtesy acknowledgements and do not give rise to a response to the host, but merely free internal correlation data.</p>
<p>
The following six figures illustrate the data acknowledgment protocol enforced between the local node and the application, and show the effects of the application generating positive and negative <b>Status-Acknowledge</b> messages.</p>
<p>
The figures show:
<ul>
<li>
The relevant RH flags in SNA requests/responses.</li>
<li>
The sequence number of SNA requests/responses.</li>
<li>
Any sense data (shown as "SENSE=...") on SNA requests/responses and <b>Status-Acknowledge</b> messages.</li>
<li>
The ACKRQD field in <a href="3270c4_4eeo.htm"><b>Data</b></a> messages.</li>
<li>
The message key field in <b>Data</b> messages.</li>
</ul>
<p>
For simplicity, all messages are assumed to be FM data flowing on the same PLU session.</p>
<p>
In the following illustration, the application accepts a <b>Data</b> message corresponding to a definite-response RU.</p>
<p>
<img src="images/32703w.gif" border=0></p>
<p>
In the following illustration, the application accepts a <b>Data</b> message corresponding to a multi-RU definite-response chain.</p>
<p>
<img src="images/32703wa.gif" border=0></p>
<p>
In the following illustration, the application rejects a <b>Data</b> message corresponding to a definite-response chain.</p>
<p>
<img src="images/32703wb.gif" border=0></p>
<p>
In the following illustration, the application rejects a <b>Data</b> message corresponding to a multi-RU definite-response chain.</p>
<p>
<img src="images/32703wc.gif" border=0></p>
<p>
In the following illustration, the local node enforces immediate response mode; that is, responses must be sent in sequence. The application rejects the second exception-response chain and accepts the definite-response chain, which implies acceptance of the third exception-response chain.</p>
<p>
<img src="images/32703wd.gif" border=0></p>
<p>
In the following illustration, the local node detects a chaining error (RQD but not EC) in data destined for the application (this example requires the receive check 0x4007 to be in force — see <a href="3270c3_425s.htm">Opening the SSCP Connection</a>).</p>
<p>
<img src="images/32703we.gif" border=0></p>
<p>&nbsp;</p></body>
</HTML>
