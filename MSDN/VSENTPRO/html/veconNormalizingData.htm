<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Normalizing the Data</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconnormalizingdata"></a>Normalizing the Data</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconNormalizingData_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconNormalizingData_T">
</object></p>
<p>
The task of a database designer is to structure the data in a way that eliminates unnecessary duplication and provides a rapid search path to all necessary information. The process of refining tables, keys, columns, and relationships to create an efficient database is called <i>normalization</i>. Normalizing is not just for relational files: it's also a common design activity for indexed files.</p>
<p>
Normalization is a complex process with many specific rules and different levels intensity. In its full definition, normalization is the process of discarding repeating groups, minimizing redundancy, eliminating composite keys for partial dependency, and separating nonkey attributes. In simple terms, the rules for normalization can be summed up in a single phrase: "Each attribute (column) must be a fact about the key, the whole key, and nothing but the key." Said another way, each table should describe only one type of entity (such as a person, place, customer order, or product item).</p>
<p>
Some of the benefits of normalization are:</p>
<ul type=disc>
<li>
Data integrity (because there is no redundant, neglected data).</li>
<li>
Optimized queries (because normalized tables produce rapid, efficient joins).</li>
<li>
Faster index creation and sorting (because the tables have fewer columns).</li>
<li>
Faster UPDATE performance (because there are fewer indexes per table).</li>
<li>
Improved concurrency resolution (because table locks will affect less data).</li>
</ul>
<p>
You can normalize most simple databases by following a simple rule of thumb: tables that contain repeated information should be divided into separate tables to eliminate the duplication.</p>
<p>
For example, let's say your new application is for a bookseller who must track information about each book, including the following data.</p>
<ul type=disc>
<li>
Author name</li>
<li>
Author address</li>
<li>
Author phone</li>
<li>
Title</li>
<li>
ISBN (International Scientific Book Number)</li>
<li>
Year published</li>
<li>
Publisher name</li>
<li>
Publisher address</li>
<li>
Publisher phone</li>
</ul>
<p>
You could simply create a single table with a field for each of the data items listed. Looking closely at the data, however, it's obvious that such a table would contain many redundancies. For example, many authors have written more than one book, so the publisher information for each book title would be repeated many times. If you put all of these fields into a single table there would be many confusing and duplicate entries.</p>
<p>
Using the principles of normalization, you might break the data into four groups: Authors, AuthorsTitles, Titles, and Publishers, as shown in the following table.</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=label width=21%><b>Authors table</b></td>
<td class=label width=27%><b>AuthorsTitles table</b></td>
<td class=label width=25%><b>Titles table</b></td>
<td class=label width=27%><b>Publishers table</b></td>
</tr>
<tr valign=top>
<td width=21%>au_id (key)</td>
<td width=27%>au_id (foreign key)</td>
<td width=25%>ti_isbn (key)</td>
<td width=27%>pu_id (key)</td>
</tr>
<tr valign=top>
<td width=21%>au_name</td>
<td width=27%>ti_isbn (foreign key)</td>
<td width=25%>ti_title</td>
<td width=27%>pu_name</td>
</tr>
<tr valign=top>
<td width=21%>au_address</td>
<td width=27%></td>
<td width=25%>ti_yearpublished</td>
<td width=27%>pu_address</td>
</tr>
<tr valign=top>
<td width=21%>au_phone</td>
<td width=27%></td>
<td width=25%>pu_id (foreign key)</td>
<td width=27%>pu_phone</td>
</tr>
</table><br>
<p>
The keys provide a means of establishing table relationships. For example, the AuthorsTitles table creates a one-to-many relationship between the Authors and Titles tables (an author may write many titles). Using the AuthorsTitles table, you can query for every book number an author wrote (using au_id), and also determine which author wrote a certain book (using ti_isbn).</p>
<p>
It's worth noting that instead of creating an AuthorsTitles table, an alternative approach would be to add the au_id attribute into the Titles table. This option is neither right nor wrong: it's simply one of those design tradeoffs where you must evaluate your application's expected query types, possible multiuser concurrency issues, and the possible performance problem of three indexes on one table.</p>
</BODY>
</HTML>
