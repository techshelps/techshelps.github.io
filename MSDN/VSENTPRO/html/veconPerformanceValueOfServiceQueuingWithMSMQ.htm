<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Performance Value of Service Queuing with MSMQ</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconperformancevalueofservicequeuingwithmsmq"></a>Performance Value of Service Queuing with MSMQ</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconPerformanceValueOfServiceQueuingWithMSMQ_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconPerformanceValueOfServiceQueuingWithMSMQ_T">
</object></p>
<p>
With Microsoft Message Queue Server (MSMQ), your application can communicate with other application programs by sending and receiving asynchronous messages. This is generally known as <i>queuing</i>. Queuing provides a very useful architectural design strategy, especially if your application must provide stable, reliable performance.</p>
<p>
In order to understand the performance benefits of queuing, it is important to understand the basic differences between synchronous and asynchronous styles of communication.</p>
<h2>What Are Synchronous and Asynchronous Communication?</h2>
<p>
Most distributed applications today use synchronous communication (such as remote procedure calls) and do not use queuing. Communications are synchronous (not queued) when the sender of a request must wait for a response from the receiver of the request before it can proceed on to performing other tasks. The time that the sender must wait is completely dependent on the time it takes for the receiver to process the request and return a response. It's acceptable to use synchronous communication for workgroup applications if you're willing to supply adequate hardware to handle the workload. Remember, though, that a large peak workload can require a lot of hardware. One of the limitations of the synchronous approach is the overhead involved in starting the server objects. When a client is done with a service, the server object is destroyed.</p>
<p>
With asynchronous communication (queuing), senders make requests to receivers and then immediately move on to other tasks. There is no guarantee that receivers will process requests within any particular period of time, but good real time responsiveness can usually be achieved in all but peak load conditions.</p>
<h2>The Advantage of Queuing</h2>
<p>
Queuing gives developers another set of design options, including the following:</p>
<ul type=disc>
<li>
The sender may want to perform other work while waiting for the receiver to respond to a request.</li>
<li>
Responses are not always required, and waiting for the receiver to process the request is unnecessary and a waste of time.</li>
<li>
The sender may not be running at the same time as the server.</li>
<li>
Excessive requests are saved (without blocking the clients) until the system can process the requests.</li>
</ul>
<p>
Without queuing, when a burst of requests comes in the object pool starts growing, the objects can't recycle fast enough, and the new object allocations rapidly degrade the server computer's ability to do work. Without queuing, you must have sufficient memory on the server computer to deal with the absolute peak load, which is often many times more than the memory needed for normal processing loads.</p>
<p>
A better answer is to put a queue in front of your objects. That way, even though the queue may get big, the resources that are actually using memory and threads are optimal for the server computer. The queue manager helps to allocate the work so that the server computer can operate using just the right number object resources.</p>
<p>
The choice to use queuing has another particular advantage: if the receiver is not running at the same time as the client, synchronous communication attempts will always fail; asynchronous communications can still succeed.</p>
<p>
Because the queue manager maintains its queue internally, client requests are never refused. If all pre-allocated services are busy, the queue manager simply waits until one becomes available and assigns it to the next waiting client in turn. In distributed solutions, such a queue can be used to keep services busy. This results in servers running at their optimum performance level — that is, fully loaded.</p>
<p>
It should be noted that queuing does impose some processing overhead. Remember, though, that if your application must handle a widely variable number of clients, and the server computer imposes certain resource limits, and then queuing will allow the maximum number of users to access your application with only a slight reduction in performance.</p>
<p>
The performance value of queuing is that it allows your hardware to work at capacity without mismanagement or inefficient use. A side benefit of queuing is that, during peak workloads, the application's throughput degrades gracefully. Queuing is an important design concept required for high-performance, robust applications.</p>
<h2>Using Queuing with MSMQ</h2>
<p>
With MSMQ, application developers can include queuing operations with transactional units of work that access other recoverable resources (such as databases). MSMQ operations can commit or abort in coordination with other resources in the transaction to preserve data integrity. For example, if an application updates a database and sends a message to another application within a transaction, any abort condition will cause the database updates to roll back. MSMQ will also roll back by canceling the send operation. MSMQ never completes the send operation until transactions commit. This prevents receivers from getting messages from transactions that subsequently aborted.</p>
<p>
MSMQ takes similar actions when receive operations occur within a transaction. If the transaction aborts, MSMQ rolls back the receive operation by putting the received message back in its queue. This message becomes available for receipt by subsequent transactions. MSMQ's transactional features are important because many types of problems will occur if abort logic does not include queue operations. For example, if a receive operation does not roll back when associated database operations are rolled back, the message effectively becomes lost because no database processing occurs.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;Microsoft Message Queue Server (MSMQ) is available in the Windows NT Service Pack 4. For more information on installing and using Microsoft Message Queue Server, see http://www.microsoft.com/ntserver/guide/msmq.asp.</p>
</BODY>
</HTML>
