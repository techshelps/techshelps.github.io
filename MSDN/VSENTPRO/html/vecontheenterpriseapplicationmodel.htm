<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Enterprise Application Model</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="vecontheenterpriseapplicationmodel"></a>Enterprise Application Model</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconTheEnterpriseApplicationModel_C;veconTheEnterpriseApplicationModelC">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconTheEnterpriseApplicationModel_T;veconTheEnterpriseApplicationModelT">
</object></p>
<p>
Today's enterprise applications are too complex for anyone to grasp completely. No one can hold all the requirements, option, and design choices in mind at one time, much less understand how each requirement affects all the others. Designing large-scale distributed applications calls for a way to simplify all this complexity, and the best approach to managing complexity is through abstraction. By grouping similar requirements together into a small number of abstract categories, you can approach them in a more orderly way. These groups can be arranged to show how they affect and depend on one another, allowing you to break the overall enterprise application development problem into a small set of more manageable tasks. When you understand the interactions between groups of requirements, you can tackle them in a systematic manner, balancing and adjusting each requirement as you go.</p>
<p>
The Enterprise Application Model presented here is such an abstraction. The model is an orderly summation of all requirements that contribute to implementing every enterprise application, divided into six specific "sub-models." The following table lists these requirements as items to define or deliver within each model.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=37%><b>Model</b></td>
<td class=label width=63%><b>Requirements</b></td>
</tr>
<tr valign=top>
<td width=37%><b>The development model</b></td>
<td width=63%>Development team  Development process  Project management  Source code control  Testing  Application milestones and deliverables</td>
</tr>
<tr valign=top>
<td width=37%><b>The business model</b></td>
<td width=63%>Business goals  Development cost  Return on investment  Resources needed  Time constraints  Security and maintenance  Existing infrastructure investment  Business rules and policies</td>
</tr>
<tr valign=top>
<td width=37%><b>The user model</b></td>
<td width=63%>User interface  Ease-of-use requirements  Training and documentation  Application support  User’s desktop configuration and network connection</td>
</tr>
<tr valign=top>
<td width=37%><b>The logical model</b></td>
<td width=63%>Logical structure of the application  Object and data modeling  Business objects and services  Interface definitions</td>
</tr>
<tr valign=top>
<td width=37%><b>The technology model</b></td>
<td width=63%>Component development or reuse  Development tools  Deployment platforms  System and database technologies  Clustering, pooling, and messaging technologies</td>
</tr>
<tr valign=top>
<td width=37%><b>The physical model</b></td>
<td width=63%>Physical application architecture  Distribution and interconnection of components  End product of the iterative inputs of each of the other sub-models</td>
</tr>
</table><br>
<p>
The following illustration shows not only the categories of requirements an enterprise application must meet, but also the <i>relationships</i> among the various requirements. By following the arrows, you can see the business requirements as the starting point for application development, and the physical architecture of the completed system as the final output. Between these two categories, the user, logical, and technology requirements are fulfilled, with each category depending on inputs from both the business requirements and its neighboring sub-models, and with each model’s outputs directly contributing to the physical architecture that is finally implemented. The development model (the teams and processes applied to developing the application) permeates and coordinates all of the other requirements.</p>
<p class=label>
<b>The Enterprise Application Model</b></p>
<p>
<img src="ve4rjc1.gif" border=0></p>
<p>
This view of the model immediately provides important insights into the requirements for successful enterprise application development.</p>
<ul type=disc>
<li>
Understanding the relationships among the different requirements gives you a way to move through the process of designing and building the application without neglecting the many dependencies that each design task has on other parts of the overall design. We’ll explore this iterative development style at length in "<a href="veovrenterprisedevelopmentteamsprocesses.htm">Enterprise Development Teams and Processes</a>."</li>
<li>
All of the requirements embodied in each of the sub-models are a part of the overall Enterprise Application Model and contribute to the success or failure of your application, whether or not they are consciously addressed in the development process.</li>
<li>
Each sub-model can be treated in a relatively stand-alone manner, much like software components. Each sub-model has its own set of concepts, requirements, techniques and process, tools, state storage, and input/output (deliverables). In most cases the output of each sub-model will become a critical part of the overall functional specification for the project, and this specification will in turn be used to define the project’s physical architecture and to produce the project test plan.</li>
</ul>
<p>
These insights suggest a development process that is iterative and incremental rather than linear. Such a process lets you work on each set of requirements a little bit at a time, and pause at frequent intervals to assess the impact of each model on its neighbors. This helps to identify conflicting requirements early, so you can make design tradeoffs and adjustments when necessary, <i>before</i> they require re-implementing major portions of your application.</p>
<p>
<B><b>For more information</b></B>&nbsp;&nbsp;&nbsp;For more information about the iterative method of development, see Chapter 2, "<a href="veovrenterprisedevelopmentteamsprocesses.htm">Enterprise Development Teams and Processes</a>."</p>
</BODY>
</HTML>
