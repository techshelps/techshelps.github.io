<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Considering Other High-Performance Design Strategies</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconconsideringotherhighperformancedesignstrategies"></a>Considering Other High-Performance Design Strategies</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconConsideringOtherHighPerformanceDesignStrategies_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconConsideringOtherHighPerformanceDesignStrategies_T">
</object></p>
<p>
In choosing a performance optimization strategy for your application, you should carefully choose what to optimize and avoid wasting time optimizing the wrong things. As a general rule, you shouldn't try to optimize everything in your application.</p>
<p>
Your performance goal should be based on the needs and expectations of both the application and the user. For example, speed might be a major concern for completing a sales order in a point-of-sale application, whereas application size might be most important for a component that will be downloaded by way of the Internet.</p>
<p>
You cannot always optimize for multiple characteristics. Typically, an approach that optimizes size compromises on speed; likewise, an application that is optimized for speed is often larger than its slower counterpart. For this reason, recommended optimization techniques in one area may directly contradict suggestions in another.</p>
<p>
It's important to note that optimization is not always completely beneficial. Sometimes the changes you make to speed up or trim down your application result in code that is harder to maintain or debug. Some optimization techniques contradict structured coding practice, which may cause problems when you try to expand your application in the future or incorporate it into other programs.</p>
<p>
As a general guideline, you should maximize performance and scalability using native Windows NT facilities for threading, scheduling, asynchronous I/O, and other system functions wherever possible. In other words, leverage the strengths of the operating system rather than re-create them again.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For information on monitoring your application's use of memory, disk I/O, CPU, objects, threads, and processes, see <a href="veconusingperformancemonitor.htm">Using Performance Monitor</a> in this chapter.</p>
<p>
While the following optimizing suggestions are not exhaustive, you can use these as a starting point for learning more about designing and implementing high-performance applications.</p>
<h2>Using Distributed COM</h2>
<p>
Microsoft's distributed COM (DCOM) supports communication among objects on different computers, different networks, and even the Internet. With DCOM, you can distribute your application to the locations that make the most sense for your customer and the application's design requirements.</p>
<p>
Using DCOM, your application's components can coordinate with other applications and their components, sharing information, processes, and resources across the entire infrastructure of your application. If you are designing a new distributed application that must scale well, DCOM is the solution.</p>
<p>
While it requires some effort to reach a thorough understanding of DCOM, the application design benefit is that you can create efficient, scalable objects for use in your enterprise application. Even better, the data access or business service components you create for your application are easily reusable in other applications.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information on DCOM architecture, search online for "DCOM Architecture" in <i>MSDN Library Visual Studio 6.0</i>.</p>
<h2>Multithreading Your Application</h2>
<p>
The basic unit of execution in Windows NT is the thread. Each process contains one or more threads. When a component has one thread of execution, code for only one object can execute at any given time. The Automation feature of the Component Object Model (COM) handles this situation by serializing requests. That is, the requests are queued and processed one at a time until all have been completed.</p>
<p>
It's typically much faster to use multiple threads for simultaneous processes. Of course, the processes are never really simultaneous with a single CPU because the CPU is handling only one thread at a time. But as resources become available (or extra CPUs or memory is added), the additional threads are serviced more quickly and throughput is typically enhanced.</p>
<p>
In a multithreading operating environment such as Windows NT, serialization protects single-threaded objects from overlapping client requests — that is, from code in a property or method being executed while one or more previous client requests are still being executed. </p>
<p>
To use threads effectively, it's important to understand the implications of the various thread properties and how your application should use them.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information using multiple threads, search online for "Multithreading for Rookies" in <i>MSDN Library Visual Studio 6.0</i>.</p>
<h2>Coding a Faster Application</h2>
<p>
Unless your application is doing tasks like generating fractals, it's unlikely to be limited by the actual processing speed of your code. Typically, other factors — such as object services, network delays, or disk activities — are the limiting factor in your application. However, you may find points in your application where the speed of your code is the controlling factor, especially for routines that are called frequently. </p>
<p>
There are several techniques you can use to increase the real speed of your application, including those described in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=39%><b>Coding technique</b></td>
<td class=label width=61%><b>Comments</b></td>
</tr>
<tr valign=top>
<td width=39%>Choose data types carefully.</td>
<td width=61%>For example, use Long integer variables for integer arithmetic.</td>
</tr>
<tr valign=top>
<td width=39%>Use constants whenever possible.</td>
<td width=61%>Constants are resolved with compilation, whereas variables must be looked up each time.</td>
</tr>
<tr valign=top>
<td width=39%>Cache frequently used properties in variables.</td>
<td width=61%>Your application can get and set the value of variables faster than those of properties.</td>
</tr>
<tr valign=top>
<td width=39%>Load modules only as needed.</td>
<td width=61%>Otherwise, the application startup time will be excessive.</td>
</tr>
<tr valign=top>
<td width=39%>Reduce the number of controls on the visual interface.</td>
<td width=61%>More controls cause slower loading.</td>
</tr>
<tr valign=top>
<td width=39%>Reduce the number of active dialog boxes.</td>
<td width=61%>Each dialog box, whether visible or not, consumes a significant amount of memory.</td>
</tr>
<tr valign=top>
<td width=39%>Use early binding of COM objects.</td>
<td width=61%>With late binding you do not get compile-time type checking, and each reference at run time requires extra processor work.</td>
</tr>
<tr valign=top>
<td width=39%>Minimize cross-process calls.</td>
<td width=61%>Cross-process calls take a long time.</td>
</tr>
<tr valign=top>
<td width=39%>Minimize explicit and implicit type conversions.</td>
<td width=61%>Explicit and implicit type conversions require extra time.</td>
</tr>
<tr valign=top>
<td width=39%>Where possible, use variables instead of arrays.</td>
<td width=61%>Accessing an array is always slower than accessing a simple variable.</td>
</tr>
<tr valign=top>
<td width=39%>Use arrays instead of COM collections when passing large amounts of data.</td>
<td width=61%>COM collections require additional time to marshal the data.</td>
</tr>
<tr valign=top>
<td width=39%>Use Integer or Long data types for controlling loops.</td>
<td width=61%>Depending on the language, some choices, such as Variant or Double, are extremely slow.</td>
</tr>
<tr valign=top>
<td width=39%>Remove all dead code before compiling.</td>
<td width=61%>All those unused routines create unnecessary bloat.</td>
</tr>
<tr valign=top>
<td width=39%>Pass arguments to in-process components by reference.</td>
<td width=61%>The server can read the arguments directly.</td>
</tr>
<tr valign=top>
<td width=39%>Pass arguments to out-of-process components by value.</td>
<td width=61%>This avoids marshaling.</td>
</tr>
<tr valign=top>
<td width=39%>Where possible, use multi-use objects instead of single-use objects.</td>
<td width=61%>This uses less memory when loading multiple instances.</td>
</tr>
<tr valign=top>
<td width=39%>Use callback mechanisms rather than events.</td>
<td width=61%>Callback mechanisms are faster than events.</td>
</tr>
<tr valign=top>
<td width=39%>Avoid string concatenation.</td>
<td width=61%>String concatenation is a slow process.</td>
</tr>
</table><br>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information on service queuing with Microsoft Message Queue Server (MSMQ), see <a href="veconperformancevalueofservicequeuingwithmsmq.htm">Performance Value of Service Queuing with MSMQ</a> in this chapter. For more information on object pooling using Microsoft Transaction Server (MTS), see <a href="veconperformancevalueofobjectpoolingwithmts.htm">Performance Value of Object Pooling with MTS</a> in this chapter.</p>
<h2>Tuning Web Applications</h2>
<p>
If your application uses Microsoft<sup>®</sup> Internet Information Server (IIS) and Active Server Pages (ASP), there are two significant factors in improving IIS capacity, response time, and reducing "Server too Busy" messages. These are:</p>
<ul type=disc>
<li>
Configuring the IIS queue.</li>
<li>
Tuning the IIS threads.</li>
</ul>
<p>
Configuring the IIS queue is important because busy Web sites are defined by a high-transaction volume. Ideally, each transaction has a very short life cycle. Under a high load, significant slowdowns (blocking) can occur when a component gets called at a greater rate than the number of transactions per second the component can satisfy. When blocking occurs, incoming requests are placed in a queue for later first in/first out processing. If the blocking only occurs for several seconds, the queue smoothes out and the request is handled in a timely fashion. However, when the blocking lasts for a longer period of time (such as 30 seconds or more), an effect called "queue saturation" may occur. Queue saturation happens when the number of queued services exceeds the maximum number allowed (RequestQueueMax) and IIS returns a "Server too Busy" message.</p>
<p>
It's not possible to automatically calculate what the optimum number of IIS queued services should be. Rather, it requires careful analysis of typical and peak loading conditions and a determination of what your target response time should be. For example, say your user response time must be 10 seconds or less. It does absolutely no good to queue more requests than can be processed in that amount of time. The whole point is to configure the queue size to handle short-term peaks and limit the queue's backlog during extreme workloads.</p>
<p>
Tuning the IIS threads has to do with effective computer use. Allowing more threads generally encourages more CPU use. Fewer threads suggest low processor use. For example, if you have a busy site, the queue length never goes up, and the actual processor use is low, you probably have more computer capacity than required. On the other hand, if the queue length goes up and down and the CPU use is still low, the threads should be increased because you have unused processor capacity.</p>
<p>
Ideally, you should be getting processor use above 70 percent during peak loads. While 70 percent processor use is merely a guideline, anything less suggests other limiting constraints on your application.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Determining the ideal queue size and number of IIS threads requires a monitoring tool (such as the Windows NT Performance Monitor) to analyze processor and thread behavior. For an introduction to using Performance Monitor, see <a href="veconusingperformancemonitor.htm">Using Performance Monitor</a> in this chapter.</p>
<p>
There are many additional performance ideas that can improve your Web application's response time. Be sure to explore the performance tuning tips available from the Web sites referred to in the following note.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information on how to correctly size your application's IIS queue and thread usage, see http://www.microsoft.com/isn/techcenter/tuningIIS.htm. For additional tips on improving the performance of an ASP-based application, see http://www.microsoft.com/workshop/server/toc.asp.</p>
</BODY>
</HTML>
