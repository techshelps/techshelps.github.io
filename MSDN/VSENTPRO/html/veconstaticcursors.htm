<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Static Cursors</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconstaticcursors"></a>Static Cursors</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconStaticCursors_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconStaticCursors_T">
</object></p>
<p>
The static cursor always displays the result set as it was when the cursor was first opened. Depending on implementation, static cursors are either read-only or read/write and provide forward and backward scrolling. The static cursor does not usually detect changes made to the membership, order, or values of the result set after the cursor is opened. Static cursors may detect their own updates, deletes, and inserts, although they are not required to do so.</p>
<p>
Static cursors never detect other updates, deletes, and inserts. For example, suppose a static cursor fetches a row and another application and then updates that row. If the application refetches the row from the static cursor, the values it sees are unchanged, despite the changes made by the other application.</p>
<p>
Static cursors are commonly implemented by locking the table rows that are in the result set or making a copy (snapshot) of the result set. While locking table rows is easy to do, it has the drawback of significantly reducing concurrency. Making a copy allows greater concurrency and allows the cursor to keep track of its own updates, deletes, and inserts by modifying the copy. However, a copy requires extra resources and can diverge from the underlying data as that data is changed by others.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information on concurrency problems and how they are handled with row locking options, see <a href="veconmanagingconcurrencywithcursorlocks.htm">Managing Concurrency with Cursor Locks</a>.</p>
<h3>Considering the Static Cursor</h3>
<p>
If your application does not need to detect data changes, the static cursor is the best choice.</p>
</BODY>
</HTML>
