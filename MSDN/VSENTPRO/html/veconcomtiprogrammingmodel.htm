<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMTI Programming Model</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconcomtiprogrammingmodel"></a>COMTI Programming Model</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconCOMTIProgrammingModel_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconCOMTIProgrammingModel_T">
</object></p>
<p>
The COMTI programming model follows the COM programming model and the mainframe Transaction Program (TP) programming model by providing a bridge between the two. One result of this bridge is that COMTI does not have APIs that you have to program. Although COMTI uses existing mainframe programming models, some changes may be needed to an existing mainframe TP to fit the models supported by COMTI. For example, a TP does not necessarily expect a simple request-reply response sequence. With one exception, COMTI imposes that model on the mainframe program. As another example, a CICS program may have terminal processing logic embedded in the same program with the business logic. This type of program must be restructured as separate programs.</p>
<p>
On the distributed platform, the programming model is object-oriented. Application objects are instantiated and methods on those objects are invoked. Using COMTI, mainframe applications appear as COM Automation objects with callable methods. The model is a synchronous exchange of inputs and outputs, as shown in the following illustration.</p>
<p>
<img src="ve520n1.gif" border=0></p>
<p>
On the mainframe platform, COMTI supports a variety of programming models, flows, and relationships as summarized in the following illustration.</p>
<p>
<img src="ve520n2.gif" border=0></p>
<p>
On the mainframe platform, COMTI supports the following flows:</p>
<ul type=disc>
<li>
Non-Transactional Single Send and Receive</li>
<li>
Non-Transactional Multiple Send and Receive</li>
<li>
Transactional Single Send and Receive</li>
<li>
Transactional Multiple Send and Receive</li>
</ul>
<h2>Non-Transactional Single Send and Receive</h2>
<p>
<img src="ve520n3.gif" border=0></p>
<p>
For each method invocation, COMTI converts and sends the input parameters to the TP. The mainframe TP executes, processes the input data (for instance, accessing or updating the database), and sends its response back to COMTI. COMTI receives the output parameters from the TP, converts them, and finally returns them to the invoking program.</p>
<h2>Non-Transactional Multiple Send and Receive</h2>
<p>
The simple model is extended to include one or more consecutive sends followed by one or more consecutive receives.</p>
<p>
<img src="ve520n4.gif" border=0></p>
<p>
In this case, the last input parameter of the method invocation can be a "variably sized" recordset. The input parameters are converted and sent, and then each row of the recordset is converted and sent to the mainframe TP. The mainframe TP executes, receives the input data and each row of the recordset, processes the data (perhaps doing database accesses and/or updates), and sends its response back to COMTI. COMTI receives any output parameters from the TP and converts them to return to the invoker. Then, each row of a variably sized recordset is received, if appropriate. The mainframe TP has no notion of a recordset; it is just receiving or sending tabular data. COMTI handles converting to and from the recordset.</p>
<h2>Transactional Single Send and Receive</h2>
<p>
<img src="ve520n5.gif" border=0></p>
<p>
When a COMTI component participates in an MTS transaction (for example, a DTC-coordinated two-phase commit exchange), COMTI uses LU 6.2 Sync Level 2.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;COMTI will also support the use of Sync Level 2 with IMS when COMTI supports IMS 6.0.</p>
<p>
DTC works with the COMTI run-time proxy and with the COMTI Resync Service to provide the necessary two-phase commit flows, as well as transaction log synchronization and recovery. Note that COMTI clients can remain completely uninvolved in transaction commit/rollback decisions, or they may elect to participate. COMTI clients are never aware of, nor involved in, transaction recovery.</p>
<p>
If a client chooses to remain uninvolved in transaction control, the COMTI run-time proxy will automatically commit transactions that have no run-time failures and will abort those that do fail. The COMTI run-time proxy, however, cannot detect or react to application-specific conditions that may require a transaction to abort. These special conditions must be handled by the application in an MTS component by simply executing the SetAbort method against the transaction's Context Object. For example, an out-of-cash situation in an automated teller machine requires a transaction rollback to reset the original account balance and a notification message to schedule machine maintenance.</p>
<h2>Transactional Multiple Send and Receive</h2>
<p>
<img src="ve520n6.gif" border=0></p>
<p>
The difference between this flow and the transactional single send-and-receive case is that multiple sends and/or multiple receives may occur between COMTI and the mainframe. This flow also supports variably-sized data where the number and size of the actual records returned or sent can vary at run time.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;With Transactional Multiple Send and Receive, the CICS LINK programming model cannot be used because it supports only fixed-size data areas.</p>
</BODY>
</HTML>
