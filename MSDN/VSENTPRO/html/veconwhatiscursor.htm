<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>What Is a Cursor?</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconwhatiscursor"></a>What Is a Cursor?</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconWhatIsCursor_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconWhatIsCursor_T">
</object></p>
<p>
Most programming languages, and the applications they build, tend to process data in terms of a logical sequence of records. For example, an application might read through the records in a customer file and print certain items of information from each record until it reaches the end of the file. When your application uses queries to do data access, the "data" is a query result set based on the SQL query statements. With query result sets, there is no "next row" concept, nor is there any way to operate on the individual result set rows.</p>
<p>
This situation is a bit awkward because most developers understand sequential record-based retrieval and have no corresponding experience with query result sets. While your query-based application knows generally what to expect in the result set, it may need to evaluate certain columns in selected rows to reach a conclusion. Such applications need a mechanism to map one row (or a small block of rows) from the result set into program variables.</p>
<p>
Cursors solve this problem by exposing the entire result set so that your application can use rows in the result set in a manner similar to using records in a sequential file. The following illustration shows how a cursor makes rows available to your application.</p>
<p>
<img src="ve51tv1.gif" border=0></p>
<p>
Using cursors, you can:</p>
<ul type=disc>
<li>
Specify positioning at specific rows in the result set.</li>
<li>
Retrieve one row or a block of rows based on the current result set position.</li>
<li>
Modify data in the rows at the current position in the result set.</li>
<li>
Define different levels of sensitivity to data changes made by other users.</li>
</ul>
<p>
For example, consider an application that displays a list of available products to a potential buyer. The buyer scrolls through the list, drilling down to get product details and cost, and finally selects a product for purchase. Additional scrolling and selection occurs for the remainder of the list. Notice that as far as the buyer is concerned the products are appearing one at a time, but the application is using a scrollable cursor to browse up and down through the result set.</p>
<p>
You can use cursors in a variety of ways:</p>
<ul type=disc>
<li>
With no rows at all.</li>
<li>
With some or all of the rows in a single table.</li>
<li>
With some or all of the rows from logically joined tables.</li>
<li>
As read-only or updatable at the cursor or field level.</li>
<li>
As forward-only or fully scrollable.</li>
<li>
With the keyset cursor keyset located on the server.</li>
<li>
Sensitive to underlying table changes caused by other applications (such as membership, sort, inserts, updates, and deletes).</li>
<li>
Existing on either the server or the client.</li>
</ul>
<p>
Read-only cursors help browse through the result set, and read/write cursors can implement individual row updates. Complex cursors can be defined with keysets that point back to base table rows. While some cursors are read-only in a forward direction, others can move back and forth and provide a dynamic refresh of the result set based on changes other applications are making to the database. Although each cursor library uses a slightly different syntax and a somewhat different approach to implementing cursors, they are all similar in most respects.</p>
</BODY>
</HTML>
