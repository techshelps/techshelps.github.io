<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Securing Microsoft Transaction Server</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconsecuringmicrosofttransactionserver"></a>Securing Microsoft Transaction Server</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconSecuringMicrosoftTransactionServer_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconSecuringMicrosoftTransactionServer_T">
</object></p>
<p>
Microsoft Transaction Server (MTS) simplifies managing component and interface security by using <i>roles</i>. A role is a symbolic name that defines a logical group of users for a package of components. Roles determine which users are allowed to invoke interfaces in a component. A role is similar to the idea of user groups in Windows NT.</p>
<p>
MTS security also uses the concept of <i>packages</i>. Packages are groups of in-process components (DLLs) that compose your application's business services. You can configure security for the package and not the individual components. This makes the administration of component access much easier. All components in a package run with the same security.</p>
<p>
As you plan the components in your enterprise application, you need to understand that there are two ways to protect component interface access: client impersonation and client authorization. For the reasons described here, client authorization is the preferred method.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;The Microsoft Management Console (MMC) provides a framework for configuring and managing Microsoft Transaction Server. You can administer Microsoft Transaction Server with the Transaction Server Explorer found in the Microsoft Management Console.</p>
<h2>Client Impersonation</h2>
<p>
Consider the situation where you've created a server providing file access. Without impersonation, any user accessing your application through your server has the identical access rights as your server, probably administrator access rights. This can be a security problem: the access rights should be no greater than those rights already assigned to the user.</p>
<p>
Windows NT lets a process take on the security attributes of another process through impersonation. With impersonation, the server uses the client's access rights to complete a task involving objects, which the server does not normally have access.</p>
<p>
Client impersonation means that access is provided explicitly to each client for only permitted interfaces. This means that when developing your application’s components, you need to code each interface to be aware of and check each client’s access privileges.</p>
<p>
This presents an administrative challenge for your enterprise application because, as clients are added, you must continually modify the component's interfaces to recognize the new client permissions.</p>
<p>
With object pooling, another consequence of client impersonation is the extra time required to complete the interface method. For example, changing the user ID of a database access component causes additional connect and disconnect time because the previous connection belonged to another client.</p>
<p>
Client impersonation is not a good choice for setting up and maintaining component interface security.</p>
<h2>Client Authorization</h2>
<p>
Client authorization means that the component runs with its own user ID — not one temporarily borrowed from the client. During development of your application's components, you define permissions to each interface using roles. When a component checks for access permission, all it has to do is determine if the client is a member of the permitted role. You can assign users and groups of users to roles.</p>
<p>
A major performance benefit of client authorization is that the connection to a database is done only once. There is no need to connect and disconnect for every different client.</p>
<p>
If your enterprise application uses Microsoft Transaction Server, you should use client authorization and roles to configure the component access security.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information on the security features of Microsoft Transaction Server, search for "Enabling Package Security" in <i>MSDN Library Visual Studio 6.0</i>.</p>
</BODY>
</HTML>
