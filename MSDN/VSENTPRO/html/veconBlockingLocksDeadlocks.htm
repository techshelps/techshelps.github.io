<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Blocking Locks and Deadlocks</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconblockinglocksdeadlocks"></a>Blocking Locks and Deadlocks</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconBlockingLocksDeadlocks_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconBlockingLocksDeadlocks_T">
</object></p>
<p>
Applications use database locks to control data integrity in multiuser concurrency situations. Poor database design coupled with uncoordinated business processes can cause crippling database lock contention and destroy your application's performance. </p>
<p>
Most databases have a number of locking capabilities. For example, Microsoft<sup>®</sup> SQL Server™ provides row, page, and table locking. While normal processing in a multiuser environment can conveniently use locks, your application will run faster without locks. Considerable design effort should be applied to table design, indexing strategy, and query optimization to avoid locking situations.</p>
<p>
The following topics discuss blocking locks, deadlocks, and present some design strategies for avoiding them.</p>
<h2>Blocking Locks</h2>
<p>
A blocking lock occurs when one lock causes another process to wait in a holding queue until the current process is entirely done with the resources. As soon as the first process is complete, the blocked process resumes operation. In a normal server environment, infrequent blocking locks are acceptable. But if blocking locks are common (rather than infrequent), there is probably some kind of design or query implementation problem.</p>
<p>
Some of the common design problems that cause blocking locks are very wide tables, insufficient indexes, and tables that are not completely normalized. If your application is using SQL Server, you can monitor the total number of blocking locks by using the User Activity Monitor in Microsoft SQL Server's SQL Enterprise Manager.</p>
<h2>Deadlocks</h2>
<p>
Consider the situation where one partially finished transaction must wait for another transaction to complete. At the same time, the other partially finished transaction must also wait for the original transaction to complete. This is called a deadlock: when each transaction is waiting for resources used by the other. When such a deadlock occurs, the database typically cancels one of the transactions.</p>
<p>
Long simultaneous transactions which variously lock and unlock resources must be carefully designed to avoid deadlocks.</p>
<h2>Lock-Avoiding Design Strategies</h2>
<p>
There are a few design strategies that can reduce the occurrence of blocking locks and deadlocks:</p>
<ul type=disc>
<li>
Use clustered indexes on high-usage tables.</li>
<li>
Avoid high row count SQL statements that can cause a table lock. For example, instead of inserting all rows from one table to another all at once, put a single INSERT statement in a loop and insert one row at a time.</li>
<li>
Break long transactions up into many shorter transactions. With SQL Server, you can use "bound connections" to control the execution sequence of the shorter transactions.</li>
<li>
Make sure that UPDATE and DELETE statements use an existing index.</li>
<li>
If you use nested transactions, be sure there are no commit or rollback conflicts.</li>
</ul>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information on how to use locks, see <a href="veconmanagingconcurrencywithcursorlocks.htm">Managing Concurrency With Cursor Locks</a> in Chapter 7 of this book. For more information on the types of locks available with SQL Server, see <a href="veconsqlservercursorlibrary.htm">SQL Server Cursor Library</a> in Chapter 7 of this book. For more information on using bound connections with SQL Server, search online for "Bound Connections" in <i>MSDN Library Visual Studio 6.0</i>.</p>
</BODY>
</HTML>
