<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Client-Side Cursors versus Server-Side Cursors</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconclientsidecursorsversusserversidecursors"></a>Client-Side Cursors versus Server-Side Cursors</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconClientSideCursorsVersusServerSideCursors_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconClientSideCursorsVersusServerSideCursors_T">
</object></p>
<p>
Every cursor uses temporary resources to hold its data. These resources can be memory, a disk paging file, temporary disk files, or even temporary storage in the database. The cursor is called a <i>client-side</i> cursor when these resources are located on the client machine. The cursor is called a <i>server-side</i> cursor when these resources are located on the server machine.</p>
<h3>Client-Side Cursors</h3>
<p>
With a non-keyset client-side cursor, the server sends the entire result set across the network to the client machine. The client machine provides and manages the temporary resources needed by the cursor and result set. The client-side application can browse through the entire result set to determine which rows it requires.</p>
<p>
Static and keyset-driven client-side cursors may place a significant load on your workstation if they include too many rows. While all of the cursor libraries are capable of building cursors with thousands of rows, applications designed to fetch such large rowsets may perform poorly. There are exceptions, of course. For some applications, a large client-side cursor may be perfectly appropriate and performance may not be an issue.</p>
<p>
One obvious benefit of the client-side cursor is quick response. After the result set has been downloaded to the client machine, browsing through the rows is very fast. Your application is generally more scalable with client-side cursors because the cursor's resource requirements are placed on each separate client and not on the server.</p>
<h3>Server-Side Cursors</h3>
<p>
With a server-side cursor, the server manages the result set using resources provided by the server machine. The server-side cursor returns only the requested data over the network. This type of cursor can sometimes provide better performance than the client-side cursor, especially in situations where excessive network traffic is a problem.</p>
<p>
Server-side cursors also permit more than one operation on the connection. That is, once you create the cursor, you can use the same connection to make changes to the rows — without having to establish an additional connection to handle the underlying update queries.</p>
<p>
However, it's important to point out that a server-side cursor is — at least temporarily — consuming precious server resources for every active client. You must plan accordingly to ensure that your server hardware is capable of managing all of the server-side cursors requested by active clients. Also, a server-side cursor can be slow because it provides only single row access — there is no batch cursor available.</p>
<p>
Server-side cursors are useful when inserting, updating, or deleting records. With server-side cursors, you can have multiple active statements on the same connection. With SQL Server, you can have pending results in multiple statement handles.</p>
<p>
Advantages to using server-side cursors include those in the following list.</p>
<ul type=disc>
<li>
<b>Memory usage</b>&nbsp;&nbsp;&nbsp;The client does not need to cache large amounts of data or maintain information about the cursor position because the server is doing that.</li>
<li>
<b>Performance</b>&nbsp;&nbsp;&nbsp;If you are going to access only some of the data in the result set, or access the data just a few times, a server-side cursor minimizes network traffic.</li>
<li>
<b>Additional cursor types</b>&nbsp;&nbsp;&nbsp;With server-side cursors, both keyset and dynamic cursors are available.</li>
<li>
<b>Positioned updates</b>&nbsp;&nbsp;&nbsp;Server-side cursors support direct positioned updates, whereas ODBC simulates positioned cursor updates by generating an SQL search and update statement. Direct positioned updates are not only faster, they avoid the risk of unintended update collisions.</li>
</ul>
<p>
Notice that server-side cursors do not support the execution of queries that return more than one result set. However, it is possible to use the server-side cursor library with this type of query if you request a forward-only, read-only cursor with a rowset size of 1. Basically, this set of options disables the scrolling overhead associated with the cursor and enables the cursor driver to manage each result set individually.</p>
</BODY>
</HTML>
