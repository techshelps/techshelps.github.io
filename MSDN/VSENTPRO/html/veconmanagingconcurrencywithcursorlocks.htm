<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Managing Concurrency With Cursor Locks</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY>

<h1><a name="veconmanagingconcurrencywithcursorlocks"></a>Managing Concurrency With Cursor Locks</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconManagingConcurrencyWithCursorLocks_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:Tasks">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="veconManagingConcurrencyWithCursorLocks_T">
</object></p>
<p>
The goal of using cursor locks is to ensure separate applications don't interfere with one another. Multiuser database applications encounter concurrency problems whenever several users try to access or update the same information at the same time. Concurrency has to do with separate processes, running at the same time, trying to use the same item. With pessimistic cursor locks, you can temporarily prohibit either read access or changes by other applications. With optimistic cursor locks, you expect no concurrent changes and do not prohibit access or changes by other applications.</p>
<p>
The following list describes several common situations where you must manage concurrency.</p>
<ul type=disc>
<li>
<b>Temporary update</b>&nbsp;&nbsp;&nbsp;This occurs when one transaction reads the uncommitted updates of another. If the first transaction does a rollback, the second transaction has misleading data. The solution is to prevent access to uncommitted updates.</li>
<li>
<b>Lost update</b>&nbsp;&nbsp;&nbsp;This occurs when two transactions read the same data item with the intention of update. In this situation, the first update might be lost because the second update, arriving moments later, is based on the original value. Using a lock with the intent to update prevents this problem.</li>
<li>
<b>Incorrect summary</b>&nbsp;&nbsp;&nbsp;This occurs when a single transaction updates two items. The database is in an inconsistent state until both updates have completed. If a summarization query reads the two items while the update is in progress, the summary can be erroneous. A read-lock on the result set eliminates the problem.</li>
</ul>
<p>
Your application can handle concurrency issues by using locks. Locking can prevent one process from reading data that is being changed by another process, and it can prevent a process from changing data that is about to be changed by another concurrent process.</p>
<p>
Locking provides the benefit of ensuring correct data, but it also makes the other concurrent applications wait to apply their changes. The application design trade-off is to carefully lock what you must, but keep the update process small enough to be quick, thereby minimizing the wait time for the other applications.</p>
<p>
You can control row and page locking by setting the appropriate cursor lock option. While the available lock options may vary with your choice of a cursor library, several lock types are generally available. These are described in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b>Lock Type</b></td>
<td class=label width=72%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=28%>Read only</td>
<td width=72%>This type of lock lets concurrent applications read the data, but no application can change the data. This lock is useful in conditions where your application must temporarily prevent data changes, but still can allow unrestricted reading.</td>
</tr>
<tr valign=top>
<td width=28%>Optimistic using values</td>
<td width=72%>Useful in conditions where there is only a small chance that a second user may update a row in the interval between when a cursor is opened and the row is finally updated. The current values in the row are compared with the values retrieved when the row was last fetched. If any of the values have changed, an error is returned. Performance is good because locks are not held on the rows that make up the result set.</td>
</tr>
<tr valign=top>
<td width=28%>Optimistic using rows</td>
<td width=72%>This is for tables where the rows have a modification timestamp column. The cursor engine compares each row's current timestamp value with the timestamp value that was stored when the row was last fetched to determine whether the row was updated. Because only the timestamp needs comparison, this is faster than checking all of the values.</td>
</tr>
<tr valign=top>
<td width=28%>Shared</td>
<td width=72%>This type of lock allows many processes to read the same information, but changes are not permitted. An example of shared locks is when many processes have the same table open for reading. If your application must temporarily prevent other users from changing the data, but still let them read the data without waiting, shared locking is a good choice.</td>
</tr>
<tr valign=top>
<td width=28%>Exclusive</td>
<td width=72%>This option locks the data for modification as it is read into the cursor result set. If you must temporarily prevent other processes from changing the data, you should use exclusive locking on either the row, the table, or the page. Locking works best within the protection of a transaction with its commit and rollback options. The lock is held until the transaction is terminated. Positioned updates using a cursor can be blocked by other connections holding a lock on a row. Exclusive locking provides the greatest data protection and the slowest throughput.</td>
</tr>
</table><br>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For more information on the different types of locks that SQL Server uses, search online for "Understanding Locking" in the <i>SQL Server Books Online</i>, and "Data Integrity and Concurrency in Microsoft SQL Server" in <i>MSDN Library Visual Studio 6.0</i>.</p>
</BODY>
</HTML>
