<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Library and object files</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="libraryobjectfiles"></a>Library and object files</h1>
<p>
From Table 8-3, you’ll notice that VBAEXE5.LIB is linked with our own OBJ file (created from our files and modules). The library contains just one component (library files contain object files), NATSUPP.OBJ. (NATSUPP might stand for “native support.”) You can find this object by using <i>DUMPBIN /ARCHIVEMEMBERS VBAEXE5.LIB</i>. (DUMPBIN.EXE is the Microsoft Common Object File Format [COFF] Binary Dumper. For a more detailed description of the COFF file format, see the MSDN library or <i>Windows 95 System Programming Secrets</i>, by Matt Pietrek (IDG Books, 1995).) NATSUPP.OBJ can be extracted for further examination using the Microsoft Library Manager, LIB.EXE:</p>
<pre><code>lib /extract:e:\vbadev\r5w32nd\presplit\vbarun\obj\natsupp.obj 
vbaexe5.lib</code></pre>
<p>
The reason for including the path to the OBJ file is that the library manager expects us to specify exactly the name of the module—including its path. (This path is embedded in the library file when the object file is first put into it and is discovered using <i>DUMPBIN /ARCHIVEMEMBERS</i>.) In other words, the object file probably “lived” at this location on someone’s machine in Redmond! Similarly, we can use <i>DUMPBIN /ALL vbaexe5.lib </i>to tell that the source code for this object file was named NATSUPP.ASM and was in the directory e:\vbadev\rt\win32. It was assembled using Microsoft’s Macro Assembler, Version 6.11d, and it seems as though it was created on “Fri Dec 06 11:17:38 1996.” Interestingly, it doesn’t contain any code—just data—although what looks like a jump table (a mechanism often used to facilitate calls to external routines) appears to be included. To call a routine, you look up its address in the table and then jump to it, as shown in Table 8-4 on page 333.</p>
<p class=blue>
<b>Table 8-3  Command-Line Switches for the Linker</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=242><b>Switch</b></td>
<td class=blue width=350><b>Explanation</b></td>
</tr>
<tr valign=top>
<td width=242>C:\TEMP\Form1.OBJ</td>
<td width=350>Form OBJ file</td>
</tr>
<tr valign=top>
<td width=242>C:\TEMP\Module1.OBJ</td>
<td width=350>Module OBJ file</td>
</tr>
<tr valign=top>
<td width=242>C:\TEMP\Class1.OBJ</td>
<td width=350>Class OBJ file</td>
</tr>
<tr valign=top>
<td width=242>C:\TEMP\Project1.OBJ</td>
<td width=350>Project OBJ file</td>
</tr>
<tr valign=top>
<td width=242>C:\PROGRAM FILES\ DEVSTUDIO\VB\VBAEXE5.LIB</td>
<td width=350>Library of Visual Basic OBJs </td>
</tr>
<tr valign=top>
<td width=242>/ENTRY:__vbaS</td>
<td width=350>Sets the starting address for an executable file or DLL. The entry point should be a function that is defined with the <i>stdcall </i>calling convention. The parameters and the return value must be defined as documented in the Win32 API for <i>WinMain</i> (for an EXE) or <i>DllEntryPoint</i> (for a DLL). This entry point is in the &lt;project name&gt;.obj file—here it will be in project1.obj. Note that neither Sub Main nor Form_Load is mentioned.</td>
</tr>
<tr valign=top>
<td width=242>/OUT:C:\TEMP\Project1.exe</td>
<td width=350>The output file—the EXE!</td>
</tr>
<tr valign=top>
<td width=242>/BASE:0x400000</td>
<td width=350>Sets a base address for the program, overriding the default location for an executable file (at 0x400000) or a DLL (at 0x10000000). The operating system first attempts to load a program at its specified or default base address. If sufficient space is not available there, the system relocates the program. To prevent relocation, use the /FIXED option. The default is 0x400000. The BASE generated for a Visual Basic 5 OLE DLL is 0x11000000—something that’s different from the default at last.</td>
</tr>
<tr valign=top>
<td width=242>/SUBSYSTEM:WINDOWS,4.0</td>
<td width=350>Tells the operating system how to run the EXE file. (Options include CONSOLE | WINDOWS | NATIVE | POSIX.)</td>
</tr>
<tr valign=top>
<td width=242>/VERSION:1.0</td>
<td width=350>Tells the linker to put a version number in the header of the executable file or DLL. (This option has nothing to do with a VERSIONINFO resource.) The major and minor arguments are decimal numbers in the range 0 through 65535. The default is version 0.0. Visual Basic uses the Major and Minor settings in the Options dialog box, available from the File menu’s Make EXE option, for these values. This switch is used to document the image version as shown by DUMPBIN.EXE (another Microsoft Visual C++ tool).</td>
</tr>
<tr valign=top>
<td width=242>/DEBUG</td>
<td width=350>Creates debugging information for the executable file or DLL. The linker puts the debugging information into a program database (PDB). It updates the PDB during subsequent builds of the program.</td>
</tr>
<tr valign=top>
<td width=242>/DEBUGTYPE:CV; /DEBUGTYPE:{CV|COFF|BOTH}</td>
<td width=350>Generates debugging information in one of three ways: Microsoft format, COFF format, or both. CV is CodeView; COFF is Common Object File Format.</td>
</tr>
<tr valign=top>
<td width=242>/INCREMENTAL:NO</td>
<td width=350>Specifies whether incremental linking is required.</td>
</tr>
<tr valign=top>
<td width=242>/OPT:REF</td>
<td width=350>Excludes unreferenced packaged functions from the executable file. Packaged functions are created using the -Gy flag at compile time. (See Table 8-1 on page 325.) Packaged functions have several uses (not mentioned here) and are created automatically, sometimes by the compiler. For example, C++ member functions are automatically packaged.</td>
</tr>
<tr valign=top>
<td width=242>/MERGE:.rdata=.text; /MERGE:from=to</td>
<td width=350>Combines the first section (from) with the second section (to), naming the resulting section “to”. If the second section does not exist, LINK renames the section “from” as “to”. The /MERGE option is most useful for creating VxDs and for overriding the compiler-generated section names.</td>
</tr>
</table><br>
<p class=blue>
<b>Table 8-4  Contents of natsupp.obj</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=158><b>Name</b></td>
<td class=blue width=138><b>Size</b></td>
<td class=blue width=296><b>Content</b></td>
</tr>
<tr valign=top>
<td width=158>.text</td>
<td width=138>0</td>
<td width=296>Readable code</td>
</tr>
<tr valign=top>
<td width=158>.data</td>
<td width=138>4</td>
<td width=296>Initialized readable writable data</td>
</tr>
<tr valign=top>
<td width=158>.debug$S</td>
<td width=138>140</td>
<td width=296>Initialized discardable readable data</td>
</tr>
<tr valign=top>
<td width=158>.debug$T</td>
<td width=138>4</td>
<td width=296>Initialized discardable readable data</td>
</tr>
</table><br>
<p>
The sections are as follows:
<ul type=disc>
<li>
<b>.text</b> is where all the general-purpose code created by the compiler is output. (It’s 0 bytes big, which probably means no code!)<br><br></li>
<li>
<b>.data</b> is where initialized data is stored.<br><br></li>
<li>
<b>.debug$S</b> and <b>.debug$T</b> contain, respectively, CodeView Version 4 (CV4) symbolic information (a stream of CV4 symbol records) and CV4 type information (a stream of CV4 type records), as described in the CV4 specification.</li>
</ul>
<p>
As well as statically linking with this library file, other object files reference exported functions in yet another library file, MSVBVM50.DLL. This is a rather large DLL installed by the Visual Basic 5 Setup program in the WINDOWS\SYSTEM directory. (The file describes itself as Visual Basic Virtual Machine and at the time of writing was at version 5.00.3724.) Using <i>DUMPBIN /EXPORTS MSVBVM50.DLL </i>yields some interesting symbolic information. For example, we can see that it exports a number of routines, 600 in fact. Some interesting-looking things, possibly routines for invoking methods and procedures, are in here as well: MethCallEngine and ProcCallEngine. Additionally, there are what look like stubs, prefixed with rtc (“run-time call,” perhaps?), one for apparently all of the VBA routines: <i>rtcIsArray</i>, <i>rtcIsDate</i>, <i>rtcIsEmpty</i>, … <i>rtcMakeDir</i>, … <i>rtcMsgBox</i>, … <i>rtcQBColor</i>, and so on. And like most DLLs, some cryptic yet interesting exports, such as <i>Zombie_Release</i>, are included.</p>
<p>
In addition to this symbolic information, the DLL contains a whole bunch of resources, which we can extract and examine using tools such as Microsoft’s Visual C++ 5. Of all the resources the DLL contains, the one that really begs examination is the type library resource. If we disassemble this using OLEVIEW.EXE, we can see its entire type library in source form. (Do not confuse OLEVIEW.EXE with OLE2VW32.EXE, which is another Microsoft tool located on the Visual Basic 5 CD in \TOOLS\OLETOOLS.)</p>
<p>
The type library contains all sorts of stuff as well as the definitions of methods and properties, such as <i>vbNullChar</i>. In the following code, \0 is C-speak for the integral value 0 and \r\n means carriage return and line feed:</p>
<pre><code>. . .
[entry(0x00000001), helpcontext(0x0010aa32)] const LPSTR vbNullString = “";
[entry(0x00000002), helpcontext(0x0010aa32)] const LPSTR vbNullChar = “\0";
[entry(0x00000003), helpcontext(0x0010aa32)] const LPSTR vbCrLf = “\r\n";
[entry(0x00000004), helpcontext(0x0010aa32)] const LPSTR vbNewLine = “\r\n";
. . .</code></pre>
<p class=indent>
<span class=blue><b>Note</b></span>  From type libraries such as this, we can gather information about help context IDs. Such information will come in handy should you ever want to provide help on someone else’s objects. By using these context IDs and, of course, the right help file, you can link F1 to another help file (other than your own).</p>
<p>
It turns out that MSVBVM50.DLL is probably the run-time support DLL for any Visual Basic 5 native and p-code executable; that is, it acts like MFC42.DLL does for a non–statically linked MFC application. (MFC stands for Microsoft Foundation Classes, Microsoft’s C++/Windows class libraries.) We can confirm this by dumping a built native code executable. Sure enough, we find that the executable imports routines from the DLL. (By the way, the setup wizard also lists this component as the Visual Basic Runtime.) I wasn’t surprised to find out that a VBRUN500.DLL doesn’t ship with Visual Basic 5!</p>
<p>
By dumping other separate object files, we can gather information about what is defined and where it is exported. For example, we can use <i>DUMPBIN /SYMBOLS MODULE1.OBJ</i> to discover that a function named <i>Beep </i>will be compiled using Microsoft’s C++ name decoration (name mangling) regime and thus end up being named ?Beep@Module1@@AAGXXZ. Presumably, this function is compiled as a kind of C++ anyway; that is, in C++ it is defined as (private: void __stdcall Module1::Beep(void)). Or better yet, we can use <i>DUMPBIN /DISASM MODULE.OBJ </i>to disassemble a module.</p>
<p>
The same routine—<i>Beep</i>—defined in a Class, Class1 for example, looks like this:</p>
<pre><code>?Beep@Class1@@AAGXXZ (private: void __stdcall Class1::Beep(void))</code></pre>
<p>
Maybe now we can see why, since Visual Basic 4, we’ve had to name modules even though they aren’t multiply instantiable. Each seems to become a kind of C++ class. According to the name decorations used, <i>Beep</i> is a member of the C++ Classes Class1 and Module1.</p>
<h1></h1>
</BODY>
</HTML>
