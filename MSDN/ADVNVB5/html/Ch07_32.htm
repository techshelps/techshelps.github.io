<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Bug Hunt</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="thebughunt"></a>The Bug Hunt</h1>
<p>
Two very reliable methods of finding new bugs in your application are available. The first involves demonstrating the program, preferably to your boss. Almost without exception, something strange and/or unexpected will happen, often resulting in severe embarrassment. Although this phenomenon has no scientific explanation, it’s been shown to happen far too often to be merely a chance occurrence.</p>
<p>
The other guaranteed way of locating bugs is to release your application into production. Out there in a hostile world, surrounded by other unruly applications and subject to the vagaries of exotic hardware devices and unusual Registry settings, it’s perhaps of little surprise that the production environment can find even the most subtle of weaknesses in your program. Then there are your users, many of whom will gleefully inform you that “your program crashed” without even attempting to explain the circumstances leading up to the crash. Trying to extract the details from them is at best infuriating, at worst impossible. So we need some simple method of trapping all possible errors and logging them in such a way as to be able to reconstruct the user’s problem. (For details on error handling, refer to Chapter 1.) Here we’ll examine the minimum requirements needed to trap and report errors and help your user retain some control over what happens to his or her data after a program crash.</p>
<p>
The first point to note about Visual Basic 5’s error handling capabilities is that they are somewhat deficient when compared with those of most compiled languages. There is no structured exception handling, and the only way to guarantee a chance of recovery from an error is to place an error trap and an error handler into <i>every</i> procedure. To understand why, we need to look in detail at what happens when a run-time error occurs in your program.</p>
<p>
Your program is riding happily down the information highway, and suddenly it hits a large pothole in the shape of a run-time error. Perhaps your user forgot to put a disk into drive A, or maybe the Windows Registry became corrupted. In other words, something fairly common happened. Visual Basic 5 first checks whether you have an error trap enabled in the offending procedure. If it finds one, it will branch to the enabled error handler. If not, it will search backward through the current procedure call stack looking for the first error trap it can locate. If none are found, your program will terminate abruptly with a rude error message, which is normally the last thing you want to happen. Losing a user’s data in this manner is a fairly heinous crime and is not likely to endear you to either your users or the technical support people. So at the very least you need to place an error handler in the initial procedure of your program.</p>
<p>
Unfortunately, this solution is not very satisfactory either, for two reasons. Another programmer could come along later and modify your code, inserting his or her own local error trap somewhere lower in the call stack. This means that the run-time error could be intercepted, and your “global” error trap might never get the chance to deal with it properly. Instead, your program has to be happy with some fly-by-night error handler dealing with what could be a very serious error. The other problem is that even if, through good luck, your global error trap receives the error, Visual Basic 5 provides no mechanism for retrying or bypassing an erroneous statement in a different procedure. So if the error was something as simple as being unable to locate a floppy disk, you’re going to look a little silly when your program can’t recover. The only way of giving your user a chance of getting around a problem is to handle it in the same procedure in which it occurred.</p>
<p>
There is no getting away from the fact that you need to place an error trap and error handler in every single procedure if you want to be able to respond to and recover from errors in a sensible way. The task then is to provide a minimalist method of protecting every procedure while dealing with all errors in a centralized routine that is clever enough to be able to discriminate between the different types of errors, interrogate the user about which action to take, and return control back to the procedure where the problem occurred. The other minimum requirement is to be able to raise errors correctly to your clients when you are writing ActiveX components.</p>
<p>
Adding the following code to every procedure in your program is a good start:</p>
<pre><code>Private Function AnyFunction() As Integer

On Error GoTo LocalError
' Normal procedure code goes here.

Exit Function
LocalError:
If Fatal("Module.AnyFunction") = vbRetry Then
    Resume
Else
    Resume Next
End If

End Function</code></pre>
<p>
This code can provide your program with comprehensive error handling, provided the <i>Fatal</i> function is written correctly. <i>Fatal</i> will receive the names of the module and procedure where the error occurred, log these and other error details to a disk log file for later analysis, and then inform the program’s operator about the error and ask whether it ought to retry the statement in error, ignore it, or abort the whole program. If the user chooses to abort, the <i>Fatal</i> function needs to perform a general cleanup followed by <i>Reset</i> and <i>End</i> statements. If the user makes any other choice, the <i>Fatal</i> function returns control back to the procedure in error, communicating what the user has chosen. The code needed for the <i>Fatal</i> function can be a little tricky. You need to think about the different types of error that can occur, including those raised by ActiveX components. You also need to think about what happens if an error ever occurs within the <i>Fatal</i> function itself. (Again, see Chapter 1 for a more detailed analysis of this type of error handling.) Here I’ll examine a couple of pitfalls that can occur when handling or raising Visual Basic 5 errors that involve the use of vbObjectError.</p>
<p>
When creating or using ActiveX components, you often need to either propagate errors specific to the component back to the client application or handle an error raised by the component. The accepted method for propagating errors is to use <i>Error.Raise</i>. To avoid clashes with Visual Basic 5’s own range of errors, you add your error number to the vbObjectError constant. Be careful, however, about raising any errors within the range vbObjectError through vbObjectError + 512. Visual Basic 5 remaps some error messages between vbObjectError and vbObjectError + 512 to standard Automation run-time errors. This can result in unexpected behavior, so user-defined errors should always be greater than vbObjectError + 512. This little beauty has caught many programmers, and it always causes confusion when encountered.</p>
<p>
When using a universal error handler to deal with many different types of problems, always bear in mind that you might be receiving errors that have been raised using the constant vbObjectError. You can use the <i>And</i> operator (<i>Err.Number</i> <i>And</i> <i>vbObjectError</i>) to check this. If <i>True</i> is returned, you should subtract vbObjectError from the actual error number before displaying or logging the error. Because vbObjectError is mainly used internally for interclass communications, there is seldom any reason to display it in its natural state.</p>
<h1></h1>
</BODY>
</HTML>
