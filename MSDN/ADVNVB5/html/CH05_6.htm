<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Rule 1: Do Not Use Global Variables</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="rule1donotuseglobalvariables"></a>Rule 1: Do Not Use Global Variables</h1>
<p>
Global variables have long been frowned upon. They are the ultimate in short-term programming. Easy to define and use initially, they always create more problems than they solve in the long term.</p>
<p>
The most obvious bad thing about them is that they increase the likelihood of bugs. Whether you are reading the variable or setting its value, you have to make assumptions. It may have been modified in some distant part of the program, leading you astray. Then again, if you modify it, the change might break some code elsewhere.</p>
<p>
Global variables make code hard to change. When you revisit some code, whether yours or someone else’s, the existence of globals makes it far harder to have full confidence in the effect of your modifications. Suppose you were making a small modification to a routine that contained some global variable. Because global variables can by definition be used throughout the program, it is necessary to sweep through the whole program, examining each instance of that variable’s use to see if it is affected by your change. This review is time-consuming and error-prone.</p>
<p>
So what’s new? Global variables have long been understood to hinder code reliability and readability, but Visual Basic has tended to encourage the use of global variables. For example, consider how you would typically solve these everyday problems.</p>
<p class=blue>
<b>The Shackles of Backward Compatibility</b></p>
<p class=indent>
Other chapters of this book concentrate on migration issues in detail, and of course some bits of code always need modification in moving from one version of Visual Basic to the next. But as a general principle, Microsoft has attempted to keep the language backward compatible. I guess it would be seen as a marketing weakness if reviews were to be printed with comments such as, “The next version of Visual Basic will break <i>all </i>of your code.”</p>
<p class=indent>
Fair enough, but this backward compatibility comes at a high price. The language will become more and more bloated with irrelevant and contradictory features until some stuff is pulled out and other stuff is put in. Some examples of what I mean follow.</p>
<p class=blue>
<b>The Use of + for String Concatenation</b></p>
<p class=indent>
This misconceived experiment with operator overloading was considered bad form even back in the days of Visual Basic 2, when the string concatenation operator &amp; was first introduced. Yet in Visual Basic 5 it is still supported. In particular, since version 4 brought in extensive implicit type conversion between numerics and strings, this issue has become even more important. It is easy to find examples of how you can be tripped up. Can you be confident of what the following will print?</p>
<p class=indent>
<code>Debug.Print "56" + 48<br>
Debug.Print "56" + "48"<br>
Debug.Print "56" — "48"</code></p>
<p class=indent>
What <i>should</i> happen is that adding to strings should have the same effect as subtracting from, multiplying, or dividing strings—that is, it should generate a type mismatch error. Unfortunately, this is not the case. The only argument for why it stays in there, causing bugs, is backward compatibility.</p>
<p class=blue>
<b><i>ReDim </i>Bypassing the <i>Option Explicit</i> Directive</b></p>
<p class=indent>
See if you can spot the bug in the following code:</p>
<pre><code>Option Explicit
' Declare an array of players.
Dim FootballTeam() As Players 
’ Do stuff...
' Redimension to have 12 elements.
ReDim FootbalTeam(12)</code></pre>
<p class=indent>
<i>ReDim</i> does not require an array name to have been already explicitly declared, even if <i>Option Explicit</i> is set. If you have an existing array and you attempt to resize it with <i>ReDim</i> but you make a typing mistake and misspell the name of the array, you get a new array with the misspelled name. It is this type of common bug that <i>Option</i> <i>Explicit</i> was designed to trap and flag at compile time.</p>
<p class=blue>
<b>DefType</b></p>
<p class=indent>
In my job reviewing program code, I’ve seen at least 50 different individuals’ Visual Basic code—not one of them has ever used a <i>DefInt</i>, a <i>DefLng</i>, or one of the other types. Does anyone use this stuff? Is it just me, or does it seem a bizarre concept that a variable’s type is defined by the first letter in the name?</p>
<p class=blue>
<b>Type Declaration Characters</b></p>
<p class=indent>
Why should we have to remember that <i>%</i> is an integer or <i>#</i> a double? There are no type declaration characters for newer data types such as Boolean or date. Those who designed Visual Basic must have run out of punctuation or decided it was a bad idea. Type declaration characters are hangovers from pre–Visual Basic forms of Basic, but now we are just left with an inconsistent mess.</p>
<p class=blue>
<b>Zero-Based or One-Based Collections</b></p>
<p class=indent>
If you are iterating through the Forms or the Controls collection, you step from 0 through Count –1; but if you are stepping through a standard Collection, you step from 1 through Count.</p>
<pre><code>Dim i, colThings As New Collection
colThings.Add "Fred"

For i = 0 To Forms.Count - 1
    ' Iterate through Forms collection.
    Debug.Print Forms(i).Name
Next i
For i = 1 To colThings.Count
    ' Iterate through colThings collection.
    Debug.Print colThings(i)
Next i</code></pre>
<p class=blue>
<b>Redundant Keywords</b></p>
<p class=indent>
Redundant keywords such as <i>Let</i> and <i>While…Wend</i> don’t do any harm, but they clutter your code.</p>
<p class=indent>
That’s enough griping. Visual Basic’s designers are obviously aware of all of these flaws and inconsistencies. Why don’t they fix them? Backward compatibility.</p>
<h1></h1>
</BODY>
</HTML>
