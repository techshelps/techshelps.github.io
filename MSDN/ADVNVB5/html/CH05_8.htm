<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Example 2: Keep the INI File Read Operation in One Place</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="example2keepinifilereadoperationinoneplace"></a>Example 2: Keep the INI File Read Operation in One Place</h1>
<p>
This example demonstrates some themes similar to those in Example 1. In the past, you might have done one of the following:
<ul type=disc>
<li>
Read your INI file at the beginning of your program and stored the values in global variables.<br><br></li>
<li>
Read your INI file “on demand.” Wherever a value from an INI file is required, the file is opened and the value read there and then.</li>
</ul>
<p>
The second option has some advantages, especially if you’re also writing back to the INI file from within your program, because you’ll always get the latest value. Moreover, the performance degradation is negligible. Visual Basic has always handled text file input/output blindingly fast, so for any normal-size INI files, you won’t notice the overhead that the file access imposes each time.</p>
<p>
The downside is that there is no centralization. Not only does this cause administrative problems—that is, quickly finding out what is in your INI file—but it also is another example of the disguised global variable.</p>
<p>
You can centralize INI file handling best by utilizing a class, as shown in the example on the following page.</p>
<h2>Class Name: IniFile</h2>
<pre><code>Option Explicit
' Contains all properties in the INI file.
' We use the Get/Let properties to read/write
' the INI file entries.

Private Function IniFileName()
' If there is no command line, the INI file
' will be myapp.ini in the same dir as the EXE.
    If Command$ = "" Then
        If Right(App.Path, 1) = "\" Then 
            IniFileName = App.Path &amp; "myapp.ini"      
        Else
            IniFileName = App.Path &amp; "\myapp.ini"
        End If
    Else
        IniFileName = Command$
    End If
End Function

Public Property Get StyleFile()
' Read value from INI file.
    StyleFile = GetSetting(IniFileName(), "GENERAL", "StyleFile")
End Property

Public Property Let Color(newLongColor)
' Write new value to INI file, and store as RGB string;
' e.g., convert 16711680 to 0, 0, 255 (blue).
    Dim RGBColor
    RGBColor = LongToRGB(newLongColor)
    SaveSetting IniFileName(), "OPTIONS", "Color", RGBColor
End Property

Public Property Get Color()
' Read value from INI file, and convert from RGB string to long;
' e.g., convert 0, 0, 255 to 16711680 (blue).
    Dim RGBColor
    RGBColor = GetSetting(IniFileName(), "OPTIONS", "Color")
    If RGBColor = "" Then
        Color = RGB(255, 255, 255)
    Else
        Color = RGBToLong(RGBColor)
    End If
End Property</code></pre>
<p>
This code segment demonstrates various advantages of using a class-based approach:
<ul type=disc>
<li>
The private function <i>IniFileName </i>encapsulates the logic for where the INI file is located.<br><br></li>
<li>
We can have read-only INI file entries, such as <i>StyleFile</i>.<br><br></li>
<li>
We can include conversions as the data is read or written. In this instance—with the <i>Color</i> property—RGB colors, which are used as longs within the program, are stored as more user-friendly strings of the form 0,0,255 in the INI file.<br><br></li>
<li>
Defaults can be added where the INI file entry is missing. In this case, the default color is RGB(255, 255, 255).<br><br></li>
<li>
In addition to this, all INI file reading and writing is centralized, and there are no global variables.</li>
</ul>
<p>
When using this class, the code will look like this:</p>
<pre><code>Dim ini As New iniFile
ini.Color = RGB(0, 255, 0)</code></pre>
<p>
You can access the INI file properties only where you have an <i>iniFile </i>object in scope—in this case, the <i>ini</i> object reference variable is local to this function.</p>
<p>
As with the previous modal form example, you have to get used to creating new instances of the objects that you want to use, which is a rather new way of programming for Visual Basic users. It would be possible, of course, to create a global <i>ini</i> file object and reference it throughout your program; but though that would save a little bit of typing, it would take us back to the original problem.</p>
<p>
Coding standards for Visual Basic have tended to be wishy-washy when it comes to globals. They are discouraged rather than prohibited. In the world of standards, this is ineffectual—you have to either say you can use something or say you can’t. There is no middle ground. Improvements in the Visual Basic language now mean that there are no longer any reasons to use globals. Whenever you find yourself writing a bit of code that “requires” a global variable, stop! Think about it, and find an alternative way of writing it.</p>
<h1></h1>
</BODY>
</HTML>
