<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Removing Declare Statements</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="removingdeclarestatements"></a>Removing <i>Declare </i>Statements</h1>
<p>
You might have noticed that throughout this book we generally prefix Windows API calls with <i>Win</i> to show that the routine being called is in Windows, that it’s an API call. You’ve also seen how to make these calls using <i>Alias</i> within the declaration of the routine. (<i>Alias </i>allows you to rename routines.) Here <i>BringWindowToTop</i> is being renamed <i>WinBringWindowToTop</i>:</p>
<pre><code>Declare Function WinBringWindowToTop Lib “user32” Alias _
"BringWindowToTop” (ByVal hwnd As Long) As Long</code></pre>
<p>
However, we could use a type library to do the same thing. Here’s an entire type library used to do just that:</p>
<p class=blue>
<b>APILIB.ODL</b></p>
<pre><code>// The machine name for a type library is a GUID.
[uuid(9ca45f20-6710-11d0-9d65-00a024154cf1)]

library APILibrary 
{
    [dllname(“user32.dll”)]

    module APILibrary 
    {
        [entry(“BringWindowToTop”)] long stdcall 
            WinBringWindowToTop([in] long hWnd);
    };
};</code></pre>
<p class=blue>
<b>MAKEFILE</b></p>
<pre><code>apilib.tlb : apilib.odl makefile
    mktyplib /win32 apilib.odl</code></pre>
<p>
The MAKEFILE is used to create the TLB file given the ODL file source code. To run MAKEFILE, invoke NMAKE.EXE. If you don’t have NMAKE.EXE, simply run MkTypLib from a command prompt like this:</p>
<pre><code>mktyplib /win32 apilib.odl</code></pre>
<p>
The type library contains a description of an interface in APILibrary named WinBringWindowToTop. Once you have compiled the library, run Visual Basic and go to References on the Project menu. Click the Browse button to find the APILIB.TLB file, and then select it, as shown in Figure 8-4.</p>
<p>
<img src="f08rf04.gif" border=0></p>
<p class=blue>
<b>Figure 8-4  Visual Basic's References dialog box</b></p>
<p>
Click OK and press F2 to bring up Visual Basic’s Object Browser, which is shown in Figure 8-5.</p>
<p>
<img src="f08rf05.gif" border=0></p>
<p class=blue>
<b>Figure 8-5  APILibrary displayed in Visual Basic’s Object Browser </b></p>
<p>
In Figure 8-5, notice that the method <i>WinBringWindowToTop </i>seems to be defined in a module and a server, both named APILibrary. Notice also that we have access to the syntax of the method. (The ToolTip Help in Visual Basic will also display correctly for this method.) To use the method (which is really a function in USER32.DLL), all we have to do is enter code. No DLL declaration is now required (and so none can be entered incorrectly).</p>
<pre><code>Call WinBringWindowToTop(frmMainForm.hWnd)</code></pre>
<p>
Another useful addition to a type library is named constants. Here’s a modified APILIB.ODL:</p>
<pre><code>[uuid(9ca45f20-6710-11d0-9d65-00a024154cf1)]

library APILibrary 
{

[dllname(“user32.dll”)]

module WindowsFunctions
{
    [entry(“BringWindowToTop”)] long stdcall 
        WinBringWindowToTop([in] long hWnd);
    [entry(“ShowWindow”      )] long stdcall 
        WinShowWindow      ([in] long hwnd, [in] 
    long nCmdShow);
};

typedef
[
        uuid(010cbe00-6719-11d0-9d65-00a024154cf1),
        helpstring
        (“WinShowWindow constants - See SDK ShowWindow for more.”)
] enum
{
    [helpstring(“Hides the window; activates another”       )] 
               SW<u>_</u>HIDE            = 0,
    [helpstring(“Maximizes the window”                      )] 
               SW<u>_</u>MAXIMIZE        = 3,
    [helpstring(“Minimizes the window; activates next window”)] 
               SW<u>_</u>MINIMIZE        = 6,
    [helpstring(“Activates the window”                      )] 
               SW_RESTORE         = 9,
    [helpstring(“Activates/displays (current size and pos)” )] 
               SW_SHOW            = 5,
    [helpstring(“Sets window state based on the SW_ flag”   )] 
               SW_SHOWDEFAULT     = 10,
    [helpstring(“Activates window - displays maximized”     )] 
               SW_SHOWMAXIMIZED   = 3,
    [helpstring(“Activates window - displays minimized”     )] 
               SW_SHOWMINIMIZED   = 2,
    [helpstring(“Displays  window minimized”                )] 
               SW_SHOWMINNOACTIVE = 7,
    [helpstring(“Displays  window to current state.”        )] 
               SW_SHOWNA          = 8,
    [helpstring(“Displays  window (current size and pos)”   )] 
               SW_SHOWNOACTIVATE  = 4,
    [helpstring(“Activates and displays window”             )] 
               SW_SHOWNORMAL      = 1,
} WinShowWindowConstants;

};</code></pre>
<p>
The library (APILibrary) now contains two sections, WindowsFunctions and WinShowWindowConstants, as shown in Figure 8-6.</p>
<p>
<img src="f08rf06.gif" border=0></p>
<p class=blue>
<b>Figure 8-6  APILibrary with named constants displayed in Visual Basic’s Object Browser </b></p>
<p>
The long numbers [uuid(9ca45f20-6710-11d0-9d65-00a024154cf1)] used in the ODL file are GUIDs (Globally Unique IDs). (See Chapter 1, page 32, for more detailed information on GUIDs.) The Visual Basic 5 CD contains, in the directory \TOOLS\IDGEN, the UUIDGEN.EXE and GUIDGEN.EXE utilities required for generating GUIDs. Just for your interest, here’s a small Visual Basic program that’ll generate IDs for you. No matter how many times you run this program (which outputs a GUID for each button click), it will never produce the same GUID twice!</p>
<p class=blue>
<b>Declaration Section</b></p>
<pre><code>Option Explicit

Private Type GUID
    D1       As Long
    D2       As Integer
    D3       As Integer
    D4(8)    As Byte
End Type

Private Declare Function WinCoCreateGuid Lib “OLE32.DLL” _
Alias “CoCreateGuid"(g As GUID) As Long</code></pre>
<p class=blue>
CreateGUID</p>
<pre><code>Public Function CreateGUID() As String

    Dim g          As GUID
    Dim sBuffer    As String
    Dim nLoop As Integer

    Call WinCoCreateGuid(g)

    sBuffer = PadRight0(sBuffer, Hex$(g.D1), 8, True)
    sBuffer = PadRight0(sBuffer, Hex$(g.D2), 4, True)
    sBuffer = PadRight0(sBuffer, Hex$(g.D3), 4, True)
    sBuffer = PadRight0(sBuffer, Hex$(g.D4(0)), 2)
    sBuffer = PadRight0(sBuffer, Hex$(g.D4(1)), 2, True)
    sBuffer = PadRight0(sBuffer, Hex$(g.D4(2)), 2)
    sBuffer = PadRight0(sBuffer, Hex$(g.D4(3)), 2)
    sBuffer = PadRight0(sBuffer, Hex$(g.D4(4)), 2)
    sBuffer = PadRight0(sBuffer, Hex$(g.D4(5)), 2)
    sBuffer = PadRight0(sBuffer, Hex$(g.D4(6)), 2)
    sBuffer = PadRight0(sBuffer, Hex$(g.D4(7)), 2)

    CreateGUID = sBuffer

End Function</code></pre>
<p class=blue>
PadRight0</p>
<pre><code>Public Function PadRight0( _
                          ByVal sBuffer As String _
                         , ByVal sBit As String _
                         , ByVal nLenRequired As Integer _
                         , Optional bHyp As Boolean _
                         ) As String

    PadRight0 = sBuffer &amp; _ 
                sBit &amp; _
                String$(Abs(nLenRequired - Len(sBit)), “0”) &amp; _ 
                IIf(bHyp = True, “-", ““)

End Function</code></pre>
<p class=blue>
Command1_Click Event Handler</p>
<pre><code>Private Sub Command1_Click()

    Print CreateGUID

End Sub</code></pre>
<p>
Notice that the optional Boolean argument in <i>PadRight0 </i>is set to False if it is missing in Visual Basic 5; that is, it is never actually missing. (See <i>IsMissing()</i> in the Visual Basic 5 online help.) In Visual Basic 5, an optional argument typed as anything other than Variant is never missing. An integer is set to 0, a string to "" a Boolean to False, and so on. Bear this in mind if you really need to know whether or not the argument was passed. If you do, you’ll need to use <i>Optional Thing As Variant </i>and <i>IsMissing()</i>. Even in Visual Basic 4 an object is never really missing; rather, it is set to be of type vbError (as in <i>VarType</i> will yield 10). I’ve no idea what the error’s value is.</p>
</BODY>
</HTML>
