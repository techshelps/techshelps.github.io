<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Grid control as a report tool</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="gridcontrolasreporttool"></a>Grid control as a report tool</h1>
<p>
In this example, data is populated into an unbound grid control. The data selection is based on the user-entered contents of text boxes in the form’s predefined Criteria section. Three business object data retrieval methods are included to illustrate the differences in syntax and performance of each method.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=140><b>Folder:</b></td>
<td width=452>CHAP03\ReportInGrid</td>
</tr>
<tr valign=top>
<td width=140><b>Dependencies:</b></td>
<td width=452>CompanyStock.exe <br>
Microsoft Rich TextBox Control 5.0 <br>
Microsoft Common Dialog Control 5.0 <br>
Microsoft Windows Common Controls 5.0 <br>
Microsoft FlexGrid Control 5.0</td>
</tr>
<tr valign=top>
<td width=140><b>Project Name:</b></td>
<td width=452>ReportInGrid.vbp</td>
</tr>
<tr valign=top>
<td width=140><b>Instructions:</b></td>
<td width=452>Ensure that CompanyStock.exe has been registered in the Registry. (Refer to page 105 on creating the EXE.) Load Visual Basic 5, and open the ReportInGrid.vbp file. Press Ctrl+F5 to run. The application will look similar to Figure 3-9 on the next page.</td>
</tr>
</table><br>
<p>
<img src="f03rf09.gif" border=0></p>
<p class=blue>
<b>Figure 3-9  Standard report using a grid </b></p>
<p>
The hardest part of this example is formatting the form, frmReportInGrid,<b> </b>with controls to hold the selection criteria, the method of data retrieval, and the report result (grid). Once you’ve set these controls up, simply add the lines of code documented in this section for a fully functional Company Details viewer.</p>
<p>
In the module modReportInGrid, the routine <i>Sub Main()</i><b> </b>is linked as the<b> </b>startup object in the ReportInGrid Project Properties dialog box. This routine contains a single line of code to display the form.</p>
<p>
In the form frmReportInGrid Declarations section, we add one line of code to create a new instance of the <i>CompanyDetails</i><b> </b>business object:</p>
<pre><code>Private csCompDet As New CompanyDetails</code></pre>
<p>
The <i>New</i><b> </b>statement ensures that the object is created automatically at run time.</p>
<p>
In the <i>Form_Load</i> event, code is entered to inform the business object of the default method of data retrieval. In the <i>Form_Unload</i> event, basic housekeeping is performed to ensure that no trailing reference to the business object is left.</p>
<pre><code>Private Sub Form_Load()
    ' Default to the data pass method.
    optCommMethod(csCompDet.DataPassFormat).Value = True
End Sub

Private Sub Form_Unload(Cancel As Integer)
    Set csCompDet = Nothing
End Sub</code></pre>
<p class=indent>
<span class=blue><b>Note</b></span>  Setting <i>csCompDet</i> to <i>Nothing</i> doesn’t necessarily mean that the object is destroyed. It ensures only that the current reference to the object is removed. Only when the last reference to the object is removed will the object destroy itself.</p>
<p>
Now place the following code in the option box event <i>optCommMethod_Click</i>:</p>
<pre><code>Private Sub optCommMethod_Click(Index As Integer)
    csCompDet.DataPassFormat = Index
End Sub</code></pre>
<p>
In the <i>cmdProcess_Click </i>event, I link the Index value of the option box controls to the methods of passing data: csPassByProperties, csPassByVariant, and csPassByFile.</p>
<p>
Apart from closing the form and initializing the grid with the correct number of rows and columns, we only have to add the code to retrieve the company details and to populate the return result into the grid:</p>
<pre><code>csCompDet.BuildCompanyList Limit:=txtNoOfItems, _
    CompanyID:=txtCriteria(0), _
    CompanyDescription:=txtCriteria(1), _
    CompanyInceptionDate:=txtCriteria(2), _
    CompanyCategory:=txtCriteria(3)</code></pre>
<p>
In the code above, the <i>BuildCompanyList</i><b> </b>method is invoked, which in turn builds up the appropriate SQL from the selection criteria parameters passed. This method also executes the SQL and creates the result in memory, with the business object ready for retrieval by the calling application.</p>
<p>
<b>Pass by parameter, data retrieval</b>  The first method of data retrieval (csPassByProperties) uses the public methods and properties of the <i>CompanyDetails </i>object (<i>csCompDet</i>):</p>
<pre><code>For nPos = 1 To csCompDet.Companies.Count
    griDisplay.AddItem csCompDet.Companies.Item(nPos).ID 
Next nPos</code></pre>
<p>
This format is easy to read and understand. Unfortunately, it is exceptionally slow compared with the other methods, making it impractical to use with high-volume data. The poor performance is a result of the overhead associated with cross-process-boundary communication; the Visual Basic application and the <i>CompanyDetails </i>object reside in different processes. Each time the calling application makes a reference to a property or method, the program must communicate (cross boundaries), which requires setting up stack space, pointer references, and communication handshaking. In the preceding code, this would occur for each pass through the loop.</p>
<p>
<b>Pass by variant, data retrieval</b>  This method (csPassByVariant) addresses the performance issues in the previous method, and it returns the data as a variant:</p>
<pre><code>vList = csCompDet.GetCompanyList
For nPos = 1 To csCompDet.Companies.Count
    griDisplay.AddItem vList(nPos)
Next nPos</code></pre>
<p>
This method cuts down cross-process-boundary communication significantly. With the <i>GetCompanyList </i>method, cross-process-boundary communication is required only once. It’s up to you, however, to place the data into the variant and to strip it out at the other end. I’ve intentionally stored the data in the variant as a single-dimension array with each value containing multiple values delimited by tabs. This type of storage allows us to pass the relevant array value to the grid, which in turn automatically splits the data according to the tabs.</p>
<p>
<b>Pass by file, data retrieval</b>  Oddly enough the fastest method (csPassByFile) of the lot, retrieving data from a disk drive, is quicker in some cases than retrieving the data from memory structures. Again, cross-process communication is a factor; here the physical data is transferred to and from the disk from separate processes rather than across a process boundary:</p>
<pre><code>nFile = FreeFile
Open csCompDet.GetCompanyList For Input As nFile
Do Until EOF(nFile)
    Input #nFile, sDetail
    griDisplay.AddItem sDetail
Loop
Close nFile</code></pre>
<p>
This method poses a security risk, however, by creating a public file on the network. It also requires you to trap all file error situations to ensure that the method is stable. For these reasons, I don’t recommend this method unless you need to retrieve high volumes of data and it’s not practical to hold the information in memory.</p>
<h1></h1>
</BODY>
</HTML>
