<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Adding to VarType</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="addingtovartype"></a>Adding to <i>VarType</i></h1>
<p>
Another “byte array” way to extend the type system is to add new Variant types. In Visual Basic 4, the following subtypes were available via the Variant:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=197><b>Visual Basic Name</b></td>
<td class=blue width=93><b><i>VarType</i></b></td>
<td class=blue width=302><b>Description</b></td>
</tr>
<tr valign=top>
<td width=197>vbEmpty</td>
<td width=93>0</td>
<td width=302>Uninitialized (default)</td>
</tr>
<tr valign=top>
<td width=197>vbNull</td>
<td width=93>1</td>
<td width=302>Contains no valid data</td>
</tr>
<tr valign=top>
<td width=197>vbInteger</td>
<td width=93>2</td>
<td width=302>Integer</td>
</tr>
<tr valign=top>
<td width=197>vbLong</td>
<td width=93>3</td>
<td width=302>Long integer</td>
</tr>
<tr valign=top>
<td width=197>vbSingle</td>
<td width=93>4</td>
<td width=302>Single-precision floating-point number</td>
</tr>
<tr valign=top>
<td width=197>vbDouble</td>
<td width=93>5</td>
<td width=302>Double-precision floating-point number</td>
</tr>
<tr valign=top>
<td width=197>vbCurrency</td>
<td width=93>6</td>
<td width=302>Currency</td>
</tr>
<tr valign=top>
<td width=197>vbDate</td>
<td width=93>7</td>
<td width=302>Date</td>
</tr>
<tr valign=top>
<td width=197>vbString</td>
<td width=93>8</td>
<td width=302>String</td>
</tr>
<tr valign=top>
<td width=197>vbObject</td>
<td width=93>9</td>
<td width=302>Automation object</td>
</tr>
<tr valign=top>
<td width=197>vbError</td>
<td width=93>10</td>
<td width=302>Error</td>
</tr>
<tr valign=top>
<td width=197>vbBoolean</td>
<td width=93>11</td>
<td width=302>Boolean</td>
</tr>
<tr valign=top>
<td width=197>vbVariant</td>
<td width=93>12</td>
<td width=302>Variant (used only for arrays of Variants)</td>
</tr>
<tr valign=top>
<td width=197>vbDataObject</td>
<td width=93>13</td>
<td width=302>Non-Automation object</td>
</tr>
<tr valign=top>
<td width=197>vbByte</td>
<td width=93>17</td>
<td width=302>Byte</td>
</tr>
<tr valign=top>
<td width=197>vbArray</td>
<td width=93>8192</td>
<td width=302>Array</td>
</tr>
</table><br>
<p>
In Visual Basic 5, we have one addition (and a great deal of scope for adding more—a lot of gaps!):</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td width=197>vbDecimal</td>
<td width=93>14</td>
<td width=302>Decimal value</td>
</tr>
</table><br>
<p>
With some limitations, we can add to this list. For example, we could, with only a small amount of effort, add a new Variant type of 42 to represent some new entity by compiling this C code to a DLL named NEWTYPE.DLL:</p>
<pre><code>#include “windows.h"
#include “ole2.h"
#include “oleauto.h"

#include &lt;time.h&gt;

typedef VARIANT * PVARIANT;

VARIANT  __stdcall CVNewType(PVARIANT v)
{
    // If the passed variant is not set yet...
    if(0 == v -&gt; vt)
    {
        // Create new type.
        v-&gt;vt = 42;

        // Set other variant members to be meaningful for this  
        // new type...
        // You do this here!
    }

    // Return the variant, initialized/used variants unaffected by 
    // this routine.
    return *v;
}


int  __stdcall EX_CInt(PVARIANT v)
{
    // Sanity check - convert only new variant types!
    if(42 != v-&gt;vt)
    {
        return 0;
    }
    else
    {
        // Integer conversion - get our data and convert it as 
        // necessary.
        // Return just a random value in this example.
        srand((unsigned)time(NULL));

        return rand();
    }
}</code></pre>
<p>
This code provides us with two routines: <i>CVNewType </i>creates, given an already created but empty Variant (it was easier), a Variant of <i>VarType</i> 42; <i>EX_CInt </i>converts a Variant of type 42 to an integer value (but doesn’t convert the Variant to a new Variant type). “Converts” here means “evaluates” or “yields.” Obviously, the implementation above is minimal. We’re not putting any real value into this new Variant type, and when we convert one all we’re doing is returning a random integer. Nevertheless, it is possible! Here’s some code to test the theory:</p>
<pre><code>Dim v As Variant

v = CVNewType(v)

Me.Print VarType(v)
Me.Print EX_CInt(v)</code></pre>
<p>
This code will output 42 and then some random number when executed against the DLL. The necessary DLL declarations are as follows:</p>
<pre><code>Private Declare Function CVNewType Lib “NEWTYPE.DLL” _
(ByRef v As Variant) As Variant
Private Declare Function EX_CInt   Lib “NEWTYPE.DLL” _
(ByRef v As Variant) As Integer</code></pre>
<p>
Again, we cannot override Visual Basic’s <i>CInt</i> (see page 347), and so I’ve had to name my routine something other than what I wanted to—in this case, <i>EX_CInt</i> for “external” CInt. I could, of course, have overloaded <i>Val</i>:</p>
<pre><code>Public Function Val(ByRef exp As Variant) As Variant

    Select Case VarType(exp)
        Case 42:   Val = EX_CInt(exp)
        Case Else: Val = VBA.Conversion.Val(exp)
    End Select

End Function</code></pre>
<p>
Here, if the passed Variant is of type 42, I know that the “real” <i>Val </i>won’t be able to convert it—it doesn’t know what it holds after all—so I convert it myself using <i>EX_CInt</i>. If, however, it contains an old Variant type, I simply pass it on to VBA to convert using the real <i>Val </i>routine.</p>
<p>
Visual Basic has also been built, starting with version 4, to expect the sudden arrival of Variant types about which nothing is known. This assertion must be true because Visual Basic 4 can be used to build ActiveX servers that have methods. In turn, these can be passed Variants as parameters. A Visual Basic 5 client (or server) can utilize these servers. A Visual Basic 5 client, then, might surprise a Visual Basic 4 server! In other words, because a Visual Basic 5 executable can pass in a Variant of type 14, Visual Basic must be built to expect unknown variant types, given that the Variant type is likely to grow at every release. You might want to consider testing for this in your Visual Basic 4 code.</p>
<p>
Having said all this and having explained how it could work, I’m not sure of the real value currently of adding a value to <i>VarType</i>. This is especially true when, through what we must call a feature of Visual Basic, not all the conversion routines are available for subclassing. In other words, why not use a user-defined type or, better still, a class to hold your new type instead of extending the Variant system?</p>
<p>
Another limitation to adding to <i>VarType </i>is due to the way we cannot override operators or define them for our new types. We have to be careful that, unlike an old Variant, our new Variant is not used in certain expressions. For example, consider what might happen if we executed <i>Me.Print 10 + v</i>. Because <i>v </i>is a Variant, it needs to be converted to a numeric type to be added to the integer constant 10. When this happens, Visual Basic must logically apply <i>VarType </i>to <i>v </i>to see what internal routine it should call to convert it to a numeric value. Obviously, it’s not going to like our new Variant type! To write expressions such as this, we’d need to do something like <i>Me.Print 10 + Val(v)</i>. This is also the reason why, in the <i>Val </i>substitute earlier, I had to pass <i>exp</i> ByRef. I couldn’t let Visual Basic evaluate it (which it would have to do using ByVal), even though it’s received as a Variant.</p>
<p>
Variants also might need to be destroyed correctly. When they go out of scope and are destroyed, you might have to tidy up any memory they might have previously allocated. If what they represent is, say, a more complex type, we might have to allocate memory to hold the representation.</p>
<p>
Microsoft does not encourage extending the Variant type scheme. For example, 42 might be free today, but who knows what it might represent in Visual Basic 6. We would need to bear this in mind whenever we created new Variant types and make sure that we could change their <i>VarType </i>values almost arbitrarily—added complexity that is, again, less than optimal!</p>
<p>
All in all, adding to <i>VarType </i>is not really a solution at the moment. If we get operator overloading and proper access to VBA’s conversion routines, however, all of this is a little more attractive.</p>
<p class=indent>
<span class=blue><b>Note</b></span>  The code to create Variants needs to be written in a language such as C. The main reason is that Visual Basic is too type safe and simply won’t allow us to treat a Variant like we’re doing in the DLL. In other words, accessing a Variant in Visual Basic accesses the type’s value and storage transparently through the VARIANT structure or user-defined type. To access its internals, it’s necessary to change the meaning of variant access from one of value to one of representation.</p>
<h1></h1>
</BODY>
</HTML>
