<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Test data and conditions</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="testdataconditions"></a>Test data and conditions</h1>
<p>
Testing for the Year 2000 won’t be like any testing you’ve done before. Here’s why: in order to be 100 percent certain that your business can survive into the year 2000, you’ll need to execute three completely separate system tests dealing with three sets of test data, and more than likely (depending on the size of your organization), each of these three tests will be in a different testing environment.</p>
<p>
<b>Regression test of today’s production environment</b>  Having made changes to your current system, your next task is to test that all programs function as expected for the current time frame. In other words, your business can continue to use its Visual Basic applications with no unexpected side effects.</p>
<p>
In effect, this test will ensure that the systems work exactly the same as they did when they were originally built. This test might sound counterproductive to begin with, but it’s no good announcing to the world that all your applications are Year 2000 compliant if they come crashing to their knees now!</p>
<p>
<b>Future date testing</b>  Having verified that your system functions correctly in the present, you’ll need to create a second set of test data that will test your system’s ability to cope with dates on either side of the year 2000. The particulars for this test will depend entirely on the business nature of your applications.</p>
<p>
For example, let’s suppose that your Visual Basic application maintains car insurance policies, which typically have a life cycle of 12 months. You’ll need to set your system clock to some time in 1999 and run your tests, this time looking specifically for the application’s ability to process car insurance policies that will expire in the year 2000.</p>
<p>
Your business might have a shorter future date requirement, such as a long-term car parking system that has a maximum life cycle of 6 months. In this case, you would need to ensure that the system date is set to at least August 1999 so that you can adequately test processing into the year 2000.</p>
<p>
And the list goes on. Make sure you thoroughly understand the future date capabilities and scope of your system. Then run your system so that it is forced to process future dates that are at least in the year 2000, if not later.</p>
<p>
<b>Running your system in the future</b>  The final test involves gauging the ability of your applications to function in and beyond the year 2000. Set your system date to some time beyond 2000, and run your original test scripts. Don’t forget that if your system processes historical information, you should have test conditions in which you’ve set your system clock beyond 2000 and you then force your applications to look at dates before 2000.</p>
<p>
<b>Leap years</b>  Include in all three of your system tests conditions that will force your application to process the last two days in February and the first two days in March. The year 2000 is a leap year, which means that February 29, 2000, is a valid date. Don’t be caught out by this one. I’ve seen much debate from mathematicians and rocket scientists on the correct way to calculate leap years, and I’ve naturally researched the subject myself thoroughly enough to conclude that 2000 is a leap year. In fact, I nearly had a fight with my neighbor the other day because he wouldn’t accept that February has 29 days in the year 2000!</p>
<p>
The point I’m trying to make here is that if superhumans and neighbors can disagree on the number of days in February 2000, so can programmers! It’s possible that during the development of your Visual Basic applications, a programmer might have manually calculated (incorrectly) that the year 2000 is <i>not </i>a leap year, so be sure to test for it.</p>
<p>
<b>Recommended system dates</b>  If you’re lucky (or wise), you’ll have already built automated testing procedures that don’t require too much manual intervention. Otherwise, somebody is going to get very sore fingers! In a perfect world, I would suggest running your complete system test against the following system date years:</p>
<p>
1997, 1998, 1999, 2000, 2001, 2002, 2007</p>
<h1></h1>
</BODY>
</HTML>
