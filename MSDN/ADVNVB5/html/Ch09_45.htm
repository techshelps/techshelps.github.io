<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CDate and CVDate</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><i><a name="cdatecvdate"></a>CDate </i>and <i>CVDate</i></h1>
<p>
These two functions each return a value that can be interpreted as a date. It is preferable to “convert” any dates that might be held as strings using these functions.</p>
<p>
<b>Compatibility</b>  As mentioned previously, the <i>CDate </i>function is available only in Visual Basic 4 and 5. For Visual Basic 3, you should use the <i>CVDate </i>function. <i>CVDate </i>is provided in Visual Basic 4 and 5 for backward compatibility, although you’ll probably want to steer clear of this because of the return type.</p>
<p>
<b>Return value</b>  Both the <i>CDate </i>and <i>CVDate </i>functions will return a value that can be interpreted as a date. The difference is that <i>CDate </i>will return an actual Date data type, whereas <i>CVDate </i>will return a Variant(7) data type that represents a date. Because the Date data type is available in Visual Basic 4 and 5, it should always take precedence over a Variant(7); hence the use of <i>CDate </i>in Visual Basic 4 and 5 over <i>CVDate</i>.</p>
<p>
A variable declared as a Date or Variant(7) data type that has been assigned the result of a <i>CDate </i>or <i>CVDate </i>function is unique in that it actually holds two values. To the outside world, the value is exposed as a normal date in the short date format of the system settings. Internally, however, the value is stored as a double-precision number of which the integer portion represents the number of days since December 31, 1899, and the fractional portion represents the time of the converted expression as a fraction of the 24-hour clock.</p>
<p>
<b>Arguments</b>  Any expression that constitutes a valid date according to the locale settings can be used as an argument to <i>CDate </i>or <i>CVDate</i>. (See “Regional settings” at the beginning of this section.) In addition to expressions that look like dates to the naked eye, <i>CVDate </i>and <i>CDate </i>will also accept date serial numbers such as 2 (January 1, 1900) and 36525 (December 31, 1999). Date expressions that include a time value can also be passed to <i>CVDate </i>or <i>CDate </i>as an expression.</p>
<p>
<b>Y2K issues</b>  In Visual Basic 3, if your date argument is not a serial number and includes only a two-digit year, <i>CVDate </i>will always assume the twentieth century. In Visual Basic 4, if your date argument is not a serial number and includes only a two-digit year, <i>CDate </i>will assume the current century (unless you have a new version of OLEAUT32.DLL—see “How OLEAUT32.DLL affects the date window” on page 414). For example, try the following piece of code in Visual Basic 3 or 4:</p>
<pre><code>Dim sMessage As String

sMessage = "Day One of the new century has a date serial of " 
MsgBox sMessage &amp; CDbl(CVDate("1/1/0"))</code></pre>
<p>
The date serial will be calculated as 2, which represents the second day since December 31, 1899—that is, January 1, 1900, and <i>not </i>January 1, 2000, as you might expect.</p>
<p>
If you change the system date on your PC to some time after the change of the next century, Visual Basic 4 will interpret “1/1/0” as January 1, 2000, but the result for Visual Basic 3 will not change. Although the Visual Basic 4 example appears to be an improvement, depending on the nature of your business, it could cause just as much havoc with your system if your system processes historical dates.</p>
<p>
If your Visual Basic application is written in Visual Basic 3, the implications of this issue should be obvious. When your application receives a short date–formatted date for the Year 2000 or beyond, the date will be interpreted as the 1900s instead of the 2000s. Three remedies to this problem are possible:
<ol>
<li>
<b>Convert your application to Visual Basic 5. </b>Although this solution would solve your problem, you need to consider the logistics of converting an entire system to a newer version of the language. In addition, consider the hard-coded, static 1930 window used by Visual Basic 5, which is covered in the “Date window” section.<br><br></li>
<li>
<b>Accept only four-digit century dates.</b> This would be the best all-round solution, although it might also involve considerable changes to the user interface. More important, it could invoke a negative reaction from the users of your system.<br><br></li>
<li>
<b>Use a windowing function on the short date.</b> This solution is possibly the easiest to implement both technically and politically. Read the “Writing your own date window” section for a more thorough discussion of the sliding-window technique.</li>
</ol>
<h1></h1>
</BODY>
</HTML>
