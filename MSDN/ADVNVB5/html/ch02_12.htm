<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Three "Simple" Tiers</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="threesimpletiers"></a>Three “Simple” Tiers</h1>
<p>
We’ll skip desktop and two-tiered (client to data usually) systems and begin with a distributed, componentized system in its simplest form: three tiers (or more frequently encountered in real life as three layers masquerading as tiers). Figure 2-2 shows an example of a simple three-tiered application.</p>
<p>
This model is essentially very simple. At the top level, we have a client for showing and manipulating information. Business-level logic is at the middle  level. This logic comprises the rules about how you calculate information and what state this information has to be in before you can carry out particular operations on it. These rules are separated into three different kinds of business logic, corresponding to “real” world (at least to the business) objects; customer, account, and order. Finally, we have an underlying RDBMS, which essentially holds the data that becomes the values of the properties in our three business objects. By building a system like this, we are in essence building a slim client—we hope. Nevertheless, the client has to coordinate all business object   DCOM to communicate with our business objects. (The decision about whether to use Remote Automation or DCOM will depend on the operating systems we are working to—there is no 16-bit DCOM, nor is it in NT 3.51; in my humble opinion, no other excuses are acceptable for using the slower, less stable Remote Automation now.) We build the business objects themselves, which do all their own direct database access, as well as apply their individual business rules. We’ve also got to create and implement the database design.</p>
<p>
<img src="f02rf02.gif" border=0></p>
<p class=blue>
<b>Figure 2-2  A simple tiered application </b></p>
<p>
So what’s wrong with creating an architecture like this? Well, several things. First, by leaving coordination in the client, you are increasing the amount of work it does and the amount of code that’s in it. Baby, your client is getting rich! That means you are really <i>layering</i> rather than <i>tiering</i>. Tiering is all about business objects working with each other cooperatively and horizontally within a tier, whereas layering is merely interacting vertically between layers. Bye-bye, vision. Second, you are building the same data access multiple times (in each individual business object) since you have only one RDBMS in your system. So long, reuse. Worst of all, you haven’t thought about the resource implications if these are all the software components you’re going to deploy (rather than all the functional components you’re going to build). Farewell, scalability!</p>
<p>
The distinction I’m trying to emphasize here is the difference between where business functionality lies and where infrastructure comes in. Actually, the data access layer here (basically the RDBMS and its underlying data) might not be strictly functional unless you’re using triggers or stored procedures or something, but we’ll let that pass.</p>
<p>
Have we done anything right? Well, we have moved a lot of the logic to one central place since the hardware environment we’re looking at now looks something like the setup in Figure 2-3.</p>
<p>
<img src="f02rf03.gif" border=0></p>
<p class=blue>
<b>Figure 2-3  Physical distribution of a typical tiered system </b></p>
<p>
This hardware setup might make that logic code (please let it be processor and memory intensive) run faster, since it’s on a bigger machine and is all in one place for those frequent occasions on which the rules of the business change. Beers all around, then? Hold on a minute! If we look more carefully at what we’ve done, we see that we’ve just lost a big cost justification here. We’ve moved from a situation in which all that business logic and data access that was using a lot of resources down on the client is now using comparable resources on the server. In fact, if you factor in having common infrastructural code, such as data access in all the servers, and logging, tracing, and error handling modules being in both the client and all the servers, we’ve probably got more code loaded now, using more resources. So we’ve moved the work to a different processor, made more work, and need more RAM, albeit in a different place. The cost is interesting too—this system is more complex and therefore more costly and slower to develop. And then there’s the cost of the object server machine. Admittedly, we’ve gotten around some of the problems of idle resources being on the clients and resources not being used except at processing peaks; but we’ve still missed a few tricks.</p>
<h1></h1>
</BODY>
</HTML>
