<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Typeless Visual Basic</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="typelessvisualbasic"></a>Typeless Visual Basic</h1>
<p>
In Visual Basic 5, the question, “Is this variable of the correct type?” has become, “Does this variable reference an instance of a class that supports this interface?” Although we are dealing with Variants, there are similarities between the way you program with Variants and the way you program with classes. You can think of a Variant as a little class that contains just one property—its value. As is the case with a class, your access to that property is not direct—there is a layer of encapsulation. As a user of a class, you are not concerned with the <i>implementation</i> of the class so much as its <i>behavior</i>. Likewise, you can ignore the underlying implementation of a Variant and concern yourself with its behavior. In classes, the definition of the behavior is its <i>interface</i>. With Variants, we might think of the subtypes as various interfaces. To see whether the Variant supports them, we can use the set of <i>Is…</i> functions to check to see that the interface is supported.</p>
<p>
For example, to see if a Variant is an array, we can use <i>IsArray().</i> Good defensive programming should test with <i>IsArray</i> before using functions such as <i>UBound</i> on a Variant. If you get into this habit, you will find your code is more robust.</p>
<h1></h1>
</BODY>
</HTML>
