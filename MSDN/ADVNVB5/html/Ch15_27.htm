<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reuse Issues for the Programmer</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="reuseissuesforprogrammer"></a>Reuse Issues for the Programmer</h1>
<p>
Good computer programming relies on a structured methodology that consists of a number of individual disciplines. For example, commenting your code as you write it is a discipline that you must practice until it becomes second nature. It is a well-known fact that many programmers either do not comment their code at all or comment it only after it’s been written. One of the reasons you should comment code as you write it is because at that time you know your exact thought processes and the reasons behind the decisions you’re making. If you were to comment the code two weeks after writing it, you might still understand how it works, but you will probably have forgotten subtle details about why you coded something a certain way or what effects a line of code might have on other parts of the application. If you ever see lots of totally meaningless comments, you can be sure they were inserted after the code was written!</p>
<p>
The discipline of coding for reusability is very important and comes only with practice. You will know when you’ve mastered this habit because you’ll start writing less code. You should view any piece of code you write as a potentially reusable component. The experience gained from adopting this practice will help you not only to identify reusable units but also to anticipate the situations in which those units might be used. It will also enable you to make better decisions about how loosely or tightly the code can be coupled—it’s not possible or efficient in all cases to decouple a code section completely from the other parts of the application. You should also remember that in a multiple-programmer project, other programmers will look to reuse code that other team members have written. Imagine you want a function and that function already exists: will you write it again or use the existing one? Obviously, you will reuse the existing function unless one or all of these conditions are true:
<ul type=disc>
<li>
You think the code is of poor quality.<br><br></li>
<li>
The code doesn’t meet your requirements.<br><br></li>
<li>
You don’t know the code exists.<br><br></li>
<li>
The code is poorly documented or commented.</li>
</ul>
<p>
Experience will also help you make the right choices about the way that a unit couples to other units. A good practice to adopt is to write all your code modularly, encapsulated as much as possible. A typical program consists of a series of calls to functions and subroutines. At the top level—for example, in a text box KeyPress event—a series of calls can be made. The functions that you call from within this event should, wherever possible, be coded as if they were contained in object components; that is, they should have no knowledge of the environment. It is the linking code, or the code in the KeyPress event, that needs to know about the environment. By coding functions and subroutines in a modular way, you can reuse them in a number of situations. You should also avoid embedding application-specific functionality in these top-level events because this prevents the code from being reused effectively. Look at the following sample code, which capitalizes the first letter of each word in the text box Text1:</p>
<pre><code>Sub Text1_KeyPress(KeyAscii As Integer)

    If Text1.SelStart = 0 Then
        ' This is the first character, so change to uppercase.
        KeyAscii = Asc(UCase$(Chr$(KeyAscii)))
    Else
        ' If the previous character is a space, capitalize
        ' the current character.
        If Mid$(Text1, Text1.SelStart, 1) = Space$(1) Then
            KeyAscii = Asc(UCase$(Chr$(KeyAscii)))
        End If
    End If
End Sub</code></pre>
<p>
The functionality in the KeyPress event is tied explicitly to Text1. To reuse this code, you would have to cut and paste it and then change every reference made to Text1 to the new control. The code would be truly reusable if written like this:</p>
<pre><code>Sub Text1_KeyPress(KeyAscii As Integer)
    KeyAscii = nConvertToCaps(Text1, KeyAscii)
End Sub

Function nConvertToCaps(ByVal ctl As Control, _
    ByRef nChar As Integer) As Integer

    If ctl.SelStart = 0 Then
        ' This is the first character, so change to uppercase.
        nChar = Asc(UCase$(Chr$(nChar)))
    Else
        ' If the previous character is a space, capitalize
        ' the current character.
        If Mid$(ctl, ctl.SelStart, 1) = Space$(1) Then
            nChar = Asc(UCase$(Chr$(nChar)))
        End If
    End If

    nConvertToCaps = nChar
End Function</code></pre>
<p>
The <i>nConvertToCaps </i>function has no knowledge of the control it is acting on and therefore can be used by any code that has appropriate input parameters. You will often write procedures that you might not foresee anyone else using. By assuming the opposite, that <i>all </i>your code will be reused, you will reduce the time you or others require to later modify functionality for reuse.</p>
<p>
The effects of not writing for reuse can be seen in many development projects but might not be obvious at first. At a high level, it is easy to break down an application into distinct components and code those components as discrete modular units using any of the methods described above. However, there is nearly always a large expanse of code that doesn’t fit neatly into a distinct modular pattern. This is usually the application’s binding code—that is, the logic that controls program flow and links various system components. Processes that are not major components in themselves but simply provide auxiliary functionality are normally assumed rather than specified formally, which is yet another reason why estimating can go wrong when this functionality is not considered. The result of bad design of these elements will usually lead to spaghetti code. The following sections discuss some habits that you should practice until they become automatic.</p>
<h1></h1>
</BODY>
</HTML>
