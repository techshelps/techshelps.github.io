<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Events from Hell</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="theeventsfromhell"></a>The Events from Hell</h1>
<p>
Visual Basic’s <i>GotFocus</i> and <i>LostFocus</i> events have always been exasperating to Visual Basic programmers. They don’t correspond to the normal <i>KillFocus</i> and <i>SetFocus</i> messages generated by Windows; they don’t always execute in the order that you might expect; they are sometimes skipped entirely; and they can prove very troublesome when you use them for field-by-field validation.</p>
<p>
If these two events have caused problems in previous versions of Visual Basic, you might legitimately ask why Microsoft didn’t find a way of “fixing” their behavior in Visual Basic 5. The reason they were left alone has to do with Visual Basic being designed to protect the developer as much as possible from the underlying environment and to be reasonably GPF-proof. If <i>GotFocus</i> and <i>LostFocus</i> really did correspond to <i>KillFocus</i> and <i>SetFocus</i>, trying to do something like show a message box in a <i>GotFocus</i> or <i>LostFocus</i> event would be walking straight into GPF territory. It appears that the Visual Basic team made a decision to “post” these events rather than “send” them. Under the ever-useful principle of least astonishment, most programmers would prefer not to have events whose order is difficult to predict or that disappear entirely, but that’s what we have to live with.</p>
<p>
To demonstrate some of the problems with these two events, I wrote a simple application. This project contains a single window with two text box controls, an OK command button, and a Cancel command button. (See Figure 7-1.)</p>
<p>
<img src="f07rf01.gif" border=0></p>
<p class=blue>
<b>Figure 7-1  Simple interface screen hides events from hell</b></p>
<p>
Both command buttons have an accelerator key; the OK button’s <i>Default</i> property is set to TRUE (that is, pressing the Enter key will click this button), and the Cancel button’s <i>Cancel</i> property is set to TRUE (that is, pressing the Esc key will click this button). The <i>GotFocus</i> and <i>LostFocus</i> events of all four controls contain a <i>Debug.Print</i> statement that will tell you (in the Immediate window) which event has been fired. In this manner, we can easily examine the order in which these events fire and understand some of the difficulties with using them.</p>
<p>
When the application’s window is initially displayed, focus is set to the first text box. The Immediate window shows the following:</p>
<pre><code>Program initialization
txtBox1_GotFocus</code></pre>
<p>
Just tabbing from the first to the second text box shows the following events:</p>
<pre><code>txtBox1_LostFocus
txtBox2_GotFocus</code></pre>
<p>
So far, everything is as expected. Now we can add some code to the <i>LostFocus</i> event of <i>txtBox1</i> to simulate a crude validation of the contents of <i>txtBox1</i>, something like this:</p>
<pre><code>Private Sub txtBox1_LostFocus

Debug.Print "txtBox1_LostFocus"
If Len(txtBox1.Text) &gt; 0 Then
    txtBox1_SetFocus
End If

End Sub</code></pre>
<p>
Restarting the application and putting any value into <i>txtBox1</i> followed by tabbing to <i>txtBox2</i> again shows what looks like a perfectly normal event stream:</p>
<pre><code>txtBox1_LostFocus
txtBox2_GotFocus
txtBox2_LostFocus
txtBox1_GotFocus</code></pre>
<p>
Normally, however, we want to inform the user if a window control contains anything invalid. So in our blissful ignorance, we add a <i>MsgBox</i> statement to the <i>LostFocus</i> event of <i>txtBox1</i> to inform the user that something’s wrong:</p>
<pre><code>Private Sub txtBox1_LostFocus

Debug.Print "txtBox1_LostFocus"
If Len(txtBox1.Text) &gt; 0 Then
    MsgBox "txtBox1 must be empty!"
    txtBox1_SetFocus
End If

End Sub</code></pre>
<p>
Restarting the application and putting any value into <i>txtBox1</i> followed by tabbing to <i>txtBox2</i> shows the first strangeness. We can see that when the message box is displayed, <i>txtBox2</i> never receives focus—but it does lose focus!</p>
<pre><code>txtBox1_LostFocus
txtBox2_LostFocus
txtBox1_GotFocus</code></pre>
<p>
Now we can go further to investigate what happens when both text boxes happen to have invalid values. So we add the following code to the <i>LostFocus</i> event of <i>txtBox2</i>:</p>
<pre><code>Private Sub txtBox2_LostFocus

Debug.Print "txtBox2_LostFocus"
If Len(txtBox2.Text) = 0 Then
    MsgBox "txtBox2 must not be empty!"
    txtBox2_SetFocus
End If

End Sub</code></pre>
<p>
Restarting the application and putting any value into <i>txtBox1</i> followed by tabbing to <i>txtBox2</i> leads to a program lockup! Because both text boxes contain what are considered to be invalid values, we see no <i>GotFocus</i> events but rather a continuous cascade of <i>LostFocus</i> events as each text box tries to claim focus in order to allow the user to change its invalid contents. This problem is a well-known one in Visual Basic, and a programmer usually gets caught by it only once.</p>
<p>
At this point, removing the <i>MsgBox</i> statements completely only makes the situation worse. If you do try this, your program goes seriously sleepy-bye-bye. Because the <i>MsgBox</i> function no longer intervenes to give you some semblance of control over the event cascade, you’re completely stuck. Whereas previously you could get access to the Task Manager to kill the hung process, you will now have to log out of Windows to regain control.</p>
<p>
These are not the only peculiarities associated with these events. If we remove the validation code to prevent the application from hanging, we can look at the event stream when using the command buttons. Restart the application, and click the OK button. The Immediate window shows a normal event stream. Now do this again, but just press Enter to trigger the OK button rather than clicking on it. The Debug window shows quite clearly that the <i>LostFocus</i> event of <i>txtBox1</i> is never triggered. Exactly the same thing happens if you use the OK button’s accelerator key (Alt+O)—no <i>LostFocus</i> event is triggered. Although in the real world you might not be too worried if the Cancel button swallows a control’s <i>LostFocus</i> event, it’s a bit more serious when you want validation to occur when the user presses OK.</p>
<p>
There are several more or less satisfactory methods of overcoming the problems with these two events. Possibly the best strategy is to ignore them altogether and instead use a tool such as MsgBlaster or SpyWorks to intercept the Windows messages that correspond to these events (<i>SetFocus</i> and <i>KillFocus</i>). This makes performing activities such as field-by-field validation relatively trivial.</p>
<p>
<b>Some Final Thoughts</b> Never rely on <i>GotFocus</i> and <i>LostFocus</i> events actually occurring or occurring in the order you expect.</p>
<h1></h1>
</BODY>
</HTML>
