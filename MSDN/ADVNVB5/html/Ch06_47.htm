<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unicode and the byte data type</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="unicodebytedatatype"></a>Unicode and the byte data type</h1>
<p>
Visual Basic 3 was not Unicode or Double-Byte Character Set (DBCS)–aware. Unicode stores each character in the character set in 2 bytes instead of 1. DBCS is a mixture—if the first character is in a certain range, the following byte also forms part of that character. These systems are used for displaying character sets in regions of the world where more than 256 characters are used—in Asia, for example. Since Visual Basic 4, the language has converted strings to Unicode for internal manipulation. If you’re using Visual Basic under a version of Windows that uses DBCS, any information that is read in as a string can be translated into its equivalent Unicode string that maps to the DBCS byte pair. Because of this effect, any existing code that reads binary data (File I/O) using the string data type might need to be converted to use the byte data type. Visual Basic’s internal Unicode strings are translated to ANSI strings when you are writing to a file or passing the string to a DLL. Additionally, code written to use Visual Basic strings as a way to manipulate binary data might need to be rewritten.</p>
<p>
For example, the following code runs fine under Visual Basic 3 and 16-bit Visual Basic 4, but it will not work properly under 32-bit Visual Basic 4 or Visual Basic 5.</p>
<pre><code>Type TData
    nAge  As Integer
    sName As String * 20
End Type
Type TStringBuffer
    sString As String * 22
End Type

Sub Main ()
    Dim nFileNo     As Integer
    Dim nNoRecords  As Integer
    Dim nRecord     As Integer
    Dim sTestString As String
    Dim udtData     As TData
    Dim udtString   As TStringBuffer

    nFileNo = FreeFile
    Open "TESTFILE.TST" For Binary As #nFileNo
    nNoRecords = 2
    Put #nFileNo, , nNoRecords
    udtData.nAge = 69
    udtData.sName = "Kevin"
    Put #nFileNo, , udtData
    udtData.nAge = 25
    udtData.sName = "Clive"
    Put #nFileNo, , udtData
    Close nFileNo
    nFileNo = FreeFile
    Open "TESTFILE.TST" For Binary As #nFileNo
    sTestString = Space(LOF(nFileNo) - 2)
    Get #nFileNo, , nNoRecords
    Get #nFileNo, , sTestString
    For nRecord = 1 To nNoRecords
        udtString.sString = Mid$(sTestString, _
            ((nRecord - 1) * 22) + 1, 22)
        LSet udtData = udtString
        MsgBox Trim$(udtData.sName) &amp; " is " _
            &amp; CStr(udtData.nAge)
    Next
    Close nFileNo
End Sub</code></pre>
<p>
The code that reads the data in needs to be rewritten thus:</p>
<pre><code>Type TData
    nAge      As Integer
    sName(20) As Byte
End Type
Type TStringBuffer
    sString As String * 22
End Type
Sub Main()
    Dim nFileNo     As Integer
    Dim nNoRecords  As Integer
    Dim nRecord     As Integer
    Dim sTestString As String
    Dim bytArray()  As Byte
    Dim udtData     As TData
    Dim udtString   As TStringBuffer
    nFileNo = FreeFile
    Open "TESTFILE.TST" For Binary As #nFileNo
    ReDim bytArray(0 To LOF(nFileNo) - 2)
    Get #nFileNo, , nNoRecords
    Get #nFileNo, , bytArray
    sTestString = bytArray
    For intRecord = 1 To nNoRecords
        udtString.sString = MidB(sTestString, _
            ((nRecord - 1) * 22) + 1, 22)
        LSet udtData = udtString
        MsgBox Trim$(StrConv(udtData.sName, _
            vbUnicode)) &amp; " is " &amp; CStr(udtData.nAge)
    Next
    Close nFileNo
End Sub</code></pre>
<p class=indent>
<span class=blue><b>Tip </b></span> Most DLLs that accept strings have two versions—one that handles Unicode and one that handles ANSI. When calling the API from Visual Basic, it is best to use the ANSI version because Visual Basic converts strings to this form when handing strings to DLL calls.</p>
<p>
The conversion to using the <i>Byte </i>data type is accomplished as follows:</p>
<h2>16-Bit Visual Basic Implementation</h2>
<pre><code>nFreeFile = FreeFile
Open sFileName For Binary As #nFreeFile
Dim sTemp As String * 128
Get #nFreeFile, , sTemp</code></pre>
<h2>32-Bit Visual Basic Implementation</h2>
<pre><code>nFreeFile = FreeFile
Open sFileName For Binary As #nFreeFile
Dim bTemp(0 To 127) As Byte
Get #nFreeFile, , bTemp()</code></pre>
<p>
To manipulate binary data using string functions, do the following:
<ul type=disc>
<li>
Put the binary data into a byte array using functions such as <i>Get</i>.<br><br></li>
<li>
Assign the byte array to a string. The data is not translated in any way—it is merely copied into the string. Note that strings in binary format are not usable in the normal sense because internal strings in Visual Basic under 32-bit Windows are assumed to be Unicode and double-byte for most operations.<br><br></li>
<li>
Use the “B” functions to manipulate the binary data in the string.<br><br></li>
<li>
Assign the contents of the string back to the byte array in order to write them back to the file.</li>
</ul>
<p>
The following functions manipulate strings of binary data:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=296><b>Function</b></td>
<td class=blue width=296><b>What It Does</b></td>
</tr>
<tr valign=top>
<td width=296>AscB</td>
<td width=296>Returns the value corresponding to the first byte in a string of binary data</td>
</tr>
<tr valign=top>
<td width=296>InStrB</td>
<td width=296>Returns the position of the first occurrence of one byte array within a string of binary data</td>
</tr>
<tr valign=top>
<td width=296>MidB</td>
<td width=296>Returns the specified number of bytes from a string of binary data</td>
</tr>
<tr valign=top>
<td width=296>LeftB/RightB</td>
<td width=296>Returns the specified number of bytes from the right or left side of a string of binary data</td>
</tr>
<tr valign=top>
<td width=296>ChrB</td>
<td width=296>Takes a byte and returns a binary string containing the byte</td>
</tr>
</table><br>
<h1></h1>
</BODY>
</HTML>
