<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Smoke and Mirrors</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="usingsmokemirrors"></a>Using Smoke and Mirrors</h1>
<p>
The best optimization is the perceived one. If you make something look or feel fast, it will generally be perceived as being fast. Give your users good feedback. For example, use a progress bar. Your code will actually run slower (it’s having to recalculate and redraw the progress bar), but the user’s perception of its speed, compared with not having the progress bar, will almost always be in your favor.</p>
<p>
One of the smartest moves you can ever make is to start fast. (Compiling to native code creates “faster to start” executables.) Go to great lengths to get that first window on the screen so that your users can start using the application. Leave the logging onto the database and other such tasks until after this first window is up. Look at the best applications around: they all start, or appear to start, very quickly. If you create your applications to work the same way, the user’s perception will be “Wow! This thing is usable <i>and </i>quick.” Bear in mind that lots of disk activity before your first window appears means you’re slow: lots after, however, means you’re busy doing smart stuff!</p>
<p>
Because you cannot easily build multithreaded Visual Basic applications (see Chapter 14 to see some light at the end of this particular tunnel), you might say that you’ll have to block sometime; that is, you’re going to have to log on sometime, and you know that takes time—and the user will effectively be blocked by the action. Consider breaking out the logging on into a separate application implemented as an out-of-process ActiveX server, perhaps writing this server to provide your application with a set of data services. Use an asynchronous callback object to signal to the user interface part of your application when the database is ready to be used. When you get the signal, enable those features that have now become usable. If you take this approach, you’ll find, of course, that the data services ActiveX server is blocked—waiting for the connection—but your thread of execution, in the user interface part of the application, is unaffected, giving your user truly smooth multitasking. The total effort is minimal; in fact, you might even get some code reuse out of the ActiveX server. The effect on the user’s perception, however, can be quite dramatic.</p>
<h1></h1>
</BODY>
</HTML>
