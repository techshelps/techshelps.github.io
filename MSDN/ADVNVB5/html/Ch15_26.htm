<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using a ROOS</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="usingroos"></a>Using a ROOS</h1>
<p>
Another aid to reusability, first mentioned in Chapter 1, is the ROOS (Resource Only OLE Server), pronounced “ruse.” We’ve referred to OLE servers as object components for most of this chapter, but they are two different names for the same object. (To be politically correct, they should really be called ActiveX components, but ROAC is not as easy to pronounce!) A ROOS essentially stores string, bitmap, and other resources that are liable to be changed at some time. Another use for a ROOS is to store multilanguage strings. If you wrote an application to be sold in the United States and in France, using the normal Visual Basic method of setting display text in code would mean that you would have to create two versions of the application: one with English display text and captions and one with French. Obviously, this would create a significant maintenance overhead, because if you have to apply a bug fix to one of the versions, you also need to apply the change to the other. The ROOS is exactly the same in principle as a resource-only DLL as used by many C and C++ programmers. The difference between a ROOS and its DLL counterpart is that the ROOS is an object component and as such can be deployed anywhere on a network and used by any client components.</p>
<p>
You can store many types of resources in a ROOS:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td width=296>Accelerator table</td>
<td width=296>Group cursor</td>
</tr>
<tr valign=top>
<td width=296>Bitmap resource</td>
<td width=296>Group icon</td>
</tr>
<tr valign=top>
<td width=296>Cursor resource</td>
<td width=296>Icon resource</td>
</tr>
<tr valign=top>
<td width=296>Dialog box</td>
<td width=296>Menu resource</td>
</tr>
<tr valign=top>
<td width=296>Font directory resource</td>
<td width=296>String resource</td>
</tr>
<tr valign=top>
<td width=296>Font resource</td>
<td width=296>User-defined resource</td>
</tr>
</table><br>
<p>
A ROOS has two components. The first is the resource module, a special file created with an application such as Microsoft Visual C++. The resource module contains all the resources you want to store and retrieve. The second element of the ROOS is a method to retrieve a resource from the resource module. At TMS, we prefer to expand the functionality of the ROOS methods so that string values can be parsed with input parameters. The following example illustrates this.</p>
<h2>Resource Entries</h2>
<pre><code>String ID:    400
String value: "The operation completed with % errors"</code></pre>
<h2>Client Code</h2>
<pre><code>StringID = 400
MyText = GetStringFromROOS(StringID, "no")</code></pre>
<h2>ROOS Code</h2>
<pre><code>Public Function GetStringFromROOS(StringID As String, _
    Param) As String
    Dim sText  As String

    sText = GetString(StringID)
    sText = MergeString(sText, Param)
    GetStringFromROOS = sText

End Function</code></pre>
<h2>Result</h2>
<pre><code>MyText: "The operation completed with no errors"</code></pre>
<p>
Many projects store custom error messages or other display text in a database file. In an error handler, the custom error text is better in a ROOS because the execution speed is much faster, and many organizations restrict access to make database changes to the database administrator—no good if you’re a programmer and have to wait two days to change the caption on a button! Another excellent use of a ROOS is to store icons and bitmaps. Imagine you’re lucky enough to have an artist to create all your graphics. You can create a ROOS with dummy resources, and then the artist can add the real graphics to the ROOS as they become available without having to access any source code. (No more multiple access problems!)</p>
<p>
Creating a resource module is easy if you have the right tools. You simply enter the resources you want. Each resource has an ID value, which is a long integer. To retrieve the resource from the resource module, you simply use the <i>LoadResData</i>, <i>LoadResPicture</i>, or <i>LoadResString </i>command specifying the resource’s ID. Figure 15-11 shows a typical resource file in Microsoft Visual C++ 5. Once the resource module is created (it’s actually an RC file), you simply compile it with the RC.EXE program (supplied on the Visual Basic CD-ROM) to create a RES file that you can add to your ROOS project. You can have only one RES file in a single Visual Basic project, but one is plenty! (If you don’t have access to Visual C++ or any other tool for creating resource files, you can use an editor such as Notepad. Before attempting this, however, you should study an RC file and a Resource.h file to become familiar with their format.)</p>
<p>
Obviously, any client requesting data from the ROOS will need to know the ID value for each resource. In Visual Basic 4, you would need to include your ID constants in each client application, either as hard-coded constants or in a shared type library. With Visual Basic 5, you can declare all your IDs within the ROOS as enumerated constants, which makes them automatically available to client applications.</p>
<p>
Listing 15-1 shows a slightly more advanced ROOS that retrieves string and bitmap resources. The ROOS allows you to merge an unlimited number of tokens into a string resource. To create a string resource with tokens, simply insert a % symbol in the string where the supplied parameter(s) will be substituted.</p>
<p>
<img src="f15rf11.gif" border=0></p>
<p class=blue>
<b>Figure 15-11  A resource file created in Microsoft Visual C++ 5</b></p>
<p class=blue>
<b>Listing 15-1  ROOS for retrieving string and bitmap resources</b></p>
<pre><code>' The following Enums declare the resource ID of the bitmaps
' in our RES file. The include file "resource.h" generated
' by the resource editor defines the constants to match each
' bitmap. Checking this file shows the first bitmap resource
' ID to be 101; therefore, these Enums are declared to match
' this.
Public Enum BITMAPS

' ***
' *** NOTE: Any new bitmaps added must be inserted between
' *** IDB_TOPVALUE and IDB_LASTVALUE because these constants are
' *** used to validate input parameters.
' ***
    idb_topvalue = 100
    IDB_SELECTSOURCE
    IDB_SELECTDESTIN
    IDB_NUMBERSOURCE
    IDB_COMPLETED
    idb_lastvalue
End Enum


Public Enum STRINGS
    
    ' VBP project file key ID words
    IDS_VBP_KEY_FORM = 500
    IDS_VBP_KEY_CLASS
    IDS_VBP_KEY_MODULE
    IDS_VBP_SEP_FORM
    IDS_VBP_SEP_CLASS
    IDS_VBP_SEP_MODULE
    IDS_VBP_SEP_RESFILE
    IDS_VBP_KEY_RESOURCE16
    IDS_VBP_KEY_RESOURCE32
    
    ' Procedure keywords
    IDS_PROCKEY_SUB1 = 600
    IDS_PROCKEY_SUB2
    IDS_PROCKEY_SUB3
    IDS_PROCKEY_FUNC1
    IDS_PROCKEY_FUNC2
    IDS_PROCKEY_FUNC3
    IDS_PROCKEY_PROP1
    IDS_PROCKEY_PROP2
    IDS_PROCKEY_PROP3
    IDS_PROCKEY_END1
    IDS_PROCKEY_END2
    IDS_PROCKEY_END3
    IDS_PROCKEY_SELECT
    IDS_PROCKEY_CASE
    IDS_PROCKEY_COMMENT
    
    ' File filter strings
    IDS_FILTER_FRX = 700
    IDS_FILTER_PROJECT
    IDS_FILTER_CLASS
    IDS_FILTER_FORM
    IDS_FILTER_MODULE
    IDS_FILTER_CONFIG
    IDS_FILE_TEMP
    
    ' Displayed caption strings
    IDS_CAP_STEP1 = 800
    IDS_CAP_STEP2
    IDS_CAP_STEP3
    IDS_CAP_STEP4
    IDS_CAP_NUMBER

IDS_CAP_UNNUMBER
    IDS_CAP_CANCEL
    IDS_CAP_FINISH
    IDS_CAP_CANCEL_ALLOWED
    
    ' Message strings
    IDS_MSG_NOT_TEMPLATE = 900
    IDS_MSG_COMPLETE_STATUS
    IDS_MSG_TEMPL_CORRUPT
    IDS_MSG_INVALID_CONFIG
    IDS_MSG_CREATE_TMPL_ERR
    IDS_MSG_NO_SOURCE
    IDS_MSG_INVALID_DESTIN
    IDS_MSG_SAME_SRC_DESTIN
    IDS_MSG_QUERY_EXIT
    IDS_MSG_ABORTED
    
    ' Err.Description strings
    IDS_ERR_GDI = 1000
    IDS_ERR_PROCESS_ERROR
End Enum

' Resource ROOS error constants
Public Enum RR_Errors
    RR_INVALID_BITMAP_ID = 2000 ' Invalid bitmap resource ID
    RR_INVALID_STRING_ID        ' Invalid string resource ID
End Enum

Public Sub PuGetBmp(ByVal ilBitmapID As Long, _
    ByVal ictl As Control)

    ' Check that the ID value passed is valid. This is an
    ' Assert type of message, but the class cannot be part
    ' of the design environment, so raise an error instead.

    If ilBitmapID &lt;= idb_topvalue Or _
        ilBitmapID &gt;= idb_lastvalue Then
        
        Err.Description = "An invalid bitmap ID value '" &amp; _
            ilBitmapID &amp; "' was passed."
        Err.Number = RR_INVALID_BITMAP_ID
        Err.Raise Err.Number
        Exit Sub
    End If

     ' Load the bitmap into the picture of the control passed.
    ictl.Picture = LoadResPicture(ilBitmapID, vbResBitmap)
End Sub

Public Function sPuGetStr(ByVal ilStringID As Long, _
    Optional ByVal ivArgs As Variant) As String

    Dim nIndex          As Integer
    Dim nPointer        As Integer
    Dim nTokenCount     As Integer
    Dim sResString      As String
    Dim vTempArg        As Variant

    Const ARG_TOKEN     As String = "%"

    sResString = LoadResString(ilStringID)

    If IsMissing(ivArgs) Then GoTo END_GETRESOURCESTRING

    If (VarType(ivArgs) And vbArray) &lt;&gt; vbArray Then

        ' Single argument passed. Store the value so that we can
        ' convert ivArgs to an array with this single
        ' value.
        vTempArg = ivArgs
        ivArgs = Empty
        ReDim ivArgs(0)

        ivArgs(0) = vTempArg
    End If

    nTokenCount = 0

    Do While nTokenCount &lt; UBound(ivArgs) _
        = LBound(ivArgs) + 1
    
        nPointer = InStr(sResString, ARG_TOKEN)
        If nPointer = 0 Then

            ' There are more arguments than tokens in the RES
            ' string, so exit the loop.

            Exit Do
        End If



        Call sPiReplaceToken(sResString, ARG_TOKEN, _
            ivArgs(LBound(ivArgs) + nTokenCount))
        nTokenCount = nTokenCount + 1
    Loop

END_GETRESOURCESTRING:
    sPuGetStr = sResString
End Function

Private Function sPiReplaceToken(ByRef iosTokenStr As String, _
    ByVal isToken As String, ByVal ivArgs As Variant)

    Dim nPointer As Integer

    nPointer = InStr(iosTokenStr, isToken)
    If nPointer &lt;&gt; 0 Then
        iosTokenStr = Left$(iosTokenStr, nPointer - 1) &amp; _
            ivArgs &amp; Mid$(iosTokenStr, nPointer + 1)
    End If
End Function
</code></pre>
<h1></h1>
</BODY>
</HTML>
