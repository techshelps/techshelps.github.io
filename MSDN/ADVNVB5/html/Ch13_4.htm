<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>When to Go Directly to the ODBC Layer</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="whentogodirectlytoodbclayer"></a>When to Go Directly to the ODBC Layer</h1>
<p>
As I mentioned earlier, although ODBC first shipped with version 2 of Visual Basic, it wasn’t until Visual Basic 3 and Access 1 that there were drivers for database systems such as Sybase and Oracle. This meant that until Visual Basic 3, not many people were using ODBC through its native API. Most users’ first taste of ODBC came through using it via DAO, and these first impressions were frequently poor because performance generally wasn’t good. Poor performance was a direct consequence of adding the Jet database engine, which was designed for high generality and for providing a generic library of data access functions that would make Visual Basic code written to the DAO independent of the data source. To achieve this independence, some flexibility and optimization for specific functions were sacrificed.</p>
<p>
In bench tests against Microsoft SQL Server, when direct ODBC API rather than DAO calls were compared with calls made using the Microsoft Visual Basic Library for SQL Server (VBSQL) API (which is built on the proprietary DB-Library API—the native API for SQL Server), the average performance numbers were comparable. Some ODBC functions were faster than some DB-Library calls, and vice versa. Getting a connection through the ODBC API, for example, took longer than getting a connection through VBSQL calls, although not by an order of magnitude.</p>
<p>
With DAO and RDO programming models, you can build applications that are not only easier to write but also seamlessly compatible with a wide variety of Indexed Sequential Access Method (ISAM) databases, such as Btrieve, or remote engine databases, such as SQL Server or Oracle. Where the target database engine is likely to change or be upgraded over time, DAO and RDO programming models can significantly reduce the time needed to adapt to a new server database.</p>
<p>
The ODBC API programming approach is somewhat more difficult to implement, but it also affords much of the same portability as the DAO and RDO models. The ODBC API is more difficult to use primarily because there is more code to write and the functions are more complex. Although you don’t write to any data objects with this approach, the ODBC API supports access to any back-end database for which an ODBC driver exists. By querying the driver for server-specific features, you can automatically adapt your data access method to the remote database’s functionality.</p>
<h1></h1>
</BODY>
</HTML>
