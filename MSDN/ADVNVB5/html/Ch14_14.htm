<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CallMe old-fashioned</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><i><a name="callmeold-fashioned"></a>CallMe </i>old-fashioned</h1>
<p>
The <i>CallMe</i> DLL is pretty simple, but it’s still a DLL. It turns a programming project into a mixed-language development, it means you have to buy a compiler, and it adds an extra component to the distribution package you’re going to have to build when you ship the product. Finding a way to do without a DLL would certainly be an attractive option.</p>
<p>
Figuring out the answer simply requires a bit of lateral thinking. You’ve already seen how API functions that take a callback parameter can invoke Visual Basic functions, so it takes a simple shift of perspective to see such API functions as obliging <i>CallMe </i>servers. All you have to do is find an API function that takes a callback function, calls it once, and preferably doesn’t do much else.</p>
<p>
A quick trawl through the Win32 API documentation (unfortunately not supplied with Visual Basic) reveals <i>SetTimer </i>as a possibility since its sole purpose is to invoke an event handler that you register with it. The only problem with this is that <i>SetTimer </i>keeps calling the function until you kill the timer, so you must find a way to kill the timer after a single invocation. You could do this by including a call to <i>KillTimer </i>in the callback procedure itself, but this is ugly because the mechanism is inextricably bound up with the functions you want to call—if you’re building an FSM, for example, all your action functions must look like this:</p>
<pre><code>Sub Action1()
    Call KillTimer lTimerId
    ' Real action code goes here
End Sub</code></pre>
<p>
The consequence of leaving out a call to <i>KillTimer </i>is a ceaseless barrage of calls to the offending function, with who knows what consequences—yuck!</p>
<p>
There are other candidates, but one that works nicely is <i>CallWindowProc</i>. This function is normally used to attach a custom message handler (a.k.a. a window procedure) to a window; the custom message handler passes on unwanted messages using <i>CallWindowProc</i>, which tells Windows to invoke the default window procedure. You’re not chaining any message handlers here, and you don’t even have a window; but you can still invoke <i>CallWindowProc </i>to call a Visual Basic function. The only restriction is that your Visual Basic function must have the following interface:</p>
<pre><code>Function Action1(ByVal hWnd As Long, _
                 ByVal lMsg As Long, _
                 ByVal wParam As Long, _
                 ByVal lParam As Long) As Long</code></pre>
<p>
Windows 95 lets you call a parameterless procedure as long as you trap the “Bad DLL calling convention” error (error 49) (The error 49 is generated when Visual Basic detects a stack frame anomaly on return from <i>CallWindowProc</i>, although there’s nothing wrong with the API call itself. In fact, the error happens earlier, when the <i>Action1</i> routine returns to <i>CallWindowProc</i>. <i>CallWindowProc </i>pushes four parameters onto the stack and expects the action function to remove them before it returns. (This is the Pascal, or <i>stdcall</i>, calling convention.) Our function doesn’t oblige since it thinks there were no parameters, but because Windows 95 doesn’t do stack checking at run time, the error goes undetected. Visual Basic <i>does</i> do stack checking, so it detects the error when the API call returns. Windows NT is less forgiving here—it immediately detects the stack error and raises an exception inside <i>CallWindowProc</i>. You can’t trap operating system exceptions in Visual Basic, so this kills the program (or kills Visual Basic if you’re in the IDE). This, of course, is exactly what should happen, and it’s a useful reminder that you shouldn’t be taking such liberties! The sample program in CHAP14\fsm\tabldriv on the companion CD uses conditional compilation to demonstrate the use of parameterless action procedures.), but for reasons of portability—and good programming practice—you shouldn’t rely on this.</p>
<p>
All you need to do now is to wrap the <i>CallWindowProc </i>call up in a Visual Basic function, and you have a <i>CallMe</i>, effectively written in Visual Basic:</p>
<pre><code>Sub CallMe(ByVal pcbAddress As Long)

    Call CallWindowProc(pcbAddress, 0&amp;, 0&amp;, 0&amp;, 0&amp;)

End Sub</code></pre>
<h1></h1>
</BODY>
</HTML>
