<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the Compiler to Optimize Your Code</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="usingcompilertooptimizeyourcode"></a>Using the Compiler to Optimize Your Code</h1>
<p>
The effect of the optimizer (project properties dialog box settings) on how C2.EXE and LINK.EXE are driven is summarized in Table 8-5 (for building a standard EXE). Because most switches have no effect on these two EXEs, we must assume that they are being acted on within VB5.EXE itself. (It seems to contain the compiler’s first pass.)</p>
<p class=blue>
<b>Table 8-5  The Compiler Effect</b></p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=218><b>Optimization Option</b></td>
<td class=blue width=180><b>C2.EXE Effect</b></td>
<td class=blue width=194><b>LINK.EXE Effect</b></td>
</tr>
<tr valign=top>
<td width=218>Optimize For Small Code</td>
<td width=180>None</td>
<td width=194>None</td>
</tr>
<tr valign=top>
<td width=218>Optimize For Fast Code</td>
<td width=180>None</td>
<td width=194>None</td>
</tr>
<tr valign=top>
<td width=218>Favor Pentium Pro</td>
<td width=180>/G6 (from G5)</td>
<td width=194>None</td>
</tr>
<tr valign=top>
<td width=218>Create Symbolic Debug Info</td>
<td width=180>/Zi</td>
<td width=194>/DEBUG/DEBUGTYPE:CV </td>
</tr>
<tr valign=top>
<td width=218>Assume No Aliasing</td>
<td width=180>None</td>
<td width=194>None</td>
</tr>
<tr valign=top>
<td width=218>Remove Array Bounds Checks</td>
<td width=180>None</td>
<td width=194>None </td>
</tr>
<tr valign=top>
<td width=218>Remove Integer Overflow Checks</td>
<td width=180>None</td>
<td width=194>None </td>
</tr>
<tr valign=top>
<td width=218>Remove Floating Point Error Checks</td>
<td width=180>None</td>
<td width=194>None </td>
</tr>
<tr valign=top>
<td width=218>Allow Unrounded Floating Point Operations</td>
<td width=180>None</td>
<td width=194>None </td>
</tr>
<tr valign=top>
<td width=218>Remove Safe Pentium FDIV Checks</td>
<td width=180>/Qifdiv Removed</td>
<td width=194>None </td>
</tr>
</table><br>
<p>
Obviously, -G6 means favor the Pentium Pro. Even the Visual C++ 4.2 compiler doesn’t implement this. But of course, Visual Basic 5’s C2 is taken from Visual C++ version 5!</p>
<p>
As I’ve said before, compiled code is faster than p-code, so of course, one “easy” optimization everyone will expect to make is to compile to native code. Surely this will create faster-executing applications when compared with a p-code clone?</p>
<p>
Using the <i>TimeGetTime </i>routine (discussed fully earlier on page 346), we do indeed see some impressive improvements when we compare one against the other. For example, the following loop code, on my 200-MHz machine, takes 13.5 milliseconds to execute as compiled p-code and just 1.15 milliseconds as native code—almost 12 times faster (optimizing for Favor Pentium Pro and Fast Code). If this kind of improvement is typical, “real” compilation is, indeed, an easy optimization.</p>
<pre><code>Dim n As Integer
Dim d As Double

For n = 1 To 32766
    ‘ Do enough to confuse the optimizer.
    d = (n * 1.1) - (n * 1#)
Next</code></pre>
<p>
In case you’re interested, this same code compiled as p-code under Visual Basic 4 (32-bit) executed in 12.75 milliseconds.</p>
<p>
Microsoft claims that Visual Basic 5 produces native code applications that run up to 20 times faster than applications built with earlier versions of Visual Basic. The CPU-intensive benchmarks in Figure 8-2 show that for compute-intensive operations, Visual Basic 5 is 20 to 60 times faster than Visual Basic 4.</p>
<p>
<img src="f08rf02.gif" border=0></p>
<p class=blue>
<b>Figure 8-2  CPU-intensive benchmark results—Visual Basic 5 vs. Visual Basic 4 . . .</b></p>
<p>
We discovered one disappointing native code negative in conducting our tests, although this drawback might affect very few people. At TMS, we often use <i>GoSub </i>to write local subroutines—that is, subroutines that don’t pollute the global name space and that are called very fast. The idea is that you might expect to have a <i>GoSub </i>simply resolve to a push/jmp instruction sequence. Because you don’t have the ability to use passed arguments to the subroutine, you might also expect to see a saving here on not having to push a set of arguments. (You use local variables for holding passed information.) Well, in the past, all of this was simply dandy. With Visual Basic 5 in Native Code mode, however, <i>GoSub </i>calls run <i>really </i>slowly. Our advice is not to use them in Visual Basic 5 if you’re going to compile to native code.</p>
<h1></h1>
</BODY>
</HTML>
