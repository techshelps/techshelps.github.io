<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Unit/Component Testing</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="unitcomponenttesting"></a>Unit/Component Testing</h1>
<p>
Unit testing is a test of a simple piece of code—in our case a subroutine, a function, an event, or a <i>Property Get/Let/Set</i>. In formal terms, it is the smallest piece of code testable. It should be nonreliant on other units of code that have been written for this development project because they will almost certainly be only partly tested themselves. However, it is acceptable to call library routines (such as the Visual Basic built-in functions) since you can be highly confident that they are correct. The idea is to confirm that the functional specification of the unit has been correctly implemented. An example of a unit would be a single user-defined calculation.</p>
<p class=indent>
<span class=blue><b>Tip</b></span>   Sometimes it is necessary to comment out one piece of code to get another piece to work. This might be necessary during the main development cycle when, for example, the underlying code might be dependent on something that has not yet been written or that contains a known bug. If you have to comment out a piece of code, add a <i>Debug.Print</i> statement just before or after it to highlight the fact that you have done so. It’s inevitable that you’ll forget to remove the leading apostrophe from time to time, and adding a <i>Debug.Print</i> statement should save your having to find out the hard way.</p>
<p>
Component-level testing is the next level up from unit testing. A component can have fairly straightforward functionality, but it is just complex enough to warrant breaking down the actual implementation into several smaller units. For example, a logical process could be specified that calculates the monthly salary for an individual. This process might consist of the following operations:
<ul type=disc>
<li>
Extract from the database the number of hours worked in the month.<br><br></li>
<li>
Calculate the amount of gross pay.<br><br></li>
<li>
Optionally, add a bonus amount.<br><br></li>
<li>
Make all standard deductions from this amount.</li>
</ul>
<p>
Each operation will probably have different requirements. For example, the database extraction will need error handling to allow for the usual group of possibilities (user record not found, database service not available, and so on). The calculations will need to prevent numeric type errors (divide by zero, mainly), and if they are remote components, they will have to raise fresh errors. Therefore, the entire component (for example, <i>CalcMonthlySalary</i>) will consist of four smaller units (<i>GetHoursForEmployee</i>, <i>CalcGrossPay</i>, <i>GetBonusAmount</i>, and <i>CalcDeductions</i>), but <i>CalcMonthlySalary</i> will still be small enough to qualify as a unit (for testing purposes).</p>
<p>
To test a defined unit, a series of scenarios should be devised that guarantees every line of code will be executed at some time (not necessarily in the same test). For example, if a function includes an <i>If..Then..Else</i> statement, at least two test scenarios should be devised, one to cover each path of execution. If it is a function that is being tested, defining the expected result of the test is generally easier because the return value of the function can be tested for correctness or reasonableness. However, if you are testing a subroutine, you can check only the effect(s) of calling the routine because there is no return value. I generally have a bias toward writing routines as functions where this is reasonable. For some operations, particularly GUI manipulation, it is not so necessary or beneficial because an error should generally be contained within the routine in which it occurred.</p>
<p>
In a small system, the developer would likely perform this level of testing. In a larger system, the initial test would still be performed by the developer, but a more formal version of the test would most likely be conducted by a separate individual.</p>
<h1></h1>
</BODY>
</HTML>
