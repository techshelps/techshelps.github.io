<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UDTs Are Not Self-Describing</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="udtsarenotself-describing"></a>UDTs Are Not Self-Describing</h1>
<p>
One seemingly trivial difference between the two examples is that with the UDT case, you would need to have had the definition of <i>Point </i>visible to your code, either in that module or as a <i>Public</i> <i>Type</i> in another module. The class, on the other hand, comes as part of the Automation framework, which means you need only have a reference to the binary implementation of the class for it to work. The accompanying type library will describe to the calling code that the <i>Point </i>class has two properties, <i>X </i>and <i>Y</i>.</p>
<p>
Suppose you were developing a library of code that handles point manipulation:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=296><b>Using a Class</b></td>
<td class=blue width=296><b>Using a User-Defined Type </b></td>
</tr>
<tr valign=top>
<td width=296>Calling function needs a reference to the library. Built-in type library enables calling function to use <i>Point </i>class.</td>
<td width=296>Need to ship a BAS file, which the calling function must include in its source code to understand <i>Point </i>UDT.</td>
</tr>
</table><br>
<p>
Automation is concerned with <i>binary</i> integration of components, not source code integration. Out-of-process and Remote Automation components interact with one another through the same mechanism as does code utilizing classes <i>within</i> a single program. It is clear that UDTs do not fit into this approach because of their inability to describe themselves at a binary level.</p>
<p>
This explains why the newer features of Visual Basic tend not to support UDTs. For example, Visual Basic 5 will not let you do the following:
<ul type=disc>
<li>
Have a UDT as a public property of a class or a form<br><br></li>
<li>
Pass a UDT as a <i>ByVal </i>parmeter to a subroutine or a function<br><br></li>
<li>
Have a UDT as a parameter to a public method of a class or a form<br><br></li>
<li>
Have a UDT as the return type of a public method of a class or a form<br><br></li>
<li>
Place a UDT into a Variant</li>
</ul>
<p>
However, you can do all these things with classes. For this reason alone, you should use classes instead of UDTs.</p>
<h1></h1>
</BODY>
</HTML>
