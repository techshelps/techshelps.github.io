<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Managing Windows</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="managingwindows"></a>Managing Windows</h1>
<p>
The most striking feature of the majority of commercial Visual Basic applications is the set of windows they create and manipulate, including the way the user gets around these windows and the ways in which the windows interact with one another. Often a window-management scheme is something that simply evolves during implementation: the developer might not have a clear idea about how each window will behave with respect to other windows, and the window-management features built into Visual Basic might be the factor that most influences how the design turns out. This isn’t so much a poor design strategy as the lack of a strategy, and the resulting problems can be anything from poor usability to insidious bugs.</p>
<p>
Visual Basic has a mixed bag of window-management tricks, the simplest of which are <i>MsgBox </i>and <i>InputBox</i>. These are modal dialog boxes, so you must deal with them before the program will remove them and continue its processing. There isn’t much to say about <i>MsgBox </i>and <i>InputBox </i>except that they are inflexible. In particular, you can’t change the button captions, and you can’t control where on the screen the dialog boxes are displayed. For added flexibility, you can, of course, write your own Visual Basic functions named <i>MsgBox </i>and <i>InputBox </i>to override the Visual Basic ones. Interestingly, doing this allows you to make nonmodal message boxes, the consequences of which will become clear later.</p>
<p>
Visual Basic also has features to support multiple-document interface (MDI) applications, and the decision to build with MDI will have a major influence on the way your application works. MDI has some advantages—chiefly that it is well defined and that Visual Basic will implement some of the features for you (menu management, window arrangements, and so on). On the other hand, adopting MDI for these reasons alone is futile if the application you want to build doesn’t fit the rigid MDI model. MDI supports a document model and usually makes sense only if your application is going to work with multiple instances of things that are somehow document-like. Document-like qualities include serialization (binding to permanent storage) and size independence, which gives meaning to the familiar MDI window-arrangement functions Tile and Cascade.</p>
<p>
On the other side of the fence from MDI is single-document interface (SDI). Because Visual Basic has no specific functions to support SDI, however, a more accurate description would be “not MDI.” You have much more flexibility when building non-MDI applications, but you lose out on some of the free functionality such as window arrangement, child window menu handling, and Ctrl+Tab to switch between child windows. On the other hand, you have more control over your application’s appearance, and you can choose whether to make your child forms modal or modeless.</p>
<p>
Finally, you can build hybrid applications that borrow some features from MDI without using built-in functionality. You can, for example, create multiple instances of an ordinary form (forms behave just like classes in many ways), and you can even create MDI parent forms dynamically within a non-MDI application. It’s important to consider these issues in advance and to plan a window-management scheme appropriate to the application you want to build.</p>
<h1></h1>
</BODY>
</HTML>
