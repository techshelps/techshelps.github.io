<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>What Is OLE DB?</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="whatisoledb"></a>What Is OLE DB?</h1>
<p>
OLE DB is to diverse unstructured data what ODBC is to structured SQL-based databases. It is a unifying access method that provides a single route to accessing any data. So in a way similar to that used by ODBC, OLE DB employs a layered model. Thus diagrams of the two architectures might at first seem similar, as you can see in Figure 13-6 and Figure 13-7.</p>
<p>
<img src="f13rf06.gif" border=0></p>
<p class=blue>
<b>Figure 13-6  ODBC architecture</b></p>
<p>
<img src="f13rf07.gif" border=0></p>
<p class=blue>
<b>Figure 13-7  OLE DB architecture</b></p>
<p>
OLE DB is different in two important aspects, however. First, unlike ODBC, OLE DB is based on OLE technology rather than on a simple API approach. Second, also unlike ODBC, OLE DB is not constrained by requiring all data access and manipulation to be performed via SQL. The only criterion that OLE DB imposes is that the data returned by a command be in the form of a table. So provided that the result of a file system query can be represented by a table (which ultimately all data can be—that is, a table of just one row and one column), an application using OLE DB should be able to retrieve and display the data.</p>
<p>
Actually, I have cheated. There is a third major distinction between OLE DB and ODBC. OLE DB is heterogeneous in the same way that DAO builds added value onto ODBC by enabling the user to execute table joins between different data sources. For example, consider the following SQL code:</p>
<pre><code>SELECT  * 
FROM  employees, deptsales
WHERE employees.deptid = deptsales.deptid</code></pre>
<p>
In this example, the employees table could be in a SQL Server database containing information for a corporate human resources system, and the deptsales table could be a Microsoft FoxPro table maintained by the sales department.</p>
<p>
In a similar way, OLE DB enables data to be joined from vastly different types of data sources, as shown here:</p>
<pre><code>REPORT email_address
TO system_supervisor
USING email_sent, stored_attachments
WHERE email_sent.owner = stored_attachments.owner
    AND stored_attachments.size &gt; 10k</code></pre>
<p>
In this example, the email_sent table is exposed by an OLE DB object that can read an e-mail system, and the stored_attachments table is a table that represents a particular set of disk files. I have altered some of the keywords from their SQL equivalent to emphasize the fact that OLE DB is not SQL-based and commands can be syntactically quite different.</p>
<p>
One last point to remember is that because OLE DB uses the OLE Component Object Model (COM) infrastructure, OLE DB is perhaps the best choice for access to data in a COM environment.</p>
<h1></h1>
</BODY>
</HTML>
