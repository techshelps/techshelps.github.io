<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Addresses</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="addresses"></a>Addresses</h1>
<p>
Visual Basic 5 (with VBA) is also able to yield real pointers, or addresses. Three undocumented VBA methods—<i>VarPtr</i>, <i>ObjPtr</i>, and <i>StrPtr </i>(which are just three different VBA type library <i>Declare</i> statements pointing to the same entry point in the run-time DLL)—are used to create these pointers. You can turn an object into a pointer value using <i>l = ObjPtr(o)</i>, where <i>o</i> is the object whose address you want and <i>l</i> is a long integer in which the address of the object is put. Just resolving an object’s address doesn’t AddRef the object, however. You can pass this value around and get back to the object by memory copying <i>l</i> into some dummy object variable and then setting another object variable to this dummy (thus adding a reference to the underlying object):</p>
<pre><code>Call CopyMemory(oDummy, l, 4)
Set oThing = oDummy</code></pre>
<p>
<i>CopyMemory </i>should be defined like this:</p>
<pre><code>Private Declare Sub CopyMemory Lib “kernel32” Alias _
"RtlMoveMemory” (pDest As Any, pSource As Any, ByVal ByteLen As Long)</code></pre>
<p>
The really neat thing here is that setting <i>l</i> doesn’t add a reference to the object referenced by the argument of <i>ObjPtr</i>. Normally, when you set an object to point to another, the object to which you point it (attach it, really) has its reference count incremented, meaning that the object can’t be destroyed, because there are now two references to it. (This incrementing also happens if you pass the object as a parameter to a routine.) For an example of how this can hinder you, see the discussion of the linked list example on page 360.</p>
<p>
By using <i>VarPtr </i>(which yields the address of variables and user-defined types), <i>StrPtr</i> (which yields the address of strings), and <i>ObjPtr</i>, you can create very real and very powerful and complex data structures.</p>
<p>
Here’s the short piece of code I used to discover that <i>VarPtr, ObjPtr,</i> and <i>StrPtr</i> are all really pretty much the same thing (that is, the same function in a DLL):</p>
<pre><code>Private Sub Form<u>_</u>Load()

    ‘ VB code to dump or match up an external
    ‘ server method with a DLL entry point. Here it’s
    ‘ used to dump the methods of the “<u>_</u>HiddenModule”.

    ‘ Add a reference to ‘TypeLib Information’ (TLBINF32.DLL),
    ‘ which gives you TLI before running this code.

    Dim tTLInfo  As TypeLibInfo
    Dim tMemInfo As MemberInfo
    Dim sDLL     As String
    Dim sOrdinal As Integer

    Set tTLInfo = <u>_</u>
        TLI.TLIApplication.TypeLibInfoFromFile(“MSVBVM50.DLL”)

    For Each tMemInfo In <u>_</u>
        tTLInfo.TypeInfos.NamedItem(“_HiddenModule”).Members

        With tMemInfo
            tMemInfo.GetDllEntry sDLL, “", sOrdinal

            ‘ labDump is the label on the form where the
            ‘ output will be printed.
            labDump.Caption = labDump.Caption &amp; <u>_</u>
                    .Name &amp; <u>_</u>
                    “ is in “ &amp; <u>_</u>
                    sDLL &amp; <u>_</u>
                    “ at ordinal reference “ &amp; sOrdinal &amp; <u>_</u>
                    vbCrLf
        End With

    Next

End Sub</code></pre>
<p>
The code uses TLBINF32.DLL, which can interrogate type libraries (very handy). Here I’m dumping some information on all the methods of a module (in type library parlance) named _HiddenModule. You’ll see that this is the module that contains <i>VarPtr, ObjPtr,</i> and <i>StrPtr</i>, which you can discover using OLEVIEW.EXE to view MSVBVM50.DLL:</p>
<pre><code>module <u>_</u>HiddenModule {
        [entry(0x60000000), vararg, helpcontext(0x000f6c9d)]
        VARIANT <u>_</u>stdcall Array([in] SAFEARRAY(VARIANT)* ArgList);
        [entry(0x60000001), helpcontext(0x000f735f)]
        BSTR <u>_</u>stdcall <u>_</u>B<u>_</u>str<u>_</u>InputB(
                        [in] long Number, 
                        [in] short FileNumber);
        [entry(0x60000002), helpcontext(0x000f735f)]
        VARIANT _stdcall _B_var_InputB(
                        [in] long Number, 
                        [in] short FileNumber);
        [entry(0x60000003), helpcontext(0x000f735f)]
        BSTR _stdcall _B_str_Input(
                        [in] long Number, 
                        [in] short FileNumber);
        [entry(0x60000004), helpcontext(0x000f735f)]
        VARIANT _stdcall _B_var_Input(
                        [in] long Number, 
                        [in] short FileNumber);
        [entry(0x60000005), helpcontext(0x000f65a4)]
        void _stdcall Width(
                        [in] short FileNumber, 
                        [in] short Width);
        [entry(0x60000006), hidden]
        long _stdcall VarPtr([in] void* Ptr);
        [entry(0x60000007), hidden]
        long _stdcall StrPtr([in] BSTR Ptr);
        [entry(0x60000008), hidden]
        long _stdcall ObjPtr([in] IUnknown* Ptr);
    };</code></pre>
<p>
Or you can use OLE2VW32.EXE:</p>
<pre><code>‘===============================================================
‘ Type Info: _HiddenModule, TypeInfo Version 0.000
‘ GUID: {CF1C2C60-0D25-1069-9427-00DD0111BF30}
‘ LCID: 0X00000009
‘ TypeKind: module
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X00000000)
‘---------------------------------------------------------------

‘ Function: Array
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X000F6C9D)
‘
Declare Function Array (ParamArray ArgList As Variant) _
As Variant

‘ Function: _B_str_InputB
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X000F735F)
‘
Declare Function _B_str_InputB (ByVal Number As Long, _
ByVal FileNumber As Integer) As String

‘ Function: _B_var_InputB
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X000F735F)
‘
Declare Function _B_var_InputB (ByVal Number As Long, _
ByVal FileNumber As Integer) As Variant

‘ Function: _B_str_Input
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X000F735F)
‘
Declare Function _B_str_Input (ByVal Number As Long, _
ByVal FileNumber As Integer) As String

‘ Function: _B_var_Input
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X000F735F)
‘
Declare Function _B_var_Input (ByVal Number As Long, _
ByVal FileNumber As Integer) As Variant

 ‘ Function: Width
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X000F65A4)
‘
Declare Sub Width (ByVal FileNumber As Integer, _
ByVal Width As Integer)

‘ Function: VarPtr
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X00000000)
‘
Declare Function VarPtr (ByRef Ptr As Variant) As Long

‘ Function: StrPtr
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X00000000)
‘
Declare Function StrPtr (ByVal Ptr As String) As Long

‘ Function: ObjPtr
‘ Help: C:\WINDOWS\SYSTEM\VBA.HLP (Help ID: 0X00000000)
‘ Declare Function ObjPtr (ByVal Ptr As LPUNKNOWN) As Long</code></pre>
<p>
When you run the Visual Basic code beginning on page 364, you’ll see this output:</p>
<pre><code>Array           is in VBA5.DLL at ordinal reference 601
<u>_</u>B<b><u>_</u></b>str<u>_</u>InputB   is in VBA5.DLL at ordinal reference 566
_B_var_InputB   is in VBA5.DLL at ordinal reference 567
_B_str_Input    is in VBA5.DLL at ordinal reference 620
_B_var_Input    is in VBA5.DLL at ordinal reference 621
Width           is in VBA5.DLL at ordinal reference 565
VarPtr          is in VBA5.DLL at ordinal reference 644
StrPtr          is in VBA5.DLL at ordinal reference 644
ObjPtr          is in VBA5.DLL at ordinal reference 644</code></pre>
<p>
This output shows the method name together with the DLL and ordinal reference (into the DLL) that implements its functionality. If you use <i>DUMPBIN /EXPORTS</i> on MSVBVM50.DLL like this:</p>
<pre><code>dumpbin /exports msvbvm50.dll &gt; dump</code></pre>
<p>
and then examine the dump file, you’ll see that the routine at ordinal 644 is in fact <i>VarPtr.</i> In other words, <i>VarPtr, ObjPtr,</i> and <i>StrPtr</i> all do their stuff in the MSVBVM50.DLL routine <i>VarPtr</i>!</p>
<p>
Matching the code output to the dump, we see this:</p>
<pre><code>Method Name     DLL Routine Name
Array           rtcArray
_B_str_InputB   rtcInputCount
_B_var_InputB   rtcInputCountVar
_B_str_Input    rtcInputCharCount
_B_var_Input    rtcInputCharCountVar
Width           rtcFileWidth
VarPtr          VarPtr
StrPtr          VarPtr
ObjPtr          VarPtr</code></pre>
<p>
I haven’t explained what the other routines do—you can discover that for yourself.</p>
<h1></h1>
</BODY>
</HTML>
