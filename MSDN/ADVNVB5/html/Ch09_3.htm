<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How Does the Y2K Problem Affect Visual Basic?</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="howdoesy2kproblemaffectvisualbasic"></a>How Does the Y2K Problem Affect Visual Basic?</h1>
<p>
For a while now, people have assumed that mainframe/legacy programs and applications built using COBOL were the only areas likely to be affected by the Y2K problem. Let’s look at a bit of history to see why this assumption came about.</p>
<p>
During the 1960s and 1970s, data storage space was not inexpensive. In an effort to conserve space, the practice of storing dates without the century part became accepted. This resulted in dates being represented in formats such as DDMMYY, MMDDYY, and YYMMDD.</p>
<p>
At the time, developers understood the consequences of not storing the century part of a date; they just didn’t really believe that those COBOL programs would still be around by the year 2000. But the fact is that in many companies those thirty-year-old programs are still alive and kicking—even worse, in many cases they are the fundamental, central components for systems that have grown into enormous core business applications.</p>
<p>
It’s probably fair to say that only about 3 percent of the world’s business applications are written in Visual Basic, and thus it’s understandable that the main focus of Y2K attention is on COBOL and other such older, more widely used languages. However, this still leaves hundreds of thousands of Visual Basic applications that are critical to the functionality and survival of many companies. Ignoring the Y2K threat from Visual Basic applications on the basis of the fact that they make up only a fraction of potentially lethal languages is rather like putting a new application into production having tested only 95 percent of its functionality: “It should be OK; we’ve tested most of it.”</p>
<p>
Another popular myth is that applications written in Visual Basic and other modern programming languages are automatically Year 2000 compliant. This assumption is based on the fact that modern languages (including Visual Basic) have intrinsic date-handling functions and specific data types for dates that when used correctly will yield Year 2000–compliant results.</p>
<p>
On the face of it, it’s reasonable to assume that Visual Basic is a Y2K-friendly language. In all fairness to Microsoft, Visual Basic is very good at handling dates. The Microsoft TechNet document <i>How the Year 2000 Affects Microsoft Product Date Fields </i>has this to say on the subject:</p>
<p class=indent>
By design, Microsoft products support dates well into the next century. However, even with Microsoft products it is possible for applications to perform incorrectly if developers have not used built-in date formats and functions.</p>
<p>
So there you have it, the bottom line: Visual Basic applications will perform past the turn of the century as long as the applications have been coded with the date problem in mind. Unfortunately, the shortsightedness of the last couple of decades within the mainframe fraternity has spilled over into the PC systems of today. The symptoms of this shortsightedness are plain to see. Look around—how many PC systems can you find that accept a date from the user that includes the century part? Not many! A two-digit input date is often a user requirement simply to cut down on the number of keystrokes.</p>
<p>
In addition to the user input problem, other external interfaces to a Visual Basic application, such as the system clock, external databases, and command-line arguments, can provide incorrectly formatted dates that will not function correctly as of the year 2000. Let’s look at a simple example of how such interfaces could affect date processing.</p>
<p>
Consider the following scenario. In a Visual Basic 3 application, a user enters a date into a text box (<i>txtEndDate</i>). The entered date is used to calculate the number of days remaining until a loan expires and subsequently to calculate the total repayment amount for the loan based on a daily payment of five dollars. Assume that the current date is July 10, 1996. (To simplify the example, the code does not validate anything.) In addition to the text box, the application’s form contains a command button (<i>cmdCalculate</i>). The <i>cmdCalculate_Click </i>event looks like this:</p>
<pre><code>Dim lDaysRemaining As Long
Dim lTotalPayment  As Long

' Calculate the number of days between today and the end 
' date.
lDaysRemaining = DateDiff("d", Now, txtEndDate)

' Multiply the number of remaining days by five units to get 
' the total.
lTotalPayment = lDaysRemaining * 5

' Display the number of days remaining.
MsgBox "Days remaining until expiration: " &amp; lDaysRemaining

' Display the total amount to repay.
MsgBox "Total to pay: " &amp; lTotalPayment</code></pre>
<p>
Try running this program under Visual Basic 3. First of all, enter 1/1/2026 into the text box, and then click the command button. If the system date on your machine is July 10, 1996, you should see that the loan has 10,767 days to run and that you have a total of $53,835 to pay.</p>
<p>
If you enter 1/1/26 into the text box (that is, no century part), however, the number of days until the loan expires will be incorrectly calculated as -25,758 and the total repayment figure will be -$128,790.</p>
<p class=indent>
<span class=blue><b>Note</b></span>   This example is designed to run in version 3 of Visual Basic, not version 5. If you run this example in version 5, the days will be calculated correctly whether or not you enter the century. I don’t mean to imply, however, that all date processing will work in Visual Basic 5. For a more detailed discussion of the differences among versions of Visual Basic, refer to the section “The Technical Issues” later in this chapter.</p>
<p>
It goes without saying that this example is extremely simplified, and I would certainly hope that nobody ever writes code like this! However simplistic, though, this example does prove a significant point I raised earlier: yes, Visual Basic is Year 2000 compliant, but <i>only </i>when the programmer fully understands the techniques involved in processing dates.</p>
<p>
So in answer to the people presuming that the Y2K issue affects only mainframe and COBOL programs, I have this to say: The example just described is only the tip of the iceberg in terms of the possible nightmares Visual Basic applications could face if their developers ignore the potential for Y2K problems.</p>
<p>
In their publication <i>So You Think the Year 2000 Is Just a Mainframe Problem? </i>the Gartner research group has this to say:</p>
<p class=indent>
Many organizations with a comprehensive strategy for dealing with the date crisis in mainframe applications have forgotten the hundreds, perhaps thousands, of PC applications built by end users in business units. These applications represent the core technology for business decision making and often contain suspect dates. Further, these PC applications may well pass an invalid date to a previously corrected mainframe program and re-infect the application.</p>
<p class=indent>
These PC applications are a ticking time bomb, just waiting for the day a date calculation for a maturity date, a due date, a payment date, or the like extends beyond Jan. 1, 2000. Although the present time is 1996, enterprises do not have 3.5 years to fix this problem: Of those applications that users insist “will be rewritten before 2000,” a significant percentage contain dates that are forecasts in nature and thus extend into or beyond 2000. Enterprises must start now to deal with this impending crisis. They cannot afford to wait until all the mainframe and legacy applications are repaired and then tackle the other stuff.</p>
<p>
I guess the question you really need to ask yourself is, “Can I be 100 percent certain that every single line of code, throughout all my Visual Basic applications, in all my systems, will manipulate dates correctly?” As you are no doubt aware from your experience with application tests, it takes only a single line of code to bring a system to its knees. Are you prepared to take that gamble?</p>
<h1></h1>
</BODY>
</HTML>
