<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Swallowing a Rhinoceros Sideways</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="swallowingrhinocerossideways"></a>Swallowing a Rhinoceros Sideways</h1>
<p>
The stark truth is that there is no such thing as zero-defect software. The joke definition passed down from generation to generation (a generation in IS being maybe 18 months or so) expresses it nicely: “Zero defects [noun]: The result of shutting down a production line.” Most real-life programs contain at least a few bugs simply because writing bug-free code is so difficult. As one of my clients likes to remind me, if writing solid code were easy, everybody would be doing it. He also claims that writing flaky code is much easier—which might account for the large quantity of it generally available.</p>
<p>
Having said this, it is really part of every professional developer’s job to aim at writing bug-free code. Knowing that bugs are inevitable is no excuse for any attitude that allows them the slightest breathing space. It’s all in the approach. Professional programmers know that their code is going to contain bugs, so they bench-test it, run it through the debugger, and generally hammer it every way they can to catch the problems that they know are lurking in there somewhere. If you watch the average hacker at work, you’ll notice something interesting. As soon as said hacker is convinced that his program is working to his satisfaction, he stops working, leans back in his chair, shouts to his boss that he’s ready to perform a production release, and then heads for the soda machine. He’s happy that he has spent some considerable time trying to show that his program is correct. Now fast-forward this hacker a few years, to the point where he has become more cynical and learned much more about the art of programming; what do you see? After reaching the stage at which he used to quit, he promptly starts working again. This time, he’s trying something different—rather than prove his program is correct, he’s trying to prove that it’s incorrect.</p>
<p>
Perhaps one of the major differences between amateur and professional developers is that amateurs are satisfied to show that their programs appear to be bug-free, whereas professionals prefer to try showing that their programs still contain bugs. The amateurs mostly haven’t had enough experience to realize that when they believe their program is working correctly, they are perhaps just halfway through the development process. After they’ve done their best to prove a negative (that their code doesn’t have any bugs), they need to spend some time trying to show the opposite.</p>
<p>
<b>Some Final Thoughts</b> Find developers who are (a) intelligent, (b) knowledgeable, (c) willing to learn, and (d) good at delivering effective code. Find out whether they are also (e) aware that writing bug-free code is so difficult that they must do everything possible to prevent and detect bugs. Don’t hire them without this final magical factor. It’s true that (a) through (d) are all wonderful qualities, but they are meaningless without (e).</p>
<h1></h1>
</BODY>
</HTML>
