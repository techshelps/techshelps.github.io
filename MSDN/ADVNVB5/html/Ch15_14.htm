<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Introducing the progress form</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="introducingprogressform"></a>Introducing the progress form</h1>
<p>
The form we’ll write here, shown in Figure 15-6, is a generic progress form of the type you often see when installing software or performing some other lengthy process. This type of form serves two basic roles. First, by its presence, the form confirms that the requested process is under way, while giving the user the opportunity to abandon the process if necessary. Second, by constantly displaying the progress of a process, the form makes the process appear faster. With Visual Basic often wrongly accused of being slow, this subjective speed is an important consideration.</p>
<p>
<img src="f15rf06.gif" border=0></p>
<p class=blue>
<b>Figure 15-6  A generic progress form in action</b></p>
<p>
This example gives us a chance to explore all the different ways you can interact with a form as a component. The form will have properties and methods to enable you to modify the form’s appearance. Additionally, the form will be able to raise an event, showing that this ability is not limited to classes.</p>
<p>
When designing a form’s interface, you must make full use of property procedures to wrap your form’s properties. Although you can declare a form’s data as Public, by doing so you are exposing it to the harsh world outside your component—a world in which you have no control over the values that might be assigned to that component. A much safer approach is to wrap this data within <i>Property Get</i> and <i>Property Let</i> procedures, giving you a chance both to validate changes prior to processing them and to perform any processing you deem necessary when the property value is changed. If you don’t use property procedures, you miss the opportunity to do either of these tasks, and any performance gains you hope for will never appear because Visual Basic creates property procedures for all public data when it compiles your form anyway.</p>
<p>
It’s also a good policy to wrap the properties of any components or controls that you want to expose in property procedures. This wrapping gives you the same advantages as mentioned previously, plus the ability to change the internal implementation of these properties without affecting your interface. This ability can allow you to change the type of control used. For example, within the example progress form, we use the common Windows 95 progress bar control. By exposing properties of the form as property procedures, we would be able to use another control within the form or even draw the progress bar ourselves while maintaining the same external interface through our property procedures. All this prevents any changes to client code, a prerequisite of reusable components.</p>
<p>
The generic progress form uses this technique of wrapping properties in property procedures to expose properties of the controls contained within it. Among the properties exposed are the form caption, the progress caption, the maximum progress bar value, the current progress bar value, and the visibility of the Cancel command button. Although all of these properties can be reached directly, by accessing them through property procedures, we’re able to both validate new settings and perform other processing if necessary. This is illustrated by the <i>AllowCancel </i>and <i>ProgressBarValue </i>properties. The <i>AllowCancel </i>property controls not only the Visible state of the Cancel command button but also the height of the form, as shown in this code segment:</p>
<pre><code>Public Property Let AllowCancel (ByVal ibNewValue As Boolean)

    If ibNewValue = True Then
            cmdCancel.Visible = True
            Me.Height = 2150
        Else
            cmdCancel.Visible = False
            Me.Height = 1750
    End If

    Me.Refresh
End Property</code></pre>
<p>
The <i>ProgressBarValue </i>property validates a new value, avoiding an unwanted error that might occur if the value is set greater than the current maximum:</p>
<pre><code>Public Property Let ProgressBarValue(ByVal ilNewValue As Long)

    ' Ensure that the new progress bar value is not
    ' greater than the maximum value.
    If Abs(ilNewValue) &gt; Abs(gauProgress.Max) Then
        ilNewValue = gauProgress.Max
    End If

    gauProgress.Value = ilNewValue
    Me.Refresh

End Property</code></pre>
<p>
We need to give the form a <i>Display </i>method to show the form modelessly so that the client code continues once the form has been displayed. A modal form would halt execution of this code until the form was dismissed. Progress forms are usually displayed in a modal state because they’re needed while the program is busy. If we want our progress form to appear to be modal, we have to imitate this functionality by disabling all other forms in the application while this form is being displayed. The following code, when placed in the form’s <i>Display </i>method, does just this. After creating this method, all we have to do is put similar code in the form’s <i>Form_Unload</i> event to reenable those forms that were disabled, and we have an instant modal form.</p>
<pre><code>Public Sub Display(ByVal inCmdShow As Integer)
    Dim frmForm As Form

    ' If the form is to be displayed modally,
    ' imitate modal behavior by disabling all other forms.
    If inCmdShow = vbModal Then

        For Each frmForm In Forms
            If frmForm.Name &lt;&gt; Me.Name _
                    And frmForm.MDIChild = False Then
                frmForm.Enabled = False
            End If
        Next frmForm

    End If

    ' Show the form modelessly.
    Me.Show vbModeless
    Me.Refresh

End Sub</code></pre>
<p>
The final example piece of code that we need to look at within our progress form is the one that generates the QueryAbandon event. This event allows the client code to obtain user confirmation before abandoning what it’s doing. To have our form generate events, we must declare each event within the general declarations for the form as shown here:</p>
<pre><code>Public Event QueryAbandon(ByRef Cancel As Boolean)</code></pre>
<p>
This event is then triggered when the Cancel command button is pressed. By passing the <i>Cancel </i>Boolean value by reference, we give the event handling routine in the client the opportunity to change this value in order to work in the same way as the <i>Cancel </i>value within a form’s QueryUnload<i> </i>event. When we set <i>Cancel </i>to True, the event handling code can prevent the process from completing. When we leave <i>Cancel</i> as False, the progress form will continue to unload. The QueryAbandon event is raised as follows:</p>
<pre><code>Private Sub cmdCancel_Click()
    Dim bCancel As Boolean
    bCancel = False
    RaiseEvent QueryAbandon(bCancel)
    If bCancel = False Then Unload Me
End Sub</code></pre>
<p>
From this code, you can see how the argument of the QueryAbandon<i> </i>event controls whether or not the form is unloaded, depending on its value after the event has completed.</p>
<h1></h1>
</BODY>
</HTML>
