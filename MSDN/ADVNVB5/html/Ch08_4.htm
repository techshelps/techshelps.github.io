<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Generating Code</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css">
<META NAME="HREF" CONTENT="stylesheets/msdn_ie4.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="generatingcode"></a>Generating Code</h1>
<p>
You select the code generation model you want via the somewhat hidden dialog box shown in Figure 8-1. You get to this dialog box by clicking Options on the Make Project dialog box.</p>
<p>
<img src="f08rf01.gif" border=0></p>
<p class=blue>
<b>Figure 8-1  Visual Basic’s compiler options dialog boxes</b></p>
<p>
As you can see in Figure 8-1, some extra compilation options and advanced optimization choices become available when you select Compile To Native Code. I’ll discuss some of these options a little later.</p>
<p>
When you compile to native code, the Visual Basic 5 native code generator/compiler, C2.EXE, is run once for each code component in the project. For example, if a project has a form, Form1; a module, Module1; and a class, Class1; then C2.EXE is run once to compile each component. Each invocation’s options are the same depending on which you selected in the dialog box; that is, the options you select are used to compile the entire project. In case you’re interested, C2 runs as a multithreaded, Win32, 32-bit console process.</p>
<p>
Each time the native code compiler is run, a hidden process (described as 16-bit by the Windows 95 Task Manager) is started and the code generator/compiler, also run as a hidden process, is run attached to this process. (In Windows 95, this process is run from the file WINOA386.MOD, with a process description of “Non-Windows application component for 386 enhanced mode.” This file is not required if you’re running under Windows NT.) As each invocation of C2 terminates, the instance of WINOLDAP (the module name given to WINOA386.MOD) in which it was run is also terminated. You should now start to see why this process might be slower than selecting p-code generation (which is an internal process and doesn’t use C2). Here’s what the command-line arguments of a typical run look like (with no optimizations):</p>
<pre><code>C2 -il C:\WINDOWS\TEMP\VB819310 -f Form1 -W3 -Gy -G5 -Gs4096 -dos 
-Zl -FoC:\TEMP\Form1.OBJ -Qifdiv -ML -basic</code></pre>
<p>
These flags are explained in Table 8-1. Some of them are described in more detail here as well:
<ul type=disc>
<li>
<b>-il</b> This flag is undocumented, but “intermediate language” is a good guess for what “il” stands for. Files produced when this flag is set are &lt;Signature&gt;GL, SY, EX, IN, and DB. I have no idea what these files contain. In the command-line example in Table 8-1, the following files (long filenames shown) are generated temporarily while the application is being built:<br><br></li>
<ul>
<li>
VB819310GL<br><br></li>
<li>
VB819310SY<br><br></li>
<li>
VB819310EX<br><br></li>
<li>
VB819310IN<br><br></li>
<li>
VB819310DB<br><br></li>
</ul>
</ul>
<p class=blue>
<b>Table 8-1  Command-Line Flags for the C2 Compiler</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=254><b>Flag</b></td>
<td class=blue width=338><b>Explanation</b></td>
</tr>
<tr valign=top>
<td width=254>-il C:\WINDOWS\TEMP\VB819310</td>
<td width=338>Undocumented but also used for a C program; probably used to “name” intermediate language files</td>
</tr>
<tr valign=top>
<td width=254>-f Form1</td>
<td width=338>The input file to be compiled</td>
</tr>
<tr valign=top>
<td width=254>-W3</td>
<td width=338>Warning level 3</td>
</tr>
<tr valign=top>
<td width=254>-Gy</td>
<td width=338>Enables function-level linking</td>
</tr>
<tr valign=top>
<td width=254>-G5</td>
<td width=338>Optimize for Pentium</td>
</tr>
<tr valign=top>
<td width=254>-Gs4096</td>
<td width=338>Turn off stack probes</td>
</tr>
<tr valign=top>
<td width=254>-dos</td>
<td width=338>Undocumented but also used for a C program</td>
</tr>
<tr valign=top>
<td width=254>-Zl</td>
<td width=338>Removes default library name from OBJ file</td>
</tr>
<tr valign=top>
<td width=254>-FoC:\TEMP\Form1.OBJ</td>
<td width=338>Name of output file</td>
</tr>
<tr valign=top>
<td width=254>-Qifdiv</td>
<td width=338>Performs Pentium FDIV erratum fix</td>
</tr>
<tr valign=top>
<td width=254>-ML</td>
<td width=338>Creates a single-threaded executable file</td>
</tr>
<tr valign=top>
<td width=254>-basic</td>
<td width=338>Undocumented but appears to be a new flag for Visual Basic compilation</td>
</tr>
</table><br>
<ul type=disc>
<li>
<b>-G5</b> The option optimizes the generated code to favor the Pentium processor. Here’s what the Microsoft Developer Network (MSDN) says about the same Visual C++ 4.2 flag: “Use this option for programs meant only for the Pentium. Code created using the /G5 option does not perform as well on 80386- and 80486-based computers as code created using the /GB (Blend) option.” Interestingly, by default, the -G5 switch is always used—even when you compile on a 486 machine.<br><br></li>
<li>
<b>-Gs[<i>size</i>]</b> If a function requires more than <i>size</i> stack space for local variables, its stack probe is activated. A stack probe is a piece of code that checks whether the space required for passed parameters and local variables is available on the stack before any attempt to allocate the space is made. -Gs0 is the same as -Ge, turn stack probes on; -Gs4096 is the default.<br><br></li>
<li>
<b>-ML</b> This option places the library name LIBC.LIB in the object file so that the linker will use LIBC.LIB to resolve external symbols. This is the compiler’s default action. LIBC.LIB does not provide multithread support, by the way.</li>
</ul>
<p>
Don’t bother to scan your Visual Basic 5 documentation for information about these flags because you won’t find any—they are all undocumented. If you have a set of documentation for the Visual C++ compiler, however, you might be in luck. Why? Because it seems that C2 is taken from the Visual C++ compiler. In fact, you’ll soon see why I’m pretty sure that C2.EXE is the C2 from Visual C++. Nevertheless, the above interpretation of the flag meanings is mine alone. Microsoft doesn’t document how its C++ compiler works beyond describing CL.EXE (the front end to the C compiler).</p>
<p>
Visual Basic itself evidently provides the compiler’s first pass, unlike Visual C++ (in which in terms of compilers, CL.EXE is seemingly analogous to VB5.EXE), and the first pass (the parser and some of the optimizer) in C and C++ is apparently provided by C1.EXE (C) and C1XX.EXE (C++). C2.EXE appears to be in Visual Basic what it is in Visual C++—the code generator and optimizer (the part of it to do with generation).</p>
<p>
How do I know? First, the way C2.EXE is driven is similar to the way the “real” C2.EXE, supplied with the Visual C++ compiler, is driven. Here’s the input to the C2 component of Visual C++ 5 (directive/invocation provided by CL.EXE) for a simple one-file C application named TEST.C:</p>
<pre><code>MSC_CMD_FLAGS=-il C:\WINDOWS\TEMP\a54497 -f test.c -W 1 -G4 
-Gs4096 -dos -Fotest.obj -ML -Fdvc50.idb</code></pre>
<p>
I gathered this information using the same tool I used on Visual Basic 5’s C2. I’ll discuss the tool more fully a little later. For now, let’s forget the how and concentrate on the what.</p>
<p>
Can you see the similarities? (For a more detailed explanation of these flags, see MSDN or Visual C++ itself.)</p>
<p>
Second, I looked back on our prerelease Visual Basic 5 CDs and examined the evolution of this component, comparing what I found there with the C2.EXE file supplied with Microsoft’s Visual C++ 4.2 and 5 products. The results of my examination of the component’s version information are shown in Table 8-2.</p>
<p>
As you can see from Table 8-2, the C2.EXE file in the Visual Basic alpha release had the same description as that of the real thing in Visual C++—this was later changed. (On the alpha and beta 1 CDs, the file C23.ERR was also supplied. This file [also supplied with Visual C++ 4.2], which contains error message text as used by the C compiler, has been removed from the packing list for the release version of Visual Basic 5 and for Visual C++ 5.)</p>
<p>
Third, replacing the C2 of Visual C++ with that of Visual Basic 5 worked; that is, once I copied the file MSPDB41.DLL to the SharedIDE folder so that Visual </p>
<p class=blue>
<b>Table 8-2  The Evolution of the C2 Compiler</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=blue width=148><b>Application</b></td>
<td class=blue width=76><b>Compiler Version Number</b></td>
<td class=blue width=186><b>Compiler Description</b></td>
<td class=blue width=182><b>Compiler Product Name</b></td>
</tr>
<tr valign=top>
<td width=148>Visual C++ 4.2</td>
<td width=76>10.20</td>
<td width=186>Microsoft 32-Bit C/C++ Compiler 80x86 Back End</td>
<td width=182>Microsoft Visual C++</td>
</tr>
<tr valign=top>
<td width=148>Visual C++ 5</td>
<td width=76>11.00</td>
<td width=186>Microsoft 32-Bit C/C++ Compiler 80x86 Back End</td>
<td width=182>Microsoft 32-Bit C/C++ Optimizing Compiler</td>
</tr>
<tr valign=top>
<td width=148>Visual Basic 5, last alpha</td>
<td width=76>11.00</td>
<td width=186>Microsoft 32-Bit C/C++ Compiler 80x86 Back End</td>
<td width=182>Microsoft 32-Bit C/C++ Optimizing Compiler</td>
</tr>
<tr valign=top>
<td width=148>Visual Basic 5, betas, RC1*, and the marketing beta</td>
<td width=76>11.00</td>
<td width=186>Microsoft 32-Bit Visual Basic Compiler 80x86 Back End</td>
<td width=182>Microsoft 32-Bit Visual Basic Optimizing Compiler</td>
</tr>
<tr valign=top>
<td width=148>Visual Basic 5, release</td>
<td width=76>11.00</td>
<td width=186>Microsoft 32-Bit Visual Basic Compiler 80x86 Back End</td>
<td width=182>Microsoft 32-Bit Visual Basic Optimizing Compiler</td>
</tr>
</table><br>
<p class=mini>
*  RC1 stands for Release Candidate 1, the first version of the product that Microsoft believes is up to release standards. Depending on what comes back from the testers, this version might be the one that goes on sale.</p>
<p>
C++ 5 could find it, a step that is not necessary if you compile from a DOS box rather than from the Visual C++ IDE, I could build C applications (such as the application shown in Listing 8-2 beginning on page 336) using Visual Basic’s C2.EXE with Visual C++ 5. (You can also use Visual Basic 5’s C2 with Visual C++ 4.2.) The reverse process also worked; I was able to compile and run a program in Visual Basic 5 using the C2 from Visual C++ 5. (This scenario does <i>not</i> work with Visual C++ 4.2, however, probably because of the -basic flag.)</p>
<h1></h1>
</BODY>
</HTML>
