<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Doing it for real</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="doingitforreal"></a>Doing it for real</h1>
<p>
The comment stripper is a simple example, and the FSM it demonstrates doesn’t deal with window management. As a slightly more realistic example, let’s look at an implementation of the GUI from Figure 14-5 (shown on page 595). You’ll find the source for this program in CHAP14\fsm\realwrld\rlw.vbp. The FSM controls the hypothetical Function 1, and the FSM starts when that function is chosen from the Function menu. Other functions would be implemented with their own FSMs, which is straightforward because the FSM was built as a class. You’re not really implementing the whole program here, just the window-management parts; all the event routines are there, so adding the code to do the database actions would be painless.</p>
<p>
The second thing you’ll notice, right after you notice those bizarre event names, is that the nice, friendly action routine names have gone, replaced by the anonymous subroutines <i>a01</i> through <i>a44</i>. With 44 subroutines to code, the only sensible names are systematic ones—using the state and event names as before is just too unwieldy. In fact, the action names are irrelevant because their corresponding state/event combinations are much more useful identifiers. Here’s a portion of the FSM table definition:</p>
<pre><code>oPuFSM.TableEntry A__, A_Ok_____, EXI, AddressOf a01
oPuFSM.TableEntry A__, A_Cancel_, EXI, AddressOf a02
oPuFSM.TableEntry A__, A_Apply__, A__, AddressOf a03
oPuFSM.TableEntry A__, A_Details, AB_, AddressOf a04
oPuFSM.TableEntry A__, A_More___, AC_, AddressOf a05
oPuFSM.TableEntry A__, B_Ok_____, ERO
oPuFSM.TableEntry A__, B_Cancel_, ERO</code></pre>
<p>
The key description of this code is “systematic,” which is also why we’ve adopted such a strange convention for the state and event names. We’re fighting Visual Basic’s unreasonable layout restrictions by making the names the same length so that the list of <i>TableEntry </i>calls is readable. You can’t quite make a table layout as in the C code example earlier, but the result is an acceptable facsimile that is reasonably self-documenting.</p>
<p>
Notice that two pseudostates have been introduced for this example: EXI, which represents termination of the FSM, and ERO, which denotes an error condition. Neither of these conditions should be encountered by the FSM: EXI successor states are never reached because the action routines associated with their transitions halt the FSM, and ERO successor states can be derived only from illegal inputs. The FSM driver function (<i>oPuFSM.EvHandler</i>) traps these pseudostates and raises an <i>FSM_Error </i>event. This is the FSM equivalent of a <i>Debug.Assert</i> statement.</p>
<p>
The use of ERO states also permits you to omit coding for state transitions that will never happen. As well as modifying the driver to raise an error on illegal transitions, we’ve also modified the <i>TableEntry </i>method to make the action function optional. In this case, it saves 12 action functions and nicely distinguishes error conditions in the matrix. It’s tempting to omit these lines from the list, but you should avoid the temptation vigorously, because if you do so you can no longer tell whether you’ve covered all possible situations by simply counting the table entries.</p>
<p>
Another temptation is to factor code by reusing action routines—for example, <i>a01</i> and <i>a02</i> appear to be the same, as do <i>a12</i> and <i>a13</i>. However, discarding <i>a02 </i>and wiring up <i>a01 </i>in its place can be disastrous because it introduces a dependency that will cause problems if you later want to change the actions for either transition independently of the other. You could, of course, define a helper subroutine that’s called by both action routines. (<i>ConfirmDiscardEdits </i>is such a function.) Remember that a <i>system</i> is useful because it takes some of the intellectual load off managing complexity, and it goes without saying that circumventing the system—for whatever reason—stops it from being systematic.</p>
<p>
One final comment about this example is that it doesn’t include validation or confirmation states. Such states would amplify the complexity by adding a new state for each OK and Cancel event, along with 11 corresponding table entries (in this case). In real life, validation and confirmation are best handled by building a conditional mechanism into the FSM. This does <i>not</i> mean you should do such processing ad hoc, and control over the successor state should remain with the FSM driver function (<i>FSM.EvHandler</i>). This means you can’t use Visual Basic’s <i>Form_QueryUnload </i>or <i>Form_Unload </i>event to trigger validation or confirmation since a form unload must always succeed. (Canceling an unload from QueryUnload will cause havoc because the FSM thinks the form has been unloaded and now its state information is incorrect.)</p>
<p>
An acceptable way to implement both types of condition is to add an <i>abort transition</i> method to the FSM class:</p>
<pre><code>Public Sub AbortTransition()
    bPuTransitionAborted = True
End Sub</code></pre>
<p>
Now you can modify the FSM driver to check the bPuTransitionAborted flag before setting the successor state:</p>
<pre><code>Public Sub EvHandler
    §
    CallMe aatPiFSMTable(M_nCurrentState, wparam).pcbAction
    If Not bPuTransitionAborted Then
        nPiCurrentState = aatPiFSMTable(nPiCurrentState, _
                                        wparam).nNextState
    End If
    §
End Sub</code></pre>
<p>
This might be simple, but it adds considerable complexity to the action routines because you must be very careful about which forms you unload. More specifically, if you cancel a transition, you need to be sure that you don’t change anything that characterizes the current state. In this case, the states are defined entirely in terms of forms, so you need to ensure that the action routine has the same forms loaded when you leave that were loaded when you entered. For example, assuming you’re in state AB_ (forms A and B loaded), you need either to unload both forms or to leave them both loaded. The following code correctly describes the validation logic for an A_Ok event in this state:</p>
<pre><code>Public Sub a12()

    Dim bUnload As Boolean

    bUnload = True

    If frmDetails.My.Dirty Or frmSummary.My.Dirty Then
        If Not bConfirmDiscardEdits Then
            bUnload = False
        End If
    End If
        
    If bUnload Then
        Unload frmDetails
        Unload frmSummary
    Else
        oPuFSM.CancelTransition
    End If
    
End Sub</code></pre>
<h1></h1>
</BODY>
</HTML>
