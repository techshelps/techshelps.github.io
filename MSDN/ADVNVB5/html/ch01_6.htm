<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tip 5: Have an error handler in every routine.</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="tip5haveerrorhandlerineveryroutine."></a>Tip 5: Have an error handler in every routine.</h1>
<p>
Because Visual Basic nests routines into local address space, all errors happen locally. An unhandled error in some routine that might be handled above that routine, in another error handler, should be considered unhandled because it will probably destabilize the application.</p>
<p>
Let’s go over that again, but more slowly. Visual Basic handles local errors. By this, I mean that whenever an error handler is called it always thinks it’s acting upon an error produced locally within the routine the error handler is in. (Indeed, a bit of obscure and normally unused—because it’s implied—syntax, <i>On </i>Local <i>Error GoTo</i>, gives this little secret away.) So if we write some functions named <i>SubA</i>, <i>SubB</i>, and <i>SubC </i>and arrange for <i>SubA </i>to call <i>SubB </i>and <i>SubB</i> in turn to call <i>SubC</i>, we can spot the potential problem. (See Figure 1-3 on the next page.) If <i>SubC</i> generates an error, who handles it? Well, it all depends. If <i>we</i> don’t handle it, Visual Basic will. Visual Basic looks up <i>Err.Number</i> in its list of error strings, produces a message box with the string, and then executes an <i>End</i> for you. If, as in Figure 1-3, <i>SubA</i> handles errors, Visual Basic will search up through the call chain until it finds <i>SubA</i> (and its error handler) and use that error handler instead of its own default error handler. Our error handler in <i>SubA</i>, however, now <i>thinks</i> that the error happened locally to it; that is, any <i>Resume</i> clause we might ultimately execute in the error handler works entirely within the local <i>SubA</i> routine.</p>
<p>
Your code always runs in the context of some event handler; that is, any entry point into your code must ultimately be in the form of an event handler. So substituting <i>SubA</i> for, say, <i>Form_Load</i>, you could now write a catchall error handler by providing an error handler in <i>Form_Load</i>. Now, when <i>SubC</i> generates its error (I’m assuming here that these functions are only ever called from <i>Form_Load</i>), Visual Basic will find the local error handler in <i>Form_Load </i>and execute it. Ultimately, this error handler will execute a <i>Resume </i>statement. For argument’s sake, let’s say that it’s <i>Resume Next</i>.</p>
<p>
<img src="f01rf03.gif" border=0></p>
<p class=blue>
<b>Figure 1-3  The call chain in action </b></p>
<p>
The <i>Next</i> here means after the call to <i>SubB</i>. OK, so what’s the problem? If a problem exists, it’s buried inside <i>SubB </i>and <i>SubC</i>—we don’t know what they did! Imagine this scenario. Maybe <i>SubC</i> opened some files or perhaps a database or two, and somewhere within <i>SubC</i>, it was also going to close them. What happens if the erroring code happened somewhere in between these two things—say, the files/databases got opened but were never closed? Again it depends, but loosely speaking, it means trouble.</p>
<p class=indent>
<span class=blue><b>Note</b></span>  The situation described above could be worse, however. Maybe instead of <i>Resume Next </i>we simply used <i>Resume</i>, that is, try again. This will result in an attempt to open the same files again; and as we all know, this attempt may fail for many reasons—perhaps instead of using <i>FreeFile</i>,<i> </i>you used hard-coded file handle IDs, or maybe you opened the files last time with exclusive access.</p>
<p>
Unfortunately, when Visual Basic fires an error handler, there’s no easy way of telling whether the error handler was really local to the error. So there’s no way to guarantee that you handled it properly. And of course, there’s no way to install a global error handler that’s called automatically by Visual Basic whenever an error occurs. There’s no way around it: to write professional and robust applications, we must have error handlers <i>absolutely everywhere!</i></p>
<h1></h1>
</BODY>
</HTML>
