<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tip 11: Replace useful intrinsic objects with your own.</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="tip11replaceusefulintrinsicobjectswithyourown."></a>Tip 11: Replace useful intrinsic objects with your own.</h1>
<p>
Our main ROOS contains a set of alternative standard object classes, <i>TMSErr </i>and <i>TMSApp</i>, for example. These are instantiated as <i>Err</i> and <i>App</i> at application start-up as part of our application template initialization. (All our Visual Basic applications are built on this template.) By creating objects like this, we can add methods, properties, and so on to what looks like one of Visual Basic’s own objects.</p>
<p>
For example, our error object has extra methods named <i>Push</i> and <i>Pop</i>. These, mostly for historical reasons, are <i>really</i> useful methods because it’s not clear in Visual Basic 4 when <i>Err.Clear </i>is actually applied to the <i>Err </i>object—that is, when the outstanding error, which you’ve been called to handle, is automatically cleared. This can easily result in the reporting of error 0. Watch out for this because you’ll see it a lot!</p>
<p>
Usually, an error is mistakenly cleared in this way when someone is handling an error and from within the error handler he or she calls some other routine that causes Visual Basic to execute an <i>Err.Clear</i>. All sorts of things can make Visual Basic execute an <i>Err.Clear</i>. The result in this case is that the error is lost! These kinds of mistakes are really hard to find. They’re also really easy to put in—lines of code that cause this to happen, that is!</p>
<p>
The Visual Basic 4 Help file under Err Object includes this Caution about losing the error context. (Note the “may be” here.)</p>
<p class=indent>
If you set up an error handler using On Error GoTo and that handler calls <i>another</i> procedure, the properties of the Err object may be reset to zero and zero-length strings. To retain values for later use, assign the values of Err properties to variables before calling another procedure, or before executing Resume, On Error, Exit Sub, Exit Function, or Exit Property statements.</p>
<p>
Actually, this problem never seemed to be the case in Visual Basic 4. Regardless, the good news is that Visual Basic 5 seems to have fixed this problem. Now <i>Err.Number</i> stays put. How do we know for sure? Because the Visual Basic 5 Help (again under Err Object) now just says this:</p>
<p class=indent>
The Err object’s properties are reset to zero or zero-length strings ("") after any form of the Resume or On Error statement and after an Exit Sub, Exit Function, or Exit Property statement within an error-handling routine. The Clear method can be used to explicitly reset Err.</p>
<p>
Two things warrant mentioning, however. Keep in mind that if <i>Err.Number</i> is set to a nonzero value when you call another routine, it will stay set as that routine’s code is executed (as long as you don’t specifically reset it). Testing <i>Err.Number</i> in a routine doesn’t mean, unless you’ve previously reset it, that the error occurred in the executing routine. Also, if you’re mixing Visual Basic 4 and Visual Basic 5, remember that this behavior is apparently not consistent between the two environments—although as I’ve said, I’ve never witnessed anything different in Visual Basic 4.</p>
<p>
Of course, if you do reset <i>Err.Number</i> (perhaps by using <i>On Error GoTo</i> in the called routine), when you return to the calling routine the error will be lost. The answer, of course, is to preserve, or push, the error context to some kind of error stack. We do this with <i>Err.Push</i>. It’s the first line of code in the error handler—<i>always</i>. (By the way, Visual Basic won’t do an <i>Err.Clear </i>on the call to <i>Err.Push</i> but only on its return—guaranteed.) Here’s an example of how this push and pop method of error handling looks in practice:</p>
<pre><code>Private Sub Command1_Click()

    On Error GoTo error_handler:

    VBA.Err.Raise 42

    Exit Sub

error_handler:

    Err.Push
    Call SomeFunc
    Err.Pop
    MsgBox Err.Description
    Resume Next

End Sub</code></pre>
<p>
Here we’re raising an error (42, as it happens) and handling it in our error handler just below. The message box reports the error correctly as being an Application Defined Error. If we were to comment out the <i>Err.Push </i>and <i>Err.Pop </i>routines and rerun the code, the error information would be lost and the message box would be empty (as <i>Err.Number </i>and <i>Err.Description </i>have been reset to some suitable “nothing”), assuming the call to <i>SomeFunc </i>completes successfully. In other words, when we come to show the message box, there’s no outstanding error to report! (The call to <i>Err.Push </i>is the first statement in the error handler. This is easy to check for during a code review.)</p>
<p class=indent>
<span class=blue><b>Note</b></span>  If we assume that Visual Basic itself raises exceptions by calling <i>Err.Raise </i>and that <i>Err.Raise </i>simply sets other properties of <i>Err</i>, such as <i>Err.Number</i>, our own <i>Err.Number </i>obviously won’t be called to set <i>VBA.Err </i>properties (as it would if we simply had a line of code that read, say, <i>Err.Number = 42</i>). This is a pity because if it did call our <i>Err.Number</i>, we could detect (what with our <i>Err.Number </i>being called first before any other routines) that an error was being raised and automatically look after preserving the error context; that is, we could do an <i>Err.Push </i>automatically without having to have it appear in each error handler.</p>
<p>
Of course, the implementation of this new error object is not important (and should be kept hidden). Needless to say, the implementation is easy. (TMS uses another Visual Basic collection and a <i>CErrorStack </i>wrapper.) Another Visual Basic object we replace with our own is the <i>Debug </i>object. We do this because we sometimes want to see what debug messages a built executable might be emitting.</p>
<p>
As you know, “normal” <i>Debug.Print </i>calls are thrown away by Visual Basic (when your application is running as a binary executable); “special” <i>Debug.Print </i>calls, however, can be captured even when the application is running as binary. Replacing this object is a little trickier than replacing the <i>Err</i> object because the <i>Debug</i> object name cannot be overloaded; that is, you have to call your new object something like <i>Debugger</i>. This new object can be designed to write to Visual Basic’s debug window so that it becomes a complete replacement for the <i>Debug </i>object. Chapter 7 shows you how to write your own <i>Assert </i>method so that you can also replace the <i>Debug </i>object’s <i>Assert </i>method.</p>
<h1></h1>
</BODY>
</HTML>
