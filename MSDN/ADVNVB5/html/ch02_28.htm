<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Procurators or Process Managers</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="procuratorsorprocessmanagers"></a>Procurators or Process Managers</h1>
<p>
An extension of the pool manager with in-process servers (essentially OLE or ActiveX DLLs) plugged into it is an out-of-process procurator or process manager component that can have in-process components attached to it. (See Figure 2-21.)</p>
<p>
<img src="f02rf21.gif" border=0></p>
<p class=blue>
<b>Figure 2-21  A tiered architecture with procurators or process managers </b></p>
<p>
This object, or more realistically these objects, can be pool managed in their turn. If they were not, the procurators would go back into a one-to-one relationship with their clients (but might have references to all the other objects of the system) and would be able to create them from in-process calls to the DLLs that would supply them. The advantage over a pool manager managing multiple instances of SingleUse creatable business objects is that the number of individual processes—assuming you have more than one business object type—is smaller and thus requires less memory to run. If you have a lot of components, your system will probably be a little easier to manage too. Certainly, performance will be enhanced, especially if you are genuinely tiering, by which I mean that your objects are talking to each other in your tiers rather than just talking between tiers (since all within-a-tier calls are going to be in process).</p>
<p>
However, the procurator must know about all the components of the system and how to make them work. If a new component were added, the procurator process might well have to be recompiled. The procurator has the benefit of moving a lot of the management of the system from the client to the server, which makes for a thinner client—not to be sneezed at when the days of intranet applications are upon us. The procurator process can also be used to hold state information for the client, especially where a number of separate server processes have to work cooperatively on the same object.</p>
<p class=blue>
<b>In-Process Components and Threading</b></p>
<p class=blue>
<b>MultiUse, Multithreaded Server with Single-Threaded DLL</b></p>
<p class=indent>
As you can see in Figure 2-22, in a MultiUse, multithreaded server with a single-threaded DLL, multiple clients get top-level objects created by the same running instance of the server. Each top-level object gets its own thread and copy of global data. Objects created in an in-process component are created on one of the server’s threads.</p>
<p>
<img src="f02rf22.gif" border=0></p>
<p class=blue>
<b>Figure 2-22  An out-of-process, MultiUse, multithreaded server using a single-threaded DLL</b></p>
<p class=blue>
<b>MultiUse, Multithreaded Server with Multithreaded DLL</b></p>
<p>
In Figure 2-23, you’ll see an example of a MultiUse, multithreaded server with a multithreaded DLL. Multiple clients get top-level objects created by the same running instance of the server. Each top-level object gets its own thread and copy of global data. Objects created in an in-process component are created on the thread of their top-level creator.</p>
<p>
<img src="f02rf23.gif" border=0></p>
<p class=blue>
<b>Figure 2-23  An out-of-process, MultiUse, multithreaded server using a multithreaded DLL</b></p>
<h1></h1>
</BODY>
</HTML>
