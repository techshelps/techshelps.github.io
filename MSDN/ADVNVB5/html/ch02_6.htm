<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Scalability, or my daddy was a mainframe</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="scalabilityormydaddywasmainframe"></a>Scalability, or my daddy was a mainframe</h1>
<p>
Another justification you run into for business object building is the supposed central benefit of the three-tiered or <i>n</i>-tiered architecture. In essence, this architecture is a combination of manageability and scalability. Many people working with a range of software tools have found the problem of scalability a tough nut to crack. The hang-up is that as the numbers of users, or the size of the data being transferred and manipulated, or the transaction rate, or all of them increase, the system begins to creak, crack, and fall apart—the problem of crumbleware.</p>
<p>
Visual Basic (until version 4 Enterprise Edition) was frequently the butt of scalability criticism and might even have been the origin of the term “fat client.” Actually, if you do still build these “fat clients,” the phrase “rich client” might come in useful. Lots of big-time consulting organizations would flame Visual Basic regularly, and yet people still used it. Here are three possible explanations:
<ul type=disc>
<li>
<b>The Samuel Beckett one:</b> People are bloody stupid apes.<br><br></li>
<li>
<b>The Conspiracy theory:</b> The developers want to put you off the scent.<br><br></li>
<li>
<b>The True explanation:</b> Writing good programs in Visual Basic is hard work that needs thought and commitment, and these qualities are not combined that often.</li>
</ul>
<p>
Do you remember the pre–Visual Basic days, when dinosaurs roamed the earth and digital watches seemed like a pretty neat idea? You would be put in charge of a project that had the goal of either getting each instance of the client application to do more work or getting more users working with the system. The idea was to get more out of the software. The PC that the client software (written in Visual Basic) was running on had finite resources. Visual Basic (even as far as version 4) was an interpreted rather than a compiled language. So you would recommend upgrading the client PCs, optimizing the client code, or moving some or all of the significant work elsewhere.</p>
<p>
But none of these solutions is ideal, especially in a big corporate environment. You have 300 users of your software; you want to do another release. Just upgrading them all is hard enough anyway, but we’ll come to manageability problems in a while. Your release is going to add significant new functionality, consume substantial resources, and demand prohibitively expensive hardware upgrades. Your budget for the upgrade project is rejected. You go back to the spreadsheets. Sadly, you don’t know about the Visual Basic Code Profiler (you should, but you don’t), so you take off the hardware budget for the upgrade and put in a new row for optimization work costs. Finger in the air stuff. You know that optimization is one of the unquantifiables. If only you knew about Visual Basic Code Profiler (VBCP). (VBCP is available on the Visual Basic 4 CD in the folder Tools\VBCP. On the Visual Basic 5 CD, it’s in the folder UNSUPPRT\VBCP.) You don’t, so you only know how much you want to improve the application’s performance. You don’t know where the application is spending all its time, and you certainly don’t know how to prove how much effort and cost you’re going to expend to get the performance you want—if you ever do get it. So you put down a big figure, because you’re realistic. Then you shave it a bit, because you’re hopeful (a natural concomitant of developing software) and because you want to get your project into the feasibility stage. Your budget is rejected again, either because it’s still too high or because you shaved off too much and management knew enough to know it and were morally honest enough to care.</p>
<p>
How about moving the work to be done somewhere other than the client PC? You have a development shop of Visual Basic coders. Right now you have an architecture that has two tiers (by which I mean client talking directly to database server, as illustrated in Figure 2-1), and you have two types of machine, client PCs for the users and a big database server or a mainframe that you talk to for data.</p>
<p>
<img src="f02rf01.gif" border=0></p>
<p class=blue>
<b>Figure 2-1  A two-tier (“fat client”) application </b></p>
<p>
In order to upgrade, suddenly you’re looking at new hardware and new skills, perhaps new people, and a complete redesign of the application. You’ve also just received an e-mail message from your manager saying that the other business areas love the prototypes you did and marketing now wants to launch a new product that needs the functionality. And it all has to be completed two months earlier than your original ballpark estimates projected.</p>
<p>
This is the point at which a sane person would start looking for a lateral move into the business strategy unit where he or she could write white papers that no one would ever read and certainly never implement, at least until the optimal strategy had already changed. A bleak scenario? Possibly. Real? I think so.</p>
<h1></h1>
</BODY>
</HTML>
