<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Windows API</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="windowsapi"></a>Windows API</h1>
<p>
The world of Windows has changed. Under 32-bit Windows NT and Windows 95, the machine registers are 32-bit. The system therefore deals mostly with 32-bit data. Most API calls return a 32-bit value, which Visual Basic considers to be a long. Under Windows 3.<i>x</i>, these registers are 16-bit and API calls return 16-bit values. Visual Basic considers these integers. Most code will return longs into integer variables if the code is imported straight into Visual Basic 4 or 5. This can be rectified by changing the variable type. If the code base is to be used under 16-bit Visual Basic 4 and Visual Basic 5, use conditional compilation constants.</p>
<pre><code>#IF WIN16 THEN
    Dim intRet As Integer
#ELSE
    Dim lngRet As Long
#ENDIF

    ' Version-independent code here

#IF WIN16 THEN
    intRet = SendMessage( ... )
#ELSE
    lngRet = SendMessage( ... )
#ENDIF</code></pre>
<p>
Alternatively, you can just use a long under both versions, though this is less elegant and slightly less efficient. If the syntax for the API call is the same under both Win16 and Win32, however, the code will be significantly simpler.</p>
<p>
Furthermore, the 32-bit Windows API is case-sensitive, whereas the 16-bit API is not. You can use aliasing to get around this, as shown here:</p>
<pre><code>Declare Function WinGetVersion Lib "kernel32" Alias "GetVersion" () As Long</code></pre>
<p>
With this declaration, if <i>WinGetVersion</i> is inadvertently changed to <i>WinGETVersion</i>, the program will still compile. Without the aliasing <i>GETVersion</i>, it would produce the error message shown in Figure 6-3.</p>
<p>
<img src="f06rf03.gif" border=0></p>
<p class=blue>
<b>Figure 6-3  The error message produced when a DLL call is capitalized </b></p>
<p>
The Crescent division of Progress Software supplies an excellent program, Migrate, which replaces most 16-bit Windows API declarations with 32-bit Windows API declarations. It could only be improved by adding conditional compilation code. Fortunately, Progress Software ships the declarations with its replacements in a Microsoft Access database, and the new Visual Basic 5 Add-In structure lets you write a simple add-in that allows this change. Use the basic add-in framework that forms the Visual Basic IDE sample, and add something like the code on the following page to the part of the program that does the work.</p>
<p class=blue>
<b>Advanced Microsoft Visual Basic 5</b></p>
<pre><code>Dim Proj             As VBProject
Dim VBComp           As VBComponent
Dim VBCode           As CodeModule
Dim lCount           As Long
Dim lOffset          As Long
Dim sLine            As String
Dim sReplacementLine As String
Dim sAPIName         As String
Dim nDeclareStart    As Integer
Dim nAPINameStart    As Integer
Dim nAPINameLength   As Integer
Dim dbAPIs           As Database
Dim snpAPIs          As Recordset
Set dbAPIs = OpenDatabase("G:\Was on VB5\Migrate\Upwizard.MDB")
                          ' Or wherever your database is located
Set snpAPIs = dbAPIs.OpenRecordset("Win32Decl", dbOpenSnapshot)
Set Proj = VBInstance.ActiveVBProject
With Proj
    For Each VBComp In .VBComponents
        If VBComp.CodeModule.Find("Declare", 0, 0, _
            VBComp.CodeModule.CountOfLines, 255) = True Then
            Set VBCode = VBComp.CodeModule
            For lCount = 1 To VBCode.CountOfDeclarationLines
                nDeclareStart = InStr(VBCode.Lines(lCount + _
                    lOffset, 1), "Declare")
                If nDeclareStart &gt; 0 Then
                    ' Replace code here.
                    sLine = VBCode.Lines(lCount + lOffset, 1)
                    nAPINameStart = InStr(nDeclareStart + _
                        Len("Declare "), sLine, " ")
                    nAPINameLength = InStr(nAPINameStart + _
                        1, sLine, " ") - nAPINameStart
                    sAPIName = Mid$(sLine, nAPINameStart + _
                        1, nAPINameLength - 1)
                    snpAPIs.FindFirst "Name like '" &amp; _
                        sAPIName &amp; "'"
                    If snpAPIs.NoMatch Then
                        sReplacementLine = "#IF WIN16 THEN" _
                            &amp; vbCrLf &amp; vbTab &amp; sLine &amp; _
                            vbCrLf &amp; "#ELSE" &amp; vbCrLf &amp; _
                            vbTab &amp; _
                            "' TODO - 32-bit eqv API needed" &amp; _
                            vbCrLf &amp; "#ENDIF" &amp; vbCrLf
                    Else
                        sReplacementLine = "#IF WIN16 THEN" &amp; _
                            vbCrLf &amp; vbTab &amp; sLine &amp; vbCrLf &amp; _
                            "#ELSE" &amp; vbCrLf &amp; vbTab &amp; _
                            snpAPIs!FullName &amp; vbCrLf &amp; _
                            "#ENDIF" &amp; vbCrLf
                    End If
                    Call VBCode.ReplaceLine(lCount + lOffset, _
                        sReplacementLine)
                    lOffset = lOffset + 5
                End If
            Next lCount
        End If
    Next VBComp
End With
snpAPIs.Close
dbAPIs.Close</code></pre>
<p class=indent>
<span class=blue><b>Note</b></span>  A modified version of the Visual Basic 5 Sample Add-In program is included in the samples for this chapter on the companion CD to illustrate this point. It is saved as the project MyAddIn.Vbp and contains the code described in the following text. The sample can be easily modified to do other tasks, such as inserting default error handlers. Run this add-in against the Visual Basic 3 CALLDLLS.MAK sample to see what it does.</p>
<p>
It’s worth remembering that many Windows API calls haven’t changed apart from the library in which they are now declared. One easy way to incorporate library name changes is to use a type library for the Windows API. Then the type library can be changed as you move from 32-bit to 16-bit without any need to change code. Such a Windows API type library comes with Bruce McKinney’s excellent <i>Hardcore Visual Basic</i> (Microsoft Press, 1995). You can obtain updates for all the <i>Hardcore Visual Basic</i> programs from the Microsoft Press Web site at <i>mspress.microsoft.com/mspress/brucem/hardcore.htm</i>.</p>
<p>
For the curious, the Microsoft Knowledge Base article Q137095, “How to Provide Constants for Use with an OLE Server” (<i>www.microsoft.com/Kb</i>), explains how type libraries are created.</p>
<h1></h1>
</BODY>
</HTML>
