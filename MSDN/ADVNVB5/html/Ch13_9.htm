<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DAO and Jet</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="daojet"></a>DAO and Jet</h1>
<p>
In Figure 13-1, you can see that Jet and DAO are intimately linked. They are not the same thing, however. Jet is a distinct component, even though only DAO and Microsoft Access know how to use it directly. Therefore, it’s not possible to use Jet directly. DAO exists primarily as an access method to Jet. However, as you will see, DAO is able to turn off some of Jet’s functionality when using an ODBC data source. This can sometimes have a significant effect on performance. Once again there is a trade-off, however, in performance vs. functionality.</p>
<p>
Jet is driven by SQL, and the dialect of SQL that Jet speaks is different from the dialect used by other implementations. This fact has both benefits and drawbacks. When using DAO (and hence, Jet), it’s worth learning these differences because they can have a dramatic impact on performance. For example, in many database management systems (such as SQL Server), a join between two tables doesn’t have to be explicitly declared. SQL Server will interpret the following SQL statement as an inner join and optimize database access accordingly:</p>
<pre><code>SELECT * 
FROM Employee, Dept
WHERE Employee.Dept_Id = Dept.Dept_Id</code></pre>
<p>
This same statement, when used via DAO and Jet, can have a completely different outcome. Rather than use the Dept_Id field to read the unique index in the Dept table, Jet will simply perform a cartesian join (that is, match each Employee record with all Dept records) and then throw away those that fail the criteria specified in the WHERE clause. This means that the number of records read is Count(Employee) * Count(Dept) (read every Dept record for each Employee record) rather than Count(Employee) * 2 (read one Dept record for each Employee record). If these were large tables, the difference in the elapsed time to execute the query could be dramatic.</p>
<p>
But it’s not all bad news. Jet SQL also has some useful features. Perhaps the feature most widely used is its ability to perform cross-tab queries. For example, suppose you have a query that produces a list of sales by product and month. The output of such a query might look like this:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=197><b>Product</b></td>
<td class=blue width=197><b>Period</b></td>
<td class=blue width=197><b>Sum of Sales</b></td>
</tr>
<tr valign=top>
<td width=197>Tea</td>
<td width=197>Jan</td>
<td width=197>100</td>
</tr>
<tr valign=top>
<td width=197>Coffee</td>
<td width=197>Jan</td>
<td width=197>1200</td>
</tr>
<tr valign=top>
<td width=197>Orange juice</td>
<td width=197>Feb</td>
<td width=197>550</td>
</tr>
<tr valign=top>
<td width=197>Tea</td>
<td width=197>Feb</td>
<td width=197>90</td>
</tr>
<tr valign=top>
<td width=197>Coffee</td>
<td width=197>Feb</td>
<td width=197>1300</td>
</tr>
<tr valign=top>
<td width=197>Orange juice</td>
<td width=197>Mar</td>
<td width=197>475</td>
</tr>
<tr valign=top>
<td width=197>Tea</td>
<td width=197>Mar</td>
<td width=197>75</td>
</tr>
<tr valign=top>
<td width=197>Coffee</td>
<td width=197>Mar</td>
<td width=197>1150</td>
</tr>
<tr valign=top>
<td width=197>Orange juice</td>
<td width=197>Jan</td>
<td width=197>500</td>
</tr>
</table><br>
<p>
Although this is fine as far as it goes, it would be much nicer to see the query output in this format:</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows>
<tr valign=top>
<td class=blue width=148><b>Product</b></td>
<td class=blue width=148><b>Jan</b></td>
<td class=blue width=148><b>Feb</b></td>
<td class=blue width=148><b>Mar</b></td>
</tr>
<tr valign=top>
<td width=148>Coffee</td>
<td width=148>1200</td>
<td width=148>1300</td>
<td width=148>1150</td>
</tr>
<tr valign=top>
<td width=148>Orange juice</td>
<td width=148>500</td>
<td width=148>550</td>
<td width=148>475</td>
</tr>
<tr valign=top>
<td width=148>Tea</td>
<td width=148>100</td>
<td width=148>90</td>
<td width=148>75</td>
</tr>
</table><br>
<p>
A cross-tab query is able to do exactly this kind of transposition, turning the values of a column in an ordinary select query into column headings in a cross-tab query.</p>
<h1></h1>
</BODY>
</HTML>
