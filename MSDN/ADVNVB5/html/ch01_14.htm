<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tip 13: Use Microsoft's MSINFO32.EXE when you can.</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="tip13usemicrosoftsmsinfo32.exewhenyoucan."></a>Tip 13: Use Microsoft’s MSINFO32.EXE when you can.</h1>
<p>
When you’re trying to help a user with some problem (especially if you’re in Support), you often need to know a lot of technical stuff about the user’s machine, such as what is loaded into memory or how the operating system is configured. Getting this information out of the user, even figuring out where to find it all in the first place, can be extremely time-consuming and difficult. (Asking the user to continually hit Ctrl+Alt+Delete in an attempt to bring up the Task List and “see” what’s running can be a dangerous practice: <i>User: “</i>Oh, my machine’s rebooting.” <i>Support:</i> “What did you do?” <i>User: “</i>What you told me to do—hit Ctrl+Alt+Delete again!”) Microsoft thought so too, so they provided their users with an application to gather this information automatically: MSINFO32.EXE (MS Info). The good news is that you can use this application to help your customers.</p>
<p>
MS Info comes with applications such as Microsoft Word and Microsoft Excel. If you have one of those applications installed, you’re almost certain to have MS Info installed too. It also ships with Visual Basic 5. If you haven’t seen this applet before, choose About Microsoft Visual Basic from the Help menu and click the System Info button. You’ll see a window similar to Figure 1-4.</p>
<p>
The bottom line is that if your user is a Microsoft Office user or has an application such as Microsoft Excel installed, MS Info will be available. All you need to do then to provide the same information on the user’s system is to run the same application!</p>
<p class=blue>
<b>Globally Unique Identifiers (GUIDs)</b></p>
<p>
A GUID (Globally Unique Identifier) is a 128-bit integer that can be used by COM (Component Object Model) to identify ActiveX components. Each GUID is guaranteed to be unique in the world. GUIDs are actually UUIDs (Universally Unique Identifiers) as defined by the Open Software Foundation’s Distributed Computing Environment. GUIDs are used in Visual Basic mainly to identify the components you use in your projects (referenced under the References and Components options of the Project menu) and to help ensure that COM components do not accidentally connect to the “wrong” component, interface, or method even in networks with millions of component objects. The GUID is the actual name of a component, not the string you and I use to name it, nor its filename. For example, a component we’ve probably all used before is F9043C88-F6F2-101A-A3C9-08002B2F49FB. You and I most likely refer to this component as “Microsoft’s Common Dialog Control,” or more simply, COMDLG32.OCX.<i> </i>(I have two of these on my machine, both with the same GUID. Their versions are different, however. One is 5.00.3609, and the other is 5.00.3112. Which do you link with?)</p>
<p>
To determine a component’s GUID, you look in your project’s .VBP file. You’ll see something like this if you use the common dialog control:</p>
<pre><code>Object={F9043C88-F6F2-101A-A3C9-08002B2F49FB}#1.1#0; COMDLG32.OCX</code></pre>
<p>
Visual Basic creates GUIDs for you automatically (for every ActiveX control you build). If you want to create them externally to Visual Basic, you can use either GUIDGEN.EXE or UUIDGEN.EXE, Microsoft utilities that come with the Visual C++ compiler, with the OLE SDK, and on the Visual Basic 5 CD. In Chapter 8, you’ll also find a Visual Basic program to generate GUIDs.</p>
<p>
<img src="f01xx04.gif" border=0></p>
<p class=blue>
<b>Figure 1-4  Running MSINFO32.EXE opens the Microsoft System Information Application</b></p>
<p>
To determine whether you’ve got this application to work with, look in the following location in the Registry:</p>
<pre><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\SharedTools\MSInfo\Path</code></pre>
<p>
In the following example, we use the registration API in ADVAPI32.DLL to retrieve the value of the Registry key. We can then check to see whether the application really exists. If it does, <i>Shell </i>it!</p>
<h2>Declaration Section</h2>
<pre><code>Option Explicit

Private Const REG_SZ                    As Long = 1
Private Const ERROR_SUCCESS             As Long = 0
Private Const HKEY_LOCAL_MACHINE        As Long = &amp;H80000002
Private Const STANDARD_RIGHTS_ALL       As Long = &amp;H1F0000
Private Const KEY_QUERY_VALUE           As Long = &amp;H1
Private Const KEY_ENUMERATE_SUB_KEYS    As Long = &amp;H8
Private Const KEY_NOTIFY                As Long = &amp;H10
Private Const SYNCHRONIZE               As Long = &amp;H100000
Private Const READ_CONTROL              As Long = &amp;H20000
Private Const STANDARD_RIGHTS_READ      As Long = (READ_CONTROL)
Private Const KEY_READ                  As Long = _
                                           ((STANDARD_RIGHTS_READ _
                                           Or KEY_QUERY_VALUE _
                                           Or KEY_ENUMERATE_SUB_KEYS _
                                           Or KEY_NOTIFY) _
                                           And (Not SYNCHRONIZE))

Private Declare Function WinRegOpenKeyEx Lib "advapi32.dll" _
Alias "RegOpenKeyExA" (ByVal hKey As Long, _
                       ByVal lpSubKey As String, _
                       ByVal ulOptions As Long, _
                       ByVal samDesired As Long, _
                       phkResult As Long) As Long

Private Declare Function WinRegQueryValueEx Lib _
"advapi32.dll" Alias "RegQueryValueExA" _
                     (ByVal hKey As Long, _
                      ByVal lpValueName As String, _
                      ByVal lpReserved As Long, _
                      lpType As Long, lpData As Any, _
                      lpcbData As Long) As Long

Private Declare Function WinRegCloseKey Lib "advapi32" _
Alias "RegCloseKey" (ByVal hKey As Long) As Long</code></pre>
<h2>Form Load Event</h2>
<pre><code>Private Sub Form_Load()

    Dim hKey   As Long
    Dim lType  As Long
    Dim Buffer As String
    
    ' Need some space to write string into - DLL routine 
    ' expects us to allocate this space before the call.
    Buffer = Space(255)
        
    ' Always expect failure!
    cmdSystemInfo.Visible = False
        
    ' This will work if MS Info is installed.
    If WinRegOpenKeyEx( _
                 HKEY_LOCAL_MACHINE _
                , "SOFTWARE\Microsoft\Shared Tools\MSInfo" _
                , 0 _
                , KEY_READ _
                , hKey _
                ) = ERROR_SUCCESS Then
    
        ' Read the Path value - happens to include the filename 
        ' too, e.g., 
        ' "C:\Program Files\Common Files\Microsoft Shared\
        ' MSinfo\msinfo32.exe".
        If WinRegQueryValueEx( _
                              hKey _
                             , "Path" _
                             , 0 _
                             , lType _
                             , ByVal Buffer _
                             , Len(Buffer) _
                             ) = ERROR_SUCCESS Then

            ' Make sure we read a string back. If we did...
            If lType = REG_SZ Then
                ' Make sure the Registry and reality are in 
                ' alignment!
                ' Note: Using FileAttr() means you're 
                ' suffering from paranoia&lt;g&gt;.
                If Dir$(Buffer) &lt;&gt; "" Then
                    ' Put the path into the buttons tag 
                    ' and make the button visible.
                    cmdSystemInfo.Tag = Buffer
                    cmdSystemInfo.Visible = True
                End If
            End If

        End If

        ' We open - we close.
        Call WinRegCloseKey(hKey)

    End If

End Sub</code></pre>
<h2>Button Click Event</h2>
<pre><code>Private Sub cmdSystemInfo_Click()

    ' If we got clicked, we must be visible and therefore 
    ' must have our tag set to the name of the MS Info app -
    ' Shell it!
    Call Shell(cmdSystemInfo.Tag, vbNormalFocus)

End Sub</code></pre>
<p>
In the code above, as the form loads (maybe this is an About box?) it detects whether or not MS Info exists. If it does, the form makes a command button visible and sets its <i>Tag</i> property to point to the program. When the form becomes visible, the button either will or won’t be visible. If it is visible, you have MS Info on your machine. When you click the button, it simply shells its <i>Tag</i>. For more information on the APIs used in this example, see the appropriate Win32 documentation.</p>
<p>
It’s possible via subclassing to provide an alternative internal class to replace CommonDialog, or whatever you want to call your one and only instance of a CommonDialog control. (You use only one, right?) We do this in our applications for two reasons. First, we use this alternative class to provide our users with both 16- and 32-bit versions of each dialog box, which is especially useful with the file type dialog boxes. Second, we use it to add a new type of dialog box to the control. Guess what it is. Here’s a clue:</p>
<p>
<i>CommonDialog1.ShowMSInfo</i></p>
<h1></h1>
</BODY>
</HTML>
