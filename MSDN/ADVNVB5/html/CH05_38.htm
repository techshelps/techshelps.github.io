<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Arrays</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="arrays"></a>Arrays</h1>
<p>
Arrays are implemented in Visual Basic 5 using the Automation data type named <i>SAFEARRAY</i>. This is a structure that, like Variants and classes, allows arrays to be <i>self-describing. </i>The <i>LBound</i> and number of elements for each dimension of the array are stored in this structure. All access to these arrays is through an extensive set of API calls. You do not get or set the array elements directly, but you use API calls. These API calls make use of the <i>LBound </i>and number of elements to make sure they always write within the allocated area. This is why they are <i>safe</i> arrays—attempts to write to elements outside the allowed area are trapped within the API and gracefully dealt with.</p>
<p>
The ability to store arrays in Variants was new to Visual Basic 4, and a number of new language elements were introduced to support them such as <i>Array()</i><b> </b>and<i> IsArray().</i></p>
<p>
To set up a Variant to be an array, you can either assign it to an already existing array or use the <i>Array</i> function. The first of these creates a Variant whose subtype is the array value (8192) operated on by OR with the type of the original array. The <i>Array</i> function, on the other hand, always creates an array of Variants—<i>VarType</i> <i>8204</i>.</p>
<p>
The following code shows three ways of creating a Variant array of the numbers 0,1,2,3:</p>
<pre><code>Dim v   As Variant
Dim a() As Integer
Dim i   As Integer

' Different ways to create Variant arrays
' 1. Use the Array function.
v = Array(0, 1, 2, 3) ' Of little practical use
v = Empty

' 2. Create a normal array, and assign it to a Variant.
' Iterate adding elements using a normal array...
For i = 0 To 3
    ReDim Preserve a(i) As Integer
    a(i) =  i
Next i

' ...and copy array to a Variant
v = a
' or
v = a()
' but not v() = a()

v = Empty

' 3. Start off with Array, and then ReDim to preferred size,
' avoiding use of intermediate array.
For i = 0 To 3
    ' First time we need to create array
    If IsEmpty(v) Then
        v = Array(i)
    Else
    ' From then on, ReDim Preserve will work on v.
        ReDim Preserve v(i)
    End If
    v(i) = i
Next i</code></pre>
<p>
Notice that the only difference between the last two arrays is that one is a Variant holding an array of integers and the other is a Variant holding an array of Variants. It can be easy to get confused here, so look at the following:</p>
<pre><code>ReDim v(5) As Variant</code></pre>
<p>
This code is creating an array of Variants, but this array is <i>not </i>a Variant array. What consequence does this have? Well, with Variant arrays, you can utilize array copying. The manuals make surprisingly little of this great feature, and you’ve probably just stumbled on it by accident if you’ve discovered it at all. Array copying is supported for Variant arrays only because, as we’ve already seen, Visual Basic calls into the Automation API. At the Automation level, the function <i>VariantCopy </i>calls another Automation API named <i>SafeArrayCopy</i> if the variant is of subtype <i>VT_ARRAY</i>. When <i>SafeArrayCopy</i> copies an array, all elements are copied in their entirety, even if they are arrays themselves. In other words, a copy of the array and all its elements is made. The <i>SafeArrayCopy</i> function must have been written recursively because each element of the array is subject to the same rules. So where the element of an array is itself an array, that whole array is copied too. This is called a <i>deep copy</i>. In short, every part and subpart of our Variant “structure” is faithfully copied, however deep the nesting.</p>
<p>
This code sample demonstrates the difference between a Variant<i> </i>array and an array of Variants:</p>
<pre><code>ReDim v1(5) As Variant  ' Array 1 - an ordinary array of Variants
Dim v2 As Variant
v2 = Array(1,2,3) ' Array 2 - a Variant array of Variants

v2 = v1  ' Ok
v1 = v2  ' Syntax error (cannot assign to nonbyte array)</code></pre>
<p>
So Variants can contain arrays, and they can be arrays of Variants. As mentioned, if those contained Variants are just ordinary Variants—which they are—they can themselves be arrays, perhaps of Variants, which can be arrays too, and so on and so forth.</p>
<p>
Just how deep can these arrays be nested? I don’t know if there is a theoretical limit, but in practice I have tested at least 10 levels of nesting. This odd bit of code works fine:</p>
<pre><code>Dim v As Variant, i As Integer

' Make v an array of two Variants, each of which is an array 
' of two Variants, each of...and so on
For i = 0 To 10
    v = Array(v, v)
Next i

' Set a value...
v(0)(0)(0)(0)(0)(0)(0)(0)(0)(0)(0) = 23</code></pre>
<p>
How do these compare to more standard multidimensional arrays? Well, on the positive side, they are much more flexible. The contained arrays—corresponding to the lower dimensions of a multidimensional array—do not have to have the same number of elements. Figure 5-3 explains the difference pictorially.</p>
<p>
<img src="f05rf03.gif" border=0></p>
<p class=blue>
<b>Figure 5-3  The difference between a standard two-dimensional array (top) and a Variant array (bottom) </b></p>
<p>
These are sometimes known as <i>ragged arrays</i>—and they were not possible to construct until Visual Basic 4. As you can see from Figure 5-3, we do not have all the wasted space of a standard multidimensional array. However, you have to contrast that with the fact that the Variant “trees” are harder to set up.</p>
<p>
This ability of Variants to hold arrays of Variants permits some interesting new data structures in Visual Basic. One obvious example is a tree. In this piece of code, an entire directory structure is folded up and inserted in a single Variant:</p>
<pre><code>Private Sub Form_Load()
    Dim v As Variant
    v = GetFiles("C:\") ' Places contents of C: into v
End Sub

Public Function GetFiles(vPath As Variant) As Variant
    ' NB cannot use recursion immediately because Dir
    ' does not support it, so get array of files first.
    Dim vDir As Variant, vSubDir As Variant, i

    vDir = GetDir(vPath)

    ' Now loop through array, adding subdirectory information.
    If Not IsEmpty(vDir) Then
        For i = LBound(vDir) To UBound(vDir)
            ' If this is a dir, then...
            If (GetAttr(vDir(i)) And vbDirectory) = vbDirectory Then
                ' replace dir name with the dir contents.
                vDir(i) = GetFiles(vDir(i))
            End If
        Next i
    End If

    GetFiles = vDir

End Function

Private Function GetDir(ByVal vPath As Variant) As Variant
    ' This function returns a Variant that is an array
    ' of file and directory names (not including "." or "..")
    ' for a given directory path.
    Dim vRet As Variant, fname As Variant

    ' Add \ if necessary.
    If Right$(vPath, 1) &lt;&gt; "\" Then vPath = vPath &amp; "\"

    ' Call the Dir function in a loop.
    fname = Dir(vPath, vbNormal &amp; vbDirectory)
    Do While fname &lt;&gt; ""
        If fname &lt;&gt; "." And fname &lt;&gt; ".." Then
            vRet = AddElement(vRet, vPath &amp; fname)
        End If
        fname = Dir()
    Loop

    ' Return the array.
    GetDir = vRet
End Function


Public Function AddElement(vArray As Variant, vElem As Variant) As Variant
' This function adds an element to a Variant array
' and returns an array with the element added to it.

    Dim vRet As Variant ' To be returned

    If IsEmpty(vArray) Then
        ' First time through, create an array of size 1.
        vRet = Array(vElem)
    Else
        vRet = vArray
        ' From then on, ReDim Preserve will work.
        ReDim Preserve vRet(UBound(vArray) + 1)
        vRet(UBound(vRet)) = vElem
    End If

    AddElement = vRet

End Function</code></pre>
<p>
This is just an indication of the kinds of things you can do with<i> </i>Variant<i> </i>arrays. They are particularly useful when creating out-of-process object applications. If you have done this, you’ll know how slow it is every time you cross a process boundary. I have found the ability to return arrays inside Variants invaluable in enabling the passing of a lot of information across a process boundary in one move.</p>
<h1></h1>
</BODY>
</HTML>
