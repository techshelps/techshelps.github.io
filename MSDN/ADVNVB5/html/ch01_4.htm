<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tip 3: Raise exceptions when possible because return values will be ignored.</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="tip3raiseexceptionswhenpossiblebecausereturnvalueswillbeignored."></a>Tip 3: Raise exceptions when possible because return values <i>will </i>be ignored.</h1>
<p>
This tip supplements Tip 1: “Inconsistent as it is, try to mimic Visual Basic’s own error handling scheme as much as possible.” Since Visual Basic 4, a function can be called like a subroutine. (In Visual Basic 3 and earlier, it couldn’t.) To demonstrate this, consider the following code fragments:</p>
<pre><code>Sub Command1_Click ()

    Debug.Print SomeFunc()
    Call SomeFunc

End Sub


Function SomeFunc () As Integer

    SomeFunc = 42

End Function</code></pre>
<p>
The line <i>Call SomeFunc</i> is illegal in Visual Basic 3 but legal in Visual Basic 4 and later. (It’s VBA!) In case you’re wondering why this is so, the facility was added to VBA (Visual Basic for Applications) to allow you to write routines that were more consistent with some of Visual Basic’s own routines, such as <i>MsgBox</i>,<i> </i>which acts sometimes like a function and sometimes like a statement (or a C type procedure if you’re used to that language). (In Tip 4, you’ll find out how to write your own <i>MsgBox </i>routine.)</p>
<p>
A side effect of all this is that routines that return some indication of success or failure might now have that result ignored. As C and SDK programmers know only too well, this <i>will</i> cause problems! In Visual Basic 3, the programmer always had to use the return value. Typically, he or she would use it correctly. If a programmer can ignore a routine’s returned value (say it’s not a database handle but a True/False value—that is, either it worked or it failed), however, he or she usually will ignore it.</p>
<p>
Exceptions, on the other hand, cannot easily be ignored (except by using <i>On Error Resume Next </i>or <i>On Error Resume 0</i>—both easy to test for and legislate against). Also, keep in mind that “newer” Visual Basic developers sometimes lack the necessary self-discipline to use and test return values correctly. By raising exceptions, you force them to test and then to take some appropriate action in one place: the error handler.</p>
<p>
Another reason to use exceptions is that not using them can cause your code to become more difficult to follow—all those (un)necessary conditional tests to see that things have worked correctly. This kind of scheme, in which you try some code and determine that it didn’t work by catching a thrown exception, is pretty close to “structured exception handling” as used in C++ and Microsoft Windows NT. For more on structured exception handling, see the Visual C++ 4.0 online help. (Select Contents, and follow this path: Visual C++ books; C/C++; Programming Techniques; Structured Exception Handling.)</p>
<p>
Here’s an example of a structured exception handling type of scheme:</p>
<pre><code>Private Sub SomeWhere()

    If a() Then
        §
        If b() Then
            §
            If c() Then
                §
            End If
        End If
    End If

End Sub</code></pre>
<p>
OK, I agree, this example is not too hard to figure out. But I’m sure you’ve seen far more complex examples of nesting conditionals and get the idea! Here’s the same code using exceptions to signal errors in <i>a</i>, <i>b</i>, or <i>c</i>:</p>
<pre><code>Private Sub SomeWhere()

' TRY
On Error Goto ????

    a()
        §
    b()
        §
    c()
        §

' CATCH
????

    ' Handle exception here.

End Sub</code></pre>
<p>
Can you see the flow any easier here? What you cannot see is that to get to the call to <i>b</i>, <i>a</i> must function correctly—it’s only implied by the presence of the error handler. By losing the <i>If</i>,<i> </i>you’re losing some plain readability but you’re also gaining some—the code is certainly less cluttered. Of course, sometimes code is clear just because you’re used to it. Consider replacing <i>b</i>, for instance, with a call to <i>Open</i>. If you were to use the <i>If…Then</i> scheme to check for errors, you couldn’t check for any errors in <i>Open </i>because you can’t put conditional statements around a procedure. So it’s easy for you to accept the fact that after <i>Open </i>is called, if an error occurs, the statement following <i>Open </i>will not run. It works the same with the <i>b</i> function. If an error occurs in the <i>b</i> function, the error routine rather than the statement that follows <i>b</i> will execute.</p>
<p>
If you adopt this kind of error handling scheme, just make sure that you have projectwide collaboration on error codes and meanings. And by the way, if the functions <i>a</i>, <i>b</i>, and <i>c</i> already exist (as used previously with the <i>If</i> statements), we’ll be using this “new” ability to ignore returned values to our advantage.</p>
<p class=indent>
<span class=blue><b>Note </b></span> Once again, if a routine’s returned value can be ignored, a programmer will probably ignore it!</p>
<h1></h1>
</BODY>
</HTML>
