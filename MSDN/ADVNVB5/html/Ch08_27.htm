<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Collections to Extend the Type System</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="usingcollectionstoextendtypesystem"></a>Using Collections to Extend the Type System</h1>
<p>
You can also extend the type system (“type” meaning mere data at this point) in other ways. At TMS, we often use a <i>Collection </i>object (as in the following code) to represent objects that are entirely entities of state; that is, they have no methods. (You cannot append a method to a collection.)</p>
<pre><code>Dim KindaForm As New Collection

Const pHeight As String = “1"
Const pWidth  As String = “2"
Const pName   As String = “3"

. . .

With KindaForm
    .Add Key:=pHeight, Item:=Me.Height
    .Add Key:=pWidth, Item:=Me.Width
    .Add Key:=pName, Item:=Me.Name
End With

. . .

With KindaForm
    Print .Item(pHeight)
    Print .Item(pWidth)
    Print .Item(pName)
End With</code></pre>
<p>
Here we have an object named <i>KindaForm </i>that has the properties <i>pHeight</i>, <i>pWidth</i>, and <i>pName</i>. In other words, an existing Visual Basic type (with both properties and method) is being used to create a generic state-only object. If you’re using classes to do this, you might want to consider using <i>Collection </i>objects as shown here instead.</p>
<p>
You can add functional members to a <i>Collection </i>object with just one level of indirection by adding an object variable to the collection that is set to point to an object that has the necessary functionality defined in it. Such methods can act on the state in the other members of the collection.</p>
<p>
So what’s the difference between using a collection and creating a user-defined type? Well, a collection is more flexible (not always an advantage) and has support for constructs such as For Each:</p>
<pre><code>For Each v In KindaForm
    Print v
Next</code></pre>
<p>
The advantage of user-defined types is that they have a known mapping. For example, they can be used as parameters to APIs, sent around a network, and passed between mainframe and PC systems—they are just byte arrays. (See Chapter 5 for more on user-defined types—they’re one of Jon Burn’s favorite things!) Obviously, a state-only <i>Collection </i>object doesn’t mean much to a mainframe system, and passing <i>KindaForm </i>as “the thing” itself will result in your only passing an object pointer to a system that cannot interpret it. (Even if it could, the object would not be available because it’s not transmitted with its address.)</p>
<h1></h1>
</BODY>
</HTML>
