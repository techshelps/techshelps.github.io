<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Calling on All Your Problem-Solving Skills</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="callingonallyourproblem-solvingskills"></a>Calling on All Your Problem-Solving Skills</h1>
<p>
Constantly examine your approach to solving problems, and always encourage input and criticism from all quarters on the same. Think problems through. And <i>always </i>profile your code!</p>
<p>
It would be nice if VBCP included some way to time Visual Basic’s routines. For example, how fast is <i>Val </i>when compared with its near functional equivalent <i>CInt</i>? You can do some of this profiling using the subclassing technique discussed in Chapter 1 (replacing some VBA routine with one of your own—see Tip 11), but here’s a small example anyway:</p>
<pre><code><b><u>Declarations Section
</u></b>Option Explicit

Declare Function WinQueryPerformanceCounter Lib “kernel32” _
    Alias “QueryPerformanceCounter” (lpPerformanceCount As _
    LARGE_INTEGER) As Long
Declare Function WinQueryPerformanceFrequency Lib “kernel32” _
Alias “QueryPerformanceFrequency” (lpFrequency As LARGE_INTEGER) _
    As Long

Type LARGE_INTEGER
    LowPart     As Long
    HighPart    As Long
End Type
In a Module
Function TimeGetTime() As Single

    Static Frequency     As Long
    Dim CurrentTime      As LARGE_INTEGER

    If 0 = Frequency Then
        Call WinQueryPerformanceFrequency(CurrentTime)
        Frequency = CurrentTime.LowPart / 1000
        TimeGetTime = 0
    Else
        Call WinQueryPerformanceCounter(CurrentTime)
        TimeGetTime = CurrentTime.LowPart / Frequency
    End If 

End Function
Replacement for <i>Val</i>
Public Function Val(ByVal exp As Variant) As Long

    Dim l1 As Single, l2 As Single
    l1 = TimeGetTime()
    Val = VBA.Conversion.Val(exp)
    l2 = TimeGetTime()
    Debug.Print “Val - “ &amp; l2 - l1

End Function</code></pre>
<p>
The <i>TimeGetTime </i>routine uses the high-resolution timer in the operating system to determine how many ticks it (the operating system’s precision timing mechanism) is capable of per second (<i>WinQueryPerformanceFrequency</i>). <i>TimeGetTime </i>then divides this figure by 1000 to determine the number of ticks per millisecond. It stores this value in a static variable so that the value is calculated only once.</p>
<p>
On subsequent calls, the routine simply returns a number of milliseconds; it queries the system time, converts that to milliseconds, and returns this value to the calling program. For the calling program to determine a quantity of time passing, it must call the routine twice and compare the results of two calls. Subtract the result of the second call from the first, and you’ll get the number of milliseconds that have elapsed between the calls. This process is shown in the “Replacement for <i>Val</i>” code on the facing page.</p>
<p>
With this example, one can imagine being able to profile the whole of VBA. Unfortunately, that isn’t possible. If you attempt to replace certain routines, you’ll find that you can’t. For example, the <i>CInt </i>routine cannot be replaced using this technique. (Your replacement <i>CInt </i>is reported as having an illegal name.) According to Microsoft, for speed, some routines were not implemented externally in the VBA ActiveX server but were kept internal—<i>CInt </i>is one of those routines.</p>
<h1></h1>
</BODY>
</HTML>
