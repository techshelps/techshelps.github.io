<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Adding an event queue to an FSM</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="addingeventqueuetofsm"></a>Adding an event queue to an FSM</h1>
<p>
To prevent reentrant code, you need to add a queue to the FSM model. Strictly speaking, the comment stripper program doesn’t need a queue because it doesn’t do anything that will cause recursion. Because it’s an example program, however, we’ll add the queuing now so that you can build on it when you design real-world FSM programs later.</p>
<p>
The queue built in the previous example worked adequately, but it needed a form to carry the list box and the timer control. This awkwardness over essentially nonvisual code has dogged Visual Basic from the start, and it means, for example, that you can’t define a queue inside a class or a startup module without creating a dummy form. You could dump the controls onto an existing form, of course, but that’s anathema to modular design, and it means you must contrive to load the form before starting the event queue. Getting rid of the list box isn’t too hard, but until now there’s been no getting around that timer control without doing something horrific like this:</p>
<pre><code>Sub Main()
    Dim nEvent As Integer
    frmMain.Show vbModeless    ' Main program is in here.
    Do
        If bGetEventFromQueue(nEvent) Then
            DoFSM nPuState, nEvent
        End If
        DoEvents
    Loop
End Sub</code></pre>
<p>
With Visual Basic 5, however, you can at last devise acceptable code-only solutions to this kind of problem—in this case, to build an event queue. By using the <i>AddressOf</i> operator, you can call the <i>SetTimer </i>API function and pass a Visual Basic routine as the timer’s callback procedure. This means you can create a timer from pure code, and just like a Visual Basic Timer control, it will invoke the Visual Basic procedure asynchronously at the requested interval. Creating a timer is simple:</p>
<pre><code>lTimerId = SetTimer(0&amp;, 0&amp;, 500&amp;, AddressOf MyFunc)</code></pre>
<p>
The first two parameters are NULL values, which simply signify that the timer isn’t associated with any window, and the third is the timer interval, in milliseconds. The last parameter is the interesting one; it passes a pointer to a Visual Basic function that will be invoked by Windows whenever the timer fires. Windows expects this function to have the following interface and will pass the appropriate parameters:</p>
<pre><code>Sub MyFunc(ByVal lHwnd As Long, _
           ByVal nMsg As Long, _
           ByVal lEventId As Long, _
           ByVal lTime As Long)</code></pre>
<p class=indent>
<span class=blue><b>Note</b></span>   When working with callback functions, be careful to include the <i>ByVal </i>keywords. If you miss a <i>ByVal</i>, simply moving your mouse pointer over the parameter name in the Visual Basic debugger is enough to crash Visual Basic. This happens because of Visual Basic 5’s instant quick watch feature, which displays a variable’s value as a ToolTip. Because Visual Basic thinks you passed a reference parameter (<i>ByRef </i>is the default), it tries to dereference an illegal pointer value, which almost always causes an access violation. You can turn off this feature with the Auto Data Tips check box under Tools/Options/Editor.</p>
<p>
For now, just ignore the parameters. Make sure to destroy the timer when you’re finished with it:</p>
<pre><code>Call KillTimer (0&amp;, lTimerId)</code></pre>
<p>
That takes care of the queue manager, so now all you need to do is provide a queue for it to manage. A simple way to do this is to use a Visual Basic collection:</p>
<pre><code>Dim colPuEventQueue As Collection</code></pre>
<p>
You’ll see a more sophisticated use of collections later, but for now you can use one as a simple queue by defining a couple of routines:</p>
<pre><code>Sub AddEventToQueue(ByVal niEvent As Integer)
    colPuEventQueue.Add niEvent
End Sub

Function bGetEventFromQueue(ByRef noEvent As Integer) As Boolean
    If colPuEventQueue.Count = 0 Then
        bGetEventFromQueue = False
    Else
        noEvent = colPuEventQueue.Item(1)
        colPuEventQueue.Remove 1
        bGetEventFromQueue = True
    End If 
End Function</code></pre>
<p>
And that’s it—a code-only asynchronous queue manager that you can build into a class or a normal module. The program CHAP14\fsm\qman\qman.vbp on the companion CD is the comment stripper FSM program amended to use the new event queue.</p>
<h1></h1>
</BODY>
</HTML>
