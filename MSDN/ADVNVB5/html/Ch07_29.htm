<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Evil Type Coercion</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="eviltypecoercion"></a>Evil Type Coercion</h1>
<p>
A programmer on my team had a surprise when writing Visual Basic code to extract information from a SQL Server database. Having retrieved a recordset, he wrote the following code:</p>
<pre><code>Dim vntFirstValue As Variant, vntSecondValue As Variant
Dim nResultValue1 As Integer, nResultValue2 As Integer

vntFirstValue = Trim(rsMyRecordset!first_value)
vntSecondValue = Trim(rsMyRecordset!second_value)

nResultValue1 = vntFirstValue + vntSecondValue
nResultValue2 = vntFirstValue + vntSecondValue + 1</code></pre>
<p>
He was rather upset when he found that the “+” operator concatenated the two variants but added the final numeric value. If <i>vntFirstValue</i> contained “1” and <i>vntSecondValue</i> contained “2”, <i>nResultValue1</i> had the value 12 and <i>nResultValue2</i> had the value 13.</p>
<p>
To understand exactly what’s going on here, we have to look at how Visual Basic handles type coercion. Up until Visual Basic 3, type coercion was relatively rare. Although you could write Visual Basic 3 code like</p>
<pre><code>txtBox.Text = 20</code></pre>
<p>
and find that it worked without giving any error, almost every other type of conversion had to be done explicitly by using statements such as <i>CStr</i> and <i>CInt</i>. Starting with Visual Basic 4, and continuing in Visual Basic 5, performance reasons dictated that automatic type coercion be introduced. Visual Basic no longer has to convert an assigned value to a Variant and then unpack it back into whatever data type is receiving the assignment. It can instead invoke a set of hard-coded coercion rules to perform direct coercion without ever involving the overhead of a Variant. Although this is often convenient and also achieves the laudable aim of good performance, it can result in some rather unexpected results. Consider the following code:</p>
<pre><code>Sub Test()

Dim sString As String, nInteger As Integer
sString = "1"
nInteger = 2
ArgTest sString, nInteger

End Sub

Sub ArgTest(ByVal inArgument1 As Integer, _
            ByVal isArgument2 As String)
' Some code here
End Sub</code></pre>
<p>
In Visual Basic 3, this code would give you an immediate error at compile time because the arguments are in the wrong order. In Visual Basic 4 and Visual Basic 5, you won’t get any error because Visual Basic will attempt to coerce the string variable into the integer parameter and vice versa. This change is not a very pleasant one. If <i>inArgument1</i> is passed a numeric value, everything looks and performs as expected. As soon as a nonnumeric value or a null string is passed, however, a run-time error occurs. This means that the detection of certain classes of bugs has been moved from compile time to run time, which is definitely not a major contribution to road safety.</p>
<p>
The table at the top of the following page shows Visual Basic 5’s automatic type coercion rules.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=blue width=122><b>Source Type</b></td>
<td class=blue width=150><b>Coerced To</b></td>
<td class=blue width=320><b>Apply This Rule</b></td>
</tr>
<tr valign=top>
<td width=122>Integer</td>
<td width=150>Boolean</td>
<td width=320>0=False, nonzero=True</td>
</tr>
<tr valign=top>
<td width=122>Boolean</td>
<td width=150>Byte</td>
<td width=320>False=0, True=255</td>
</tr>
<tr valign=top>
<td width=122>Boolean</td>
<td width=150>Any numeric</td>
<td width=320>False=0, True=-1 (except Byte)</td>
</tr>
<tr valign=top>
<td width=122>String</td>
<td width=150>Date</td>
<td width=320>String is analyzed for MM/dd/yy and so on</td>
</tr>
<tr valign=top>
<td width=122>Date</td>
<td width=150>Numeric type</td>
<td width=320>Coerce to Double and use DateSerial(Double)</td>
</tr>
<tr valign=top>
<td width=122>Numeric</td>
<td width=150>Date</td>
<td width=320>Use number as serial date, check valid date range</td>
</tr>
<tr valign=top>
<td width=122>Numeric</td>
<td width=150>Byte</td>
<td width=320>Error if negative</td>
</tr>
<tr valign=top>
<td width=122>String</td>
<td width=150>Numeric type</td>
<td width=320>Treat as Double when representing a number</td>
</tr>
</table><br>
<p>
<b>Some Final Thoughts</b> Any Visual Basic developer with aspirations to competence should learn the automatic type coercion rules and understand the most common situations in which type coercion’s bite can be dangerous.</p>
<h1></h1>
</BODY>
</HTML>
