<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual Basic 4: Open the box, add water, and distribute</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="visualbasic4openboxaddwaterdistribute"></a>Visual Basic 4: Open the box, add water, and distribute</h1>
<p>
So what’s the answer for scalable distributed applications? Some people—and I’ll put my hand up, I was one—thought they had found it in Visual Basic 4 Enterprise Edition. Thanks to the class module and collections, we could make objects with properties and methods that could encapsulate data and functionality. I won’t go into the object-oriented purity of an object’s polymorphism and multiple inheritance from grandfather objects—objects so long forgotten that you couldn’t tell whether your object instances had a full head of jet black hair into their nineties or were bald before they were twenty-five. Well, not until the First Law of Multiple Inheritance manifested itself: “When you need to know how a thing is going to behave, it’s already too late.” Thanks to Remote Automation and later DCOM, we could plonk the objects in a Windows environment somewhere other than the client PC—on a machine with more processors, more RAM, and more disk space—and use them (almost) as if they were on our machine and part of our good old “fat client.” We <i>could</i> even deploy our existing skill sets to build them in good old Visual Basic. Nirvana, Valhalla, Ambrosia. (These are, incidentally, names I’ve never dared give to any system—so you may take them and use them without fear of my enforcing copyright.) Simply open the Visual Basic 4 Enterprise Edition box, add water, and distribute—now with the super new added ingredient: scalability.</p>
<p>
The Visual Basic 4 vision, then, was of being able to take monolithic designs and even monolithic applications and slice them up for implementation. We wanted to build systems of cooperating components that could easily (“seamlessly” was always the irritating buzzword) combine to provide the means of carrying out a task, no matter where we wanted to deploy them—any platform anywhere that they would run best.</p>
<p>
Some of us, of course, had already been applying a bit of common sense to our designs in the first place, even before Visual Basic 4 Enterprise Edition. We had been building our applications in a modular fashion, albeit they were compiled into one executable. Such visionary developers had fewer problems than many out there who didn’t build modular applications, but we still didn’t have the ability to build lots of separate executables or DLLs and deploy them where we would. Sure, we could build our applications in such a way that we had a number of cooperating executables all on the client. But organizing them and marshaling their resources for an application’s tasks often appeared an unnecessary complication using anything other than OLE (now called ActiveX); and despite the best will in the world, OLE in previous versions of Visual Basic proved to be ponderous and heavy on resources. So this route was usually pursued only as a way of breaking up monolithic applications into functional pieces after they had reached the size where they didn’t work sensibly or in some cases wouldn’t even compile in Visual Basic anymore.</p>
<h1></h1>
</BODY>
</HTML>
