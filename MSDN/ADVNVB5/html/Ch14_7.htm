<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Art of the State</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="theartofstate"></a>The Art of the State</h1>
<p>
An FSM is a virtual machine characterized by a set of internal states, a set of external events, and a set of transitions between the states. You might also hear FSMs referred to by the name finite state automata, deterministic finite automata, or simply state machines. FSMs can be used to model an entire application, a small part of it, or both, and they are extremely common in the design of real-time systems, compilers, and communications protocols. FSMs are ideal tools for representing event-driven programs such as GUIs.</p>
<p>
States are labels assigned to particular sets of circumstances within the application. Although FSMs are often used to model the GUI part of applications, states are not forms, and events are not necessarily Visual Basic events. You generate a set of predefined events from real-world stimuli and apply them as inputs to the FSM to drive it through transitions into different states. Transitions can have arbitrary lists of actions associated with them, and these actions are executed as you drive the FSM from state to state by repeatedly applying events. An FSM is deterministic because each combination of state and event unambiguously defines the next state to move into.</p>
<p>
&nbsp;An FSM can be represented as a state transition diagram or as a pair of tables, one table defining the next state to move into when a particular state/event combination is detected and the other a list of actions to be performed along the way.</p>
<p>
Figure 14-4 shows an FSM for a program to strip C comments out of a text stream. (Comments in C are delimited by /<i>*</i> and <i>*</i>/.)</p>
<p>
<img src="f14rf04.gif" border=0></p>
<p class=blue>
<b>Figure 14-4  Comment stripper FSM</b></p>
<p>
The bubbles in Figure 14-4 represent states, and the arrows represent transitions between states. Each transition is labeled with the event that stimulates it and the list of associated actions. One state is designated the start state, which is the initial state when the FSM starts to operate. Here is the FSM in tabular form:</p>
<p class=blue>
<b>State Table</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=220></td>
<td class=blue width=371><b>State</b></td>
</tr>
<tr valign=top>
<td class=blue width=220><b>Event</b></td>
<td class=blue width=96><b>Outside</b></td>
<td class=blue width=88><b>Starting</b></td>
<td class=blue width=80><b>Inside</b></td>
<td class=blue width=107><b>Ending</b></td>
</tr>
<tr valign=top>
<td width=220>/</td>
<td width=96>Starting</td>
<td width=88>Starting</td>
<td width=80>Inside</td>
<td width=107>Outside</td>
</tr>
<tr valign=top>
<td width=220>*</td>
<td width=96>Outside</td>
<td width=88>Inside</td>
<td width=80>Ending</td>
<td width=107>Ending</td>
</tr>
<tr valign=top>
<td width=220>Any other char</td>
<td width=96>Outside</td>
<td width=88>Outside</td>
<td width=80>Inside</td>
<td width=107>Inside</td>
</tr>
</table><br>
<p class=blue>
<b>Action Table</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=blue width=220></td>
<td class=blue width=371><b>State</b></td>
</tr>
<tr valign=top>
<td class=blue width=220><b>Event</b></td>
<td class=blue width=96><b>Outside</b></td>
<td class=blue width=88><b>Starting</b></td>
<td class=blue width=80><b>Inside</b></td>
<td class=blue width=107><b>Ending</b></td>
</tr>
<tr valign=top>
<td width=220>/</td>
<td width=96>N/A</td>
<td width=88>Print “/”</td>
<td width=80>N/A</td>
<td width=107>N/A</td>
</tr>
<tr valign=top>
<td width=220>*</td>
<td width=96>Print char</td>
<td width=88>N/A</td>
<td width=80>N/A</td>
<td width=107>N/A</td>
</tr>
<tr valign=top>
<td width=220>Any other char</td>
<td width=96>Print char</td>
<td width=88>Print “/”<br>
Print char</td>
<td width=80>N/A</td>
<td width=107>N/A</td>
</tr>
</table><br>
<p>
These tables provide the basis for implementing an FSM as a program. An FSM program has the following elements:
<ul type=disc>
<li>
A static variable to track the current state and a set of constants to represent all available states<br><br></li>
<li>
A table or equivalent program network to look up a state/event pair and decide which state to move into<br><br></li>
<li>
A set of constants to represent FSM events<br><br></li>
<li>
A driver loop that captures real-world events and decodes the state/event pair</li>
</ul>
<h1></h1>
</BODY>
</HTML>
