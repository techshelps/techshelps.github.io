<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Toward a General Modality Class</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="towardgeneralmodalityclass"></a>Toward a General Modality Class</h1>
<p>
You can both create and manipulate value-added forms by building a CFormAttributes class (see the “Forms Are Classes Too” sidebar on page 584) and adding the function modality mechanism to it. The central requirement for such a mechanism is to associate a parent with each form you create. You can do this by adding a <i>Parent </i>property to the CFormAttributes class:</p>
<pre><code>Public Parent As Form</code></pre>
<p>
Now you have somewhere to store a reference to the parent form, so you need to arrange for this reference to be set when the form is loaded. Since you can’t pass parameters to a form’s <i>Show </i>method (or to the CFormAttributes instance), you need to do this manually from outside the CFormAttributes class. You want to be able to do something like this:</p>
<pre><code>Public Sub ShowChild Child:=frmReview, Parent:=Me</code></pre>
<p>
You could make this a global procedure and give it its own BAS file, but it’s better to keep all the code in one place by making <i>ShowChild </i>a method of the CFormAttributes class. Obviously, this means you can’t invoke <i>ShowChild</i> to display the first form in a hierarchy, but the only implication of this is that you need to make sure that the CFormAttributes class recognizes that it has no parent when it is destroyed. You can also dispense with the <i>Parent</i> parameter since you already have a <i>Self</i> reference in the CFormAttributes class. Here’s the method in the CFormAttributes class, which is named <i>NewChild</i>:</p>
<pre><code>Public Sub NewChild(ByVal frmiChild As Form)
    frmiChild.Show
    Set frmiChild.My.Parent = frmPiSelf
    frmPiSelf.Enabled = False
End Sub</code></pre>
<p>
The last statement is the significant one because it’s the one that disables the parent form and creates a new mode. You need a reciprocal action to reenable the parent when the form unloads, so you need to define another method:</p>
<pre><code>Public Sub EnableParent()
    If Not Me.Parent Is Nothing Then Me.Parent.Enabled = True
End Sub</code></pre>
<p>
Unfortunately, there’s no elegant way to bind this to a form unload; you must ensure that you call this method from each <i>Form_Unload </i>event:</p>
<pre><code>Private Sub Form_Unload()
    My.EnableParent
End Sub</code></pre>
<p>
In fact, the sample code in CHAP14\atribcls\pubatrib.cls has a generic <i>UnloadActions </i>method, which takes the place of <i>EnableParent</i>, but this discussion is clearer if I continue to refer to an <i>EnableParent </i>method.</p>
<p>
That takes care of modal child forms, as long as you invoke them with <i>My.NewChild </i>and include the appropriate reciprocal call in the <i>Form_Unload</i> event. You can now build on this to extend the mechanism. To cope with the swapping in the sample program, for example, you need to do a couple of extra things: pass on the outgoing form’s parent reference to the new form and then prevent the parent from being reenabled when the old form unloads. You can do this by adding a new method and modifying the <i>EnableParent </i>method slightly so that the two communicate through a module-level flag:</p>
<pre><code>Private bPiKeepParentDisabled As Boolean

Public Sub SwapMe(ByVal frmiNewChild As Form)
    frmiNewChild.Show vbModeless
    If frmiNewChild.Enabled Then
        Set frmiNewChild.My.Parent = Parent
        bPiKeepParentDisabled = True
    End If
    Unload frmPiSelf
End Sub

Public Sub EnableParent()
    If Not bPiKeepParentDisabled Then
        If Not Parent Is Nothing Then Parent.Enabled = True
    End If
End Sub</code></pre>
<p>
Notice the check to find out whether the form you’re trying to swap to is enabled. If it isn’t, it must already have been loaded, in which case you’ll just leave the <i>Parent </i>property alone. This is an ad hoc test that works in the simple examples shown here, but it might not be general, and so you’ll need to extend the mechanism to cope with other situations. For example, the mechanism as it stands won’t prevent you from trying to swap to a form that’s in the <i>middle</i> of a modal cascade—in fact, this would orphan any child forms in the cascade. With a little thought, you should be able to extend the mechanism to allow swapping to remove child forms of the form you’re trying to swap to, to prevent swapping between forms belonging to other functions in a function modal situation, or to support any other flavors of modality you care to invent.</p>
<h1></h1>
</BODY>
</HTML>
