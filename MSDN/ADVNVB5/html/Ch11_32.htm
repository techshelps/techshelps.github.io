<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The CBT builder application</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="thecbtbuilderapplication"></a>The CBT builder application</h1>
<p>
To get a flying start with the application, I have used the Visual Basic Application wizard to produce a skeleton MDI application. (<i>Note:</i> This program is intended for Windows 95 only.) I won’t cover any of the generated code or forms here. You should be able to review that at your leisure, either by using what’s on the CD or by generating a skeleton application yourself.</p>
<p>
A substantial amount of the code that we will be creating in the builder application will also be used in the presenter application, albeit with some minor changes. You will also see striking similarities between a lot of the builder code and the code that we have developed for the previous applications. We will be building on the knowledge gained so far.</p>
<p>
The builder will allow you to create a project and then add images for each of the forms that make up the application. The main limitation here is that you can create only one calling link and one called link for each form. You can create hot spot regions on these images and link hot spot actions for these regions. You can also create help text for each of the forms.</p>
<p>
At the start of the application, a splash screen is displayed. There has been no alteration to this form from generation except for a few changes to labels, so I’ll ignore this form. We’ll look at the other areas of functionality in the order that they appear in the menu on the MDI parent form. The builder MDI at run time is shown in Figure 11-9.</p>
<p>
<img src="f11rf09.gif" border=0></p>
<p class=blue>
<b>Figure 11-9  The CBT builder MDI at run time</b></p>
<p>
<b>The File menu</b>  The first set of menu items consists of the File menu functions. These are functionally identical to the File menu functions for the hot spot editor project. The New menu item creates a new CBT database from a blank template database and then allows you to set up all the details. The Open menu item opens a CBT database that has been previously created so that you can continue work on it, and Close closes the database that’s currently open. The Exit menu item shuts down the application by deleting any objects in memory (using the <i>ResetHotSpots </i>function developed in the hot spot editor project), closing the database and unloading the form.</p>
<p>
<b>The Edit menu</b>  No code has been written for the Edit menu items, but the items have been left in the application. In a commercial application, there would be at a minimum Cut, Copy, and Paste items. You will also notice that there are icons on the toolbar for formatting text. These have also been left in so that you can code them for formatting the text you’ll create to describe the forms. In a commercial application, you’d add a flag to the database that indicates whether the text is in an external file or held within the database. After all, it’s easier to use another editor than code one yourself.</p>
<p>
<b>The View menu</b>  The last item on the View menu (Project Detail) has been added from the details generated. This item calls a form that allows the user to view the project details that have been set up. This form has been generated using the Data Form Wizard and has not been altered in any way. The form allows the user to view the project details and the forms that have been set up for the project so far.</p>
<p>
<b>The Project menu</b>  When you have created or opened a database, you first create or open a project. The CBT system has been designed to be a multiproject database, so you can hold details about more than one application in a single place. The New and Amend menu items each load forms that allow the user to set up a new project or amend an existing project. These forms were generated with the Data Form wizard, so I’ll leave you to review the code at your leisure.</p>
<p>
To let the user open a project and make it the current project, a small dialog box, <i>frmProjSel</i>, is displayed that lets the user select from a list of projects previously set up on the database:</p>
<pre><code>Dim strSQL As String

    On Error GoTo ErrDetect

    ' Get the project details.
    strSQL = ""
    strSQL = strSQL &amp; "SELECT    ProjID"
    strSQL = strSQL &amp; "         ,Version "
    strSQL = strSQL &amp; "FROM Project"
    Set rsPiProject = dbPuProj.OpenRecordset(strSQL, _
        dbOpenSnapshot)

    ' Load them into a combo box.
    rsPiProject.MoveFirst

    Do
       cboProj.AddItem rsPiProject!ProjID &amp; "-" &amp; _
           rsPiProject!Version
       rsPiProject.MoveNext
    Loop Until rsPiProject.EOF

    Exit Sub</code></pre>
<p>
For the demonstration application, I’m using SQL directly from within the code. Although this is more efficient than using DAO, there are a few things that you might like to consider. In a commercial application, for added efficiency you may find stored procedures or stored queries in a Jet database more effective. If you don’t want to create stored procedures but you want to maintain a reasonable amount of decoupling from the database for security or maintenance reasons, you can create the SQL in a resource file and load it as required. The actual method will, as usual, depend on your requirements.</p>
<p>
The Form_Load event reads all of the projects on the Project table and populates a combo box with the details.</p>
<p>
The cancel Button_Click event closes the recordset and unloads the form but does not reset the current project.</p>
<p>
The SelectClick event sets the two public variables that reset the current project and version. These are used throughout the rest of the application to access and set up the project-specific and version-specific details.</p>
<p>
If you neither set up a new project nor select a current project, you will not be able to use the form functions. In a commercial system, a useful feature would be to save the application settings in the registry so that when the CBT system is reloaded you can resume where you left off.</p>
<p>
<b>The Form menu</b>  Because most projects are based on forms, the majority of the functionality is focused on the Form menu items. To create a new form for your project, you choose Set Up New Form Image. This displays a common dialog box to get the path and name of the image that represents the form and then sets up the image form in N (new) mode.</p>
<p>
If you want to test or edit form hot spot details, select Add To Saved Image. This loads a dialog box (named frmFormGet) modally, which allows the user to select a previously set up form.</p>
<pre><code>frmFormGet.Show vbModal
    If frmFormGet.FormToLoad = "" Then Exit Sub ' Cancel selected

    frmImage.FormImage = frmFormGet.FormToLoad
    frmImage.FormStyle = "A"

    Load frmImage
    frmImage.Show</code></pre>
<p>
After a selection is made, the image form is loaded in A (amend) mode. The code for frmFormGet<i> </i>selects all of the forms for the project from the database and sets a set of properties, depending on the selection. These are used in frmImage, which we’ll look at next.</p>
<p>
<b>The Image form</b>  This form has functionality similar to that of the irregular hot spot editor of the previous project. You set up the form details, define hot spot regions, and save the hot spot regions to the database. The functionality is extended in that you can define actions for each hot spot and each is saved in the database and can be tested there. For this demonstration application, the actions available are showing a BMP, playing a WAV file, or playing an AVI file. In a commercial system, these actions could be extended to allow for the playing of other multimedia files or animating the hot spot that was clicked. When the hot spots are loaded from the database, a visual representation is added by creating a brush icon and filling in the defined polygon. You can then test the hot spot actions, alter the action details, or add new hot spots. The Image form at run time is shown in Figure 11-10.</p>
<p>
<img src="f11rf10.gif" border=0></p>
<p class=blue>
<b>Figure 11-10  The Image form with hot spots defined at run time</b></p>
<p>
As you can see in Figure 11-10, two hot spots are defined for the image. To clearly show the hot spot definitions, the two defined are not actually on the image itself. Once again, in a commercial application, you should ensure that the hot spot definitions fit the image. Before the form is called from the MDI parent form (or the form get dialog box), the <i>FormStyle </i>and <i>FormImage </i>custom properties are set. These are used in the FormLoad event, which loads the form with all of its hot spots:</p>
<pre><code>Private Sub Form_Load()
Dim nSpot As Integer ' Current hot spot
Dim nPoints As Integer ' Number of points for the hot spot
Dim sSQL As String ' SQL
Dim lReturn As Long ' Return from API calls

    ' Open the recordsets, restricting them to the current
    ' project and version.

    Me.Width = 7480 ' Set the initial form size.
    Me.Height = 6200
    sSQL = ""
    sSQL = sSQL &amp; " SELECT * "
    sSQL = sSQL &amp; " FROM"
    sSQL = sSQL &amp; " HotSpot"
    sSQL = sSQL &amp; " WHERE"
    sSQL = sSQL &amp; "     HotSpot.ProjID = '" &amp; _
        sPuCurrProject &amp; "'"
    sSQL = sSQL &amp; " AND HotSpot.Version = '" &amp; _
        sPuCurrVers &amp; "'"

    Set rsPiSpot = dbPuProj.OpenRecordset(sSQL, _
        dbOpenDynaset)

    sSQL = ""
    sSQL = sSQL &amp; " SELECT * "
    sSQL = sSQL &amp; " FROM"
    sSQL = sSQL &amp; " HotSpotPoint"
    sSQL = sSQL &amp; " WHERE"
    sSQL = sSQL &amp; "     HotSpotPoint.ProjID = '" &amp; _
        sPuCurrProject &amp; "'"
    sSQL = sSQL &amp; " AND HotSpotPoint.Version = '" &amp; _
        sPuCurrVers &amp; "'"

    Set rsPiPoint = dbPuProj.OpenRecordset(sSQL, _
        dbOpenDynaset)

    sSQL = ""
    sSQL = sSQL &amp; " SELECT * "
    sSQL = sSQL &amp; " FROM"
    sSQL = sSQL &amp; " Form"
    sSQL = sSQL &amp; " WHERE"
    sSQL = sSQL &amp; "     Form.ProjID = '" &amp; _
        sPuCurrProject &amp; "'"
    sSQL = sSQL &amp; " AND Form.Version = '" &amp; _
        sPuCurrVers &amp; "'"

    Set rsPiForm = dbPuProj.OpenRecordset(sSQL, dbOpenDynaset)

    bPuStart = False

    nPuPointIndex = -1
    bPiDirty = False
    bPiAction = False
    nPuHotIndex = 0
    ReDim lPuHotSpots(0)

    Select Case sPiStyle

    Case "N" ' It's a new image.
        ' Set the picture property of the image.
        lblLocation.Caption = App.Path &amp; "\AppFig\" &amp; sPiImage
        picImage.Picture = LoadPicture(lblLocation.Caption)
        sPuImageFile = sPiImage

    Case "A" ' Load a previously saved image and hot spots.

        Call ResetHotSpots

        ' Set a hatch brush.
        hPiBrush = WinCreateHatchBrush(1, vbButtonFace)

        ' Get the image details.

        txtImageID.Text = sPiImage
        txtImageID.Enabled = False
        lblLocation.Caption = App.Path &amp; _
            "\AppFig\" &amp; sPuImageFile
        txtCalls.Text = frmFormGet.FormCalls
        txtCalledBy.Text = frmFormGet.FormCalledBy
        picImage.Picture = LoadPicture(lblLocation.Caption)

        ' Check to see whether any hot spots are declared.
        rsPiSpot.FindFirst "FormID = '" &amp; sPiImage &amp; "'"
            If rsPiSpot.NoMatch Then
            MsgBox " There are no hot spots declared yet " &amp; _
                "for this image", vbInformation, "Image Load"
            Exit Sub
        End If

        ' Set up the current hot spots from the points table.
        rsPiPoint.FindFirst "FormID = '" &amp; sPiImage &amp; "'"

        nSpot = rsPiPoint!HotSpotID
        nPoints = 0
         Do
            If nSpot = rsPiPoint!HotSpotID Then ' Same hot spot
                PolyPoints(rsPiPoint!PointNo).x = rsPiPoint!x
                PolyPoints(rsPiPoint!PointNo).y = rsPiPoint!y
                nPoints = nPoints + 1
            Else ' Create the hot spot region and save it.
                ReDim Preserve lPuHotSpots(nSpot)
                lPuHotSpots(nSpot) = WinCreatePolygonRgn( _
                    PolyPoints(0), nPoints, 0)

                lReturn = WinFillRgn(picImage.hdc, _
                    lPuHotSpots(nSpot), hPiBrush)

                nSpot = rsPiPoint!HotSpotID

                PolyPoints(rsPiPoint!PointNo).x = rsPiPoint!x
                PolyPoints(rsPiPoint!PointNo).y = rsPiPoint!y
                nPoints = 1

            End If
            rsPiPoint.FindNext "FormID = '" &amp; sPiImage &amp; "'"
            If rsPiPoint.NoMatch Then ' Save the last hot spot.
                ReDim Preserve lPuHotSpots(nSpot)
                rsPiPoint.FindLast "FormID = '" &amp; _
                    sPiImage &amp; "'"
                lPuHotSpots(nSpot) = WinCreatePolygonRgn( _
                    PolyPoints(0), rsPiPoint!PointNo + 1, 0)
                lReturn = WinFillRgn(picImage.hdc, _
                    lPuHotSpots(nSpot), hPiBrush)

                nPuHotIndex = rsPiPoint!HotSpotID

                rsPiPoint.FindNext "FormID = '" &amp; _
                    sPiImage &amp; "'"
            End If

        Loop Until rsPiPoint.NoMatch

        txtImageID.Text = sPiImage
        txtImageID.Enabled = False

    End Select
    WinDeleteObject (hPiBrush)

End Sub</code></pre>
<p>
The initial SQL sets up and loads the recordsets for the form, hot spots, and hot spot points, which are restricted to the current project and version. This code is fairly mundane and can be reviewed on the CD.</p>
<p>
Next, the flags and indexes are initialized. You will notice a new flag called <i>bPiAction</i>, which didn’t appear in the hot spot editor project. This will be used to determine whether the user wants to set up or amend hot spot action details.</p>
<p>
The select case determines the mode of the form, which will be N (new) or A (amended). For a new image, the image is loaded, and the user can then create a form ID and set up hot spots. For an amended image, a brush icon is first created, and then the image details are retrieved from the database as in the hot spot editor project. The only addition to this section of code is that the Windows API call <i>fillrgn </i>is used to give a visual indication as to where the hot spots are defined on the image. The hot spot image is inverted because the pen type is set to 6-invert. After all of the hot spots are declared and painted, the brush is destroyed.</p>
<p>
<b>The Form menu</b>  The items on the Form menu reset the form details and exit the form. The majority of the work is undertaken by the Hot Spot menu items. The New Hot Spot menu item is the same as in the irregular hot spot editor project except that it sets the flags to indicate that a new hot spot is to be drawn. The Save Hot Spot item is identical to its counterpart in the hot spot editor project. It saves the hot spot details and all of the hot spot points to the database. The Set Hot Spot Action item sets the <i>bAction </i>flag to True so that it can be picked up in the mouse events and calls the Action Set Up dialog box. The final item, Test Hot Spot, sets the flags so that the hot spot action can be tested. This is detected in the MouseUp event for the picture:</p>
<pre><code>Private Sub picImage_MouseUp(Button As Integer, _
    Shift As Integer, x As Single, y As Single)

Dim nDiffX As Integer
Dim nDiffY As Integer ' X and Y differences used to
                      ' close polygon
Dim nIndex As Integer ' Index of current hot spot
Dim nReply As Integer ' Reply to message box

    ' Check whether draw mode off and hot spot clicked.
    If bPuDraw = False And bPiAction = False Then
        ' Hot spot clicked and test required

         nIndex = nHotSpot(x, y) ' Decide which hot spot clicked.
        ' Run the action required.
        Call ActionRun(nIndex)

    End If

    ' Check whether it's an action setup.
    If bPuDraw = False And bPiAction Then ' Set up an action
                                          ' for the current
                                          ' hot spot.
        nIndex = nHotSpot(x, y) ' Decide which hot spot clicked.
        If nIndex &lt;&gt; -1 Then
            nReply = MsgBox("Do you want to set up an " &amp; _
                "action for this hot spot", _
                vbQuestion + vbYesNo, "Hot Spot Action")
        Else
            Exit Sub ' Not on a hot spot, so no action set up.
        End If
        If nReply = vbNo Then Exit Sub

        ' Set up an action for this hot spot.
        With frmAction
            .HotSpotID = nIndex
            .FormID = txtImageID.Text
        End With
        Load frmAction
        frmAction.Show vbModal
        bPiAction = False
        Exit Sub
    End If ' End of Action setup check

    If bPuDraw And nPuPointIndex &gt; 0 Then ' We are in
                                          ' drawing mode.

        ' Check whether we're close to the start to close the polygon.
        nDiffX = Abs(PolyPoints(0).x - x)
        nDiffY = Abs(PolyPoints(0).y - y)

        ' Check to see whether we're within 10 pixels, and
        ' close the polygon.
        If nDiffX &lt; 11 And nDiffY &lt; 11 Then bPuDraw = False
    End If ' End of first draw check.
End Sub</code></pre>
<p>
The main addition to this event is the test to see whether a test of the hot spot is required. Instead of the Select Case that we saw in the hot spot editor project, we now have a call to the <i>ActionRun </i>procedure, passing it the index of the hot spot that is clicked. This is used to test the action that’s set up for the hot spot:</p>
<pre><code>Private Sub ActionRun(ByVal inHotSpotID As Integer)
' This procedure runs the action associated with the hot spot
' if one has been set up.
Dim lReturn     As Long ' The return details from the MCI
Dim sMCIReturn  As String * 128 ' MCI return string
Dim sSQL        As String ' SQL for the find clause
Dim nFileNo     As Integer ' File number
Dim sLine       As String ' Text line

Static bAviOpen As Boolean ' Is AVI playing?
Static bWavOpen As Boolean ' Is WAV playing?

    On Error GoTo ErrDetect

    If inHotSpotID = -1 Then Exit Sub ' Not on a hot spot

    sSQL = "HotSpotID = " &amp; inHotSpotID
    sSQL = sSQL &amp; " AND FormID = '" &amp; sPiImage &amp; "'"
    ' Now find the hot spot record.
    rsPiSpot.FindFirst sSQL

    ' Now undertake the required multimedia action. It will
    ' select the type of call to the MCI, depending on the
    ' action retrieved.

    ' Play the multimedia file, depending on its extension.

    Select Case rsPiSpot!Action

    ' WAV files
    Case "P"
        ' If a WAV file is open, then...
        If bWavOpen Then
            ' Stop it, and close it.
            lReturn = WinmciSendString("Stop WaveFile", _
                "", 0, 0)
            lReturn = WinmciSendString("Close WaveFile", _
                "", 0, 0)
        End If

        ' Set the WAV file open flag to True.
        bWavOpen = True

        ' Open it.
        lReturn = WinmciSendString("Open " &amp; App.Path &amp; _
            "\AppWav\" &amp; rsPiSpot!ActionFile &amp; _
            " alias WaveFile type WaveAudio", "", 0, 0)

        ' Play it (NoWAIT).
        lReturn = WinmciSendString("Play WaveFile", "", 0, 0)

    ' AVI files
    Case "R"

    ' If an AVI file is open, then...
        If bAviOpen Then
            ' Stop it, and close it.
            lReturn = WinmciSendString("Stop AviFile", _
                "", 0, 0)
            lReturn = WinmciSendString("Close AviFile", _
                "", 0, 0)
        End If

        ' Set the AVI file open flag.
        bAviOpen = True

        ' Open it.
        lReturn = WinmciSendString("Open " &amp; App.Path &amp; _
            "\AppAvi\" &amp; rsPiSpot!ActionFile &amp; _
            " alias AviFile type AviVideo", "", 0, 0)
        ' Play it, wait for it to finish, and then close.
            lReturn = WinmciSendString( _
                "Play AviFile wait ", "", 0, 0)
            lReturn = WinmciSendString( _
                "Close AviFile", "", 0, 0)

    Case "S" ' BMP
        imgAction.Picture = LoadPicture(App.Path &amp; _
            "\AppFig\" &amp; rsPiSpot!ActionFile)
        picImage.Visible = False
        imgAction.Visible = True

    Case "T" ' Text
        ' Open the file.
        nFileNo = FreeFile
        Open App.Path &amp; "\AppFig\" &amp; _
            rsPiSpot!ActionFile For Input As #nFileNo
        ' Read the records and load into RTF text box.
        Do While Not EOF(nFileNo)
            Line Input #nFileNo, sLine
            txtText.Text = txtText.Text &amp; sLine &amp; vbCrLf
        Loop
        Close #nFileNo
        txtText.Visible = True

    Case Else ' No action set up
        MsgBox "You have not set an action up " &amp; _
            "for hot spot number " &amp; Val(inHotSpotID)

    End Select
    Exit Sub

ErrDetect:
' Error trap
    If Err.Number = 53 Then ' Missing action file
        MsgBox "The path of the file for the hot spot " &amp; _
            "action is incorrect. Please reset the action", _
            vbCritical, "Action Path Error"
        Exit Sub
    End If

    MsgBox "The error '" &amp; Err.Description &amp; _
        "' has occurred.", vbCritical

End Sub</code></pre>
<p>
The initial section of code builds an SQL statement that gets the hot spot record from the database. This will contain the action that has been set up, which is then used in the following Select Case statement to determine the multimedia action required. This code should look familiar to you—it’s similar to the code used in the spoken help application we developed earlier. The main difference is that the AVI file is now played in wait mode, which means that the system will wait until it’s finished before resuming. The file is played in the default window.</p>
<p>
In the presenter, we will look at how we can create our own window and use this to play the AVI clips. This is a useful technique for multimedia developments because you can play video clips wherever you want them and build this feature into your custom user interface.</p>
<p>
The Case Else statement is triggered when no actions are set up for the current hot spot, and a message is displayed to the user. This, in effect, tests the hot spot region, even though no actions have been set up.</p>
<p>
<b>Additional details</b>  Most of the general functions in the CBT builder application have been generated at this point, and the specific functionality has been built on the projects that we created earlier (with some small alterations). What we now have is an application that will allow you to create projects and, within projects, form details that can be used as a basis for end user training. We’ve managed to link graphics, text, sound, and video to these forms, and there is no limit (within reason) to the amount of information that we can log for each form in a project. Now that we have these details logged, we need to be able to present them to the user.</p>
<p>
As with the builder, the demonstration presenter will concentrate on techniques rather than bells and whistles, but we will look at ways to enhance the application as we go.</p>
<h1></h1>
</BODY>
</HTML>
