<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Develop a Coupling Strategy</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><a name="developcouplingstrategy"></a>Develop a Coupling Strategy</h1>
<p>
Nonspecified code can often suffer problems caused by tight coupling. Because nonspecified code doesn’t form part of a major unit, programmers often pay less attention to its interaction with other parts of the application. Where possible, you should pass parameters into procedures rather than use module-level variables. Input parameters that won’t need to be changed should always be declared by value (<i>ByVal</i>) rather than the default, by reference (<i>ByRef</i>). Many programmers choose the by reference method simply because it saves typing. </p>
<p>
Another common excuse for using <i>ByRef </i>is the argument of speed: passing by reference is a few milliseconds faster than passing by value because Visual Basic has to create a copy of the variable when it’s passed by value. But the consequence of misusing <i>ByRef</i> can be severe in terms of debugging time. Imagine a seldom-used application configuration variable that gets inadvertently changed by another procedure. You might not detect the error until someone uses the configuration function several times, maybe even long after you’ve written the code. Now imagine trying to trace the cause of the problem! As a rule, always pass parameters by value unless you explicitly want changes to be passed back to the caller.</p>
<p>
The purposes of passing parameters to a procedure rather than using module-level variables are to make it obvious to anyone not familiar with the code exactly what external dependencies are being used and to allow the procedure to be rewritten or reused more easily. A good practice is to document procedure parameters in a header box. A header box is simply a series of comments at the beginning of a procedure that explain the purpose of the procedure. Any external dependencies should also be documented here. Often programmers do not reuse functionality simply because the parameters or dependencies are unclear or not easy to understand. Imagine a procedure that accepts an array containing 20 data items. If the procedure is dependent on all 20 data items being present, other programmers might find it difficult to use unless it is well documented.</p>
<p>
Passing parameters to procedures allows you to create code that is loosely coupled and therefore potentially reusable. The following code fragment shows a would-be reusable procedure that is too tightly coupled to the form it’s in to be reused anywhere else in that application, let alone in another application:</p>
<pre><code>Sub SearchForFile(ByVal isFile As String)

    ' Disable all buttons.
    cmdClose.Enabled = False
    cmdView.Enabled = False

    ' Process
    §
    labStatus = "File " &amp; isFile
    §</code></pre>
<p>
The procedure is rewritten here in a more reusable way:</p>
<pre><code>Sub cmdProcess_Click()

    Dim ctlDisableArray(0 To 1) As Control
    Dim sFile                   As String

    ' sFile = filename
    ctlDisableArray(0) = cmdClose
    ctlDisableArray(1) = cmdView

    Call SearchForFile(sFile, ctlDisableArray(), labStatus)
    §
End Sub

Sub SearchForFile(ByVal isFile As String, _
    Optional ctlDisable() As Control, _
    Optional labUpdate As Label)

    Dim nIndex   As Integer

    ' Disable all buttons if any are specified.
    If Not IsMissing(ctlDisable) Then
        For nIndex = LBound(ctlDisable) To UBound(ctlDisable)
            ctlDisable(nIndex).Enabled = False
        Next nIndex
    End If

    ' Process
    §
    If Not IsMissing(labUpdate) Then
        labUpdate = "File " &amp; isFile
    End If
    §</code></pre>
<p>
Now the procedure is totally decoupled and can be called from anywhere in the application.</p>
<p>
Another good practice to adopt is using more flexible parameter types for inputs to a procedure. In Chapter 5, Jon Burn says, “Use variants for everything.” If you take Jon’s advice, you should be careful to validate the parameters and display helpful errors. In a simple application, you can easily locate the cause </p>
<p>
of an error; but if the error occurs in a compiled ActiveX control, it might be a different story. The sample code here is the procedure declaration for a subroutine that fills a list box from an array:</p>
<pre><code>Public Sub FillList(lst As ListBox, anArray() As Integer)</code></pre>
<p>
The function might work fine, but it’s restrictive. Imagine you have another type of list box control that has some added functionality. You won’t be able to pass it into this function. It’s also possible that someone might want to use this routine with a combo box. The code will be similar, so this is a feasible request. However, you won’t be able to use the procedure above with a combo box. If the routine is part of the application, you can rewrite it; more than likely, however, you’ll write another routine instead. If the routine is in a DLL file, rewriting it might not be so easy. In the following code, the procedure header is changed to make it more generic and the rest of the code is added as well:</p>
<pre><code>Public Sub FillList(ctl As Control, anArray() As Integer)
    Dim nIndex  As Integer

    For nIndex = LBound(anArray) To UBound(anArray)
        ctl.AddItem anArray(nIndex)
    Next nIndex

End Sub</code></pre>
<p>
Notice the potential problem now in this routine, however. If any control that doesn’t have an <i>AddItem </i>method is passed to the routine, it will fail. It might be some time later, when another programmer calls the routine, that the error is detected; and if the routine is in a DLL, it might take some time to debug. What we need is some defensive programming. Always try to code as if the procedure is part of an external DLL in which other programmers cannot access the source code. In this example, you can use defensive coding in two ways: by using <i>Debug.Assert </i>or by raising an error.</p>
<p>
The <i>Debug.Assert </i>method, new to Visual Basic 5, evaluates an expression that you supply and, if the expression is false, executes a break. C programmers use these assertions in their code all the time. This method is intended to trap development-type errors that you don’t expect to occur once the system is complete. You should never use assertions in a built executable; therefore, the method has been added to the <i>Debug </i>object. In a built executable, <i>Debug.Assert </i>is ignored, just as with the <i>Debug.Print </i>method. You could use an assertion here like this:</p>
<pre><code>Public Sub FillList(ctl As Control, anArray() As Integer)

    Dim nIndex  As Integer

    ' Assert - This subroutine handles only ListBox and ComboBox.
    Debug.Assert TypeOf ctl Is ListBox Or _
        TypeOf Ctl Is ComboBox

    For nIndex = LBound(anArray) To UBound(anArray)
        §</code></pre>
<p>
This will now trap the error if the routine is running in design mode. Because the debugger will break on the assert line, it’s always best to put a comment around the assert so that another programmer triggering the assert can easily identify the problem.</p>
<p>
With our example, the assert is not a good method to use for defensive programming because we might put this routine into a DLL, in which case the assert would be ignored and the user would get an error. A better way would be to raise an error. When you raise an error, the code that calls this function will have to deal with the problem. Think of the File Open procedure in Visual Basic. If you try to open a file that doesn’t exist, the Open procedure raises an error: “File not found.” We can do the same with our routine:</p>
<pre><code>Public Sub FillList(ctl As Control, anArray() As Integer)

    Dim nIndex  As Integer
    
    Const ERR_INVALID_CONTROL = 3000
    
    If Not(TypeOf ctl Is ListBox) And _
        Not(TypeOf ctl Is ComboBox) Then
    
        Err.Number = ERR_INVALID_CONTROL
        Err.Description = "An invalid control " &amp; ctl.Name &amp; _
            " was passed to sub 'FillList' - "
        Err.Raise Err.Number

    End If

    For nIndex = LBound(anArray) To UBound(anArray)
        §</code></pre>
<p>
This method will work in any situation, but it has two problems. The first problem is not really a problem in this instance because the caller won’t be expecting an error. If the caller were anticipating an error, however, we might want to check the error number and perform a specific action. Visual Basic 4 allowed type libraries in which you could declare constants and declarations to include in a project. The main problem with these was that you couldn’t create a type library within Visual Basic. It also meant that any client project would need to include the type library, thus increasing dependencies.</p>
<p>
In Visual Basic 5, you can use a new feature, Enum constants. Let’s see how the code looks before we explain what’s happening:</p>
<pre><code>' General declarations

Public Enum CustomErrors
    ERR_INVALID_CONTROL = 3000
    ERR_ANOTHER_ERROR
    §
End Enum

Public Sub FillList(ctl As Control, anArray() As Integer)

    Dim nIndex  As Integer
    
    If Not(TypeOf ctl Is ListBox) And _
        Not(TypeOf ctl Is ComboBox) Then
    
        Err.Number = CustomErrors.ERR_INVALID_CONTROL
        Err.Description = "An invalid control " &amp; ctl.Name &amp; _
            " was passed to sub 'FillList' - " &amp;
        §</code></pre>
<p>
The constants are declared between the Enum…End Enum, just as in a user-defined type. The Enum name can be used to explicitly scope to the correct constant if you have duplicates. Notice that the second constant in the example doesn’t have a value assigned. With enumerated constants, if you specify a value, it will be used. If you don’t specify a value, one is assigned, starting from 0 or 1 plus the previous constant. Enumerated constants can contain only long integers. The big advantage in using enumerated constants is that they can be public. For example, if you create a class, any client of that class can access the constants. Now you don’t have to have constants with global scope, and you don’t need to create type libraries. In effect, the module becomes more encapsulated.</p>
<p>
The second potential problem with the function on page 670 is that the array might be empty—but not the kind of empty that you can check with the <i>IsEmpty </i>function. If our sample code were to be passed an array that didn’t contain any elements (for example, it might have been cleared using <i>Erase</i>), you would get a “Subscript out of range” error as soon as you used <i>LBound </i>on it. A much better way of passing arrays is to use a Variant array. A Variant array is simply a variable declared as type Variant that you ReDim. If the array has no elements, <i>IsEmpty </i>will return True. You can also check that an array as opposed to, say, a string has been passed. The code looks something like this:</p>
<pre><code>Public Sub FillList(ctl As Control, vArray As Variant)

    Dim nIndex  As Integer
    
    ' Exit if array is empty.
    If IsEmpty(vArray) Then Exit Sub

    ' Exit if not an Integer array.
    If VarType(vArray) &lt;&gt; (vbArray Or vbInteger) Then
        ' Error</code></pre>
<p>
The techniques described all help you to achieve the following benefits:
<ul type=disc>
<li>
Create reusable and generic code by creating loosely coupled routines and components<br><br></li>
<li>
Help others to reuse your code<br><br></li>
<li>
Protect your code from errors caused by client code</li>
</ul>
<h1></h1>
</BODY>
</HTML>
