<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Empty and Null</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="2">
<h1><i><a name="emptynull"></a>Empty</i> and <i>Null</i></h1>
<p>
Any uninitialized Variant has the <i>Empty</i> value until something is assigned to it. This is true for all variables of type Variant, whether <i>Public</i>, <i>Private</i>, <i>Static</i>, or local. This is the first feature to distinguish Variants from other data types—you cannot determine whether any other data type is uninitialized.</p>
<p>
As well as testing for<i> VarType</i> zero, a shorthand function exists—<i>IsEmpty()</i>—which does the same thing but is more readable.</p>
<p>
In Visual Basic 3, once a Variant was given a value, the only way to reset it to <i>Empty</i> was to assign it to another Variant that itself was empty. In Visual Basic 5, you can also set it to the keyword <i>Empty</i>, as follows:</p>
<pre><code>v1 = Empty</code></pre>
<p>
I like <i>Empty</i>, although I find it is one of those things that I forget about and sometimes miss opportunities to use. Coming from a C background, where there is no equivalent to Empty, doesn’t help either. But it does have uses in odd places, so it’s worth keeping it in the back of your mind. File it under miscellaneous.</p>
<p>
Of course, <i>Null</i> is familiar to everyone as that database “no value” value, found in all SQL databases. But as a Variant subtype, it can be used to mean <i>no value </i>or <i>invalid value </i>in a more general sense—in fact, in any sense that you want to use it. Conceptually, it differs from <i>Empty</i> in that it implies you have <i>intentionally</i> set a Variant to this value for some reason, whereas <i>Empty</i> implies you just haven’t gotten around to doing anything with the Variant yet.</p>
<p>
As is the case with <i>Empty</i>, you have an <i>IsNull()</i> function and a Null keyword that you can use directly.</p>
<p>
Visual Basic programmers tend to convert a variable with a Null value—read, say, from a database—to something else as quickly as possible. I’ve seen plenty of code in which Null is converted to empty strings or zeros as soon as it’s pulled out of a recordset, even though this usually results in information loss and some bad assumptions. I think this stems from the fact that the stuff we want to do with data items—such as display them in text boxes or do calculations with them—often results in the all too familiar error 94—“Invalid use of Null.”</p>
<p>
This is exacerbated by the fact that Null propagates through expressions. Any arithmetic operator (+, -, *, /, \, Mod, ^) or comparison operator (&lt;, &gt;, =, &lt;&gt;) that has a Null as one of its operands will result in a Null being the value of the overall expression, irrespective of the type or value of the other operand. This can lead to some well-known bugs, such as:</p>
<pre><code>v = Null
If v = Null Then
    MsgBox "Hi"
End if</code></pre>
<p>
In this code, the message “Hi” will <i>not</i> be displayed because as <i>v </i>is Null, the value of the expression <i>v </i>= <i>Null</i> is itself Null. And Null is treated as <i>False</i> in <i>If...Then </i>clauses.</p>
<p>
The propagation rule has some exceptions. The string concatenation operator <b>&amp;</b> treats <i>Null</i> as an empty string "" if one of its operands is Null. This explains, for example, the following shorthand way of removing Null when reading values from a database:</p>
<pre><code>v = "" &amp; v</code></pre>
<p>
This will leave <i>v</i> unchanged if it is a string, unless it is Null, in which case it will convert it to "".</p>
<p>
Another set of exceptions is with the logical operators (And, Eqv, Imp, Not, Or, Xor). Here Null is treated as a third truth value, as in standard many-valued logic. Semantically, Null should be interpreted as <i>unsure </i>in this context, and this helps to explain the truth tables. For example:</p>
<pre><code>v = True And Null</code></pre>
<p>
gives <i>v </i>the value Null, but</p>
<pre><code>v = True Or Null</code></pre>
<p>
gives <i>v </i>the value True. This is because if you know A is true but you are unsure about B, you are unsure about A and B together, but you are sure about A or B. Follow?</p>
<p>
By the way, watch out for the Not operator. Because the truth value of Null lies halfway between True and False, Not Null must evaluate to Null in order to keep the logical model consistent. This is indeed what it does.</p>
<pre><code>v = Not Null
If IsNull(v) Then MsgBox "Hi"  ' You guessed it...</code></pre>
<p>
That’s about all on Null—I think it is the trickiest of the Variant subtypes, but once you come to grips with how it behaves, it can add a lot of value.</p>
<h1></h1>
</BODY>
</HTML>
