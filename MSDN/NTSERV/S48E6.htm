<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Stripe Set</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css"><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"></HEAD><BODY BGCOLOR="#FFFFFF">
<H3 CLASS="h2">Stripe Set</H3><P CLASS="t">Stripe sets are composed of <I>strips</I> of equal size on each disk in the volume. You create a stripe set from equal sized, unallocated areas on two to 32 physical disks. For Windows&nbsp;NT Workstation and Windows&nbsp;NT Server, the size of the strips is 64K. </P>
<P CLASS="t">Conceptually, a stripe set is similar to a table in a document, where a disk is a column and a strip is one of the entries in the table. A stripe is all of the entries in one row. The next table shows how a stripe set is similar to a table. It also shows the order in which data are written to a stripe set.</P>
<P CLASS="ttl"><B>Table 4.1    Stripe set</B></P>

<TABLE COLS="5" BORDER="1" CELLPADDING="7"><COLGROUP><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="69pt" VALIGN="TOP"><COL WIDTH="69pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P CLASS="th"><B></B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Disk 1</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Disk 2</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Disk 3</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B>Disk 4</B></P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">Stripe 1</P></TD><TD VALIGN="TOP"><P CLASS="tt">1 </P></TD><TD VALIGN="TOP"><P CLASS="tt">2</P></TD><TD VALIGN="TOP"><P CLASS="tt">3</P></TD><TD VALIGN="TOP"><P CLASS="tt">4</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">Stripe 2</P></TD><TD VALIGN="TOP"><P CLASS="tt">5</P></TD><TD VALIGN="TOP"><P CLASS="tt">6</P></TD><TD VALIGN="TOP"><P CLASS="tt">7</P></TD><TD VALIGN="TOP"><P CLASS="tt">8</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">Stripe 3</P></TD><TD VALIGN="TOP"><P CLASS="tt">9 </P></TD><TD VALIGN="TOP"><P CLASS="tt">10</P></TD><TD VALIGN="TOP"><P CLASS="tt">11</P></TD><TD VALIGN="TOP"><P CLASS="tt">12</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">Stripe 4</P></TD><TD VALIGN="TOP"><P CLASS="tt">13 </P></TD><TD VALIGN="TOP"><P CLASS="tt">14</P></TD><TD VALIGN="TOP"><P CLASS="tt">15</P></TD><TD VALIGN="TOP"><P CLASS="tt">16</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">Stripe 5</P></TD><TD VALIGN="TOP"><P CLASS="tt">17 </P></TD><TD VALIGN="TOP"><P CLASS="tt">18</P></TD><TD VALIGN="TOP"><P CLASS="tt">19</P></TD><TD VALIGN="TOP"><P CLASS="tt">20</P></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t">The next figure shows a stripe set using four disks. A strip is one of the blocks on one of the disks. Like the preceding table, stripe 1 consists of the four strips that are the first block on each of the four disks. Stripe 5 is made up of the strips that are the last block on each disk.</P>
<P><img src="xsr_e01.gif"></P>
<P CLASS="cap"><B>Figure 4.1.    Stripe set </B></P>
<P CLASS="t">When you write data to a stripe set, the data are written <I>across</I> the strips in the volume. Thus, using the Table 4.1 and Figure 4.1 as the example, if you wrote a file that was 325K long, it would occupy the following areas:</P>
<UL><LI>64K on strip 1 of disk 1.</LI><LI>64K on strip 1 of disk 2.</LI><LI>64K on strip 1 of disk 3.</LI><LI>64K on strip 1 of disk 4</LI><LI>64K on strip 2 of disk 1.</LI><LI>5K on strip 2 of disk 2.</LI></UL><P CLASS="t">The physical disks in a stripe set do not need to be identical, but there must be unpartitioned areas available on each disk that you want to include in the volume. You cannot add disks to a stripe set if you need to increase the size of the volume later, because Windows&nbsp;NT would have to move the data around on the stripe set. If you want to change the size of a stripe set, you have to:</P>
<UL><LI>Back up the data.</LI><LI>Delete the stripe set by using Disk Administrator.</LI><LI>Create a new stripe set, also by using Disk Administrator.</LI><LI>Restore the data to the new stripe set.</LI></UL><P CLASS="t">Stripe sets do not contain any redundant information. Therefore, the cost per MB for a stripe set is identical to that for the same amount of storage configured from a contiguous area on a single disk. Although the data are spread across multiple disks, there is no fault tolerance. When any disk fails, the whole stripe set fails, and no data can be recovered. The reliability for the stripe set is worse than the least reliable disk in the set.</P>
<P CLASS="t">You create and use a stripe set for performance reasons. Access to the data on a stripe set is usually faster than access to the same data would be on a single disk, because the I/O is spread across more than one disk. Therefore, Windows&nbsp;NT can be doing seeks on more than one disk at the same time, and can even have simultaneous reads or writes occurring. </P>
<P CLASS="t">A stripe set works well in the following environments:</P>
<UL><LI>When users need rapid read access to large databases or other data structures.</LI><LI>Storing program images, DLLs or run-time libraries for rapid loading. Operating systems that use memory mapped images, such as Windows&nbsp;NT, can benefit from using stripe sets.</LI><LI>Collecting data from external sources at very high transfer rates. This is especially useful when the collection is done asynchronously. </LI><LI>Multiple independent applications require access to data stored on the stripe set. When the operating system supports asynchronous multithreading, this insures disk reads and writes can be load balanced.</LI></UL><P CLASS="t">Stripe sets are not well suited for the following situations:</P>
<UL><LI>When programs make requests for small amounts of sequentially located data. It would probably be more efficient to use one volume on a single disk for this type of data, because other users' data requests would not be impacted as much. For example, if a program requests 8K at a time, it takes eight separate I/O requests to read or write all of the data in a 64K strip, which is not a very good use of this storage mechanism.</LI><LI>When programs make synchronous random requests for small amounts of data. This causes I/O bottlenecks because each request requires a separate seek operation. 16-bit single-threaded programs are very prone to this problem.</LI></UL></BODY></HTML>
