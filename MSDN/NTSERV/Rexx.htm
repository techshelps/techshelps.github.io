<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Regina REXX for Win32</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<h1>Regina REXX for Win32™</h1>
<p>
Copyright © 1995 Microsoft Corporation.  All rights reserved.</p>
<p>
Written for Microsoft Corporation by Ataman Software, Inc. (info@ataman.com).</p>
<p>
This document describes issues specific to the Win32 port of Regina REXX.</p>
<h2>Table of Contents</h2>
<p>
Installation4</p>
<p>
Usage4</p>
<p>
OLE Automation Support4</p>
<p>
w32CreateObject4</p>
<p>
w32ReleaseObject5</p>
<p>
w32CallFunc, w32CallProc5</p>
<p>
w32GetProperty6</p>
<p>
w32PutProperty6</p>
<p>
w32GetObject7</p>
<p>
w32GetSubObj7</p>
<p>
Win32 Registry Functions7</p>
<p>
w32ExpandEnvironmentStrings8</p>
<p>
w32RegCloseKey8</p>
<p>
w32RegConnectRegistry8</p>
<p>
w32RegCreateKey9</p>
<p>
w32RegDeleteKey9</p>
<p>
w32RegDeleteValue10</p>
<p>
w32RegEnumKey10</p>
<p>
w32RegEnumValue10</p>
<p>
w32RegFlushKey11</p>
<p>
w32RegGetKeySecDesc11</p>
<p>
w32RegLoadKey12</p>
<p>
w32RegOpenKey12</p>
<p>
w32RegQueryInfoKey12</p>
<p>
w32RegQueryValue13</p>
<p>
w32RegQueryValue13</p>
<p>
w32RegRestoreKey14</p>
<p>
w32RegSaveKey14</p>
<p>
w32RegSetKeySecDesc15</p>
<p>
w32RegSetValue15</p>
<p>
w32RegUnLoadKey16</p>
<p>
Win32 Event Log Functions16</p>
<p>
w32BackupEventLog16</p>
<p>
w32ClearEventLog17</p>
<p>
w32CloseEventLog17</p>
<p>
w32FindEventLogEntry17</p>
<p>
w32GetEventCategory18</p>
<p>
w32GetEventData18</p>
<p>
w32GetEventID18</p>
<p>
w32GetEventNumStrings19</p>
<p>
w32GetEventString19</p>
<p>
w32GetEventTimeGenerated19</p>
<p>
w32GetEventTimeWritten20</p>
<p>
w32GetEventType20</p>
<p>
w32GetNumberOfEventLogRecords20</p>
<p>
w32OpenBackupEventLog21</p>
<p>
w32OpenEventLog21</p>
<p>
w32WriteEventLog21</p>
<p>
Known Limitations22</p>
<h2>Installation</h2>
<p>
Installation is simple, just copy REXX.EXE to a directory that is in your PATH.</p>
<p>
Alternatively, you can run the SETUP.CMD file, this file runs REXX on a script called: INS-REXX.  This script will prompt for a directory name, create the directory, then copy REXX.EXE to that directory.  Finally, it will add that directory to your PATH environment variable. You will need to logoff and log back on before this new PATH setting takes effect.</p>
<h2>Usage</h2>
<p>
Prepare a script file using NOTEPAD.EXE, or other text file editor.  To execute the script, run REXX.EXE with the name of the script file.</p>
<p>
Example:</p>
rexx myscript.rexx</code>
<p>
A new feature in CMD.EXE under Windows NT 3.51 allows the same script above to</p>
<p>
be started as:</p>
<p>
Example:</p>
myscript.rexx</code>
<p>
For information on how to do this, see the documentation under the<b> /X</b> switch when you type <b>CMD /?.</b></p>
<h2>OLE Automation Support</h2>
<p>
The OLE Automation support closely parallels that found in Microsoft Visual Basic 3.0.</p>
<p>
The &ldquo;OLEAUTO&rdquo; subdirectory contains three REXX files that use OLE Automation with Microsoft Word, Microsoft Excel and a sample application called DspCalc2.  See the &ldquo;README.TXT&rdquo; file in that subdirectory for more information on the samples.</p>
<p>
<b>w32CreateObject</b></p>
<p>
The <b>w32CreateObject</b> function is the most common way to access an OLE Automation object.  This function launches (if necessary) the OLE Automation server and returns a handle through which the OLE Automation object can be manipulated.</p>
<p>
Syntax:</p>
<i>ObjectHandle</i> <b>=</b> <b>w32CreateObject</b> <b>(</b> <i>OLEAutomationServerClassName </i><b>)</b></code>
<p>
Example:</p>
wrd = w32CreateObject(&ldquo;Word.Basic&rdquo;)</code>
<p>
<b>w32ReleaseObject</b></p>
<p>
The <b>w32ReleaseObject</b> subroutine is called to free up the resources obtained when an OLE Automation object was created or otherwise obtained.  If you do not call <b>w32ReleaseObject</b>, the resources will remain in use until REXX exits.</p>
<p>
Syntax:</p>
<b>call w32ReleaseObject </b><i>ObjectHandle</i></code>
<p>
Example:</p>
call w32ReleaseObject wrd</code>
<p>
Valid object handles are those obtained by calls to <b>w32CreateObject</b>, <b>w32GetObject</b>, <b>w32GetSubObj</b>, <b>w32GetProperty</b> and <b>w32CallFunc</b>.</p>
<p>
<b>w32CallFunc, w32CallProc</b></p>
<p>
The <b>w32CallFunc</b> function is used to access a method of an OLE Automation object where you expect to receive a return value.  If no return value is needed, use w32CallProc instead.</p>
<p>
Syntax:</p>
<i>ReturnValue</i> <b>=</b> <b>w32CallFunc</b> <b>(</b> <i>ObjectHandle</i><b>,</b> <i>MethodName</i><b>,</b><i></i><b>[</b><i> TypeList</i> <b>],</b><i> </i><b>[</b> <i>Argument</i><b>,</b><i> </i><b>...</b> <b>]</b><i> </i><b>)</b>
<b>w32CallProc</b> <b>(</b> <i>ObjectHandle</i><b>,</b> <i>MethodName</i><b>,</b> <b>[</b><i> TypeList</i> <b>],</b> <b>[</b> <i>Argument<b>,</b> </i><b>... ]<i> </i>)</b></code>
<p>
Examples:</p>
SalesValue = w32CallFunc(wrd, &ldquo;GetMergeField$&rdquo;, , &ldquo;Sales&rdquo;)
w32CallProc(wrd, &ldquo;FileNew&rdquo;,  &lsquo;si&rsquo;, &ldquo;Normal&rdquo;,  0)</code>
<p>
Optional arguments to the method can be omitted, leaving only the corresponding &ldquo;,&rdquo; as in the example for <b>w32CallFunc</b> above.</p>
<p>
The <i>TypeList</i> is optional, and for many OLE Automation servers is unnecessary because automatic type conversion is usually done by the OA server.  REXX is an untyped language and all its data are stored as strings, thus, if <i>TypeList</i> is omitted, all arguments will be sent to the OA server as strings.  However some OA servers, such as Microsoft Word, require correct typing of parameters.  The <i>TypeList</i> is simply a series of characters that define the type of each  argument that follows.  There should be as many type characters list in the <i>TypeList</i> as there are arguments listed.  The type character for an omitted argument is ignored, but must be present. (I usually use &lsquo; &lsquo; as the type character for omitted arguments.)</p>
<p>
<b>Type Required</b></p>
<p>
<b>Type Character</b></p>
<p>
Boolean</p>
<p>
<b>b</b></p>
<p>
Currency</p>
<p>
<b>c</b></p>
<p>
Date</p>
<p>
<b>d</b></p>
<p>
Integer (16-bit)</p>
<p>
<b>i</b></p>
<p>
Integer (32-bit)</p>
<p>
<b>I</b></p>
<p>
Object Handle</p>
<p>
<b>o</b></p>
<p>
Real Number (4 byte)</p>
<p>
<b>r</b></p>
<p>
Real Number (8 byte)</p>
<p>
<b>R</b></p>
<p>
String</p>
<p>
<b>s</b></p>
<p>
<b>w32GetProperty</b></p>
<p>
The <b>w32GetProperty</b> function returns the value of a named property from an OLE Automation object.</p>
<p>
Syntax:</p>
<i>ReturnValue</i> <b>=</b> <b>w32GetProperty</b> <b>(</b> <i>ObjectHandle</i><b>,</b> <i>PropertyName</i><b> )</b></code>
<p>
Example:</p>
MyCaption = w32GetProperty(xl, &ldquo;Caption&rdquo;)</code>
<p>
<b>w32PutProperty</b></p>
<p>
The <b>w32PutProperty</b> subroutine sets the value of a named property in an OLE Automation object.</p>
<p>
Syntax:</p>
<b>call</b> <b>w32PutProperty</b> <i>ObjectHandle</i><b>,</b> <i>PropertyName</i><b>,</b><i>Type</i><b>,</b> <i>Value</i></code>
<p>
Example:</p>
call w32PutProperty xl, &ldquo;Caption&rdquo;, , &ldquo;Change Window Title&rdquo;</code>
<p>
The <i>Type</i> is optional, and is defined using the same characters as <i>TypeList</i> in <b>w32CallProc</b>. The<i> Type</i> is the data type in which the OLE Automation server requires <i>Value</i> to be expressed.</p>
<p>
<b>w32GetObject</b></p>
<p>
The <b>w32GetObject</b> function is similar to <b>w32CreateObject</b>.  It gets an object that previously exists either saved in a disk file, or in already running OLE Automation server.  It returns a handle through which the OLE Automation object can be manipulated.</p>
<p>
Syntax:</p>
<i>ObjectHandle</i> <b>=</b> <b>w32GetObject</b> <b>(</b> <b>[</b> <i>Filename</i><b> ], [</b> <i>OAServerClassName</i> <b>]<i> </i>)</b></code>
<p>
Example:</p>
xl = w32GetObject(&ldquo;D:\MYDIR\SPREADSHEET.XLS&rdquo;)</code>
<p>
<b>w32GetSubObj</b></p>
<p>
Some OLE Automation servers, such as Microsoft Excel, have methods that return handles to sub-objects.  The <b>w32GetSubObj</b> function is a bit of syntactic sugar that works exactly like <b>w32CallFunc</b>.  The only difference is that the return value must be the handle of an object.</p>
<p>
Syntax:</p>
<i>ObjectHandle</i> <b>=</b> <b>w32GetSubObj</b> <b>(</b> <i>ObjectHandle</i><b>,</b> <i>MethodName</i><b>,</b><i></i><b>[</b><i> TypeList</i> <b>],</b><i> </i><b>[</b> <i>Argument</i><b>,</b><i> </i><b>...</b> <b>]</b><i> </i><b>)</b></code>
<p>
Example:</p>
wbs = w32GetSubObj(xl, &ldquo;WorkBooks&rdquo;)</code>
<p>
Object handles obtained by <b>w32GetSubObj</b> should be released by <b>w32ReleaseObject</b> when no longer needed.</p>
<h2>Win32 Registry Functions</h2>
<p>
The Win32 registry functions closely parallels the corresponding C functions found in the Win32 API.  The descriptions below are fairly brief.  Consult the Win32 SDK documentation for more detailed information.</p>
<p>
The &ldquo;W32FUNCS&rdquo; subdirectory contains an example file: &ldquo;registry.rexx&rdquo; that uses the registry functions.  See the &ldquo;README.TXT&rdquo; file in that subdirectory for more information on this example.</p>
<p>
<b>WARNING:  The Win32 Registry contains information vital to the functioning of your system.  The functions below should be used with caution.</b></p>
<p>
<b>w32ExpandEnvironmentStrings</b></p>
<p>
The <b>w32ExpandEnvironmentStrings</b> function expands environment variables (names are denoted by preceding and trailing &lsquo;%&rsquo;) in the string argument using the process&rsquo; environment.  It returns the expanded string.</p>
<p>
Syntax:</p>
<i>expanded_string</i> <b>=</b> <b>w32ExpandEnvironmentStrings</b> <b>(</b> <i>string </i><b>)</b></code>
<p>
Example:</p>
path = w32ExpandEnvironmentStrings(&ldquo;PATH=%PATH%&rdquo;)
say path /* says: PATH=C:\WINNT\system32;C:\WINNT;... */</code>
<p>
<b>w32RegCloseKey</b></p>
<p>
The <b>w32RegCloseKey</b> subroutine closes a key handle returned by <b>w32RegOpenKey</b>, <b>w32RegConnectRegistry</b>, or <b>w32RegCreateKey</b>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegCloseKey</b> <i>KeyHandle</i></code>
<p>
Example:</p>
call w32RegCloseKey hkey;</code>
<p>
<b>w32RegConnectRegistry</b></p>
<p>
The <b>w32RegConnectRegistry</b> function opens a registry key on a remote host.  It returns a handle to the remotely opened key.</p>
<p>
Syntax:</p>
<i>hkeyRet </i><b>=</b><i> </i><b>w32RegConnectRegistry</b> <b>( </b><i>hostname</i>,<b> </b><i>hkey</i><b> )</b></code>
<p>
Example:</p>
hk = w32RegConnectRegistry(&ldquo;\\mainserver&rdquo;, &ldquo;HKEY_LOCAL_MACHINE&rdquo;)</code>
<p>
<i>Hkey</i> should be one of the string constants <b>HKEY_LOCAL_MACHINE</b> or <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegCreateKey</b></p>
<p>
The <b>w32RegCreateKey</b> creates or opens a subkey under a registry key.  It returns a handle to the subkey created or opened.</p>
<p>
Syntax:</p>
<i>hkeyRet </i><b>=</b><i> </i><b>w32RegCreateKey</b> <b>( </b><i>hkey</i>,<b> </b><i>subkeyname</i><b> )</b></code>
<p>
Example:</p>
hk = w32RegCreateKey(&ldquo;HKEY_LOCAL_MACHINE&rdquo;,&ldquo;Software\Microsoft\NewProduct&rdquo;)</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegDeleteKey</b></p>
<p>
The <b>w32RegDeleteKey</b> subroutine deletes the key <i>subkey</i>, which must be located under the key <i>hkey</i>.  All values under <i>subkey</i> are also deleted.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegDeleteKey</b> <i>hkey</i><b>,</b> <i>subkey</i></code>
<p>
Example:</p>
call w32RegDeleteKey hk, &ldquo;WidgetTuningParameters&rdquo;</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegDeleteValue</b></p>
<p>
The <b>w32RegDeleteValue</b> subroutine deletes the value named <i>valuename</i>, which must be located under the key <i>hkey</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegDeleteValue</b> <i>hkey</i><b>,</b> <i>valuename</i></code>
<p>
Example:</p>
call w32RegDeleteValue whk, &ldquo;WidgetMaximumSize&rdquo;</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT</b>_<b>USER, HKEY_LOCAL</b>_<b>MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegEnumKey</b></p>
<p>
The <b>w32RegEnumKey</b> function returns the name of the subkey of <i>hkey</i> specified by <i>index</i>.</p>
<p>
Syntax:</p>
<i>subkeyname </i><b>=</b><i> </i><b>w32RegEnumKey ( </b><i>hkey</i>,<b> </b><i>index</i><b> )</b></code>
<p>
Example:</p>
firstsubkey = w32RegEnumKey(&ldquo;HKEY_LOCAL_MACHINE&rdquo;, 0)</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<i>Index </i>ranges from 0 to <code>w32RegQueryInfoKey(<i>hkey</i>, &ldquo;NumSubKeys&rdquo;)-1</code>.</p>
<p>
<b>w32RegEnumValue</b></p>
<p>
The <b>w32RegEnumValue</b> function returns the name of the value under <i>hkey</i> specified by <i>index</i>.</p>
<p>
Syntax:</p>
<i>valuename </i><b>=</b><i> </i><b>w32RegEnumValue ( </b><i>hkey</i>,<b> </b><i>index</i><b> )</b></code>
<p>
Example:</p>
firstvalue = w32RegEnumValue(&ldquo;HKEY_LOCAL_MACHINE&rdquo;, 0)</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<i>Index </i>ranges from 0 to <code>w32RegQueryInfoKey(<i>hkey</i>, &ldquo;NumValues&rdquo;)-1</code>.</p>
<p>
<b>w32RegFlushKey</b></p>
<p>
The <b>w32RegFlushKey</b> subroutine cause all changes in a key to be flushed immediately to disk.  The use of this subroutine is normally not necessary and should only be used in very unusual circumstances.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegFlushKey</b> <i>hkey</i></code>
<p>
Example:</p>
call w32RegFlushKey hk</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegGetKeySecDesc</b></p>
<p>
The <b>w32RegGetKeySecDesc</b> function returns a hexadecimal string representing the self-relative security descriptor associated with key <i>hkey</i>.</p>
<p>
Syntax:</p>
<i>secdesc </i><b>=</b><i> </i><b>w32RegGetKeySecDesc ( </b><i>hkey </i><b>)</b></code>
<p>
Example:</p>
secdesc = w32RegGetKeySecDesc(&ldquo;HKEY_LOCAL_MACHINE&rdquo;)</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegLoadKey</b></p>
<p>
The <b>w32RegLoadKey</b> subroutine creates  subkey <i>subkeyname</i> under the key <i>hkey</i> using the key hive stored in <i>filename</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegLoadKey</b> <i>hkey</i><b>,</b><i> subkeyname</i><b>,</b><i> filename</i></code>
<p>
Example:</p>
call w32RegLoadKey hk, &ldquo;Stuff&rdquo;, &ldquo;D:\keyhives\stuff&rdquo;</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegOpenKey</b></p>
<p>
The <b>w32RegOpenKey</b> opens a subkey under a registry key.  It returns a handle to the subkey opened.</p>
<p>
Syntax:</p>
<i>hkeyRet </i><b>=</b><i> </i><b>w32RegOpenKey</b> <b>( </b><i>hkey</i>,<b> </b><i>subkeyname</i><b> )</b></code>
<p>
Example:</p>
hk = w32RegOpenKey(&ldquo;HKEY_LOCAL_MACHINE&rdquo;,&ldquo;Software\Microsoft\NewProduct&rdquo;)</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegQueryInfoKey</b></p>
<p>
The <b>w32RegQueryInfoKey</b> returns the requested information about key <i>hkey</i>.</p>
<p>
Syntax:</p>
<i>info </i><b>=</b><i> </i><b>w32RegQueryInfoKey</b> <b>( </b><i>hkey</i>,<b> </b><i>infoname</i><b> )</b></code>
<p>
Example:</p>
nKeys = w32RegQueryInfoKey(hkey, &ldquo;NumSubKeys&rdquo;)</code>
<p>
<b><i>infoname</i></b></p>
<p>
<b>Value Returned</b></p>
<p>
<b>NumSubKeys</b></p>
<p>
Number of subkeys under <i>hkey</i>.</p>
<p>
<b>MaxSubKeyName</b></p>
<p>
Length of longest subkey name.</p>
<p>
<b>NumValues</b></p>
<p>
Number of values under <i>hkey</i>.</p>
<p>
<b>MaxValueName</b></p>
<p>
Length of longest value name.</p>
<p>
<b>MaxValueData</b></p>
<p>
Size of largest data item stored in a value.</p>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegQueryValue</b></p>
<p>
The <b>w32RegQueryValue</b> function returns the data stored under <i>valuename</i>. If the data is of type <b>REG_SZ</b> or <b>REG_EXPAND_SZ</b>, a string is returned.  If the data is of type <b>REG_DWORD</b>, a string representing that number is returned.  All other data types return a hexadecimal string representation of the data.</p>
<p>
Syntax:</p>
<i>value </i><b>=</b><i> </i><b>w32RegQueryValue ( </b><i>hkey</i>,<b> </b><i>valuename </i><b>)</b></code>
<p>
Example:</p>
wspeed = w32RegQueryValue(hk, &ldquo;WidgetSpeed&rdquo;)</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegQueryValue</b></p>
<p>
The <b>w32RegQueryValue</b> function returns the <i>type</i> of the data stored under <i>valuename</i>.</p>
<p>
Syntax:</p>
<i>type </i><b>=</b><i> </i><b>w32RegQueryValueType ( </b><i>hkey</i>,<b> </b><i>valuename </i><b>)</b></code>
<p>
Example:</p>
type = w32RegQueryValueType(hk, &ldquo;WidgetSpeed&rdquo;)</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<i>Type</i> is returned as one of the following strings: <b>REG_DWORD</b>, <b>REG_EXPAND_SZ</b>, <b>REG_SZ</b>, <b>REG_BINARY</b>, <b>REG_DWORD_BIG_ENDIAN</b>, <b>REG_LINK</b>, <b>REG_MULTI_SZ</b>, <b>REG_NONE</b>, <b>REG_RESOURCE_LIST</b>, <b>UNKNOWN</b>.</p>
<p>
<b>w32RegRestoreKey</b></p>
<p>
The <b>w32RegRestoreKey</b> subroutine overwrites <i>hkey</i> with information from the hive stored in <i>filename</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegRestoreKey</b> <i>hkey</i><b>,</b><i> filename</i></code>
<p>
Example:</p>
call w32RegRestoreKey hk, &ldquo;D:\keyhives\stuff&rdquo;</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegSaveKey</b></p>
<p>
The <b>w32RegSaveKey</b> subroutine saves the information in <i>hkey</i> as a hive stored in <i>filename</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegSaveKey</b> <i>hkey</i><b>,</b><i> filename</i></code>
<p>
Example:</p>
call w32RegSaveKey hk, &ldquo;D:\keyhives\stuff&rdquo;</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<b>w32RegSetKeySecDesc</b></p>
<p>
The <b>w32RegSetKeySecDesc</b> subroutine sets the security descriptor of key <i>hkey</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegSetKeySecDesc</b> <i>hkey</i><b>,</b><i> secdesc</i></code>
<p>
Example:</p>
call w32RegSetKeySecDesc hk, &ldquo;ff00...&rdquo;</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<i>SecDesc </i>is a hexadecimal string representing a self-relative security descriptor.  The easiest way to make one is to create a temporary key with <b>REGEDT32.EXE</b>, set its security, then use the <b>w32RegGetKeySecDesc</b> to obtain the security descriptor.</p>
<p>
<b>w32RegSetValue</b></p>
<p>
The <b>w32RegSetValue</b> subroutine sets the value of <i>valuename</i> to <i>data</i> of type <i>type</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegSetValue</b> <i>hkey</i><b>,</b><i> valuename, type, data</i></code>
<p>
Example:</p>
call w32RegSetValue hk, &ldquo;BinaryUserInfo&rdquo;, &ldquo;REG_BINARY&rdquo;, &ldquo;ff003a&rdquo;</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_CLASSES_ROOT</b>, <b>HKEY_CURRENT_USER</b>, <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<i>Type</i> is one of the following strings: <b>REG_DWORD</b>, <b>REG_EXPAND_SZ</b>,<b> REG_SZ</b>, <b>REG_BINARY</b>, <b>REG_DWORD_BIG_ENDIAN</b>, <b>REG_LINK</b>, <b>REG_MULTI_SZ</b>, <b>REG_NONE</b>, <b>REG_RESOURCE_LIST</b>, <b>UNKNOWN</b>.</p>
<p>
<i>Data</i> is a string if type is <b>REG_SZ</b> or <b>REG_EXPAND_SZ</b>.  <i>Data</i> is a string of decimal digits if type is <b>REG_DWORD</b>.  For all other types, <i>data</i> is a hexadecimal string representing the data.</p>
<p>
<b>w32RegUnLoadKey</b></p>
<p>
The <b>w32RegUnLoadKey</b> subroutine unloads the subkey named by <i>subkeyname</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32RegUnLoadKey</b> <i>hkey</i><b>,</b><i> subkeyname</i></code>
<p>
Example:</p>
call w32RegUnLoadKey hk, &ldquo;Stuff&rdquo;</code>
<p>
<i>Hkey</i> should be a previously obtained key handle or one of the string constants: <b>HKEY_LOCAL_MACHINE</b>, <b>HKEY_USERS</b>.</p>
<p>
<i>Subkeyname</i> must be the name of a subkey that was previously created with <b>w32RegLoadKey</b>.</p>
<h2>Win32 Event Log Functions</h2>
<p>
The Win32  Event Log functions closely parallels the corresponding C functions found in the Win32 API.  The descriptions below are fairly brief.  Consult the Win32 SDK documentation for more detailed information.</p>
<p>
The &ldquo;W32FUNCS&rdquo; subdirectory contains an example file:  &ldquo;eventlog.rexx&rdquo; that uses the eventlog functions.  See the &ldquo;README.TXT&rdquo; file in that subdirectory for more information on this example.</p>
<p>
<b>w32BackupEventLog</b></p>
<p>
The <b>w32BackupEventLog</b> subroutine saves the event log opened on <i>helog</i> in the disk file specified by <i>filename</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32BackupEventLog</b> <i>helog</i><b>,</b><i> filename</i></code>
<p>
Example:</p>
call w32BackupEventLog <i>helog</i>, &ldquo;D:\keyhives\stuff&rdquo;</code>
<p>
<b>w32ClearEventLog</b></p>
<p>
The w32ClearEventLog subroutine clears the event log opened on <i>helog</i>. If the optional argument <i>filename</i> is provided, the eventlog will be saved to that file.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32ClearEventLog</b> <i>helog</i><b>,</b><i> </i><b>[</b><i> filename </i><b>]</b></code>
<p>
Example:</p>
call w32ClearEventLog <i>helog</i></code>
<p>
<b>w32CloseEventLog</b></p>
<p>
The <b>w32CloseEventLog</b> subroutine frees any resources associated with the eventlog handle <i>helog</i>.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32CloseEventLog</b> <i>helog</i></code>
<p>
Example:</p>
call w32CloseEventLog <i>helog</i></code>
<p>
<b>w32FindEventLogEntry</b></p>
<p>
The <b>w32FindEventLogEntry</b> subroutine reads the eventlog entry specified by <i>eventnum</i> into a static buffer.  This buffer is allocated on a per-process basis and any call to <b>w32CloseEventLog</b> or <b>w32FindEventLogEntry</b> on ANY HANDLE will invalidate the data from the previous call to w32FindEventLogEntry.  Data from the static buffer is accessed by the <b>w32GetEventCategory</b>,  <b>w32GetEventData</b>, <b>w32GetEventID</b>,  <b>w32GetEventNumStrings</b>, <b>w32GetEventString</b>, <b>w32GetEventTimeGenerated</b>,  <b>w32GetEventTimeWritten</b> and  <b>w32GetEventType</b> functions.</p>
<p>
Syntax:</p>
<b>call</b><i> </i><b>w32FindEventLogEntry</b> <i>helog</i><b>,</b><i> eventnum</i></code>
<p>
Example:</p>
call w32FindEventLogEntry <i>helog</i>, 1 /*Find first eventlog entry.*/</code>
<p>
<i>Eventnum</i> ranges from 1 to <code>w32GetNumberOfEventLogRecords(<i>helog</i>)</code>.</p>
<p>
<b>w32GetEventCategory</b></p>
<p>
The <b>w32GetEventCategory</b> function returns the event category associated with event log entry found in the last call to <b>w32FindEventLogEntry</b>.</p>
<p>
Syntax:</p>
<i>category </i><b>=</b><i> </i><b>w32GetEventCategory ( )</b></code>
<p>
Example:</p>
category = w32GetEventCategory()</code>
<p>
<b>w32GetEventData</b></p>
<p>
The <b>w32GetEventData</b> function returns a hexadecimal string representing the binary data associated with event log entry found in the last call to <b>w32FindEventLogEntry</b>.</p>
<p>
Syntax:</p>
<i>data </i><b>=</b><i> </i><b>w32GetEventData ( )</b></code>
<p>
Example:</p>
data = w32GetEventData()</code>
<p>
<b>w32GetEventID</b></p>
<p>
The <b>w32GetEventID</b> function returns the event identifier associated with event log entry found in the last call to <b>w32FindEventLogEntry</b>.</p>
<p>
Syntax:</p>
<i>id </i><b>=</b><i> </i><b>w32GetEventID</b> <b>( )</b></code>
<p>
Example:</p>
id = w32GetEventID()</code>
<p>
<b>w32GetEventNumStrings</b></p>
<p>
The <b>w32GetEventNumStrings</b> function returns the number of strings associated with event log entry found in the last call to <b>w32FindEventLogEntry</b>.</p>
<p>
Syntax:</p>
<i>nStrings </i><b>=</b><i> </i><b>w32GetEventNumStrings</b> <b>( )</b></code>
<p>
Example:</p>
ns = w32GetEventNumStrings()</code>
<p>
<b>w32GetEventString</b></p>
<p>
The <b>w32GetEventString</b> function returns the string denoted by <i>index</i> associated with event log entry found in the last call to <b>w32FindEventLogEntry</b>.</p>
<p>
Syntax:</p>
<i>string </i><b>=</b><i> </i><b>w32GetEventString</b> <b>( </b><i>index</i><b> )</b></code>
<p>
Example:</p>
str = w32GetEventString(1)</code>
<p>
<i>Index</i> ranges from 1 to <code>w32GetEventNumStrings()</code>.</p>
<p>
<b>w32GetEventTimeGenerated</b></p>
<p>
The w32GetEventTimeGenerated function returns (for the event log entry found in the last call to w32FindEventLogEntry) the date the event was generated.  The format of the date is that returned by the standard C function <b>asctime</b>.</p>
<p>
Syntax:</p>
<i>date </i><b>=</b><i> </i><b>w32GetEventTimeGenerated</b> <b>( )</b></code>
<p>
Example:</p>
date = w32GetEventTimeGenerated()</code>
<p>
<b>w32GetEventTimeWritten</b></p>
<p>
The <b>w32GetEventTimeWritten</b> function returns (for the event log entry found in the last call to <b>w32FindEventLogEntry</b>) the date the event was written.  The format of the date is that returned by the standard C function <b>asctime</b>.</p>
<p>
Syntax:</p>
<i>date </i><b>=</b><i> </i><b>w32GetEventTimeWritten</b> <b>( )</b></code>
<p>
Example:</p>
date = w32GetEventTimeWritten()</code>
<p>
<b>w32GetEventType</b></p>
<p>
The <b>w32GetEventType</b> function returns the numeric type associated with event log entry found in the last call to <b>w32FindEventLogEntry</b>.  Errors are type 1, Warnings are type 2, and Informational messages are type 4.</p>
<p>
Syntax:</p>
<i>nStrings </i><b>=</b><i> </i><b>w32GetEventType</b> <b>( )</b></code>
<p>
Example:</p>
ns = w32GetEventType()</code>
<p>
<b>w32GetNumberOfEventLogRecords</b></p>
<p>
The <b>w32GetNumberOfEventLogRecords</b> function returns the number of event log records in the event log opened on <i>helog</i>.</p>
<p>
Syntax:</p>
<i>nRecords </i><b>=</b><i> </i><b>w32GetNumberOfEventLogRecords</b> <b>( </b><i>helog</i><b> )</b></code>
<p>
Example:</p>
nr = w32GetNumberOfEventLogRecords()</code>
<p>
<b>w32OpenBackupEventLog</b></p>
<p>
The <b>w32OpenBackupEventLog</b> function returns a handle to the events in an eventlog backup file (created by <b>w32BackupEventLog</b> or <b>w32ClearEventLog</b>) stored on host <i>hostname</i> specified by <i>filename</i>.  If <i>hostname </i>not specified, the event log is opened on the local host.</p>
<p>
Syntax:</p>
<i>helog</i><b> =</b><i> </i><b>w32OpenBackupEventLog</b> <b>(</b><i> [hostname], filename</i><b> )</b></code>
<p>
Example:</p>
h = w32OpenBackupEventLog(, &ldquo;C:\applog.evt&rdquo;)</code>
<p>
<b>w32OpenEventLog</b></p>
<p>
The w32OpenEventLog function returns a handle to the events in the <i>sourcename</i> eventlog stored on host <i>hostname</i>.  If <i>hostname </i>not specified, the event log is opened on the local host.</p>
<p>
Syntax:</p>
<i>helog</i><b> =</b><i> </i><b>w32OpenEventLog</b> <b>(</b><i> [hostname], sourcename</i><b> )</b></code>
<p>
Example:</p>
h = w32OpenEventLog(&ldquo;\\mainserver&rdquo;, &ldquo;system&rdquo;)</code>
<p>
<b>w32WriteEventLog</b></p>
<p>
The <b>w32WriteEventLog</b> subroutine writes an event entry to the <i>sourcename</i> eventlog stored on host <i>hostname</i>.  If <i>hostname </i>not specified, the event log written to is on the local host. Errors are type 1, Warnings are type 2, and Informational messages are type 4.</p>
<p>
Syntax:</p>
<b>call</b><i> </i>w32WriteEventLog <b>[</b><i> hostname </i><b>],</b><i> sourcename</i><b>,</b><i> </i><b>[</b><i> eventtype </i><b>],</b><i></i><b>[</b><i> category </i><b>], [</b><i> eventid </i><b>], [</b><i> data </i><b>], [</b><i> string1 ... </i><b>]</b>

</code>
<p>
Example:</p>
call w32WriteEventLog , &ldquo;My REXX Prog&rdquo;, 2, , , , &ldquo;Error message&rdquo;</code>
<p>
For <i>eventtype</i>, Errors are type 1, Warnings are type 2, and Informational messages are type 4.</p>
<p>
<i>Data</i> is optional binary data to be put into the eventlog.  It is specified as a hexadecimal string.</p>
<p>
<i>Eventtype</i> defaults to 1 (Error).</p>
<p>
<i>Category</i> defaults to 0.</p>
<p>
<i>EventID</i> defaults to 0.</p>
<p>
At least one of <i>data</i> or <i>string1</i> must be present.</p>
<h2>Known Limitations</h2>
<p>
Because Win32 raises process termination and process interrupt signals in a separate thread, the <b>SIGNAL</b>  and <b>CALL</b> statements cannot be used with the <b>HALT</b> conditions.</p>
<p>
Regina has been modified to treat attempts to use the <b>HALT</b> condition as a syntax error.</p>
<p>
The implementation of the <b>STREAM</b> statement&rsquo;s &lsquo;C&rsquo; option is weak when used with the <b>READABLE</b>, <b>EXECUTABLE</b> or <b>WRITEABLE</b> commands:</p>
<p>
<font face="Symbol">&#183;</font>All regular files are considered executable.</p>
<p>
<font face="Symbol">&#183;</font>Only the older DOS-style read-only attribute is looked at to determine read-only.  Windows NT security constraints imposed under NTFS are ignored.</p>
<p>
Forcing a <b>NOTREADY</b> condition on a console "file" interacts with the underlying runtime stdio functions such that the file can never be reset. [This is a hard error to describe and one that you will probably never encounter.  To understand it, Look in the "srccode\trip.w32" file: files.rexx.  See the sections using "&lt;stdout&gt;" (tests 15 and 17) that are commented out.]</p>
<p>
At the time of this writing, Windows 95 was still in beta.  Only limited testing has been done under Windows 95.</p>

</FONT>
</BODY>
</HTML>
