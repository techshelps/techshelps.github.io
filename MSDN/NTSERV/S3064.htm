<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Open Systems Interconnect Model</title>
<style>@import url(msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="msdn_ie3.css"><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"></HEAD><BODY BGCOLOR="#FFFFFF">
<H3 CLASS="h2">The Open Systems Interconnect Model</H3><P CLASS="t">In the early years of networking, sending and receiving data across a network was confusing because large companies, such as IBM, Honeywell, and Digital Equipment Corporation had individual standards for connecting computers. The transmit and receive processes had to "talk" to the same protocols to communicate. It was unlikely that applications operating on different equipment from different vendors would be able to communicate. Vendors, users, and standards bodies needed to agree upon and implement a standard architecture that would allow computer systems to exchange information even though they were using software and equipment from different vendors.</P>
<P CLASS="t">In 1978, the International Standards Organization (ISO) introduced a model for Open Systems Interconnect (OSI) as a first step toward international standardization of the various protocols required for network communication. This ISO OSI model incorporates the following qualities.</P>
<UL><LI>It is designed to establish data-communications standards that promote multivendor interoperability.</LI><LI>It consists of seven layers, with a specific set of network functions allocated to each layer and guidelines<B> </B>for implementation of the interfaces between layers.</LI><LI>It specifies the set of protocols and interfaces to implement at each layer.</LI></UL><H4 CLASS="h3"><A NAME="sec0"></A>OSI Layers</H4><P CLASS="t">Each layer of the OSI model exists as an independent module. In theory, you can substitute one protocol for another at any given layer without affecting the operation of layers above or below, although you probably wouldn't want to do so. </P>
<P CLASS="t">The principles used to create the seven-layer model are listed below.</P>
<UL><LI>A layer should be created only when a different level of abstraction is required.</LI><LI>Each layer should perform a well-defined function.</LI><LI>The function of each layer should be chosen with the goal of defining internationally standardized protocols.</LI><LI>The layer boundaries should be chosen to minimize the information flow across the interfaces.</LI><LI>The number of layers should be large enough to enable distinct functions to be separated, but few enough to keep the architecture from becoming unwieldy. </LI></UL><P>The following diagram shows the numbering of the layers, beginning with the physical layer, which is closest to the network media.</P>
<P><img src="XNG_A05.gif"></P>
<P CLASS="cap"><B>Figure 1.3    Layers of the OSI model </B></P>
<H5 CLASS="h4"><A NAME="sec1"></A>Physical Layer</H5><P CLASS="t">The physical layer is the lowest layer of the OSI model. This layer controls the way unstructured, raw, bit-stream data is sent and received over a physical medium. This layer describes the electrical or optical, mechanical, and functional interfaces to the physical network medium. The physical layer carries the signals for all of the higher layers.</P>
<P CLASS="t">Data<B>-</B>encoding modifies the simple, digital-signal pattern (1s and 0s) used by the computer to better accommodate the characteristics of the physical medium and to assist in bit and frame synchronization.</P>
<P CLASS="t">Data encoding resolves the following issues.</P>
<UL><LI>Which signal pattern represents a binary 1</LI><LI>How the receiving station recognizes when a "bit-time" starts</LI><LI>How the receiving station delimits a frame</LI></UL><P CLASS="t">Physical medium attachment resolves the following issues.</P>
<UL><LI>Whether an external transceiver will be used to connect to the medium</LI><LI>How many pins the connectors have and what each pin is used for</LI></UL><P CLASS="t">The transmission technique determines whether the encoded bits will be transmitted by means of baseband (digital signaling or broadband (analog) signaling.</P>
<P CLASS="t">Physical-medium transmission determines whether it is appropriate to transmit bits as electrical or optical signals, based on the following criteria.</P>
<UL><LI>Which physical-medium options can be used</LI><LI>How many volts should be used to represent a given signal state in the specific physical medium</LI></UL><H5 CLASS="h4"><A NAME="sec2"></A>Data-link Layer</H5><P CLASS="t">The data-link layer provides error-free transfer of data frames from one computer to another over the physical layer. The layers above this layer can assume virtually error-free transmission over the network. </P>
<P CLASS="t">The data-link layer provides the following functions.</P>
<UL><LI>Establishing and terminating alogical link (virtual-circuit connection) between two computers identified by their unique network interface card (NIC) addresses</LI><LI>Controlling frame flow by instructing the transmitting computer not to transmit frame buffers</LI><LI>Sequentially transmitting and receiving frames</LI><LI>Providing and expecting frame-acknowledgment, and detecting and recovering from errors that occur in the physical layer by retransmitting non-acknowledged frames and handling duplicate frame receipts</LI><LI>Managing media access to determine when the computer is permitted to use the physical medium</LI><LI>Delimiting<B> </B>frames to create and recognize frame boundaries</LI><LI>Error-checking<B> </B>frames to confirm the integrity of the received frame</LI><LI>Inspecting the destination address of each received frame and determining if the frame should be directed to the layer above</LI></UL><H5 CLASS="h4"><A NAME="sec3"></A>Network Layer</H5><P CLASS="t">The network layer controls the operation of the subnet. It determines which physical path the data takes, based on the network conditions, the priority of service, and other factors. </P>
<P CLASS="t">The network layer provides the following functions.</P>
<UL><LI>Transferring the frameto a router if the network address of the destination does not indicate the network to which the station is attached</LI><LI>Controlling subnet traffic to allow an intermediate system to instruct a sending station not to transmit its frame when the router's buffer fills up. If the router is busy, the network layer can instruct the sending station to use an alternate router </LI><LI>Allowing the router to fragment a frame when a downstream router's maximum transmission unit (MTU) size is less than the frame size. The frame fragments will be reassembled by the destination station </LI><LI>Resolving the logical computer address (at the network layer) with the physical network-interface-card (NIC) address (at the data-link layer), if necessary </LI><LI>Keeping an accounting record of frames forwarded by subnet intermediate system to produce billing information </LI></UL><P CLASS="t">The network layer at the transmitting computer must build its header in such a way that the network layers residing in the subnet's intermediate systems can recognize the header and use it to route the data to the destination address.</P>
<P CLASS="t">This layer eliminates the need for higher layers to know anything about the data transmission or intermediate switching technologies used to connect systems. The network layer is responsible for establishing, maintaining, and terminating the connection to one or to several intermediate systems in the communication subnet. </P>
<P CLASS="t">In the network layer and the layers below it, the peer protocols are between each computer and its immediate neighbor, which is often not the ultimate destination computer. The source and destination computers may be separated by many intermediate systems.</P>
<H5 CLASS="h4"><A NAME="sec4"></A>Transport Layer</H5><P CLASS="t">The transport layer makes sure that messages are delivered in the order in which they were sent and that there is no loss or duplication. It removes the concern from the higher layer protocols about data transfer between the higher layer and its peers.</P>
<P CLASS="t">The size and complexity of a transport protocol depend on the type of service it can get from the network layer or data link layer. For a reliable network layer or data-link layer with virtual-circuit capability, such as NetBEUI's LLC layer, a minimal transport layer is required. If the network layer or data-link layer is unreliable or supports only datagrams (as TCP/IP's IP layer and NWLink's IPX layer do), the transport layer should include frame sequencing and acknowledgment, and associated error-detection and recovery. </P>
<P CLASS="t">Functions of the transport layer include the following tasks.</P>
<UL><LI>Accepting messages from the layer above and, if necessary, splitting them into frames</LI><LI>Providing reliable, end-to-end message delivery with acknowledgments</LI><LI>Instructing the transmitting computer not to transmit when no receive buffers are available</LI><LI>Multiplexing several process-to-process message streams or sessions onto one logical link and keeping track of which messages belong to which sessions</LI></UL><P CLASS="t">The transport layer can accept large messages, but there are strict size limits imposed by the layers at the network level and lower. Consequently, the transport layer must break up the messages into smaller units, called <I>frames,</I> and attach a header to each frame. </P>
<P CLASS="t">If the lower layers do not maintain sequence, the transport header (TH) must contain sequence information, which enables the transport layer on the receiving end to present data in the correct sequence to the next higher layer.</P>
<P CLASS="t">Unlike the lower subnet layers, whose protocols are between immediately adjacent nodes or computers, the transport layer and the layers above it are true source-to-destination layers. They are not concerned with the details of the underlying communications facility. Software for layers on the source computer at the transport level and above carries on a conversation with similar software on the destination computer, using message headers and control messages.</P>
<H5 CLASS="h4"><A NAME="sec5"></A>Session Layer</H5><P CLASS="t">The session layer establishes a communications session between processes running on different computers, and can support message-mode data transfer. </P>
<P CLASS="t">Functions of the session layer include: </P>
<UL><LI>Allowing application processes to register unique process addresses, such as NetBIOS names. It provides the means by which these process addresses can be resolved to the network-layer or data-link-layer NIC addresses, if necessary.</LI><LI>Establishing, monitoring, and terminating a virtual-circuit session between two processes identified by their unique process addresses. A virtual-circuit session is a direct link that seems to exist between the sender and receiver: In reality, the connection is established through circuits.</LI><LI>Delimiting messages, to add header information that indicates where a message starts and ends. The receiving session layer can then refrain from indicating any message data to the overlying application until the entire message has been received.</LI><LI>Informing the receiving application when buffer space is insufficient for the entire message and that the message is incomplete (called <I>message synchronization).</I> The receiving session layer may also use a control frame to inform the sending session layer how many bytes of the message have been successfully received. The sending session layer can then resume sending data at the byte following the last byte acknowledged as received. When the application subsequently provides another buffer, the session layer can place the remainder of the message in that buffer and indicate to the application that the entire message has been received.</LI><LI>Performing other support functions that allow processes to communicate over the network, such as user authentication and resource-access security.</LI></UL><H5 CLASS="h4"><A NAME="sec6"></A>Presentation Layer</H5><P CLASS="t">The presentation layer serves as the data translator for the network. This layer on the sending computer translates data from the format sent by the application layer into a common format. At the receiving computer, the presentation layer translates the common format to a format known to the application layer. </P>
<P CLASS="t">The presentation layer provides the following functions.</P>
<UL><LI>Character-code translation, such as from ASCII to EBCDIC</LI><LI>Data conversion, such as bit order, CR-to-CR/LF, and integer-to-floating point</LI><LI>Data compression, which reduces the number of bits that need to be transmitted</LI><LI>Data encryption, which renders data unreadable until it has been unencrypted, for security purposes. An example is password encryption</LI></UL><H5 CLASS="h4"><A NAME="sec7"></A>Application Layer</H5><P CLASS="t">The application layer serves as the window for users and application processes to access network services. The application layer provides the following functions.</P>
<UL><LI>Resource sharing and device redirection</LI><LI>Remote file access</LI><LI>Remote printer access</LI><LI>Interprocess communication<B> </B>support</LI><LI>Remote procedure call support</LI><LI>Network management</LI><LI>Directory services</LI><LI>Electronic messaging, including e-mail messaging</LI><LI>Simulation of virtual terminals</LI></UL><H4 CLASS="h3"><A NAME="sec8"></A>Data Flow in the OSI Model</H4><P CLASS="t">The OSI model presents a standard data flow architecture, with protocols specified in such a way that layer <I>n</I> at the destination computer receives exactly the same object as was sent by layer <I>n</I> at the source computer.</P>
<P><img src="XNG_A06.gif"></P>
<P CLASS="cap"><B>Figure 1.4    OSI model data flow</B></P>
<P CLASS="t">The sending process passes data to the application layer, which attaches an application header (AH) and then passes the frame to the presentation layer.</P>
<P CLASS="t">The presentation layer can transform data in various ways, if necessary, such as by translating it and adding a header. It then gives the result to the session layer. The presentation layer is not "aware" of which portion (if any) of the data received from the application layer is AH and which portion is actually user data, because that information is irrelevant to the presentation layer's role. </P>
<P CLASS="t">The process is repeated from layer to layer until the frame reaches the data-link layer. There, in addition to a header, a data trailer (DT) is added to aid in frame synchronization. The frame is then passed down to the physical layer, where it is actually transmitted to the receiving computer.</P>
<P CLASS="t">On the receiving computer, the various headers and the DT are stripped off one by one as the frame ascends the layers and finally reaches the receiving process.</P>
<P CLASS="t">Although the actual data transmission is vertical, each layer is programmed as if the transmission were horizontal. For example, when a sending transport layer gets a message from the session layer, it attaches a transport header (TH) and sends it to the receiving transport layer. The fact that the message actually passes to the network layer on its own machine is unimportant.</P>
<H4 CLASS="h3"><A NAME="sec9"></A>Vertical Interface Terminology in the OSI Model</H4><P CLASS="t">In addition to defining the ideal seven-layer architecture and the network functions allocated to each layer, the OSI model also defines a standard set of rules and associated terms that govern the interfaces between layers. </P>
<P CLASS="t">The active protocol elements in each layer are called <I>entitie</I><B><I>s</I></B>, which are typically implemented by means of a software process. For example, the TCP/IP protocol suite contains two entities within its transport layer: Transmission Control Protocol (TCP) and User Datagram Protocol (UDP). Entities in the same layer on different computers are called <I>peer entities</I>.</P>
<P CLASS="t">The layer directly below layer-<I>n</I> entities implements services that will be used by layer <I>n</I>. </P>
<P CLASS="t">For data transfer services, OSI defines the terminology for the discrete data components passed across the interface and between peer entities, as described in the following example.</P>
<UL><LI>The layer-<I>n</I> entity passes an <I>interface data unit </I>(IDU) to the layer-<I>n–1</I> entity. </LI><LI>The IDU consists of a <I>protocol data unit</I> (PDU) and some <I>interface control information</I> (ICI). </LI><LI>The PDU is the data that the layer-<I>n </I>entity wishes to pass across the network to its peer entity. It consists of the layer-<I>n</I> header and the data that layer <I>n</I> received from layer <I>n+1</I>. </LI><LI>The layer-<I>n</I> PDU becomes the layer <I>n–1</I> service data unit (SDU), because it is the data unit that will be serviced by layer <I>n.</I></LI><LI>The ICI is made up of control information, such as the length of the SDU, and the addressing information that the layer below needs to do its job.</LI><LI>When layer <I>n–1</I> receives the layer-<I>n</I> IDU, it strips off and "considers" the ICI, adds the header information for its peer entity across the network, adds ICI for the layer below, and passes the resulting IDU to the layer <I>n–2 </I>entity.</LI></UL><P><img src="XNG_A07.gif"></P>
<P CLASS="cap"><B>Figure 1.5    Vertical interface entities</B></P>
<P CLASS="t">Problems can occur in the data-flow path between two network stations. These problems can include errant, restricted, or even halted communication. Vertical and peer-trace utilities can be developed by third-party vendors to trace network communication errors.</P>
<H4 CLASS="h3"><A NAME="sec10"></A>Vertical Interface Trace Utilities</H4><P CLASS="t">Layer entities within a computer can call layer entities above and below them by means of established interface-call mechanisms (such as an interrupt in MS-DOS or, in Windows&nbsp;NT, an API-function call or IRP submission)and then pass a defined IDU structure. These call mechanisms provide the means to write a trace utility, which can do the following items.</P>
<UL><LI>Capture the interface-call-mechanism entry point, saving the original entry point.</LI><LI>Gain control when the entry point is called.</LI><LI>Examine the structure being passed, "snapshot" all or part of the IDU structure, and then write the snapshot to a buffer or log file.</LI><LI>Pass control to the original entry point.</LI></UL><P CLASS="t">If the data-flow problem is due to a layer entity's passing incorrect or incorrectly formatted ICI information, an examination of the log generated by the interface trace utility should reveal the cause of the problem. Vertical-interface trace utilities that can be used to troubleshoot networking include the NBTRAP (NetBIOS interface trace) utility for MS-DOS and the TDITRACE (Transport Driver Interface interface trace) utility for Windows&nbsp;NT, among others. </P>
<H4 CLASS="h3"><A NAME="sec11"></A>Peer-protocol Trace Utilities</H4><P CLASS="t">A specially configured computer can connect to the physical medium to receive and examine all frames sent to and from specified network addresses. The user can set the computer software to display frame-header information at any functional layer. The user can then view peer-protocol conversations between selected computers. If the data-flow problem is due to an error in the peer protocol, the user can detect it by examining the trace. Peer-protocol trace utilities include Sniffer from Network General and Microsoft Network Monitor, among others.</P>
<P><img src="XNG_A08.gif"></P>
<P CLASS="cap"><B>Figure 1.6    Troubleshooting, using a Data Flow Trace</B></P>
<H4 CLASS="h3"><A NAME="sec12"></A>IEEE Standard 802 for Low-level Protocols</H4><P CLASS="t">Recognizing a need for standards in the local area network (LAN) market, the IEEE undertook Project 802. Named for the year (1980) and month (February) of its inception, Project 802 defines a family of low-level protocol standards at the physical and data-link layers of the OSI model.</P>
<P CLASS="t">Under the terms of IEEE 802, the OSI data-link layer is further divided into two sublayers: Logical Link Control (LLC) and Media Access Control (MAC).</P>
<P><img src="XNG_A09.gif"></P>
<P CLASS="cap"><B>Figure 1.7    Comparison of IEEE layers and the OSI model</B></P>
<P CLASS="t">Data-link-layer functions allocated to the LLC sublayer include the following.</P>
<UL><LI>Establishing and terminating links</LI><LI>Controlling frame traffic</LI><LI>Sequencing frames</LI><LI>Acknowledging frames</LI></UL><P CLASS="t">Data-link-layer functions allocated to the MAC sublayer include the following items.</P>
<UL><LI>Managing media access</LI><LI>Delimiting frames</LI><LI>Checking frame errors</LI><LI>Recognizing frame addresses</LI></UL><P CLASS="t">Project 802 specifications include the following categories.</P>
<UL><LI>802.1 Overview of project 802, including higher layers and internetworking</LI><LI>802.2 Logical Link Control (LLC)</LI><LI>802.3 Carrier Sense Multiple Access with Collision Detect (CSMA/CD)</LI><LI>802.4 Token Bus</LI><LI>802.5 Token Ring</LI><LI>802.6 Metropolitan Area Network</LI><LI>802.7 Broadband Technology Advisory Group</LI><LI>802.8 Optical Fiber Technology Advisory Group</LI><LI>802.9 Voice/Data Integration on LANs</LI><LI>802.10 Standard for Interoperable LAN Security</LI></UL><P CLASS="t">The low-level protocol specifications 802.3 CSMA/CD, 802.4 Token Bus, and 802.5 Token Ring differ at the physical layer and MAC sublayer, but are compatible at the LLC sublayer. </P>
<P CLASS="t">The 802 standards have been adopted by the following standards bodies.</P>
<UL><LI>ANSI, as American National Standards</LI><LI>National Bureau of Standards (NBS), as<B> </B>government standards</LI><LI>ISO, as international standards (known as ISO 8802)</LI></UL><H4 CLASS="h3"><A NAME="sec13"></A>ANSI FDDI Specification</H4><P CLASS="t">Closely related to the IEEE 802 standards is a more recently developed low-level protocol standard, Fiber Distributed Data Interchange (FDDI). FDDI was developed by ANSI and is based on the use of fiber-optic cable.</P>
<P CLASS="t">FDDI differs from the IEEE 802 standards at the physical layer and MAC sublayer, but is compatible with the IEEE standards at the LLC sublayer.</P>
<H4 CLASS="h3"><A NAME="sec14"></A>Data-transfer Services</H4><P CLASS="t">Protocol entities within a network architecture provide various types of data-transfer services from a layer to the layers above it. The most prevalent data-transfer services are called <I>reliable connection</I> and <I>unreliable connectionless</I>. </P>
<P CLASS="t">A <I>connection service</I> requires a virtual circuit or connection to be established from the source computer to a single destination computer before any data transfer can take place. A connection acts like a tube: The sender pushes objects in at one end, and the receiver takes them out at the other end, in proper sequence. Because sequencing is provided, a message that is larger than the maximum transmit-frame size can be broken down into multiple frames, sent across the network, and re-sequenced at the receiving computer.</P>
<P CLASS="t">A <I>connectionless service</I> requires no initial connection and offers no guarantee that the data units will arrive in sequence. No connection is required, so messages can be sent to one or multiple destination stations. No sequencing is provided, so messages can be sent only in single-frame size.</P>
<P CLASS="t">A <I>reliable service</I> never loses data because the receiver acknowledges receipt of all data sent. If the sender doesn't receive acknowledgment, it re-sends. </P>
<P CLASS="t">With an <I>unreliable service</I>, no acknowledgments are sent, so there is no guarantee that data sent was ever received.</P>
<P CLASS="t">Microsoft network products require that the underlying network drivers provide both reliable-connection and unreliable-connectionless data-transfer services.</P>
<P CLASS="t">Microsoft network products use unreliable-connectionless data transfer only when there is a need to send data simultaneously to many stations. Often, unreliable-connectionless data transfer is used to locate the name of a computer. Once the computer name is received, reliable-connection data transfer is used to connect to the computer and complete the desired transaction. For example, an unreliable-connectionless data transfer may be sent to all computers in a domain (such as <B>net send /d:</B><B><I>&lt;domain name&gt;</I></B><B> "hello"</B>) to find the name of a server that provides a particular service.</P>
<H4 CLASS="h3"><A NAME="sec15"></A>Data-transfer Modes</H4><P CLASS="t">Different protocol entities offer different modes by which data can be transferred across the network from one process to another. As indicated in Table 1.1, some protocols, such as the NetBEUI NBFP, support more than one data-transfer mode.</P>
<P CLASS="ttl"><B>Table 1.1    Data-transfer Mode Definitions and Protocols </B></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="78pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="4" VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="th"><B>Data-transfer mode</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B><BR>Mode type</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B><BR>Definition</B></P></TD><TD VALIGN="TOP"><P CLASS="th"><B><BR>Protocol</B></P></TD></TR><TR><TD COLSPAN="4" VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">Reliable connection</P></TD><TD VALIGN="TOP"><P CLASS="tt">Message mode</P></TD><TD VALIGN="TOP"><P CLASS="tt">Message delimination and synchronization</P></TD><TD VALIGN="TOP"><P CLASS="tt">NetBEUI NBFP, TCP/IP NetBT, NWLink NBIPX</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"></P></TD><TD VALIGN="TOP"><P CLASS="tt">Byte-stream mode</P></TD><TD VALIGN="TOP"><P CLASS="tt">Byte granular data sequencing and acknowledgment</P></TD><TD VALIGN="TOP"><P CLASS="tt">TCP/IP <BR>TCP</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"></P></TD><TD VALIGN="TOP"><P CLASS="tt">Packetstream mode</P></TD><TD VALIGN="TOP"><P CLASS="tt">Packet granular data sequencing and acknowledgment</P></TD><TD VALIGN="TOP"><P CLASS="tt">NetBEUI, LLC, MSDLC, NWLink SPX</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">Unreliable connectionless</P></TD><TD VALIGN="TOP"><P CLASS="tt">Datagram mode</P></TD><TD VALIGN="TOP"><P CLASS="tt"></P></TD><TD VALIGN="TOP"><P CLASS="tt">NetBEUI NBFP and LLC;MSDLC, TCP/IP UDP and IP; NWLink IPX</P></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t">The following sections discuss the attributes of various data-transfer modes.</P>
<H5 CLASS="h4"><A NAME="sec16"></A>Reliable Connection Message Mode</H5><P CLASS="t">When the sending client submits a larger-than-packet-size message to be sent, the sending protocol entity breaks the message into frame-sized segments. These include message-delimiter information in the protocol header, which identifies where the client submitted message starts and ends. This process allows the receiving-protocol driver to receive the entire client message before indicating the data to the receiving client. </P>
<P CLASS="t">If the receiving-client buffer fills up before the receiving-station protocol entity has received the entire message, it will still provide the partial message to the receiving client. It will also indicate that the data provided is a partial message and that the receiving client must supply another buffer to receive the remaining portion of the message. </P>
<P CLASS="t">When the receiving-protocol entity has received the entire message, it returns a message to the sending-protocol entity, acknowledging receipt of the entire message.</P>
<H5 CLASS="h4"><A NAME="sec17"></A>Reliable Connection Byte-stream Mode </H5><P CLASS="t">When the sending client submits a larger-than-packet-size message, the sending-protocol-driver entity breaks the message into segments but does not include message-delimiter information in the protocol header. The receiving-station-protocol entity provides the data to the receiving client when the receiving client provides the buffers to receive it, without any regard to the original message size. </P>
<P CLASS="t">When the receiving-protocol entity provides the data to the receiving client, it returns a byte acknowledgment to the sending-protocol entity, acknowledging receipt of all data up to a specified byte. The sending client can then begin sending the message at the last byte acknowledged.</P>
<H5 CLASS="h4"><A NAME="sec18"></A>Reliable Connection Packetstream Mode</H5><P CLASS="t">In this mode, the sending client can submit only packet-size messages. The receiving protocol provides the packet-by-packet data in sequence to the receiving client. </P>
<P CLASS="t">While the receiving protocol entity provides a frame of data to the receiving client, it returns a message to the sending protocol entity, acknowledging receipt of all packets up to the specified packet number.</P>
<P CLASS="t"><B>Note</B></P>
<P>The Windows Sockets emulator emulates message-mode data transfer over the NWLink SPX packet stream. The Sockets emulator component will break large messages into packets and place message delimiters in the packet stream. The receiving Sockets emulator will not provide the received data to the receiving Sockets client until the entire message has been received.</P>
<H5 CLASS="h4"><A NAME="sec19"></A>Unreliable Connectionless Datagram Mode</H5><P CLASS="t">The sending client can submit only packet-size messages to be sent. If the data unit received is larger than the receiving client's next receive buffer, then as much of the received data unit as will fit is placed in the receiving client's buffer and provided to the client. The portion of the received data unit that could not fit in the client buffer is simply lost; no associated error is returned to the receiving client. If the data unit received is smaller than the client buffer, the protocol entity will place the received data unit in the client buffer and immediately provide the message, without waiting for more data to be received.</P>
<P CLASS="t">No acknowledgment is returned to the sending-protocol entity.</P>
<P CLASS="t">The following diagram illustrates the data transfer process: 'S' (on the right side of the diagram) indicates a SUCCESS return status code on the receive. 'E' indicates an error status on the receive: ERROR_MORE_DATA on message mode data transfer. </P>
<P><img src="XNG_A11a.gif"></P>
<P CLASS="cap"><B>Figure 1.8    Data-transfer modes</B></P></BODY></HTML>
