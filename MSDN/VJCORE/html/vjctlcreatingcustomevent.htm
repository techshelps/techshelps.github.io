<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Custom Event</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<h2><a name="vjctlcreatingcustomevent"></a>Creating a Custom Event</h2>
<p>
WFC controls support a standard set of events that they inherit from the Control class, such as click, mouseDown, keyPress, and so on. Your control automatically exposes these events, and they are available in the host application without any special effort on your part unless you want to override the events to add special functionality.</p>
<p class=indent>
<b>Note&nbsp;&nbsp;&nbsp;</b>For information about creating event handlers&nbsp;— receiving events in a host application&nbsp;— see <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vjconHandlingEventsInWFC">
</object><a href=JavaScript:alink_1.Click()>Handling Events in WFC</a>. For details about how to capture a standard event and process it within your control, see <a href="vjctlcapturinguserinteractionwithcontrol.htm">Capturing User Interaction with a Control</a>.</p>
<p>
In some instances, however, you might want to create custom events that are unique to your control. For example, you might want your control to use an event to notify the host application of a change in status, such as the completion of an initialization procedure, or to report an error condition.</p>
<p class=indent>
<b>Note</b>&nbsp;&nbsp;&nbsp;By convention, to indicate a change in the value of a property, you create on&lt;<i>property</i>&gt;Changing and on&lt;<i>property</i>&gt;Changed methods using the techniques described below. For additional details, see <a href="vjctlprovidingpropertychangenotification.htm">Providing Property Change Notification</a>.</p>
<p>
Custom events rely on Visual J++ delegate technology. To implement a custom event, you create a delegate that can bind event handlers in an application to your event. This topic provides information on the following aspects of creating custom events:
<ul type=disc>
<li>
<a href="#vjctlusingdelegatesforevents">Using Delegates for Events</a>&nbsp;&nbsp;&nbsp;Background information on the Visual J++ delegate technology as used for events.<br><br></li>
<li>
<a href="#vjctlcreatingcustomeventclass">Creating a Custom Event Class</a>&nbsp;&nbsp;&nbsp;Creating your own event class to specify event-specific data.<br><br></li>
<li>
<a href="#vjctlcreatingdelegate">Creating a Delegate</a>&nbsp;&nbsp;&nbsp;Creating your own delegate to allow host applications to bind methods (event handlers) to your event.<br><br></li>
<li>
<a href="#vjctlimplementingcustomevent">Implementing a Custom Event</a>&nbsp;&nbsp;&nbsp;Creating special methods that allow host applications to use your delegate.<br><br></li>
<li>
<a href="#vjctlexposingeventatdesigntime">Exposing the Event at Design Time</a>&nbsp;&nbsp;&nbsp;Using the EventInfo object to show event information in the Properties window.<br><br></li>
<li>
<a href="#vjctlfiringevent">Firing an Event</a>&nbsp;&nbsp;&nbsp;Sending the event message.</li>
</ul>
<p>
Finally, at the end of this topic you can find a complete <a href="#vjexaacompleteexample">example</a> that shows the process in the context of a simple control.</p>

<h3><a name="vjctlusingdelegatesforevents"></a>Using Delegates for Events</h3>
<p>
The event model for WFC uses delegates to bind events to the methods used to handle them. To define an event in Visual J++, you subclass the Event class, and then create a delegate class based on com.ms.lang.Delegate that binds to it. The delegate allows other classes to register for event notification by specifying a handler method. When the event occurs (is invoked), the delegate calls the bound method.</p>
<p>
Delegates can be bound to a single method or to multiple methods, referred to as <i>multicasting</i>. When creating a delegate for an event, you typically create a multicast event. A rare exception might be an event that resulted in a specific procedure (such as displaying a dialog box) that it would not be sensible to repeat multiple times per event.</p>
<p>
A multicast delegate maintains an <i>invocation list</i> of the methods it is bound to. The multicast delegate supports a combine method to add a method to the invocation list and a remove method to remove it.</p>
<p>
A control fires an event by invoking the delegate for that event. The delegate in turn calls the bound method. In the most common case (a multicast delegate) the delegate calls each bound method in the invocation list in turn, which provides a one-to-many notification. This strategy means that the control does not need to maintain a list of target objects for event notification&nbsp;— the delegate handles all registration, notification, and unregistration. </p>
<p>
Delegates also allow multiple events to be bound to the same method, allowing a many-to-one notification. For example, a button click event and a menu command click event can both invoke the same delegate, which then calls a single method to handle these two separate events the same way.</p>
<p>
The binding mechanism used with delegates is dynamic&nbsp;— a delegate can be bound at run time to any method whose signature matches that of the event handler. This feature allows you to set up or change the bound method depending on condition and to dynamically attach an event handler to a control. </p>

<h3><a name="vjctlcreatingcustomeventclass"></a>Creating a Custom Event Class</h3>
<p>
If you want to pass event-specific data with the event (similar to the x and y properties of the Control class' mouseMove event), you must create a custom event class and define its data. To create a custom event, you subclass the Event class. To make the event a top-level public class, it must reside in a separate .java file. In your class you define members to hold the event data.</p>
<p>
The following example shows how you can create a simple error event class that has two fields, one for an error number and another for the text of the error message:</p>
<pre><code>// ErrorEvent.java
import com.ms.wfc.core.*;
public class ErrorEvent extends Event{
   public final int errorNumber;
   public final String errorText;
   public ErrorEvent( int eNum, String eTxt){
      this.errorNumber = eNum;
      this.errorText   = eTxt;
   }
}
</code></pre>

<h3><a name="vjctlcreatingdelegate"></a>Creating a Delegate</h3>
<p>
To allow binding for your event, create a handler class which declares a delegate specifying the signature for your event. If you want to be able to bind the delegate to multiple methods, declare it as a multicast delegate. The delegate should be a top-level class, it should therefore be in a separate file.</p>
<p>
The following example shows a handler class for the ErrorEvent class illustrated earlier:</p>
<pre><code>// ErrorEventHandler.java
import com.ms.wfc.core.*;
public final multicast delegate void ErrorEvent(Object sender, 
   ErrorEvent event);
</code></pre>
<p>
Multicast delegates must return void, because they cannot return the results of more than one method. </p>

<h3><a name="vjctlimplementingcustomevent"></a>Implementing a Custom Event</h3>
<p>
To implement a custom event in your control, you provide a way for the host application to register for the event. First create a private instance of your delegate. Then create an addOn&lt;<i>event</i>&gt; method that the host can call to register for an event and bind it to a specific method. If the delegate is multicast, call the delegate's combine method in your addOn&lt;<i>event</i>&gt; method to add the user's method to the delegate's invocation list.</p>
<p>
The following example shows how you can perform these steps for the ErrorEvent class illustrated earlier:</p>
<pre><code>// Create instance of delegate
private ErrorEventHandler err = null;
// Call delegate's combine method to add binding to invocation list
public final void addOnErrorEvent(ErrorEventHandler handler){
   err = (ErrorEventHandler)Delegate.combine(err, handler);
}
</code></pre>
<p>
Typically, you also provide a removeOn&lt;<i>event</i>&gt; method so the host can unregister for the event:</p>
<pre><code>public final void removeOnErrorEvent(ErrorEventHandler handler){
   err = (ErrorEventHandler)Delegate.remove(err, handler);
}
</code></pre>
<p>
If you are using a non-multicast delegate, the syntax for the addOn&lt;<i>event</i>&gt; method is simpler:</p>
<pre><code>private ErrorEventHandler err = null;   // Create instance of delegate
public final void addOnErrorEvent(ErrorEventHandler handler){
   err = handler;
}
</code></pre>
<p class=indent>
<b>Note</b>&nbsp;&nbsp;&nbsp;The Component class from which the control derives contains utility code to add, remove, and fire events.</p>

<h3><a name="vjctlexposingeventatdesigntime"></a>Exposing the Event at Design Time</h3>
<p>
Exposing an event at design time is similar to exposing a property. First, you create an instance of the <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="com.ms.wfc.core.EventInfo">
</object><a href=JavaScript:alink_2.Click()>EventInfo</a> class indicating the new event's class, name, and delegate. You then you override the superclass' <object id=alink_3 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="com.ms.wfc.core.ClassInfo_getEvents">
</object><a href=JavaScript:alink_3.Click()>getEventsEventInfo</a> method, adding the superclass' existing events and then your new event. </p>
<p class=indent>
<b>Note&nbsp;&nbsp;&nbsp;</b>The event name should start with a lowercase letter (for example, errorEvent), unless the first two letters are uppercase (such as MIDIChildActivated).</p>
<p>
The following example shows the <object id=alink_4 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="com.ms.wfc.core.ClassInfo">
</object><a href=JavaScript:alink_4.Click()>ClassInfo</a> class for the ErrorEvent event shown earlier:</p>
<pre><code>public static class ClassInfo extends Control.ClassInfo{
   public static EventInfo errEvt = new EventInfo(MyControl.class,
       "errorEvent", ErrorEventHandler.class);
   public void getEvents(IEvents events({
      super.getEvents(events);
      events.add(errEvt);
   }
}
</code></pre>

<h3><a name="vjctlfiringevent"></a>Firing an Event</h3>
<p>
To fire the event, you create an instance of your event class, passing to it the event-specific parameters that you defined in the class. You then invoke the delegate, as in the following example:</p>
<pre><code>// the err delegate must already exist
int errNumber = 1020;
String errText = "Invalid value."
ErrorEvent e = new ErrorEvent(errNumber, errText);
err.invoke(this, e);
</code></pre>
<p>
Most events in WFC include a protected <code>on</code>&lt;<i>eventname</i>&gt; member that lets subclasses override the event and determine the order in which the event is triggered through placement of the call to super.on&lt;<i>eventname</i>&gt;. The following shows the protected member for ErrorEvent:</p>
<pre><code>protected void onErrorEvent(ErrorEvent event){
   if(err != null){
      err.invoke(this, event);
   }
}
</code></pre>
<p>
If you include the protected member, you can fire the event within your control by calling it instead of directly calling the invoke method, as in this example:</p>
<pre><code>if(value &gt; 20){
   onErrorEvent(new ErrorEvent(1020, "Invalid value"));
}
</code></pre>

<h3><a name="vjexaacompleteexample"></a>A Complete Example</h3>
<p>
The following shows a complete, simple control that includes the ErrorEvent event described in the preceding sections:</p>
<pre><code>&nbsp;// MyControl.java
import com.ms.wfc.ui.* ;
import com.ms.wfc.core.* ;
import com.ms.lang.Delegate;

public class MyControl extends Control {
   private int myProp = 1;
   public int getMyProp(){
      return myProp;
   }
   public void setMyProp(int value){
      // Fires error event if property value exceeed 200
      if(value &gt; 200){
<span class=cfe><b>         onErrorEvent(new ErrorEvent(1020, "Invalid value"));</b></span>
      }
      myProp = value;
   }

   protected void onPaint( PaintEvent p){
      super.onPaint(p);
      Graphics g=p.graphics;
      g.drawString( getText(), 0, 0);
   }

<span class=cfe><b>   // event setup to be able to fire event "ErrorEvent"</b></span>
<span class=cfe><b>   private ErrorEventHandler errDelegate = null;</b></span>
<span class=cfe><b>   public final void addOnErrorEvent(ErrorEventHandler handler){</b></span>
<span class=cfe><b>      errDelegate = (ErrorEventHandler)Delegate.combine(errDelegate,
       handler);</b></span>
<span class=cfe><b>   }</b></span>
<span class=cfe><b>   public final void removeOnErrorEvent(ErrorEventHandler handler){</b></span>
<span class=cfe><b>      errDelegate = (ErrorEventHandler)Delegate.remove(errDelegate,
       handler);   </b></span>
<span class=cfe><b>   }</b></span>
<span class=cfe><b>   protected void onErrorEvent(ErrorEvent event){</b></span>
<span class=cfe><b>      if(errDelegate != null){</b></span>
<span class=cfe><b>         errDelegate.invoke(this, event);</b></span>
<span class=cfe><b>      }   </b></span>
<span class=cfe><b>   }</b></span>
      
   public static class ClassInfo extends Control.ClassInfo{
      public static final PropertyInfo myProp = new 
         PropertyInfo(MyControl.class, "myProp", int.class);
      public void getProperties(IProperties props){
         super.getProperties(props);
         props.add(myProp);
      }
      
<span class=cfe><b>      public static EventInfo evt = new EventInfo(MyControl.class, 
         "errorEvent", ErrorEventHandler.class);</b></span>
<span class=cfe><b>      public void getEvents(IEvents events){</b></span>
<span class=cfe><b>         super.getEvents(events);</b></span>
<span class=cfe><b>         events.add(evt);</b></span>
<span class=cfe><b>      }</b></span>
   }
}
</code></pre>
</BODY>
</HTML>
