<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Receiving a String from a DLL Function</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<h2><a name="vjconreceivingstringfromdllfunction"></a>Receiving a String from a DLL Function</h2>
<p>
There are two common ways of passing a string back from a function: either the caller allocates a buffer that is filled in by the function, or the function allocates the string and returns it to the caller. Most Win32 functions use the first method, but OLE functions use the second method. (See <a href="vjconinvokingoleapifunctions.htm">Invoking OLE API Functions</a> to learn about the special support that J/Direct provides for calling OLE functions.) One function that uses the first method is the Kernel32 function GetTempPath, which has the following prototype:</p>
<pre><code>DWORD GetTempPath(DWORD sizeofbuffer, LPTSTR buffer);
</code></pre>
<p>
This function simply returns the path of the system temporary file directory (such as "c:\tmp\"). The <i>buffer</i> argument points to a caller-allocated buffer that receives the path, and <i>sizeofbuffer</i> indicates the number of characters that can be written to the buffer. (This is different from the number of bytes in the Unicode version.) In Java, strings are read-only, so you cannot pass a String object as the buffer. Instead, you can use Java's StringBuffer class to create a writable StringBuffer object. The following is an example that invokes the GetTempPath function:</p>
<pre><code>class ShowGetTempPath
{
  static final int MAX_PATH = 260;
  public static void main(String args[])
  {
 &nbsp;&nbsp; StringBuffer temppath = new StringBuffer(MAX_PATH);
 &nbsp;&nbsp; GetTempPath(temppath.capacity(), temppath);
 &nbsp;&nbsp; System.out.println("Temppath = " + temppath);
  }
   
  /** @dll.import("KERNEL32") */
  private static native int GetTempPath(int sizeofbuffer,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StringBuffer buffer);
}
</code></pre>
<p>
To understand this example, it is important to distinguish between a StringBuffer's length and its capacity. The length is the number of characters logically in the string currently stored in the StringBuffer. The capacity is the actual amount of storage currently allocated to that StringBuffer. After the following statement executes:</p>
<pre><code>StringBuffer sb = new StringBuffer(259);
</code></pre>
<p>
the value of <i>sb.length</i> is zero, and the value of <i>sb.capacity</i> is 259. When you invoke a DLL method passing a StringBuffer, the Microsoft VM examines the capacity of the StringBuffer, adds one for the null terminator, multiplies by 2 if Unicode is the default character size, and then allocates that many bytes of memory for the buffer that is passed to the DLL function. In other words, you use the capacity, not the length, to set the size of the buffer. Be careful not to make the following mistake:</p>
<pre><code>StringBuffer sb = new StringBuffer();&nbsp; //Wrong!
  GetTempPath(MAX_PATH, sb);
</code></pre>
<p>
Invoking the StringBuffer constructor with no arguments creates a StringBuffer object with a capacity of 16, which is probably too small. MAX_PATH was passed to the GetTempPath method, indicating that there was enough room in the buffer to hold 260 characters. Thus, GetTempPath will probably overrun the buffer. If you were planning to use GetTempPath extensively, you should wrap it in a Java-friendly wrapper in the following manner:</p>
<pre><code>public static String GetTempPath()
{
  StringBuffer temppath = new StringBuffer(MAX_PATH-1);
  int res = GetTempPath(MAX_PATH, temppath);
  if (res == 0 || res &gt; MAX_PATH) {
 &nbsp;&nbsp; throw new RuntimeException("GetTempPath error!");
  }
  return temppath.toString(); // can't return a StringBuffer 
}
</code></pre>
<p>
This method offers both convenience and safety, and it maps the error return value of the function to a Java exception. Notice that you cannot return StringBuffer objects.</p>
</BODY>
</HTML>
