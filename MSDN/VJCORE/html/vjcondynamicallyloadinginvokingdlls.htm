<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dynamically Loading and Invoking DLLs</title>
<style>@import url(stylesheets/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="stylesheets/msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vjcondynamicallyloadinginvokingdlls"></a>Dynamically Loading and Invoking DLLs</h1>
<p>
There may be times when you need more control over the loading and linking process than the @dll.import directive normally provides. For instance, your requirements might include:
<ul type=disc>
<li>
Loading a library whose name or path must be computed at run time or generated from user input.<br><br></li>
<li>
Freeing a library prior to process termination.<br><br></li>
<li>
Executing a function whose name or ordinal must be computed at run time.</li>
</ul>
<p>
The Win32 APIs have always provided the ability to control loading and linking. The LoadLibrary, LoadLibraryEx, and FreeLibrary functions allow you to have explicit control over the loading and freeing of DLLs. The GetProcAddress function allows you to link to a specific export. The GetProcAddress function returns a function pointer, so any language that can call through a function pointer can implement dynamic invocation without a problem. </p>
<p>
J/Direct allows Java programmers to declare the requisite functions in the following way:</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you are using the com.ms.win32 package, these declarations also appear in the Kernel32 class.</p>
<pre><code>/** @dll.import("KERNEL32",auto) */
public native static int LoadLibrary(String lpLibFileName);

/** @dll.import("KERNEL32",auto) */
public native static int LoadLibraryEx(String lpLibFileName, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int hFile, int dwFlags);

/** @dll.import("KERNEL32",auto) */
public native static boolean FreeLibrary(int hLibModule);

/** @dll.import("KERNEL32",ansi) */
public native static int GetProcAddress(int hModule, String lpProcName);
</code></pre>
<p>
Notice that GetProcAddress is declared with the <i>ansi</i> modifier, not <i>auto</i>. This is because GetProcAddress is one of the few Windows functions without a Unicode equivalent. If we were to use the <i>auto</i> modifier, this function would fail on Microsoft Windows NT systems. </p>
<p>
That only leaves the problem of invoking a function obtained by GetProcAddress. For your convenience, msjava.dll, (the DLL that implements the Microsoft VM) exports a special function named call. The call function's first argument is a pointer to a second function. All call does is invoke the second function, passing it the remaining arguments. </p>
<p>
The following is an example of how an application could load a DLL and call AFunction exported by the DLL:</p>
<pre><code>BOOL AFunction(LPCSTR argument);

  /** @dll.import("msjava") */
  static native boolean call(int funcptr,String argument);

  int hmod = LoadLibrary("...");
  int funcaddr = GetProcAddress(hmod, "AFunction");
  boolean result = call(funcaddr, "Hello");
  FreeLibrary(hmod);
</code></pre>
</BODY>
</HTML>
