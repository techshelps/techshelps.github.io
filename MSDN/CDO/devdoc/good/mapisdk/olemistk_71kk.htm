<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reinstantiating an Object</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_olemsg_reinstantiating_an_object"></a>Reinstantiating an Object</h1>
<p>
You normally instantiate a CDO library object by accessing a property on a parent object that causes the desired object to be created. For example, the statement </p>
<pre><code>Set objMsg = objSession.Inbox.Messages.Item(1) 
 </code></pre>
<p>
instantiates a <a href="oleobjaf_4u2c.htm">Folder</a> object for the <a href="oleobjis_7jqm.htm"><b>Inbox</b></a> property of the <a href="oleobjis_57w4.htm">Session</a> object, then a <a href="oleobjis_1qd0.htm">Messages</a> collection object for the <a href="oleobjaf_2jsi.htm"><b>Messages</b></a> property of the Inbox folder, and then a <a href="oleobjis_2p10.htm">Message</a> object for the <a href="oleobjis_3bdr.htm"><b>Item</b></a> property of the Messages collection. </p>
<p>
Every time you cross a period from left to right, you instantiate the object on the right of the period. This is true whether or not you have previously instantiated another version of the same object. This code fragment, for example, is intended to count the members of an <a href="oleobjaf_7qd0.htm">AddressEntries</a> collection that can resolve the name "John": </p>
<pre><code>Dim objAdrList As AddressList 
  Dim objAEFilt As AddressEntryFilter 
  Dim objAE As AddressEntry 
  ... 
  Set objAEFilt = objAdrList.AddressEntries.Filter 
  objAEFilt.Name = "John" ' set filter to restrict on this name 
  i = 0 
  For Each objAE in objAdrList.AddressEntries 
    i = i + 1 
    MsgBox objAE.Name 
  Next 
 </code></pre>
<p>
As written, however, this code counts every <a href="oleobjaf_6n1w.htm">AddressEntry</a> object in the collection. This is because the collection itself is instantiated twice, once when setting the filter and once when initializing the loop, in response to the code <code>objAdrList.AddressEntries</code>. The second collection is instantiated with a default <a href="oleobjaf_10ac.htm">AddressEntryFilter</a> object with no restrictions, which is used in the loop. The filter with the <a href="oleobjaf_180v.htm"><b>Name</b></a> property restriction remains with the first collection and is never used. </p>
<p>
This behavior is counterintuitive to programmers accustomed to having the same object returned by repeated references. But no variable is defined for an object that is generated internally by crossing a period, and Visual Basic has no way of correlating its internal objects. It is up to you to take care of the correlation at the source code level. </p>
<p>
The proper approach is to define and <b>Set</b> a variable for any object you plan to use more than once. In the case of the previous code fragment, it is the <a href="oleobjaf_7qd0.htm">AddressEntries</a> collection object that is to be reused: </p>
<pre><code>Dim colAddrEntries As AddressEntries 
  ... 
  Set colAddrEntries = objAdrList.AddressEntries 
  Set objAEFilt = colAddrEntries.Filter 
  objAEFilt.Name = "John" ' set filter to restrict on this name 
  i = 0 
  For Each objAE in colAddrEntries 
    i = i + 1 
    MsgBox objAE.Name 
  Next 
 </code></pre>
<p>
C/C++ programmers should observe that the period in Visual Basic is not a class member access operator, nor is it a pointer. Although <code>objAdrList.AddressEntries</code> may appear analogous to a construction such as <code>lpAdrList-&gt;AddressEntries</code>, there is in fact very little parallelism between the two, and access to a property in C/C++ requires more than a single statement. </p>
<p>
When you instantiate an object multiple times, you subject your application to several problems: 
<ul>
<li>
Your application wastes execution time and memory creating and retaining more than one version of the object. </li>
<li>
A subsequent instantiation does not <b>Release</b> a previous one, and all instantiated objects remain in memory with nonzero reference counts. </li>
<li>
The instantiations are unrelated to one another, and any operations you perform on one have no effect on any of the others. </li>
<li>
A given instantiation is used only by the code that follows its creation and precedes a subsequent instantiation. That is, different sections of your code are using different, unrelated versions of the object. </li>
</ul>
<p>
The safest procedure is to use explicit variables for all the objects and collections in your application. The consequence of not doing so can vary from inefficient execution to wrong results. For more information, see <a href="oletasks_1gv9.htm">Improving Application Performance</a>. </p>
<p>&nbsp;</p></body>
</HTML>
