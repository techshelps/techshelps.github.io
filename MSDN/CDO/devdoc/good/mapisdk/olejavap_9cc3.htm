<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Java Language Features</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_olemsg_java_language_features"></a>Java Language Features</h1>
<p>
The Java language is based on C++ and shows considerable similarity to it. In particular, Java code is case-sensitive. There are, however, significant differences between the two languages. </p>
<p>
Because it is interpreted instead of compiled, Java cannot process <b>#define</b> directives. This means that the constants defined in the CDO and CDO Rendering type libraries cannot be used in a Java program. You have to use numeric equivalents, which can be found in the <a href="oleerror_0y7n.htm">Error Codes</a>, <a href="oleprops_8i0j.htm">MAPI Property Tags</a>, and <a href="cdoexprp_5vzn.htm">Microsoft Exchange Property Tags</a> appendixes. </p>
<p>
Java does not provide any error trapping mechanism equivalent to the Microsoft® Visual Basic® <b>On Error GoTo</b> statement. All errors must be anticipated and explicitly tested for after each call that could generate them. </p>
<p>
Like all alphanumeric elements in Java, the keywords are case-sensitive. Their predefined values are all lowercase, such as <b>true</b>, <b>false</b>, and <b>null</b>. This means Java does not recognize capitalized keywords such as <b>True</b>, <b>False</b>, or <b>Null</b>, which you may be accustomed to using in Visual Basic. </p>
<p>
Java objects expose only methods and no properties. CDO library properties are referenced through accessor methods defined for each property by prefixing <b>get</b> or <b>put</b> to the property name, for example <b>getInbox</b> and <b>putSubject</b>. Parameters to methods are referenced by accessor methods with <b>get</b> or <b>put</b> prefixed to the data type, such as <b>getString</b> and <b>putBoolean</b>. </p>
<p>
Read-only properties use the corresponding <b>get</b> accessor method. The <a href="oleobjis_7jqm.htm"><b>Inbox</b></a> property of the <a href="oleobjis_57w4.htm">Session</a> object, for example, can be read with the <b>getInbox</b> method: </p>
<pre><code>Variant inboxFolder = new Variant(); 
  inboxFolder = session.getInbox(); 
 </code></pre>
<p>
Read/write properties use the corresponding <b>get</b> and <b>put</b> accessor methods. For example, the <a href="oleobjis_7411.htm"><b>Subject</b></a> property of the <a href="oleobjis_2p10.htm">Message</a> object can be read with <b>getSubject</b> and written with <b>putSubject</b>, after the parameter is prepared with the help of the <b>getString</b> and <b>putString</b> methods: </p>
<pre><code>Variant inSubject = new Variant(); 
  StringBuffer newSubject = new StringBuffer( "RE: " ); 
  Variant outSubject = new Variant(); 
 ... 
  inSubject = inMessage.getSubject(); 
  newSubject.append( inSubject.getString() ); // already have "RE: " 
  outSubject.putString( newSubject.toString() ); 
  outMessage.putSubject( outSubject ); 
 </code></pre>
<p>
The property accessor methods such as <b>getInbox</b> always return a Variant object. If your code assigns them to another Variant object, as in the preceding code fragments, the types already match. If, however, you cast an object returned from an accessor method to another object type, you need to use the <b>getDispatch</b> method to obtain a type match: </p>
<pre><code>Folder inboxFolder; 
  inboxFolder = (Folder) session.getInbox().getDispatch(); 
 </code></pre>
<p>
The CDO libraries support the <b>IDispatch</b> interface, which allows a program to access the underlying messaging and rendering objects. Invocation of the <b>getDispatch</b> method signals Java to call <b>QueryInterface</b> on a Variant object and obtain the appropriate messaging or rendering interface for it. For more information, see <a href="oleprobj_7e08.htm">IDispatch</a>. </p>
<p>
Java methods do not allow for optional parameters. Calls to methods must present every parameter included in the definition of the method. The equivalent of a Visual Basic <b>Null</b> parameter can be achieved by using the <b>noParam</b> method on a Java Variant object: </p>
<pre><code>Variant nullPar = new Variant(); 
  nullPar.noParam(); 
  object.Method( firstPar, nullPar, thirdPar, nullPar, nullPar ); 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
