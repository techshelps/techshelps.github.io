<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SENDRECV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5091"></a>SENDRECV.C</h2>
<pre><code>/* sendrecv.c */ <br>/* (C) COPYRIGHT DATA CONNECTION LIMITED 1993 */ <br> <br>/*****************************************************************************/ <br>/* Change History                                                            */ <br>/*                                                                           */ <br>/*       04/05/93 NGR Created.                                               */ <br>/* TPED  26/05/93 SW  RECVTP must issue TP_ENDED after each conversation     */ <br>/* PERF  24/06/93 SW  Don't regenerate data for each SEND verb               */ <br>/* FILE  02/07/93 NGR Don't attempt to close NULL file handle                */ <br>/* PATH  10/08/93 NGR Gord's changes to get config from current directory    */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/*                                                                           */ <br>/* ROUTINE : SENDRECV                                                        */ <br>/*                                                                           */ <br>/* FUNCTION: This file contains the main routines for a simple bulk data     */ <br>/*           sending and receiving TPs SENDTP and RECVTP                     */ <br>/*                                                                           */ <br>/* INPUTS  : SENDTP.CFG (file) (documented below)                            */ <br>/*           RECVTP.CFG (file) (documented below)                            */ <br>/*                                                                           */ <br>/* OUTPUTS : SENDTP.OUT                                                      */ <br>/*           RECVTP.OUT                                                      */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* Operation:                                                                */ <br>/*                                                                           */ <br>/* SENDTP                                                                    */ <br>/* DOS and OS/2. Simple command line TP which simply allocates, does the     */ <br>/* specified number of send_data and then deallocates. Done via a while loop */ <br>/* which makes calls to IssueNextVerb.                                       */ <br>/*                                                                           */ <br>/* RECVTP                                                                    */ <br>/* As SENDTP, but it receive_allocates, then receive_and_waits until it gets */ <br>/* deallocated. Repeat this NumConversation times.                           */ <br>/*                                                                           */ <br>/* NT and Win16. Simple windows apps which use the async verbs and control   */ <br>/* operation via the window proc of a minimised window. This proc makes      */ <br>/* calls to IssueNextVerb on receipt of an async_complete message            */ <br>/*                                                                           */ <br>/* IssueNextVerb uses the opcode of the verb which just completed to         */ <br>/* decide what to issue next, and calls the appropriate do_ routine to fill  */ <br>/* in the vcb, it then calls the appropriate APPC entry point.               */ <br>/*                                                                           */ <br>/* Send TP will initially issue a SEND_CONVERSATION verb in order to send    */ <br>/* the number of conversations to be done to the Recv TP which expect this   */ <br>/* to be sent to it.                                                         */ <br>/*                                                                           */ <br>/* The applications will terminate if they encounter an error and do not     */ <br>/* produce diagnostic output so the APPC API trace is the best place to look */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* Configuration files:                                                      */ <br>/*                                                                           */ <br>/* Configuration file is C:\SENDTP.CFG or RECVTP.CFG which contains          */ <br>/* the following, one per line in any order. If not present then the given   */ <br>/* default is assumed.                                                       */ <br>/*                                                                           */ <br>/* ResultFile = &lt;Name of file for results, default C:\(SEND/RECV)TP.OUT&gt;     */ <br>/* LocalTPName = &lt;Name to be used for TP started, default SENDTP/RECVTP&gt;     */ <br>/*                                                                           */ <br>/* The following only apply to SENDTP                                        */ <br>/*                                                                           */ <br>/* NumConversations = &lt;Number of conversations to be done, default = 1&gt;      */ <br>/* LocalLUAlias = &lt;Alias for local LU (!), default SENDLU&gt;                   */ <br>/* RemoteLUAlias = &lt;Alias for remote LU (!!), default RECVLU&gt;                */ <br>/* ModeName = &lt;!?! default #INTER&gt;                                           */ <br>/* RemoteTPName = &lt;name of the TP, default RECVTP&gt;                           */ <br>/* NumSends = &lt;number of SEND_DATA verbs per conversation, default = 2&gt;      */ <br>/* ConfirmEvery = &lt;number of SEND_DATA verbs between CONFIRMs, default = 1&gt;  */ <br>/* SendSize = &lt;number of bytes per SEND_DATA, default = 1024&gt;                */ <br>/* SendConversation = &lt;use the SEND_CONVERSATION verb, default = no&gt;         */ <br>/*                                                                           */ <br>/* Note that if SendConversation is used then NumSends is irrelevant, the TP */ <br>/* will simply do NumConversations SEND_CONVERSATION verbs                   */ <br>/* If NumConversations is zero, then the TPs will do an infinite number of   */ <br>/* conversations.                                                            */ <br>/* If NumSends is zero, then SENDTP will never DEALLOCATE the first          */ <br>/* conversation.                                                             */ <br>/* If ConfirmEvery is zero, then SENDTP will not issue CONFIRM verbs.        */ <br>/*****************************************************************************/ <br>#if (defined(WINDOWS)||defined(WIN32)) <br>#include &lt;windows.h&gt; <br>HINSTANCE hInst; <br>#endif <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winappc.h&gt; <br>#include &lt;wincsv.h&gt; <br>#include "sendrecv.h" <br> <br>#if defined(DOS5) || defined(DOS) <br>#define SYNC <br>#endif <br> <br>#ifdef WINDOWS <br>#define memset(x,y,z) _fmemset(x,y,z) <br>#define memchr(x,y,z) _fmemchr(x,y,z) <br>#define strupr(x) _fstrupr(x) <br>#define strcmpi(x,y) _fstricmp(x,y) <br>#define strncpy(x,y,z) _fstrncpy(x,y,z) <br>#endif <br> <br>#ifdef SYNC <br>/*****************************************************************************/ <br>/* main - reads initialisation info and creates threads                      */ <br>/*        DOS &amp; OS\2 version                                                 */ <br>/*****************************************************************************/ <br>void main( int argc, char FAR * argv[]) <br>{ <br> <br>#if defined(WIN32) || defined(WINDOWS) <br>  WAPPCDATA APPCData; <br>  WNDCLASS class; <br>  #define WinAPPCVERSION  0x0001 <br> <br>  /**************************************************************************/ <br>  /* Startup WinAPPC                                                        */ <br>  /**************************************************************************/ <br>  if (WinAPPCStartup(WinAPPCVERSION,&amp;APPCData)) <br>  { <br>     return (FALSE); <br>  } <br>#endif <br> <br>  printf("\n\n\n\n\n\n\n"); <br>#ifdef SENDTP <br>  printf("SENDTP - APPC Bulk data send program to be used with RECVTP\n"); <br>#else <br>  printf("RECVTP - APPC Bulk data recv program to be used with SENDTP\n"); <br>#endif <br>  printf("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\n"); <br> <br> <br>  InitialiseMain(); <br>  ReadConfig(); <br> <br>  while (!TPDead) <br>  { <br>     IssueNextVerb(); <br>  } <br>#ifdef SENDTP <br>  OutputResults(); <br>#endif <br> <br>#if defined(WIN32) || defined(WINDOWS) <br>  WinAPPCCleanup(); <br>#endif <br> <br>  printf("Finished"); <br> <br>} <br>#else <br>/*****************************************************************************/ <br>/* WinMain - reads initialisation info and controls message loop             */ <br>/*           NT and Win16 version                                            */ <br>/*****************************************************************************/ <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                   LPSTR lpCmdLine, int nCmdShow) <br>{ <br> <br>  MSG msg; <br> <br>  hInst = hInstance; <br> <br>  InitialiseMain(); <br> <br>  if (!InitialiseWinMain(hInstance)) <br>  { <br>     return (FALSE); <br>  } <br> <br>  ReadConfig(); <br> <br>  while(GetMessage(&amp;msg,NULL,0,0)) <br>  { <br>     TranslateMessage(&amp;msg); <br>     DispatchMessage(&amp;msg); <br>  } <br> <br>  return msg.wParam;         /* save exit parameter for return               */ <br> <br>} <br> <br>/*****************************************************************************/ <br>/* InitialiseWinMain - does the windows bits of initialisation               */ <br>/*****************************************************************************/ <br>BOOL InitialiseWinMain(HINSTANCE hInstance) <br>{ <br>   WAPPCDATA APPCData; <br>   WNDCLASS class; <br>   #define WinAPPCVERSION  0x0001 <br> <br>   /**************************************************************************/ <br>   /* Startup WinAPPC                                                        */ <br>   /**************************************************************************/ <br>   if (WinAPPCStartup(WinAPPCVERSION,&amp;APPCData)) <br>   { <br>      return (FALSE); <br>   } <br> <br>   if ( (ASYNC_COMPLETE = <br>         RegisterWindowMessage(WIN_APPC_ASYNC_COMPLETE_MESSAGE)) == 0 ) <br>   { <br>      return (0); <br>   } <br> <br>   async_corr=0; <br> <br>   /**************************************************************************/ <br>   /* Register Window Class for our icon                                     */ <br>   /**************************************************************************/ <br> <br>   class.style = 0; <br>   class.lpfnWndProc   = (WNDPROC)TPWndProc; <br>   class.cbClsExtra    = (DWORD)0; <br>   class.cbWndExtra    = (DWORD)0; <br>   class.hInstance     = hInstance; <br>   class.hIcon         = LoadIcon(hInstance,"MainIcon"); <br>   class.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>   class.hbrBackground = GetStockObject(WHITE_BRUSH); <br>   class.lpszMenuName  = (LPSTR) NULL; <br>   class.lpszClassName = (LPSTR) "SENDRECV\0"; <br> <br>   if (!RegisterClass(&amp;class)) <br>   { <br>     return (FALSE); <br>   } <br> <br>   /**************************************************************************/ <br>   /* Create the window                                                      */ <br>   /**************************************************************************/ <br>#ifdef SENDTP <br>   sprintf(title,"APPC Send TP\0"); <br>#else <br>   sprintf(title,"APPC Receive TP\0"); <br>#endif <br> <br>   if ((hWndMain = CreateWindow("SENDRECV\0",      /* window class           */ <br>       title,                                      /* window name            */ <br>       WS_MINIMIZE|WS_OVERLAPPEDWINDOW,            /* window style           */ <br>       0,                                          /* x position             */ <br>       0,                                          /* y position             */ <br>       10,                                         /* width                  */ <br>       10,                                         /* height                 */ <br>       NULL,                                       /* parent handle          */ <br>       NULL,                                       /* menu or child ID       */ <br>       hInstance,                                  /* instance               */ <br>       NULL))                                      /* additional info        */ <br>       == NULL) <br>   { <br>      return (FALSE); <br>   } <br> <br>   ShowWindow(hWndMain, SW_MINIMIZE); <br> <br>   return(TRUE); <br> <br>} <br> <br>/*****************************************************************************/ <br>/* Window proc for the iconised window                                       */ <br>/*****************************************************************************/ <br>LONG FAR PASCAL TPWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br>{ <br>   if (message == ASYNC_COMPLETE) <br>   { <br>      if (wParam != (WPARAM) async_corr) <br>      { <br>         /*****************************************************************/ <br>         /* This is not the correlator we were expecting, so we must die. */ <br>         /*****************************************************************/ <br>         TPDead = TRUE; <br>#ifdef WIN32 <br>         DebugBreak(); <br>#endif <br>      } <br>      else <br>      { <br>#ifdef SENDTP <br>         IssueNextVerb(); <br>#else <br>         if (!GotNumConv) <br>         { <br>            /*****************************************************************/ <br>            /* We are still in the process of getting the number of convs to */ <br>            /* be done, so do the next stage of this. Note if all is not OK  */ <br>            /* then we just die.                                             */ <br>            /*****************************************************************/ <br>            Get_Run_Details(); <br>            if (TPDead) <br>            { <br>               PostMessage(hWndMain, WM_CLOSE, 0, 0); <br>            } <br>         } <br>         else <br>         { <br>            IssueNextVerb(); <br>         } <br>#endif <br>      } <br>   } <br>   else <br>   { <br>      switch (message) <br>      { <br>         case WM_CREATE: <br>            /*****************************************************************/ <br>            /* Post a message to ourselves to kick off the first verb        */ <br>            /*****************************************************************/ <br>            vcb.hdr.opcode = 0x0000; <br>            async_corr = 0; <br>            PostMessage(hWnd, ASYNC_COMPLETE, (WPARAM)async_corr, <br>                                                 (LPARAM)(char FAR *)(vcbptr)); <br>            break; <br> <br>         case WM_QUERYOPEN: <br>            /*****************************************************************/ <br>            /* Prevent the window being opened                               */ <br>            /*****************************************************************/ <br>            break; <br> <br>         case WM_CLOSE: <br>            TPDead = TRUE; <br>            WinAPPCCleanup(); <br>#ifdef SENDTP <br>            OutputResults(); <br>#endif <br>            return DefWindowProc(hWnd, message, wParam, lParam); <br>            break; <br> <br>         case WM_DESTROY: <br>if( DataPtr != NULL ) <br>{ <br>#ifdef WINDOWS <br>GlobalUnlock(LOWORD(GlobalHandle(SELECTOROF(DataPtr)))); <br>GlobalFree(LOWORD(GlobalHandle(SELECTOROF(DataPtr)))); <br>#else <br> #ifdef WIN32 <br> free(DataPtr); <br> #else <br> DosFreeSeg(selector); <br> #endif <br>#endif <br>} <br>            PostQuitMessage(0); <br>            break; <br> <br>         default: <br>            return DefWindowProc(hWnd, message, wParam, lParam); <br>            break; <br>      } <br>   } <br>   return 0l; <br>} <br> <br>#endif <br> <br>/*****************************************************************************/ <br>/* InitialiseMain - blanks out variables.                                    */ <br>/*****************************************************************************/ <br>void InitialiseMain() <br>{ <br>   NumConversations=0; <br>   FirstConv=TRUE; <br>   memset(LocalTPName,0,64); <br>   ConvCount=0; <br>   Convid=0; <br>   SendSize=0; <br>   memset(TPid,0,8); <br>   TPDead=FALSE; <br>   vcbptr=(char *)&amp;vcb; <br>   cnvtptr=(char *)&amp;cnvt; <br> <br>#ifdef SENDTP <br>   NumSends=0; <br>   SendConversation=0; <br>   ConfirmEvery=0; <br>   SendCount=0; <br>   ConfirmCount=0; <br>   datach='A'; <br> <br>   memset(LocalLUAlias,0,8); <br>   memset(RemoteLUAlias,0,8); <br>   memset(ModeName,0,8); <br>   memset(RemoteTPName,0,64); <br>#else <br>   GotNumConv = FALSE; <br>   GetStage = 0; <br>#endif <br> <br> <br>} <br> <br>/*****************************************************************************/ <br>/* IssueNextVerb - looks at the verb which has just completed and does the   */ <br>/*                 next one                                                  */ <br>/*****************************************************************************/ <br>void IssueNextVerb() <br>{ <br>   if (vcb.hdr.opcode != 0x0000) <br>   { <br>      ProcessReturns(); <br>   } <br>   if (!TPDead) <br>   { <br>      switch (vcb.hdr.opcode) <br>      { <br>         case 0x0000: <br>#ifdef SENDTP <br>            Build_TP_STARTED(); <br> <br>            /**************************************************************/ <br>            /*PERF* Don't re-generate data each time we issue a send!     */ <br>            /**************************************************************/ <br>            GenerateData(); <br> <br>#else <br>            Build_RECEIVE_ALLOCATE(); <br>#endif <br>            break; <br> <br>#ifdef SENDTP <br>         case AP_TP_STARTED: <br>            if (ConvCount == 0) <br>            { <br>               Send_Run_Details(); <br>            } <br>            if (!TPDead) <br>            { <br>               NewConversation(); <br>               if (SendConversation) <br>               { <br>                  Build_MC_SEND_CONVERSATION(); <br>               } <br>               else <br>               { <br>                  Build_MC_ALLOCATE(); <br>               } <br>            } <br>            break; <br> <br>         case AP_M_ALLOCATE: <br>            Build_MC_SEND_DATA(); <br>            break; <br> <br>         case AP_M_SEND_DATA: <br>            SendCount++; <br>            ConfirmCount++; <br>            if ((NumSends != 0) &amp;&amp; (SendCount == NumSends)) <br>            { <br>               Build_MC_DEALLOCATE(); <br>            } <br>            else if ((ConfirmEvery != 0) &amp;&amp; (ConfirmCount == ConfirmEvery)) <br>            { <br>               Build_MC_CONFIRM(); <br>            } <br>            else <br>            { <br>               Build_MC_SEND_DATA(); <br>            } <br>            break; <br> <br>         case AP_M_SEND_CONVERSATION: <br>            if ((NumConversations != 0) &amp;&amp; (ConvCount == NumConversations)) <br>            { <br>               NewConversation(); <br>               Build_TP_ENDED(); <br>            } <br>            else <br>            { <br>               NewConversation(); <br>               Build_MC_SEND_CONVERSATION(); <br>            } <br>            break; <br> <br>         case AP_M_CONFIRM: <br>            ConfirmCount=0; <br>            Build_MC_SEND_DATA(); <br>            break; <br> <br>         case AP_M_DEALLOCATE: <br>            if ((NumConversations !=0) &amp;&amp; (ConvCount == NumConversations)) <br>            { <br>               NewConversation(); <br>               Build_TP_ENDED(); <br>            } <br>            else <br>            { <br>               NewConversation(); <br>               Build_MC_ALLOCATE(); <br>            } <br>            break; <br> <br>         case AP_TP_ENDED: <br>            /**************************************************************/ <br>            /*TPED* Quit out and die if SENDTP                            */ <br>            /**************************************************************/ <br>            TPDead = TRUE; <br>            break; <br>#else <br>         case AP_RECEIVE_ALLOCATE: <br>            NewConversation(); <br>            Build_MC_RECEIVE_AND_WAIT(); <br>            break; <br> <br>         case AP_M_RECEIVE_AND_WAIT: <br>            if ((vcb.rcvwait.primary_rc == AP_DEALLOC_NORMAL)) <br>            { <br>               /*************************************************************/ <br>               /*TPED* Issue TP_ENDED every time conversation deallocated   */ <br>               /*************************************************************/ <br>               Build_TP_ENDED(); <br>            } <br>            else if ((vcb.rcvwait.what_rcvd == AP_CONFIRM_WHAT_RECEIVED) || <br>                     (vcb.rcvwait.what_rcvd == AP_DATA_COMPLETE_CONFIRM)) <br>            { <br>               Build_MC_CONFIRMED(); <br>               Deallocated = FALSE; <br>            } <br>            else if ((vcb.rcvwait.what_rcvd == AP_CONFIRM_DEALLOCATE) || <br>                     (vcb.rcvwait.what_rcvd == AP_DATA_COMPLETE_CONFIRM_DEALL)) <br>            { <br>               Build_MC_CONFIRMED(); <br>               Deallocated = TRUE; <br>            } <br>            else <br>            { <br>               Build_MC_RECEIVE_AND_WAIT(); <br>            } <br>            break; <br> <br>         case AP_M_CONFIRMED: <br>            if (Deallocated) <br>            { <br>               /*************************************************************/ <br>               /*TPED* Issue TP_ENDED every time conversation deallocated   */ <br>               /*************************************************************/ <br>               Build_TP_ENDED(); <br>            } <br>            else <br>            { <br>               Build_MC_RECEIVE_AND_WAIT(); <br>            } <br>            break; <br> <br>         case AP_TP_ENDED: <br>            /**************************************************************/ <br>            /*TPED* If not completed all conversations,  issue RCV_ALLOC  */ <br>            /**************************************************************/ <br>            if ((NumConversations != 0) &amp;&amp; (ConvCount &lt; NumConversations)) <br>            { <br>               Build_RECEIVE_ALLOCATE(); <br>            } <br>            else <br>            { <br>               TPDead = TRUE; <br>            } <br>            break; <br>#endif <br> <br>         default: <br>            /*****************************************************************/ <br>            /* What is this verb then ??                                     */ <br>            /*****************************************************************/ <br>            TPDead = TRUE; <br>#ifdef WIN32 <br>            DebugBreak(); <br>#endif <br>            break; <br> <br>      } /* Op-code switch */ <br> <br>   } /* TPDead after previous verb */ <br> <br>   /**************************************************************************/ <br>   /* Now go ahead and issue the verb, if we're not dead.                    */ <br>   /**************************************************************************/ <br>   if (!TPDead) <br>   { <br>#ifdef SYNC <br>      APPC((long)(vcbptr)); <br>#else <br>      async_corr=WinAsyncAPPC(hWndMain, (long)(char FAR *)(vcbptr)); <br>#endif <br>   } <br>#ifndef SYNC <br>   else <br>   { <br>      PostMessage(hWndMain, WM_CLOSE, 0, 0); <br>   } <br>#endif <br>} /* Issue next verb */ <br> <br>#ifdef SENDTP <br>void Build_TP_STARTED() <br>{ <br>   CLEARVCB <br> <br>   vcb.tpstart.opcode = AP_TP_STARTED; <br>   memcpy(&amp;(vcb.tpstart.lu_alias), LocalLUAlias, 8); <br>   memcpy(&amp;(vcb.tpstart.tp_name), LocalTPName, 64); <br> <br>} <br> <br>void Build_MC_ALLOCATE() <br>{ <br>   CLEARVCB <br> <br>   vcb.allocate.opcode = AP_M_ALLOCATE; <br>   vcb.allocate.opext = AP_MAPPED_CONVERSATION; <br>   memcpy(&amp;(vcb.allocate.tp_id),TPid, 8); <br>   vcb.allocate.sync_level = AP_CONFIRM_SYNC_LEVEL; <br>   vcb.allocate.rtn_ctl = AP_WHEN_SESSION_ALLOCATED; <br>   memcpy(&amp;(vcb.allocate.plu_alias), RemoteLUAlias, 8); <br>   memcpy(&amp;(vcb.allocate.mode_name), ModeName, 8); <br>   memcpy(&amp;(vcb.allocate.tp_name), RemoteTPName, 64); <br>   vcb.allocate.security = AP_NONE; <br> <br>} <br> <br>void Build_MC_DEALLOCATE() <br>{ <br>   CLEARVCB <br> <br>   vcb.deallocate.opcode = AP_M_DEALLOCATE; <br>   vcb.deallocate.opext = AP_MAPPED_CONVERSATION; <br>   memcpy(&amp;(vcb.deallocate.tp_id), TPid, 8); <br>   vcb.deallocate.conv_id = Convid; <br>   if (ConfirmEvery == 0) <br>   { <br>      vcb.deallocate.dealloc_type = AP_FLUSH; <br>   } <br>   else <br>   { <br>      vcb.deallocate.dealloc_type = AP_SYNC_LEVEL; <br>   } <br> <br>} <br> <br>void Build_MC_SEND_DATA() <br>{ <br>   CLEARVCB <br> <br>   //  PERF - GenerateData(); <br> <br>   vcb.snddata.opcode = AP_M_SEND_DATA; <br>   vcb.snddata.opext = AP_MAPPED_CONVERSATION; <br>   memcpy(&amp;(vcb.snddata.tp_id), TPid, 8); <br>   vcb.snddata.conv_id = Convid; <br>   vcb.snddata.dlen = SendSize; <br>   vcb.snddata.dptr = DataPtr; <br>   vcb.snddata.type = AP_NONE; <br>} <br> <br>void Build_MC_SEND_CONVERSATION() <br>{ <br>   CLEARVCB <br> <br>   // PERF - GenerateData(); <br> <br>   vcb.sndconv.opcode = AP_M_SEND_CONVERSATION; <br>   vcb.sndconv.opext = AP_MAPPED_CONVERSATION; <br>   memcpy(&amp;(vcb.sndconv.tp_id), TPid, 8); <br>   vcb.sndconv.rtn_ctl = AP_WHEN_SESSION_ALLOCATED; <br>   memcpy(&amp;(vcb.sndconv.plu_alias), RemoteLUAlias, 8); <br>   memcpy(&amp;(vcb.sndconv.mode_name), ModeName, 8); <br>   memcpy(&amp;(vcb.sndconv.tp_name), RemoteTPName, 64); <br>   vcb.sndconv.security = AP_NONE; <br>   vcb.sndconv.dlen = SendSize; <br>   vcb.sndconv.dptr = DataPtr; <br>} <br> <br>void Build_MC_CONFIRM() <br>{ <br>   CLEARVCB <br> <br>   vcb.confirm.opcode = AP_M_CONFIRM; <br>   vcb.confirm.opext = AP_MAPPED_CONVERSATION; <br>   memcpy(&amp;(vcb.confirm.tp_id), TPid, 8); <br>   vcb.confirm.conv_id = Convid; <br>} <br>#else <br> <br>void Build_RECEIVE_ALLOCATE() <br>{ <br>   CLEARVCB <br> <br>   vcb.rcvalloc.opcode = AP_RECEIVE_ALLOCATE; <br>   memcpy(&amp;(vcb.rcvalloc.tp_name), LocalTPName, 64); <br>} <br> <br>void Build_MC_RECEIVE_AND_WAIT() <br>{ <br>   CLEARVCB <br> <br>   vcb.rcvwait.opcode = AP_M_RECEIVE_AND_WAIT; <br>   vcb.rcvwait.opext = AP_MAPPED_CONVERSATION; <br>   memcpy(&amp;(vcb.rcvwait.tp_id),TPid,8); <br>   vcb.rcvwait.conv_id = Convid; <br>   vcb.rcvwait.rtn_status = AP_YES; <br>   vcb.rcvwait.max_len = 0xFFFF; <br>   vcb.rcvwait.dptr = DataPtr; <br>} <br> <br>void Build_MC_CONFIRMED() <br>{ <br>   CLEARVCB <br> <br>   vcb.confirmed.opcode = AP_M_CONFIRMED; <br>   vcb.confirmed.opext = AP_MAPPED_CONVERSATION; <br>   memcpy(&amp;(vcb.confirmed.tp_id),TPid,8); <br>   vcb.confirmed.conv_id = Convid; <br>} <br>#endif <br> <br>void Build_TP_ENDED() <br>{ <br>   CLEARVCB <br> <br>   vcb.tpend.opcode = AP_TP_ENDED; <br>   memcpy(&amp;(vcb.tpend.tp_id), TPid, 8); <br>   vcb.tpend.type = AP_SOFT; <br>} <br> <br>#ifdef SENDTP <br>void Send_Run_Details() <br>{ <br>   /**************************************************************************/ <br>   /* Issues a Send_Conversation verb to send the number of conversations to */ <br>   /* be done to the other side.                                             */ <br>   /**************************************************************************/ <br>   CLEARVCB <br> <br>   vcb.sndconv.opcode = AP_M_SEND_CONVERSATION; <br>   vcb.sndconv.opext = AP_MAPPED_CONVERSATION; <br>   memcpy(&amp;(vcb.sndconv.tp_id), TPid, 8); <br>   vcb.sndconv.rtn_ctl = AP_WHEN_SESSION_ALLOCATED; <br>   memcpy(&amp;(vcb.sndconv.plu_alias), RemoteLUAlias, 8); <br>   memcpy(&amp;(vcb.sndconv.mode_name), ModeName, 8); <br>   memcpy(&amp;(vcb.sndconv.tp_name), RemoteTPName, 64); <br>   vcb.sndconv.security = AP_NONE; <br>   vcb.sndconv.dlen = sizeof(unsigned short); <br>   vcb.sndconv.dptr = DataPtr; <br>#ifdef WIN32 <br>   *((unsigned short UNALIGNED *) DataPtr) = NumConversations; <br>#else <br>   *((unsigned short far *)DataPtr) = NumConversations; <br>#endif <br> <br>   APPC((long)(vcbptr)); <br>   if (vcb.sndconv.primary_rc != AP_OK) <br>   { <br>      TPDead = TRUE; <br>   } <br>} <br>#else <br>void Get_Run_Details() <br>{ <br>   /**************************************************************************/ <br>   /* Issues a Receive_Allocate and Receive_and_wait verb to get the number  */ <br>   /* of conversations to be done.                                           */ <br>   /* Returns true if this was successful, false otherwise.                  */ <br>   /**************************************************************************/ <br>   switch (GetStage) <br>   { <br>      case 0: <br> <br>         CLEARVCB <br>         vcb.rcvalloc.opcode = AP_RECEIVE_ALLOCATE; <br>         memcpy(&amp;(vcb.rcvalloc.tp_name), LocalTPName, 64); <br>         async_corr=WinAsyncAPPC(hWndMain, (long)(char FAR *)(vcbptr)); <br>         GetStage = 1; <br>         break; <br> <br>      case 1: <br> <br>         if (vcb.rcvalloc.primary_rc != AP_OK) <br>         { <br>            TPDead = TRUE; <br>         } <br>         else <br>         { <br>            memcpy(TPid,&amp;(vcb.rcvalloc.tp_id),8); <br>            Convid = vcb.rcvalloc.conv_id; <br>            CLEARVCB <br>            vcb.rcvwait.opcode = AP_M_RECEIVE_AND_WAIT; <br>            vcb.rcvwait.opext = AP_MAPPED_CONVERSATION; <br>            memcpy(&amp;(vcb.rcvwait.tp_id),TPid,8); <br>            vcb.rcvwait.conv_id = Convid; <br>            vcb.rcvwait.rtn_status = AP_YES; <br>            vcb.rcvwait.max_len = sizeof(unsigned short); <br>            vcb.rcvwait.dptr = DataPtr; <br>            async_corr=WinAsyncAPPC(hWndMain, (long)(char FAR *)(vcbptr)); <br>            GetStage = 2; <br>         } <br>         break; <br> <br>      case 2: <br> <br>         if (vcb.rcvwait.primary_rc != AP_DEALLOC_NORMAL) <br>         { <br>            TPDead = TRUE; <br>         } <br>         else <br>         { <br>#ifdef WIN32 <br>            NumConversations = *((unsigned short UNALIGNED *)DataPtr); <br>#else <br>            NumConversations = *((unsigned short far *)DataPtr); <br>#endif <br>            CLEARVCB <br>            vcb.tpend.opcode = AP_TP_ENDED; <br>            memcpy(&amp;(vcb.tpend.tp_id), TPid, 8); <br>            vcb.tpend.type = AP_SOFT; <br>            async_corr=WinAsyncAPPC(hWndMain, (long)(char FAR *)(vcbptr)); <br>            GetStage = 3; <br>         } <br>         break; <br> <br>      case 3: <br> <br>         if (vcb.tpend.primary_rc != AP_OK) <br>         { <br>            TPDead = TRUE; <br>         } <br>         else <br>         { <br>            GotNumConv = TRUE; <br>            vcb.hdr.opcode = 0x0000; <br>            async_corr = 0; <br>            PostMessage(hWndMain, ASYNC_COMPLETE, (WPARAM)async_corr, <br>                                                 (LPARAM)(char FAR *)(vcbptr)); <br>         } <br>         break; <br>   } <br>} <br>#endif <br> <br> <br>/*****************************************************************************/ <br>/* ProcessReturns - Checks return codes from the last verb to complete and   */ <br>/*                  saves off any useful information. If the return code is  */ <br>/*                  bad then we just die.                                    */ <br>/*****************************************************************************/ </code></pre>
<p>
</p>
<pre><code>void ProcessReturns() <br>{ <br>   if ( (  vcb.hdr.primary_rc != AP_OK) &amp;&amp; <br>       !( (vcb.hdr.opcode == AP_M_RECEIVE_AND_WAIT)&amp;&amp; <br>          (vcb.hdr.primary_rc == AP_DEALLOC_NORMAL)  )  ) <br>   { <br>      TPDead = TRUE; <br>   } <br>   else <br>   { <br>      switch (vcb.hdr.opcode) <br>      { <br>         case AP_TP_ENDED: <br>            break; <br>#ifdef SENDTP <br>         case AP_TP_STARTED: <br>            memcpy(TPid,&amp;(vcb.tpstart.tp_id),8); <br>            break; <br> <br>         case AP_M_SEND_CONVERSATION: <br>            break; <br> <br>         case AP_M_ALLOCATE: <br>            Convid = vcb.allocate.conv_id; <br>            break; <br> <br>         case AP_M_SEND_DATA: <br>            break; <br> <br>         case AP_M_DEALLOCATE: <br>            Convid = 0; <br>            break; <br> <br>         case AP_M_CONFIRM: <br>            break; <br>#else <br>         case AP_RECEIVE_ALLOCATE: <br>            memcpy(TPid,&amp;(vcb.rcvalloc.tp_id),8); <br>            Convid = vcb.rcvalloc.conv_id; <br>            break; <br> <br>         case AP_M_RECEIVE_AND_WAIT: <br>            break; <br> <br>         case AP_M_CONFIRMED: <br>            break; <br>#endif <br>         default: <br>            TPDead = TRUE; <br>#ifdef WIN32 <br>            DebugBreak(); <br>#endif <br>            break; <br>      } <br>   } <br>} <br> <br>/*****************************************************************************/ <br>/* ReadConfig - Reads config info from SENDTP.CFG also allocates buffer for  */ <br>/*              sending                                                      */ <br>/*****************************************************************************/ <br>void ReadConfig() <br>{ <br>#ifdef SENDTP <br>   char buffer[200]; <br>#endif <br>#ifdef DOS5 <br>   unsigned short selector; <br>#endif <br> <br>   SendSize = 0xFFFF; <br> <br>   if (!ReadString("LocalTPName",LocalTPName,64)) <br>   { <br>#ifdef SENDTP <br>      strncpy(LocalTPName,"SENDTP",6); <br>#else <br>      strncpy(LocalTPName,"RECVTP",6); <br>#endif <br>   } <br>   PadString(LocalTPName,64); <br>   CONV_A_TO_E(LocalTPName,64); <br> <br>#ifdef SENDTP <br>   if (!ReadString("ResultFile",FileName,60)) <br>   { <br>      strcpy(FileName,"C:\\SENDTP.OUT"); <br>   } <br>   NumConversations=1; <br>   if (ReadString("NumConversations",buffer,200)) <br>   { <br>      NumConversations=atoi(buffer); <br>   } <br>   if (!ReadString("LocalLUAlias",LocalLUAlias,8)) <br>   { <br>      strncpy(LocalLUAlias,"SENDLU",8); <br>   } <br>   PadString(LocalLUAlias,8); <br>   if (!ReadString("RemoteLUAlias",RemoteLUAlias,8)) <br>   { <br>      strncpy(RemoteLUAlias,"RECVLU",8); <br>   } <br>   PadString(RemoteLUAlias,8); <br>   if (!ReadString("ModeName",ModeName,8)) <br>   { <br>      strncpy(ModeName,"#INTER",8); <br>   } <br>   PadString(ModeName,8); <br>   CONV_A_TO_E(ModeName,8); <br>   if (!ReadString("RemoteTPName",RemoteTPName,64)) <br>   { <br>      strncpy(RemoteTPName,"RECVTP",6); <br>   } <br>   PadString(RemoteTPName,64); <br>   CONV_A_TO_E(RemoteTPName,64); <br>   NumSends=2; <br>   if (ReadString("NumSends",buffer,200)) <br>   { <br>      NumSends=atoi(buffer); <br>   } <br>   ConfirmEvery=1; <br>   if (ReadString("ConfirmEvery",buffer,200)) <br>   { <br>      ConfirmEvery=atoi(buffer); <br>   } <br>   SendSize=1024; <br>   if (ReadString("SendSize",buffer,200)) <br>   { <br>      SendSize=atoi(buffer); <br>   } <br>   SendConversation=FALSE; <br>   if (ReadString("SendConversation",buffer,200)) <br>   { <br>      SendConversation = (*(strupr(buffer)) == 'Y'); <br>   } <br>#endif <br>#ifdef DOS5 <br>   DosAllocSeg(SendSize,&amp;selector,1); <br>   DataPtr = MAKEP(selector,0); <br>#else <br> #ifdef WIN32 <br>   DataPtr = malloc(SendSize); <br> #else <br>   DataPtr = (char far *)GlobalLock(GlobalAlloc(GPTR,SendSize)); <br> #endif <br>#endif <br>   ResultBuf = (NumConversations == 0) ? <br>               NULL : malloc(NumConversations * sizeof(RESULT)); <br>   ResultPtr = ResultBuf; <br>} <br> <br>/*****************************************************************************/ <br>/* CONV_A_TO_E - ASCII to EBCDIC conversion routine.                         */ <br>/*****************************************************************************/ <br>void CONV_A_TO_E(char FAR * string,int length) <br>{ <br>   memset(cnvtptr,0,sizeof(cnvt)); <br> <br>   cnvt.opcode       = SV_CONVERT; <br>   cnvt.direction    = SV_ASCII_TO_EBCDIC; <br>   cnvt.char_set     = SV_AE; <br> <br>   cnvt.len          = length; <br>   cnvt.source       = string; <br>   cnvt.target       = string; <br> <br>   ACSSVC_C((long)(char far *) (cnvtptr));      /* Call ACSSVC - go convert! */ <br>} <br> <br>/*****************************************************************************/ <br>/* CONV_E_TO_A - EBCDIC to ASCII conversion routine.                         */ <br>/*****************************************************************************/ <br>void CONV_E_TO_A(char FAR * string,int length) <br>{ <br>   memset(cnvtptr,0,sizeof(cnvt)); <br> <br>   cnvt.opcode       = SV_CONVERT; <br>   cnvt.direction    = SV_EBCDIC_TO_ASCII; <br>   cnvt.char_set     = SV_AE; <br>   cnvt.len          = length; <br>   cnvt.source       = string; <br>   cnvt.target       = string; <br> <br>   ACSSVC_C((long)(char FAR *) (cnvtptr));      /* Call ACSSVC - go convert! */ <br>} <br> <br> <br> <br>/*****************************************************************************/ <br>/* NewConversation - Reset and record timers for this conversation.          */ <br>/*****************************************************************************/ <br>void NewConversation() <br>{ <br>   RESULT NewTime; <br> <br>#ifdef SENDTP <br>   SendCount = 0; <br>   ConfirmCount =0; <br>#endif <br> <br>   if (FirstConv) <br>   { <br>      FirstConv = FALSE; <br>      ConvStarted = GetTickCount(); <br>   } <br>   else if (ResultPtr != NULL) <br>   { <br>      *ResultPtr++ = ((NewTime = GetTickCount()) - ConvStarted); <br>      ConvStarted = NewTime; <br>   } <br>   ConvCount++; <br>   OUTPUTNUMBER <br>} <br> <br>#ifdef SENDTP <br>/*****************************************************************************/ <br>/* GenerateData    - Fill in data buffer                                     */ <br>/*****************************************************************************/ <br>void GenerateData() <br>{ <br>   int i; <br>   int div; <br>   int rem; <br>   char FAR * dptr; <br> <br>   dptr = DataPtr; <br>   div = SendSize / 5; <br>   rem = SendSize % 5; <br> <br>   for (; div--;) <br>   { <br>      for (i=4; i--; *dptr++ = datach); <br>      *dptr++ = '.'; <br>   } <br>   for (; rem--; *dptr++ = datach); <br> <br>   datach = (datach=='Z' ? 'A' : datach + 1); <br>} <br> <br>/*****************************************************************************/ <br>/* OutputResults - dump the times of conversations to file                   */ <br>/*****************************************************************************/ <br>void OutputResults() <br>{ <br>  FILE *h = NULL; <br>  RESULT FAR * ptr = NULL; <br>  unsigned short i = 0; <br>  RESULT TotalTime=0; <br> <br>  h = fopen(FileName,"w"); <br>  if (h != NULL) <br>  { <br>    fprintf(h,"SENDTP Results\n--------------\n\n"); <br>    CONV_E_TO_A(LocalTPName,64); <br>    fprintf(h,"Local TP Name           = %.64s\n",LocalTPName); <br>    CONV_E_TO_A(RemoteTPName,64); <br>    fprintf(h,"Remote TP Name          = %.64s\n",RemoteTPName); <br>    fprintf(h,"Local LU Alias          = %.8s\n",LocalLUAlias); <br>    fprintf(h,"Remote LU Alias         = %.8s\n",RemoteLUAlias); <br>    CONV_E_TO_A(ModeName,8); <br>    fprintf(h,"ModeName                = %.8s\n",ModeName); <br>    fprintf(h,"Number of conversations = %d\n",NumConversations); <br>    if (!SendConversation) <br>    { <br>       fprintf(h,"Sends per conversation  = %d\n",NumSends); <br>       fprintf(h,"Sends between confirms  = %d\n",ConfirmEvery); <br>    } <br>    fprintf(h,"Bytes per send          = %d\n",SendSize); <br>    fprintf(h,"Use SEND_CONVERSATION   = %s\n",(SendConversation ? "Yes":"No")); <br>    fprintf(h,"\n"); <br> <br>    ptr = ResultBuf; <br>    while (ptr &lt; ResultPtr) <br>    { <br>TotalTime += *ptr; <br>      fprintf(h,"Conversation number %d, time = %.3f seconds\n",i++, <br>                                                (((float) *ptr++) / 1000.0 )); <br>   <br>    } <br>fprintf( h,"Total Time in Conversation = %.3f seconds\n",(((float)TotalTime)/1000.0) ); <br>    fclose(h);                                                        /*FILE*/ <br>  } <br>} <br> <br>#endif <br> <br>/*****************************************************************************/ <br>/* ReadString - Get a line of text from the config file.                     */ <br>/*****************************************************************************/ <br>int ReadString(char FAR * lpValueName,char FAR * lpData, int maxlen) <br>{ <br>   char       buffer[200]; <br>   char      *p = NULL; <br>   FILE      *h = NULL; <br>   BOOL       match = FALSE; <br>   BOOL       eof   = FALSE; <br>   int        rc = 0; <br>   int        ch = 0; <br>   int        i = 0; <br>   BOOL       gotdata = FALSE; <br>   char       separators[] = " =\t\n"; <br> <br>#if (defined(WINDOWS)||defined(WIN32))                                 /*PATH*/ <br>                                                                       /*PATH*/ <br>GetModuleFileName( hInst, buffer, sizeof(buffer) );                /*PATH*/ <br>lstrcpy( buffer+lstrlen(buffer) - 4, ".CFG" );                     /*PATH*/ <br>h = fopen( buffer, "r" );                                          /*PATH*/ <br>buffer[0] = '\0';                                                  /*PATH*/ <br>                                                                       /*PATH*/ <br>#else                                                                  /*PATH*/ <br>#ifdef SENDTP <br>   h = fopen("C:\\sendtp.cfg", "r"); <br>#else <br>   h = fopen("C:\\recvtp.cfg", "r"); <br>#endif <br>#endif                                                                 /*PATH*/ <br> <br>   lpValueName=strupr(lpValueName); <br> <br>   if (h != NULL) <br>   { <br>      while ((!match) &amp;&amp; (!eof)) <br>      { <br>         /********************************************************************/ <br>         /* Use fgetc to read a line of text from the file.                  */ <br>         /********************************************************************/ <br>         for (i=0; (i&lt;sizeof(buffer))     &amp;&amp; <br>                   ((ch=getc(h)) != EOF)  &amp;&amp; <br>                   ((char)ch != '\n'); <br>                                      i++) <br>         { <br>            buffer[i] = (char)ch; <br>         } <br>         if ((char)ch == '\n') <br>         { <br>            buffer[i++] = (char)ch; <br>         } <br>         if (ch == EOF) <br>         { <br>            eof = TRUE; <br>         } <br>         else <br>         { <br>            /*****************************************************************/ <br>            /* Compare the 1st token in the line read with the requested     */ <br>            /* param.                                                        */ <br>            /*****************************************************************/ <br>            if (!strcmpi(strupr(strtok(buffer, separators)), lpValueName)) <br>            { <br>               match = TRUE; <br>               /**************************************************************/ <br>               /* Get a pointer to the 2nd token (the value we want)         */ <br>               /**************************************************************/ <br>               p = strtok(NULL, separators); <br> <br>               /**************************************************************/ <br>               /* Copy the data IF there is some.                            */ <br>               /**************************************************************/ <br>               if (p != NULL) <br>               { <br>                  /***********************************************************/ <br>                  /* Force a NULL after the 2nn token                        */ <br>                  /***********************************************************/ <br>                  strtok(NULL, separators); <br> <br>                  /***********************************************************/ <br>                  /* Copy the data                                           */ <br>                  /***********************************************************/ <br>                  strncpy(lpData, p, maxlen); <br>                  gotdata = TRUE; <br>               } <br>               else <br>               { <br>                  gotdata = FALSE; <br>               } <br>            } <br>         } <br>      } <br> <br>      if (gotdata) <br>      { <br>         rc = 1; <br>      } <br> <br>      fclose(h); <br> <br>   } <br> <br>return(rc); <br>} <br> <br>/*****************************************************************************/ <br>/* PadString - Remove terminating NULL  and pad on the right with spaces     */ <br>/*****************************************************************************/ <br>void PadString(char FAR * string,int length) <br>{ <br>   char FAR * p; <br>   if ((p=memchr(string,'\0',length)) != NULL) <br>   { <br>      while (p &lt; string+length) <br>      { <br>         *p++=' '; <br>      } <br>   } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
