<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSEND.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5111"></a>MSEND.C</h2>
<pre><code>/* msend.c */ <br>/* (C) COPYRIGHT DATA CONNECTION LIMITED 1994 */ <br> <br>/*****************************************************************************/ <br>/* Change History                                                            */ <br>/*                                                                           */ <br>/*       21/02/94 DK  Created                                                */ <br>/*       15/03/94 DK  Thread priorities added and signalled event goes to    */ <br>/*                    back of the list (for WaitForMultipleObjects)          */ <br>/*       14/04/94 DK  OutputResults removed                                  */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* If you want internal tracing, #define SRTRC here                          */ <br>/*****************************************************************************/ <br>//#define SRTRC <br> <br>/*****************************************************************************/ <br>/*                                                                           */ <br>/* ROUTINE : SEND using event completion                                     */ <br>/*                                                                           */ <br>/* FUNCTION: This file contains the routines for a multi-threaded routine    */ <br>/*           which uses asynchronous APPC calls with event completion        */ <br>/*           to send data.                                                   */ <br>/*                                                                           */ <br>/*           It runs with either the single-threaded or the multi-threaded   */ <br>/*           version of receive (mrcv or recvtp).                            */ <br>/*                                                                           */ <br>/* INPUTS  : MSEND.CFG (file) (documented below)                             */ <br>/*                                                                           */ <br>/* OUTPUTS : MSEND.OUT                                                       */ <br>/*           MSEND.TRC                                                       */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* Operation:                                                                */ <br>/*                                                                           */ <br>/* This is a Windows NT application which runs in a minimized window.        */ <br>/*                                                                           */ <br>/* Thread structure:                                                         */ <br>/*                                                                           */ <br>/*   A variable number of send threads                                       */ <br>/*     Each send thread processes a variable number of conversations and     */ <br>/*     issues a WaitForMultipleObjects to wait for completion of any of its  */ <br>/*     send operations.  Each conversation starts with TP_STARTED, followed  */ <br>/*     by MC_ALLOCATE and MC_CONFIRM.  Then it issues MC_SEND_DATA verbs     */ <br>/*     to send data.  MC_CONFIRMs are issued at configurable intervals.      */ <br>/*     If a confirm fails, an attempt is made to restart the conversation    */ <br>/*     after five seconds.                                                   */ <br>/*                                                                           */ <br>/*   Note:  this program is compatible with the single-threaded version of   */ <br>/*   receive, which can be run for example on WIN16 clients.                 */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* Configuration file:                                                       */ <br>/*                                                                           */ <br>/* The configuration file is called MSEND.CFG and must reside in the         */ <br>/* same directory as the program.  It contains the following, in any order.  */ <br>/* If any parameter is omitted, the default is assumed.                      */ <br>/*                                                                           */ <br>/* TraceFile = &lt;Name of file for tracing, default MSEND.TRC&gt;                 */ <br>/* RemoteTPName = &lt;Name used for allocate, default MRCVTP&gt;                   */ <br>/* LocalLUAlias = &lt;Alias for local LU, default SENDLU&gt;                       */ <br>/* RemoteLUAlias = &lt;Alias for remote LU, default RECVLU&gt;                     */ <br>/* ModeName = &lt;Mode Name, default #INTER&gt;                                    */ <br>/*                                                                           */ <br>/* NumSendConvs = &lt;Number of conversations to be sent, default = 4&gt;          */ <br>/* NumSends = &lt;number of SEND_DATA verbs per conversation, default = 8&gt;      */ <br>/* ConfirmEvery = &lt;number of SEND_DATA verbs between CONFIRMs, default = 2&gt;  */ <br>/* SendSize = &lt;number of bytes per SEND_DATA, default = 256&gt;                 */ <br>/*                                                                           */ <br>/* The name used for TP_STARTED is fixed at MSEND.                           */ <br>/*                                                                           */ <br>/* If NumSends is zero, the TP will never DEALLOCATE a conversation.         */ <br>/* If ConfirmEvery is zero, the TP will not issue CONFIRM verbs except       */ <br>/*    after the MC_ALLOCATE.                                                 */ <br>/* If ConfirmEvery is non-zero, the TP issues a CONFIRM verbs ConfirmEvery   */ <br>/*    sends.                                                                 */ <br>/*                                                                           */ <br>/* Configuration constants (in msend.h)                                      */ <br>/*                                                                           */ <br>/* #define MAX_SEND_PER_THREAD  Max conversations per send thread      (64)  */ <br>/*                                                                           */ <br>/* MAX_SEND_PER_THREAD is constrained by the limit of 64 objects that can be */ <br>/* waited for in WaitForMultipleObjects.                                     */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>HINSTANCE hInst; <br>BOOL verbs_started = FALSE; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winappc.h&gt; <br>#include &lt;wincsv.h&gt; <br>#include "msend.h" <br> <br>/*****************************************************************************/ <br>/* Trace macros                                                              */ <br>/*****************************************************************************/ <br>#ifdef SRTRC <br>#define SRTROPEN() t = fopen(TraceFile,"w"); <br>#define SRTRFLUSH() fflush(t); <br>#define SRTRCLOSE() fclose(t); <br>#define SRTRACE fprintf <br>#else <br>#define SRTROPEN() <br>#define SRTRFLUSH() <br>#define SRTRCLOSE() <br>#define SRTRACE 1 ? (void) 0 : fprintf <br>#endif <br> <br>/*****************************************************************************/ <br>/* WinMain - reads initialization info and controls message loop             */ <br>/*           NT version                                                      */ <br>/*****************************************************************************/ <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                   LPSTR lpCmdLine, int nCmdShow) <br>{ <br> <br>  MSG msg; <br>  DWORD Tid; <br>  int i; <br>  DWORD NumConvs; <br>  HANDLE ThreadHandle; <br> <br>  hInst = hInstance; <br> <br>  InitializeMain(); <br> <br>  if (!InitializeWinMain(hInstance)) <br>  { <br>    return (FALSE); <br>  } <br> <br>  ReadConfig(); <br>  SRTROPEN() <br> <br>  /***************************************************************************/ <br>  /* Create enough send threads to process conversations                     */ <br>  /***************************************************************************/ <br>  i = NumSendConvs; <br>  while (i &gt; 0) <br>  { <br>    NumConvs = (i &gt; 64) ? 64 : i; <br>    ThreadHandle = CreateThread(NULL, <br>                                16000, <br>                                (LPTHREAD_START_ROUTINE)SendThread, <br>                                (void *)NumConvs, <br>                                0, <br>                                &amp;Tid); <br>    if (ThreadHandle == NULL) <br>    { <br>      GetLastError(); <br>      DebugBreak(); <br>    } <br>    SetThreadPriority(ThreadHandle,THREAD_PRIORITY_BELOW_NORMAL); <br>    SRTRACE(t,"Created send thread with %d conversations and priority %d\n", <br>            NumConvs,GetThreadPriority(ThreadHandle)); <br>    CloseHandle(ThreadHandle); <br>    i -= NumConvs; <br>  } <br> <br>  /***************************************************************************/ <br>  /* Windows processing loop                                                 */ <br>  /***************************************************************************/ <br>  while(GetMessage(&amp;msg,NULL,0,0)) <br>  { <br>    TranslateMessage(&amp;msg); <br>    DispatchMessage(&amp;msg); <br>  } <br> <br>  WinAPPCCleanup(); <br>  SRTRFLUSH() <br>  SRTRCLOSE() <br>  DeleteCriticalSection(&amp;runsem); <br>  return msg.wParam;         /* save exit parameter for return               */ <br> <br>} <br> <br>/*****************************************************************************/ <br>/* SendThread - thread which processes multiple conversations                */ <br>/*****************************************************************************/ <br>DWORD WINAPI SendThread(DWORD NumConvs) <br>{ <br>  /***************************************************************************/ <br>  /* Separate variables for each instance of this thread                     */ <br>  /***************************************************************************/ <br>  CONVCB * convptr; <br>  struct appc_hdr * vcbptr; <br>  unsigned short ThreadNo; <br>  unsigned short SendThreadNo; <br>  DWORD ObjIndex; <br>  DWORD i; <br>  DWORD j; <br>  DWORD rc; <br>  CONVCB * ConvptrArray [MAX_SEND_PER_THREAD+1]; <br>  HANDLE EventArray [MAX_SEND_PER_THREAD+1]; <br>  SYSTEMTIME st; <br> <br>  for (i = 0; i &lt; MAX_SEND_PER_THREAD+1; i++) <br>  { <br>    ConvptrArray[i] = NULL; <br>    EventArray[i] = NULL; <br>  } <br> <br>  /***************************************************************************/ <br>  /* Count threads within critical section                                   */ <br>  /***************************************************************************/ <br>  EnterCriticalSection(&amp;runsem); <br>  ThreadCount++; <br>  SendThreads++; <br>  ThreadNo = ThreadCount; <br>  SendThreadNo = SendThreads; <br>  OUTPUTNUMBER <br>  LeaveCriticalSection(&amp;runsem); <br> <br>  for (i = 0; i &lt; NumConvs; i++) <br>  { <br>    /*************************************************************************/ <br>    /* Make a conversation control block                                     */ <br>    /*************************************************************************/ <br>    convptr = malloc (sizeof(CONVCB)); <br>    convptr-&gt;thread       = SendThreadNo; <br>    convptr-&gt;conv         = (unsigned short)i; <br>    convptr-&gt;async_corr   = 0; <br>    convptr-&gt;TPid[0]      = '\0'; <br>    convptr-&gt;Convid       = 0; <br>    convptr-&gt;SendCount    = 0; <br>    convptr-&gt;ConfirmCount = 0; <br>    convptr-&gt;TPEnded      = FALSE; <br>    convptr-&gt;Deallocated  = FALSE; <br>    convptr-&gt;Counted      = FALSE; <br>    convptr-&gt;SendSize     = SendSize; <br>    convptr-&gt;DataPtr      = malloc(convptr-&gt;SendSize); <br>    vcbptr = (struct appc_hdr *) &amp;convptr-&gt;vcb; <br>    memset(vcbptr,0,sizeof(VCB)); <br>    strcpy (convptr-&gt;type,"send"); <br>//  SRTRACE(t,"Thread %d:%d (send) has convptr %p\n", <br>//          SendThreadNo,i,convptr); <br> <br>    /*************************************************************************/ <br>    /* Create an event                                                       */ <br>    /*************************************************************************/ <br>    convptr-&gt;hEvent = CreateEvent(NULL,FALSE,FALSE,NULL); <br>    SRTRACE(t,"Thread %d:%d (send) has event handle %p\n", <br>            SendThreadNo,i,convptr-&gt;hEvent); <br> <br>    /*************************************************************************/ <br>    /* Add to arrays                                                         */ <br>    /*************************************************************************/ <br>    ConvptrArray[i] = convptr; <br>    EventArray[i]   = convptr-&gt;hEvent; <br> <br>    /*************************************************************************/ <br>    /* Build a tp_started                                                    */ <br>    /*************************************************************************/ <br>    Build_TP_STARTED(convptr); <br>    SRTRFLUSH() <br> <br>    /*************************************************************************/ <br>    /*PERF* Don't re-generate data each time we issue a send!                */ <br>    /*************************************************************************/ <br>    GenerateData(convptr); <br> <br>    /*************************************************************************/ <br>    /* Issue tp_started                                                      */ <br>    /*************************************************************************/ <br>    convptr-&gt;async_corr = WinAsyncAPPCEx(convptr-&gt;hEvent, <br>                                         (long)(char *)(vcbptr)); <br>//  SRTRACE(t,"Thread %d:%d (send) tp_started issued corr %p\n", <br>//          SendThreadNo,i,convptr-&gt;async_corr); <br>    SRTRFLUSH() <br>    if (convptr-&gt;async_corr == 0) <br>    { <br>      SRTRACE(t,"Thread %d:%d (send) WinAsync call %x failed corr %p\n", <br>              SendThreadNo,i,vcbptr-&gt;opcode,convptr-&gt;async_corr); <br>      convptr-&gt;TPEnded = TRUE; <br>    } <br>  } <br> <br>  /***************************************************************************/ <br>  /* Loop round until finished                                               */ <br>  /***************************************************************************/ <br>  while (TRUE) <br>  { <br>    /*************************************************************************/ <br>    /* Wait for event completion                                             */ <br>    /*************************************************************************/ <br>//  SRTRACE(t,"Thread %d (send) waiting for %d events to complete\n", <br>//          SendThreadNo,NumConvs); <br>    ObjIndex = WaitForMultipleObjects(NumConvs,EventArray,FALSE,INFINITE); <br>    if (ObjIndex == WAIT_FAILED) <br>    { <br>      rc = GetLastError(); <br>      SRTRACE(t,"Thread %d (send) wait for %d events failed with rc %d\n", <br>              SendThreadNo,NumConvs,rc); <br>      for (j = 0; j &lt; NumConvs; j++) <br>      { <br>        SRTRACE(t,"Thread %d (send) event %d has handle %p\n", <br>                SendThreadNo,j,EventArray[j]); <br>      } <br>      break; <br>    } <br> <br>    /*************************************************************************/ <br>    /* Get index to conversation array                                       */ <br>    /*************************************************************************/ <br>    i = ObjIndex - WAIT_OBJECT_0; <br>//  SRTRACE(t,"Thread %d:%d (send) event %d has completed\n", <br>//          SendThreadNo,ConvptrArray[i]-&gt;conv,i); <br> <br>    /*************************************************************************/ <br>    /* Issue the next verb                                                   */ <br>    /*************************************************************************/ <br>//  SRTRACE(t,"Thread %d:%d (send) issuing next send verb\n", <br>//          SendThreadNo,ConvptrArray[i]-&gt;conv); <br>    ConvptrArray[i]-&gt;TPEnded = IssueSendVerb(ConvptrArray[i]); <br> <br>    if (ConvptrArray[i]-&gt;TPEnded) <br>    { <br>      /***********************************************************************/ <br>      /* end of conversation                                                 */ <br>      /***********************************************************************/ <br>      NumConvs--; <br>      SRTRACE(t,"Thread %d:%d (send) conversation completed: NumConvs %d\n", <br>              SendThreadNo,ConvptrArray[i]-&gt;conv,NumConvs); <br>      EnterCriticalSection(&amp;runsem); <br>      SendConvs++; <br>      OUTPUTNUMBER <br>      SRTRACE(t,"Thread %d:%d (send) NumConvs %d SendConvs %d\n", <br>              SendThreadNo,ConvptrArray[i]-&gt;conv,NumConvs,SendConvs); <br>      LeaveCriticalSection(&amp;runsem); <br> <br>      /***********************************************************************/ <br>      /* free resources                                                      */ <br>      /***********************************************************************/ <br>      CloseHandle(ConvptrArray[i]-&gt;hEvent); <br>      free (ConvptrArray[i]-&gt;DataPtr); <br>      free (ConvptrArray[i]); <br>      ConvptrArray[i] = NULL; <br>      EventArray[i]   = NULL; <br> <br>      /***********************************************************************/ <br>      /* if all conversations have completed, end loop                       */ <br>      /***********************************************************************/ <br>      if (NumConvs == 0) <br>      { <br>        break; <br>      } <br>      /***********************************************************************/ <br>      /* the event array cannot have holes in it, so shuffle up the          */ <br>      /* pointers and events                                                 */ <br>      /* note that this means convptr-&gt;conv no longer matches i              */ <br>      /* which is why tracing uses ConvptrArray[i]-&gt;conv                     */ <br>      /***********************************************************************/ <br>      for (j = i; j &lt; MAX_SEND_PER_THREAD - 1; j++) <br>      { <br>        ConvptrArray [j] = ConvptrArray [j+1]; <br>        EventArray [j] = EventArray [j+1]; <br>      } <br>      ConvptrArray [MAX_SEND_PER_THREAD-1] = NULL; <br>      EventArray [MAX_SEND_PER_THREAD-1] = NULL; <br>    } <br>    else <br>    { <br>      /***********************************************************************/ <br>      /* to stop one conversation getting an unfair share of the time,       */ <br>      /* move this conversation to the end and shuffle up the pointers.      */ <br>      /* note that this means convptr-&gt;conv no longer matches i              */ <br>      /* which is why tracing uses ConvptrArray[i]-&gt;conv                     */ <br>      /***********************************************************************/ <br>      ConvptrArray [NumConvs] = ConvptrArray [i]; <br>      EventArray [NumConvs] = EventArray [i]; <br>      for (j = i; j &lt; NumConvs; j++) <br>      { <br>        ConvptrArray [j] = ConvptrArray [j+1]; <br>        EventArray [j] = EventArray [j+1]; <br>      } <br>      ConvptrArray [NumConvs] = NULL; <br>      EventArray [NumConvs] = NULL; <br>    } <br>  } <br> <br>  /***************************************************************************/ <br>  /* Count threads within critical section                                   */ <br>  /***************************************************************************/ <br>  EnterCriticalSection(&amp;runsem); <br>  ThreadCount--; <br>  SendThreads--; <br>  GetLocalTime(&amp;st); <br>  SRTRACE(t,"Thread %d (send) Exit at %d:%d:%d: ThreadCount %d\n", <br>          SendThreadNo,st.wHour,st.wMinute,st.wSecond,ThreadCount); <br>  OUTPUTNUMBER <br>  if (ThreadCount == 0) <br>  { <br>    PostMessage(hWndMain, WM_CLOSE, 0, 0); <br>  } <br>  LeaveCriticalSection(&amp;runsem); <br>  return(0); <br>} <br> <br>/*****************************************************************************/ <br>/* InitializeWinMain - does the windows bits of initialisation               */ <br>/*****************************************************************************/ <br>BOOL InitializeWinMain(HINSTANCE hInstance) <br>{ <br>  WAPPCDATA APPCData; <br>  WNDCLASS class; <br>  #define WinAPPCVERSION  0x0001 <br> <br>  /***************************************************************************/ <br>  /* Startup WinAPPC                                                         */ <br>  /***************************************************************************/ <br>  if (WinAPPCStartup(WinAPPCVERSION,&amp;APPCData)) <br>  { <br>    return (FALSE); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Register Window Class for our icon                                      */ <br>  /***************************************************************************/ <br> <br>  class.style = 0; <br>  class.lpfnWndProc   = (WNDPROC)TPWndProc; <br>  class.cbClsExtra    = (DWORD)0; <br>  class.cbWndExtra    = (DWORD)0; <br>  class.hInstance     = hInstance; <br>  class.hIcon         = LoadIcon(hInstance,"MainIcon"); <br>  class.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>  class.hbrBackground = GetStockObject(WHITE_BRUSH); <br>  class.lpszMenuName  = (LPSTR) NULL; <br>  class.lpszClassName = (LPSTR) "MSEND\0"; <br> <br>  if (!RegisterClass(&amp;class)) <br>  { <br>    return (FALSE); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Create the window                                                       */ <br>  /***************************************************************************/ <br>  sprintf(title,"APPC Send TP\0"); <br> <br>  if ((hWndMain = CreateWindow("MSEND\0",         /* window class            */ <br>      title,                                      /* window name             */ <br>      WS_MINIMIZE|WS_OVERLAPPEDWINDOW,            /* window style            */ <br>      0,                                          /* x position              */ <br>      0,                                          /* y position              */ <br>      10,                                         /* width                   */ <br>      10,                                         /* height                  */ <br>      NULL,                                       /* parent handle           */ <br>      NULL,                                       /* menu or child ID        */ <br>      hInstance,                                  /* instance                */ <br>      NULL))                                      /* additional info         */ <br>      == NULL) <br>  { <br>    return (FALSE); <br>  } <br> <br>  ShowWindow(hWndMain, SW_MINIMIZE); <br> <br>  return(TRUE); <br> <br>} <br> <br>/*****************************************************************************/ <br>/* Window proc for the iconised window                                       */ <br>/*****************************************************************************/ <br>LONG PASCAL TPWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br>{ <br>  switch (message) <br>  { <br>    case WM_CREATE: <br>      break; <br> <br>    case WM_QUERYOPEN: <br>      /***********************************************************************/ <br>      /* Prevent the window being opened                                     */ <br>      /***********************************************************************/ <br>      break; <br> <br>    case WM_CLOSE: <br>      return DefWindowProc(hWnd, message, wParam, lParam); <br>      break; <br> <br>    case WM_DESTROY: <br>      PostQuitMessage(0); <br>      break; <br> <br>    default: <br>      return DefWindowProc(hWnd, message, wParam, lParam); <br>      break; <br>  } <br>  return 0l; <br>} <br> <br>/*****************************************************************************/ <br>/* InitializeMain - blanks out variables not set in ReadConfig               */ <br>/*****************************************************************************/ <br>void InitializeMain() <br>{ <br>  SendThreads = 0; <br>  ThreadCount = 0; <br>  cnvtptr     = (char *)&amp;cnvt; <br> <br>  datach      = 'A'; <br> <br>  InitializeCriticalSection(&amp;runsem); <br>} <br> <br>/*****************************************************************************/ <br>/* IssueSendVerb - looks at the verb which has just completed and does the   */ <br>/*                 next one                                                  */ <br>/*****************************************************************************/ <br>BOOL IssueSendVerb(CONVCB * convptr) <br>{ <br>  BOOL TPEnded; <br>  struct appc_hdr * vcbptr; <br> <br>//SRTRACE(t,"Thread %d (send) IssueSendVerb\n",convptr-&gt;thread); <br>  TPEnded = FALSE; <br>  vcbptr = (struct appc_hdr *) &amp;convptr-&gt;vcb; <br>  if (vcbptr-&gt;opcode != 0x0000) <br>  { <br>    TPEnded = ProcessReturns(convptr); <br>  } <br>  if (!TPEnded) <br>  { <br>    switch (vcbptr-&gt;opcode) <br>    { <br>      case 0x0000: <br>        Build_TP_STARTED(convptr); <br> <br>        /*********************************************************************/ <br>        /*PERF* Don't re-generate data each time we issue a send!            */ <br>        /*********************************************************************/ <br>        GenerateData(convptr); <br>        break; <br> <br>      case AP_TP_STARTED: <br>        Build_MC_ALLOCATE(convptr); <br>        break; <br> <br>      case AP_M_ALLOCATE: <br>        if (vcbptr-&gt;primary_rc == AP_OK) <br>        { <br>          /*******************************************************************/ <br>          /* confirm before the first send to find out if anyone there       */ <br>          /*******************************************************************/ <br>          Build_MC_CONFIRM(convptr); <br>        } <br>        else <br>        { <br>          /*******************************************************************/ <br>          /* allocate timed out or connection is for incoming call           */ <br>          /* if there are no conversations active, try again in 5 seconds    */ <br>          /* otherwise retry immediately - someone must be out there         */ <br>          /*******************************************************************/ <br>          if (SimSendConvs == 0) <br>          { <br>            SRTRACE(t,"Thread %d:%d (send) wait 5 seconds before retry\n", <br>                    convptr-&gt;thread,convptr-&gt;conv); <br>            Sleep (5000); <br>          } <br>          SRTRACE(t,"Thread %d:%d (send) retrying\n", <br>                  convptr-&gt;thread,convptr-&gt;conv); <br>          Build_MC_ALLOCATE(convptr); <br>        } <br>        break; <br> <br>      case AP_M_SEND_DATA: <br>        convptr-&gt;SendCount++; <br>        convptr-&gt;ConfirmCount++; <br>        if ((NumSends != 0) &amp;&amp; (convptr-&gt;SendCount == NumSends)) <br>        { <br>          /*******************************************************************/ <br>          /* all sends done - deallocate                                     */ <br>          /*******************************************************************/ <br>          Build_MC_DEALLOCATE(convptr); <br>        } <br>        else if ((ConfirmEvery != 0) &amp;&amp; <br>                 (convptr-&gt;ConfirmCount == ConfirmEvery)) <br>        { <br>          /*******************************************************************/ <br>          /* time to confirm                                                 */ <br>          /*******************************************************************/ <br>          Build_MC_CONFIRM(convptr); <br>        } <br>        else <br>        { <br>          /*******************************************************************/ <br>          /* just send more data                                             */ <br>          /*******************************************************************/ <br>          Build_MC_SEND_DATA(convptr); <br>        } <br>        break; <br> <br>      case AP_M_CONFIRM: <br>        if (vcbptr-&gt;primary_rc == AP_OK) <br>        { <br>          if (convptr-&gt;SendCount == 0) <br>          { <br>            convptr-&gt;Counted = TRUE; <br>            EnterCriticalSection(&amp;runsem); <br>            SimSendConvs++; <br>            OUTPUTNUMBER <br>            SRTRACE(t,"Thread %d (send) SimSendConvs %d\n", <br>                    convptr-&gt;thread,SimSendConvs); <br>            LeaveCriticalSection(&amp;runsem); <br>          } <br>          convptr-&gt;ConfirmCount=0; <br>          Build_MC_SEND_DATA(convptr); <br>        } <br>        else <br>        { <br>          /*******************************************************************/ <br>          /* if there are no conversations active, try again in 5 seconds    */ <br>          /* otherwise retry immediately - someone must be out there         */ <br>          /*******************************************************************/ <br>          if (SimSendConvs == 0) <br>          { <br>            SRTRACE(t,"Thread %d:%d (send) wait 5 seconds before retry\n", <br>                    convptr-&gt;thread,convptr-&gt;conv); <br>            Sleep (5000); <br>          } <br>          SRTRACE(t,"Thread %d:%d (send) retrying\n", <br>                  convptr-&gt;thread,convptr-&gt;conv); <br>          Build_MC_ALLOCATE(convptr); <br>        } <br>        break; <br> <br>      case AP_M_DEALLOCATE: <br>        Build_TP_ENDED(convptr); <br>        break; <br> <br>      case AP_TP_ENDED: <br>        /*********************************************************************/ <br>        /* quit                                                              */ <br>        /*********************************************************************/ <br>        TPEnded = TRUE; <br>        break; <br> <br>      default: <br>        /*********************************************************************/ <br>        /* What is this verb then ??                                         */ <br>        /*********************************************************************/ <br>        TPEnded = TRUE; <br>        DebugBreak(); <br>        break; <br> <br>    } /* Op-code switch */ <br> <br>  } <br> <br>  /***************************************************************************/ <br>  /* If send conversation has finished and was counted, count it down        */ <br>  /***************************************************************************/ <br>  if (TPEnded &amp;&amp; convptr-&gt;Counted) <br>  { <br>    EnterCriticalSection(&amp;runsem); <br>    SimSendConvs--; <br>    OUTPUTNUMBER <br>    SRTRACE(t,"Thread %d (send) SimSendConvs %d\n", <br>            convptr-&gt;thread,SimSendConvs); <br>    LeaveCriticalSection(&amp;runsem); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Now go ahead and issue the verb, if we're not finished                  */ <br>  /***************************************************************************/ <br>  if (!TPEnded) <br>  { <br>    convptr-&gt;async_corr = WinAsyncAPPCEx(convptr-&gt;hEvent, </code></pre>
<p>
</p>
<pre><code>(long)(char *)(vcbptr)); <br>    if (convptr-&gt;async_corr == 0) <br>      { <br>        SRTRACE(t,"Thread %d (send) WinAsync call %x failed corr %p\n", <br>                convptr-&gt;thread,vcbptr-&gt;opcode, <br>                convptr-&gt;async_corr); <br>        convptr-&gt;TPEnded = TRUE; <br>      } <br>  } <br> <br>  SRTRFLUSH() <br>  return(TPEnded); <br> <br>} /* Issue send verb */ <br> <br>/*****************************************************************************/ <br>/* Build routines to build all required verbs                                */ <br>/*****************************************************************************/ <br> <br>void Build_TP_STARTED(CONVCB * convptr) <br>{ <br>  TP_STARTED * vcbptr; <br>  SRTRACE(t,"Thread %d:%d (%s) Build_TP_Started\n", <br>          convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (TP_STARTED *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_TP_STARTED; <br>  memcpy(&amp;(vcbptr-&gt;lu_alias), LocalLUAlias, 8); <br>  memcpy(&amp;(vcbptr-&gt;tp_name), TPName, 64); <br>} <br> <br>void Build_TP_ENDED(CONVCB * convptr) <br>{ <br>  TP_ENDED * vcbptr; <br>  SRTRACE(t,"Thread %d:%d (%s) Build_TP_Ended\n", <br>          convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (TP_ENDED *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_TP_ENDED; <br>  memcpy(&amp;(vcbptr-&gt;tp_id), convptr-&gt;TPid, 8); <br>  vcbptr-&gt;type = AP_SOFT; <br>} <br> <br>void Build_MC_ALLOCATE(CONVCB * convptr) <br>{ <br>  MC_ALLOCATE * vcbptr; <br>  SRTRACE(t,"Thread %d:%d (%s) Build_MC_Allocate\n", <br>          convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (MC_ALLOCATE *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_M_ALLOCATE; <br>  vcbptr-&gt;opext = AP_MAPPED_CONVERSATION; <br>  memcpy(vcbptr-&gt;tp_id,convptr-&gt;TPid, 8); <br>  vcbptr-&gt;sync_level = AP_CONFIRM_SYNC_LEVEL; <br>  vcbptr-&gt;rtn_ctl = AP_WHEN_SESSION_ALLOCATED; <br>  memcpy(vcbptr-&gt;plu_alias, RemoteLUAlias, 8); <br>  memcpy(vcbptr-&gt;mode_name, ModeName, 8); <br>  memcpy(vcbptr-&gt;tp_name, RemoteTPName, 64); <br>  vcbptr-&gt;security = AP_NONE; <br>} <br> <br>void Build_MC_CONFIRM(CONVCB * convptr) <br>{ <br>  MC_CONFIRM * vcbptr; <br>//SRTRACE(t,"Thread %d:%d (%s) Build_MC_Confirm\n", <br>//        convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (MC_CONFIRM *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_M_CONFIRM; <br>  vcbptr-&gt;opext = AP_MAPPED_CONVERSATION; <br>  memcpy(vcbptr-&gt;tp_id,convptr-&gt;TPid, 8); <br>  vcbptr-&gt;conv_id = convptr-&gt;Convid; <br>} <br> <br>void Build_MC_DEALLOCATE(CONVCB * convptr) <br>{ <br>  MC_DEALLOCATE * vcbptr; <br>  SRTRACE(t,"Thread %d:%d (%s) Build_MC_Deallocate\n", <br>          convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (MC_DEALLOCATE *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_M_DEALLOCATE; <br>  vcbptr-&gt;opext = AP_MAPPED_CONVERSATION; <br>  memcpy(&amp;(vcbptr-&gt;tp_id),convptr-&gt;TPid, 8); <br>  vcbptr-&gt;conv_id = convptr-&gt;Convid; <br>  if (ConfirmEvery == 0) <br>  { <br>     vcbptr-&gt;dealloc_type = AP_FLUSH; <br>  } <br>  else <br>  { <br>     vcbptr-&gt;dealloc_type = AP_SYNC_LEVEL; <br>  } <br>} <br> <br>void Build_MC_SEND_DATA(CONVCB * convptr) <br>{ <br>  MC_SEND_DATA * vcbptr; <br>//SRTRACE(t,"Thread %d:%d (%s) Build_MC_Send_Data\n", <br>//        convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (MC_SEND_DATA *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  //  PERF - GenerateData(); <br> <br>  vcbptr-&gt;opcode = AP_M_SEND_DATA; <br>  vcbptr-&gt;opext = AP_MAPPED_CONVERSATION; <br>  memcpy(&amp;(vcbptr-&gt;tp_id),convptr-&gt;TPid, 8); <br>  vcbptr-&gt;conv_id = convptr-&gt;Convid; <br>  vcbptr-&gt;dlen = convptr-&gt;SendSize; <br>  vcbptr-&gt;dptr = convptr-&gt;DataPtr; <br>  vcbptr-&gt;type = AP_NONE; <br>} <br> <br>/*****************************************************************************/ <br>/* ProcessReturns - Checks return codes from the last verb to complete and   */ <br>/*                  saves conversation id and tp id in the conversation cb   */ <br>/*****************************************************************************/ <br>BOOL ProcessReturns(CONVCB * convptr) <br>{ <br>  BOOL TPEnded = FALSE; <br>  struct appc_hdr * vcbptr; <br>  SYSTEMTIME st; <br> <br>//SRTRACE(t,"Thread %d:%d (%s) ProcessReturns\n", <br>//        convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (struct appc_hdr *) &amp;(convptr-&gt;vcb); <br> <br>  GetLocalTime(&amp;st); <br>  if (vcbptr-&gt;primary_rc != AP_OK) <br>  { <br>    SRTRACE(t,"Thread %d:%d (%s) error: %s prc %4.4x src %8.8x at %d:%d:%d\n", <br>            convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>            VerbName[vcbptr-&gt;opcode], <br>            APPC_FLIPI(vcbptr-&gt;primary_rc),APPC_FLIPL(vcbptr-&gt;secondary_rc), <br>            st.wHour,st.wMinute,st.wSecond); <br>    if ((vcbptr-&gt;opcode == AP_M_CONFIRM) &amp;&amp; <br>             (vcbptr-&gt;primary_rc == AP_ALLOCATION_ERROR)) <br>    { <br>      SRTRACE(t,"Thread %d:%d (%s) MC_CONFIRM completed with ALLOCATION_ERROR\n", <br>              convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>    } <br>    else <br>    { <br>      TPEnded = TRUE; <br>      SRTRACE(t,"Thread %d:%d (%s) unexpected error on %s - set TPEnded\n", <br>              convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>              VerbName[vcbptr-&gt;opcode]); <br>    } <br>  } <br>  else <br>  { <br>    switch (vcbptr-&gt;opcode) <br>    { <br>      case AP_TP_STARTED: <br>        SRTRACE(t,"Thread %d:%d (%s) TP_Started completed at %d:%d:%d\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>                st.wHour,st.wMinute,st.wSecond); <br>        memcpy(convptr-&gt;TPid,&amp;(P_TPS(vcbptr)-&gt;tp_id),8); <br>        break; <br> <br>      case AP_TP_ENDED: <br>        SRTRACE(t,"Thread %d:%d (%s) TP_Ended completed at %d:%d:%d\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>                st.wHour,st.wMinute,st.wSecond); <br>        break; <br> <br>      case AP_M_ALLOCATE: <br>        SRTRACE(t,"Thread %d:%d (%s) MC_Allocate completed at %d:%d:%d\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>                st.wHour,st.wMinute,st.wSecond); <br>        convptr-&gt;Convid = P_M_ALC(vcbptr)-&gt;conv_id; <br>        break; <br> <br>      case AP_M_SEND_DATA: <br>//      SRTRACE(t,"Thread %d:%d (%s) MC_Send_Data completed at %d:%d:%d\n", <br>//              convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>//              st.wHour,st.wMinute,st.wSecond); <br>        break; <br> <br>      case AP_M_DEALLOCATE: <br>SRTRACE(t,"Thread %d:%d (%s) MC_Deallocate completed at %d:%d:%d: send count %d\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>                st.wHour,st.wMinute,st.wSecond, <br>                convptr-&gt;SendCount); <br>        convptr-&gt;Convid = 0; <br>        break; <br> <br>      case AP_M_CONFIRM: <br>SRTRACE(t,"Thread %d:%d (%s) MC_Confirm completed at %d:%d:%d: send count %d\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>                st.wHour,st.wMinute,st.wSecond, <br>                convptr-&gt;SendCount); <br>        break; <br> <br>      default: <br>        SRTRACE(t,"Thread %d:%d (%s) UNKNOWN opcode - set TPEnded\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>        TPEnded = TRUE; <br>        DebugBreak(); <br>        break; <br>    } <br>  } <br>  SRTRFLUSH() <br>  return(TPEnded); <br>} <br> <br>/*****************************************************************************/ <br>/* ReadConfig - Reads config info from MSEND.CFG and allocates buffer for    */ <br>/*              sending                                                      */ <br>/*****************************************************************************/ <br>void ReadConfig() <br>{ <br>  char buffer[200]; <br> <br>  if (!ReadString("TraceFile",TraceFile,60)) <br>  { <br>    strcpy(TraceFile,"MSEND.TRC"); <br>  } <br> <br>  strcpy(TPName,"MSEND"); <br>  PadString(TPName,64); <br>  CONV_A_TO_E(TPName,64); <br> <br>  if (!ReadString("RemoteTPName",RemoteTPName,64)) <br>  { <br>    strcpy(RemoteTPName,"MRCVTP"); <br>  } <br>  PadString(RemoteTPName,64); <br>  CONV_A_TO_E(RemoteTPName,64); <br> <br>  if (!ReadString("LocalLUAlias",LocalLUAlias,8)) <br>  { <br>    strcpy(LocalLUAlias,"SENDLU"); <br>  } <br>  PadString(LocalLUAlias,8); <br> <br>  if (!ReadString("RemoteLUAlias",RemoteLUAlias,8)) <br>  { <br>    strcpy(RemoteLUAlias,"RECVLU"); <br>  } <br>  PadString(RemoteLUAlias,8); <br> <br>  if (!ReadString("ModeName",ModeName,8)) <br>  { <br>    strcpy(ModeName,"#INTER"); <br>  } <br>  PadString(ModeName,8); <br>  CONV_A_TO_E(ModeName,8); <br> <br>  NumSends=8; <br>  if (ReadString("NumSends",buffer,200)) <br>  { <br>    NumSends=atoi(buffer); <br>  } <br> <br>  ConfirmEvery=2; <br>  if (ReadString("ConfirmEvery",buffer,200)) <br>  { <br>    ConfirmEvery=atoi(buffer); <br>  } <br> <br>  SendSize=256; <br>  if (ReadString("SendSize",buffer,200)) <br>  { <br>    SendSize=atoi(buffer); <br>  } <br> <br>  NumSendConvs = 4; <br>  if (ReadString("NumSendConvs",buffer,200)) <br>  { <br>    NumSendConvs=atoi(buffer); <br>  } <br> <br>} <br> <br>/*****************************************************************************/ <br>/* CONV_A_TO_E - ASCII to EBCDIC conversion routine                          */ <br>/*****************************************************************************/ <br>void CONV_A_TO_E(char * string,int length) <br>{ <br>  memset(cnvtptr,0,sizeof(cnvt)); <br> <br>  cnvt.opcode       = SV_CONVERT; <br>  cnvt.direction    = SV_ASCII_TO_EBCDIC; <br>  cnvt.char_set     = SV_AE; <br> <br>  cnvt.len          = length; <br>  cnvt.source       = string; <br>  cnvt.target       = string; <br> <br>  ACSSVC_C((long)(char *) (cnvtptr)); <br>} <br> <br>/*****************************************************************************/ <br>/* CONV_E_TO_A - EBCDIC to ASCII conversion routine                          */ <br>/*****************************************************************************/ <br>void CONV_E_TO_A(char * string,int length) <br>{ <br>  memset(cnvtptr,0,sizeof(cnvt)); <br> <br>  cnvt.opcode       = SV_CONVERT; <br>  cnvt.direction    = SV_EBCDIC_TO_ASCII; <br>  cnvt.char_set     = SV_AE; <br>  cnvt.len          = length; <br>  cnvt.source       = string; <br>  cnvt.target       = string; <br> <br>  ACSSVC_C((long)(char *) (cnvtptr)); <br>} <br> <br>/*****************************************************************************/ <br>/* GenerateData    - Fill in data buffer                                     */ <br>/*****************************************************************************/ <br>void GenerateData(CONVCB * convptr) <br>{ <br>  int i; <br>  int div; <br>  int rem; <br>  char * dptr; <br> <br>  dptr = convptr-&gt;DataPtr; <br>  div = convptr-&gt;SendSize / 5; <br>  rem = convptr-&gt;SendSize % 5; <br> <br>  for (; div--;) <br>  { <br>    for (i=4; i--; *dptr++ = datach); <br>    *dptr++ = '.'; <br>  } <br>  for (; rem--; *dptr++ = datach); <br> <br>  EnterCriticalSection(&amp;runsem); <br>  datach = (datach=='Z' ? 'A' : datach + 1); <br>  LeaveCriticalSection(&amp;runsem); <br>} <br> <br>/*****************************************************************************/ <br>/* ReadString - Get a line of text from the config file                      */ <br>/*****************************************************************************/ <br>int ReadString(char * lpValueName,char * lpData, int maxlen) <br>{ <br>  char       buffer[200]; <br>  char      *p = NULL; <br>  FILE      *h = NULL; <br>  BOOL       match = FALSE; <br>  BOOL       eof   = FALSE; <br>  int        rc = 0; <br>  int        ch = 0; <br>  int        i = 0; <br>  BOOL       gotdata = FALSE; <br>  char       separators[] = " =\t\n"; <br> <br>  GetModuleFileName( hInst, buffer, sizeof(buffer) ); <br>  lstrcpy( buffer+lstrlen(buffer) - 4, ".CFG" ); <br>  h = fopen( buffer, "r" ); <br>  buffer[0] = '\0'; <br> <br>  if (h != NULL) <br>  { <br>    while ((!match) &amp;&amp; (!eof)) <br>    { <br>      /***********************************************************************/ <br>      /* Use fgetc to read a line of text from the file                      */ <br>      /***********************************************************************/ <br>      for (i=0; (i&lt;sizeof(buffer))     &amp;&amp; <br>                ((ch=getc(h)) != EOF)  &amp;&amp; <br>                ((char)ch != '\n'); <br>                                   i++) <br>      { <br>        buffer[i] = (char)ch; <br>      } <br>      if ((char)ch == '\n') <br>      { <br>        buffer[i++] = (char)ch; <br>      } <br>      if (ch == EOF) <br>      { <br>        eof = TRUE; <br>      } <br>      else <br>      { <br>        /*********************************************************************/ <br>        /* Compare the first token in the line read with the requested parm  */ <br>        /*********************************************************************/ <br>        if (!strcmpi(strupr(strtok(buffer, separators)), lpValueName)) <br>        { <br>          match = TRUE; <br>          /*******************************************************************/ <br>          /* Get a pointer to the second token (the value we want)           */ <br>          /*******************************************************************/ <br>          p = strtok(NULL, separators); <br> <br>          /*******************************************************************/ <br>          /* Copy the data IF there is some                                  */ <br>          /*******************************************************************/ <br>          if (p != NULL) <br>          { <br>            /*****************************************************************/ <br>            /* Force a NULL after the second token                           */ <br>            /*****************************************************************/ <br>            strtok(NULL, separators); <br> <br>            /*****************************************************************/ <br>            /* Copy the data                                                 */ <br>            /*****************************************************************/ <br>            strncpy(lpData, p, maxlen); <br>            gotdata = TRUE; <br>          } <br>          else <br>          { <br>            gotdata = FALSE; <br>          } <br>        } <br>      } <br>    } <br> <br>    if (gotdata) <br>    { <br>      rc = 1; <br>    } <br> <br>    fclose(h); <br> <br>  } <br> <br>  return(rc); <br>} <br> <br>/*****************************************************************************/ <br>/* PadString - Remove terminating NULL  and pad on the right with spaces     */ <br>/*****************************************************************************/ <br>void PadString(char * string,int length) <br>{ <br>  char * p; <br>  if ((p=memchr(string,'\0',length)) != NULL) <br>  { <br>    while (p &lt; string+length) <br>    { <br>      *p++=' '; <br>    } <br>  } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
