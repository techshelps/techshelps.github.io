<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MRCV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5109"></a>MRCV.C</h2>
<pre><code>/* mrcv.c */ <br>/* (C) COPYRIGHT DATA CONNECTION LIMITED 1994 */ <br> <br>/*****************************************************************************/ <br>/* Change History                                                            */ <br>/*                                                                           */ <br>/*       21/02/94 DK  Created                                                */ <br>/*       15/03/94 DK  Thread priorities added and signalled event goes to    */ <br>/*                    back of the list (for WaitForMultipleObjects)          */ <br>/*       14/04/94 DK  OutputResults added                                    */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* If you want internal tracing, #define SRTRC here                          */ <br>/*****************************************************************************/ <br>//#define SRTRC <br> <br>/*****************************************************************************/ <br>/*                                                                           */ <br>/* ROUTINE : RECEIVE using event completion                                  */ <br>/*                                                                           */ <br>/* FUNCTION: This file contains the routines for a multi-threaded routine    */ <br>/*           which uses asynchronous APPC calls with event completion        */ <br>/*           to receive data.                                                */ <br>/*                                                                           */ <br>/*           It runs with either the single-threaded or the multi-threaded   */ <br>/*           version of send (msend or sendtp).                              */ <br>/*                                                                           */ <br>/* INPUTS  : MRCV.CFG (file) (documented below)                              */ <br>/*                                                                           */ <br>/* OUTPUTS : MRCV.TRC                                                        */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* Operation:                                                                */ <br>/*                                                                           */ <br>/* This is a Windows NT application which runs in a minimized window.        */ <br>/*                                                                           */ <br>/* Thread structure:                                                         */ <br>/*                                                                           */ <br>/*   A receive_allocate thread                                               */ <br>/*     This thread issues a receive_allocate and, when it completes, hands   */ <br>/*     it to a receive thread.  It then waits for the receive thread to      */ <br>/*     accept the conversation.  This thread uses event completion, but      */ <br>/*     its operation is essentially synchronous.                             */ <br>/*                                                                           */ <br>/*   A variable number of receive threads                                    */ <br>/*     Each receive thread processes a variable number of conversations and  */ <br>/*     issues a WaitForMultipleObjects call to wait for completion of any    */ <br>/*     one of its receive operations or for a request for a new conversation */ <br>/*     from the receive_allocate thread.  It sets a second event to tell the */ <br>/*     receive_allocate thread that it has accepted the conversation.        */ <br>/*     Each conversation issues MC_RECEIVE_AND_WAIT verbs to receive data.   */ <br>/*     If confirmation is requested, an MC_CONFIRM verb is issued.           */ <br>/*                                                                           */ <br>/*   Note:  this program is compatible with the single-threaded versions of  */ <br>/*   send, which can be run for example on WIN16 clients.                    */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* Configuration file:                                                       */ <br>/*                                                                           */ <br>/* The configuration file is called MRCV.CFG and must reside in the          */ <br>/* same directory as the program.  It contains the following, in any order.  */ <br>/* If any parameter is omitted, the default is assumed.                      */ <br>/*                                                                           */ <br>/* ResultFile = &lt;Name of file for results, default MRCV.OUT&gt;                 */ <br>/* TraceFile = &lt;Name of file for tracing, default MRCV.TRC&gt;                  */ <br>/* LocalTPName = &lt;Name used for receive_allocate, default MRCVTP&gt;            */ <br>/*                                                                           */ <br>/* NumRcvConvs = &lt;Number of conversations to be received, default = 4&gt;       */ <br>/* NumRcvThreads = &lt;Number of receive threads, default = 2&gt;                  */ <br>/*                                                                           */ <br>/* The name used for TP_STARTED is fixed at MRCV.                            */ <br>/*                                                                           */ <br>/* If NumRcvConvs is zero, the TP will keep issuing receive_allocates.       */ <br>/* If NumRcvConvs is non-zero and NumRcvThreads is greater than NumRcvConvs, */ <br>/*    NumRcvThreads is reduced to NumRcvConvs.                               */ <br>/* If NumRcvConvs is non-zero and NumRcvThreads*63 &lt; NumRcvConvs,            */ <br>/*    NumRcvThreads is increased to NumRcvConvs / 63 + 1.                    */ <br>/*                                                                           */ <br>/* Configuration constants (in mrcv.h)                                       */ <br>/*                                                                           */ <br>/* #define MAX_RECEIVE_THREADS  Max number of receive threads          (64)  */ <br>/* #define MAX_RCV_PER_THREAD   Max conversations per receive thread   (63)  */ <br>/*                                                                           */ <br>/* MAX_RCV_PER_THREAD is constrained by the limit of 64 objects that can be  */ <br>/* waited for in WaitForMultipleObjects.                                     */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>HINSTANCE hInst; <br>BOOL verbs_started = FALSE; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winappc.h&gt; <br>#include &lt;wincsv.h&gt; <br>#include "mrcv.h" <br> <br>/*****************************************************************************/ <br>/* Trace macros                                                              */ <br>/*****************************************************************************/ <br>#ifdef SRTRC <br>#define SRTROPEN() t = fopen(TraceFile,"w"); <br>#define SRTRFLUSH() fflush(t); <br>#define SRTRCLOSE() fclose(t); <br>#define SRTRACE fprintf <br>#else <br>#define SRTROPEN() <br>#define SRTRFLUSH() <br>#define SRTRCLOSE() <br>#define SRTRACE 1 ? (void) 0 : fprintf <br>#endif <br> <br>/*****************************************************************************/ <br>/* WinMain - reads initialization info and controls message loop             */ <br>/*           NT version                                                      */ <br>/*****************************************************************************/ <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                   LPSTR lpCmdLine, int nCmdShow) <br>{ <br> <br>  MSG msg; <br>  DWORD Tid; <br>  int i; <br>  HANDLE ThreadHandle; <br> <br>  hInst = hInstance; <br> <br>  InitializeMain(); <br> <br>  if (!InitializeWinMain(hInstance)) <br>  { <br>    return (FALSE); <br>  } <br> <br>  ReadConfig(); <br>  SRTROPEN() <br> <br>  /***************************************************************************/ <br>  /* Create two events for each receive thread                               */ <br>  /***************************************************************************/ <br>  for (i = 0; i &lt; NumRcvThreads; i++) <br>  { <br>    /*************************************************************************/ <br>    /* Create an event for kicking the receive thread                        */ <br>    /*************************************************************************/ <br>    RcvThreadArray[i].convptr = NULL; <br>    RcvThreadArray[i].event1 = CreateEvent(NULL,FALSE,FALSE,NULL); <br>    RcvThreadArray[i].event2 = CreateEvent(NULL,FALSE,FALSE,NULL); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Create receive threads                                                  */ <br>  /***************************************************************************/ <br>  for (i = 0; i &lt; NumRcvThreads; i++) <br>  { <br>    SRTRACE(t,"Created event handles %p %p for receive thread %d\n", <br>            RcvThreadArray[i].event1, RcvThreadArray[i].event2,i); <br> <br>    /*************************************************************************/ <br>    /* Create the thread                                                     */ <br>    /*************************************************************************/ <br>    ThreadHandle = CreateThread(NULL, <br>                                16000, <br>                                (LPTHREAD_START_ROUTINE)ReceiveThread, <br>                                (void *)i, <br>                                0, <br>                                &amp;Tid); <br>    if (ThreadHandle == NULL) <br>    { <br>      GetLastError(); <br>      DebugBreak(); <br>    } <br>    SetThreadPriority(ThreadHandle,THREAD_PRIORITY_LOWEST); <br>    SRTRACE(t,"Created receive thread %d with priority %d\n", <br>            i,GetThreadPriority(ThreadHandle)); <br>    CloseHandle(ThreadHandle); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Create receive_allocate thread                                          */ <br>  /***************************************************************************/ <br>  if (NumRcvThreads &gt; 0) <br>  { <br>    ThreadHandle = CreateThread(NULL, <br>                                16000, <br>                                (LPTHREAD_START_ROUTINE)RcvAllocThread, <br>                                NULL, <br>                                0, <br>                                &amp;Tid); <br>    if (ThreadHandle == NULL) <br>    { <br>      GetLastError(); <br>      DebugBreak(); <br>    } <br>    SetThreadPriority(ThreadHandle,THREAD_PRIORITY_NORMAL); <br>    SRTRACE(t,"Created receive allocate thread with priority %d\n", <br>            GetThreadPriority(ThreadHandle)); <br>    CloseHandle(ThreadHandle); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Windows processing loop                                                 */ <br>  /***************************************************************************/ <br>  while(GetMessage(&amp;msg,NULL,0,0)) <br>  { <br>    TranslateMessage(&amp;msg); <br>    DispatchMessage(&amp;msg); <br>  } <br> <br>  WinAPPCCleanup(); <br>  OutputResults(); <br>  SRTRFLUSH() <br>  SRTRCLOSE() <br>  DeleteCriticalSection(&amp;runsem); <br>  return msg.wParam;         /* save exit parameter for return               */ <br> <br>} <br> <br>/*****************************************************************************/ <br>/* RcvAllocThread - separate thread for receive_allocates                    */ <br>/*****************************************************************************/ <br>DWORD WINAPI RcvAllocThread() <br>{ <br>  /***************************************************************************/ <br>  /* Local variables                                                         */ <br>  /***************************************************************************/ <br>  CONVCB * convptr; <br>  struct appc_hdr * vcbptr; <br>  unsigned short ThreadNo; <br>  unsigned short NextReceive = 0; <br>  BOOL   RcvAllocEnded = FALSE; <br>  DWORD rc; <br>  SYSTEMTIME st; <br> <br>  /***************************************************************************/ <br>  /* Count threads within critical section                                   */ <br>  /***************************************************************************/ <br>  EnterCriticalSection(&amp;runsem); <br>  ThreadCount++; <br>  ThreadNo = ThreadCount; <br>  LeaveCriticalSection(&amp;runsem); <br> <br>  SRTRACE(t,"Thread %d (ralc) Started\n",ThreadNo); <br> <br>  /***************************************************************************/ <br>  /* Loop round until the required number of conversations have been         */ <br>  /* allocated                                                               */ <br>  /***************************************************************************/ <br>  while ((NumRcvConvs == 0) || (NumRalcs &lt; NumRcvConvs)) <br>  { <br>    /*************************************************************************/ <br>    /* Make a conversation control block                                     */ <br>    /*************************************************************************/ <br>    convptr = malloc (sizeof(CONVCB)); <br>    convptr-&gt;thread       = ThreadNo; <br>    convptr-&gt;conv         = 0; <br>    convptr-&gt;TPid[0]      = '\0'; <br>    convptr-&gt;Convid       = 0; <br>    convptr-&gt;async_corr   = 0; <br>    convptr-&gt;RcvCount     = 0; <br>    convptr-&gt;TPEnded      = FALSE; <br>    convptr-&gt;Deallocated  = FALSE; <br>    convptr-&gt;DataPtr      = malloc(RcvSize); <br>    vcbptr = (struct appc_hdr *) &amp;convptr-&gt;vcb; <br>    memset(vcbptr,0,sizeof(VCB)); <br>    strcpy (convptr-&gt;type,"ralc"); <br> <br>    /*************************************************************************/ <br>    /* Create an event                                                       */ <br>    /*************************************************************************/ <br>    convptr-&gt;hEvent = CreateEvent(NULL,FALSE,FALSE,NULL); <br>    SRTRACE(t,"Thread %d (ralc) convptr %p\n",ThreadNo,convptr); <br>    SRTRACE(t,"Thread %d (ralc) event handle %p\n",ThreadNo,convptr-&gt;hEvent); <br> <br>    /*************************************************************************/ <br>    /* Build a receive_allocate                                              */ <br>    /*************************************************************************/ <br>    Build_RECEIVE_ALLOCATE (convptr); <br> <br>    /*************************************************************************/ <br>    /* Issue receive_allocate using event notification                       */ <br>    /*************************************************************************/ <br>    convptr-&gt;async_corr = WinAsyncAPPCEx(convptr-&gt;hEvent, <br>                                         (long)(char *)(vcbptr)); <br>//  SRTRACE(t,"Thread %d (ralc) Receive_Allocate issued corr %p\n", <br>//          ThreadNo,convptr-&gt;async_corr); <br>    SRTRFLUSH() <br>    if (convptr-&gt;async_corr == 0) <br>    { <br>      SRTRACE(t,"Thread %d (ralc) WinAsync call %x failed zero corr %p\n", <br>              ThreadNo,vcbptr-&gt;opcode,convptr-&gt;async_corr); <br>      break; <br>    } <br>    else <br>    { <br>      /***********************************************************************/ <br>      /* Wait for event completion                                           */ <br>      /***********************************************************************/ <br>      rc = WaitForSingleObject(convptr-&gt;hEvent,INFINITE); <br>      if (rc == WAIT_FAILED) <br>      { <br>        rc = GetLastError(); <br>        SRTRACE(t,"Thread %d (ralc) wait for event_1 %p failed with rc %d\n", <br>                ThreadNo,convptr-&gt;hEvent,rc); <br>        break; <br>      } <br>      if (vcbptr-&gt;primary_rc != AP_OK) <br>      { <br>        SRTRACE(t,"Thread %d (ralc) WinAsync error: %s prc %4.4x src %8.8x\n", <br>                ThreadNo,VerbName[vcbptr-&gt;opcode], <br>                APPC_FLIPI(vcbptr-&gt;primary_rc), <br>                APPC_FLIPL(vcbptr-&gt;secondary_rc)); <br>        break; <br>      } <br>      else <br>      { <br>        NumRalcs++; <br>        SRTRACE(t,"Thread %d (ralc) Receive_Allocate %d completed\n", <br>                ThreadNo,NumRalcs); <br> <br>        /*********************************************************************/ <br>        /* give it to a receive thread by kicking event 1                    */ <br>        /*********************************************************************/ <br>        RcvThreadArray[NextReceive].convptr = convptr; <br>//      SRTRACE(t,"Thread %d (ralc) convptr %p\n",ThreadNo,convptr); <br>//      SRTRACE(t,"Thread %d (ralc) kicking receive thread %d\n", <br>//              ThreadNo,NextReceive); <br>//      SRTRACE(t,"Thread %d (ralc) setting event_1 %p\n",ThreadNo, <br>//              RcvThreadArray[NextReceive].event1); <br>        rc = SetEvent (RcvThreadArray[NextReceive].event1); <br>        if (rc == FALSE) <br>        { <br>          rc = GetLastError(); <br>          SRTRACE(t,"Thread %d (ralc) setting event_1 %p failed with rc %d\n", <br>                  ThreadNo,RcvThreadArray[NextReceive].event1,rc); <br>          break; <br>        } <br> <br>        /*********************************************************************/ <br>        /* wait for receive thread to release event 2                        */ <br>        /*********************************************************************/ <br>//      SRTRACE(t,"Thread %d (ralc) waiting for event_2 %d\n",ThreadNo, <br>//              RcvThreadArray[NextReceive].event2); <br>        rc = WaitForSingleObject(RcvThreadArray[NextReceive].event2,INFINITE); <br>        if (rc == WAIT_FAILED) <br>        { <br>          rc = GetLastError(); <br>          SRTRACE(t,"Thread %d (ralc) wait for event_2 %p failed with rc %d\n", <br>                  ThreadNo,RcvThreadArray[NextReceive].event2,rc); <br>          break; <br>        } <br> <br>        /*********************************************************************/ <br>        /* ready for next receive allocate                                   */ <br>        /*********************************************************************/ <br>        NextReceive++; <br>        if (NextReceive == NumRcvThreads) <br>        { <br>          NextReceive = 0; <br>        } <br>      } <br>    } <br>  } <br> <br>  /***************************************************************************/ <br>  /* Kick receive threads for last time in case they are idle                */ <br>  /* convptr is set to NULL to indicate this final kick                      */ <br>  /***************************************************************************/ <br>  SRTRACE(t,"Thread %d (ralc) last kicks\n",ThreadNo); <br>  for (NextReceive = 0; NextReceive &lt; NumRcvThreads; NextReceive++) <br>  { <br>    RcvThreadArray[NextReceive].convptr = NULL; <br>    rc = SetEvent (RcvThreadArray[NextReceive].event1); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Count threads within critical section                                   */ <br>  /***************************************************************************/ <br>  EnterCriticalSection(&amp;runsem); <br>  ThreadCount--; <br>  GetLocalTime(&amp;st); <br>  SRTRACE(t,"Thread %d (ralc) Exit at %d:%d:%d: ThreadCount %d\n", <br>          ThreadNo,st.wHour,st.wMinute,st.wSecond,ThreadCount); <br>  if (ThreadCount == 0) <br>  { <br>    PostMessage(hWndMain, WM_CLOSE, 0, 0); <br>  } <br>  LeaveCriticalSection(&amp;runsem); <br>  return(0); <br>} <br> <br>/*****************************************************************************/ <br>/* ReceiveThread - service thread which processes multiple conversations     */ <br>/*****************************************************************************/ <br>DWORD WINAPI ReceiveThread(DWORD k) <br>{ <br>  /***************************************************************************/ <br>  /* Separate variables for each instance of this thread                     */ <br>  /***************************************************************************/ <br>  DWORD ObjIndex; <br>  DWORD i; <br>  DWORD j; <br>  DWORD rc; <br>  unsigned short NumConvs = 0; <br>  unsigned short RcvMax = 0; <br>  unsigned short ThreadNo; <br>  unsigned short RcvThreadNo; <br>  CONVCB * ConvptrArray [MAX_RCV_PER_THREAD+2]; <br>  HANDLE EventArray [MAX_RCV_PER_THREAD+2]; <br>  SYSTEMTIME st; <br> <br>  EventArray[0] = RcvThreadArray[k].event1; <br>  ConvptrArray[0] = NULL; <br>  for (i = 1; i &lt; MAX_RCV_PER_THREAD+2; i++) <br>  { <br>    EventArray[i] = NULL; <br>    ConvptrArray[i] = NULL; <br>  } <br> <br>  /***************************************************************************/ <br>  /* Count threads                                                           */ <br>  /***************************************************************************/ <br>  EnterCriticalSection(&amp;runsem); <br>  ThreadCount++; <br>  RcvThreads++; <br>  ThreadNo = ThreadCount; <br>  RcvThreadNo = RcvThreads; <br>  OUTPUTNUMBER <br>  LeaveCriticalSection(&amp;runsem); <br> <br>  SRTRACE(t,"Thread %d (recv) Started\n",k); <br>  SRTRACE(t,"Thread %d (recv) has event handles %p %p\n",k, <br>          RcvThreadArray[k].event1,RcvThreadArray[k].event2); <br> <br>  /***************************************************************************/ <br>  /* Loop round until finished                                               */ <br>  /***************************************************************************/ <br>  while (TRUE) <br>  { <br>    /*************************************************************************/ <br>    /* Wait for event completion                                             */ <br>    /*************************************************************************/ <br>//  SRTRACE(t,"Thread %d (recv) waiting for %d events to complete\n", <br>//          k,NumConvs+1); <br>    ObjIndex = WaitForMultipleObjects(NumConvs+1,EventArray,FALSE,INFINITE); <br>    if (ObjIndex == WAIT_FAILED) <br>    { <br>      rc = GetLastError(); <br>      SRTRACE(t,"Thread %d (recv) wait for %d events failed with rc %d\n", <br>              k,NumConvs+1,rc); <br>      for (j = 0; j &lt;= NumConvs; j++) <br>      { <br>        SRTRACE(t,"Thread %d (recv) event %d has handle %p\n", <br>                k,j,EventArray[j]); <br>      } <br>      break; <br>    } <br>    ObjIndex -= WAIT_OBJECT_0; <br>//  SRTRACE(t,"Thread %d (recv) event %d has completed\n",k,ObjIndex); <br>    if (ObjIndex == 0) <br>    { <br>      /***********************************************************************/ <br>      /* final kick from receive_allocate thread - terminate if idle         */ <br>      /***********************************************************************/ <br>      if (RcvThreadArray[k].convptr == NULL) <br>      { <br>        SRTRACE(t,"Thread %d (recv) ralc thread terminating\n",k); <br>        SRTRACE(t,"Thread %d (recv) NumRalcs %d NumRcvConvs %d NumConvs %d\n", <br>                k,NumRalcs,NumRcvConvs,NumConvs); <br>        if (NumConvs == 0) <br>        { <br>          break; <br>        } <br>        else <br>        { <br>          continue; <br>        } <br>      } <br>      else <br>      { <br>        /*********************************************************************/ <br>        /* new conversation - save convptr and release rcv_alloc thread      */ <br>        /*********************************************************************/ <br>        SRTRACE(t,"Thread %d (recv) new conversation\n",k); <br> <br>        /*********************************************************************/ <br>        /* select next entry in the convptr array as conversation index      */ <br>        /*********************************************************************/ <br>        NumConvs++; <br>        i = NumConvs; <br> <br>        /*********************************************************************/ <br>        /* set up convptr array                                              */ <br>        /* save service thread number and slot number in convcb for tracing  */ <br>        /* add event to event array                                          */ <br>        /*********************************************************************/ <br>        ConvptrArray[i] = RcvThreadArray[k].convptr; <br>//      SRTRACE(t,"Thread %d:%d (recv) using convptr %p\n",k,i,ConvptrArray[i]); <br>        ConvptrArray[i]-&gt;thread = (unsigned short)k; <br>        ConvptrArray[i]-&gt;conv   = (unsigned short)i; <br>        strcpy (ConvptrArray[i]-&gt;type,"recv"); <br>        EventArray[i] = ConvptrArray[i]-&gt;hEvent; <br>        EnterCriticalSection(&amp;runsem); <br>        SimRcvConvs++; <br>        OUTPUTNUMBER <br>        SRTRACE(t,"Thread %d:%d (recv) NumConvs %d SimRcvConvs %d\n", <br>                k,i,NumConvs,SimRcvConvs); <br>        LeaveCriticalSection(&amp;runsem); <br> <br>        /*********************************************************************/ <br>        /* release receive_allocate thread                                   */ <br>        /*********************************************************************/ <br>//      SRTRACE(t,"Thread %d:%d (recv) setting event_2 %p\n", <br>//              k,i,RcvThreadArray[k].event2); <br>        rc = SetEvent (RcvThreadArray[k].event2); <br>        if (rc == FALSE) <br>        { <br>          rc = GetLastError(); <br>          SRTRACE(t,"Thread %d:%d (recv) setting event_2 %p failed with rc %d\n", <br>                  k,i,RcvThreadArray[k].event2,rc); <br>          break; <br>        } <br>      } <br>    } <br>    else <br>    { <br>      /***********************************************************************/ <br>      /* Object index locates existing conversation                          */ <br>      /***********************************************************************/ <br>      i = ObjIndex; <br>    } <br> <br>    /*************************************************************************/ <br>    /* Issue the next verb                                                   */ <br>    /*************************************************************************/ <br>//  SRTRACE(t,"Thread %d:%d (recv) issuing next verb\n", <br>//          k,ConvptrArray[i]-&gt;conv); <br>    ConvptrArray[i]-&gt;TPEnded = IssueRcvVerb(ConvptrArray[i]); <br>    if (ConvptrArray[i]-&gt;TPEnded) <br>    { <br>      /***********************************************************************/ <br>      /* end of conversation                                                 */ <br>      /***********************************************************************/ <br>      SRTRACE(t,"Thread %d:%d (recv) conversation completed\n", <br>              k,ConvptrArray[i]-&gt;conv); <br>      NumConvs--; <br>      EnterCriticalSection(&amp;runsem); <br>      SimRcvConvs--; <br>      RcvConvs++; <br>      OUTPUTNUMBER <br>      SRTRACE(t,"Thread %d:%d (recv) NumConvs %d SimRcvConvs %d RcvConvs %d\n", <br>              k,ConvptrArray[i]-&gt;conv,NumConvs,SimRcvConvs,RcvConvs); <br>      SRTRACE(t,"Thread %d:%d (recv) NumRalcs %d NumRcvConvs %d NumConvs %d\n", <br>              k,ConvptrArray[i]-&gt;conv,NumRalcs,NumRcvConvs,NumConvs); <br>      LeaveCriticalSection(&amp;runsem); <br> <br>      /***********************************************************************/ <br>      /* free resources                                                      */ <br>      /***********************************************************************/ <br>      SRTRACE(t,"Thread %d:%d (recv) clearing entry %d\n", <br>              k,ConvptrArray[i]-&gt;conv,i); <br>      CloseHandle(ConvptrArray[i]-&gt;hEvent); <br>      free (ConvptrArray[i]-&gt;DataPtr); <br>      free (ConvptrArray[i]); <br>      ConvptrArray[i] = NULL; <br>      EventArray[i]   = NULL; <br> <br>      /***********************************************************************/ <br>      /* if the required number of conversations have been allocated and     */ <br>      /* this thread has just finished its last conversation, end loop       */ <br>      /***********************************************************************/ <br>      if ((NumRcvConvs &gt; 0) &amp;&amp; (NumRalcs == NumRcvConvs) &amp;&amp; (NumConvs == 0)) <br>      { <br>        break; <br>      } <br> <br>      /***********************************************************************/ <br>      /* the event array cannot have holes in it, so shuffle up the          */ <br>      /* pointers and events                                                 */ <br>      /* note that this means convptr-&gt;conv no longer matches i              */ <br>      /* which is why tracing uses ConvptrArray[i]-&gt;conv                     */ <br>      /***********************************************************************/ <br>      for (j = i; j &lt;= NumConvs; j++) <br>      { <br>        ConvptrArray [j] = ConvptrArray [j+1]; <br>        EventArray [j] = EventArray [j+1]; <br>      } <br>      ConvptrArray [NumConvs+1] = NULL; <br>      EventArray [NumConvs+1] = NULL; <br>    } <br>    else <br>    { <br>      /***********************************************************************/ <br>      /* to stop one conversation getting an unfair share of the time,       */ <br>      /* move this conversation to the end and shuffle up the pointers.      */ <br>      /* note that this means convptr-&gt;conv no longer matches i              */ <br>      /* which is why tracing uses ConvptrArray[i]-&gt;conv                     */ <br>      /***********************************************************************/ <br>      ConvptrArray [NumConvs+1] = ConvptrArray [i]; <br>      EventArray [NumConvs+1] = EventArray [i]; <br>      for (j = i; j &lt;= NumConvs; j++) <br>      { <br>        ConvptrArray [j] = ConvptrArray [j+1]; <br>        EventArray [j] = EventArray [j+1]; <br>      } <br>      ConvptrArray [NumConvs+1] = NULL; <br>      EventArray [NumConvs+1] = NULL; <br>    } <br>  } <br> <br>  /***************************************************************************/ <br>  /* Count threads within critical section                                   */ <br>  /***************************************************************************/ <br>  EnterCriticalSection(&amp;runsem); <br>  ThreadCount--; <br>  RcvThreads--; <br>  GetLocalTime(&amp;st); <br>  SRTRACE(t,"Thread %d (recv) Exit at %d:%d:%d: ThreadCount %d\n", <br>          k,st.wHour,st.wMinute,st.wSecond,ThreadCount); <br>  OUTPUTNUMBER <br>  if (ThreadCount == 0) <br>  { <br>    PostMessage(hWndMain, WM_CLOSE, 0, 0); <br>  } <br>  LeaveCriticalSection(&amp;runsem); <br> <br>  return(0); <br>} <br> <br>/*****************************************************************************/ <br>/* InitializeWinMain - does the windows bits of initialisation               */ <br>/*****************************************************************************/ </code></pre>
<p>
</p>
<pre><code>BOOL InitializeWinMain(HINSTANCE hInstance) <br>{ <br>  WAPPCDATA APPCData; <br>  WNDCLASS class; <br>  #define WinAPPCVERSION  0x0001 <br> <br>  /***************************************************************************/ <br>  /* Startup WinAPPC                                                         */ <br>  /***************************************************************************/ <br>  if (WinAPPCStartup(WinAPPCVERSION,&amp;APPCData)) <br>  { <br>    return (FALSE); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Register Window Class for our icon                                      */ <br>  /***************************************************************************/ <br> <br>  class.style = 0; <br>  class.lpfnWndProc   = (WNDPROC)TPWndProc; <br>  class.cbClsExtra    = (DWORD)0; <br>  class.cbWndExtra    = (DWORD)0; <br>  class.hInstance     = hInstance; <br>  class.hIcon         = LoadIcon(hInstance,"MainIcon"); <br>  class.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>  class.hbrBackground = GetStockObject(WHITE_BRUSH); <br>  class.lpszMenuName  = (LPSTR) NULL; <br>  class.lpszClassName = (LPSTR) "MRCV\0"; <br> <br>  if (!RegisterClass(&amp;class)) <br>  { <br>    return (FALSE); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Create the window                                                       */ <br>  /***************************************************************************/ <br>  sprintf(title,"APPC Receive TP\0"); <br> <br>  if ((hWndMain = CreateWindow("MRCV\0",          /* window class            */ <br>      title,                                      /* window name             */ <br>      WS_MINIMIZE|WS_OVERLAPPEDWINDOW,            /* window style            */ <br>      0,                                          /* x position              */ <br>      0,                                          /* y position              */ <br>      10,                                         /* width                   */ <br>      10,                                         /* height                  */ <br>      NULL,                                       /* parent handle           */ <br>      NULL,                                       /* menu or child ID        */ <br>      hInstance,                                  /* instance                */ <br>      NULL))                                      /* additional info         */ <br>      == NULL) <br>  { <br>    return (FALSE); <br>  } <br> <br>  ShowWindow(hWndMain, SW_MINIMIZE); <br> <br>  return(TRUE); <br> <br>} <br> <br>/*****************************************************************************/ <br>/* Window proc for the iconised window                                       */ <br>/*****************************************************************************/ <br>LONG PASCAL TPWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br>{ <br>  switch (message) <br>  { <br>    case WM_CREATE: <br>      break; <br> <br>    case WM_QUERYOPEN: <br>      /***********************************************************************/ <br>      /* Prevent the window being opened                                     */ <br>      /***********************************************************************/ <br>      break; <br> <br>    case WM_CLOSE: <br>      return DefWindowProc(hWnd, message, wParam, lParam); <br>      break; <br> <br>    case WM_DESTROY: <br>      PostQuitMessage(0); <br>      break; <br> <br>    default: <br>      return DefWindowProc(hWnd, message, wParam, lParam); <br>      break; <br>  } <br>  return 0l; <br>} <br> <br>/*****************************************************************************/ <br>/* InitializeMain - blanks out variables not set in ReadConfig               */ <br>/*****************************************************************************/ <br>void InitializeMain() <br>{ <br>  RcvThreads  = 0; <br>  ThreadCount = 0; <br>  NumResults  = 0; <br>  cnvtptr     = (char *)&amp;cnvt; <br> <br>  InitializeCriticalSection(&amp;runsem); <br>} <br> <br>/*****************************************************************************/ <br>/* IssueRcvVerb - looks at the verb which has just completed and does the    */ <br>/*                 next one                                                  */ <br>/*****************************************************************************/ <br>BOOL IssueRcvVerb(CONVCB * convptr) <br>{ <br>  BOOL TPEnded; <br>  struct appc_hdr * vcbptr; <br> <br>//SRTRACE(t,"Thread %d:%d (recv) IssueRcvVerb\n", <br>//        convptr-&gt;thread,convptr-&gt;conv); <br>  TPEnded = FALSE; <br>  vcbptr = (struct appc_hdr *) &amp;convptr-&gt;vcb; <br>  if (vcbptr-&gt;opcode != 0x0000) <br>  { <br>    TPEnded = ProcessReturns(convptr); <br>  } <br>  if (!TPEnded) <br>  { <br>    switch (vcbptr-&gt;opcode) <br>    { <br>      case 0x0000: <br>        Build_RECEIVE_ALLOCATE(convptr); <br>        break; <br> <br>      case AP_RECEIVE_ALLOCATE: <br>        StartConversation(convptr); <br>        Build_MC_RECEIVE_AND_WAIT(convptr); <br>        break; <br> <br>      case AP_M_RECEIVE_AND_WAIT: <br>        if ((P_M_RAW(vcbptr)-&gt;what_rcvd == AP_DATA_COMPLETE) || <br>            (P_M_RAW(vcbptr)-&gt;what_rcvd == AP_DATA_COMPLETE_CONFIRM) || <br>            (P_M_RAW(vcbptr)-&gt;what_rcvd == AP_DATA_COMPLETE_CONFIRM_DEALL)) <br>        { <br>          convptr-&gt;RcvCount++; <br>        } <br>        if ((P_M_RAW(vcbptr)-&gt;primary_rc == AP_DEALLOC_NORMAL)) <br>        { <br>          /*******************************************************************/ <br>          /* Issue TP_ENDED every time conversation deallocated              */ <br>          /*******************************************************************/ <br>          EndConversation(convptr); <br>          Build_TP_ENDED(convptr); <br>        } <br>        else if ((P_M_RAW(vcbptr)-&gt;what_rcvd == AP_CONFIRM_WHAT_RECEIVED) || <br>                 (P_M_RAW(vcbptr)-&gt;what_rcvd == AP_DATA_COMPLETE_CONFIRM)) <br>        { <br>          Build_MC_CONFIRMED(convptr); <br>          convptr-&gt;Deallocated = FALSE; <br>        } <br>        else if ((P_M_RAW(vcbptr)-&gt;what_rcvd == AP_CONFIRM_DEALLOCATE) || <br>                 (P_M_RAW(vcbptr)-&gt;what_rcvd == AP_DATA_COMPLETE_CONFIRM_DEALL)) <br>        { <br>          Build_MC_CONFIRMED(convptr); <br>          convptr-&gt;Deallocated = TRUE; <br>        } <br>        else <br>        { <br>          Build_MC_RECEIVE_AND_WAIT(convptr); <br>        } <br>        break; <br> <br>      case AP_M_CONFIRMED: <br>        if (convptr-&gt;Deallocated) <br>        { <br>          /*******************************************************************/ <br>          /* Issue TP_ENDED every time conversation deallocated              */ <br>          /*******************************************************************/ <br>          EndConversation(convptr); <br>          Build_TP_ENDED(convptr); <br>        } <br>        else <br>        { <br>          Build_MC_RECEIVE_AND_WAIT(convptr); <br>        } <br>        break; <br> <br>      case AP_TP_ENDED: <br>        /*********************************************************************/ <br>        /* set TPEnded                                                       */ <br>        /*********************************************************************/ <br>        TPEnded = TRUE; <br>        break; <br> <br>      default: <br>        /*********************************************************************/ <br>        /* What is this verb then ??                                         */ <br>        /*********************************************************************/ <br>        TPEnded = TRUE; <br>        DebugBreak(); <br>        break; <br> <br>    } /* Op-code switch */ <br>    SRTRFLUSH() <br> <br>  } <br> <br>  /***************************************************************************/ <br>  /* Now go ahead and issue the verb, if we're not finished                  */ <br>  /***************************************************************************/ <br>  if (!TPEnded) <br>  { <br>    convptr-&gt;async_corr = WinAsyncAPPCEx(convptr-&gt;hEvent, <br>                          (long)(char *)(vcbptr)); <br>    if (convptr-&gt;async_corr == 0) <br>    { <br>      SRTRACE(t,"Thread %d:%d (recv) WinAsync call %x failed corr %p\n", <br>              convptr-&gt;thread,convptr-&gt;conv, <br>              vcbptr-&gt;opcode,convptr-&gt;async_corr); <br>      convptr-&gt;TPEnded = TRUE; <br>    } <br>  } <br> <br>  SRTRFLUSH() <br>  return(TPEnded); <br> <br>} /* Issue receive verb */ <br> <br>/*****************************************************************************/ <br>/* Build routines to build all required verbs                                */ <br>/*****************************************************************************/ <br> <br>void Build_TP_ENDED(CONVCB * convptr) <br>{ <br>  TP_ENDED * vcbptr; <br>  SRTRACE(t,"Thread %d:%d (%s) Build_TP_Ended\n", <br>          convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (TP_ENDED *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_TP_ENDED; <br>  memcpy(&amp;(vcbptr-&gt;tp_id), convptr-&gt;TPid, 8); <br>  vcbptr-&gt;type = AP_SOFT; <br>} <br> <br>void Build_RECEIVE_ALLOCATE(CONVCB * convptr) <br>{ <br>  RECEIVE_ALLOCATE * vcbptr; <br>  SRTRACE(t,"Thread %d:%d (%s) Build_Receive_Allocate\n", <br>          convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (RECEIVE_ALLOCATE *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_RECEIVE_ALLOCATE; <br>  memcpy(vcbptr-&gt;tp_name, LocalTPName, 64); <br>} <br> <br>void Build_MC_CONFIRMED(CONVCB * convptr) <br>{ <br>  MC_CONFIRMED * vcbptr; <br>//SRTRACE(t,"Thread %d:%d (%s) Build_MC_Confirmed\n", <br>//        convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (MC_CONFIRMED *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_M_CONFIRMED; <br>  vcbptr-&gt;opext = AP_MAPPED_CONVERSATION; <br>  memcpy(&amp;(vcbptr-&gt;tp_id),convptr-&gt;TPid, 8); <br>  vcbptr-&gt;conv_id = convptr-&gt;Convid; <br>} <br> <br>void Build_MC_RECEIVE_AND_WAIT(CONVCB * convptr) <br>{ <br>  MC_RECEIVE_AND_WAIT * vcbptr; <br>//SRTRACE(t,"Thread %d:%d (%s) Build_MC_Receive_And_Wait\n", <br>//        convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (MC_RECEIVE_AND_WAIT *) &amp;(convptr-&gt;vcb); <br> <br>  CLEARVCB <br> <br>  vcbptr-&gt;opcode = AP_M_RECEIVE_AND_WAIT; <br>  vcbptr-&gt;opext = AP_MAPPED_CONVERSATION; <br>  memcpy(&amp;(vcbptr-&gt;tp_id),convptr-&gt;TPid, 8); <br>  vcbptr-&gt;conv_id = convptr-&gt;Convid; <br>  vcbptr-&gt;rtn_status = AP_YES; <br>  vcbptr-&gt;max_len = RcvSize; <br>  vcbptr-&gt;dptr = convptr-&gt;DataPtr; <br>} <br> <br>/*****************************************************************************/ <br>/* ProcessReturns - Checks return codes from the last verb to complete and   */ <br>/*                  saves conversation id and tp id in the conversation cb   */ <br>/*****************************************************************************/ <br>BOOL ProcessReturns(CONVCB * convptr) <br>{ <br>  BOOL TPEnded = FALSE; <br>  struct appc_hdr * vcbptr; <br>  SYSTEMTIME st; <br> <br>//SRTRACE(t,"Thread %d:%d (%s) ProcessReturns\n", <br>//        convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>  vcbptr = (struct appc_hdr *) &amp;(convptr-&gt;vcb); <br> <br>  GetLocalTime(&amp;st); <br>  if (vcbptr-&gt;primary_rc != AP_OK) <br>  { <br>    SRTRACE(t,"Thread %d:%d (%s) error: %s prc %4.4x src %8.8x at %d:%d:%d\n", <br>            convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>            VerbName[vcbptr-&gt;opcode], <br>            APPC_FLIPI(vcbptr-&gt;primary_rc),APPC_FLIPL(vcbptr-&gt;secondary_rc), <br>            st.wHour,st.wMinute,st.wSecond); <br>    if ((vcbptr-&gt;opcode == AP_M_RECEIVE_AND_WAIT) &amp;&amp; <br>        (vcbptr-&gt;primary_rc == AP_DEALLOC_NORMAL)) <br>    { <br>      SRTRACE(t,"Thread %d:%d (%s) MC_RECEIVE_AND_WAIT completed with DEALLOC_NORMAL\n",\ <br>              convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>    } <br>    else if ((vcbptr-&gt;opcode == AP_M_CONFIRM) &amp;&amp; <br>             (vcbptr-&gt;primary_rc == AP_ALLOCATION_ERROR)) <br>    { <br>      SRTRACE(t,"Thread %d:%d (%s) MC_CONFIRM completed with ALLOCATION_ERROR\n", <br>              convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>    } <br>    else <br>    { <br>      TPEnded = TRUE; <br>      SRTRACE(t,"Thread %d:%d (%s) unexpected error on %s - set TPEnded\n", <br>              convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>              VerbName[vcbptr-&gt;opcode]); <br>    } <br>  } <br>  else <br>  { <br>    switch (vcbptr-&gt;opcode) <br>    { <br>      case AP_TP_ENDED: <br>        SRTRACE(t,"Thread %d:%d (%s) TP_Ended completed at %d:%d:%d\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>                st.wHour,st.wMinute,st.wSecond); <br>        break; <br> <br>      case AP_RECEIVE_ALLOCATE: <br>        SRTRACE(t,"Thread %d:%d (%s) Receive_Allocate completed at %d:%d:%d\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>                st.wHour,st.wMinute,st.wSecond); <br>        memcpy(convptr-&gt;TPid,&amp;(P_RAL(vcbptr)-&gt;tp_id),8); <br>        convptr-&gt;Convid = P_RAL(vcbptr)-&gt;conv_id; <br>        break; <br> <br>      case AP_M_RECEIVE_AND_WAIT: <br>//      SRTRACE(t,"Thread %d:%d (%s) MC_Receive_And_Wait completed at %d:%d:%d\n", <br>//              convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>//              st.wHour,st.wMinute,st.wSecond); <br>        break; <br> <br>      case AP_M_CONFIRMED: <br>SRTRACE(t,"Thread %d:%d (%s) MC_Confirmed completed at %d:%d:%d: receive count %d\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type, <br>                st.wHour,st.wMinute,st.wSecond, <br>                convptr-&gt;RcvCount); <br>        break; <br> <br>      default: <br>        SRTRACE(t,"Thread %d:%d (%s) UNKNOWN opcode - set TPEnded\n", <br>                convptr-&gt;thread,convptr-&gt;conv,convptr-&gt;type); <br>        TPEnded = TRUE; <br>        DebugBreak(); <br>        break; <br>    } <br>  } <br>  SRTRFLUSH() <br>  return(TPEnded); <br>} <br> <br>/*****************************************************************************/ <br>/* ReadConfig - Reads config info from MRCV.CFG and allocates buffer for     */ <br>/*              receiving                                                    */ <br>/*****************************************************************************/ <br>void ReadConfig() <br>{ <br>  char buffer[200]; <br> <br>  if (!ReadString("ResultFile",FileName,60)) <br>  { <br>    strcpy(FileName,"MRCV.OUT"); <br>  } <br> <br>  if (!ReadString("TraceFile",TraceFile,60)) <br>  { <br>    strcpy(TraceFile,"MRCV.TRC"); <br>  } <br> <br>  strcpy(TPName,"MRCV"); <br>  PadString(TPName,64); <br>  CONV_A_TO_E(TPName,64); <br> <br>  if (!ReadString("LocalTPName",LocalTPName,64)) <br>  { <br>    strcpy(LocalTPName,"MRCVTP"); <br>  } <br>  PadString(LocalTPName,64); <br>  CONV_A_TO_E(LocalTPName,64); <br> <br>  RcvSize=4096; <br>  if (ReadString("RcvSize",buffer,200)) <br>  { <br>    RcvSize=atoi(buffer); <br>  } <br> <br>  NumRcvThreads = 2; <br>  if (ReadString("NumRcvThreads",buffer,200)) <br>  { <br>    NumRcvThreads=atoi(buffer); <br>  } <br> <br>  NumRcvConvs = 4; <br>  if (ReadString("NumRcvConvs",buffer,200)) <br>  { <br>    NumRcvConvs=atoi(buffer); <br>  } <br>  NumRalcs = 0; <br>  RcvConvs = 0; <br> <br>  if (NumRcvConvs &gt; 0 &amp;&amp; NumRcvThreads * 63 &lt; NumRcvConvs) <br>  { <br>    NumRcvThreads = NumRcvConvs / 63 + 1; <br>  } <br> <br>  if (NumRcvConvs &gt; 0 &amp;&amp; NumRcvThreads &gt; NumRcvConvs) <br>  { <br>    NumRcvThreads = NumRcvConvs; <br>  } <br>} <br> <br>/*****************************************************************************/ <br>/* CONV_A_TO_E - ASCII to EBCDIC conversion routine                          */ <br>/*****************************************************************************/ <br>void CONV_A_TO_E(char * string,int length) <br>{ <br>  memset(cnvtptr,0,sizeof(cnvt)); <br> <br>  cnvt.opcode       = SV_CONVERT; <br>  cnvt.direction    = SV_ASCII_TO_EBCDIC; <br>  cnvt.char_set     = SV_AE; <br> <br>  cnvt.len          = length; <br>  cnvt.source       = string; <br>  cnvt.target       = string; <br> <br>  ACSSVC_C((long)(char *) (cnvtptr)); <br>} <br> <br>/*****************************************************************************/ <br>/* CONV_E_TO_A - EBCDIC to ASCII conversion routine                          */ <br>/*****************************************************************************/ <br>void CONV_E_TO_A(char * string,int length) <br>{ <br>  memset(cnvtptr,0,sizeof(cnvt)); <br> <br>  cnvt.opcode       = SV_CONVERT; <br>  cnvt.direction    = SV_EBCDIC_TO_ASCII; <br>  cnvt.char_set     = SV_AE; <br>  cnvt.len          = length; <br>  cnvt.source       = string; <br>  cnvt.target       = string; <br> <br>  ACSSVC_C((long)(char *) (cnvtptr)); <br>} <br> <br>/*****************************************************************************/ <br>/* StartConversation - Record start time for this conversation               */ <br>/*****************************************************************************/ <br>void StartConversation(CONVCB * convptr) <br>{ <br>  convptr-&gt;ConvStarted = GetTickCount(); <br>} <br> <br>/*****************************************************************************/ <br>/* EndConversation - Calculate elapsed time for this conversation            */ <br>/*****************************************************************************/ <br>void EndConversation(CONVCB * convptr) <br>{ <br>  if (ResultPtr != NULL) <br>  { <br>    /*************************************************************************/ <br>    /* Make sure we don't go over the end of the allocated area              */ <br>    /*************************************************************************/ <br>    if (NumResults &lt; NumRcvConvs) <br>    { <br>      *ResultPtr++ = (GetTickCount() - convptr-&gt;ConvStarted); <br>      NumResults++; <br>    } <br>    else <br>    { <br>      SRTRACE(t,"Thread %d:%d Too many calls to EndConversation\n", <br>              convptr-&gt;thread,convptr-&gt;conv); <br>    } <br>  } <br>} <br> <br>/*****************************************************************************/ <br>/* OutputResults - dump the times of conversations to file                   */ <br>/*****************************************************************************/ <br>void OutputResults() <br>{ <br>  FILE *h = NULL; <br>  RESULT * ptr = NULL; <br>  unsigned short i = 0; <br> <br>  h = fopen(FileName,"w"); <br>  if (h != NULL) <br>  { <br>    fprintf(h,"\nMRCV Results\n------------\n\n"); <br>    CONV_E_TO_A(LocalTPName,64); <br>    fprintf(h,"Local TP Name              = %.64s\n",LocalTPName); <br>    CONV_E_TO_A(RemoteTPName,64); <br>    fprintf(h,"Remote TP Name             = %.64s\n",RemoteTPName); <br>    fprintf(h,"Local LU Alias             = %.8s\n",LocalLUAlias); <br>    fprintf(h,"Remote LU Alias            = %.8s\n",RemoteLUAlias); <br>    CONV_E_TO_A(ModeName,8); <br>    fprintf(h,"ModeName                   = %.8s\n",ModeName); <br>    fprintf(h,"No. of receive threads     = %d\n",NumRcvThreads); <br>    fprintf(h,"No. of rcv convs started   = %d\n",NumRalcs); <br>    fprintf(h,"No. of rcv convs completed = %d\n",RcvConvs); <br>    fprintf(h,"\n"); <br> <br>    ptr = ResultBuf; <br>    while (ptr &lt; ResultPtr) <br>    { <br>      fprintf(h,"Conversation number %d, time = %.3f seconds\n",i++, <br>                                                (((float) *ptr++) / 1000.0 )); <br>    } <br>    fclose(h); <br>  } <br>} <br> <br>/*****************************************************************************/ <br>/* ReadString - Get a line of text from the config file                      */ <br>/*****************************************************************************/ <br>int ReadString(char * lpValueName,char * lpData, int maxlen) <br>{ <br>  char       buffer[200]; <br>  char      *p = NULL; <br>  FILE      *h = NULL; <br>  BOOL       match = FALSE; <br>  BOOL       eof   = FALSE; <br>  int        rc = 0; <br>  int        ch = 0; <br>  int        i = 0; <br>  BOOL       gotdata = FALSE; <br>  char       separators[] = " =\t\n"; <br> <br>  GetModuleFileName( hInst, buffer, sizeof(buffer) ); <br>  lstrcpy( buffer+lstrlen(buffer) - 4, ".CFG" ); <br>  h = fopen( buffer, "r" ); <br>  buffer[0] = '\0'; <br> <br>  if (h != NULL) <br>  { <br>    while ((!match) &amp;&amp; (!eof)) <br>    { <br>      /***********************************************************************/ <br>      /* Use fgetc to read a line of text from the file                      */ <br>      /***********************************************************************/ <br>      for (i=0; (i&lt;sizeof(buffer))     &amp;&amp; <br>                ((ch=getc(h)) != EOF)  &amp;&amp; <br>                ((char)ch != '\n'); <br>                                   i++) <br>      { <br>        buffer[i] = (char)ch; <br>      } <br>      if ((char)ch == '\n') <br>      { <br>        buffer[i++] = (char)ch; <br>      } <br>      if (ch == EOF) <br>      { <br>        eof = TRUE; <br>      } <br>      else <br>      { <br>        /*********************************************************************/ <br>        /* Compare the first token in the line read with the requested parm  */ <br>        /*********************************************************************/ <br>        if (!strcmpi(strupr(strtok(buffer, separators)), lpValueName)) <br>        { <br>          match = TRUE; <br>          /*******************************************************************/ <br>          /* Get a pointer to the second token (the value we want)           */ <br>          /*******************************************************************/ <br>          p = strtok(NULL, separators); <br> <br>          /*******************************************************************/ <br>          /* Copy the data IF there is some                                  */ <br>          /*******************************************************************/ <br>          if (p != NULL) <br>          { <br>            /*****************************************************************/ <br>            /* Force a NULL after the second token                           */ <br>            /*****************************************************************/ <br>            strtok(NULL, separators); <br> <br>            /*****************************************************************/ <br>            /* Copy the data                                                 */ <br>            /*****************************************************************/ <br>            strncpy(lpData, p, maxlen); <br>            gotdata = TRUE; <br>          } <br>          else <br>          { <br>            gotdata = FALSE; <br>          } <br>        } <br>      } <br>    } <br> <br>    if (gotdata) <br>    { <br>      rc = 1; <br>    } <br> <br>    fclose(h); <br> <br>  } <br> <br>  return(rc); <br>} <br> <br>/*****************************************************************************/ <br>/* PadString - Remove terminating NULL  and pad on the right with spaces     */ <br>/*****************************************************************************/ <br>void PadString(char * string,int length) <br>{ <br>  char * p; <br>  if ((p=memchr(string,'\0',length)) != NULL) <br>  { <br>    while (p &lt; string+length) <br>    { <br>      *p++=' '; <br>    } <br>  } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
