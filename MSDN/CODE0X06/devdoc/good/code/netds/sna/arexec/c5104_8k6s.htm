<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AREXEC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5104"></a>AREXEC.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  MODULE NAME : AREXEC.C <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:    Peter J. Schwaller <br> *             VNET:     PJS at RALVM6           Tie Line: 444-4376 <br> *             Internet: pjs@ralvm6.vnet.ibm.com     (919) 254-4376 <br> * <br> *  FUNCTION:  Execute a command on a remote workstation and display the <br> *             output from the command (both stdout and stderr) on the <br> *             requesting workstation. <br> * <br> *  Usage: <br> *      AREXEC destination command <br> * <br> *    Destination may be either a partner LU alias (up to eight <br> *    characters) or a fully qualified LU name (3-17 characters separated <br> *    by a period) <br> * <br> *  AVAILABILITY: <br> *             These sample programs and source are also available on <br> *             CompuServe through the APPC Information Exchange.  To get <br> *             to the APPC forum just type 'GO APPC' from any CompuServe <br> *             prompt.  The samples are available in the Sample Programs <br> *             library section.  Just search on the keyword CPICPGMS to <br> *             find all the samples in this series. <br> * <br> *             Updates for the sample programs and support for many more <br> *             CPI-C platforms will also be made available on CompuServe. <br> * <br> *  RELATED FILES: <br> *             See AREXEC.DOC for usage instructions. <br> * <br> *  CHANGE HISTORY: <br> *  Date       Description <br> *  06/15/92   NS/DOS accepts version 2.02 into system test. <br> *  08/05/92   Version 2.31 released to CompuServe <br> *             This version was also distributed at the APPC/APPN Platform <br> *             Developer's Conference held in Raleigh, NC. <br> *  08/13/92   Changed all printf and fprintf calls to use a write_*() call. <br> *  08/17/92   Made security handling code conditionally compiled. <br> *  08/23/92   Removed call to cpicinit_default_destination(). <br> *  08/24/92   Version 2.32 released to CompuServe. <br> *  09/22/92   Version 2.33 released to CompuServe. <br> *  11/17/92   Added support for printing remote operating system name. <br> *             Version 2.34 released to CompuServe <br> *  01/07/93   Version 2.35 <br> *             Fixed a number of problems when compiling with IBM C Set/2 <br> *                password input was displayed <br> *                timer resolution was 1 second <br> * <br> *****************************************************************************/ <br> <br>/***************************************************************************** <br> * OVERVIEW of AREXEC CPI-C Flows <br> * <br> *   Client (AREXEC)                     Server (AREXECD) <br> *   --------------                      --------------- <br> * Set up conversation <br> *   Allocate       -------------------&gt; Accept Conversation <br> * Exchange Version Numbers <br> *   Send Data      -------------------&gt; Receive <br> *   Receive        &lt;------------------- Send Data <br> * Send the Command <br> *   Send Data      -------------------&gt; Receive <br> * Receive the Output <br> * --&gt;                                           &lt;-- <br> * | Receive        &lt;------------------- Send Data |     LOOP <br> * ---                                           --- <br> * Command is finished <br> * Receive          &lt;------------------- Deallocate(FLUSH) <br> *****************************************************************************/ <br> <br>#if defined(WINDOWS)||defined(WIN32) <br>#include &lt;windows.h&gt; <br>#endif <br>#include "wincpic.h" <br> <br>/* standard C include files */ <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>/* Set up constant declarations */ <br>#include "cpicdefs.h" <br> <br>/* Collection of routines with special ported version for each platform */ <br>#include "cpicport.h" <br> <br>/* CPI-C error handling routines */ <br>/* This file is supplied with AREXEC */ <br>#include "cpicerrs.h" <br> <br>/* Argument processing procedure */ <br>/* This file is supplied with AREXEC */ <br>#include "getopt.h" <br> <br>/* CPI-C initialization routines */ <br>/* This file is supplied with AREXEC */ <br>#include "cpicinit.h" <br> <br>#define  MAX_COMMAND_LENGTH   500 <br> <br>/* CPI-C error handling info */ <br>CPICERR * cpicerr; <br> <br>/* These are the defaults to be used if the user does not provide arguments  */ <br>/* to override these values.                                                 */ <br>#define  DEFAULT_TP_NAME   "AREXECD" <br>#define  DEFAULT_MODE_NAME "#INTER" <br>#define  DEFAULT_SYM_DEST  "AREXECD" <br> <br>/* Define these here so we can make changes throughout the code. */ <br>/* <br> * The PROGRAM_INFO string should be kept in sync with the <br> * MAJOR_VERSION and MINOR_VERSION constants.  Although the <br> * cpicerr_exchange_version() call will support values up to 255, <br> * values for MINOR_VERSION should be from 00-99 to maintain the <br> * two character format in the version string. <br> */ <br>#define  PROGRAM_NAME      "AREXEC" <br>#define  PROGRAM_INFO      "version 2.35" <br>#define  MAJOR_VERSION     (2) <br>#define  MINOR_VERSION     (35) <br>#define  LOG_FILE_NAME     "arexec.err" <br>#define  LOG_FILE_PATH     "$LOGPATH" <br> <br>/* local structure definition */ <br>typedef struct command_info { <br>    char        buffer[MAX_COMMAND_LENGTH]; <br>    CM_INT32    buffer_length; <br>} COMMAND_INFO; <br> <br>/* local function prototypes */ <br>void process_arguments(int argc, <br>                       char *argv[], <br>                       CPICINIT * cpicinit, <br>                       COMMAND_INFO * command_info); <br> <br>/* <br> * Message displayed with show_info() when APING is started. <br> */ <br>char * intro[] = { <br>    PROGRAM_NAME " " PROGRAM_INFO " - Execute a remote command.", <br>    "  by Peter J. Schwaller (pjs@ralvm6.vnet.ibm.com)", <br>    NULL <br>    }; <br> <br>/* <br> * Message displayed with show_info() when AREXEC is started. <br> */ <br>char * usage[] = { <br>    "", <br>    "Usage:", <br>    "AREXEC [flags] destination command", <br>    "Flags:", <br>    "  destination", <br>    "\tmay be either a symbolic destination name or a partner LU name", <br>    "  command", <br>    "\tcommand string to be executed on the remote machine", <br>    "  -m mode_name", <br>    "\tMode name (default: " DEFAULT_MODE_NAME ")", <br>    "  -t tp_name", <br>#if defined(SUPPORTS_SETTING_SECURITY) <br>    "\tthe TP to use on the allocate (default: " DEFAULT_TP_NAME ")", <br>    "  -u userid", <br>    "  -p password", <br>    "\tSecurity parameters.  If a userid is specified without a password,", <br>    "\tyou will be prompted for the password.", <br>    "  -n", <br>    "\tDo not use any security (SECURITY=NONE).", <br>#endif <br>    NULL <br>    }; <br> <br> <br>void _cdecl <br>main( int argc, char *argv[]) <br>{ <br>    /* Variables used for CPI-C calls */ <br>    unsigned char cm_conv_id[8];            /* CPI-C conversation ID         */ <br>    CM_INT32     cm_rc;                     /* CPI-C return code             */ <br>    CM_INT32     rts_received;              /* request to send received      */ <br>    CM_INT32     max_receive_len;           /* Max receive length on CMRCV   */ <br>    CM_INT32     what_received;             /* What received parm from CMRCV */ <br>    CM_INT32     received_len;              /* Amount of data rcvd on CMRCV  */ <br>    CM_INT32     status_received;           /* Status from CMRCV             */ <br> <br>    /* Destination information */ <br>    CPICINIT *   cpicinit; <br> <br>    char         partner_major_version; <br>    char         partner_minor_version; <br>    char         opsys_string[64]; <br> <br>#if defined(WINDOWS) || defined(WIN32) <br>    unsigned short WinCPICVersion = 0x0001; <br>    WCPICDATA CPICData; <br>#endif <br> <br>    COMMAND_INFO command_info; <br> <br>    /* <br>     * Make sure all output is seen as soon as possible. <br>     */ <br>    setbuf(stdout, NULL); <br> <br>    show_info(intro);                       /* Show program information      */ <br> <br>#if (defined(WIN32) || defined(WINDOWS))                              /*WIN32*/ <br>       /****************************************************************WIN32*/ <br>       /* Initialisation for WinCPIC                                   *WIN32*/ <br>       /****************************************************************WIN32*/ <br>    if (WinCPICStartup(WinCPICVersion,&amp;CPICData))                     /*WIN32*/ <br>    {                                                                 /*WIN32*/ <br>       return;                                                        /*WIN32*/ <br>    }                                                                 /*WIN32*/ <br>#endif                                                                /*WIN32*/ <br> <br>    /* <br>     * Create a new CPICINIT structure and initialize values. <br>     * The procedures are in CPICINIT.C <br>     */ <br>    cpicinit = cpicinit_new(); <br>    cpicinit_default_tp_name(cpicinit, DEFAULT_TP_NAME); <br>    cpicinit_default_mode_name(cpicinit, DEFAULT_MODE_NAME); <br>    cpicinit_default_sym_dest_name(cpicinit, DEFAULT_SYM_DEST); <br> <br> <br>    /* <br>     * Process all of the command line arguments.  All of the conversation <br>     * setup arguments are stored in the cpicinit object.  The command <br>     * to be sent is returned in the buffer variable within command_info. <br>     */ <br>    process_arguments(argc, argv, cpicinit, &amp;command_info); <br> <br>    if (cpicinit_query_password_needed(cpicinit)) { <br>        /* get a password from the user */ <br>        cpicinit_get_password(cpicinit); <br>    } <br> <br>    /* <br>     * Initialize the CPICERR structure.  This is done before the CMINIT <br>     * call so that we can use CPICERR for help with errors on CMINIT. <br>     * The procedure is in CPICERR.C <br>     */ <br>    cpicerr = cpicerr_new(); <br>    cpicerr_set_program_name(cpicerr, PROGRAM_NAME); <br>    cpicerr_set_program_info(cpicerr, PROGRAM_INFO); <br>    cpicerr_set_major_version(cpicerr, MAJOR_VERSION); <br>    cpicerr_set_minor_version(cpicerr, MINOR_VERSION); <br>    cpicerr_set_log_file_name(cpicerr, LOG_FILE_NAME); <br>    cpicerr_set_log_file_path(cpicerr, LOG_FILE_PATH); <br> <br>    cpicinit_setup_conversation(cpicinit, cm_conv_id, cpicerr); <br> <br>    { <br>    CM_SYNC_LEVEL sync_level = CM_CONFIRM; <br>    cmssl(cm_conv_id,                        /* Set sync level               */ <br>          &amp;sync_level, <br>          &amp;cm_rc); <br>    } <br> <br>    cmallc(cm_conv_id,                       /* Allocate the conversation    */ <br>           &amp;cm_rc); <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMALLC, cm_rc); <br> <br>    cpicerr_exchange_version_plus(cpicerr, <br>                                  cm_conv_id, <br>                                  CM_SEND_STATE, <br>                                  &amp;partner_major_version, <br>                                  &amp;partner_minor_version, <br>                                  opsys_string, <br>                                  sizeof(opsys_string)); <br>    /* <br>     * Display the operating system string returned in the exchange. <br>     * The string length will be 0 if the operating system string <br>     * wasn't available. <br>     */ <br> <br>    if (strlen(opsys_string) != 0) { <br>        write_output("\nConnected to a partner running on: %s\n", <br>                     opsys_string); <br>    } <br> <br>    convert_to_ascii(command_info.buffer, command_info.buffer_length); <br>    cmsend(cm_conv_id,                     /* Send Data                      */ <br>           (unsigned char *)command_info.buffer, /* data pointer             */ <br>           &amp;command_info.buffer_length,    /* length of data sent            */ <br>           &amp;rts_received,                  /* request to send indicator      */ <br>           &amp;cm_rc); <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br> <br>    max_receive_len = sizeof(command_info.buffer); <br>    do { <br>        cmrcv(cm_conv_id,                   /* Receive Data                  */ <br>              (unsigned char *)command_info.buffer, /* Data Pointer          */ <br>              &amp;max_receive_len,             /* Size of Data Buffer           */ <br>              &amp;what_received,               /* returned - what received      */ <br>              &amp;received_len,                /* returned - length of data     */ <br>              &amp;status_received,             /* returned - status received    */ <br>              &amp;rts_received,                /* returned - request to send    */ <br>              &amp;cm_rc); <br> <br>       if (what_received != CM_NO_DATA_RECEIVED &amp;&amp; <br>            (cm_rc == CM_OK || cm_rc == CM_DEALLOCATED_NORMAL)) { <br>                                            /* Write the received data       */ <br>            convert_from_ascii(command_info.buffer, received_len); <br>            fwrite(command_info.buffer, 1, (unsigned int)received_len, stdout); <br>       } <br> <br>    } while ( !cm_rc ); <br> <br>    if (cm_rc != CM_DEALLOCATED_NORMAL) { <br>        cpicerr_handle_rc(cpicerr, MSG_CMRCV, cm_rc); <br>    } <br> <br>    /* destroy the object we created with cpicinit_new() */ <br>    cpicinit_destroy(cpicinit); <br> <br>    /* destroy the object we created with cpicerr_new() */ <br>    cpicerr_destroy(cpicerr); <br> <br>    exit(EXIT_SUCCESS); <br>} <br> <br> <br>void <br>process_arguments(int argc, <br>                  char *argv[], <br>                  CPICINIT * cpicinit, <br>                  COMMAND_INFO * command_info) <br>{ <br>    int         set_destination = 0; <br>    int         c;                          /* flag specifed, used w/getopt  */ <br> <br>    command_info -&gt; buffer_length = 0; <br>    command_info -&gt; buffer[0] = '\0'; <br> <br>    while (optind != argc) { <br>        c = getopt(argc, argv, "?t:m:u:p:T:M:U:P:Nn"); <br>        switch (c) { <br>        case EOF: <br>            if (set_destination == 0) { <br>                set_destination = 1; <br>                optarg = argv[optind]; <br>                if (optarg[0] == '?') { <br>                   show_info(usage); <br>                   exit(EXIT_FAILURE); <br>                } <br>                optind++; <br>                cpicinit_set_destination(cpicinit, optarg); <br>            } else { <br>                command_info -&gt; buffer[0] = '\0'; <br>                for ( ; optind&lt;argc ; optind++ ) { <br>                    command_info -&gt; buffer_length += strlen(argv[optind])+1; <br>                    if (command_info-&gt;buffer_length &lt; MAX_COMMAND_LENGTH) { <br>                        strcat(command_info-&gt;buffer, argv[optind]); <br>                        strcat(command_info-&gt;buffer, " "); <br>                    } else { <br>                        write_error( <br>                                "Command length exceeds max allowed (%d).\n", <br>                                MAX_COMMAND_LENGTH-1); <br>                        write_error( <br>                                "No command will be sent.\n"); <br>                        exit(EXIT_FAILURE); <br>                    } <br>                } <br>            } <br>            break; <br>        case 'M': <br>        case 'm': <br>            cpicinit_set_mode_name(cpicinit, optarg); <br>            break; <br>        case 'T': <br>        case 't': <br>            cpicinit_set_tp_name(cpicinit,optarg); <br>            break; <br>#if defined(SUPPORTS_SETTING_SECURITY) <br>        case 'U': <br>        case 'u': <br>            cpicinit_set_userid(cpicinit, optarg); <br>            break; <br>        case 'P': <br>        case 'p': <br>            cpicinit_set_password(cpicinit, optarg); <br>            break; <br>        case 'N': <br>        case 'n': <br>            cpicinit_set_security_type(cpicinit, CM_SECURITY_NONE); <br>            break; <br>#endif <br>        case '?': <br>            show_info(usage); <br>            exit(EXIT_FAILURE); <br>            break; <br>        default: <br>            write_output("Invalid flag.  Use AREXEC -? for usage\n"); <br>            exit(EXIT_FAILURE); <br>        } <br>    } <br>    if (!(set_destination &amp;&amp; command_info-&gt;buffer_length)) { <br>        write_error( <br>                "You must specify at least a destination and a command.\n"); <br>        show_info(usage); <br>        exit(EXIT_FAILURE); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
