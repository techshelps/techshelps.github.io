<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AREXECD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5105"></a>AREXECD.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  MODULE NAME : AREXECD.C <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:    Peter J. Schwaller <br> *             VNET:     PJS at RALVM6           Tie Line: 444-4376 <br> *             Internet: pjs@ralvm6.vnet.ibm.com     (919) 254-4376 <br> * <br> *  FUNCTION:  This module is the server side of AREXEC.  This module <br> *             will execute a specified command and route the output <br> *             back to the AREXEC transaction program. <br> * <br> *  AVAILABILITY: <br> *             These sample programs and source are also available on <br> *             CompuServe through the APPC Information Exchange.  To get <br> *             to the APPC forum just type 'GO APPC' from any CompuServe <br> *             prompt.  The samples are available in the Sample Programs <br> *             library section.  Just search on the keyword CPICPGMS to <br> *             find all the samples in this series. <br> * <br> *             Updates for the sample programs and support for many more <br> *             CPI-C platforms will also be made available on CompuServe. <br> * <br> *  RELATED FILES: <br> *             See AREXEC.DOC for usage instructions. <br> * <br> *  CHANGE HISTORY: <br> *  Date       Description <br> *  06/15/92   NS/DOS accepts version 2.02 into system test. <br> *  08/05/92   Version 2.31 released to CompuServe <br> *             This version was also distributed at the APPC/APPN Platform <br> *             Developer's Conference held in Raleigh, NC. <br> *  08/13/92   Changed all printf and fprintf calls to use a write_*() call. <br> *  08/24/92   Version 2.32 released to CompuServe. <br> *  09/22/92   Version 2.33 released to CompuServe. <br> *  11/17/92   Supports sending operating system string - see CPICERR.C <br> *             Version 2.34 released to CompuServe <br> *  01/07/93   Version 2.35 <br> *             Fixed a number of problems when compiling with IBM C Set/2 <br> *                password input was displayed <br> *                timer resolution was 1 second <br> *                arexecd server did not function properly <br> * <br> *****************************************************************************/ <br> <br>#ifdef WIN32                                                           /*WIN32*/ <br>#include &lt;windows.h&gt;                                                   /*WIN32*/ <br>SERVICE_STATUS_HANDLE stat_hand;                                       /*WIN32*/ <br>SERVICE_STATUS servstat;                                               /*WIN32*/ <br>#endif                                                                 /*WIN32*/ <br> <br>#include "wincpic.h" <br> <br>/* standard C include files */ <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stddef.h&gt; <br> <br>/* Set up constant declarations */ <br>#include "cpicdefs.h" <br> <br>/* Collection of routines with special ported version for each platform */ <br>#include "cpicport.h" <br> <br>#define  MAX_COMMAND_LENGTH   500 <br> <br>/*--------------------------------------------------------------------------*/ <br>/*      CPI-C Error Handling Global Variables                               */ <br>/*--------------------------------------------------------------------------*/ <br>#include "cpicerrs.h"                        /* CPI-C error handling vars.   */ <br>CPICERR * cpicerr; <br> <br>/* Define these here so we can make changes throughout the code. */ <br>/* <br> * The PROGRAM_INFO string should be kept in sync with the <br> * MAJOR_VERSION and MINOR_VERSION constants.  Although the <br> * cpicerr_exchange_version() call will support values up to 255, <br> * values for MINOR_VERSION should be from 00-99 to maintain the <br> * two character format in the version string. <br> */ <br>#define  PROGRAM_NAME      "AREXECD" <br>#define  PROGRAM_INFO      "version 2.35" <br>#define  MAJOR_VERSION     (2) <br>#define  MINOR_VERSION     (35) <br>#define  LOG_FILE_NAME     "arexecd.err" <br>#define  LOG_FILE_PATH     "$LOGPATH" <br> <br> <br>char * intro[] = { <br>    PROGRAM_NAME " " PROGRAM_INFO " - Remote execution of a command. (Server)", <br>    NULL <br>    }; <br> <br> <br>void <br>TPStart(void) <br>{ <br>    /* Variables used for CPI-C calls */ <br>    unsigned char cm_conv_id[8];            /* CPI-C conversation ID         */ <br>    CM_INT32    temp;                                                 /*WIN32*/ <br>    CM_INT32    cm_rc;                      /* CPI-C return code             */ <br>    CM_INT32    length;                     /* generic length variable       */ <br>    CM_INT32    rts_received;               /* request to send received      */ <br>    CM_INT32    max_receive_len;            /* Max receive length on CMRCV   */ <br>    CM_INT32    what_received;              /* What received parm from CMRCV */ <br>    CM_INT32    received_len;               /* Amount of data rcvd on CMRCV  */ <br>    CM_INT32    status_received;            /* Status from CMRCV             */ <br> <br>    /* Data buffer for send and receive */ <br>    char        buffer[MAX_COMMAND_LENGTH]; /* CPIC data buffer              */ <br> <br>    char partner_major_version; <br>    char partner_minor_version; <br> <br>    unsigned char destination[MAX_FQPLU_NAME]; <br> <br>    show_info(intro); <br> <br>#ifdef WIN32 <br>    { <br>       /**********************************************************************/ <br>       /* Initialisation for WinCPIC                                         */ <br>       /**********************************************************************/ <br>       unsigned short WinCPICVERSION = 0x0001; <br>       WCPICDATA CPICData; <br>       if (WinCPICStartup(WinCPICVERSION,&amp;CPICData)) <br>       { <br>         return; <br>       } <br>       /**********************************************************************/ <br>       /* Set our local TP Name                                              */ <br>       /**********************************************************************/ <br>       temp=7; <br>       cmsltp("AREXECD",&amp;temp,&amp;cm_rc); <br>    } <br>#endif <br> <br>    /* <br>     * Initialize the CPICERR structure.  This is done before the CMINIT <br>     * call so that we can use CPICERR for help with errors on CMINIT. <br>     * The procedure is in CPICERR.C <br>     */ <br>    cpicerr = cpicerr_new(); <br>    cpicerr_set_program_name(cpicerr, PROGRAM_NAME); <br>    cpicerr_set_program_info(cpicerr, PROGRAM_INFO); <br>    cpicerr_set_major_version(cpicerr, MAJOR_VERSION); <br>    cpicerr_set_minor_version(cpicerr, MINOR_VERSION); <br>    cpicerr_set_log_file_name(cpicerr, LOG_FILE_NAME); <br>    cpicerr_set_log_file_path(cpicerr, LOG_FILE_PATH); <br> <br>    cmaccp(cm_conv_id, <br>           &amp;cm_rc); <br>    /* <br>     * Note that as we have used cmsltp to specify our local TP name, <br>     * cmaccp may return asynchronously, so we must do a cmwait <br>     */ <br>    if (cm_rc == CM_OPERATION_INCOMPLETE)                             /*WIN32*/ <br>    {                                                                 /*WIN32*/ <br>      cmwait(cm_conv_id, &amp;cm_rc, &amp;temp);                              /*WIN32*/ <br>    }                                                                 /*WIN32*/ <br> <br>   /*------------------------------------------------------------------------* <br>    * Fill in conversation information for CPI-C error reporting. <br>    *------------------------------------------------------------------------*/ <br>    cpicerr_set_conv_id(cpicerr, cm_conv_id); <br> <br>    if (cm_rc != CM_OK) { <br>        cpicerr_handle_rc(cpicerr, MSG_CMACCP, cm_rc); <br>    } else { <br>        length = 17; <br>        cmepln(cm_conv_id, <br>               destination, <br>               &amp;length, <br>               &amp;cm_rc ); <br>        destination[(unsigned int)length] = '\0'; <br>        write_output("\nContacted by partner: "); <br>        write_output("%s", destination); <br>        write_output("\n"); <br>    } <br> <br>    cpicerr_exchange_version(cpicerr, <br>                             cm_conv_id, <br>                             CM_RECEIVE_STATE, <br>                             &amp;partner_major_version, <br>                             &amp;partner_minor_version); <br> <br>    { <br>    CM_SEND_TYPE send_type = CM_SEND_AND_FLUSH; <br>    cmsst(cm_conv_id,                       /* Set send type                 */ <br>          &amp;send_type, <br>          &amp;cm_rc); <br>    } <br> <br>    max_receive_len = MAX_COMMAND_LENGTH-1; <br> <br>    cmrcv(cm_conv_id,                       /* Receive Data                  */ <br>          (unsigned char *) buffer,         /* Data Pointer                  */ <br>          &amp;max_receive_len,                 /* Size of Data Buffer           */ <br>          &amp;what_received,                   /* returned - what received      */ <br>          &amp;received_len,                    /* returned - length of data     */ <br>          &amp;status_received,                 /* returned - status received    */ <br>          &amp;rts_received,                    /* returned - request to send    */ <br>          &amp;cm_rc); <br> <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMRCV, cm_rc); <br> <br>    buffer[(unsigned int)received_len] = '\0'; <br> <br>    convert_from_ascii(buffer, strlen(buffer)); <br> <br>    write_output("The command is:\n%s\n\n", buffer); <br> <br>    execute_and_send_output(buffer, <br>                            cm_conv_id, <br>                            cpicerr); <br> <br>    { <br>    CM_DEALLOCATE_TYPE deallocate_type = CM_DEALLOCATE_FLUSH; <br> <br>    cmsdt(cm_conv_id, <br>          &amp;deallocate_type, <br>          &amp;cm_rc); <br>    } <br> <br>    cmdeal(cm_conv_id, <br>           &amp;cm_rc); <br>    if (cm_rc) cpicerr_handle_rc(cpicerr, MSG_CMDEAL, cm_rc); <br> <br>    /* destroy the object we created with cpicerr_new() */ <br>    cpicerr_destroy(cpicerr); <br> <br>    exit(EXIT_SUCCESS); <br> <br>} <br> <br>#ifdef WIN32 <br>/*****************************************************************************/ <br>/* The following code makes this TP invokable as an NT service. There are 3  */ <br>/* routines.                                                                 */ <br>/*                                                                           */ <br>/* 1. main. This is the entry point for the process, it sets up a service    */ <br>/*          table entry and then calls StartServiceCtrlDispatcher. This call */ <br>/*          doesn't return, but uses the thread which called it as a         */ <br>/*          control dispatcher for all the services implemented by this      */ <br>/*          process (in this case, just the TP itself).                      */ <br>/*                                                                           */ <br>/* 2. ServiceMain. This is the main entry point for the service itself, the  */ <br>/*          service control dispatcher creates a thread to start at this     */ <br>/*          routine. It must register a service control handler for the      */ <br>/*          service which will be called by the control dispatcher when it   */ <br>/*          has control instructions for the service. It then informs the    */ <br>/*          service control manager that the service is running and finally  */ <br>/*          calls the start of the TP itself. This routine should not return */ <br>/*          until the service is ready to die.                               */ <br>/*                                                                           */ <br>/* 3. ControlHandler. This routine is called by the control dispatcher when  */ <br>/*          it has instructions for the service. We do not respond to any    */ <br>/*          of the instructions as this service should be transitory and not */ <br>/*          actually run for more than a few seconds so we don't need to do  */ <br>/*          anything with the STOP or SHUTDOWN requests.                     */ <br>/*          Note that we MUST call SetServiceStatus, even if the status      */ <br>/*          hasn't changed.                                                  */ <br>/*****************************************************************************/ <br> <br>void __cdecl main( DWORD argc, LPSTR * argv); <br>void WINAPI ServiceMain(DWORD dwNumServiceArgs, LPTSTR * lpServiceArgs); <br>VOID WINAPI ControlHandler(DWORD dwControl); <br>SERVICE_STATUS_HANDLE stat_hand; <br>SERVICE_STATUS servstat; <br> <br>void __cdecl main( DWORD argc, LPSTR * argv) <br>{ <br>  SERVICE_TABLE_ENTRY  stab[2]; <br> <br>  /***************************************************************************/ <br>  /* Start the control dispatcher. This call gives the SCManager this        */ <br>  /* thread for the entire period that this service is running, so that it   */ <br>  /* can call us back with service controls. It will spawn a new thread to   */ <br>  /* run the service itself, starting at entrypoint ServiceMain.             */ <br>  /***************************************************************************/ <br>  stab[0].lpServiceName = "AREXECD\0"; <br>  stab[0].lpServiceProc = ServiceMain; <br> <br>  stab[1].lpServiceName = NULL; <br>  stab[1].lpServiceProc = NULL; <br> <br>  StartServiceCtrlDispatcher(stab); <br> <br>} <br> <br> <br>/*****************************************************************************/ <br>/* This routine is the entry-point for the service itself the service        */ <br>/* control dispatcher creates a thread to start here when we issue           */ <br>/* StartServiceControlDispatcher.                                            */ <br>/*                                                                           */ <br>/* Inputs:  number of arguments to services, array of strings.               */ <br>/*                                                                           */ <br>/* Outputs: none                                                             */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>void WINAPI ServiceMain(DWORD dwNumServiceArgs, LPTSTR * lpServiceArgs) <br>{ <br> <br>  DWORD rc; <br> <br>  stat_hand = RegisterServiceCtrlHandler("AREXECD\0", ControlHandler); <br>  if (stat_hand == (SERVICE_STATUS_HANDLE)NULL) <br>  { <br>    rc = GetLastError(); <br>    DebugBreak(); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Let the SCManager know that we are running.                             */ <br>  /***************************************************************************/ <br>  servstat.dwServiceType              = SERVICE_WIN32; <br>  servstat.dwCurrentState             = SERVICE_RUNNING; <br>  servstat.dwControlsAccepted         = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN; <br>  servstat.dwWin32ExitCode            = NO_ERROR; <br>  servstat.dwServiceSpecificExitCode  = NO_ERROR; <br>  servstat.dwCheckPoint               = 0; <br>  servstat.dwWaitHint                 = 0; <br> <br>  rc = SetServiceStatus(stat_hand, &amp;servstat); <br>  if (!rc) <br>  { <br>     rc = GetLastError(); <br>     DebugBreak(); <br>  } <br> <br>  TPStart(); <br> <br>} <br> <br>/*****************************************************************************/ <br>/* This routine is the callback from the SCManager to handle specific        */ <br>/* service control requests. It MUST call SetServiceStatus before it         */ <br>/* returns, regardless of whether the status has changed.                    */ <br>/*                                                                           */ <br>/* Inputs: service control requested                                         */ <br>/*                                                                           */ <br>/* Outputs: none                                                             */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>VOID WINAPI ControlHandler(DWORD dwControl) <br>{ <br>  DWORD rc; <br> <br>  switch (dwControl) <br>  { <br>    case SERVICE_CONTROL_STOP : <br>      servstat.dwCurrentState = SERVICE_STOP_PENDING; <br>      servstat.dwWaitHint     = 24000; <br>      break; <br> <br>    case SERVICE_CONTROL_PAUSE : <br>    case SERVICE_CONTROL_CONTINUE : <br>    case SERVICE_CONTROL_INTERROGATE : <br>      servstat.dwWaitHint     = 0; <br>      break; <br> <br> case SERVICE_CONTROL_SHUTDOWN: <br>      servstat.dwCurrentState = SERVICE_STOP_PENDING; <br>      servstat.dwWaitHint     = 10000; <br>break; <br>  } <br> <br>  rc=SetServiceStatus(stat_hand, &amp;servstat); <br>  if (!rc) <br>  { <br>     rc=GetLastError(); <br>  } <br> <br>} <br> <br>#endif <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
