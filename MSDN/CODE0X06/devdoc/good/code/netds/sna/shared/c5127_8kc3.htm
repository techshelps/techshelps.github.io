<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPICPORT.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5133"></a>CPICPORT.H</h2>
<pre><code>/***************************************************************************** <br> * <br> *  MODULE NAME: CPICPORT.H <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:    Peter J. Schwaller <br> *             VNET:     PJS at RALVM6           Tie Line: 444-4376 <br> *             Internet: pjs@ralvm6.vnet.ibm.com     (919) 254-4376 <br> * <br> *  AVAILABILITY: <br> *             These sample programs and source are also available on <br> *             CompuServe through the APPC Information Exchange.  To get <br> *             to the APPC forum just type 'GO APPC' from any CompuServe <br> *             prompt.  The samples are available in the Sample Programs <br> *             library section.  Just search on the keyword CPICPGMS to <br> *             find all the samples in this series. <br> * <br> *             Updates for the sample programs and support for many more <br> *             CPI-C platforms will also be made available on CompuServe. <br> * <br> *  RELATED FILES: <br> *             Used by CPICPORT.C <br> * <br> *  CHANGE HISTORY: <br> *  Date       Description <br> *  08/05/92   Version 2.31 of APING, ATELL and AREXEC released to CompuServe. <br> *             This version was also distributed at the APPC/APPN Platform <br> *             Developer's Conference held in Raleigh, NC. <br> *  08/13/92   Added the write_*() calls. <br> *             Changed all printf and fprintf calls to use a write_*() call. <br> * <br> *****************************************************************************/ <br> <br>#ifndef INCL_CPICPORT <br>#define INCL_CPICPORT <br> <br>/* <br> * This file contains all of the non-portable code for the CPI-C toolkit. <br> * Conditional compilation directives determine what code will be compiled <br> * for which platform.  The following constants have been established <br> * to identify the supported platforms: <br> *    DOS   - Networking Services/DOS <br> *    OS2   - Extended Services for OS/2 <br> *    FAPI  - Compiling for both DOS and OS2 <br> *    AIX   - SNA Services <br> *    OS400 - OS/400 (for the AS/400) <br> *    MVS   - MVS ESA 4.2 or greater <br> *    VM    - VM/CMS ESA 1.0 or greater <br> *    WIN32 - Windows NT v3.1 <br> *    WINDOWS - Windows v3.1 <br> * These constants should be defined outside of the source code on <br> * your compiler command line (e.g., cc -DOS2 foo.c). <br> * <br> * If you are porting to another platform, you should only use new constant <br> * if you don't fit into any of the above categories.  To avoid name <br> * conflicts please contact the supplier of this file, indicated above. <br> */ <br> <br> <br>/* <br> * Set up the various constant definitions for: <br> *    EBCDIC_HOST <br> *    BIG_ENDIAN <br> *    SHORT_IDENTIFIERS <br> *    DOES_NOT_NEED_STRUPR <br> *    SUPPORTS_SETTING_SECURITY <br> *    PLN_COULD_REQUIRE_LOWERCASE <br> *    ECS_NOT_SUPPORTED <br> */ <br>#include "cpicdefs.h" <br> <br>/* <br> * Include CPICERRS.H file for the definition of the CPICERR structure. <br> */ <br>#include "cpicerrs.h" <br> <br> <br> <br>#define TIMELENGTH                 26 <br>#define MAX_MESSAGE_LENGTH        (300+1) <br> <br> <br>#ifdef SHORT_IDENTIFIERS <br>/* The C/370 compiler requires that identifier be unique in the 1st 8 chars. */ <br>    #define  ascii_to_ebcdic_field        a2efield <br>    #define  ascii_to_ebcdic_table        a2etab <br>    #define  ebcdic_to_ascii_field        e2afield <br>    #define  ebcdic_to_ascii_table        e2atab <br>#endif <br> <br> <br>#ifdef EBCDIC_HOST <br> <br>#define convert_to_ascii(buffer, len)  ebcdic_to_ascii_field(buffer,len) <br>#define convert_from_ascii(buffer, len) ascii_to_ebcdic_field(buffer,len) <br> <br>#else <br> <br>#define convert_to_ascii(buffer, len) <br>#define convert_from_ascii(buffer, len) <br> <br>#endif <br> <br> <br> <br>/* <br> * If we are on a big endian machine, we will convert the integer format <br> * to little endian before sending the integers.  This is done through <br> * a set of macros to swap the byte order. <br> * <br> * Programs should use the following macros before sending: <br> *   convert_long_to_network     -- 32 bit integers <br> *   convert_short_to_network    -- 16 bit integers <br> * <br> * Programs should use the following macros after receiving: <br> *   convert_long_from_network   -- 32 bit integers <br> *   convert_short_from_network  -- 16 bit integers <br> * <br> * Application code should use these macros before sending or receiving <br> * any integers.  On a big endian platform, the macros will return a <br> * a byte swapping of the integer.  On a little endian platform, <br> * the original integer will be returned unmodified (no-op). <br> */ <br>#ifdef BIG_ENDIAN <br> <br>#define  convert_long_to_network(x)        SWAP4(x) <br>#define  convert_short_to_network(x)       SWAP2(x) <br>#define  convert_long_from_network(x)      SWAP4(x) <br>#define  convert_short_from_network(x)     SWAP2(x) <br> <br>#    ifndef SWAP2 <br>/* Macro SWAP2 swaps the bytes in a two-byte integer         */ <br>#    define SWAP2(s)       (unsigned short)(((s)&lt;&lt;8)|(((s)&amp;0xFF00)&gt;&gt;8)) <br>#    endif <br> <br>#    ifndef SWAP4 <br>/* Macro SWAP4 swaps the bytes in a four-byte integer        */ <br>#    define SWAP4(l)       (unsigned long)(((l)&lt;&lt;24)|(((l)&amp;0xFF000000)&gt;&gt;24)\ <br>                           |(((l)&amp;0xFF00)&lt;&lt;8)|(((l)&amp;0xFF0000)&gt;&gt;8)) <br>#    endif <br> <br> <br>#else <br>/* <br> * If the platform is little endian, we don't have to do any byte <br> * order changing of the integers. <br> */ <br>#define  convert_long_to_network(x)        x <br>#define  convert_short_to_network(x)       x <br>#define  convert_long_from_network(x)      x <br>#define  convert_short_from_network(x)     x <br>#    ifndef SWAP2 <br>/* Macro SWAP2 swaps the bytes in a two-byte integer         */ <br>#    define SWAP2(s)       (unsigned short)(((s)&lt;&lt;8)|(((s)&amp;0xFF00)&gt;&gt;8)) <br>#    endif <br> <br>#    ifndef SWAP4 <br>/* Macro SWAP4 swaps the bytes in a four-byte integer        */ <br>#    define SWAP4(l)       (unsigned long)(((l)&lt;&lt;24)|(((l)&amp;0xFF000000)&gt;&gt;24)\ <br>                           |(((l)&amp;0xFF00)&lt;&lt;8)|(((l)&amp;0xFF0000)&gt;&gt;8)) <br>#    endif <br> <br>#endif <br> <br> <br> <br> <br> <br>/* <br> * Function prototypes <br> */ <br> <br>void           write_error(            char *fmt, ...); <br>void           write_output(           char *fmt, ...); <br>void           write_log(              FILE * file, <br>                                       char *fmt, ...); <br> <br>char CM_PTR    alloc_cpic_buffer(      unsigned int size); <br> <br>void           show_info(              char * * text); <br> <br>void           set_echo(               int mode); <br> <br>int            get_password(           char * password, <br>                                       int max_length); <br> <br>unsigned long  get_time(               void); <br> <br>void           display_message(        char * destination, <br>                                       char * userid, <br>                                       char * message); <br> <br> <br>void           datetime(               char *); <br> <br>void           do_exit(                int rc); <br> <br>void           ascii_to_ebcdic_field(  unsigned char * ascii_field, <br>                                       unsigned int field_size); <br>void           ebcdic_to_ascii_field(  unsigned char * ebcdic_field, <br>                                       unsigned int field_size); <br> <br>void           execute_and_send_output(char * command, <br>                                       unsigned char * cm_conv_id, <br>                                       struct error_handler_cpicerr * cpicerr); <br>void   free_cpic_buffer(   void *memblock );  <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
