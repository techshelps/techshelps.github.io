<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GETOPT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5134"></a>GETOPT.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  MODULE NAME : GETOPT.C <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:   Original author: <br> *                 G. R. Blair (BOBBLAIR at AUSVM1) <br> *                 Internet: bobblair@bobblair.austin.ibm.com <br> * <br> *            Extensively revised by: <br> *                 John Q. Walker II, Ph.D. (JOHHQ at RALVM6) <br> *                 Internet: johnq@ralvm6.vnet.ibm.com <br> * <br> *****************************************************************************/ <br> <br>/****************************************************************************** <br> * getopt() <br> * <br> * The getopt() function is a command line parser.  It returns the next <br> * option character in argv that matches an option character in opstring. <br> * <br> * The argv argument points to an array of argc+1 elements containing argc <br> * pointers to character strings followed by a null pointer. <br> * <br> * The opstring argument points to a string of option characters; if an <br> * option character is followed by a colon, the option is expected to have <br> * an argument that may or may not be separated from it by white space. <br> * The external variable optarg is set to point to the start of the option <br> * argument on return from getopt(). <br> * <br> * The getopt() function places in optind the argv index of the next argument <br> * to be processed.  The system initializes the external variable optind to <br> * 1 before the first call to getopt(). <br> * <br> * When all options have been processed (that is, up to the first nonoption <br> * argument), getopt() returns EOF.  The special option "--" may be used to <br> * delimit the end of the options; EOF will be returned, and "--" will be <br> * skipped. <br> * <br> * The getopt() function returns a question mark (?) when it encounters an <br> * option character not included in opstring.  This error message can be <br> * disabled by setting opterr to zero.  Otherwise, it returns the option <br> * character that was detected. <br> * <br> * If the special option "--" is detected, or all options have been <br> * processed, EOF is returned. <br> * <br> * Options are marked by either a minus sign (-) or a slash (/). <br> * <br> * No errors are defined. <br> *****************************************************************************/ <br> <br>#include &lt;stdio.h&gt;                  /* for EOF */ <br>#include &lt;string.h&gt;                 /* for strchr() */ <br> <br> <br>/* static (global) variables that are specified as exported by getopt() */ <br>char *optarg = NULL;    /* pointer to the start of the option argument  */ <br>int   optind = 1;       /* number of the next argv[] to be evaluated    */ <br>int   opterr = 1;       /* non-zero if a question mark should be returned <br>                           when a non-valid option character is detected */ <br> <br>/* handle possible future character set concerns by putting this in a macro */ <br>#define _next_char(string)  (char)(*(string+1)) <br> <br>int getopt(int argc, char *argv[], char *opstring) <br>{ <br>    static char *pIndexPosition = NULL; /* place inside current argv string */ <br>    char *pArgString = NULL;        /* where to start from next */ <br>    char *pOptString;               /* the string in our program */ <br> <br> <br>    if (pIndexPosition != NULL) { <br>        /* we last left off inside an argv string */ <br>        if (*(++pIndexPosition)) { <br>            /* there is more to come in the most recent argv */ <br>            pArgString = pIndexPosition; <br>        } <br>    } <br> <br>    if (pArgString == NULL) { <br>        /* we didn't leave off in the middle of an argv string */ <br>        if (optind &gt;= argc) { <br>            /* more command-line arguments than the argument count */ <br>            pIndexPosition = NULL;  /* not in the middle of anything */ <br>            return EOF;             /* used up all command-line arguments */ <br>        } <br> <br>        /*--------------------------------------------------------------------- <br>         * If the next argv[] is not an option, there can be no more options. <br>         *-------------------------------------------------------------------*/ <br>        pArgString = argv[optind++]; /* set this to the next argument ptr */ <br> <br>        if (('/' != *pArgString) &amp;&amp; /* doesn't start with a slash or a dash? */ <br>            ('-' != *pArgString)) { <br>            --optind;               /* point to current arg once we're done */ <br>            optarg = NULL;          /* no argument follows the option */ <br>            pIndexPosition = NULL;  /* not in the middle of anything */ <br>            return EOF;             /* used up all the command-line flags */ <br>        } <br> <br>        /* check for special end-of-flags markers */ <br>        if ((strcmp(pArgString, "-") == 0) || <br>            (strcmp(pArgString, "--") == 0)) { <br>            optarg = NULL;          /* no argument follows the option */ <br>            pIndexPosition = NULL;  /* not in the middle of anything */ <br>            return EOF;             /* encountered the special flag */ <br>        } <br> <br>        pArgString++;               /* look past the / or - */ <br>    } <br> <br>    if (':' == *pArgString) {       /* is it a colon? */ <br>        /*--------------------------------------------------------------------- <br>         * Rare case: if opterr is non-zero, return a question mark; <br>         * otherwise, just return the colon we're on. <br>         *-------------------------------------------------------------------*/ <br>        return (opterr ? (int)'?' : (int)':'); <br>    } <br>    else if ((pOptString = strchr(opstring, *pArgString)) == 0) { <br>        /*--------------------------------------------------------------------- <br>         * The letter on the command-line wasn't any good. <br>         *-------------------------------------------------------------------*/ <br>        optarg = NULL;              /* no argument follows the option */ <br>        pIndexPosition = NULL;      /* not in the middle of anything */ <br>        return (opterr ? (int)'?' : (int)*pArgString); <br>    } <br>    else { <br>        /*--------------------------------------------------------------------- <br>         * The letter on the command-line matches one we expect to see <br>         *-------------------------------------------------------------------*/ <br>        if (':' == _next_char(pOptString)) { /* is the next letter a colon? */ <br>            /* It is a colon.  Look for an argument string. */ <br>            if ('\0' != _next_char(pArgString)) {  /* argument in this argv? */ <br>                optarg = &amp;pArgString[1];   /* Yes, it is */ <br>            } <br>            else { <br>                /*------------------------------------------------------------- <br>                 * The argument string must be in the next argv. <br>                 * But, what if there is none (bad input from the user)? <br>                 * In that case, return the letter, and optarg as NULL. <br>                 *-----------------------------------------------------------*/ <br>                if (optind &lt; argc) <br>                    optarg = argv[optind++]; <br>                else { <br>                    optarg = NULL; <br>                    return (opterr ? (int)'?' : (int)*pArgString); <br>                } <br>            } <br>            pIndexPosition = NULL;  /* not in the middle of anything */ <br>        } <br>        else { <br>            /* it's not a colon, so just return the letter */ <br>            optarg = NULL;          /* no argument follows the option */ <br>            pIndexPosition = pArgString;    /* point to the letter we're on */ <br>        } <br>        return (int)*pArgString;    /* return the letter that matched */ <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
