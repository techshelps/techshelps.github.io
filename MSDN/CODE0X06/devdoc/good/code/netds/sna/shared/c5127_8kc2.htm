<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPICPORT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5132"></a>CPICPORT.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  MODULE NAME: CPICPORT.C <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:    Peter J. Schwaller <br> *             VNET:     PJS at RALVM6           Tie Line: 444-4376 <br> *             Internet: pjs@ralvm6.vnet.ibm.com     (919) 254-4376 <br> * <br> *  FUNCTION:  Contains procedures to that may have to be rewritten for <br> *             different environments. <br> * <br> *  AVAILABILITY: <br> *             These sample programs and source are also available on <br> *             CompuServe through the APPC Information Exchange.  To get <br> *             to the APPC forum just type 'GO APPC' from any CompuServe <br> *             prompt.  The samples are available in the Sample Programs <br> *             library section.  Just search on the keyword CPICPGMS to <br> *             find all the samples in this series. <br> * <br> *             Updates for the sample programs and support for many more <br> *             CPI-C platforms will also be made available on CompuServe. <br> * <br> *  RELATED FILES: <br> *             CPICPORT.H <br> * <br> *  PORTABILITY NOTES: <br> *             This file is the home of all operating system specific <br> *             functions.  The following is a summary of the routines <br> *             in this file and where they are used: <br> * <br> *             write_output() <br> *                 displays a text string to normal output <br> * <br> *             write_error() <br> *                 displays error text to error output <br> * <br> *             write_log() <br> *                 logs text to an opened log file <br> *                 if the log file was not open, will display to error output <br> * <br> *             display_message() <br> *                 Delivers a text message. <br> *                 Used by ATELLD.C. <br> * <br> *             get_time() <br> *                 Returns time in milliseconds. <br> *                 Used by APING.C. <br> * <br> *             alloc_cpic_buffer() <br> *                 Allocates the best memory buffer for CPI-C performance. <br> *                 Used by APING.C and APINGD.C. <br> * <br> *             show_info() <br> *                 Displays an array of text strings. <br> *                 Used by all files with a main() function. <br> * <br> *             get_machine_mode() <br> *                 For family API applications; determines whether we <br> *                 are running under OS/2 or DOS. <br> * <br> *             get_password() <br> *                 Used to request that the user enter a password. <br> *                 If possible, the password will not display while the <br> *                 user types it. <br> *                 Used by CPICINIT.C <br> * <br> *             execute_and_send_output() <br> *                 Execute the specified command and send the output back <br> *                 to the client side. <br> *                 This routine is called by AREXECD.C. <br> * <br> *             do_exit() <br> *                 Exit properly for the environment.  This is usually <br> *                 necessary for GUI environments. <br> * <br> *             free_cpic_buffer() <br> *                 Frees the memory allocated by alloc_cpic_buffer(). <br> *                 Used by MPINGD.C. <br> * <br> *  CHANGE HISTORY: <br> *  Date       Description <br> *  08/05/92   Version 2.31 of APING, ATELL and AREXEC released to CompuServe. <br> *             This version was also distributed at the APPC/APPN Platform <br> *             Developer's Conference held in Raleigh, NC. <br> *  08/13/92   Added the write_*() calls. <br> *             Changed all printf and fprintf calls to use a write_*() call. <br> *  08/19/92   Added workaround for problem with system() returning non-null <br> *             even when command succeeded.  The fix is in DOS and FAPI <br> *             versions of execute_and_send_output(). <br> *  08/20/92   Fixed alloc_cpic_buffer() so it will use a shared buffer <br> *             under OS/2 2.0. <br> *  08/23/92   Fixed extra rc definition for AS/400 definition of the <br> *             execute_and_send_output() routine. <br> *  08/24/92   Version 2.32 released to CompuServe. <br> *  08/25/92   Changed DOS and AIX execute_and_send_output() to use the <br> *             tempnam() function instead of the tmpnam() function.  This <br> *             results in tempfiles being written to the TMP directory. <br> *  09/22/92   Version 2.33 released to CompuServe. <br> *  01/07/93   Added OS2_20 to list of conditional compile directives in <br> *             the following routines: <br> *               get_time <br> *               get_password <br> *               set_echo <br> *               execute_and_send_output <br> *  11/11/94   Wrote free_cpic_buffer() <br> * <br> *****************************************************************************/ <br> <br>#if defined(WIN32) || defined(WINDOWS) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include "wincpic.h" <br> <br>#include "cpicerrs.h" <br> <br>/* Set up constant declarations */ <br>#include "cpicdefs.h" <br> <br>#include "cpicport.h" <br> <br> <br>/* standard C include files */ <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;time.h&gt; <br> <br>extern char ebcdic_to_ascii_table[]; <br>extern char ascii_to_ebcdic_table[]; <br> <br> <br> <br>void write_error(char *fmt, ...) <br>{ <br>    /*========================================================================= <br>     * <br>     *=======================================================================*/ <br> <br>    va_list args; <br> <br>    va_start(args, fmt); <br>    vfprintf(stderr, fmt, args); <br>    va_end(args); <br>} <br> <br> <br>void write_output(char *fmt, ...) <br>{ <br>    /*========================================================================= <br>     * <br>     *=======================================================================*/ <br> <br>    va_list args; <br> <br>    va_start(args, fmt); <br>    vfprintf(stdout, fmt, args); <br>    va_end(args); <br>} <br> <br>void write_log(FILE * file, char *fmt, ...) <br>{ <br>    /*========================================================================= <br>     * <br>     *=======================================================================*/ <br> <br>    va_list args; <br> <br>    va_start(args, fmt); <br>    if (file == NULL) { <br>        write_error(fmt, args); <br>    } else { <br>        vfprintf(file, fmt, args); <br>    } <br>    va_end(args); <br>} <br> <br>/* <br> * display_message() <br> *       delivers a text message <br> *       used by ATELLD.C <br> * <br> *    default <br> *       Uses C library functions to print the message. <br> */ <br>void <br>display_message(char * origin, char * dest_userid, char * message) <br>{ <br> <br>    char timestamp[TIMELENGTH]; <br>    struct tm * newtime; <br>    time_t ltime; <br> <br>    time(&amp;ltime); <br>    newtime = localtime(&amp;ltime); <br>    strcpy(timestamp, asctime(newtime)); <br> <br>    /* eliminate new line character for display */ <br>    timestamp[strlen(timestamp)-1] = '\0'; <br> <br>    write_output("\n\n  msg from %s ", origin); <br>    if (dest_userid[0] != '\0') { <br>        write_output("to user %s ", dest_userid); <br>    } <br>    write_output("on %s:", timestamp); <br>    write_output("\n\n     %s\n\n",message); <br>} <br> <br> <br> <br>/* <br> * get_time() <br> *       returns time in milliseconds <br> *       used by APING.C <br> * <br> */ <br>unsigned long <br>get_time(void) <br>{ <br> <br>    return GetTickCount(); <br> <br>} <br> <br> <br>/* <br> * alloc_cpic_buffer() <br> */ <br> <br>char CM_PTR <br>alloc_cpic_buffer (unsigned int size) <br>{ <br>   return malloc(size); <br>} <br> <br>/* <br> * freec_cpic_buffer() <br> */ <br> <br>void <br>free_cpic_buffer( void *memblock ) <br>{ <br>free( memblock ); <br>} <br> <br> <br>/* <br> * show_info() <br> * <br> *       This procedure displays a block of text information on the the <br> *       screen.  The input argument is an array of strings to be output, <br> *       one string per line.  A NULL array element indicates the end of <br> *       the strings. <br> * <br> *    default <br> *       print out all of the text strings in the array using the cpicport <br> *       write_output() call. <br> */ <br>void <br>show_info(char * * text) <br>{ <br>    int i; <br> <br>    for ( i = 0; text[i] != NULL; i++ ) { <br>        write_output("%s\n", text[i]); <br>    } <br>    return; <br>} <br> <br>/* <br> * get_password() <br> * <br> *    Gets a password from the user.  Where possible, this routine should <br> *    disable echoing of keystrokes for security reasons. <br> * <br> *    Returns <br> *       0 - password was successfully input <br> *       1 - password variable was not updated successfully <br> */ <br>int <br>get_password(char * password, int max_length) <br>{ <br>    int rc; <br>    int length; <br> <br>    /* There is no portable way to disable echoing of input keystrokes.      */ <br>    /* If a platform does support turning off echo, this section should be   */ <br>    /* rewritten and ifdef'ed.                                               */ <br> <br>    if (NULL != fgets(password, max_length+1, stdin)) { <br>        length = strlen(password); <br>        if (length &gt; 0 &amp;&amp; length &lt; max_length) { <br>            if (password[length-1] == '\n') { /* remove the trailing         */ <br>                password[length-1] = '\0';    /* newline if it exists        */ <br>            } <br>            rc = 0; <br>        } else { <br>            rc = 1; <br>        } <br> <br>    } else { <br>        rc = 1; <br>    } <br> <br>    return rc; <br>} <br> <br>/* <br> * do_exit() <br> * <br> * Exit properly for the environment we're running in. <br> */ <br>void <br>do_exit(int rc) <br>{ <br>#ifdef EXITTHREAD <br>    ExitThread(rc); <br>#else <br>    WinCPICCleanup(); <br>    exit(rc); <br>#endif <br>} <br> <br>/* <br> * The ASCII&lt;--&gt;EBCDIC character set translation routines are implemented <br> * below.  These procedures should never be called directly, but should <br> * be accessed through the convert_to_ascii() and convert_from_ascii() <br> * macros.  This frees the application program from knowing whether <br> * it is being coded on an ASCII or EBCDIC computer (this must be <br> * determined in the macro definition in CPICPORT.H). <br> */ <br> <br>void   ascii_to_ebcdic_field  (unsigned char * ascii_field, <br>                               unsigned int field_size) <br>{ <br>    unsigned int i; <br> <br>    for (i = 0; <br>         i &lt; field_size; <br>         ascii_field[i] = ascii_to_ebcdic_table[(unsigned)ascii_field[i]],i++); <br>} <br> <br>void  ascii_to_ebcdic_string (unsigned char * ascii_string) <br>{ <br>    ascii_to_ebcdic_field(ascii_string, strlen((char*)ascii_string)); <br>} <br> <br>void   ebcdic_to_ascii_field  (unsigned char * ebcdic_field, <br>                               unsigned int field_size) <br>{ <br>    unsigned int i; <br> <br>    for (i = 0; <br>         i &lt; field_size; <br>         ebcdic_field[i] = <br>                         ebcdic_to_ascii_table[(unsigned)ebcdic_field[i]],i++); <br>} <br> <br>void  ebcdic_to_ascii_string (unsigned char * ebcdic_string) <br>{ <br>    ebcdic_to_ascii_field(ebcdic_string, strlen((char*)ebcdic_string)); <br>} <br> <br> <br> <br>/* ASCII to EBCDIC translate table (only UGL character set) */ <br> <br>char ascii_to_ebcdic_table[] = { <br>"\x00\x01\x02\x03\x37\x2D\x2E\x2F\x16\x05\x15\x0B\x0C\x0D\x0E\x0F"  /* 00-0F */ <br>"\x10\x11\x12\x13\x3C\x3D\x32\x26\x18\x19\x3F\x27\x22\x1D\x35\x1F"  /* 10-1F */ <br>"\x40\x5A\x7F\x7B\x5B\x6C\x50\x7D\x4D\x5D\x5C\x4E\x6B\x60\x4B\x61"  /* 20-2F */ <br>"\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\x7A\x5E\x4C\x7E\x6E\x6F"  /* 30-3F */ <br>"\x7C\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xD1\xD2\xD3\xD4\xD5\xD6"  /* 40-4F */ <br>"\xD7\xD8\xD9\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xAD\xE0\xBD\x5F\x6D"  /* 50-5F */ <br>"\x79\x81\x82\x83\x84\x85\x86\x87\x88\x89\x91\x92\x93\x94\x95\x96"  /* 60-6F */ <br>"\x97\x98\x99\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xC0\x4F\xD0\xA1\x07"  /* 70-7F */ <br>"\x43\x20\x21\x1C\x23\xEB\x24\x9B\x71\x28\x38\x49\x90\xBA\xEC\xDF"  /* 80-8F */ <br>"\x45\x29\x2A\x9D\x72\x2B\x8A\x9A\x67\x56\x64\x4A\x53\x68\x59\x46"  /* 90-9F */ <br>"\xEA\xDA\x2C\xDE\x8B\x55\x41\xFE\x58\x51\x52\x48\x69\xDB\x8E\x8D"  /* A0-AF */ <br>"\x73\x74\x75\xFA\x15\xB0\xB1\xB3\xB4\xB5\x6A\xB7\xB8\xB9\xCC\xBC"  /* B0-BF */ <br>"\xAB\x3E\x3B\x0A\xBF\x8F\x3A\x14\xA0\x17\xCB\xCA\x1A\x1B\x9C\x04"  /* C0-CF */ <br>"\x34\xEF\x1E\x06\x08\x09\x77\x70\xBE\xBB\xAC\x54\x63\x65\x66\x62"  /* D0-DF */ <br>"\x30\x42\x47\x57\xEE\x33\xB6\xE1\xCD\xED\x36\x44\xCE\xCF\x31\xAA"  /* E0-EF */ <br>"\xFC\x9E\xAE\x8C\xDD\xDC\x39\xFB\x80\xAF\xFD\x78\x76\xB2\x9F\xFF"  /* F0-FF */ <br>}; <br> <br>/* EBCDIC to ASCII translate table (only UGL character set) */ <br> <br>char ebcdic_to_ascii_table[] = { <br>"\x00\x01\x02\x03\xCF\x09\xD3\x7F\xD4\xD5\xC3\x0B\x0C\x0D\x0E\x0F"  /* 00-0F */ <br>"\x10\x11\x12\x13\xC7\x0A\x08\xC9\x18\x19\xCC\xCD\x83\x1D\xD2\x1F"  /* 10-1F */ <br>"\x81\x82\x1C\x84\x86\x0A\x17\x1B\x89\x91\x92\x95\xA2\x05\x06\x07"  /* 20-2F */ <br>"\xE0\xEE\x16\xE5\xD0\x1E\xEA\x04\x8A\xF6\xC6\xC2\x14\x15\xC1\x1A"  /* 30-3F */ <br>"\x20\xA6\xE1\x80\xEB\x90\x9F\xE2\xAB\x8B\x9B\x2E\x3C\x28\x2B\x7C"  /* 40-4F */ <br>"\x26\xA9\xAA\x9C\xDB\xA5\x99\xE3\xA8\x9E\x21\x24\x2A\x29\x3B\x5E"  /* 50-5F */ <br>"\x2D\x2F\xDF\xDC\x9A\xDD\xDE\x98\x9D\xAC\xBA\x2C\x25\x5F\x3E\x3F"  /* 60-6F */ <br>"\xD7\x88\x94\xB0\xB1\xB2\xFC\xD6\xFB\x60\x3A\x23\x40\x27\x3D\x22"  /* 70-7F */ <br>"\xF8\x61\x62\x63\x64\x65\x66\x67\x68\x69\x96\xA4\xF3\xAF\xAE\xC5"  /* 80-8F */ <br>"\x8C\x6A\x6B\x6C\x6D\x6E\x6F\x70\x71\x72\x97\x87\xCE\x93\xF1\xFE"  /* 90-9F */ <br>"\xC8\x7E\x73\x74\x75\x76\x77\x78\x79\x7A\xEF\xC0\xDA\x5B\xF2\xF9"  /* A0-AF */ <br>"\xB5\xB6\xFD\xB7\xB8\xB9\xE6\xBB\xBC\xBD\x8D\xD9\xBF\x5D\xD8\xC4"  /* B0-BF */ <br>"\x7B\x41\x42\x43\x44\x45\x46\x47\x48\x49\xCB\xCA\xBE\xE8\xEC\xED"  /* C0-CF */ <br>"\x7D\x4A\x4B\x4C\x4D\x4E\x4F\x50\x51\x52\xA1\xAD\xF5\xF4\xA3\x8F"  /* D0-DF */ <br>"\x5C\xE7\x53\x54\x55\x56\x57\x58\x59\x5A\xA0\x85\x8E\xE9\xE4\xD1"  /* E0-EF */ <br>"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\xB3\xF7\xF0\xFA\xA7\xFF"  /* F0-FF */ <br>}; <br> <br>void <br>execute_and_send_output(char * command, <br>                        unsigned char * cm_conv_id, <br>                        struct error_handler_cpicerr * cpicerr) <br>{ <br> <br>   DWORD lasterror = 0; <br>   HANDLE hWritePipe = NULL; <br>   HANDLE hReadPipe = NULL; <br>   SECURITY_ATTRIBUTES SecAttrib = {0}; <br>   STARTUPINFO StartInfo = {0}; <br>   PROCESS_INFORMATION ProcInfo = {0}; <br>   unsigned char * buffer=NULL; <br>   DWORD BufferSize=10000; <br>   DWORD BytesRead=0; <br>   DWORD BytesInPipe=0; <br>   DWORD WaitState=0; <br>   BOOL ProcessDead=FALSE; <br>   CM_INT32 rts_received; <br>   CM_INT32 cm_rc; <br>   char NewCommand[255] = {0}; <br> <br>   strcpy(NewCommand,"cmd /c "); <br>   strcat(NewCommand,command); <br> <br>   buffer=malloc(BufferSize+2); <br> <br>   SecAttrib.nLength = sizeof(SECURITY_ATTRIBUTES); <br>   SecAttrib.lpSecurityDescriptor = NULL; <br>   SecAttrib.bInheritHandle = TRUE; <br> <br>   /**************************************************************************/ <br>   /* Create named pipe and get handle to read end of the pipe.              */ <br>   /**************************************************************************/ <br>   if ((hReadPipe = CreateNamedPipe("\\\\.\\pipe\\arexecpipe", <br>               PIPE_ACCESS_INBOUND, PIPE_TYPE_BYTE, 1, BufferSize, <br>               BufferSize, 1000,&amp;SecAttrib)) == INVALID_HANDLE_VALUE) <br>   { <br>      lasterror = GetLastError(); <br>      printf("CreateNamedPipe returned %d",lasterror); <br>      return; <br>   } <br> <br>   /**************************************************************************/ <br>   /* Open a handle to the write end of the pipe, NB must be inheritable     */ <br>   /**************************************************************************/ <br>   if ((hWritePipe = CreateFile("\\\\.\\pipe\\arexecpipe",GENERIC_WRITE, 0, <br>                &amp;SecAttrib, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) <br>        == INVALID_HANDLE_VALUE) <br>   { <br>      lasterror = GetLastError(); <br>      printf("CreateFile returned %d",lasterror); <br>      return; <br>   } <br> <br>   /**************************************************************************/ <br>   /* Now create the process, with its stdout and stderr pipes attatched to  */ <br>   /* the write end of the named pipe.                                       */ <br>   /**************************************************************************/ <br>   StartInfo.cb = sizeof(STARTUPINFO); <br>   StartInfo.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; <br>   StartInfo.wShowWindow = SW_HIDE; <br>   StartInfo.hStdInput = NULL; <br>   StartInfo.hStdOutput = hWritePipe; <br>   StartInfo.hStdError = hWritePipe; <br>   ProcessDead = FALSE; <br> <br>   if (!CreateProcess(NULL,NewCommand, NULL, NULL, TRUE, 0, NULL, NULL, <br>                      &amp;StartInfo, &amp;ProcInfo)) <br>   { <br>      lasterror=GetLastError(); <br>      printf("CreateProcess returned %d\n",lasterror); <br>      return; <br>   } <br> <br>   /**************************************************************************/ <br>   /* Loop whilst the process is still running                               */ <br>   /**************************************************************************/ <br>   while (!ProcessDead) <br>   { <br>      /***********************************************************************/ <br>      /* Check the process handle to see if it is dead yet.                  */ <br>      /***********************************************************************/ <br>      WaitState = WaitForSingleObject(ProcInfo.hProcess,1); <br>      if (WaitState != WAIT_TIMEOUT) <br>      { <br>         ProcessDead = TRUE; <br>      } <br> <br>      /***********************************************************************/ <br>      /* Peek in the named pipe for some data, don't just do a ReadFile as   */ <br>      /* we may never get any more data!                                     */ <br>      /* If there is some then read it out of the pipe and send it.          */ <br>      /***********************************************************************/ <br>      if (!PeekNamedPipe(hReadPipe, NULL, 0, NULL, &amp;BytesInPipe, NULL)) <br>      { <br>         lasterror=GetLastError(); <br>         printf("PeekNamePipe returned %d\n",lasterror); <br>         return; <br>      } <br>      if (BytesInPipe != 0) <br>      { <br>         memset(buffer,'\0',BufferSize+1); <br>         if (!ReadFile(hReadPipe, buffer, BufferSize, &amp;BytesRead, NULL)) <br>         { <br>            lasterror=GetLastError(); <br>            printf("ReadFile returned %d\n",lasterror); <br>            return; <br>         } <br>         cmsend(cm_conv_id,(unsigned char *) buffer,(CM_INT32 *)&amp;BytesRead, <br>                &amp;rts_received,&amp;cm_rc); <br>         if (cm_rc) cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br>      } <br>   } <br>   do <br>   { <br>      /***********************************************************************/ <br>      /* The process is now dead, but there could still be some data in the  */ <br>      /* pipe, so we do a peek/read loop until the number of bytes left is 0 */ <br>      /***********************************************************************/ <br>      if (!PeekNamedPipe(hReadPipe, NULL, 0, NULL, &amp;BytesInPipe, NULL)) <br>      { <br>         lasterror=GetLastError(); <br>         printf("PeekNamePipe returned %d\n",lasterror); <br>         return; <br>      } <br>      if (BytesInPipe != 0) <br>      { <br>         memset(buffer,'\0',BufferSize+1); <br>         if (!ReadFile(hReadPipe, buffer, BufferSize, &amp;BytesRead, NULL)) <br>         { <br>            lasterror=GetLastError(); <br>            printf("ReadFile returned %d\n",lasterror); <br>            return; <br>         } <br>         cmsend(cm_conv_id,(unsigned char *) buffer,(CM_INT32 *)&amp;BytesRead, <br>                &amp;rts_received,&amp;cm_rc); <br>         if (cm_rc) cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br>      } <br>   } while (BytesInPipe != 0); <br> <br>   CloseHandle(hReadPipe); <br>   CloseHandle(hWritePipe); <br> <br>   return; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
