<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPICINIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5130"></a>CPICINIT.C</h2>
<pre><code>/* need to look for SUPPORTS_SETTING_SECURITY before using XC_SECURITY*     */ <br>/***************************************************************************** <br> * <br> *  MODULE NAME: CPICINIT.C <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:    Peter J. Schwaller <br> *             VNET:     PJS at RALVM6           Tie Line: 444-4376 <br> *             Internet: pjs@ralvm6.vnet.ibm.com     (919) 254-4376 <br> * <br> *  FUNCTION:  Provides procedures to be used in programs to help them set up <br> *             all of the partner program information for CPI-C.  All of the <br> *             information is stored in a CPICINIT structure.  The <br> *             information is stored in the structure using default and set <br> *             calls. <br> * <br> *             The cpicinit_setup_conversation procedure can then be used <br> *             to issue the CPI-C calls to setup a conversation_id. <br> *             All of the CPI-C calls from CMINIT to just before CMALLC <br> *             are issued.  The program should issue CMALLC on its own <br> *             so it can control error handling. <br> * <br> *             By collecting all of the partner program information within <br> *             a single object, restarting a conversation that has failed <br> *             is made easier, since the information does not have to <br> *             be collected or read from a profile again. <br> * <br> *  AVAILABILITY: <br> *             These sample programs and source are also available on <br> *             CompuServe through the APPC Information Exchange.  To get <br> *             to the APPC forum just type 'GO APPC' from any CompuServe <br> *             prompt.  The samples are available in the Sample Programs <br> *             library section.  Just search on the keyword CPICPGMS to <br> *             find all the samples in this series. <br> * <br> *             Updates for the sample programs and support for many more <br> *             CPI-C platforms will also be made available on CompuServe. <br> * <br> *  RELATED FILES: <br> *             Uses CPICINIT.H <br> * <br> *  CHANGE HISTORY: <br> *  Date       Description <br> *  08/05/92   Version 2.31 of APING, ATELL and AREXEC released to CompuServe. <br> *             This version was also distributed at the APPC/APPN Platform <br> *             Developer's Conference held in Raleigh, NC. <br> *  08/13/92   Changed all printf and fprintf calls to use a write_*() call. <br> *  08/18/92   Fixed problem with imbedded \0 added setting def_sym_dest_name <br> *             in cpicinit_default_sym_dest_name().  This fixes a problem <br> *             seen in MVS. <br> *  08/23/92   Removed cpicinit_default_destination() and associated <br> *             processing.   After review, we decided that this call was <br> *             extraneous and that cpicinit_default_sym_dest_name() was <br> *             a better mechanism for a default destination. <br> *  11/13/92   Changed most return values from TRUE/FALSE to CPICINIT_OK and <br> *             other return codes. <br> * <br> *****************************************************************************/ <br> <br>/***************************************************************************** <br> * <br> * OVERVIEW OF CPICINIT CALLS <br> * <br> * cpicinit_new()                     Creates a CPICINIT object. <br> *                                    This must be done before any other <br> *                                    cpicinit calls can be used. <br> * <br> * cpicinit_default_tp_name()         These calls set the initial values <br> * cpicinit_default_mode_name()       for CPICINIT parameters.  These should <br> * cpicinit_default_sym_dest_name()   all be issued right after the CPICINIT <br> *                                    object is created.  Usually, these calls <br> *                                    should set the values that should be used <br> *                                    only if the user does not specify new <br> *                                    values. <br> * <br> * cpicinit_set_tp_name()             These calls also set the values for <br> * cpicinit_set_mode_name()           CPICINIT parameters.  These calls should <br> * cpicinit_set_destination()         be used to set values from user input <br> *                                    or profile values.  These calls should be <br> *                                    used after the user has specified values, <br> *                                    through command line parameters, program <br> *                                    profiles, or interactive input. <br> * <br> *   Security calls - only available where supported by CPI-C <br> * cpicinit_set_userid                Sets the userid for the conversation. <br> * cpicinit_set_password              Sets the password for the conversation. <br> * cpicinit_query_password_needed     If a userid was set, then a password <br> *                                    is required. <br> * cpicinit_get_password              Let cpicinit prompt the user for a <br> *                                    password. <br> * cpicinit_set_security_type         Set the security type for this conv. <br> * <br> * cpicinit_setup_conversation()      Handles all CMINIT and set calls. <br> *                                    Should be used by the calling program <br> *                                    instead of CMINIT.  See description <br> *                                    of the procedure for more details. <br> * <br> * cpicinit_destroy()                 Destroys the CPICINIT object. <br> * <br> * cpicinit_pln_valid()               These are internal calls used by <br> * cpicinit_mode_valid()              cpicinit_setup_conversation. <br> * <br> *****************************************************************************/ <br> <br>#if defined(WIN32) || defined(WINDOWS) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include "wincpic.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br> <br>/* CPI-C error handling routines */ <br>#include "cpicerrs.h" <br> <br>/* CPI-C initialization routines */ <br>#include "cpicinit.h" <br> <br>/* Collection of routines with special ported version for each platform */ <br>#include "cpicport.h" <br> <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_new <br> * <br> *  Creates a new CPICINIT object and returns its handle to the caller. <br> *  This object handle must be used on all subsequent cpicinit calls. <br> *  All internal fields are initialized appropriately. <br> * <br> *  If memory cannot be allocated for the CPICINIT object, NULL will be <br> *  returned as the result of the call.  Otherwise, the return value will <br> *  be a pointer to the CPICINIT object. <br> * <br> *****************************************************************************/ <br>CPICINIT * <br>cpicinit_new(void) <br>{ <br>    CPICINIT * cpicinit; <br> <br>    cpicinit = (CPICINIT *) malloc(sizeof(*cpicinit)); <br>    if (cpicinit == NULL) { <br>        return NULL; <br>    } <br> <br>    /* Initialize the entire structure to 0's */ <br>    memset(cpicinit, <br>           0, <br>           sizeof(*cpicinit)); <br> <br>    /* Set the default symbolic destination name to BLANKs. */ <br>    /* This is the "default-default" if nothing else is set. */ <br>    memset(cpicinit -&gt; def_sym_dest_name, <br>           ' ', <br>           sizeof(cpicinit-&gt;def_sym_dest_name)); <br>    cpicinit-&gt;def_sym_dest_name[sizeof(cpicinit-&gt;def_sym_dest_name)-1] = '\0'; <br> <br>    /* Indicate that the values have not yet been SET */ <br>    cpicinit -&gt; set_mode_name = NOT_SET; <br>    cpicinit -&gt; set_destination = NOT_SET; <br>    cpicinit -&gt; set_tp_name = NOT_SET; <br>    cpicinit -&gt; set_userid = NOT_SET; <br>    cpicinit -&gt; set_password = NOT_SET; <br>    cpicinit -&gt; security_type = XC_SECURITY_SAME; <br> <br>    /* <br>     * This flag is usedby other cpicinit calls to decide whether or not <br>     * to show errors encountered during processing. <br>     * <br>     * If this value is turned off, the cpicinit routines will not produce <br>     * any output, even in the event of an error. <br>     */ <br>    cpicinit -&gt; show_error = SET; <br> <br> <br>    /* return a pointer to the structure */ <br>    return cpicinit; <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_default_sym_dest_name <br> * <br> *  Sets a symbolic destination name to be used if no call is made to <br> *  cpicinit_set_destination(). <br> * <br> *  Returns: <br> *    CPICINIT_OK,     if there was no error. <br> *    CPICINIT_ERROR,  if there was an error. <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_default_sym_dest_name( CPICINIT * cpicinit, <br>                                char *     def_sym_dest_name) <br>/* <br> * Set the default symbolic destination name to be used if no destination <br> * is ever set. <br> */ <br>{ <br>    int length; <br>    int rc; <br> <br> <br>    /* Set the default symbolic destination name to BLANKs. */ <br>    memset(cpicinit -&gt; def_sym_dest_name, <br>           ' ', <br>           sizeof(cpicinit-&gt;def_sym_dest_name)); <br>    cpicinit-&gt;def_sym_dest_name[sizeof(cpicinit-&gt;def_sym_dest_name)-1] = '\0'; <br> <br>    length = strlen(def_sym_dest_name); <br> <br>    if (length &lt; sizeof(cpicinit-&gt;def_sym_dest_name)) { <br>        rc = CPICINIT_ERROR; <br>        memcpy(cpicinit-&gt;def_sym_dest_name, <br>               def_sym_dest_name, <br>               length); <br>    } else { <br>        rc = CPICINIT_OK; <br>    } <br> <br>    return rc; <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_default_tp_name <br> * <br> *  Sets a symbolic destination name to be used if no call is made to <br> *  cpicinit_set_destination(). <br> * <br> *  Returns: <br> *    CPICINIT_OK,     if there was no error. <br> *    CPICINIT_ERROR,  if there was an error. <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_default_tp_name(CPICINIT * cpicinit, <br>                         char *     tp_name) <br>/* initialize the tp_name */ <br>{ <br>    int length; <br>    int rc; <br> <br>    length = strlen(tp_name); <br> <br>    if (length &lt; sizeof(cpicinit-&gt;tp_name)) { <br>        rc = CPICINIT_ERROR; <br>        memcpy(cpicinit-&gt;tp_name, <br>               tp_name, <br>               length); <br>        cpicinit-&gt;tp_name[length] = '\0'; <br>    } else { <br>        rc = CPICINIT_OK; <br>        if (cpicinit -&gt; show_error) { <br>             write_error( <br>                     "The TP name you specified is too long:\n%s\n", <br>                     tp_name); <br>             write_error( <br>                    "The maximum length of a TP name is %u characters.\n", <br>                    sizeof(cpicinit-&gt;tp_name)-1); <br>             write_error( <br>                     "TP name of %s will be used.\n", cpicinit-&gt;tp_name); <br>        } <br>    } <br> <br>    return rc; <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_default_mode_name <br> * <br> *  Sets the default mode name to be used if there is no call made to <br> *  cpicinit_set_mode_name(). <br> * <br> *  Returns: <br> *    CPICINIT_OK,     if there was no error. <br> *    CPICINIT_ERROR,  if there was an error. <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_default_mode_name(CPICINIT * cpicinit, <br>                           char *     mode_name) <br>/* initialize the mode name */ <br>{ <br>    int length; <br>    int rc; <br> <br>    length = strlen(mode_name); <br> <br>    if (length &lt; sizeof(cpicinit-&gt;mode_name)) { <br>        rc = CPICINIT_ERROR; <br>        memcpy(cpicinit-&gt;mode_name, <br>               mode_name, <br>               length); <br>        cpicinit-&gt;mode_name[length] = '\0'; <br>        strupr(cpicinit-&gt;mode_name); <br>    } else { <br>        rc = CPICINIT_OK; <br>        if (cpicinit -&gt; show_error) { <br>            write_error( <br>                    "The mode name you specified is too long:\n%s\n", <br>                    mode_name); <br>            write_error( <br>                   "The maximum length of a mode name is %u characters.\n", <br>                   sizeof(cpicinit-&gt;mode_name)-1); <br>            write_error( <br>                   "Mode name of %s will be used.\n", cpicinit-&gt;mode_name); <br>        } <br>    } <br> <br>    return rc; <br>} <br> <br> <br>/* <br> * The major difference between the default calls above and the set calls <br> * below is the setting of a flag in the set calls indicating that the user <br> * has specified this value.  This flag is used later as an indication that <br> * any value set by the symbolic destination name entries should be <br> * overridden. <br> */ <br> <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_set_tp_name <br> * <br> *  Returns: <br> *    CPICINIT_OK,     if there was no error. <br> *    CPICINIT_ERROR,  if there was an error. <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_set_tp_name(CPICINIT * cpicinit, <br>                     char *     tp_name) <br>{ <br>    cpicinit-&gt;set_tp_name = SET; <br>    return cpicinit_default_tp_name(cpicinit, tp_name); <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_set_mode_name <br> * <br> *  Returns: <br> *    CPICINIT_OK,     if there was no error. <br> *    CPICINIT_ERROR,  if there was an error. <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_set_mode_name(CPICINIT * cpicinit, <br>                       char *     mode_name) <br>{ <br>    cpicinit-&gt;set_mode_name = SET; <br>    return cpicinit_default_mode_name(cpicinit, mode_name); <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_set_destination <br> * <br> *  Returns: <br> *    CPICINIT_OK,     if there was no error. <br> *    CPICINIT_ERROR,  if there was an error. <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_set_destination(CPICINIT * cpicinit, <br>                         char *     destination) <br>{ <br>    int length; <br>    int rc; <br> <br>    cpicinit-&gt;set_destination = SET; <br> <br>    length = strlen(destination); <br> <br>    if (length &lt; sizeof(cpicinit-&gt;destination)) { <br>        rc = CPICINIT_ERROR; <br>        memcpy(cpicinit-&gt;destination, <br>               destination, <br>               length); <br>        cpicinit-&gt;destination[length] = '\0'; <br>    } else { <br>        rc = CPICINIT_OK; <br>        if (cpicinit -&gt; show_error) { <br>            write_error( <br>                    "The destination you specified is too long:\n%s\n", <br>                    destination); <br>            write_error( <br>            "The maximum length of a destination is %u characters.\n", <br>                sizeof(cpicinit-&gt;destination)-1); <br>            write_error( <br>                    "Destination %s will be used.\n", cpicinit-&gt;destination); <br>        } <br>    } <br> <br>    return rc; <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_set_userid <br> * <br> *  Sets the userid to be used for security on the conversation.  Issuing <br> *  this call implies that the conversation will use security=PROGRAM; <br> *  a password will also be required in order to get a conversation. <br> *  The password should be set using either the cpicinit_set_password() call <br> *  or the cpicinit_get_password() call. <br> * <br> *  Returns: <br> *    CPICINIT_OK,     if there was no error. <br> *    CPICINIT_ERROR,  if there was an error. <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_set_userid(CPICINIT * cpicinit, <br>                    char *     userid) <br>/* initialize the userid */ <br>{ <br>    int length; <br>    int rc; <br> <br>    length = strlen(userid); <br> <br>    if (length &lt; sizeof(cpicinit-&gt;userid)) { <br>        rc = CPICINIT_ERROR; <br>        memcpy(cpicinit-&gt;userid, <br>               userid, <br>               length); <br>        cpicinit-&gt;userid[length] = '\0'; <br>        cpicinit-&gt;set_userid = SET; <br>        cpicinit-&gt;security_type = XC_SECURITY_PROGRAM; <br>    } else { <br>        rc = CPICINIT_OK; <br>        if (cpicinit -&gt; show_error) { <br>            write_error( <br>                    "The userid you specified is too long:\n%s\n", <br>                    userid); <br>            write_error( <br>                   "The maximum length of a userid is %u characters.\n", <br>                   sizeof(cpicinit-&gt;userid)-1); <br>        } <br>    } <br> <br>    return rc; <br> <br>} <br>/****************************************************************************** <br> * <br> *  cpicinit_query_password_needed <br> * <br> *  Can be used by the program to inquire whether a password will be required <br> *  to establish a conversation.  This can be used by a program instead of <br> *  keeping track itself of whether a userid has been specified.  If a password <br> *  is required, the password should be set using either the <br> *  cpicinit_set_password() call or the cpicinit_get_password() call. <br> * <br> *  Returns: <br> *    TRUE   if password is required <br> *    FALSE  if no password should be set <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_query_password_needed(CPICINIT * cpicinit) <br>{ <br>    if (cpicinit-&gt;set_userid == SET &amp;&amp; cpicinit-&gt;set_password == NOT_SET) { <br>        return TRUE; <br>    } else { <br>        return FALSE; <br>    } <br>} <br> <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_set_password <br> * <br> *  Sets the password to be used with security=PROGRAM.  This call should be <br> *  used in conjunction with the cpicinit_set_userid() call. <br> * <br> *  Returns: <br> *    CPICINIT_OK,     if there was no error. <br> *    CPICINIT_ERROR,  if there was an error. <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_set_password(CPICINIT * cpicinit, <br>                    char *     password) <br>/* initialize the password */ <br>{ <br>    int length; <br>    int rc; <br> <br>    length = strlen(password); <br> <br>    if (length &lt; sizeof(cpicinit-&gt;password)) { <br>        rc = CPICINIT_ERROR; <br>        memcpy(cpicinit-&gt;password, <br>               password, <br>               length); <br>        cpicinit-&gt;password[length] = '\0'; <br>        cpicinit-&gt;set_password = SET; <br>        cpicinit-&gt;security_type = XC_SECURITY_PROGRAM; <br>    } else { <br>        rc = CPICINIT_OK; <br>        if (cpicinit -&gt; show_error) { <br>            write_error( <br>                    "The password you specified is too long:\n%s\n", <br>                    password); <br>            write_error( <br>                   "The maximum length of a password is %u characters.\n", <br>                   sizeof(cpicinit-&gt;password)-1); <br>        } <br>    } <br> <br>    return rc; <br>} <br> <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_get_password <br> * <br> *****************************************************************************/ <br>void <br>cpicinit_get_password(CPICINIT * cpicinit) <br>{ <br>    write_output("\nPassword: ");           /* display the prompt            */ <br> <br>    if (!get_password(cpicinit-&gt;password, sizeof(cpicinit-&gt;password)-1)) { <br>        cpicinit-&gt;set_password = SET; <br>        cpicinit-&gt;security_type = XC_SECURITY_PROGRAM; <br>    } <br>    return; <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_set_security_type <br> * <br> *****************************************************************************/ <br>void <br>cpicinit_set_security_type(CPICINIT * cpicinit, <br>                           unsigned long security_type) <br>{ <br>    cpicinit-&gt;security_type = security_type; <br>} <br> <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_setup_conversation <br> * <br> *  The goal of this procedure is to initialize a CPI-C conversation ID <br> *  and make sure that partner destination information is all specified. <br> *  This destination information includes partner LU name, mode name, <br> *  and TP name. <br> * <br> *  To be as flexible as possible, the destination parameter can serve <br> *  a dual role.  If specified, the destination is first used as the <br> *  symbolic destination name.  If this does not produce a valid partner <br> *  LU name, another symbolic destination name will be used and the <br> *  destination parameter will be used instead as a partner LU name. <br> * <br> *  AN OVERVIEW OF THE PROCEDURE <br> * <br> *  If the destination was SET <br> *      use destination as a symbolic destination name <br> *      If CMINIT failed or there was no partner LU name extracted <br> *          use the default symbolic destination name or all blanks <br> *          use the destination as a partner LU name <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_setup_conversation(CPICINIT *      cpicinit, <br>                            unsigned char * cm_conv_id, <br>                            CPICERR *       cpicerr) <br>{ <br>    CM_INT32 cm_rc = CM_OK; <br>    CM_INT32 length; <br>    int      dest_len; <br>    char sym_dest_name[9]; <br> <br>    /* check if a destination was set by the cpicinit_set_destination() call */ <br>    if (cpicinit-&gt;set_destination == SET) { <br> <br>        /* check if the destination could be a symbolic destination name     */ <br>        if (((dest_len = strlen(cpicinit-&gt;destination)) &lt; <br>                                                         MAX_SYM_DEST_NAME)) { <br>            /* <br>             * Try to use the specified destination as a symbolic <br>             * destination name.  A symbolic destination name is blank <br>             * padded and must contain all uppercase characters. <br>             */ <br> <br>            memset(sym_dest_name,           /* Initialize the sym dest name  */ <br>                   ' ',                     /* to all blanks.                */ <br>                   sizeof(sym_dest_name)); <br> <br>            memcpy(sym_dest_name,           /* Copy the destination into the */ <br>                   cpicinit-&gt;destination,   /* sym dest name.                */ <br>                   dest_len); <br>                                            /* place the null terminator     */ <br>            sym_dest_name[MAX_SYM_DEST_NAME - 1] = '\0'; <br> <br>            strupr(sym_dest_name);          /* sym dest must be uppercase    */ <br> <br>            /* <br>             * Since we are using the destination as a sym_dest, make sure <br>             * we don't also use it as a partner LU name. <br>             */ <br>            cpicinit-&gt;set_destination = NOT_SET; <br> <br>            cminit(cm_conv_id, <br>                   (unsigned char *)sym_dest_name, <br>                   &amp;cm_rc); <br> <br>        } else { <br>            /* <br>             * The destination was too long to be a symbolic destination name. <br>             */ <br>        } <br> <br> <br> <br>        if (cm_rc != CM_OK || !cpicinit_pln_valid(cm_conv_id)) { <br> <br>            /* <br>             * Since the destination was not a sym_dest, we can use it <br>             * later as a partner LU name. <br>             */ <br>            cpicinit-&gt;set_destination = SET; <br> <br>            /* <br>             * Try to use the default symbolic destination name.  If <br>             * configured, this symbolic destination can be used to <br>             * initialize the partner LU name and mode name entries, <br>             * or left blank. <br>             */ <br>            cminit(cm_conv_id, <br>                   (unsigned char *)cpicinit-&gt;def_sym_dest_name, <br>                   &amp;cm_rc); <br> <br>            if (cm_rc != CM_OK) { <br>                /* <br>                 * Nothing else worked, so let's try the blank symbolic <br>                 * destination name.  All CPI-C values will be initialized <br>                 * to non usable values. <br>                 */ <br>                cminit(cm_conv_id, <br>                       (unsigned char *)BLANK_SYM_DEST_NAME, <br>                       &amp;cm_rc); <br>                if (cm_rc != CM_OK) { <br>                    return cpicerr_handle_rc(cpicerr, MSG_CMINIT, cm_rc); <br>                } <br> <br>                /* <br>                 * Since the blank symbolic destination name was used, <br>                 * we must set the partner LU name and mode even if we <br>                 * use the defaults. <br>                 */ <br>                cpicinit-&gt;set_destination = cpicinit-&gt;set_mode_name = SET; <br> <br>            } <br> <br>        } <br> <br>    } else { <br>        /* <br>         * Although no destination was specified, we can try to continue <br>         * by using the default symbolic destination name.  If this entry <br>         * is configured with a valid partner LU, we may be able to <br>         * establish a connection with a partner. <br>         */ <br>        cminit(cm_conv_id, <br>               (unsigned char * )cpicinit-&gt;def_sym_dest_name, <br>               &amp;cm_rc); <br>        if (cm_rc != CM_OK) { <br>            /* <br>             * Fill in conversation information for CPI-C error reporting. <br>             */ <br>            cpicerr_set_conv_id(cpicerr, cm_conv_id); <br>            return cpicerr_handle_rc(cpicerr, MSG_CMINIT, cm_rc); <br>        } <br>    } <br> <br>    /* <br>     * Fill in conversation information for CPI-C error reporting. <br>     */ <br>    cpicerr_set_conv_id(cpicerr, cm_conv_id); <br> <br>    if (cpicinit-&gt;set_destination == SET) { <br>        CM_INT32 dest_length; <br>        dest_length = strlen(cpicinit-&gt;destination); <br> <br>#if defined(PLN_COULD_REQUIRE_LOWERCASE) <br>        /* <br>         * strupr should only be performed if the partner LU name is <br>         * a fully qualified name. <br>         */ <br>#ifdef FAPI <br>        if ((strchr(cpicinit-&gt;destination,'.') != NULL) || <br>            (get_machine_mode() == 0)) { <br>            strupr(cpicinit-&gt;destination); <br>        } <br>#else <br>        if (strchr(cpicinit-&gt;destination,'.') != NULL) { <br>            strupr(cpicinit-&gt;destination); <br>        } <br>#endif <br>#else <br>        strupr(cpicinit-&gt;destination); <br>#endif <br> <br>        cmspln(cm_conv_id,                  /* Set partner LU name           */ <br>               (unsigned char *)cpicinit-&gt;destination, <br>               &amp;dest_length, <br>               &amp;cm_rc); <br>        if (cm_rc != CM_OK) <br>            return cpicerr_handle_rc(cpicerr, MSG_CMSPLN, cm_rc); <br>    } <br> <br>    /* <br>     * Since there is no way to query the TP name, we will always set it. <br>     * The default TP name can be overridden on the cpicinit_set_tp_name <br>     * call. <br>     */ <br> <br>    length = strlen(cpicinit-&gt;tp_name); <br>    cmstpn(cm_conv_id,                      /* Set TP name                   */ <br>           (unsigned char *)cpicinit-&gt;tp_name, <br>           &amp;length, <br>           &amp;cm_rc); <br>    if (cm_rc != CM_OK) <br>        return cpicerr_handle_rc(cpicerr, MSG_CMSTPN, cm_rc); <br> <br>    /* <br>     * If there was a cpicinit_set_mode_name call made previously or <br>     * present mode name is not initialized, we need to set the mode <br>     * name. <br>     */ <br>    if ((cpicinit-&gt;set_mode_name == SET) || <br>                                         !cpicinit_mode_valid(cm_conv_id)) { <br>        length = strlen(cpicinit-&gt;mode_name); <br>        cmsmn(cm_conv_id,                   /* Set mode name                 */ <br>              (unsigned char *)cpicinit-&gt;mode_name, <br>              &amp;length, <br>              &amp;cm_rc); <br>        if (cm_rc != CM_OK) <br>            return cpicerr_handle_rc(cpicerr, MSG_CMSMN, cm_rc); <br>    } <br> <br>#if defined(SUPPORTS_SETTING_SECURITY) <br>    /* <br>     * If there was a cpicinit_set_userid AND cpicinit_set_password call made <br>     * previously, we need to set the security parameters.  The security <br>     * functions are not available on all CPI-C platforms. <br>     */ <br> <br>    if (cpicinit-&gt;security_type == XC_SECURITY_NONE) { <br>        CM_INT32 security_type; <br>        security_type = XC_SECURITY_NONE; <br>        xcscst(cm_conv_id,                  /* Set Security Type             */ <br>               &amp;security_type, <br>               &amp;cm_rc); <br>        if (cm_rc != CM_OK) <br>            return cpicerr_handle_rc(cpicerr, MSG_XCSCST, cm_rc); <br>    } else { <br>        if ((cpicinit-&gt;set_userid == SET) &amp;&amp; (cpicinit-&gt;set_password == SET)) { <br>            CM_INT32 security_type; <br>            security_type = XC_SECURITY_PROGRAM; <br>            xcscst(cm_conv_id,              /* Set Security Type             */ <br>                   &amp;security_type, <br>                   &amp;cm_rc); <br>            if (cm_rc != CM_OK) <br>                return cpicerr_handle_rc(cpicerr, MSG_XCSCST, cm_rc); <br> <br>            length = strlen(cpicinit-&gt;userid); <br>            xcscsu(cm_conv_id,              /* Set Security Userid           */ <br>                   (unsigned char *)cpicinit-&gt;userid, <br>                   &amp;length, <br>                   &amp;cm_rc); <br>            if (cm_rc != CM_OK) <br>                return cpicerr_handle_rc(cpicerr, MSG_XCSCSU, cm_rc); <br> <br>            length = strlen(cpicinit-&gt;password); <br>            xcscsp(cm_conv_id,              /* Set Security Password         */ <br>                   (unsigned char *)cpicinit-&gt;password, <br>                   &amp;length, <br>                   &amp;cm_rc); <br>            if (cm_rc != CM_OK) <br>                return cpicerr_handle_rc(cpicerr, MSG_XCSCSP, cm_rc); <br> <br>        } <br>    } <br> <br>#endif <br> <br>    return FALSE; <br>} <br> </code></pre>
<p>
</p>
<pre><code><br>/****************************************************************************** <br> * <br> *  cpicinit_destroy <br> * <br> *  This function is the inverse of the cpicinit_new() call.  All memory <br> *  allocated by cpicinit_new() is freed. <br> * <br> *  This function has no return code. <br> * <br> *****************************************************************************/ <br>void <br>cpicinit_destroy(CPICINIT * cpicinit) <br>{ <br>    free(cpicinit); <br>    return; <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_pln_valid <br> * <br> *  Internal function, used by cpic_setup_conversation(). <br> * <br> *  This function is used after a cminit() call to ensure that there was <br> *  a partner LU name configured with the symbolic destination used on <br> *  cminit().  If there was no partner LU name configured with the symbolic <br> *  destination name, a partner LU name will have to be set with the cmspln() <br> *  call. <br> * <br> *  Returns: <br> *    TRUE  if a partner LU name was configured <br> *    FALSE is there was no partner LU name configured <br> * <br> *****************************************************************************/ <br>int <br>cpicinit_pln_valid(unsigned char * cm_conv_id) <br>{ <br>    unsigned char  destination[MAX_DESTINATION]; /* variable to store the    */ <br>                                            /* extracted partner LU name     */ <br>    CM_INT32       length = 0;              /* length of partner LU name     */ <br>    CM_RETURN_CODE cm_rc;                   /* CPI-C return code             */ <br>    int            rc;                      /* procedure return code         */ <br> <br>    cmepln(cm_conv_id,                      /* extract partner LU name       */ <br>           destination, <br>           &amp;length,                         /* length of partner LU name     */ <br>           &amp;cm_rc ); <br> <br>    if (cm_rc != CM_OK || (length == 1 &amp;&amp; destination[0] == ' ')) { <br>        rc = FALSE; <br>    } else { <br>        rc = TRUE; <br>    } <br>    return rc; <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicinit_mode_valid <br> * <br> *  Internal function, used by cpic_setup_conversation(). <br> * <br> *  This function is used after a cminit() call to ensure that there was <br> *  a mode name configured with the symbolic destination used on  cminit(). <br> *  If there was no mode name configured with the symbolic destination name, <br> *  a partner LU name will have to be set with the cmsmn() call. <br> * <br> *  Returns: <br> *    TRUE  if a mode name was configured <br> *    FALSE is there was no mode name configured <br> * <br> *****************************************************************************/ <br>cpicinit_mode_valid(unsigned char * cm_conv_id) <br>{ <br>    unsigned char  mode[MAX_MODE_NAME];     /* variable to store the         */ <br>                                            /* extracted mode name           */ <br>    CM_INT32       length = 0;              /* length of mode name           */ <br>    CM_RETURN_CODE cm_rc;                   /* CPI-C return code             */ <br>    int            rc;                      /* procedure return code         */ <br> <br>    cmemn(cm_conv_id,                       /* extract mode name             */ <br>          mode, <br>          &amp;length, <br>          &amp;cm_rc ); <br> <br>    if (cm_rc != CM_OK || length == 0) { <br>        rc = FALSE; <br>    } else { <br>        rc = TRUE; <br>    } <br>    return rc; <br> <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
