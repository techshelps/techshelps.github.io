<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPICERR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5128"></a>CPICERR.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  MODULE NAME: CPICERR.C <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:    Peter J. Schwaller <br> *             VNET:     PJS at RALVM6           Tie Line: 444-4376 <br> *             Internet: pjs@ralvm6.vnet.ibm.com     (919) 254-4376 <br> * <br> *             John Q. Walker <br> *             VNET:     JOHNQ at RALVM6         Tie Line: 444-4414 <br> *             Internet: johnq@ralvm6.vnet.ibm.com   (919) 254-4414 <br> * <br> *  FUNCTION:  Contains procedures to be called for handling <br> *             unexpected CPI-C return codes. <br> *             Contains procedures to be called for handling the <br> *             CPI-C error information cpicerr. <br> * <br> *  AVAILABILITY: <br> *             These sample programs and source are also available on <br> *             CompuServe through the APPC Information Exchange.  To get <br> *             to the APPC forum just type 'GO APPC' from any CompuServe <br> *             prompt.  The samples are available in the Sample Programs <br> *             library section.  Just search on the keyword CPICPGMS to <br> *             find all the samples in this series. <br> * <br> *             Updates for the sample programs and support for many more <br> *             CPI-C platforms will also be made available on CompuServe. <br> * <br> *  RELATED FILES: <br> *             CPICERR.H <br> * <br> *  CHANGE HISTORY: <br> *  Date       Description <br> *  08/05/92   Version 2.31 of APING, ATELL and AREXEC released to CompuServe. <br> *             This version was also distributed at the APPC/APPN Platform <br> *             Developer's Conference held in Raleigh, NC. <br> *  08/13/92   Changed all printf and fprintf calls to use a write_*() call. <br> *             Changed cpicerr_handle_rc() to a macro referencing a new call, <br> *             cpicerr_handle_rc_extended().  The macro adds the current <br> *             source file and line number to improve source code debugging. <br> *  08/15/92   Changed cpicerr_exchange_version() to receive 128 bytes <br> *             instead of 3 bytes.  This change was also made to the <br> *             NS/DOS ship code. <br> *  08/18/92   Removed extra newline in cpicerr_show_rc(). <br> *  09/02/92   Fixed bug in cpicerr_log_cpicerr() when the log_file_path <br> *             was a zero length string. <br> *  11/15/92   Changed reply structure to include 2 byte indicator. <br> *  11/17/92   Added send/receipt of operating system string. <br> *             Added cpicerr_exchange_version_plus() to return the string. <br> * <br> *****************************************************************************/ <br> <br>/***************************************************************************** <br> * <br> * OVERVIEW OF CPICERR CALLS <br> * <br> * cpicerr_new()                      Creates a CPICERR object. <br> *                                    This must be done before any other <br> *                                    cpicerr calls can be used. <br> * <br> * These calls set values in the cpicerr object structure and affect how <br> * cpicerr_handle_rc reacts to errors. <br> * <br> * cpicerr_set_conv_id()              Used to extract conversation state info <br> * cpicerr_set_exit_level()           Level of error on which to exit <br> * cpicerr_set_log_file_name()        What filename to use for logging <br> * cpicerr_set_log_file_path()        Where the filename is <br> * cpicerr_set_log_level()            Level of error on which to log errors <br> * cpicerr_set_major_version()        8 bit int - see cpicerr_exchange_version <br> * cpicerr_set_minor_version()        8 bit int - see cpicerr_exchange_version <br> * cpicerr_set_program_name()         String - Output as part of log info <br> * cpicerr_set_program_info()         String - Output as part of log info <br> * cpicerr_set_show_level()           Level of error on which to show errors <br> * <br> * cpicerr_handle_rc()                Should be called by the program for all <br> *                                    UNEXPECTED return codes. <br> *                                    Functions performed are: <br> *                                       Classification of the return code <br> *                                       Showing partial info to end user <br> *                                       Logging complete info to disk <br> *                                    This is a macro that actually expands <br> *                                    to cpicerr_handle_rc_extended(). <br> * <br> * cpicerr_exchange_version()         Exchanges version numbers with the <br> *                                    partner.  Very useful when supporting <br> *                                    multiple versions of a program. <br> * <br> * cpicerr_destroy()                  Destroys the CPICERR  object. <br> * <br> * <br> * cpicerr_classify_rc()              These are internal calls used by <br> * cpicerr_show_rc()                  other cpicerr_handle_rc. <br> * cpicerr_log_rc() <br> * cpicerr_log_cpicerr() <br> * cpicerr_get_message() <br> * cpicerr_set_rc_info() <br> * cpicerr_show_product_info() <br> * <br> *****************************************************************************/ <br>#if defined(WIN32) || defined(WINDOWS)                                /*WIN32*/ <br>#include &lt;windows.h&gt;                                                  /*WIN32*/ <br>#define GET_OS2_SENSE_DATA                                            /*WIN32*/ <br>#endif                                                                /*WIN32*/ <br> <br>#include "wincpic.h" <br> <br>#ifdef GET_OS2_SENSE_DATA <br>#include &lt;winappc.h&gt; <br>#endif <br> <br>/* Set up constant declarations */ <br>#include "cpicdefs.h" <br> <br>/* Collection of routines with special ported version for each platform */ <br>#include "cpicport.h" <br> <br>#include &lt;stdio.h&gt;                          /* C library includes            */ <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include &lt;time.h&gt; <br> <br>#include "cpicerrs.h"                       /* CPI-C error handling vars.    */ <br> <br>/* <br> * Each of the following is a list of messages, which are actually defined <br> * in this file below.  The messages are grouped together.  For example, <br> * all of the return code messages are in the cpicerr_return_codes list. <br> */ <br>extern CPICERR_MESSAGE cpicerr_verbs_short[]; <br>extern CPICERR_MESSAGE cpicerr_verbs_long[]; <br>extern CPICERR_MESSAGE cpicerr_return_codes[]; <br>extern CPICERR_MESSAGE cpicerr_rc_classes[]; <br>extern CPICERR_MESSAGE cpicerr_states_conv[]; <br>extern CPICERR_MESSAGE cpicerr_conv_types[]; <br>extern CPICERR_MESSAGE cpicerr_sync_levels[]; <br> <br>/***************************************************************************** <br> * Function prototypes for internal routines.  In general, these should <br> * not be called directly by an application program. <br> *****************************************************************************/ <br>void   cpicerr_classify_rc(      CM_RETURN_CODE       conv_rc, <br>                                 CPIC_RC_HANDLING *   classification); <br>void   cpicerr_show_rc(          CPICERR *            cpicerr); <br>void   cpicerr_log_rc(           CPICERR *            cpicerr, <br>                                 FILE *               log_file); <br>int    cpicerr_log_cpicerr(      CPICERR *            cpicerr, <br>                                 char *               file_name, <br>                                 int                  file_line); <br>char * cpicerr_get_message(      CPICERR_MESSAGE_TYPE message_type, <br>                                 CM_INT32             index); <br>void   cpicerr_set_rc_info(      CPICERR *            cpicerr, <br>                                 CPIC_VERB_INDEX      verb_index, <br>                                 CM_RETURN_CODE       conv_rc); <br>void   cpicerr_show_product_info(CPICERR *            cpicerr); <br> <br>/***************************************************************************** <br> * The following function prototypes and macros are used only by the <br> * OS/2 specific code used to obtain the sense data after an <br> * allocation failure.  They are not necessary, if GET_OS2_SENSE_DATA <br> * has not been externally defined (with the -D compile flag). <br> *****************************************************************************/ <br>#ifdef GET_OS2_SENSE_DATA <br>int    cpicerr_os2_appc_allocate(CPICERR *            cpicerr); <br> <br>int <br>parse_destination(char * in_string, <br>                  char * plu_alias, <br>                  char * fqplu_name); <br> <br> <br> <br> <br>/* Macro BLANK_STRING sets string to all blanks */ <br>#define BLANK_STRING(str)  memset(str,(int)' ',sizeof(str)) <br> <br>#undef CLEAR_VCB <br>/* Macro CLEAR_VCB sets the APPC verb control block to zeros */ <br>#define CLEAR_VCB(vcb)     memset((char *)&amp;vcb,(int)'\0',sizeof(vcb)) <br> <br>/* convert a string to uppercase, up to length specified */ <br>#define TOUPPER_STRING(str,length) \ <br>                           {int i; for (i=0;i &lt; length;i ++) \ <br>                           {str[i] = (char)toupper(str[i]);}} <br> <br>/* convert an ASCII blank padded string to an ASCIIZ string without pads */ <br>#define SNA2STRING(outstr, instr, max_length) \ <br>                   {int i; for (i=0;i &lt; max_length &amp;&amp; instr[i] != ' ';i ++) \ <br>                   {outstr[i] = instr[i];} outstr[i] = '\0';} <br> <br>#endif <br> <br> <br>/* <br> * The error REPLY routines below are experimental and may change <br> * at any time! <br> */ <br> <br>void <br>cpicerr_show_reply(CPICERR_REPLY * reply) <br>{ <br>    unsigned short length; <br>    unsigned short offset; <br>    unsigned short indicator; <br>    int            rc = 0; <br> <br>    if (reply-&gt;length &gt;= CPICERR_REPLY_MIN_LENGTH) { <br>        write_error( <br>            "\nAn application error was detected by the partner:\n"); <br>        indicator = <br>          convert_short_from_network( <br>              *((unsigned short*)&amp;reply-&gt;buffer[CPICERR_REPLY_INDICATOR])); <br>        if (indicator == CPICERR_REPLY_INDICATOR_VALUE) { <br>            write_error("Response:              %d\n", <br>                        (int)reply-&gt;buffer[CPICERR_REPLY_RESPONSE]); <br>            write_error("Message Category:      %u\n", <br>              convert_short_from_network( <br>                  *((unsigned short*)&amp;reply-&gt;buffer[CPICERR_REPLY_CATEGORY]))); <br>            write_error("Primary Code:          %ld\n", <br>              convert_long_from_network( <br>                  *((unsigned long *)&amp;reply-&gt;buffer[CPICERR_REPLY_PRIMARY]))); <br>            write_error("Secondary Code:        %ld\n", <br>              convert_long_from_network( <br>                 *((unsigned long *)&amp;reply-&gt;buffer[CPICERR_REPLY_SECONDARY]))); <br> <br> <br>            if (reply-&gt;length &gt;= <br>                (unsigned int)(CPICERR_REPLY_MIN_LENGTH + 2)) { <br>                length = convert_short_from_network( <br>                *((unsigned short *) <br>                               &amp;reply-&gt;buffer[CPICERR_REPLY_PRIMARY_LENGTH])); <br> <br>                if (reply-&gt;length &gt;= <br>                    (unsigned int)(CPICERR_REPLY_PRIMARY_TEXT+length)) { <br>                    reply-&gt;buffer[length + CPICERR_REPLY_PRIMARY_TEXT - 1] = <br>                                                                          '\0'; <br>                    write_error("%s\n", <br>                                &amp;reply-&gt;buffer[CPICERR_REPLY_PRIMARY_TEXT]); <br>                    offset = CPICERR_REPLY_PRIMARY_TEXT + length; <br>                    if (reply-&gt;length &gt;= 2+offset) { <br>                        length = convert_short_from_network( <br>                                  *((unsigned short *)&amp;reply-&gt;buffer[offset])); <br>                        if (reply-&gt;length &gt;= (offset+ 2 +length)) { <br>                            reply-&gt;buffer[length + offset + 2] = '\0'; <br>                            write_error("%s\n", &amp;reply-&gt;buffer[offset+2]); <br>                        } <br>                        else { <br>                            rc = 1; <br>                        } <br>                    } <br>                    else { <br>                        rc = 1; <br>                    } <br>                } <br>                else { <br>                    rc = 1; <br>                } <br>            } <br>            else { <br>                write_error("No text strings were sent.\n"); <br>            } <br>        } <br>        else { <br>            write_error("Record received was not a reply structure.\n"); <br>        } <br> <br>    } <br>    else { <br>        rc = 1; <br>    } <br>    if (rc) { <br>        write_error("Reply length error in cpicerr_show_reply().\n"); <br>    } <br>} <br> <br> <br>CPICERR_REPLY * <br>cpicerr_create_reply(unsigned int primary_message_buffer_size, <br>                     unsigned int secondary_message_buffer_size) <br>{ <br>    CPICERR_REPLY * reply; <br> <br>    reply = calloc(1, sizeof(CPICERR_REPLY)); <br>    if (reply == NULL) { <br>        return NULL; <br>    } <br> <br>    reply-&gt;buffer_length = CPICERR_REPLY_MIN_LENGTH+ <br>                           primary_message_buffer_size+1 + <br>                           secondary_message_buffer_size+1 + <br>                           4;          /* two length fields */ <br>    reply-&gt;buffer = calloc(reply-&gt;buffer_length, 1); <br>    if (reply == NULL) { <br>        return NULL; <br>    } <br> <br>    return reply; <br>} <br> <br>void <br>cpicerr_destroy_reply(CPICERR_REPLY * reply) <br>{ <br>    /* <br>     * Make sure we don't free any NULL pointers! <br>     */ <br>    if (reply != NULL) { <br>        if (reply-&gt;buffer != NULL) { <br>            free(reply-&gt;buffer); <br>        } <br>        free(reply); <br>    } <br>} <br> <br> <br> <br>/* <br> * Requires that cpicerr_set_conv_id() has been called. <br> */ <br>int    cpicerr_recv_appl_error(CPICERR *  cpicerr, <br>                               CPICERR_REPLY * reply) <br>{ <br>    CM_RETURN_CODE cm_rc; <br>    CM_INT32  rts_received; <br>    CM_INT32  max_receive_len; <br>    CM_INT32  what_received; <br>    CM_INT32  received_len; <br>    CM_INT32  status_received; <br> <br>    max_receive_len = reply-&gt;buffer_length; <br> <br>    cmrcv (cpicerr-&gt;conversation_id, <br>           reply-&gt;buffer, <br>           &amp;max_receive_len, <br>           &amp;what_received, <br>           &amp;received_len, <br>           &amp;status_received, <br>           &amp;rts_received, <br>           &amp;cm_rc); <br> <br>    reply-&gt;length = (unsigned int)received_len; <br> <br>    return reply-&gt;buffer[0]; <br>} <br> <br> <br>void <br>cpicerr_set_error_reply(CPICERR_REPLY * reply, <br>                        REPLY_RESPONSE  response, <br>                        unsigned int    message_category, <br>                        unsigned long   primary_code, <br>                        char *          primary_message_text, <br>                        unsigned long   secondary_code, <br>                        char *          secondary_message_text) <br>{ <br>    unsigned int length = 0; <br>    unsigned short string_length; <br> <br>    /* <br>     * Check and see that there is at least enough space in the reply_buffer <br>     * to sent the required fields.  If there is not enough space, return <br>     * 0 (zero) to the caller, indicating that no bytes were copied into <br>     * the reply_buffer. <br>     */ <br>    if (reply-&gt;buffer_length &lt; CPICERR_REPLY_MIN_LENGTH) { <br>        reply-&gt;length = 0; <br>        return/* 0 */; <br>    } <br> <br>    *((unsigned short *)&amp;reply-&gt;buffer[CPICERR_REPLY_INDICATOR]) = <br>                       convert_short_to_network(CPICERR_REPLY_INDICATOR_VALUE); <br>    reply-&gt;buffer[CPICERR_REPLY_RESPONSE] = (char)response; <br>    reply-&gt;buffer[CPICERR_REPLY_RESERVED] = 0; /* set reserved byte to zero  */ <br>    *((unsigned short *)&amp;reply-&gt;buffer[CPICERR_REPLY_CATEGORY]) = <br>                            convert_short_to_network(message_category); <br>    *((unsigned long *)&amp;reply-&gt;buffer[CPICERR_REPLY_PRIMARY]) = <br>                            convert_long_to_network(primary_code); <br>    *((unsigned long *)&amp;reply-&gt;buffer[CPICERR_REPLY_SECONDARY]) = <br>                            convert_long_to_network(secondary_code); <br>    length = CPICERR_REPLY_MIN_LENGTH; <br> <br> <br>    /* check length of buffer!!! */ <br> <br>    /* <br>     * Copy the length and text of the primary message. <br>     */ <br>    string_length = strlen(primary_message_text) + 1; <br>    *((unsigned short *)&amp;reply-&gt;buffer[CPICERR_REPLY_PRIMARY_LENGTH]) = <br>                  convert_short_to_network(string_length); <br>    memcpy(&amp;reply-&gt;buffer[CPICERR_REPLY_PRIMARY_TEXT], <br>           primary_message_text, <br>           string_length); <br>    convert_to_ascii(&amp;reply-&gt;buffer[CPICERR_REPLY_PRIMARY_TEXT], <br>                     string_length); <br> <br>    length += 2 + string_length; <br> <br>    /* <br>     * Copy the length and text of the secondary message. <br>     */ <br>    string_length = strlen(secondary_message_text) + 1; <br>    *((unsigned short *)&amp;reply-&gt;buffer[length]) = <br>              convert_short_to_network(string_length); <br>    memcpy(&amp;reply-&gt;buffer[length+2], <br>           secondary_message_text, <br>           string_length); <br>    convert_to_ascii(&amp;reply-&gt;buffer[length+2], <br>                     string_length); <br> <br>    length += 2 + string_length; <br> <br>    reply-&gt;length = length; <br> <br>    return /* length */; <br>} <br> <br> <br> <br> <br>/* <br> * Requires that cpicerr_set_conv_id() has been called. <br> */ <br> <br>int <br>cpicerr_send_appl_error( CPICERR *       cpicerr, <br>                         NEXT_STATE      next_state, <br>                         CPICERR_REPLY * reply) <br>{ <br>    CM_RETURN_CODE  cm_rc; <br>    CM_INT32        length; <br>    CM_INT32        rts_received; <br>    CM_SEND_TYPE    send_type; <br> <br>    cmserr(cpicerr-&gt;conversation_id, <br>           &amp;rts_received, <br>           &amp;cm_rc); <br> <br> <br>    switch (next_state) { <br>        case NEXT_DEALLOCATE: <br>        case NEXT_DEALLOCATE_AND_EXIT: <br>            send_type = CM_SEND_AND_DEALLOCATE; <br>            { <br>            CM_INT32 deallocate_type = CM_DEALLOCATE_FLUSH; <br>            cmsdt(cpicerr-&gt;conversation_id, <br>                  &amp;deallocate_type, <br>                  &amp;cm_rc); <br>            } <br>            break; <br>        case NEXT_SEND: <br>            send_type = CM_SEND_AND_FLUSH; <br>            break; <br>        case NEXT_RECEIVE: <br>            send_type = CM_SEND_AND_PREP_TO_RECEIVE; <br>            { <br>            CM_PREPARE_TO_RECEIVE_TYPE ptr_type; <br>            ptr_type = CM_PREP_TO_RECEIVE_FLUSH; <br>            cmsptr (cpicerr-&gt;conversation_id, <br>                    &amp;ptr_type, <br>                    &amp;cm_rc); <br>            } <br>            break; <br>    } <br> <br>    cmsst (cpicerr-&gt;conversation_id, <br>           &amp;send_type, <br>           &amp;cm_rc); <br>#if 1 <br>    if (cm_rc != CM_OK) { <br>        printf("Ouch!!!!!!!!\n"); <br>    } <br>    else { <br>    } <br>#endif <br> <br>    length = reply-&gt;length; <br> <br>    cmsend (cpicerr-&gt;conversation_id, <br>            reply-&gt;buffer, <br>            &amp;length, <br>            &amp;rts_received, <br>            &amp;cm_rc); <br> <br>    if (next_state == NEXT_DEALLOCATE_AND_EXIT) { <br>        exit(EXIT_FAILURE); <br>    } <br> <br>#if 1 <br>    printf("didn't exit\n"); <br>#endif <br> <br>return0; <br> <br>} <br> <br> <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_new() <br> * <br> *  Usage: <br> *  This function creates a CPICERR object which should be used on all <br> *  subsequent calls to cpicerr.  If an error occurs and a valid object <br> *  cannot be created, NULL will be returned. <br> * <br> *****************************************************************************/ <br>CPICERR * <br>cpicerr_new(void) <br>{ <br>    CPICERR *  cpicerr; <br> <br>    /*-----------------------------------------------------------------------* <br>     * Allocate a block for the CPICERR structure.  calloc() will initialize <br>     * all bytes to 0. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr = (CPICERR *) calloc(1, sizeof(*cpicerr)); <br>    if (cpicerr == NULL) { <br>        return NULL; <br>    } <br> <br> <br>    /*-----------------------------------------------------------------------* <br>     * Save the time of program initialization. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;program_start_time = time(NULL); <br> <br>    /*-----------------------------------------------------------------------* <br>     * Indicate that the conversation id field has not been set. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;conv_id_set = FALSE; <br> <br> <br>    /*-----------------------------------------------------------------------* <br>     * Initialize version levels.  0 indicates they have not been set. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;major_version = 0; <br>    cpicerr-&gt;minor_version = 0; <br> <br>    /*-----------------------------------------------------------------------* <br>     * Initialize to always exit after an error occurs. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;exit_level = ALL_ERRORS; <br> <br>    /*-----------------------------------------------------------------------* <br>     * Initialize to always show errors. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;show_level = ALL_ERRORS; <br> <br>    /*-----------------------------------------------------------------------* <br>     * Initialize to always log errors. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;log_level = ALL_ERRORS; <br> <br>    /*-----------------------------------------------------------------------* <br>     * Indicate that cpicerr should process all ERROR_RECEIVED return codes <br>     * (indicating our partner issued Send_Error()) <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;handle_error = TRUE; <br> <br>    /*-----------------------------------------------------------------------* <br>     * Initialize strings to NULL in case 0 != NULL <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;program_name  = NULL; <br>    cpicerr-&gt;program_info  = NULL; <br>    cpicerr-&gt;log_file_name = NULL; <br>    cpicerr-&gt;log_file_path = NULL; <br> <br> <br>    /*-----------------------------------------------------------------------* <br>     * Set the conversation characteristics to invalid values.  If this <br>     * isn't done, we could display seemingly valid values for these <br>     * parameters even though they were never set properly. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;conversation_type  = MAX_MESSAGE; <br>    cpicerr-&gt;conversation_state = MAX_MESSAGE; <br>    cpicerr-&gt;sync_level         = MAX_MESSAGE; <br> <br>    return cpicerr; <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_conv_id <br> * <br> *  Usage: <br> *  This call should be used just before the cmallc call (for clients), <br> *  or just after the cmaccp call (for servers). <br> * <br> *  This routine will save the conversation id, as well as partner information <br> *  and conversation status which can be extracted from CPI-C. <br> * <br> *  This information is often helpful for debugging and in many cases cannot <br> *  be obtained after an error occurs, since you no longer have a valid <br> *  conversation id after the conversation has been deallocated. <br> * <br> *  Returns 0 if everything was processed successfully. <br> *  Returns 1 if an error occurred.  In general, the only reason for an <br> *     error to occur is if one of the passed parameters is invalid.  Since <br> *     this is just storing information in the footprint, we will not <br> *     attempt to do sophisticated error processing in this procedure. <br> * <br> *****************************************************************************/ <br>int <br>cpicerr_set_conv_id(CPICERR *       cpicerr, <br>                    unsigned char * conversation_id) <br>{ <br>    CM_RETURN_CODE        conv_rc;          /* Return code from CPI-C call   */ <br>    int                   rc;               /* return value for function     */ <br> <br> <br>    if (cpicerr != (CPICERR *)NULL) { <br>        /*-------------------------------------------------------------------* <br>         * Save the conversation ID. <br>         * This can often be used in conjunction with error logs or trace <br>         * utilities. <br>         *-------------------------------------------------------------------*/ <br>        memcpy(cpicerr-&gt;conversation_id, <br>               conversation_id, <br>               sizeof(cpicerr-&gt;conversation_id)); <br> <br>        /* <br>         * Extract the conversation type. <br>         */ <br>        cmect(conversation_id,              /* Current conversation ID       */ <br>              &amp;cpicerr-&gt;conversation_type,  /* Returned conversation type    */ <br>              &amp;conv_rc);                    /* Put the return code here      */ <br>        if (conv_rc != CM_OK) { <br>            /* <br>             * Set the conversation type to an invalid value and set <br>             * the return code to indicate an error. <br>             */ <br>            cpicerr-&gt;conversation_type = MAX_MESSAGE; <br>            rc = 1; <br>        } <br> <br>        /* <br>         * Extract the mode name used for this conversation. <br>         */ <br>        cmemn(conversation_id,              /* Current conversation ID       */ <br>              cpicerr-&gt;mode_name,           /* Returned mode name            */ <br>              &amp;(cpicerr-&gt;mode_name_length), /* Returned mode name length     */ <br>              &amp;conv_rc);                    /* Put the return code here      */ <br>        if (conv_rc != CM_OK) { <br>            /* <br>             * Make sure the mode name is reset to uninitialized and <br>             * set the return code to indicate an error. <br>             */ <br>            cpicerr-&gt;mode_name_length = 0; <br>            rc = 1; <br>        } <br>        /* make sure we place the null terminator at the end of the string   */ <br>        cpicerr-&gt;mode_name[(int)cpicerr-&gt;mode_name_length] = '\0'; <br> <br>        /*-------------------------------------------------------------------* <br>         * Extract the partner's LU name. <br>         *-------------------------------------------------------------------*/ <br>        cmepln(conversation_id,             /* Current conversation ID       */ <br>               cpicerr-&gt;partner_LU_name,    /* Returned partner LU           */ <br>               &amp;(cpicerr-&gt;partner_LU_name_length),/* Partner LU name length  */ <br>               &amp;conv_rc);                   /* Put the return code here      */ <br>        if (conv_rc != CM_OK) { <br>            /* <br>             * Make sure the partner LU name is reset to uninitialized and <br>             * set the return code to indicate an error. <br>             */ <br>            cpicerr-&gt;partner_LU_name_length = 0; <br>            rc = 1; <br>        } <br>        /* make sure we place the null terminator at the end of the string   */ <br>        cpicerr-&gt;partner_LU_name[(int)cpicerr-&gt;partner_LU_name_length] = '\0'; <br> <br>        /*-------------------------------------------------------------------* <br>         * Extract the conversation sync level. <br>         *-------------------------------------------------------------------*/ <br>        cmesl(conversation_id,              /* Current conversation ID       */ <br>              &amp;cpicerr-&gt;sync_level,         /* Returned sync level           */ <br>              &amp;conv_rc);                    /* Put the return code here      */ <br>        if (conv_rc != CM_OK) { <br>            /* <br>             * Set the sync level to an invalid value and set <br>             * the return code to indicate an error. <br>             */ <br>            cpicerr-&gt;sync_level = MAX_MESSAGE; <br>            rc = 1; <br>        } <br> <br>        rc = 0; <br>    } else { <br>        rc = 1; <br>    } <br>    return rc; <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_exit_level <br> * <br> *  Usage: <br> *  Specify the CPI-C error classification as the exit level. <br> *  When cpicerr_handle_rc() is called, the return code will be classified. <br> *  If the classification is above the exit level, the program will be <br> *  terminated (after conversation cleanup). <br> * <br> *  A value of ALL_ERRORS can be used to force an exit on any call to <br> *  cpicerr_handle_rc().  This is the DEFAULT value. <br> * <br> *  A value of NO_ERRORS can be used to indicate that cpicerr should never <br> *  cause an exit.  Your application should handle all exit termination. <br> *  This is especially useful when using more than one conversation. <br> * <br> *  Also see: <br> *      cpicerr_set_log_level <br> *      cpicerr_set_show_level <br> *****************************************************************************/ <br>int <br>cpicerr_set_exit_level(CPICERR *        cpicerr, <br>                       CPIC_RC_HANDLING exit_level) <br>{ <br>    cpicerr-&gt;exit_level = exit_level; <br>    return 0; <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_log_file_name <br> * <br> *  Usage: <br> *  Sets the name of the log file to be used in cpicerr_handle_rc() to <br> *  log complete error information.  No attempt is made to verify that <br> *  the log_file_name specified is a valid filename or whether the file <br> *  can be opened.  If the log_file_name cannot be opened when logging <br> *  needs to be done, all log output will be sent to stderr instead. <br> * <br> *  For environments that support directory structures, you should specify <br> *  the filename on cpicerr_set_log_file_name and the directory on <br> *  cpicerr_set_log_file_path.  This allows your program to be isolated <br> *  from changes in environments that only support a single level </code></pre>
<p>
</p>
<pre><code>*  of directory (for example, VM). <br> * <br> *  Also see: <br> *      cpicerr_set_log_file_path <br> *      cpicerr_log_cpicerr (internal) <br> *****************************************************************************/ <br>int <br>cpicerr_set_log_file_name(CPICERR * cpicerr, <br>                          char *    log_file_name) <br>{ <br>    /*-----------------------------------------------------------------------* <br>     * Initialize the name of the log file. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;log_file_name = (char *) malloc(strlen(log_file_name)+1); <br>    if (cpicerr-&gt;log_file_name != NULL) { <br>        strcpy(cpicerr-&gt;log_file_name, log_file_name); <br>        return 0; <br>    } else { <br>        return 1; <br>    } <br> <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_log_file_path <br> * <br> *  Usage: <br> *  Specifies the path qualifier for the log file name specified in the <br> *  cpicerr_set_log_file_name call.  If cpicerr_set_log_file_path is used <br> *  without setting the log file name, no error logging will occur. <br> * <br> *  If you specify a string whose first character is a $, the rest of the <br> *  string will be looked for as an environment variable.  For example, <br> *  in OS/2, you put the following in your CONFIG.SYS: <br> *  SET LOGPATH=d:\logfiles <br> * <br> *  then specify $LOGPATH as a parameter on cpicerr_set_log_file_path. <br> * <br> *****************************************************************************/ <br>int <br>cpicerr_set_log_file_path(CPICERR * cpicerr, <br>                          char *    log_file_path) <br>{ <br>    char * path; <br>    int    rc; <br> <br>    /*-----------------------------------------------------------------------* <br>     * Initialize the name of the log file. <br>     * If the first character is a dollar sign ('$'), then try to extract <br>     * the log file path from the environment.  If not, use the path <br>     * as specified. <br>     *-----------------------------------------------------------------------*/ <br>    if (log_file_path[0] == '$') { <br>        path = getenv(&amp;log_file_path[1]); <br>    } else { <br>        path = log_file_path; <br>    } <br> <br>    /*-----------------------------------------------------------------------* <br>     * Check that we have a valid log file path string, allocate memory for <br>     * the string and copy it into the cpicerr structure. <br>     *-----------------------------------------------------------------------*/ <br>    if (path != NULL) { <br>        cpicerr-&gt;log_file_path = (char *) malloc(strlen(path)+1); <br>        if (cpicerr-&gt;log_file_path != NULL) { <br>            strcpy(cpicerr-&gt;log_file_path, path); <br>            rc = 0; <br>        } else { <br>            rc = 1; <br>        } <br>    } <br>    else { <br>        rc = 1; <br>    } <br>    return rc; <br> <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_log_level <br> * <br> *  Usage: <br> *  Specify the CPI-C error classification as the log level. <br> *  When cpicerr_handle_rc() is called, the return code will be classified. <br> *  If the classification is above the log level, the return code and <br> *  conversation information will be logged to the log file specified <br> *  with the cpicerr_set_log_file_name and cpicerr_set_log_file_path. <br> * <br> *  A value of ALL_ERRORS can be used to force logging on any call to <br> *  cpicerr_handle_rc().  This is the DEFAULT value.  This is especially <br> *  useful when used on servers. <br> * <br> *  A value of NO_ERRORS can be used to indicate that cpicerr should never <br> *  cause an error log.  Your application should handle all error logging. <br> * <br> *  Also see: <br> *      cpicerr_set_log_file_name <br> *      cpicerr_set_log_file_path <br> *      cpicerr_log_cpicerr (internal) <br> *      cpicerr_set_exit_level <br> *      cpicerr_set_show_level <br> *****************************************************************************/ <br>int <br>cpicerr_set_log_level(CPICERR *        cpicerr, <br>                      CPIC_RC_HANDLING log_level) <br>{ <br>    cpicerr-&gt;log_level = log_level; <br>    return 0; <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_major_version <br> * <br> *  Usage: <br> *  Sets the major version number for the application. <br> *  The version number can be 0-255. <br> * <br> *  The version number is used on error logging and by the <br> *  cpicerr_exchange_version() call. <br> * <br> *  Also see: <br> *      cpicerr_set_minor_version <br> *****************************************************************************/ <br>int <br>cpicerr_set_major_version(CPICERR *     cpicerr, <br>                          unsigned char major_version) <br>{ <br>    cpicerr-&gt;major_version = major_version; <br>    return 0; <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_minor_version <br> * <br> *  Usage: <br> *  Sets the minor version number for the application. <br> *  The version number can be 0-255. <br> * <br> *  The version number is used on error logging and by the <br> *  cpicerr_exchange_version() call. <br> * <br> *  Also see: <br> *      cpicerr_set_major_version <br> *****************************************************************************/ <br>int <br>cpicerr_set_minor_version(CPICERR *     cpicerr, <br>                          unsigned char minor_version) <br>{ <br>    cpicerr-&gt;minor_version = minor_version; <br>    return 0; <br>} <br> <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_program_info <br> * <br> *  Usage: <br> *  Sets a program information string that is included in the log information. <br> *****************************************************************************/ <br>int <br>cpicerr_set_program_info( CPICERR * cpicerr, <br>                          char * program_info) <br>{ <br>    int rc; <br> <br>    /*-----------------------------------------------------------------------* <br>     * Save the application's program information string <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;program_info = (char *) malloc(strlen(program_info)+1); <br>    if (cpicerr-&gt;program_info != NULL) { <br>        strcpy(cpicerr-&gt;program_info, program_info); <br>        rc = 0; <br>    } else { <br>        rc = 1; <br>    } <br>    return rc; <br>} <br> <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_program_name <br> * <br> *  Usage: <br> *  Sets a program name string that is included in the log information. <br> *****************************************************************************/ <br>int <br>cpicerr_set_program_name(CPICERR * cpicerr, <br>                         char * program_name) <br>{ <br>    int rc; <br>    /*-----------------------------------------------------------------------* <br>     * Save the local program name. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr-&gt;program_name = (char *) malloc(strlen(program_name)+1); <br>    if (cpicerr-&gt;program_name != NULL) { <br>        strcpy(cpicerr-&gt;program_name, program_name); <br>        rc = 0; <br>    } else { <br>        rc = 1; <br>    } <br>    return rc; <br>} <br> <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_show_level <br> * <br> *  Usage: <br> *  Specify the CPI-C error classification as the show level. <br> *  When cpicerr_handle_rc() is called, the return code will be classified. <br> *  If the classification is above the show level, the return code and <br> *  some conversation information will be shown to the user. <br> * <br> *  A value of ALL_ERRORS can be used to force showing of all calls to <br> *  cpicerr_handle_rc().  This is the DEFAULT value. <br> * <br> *  A value of NO_ERRORS can be used to indicate that cpicerr should never <br> *  cause an error to be shown to the user. <br> * <br> *  Also see: <br> *      cpicerr_set_exit_level <br> *      cpicerr_set_log_level <br> *****************************************************************************/ <br>int <br>cpicerr_set_show_level(CPICERR *        cpicerr, <br>                       CPIC_RC_HANDLING show_level) <br>{ <br>    cpicerr-&gt;show_level = show_level; <br>    return 0; <br>} <br> <br> <br>/****************************************************************************** <br> * <br> *  cpicerr_handle_rc_extended <br> * <br> *  Note: <br> *  applications should use the cpicerr_handle_rc() macro. <br> * <br> *  Usage: <br> *  This function should be called to handle any unexpected CPI-C return <br> *  codes.  The exact function of this routine depends upon the settings <br> *  that have been made to the CPICERR object. <br> * <br> *  Functions include: <br> *      Determining the current conversation state <br> *      Classifying the return code (CPIC_RC_HANDLING enum) <br> *      Showing return code info to the user <br> *      Logging the return code and conversation info to disk <br> *      Deallocate the conversation and exit <br> * <br> *  Also see: <br> *      cpicerr_set_exit_level <br> *      cpicerr_set_log_level <br> *      cpicerr_set_show_level <br> * <br> *****************************************************************************/ <br>CPIC_RC_HANDLING <br>cpicerr_handle_rc_extended(CPICERR *       cpicerr, <br>                           CPIC_VERB_INDEX verb_index, <br>                           CM_RETURN_CODE  conv_rc, <br>                           char *          file_name, <br>                           int             file_line) <br> <br>{ <br>   /* Displays the CPI-C return code and the verb name. */ <br> <br>    CM_RETURN_CODE   cm_rc;                 /* Return code from CPI-C call   */ <br>    CPIC_RC_HANDLING classification;        /* Returned RC classification    */ <br>    char *           string;                /* temp var for output strings   */ <br>    CM_CONVERSATION_STATE conversation_state; /* Current conv. state         */ <br> <br>    /*-----------------------------------------------------------------------* <br>     * Extract the current conversation state. <br>     * This will not be useful if the conversation has failed or a deallocate <br>     * return code has been received.  The conversation state is most useful <br>     * when a state check has occurred. <br>     *-----------------------------------------------------------------------*/ <br>#ifndef ECS_NOT_SUPPORTED <br>     cmecs(cpicerr-&gt;conversation_id, <br>           &amp;conversation_state, <br>           &amp;cm_rc); <br>     if (cm_rc == CM_OK) { <br>         cpicerr-&gt;conversation_state = conversation_state; <br>     } <br>     else { <br>         cpicerr-&gt;conversation_state = CMECS_NOT_SUPPORTED; <br>     } <br>#else <br>     cpicerr-&gt;conversation_state = CMECS_NOT_SUPPORTED; <br>#endif <br> <br>    /*-----------------------------------------------------------------------* <br>     * Store the error information in the cpicerr structure <br>     *-----------------------------------------------------------------------*/ <br>     cpicerr_set_rc_info(cpicerr, verb_index, conv_rc); <br> <br>    /*-----------------------------------------------------------------------* <br>     * Get the classification for this return code. <br>     *-----------------------------------------------------------------------*/ <br>    cpicerr_classify_rc(conv_rc, &amp;classification); <br> <br> <br>    if (classification == ERROR_RECEIVED &amp;&amp; cpicerr-&gt;handle_error == TRUE) { <br>        CPICERR_REPLY * reply; <br>        reply = cpicerr_create_reply(1000,1000); <br>        cpicerr_recv_appl_error(cpicerr, reply); <br>        cpicerr_show_reply(reply); <br>        if (classification &gt;= cpicerr-&gt;exit_level) { <br>            CM_INT32 deallocate_type; <br>            /* <br>             * Exit the application, rather than returning to the caller. <br>             */ <br>            deallocate_type = CM_DEALLOCATE_ABEND; <br> <br>            cmsdt(cpicerr -&gt; conversation_id, <br>                  &amp;deallocate_type, <br>                  &amp;cm_rc); <br> <br>            cmdeal(cpicerr -&gt; conversation_id, <br>                   &amp;cm_rc); <br> <br>            do_exit(EXIT_FAILURE); <br>        } <br>        return classification; <br>    } <br> <br> <br>    /*-----------------------------------------------------------------------* <br>     * Show the CPI-C verb and return code. <br>     *-----------------------------------------------------------------------*/ <br>    if (classification &gt;= cpicerr-&gt;show_level) { <br>        cpicerr_show_rc(cpicerr); <br>    } <br> <br> <br>    /*-----------------------------------------------------------------------* <br>     * Show the classification for this return code. <br>     *-----------------------------------------------------------------------*/ <br>    if (classification &gt;= cpicerr-&gt;show_level) { <br>        string = cpicerr_get_message(CPIC_RC_CLASSES, classification); <br>        write_error("       return code class: %s\n", string); <br>        /*-------------------------------------------------------------------* <br>         * Show product specific information associated with this error. <br>         *-------------------------------------------------------------------*/ <br>        cpicerr_show_product_info(cpicerr); <br>    } <br> <br> <br>    /*-----------------------------------------------------------------------* <br>     * Log this error, along with the infomation in its cpicerr. <br>     *-----------------------------------------------------------------------*/ <br>    if (classification &gt;= cpicerr-&gt;log_level) { <br>        cpicerr_log_cpicerr(cpicerr, file_name, file_line); <br>    } <br> <br> <br>    if (classification &gt;= cpicerr-&gt;exit_level) { <br>        CM_INT32 deallocate_type; <br>        /*-------------------------------------------------------------------* <br>         * Exit the application, rather than returning to the caller. <br>         *-------------------------------------------------------------------*/ <br>        deallocate_type = CM_DEALLOCATE_ABEND; <br> <br>        cmsdt(cpicerr -&gt; conversation_id, <br>              &amp;deallocate_type, <br>              &amp;cm_rc); <br> <br>        cmdeal(cpicerr -&gt; conversation_id, <br>               &amp;cm_rc); <br> <br>        do_exit(EXIT_FAILURE);              /* Set a failure return code     */ <br>    } <br>    return classification; <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicerr_exchange_version <br> * <br> *  Usage: <br> *  Calls cpicerr_exchange_version_plus() <br> * <br> *****************************************************************************/ <br>int <br>cpicerr_exchange_version(CPICERR *       cpicerr, <br>                         unsigned char * cm_conv_id, <br>                         CM_INT32        conv_state, <br>                         unsigned char * partner_major_version, <br>                         unsigned char * partner_minor_version) <br>{ <br>    return cpicerr_exchange_version_plus(cpicerr, <br>                                         cm_conv_id, <br>                                         conv_state, <br>                                         partner_major_version, <br>                                         partner_minor_version, <br>                                         NULL, <br>                                         0); <br> <br> <br> <br> <br>} <br> <br>/****************************************************************************** <br> * <br> *  cpicerr_exchange_version_plus <br> * <br> *  Usage: <br> *  Send our two version number bytes to the partner and receive our <br> *  partner's two version numbers.  The input parameter conv_state <br> *  determines whether our version numbers are sent first, or whether <br> *  we receive the partner's numbers first. <br> * <br> *  Also will return the remote operating system string, if sent. <br> * <br> *****************************************************************************/ <br>int <br>cpicerr_exchange_version_plus(CPICERR *       cpicerr, <br>                              unsigned char * cm_conv_id, <br>                              CM_INT32        conv_state, <br>                              unsigned char * partner_major_version, <br>                              unsigned char * partner_minor_version, <br>                              unsigned char * opsys_string, <br>                              unsigned int    opsys_string_length) <br>{ <br>    CM_SEND_TYPE send_type;                 /* CPI-C send type               */ <br>    CM_PREPARE_TO_RECEIVE_TYPE prep_to_receive; /* CPI-C prepare to receive  */ <br>    CM_INT32    cm_rc;                      /* CPI-C return code             */ <br>    CM_INT32    length;                     /* generic length variable       */ <br>    CM_INT32    rts_received;               /* request to send received      */ <br>    CM_INT32    max_receive_len;            /* Max receive length on CMRCV   */ <br>    CM_INT32    what_received;              /* What received parm from CMRCV */ <br>    CM_INT32    received_len;               /* Amount of data rcvd on CMRCV  */ <br>    CM_INT32    status_received;            /* Status from CMRCV             */ <br>    unsigned char buffer[EXCHANGE_BUFFER_SIZE]; /* data buffer               */ <br> <br>    *partner_major_version = 0; <br>    *partner_minor_version = 0; <br> <br>    prep_to_receive = CM_PREP_TO_RECEIVE_FLUSH; <br>    cmsptr(cm_conv_id,                      /* Set prepare to receive type   */ <br>           &amp;prep_to_receive, <br>           &amp;cm_rc); <br>    /* The only expected return code is CM_OK */ <br>    if (cm_rc != CM_OK) return cpicerr_handle_rc(cpicerr, MSG_CMSPTR, cm_rc); <br> <br>    send_type = CM_BUFFER_DATA; <br>    cmsst(cm_conv_id,                       /* Set send type                 */ <br>          &amp;send_type, <br>          &amp;cm_rc); <br>    if (cm_rc != CM_OK) return cpicerr_handle_rc(cpicerr, MSG_CMSST, cm_rc); <br> <br> <br>    switch (conv_state) { <br>    case CM_SEND_STATE: <br>        buffer[0] = CPICERR_EXCHANGE_VERSION; <br>        buffer[1] = cpicerr-&gt;major_version; <br>        buffer[2] = cpicerr-&gt;minor_version; <br>        length = 3; <br>        cmsend(cm_conv_id, <br>               buffer, <br>               &amp;length, <br>               &amp;rts_received, <br>               &amp;cm_rc); <br>        /* The only expected return code is CM_OK */ <br>        if (cm_rc != CM_OK) <br>            return cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br>        /* this falls through to the receive code!!! */ <br>    case CM_RECEIVE_STATE: <br>        max_receive_len = sizeof(buffer); <br>        cmrcv (cm_conv_id, <br>               buffer, <br>               &amp;max_receive_len, <br>               &amp;what_received, <br>               &amp;received_len, <br>               &amp;status_received, <br>               &amp;rts_received, <br>               &amp;cm_rc); <br>        if (cm_rc == CM_OK) { <br>            if (what_received != CM_NO_DATA_RECEIVED) { <br>                if (received_len &gt; 2 &amp;&amp; buffer[0]==CPICERR_EXCHANGE_VERSION) { <br>                    *partner_major_version = buffer[1]; <br>                    *partner_minor_version = buffer[2]; <br>                } <br>                if (opsys_string != NULL &amp;&amp; opsys_string_length &gt; 1) { <br>                    if (received_len &gt; 4 &amp;&amp; <br>                        buffer[3]==CPICERR_EXCHANGE_OPSYS_STRING) { <br>                        if (received_len &lt; sizeof(buffer)) { <br>                            buffer[received_len] = '\0'; <br>                        } <br>                        else { <br>                            buffer[sizeof(buffer)] = '\0'; <br>                        } <br>                        { <br>                        unsigned int string_length; <br> <br>                        string_length = strlen(&amp;buffer[4]); <br>                        convert_from_ascii(&amp;buffer[4], string_length); <br> <br>                        memcpy(opsys_string, <br>                               &amp;buffer[4], <br>                               min(string_length, opsys_string_length-1)); <br> <br>                        opsys_string[min(string_length, opsys_string_length-1)] <br>                                                                        = '\0'; <br> <br>                        } <br> <br>                    } <br>                    else { <br>                        opsys_string[0] = '\0'; <br>                    } <br>                } <br>                else { <br>                } <br> <br>            } <br>            switch (status_received) { <br>            case CM_CONFIRM_RECEIVED: <br>                cmcfmd(cm_conv_id, <br>                       &amp;cm_rc); <br>                if (cm_rc != CM_OK) <br>                    return cpicerr_handle_rc(cpicerr, MSG_CMCFMD, cm_rc); <br>                break; <br>            case CM_SEND_RECEIVED: <br>                /* This is good, we don't have to do anything. */ <br>                break; <br>            default: <br>                ; <br>                /* should do a reply_error here */ <br> <br>            } <br>        } else { <br>            return cpicerr_handle_rc(cpicerr, MSG_CMRCV, cm_rc); <br>        } <br>        break; <br>    default: <br>        /* do a reply error here */ <br>        return UNRECOVERABLE; <br>    } <br> <br>    if ((conv_state == CM_RECEIVE_STATE) &amp;&amp; <br>         (status_received == CM_SEND_RECEIVED)) { <br> <br>        char *       local_opsys_string; <br>        unsigned int local_opsys_string_length; <br> <br>        buffer[0] = CPICERR_EXCHANGE_VERSION; <br>        buffer[1] = cpicerr-&gt;major_version; <br>        buffer[2] = cpicerr-&gt;minor_version; <br>        local_opsys_string = OPSYS_STRING; <br>        local_opsys_string_length = strlen(local_opsys_string); <br>        if ((local_opsys_string_length + 1+ 3 +1) &lt; sizeof(buffer)) { <br>            buffer[3] = CPICERR_EXCHANGE_OPSYS_STRING; <br>            memcpy(&amp;buffer[4], <br>                   local_opsys_string, <br>                   local_opsys_string_length); <br>            convert_to_ascii(&amp;buffer[4], local_opsys_string_length); <br>            buffer[4+local_opsys_string_length] ='\0'; <br>            length = 4 + local_opsys_string_length + 1; <br>        } <br>        else { <br> <br> <br>            length = 3; <br>        } <br> <br>        cmsend(cm_conv_id, <br>               buffer, <br>               &amp;length, <br>               &amp;rts_received, <br>               &amp;cm_rc); <br>        /* The only expected return code is CM_OK */ <br> <br>        if (cm_rc != CM_OK) <br>            return cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br> <br>        cmptr(cm_conv_id, <br>              &amp;cm_rc); <br>        if (cm_rc != CM_OK) <br>            return cpicerr_handle_rc(cpicerr, MSG_CMPTR, cm_rc); <br>    } <br>    return RC_OK; <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_destroy() <br> * <br> *  Destroys a CPICERR structure created with cpicerr_new(). <br> *  All memory assocated with the input CPICERR pointer is freed. <br> * <br> *****************************************************************************/ <br>void <br>cpicerr_destroy(CPICERR * cpicerr) <br>{ <br>    /* <br>     * Make sure we don't free() a NULL pointer!!! <br>     */ <br>    if (cpicerr != NULL) { <br>        if (cpicerr-&gt;program_name != NULL) { <br>            free(cpicerr-&gt;program_name); <br>        } <br> <br>        if (cpicerr-&gt;program_info != NULL) { <br>            free(cpicerr-&gt;program_info); <br>        } <br> <br>        if (cpicerr-&gt;log_file_name != NULL) { <br>            free(cpicerr-&gt;log_file_name); <br>        } <br> <br>        if (cpicerr-&gt;log_file_path != NULL) { <br>            free(cpicerr-&gt;log_file_path); <br>        } <br> <br>        free(cpicerr); <br>    } <br>    return; <br>} <br> <br> <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_set_rc_info <br> * <br> *  Internal call which makes it easier to store return code information <br> *  in the CPICERR structure.  Called from cpicerr_handle_rc(). <br> * <br> *****************************************************************************/ <br>void <br>cpicerr_set_rc_info(CPICERR *       cpicerr, <br>                    CPIC_VERB_INDEX verb_index, <br>                    CM_RETURN_CODE  conv_rc) <br>/* Store the verb return code information into the cpicerr structure */ <br>{ <br>    cpicerr-&gt;verb_index = verb_index; <br>    cpicerr-&gt;conv_rc =    conv_rc; <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_show_rc <br> * <br> *  Internal call which will display information about the unexpected <br> *  return code encountered.  Called from cpicerr_handle_rc(). <br> * <br> *****************************************************************************/ <br>void <br>cpicerr_show_rc(CPICERR * cpicerr) <br>{ <br>    write_error("\n  Unexpected CPI-C return code encountered...\n"); <br> <br>    /*-----------------------------------------------------------------------* <br>     * Find the CPI-C verb's name, and show it. <br>     *-----------------------------------------------------------------------*/ <br>    write_error( "         CPI-C verb name: %s, %s\n", <br>            cpicerr_get_message(CPIC_VERBS_SHORT, <br>                                (CM_INT32)cpicerr-&gt;verb_index), <br>            cpicerr_get_message(CPIC_VERBS_LONG, <br>                                (CM_INT32)cpicerr-&gt;verb_index)); <br> <br>    /*-----------------------------------------------------------------------* <br>     * Find the CPI-C return code's name, and show it. <br>     *-----------------------------------------------------------------------*/ <br>    write_error( "       CPI-C return code: %lu, %s\n", <br>            cpicerr-&gt;conv_rc, <br>            cpicerr_get_message(CPIC_RETURN_CODES, cpicerr-&gt;conv_rc)); <br> <br>    return; <br>} <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_log_rc <br> * <br> *  Internal call which will log information about the unexpected <br> *  return code encountered.  Called from cpicerr_handle_rc(). <br> * <br> *****************************************************************************/ <br>void <br>cpicerr_log_rc(CPICERR * cpicerr, <br>               FILE *    log_file) <br>{ <br>    write_log(log_file, "  Unexpected CPI-C return code encountered...\n"); <br> <br>    /*-----------------------------------------------------------------------* <br>     * Find the CPI-C verb's name, and show it. <br>     *-----------------------------------------------------------------------*/ <br>    write_log(log_file, <br>              "         CPI-C verb name: %s, %s\n", <br>              cpicerr_get_message(CPIC_VERBS_SHORT, <br>                                  (CM_INT32)cpicerr-&gt;verb_index), <br>              cpicerr_get_message(CPIC_VERBS_LONG, <br>                                  (CM_INT32)cpicerr-&gt;verb_index)); <br> <br>    /*-----------------------------------------------------------------------* <br>     * Find the CPI-C return code's name, and show it. <br>     *-----------------------------------------------------------------------*/ <br>    write_log(log_file, <br>              "       CPI-C return code: %lu, %s\n", <br>              cpicerr-&gt;conv_rc, <br>              cpicerr_get_message(CPIC_RETURN_CODES, cpicerr-&gt;conv_rc)); <br> <br>    return; <br>} <br> <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_classify_rc <br> * <br> *  Internal call which takes a CPI-C return code and classifies it <br> *  into one of the categories that we have defined. <br> *  Called from cpicerr_handle_rc(). <br> * <br> *****************************************************************************/ <br>void <br>cpicerr_classify_rc (CM_RETURN_CODE conv_rc, <br>                     CPIC_RC_HANDLING * classification) <br>{ <br>    switch (conv_rc) { <br> <br>        case CM_ALLOCATE_FAILURE_NO_RETRY: <br>            /* configuration defect or protocol defect, local or partner */ <br>        case CM_TP_NOT_AVAILABLE_NO_RETRY: <br>            /* partner program could not be sucessfully started */ <br>        case CM_RESOURCE_FAILURE_NO_RETRY: <br>            /* communication failure or protocol defect, local or partner */ <br> <br>        case CM_DEALLOCATED_ABEND: <br>            /* unrecoverable error in the partner TP */ <br>        case CM_DEALLOCATED_ABEND_SVC: <br>            /* unrecoverable error in the partner TP */ <br>        case CM_DEALLOCATED_ABEND_TIMER: <br>            /* unrecoverable error in the partner TP */ <br> <br>        case CM_CONVERSATION_TYPE_MISMATCH: <br>        case CM_PIP_NOT_SPECIFIED_CORRECTLY: <br> <br>            /* configuration defect or mismatch with the partner */ <br> <br>        case CM_OK: <br>            /* application design defect, local or partner program */ <br>        case CM_DEALLOCATED_NORMAL: <br>            /* TP design defect, local or partner program */ <br>        case CM_PARAMETER_ERROR: <br>            /* local program design or coding defect */ <br>        case CM_PROGRAM_PARAMETER_CHECK: <br>            /* local program design or coding defect */ <br>        case CM_PROGRAM_STATE_CHECK: <br>            /* local program design or coding defect */ <br>            *classification = UNRECOVERABLE; <br>            break; <br> <br>        case CM_ALLOCATE_FAILURE_RETRY: <br>            /* configuration defect or route temporarily down */ <br>        case CM_TP_NOT_AVAILABLE_RETRY: <br>            /* congestion at the partner operating system */ <br>        case CM_RESOURCE_FAILURE_RETRY: <br>            /* route temporarily down */ <br>            *classification = RETRY_CONV; <br>            break; <br> <br>        case CM_UNSUCCESSFUL: <br>            /* verb could not be completed now */ <br>            *classification = RETRY_VERB; <br>            break; <br> <br>        case CM_PROGRAM_ERROR_NO_TRUNC: <br>        case CM_SVC_ERROR_NO_TRUNC: <br>            /* partner failed while building a record to send */ <br>        case CM_PROGRAM_ERROR_PURGING: <br>        case CM_SVC_ERROR_PURGING: <br>            /* partner failed while processing a received record */ <br>        case CM_PROGRAM_ERROR_TRUNC: <br>        case CM_SVC_ERROR_TRUNC: <br>            /* partner failed after partially sending a record */ <br>            *classification = ERROR_RECEIVED; <br>            break; <br> <br>        case CM_PRODUCT_SPECIFIC_ERROR: <br>            /********************************/ <br>            /* Examine each of these.       */ <br>            /* In some cases, you may want  */ <br>            /* to return CONTINUE.          */ <br>            /********************************/ <br>            *classification = UNRECOVERABLE; <br>            break; <br> <br>        case CM_SECURITY_NOT_VALID: <br>            *classification = SECURITY_NOT_VALID; <br>            break; <br> <br>        default: <br>            *classification = UNRECOVERABLE; <br>            break; <br>    } <br>    return; <br>} <br> <br> <br> <br> <br>/***************************************************************************** </code></pre>
<p>
</p>
<pre><code>* <br> *  cpicerr_log_cpicerr() <br> * <br> *  Internal call which logs complete conversation and error information <br> *  to a log file.  Called by cpicerr_handle_rc(). <br> * <br> *****************************************************************************/ <br>int <br>cpicerr_log_cpicerr(CPICERR * cpicerr, <br>                    char *    file_name, <br>                    int       file_line) <br>{ <br>    int      rc;                            /* return value                  */ <br>    FILE *   log_file;                      /* log file handle               */ <br>    unsigned count;                         /* used to extract text strings  */ <br>    char     filepath[256];                 /* actual file path for logging  */ <br>    char     last_char; <br> <br>    if (cpicerr != (CPICERR *)NULL) { <br> <br>        /*-------------------------------------------------------------------* <br>         * Save the time of the call to this procedure. <br>         *-------------------------------------------------------------------*/ <br>        cpicerr-&gt;program_error_time = time(NULL); <br> <br>        filepath[0] = '\0'; <br>        if (cpicerr-&gt;log_file_path != NULL &amp;&amp; <br>            cpicerr-&gt;log_file_path[0] != '\0') { <br>            strcpy(filepath, cpicerr-&gt;log_file_path); <br>            last_char = <br>                    cpicerr-&gt;log_file_path[strlen(cpicerr-&gt;log_file_path)-1]; <br>            if (!(last_char == '\\' || last_char == '/')) { <br>                strcat(filepath, "/"); <br>            } <br>        } <br>        if (cpicerr-&gt;log_file_name != NULL) { <br>            strcat(filepath, cpicerr-&gt;log_file_name); <br>        } <br> <br>        if ((strlen(filepath) == 0) || <br>                               ((log_file = fopen(filepath, "a")) == NULL  )) { <br>            log_file = stderr; <br>        } <br> <br>        write_log(log_file, <br>                  "------------------------------------------------------\n"); <br> <br>        if (cpicerr-&gt;program_name != NULL) { <br>            write_log(log_file, "  CPI-C error in program: \"%s\"", <br>                                                     cpicerr-&gt;program_name); <br>        } <br> <br>        if (cpicerr-&gt;program_info != NULL) { <br>            write_log(log_file, ", %s\n", cpicerr-&gt;program_info); <br>        } <br> <br>        if (cpicerr-&gt;major_version != 0 || cpicerr-&gt;minor_version != 0) { <br>            write_log(log_file, "         Program version: %u.%u\n", <br>                                       (unsigned int)cpicerr-&gt;major_version, <br>                                       (unsigned int)cpicerr-&gt;minor_version); <br>        } <br> <br>        cpicerr_log_rc(cpicerr, log_file); <br> <br>        if (cpicerr-&gt;partner_LU_name[0] != '\0') { <br>            cpicerr-&gt;partner_LU_name[(int)cpicerr-&gt;partner_LU_name_length] <br>                                                                       = '\0'; <br>        } <br>        if (cpicerr-&gt;mode_name[0] != '\0') { <br>            cpicerr-&gt;mode_name[(int)cpicerr-&gt;mode_name_length] = '\0'; <br>        } <br>        write_log(log_file, "         Partner LU name: %s\n", <br>                                                     cpicerr-&gt;partner_LU_name); <br>        write_log(log_file, "               Mode name: %s\n", <br>                                                     cpicerr-&gt;mode_name); <br> <br>        write_log(log_file, "   CPI-C conversation ID: "); <br> <br>        for (count = 0; count&lt;sizeof(cpicerr-&gt;conversation_id); count++ ) { <br>            write_log(log_file, "%02X", <br>                               (unsigned int)cpicerr-&gt;conversation_id[count]); <br>        } <br>        write_log(log_file, "\n"); <br> <br>        write_log(log_file, "CPI-C conversation state: %lu, %s\n", <br>           cpicerr-&gt;conversation_state, <br>           cpicerr_get_message(CPIC_STATES_CONV, cpicerr-&gt;conversation_state)); <br> <br>        write_log(log_file, " CPI-C conversation type: %lu, %s\n", <br>           cpicerr-&gt;conversation_type, <br>           cpicerr_get_message( CPIC_CONV_TYPES, cpicerr-&gt;conversation_type)); <br> <br>        write_log(log_file, " Conversation sync level: %lu, %s\n", <br>                cpicerr-&gt;sync_level, <br>                cpicerr_get_message( CPIC_SYNC_LEVELS, cpicerr-&gt;sync_level)); <br> <br> <br> <br> <br>        write_log(log_file, "      Program start time: %s", <br>                                        ctime(&amp;(cpicerr-&gt;program_start_time))); <br>        write_log(log_file, "      Program error time: %s", <br>                                        ctime(&amp;(cpicerr-&gt;program_error_time))); <br>        write_log(log_file, " Called from source file: %s\n", file_name); <br>        write_log(log_file, "                 at line: %d\n", file_line); <br> <br>        fclose(log_file); <br> <br>        rc = 0; <br>    } else { <br>        rc = 1; <br>    } <br> <br>    return rc; <br>} <br> <br> <br> <br> <br>CPICERR_MESSAGE cpicerr_verbs_short[] = { <br>    MSG_CMACCP,         "CMACCP", <br>    MSG_CMALLC,         "CMALLC", <br>    MSG_CMCFM,          "CMCFM", <br>    MSG_CMCFMD,         "CMCFMD", <br>    MSG_CMDEAL,         "CMDEAL", <br>    MSG_CMECS,          "CMECS", <br>    MSG_CMECT,          "CMECT", <br>    MSG_CMEMN,          "CMEMN", <br>    MSG_CMEPLN,         "CMEPLN", <br>    MSG_CMESL,          "CMESL", <br>    MSG_CMFLUS,         "CMFLUS", <br>    MSG_CMINIT,         "CMINIT", <br>    MSG_CMPTR,          "CMPTR", <br>    MSG_CMRCV,          "CMRCV", <br>    MSG_CMRTS,          "CMRTS", <br>    MSG_CMSCT,          "CMSCT", <br>    MSG_CMSDT,          "CMSDT", <br>    MSG_CMSED,          "CMSED", <br>    MSG_CMSEND,         "CMSEND", <br>    MSG_CMSERR,         "CMSERR", <br>    MSG_CMSF,           "CMSF", <br>    MSG_CMSLD,          "CMSLD", <br>    MSG_CMSMN,          "CMSMN", <br>    MSG_CMSPLN,         "CMSPLN", <br>    MSG_CMSPTR,         "CMSPTR", <br>    MSG_CMSRC,          "CMSRC", <br>    MSG_CMSRT,          "CMSRT", <br>    MSG_CMSSL,          "CMSSL", <br>    MSG_CMSST,          "CMSST", <br>    MSG_CMSTPN,         "CMSTPN", <br>    MSG_CMTRTS,         "CMTRTS", <br>    MSG_XCSCSU,         "XCSCSU", <br>    MSG_XCSCSP,         "XCSCSP", <br>    MSG_XCSCST,         "XCSCST", <br>    MSG_XCECST,         "XCECST", <br>    MSG_XCECSU,         "XCECSU", <br>    MSG_XCMSSI,         "XCMSSI", <br>    MSG_XCMESI,         "XCMESI", <br>    MSG_XCMDSI,         "XCMDSI", <br>    MAX_MESSAGE,        "ERROR " <br>}; <br> <br>CPICERR_MESSAGE cpicerr_verbs_long[] = { <br>    MSG_CMACCP,         "Accept_Conversation", <br>    MSG_CMALLC,         "Allocate", <br>    MSG_CMCFM,          "Confirm", <br>    MSG_CMCFMD,         "Confirmed", <br>    MSG_CMDEAL,         "Deallocate", <br>    MSG_CMECS,          "Extract_Conversation_State", <br>    MSG_CMECT,          "Extract_Conversation_Type", <br>    MSG_CMEMN,          "Extract_Mode_Name", <br>    MSG_CMEPLN,         "Extract_Partner_LU_Name", <br>    MSG_CMESL,          "Extract_Sync_Level", <br>    MSG_CMFLUS,         "Flush", <br>    MSG_CMINIT,         "Initialize_Conversation", <br>    MSG_CMPTR,          "Prepare_To_Receive", <br>    MSG_CMRCV,          "Receive", <br>    MSG_CMRTS,          "Request_To_Send", <br>    MSG_CMSCT,          "Set_Conversation_Type", <br>    MSG_CMSDT,          "Set_Deallocate_Type", <br>    MSG_CMSED,          "Set_Error_Direction", <br>    MSG_CMSEND,         "Send_Data", <br>    MSG_CMSERR,         "Send_Error", <br>    MSG_CMSF,           "Set_Fill", <br>    MSG_CMSLD,          "Set_Log_Data", <br>    MSG_CMSMN,          "Set_Mode_Name", <br>    MSG_CMSPLN,         "Set_Partner_LU_Name", <br>    MSG_CMSPTR,         "Set_Prepare_To_Receive_Type", <br>    MSG_CMSRC,          "Set_Return_Control", <br>    MSG_CMSRT,          "Set_Receive_Type", <br>    MSG_CMSSL,          "Set_Sync_Level", <br>    MSG_CMSST,          "Set_Send_Type", <br>    MSG_CMSTPN,         "Set_TP_Name", <br>    MSG_CMTRTS,         "Test_Request_To_Send_Received", <br>    MSG_XCSCSU,         "Set Conversation Security Userid", <br>    MSG_XCSCSP,         "Set Conversation Security Password", <br>    MSG_XCSCST,         "Set Conversation Security Type", <br>    MSG_XCECST,         "Extract_Conversation_Security_Type", <br>    MSG_XCECSU,         "Extract_Conversation_Security_Userid", <br>    MSG_XCMSSI,         "Set_CPIC_Side_Information", <br>    MSG_XCMESI,         "Extract_CPIC_Side_Information", <br>    MSG_XCMDSI,         "Delete_CPIC_Side_Information", <br>    MAX_MESSAGE,        "Invalid verb name" <br>}; <br> <br>CPICERR_MESSAGE cpicerr_return_codes[] = { <br>    CM_OK,                          "CM_OK", <br>    CM_ALLOCATE_FAILURE_NO_RETRY,   "CM_ALLOCATE_FAILURE_NO_RETRY", <br>    CM_ALLOCATE_FAILURE_RETRY,      "CM_ALLOCATE_FAILURE_RETRY", <br>    CM_CONVERSATION_TYPE_MISMATCH,  "CM_CONVERSATION_TYPE_MISMATCH", <br>    CM_PIP_NOT_SPECIFIED_CORRECTLY, "CM_PIP_NOT_SPECIFIED_CORRECTLY", <br>    CM_SECURITY_NOT_VALID,          "CM_SECURITY_NOT_VALID", <br>    CM_TP_NOT_AVAILABLE_NO_RETRY,   "CM_TP_NOT_AVAILABLE_NO_RETRY", <br>    CM_TP_NOT_AVAILABLE_RETRY,      "CM_TP_NOT_AVAILABLE_RETRY", <br>    CM_DEALLOCATED_ABEND,           "CM_DEALLOCATED_ABEND", <br>    CM_DEALLOCATED_NORMAL,          "CM_DEALLOCATED_NORMAL", <br>    CM_PARAMETER_ERROR,             "CM_PARAMETER_ERROR", <br>    CM_PRODUCT_SPECIFIC_ERROR,      "CM_PRODUCT_SPECIFIC_ERROR", <br>    CM_PROGRAM_ERROR_NO_TRUNC,      "CM_PROGRAM_ERROR_NO_TRUNC", <br>    CM_PROGRAM_ERROR_PURGING,       "CM_PROGRAM_ERROR_PURGING", <br>    CM_PROGRAM_ERROR_TRUNC,         "CM_PROGRAM_ERROR_TRUNC", <br>    CM_PROGRAM_PARAMETER_CHECK,     "CM_PROGRAM_PARAMETER_CHECK", <br>    CM_PROGRAM_STATE_CHECK,         "CM_PROGRAM_STATE_CHECK", <br>    CM_RESOURCE_FAILURE_NO_RETRY,   "CM_RESOURCE_FAILURE_NO_RETRY", <br>    CM_RESOURCE_FAILURE_RETRY,      "CM_RESOURCE_FAILURE_RETRY", <br>    CM_UNSUCCESSFUL,                "CM_UNSUCCESSFUL", <br>    CM_DEALLOCATED_ABEND_SVC,       "CM_DEALLOCATED_ABEND_SVC", <br>    CM_DEALLOCATED_ABEND_TIMER,     "CM_DEALLOCATED_ABEND_TIMER", <br>    CM_SVC_ERROR_NO_TRUNC,          "CM_SVC_ERROR_NO_TRUNC", <br>    CM_SVC_ERROR_PURGING,           "CM_SVC_ERROR_PURGING", <br>    CM_SVC_ERROR_TRUNC,             "CM_SVC_ERROR_TRUNC", <br>    MAX_MESSAGE,                    "Invalid Return Code Value" <br>}; <br> <br>CPICERR_MESSAGE cpicerr_rc_classes[] = { <br>    BACKOUT_RECEIVED,   "BACKOUT_RECEIVED", <br>    CONTINUE,           "CONTINUE", <br>    ERROR_RECEIVED,     "ERROR_RECEIVED", <br>    SECURITY_NOT_VALID, "SECURITY_NOT_VALID", <br>    RETRY_CONV,         "RETRY_CONVERSATION", <br>    RETRY_CONV_BO,      "RETRY_CONVERSATION_BACKOUT", <br>    RETRY_VERB,         "RETRY_LAST_VERB", <br>    UNRECOVERABLE,      "UNRECOVERABLE", <br>    UNRECOVERABLE_BO,   "UNRECOVERABLE_BACKOUT", <br>    MAX_MESSAGE,        "Invalid Return Code Class" <br>}; <br> <br>CPICERR_MESSAGE cpicerr_states_conv[] = { <br>    CM_INITIALIZE_STATE,            "Initialize state", <br>    CM_SEND_STATE,                  "Send state", <br>    CM_RECEIVE_STATE,               "Receive state", <br>    CM_SEND_PENDING_STATE,          "Send pending state", <br>    CM_CONFIRM_STATE,               "Confirm state", <br>    CM_CONFIRM_SEND_STATE,          "Confirm send state", <br>    CM_CONFIRM_DEALLOCATE_STATE,    "Confirm deallocate state", <br>    CMECS_NOT_SUPPORTED,            "CMECS not supported", <br>    MAX_MESSAGE,                    "Invalid Conversation State value" <br>}; <br> <br>CPICERR_MESSAGE cpicerr_sync_levels[] = { <br>    CM_NONE,            "None", <br>    CM_CONFIRM,         "Confirm", <br>    MAX_MESSAGE,        "Invalid Sync Level value" <br>}; <br> <br>CPICERR_MESSAGE cpicerr_conv_types[] = { <br>    CM_BASIC_CONVERSATION , "Basic", <br>    CM_MAPPED_CONVERSATION, "Mapped", <br>    MAX_MESSAGE,            "Invalid conversation type value" <br>}; <br> <br>CPICERR_MESSAGE_LIST message_list[] = { <br>    CPIC_SYNC_LEVELS,   cpicerr_sync_levels, <br>    CPIC_CONV_TYPES,    cpicerr_conv_types, <br>    CPIC_STATES_CONV,   cpicerr_states_conv, <br>    CPIC_RC_CLASSES,    cpicerr_rc_classes, <br>    CPIC_RETURN_CODES,  cpicerr_return_codes, <br>    CPIC_VERBS_SHORT,   cpicerr_verbs_short, <br>    CPIC_VERBS_LONG,    cpicerr_verbs_long, <br>    MAX_MESSAGE,        NULL <br>}; <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_get_message() <br> * <br> *  Loop through the message arrays looking for the message type and <br> *  message index.  Return a pointer to the appropriate string. <br> * <br> *  This procedure will never return NULL, thus is safe to use in <br> *  printf() type calls. <br> * <br> *****************************************************************************/ <br>char * <br>cpicerr_get_message(CPICERR_MESSAGE_TYPE message_type, CM_INT32 index) <br>{ <br>    unsigned int count;                     /* counter through the array     */ <br> <br>    CPICERR_MESSAGE * messages; <br> <br>    for (count = 0; message_list[count].type &lt; MAX_MESSAGE ; count++ ) { <br>        if (message_list[count].type == message_type) break; <br>    } <br> <br>    if ( (messages = message_list[count].list) == NULL ) { <br>        return "Message list not found."; <br>    } <br> <br>    for (count = 0; messages[count].index &lt; MAX_MESSAGE; count++) { <br>       if (messages[count].index == index) break; <br>    } <br>    return messages[count].message; <br>} <br> <br> <br> <br>/***************************************************************************** <br> * <br> *  cpicerr_show_product_info <br> * <br> *****************************************************************************/ <br>void <br>cpicerr_show_product_info(CPICERR * cpicerr) <br>{ <br>    if (cpicerr-&gt;conv_rc == CM_ALLOCATE_FAILURE_NO_RETRY || <br>        cpicerr-&gt;conv_rc == CM_ALLOCATE_FAILURE_RETRY ) { <br>#if defined(GET_OS2_SENSE_DATA) <br>#if defined(FAPI) <br>        if (get_machine_mode()) { <br>#endif <br>             write_error( <br>             "\n  Retrying Allocate to extract OS/2 sense data:\n"); <br>            cpicerr_os2_appc_allocate(cpicerr); <br>#if defined(FAPI) <br>        } <br>#endif <br>#endif <br> <br>    } <br>} <br> <br>#ifdef GET_OS2_SENSE_DATA <br> <br>cpicerr_os2_appc_allocate(CPICERR * cpicerr) <br>/* <br> * This procedure retries the allocate that failed in CPI-C.  We are not <br> * retrying the allocate to establish the connection, but to get more <br> * error information about why the first allocate failed. <br> * <br> * The OS/2 APPC api is used to extract the sense data, which provides <br> * a more specify reason for an allocation failure. <br> */ <br>{ <br>   TP_STARTED tp_started;                    /* Declare a verb control block */ <br>   TP_STARTED *ptr_tp_started = (TP_STARTED *)&amp;tp_started; <br>   int    length;                            /* length of lu_alias           */ <br>   char   plu_alias[8+1]; <br>   char   fqplu_name[17+1]; <br> <br>   ALLOCATE allocate;                        /* Declare a verb control block */ <br>   ALLOCATE *ptr_allocate = (ALLOCATE *)&amp;allocate; <br> <br>   TP_ENDED tp_ended;                        /* Declare a verb control block */ <br>   TP_ENDED *ptr_tp_ended = (TP_ENDED *)&amp;tp_ended; <br> <br> <br>   CLEAR_VCB(tp_started);                    /* Zero the verb control block  */ <br>   tp_started.opcode = AP_TP_STARTED;        /* APPC verb - TP_STARTED       */ <br> <br>   memset( tp_started.lu_alias, (int)'\0', sizeof(tp_started.lu_alias)); <br> <br>   BLANK_STRING(tp_started.tp_name);         /* Set 64-byte string to blanks */ <br>   ascii_to_ebcdic_field(tp_started.tp_name, <br>                         sizeof(tp_started.tp_name)); <br> <br>   APPC ((ULONG) (TP_STARTED far *)ptr_tp_started); /* Issue the verb        */ <br> <br>   if (tp_started.primary_rc == AP_OK) { <br>       CLEAR_VCB(allocate);                  /* Zero the vcb                 */ <br>       allocate.opcode = AP_B_ALLOCATE;      /* Verb - ALLOCATE              */ <br>       allocate.opext = AP_MAPPED;           /* Basic Conversation type      */ <br> <br>                                             /* Set the TP_ID */ <br>       memcpy (allocate.tp_id, tp_started.tp_id, sizeof(allocate.tp_id)); <br>       allocate.sync_level = AP_CONFIRM;     /* Sync level-confirm           */ <br>       allocate.rtn_ctl = AP_WHEN_SESSION_FREE;/* avoid deadlock             */ <br>       allocate.security = AP_NONE;          /* Set security type            */ <br> <br>       if (!parse_destination(cpicerr-&gt;partner_LU_name, <br>                              plu_alias, <br>                              fqplu_name)) { <br>          if ((length = strlen(plu_alias)) != 0) { <br>             BLANK_STRING(allocate.plu_alias); <br>             memcpy ( allocate.plu_alias, <br>                      plu_alias, <br>                      min(length, sizeof(allocate.plu_alias))); <br>                                             /* Set PLU_ALIAS                */ <br>          } else { <br>             memset (allocate.plu_alias,(int)'\0',sizeof(allocate.plu_alias)); <br>             BLANK_STRING(allocate.fqplu_name);  /* Set FQ PLU NAME          */ <br>             memcpy ( allocate.fqplu_name, <br>                      fqplu_name, <br>                      min(strlen(fqplu_name), sizeof(allocate.fqplu_name))); <br>             TOUPPER_STRING(allocate.fqplu_name, 17); <br>             ascii_to_ebcdic_field(allocate.fqplu_name, <br>                                   sizeof(allocate.fqplu_name)); <br>          } <br> <br> <br>       } else { <br>          BLANK_STRING(allocate.plu_alias); <br>          memcpy ( allocate.plu_alias, <br>                   "UNKNOWN", <br>                   7); <br>       } <br> <br> <br>       BLANK_STRING(allocate.tp_name);       /* Set 64-byte string to blanks */ <br>       ascii_to_ebcdic_field(allocate.tp_name, <br>                             sizeof(allocate.tp_name)); <br> <br>       BLANK_STRING(allocate.mode_name);     /* Set 8-byte string to blanks  */ <br>          memcpy ( allocate.mode_name, <br>                   cpicerr-&gt;mode_name, <br>                   min(strlen(cpicerr-&gt;mode_name), <br>                       sizeof(allocate.mode_name))); <br>          TOUPPER_STRING(allocate.mode_name, 8); <br>       ascii_to_ebcdic_field(allocate.mode_name, <br>                             sizeof(allocate.mode_name)); <br> <br>       APPC((ULONG) (ALLOCATE far *) ptr_allocate);  /* Issue the verb       */ <br> <br>       if (allocate.primary_rc != AP_OK) { <br>        write_error( <br>        "\t OS/2 Sense Data: %08lX\n", SWAP4(allocate.sense_data)); <br> <br>       } <br> <br>   } else {                                  /* Save the returned tp_id      */ <br>       return (tp_started.primary_rc); <br>   } <br>   CLEAR_VCB(tp_ended);                      /* Zero the verb control block  */ <br>   tp_ended.opcode = AP_TP_ENDED;            /* Set the verb opcode          */ <br>                                             /* Set the tp_id  */ <br>   memcpy (tp_ended.tp_id, tp_started.tp_id, sizeof(tp_ended.tp_id)); <br>   tp_ended.type = AP_SOFT;                  /* type: AP_HARD or AP_SOFT     */ <br> <br>   APPC((ULONG) (TP_ENDED far *) ptr_tp_ended); /* Issue the verb.           */ <br>} <br> <br> <br> <br>int <br>parse_destination(char * in_string, <br>                  char * plu_alias, <br>                  char * fqplu_name) <br>/* <br> * This procedure is used by cpicerr_os2_appc_allocate verb <br> */ <br>{ <br>   if (strchr(in_string, '.') != NULL) { <br>      if (in_string[0] == '.') { <br>          in_string++; <br>      } <br>      strcpy(fqplu_name, in_string); <br>      plu_alias[0] = '\0'; <br>   } else { <br>      strcpy(plu_alias, in_string); <br>      fqplu_name[0] = '\0'; <br>   } <br>   return 0; <br> <br>} <br> <br>#endif <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
