<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5099"></a>CLIENT.C</h2>
<pre><code>/* <br>Copyright (c) 1994, 1993 Microsoft Corporation <br> <br>Module Name: <br>    Client.c <br> <br>Abstract: <br>    The Client component of Remote. Connects to the remote <br>    server using named pipes. It sends its stdin to <br>    the server and output everything from server to <br>    its stdout. <br> <br>Author: <br>    Rajivendra Nath (rajnath) 2-Jan-1993 <br> <br>Environment: <br>    Console App. User mode. <br> <br>Revision History: <br>Alex Wetmore (t-alexwe) 6-Jun-1994 <br>- converted remote to use APPC with Windows SNA Server instead of named <br>  pipes <br>*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winappc.h&gt; <br>#include "appclib.h" <br>#include "aremote.h" <br> <br>tpconvid_t EstablishSession(TCHAR *locallu, TCHAR *serverlu, TCHAR *tpname,  <br>TCHAR *loctpname, TCHAR *mode_name); <br>DWORD WINAPI GetServerOut(PVOID *Noarg); <br>DWORD WINAPI SendServerInp(PVOID *Noarg); <br>BOOL FilterClientInp(TCHAR *buff, int count); <br>BOOL Mych(DWORD ctrlT); <br>VOID SendMyInfo(tpconvid_t tpconv); <br> <br> <br>HANDLE iothreads[2]; <br>HANDLE MyStdInp; <br>HANDLE MyStdOut; <br>tpconvid_t tpconv; <br> <br> <br>CONSOLE_SCREEN_BUFFER_INFO csbi; <br> <br>TCHAR   MyEchoStr[30]; <br>BOOL   CmdSent; <br>DWORD  LinesToSend=LINESTOSEND; <br> <br>VOID Client(TCHAR *local_lu, TCHAR *server_lu, TCHAR *tp_name,  <br>        TCHAR *loc_tp_name, TCHAR *mode_name) { <br>    DWORD  tid; <br> <br> <br>    MyStdInp=GetStdHandle(STD_INPUT_HANDLE); <br>    MyStdOut=GetStdHandle(STD_OUTPUT_HANDLE); <br> <br>    WRITEF((VBuff,TEXT("**************************************\n"))); <br>    WRITEF((VBuff,TEXT("***********     REMOTE    ************\n"))); <br>    WRITEF((VBuff,TEXT("***********     CLIENT    ************\n"))); <br>    WRITEF((VBuff,TEXT("**************************************\n"))); <br> <br>tpconv = EstablishSession(local_lu, server_lu, tp_name, loc_tp_name,  <br>mode_name); <br>if (tpconv == NULL) { <br>appcdestroy(); <br>return; <br>} <br> <br>    SetConsoleCtrlHandler((PHANDLER_ROUTINE)Mych,TRUE); <br> <br>    // Start Thread For Server --&gt; Client Flow <br>    if ((iothreads[0]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,     // No security attributes. <br>            (DWORD)0,                           // Use same stack size. <br>            (LPTHREAD_START_ROUTINE)GetServerOut, // Thread procedure. <br>            (LPVOID)NULL,              // Parameter to pass. <br>            (DWORD)0,                           // Run immediately. <br>            (LPDWORD)&amp;tid))==NULL)              // Thread identifier. <br>    { <br> <br>        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread")); <br>        return; <br>    } <br> <br> <br> <br>    // <br>    // Start Thread for Client --&gt; Server Flow <br>    // <br> <br>    if ((iothreads[1]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes. <br>                    (DWORD)0,                           // Use same stack size. <br>                    (LPTHREAD_START_ROUTINE)SendServerInp, // Thread procedure. <br>                    (LPVOID)NULL,          // Parameter to pass. <br>                    (DWORD)0,                           // Run immediately. <br>                    (LPDWORD)&amp;tid))==NULL)              // Thread identifier. <br>    { <br> <br>        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread")); <br>        return; <br>    } <br> <br>    WaitForSingleObject(iothreads[0], INFINITE); <br> <br>    TerminateThread(iothreads[1],1); <br> <br>appcclose(tpconv); <br>appcdestroy(); <br> <br>WRITEF((VBuff,TEXT("*** SESSION OVER ***\n"))); <br>} <br> <br> <br>DWORD WINAPI GetServerOut(PVOID *Noarg) { <br>    TCHAR buffin[1024]; <br>    DWORD dread=0,tmp; <br> <br>while (appcvalid(tpconv)) { <br>dread = appcread(tpconv, (void *) buffin, 1000); <br>if (dread &gt; 0) { <br>if (!WriteConsole(MyStdOut, buffin, dread/2, &amp;tmp, NULL)) <br>break; <br>} <br>} <br>    return 1; <br>} <br> <br>DWORD WINAPI SendServerInp(PVOID *Noarg) { <br>    TCHAR buff[1000]; <br>    DWORD dread; <br>    SetLastError(0); <br> <br>    while(ReadConsole(MyStdInp,buff,999,&amp;dread,NULL)) { <br>        if (FilterClientInp(buff, dread)) continue; <br>appcwrite(tpconv, (void *) buff, dread * sizeof(TCHAR)); <br>    } <br>    return 0; <br>} <br> <br>BOOL FilterClientInp(TCHAR *buff, int count) { <br>    if (count==0) <br>        return(TRUE); <br> <br>    if (buff[0]==2)  //Adhoc screening of ^B so that i386kd/mipskd <br>        return(TRUE);//do not terminate. <br> <br>    if (buff[0]==COMMANDCHAR) { <br>        switch (tolower(buff[1])) { <br>        case TEXT('k'): <br>        case TEXT('q'): <br>            return(FALSE); <br> <br>        case TEXT('h'): <br>            WRITEF((VBuff,TEXT("%cM : Send Message\n"),COMMANDCHAR)); <br>            WRITEF((VBuff,TEXT("%cP : Show Popup on Server\n"),COMMANDCHAR)); <br>            WRITEF((VBuff,TEXT("%cS : Status of Server\n"),COMMANDCHAR)); <br>            WRITEF((VBuff,TEXT("%cQ : Quit client\n"),COMMANDCHAR)); <br>            WRITEF((VBuff,TEXT("%cH : This Help\n"),COMMANDCHAR)); <br>            return(TRUE); <br> <br>        default: <br>            return(FALSE); <br>        } <br> <br>    } <br>    return(FALSE); <br>} <br> <br> <br>BOOL Mych(DWORD ctrlT) { <br>    TCHAR  c[3]; <br>    DWORD send; <br> <br>    if (ctrlT==CTRL_C_EVENT) { <br>c[0] = 3; <br>send = 1; <br>appcwrite(tpconv, (void *) c, send); <br>    } <br>    if ((ctrlT==CTRL_BREAK_EVENT) || <br>        (ctrlT==CTRL_CLOSE_EVENT) || <br>        (ctrlT==CTRL_LOGOFF_EVENT) || <br>        (ctrlT==CTRL_SHUTDOWN_EVENT)) { <br>c[0] = COMMANDCHAR; <br>c[1] = TEXT('q'); <br>send = 2; <br>appcwrite(tpconv, (void *) c, send); <br>    } <br>    return(TRUE); <br>} <br> <br>tpconvid_t EstablishSession(TCHAR *local_lu, TCHAR *server_lu, TCHAR *tp_name,  <br>                            TCHAR *loc_tp_name, TCHAR *mode_name) { <br>TCHAR buf[255]; <br>tpconvid_t tpconv; <br> <br>appcinit(); <br>WRITEF((VBuff, TEXT("\nClient Connection Information:\n"))); <br>WRITEF((VBuff, TEXT("  Local LU       = %ws\n"), local_lu)); <br>WRITEF((VBuff, TEXT("  Server LU      = %ws\n"), server_lu)); <br>WRITEF((VBuff, TEXT("  Server TP Name = %ws\n"), tp_name)); <br>WRITEF((VBuff, TEXT("  Client TP Name = %ws\n"), loc_tp_name)); <br>WRITEF((VBuff, TEXT("  Mode Name      = %ws\n"), mode_name)); <br>WRITEF((VBuff, TEXT("\n"))); <br>WRITEF((VBuff, TEXT("Connecting . . . "))); <br> <br>// connect to the server <br>tpconv = appcconnect(local_lu, server_lu, tp_name, loc_tp_name, mode_name); <br> <br>// the server will either send us zero bytes (signifying a valid  <br>// connection), or close our connection.  If it is closed then <br>// let the client know <br>appcread(tpconv, buf, 255); <br>if (!appcvalid(tpconv)) { <br>WRITEF((VBuff,  <br>TEXT("Remote: server doesn't have any available sessions\n"))); <br>return NULL; <br>} <br>if (lstrcmp(buf, REMOTE_INIT_MSG) != 0) { <br>WRITEF((VBuff,  <br>TEXT("Remote: this doesn't seem to be a remote server\n"))); <br>return NULL; <br>} <br> <br>WRITEF((VBuff, TEXT("\rConnected        \n\n"))); <br>SendMyInfo(tpconv); <br> <br>return tpconv; <br>} <br> <br>VOID SendMyInfo(tpconvid_t tpconv) { <br>    DWORD  hostlen=HOSTNAMELEN-1; <br>    DWORD  tmp, BytesToRead; <br>    SESSION_STARTUPINFO ssi; <br>    SESSION_STARTREPLY  ssr; <br>    TCHAR   *buff; <br> <br>// fill out the SESSION_STARTUPINFO structure <br>    ssi.MagicNumber = MAGICNUMBER; <br>    GetComputerName((TCHAR *) ssi.ClientName, &amp;hostlen); <br>    ssi.LinesToSend = LinesToSend; <br>    ssi.Flag = ClientToServerFlag; <br>appcwrite(tpconv, (void *) &amp;ssi, sizeof(ssi)); <br> <br>// receive a SESSION_STARTUPREPLY structure <br>appcread(tpconv, (void *) &amp;ssr, sizeof(ssr)); <br> <br>if (ssr.MagicNumber &lt; MAGICNUMBER) { <br>WRITEF((VBuff, TEXT("Warning: this APPC Remote server is older than your client\n"))); <br>} else if (ssr.MagicNumber &gt; MAGICNUMBER) { <br>WRITEF((VBuff, TEXT("Warning: your APPC Remote client is older than the server \n"))); <br>} <br> <br>    BytesToRead=MINIMUM(ssr.FileSize,ssi.LinesToSend*CHARS_PER_LINE); <br>    buff=calloc(BytesToRead+1,sizeof(TCHAR)); <br>    if (buff!=NULL) <br>    { <br>        DWORD  bytesread=0; <br> <br>        bytesread = appcread(tpconv, (void *) buff, BytesToRead*sizeof(TCHAR)); <br> <br>        WriteConsole(MyStdOut,buff,bytesread/sizeof(TCHAR),&amp;tmp,NULL); <br>        LocalFree(buff); <br>    } <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
