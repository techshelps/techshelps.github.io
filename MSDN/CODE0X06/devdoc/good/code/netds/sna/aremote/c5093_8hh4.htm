<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ARSETUP.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5098"></a>ARSETUP.H</h2>
<pre><code>#include "setupdlg.h" <br>#define MAXREGPATHLEN1024     // Max length of registry path <br>#define MAXTPLEN128             // Max length of TP name <br>#define MAXBINPATHLEN   256             // Max length of file path <br>#define MAXPARAMLEN  128        // Max length of command-line parameters <br>#define MAXUSERNAMELEN  32// Max length of username <br>#define MAXPASSWORDLEN  32// Max length of password <br>#define MAXLULEN8// Max length of LU name <br> <br>#define VALIDATE_INT 1 <br>#define VALIDATE_APPC 2 <br> <br>#define INFINITE_TIMEOUT  "-1"     // Value used for infinite timeout <br>#define INIT_TIMEOUT    5     // Initial value displayed in timeout box <br>#define MAXTIMEOUTLEN5     // Max digits in timeout <br> <br>#ifdef WIN32 <br> <br>typedef struct _KeyEntry { <br>  LPSTR lpParent;                       // Parent key <br>  LPSTR lpName;                         // Data field name <br>  int   iDataType;                      // Type of data <br>  LPSTR lpData;// Data itself <br>  int   iDataSize;// Length of data, including nulls <br>} KEYENTRY; <br> <br>// The following variable defines the subkeys that are placed in the registry. <br>// The first field gives the key under which to create the new subkey.  The <br>// second field is the subkey name.  The third field is the data type. <br>// The fourth field gives the data itself.  This should always be a string, <br>// HOWEVER, if the third field isn't REG_SZ, some interpretation will go on, <br>// as follows: <br>//   If the third field is REG_MULTI_SZ, you should add an extra null character <br>//   to the end of the string to simulate an array of strings. <br>//   If the third field is REG_DWORD, you should enter the numeric value as <br>//   a string in the fourth field, as in "345" if you want the data to be the <br>//   number 345. <br>// The fifth field is the length of the fourth field in bytes, INCLUDING nulls. <br>// This field is set automatically for REG_DWORD data. <br>KEYENTRY keyinfo[] = { <br>  { "Linkage",    "OtherDependencies",    REG_MULTI_SZ, "SnaBase\0", 9 }, <br>  { "Parameters", "SNAServiceType",       REG_DWORD,    "5",         4 }, <br>  { "Parameters", "ConversationSecurity", REG_SZ,       "yes",       4 }, <br>  { "Parameters", "AlreadyVerified",      REG_SZ,       "yes",       4 }, <br>  { "Parameters", "Timeout",              REG_DWORD,    "",     4 }, <br>  { "Parameters", "Parameters",           REG_SZ,       "",       4 }, <br>  { "Parameters", "LocalLU",              REG_SZ,       "",     4 }, <br>  { "Parameters", "",                     REG_SZ,       "",          4 }, <br>  { "Parameters", "PathName",             REG_SZ,       "",          4 }, <br>}; <br> <br>// These numbers must correspond to the indices in keyinfo above! <br>#define SNASRVTYPE 1 <br>#define CONVSEC    2 <br>#define ALREADYVER 3 <br>#define TIMEOUT    4 <br>#define PARAMETERS 5 <br>#define LUNAME     6 <br>#define USER       7  // Blank field for writing out users &amp; passwords <br>#define EXENAME    8 <br>#define NUMKEYS    6      // Last three keys only written out if needed <br> <br>int  InstallServiceNT(HWND, LPSTR, LPSTR); <br>int  CreateKeys(LPSTR, BOOL, LPSTR, int, int, int, LPSTR, LPSTR, LPSTR); <br>INT  WriteKeyNT(LPSTR, KEYENTRY, BOOL); <br> <br>#else <br> <br>#define USHORT unsigned short <br>#define INT    int <br>#define SHORT  short <br> <br>typedef struct _KeyEntry { <br>  char *name;                        // Data field name <br>  char *data;     // Data itself <br>} KEYENTRY; <br> <br>// If you change the fields below, change the #defines too; they are used <br>// as indices into the keyinfo structure to set the data fields, which are <br>// initially all NULL. <br> <br>KEYENTRY keyinfo[] = { <br>  { "PathName",     NULL }, <br>  { "Parameters",     NULL }, <br>  { "Queued",     NULL }, <br>  { "Timeout",     NULL }, <br>  { "ConversationSecurity", NULL }, <br>  { "AlreadyVerified",      NULL }, <br>  { "LocalLU",    NULL }, <br>  { "",                     NULL }, <br>}; <br>#define PATHNAME    0 <br>#define PARAMETERS  1 <br>#define QUEUED      2 <br>#define TIMEOUT     3 <br>#define CONVSEC     4 <br>#define ALREADYVER  5 <br>#define LUNAME      6 <br>#define USER        7 <br>#define NUMKEYS     6// Last keys only written out if necessary <br> <br>int  InstallWindows(HWND, char *, char *, char *, char *, int, int, int, char *); <br>INT  WriteKeyWindows(char *, char *, char *); <br> <br>#endif //ifdef WIN32 <br> <br>extern BOOL CALLBACK MainDlgProc (HWND, UINT, WPARAM, LPARAM); <br>extern BOOL CALLBACK UserDlgProc (HWND, UINT, WPARAM, LPARAM); <br>BOOL ValidateField(HWND, USHORT); <br>void InstallCallback(HWND, UINT, WNDPROC *, FARPROC); <br>extern LRESULT CALLBACK ValidateFieldInt(HWND, WORD, WPARAM, LPARAM); <br>extern LRESULT CALLBACK ValidateFieldAppc(HWND, WORD, WPARAM, LPARAM); <br>extern LRESULT CALLBACK InfiniteWndProc(HWND, WORD, WPARAM, LPARAM); <br>extern LRESULT CALLBACK FiniteWndProc(HWND, WORD, WPARAM, LPARAM); <br>extern LRESULT CALLBACK ConvSecWndProc(HWND, WORD, WPARAM, LPARAM); <br>extern LRESULT CALLBACK ServiceWndProc(HWND, WORD, WPARAM, LPARAM); <br>void ParseCreateError(HWND, UINT); <br>void DeleteListItem(INT); <br>INT  ReadString(HWND, INT, char **, INT); <br>void DisplayError(HWND, UINT); <br>void DisplayInfo(HWND, UINT); <br>void MakeValidLUName(LPTSTR name); </code></pre>
<p>&nbsp;</p></body>
</HTML>
