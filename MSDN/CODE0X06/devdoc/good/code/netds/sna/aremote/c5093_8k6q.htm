<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5102"></a>SERVER.C</h2>
<pre><code>/* <br>Copyright (c) 1994, 1993 Microsoft Corporation <br> <br>Module Name: <br>    Server.c <br> <br>Abstract: <br>    The server component of Remote. It spawns a child process <br>    and redirects the stdin/stdout/stderr of child to itself. <br>    Waits for connections from clients - passing the <br>    output of child process to client and the input from clients <br>    to child process. <br> <br>Author: <br>    Rajivendra Nath (rajnath) 2-Jan-1993 <br> <br>Environment: <br>    Console App. User mode. <br> <br>Revision History: <br>Alex Wetmore (t-alexwe) 6-Jun-1994 <br>- converted remote to use APPC with Windows SNA Server instead of named <br>  pipes <br>- converted to use Unicode <br>*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winappc.h&gt; <br>#include "appclib.h" <br>#include "aremote.h" <br> <br>#define COMMANDFORMAT       TEXT("%c%-15s    [%-15s %d:%d]\n%c") <br>#define RemoteInfo(prt,flg) {if (!(flg&amp;0x80000000)) prt;} <br> <br>#define CMDSTRING(OutBuff,InpBuff,Client,sTime) \ <br>        {                                \ <br>            /* int xxlen; */             \ <br>            wsprintf                      \ <br>            (                            \ <br>               &amp;OutBuff[0],COMMANDFORMAT,\ <br>               BEGINMARK,InpBuff,        \ <br>               Client-&gt;Name,sTime.wHour, \ <br>               sTime.wMinute,ENDMARK     \ <br>            );                           \ <br>         } <br> <br>#define BUFFSIZE      1024 <br> <br>SESSION_TYPE ClientList[MAX_SESSION]; <br> <br>HANDLE  ChildStdInp;     //Server Writes to  it <br>HANDLE  ChildStdOut;     //Server Reads from it <br>HANDLE  ChildStdErr;     //Server Reads from it <br> <br>HANDLE  SaveFile;       //File containing all that was <br>                        //output by child process. <br>                        //Each connection opens a handle to this file <br>                        //and is sent through PipeWriteH. <br> <br>TCHAR   SaveFileName[64]; //Name of above file - all new sessions need <br>HANDLE  ChldProc;         //Handle to the Child Process <br>HANDLE  ListenThreadH;    //Handle to the thread listening for connections <br>                          //from Remote Clients. <br>extern BOOL AutoStarted;// true if this is an autostarted service <br> <br>CRITICAL_SECTIONclose_crit;// critical section for closing <br> <br>HANDLE <br>ForkChildProcess(          // Creates a new process <br>    TCHAR *cmd,             // Redirects its stdin,stdout <br>    PHANDLE in,            // and stderr - returns the <br>    PHANDLE out,           // corresponding pipe ends. Using currently <br>    PHANDLE err <br>    ); <br> <br>DWORD WINAPI <br>ListenForSession(          //THREAD:Listens for new connections and <br>    TCHAR* pipe             //spawns of new seesions - Updates the <br>    );                     //Status in Client DataStructure. Seperate Thread. <br> <br>// <br>// threads for dealing with local session (only when non-autostarted) <br>DWORD WINAPI LocalSession(SESSION_TYPE *cli); <br>DWORD WINAPI StdoutThread(SESSION_TYPE *cli); <br>DWORD WINAPI StdinThread(SESSION_TYPE *cli); <br> <br>BOOL <br>CreateMySecurityDescriptor(                    // <br>    PSECURITY_DESCRIPTOR pSecurityDescriptor,  // Creates a security descriptor <br>    TCHAR *Owner                                // with discretionary access for <br>    );                                         // access for Owner. <br> <br> <br>DWORD <br>NewSession(                //Manages the session with a client. <br>    SESSION_TYPE* Client <br>    ); <br> <br>DWORD WINAPI               //2 THREAD:Each reads either <br>GetChldOutput(             //StdOut or StdErr of child and <br>    HANDLE rhandle         //writes to SaveFile. Seperate Thread. <br>    ); <br> <br>DWORD WINAPI <br>TransferFileToClient(      //X THREADS:Reads the save <br>    SESSION_TYPE* Client   //file and sendsoutput to a client. Seperate Thread <br>    ); <br> <br> <br>DWORD WINAPI <br>GetClientInput(            //Times X THREADS:Gets input from Child pipe <br>    SESSION_TYPE* Client   //and sends to childs StdIn. Seperate Thread. <br>    ); <br> <br> <br>BOOL <br>FilterCommand(             //Filters input from client <br>    SESSION_TYPE *cl,      //for commands intended for REMOTE <br>    TCHAR *buff, <br>    int dread <br>    ); <br> <br>DWORD WINAPI               // Manages the IO with Remote Client. <br>RemoteSession( <br>    SESSION_TYPE* Client <br>    ); <br> <br>BOOL                       // Ctrl-C handler <br>SrvCtrlHand( <br>    DWORD event <br>    ); <br> <br>VOID                       // @s command to remote <br>SendStatus( <br>    tpconvid_t tpconv <br>    ); <br> <br>DWORD WINAPI               // @p command to remote <br>ShowPopup( <br>    TCHAR *mssg <br>    ); <br> <br>VOID                       // Removes the command begin and end markers <br>RemoveInpMark(             // from the save file. <br>    char* Buff, <br>    DWORD Size <br>    ); <br> <br>VOID                       // Cleans up the session <br>CloseClient(               // once it ends. <br>    SESSION_TYPE *Client <br>    ); <br>                           // Initialises the Client datastructs <br>VOID <br>InitClientList( <br>    ); <br> <br> <br>/*************************************************************/ <br>/* The main entry point for the Server End of Remote         */ <br>/*************************************************************/ <br>VOID Server(TCHAR* ChildCmd, TCHAR *tp_name) { <br>    DWORD  ThreadID ; <br>    HANDLE WaitH[3], objs[MAX_SESSION]; <br>    DWORD  WaitObj; <br>    TCHAR  tmpdir[32]; <br>int    i, active; <br> <br>    WRITEF((VBuff, TEXT("**************************************\n"))); <br>    WRITEF((VBuff, TEXT("***********     REMOTE    ************\n"))); <br>    WRITEF((VBuff, TEXT("***********     SERVER    ************\n"))); <br>    WRITEF((VBuff, TEXT("**************************************\n"))); <br> <br>    InitClientList(); <br> <br>appcinit(); <br> <br>// <br>// This critical section is used around close so that only one appcclose <br>// is happening at a time. <br>// <br>InitializeCriticalSection(&amp;close_crit); <br> <br>    // <br>    //Start the command as a child process <br>    // <br> <br>    ChldProc=ForkChildProcess(ChildCmd,&amp;ChildStdInp,&amp;ChildStdOut,&amp;ChildStdErr); <br> <br>    // <br>    //Create a tempfile for storing Child process output. <br>    // <br>    { <br>         DWORD size=sizeof(tmpdir); <br>         if ( <br>             (GetEnvironmentVariable(TEXT("TMP"),tmpdir,size)==0)&amp;&amp; <br>             (GetEnvironmentVariable(TEXT("TEMP"),tmpdir,size)==0) <br>            ) <br>         { <br>            wsprintf(tmpdir,TEXT("%ws"),TEXT(".")); <br>         } <br>         if (!GetTempFileName(tmpdir,TEXT("REMOTE"),0,SaveFileName)) <br>            GetTempFileName(TEXT("."),TEXT("REMOTE"),0,SaveFileName); <br>    } <br> <br> <br>    if ((SaveFile=CreateFile <br>                  ( <br>                     (LPCTSTR)SaveFileName,           /* address of name of the file  */ <br>                     GENERIC_READ|GENERIC_WRITE,      /* access (read/write) mode */ <br>                     FILE_SHARE_READ|FILE_SHARE_WRITE,/* share mode   */ <br>                     (LPSECURITY_ATTRIBUTES)NULL,     /* security descriptor  */ <br>                     CREATE_ALWAYS,                   /* how to create    */ <br>                     FILE_ATTRIBUTE_NORMAL,           /* File Attribute */ <br>                     (HANDLE)NULL) <br>                  )==NULL) <br>    { <br>        TerminateProcess(ChldProc,0); <br>        ErrorExit(TEXT("Could not Create Output File")); <br>    } <br> <br> <br>    // <br>    //Start 2 threads to save the output from stdout and stderr of cmd to savefile. <br>    // <br> <br>    if ((WaitH[0]=CreateThread <br>                  ( <br>                     (LPSECURITY_ATTRIBUTES)NULL,           // No security attributes. <br>                     (DWORD)0,                              // Use same stack size. <br>                     (LPTHREAD_START_ROUTINE)GetChldOutput, // Thread procedure. <br>                     (LPVOID)ChildStdErr,                   // Parameter to pass. <br>                     (DWORD)0,                              // Run immediately. <br>                     (LPDWORD)&amp;ThreadID) <br>                   )==NULL) <br>    { <br> <br>        TerminateProcess(ChldProc,0); <br>        ErrorExit(TEXT("Failed to Create GetGhldOutput#1 Thread")); <br>    } <br> <br> <br>    if ((WaitH[1]=CreateThread <br>                  ( <br>                     (LPSECURITY_ATTRIBUTES)NULL,           // No security attributes. <br>                     (DWORD)0,                              // Use same stack size. <br>                     (LPTHREAD_START_ROUTINE)GetChldOutput, // Thread procedure. <br>                     (LPVOID)ChildStdOut,                   // Parameter to pass. <br>                     (DWORD)0,                              // Run immediately. <br>                     (LPDWORD)&amp;ThreadID) <br>                  )==NULL) <br>    { <br> <br>        TerminateProcess(ChldProc,0); <br>        ErrorExit(TEXT("Failed to Create GetGhldOutput#2 Thread")); <br>    } <br> <br> <br>    // <br>    // Start Thread for local session <br>// only run if this is not an autostarted TP <br>    // <br>if (!AutoStarted) { <br>ClientList[0].Active = TRUE; <br>   if ((ClientList[0].hThread = CreateThread( <br>      (LPSECURITY_ATTRIBUTES) NULL,   // No security attributes. <br>      (DWORD) 0,                      // Use same stack size. <br>      (LPTHREAD_START_ROUTINE) LocalSession, // Thread procedure. <br>      (LPVOID) &amp;ClientList[0],            // Parameter to pass. <br>      (DWORD) 0,                          // Run immediately. <br>      (LPDWORD) &amp;ThreadID))==NULL) { <br>       TerminateProcess(ChldProc,0); <br>       ErrorExit(TEXT("Failed To Create LocalSession Thread")); <br>   } <br>} <br> <br>    // <br>    //Start Thread to listen for new Connections <br>    // <br> <br>    if ((ListenThreadH=CreateThread <br>                       ( <br>                         (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes. <br>                         (DWORD)0,                           // Use same stack size. <br>                         (LPTHREAD_START_ROUTINE)ListenForSession, // Thread procedure. <br>                         (LPVOID)tp_name,                    // Parameter to pass. <br>                         (DWORD)0,                           // Run immediately. <br>                         (LPDWORD)&amp;ThreadID) <br>                       )==NULL) <br>    { <br> <br>        TerminateProcess(ChldProc,0); <br>        ErrorExit(TEXT("Failed To Create ListenForSession Thread")); <br> <br>    } <br> <br>    SetConsoleCtrlHandler((PHANDLER_ROUTINE)SrvCtrlHand,TRUE); <br> <br>    WaitH[2]=ChldProc; <br> <br>    // <br>    // Wait until the child process terminates <br>    // or local IO thread terminates <br>    // or IO with child process ends <br>    // <br> <br>    WaitObj=WaitForMultipleObjects(3,WaitH,FALSE,INFINITE); <br> <br>    switch (WaitObj-WAIT_OBJECT_0) <br>    { <br>        case 0:      // Error Writing to savefile <br>        case 1: <br>            TerminateProcess(ChldProc,0); <br>            break; <br>        case 2:      // Child Proc Terminated <br>            break; <br> <br>        default:     // Out of Some Resource <br>            WRITEF((VBuff, <br>TEXT("Out of Resource Error %d..Terminating\n"), <br>GetLastError())); <br>            break; <br> <br>    } <br> <br>    TerminateThread(ListenThreadH,0); <br> <br>    CloseHandle(ChildStdInp); <br>    CloseHandle(ChildStdOut); <br>    CloseHandle(ChildStdErr); <br> <br>    WRITEF((VBuff, <br>TEXT("\nServer: Child process \"%ws\" died, parent exiting...\n"), <br>ChildCmd)); <br> <br>    CloseHandle(SaveFile); <br> <br>// signal all of the client threads to tell them that they should die <br>for (i = 0, active = 0; i &lt; MAX_SESSION; i++) { <br>if (ClientList[i].Active) { <br>SetEvent(ClientList[i].DoClose); <br>objs[active++] = ClientList[i].hThread; <br>} <br>} <br> <br>// Wait for all of the client to die gracefully <br>WaitForMultipleObjects(active, objs, TRUE, INFINITE); <br> <br>    for (i = 0; i &lt; MAX_SESSION; i++) { <br>    if (ClientList[i].rSaveFile != INVALID_HANDLE_VALUE) <br>        CloseHandle(ClientList[i].rSaveFile); <br> <br>    if (ClientList[i].MoreData != NULL) <br>        CloseHandle(ClientList[i].MoreData); <br>} <br> <br>    if (!DeleteFile(SaveFileName)) <br>          WRITEF((VBuff,TEXT("Temp File %ws not deleted..\n"),SaveFileName)); <br> <br>appcdestroy(); <br> <br>    return; <br>} <br> <br>/*************************************************************/ <br>/* Creates the child process and redirects its std.IO handles*/ <br>/*************************************************************/ <br>// these handles should be treated as if they send and receive ANSI, not Unicode <br>HANDLE <br>ForkChildProcess(          // Creates a new process <br>    TCHAR *cmd,             // Redirects its stdin,stdout <br>    PHANDLE inH,           // and stderr - returns the <br>    PHANDLE outH,          // corresponding pipe ends. <br>    PHANDLE errH <br>    ) <br>{ <br>    SECURITY_ATTRIBUTES lsa; <br>    STARTUPINFO         si; <br>    PROCESS_INFORMATION pi; <br> <br>    HANDLE ChildIn; <br>    HANDLE ChildOut; <br>    HANDLE ChildErr; <br> <br>    lsa.nLength=sizeof(SECURITY_ATTRIBUTES); <br>    lsa.lpSecurityDescriptor=NULL; <br>    lsa.bInheritHandle=TRUE; <br> <br>    // <br>    //Create Parent_Write to ChildStdIn Pipe <br>    // <br> <br>    if (!CreatePipe(&amp;ChildIn,inH,&amp;lsa,0)) <br>        ErrorExit(TEXT("Could Not Create Parent--&gt;Child Pipe")); <br> <br>    // <br>    //Create ChildStdOut to Parent_Read pipe <br>    // <br> <br>    if (!CreatePipe(outH,&amp;ChildOut,&amp;lsa,0)) <br>        ErrorExit(TEXT("Could Not Create Child--&gt;Parent Pipe")); <br> <br>    // <br>    //Create ChildStdOut to Parent_Read pipe <br>    // <br> <br>    if (!CreatePipe(errH,&amp;ChildErr,&amp;lsa,0)) <br>        ErrorExit(TEXT("Could Not Create Child--&gt;Parent Pipe")); <br> <br>    // <br>    // Lets Redirect Console StdHandles - easy enough <br>    // <br> <br> <br>    si.cb=sizeof(STARTUPINFO); <br>    si.lpReserved=NULL; <br>    si.lpTitle=NULL; <br>    si.lpDesktop=NULL; <br>    si.dwX=si.dwY=si.dwYSize=si.dwXSize=0; <br>    si.dwFlags=STARTF_USESTDHANDLES; <br>    si.hStdInput =ChildIn; <br>    si.hStdOutput=ChildOut; <br>    si.hStdError =ChildErr; <br>    si.wShowWindow=SW_SHOW; <br>    si.lpReserved2=NULL; <br>    si.cbReserved2=0; <br> <br>    // <br>    //Create Child Process <br>    // <br> <br>    if (!CreateProcess <br>         ( <br>            NULL, <br>            cmd, <br>            NULL, <br>            NULL, <br>            TRUE, <br>            NORMAL_PRIORITY_CLASS, <br>            NULL, <br>            NULL, <br>            &amp;si, <br>            &amp;pi) <br>         ) <br>    { <br>        if (GetLastError()==2) <br>            WRITEF((VBuff,TEXT("Executable %ws not found\n"),cmd)); <br>        ErrorExit(TEXT("Could Not Create Child Process")); <br>    } <br> <br>    // <br>    //Close unneccesary Handles and Restore the crt handles <br>    // <br> <br>    CloseHandle(ChildIn); <br>    CloseHandle(ChildOut); <br>    CloseHandle(ChildErr); <br> <br>    return(pi.hProcess); <br>} <br> <br>/*************************************************************/ <br>/* Listens for sessions from Clients and creates a new thread*/ <br>/* for each client                                           */ <br>/*************************************************************/ <br> <br>DWORD WINAPI ListenForSession(TCHAR* tp_name) { <br>    int    i; <br>    DWORD  ThreadID; <br>tpconvid_t tpconv; <br>    HANDLE TokenHandle; <br>    TOKEN_DEFAULT_DACL DefaultDacl; <br> <br>WRITEF((VBuff, TEXT("\nServer: Waiting for clients on TP: %ws\n\n"), tp_name)); <br> <br>    DefaultDacl.DefaultDacl = NULL; <br> <br>    if (OpenProcessToken <br>        ( <br>            GetCurrentProcess(), <br>            TOKEN_ADJUST_DEFAULT, <br>            &amp;TokenHandle <br>        )) <br>    { <br> <br>        // <br>        // Remove the default DACL on the token <br>        // <br> <br>        SetTokenInformation <br>        ( <br>            TokenHandle, <br>            TokenDefaultDacl, <br>            &amp;DefaultDacl, <br>            sizeof( TOKEN_DEFAULT_DACL ) <br>        ); <br> <br>    } <br> <br>    while(TRUE) { <br>tpconv = appclisten(tp_name); <br> <br>        // <br>        // Look For a Free Slot <br>// There is guaranteed to be one or appclisten wouldn't have run. <br>        // <br> <br>        for (i = 0; i &lt; MAX_SESSION; i++) { <br>            // <br>            // Locate a Free Client block <br>            // <br>            if (!ClientList[i].Active) break; <br>        } <br> <br>// check to see if we couldn't find a free session <br>if (i == MAX_SESSION) { <br>WRITEF((VBuff, TEXT("\nServer: Client tried to connect with all sessions in use\n"))); <br>appcclose(tpconv); <br>continue; <br>} else { <br>appcwrite(tpconv, REMOTE_INIT_MSG, <br>lstrlen(REMOTE_INIT_MSG) * sizeof(TCHAR)); <br>} <br> <br>        // <br>        // Initialize the Client <br>        // <br>        ClientList[i].tpconv = tpconv; <br>        ClientList[i].Active = TRUE; <br>        ClientList[i].SendOutput = TRUE; <br>        ClientList[i].CommandRcvd = FALSE; <br> <br>        // <br>        //start new thread for this connection <br>        // <br> <br>        if((ClientList[i].hThread=CreateThread <br>            ( <br>                 (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes. <br>                 (DWORD)0,                           // Use same stack size. <br>                 (LPTHREAD_START_ROUTINE)RemoteSession, // Thread procedure. <br>                 (LPVOID)&amp;ClientList[i],             // Parameter to pass. <br>                 (DWORD)0,                           // Run immediately. <br>                 (LPDWORD)&amp;ThreadID) <br>            )==NULL) <br>        { <br>            CloseClient(&amp;ClientList[i]); <br>            continue; <br>        } <br> <br>    } <br>    return(0); <br>} <br> <br>/*************************************************************/ <br>/* Creates a security descriptor with the discrtionry access */ <br>/* for the account specified in the /U switch  if any        */ <br>/*************************************************************/ <br> <br>BOOL <br>CreateMySecurityDescriptor( <br>    PSECURITY_DESCRIPTOR pSecurityDescriptor, <br>    TCHAR *Owner <br>    ) <br>{ <br>    PSID pOwnerSid; <br>    PACL pAcl; <br>    BOOL Ret=FALSE; <br> <br>    // <br>    // Initialize the Security Descriptor struct. <br>    // <br> <br> <br>    InitializeSecurityDescriptor <br>    ( <br>        pSecurityDescriptor, <br>        SECURITY_DESCRIPTOR_REVISION <br>    ); <br> <br>    if (Owner==NULL) <br>    { <br>        // <br>        // No security required. <br>        // <br> <br>        SetSecurityDescriptorDacl <br>        ( <br>               pSecurityDescriptor, <br>               TRUE, <br>               NULL, <br>               FALSE <br>        ); <br> <br>        return TRUE; <br>    } <br> <br>    { <br>        // <br>        // Get the SID for the account/Group <br>        // <br> <br>        DWORD len1=1024,len2=1024; <br>        TCHAR RefDomain[1024]; <br>        SID_NAME_USE snu=0;        //don't care <br> <br>        if ((pOwnerSid=(PSID)LocalAlloc(LMEM_FIXED, len1))==NULL) <br>            return FALSE; <br> <br> <br>        Ret= <br>        LookupAccountName <br>        ( <br>            NULL, <br>            Owner, <br>            pOwnerSid, <br>            &amp;len1, <br>            RefDomain, <br>            &amp;len2, <br>            &amp;snu <br>        ); <br> <br>        if (!Ret) <br>        { <br>            LocalFree(pOwnerSid); <br>            return FALSE; <br>        } <br> <br>    } <br> <br>    { <br> <br>        // <br>        // Create the access control list with access for <br>        // the SID obtained above. <br>        // <br> <br>        DWORD aclsize=sizeof(ACL)+ <br>                      sizeof(ACCESS_ALLOWED_ACE)+ <br>                      GetLengthSid(pOwnerSid)- <br>                      sizeof(DWORD); <br> <br>        if ((pAcl=(PACL)LocalAlloc(LMEM_FIXED,aclsize))==NULL) <br>        { <br>            LocalFree(pOwnerSid); <br>            return FALSE; <br>        } <br> <br>        // <br>        // Initialize the acl buffer <br>        // <br> <br>        Ret= <br>        InitializeAcl <br>        ( <br>            pAcl, <br>            aclsize, <br>            ACL_REVISION <br>        ); <br> <br>        if (!Ret) <br>        { <br>            LocalFree(pOwnerSid); <br>            LocalFree(pAcl); <br>            return FALSE; <br>        } <br> <br>        // <br>        // Add the sid to the access allowed part in ACL <br>        // <br> <br>        Ret= <br>        AddAccessAllowedAce <br>        ( <br>            pAcl, <br>            ACL_REVISION, <br>            GENERIC_ALL, <br>            pOwnerSid <br>        ); <br> <br>        if (!Ret) <br>        { <br>            LocalFree(pOwnerSid); <br>            LocalFree(pAcl); <br>            return FALSE; <br>        } <br>    } <br> <br>    // <br>    // Add the created ACL to the discreationary control list <br>    // <br> <br>    Ret= <br>    SetSecurityDescriptorDacl <br>    ( <br>        pSecurityDescriptor, <br>        TRUE, <br>        pAcl, <br>        FALSE <br>    ); <br> <br>    if (!Ret) <br>    { <br>        LocalFree(pOwnerSid); <br>        LocalFree(pAcl); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/*************************************************************/ <br>/* Manages the Session with a Client - Creates a thread for  */ <br>/* Inputs from the client and a thread for sending outputs to*/ <br>/* the client. Could have just as easily done with 1 thread  */ <br>/* using Asyn IO.                                            */ <br>/*************************************************************/ <br>DWORD WINAPI RemoteSession(SESSION_TYPE         *MyClient) { <br>    SESSION_STARTUPINFO  ssi; <br>    DWORD                tmp; <br>    SESSION_STARTREPLY   ssr; <br>    SYSTEMTIME           st; <br> <br>    GetLocalTime(&amp;st); <br>    memset((TCHAR *)&amp;ssi,0,sizeof(ssi)); <br> <br>    // <br>    // Open a new handle to the save file ... <br>    // contains the saved output from the child process <br>    // and the commands already given to it. <br>    // <br> <br>    if ((MyClient-&gt;rSaveFile=CreateFile <br>        ( <br>            SaveFileName, <br>            GENERIC_READ|GENERIC_WRITE, <br>            FILE_SHARE_READ|FILE_SHARE_WRITE, <br>            NULL,OPEN_EXISTING, <br>            FILE_ATTRIBUTE_NORMAL,NULL) <br>        )==NULL) <br> <br>    { <br>        CloseClient(MyClient); <br>        return(1); <br>    } <br> <br>    // <br>    // Exchange Remote Information with Client. <br>    // <br>appcread(MyClient-&gt;tpconv, (void *) &amp;ssi, sizeof(ssi)); <br>wcscpy(MyClient-&gt;Name, ssi.ClientName); <br>MyClient-&gt;Name[15] = 0; <br> <br>ssr.FileSize = GetFileSize(MyClient-&gt;rSaveFile, &amp;tmp); <br>ssr.MagicNumber = MAGICNUMBER; <br> <br>appcwrite(MyClient-&gt;tpconv, (void *) &amp;ssr, sizeof(ssr)); <br> <br>    /* Lines  */ <br>    if (ssi.LinesToSend!=-1) <br>    { <br>        long  PosFromEnd=ssi.LinesToSend*CHARS_PER_LINE; <br>        DWORD BytesToSend=MINIMUM((DWORD)PosFromEnd,ssr.FileSize); <br>        DWORD BytesRead, usize; <br>        char *abuff=(char *)LocalAlloc(LMEM_FIXED,(BytesToSend+1)*sizeof(char)); <br>        TCHAR *ubuff=(TCHAR *)LocalAlloc(0, (BytesToSend+1)*sizeof(TCHAR)); <br> <br>        if (ssr.FileSize &gt; (DWORD)PosFromEnd) <br>        { <br>            SetFilePointer( <br>                            MyClient-&gt;rSaveFile, <br>                            -PosFromEnd, <br>                            (PLONG)NULL, <br>                            FILE_END <br>                          ); <br>        } <br> <br>        if (abuff!=NULL &amp;&amp; ubuff!=NULL) <br>        { <br>            if (!ReadFile(MyClient-&gt;rSaveFile,abuff,BytesToSend,&amp;BytesRead,NULL)) <br>            { <br>                CloseClient(MyClient); <br>                return(1); <br>            } <br> <br>            // Don't want the markers to be part of the output display <br>            // at the client end. <br>            RemoveInpMark(abuff, BytesRead); <br> <br>// convert to wbs <br>usize = mbstowcs(ubuff, abuff, BytesRead); <br> <br>appcwrite(MyClient-&gt;tpconv, (void *) ubuff, usize * sizeof(TCHAR)); <br>        } <br>        LocalFree(abuff); <br>LocalFree(ubuff); <br> <br>    } <br> <br>    RemoteInfo(WRITEF((VBuff, TEXT("\nServer: Connected To %ws [%02d:%02d]\n"),MyClient-&gt;Name,st.wHour,st.wMinute)),ssi.Flag); <br> <br>    // <br>    // Start off the new session. <br>    // <br>    NewSession(MyClient); <br> <br>    RemoteInfo(WRITEF((VBuff, TEXT("\nServer: Disconnected From %ws [%02d:%02d]\n"),MyClient-&gt;Name,st.wHour,st.wMinute)),ssi.Flag); <br> <br>LocalFree(MyClient-&gt;tpconv); <br> <br>    return(0); <br>} <br> <br>// <br>// LocalSession: creates a session for use by the local terminal <br>// <br>// argument is ignored <br>// <br>DWORD WINAPI LocalSession(SESSION_TYPE *cli) { <br>BOOLdone = FALSE; <br>HANDLErthread, wthread; <br>DWORDtid; <br>    SYSTEMTIME  st; <br> <br>    GetLocalTime(&amp;st); <br> <br>cli-&gt;Active = TRUE; <br>cli-&gt;tpconv = NULL; <br>cli-&gt;SendOutput = TRUE; <br>lstrcpy(cli-&gt;Name, TEXT("Local")); <br> <br>    if ((cli-&gt;rSaveFile=CreateFile(SaveFileName, <br>            GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, <br>            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))==NULL) { <br>cli-&gt;Active = FALSE; <br>        return 0; <br>    } <br> <br>    cli-&gt;MoreData = CreateEvent( <br>        (LPSECURITY_ATTRIBUTES) NULL, /* address of security attributes*/ <br>        FALSE,                      /* flag for manual-reset event*/ <br>        TRUE,                      /* flag for initial state*/ <br>        NULL                      /* address of event-object name*/ <br>    ); <br> <br>cli-&gt;DoClose = CreateEvent( <br>(LPSECURITY_ATTRIBUTES) NULL,// no security on event <br>FALSE,// auto reset event mode <br>FALSE,// initially false <br>NULL);// unnamed object <br> <br>    WRITEF((VBuff, TEXT("\nServer: Connected To %ws [%02d:%02d]\n"),cli-&gt;Name,st.wHour,st.wMinute)); <br> <br>if ((wthread = CreateThread(NULL,// no security attributes <br>0,// use same stack size <br>(LPTHREAD_START_ROUTINE) StdinThread,// function to run <br>cli,// pass client info <br>0,// run now <br>&amp;tid)) == NULL) {// return thread id <br>ExitThread(0); <br>} <br> <br>if ((rthread = CreateThread(NULL,// no security attributes <br>0,// use same stack size <br>(LPTHREAD_START_ROUTINE) StdoutThread,// function to run <br>cli,// pass client info <br>0,// run now <br>&amp;tid)) == NULL) {// return thread id <br>ExitThread(0); <br>} <br> <br>WaitForSingleObject(cli-&gt;DoClose, INFINITE); <br> <br>TerminateThread(rthread, 0); <br>TerminateThread(wthread, 0); <br> <br>cli-&gt;Active = FALSE; <br>CloseHandle(cli-&gt;DoClose); <br>CloseHandle(cli-&gt;MoreData); <br>CloseHandle(cli-&gt;rSaveFile); <br>CloseHandle(stdin); <br>CloseHandle(stdout); <br> <br>    WRITEF((VBuff, TEXT("\nServer: Disconnected From %ws [%02d:%02d]\n"),cli-&gt;Name,st.wHour,st.wMinute)); <br> <br>return 0; <br>} <br> <br>DWORD WINAPI StdinThread(SESSION_TYPE *cli) { <br>HANDLEStdin; <br>TCHARubuf[BUFFSIZE]; <br>charabuf[BUFFSIZE]; <br>DWORDtmp, dread, asize; <br> <br>Stdin = GetStdHandle(STD_INPUT_HANDLE); <br>// read a command from the user into a buffer (it will be in Unicode) <br>while (ReadConsole(Stdin, ubuf, BUFFSIZE - 1, &amp;dread, NULL)) { <br>cli-&gt;CommandRcvd = TRUE; <br>ubuf[dread] = 0; <br>// see if it is a valid command <br>if (!FilterCommand(cli, ubuf, dread)) { <br>// convert the buffer from Unicode to ANSI <br>asize = wcstombs(abuf, ubuf, BUFFSIZE); <br> <br>// write the buffer to the child's pipe <br>if (!WriteFile(ChildStdInp, abuf, asize, &amp;tmp, NULL)) <br>ExitThread(0); <br>} <br>} <br>return 0; <br>} <br> <br>DWORD WINAPI StdoutThread(SESSION_TYPE *cli) { <br>HANDLEStdout; <br>charabuffin[BUFFSIZE]; <br>    TCHAR   buffin[BUFFSIZE], buffout[BUFFSIZE], cmdbuff[BUFFSIZE]; <br>    DWORD  aread, dread=0, dwrite=0, tmp, cmdP = 0, i; <br>    BOOL   incmd=FALSE; <br>    TCHAR   MyEchoStr[30]; <br> <br>    wsprintf(MyEchoStr,TEXT("[%-15s"),cli-&gt;Name); <br> <br>    Stdout = GetStdHandle(STD_OUTPUT_HANDLE); <br> <br>// read a buffer from an ansi file (the buffer will be ANSI) <br>    while (ReadFile(cli-&gt;rSaveFile, abuffin, BUFFSIZE-1, &amp;aread, NULL)) { <br>        if (aread == 0) { <br>// wait for more data to arrive and loop again <br>WaitForSingleObject(cli-&gt;MoreData, INFINITE); <br>continue; <br>} <br> <br>abuffin[aread] = 0; <br>dread = mbstowcs(buffin, abuffin, BUFFSIZE); <br> <br>        dwrite=0; <br> <br>        // <br>        // This is all to insure that the commands entered <br>        // by clients are not echoed back to them. <br>        // A Beginmark and an Endmark is placed around commands <br>        // sent to the child process from some client. <br>        // <br> <br>        for (i = 0; i &lt; dread; i++) { <br>            if (incmd) { <br>                if ((buffin[i] == ENDMARK) || (cmdP == BUFFSIZE - 1)) { <br>                    incmd = FALSE; <br>                    cmdbuff[cmdP] = 0; <br>                    if ((wcsstr(cmdbuff, MyEchoStr) == NULL) || <br>                        (!cli-&gt;CommandRcvd)) { <br>WriteConsole(Stdout, cmdbuff, dread, &amp;tmp, NULL); <br>                    } <br>                    cmdP=0; <br>                } else { <br>                    cmdbuff[cmdP++] = buffin[i]; <br>                } <br>            } else { <br>                if (buffin[i] == BEGINMARK) { <br>                    if (dwrite != 0) { <br>WriteConsole(Stdout, buffout, dread, &amp;tmp, NULL); <br>                        dwrite = 0; <br>                    } <br>                    incmd = TRUE; <br>                    continue; <br>                } else { <br>                    buffout[dwrite++] = buffin[i]; <br>                } <br>            } <br>        } <br> <br>        if (dwrite != 0) { <br>WriteConsole(Stdout, buffout, dread, &amp;tmp, NULL); <br>        } <br>    } <br> <br>return 0; <br>} <br> <br>DWORD NewSession(SESSION_TYPE* MyClient) { <br>    DWORD ThreadId; <br>    HANDLE  rThread, wThread; <br> <br>    MyClient-&gt;MoreData = CreateEvent( <br>        (LPSECURITY_ATTRIBUTES) NULL, /* address of security attributes*/ <br>        FALSE,                      /* flag for manual-reset event*/ <br>        TRUE,                      /* flag for initial state*/ <br>        NULL                      /* address of event-object name*/ <br>    ); <br> <br>MyClient-&gt;DoClose = CreateEvent( <br>(LPSECURITY_ATTRIBUTES) NULL,// no security on event <br>FALSE,// flag for manual-reset event <br>FALSE,// initially false <br>NULL);// unnamed object <br> <br>    if ((rThread = CreateThread( <br>            (LPSECURITY_ATTRIBUTES) NULL,         // No security attributes. <br>            (DWORD) 0,                            // Use same stack size. </code></pre>
<p>
</p>
<pre><code>(LPTHREAD_START_ROUTINE) GetClientInput, <br>            (LPVOID) MyClient,                    // Parameter to pass. <br>            (DWORD) 0,                            // Run immediately. <br>            (LPDWORD) &amp;ThreadId))==NULL) { <br>        return(GetLastError()); <br>    } <br> <br> <br>    if ((wThread=CreateThread( <br>            (LPSECURITY_ATTRIBUTES) NULL,        // No security attributes. <br>            (DWORD) 0,                           // Use same stack size. <br>            (LPTHREAD_START_ROUTINE) TransferFileToClient, <br>            (LPVOID) MyClient,                   // Parameter to pass. <br>            (DWORD) 0,                           // Run immediately. <br>            (LPDWORD) &amp;ThreadId))==NULL) { <br>        CloseHandle(rThread); <br>        return(GetLastError()); <br>    } <br> <br>// Wait for the input thread to terminate.  when it does the session is <br>// over. <br>    ThreadId = WaitForSingleObject(wThread, INFINITE); <br> <br>CloseClient(MyClient); <br> <br>ThreadId = WaitForSingleObject(rThread, INFINITE); <br> <br>// close the thread handles <br>    CloseHandle(rThread); <br>    CloseHandle(wThread); <br> <br>    return 0; <br>} <br> <br>/*************************************************************/ <br>/* Saves the output from the child process into the savefile */ <br>/* All the remote client thread and local client thread      */ <br>/* open a seperate handle to this and output its content     */ <br>/* sequentially.                                             */ <br>/*************************************************************/ <br>DWORD WINAPI GetChldOutput(HANDLE readH) { <br>    TCHAR  buff[BUFFSIZE]; <br>    DWORD dread; <br>    DWORD tmp; <br>inti; <br> <br> <br>    while (ReadFile(readH,buff,BUFFSIZE-1,&amp;dread,NULL)) { <br>        buff[dread]=TEXT('\0'); <br> <br>        if (!WriteFile(SaveFile,buff,dread,&amp;tmp,NULL)) <br>            return(1); <br> <br>        // <br>        // Signal Reader Thread that more data is available <br>        // <br>        for (i=0;i&lt;MAX_SESSION;i++) <br>if (ClientList[i].Active) SetEvent(ClientList[i].MoreData); <br>    } <br>    return 1; <br>} <br> <br>/*************************************************************/ <br>/* A thread for each client connection and one for local IO  */ <br>/* Reads the contents of Save file and sends it to client for*/ <br>/* display.                                                  */ <br>/*************************************************************/ <br>DWORD WINAPI TransferFileToClient(SESSION_TYPE *MyClient) { <br>    TCHAR   buffin[BUFFSIZE], buffout[BUFFSIZE], cmdbuff[BUFFSIZE]; <br>charabuffin[BUFFSIZE]; <br>    DWORD  dread=0,dwrite=0,aread; <br>    BOOL   incmd=FALSE; <br>    DWORD  cmdP=0; <br>    DWORD  i; <br>    TCHAR   MyEchoStr[30]; <br>HANDLEobjs[2]; <br>DWORD which; <br> <br>    wsprintf(MyEchoStr,TEXT("[%-15s"),MyClient-&gt;Name); <br> <br>    while (ReadFile(MyClient-&gt;rSaveFile, abuffin, BUFFSIZE-1, &amp;aread, NULL)) { <br>        if (aread == 0) { <br>            // <br>            // Event is set by GetChldOutput() func. to signal <br>            // More data is available in save file. <br>            // <br>objs[0] = MyClient-&gt;MoreData; <br>objs[1] = MyClient-&gt;DoClose; <br> <br>// wait for moredata or a close request <br>which = WaitForMultipleObjects(2, objs, FALSE, INFINITE); <br>which = which - WAIT_OBJECT_0; <br> <br>            if (which == 0) { <br>// there is more data waiting <br>continue; <br>} else { <br>// they want us to close <br>return 0; <br>} <br>        } <br> <br>dread = mbstowcs(buffin, abuffin, aread); <br> <br>        dwrite=0; <br> <br>        // <br>        // This is all to insure that the commands entered <br>        // by clients are not echoed back to them. <br>        // A Beginmark and an Endmark is placed around commands <br>        // sent to the child process from some client. <br>        // <br> <br>        for (i = 0; i &lt; dread; i++) { <br>            if (incmd) { <br>                if ((buffin[i] == ENDMARK) || (cmdP == BUFFSIZE - 1)) { <br>                    incmd = FALSE; <br>                    cmdbuff[cmdP] = 0; <br>                    if ((wcsstr(cmdbuff, MyEchoStr) == NULL) || <br>                        (!MyClient-&gt;CommandRcvd)) { <br>appcwrite(MyClient-&gt;tpconv, (void *) cmdbuff, <br>cmdP * sizeof(TCHAR)); <br>                    } <br>                    cmdP=0; <br>                } else { <br>                    cmdbuff[cmdP++] = buffin[i]; <br>                } <br>            } else { <br>                if (buffin[i] == BEGINMARK) { <br>                    if (dwrite != 0) { <br>appcwrite(MyClient-&gt;tpconv, (void *) buffout, <br>dwrite * sizeof(TCHAR)); <br>                        dwrite = 0; <br>                    } <br>                    incmd = TRUE; <br>                    continue; <br>                } else { <br>                    buffout[dwrite++] = buffin[i]; <br>                } <br>            } <br>        } <br> <br>        if (dwrite != 0) { <br>appcwrite(MyClient-&gt;tpconv, (void *) buffout, <br>dwrite * sizeof(TCHAR)); <br>        } <br>    } <br>    return 0; <br>} <br> <br>/*************************************************************/ <br>/* Commands from the clients are sent to the child process   */ <br>/* and also saved in the SaveFile with Begin and End markers */ <br>/* around them to seperate them from the output from child   */ <br>/* process.                                                  */ <br>/*************************************************************/ <br>DWORD WINAPI GetClientInput(SESSION_TYPE *MyClient) { <br>    TCHAR ubuff[BUFFSIZE]; <br>char  abuff[BUFFSIZE]; <br>    DWORD tmp,uread,aread; <br> <br>while (TRUE) { <br>    uread = appcread(MyClient-&gt;tpconv, (void *) ubuff, BUFFSIZE) / <br>sizeof(TCHAR); <br>if (!appcvalid(MyClient-&gt;tpconv)) break; <br> <br>        MyClient-&gt;CommandRcvd = TRUE; <br> <br>        if (FilterCommand(MyClient, ubuff, uread)) continue; <br> <br>aread = wcstombs(abuff, ubuff, uread); <br> <br>        if (!WriteFile(ChildStdInp, abuff, aread, &amp;tmp, NULL)) ExitThread(0); <br>    } <br> <br>    return(1); <br>} <br> <br>/*************************************************************/ <br>/* If a client command is intended for the Remote server -   */ <br>/* those beginning with COMMANDCHAR (are not intended        */ <br>/* for the child process) - they are executed here           */ <br>/* and the output sent to the client.                        */ <br>/*************************************************************/ <br>BOOL FilterCommand(SESSION_TYPE *cl, TCHAR *buff, int dread) { <br>    SYSTEMTIME st; <br>    TCHAR       inp_buff[4096]; <br>    TCHAR       tmpchar; <br>    TCHAR       ch[3]; <br>    DWORD      tmp; <br>    int        len; <br>    DWORD      ThreadID; //Useless <br> <br>    if (dread==0) <br>        return(FALSE); <br> <br>    buff[dread]=0; <br> <br>    GetLocalTime(&amp;st); <br> <br>    if (buff[0]==COMMANDCHAR) { <br>        switch(tolower(buff[1])) { <br>            case TEXT('o'): <br>                cl-&gt;SendOutput=!cl-&gt;SendOutput; <br>                break; <br> <br>            case TEXT('k'): <br>                TerminateProcess(ChldProc,1); <br>                break; <br> <br>case TEXT('q'): <br>SetEvent(cl-&gt;DoClose); <br>break; <br> <br>            case TEXT('s'): <br>                SendStatus(cl-&gt;tpconv); <br>                break; <br> <br>            case TEXT('p'): <br>if (cl-&gt;tpconv == NULL) break; <br>{ <br> //Free it in called Proc <br>TCHAR *mssg=(TCHAR *)LocalAlloc(0, 4096*sizeof(TCHAR)); <br>                TCHAR  *ack=TEXT("Server: Popup Shown..\n"); <br> <br>                    if (mssg==NULL) <br>                        break; <br> <br>                    wsprintf(mssg,TEXT("From %ws [%d:%d]\n\n%ws\n"),cl-&gt;Name,st.wHour,st.wMinute,&amp;buff[2]); <br>                    CreateThread( <br>                          (LPSECURITY_ATTRIBUTES)NULL,         // No security attributes. <br>                          (DWORD)0,              // Use same stack size. <br>                          (LPTHREAD_START_ROUTINE)ShowPopup, // Thread procedure. <br>                          (LPVOID)mssg,          // Parameter to pass. <br>                          (DWORD)0,              // Run immediately. <br>                          (LPDWORD)&amp;ThreadID <br>                         ); <br>appcwrite(cl-&gt;tpconv, (void *) ack, lstrlen(ack) * <br>sizeof(TCHAR)); <br>                    break; <br>                 } <br> <br>            case TEXT('m'): <br>                buff[dread-2]=0; <br>                CMDSTRING(inp_buff,buff,cl,st); <br>                len=lstrlen(inp_buff); <br>                WriteFile(SaveFile,inp_buff,len,&amp;tmp,NULL); <br>                break; <br> <br>            case TEXT('@'): <br>                buff[dread-2]=0; <br>                CMDSTRING(inp_buff,&amp;buff[1],cl,st); <br>                len=lstrlen(inp_buff); <br>                WriteFile(SaveFile,inp_buff,len,&amp;tmp,NULL); <br>                // <br>                // Remove the first @ sign <br>                // <br>                MoveMemory(buff,&amp;buff[1],dread-1); <br>                buff[dread-1]=TEXT(' '); <br>                return(FALSE); //Send it it to the chile process <br>                break; <br> <br> <br>            default : <br>if (cl-&gt;tpconv == NULL) break; <br>                lstrcpy(inp_buff, TEXT("** Unknown Command **\n")); <br>appcwrite(cl-&gt;tpconv, (void *) inp_buff, <br>lstrlen(inp_buff) * sizeof(TCHAR)); <br> <br>            case TEXT('h'): <br>if (cl-&gt;tpconv != NULL) { <br>                wsprintf(inp_buff,TEXT("%cM: To Send Message\n"),COMMANDCHAR); <br>appcwrite(cl-&gt;tpconv, (void *) inp_buff, lstrlen(inp_buff) * sizeof(TCHAR)); <br>               wsprintf(inp_buff,TEXT("%cP: To Generate popup\n"),COMMANDCHAR); <br>appcwrite(cl-&gt;tpconv, (void *) inp_buff, lstrlen(inp_buff) * sizeof(TCHAR)); <br>               wsprintf(inp_buff,TEXT("%cK: To kill the server\n"),COMMANDCHAR); <br>appcwrite(cl-&gt;tpconv, (void *) inp_buff, lstrlen(inp_buff) * sizeof(TCHAR)); <br>               wsprintf(inp_buff,TEXT("%cH: This Help\n"),COMMANDCHAR); <br>appcwrite(cl-&gt;tpconv, (void *) inp_buff, lstrlen(inp_buff) * sizeof(TCHAR)); <br>} <br>                break; <br>        } <br>        return(TRUE); <br>    } <br> <br> <br>    if ((buff[0]&lt;26)) { <br>        BOOL ret=FALSE; <br> <br>        wsprintf(ch,TEXT("^%c"),buff[0]+64); <br>//        CMDSTRING(inp_buff,ch,cl,st); <br>        len=lstrlen(inp_buff); <br> <br>        if (buff[0]==CTRLC) <br>        { <br>            cl-&gt;CommandRcvd=FALSE; <br>            GenerateConsoleCtrlEvent(CTRL_C_EVENT,0); <br>            ret=TRUE; //Already sent to child <br>        } <br> <br>        WriteFile(SaveFile,inp_buff,len,&amp;tmp,NULL); <br>        return(ret); //FALSE:send it to child StdIn <br>    } <br> <br>    tmpchar=buff[dread-2]; //must be 13;but just incase <br>    buff[dread-2]=0; <br>//    CMDSTRING(inp_buff,buff,cl,st); <br>    buff[dread-2]=tmpchar; <br>    len=lstrlen(inp_buff); <br>    WriteFile(SaveFile,inp_buff,len,&amp;tmp,NULL); <br>    return(FALSE); <br>} <br> <br>/*************************************************************/ <br>VOID SendStatus(tpconvid_t tpconv) { <br>    TCHAR  buff[1024]; <br>    int   i; <br>    TCHAR  *env=(TCHAR *)GetEnvironmentStrings(); <br>    DWORD ver=GetVersion(); <br> <br>if (tpconv == NULL) return; <br> <br>    wsprintf(buff,TEXT("Command = %ws\n"), ChildCmd); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br> <br>    wsprintf(buff,TEXT("Build = %d \n"),((WORD *)&amp;ver)[1]); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br> <br>    for (i=1;i&lt;MAX_SESSION;i++) <br>    { <br>        if (ClientList[i].Active) <br>        { <br>            wsprintf(buff,TEXT("ACTIVE SESSION=%ws\n"),ClientList[i].Name); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br>        } <br>    } <br> <br>    wsprintf(buff,TEXT("====================\n")); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br> <br>    wsprintf(buff,TEXT("ENVIRONMENT VARIABLES\n")); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br> <br>    wsprintf(buff,TEXT("====================\n")); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br> <br> <br>    __try { <br>        while (*env!=0) <br>        { <br>            wsprintf(buff,TEXT("%ws\n"),env); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br> <br>            while(*(env++)!=0); <br>        } <br>    } __except(EXCEPTION_EXECUTE_HANDLER) { <br>        wsprintf(buff,TEXT("Exception Generated Getting Environment Block\n"),env); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br>    } <br> <br>    wsprintf(buff,TEXT("====================\n")); <br>appcwrite(tpconv, (void *) buff, lstrlen(buff) * sizeof(TCHAR)); <br>    return; <br>} <br> <br>/*************************************************************/ <br>DWORD WINAPI <br>ShowPopup( <br>    TCHAR *mssg <br>    ) <br>{ <br>    MessageBox(GetActiveWindow(),mssg,TEXT("***REMOTE***"),MB_OK|MB_SETFOREGROUND); <br>    LocalFree(mssg); <br>    return(0); <br>} <br>/*************************************************************/ <br>BOOL SrvCtrlHand( <br>    DWORD event <br>    ) <br>{ <br>    if (event==CTRL_BREAK_EVENT) <br>    { <br>        TerminateProcess(ChldProc,1); <br>    } <br>    return(TRUE); <br>} <br>/*************************************************************/ <br> <br>VOID CloseClient(SESSION_TYPE *Client) { <br>EnterCriticalSection(&amp;close_crit); <br> <br>appcclose(Client-&gt;tpconv); <br> <br>    if (Client-&gt;rSaveFile != INVALID_HANDLE_VALUE) { <br>        CloseHandle(Client-&gt;rSaveFile); <br>        Client-&gt;rSaveFile = INVALID_HANDLE_VALUE; <br>    } <br> <br>    if (Client-&gt;MoreData != NULL) { <br>        CloseHandle(Client-&gt;MoreData); <br>        Client-&gt;MoreData = NULL; <br>    } <br> <br>Client-&gt;Active=FALSE; //Keep it last else synch problem. <br> <br>LeaveCriticalSection(&amp;close_crit); <br> <br>    return; <br>} <br> <br>VOID InitClientList(VOID) { <br>    int i; <br>    for (i=0;i&lt;MAX_SESSION;i++) <br>    { <br>        ZeroMemory(ClientList[i].Name,HOSTNAMELEN); <br>ClientList[i].tpconv = NULL; <br>        ClientList[i].rSaveFile = INVALID_HANDLE_VALUE; <br>        ClientList[i].MoreData = NULL; <br>        ClientList[i].Active = FALSE; <br>        ClientList[i].CommandRcvd = FALSE; <br>        ClientList[i].SendOutput = FALSE; <br>        ClientList[i].hThread = NULL; <br>    } <br>    return; <br>} <br> <br> <br> <br>VOID RemoveInpMark(char* Buff, DWORD Size) { <br>    DWORD i; <br>    for (i=0;i&lt;Size;i++) <br>    { <br>        switch (Buff[i]) <br>        { <br>        case BEGINMARK: <br>            Buff[i]=' '; <br>            break; <br> <br>        case ENDMARK: <br>            if (i&lt;2) <br>            { <br>                Buff[i]= ' '; <br>            } <br>            else <br>            { <br>                Buff[i]  =Buff[i-1]; <br>                Buff[i-1]=Buff[i-2]; <br>                Buff[i-2]=' '; <br>            } <br>            break; <br> <br>        default: <br>           break; <br>       } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
