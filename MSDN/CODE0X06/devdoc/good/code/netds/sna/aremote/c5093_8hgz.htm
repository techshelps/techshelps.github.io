<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APPCLIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5093"></a>APPCLIB.C</h2>
<pre><code>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;winappc.h&gt; <br>#include &lt;wincsv.h&gt; <br>#include "appclib.h" <br>#include "queue.h" <br> <br>#define memalloc(size) LocalAlloc(LMEM_FIXED, size) <br>#define memfree(pointer) LocalFree(pointer) <br> <br>// --- internal functions used by the module --- <br>void appcerror(vcb_t vcb); <br>BOOL callappc(vcb_t *vcb); <br>void conv_a_to_e(char *string, int length); <br>void memcpypad(char *dest, TCHAR *source, int length); <br>void memcpya2e(char *dest, TCHAR *source, int length); <br>int do_receive_and_wait(char *tp_id, unsigned long int conv_id, <br>    void *data, int maxlen, BOOL *dealloc);  <br>void do_send_data(char *tp_id, unsigned long int conv_id, void *data, int len); <br>void do_confirm(char *tp_id, unsigned long int conv_id); <br>void do_prepare_to_receive(char *tp_id, unsigned long int conv_id); <br>void do_get_fqplu_name(char *tp_id, unsigned long int conv_id,  <br>   char *fqplu_name); <br>void do_tp_started(TCHAR *lu_alias, TCHAR *tp_name, char *tp_id); <br>unsigned long int do_mc_allocate(TCHAR *lu_alias, TCHAR *tp_name,  <br>     TCHAR *mode_name, char *tp_id); <br>void do_deallocate(char *tp_id, unsigned long int conv_id); <br>void do_tp_ended(char *tp_id); <br> <br>queue       *pairq;                     // queue of sessions that have <br>                                        // both read and write established <br>HANDLE      hPairqSem;                  // semaphore of number of objects <br>                                        // in pairq; <br>HANDLE      hListenThread = NULL;       // handle to listenthread() <br>HANDLEhShutdownEvent = NULL;// event to signal that the application <br>// is shutting down <br>intoutstanding;// number of outstanding APPC reqs <br>HANDLEhOutstandingZero = NULL;// event set when outstanding goes to <br>// zero <br>CRITICAL_SECTION    csPairq;            // critical section for pairq <br> <br>/* <br> * convert string from ascii to ebcdic (overwriting the original string). <br> */ <br>void conv_a_to_e(char *string, int length) { <br>    struct convert cnvt; <br> <br>    memset(&amp;cnvt, 0, sizeof(cnvt)); <br>    cnvt.opcode = SV_CONVERT; <br>    cnvt.direction = SV_ASCII_TO_EBCDIC; <br>    cnvt.char_set = SV_AE; <br>    cnvt.len = length; <br>    cnvt.source = string; <br>    cnvt.target = string; <br> <br>    ACSSVC_C((long) &amp;cnvt); <br>} <br> <br>/* <br> * copy a string from &lt;source&gt; to &lt;dest&gt;, padding the end of it with spaces so <br> * it takes &lt;length&gt; bytes. <br> * <br> * input is assumed to be Unicode if UNICODE is defined, output is always Ansi <br> */ <br>void memcpypad(char *dest, TCHAR *source, int length) { <br>#ifdef UNICODE <br>    char ansisrc[1024]; <br> <br>    // convert the source string from Unicode to ANSI <br>    wcstombs(ansisrc, source, 1024); <br> <br>    // copy the ANSI string into the destination <br>    memset(dest, ' ', length); <br>    memcpy(dest, ansisrc, strlen(ansisrc)); <br>#else <br>    memset(dest, ' ', length); <br>    memcpy(dest, source, strlen(source)); <br>#endif <br>} <br> <br>/* <br> * copy a string from &lt;source&gt; to &lt;dest&gt;, padding the end of it with spaces  <br> * so it takes &lt;length&gt; bytes.  convert the &lt;dest&gt; string from ascii to ebcdic <br> * <br> * input is assumed to be Unicode if UNICODE is defined, output is always Ansi <br> */ <br>void memcpya2e(char *dest, TCHAR *source, int length) { <br>#ifdef UNICODE <br>    char ansisrc[1024]; <br> <br>    // convert the source string from Unicode to ANSI <br>    wcstombs(ansisrc, source, 1024); <br> <br>    // copy the ANSI string into the destination <br>    memset(dest, ' ', length); <br>    memcpy(dest, ansisrc, strlen(ansisrc)); <br> <br>    // convert ansi to ebcdic <br>    conv_a_to_e(dest, length); <br>#else <br>    memset(dest, ' ', length); <br>    memcpy(dest, source, strlen(source)); <br>    conv_a_to_e(dest, length); <br>#endif <br>} <br> <br>/* <br> * a standard error handler for APPC errors.  prints out the last verb and the <br> * two return codes <br> */ <br>void appcerror(vcb_t vcb) { <br>    char errorbuf[1024]; <br> <br>    printf("\nAPPC Error: Verb = 0x%0x   PriRC = 0x%0x   SecRC = 0x%0x\n", <br>        APPC_FLIPI(vcb.hdr.opcode), APPC_FLIPI(vcb.hdr.primary_rc),  <br>        APPC_FLIPL(vcb.hdr.secondary_rc)); <br> <br>    GetAppcReturnCode((struct appc_hdr *) &amp;(vcb.hdr), 1024, errorbuf); <br> <br>    printf("\n%s\n", errorbuf); <br> <br>appcdestroy(); <br> <br>    ExitProcess(1); <br>} <br> <br>/* <br> * initialize APPC.  all programs should call this before using any  <br> * APPC functions <br> */ <br>int appcinit(void) { <br>    WAPPCDATA APPCData; <br> <br>// create the shutdown event <br>hShutdownEvent = CreateEvent(NULL, FALSE, FALSE, NULL); <br>if (hShutdownEvent == NULL) return -1; <br> <br>// create the event that is triggered when outstanding goes to zero <br>// this only gets set when hShutdownEvent has been set and all requests <br>// are being cancelled <br>hOutstandingZero = CreateEvent(NULL, FALSE, FALSE, NULL); <br>if (hOutstandingZero == NULL) return -1; <br> <br>    return WinAPPCStartup(WINAPPCVERSION, &amp;APPCData); <br>} <br> <br>/* <br> * kill APPC.  this should be called when a program is done using APPC <br> */ <br>BOOL WINAPI appcdestroy(void) { <br>// if there are any outstanding requests <br>if (outstanding &gt; 0) { <br>// tell all threads to cancel their outstanding requests.  when the last <br>// one cancels its request it will set hOutstandingZero. <br>SetEvent(hShutdownEvent); <br>// wait up to 60 seconds for all outstanding requests to be canceled <br>while  <br>((WaitForSingleObject(hOutstandingZero, 20000) == WAIT_OBJECT_0) &amp;&amp; <br> (outstanding &gt; 0)); <br>} <br> <br>// tell WinAPPC that we're done with it <br>    return WinAPPCCleanup(); <br>} <br> <br>// a wrapper around APPC which handles hShutdownEvent for clean shutdowns <br>BOOL callappc(vcb_t *vcb) { <br>HANDLE hAsync, objs[2]; <br>DWORD event; <br> <br>// create an event handle <br>objs[0] = CreateEvent(NULL, FALSE, FALSE, NULL); <br> <br>InterlockedIncrement(&amp;outstanding); <br> <br>// make the APPC call <br>ASYNCAPPC(objs[0], vcb, hAsync); <br>// see if the async APPC call failed <br>if (hAsync == 0) { <br>InterlockedDecrement(&amp;outstanding); <br>SetLastError(APPCLIB_ASYNC_FAILED); <br>return FALSE; <br>} <br> <br>// wait for either the APPC call to complete or the hShutdownEvent to be <br>// triggered <br>objs[1] = hShutdownEvent; <br>event = WaitForMultipleObjects(2, objs, FALSE, INFINITE) - WAIT_OBJECT_0; <br>switch (event) { <br>case 0:// APPC call completed <br>InterlockedDecrement(&amp;outstanding); <br>break; <br>case 1:// shutdown event triggered <br>// cancel the outstanding request <br>WinAPPCCancelAsyncRequest(hAsync); <br>// if this is the last cancel than let appcdestroy() know that <br>if (InterlockedDecrement(&amp;outstanding) &lt;= 0) { <br>SetEvent(hOutstandingZero); <br>} <br>break; <br>case WAIT_FAILED: <br>SetLastError(APPCLIB_NO_INIT); <br>return FALSE; <br>} <br>CloseHandle(objs[0]); <br>CloseHandle(hAsync); <br> <br>return TRUE; <br>} <br> <br>/* <br> * execute a MC_RECEIVE_AND_WAIT verb with the given TP ID and Conversation ID <br> * data is copied into the buffer at &lt;data&gt; for a maximum of &lt;maxlen&gt; bytes.   <br> * Returns the number of bytes actually read. <br> * <br> * If the sender requests confirmation a MC_CONFIRM verb is send to them. <br> * if the conversation gets deallocated then dealloc is set to true. <br> */ <br>int do_receive_and_wait(char *tp_id, unsigned long int conv_id,  <br>                        void *data, int maxlen, BOOL *dealloc) { <br>    vcb_t vcb; <br>    int read; <br> <br>    CLEARVCB(vcb); <br> <br>    *dealloc = FALSE; <br> <br>    vcb.rcvwait.opcode = AP_M_RECEIVE_AND_WAIT; <br>    vcb.rcvwait.opext = AP_MAPPED_CONVERSATION; <br>    memcpy(&amp;(vcb.rcvwait.tp_id), tp_id, 8); <br>    vcb.rcvwait.conv_id = conv_id; <br>    vcb.rcvwait.rtn_status = AP_YES; <br>    vcb.rcvwait.max_len = maxlen; <br>    vcb.rcvwait.dptr = data; <br> <br>    callappc(&amp;vcb);                                          <br>    APPCDBG(printf("vcb.rcvwait.what_rcvd = 0x%x\n", APPC_FLIPI(vcb.rcvwait.what_rcvd))); <br>    APPCDBG(printf("vcb.rcvwait.primary_rc = 0x%x\n", APPC_FLIPI(vcb.rcvwait.primary_rc))); <br>    APPCDBG(printf("vcb.rcvwait.dlen = %i\n", vcb.rcvwait.dlen)); <br>    read = vcb.rcvwait.dlen; <br> <br>    if ((vcb.rcvwait.primary_rc == AP_DEALLOC_NORMAL) ||  <br>        (vcb.rcvwait.primary_rc == AP_DEALLOC_ABEND)) { <br>        do_tp_ended(tp_id); <br>        *dealloc = TRUE; <br>    } else if (vcb.rcvwait.primary_rc != AP_OK) { <br>        appcerror(vcb); <br>    } else if ((vcb.rcvwait.what_rcvd == AP_CONFIRM_DEALLOCATE) || <br>               (vcb.rcvwait.what_rcvd == AP_DATA_COMPLETE_CONFIRM_DEALL)) { <br>        /* confirm deallocation */ <br>        CLEARVCB(vcb); <br>        vcb.confirmed.opcode = AP_M_CONFIRMED; <br>        vcb.confirmed.opext = AP_MAPPED_CONVERSATION; <br>        memcpy(vcb.confirmed.tp_id, tp_id, 8); <br>        vcb.confirmed.conv_id = conv_id; <br>        callappc(&amp;vcb); <br>        if (vcb.confirmed.primary_rc != AP_OK) appcerror(vcb); <br> <br>        do_tp_ended(tp_id); <br>        *dealloc = TRUE; <br>    } else if ((vcb.rcvwait.what_rcvd == AP_CONFIRM_WHAT_RECEIVED) ||  <br>               (vcb.rcvwait.what_rcvd == AP_CONFIRM_SEND) || <br>               (vcb.rcvwait.what_rcvd == AP_DATA_COMPLETE_CONFIRM) ||  <br>               (vcb.rcvwait.what_rcvd == AP_DATA_CONFIRM)) { <br>        /* do a confirmation if one was requested */ <br>        CLEARVCB(vcb); <br>        vcb.confirmed.opcode = AP_M_CONFIRMED; <br>        vcb.confirmed.opext = AP_MAPPED_CONVERSATION; <br>        memcpy(vcb.confirmed.tp_id, tp_id, 8); <br>        vcb.confirmed.conv_id = conv_id; <br>        callappc(&amp;vcb); <br>        if (vcb.confirmed.primary_rc != AP_OK) appcerror(vcb); <br>    } <br>     <br>    return read; <br>} <br> <br>/* <br> * do a MC_SEND_DATA verb with the given TP ID, Conversation ID and &lt;len&gt;  <br> * bytes of data at the &lt;data&gt; pointer.  asks for a confirmation upon <br> * sending. <br> */ <br>void do_send_data(char *tp_id, unsigned long int conv_id, void *data, int len) { <br>    vcb_t vcb; <br> <br>    CLEARVCB(vcb); <br> <br>    vcb.snddata.opcode = AP_M_SEND_DATA; <br>    vcb.snddata.opext = AP_MAPPED_CONVERSATION; <br>    memcpy(vcb.snddata.tp_id, tp_id, 8); <br>    vcb.snddata.conv_id = conv_id; <br>    vcb.snddata.dlen = len; <br>    vcb.snddata.dptr = data; <br>    vcb.snddata.type = AP_SEND_DATA_CONFIRM; <br> <br>    callappc(&amp;vcb); <br> <br>    if (vcb.snddata.primary_rc != AP_OK) appcerror(vcb); <br>} <br> <br>/* <br> * ask for a confirmation on a given TP ID and Conversation ID.  used for <br> * syncronizing data flow. <br> */ <br>void do_confirm(char *tp_id, unsigned long int conv_id) { <br>    vcb_t vcb; <br> <br>    CLEARVCB(vcb); <br>    vcb.confirm.opcode = AP_M_CONFIRM; <br>    vcb.confirm.opext = AP_MAPPED_CONVERSATION; <br>    memcpy(vcb.confirm.tp_id, tp_id, 8); <br>    vcb.confirm.conv_id = conv_id; <br>         <br>    callappc(&amp;vcb); <br> <br>    if (vcb.confirm.primary_rc != AP_OK) appcerror(vcb); <br>} <br> <br>/* <br> * switch the conversation into a receive state and ask the partner TP <br> * to confirm this. <br> */ <br>void do_prepare_to_receive(char *tp_id, unsigned long int conv_id) { <br>    vcb_t vcb; <br> <br>    CLEARVCB(vcb); <br>    vcb.torec.opcode = AP_M_PREPARE_TO_RECEIVE; <br>    vcb.torec.opext = AP_MAPPED_CONVERSATION; <br>    vcb.torec.ptr_type = AP_SYNC_LEVEL; <br>    vcb.torec.locks = AP_SHORT; <br>    memcpy(vcb.torec.tp_id, tp_id, 8); <br>    vcb.torec.conv_id = conv_id; <br>         <br>    callappc(&amp;vcb); <br> <br>    if (vcb.confirm.primary_rc != AP_OK) appcerror(vcb); <br>}    <br> <br>/* <br> * wait on a TP name for a MC_ALLOCATE request.  the TP ID is written into <br> * the buffer at &lt;tp_id&gt;, the conversation ID is returned. <br> */ <br>void do_get_fqplu_name(char *tp_id, unsigned long int conv_id,  <br>                       char *fqplu_name) { <br>    vcb_t vcb; <br> <br>    CLEARVCB(vcb); <br>    vcb.getattrib.opcode = AP_M_GET_ATTRIBUTES; <br>    vcb.getattrib.opext = AP_MAPPED_CONVERSATION; <br>    memcpy(vcb.getattrib.tp_id, tp_id, 8); <br>    vcb.getattrib.conv_id = conv_id; <br>     <br>    callappc(&amp;vcb); <br>    if (vcb.rcvalloc.primary_rc != AP_OK) appcerror(vcb); <br> <br>    memcpy(fqplu_name, vcb.getattrib.fqplu_name, 17); <br>} <br> <br>/* <br> * start a new TP.  this registers the LU alias and TP name for your TP <br> * to use and returns a TP ID <br> */ <br>void do_tp_started(TCHAR *lu_alias, TCHAR *tp_name, char *tp_id) { <br>    vcb_t vcb; <br> <br>    CLEARVCB(vcb); <br>    vcb.tpstart.opcode = AP_TP_STARTED; <br>    memcpypad(vcb.tpstart.lu_alias, lu_alias, 8); <br>    memcpya2e(vcb.tpstart.tp_name, tp_name, 64); <br> <br>    callappc(&amp;vcb); <br>    if (vcb.tpstart.primary_rc != AP_OK) appcerror(vcb); <br> <br>    memcpy(tp_id, vcb.tpstart.tp_id, 8); <br>} <br> <br>/* <br> * allocate a conversation with a partner TP.  This takes the partner TP's <br> * alias, tp name, mode name, and your TP ID and returns a conversation ID. <br> * <br> * it does a MC_CONFIRM directly afterwords to see if the conversation was <br> * really allocated.  if it wasn't it sleeps for 100ms and tries again for <br> * up to 20 retries (about 2 seconds). <br> */ <br>unsigned long int do_mc_allocate(TCHAR *lu_alias, TCHAR *tp_name,  <br>                                 TCHAR *mode_name, char *tp_id) { <br>    vcb_t vcb; <br>    int tries = 0; <br>    unsigned long int conv_id; <br> <br>    do { <br>        CLEARVCB(vcb); <br>        vcb.allocate.opcode = AP_M_ALLOCATE; <br>        vcb.allocate.opext = AP_MAPPED_CONVERSATION; <br>        memcpy(vcb.allocate.tp_id, tp_id, 8); <br>        vcb.allocate.sync_level = AP_CONFIRM_SYNC_LEVEL; <br>        vcb.allocate.rtn_ctl = AP_WHEN_SESSION_ALLOCATED; <br>     <br>        memcpypad(vcb.allocate.plu_alias, lu_alias, 8); <br>        memcpya2e(vcb.allocate.mode_name, mode_name, 8); <br>        memcpya2e(vcb.allocate.tp_name, tp_name, 64); <br>        vcb.allocate.security = AP_NONE; <br> <br>        callappc(&amp;vcb); <br>        conv_id = vcb.allocate.conv_id; <br>        if (vcb.allocate.primary_rc != AP_OK) appcerror(vcb); <br> <br>        if (vcb.allocate.primary_rc == AP_ALLOCATION_ERROR) Sleep(100); <br>    } while ((tries++ &lt; 20) &amp;&amp;  <br>             (vcb.allocate.primary_rc == AP_ALLOCATION_ERROR)); <br>     <br>    if (vcb.allocate.primary_rc != AP_OK) appcerror(vcb); <br>                <br>    return conv_id; <br>} <br> <br>/* <br> * deallocate a conversation.  should only be called with a TP ID and <br> * conversation ID that are in the send state. <br> */ <br>void do_deallocate(char *tp_id, unsigned long int conv_id) { <br>    vcb_t vcb; <br> <br>    CLEARVCB(vcb); <br>    vcb.dealloc.opcode = AP_M_DEALLOCATE; <br>    vcb.dealloc.opext = AP_MAPPED_CONVERSATION; <br>    memcpy(vcb.confirm.tp_id, tp_id, 8); <br>    vcb.confirm.conv_id = conv_id; <br>    vcb.dealloc.dealloc_type = AP_SYNC_LEVEL; <br> <br>    callappc(&amp;vcb); <br> <br>    if (vcb.dealloc.primary_rc != AP_OK) appcerror(vcb); <br>} <br> <br>void do_tp_ended(char *tp_id) { <br>    vcb_t vcb; <br> <br>    CLEARVCB(vcb); <br>    vcb.tpend.opcode = AP_TP_ENDED; <br>    vcb.tpend.type = AP_SOFT; <br>    memcpy(vcb.confirm.tp_id, tp_id, 8); <br> <br>    callappc(&amp;vcb); <br> <br>    if (vcb.dealloc.primary_rc != AP_OK) appcerror(vcb); <br>} <br> <br>DWORD WINAPI listenthread(TCHAR *tpname) { <br>    vcb_t       vcb_r, vcb_w;               // verb control block for each sess <br>    TCHAR       tpname_r[9], tpname_w[9];   // tp name for each session <br>    HANDLE      h_event_r, h_event_w;       // event handles for each session <br>    HANDLE      h_async_r, h_async_w;       // async task handles for each sess <br>    HANDLE      objs[3];                    // array of handles to wait for <br>    DWORD       event;                      // which event returned <br>    tpconvid_t  tpconv;                     // temporary tpconv pointer <br>    name_time_t name_time;                  // logical unit of work &amp; time key <br>    int         dread; <br>    BOOL        dealloc;                    // deallocation flag on session <br>    queue       *readq;                     // queue of sessions that have <br>                                            // read establish, but not write <br>    readnode_t  readnode;                   // node for readq <br>    unsigned long int w_conv_id;            // conversation id for write sess <br>    unsigned char w_tp_id[8];               // tp_id for write session <br>    qnode       *n;                         // temp node for searching queues <br> <br>    // create the event handles for each session <br>    h_event_r = CreateEvent(NULL, FALSE, FALSE, NULL); <br>    h_event_w = CreateEvent(NULL, FALSE, FALSE, NULL); <br>    if ((h_event_r == NULL) || (h_event_w == NULL)) { <br>        printf("appclib: CreateEvent() failed near line %i\n", __LINE__); <br>        return FALSE; <br>    } <br> <br>    // create the q <br>    readq = newq(); <br>    if (readq == NULL) { <br>        printf("appclib: newq() failed near line %i\n", __LINE__); <br>        return FALSE; <br>    } <br> <br>    // we actually use two different TP names, one for each session.   <br>    // the name that the server reads on ends in a R, the name that the <br>    // server writes on ends in a W <br> <br>// <br>// last minute change to ensure we work as an autostarted TP where <br>// the tp name we issue in the rcv_alloc must match the TP name we <br>// registered as with Service Control Manager.  On the Server read <br>// tp we do not alter the name.  The server write TP is still altered. <br>// will most likely not work if the TP name is 8 chars long and ends <br>// in a W. <br>// <br>    memcpy(tpname_r, tpname, 8 * sizeof(TCHAR));  <br>//    tpname_r[7] = 0;  <br>//    lstrcat(tpname_r, TEXT("R")); <br>     <br>    memcpy(tpname_w, tpname, 7 * sizeof(TCHAR));  <br>    tpname_w[7] = 0;  <br>    lstrcat(tpname_w, TEXT("W")); <br> <br>    // start an receive_allocate on the read tp <br>InterlockedIncrement(&amp;outstanding); <br>    CLEARVCB(vcb_r); <br>    vcb_r.rcvalloc.opcode = AP_RECEIVE_ALLOCATE; <br>    memcpya2e(vcb_r.rcvalloc.tp_name, tpname_r, 64); <br>    ASYNCAPPC(h_event_r, &amp;vcb_r, h_async_r); <br>    if (h_async_r == 0) { <br>InterlockedDecrement(&amp;outstanding); <br>        return FALSE; <br>    } <br>     <br>    // start an receive_allocate on the write tp <br>InterlockedIncrement(&amp;outstanding); <br>    CLEARVCB(vcb_w); <br>    vcb_w.rcvalloc.opcode = AP_RECEIVE_ALLOCATE; <br>    memcpya2e(vcb_w.rcvalloc.tp_name, tpname_w, 64); <br>    ASYNCAPPC(h_event_w, &amp;vcb_w, h_async_w); <br>    if (h_async_w == 0) { <br>InterlockedDecrement(&amp;outstanding); <br>        printf("appclib: WinAsyncAPPCEx failed with verb 0x%x near line %i\n",  <br>            APPC_FLIPI(vcb_r.rcvalloc.opcode), __LINE__); <br>        return FALSE; <br>    } <br> <br>    while (TRUE) { <br>        objs[0] = h_event_r; <br>        objs[1] = h_event_w; <br>objs[2] = hShutdownEvent; <br>        event = WaitForMultipleObjects(3, objs, FALSE, INFINITE)-WAIT_OBJECT_0; <br>        switch (event) { <br>            case 0:// someone connected to reader <br>InterlockedDecrement(&amp;outstanding); <br> <br>// check the APPC return codes <br>if (vcb_r.rcvalloc.primary_rc != AP_OK) appcerror(vcb_r); <br> <br>                // allocate a new readnode struct and the tpconv structure <br>                // inside it.  save the tp_id and conv_id into the tpconv  <br>                // structure <br>                readnode = (readnode_t) memalloc(sizeof(struct readnode_st)); <br>                readnode-&gt;tpconv =  <br>(tpconvid_t) memalloc(sizeof(struct tpconvid_st)); <br>                memcpy(readnode-&gt;tpconv-&gt;r_tp_id, vcb_r.rcvalloc.tp_id, 8); <br>                readnode-&gt;tpconv-&gt;r_conv_id = vcb_r.rcvalloc.conv_id; <br>                 <br>                // start another receive_allocate on the read TP <br>InterlockedIncrement(&amp;outstanding); <br>                CLEARVCB(vcb_r); <br>                vcb_r.rcvalloc.opcode = AP_RECEIVE_ALLOCATE; <br>                memcpya2e(vcb_r.rcvalloc.tp_name, tpname_r, 64); <br>                ASYNCAPPC(h_event_r, &amp;vcb_r, h_async_r); <br>    if (h_async_r == 0) { <br>InterlockedDecrement(&amp;outstanding); <br>        return FALSE; <br>    } <br> <br>                // receive_and_wait for the name_time key for this session <br>                dread = do_receive_and_wait(readnode-&gt;tpconv-&gt;r_tp_id,  <br>                    readnode-&gt;tpconv-&gt;r_conv_id, &amp;(readnode-&gt;name_time),  <br>                    sizeof(name_time_t), &amp;dealloc); <br>                if ((dread != sizeof(name_time_t)) || (dealloc)) { <br>                    // close session <br>memfree(readnode-&gt;tpconv); <br>memfree(readnode); <br>                    break; <br>                } <br> <br>                // add all of this to the readq <br>                addtoq(readq, (void *) readnode); <br>                break; <br>            case 1:// someone connected to writer <br>InterlockedDecrement(&amp;outstanding); <br> <br>// check the APPC return codes <br>if (vcb_w.rcvalloc.primary_rc != AP_OK) appcerror(vcb_w); <br> <br>                // save the tp id and conversation id for this session <br>                memcpy(w_tp_id, vcb_w.rcvalloc.tp_id, 8); <br>                w_conv_id = vcb_w.rcvalloc.conv_id; <br> <br>                // start another receive_allocate on the write TP <br>InterlockedIncrement(&amp;outstanding); <br>                CLEARVCB(vcb_w); <br>                vcb_w.rcvalloc.opcode = AP_RECEIVE_ALLOCATE; <br>                memcpya2e(vcb_w.rcvalloc.tp_name, tpname_w, 64); <br>                ASYNCAPPC(h_event_w, &amp;vcb_w, h_async_w); <br>    if (h_async_w == 0) { <br>InterlockedDecrement(&amp;outstanding); <br>        return FALSE; <br>    } <br> <br>                // receive and wait for the name_time key for this session <br>                dread = do_receive_and_wait(w_tp_id, w_conv_id, &amp;name_time, <br>                    sizeof(name_time_t), &amp;dealloc); <br>                if ((dread != sizeof(name_time_t)) || (dealloc)) { <br>                    // close session <br>                    break; <br>                } <br> <br>                // find the matching name_time key in the readq <br>                for (n = readq-&gt;head; n != NULL; n = n-&gt;next) { <br>                    if (memcmp(&amp;name_time,  <br>                        &amp;(((readnode_t) (n-&gt;ptr))-&gt;name_time),  <br>                        sizeof(name_time_t)) == 0) break; <br>                } <br>                if (n == NULL) { <br>                    // close session <br>                    break; <br>                } <br> <br>                readnode = (readnode_t) removeqnodefromq(readq, n); <br>                tpconv = readnode-&gt;tpconv; <br>                memfree(readnode); <br>                memcpy(tpconv-&gt;w_tp_id, w_tp_id, 8); <br>                tpconv-&gt;w_conv_id = w_conv_id; <br>                tpconv-&gt;r_valid = TRUE; <br>                tpconv-&gt;w_valid = TRUE; <br> <br>                // receive and wait to confirm data turnaround <br>                do_receive_and_wait(tpconv-&gt;w_tp_id, tpconv-&gt;w_conv_id,  <br>NULL, 0, &amp;dealloc); <br> <br>                // add it to the pairq and signal that there is one more <br>                // pair available <br>                EnterCriticalSection(&amp;csPairq); <br>                addtoq(pairq, (void *) tpconv); <br>                ReleaseSemaphore(hPairqSem, 1, NULL); <br>                LeaveCriticalSection(&amp;csPairq); <br>                break; <br>case 2:// shutdown event <br>WinAPPCCancelAsyncRequest(h_async_r); <br>InterlockedDecrement(&amp;outstanding); <br>WinAPPCCancelAsyncRequest(h_async_w); <br>if (InterlockedDecrement(&amp;outstanding) &lt;= 0)  <br>SetEvent(hOutstandingZero); <br>return FALSE; <br>        } <br>    } <br>} <br> <br>/* <br> * ---- functions to setup easy two-way APPC communication ---- <br> */ <br> <br>/* <br> * listen on a TP name for incoming conversations. <br> * <br> * each TP can only listen to one tpname at a time (because this only <br> * spawns one listenthread).  If a TP needs to be written that can handle <br> * listening to multiple TP names in one run then this will need to be  <br> * modified to make one listenthread() for each appclisten() that gets <br> * called with a unique TP name. <br> * <br> * returns a tpconvid that can be used with appcread, appcwrite and  <br> * appcclose. <br> */ <br>tpconvid_t appclisten(TCHAR *tpname) { <br>    tpconvid_t tpconv; <br>    DWORD tid; <br> <br>    APPCDBG(printf("appclisten(%ws) starting\n", tpname)); <br> <br>    if (hListenThread == NULL) { <br>        APPCDBG(printf("appclisten: creating listenthread\n")); <br>        // create the semaphore for the pairq <br>        hPairqSem = CreateSemaphore(NULL, 0, 100000, NULL); <br>        if (hPairqSem == NULL) return NULL; <br> <br>        // create the pairq <br>        pairq = newq(); <br>        if (pairq == NULL) return NULL; <br> <br>        // create a critical section for dealing with the pairq <br>        InitializeCriticalSection(&amp;csPairq); <br>     <br>        // create the listen thread <br>        hListenThread = CreateThread(NULL, 0,  <br>            (LPTHREAD_START_ROUTINE) listenthread, tpname, 0, &amp;tid); <br>        if (hListenThread == NULL) return NULL; <br>    } <br> <br>    // wait for the listen thread to put a tpconv pair into the pairq <br>    WaitForSingleObject(hPairqSem, INFINITE); <br> <br>    // remove the first tpconv pair from the pairq and return it <br>    EnterCriticalSection(&amp;csPairq); <br>    tpconv = removeheadfromq(pairq); <br>    LeaveCriticalSection(&amp;csPairq); <br> <br>    APPCDBG(printf("appclisten done\n", tpname)); <br> <br>    return tpconv; <br>} <br> <br>/* <br> * connect to a remote server.  this allocates two conversations, one <br> * to write on and one to read on.   <br> * <br> * the LU's should be listed as partners under SNA Admin with a mode name of <br> * &lt;mode_name&gt; between them. <br> * <br> * returns a tpconvid which can be used with appcread, appcwrite, and  <br> * appcclose. <br> */ <br>tpconvid_t appcconnect(TCHAR *lu_alias, TCHAR *plu_alias,  <br>                       TCHAR *tp_name, TCHAR *loc_tp_name, TCHAR *mode_name) { <br>    tpconvid_t  tpconv; <br>    name_time_t name_time; <br>    TCHAR       tpname_w[9], tpname_r[9]; <br>    TCHAR       loctpname_w[9], loctpname_r[9]; <br> <br> <br>    APPCDBG(printf("appcconnect(%ws, %ws, %ws, %ws) starting\n", lu_alias, plu_alias, tp_name, mode_name)); <br> <br>    // we actually use two different TP names, one for each session.   <br>    // the name that the server reads on ends in a R, the name that the <br>    // server writes on ends in a W <br>    memcpy(tpname_r, tp_name, 8 * sizeof(TCHAR));  <br>//    tpname_r[7] = 0;  <br>//    lstrcat(tpname_r, TEXT("R")); <br>     <br>    memcpy(tpname_w, tp_name, 7 * sizeof(TCHAR));  <br>    tpname_w[7] = 0;  <br>    lstrcat(tpname_w, TEXT("W")); <br> <br>    memcpy(loctpname_r, loc_tp_name, 8 * sizeof(TCHAR));  <br>//    loctpname_r[7] = 0;  <br>//    lstrcat(loctpname_r, TEXT("R")); <br>     <br>    memcpy(loctpname_w, loc_tp_name, 7 * sizeof(TCHAR));  <br>loctpname_w[7] = 0;  <br>    lstrcat(loctpname_w, TEXT("W")); <br> <br>    tpconv = (tpconvid_t) memalloc(sizeof(struct tpconvid_st)); <br>    if (tpconv == NULL) { <br>        printf("appclib: couldn't allocate memory for tpconvid_t\n"); <br>        exit(1); <br>    } <br> <br>    // connect the first session <br>    do_tp_started(lu_alias, loctpname_w, tpconv-&gt;w_tp_id); <br>    tpconv-&gt;w_conv_id = do_mc_allocate(plu_alias, tpname_r, mode_name,  <br>        tpconv-&gt;w_tp_id); <br>    // fill in the logical unit of work/time structure <br>    do_get_fqplu_name(tpconv-&gt;w_tp_id, tpconv-&gt;w_conv_id, name_time.fqplu_name); <br>    name_time.time = GetTickCount(); <br>    // send the fqplu name/time information <br>    do_send_data(tpconv-&gt;w_tp_id, tpconv-&gt;w_conv_id, (void *) &amp;name_time,  <br>        sizeof(name_time_t)); <br>    tpconv-&gt;w_valid = TRUE; <br> <br>    // connect the second session <br>    do_tp_started(lu_alias, loctpname_r, tpconv-&gt;r_tp_id); <br>    tpconv-&gt;r_conv_id = do_mc_allocate(plu_alias, tpname_w, mode_name,  <br>        tpconv-&gt;r_tp_id); <br>    // send the fqplu name/time information <br>    do_send_data(tpconv-&gt;r_tp_id, tpconv-&gt;r_conv_id, (void *) &amp;name_time,  <br>        sizeof(name_time_t)); <br>    // reverse the conversation <br>    do_prepare_to_receive(tpconv-&gt;r_tp_id, tpconv-&gt;r_conv_id); <br>    tpconv-&gt;r_valid = TRUE; <br> <br>    APPCDBG(printf("appcconnect done\n")); <br> <br>    return tpconv; <br>} <br> <br>/* <br> * read from a conversation setup by appcconnect() or appclisten().   <br> * will read at most &lt;maxlen&gt; bytes into the buffer at &lt;data&gt;. <br> */ <br>int appcread(tpconvid_t tpconv, void *data, int maxlen) { <br>    BOOL dealloc; <br>    int read; <br> <br>    APPCDBG(printf("appcread(tpconv, data, %i) starting\n", maxlen)); <br> <br>    if (!tpconv-&gt;r_valid) return -1; <br>    read = do_receive_and_wait(tpconv-&gt;r_tp_id, tpconv-&gt;r_conv_id, data, maxlen, <br>        &amp;dealloc); <br>    if (dealloc) tpconv-&gt;r_valid = FALSE; <br> <br>    APPCDBG(printf("appcread done, returning %i, dealloc = %i, tpconv-&gt;r_valid = %i\n", read, dealloc, tpconv-&gt;r_valid)); <br> <br>    return read; <br>} <br> <br>/* <br> * write to a conversation setup by appcconnect() or appclisten(). <br> * will write at most &lt;maxlen&gt; bytes into the buffer at &lt;data&gt; <br> */ <br>void appcwrite(tpconvid_t tpconv, void *data, int len) { <br>    APPCDBG(printf("appcwrite(tpconv, data, %i) starting\n", len)); <br>    do_send_data(tpconv-&gt;w_tp_id, tpconv-&gt;w_conv_id, data, len); <br>    APPCDBG(printf("appcwrite done\n")); <br>} <br> <br>int appcvalid(tpconvid_t tpconv) { <br>    int rc; <br> <br>    APPCDBG(printf("appcvalid starting and done, returning %i\n", (tpconv-&gt;r_valid &amp;&amp; tpconv-&gt;w_valid))); <br>    rc = (tpconv-&gt;r_valid &amp;&amp; tpconv-&gt;w_valid); <br>    return rc; <br>} <br> <br>void appcclose(tpconvid_t tpconv) { <br>    APPCDBG(printf("appcclose(tpconv) starting\n")); <br> <br>    /* deallocate the write channel */ <br>    if (tpconv-&gt;w_valid) { <br>        do_deallocate(tpconv-&gt;w_tp_id, tpconv-&gt;w_conv_id); <br>        do_tp_ended(tpconv-&gt;w_tp_id); <br>        tpconv-&gt;w_valid = FALSE; <br>    } <br> <br>    APPCDBG(printf("appcclose done\n")); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
