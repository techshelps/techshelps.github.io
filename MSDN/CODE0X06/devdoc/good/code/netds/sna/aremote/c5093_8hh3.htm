<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ARSETUP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5097"></a>ARSETUP.C</h2>
<pre><code>/*************************************************************************\ <br>* <br>* APPC Remote Installer <br>* <br>* This program brings up a dialog box that prompts for TP configuration <br>* information.  The information is then placed in the registry under <br>* Windows NT, and in the WIN.INI file under Windows.  The WIN32 compiler <br>* flag specifies the NT version, while the WINDOWS flag specifies the <br>* Windows version. <br>* <br>* 6/93 Initial coding    ARK <br>* 6/94 Modified to work with APPC Remote    T-ALEXWE <br>* <br>\*************************************************************************/ <br> <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#ifdef WIN32 <br>#include &lt;winsvc.h&gt; <br>#endif <br> <br>#ifdef        WIN32 <br>        #include &lt;windowsx.h&gt; <br>#else <br>        #include &lt;windowsx.h16&gt; <br>#endif <br> <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include "arsetup.h" <br> <br>HANDLE  hInst;                       // This program's instance <br>HWND    hDialog;                     // Global handle to main dialog <br>HWND    hTimeout;                    // A handle to the "timeout" window <br>HWND    hList;                       // Handle to the "users" list box <br> <br>WNDPROC lPrevWndProcInt = NULL,      // Holds original integer edit box window proc <br>        lPrevWndProcAppc = NULL,     // Holds original APPC edit box window proc <br>        lPrevWndProcInfinite = NULL, // Original window proc for "infinite" <br>                                     // radio button <br>        lPrevWndProcConvSec = NULL,  // Same for "conversation security" box <br>        lPrevWndProcService = NULL;  // Same for "service" box <br> <br>FARPROC lpfnInt = NULL,              // Pointer to the ValidateFieldInt <br>                                     // procedure; becomes non-NULL upon <br>                                     // initialization in ValidateField(). <br>        lpfnAppc = NULL;         // Pointer to ValidateFieldAppc procedure <br> <br>/*************************************************************************\ <br>* <br>*  FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>* <br>*  PURPOSE: Creates the dialog box. <br>* <br>*  COMMENTS: <br>* <br>\*************************************************************************/ <br> <br>int PASCAL WinMain (HINSTANCE hInstance, <br>                      HINSTANCE hPrevInstance, <br>                      LPSTR     lpCmdLine, <br>                      int       nCmdShow) <br>{ <br>  DWORD retCode; <br>  FARPROC lpfn; <br> <br>  hInst   = hInstance; <br> <br>  lpfn = (FARPROC) MakeProcInstance( (FARPROC)MainDlgProc, hInst); <br>  retCode = DialogBoxParam ((HANDLE)hInst, <br>                            (LPCSTR)"MainDlg", <br>                            NULL, <br>                            (DLGPROC) lpfn, <br>                            0); <br>  FreeProcInstance(lpfn); <br> <br>  return  (retCode); <br>} <br>/************************************************************************/ <br>/* <br> *  MainDlgProc: Handle messages to the main dialog. <br> *  Note:  Under Windows NT, installation consists of creating a service <br> *         and creating some keys in the registry, while under Windows <br> *         we instead add slightly different information to the WIN.INI file. <br> *         So two different dialogs are necessary for the different operating <br> *         systems.  Appropriate sections of the procedure below are <br> *         #ifdef'ed to handle parts of the installation that are unique <br> *         to a particular operating system. <br> */ <br>/************************************************************************/ <br>BOOL CALLBACK MainDlgProc (HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam) <br>  { <br>  static   HWND hInfinite; <br>  char     lpPathName[MAXBINPATHLEN], *lpTPName, lpParameters[MAXBINPATHLEN]; <br>  char     *lpTimeout, *lpLocalLUName, *lpCommand, *divider; <br>  char     lpFileTitle[MAXBINPATHLEN], lpSysDir[MAXBINPATHLEN]; <br>  INT      cmd; <br>  char     lpszName[MAX_COMPUTERNAME_LENGTH + 1]; <br>  int      lpcchName = MAX_COMPUTERNAME_LENGTH + 1; <br>  HANDLE   hTemp; <br>  WIN32_FIND_DATA  fdFile; <br>                                                                 <br>#ifdef WIN32 <br>  UNREFERENCED_PARAMETER(divider); <br>  UNREFERENCED_PARAMETER(lpParameters); <br>#endif <br> <br>  switch (wMsg) <br>    { <br>      case WM_INITDIALOG: <br>        hDialog = hDlg; <br> <br>        // Set maximum TP name to 128 characters <br>        SendMessage(GetDlgItem(hDlg, IDE_TPNAME), <br>                    EM_LIMITTEXT, MAXTPLEN, 0); <br> <br>        // set the default TPName <br>        SetDlgItemText(hDlg, IDE_TPNAME, "AREMOTE"); <br> <br>        // Set maximum pathname to 512 characters <br>        SendMessage(GetDlgItem(hDlg, IDE_CMDPATH), <br>                    EM_LIMITTEXT, MAXBINPATHLEN, 0); <br> <br>        // Have it use cmd.exe by default for the command <br>        GetSystemDirectory(lpSysDir, sizeof(lpSysDir)); <br>        strcat(lpSysDir, "\\cmd.exe"); <br>        SetDlgItemText(hDlg, IDE_CMDPATH, lpSysDir); <br> <br>        // Set maximum pathname to 512 characters <br>        SendMessage(GetDlgItem(hDlg, IDE_REMOTEPATH), <br>                    EM_LIMITTEXT, MAXBINPATHLEN, 0); <br> <br>        // Have it use aremote.exe by default for remote <br>        GetCurrentDirectory(sizeof(lpSysDir), lpSysDir); <br>        strcat(lpSysDir, "\\aremote.exe"); <br>        SetDlgItemText(hDlg, IDE_REMOTEPATH, lpSysDir); <br> <br>        // Allow only legal characters in "Local LU Alias" box: <br>        ValidateField(GetDlgItem(hDlg, IDE_LOCALLU), VALIDATE_APPC); <br> <br>        // Set maximum length of LU name to be 8 characters <br>        SendMessage(GetDlgItem(hDlg, IDE_LOCALLU), EM_LIMITTEXT, MAXLULEN, 0); <br> <br>        // set the LU name to this computers name by default <br>        GetComputerName(lpszName, &amp;lpcchName); <br>        MakeValidLUName(lpszName); <br>        SetDlgItemText(hDlg, IDE_LOCALLU, lpszName); <br> <br>        return TRUE; <br> <br>      case WM_COMMAND: <br>        switch (cmd = GET_WM_COMMAND_ID(wParam, lParam)) <br>          { <br>            case IDOK: <br>              // User hits OK; we get relevant info &amp; try to install. <br> <br>              // If TP name field is blank, error out <br>              if (ReadString(hDlg, IDE_TPNAME, &amp;lpTPName, MAXTPLEN) == 0) <br>                { <br>                  DisplayError(hDlg, IDS_BADTPNAME); <br>                  free(lpTPName); <br>                  return TRUE; <br>                } <br> <br>              // read path name for remote <br>              ReadString(hDlg, IDE_REMOTEPATH, &amp;lpCommand, MAXBINPATHLEN); <br>               <br>              // open the file to make sure it exists <br>              hTemp = FindFirstFile(lpCommand, &amp;fdFile); <br>              if (hTemp == INVALID_HANDLE_VALUE) { <br>                  DisplayError(hDlg, IDS_BADREMOTEPATH); <br>                  return TRUE; <br>              } else CloseHandle(hTemp); <br>                 <br>              strcpy(lpPathName, lpCommand); <br>              strcat(lpPathName, " /a "); <br> <br>              // read path name for command <br>              ReadString(hDlg, IDE_CMDPATH, &amp;lpCommand, MAXBINPATHLEN); <br> <br>              // open the file to make sure it exists <br>              hTemp = FindFirstFile(lpCommand, &amp;fdFile); <br>              if (hTemp == INVALID_HANDLE_VALUE) { <br>                  DisplayError(hDlg, IDS_BADCMDPATH); <br>                  return TRUE; <br>              } else CloseHandle(hTemp); <br>                 <br>              strcat(lpPathName, lpCommand); <br> <br>              strcpy(lpParameters, "/a "); <br>              strcat(lpParameters, lpCommand); <br> <br>              // read Local LU Alias <br>              ReadString(hDlg, IDE_LOCALLU, &amp;lpLocalLUName, MAXLULEN); <br>              if (strlen(lpLocalLUName) &lt; 1) { <br>                  DisplayError(hDlg, IDS_BADLUNAME); <br>                  return TRUE; <br>              } <br> <br>              lpTimeout = INFINITE_TIMEOUT; <br> <br>#ifdef WIN32 <br>              // Install the new service; if successful, set subkeys <br>              if (InstallServiceNT(hDlg, lpTPName, lpPathName) != 0) <br>                { <br>                  free(lpPathName); <br>                  free(lpTPName); <br>                  return TRUE; <br>                } <br> <br>              if (CreateKeys(  lpTPName, <br>                               TRUE, <br>                               lpLocalLUName, <br>                               FALSE, <br>                               FALSE, <br>                               FALSE, <br>                               lpTimeout, <br>                               lpParameters, <br>                               lpPathName <br>                               ) <br>                               != 0) <br>                { <br>                  free(lpPathName); <br>                  free(lpTPName); <br>                  return TRUE; <br>                } <br>              DisplayInfo(hDlg, IDS_SUCCESS); <br> <br>#else <br> <br>              // Add entries to WIN.INI <br>              if (InstallWindows(hDlg, lpTPName, lpPathName, <br>                     lpLocalLUName, lpParameters, <br>                                 IsDlgButtonChecked(hDlg, IDC_CONVSEC) == 1, <br>                                 IsDlgButtonChecked(hDlg, IDC_ALREADYVER) == 1, <br>                                 IsDlgButtonChecked(hDlg, IDC_QUEUED) == 1, <br>                                 lpTimeout <br>                                 ) != 0) <br>                { <br>                  free(lpPathName); <br>                  free(lpTPName); <br>                  return TRUE; <br>                } <br>              DisplayInfo(hDlg, IDS_SUCCESS); <br> <br>#endif //ifdef WIN32 <br> <br>              EndDialog(hDlg, TRUE); <br>              free(lpPathName); <br>              free(lpTPName); <br>              return TRUE; <br> <br>            case IDC_CMDPATH_BROWSE: { <br>                char filters[256]; <br>                char lpDirPath[MAXBINPATHLEN], lpFileName[MAXBINPATHLEN]; <br>                char *lpTemp; <br>                OPENFILENAME ofn; <br> <br>                GetDlgItemText(hDlg, IDE_CMDPATH, lpFileName,  <br>                    sizeof(lpFileName)); <br>                GetFullPathName(lpFileName, sizeof(lpDirPath),  <br>                    lpDirPath, &amp;lpTemp); <br>                strcpy(lpFileName, lpTemp); <br>                lpTemp[0] = 0; <br> <br>                memcpy(filters,  <br>                    "Executable Programs\0*.exe;*.bat;*.com\0\0\0", 256); <br> <br>                memset(&amp;ofn, 0, sizeof(ofn)); <br>                ofn.lStructSize = sizeof(OPENFILENAME); <br>                ofn.hwndOwner = hDlg; <br>                ofn.lpstrFilter = filters; <br>                ofn.lpstrCustomFilter = NULL; <br>                ofn.nFilterIndex = 0; <br>                ofn.lpstrFile = lpFileName; <br>                ofn.nMaxFile = sizeof(lpFileName); <br>                ofn.lpstrFileTitle = lpFileTitle; <br>                ofn.nMaxFileTitle = sizeof(lpFileTitle); <br>                ofn.lpstrTitle = "Path to Command"; <br>                ofn.lpstrInitialDir = lpDirPath; <br>                ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | <br>                            OFN_HIDEREADONLY; <br> <br>                if (GetOpenFileName(&amp;ofn)) { <br>                    SetDlgItemText(hDlg, IDE_CMDPATH, lpFileName); <br>                } <br> <br>                return TRUE; <br>              } <br> <br>            case IDC_REMOTEPATH_BROWSE: { <br>                char filters[256]; <br>                char lpDirPath[MAXBINPATHLEN], lpFileName[MAXBINPATHLEN]; <br>                char *lpTemp; <br>                OPENFILENAME ofn; <br> <br>                GetDlgItemText(hDlg, IDE_REMOTEPATH, lpFileName,  <br>                    sizeof(lpFileName)); <br>                GetFullPathName(lpFileName, sizeof(lpDirPath),  <br>                    lpDirPath, &amp;lpTemp); <br>                strcpy(lpFileName, lpTemp); <br>                lpTemp[0] = 0; <br> <br>                memcpy(filters,  <br>                    "APPC Remote\0aremote.exe\0Executable Programs\0*.exe;*.bat;*.com\0\0\0",  <br>                    256); <br> <br>                memset(&amp;ofn, 0, sizeof(ofn)); <br>                ofn.lStructSize = sizeof(OPENFILENAME); <br>                ofn.hwndOwner = hDlg; <br>                ofn.lpstrFilter = filters; <br>                ofn.lpstrCustomFilter = NULL; <br>                ofn.nFilterIndex = 0; <br>                ofn.lpstrFile = lpFileName; <br>                ofn.nMaxFile = sizeof(lpFileName); <br>                ofn.lpstrFileTitle = lpFileTitle; <br>                ofn.nMaxFileTitle = sizeof(lpFileTitle); <br>                ofn.lpstrTitle = "Path to APPC Remote"; <br>                ofn.lpstrInitialDir = lpDirPath; <br>                ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | <br>                            OFN_HIDEREADONLY; <br> <br>                if (GetOpenFileName(&amp;ofn)) { <br>                    SetDlgItemText(hDlg, IDE_REMOTEPATH, lpFileName); <br>                } <br> <br>                return TRUE; <br>              } <br> <br>            case IDCANCEL: <br>              EndDialog(hDlg, FALSE); <br>              return TRUE; <br>          } <br> <br>        break; <br> <br>      case WM_DESTROY: <br>        PostQuitMessage(0); <br>        return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br> <br>#ifdef WIN32 <br> <br>/*****************************************************************************/ <br>/* <br> * InstallServiceNT( HWND hDlg, LPSTR lpServiceName, LPSTR lpPath ) <br> * <br> * Windows NT version of installation--register a new service. <br> * <br> * Parameters <br> * ---------- <br> * <br> * hDlg: Handle to top level dialog; used for error messages. <br> * lpServiceName: A string giving the name of the TP. <br> * lpPath: A string giving the full pathname of the TP's executable. <br> * <br> * Returns <br> * ------- <br> * <br> *  Zero upon successful completion, nonzero otherwise. <br> * <br> * Comments <br> * -------- <br> *  Installs new service if possible.  Puts up appropriate message boxes if <br> *  installation fails. <br> */ <br>/*****************************************************************************/ <br>int InstallServiceNT(HWND hDlg, LPSTR lpServiceName, LPSTR lpBinaryPath) <br>{ <br> <br>  SC_HANDLE hSCManager = NULL; <br>  SC_HANDLE hService   = NULL; <br>  SC_LOCK   lSCLock    = NULL; <br> <br>  hSCManager = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS ); <br> <br>  if( hSCManager != NULL ) <br>  { <br>    /*************************************************************************/ <br>    /* Lock the service database                                             */ <br>    /*************************************************************************/ <br>    lSCLock = LockServiceDatabase( hSCManager ); <br>    if ( lSCLock != NULL ) <br>    { <br>      /***********************************************************************/ <br>      /* Create the service                                                  */ <br>      /***********************************************************************/ <br>      hService = CreateService( hSCManager, <br>                                lpServiceName,     // Service's name <br>                                lpServiceName,     // Display name (new for NT) <br>                                SERVICE_ALL_ACCESS,// Access (allow all) <br>                                0x10,              // Service type <br>                                0x3,               // Startup behavior <br>                                0x1,               // Error control <br>                                lpBinaryPath,      // Full pathname of binary <br>                                NULL,              // Load order group <br>                                NULL,              // Tag ID <br>                                NULL,              // Dependencies (none) <br>                                NULL,              // Account name <br>                                NULL               // Password <br>                                ); <br>      if ( hService != NULL ) <br>        { <br>          /*********************************************************************/ <br>          /* Close our handle to the new service                               */ <br>          /*********************************************************************/ <br>          CloseServiceHandle( hService ); <br>        } <br>      else <br>        { <br>          // Try to display the reason for the create failure <br>          ParseCreateError(hDlg, GetLastError()); <br> <br>          // Must release lock in case we are called again <br>          UnlockServiceDatabase( lSCLock ); <br> <br>          return 1; <br>        } <br> <br>      /***********************************************************************/ <br>      /* Unlock the database                                                 */ <br>      /***********************************************************************/ <br>      UnlockServiceDatabase( lSCLock ); <br>    } <br>    else <br>      { <br>        DisplayError(hDlg, IDS_LOCKFAILED); <br>        return 1; <br>      } <br>    /*************************************************************************/ <br>    /* Free our handle to the service control manager                        */ <br>    /*************************************************************************/ <br>    CloseServiceHandle( hSCManager ); <br>    return 0; <br>  } <br> <br>  DisplayError(hDlg, IDS_OPENSCMFAILED); <br>  return 1; <br>} <br> <br>/*****************************************************************************/ <br>/* <br> * CreateKeys: Set the required key values for the newly created service. <br> *  The keys are: <br> *                 Linkage: <br> *                        OtherDependencies: REG_MULTI_SZ: SnaBase <br> *                Parameters: <br> *                        SNAServiceType: REG_DWORD: 0x5 <br> *                        ConversationSecurity: REG_SZ:  "yes" or "no" <br> *                           (depending on setting of radio button in dialog box) <br> *                AlreadyVerified: REG_SZ: "yes" or "no" <br> * If the timeout isn't infinite, there appears the key: <br> *                        Timeout: REG_DWORD: &lt;timeout in seconds&gt; <br> *                        Parameters: REG_SZ: cmd line parameters <br> * If ConversationSecurity is yes, there are also these keys: <br> *                        &lt;User1&gt;: REG_SZ: &lt;Password1&gt; <br> *                                ... <br> *                        &lt;Usern&gt;: REG_SZ: &lt;Passwordn&gt; <br> * <br> *  Note that the users and passwords are read from the list box. <br> * <br> *  Arguments: <br> *    lpServiceName is the name of the TP. <br> *    lpLUName is the Local LU Alias. <br> *    The two integer arguments give the state of the radio buttons on the <br> *      dialog box.  They should be zero to indicate that "No" is selected, <br> *      nonzero otherwise. <br> *    lpTimeout is a string containing the timeout value; if the timeout is <br> *      infinite, it holds the value of INFINITE_TIMEOUT. <br> * <br> *  Returns: 0 on success, nonzero otherwise. <br> */ <br>/*****************************************************************************/ <br>INT CreateKeys(LPSTR lpServiceName, BOOL bService, LPSTR lpLUName, int iConvSec, <br>               int iAlreadyVer, int iQueued, LPSTR lpTimeout, LPSTR lpParameters, <br>               LPSTR lpExeName) <br>{ <br>  LPSTR  lpServiceFullName; <br>  int    bufsize, i, nCount; <br>  LOCALHANDLE hLocalMem; <br> <br>  // If any of the buttons says "no", change the key values so that they <br>  // will be inserted into the registry below.  This is kind of gross, but <br>  // it keeps the loop below simple. <br>  if (iConvSec == 0) <br>    { <br>      keyinfo[CONVSEC].lpData = "no"; <br>      keyinfo[CONVSEC].iDataSize = 3; <br>    } <br>  if (iAlreadyVer == 0) <br>    { <br>      keyinfo[ALREADYVER].lpData = "no"; <br>      keyinfo[ALREADYVER].iDataSize = 3; <br>    } <br>  if (bService == FALSE &amp;&amp; iQueued == 0) <br>    { <br>      // <br>      // the default of 5 is OK for queued support. <br>      // needs to be redefined to 6 for nonqueued. <br>      // <br>      keyinfo[SNASRVTYPE].lpData = "6"; <br>      keyinfo[SNASRVTYPE].iDataSize = 4; <br>    } <br> <br>  // Put timeout in structure (it won't be written out if infinite) <br>  keyinfo[TIMEOUT].lpData = lpTimeout; <br> <br>  // Put Parameters in structure <br>  keyinfo[PARAMETERS].lpData = lpParameters; <br>  keyinfo[PARAMETERS].iDataSize = strlen(lpParameters) + 1;   // Count null <br> <br>  // Put Local LU Alias in structure; it won't be written out if blank <br>  keyinfo[LUNAME].lpData = lpLUName; <br>  keyinfo[LUNAME].iDataSize = strlen(lpLUName) + 1;   // Count null <br> <br>  // Create full path of TP by concatenating the registry path with the <br>  // TP's name <br>  bufsize = MAXREGPATHLEN + 1; <br>  lpServiceFullName = (LPSTR) malloc(bufsize); <br> <br>  i = bService ? IDS_REGISTRYPATH : IDS_REGISTRYAPPLPATH ; <br>  LoadString( hInst, i, lpServiceFullName, bufsize ); <br>  lstrcat(lpServiceFullName, lpServiceName); <br> <br>  // Write out the basic keys; first key is skipped for non-service tps <br>  for ( i = bService ? 0 : 1; i &lt; NUMKEYS; i++ ) <br>    { <br>      if ( WriteKeyNT(lpServiceFullName, keyinfo[i], TRUE ) ) <br>          return 1; <br>    } <br> <br>  // if not a service then write out the path name <br>  if ( bService == FALSE ) <br>    { <br>      keyinfo[EXENAME].lpData = lpExeName; <br>      keyinfo[EXENAME].iDataSize = strlen(lpExeName) + 1;   // Count null <br>      if (WriteKeyNT(lpServiceFullName, keyinfo[EXENAME], TRUE ) ) <br>          return 1; <br>    } <br> <br>  // If timeout isn't infinite, write out the "timeout" key <br>  if (lstrcmp(lpTimeout, INFINITE_TIMEOUT)) <br>    { <br>      if (WriteKeyNT(lpServiceFullName, keyinfo[TIMEOUT], TRUE ) ) <br>          return 1; <br>    } <br> <br>  // If Local LU Alias isn't blank, write out its key <br>  if (strlen(lpLUName) &gt; 0) <br>     { <br>      if (WriteKeyNT(lpServiceFullName, keyinfo[LUNAME], TRUE ) ) <br>          return 1; <br>    } <br> <br>  // Only write out user stuff if conversation security is "yes" <br>  if (iConvSec) <br>    { <br>      keyinfo[USER].lpName = (LPSTR) malloc(MAXUSERNAMELEN + 1); <br>      nCount = SendMessage(hList, LB_GETCOUNT, 0, 0); <br>      for (i = 0; i &lt; nCount; i++) <br>        { <br>          // Get username &amp; make it the name of this key <br>          SendMessage(hList, LB_GETTEXT, (WPARAM) i, <br>                                  (LPARAM) keyinfo[USER].lpName); <br> <br>          // Get pointer to password and then get password <br>          hLocalMem = (LOCALHANDLE) SendMessage(hList, LB_GETITEMDATA, i, 0); <br>          keyinfo[USER].lpData = (LPSTR) LocalLock(hLocalMem); <br> <br>          // Password shouldn't be blank, but just in case... <br>          if (keyinfo[USER].lpData == NULL) <br>            keyinfo[USER].iDataSize = 0; <br>          else <br>            keyinfo[USER].iDataSize = strlen(keyinfo[USER].lpData); <br> <br>          if (WriteKeyNT(lpServiceFullName, keyinfo[USER], TRUE ) ) <br>            { <br>              LocalUnlock(hLocalMem); <br>              return 1; <br>            } <br>          LocalUnlock(hLocalMem); <br>        } <br>    } <br> <br>  free(lpServiceFullName); <br>  return 0; <br>} <br>/*****************************************************************************/ <br>/* <br> * WriteKeyNT: Write out the given key to the registry. <br> * Return 0 on success, nonzero otherwise. <br> */ <br>/*****************************************************************************/ <br>INT WriteKeyNT(LPSTR lpServiceFullName, KEYENTRY keyinfo, BOOL bAppendParent ) <br>{ <br>static BOOL bAskToReplace = TRUE; <br>  DWORD     dwResult; <br>  HKEY      hKey; <br>  LPSTR     lpKeyName; <br>  DWORD     dwTemp; <br> <br>  lpKeyName = (LPSTR) malloc(MAXREGPATHLEN + 1); <br> <br>  // Build full pathname of key by appending a backslash and the name of the <br>  // key to the full pathname of the TP. <br>  lstrcpy(lpKeyName, lpServiceFullName); <br>  lstrcat(lpKeyName, TEXT("\\")); <br>  lstrcat(lpKeyName, keyinfo.lpParent); <br> <br>  // Now create the subkeys and set their values <br>  if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,      // Predefined key <br>      lpKeyName,                      // Our subkey's name <br>      0,                       // Reserved <br>      NULL,                    // Class string <br>      REG_OPTION_NON_VOLATILE, // Option type (value is saved) <br>      KEY_ALL_ACCESS,          // Access mask <br>      NULL,                    // Security attributes <br>      &amp;hKey,                   // Handle to key is put here <br>      &amp;dwResult)               // Was key opened or created? <br>      == ERROR_SUCCESS) <br>        { <br>          if ( bAskToReplace &amp;&amp; dwResult == REG_OPENED_EXISTING_KEY ) <br>            { <br>            char szCaption[64]; <br>            char szText[256]; <br>              LoadString( hInst, IDS_REPLACECAPTION, szCaption, sizeof(szCaption) ); <br>              LoadString( hInst, IDS_REPLACETEXT, szText, sizeof(szText) ); <br>              switch( MessageBox( hDialog, szText, szCaption, MB_OKCANCEL|MB_ICONQUESTION ) ) <br>                { <br>              case IDCANCEL: <br>                  return 1; <br> <br>                } <br>            } <br> <br>          // <br>          // after first successful pass no need to query <br>          // <br>          bAskToReplace = FALSE; <br> <br>          // We stored all the values as strings, but some are actually numbers. <br>          // So we have to make a temporary buffer to pass RegSetValueEx the <br>          // pointer to a DWORD that it wants for DWORD data. <br>          if ( keyinfo.iDataType == REG_DWORD ) <br>            { <br>              dwTemp = atol(keyinfo.lpData); <br>              keyinfo.lpData = (LPSTR) &amp;dwTemp; <br>              keyinfo.iDataSize = sizeof(DWORD); <br>            } <br> <br>          if (RegSetValueEx(hKey, <br>                        keyinfo.lpName,    // Key name <br>                        0,                    // Reserved <br>                        keyinfo.iDataType, // Type of key data <br>                        keyinfo.lpData,    // Key's value <br>                        keyinfo.iDataSize  // Length of value (incl. nulls) <br>                        ) <br>                        != ERROR_SUCCESS) <br>            { <br>              DisplayError(hDialog, IDS_SETKEYFAILED); <br>              return 1; <br>            } <br>        } <br>      else <br>        { <br>          DisplayError(hDialog, IDS_OPENKEYFAILED); <br>          return 1; <br>        } <br> <br>  free(lpKeyName); <br>  return 0; <br>} <br>/*****************************************************************************/ <br>/* <br> * ParseCreateError: Given an error code from a registry operation, attempt <br> *   to give an appropriate error message. <br> */ <br>/*****************************************************************************/ <br>void ParseCreateError(HWND hDlg, UINT uError) <br>{ <br>  UINT code; <br>  switch (uError) <br>    { <br>      case ERROR_INVALID_PARAMETER: <br>        // "Invalid parameter" is a rather generic error name.  Since a blank <br>        // service name is the most probable way the error arose, say so: <br>        code = IDS_BADPATHNAME; <br>        break; <br> <br>      case ERROR_INVALID_NAME: <br>        code = IDS_BADTPNAME; <br>        break; <br> <br>      case ERROR_SERVICE_EXISTS: <br>        code = IDS_SERVICEEXISTS; <br>        break; <br> <br>      default: <br>        // Since we don't have a code for this error, the following will bring <br>        // up the "unknown" error message <br>        code = uError; <br>    } <br>  DisplayError(hDlg, code); <br>} <br> <br>#else <br> <br>/*****************************************************************************/ <br>/* <br> * InstallWindows: Windows version of installation; add lines to WIN.INI <br> * <br> * First we must add an entry under the heading SNAServerAutoTPs.  This entry <br> * has the name of the TP and points to another heading that contains TP- <br> * specific data.  Sample WIN.INI: <br> * <br> * [SNAServerAutoTPs] <br> * BounceTP = BounceTPParams <br> * <br> * [BounceTPParams] <br> * PathName = c:\sna\bounce.exe <br> * Parameters = /t <br> * etc.... <br> * <br> * For a list of entries, see the comment at CreateKeys().  The only difference <br> * is that WIN.INI also contains an entry for the "queued" toggle. <br> * <br> * <br> * Parameters: <br> *    szTPName: The name of the TP <br> *    szBinaryPath: The full pathname of the executable <br> *    szLUName: Local LU Alias <br> *    szParameters: The list of command line parameters <br> *    iConvSec: "Conversation security" toggle (1 = yes, 0 = no) <br> *    iAlreadyVer: "Already verified" toggle <br> *    iQueued: "Queued" toggle <br> *    lpTimeout: A string specifying the timeout in seconds, e.g. "2" <br> * <br> * Returns: zero on success, nonzero otherwise <br> */ <br>/*****************************************************************************/ <br>INT InstallWindows(HWND hDlg, char *szTPName, char *szBinaryPath, char *szLUName, <br>                   char *szParameters, <br>                   int iConvSec, int iAlreadyVer, int iQueued, char *lpTimeout <br>                   ) <br>{ <br>  char szNewKeyName[MAXTPLEN + 6]; <br>  int  i, nCount; <br>  LOCALHANDLE hLocalMem; <br> <br>  // Make new heading by concatenating TP's name and the string "Params" <br>  strcpy(szNewKeyName, szTPName); <br>  strcat(szNewKeyName, "Params"); <br> <br>  // Now add the key to the SNAServerAutoTPs heading <br>  if (WriteKeyWindows("SNAServerAutoTPs", szTPName, szNewKeyName)) <br>    return 1; <br> <br>  // Set the data fields of the keys, one at a time <br>  keyinfo[PATHNAME].data    = szBinaryPath; <br>  keyinfo[PARAMETERS].data  = szParameters; <br>  keyinfo[LUNAME].data      = szLUName; <br>  keyinfo[QUEUED].data      = iQueued ? "yes" : "no"; <br>  keyinfo[TIMEOUT].data     = lpTimeout; <br>  keyinfo[CONVSEC].data     = iConvSec ? "yes" : "no"; <br>  keyinfo[ALREADYVER].data  = iAlreadyVer ? "yes" : "no"; <br> <br>  // Loop through all the keys and add them under the new "Params" heading <br>  for (i=0; i &lt; NUMKEYS; i++) <br>    if (WriteKeyWindows(szNewKeyName, keyinfo[i].name, keyinfo[i].data)) <br>      return 1; <br> <br>  // Only write out Local LU Alias if it's not blank <br>  if (strlen(szLUName) &gt; 0) <br>    if (WriteKeyWindows(szNewKeyName, keyinfo[LUNAME].name, keyinfo[LUNAME].data)) <br>      return 1; <br> <br>  // If conversation security is on, write out users &amp; passwords <br>  if (iConvSec) <br>    { <br>      keyinfo[USER].name = (char *) malloc(MAXUSERNAMELEN + 1); <br>      nCount = SendMessage(hList, LB_GETCOUNT, 0, 0); <br> <br>      // Read usernames and passwords from list box &amp; create keys <br>      for (i = 0; i &lt; nCount; i++) <br>        { <br>          // Get username &amp; make it the name of this key <br>          SendMessage(hList, LB_GETTEXT, (WPARAM) i, <br>                                  (LPARAM) keyinfo[USER].name); <br> <br>          // Get pointer to password and then get password <br>          hLocalMem = (LOCALHANDLE) SendMessage(hList, LB_GETITEMDATA, i, 0); <br>          keyinfo[USER].data = (char *) LocalLock(hLocalMem); <br> </code></pre>
<p>
</p>
<pre><code>if (WriteKeyWindows(szNewKeyName, keyinfo[USER].name, <br>                                keyinfo[USER].data)) <br>            { <br>              LocalUnlock(hLocalMem); <br>              return 1; <br>            } <br>          LocalUnlock(hLocalMem); <br>        } <br>      free(keyinfo[USER].name); <br> <br>    } <br> <br>  return 0; <br>} <br>/*****************************************************************************/ <br>/* <br> * WriteKeyWindows:  Write the given key out to WIN.INI <br> * Return 0 on success, nonzero otherwise. <br> */ <br>/*****************************************************************************/ <br>INT WriteKeyWindows(char *heading, char *keyname, char *value) <br>{ <br>  if (WriteProfileString(heading, keyname, value) == FALSE) <br>    { <br>      DisplayError(hDialog, IDS_INIWRITEFAILED); <br>      return 1; <br>    } <br>  return 0; <br>} <br> <br>#endif //ifdef WIN32 <br> <br>/*****************************************************************************/ <br>/* <br> * ValidateField: Install a window procedure that handles messages to the <br> *   given edit window. <br> * <br> * Parameters: hwnd is the edit window, usType an identifier for the window <br> *   procuedure to install.  Currently the only allowed type is VALIDATE_INT, <br> *   which allows only digits to be typed into the edit box. <br> * <br> * Returns:  TRUE if window procedure is successfully installed, <br> *   FALSE otherwise. <br>/*****************************************************************************/ <br>BOOL ValidateField( HWND hwnd, USHORT usType) <br>{ <br>        FARPROC lpfn = NULL; <br>        LONG        lPrevWndProc; <br>        LONG FAR *lplNewWndProc; <br> <br>        if (hwnd == NULL) { <br>                return(FALSE); <br>        } <br> <br>        lPrevWndProc = GetWindowLong( hwnd, GWL_WNDPROC ); <br> <br>        if (lPrevWndProc == 0) { <br>                return(FALSE); <br>        } <br> <br>        // check that the old wndproc is the same as the one we have stored <br>        // also, get the new wndproc, based on contents of edit field <br> <br>        // We only need two validation procedures, but if you want others <br>        // (such as hexadecimal, filenames, etc.) you can add extra cases <br>        // and procedures below. <br> <br>        switch (usType) { <br>          case VALIDATE_INT: <br>            if (lpfnInt == NULL) { <br>              lpfnInt = MakeProcInstance( (FARPROC)ValidateFieldInt, hInst ); <br>            } <br>            lpfn = lpfnInt; <br> <br>            lplNewWndProc = (LONG FAR *) &amp;lPrevWndProcInt; <br>            break; <br> <br>          case VALIDATE_APPC: <br>            if (lpfnAppc == NULL) { <br>              lpfnAppc = MakeProcInstance( (FARPROC)ValidateFieldAppc, hInst ); <br>            } <br>            lpfn = lpfnAppc; <br> <br>            lplNewWndProc = (LONG FAR *) &amp;lPrevWndProcAppc; <br>            break; <br> <br>          default: <br>            return(FALSE); <br>          } <br> <br>        if (*lplNewWndProc == (LONG) NULL) { <br> <br>                *lplNewWndProc = lPrevWndProc; <br> <br>        } else { <br> <br>                if (*lplNewWndProc != lPrevWndProc) { <br>                        return(FALSE); <br>                } <br> <br>                *lplNewWndProc = lPrevWndProc; <br>        } <br> <br>        if (lpfn == NULL || <br>                SetWindowLong(hwnd, GWL_WNDPROC, (LONG) lpfn) == (LONG) NULL) { <br> <br>                return(FALSE); <br>        } <br>        return(TRUE); <br>} <br> <br>/*****************************************************************************/ <br>/* <br> * ValidateFieldInt: A window proc that allows only 0 through 9 to be typed to <br> *   an edit box. <br> */ <br>/*****************************************************************************/ <br>LRESULT CALLBACK ValidateFieldInt( HWND hwnd, WORD msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>        if (msg == WM_CHAR) { <br> <br>                char ch = LOBYTE(LOWORD(wParam)); <br> <br>                if ((ch &lt; '0' || ch &gt; '9') &amp;&amp; ch != VK_BACK ) <br>                  return(0); <br>        } <br>        // If character was legal or message wasn't WM_CHAR, <br>        // pass message on to default window proc. <br>        return CallWindowProc( lPrevWndProcInt, hwnd, msg, wParam, lParam); <br>} <br>/*****************************************************************************/ <br>/* <br> * ValidateFieldAppc: A window proc that allows only legal APPC name characters <br> *    to be typed to an edit box. <br> */ <br>/*****************************************************************************/ <br>LRESULT CALLBACK ValidateFieldAppc( HWND hwnd, WORD msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>    if (msg == WM_CHAR) { <br> <br>        char ch = LOBYTE(LOWORD(wParam)); <br> <br>        if (!(ch &gt;= '0' &amp;&amp; ch &lt;= '9' || <br>            ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' || <br>            ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' || <br>            ch == '@'   || <br>            ch == '#'   || <br>            ch == '$'   || <br>            ch == '%'   || <br>            ch == VK_BACK )) <br>            return(0); <br>    } <br>    return CallWindowProc( lPrevWndProcAppc, hwnd, msg, wParam, lParam); <br>} <br>/*****************************************************************************/ <br>/* <br> * InstallCallback: Install a callback window proc. <br> *   Arguments: <br> *        hDlg: Handle of the parent dialog <br> *      uId: ID of window for which callback will be installed <br> *      OldWndProc: Handle for previous window proc <br> *      NewWndProc: Pointer to new window proc <br> */ <br>/*****************************************************************************/ <br>void InstallCallback(HWND hDlg, UINT uId, WNDPROC *OldWndProc, FARPROC NewWndProc) <br>{ <br>  HANDLE hTemp; <br> <br>  hTemp = GetDlgItem(hDlg, uId); <br>  *OldWndProc = (WNDPROC) GetWindowLong(hTemp, GWL_WNDPROC); <br>  SetWindowLong(hTemp, GWL_WNDPROC, <br>               (LONG) MakeProcInstance( (FARPROC)NewWndProc, hInst)); <br>} <br>/*****************************************************************************/ <br>/* <br> * InfiniteWndProc: Disable "timeout" box when the "infinite" <br> *   button is pressed, and enable it when "finite" is pressed. <br> */ <br>/*****************************************************************************/ <br>LRESULT CALLBACK InfiniteWndProc( HWND hwnd, WORD msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>  if (msg == BM_SETCHECK) <br>    // wParam is 0 if button is being turned off, 1 if being turned on <br>    EnableWindow(hTimeout, (wParam == 0)); <br>  return CallWindowProc(lPrevWndProcInfinite, hwnd, msg, wParam, lParam); <br>} <br> <br> <br>/*****************************************************************************/ <br>/* <br> * ServiceWndProc: Disable "queued" box when the "service" button is pressed <br> */ <br>/*****************************************************************************/ <br>LRESULT CALLBACK ServiceWndProc( HWND hwnd, WORD msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>  HWND hwndCntl; <br> <br>  if (msg == BM_SETCHECK) { <br>    // <br>    // wParam is 0 if button is being turned off, 1 if being turned on <br>    // <br>    hwndCntl = GetDlgItem( hDialog, IDC_QUEUED ); <br>    EnableWindow( hwndCntl, wParam == 1 ? FALSE : TRUE ); <br> <br>    if ( wParam == 1 ) { <br>        SendMessage( hwndCntl, BM_SETCHECK, 1, 0 ); <br>    } <br>  } <br> <br>  return CallWindowProc(lPrevWndProcService, hwnd, msg, wParam, lParam); <br>} <br> <br> <br>/*****************************************************************************/ <br>/* <br> * ConvSecWndProc: Window proc for "conversation security" checkbox.  Grey <br> *   out "users" group box when checkbox is off <br> */ <br>/*****************************************************************************/ <br>LRESULT CALLBACK ConvSecWndProc( HWND hwnd, WORD msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>  int nItems = SendMessage(hList, LB_GETCOUNT, 0, 0L); <br>  if (msg == BM_SETCHECK) <br>    { <br>      EnableWindow(GetDlgItem(hDialog, IDC_USERBOX), wParam == 1 ? TRUE : FALSE); <br>      EnableWindow(GetDlgItem(hDialog, IDC_ADD), wParam == 1 ? TRUE : FALSE); <br>      EnableWindow(hList, wParam == 1 ? TRUE : FALSE); <br>      // Only turn on Delete &amp; Edit if there's something in the list box <br>      EnableWindow(GetDlgItem(hDialog, IDC_DELETE), wParam == 1 &amp;&amp; nItems); <br>      EnableWindow(GetDlgItem(hDialog, IDC_EDIT), wParam == 1 &amp;&amp; nItems); <br>    } <br>  return CallWindowProc(lPrevWndProcConvSec, hwnd, msg, wParam, lParam); <br>} <br> <br> <br>/*****************************************************************************/ <br>/* <br> * DeleteListItem: Handle all aspects of deleting a user from the list box, <br> *   given his index. <br> */ <br>/*****************************************************************************/ <br>void DeleteListItem(INT nIndex) <br>{ <br>  LOCALHANDLE hLocalMem; <br>  INT nUsers; <br> <br>  // Free associated password memory, if necessary <br>  if (hLocalMem = (LOCALHANDLE) SendMessage(hList, LB_GETITEMDATA, <br>                                            nIndex, 0)) <br>    LocalFree(hLocalMem); <br> <br>  // Simply remove currently selected user <br>  SendMessage(hList, LB_DELETESTRING, (WPARAM) nIndex, 0); <br> <br>  nUsers = SendMessage(hList, LB_GETCOUNT, 0, 0); <br> <br>  // Disable Delete &amp; Edit buttons if no one is left <br>  if (0 == nUsers) <br>    { <br>      EnableWindow(GetDlgItem(hDialog, IDC_DELETE), FALSE); <br>      EnableWindow(GetDlgItem(hDialog, IDC_EDIT), FALSE); <br>      return; <br>    } <br> <br>  // Move the highlight: <br>  // 1) If the deleted user was the last one in the list, go to previous user. <br>  // 2) Otherwise go to the next user. <br>  SendMessage(hList, LB_SETCURSEL, <br>              (nUsers == nIndex) ? (nIndex - 1) : nIndex, 0); <br>} <br>/*****************************************************************************/ <br>/* <br> * ReadString: Get the text from an edit box and turn it into a C string. <br> * <br> * Parameters: <br> * <br> * hDlg:  The dialog box. <br> * id: The dialog item id. <br> * lpString:  A double pointer to a character.  ReadString reserves space <br> *            for the incoming string. <br> * maxlen: The maximum number of characters to read from the edit box. <br> * <br> * Returns: <br> *   The number of characters read from the edit box. <br> */ <br>/*****************************************************************************/ <br>INT ReadString(HWND hDlg, INT id, char **lpString, INT maxlen) <br>{ <br>  // Leave space for null character <br>  *lpString = malloc((maxlen + 1) * sizeof(char)); <br> <br>  return GetDlgItemText(hDlg, id, *lpString, maxlen+1); <br>} <br>/*****************************************************************************/ <br>/* <br> * DisplayError: Bring up MessageBox with given message code's string. <br> */ <br>/*****************************************************************************/ <br>void DisplayError( HWND hwnd, UINT uError) <br>{ <br>        char        sz[256], szFormat[256]; <br> <br>        if ( LoadString( hInst, uError, sz, sizeof(sz)) == 0 ) { <br>                LoadString( hInst, IDS_UNKNOWN, szFormat, sizeof(szFormat) ); <br>                sprintf( sz, szFormat, uError ); <br>        } <br> <br>        LoadString( hInst, IDS_ERRORTITLE, szFormat, sizeof(szFormat) ); <br>        MessageBox( hwnd, sz, szFormat, MB_ICONEXCLAMATION | MB_OK); <br>} <br>/*****************************************************************************/ <br>/* <br> * DisplayInfo:  Put up an information box with given message string. <br> */ <br>/*****************************************************************************/ <br>void DisplayInfo( HWND hwnd, UINT uInfo) <br>{ <br>        char        sz[256], szFormat[256]; <br> <br>        if ( LoadString( hInst, uInfo, sz, sizeof(sz) ) == 0 ) { <br>                LoadString( hInst, IDS_NOMESSAGE, szFormat, sizeof(szFormat) ); <br>                sprintf( sz, szFormat, uInfo ); <br>        } <br> <br>        LoadString( hInst, IDS_INFOTITLE, szFormat, sizeof(szFormat) ); <br>        MessageBox( hwnd, sz, szFormat, MB_ICONINFORMATION | MB_OK); <br>} <br> <br>void MakeValidLUName(LPTSTR name) { <br>    int o, n; <br>    char oldname[MAX_COMPUTERNAME_LENGTH + 1], c; <br>    int l; <br> <br>    strcpy(oldname, name); <br> <br>    l = strlen(oldname); <br>    for (o = 0, n = 0; o &lt; l; o++) { <br>        c = toupper(oldname[o]); <br> <br>        // make sure this is a valid character <br>        if (((c &gt;= '0') &amp;&amp; (c &lt;= '9')) || <br>            ((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z')) || <br>            (c == '@') || <br>            (c == '#') || <br>            (c == '$') || <br>            (c == '%') || <br>            (c == ' ')) name[n++] = c; <br> <br>        // only allow 8 characters in a LU name <br>        if (n == 8) break; <br>    } <br>    name[n] = 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
