<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APING.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5089"></a>APING.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  MODULE NAME: APING.C <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:    Peter J. Schwaller <br> *             VNET:     PJS at RALVM6           Tie Line: 444-4376 <br> *             Internet: pjs@ralvm6.vnet.ibm.com     (919) 254-4376 <br> * <br> *  FUNCTION:  Perform an echo test to a specified destination. <br> *             APING can be used when you are first installing APPC on <br> *             your computer to make sure you can connect to another <br> *             computer in the network.  APING can also be used to <br> *             get an estimate of the delay time or throughput to another <br> *             computer in the network. <br> * <br> *  AVAILABILITY: <br> *             These sample programs and source are also available on <br> *             CompuServe through the APPC Information Exchange.  To get <br> *             to the APPC forum just type 'GO APPC' from any CompuServe <br> *             prompt.  The samples are available in the Sample Programs <br> *             library section.  Just search on the keyword CPICPGMS to <br> *             find all the samples in this series. <br> * <br> *             Updates for the sample programs and support for many more <br> *             CPI-C platforms will also be made available on CompuServe. <br> * <br> *  RELATED FILES: <br> *             See APING.DOC for detailed information. <br> * <br> *  PORTABILIITY NOTES: <br> *             The APING client program is completely portable.  In fact, <br> *             all of the source modules can be compiled without #define-ing <br> *             any platform constant value. <br> * <br> *             To take advantage of a performance optimization on the <br> *             OS/2 platform, the alloc_cpic_buffer() is used.  If the <br> *             OS/2 platform is specified (#define of OS2, FAPI, or OS2_20) <br> *             alloc_cpic_buffer() will return a shared memory buffer. <br> *             If not, a buffer allocated with malloc() will be returned. <br> * <br> *             If you are porting to a platform that can take advantage <br> *             of a specially allocated memory buffer, you should <br> *             add this support to the alloc_cpic_buffer() routine in the <br> *             CPICPORT.C file. <br> * <br> *             The get_time() routine is used to determine the current time, <br> *             which is in turn used to calculate the elapsed time of the <br> *             data transfer.  The get_time() routine is used to hide <br> *             differences between operating system timer facilties that <br> *             are available.  Since the C library routine to query the <br> *             current time only returns the time in seconds, it is <br> *             advantageous to return the current time in milliseconds <br> *             if it is available. <br> * <br> *             If you are porting to a platform that support a timer <br> *             with a resolution better than one second, you should <br> *             modify the get_time() routine in the CPICPORT.C file. <br> * <br> *  CHANGE HISTORY: <br> *  Date       Description <br> *  06/15/92   NS/DOS accepts version 2.02 into system test. <br> *  08/05/92   Version 2.31 released to CompuServe <br> *             This version was also distributed at the APPC/APPN Platform <br> *             Developer's Conference held in Raleigh, NC. <br> *  08/13/92   Changed all printf and fprintf calls to use a write_*() call. <br> *  08/17/92   Made security handling code conditionally compiled. <br> *  08/23/92   Removed call to cpicinit_default_destination(). <br> *  08/24/92   Version 2.32 released to CompuServe. <br> *  08/28/92   Changed message about invalid size parm to go to write_error(). <br> *  09/08/92   Added check for buffer==NULL.  Initialized block to zeros. <br> *  09/22/92   Version 2.33 released to CompuServe. <br> *  11/17/92   Added support for printing remote operating system name. <br> *             Version 2.34 released to CompuServe <br> *  01/07/93   Version 2.35 <br> *             Fixed a number of problems when compiling with IBM C Set/2 <br> *                password input was displayed <br> *                timer resolution was 1 second <br> * <br> *****************************************************************************/ <br> <br>/***************************************************************************** <br> * OVERVIEW of APING CPI-C Flows <br> * <br> *   Client (APING)                      Server (APINGD) <br> *   --------------                      --------------- <br> * Set up conversation <br> *   Allocate       -------------------&gt; Accept Conversation <br> * Exchange Version Numbers <br> *   Send Data      -------------------&gt; Receive <br> *   Receive        &lt;------------------- Send Data <br> * For number of iterations (i) <br> *  For number of consecutive packets (c) <br> *     Send Data    -------------------&gt; Receive <br> *  For number of consecutive packets (c) <br> *     Receive      &lt;------------------- Send Data <br> * Shut down the conversation <br> *   Deallocate (FLUSH) <br> *****************************************************************************/ <br> <br>#if defined(WIN32) || defined(WINDOWS)                                 /*WIN32*/ <br>#include &lt;windows.h&gt;                                                   /*WIN32*/ <br>#endif                                                                 /*WIN32*/ <br> <br>#include "wincpic.h" <br> <br>/* Set up constant declarations */ <br>#include "cpicdefs.h" <br> <br>/* Collection of routines with special ported version for each platform */ <br>#include "cpicport.h" <br> <br>/* standard C include files */ <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br> <br>/* CPI-C error handling routines */ <br>/* This file is supplied with APING */ <br>#include "cpicerrs.h" <br> <br>/* CPI-C conversation startup routines */ <br>/* This file is supplied with APING */ <br>#include "cpicinit.h" <br> <br>/* Argument processing procedure */ <br>/* This file is supplied with APING */ <br>#include "getopt.h" <br> <br> <br> <br>/* CPI-C error handling info */ <br>CPICERR * cpicerr; <br> <br> <br>/* <br> * Max size of a data buffer.  This is the largest size buffer that can <br> * be specified on a call to CPI-C. <br> */ <br>#define  MAX_SIZE (32763) <br> <br>/* These are the defaults to be used if the user does not provide arguments  */ <br>/* to override these values.                                                 */ <br>#define  DEFAULT_TP_NAME   "APINGD" <br>#define  DEFAULT_MODE_NAME "#INTER" <br>#define  DEFAULT_SYM_DEST  "APINGD" <br> <br>/* Define these here so we can make changes throughout the code. */ <br>/* <br> * The PROGRAM_INFO string should be kept in sync with the <br> * MAJOR_VERSION and MINOR_VERSION constants.  Although the <br> * cpicerr_exchange_version() call will support values up to 255, <br> * values for MINOR_VERSION should be from 00-99 to maintain the <br> * two character format in the version string. <br> */ <br>#define  PROGRAM_NAME      "APING" <br>#define  PROGRAM_INFO      "version 2.35" <br>#define  MAJOR_VERSION     (2) <br>#define  MINOR_VERSION     (35) <br>#define  LOG_FILE_NAME     "aping.err" <br>#define  LOG_FILE_PATH     "$LOGPATH" <br> <br>/* <br> * Define the first APING version to support one way data transfer. <br> * (Version 2.02).  After we exchange version numbers, we can determine <br> * whether or not our partner can handle one way data or not. <br> */ <br>#define  ONEWAY_MAJOR_VERSION    (2) <br>#define  ONEWAY_MINOR_VERSION    (2) <br> <br> <br> <br>typedef struct flags { <br>    int    one_way_flag;                    /* Was one way data requested    */ <br>                                            /* value of 2 means two way echo */ <br>                                            /* value of 1 means one way      */ <br>    unsigned long size;                     /* size of data sends            */ <br>    unsigned long number_iterations;        /* times through the loop        */ <br>    unsigned long number_concurrent;        /* sends by each side per loop   */ <br>} FLAGS; <br> <br>/* function prototypes for procedures in this file */ <br>void     do_aping(int argc, <br>                  char *argv[]); <br>void     process_arguments(int argc, <br>                           char *argv[], <br>                           CPICINIT * cpicinit, <br>                           FLAGS * flags); <br> <br> <br> <br>/* <br> * Message displayed with show_info() when APING is started. <br> */ <br>char * intro[] = { <br>    PROGRAM_NAME " " PROGRAM_INFO " APPC echo test with timings.", <br>    "  by Peter J. Schwaller (pjs@ralvm6.vnet.ibm.com)", <br>    NULL <br>    }; <br> <br>/* <br> * Message displayed with show_info() when usage information is requested or <br> * after an invalid flag was specified. <br> */ <br>char * usage[] = { <br>    "", <br>    "APING [flags] destination", <br>    "  destination", <br>    "\tmay be either a symbolic destination name or a partner LU name", <br>    "  -m mode_name", <br>    "\tmode name (default: " DEFAULT_MODE_NAME ")", <br>    "  -t tp_name", <br>    "\tthe TP to start on the server (default: " DEFAULT_TP_NAME ")", <br>    "  -s N", <br>    "\tN is the size of the packet transmitted (default: 100 bytes)", <br>    "  -i N", <br>    "\tN is the number of iterations (default: 2)", <br>    "  -c N", <br>    "\tN is the number of consecutive packets sent by each side (default: 1)", <br>    "  -1", <br>    "\tOnly send data from client to server (No echo)", <br>#if defined(SUPPORTS_SETTING_SECURITY) <br>    "  -u userid", <br>    "  -p password", <br>    "\tSecurity parameters.  If a userid is specified without a password,", <br>    "\tyou will be prompted for the password.", <br>    "  -n", <br>    "\tDo not use any security (SECURITY=NONE).", <br>#endif <br>    "", <br>    "The minimum time, maximum time, and average time will be shown.", <br>    NULL <br>    }; <br> <br>void _cdecl <br>main(int argc, char *argv[]) <br>{ <br> <br>    do_aping(argc, argv); <br> <br>} <br> <br> <br>void <br>do_aping( int argc, char *argv[]) <br>{ <br>    /* Variables used for CPI-C calls */ <br>    unsigned char cm_conv_id[8];            /* CPI-C conversation ID         */ <br>    CM_INT32    cm_rc;                      /* CPI-C return code             */ <br>    CM_INT32    length;                     /* generic length variable       */ <br>    CM_INT32    rts_received;               /* request to send received      */ <br>    CM_INT32    max_receive_len;            /* Max receive length on CMRCV   */ <br>    CM_INT32    data_received;              /* Data received parm from CMRCV */ <br>    CM_INT32    received_len;               /* Amount of data rcvd on CMRCV  */ <br>    CM_INT32    status_received;            /* Status from CMRCV             */ <br> <br>    /* Data buffer for send and receive */ <br>    unsigned char CM_PTR buffer;            /* CPIC data buffer              */ <br> <br>#ifdef WIN32                                                          /*WIN32*/ <br>    unsigned short WinCPICVERSION = 0x0001;                           /*WIN32*/ <br>    WCPICDATA CPICData;                                               /*WIN32*/ <br>#endif                                                                /*WIN32*/ <br> <br>    /* Destination information */ <br>    CPICINIT * cpicinit; <br> <br>    unsigned long start_time = 0;           /* when a ping starts            */ <br>    unsigned long end_time;                 /* when a ping ends              */ <br>    unsigned long elapsed_time;             /* used for time calculations    */ <br> <br>    char          partner_major_version; <br>    char          partner_minor_version; <br>    char          opsys_string[64]; <br> <br> <br>    unsigned long curr_iteration;           /* which iteration is active     */ <br>    unsigned long curr_concurrent;          /* which send/recv is active     */ <br>    unsigned long total_time = 0;           /* used to calculate averages    */ <br> <br>    unsigned long min_time = 0xFFFFFFFF;    /* used for min elapsed time     */ <br>    unsigned long max_time = 0;             /* used for max elapsed time     */ <br>                                            /* min and max are initialized   */ <br>                                            /* to the extreme opposite values*/ <br>                                            /* to avoid doing special        */ <br>                                            /* processing the first time thru*/ <br> <br>    double data_rate;                       /* Variable used to calculate    */ <br>                                            /* the data rate                 */ <br> <br>    FLAGS  flags;                           /* Command line flags            */ <br> <br>    flags.one_way_flag = 2; <br>    flags.size = 100; <br>    flags.number_iterations = 2; <br>    flags.number_concurrent = 1; <br> <br>    /* <br>     * Make sure all output is seen as soon as possible. <br>     */ <br>    setbuf(stdout, NULL); <br> <br>    show_info(intro);                       /* Show program information      */ <br> <br>#if (defined(WIN32) || defined(WINDOWS))                              /*WIN32*/ <br>       /****************************************************************WIN32*/ <br>       /* Initialisation for WinCPIC                                   *WIN32*/ <br>       /****************************************************************WIN32*/ <br>    if (WinCPICStartup(WinCPICVERSION,&amp;CPICData))                     /*WIN32*/ <br>    {                                                                 /*WIN32*/ <br>       return ;                                                    /*WIN32*/ <br>    }                                                                 /*WIN32*/ <br>#endif                                                                /*WIN32*/ <br> <br>    /* <br>     * Create a new CPICINIT structure and initialize values. <br>     * The procedures are in CPICINIT.C <br>     */ <br> <br>    cpicinit = cpicinit_new(); <br>    cpicinit_default_tp_name(cpicinit, DEFAULT_TP_NAME); <br>    cpicinit_default_mode_name(cpicinit, DEFAULT_MODE_NAME); <br>    cpicinit_default_sym_dest_name(cpicinit, DEFAULT_SYM_DEST); <br> <br>    /* <br>     * Process all of the command line arguments.  All of the conversation <br>     * setup arguments are stored in the cpicinit object.  The block size <br>     * and other loop parameters are set in the global variables. <br>     */ <br>    process_arguments(argc, argv, cpicinit, &amp;flags); <br> <br> <br>    if (cpicinit-&gt;set_destination == NOT_SET) { <br>        write_error( "\n\aYou must specify a destination.\n"); <br>        show_info(usage); <br>        do_exit(EXIT_FAILURE); <br>    } <br> <br>    if (cpicinit_query_password_needed(cpicinit)) { <br>        /* get a password from the user */ <br>        cpicinit_get_password(cpicinit); <br>    } <br> <br>    buffer = (unsigned char CM_PTR)alloc_cpic_buffer((unsigned int)flags.size); <br>                                            /* allocate an APPC buffer       */ <br> <br>    if (buffer == NULL) { <br>        write_error("Error allocating memory buffer.\nExiting...\n"); <br>        do_exit(EXIT_FAILURE); <br>    } <br> <br>    memset(buffer, 0, (unsigned int)flags.size);  /* Set block to zeros      */ <br> <br> <br>    /* <br>     * Initialize the CPICERR structure.  This is done before the CMINIT <br>     * call so that we can use CPICERR for help with errors on CMINIT. <br>     * The procedure is in CPICERR.C <br>     */ <br>    cpicerr = cpicerr_new(); <br>    cpicerr_set_program_name(cpicerr, PROGRAM_NAME); <br>    cpicerr_set_program_info(cpicerr, PROGRAM_INFO); <br>    cpicerr_set_major_version(cpicerr, MAJOR_VERSION); <br>    cpicerr_set_minor_version(cpicerr, MINOR_VERSION); <br>    cpicerr_set_log_file_name(cpicerr, LOG_FILE_NAME); <br>    cpicerr_set_log_file_path(cpicerr, LOG_FILE_PATH); <br> <br>    /* <br>     * Setup a CPI-C conversation.  This routine issues all of the <br>     * CPI-C calls from CMINIT() through just before you would <br>     * issue the CMALLC() call.  The conversation id is returned <br>     * for use by the program. <br>     */ <br>    cpicinit_setup_conversation(cpicinit, cm_conv_id, cpicerr); <br> <br>    /* <br>     * Fill in conversation information for CPI-C error reporting. <br>     */ <br>    cpicerr_set_conv_id(cpicerr, cm_conv_id); <br> <br>    { <br>    CM_SYNC_LEVEL sync_level = CM_CONFIRM; <br>    cmssl(cm_conv_id,                       /* Set sync level                */ <br>          &amp;sync_level, <br>          &amp;cm_rc); <br>    /* The only expected return code is CM_OK */ <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSSL, cm_rc); <br>    } <br> <br>    { <br>    CM_PREPARE_TO_RECEIVE_TYPE prep_to_receive = CM_PREP_TO_RECEIVE_FLUSH; <br>    cmsptr(cm_conv_id,                      /* Set prepare to receive type   */ <br>           &amp;prep_to_receive, <br>           &amp;cm_rc); <br>    /* The only expected return code is CM_OK */ <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSPTR, cm_rc); <br>    } <br> <br> <br>    /* <br>     * Fill in conversation information for CPI-C error reporting. <br>     */ <br>    cpicerr_set_conv_id(cpicerr, cm_conv_id); <br> <br>    start_time = get_time();            /* let's time the allocate       */ <br> <br>    cmallc(cm_conv_id, <br>           &amp;cm_rc); <br> <br>    end_time = get_time();                  /* stop the timer                */ <br> <br>    /* The only expected return code is CM_OK */ <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMALLC, cm_rc); <br> <br> <br>                                            /* show the allocate time        */ <br>    write_output("\nAllocate duration:                     %8lu ms\n", <br>                                                       end_time - start_time); <br> <br>    start_time = get_time(); <br> <br>    cpicerr_exchange_version_plus(cpicerr, <br>                                  cm_conv_id, <br>                                  CM_SEND_STATE, <br>                                  &amp;partner_major_version, <br>                                  &amp;partner_minor_version, <br>                                  opsys_string, <br>                                  sizeof(opsys_string)); <br> <br>    end_time = get_time();                  /* stop the timer                */ <br> <br> <br>    /* <br>     * Display the operating system string returned in the exchange. <br>     * The string length will be 0 if the operating system string <br>     * wasn't available. <br>     */ <br> <br>    if (strlen(opsys_string) != 0) { <br>        write_output("\nConnected to a partner running on: %s\n", <br>                     opsys_string); <br>    } <br> <br> <br>    /* <br>     * If the one_way_flag has been set, we have to make sure that our <br>     * partner is at the correct version to accept one way data.  If <br>     * the partner is not at the right level, we'll turn off the one <br>     * way flag and the partner will echo data (normal operating mode). <br>     * <br>     * Trying to use one way data with a partner that can't handle the <br>     * CONFIRM status indicator would result in an error on the partner <br>     * side.  On this side, we would see DEALLOCATE_ABEND. <br>     */ <br>    if ((flags.one_way_flag == 1)  &amp;&amp; <br>        !(partner_major_version &gt; ONEWAY_MAJOR_VERSION || <br>        (partner_major_version == ONEWAY_MAJOR_VERSION &amp;&amp; <br>         partner_minor_version &gt;= ONEWAY_MINOR_VERSION))) { <br>        write_output("\nOne way data transfer is not supported by partner.\n"); <br>        write_output("Partner will echo data.\n"); <br>        flags.one_way_flag = 2; <br>    } <br> <br> <br>                                            /* show the startup time         */ <br>    write_output("\nProgram startup and Confirm duration:  %8lu ms\n\n", <br>                                                       end_time - start_time); <br> <br> <br>    write_output( <br>    "        Duration        Data Sent        Data Rate        Data Rate\n"); <br>    write_output( <br>    "        (msec)          (bytes)          (KB/s)           (Mb/s)   \n"); <br>    write_output( <br>    "        --------        ---------        ---------        ---------\n"); <br> <br>    /* <br>     * Set the amount of data we will send on each CMSEND() call. <br>     */ <br>    length = flags.size; <br> <br>    /* <br>     * Start current at zero so if a BREAK occurs, it will contain the number <br>     * of iterations completed.  We take a slight risk in assuming that <br>     * the curr_iteration++ operation is atomic. <br>     * <br>     * This loop encompasses both a send loop and a receive loop.  Both <br>     * the send a receive loop are executed the number of times specified <br>     * by the number_iterations variable (set by the -i argument). <br>     */ <br>    for (curr_iteration = 0; <br>         curr_iteration&lt;flags.number_iterations; <br>         curr_iteration++ ) { <br>        { <br>        CM_SEND_TYPE send_type = CM_BUFFER_DATA; <br>        cmsst(cm_conv_id, <br>              &amp;send_type, <br>              &amp;cm_rc); <br>        if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSST, cm_rc); <br>        } <br> <br>        start_time = get_time(); <br> <br> <br>        for (curr_concurrent = 1;           /* Start current at one so we    */ <br>             curr_concurrent&lt;flags.number_concurrent ;/* do one LESS send in */ <br>             curr_concurrent++ ) {          /* loop than the specifed number */ <br> <br>            cmsend(cm_conv_id, <br>                   buffer, <br>                   &amp;length, <br>                   &amp;rts_received, <br>                   &amp;cm_rc); <br> <br> <br>            /* The only expected return code is CM_OK */ <br>            if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br> <br>        } <br> <br>        /* <br>         * For the final send in the number of concurrent sends, set the send <br>         * type to do a send and a prepare to receive.  This will send both <br>         * the data and the send permission indicator to our partner all at <br>         * once. <br>         * <br>         * If the one_way_flag has been set, we will issue a Confirm along <br>         * with the Send_Data.  This will allow us to know when the partner <br>         * has actually received all the data so we can get an accurate <br>         * timing. <br>         * <br>         * On the partner side, if Send status is received, the partner will <br>         * know to echo the data.  If Confirm status is received, the partner <br>         * will know to issued Confirmed and then get ready to receive <br>         * more data, since the partner won't be echoing. <br>         */ <br>        { <br>        CM_SEND_TYPE send_type; <br>        if (flags.one_way_flag != 1) { <br>            send_type = CM_SEND_AND_PREP_TO_RECEIVE; <br>        } else { <br>            send_type = CM_SEND_AND_CONFIRM; <br>        } <br>        cmsst(cm_conv_id, <br>              &amp;send_type, <br>              &amp;cm_rc); <br>        if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSST, cm_rc); <br>        } <br> <br>        cmsend(cm_conv_id, <br>               buffer, <br>               &amp;length, <br>               &amp;rts_received, <br>               &amp;cm_rc); <br>        /* The only expected return code is CM_OK */ <br>        if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br> <br>        if (flags.one_way_flag != 1) { <br>            max_receive_len = flags.size; <br>            do { <br> <br>                cmrcv (cm_conv_id,          /* Receive Data                  */ <br>                       buffer,              /* Data Pointer                  */ <br>                       &amp;max_receive_len,    /* Size of Data Buffer           */ <br>                       &amp;data_received,      /* returned - data received      */ <br>                       &amp;received_len,       /* returned - length of data     */ <br>                       &amp;status_received,    /* returned - status received    */ <br>                       &amp;rts_received,       /* returned - request to send    */ <br>                       &amp;cm_rc); <br>                /* The only expected return code is CM_OK */ <br>                if (cm_rc != CM_OK) { <br>                    cpicerr_handle_rc(cpicerr, MSG_CMRCV, cm_rc); <br>                } <br> <br>                if (data_received != CM_NO_DATA_RECEIVED) { <br>                    curr_concurrent--; <br>                } <br> <br>            } while ((status_received !=  CM_SEND_RECEIVED)); <br>            /* Repeat the receive loop until SEND permission has been rcvd. */ <br> <br>            if (curr_concurrent != 0) { <br>                write_error( <br>                "ERROR.\n"); <br>                write_error( <br>                    "Partner did not send the expected number of records.\n"); <br>            } <br>        } else { <br>        } <br> <br>        end_time = get_time();              /* stop timer                    */ <br> <br>        elapsed_time = end_time - start_time; /* calculate elapsed time      */ <br> <br>        write_output("%16ld", elapsed_time); <br>        write_output("%17lu", flags.size * flags.number_concurrent * <br>                              flags.one_way_flag); <br> <br>        if (elapsed_time) { <br>            data_rate =                     /* in KBytes / 0.1 Sec           */ <br>                              (double) <br>              ( ( (((double)flags.size * (double)flags.number_concurrent) / <br>                       (double)1024) * <br>                   (double)1 * (double)1000 * (double)flags.one_way_flag) <br>                           /    /* divided by */ <br>                 ( (double)elapsed_time  / (double)10)  ); <br> <br>            data_rate = data_rate / (double)10; <br> <br>            write_output("%17.1f", data_rate); <br>            write_output("%17.3f\n", (data_rate * (double)8) / (double)1000); <br>            { <br>            /* this code was for integer arithmetic */ <br>            unsigned long data_rate; <br>            unsigned long modifier = 100000L; <br>            unsigned long bytes = flags.size * flags.number_concurrent <br>                                  * flags.one_way_flag; <br> <br>            while ( bytes &gt; (0xFFFFFFFF / modifier) &amp;&amp; (modifier &gt; 10)) { <br>                modifier = modifier / 10; <br>            } /* endwhile */ <br> <br>            data_rate = (unsigned long) <br>                           ((bytes * modifier)) <br>                                    / <br>               (((unsigned long)elapsed_time * 1024L) / (100000L / modifier) ); <br>            } <br> <br> <br>        } else { <br>            write_output("\n");             /* Make sure we move to next line*/ <br>        } <br> <br>        total_time += elapsed_time;         /* accumulate the elapsed time   */ <br> <br>        if (elapsed_time &gt; max_time) { <br>            max_time = elapsed_time;        /* set the max time              */ <br>        } <br>        if (elapsed_time &lt; min_time) { <br>            min_time = elapsed_time;        /* set the min time              */ <br>        } <br> <br>    } <br> <br>    { <br>    CM_DEALLOCATE_TYPE deallocate_type = CM_DEALLOCATE_FLUSH; <br>    cmsdt(cm_conv_id, <br>          &amp;deallocate_type, <br>          &amp;cm_rc); <br>    /* The only expected return code is CM_OK */ <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSDT, cm_rc); <br>    } <br> <br>    cmdeal(cm_conv_id, <br>           &amp;cm_rc); <br>    /* The only expected return code is CM_OK */ <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMDEAL, cm_rc); <br> <br>    /* destroy the object we created with cpicinit_new() */ <br>    cpicinit_destroy(cpicinit); <br> <br>    /* destroy the object we created with cpicerr_new() */ <br>    cpicerr_destroy(cpicerr); <br> <br>    /* <br>     * Print out the grand totals and max/min times. <br>     */ <br>    { <br> <br>        double data_rate; <br> <br> <br>        if (total_time &gt; 10) { <br> <br>            data_rate =                 /* in KBytes / 0.1 Sec           */ <br>                              (double) <br>              ( ( (((double)flags.size * (double)flags.number_concurrent) / <br>                         (double)1024) * <br>                (double)curr_iteration * (double)1000 * <br>                (double)flags.one_way_flag) <br>                           /    /* divided by */ <br>                 ( (double)total_time  / (double)10)  ); <br> <br>            data_rate = data_rate / 10; <br> <br>            write_output("Totals:%9lu", total_time); <br>            write_output("%17lu", flags.size * <br>                                  flags.number_concurrent * <br>                                  curr_iteration * <br>                                  flags.one_way_flag); <br>            write_output("%17.1f", data_rate); <br>            write_output("%17.3f\n", (data_rate * (double)8) / <br>                                               (double)1000); <br>        } else { <br>            write_output("Totals:%9lu", total_time); <br>            write_output("%17lu\n", flags.size * <br>                                    flags.number_concurrent * <br>                                    curr_iteration * <br>                                    flags.one_way_flag); <br>        } <br>        if (curr_iteration &gt; 0) { <br>            write_output( <br>            "\nDuration statistics:   Min = %lu   Ave = %lu   Max = %lu\n", <br>                                             min_time, <br>                                             total_time / curr_iteration, <br>                                             max_time); <br>        } <br> <br>    } <br>    do_exit(EXIT_SUCCESS); <br> <br>} <br> <br>void <br>process_arguments(int argc, <br>                  char *argv[], <br>                  CPICINIT * cpicinit, <br>                  FLAGS * flags ) <br>{ <br>    int         c;                          /* flag specifed, used w/getopt  */ <br> <br>    /* <br>     * GETOPT is an easy way to parse command line arguments <br>     * Each parameter which can have a flag is passed in the third argument <br>     * to getopt.  Getopt returns the character of the flag on the command <br>     * line and sets optarg to point to the value associated with the flag. <br>     * optind is the index of the argument that getopt is currently processing. <br>     */ <br>    while (optind != argc) { <br>        c = getopt(argc, argv, "?1c:t:m:i:s:u:p:C:T:M:I:S:U:P:nNqQ"); </code></pre>
<p>
</p>
<pre><code>switch (c) { <br>        case EOF: <br>            optarg = argv[optind]; <br>            if (optarg[0] == '?') { <br>               show_info(usage); <br>               do_exit(EXIT_FAILURE); <br>            } <br>            optind++; <br>            if (cpicinit-&gt;set_destination == NOT_SET) { <br>                cpicinit_set_destination(cpicinit, optarg); <br>            } else { <br>                write_error("Only one destination may be specified.\n"); <br>            } <br>            break; <br>        case 'M': <br>        case 'm': <br>            cpicinit_set_mode_name(cpicinit, optarg); <br>            break; <br>        case 'T': <br>        case 't': <br>            cpicinit_set_tp_name(cpicinit,optarg); <br>            break; <br>#if defined(SUPPORTS_SETTING_SECURITY) <br>        case 'U': <br>        case 'u': <br>            cpicinit_set_userid(cpicinit, optarg); <br>            break; <br>        case 'P': <br>        case 'p': <br>            cpicinit_set_password(cpicinit, optarg); <br>            break; <br>        case 'N': <br>        case 'n': <br>            cpicinit_set_security_type(cpicinit, CM_SECURITY_NONE); <br>            break; <br>#endif <br>        case 'S': <br>        case 's': <br>            flags -&gt; size = atol(optarg); <br> <br>            if (flags-&gt;size &gt; MAX_SIZE) {   /* check bounds                  */ <br>                write_error("Size (-s) of %lu too large.\n", flags-&gt;size); <br>                write_error("Setting size to %lu\n", (unsigned long)MAX_SIZE); <br>                flags-&gt;size = MAX_SIZE;     /* reset to MAX                  */ <br>            } <br>            break; <br>        case 'Q': <br>        case 'q': <br>            /* quiet processing is done in main() */ <br>            break; <br>        case 'I': <br>        case 'i': <br>            flags-&gt;number_iterations = atol(optarg); <br>            break; <br>        case 'C': <br>        case 'c': <br>            flags-&gt;number_concurrent = atol(optarg); <br>            break; <br>        case '1': <br>            flags-&gt;one_way_flag = 1; <br>            break; <br>        case '?': <br>            show_info(usage); <br>            do_exit(EXIT_FAILURE); <br>            break; <br>        default: <br>            write_output("Invalid flag.  Use %s -? for usage\n", PROGRAM_NAME); <br>            do_exit(EXIT_FAILURE); <br>        } <br>    } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
