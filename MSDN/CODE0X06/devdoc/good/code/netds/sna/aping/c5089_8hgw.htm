<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APINGD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5090"></a>APINGD.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  MODULE NAME: APINGD.C <br> * <br> *  COPYRIGHTS: <br> *             This module contains code made available by IBM <br> *             Corporation on an AS IS basis.  Any one receiving the <br> *             module is considered to be licensed under IBM copyrights <br> *             to use the IBM-provided source code in any way he or she <br> *             deems fit, including copying it, compiling it, modifying <br> *             it, and redistributing it, with or without <br> *             modifications.  No license under any IBM patents or <br> *             patent applications is to be implied from this copyright <br> *             license. <br> * <br> *             A user of the module should understand that IBM cannot <br> *             provide technical support for the module and will not be <br> *             responsible for any consequences of use of the program. <br> * <br> *             Any notices, including this one, are not to be removed <br> *             from the module without the prior written consent of <br> *             IBM. <br> * <br> *  AUTHOR:    Peter J. Schwaller <br> *             VNET:     PJS at RALVM6           Tie Line: 444-4376 <br> *             Internet: pjs@ralvm6.vnet.ibm.com     (919) 254-4376 <br> * <br> *  FUNCTION:  Perform an echo test to a specified LU. <br> *             APING can be used when you are first installing APPC on <br> *             your computer to make sure you can connect to another <br> *             computer in the network.  APING can also be used to <br> *             get an estimate of the delay time or throughput to another <br> *             computer in the network. <br> * <br> *             APINGD echos whatever is sent by APING. <br> *                Keep receiving until you get permission to send <br> *                Send the same number of same size records <br> * <br> *  AVAILABILITY: <br> *             These sample programs and source are also available on <br> *             CompuServe through the APPC Information Exchange.  To get <br> *             to the APPC forum just type 'GO APPC' from any CompuServe <br> *             prompt.  The samples are available in the Sample Programs <br> *             library section.  Just search on the keyword CPICPGMS to <br> *             find all the samples in this series. <br> * <br> *             Updates for the sample programs and support for many more <br> *             CPI-C platforms will also be made available on CompuServe. <br> * <br> *  RELATED FILES: <br> *             See APING.DOC for usage instructions. <br> * <br> *  PORTABILIITY NOTES: <br> *             The APINGD server program is completely portable.  In fact, <br> *             all of the source modules can be compiled without #define-ing <br> *             any platform constant value. <br> * <br> *             To take advantage of a performance optimization on the <br> *             OS/2 platform, the alloc_cpic_buffer() is used.  If the <br> *             OS/2 platform is specified (#define of OS2, FAPI, or OS2_20) <br> *             alloc_cpic_buffer() will return a shared memory buffer. <br> *             If not, a buffer allocated with malloc() will be returned. <br> * <br> *             If you are porting to a platform that can take advantage <br> *             of a specially allocated memory buffer, you should <br> *             add this support to the alloc_cpic_buffer() call in the <br> *             CPICPORT.C file. <br> * <br> *  CHANGE HISTORY: <br> *  Date       Description <br> *  06/15/92   NS/DOS accepts version 2.02 into system test. <br> *  08/05/92   Version 2.31 released to CompuServe <br> *             This version was also distributed at the APPC/APPN Platform <br> *             Developer's Conference held in Raleigh, NC. <br> *  08/13/92   Changed all printf and fprintf calls to use a write_*() call. <br> *  08/24/92   Version 2.32 released to CompuServe. <br> *  09/22/92   Version 2.33 released to CompuServe. <br> *  11/17/92   Supports sending operating system string - see CPICERR.C <br> *             Version 2.34 released to CompuServe <br> *  01/07/93   Version 2.35 <br> *             Fixed a number of problems when compiling with IBM C Set/2 <br> *                password input was displayed <br> *                timer resolution was 1 second <br> * <br> *****************************************************************************/ <br> <br>#ifdef WIN32                                                           /*WIN32*/ <br>#include &lt;windows.h&gt;                                                   /*WIN32*/ <br>SERVICE_STATUS_HANDLE stat_hand;                                       /*WIN32*/ <br>SERVICE_STATUS servstat;                                               /*WIN32*/ <br>#endif                                                                 /*WIN32*/ <br> <br>#include "wincpic.h" <br> <br>/* standard C include files */ <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>/* Set up constant declarations */ <br>#include "cpicdefs.h" <br> <br>/* Collection of routines with special ported version for each platform */ <br>#include "cpicport.h" <br> <br>/* CPI-C error handling routines */ <br>/* This file is supplied with APINGD */ <br>#include "cpicerrs.h" <br> <br>/* CPI-C initialization routines */ <br>/* This file is supplied with APINGD */ <br>#include "cpicinit.h" <br> <br>/* Argument processing procedure */ <br>/* This file is supplied with APINGD */ <br>#include "getopt.h" <br> <br>/* CPI-C error handling info */ <br>CPICERR * cpicerr; <br> <br>/* <br> * Max size of a data buffer.  This is the largest size buffer that can <br> * be specified on a call to CPI-C. <br> */ <br>#define  MAX_SIZE (0x7FFF) <br> <br>/* Define these here so we can make changes throughout the code. */ <br>/* <br> * The PROGRAM_INFO string should be kept in sync with the <br> * MAJOR_VERSION and MINOR_VERSION constants.  Although the <br> * cpicerr_exchange_version() call will support values up to 255, <br> * values for MINOR_VERSION should be from 00-99 to maintain the <br> * two character format in the version string. <br> */ <br>#define  PROGRAM_NAME      "APINGD" <br>#define  PROGRAM_INFO      "version 2.35" <br>#define  MAJOR_VERSION     (2) <br>#define  MINOR_VERSION     (35) <br>#define  LOG_FILE_NAME     "apingd.err" <br>#define  LOG_FILE_PATH     "$LOGPATH" <br> <br>/* <br> * Message displayed with show_info() when APINGD is started. <br> */ <br>char * intro[] = { <br>    PROGRAM_NAME " " PROGRAM_INFO " - APPC loopback server", <br>    NULL <br>    }; <br> <br>char * log_file_name = NULL; <br> <br>void TPStart( DWORD argc, LPSTR *argv)                                /*WIN32*/ <br>{ <br>    /* Variables used for CPI-C calls */ <br>    unsigned char cm_conv_id[8];            /* CPI-C conversation ID         */ <br>    CM_INT32    temp;                                                 /*WIN32*/ <br>    CM_INT32    cm_rc;                      /* CPI-C return code             */ <br>    CM_INT32    length;                     /* generic length variable       */ <br>    CM_INT32    rts_received;               /* request to send received      */ <br>    CM_INT32    max_receive_len;            /* Max receive length on CMRCV   */ <br>    CM_INT32    data_received;              /* Data received parm from CMRCV */ <br>    CM_INT32    received_len;               /* Amount of data rcvd on CMRCV  */ <br>    CM_INT32    status_received;            /* Status from CMRCV             */ <br> <br>    /* Data buffer for send and receive */ <br>    unsigned char CM_PTR buffer;            /* CPIC data buffer              */ <br> <br>    char        destination[MAX_DESTINATION];/* Partner destination          */ <br>    unsigned int max_size;                  /* size to receive               */ <br>    int         c;                          /* flag specifed, used w/getopt  */ <br> <br>    char partner_major_version; <br>    char partner_minor_version; <br> <br> <br>    show_info(intro);                       /* display intro information     */ <br> <br>#ifdef WIN32 <br>    { <br>       /**********************************************************************/ <br>       /* Initialisation for WinCPIC                                         */ <br>       /**********************************************************************/ <br>       unsigned short WinCPICVERSION = 0x0001; <br>       WCPICDATA CPICData; <br>       if (WinCPICStartup(WinCPICVERSION,&amp;CPICData)) <br>       { <br>         return; <br>       } <br>       /**********************************************************************/ <br>       /* Set our local TP Name                                              */ <br>       /**********************************************************************/ <br>       temp=6; <br>       cmsltp("APINGD",&amp;temp,&amp;cm_rc); <br>    } <br>#endif <br> <br>    while ((DWORD)optind != argc) { <br>        c = getopt(argc, argv, "?l:"); <br>        switch (c) { <br>        case EOF: <br>            optind++; <br>            break; <br>        case 'l': <br>        case 'L': <br>            write_output("\nIncoming partner LU names will be logged to: %s\n", <br>                                                                optarg); <br>            log_file_name = optarg; <br>            break; <br>        } /* endswitch */ <br>    } /* endwhile */ <br> <br>    /* <br>     * Initialize the CPICERR structure.  This is done before the CMACCP <br>     * call so that we can use CPICERR for help with errors on CMACCP. <br>     * The procedure is in CPICERR.C <br>     */ <br>    cpicerr = cpicerr_new(); <br>    cpicerr_set_program_name(cpicerr, PROGRAM_NAME); <br>    cpicerr_set_program_info(cpicerr, PROGRAM_INFO); <br>    cpicerr_set_major_version(cpicerr, MAJOR_VERSION); <br>    cpicerr_set_minor_version(cpicerr, MINOR_VERSION); <br>    cpicerr_set_log_file_name(cpicerr, LOG_FILE_NAME); <br>    cpicerr_set_log_file_path(cpicerr, LOG_FILE_PATH); <br> <br>    cmaccp(cm_conv_id,                      /* Accept Conversation           */ <br>           &amp;cm_rc); <br>    /* <br>     * Note that as we have used cmsltp to specify our local TP name, <br>     * cmaccp may return asynchronously, so we must do a cmwait <br>     */ <br>    if (cm_rc == CM_OPERATION_INCOMPLETE)                             /*WIN32*/ <br>    {                                                                 /*WIN32*/ <br>      cmwait(cm_conv_id, &amp;cm_rc, &amp;temp);                              /*WIN32*/ <br>    }                                                                 /*WIN32*/ <br> <br>    /* <br>     * Fill in conversation information for CPI-C error reporting. <br>     */ <br>    cpicerr_set_conv_id(cpicerr, cm_conv_id); <br> <br> <br>    if (cm_rc != CM_OK) { <br>        cpicerr_handle_rc(cpicerr, MSG_CMACCP, cm_rc); <br>    } else { <br>        CM_INT32 pln_length; <br>        /* <br>         * Extract the partner LU name and display it. <br>         */ <br>        cmepln(cm_conv_id, <br>               (unsigned char *)destination, <br>               &amp;pln_length, <br>               &amp;cm_rc ); <br> <br>        destination[(int)pln_length] = '\0'; <br>        write_output("\nContacted by partner: %s\n", destination); <br> <br>        if (log_file_name != NULL) { <br>            FILE * file; <br>            file = fopen(log_file_name, "a"); <br>            if (file != NULL) { <br>                write_log(file, "\nContacted by partner: %s\n", destination); <br>                fclose(file); <br>            } <br>        } <br> <br>    } <br> <br> <br>    { <br>    CM_PREPARE_TO_RECEIVE_TYPE prep_to_receive = CM_PREP_TO_RECEIVE_FLUSH; <br>    cmsptr(cm_conv_id,                       /* Set prepare to receive type  */ <br>           &amp;prep_to_receive, <br>           &amp;cm_rc); <br>    if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSPTR, cm_rc); <br>    } <br> <br> <br>    max_receive_len = max_size = MAX_SIZE; <br> <br>    buffer = (unsigned char CM_PTR)alloc_cpic_buffer(max_size); <br>                                            /* allocate a buffer             */ <br> <br>    cpicerr_exchange_version(cpicerr, <br>                             cm_conv_id, <br>                             CM_RECEIVE_STATE, <br>                             &amp;partner_major_version, <br>                             &amp;partner_minor_version); <br> <br>    do { <br>        unsigned long count;                /* number of consecutive         */ <br>                                            /* sends or receives             */ <br>        count = 0;                          /* initialize count of recvs     */ <br>        do { <br>           cmrcv (cm_conv_id,               /* Receive Data                  */ <br>                  buffer,                   /* Data Pointer                  */ <br>                  &amp;max_receive_len,         /* Size of Data Buffer           */ <br>                  &amp;data_received,           /* returned - data received      */ <br>                  &amp;received_len,            /* returned - length of data     */ <br>                  &amp;status_received,         /* returned - status received    */ <br>                  &amp;rts_received,            /* returned - request to send    */ <br>                  &amp;cm_rc); <br> <br>            if (data_received != CM_NO_DATA_RECEIVED) { <br>                count++;                    /* keep track of receives        */ <br>            } <br>        } while ( (status_received != CM_SEND_RECEIVED) &amp;&amp; <br>                  (status_received != CM_CONFIRM_RECEIVED) &amp;&amp; <br>                   !cm_rc); <br>        /* <br>         * loop until we get permission to send data or until error <br>         */ <br> <br>        if (cm_rc != CM_OK) { <br>            if (cm_rc == CM_DEALLOCATED_NORMAL) { <br>                do_exit(EXIT_SUCCESS); <br>            } else { <br>                cpicerr_handle_rc(cpicerr, MSG_CMRCV, cm_rc); <br>            } <br>        } <br> <br>        if (status_received != CM_CONFIRM_RECEIVED) { <br>            /* <br>             * count is now equal to the number of data blocks we received <br>             * now we will send back the same number of data blocks of equal <br>             * size <br>             */ <br>            { <br>            CM_SEND_TYPE send_type = CM_BUFFER_DATA; <br>            cmsst(cm_conv_id, <br>                  &amp;send_type, <br>                  &amp;cm_rc); <br>            if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSST, cm_rc); <br>            } <br> <br>                                 /* send back the same number except for one */ <br>            for ( count--; count &amp;&amp; !cm_rc; count-- ) { <br>                length = received_len; <br>                cmsend(cm_conv_id, <br>                       buffer, <br>                       &amp;length, <br>                       &amp;rts_received, <br>                       &amp;cm_rc); <br>                if (cm_rc != CM_OK) { <br>                    cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br>                } <br>            } <br> <br>            /* <br>             * Set the send type to do a send and a prepare to receive. <br>             * This will send both the data and the send permission indicator <br>             * to our partner all at once. <br>             */ <br>            { <br>            CM_SEND_TYPE send_type = CM_SEND_AND_PREP_TO_RECEIVE; <br>            cmsst(cm_conv_id, <br>                  &amp;send_type, <br>                  &amp;cm_rc); <br>            if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSST, cm_rc); <br>            } <br> <br>            length = received_len; <br>            cmsend(cm_conv_id, <br>                   buffer, <br>                   &amp;length, <br>                   &amp;rts_received, <br>                   &amp;cm_rc); <br>            if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMSEND, cm_rc); <br>        } else { <br>            /* <br>             * The partner has requested one way data transfer only. <br>             * We'll just issue Confirmed, then go back up to receive <br>             * more data. <br>             */ <br>            cmcfmd(cm_conv_id, <br>                   &amp;cm_rc); <br>            if (cm_rc != CM_OK) cpicerr_handle_rc(cpicerr, MSG_CMCFMD, cm_rc); <br>        } <br>    } while (cm_rc == CM_OK); <br> <br> <br>    /* destroy the object we created with cpicerr_new() */ <br>    cpicerr_destroy(cpicerr); <br> <br>    do_exit(EXIT_SUCCESS); <br>} <br> <br>#ifdef WIN32 <br>/*****************************************************************************/ <br>/* The following code makes this TP invokable as an NT service. There are 3  */ <br>/* routines.                                                                 */ <br>/*                                                                           */ <br>/* 1. main. This is the entry point for the process, it sets up a service    */ <br>/*          table entry and then calls StartServiceCtrlDispatcher. This call */ <br>/*          doesn't return, but uses the thread which called it as a         */ <br>/*          control dispatcher for all the services implemented by this      */ <br>/*          process (in this case, just the TP itself).                      */ <br>/*                                                                           */ <br>/* 2. ServiceMain. This is the main entry point for the service itself, the  */ <br>/*          service control dispatcher creates a thread to start at this     */ <br>/*          routine. It must register a service control handler for the      */ <br>/*          service which will be called by the control dispatcher when it   */ <br>/*          has control instructions for the service. It then informs the    */ <br>/*          service control manager that the service is running and finally  */ <br>/*          calls the start of the TP itself. This routine should not return */ <br>/*          until the service is ready to die.                               */ <br>/*                                                                           */ <br>/* 3. ControlHandler. This routine is called by the control dispatcher when  */ <br>/*          it has instructions for the service. We do not respond to any    */ <br>/*          of the instructions as this service should be transitory and not */ <br>/*          actually run for more than a few seconds so we don't need to do  */ <br>/*          anything with the STOP or SHUTDOWN requests.                     */ <br>/*          Note that we MUST call SetServiceStatus, even if the status      */ <br>/*          hasn't changed.                                                  */ <br>/*****************************************************************************/ <br> <br>void __cdecl main( DWORD argc, LPSTR * argv); <br>void WINAPI ServiceMain(DWORD dwNumServiceArgs, LPTSTR * lpServiceArgs); <br>VOID WINAPI ControlHandler(DWORD dwControl); <br>SERVICE_STATUS_HANDLE stat_hand; <br>SERVICE_STATUS servstat; <br> <br>void __cdecl main( DWORD argc, LPSTR * argv) <br>{ <br>  SERVICE_TABLE_ENTRY  stab[2]; <br> <br>  /***************************************************************************/ <br>  /* Start the control dispatcher. This call gives the SCManager this        */ <br>  /* thread for the entire period that this service is running, so that it   */ <br>  /* can call us back with service controls. It will spawn a new thread to   */ <br>  /* run the service itself, starting at entrypoint ServiceMain.             */ <br>  /***************************************************************************/ <br>  stab[0].lpServiceName = "APINGD\0"; <br>  stab[0].lpServiceProc = ServiceMain; <br> <br>  stab[1].lpServiceName = NULL; <br>  stab[1].lpServiceProc = NULL; <br> <br>  StartServiceCtrlDispatcher(stab); <br> <br>} <br> <br> <br>/*****************************************************************************/ <br>/* This routine is the entry-point for the service itself the service        */ <br>/* control dispatcher creates a thread to start here when we issue           */ <br>/* StartServiceControlDispatcher.                                            */ <br>/*                                                                           */ <br>/* Inputs:  number of arguments to services, array of strings.               */ <br>/*                                                                           */ <br>/* Outputs: none                                                             */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>void WINAPI ServiceMain(DWORD dwNumServiceArgs, LPTSTR * lpServiceArgs) <br>{ <br> <br>  DWORD rc; <br> <br>  stat_hand = RegisterServiceCtrlHandler("APINGD\0", ControlHandler); <br>  if (stat_hand == (SERVICE_STATUS_HANDLE)NULL) <br>  { <br>    rc = GetLastError(); <br>    DebugBreak(); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Let the SCManager know that we are running.                             */ <br>  /***************************************************************************/ <br>  servstat.dwServiceType              = SERVICE_WIN32; <br>  servstat.dwCurrentState             = SERVICE_RUNNING; <br>  servstat.dwControlsAccepted         = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN; <br>  servstat.dwWin32ExitCode            = NO_ERROR; <br>  servstat.dwServiceSpecificExitCode  = NO_ERROR; <br>  servstat.dwCheckPoint               = 0; <br>  servstat.dwWaitHint                 = 0; <br> <br>  rc = SetServiceStatus(stat_hand, &amp;servstat); <br>  if (!rc) <br>  { <br>     rc = GetLastError(); <br>     DebugBreak(); <br>  } <br> <br>  TPStart(dwNumServiceArgs, lpServiceArgs); <br> <br>} <br> <br>/*****************************************************************************/ <br>/* This routine is the callback from the SCManager to handle specific        */ <br>/* service control requests. It MUST call SetServiceStatus before it         */ <br>/* returns, regardless of whether the status has changed.                    */ <br>/*                                                                           */ <br>/* Inputs: service control requested                                         */ <br>/*                                                                           */ <br>/* Outputs: none                                                             */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br>VOID WINAPI ControlHandler(DWORD dwControl) <br>{ <br>  DWORD rc; <br> <br>  switch (dwControl) <br>  { <br>    case SERVICE_CONTROL_STOP : <br>      servstat.dwCurrentState = SERVICE_STOP_PENDING; <br>      servstat.dwWaitHint     = 24000; <br>      break; <br> <br>    case SERVICE_CONTROL_PAUSE : <br>    case SERVICE_CONTROL_CONTINUE : <br>    case SERVICE_CONTROL_INTERROGATE : <br>      servstat.dwWaitHint     = 0; <br>      break; <br> <br> case SERVICE_CONTROL_SHUTDOWN: <br>      servstat.dwCurrentState = SERVICE_STOP_PENDING; <br>      servstat.dwWaitHint     = 10000; <br>break; <br>  } <br> <br>  rc=SetServiceStatus(stat_hand, &amp;servstat); <br>  if (!rc) <br>  { <br>     rc=GetLastError(); <br>  } <br> <br>} <br> <br>#endif <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
