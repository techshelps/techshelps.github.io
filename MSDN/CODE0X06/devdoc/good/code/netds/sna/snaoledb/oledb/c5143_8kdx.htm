<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CSTRING.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5145"></a>CSTRING.H</h2>
<pre><code>//////////////////////////////////////////////////////////////////////////////// <br>// string.h <br>// <br>// Copyright (C) 1987-1997 By Microsoft Corp. All rights reserved.  <br>// Copyright (C) 1997 Metawise Computing, Inc. All rights reserved. <br>// <br>//////////////////////////////////////////////////////////////////////////////// <br> <br> <br>#ifndef _STRING_H_ <br>#define _STRING_H_ <br> <br>#ifndef __wtypes_h__ <br>#include &lt;wtypes.h&gt; <br>#endif <br> <br>#ifndef _INC_TCHAR <br>#include &lt;tchar.h&gt; <br>#endif <br>#include &lt;assert.h&gt; <br> <br>extern TCHAR* g_NULL_STRING; <br>extern int _wcstombsz (char* mbstr, const wchar_t* wcstr, size_t count); <br>#ifndef NO_BSTR_SUPPORT <br>extern int _mbstowcsz (wchar_t* wcstr, const char* mbstr, size_t count); <br>#endif <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// String definition similar to CString in MFC <br> <br>class CString <br>{ <br>public: <br>// Constructors/Destructor <br>CString (); <br>CString (LPCSTR lpsz); <br>CString (LPCWSTR lpsz); <br>CString (const unsigned char* psz); <br>CString (const CString&amp; str); <br>CString (REFGUID guid); <br>~CString (); <br> <br>// Attributes &amp; Operations <br>int GetLength () const; <br>BOOL IsEmpty () const; <br>void Empty ();// free up data <br>int Copy// return size of original string <br>( <br>OUT LPTSTR lpsz,// buffer to copy string to <br>IN int nSize// size of buffer <br>); <br> <br>operator LPCTSTR() const; <br>LPTSTR Detach ();// return the string and detach it from this class <br> <br>TCHAR GetAt (int nIndex) const;// 0 based <br> <br>LPTSTR GetBuffer (int nMinLength); <br>LPTSTR GetBufferSetLength (int nNewLength); <br>void ReleaseBuffer (int nNewLength = -1); <br> <br>void TrimLeft (); <br>void TrimRight (); <br>void TruncateAt (int n); <br> <br>CString Left (int nCount) const; <br>CString Mid (int nFirst, int nCount) const; <br>CString Right (int nCount) const; <br> <br>int Find (TCHAR ch) const; <br>int ReverseFind (TCHAR ch) const; <br> <br>void MakeUpper (); <br>void MakeLower (); <br>void ReplaceBy (TCHAR chFrom, TCHAR chTo); <br> <br>void AllocCopy (CString&amp; dest, int nCopyLen, int nCopyIndex, int nExtraLen) const; <br> <br>// Assignment operations <br>void AssignCopy (int nSrcLen, LPCTSTR lpszSrcData); <br>const CString&amp; operator= (const CString&amp; str); <br>const CString&amp; operator= (TCHAR ch); <br>#ifdef _UNICODE <br>const CString&amp; operator= (char ch); <br>#endif <br>const CString&amp; operator= (LPCSTR lpsz); <br>const CString&amp; operator= (LPCWSTR lpsz); <br>const CString&amp; operator= (const unsigned char* psz); <br> <br>// Concatenation operations <br>void ConcatCopy (int len1, LPCTSTR lpsz1, int len2, LPCTSTR lpsz2); <br>void ConcatInPlace (int len, LPCTSTR lpsz); <br>const CString&amp; operator+= (const CString&amp; str); <br>const CString&amp; operator+= (TCHAR ch); <br>#ifdef _UNICODE <br>const CString&amp; operator+= (char ch); <br>#endif <br>const CString&amp; operator+= (LPCTSTR lpsz); <br> <br>friend CString operator+ (const CString&amp; str1, const CString&amp; str2); <br> <br>// Comparison operations <br>int Compare (LPCTSTR lpsz) const; <br>int CompareNoCase (LPCTSTR lpsz) const; <br> <br>#ifndef NO_BSTR_SUPPORT <br>BSTR AllocSysString () const; <br>#endif <br> <br>protected: <br>LPTSTR m_pchData;// buffer pointer <br>int m_nDataLength;// data length in TCHAR, excluding 0 terminator <br>int m_nBuffLength;// buffer length in TCHAR <br> <br>void Init (); <br>void AllocBuffer <br>( <br>IN int nLen// #TCHARs to allocate <br>); <br> <br>LPTSTR GetData () const;// return m_pchData if its not zero, else return s_NULL_STRING <br> <br>// helper functions <br>static int PASCAL SafeStrlen// return #bytes (ANSI) or #Characters(Unicode), excluding terminating 0 <br>( <br>IN LPCTSTR lpsz// could be 0 <br>); <br>}; <br> <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// Compare helpers <br> <br>BOOL operator== (const CString&amp; str1, const CString&amp; str2); <br>BOOL operator== (const CString&amp; str1, LPCTSTR lpsz2); <br>BOOL operator== (LPCTSTR lpsz1, const CString&amp; str2); <br>BOOL operator!= (const CString&amp; str1, const CString&amp; str2); <br>BOOL operator!= (const CString&amp; str1, LPCTSTR lpsz2); <br>BOOL operator!= (LPCTSTR lpsz1, const CString&amp; str2); <br>BOOL operator &lt; (const CString&amp; str1, const CString&amp; str2); <br>BOOL operator &lt; (const CString&amp; str1, LPCTSTR lpsz2); <br>BOOL operator &lt; (LPCTSTR lpsz1, const CString&amp; str2); <br>BOOL operator &gt; (const CString&amp; str1, const CString&amp; str2); <br>BOOL operator &gt; (const CString&amp; str1, LPCTSTR lpsz2); <br>BOOL operator &gt; (LPCTSTR lpsz1, const CString&amp; str2); <br>BOOL operator&lt;= (const CString&amp; str1, const CString&amp; str2); <br>BOOL operator&lt;= (const CString&amp; str1, LPCTSTR lpsz2); <br>BOOL operator&lt;= (LPCTSTR lpsz1, const CString&amp; str2); <br>BOOL operator&gt;= (const CString&amp; str1, const CString&amp; str2); <br>BOOL operator&gt;= (const CString&amp; str1, LPCTSTR lpsz2); <br>BOOL operator&gt;= (LPCTSTR lpsz1, const CString&amp; str2); <br> <br> <br>#ifndef _DEBUG <br> <br>inline CString::~CString () <br>{ <br>Empty (); <br>} <br> <br>inline void CString::Init () <br>{ <br>m_pchData = 0; <br>m_nDataLength = 0; <br>m_nBuffLength = 0; <br>} <br> <br>inline BOOL CString::IsEmpty () const <br>{ <br>return (0 == m_nDataLength); <br>} <br> <br>inline int CString::GetLength () const <br>{ <br>return m_nDataLength; <br>} <br> <br>inline int PASCAL CString::SafeStrlen <br>( <br>IN LPCTSTR lpsz// could be 0 <br>) <br>{ <br>return (0 == lpsz) ? 0 : lstrlen(lpsz); <br>} <br> <br>inline CString::operator LPCTSTR () const <br>{ <br>return (LPCTSTR) GetData (); <br>} <br> <br>inline TCHAR CString::GetAt (int nIndex) const <br>{ <br>assert(nIndex &gt;= 0); <br>assert(nIndex &lt; m_nDataLength); <br>return GetData()[nIndex]; <br>} <br> <br>inline LPTSTR CString::GetData () const <br>{ <br>return (m_pchData ? m_pchData : g_NULL_STRING); <br>} <br> <br> <br>//////////////////////////////////////////////////////////////////////////////// <br>// Compare helpers <br> <br>inline BOOL operator== (const CString&amp; str1, const CString&amp; str2) <br>{ <br>return str1.Compare (str2) == 0; <br>} <br> <br>inline BOOL operator== (const CString&amp; str1, LPCTSTR lpsz2) <br>{ <br>return str1.Compare (lpsz2) == 0; <br>} <br> <br>inline BOOL operator== (LPCTSTR lpsz1, const CString&amp; str2) <br>{ <br>return str2.Compare (lpsz1) == 0; <br>} <br> <br>inline BOOL operator!= (const CString&amp; str1, const CString&amp; str2) <br>{ <br>return str1.Compare (str2) != 0; <br>} <br> <br>inline BOOL operator!= (const CString&amp; str1, LPCTSTR lpsz2) <br>{ <br>return str1.Compare (lpsz2) != 0; <br>} <br> <br>inline BOOL operator!= (LPCTSTR lpsz1, const CString&amp; str2) <br>{ <br>return str2.Compare (lpsz1) != 0; <br>} <br> <br>inline BOOL operator &lt; (const CString&amp; str1, const CString&amp; str2) <br>{ <br>return str1.Compare (str2) &lt; 0; <br>} <br> <br>inline BOOL operator &lt; (const CString&amp; str1, LPCTSTR lpsz2) <br>{ <br>return str1.Compare (lpsz2) &lt; 0; <br>} <br> <br>inline BOOL operator &lt; (LPCTSTR lpsz1, const CString&amp; str2) <br>{ <br>return str2.Compare (lpsz1) &gt; 0; <br>} <br> <br>inline BOOL operator &gt; (const CString&amp; str1, const CString&amp; str2) <br>{ <br>return str1.Compare (str2) &gt; 0; <br>} <br> <br>inline BOOL operator &gt; (const CString&amp; str1, LPCTSTR lpsz2) <br>{ <br>return str1.Compare (lpsz2) &gt; 0; <br>} <br> <br>inline BOOL operator &gt; (LPCTSTR lpsz1, const CString&amp; str2) <br>{ <br>return str2.Compare (lpsz1) &lt; 0; <br>} <br> <br>inline BOOL operator&lt;= (const CString&amp; str1, const CString&amp; str2) <br>{ <br>return str1.Compare (str2) &lt;= 0; <br>} <br> <br>inline BOOL operator&lt;= (const CString&amp; str1, LPCTSTR lpsz2) <br>{ <br>return str1.Compare (lpsz2) &lt;= 0; <br>} <br> <br>inline BOOL operator&lt;= (LPCTSTR lpsz1, const CString&amp; str2) <br>{ <br>return str2.Compare (lpsz1) &gt;= 0; <br>} <br> <br>inline BOOL operator&gt;= (const CString&amp; str1, const CString&amp; str2) <br>{ <br>return str1.Compare (str2) &gt;= 0; <br>} <br> <br>inline BOOL operator&gt;= (const CString&amp; str1, LPCTSTR lpsz2) <br>{ <br>return str1.Compare (lpsz2) &gt;= 0; <br>} <br> <br>inline BOOL operator&gt;= (LPCTSTR lpsz1, const CString&amp; str2) <br>{ <br>return str2.Compare (lpsz1) &lt;= 0; <br>} <br> <br>inline int CString::Compare (LPCTSTR lpsz) const <br>{ <br>return _tcscmp(GetData(), lpsz); <br>} <br> <br>inline int CString::CompareNoCase (LPCTSTR lpsz) const <br>{ <br>return _tcsicmp(GetData(), lpsz); <br>} <br> <br>#endif // _DEBUG <br> <br>#endif // _STRING_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
