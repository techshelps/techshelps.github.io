<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QUERY.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5151"></a>QUERY.CPP</h2>
<pre><code>//----------------------------------------------------------------------------- <br>// Microsoft OLE DB QURYDEMO Sample <br>// Copyright (C) 1994 - 1996 By Microsoft Corporation. <br>// <br>// @doc <br>// <br>// @module QURYDEMO.CPP <br>// <br>//----------------------------------------------------------------------------------- <br>/* <br>PROGRAM: QURYDEMO <br>======== <br> <br>PURPOSE: <br>======== <br>demonstrates a simple MDI (Multiple Document Interface)application <br>that allows a user to simultaneously connect to multiple <br>hetrogeneous databases and perform SQL queries to get results. <br> <br>FUNCTIONS: <br>========== <br>InitEnvironment() - Initialize OLE <br>DisplayProviders() - Display available Providers <br>ConnectDatabase() - Connect to a specific data source <br>DisplayConnections() - Display List of made connections <br>DisplayICommands() - Display list of ICommands <br>NewICommandWindow() - Open a new ICommand and update displays <br>ChangeCurrentCursor() - Change current cursor display <br>ChangeCurrentICommand() - Change current ICommand display <br>DisplayNewCrsrAndICommand() - update cusor &amp; ICommand displays <br>FreeConnect() - free a IDBCreateCommand <br>FreeICommand() - free a ICommand <br>CloseICommandWindow() - close a ICommand window <br>ExecuteQuery() - execute a user specified query <br>CloseIDBCreateCommand() - check if all connections are closed <br>FreeEnvironment() - free OLE <br>ExecuteCommand() - Execute the ICommand and return an IRowset  <br>GetDataFromRowset() - Get the Data from the IRowset <br>SetupBindings() - Set the binding structure <br>CreateAccessor() - Create Accessor to store the Data <br>GetData() - Get the Data out of the rowset <br>  <br> <br>COMMENTS: <br>========= <br>Created by Microsoft Corporation. <br> <br>The application uses MDI Child Window Titles to store values of <br>PROVIDER's and Command Objects. These values are also stored in the <br>comboboxes that are displayed on the toolbar. <br> <br>*/ <br>#define DBINITCONSTANTS <br>#define INITGUID <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;stddef.h&gt;// offsetof <br>#include &lt;assert.h&gt;// assert <br> <br>#include "oledb.h" <br>#include "oledberr.h" <br>#include "msdaguid.h" <br> <br>#include "qurydemo.h"   <br> <br>// Globals <br>extern HWNDhWndFrame; // Main Frame Window handle <br>extern HWNDhWndCrsrList;// hdbc(s) combobox on the tool bar <br>extern HWNDhWndStmtList;// hstmt(s) combobox on the tool bar <br>extern HWNDhWndMDIClient;// MDI Client window handle <br>extern HWNDhWndActiveChild;// Current active MDI Child window <br>extern HINSTANCEhAppInstance;// Application instance <br> <br>IMalloc* g_pIMalloc = NULL; <br> <br>intnChildCount;// Number of child windows currently open <br>charszDispBuffer[MAXDISPLAYSIZE+1];// Display Buffer <br>unsigned charrgbData[MAX_COL][MAXDATALEN];// Results Data Array <br>long dwDataLen[MAX_COL];// Results Data Length Array <br> <br>//charszErrorDescription [MAXDISPLAYSIZE+1]; <br>//charszErrorSource      [MAXDISPLAYSIZE+1]; <br> <br>//Variables and constants used for provider enumeration <br>//#define   MAX_VALUE_NAME          300 <br>//#define   MAX_PROVIDER_NUM        10 <br>#define NUMELEM(p1) (sizeof(p1) / sizeof(p1[0])) <br>#define COLUMN_ALIGNVAL 8 <br>#define ROUND_UP( Size, Amount ) (((DWORD)(Size) +  ((Amount) - 1)) &amp; ~((Amount) - 1)) <br> <br>const ULONGDEF_SOURCES_CBMAXLEN= 64; <br>const ULONG MAX_NUM_PROVIDERS= 16; <br> <br>IParseDisplayName*g_pIParse = NULL; <br>ULONGg_cProvNames; <br>CHARg_rgszProvName[MAX_NUM_PROVIDERS][DEF_SOURCES_CBMAXLEN]; <br>WCHARg_rgwszParseName[MAX_NUM_PROVIDERS][DEF_SOURCES_CBMAXLEN]; <br> <br>/* <br>FUNCTION: InitEnvironment() <br>COMMENTS: Allocate an environment handle for OLE function calls. <br>*/ <br>FAR PASCAL InitEnvironment() <br>{ <br>HRESULThr; <br> <br>// Initialize OLE <br>hr = CoInitialize( NULL ); <br> <br>if (FAILED(hr)) <br>{ <br>DumpErrorHResult( hr, (LPSTR)"CoInitialize FAILED!!" ); <br>return FALSE; <br>} <br> <br>    // Retrieve the task memory allocator <br>    hr = CoGetMalloc( MEMCTX_TASK, &amp;g_pIMalloc ); <br> <br>if (FAILED(hr)) <br>{ <br>DumpErrorHResult( hr, (LPSTR)"CoGetMalloc FAILED!!" ); <br>return FALSE; <br>} <br> <br>// reset child window count <br>nChildCount = 0; <br> <br>// Return TRUE <br>return TRUE; <br>} <br> <br>/* <br>FUNCTION: DisplayProviders(HWND hWnd) <br>COMMENTS: Display a list of available Providers. <br>*/ <br>void FAR PASCAL DisplayProviders(HWND hWnd) <br>{ <br>    ULONGiProv; <br>HRESULThr; <br> <br>// Initialize count of provider names <br>g_cProvNames = 0; <br> <br>//Go to registry and get me the provider names <br>hr = EnumerateProviders();   <br>if (FAILED (hr)) <br>{ <br>  MessageBox(hWndFrame,  <br>             "There was an error retrieve providers from the OLE DB Enumerator",  <br>             "Enumeration Error",  <br> MB_OK | MB_ICONERROR); <br>  return; <br>} <br> <br>//All returned Providerss in the provided combo box for display. <br>SendMessage(hWnd, CB_RESETCONTENT, 0, 0); <br>for (iProv=0; iProv&lt;g_cProvNames; iProv++) <br>   SendMessage(hWnd, CB_ADDSTRING, 0, (LPARAM)(LPSTR)g_rgszProvName[iProv]); <br> <br>SendMessage(hWnd, CB_SETCURSEL, 0, 0); <br>} <br> <br>/* <br>FUNCTION: EnumerateProviders <br>COMMENTS: Display a list of available providers <br>*/ <br>HRESULT EnumerateProviders <br>( <br>) <br>{ <br>HRESULThr; <br>ULONGul, cRows = 0; <br>ISourcesRowset*pISrcRowset = NULL; <br>IRowset*pIRowset = NULL; <br>IAccessor*pIAccessor = NULL; <br>BYTE*pData = NULL; <br>DWORDdwOffset; <br>HACCESSORhAccessor = NULL; <br>DBBINDINGrgBind[3]; <br>HROWrghRows[MAX_NUM_PROVIDERS]; <br>HROW*pRows = &amp;rghRows[0]; <br> <br>enum enumSOURCES_COLUMNS { <br>eid_SOURCES_NAME = 1, <br>eid_SOURCES_PARSENAME, <br>eid_SOURCES_DESCRIPTION, <br>eid_SOURCES_TYPE, <br>eid_SOURCES_ISPARENT, <br>eid_SOURCES_CLSID, <br>}; <br> <br>static struct tagSOURCES <br>{ <br>ULONGiOrdinal; <br>DBTYPEwType; <br>ULONGcbMaxLen; <br>} s_rgSources[] = { <br>eid_SOURCES_NAME,DBTYPE_STR,DEF_SOURCES_CBMAXLEN, <br>eid_SOURCES_PARSENAME,DBTYPE_WSTR,DEF_SOURCES_CBMAXLEN * sizeof(WCHAR), <br>eid_SOURCES_TYPE,DBTYPE_UI4,sizeof(ULONG), <br>}; <br> <br>memset(rghRows, 0, sizeof(rghRows)); <br> <br>// Initialize the OLE DB Enumerator <br>if( FAILED(hr = CoCreateInstance(CLSID_OLEDB_ENUMERATOR, NULL,  <br>CLSCTX_INPROC_SERVER, IID_ISourcesRowset, (LPVOID*)&amp;pISrcRowset)) ) <br>{ <br>DumpErrorHResult( hr, (LPSTR)"CoCreateInstance FAILED!!" ); <br>goto EXIT; <br>} <br> <br>// Retrieve the Rowset <br>if( FAILED(hr = pISrcRowset-&gt;GetSourcesRowset(NULL, IID_IRowset, 0, NULL,  <br>(IUnknown**)&amp;pIRowset)) ) <br>{ <br>DumpErrorHResult( hr, (LPSTR)"GetSourcesRowset FAILED!!" ); <br>goto EXIT; <br>} <br> <br>memset(rgBind, 0, sizeof(rgBind)); <br> <br>if( FAILED(hr = pIRowset-&gt;QueryInterface(IID_IAccessor, (LPVOID*)&amp;pIAccessor)) ) <br>{ <br>DumpErrorHResult( hr, (LPSTR)"QI of IID_IAccessor from pIRowset failed" ); <br>goto EXIT; <br>} <br> <br>dwOffset = 0; <br>for(ul=0; ul&lt; NUMELEM(s_rgSources); ul++) <br>{ <br>rgBind[ul].dwPart= DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS; <br>rgBind[ul].eParamIO= DBPARAMIO_NOTPARAM; <br>rgBind[ul].iOrdinal= s_rgSources[ul].iOrdinal; <br>rgBind[ul].wType= s_rgSources[ul].wType; <br>rgBind[ul].obValue= dwOffset + offsetof(COLUMNDATA,bData); <br>rgBind[ul].obLength= dwOffset + offsetof(COLUMNDATA,dwLength); <br>rgBind[ul].obStatus= dwOffset + offsetof(COLUMNDATA,wStatus); <br>rgBind[ul].cbMaxLen= s_rgSources[ul].cbMaxLen; <br>rgBind[ul].dwMemOwner= DBMEMOWNER_CLIENTOWNED; <br>dwOffset += rgBind[ul].cbMaxLen + offsetof( COLUMNDATA, bData ); <br>dwOffset = ROUND_UP( dwOffset, COLUMN_ALIGNVAL ); <br>} <br> <br>if( FAILED(hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, NUMELEM(s_rgSources),  <br>rgBind, dwOffset, &amp;hAccessor, NULL)) ) <br>{ <br>DumpErrorHResult( hr, (LPSTR)"Accessor Creation failed!!" ); <br>goto EXIT; <br>} <br> <br>// Retrieve the providers <br>if( SUCCEEDED(hr = pIRowset-&gt;GetNextRows(NULL, 0, MAX_NUM_PROVIDERS, &amp;cRows, &amp;pRows)) ) <br>{ <br>// Allocate block of memory to retrieve the row data into. <br>pData = new BYTE[dwOffset]; <br>if( pData == NULL ) <br>{ <br>DumpErrorHResult( E_OUTOFMEMORY, (LPSTR)"Unable to allocate memory for buffer"); <br>goto EXIT; <br>} <br> <br>// Loop over the rows of data, collecting providers and discarding  <br>// enumerators.. <br>for(ul=0; (ul&lt;cRows) &amp;&amp; (ul&lt;MAX_NUM_PROVIDERS); ul++) <br>{ <br>memset(pData, 0, dwOffset); <br> <br>if( SUCCEEDED(hr = pIRowset-&gt;GetData(rghRows[ul], hAccessor, pData)) ) <br>{ <br>if( *((ULONG*)(pData + rgBind[2].obValue)) == DBSOURCETYPE_DATASOURCE ) <br>{ <br>// Store Provider Name <br>strcpy(g_rgszProvName[g_cProvNames], (CHAR*)(pData + rgBind[0].obValue)); <br> <br>// Store Parse Name <br>wcscpy(g_rgwszParseName[g_cProvNames], (WCHAR*)(pData + rgBind[1].obValue)); <br> <br>g_cProvNames++; <br>} <br>} <br>} <br>} <br>else <br>{ <br>DumpErrorHResult( hr, (LPSTR)"GetNextRows failed to retrieve Providers" ); <br>goto EXIT; <br>} <br> <br>// Retrieve the IID_IParseDisplayName interface before returning <br>if( FAILED(hr = pISrcRowset-&gt;QueryInterface(IID_IParseDisplayName, (LPVOID*)&amp;g_pIParse)) ) <br>{ <br>DumpErrorHResult( hr, (LPSTR)"QI for IParseDisplayName failed"); <br>goto EXIT; <br>} <br> <br>EXIT: <br>if( pData ) <br>delete[] pData; <br> <br>if( pIAccessor ) <br>{ <br>if( hAccessor ) <br>{ <br>if( FAILED(hr = pIAccessor-&gt;ReleaseAccessor(hAccessor, NULL)) ) <br>DumpErrorHResult( hr, (LPSTR)"Release Accessor failed!!" ); <br>} <br>pIAccessor-&gt;Release(); <br>} <br> <br>if( pIRowset ) <br>{ <br>if( cRows ) <br>{ <br>if( FAILED(hr = pIRowset-&gt;ReleaseRows(cRows, rghRows, NULL, NULL, NULL)) ) <br>DumpErrorHResult( hr, (LPSTR)"Release of Row handles failed"); <br>} <br>pIRowset-&gt;Release(); <br>} <br> <br>if( pISrcRowset ) <br>pISrcRowset-&gt;Release(); <br>return hr; <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// ConnectDatabase <br>//  <br>// Purpose: <br>//  <br>//     Initializes the PROVIDER and creates a IDBCreateCommand Object. <br>//      <br>// Parameters: <br>// <br>// HWND hWnd                - handle to the window <br>//  <br>// Return Value: <br>//     TRUE         - Success <br>//     FALSE        - Failure <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     IDBInitialize::Release      provider's Command object <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>BOOL FAR PASCAL ConnectDatabase(HWND hWnd) <br>{ <br>// Global IDBInitialize Options <br>IMoniker*pIMoniker= NULL;// Moniker <br>IDBInitialize * pIDBInit= NULL;// IDBInitialize Object <br>IDBCreateCommand *pIDBCreateCommand= NULL;// IDBCreateCommand <br>IDBCreateSession *pIDBCreateSession= NULL; // IDBCreateSession <br>IDBProperties*pIDBProperties= NULL; // IDBProperties <br>IOpenRowset *pIOpenRowset= NULL;// IOpenRowset <br>IUnknown *pIUnknown= NULL;// IUnknown <br>HRESULThr;// HRESULT <br>DBPROPSETrgPropertySet[1];// Array of property sets <br>DBPROPrgProperties[5];// Array of property values <br>BOOLbReturn = FALSE;// Return Value <br>shortiPrompt;// DBPROP_INIT_PROMPT value. <br>ULONGiProp, iPDex; <br>ULONGchEaten; <br> <br>// Strings for MSDASQL (CHAR &amp; WCHAR) <br>CHARszProvName[MAXBUFLEN+1];// Provider String <br>CHARszDBName[MAXBUFLEN+1];// DSN String <br>WCHARwszBuff[MAXBUFLEN+1];// WCHAR buffer <br>CHARszUserName[MAXBUFLEN+1];// User Name <br>CHARszPassword[MAXBUFLEN+1];// Password <br>CHARszBuffer[MAXBUFLEN+1];// String Buffer <br>LRESULT nResult;// Return Code <br>BOOLfCommandWindow=FALSE;// Flag to indicate Command support <br> <br>// Initialize Property Buffers <br>for(iProp=0; iProp&lt;NUMELEM(rgProperties); iProp++) <br>VariantInit(&amp;(rgProperties[iProp].vValue)); <br> <br>// check if enough windows are already open, refuse connection <br>if (nChildCount &gt;= MAXCHILDWNDS) <br>{ <br>MessageBox(hWndFrame, MAXCHILDEXCEEDED, MAXCHLDERR, MB_OK | MB_ICONHAND); <br>return (FALSE); <br>} <br> <br>// Retrieve Provider values from the connect dialog box <br>GetDlgItemText(hWnd, IDCOMBO_PROVIDER, szProvName, MAXBUFLEN); <br>GetDlgItemText(hWnd, IDCOMBO_NAME,    szDBName,   MAXBUFLEN); <br>GetDlgItemText(hWnd, IDTEXT_USERID,    szUserName, MAXBUFLEN); <br>GetDlgItemText(hWnd, IDTEXT_PASSWORD,  szPassword, MAXBUFLEN); <br>if ((iPrompt = (short) SendMessage(GetDlgItem(hWnd, IDCOMBO_PROMPT), CB_GETCURSEL, 0, 0)) == CB_ERR) <br>iPrompt = -1; <br>else <br>++iPrompt; <br> <br>    //Determine the ParseDisplayName <br>for(iPDex=0; iPDex&lt;g_cProvNames; iPDex++) <br>    { <br>if( strcmp((const char *)szProvName, (const char *) g_rgszProvName[iPDex])==0 ) <br>break; <br>} <br> <br>if( iPDex &gt;= g_cProvNames ) <br>{ <br>DumpErrorHResult( E_FAIL, (LPSTR)"Unknown Provider, Please Select Valid Provider" ); <br>goto error; <br>} <br> <br>if( FAILED(hr = g_pIParse-&gt;ParseDisplayName(NULL, g_rgwszParseName[iPDex], &amp;chEaten, &amp;pIMoniker)) )  <br>{ <br>DumpErrorHResult( hr, (LPSTR)"ParseDisplayName failed"); <br>goto error; <br>} <br> <br>if( FAILED(hr = BindMoniker(pIMoniker, 0, IID_IDBInitialize, (LPVOID*)&amp;pIDBInit)) ) <br>{ <br>DumpErrorHResult( hr, (LPSTR)"BindMoniker failed"); <br>goto error; <br>} <br> <br>iProp = 0; <br>// If DataSource name specified, then create property node <br>if( *szDBName != '\0' ) <br>{ <br>// Fill in Data Source <br>rgProperties[iProp].dwPropertyID=DBPROP_INIT_DATASOURCE; <br>rgProperties[iProp].dwOptions=DBPROPOPTIONS_REQUIRED; <br>rgProperties[iProp].colid=DB_NULLID; <br>MultiByteToWideChar(CP_ACP, 0, szDBName, -1, wszBuff, MAXBUFLEN+1); <br>V_VT(&amp;(rgProperties[iProp].vValue))=VT_BSTR; <br>V_BSTR(&amp;(rgProperties[iProp].vValue))=SysAllocString(wszBuff); <br>iProp++; <br>} <br> <br>// If User Name specified, then create property node <br>if( *szUserName != '\0' ) <br>{ <br>rgProperties[iProp].dwPropertyID=DBPROP_AUTH_USERID; <br>rgProperties[iProp].dwOptions=DBPROPOPTIONS_REQUIRED; <br>rgProperties[iProp].colid=DB_NULLID; <br>MultiByteToWideChar(CP_ACP, 0, szUserName, -1, wszBuff, MAXBUFLEN+1); <br>V_VT(&amp;(rgProperties[iProp].vValue))=VT_BSTR; <br>V_BSTR(&amp;(rgProperties[iProp].vValue))=SysAllocString(wszBuff); <br>iProp++; <br>} <br> <br>// If Password specified, then create property node <br>if( *szPassword != '\0' ) <br>{ <br>rgProperties[iProp].dwPropertyID=DBPROP_AUTH_PASSWORD; <br>rgProperties[iProp].dwOptions=DBPROPOPTIONS_REQUIRED; <br>rgProperties[iProp].colid=DB_NULLID; <br>MultiByteToWideChar(CP_ACP, 0, szPassword, -1, wszBuff, MAXBUFLEN+1); <br>V_VT(&amp;(rgProperties[iProp].vValue))=VT_BSTR; <br>V_BSTR(&amp;(rgProperties[iProp].vValue))=SysAllocString(wszBuff); <br>iProp++; <br>} <br> <br>// Set prompt level if one was given. <br>if (iPrompt != -1) <br>{ <br>rgProperties[iProp].dwPropertyID=DBPROP_INIT_PROMPT; <br>rgProperties[iProp].dwOptions=DBPROPOPTIONS_REQUIRED; <br>rgProperties[iProp].colid=DB_NULLID; <br>rgProperties[iProp].vValue.vt= VT_I2; <br>rgProperties[iProp].vValue.iVal= iPrompt; <br>iProp++; <br> <br>rgProperties[iProp].dwPropertyID=DBPROP_INIT_HWND; <br>rgProperties[iProp].dwOptions=DBPROPOPTIONS_REQUIRED; <br>rgProperties[iProp].colid=DB_NULLID; <br>rgProperties[iProp].vValue.vt= VT_I4; <br>rgProperties[iProp].vValue.lVal= (long) hWnd; <br>iProp++; <br>} <br> <br>if( iProp ) <br>{ <br>// Identify Property Set <br>rgPropertySet[0].rgProperties=rgProperties; <br>rgPropertySet[0].cProperties=iProp; <br>rgPropertySet[0].guidPropertySet=DBPROPSET_DBINIT; <br> <br>// from the DataSource Object get the Session Object <br>hr = pIDBInit-&gt;QueryInterface(  <br>IID_IDBProperties,  <br>(void**)&amp;pIDBProperties ); <br>if (FAILED(hr)) <br>{ <br>GetDetailedErrorInfo(hr, pIDBInit, IID_IDBInitialize, "QI for IDBProperties FAILED!!"); <br>goto error; <br>} <br> <br>// Set Connection Properties <br>hr = pIDBProperties-&gt;SetProperties(1, rgPropertySet); <br>if (FAILED(hr)) <br>{ <br>GetDetailedErrorInfo(hr, pIDBProperties, IID_IDBProperties, "IDBProperties-&gt;SetProperties FAILED!!"); <br>goto error; <br>} <br>}  <br> <br> // Initialize the PROVIDER <br>if( FAILED(hr = pIDBInit-&gt;Initialize()) ) <br>{ <br>        GetDetailedErrorInfo(hr, pIDBInit, IID_IDBInitialize, "IDBInit-&gt;Initialize FAILED!!"); <br>goto error; <br>} <br> <br>// from the DataSource Object get the Session Object <br>if( FAILED(hr = pIDBInit-&gt;QueryInterface(  <br>IID_IDBCreateSession,  <br>(void**)&amp;pIDBCreateSession)) ) <br>{ <br>GetDetailedErrorInfo(hr, pIDBInit, IID_IDBInitialize, "QI for IDBCreateSession FAILED!!"); <br>goto error; <br>} <br> <br>// from the Session object, attempt to get an IUnknown <br>if( FAILED(hr = pIDBCreateSession-&gt;CreateSession(NULL, IID_IUnknown, (IUnknown**)&amp;pIUnknown)) ) <br>{ <br>GetDetailedErrorInfo(hr, pIDBCreateSession, IID_IDBCreateSession, "IDBCreateSession-&gt;CreateSession FAILED!!"); <br>goto error; <br>} <br> <br>// from the Session object, attempt to get the IDBCreateCommand interface <br>if( FAILED(hr = pIUnknown-&gt;QueryInterface( <br>IID_IDBCreateCommand,  <br>(void**)&amp;pIDBCreateCommand)) ) <br>{ <br>// if no Command object support, attempt to get the IOpenRowset interface <br>hr = pIUnknown-&gt;QueryInterface( <br>IID_IOpenRowset,  <br>(void**)&amp;pIOpenRowset); <br>if (FAILED(hr)) <br>{ <br>        GetDetailedErrorInfo(hr, pIUnknown, IID_IUnknown, "QI for IOpenRowset FAILED!!"); <br>goto error; <br>} <br>} <br>else <br>{ <br>fCommandWindow = TRUE; <br>} <br> <br>// update the combo-box with IUnknown from Session object <br>wsprintf( szBuffer, PROVIDER_SESSION_FORMAT, (LPSTR)szProvName, pIUnknown ); <br> <br>nResult = (UINT)SendMessage(hWndCrsrList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndCrsrList, CB_SETCURSEL, (WPARAM)nResult, 0); <br>SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>ChangeCurrentCursor(hWndCrsrList); <br> <br>if (fCommandWindow) <br>{ <br>// Create a Command Object and its associated window. <br>NewICommandWindow(); <br>} <br>else <br>{ <br>NewIOpenRowsetWindow(); <br>} <br> <br>bReturn = TRUE; <br> <br>error: <br>if( pIMoniker ) <br>pIMoniker-&gt;Release(); <br> <br>// Initialize Property Buffers <br>for(iProp=0; iProp&lt;NUMELEM(rgProperties); iProp++) <br>VariantClear(&amp;(rgProperties[iProp].vValue)); <br> <br>// If we are successully connected, and the IParse pointer <br>// exists release it. <br>if( bReturn &amp;&amp; g_pIParse ) <br>{ <br>g_pIParse-&gt;Release(); <br>g_pIParse = NULL; <br>} <br> <br>// Release IUnknown (for Session) on error only. <br>// The pointer value has been copied to the window. <br>if( (!bReturn) &amp;&amp; (pIUnknown) ) <br>pIUnknown-&gt;Release(); <br> <br>if( (pIDBCreateCommand) ) <br>pIDBCreateCommand-&gt;Release(); <br> <br>if( (pIDBProperties) ) <br>pIDBProperties-&gt;Release(); <br> <br>if( (pIOpenRowset) ) <br>pIOpenRowset-&gt;Release(); <br> <br>if( pIDBCreateSession ) <br>pIDBCreateSession-&gt;Release(); <br> <br>if(pIDBInit) <br>pIDBInit-&gt;Release(); <br> <br>return (bReturn); <br> <br>}  <br> <br>//********************************************************************** <br>//  <br>// DisplayConnections <br>//  <br>// Purpose: <br>//  <br>//     Display list of available hdbc(s) in the given list box. <br>//      <br>// Parameters: <br>// <br>// HWND hWndhdbc               - handle to the window <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL DisplayConnections(HWND hWndhdbc) <br>{ <br>ULONG nConnects;// # of Connections <br>ULONG count;// Count <br>charszBuffer[MAXBUFLEN+1];// String Buffer <br> <br>// Read the information from the  combo-box  <br>// on the tool bar and feed it in the given list box. <br>SendMessage(hWndhdbc, LB_RESETCONTENT, 0, 0); <br>nConnects = SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0); <br> <br>for (count = 0; count &lt; nConnects; count++) <br>{ <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, count, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndhdbc, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>} <br> <br>SendMessage(hWndhdbc, LB_SETCURSEL, 0, 0); <br>} <br> <br>//********************************************************************** <br>//  <br>// DisplayICommands <br>//  <br>// Purpose: <br>//  <br>//     Initializes the PROVIDER and creates a ICommand Object. <br>//     Display list of ICommand Objects for the currently selected PROVIDER. <br>//      <br>// Parameters: <br>// <br>//  HWND hWndhdbc - handle to the PROVIDER <br>// HWND hWndhstmt                - handle to the ICommand <br>//int nCrsrIndex - Count <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL DisplayICommands(HWND hWndhstmt, HWND hWndhdbc, int nCrsrIndex) <br>{ <br>charszBuffer[MAXBUFLEN+1];// MDI child window title <br>HWNDhWndChild;// MDI child window handle <br>IDBCreateCommand * pIDBCreate1;// IDBCreateCommand Object #1 <br>IDBCreateCommand * pIDBCreate2;// IDBCreateCommand Object #2 <br>ICommand *pICommand;// ICommand Object <br> <br>// Reset the Command list box in the disconnect dialog box <br>SendMessage(hWndhstmt, LB_RESETCONTENT, 0, 0); <br> <br>// Go through all available MDI child windows and check if the <br>// PROVIDER in the title matches the one selected in the list box. <br>// If they match, use the Command in the window title to create <br>// a new entry in the Command list box. <br>for (hWndChild=GetWindow(hWndMDIClient, GW_CHILD); hWndChild; hWndChild=GetWindow(hWndChild, GW_HWNDNEXT)) <br>{ <br>// Class name check is necessary as some of MDI child <br>// windows may be iconized by the user and MDIClient <br>// in such cases create additional windows (such as icon titles). <br>GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br> <br>if (strcmp(szBuffer, OLEDBMDICLASS)) <br>continue; <br> <br>GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSIONCOMMAND_FORMAT, &amp;pIDBCreate1, &amp;pICommand); <br> <br>SendMessage(hWndhdbc, LB_GETTEXT, (WPARAM)nCrsrIndex, (LPARAM)(LPSTR)szBuffer); <br>sscanf(szBuffer, SCANSESSION_FORMAT, &amp;pIDBCreate2); <br> <br>if (pIDBCreate1 != pIDBCreate2) <br>continue; <br> <br>wsprintf(szBuffer, ((hWndChild == hWndActiveChild) ?  CURQUERY_STRING:QUERY_STRING), pICommand); <br>SendMessage(hWndhstmt, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>} <br>SendMessage(hWndhstmt, LB_SETSEL, TRUE, 0); <br>} <br> <br>//********************************************************************** <br>//  <br>// NewICommandWindow <br>//  <br>// Purpose: <br>//  <br>//     Create a new ICommand Object on the current IDBCreateCommand. <br>//      <br>// Parameters: <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                         Location <br>//  <br>//   IDBCreateCommand::CreateCommandprovider's Command object <br>//     ICommand::Release                provider's Command object <br>//     <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL NewICommandWindow() <br>{ <br>int nCurrenthdbc;// Current PROVIDER <br>charszBuffer[MAXBUFLEN+1];// String in PROVIDER ComboBox on Toolbar <br>charszProvName[MAXBUFLEN+1];// DSN String <br>MDICREATESTRUCTmcs;// MDI Child Window Create Struc <br> <br>IDBCreateCommand * pIDBCreateCommand= NULL;// IDBCreateCommand Object <br>IOpenRowset * pIOpenRowset= NULL;// IOpenRowset Object <br>ICommand *pICommand= NULL;// ICommand Object <br>ICommand *pIUnknown= NULL;// IUnknown for session Object <br>HRESULThr;// HRESULT <br>BOOLbReturn= FALSE;// Return Value <br> <br>         <br>// check if there is PROVIDER selected in the Combo-Box <br>if ((nCurrenthdbc = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0)) == CB_ERR) <br>{ <br>MessageBox(hWndFrame, MAKECONNECT, NOSESSIONERROR, MB_OK | MB_ICONHAND); <br>return; <br>} <br> <br>// check if the number of windows exceeds MAXCHILDWNDS <br>if (nChildCount &gt;= MAXCHILDWNDS) <br>{ <br>MessageBox(hWndFrame, MAXCHILDEXCEEDED, MAXCHLDERR, MB_OK | MB_ICONHAND); <br>return; <br>} <br> <br>// Scan PROVIDER string and IDBCreateCommand value from the combo-box <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, (WPARAM)nCurrenthdbc, (LPARAM)(LPSTR)szBuffer); <br> <br>sscanf(szBuffer, SCANPROVIDERSESSION_FORMAT, szProvName, &amp;pIUnknown); <br> <br>// from the Session object, attempt to get the IDBCreateCommand interface <br>hr = pIUnknown-&gt;QueryInterface( <br>IID_IDBCreateCommand,  <br>(void**)&amp;pIDBCreateCommand); <br>if (FAILED(hr)) <br>{ <br>// if no Command object support, attempt to get the IOpenRowset interface <br>hr = pIUnknown-&gt;QueryInterface( <br>IID_IOpenRowset,  <br>(void**)&amp;pIOpenRowset); <br>if (FAILED(hr)) <br>{ <br>    GetDetailedErrorInfo(hr, pIUnknown, IID_IUnknown, "QI for IOpenRowset FAILED!!"); <br>goto error; <br>} <br>} <br>else <br>{ <br>// Create a command object  <br>hr = pIDBCreateCommand-&gt;CreateCommand(NULL, IID_ICommand, (IUnknown**)&amp;pICommand); <br> <br>if (FAILED(hr)) <br>{ <br>       GetDetailedErrorInfo(hr, pIDBCreateCommand, IID_IDBCreateCommand, "pIDBCreateCommand-&gt;CreateCommand FAILED!!"); <br>   goto error; <br>} <br>} <br> <br> <br>// create a new MDI client window. maximized, if the previous is so. <br>mcs.szClass = OLEDBMDICLASS; <br>mcs.szTitle = UNTITLED; <br>mcs.hOwner  = hAppInstance; <br>mcs.style   = hWndActiveChild &amp;&amp; IsZoomed(hWndActiveChild) ? WS_MAXIMIZE : 0; <br>mcs.x = mcs.cx = mcs.y = mcs.cy = CW_USEDEFAULT; <br>hWndActiveChild = (HWND)(UINT)SendMessage(hWndMDIClient, WM_MDICREATE, 0, (LPARAM)(LPMDICREATESTRUCT)&amp;mcs); <br>         <br>    // check if it was created, if it wasn't free up resource and flag warning <br>    if (!hWndActiveChild) <br>    { <br>MessageBox(hWndFrame, CREATECHILDERR, EXECERROR, MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>goto error; <br>    } <br>         <br>// Display the Provider string, PROVIDER and IDBCreateCommand/IOpenRowset in the title <br>// of newly created window. Increment the child window counter <br> wsprintf(szBuffer, QUERY_STRING, pICommand); <br> <br>SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br> <br> wsprintf(szBuffer, PROVIDER_SESSION_COMMAND_FORMAT, (LPSTR)szProvName, pIUnknown, pICommand); <br> <br>SetWindowText(hWndActiveChild, szBuffer); <br>nChildCount++; <br> <br>// Update the Command Combo-Box on the tool bar. <br>ChangeCurrentICommand(hWndStmtList); <br>bReturn = TRUE; <br> <br>error: <br>// Note that we obtained pIUnknown (Session ptr) from the window. <br>// So we leave it alone. <br> <br>// Release ICommand on error only. <br>// The pointer value has been copied to the window. <br>if (pICommand &amp;&amp; !bReturn) <br>pICommand-&gt;Release(); <br> <br>if (pIDBCreateCommand) <br>pIDBCreateCommand-&gt;Release(); <br> <br>if (pIOpenRowset) <br>pIOpenRowset-&gt;Release(); <br>} <br> <br> <br> <br> <br>//********************************************************************** <br>//  <br>// ChangeCurrentCursor <br>//  <br>// Purpose: <br>//  <br>//     Change the displayed PROVIDER in the PROVIDER(s) combobox. <br>//     Also activate the appropriate MDI child window that <br>//     has the same PROVIDER as the new PROVIDER in the combobox. <br>// <br>// Parameters: <br>// <br>// HWND hWndCrsrList               - handle to the window <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL ChangeCurrentCursor(HWND hWndCrsrList) <br>{ <br>ULONGnNewhdbc;// New PROVIDER position <br>ULONGnConnects;// # of connections <br>ULONGnCount;// Counter <br>charszBuffer[MAXBUFLEN+1];// String Buffer <br>BOOLbChangedFocus;// Activate different MDI child <br>HWNDhWndChild;// MDI Child window <br>IDBCreateCommand* pIDBCreate1;// IDBCreateCommand #1 <br>IDBCreateCommand* pIDBCreate2;// IDBCreateCommand #2 <br>ICommand*pICommand;// ICommand Object <br> <br>// check to see if the current selection in the combo-box <br>// differs from the previous selection, if it is the same then <br>// simply return. Check is made by searching a marked string <br>// in the PROVIDER combobox. <br>nNewhdbc = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0); <br>nConnects = (int)SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0); <br> <br>for(nCount = 0; nCount &lt; nConnects; nCount++) <br>{ <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, nCount, (LPARAM)(LPSTR)szBuffer); <br>if (strstr(szBuffer, CUR_MARK)) <br>break; <br>} <br> <br>if (nCount == nNewhdbc) <br>return; <br> <br>// if there was a current marked hdbc in the combobox, remove the <br>// mark from the string and replace it in the combobox. <br>if (nCount != nConnects) <br>{ <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, nCount, (LPARAM)(LPSTR)szBuffer); <br>szBuffer[strlen(szBuffer)-2] = '\0'; <br>SendMessage(hWndCrsrList, CB_INSERTSTRING, nCount, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndCrsrList, CB_DELETESTRING, nCount+1, 0); <br>} <br> <br>// Create a new marked string with currently selected hdbc string in <br>// the combobox and replace it with the original. <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, nNewhdbc, (LPARAM)(LPSTR)szBuffer); <br>strcat(szBuffer, CUR_MARK); <br>SendMessage(hWndCrsrList, CB_INSERTSTRING, nNewhdbc, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndCrsrList, CB_DELETESTRING, nNewhdbc+1, 0); <br>SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br> <br>// Reset the ICommand combobox. Search through the MDI child windows <br>// and collect all ICommands from window titles that have the same <br>// PROVIDER value as the newly selected PROVIDER in the PROVIDER(s) combo-box above. <br>SendMessage(hWndStmtList, CB_RESETCONTENT, 0, 0); <br>for (bChangedFocus=FALSE, hWndChild=GetWindow(hWndMDIClient, GW_CHILD);hWndChild; hWndChild = GetWindow( <br>hWndChild, GW_HWNDNEXT)) </code></pre>
<p>
</p>
<pre><code>{ <br>// Check class name to skip iconized titles or other <br>// such non MDI Child windows <br>GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>if (strcmp(szBuffer, OLEDBMDICLASS)) <br>continue; <br> <br>GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSIONCOMMAND_FORMAT, &amp;pIDBCreate1, &amp;pICommand); <br> <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, (WPARAM)nNewhdbc, (LPARAM)(LPSTR)szBuffer); <br>sscanf(szBuffer, SCANSESSION_FORMAT, &amp;pIDBCreate2); <br> <br>if (pIDBCreate1 != pIDBCreate2) <br>continue; <br>                 <br>if (!bChangedFocus) <br>{ <br>            // If the first match is found, change the active window <br>        // and update the ICommand(s) combobox with a new entry that <br>        // has ICommand marked with current marker. <br>bChangedFocus = TRUE; <br>hWndActiveChild = hWndChild; <br>SendMessage(hWndMDIClient, WM_MDIACTIVATE, (WPARAM)hWndChild, 0); <br>wsprintf(szBuffer, CURQUERY_STRING, pICommand); <br>SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>} <br>else <br>{ <br>// simply add the ICommand in the ICommand(s) combobox. <br>wsprintf(szBuffer, QUERY_STRING, pICommand); <br>SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>} <br>} <br>} <br> <br>//********************************************************************** <br>//  <br>// ChangeCurrentICommand <br>//  <br>// Purpose: <br>//  <br>//     Change the current selection in the ICommand(s) combobox. <br>//     Update the current marker in the combobox and activate <br>//     proper MDI Child window. <br>// <br>// Parameters: <br>// <br>// HWND hWndStmtList               - handle to the window <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL ChangeCurrentICommand(HWND hWndStmtList) <br>{ <br>ULONGnNewICommand;// New Selection in Combo-Box <br>ULONG nICommands;// # of ICommands <br>ULONG nCount;// Counter <br>charszBuffer[MAXBUFLEN+1];// String Buffer <br>HWNDhWndChild;// MDI Child Window Handle <br>IDBCreateCommand* pIDBCreate1;// IDBCreateCommand Object #1 <br>IDBCreateCommand* pIDBCreate2;// IDBCreateCommand Object #2 <br>ICommand*pICommand1;// ICommand Object #1 <br>ICommand*pICommand2;// ICommand Object #2 <br> <br>// Find the index of new selection and total number of ICommand(s) <br>nNewICommand = (int)SendMessage(hWndStmtList, CB_GETCURSEL, 0, 0); <br>nICommands  = (int)SendMessage(hWndStmtList, CB_GETCOUNT,  0, 0); <br> <br>// Check if the current selection is same as previous one, if <br>// so simply return. Check for marker to determine previous selection <br>for(nCount = 0; nCount &lt; nICommands; nCount++) <br>{ <br>SendMessage(hWndStmtList, CB_GETLBTEXT, nCount, (LPARAM)(LPSTR)szBuffer); <br>if (strstr(szBuffer, CUR_MARK)) <br>break; <br>} <br> <br>if (nCount == nNewICommand) <br>return; <br> <br>// If a previous selection was found, remove current marker <br>// and update it in the ICommand(s) combobox. <br>if (nCount != nICommands) <br>{ <br>SendMessage(hWndStmtList, CB_GETLBTEXT, nCount, (LPARAM)(LPSTR)szBuffer); <br>szBuffer[strlen(szBuffer)-2] = '\0'; <br>SendMessage(hWndStmtList, CB_INSERTSTRING, nCount, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndStmtList, CB_DELETESTRING, nCount+1, 0); <br>} <br> <br>// Mark the current selection and update it in the ICommand(s) combobox <br>SendMessage(hWndStmtList, CB_GETLBTEXT, nNewICommand, (LPARAM)(LPSTR)szBuffer); <br>strcat(szBuffer, CUR_MARK); <br>SendMessage(hWndStmtList, CB_INSERTSTRING, nNewICommand, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndStmtList, CB_DELETESTRING, nNewICommand+1, 0); <br>SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br> <br>// Scan ICommand value and DSN value from current selection in <br>// PROVIDER(s) and ICommand(s) comboboxes. <br>sscanf(szBuffer, QUERY_STRING, &amp;pICommand1); <br> <br>SendMessage( hWndCrsrList, CB_GETLBTEXT,  <br>(UINT)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0), <br>(LPARAM)(LPSTR)szBuffer); <br> <br>sscanf(szBuffer, SCANSESSION_FORMAT, &amp;pIDBCreate1); <br> <br>// Go through list of MDI Child windows and match the ICommand and PROVIDER <br>// values. If a match if found (must be), activate the window <br>for (hWndChild=GetWindow(hWndMDIClient, GW_CHILD); hWndChild; hWndChild=GetWindow(hWndChild, GW_HWNDNEXT)) <br>{ <br>// Ignore non MDI child windows <br>GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>if (strcmp(szBuffer, OLEDBMDICLASS)) <br>continue; <br> <br>GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSIONCOMMAND_FORMAT, &amp;pIDBCreate2, &amp;pICommand2); <br> <br>if (pIDBCreate1 == pIDBCreate2 &amp;&amp; pICommand1 == pICommand2) <br>{ <br>hWndActiveChild = hWndChild; <br>SendMessage(hWndMDIClient, WM_MDIACTIVATE, (WPARAM)hWndChild, 0); <br>break; <br>} <br>} <br>} <br> <br>//********************************************************************** <br>//  <br>// DisplayNewCrsrAndICommand <br>//  <br>// Purpose: <br>//  <br>//     Change the current selection in the ICommand(s) combobox. <br>//     Update the current marker in the combobox and activate <br>//     proper MDI Child window. <br>// <br>// Parameters: <br>// <br>// HWND hWndStmtList               - handle to the window <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL DisplayNewCrsrAndICommand() <br>{ <br>ULONG nConnects;// # of PROVIDER(s) <br>ULONG nICommands;// # of ICommand(s) <br>ULONG nOldPROVIDER;// Prev selected PROVIDER in combobox <br>ULONGnOldICommand;// Prev selected ICommand in combobox <br>ULONGnIndex;// Counter <br>charszBuffer[MAXBUFLEN+1];// String Buffer <br>HWNDhWndChild;// MDI Child Window <br>IDBCreateCommand* pIDBCreate1;// IDBCreateCommand Object #1 <br>IDBCreateCommand* pIDBCreate2;// IDBCreateCommand Object #2 <br>ICommand*pICommand1;// ICommand Object #1 <br>ICommand*pICommand2;// ICommand Object #2 <br> <br>// Scan PROVIDER and ICommand values from newly selected window <br>GetWindowText(hWndActiveChild, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSIONCOMMAND_FORMAT, &amp;pIDBCreate1, &amp;pICommand1); <br> <br>// Search through list of PROVIDER(s) in PROVIDER combobox and find <br>// matching PROVIDER. remove marker from prev selection and add <br>// marker to the new selection. Update combobox accordingly. <br>nConnects = (int)SendMessage(hWndCrsrList, CB_GETCOUNT,  0, 0); <br>nOldPROVIDER   = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0); <br> <br>for(pIDBCreate2 = (IDBCreateCommand*)(nIndex = 0); pIDBCreate1 != pIDBCreate2; nIndex++) <br>{ <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>sscanf(szBuffer, SCANSESSION_FORMAT, &amp;pIDBCreate2); <br>} <br> <br>// Change in PROVIDER combobox required. <br>if (--nIndex != nOldPROVIDER) <br>{ <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, nOldPROVIDER, (LPARAM)(LPSTR)szBuffer); <br>szBuffer[strlen(szBuffer)-2] = '\0'; <br>SendMessage(hWndCrsrList, CB_INSERTSTRING, nOldPROVIDER, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndCrsrList, CB_DELETESTRING, nOldPROVIDER+1, 0); <br> <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>strcat(szBuffer, CUR_MARK); <br>SendMessage(hWndCrsrList, CB_INSERTSTRING, nIndex, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndCrsrList, CB_DELETESTRING, nIndex+1, 0); <br>SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br> <br>// Reset the ICommand(s) combobox, search through the list <br>// of MDI child windows and find all hstmt(s) associated to <br>// new PROVIDER. Build the new list of ICommand(s) for the ICommand <br>// combobox. Mark the one ICommand that matches the currently <br>// activated MDI child window. <br>SendMessage(hWndStmtList, CB_RESETCONTENT, 0, 0); <br>for (hWndChild=GetWindow(hWndMDIClient,GW_CHILD);hWndChild;hWndChild=GetWindow(hWndChild,GW_HWNDNEXT)) <br>{ <br>GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>if (strcmp(szBuffer, OLEDBMDICLASS)) <br>continue; <br> <br>GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSIONCOMMAND_FORMAT, &amp;pIDBCreate2, &amp;pICommand2); <br> <br>if (pIDBCreate1 != pIDBCreate2) <br>continue; <br> <br>if (hWndActiveChild == hWndChild) <br>{ <br>wsprintf(szBuffer, CURQUERY_STRING, pICommand2); <br>SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>} <br>else <br>{ <br>wsprintf(szBuffer, QUERY_STRING, pICommand2); <br>SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>} <br>} <br>} <br>// No change in PROVIDER combobox required <br>else <br>{ <br>// Go through the list of ICommand(s) in ICommand combobox. <br>// Find the one that matches the currently activated MDI child window. <br>nOldICommand = (int)SendMessage(hWndStmtList, CB_GETCURSEL, 0, 0); <br>nICommands = (int)SendMessage(hWndStmtList, CB_GETCOUNT, 0, 0); <br> <br>for(pICommand2 = (ICommand*)(nIndex = 0); pICommand1 != pICommand2; nIndex++) <br>{ <br>SendMessage(hWndStmtList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>sscanf(szBuffer, QUERY_STRING, &amp;pICommand2); <br>} <br> <br>// New index in ICommand differs from previous selection <br>if (--nIndex != nOldICommand) <br>{ <br>// Remove the marker from previous selection. <br>// Add it to the new string and update the combobox display <br>SendMessage(hWndStmtList, CB_GETLBTEXT, nOldICommand, (LPARAM)(LPSTR)szBuffer); <br>szBuffer[strlen(szBuffer)-2] = '\0'; <br>SendMessage(hWndStmtList, CB_INSERTSTRING, nOldICommand, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndStmtList, CB_DELETESTRING, nOldICommand+1, 0); <br> <br>SendMessage(hWndStmtList, CB_GETLBTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>strcat(szBuffer, CUR_MARK); <br>SendMessage(hWndStmtList, CB_INSERTSTRING, nIndex, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndStmtList, CB_DELETESTRING, nIndex+1, 0); <br>SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>} <br>} <br>} <br> <br>//********************************************************************** <br>//  <br>// FreeConnect <br>//  <br>// Purpose: <br>//  <br>//     Disconnect and Free the currently selected PROVIDER in <br>//     the PROVIDER listbox in disconnect dialog. Call RELEASE <br>//     to free the PROVIDER. Close all MDI <br>//     child windows associated with this PROVIDER. That will <br>//     automatically free associated ICommand(s). <br>// <br>// Parameters: <br>// <br>// HWND hWndhdbc               - handle to the window <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     IDBCreateCommand::Release   provider's Command object <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL FreeConnect(HWND hWndhdbc) <br>{ <br>int nIndex;// Current Selection in the listbox of disconnect dlg <br>intnCurrent;// Current Selected PROVIDER(s) combobox <br>charszBuffer[MAXBUFLEN+1];// String Buffer <br>charszSelect[MAXBUFLEN+1];// Original Selected PROVIDER(s) combobox <br>charszProvName[MAXBUFLEN+1];// DSN string <br>HWNDhWndChild;// MDI Child window <br>IDBCreateCommand * pIDBCreate1;// IDBCreateCmmand Object #1 <br>IDBCreateCommand * pIDBCreate2;// IDBCreateCmmand Object #2 <br>IErrorInfo *pIErrorInfo;// IErrorInfo Object <br> <br>// Check current selection in the list box of disconnect dialog.  <br>// Scan PROVIDER value from the current selection. <br>if ((nIndex = (int)SendMessage(hWndhdbc, LB_GETCURSEL, 0, 0)) == LB_ERR) <br>return; <br> <br>SendMessage(hWndhdbc, LB_GETTEXT, (WPARAM)nIndex, (LPARAM)(LPSTR)szBuffer); <br>sscanf(szBuffer, SCANPROVIDERSESSION_FORMAT, szProvName, &amp;pIDBCreate1); <br> <br>// Go through the list of MDI child windows and find matching PROVIDER(s) <br>// close all children who have the same PROVIDER value. Closing them <br>// automatically frees associated ICommands. See CloseICommandWindow. <br>for(hWndChild = GetWindow(hWndMDIClient, GW_CHILD); hWndChild; ) <br>{ <br>// Store next window handle before destroying the currentone <br>HWND hWndTemp = GetWindow(hWndChild, GW_HWNDNEXT); <br> <br>// Ignore non MDI child windows <br>GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>if (!strcmp(szBuffer, OLEDBMDICLASS)) <br>{ <br>GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSION_TITLEFORMAT, &amp;pIDBCreate2); <br>if (pIDBCreate1 == pIDBCreate2) <br>{ <br>// Destroy the window and restart search <br>SendMessage(hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChild, 0); <br>hWndTemp = GetWindow(hWndMDIClient, GW_CHILD); <br>} <br>} <br>hWndChild = hWndTemp; <br>} <br> <br>// Release the Command Object &amp; return <br>if( pIDBCreate1 ) <br>pIDBCreate1-&gt;Release(); <br> <br>// Release any remaining error objects.  This is idempotent. <br>// Otherwise the provider might have an outstanding global-object count. <br>GetErrorInfo( 0, &amp;pIErrorInfo ); <br>if (pIErrorInfo) <br>pIErrorInfo-&gt;Release(); <br> <br>// Unload any DLL's no longer being used <br>CoFreeUnusedLibraries(); <br> <br>// Update the PROVIDER(s) combobox display by removing the deleted PROVIDER <br>// from the list and reselecting the previous selection <br>wsprintf(szBuffer, PROVIDER_SESSION_FORMAT, (LPSTR)szProvName, pIDBCreate1); <br>nCurrent = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0); <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, nCurrent, (LPARAM)(LPSTR)szSelect); <br>nIndex = (int)SendMessage(hWndCrsrList, CB_FINDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndCrsrList, CB_DELETESTRING, (WPARAM)nIndex, 0); <br>SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szSelect); <br> <br>// If there is no query window open and the current selected PROVIDER <br>// was deleted, make sure to make the next available PROVIDER as current <br>if (SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0) &amp;&amp; <br>!GetWindow(hWndMDIClient, GW_CHILD) &amp;&amp; (nCurrent == nIndex)) <br>{ <br>if ((nCurrent = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0))!=CB_ERR) <br>return; <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, 0, (LPARAM)(LPSTR)szSelect); <br>strcat(szSelect, CUR_MARK); <br>SendMessage(hWndCrsrList, CB_INSERTSTRING, 0, (LPARAM)(LPSTR)szSelect); <br>SendMessage(hWndCrsrList, CB_DELETESTRING, 1, 0); <br>SendMessage(hWndCrsrList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szSelect); <br>} <br>} <br> <br>//********************************************************************** <br>//  <br>// FreeICommand <br>//  <br>// Purpose: <br>//  <br>//     Free a ICommand window based upon current selection in <br>//     ICommand list box in the disconnect dialog. <br>// <br>// Parameters: <br>// <br>// HWND hWndhstmt               - handle to the window <br>// HWND hWndhdbc                - handle to the window <br>//  int             nIndex- Index <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL FreeICommand(HWND hWndhstmt, HWND hWndhdbc, int nIndex) <br>{ <br>charszBuffer[MAXBUFLEN+1];// display buffer <br>HWNDhWndChild;// MDI child window <br>IDBCreateCommand* pIDBCreate1;// IDBCreateCommand Object #1 <br>IDBCreateCommand* pIDBCreate2;// IDBCreateCommand Object #2 <br>ICommand*pICommand1;// ICommand Object #1 <br>ICommand*pICommand2;// ICommand Object #2 <br> <br>// Scan the ICommand and PROVIDER values from the current selections in <br>// respective listboxes of disconnect dialog box. <br>SendMessage(hWndhstmt, LB_GETTEXT, nIndex, (LPARAM)(LPSTR)szBuffer); <br>sscanf(szBuffer, QUERY_STRING, &amp;pICommand1); <br>SendMessage(hWndhdbc, LB_GETTEXT, (UINT)SendMessage(hWndhdbc, LB_GETCURSEL,0, 0), (LPARAM)(LPSTR)szBuffer); <br>sscanf(szBuffer, SCANSESSION_FORMAT, &amp;pIDBCreate1); <br>         <br>    // Go through the list of MDI child windows and find matching window <br>    // that has same values for PROVIDER and ICommand. Destroy the matching window. <br>    // That will call CloseICommandWindow and free up associated ICommand(s). <br>for(hWndChild=GetWindow(hWndMDIClient, GW_CHILD); hWndChild; hWndChild=GetWindow(hWndChild, GW_HWNDNEXT)) <br>{ <br>// Ignore non MDI child windows <br>GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>if( strcmp(szBuffer, OLEDBMDICLASS) ) <br>continue; <br> <br>GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSIONCOMMAND_FORMAT, &amp;pIDBCreate2, &amp;pICommand2); <br>if (pIDBCreate1 == pIDBCreate2 &amp;&amp; pICommand1 == pICommand2) <br>break; <br>} <br>SendMessage(hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChild, 0); <br>} <br> <br>//********************************************************************** <br>//  <br>// CloseICommandWindow <br>//  <br>// Purpose: <br>//  <br>//     Close a ICommand window.  <br>//     Call ICommand-&gt;Release() to free associated ICommand(s). <br>// <br>// Parameters: <br>// <br>// HWND hWnd               - handle to the window <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     ICommand::Release           provider's Command object <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL CloseICommandWindow(HWND hWnd) <br>{ <br>charszBuffer[MAXBUFLEN+1];// String buffer <br>charszSelect[MAXBUFLEN+1];// Current Selected ICommand(s) <br>ICommand*pICommand;// ICommand Object <br> <br>// Scan the ICommand value from the window title <br>GetWindowText(hWnd, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANCOMMAND_TITLEFORMAT, &amp;pICommand); <br> <br>// Release the Command Object &amp; return <br>if( pICommand ) <br>pICommand-&gt;Release(); <br> <br>// Find the matching ICommand in the ICommand(s) combobox and remove it <br>// from the list. Closure of a MDI child window will cause MDIClient <br>// to automatically activate a different child window if available. <br>// That will automatically refresh the ICommand and PROVIDER displays.  <br>// See DisplayNewCrsrAndICommand function. <br>wsprintf( szBuffer, QUERY_STRING, pICommand ); <br> <br>SendMessage( hWndStmtList, CB_GETLBTEXT,  <br>(WPARAM)SendMessage(hWndStmtList, CB_GETCURSEL, 0, 0), <br>(LPARAM)(LPSTR)szSelect ); <br> <br>SendMessage( hWndStmtList, CB_DELETESTRING,  <br>(WPARAM)SendMessage(hWndStmtList, CB_FINDSTRING, 0, <br>(LPARAM)(LPSTR)szBuffer), 0 ); <br> <br>SendMessage( hWndStmtList, CB_SELECTSTRING, <br>(WPARAM)-1,  <br>(LPARAM)(LPSTR)szSelect ); <br> <br>// Decrement the child window counter. <br>nChildCount--; <br>} <br> <br>//********************************************************************** <br>//  <br>// ExecuteQuery <br>//  <br>// Purpose: <br>//  <br>//     Execute the user typed SQL Statements in the currently  <br>//     active MDI child window. If successful, then prepare <br>//     the list of results and display it in the child listbox. <br>//     Display errors in the OLE DB function(s) failed. <br>// <br>// Parameters: <br>// <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     ExecuteCommand              query.cpp <br>//     GetDataFromRowset           query.cpp <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL ExecuteQuery() <br>{ <br>CHARszBuffer[MAXBUFLEN+1];// String Buffer <br>WCHARwszBuffer[MAXBUFLEN+1];// String Buffer (WCHAR) <br>signed short intswColLength = MAXDATALEN;// Column Data Length <br>HCURSORhOldCursor;// Default Cursor Handle <br>IUnknown*pIUnknown = NULL;// Session Object <br>ICommand*pICommand = NULL;// ICommand Object <br>IOpenRowset*pIOpenRowset= NULL;// IOpenRowset Object <br>IRowset*pIRowset = NULL;// IRowset Object <br>HRESULThr;// HRESULT <br> <br>// Check if there is an active window available <br>if (!hWndActiveChild) <br>{ <br>MessageBox(hWndFrame, ((SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0) &lt;=0) ? <br>MAKECONNECT : OPENWINDOW ), NOCOMMANDERROR, MB_OK | MB_ICONHAND); <br>return; <br>} <br> <br>// Change cursor shape to hour glass <br>hOldCursor = SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT)); <br>         <br>// Scan PROVIDER, session and ICommand values <br>GetWindowText(hWndActiveChild, (char*)szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSIONCOMMAND_FORMAT, &amp;pIUnknown, &amp;pICommand); <br> <br>// Get the user typed SQL <br>GetWindowText(GetDlgItem((HWND)GetWindowLong(hWndActiveChild, GWLAPP_HDLG), IDTEXT_SQL), szBuffer, MAXBUFLEN); <br> <br>// Convert ANSI String to WCHARString <br>MultiByteToWideChar(CP_ACP, 0, szBuffer, -1, wszBuffer, MAXBUFLEN+1); <br> <br>// Execute the Command Object <br>hr = ExecuteCommand( pIUnknown, pICommand, wszBuffer, &amp;pIRowset );  <br> <br>if (FAILED(hr)) <br>return; <br> <br>// Empty IRowset <br>if( hr == ResultFromScode(S_FALSE) ) <br>{  <br>DumpErrorHResult( ResultFromScode(S_OK), (LPSTR)"ExecuteCommand returned No Rowset!!" ); <br>return; <br>} <br> <br>// Get Data from the IRowset Object <br>GetDataFromRowset( pIRowset ); <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// CloseIDBCreateCommand <br>//  <br>// Purpose: <br>//  <br>//     Go through all open PROVIDER's (IDBCreateCommand(s) and ICommand(s))  <br>//     and close them one by one. <br>// <br>// Parameters: <br>// <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     IDBCreateCommand::Release   provider's Command object <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>BOOL FAR PASCAL CloseIDBCreateCommand() <br>{ <br>ULONG nIndex;// Index <br>ULONGnCount;// # of PROVIDER(s) <br>charszBuffer[MAXBUFLEN+1];// String Buffer <br>HWNDhWndChild;// MDI Child Window <br>IDBCreateCommand* pIDBCreate1;// IDBCreateCommand Object #1 <br>IDBCreateCommand* pIDBCreate2;// IDBCreateCommand Object #2 <br> <br>// Get count of connected PROVIDER(s) from the PROVIDER(s) combobox on the toolbar <br>if (!(nCount = (int)SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0))) <br>return (TRUE); <br> <br>// Go through all available MDI child windows and for each PROVIDER, <br>// find the matching MDI child window and ask it for closure, thereby <br>// freeing the associated ICommand (see CloseICommandWindow). Once all <br>// associated ICommand(s) are freed, free the PROVIDER <br>for (nIndex = 0; nIndex &lt; nCount; nIndex++) <br>{        <br>// Scan current indexed PROVIDER from PROVIDER(s) combobox <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, (WPARAM)nIndex, (LPARAM)(LPSTR)szBuffer); <br>sscanf(szBuffer, SCANSESSION_FORMAT, &amp;pIDBCreate1); <br> <br>// Search through the list of MDI Child Windows <br>for(hWndChild = GetWindow(hWndMDIClient, GW_CHILD); hWndChild; ) <br>{ <br>// Store the next child, before destroying the current <br>HWND hWndTemp = GetWindow(hWndChild, GW_HWNDNEXT); <br> <br>// Ignore non MDI child windows <br>GetClassName(hWndChild, szBuffer, MAXBUFLEN); <br>if (!strcmp(szBuffer, OLEDBMDICLASS)) <br>{ <br>GetWindowText(hWndChild, szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSION_TITLEFORMAT, &amp;pIDBCreate2); <br>if (pIDBCreate1 == pIDBCreate2) <br>{ <br>// Destroy the window and restart search <br>SendMessage(hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChild, 0); <br>hWndTemp = GetWindow(hWndMDIClient, GW_CHILD); <br>} <br>} <br>hWndChild = hWndTemp; <br>} <br> <br>// Call IDBCreateCommand-&gt;Release()  <br>// to free the current IDBCreateCommand resource <br>if( pIDBCreate1 ) <br>pIDBCreate1-&gt;Release(); <br>} <br> <br>// Reset the PROVIDER(s) combobox display and display all connections <br>// closed message. Return success to let application exit. <br>SendMessage(hWndCrsrList, CB_RESETCONTENT, 0, 0); <br>MessageBox(hWndFrame, CLOSEALLSESSION, LOGOUTINFO,MB_OK | MB_ICONINFORMATION); <br>return (TRUE); <br>} <br> <br>/* <br>FUNCTION: FreeEnvironment() <br>COMMENTS: Free the OLE environment. <br>*/ <br>HRESULT FreeEnvironment() <br>{ <br>    HRESULThr = S_OK;// HRESULT <br>IErrorInfo*pIErrorInfo;//IErrorInfo <br> <br>    // Release the task memory allocator <br>if( g_pIMalloc ) <br>g_pIMalloc-&gt;Release(); <br> <br>// Release any remaining error objects.  This is idempotent. <br>// Otherwise the provider might have an outstanding global-object count. <br>GetErrorInfo( 0, &amp;pIErrorInfo ); <br>if (pIErrorInfo) <br>pIErrorInfo-&gt;Release(); <br> <br>// Free the error queues <br>SetErrorInfo(0,NULL); <br> <br>// Uninitialize OLE <br>CoUninitialize(); <br> <br>return hr; <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// ExecuteCommand <br>//  <br>// Purpose: <br>//  <br>//    Executes the query command that was previously set on the Command object, <br>//    and returns a first interface pointer on the resulting Rowset object. <br>//  <br>// Parameters: <br>//   IOpenRowset*pIOpenRowset- interface pointer to data provider's <br>//  IOpenRowset <br>//   ICommand*pICommand       - interface pointer on data provider's <br>//              Command object <br>//   LPWSTRwszBuffer- SQL-style query string to be sent <br>//              to the Command object or table/file name to <br>//  be sent to IOpenRowset <br>//   IRowset**ppIRowset_out   - out pointer through which to return  <br>//              interface pointer on provider's <br>//          Rowset object <br>//  <br>// Return Value: <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//      <br>//     ICommand::Execute           provider's Command object <br>//     IMalloc::Free               OLE task memory allocator <br>//      <br>//  <br>//     assert                      c runtime <br>//  <br>//  <br>//      <br>// Comments:       <br>//  <br>//     The interface pointer returned through ppIRowset_out has been AddRef'ed,  <br>//     it must be Release'd later by the caller. <br>// <br>//********************************************************************** <br>HRESULT ExecuteCommand( <br>IUnknown*pIUnknown,// Session object <br>ICommand*pICommand,// Command object <br>LPWSTR wszBuffer,// SQL String (WCHAR) or Table Name <br>IRowset**ppIRowset_out <br>) <br>{ <br>ICommandText*pICommandText = NULL;// ICommandText Object <br>IOpenRowset*pIOpenRowset = NULL; <br>DBIDTableID;// Table ID <br>HRESULThr = S_OK;// HRESULT <br> <br>// Asserts <br>assert(ppIRowset_out != NULL); <br>    assert(wszBuffer != NULL); <br> <br>memset(&amp;TableID, 0, sizeof(DBID)); <br> <br>// If no command object use IOpenRowset <br>if (NULL == pICommand) <br>{ <br>// if no Command object support, attempt to get the IOpenRowset interface <br>if( FAILED(hr = pIUnknown-&gt;QueryInterface(IID_IOpenRowset, (void**)&amp;pIOpenRowset)) ) <br>{ <br>        GetDetailedErrorInfo(hr, pIUnknown, IID_IUnknown, "QI for IOpenRowset FAILED!!"); <br>goto error; <br>} <br>// Pass in table/file name <br>TableID.eKind = DBKIND_NAME; <br> <br>TableID.uName.pwszName = wszBuffer; <br> <br>// From IOpenRowset, get a rowset object <br>if( FAILED(hr = pIOpenRowset-&gt;OpenRowset( <br>NULL,// pUnkOuter <br>&amp;TableID,// pTableID <br>NULL,// pIndexID <br>IID_IRowset,// refiid <br>0,// cProperties <br>NULL,// rgProperties <br> (IUnknown**)ppIRowset_out)) )  // IRowset pointer <br>{ <br>     GetDetailedErrorInfo(hr, pIOpenRowset, IID_IOpenRowset, "IOpenRowset-&gt;OpenRowset FAILED!!"); <br>goto error; <br>} <br>} <br>else <br>{ <br>// QueryInterface for ICommandText::SetCommandText <br>if( SUCCEEDED(hr = pICommand-&gt;QueryInterface(IID_ICommandText,(LPVOID*)&amp;pICommandText)) ) <br>{ <br>// Tell the command object to copy this command text <br>// The command object will then use this query when we call ICommand::Execute <br>if( FAILED(hr = pICommandText-&gt;SetCommandText(DBGUID_DBSQL, wszBuffer)) ) <br>{ <br>        GetDetailedErrorInfo(hr, pICommandText, IID_ICommandText, "ICommandText-&gt;SetCommandText FAILED!!"); <br>goto error; <br>} <br>} <br> <br>// From the command object, get a rowset object by executing command <br>if( FAILED(hr = pICommand-&gt;Execute( <br>NULL,// pUnkOuter <br>IID_IRowset,// refiid <br>NULL,// disp parms <br>NULL,// rows affected <br> (IUnknown**)ppIRowset_out)) )  // IRowset pointer <br>{ <br>GetDetailedErrorInfo(hr, pICommand, IID_ICommand, "ICommand-&gt;Execute FAILED!!"); <br>goto error; <br>} <br>} <br> <br>// NO Rowset Returning Statement <br>    if( !*ppIRowset_out ) <br>hr = ResultFromScode(S_FALSE); <br>error: <br>if( pICommandText ) <br>pICommandText-&gt;Release(); <br>if( pIOpenRowset ) <br>pIOpenRowset-&gt;Release(); <br> <br>if( FAILED(hr) ) <br>*ppIRowset_out = NULL; <br> <br>return hr;     <br>} <br> <br>//********************************************************************** <br>//  <br>// GetDataFromRowset <br>//  <br>// Purpose: <br>//  <br>//     Pulls the data from a Rowset object. <br>//      <br>// Parameters: <br>//  <br>// IRowset*pIRowset    -  interface pointer on data provider's <br>//                             Rowset object <br>//  <br>// Return Value: <br>//  <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//   IRowset::QueryInterface   Clients Rowset pointer <br>//     SetupBindings               query.cpp <br>//     CreateAccessor              query.cpp <br>//     GetData                     query.cpp <br>//     CleanupRowset               query.cpp <br>//  <br>//     IMalloc::Free               OLE task memory allocator <br>//  <br>//     assert                      c runtime <br>//  <br>// Comments:       <br>//  <br>//     At a high level, a consumer pulls the data from a Rowset object by: <br>//      <br>//     1. getting metadata for the Rowset's columns </code></pre>
<p>
</p>
<pre><code>//     2. using that metadata, along with the consumer's own knowledge of <br>//        how it wants to recieve the data, to create bindings. Bindings <br>//        represent how the actual data in the Rowset's columns is <br>//        actually transferred to the consumer's buffer. <br>//     3. pass the bindings to the Rowset, and get in return an accessor <br>//        handle that represents that particular set of bindings    <br>//     4. get the actual data <br>//     5. clean up the rowset (at a minumum, release the accessor)  <br>//      <br>//     GetDataFromRowset performs these steps by calling GetColumnsInfo, <br>//     SetupBindings, CreateAccessor, GetData, and CleanupRowset <br>//        <br>//********************************************************************** <br>HRESULT GetDataFromRowset( <br>IRowset*pIRowset <br>) <br>{ <br>charszBuffer[MAXBUFLEN+1];// String Buffer <br>HWNDhList;// Result Listbox Handle <br>DWORD dwText;// Tab Stop for Listbox <br>unsigned short intnCount;// Index <br>signed short intswColLength = MAXDATALEN;// Column Data Length <br>intcch;// Count of characters <br>HCURSORhOldCursor;// Default Cursor Handle <br>HRESULThr = S_OK;// HRESULTS <br>    ULONGcCol;// # of Columns in Rowset <br>    DBCOLUMNINFO*pColumnInfo;// Array of DBCOLUMNINFO <br>    WCHAR*pStringsBuffer;// Storage for strings <br> <br>// BINDINGS <br>ULONG cbMaxRowSize;// buffer size for 1 row's data <br>ULONG cBind; <br>DBBINDINGrgBind[MAX_COL]; <br> <br>// ACCESSORS <br>HACCESSORhAccessor= NULL; <br> <br>// Asserts <br>assert(pIRowset   != NULL); <br>assert(g_pIMalloc != NULL); <br> <br>// Change cursor shape to hour glass <br>hOldCursor = SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT)); <br> <br>// Get the Columns Info <br>GetColumnsInfo( pIRowset, &amp;cCol, &amp;pColumnInfo, &amp;pStringsBuffer); <br> <br>// Call GetColumnsInfo to calculate the number of columns in <br>// the result set, if more than the MAX_COL (the array boundary) <br>// limit the number to MAX_COL and display truncation warning. <br>// if it is 0, the statement probably was a non-SELECT simply return <br>if (cCol &gt;= MAX_COL) <br>{ <br>cCol = MAX_COL; <br>wsprintf(szDispBuffer, COLTRUNC_WARNG, MAX_COL); <br>MessageBox(hWndFrame, szDispBuffer, TRUNCERR, MB_OK | MB_ICONINFORMATION); <br>} <br>else if (cCol == 0) <br>{ <br>SetCursor(hOldCursor); <br>goto error; <br>} <br> <br>// Reset the display in the list box. Set tabstops to display <br>// multiple columns in the list box separated by tabs. <br>hList = GetDlgItem((HWND)GetWindowLong(hWndActiveChild, GWLAPP_HDLG), IDLIST_RSLT); <br> <br>SendMessage(hList, LB_RESETCONTENT, 0, 0); <br>SendMessage(hList, WM_SETREDRAW, FALSE, 0); <br>dwText = LISTTABSTOP; <br>SendMessage(hList, LB_SETTABSTOPS, (WPARAM)1, (LPARAM)(LPINT)&amp;dwText); <br> <br>// Display a description of each column in the result set.  <br>// Store the column name in the display buffer and make it <br>// the first entry in the results list box of the MDI child window. <br>for(nCount=0, szDispBuffer[0]='\0'; nCount &lt; cCol; nCount++) <br>{ <br>if (pColumnInfo[nCount].pwszName) <br>{ <br>cch = WideCharToMultiByte(CP_ACP, 0, pColumnInfo[nCount].pwszName, -1, szBuffer, MAXBUFLEN+1, NULL, NULL); <br> <br>// Truncate if needed. <br>// We should use GetTextExtents to determine width, but that's too complicated for now. <br>szBuffer[MAXCOLNAMELEN] = '\0'; <br> <br>// Might be empty string for column name. <br>if (cch) <br>strcat(szDispBuffer, szBuffer); <br>else <br>strcat(szDispBuffer, "&lt;EMPTY STRING&gt;"); <br>} <br>else <br>{ <br>// Missing the column name; it is unknown. <br>strcat(szDispBuffer, "&lt;NULL STRING&gt;"); <br>} <br> <br>dwText = strlen(szDispBuffer); <br>szDispBuffer[dwText++] = '\t'; <br>szDispBuffer[dwText] = '\0'; <br>} <br> <br>// NULL Terminate the Display Buffer <br>if (*szDispBuffer) <br>szDispBuffer[strlen(szDispBuffer)-1]='\0'; <br> <br>// ADD the Column Info to the Screen <br>SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)(LPSTR)szDispBuffer); <br> <br>// SetUp Bindings <br>if( FAILED(hr = SetupBindings( cCol, pColumnInfo, rgBind, &amp;cBind, &amp;cbMaxRowSize)) ) <br>goto error; <br> <br>// Create the Accessor <br>if( FAILED(hr = CreateAccessor( pIRowset, rgBind, cBind, &amp;hAccessor)) ) <br>goto error; <br> <br>// GetData <br>if( FAILED(hr = GetData( pIRowset, cbMaxRowSize, hAccessor, rgBind, cBind, pColumnInfo,  <br>cCol, hList, dwText, LB_ADDSTRING)) ) <br>goto error; <br> <br>// restore the cursor to default value <br>SetCursor(hOldCursor); <br>   <br>error:     <br>// Release the IColumnsInfo Object <br>if( pColumnInfo ) <br>g_pIMalloc-&gt;Free( pColumnInfo ); <br>if( pStringsBuffer ) <br>g_pIMalloc-&gt;Free( pStringsBuffer );     <br>     <br>// Clean-up the Rowset <br>CleanupRowset( pIRowset, hAccessor ); <br> <br>    return hr;     <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// GetColumnsInfo <br>//  <br>// Purpose: <br>//  <br>//     Get the Columns metadata back for the provider to setup the bundings.  <br>//      <br>// Parameters: <br>// <br>//IRowset*pIRowset- IRowset pointer to QI off of <br>// ULONG cCol                - number of columns in metadata <br>// DBCOLUMNINFO*pColumnInfo         - pointer to column metadata <br>// WCHAR*pStringsBuffer      - pointer through which to return <br>//                                        an array of string data, one <br>//                                        structure per column bound <br>//  <br>// Return Value: <br>//     S_OK         - Success <br>//     E_*          - Failure <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     assert                      c runtime <br>//     IRowset::QueryInterface     provider's Rowset object <br>//     IColumnsInfo::GetColumnInfo provider's ColumnInfo object <br>//     IColumnsInfo::Release       provider's ColumnInfo object <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>HRESULT GetColumnsInfo <br>( <br>IRowset*pIRowset, <br>ULONG* pcCol, <br>DBCOLUMNINFO**ppColumnInfo, <br>WCHAR**ppStringsBuffer <br>) <br>{ <br> <br>HRESULThr=NOERROR;// HRESULTS <br>IColumnsInfo* pIColumnsInfo = NULL;// IColumnsInfo Object <br> <br>// QI for IColumnsInfo Object <br>if( FAILED(hr = pIRowset-&gt;QueryInterface( IID_IColumnsInfo, (void **) &amp;pIColumnsInfo)) ) <br>{ <br>GetDetailedErrorInfo(hr, pIRowset, IID_IRowset, "QI for IColumnsInfo FAILED!!"); <br>goto error; <br>} <br> <br>// Get column information from the command object via IColumnsInfo::GetColumnsInfo  <br>if( FAILED(hr = pIColumnsInfo-&gt;GetColumnInfo( pcCol, ppColumnInfo, ppStringsBuffer)) ) <br>{ <br>GetDetailedErrorInfo(hr, pIColumnsInfo, IID_IColumnsInfo, "IColumnsInfo-&gt;GetColumnsInfo FAILED!!"); <br>goto error; <br>} <br> <br>error: <br>// Release the IColumnsInfo Object <br>if( pIColumnsInfo ) <br>pIColumnsInfo-&gt;Release(); <br>return hr; <br> <br>} <br> <br>//********************************************************************** <br>//  <br>// SetupBindings <br>//  <br>// Purpose: <br>//  <br>//     Creates bindings that map the data in the rowset's columns to  <br>//     slots in the consumer's data buffer. <br>//      <br>// Parameters: <br>// <br>// ULONG cCol                - number of columns in rowset to bind <br>// DBCOLUMNINFO*pColumnInfo         - pointer to column metadata <br>// DBBINDING*rgBind_out          - out pointer through which to return <br>//                                        an array of binding structures, one <br>//                                        structure per column bound <br>// ULONG*pcBind_out          - out pointer through which to return    <br>//                                        the number of columns bound (number <br>//                                        of valid elements in rgBind_out)               <br>// ULONG*pcMaxRowSize_out    - out pointer through which to return <br>//                                        the buffer size necessary to hold <br>//                                        the largest row data <br>//  <br>// Return Value: <br>//     S_OK         - Success <br>//     E_*          - Failure <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     assert                      c runtime <br>//  <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>HRESULT SetupBindings <br>( <br>ULONG cCol, <br>DBCOLUMNINFO*pColumnInfo, <br>DBBINDING*rgBind_out, <br>ULONG*pcBind_out, <br>ULONG*pcMaxRowSize_out <br>) <br>{ <br>#define DEFAULT_CBMAXLENGTH 80// cbMaxLength for binding <br>ULONG dwOffset;// Length of a Row <br>ULONG iCol;// Column Count <br>ULONG iBind;// Binding Index <br> <br>// Asserts <br>    assert(pColumnInfo!= NULL); <br>    assert(rgBind_out != NULL); <br>    assert(pcBind_out != NULL); <br>    assert(pcMaxRowSize_out != NULL); <br> <br>   // Create bindings. <br>// Bind everything as a string just to keep things simple. <br>dwOffset = 0; <br>iBind=0; <br>for (iCol=0; iCol &lt; cCol; iCol++) <br>{ <br>// Binding Structure <br>rgBind_out[iBind].dwPart= DBPART_VALUE | DBPART_LENGTH | <br>  DBPART_STATUS; <br>rgBind_out[iBind].eParamIO  = DBPARAMIO_NOTPARAM; <br>rgBind_out[iBind].iOrdinal= pColumnInfo[iCol].iOrdinal; <br>rgBind_out[iBind].wType     = DBTYPE_WSTR; <br>rgBind_out[iBind].pTypeInfo = NULL; <br>rgBind_out[iBind].obValue   = dwOffset + offsetof(COLUMNDATA,bData); <br>rgBind_out[iBind].obLength  = dwOffset + offsetof(COLUMNDATA,dwLength); <br>rgBind_out[iBind].obStatus  = dwOffset + offsetof(COLUMNDATA,wStatus); <br> <br>// If columns information is a STR, double buffer and  <br>// add space for terminator <br>if( ((pColumnInfo[iCol].wType == DBTYPE_STR) || <br> (pColumnInfo[iCol].wType == DBTYPE_WSTR)) &amp;&amp;  <br>(pColumnInfo[iCol].ulColumnSize != 0xffffffff) ) <br>rgBind_out[iBind].cbMaxLen = (pColumnInfo[iCol].ulColumnSize + sizeof(CHAR)) * 2; <br>else <br>rgBind_out[iBind].cbMaxLen = DEFAULT_CBMAXLENGTH; <br>rgBind_out[iBind].pObject= NULL; <br>rgBind_out[iBind].pBindExt= NULL; <br>rgBind_out[iBind].dwFlags= 0; <br>rgBind_out[iBind].dwMemOwner = DBMEMOWNER_CLIENTOWNED; <br>rgBind_out[iBind].bPrecision = 0; <br>rgBind_out[iBind].bScale= 0; <br> <br>// LONG DATA hack  <br>if(rgBind_out[iBind].cbMaxLen &gt; 1000) <br>rgBind_out[iBind].cbMaxLen = 1000; <br> <br>dwOffset += rgBind_out[iBind].cbMaxLen + offsetof( COLUMNDATA, bData ); <br>dwOffset = ROUND_UP( dwOffset, COLUMN_ALIGNVAL ); <br>iBind++; <br>}   <br> <br>// Return Values     <br>*pcBind_out   = iBind; <br>*pcMaxRowSize_out = dwOffset; <br> <br>return S_OK; <br>} <br> <br> <br> <br>//********************************************************************** <br>//  <br>// CreateAccessor <br>//  <br>// Purpose: <br>// <br>//     Passes a set of bindings to the data provider and recieves in return <br>//     an accessor handle that represents those bindings.  <br>//       <br>// Parameters: <br>// IRowset*pIRowset        - interface pointer on data provider's Rowset <br>//                                object <br>// DBBINDING*rgBind          - array of binding structures <br>// ULONGcBind           - number of binding structures in rgBind <br>// HACCESSOR*phAccessor_out  - out pointer through which to return an  <br>//                                accessor handle that represents all the bindings <br>//                                in rgBind <br>//  <br>// Return Value: <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     IRowset::QueryInterface     provider's Rowset object <br>//     IAccessor::CreateAccessor   provider's Rowset object <br>//     IAccessor::Release          provider's Rowset object <br>//  <br>//     assert                      c runtime <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>HRESULT CreateAccessor <br>( <br>IRowset*pIRowset, <br>DBBINDING*rgBind, <br>ULONGcBind, <br>HACCESSOR*phAccessor_out  <br>) <br>{ <br>IAccessor*pIAccessor = NULL; <br>HRESULT hr; <br> <br>// Asserts <br>assert(pIRowset   != NULL); <br>    assert(rgBind   != NULL); <br>    assert(phAccessor_out != NULL); <br> <br>  // Get an accessor for our bindings from the rowset, via IAccessor  <br>if( FAILED(hr = pIRowset-&gt;QueryInterface( IID_IAccessor, (void**)&amp;pIAccessor)) ) <br>{ <br>GetDetailedErrorInfo(hr, pIRowset, IID_IRowset, "QI for IAccessor FAILED!!"); <br>goto error; <br>} <br> <br>if( FAILED(hr = pIAccessor-&gt;CreateAccessor( <br>DBACCESSOR_ROWDATA,  <br>cBind,  <br>rgBind,  <br>0,  <br>phAccessor_out, <br>NULL)) ) <br>{ <br>GetDetailedErrorInfo(hr, pIAccessor, IID_IAccessor, "IAccessor-&gt;CreateAccessor FAILED!!"); <br>goto error; <br>} <br> <br>hr = S_OK; <br> <br>error: <br>if (pIAccessor) <br>    pIAccessor-&gt;Release(); <br> <br>if( FAILED(hr) ) <br>*phAccessor_out = NULL; <br> <br>return hr; <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// GetData <br>//  <br>// Purpose: <br>//  <br>//     Reads the data from a rowset. <br>//  <br>// Parameters: <br>// <br>//    IRowset* pIRowset           - interface pointer on data provider's <br>//                                    Rowset object <br>//    ULONG    cMaxRowSize        - size of buffer needed to hold the data <br>//                                    for the largest row <br>//     HACCESSOR hAccessor          - accessor handle representing the set <br>//                                    of desired bindings <br>//     DBBINDING*rgBind  - needed only for pretty printing <br>//     ULONGcBind  - for pretty printing   <br>//     DBCOLUMNINFO*pColumnInfo - for pretty printing   <br>//     ULONGcCol- for pretty printing   <br>//  <br>//  <br>// Return Value: <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//  <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     IRowset::GetNextRows        provider's Rowset object <br>//     IRowset::GetData            provider's Rowset object <br>//     IRowset::ReleaseRows        provider's Rowset object <br>//  <br>//  <br>//     malloc, free                c runtime <br>//     assert                      c runtime <br>//  <br>//  <br>//      <br>// Comments:       <br>// <br>//     GetData reads all the rows in the rowset, sequentially. <br>//   <br>//  <br>//********************************************************************** <br>HRESULT GetData <br>( <br>IRowset*pIRowset, <br>ULONG   cMaxRowSize, <br>    HACCESSOR   hAccessor, <br>    DBBINDING*rgBind,     <br>    ULONGcBind,     <br>    DBCOLUMNINFO*pColumnInfo,   <br>    ULONGcCol, <br>HWNDhList, <br>DWORDdwText, <br>DWORDaddString <br>) <br>{ <br>#define NUMROWS_CHUNK       20// Number of Rows to Grab at a Time <br> <br>ULONG cRowsObtained;// Number of rows obtained <br>ULONGiRow;// Row Count <br>BYTE*pRowData = NULL;// Memory for Data <br>HROW rghRows[NUMROWS_CHUNK];// Row Handles <br>HROW*pRows = &amp;rghRows[0];// Pointer to the Row Handles <br>ULONGcMaxColWidth = MAXCOLNDATALENGTH; // Needed for Output <br>HRESULT hr;// HRESULT <br> <br>// Asserts <br>assert(pIRowset != NULL); <br>    assert(rgBind != NULL); <br>    assert(pColumnInfo  != NULL); <br> <br>// Create a buffer for row data, big enough to hold the biggest row <br>pRowData = (BYTE *) malloc( cMaxRowSize ); <br>if (!pRowData) <br>        goto error; <br> <br>    // Process all the rows, NUMROWS_CHUNK rows at a time <br>while (1) <br>{ <br>if( FAILED(hr = pIRowset-&gt;GetNextRows( <br>0,// cbChapter <br>0,// cRowsToSkip <br>NUMROWS_CHUNK,// cRowsDesired <br>&amp;cRowsObtained,// cRowsObtained <br>&amp;pRows)) )// filled in w/ row handles <br>{ <br>    GetDetailedErrorInfo(hr, pIRowset, IID_IRowset, "IRowset-&gt;GetNextRows FAILED!!"); <br>goto error; <br>} <br> <br>// All done, no more rows left to get <br>if ( cRowsObtained == 0 ) <br>break; <br> <br>// Loop over rows obtained, getting data for each <br>for ( iRow=0; iRow &lt; cRowsObtained; iRow++ ) <br>{ <br>if( FAILED(hr = pIRowset-&gt;GetData( <br>rghRows[iRow], <br>hAccessor, <br>pRowData)) ) <br>{ <br>                GetDetailedErrorInfo(hr, pIRowset, IID_IRowset, "IRowset-&gt;GetData FAILED!!"); <br>goto error; <br>} <br> <br> <br>// Print to the Screen <br>            DumpRow( rgBind, cBind, cMaxColWidth, pRowData, hList, dwText, addString ); <br> <br>// See if you are over the limit of rows <br>if ((iRow + 1) == MAX_ROW) <br>{ <br>wsprintf(szDispBuffer, ROWTRUNC_WARNG, MAX_ROW); <br>MessageBox(hWndFrame, szDispBuffer, TRUNCERR, MB_OK | MB_ICONINFORMATION); <br>break; <br>} <br> <br>} <br> <br>// Release row handles <br>if( FAILED(hr = pIRowset-&gt;ReleaseRows( cRowsObtained, rghRows, NULL, NULL, NULL)) ) <br>{ <br>           GetDetailedErrorInfo(hr, pIRowset, IID_IRowset, "IRowset-&gt;ReleaseRows FAILED!!"); <br>   goto error; <br>} <br> <br>}// end while <br> <br>hr = S_OK; <br>error: <br>// Set the horizontal scroll extent in the list box and ask for repaint. <br>SendMessage(hList, LB_SETHORIZONTALEXTENT, (WPARAM)(cBind*LISTHORZSCROLL+LISTHORZEXT), 0); <br>SendMessage(hList, WM_SETREDRAW, TRUE, 0); <br> <br>if( cRowsObtained ) <br>pIRowset-&gt;ReleaseRows( cRowsObtained, rghRows, NULL, NULL, NULL); <br> <br>if( pRowData ) <br>free( pRowData ); <br>     <br>    return hr; <br>} <br> <br>//********************************************************************** <br>//  <br>// GetSchemaRowset <br>//  <br>// Purpose: <br>//  <br>//     Pulls the schema info out of the provider. <br>//      <br>// Parameters: <br>//  <br>// GUID  rguidSchema    -  SchemaRowset IID <br>// <br>// <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                      Location <br>//  <br>//   IDBCreateCommand::QueryInterface   QI <br>//   IDBSchemaRowset-&gt;GetRowset  Clients Rowset pointer <br>//     GetDataFromRowset                 query.cpp <br>//  <br>//     IMalloc::Free                 OLE task memory allocator <br>//  <br>//     assert                        c runtime <br>//  <br>// Comments:       <br>//  <br>//        <br>//********************************************************************** <br>void FAR PASCAL GetSchemaRowset(GUID rguidSchema) <br>{ <br>charszBuffer[MAXBUFLEN+1];// String Buffer <br>HCURSORhOldCursor;// Default Cursor Handle <br>IDBCreateCommand* pIDBCreate  = NULL;// IDBCreateCommand Object <br>IDBSchemaRowset*pIDBSchemaRowset = NULL;// SchemaRowset Object <br>ICommand*pICommand = NULL;// Command Object <br>IRowset*pIRowset = NULL;// Rowset Object <br>HRESULThr;// HRESULT <br> <br>// Check if there is an active window available <br>if( !hWndActiveChild ) <br>{ <br>MessageBox( hWndFrame,  <br>((SendMessage(hWndCrsrList, CB_GETCOUNT, 0, 0) &lt;=0) ? <br>MAKECONNECT : OPENWINDOW ),  <br>NOCOMMANDERROR, MB_OK | MB_ICONHAND); <br>return; <br>} <br> <br>// Change cursor shape to hour glass <br>hOldCursor = SetCursor(LoadCursor((HINSTANCE)NULL, IDC_WAIT)); <br>         <br>// Scan hdbc, hstmt values <br>GetWindowText(hWndActiveChild, (char*)szBuffer, MAXBUFLEN); <br>sscanf(szBuffer, SCANSESSIONCOMMAND_FORMAT, &amp;pIDBCreate, &amp;pICommand); <br> <br>// QueryInterface for IDBSession::IDBSchemaRowset <br>hr = pIDBCreate-&gt;QueryInterface( IID_IDBSchemaRowset, <br>(LPVOID*)&amp;pIDBSchemaRowset ); <br> <br>if (FAILED(hr)) <br>{ <br>        GetDetailedErrorInfo(hr, pIDBCreate, IID_IDBCreateCommand, "QI for IDBScemaRowset FAILED!!"); <br>goto error; <br>} <br> <br>// Get a SchemaRowset back <br>hr = pIDBSchemaRowset-&gt;GetRowset( <br>NULL,// punkOuter <br>rguidSchema,// schema IID <br>0L,// # of restrictions <br>NULL,// array of restrictions <br>IID_IRowset,// rowset interface <br>0L,// # of properties <br>NULL,// properties <br>(IUnknown**)&amp;pIRowset);// rowset pointer <br> <br>if (FAILED(hr)) <br>{ <br>        GetDetailedErrorInfo(hr, pIDBSchemaRowset, IID_IDBSchemaRowset, "IDBSchemaRowset-&gt;GetRowset FAILED!!"); <br>goto error; <br>} <br> <br>// Get Data from the IRowset Object <br>hr = GetDataFromRowset( pIRowset ); <br> <br>if (FAILED(hr)) <br>{ <br>//DumpErrorHResult( hr, (LPSTR)"GetDataFromRowset returned error!!" ); <br>goto error; <br>} <br> <br>// Release Object <br>pIDBSchemaRowset-&gt;Release(); <br>    pIDBSchemaRowset = NULL; <br> <br>return; <br> <br>error:     <br>if( pIDBSchemaRowset ) <br>pIDBSchemaRowset-&gt;Release(); <br> <br>return; <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// CleanupRowset <br>//  <br>// Purpose: <br>// <br>//     Allows the rowset to perform any necessary cleanup. <br>//   <br>// Parameters: <br>// <br>// IRowset*pIRowset    - interface pointer on data provider's Rowset <br>//                            object <br>// HACCESSOR hAccessor   - accessor handle to release <br>//  <br>// Return Value: <br>// <br>//     S_OK        - Success <br>//     E_*         - Failure <br>//      <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     IRowset::QueryInterface     provider's Rowset object <br>//     IAccessor::ReleaseAccessor  provider's Rowset object <br>//     IAccessor::Release          provider's Rowset object <br>//  <br>//     assert                      c runtime <br>//  <br>//      <br>// Comments:       <br>// <br>//     In this sample, the only cleanup that the rowset needs to do is <br>//     release the accessor handle.  <br>//  <br>//********************************************************************** <br>HRESULT CleanupRowset <br>( <br>IRowset*pIRowset, <br>HACCESSOR hAccessor <br>) <br>{ <br>IAccessor*pIAccessor = NULL;// Pointer to an Accessor <br>HRESULThr;// HRESULT <br> <br>// Assert     <br>    assert(pIRowset != NULL); <br>     <br>if( hAccessor ) <br>{ <br>// Tell the rowset object it can release the accessor, via IAccessor <br>hr = pIRowset-&gt;QueryInterface( IID_IAccessor, (void**)&amp;pIAccessor ); <br> <br>if (FAILED(hr)) <br>{ <br>GetDetailedErrorInfo(hr, pIRowset, IID_IRowset, "QI for IAccessor FAILED!!"); <br>goto error; <br>} <br> <br>hr = pIAccessor-&gt;ReleaseAccessor( hAccessor, NULL ); <br>if (FAILED(hr)) <br>{ <br>GetDetailedErrorInfo(hr, pIAccessor, IID_IAccessor, "IAccessor-&gt;ReleaseAccessor FAILED!!"); <br>goto error; <br>} <br> <br>pIAccessor-&gt;Release(); <br>pIAccessor = NULL; <br>} <br> <br>pIRowset-&gt;Release(); <br>pIRowset = NULL; <br> <br>return S_OK; <br>     <br>error:     <br>if( pIAccessor ) <br>    pIAccessor-&gt;Release(); <br>if( pIRowset ) <br>pIRowset-&gt;Release(); <br> <br>    return hr;     <br>} <br> <br> <br>//********************************************************************** <br>//  <br>// DumpRow <br>//  <br>// Purpose: <br>// <br>//     Display the row to the screen. <br>//   <br>// Parameters: <br>// <br>//  <br>// Return Value: <br>// <br>//      <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     assert                      c runtime <br>//  <br>//      <br>// Comments:       <br>// <br>//  <br>//********************************************************************** <br>void DumpRow <br>( <br>    DBBINDING* rgBind, <br>    ULONGcBind, <br>    ULONGcMaxColWidth, <br>    BYTE* pData, <br>HWNDhList, <br>DWORDdwText, <br>DWORDaddString <br>    ) <br>{ <br>ULONG iBind;// Binding Count <br>    COLUMNDATA*pColumn;// Data Structure <br>intcb; <br>CHARszTempString[MAXDISPLAYSIZE+1];// Temporary Display Buffer, used to check data length <br> <br>// Asserts <br>assert(rgBind); <br>assert( offsetof(COLUMNDATA, wStatus) == 0); <br>     <br>// Print each column we're bound to. <br>for (iBind=0, szDispBuffer[0]='\0'; iBind &lt; cBind; iBind++) <br>{ <br>// Columns are bound differently; not so easy. <br>// Print out to at least DEFAULT_CBMAXLENGTH width (pretty), <br>// Limit to first dwLength characters. <br>pColumn = (COLUMNDATA *) (pData + rgBind[iBind].obStatus); <br> <br>// Check Status for NULL / OK / CANTCONVERT. <br>switch (pColumn-&gt;wStatus) <br>{ <br>case DBSTATUS_S_ISNULL: <br>strcat(szDispBuffer, (LPSTR)"&lt;NULL&gt;"); <br>break; <br>case DBSTATUS_S_OK: <br>// Truncate if needed. <br>// - calculate number of bytes needed <br>cb = WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pColumn-&gt;bData, -1, <br>NULL, 0, NULL, NULL); <br>if( cb &gt; MAXCOLNDATALENGTH ) <br>{ <br>cb = WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pColumn-&gt;bData, -1, <br>szTempString, MAXCOLNDATALENGTH, NULL, NULL); <br> <br>szTempString[MAXCOLNDATALENGTH] = '\0';   <br>strcat(szTempString, "..."); <br>} <br>else <br>{ <br>cb = WideCharToMultiByte(CP_ACP, 0, (LPWSTR)pColumn-&gt;bData, -1, <br>szTempString, (MAXDISPLAYSIZE+1), NULL, NULL); <br>} <br> <br>strcat(szDispBuffer,szTempString); <br>        break; <br> <br>case DBSTATUS_E_CANTCONVERTVALUE: <br>strcat(szDispBuffer, "&lt;can't convert value&gt;"); <br>break; <br>default: <br>{ <br>CHAR szChar[10] = ""; <br>strcat(szDispBuffer, "&lt;unknown status of "); <br>strcat(szDispBuffer, itoa(pColumn-&gt;wStatus, szChar, 10)); <br>strcat(szDispBuffer, "&gt;"); <br>} <br>break; <br>} <br> <br>dwText = strlen(szDispBuffer); <br>szDispBuffer[dwText++] = '\t'; <br>szDispBuffer[dwText] = '\0'; <br>} <br>// Take the last \t off the end <br>szDispBuffer[--dwText] = '\0'; <br>SendMessage(hList, addString, 0, (LPARAM)(LPSTR)szDispBuffer); <br> <br>}     <br> <br>//********************************************************************** <br>//  <br>// GetDetailedErrorInfo <br>//  <br>// Purpose: <br>// <br>//    Reads error from the error collection and displays it in messageboxes <br>//   <br>// Parameters: <br>// <br>// HRESULThr- OLE DB HRESULT <br>// IUnknown*  pBadObject       - Object that caused an error <br>//  GUIDIID_BadInterface    - Interface that contains method that caused the error <br>// LPSTR lpStrBuffer- Title Bar text <br>// <br>// Return Value: <br>//      <br>// Comments:       <br>// If any sort of failure is encountered the return values will be NULL <br>//   strings. Therefore no extended error info will be printed. <br>//********************************************************************** <br> <br>HRESULT GetDetailedErrorInfo  <br>    ( <br>HRESULThresult,  <br>IUnknown*pBadObject,                   <br>GUIDIID_BadIntereface,                  <br>LPSTRlpStrBuffer <br>) <br>{ <br>IErrorInfo *        pErrorInfo = NULL;  <br>IErrorInfo *    pErrorInfoRec = NULL; <br>IErrorRecords *     pErrorRecords = NULL; <br>ISupportErrorInfo * pSupportErrorInfo = NULL; <br>HRESULT             hr = S_OK; <br>ULONG               i,ulNumErrorRecs; <br>BSTRbstrDescriptionOfError = NULL; <br>BSTRbstrSourceOfError = NULL; <br>CHAR                szBuffer [512];  //Error Info Buffer <br>    <br>// Check to see if this interface posts error messages <br>if( SUCCEEDED( pBadObject-&gt;QueryInterface(IID_ISupportErrorInfo,  <br>(LPVOID FAR*)&amp;pSupportErrorInfo)) )  <br>{ <br>if( pSupportErrorInfo-&gt;InterfaceSupportsErrorInfo(IID_BadIntereface) == S_OK ) <br>{ <br>//Get Error Object. Return if no object Exists <br>if( !SUCCEEDED(hr = GetErrorInfo(0,&amp;pErrorInfo)) ) <br>   goto DisplayHResult; <br> <br>// If returned a NULL error Object, then just display HR <br>if( pErrorInfo == NULL ) <br>goto DisplayHResult; <br> <br>//Get the IErrorRecord interface and get the count of error recs. <br>if( FAILED(hr = pErrorInfo-&gt;QueryInterface(IID_IErrorRecords,(LPVOID FAR*)&amp;pErrorRecords)) ) <br>   goto DisplayHResult; <br> <br>//Retrieve the number of Error Records <br>if( FAILED(hr = pErrorRecords-&gt;GetRecordCount(&amp;ulNumErrorRecs)) ) <br>   goto DisplayHResult; <br> <br>//Go through and print messages <br>for(i=0; i&lt;ulNumErrorRecs; i++)  <br>{ <br>if( FAILED(hr = pErrorRecords-&gt;GetErrorInfo(i, GetUserDefaultLCID(), &amp;pErrorInfoRec)) ) <br>goto Exit; <br>if( FAILED(hr = pErrorInfoRec-&gt;GetDescription(&amp;bstrDescriptionOfError)) ) <br>goto Exit; <br>if( FAILED(hr = pErrorInfoRec-&gt;GetSource(&amp;bstrSourceOfError)) ) <br>goto Exit; <br> <br>sprintf(szBuffer, "HResult of 0x%0x (%ld) returned\nError Source: %S\nError Description: %S\n",  <br>(long)hresult,(long)hresult,  <br>bstrSourceOfError ? bstrSourceOfError : L"No Source Description", <br>bstrDescriptionOfError ? bstrDescriptionOfError : L"No Error Description"); <br> <br>MessageBox( NULL, (LPCTSTR)szBuffer, lpStrBuffer, MB_OK); <br> <br>if (pErrorInfoRec)     <br>{ <br>pErrorInfoRec-&gt;Release(); <br>pErrorInfoRec = NULL; <br>} <br>if( bstrSourceOfError ) <br>{ <br>SysFreeString(bstrSourceOfError); <br>bstrSourceOfError = NULL; <br>} <br>if( bstrDescriptionOfError ) <br>{ <br>SysFreeString(bstrDescriptionOfError); <br>bstrDescriptionOfError = NULL; <br>} <br>} <br> <br>// if we've process all the records we can go to end <br>goto Exit; <br> <br>} //S_OK <br>} //if (SUCCEEDED) <br> <br>DisplayHResult: <br>// In some error cases we may not have extended error information and it still would be good to <br>// post the error HRESULT <br>sprintf(szBuffer, "HResult of 0x%0x (%ld) returned, no Extended Error Information posted or supported",  <br>(long)hresult,(long)hresult); <br>MessageBox( NULL, (LPCTSTR)szBuffer, lpStrBuffer, MB_OK); <br> <br> Exit :  <br>if (pErrorInfo) <br>pErrorInfo-&gt;Release(); <br>if (pErrorRecords) <br>pErrorRecords-&gt;Release(); <br>if( pSupportErrorInfo ) <br>pSupportErrorInfo-&gt;Release(); <br>if( pErrorInfoRec ) <br>pErrorInfoRec-&gt;Release(); <br>if( bstrSourceOfError ) <br>SysFreeString(bstrSourceOfError); <br>if( bstrDescriptionOfError ) <br>SysFreeString(bstrDescriptionOfError); <br> <br> return hr; <br>} //PrintErrorInfo <br> <br> <br>//********************************************************************** <br>//  <br>// DumpErrorHResult <br>//  <br>// Purpose: <br>// <br>//     Dump the OLE DB HRESULT in a Message Box with a text Title Bar. <br>//   <br>// Parameters: <br>// <br>// HRESULThr    - OLE DB HRESULT <br>// <br>// LPSTR lpStrBuffer - Title Bar text <br>// <br>//  <br>// Return Value: <br>// <br>//      <br>// Function Calls: <br>//     Function                    Location <br>//  <br>//     assert                      c runtime <br>//  <br>//      <br>// Comments:       <br>// <br>//  <br>//********************************************************************** <br>void DumpErrorHResult( HRESULT hr, LPSTR lpStrBuffer ) </code></pre>
<p>
</p>
<pre><code>{ <br>LPVOIDlpMessageBuffer; <br> <br>if(0 != FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>FORMAT_MESSAGE_FROM_SYSTEM, <br>NULL, <br>hr, <br>GetUserDefaultLCID(), <br>(LPSTR)&amp;lpMessageBuffer, <br>0, <br>NULL)) <br>{ <br>MessageBox( NULL, (LPCTSTR)lpMessageBuffer, lpStrBuffer, MB_OK); <br>LocalFree(lpMessageBuffer); <br>} <br>else <br>{ <br>lpMessageBuffer = LocalAlloc(LPTR, 256); <br> <br>if( lpMessageBuffer ) <br>{ <br>sprintf((LPSTR)lpMessageBuffer, "HResult of %ld returned", (long)hr); <br>MessageBox( NULL, (LPCTSTR)lpMessageBuffer, lpStrBuffer, MB_OK); <br>LocalFree(lpMessageBuffer); <br>} <br>} <br>} <br> <br>//********************************************************************** <br>//  <br>// NewIOpenRowsetWindow <br>//  <br>// Purpose: <br>//  <br>//     Create a new ICommand Object on the current IDBCreateCommand. <br>//      <br>// Parameters: <br>//  <br>// Return Value: <br>//  <br>// Function Calls: <br>//     Function                         Location <br>//  <br>//   IDBCreateCommand::CreateCommandprovider's Command object <br>//     ICommand::Release                provider's Command object <br>//     <br>//      <br>// Comments:       <br>//  <br>//  <br>//********************************************************************** <br>void FAR PASCAL NewIOpenRowsetWindow() <br>{ <br>int nCurrenthdbc;// Current PROVIDER <br>charszBuffer[MAXBUFLEN+1];// String in PROVIDER ComboBox on Toolbar <br>charszProvName[MAXBUFLEN+1];// DSN String <br>MDICREATESTRUCTmcs;                    // MDI Child Window Create Struc <br> <br>IOpenRowset * pIOpenRowset= NULL;// IOpenRowset Object <br> <br>         <br>// check if there is PROVIDER selected in the Combo-Box <br>if ((nCurrenthdbc = (int)SendMessage(hWndCrsrList, CB_GETCURSEL, 0, 0)) == CB_ERR) <br>{ <br>MessageBox(hWndFrame, MAKECONNECT, NOSESSIONERROR, MB_OK | MB_ICONHAND); <br>return; <br>} <br> <br>// check if the number of windows exceeds MAXCHILDWNDS <br>if (nChildCount &gt;= MAXCHILDWNDS) <br>{ <br>MessageBox(hWndFrame, MAXCHILDEXCEEDED, MAXCHLDERR, MB_OK | MB_ICONHAND); <br>return; <br>} <br> <br>// Scan PROVIDER string and IDBCreateCommand value from the combo-box <br>SendMessage(hWndCrsrList, CB_GETLBTEXT, (WPARAM)nCurrenthdbc, (LPARAM)(LPSTR)szBuffer); <br> <br> sscanf(szBuffer, SCANPROVIDERSESSION_FORMAT, szProvName, &amp;pIOpenRowset); <br> <br>// create a new MDI client window. maximized, if the previous is so. <br>mcs.szClass = OLEDBMDICLASS; <br>mcs.szTitle = UNTITLED; <br>mcs.hOwner  = hAppInstance; <br>mcs.style   = hWndActiveChild &amp;&amp; IsZoomed(hWndActiveChild) ? WS_MAXIMIZE : 0; <br>mcs.x = mcs.cx = mcs.y = mcs.cy = CW_USEDEFAULT; <br>hWndActiveChild = (HWND)(UINT)SendMessage(hWndMDIClient, WM_MDICREATE, 0, (LPARAM)(LPMDICREATESTRUCT)&amp;mcs); <br>         <br>    // check if it was created, if it wasn't free up resource and flag warning <br>    if (!hWndActiveChild) <br>    { <br>MessageBox(hWndFrame, CREATECHILDERR, EXECERROR, MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>return; <br>    } <br>         <br>// Display the Provider string, PROVIDER and IOpenRowset in the title <br>// of newly created window. Increment the child window counter <br>wsprintf(szBuffer, QUERY_STRING, pIOpenRowset); <br> <br>SendMessage(hWndStmtList, CB_ADDSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br>SendMessage(hWndStmtList, CB_SELECTSTRING, 0, (LPARAM)(LPSTR)szBuffer); <br> <br>wsprintf(szBuffer, PROVIDER_SESSION_COMMAND_FORMAT, (LPSTR)szProvName, pIOpenRowset, NULL); <br> <br>SetWindowText(hWndActiveChild, szBuffer); <br>nChildCount++; <br> <br>// Update the Command Combo-Box on the tool bar. <br>ChangeCurrentICommand(hWndStmtList); <br>} <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
