<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPICSR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5106"></a>CPICSR.C</h2>
<pre><code>/* CPICSR.C */ <br>/* (C) COPYRIGHT DATA CONNECTION LIMITED 1993 */ <br> <br>/*****************************************************************************/ <br>/* Change History                                                            */ <br>/*                                                                           */ <br>/*       30/06/93 NGR Created.                                               */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/*                                                                           */ <br>/* ROUTINE : CPICSR                                                          */ <br>/*                                                                           */ <br>/* FUNCTION: This file contains the main routines for CPI-C versions of the  */ <br>/*           send and receive TPs.                                           */ <br>/*           sending and receiving TPs SENDTP and RECVTP                     */ <br>/*                                                                           */ <br>/* INPUTS  : C:\CPICSEND.CFG (file) (documented below)                       */ <br>/*           C:\CPICRECV.CFG (file) (documented below)                       */ <br>/*           Note files are in executable's directory in WIN32               */ <br>/*                                                                           */ <br>/* OUTPUTS : CPICSEND.OUT                                                    */ <br>/*           CPICRECV.OUT                                                    */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br>/*****************************************************************************/ <br>/* Configuration files:                                                      */ <br>/*                                                                           */ <br>/* Configuration file is C:\CPICSEND.CFG or CPICRECV.CFG which contains      */ <br>/* the following, one per line in any order. If not present then the given   */ <br>/* default is assumed.                                                       */ <br>/*                                                                           */ <br>/* ResultFile = &lt;Name of file for results, default C:\CPIC(SEND/RECV).OUT&gt;   */ <br>/* NumConversations = &lt;Number of conversations to be done, default = 1&gt;      */ <br>/* LocalTPName = &lt;Name to be used for TP started, default SENDTP/RECVTP&gt;     */ <br>/* WaitMode = Yes/No/Block (default = No)                                    */ <br>/*            Yes      - Verbs are non-blocking but completed via CMWAIT     */ <br>/*            No       - Verbs are completed via posted Windows messages     */ <br>/*            Block    - All verbs are blocking                              */ <br>/*                                                                           */ <br>/* The following only apply to CPICSEND:                                     */ <br>/* SymDestName = &lt;symbolic destination name, default = CPICRECV&gt;             */ <br>/* NumSends = &lt;number of CMSEND verbs per conversation, default = 2&gt;         */ <br>/* ConfirmEvery = &lt;number of CMSEND verbs between CMCFMs, default = 1&gt;       */ <br>/* SendSize = &lt;number of bytes per CMSEND, default = 1024&gt;                   */ <br>/*                                                                           */ <br>/* The following only applies to CPICRECV:                                   */ <br>/* LocalTPName = &lt;Name to be used for CMSLTP verb, default CPICRECV          */ <br>/*                                                                           */ <br>/* If NumConversations is zero, then the TPs will do an infinite number of   */ <br>/* conversations.                                                            */ <br>/* If NumSends is zero, then CPICSEND will never CMDEAL the first            */ <br>/* conversation.                                                             */ <br>/* If ConfirmEvery is zero, then SENDTP will not issue CONFIRM verbs.        */ <br>/*****************************************************************************/ <br> <br>#if (defined(WINDOWS)||defined(WIN32)) <br>#include &lt;windows.h&gt; <br>HINSTANCE hInst; <br>#endif <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;wincpic.h&gt; <br>#include "cpicsr.h" <br> <br> <br>/*****************************************************************************/ <br>/* WinMain - reads initialisation info and controls message loop             */ <br>/*           NT and Win16 version                                            */ <br>/*****************************************************************************/ <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                   LPSTR lpCmdLine, int nCmdShow) <br>{ <br> <br>  MSG msg; <br> <br>  hInst = hInstance; <br> <br>  ReadConfig(); <br> <br>  if (!InitialiseWinMain(hInstance)) <br>  { <br>     return (FALSE); <br>  } <br> <br>  InitialiseMain(); <br> <br>  while(GetMessage(&amp;msg,NULL,0,0)) <br>  { <br>     TranslateMessage(&amp;msg); <br>     DispatchMessage(&amp;msg); <br>  } <br> <br>  return msg.wParam;         /* save exit parameter for return               */ <br> <br>} <br> <br>/*****************************************************************************/ <br>/* InitialiseWinMain - does the windows bits of initialisation               */ <br>/*****************************************************************************/ <br>BOOL InitialiseWinMain(HINSTANCE hInstance) <br>{ <br>   WCPICDATA CPICData; <br>   WNDCLASS class; <br>   #define WinCPICVERSION  0x0001 <br> <br>   /**************************************************************************/ <br>   /* Startup WinAPPC                                                        */ <br>   /**************************************************************************/ <br>   if (WinCPICStartup(WinCPICVERSION,&amp;CPICData)) <br>   { <br>      return (FALSE); <br>   } <br> <br>   if ( (ASYNC_COMPLETE = <br>         RegisterWindowMessage(WIN_CPIC_ASYNC_COMPLETE_MESSAGE)) == 0 ) <br>   { <br>      return (0); <br>   } <br> <br>   /**************************************************************************/ <br>   /* Register Window Class for our icon                                     */ <br>   /**************************************************************************/ <br> <br>   class.style = 0; <br>   class.lpfnWndProc   = (WNDPROC)TPWndProc; <br>   class.cbClsExtra    = (DWORD)0; <br>   class.cbWndExtra    = (DWORD)0; <br>   class.hInstance     = hInstance; <br>   class.hIcon         = LoadIcon(hInstance,"MainIcon"); <br>   class.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>   class.hbrBackground = GetStockObject(WHITE_BRUSH); <br>   class.lpszMenuName  = (LPSTR) NULL; <br>   class.lpszClassName = (LPSTR) "CPICSR\0"; <br> <br>   if (!RegisterClass(&amp;class)) <br>   { <br>     return (FALSE); <br>   } <br> <br>   /**************************************************************************/ <br>   /* Create the window                                                      */ <br>   /**************************************************************************/ <br>#ifdef CPICSEND <br>   sprintf(title,"CPI-C Send TP\0"); <br>#else <br>   sprintf(title,"CPI-C Receive TP\0"); <br>#endif <br> <br>   if ((hWndMain = CreateWindow("CPICSR\0",        /* window class           */ <br>       title,                                      /* window name            */ <br>       WS_MINIMIZE|WS_OVERLAPPEDWINDOW,            /* window style           */ <br>       0,                                          /* x position             */ <br>       0,                                          /* y position             */ <br>       10,                                         /* width                  */ <br>       10,                                         /* height                 */ <br>       NULL,                                       /* parent handle          */ <br>       NULL,                                       /* menu or child ID       */ <br>       hInstance,                                  /* instance               */ <br>       NULL))                                      /* additional info        */ <br>       == NULL) <br>   { <br>      return (FALSE); <br>   } <br> <br>   ShowWindow(hWndMain, SW_MINIMIZE); <br> <br>   /**************************************************************************/ <br>   /* Specify the window handle to be used, if this is NULL then we must use */ <br>   /* Wait_For_Conversation to wait for the verb to complete.                */ <br>   /**************************************************************************/ <br>   xchwnd((wait_mode || blocking) ? NULL : hWndMain, &amp;return_code); <br>#ifndef CPICSEND <br>   /**************************************************************************/ <br>   /* Specify our local TP name. Note that because we have done this, the    */ <br>   /* cmaccp will return asynchronously using the current notification type  */ <br>   /**************************************************************************/ <br>   { <br>      CM_INT32 temp_length; <br>      CM_INT32 temp_return_code; <br>      temp_length = strlen(LocalTPName); <br>      cmsltp(LocalTPName,&amp;temp_length,&amp;temp_return_code); <br>   } <br>#endif <br> <br>   return(TRUE); <br> <br>} <br> <br>/*****************************************************************************/ <br>/* Window proc for the iconised window                                       */ <br>/*****************************************************************************/ <br>LONG FAR PASCAL TPWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br>{ <br>   if (message == ASYNC_COMPLETE) <br>   { <br>      return_code = (CM_RETURN_CODE) wParam; <br>      IssueNextVerb(); <br>   } <br>   else <br>   { <br>      switch (message) <br>      { <br>         case WM_CREATE: <br>            /*****************************************************************/ <br>            /* Post a message to ourselves to kick off the first verb        */ <br>            /*****************************************************************/ <br>            PostMessage(hWnd, ASYNC_COMPLETE, 0, 0); <br>            break; <br> <br>         case WM_QUERYOPEN: <br>            /*****************************************************************/ <br>            /* Prevent the window being opened                               */ <br>            /*****************************************************************/ <br>            break; <br> <br>         case WM_CLOSE: <br>            TPDead = TRUE; <br>            WinCPICCleanup(); <br>            OutputResults(); <br>            return DefWindowProc(hWnd, message, wParam, lParam); <br>            break; <br> <br>         case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>         default: <br>            return DefWindowProc(hWnd, message, wParam, lParam); <br>            break; <br>      } <br>   } <br>   return 0l; <br>} <br> <br>/*****************************************************************************/ <br>/* InitialiseMain - blanks out variables and allocates buffers.              */ <br>/*****************************************************************************/ <br>void InitialiseMain() <br>{ <br>   TPDead = FALSE; <br>   FirstConv = TRUE; <br>   last_verb = 0; <br>   ConvCount = 0; <br> <br>   DataPtr = malloc((size_t) SendSize); <br>#ifdef CPICSEND <br>   GenerateData(); <br>   SendCount = 0; <br>   ConfirmCount = 0; <br>#else <br>   Deallocated = FALSE; <br>#endif <br> <br>   ResultBuf = (NumConversations == 0) ? <br>               NULL : malloc(NumConversations * sizeof(RESULT)); <br>   ResultPtr = ResultBuf; <br> <br>} <br> <br>/*****************************************************************************/ <br>/* IssueNextVerb - looks at the verb which has just completed and does the   */ <br>/*                 next one                                                  */ <br>/*****************************************************************************/ <br>void IssueNextVerb() <br>{ <br>   unsigned char wait_conv_ID[8]; <br>   CM_INT32 wait_return_code; <br>   /**************************************************************************/ <br>   /* last_verb = 0 is special case, before any verb has been issued.        */ <br>   /**************************************************************************/ <br>   if (last_verb != 0) <br>   { <br>      ProcessReturns(); <br>   } <br>   if (!TPDead) <br>   { <br>      switch (last_verb) <br>      { <br>         case 0x0000: <br>#ifdef CPICSEND <br>            NewConversation(); <br>            Do_cminit(); <br>#else <br>            Do_cmaccp(); <br>#endif <br>            break; <br> <br>#ifdef CPICSEND <br>         case C_INIT: <br>            /*****************************************************************/ <br>            /* Set the processing mode for this conversation to non-blocking */ <br>            /* we have already used xchwnd to set the window handle (or to   */ <br>            /* NULL it for WAIT mode)                                        */ <br>            /*****************************************************************/ <br>            { <br>               CM_INT32 receive_type = (blocking) ? CM_BLOCKING : <br>                                                    CM_NON_BLOCKING ; <br>               CM_INT32 temp_return_code; <br>               cmspm(conversation_ID, &amp;receive_type, &amp;temp_return_code); <br>            } <br>            /*****************************************************************/ <br>            /* Set the sync level for this conversation                      */ <br>            /*****************************************************************/ <br>            { <br>               CM_INT32 sync_level; <br>               CM_INT32 temp_return_code; <br>               sync_level = (ConfirmEvery == 0) ? CM_NONE : CM_CONFIRM; <br>               cmssl(conversation_ID, &amp;sync_level, &amp;temp_return_code); <br>            } <br>            Do_cmallc(); <br>            break; <br> <br>         case C_ALLC: <br>            Do_cmsend(); <br>            break; <br> <br>         case C_SEND: <br>            SendCount++; <br>            ConfirmCount++; <br>            if ((NumSends != 0) &amp;&amp; (SendCount == NumSends)) <br>            { <br>               Do_cmdeal(); <br>            } <br>            else if ((ConfirmEvery != 0) &amp;&amp; (ConfirmCount == ConfirmEvery)) <br>            { <br>               Do_cmcfm(); <br>            } <br>            else <br>            { <br>               Do_cmsend(); <br>            } <br>            break; <br> <br>         case C_CFM: <br>            ConfirmCount=0; <br>            Do_cmsend(); <br>            break; <br> <br>         case C_DEAL: <br>            if ((NumConversations !=0) &amp;&amp; (ConvCount == NumConversations)) <br>            { <br>               NewConversation(); <br>               TPDead = TRUE; <br>            } <br>            else <br>            { <br>#if 0 <br>            /*****************************************************************/ <br>            /* Enable this to check Startup/Cleanup in loop                  */ <br>            /*****************************************************************/ <br>     WCPICDATA CPICData; <br>  WinCPICCleanup(); <br>  WinCPICStartup(WinCPICVERSION,&amp;CPICData); <br>#endif <br>               NewConversation(); <br>               Do_cminit(); <br>            } <br>            break; <br> <br>#else <br>         case C_ACCP: <br>            NewConversation(); <br>            Do_cmrcv(); <br>            break; <br> <br>         case C_RCV: <br>            if (return_code == CM_DEALLOCATED_NORMAL) <br>            { <br>               if ((NumConversations != 0) &amp;&amp; (ConvCount &lt; NumConversations)) <br>               { <br>                  Do_cmaccp(); <br>               } <br>               else <br>               { <br>                  NewConversation(); <br>                  TPDead = TRUE; <br>               } <br>            } <br>            else if (status_received == CM_CONFIRM_RECEIVED) <br>            { <br>               Do_cmcfmd(); <br>               Deallocated = FALSE; <br>            } <br>            else if (status_received == CM_CONFIRM_DEALLOC_RECEIVED) <br>            { <br>               Do_cmcfmd(); <br>               Deallocated = TRUE; <br>            } <br>            else <br>            { <br>               Do_cmrcv(); <br>            } <br>            break; <br> <br>         case C_CFMD: <br>            if (Deallocated) <br>            { <br>               if ((NumConversations != 0) &amp;&amp; (ConvCount &lt; NumConversations)) <br>               { <br>                  Do_cmaccp(); <br>               } <br>               else <br>               { <br>                  NewConversation(); <br>                  TPDead = TRUE; <br>               } <br>            } <br>            else <br>            { <br>               Do_cmrcv(); <br>            } <br>            break; <br> <br>#endif <br> <br>         default: <br>            /*****************************************************************/ <br>            /* What is this verb then ??                                     */ <br>            /*****************************************************************/ <br>            TPDead = TRUE; <br>#ifdef WIN32 <br>            DebugBreak(); <br>#endif <br>            break; <br> <br>      } /* last_verb switch */ <br> <br>   } /* TPDead after previous verb */ <br>   if (!TPDead) <br>   { <br>      /***********************************************************************/ <br>      /* If the verb just issued has already completed, then post ourselves  */ <br>      /* a message to kick off the next verb.                                */ <br>      /* Otherwise, if the async mode being used is WAIT, then issue a       */ <br>      /* Wait_For_Conversation verb and then post ourselves a message        */ <br>      /* If the async mode is POST then WinCPIC will post a message for us   */ <br>      /***********************************************************************/ <br>      if (return_code != CM_OPERATION_INCOMPLETE) <br>      { <br>         PostMessage(hWndMain, ASYNC_COMPLETE, (WPARAM)return_code, <br>                                      (LPARAM)((void FAR *)&amp;conversation_ID)); <br>      } <br>      else if (wait_mode) <br>      { <br>         cmwait(wait_conv_ID, &amp;return_code, &amp;wait_return_code); <br>         /********************************************************************/ <br>         /* We don't bother checking the wait_conv_ID since we only have one */ <br>         /* conversation in progress.                                        */ <br>         /********************************************************************/ <br>         PostMessage(hWndMain, ASYNC_COMPLETE, (WPARAM)return_code, <br>                                      (LPARAM)((void FAR *)&amp;conversation_ID)); <br>      } <br>   } <br>   else <br>   { <br>      /***********************************************************************/ <br>      /* If we have finished then post ourselves a close message. Note that  */ <br>      /* WinCPICCleanup will be done in the WM_CLOSE processing, so that the */ <br>      /* case where the user closes the application prematurely is caught    */ <br>      /***********************************************************************/ <br>      PostMessage(hWndMain, WM_CLOSE, 0, 0); <br>   } <br>} /* Issue next verb */ <br> <br>#ifdef CPICSEND <br>void Do_cminit() <br>{ <br>   cminit(conversation_ID,SymDestName,&amp;return_code); <br>   last_verb = C_INIT; <br>} <br> <br>void Do_cmallc() <br>{ <br>   cmallc(conversation_ID,&amp;return_code); <br>   last_verb = C_ALLC; <br>} <br> <br>void Do_cmdeal() <br>{ <br>   cmdeal(conversation_ID,&amp;return_code); <br>   last_verb = C_DEAL; <br>} <br> <br>void Do_cmsend() <br>{ <br>   cmsend(conversation_ID,DataPtr,&amp;SendSize,&amp;request_to_send_received, <br>                                                                 &amp;return_code); <br>   last_verb = C_SEND; <br>} <br> <br>void Do_cmcfm() <br>{ <br>   cmcfm(conversation_ID,&amp;request_to_send_received,&amp;return_code); <br>   last_verb = C_CFM; <br>} <br> <br>#else <br> <br>void Do_cmaccp() <br>{ <br>   cmaccp(conversation_ID,&amp;return_code); <br>   last_verb = C_ACCP; <br>} <br> <br>void Do_cmrcv() <br>{ <br>   cmrcv(conversation_ID,DataPtr,&amp;SendSize,&amp;data_received,&amp;received_length, <br>                      &amp;status_received,&amp;request_to_send_received,&amp;return_code); <br>   last_verb = C_RCV; <br>} <br> <br>void Do_cmcfmd() <br>{ <br>   cmcfmd(conversation_ID,&amp;return_code); <br>   last_verb = C_CFMD; <br>} <br>#endif <br> <br>/*****************************************************************************/ <br>/* ProcessReturns - Checks return codes from the last verb to complete and   */ <br>/*                  saves off any useful information. If the return code is  */ <br>/*                  bad then we just die.                                    */ <br>/*****************************************************************************/ <br>void ProcessReturns() <br>{ <br>   if ( (return_code != CM_OK) &amp;&amp; <br>       !( (last_verb == C_RCV) &amp;&amp; <br>          (return_code == CM_DEALLOCATED_NORMAL) ) ) <br>   { <br>      TPDead = TRUE; <br>   } <br>} <br> <br>/*****************************************************************************/ <br>/* ReadConfig - Reads config info from SENDTP.CFG also allocates buffer for  */ <br>/*              sending                                                      */ <br>/*****************************************************************************/ <br>void ReadConfig() <br>{ <br>   char buffer[200]; <br> <br>#ifdef CPICSEND <br> <br>   if (!ReadString("ResultFile",FileName,20)) <br>   { <br>      strcpy(FileName,"C:\\CPICSEND.OUT"); <br>   } <br>   if (!ReadString("SymDestName",SymDestName,8)) <br>   { <br>      strcpy(SymDestName,"CPICRECV"); <br>   } <br>   NumSends=2; <br>   if (ReadString("NumSends",buffer,200)) <br>   { <br>      NumSends=atoi(buffer); <br>   } <br>   ConfirmEvery=1; <br>   if (ReadString("ConfirmEvery",buffer,200)) <br>   { <br>      ConfirmEvery=atoi(buffer); <br>   } <br>   SendSize=1024; <br>   if (ReadString("SendSize",buffer,200)) <br>   { <br>      SendSize=atoi(buffer); <br>   } <br> <br>#else <br> <br>   SendSize = 0x7FFF; <br>   if (!ReadString("ResultFile",FileName,20)) <br>   { <br>      strcpy(FileName,"C:\\CPICRECV.OUT"); <br>   } <br>   if (!ReadString("LocalTPName",LocalTPName,64)) <br>   { <br>      strcpy(LocalTPName,"CPICRECV"); <br>   } <br> <br>#endif <br> <br>   wait_mode = FALSE;                                                  /*BLOK*/ <br>   blocking  = FALSE;                                                  /*BLOK*/ <br>   if (ReadString("WaitMode",buffer,200))                              /*BLOK*/ <br>   {                                                                   /*BLOK*/ <br>      wait_mode = (*(strupr(buffer)) != 'N');  /* Yes or Blocking */   /*BLOK*/ <br>#ifdef CPICSEND                                                        /*BLOK*/ <br>      blocking  = (*(strupr(buffer)) == 'B');  /* Blocking  */         /*BLOK*/ <br>#endif                                                                 /*BLOK*/ <br>   }                                                                   /*BLOK*/ <br> <br>   NumConversations=1; <br>   if (ReadString("NumConversations",buffer,200)) <br>   { <br>      NumConversations=atoi(buffer); <br>   } <br> <br>} <br> <br>/*****************************************************************************/ <br>/* NewConversation - Reset and record timers for this conversation.          */ <br>/*****************************************************************************/ <br>void NewConversation() <br>{ <br>   RESULT NewTime; <br> <br>#ifdef CPICSEND <br>   SendCount = 0; <br>   ConfirmCount =0; <br>#endif <br> <br>   if (FirstConv) <br>   { <br>      FirstConv = FALSE; <br>      ConvStarted = GetTickCount(); <br>   } <br>   else if (ResultPtr != NULL) <br>   { <br>      *ResultPtr++ = ((NewTime = GetTickCount()) - ConvStarted); <br>      ConvStarted = NewTime; <br>   } <br>   ConvCount++; <br>   OUTPUTNUMBER <br>} <br> <br>#ifdef CPICSEND <br>/*****************************************************************************/ <br>/* GenerateData    - Fill in data buffer                                     */ <br>/*****************************************************************************/ <br>void GenerateData() <br>{ <br>   int i; <br>   int div; <br>   int rem; <br>   char * dptr; <br> <br>   dptr = DataPtr; <br>   div = SendSize / 5; <br>   rem = SendSize % 5; <br> <br>   for (; div--;) <br>   { <br>      for (i=4; i--; *dptr++ = datach); <br>      *dptr++ = '.'; <br>   } <br>   for (; rem--; *dptr++ = datach); <br> <br>   datach = (datach=='Z' ? 'A' : datach + 1); <br>} <br>#endif <br> <br>/*****************************************************************************/ <br>/* ReadString - Get a line of text from the config file.                     */ <br>/*****************************************************************************/ <br>int ReadString(char * lpValueName,char * lpData, int maxlen) <br>{ <br>   char       buffer[200]; <br>   char       value[200]; <br>   char      *p = NULL; <br>   FILE      *h = NULL; <br>   BOOL       match = FALSE; <br>   BOOL       eof   = FALSE; <br>   int        rc = 0; <br>   int        ch = 0; <br>   int        i = 0; <br>   BOOL       gotdata = FALSE; <br>   char       separators[] = " =\t\n"; <br> <br>#if (defined(WINDOWS)||defined(WIN32))                                 /*PATH*/ <br>                                                                       /*PATH*/ <br>GetModuleFileName( hInst, buffer, sizeof(buffer) );                /*PATH*/ <br>lstrcpy( buffer+lstrlen(buffer) - 4, ".CFG" );                     /*PATH*/ <br>h = fopen( buffer, "r" );                                          /*PATH*/ <br>buffer[0] = '\0';                                                  /*PATH*/ <br>                                                                       /*PATH*/ <br>#else                                                                  /*PATH*/ <br>#ifdef CPICSEND <br>   h = fopen("C:\\cpicsend.cfg", "r"); <br>#else <br>   h = fopen("C:\\cpicrecv.cfg", "r"); <br>#endif <br>#endif                                                                 /*PATH*/ <br> <br>   strupr(strcpy(value,lpValueName)); <br> <br>   if (h != NULL) <br>   { <br>      while ((!match) &amp;&amp; (!eof)) <br>      { <br>         /********************************************************************/ <br>         /* Use fgetc to read a line of text from the file.                  */ <br>         /********************************************************************/ <br>         for (i=0; (i&lt;sizeof(buffer))     &amp;&amp; <br>                   ((ch=getc(h)) != EOF)  &amp;&amp; <br>                   ((char)ch != '\n'); <br>                                      i++) <br>         { <br>            buffer[i] = (char)ch; <br>         } <br>         if ((char)ch == '\n') <br>         { <br>            buffer[i++] = (char)ch; <br>         } <br>         if (ch == EOF) <br>         { <br>            eof = TRUE; <br>         } <br>         else <br>         { <br>            /*****************************************************************/ <br>            /* Compare the 1st token in the line read with the requested     */ <br>            /* param.                                                        */ <br>            /*****************************************************************/ <br>            if (!strcmpi(strupr(strtok(buffer, separators)), lpValueName)) <br>            { <br>               match = TRUE; <br>               /**************************************************************/ <br>               /* Get a pointer to the 2nd token (the value we want)         */ <br>               /**************************************************************/ <br>               p = strtok(NULL, separators); <br> <br>               /**************************************************************/ <br>               /* Copy the data IF there is some.                            */ <br>               /**************************************************************/ <br>               if (p != NULL) <br>               { <br>                  /***********************************************************/ <br>                  /* Force a NULL after the 2nn token                        */ <br>                  /***********************************************************/ <br>                  strtok(NULL, separators); <br> <br>                  /***********************************************************/ <br>                  /* Copy the data                                           */ <br>                  /***********************************************************/ <br>                  strncpy(lpData, p, maxlen); <br>                  gotdata = TRUE; <br>               } <br>               else <br>               { <br>                  gotdata = FALSE; <br>               } <br>            } <br>         } <br>      } <br> <br>      if (gotdata) <br>      { <br>         rc = 1; <br>      } <br> <br>      fclose(h); <br>   } <br> <br>return(rc); <br>} <br> <br>/*****************************************************************************/ <br>/* OutputResults - dump the times of conversations to file                   */ <br>/*****************************************************************************/ <br>void OutputResults() <br>{ <br>   FILE *h = NULL; <br>   RESULT * ptr = NULL; <br>   unsigned short i = 0; <br> <br>   h = fopen(FileName,"w"); <br>   if (h != NULL) <br>   { <br>#ifdef CPICSEND <br>     fprintf(h,"CPICSEND Results\n----------------\n\n"); <br>     fprintf(h,"Symbolic destination name = %s\n",SymDestName); <br>     fprintf(h,"Number of conversations = %d\n",NumConversations); <br>     fprintf(h,"Sends per conversation  = %d\n",NumSends); <br>     fprintf(h,"Sends between confirms  = %d\n",ConfirmEvery); <br>     fprintf(h,"Bytes per send          = %d\n",SendSize); <br>     fprintf(h,"Wait mode               = %s\n",(wait_mode ? "Yes" : "No")); <br>     fprintf(h,"Blocking                = %s\n",(blocking  ? "Yes" : "No")); <br>     fprintf(h,"\n"); <br>#else <br>     fprintf(h,"CPICRECV Results\n----------------\n\n"); <br>     fprintf(h,"Local TP Name           = %s\n",LocalTPName); <br>     fprintf(h,"Number of conversations = %d\n",NumConversations); <br>     fprintf(h,"Wait mode               = %s\n",(wait_mode ? "Yes" : "No")); <br>     fprintf(h,"\n"); <br>#endif <br> <br>     ptr = ResultBuf; <br>     while (ptr &lt; ResultPtr) <br>     { <br>       fprintf(h,"Conversation number %d, time = %.3f seconds\n",i++, <br>                                              (((float) *ptr++) / 1000.0 )); <br>     } <br>     fclose(h); <br>   } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
