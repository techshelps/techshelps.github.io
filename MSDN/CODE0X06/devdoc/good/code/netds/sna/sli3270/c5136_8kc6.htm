<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SLI3270.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5136"></a>SLI3270.C</h2>
<pre><code>/*****************************************************************************/ <br>/* SLI Sample Program                                                        */ <br>/*                                                                           */ <br>/* (C) Copyright 1990 - 1993 Data Connection Ltd.                            */ <br>/*                                                                           */ <br>/* This program is a crude 3270 emulator.  It uses the SLI API to access the */ <br>/* LU-LU session.  Outbound data from the host is displayed on the screen    */ <br>/* unformatted.                                                              */ <br>/*                                                                           */ <br>/* If the outbound data is an RQD request an automatic positive response     */ <br>/* is sent.  Inbound data can be entered at the keyboard and is sent on      */ <br>/* the current session.                                                      */ <br>/*                                                                           */ <br>/* The program is invoked with two parameters - the name of the LUA LU       */ <br>/* to use and a logon string.  This is converted to upper case and must      */ <br>/* match an LUA LU in the configuration file.  This LU should be configured  */ <br>/* for a 327? on the host.                                                   */ <br>/*                                                                           */ <br>/* The program can only access hosts that use simple unformatted logon       */ <br>/* requests                                                                  */ <br>/*                                                                           */ <br>/* To exit the program type ] (right square bracket)                         */ <br>/*                                                                           */ <br>/* The CSV CONVERT function is used to convert data between ASCII and        */ <br>/* EBCDIC.  This uses the type G conversion table, so the environment        */ <br>/* variable COMTBLG must be set to point to a suitable file.                 */ <br>/*                                                                           */ <br>/* Keys that work are:                                                       */ <br>/*                                                                           */ <br>/*     Alt-1 to Alt-9 are PF1 to PF9                                         */ <br>/*     F2 sends a CLEAR to the host                                          */ <br>/*     backspace                                                             */ <br>/*     Letters, numbers and symbols                                          */ <br>/*     ] terminates the program                                              */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br> <br>#ifdef WIN32 <br>  #include &lt;windows.h&gt; <br>#else <br>  #define INCL_DOS <br>  #define INCL_DOSERRORS <br>  #include &lt;os2.h&gt; <br>#endif <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;lua_c.h&gt; <br>#include &lt;acssvcc.h&gt; <br> <br> <br>/*****************************************************************************/ <br>/* Program constants                                                         */ <br>/*****************************************************************************/ <br>#define DATASIZE 4096                  /* Max size of RU                     */ <br>#define EXITKEY  0x5D                  /* ']'   to exit program              */ <br> <br>#define BETB     1                     /* Between brackets                   */ <br>#define SEND     2                     /* In bracket and can send            */ <br>#define RECV     3                     /* In bracket, but cannot send        */ <br> <br> <br>/*****************************************************************************/ <br>/* State variables                                                           */ <br>/*                                                                           */ <br>/* We can only have one read or write verb outstanding per flow.  These      */ <br>/* state variables keep track of these verbs and what we need to do with     */ <br>/* them.                                                                     */ <br>/*****************************************************************************/ <br> <br>UINT  write_state; <br>#define NO_WRITE              1 <br>#define WRITE_OUTSTANDING     2        /* waiting for write to complete      */ <br>#define WRITE_QUEUED          3        /* have data to write                 */ <br> <br>UINT  read_state; <br>#define NO_READ               1 <br>#define READ_OUTSTANDING      2        /* read verb outstanding              */ <br>#define RSP_QUEUED            3        /* have a response to write           */ <br>#define RSP_OUTSTANDING       4        /* waiting for a response to complete */ <br> <br>UINT  rpq_state; <br>#define NO_RPQ                1 <br>#define RPQ_OUTSTANDING       2        /* waiting for an RPQ to complete     */ <br>#define RPQ_QUEUED            3        /* have RPQ to send                   */ <br> <br>/***************************************************************************/ <br>/* Global variables                                                        */ <br>/*                                                                         */ <br>/* Inbound data is  prefixed with the &lt;enter&gt; key AID plus a two byte      */ <br>/* cursor address.                                                         */ <br>/***************************************************************************/ <br>LUA_VERB_RECORD recv_verb;             /* SLI read verb                    */ <br>LUA_VERB_RECORD other_verb;            /* SLI init, write or term verb     */ <br>LUA_VERB_RECORD rpq_verb;              /* SLI_WRITE for RPQs               */ <br> <br>UCHAR rpq_data[] = { <br> <br>  0x88, <br>  0x00, 0x0C, 0x81, 0x80, 0x80, 0x81, 0x85, 0x86, 0x87, 0x88, 0x95, 0xA6, <br> <br>  0x00, 0x17, 0x81, 0x81, 0x21, 0x00, 0x00, 0x50, 0x00, 0x18, 0x00, 0x00, <br>  0x0A, 0x02, 0xE5, 0x00, 0x02, 0x00, 0x6F, 0x09, 0x10, 0x07, 0x80, <br> <br>  0x00, 0x14, 0x81, 0x85, 0x02, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, <br>  0x07, 0x00, 0x00, 0x00, 0x02, 0xB9, 0x01, 0x1D, <br> <br>  0x00, 0x16, 0x81, 0x86, 0x00, 0x08, 0x00, 0xF4, 0xF1, 0x00, 0xF2, 0x00, <br>  0xF3, 0x00, 0xF4, 0x00, 0xF5, 0x00, 0xF6, 0x00, 0xF7, 0x00, <br> <br>  0x00, 0x0D, 0x81, 0x87, 0x04, 0x00, 0xF0, 0xF1, 0x00, 0xF2, 0x00, 0xF4, <br>  0x00, <br> <br>  0x00, 0x07, 0x81, 0x88, 0x00, 0x01, 0x02, <br> <br>  0x00, 0x0C, 0x81, 0x95, 0x00, 0x00, 0x7F, 0xFF, 0x7F, 0xFF, 0x01, 0x01, <br> <br>  0x00, 0x11, 0x81, 0xA6, 0x00, 0x00, 0x0B, 0x01, 0x00, 0x00, 0x50, 0x00, <br>  0x18, 0x00, 0x50, 0x00, 0x18}; <br> <br>#define RPQ_LENGTH (sizeof(rpq_data)) <br> <br> <br> <br> <br>unsigned char read_data[DATASIZE];     /* Outbound RU                       */ <br>#define WRITE_EXTRA 6 <br>unsigned char write_array[DATASIZE + WRITE_EXTRA] = <br>                                          {0x7d, 0x40, 0x40, 0x11, 0x40, 0x40}; <br>                                       /* Inbound RU                         */ <br>unsigned char *write_data = write_array + WRITE_EXTRA; <br>                                       /* Pointer to inbound RU              */ <br>UINT data_offset = 0;                  /* offset into read_data              */ <br>UINT write_len   = 0;                  /* length of write data               */ <br> <br>struct convert convert_to_asc;         /* Outbound convert verb              */ <br>struct convert convert_to_ebc;         /* Inbound convert verb               */ <br> <br>#ifdef WIN32 <br>  HANDLE write_event = 0l;             /* write arm verb semaphore           */ <br>  HANDLE read_event  = 0l;             /* read arm verb semaphore            */ <br>  HANDLE init_event  = 0l;             /* SLI_OPEN semaphore                 */ <br>  HANDLE term_event  = 0l;             /* SLI_CLOSE semaphore                */ <br>  HANDLE rpq_event   = 0l; <br>  HANDLE std_input;                    /* standard input handle              */ <br>  HANDLE std_output;                   /* standard output handle             */ <br>#else <br>  ULONG write_sema4 = 0l;              /* write arm verb semaphore           */ <br>  ULONG read_sema4  = 0l;              /* read arm verb semaphore            */ <br>  ULONG init_sema4  = 0l;              /* SLI_OPEN semaphore                 */ <br>  ULONG term_sema4  = 0l;              /* SLI_CLOSE semaphore                */ <br>  ULONG rpq_sema4   = 0l; <br>#endif <br> <br>BOOL terminating = FALSE;              /* are we already in closedown() ?    */ <br> <br>unsigned long sense = 0l;              /* sense code                         */ <br> <br>unsigned char lu_name[9] = "        "; /* LU name                            */ <br>unsigned long sid;                     /* SLI session ID                     */ <br>int send_state = BETB;                 /* LU session send state              */ <br> <br>#define LOGON_MAX  25                  /* maximum logon string length        */ <br> <br>UCHAR logon_data[LOGON_MAX+1] = {0}; <br>UCHAR logon_length   = 0; <br> <br>#ifdef WIN32 <br>  #define OPENPOST        (ULONG) init_event <br>  #define CLOSEPOST       (ULONG) term_event <br>  #define RECVPOST        (ULONG) read_event <br>  #define SENDPOST        (ULONG) write_event <br>  #define RPQPOST         (ULONG) rpq_event <br>#else <br>  #define OPENPOST        (unsigned long) ((UCHAR FAR *) &amp;init_sema4) <br>  #define CLOSEPOST       (unsigned long) ((UCHAR FAR *) &amp;term_sema4) <br>  #define RECVPOST        (unsigned long) ((UCHAR FAR *) &amp;read_sema4) <br>  #define SENDPOST        (unsigned long) ((UCHAR FAR *) &amp;write_sema4) <br>  #define RPQPOST         (unsigned long) ((UCHAR FAR *) &amp;rpq_sema4) <br>#endif <br> <br> <br>/*****************************************************************************/ <br>/* Function declarations.                                                    */ <br>/*****************************************************************************/ <br> <br>#ifdef WIN32 <br>  #define LOADDS <br>#else <br>  #define LOADDS _loadds <br>#endif <br> <br>void pascal far LOADDS SLI (LUA_VERB_RECORD FAR *); <br> <br>#ifdef WIN32 <br>  void _CRTAPI1 main(int argc, char *argv[]); <br>#else <br>  int             main                (int  argc,char  * *argv); <br>#endif <br>void            csv_init            (void); <br>int             issue_verb          (unsigned int  type); <br>void            issue_receive       (void); <br>void            other_done          (LUA_VERB_RECORD *verb); <br>void            recv_done           (LUA_VERB_RECORD *verb); <br>void            issue_rsp           (unsigned long  sense); <br>void            rsp_done            (LUA_VERB_RECORD *verb); <br>void            closedown           (void); <br>BOOL            do_send             (void); <br>void            wait_verb_complete  (LUA_VERB_RECORD *verb); <br>void            set_semaphore       (LUA_VERB_RECORD *verb); <br>BOOL            do_keyboard_stuff   (void); <br>BOOL            check_verb_complete (LUA_VERB_RECORD *verb); <br>void            parse_data          (UCHAR FAR *, USHORT); <br>BOOL            issue_rpq           (void); <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      main                                                           */ <br>/*                                                                           */ <br>/* Purpose:   set up CSV convert verbs                                       */ <br>/*                                                                           */ <br>/* Returns:   none                                                           */ <br>/*                                                                           */ <br>/* Params:    argv, argc                                                     */ <br>/*                                                                           */ <br>/* Operation: Get LU name and logon string from command line                 */ <br>/*            do some initialisation                                         */ <br>/*            Issue SLI_OPEN to get LU-LU   session                          */ <br>/*            Loop reading data from keyboard and host, and send keyboard    */ <br>/*            data to host                                                   */ <br>/**PROC-**********************************************************************/ <br>#ifdef WIN32 <br>  void _CRTAPI1 main(int argc, char *argv[]) <br>#else <br>int main(argc, argv) <br>int argc; <br>char *argv[]; <br>#endif <br>{ <br>  BOOL whole_data;       /* we have a whole data string to write             */ <br>  BOOL verb_complete;    /* Has a verb completed                             */ <br>  BOOL write_ok;         /* Has write worked?                                */ <br>  BOOL rpq_ok;           /* Has rpq worked                                   */ <br>  int ii; <br>#ifdef WIN32 <br>  HANDLE handle_list [6]; <br>#endif <br>#ifdef DOS5 <br>  DEFINEMUXSEMLIST(sem_list,5) <br>  USHORT           sem_index; <br>#endif <br> <br>  printf("SLI simple 3270 application\n"); <br> <br>  /***************************************************************************/ <br>  /* Validate parameter usage and get LU name.                               */ <br>  /***************************************************************************/ <br>  if (argc != 3) <br>  { <br>    printf("Usage: SLI3270 luname \"logon string\"\n"); <br>    exit(1); <br>  } <br>  if (strlen(argv[1]) &gt; 8) <br>  { <br>    printf("LU name too long\n"); <br>    exit(1); <br>  } <br>  if (strlen(argv[2]) &gt; LOGON_MAX) <br>  { <br>    printf("Logon string too long"); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Convert to upper case                                                   */ <br>  /***************************************************************************/ <br>  ii=0; <br>  while (argv[1][ii]) <br>  { <br>    if (argv[1][ii] &gt;= 'a' &amp;&amp; argv[1][ii] &lt;= 'z') <br>    { <br>      argv[1][ii] = argv[1][ii] - 'a' + 'A'; <br>    } <br>    ii++; <br>  } <br>  memcpy(lu_name, argv[1], strlen(argv[1])); <br>  printf("lu_name %s\n", lu_name); <br> <br>  /***************************************************************************/ <br>  /* Set up logon message                                                    */ <br>  /***************************************************************************/ <br>  strcpy (logon_data, argv[2]); <br>  logon_length = strlen(logon_data); <br>  convert_to_ebc.opcode       = SV_CONVERT; <br>  convert_to_ebc.direction    = SV_ASCII_TO_EBCDIC; <br>  convert_to_ebc.char_set     = SV_G; <br>  convert_to_ebc.source       = logon_data; <br>  convert_to_ebc.target       = logon_data; <br>  convert_to_ebc.len          = (unsigned short) logon_length; <br>  ACSSVC_C((LONG)((UCHAR FAR *)&amp;convert_to_ebc)); <br> <br>  /***************************************************************************/ <br>  /* Set up CSV convert verbs                                                */ <br>  /***************************************************************************/ <br>  csv_init(); <br> <br>#ifdef WIN32 <br>  /***************************************************************************/ <br>  /* Create the necessary events                                             */ <br>  /***************************************************************************/ <br>  write_event = CreateEvent (NULL, TRUE, FALSE, NULL); <br>  read_event  = CreateEvent (NULL, TRUE, FALSE, NULL); <br>  init_event  = CreateEvent (NULL, TRUE, FALSE, NULL); <br>  term_event  = CreateEvent (NULL, TRUE, FALSE, NULL); <br>  rpq_event   = CreateEvent (NULL, TRUE, FALSE, NULL); <br> <br> <br>  /***************************************************************************/ <br>  /* Get standard input and output handles.                                  */ <br>  /***************************************************************************/ <br>  std_input  = GetStdHandle (STD_INPUT_HANDLE ); <br>  std_output = GetStdHandle (STD_OUTPUT_HANDLE); <br>  if ((std_input  == INVALID_HANDLE_VALUE) || <br>      (std_output == INVALID_HANDLE_VALUE)) <br>  { <br>    printf("GetStdHandle Failed, %d", GetLastError()); <br>    exit (1); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Set up list of handles to wait for                                      */ <br>  /***************************************************************************/ <br>  handle_list[0] = write_event; <br>  handle_list[1] = read_event; <br>  handle_list[2] = init_event; <br>  handle_list[3] = term_event; <br>  handle_list[4] = rpq_event; <br>  handle_list[5] = std_input; <br>#endif <br> <br>#ifdef DOS5 <br>  /***************************************************************************/ <br>  /* Set semaphores to begin with                                            */ <br>  /***************************************************************************/ <br>  DosSemSet (&amp;init_sema4); <br>  DosSemSet (&amp;term_sema4); <br>  DosSemSet (&amp;read_sema4); <br>  DosSemSet (&amp;write_sema4); <br>  DosSemSet (&amp;rpq_sema4); <br> <br>  sem_list.amxs[0].hsem = &amp;init_sema4; <br>  sem_list.amxs[1].hsem = &amp;term_sema4; <br>  sem_list.amxs[2].hsem = &amp;read_sema4; <br>  sem_list.amxs[3].hsem = &amp;write_sema4; <br>  sem_list.amxs[4].hsem = &amp;rpq_sema4; <br>#endif <br> <br> <br>  /***************************************************************************/ <br>  /* Initialize SLI (get LU-LU session)                                      */ <br>  /***************************************************************************/ <br>  if (issue_verb((unsigned int) LUA_OPCODE_SLI_OPEN)) <br>  { <br>    printf("OPEN failed\n"); <br>    exit(1); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Set initial states                                                      */ <br>  /***************************************************************************/ <br>  write_state = NO_WRITE; <br>  read_state  = NO_READ; <br>  rpq_state   = NO_RPQ; <br> <br>  /***************************************************************************/ <br>  /* Loop reading inbound data from the keyboard                             */ <br>  /***************************************************************************/ <br>  while (!terminating) <br>  { <br>    /*************************************************************************/ <br>    /* Determine if we can pause                                             */ <br>    /*************************************************************************/ <br>    if (  (read_state != NO_READ)   &amp;&amp; <br> <br>          ((write_state != WRITE_QUEUED)    || <br>           (rpq_state   != NO_RPQ)          || <br>           (read_state  == RSP_OUTSTANDING) || <br>           (read_state  == RSP_QUEUED)) &amp;&amp; <br> <br>          ((rpq_state   != RPQ_QUEUED)        || <br>           (write_state == WRITE_OUTSTANDING) || <br>           (read_state  == RSP_OUTSTANDING)   || <br>           (read_state  == RSP_QUEUED))    &amp;&amp; <br> <br>          ((read_state != RSP_QUEUED) || <br>           (write_state == WRITE_OUTSTANDING))) <br>    { <br>#ifdef WIN32 <br>      WaitForMultipleObjects (6, handle_list, FALSE, INFINITE); <br>#else <br>      if (!kbhit()) <br>      { <br>        DosMuxSemWait (&amp;sem_index, &amp;sem_list, 200l); <br>      } <br>#endif <br>    } <br> <br>    /*************************************************************************/ <br>    /* First check on the state of write verbs                               */ <br>    /*************************************************************************/ <br>    if ((write_state == NO_WRITE)        &amp;&amp; <br>        (rpq_state   == NO_RPQ)          &amp;&amp; <br>        (read_state  != RSP_QUEUED)      &amp;&amp; <br>        (read_state  != RSP_OUTSTANDING)) <br>    { <br>      /***********************************************************************/ <br>      /* Don't write here if we need to respond, since we can only have one  */ <br>      /* write outstanding on each flow.                                     */ <br>      /* Here we want to check if we have a whole string of data (i.e.  that */ <br>      /* the user has hit enter).  If so write the data to the HOST          */ <br>      /***********************************************************************/ <br>      whole_data = do_keyboard_stuff (); <br>      if (whole_data) <br>      { <br>        /*********************************************************************/ <br>        /* Attempt to write the data.  May not work because of bracket state */ <br>        /*********************************************************************/ <br> <br>        write_ok = do_send (); <br>        if (write_ok) <br>        { <br>          /*******************************************************************/ <br>          /* If verb completes async change state to indicate this o.w.      */ <br>          /* call the verb done processor                                    */ <br>          /*******************************************************************/ <br>          if (other_verb.common.lua_flag2.async) <br>          { <br>            write_state = WRITE_OUTSTANDING; <br>          } <br>          else <br>          { <br>            other_done (&amp;other_verb); <br>            write_state = NO_WRITE; <br>          } <br>        } <br>        else <br>        { <br>          /*******************************************************************/ <br>          /* Failed to do a write.  Queue up data                            */ <br>          /*******************************************************************/ <br>          write_state = WRITE_QUEUED; <br>        } <br>      } <br>    } <br>    else if ((write_state == WRITE_QUEUED)    &amp;&amp; <br>             (rpq_state   == NO_RPQ)          &amp;&amp; <br>             (read_state  != RSP_OUTSTANDING) &amp;&amp; <br>             (read_state  != RSP_QUEUED)) <br>    { <br>      /***********************************************************************/ <br>      /* Attempt to write the data.  May not work because of bracket state   */ <br>      /***********************************************************************/ <br>      write_ok = do_send (); <br>      if (write_ok) <br>      { <br>        /*********************************************************************/ <br>        /* If verb completes async change state to indicate this o.w.  call  */ <br>        /* the verb done processor                                           */ <br>        /*********************************************************************/ <br>        if (other_verb.common.lua_flag2.async) <br>        { <br>          write_state = WRITE_OUTSTANDING; <br>        } <br>        else <br>        { <br>          other_done (&amp;other_verb); <br>          write_state = NO_WRITE; <br>        } <br>      } <br> <br>    } <br>    else if (write_state == WRITE_OUTSTANDING) <br>    { <br>      /***********************************************************************/ <br>      /* We have a SLI_WRITE outstanding so check if it is complete          */ <br>      /***********************************************************************/ <br>      verb_complete = check_verb_complete (&amp;other_verb); <br>      if (verb_complete) <br>      { <br>        other_done (&amp;other_verb); <br>        write_state = NO_WRITE; <br>      } <br>    } <br> <br> <br> <br>    /*************************************************************************/ <br>    /* Now check the RPQ state                                               */ <br>    /*************************************************************************/ <br>    if ((rpq_state   == RPQ_QUEUED)        &amp;&amp; <br>        (write_state != WRITE_OUTSTANDING) &amp;&amp; <br>        (read_state  != RSP_OUTSTANDING)   &amp;&amp; <br>        (read_state  != RSP_QUEUED)) <br>    { <br>      /***********************************************************************/ <br>      /* We have an RPQ queued up.  Try to send it                           */ <br>      /***********************************************************************/ <br>      rpq_ok = issue_rpq (); <br>      if (rpq_ok) <br>      { <br>        /*********************************************************************/ <br>        /* If verb completes async change state to indicate this o.w.  call  */ <br>        /* the verb done processor                                           */ <br>        /*********************************************************************/ <br>        if (rpq_verb.common.lua_flag2.async) <br>        { <br>          rpq_state = WRITE_OUTSTANDING; <br>        } <br>        else <br>        { <br>          other_done (&amp;rpq_verb); <br>          write_state = NO_RPQ; <br>        } <br>      } <br>    } <br>    else if (rpq_state == RPQ_OUTSTANDING) <br>    { <br>      /***********************************************************************/ <br>      /* Check for verb completion                                           */ <br>      /***********************************************************************/ <br>      verb_complete = check_verb_complete (&amp;rpq_verb); <br>      if (verb_complete) <br>      { <br>        other_done (&amp;rpq_verb); <br>        rpq_state = NO_RPQ; <br>      } <br> <br>    } <br> <br> <br> <br>    /*************************************************************************/ <br>    /* Now check on read verbs                                               */ <br>    /*************************************************************************/ <br>    if (read_state == NO_READ) <br>    { <br>      issue_receive (); <br>      if (recv_verb.common.lua_flag2.async) <br>      { <br>        read_state = READ_OUTSTANDING; <br>      } <br>      else <br>      { <br>        /*********************************************************************/ <br>        /* recv_done will change read_state to RESPONSE_QUEUED or NO_READ    */ <br>        /*********************************************************************/ <br>        recv_done (&amp;recv_verb); <br>      } <br>    } <br>    else if (read_state == READ_OUTSTANDING) <br>    { <br>      verb_complete = check_verb_complete (&amp;recv_verb); <br>      if (verb_complete) <br>      { <br>        /*********************************************************************/ <br>        /* recv_done will change read_state to RESPONSE_QUEUED or NO_READ    */ <br>        /*********************************************************************/ <br>        recv_done (&amp;recv_verb); <br>      } <br>    } <br>    else if (read_state == RSP_QUEUED) <br>    { <br>      /***********************************************************************/ <br>      /* We need to respond to a message read.  Do a write if one is         */ <br>      /* availible.                                                          */ <br>      /***********************************************************************/ <br>      if (write_state != WRITE_OUTSTANDING) <br>      { <br>        /*********************************************************************/ <br>        /* The response is issued using the recv_verb                        */ <br>        /*********************************************************************/ <br>        issue_rsp (sense); <br>        if (recv_verb.common.lua_flag2.async) <br>        { <br>          read_state = RSP_OUTSTANDING; <br>        } <br>        else <br>        { <br>          rsp_done (&amp;recv_verb); <br>          read_state = NO_READ; <br>        } <br>      } <br>    } <br>    else if (read_state == RSP_OUTSTANDING) <br>    { <br>      /***********************************************************************/ <br>      /* Check to see if the response is complete                            */ <br>      /***********************************************************************/ <br>      verb_complete = check_verb_complete (&amp;recv_verb); <br>      if (verb_complete) <br>      { <br>        rsp_done (&amp;recv_verb); <br>        read_state = NO_READ; <br>      } <br>    } <br>    else <br>    { <br>      /***********************************************************************/ <br>      /* Invalid state                                                       */ <br>      /***********************************************************************/ <br>      printf("invalid state"); <br>    } <br> <br>  }  /* while not terminating                                                */ <br> <br> <br>}  /* main ()                                                                */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      csv_init                                                       */ <br>/*                                                                           */ <br>/* Purpose:   set up CSV convert verbs                                       */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: sets uup two CSV convert verbs, one in each direction.  Only   */ <br>/* the length needs to be set when the verb is called                        */ <br>/**PROC-**********************************************************************/ <br>void csv_init (void) <br>{ <br>  convert_to_asc.opcode       = SV_CONVERT; <br>  convert_to_asc.direction    = SV_EBCDIC_TO_ASCII; <br>  convert_to_asc.char_set     = SV_G; <br>  convert_to_asc.source       = read_data; <br>  convert_to_asc.target       = read_data; <br> <br>  convert_to_ebc.opcode       = SV_CONVERT; <br>  convert_to_ebc.direction    = SV_ASCII_TO_EBCDIC; <br>  convert_to_ebc.char_set     = SV_G; <br>  convert_to_ebc.source       = write_data; <br>  convert_to_ebc.target       = write_data; <br>}  /* csv_init                                                               */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      issue_verb                                                     */ <br>/*                                                                           */ <br>/* Purpose:   build a verb and send it                                       */ <br>/*                                                                           */ <br>/* Returns:   int - non-zero =&gt; verb failed                                  */ <br>/*                                                                           */ <br>/* Params:    IN type - type of verb to issue                                */ <br>/*                                                                           */ <br>/* Operation: Build an OPEN or CLOSE verb and issue it.  Wait for the verb   */ <br>/*            to complete                                                    */ <br>/**PROC-**********************************************************************/ <br>int issue_verb(type) <br>unsigned int  type; <br>{ <br>  memset(&amp;other_verb, 0, sizeof(other_verb)); <br>  other_verb.common.lua_verb             = LUA_VERB_SLI; </code></pre>
<p>
</p>
<pre><code>other_verb.common.lua_opcode           = type; <br>  if (type == LUA_OPCODE_SLI_OPEN) <br>  { <br>    other_verb.common.lua_verb_length    = sizeof(struct LUA_COMMON)+ <br>                            sizeof(other_verb.specific.open.lua_init_type) + <br>                            sizeof(other_verb.specific.open.lua_resv65) + <br>                            sizeof(other_verb.specific.open.lua_wait) + <br>                            sizeof(other_verb.specific.open.lua_ending_delim); <br>    memcpy(other_verb.common.lua_luname, lu_name, 8); <br>    other_verb.common.lua_post_handle    = OPENPOST; <br>    other_verb.specific.open.lua_init_type = LUA_INIT_TYPE_SEC_LOG; <br>    other_verb.common.lua_data_length    = logon_length; <br>    other_verb.common.lua_data_ptr       = logon_data; <br>    other_verb.specific.open.lua_open_extension[0].lua_routine_type = <br>                                                         LUA_ROUTINE_TYPE_END; <br>  } <br>  else <br>  { <br>    other_verb.common.lua_verb_length    = sizeof(struct LUA_COMMON); <br>    other_verb.common.lua_sid            = sid; <br>    other_verb.common.lua_post_handle    = CLOSEPOST; <br>  } <br>  SLI((LUA_VERB_RECORD FAR *) &amp;other_verb); <br>  if (other_verb.common.lua_flag2.async) <br>  { <br>    wait_verb_complete (&amp;other_verb); <br>  } <br>  other_done(&amp;other_verb); <br> <br>  return(other_verb.common.lua_prim_rc != LUA_OK); <br>}  /* issue_verb                                                             */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      issue_receive                                                  */ <br>/*                                                                           */ <br>/* Purpose:   build a recv verb and send it                                  */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: Build a read verb for all flows and issue it                   */ <br>/**PROC-**********************************************************************/ <br>void issue_receive (void) <br>{ <br>  memset(&amp;recv_verb, 0, sizeof(recv_verb)); <br>  memset(read_data, 0, DATASIZE); <br>  recv_verb.common.lua_verb             = LUA_VERB_SLI; <br>  recv_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON); <br>  recv_verb.common.lua_opcode           = LUA_OPCODE_SLI_RECEIVE; <br>  recv_verb.common.lua_sid              = sid; <br>  recv_verb.common.lua_max_length       = DATASIZE; <br>  recv_verb.common.lua_data_ptr         = (char *) read_data; <br>  recv_verb.common.lua_post_handle      = RECVPOST; <br>  recv_verb.common.lua_flag1.lu_norm    = 1; <br>  recv_verb.common.lua_flag1.lu_exp     = 1; <br>  recv_verb.common.lua_flag1.sscp_norm  = 1; <br>  recv_verb.common.lua_flag1.sscp_exp   = 1; <br>  SLI((LUA_VERB_RECORD FAR *)&amp;recv_verb); <br> <br>}  /* issue_receive                                                          */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      other_done                                                     */ <br>/*                                                                           */ <br>/* Purpose:   handle completed open, send or close verb                      */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN verb - completed verb                                       */ <br>/*                                                                           */ <br>/* Operation: write status to he screen                                      */ <br>/**PROC-**********************************************************************/ <br>void other_done(verb) <br>LUA_VERB_RECORD *verb; <br>{ <br>  switch (verb-&gt;common.lua_opcode) <br>  { <br>    case LUA_OPCODE_SLI_OPEN: <br>         if (verb-&gt;common.lua_prim_rc == LUA_OK) <br>         { <br>           printf("session active\n"); <br>           sid = verb-&gt;common.lua_sid; <br>         } <br>         else <br>         { <br>           printf("OPEN failed, (%4.4x, %8.8lx)\n", <br>                  verb-&gt;common.lua_prim_rc, verb-&gt;common.lua_sec_rc); <br>         } <br>         break; <br> <br>    case LUA_OPCODE_SLI_SEND: <br>         if (verb-&gt;common.lua_prim_rc != LUA_OK) <br>         { <br>           printf("SEND failed, (%4.4x, %8.8lx)\n", <br>                  verb-&gt;common.lua_prim_rc, verb-&gt;common.lua_sec_rc); <br>         } <br>         break; <br> <br>    case LUA_OPCODE_SLI_CLOSE: <br>         printf("Terminated\n"); <br>         break; <br> <br>  } <br>}  /* other_done                                                             */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      recv_done                                                      */ <br>/*                                                                           */ <br>/* Purpose:   handle completed receive verb                                  */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN verb - completed read verb                                  */ <br>/*                                                                           */ <br>/* Operation: If the completed verb contains data, first parse it and then   */ <br>/*            display it.                                                    */ <br>/*            If message is a BIND or an UNBIND, set the LU-LU session state */ <br>/*            accordingly                                                    */ <br>/*            Also check for EB, CD and change session state flags           */ <br>/**PROC-**********************************************************************/ <br>void recv_done(verb) <br>LUA_VERB_RECORD *verb; <br>{ <br>  int            count;         /* number of bytes of data left to display   */ <br>  unsigned char *data;          /* pointer to next data to display           */ <br>  BOOL           rsp_required = FALSE; /* is a resonse required              */ <br> <br>  sense = 0l; <br> <br>  if (verb-&gt;common.lua_prim_rc == LUA_OK) <br>  { <br>    if (verb-&gt;common.lua_message_type == LUA_MESSAGE_TYPE_LU_DATA) <br>    { <br>      if (verb-&gt;common.lua_data_length &gt; 0) <br>      { <br>        /*********************************************************************/ <br>        /* We now have to parse the data.  For the moment we only look for   */ <br>        /* RPQ requests.                                                     */ <br>        /*********************************************************************/ <br>        parse_data (read_data, (USHORT) (verb-&gt;common.lua_data_length)); <br> <br>        /*********************************************************************/ <br>        /* Display outbound data.                                            */ <br>        /*********************************************************************/ <br>        convert_to_asc.len = (unsigned short) verb-&gt;common.lua_data_length; <br>        ACSSVC_C((LONG)((UCHAR FAR *)&amp;convert_to_asc)); <br>        data  = read_data; <br>        count = strlen(data); <br>        while (count &gt; 0) <br>        { <br>          if (count &lt;= 80) <br>          { <br>            printf("%s\n",data); <br>            count = 0; <br>          } <br>          else <br>          { <br>            printf("%80.80s\n",data); <br>            count -= 80; <br>            data  += 80; <br>          } <br>        } <br>      } <br> <br>      /***********************************************************************/ <br>      /* Set session state.                                                  */ <br>      /***********************************************************************/ <br>      if (verb-&gt;common.lua_rh.ebi) <br>      { <br>        printf("EB\n"); <br>        send_state = BETB; <br>      } <br>      else if (verb-&gt;common.lua_rh.cdi) <br>      { <br>        printf("CD\n"); <br>        send_state = SEND; <br>      } <br>      else <br>      { <br>        send_state = RECV; <br>      } <br>    } <br> <br>    /*************************************************************************/ <br>    /* Respond to any RQD request.                                           */ <br>    /*************************************************************************/ <br>    if ((verb-&gt;common.lua_message_type != LUA_MESSAGE_TYPE_RSP)  &amp;&amp; <br>        (verb-&gt;common.lua_rh.ri == 0))                  /* definite response */ <br>    { <br>      rsp_required = TRUE; <br>    } <br>  } <br>  else         /* primary rc not OK - read failed - stop now */ <br>  { <br>    printf("RECEIVE ERROR, primary rc = %4.4x, secondary rc = %8.8lx\n", <br>           verb-&gt;common.lua_prim_rc, verb-&gt;common.lua_sec_rc); <br>    closedown(); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Continue processing with either another recv or a send  positive rsp.   */ <br>  /* (The callback from issuing response will then issue another recv) If    */ <br>  /* we've already gone into closedown, stop here                            */ <br>  /***************************************************************************/ <br>  if (!terminating) <br>  { <br>    if (rsp_required) <br>    { <br>      read_state = RSP_QUEUED; <br>    } <br>    else <br>    { <br>      read_state = NO_READ; <br>    } <br>  } <br>}  /* recv_done                                                              */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      issue_rsp                                                      */ <br>/*                                                                           */ <br>/* Purpose:   issue a response for a request from the host                   */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN sense - sense code for the response                         */ <br>/*                                                                           */ <br>/* Operation: Build a response and write it out.  Uses the recv verb control */ <br>/*            block because it has the necessary information.                */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void issue_rsp(sense) <br>unsigned long sense; <br>{ <br>  recv_verb.common.lua_opcode           = LUA_OPCODE_SLI_SEND; <br>  recv_verb.common.lua_max_length       = 0; <br>  recv_verb.common.lua_post_handle      = (ULONG) RECVPOST; <br>  recv_verb.common.lua_message_type     = LUA_MESSAGE_TYPE_RSP; <br>  recv_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON) + <br>                                sizeof(recv_verb.specific.lua_sequence_number); <br> <br>  recv_verb.common.lua_rh.rri           = 1;        /* response              */ <br>  recv_verb.common.lua_flag1.lu_norm    = 0; <br>  recv_verb.common.lua_flag1.lu_exp     = 0; <br>  recv_verb.common.lua_flag1.sscp_norm  = 0; <br>  recv_verb.common.lua_flag1.sscp_exp   = 0; <br> <br>  /***************************************************************************/ <br>  /* If we have been given a sense code this must be a negative response     */ <br>  /***************************************************************************/ <br>  if (sense) <br>  { <br>    recv_verb.common.lua_data_length      = 4; <br>    memcpy(read_data, &amp;sense, 4); <br>    recv_verb.common.lua_rh.ri            = 1;       /* negative rsp         */ <br>  } <br>  else <br>  { <br>    recv_verb.common.lua_data_length      = 0; <br>    recv_verb.common.lua_rh.ri            = 0;       /* positive rsp         */ <br>  } <br>  /***************************************************************************/ <br>  /* Send the response back on the flow from which the request came          */ <br>  /***************************************************************************/ <br>  if (recv_verb.common.lua_flag2.lu_norm) <br>  { <br>    recv_verb.common.lua_flag1.lu_norm = 1; <br>  } <br>  else if (recv_verb.common.lua_flag2.lu_exp) <br>  { <br>    recv_verb.common.lua_flag1.lu_exp = 1; <br>  } <br>  else if (recv_verb.common.lua_flag2.sscp_norm) <br>  { <br>    recv_verb.common.lua_flag1.sscp_norm = 1; <br>  } <br>  else if (recv_verb.common.lua_flag2.sscp_exp) <br>  { <br>    recv_verb.common.lua_flag1.sscp_exp = 1; <br>  } <br>  /***************************************************************************/ <br>  /* Send out the verb                                                       */ <br>  /***************************************************************************/ <br>  SLI((LUA_VERB_RECORD FAR *)&amp;recv_verb);              /* write the response */ <br>}  /* issue_rsp                                                              */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      rsp_done                                                       */ <br>/*                                                                           */ <br>/* Purpose:   handle completion of SLI_SEND, when SLI_SEND has written a     */ <br>/*            response                                                       */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN verb - completed verb                                       */ <br>/*                                                                           */ <br>/* Operation: If verb did not complete OK print a message and terminate      */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void rsp_done (verb) <br>LUA_VERB_RECORD *verb; <br>{ <br>  if (verb-&gt;common.lua_prim_rc != LUA_OK)    /* failed to write the response */ <br>  {                                          /* so stop here                 */ <br>    printf("SEND for response failed, (%4.4x, %8.8lx)\n", <br>            verb-&gt;common.lua_prim_rc, verb-&gt;common.lua_sec_rc); <br>    closedown(); <br>  } <br>}  /* rsp_done                                                               */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      closedown                                                      */ <br>/*                                                                           */ <br>/* Purpose:   terminate the application cleanly                              */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: Issue an SLI_CLOSE and wait for it to complete.  Then exit     */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void closedown (void) <br>{ <br>  if (!terminating)                /* check we haven't already got here from */ <br>  {                                /* another section of the code            */ <br>    terminating = TRUE;            /* then make sure we can't get here again */ <br>    printf("Closedown\n"); <br>    if (issue_verb((unsigned int) LUA_OPCODE_SLI_CLOSE)) <br>    { <br>      exit(1); <br>    } <br>    exit(0); <br>  } <br>}  /* closedown                                                              */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      check_verb_complete                                            */ <br>/*                                                                           */ <br>/* Purpose:   check for asynchronous verb completion                         */ <br>/*                                                                           */ <br>/* Returns:   BOOL - TRUE =&gt; verb has completed                              */ <br>/*                                                                           */ <br>/* Params:    IN - verb - pointer to verb control block                      */ <br>/*                                                                           */ <br>/* Operation: OS specific                                                    */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>BOOL check_verb_complete (verb) <br> <br>LUA_VERB_RECORD * verb; <br>{ <br>#ifdef DOS5 <br>  /***************************************************************************/ <br>  /* OS/2 case.  The verb is complete when the semaphore is cleared          */ <br>  /***************************************************************************/ <br>  USHORT RetCode;                     /* Holds return code from OS calls     */ <br>  BOOL   verb_complete;               /* Has the verb completed              */ <br> <br>  verb_complete = FALSE; <br> <br>  RetCode = DosSemRequest ((HSEM)verb-&gt;common.lua_post_handle, 0l); <br> <br>  if (RetCode != NO_ERROR) <br>  { <br>    if (RetCode != ERROR_SEM_TIMEOUT) <br>    { <br>      /***********************************************************************/ <br>      /* If we get here we've got problems                                   */ <br>      /***********************************************************************/ <br>      printf("Bad DosSemRequest return code, %d", RetCode); <br>    } <br>  } <br>  else <br>  { <br>    verb_complete = TRUE; <br>    set_semaphore (verb); <br>  } <br> <br>  return(verb_complete); <br>#endif <br> <br>#ifdef PDOS <br>  /***************************************************************************/ <br>  /* DOS case.  The verb is complete when the lua_post_handle is cleared     */ <br>  /***************************************************************************/ <br>  BOOL   verb_complete;               /* Has the verb completed              */ <br> <br>  verb_complete = FALSE; <br> <br>  if (!verb-&gt;common.lua_post_handle) <br>  { <br>    verb_complete = TRUE; <br>    set_semaphore (verb); <br>  } <br> <br>  return(verb_complete); <br>#endif <br> <br>#ifdef WIN32 <br>  /***************************************************************************/ <br>  /* Win32 case.  The verb is complete when the semaphore is cleared         */ <br>  /***************************************************************************/ <br>  DWORD  RetCode; <br> <br>  RetCode = WaitForSingleObject((HANDLE) verb-&gt;common.lua_post_handle, 0l); <br> <br>  if (RetCode == 0) <br>  { <br>    set_semaphore (verb); <br>  } <br>  return((RetCode == 0)); <br>#endif <br>}  /* check_verb_complete                                                    */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      wait_verb_complete                                             */ <br>/*                                                                           */ <br>/* Purpose:   waits for async verb completion                                */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN - verb - pointer to verb control block                      */ <br>/*                                                                           */ <br>/* Operation: Wait for the lua_post_handle to become clear                   */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void wait_verb_complete (verb) <br> <br>LUA_VERB_RECORD * verb ; <br>{ <br>#ifdef DOS5 <br>  USHORT RetCode;                     /* Holds return code from OS calls     */ <br> <br>  RetCode = DosSemRequest ((HSEM)verb-&gt;common.lua_post_handle, -1l); <br>#endif <br> <br>#ifdef WIN32 <br>  DWORD RetCode; <br> <br>  RetCode = WaitForSingleObject((HANDLE)verb-&gt;common.lua_post_handle, <br>                                                                   (DWORD)-1l); <br>#endif <br>  set_semaphore (verb); <br> <br>}  /* wait_verb_complete                                                     */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      set_semaphore                                                  */ <br>/*                                                                           */ <br>/* Purpose:   sets verb completion flags                                     */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN - verb - pointer to vcb                                     */ <br>/*                                                                           */ <br>/* Operation: set the lua_post_handle to the non-signaled state              */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void set_semaphore (verb) <br> <br>LUA_VERB_RECORD * verb; <br>{ <br>#ifdef DOS5 <br>  USHORT RetCode; <br>  RetCode = DosSemSet ((HSEM)verb-&gt;common.lua_post_handle); <br>#endif <br> <br>#ifdef WIN32 <br>  /*W32***********************************************************************/ <br>  /*W32* Win 32 case.  Clear the event                                       */ <br>  /*W32***********************************************************************/ <br>  ResetEvent ((HANDLE) verb-&gt;common.lua_post_handle); <br>#endif <br>}  /* set_semaphore                                                          */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      do_keyboard_stuff                                              */ <br>/*                                                                           */ <br>/* Purpose:   poll keyboard for data                                         */ <br>/*                                                                           */ <br>/* Returns:   BOOL - TRUE =&gt; we have data to send                            */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: poll keyboard                                                  */ <br>/*            if some data                                                   */ <br>/*              read it in                                                   */ <br>/*              add it to data buffer                                        */ <br>/*              if data is &lt;enter&gt;                                           */ <br>/*                return TRUE                                                */ <br>/*              endif                                                        */ <br>/*            endif                                                          */ <br>/*            return false                                                   */ <br>/*                                                                           */ <br>/* Also keep track of which session is being used, and if user wishes to     */ <br>/* exit.                                                                     */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>BOOL do_keyboard_stuff (void) <br> <br>{ <br>  BOOL   data_to_send;             /* do we have data to send?               */ <br>  INT    input_char;               /* an input character                     */ <br>#ifdef WIN32 <br>  INPUT_RECORD input_record;       /* input record                           */ <br>  DWORD        no_read;            /* number of input records read           */ <br>#endif <br> <br>  data_to_send = FALSE; <br> <br>  /***************************************************************************/ <br>  /* Check if keyboard has been hit                                          */ <br>  /***************************************************************************/ <br>#ifdef WIN32 <br>  while ((!data_to_send) &amp;&amp; <br>         (!terminating)  &amp;&amp; <br>         (PeekConsoleInput (std_input, &amp;input_record, 1, &amp;no_read)) &amp;&amp; <br>         (no_read &gt; 0)) <br>#else <br>  while ((!data_to_send) &amp;&amp; (!terminating) &amp;&amp; (kbhit())) <br>#endif <br>  { <br>#ifndef WIN32 <br>    input_char = getche (); <br>    if ((input_char == 0) || (input_char == 0xE0)) <br>#else <br>    ReadConsoleInput (std_input, &amp;input_record, 1, &amp;no_read); <br> <br> <br>    if ((input_record.EventType == KEY_EVENT) &amp;&amp; <br>        (input_record.Event.KeyEvent.bKeyDown) &amp;&amp; <br>        ((input_record.Event.KeyEvent.dwControlKeyState == LEFT_ALT_PRESSED) || <br>         ((input_record.Event.KeyEvent.wVirtualKeyCode &gt;= VK_F1 ) &amp;&amp; <br>          (input_record.Event.KeyEvent.wVirtualKeyCode &lt;= VK_F24)))) <br>#endif <br>    { <br>      /***********************************************************************/ <br>      /* Not an ascii char                                                   */ <br>      /***********************************************************************/ <br>#ifndef WIN32 <br>      input_char = getch (); <br>#endif <br> <br> <br>      /***********************************************************************/ <br>      /* Check for function keys and ALT-??                                  */ <br>      /***********************************************************************/ <br>#ifndef WIN32 <br>      if (input_char == 60)               /* F2                              */ <br>#else <br>      if (input_record.Event.KeyEvent.wVirtualKeyCode == VK_F2) <br>#endif <br>      { <br>        /*********************************************************************/ <br>        /* Send a Clear.                                                     */ <br>        /*********************************************************************/ <br>        printf("sending clear\n"); <br>        *write_data = 0x6d; <br>        write_len   = 1; <br>        data_to_send = TRUE; <br>      } <br>#ifndef WIN32 <br>      else if ((input_char &gt;= 120) &amp;&amp; (input_char &lt;= 129)) <br>#else <br>      else if ((input_record.Event.KeyEvent.wVirtualKeyCode &gt;= '0') &amp;&amp; <br>               (input_record.Event.KeyEvent.wVirtualKeyCode &lt;= '9')) <br>#endif <br>      { <br>        /*********************************************************************/ <br>        /* ALT-1 to ALT-0                                                    */ <br>        /* 0xF1 is the AID code for PF1                                                              */ <br>        /* Follow this with the cursor address                               */ <br>        /*********************************************************************/ <br>#ifndef WIN32 <br>        *write_data = 0xF1 + input_char - 120; <br>#else <br>        *write_data = 0xF0 + input_record.Event.KeyEvent.wVirtualKeyCode - '0'; <br>#endif <br>        *(write_data + 1) = 0x40; <br>        *(write_data + 2) = 0x40; <br>        write_len = 3; <br>        data_to_send = TRUE; <br> <br>      } <br>    } <br>    else <br>#ifdef WIN32 <br>        if ((input_record.EventType == KEY_EVENT ) &amp;&amp; <br>            (input_record.Event.KeyEvent.bKeyDown)) <br>#endif <br>    { <br>      /***********************************************************************/ <br>      /* An ASCII char                                                       */ <br>      /***********************************************************************/ <br>#ifdef WIN32 <br>      input_char = input_record.Event.KeyEvent.uChar.AsciiChar; <br>#endif <br>      if (input_char == EXITKEY) <br>      { <br>        closedown(); <br>      } <br>      else <br>      { <br>        /*********************************************************************/ <br>        /* Key should be real data.  Add it to the string                    */ <br>        /* For Windows NT echo the character to the screen                   */ <br>        /*********************************************************************/ <br> <br>        if (input_char == 13) <br>        { <br>#ifdef WIN32 <br>          WriteConsole (std_output, &amp;input_char, 1, &amp;no_read, NULL); <br>#endif <br>          /*******************************************************************/ <br>          /* If user pressed return key then send the data.  Reset           */ <br>          /* data_offset for next data.                                      */ <br>          /*******************************************************************/ <br>          write_data[data_offset++] = '\0'; <br>          data_to_send = TRUE; <br>          data_offset  = 0; <br> <br>          /*******************************************************************/ <br>          /* Convert data to EBCDIC                                          */ <br>          /*******************************************************************/ <br>          convert_to_ebc.len = (unsigned short) (strlen(write_data) ); <br>          if (convert_to_ebc.len &gt; 0) <br>          { <br>            ACSSVC_C((LONG)((UCHAR FAR *)&amp;convert_to_ebc)); <br>          } <br>          write_len = convert_to_ebc.len; <br> <br>          /*******************************************************************/ <br>          /* Allow for ENTER AID if necessary                                */ <br>          /*******************************************************************/ <br>          write_data -= WRITE_EXTRA; <br>          write_len  += WRITE_EXTRA; <br>        } <br>        else if (input_char == 8) <br>        { <br>#ifdef WIN32 <br>          WriteConsole (std_output, &amp;input_char, 1, &amp;no_read, NULL); <br>#endif <br>          /*******************************************************************/ </code></pre>
<p>
</p>
<pre><code>/* Backspace.  Delete last char                                    */ <br>          /*******************************************************************/ <br>          if (data_offset &gt; 0) <br>          { <br>            data_offset--; <br>          } <br>        } <br>        else if (input_char != 0) <br>        { <br>#ifdef WIN32 <br>          WriteConsole (std_output, &amp;input_char, 1, &amp;no_read, NULL); <br>#endif <br>          write_data[data_offset++] = (UCHAR) input_char; <br>        } <br>      } <br>    } <br>  }  /* if (kbhit())                                                         */ <br> <br>  return(data_to_send); <br>}  /* do_keyboard_stuff                                                      */ <br> <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      do_send                                                        */ <br>/*                                                                           */ <br>/* Purpose:   issue a write verb                                             */ <br>/*                                                                           */ <br>/* Returns:   BOOL - TRUE =&gt; data sent OK                                    */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: convert data to EBCDIC and send it on the right session        */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>BOOL do_send (void) <br> <br>{ <br>  BOOL ok; <br> <br>  ok = TRUE; <br> <br> <br>  /***************************************************************************/ <br>  /* Set up the vcb                                                          */ <br>  /***************************************************************************/ <br>  memset(&amp;other_verb, 0, sizeof(other_verb)); <br>  other_verb.common.lua_verb             = LUA_VERB_SLI; <br>  other_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON) + <br>                         sizeof(other_verb.specific.lua_sequence_number); <br>  other_verb.common.lua_opcode           = LUA_OPCODE_SLI_SEND; <br>  other_verb.common.lua_sid              = sid; <br>  other_verb.common.lua_message_type     = LUA_MESSAGE_TYPE_LU_DATA; <br>  other_verb.common.lua_data_length      = write_len; <br>  other_verb.common.lua_data_ptr         = (char far *) write_data; <br>  other_verb.common.lua_post_handle      = SENDPOST; <br>  other_verb.common.lua_rh.dr1i          = 1; <br> <br>  /***************************************************************************/ <br>  /* On the LU session we must add the &lt;enter&gt; key prefix.  All inbound      */ <br>  /* requests flow RQE with the BBI and CDI flags set depending on the       */ <br>  /* current session state.                                                  */ <br>  /***************************************************************************/ <br>  other_verb.common.lua_rh.ri          = 1; <br>  if (send_state == BETB) <br>  { <br>    /*************************************************************************/ <br>    /* Between bracket, so open bracket and give direction.  Note that we    */ <br>    /* can do this since we will always be contention winner.                */ <br>    /*************************************************************************/ <br>    other_verb.common.lua_rh.bbi         = 1; <br>    other_verb.common.lua_rh.cdi         = 1; <br>    send_state = RECV; <br>  } <br>  else if (send_state = SEND) <br>  { <br>    /*************************************************************************/ <br>    /* In bracket and we have direction, so simply give direction.           */ <br>    /*************************************************************************/ <br>    other_verb.common.lua_rh.cdi         = 1; <br>    send_state = RECV; <br>  } <br>  else <br>  { <br>    /*************************************************************************/ <br>    /* In bracket and we do not have direction, so do not send.              */ <br>    /*************************************************************************/ <br>    printf("Wait\n"); <br>    ok = FALSE; <br>  } <br> <br>  if (ok) <br>  { <br>    /*************************************************************************/ <br>    /* Issue write verb                                                      */ <br>    /*************************************************************************/ <br>    SLI((LUA_VERB_RECORD FAR *) &amp;other_verb); <br> <br>    /*************************************************************************/ <br>    /* Reset write_data to point to correct point in write_array             */ <br>    /*************************************************************************/ <br>    write_data = write_array + WRITE_EXTRA; <br>  } <br> <br>  return(ok); <br>}  /* do_send ()                                                            */ <br> <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      parse_data                                                     */ <br>/*                                                                           */ <br>/* Purpose:   parse data from the host                                       */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN  data - pointer to data                                     */ <br>/*                                                                           */ <br>/* Operation: Looks through data for read partition query from host.  Could  */ <br>/* be expanded to format data from host                                      */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void parse_data (data, length) <br> <br>UCHAR FAR * data; <br>USHORT      length; <br>{ <br>  USHORT  field_length; <br> <br>  switch (*(data++)) <br>  { <br>    case 0xF3:                       /* write structured field               */ <br>      /***********************************************************************/ <br>      /* Next byte is the WCC - ignore                                       */ <br>      /***********************************************************************/ <br>      data++; <br>      length -= 2; <br> <br>      while (length &gt; 0) <br>      { <br>        /*********************************************************************/ <br>        /* We're just looking for a Read Partion query                       */ <br>        /*********************************************************************/ <br>        field_length = (((USHORT) *data) &lt;&lt; 8) || ((USHORT) *(data + 1)); <br>        if ((*(data+2) == 0x01) &amp;&amp;   /* Read partition                       */ <br>            (*(data+3) == 0xFF) &amp;&amp;   /* Query                                */ <br>            (*(data+4) == 0x02))     /* not a list                           */ <br>        { <br>          /*******************************************************************/ <br>          /* Build an RPQ and flag it to be sent                             */ <br>          /*******************************************************************/ <br>          rpq_state = RPQ_QUEUED; <br>        } <br>        data   += field_length; <br>        length -= field_length; <br>      } <br> <br> <br>      break; <br> <br>    default: <br>      break; <br> <br>  } <br>}  /* parse_data                                                             */ <br> <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      issue_rpq                                                      */ <br>/*                                                                           */ <br>/* Purpose:   issue a response to a Read partition query                     */ <br>/*                                                                           */ <br>/* Returns:   BOOL - TRUE =&gt; sent OK                                         */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: Builds and sends an RPQ reesponse                              */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>BOOL issue_rpq (void) <br> <br>{ <br>  BOOL issue_rpq; <br> <br>  issue_rpq = TRUE; <br>  /***************************************************************************/ <br>  /* Set up the vcb                                                          */ <br>  /***************************************************************************/ <br>  memset(&amp;rpq_verb, 0, sizeof(rpq_verb)); <br>  rpq_verb.common.lua_verb             = LUA_VERB_SLI; <br>  rpq_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON) + <br>                         sizeof(rpq_verb.specific.lua_sequence_number); <br>  rpq_verb.common.lua_opcode           = LUA_OPCODE_SLI_SEND; <br>  rpq_verb.common.lua_sid              = sid; <br>  rpq_verb.common.lua_message_type     = LUA_MESSAGE_TYPE_LU_DATA; <br>  rpq_verb.common.lua_data_length      = RPQ_LENGTH; <br>  rpq_verb.common.lua_data_ptr         = (char far *) rpq_data; <br>  rpq_verb.common.lua_post_handle      = RPQPOST; <br>  rpq_verb.common.lua_rh.dr1i          = 1; <br> <br>  /***************************************************************************/ <br>  /* On the LU session we must add the &lt;enter&gt; key prefix.  All inbound      */ <br>  /* requests flow RQE with the BBI and CDI flags set depending on the       */ <br>  /* current session state.                                                  */ <br>  /***************************************************************************/ <br>  rpq_verb.common.lua_flag1.lu_norm  = 0; <br>  rpq_verb.common.lua_rh.ri          = 1; <br>  if (send_state == BETB) <br>  { <br>    /*************************************************************************/ <br>    /* Between bracket, so open bracket and give direction.  Note that we    */ <br>    /* can do this since we will always be contention winner.                */ <br>    /*************************************************************************/ <br>    rpq_verb.common.lua_rh.bbi         = 1; <br>    rpq_verb.common.lua_rh.cdi         = 1; <br>    send_state = RECV; <br>  } <br>  else if (send_state = SEND) <br>  { <br>    /*************************************************************************/ <br>    /* In bracket and we have direction, so simply give direction.           */ <br>    /*************************************************************************/ <br>    rpq_verb.common.lua_rh.cdi         = 1; <br>    send_state = RECV; <br>  } <br>  else <br>  { <br>    /*************************************************************************/ <br>    /* In bracket and we do not have direction, so do not send.              */ <br>    /*************************************************************************/ <br>    printf("Wait\n"); <br>    issue_rpq = FALSE; <br>  } <br> <br>  if (issue_rpq) <br>  { <br>    SLI((LUA_VERB_RECORD FAR *) &amp;rpq_verb); <br>  } <br> <br>  return(issue_rpq); <br>}  /* issue_rpq                                                              */ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
