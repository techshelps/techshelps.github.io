<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WSLI3270.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5137"></a>WSLI3270.C</h2>
<pre><code>/**MOD+***********************************************************************/ <br>/* Module:  wsli3270.c                                                       */ <br>/*                                                                           */ <br>/* Purpose: Simple 3270 emulator                                             */ <br>/*                                                                           */ <br>/* (C) COPYRIGHT DATA CONNECTION LIMITED 1991                                */ <br>/*                                                                           */ <br>/**MOD-***********************************************************************/ <br> <br> <br>/*****************************************************************************/ <br>/* SLI Sample Program                                                        */ <br>/*                                                                           */ <br>/* (C) Copyright 1990 - 1993 Data Connection Ltd.                            */ <br>/*                                                                           */ <br>/* This program is a crude 3270 emulator.  It uses the SLI API to access     */ <br>/* the LU session.  Outbound data from the host is displayed on the screen   */ <br>/* unformatted.  If the outbound data is an RQD request an automatic         */ <br>/* positive response is sent.  Inbound data can be entered at the keyboard   */ <br>/*                                                                           */ <br>/*                                                                           */ <br>/* The program is invoked with two parameters - the name of the LUA LU       */ <br>/* to use and a logon string.  This is must match an LUA LU in the           */ <br>/* configuration file.  This LU should be configured for a 327? on the host. */ <br>/*                                                                           */ <br>/* The program can only access hosts that use simple unformatted logon       */ <br>/* requests                                                                  */ <br>/*                                                                           */ <br>/* The CSV CONVERT function is used to convert data between ASCII and        */ <br>/* EBCDIC.  This uses the type G conversion table, so the environment        */ <br>/* variable COMTBLG must be set to point to a suitable file.                 */ <br>/*                                                                           */ <br>/* Keys that work are:                                                       */ <br>/*                                                                           */ <br>/*     Alt-1 to Alt-9 are PF1 to PF9                                         */ <br>/*     backspace                                                             */ <br>/*     Letters, numbers and symbols                                          */ <br>/*                                                                           */ <br>/*****************************************************************************/ <br> <br> <br>/*****************************************************************************/ <br>/* SYSTEM INCLUDES                                                           */ <br>/*****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;winlua.h&gt; <br>#include &lt;wincsv.h&gt; <br> <br>typedef unsigned char  UCHAR; <br>typedef unsigned short USHORT; <br>typedef unsigned long  ULONG; <br> <br> <br>/*****************************************************************************/ <br>/* Program constants                                                         */ <br>/*****************************************************************************/ <br>#define DATASIZE 4096                  /* Max size of RU                     */ <br> <br>#define BETB     1                     /* Between brackets                   */ <br>#define SEND     2                     /* In bracket and can send            */ <br>#define RECV     3                     /* In bracket, but cannot send        */ <br> <br>#define APPNAME                "WSLI3270" <br>#define SLI_WINDOW_MESSAGE     "WinSLI" <br> <br>#define DISPLAY_BUFFER_SIZE    3200    /* size of circular display buffer    */ <br> <br>/*****************************************************************************/ <br>/* State variables                                                           */ <br>/*                                                                           */ <br>/* We can only have one read or write verb outstanding per flow.  These      */ <br>/* state variables keep track of these verbs and what we need to do with     */ <br>/* them.                                                                     */ <br>/*****************************************************************************/ <br> <br>UINT  write_state; <br>#define NO_WRITE              1 <br>#define WRITE_OUTSTANDING     2        /* waiting for write to complete      */ <br>#define WRITE_QUEUED          3        /* have data to write                 */ <br> <br>UINT  read_state; <br>#define NO_READ               1 <br>#define READ_OUTSTANDING      2        /* read verb outstanding              */ <br>#define RSP_QUEUED            3        /* have a response to write           */ <br>#define RSP_OUTSTANDING       4        /* waiting for a response to complete */ <br> <br>UINT  rpq_state; <br>#define NO_RPQ                1 <br>#define RPQ_OUTSTANDING       2        /* waiting for an RPQ to complete     */ <br>#define RPQ_QUEUED            3        /* have RPQ to send                   */ <br> <br>/***************************************************************************/ <br>/* Global variables                                                        */ <br>/*                                                                         */ <br>/***************************************************************************/ <br>LUA_VERB_RECORD read_verb;             /* SLI recv verb                    */ <br>LUA_VERB_RECORD close_verb;             /* SLI recv verb                    */ <br>LUA_VERB_RECORD other_verb;            /* SLI open or send verb            */ <br>LUA_VERB_RECORD rpq_verb;              /* SLI_SEND for RPQs                */ <br> <br>UCHAR rpq_data[] = { <br> <br>  0x88, <br>  0x00, 0x0C, 0x81, 0x80, 0x80, 0x81, 0x85, 0x86, 0x87, 0x88, 0x95, 0xA6, <br> <br>  0x00, 0x17, 0x81, 0x81, 0x21, 0x00, 0x00, 0x50, 0x00, 0x18, 0x00, 0x00, <br>  0x0A, 0x02, 0xE5, 0x00, 0x02, 0x00, 0x6F, 0x09, 0x10, 0x07, 0x80, <br> <br>  0x00, 0x14, 0x81, 0x85, 0x02, 0x00, 0x09, 0x0E, 0x00, 0x00, 0x00, 0x00, <br>  0x07, 0x00, 0x00, 0x00, 0x02, 0xB9, 0x01, 0x1D, <br> <br>  0x00, 0x16, 0x81, 0x86, 0x00, 0x08, 0x00, 0xF4, 0xF1, 0x00, 0xF2, 0x00, <br>  0xF3, 0x00, 0xF4, 0x00, 0xF5, 0x00, 0xF6, 0x00, 0xF7, 0x00, <br> <br>  0x00, 0x0D, 0x81, 0x87, 0x04, 0x00, 0xF0, 0xF1, 0x00, 0xF2, 0x00, 0xF4, <br>  0x00, <br> <br>  0x00, 0x07, 0x81, 0x88, 0x00, 0x01, 0x02, <br> <br>  0x00, 0x0C, 0x81, 0x95, 0x00, 0x00, 0x7F, 0xFF, 0x7F, 0xFF, 0x01, 0x01, <br> <br>  0x00, 0x11, 0x81, 0xA6, 0x00, 0x00, 0x0B, 0x01, 0x00, 0x00, 0x50, 0x00, <br>  0x18, 0x00, 0x50, 0x00, 0x18}; <br> <br>#define RPQ_LENGTH (sizeof(rpq_data)) <br> <br>UCHAR display_buffer[DISPLAY_BUFFER_SIZE] = {0}; <br>UINT  buffer_end   = 0;             /* end of data in display buffer         */ <br>BOOL  wrapped      = FALSE;         /* has buffer wrapped?                   */ <br> <br> <br>/*****************************************************************************/ <br>/* Global Variables                                                          */ <br>/*****************************************************************************/ <br>HANDLE hInst = 0;                   /* current instance                      */ <br>UINT   verb_complete = 0;           /* verb completion message               */ <br>HANDLE hWnd = 0;                    /* Handle to program window              */ <br> <br>BOOL   init_done = FALSE;           /* SLI_OPEN completed                    */ <br> <br> <br> <br>unsigned char read_data[DATASIZE];     /* Outbound RU                       */ <br>#define WRITE_EXTRA 6 <br>unsigned char write_array[DATASIZE + WRITE_EXTRA] = <br>                                          {0x7d, 0x40, 0x40, 0x11, 0x40, 0x40}; <br>                                       /* Inbound RU                         */ <br>unsigned char *write_data = write_array + WRITE_EXTRA; <br>                                       /* Pointer to inbound RU              */ <br>UINT data_offset = 0;                  /* offset into read_data              */ <br>UINT write_len   = 0;                  /* length of write data               */ <br> <br>struct convert convert_to_asc;         /* Outbound convert verb              */ <br>struct convert convert_to_ebc;         /* Inbound convert verb               */ <br> <br>BOOL terminating = FALSE;              /* are we already in closedown() ?    */ <br> <br>unsigned long sense = 0l;              /* sense code                         */ <br> <br>unsigned char lu_name[9] = "        "; /* LU name                            */ <br>unsigned long sid;                     /* SLI session ID                     */ <br>int send_state = BETB;                 /* LU session send state              */ <br> <br>#define LOGON_MAX  25                  /* maximum logon string length        */ <br> <br>UCHAR logon_data[LOGON_MAX+1] = {0}; <br>UCHAR logon_length   = 0; <br> <br>UCHAR  string[64]={0}; <br> <br> <br> <br> <br> <br> <br>void            csv_init            (void); <br>void            issue_init          (void); <br>void            issue_close        (void); <br>void            issue_read          (void); <br>void            other_done          (LUA_VERB_RECORD FAR *verb); <br>void            read_done           (LUA_VERB_RECORD FAR *verb); <br>void            issue_rsp           (unsigned long  sense); <br>void            rsp_done            (LUA_VERB_RECORD FAR *verb); <br>void            closedown           (void); <br>BOOL            do_write            (void); <br>void            wait_verb_complete  (LUA_VERB_RECORD FAR *verb); <br>void            set_semaphore       (LUA_VERB_RECORD FAR *verb); <br>BOOL            do_keyboard_stuff   (UINT, UCHAR); <br>BOOL            check_verb_complete (LUA_VERB_RECORD FAR *verb); <br>void            parse_data          (UCHAR FAR *, USHORT); <br>BOOL            issue_rpq           (void); <br>void            verb_complete_proc  (LUA_VERB_RECORD FAR * verb); <br>void          add_to_display_buffer (UCHAR FAR *); <br> <br>/*****************************************************************************/ <br>/* Windows function prototypes.                                              */ <br>/*****************************************************************************/ <br>int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int); <br>long FAR PASCAL WndProc(HWND, UINT, UINT, LONG); <br> <br> <br> <br> <br>/***PROC+*********************************************************************/ <br>/* Name:     WinMain                                                         */ <br>/*                                                                           */ <br>/* Purpose:  Main Windows function                                           */ <br>/*                                                                           */ <br>/* Params:   IN current instance handle                                      */ <br>/*           IN previous instance handle                                     */ <br>/*           IN pointer to command line                                      */ <br>/*           IN show window type                                             */ <br>/*                                                                           */ <br>/* Returns:  int                                                             */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br> <br>int PASCAL WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow) <br> <br>HINSTANCE hInstance;                         /* current instance             */ <br>HINSTANCE hPrevInstance;                     /* previous instance            */ <br>LPSTR     lpCmdLine;                         /* command line                 */ <br>int       nCmdShow;                          /* show-window type (open/icon) */ <br>{ <br>  /***************************************************************************/ <br>  /* LOCAL VARIABLES                                                         */ <br>  /***************************************************************************/ <br>  MSG   msg;                                 /* message                      */ <br>  int   xscreen; <br>  int   yscreen; <br>  int   delta; <br>  WNDCLASS class; <br>  LUADATA  LUAData; <br>  UINT  cmdlength;                           /* length of command line       */ <br>  UINT  lu_name_length;                      /* length of LU name            */ <br> <br> <br>  if (!hPrevInstance) <br>  { <br>    class.style         = CS_HREDRAW | CS_VREDRAW; <br>    class.lpfnWndProc   = (WNDPROC)WndProc; <br>    class.cbClsExtra    = 0; <br>    class.cbWndExtra    = 0; <br>    class.hInstance     = hInstance; <br>    class.hIcon         = LoadIcon(NULL, IDI_APPLICATION); <br>    class.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    class.hbrBackground = GetStockObject(WHITE_BRUSH); <br>    class.lpszMenuName  = NULL; <br>    class.lpszClassName = APPNAME; <br> <br>    if (!RegisterClass(&amp;class)) <br>    { <br>      return (0); <br>    } <br>  } <br> <br>  /***************************************************************************/ <br>  /* save current instance handle                                            */ <br>  /***************************************************************************/ <br>  hInst = hInstance; <br> <br>  /***************************************************************************/ <br>  /* Set initial states                                                      */ <br>  /***************************************************************************/ <br>  write_state = NO_WRITE; <br>  read_state  = NO_READ; <br>  rpq_state   = NO_RPQ; <br> <br>  /***************************************************************************/ <br>  /* get details of display                                                  */ <br>  /***************************************************************************/ <br>  xscreen = GetSystemMetrics(SM_CXSCREEN); <br>  yscreen = GetSystemMetrics(SM_CYSCREEN); <br> <br>  /***************************************************************************/ <br>  /* invent somewhere to put window                                          */ <br>  /***************************************************************************/ <br>  delta = xscreen / 100; <br> <br>  /***************************************************************************/ <br>  /* create display window                                                   */ <br>  /***************************************************************************/ <br>  hWnd = CreateWindow(APPNAME,                    /* window class            */ <br>        "SLI3270",                                /* window name             */ <br>        WS_OVERLAPPEDWINDOW,                      /* window style            */ <br>        (xscreen/2) + delta,                      /* x position              */ <br>        yscreen / 8,                              /* y position              */ <br>        (xscreen / 2) - (delta * 2),              /* width                   */ <br>        3 * yscreen / 4,                          /* height                  */ <br>        NULL,                                     /* parent handle           */ <br>        NULL,                                     /* menu or child ID        */ <br>        hInstance,                                /* instance                */ <br>        NULL);                                    /* additional info         */ <br> <br>  if (!hWnd) <br>  { <br>    return (0); <br>  } <br> <br>  ShowWindow(hWnd, nCmdShow);                     /* Shows the window        */ <br>  UpdateWindow(hWnd);                             /* Sends WM_PAINT message  */ <br> <br> <br>  /***************************************************************************/ <br>  /* Register message used for async completion                              */ <br>  /***************************************************************************/ <br>  verb_complete = RegisterWindowMessage(SLI_WINDOW_MESSAGE); <br> <br>  if (verb_complete == 0) <br>  { <br>    return (0); <br>  } <br> <br>  WinSLIStartup (0x0001, &amp;LUAData); <br> <br>  /***************************************************************************/ <br>  /* Issue SLI_OPEN to get the ball rolling.  Setup up the LU name           */ <br>  /***************************************************************************/ <br>  cmdlength = _fstrlen(lpCmdLine); <br>  for (lu_name_length = 0; lu_name_length &lt; cmdlength; lu_name_length++) <br>  { <br>    if (lpCmdLine[lu_name_length] == ' ') <br>    { <br>      break; <br>    } <br>    else <br>    { <br>      lu_name[lu_name_length] = lpCmdLine[lu_name_length]; <br>    } <br>  } <br>  if (lu_name_length == cmdlength) <br>  { <br>    /*************************************************************************/ <br>    /* Need  a logon string                                                  */ <br>    /*************************************************************************/ <br>    closedown(); <br>  } <br>  else <br>  { <br>    while (lpCmdLine[lu_name_length] == ' ') <br>    { <br>      lu_name_length++; <br>    } <br>    logon_length = _fstrlen(lpCmdLine + lu_name_length); <br>    _fstrncpy ((UCHAR FAR *)logon_data, <br>               lpCmdLine + lu_name_length, <br>               logon_length); <br>    convert_to_ebc.opcode       = SV_CONVERT; <br>    convert_to_ebc.direction    = SV_ASCII_TO_EBCDIC; <br>    convert_to_ebc.char_set     = SV_G; <br>    convert_to_ebc.source       = logon_data; <br>    convert_to_ebc.target       = logon_data; <br>    convert_to_ebc.len          = (unsigned short) logon_length; <br>    ACSSVC_C((LONG)((UCHAR FAR *)&amp;convert_to_ebc)); <br> <br>    /*************************************************************************/ <br>    /* Set up CSV convert verbs                                              */ <br>    /*************************************************************************/ <br>    csv_init(); <br> <br>    issue_init (); <br>  } <br> <br>  while(GetMessage(&amp;msg,NULL,0,0)) <br>  { <br>    TranslateMessage(&amp;msg); <br>    DispatchMessage(&amp;msg); <br>  } <br> <br>  return msg.wParam;         /* save exit parameter for return               */ <br>} <br> <br>/***PROC+*********************************************************************/ <br>/* Name:     WndProc                                                         */ <br>/*                                                                           */ <br>/* Purpose:  Windows call-back routine                                       */ <br>/*                                                                           */ <br>/* Params:   IN window handle                                                */ <br>/*           IN message type                                                 */ <br>/*           IN additional information 1                                     */ <br>/*           IN additional information 2                                     */ <br>/*                                                                           */ <br>/* Returns:  long                                                            */ <br>/*                                                                           */ <br>/* Operation:set up window characteristics and register it                   */ <br>/*           return success or failure                                       */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br> <br>long FAR PASCAL WndProc(hWnd, message, wParam, lParam) <br>HWND hWnd;                                /* window handle                   */ <br>UINT message;                             /* type of message                 */ <br>UINT wParam;                              /* additional information          */ <br>LONG lParam;                              /* additional information          */ <br>{ <br>  /***************************************************************************/ <br>  /* LOCAL VARIABLES                                                         */ <br>  /***************************************************************************/ <br>  HDC          hDC;              /* handle to our device context             */ <br>  TEXTMETRIC   tm;               /* holds info on the current font           */ <br>  PAINTSTRUCT  ps;               /*  paint structure                         */ <br>  RECT         rc;               /* holds info on the size oof our window    */ <br>  ULONG        width;            /* width of window in chars                 */ <br>  ULONG        height;           /* height of window in chars                */ <br>  UINT         buffer_offset;    /* offset withing display buffer            */ <br>  UINT         buffer_length;    /* length of data in buffer                 */ <br>  UINT         out_length;       /* lngth of text to output                  */ <br>  UINT         out_length2;      /* and again                                */ <br>  static int   xChar, yChar;     /* width &amp; height of the average char       */ <br>  int          position;         /* number of lines down the screen          */ <br>  BOOL         whole_data;       /* do we have data to send?                 */ <br> <br>  if ((message == verb_complete) &amp;&amp; <br>      (!terminating)) <br>  { <br>    /*************************************************************************/ <br>    /* Message is SLI verb completed.  We are not terminating, so process    */ <br>    /* the message.                                                          */ <br>    /*************************************************************************/ <br>    verb_complete_proc ((LUA_VERB_RECORD FAR *) lParam); <br>    return(0l); <br>  } <br> <br>  switch (message) <br>  { <br>    case WM_CREATE: <br>      /***********************************************************************/ <br>      /* Window creation message.  Get some infomation about our font and    */ <br>      /* save it for later                                                   */ <br>      /***********************************************************************/ <br>      hDC= GetDC(hWnd); <br>      GetTextMetrics (hDC, &amp;tm); <br>      xChar = (int)tm.tmAveCharWidth; <br>      yChar = (int)(tm.tmHeight + tm.tmExternalLeading); <br>      ReleaseDC(hWnd, hDC); <br>      return 0l; <br>      break; <br> <br>    case WM_CHAR: <br>    case WM_SYSCHAR: <br>      /***********************************************************************/ <br>      /* Character or Alt+char hit                                           */ <br>      /***********************************************************************/ <br>      if ((init_done)                 &amp;&amp; <br>          (!terminating)              &amp;&amp; <br>          (write_state == NO_WRITE)   &amp;&amp; <br>          (rpq_state   == NO_RPQ)     &amp;&amp; <br>          (read_state  != RSP_QUEUED) &amp;&amp; <br>          (read_state  != RSP_OUTSTANDING)) <br>      { <br>        /*********************************************************************/ <br>        /* Someone pressed a key and we are in a state to deal with it       */ <br>        /*********************************************************************/ <br>        whole_data = do_keyboard_stuff (message, (UCHAR)wParam); <br>        if (whole_data) <br>        { <br>          /*******************************************************************/ <br>          /* We have data to send                                            */ <br>          /* Attempt to write the data out                                   */ <br>          /*******************************************************************/ <br>          if (do_write()) <br>          { <br>            write_state = WRITE_OUTSTANDING; <br>          } <br>          else <br>          { <br>            write_state = WRITE_QUEUED; <br>          } <br>        } <br>        return(0l); <br>      } <br>      break; <br> <br>    case WM_PAINT: <br>      BeginPaint (hWnd, &amp;ps); <br>      /***********************************************************************/ <br>      /* Determine the size of the Window in characters                      */ <br>      /***********************************************************************/ <br>      GetClientRect (hWnd, &amp;rc); <br>      height = rc.bottom / yChar; <br>      width  = rc.right  / xChar; <br>      /***********************************************************************/ <br>      /* subtract 2 from height for the status line                          */ <br>      /***********************************************************************/ <br>      height -= 2; <br>      /***********************************************************************/ <br>      /* Work out how early in the buffer we can start                       */ <br>      /***********************************************************************/ <br>      if (!wrapped) <br>      { <br>        /*********************************************************************/ <br>        /* buffer is not wrapped                                             */ <br>        /*********************************************************************/ <br>        buffer_length = buffer_end; <br>        buffer_offset = (buffer_length &gt; (width * height)) ? <br>                         buffer_end - (width * height) : <br>                         0; <br>      } <br>      else <br>      { <br>        /*********************************************************************/ <br>        /* buffer is wrapped                                                 */ <br>        /*********************************************************************/ <br>        buffer_length = DISPLAY_BUFFER_SIZE; <br>        if (buffer_length &gt; width * height) <br>        { <br>          /*******************************************************************/ <br>          /* buffer is too big.  Work out where best to start in the buffer/ */ <br>          /*******************************************************************/ <br>          if (buffer_end &gt; width * height) <br>          { <br>            buffer_offset = buffer_end - (width * height); <br>          } <br>          else <br>          { <br>            buffer_offset = DISPLAY_BUFFER_SIZE + <br>                            buffer_end - <br>                            (width * height); <br>          } <br>        } <br>        else <br>        { <br>          /*******************************************************************/ <br>          /* We can fit everything in                                        */ <br>          /*******************************************************************/ <br>          buffer_offset = buffer_end; <br>        } <br>      } <br>      /***********************************************************************/ <br>      /* We've worked out where to start printing from, so start printing    */ <br>      /***********************************************************************/ <br>      position = 0; <br>      out_length = width; <br>      if (buffer_offset &gt; buffer_end) <br>      { <br>        while (buffer_offset &lt; DISPLAY_BUFFER_SIZE) <br>        { <br>          if (DISPLAY_BUFFER_SIZE - buffer_offset &lt; width) <br>          { <br>            out_length = DISPLAY_BUFFER_SIZE - buffer_offset; <br>          } <br>          else <br>          { <br>            out_length = width; <br>          } <br>          TextOut(ps.hdc, <br>                  0, <br>                  yChar * position, <br>                  display_buffer + buffer_offset, <br>                  out_length); <br>          buffer_offset += out_length; <br>          position++; <br>        } <br>        buffer_offset = 0; <br>      } <br>      /***********************************************************************/ <br>      /* If last line printed was a partial line, print the rest of the line */ <br>      /***********************************************************************/ <br>      if (out_length &lt; width) <br>      { <br>        out_length2 = out_length; <br>        if (buffer_end &lt; (width - out_length)) <br>        { <br>          out_length = buffer_end; <br>        } <br>        else <br>        { <br>          out_length = width - out_length; <br>        } <br>        TextOut(ps.hdc, <br>                xChar * out_length2, <br>                yChar * (position - 1), <br>                display_buffer, <br>                out_length); <br>        buffer_offset += out_length; <br> <br>      } <br>      /***********************************************************************/ <br>      /* Now print to the end of the buffer                                  */ <br>      /***********************************************************************/ <br>      while (buffer_offset &lt; buffer_end) <br>      { <br>        if (buffer_end - buffer_offset &lt; width) <br>        { <br>          out_length = buffer_end - buffer_offset; <br>        } <br>        else <br>        { <br>          out_length = width; <br>        } <br>        TextOut(ps.hdc, <br>                0, <br>                yChar * position, <br>                display_buffer + buffer_offset, <br>                out_length); <br>        buffer_offset += out_length; <br>        position++; <br>      } <br>      /***********************************************************************/ <br>      /* Now fill in the status line                                         */ <br>      /***********************************************************************/ <br>      out_length  = wsprintf (string, <br>                              "%s", <br>                   (UCHAR FAR *)((send_state == BETB) ? "BETB" : "INB")); <br>      TextOut(ps.hdc, <br>              0, <br>              (UINT) (yChar * (height + 2)), <br>              string, <br>              out_length); <br>      /***********************************************************************/ <br>      /* Now write the input line.  Only in NO_WRITE state, o.w.  data is in */ <br>      /* EBCDIC                                                              */ <br>      /***********************************************************************/ <br>      if (write_state == NO_WRITE) <br>      { <br>        TextOut(ps.hdc, <br>                0, <br>                (UINT) (yChar * (height+1)), <br>                write_data, <br>                data_offset); <br>      } <br>      EndPaint(hWnd, &amp;ps); <br>      break; <br> <br>    case WM_CLOSE: <br>      if (!terminating) <br>      { <br>        /*********************************************************************/ <br>        /* Tell the SLI we are going                                         */ <br>        /*********************************************************************/ <br>        terminating = TRUE; <br>        issue_close(); <br>        WinSLICleanup(); <br>      } <br>      break; <br> <br>    case WM_DESTROY: </code></pre>
<p>
</p>
<pre><code>PostQuitMessage(0); <br>      return 0l; <br>      break; <br> <br>    default: <br>      break; <br>  } <br>  return (DefWindowProc(hWnd, message, wParam, lParam)); <br>} <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      verb_complete_proc                                             */ <br>/*                                                                           */ <br>/* Purpose:   deal with verb completion                                      */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN verb - pointer to completed verb                            */ <br>/*                                                                           */ <br>/* Operation: Determine which verb has completed and perform the appropriate */ <br>/* action                                                                    */ <br>/**PROC-**********************************************************************/ <br>VOID verb_complete_proc (verb) <br> <br>LUA_VERB_RECORD FAR * verb; <br>{ <br> <br>  switch (verb-&gt;common.lua_opcode) <br>  { <br> <br>    case LUA_OPCODE_SLI_CLOSE: <br>      break; <br> <br>    case LUA_OPCODE_SLI_OPEN: <br>      /***********************************************************************/ <br>      /* Received ACTLU.  Save the SID for use on other verbs, flag init     */ <br>      /* done so that we can write data, and issue first read                */ <br>      /***********************************************************************/ <br>      sid = other_verb.common.lua_sid; <br>      init_done = TRUE; <br>      issue_read(); <br>      break; <br> <br>    case LUA_OPCODE_SLI_RECEIVE: <br>      /***********************************************************************/ <br>      /* Read completed.  Call read dne processor to display data and        */ <br>      /* determine if a response is required.                                */ <br>      /* If no response is required issue a new read                         */ <br>      /* if a response is required issue the response if we can              */ <br>      /***********************************************************************/ <br>      read_done (verb); <br>      if (terminating == TRUE) <br>        break; <br>      if (read_state == NO_READ) <br>      { <br>        /*********************************************************************/ <br>        /* No work to do, issue a new read verb                              */ <br>        /*********************************************************************/ <br>        read_state = READ_OUTSTANDING; <br>        issue_read(); <br>      } <br>      else if ((read_state  == RSP_QUEUED) &amp;&amp; <br>               (write_state != WRITE_OUTSTANDING) &amp;&amp; <br>               (rpq_state   != RPQ_OUTSTANDING)) <br>      { <br>        /*********************************************************************/ <br>        /* We need to send a response to the RU we have just received.  The  */ <br>        /* write flow is free, so send it                                    */ <br>        /*********************************************************************/ <br>        read_state = RSP_OUTSTANDING; <br>        issue_rsp (sense); <br>      } <br> <br>      if ((rpq_state   == RPQ_QUEUED) &amp;&amp; <br>          (write_state != WRITE_OUTSTANDING) &amp;&amp; <br>          (read_state  != RSP_OUTSTANDING)) <br>      { <br>        /*********************************************************************/ <br>        /* We need to send a read partition query response and we can, so do */ <br>        /* it.                                                               */ <br>        /*********************************************************************/ <br>        if (issue_rpq()) <br>        { <br>          rpq_state = RPQ_OUTSTANDING; <br>        } <br>      } <br>      break; <br> <br>    case LUA_OPCODE_SLI_SEND: <br>      /***********************************************************************/ <br>      /* Determine what kind of SLI_SEND completed                          */ <br>      /* either                                                              */ <br>      /* -  writing user data                                                */ <br>      /* -  writing a RPQ response                                           */ <br>      /* -  writing a RSP to host data                                       */ <br>      /***********************************************************************/ <br>      if (write_state == WRITE_OUTSTANDING) <br>      { <br>        write_state = NO_WRITE; <br>        write_data[0] = '\0'; <br>      } <br>      else if (rpq_state == RPQ_OUTSTANDING) <br>      { <br>        rpq_state = NO_RPQ; <br>      } <br>      else if (read_state == RSP_OUTSTANDING) <br>      { <br>        read_state = NO_READ; <br>        issue_read(); <br>      } <br>      /***********************************************************************/ <br>      /* Perform the next action depending on what work their is to do.      */ <br>      /***********************************************************************/ <br>      if (read_state == RSP_QUEUED) <br>      { <br>        /*********************************************************************/ <br>        /* We need to issue a RSP to an RU we have received.  Do it          */ <br>        /*********************************************************************/ <br>        read_state = RSP_OUTSTANDING; <br>        issue_rsp (sense); <br>      } <br>      else if (rpq_state == RPQ_QUEUED) <br>      { <br>        /*********************************************************************/ <br>        /* We need to issue a response to a read partion query.  Send it if  */ <br>        /* the bracket state allows.                                         */ <br>        /*********************************************************************/ <br>        if (issue_rpq()) <br>        { <br>          rpq_state = RPQ_OUTSTANDING; <br>        } <br>      } <br>      else if (write_state == WRITE_QUEUED) <br>      { <br>        /*********************************************************************/ <br>        /* We have user data to send to the Host.  Send it if the bracket    */ <br>        /* state allows                                                      */ <br>        /*********************************************************************/ <br>        if (do_write()) <br>        { <br>          write_state = WRITE_OUTSTANDING; <br>        } <br>      } <br>      break; <br> <br>    default: <br>      break; <br>  } <br>}  /* verb_complete_proc                                                     */ <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      csv_init                                                       */ <br>/*                                                                           */ <br>/* Purpose:   set up CSV convert verbs                                       */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: sets uup two CSV convert verbs, one in each direction.  Only   */ <br>/* the length needs to be set when the verb is called                        */ <br>/**PROC-**********************************************************************/ <br>void csv_init (void) <br>{ <br>  convert_to_asc.opcode       = SV_CONVERT; <br>  convert_to_asc.direction    = SV_EBCDIC_TO_ASCII; <br>  convert_to_asc.char_set     = SV_G; <br>  convert_to_asc.source       = read_data; <br>  convert_to_asc.target       = read_data; <br> <br>  convert_to_ebc.opcode       = SV_CONVERT; <br>  convert_to_ebc.direction    = SV_ASCII_TO_EBCDIC; <br>  convert_to_ebc.char_set     = SV_G; <br>  convert_to_ebc.source       = write_data; <br>  convert_to_ebc.target       = write_data; <br>}  /* csv_init                                                               */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      issue_init                                                     */ <br>/*                                                                           */ <br>/* Purpose:   build a verb and send it                                       */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    None                                                           */ <br>/*                                                                           */ <br>/* Operation: Build an OPEN verb and issue it.                               */ <br>/**PROC-**********************************************************************/ <br>void issue_init(void) <br>{ <br>  memset(&amp;other_verb, 0, sizeof(other_verb)); <br>  other_verb.common.lua_verb             = LUA_VERB_SLI; <br>  other_verb.common.lua_opcode           = LUA_OPCODE_SLI_OPEN; <br>  other_verb.common.lua_verb_length    = sizeof(struct LUA_COMMON)+ <br>                          sizeof(other_verb.specific.open.lua_init_type) + <br>                          sizeof(other_verb.specific.open.lua_resv65) + <br>                          sizeof(other_verb.specific.open.lua_wait) + <br>                          sizeof(other_verb.specific.open.lua_ending_delim); <br>  memcpy(other_verb.common.lua_luname, lu_name, 8); <br>  other_verb.specific.open.lua_init_type = LUA_INIT_TYPE_SEC_LOG; <br>  other_verb.common.lua_data_length      = logon_length; <br>  other_verb.common.lua_data_ptr         = logon_data; <br>  other_verb.specific.open.lua_open_extension[0].lua_routine_type = <br>                                                          LUA_ROUTINE_TYPE_END; <br> <br>  WinSLI(hWnd, (LUA_VERB_RECORD FAR *) &amp;other_verb); <br> <br>  /***************************************************************************/ <br>  /* The sid is valid immediately.  Save it now.                             */ <br>  /***************************************************************************/ <br>  sid = other_verb.common.lua_sid; <br> <br>  if (!other_verb.common.lua_flag2.async) <br>  { <br>    /*************************************************************************/ <br>    /* Verb completed immediately.  Post our own completion message          */ <br>    /*************************************************************************/ <br>    PostMessage (hWnd, verb_complete, 0, (LPARAM) (VOID FAR *)&amp;other_verb); <br>  } <br> <br>}  /* issue_init                                                             */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      issue_read                                                     */ <br>/*                                                                           */ <br>/* Purpose:   build a read verb and send it                                  */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: Build a read verb for all flows and issue it                   */ <br>/**PROC-**********************************************************************/ <br>void issue_read (void) <br>{ <br>  memset(&amp;read_verb, 0, sizeof(read_verb)); <br>  memset(read_data, 0, DATASIZE); <br>  read_verb.common.lua_verb             = LUA_VERB_SLI; <br>  read_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON); <br>  read_verb.common.lua_opcode           = LUA_OPCODE_SLI_RECEIVE; <br>  read_verb.common.lua_sid              = sid; <br>  read_verb.common.lua_max_length       = DATASIZE; <br>  read_verb.common.lua_data_ptr         = (char FAR *) read_data; <br>  read_verb.common.lua_flag1.lu_norm    = 1; <br>  read_verb.common.lua_flag1.lu_exp     = 1; <br>  read_verb.common.lua_flag1.sscp_norm  = 1; <br>  read_verb.common.lua_flag1.sscp_exp   = 1; <br>  WinSLI(hWnd, (LUA_VERB_RECORD FAR *)&amp;(read_verb)); <br>  if (!read_verb.common.lua_flag2.async) <br>  { <br>    /*************************************************************************/ <br>    /* Verb completed immediately.  Post our own completion message          */ <br>    /*************************************************************************/ <br>    PostMessage (hWnd, verb_complete, 0, (LPARAM) (VOID FAR *)&amp;read_verb); <br>  } <br> <br>}  /* issue_read                                                             */ <br> <br>void issue_close (void) <br>{ <br>  memset(&amp;close_verb, 0, sizeof(close_verb)); <br>  memset(read_data, 0, DATASIZE); <br>  close_verb.common.lua_verb             = LUA_VERB_SLI; <br>  close_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON); <br>  close_verb.common.lua_opcode           = LUA_OPCODE_SLI_CLOSE; <br>  close_verb.common.lua_sid              = sid; <br>  WinSLI(hWnd, (LUA_VERB_RECORD FAR *)&amp;(close_verb)); <br>  if (!close_verb.common.lua_flag2.async) <br>  { <br>    /*************************************************************************/ <br>    /* Verb completed immediately.  Post our own completion message          */ <br>    /*************************************************************************/ <br>    PostMessage (hWnd, verb_complete, 0, (LPARAM) (VOID FAR *)&amp;close_verb); <br>  } <br> <br>}  /* issue_read                                                             */ <br> <br> <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      read_done                                                      */ <br>/*                                                                           */ <br>/* Purpose:   handle completed read verb                                     */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN verb - completed read verb                                  */ <br>/*                                                                           */ <br>/* Operation: If the completed verb contains data, first parse it and then   */ <br>/*            display it.                                                    */ <br>/*            If message is a BIND or an UNBIND, set the LU-LU session state */ <br>/*            accordingly                                                    */ <br>/*            Also check for EB, CD and change session state flags           */ <br>/**PROC-**********************************************************************/ <br>void read_done(verb) <br>LUA_VERB_RECORD FAR * verb; <br>{ <br>  BOOL           rsp_required = FALSE; /* is a resonse required              */ <br> <br>  sense = 0l; <br> <br>  if (verb-&gt;common.lua_prim_rc == LUA_OK) <br>  { <br>    if (verb-&gt;common.lua_message_type == LUA_MESSAGE_TYPE_LU_DATA) <br>    { <br>      if (verb-&gt;common.lua_data_length &gt; 0) <br>      { <br>        /*********************************************************************/ <br>        /* We now have to parse the data.  For the moment we only look for   */ <br>        /* RPQ requests.                                                     */ <br>        /*********************************************************************/ <br>        parse_data (read_data, (USHORT) (verb-&gt;common.lua_data_length)); <br> <br>        /*********************************************************************/ <br>        /* Display outbound data.                                            */ <br>        /*********************************************************************/ <br>        convert_to_asc.len = (unsigned short) verb-&gt;common.lua_data_length; <br>        ACSSVC_C((LONG)((UCHAR FAR *)&amp;convert_to_asc)); <br>        add_to_display_buffer (read_data); <br>      } <br> <br>      /***********************************************************************/ <br>      /* Set session state.                                                  */ <br>      /***********************************************************************/ <br>      if (verb-&gt;common.lua_rh.ebi) <br>      { <br>        send_state = BETB; <br>      } <br>      else if (verb-&gt;common.lua_rh.cdi) <br>      { <br>        send_state = SEND; <br>      } <br>      else <br>      { <br>        send_state = RECV; <br>      } <br>      InvalidateRect (hWnd, NULL, TRUE); <br>    } <br> <br>    /*************************************************************************/ <br>    /* Respond to any RQD request.                                           */ <br>    /*************************************************************************/ <br>    if ((verb-&gt;common.lua_message_type != LUA_MESSAGE_TYPE_RSP)  &amp;&amp; <br>        (verb-&gt;common.lua_rh.ri == 0))                  /* definite response */ <br>    { <br>      rsp_required = TRUE; <br>    } <br>  } <br>  else if (verb-&gt;common.lua_prim_rc != LUA_STATUS) <br>  { <br>    closedown(); <br>  } <br> <br>  /***************************************************************************/ <br>  /* Continue processing with either another read or a write positive rsp.   */ <br>  /* (The callback from issuing response will then issue another read) If    */ <br>  /* we've already gone into closedown, stop here                            */ <br>  /***************************************************************************/ <br>  if (!terminating) <br>  { <br>    if (rsp_required) <br>    { <br>      read_state = RSP_QUEUED; <br>    } <br>    else <br>    { <br>      read_state = NO_READ; <br>    } <br>  } <br>}  /* read_done                                                              */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      issue_rsp                                                      */ <br>/*                                                                           */ <br>/* Purpose:   issue a response for a request from the host                   */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN sense - sense code for the response                         */ <br>/*                                                                           */ <br>/* Operation: Build a response and write it out.  Uses the read verb control */ <br>/*            block because it has the necessary information.                */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void issue_rsp(sense) <br>unsigned long sense; <br>{ <br>  read_verb.common.lua_opcode           = LUA_OPCODE_SLI_SEND; <br>  read_verb.common.lua_max_length       = 0; <br>  read_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON) + <br>                                sizeof(read_verb.specific.lua_sequence_number); <br>  read_verb.common.lua_rh.rri           = 1;         /* response             */ <br>  read_verb.common.lua_post_handle      = NULL; <br>  read_verb.common.lua_flag1.lu_norm    = 0; <br>  read_verb.common.lua_flag1.lu_exp     = 0; <br>  read_verb.common.lua_flag1.sscp_norm  = 0; <br>  read_verb.common.lua_flag1.sscp_exp   = 0; <br>  read_verb.common.lua_message_type     = LUA_MESSAGE_TYPE_RSP; <br>  memset(read_verb.common.lua_resv56, '\0', 7); <br> <br>#if 0 <br>  read_verb.common.lua_rh.eci           = 0; <br>  read_verb.common.lua_rh.bci           = 0; <br>  read_verb.common.lua_rh.dr1i          = 0; <br>  read_verb.common.lua_rh.dr2i          = 0; <br>  read_verb.common.lua_rh.qri           = 0; <br>  read_verb.common.lua_rh.pi            = 0; <br>  read_verb.common.lua_rh.bbi           = 0; <br>  read_verb.common.lua_rh.ebi           = 0; <br>  read_verb.common.lua_rh.cdi           = 0; <br>  read_verb.common.lua_rh.csi           = 0; <br>  read_verb.common.lua_rh.edi           = 0; <br>  read_verb.common.lua_rh.pdi           = 0; <br>#endif <br> <br>  /***************************************************************************/ <br>  /* If we have been given a sense code this must be a negative response     */ <br>  /***************************************************************************/ <br>  if (sense) <br>  { <br>    read_verb.common.lua_data_length      = 4; <br>    memcpy(read_data, &amp;sense, 4); <br>    read_verb.common.lua_rh.ri            = 1;       /* negative rsp         */ <br>  } <br>  else <br>  { <br>    read_verb.common.lua_data_ptr         = NULL; <br>    read_verb.common.lua_data_length      = 0; <br>    read_verb.common.lua_rh.ri            = 0;       /* positive rsp         */ <br>  } <br>  /***************************************************************************/ <br>  /* Send the response back on the flow from which the request came          */ <br>  /***************************************************************************/ <br>  if (read_verb.common.lua_flag2.lu_norm) <br>  { <br>    read_verb.common.lua_flag1.lu_norm = 1; <br>    read_verb.common.lua_flag2.lu_norm = 0; <br>  } <br>  else if (read_verb.common.lua_flag2.lu_exp) <br>  { <br>    read_verb.common.lua_flag1.lu_exp = 1; <br>    read_verb.common.lua_flag2.lu_exp = 0; <br>  } <br>  else if (read_verb.common.lua_flag2.sscp_norm) <br>  { <br>    read_verb.common.lua_flag1.sscp_norm = 1; <br>    read_verb.common.lua_flag2.sscp_norm = 0; <br>  } <br>  else if (read_verb.common.lua_flag2.sscp_exp) <br>  { <br>    read_verb.common.lua_flag1.sscp_exp = 1; <br>    read_verb.common.lua_flag2.sscp_exp = 0; <br>  } <br>  read_verb.common.lua_flag2.async = 0; <br>  /***************************************************************************/ <br>  /* Send out the verb                                                       */ <br>  /***************************************************************************/ <br>  WinSLI(hWnd, (LUA_VERB_RECORD FAR *)&amp;read_verb);     /* write the response */ <br>  if (!read_verb.common.lua_flag2.async) <br>  { <br>    /*************************************************************************/ <br>    /* Verb completed immediately.  Post our own completion message          */ <br>    /*************************************************************************/ <br>    PostMessage (hWnd, verb_complete, 0, (LPARAM) (VOID FAR *)&amp;read_verb); <br>  } <br>}  /* issue_rsp                                                              */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      rsp_done                                                       */ <br>/*                                                                           */ <br>/* Purpose:   handle completion of SLI_SEND, when SLI_SEND has written a     */ <br>/*            response                                                       */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN verb - completed verb                                       */ <br>/*                                                                           */ <br>/* Operation: If verb did not complete OK terminate                          */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void rsp_done (verb) <br>LUA_VERB_RECORD FAR * verb; <br>{ <br>  if (verb-&gt;common.lua_prim_rc != LUA_OK)   /* failed to write the response */ <br>  {                                         /* so stop here                 */ <br>    closedown(); <br>  } <br>}  /* rsp_done                                                               */ <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      closedown                                                      */ <br>/*                                                                           */ <br>/* Purpose:   terminate the application cleanly                              */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: Issue a WinSLICleanup() to tell SLI the we are about to go,    */ <br>/* and then post a close message so that we do.                              */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void closedown (void) <br>{ <br>  if (!terminating)                /* check we haven't already got here from */ <br>  {                                /* another section of the code            */ <br>    terminating = TRUE;            /* then make sure we can't get here again */ <br>    issue_close(); <br>    WinSLICleanup(); <br>    PostMessage (hWnd, WM_CLOSE, 0, 0l); <br>  } <br>}  /* closedown                                                              */ <br> <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      do_keyboard_stuff                                              */ <br>/*                                                                           */ <br>/* Purpose:   poll keyboard for data                                         */ <br>/*                                                                           */ <br>/* Returns:   BOOL - TRUE =&gt; we have data to send                            */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: Look for Alt-1 to Alt-9 and ascii chars.                       */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>BOOL do_keyboard_stuff (type, key) <br> <br>UINT  type; <br>UCHAR key; <br> <br>{ <br>  BOOL   data_to_send;             /* do we have data to send?               */ <br> <br>  data_to_send = FALSE; <br> <br>  if (type == WM_SYSCHAR) <br>  { <br>    /*************************************************************************/ <br>    /* Alt key pressed                                                       */ <br>    /*************************************************************************/ <br>    if ((key &gt;= '1') &amp;&amp; <br>        (key &lt;= '9')) <br>    { <br>      /***********************************************************************/ <br>      /* ALT-1 to ALT-9 0xF1 is the AID code for PF1.  Follow this with the  */ <br>      /* cursor address                                                      */ <br>      /***********************************************************************/ <br>      *write_data = 0xF1 + key - '1'; <br>      *(write_data + 1) = 0x40; <br>      *(write_data + 2) = 0x40; <br>      write_len = 3; <br>      data_to_send = TRUE; <br>    } <br>  } <br>  else <br>  { <br>    /*************************************************************************/ <br>    /* Ordinary ASCII char                                                   */ <br>    /* Key should be real data.  Add it to the string                        */ <br>    /*************************************************************************/ <br>    if (key == 13) <br>    { <br>      /***********************************************************************/ <br>      /* If user pressed return key then send the data.  Reset data_offset   */ <br>      /* for next data.                                                      */ <br>      /***********************************************************************/ <br>      write_data[data_offset++] = '\0'; <br>      data_to_send = TRUE; <br>      data_offset  = 0; <br> <br>      /***********************************************************************/ <br>      /* Convert data to EBCDIC                                              */ <br>      /***********************************************************************/ <br>      convert_to_ebc.len = (unsigned short) (strlen(write_data) ); <br>      if (convert_to_ebc.len &gt; 0) <br>      { <br>        ACSSVC_C((LONG)((UCHAR FAR *)&amp;convert_to_ebc)); <br>      } <br>      write_len = convert_to_ebc.len; <br> <br>      /***********************************************************************/ <br>      /* Allow for ENTER AID if necessary                                    */ <br>      /***********************************************************************/ <br>      write_data -= WRITE_EXTRA; <br>      write_len  += WRITE_EXTRA; <br>    } <br>    else if (key == 8) <br>    { <br>      /***********************************************************************/ <br>      /* Backspace.  Delete last char                                        */ <br>      /***********************************************************************/ <br>      if (data_offset &gt; 0) <br>      { <br>        data_offset--; <br>      } <br>    } <br>    else if (key != 0) <br>    { <br>      /***********************************************************************/ <br>      /* ASCII char.  Add it to the data buffer                              */ <br>      /***********************************************************************/ <br>      write_data[data_offset++] = (UCHAR) key; <br> <br>    } <br>    /*************************************************************************/ <br>    /* Invalidate our window so that the new data is displayed               */ <br>    /*************************************************************************/ <br>    InvalidateRect (hWnd, NULL, TRUE); <br>  } <br> <br> <br>  return(data_to_send); <br>}  /* do_keyboard_stuff                                                      */ <br> <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      do_write                                                       */ <br>/*                                                                           */ </code></pre>
<p>
</p>
<pre><code>/* Purpose:   issue a write verb                                             */ <br>/*                                                                           */ <br>/* Returns:   BOOL - TRUE =&gt; data sent OK                                    */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: convert data to EBCDIC and send it on the right session        */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>BOOL do_write (void) <br> <br>{ <br>  BOOL ok; <br> <br>  ok = TRUE; <br> <br> <br>  /***************************************************************************/ <br>  /* Set up the vcb                                                          */ <br>  /***************************************************************************/ <br>  memset(&amp;other_verb, 0, sizeof(other_verb)); <br>  other_verb.common.lua_verb             = LUA_VERB_SLI; <br>  other_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON) + <br>                         sizeof(other_verb.specific.lua_sequence_number); <br>  other_verb.common.lua_opcode           = LUA_OPCODE_SLI_SEND; <br>  other_verb.common.lua_message_type     = LUA_MESSAGE_TYPE_LU_DATA; <br>  other_verb.common.lua_sid              = sid; <br>  other_verb.common.lua_data_length      = write_len; <br>  other_verb.common.lua_data_ptr         = (char far *) write_data; <br>  other_verb.common.lua_rh.dr1i          = 1; <br> <br>  /***************************************************************************/ <br>  /* On the LU session we must add the &lt;enter&gt; key prefix.  All inbound      */ <br>  /* requests flow RQE with the BBI and CDI flags set depending on the       */ <br>  /* current session state.                                                  */ <br>  /***************************************************************************/ <br>  other_verb.common.lua_rh.ri          = 1; <br>  if (send_state == BETB) <br>  { <br>    /*************************************************************************/ <br>    /* Between bracket, so open bracket and give direction.  Note that we    */ <br>    /* can do this since we will always be contention winner.                */ <br>    /*************************************************************************/ <br>    other_verb.common.lua_rh.bbi         = 1; <br>    other_verb.common.lua_rh.cdi         = 1; <br>    send_state = RECV; <br>  } <br>  else if (send_state = SEND) <br>  { <br>    /*************************************************************************/ <br>    /* In bracket and we have direction, so simply give direction.           */ <br>    /*************************************************************************/ <br>    other_verb.common.lua_rh.cdi         = 1; <br>    send_state = RECV; <br>  } <br>  else <br>  { <br>    /*************************************************************************/ <br>    /* In bracket and we do not have direction, so do not send.              */ <br>    /*************************************************************************/ <br>    ok = FALSE; <br>  } <br> <br>  if (ok) <br>  { <br>    /*************************************************************************/ <br>    /* Issue write verb                                                      */ <br>    /*************************************************************************/ <br>    WinSLI(hWnd, (LUA_VERB_RECORD FAR *) &amp;other_verb); <br>    if (!other_verb.common.lua_flag2.async) <br>    { <br>      /***********************************************************************/ <br>      /* Verb completed immediately.  Post our own completion message        */ <br>      /***********************************************************************/ <br>      PostMessage (hWnd, verb_complete, 0, (LPARAM) (VOID FAR *)&amp;other_verb); <br>    } <br> <br>    /*************************************************************************/ <br>    /* Reset write_data to point to correct point in write_array             */ <br>    /*************************************************************************/ <br>    write_data = write_array + WRITE_EXTRA; <br>  } <br> <br>  return(ok); <br>}  /* do_write ()                                                            */ <br> <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      parse_data                                                     */ <br>/*                                                                           */ <br>/* Purpose:   parse data from the host                                       */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN  data - pointer to data                                     */ <br>/*                                                                           */ <br>/* Operation: Looks through data for read partition query from host.  Could  */ <br>/* be expanded to format data from host                                      */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void parse_data (data, length) <br> <br>UCHAR FAR * data; <br>USHORT      length; <br>{ <br>  USHORT  field_length; <br> <br>  switch (*(data++)) <br>  { <br>    case 0xF3:                       /* write structured field               */ <br>      /***********************************************************************/ <br>      /* Next byte is the WCC - ignore                                       */ <br>      /***********************************************************************/ <br>      data++; <br>      length -= 2; <br> <br>      while (length &gt; 0) <br>      { <br>        /*********************************************************************/ <br>        /* We're just looking for a Read Partion query                       */ <br>        /*********************************************************************/ <br>        field_length = (((USHORT) *data) &lt;&lt; 8) || ((USHORT) *(data + 1)); <br>        if ((*(data+2) == 0x01) &amp;&amp;   /* Read partition                       */ <br>            (*(data+3) == 0xFF) &amp;&amp;   /* Query                                */ <br>            (*(data+4) == 0x02))     /* not a list                           */ <br>        { <br>          /*******************************************************************/ <br>          /* Build an RPQ and flag it to be sent                             */ <br>          /*******************************************************************/ <br>          rpq_state = RPQ_QUEUED; <br>        } <br>        data   += field_length; <br>        length -= field_length; <br>      } <br> <br> <br>      break; <br> <br>    default: <br>      break; <br> <br>  } <br>}  /* parse_data                                                             */ <br> <br> <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      issue_rpq                                                      */ <br>/*                                                                           */ <br>/* Purpose:   issue a response to a Read partition query                     */ <br>/*                                                                           */ <br>/* Returns:   BOOL - TRUE =&gt; sent OK                                         */ <br>/*                                                                           */ <br>/* Params:    none                                                           */ <br>/*                                                                           */ <br>/* Operation: Builds and sends an RPQ reesponse                              */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>BOOL issue_rpq (void) <br> <br>{ <br>  BOOL issue_rpq; <br> <br>  issue_rpq = TRUE; <br>  /***************************************************************************/ <br>  /* Set up the vcb                                                          */ <br>  /***************************************************************************/ <br>  memset(&amp;rpq_verb, 0, sizeof(rpq_verb)); <br>  rpq_verb.common.lua_verb             = LUA_VERB_SLI; <br>  rpq_verb.common.lua_verb_length      = sizeof(struct LUA_COMMON) + <br>                         sizeof(rpq_verb.specific.lua_sequence_number); <br>  rpq_verb.common.lua_opcode           = LUA_OPCODE_SLI_SEND; <br>  rpq_verb.common.lua_sid              = sid; <br>  rpq_verb.common.lua_message_type     = LUA_MESSAGE_TYPE_LU_DATA; <br>  rpq_verb.common.lua_data_length      = RPQ_LENGTH; <br>  rpq_verb.common.lua_data_ptr         = (char far *) rpq_data; <br>  rpq_verb.common.lua_rh.dr1i          = 1; <br> <br>  /***************************************************************************/ <br>  /* All inbound requests flow RQD with the BBI and CDI flags set depending  */ <br>  /* on the current session state.                                           */ <br>  /***************************************************************************/ <br>  rpq_verb.common.lua_rh.ri          = 1; <br>  if (send_state == BETB) <br>  { <br>    /*************************************************************************/ <br>    /* Between bracket, so open bracket and give direction.  Note that we    */ <br>    /* can do this since we will always be contention winner.                */ <br>    /*************************************************************************/ <br>    rpq_verb.common.lua_rh.bbi         = 1; <br>    rpq_verb.common.lua_rh.cdi         = 1; <br>    send_state = RECV; <br>  } <br>  else if (send_state = SEND) <br>  { <br>    /*************************************************************************/ <br>    /* In bracket and we have direction, so simply give direction.           */ <br>    /*************************************************************************/ <br>    rpq_verb.common.lua_rh.cdi         = 1; <br>    send_state = RECV; <br>  } <br>  else <br>  { <br>    /*************************************************************************/ <br>    /* In bracket and we do not have direction, so do not send.              */ <br>    /*************************************************************************/ <br>    issue_rpq = FALSE; <br>  } <br> <br>  if (issue_rpq) <br>  { <br>    WinSLI(hWnd, (LUA_VERB_RECORD FAR *) &amp;rpq_verb); <br>    if (!rpq_verb.common.lua_flag2.async) <br>    { <br>      /***********************************************************************/ <br>      /* Verb completed immediately.  Post our own completion message        */ <br>      /***********************************************************************/ <br>      PostMessage (hWnd, verb_complete, 0, (LPARAM) (VOID FAR *)&amp;rpq_verb); <br>    } <br>  } <br> <br>  return(issue_rpq); <br>}  /* issue_rpq                                                              */ <br> <br>/**PROC+**********************************************************************/ <br>/* Name:      add_to_display_buffer                                          */ <br>/*                                                                           */ <br>/* Purpose:   add data to the display buffer                                 */ <br>/*                                                                           */ <br>/* Returns:   void                                                           */ <br>/*                                                                           */ <br>/* Params:    IN data - data to be displayed                                 */ <br>/*                                                                           */ <br>/* Operation: Add the zero terminated data string to the circular display    */ <br>/* buffer.  Cope with wrapping                                               */ <br>/*                                                                           */ <br>/**PROC-**********************************************************************/ <br>void add_to_display_buffer (data) <br> <br>UCHAR FAR * data; <br>{ <br>  UINT data_length;         /* length of new data to display                 */ <br>  BOOL need_to_wrap;        /* do we need to wrap to the start of the buffer */ <br>  UINT copy_length;         /* length of data to copy                        */ <br> <br> <br>  data_length = _fstrlen (data); <br> <br>  /***************************************************************************/ <br>  /* Work out whether the data will go over the end of the dispaly buffer.   */ <br>  /* If it will, wrap it back over the start of the buffer.                  */ <br>  /***************************************************************************/ <br>  need_to_wrap = (buffer_end + data_length &gt; DISPLAY_BUFFER_SIZE); <br> <br>  if (need_to_wrap) <br>  { <br>    copy_length = DISPLAY_BUFFER_SIZE - buffer_end; <br>    wrapped = TRUE; <br>  } <br>  else <br>  { <br>    copy_length = data_length; <br>  } <br> <br>  /***************************************************************************/ <br>  /* Copy as much data as will fit into the buffer                           */ <br>  /***************************************************************************/ <br>  _fmemcpy ((UCHAR FAR *) (display_buffer + buffer_end), <br>            data, <br>            copy_length); <br> <br>  /***************************************************************************/ <br>  /* If there is more data to copy, copy it to the start of the buffer       */ <br>  /* Set up the new end point.                                               */ <br>  /***************************************************************************/ <br>  if (need_to_wrap) <br>  { <br>    _fmemcpy ((UCHAR FAR *)display_buffer, <br>              data + copy_length, <br>              data_length - copy_length); <br> <br>    buffer_end   = data_length - copy_length; <br>  } <br>  else <br>  { <br>    buffer_end   += data_length; <br>  } <br> <br>  /***************************************************************************/ <br>  /* Cause the window to be re-painted                                       */ <br>  /***************************************************************************/ <br>  InvalidateRect (hWnd, NULL, TRUE); <br> <br>}  /* add_to_display_buffer                                                  */ <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
