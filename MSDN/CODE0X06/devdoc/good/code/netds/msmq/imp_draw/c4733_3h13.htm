<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMP_DRAWDLG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4737"></a>IMP_DRAWDLG.CPP</h2>
<pre><code>// Imp_DrawDlg.cpp : implementation file <br>// <br> <br>#include "stdafx.h" <br>#include &lt;afxdisp.h&gt; <br>#include "Imp_Draw.h" <br>#include "Imp_DrawDlg.h" <br>#include "logindlg.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CImp_DrawDlg dialog <br> <br>CImp_DrawDlg::CImp_DrawDlg(CWnd* pParent /*=NULL*/) <br>: CDialog(CImp_DrawDlg::IDD, pParent) <br>{ <br>//{{AFX_DATA_INIT(CImp_DrawDlg) <br>m_csFriendName = _T(""); <br>m_iRadio = -1; <br>//}}AFX_DATA_INIT <br>// Note that LoadIcon does not require a subsequent DestroyIcon in Win32 <br>m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); <br>m_vtguidDraw = "{151ceac0-acb5-11cf-8b51-0020af929546}"; <br>m_vtFriendName = ""; <br>m_pHandler = NULL; <br>} <br> <br>CImp_DrawDlg::~CImp_DrawDlg() <br>{ <br>if (m_pHandler) <br>delete m_pHandler;// Handler's destructor will release event object <br>}; <br> <br>void CImp_DrawDlg::DoDataExchange(CDataExchange* pDX) <br>{ <br>CDialog::DoDataExchange(pDX); <br>//{{AFX_DATA_MAP(CImp_DrawDlg) <br>DDX_Control(pDX, IDC_DRAWAREA_SCRIBLLE, m_drawScribble); <br>DDX_Text(pDX, IDC_EDIT_FRIEND, m_csFriendName); <br>DDX_Radio(pDX, IDC_RADIO_EXPRESS, m_iRadio); <br>//}}AFX_DATA_MAP <br>} <br> <br>BEGIN_MESSAGE_MAP(CImp_DrawDlg, CDialog) <br>//{{AFX_MSG_MAP(CImp_DrawDlg) <br>ON_WM_PAINT() <br>ON_WM_QUERYDRAGICON() <br>ON_BN_CLICKED(IDC_BUTTON_ATTACH, OnButtonAttach) <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CImp_DrawDlg message handlers <br>CString CImp_DrawDlg::GetUserName() <br>{ <br>DWORD dwsize = 255; <br>char username[255]; <br>if (::GetUserName(&amp;username[0], &amp;dwsize)) <br>return username; <br>return ""; <br>}; <br> <br>CString CImp_DrawDlg::GetComputerName() <br>{ <br>DWORD dwsize = 255; <br>char username[255]; <br>if (::GetComputerName(&amp;username[0], &amp;dwsize)) <br>return username; <br>return ""; <br>} <br> <br>CString CImp_DrawDlg::LoginPrompt(CString DefaultName) <br>{ <br>CLoginDlgdialog; <br>dialog.m_strLogin = DefaultName; <br>dialog.DoModal(); <br>return dialog.m_strLogin; <br>}; <br> <br> <br>void CImp_DrawDlg::SendMouseMovement(LINE line) <br>{ <br>try <br>{ <br>if (m_qFriend != NULL &amp;&amp; m_qFriend-&gt;IsOpen) <br>{ <br>m_msgOut-&gt;Priority = 3; <br> <br>/* Pack the data into one line (twice) */ <br>WCHAR wcsBody[MAX_MSG_BODY_LEN]; <br>swprintf(wcsBody, L"%07ld%07ld%07ld%07ld",  <br> line.ptStart.x, line.ptStart.y, line.ptEnd.x, line.ptEnd.y); <br> <br>WCHAR wcsLabel[MQ_MAX_MSG_LABEL_LEN]; <br>swprintf(wcsLabel, L"%ld,%ld To %ld,%ld",  <br> line.ptStart.x, line.ptStart.y, line.ptEnd.x, line.ptEnd.y); <br> <br>/* Initialize a variant with the wcsbody data */ <br>_variant_tvtBody(wcsBody); <br> <br>m_msgOut-&gt;Body = vtBody; <br>m_msgOut-&gt;Label = wcsLabel; <br>m_msgOut-&gt;Delivery = m_iRadio; <br>m_msgOut-&gt;Send(m_qFriend); <br>}; <br>} <br>catch(_com_error comerr) <br>{ <br>HandleErrors(comerr); <br>}; <br>}; <br> <br>void CImp_DrawDlg::SendKeystroke(UINT uChar) <br>{ <br>try <br>{ <br>if (m_qFriend != NULL &amp;&amp; m_qFriend-&gt;IsOpen) <br>{ <br>_variant_t vtChar((char*)&amp;uChar); <br>m_msgOut-&gt;Priority = 4; <br>m_msgOut-&gt;Body = &amp;vtChar; <br>m_msgOut-&gt;Label = "Key: " + uChar; <br>m_msgOut-&gt;Delivery = m_iRadio; <br>m_msgOut-&gt;Send(m_qFriend); <br>}; <br>} <br>catch(_com_error comerr) <br>{ <br>HandleErrors(comerr); <br>}; <br>}; <br> <br>void CImp_DrawDlg::Arrived(IDispatch* pdispQueue, long lErrorCode, long lCursor) <br>{ <br>if (lErrorCode != S_OK) <br>{ <br>// This code is what will run if ArrivedError is called <br>char* szErr = ""; <br>itoa(lErrorCode, szErr, 16); <br>CString tempString = "Method returned HRESULT: "; <br>tempString += szErr; <br>MessageBox(tempString, NULL, MB_ICONSTOP | MB_OK); <br>return; <br>}; <br> <br>IMSMQMessagePtr msgIn; <br>LINEline; <br>char*strTextIn = ""; <br>_variant_tvtTimeout((short) 100); <br>_bstr_tbtBody; <br> <br> <br>try <br>{ <br>IMSMQQueuePtrq(pdispQueue);// Creates a Queue smart pointer pointing to pdispQueue <br>msgIn = q-&gt;Receive(&amp;vtMissing, &amp;vtMissing, &amp;vtMissing, &amp;vtTimeout);// Any messages? <br>btBody = msgIn-&gt;Body;// convert to char* <br>strTextIn = (char*) btBody; <br>if (strlen(strTextIn) == 1) <br>m_drawScribble.AddKeystroke(strTextIn); <br>else <br>{ <br>       sscanf(strTextIn, "%07ld%07ld%07ld%07ld",  <br>&amp;line.ptStart.x, &amp;line.ptStart.y,  <br>&amp;line.ptEnd.x, &amp;line.ptEnd.y); <br>m_drawScribble.AddLine(line); <br>}; <br>} <br>catch(_com_error comerr) <br>{ <br>HandleErrors(comerr); <br>}; <br> <br>m_queue-&gt;EnableNotification(m_qevent);// IMPORTANT: Re-enable notification <br>}; <br> <br> <br>void CImp_DrawDlg::HandleErrors(_com_error comerr) <br>{ <br>HRESULT hr = comerr.Error(); <br>char* szErr = ""; <br>itoa(hr, szErr, 16); <br>CString tempString = "Method returned HRESULT: "; <br>tempString += szErr; <br>tempString += ".  Exiting."; <br>MessageBox(tempString, NULL, MB_ICONSTOP | MB_OK); <br>AfxAbort(); <br>}; <br> <br> <br> <br>BOOL CImp_DrawDlg::OnInitDialog() <br>{ <br>CDialog::OnInitDialog(); <br> <br>// Set the icon for this dialog.  The framework does this automatically <br>//  when the application's main window is not a dialog <br>SetIcon(m_hIcon, TRUE);// Set big icon <br>SetIcon(m_hIcon, FALSE);// Set small icon <br> <br>// TODO: Add extra initialization here <br>HRESULT hr = AfxOleInit(); <br> <br>try <br>{ <br>CStringcsDefaultQueueName; <br>CStringcsComputerName; <br> <br>IMSMQQueryPtrquery("MSMQ.MSMQQuery"); <br>IMSMQQueueInfoPtrqinfo; <br>IMSMQQueueInfosPtrqinfos; <br> <br>m_msgOut.CreateInstance("MSMQ.MSMQMessage"); <br>csDefaultQueueName = GetUserName(); <br>m_csLogin = LoginPrompt(csDefaultQueueName);// Present login dialog <br>if (m_csLogin == "") <br>return FALSE; <br>m_csLogin.MakeUpper(); <br>SetWindowText(m_csLogin); <br> <br>m_vtLogin = m_csLogin; <br>qinfos = query-&gt;LookupQueue(&amp;vtMissing,&amp;m_vtguidDraw, &amp;m_vtLogin);  // Look for user's queue <br>qinfos-&gt;Reset(); <br>qinfo = qinfos-&gt;Next(); <br> <br>if (qinfo == NULL)// if it doesn't exist <br>{ <br>qinfo.CreateInstance("MSMQ.MSMQQueueInfo"); <br>csComputerName = GetComputerName(); <br>if (csComputerName == "") <br>csComputerName = "."; <br>qinfo-&gt;PathName = (_bstr_t) LPCTSTR(csComputerName + "\\" + m_csLogin); <br>qinfo-&gt;Label = (_bstr_t) LPCTSTR(m_csLogin); <br>qinfo-&gt;ServiceTypeGuid = (_bstr_t) m_vtguidDraw; <br>qinfo-&gt;Create();// We'll make one <br>}; <br>for (int i = 0; i &lt; 5; i++) <br>{ <br>// We'll try to open it five times in case the creation takes time to replicate <br>try <br>{ <br>m_queue = NULL; <br>m_queue = qinfo-&gt;Open(MQ_RECEIVE_ACCESS, MQ_DENY_NONE); <br>if (m_queue != NULL) <br>i=5; <br>} <br>catch (_com_error comerr) <br>{ <br>hr = comerr.Error(); <br>if (hr != MQ_ERROR_QUEUE_NOT_FOUND) <br>throw comerr; <br>}; <br>}; <br> <br>if (m_queue == NULL) <br>{ <br>MessageBox("Could not open your queue after five tries", MB_OK); <br>return FALSE; <br>}; <br> <br>// Now we'll link up with the event source <br>// the first five lines below imitate <br>// Dim WithEvents m_qevent as MSMQ.MSMQEvent <br> <br>m_qevent.CreateInstance("MSMQ.MSMQEvent"); <br>if (m_pHandler) <br>delete m_pHandler; <br>m_pHandler = new CMSMQEventHandler(); <br>hr = m_pHandler-&gt;AdviseSource(m_qevent); <br> <br>hr = m_queue-&gt;EnableNotification(m_qevent); <br> <br>} <br>catch (_com_error comerr) <br>{ <br>HandleErrors(comerr); <br>}; <br> <br>m_iRadio = 1; <br>UpdateData(FALSE); <br> <br>return TRUE;  // return TRUE  unless you set the focus to a control <br>} <br> <br>// If you add a minimize button to your dialog, you will need the code below <br>//  to draw the icon.  For MFC applications using the document/view model, <br>//  this is automatically done for you by the framework. <br> <br>void CImp_DrawDlg::OnPaint()  <br>{ <br>if (IsIconic()) <br>{ <br>CPaintDC dc(this); // device context for painting <br> <br>SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); <br> <br>// Center icon in client rectangle <br>int cxIcon = GetSystemMetrics(SM_CXICON); <br>int cyIcon = GetSystemMetrics(SM_CYICON); <br>CRect rect; <br>GetClientRect(&amp;rect); <br>int x = (rect.Width() - cxIcon + 1) / 2; <br>int y = (rect.Height() - cyIcon + 1) / 2; <br> <br>// Draw the icon <br>dc.DrawIcon(x, y, m_hIcon); <br>} <br>else <br>{ <br>CDialog::OnPaint(); <br>} <br>} <br> <br>// The system calls this to obtain the cursor to display while the user drags <br>//  the minimized window. <br>HCURSOR CImp_DrawDlg::OnQueryDragIcon() <br>{ <br>return (HCURSOR) m_hIcon; <br>} <br> <br>void CImp_DrawDlg::OnButtonAttach()  <br>{ <br> <br>try <br>{ <br>IMSMQQueryPtrqueryFriend("MSMQ.MSMQQuery");// Creates a Query object <br>IMSMQQueueInfoPtrqinfoFriend; <br>IMSMQQueueInfosPtrqinfos; <br>UpdateData(TRUE); <br>m_csFriendName.MakeUpper(); <br>m_vtFriendName = m_csFriendName; <br>qinfos = queryFriend-&gt;LookupQueue(&amp;vtMissing,&amp;m_vtguidDraw, &amp;m_vtFriendName); <br>qinfos-&gt;Reset(); <br>qinfoFriend = qinfos-&gt;Next(); <br>if (qinfoFriend == NULL) <br>{ <br>MessageBox("No such friend, sorry..."); <br>} <br>else <br>{ <br>if (m_qFriend != NULL &amp;&amp; m_qFriend-&gt;IsOpen) <br>m_qFriend-&gt;Close(); <br> <br>m_qFriend = qinfoFriend-&gt;Open(MQ_SEND_ACCESS, MQ_DENY_NONE); <br>SetWindowText(m_csLogin + " - Connected to " + m_csFriendName); <br>}; <br>} <br>catch (_com_error comerr) <br>{ <br>HandleErrors(comerr); <br>}; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
