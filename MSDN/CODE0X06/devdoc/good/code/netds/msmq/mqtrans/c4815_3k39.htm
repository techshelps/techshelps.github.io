<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MQTRANS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4815"></a>MQTRANS.CPP</h2>
<pre><code><br>            ///////////////////////////////////// <br>            //                                 // <br>            // Transactions Sample Application // <br>            //                                 // <br>            ///////////////////////////////////// <br> <br> <br>#define UNICODE                     // For all MSMQ applications <br> <br>#include &lt;stdio.h&gt; <br> <br> <br>//------------------------------------------------------------------------------ <br>// Include MS DTC specific header files. <br>//------------------------------------------------------------------------------ <br>#define INITGUID <br>#include &lt;transact.h&gt; <br> <br>// Because we are compiling in UNICODE, here is a problem with DTC... <br>//#include &lt;xolehlp.h&gt; <br>extern HRESULT DtcGetTransactionManager( <br>                                    LPSTR  pszHost, <br>                                    LPSTR   pszTmName, <br>                                    REFIID rid, <br>                                    DWORD   dwReserved1, <br>                                    WORD    wcbReserved2, <br>                                    void FAR * pvReserved2, <br>                                    void** ppvObject )  ; <br> <br>//------------------------------------------------------------------------------ <br>// Include ODBC specific header file. <br>//------------------------------------------------------------------------------ <br>#ifndef DBNTWIN32 <br>#define DBNTWIN32 <br> <br>#include &lt;SQLEXT.h&gt; <br> <br>// from  &lt;odbcss.h&gt; <br>#define SQL_COPT_SS_BASE               1200 <br>#define SQL_COPT_SS_ENLIST_IN_DTC      (SQL_COPT_SS_BASE+7) // Enlist in a Viper transaction <br> <br>// Defines for use with SQL_ENLIST_IN_DTC <br>#define SQL_DTC_DONE 0L       // Delimits end of Viper transaction <br> <br>#endif <br> <br>//-------------------------------------------------------------------------- <br>//  Enable Ansi ODBC on VC5 <br>//-------------------------------------------------------------------------- <br> <br>#ifdef  SQLExecDirect <br>#undef  SQLExecDirect <br>#define SQLExecDirect SQLExecDirectA <br>#endif <br> <br>#ifdef  SQLSetConnectOption <br>#undef  SQLSetConnectOption <br>#define SQLSetConnectOption  SQLSetConnectOptionA <br>#endif <br> <br>#ifdef  SQLError <br>#undef  SQLError <br>#define SQLError  SQLErrorA <br>#endif <br> <br>#ifdef  SQLConnect <br>#undef  SQLConnect <br>#define SQLConnect  SQLConnectA <br>#endif <br> <br>//------------------------------------------------------------------------------ <br>// Include MSMQ specific header file. <br>//------------------------------------------------------------------------------ <br>#include "mq.h" <br> <br>//------------------------------------------------------------------------------ <br>// Define constants <br>//------------------------------------------------------------------------------ <br>#define STR_LEN      40 <br>#define MAX_VAR      20 <br>#define MAX_FORMAT  100 <br> <br> <br>//------------------------------------------------------------------------------ <br>// Define datatypes <br>//------------------------------------------------------------------------------ <br>typedef struct DBCONN <br>{ <br>   char  pszSrv [STR_LEN];    // data source name, configured through control panel <br>   char  pszUser [STR_LEN];   // Login user name <br>   char  pszPasswd[STR_LEN];  // Login user password <br>   HDBC  hdbc;                // handle to an ODBC database connection <br>   HSTMT hstmt;               // an ODBC statement handle, for use with SQLExecDirect <br> <br>}  DBCONN; <br> <br> <br>//------------------------------------------------------------------------------ <br>// Define Globals <br>//------------------------------------------------------------------------------ <br> <br>// global DB connection struct for the server <br>static DBCONN  gSrv = <br>   {  "MSMQDemo", <br>      "sa", <br>      "", <br>      SQL_NULL_HDBC, <br>      SQL_NULL_HSTMT <br>   }; <br> <br> <br>// guid type for MQTransTest queues <br>static CLSID guidMQTransTestType = <br>{ 0xb856ab1, 0x16b6, 0x11d0, { 0x80, 0x48, 0x0, 0xa0, 0x24, 0x53, 0xc1, 0x6f } }; <br> <br> <br>//handle to ODBC environment <br>HENV  g_hEnv = SQL_NULL_HENV ; <br> <br> <br>//buffer for machine name <br>WCHAR g_wszMachineName[ MAX_COMPUTERNAME_LENGTH + 1 ]; <br> <br> <br>//-------------------------------------------------------------------------- <br>// Forward declaration of routines used. <br>//-------------------------------------------------------------------------- <br> <br>void LogonToDB(DBCONN *ptr); <br>void ExecuteStatement(DBCONN *ptr, char* pszBuf, BOOL ProcessFlag); <br>BOOL ProcessRetCode(char*   pszFuncName, <br>                    DBCONN  *ptr, <br>                    RETCODE retcode, <br>                    BOOL    fExit = TRUE); <br>void DoSQLError(DBCONN *ptr); <br>void FreeODBCHandles(DBCONN *ptr); <br>void Error(char *s, HRESULT hr); <br>void Syntax(); <br>void LocateTargetQueue(CLSID *pGuidType, WCHAR wsFormat[MAX_FORMAT]); <br>void PrepareSendMessageProperties(MSGPROPID     amPropId[MAX_VAR], <br>                          MQPROPVARIANT aPropVar[MAX_VAR], <br>                          MQMSGPROPS    &amp;msgprops, <br>                          DWORD        &amp;TransferSum); <br>void CreateQueue(CLSID *pGuidType, WCHAR wsFormat[]); <br>void GetMachineName(); <br>void DisplayDollars (DBCONN *ptr, char *psAccount); <br> <br> <br>//------------------------------------------------------------------------------ <br>// SENDER MODE: <br>// <br>// The Sender side does the following: <br>//    1. Creates database "SenderAccount". <br>//    2. Locates a MSMQ queue of type MQTransTest and opens it. <br>//       (NOTE: for simplicity, this sample assumes there's only one queue of this type) <br>//   3. In a loop: <br>//            Prompts the user to enter TransferSum. <br>//            Creates a transaction using MS DTC. <br>//            Within the transaction: <br>//                 Updates "SenderAccount" database (subtracts TransferSum). <br>//                 Sends a message to Receiver side. <br>//            Commits the transaction. <br>// <br>//    4. Cleanup. <br>// <br>// <br>// <br>// The transaction in the Sender mode includes two operations: <br>// (1) Update "SenderAccount" database (subtract TransferSum). <br>// (2) Send message to Receiver side. <br>//------------------------------------------------------------------------------ <br> <br>void Sender() <br>{ <br> <br>   ITransactionDispenser   *pTransactionDispenser; <br>   ITransaction            *pTransaction; <br>   BOOL                    fTransactionCommitFlag; <br>                            // used to decide wother to Commit or Abort <br> <br>   HRESULT              hr; <br>   RETCODE              retcode; <br>   DWORD                dwTransferSum;              // set by user <br>   char                 sUserString[ STR_LEN ]; <br>   char                 sSQLStatement[ STR_LEN*2 ]; <br> <br>   MQMSGPROPS           msgprops; <br>   MQPROPVARIANT        aPropVar[MAX_VAR]; <br>   MSGPROPID            amPropId[MAX_VAR]; <br>   WCHAR                wsFormat[MAX_FORMAT]; <br>   QUEUEHANDLE          aqh; <br> <br> <br>    printf("\nSender Side.\n\n"); <br> <br>   //--------------------------------------------------------------------- <br>   // Build "SenderAccount" database (with the sum $1000) <br>   //--------------------------------------------------------------------- <br> <br>   printf ("Building SenderAccount with the sum $1000...   "); <br> <br>   // Get ODBC environment handle <br>   retcode = SQLAllocEnv(&amp;g_hEnv); <br> <br>   ProcessRetCode("SQLAllocEnv",0, retcode); <br> <br>   // Establish connection to database <br>   LogonToDB(&amp;gSrv); <br> <br>   // Clear database from previous run. <br>   ExecuteStatement(&amp;gSrv,"DROP TABLE SenderAccount",FALSE); <br> <br>   // Create new table in database <br>   ExecuteStatement(&amp;gSrv, <br>    "CREATE TABLE SenderAccount (Rate INTEGER CONSTRAINT c1 CHECK (Rate&gt;=0))",TRUE); <br> <br>   // Insert new data in database <br>   ExecuteStatement(&amp;gSrv,"INSERT INTO SenderAccount   VALUES(1000)",TRUE); <br> <br>   printf ("OK.\n\n"); <br> <br>   //----------------------------------------------------------------------- <br>   // Locate target queue and Open it for send <br>   //----------------------------------------------------------------------- <br> <br>   printf ("Searching Receiver queue...   "); <br> <br>   // Locate target queue <br>   LocateTargetQueue (&amp;guidMQTransTestType, wsFormat); <br> <br>   // Open target queue <br>   hr = MQOpenQueue(wsFormat, MQ_SEND_ACCESS, 0, &amp;aqh); <br> <br>   if (FAILED(hr)) <br>   { <br>      Error ("Open Queue ",hr); <br>   } <br> <br>   //-------------------------------------------------------------------------- <br>   // Get Transaction Dispenser <br>   //-------------------------------------------------------------------------- <br> <br>   // Obtain an interface pointer from MS DTC proxy <br>   hr = DtcGetTransactionManager( <br>               NULL,                        // pszHost <br>               NULL,                        // pszTmName <br>               IID_ITransactionDispenser,   // IID of  interface <br>               0,                           // Reserved -- must be null <br>               0,                           // Reserved -- must be null <br>               0,                           // Reserved -- must be null <br>               (void **)&amp;pTransactionDispenser  // pointer to pointer to requested interface <br>                                 ); <br> <br>   if (FAILED(hr)) <br>   { <br>      Error ("DTCGetTransactionManager",hr); <br>   } <br> <br>   //-------------------------------------------------------------------- <br>   // Sender Main Loop <br>   //-------------------------------------------------------------------- <br>   while (TRUE) <br>   { <br> <br>      // Prompt user to enter TransferSum <br>      printf ("\n\nPlease enter the sum of dollars to transfer, or '0' to quit  ==&gt; "); <br> <br>      // Read user input <br>      fgets (sUserString, STR_LEN, stdin); <br> <br>      // Convert user string to DWORD <br>      dwTransferSum = atoi(sUserString); <br> <br>      // Prepare properties of message to send <br>      PrepareSendMessageProperties (amPropId, <br>                                    aPropVar, <br>                                    msgprops, <br>                                    dwTransferSum); <br> <br>      //--------------------------------------------------------------------- <br>      // Create transaction (Inside Sender's Main Loop) <br>      //--------------------------------------------------------------------- <br> <br>      printf ("\nStarting transaction...\n\n"); <br> <br>      // Initiate an MS DTC transaction <br>      hr = pTransactionDispenser-&gt;BeginTransaction ( <br>            0,                         // must be null <br>            ISOLATIONLEVEL_ISOLATED,   // Isolation Level <br>            ISOFLAG_RETAIN_DONTCARE,   // Isolation flags <br>            0,                         // pointer to transaction options object <br>            &amp;pTransaction);            // pointer to pointer to transaction object <br> <br>      if (FAILED(hr)) <br>      { <br>         Error ("BeginTransaction",hr); <br>      } <br> <br>      // Default is to commit transaction <br>      fTransactionCommitFlag = TRUE; <br> <br>      // <br>      // SQL is a resource manager in the transaction. <br>      // It must be enlisted. <br>      // <br> <br>      // Enlist database in the transaction <br>      retcode = SQLSetConnectOption (gSrv.hdbc, <br>                                     SQL_COPT_SS_ENLIST_IN_DTC, <br>                                     (UDWORD)pTransaction); <br> <br>      if (retcode != SQL_SUCCESS) <br>      { <br>         ProcessRetCode("SQLSetConnection", &amp;gSrv, retcode, FALSE); <br>         fTransactionCommitFlag = FALSE; <br>      } <br> <br> <br>      // Prepare SQL statement to update SenderAccount <br>      sprintf (sSQLStatement, <br>               "UPDATE SenderAccount  SET Rate = Rate - %lu", dwTransferSum) ; <br> <br>      // Allocate a statement handle for use with SQLExecDirect <br>      retcode = SQLAllocStmt(gSrv.hdbc, &amp;gSrv.hstmt); <br> <br>      if (retcode != SQL_SUCCESS) <br>      { <br>         ProcessRetCode("SQLAllocStmt", &amp;gSrv, retcode, FALSE); <br>         fTransactionCommitFlag = FALSE; <br>      } <br> <br>      // Update database  (subtract TransferSum from SenderAccount) <br>      retcode = SQLExecDirect (gSrv.hstmt,(UCHAR *) sSQLStatement, SQL_NTS); <br> <br>      if (retcode != SQL_SUCCESS) <br>      { <br>         ProcessRetCode("SQLExecDirect", &amp;gSrv, retcode, FALSE); <br>         fTransactionCommitFlag = FALSE; <br>      } <br> <br>      // Free the statement handle <br>      retcode = SQLFreeStmt(gSrv.hstmt, SQL_DROP); <br> <br>      gSrv.hstmt = SQL_NULL_HSTMT; <br> <br>      // <br>      // MSMQ is another resource manager in the transaction. <br>      // Its enlistment is implicit. <br>      // <br> <br>      // Within the transaction: Send message to Receiver Side <br>      hr = MQSendMessage(aqh,              // Handle to destination queue <br>                         &amp;msgprops,        // pointer to MQMSGPROPS structure <br>                         pTransaction);    // pointer to Transaction Object <br> <br> <br>      if (FAILED(hr)) <br>      { <br>         printf("\nFailed in MQSendMessage(). hresult- %lxh\n", (DWORD) hr) ; <br>         fTransactionCommitFlag = FALSE; <br>      } <br> <br> <br>      // Commit the transaction <br>      if (fTransactionCommitFlag) <br>      { <br>         printf ("Committing the transaction...   "); <br> <br>         hr = pTransaction-&gt;Commit(0, 0, 0); <br> <br>         if (FAILED(hr)) <br>            printf ("Failed... Transaction aborted.\n\n"); <br>         else <br>            printf ("Transaction committed successfully.\n\n"); <br> <br>      } <br>      else <br>      { <br>         printf ("Aborting the transaction...   "); <br> <br>         hr = pTransaction-&gt;Abort(0, 0, 0); <br> <br>         if (FAILED(hr)) <br>            Error("Transaction Abort",hr); <br>         else <br>            printf ("Transaction aborted.\n\n"); <br>      } <br> <br>      // Release the transaction <br>      pTransaction-&gt;Release(); <br> <br>      // End enlistment of database <br>      retcode = SQLSetConnectOption (gSrv.hdbc, SQL_COPT_SS_ENLIST_IN_DTC, SQL_DTC_DONE); <br> <br>      ProcessRetCode ("SQLSetConnectOption", &amp;gSrv, retcode); <br> <br>      // Display sum of dollars in Sender Account <br>      DisplayDollars (&amp;gSrv,"SenderAccount"); <br> <br>      // quit loop when nothing was transferred. <br>      if (dwTransferSum == 0) <br>         break; <br>   } <br> <br>   //-------------------------------------------------------------------------- <br>   // Cleanup <br>   //-------------------------------------------------------------------------- <br> <br>   // Release Transaction Dispenser <br>   pTransactionDispenser-&gt;Release(); <br> <br> <br>   // Free database <br>   ExecuteStatement(&amp;gSrv,"DROP TABLE SenderAccount",TRUE); <br> <br> <br>   // Free ODBC handle <br>   FreeODBCHandles(&amp;gSrv); <br> <br> <br>   // Free the ODBC environment handle <br>   retcode = SQLFreeEnv(g_hEnv); <br> <br>   if (retcode == SQL_ERROR) <br>      Error ("SQL FreeEnv ",0); <br> <br> <br>   // Free MSMQ queue handle <br>   MQCloseQueue(aqh); <br> <br> <br>   printf ("\n\nSender Side completed.\n\n"); <br> <br>} <br> <br> <br> <br> <br>//------------------------------------------------------------------------------ <br>// RECEIVER MODE: <br>// <br>// The Receiver side does the following: <br>//    1. Creates database "ReceiverAccount". <br>//    2. Creates a MSMQ public queue (with the Transactional property) <br>//       of type MQTransTest on its own machine and opens it. <br>//    3. In a loop: <br>//            Creates a transaction using MS DTC. <br>//            Within the transaction: <br>//                 Receives a message from the queue (with the TransferSum). <br>//                 Updates "ReceiverAccount" database (adds TransferSum). <br>//            Commits the transaction. <br>// <br>//    4. Cleanup. <br>// <br>// <br>// <br>// The transaction in the Receiver mode include two operations: <br>// (1) Receive message from queue (sent by Sender Side). <br>// (2) Update "ReceiverAccount" database  (add TransferSum). <br>//------------------------------------------------------------------------------ <br> <br>void Receiver() <br>{ <br>   MSGPROPID            amPropId[MAX_VAR]; <br>   MQMSGPROPS           msgprops; <br>   MQPROPVARIANT        aPropVar[MAX_VAR]; <br>   DWORD             cProps; <br>   HRESULT              hr; <br>   WCHAR             wsFormat[MAX_FORMAT]; <br>   QUEUEHANDLE          aqh; <br> <br>   ITransactionDispenser   *pTransactionDispenser; <br>   ITransaction         *pTransaction; <br>   BOOL              TransactionCommitFlag;  // used to decide Commit or Abort <br> <br>   RETCODE              retcode; <br>   DWORD             TransferSum; <br> <br>   DWORD             MessageBuffer;       // message body is the TransferSum <br>   char              sSQLStatement[STR_LEN*2]; <br> <br> <br> <br> <br> <br>   printf ("\nReceiver Side.\n\n"); <br> <br>   //----------------------------------------------------------------------- <br>   // Build "ReceiverAccount" database (with the rate $500) <br>   //----------------------------------------------------------------------- <br> <br>   printf ("Building ReceiverAccount with the rate $500...   "); <br> <br>   // Get ODBC environment handle <br>   retcode = SQLAllocEnv(&amp;g_hEnv); <br> <br>   ProcessRetCode("SQLAllocEnv",0, retcode); <br> <br>   // Establish connection to database. <br>   LogonToDB(&amp;gSrv); <br> <br>   // Clear table from previous run. <br>   ExecuteStatement(&amp;gSrv,"DROP TABLE ReceiverAccount",FALSE); <br> <br>   // Create new table. <br>   ExecuteStatement(&amp;gSrv,"CREATE TABLE ReceiverAccount (Rate INTEGER CONSTRAINT c2 CHECK (Rate&gt;0))",TRUE); <br> <br>   // Insert new data in the table. <br>   ExecuteStatement(&amp;gSrv,"INSERT INTO ReceiverAccount  VALUES(500)",TRUE); <br> <br>   printf ("OK.\n\n"); <br> <br>   //----------------------------------------------------------------------- <br>   // Create queue and Open it for receive <br>   //----------------------------------------------------------------------- <br> <br>   printf ("Creating Receiver queue...   "); <br> <br>   // Create the queue <br>   CreateQueue (&amp;guidMQTransTestType, wsFormat); <br> <br>   // Prepare message properties to read <br>   cProps = 0; <br> <br>   amPropId[cProps] =             PROPID_M_BODY; <br> <br>   aPropVar[cProps].vt =          VT_UI1 | VT_VECTOR; <br>   aPropVar[cProps].caub.cElems =  sizeof(MessageBuffer); <br>   aPropVar[cProps].caub.pElems =  (unsigned char *)&amp;MessageBuffer; <br>   cProps++; <br> <br>   // Create a MSGPROPS structure <br>   msgprops.cProp =    cProps; <br>   msgprops.aPropID =  amPropId; <br>   msgprops.aPropVar = aPropVar; <br>   msgprops.aStatus =  0; <br> <br>   // Open the queue <br>   hr = MQOpenQueue(wsFormat, MQ_RECEIVE_ACCESS, 0, &amp;aqh); <br> <br>   // <br>   // Little bit tricky. MQCreateQueue succeeded but it does not mean <br>   // that MQOpenQueue will, because of replication delay. The queue is <br>   // registered in MQIS, but it might take a replication interval <br>   // until the replica reach the server I am connected to. <br>   // To overcome this, open the queue in a loop. <br>   // <br>   if (hr == MQ_ERROR_QUEUE_NOT_FOUND) <br>   { <br>       int iCount = 0 ; <br>       while((hr == MQ_ERROR_QUEUE_NOT_FOUND) &amp;&amp; (iCount &lt; 120)) <br>       { <br>          printf("."); <br> <br>          // Wait a bit <br>          iCount++ ; <br>          Sleep(500); <br> <br>          // And retry <br>          hr = MQOpenQueue(wsFormat, MQ_RECEIVE_ACCESS, 0, &amp;aqh); <br>       } <br>   } <br> <br>   if (FAILED(hr)) <br>   { <br>      Error ("Can't OpenQueue", hr); <br>   } <br> <br>   printf("OK."); <br> <br> <br>   //-------------------------------------------------------------------------- <br>   // Get Transaction Dispenser <br>   //-------------------------------------------------------------------------- <br> <br>   // Obtain an interface pointer from MS DTC proxy <br>   hr = DtcGetTransactionManager( <br>         NULL, NULL, // pszHost, pszTmName <br>         IID_ITransactionDispenser,         // IID of requested interface <br>         0,0,0,                             // Reserved -- must be null <br>         (void **)&amp;pTransactionDispenser);  // pointer to pointer to requested interface <br> <br> <br>   if (FAILED(hr)) <br>      Error ("DTCGetTransactionManager",hr); <br> <br> <br>   //-------------------------------------------------------------------------- <br>   // Receiver Main Loop <br>   //-------------------------------------------------------------------------- <br>   while (TRUE) <br>   { <br> <br>      printf ("\n\nWaiting for a message to come...   "); <br> <br>      // Peek outside the transaction, to avoid database lock <br>      // for long/infinite period. <br>      // <br>      //dwSize = sizeof(wsResponse); <br>      hr = MQReceiveMessage( <br>                    aqh,                     // Handle to queue <br>                    INFINITE,                // Timeout <br>                    MQ_ACTION_PEEK_CURRENT,  // Peek Action <br>                    &amp;msgprops,               // Message Properties <br>                    NULL,                    // Overlap <br>                    NULL,                    // Receive Callback <br>                    NULL,                    // Cursor <br>                    NULL                     // No transaction yet <br>                           ); <br> <br>      if (FAILED(hr)) <br>         Error("MQReceiveMessage (PEEKING) ",hr); <br> <br> <br> <br>      //-------------------------------------------------------------------------- <br>      // Create transaction <br>      //-------------------------------------------------------------------------- <br>      printf ("\n\nStarting transaction...\n\n"); <br> <br> <br>      // Initiate an MS DTC transaction <br>      hr = pTransactionDispenser-&gt;BeginTransaction ( <br>            0,                                 // must be null <br>            ISOLATIONLEVEL_ISOLATED,         // Isolation Level <br>            ISOFLAG_RETAIN_DONTCARE,         // Isolation flags <br>            0,                                 // pointer to transaction options object <br>            &amp;pTransaction);                    // pointer to pointer to transaction object <br> <br>      if (FAILED(hr)) <br>         Error ("BeginTransaction",hr); <br> <br> <br>      // Default is to commit transaction <br>      TransactionCommitFlag = TRUE; <br> <br>      // <br>      // SQL is a resource manager in the transaction. <br>      // It must be enlisted. <br>      // <br> <br>      // Enlist database in the transaction <br>      retcode = SQLSetConnectOption (gSrv.hdbc, SQL_COPT_SS_ENLIST_IN_DTC, (UDWORD)pTransaction); <br> <br>      if (retcode != SQL_SUCCESS) <br>         TransactionCommitFlag = FALSE; <br> <br> <br> <br>      // Receive the message from the queue <br>      //dwSize = sizeof(wsResponse); <br>      hr = MQReceiveMessage( <br>            aqh,                      // Handle to queue <br>            INFINITE,                         // Timeout <br>            MQ_ACTION_RECEIVE,                // Receive Action <br>            &amp;msgprops,                   // Message Properties <br>            NULL,NULL,NULL,                   // Overlap, Receive Callback, Cursor <br>            pTransaction);                    // pointer to transaction object <br> <br>      if (FAILED(hr)) <br>         TransactionCommitFlag = FALSE; <br> <br> <br>      // Message buffer holds the TransferSum <br>      TransferSum = (DWORD)MessageBuffer; <br> <br> <br>      // Prepare SQL statement to update ReceiverAccount <br>      sprintf (sSQLStatement, "UPDATE ReceiverAccount   SET Rate = Rate + %i",TransferSum); <br> <br> <br>      // Allocate a statement handle for use with SQLExecDirect <br>      retcode = SQLAllocStmt(gSrv.hdbc,&amp;gSrv.hstmt); <br> <br>      if (retcode != SQL_SUCCESS) <br>         TransactionCommitFlag = FALSE; <br> <br> <br>      // Update database  (add TransferSum to ReceiverAccount) <br>      retcode = SQLExecDirect (gSrv.hstmt,(UCHAR *) sSQLStatement, SQL_NTS); <br> <br>      if (retcode != SQL_SUCCESS) <br>         TransactionCommitFlag = FALSE; <br> <br> <br>      // Free the statement handle <br>      retcode = SQLFreeStmt(gSrv.hstmt, SQL_DROP); <br> <br>      gSrv.hstmt = SQL_NULL_HSTMT; <br> <br> <br> <br>      // Commit the transaction <br>      if (TransactionCommitFlag) <br>      { <br>         printf ("Committing the transaction...   "); <br> <br>         hr = pTransaction-&gt;Commit(0, 0, 0); <br> <br>         if (FAILED(hr)) <br>            printf ("Failed... Transaction aborted.\n\n"); <br>         else <br>            printf ("Transaction committed successfully.\n\n"); <br> <br>      } <br> <br> <br>      // Abort the transaction <br>      else <br>      { <br>         printf ("Aborting the transaction...   "); <br> <br>         hr = pTransaction-&gt;Abort(0, 0, 0); <br> <br>         if (FAILED(hr)) <br>            Error("Transaction Abort",hr); <br>         else <br>            printf ("Transaction aborted.\n\n"); <br> <br>      } <br> <br> <br> <br>      // Release the transaction <br>      pTransaction-&gt;Release(); <br> <br> <br>      // End enlistment of database <br>      retcode = SQLSetConnectOption (gSrv.hdbc, SQL_COPT_SS_ENLIST_IN_DTC, SQL_DTC_DONE); <br> <br>      ProcessRetCode ("SQLSetConnectOption", &amp;gSrv, retcode); <br> <br> <br>      // Display sum of dollars in Receiver Account <br>      DisplayDollars (&amp;gSrv, "ReceiverAccount"); <br> <br> <br>      // Decide if to continue loop <br>      if (TransferSum == 0) <br>         break; <br> <br> <br>   } <br> <br> <br>   //-------------------------------------------------------------------------- <br>   // Cleanup <br>   //-------------------------------------------------------------------------- <br> <br>   // Release Transaction Dispenser <br>   pTransactionDispenser-&gt;Release(); <br> <br> <br>   // Free database <br>   ExecuteStatement(&amp;gSrv,"DROP TABLE ReceiverAccount",TRUE); <br> <br> <br>   // Free ODBC handle <br>   FreeODBCHandles(&amp;gSrv); <br> <br> <br>   // Free the ODBC environment handle <br>   retcode = SQLFreeEnv(g_hEnv); <br> <br>   if (retcode == SQL_ERROR) <br>      Error ("SQL FreeEnv ",0); <br> <br> <br>   // Free queue handle <br>    MQCloseQueue(aqh); <br> <br> <br>   // Delete queue from directory <br>   MQDeleteQueue(wsFormat); <br> <br> <br>   printf ("\n\nReceiver Side completed.\n\n"); <br>} <br> <br> <br> <br>//------------------------------------------------------------------------------ <br>//  MAIN <br>//------------------------------------------------------------------------------ <br>main(int argc, char * * argv) <br>{ <br>   DWORD dwSize; <br> <br>    if(argc != 2) <br>        Syntax(); <br> <br> <br>    // Retrieve machine name <br>    dwSize = sizeof(g_wszMachineName); <br>    GetComputerName(g_wszMachineName, &amp;dwSize); <br> <br> <br> <br>    if(strcmp(argv[1], "-s") == 0) <br>        Sender(); <br> <br>    else if(strcmp(argv[1], "-r") == 0) <br>        Receiver(); <br> <br>    else <br>        Syntax(); <br> <br>    return(1); <br> <br>} <br> <br> <br> <br>//------------------------------------------------------------------------------ <br>// Subroutines <br>//------------------------------------------------------------------------------ <br> <br>void Error(char *s, HRESULT hr) <br>{ <br> <br>    printf("\n\nError: %s (0x%X)  \n", s, hr); <br>    exit(1); <br>} <br> <br>//------------------------------------------------------------------------------ <br> <br>void Syntax() <br>{ <br>    printf("\n"); <br>    printf("Syntax: msmqtrans -s | -r\n"); <br>    printf("\t-s - Sender Side\n"); <br>    printf("\t-r - Receiver Side\n"); <br>    exit(1); <br> <br>} <br> <br>//------------------------------------------------------------------------------ <br> <br>void LocateTargetQueue (CLSID *pGuidType, WCHAR wsFormat[MAX_FORMAT]) <br>{ <br> <br>   DWORD      dwSize; <br>   DWORD      i; <br> <br>   DWORD      cQueue; <br>   DWORD      cProps; <br>   HRESULT       hr; <br>   MQPROPERTYRESTRICTION   aPropRestriction[MAX_VAR]; <br>   MQRESTRICTION        Restriction; <br>   MQCOLUMNSET          Column; <br>   QUEUEPROPID          aqPropId[MAX_VAR]; <br>   HANDLE               hEnum; <br>   MQPROPVARIANT        aPropVar[MAX_VAR]; <br> <br>   //-------------------------------------------------------------------------- <br>    // Prepare Parameters to locate a queue <br>    //-------------------------------------------------------------------------- <br> <br>    // 1. Restriction = All queue with PROPID_TYPE <br>    //            equal the type of MQTransTest queue. <br>    cProps = 0; <br> <br>    aPropRestriction[cProps].rel = PREQ; <br>    aPropRestriction[cProps].prop = PROPID_Q_TYPE; <br>    aPropRestriction[cProps].prval.vt = VT_CLSID; <br>    aPropRestriction[cProps].prval.puuid = pGuidType; <br>    cProps++; <br> <br>    Restriction.cRes = cProps; <br>    Restriction.paPropRes = aPropRestriction; <br> <br> <br>    // 2. Columnset (In other words what property I want to retrieve). <br>    //   Only the instance is important. <br>    cProps = 0; <br>    aqPropId[cProps] = PROPID_Q_INSTANCE; <br>    cProps++; <br> <br>    Column.cCol = cProps; <br>    Column.aCol = aqPropId; <br> <br>    //-------------------------------------------------------------------------- <br>    // Locate the queues. Issue the query <br>    //-------------------------------------------------------------------------- <br>    hr = MQLocateBegin(NULL,&amp;Restriction,&amp;Column,NULL,&amp;hEnum); <br> <br>   if (FAILED(hr)) <br>      Error ("Locate Begin ",hr); <br> <br> <br>    //-------------------------------------------------------------------------- <br>    // Get the results <br>    //-------------------------------------------------------------------------- <br>    cQueue = MAX_VAR; <br>    hr = MQLocateNext(hEnum, &amp;cQueue, aPropVar); <br> <br>   if (FAILED(hr)) <br>      Error ("MQLocateNext ",hr); <br> <br>    hr = MQLocateEnd(hEnum); <br> <br>    if(cQueue == 0) <br>    { <br>        // Could Not find any queue, so exit <br>        printf("NOT FOUND...   exiting.\n\n"); <br>        exit(0); <br>    } <br> <br> <br>    printf("FOUND.", cQueue); <br> <br>    dwSize = sizeof(WCHAR)*MAX_FORMAT; <br> <br>   //Transform the Instance GUID to format name <br>   hr = MQInstanceToFormatName(aPropVar[0].puuid, wsFormat, &amp;dwSize); <br> <br>   if (FAILED(hr)) <br>      Error ("Guidto Format Name ",hr); <br> <br> <br>   // Free the GUID memory that was allocated during the locate <br>    for(i = 0; i &lt; cQueue; i++) <br>      MQFreeMemory(aPropVar[i].puuid); <br> <br> <br>} <br> <br> <br>//------------------------------------------------------------------------------ <br> <br>void PrepareSendMessageProperties (MSGPROPID     amPropId[MAX_VAR], <br>                           MQPROPVARIANT aPropVar[MAX_VAR], <br>                           MQMSGPROPS    &amp;msgprops, <br>                           DWORD     &amp;TransferSum) <br>{ <br> <br>   DWORD      cProps; <br> <br>    cProps = 0; <br>    amPropId[cProps] =             PROPID_M_BODY; <br>    aPropVar[cProps].vt =          VT_UI1 | VT_VECTOR; <br>    aPropVar[cProps].caub.cElems =  sizeof(TransferSum); <br>    aPropVar[cProps].caub.pElems =  (unsigned char *)&amp;TransferSum; <br>    cProps++; <br> <br>    // Create a MSGPROPS structure <br>    msgprops.cProp =    cProps; </code></pre>
<p>
</p>
<pre><code>msgprops.aPropID =  amPropId; <br>    msgprops.aPropVar = aPropVar; <br>    msgprops.aStatus =  0; <br> <br>} <br> <br>//-------------------------------------------------------------------------- <br> <br>void  CreateQueue (CLSID *pGuidType, WCHAR wsFormat[]) <br>{ <br>   QUEUEPROPID       aqPropId[MAX_VAR]; <br>   WCHAR             wsPathName[1000];  //Big path name <br>   MQPROPVARIANT     aPropVar[MAX_VAR]; <br>   DWORD             cProps; <br>   MQQUEUEPROPS      qprops; <br>   DWORD             dwSize; <br>   HRESULT           hr; <br> <br>   //--------------------------------------------------------------------- <br>   // Prepare properties to create a queue on local machine <br>   //--------------------------------------------------------------------- <br>   cProps = 0; <br> <br>   // Set the PathName <br>   aqPropId[cProps] =          PROPID_Q_PATHNAME; <br> <br>   wsprintf(wsPathName, TEXT("%s\\MSMQDemo"), g_wszMachineName); <br>   aPropVar[cProps].vt =       VT_LPWSTR; <br>   aPropVar[cProps].pwszVal =  wsPathName; <br>   cProps++; <br> <br>   // Set the queue to transactional <br>   aqPropId[cProps] =        PROPID_Q_TRANSACTION; <br> <br>   aPropVar[cProps].vt =     VT_UI1; <br>   aPropVar[cProps].bVal =   MQ_TRANSACTIONAL; <br>   cProps++; <br> <br>   // Set the type of the queue (Will be used to locate queues of this type) <br>   aqPropId[cProps] =        PROPID_Q_TYPE; <br> <br>   aPropVar[cProps].vt =     VT_CLSID; <br>   aPropVar[cProps].puuid =  pGuidType; <br>   cProps++; <br> <br>   // Create a QUEUEPROPS structure <br>   qprops.cProp =    cProps; <br>   qprops.aPropID =  aqPropId; <br>   qprops.aPropVar = aPropVar; <br>   qprops.aStatus =  0; <br> <br>   //----------------------------------------------------------------------- <br>   // Create the queue <br>   //----------------------------------------------------------------------- <br>   dwSize = sizeof(WCHAR)*MAX_FORMAT; <br>   hr = MQCreateQueue(NULL, &amp;qprops, wsFormat, &amp;dwSize); <br> <br>   if(FAILED(hr)) <br>   { <br>      // API Fails, not because the queue exists <br>      if(hr != MQ_ERROR_QUEUE_EXISTS) <br>            Error("Cannot create queue.", hr); <br> <br>      // Queue exist, so get its format name <br>      // Note: Since queue already exists, this sample assumes <br>      // that it was created earlier by this program, so we <br>      // do not check if queue is transactional. If at this point the <br>      // queue is Not Transactional, the transactions will abort later... <br>      // <br>      hr = MQPathNameToFormatName(wsPathName, wsFormat, &amp;dwSize); <br> <br>      if (FAILED(hr)) <br>         Error ("Cannot retrieve format name",hr); <br>   } <br>} <br> <br>//------------------------------------------------------------------------------- <br> <br>void LogonToDB(DBCONN *ptr) <br>{ <br>   RETCODE retcode = 0; <br> <br>   retcode = SQLAllocConnect(g_hEnv, &amp;(ptr-&gt;hdbc) ); <br> <br>   if (ProcessRetCode("SQLAllocConnect",ptr,retcode)) <br>   { <br>      retcode = SQLConnect(ptr-&gt;hdbc, <br>                  (UCHAR *)(ptr-&gt;pszSrv), <br>                  SQL_NTS, <br>                  (UCHAR *)(ptr-&gt;pszUser), <br>                  SQL_NTS, <br>                  (UCHAR *)(ptr-&gt;pszPasswd), <br>                  SQL_NTS <br>                  ); <br> <br>      ProcessRetCode("SQLConnect",ptr,retcode); <br>   } <br>} <br> <br>//------------------------------------------------------------------------------ <br> <br>void ExecuteStatement(DBCONN *ptr, char* pszBuf,BOOL ProcessFlag) <br>{ <br>   RETCODE retcode = 0; <br> <br>   // Allocate a statement handle for use with SQLExecDirect <br>   retcode = SQLAllocStmt(ptr-&gt;hdbc,&amp;(ptr-&gt;hstmt)); <br> <br>   if (ProcessFlag) <br>      ProcessRetCode("SQLAllocStmt",ptr,retcode); <br> <br>   // Execute the passed string as a SQL statement <br>    retcode = SQLExecDirect (ptr-&gt;hstmt,(UCHAR *) pszBuf,SQL_NTS); <br> <br>   if (ProcessFlag) <br>      ProcessRetCode("SQLExecDirect",ptr,retcode); <br> <br>   // Free the statement handle <br>   retcode = SQLFreeStmt(ptr-&gt;hstmt, SQL_DROP); <br>   ptr-&gt;hstmt = SQL_NULL_HSTMT; <br> <br>   if (ProcessFlag) <br>      ProcessRetCode("SQLFreeStmt",ptr,retcode); <br> <br>} <br> <br>// --------------------------------------------------------------------------- <br> <br>void DisplayDollars (DBCONN *ptr, char *psAccount) <br>{ <br> <br>   DWORD             DollarsSum;               // in SQL database <br>   SDWORD               cbValue;                  // OUT argument for SQL query <br>   char              sSQLStatement[STR_LEN*2]; <br>   RETCODE              retcode; <br> <br> <br> <br> <br>   // Allocate a statement handle for use with SQLExecDirect <br>   retcode = SQLAllocStmt(ptr-&gt;hdbc,&amp;(ptr-&gt;hstmt)); <br> <br>   ProcessRetCode("SQLAllocStmt",ptr,retcode); <br> <br> <br>   // Prepare SQL Statement to issue query <br>   sprintf (sSQLStatement, "SELECT * FROM %s", psAccount); <br> <br> <br>   // Issue SQL query <br>   retcode = SQLExecDirect (ptr-&gt;hstmt,(UCHAR *)sSQLStatement,SQL_NTS); <br> <br>   ProcessRetCode ("SQLExecDirect",ptr,retcode); <br> <br> <br>   // Prepare data structure to retrieve query results <br>   retcode = SQLBindCol(ptr-&gt;hstmt,1,SQL_C_ULONG,&amp;DollarsSum,0,&amp;cbValue); <br> <br>   ProcessRetCode ("SQLBindCol",ptr,retcode); <br> <br> <br>   // Retrieve query results <br>   retcode = SQLFetch (ptr-&gt;hstmt); <br> <br>   ProcessRetCode ("SQLFetch",ptr,retcode); <br> <br> <br>   // Display query results <br>   printf ("Sum of dollars in %s is %d .\n\n",psAccount,DollarsSum); <br> <br> <br>   // Free the statement handle <br>   retcode = SQLFreeStmt(ptr-&gt;hstmt, SQL_DROP); <br>   ptr-&gt;hstmt = SQL_NULL_HSTMT; <br> <br>   ProcessRetCode("SQLFreeStmt",ptr,retcode); <br> <br>} <br> <br>// --------------------------------------------------------------------------- <br> <br>void FreeODBCHandles(DBCONN *ptr) <br>{ <br>   SQLDisconnect(ptr-&gt;hdbc); <br> <br>   SQLFreeConnect(ptr-&gt;hdbc); <br> <br>   ptr-&gt;hdbc   = SQL_NULL_HDBC; <br>   ptr-&gt;hstmt  = SQL_NULL_HSTMT; <br>} <br> <br> <br>// --------------------------------------------------------------------------- <br> <br>BOOL ProcessRetCode(char*   pszFuncName, <br>                    DBCONN  *ptr, <br>                    RETCODE retcode, <br>                    BOOL    fExit) <br>{ <br>   BOOL state = TRUE ; <br>   BOOL fExitP = fExit ; <br> <br>   switch (retcode) <br>   { <br> <br>   case SQL_SUCCESS: <br>         fExitP = FALSE ; <br>         break; <br> <br>   case SQL_SUCCESS_WITH_INFO: <br>         fExitP = FALSE ; <br>         break; <br> <br>   case SQL_ERROR: <br>         printf("%s Failed - see more info\n",pszFuncName); <br>         DoSQLError(ptr); <br>         state = FALSE; <br>         break; <br> <br>   case SQL_INVALID_HANDLE: <br>         printf("%s Failed - SQL_INVALID_HANDLE\n",pszFuncName); <br>         state = FALSE; <br>         break; <br> <br>   case SQL_NO_DATA_FOUND: <br>         printf("%s Failed - SQL_NO_DATA_FOUND\n",pszFuncName); <br>         fExitP = FALSE ; <br>         state = FALSE; <br>         break; <br> <br>   case SQL_STILL_EXECUTING: <br>         printf("%s Failed - SQL_STILL_EXECUTING\n",pszFuncName); <br>         fExitP = FALSE ; <br>         state = FALSE; <br>         break; <br> <br>   case SQL_NEED_DATA: <br>         printf("%s Failed - SQL_NEED_DATA\n",pszFuncName); <br>         fExitP = FALSE ; <br>         state = FALSE; <br>         break; <br> <br>   default: <br>         printf("%s Failed - unexpected error, retcode = %x\n",pszFuncName,retcode); <br>         DoSQLError(ptr); <br>         state = FALSE; <br>         break; <br>   } <br> <br>   if (fExitP) <br>   { <br>      exit(-1) ; <br>   } <br>   return state ; <br>} <br> <br>// --------------------------------------------------------------------------- <br> <br>void DoSQLError(DBCONN *ptr) <br>{ <br> <br>   const INT            MSG_BUF_SIZE = 300; <br>   UCHAR                szSqlState[MSG_BUF_SIZE]; <br>   UCHAR             szErrorMsg[MSG_BUF_SIZE]; <br> <br>   SQLINTEGER  fNativeError   = 0; <br>   SWORD    cbErrorMsg     = MSG_BUF_SIZE; <br>   RETCODE     retcode; <br> <br>   retcode = SQLError(g_hEnv, <br>              ptr ? ptr-&gt;hdbc : 0, <br>              ptr ? ptr-&gt;hstmt :0, <br>              szSqlState, <br>              &amp;fNativeError, <br>              szErrorMsg, <br>              MSG_BUF_SIZE, <br>              &amp;cbErrorMsg <br>              ); <br> <br>   if (retcode != SQL_NO_DATA_FOUND &amp;&amp; retcode != SQL_ERROR) <br>   { <br>      if (fNativeError != 0x1645)   // ignore change database to master context message <br>      { <br>         printf("SQLError info:\n"); <br>         printf("SqlState: %s, fNativeError: %x\n",szSqlState,fNativeError); <br>         printf("Error Message: %s\n\n",szErrorMsg); <br>      } <br>   } <br>   else <br>   { <br>      printf("SQLError() failed: %x, NO_DATA_FOUND OR SQL_ERROR\n",retcode); <br>   } <br> <br>} <br>// --------------------------------------------------------------------------- <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
