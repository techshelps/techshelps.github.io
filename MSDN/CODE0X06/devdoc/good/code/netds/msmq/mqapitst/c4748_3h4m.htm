<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAINFRM.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4756"></a>MAINFRM.CPP</h2>
<pre><code>/* ************************************************************************ */ <br>/*                                                                          */ <br>/* Main file of the application MQ API test.                                */ <br>/*                                                                          */ <br>/* ************************************************************************ */ <br> <br>// <br>// MainFrm.cpp : implementation of the CMainFrame class <br>// <br> <br>#include "stdafx.h" <br>#include "MQApitst.h" <br>#include &lt;afxtempl.h&gt; <br> <br>#include "MainFrm.h" <br>#include "CrQDlg.h" <br>#include "DelQDlg.h" <br>#include "OpenQDlg.h" <br>#include "ClosQDlg.h" <br>#include "SendMDlg.h" <br>#include "RecvMDlg.h" <br>#include "RecWDlg.h" <br>#include "LocatDlg.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>LPSTR UnicodeStringToAnsiString(LPCWSTR lpcsUnicode) <br>{ <br>    LPSTR lpAnsiString = NULL; <br> <br>    if (lpcsUnicode) <br>    { <br>        DWORD dwSize = wcstombs(NULL, lpcsUnicode, 0); <br>        lpAnsiString = new char[dwSize+1]; <br>        size_t rc = wcstombs(lpAnsiString, lpcsUnicode, dwSize); <br>        ASSERT(rc != (size_t)(-1)); <br>        lpAnsiString[dwSize] = '\0'; <br>    } <br> <br>    return lpAnsiString; <br>} <br> <br>void AnsiStringToUnicode(LPWSTR lpsUnicode, LPSTR  lpsAnsi, DWORD  nSize) <br>{ <br>    if (lpsUnicode == NULL) <br>    { <br>        return; <br>    } <br> <br>    ASSERT(lpsAnsi != NULL); <br> <br>    size_t rc = mbstowcs(lpsUnicode, lpsAnsi, nSize); <br>    ASSERT(rc != (size_t)(-1)); <br>    if (lpsUnicode[nSize-1] != L'\0') <br>        lpsUnicode[nSize] = L'\0'; <br>} <br> <br>#ifdef UNICODE <br>#define _mqscpy(dest, src)  wcscpy(dest, src) <br>#else <br>#define _mqscpy(dest, src)  AnsiStringToUnicode(dest, src, _tcslen(src)+1) <br>#endif <br> <br>BOOL GetTextualSid( <br>    PSID pSid,          // binary SID <br>    LPTSTR TextualSID,   // buffer for textual representation of SID <br>    LPDWORD dwBufferLen // required/provided TextualSid buffersize <br>    ) <br>{ <br>    PSID_IDENTIFIER_AUTHORITY psia; <br>    DWORD dwSubAuthorities; <br>    DWORD dwSidRev=SID_REVISION; <br>    DWORD dwCounter; <br>    DWORD dwSidSize; <br> <br>    // obtain SidIdentifierAuthority <br>    psia=&amp;((SID *)pSid)-&gt;IdentifierAuthority; <br> <br>    // obtain sidsubauthority count <br>    dwSubAuthorities=(DWORD)((SID *)pSid)-&gt;SubAuthorityCount; <br> <br>    // <br>    // compute buffer length <br>    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL <br>    // <br>    dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR); <br> <br>    // <br>    // check provided buffer length. <br>    // If not large enough, indicate proper size and setlasterror <br>    // <br>    if (*dwBufferLen &lt; dwSidSize) <br>    { <br>        *dwBufferLen = dwSidSize; <br>        SetLastError(ERROR_INSUFFICIENT_BUFFER); <br>        return FALSE; <br>    } <br> <br>    // <br>    // prepare S-SID_REVISION- <br>    // <br>    TextualSID += _stprintf(TextualSID, TEXT("S-%lu-"), dwSidRev ); <br> <br>    // <br>    // prepare SidIdentifierAuthority <br>    // <br>    if ( (psia-&gt;Value[0] != 0) || (psia-&gt;Value[1] != 0) ) <br>    { <br>        TextualSID += _stprintf(TextualSID, <br>                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"), <br>                    (USHORT)psia-&gt;Value[0], <br>                    (USHORT)psia-&gt;Value[1], <br>                    (USHORT)psia-&gt;Value[2], <br>                    (USHORT)psia-&gt;Value[3], <br>                    (USHORT)psia-&gt;Value[4], <br>                    (USHORT)psia-&gt;Value[5]); <br>    } <br>    else <br>    { <br>        TextualSID += _stprintf(TextualSID, TEXT("%lu"), <br>                    (ULONG)(psia-&gt;Value[5]      )   + <br>                    (ULONG)(psia-&gt;Value[4] &lt;&lt;  8)   + <br>                    (ULONG)(psia-&gt;Value[3] &lt;&lt; 16)   + <br>                    (ULONG)(psia-&gt;Value[2] &lt;&lt; 24)   ); <br>    } <br> <br>    // <br>    // loop through SidSubAuthorities <br>    // <br>    for (dwCounter=0 ; dwCounter &lt; dwSubAuthorities ; dwCounter++) <br>    { <br>        TextualSID += _stprintf(TextualSID, TEXT("-%lu"), <br>                    ((SID *)pSid)-&gt;SubAuthority[ dwCounter] ); <br>    } <br> <br>    return TRUE; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CMainFrame <br> <br>IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd) <br> <br>BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd) <br>   //{{AFX_MSG_MAP(CMainFrame) <br>   ON_WM_CREATE() <br>   ON_COMMAND(ID_API_CREATE_QUEUE, OnApiCreateQueue) <br>   ON_COMMAND(ID_API_DELETE_QUEUE, OnApiDeleteQueue) <br>   ON_COMMAND(ID_API_OPEN_QUEUE, OnApiOpenQueue) <br>   ON_COMMAND(ID_API_CLOSE_QUEUE, OnApiCloseQueue) <br>   ON_COMMAND(ID_API_SEND_MESSAGE, OnApiSendMessage) <br>   ON_COMMAND(ID_API_RECEIVE_MESSAGE, OnApiReceiveMessage) <br>   ON_COMMAND(ID_API_LOCATE, OnApiLocate) <br>   //}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>static UINT indicators[] = <br>{ <br>   ID_SEPARATOR,           // status line indicator <br>   ID_INDICATOR_CAPS, <br>   ID_INDICATOR_NUM, <br>   ID_INDICATOR_SCRL, <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CMainFrame construction/destruction <br> <br>CMainFrame::CMainFrame() <br>{ <br>   // TODO: add member initialization code here. <br>} <br> <br>CMainFrame::~CMainFrame() <br>{ <br>} <br> <br>int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) <br>{ <br>    if (CFrameWnd::OnCreate(lpCreateStruct) == -1) <br>        return -1; <br> <br>    if (!m_wndToolBar.Create(this) || <br>        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME)) <br>    { <br>        TRACE0("Failed to create toolbar\n"); <br>        return -1;      // fail to create <br>    } <br> <br>    if (!m_wndStatusBar.Create(this) || <br>        !m_wndStatusBar.SetIndicators(indicators, <br>        sizeof(indicators)/sizeof(UINT))) <br>    { <br>        TRACE0("Failed to create status bar\n"); <br>        return -1;      // fail to create <br>    } <br> <br>    // TODO: Remove this if you don't want tool tips or a resizeable toolbar <br>    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() | <br>        CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC); <br> <br>    // TODO: Delete these three lines if you don't want the toolbar to <br>    //  be dockable <br>    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY); <br>    EnableDocking(CBRS_ALIGN_ANY); <br>    DockControlBar(&amp;m_wndToolBar); <br> <br>    return 0; <br>} <br> <br>BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs) <br>{ <br>    // TODO: Modify the Window class or styles here by modifying <br>    //  the CREATESTRUCT cs <br> <br>    return CFrameWnd::PreCreateWindow(cs); <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CMainFrame diagnostics <br> <br>#ifdef _DEBUG <br>void CMainFrame::AssertValid() const <br>{ <br>    CFrameWnd::AssertValid(); <br>} <br> <br>void CMainFrame::Dump(CDumpContext&amp; dc) const <br>{ <br>    CFrameWnd::Dump(dc); <br>} <br> <br>#endif //_DEBUG <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CMainFrame message handlers <br> <br>#define MAXINDEX 31 <br> <br> <br>/* ************************************************************************ */ <br>/*                        RemoveFromPathNameArray                           */ <br>/* ************************************************************************ */ <br>/* This function goes through the PathName Array and compares the given     */ <br>/* PathName to the PathName's of the items in the array.                    */ <br>/* If a match is found the item is removed from the array and the function  */ <br>/* returns a pointer to the item, otherwise a NULL pointer is returned.     */ <br>/* ************************************************************************ */ <br>ARRAYQ* CMainFrame::RemoveFromPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]) <br>{ <br>    int Index; <br>    int MaxIndex = m_PathNameArray.GetSize(); <br>    ARRAYQ* pQueue; <br> <br>    // <br>    // Loop through the PathName array. <br>    // <br>    for (Index=0; Index&lt;MaxIndex; Index++) <br>    { <br>        if (_tcscmp(szPathName, m_PathNameArray[Index]-&gt;szPathName) == 0) <br>        { <br>            // <br>            // Found a match. <br>            // <br>            pQueue = m_PathNameArray[Index]; <br>            m_PathNameArray.RemoveAt(Index); <br>            return pQueue; <br>        } <br>    } <br>    return NULL; // ERROR - no match was found. <br>} <br> <br>/* ************************************************************************ */ <br>/*                             CleanPathNameArray                           */ <br>/* ************************************************************************ */ <br>/* This function goes through the PathName array and deletes all the items  */ <br>/* in it. the function frees the allocated memory.                          */ <br>/* ************************************************************************ */ <br>void CMainFrame::CleanPathNameArray() <br>{ <br>    ARRAYQ* pQueue; <br> <br>    while (m_PathNameArray.GetSize() &gt; 0) <br>    { <br>        pQueue = m_PathNameArray[0]; <br>        m_PathNameArray.RemoveAt(0); <br>        delete pQueue; <br>    } <br>} <br> <br>/* ************************************************************************ */ <br>/*                        RemoveFromOpenedQueuePathNameArray                */ <br>/* ************************************************************************ */ <br>/* This function goes through the OpenedPathName Array and compares the     */ <br>/* given PathName to the PathName's of the items in the array.              */ <br>/* If a match is found the item is removed from the array and the function  */ <br>/* returns a pointer to the item, otherwise a NULL pointer is returned.     */ <br>/* ************************************************************************ */ <br>ARRAYQ* CMainFrame::RemoveFromOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]) <br>{ <br>    int Index; <br>    int MaxIndex = m_OpenedQueuePathNameArray.GetSize(); <br>    ARRAYQ* pQueue; <br> <br>    // <br>    // Loop through the OpenedPathName array. <br>    // <br>    for (Index=0; Index&lt;MaxIndex; Index++) <br>    { <br>        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]-&gt;szPathName) == 0) <br>        { <br>            // <br>            // Found a match. <br>            // <br>            pQueue = m_OpenedQueuePathNameArray[Index]; <br>            m_OpenedQueuePathNameArray.RemoveAt(Index); <br>            return pQueue; <br>        } <br>    } <br>    return NULL; // ERROR - no match was found. <br>} <br> <br>/* ************************************************************************ */ <br>/*                           IsOpenedQueueArrayEmpty                        */ <br>/* ************************************************************************ */ <br>/* This function checks if the size of the OpenedPathName array is zero or  */ <br>/* less and if so it returns TRUE otherwise it returns FALSE.               */ <br>/* ************************************************************************ */ <br>BOOL CMainFrame::IsOpenedQueueArrayEmpty() <br>{ <br>    if (m_OpenedQueuePathNameArray.GetSize() &lt;= 0) <br>    { <br>        return TRUE; <br>    } <br>    else <br>    { <br>        return FALSE; <br>    } <br>} <br> <br>/* ************************************************************************ */ <br>/*                        MoveToOpenedQueuePathNameArray                    */ <br>/* ************************************************************************ */ <br>/* This function moves an item from the PathName array to the               */ <br>/* OpenedPathName array. also it updates the hadle and the access rights    */ <br>/* to the moved queue.                                                      */ <br>/* ************************************************************************ */ <br>void CMainFrame::MoveToOpenedQueuePathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN], <br>                                                QUEUEHANDLE hQueue, DWORD dwAccess) <br>{ <br>    ARRAYQ* pQueue; <br> <br>    pQueue = RemoveFromPathNameArray(szPathName); <br>    pQueue-&gt;hHandle = hQueue;                     // add Queue Handle. <br>    pQueue-&gt;dwAccess = dwAccess;                  // add Queue Access rights. <br>    Add2OpenedQueuePathNameArray(pQueue); <br>} <br> <br>/* ************************************************************************ */ <br>/*                              MoveToPathNameArray                         */ <br>/* ************************************************************************ */ <br>/* This function moves an item from the OpenedPathName array to the         */ <br>/* PathName array.                                                          */ <br>/* ************************************************************************ */ <br>void CMainFrame::MoveToPathNameArray(TCHAR szPathName[MAX_Q_PATHNAME_LEN]) <br>{ <br>    ARRAYQ* pQueue; <br> <br>    pQueue = RemoveFromOpenedQueuePathNameArray(szPathName); <br>    Add2PathNameArray(pQueue); <br>} <br> <br>/* ************************************************************************ */ <br>/*                             UpdatePathNameArrays                         */ <br>/* ************************************************************************ */ <br>/* This function goes through the Opened Queue PathName array and for every */ <br>/* item in it, it checkes if the item is found in the PathName array as     */ <br>/* well, if so the function removes the item from the PathName array.       */ <br>/* ************************************************************************ */ <br>void CMainFrame::UpdatePathNameArrays() <br>{ <br>    int PathNameIndex; <br>    int OpenedPathNameIndex; <br>    int MaxPathNameIndex = m_PathNameArray.GetSize(); <br>    int MaxOpenedPathNameIndex = m_OpenedQueuePathNameArray.GetSize(); <br>    ARRAYQ* pQueue; <br> <br>    // <br>    // Loop through the OpenedPathName array. <br>    // <br>    for (OpenedPathNameIndex=0; OpenedPathNameIndex&lt;MaxOpenedPathNameIndex; OpenedPathNameIndex++) <br>    { <br>        for (PathNameIndex=0; PathNameIndex&lt;MaxPathNameIndex; PathNameIndex++) <br>        { <br>            if (_tcscmp(m_OpenedQueuePathNameArray[OpenedPathNameIndex]-&gt;szPathName, <br>                m_PathNameArray[PathNameIndex]-&gt;szPathName) == 0) <br>            { <br>                // <br>                // Found a match, remove it from PathName Array. <br>                // <br>                pQueue = m_PathNameArray[PathNameIndex]; <br>                m_PathNameArray.RemoveAt(PathNameIndex); <br>                delete pQueue; <br>                // <br>                // get out of inner for loop. <br>                // <br>                break; <br>            } <br>        } <br>    } <br>} <br> <br> <br>/* ************************************************************************ */ <br>/*                              GetQueueHandle                              */ <br>/* ************************************************************************ */ <br>/* This function goes through the OpenedPathName array and retrieve the     */ <br>/* Handle to the queue which matches the given PathName. If no match was    */ <br>/* found the function returns FALSE.                                        */ <br>/* ************************************************************************ */ <br>BOOL CMainFrame::GetQueueHandle(TCHAR szPathName[MAX_Q_PATHNAME_LEN], <br>                                QUEUEHANDLE* phClosedQueueHandle) <br>{ <br>    int Index; <br>    int MaxIndex = m_OpenedQueuePathNameArray.GetSize(); <br>    ARRAYQ* pQueue; <br> <br>    // <br>    // Loop through the OpenedPathName array. <br>    // <br>    for (Index=0; Index&lt;MaxIndex; Index++) <br>    { <br>        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]-&gt;szPathName) == 0) <br>        { <br>            // <br>            // Found a match. <br>            // <br>            pQueue = m_OpenedQueuePathNameArray[Index]; <br>            *phClosedQueueHandle = pQueue-&gt;hHandle; <br>            return TRUE; <br>        } <br>    } <br>    return FALSE; // ERROR - no match was found. <br>} <br> <br>/* ************************************************************************ */ <br>/*                       TranslatePathNameToFormatName                      */ <br>/* ************************************************************************ */ <br>/* This function goes through the PathName array and retrieve the           */ <br>/* FormatName to the queue which matches the given PathName. If no match    */ <br>/* was found the function returns FALSE.                                    */ <br>/* ************************************************************************ */ <br>BOOL CMainFrame::TranslatePathNameToFormatName(TCHAR szPathName[MAX_Q_PATHNAME_LEN], <br>                                               TCHAR szFormatName[MAX_Q_FORMATNAME_LEN]) <br>{ <br>    int Index; <br>    int MaxIndex = m_PathNameArray.GetSize(); <br>    ARRAYQ* pQueue; <br> <br>    // <br>    // Loop through the PathName array. <br>    // <br>    for (Index=0; Index&lt;MaxIndex; Index++) <br>    { <br>        if (_tcscmp(szPathName, m_PathNameArray[Index]-&gt;szPathName) == 0) <br>        { <br>            // <br>            // Found a match. <br>            // <br>            pQueue = m_PathNameArray[Index]; <br>            _tcsncpy (szFormatName, pQueue-&gt;szFormatName, MAX_Q_FORMATNAME_LEN); <br>            return TRUE; <br>        } <br>    } <br>    return FALSE; // ERROR - no match was found. <br>} <br> <br>/* ************************************************************************ */ <br>/*                  TranslateOpenedQueuePathNameToFormatName                */ <br>/* ************************************************************************ */ <br>/* This function goes through the OpenedPathName array and retrieve the     */ <br>/* FormatName to the queue which matches the given PathName. If no match    */ <br>/* was found the function returns FALSE.                                    */ <br>/* ************************************************************************ */ <br>BOOL CMainFrame::TranslateOpenedQueuePathNameToFormatName( <br>    TCHAR szPathName[MAX_Q_PATHNAME_LEN], <br>    TCHAR szFormatName[MAX_Q_FORMATNAME_LEN] <br>    ) <br>{ <br>    int Index; <br>    int MaxIndex = m_OpenedQueuePathNameArray.GetSize(); <br>    ARRAYQ* pQueue; <br> <br>    // <br>    // Loop through the OpenedPathName array. <br>    // <br>    for (Index=0; Index&lt;MaxIndex; Index++) <br>    { <br>        if (_tcscmp(szPathName, m_OpenedQueuePathNameArray[Index]-&gt;szPathName) == 0) <br>        { <br>            // <br>            // Found a match. <br>            // <br>            pQueue = m_OpenedQueuePathNameArray[Index]; <br>            _tcsncpy (szFormatName, pQueue-&gt;szFormatName, MAX_Q_FORMATNAME_LEN); <br>            return TRUE; <br>        } <br>    } <br>    return FALSE; // ERROR - no match was found. <br>} <br> <br> <br>/* ************************************************************************ */ <br>/*                         DisplayPathNameArray                             */ <br>/* ************************************************************************ */ <br>/* This function goes through the PathName Array and prints it to screen.   */ <br>/* ************************************************************************ */ <br>void CMainFrame::DisplayPathNameArray() <br>{ <br>    int Index; <br>    int MaxIndex = m_PathNameArray.GetSize(); <br>    TCHAR szMsgBuffer[BUFFERSIZE]; <br> <br>    _stprintf(szMsgBuffer, TEXT("   Located Queues Path Name :")); <br>    PrintToScreen(szMsgBuffer); <br>    // <br>    // Loop through the PathName array. <br>    // <br>    for (Index=0; Index&lt;MaxIndex; Index++) <br>    { <br>        // <br>        // Print the PathNames. <br>        // <br>        _stprintf(szMsgBuffer, TEXT("\t%d. %s"),Index+1, m_PathNameArray[Index]-&gt;szPathName); <br>        PrintToScreen(szMsgBuffer); <br>    } <br>} <br> <br>/* ************************************************************************ */ <br>/*                    DisplayOpenedQueuePathNameArray                       */ <br>/* ************************************************************************ */ <br>/* This function goes through the Opened Queues PathName Array and          */ <br>/* prints it to screen.                                                     */ <br>/* ************************************************************************ */ <br>void CMainFrame::DisplayOpenedQueuePathNameArray() <br>{ <br>    int Index; <br>    int MaxIndex = m_OpenedQueuePathNameArray.GetSize(); <br>    TCHAR szMsgBuffer[BUFFERSIZE]; <br> <br>    _stprintf(szMsgBuffer, TEXT("   Currently Opened Queues Path Names:")); <br>    PrintToScreen(szMsgBuffer); <br>    // <br>    // Loop through the OpenedQueuePathName array. <br>    // <br>    for (Index=0; Index&lt;MaxIndex; Index++) <br>    { <br>        // <br>        // Print the PathNames. <br>        // <br>        _stprintf(szMsgBuffer, TEXT("\t%d. %s"),Index+1, m_OpenedQueuePathNameArray[Index]-&gt;szPathName); <br>        PrintToScreen(szMsgBuffer); <br>    } <br>} <br> <br>/* ************************************************************************ */ <br>/*                          GetMsgClassStatus                               */ <br>/* ************************************************************************ */ <br>/* This function sets proper status string based on a given MQMSG class.    */ <br>/* ************************************************************************ */ <br> <br>struct <br>{ <br>unsigned shortmclass; <br>LPTSTR          pszDescription; <br>} StringClass[] = <br>  { <br>{ MQMSG_CLASS_NORMAL, TEXT("The Message was received successfully.")}, <br>{ MQMSG_CLASS_ACK_REACH_QUEUE, TEXT("The REACH QUEUE ACK Message was read successfully.")}, <br>{ MQMSG_CLASS_ACK_RECEIVE, TEXT("The RECEIVE ACK Message was read successfully.")}, <br>{ MQMSG_CLASS_NACK_BAD_DST_Q, TEXT("The DESTINATION QUEUE HANDLE INVALID Nack Message was read successfully.")}, <br>{ MQMSG_CLASS_NACK_RECEIVE_TIMEOUT, TEXT("The TIME TO RECEIVE EXPIRED Nack Message was read successfully.")}, <br>{ MQMSG_CLASS_NACK_REACH_QUEUE_TIMEOUT, TEXT("The TIME TO REACH QUEUE EXPIRED Nack Message was read successfully.")}, <br>{ MQMSG_CLASS_NACK_Q_EXCEED_QUOTA, TEXT("The QUEUE IS FULL Nack Message was read successfully.")}, <br>{ MQMSG_CLASS_NACK_ACCESS_DENIED, TEXT("The SENDER HAVE NO SEND ACCESS RIGHTS ON QUEUE Nack Message was read successfully.")}, <br>{ MQMSG_CLASS_NACK_HOP_COUNT_EXCEEDED, TEXT("The HOP COUNT EXCEEDED Nack Message was read successfully.")}, <br>{ MQMSG_CLASS_NACK_BAD_SIGNATURE, TEXT("The MESSAGE RECEIVED WITH BAD SIGNATURE Nack Message was read successfully.")}, <br>{ MQMSG_CLASS_NACK_BAD_ENCRYPTION, TEXT("The MSG COULD NOT DECRYPTED Nack Message was read successfully.")}, <br>    { MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT, TEXT("The SOURCE QM COULD NOT ENCRYPT MSG FOR DEST QM Nack Message was read successfully.")}, <br>{ 0, NULL} <br>  }; <br> <br>void CMainFrame::ClassToString(unsigned short MsgClass,LPTSTR pszStatus) <br>{ <br>// <br>// loop the StringClass array to find MsgClass <br>// <br>DWORD dwIndex = 0; <br>while (StringClass[dwIndex].pszDescription != NULL) <br>{ <br>if (StringClass[dwIndex].mclass == MsgClass) <br>{ <br>_stprintf(pszStatus,StringClass[dwIndex].pszDescription); <br>return; <br>} <br>dwIndex++; <br>} <br> <br>// <br>// MsgClass not found - print default error <br>// <br>_stprintf(pszStatus,TEXT("The NACK (0x%X) Message was read successfully."),MsgClass); <br>} <br> <br> <br>/* ************************************************************************ */ <br>/*                            OnApiCreateQueue                              */ <br>/* ************************************************************************ */ <br>/* This function opens a dialog box and asks the user for the queue's       */ <br>/* PathName and Label. Then it creates the specified queue.                 */ <br>/*                                                                          */ <br>/* Uses: MQCreateQueue.                                                     */ <br>/* ************************************************************************ */ <br>void CMainFrame::OnApiCreateQueue() <br>{ <br>    // TODO: Add your command handler code here <br> <br>    TCHAR szMsgBuffer[BUFFERSIZE]; <br> <br>    MQQUEUEPROPS QueueProps; <br>    MQPROPVARIANT aVariant[MAXINDEX]; <br>    QUEUEPROPID aPropId[MAXINDEX]; <br>    DWORD PropIdCount = 0; <br>    HRESULT hr; <br> <br>    PSECURITY_DESCRIPTOR pSecurityDescriptor; <br> <br>    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szFormatNameBuffer[MAX_Q_FORMATNAME_LEN]; <br>    TCHAR szLabelBuffer[MAX_Q_PATHNAME_LEN]; <br>    DWORD dwFormatNameBufferLength = MAX_Q_FORMATNAME_LEN; <br> <br> <br>    // <br>    // Display CreateQueue Dialog. <br>    // <br>    CCreateQueueDialog CreateQueueDialog; <br> <br>    if(CreateQueueDialog.DoModal() == IDCANCEL) <br>    { <br>        return; <br>    } <br>    CreateQueueDialog.GetPathName(szPathNameBuffer); <br>    CreateQueueDialog.GetLabel(szLabelBuffer); <br> <br>    // <br>    // Get the input fields from the dialog box <br>    // and prepare the property array PROPVARIANT <br>    // <br> <br> <br>    // <br>    // Set the PROPID_Q_PATHNAME property <br>    // <br>    aPropId[PropIdCount] = PROPID_Q_PATHNAME;    //PropId <br>    aVariant[PropIdCount].vt = VT_LPWSTR;        //Type <br>    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_Q_PATHNAME_LEN]; <br>    _mqscpy(aVariant[PropIdCount].pwszVal, szPathNameBuffer); //Value <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_Q_LABEL property <br>    // <br>    aPropId[PropIdCount] = PROPID_Q_LABEL;    //PropId <br>    aVariant[PropIdCount].vt = VT_LPWSTR;     //Type <br>    aVariant[PropIdCount].pwszVal = new WCHAR[MAX_Q_PATHNAME_LEN]; <br>    _mqscpy(aVariant[PropIdCount].pwszVal, szLabelBuffer); //Value <br> <br>    PropIdCount++; <br> <br> <br>    // <br>    // Set the MQEUEUPROPS structure <br>    // <br>    QueueProps.cProp = PropIdCount;           //No of properties <br>    QueueProps.aPropID = aPropId;             //Id of properties <br>    QueueProps.aPropVar = aVariant;           //Value of properties <br>    QueueProps.aStatus = NULL;                //No error reports <br> <br>    // <br>    // No security (default) <br>    // <br>    pSecurityDescriptor = NULL; <br> <br>    // <br>    // Create the queue <br>    // <br>#ifdef UNICODE <br>    hr = MQCreateQueue( <br>            pSecurityDescriptor,            //Security <br>            &amp;QueueProps,                    //Queue properties <br>            szFormatNameBuffer,             //Output: Format Name <br>            &amp;dwFormatNameBufferLength       //Output: Format Name len <br>            ); <br>#else <br>    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN]; <br>    hr = MQCreateQueue( <br>            pSecurityDescriptor,            //Security <br>            &amp;QueueProps,                    //Queue properties <br>            szwFormatNameBuffer,            //Output: Format Name <br>            &amp;dwFormatNameBufferLength       //Output: Format Name len <br>            ); <br> <br>    if (SUCCEEDED(hr)) <br>    { <br>        size_t rc =wcstombs(szFormatNameBuffer, szwFormatNameBuffer, dwFormatNameBufferLength); <br>        ASSERT(rc != (size_t)(-1)); <br>    } <br>#endif <br> <br>    if (FAILED(hr)) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("MQCreateQueue failed, Error code = 0x%x."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>    } <br>    else <br>    { <br>        // <br>        // Success - write in edit control. <br>        // <br>        _stprintf(szMsgBuffer, TEXT("The queue %s was created successfully. ( FormatName: %s )"), <br>            szPathNameBuffer, szFormatNameBuffer); <br>        PrintToScreen(szMsgBuffer); <br> <br>        // <br>        // Add the new queue to the PathName Array. <br>        // <br>        ARRAYQ* pNewQueue = new ARRAYQ; <br>        // <br>        // Save PathName and FormatName in the ARRAYQ structure. <br>        // <br>        _tcsncpy (pNewQueue-&gt;szPathName, szPathNameBuffer, MAX_Q_PATHNAME_LEN); <br>        _tcsncpy (pNewQueue-&gt;szFormatName, szFormatNameBuffer, MAX_Q_FORMATNAME_LEN); <br>        Add2PathNameArray(pNewQueue); <br>    } <br> <br>    // <br>    // Free allocated memory <br>    // <br>    delete   aVariant[0].pwszVal; <br>    delete   aVariant[1].pwszVal; <br>} <br> <br>/* ************************************************************************ */ <br>/*                            OnApiDeleteQueue                              */ <br>/* ************************************************************************ */ <br>/* This function opens a dialog box and asks the user for the queue's       */ <br>/* PathName. then it deletes the specified queue.                           */ <br>/*                                                                          */ <br>/* Uses: MQDeleteQueue.                                                     */ <br>/* ************************************************************************ */ <br>void CMainFrame::OnApiDeleteQueue() <br>{ <br>    // TODO: Add your command handler code here <br>    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szFormatNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szMsgBuffer[BUFFERSIZE]; <br> <br>    HRESULT hr; <br> <br>    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN; <br> <br>    CDeleteQueueDialog DeleteQueueDialog(&amp;m_PathNameArray); <br> <br>    // <br>    // Display DeleteQueue Dialog. <br>    // <br>    if (DeleteQueueDialog.DoModal() == IDCANCEL) <br>    { <br>        return; <br>    } <br> <br>    DeleteQueueDialog.GetPathName(szPathNameBuffer); <br> <br>    // <br>    // Translate the path name to format name using the ARRAYQ arrays. <br>    // <br>    if (TranslatePathNameToFormatName(szPathNameBuffer, szFormatNameBuffer) == FALSE) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("Queue wasn't found")); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>        return; <br>    } <br> <br>    // <br>    // Delete the queue. <br>    // <br>#ifdef UNICODE <br>    hr = MQDeleteQueue(szFormatNameBuffer);  // FormatName of the Queue to be deleted. <br>#else <br>    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN]; <br>    size_t rc = mbstowcs(szwFormatNameBuffer, szFormatNameBuffer, _tcslen(szFormatNameBuffer)+1); <br>    ASSERT(rc != (size_t)(-1)); <br>    hr = MQDeleteQueue(szwFormatNameBuffer);  // FormatName of the Queue to be deleted. <br>#endif <br> <br>    if (FAILED(hr)) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("MQDeleteQueue failed, Error code = 0x%x."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>    } <br>    else <br>    { <br>        // <br>        // Success - write in edit control <br>        // <br>        _stprintf(szMsgBuffer, TEXT("The queue %s was deleted successfully."), szPathNameBuffer); <br>        PrintToScreen(szMsgBuffer); </code></pre>
<p>
</p>
<pre><code>// <br>        // Delete the name from the Path Names array. <br>        // <br>        ARRAYQ* DeletedQueue = RemoveFromPathNameArray(szPathNameBuffer); <br>        if (DeletedQueue != NULL) <br>        { <br>            delete DeletedQueue; <br>        } <br>    } <br>} <br> <br>/* ************************************************************************ */ <br>/*                             OnApiOpenQueue                               */ <br>/* ************************************************************************ */ <br>/* This function opens a dialog box and asks the user for the queue's       */ <br>/* PathName. then it opens the specified queue.                             */ <br>/*                                                                          */ <br>/* Uses: MQOpenQueue.                                                       */ <br>/* ************************************************************************ */ <br>void CMainFrame::OnApiOpenQueue() <br>{ <br>    // TODO: Add your command handler code here <br>    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szFormatNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szAccessBuffer[50]; // BUGBUG - maybe set with a define <br>    TCHAR szMsgBuffer[BUFFERSIZE]; <br> <br>    HRESULT hr; <br> <br>    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN; <br>    DWORD dwAccess; <br> <br>    QUEUEHANDLE hQueue; <br> <br>    COpenQueueDialog OpenQueueDialog(&amp;m_PathNameArray); <br> <br>    // <br>    // Display the OpenQueue dialog. <br>    // <br>    if (OpenQueueDialog.DoModal() == IDCANCEL) <br>    { <br>        return; <br>    } <br> <br>    OpenQueueDialog.GetPathName(szPathNameBuffer); <br>    dwAccess = OpenQueueDialog.GetAccess(); <br>    // <br>    // Set the access buffer string. <br>    // <br>    switch (dwAccess) <br>    { <br>    case (MQ_RECEIVE_ACCESS | MQ_SEND_ACCESS): <br> <br>        _tcscpy(szAccessBuffer, TEXT("MQ_RECEIVE_ACCESS, MQ_SEND_ACCESS.")); <br>        break; <br> <br>    case MQ_RECEIVE_ACCESS: <br> <br>        _tcscpy(szAccessBuffer, TEXT("MQ_RECEIVE_ACCESS.")); <br>        break; <br> <br>    case MQ_SEND_ACCESS: <br> <br>        _tcscpy(szAccessBuffer, TEXT("MQ_SEND_ACCESS.")); <br>        break; <br> <br>    default: <br> <br>        _tcscpy(szAccessBuffer, TEXT("NONE.")); <br>        break; <br>    } <br> <br>    // <br>    // Translate the path name to format name using the ARRAYQ arrays. <br>    // <br>    if (TranslatePathNameToFormatName(szPathNameBuffer, szFormatNameBuffer) == FALSE) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("Queue wasn't found")); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>        return; <br>    } <br> <br>    // <br>    // Open the queue. (no sharing) <br>    // <br>#ifdef UNICODE <br>    hr = MQOpenQueue( <br>            szFormatNameBuffer,     // Format Name of the queue to be opened. <br>            dwAccess,               // Access rights to the Queue. <br>            0,                      // No receive Exclusive. <br>            &amp;hQueue                 // OUT: handle to the opened Queue. <br>            ); <br>#else <br>    WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN]; <br>    size_t rc = mbstowcs(szwFormatNameBuffer, szFormatNameBuffer, _tcslen(szFormatNameBuffer)+1); <br>    ASSERT(rc != (size_t)(-1)); <br> <br>    hr = MQOpenQueue( <br>            szwFormatNameBuffer,    // Format Name of the queue to be opened. <br>            dwAccess,               // Access rights to the Queue. <br>            0,                      // No receive Exclusive. <br>            &amp;hQueue                 // OUT: handle to the opened Queue. <br>            ); <br>#endif <br> <br>    if (FAILED(hr)) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("MQOpenQueue failed, Error code = 0x%x."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>    } <br>    else <br>    { <br>        // <br>        // Success - write in edit control <br>        // <br>        _stprintf(szMsgBuffer, <br>            TEXT("The queue %s was opened successfully.\r\n\tQueueHandle: 0x%x\r\n\tQueue Access : %s"), <br>            szPathNameBuffer, <br>            hQueue, <br>            szAccessBuffer); <br>        PrintToScreen(szMsgBuffer); <br> <br>        // <br>        // move the queue to the opened queues array. <br>        // <br>        MoveToOpenedQueuePathNameArray(szPathNameBuffer, hQueue, dwAccess); <br>    } <br>} <br> <br>/* ************************************************************************ */ <br>/*                            OnApiCloseQueue                               */ <br>/* ************************************************************************ */ <br>/* This function opens a dialog box and asks the user for the queue's       */ <br>/* PathName. then it closes the specified queue.                            */ <br>/*                                                                          */ <br>/* Uses: MQCloseQueue.                                                      */ <br>/* ************************************************************************ */ <br>void CMainFrame::OnApiCloseQueue() <br>{ <br>    // TODO: Add your command handler code here <br> <br>    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szMsgBuffer[BUFFERSIZE]; <br> <br>    HRESULT hr; <br> <br>    DWORD dwFormatNameBufferLength = MAX_Q_PATHNAME_LEN; <br> <br>    QUEUEHANDLE hClosedQueueHandle; <br> <br>    // <br>    // Display CloseQueue Dialog. <br>    // <br>    CCloseQueueDialog CloseQueueDialog(&amp;m_OpenedQueuePathNameArray); <br> <br>    if (CloseQueueDialog.DoModal() == IDCANCEL) <br>    { <br>        return; <br>    } <br> <br>    CloseQueueDialog.GetPathName(szPathNameBuffer); <br> <br>    // <br>    // Get the closed queue handle. <br>    // <br>    if (GetQueueHandle(szPathNameBuffer, &amp;hClosedQueueHandle) == FALSE) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("The Queue couldn't be closed since it was not opened before.")); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>        return; <br>    } <br> <br>    // <br>    // Close the queue. <br>    // <br>    hr = MQCloseQueue(hClosedQueueHandle);   // the handle of the Queue to be closed. <br>    if (FAILED(hr)) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("MQCloseQueue failed, Error code = 0x%x."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>    } <br>    else <br>    { <br>        // <br>        // Success - write in edit control <br>        // <br>        _stprintf(szMsgBuffer, TEXT("The queue %s was closed successfully."), szPathNameBuffer); <br>        PrintToScreen(szMsgBuffer); <br>        // <br>        // Move the queue form the opened queues array to the path name array. <br>        // <br>        MoveToPathNameArray(szPathNameBuffer); <br>    } <br>} <br> <br>/* ************************************************************************ */ <br>/*                            OnApiSendMessage                              */ <br>/* ************************************************************************ */ <br>/* This function opens a dialog box and asks the user for the queue's       */ <br>/* PathName and some message properties. Then it sends the message to the   */ <br>/* specified queue.                                                         */ <br>/*                                                                          */ <br>/* Uses: MQSendMessage.                                                     */ <br>/* ************************************************************************ */ <br> <br>// <br>// two static buffers to hold the last message body and label for the next time. <br>// <br>TCHAR szLastMessageBody[BUFFERSIZE]; <br>TCHAR szLastMessageLabel[BUFFERSIZE]; <br> <br>void CMainFrame::OnApiSendMessage() <br>{ <br>    // TODO: Add your command handler code here <br> <br>    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szAdminPathNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szAdminFormatNameBuffer[MAX_Q_FORMATNAME_LEN]; <br>    TCHAR szMsgBuffer[BUFFERSIZE]; <br> <br>    MQMSGPROPS MsgProps; <br>    MQPROPVARIANT aVariant[MAXINDEX]; <br>    MSGPROPID aPropId[MAXINDEX]; <br>    DWORD PropIdCount = 0; <br> <br>    HRESULT hr; <br> <br>    unsigned char bPriority; <br>    unsigned char bDelivery; <br>    unsigned char bJournal; <br>    unsigned char bDeadLetter; <br>unsigned char bAuthenticated; <br>unsigned char bEncrypted; <br>    unsigned char bAcknowledge; <br> <br>    WCHAR szMessageBodyBuffer [BUFFERSIZE]; <br>    WCHAR szMessageLabelBuffer[BUFFERSIZE]; <br>    DWORD dwTimeToReachQueue; <br>DWORD dwTimeToBeReceived; <br> <br>    QUEUEHANDLE hQueue; <br> <br>    CSendMessageDialog SendMessageDialog(&amp;m_OpenedQueuePathNameArray); <br> <br>    // <br>    // Display the SendMessage dialog. <br>    // <br>    if (SendMessageDialog.DoModal() == IDCANCEL) <br>    { <br>        return; <br>    } <br> <br>    // <br>    // Retrieve the properties from the dialog box. <br>    // <br>    SendMessageDialog.GetPathName(szPathNameBuffer); <br>    SendMessageDialog.GetAdminPathName(szAdminPathNameBuffer); <br>    bPriority = SendMessageDialog.GetPriority(); <br>    bDelivery = SendMessageDialog.GetDelivery(); <br>    bJournal = SendMessageDialog.GetJournal(); <br>    bDeadLetter = SendMessageDialog.GetDeadLetter(); <br>bAuthenticated = SendMessageDialog.GetAuthenticated(); <br>bEncrypted = SendMessageDialog.GetEncrypted(); <br>    bAcknowledge = SendMessageDialog.GetAcknowledge(); <br>    SendMessageDialog.GetMessageBody(szLastMessageBody); <br>    SendMessageDialog.GetMessageLabel(szLastMessageLabel); <br>    dwTimeToReachQueue = SendMessageDialog.GetTimeToReachQueue(); <br>dwTimeToBeReceived = SendMessageDialog.GetTimeToBeReceived(); <br> <br>    // <br>    // Update the Last message properties. <br>    // <br>    _mqscpy(szMessageBodyBuffer, szLastMessageBody); <br>    _mqscpy(szMessageLabelBuffer, szLastMessageLabel); <br> <br>    // <br>    // Get the target queue handle. <br>    // <br>    if (GetQueueHandle(szPathNameBuffer, &amp;hQueue) == FALSE) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("GetQueueHandle failed. Queue not opened yet.")); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>        return; <br>    } <br> <br>    // <br>    // Get the admin queue FormatName. <br>    // <br>    if (TranslateOpenedQueuePathNameToFormatName(szAdminPathNameBuffer, szAdminFormatNameBuffer) == FALSE) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("TranslatePathNameToFormatName failed, Queue has not been opened yet.")); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>        return; <br>    } <br> <br>    // <br>    // prepare the property array PROPVARIANT. <br>    // <br> <br>    // <br>    // Set the PROPID_M_PRIORITY property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_PRIORITY;    //PropId <br>    aVariant[PropIdCount].vt = VT_UI1;           //Type <br>    aVariant[PropIdCount].bVal = bPriority;      //Value <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_DELIVERY property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_DELIVERY;    //PropId <br>    aVariant[PropIdCount].vt = VT_UI1;           //Type <br>    aVariant[PropIdCount].bVal = bDelivery;      //Value <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_ACKNOWLEDGE property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_ACKNOWLEDGE; //PropId <br>    aVariant[PropIdCount].vt = VT_UI1;           //Type <br>    aVariant[PropIdCount].bVal = bAcknowledge;   //Value <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_BODY property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_BODY;                  //PropId <br>    aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;           //Type <br>    aVariant[PropIdCount].caub.cElems = <br>        (wcslen(szMessageBodyBuffer) + 1) * sizeof(WCHAR); //Value <br>    aVariant[PropIdCount].caub.pElems = (unsigned char *)szMessageBodyBuffer; <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_LABEL property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_LABEL;                  //PropId <br>    aVariant[PropIdCount].vt = VT_LPWSTR;                   //Type <br>    aVariant[PropIdCount].pwszVal = szMessageLabelBuffer;     //Value <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_TIME_TO_REACH_QUEUE property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_TIME_TO_REACH_QUEUE;    //PropId <br>    aVariant[PropIdCount].vt = VT_UI4;                      //Type <br>    aVariant[PropIdCount].ulVal = dwTimeToReachQueue;       //Value <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_TIME_TO_BE_RECEIVED property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_TIME_TO_BE_RECEIVED;    //PropId <br>    aVariant[PropIdCount].vt = VT_UI4;                      //Type <br>    aVariant[PropIdCount].ulVal = dwTimeToBeReceived;       //Value <br> <br>    PropIdCount++; <br> <br> <br>    if (bJournal || bDeadLetter) <br>    { <br>        // <br>        // Set the PROPID_M_JOURNAL property. <br>        // <br>        aPropId[PropIdCount] = PROPID_M_JOURNAL;            //PropId <br>        aVariant[PropIdCount].vt = VT_UI1;                  //Type <br> <br>        if (bJournal) <br>            aVariant[PropIdCount].bVal = MQMSG_JOURNAL; <br>        else <br>            aVariant[PropIdCount].bVal = 0; <br>        if (bDeadLetter) <br>            aVariant[PropIdCount].bVal |= MQMSG_DEADLETTER; <br> <br>        PropIdCount++; <br>    } <br> <br> <br>if (bAuthenticated) <br>{ <br>// <br>// Set the PROPID_M_AUTH_LEVEL property. <br>// <br>aPropId[PropIdCount] = PROPID_M_AUTH_LEVEL;            //PropId <br>aVariant[PropIdCount].vt = VT_UI4;                     //Type <br>aVariant[PropIdCount].ulVal = MQMSG_AUTH_LEVEL_ALWAYS; //Value <br> <br>PropIdCount++; <br>} <br> <br>if (bEncrypted) <br>{ <br>// <br>// Set the PROPID_M_ENCRYPTION_ALG property. <br>// <br>aPropId[PropIdCount] = PROPID_M_PRIV_LEVEL;            //PropId <br>aVariant[PropIdCount].vt = VT_UI4;                     //Type <br>aVariant[PropIdCount].ulVal = MQMSG_PRIV_LEVEL_BODY;   //Value <br> <br>PropIdCount++; <br>} <br> <br> <br>    // <br>    // Set the PROPID_M_ADMIN_QUEUE property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_ADMIN_QUEUE;               //PropId <br>    aVariant[PropIdCount].vt = VT_LPWSTR;                      //Type <br>#ifdef UNICODE <br>    aVariant[PropIdCount].pwszVal = szAdminFormatNameBuffer;   //Value <br>#else <br>    WCHAR szwAdminFormatNameBuffer[MAX_Q_FORMATNAME_LEN]; <br>    size_t rc = mbstowcs(szwAdminFormatNameBuffer, <br>                    szAdminFormatNameBuffer, <br>                    _tcslen(szAdminFormatNameBuffer)+1); <br>    ASSERT(rc != (size_t)(-1)); <br>    aVariant[PropIdCount].pwszVal = szwAdminFormatNameBuffer;  //Value <br>#endif <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the MQMSGPROPS structure <br>    // <br>    MsgProps.cProp = PropIdCount;       //Number of properties. <br>    MsgProps.aPropID = aPropId;         //Id of properties. <br>    MsgProps.aPropVar = aVariant;       //Value of properties. <br>    MsgProps.aStatus  = NULL;           //No Error report. <br> <br>    // <br>    // Send the message. <br>    // <br>    hr = MQSendMessage( <br>            hQueue,                     // handle to the Queue. <br>            &amp;MsgProps,                  // Message properties to be sent. <br>            NULL                        // No transaction <br>            ); <br> <br>    if (FAILED(hr)) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("MQSendMessage failed, Error code = 0x%x."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>    } <br>    else <br>    { <br>        // <br>        // Success - write in edit control <br>        // <br>        _stprintf(szMsgBuffer, TEXT("The Message \"%s\" was sent successfully."), szLastMessageLabel); <br>        PrintToScreen(szMsgBuffer); <br>    } <br>} <br> <br>/* ************************************************************************ */ <br>/*                           OnApiReceiveMessage                            */ <br>/* ************************************************************************ */ <br>/* This function opens a dialog box and asks the user for the queue's       */ <br>/* PathName and the Time to wait for the message. Then it tries to get a    */ <br>/* message from the specified queue at the given time.                      */ <br>/*                                                                          */ <br>/* Uses: MQReceiveMessage, MQFreeMemory.                                    */ <br>/* ************************************************************************ */ <br>void CMainFrame::OnApiReceiveMessage() <br>{ <br>    TCHAR szPathNameBuffer[MAX_Q_PATHNAME_LEN]; <br>    TCHAR szMsgBuffer[2*BUFFERSIZE]; <br>    TCHAR szDomainName[BUFFERSIZE]; <br> TCHAR szAccountName[BUFFERSIZE]; <br>    DWORD dwActNameSize = sizeof(szAccountName); <br>    DWORD dwDomNameSize = sizeof(szDomainName); <br>    TCHAR szTextSid[BUFFERSIZE]; <br>    DWORD dwTextSidSize = sizeof(szTextSid); <br>    BYTE  blobBuffer[BUFFERSIZE]; <br> <br>    MQMSGPROPS MsgProps; <br>    MQPROPVARIANT aVariant[MAXINDEX]; <br>    MSGPROPID aPropId[MAXINDEX]; <br>    DWORD PropIdCount = 0; <br> <br>    HRESULT hr; <br> <br>    WCHAR szMessageLabelBuffer[BUFFERSIZE]; <br>    DWORD dwTimeout; <br> <br>    QUEUEHANDLE hQueue; <br> <br>    CReceiveWaitDialog    WaitDialog; <br>    CReceiveMessageDialog ReceiveMessageDialog(&amp;m_OpenedQueuePathNameArray); <br> <br>    // <br>    // Display the ReceiveMessage dialog. <br>    // <br>    if (ReceiveMessageDialog.DoModal() == IDCANCEL) <br>    { <br>        return; <br>    } <br> <br>    ReceiveMessageDialog.DestroyWindow(); <br>    ReceiveMessageDialog.GetPathName(szPathNameBuffer); <br> <br>    // <br>    // Get the queue handle. <br>    // <br>    if (GetQueueHandle(szPathNameBuffer, &amp;hQueue) == FALSE) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("GetQueueHandle failed. Queue was not found in Opened Queue Array")); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>        return; <br>    } <br> <br>    // <br>    // Retrieve the properties form the dialog box. <br>    // <br>    dwTimeout = ReceiveMessageDialog.GetTimeout(); <br> <br> <br>    // <br>    // prepare the property array PROPVARIANT of <br>    // message properties that we want to receive <br>    // <br> <br>    // <br>    // Set the PROPID_M_BODY property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_BODY;                                //PropId <br>    aVariant[PropIdCount].vt = VT_VECTOR|VT_UI1;                         //Type <br>    aVariant[PropIdCount].caub.cElems = ReceiveMessageDialog.GetBodySize() ; <br>    aVariant[PropIdCount].caub.pElems = (unsigned char *) new <br>                               char [ aVariant[PropIdCount].caub.cElems ] ; <br> <br>    int iBodyIndex = PropIdCount ; <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_LABEL property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_LABEL;                   //PropId <br>    aVariant[PropIdCount].vt = VT_LPWSTR;                    //Type <br>    aVariant[PropIdCount].pwszVal = szMessageLabelBuffer; <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_PRIORITY property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_PRIORITY;               //PropId <br>    aVariant[PropIdCount].vt = VT_UI1;                      //Type <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_CLASS property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_CLASS;                  //PropId <br>    aVariant[PropIdCount].vt = VT_UI2;                      //Type <br> <br>    PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_AUTHENTICATED property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_AUTHENTICATED;          //PropId <br>    aVariant[PropIdCount].vt = VT_UI1;                      //Type <br> <br>    PropIdCount++; <br> <br>// <br>// Set the PROPID_M_SENDERID property <br>// <br>aPropId[PropIdCount] = PROPID_M_SENDERID;               //PropId <br>aVariant[PropIdCount].vt = VT_UI1|VT_VECTOR;            //Type <br>aVariant[PropIdCount].blob.pBlobData = blobBuffer; <br>aVariant[PropIdCount].blob.cbSize = sizeof(blobBuffer); <br> <br>PropIdCount++; <br> <br>// <br>// Set the PROPID_M_PRIV_LEVEL property <br>// <br>aPropId[PropIdCount] = PROPID_M_PRIV_LEVEL;             //PropId <br>aVariant[PropIdCount].vt = VT_UI4          ;            //Type <br> <br>PropIdCount++; <br> <br>    // <br>    // Set the PROPID_M_LABEL_LEN property. <br>    // <br>    aPropId[PropIdCount] = PROPID_M_LABEL_LEN;              //PropId <br>    aVariant[PropIdCount].vt = VT_UI4;                      //Type <br>    aVariant[PropIdCount].ulVal = BUFFERSIZE;               //Value <br> <br>    PropIdCount++; <br> <br> <br>    // <br>    // Set the MQMSGPROPS structure <br>    // <br>    MsgProps.cProp = PropIdCount;       //Number of properties. <br>    MsgProps.aPropID = aPropId;         //Id of properties. <br>    MsgProps.aPropVar = aVariant;       //Value of properties. <br>    MsgProps.aStatus  = NULL;           //No Error report. <br> <br>    // <br>    // Display a message window until the message from the queue will be received. <br>    // <br>    WaitDialog.Create(IDD_WAIT_DIALOG,pMainView); <br>    WaitDialog.ShowWindow(SW_SHOWNORMAL); <br>    WaitDialog.UpdateWindow(); <br>    WaitDialog.CenterWindow(); <br>    pMainView-&gt;RedrawWindow(); <br> <br>    // <br>    // Receive the message. <br>    // <br>    hr = MQReceiveMessage( <br>               hQueue,               // handle to the Queue. <br>               dwTimeout,            // Max time (msec) to wait for the message. <br>               MQ_ACTION_RECEIVE,    // Action. <br>               &amp;MsgProps,            // properties to retrieve. <br>               NULL,                 // No overlaped structure. <br>               NULL,                 // No callback function. <br>               NULL,                 // No Cursor. <br>               NULL                  // No transaction <br>               ); <br> <br>    WaitDialog.ShowWindow(SW_HIDE); <br> <br> <br>if(hr == MQ_ERROR_IO_TIMEOUT) <br>{ <br>        _stprintf(szMsgBuffer, TEXT("MQReceiveMessage failed, Timeout expired."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>} <br>else if(hr != MQ_OK) <br>{ <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, TEXT("MQReceiveMessage failed, Error code = 0x%x."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>} <br>else <br>{ <br>        // <br>        // Success - write in edit control <br>        // <br>ClassToString(aVariant[3].uiVal,szMsgBuffer); <br>        PrintToScreen(szMsgBuffer); <br> <br>        // <br>        // Print some of the Message properties. <br>        // <br>#ifdef UNICODE <br>        _stprintf(szMsgBuffer, TEXT("\tLabel: %s"), (WCHAR *)(aVariant[1].pwszVal)); <br>#else <br>        { <br>            PCHAR lpLable = UnicodeStringToAnsiString((WCHAR *)(aVariant[1].pwszVal)); <br>            _stprintf(szMsgBuffer, TEXT("\tLabel: %s"), lpLable); <br>            delete [] lpLable; <br>        } <br>#endif <br>        PrintToScreen(szMsgBuffer); <br> <br>        // <br>        // Only if the message is not a falcon message print the body. <br>        // (this is done since in ACK messages there is no message body). <br>        // <br>        if (aVariant[3].bVal == MQMSG_CLASS_NORMAL) <br>        { <br>#ifdef UNICODE <br>            _stprintf(szMsgBuffer, TEXT("\tBody : %s"), (WCHAR *)(aVariant[0].caub.pElems)); <br>#else <br>            { <br>                PCHAR pBody = UnicodeStringToAnsiString((WCHAR *)(aVariant[0].caub.pElems)); <br>                _stprintf(szMsgBuffer, TEXT("\tBody : %s"), pBody); <br>                delete [] pBody; <br>            } <br>#endif <br>            PrintToScreen(szMsgBuffer); <br>        } <br> <br>        _stprintf(szMsgBuffer, TEXT("\tPriority : %d"), aVariant[2].bVal); <br>        PrintToScreen(szMsgBuffer); <br> <br> <br>// <br>// Print Sender ID <br>// <br>        // <br>        // See if we're running on NT or Win95. <br>        // <br>        OSVERSIONINFO OsVerInfo; <br> <br>        OsVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); <br>        GetVersionEx(&amp;OsVerInfo); <br> <br>        if (OsVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) <br>        { <br>            // <br>            //  On NT <br>            // <br>    SID_NAME_USE peUse; <br>    if (LookupAccountSid(NULL, <br>     blobBuffer, <br>     szAccountName, <br>     &amp;dwActNameSize, <br>     szDomainName, <br>     &amp;dwDomNameSize, <br>     &amp;peUse) ) <br>            { <br>                _stprintf(szMsgBuffer, TEXT("\tUser: %s\\%s"), <br>        (WCHAR *)(szDomainName),(WCHAR *)(szAccountName)); <br>        PrintToScreen(szMsgBuffer); <br>            } <br>        } <br>        else <br>        { <br>            // <br>            // LookupAccountSid is not implemented on Win95, <br>            // instead print textual sid <br>            // <br>            if ( GetTextualSid((PSID)blobBuffer, szTextSid, &amp;dwTextSidSize)) <br>            { <br>                _stprintf(szMsgBuffer, TEXT("\tUser SID : %s"), szTextSid); <br>        PrintToScreen(szMsgBuffer); <br>            } <br>        } <br>// <br>// Print "Authenticated" or "Non Authenticated" <br>// <br>if (aVariant[4].bVal) <br>PrintToScreen(TEXT("\tMessage is Authenticated.")); <br>else <br>PrintToScreen(TEXT("\tMessage is Not Authenticated.")); <br> <br> <br>// <br>// Print "Encrypted" or "Non Encrypted" <br>// <br>if (aVariant[6].ulVal) <br>PrintToScreen(TEXT("\tMessage is Encrypted.")); <br>else <br>PrintToScreen(TEXT("\tMessage is Not Encrypted.")); <br>   } <br> <br>   delete aVariant[ iBodyIndex ].caub.pElems ; <br>} <br> <br>/* ************************************************************************ */ <br>/*                               OnApiLocate                                */ <br>/* ************************************************************************ */ <br>/* This function opens a dialog box and ask the user to give a Label. Then  */ <br>/* it locates all the Queues in the DS with a matching label.               */ <br>/* The function updates the PathName Array with those queues.               */ <br>/*                                                                          */ <br>/* Uses: MQLocateBegin, MQLocateNext, MQLocateEnd,                          */ <br>/*       MQInstanceToFormatName, MQFreeMemory.                              */ <br>/* ************************************************************************ */ <br>void CMainFrame::OnApiLocate() <br>{ <br>    // TODO: Add your command handler code here <br>    TCHAR szMsgBuffer[BUFFERSIZE]; <br>    TCHAR szLabelBuffer[BUFFERSIZE]; <br> <br>    HRESULT hr; <br> <br>    MQPROPERTYRESTRICTION PropertyRestriction; <br>    MQRESTRICTION  Restriction; <br>    MQCOLUMNSET    Column; <br>    QUEUEPROPID    aPropId[2]; // only two properties to retrieve. <br>    HANDLE         hEnum; <br>    DWORD       cQueue; <br>    MQPROPVARIANT   aPropVar[MAX_VAR] = {0}; <br>    ARRAYQ*         pArrayQ; <br>    DWORD       i; <br>    DWORD           dwColumnCount = 0; <br>    DWORD dwFormatNameLength = MAX_Q_FORMATNAME_LEN; <br> <br>    CLocateDialog LocateDialog; <br> <br>    // <br>    // Display the ReceiveMessage dialog. <br>    // <br>    if (LocateDialog.DoModal() == IDCANCEL) <br>    { <br>        return; <br>    } <br> <br>    // <br>    // Retrieve the label from the dialog box. <br>    // <br>    LocateDialog.GetLabel(szLabelBuffer); <br> <br>    // <br>    // Clean the PathNameArray before locate. <br>    // <br>    CleanPathNameArray(); <br> <br>    // <br>    // Prepare Parameters to locate a queue. <br>    // <br> <br>    // <br>    // Prepare property restriction. <br>    // Restriction = All queue with PROPID_Q_LABEL equal to "MQ API test". <br>    // <br>    PropertyRestriction.rel = PREQ; <br>    PropertyRestriction.prop = PROPID_Q_LABEL; <br>    PropertyRestriction.prval.vt = VT_LPWSTR; <br>#ifdef UNICODE <br>    PropertyRestriction.prval.pwszVal = szLabelBuffer; <br>#else <br>    DWORD size = _tcslen(szLabelBuffer) +1; <br>    PropertyRestriction.prval.pwszVal = new WCHAR[size]; <br>    AnsiStringToUnicode(PropertyRestriction.prval.pwszVal, szLabelBuffer,size); <br>#endif <br> <br>    // <br>    // prepare a restriction with one property restriction. <br>    // <br>    Restriction.cRes = 1; <br>    Restriction.paPropRes = &amp;PropertyRestriction; <br> <br>    // <br>    // Columset (In other words what property I want to retrieve). <br>    // Only the PathName is important. <br>    // <br>    aPropId[dwColumnCount] = PROPID_Q_PATHNAME; <br>    dwColumnCount++; <br> <br>    aPropId[dwColumnCount] = PROPID_Q_INSTANCE; <br>    dwColumnCount++; <br> <br>    Column.cCol = dwColumnCount; <br>    Column.aCol = aPropId; <br> <br>    // <br>    // Locate the queues. Issue the query <br>    // <br>    hr = MQLocateBegin( <br>            NULL,           //start search at the top. <br>            &amp;Restriction,   //Restriction <br>            &amp;Column,        //ColumnSet <br>            NULL,           //No sort order <br>            &amp;hEnum          //Enumeration Handle <br>            ); <br> <br>    if(FAILED(hr)) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf(szMsgBuffer, <br>            TEXT("MQLocateBegin failed, Error code = 0x%x."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>        return; <br>    } <br> <br>    // <br>    // Get the results. <br>    // <br>    cQueue = MAX_VAR; <br> <br>    // <br>    // If cQueue == 0 it means that no Variants were retrieved in the last MQLocateNext. <br>    // <br>    while (cQueue != 0) <br>    { <br>        hr = MQLocateNext( <br>                hEnum,      // handle returned by MQLocateBegin. <br>                &amp;cQueue,    // size of aPropVar array. <br>                aPropVar    // OUT: an array of MQPROPVARIANT to get the results in. <br>                ); <br> <br>        if(FAILED(hr)) <br>        { <br>            // <br>            // Error - display message <br>            // <br>            _stprintf(szMsgBuffer, <br>                TEXT("MQLocateNext failed, Error code = 0x%x."),hr); <br>            MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>            return; <br>        } <br> <br>        for (i=0; i&lt;cQueue; i++) <br>        { <br>            // <br>            // add the new path names to the path name array. <br>            // <br>            pArrayQ = new ARRAYQ; <br>#ifdef UNICODE <br>            wcsncpy (pArrayQ-&gt;szPathName, aPropVar[i].pwszVal, MAX_Q_PATHNAME_LEN); <br>#else <br>            size_t rc = wcstombs(pArrayQ-&gt;szPathName, aPropVar[i].pwszVal, MAX_Q_PATHNAME_LEN); <br>            ASSERT(rc != (size_t)(-1)); </code></pre>
<p>
</p>
<pre><code>#endif <br>            // <br>            // move to the next property. <br>            // <br>            i = i + 1; <br> <br>            // <br>            // Get the FormatName of the queue and set it in the PathName array. <br>            // <br>#ifdef UNICODE <br>            hr = MQInstanceToFormatName(aPropVar[i].puuid, pArrayQ-&gt;szFormatName, &amp;dwFormatNameLength); <br>#else <br>            WCHAR szwFormatNameBuffer[MAX_Q_FORMATNAME_LEN]; <br>            hr = MQInstanceToFormatName(aPropVar[i].puuid, szwFormatNameBuffer, &amp;dwFormatNameLength); <br>            if (SUCCEEDED(hr)) <br>            { <br>                size_t rwc =wcstombs(pArrayQ-&gt;szFormatName, szwFormatNameBuffer, dwFormatNameLength); <br>                ASSERT(rwc != (size_t)(-1)); <br>            } <br>#endif <br> <br>            if(FAILED(hr)) <br>            { <br>                // <br>                // Error - display message <br>                // <br>                _stprintf (szMsgBuffer, <br>                    TEXT("MQGUIDToFormatName failed, Error code = 0x%x."),hr); <br>                MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>            } <br> <br>            // <br>            // Free the memory allocated by MSMQ <br>            // <br>            MQFreeMemory(aPropVar[i].pwszVal); <br> <br>            // <br>            // Add the new Queue to the PathNameArray. <br>            // <br>            Add2PathNameArray(pArrayQ); <br>        } <br>    } <br> <br>    // <br>    // End the locate operation. <br>    // <br>    hr = MQLocateEnd(hEnum);   // handle returned by MQLocateBegin. <br>    if(FAILED(hr)) <br>    { <br>        // <br>        // Error - display message <br>        // <br>        _stprintf (szMsgBuffer, <br>            TEXT("MQLocateEnd failed, Error code = 0x%x."),hr); <br>        MessageBox(szMsgBuffer, TEXT("ERROR"), MB_OK); <br>        return; <br>    } <br> <br>    // <br>    // Display the Queues found on the locate. <br>    // <br>    _stprintf (szMsgBuffer, TEXT("Locate Operation completed successfully")); <br>    PrintToScreen(szMsgBuffer); <br>    UpdatePathNameArrays(); <br>    DisplayPathNameArray(); <br>    DisplayOpenedQueuePathNameArray(); <br>} <br> <br>/* ************************************************************************ */ <br>/*                           OnUpdateFrameTitle                             */ <br>/* ************************************************************************ */ <br>void CMainFrame::OnUpdateFrameTitle(BOOL bAddToTitle) <br>{ <br>    SetWindowText (TEXT("MQ API test")); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
