<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSMQTEST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4823"></a>MSMQTEST.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright (C) 1996 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>// <br>// Includes <br>// <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br> <br> <br>// <br>// Unique include file for MSMQ apps <br>// <br>#include "mq.h" <br> <br> <br>// <br>// Various defines <br>// <br>#define MAX_VAR       20 <br>#define MAX_FORMAT   100 <br>#define MAX_BUFFER   500 <br> <br> <br>// <br>// GUID created with the tool "GUIDGEN" <br>// <br>static CLSID guidMQTestType = <br>{ 0xc30e0960, 0xa2c0, 0x11cf, { 0x97, 0x85, 0x0, 0x60, 0x8c, 0xb3, 0xe8, 0xc } }; <br> <br> <br>// <br>// Prototypes <br>// <br>void Error(char *s, HRESULT hr); <br>void Syntax(); <br> <br> <br> <br>char mbsMachineName[MAX_COMPUTERNAME_LENGTH + 1]; <br> <br> <br>//----------------------------------------------------- <br>// <br>// Receiver Mode <br>// ------------- <br>// The receiver side does the following: <br>//    1. Creates a public queue on its own machine <br>//       of type "guidMQTestType" <br>//    2. Opens the queue <br>//    3. In a Loop <br>//          Receives messages <br>//          Prints message body and message label <br>//    4. Cleanup handles <br>//    5. Deletes the queue from the directory service <br>// <br>//----------------------------------------------------- <br>void Receiver() <br>{ <br> <br>    MQQUEUEPROPS  qprops; <br>    MQMSGPROPS    msgprops; <br>    MQPROPVARIANT aPropVar[MAX_VAR]; <br>    QUEUEPROPID   aqPropId[MAX_VAR]; <br>    MSGPROPID     amPropId[MAX_VAR]; <br>    DWORD         cProps; <br> <br>    WCHAR         wcsFormat[MAX_FORMAT]; <br> <br>    UCHAR         Buffer[MAX_BUFFER]; <br>    WCHAR         wcsMsgLabel[MQ_MAX_MSG_LABEL_LEN]; <br>    WCHAR         wcsPathName[1000]; <br> <br> <br>    DWORD         dwNumChars; <br>    QUEUEHANDLE   qh; <br> <br>    HRESULT       hr; <br> <br> <br>    printf("\nReceiver Mode on Machine: %s\n\n", mbsMachineName); <br> <br> <br>    // <br>    // Prepare properties to create a queue on local machine <br>    // <br>    cProps = 0; <br> <br>    // Set the PathName <br>    swprintf(wcsPathName, L"%S\\MSMQTest", mbsMachineName); <br>    aqPropId[cProps]         = PROPID_Q_PATHNAME; <br>    aPropVar[cProps].vt      = VT_LPWSTR; <br>    aPropVar[cProps].pwszVal = wcsPathName; <br>    cProps++; <br> <br>    // Set the type of the queue <br>    // (Will be used to locate all the queues of this type) <br>    aqPropId[cProps]         = PROPID_Q_TYPE; <br>    aPropVar[cProps].vt      = VT_CLSID; <br>    aPropVar[cProps].puuid   = &amp;guidMQTestType; <br>    cProps++; <br> <br>    // Put a description to the queue <br>    // (Useful for administration through the MSMQ admin tools) <br>    aqPropId[cProps]         = PROPID_Q_LABEL; <br>    aPropVar[cProps].vt      = VT_LPWSTR; <br>    aPropVar[cProps].pwszVal = L"Sample application of MSMQ SDK"; <br>    cProps++; <br> <br>    // Create a QUEUEPROPS structure <br>    qprops.cProp    = cProps; <br>    qprops.aPropID  = aqPropId; <br>    qprops.aPropVar = aPropVar; <br>    qprops.aStatus  = 0; <br> <br> <br>    // <br>    // Create the queue <br>    // <br>    dwNumChars = MAX_FORMAT; <br>    hr = MQCreateQueue( <br>            NULL,           // IN:     Default security <br>            &amp;qprops,        // IN/OUT: Queue properties <br>            wcsFormat,      // OUT:    Format name (OUT) <br>            &amp;dwNumChars);   // IN/OUT: Size of format name <br> <br>    if (FAILED(hr)) <br>    { <br>        // <br>        // API Fails, not because the queue exists <br>        // <br>        if (hr != MQ_ERROR_QUEUE_EXISTS) <br>            Error("Cannot create queue", hr); <br> <br>        // <br>        // Queue exist, so get its format name <br>        // <br>        printf("Queue already exists. Open it anyway.\n"); <br> <br>        dwNumChars = MAX_FORMAT; <br>        hr = MQPathNameToFormatName( <br>                   wcsPathName,     // IN:     Queue pathname <br>                   wcsFormat,       // OUT:    Format name <br>                   &amp;dwNumChars);    // IN/OUT: Size of format name <br> <br>        if (FAILED(hr)) <br>            Error("Cannot retrieve format name", hr); <br>    } <br> <br> <br>    // <br>    // Open the queue for receive access <br>    // <br>    hr = MQOpenQueue( <br>             wcsFormat,          // IN:  Queue format name <br>             MQ_RECEIVE_ACCESS,  // IN:  Want to receive from queue <br>             0,                  // IN:  Allow sharing <br>             &amp;qh);               // OUT: Handle of open queue <br> <br>    // <br>    // Little bit tricky. MQCreateQueue succeeded but it does not mean <br>    // that MQOpenQueue will, because of replication delay. The queue is <br>    // registered in MQIS, but it might take a replication interval <br>    // until the replica reach the server I am connected to. <br>    // To overcome this, open the queue in a loop. <br>    // <br>    // (in this specific case, this can happen only if this <br>    //  program is run on a Backup Server Controller - BSC, or on <br>    //  a client connected to a BSC) <br>    // To be totally on the safe side, we should have put some code <br>    // to exit the loop after a few retries, but hey, this is just a sample. <br>    // <br>    while (hr == MQ_ERROR_QUEUE_NOT_FOUND) <br>    { <br>       printf("."); <br> <br>       // Wait a bit <br>       Sleep(500); <br> <br>       // And retry <br>       hr = MQOpenQueue(wcsFormat, MQ_RECEIVE_ACCESS, 0, &amp;qh); <br>    } <br> <br>    if (FAILED(hr)) <br>         Error("Cannot open queue", hr); <br> <br> <br>    // <br>    // Main receiver loop <br>    // <br>    printf("\nWaiting for messages...\n"); <br>    while (1) <br>    { <br>        // <br>        // Prepare message properties to read <br>        // <br>        cProps = 0; <br> <br>        // Ask for the body of the message <br>        amPropId[cProps]            = PROPID_M_BODY; <br>        aPropVar[cProps].vt         = VT_UI1 | VT_VECTOR; <br>        aPropVar[cProps].caub.cElems = sizeof(Buffer); <br>        aPropVar[cProps].caub.pElems = Buffer; <br>        cProps++; <br> <br>        // Ask for the label of the message <br>        amPropId[cProps]         = PROPID_M_LABEL; <br>        aPropVar[cProps].vt      = VT_LPWSTR; <br>        aPropVar[cProps].pwszVal = wcsMsgLabel; <br>        cProps++; <br> <br>        // Ask for the length of the label of the message <br>        amPropId[cProps]         = PROPID_M_LABEL_LEN; <br>        aPropVar[cProps].vt      = VT_UI4; <br>        aPropVar[cProps].ulVal   = MQ_MAX_MSG_LABEL_LEN; <br>        cProps++; <br> <br>        // Create a MSGPROPS structure <br>        msgprops.cProp    = cProps; <br>        msgprops.aPropID  = amPropId; <br>        msgprops.aPropVar = aPropVar; <br>        msgprops.aStatus  = 0; <br> <br> <br>        // <br>        // Receive the message <br>        // <br>        hr = MQReceiveMessage( <br>               qh,                // IN:     Queue handle <br>               INFINITE,          // IN:     Timeout <br>               MQ_ACTION_RECEIVE, // IN:     Read operation <br>               &amp;msgprops,         // IN/OUT: Message properties to receive <br>               NULL,              // IN/OUT: No overlap <br>               NULL,              // IN:     No callback <br>               NULL,              // IN:     No cursor <br>               NULL);           // IN:     Not part of a transaction <br> <br>        if (FAILED(hr)) <br>            Error("Receive message", hr); <br> <br>        // <br>        // Display the received message <br>        // <br>        printf("%S : %s\n", wcsMsgLabel, Buffer); <br> <br>        // <br>        // Check for end of app <br>        // <br>        if (stricmp(Buffer, "quit") == 0) <br>            break; <br> <br>    } /* while (1) */ <br> <br>    // <br>    // Cleanup - Close handle to the queue <br>    // <br>    MQCloseQueue(qh); <br> <br> <br>    // <br>    // Finish - Let's delete the queue from the directory service <br>    // (We don't need to do it. Leaving the queue in the DS, enables <br>    //  sender applications to send messages even if the receiver is not <br>    //  available.) <br>    // <br>    hr = MQDeleteQueue(wcsFormat); <br>    if (FAILED(hr)) <br>        Error("Cannot delete queue", hr); <br>} <br> <br> <br>//----------------------------------------------------- <br>// <br>// Sender Mode <br>// ----------- <br>// The sender side does the following: <br>//    1. Locates all queues of type "guidMQTestType" <br>//    2. Opens handles to all the queues <br>//    3. In a loop <br>//          Sends messages to all those queues <br>//    4. Cleanup handles <br>// <br>//----------------------------------------------------- <br>void Sender() <br>{ <br>    DWORD         cProps; <br> <br>    MQMSGPROPS    msgprops; <br>    MQPROPVARIANT aPropVar[MAX_VAR]; <br>    QUEUEPROPID   aqPropId[MAX_VAR]; <br>    MSGPROPID     amPropId[MAX_VAR]; <br> <br>    MQPROPERTYRESTRICTION aPropRestriction[MAX_VAR]; <br>    MQRESTRICTION Restriction; <br> <br>    MQCOLUMNSET      Column; <br>    HANDLE        hEnum; <br> <br>    WCHAR         wcsFormat[MAX_FORMAT]; <br> <br>    UCHAR         Buffer[MAX_BUFFER]; <br>    WCHAR         wcsMsgLabel[MQ_MAX_MSG_LABEL_LEN]; <br> <br>    DWORD         i; <br> <br>    DWORD         cQueue; <br>    DWORD         dwNumChars; <br>    QUEUEHANDLE   aqh[MAX_VAR]; <br> <br>    HRESULT       hr; <br> <br> <br>    printf("\nSender Mode on Machine: %s\n\n", mbsMachineName); <br> <br> <br>    // <br>    // Prepare parameters to locate a queue <br>    // <br> <br>    // <br>    // 1. Restriction = Queues with PROPID_TYPE = MSMQTest queue type <br>    // <br>    cProps = 0; <br>    aPropRestriction[cProps].rel         = PREQ; <br>    aPropRestriction[cProps].prop        = PROPID_Q_TYPE; <br>    aPropRestriction[cProps].prval.vt    = VT_CLSID; <br>    aPropRestriction[cProps].prval.puuid = &amp;guidMQTestType; <br>    cProps++; <br> <br>    Restriction.cRes      = cProps; <br>    Restriction.paPropRes = aPropRestriction; <br> <br> <br>    // <br>    // 2. Columnset (i.e. queue properties to retrieve) = queue instance <br>    // <br>    cProps = 0; <br>    aqPropId[cProps] = PROPID_Q_INSTANCE; <br>    cProps++; <br> <br>    Column.cCol = cProps; <br>    Column.aCol = aqPropId; <br> <br> <br>    // <br>    // Locate the queues. Issue the query <br>    // <br>    hr = MQLocateBegin( <br>             NULL,          // IN:  Context must be NULL <br>             &amp;Restriction,  // IN:  Restriction <br>             &amp;Column,       // IN:  Columns (properties) to return <br>             NULL,          // IN:  No need to sort <br>             &amp;hEnum);       // OUT: Enumeration handle <br> <br>    if (FAILED(hr)) <br>        Error("LocateBegin", hr); <br> <br>    // <br>    // Get the results (up to MAX_VAR) <br>    // (For more results, call MQLocateNext in a loop) <br>    // <br>    cQueue = MAX_VAR; <br>    hr = MQLocateNext( <br>             hEnum,         // IN:     Enumeration handle <br>             &amp;cQueue,       // IN/OUT: Count of properties <br>             aPropVar);     // OUT:    Properties of located queues <br> <br>    if (FAILED(hr)) <br>        Error("LocateNext", hr); <br> <br>    // <br>    // And that's it for locate <br>    // <br>    hr = MQLocateEnd(hEnum); <br> <br>    if (cQueue == 0) <br>    { <br>        // <br>        // Could Not find any queue, so exit <br>        // <br>        printf("No queue registered"); <br>        exit(0); <br>    } <br> <br> <br>    printf("\t%d queue(s) found.\n", cQueue); <br> <br> <br>    // <br>    // Open a handle for each of the queues found <br>    // <br>    for (i = 0; i &lt; cQueue; i++) <br>    { <br>        // Convert the queue instance to a format name <br>        dwNumChars = MAX_FORMAT; <br>        hr = MQInstanceToFormatName( <br>                  aPropVar[i].puuid,    // IN:     Queue instance <br>                  wcsFormat,            // OUT:    Format name <br>                  &amp;dwNumChars);         // IN/OUT: Size of format name <br> <br>        if (FAILED(hr)) <br>            Error("GuidToFormatName", hr); <br> <br>        // <br>        // Open the queue for send access <br>        // <br>        hr = MQOpenQueue( <br>                 wcsFormat,           // IN:  Queue format name <br>                 MQ_SEND_ACCESS,      // IN:  Want to send to queue <br>                 0,                   // IN:  Must be 0 for send access <br>                 &amp;aqh[i]);            // OUT: Handle of open queue <br> <br>        if (FAILED(hr)) <br>            Error("OpenQueue", hr); <br> <br>        // <br>        // Free the GUID memory that was allocated during the locate. <br>        // <br>        MQFreeMemory(aPropVar[i].puuid); <br>    } <br> <br> <br>    printf("\nEnter \"quit\" to exit\n"); <br> <br> <br>    // <br>    // Build the message label property <br>    // <br>    swprintf(wcsMsgLabel, L"Message from %S", mbsMachineName); <br> <br> <br>    // <br>    // Main sender loop <br>    // <br>    while (1) <br>    { <br>        // <br>        // Get a string from the console <br>        // <br>        printf("Enter a string: "); <br>        if (gets(Buffer) == NULL) <br>            break; <br> <br> <br>        // <br>        // Prepare properties of message to send <br>        // <br>        cProps = 0; <br> <br>        // Set the body of the message <br>        amPropId[cProps]            = PROPID_M_BODY; <br>        aPropVar[cProps].vt         = VT_UI1 | VT_VECTOR; <br>        aPropVar[cProps].caub.cElems = sizeof(Buffer); <br>        aPropVar[cProps].caub.pElems = Buffer; <br>        cProps++; <br> <br>        // Set the label of the message <br>        amPropId[cProps]            = PROPID_M_LABEL; <br>        aPropVar[cProps].vt         = VT_LPWSTR; <br>        aPropVar[cProps].pwszVal    = wcsMsgLabel; <br>        cProps++; <br> <br>        // Create a MSGPROPS structure <br>        msgprops.cProp    = cProps; <br>        msgprops.aPropID  = amPropId; <br>        msgprops.aPropVar = aPropVar; <br>        msgprops.aStatus  = 0; <br> <br> <br>        // <br>        // Send the message to all the queue <br>        // <br>        for (i = 0; i &lt; cQueue; i++) <br>        { <br>            hr = MQSendMessage( <br>                    aqh[i],     // IN: Queue handle <br>                    &amp;msgprops,  // IN: Message properties to send <br>                    NULL);      // IN: Not part of a transaction <br> <br>            if (FAILED(hr)) <br>                Error("Send message", hr); <br>        } <br> <br>        // <br>        // Check for end of app <br>        // <br>        if (stricmp(Buffer, "quit") == 0) <br>            break; <br> <br>    } /* while (1) */ <br> <br> <br>    // <br>    // Close all the queue handles <br>    // <br>    for (i = 0; i &lt; cQueue; i++) <br>        MQCloseQueue(aqh[i]); <br> <br>} <br> <br> <br>//----------------------------------------------------- <br>// <br>//  MAIN <br>// <br>//----------------------------------------------------- <br>main(int argc, char * * argv) <br>{ <br>    DWORD dwNumChars; <br> <br> <br>    if (argc != 2) <br>        Syntax(); <br> <br> <br>    // <br>    // Retrieve machine name <br>    // <br>    dwNumChars = MAX_COMPUTERNAME_LENGTH + 1; <br>    GetComputerName(mbsMachineName, &amp;dwNumChars); <br> <br> <br>    if (strcmp(argv[1], "-s") == 0) <br>        Sender(); <br> <br>    else if (strcmp(argv[1], "-r") == 0) <br>        Receiver(); <br> <br>    else <br>        Syntax(); <br> <br> <br>    printf("\nOK\n"); <br> <br> <br>    return(1); <br>} <br> <br> <br>void Error(char *s, HRESULT hr) <br>{ <br>    printf("Error: %s (0x%X)\n", s, hr); <br>    exit(1); <br>} <br> <br> <br>void Syntax() <br>{ <br>    printf("\n"); <br>    printf("Syntax: msmqtest -s | -r\n"); <br>    printf("\t-s: Sender\n"); <br>    printf("\t-r: Receiver\n"); <br>    exit(1); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
