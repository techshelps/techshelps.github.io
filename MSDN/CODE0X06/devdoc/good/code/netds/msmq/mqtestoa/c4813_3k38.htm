<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MQTESTOA.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4814"></a>MQTESTOA.CPP</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright (C) 1996 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>// <br>// Includes <br>// <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br> <br>// <br>// Unique include file for ActiveX MSMQ apps <br>// <br>#include "mqoai.h" <br> <br>// <br>// Various defines <br>// <br>#define MAX_VAR       20 <br>#define MAX_BUFFER   500 <br> <br> <br>// <br>// GUID created with the tool "GUIDGEN" <br>// <br>static WCHAR strGuidMQTestType[] = <br>  L"{c30e0960-a2c0-11cf-9785-00608cb3e80c}"; <br>// <br>// Prototypes <br>// <br>void PrintError(char *s, HRESULT hr); <br>HRESULT Syntax(); <br> <br>char mbsMachineName[MAX_COMPUTERNAME_LENGTH + 1]; <br> <br>// Some useful macros <br>#define RELEASE(punk) if (punk) { (punk)-&gt;Release(); (punk) = NULL; } <br>#define ADDREF(punk) ((punk) ? (punk)-&gt;AddRef() : 0) <br>#define PRINTERROR(s, hr) { PrintError(s, hr); goto Cleanup; } <br> <br> <br>//----------------------------------------------------- <br>// <br>// Receiver Mode <br>// ------------- <br>// The receiver side does the following: <br>//    1. Creates a public queue on its own machine <br>//       of type "strGuidMQTestType" <br>//    2. Opens the queue <br>//    3. In a Loop <br>//          Receives messages <br>//          Prints message body and message label <br>//    4. Cleanup handles <br>//    5. Deletes the queue from the directory service <br>// <br>//----------------------------------------------------- <br>HRESULT Receiver() <br>{ <br>    IMSMQMessage *pmessageReceive = NULL; <br>    IMSMQQueue *pqReceive = NULL; <br>    IMSMQQueueInfo  *pqinfo = NULL; <br>    BSTR bstrPathName = NULL; <br>    BSTR bstrServiceType = NULL; <br>    BSTR bstrLabel = NULL; <br>    BSTR bstrMsgLabel = NULL; <br>    VARIANT varIsTransactional, varIsWorldReadable, varBody, varBody2, varWantDestQueue, varWantBody, varReceiveTimeout; <br>    WCHAR wcsPathName[1000]; <br>    BOOL fQuit = FALSE; <br>    HRESULT hresult = NOERROR; <br> <br>    printf("\nReceiver Mode on Machine: %s\n\n", mbsMachineName); <br> <br>    // <br>    // Create MSMQQueueInfo object <br>    // <br>    hresult = CoCreateInstance( <br>                   CLSID_MSMQQueueInfo, <br>                   NULL,      // punkOuter <br>                   CLSCTX_SERVER, <br>                   IID_IMSMQQueueInfo, <br>                   (LPVOID *)&amp;pqinfo); <br>    if (FAILED(hresult)) { <br>      PRINTERROR("Cannot create queue", hresult); <br>    } <br> <br>    // <br>    // Prepare properties to create a queue on local machine <br>    // <br> <br>    // Set the PathName <br>    swprintf(wcsPathName, L"%S\\MSMQTest", mbsMachineName); <br>    bstrPathName = SysAllocString(wcsPathName); <br>    if (bstrPathName == NULL) { <br>      PRINTERROR("OOM: pathname", E_OUTOFMEMORY); <br>    } <br>    pqinfo-&gt;put_PathName(bstrPathName); <br> <br>    // <br>    // Set the type of the queue <br>    // (Will be used to locate all the queues of this type) <br>    // <br>    bstrServiceType = SysAllocString(strGuidMQTestType); <br>    if (bstrServiceType == NULL) { <br>      PRINTERROR("OOM: ServiceType", E_OUTOFMEMORY); <br>    } <br>    pqinfo-&gt;put_ServiceTypeGuid(bstrServiceType); <br> <br>    // <br>    // Put a description to the queue <br>    // (Useful for administration through the MSMQ admin tools) <br>    // <br>    bstrLabel = <br>      SysAllocString(L"Sample ActiveX application of MSMQ SDK"); <br>    if (bstrLabel == NULL) { <br>      PRINTERROR("OOM: label ", E_OUTOFMEMORY); <br>    } <br>    pqinfo-&gt;put_Label(bstrLabel); <br> <br>    // <br>    // specify if transactional <br>    // <br>    VariantInit(&amp;varIsTransactional); <br>    varIsTransactional.vt = VT_BOOL; <br>    varIsTransactional.boolVal = MQ_TRANSACTIONAL_NONE; <br>    VariantInit(&amp;varIsWorldReadable); <br>    varIsWorldReadable.vt = VT_BOOL; <br>    varIsWorldReadable.boolVal = FALSE; <br>    // <br>    // create the queue <br>    // <br>    hresult = pqinfo-&gt;Create(&amp;varIsTransactional, &amp;varIsWorldReadable); <br>    if (FAILED(hresult)) { <br>      // <br>      // API Fails, not because the queue exists <br>      // <br>      if (hresult != MQ_ERROR_QUEUE_EXISTS) { <br>        PRINTERROR("Cannot create queue", hresult); <br>      } <br>    } <br> <br>    // <br>    // Open the queue for receive access <br>    // <br>    hresult = pqinfo-&gt;Open(MQ_RECEIVE_ACCESS, <br>                           MQ_DENY_NONE, <br>                           &amp;pqReceive); <br> <br>    // <br>    // Little bit tricky. MQCreateQueue succeeded but it does not mean <br>    // that MQOpenQueue will, because of replication delay. The queue is <br>    // registered in MQIS, but it might take a replication interval <br>    // until the replica reach the server I am connected to. <br>    // To overcome this, open the queue in a loop. <br>    // <br>    // (in this specific case, this can happen only if this <br>    //  program is run on a Backup Server Controller - BSC, or on <br>    //  a client connected to a BSC) <br>    // To be totally on the safe side, we should have put some code <br>    // to exit the loop after a few retries, but hey, this is just a sample. <br>    // <br>    while (hresult == MQ_ERROR_QUEUE_NOT_FOUND) { <br>      printf("."); <br> <br>      // Wait a bit <br>      Sleep(500); <br> <br>      // And retry <br>      hresult = pqinfo-&gt;Open(MQ_RECEIVE_ACCESS, <br>                             MQ_DENY_NONE, <br>                             &amp;pqReceive); <br>    } <br>    if (FAILED(hresult)) { <br>      PRINTERROR("Cannot open queue", hresult); <br>    } <br> <br>    // <br>    // Main receiver loop <br>    // <br>    printf("\nWaiting for messages...\n"); <br>    while (!fQuit) { <br>      // <br>      // Receive the message <br>      // <br>      VariantInit(&amp;varWantDestQueue); <br>      VariantInit(&amp;varWantBody); <br>      VariantInit(&amp;varReceiveTimeout); <br>      varWantDestQueue.vt = VT_BOOL; <br>      varWantDestQueue.boolVal = TRUE;    // yes we want the dest queue <br>      varWantBody.vt = VT_BOOL; <br>      varWantBody.boolVal = TRUE;         // yes we want the msg body <br>      varReceiveTimeout.vt = VT_I4; <br>      varReceiveTimeout.lVal = INFINITE;  // infinite timeout <br>      hresult = pqReceive-&gt;Receive( <br>                  NULL, <br>                  &amp;varWantDestQueue, <br>                  &amp;varWantBody, <br>                  &amp;varReceiveTimeout, <br>                  &amp;pmessageReceive); <br>      if (FAILED(hresult)) { <br>        PRINTERROR("Receive message", hresult); <br>      } <br> <br>      // <br>      // Display the received message <br>      // <br>      pmessageReceive-&gt;get_Label(&amp;bstrMsgLabel); <br>      VariantInit(&amp;varBody); <br>      VariantInit(&amp;varBody2); <br>      hresult = pmessageReceive-&gt;get_Body(&amp;varBody); <br>      if (FAILED(hresult)) { <br>        PRINTERROR("can't get body", hresult); <br>      } <br>      hresult = VariantChangeType(&amp;varBody2, <br>                                  &amp;varBody, <br>                                  0, <br>                                  VT_BSTR); <br>      if (FAILED(hresult)) { <br>        PRINTERROR("can't convert message to string.", hresult); <br>      } <br>      printf("%S : %s\n", bstrMsgLabel, V_BSTR(&amp;varBody2)); <br>      // <br>      // Check for end of app <br>      // <br>      if (stricmp((char *)V_BSTR(&amp;varBody2), "quit") == 0) { <br>        fQuit = TRUE; <br>      } <br> <br>      VariantClear(&amp;varBody); <br>      VariantClear(&amp;varBody2); <br> <br>      // <br>      // release the current message <br>      // <br>      RELEASE(pmessageReceive); <br>    } /* while (1) */ <br> <br>    // <br>    // Cleanup - Close handle to the queue <br>    // <br>    pqReceive-&gt;Close(); <br>    if (FAILED(hresult)) { <br>      PRINTERROR("Cannot close queue", hresult); <br>    } <br> <br>    // <br>    // Finish - Let's delete the queue from the directory service <br>    // (We don't need to do it. Leaving the queue in the DS, enables <br>    //  sender applications to send messages even if the receiver is not <br>    //  available.) <br>    // <br>    hresult = pqinfo-&gt;Delete(); <br>    if (FAILED(hresult)) { <br>      PRINTERROR("Cannot delete queue", hresult); <br>    } <br>    // fall through... <br> <br>Cleanup: <br>    SysFreeString(bstrPathName); <br>    SysFreeString(bstrMsgLabel); <br>    SysFreeString(bstrServiceType); <br>    SysFreeString(bstrLabel); <br>    RELEASE(pmessageReceive); <br>    RELEASE(pqReceive); <br>    RELEASE(pqinfo); <br>    return hresult; <br>} <br> <br> <br>//----------------------------------------------------- <br>// <br>// Sender Mode <br>// ----------- <br>// The sender side does the following: <br>//    1. Locates all queues of type "guidMQTestType" <br>//    2. Opens handles to all the queues <br>//    3. In a loop <br>//          Sends messages to all those queues <br>//    4. Cleanup handles <br>// <br>//----------------------------------------------------- <br>HRESULT Sender() <br>{ <br>    IMSMQQuery *pquery = NULL; <br>    IMSMQQueueInfo *rgpqinfo[MAX_VAR]; <br>    IMSMQQueue *rgpqSend[MAX_VAR]; <br>    IMSMQQueueInfo *pqinfo = NULL; <br>    IMSMQQueueInfos *pqinfos = NULL; <br>    IMSMQMessage *pmessage = NULL; <br>    char *szBuffer = new char[MAX_BUFFER]; <br>    WCHAR wcsMsgLabel[MQ_MAX_MSG_LABEL_LEN]; <br>    BSTR bstrServiceType = NULL; <br>    BSTR bstrLabel = NULL; <br>    BSTR bstrBody = NULL; <br>    VARIANT varBody; <br>    DWORD i; <br>    DWORD cQueue = 0; <br>    HRESULT hresult = NOERROR; <br> <br>    printf("\nSender Mode on Machine: %s\n\n", mbsMachineName); <br> <br>    // <br>    // create query object for lookup <br>    // <br>    hresult = CoCreateInstance( <br>                   CLSID_MSMQQuery, <br>                   NULL,      // punkOuter <br>                   CLSCTX_SERVER, <br>                   IID_IMSMQQuery, <br>                   (LPVOID *)&amp;pquery); <br>    if (FAILED(hresult)) { <br>      PRINTERROR("Cannot create query", hresult); <br>    } <br> <br>    // <br>    // Prepare parameters to locate a queue: all queues that <br>    //  match test guid type <br>    // <br>    VARIANT varGuidQueue; <br>    VARIANT varStrLabel; <br>    VARIANT varGuidServiceType; <br>    VARIANT varRelServiceType; <br>    VARIANT varRelLabel; <br>    VARIANT varCreateTime; <br>    VARIANT varModifyTime; <br>    VARIANT varRelCreateTime; <br>    VARIANT varRelModifyTime; <br> <br>    VariantInit(&amp;varGuidQueue); <br>    VariantInit(&amp;varStrLabel); <br>    VariantInit(&amp;varGuidServiceType); <br>    VariantInit(&amp;varRelServiceType); <br>    VariantInit(&amp;varRelLabel); <br>    VariantInit(&amp;varCreateTime); <br>    VariantInit(&amp;varModifyTime); <br>    VariantInit(&amp;varRelCreateTime); <br>    VariantInit(&amp;varRelModifyTime); <br> <br>    // <br>    // We only want to specify service type so we set <br>    //  the other variant params to VT_ERROR to simulate <br>    //  "missing", i.e. optional, params. <br>    // <br>    V_VT(&amp;varGuidQueue) = VT_ERROR; <br>    V_VT(&amp;varStrLabel) = VT_ERROR; <br>    V_VT(&amp;varRelServiceType) = VT_ERROR; <br>    V_VT(&amp;varRelLabel) = VT_ERROR; <br>    V_VT(&amp;varCreateTime) = VT_ERROR; <br>    V_VT(&amp;varModifyTime) = VT_ERROR; <br>    V_VT(&amp;varRelCreateTime) = VT_ERROR; <br>    V_VT(&amp;varRelModifyTime) = VT_ERROR; <br>    bstrServiceType = SysAllocString(strGuidMQTestType); <br>    if (bstrServiceType == NULL) { <br>      PRINTERROR("OOM: Service Type", E_OUTOFMEMORY); <br>    } <br>    V_VT(&amp;varGuidServiceType) = VT_BSTR; <br>    V_BSTR(&amp;varGuidServiceType) = bstrServiceType; <br> <br>    hresult = pquery-&gt;LookupQueue(&amp;varGuidQueue, <br>                                  &amp;varGuidServiceType, <br>                                  &amp;varStrLabel, <br>                                  &amp;varCreateTime, <br>                                  &amp;varModifyTime, <br>                                  &amp;varRelServiceType, <br>                                  &amp;varRelLabel, <br>                                  &amp;varRelCreateTime, <br>                                  &amp;varRelModifyTime, <br>                                  &amp;pqinfos); <br>    if (FAILED(hresult)) { <br>      PRINTERROR("LookupQueue failed", hresult); <br>    } <br> <br>    // <br>    // reset the queue collection <br>    // <br>    hresult = pqinfos-&gt;Reset(); <br>    if (FAILED(hresult)) { <br>      PRINTERROR("Reset failed", hresult); <br>    } <br> <br>    // <br>    // Open each of the queues found <br>    // <br>    i = 0; <br>    hresult = pqinfos-&gt;Next(&amp;rgpqinfo[i]); <br>    if (FAILED(hresult)) { <br>      PRINTERROR("Next failed", hresult); <br>    } <br>    pqinfo = rgpqinfo[i]; <br>    while (pqinfo) { <br>      // <br>      // Open the queue for send access <br>      // <br>      hresult = pqinfo-&gt;Open( <br>                  MQ_SEND_ACCESS, <br>                  MQ_DENY_NONE, <br>                  &amp;rgpqSend[i]); <br>      if (FAILED(hresult)) { <br>        PRINTERROR("Open failed", hresult); <br>      } <br>      i++; <br>      hresult = pqinfos-&gt;Next(&amp;rgpqinfo[i]); <br>      if (FAILED(hresult)) { <br>        PRINTERROR("Next failed", hresult); <br>      } <br>      pqinfo = rgpqinfo[i]; <br>    } <br>    cQueue = i; <br>    if (cQueue == 0) { <br>      // <br>      // Could Not find any queue, so exit <br>      // <br>      PRINTERROR("No queue registered", hresult = E_INVALIDARG); <br>    } <br>    printf("\t%d queue(s) found.\n", cQueue); <br>    printf("\nEnter \"quit\" to exit\n"); <br> <br> <br>    // <br>    // Build the message label property <br>    // <br>    swprintf(wcsMsgLabel, L"Message from %S", mbsMachineName); <br> <br> <br>    // <br>    // Main sender loop <br>    // <br>    while (1) { <br>      // <br>      // Get a string from the console <br>      // <br>      printf("Enter a string: "); <br>      if (gets(szBuffer) == NULL) <br>        break; <br> <br> <br>      // <br>      // create a message object <br>      // <br>      hresult = CoCreateInstance( <br>                     CLSID_MSMQMessage, <br>                     NULL,      // punkOuter <br>                     CLSCTX_SERVER, <br>                     IID_IMSMQMessage, <br>                     (LPVOID *)&amp;pmessage); <br>      // <br>      // Send the message to all the queues <br>      // <br>      for (i = 0; i &lt; cQueue; i++) { <br>        bstrLabel = SysAllocString(wcsMsgLabel); <br>        if (bstrLabel == NULL) { <br>          PRINTERROR("OOM: label", E_OUTOFMEMORY); <br>        } <br>        hresult = pmessage-&gt;put_Label(bstrLabel); <br> <br>        // <br>        // This isn't a "true" unicode string of course... <br>        // <br>        bstrBody = SysAllocStringByteLen(szBuffer, strlen(szBuffer)+1); <br>        if (bstrBody == NULL) { <br>          PRINTERROR("OOM: body", E_OUTOFMEMORY); <br>        } <br>        VariantInit(&amp;varBody); <br>        V_VT(&amp;varBody) = VT_BSTR; <br>        V_BSTR(&amp;varBody) = bstrBody; <br>        hresult = pmessage-&gt;put_Body(varBody); <br>        if (FAILED(hresult)) { <br>          PRINTERROR("put_body failed", hresult); <br>        } <br>        hresult = pmessage-&gt;Send(rgpqSend[i], NULL); <br>        if (FAILED(hresult)) { <br>          PRINTERROR("Send failed", hresult); <br>        } <br>        VariantClear(&amp;varBody); <br>        bstrBody = NULL; <br>      } <br>      RELEASE(pmessage); <br> <br>      // <br>      // Check for end of app <br>      // <br>      if (stricmp(szBuffer, "quit") == 0) <br>        break; <br>    } /* while (1) */ <br> <br> <br> <br>Cleanup: <br>    // <br>    // Close and release all the queues <br>    // <br>    for (i = 0; i &lt; cQueue; i++) { <br>      rgpqSend[i]-&gt;Close(); <br>      rgpqSend[i]-&gt;Release(); <br>      rgpqinfo[i]-&gt;Release(); <br>    } <br>    RELEASE(pqinfos); <br>    RELEASE(pquery); <br>    RELEASE(pmessage); <br>    SysFreeString(bstrLabel); <br>    SysFreeString(bstrBody); <br>    SysFreeString(bstrServiceType); <br>    delete [] szBuffer; <br>    return hresult; <br>} <br> <br> <br>//----------------------------------------------------- <br>// <br>//  MAIN <br>// <br>//----------------------------------------------------- <br>int main(int argc, char * * argv) <br>{ <br>    DWORD dwNumChars; <br>    HRESULT hresult = NOERROR; <br> <br>    if (argc != 2) <br>      return Syntax(); <br> <br>    hresult = OleInitialize(NULL); <br>    if (FAILED(hresult)) { <br>      PRINTERROR("Cannot init OLE", hresult); <br>    } <br> <br> <br>    // <br>    // Retrieve machine name <br>    // <br>    dwNumChars = MAX_COMPUTERNAME_LENGTH + 1; <br>    GetComputerNameA(mbsMachineName, &amp;dwNumChars); <br> <br> <br>    if (strcmp(argv[1], "-s") == 0) <br>      hresult = Sender(); <br> <br>    else if (strcmp(argv[1], "-r") == 0) <br>      hresult = Receiver(); <br> <br>    else <br>      hresult = Syntax(); <br> <br>    printf("\nOK\n"); <br> <br>    // fall through... <br> <br> <br>Cleanup: <br>    return (int)hresult; <br>} <br> <br> <br>void PrintError(char *s, HRESULT hr) <br>{ <br>    printf("Cleanup: %s (0x%X)\n", s, hr); <br>} <br> <br> <br>HRESULT Syntax() <br>{ <br>    printf("\n"); <br>    printf("Syntax: mqtestoa -s | -r\n"); <br>    printf("\t-s: Sender\n"); <br>    printf("\t-r: Receiver\n"); <br>    return E_INVALIDARG; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
