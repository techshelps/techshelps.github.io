<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERMAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4822"></a>PERMAIN.CPP</h2>
<pre><code>#define UNICODE <br>#define _UNICODE <br> <br>#define DBNTWIN32 <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;rpc.h&gt; <br>#include "cs.h" <br> <br>#define DllExport __declspec( dllexport ) <br>#define PERF_QUEUE_OBJECT   TEXT("MSMQ Queue") <br> <br>typedef PERF_DATA_BLOCK             PERF_DATA,      *PPERF_DATA; <br>typedef PERF_OBJECT_TYPE            PERF_OBJECT,    *PPERF_OBJECT; <br>typedef PERF_INSTANCE_DEFINITION    PERF_INSTANCE,  *PPERF_INSTANCE; <br>typedef PERF_COUNTER_DEFINITION     PERF_COUNTER,   *PPERF_COUNTER; <br> <br>LPWSTR* aszTitleArray;   // Array of pointers to title strings <br>DWORD dwLastCounter=0; <br>WCHAR wcsObjectID[32]; <br>WCHAR wcsInstanceName[100]; <br>DWORD   dwObjectIndex;    // Holds the the entry of the object in the title array <br>CCriticalSection g_critRegistry; <br> <br> <br>//********************************************************************* <br>// <br>//  CounterData <br>// <br>//      Returns counter data for an object instance.  If pInst or pCount <br>//      is NULL then NULL is returne. <br>// <br>PVOID CounterData (PPERF_INSTANCE pInst, PPERF_COUNTER pCount) <br>{ <br>PPERF_COUNTER_BLOCK pCounterBlock; <br> <br>    if (pCount &amp;&amp; pInst) <br>        { <br>        pCounterBlock = (PPERF_COUNTER_BLOCK)((PCHAR)pInst + pInst-&gt;ByteLength); <br>        return (PVOID)((PCHAR)pCounterBlock + pCount-&gt;CounterOffset); <br>        } <br>    else <br>        return NULL; <br>} <br> <br>//********************************************************************* <br>// <br>//  FirstCounter <br>// <br>//      Find the first counter in pObject. <br>// <br>//      Returns a pointer to the first counter.  If pObject is NULL <br>//      then NULL is returned. <br>// <br>PPERF_COUNTER FirstCounter (PPERF_OBJECT pObject) <br>{ <br>    if (pObject) <br>        return (PPERF_COUNTER)((PCHAR) pObject + pObject-&gt;HeaderLength); <br>    else <br>        return NULL; <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//  NextCounter <br>// <br>//      Find the next counter of pCounter. <br>// <br>//      If pCounter is the last counter of an object type, bogus data <br>//      maybe returned.  The caller should do the checking. <br>// <br>//      Returns a pointer to a counter.  If pCounter is NULL then <br>//      NULL is returned. <br>// <br>PPERF_COUNTER NextCounter (PPERF_COUNTER pCounter) <br>{ <br>    if (pCounter) <br>        return (PPERF_COUNTER)((PCHAR) pCounter + pCounter-&gt;ByteLength); <br>    else <br>        return NULL; <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//  FirstInstance <br>// <br>//      Returns pointer to the first instance of pObject type. <br>//      If pObject is NULL then NULL is returned. <br>// <br>PPERF_INSTANCE   FirstInstance (PPERF_OBJECT pObject) <br>{ <br>    if (pObject) <br>        return (PPERF_INSTANCE)((PCHAR) pObject + pObject-&gt;DefinitionLength); <br>    else <br>        return NULL; <br>} <br> <br> <br>//********************************************************************* <br>// <br>//  NextInstance <br>// <br>//      Returns pointer to the next instance following pInst. <br>// <br>//      If pInst is the last instance, bogus data maybe returned. <br>//      The caller should do the checking. <br>// <br>//      If pInst is NULL, then NULL is returned. <br>// <br>PPERF_INSTANCE   NextInstance (PPERF_INSTANCE pInst) <br>{ <br>PERF_COUNTER_BLOCK *pCounterBlock; <br> <br>    if (pInst) <br>        { <br>        pCounterBlock = (PERF_COUNTER_BLOCK *)((PCHAR) pInst + pInst-&gt;ByteLength); <br>        return (PPERF_INSTANCE)((PCHAR) pCounterBlock + pCounterBlock-&gt;ByteLength); <br>        } <br>    else <br>        return NULL; <br>} <br> <br> <br> <br>//********************************************************************* <br>// <br>//  InstanceName <br>// <br>//      Returns the name of the pInst. <br>// <br>//      If pInst is NULL then NULL is returned. <br>// <br>LPTSTR  InstanceName (PPERF_INSTANCE pInst) <br>{ <br>    if (pInst) <br>        return (LPTSTR) ((PCHAR) pInst + pInst-&gt;NameOffset); <br>    else <br>        return NULL; <br>} <br> <br> <br> <br>BOOL GetPerformanceData(PPERF_DATA      pPerfData, <br>                        PPERF_OBJECT    pObject, <br>                        LPWSTR* aszTitleArray, <br>                        LPWSTR lpcsInstanceName, <br>                        DWORD *pdwMsgInQueue) <br>{ <br>        <br>    PPERF_INSTANCE  pInstance = NULL; <br> <br>    *pdwMsgInQueue = 0; <br> <br>    pInstance = FirstInstance (pObject); <br>    for (int i=0;i&lt;pObject-&gt;NumInstances;i++) <br>    { <br> <br>        LPWSTR lpwcsInstanceName = InstanceName(pInstance); <br>        if (wcsicmp(lpcsInstanceName, lpwcsInstanceName) == 0) <br>        { <br>            break; <br>        } <br> <br>        pInstance = NextInstance(pInstance); <br>    } <br> <br>    if (i==pObject-&gt;NumInstances) <br>    { <br>        return FALSE; <br>    } <br>     <br>    PPERF_COUNTER pCounter; <br>    pCounter = FirstCounter (pObject); <br>    LPWSTR lpwcsNameTitle; <br> <br>    for (DWORD Index =0; Index &lt; pObject-&gt;NumCounters; Index++) <br>    { <br>        lpwcsNameTitle = aszTitleArray[pCounter-&gt;CounterNameTitleIndex]; <br>        if (wcscmp(L"Messages in Queue", lpwcsNameTitle)) <br>        { <br>            pCounter = NextCounter (pCounter); <br>            continue; <br>        } <br> <br> <br>        DWORD dwCounterValue; <br>     <br>        // <br>        // update counters value <br>        // <br> <br>        if (pInstance) <br>        { <br>            dwCounterValue = *(DWORD *)CounterData(pInstance,pCounter); <br>        } <br>        else <br>        { <br>            return FALSE; <br>        } <br> <br>        *pdwMsgInQueue = dwCounterValue; <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br>//********************************************************************* <br>// <br>//  FirstObject <br>// <br>//      Returns pointer to the first object in pData. <br>//      If pData is NULL then NULL is returned. <br>// <br>PPERF_OBJECT FirstObject (PPERF_DATA pData) <br>{ <br>    if (pData) <br>        return ((PPERF_OBJECT) ((PBYTE) pData + pData-&gt;HeaderLength)); <br>    else <br>        return NULL; <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//  NextObject <br>// <br>//      Returns pointer to the next object following pObject. <br>// <br>//      If pObject is the last object, bogus data maybe returned. <br>//      The caller should do the checking. <br>// <br>//      If pObject is NULL, then NULL is returned. <br>// <br>PPERF_OBJECT NextObject (PPERF_OBJECT pObject) <br>{ <br>    if (pObject) <br>        return ((PPERF_OBJECT) ((PBYTE) pObject + pObject-&gt;TotalByteLength)); <br>    else <br>        return NULL; <br>} <br> <br> <br>//********************************************************************* <br>// <br>//  FindObject <br>// <br>//      Returns pointer to object with TitleIndex.  If not found, NULL <br>//      is returned. <br>// <br>PPERF_OBJECT FindObject (PPERF_DATA pData, DWORD TitleIndex) <br>{ <br>PPERF_OBJECT pObject; <br>DWORD        i = 0; <br> <br>    if (pObject = FirstObject (pData)) <br>        while (i &lt; pData-&gt;NumObjectTypes) <br>            { <br>            if (pObject-&gt;ObjectNameTitleIndex == TitleIndex) <br>                return pObject; <br> <br>            pObject = NextObject (pObject); <br>            i++; <br>            } <br> <br>    return NULL; <br>} <br> <br>//********************************************************************* <br>// <br>//  GetPerfData <br>// <br>//      Get a new set of performance data. <br>// <br>//      *ppData should be NULL initially. <br>//      This function will allocate a buffer big enough to hold the <br>//      data requested by szObjectIndex. <br>// <br>//      *pDataSize specifies the initial buffer size.  If the size is <br>//      too small, the function will increase it until it is big enough <br>//      then return the size through *pDataSize.  Caller should <br>//      deallocate *ppData if it is no longer being used. <br>// <br>//      Returns ERROR_SUCCESS if no error occurs. <br>// <br>//      Note: the trial and error loop is quite different from the normal <br>//            registry operation.  Normally if the buffer is too small, <br>//            RegQueryValueEx returns the required size.  In this case, <br>//            the perflib, since the data is dynamic, a buffer big enough <br>//            for the moment may not be enough for the next. Therefor, <br>//            the required size is not returned. <br>// <br>//            One should start with a resonable size to avoid the overhead <br>//            of reallocation of memory. <br>// <br>DWORD <br>GetPerfData( <br>    HKEY hPerfKey, <br>    LPTSTR szObjectIndex, <br>    PPERF_DATA* ppData, <br>    DWORD* pDataSize <br>    ) <br>{ <br>    DWORD   DataSize; <br>    DWORD   dwR; <br>    DWORD   Type; <br> <br>   *ppData = NULL; <br>    do  { <br>        DataSize = *pDataSize; <br>        dwR = RegQueryValueEx (hPerfKey, <br>                               szObjectIndex, <br>                               NULL, <br>                               &amp;Type, <br>                               (BYTE*) *ppData, <br>                               &amp;DataSize); <br> <br> <br>        if (dwR == ERROR_MORE_DATA) <br>        { <br>            *pDataSize += 1024; <br>            LocalFree (*ppData); <br>            *ppData = (PPERF_DATA) LocalAlloc (LMEM_FIXED, *pDataSize); <br>        } <br> <br>        if (!*ppData) <br>        { <br>            LocalFree (*ppData); <br>            return ERROR_NOT_ENOUGH_MEMORY; <br>        } <br> <br>        } while (dwR == ERROR_MORE_DATA); <br> <br>    return dwR; <br>} <br> <br>//********************************************************************* <br>// <br>//      RefreshPerfData <br>// <br>//  Get a new set of performance data.  pData should be NULL initially. <br>// <br>PPERF_DATA RefreshPerfData (HKEY        hPerfKey, <br>                            LPTSTR      szObjectIndex, <br>                            PPERF_DATA  pData, <br>                            DWORD       *pDataSize) <br>{ <br>    if (GetPerfData (hPerfKey, szObjectIndex, &amp;pData, pDataSize) == ERROR_SUCCESS) <br>        return pData; <br>    else <br>        return NULL; <br>} <br>//********************************************************************* <br>// <br>//  GetPerfTitleSz <br>// <br>//      Retrieves the performance data title strings. <br>// <br>//   This call retrieves english version of the title strings. <br>// <br>//   For NT 3.1, the counter names are stored in the "Counters" value <br>//   in the ...\perflib\009 key.  For 3.5 and later, the 009 key is no <br>//      longer used.  The counter names should be retrieved from "Counter 009" <br>//      value of HKEY_PERFORMANCE_KEY. <br>// <br>//      Caller should provide two pointers, one for buffering the title <br>//      strings the other for indexing the title strings.  This function will <br>//      allocate memory for the TitleBuffer and TitleSz.  To get the title <br>//      string for a particular title index one would just index the TitleSz. <br>//      *TitleLastIdx returns the highest index can be used.  If TitleSz[N] is <br>//      NULL then there is no Title for index N. <br>// <br>//      Example:  TitleSz[20] points to titile string for title index 20. <br>// <br>//      When done with the TitleSz, caller should LocalFree(*TitleBuffer). <br>// <br>//      This function returns ERROR_SUCCESS if no error. <br>// <br>DWORD   GetPerfTitleSz (HKEY    hKeyMachine, <br>                        HKEY    hKeyPerf, <br>                        LPWSTR  *TitleBuffer, <br>                        LPWSTR  *TitleSz[], <br>                        DWORD   *TitleLastIdx) <br>{ <br>HKEYhKey1; <br>HKEY    hKey2; <br>DWORD   Type; <br>DWORD   DataSize; <br>DWORD   dwR; <br>DWORD   Len; <br>DWORD   Index; <br>DWORD   dwTemp; <br>BOOL    bNT10; <br>LPWSTR  szCounterValueName; <br>LPWSTR  szTitle; <br> <br>    // Initialize <br>    // <br>    hKey1        = NULL; <br>    hKey2        = NULL; <br>    *TitleBuffer = NULL; <br>    *TitleSz     = NULL; <br> <br> <br> <br> <br>    // Open the perflib key to find out the last counter's index and system version. <br>    // <br>    dwR = RegOpenKeyEx (hKeyMachine, <br>                        TEXT("software\\microsoft\\windows nt\\currentversion\\perflib"), <br>                        0, <br>                        KEY_READ, <br>                        &amp;hKey1); <br>    if (dwR != ERROR_SUCCESS) <br>        goto done; <br> <br> <br> <br>    // Get the last counter's index so we know how much memory to allocate for TitleSz <br>    // <br>    DataSize = sizeof (DWORD); <br>    dwR = RegQueryValueEx (hKey1, TEXT("Last Counter"), 0, &amp;Type, (LPBYTE)TitleLastIdx, &amp;DataSize); <br>    if (dwR != ERROR_SUCCESS) <br>        goto done; <br> <br> <br> <br>    // Find system version, for system earlier than 1.0a, there's no version value. <br>    // <br>    dwR = RegQueryValueEx (hKey1, TEXT("Version"), 0, &amp;Type, (LPBYTE)&amp;dwTemp, &amp;DataSize); <br> <br>    if (dwR != ERROR_SUCCESS) <br>        // unable to read the value, assume NT 1.0 <br>        bNT10 = TRUE; <br>    else <br>        // found the value, so, NT 1.0a or later <br>        bNT10 = FALSE; <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>    // Now, get ready for the counter names and indexes. <br>    // <br>    if (bNT10) <br>        { <br>        // NT 1.0, so make hKey2 point to ...\perflib\009 and get <br>        //  the counters from value "Counters" <br>        // <br>        szCounterValueName = TEXT("Counters"); <br>        dwR = RegOpenKeyEx (hKeyMachine, <br>                            TEXT("software\\microsoft\\windows nt\\currentversion\\perflib\\009"), <br>                            0, <br>                            KEY_READ, <br>                            &amp;hKey2); <br>        if (dwR != ERROR_SUCCESS) <br>            goto done; <br>        } <br>    else <br>        { <br>        // NT 1.0a or later.  Get the counters in key HKEY_PERFORMANCE_KEY <br>        //  and from value "Counter 009" <br>        // <br>        szCounterValueName = TEXT("Counter 009"); <br>        hKey2 = hKeyPerf; <br>        } <br> <br> <br> <br> <br> <br>    // Find out the size of the data. <br>    // <br>    dwR = RegQueryValueEx (hKey2, szCounterValueName, 0, &amp;Type, 0, &amp;DataSize); <br>    if (dwR != ERROR_SUCCESS) <br>        goto done; <br> <br> <br> <br>    // Allocate memory <br>    // <br>    *TitleBuffer = (LPTSTR)LocalAlloc (LMEM_FIXED, DataSize); <br>    if (!*TitleBuffer) <br>        { <br>        dwR = ERROR_NOT_ENOUGH_MEMORY; <br>        goto done; <br>        } <br> <br>    *TitleSz = (LPTSTR *)LocalAlloc (LPTR, (*TitleLastIdx+1) * sizeof (LPTSTR)); <br>    if (!*TitleSz) <br>        { <br>        dwR = ERROR_NOT_ENOUGH_MEMORY; <br>        goto done; <br>        } <br> <br> <br> <br> <br> <br>    // Query the data <br>    // <br>    dwR = RegQueryValueEx (hKey2, szCounterValueName, 0, &amp;Type, (BYTE *)*TitleBuffer, &amp;DataSize); <br>    if (dwR != ERROR_SUCCESS) <br>        goto done; <br> <br> <br> <br> <br>    // Setup the TitleSz array of pointers to point to beginning of each title string. <br>    // TitleBuffer is type REG_MULTI_SZ. <br>    // <br>    szTitle = *TitleBuffer; <br> <br>    while (Len = lstrlen (szTitle)) <br>        { <br>        Index = _wtoi (szTitle); <br> <br>        szTitle = szTitle + Len +1; <br> <br>        if (Index &lt;= *TitleLastIdx) <br>            (*TitleSz)[Index] = szTitle; <br> <br>        szTitle = szTitle + lstrlen (szTitle) +1; <br>        } <br> <br> <br> <br>done: <br> <br>    // Done. Now cleanup! <br>    // <br>    if (dwR != ERROR_SUCCESS) <br>        { <br>        // There was an error, free the allocated memory <br>        // <br>        if (*TitleBuffer) LocalFree (*TitleBuffer); <br>        if (*TitleSz)     LocalFree (*TitleSz); <br>        } <br> <br>    // Close the hKeys. <br>    // <br>    if (hKey1) RegCloseKey (hKey1); <br>    if (hKey2 &amp;&amp; hKey2 != hKeyPerf) RegCloseKey (hKey2); <br> <br> <br> <br>    return dwR; <br> <br>} <br> <br> <br>DWORD <br>WINAPI <br>GetPerfmonInfo(LPCSTR lpwcsInstanceName) <br>{ <br>    DWORD dwR = 0; <br>    DWORD Index; <br>    static fFirst = TRUE; <br>    LPWSTR sTitleBuffer;      // Buffer which holds title strings <br>    DWORD dwMsgInQueue; <br>    WCHAR wcsInstanceName[100]; <br> <br>    swprintf(wcsInstanceName,L"%S", lpwcsInstanceName);  <br> <br> <br>    if (fFirst) <br>    { <br>        dwR = GetPerfTitleSz (HKEY_LOCAL_MACHINE,  <br>                              HKEY_PERFORMANCE_DATA, <br>                              &amp;sTitleBuffer,  <br>                              &amp;aszTitleArray,  <br>                              &amp;dwLastCounter); <br> <br>        if (FAILED(dwR)) <br>        { <br>            return 0; <br>        } <br>        fFirst = FALSE; <br>        // <br>        // Initiate the objects Index <br>        // <br>        dwObjectIndex = (DWORD)-1; <br> <br>        for (Index = 0; Index &lt;= dwLastCounter; Index++) <br>        { <br>            if (aszTitleArray[Index] &amp;&amp; <br>                (lstrcmpi (aszTitleArray[Index], PERF_QUEUE_OBJECT) == 0)) <br>            { <br>                dwObjectIndex = Index; <br>            } <br>        } <br> <br>        if ((DWORD)-1 == dwObjectIndex) <br>        { <br>            return 0; <br>        } <br> <br>        swprintf(wcsObjectID,L"%ld", dwObjectIndex); <br>    } <br>    // <br>    // Get the number of counters the object has <br>    //  <br>    PPERF_OBJECT    pObject; <br>    PPERF_DATA      pPerfData; <br>    DWORD dwPerfDataSize = 0; <br> <br>    pPerfData = RefreshPerfData (HKEY_PERFORMANCE_DATA, wcsObjectID, pPerfData, &amp;dwPerfDataSize); <br> <br>    pObject= FindObject (pPerfData, dwObjectIndex); <br>    if (pObject == NULL) <br>    {  <br>        return 0; <br>    } <br> <br> <br>    GetPerformanceData(pPerfData,pObject,aszTitleArray, wcsInstanceName,&amp;dwMsgInQueue); <br>    LocalFree (pPerfData); <br>    return dwMsgInQueue; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
