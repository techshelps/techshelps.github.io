<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRAWDLG.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context4726"></a>DRAWDLG.CPP</h2>
<pre><code>// drawdlg.cpp : implementation file <br>// <br> <br>#include "stdafx.h" <br>#include "disdraw.h" <br>#include "drawdlg.h" <br> <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>#define MAX_FORMAT_NAME_LEN 256 <br> <br>// <br>// Distributed draw queue type <br>// <br>CLSID guidDrawType = <br>{ 0x151ceac0, 0xacb5, 0x11cf, { 0x8b, 0x51, 0x00, 0x20, 0xaf, 0x92, 0x95, 0x46 } }; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDisdrawDlg dialog <br> <br>CDisdrawDlg::CDisdrawDlg(CWnd* pParent /*=NULL*/) <br>: CDialog(CDisdrawDlg::IDD, pParent) <br>{ <br>//{{AFX_DATA_INIT(CDisdrawDlg) <br>m_strFriend = _T(""); <br>m_iDelivery = 0; <br>//}}AFX_DATA_INIT <br>// Note that LoadIcon does not require a subsequent DestroyIcon in Win32 <br>m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); <br>} <br> <br>void CDisdrawDlg::DoDataExchange(CDataExchange* pDX) <br>{ <br>CDialog::DoDataExchange(pDX); <br>//{{AFX_DATA_MAP(CDisdrawDlg) <br>DDX_Control(pDX, IDC_DRAWAREA_SCRIBLLE, m_drawScribble); <br>DDX_Control(pDX, IDC_BUTTON_ATTACH, m_btnAttach); <br>DDX_Text(pDX, IDC_EDIT_FRIEND, m_strFriend); <br>DDX_Radio(pDX, IDC_RADIO_EXPRESS, m_iDelivery); <br>//}}AFX_DATA_MAP <br>} <br> <br>BEGIN_MESSAGE_MAP(CDisdrawDlg, CDialog) <br>//{{AFX_MSG_MAP(CDisdrawDlg) <br>ON_WM_PAINT() <br>ON_WM_QUERYDRAGICON() <br>ON_BN_CLICKED(IDC_BUTTON_ATTACH, OnButtonAttach) <br>ON_EN_CHANGE(IDC_EDIT_FRIEND, OnChangeEditFriend) <br>ON_WM_CLOSE() <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CDisdrawDlg message handlers <br> <br> <br>BOOL LocateQueue(CString m_strLabel, WCHAR *wcsFormatName, DWORD dwNumChars) <br>{ <br>// <br>// Set restrictions to locate the draw queue with the specified label <br>// <br>DWORD cProps = 0; <br>MQPROPERTYRESTRICTION aPropRestriction[2]; <br>MQRESTRICTION Restriction; <br> <br>aPropRestriction[cProps].rel           = PREQ; <br>aPropRestriction[cProps].prop          = PROPID_Q_TYPE; <br>aPropRestriction[cProps].prval.vt      = VT_CLSID; <br>aPropRestriction[cProps].prval.puuid   = &amp;guidDrawType; <br>cProps++; <br> <br>WCHAR wcsLabel[MQ_MAX_Q_LABEL_LEN]; <br>mbstowcs(wcsLabel, m_strLabel, MQ_MAX_Q_LABEL_LEN); <br>aPropRestriction[cProps].rel           = PREQ; <br>aPropRestriction[cProps].prop          = PROPID_Q_LABEL; <br>aPropRestriction[cProps].prval.vt      = VT_LPWSTR; <br>aPropRestriction[cProps].prval.pwszVal = wcsLabel; <br>cProps++; <br> <br>Restriction.cRes = cProps; <br>Restriction.paPropRes = aPropRestriction; <br> <br> <br>// <br>// Request the queue instance for the specified queue <br>// <br>cProps = 0; <br>QUEUEPROPID aPropId[1]; <br>MQCOLUMNSET Column; <br> <br>aPropId[cProps] = PROPID_Q_INSTANCE; <br>cProps++; <br> <br>Column.cCol = cProps; <br>Column.aCol = aPropId; <br> <br> <br>// <br>// Locate the specified queue <br>// <br>HANDLE hEnum; <br>BOOL fFound = FALSE; <br>HRESULT hr = MQLocateBegin(NULL, &amp;Restriction, &amp;Column, NULL, &amp;hEnum); <br>if (!FAILED(hr)) <br>{ <br>    MQPROPVARIANT aPropVar[1]; <br>DWORD cQueue = 1; <br>hr = MQLocateNext(hEnum, &amp;cQueue, aPropVar); <br>if (!FAILED(hr) &amp;&amp; cQueue &gt; 0) <br>{ <br>// <br>// Obtain the format name for the located queue <br>// <br>hr = MQInstanceToFormatName(aPropVar[0].puuid, wcsFormatName, &amp;dwNumChars); <br>            MQFreeMemory(aPropVar[0].puuid); <br>if (!FAILED(hr)) <br>fFound = TRUE; <br>} <br> <br>MQLocateEnd(hEnum); <br>} <br> <br> <br>    return fFound; <br>} <br> <br> <br>BOOL CDisdrawDlg::OpenReceiveQueue() <br>{ <br>    // <br>    // Do not create the receiving queue if it already exists in the enterprise <br>    // <br>    HRESULT hr; <br>WCHAR wcsFormatName[MAX_FORMAT_NAME_LEN]; <br>    if (!LocateQueue(m_strLogin, wcsFormatName, MAX_FORMAT_NAME_LEN)) <br>    { <br>    // <br>    // Form the pathname to the receiving queue <br>    // <br>    char mbsPathName[MQ_MAX_Q_NAME_LEN]; <br>    DWORD dwNumChars = MQ_MAX_Q_NAME_LEN; <br>    GetComputerName(mbsPathName, &amp;dwNumChars); <br>strcat(mbsPathName, "\\"); <br>strcat(mbsPathName, m_strLogin); <br> <br> <br>    // <br>    // Prepare the receiving queue properties <br>    // <br>    DWORD cProps = 0; <br>    QUEUEPROPID  aPropId[3]; <br>    MQPROPVARIANT aPropVar[3]; <br>    MQQUEUEPROPS propsQueue; <br>     <br>WCHAR wcsPathName[MQ_MAX_Q_NAME_LEN]; <br>mbstowcs(wcsPathName, mbsPathName, MQ_MAX_Q_NAME_LEN); <br>    aPropId[cProps] = PROPID_Q_PATHNAME; <br>    aPropVar[cProps].vt = VT_LPWSTR; <br>    aPropVar[cProps].pwszVal = wcsPathName; <br>    cProps++; <br> <br>    aPropId[cProps] = PROPID_Q_TYPE; <br>    aPropVar[cProps].vt = VT_CLSID; <br>    aPropVar[cProps].puuid = &amp;guidDrawType; <br>    cProps++; <br> <br>WCHAR wcsLabel[MQ_MAX_Q_LABEL_LEN]; <br>mbstowcs(wcsLabel, m_strLogin, MQ_MAX_Q_LABEL_LEN); <br>    aPropId[cProps] = PROPID_Q_LABEL; <br>    aPropVar[cProps].vt = VT_LPWSTR; <br>    aPropVar[cProps].pwszVal = wcsLabel; <br>    cProps++; <br> <br>    propsQueue.cProp= cProps; <br>    propsQueue.aPropID= aPropId; <br>    propsQueue.aPropVar = aPropVar; <br>    propsQueue.aStatus= NULL; <br> <br> <br>    // <br>    // Create the receiving queue <br>    // <br>    dwNumChars = MAX_FORMAT_NAME_LEN; <br>    hr = MQCreateQueue(NULL, &amp;propsQueue, wcsFormatName, &amp;dwNumChars); <br> <br> <br>    // <br>    // If the receiving queue already exists, obtain its format name <br>    // <br>    if (hr == MQ_ERROR_QUEUE_EXISTS) <br>    hr = MQPathNameToFormatName(wcsPathName, wcsFormatName, &amp;dwNumChars); <br> <br>    if (FAILED(hr)) <br>    return FALSE; <br>    } <br> <br>// <br>// Open the receiving queue (may need to retry due to replication latency) <br>// <br>while ((hr = MQOpenQueue(wcsFormatName,  <br>                             MQ_RECEIVE_ACCESS,  <br>                             0, &amp;m_hqIncoming)) == MQ_ERROR_QUEUE_NOT_FOUND) <br>Sleep (500); <br> <br>if (FAILED(hr)) <br>return FALSE; <br> <br> <br>return TRUE; <br>} <br> <br> <br>DWORD ReceiveUpdates(CDisdrawDlg *pDrawDlg) <br>{ <br>   // <br>// Prepare the message properties to receive <br>// <br>DWORD cProps = 0; <br>MQMSGPROPS    propsMessage; <br>MQPROPVARIANT aPropVar[2]; <br>MSGPROPID     aPropId[2]; <br> <br>WCHAR wcsBody[MAX_MSG_BODY_LEN]; <br>aPropId[cProps]= PROPID_M_BODY; <br>aPropVar[cProps].vt= VT_UI1 | VT_VECTOR; <br>aPropVar[cProps].caub.cElems = sizeof(wcsBody); <br>aPropVar[cProps].caub.pElems = (UCHAR *)wcsBody; <br>cProps++; <br> <br>    aPropId[cProps]= PROPID_M_BODY_SIZE; <br>aPropVar[cProps].vt= VT_UI4; <br>cProps++; <br> <br>propsMessage.cProp    = cProps; <br>propsMessage.aPropID  = aPropId; <br>propsMessage.aPropVar = aPropVar; <br>propsMessage.aStatus  = NULL; <br> <br> <br>    // <br>    // Keep receiving updates sent to the incoming queue <br>    // <br>    HRESULT hr; <br>    LINE line; <br>char mbsBody[MAX_MSG_BODY_LEN + 1]; <br> <br>    while (TRUE) <br>    { <br>        // <br>        // Synchronously receive a message from the incoming queue <br>        // <br>        hr = MQReceiveMessage(pDrawDlg-&gt;m_hqIncoming, INFINITE,  <br>                              MQ_ACTION_RECEIVE, &amp;propsMessage,  <br>  NULL, NULL, NULL, NULL); <br> <br>// <br>// Determine if the message contains a keystroke or a line <br>// <br>        if (!FAILED(hr)) <br>        { <br>// <br>// Convert the body to a multi-byte null-terminated string  <br>// <br>            UINT uNumChars = aPropVar[1].ulVal/sizeof(WCHAR); <br>wcstombs(mbsBody, wcsBody, uNumChars); <br>mbsBody[uNumChars] = '\0'; <br> <br>// <br>// Add the keystroke to the drawing <br>// <br>if (uNumChars == 1) <br>            { <br>pDrawDlg-&gt;m_drawScribble.AddKeystroke(mbsBody); <br>            } <br> <br>// <br>// Add the received line to the drawing <br>// <br>else <br>{ <br>        sscanf(mbsBody, "%07ld%07ld%07ld%07ld",  <br>   &amp;line.ptStart.x, &amp;line.ptStart.y,  <br>   &amp;line.ptEnd.x, &amp;line.ptEnd.y); <br>pDrawDlg-&gt;m_drawScribble.AddLine(line); <br>} <br>        } <br>    } <br> <br> <br>    return 0; <br>} <br> <br> <br>BOOL CDisdrawDlg::OnInitDialog() <br>{ <br>CDialog::OnInitDialog(); <br> <br>// Set the icon for this dialog.  The framework does this automatically <br>//  when the application's main window is not a dialog <br>SetIcon(m_hIcon, TRUE);// Set big icon <br>SetIcon(m_hIcon, FALSE);// Set small icon <br> <br>// TODO: Add extra initialization here <br> <br>// <br>// Display the login name in the window title <br>// <br>SetWindowText(m_strLogin); <br> <br> <br>// <br>// No queues are open yet <br>// <br>m_hqIncoming = NULL; <br>m_hqOutgoing = NULL; <br> <br> <br>// <br>// Open the receiving queue and receive incoming messages <br>// <br>    DWORD dwThreadID; <br>    if (OpenReceiveQueue()) <br>        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ReceiveUpdates, this, 0, <br>                     &amp;dwThreadID); <br>else <br>AfxMessageBox("Cannot open receiving queue."); <br> <br> <br>return TRUE;  // return TRUE  unless you set the focus to a control <br>} <br> <br> <br>// If you add a minimize button to your dialog, you will need the code below <br>//  to draw the icon.  For MFC applications using the document/view model, <br>//  this is automatically done for you by the framework. <br> <br>void CDisdrawDlg::OnPaint()  <br>{ <br>if (IsIconic()) <br>{ <br>CPaintDC dc(this); // device context for painting <br> <br>SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); <br> <br>// Center icon in client rectangle <br>int cxIcon = GetSystemMetrics(SM_CXICON); <br>int cyIcon = GetSystemMetrics(SM_CYICON); <br>CRect rect; <br>GetClientRect(&amp;rect); <br>int x = (rect.Width() - cxIcon + 1) / 2; <br>int y = (rect.Height() - cyIcon + 1) / 2; <br> <br>// Draw the icon <br>dc.DrawIcon(x, y, m_hIcon); <br>} <br>else <br>{ <br>CDialog::OnPaint(); <br>} <br>} <br> <br> <br>// The system calls this to obtain the cursor to display while the user drags <br>//  the minimized window. <br>HCURSOR CDisdrawDlg::OnQueryDragIcon() <br>{ <br>return (HCURSOR) m_hIcon; <br>} <br> <br> <br>void CDisdrawDlg::SendKeystroke(UINT uChar) <br>{ <br>// <br>// Send the keystroke to the friend, if any <br>// <br>if (m_hqOutgoing != NULL) <br>{ <br>// <br>// Prepare the message properties to send <br>// <br>DWORD cProps = 0; <br>MQMSGPROPS    propsMessage; <br>MQPROPVARIANT aPropVar[5]; <br>MSGPROPID     aPropId[5]; <br> <br>WCHAR wcsBody[1]; <br>swprintf(wcsBody, L"%c", uChar);  <br>aPropId[cProps]= PROPID_M_BODY; <br>aPropVar[cProps].vt= VT_UI1 | VT_VECTOR; <br>aPropVar[cProps].caub.cElems = sizeof(wcsBody); <br>aPropVar[cProps].caub.pElems = (UCHAR *)wcsBody; <br>cProps++; <br> <br>WCHAR wcsLabel[MQ_MAX_MSG_LABEL_LEN]; <br>swprintf(wcsLabel, L"Key: %c", uChar); <br>aPropId[cProps]= PROPID_M_LABEL; <br>aPropVar[cProps].vt= VT_LPWSTR; <br>aPropVar[cProps].pwszVal= wcsLabel; <br>cProps++; <br> <br>        UpdateData(TRUE); <br>aPropId[cProps]= PROPID_M_DELIVERY; <br>aPropVar[cProps].vt= VT_UI1; <br>aPropVar[cProps].bVal= m_iDelivery; <br>cProps++; <br> <br>aPropId[cProps]= PROPID_M_PRIORITY; <br>aPropVar[cProps].vt= VT_UI1; <br>aPropVar[cProps].bVal= 4; <br>cProps++; <br> <br>aPropId[cProps]= PROPID_M_BODY_TYPE; <br>aPropVar[cProps].vt= VT_UI4; <br>aPropVar[cProps].lVal= (long)VT_BSTR; <br>cProps++; <br> <br>propsMessage.cProp    = cProps; <br>propsMessage.aPropID  = aPropId; <br>propsMessage.aPropVar = aPropVar; <br>propsMessage.aStatus  = NULL; <br> <br> <br>// <br>// Send the message to the outgoing queue <br>// <br>MQSendMessage(m_hqOutgoing, &amp;propsMessage, NULL); <br>} <br>} <br> <br> <br>void CDisdrawDlg::SendMouseMovement(LINE line) <br>{ <br>// <br>// Send the line to the friend, if any <br>// <br>if (m_hqOutgoing != NULL) <br>{ <br>// <br>// Prepare the message properties to send <br>// <br>DWORD cProps = 0; <br>MQMSGPROPS    propsMessage; <br>MQPROPVARIANT aPropVar[5]; <br>MSGPROPID     aPropId[5]; <br> <br>WCHAR wcsBody[MAX_MSG_BODY_LEN]; <br>swprintf(wcsBody, L"%07ld%07ld%07ld%07ld",  <br> line.ptStart.x, line.ptStart.y, line.ptEnd.x, line.ptEnd.y); <br>aPropId[cProps]= PROPID_M_BODY; <br>aPropVar[cProps].vt= VT_UI1 | VT_VECTOR; <br>aPropVar[cProps].caub.cElems = sizeof(wcsBody); <br>aPropVar[cProps].caub.pElems = (UCHAR *)wcsBody; <br>cProps++; <br> <br>WCHAR wcsLabel[MQ_MAX_MSG_LABEL_LEN]; <br>swprintf(wcsLabel, L"%ld,%ld To %ld,%ld",  <br> line.ptStart.x, line.ptStart.y, line.ptEnd.x, line.ptEnd.y); <br>aPropId[cProps]= PROPID_M_LABEL; <br>aPropVar[cProps].vt= VT_LPWSTR; <br>aPropVar[cProps].pwszVal= wcsLabel; <br>cProps++; <br> <br>        UpdateData(TRUE); <br>aPropId[cProps]= PROPID_M_DELIVERY; <br>aPropVar[cProps].vt= VT_UI1; <br>aPropVar[cProps].bVal= m_iDelivery; <br>cProps++; <br> <br>aPropId[cProps]= PROPID_M_PRIORITY; <br>aPropVar[cProps].vt= VT_UI1; <br>aPropVar[cProps].bVal= 3; <br>cProps++; <br> <br>aPropId[cProps]= PROPID_M_BODY_TYPE; <br>aPropVar[cProps].vt= VT_UI4; <br>aPropVar[cProps].lVal= (long)VT_BSTR; <br>cProps++; <br> <br>propsMessage.cProp    = cProps; <br>propsMessage.aPropID  = aPropId; <br>propsMessage.aPropVar = aPropVar; <br>propsMessage.aStatus  = NULL; <br> <br> <br>// <br>// Send the message to the outgoing queue <br>// <br>MQSendMessage(m_hqOutgoing, &amp;propsMessage, NULL); <br>} <br>} <br> <br> <br>void CDisdrawDlg::OnButtonAttach()  <br>{ <br>// TODO: Add your control notification handler code here <br> <br>// <br>// Obtain the name of the friend <br>// <br>UpdateData(TRUE); <br>m_strFriend.MakeUpper(); <br> <br> <br>    // <br>    // Make sure the friend queue exists <br>    // <br>    WCHAR wcsFormatName[MAX_FORMAT_NAME_LEN]; <br>if (!LocateQueue(m_strFriend, wcsFormatName, MAX_FORMAT_NAME_LEN)) <br>{ <br>AfxMessageBox("No such friend, sorry..."); <br>return; <br>} <br> <br> <br>// <br>// Open the friend queue for sending <br>// <br>HANDLE hqNewFriend; <br>HRESULT hr = MQOpenQueue(wcsFormatName, MQ_SEND_ACCESS, 0, &amp;hqNewFriend); <br>if (FAILED(hr)) <br>AfxMessageBox("Cannot open friend queue."); <br> <br>else <br>{ <br>// <br>// Close the previous friend and update the window title <br>// <br>if (m_hqOutgoing != NULL) <br>MQCloseQueue(m_hqOutgoing); <br>m_hqOutgoing = hqNewFriend; <br>CString strTitle = m_strLogin + " connected to " + m_strFriend; <br>SetWindowText(strTitle); <br>m_btnAttach.EnableWindow(FALSE); <br>} <br>} <br> <br> <br>void CDisdrawDlg::OnChangeEditFriend()  <br>{ <br>// TODO: Add your control notification handler code here <br> <br>m_btnAttach.EnableWindow(TRUE); <br>} <br> <br> <br>void CDisdrawDlg::OnClose()  <br>{ <br>// TODO: Add your message handler code here and/or call default <br> <br>// <br>// Close the open queues, if any <br>// <br>if (m_hqIncoming != NULL) <br>MQCloseQueue(m_hqIncoming); <br> <br>if (m_hqOutgoing != NULL) <br>MQCloseQueue(m_hqOutgoing); <br> <br>CDialog::OnClose(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
